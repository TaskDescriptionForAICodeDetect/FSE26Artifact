[
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <tuple>\nusing namespace std;\ntypedef pair<int,int> P;//to, cov\nvector<P> E[2000];\nbool used[2000];\n\nint n,k,s,S,ans;\n\nvoid dfs(int st, int v, int len, int sur){\n    used[v]=true;\n    // cout<<v<<' '<<len<<endl;\n    if(len==k) ans = min(ans,sur);\n    for(auto p:E[v]){\n        int to, cov;\n        tie(to,cov)=p;\n        if(to==st&&len==k){\n            ans = min(ans, sur-cov);\n        }else if(len<k&&!used[to]){\n            dfs(st,to,len+1,sur+S-cov);\n        }\n    }\n    used[v]=false;\n}\n\nint main(){\n    while(cin>>n>>k>>s,n){\n        vector<int> X,Y,Z;\n        for(int i=0;i<2000;i++) E[i].clear();\n        S=s*s*6;\n        ans = 1000000000;\n        for(int i=0;i<n;i++){\n            int x,y,z;\n            cin>>x>>y>>z;\n            X.push_back(x);\n            Y.push_back(y);\n            Z.push_back(z);\n        }\n        for(int i=0;i<n;i++){\n            for(int j=0;j<n;j++){\n                if(i!=j){\n                    int dx = abs(X[i]-X[j]);\n                    int dy = abs(Y[i]-Y[j]);\n                    int dz = abs(Z[i]-Z[j]);\n                    if(dx<s&&dy<s&&dz<s){\n                        // cout<<i<<' '<<j<<':'<<dx<<' '<<dy<<' '<<dz<<endl;\n                        int cov=((s-dx)*(s-dy)+(s-dy)*(s-dz)+(s-dz)*(s-dx))*2;\n                        E[i].emplace_back(j,cov);\n                    }\n                }\n            }\n        }\n        for(int i=0;i<n;i++){\n            dfs(i,i,1,S);\n        }\n        if(ans==1000000000)ans=-1;\n        cout<<ans<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <math.h>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <bitset>\n#include <algorithm>\nusing namespace std;\n\nstruct xyz_t {\n    int x;\n    int y;\n    int z;\n    double length;       //一乗\n};\n\nstruct first_t {\n    int sec;\n    long long w;\n};\n\nbool asc(const xyz_t& left,const xyz_t& right);\nint next(int p,int q);\nint root(int p);\nvoid unite(int p,int q);\nint same(int p,int q);\nvoid pr(vector<vector<int> > pri);\nvoid nnn();\n\nvector<xyz_t> a;\nvector<int> tree;\nvector<int> endd;\nvector<vector<int> > tree_f;\nvector<vector<int> > kaburi;\nvector<vector<int> > tree_r;\nvector<int> num;\nvector<int> flg;\nlong long ans;\nint n,k,s;\ndouble LE;\nlong long sum;\nint rr;\n\nint main(){\n  scanf (\"%d %d %d\",&n,&k,&s);\n  while(n){\n    ans=0;\n    LE=sqrt(s*s*3.0);\n    xyz_t aaa={0,0,0,0};\n    a.assign(n,aaa);\n    tree.assign(n,-1);\n    endd.assign(n,-1);\n    tree_f.assign(n,vector<int>(1,0));\n    kaburi.assign(n,vector<int>(n,0));\n    tree_r.assign(n,vector<int>(0,0));\n    num.assign(n,1);\n    flg.assign(n,0);\n    for(int t=0;t<n;t++){\n      scanf (\"%d %d %d\",&a[t].x,&a[t].y,&a[t].z);\n      a[t].length=sqrt(a[t].x*a[t].x*1.0+a[t].y*a[t].y*1.0+a[t].z*a[t].z*1.0);\n    }\n    sort(a.begin(),a.end(),asc);\n    for(int i=0;i<n;i++){\n      tree[i]=i;\n      endd[i]=i;\n    }\n\n    switch(k){\n      case 1:\n        printf(\"%d\\n\",s*s*6);\n        break;\n      case 3:\n        for(int t=0;t<n-1;++t){\n          for(int s=t+1;(a[s].length<a[t].length+LE&&s<n);++s){\n            int xx=next(a[t].x,a[s].x);\n            int yy=next(a[t].y,a[s].y);\n            int zz=next(a[t].z,a[s].z);\n            if(xx&&yy&&zz){\n              if(same(t,s)==0){\n                int ee;\n                int eee;\n                  if(tree[t]==t&&tree[s]==s){\n                    //printf(\"%d %d\\n\",endd[t],endd[s]);\n                    ee=num[tree[t]];\n                    eee=num[tree[s]];\n                    num[tree[t]]=0;\n                    num[tree[s]]=0;\n                    num[endd[t]]=ee+eee;\n                    tree[t]=endd[t];\n                    tree[endd[t]]=endd[t];\n                    endd[endd[t]]=endd[s];\n                    unite(s,t);\n                  }\n                  else if(tree[t]!=t&&tree[s]==s){\n                    num[tree[t]]=num[tree[t]]+num[s];\n                    num[tree[s]]=0;\n                    endd[tree[t]]=endd[s];\n                    unite(s,t);\n                    //printf(\"%d\\n\",tree[t]);\n                  }\n                  else if(tree[t]==t&&tree[s]!=s){\n                    num[tree[s]]=num[t]+num[tree[s]];\n                    num[tree[t]]=0;\n                    endd[tree[s]]=endd[t];\n                    unite(t,s);\n                    //printf(\"%d\\n\",tree[s]);\n                  }\n                  else if(tree[t]!=t&&tree[s]!=s){\n                    num[tree[t]]=num[tree[t]]+num[tree[s]];\n                    num[tree[s]]=0;\n                    endd[tree[t]]=tree[s];\n                    unite(s,t);\n                    //printf(\"%d %d %d %d\\n\",t,s,tree[t],endd[tree[t]]);\n                  }\n                kaburi[s][t]=xx*yy+yy*zz+zz*xx;\n                  kaburi[t][s]=kaburi[s][t];\n                  tree_r[t].push_back(s);\n                  tree_r[s].push_back(t);\n                  //printf(\"%d %d %d\\n\",kaburi[q].back());\n                  //printf(\"%d %d %d\\n\",xx,yy,zz);\n                }\n              else{\n                kaburi[s][t]=xx*yy+yy*zz+zz*xx;\n                kaburi[t][s]=kaburi[s][t];\n                tree_r[t].push_back(s);\n                tree_r[s].push_back(t);\n                flg[tree[t]]=1;\n              }\n            }\n          }\n        }\n        //pr(kaburi);\n        for(int t=0;t<n;++t){\n          sum=0;\n          if(num[t]>=k){\n            if(flg[t]==0){\n              int u=t;\n              int uu=t;\n              tree_f[t][0]=t;\n              for(int r=0;r<k-1;++r){\n                rr=0;\n                if(tree_r[u][rr]==uu){\n                  ++rr;\n                }\n                sum+=kaburi[u][tree_r[u][rr]];\n                tree_f[t].push_back(tree_r[u][rr]);\n                uu=u;\n                u=tree_r[u][rr];\n              }\n              for(int r=k-1;r<num[t]-1;++r){\n                rr=0;\n                if(tree_r[u][rr]==uu){\n                  ++rr;\n                }\n                tree_f[t].push_back(tree_r[u][rr]);\n                uu=u;\n                u=tree_r[u][rr];\n              }\n              if(ans<sum){\n                ans=sum;\n              }\n              for(int r=0;r+k<num[t];++r){\n                sum=sum-kaburi[tree_f[t][r]][tree_f[t][r+1]]+kaburi[tree_f[t][r+k-1]][tree_f[t][r+k]];\n                if(ans<sum){\n                  ans=sum;\n                }\n              }\n            }\n            else{\n              if(num[t]!=k){\n                int u=t;\n                int uu=t;\n                tree_f[t][0]=t;\n                for(int r=0;r<k-1;++r){\n                  rr=0;\n                  if(tree_r[u][rr]==uu){\n                    ++rr;\n                  }\n                  sum+=kaburi[u][tree_r[u][rr]];\n                  tree_f[t].push_back(tree_r[u][rr]);\n                  uu=u;\n                  u=tree_r[u][rr];\n                }\n                for(int r=k-1;r<num[t]*2;++r){\n                  rr=0;\n                  if(tree_r[u][rr]==uu){\n                    ++rr;\n                  }\n                  tree_f[t].push_back(tree_r[u][rr]);\n                  uu=u;\n                  u=tree_r[u][rr];\n                }\n                if(ans<sum){\n                  ans=sum;\n                }\n                for(int r=0;r<num[t];++r){\n                  sum=sum-kaburi[tree_f[t][r]][tree_f[t][r+1]]+kaburi[tree_f[t][r+k-1]][tree_f[t][r+k]];\n                  if(ans<sum){\n                    ans=sum;\n                  }\n                  //printf(\"%lld\\n\",sum);\n                }\n                //pr(tree_f);\n              }\n              else{\n                if(num[t]!=3){\n                  int u=t;\n                  int uu=t;\n                  tree_f[t][0]=t;\n                  for(int r=0;r<k;++r){\n                    rr=0;\n                    if(tree_r[u][rr]==uu){\n                      ++rr;\n                    }\n                    sum+=kaburi[u][tree_r[u][rr]];\n                    uu=u;\n                    u=tree_r[u][rr];\n                  }\n                  if(ans<sum){\n                    ans=sum;\n                  }\n                }\n                else{\n                  int u=t;\n                  int uu=t;\n                  tree_f[t][0]=t;\n                  for(int r=0;r<k;++r){\n                    rr=0;\n                    if(tree_r[u][rr]==uu){\n                      ++rr;\n                    }\n                    sum+=kaburi[u][tree_r[u][rr]];\n                    tree_f[t].push_back(tree_r[u][rr]);\n                    uu=u;\n                    u=tree_r[u][rr];\n                  }\n                  int xxx=s+min({a[tree_f[t][0]].x,a[tree_f[t][1]].x,a[tree_f[t][2]].x})-max({a[tree_f[t][0]].x,a[tree_f[t][1]].x,a[tree_f[t][2]].x});\n                  int yyy=s+min({a[tree_f[t][0]].y,a[tree_f[t][1]].y,a[tree_f[t][2]].y})-max({a[tree_f[t][0]].y,a[tree_f[t][1]].y,a[tree_f[t][2]].y});\n                  int zzz=s+min({a[tree_f[t][0]].z,a[tree_f[t][1]].z,a[tree_f[t][2]].z})-max({a[tree_f[t][0]].z,a[tree_f[t][1]].z,a[tree_f[t][2]].z});\n                  sum=sum-(xxx*yyy+yyy*zzz+zzz*xxx);\n                  if(ans<sum){\n                    ans=sum;\n                  }\n                }\n              }\n            }\n          }\n        }\n        if(ans==0){\n          printf(\"-1\\n\");\n        }\n        else{\n          printf(\"%lld\\n\",s*s*6*k-ans*2);\n        }\n        break;\n      default:\n        for(int t=0;t<n-1;++t){\n          for(int s=t+1;(a[s].length<a[t].length+LE&&s<n);++s){\n            int xx=next(a[t].x,a[s].x);\n            int yy=next(a[t].y,a[s].y);\n            int zz=next(a[t].z,a[s].z);\n            if(xx&&yy&&zz){\n              if(same(t,s)==0){\n                int ee;\n                int eee;\n                if(tree[t]==t&&tree[s]==s){\n                  //printf(\"%d %d\\n\",endd[t],endd[s]);\n                  ee=num[tree[t]];\n                  eee=num[tree[s]];\n                  num[tree[t]]=0;\n                  num[tree[s]]=0;\n                  num[endd[t]]=ee+eee;\n                  tree[t]=endd[t];\n                  tree[endd[t]]=endd[t];\n                  endd[endd[t]]=endd[s];\n                  unite(s,t);\n                }\n                else if(tree[t]!=t&&tree[s]==s){\n                  num[tree[t]]=num[tree[t]]+num[s];\n                  num[tree[s]]=0;\n                  endd[tree[t]]=endd[s];\n                  unite(s,t);\n                  //printf(\"%d\\n\",tree[t]);\n                }\n                else if(tree[t]==t&&tree[s]!=s){\n                  num[tree[s]]=num[t]+num[tree[s]];\n                  num[tree[t]]=0;\n                  endd[tree[s]]=endd[t];\n                  unite(t,s);\n                  //printf(\"%d\\n\",tree[s]);\n                }\n                else if(tree[t]!=t&&tree[s]!=s){\n                  num[tree[t]]=num[tree[t]]+num[tree[s]];\n                  num[tree[s]]=0;\n                  endd[tree[t]]=tree[s];\n                  unite(s,t);\n                  //printf(\"%d %d %d %d\\n\",t,s,tree[t],endd[tree[t]]);\n                }\n                kaburi[s][t]=xx*yy+yy*zz+zz*xx;\n                kaburi[t][s]=kaburi[s][t];\n                tree_r[t].push_back(s);\n                tree_r[s].push_back(t);\n                //printf(\"%d %d %d\\n\",kaburi[q].back());\n                //printf(\"%d %d %d\\n\",xx,yy,zz);\n              }\n              else{\n                kaburi[s][t]=xx*yy+yy*zz+zz*xx;\n                kaburi[t][s]=kaburi[s][t];\n                flg[tree[t]]=1;\n                tree_r[t].push_back(s);\n                tree_r[s].push_back(t);\n              }\n              //nnn();\n            }\n          }\n        }\n        for(int t=0;t<n;++t){\n          root(t);\n        }\n        for(int t=0;t<n;++t){\n          sum=0;\n          if(num[t]>=k){\n            if(flg[t]==0){\n              int u=t;\n              int uu=t;\n              tree_f[t][0]=t;\n              for(int r=0;r<k-1;++r){//k-1\n                rr=0;\n                if(tree_r[u][rr]==uu){\n                  ++rr;\n                }\n                sum+=kaburi[u][tree_r[u][rr]];\n                tree_f[t].push_back(tree_r[u][rr]);\n                uu=u;\n                u=tree_r[u][rr];\n              }\n              for(int r=k-1;r<num[t]-1;++r){\n                rr=0;\n                if(tree_r[u][rr]==uu){\n                  ++rr;\n                }\n                tree_f[t].push_back(tree_r[u][rr]);\n                uu=u;\n                u=tree_r[u][rr];\n              }\n              if(ans<sum){\n                ans=sum;\n              }\n              //printf(\"%lld\\n\",sum);\n              for(int r=0;r+k<num[t];++r){\n                sum=sum-kaburi[tree_f[t][r]][tree_f[t][r+1]]+kaburi[tree_f[t][r+k-1]][tree_f[t][r+k]];\n                //printf(\"%lld\\n\",sum);\n                if(ans<sum){\n                  ans=sum;\n                }\n              }\n            }\n            else{\n              if(num[t]!=k||k==2){\n                int u=t;\n                int uu=t;\n                tree_f[t][0]=t;\n                for(int r=0;r<k-1;++r){\n                  rr=0;\n                  if(tree_r[u][rr]==uu){\n                    ++rr;\n                  }\n                  sum+=kaburi[u][tree_r[u][rr]];\n                  tree_f[t].push_back(tree_r[u][rr]);\n                  uu=u;\n                  u=tree_r[u][rr];\n                }\n                for(int r=k-1;r<num[t]*2;++r){\n                  rr=0;\n                  if(tree_r[u][rr]==uu){\n                    ++rr;\n                  }\n                  tree_f[t].push_back(tree_r[u][rr]);\n                  uu=u;\n                  u=tree_r[u][rr];\n                }\n                if(ans<sum){\n                  ans=sum;\n                }\n                for(int r=0;r<num[t];++r){\n                  sum=sum-kaburi[tree_f[t][r]][tree_f[t][r+1]]+kaburi[tree_f[t][r+k-1]][tree_f[t][r+k]];\n                  if(ans<sum){\n                    ans=sum;\n                  }\n                  //printf(\"%lld\\n\",sum);\n                }\n                //pr(tree_f);\n              }\n              else{\n                int u=t;\n                int uu=t;\n                tree_f[t][0]=t;\n                for(int r=0;r<k;++r){\n                  rr=0;\n                  if(tree_r[u][rr]==uu){\n                    ++rr;\n                  }\n                  sum+=kaburi[u][tree_r[u][rr]];\n                  uu=u;\n                  u=tree_r[u][rr];\n                  //printf(\"%lld\\n\",sum);\n                }\n                if(ans<sum){\n                  ans=sum;\n                }\n              }\n            }\n          }\n        }\n        if(ans==0){\n          printf(\"-1\\n\");\n        }\n        else{\n          printf(\"%lld\\n\",s*s*6*k-ans*2);\n        }\n    }\n    scanf (\"%d %d %d\",&n,&k,&s);\n  }\n}\n/*\n環状 k=3の時 それ以外の時\n\n\n*/\n\n\nbool asc(const xyz_t& left,const xyz_t& right){\n  return left.length<right.length;\n}\n\nint next(int p,int q){\n  if(-s<=(p-q)&&(p-q)<=s){\n    if((p-q)>=0){\n      return s-(p-q);\n    }\n    else{\n      return s-(q-p);\n    }\n  }\n  else{\n    return 0;\n  }\n}\n\nint root(int p){\n  if (tree[p] == p){// 根\n    return p;\n  }\n  else {\n    return tree[p] = root(tree[p]); // 経路圧縮\n  }\n}\n\nvoid unite(int p, int q){\n  p = root(p);\n  q = root(q);\n  if (p == q){}\n  else{\n    tree[p] = q;     //pの親をqの親にする\n  }\n}\n\nint same(int p, int q){\n  return root(p) == root(q);\n}\n\n\n\nvoid pr(vector<vector<int> > pri){\n  for(int t=0;t<int(pri.size());++t){\n    for(int s=0;s<int(pri[t].size())-1;++s){\n      printf(\"%d \",pri[t][s]);\n    }\n    printf(\"%d\\n\",pri[t][pri[t].size()-1]);\n  }\n  printf(\"\\n\");\n}\n\nvoid nnn(){\n  for(int t=0;t<n-1;++t){\n    printf(\"%d \",num[t]);\n  }\n  printf(\"%d\\n\",num[n-1]);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing P = pair<int, ll>;\n\nint main()\n{\n\tll n, k, s;\n\twhile (cin >> n >> k >> s, n | k | s) {\n\t\tvector<ll> x(n), y(n), z(n);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcin >> x[i] >> y[i] >> z[i];\n\t\t}\n\t\tif (k == 1) {\n\t\t\tcout << s * s * 6 << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tvector<vector<P>> G(n);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tif (i != j) {\n\t\t\t\t\tll dx = s - abs(x[i] - x[j]), dy = s - abs(y[i] - y[j]), dz = s - abs(z[i] - z[j]);\n\t\t\t\t\tif (dx > 0 && dy > 0 && dz > 0) {\n\t\t\t\t\t\tG[i].push_back(P(j, dx * dy * 2 + dy * dz * 2 + dz * dx * 2));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tll res = s * s * 6 * k, d = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tvector<int> v;\n\t\t\tvector<ll> used(n);\n\t\t\tll tmp = 0;\n\t\t\tbool flag = true;\n\t\t\tused[i] = -1;\n\t\t\tfor (auto p : G[i]) {\n\t\t\t\tused[p.first] += p.second;\n\t\t\t\tv.push_back(p.first);\n\t\t\t}\n\t\t\tfor (int j = 0; j < k - 1; j++) {\n\t\t\t\tif (v.empty()) {\n\t\t\t\t\tflag = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tauto ne = v.back(); v.pop_back();\n\t\t\t\ttmp += used[ne];\n\t\t\t\tused[ne] = -1;\n\t\t\t\tfor (auto p : G[ne]) {\n\t\t\t\t\tif (used[p.first] >= 0) {\n\t\t\t\t\t\tused[p.first] += p.second;\n\t\t\t\t\t\tv.push_back(p.first);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (flag) {\n\t\t\t\td = max(d, tmp);\n\t\t\t}\n\t\t}\n\t\tcout << (d ? res - d : -1) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <cmath>\n#include <cstdlib>\n#include <map>\nusing namespace std;\n\nclass Point {\npublic:\n    int x, y, z;\n    Point(int x = 0, int y = 0, int z = 0) : x(x), y(y), z(z) {}\n\n    bool operator < (const Point &p) const {\n        if (x == p.x && y == p.y) return z < p.z;\n        if (x == p.x) return y < p.y;\n        return x < p.x;\n    }\n};\n\nclass Cube {\npublic:\n    Point p;\n    int s;\n    int vx[4] = {0, 1, 1, 0}, vy[4] = {0, 0, 1, 1}, vz[2] = {0, 1};\n    Cube(Point p = Point(), int s = 0) : p(p), s(s) {}\n\n    // c???????????¨????????£?????????????????????\n    bool isIn(const Cube &c) {\n        int nx, ny, nz;\n\n        for (int i = 0; i < 2; ++i) {\n            for (int j = 0; j < 4; ++j) {\n                nx = c.p.x + c.s * vx[j];\n                ny = c.p.y + c.s * vy[j];\n                nz = c.p.z + c.s * vz[i];\n\n                //cout << nx << \" \" << ny << \" \" << nz << endl;\n\n                if (p.x <= nx && nx <= p.x + s &&\n                    p.y <= ny && ny <= p.y + s &&\n                    p.z <= nz && nz <= p.z + s) {\n                        return true;\n                    }\n            }\n        }\n\n        return false;\n    }\n\n    int shareS(Cube &c) {\n        int ret = 0;\n        Point a, b;\n        a = p; b = c.p;\n\n        if (a.x > b.x) swap(a.x, b.x);\n        if (a.y > b.y) swap(a.y, b.y);\n        if (a.z > b.z) swap(a.z, b.z);\n\n        ret += abs((a.x + s - b.x) * (a.z + s - b.z) * 2);\n        ret += abs((a.y + s - b.y) * (a.z + s - b.z) * 2);\n        ret += abs((a.x + s - b.x) * (a.y + s - b.y) * 2);\n        return ret;\n    }\n\n};\n\nint n, k, s, x, y, z, ans, cnt;\nvector<Cube> c;\nvector<vector<int> > subg;\nvector<bool> used;\nvector<deque<int> > graph;\ndeque<int> que;\nmap<pair<int, int>, bool> mp, init;\n\ninline void makegraph(int v) {\n    for (int i = 0; i < n; ++i) {\n        if (!mp[make_pair(v, i)] && i != v && c[v].isIn(c[i])) {\n            subg[v].push_back(i);\n            subg[i].push_back(v);\n            mp[make_pair(v, i)] = true;\n            mp[make_pair(i, v)] = true;\n        }\n    }\n}\n\ninline bool isCycle(int graphid) {\n    int size_ = graph[graphid].size();\n    //cout << \"graph size = \" << graph[graphid].size() << endl;\n\n    for (int i = 0; i < size_; ++i) {\n        if (subg[graph[graphid][i]].size() != 2) return false;\n    }\n\n    return true;\n}\n\nvoid dfs(int v) {\n    used[v] = true;\n    int size_ = subg[v].size();\n    bool flag = false;\n\n    for (int i = 0; i < size_; ++i) {\n        if (!used[subg[v][i]]) {\n            dfs(subg[v][i]);\n            if (!flag) que.push_front(v);\n            flag = true;\n        }\n    }\n\n    if (!flag) que.push_front(v);\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    while (cin >> n >> k >> s, n | k | s) {\n        //cout << \"---- begin ----\" << endl;\n        c.resize(n);\n        subg.resize(n);\n        que.clear();\n        used.assign(n, false);\n        mp = init;\n        ans = int(1e9);\n\n        for (int i = 0; i < n; ++i) {\n            cin >> x >> y >> z;\n            c[i] = {Point(x, y, z), s};    \n        }\n\n        for (int i = 0; i < n; ++i) {\n            makegraph(i);\n        }\n\n        for (int i = 0; i < n; ++i) {\n            if (!used[i]) {\n                dfs(i);\n                graph.push_back(que);\n                que.clear();\n            }\n        }\n\n        //cout << isCycle(0) << endl;\n\n        int gsize = graph.size(), qsize, tmp, share, upper;\n        bool isGraphCycle = false;\n\n        for (int i = 0; i < gsize; ++i) {\n            qsize = graph[i].size();\n            tmp = 0;\n            isGraphCycle = isCycle(i);\n            //cout << \"isGraphCycle = \" << isGraphCycle << endl;\n            if (isGraphCycle) {\n                upper = qsize + k - 1;\n            }\n            else upper = qsize;\n\n            if (qsize < k) continue;\n\n            for (int j = 0; j + k - 1 < upper; ++j) {\n                share = 0;\n                for (int l = 0; l < k - 1; ++l) {\n                    //Cube a = c[graph[i][j + l]],\n                    //    b = c[graph[i][j + l + 1]];\n                    //cout << a.p.x << \" \" << a.p.y << \" \" << a.p.z << endl;\n                    //cout << b.p.x << \" \" << b.p.y << \" \" << b.p.z << endl;\n                    tmp = c[graph[i][(j + l) % qsize]].shareS(c[graph[i][(j + l + 1) % qsize]]);\n                    //cout << graph[i][(j + l) % qsize] << \" & \" << graph[i][(j + l + 1) % qsize] << endl;\n                    //cout << \"share is \" << tmp << endl;\n                    share += tmp;\n                }\n\n                if (isGraphCycle && qsize == k) {\n                    tmp = c[graph[i][j % qsize]].shareS(c[graph[i][(j + k - 1) % qsize]]);\n                    //cout << \"this is cycle : \" << tmp << endl;\n                    share += tmp;\n                }\n\n                //cout << endl;\n                ans = min(ans, 6 * s * s * k - share);\n                //cout << \"all - share = \" << 6*s*s*k-share << endl;\n            }\n        }\n\n        if (n == 1) ans = 6 * s * s;\n        if (ans == int(1e9)) ans = -1;\n\n        cout << ans << endl;\n\n        graph.clear();\n        //cout << \"---- end ----\" << endl;\n        //cout << endl;\n\n        c.clear();\n        subg.clear();\n        used.clear();\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint n,k,s;\nvector<vector<int>> edge;\nmap<pair<int,int>,long long int> cost;\n\nconst long long int INF=1e16;\n\nlong long int kwalk(const int org){\n  int pre=-1;\n  long long int res=-INF;\n  for(int lop=0;lop<edge[org].size();lop++){\n    int v=org;\n    pre=v;\n    v=edge[org][lop];\n    long long int sum=cost[{pre,v}];   \n    for(int i=0;i<k-2;i++){\n      if(edge[v].size()<2){\n\tsum=-INF;\n\tbreak;\n      }\n      assert(edge[v].size()==2);\n      int to=(edge[v][0]==pre ? edge[v][1] : edge[v][0]);\n      if(to==org){\n\tsum=-INF;\n\tbreak;\n      }\n      sum+=cost[{v,to}];\n      pre=v;\n      v=to;\n    }\n\n    if(edge[v].size()==2){\n\n      int to=(edge[v][0]==pre ? edge[v][1] : edge[v][0]);\n      if(to==org){\n\n\tsum+=cost[{v,org}];\n      }\n    }\n    res=max(res,sum);\n  }\n  \n  return res;\n}\n\nint main(){\n  while(cin>>n>>k>>s,n){\n    vector<long long int> x(n),y(n),z(n);\n    for(int i=0;i<n;i++){\n      cin>>x[i]>>y[i]>>z[i];\n    }\n    if(k==1){\n      cout<<s*s*6<<endl;\n      continue;\n    }\n    edge.clear();\n    cost.clear();\n    edge.resize(n);\n    for(int i=0;i<n;i++){\n      for(int j=i+1;j<n;j++){\n\tlong long int p=s-abs(x[i]-x[j]);\n\tlong long int q=s-abs(y[i]-y[j]);\n\tlong long int r=s-abs(z[i]-z[j]);\n\tif(p>0 && q>0 && r>0){\n\t  long long int cst=2*(p*q+q*r+r*p);\n\t  edge[i].push_back(j);\n\t  cost[{i,j}]=cst;\n\t  edge[j].push_back(i);\n\t  cost[{j,i}]=cst;\n\t}\n      }\n    }\n    \n    long long int res=-INF;\n   \n    for(int i=0;i<n;i++){\n      res=max(res,kwalk(i));\n    }\n    if(res<0){\n      cout<<-1<<endl;\n      continue;\n    }\n    res=6*s*s*k-res;\n    cout<<res<<endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long   // <-----!!!!!!!!!!!!!!!!!!!\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n)-1;i>=0;i--)\n#define rrep2(i,a,b) for (int i=(a)-1;i>=b;i--)\n#define chmin(a,b) (a)=min((a),(b));\n#define chmax(a,b) (a)=max((a),(b));\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n#define printV(v) cout<<(#v)<<\":\";for(auto(x):(v)){cout<<\" \"<<(x);}cout<<endl;\n#define printVS(vs) cout<<(#vs)<<\":\"<<endl;for(auto(s):(vs)){cout<<(s)<< endl;}\n#define printVV(vv) cout<<(#vv)<<\":\"<<endl;for(auto(v):(vv)){for(auto(x):(v)){cout<<\" \"<<(x);}cout<<endl;}\n#define printP(p) cout<<(#p)<<(p).first<<\" \"<<(p).second<<endl;\n#define printVP(vp) cout<<(#vp)<<\":\"<<endl;for(auto(p):(vp)){cout<<(p).first<<\" \"<<(p).second<<endl;}\n\ninline void output(){ cout << endl; }\ntemplate<typename First, typename... Rest>\ninline void output(const First& first, const Rest&... rest) {\n    cout << first << \" \"; output(rest...);\n}\n\nusing ll = long long;\nusing Pii = pair<int, int>;\nusing TUPLE = tuple<int, int, int>;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vvvi = vector<vvi>;\nconst int inf = 1ll << 60;\nconst int mod = 1e9 + 7;\nusing Graph = vector<vector<int>>;\n\n// undirected\nvoid addEdge(Graph& G, int x, int y) {\n    G[x].emplace_back(y);\n    G[y].emplace_back(x);\n}\n\nstruct Point {\n    int x, y, z;\n    Point(){}\n    Point(int _x, int _y, int _z) : x(_x), y(_y), z(_z) {}\n};\n\nstruct Cube {\n    Point mi, ma;\n    Cube() : mi(inf, inf, inf), ma(-inf, -inf, -inf) {}\n    Cube(int x, int y, int z, int s) : mi(inf, inf, inf), ma(-inf, -inf, -inf) {\n        update(Point(x, y, z));\n        update(Point(x + s, y + s, z + s));\n    }\n    void update(Point p) {\n        chmin(mi.x, p.x); chmin(mi.y, p.y); chmin(mi.z, p.z);\n        chmax(ma.x, p.x); chmax(ma.y, p.y); chmax(ma.z, p.z);\n    }\n    bool inside(Point p) {\n        return mi.x <= p.x && p.x <= ma.x && mi.y <= p.y && p.y <= ma.y && mi.z <= p.z && p.z <= ma.z;\n    }\n    int surface() {\n        int wx = ma.x - mi.x;\n        int wy = ma.y - mi.y;\n        int wz = ma.z - mi.z;\n        if (wx <= 0 || wy <= 0 || wz <= 0) return -1;\n        return 2 * (wx * wy + wy * wz + wz * wx);\n    }\n    Point kthPoint(int k) {\n        switch(k) {\n            case 0: return Point(mi.x, mi.y, mi.z);\n            case 1: return Point(mi.x, mi.y, ma.z);\n            case 2: return Point(mi.x, ma.y, mi.z);\n            case 3: return Point(mi.x, ma.y, ma.z);\n            case 4: return Point(ma.x, mi.y, mi.z);\n            case 5: return Point(ma.x, mi.y, ma.z);\n            case 6: return Point(ma.x, ma.y, mi.z);\n            case 7: return Point(ma.x, ma.y, ma.z);\n        }\n    }\n    void print() {\n        cerr << \"mi: \"; output(mi.x, mi.y, mi.z);\n        cerr << \"ma: \"; output(ma.x, ma.y, ma.z);\n    }\n};\n\nint intersect(Cube c1, Cube c2) {\n    Cube c;\n    rep(k, 8) {\n        if (c2.inside(c1.kthPoint(k))) {\n            c.update(c1.kthPoint(k));\n        }\n    }\n    rep(k, 8) {\n        if (c1.inside(c2.kthPoint(k))) {\n            c.update(c2.kthPoint(k));\n        }\n    }\n    // c.print();\n    return c.surface();\n}\n\nint n, k, s;\nint ma;\nGraph G;\nvvi overlap;\nvi vs;\n\nint sumOverlap() {\n    // printV(vs);\n    int t = 0;\n    rep(i, k - 1) {\n        assert(overlap[vs[i]][vs[i + 1]] > 0);\n        t += overlap[vs[i]][vs[i + 1]];\n    }\n    if (k >= 3 && overlap[vs.back()][vs[0]] > 0) {\n        // cycle\n        t += overlap[vs.back()][vs[0]];\n    }\n    return t;\n}\n\nvoid dfs(int now, int pre, int start) {\n    vs.emplace_back(now);\n\n    if ((int)vs.size() == k) {\n        chmax(ma, sumOverlap());\n    }\n    else {\n        for (auto nxt : G[now]) {\n            if (nxt == pre || nxt == start) continue;\n            dfs(nxt, now, start);\n        }\n    }\n\n    vs.pop_back();\n}\n\nmain() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n\n    int testcase = 0;\n    while (cin >> n >> k >> s, n) {\n        // cerr << \"--- testcase = \" << ++testcase << \" ---\" << endl;\n\n        vector<Cube> cube;\n        rep(i, n) {\n            int x, y, z;\n            cin >> x >> y >> z;\n            cube.emplace_back(x, y, z, s);\n        }\n        // rep(i, n) {\n        //     cerr << i << \":\" << endl;\n        //     cube[i].print();\n        // }\n\n        // if (testcase != 4) continue;\n\n        if (k == 1) {\n            cout << 6 * s * s << endl;\n            continue;\n        }\n\n        G.clear(); G.resize(n);\n        overlap.clear(); overlap.resize(n, vi(n));\n        rep(i, n) {\n            rep2(j, i + 1, n) {\n                int t = intersect(cube[i], cube[j]);\n                if (t > 0) {\n                    addEdge(G, i, j);\n                    overlap[i][j] = t;\n                    overlap[j][i] = t;\n                }\n            }\n        }\n        // printVV(G);\n        // printVV(overlap);\n\n        ma = -1;\n        rep(i, n) {\n            dfs(i, -1, i);\n        }\n\n        cout << (ma == -1 ? -1 : k * 6 * s * s - ma) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int INF = 1 << 30;\n\nstruct edge\n{\n  int to, cost;\n};\n\nint main()\n{\n  int N, K, S;\n  int X[2000], Y[2000], Z[2000];\n\n  while(cin >> N >> K >> S, N) {\n    for(int i = 0; i < N; i++) {\n      cin >> X[i] >> Y[i] >> Z[i];\n    }\n\n    vector< edge > g[2000];\n    for(int i = 0; i < N; i++) {\n      for(int j = 0; j < i; j++) {\n        int latte = max(0, S - abs(X[i] - X[j]));\n        int malta = max(0, S - abs(Y[i] - Y[j]));\n        int beeet = max(0, S - abs(Z[i] - Z[j]));\n        int ukuku = latte * malta + malta * beeet + beeet * latte;\n        if(latte > 0 && malta > 0 && beeet > 0) {\n          g[i].emplace_back((edge) {j, ukuku});\n          g[j].emplace_back((edge) {i, ukuku});\n        }\n      }\n    }\n\n    int ret = 0;\n    for(int i = 0; i < N; i++) {\n      bool v[2000] = {};\n      function< void(int, int, int) > dfs = [&](int idx, int k, int sz)\n      {\n        if(v[idx]++) return;\n        if(k == 0) {\n          if(k >= 2) for(auto &e: g[idx]) if(e.to == i) sz += e.cost;\n          ret = max(ret, sz);\n        } else {\n          for(auto &e : g[idx]) dfs(e.to, k - 1, sz + e.cost);\n        }\n      };\n      dfs(i, K - 1, 0);\n    }\n    if(ret == 0 && K > 1) cout << -1 << endl;\n    else cout << 6 * S * S * K - ret * 2 << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb(s) push_back(s)\n#define mp(a,b) make_pair(a,b)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define maxch(x,y) x=max(x,y)\n#define minch(x,y) x=min(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt(x) bitset<32>(x).count()\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\ntypedef pair<P, int> PPI;\ntypedef pair<ll, ll> PL;\ntypedef pair<P, ll> PPL;\n\n#define INF 1e16\n\n#define MAX_N 1000\n\nll n,k,s;\nll x[2222],y[2222],z[2222];\nvector<int> g[2222];\nbool used[2222];\n\nbool is_cross(int i,int j){\n  return (abs(x[i]-x[j])<=s)&&(abs(y[i]-y[j])<=s)&&(abs(z[i]-z[j])<=s);\n}\n\nll cross_surf(int i,int j){\n  ll xx=s-abs(x[i]-x[j]);\n  ll yy=s-abs(y[i]-y[j]);\n  ll zz=s-abs(z[i]-z[j]);\n  return 2*(xx*yy+yy*zz+zz*xx);\n}\n\nll dfs(int i,int d,int pre,ll sum){\n  if(d==k-1){\n    if(g[i].size()==2&&used[g[i][0]]&&used[g[i][1]])return sum-cross_surf(i,pre);\n    else return sum;\n  }else{\n    ll res=INF;\n    used[i]=true;\n    for(int j:g[i]){\n      if(used[j])continue;\n      minch(res,dfs(j,d+1,i,sum+s*s*6-cross_surf(i,j)));\n    }\n    used[i]=false;\n    return res;\n  }\n}\n\nint main(){\n\tcin.sync_with_stdio(false);\n  while(1){\n    memset(used,0,sizeof(used));\n    rep(i,2222)g[i].clear();\n    cin>>n>>k>>s;\n    if(n==0)break;\n    rep(i,n){\n      cin>>x[i]>>y[i]>>z[i];\n    }\n    rep(i,n)rep(j,i){\n      if(is_cross(i,j)){\n        g[i].pb(j);\n        g[j].pb(i);\n      }\n    }\n    ll res=INF;\n    rep(i,n){\n      minch(res,dfs(i,0,-1,s*s*6));\n    }\n    if(res==INF)cout<<-1<<endl;\n    else cout<<res<<endl;\n  }\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define all(v) begin(v), end(v)\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\n#define reps(i, s, n) for(int i = (int)(s); i < (int)(n); i++)\n\ntemplate<class T1, class T2> void chmin(T1 &a, T2 b){if(a>b)a=b;}\ntemplate<class T1, class T2> void chmax(T1 &a, T2 b){if(a<b)a=b;}\n\nusing pint = pair<int, int>;\nusing tint = tuple<int, int, int>;\nusing vint = vector<int>;\n\nconst int inf = 1LL << 55;\nconst int mod = 1e9 + 7;\n\nstruct Point {\n  int x, y, z;\n  Point(){}\n  Point(int x, int y, int z):x(x), y(y), z(z){}\n};\n\nstruct edge {\n  int to, cost;\n  edge(){}\n  edge(int to, int cost):to(to), cost(cost){}\n};\n\nint n, k, s;\nvector<Point> ps;\nvector< vector<edge> > graph;\n\nbool isIntersect(int a, int b) {\n  if(abs(ps[a].x - ps[b].x) > s) return false;\n  if(abs(ps[a].y - ps[b].y) > s) return false;\n  if(abs(ps[a].z - ps[b].z) > s) return false;\n  return true;\n}\n\nint intersectSurface(int a, int b) {\n  int vx = s - abs(ps[a].x - ps[b].x);\n  int vy = s - abs(ps[a].y - ps[b].y);\n  int vz = s - abs(ps[a].z - ps[b].z);\n  return (vx*vy + vy*vz + vz*vx) * 2;\n}\n\nint ans;\n\nvoid dfs(int u, int p, int r, int d, int sum) {\n  if(d == k) {\n    if(k > 2) {\n      for(edge& e : graph[u]) {\n\tif(e.to == r) sum += e.cost;\n      }\n    }\n    chmax(ans, sum);\n    return;\n  }\n  for(edge& e : graph[u]) {\n    if(e.to == p || e.to == r) continue;\n    dfs(e.to, u, r, d+1, sum+e.cost);\n  }\n}\n\nint solve() {\n  ans = -1;\n  rep(u, n) dfs(u, -1, u, 1, 0);\n  if(ans == -1) return -1;\n  return s*s*6*k - ans;\n}\n\nsigned main()\n{\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  while(cin >> n >> k >> s, n) {\n    ps.clear();\n    rep(i, n) {\n      int x, y, z;\n      cin >> x >> y >> z;\n      ps.emplace_back(x, y, z);\n    }\n    graph.clear(); graph.resize(n);\n    rep(i, n) rep(j, n) if(i != j) {\n      if(isIntersect(i, j)) graph[i].emplace_back(j, intersectSurface(i, j));\n    }\n    cout << solve() << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 2001\n#define int long long\nusing namespace std;\nvector<int>G[N];\nint n,K,S;\nstruct point{int x,y,z;};\n\nint Area(){return S*S*6;}\nint sArea(point a,point b){\n  int x = min(a.x+S, b.x+S),X = max(a.x,b.x);\n  int y = min(a.y+S, b.y+S),Y = max(a.y,b.y);\n  int z = min(a.z+S, b.z+S),Z = max(a.z,b.z);\n  if(y <= Y || x <= X || z <= Z) return 0;\n  int area=0;\n  area += 2*(x-X)*(y-Y);\n  area += 2*(y-Y)*(z-Z);\n  area += 2*(z-Z)*(x-X);\n  return area;\n}\n\nvector<point> A;\nint used[N];\nint dfs(int pos,int k,int start,int prev){\n  if(k == K) return prev==-1? 0:-sArea(A[pos],A[start]);\n  if(used[pos]++) return 1e9;\n  \n  int res = 1e9;\n  for(int nx:G[pos]){\n    if(nx == prev)continue;\n    int area = Area() - sArea(A[pos],A[nx]);\n    res = min(res,area+dfs(nx,k+1,start,pos));\n  }\n  return res;\n}\n\nsigned main(){\n  while(1){\n    cin>>n>>K>>S;\n    if(!n&&!K&&!S)break;\n    \n    A.resize(n);\n    for(int i=0;i<n;i++)cin>>A[i].x>>A[i].y>>A[i].z;\n    \n    for(int i=0;i<N;i++) G[i].clear();\n\n    for(int i=0;i<n;i++)\n      for(int j=i+1;j<n;j++){\n\tif(!sArea(A[i],A[j]))continue;\n\tG[i].push_back(j);\n\tG[j].push_back(i);\n      }\n\n    for(int i=0;i<n;i++) assert(G[i].size()<3);\n    int ans = 1e9;\n    for(int i=0;i<n;i++){\n      memset(used,0,sizeof(used));\n      ans = min(ans,Area()+dfs(i,1,i,-1));\n    }\n\n    if(ans == 1e9) ans = -1;\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define DEBUG(x) cerr << #x << \" = \" << x << endl\nconst int INF = (int)1e18;\nint N, K, S;\nint X[2000], Y[2000], Z[2000];\nstruct Edge {\n  int from, to, ds;\n  Edge(int from_, int to_, int ds_) : from(from_), to(to_), ds(ds_) {}\n  bool operator <(const Edge &other) const {\n    return ds > other.ds;\n  }\n};\nsigned main() {\n  ios::sync_with_stdio(false);\n  while(true) {\n    cin >> N >> K >> S;\n    if(N == 0 && K == 0 && S == 0) break;\n    REP(i,N) {\n      cin >> X[i] >> Y[i] >> Z[i];\n    }\n    vector<vector<Edge>> G(N);\n    REP(i,N) for(int j = i + 1; j < N; ++j) {\n      int dx = abs(X[i] - X[j]);\n      int dy = abs(Y[i] - Y[j]);\n      int dz = abs(Z[i] - Z[j]);\n      if(dx <= S && dy <= S && dz <= S) {\n        int ds = 2 * ((S - dx) * (S - dy) + (S - dy) * (S - dz) + (S - dz) * (S - dx));\n        // cerr << i << \" <-> \" << j << \" = \" << ds << endl;\n        G[i].emplace_back(i, j, ds);\n        G[j].emplace_back(j, i, ds);\n      }\n    }\n    int ans = INF;\n    REP(v,N) {\n      if(G[v].size() == 0) {\n        if(K == 1) ans = min(ans, 6 * S * S * K);\n        continue;\n      }\n      REP(i,G[v].size()) {\n        int prev, next;\n        int tmp;\n        int k;\n        k = 2;\n        tmp = G[v][i].ds;\n        prev = v;\n        next = G[v][i].to;\n        while(true) {\n          assert(G[next].size() > 0);\n          if(k == K) {\n            if(G[next][0].to == v) tmp += G[next][0].ds;\n            if(G[next].size() == 2 && G[next][1].to == v) tmp += G[next][1].ds;\n            break;\n          }\n          if(G[next].size() == 1) {\n            // ??????\n            break;\n          }\n          if(G[next][0].to != prev) {\n            if(next != v) k += 1;\n            tmp += G[next][0].ds;\n            prev = next;\n            next = G[next][0].to;\n            if(next == v) break;\n          }\n          else {\n            if(next != v) k += 1;\n            tmp += G[next][1].ds;\n            prev = next;\n            next = G[next][1].to;\n            if(next == v) break;\n          }\n        }\n        if(k == K) {\n          ans = min(ans, 6 * S * S * K - tmp);\n        }\n      }\n    }\n    cout << (ans == INF ? -1 : ans) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cstring>\nusing namespace std;\nusing ll = long long;\n\nstruct Cube{\n    ll lx, rx;\n    ll ly, ry;\n    ll lz, rz;\n    ll S(){\n        ll dx = rx - lx;\n        ll dy = ry - ly;\n        ll dz = rz - lz;\n        return (dx * dy + dy * dz + dz * dx) * 2;\n    } \n};\n\nll f(Cube c1, Cube c2){\n    ll L[3][2] = {{c1.lx, c2.lx}, {c1.ly, c2.ly}, {c1.lz, c2.lz}};\n    ll R[3][2] = {{c1.rx, c2.rx}, {c1.ry, c2.ry}, {c1.rz, c2.rz}};\n    ll LX, LY, LZ, RX, RY, RZ;\n    ll sum = 0;\n    LX = max(c1.lx, c2.lx);\n    RX = min(c1.rx, c2.rx);\n    LY = max(c1.ly, c2.ly);\n    RY = min(c1.ry, c2.ry);\n    LZ = max(c1.lz, c2.lz);\n    RZ = min(c1.rz, c2.rz);\n    if(RX <= LX) return 0;\n    if(RY <= LY) return 0;\n    if(RZ <= LZ) return 0;\n    ll dx = RX - LX;\n    ll dy = RY - LY;\n    ll dz = RZ - LZ;\n    return (dx * dy + dy * dz + dz * dx) * 2;\n}\n\nint n, k, s;\nCube c[2000];\nint vis[2000];\n\nvector<int> G[2000];\n\nvector<vector<int>> C;// ????????????\nvector<vector<int>> S;// ?????¬???\n\n// ????????????????????????\nbool dfs(int v, int p, vector<int>& a){\n    vis[v] = 1;\n    a.push_back(v);\n    for(int c : G[v]){\n        if(c == p) continue;\n        if(vis[c]) continue;\n        return dfs(c, v, a);\n    }\n    // \n    return G[v].size() == 2;\n}\n\n// ??±?????¢???;\nll X[2000][2000];\n\nint main(){\n    while(cin >> n >> k >> s, n){\n        for(int i = 0; i < n; i++){\n            cin >> c[i].lx  >> c[i].ly >> c[i].lz;\n            c[i].rx = c[i].lx + s;\n            c[i].ry = c[i].ly + s;\n            c[i].rz = c[i].lz + s;\n            G[i].clear();\n        }\n        C.clear();\n        S.clear();\n\n        for(int i = 0; i < n; i++){\n            for(int j = 0; j < n; j++){\n                if(i == j) continue;\n                ll res = f(c[i], c[j]);\n                X[i][j] = res;\n                if(res) G[i].push_back(j);\n            }\n        }\n\n        memset(vis, 0, sizeof vis);\n        for(int i = 0; i < n; i++){\n            if(vis[i]) continue;\n            if(G[i].size() == 1){\n                vector<int> a;\n                bool res = dfs(i, -1, a);\n                if(a.size() < k) continue;\n                S.push_back(a);\n            }   \n        }\n        for(int i = 0; i < n; i++){\n            if(vis[i]) continue;\n            vector<int> a;\n            bool res = dfs(i, -1, a);\n            if(a.size() < k) continue;\n            C.push_back(a);\n        }\n\n        ll ans = 1LL << 61;\n        for(auto a : C){\n            int sz = a.size();\n            for(int i = 0; i < sz; i++) a.push_back(a[i]);\n            ll sum = 0;\n            for(int i = 0; i < k; i++){\n                sum += c[a[i]].S();\n                if(i != k - 1 || k == sz) sum -= X[a[i]][a[i + 1]];\n            }\n            for(int i = 0; i < sz; i++){\n                ans = min(ans, sum);\n                sum -= c[a[i]].S();\n                sum += X[a[i]][a[i+1]];\n                sum += c[a[i+k]].S();\n                sum -= X[a[i+k-1]][a[i+k]];\n            }\n            if(k != sz){\n                ans = min(ans, sum);\n            }\n        }\n        for(auto a : S){\n            ll sum = 0;\n            for(int i = 0; i < k; i++){\n                sum += c[a[i]].S();\n                if(i != k - 1) sum -= X[a[i]][a[i + 1]];\n            }\n            for(int i = 0; i < a.size() - k; i++){\n                ans = min(ans, sum);\n                sum -= c[a[i]].S();\n                sum += X[a[i]][a[i+1]];\n                sum += c[a[i+k]].S();\n                sum -= X[a[i+k-1]][a[i+k]];\n            }\n            ans = min(ans, sum);\n        }\n        if(ans == 1LL << 61) cout << -1 << endl;\n        else cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cstring>\n#include <cassert>\nusing namespace std;\nusing ll = long long;\n\nstruct Cube{\n    ll lx, rx;\n    ll ly, ry;\n    ll lz, rz;\n    ll S(){\n        ll dx = rx - lx;\n        ll dy = ry - ly;\n        ll dz = rz - lz;\n        return (dx * dy + dy * dz + dz * dx) * 2;\n    } \n};\n\nll f(Cube c1, Cube c2){\n    ll LX, LY, LZ, RX, RY, RZ;\n    LX = max(c1.lx, c2.lx);\n    RX = min(c1.rx, c2.rx);\n    LY = max(c1.ly, c2.ly);\n    RY = min(c1.ry, c2.ry);\n    LZ = max(c1.lz, c2.lz);\n    RZ = min(c1.rz, c2.rz);\n    if(RX <= LX) return 0;\n    if(RY <= LY) return 0;\n    if(RZ <= LZ) return 0;\n    ll dx = RX - LX;\n    ll dy = RY - LY;\n    ll dz = RZ - LZ;\n    return (dx * dy + dy * dz + dz * dx) * 2;\n}\n\nint n, k, s;\nCube c[2000];\nint vis[2000];\n\nvector<int> G[2000];\n\nvector<vector<int>> C;// ????????????\nvector<vector<int>> S;// ?????¬???\n\n// ????????????????????????\nvoid dfs(int v, int p, vector<int>& a){\n    vis[v] = 1;\n    a.push_back(v);\n    for(int c : G[v]){\n        if(c == p) continue;\n        if(vis[c]) continue;\n        dfs(c, v, a);\n        return;\n    }\n    return;\n}\n\n// ??±?????¢???;\nll X[2000][2000];\n\nint main(){\n    while(cin >> n >> k >> s, n){\n        for(int i = 0; i < n; i++){\n            cin >> c[i].lx  >> c[i].ly >> c[i].lz;\n            c[i].rx = c[i].lx + s;\n            c[i].ry = c[i].ly + s;\n            c[i].rz = c[i].lz + s;\n            G[i].clear();\n        }\n        C.clear();\n        S.clear();\n\n        for(int i = 0; i < n; i++){\n            for(int j = 0; j < n; j++){\n                if(i == j) continue;\n                ll res = f(c[i], c[j]);\n                X[i][j] = res;\n                if(res) G[i].push_back(j);\n            }\n        }\n\n        memset(vis, 0, sizeof vis);\n        for(int i = 0; i < n; i++){\n            if(vis[i]) continue;\n            if(G[i].size() <= 1){\n                vector<int> a;\n                dfs(i, -1, a);\n                if(a.size() < k) continue;\n                S.push_back(a);\n            }   \n        }\n        for(int i = 0; i < n; i++){\n            if(vis[i]) continue;\n            assert(G[i].size() <= 2);\n            vector<int> a;\n            dfs(i, -1, a);\n            if(a.size() < k) continue;\n            C.push_back(a);\n        }\n\n        ll ans = 1LL << 61;\n        for(auto a : C){\n            int sz = a.size();\n            for(int i = 0; i < sz; i++) a.push_back(a[i]);\n            ll sum = 0;\n            for(int i = 0; i < k; i++){\n                sum += c[a[i]].S();\n                if(i != k - 1 || k == sz) sum -= X[a[i]][a[i + 1]];\n            }\n            for(int i = 0; i < sz && sz != k; i++){\n                ans = min(ans, sum);\n                sum -= c[a[i]].S();\n                sum += X[a[i]][a[i+1]];\n                sum += c[a[i+k]].S();\n                sum -= X[a[i+k-1]][a[i+k]];\n            }\n            ans = min(ans, sum);\n        }\n        for(auto a : S){\n            ll sum = 0;\n            for(int i = 0; i < k; i++){\n                sum += c[a[i]].S();\n                if(i != k - 1) sum -= X[a[i]][a[i + 1]];\n            }\n            for(int i = 0; i < a.size() - k; i++){\n                ans = min(ans, sum);\n                sum -= c[a[i]].S();\n                sum += X[a[i]][a[i+1]];\n                sum += c[a[i+k]].S();\n                sum -= X[a[i+k-1]][a[i+k]];\n            }\n            ans = min(ans, sum);\n        }\n        if(ans == 1LL << 61) ans = -1;\n        cout << ans << endl;\n       // cout << ans << \" \" << n << \" \" << S.size() << \" \"  << C.size() << \" \" <<  k << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef tuple<ll,ll,ll> T;\n\nvector<T> v;\nll N, K, S;\n    \nll connect(ll i, ll j){\n    ll x1,y1,z1,x2,y2,z2;\n    tie(x1,y1,z1) = v[i];\n    tie(x2,y2,z2) = v[j];\n    bool checkx = (x1 <= x2 && x2 <= x1 + S) || (x2 <= x1 && x1 <= x2 + S);\n    bool checky = (y1 <= y2 && y2 <= y1 + S) || (y2 <= y1 && y1 <= y2 + S);\n    bool checkz = (z1 <= z2 && z2 <= z1 + S) || (z2 <= z1 && z1 <= z2 + S);\n    ll wix=S-abs(x1-x2);\n    ll wiy=S-abs(y1-y2);\n    ll wiz=S-abs(z1-z2);\n    ll ans=wix*wiy+wiy*wiz+wiz*wix;\n    return (checkx&&checky&&checkz) *ans*2;\n}\nstruct Edge{\n    ll from;\n    ll to;\n    ll cost;\n};\nll ans=0;\nvector<ll>used;\nvoid dfschain(const ll now,const ll from,const vector<vector<Edge>>&edges,vector<ll>kasanari){\n    if(used[now]==true)assert(false);\n    \n    used[now]=true;\n\n    if(edges[now].size()==1&&from!=-1){\n        if(kasanari.size()<K-1){\n            return;\n        } \n        else{\n            ll sum=0;\n            for(ll i=0;i<K-1;++i){\n                sum+=kasanari[i];\n            }\n            for(ll j=0;j<kasanari.size();++j){\n                ans=max(ans,sum);\n                sum+=kasanari[(j+K-1)%kasanari.size()];\n                sum-=kasanari[j];\n            }\n\n        }\n        return;\n    }\n    bool flag=false;\n    for(auto e:edges[now]){\n        if(e.to!=from){\n\n            if(flag)assert(false);\n            flag=true;\n\n            kasanari.push_back(e.cost);\n            dfschain(e.to,now,edges,kasanari);\n        }\n    }\n}\n\nvoid dfscircle(const ll now,const ll from,const vector<vector<Edge>>&edges,vector<ll>kasanari){\n    if(used[now]==true){\n        if(kasanari.size()<K){\n            return;\n        } \n        else if(kasanari.size()==K){\n            ans=max(ans,accumulate(kasanari.begin(),kasanari.end(),0ll));\n        }else{\n            ll sum=0;\n            for(ll i=0;i<K-1;++i){\n                sum+=kasanari[i];\n            }\n            for(ll j=0;j<kasanari.size();++j){\n                ans=max(ans,sum);\n                sum+=kasanari[(j+K-1)%kasanari.size()];\n                sum-=kasanari[j];\n            }\n\n        }\n        return;\n    }\n    used[now]=true;\n\n    bool flag=false;\n    for(auto e:edges[now]){\n        if(e.to!=from){\n            if(flag)assert(false);\n            flag=true;\n\n            kasanari.push_back(e.cost);\n             dfscircle(e.to,now,edges,kasanari);\n             if(from==1)break;\n        }\n            \n    }\n}\nint main(){\n    while(true){\n        v.clear();\n        ans=0;\n        cin >> N >> K >> S;\n        if(!N)break;\n        used.assign(N,0);\n        \n        for(ll i=0;i<N;i++){\n            ll x,y,z;\n            cin >> x >> y >> z;\n            v.push_back(T(x,y,z));\n        }\n        vector<vector<Edge>>edges(N);\n        for(ll i=0;i<N;++i){\n            for(ll j=0;j<N;++j){\n                if(i==j)continue;\n                if(connect(i,j)){\n                    ll k=connect(i,j);\n                    edges[i].push_back(Edge{i,j,k});\n                }\n            }\n        }\n      \n        for(ll i=0;i<N;++i){\n            if(used[i])continue;\n            if(edges[i].size()==1){\n                vector<ll>kasanari;\n                dfschain(i,-1,edges,kasanari);\n            }\n        }\n        for(ll i=0;i<N;++i){\n            if(used[i])continue;\n            if(edges[i].size()==2){\n                vector<ll>kasanari;\n                \n                dfscircle(i,-1,edges,kasanari);\n            }\n        }\n        if(K==1)cout<<S*S*6<<endl;\n\n        else if(ans==0)cout<<-1<<endl;\n        else cout<<S*S*6*K-ans<<endl;\n    }\n    \n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define loop for(;;)\n#define rep(i, n) for(long i = 0; i < (long)(n); ++i)\ntypedef std::vector<long> LI;\n\nstruct Solver {\n   std::vector<long> nexts[2123];\n   std::vector<long> overlap[2123];\n   long n, len, s;\n   LI xs, ys, zs;\n   long f(long i, long k) {\n      long dx = std::max((long)0, s - std::abs(xs[k] - xs[i]));\n      long dy = std::max((long)0, s - std::abs(ys[k] - ys[i]));\n      long dz = std::max((long)0, s - std::abs(zs[k] - zs[i]));\n      if( dx == 0 or dy == 0 or dz == 0 ) return 0;\n      return 2 * (dx * dy + dy * dz + dz * dx);\n   }\n   void solve() {\n      std::cin >> n >> len >> s;\n      if( !(n|len|s) ) exit(0);\n      xs.resize(n), ys.resize(n), zs.resize(n);\n      rep(i, n) std::cin >> xs[i] >> ys[i] >> zs[i];\n      rep(i, n) rep(k, n) {\n         if( i == k ) continue;\n         long over = f(i, k);\n         if( over == 0 ) continue;\n         nexts[i].push_back(k);\n         overlap[i].push_back(over);\n      }\n      long res = -(1LL << 53);\n      rep(i, n) {\n         visited.resize(n, false);\n         res = std::max(res, dfs(i, len-1, i));\n      }\n      visited.resize(n);\n      printf(\"%ld\\n\", res >= 0 ? 6 * s * s * len - res : -1);\n   }\n   std::vector<bool> visited;\n   long dfs(long v, long d, long begin) {\n      if( d == 0 ) {\n         if( len >= 3 ) {\n            rep(i, nexts[v].size()) {\n               long next = nexts[v][i];\n               long over = overlap[v][i];\n               if( next == begin ) {\n                  return over;\n               }\n            }\n         }\n         return 0;\n      }\n      long res = -(1LL << 53);\n      visited[v] = true;\n      rep(i, nexts[v].size()) {\n         long next = nexts[v][i];\n         long over = overlap[v][i];\n         if( visited[next] ) continue;\n         res = std::max(res, dfs(next, d-1, begin) + over);\n      }\n      visited[v] = false;\n      return res;\n   }\n};\n\nint main() {\n   loop std::shared_ptr<Solver>(new Solver())->solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> l_l;\ntypedef pair<int, int> i_i;\n\n#define EPS (1e-7)\n#define INF (1e17)\n#define PI (acos(-1))\n//const ll mod = 1000000007;\nll x[2005][3];\nvector<int> connected[2005];\nll ans;\nll n, k, s;\n\nll g(int a, int b) {\n    ll ret = 0;\n    ll dx[3];\n    for(int i = 0; i <= 2; i++) {\n        dx[i] = - max(x[a][i], x[b][i]) + min(x[a][i], x[b][i]) + s;\n    }\n    for(int i = 0; i <= 2; i++) {\n        for(int j = i + 1; j <= 2; j++) {\n            ret += dx[i] * dx[j] * 2;\n        }\n    }\n    return ret;\n}\n\nvoid f(int now, int par, int rest, int root, ll val) {\n    val += 6 * s * s;\n    if(rest == 1) {\n        if(k != 2) {\n            if(count(connected[now].begin(), connected[now].end(), root)) {\n                val -= g(now, root);\n            }\n        }\n        ans = min(ans, val);\n        return;\n    }\n    for(int i = 0; i < connected[now].size(); i++) {\n        int to = connected[now][i];\n        if(to == par) continue;\n        if(to == root) continue;\n        f(to, now, rest - 1, root, val - g(now, to));\n    }\n    return;\n}\n\nint main() {\n    //cout.precision(10);\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while(true) {\n        ans = INF;\n        cin >> n >> k >> s;\n        if(n == 0) break;\n        for(int i = 1; i <= n; i++) {\n            cin >> x[i][0] >> x[i][1] >> x[i][2];\n            connected[i].clear();\n        }\n        for(int i = 1; i <= n; i++) {\n            for(int j = i + 1; j <= n; j++) {\n                bool isconnected = true;\n                for(int k = 0; k <= 2; k++) {\n                    if(min(x[i][k], x[j][k]) + s < max(x[i][k], x[j][k])) isconnected = false;\n                }\n                if(isconnected) {\n                    connected[i].push_back(j);\n                    connected[j].push_back(i);\n                }\n            }\n        }\n        for(int i = 1; i <= n; i++) {\n            f(i, -1, k, i, 0);\n        }\n        if(ans == INF) ans = -1;\n        cout << ans << endl;\n        /*\n        for(int i = 1; i <= n; i++) {\n            cerr << i << \" is connected with \";\n            for(int j = 0; j < connected[i].size(); j++) cerr << connected[i][j] << \" \";\n            cerr << endl;\n        }\n        */\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\nusing namespace std;\ntypedef long long ll;\nconst ll MOD = 1000000007;\nconst ll INF = (ll)1000000007 * 1000000007;\nconst double EPS = 1e-9;\ntypedef pair<int, int> P;\ntypedef unsigned int ui;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\nint n, k, s;\nstruct cube { int x, y, z; };\nint cap(cube a, cube b) {\n\tint da = s - abs(a.x - b.x);\n\tint db = s - abs(a.y - b.y);\n\tint dc = s - abs(a.z - b.z);\n\tif (da <= 0 || db <= 0 || dc <= 0)return 0;\n\treturn 2*(da * db +db* dc+dc*da);\n}\nstruct edge { int to,cost; };\nint main() {\n\twhile (cin >> n >> k >> s,n) {\n\t\tvector<edge> G[2000]; cube a[2000];\n\t\trep(i, n) {\n\t\t\tint x, y, z; cin >> x >> y >> z;\n\t\t\ta[i] = { x,y,z };\n\t\t}\n\t\tif (k == 1) {\n\t\t\tcout << 6 * s*s << endl; continue;\n\t\t}\n\t\trep(i, n) {\n\t\t\trep(j, n) {\n\t\t\t\tif (i == j)continue;\n\t\t\t\tint dis = cap(a[i], a[j]);\n\t\t\t\tif (dis > 0) {\n\t\t\t\t\tG[i].push_back({ j,dis });\n\t\t\t\t\tG[j].push_back({ i,dis });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ma = 0;\n\t\trep(sta, n) {\n\t\t\trep(i, (int)G[sta].size()) {\n\t\t\t\tvector<int> ad;\n\t\t\t\tint nf = G[sta][i].to;\n\t\t\t\tint used[2000] = {}; used[sta] = used[nf] = 1;\n\t\t\t\tbool f = false;\n\t\t\t\tad.push_back(nf); ad.push_back(sta);\n\t\t\t\trep(aaa, k - 2) {\n\t\t\t\t\tf = false;\n\t\t\t\t\trep(b, (int)G[nf].size()) {\n\t\t\t\t\t\tif (!used[G[nf][b].to]) {\n\t\t\t\t\t\t\tf = true;\n\t\t\t\t\t\t\tused[G[nf][b].to] = 1;\n\t\t\t\t\t\t\tnf = G[nf][b].to; \n\t\t\t\t\t\t\tad.push_back(nf);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!f)continue;\n\t\t\t\tint sum = 0;\n\t\t\t\tint len = ad.size();\n\t\t\t\trep(i, len) {\n\t\t\t\t\trep(j, len) {\n\t\t\t\t\t\tif (i < j) {\n\t\t\t\t\t\t\tsum += cap(a[ad[i]], a[ad[j]]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tma = max(ma, sum);\n\t\t\t}\n\t\t}\n\t\tif (ma == 0) {\n\t\t\tcout << -1 << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << 6 * s*s*k - ma << endl;\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cassert>\n\nusing namespace std;\nusing ll = long long;\nconstexpr ll INF = 1LL << 50;\nll s;\n\nstruct Cube {\n    ll x;\n    ll y;\n    ll z;\n};\nll connected(const Cube& c1, const Cube& c2)\n{\n    const ll x1 = c1.x;\n    const ll y1 = c1.y;\n    const ll z1 = c1.z;\n    for (int i = 0; i < 2; i++) {\n        const ll x2 = c2.x + i * s;\n        const ll dx = x2 - x1;\n        for (int j = 0; j < 2; j++) {\n            const ll y2 = c2.y + j * s;\n            const ll dy = y2 - y1;\n            for (int k = 0; k < 2; k++) {\n                const ll z2 = c2.z + k * s;\n                const ll dz = z2 - z1;\n                if (0 <= dx and dx <= s and 0 <= dy and dy <= s and 0 <= dz and dz <= s) {\n                    const ll lx = (i == 0) ? s - dx : dx;\n                    const ll ly = (j == 0) ? s - dy : dy;\n                    const ll lz = (k == 0) ? s - dz : dz;\n                    return (lx * ly + ly * lz + lz * lx) * 2;\n                }\n            }\n        }\n    }\n    return 0;\n}\n\nstruct Edge {\n    int from;\n    int to;\n    ll cost;\n};\nstruct Graph {\n    Graph(const int n)\n    {\n        edge.resize(n);\n    }\n    void addEdge(const int from, const int to, const ll cost)\n    {\n        edge[from].push_back(Edge{from, to, cost});\n        edge[to].push_back(Edge{to, from, cost});\n    }\n    vector<vector<Edge>> edge;\n};\n\nint getEdge(const Graph& g, const int s, vector<bool>& visited)\n{\n    visited[s] = true;\n    int child = 0;\n    for (const auto& e : g.edge[s]) {\n        if (not visited[e.to]) {\n            return getEdge(g, e.to, visited);\n        }\n    }\n    if (child == 0) {\n        return s;\n    }\n}\nstruct Chain {\n    bool ring = false;\n    vector<ll> edges;\n};\nostream& operator<<(ostream& os, const Chain& ch)\n{\n    os << \"Ring: \" << boolalpha << ch.ring << \"\\nEdge: {\";\n    for (int i = 0; i < ch.edges.size(); i++) {\n        if (i != 0) {\n            os << \",\";\n        }\n        os << ch.edges[i];\n    }\n    os << \"}\" << endl;\n}\nvoid dfs(const Graph& g, const int s, const int dep, vector<bool>& visited, Chain& chain)\n{\n    visited[s] = true;\n    for (const auto& e : g.edge[s]) {\n        if (e.to == dep and chain.edges.size() >= 2) {\n            if (not chain.ring) {\n                chain.edges.push_back(e.cost);\n                chain.ring = true;\n            }\n            return;\n        }\n        if (not visited[e.to]) {\n            chain.edges.push_back(e.cost);\n            dfs(g, e.to, dep, visited, chain);\n        }\n    }\n}\n\nint main()\n{\n    while (true) {\n        int n, k;\n        cin >> n >> k >> s;\n        if (n == 0 and k == 0 and s == 0) {\n            break;\n        }\n\n        const ll whole = 6 * s * s * k;\n        if (k == 1) {\n            cout << whole << endl;\n            continue;\n        }\n\n        vector<Cube> cube(n);\n        for (int i = 0; i < n; i++) {\n            cin >> cube[i].x >> cube[i].y >> cube[i].z;\n        }\n        Graph g(n);\n        for (int i = 0; i < n - 1; i++) {\n            for (int j = i + 1; j < n; j++) {\n                const ll cost = connected(cube[i], cube[j]);\n                if (cost > 0) {\n                    g.addEdge(i, j, cost);\n                }\n            }\n        }\n        vector<bool> visited(n, false);\n        vector<Chain> chains;\n        for (int i = 0; i < n; i++) {\n            if (not visited[i]) {\n                vector<bool> visited2(n, false);\n                const int dep = getEdge(g, i, visited2);\n                Chain chain;\n                chain.ring = false;\n                dfs(g, dep, dep, visited, chain);\n                chains.push_back(chain);\n            }\n        }\n        ll mini = INF;\n        for (const auto chain : chains) {\n\n            const bool ring = chain.ring;\n            const vector<ll>& costs = chain.edges;\n            if (costs.size() < k) {\n                continue;\n            }\n            if (ring) {\n                ll sum = 0;\n                for (int i = 0; i < k - 1; i++) {\n                    sum += costs[i];\n                }\n                if (costs.size() == k) {\n                    sum += costs[k - 1];\n                    mini = min(mini, whole - sum);\n                } else {\n                    mini = min(mini, whole - sum);\n                    int head = 0;\n                    int tail = k - 1;\n                    for (int i = 0; i < costs.size(); head++, tail++, tail = tail % costs.size()) {\n                        sum += (costs[tail] - costs[head]);\n                        mini = min(mini, whole - sum);\n                    }\n                }\n            } else {\n                ll sum = 0;\n                for (int i = 0; i < k - 1; i++) {\n                    sum += costs[i];\n                }\n                mini = min(mini, whole - sum);\n                int head = 0;\n                int tail = k - 1;\n                for (; tail < costs.size(); head++, tail++) {\n                    sum += (costs[tail] - costs[head]);\n                    mini = min(mini, whole - sum);\n                }\n            }\n        }\n        cout << ((mini == INF) ? -1 : mini) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define loop for(;;)\ntypedef std::vector<long> LI;\ntemplate<typename T> void scan1(T& x) { fprintf(stderr, \"unknown type\\n\"); }\ntemplate<> void scan1(long& x) { if( scanf(\"%ld\", &x) < 0 ) exit(0); }\ntemplate<> void scan1(std::string& x) { if( not ( std::cin >> x ) ) exit(0); }\nvoid scan() {}\ntemplate<typename Head, typename... Tail>\nvoid scan(Head& x, Tail&... xs) {\n  scan1(x); scan(xs...);\n}\n\nstruct Solver {\n   std::vector<long> nexts[2123];\n   std::vector<long> overlap[2123];\n   long n, len, s;\n   LI xs, ys, zs;\n   long f(long i, long k) {\n      long dx = std::max((long)0, s - std::abs(xs[k] - xs[i]));\n      long dy = std::max((long)0, s - std::abs(ys[k] - ys[i]));\n      long dz = std::max((long)0, s - std::abs(zs[k] - zs[i]));\n      if( dx == 0 or dy == 0 or dz == 0 ) return 0;\n      return 2 * (dx * dy + dy * dz + dz * dx);\n   }\n   void solve() {\n      scan(n, len, s);\n      if( n == 0 and len == 0 and s == 0 ) exit(0);\n      xs.resize(n), ys.resize(n), zs.resize(n);\n      for(long i = 0; i < n; ++i) scan(xs[i], ys[i], zs[i]);\n      for(long i = 0; i < n; ++i) {\n         for(long k = 0; k < n; ++k) {\n            if( i == k ) continue;\n            long over = f(i, k);\n            if( over == 0 ) continue;\n            nexts[i].push_back(k);\n            overlap[i].push_back(over);\n            fprintf(stderr, \"%ld %ld %ld\\n\", i, k, over);\n         }\n      }\n      long res = 0;\n      for(long i = 0; i < n; ++i) {\n         visited.resize(n, false);\n         res = std::max(res, dfs(i, len-1, i));\n      }\n      visited.resize(n);\n      printf(\"%ld\\n\", res > 0 ? 6 * s * s * len - res : -1);\n   }\n   std::vector<bool> visited;\n   long dfs(long v, long d, long begin) {\n      if( d == 0 ) {\n         for(long i = 0; i < (long)nexts[v].size(); ++i) {\n            long next = nexts[v][i];\n            long over = overlap[v][i];\n            if( next == begin ) {\n               return over;\n            }\n         }\n         return 0;\n      }\n      long res = -(1LL << 53);\n      visited[v] = true;\n      for(long i = 0; i < (long)nexts[v].size(); ++i) {\n         long next = nexts[v][i];\n         long over = overlap[v][i];\n         if( visited[next] ) continue;\n         res = std::max(res, dfs(next, d-1, begin) + over);\n      }\n      visited[v] = false;\n      return res;\n   }\n};\n\nint main() {\n   loop std::shared_ptr<Solver>(new Solver())->solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MAX_N 2000\n#define pb push_back\ntypedef long long int ll;\nint N,K;\nll S;\nll X[MAX_N],Y[MAX_N],Z[MAX_N];\nvector<int>G[MAX_N];\nvector<vector<int> >object;\nvector<vector<ll> >kyoutuu;\nbool flag[MAX_N];\nll ans=100000000000000;\nint main()\n{\n\twhile(true){\n\t\tscanf(\"%d%d%lld\",&N,&K,&S);\n\t\tif(N==0&&K==0&&S==0LL){break;}\n\t\tfor(int i=0;i<N;i++){\n\t\t\tscanf(\"%lld%lld%lld\",&X[i],&Y[i],&Z[i]);\n\t\t}\n\t\tfor(int i=0;i<N;i++){\n\t\t\tG[i].clear();\n\t\t}\n\t\tfor(int i=0;i<N;i++){\n\t\t\tflag[i]=1;\n\t\t}\n\t\tobject.clear();\n\t\tkyoutuu.clear();\n\t\tans=100000000000000;\n\t\tfor(int i=0;i<N;i++){\n\t\t\tfor(int j=i+1;j<N;j++){\n\t\t\t\tif(i==j){continue;}\n\t\t\t\tif(abs(X[i]-X[j])<=S){\n\t\t\t\t\tif(abs(Y[i]-Y[j])<=S){\n\t\t\t\t\t\tif(abs(Z[i]-Z[j])<=S){\n\t\t\t\t\t\t\tG[i].pb(j);\n\t\t\t\t\t\t\tG[j].pb(i);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<N;i++){\n\t\t\tif(flag[i]==0){continue;}\n\t\t\tif((int)G[i].size()==1){\n\t\t\t\tvector<int> now;\n\t\t\t\tnow.pb(i);flag[i]=0;\n\t\t\t\tint fv=i;\n\t\t\t\tint v=G[i][0];\n\t\t\t\tnow.pb(v);flag[v]=0;\n\t\t\t\twhile(true){\n\t\t\t\t\tif((int)G[v].size()==1){\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tif(G[v][0]!=fv){\n\t\t\t\t\t\t\tnow.pb(G[v][0]);flag[G[v][0]]=0;\n\t\t\t\t\t\t\tfv=v;\n\t\t\t\t\t\t\tv=G[v][0];\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tnow.pb(G[v][1]);flag[G[v][1]]=0;\n\t\t\t\t\t\t\tfv=v;\n\t\t\t\t\t\t\tv=G[v][1];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tobject.pb(now);\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<N;i++){\n\t\t\tif(flag[i]==0){continue;}\n\t\t\tif((int)G[i].size()==0){\n\t\t\t\tvector<int>now;\n\t\t\t\tnow.pb(i);flag[i]=0;\n\t\t\t\tobject.pb(now);\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<N;i++){\n\t\t\tif(flag[i]==0){continue;}\n\t\t\tif((int)G[i].size()==2){\n\t\t\t\tvector<int> now;\n\t\t\t\tnow.pb(i);flag[i]=0;\n\t\t\t\tint fv=i;\n\t\t\t\tint v=G[i][0];\n\t\t\t\tnow.pb(v);flag[v]=0;\n\t\t\t\twhile(true){\n\t\t\t\t\tif(v==i){\n\t\t\t\t\t\tnow.erase(now.end()-1,now.end());\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tif(G[v][0]!=fv){\n\t\t\t\t\t\t\tnow.pb(G[v][0]);flag[G[v][0]]=0;\n\t\t\t\t\t\t\tfv=v;\n\t\t\t\t\t\t\tv=G[v][0];\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tnow.pb(G[v][1]);flag[G[v][1]]=0;\n\t\t\t\t\t\t\tfv=v;\n\t\t\t\t\t\t\tv=G[v][1];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tobject.pb(now);\n\t\t\t}\n\t\t}\n\t\t/*\n\t\tfor(int i=0;i<N;i++){\n\t\t\tprintf(\"%d:\",i);\n\t\t\tfor(int j=0;j<(int)G[i].size();j++){\n\t\t\t\tprintf(\"%d \",G[i][j]);\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t\tprintf(\"\\n\");\n\t\tfor(int i=0;i<(int)object.size();i++){\n\t\t\tprintf(\"%d:\",(int)object[i].size());\n\t\t\tfor(int j=0;j<(int)object[i].size();j++){\n\t\t\t\tprintf(\"%d \",object[i][j]);\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t\t*/\n\t\tfor(int i=0;i<(int)object.size();i++){\n\t\t\tvector<ll> kari;\n\t\t\tfor(int j=0;j<((int)object[i].size())-1;j++){\n\t\t\t\t//printf(\"%d %d\\n\",i,j);\n\t\t\t\tll x=S-abs(X[object[i][j]]-X[object[i][j+1]]);\n\t\t\t\tll y=S-abs(Y[object[i][j]]-Y[object[i][j+1]]);\n\t\t\t\tll z=S-abs(Z[object[i][j]]-Z[object[i][j+1]]);\n\t\t\t\t//printf(\"%lld %lld %lld\\n\",x,y,z);\n\t\t\t\tll SS=2*x*y+2*y*z+2*z*x;\n\t\t\t\t//printf(\"%lld\\n\",SS);\n\t\t\t\tkari.pb(SS);\n\t\t\t\t//printf(\"%lld\\n\",SS);\n\t\t\t}\n\t\t\tint os=(int)object[i].size()-1;\n\t\t\tll x=S-abs(X[object[i][os]]-X[object[i][0]]);\n\t\t\tll y=S-abs(Y[object[i][os]]-Y[object[i][0]]);\n\t\t\tll z=S-abs(Z[object[i][os]]-Z[object[i][0]]);\n\t\t\tll SS=2*x*y+2*y*z+2*z*x;\n\t\t\tif(x<=0||y<=0||z<=0){SS=0;}\n\t\t\tkari.pb(SS);\n\t\t//\tprintf(\"%lld\\n\",SS);\n\t\t\tkyoutuu.pb(kari);\n\t\t}\n\t\tfor(int i=0;i<(int)object.size();i++){\n\t\t\tif((int)object[i].size()<K){continue;}\n\t\t\tif((int)G[object[i][0]].size()==1){\n\t\t\t\tll sum=0;\n\t\t\t\tfor(int j=0;j<K-1;j++){\n\t\t\t\t\tsum+=kyoutuu[i][j];\n\t\t\t\t}\n\t\t\t\tll cou=6*S*S*K-sum;\n\t\t\t\tans=min(ans,cou);\n\t\t\t\tfor(int j=K-1;j<(int)object[i].size();j++){\n\t\t\t\t\tcou=6*S*S*K;\n\t\t\t\t\tsum-=kyoutuu[i][j-K+1];\n\t\t\t\t\tsum+=kyoutuu[i][j];\n\t\t\t\t\tcou-=sum;\n\t\t\t\t\tans=min(ans,cou);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if((int)object[i].size()!=K){\n\t\t\t\tll sum=0;\n\t\t\t\tfor(int j=0;j<K-1;j++){\n\t\t\t\t\tsum+=kyoutuu[i][j];\n\t\t\t\t}\n\t\t\t\tll cou=6*S*S*K-sum;\n\t\t\t\t//printf(\"%lld\\n\",cou);\n\t\t\t\tans=min(ans,cou);\n\t\t\t\tfor(int j=0;j<(int)object[i].size();j++){\n\t\t\t\t\tcou=6*S*S*K;\n\t\t\t\t\tsum-=kyoutuu[i][j];\n\t\t\t\t\tif(j+K-1>=(int)object[i].size()){sum+=kyoutuu[i][j+K-1-(int)object[i].size()];}\n\t\t\t\t\telse{sum+=kyoutuu[i][(j+K-1)];}\n\t\t\t\t\tcou-=sum;\n\t\t\t\t\tans=min(ans,cou);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if((int)object[i].size()!=1){\n\t\t\t\tll sum=0;\n\t\t\t\tfor(int j=0;j<K;j++){\n\t\t\t\t\tsum+=kyoutuu[i][j];\n\t\t\t\t}\n\t\t\t\tll cou=6*S*S*K-sum;\n\t\t\t\tans=min(ans,cou);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tll cou=6*S*S*K;\n\t\t\t\tans=min(ans,cou);\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(ans==100000000000000){printf(\"-1\\n\");}\n\t\telse{printf(\"%lld\\n\",ans);}\n\t\t\n\t\t\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n#include <tuple>\n#include <map>\n#include <unordered_set>\n\n#define FOR(i, a, b) for(int i = (int)a; i < (int)b; ++i)\n#define REP(i, n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\nusing ll = long long;\ntemplate <class T, class U> void CHMAX(T & a, const U & b) { if (a < b) a = b; }\ntemplate <class T, class U> void CHMIN(T& a, const U& b) { if (a > b) a = b; }\n\nsigned main() {\n\tint n, k, s;\n\twhile (std::cin >> n >> k >> s, n || k || s) {\n\t\tstd::vector<int> x(n), y(n), z(n);\n\t\tREP(i, n) std::cin >> x[i] >> y[i] >> z[i];\n\n\t\tif (k == 1) {\n\t\t\tstd::cout << 6ll * s * s << std::endl;\n\t\t\tcontinue;\n\t\t}\n\n\t\tusing P = std::pair<int, ll>;\n\t\tstd::vector<std::vector<P>> g(n);\n\n\t\tREP(i, n) FOR(j, i + 1, n) {\n\t\t\tint tx = 0;\n\t\t\tif (x[i] <= x[j]) CHMAX(tx, (x[i] + s) - (x[j]));\n\t\t\telse CHMAX(tx, (x[j] + s) - (x[i]));\n\t\t\tint ty = 0;\n\t\t\tif (y[i] <= y[j]) CHMAX(ty, (y[i] + s) - (y[j]));\n\t\t\telse CHMAX(ty, (y[j] + s) - (y[i]));\n\t\t\tint tz = 0;\n\t\t\tif (z[i] <= z[j]) CHMAX(tz, (z[i] + s) - (z[j]));\n\t\t\telse CHMAX(tz, (z[j] + s) - (z[i]));\n\n\t\t\tif (tx == 0 || ty == 0 || tz == 0) continue;\n\t\t\tll cost = 2ll * tx * ty + 2ll * ty * tz + 2ll * tz * tx;\n\t\t\tg[i].emplace_back(j, cost);\n\t\t\tg[j].emplace_back(i, cost);\n\t\t}\n\n\t\tll ma = -1;\n\t\tREP(i, n) {\n\t\t\tfor (P e0 : g[i]) {\n\t\t\t\tstd::unordered_set<int> st; st.reserve(k);\n\t\t\t\tll sum = e0.second;\n\t\t\t\tst.insert(i);\n\t\t\t\tst.insert(e0.first);\n\n\t\t\t\tint pre = i, cur = e0.first, cnt = 2;\n\t\t\t\twhile (cnt < k) {\n\t\t\t\t\tbool f = false;\n\t\t\t\t\tfor (auto& e : g[cur]) {\n\t\t\t\t\t\tint nex = e.first;\n\t\t\t\t\t\tll cost = e.second;\n\t\t\t\t\t\tif (st.count(nex)) continue;\n\t\t\t\t\t\tst.insert(nex);\n\t\t\t\t\t\tf = true;\n\t\t\t\t\t\tsum += cost;\n\t\t\t\t\t\tpre = cur;\n\t\t\t\t\t\tcur = nex;\n\t\t\t\t\t\t++cnt;\n\t\t\t\t\t}\n\t\t\t\t\tif (!f) break;\n\t\t\t\t}\n\t\t\t\tif (st.size() != k) continue;\n\t\t\t\tif (k != 2) {\n\t\t\t\t\tfor (auto& e : g[cur]) {\n\t\t\t\t\t\tif (e.first == i) {\n\t\t\t\t\t\t\tsum += e.second;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tCHMAX(ma, sum);\n\t\t\t}\n\t\t}\n\n\t\tll ans = 6ll * s * s * k;\n\t\tif (ma == -1) ans = -1;\n\t\telse ans -= ma;\n\n\t\tstd::cout << ans << std::endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n#include <cstdlib>\nusing namespace std;\nconst int inf = 1e9;\nint x[2000], y[2000], z[2000];\nbool used[2000];\nint n,k,s;\n\nvoid dfs(int node, int prev, vector<vector<int> > &adj, vector<int> &ret){\n    if(used[node]) return;\n    used[node] = true;\n    for(size_t i=0; i<adj[node].size(); i++){\n        int next = adj[node][i];\n        if(next != prev){\n            int dx = s -abs(x[node]-x[next]);\n            int dy = s -abs(y[node]-y[next]);\n            int dz = s -abs(z[node]-z[next]);\n            ret.push_back(2*(dx*dy +dy*dz +dz*dx));\n            dfs(next, node, adj, ret);\n        }\n    }\n}\n\nint solve(int k, vector<vector<int> > &adj){\n    memset(used, 0, sizeof(used));\n    int res = inf;\n    for(int d=0; d<2; d++){\n        for(int i=0; i<n; i++){\n            if(used[i]) continue;\n            if(d==0 && (int)adj[i].size()>=2) continue;\n            vector<int> ret;\n            int pre = (d==0)? -1: adj[i][0];\n            dfs(i, pre, adj, ret);\n            int m = ret.size();\n            if((d==0 && m+1<k) || (d==1 && m<k)) continue;\n            int rep = (d==1 && m==k)? k: k-1;\n            for(int j=0; (d==0)? j<m-k+2: j<m; j++){\n                int sur = k*6*s*s;\n                for(int r=0; r<rep; r++){\n                    sur -= ret[(j+r)%m];\n                }\n                res = min(res, sur);\n            }\n        }\n    }\n    return (res==inf)? -1 : res;\n}\n\nint main(){\n    while(1){\n        cin >> n >> k >> s;\n        if(n==0) break;\n        \n        for(int i=0; i<n; i++){\n            cin >> x[i] >> y[i] >> z[i];\n        }\n        vector<vector<int> > adj(n);\n        for(int i=0; i<n; i++){\n            for(int j=i+1; j<n; j++){\n                if(abs(x[i]-x[j])<s && abs(y[i]-y[j])<s && abs(z[i]-z[j])<s){\n                    adj[i].push_back(j);\n                    adj[j].push_back(i);\n                }\n            }\n        }\n        cout << solve(k, adj) << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <functional>\nusing namespace std;\n\nstruct cube {\n    int x, y, z, w;\n    cube() {}\n    cube(int a, int b, int c, int d): x(a), y(b), z(c), w(d) {}\n\n    int overlap_area(cube o) {\n        int ox = w - abs(x - o.x);\n        int oy = w - abs(y - o.y);\n        int oz = w - abs(z - o.z);\n\n        if (ox < 0 || oy < 0 || oz < 0) {\n            return -1;\n        }\n\n        return 2 * (ox * oy + oy * oz + oz * ox);\n    }\n};\n\nint main() {\n    int N, K, S;\n    while (true) {\n        cin >> N >> K >> S;\n        if (N == 0 && K == 0 && S == 0) break;\n\n        vector<cube> cubes;\n        vector<vector<int>> graph(N);\n\n        for (int j = 0; j < N; ++j) {\n            int x, y, z; cin >> x >> y >> z;\n            cubes.emplace_back(x, y, z, S);\n        }\n\n        if (K == 1) {\n            cout << 6*S*S << endl;\n            continue;\n        }\n\n        for (int j = 0; j < N; ++j) {\n            for (int k = j+1; k < N; ++k) {\n                int area = cubes[j].overlap_area(cubes[k]);\n                if (area >= 0) {\n                    graph[j].push_back(k);\n                    graph[k].push_back(j);\n                }\n            }\n        }\n\n        vector<int> visited(N, 0);\n        function<int(int)> get_start = [&](int v) -> int {\n            visited[v] = 1;\n            for (int w: graph[v]) {\n                if (!visited[w])\n                    return get_start(w);\n            }\n            return v;\n        };\n\n        int ans = -1;\n\n        for (int j = 0; j < N; ++j) {\n            if (visited[j])\n                continue;\n            int s = get_start(j);\n\n            vector<int> chain;\n            function<bool(int, int)> set_chain = [&](int v, int prev) -> bool {\n                chain.push_back(v);\n                visited[v] = 1;\n                for (int w: graph[v]) {\n                    if (w == prev) continue;\n                    if (w == s) return true; \n                    return set_chain(w, v);\n                }\n                return false;\n            };\n            bool loop = set_chain(s, -1);\n\n            const int L = chain.size();\n            if (L < K) continue;\n\n            int area = 6*S*S;\n            for (int j = 1; j < (loop ? 2*L : L); ++j) {\n                if (j >= K) {\n                    int v0 = chain[(j-K)%L], v1 = chain[(j-K+1)%L];\n                    area -= 6*S*S - cubes[v0].overlap_area(cubes[v1]);\n                }\n                area += 6*S*S - cubes[chain[(j-1)%L]].overlap_area(cubes[chain[j%L]]);\n\n                if (loop && L == K && j >= L-1)\n                    area -= cubes[chain[j%L]].overlap_area(cubes[chain[(j+1)%L]]);\n\n                if (j+1 >= K)\n                    ans = (ans == -1) ? area : min(ans, area);\n            }\n        }\n\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <array>\n#include <cassert>\n#include <climits>\n#include <complex>\n#include <cstdio>\n#include <cstring>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <iterator>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <string>\n#include <tuple>\n#include <vector>\n\nusing namespace std;\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define ALL(x) (x).begin(), (x).end()\n\nint subcube(int len, int x0, int y0, int z0, int x1, int y1, int z1) {\n    int dx = x0 - x1, dy = y0 - y1, dz = z0 - z1;\n    int sx = max(min(len + dx, len - dx), 0);\n    int sy = max(min(len + dy, len - dy), 0);\n    int sz = max(min(len + dz, len - dz), 0);\n    return (sx * sy * sz == 0) ? 0 : 2 * (sx * sy + sy * sz + sz * sx);\n}\n\nint main(){\n    int n, k, s; \n    while(cin >> n >> k >> s, n != 0){\n    vector<int> xs(n), ys(n), zs(n);\n    REP(i, n) {\n        cin >> xs[i] >> ys[i] >> zs[i];\n    }\n\n    if (k == 1) {\n        cout << s * s * 6 * k << endl;\n        continue;\n    }\n\n    vector<vector<int>> subc(n, vector<int>(n));\n    REP(a, n) {\n        REP(b, n) {\n            if (a == b) {/*cout << \"--\\t\";*/ continue;}\n            subc[a][b] = subcube(s, xs[a], ys[a], zs[a], xs[b], ys[b], zs[b]);\n            //cout << subc[a][b] << \"\\t\";\n        }\n        //cout << endl;\n    }\n\n    vector<vector<int>> segs;\n    vector<int> used(n, false);\n\n    /// 4 8 12 16 20\n    REP(a, n){\n        if (used[a]) continue;\n        vector<int> seg;\n        int p = a; bool ok = true;\n        seg.push_back(p);\n        used[a] = true;\n        while(ok) {\n            ok = false;\n            REP(b, n) {\n                if (subc[p][b] > 0) {\n                    if (used[b]) continue;\n                    p = b;\n                    seg.push_back(p);\n                    used[b] = true;\n                    ok = true;\n                    break;\n                }\n            }\n        }\n        reverse(ALL(seg));\n        p = a;\n        ok = true;\n        while(ok) {\n            ok = false;\n            REP(b, n) {\n                //cout << \"?\" << a << \"->\" << b << endl;\n                if (subc[p][b] > 0) {\n                    if (used[b]) continue;\n                    p = b;\n                    seg.push_back(p);\n                    used[b] = true;\n                    ok = true;\n                    break;\n                }\n            }\n        }\n        segs.push_back(seg);\n    }\n\n    int res = -1;\n    REP(i, segs.size()) {\n        const vector<int> seg(segs[i]);\n        \n        /*cout << \"# \"; REP(a, seg.size()) {\n            cout << seg[a] << \" \";\n        } cout << endl;*/\n        \n        const int l = seg.size();\n        if (l < k) { continue; }\n        if (l == k) {\n            int sum = 0;\n            if (l == 2) {\n                res = max(res, subc[seg[0]][seg[1]]);\n                continue;\n            }\n            REP(a, l) {\n                //cout << \"+=\" << seg[a] << \" \" << seg[(a+1)%l] << endl;\n                //cout << \"   : \" << subc[seg[a]][seg[(a+1)%l]] << endl;\n                sum += subc[seg[a]][seg[(a+1)%l]];\n            }\n            res = max(res, sum);\n            continue;\n        }\n        int sum = 0;\n        REP(a, k - 1) {\n            sum += subc[seg[a]][seg[a+1]];\n        }\n        REP(a, l) {\n            res = max(res, sum);\n            int ad = subc[seg[(a + k - 1) % l]][seg[(a + k) % l]];\n            if (ad == 0) break;\n            sum += ad;\n            sum -= subc[seg[(a % l)]][seg[(a + 1) % l]];\n        }\n    }\n\n    // cout << \"$\" << subc[0][1] << endl;\n    // cout << res << endl;\n    if (res < 0) cout << res << endl;\n    else cout << s * s * 6 * k - res << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 2001\n#define int long long\nusing namespace std;\nvector<int>G[N];\nint n,K,S;\nstruct point{int x,y,z;};\n\nint Area(){return S*S*6;}\nint sArea(point a,point b){\n  int x = min(a.x+S, b.x+S),X = max(a.x,b.x);\n  int y = min(a.y+S, b.y+S),Y = max(a.y,b.y);\n  int z = min(a.z+S, b.z+S),Z = max(a.z,b.z);\n  if(y <= Y || x <= X || z <= Z) return 0;\n  int area=0;\n  area += 2*(x-X)*(y-Y);\n  area += 2*(y-Y)*(z-Z);\n  area += 2*(z-Z)*(x-X);\n  return area;\n}\n\nvector<point> A;\nint used[N];\nint dfs(int pos,int k,int start,int prev){\n  if(k == K) return prev==-1? 0:-sArea(A[pos],A[start]);\n  if(used[pos]++) return 1e9;\n  \n  int res = 1e9;\n  for(int nx:G[pos]){\n    if(nx == prev)continue;\n    int area = Area() - sArea(A[pos],A[nx]);\n    res = min(res,area+dfs(nx,k+1,start,pos));\n  }\n  return res;\n}\n\nsigned main(){\n  while(1){\n    cin>>n>>K>>S;\n    if(!n&&!K&&!S)break;\n    A.resize(n);\n    for(int i=0;i<n;i++)cin>>A[i].x>>A[i].y>>A[i].z;\n\n    for(int i=0;i<n;i++) G[i].clear();\n    for(int i=0;i<n;i++)\n      for(int j=i+1;j<n;j++){\n\tif(!sArea(A[i],A[j]))continue;\n\tG[i].push_back(j);\n\tG[j].push_back(i);\n      }\n    int ans = 1e9;\n    for(int i=0;i<n;i++){\n      memset(used,0,sizeof(used));\n      ans = min(ans,Area()+dfs(i,1,i,-1));\n    }\n    if(ans == 1e9) ans = -1;\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <cmath>\n#include <cstdlib>\n#include <map>\nusing namespace std;\n\nclass Point {\npublic:\n    int x, y, z;\n    Point(int x = 0, int y = 0, int z = 0) : x(x), y(y), z(z) {}\n};\n\nclass Cube {\npublic:\n    Point p;\n    int s;\n    int vx[4] = {0, 1, 1, 0}, vy[4] = {0, 0, 1, 1}, vz[2] = {0, 1};\n    Cube(Point p = Point(), int s = 0) : p(p), s(s) {}\n\n    bool isIn(const Cube &c) {\n        return ((abs(p.x - c.p.x) < s) && (abs(p.y - c.p.y) <= s) && (abs(p.z - c.p.z) <= s) &&\n                (abs(p.x - c.p.x) <= s) && (abs(p.y - c.p.y) < s) && (abs(p.z - c.p.z) <= s) &&\n                (abs(p.x - c.p.x) <= s) && (abs(p.y - c.p.y) <= s) && (abs(p.z - c.p.z) < s));\n    }\n\n    long long shareS(Cube &c) {\n        long long ret = 0;\n        Point a, b;\n        a = p; b = c.p;\n\n        if (a.x > b.x) swap(a.x, b.x);\n        if (a.y > b.y) swap(a.y, b.y);\n        if (a.z > b.z) swap(a.z, b.z);\n\n        ret += abs((a.x + s - b.x) * (a.z + s - b.z) * 2);\n        ret += abs((a.y + s - b.y) * (a.z + s - b.z) * 2);\n        ret += abs((a.x + s - b.x) * (a.y + s - b.y) * 2);\n        return ret;\n    }\n\n};\n\nint n, k, s, x, y, z;\nlong long ans;\nvector<Cube> c;\nvector<vector<int> > subg;\nvector<bool> used;\nvector<deque<int> > graph;\ndeque<int> que;\n\ninline void makegraph() {\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            if (c[i].isIn(c[j])) {\n                subg[j].push_back(i);\n                subg[i].push_back(j);\n            }\n        }\n    }\n}\n\n// make path\nvoid dfs(int v) {\n    used[v] = true;\n    int size_ = subg[v].size();\n    bool flag = false;\n\n    for (int i = 0; i < size_; ++i) {\n        if (!used[subg[v][i]]) {\n            dfs(subg[v][i]);\n            if (!flag) que.push_front(v);\n            flag = true;\n        }\n    }\n\n    if (!flag) que.push_front(v);\n}\n\n// is graph[graphid] cycle ?\ninline bool isCycle(int graphid) {\n    int size_ = graph[graphid].size();\n\n    // if all vertex's degree are two, this graph has closed path.\n    for (int i = 0; i < size_; ++i) {\n        if (subg[graph[graphid][i]].size() != 2) return false;\n    }\n\n    return true;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    while (cin >> n >> k >> s, n | k | s) {\n        c.resize(n);\n        subg.resize(n);\n        que.clear();\n        used.assign(n, false);\n        ans = int(1e15);\n\n        for (int i = 0; i < n; ++i) {\n            cin >> x >> y >> z;\n            c[i] = {Point(x, y, z), s};    \n        }\n\n        makegraph();\n\n        for (int i = 0; i < n; ++i) {\n            if (!used[i]) {\n                dfs(i);\n                graph.push_back(que);\n                que.clear();\n            }\n        }\n\n        int gsize = graph.size(), qsize, upper;\n        long long share;\n        bool isGraphCycle = false;\n\n        for (int i = 0; i < gsize; ++i) {\n            qsize = graph[i].size();\n            isGraphCycle = isCycle(i);\n\n            if (qsize < k) continue;\n\n            for (int j = 0; j < qsize; ++j) {\n                share = 0;\n                //cout << \"isGraphCycle \" << isGraphCycle << endl;\n                if (!isGraphCycle && j + k - 1 >= qsize) continue;\n\n                for (int l = 0; l < k - 1; ++l) {\n                    //cout << (j + l) % qsize << \", \" << (j + l + 1) % qsize << endl;\n                    share += c[graph[i][(j + l) % qsize]].shareS(c[graph[i][(j + l + 1) % qsize]]);\n                }\n\n\n                if (isGraphCycle && qsize == k) {\n                    share += c[graph[i][j % qsize]].shareS(c[graph[i][(j + qsize - 1) % qsize]]);\n                }\n\n                ans = min(ans, 6 * s * s * k - share);\n            }\n        }\n\n        if (n == 1) ans = 6 * s * s;\n        if (ans == int(1e15)) ans = -1;\n\n        cout << ans << endl;\n        //cout << endl;\n\n        c.clear();\n        graph.clear();\n        subg.clear();\n        used.clear();\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define dbg(...) do{cerr<<__LINE__<<\": \";dbgprint(#__VA_ARGS__, __VA_ARGS__);}while(0);\n\nusing namespace std;\n\nnamespace std{template<class S,class T>struct hash<pair<S,T>>{size_t operator()(const pair<S,T>&p)const{return ((size_t)1e9+7)*hash<S>()(p.first)+hash<T>()(p.second);}};template<class T>struct hash<vector<T>>{size_t operator()(const vector<T> &v)const{size_t h=0;for(auto i : v)h=h*((size_t)1e9+7)+hash<T>()(i)+1;return h;}};}\ntemplate<class T>ostream& operator<<(ostream &os, const vector<T> &v){os<<\"[ \";rep(i,v.size())os<<v[i]<<(i==v.size()-1?\" ]\":\", \");return os;}template<class T>ostream& operator<<(ostream &os,const set<T> &v){os<<\"{ \"; for(const auto &i:v)os<<i<<\", \";return os<<\"}\";}\ntemplate<class T,class U>ostream& operator<<(ostream &os,const map<T,U> &v){os<<\"{\";for(const auto &i:v)os<<\" \"<<i.first<<\": \"<<i.second<<\",\";return os<<\"}\";}template<class T,class U>ostream& operator<<(ostream &os,const pair<T,U> &p){return os<<\"(\"<<p.first<<\", \"<<p.second<<\")\";}\nvoid dbgprint(const string &fmt){cerr<<endl;}template<class H,class... T>void dbgprint(const string &fmt,const H &h,const T&... r){cerr<<fmt.substr(0,fmt.find(\",\"))<<\"= \"<<h<<\" \";dbgprint(fmt.substr(fmt.find(\",\")+1),r...);}\ntypedef long long ll;typedef vector<int> vi;typedef pair<int,int> pi;const int inf = (int)1e9;const double INF = 1e12, EPS = 1e-9;\n\nint main(){\n\tcin.tie(0); cin.sync_with_stdio(0);\n\tint n, k, s;\n\twhile(cin >> n >> k >> s, n){\n\t\tvi x(n), y(n), z(n);\n\t\trep(i, n) cin >> x[i] >> y[i] >> z[i];\n\t\t\n\t\tauto intersect = [&](int i, int j){\n\t\t\tll dx = s - abs(x[i] - x[j]);\n\t\t\tll dy = s - abs(y[i] - y[j]);\n\t\t\tll dz = s - abs(z[i] - z[j]);\n\t\t\tif(dx <= 0 || dy <= 0 || dz <= 0) return 0ll;\n\t\t\treturn (dx * dy + dy * dz + dz * dx) * 2;\n\t\t};\n\t\t\n\t\tvector<vi> e(n);\n\t\trep(i, n) rep(j, i) if(intersect(i, j)){\n\t\t\te[i].pb(j);\n\t\t\te[j].pb(i);\n\t\t\t//dbg(i, j);\n\t\t}\n\t\trep(i, n) assert(e[i].size() <= 2);\n\t\t\n\t\tfunction<bool(int,int,vector<bool>&,vi&)> rec = [&](int c, int p, vector<bool> &v, vi &idx){\n\t\t\tv[c] = 1;\n\t\t\tbool ans = 0;\n\t\t\tidx.pb(c);\n\t\t\tfor(int i : e[c]) if(i != p){\n\t\t\t\tif(v[i]) ans |= 1;\n\t\t\t\telse ans |= rec(i, c, v, idx); \n\t\t\t}\n\t\t\treturn ans;\n\t\t};\n\t\t\n\t\tll ans = 1e18;\n\t\tvector<bool> v(n);\n\t\trep(ii, n) if(!v[ii]){\n\t\t\tvi idx;\n\t\t\tbool loop = rec(ii, ii, v, idx);\n\t\t\tif(idx.size() < k) continue;\n\t\t\t\n\t\t\tif(loop && idx.size() == k){\n\t\t\t\tll sum = 6ll * k * s * s;\n\t\t\t\trep(i, (int)idx.size()){\n\t\t\t\t\tll c = intersect(idx[i], idx[(i + 1) % idx.size()]);\n\t\t\t\t\tsum -= c;\n\t\t\t\t}\n\t\t\t\tans = min(ans, sum);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tll sum = 6ll * k * s * s;\n\t\t\tif(k == 1){\n\t\t\t\tans = min(ans, sum);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tvector<ll> costs;\n\t\t\tif(loop){\n\t\t\t\trep(i, (int)idx.size())\n\t\t\t\t\tcosts.pb(intersect(idx[i], idx[(i + 1) % idx.size()]));\n\t\t\t\tint it = idx.size();\n\t\t\t\trep(i, it) idx.pb(idx[i]);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tint hasi = 0;\n\t\t\t\trep(i, idx.size()) if(e[idx[i]].size() == 1) hasi = idx[i];\n\t\t\t\tfor(int i : idx) v[i] = 0;\n\t\t\t\tidx.clear();\n\t\t\t\trec(hasi, hasi, v, idx);\n\t\t\t\t\n\t\t\t\trep(i, (int)idx.size()-1)\n\t\t\t\t\tcosts.pb(intersect(idx[i], idx[i + 1]));\n\t\t\t\t#if 1\n\t\t\t\tassert(idx.size() >= 2);\n\t\t\t\trep(i, idx.size()){\n\t\t\t\t\tif(i==0 || i==idx.size()-1) assert(e[idx[i]].size() == 1);\n\t\t\t\t\telse assert(e[idx[i]].size()==2);\n\t\t\t\t\tassert(e[idx[i]].size() <= 2);\n\t\t\t\t\tassert(e[idx[i]].size() >= 1);\n\t\t\t\t}\n\t\t\t\t#endif\n\t\t\t}\n\t\t\t//dbg(k, costs);\n\t\t\t\n\t\t\trep(i, k-2) sum -= costs[i];\n\t\t\trep(i, (int)costs.size() - (k-1) + 1){\n\t\t\t\tsum -= costs[i + k-2];\n\t\t\t\tans = min(ans, sum);\n\t\t\t\tsum += costs[i];\n\t\t\t}\n\t\t}\n\t\tif(ans >= 1e18) ans = -1;\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\n#define int ll\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define PB push_back\n\nconst ll LLINF = (1LL<<60);\nconst int INF = (1LL<<30);\nconst int MOD = 1000000007;\n\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate <typename T> bool IN(T a, T b, T x) { return a<=x&&x<b; }\ntemplate<typename T> T ceil(T a, T b) { return a/b + !!(a%b); }\ntemplate<class S,class T>\nostream &operator <<(ostream& out,const pair<S,T>& a){\n  out<<'('<<a.first<<','<<a.second<<')';\n  return out;\n}\ntemplate<class T>\nostream &operator <<(ostream& out,const vector<T>& a){\n  out<<'[';\n  REP(i, a.size()) {out<<a[i];if(i!=a.size()-1)out<<',';}\n  out<<']';\n  return out;\n}\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\nvector<PII> g[2010];\nbool used[2010];\nint n, k, s, ans = -INF, st;\n\nvoid dfs(int x, int m, int cost) {\n  used[x] = true;\n  if(m == k) {\n    int tmp = 0;\n    for(auto e: g[x]) if(e.first == st) tmp = e.second;\n    if(3 <= k) cost += tmp;\n    chmax(ans, cost);\n    return;\n  }\n  for(auto e: g[x]) {\n    if(used[e.first]) continue;\n    dfs(e.first, m+1, cost + e.second);\n  }\n}\n\nsigned main(void)\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  while(true) {\n    cin >> n >> k >> s;\n    if(!n) break;\n    VI x(n), y(n), z(n);\n    REP(i, n) cin >> x[i] >> y[i] >> z[i];\n\n    ans = -INF;\n    REP(i, 2010) g[i].clear();\n    REP(i, n) FOR(j, i+1, n) {\n      // (i,j)が重複していたらその分の面積の重みの辺を張る\n      int dx = abs(x[i] - x[j]), dy = abs(y[i] - y[j]), dz = abs(z[i] - z[j]);\n      if(dx <= s && dy <= s && dz <= s) {\n        int cost = 2 * ((s-dx)*(s-dy) + (s-dy)*(s-dz) + (s-dz)*(s-dx));\n        g[i].PB({j, cost});\n        g[j].PB({i, cost});\n        // cout << i << \" \" << j << \" \" << cost << endl;\n      }\n    }\n\n    REP(i, n) {\n      // iからk個取る\n      memset(used, 0, sizeof(used));\n      st = i;\n      dfs(i, 1, 0);\n    }\n\n    // cout << s*s*6*k << \" \" << ans << endl;\n    if(ans == -INF) cout << -1 << endl;\n    else cout << s*s*6*k - ans << endl;\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 2001\n#define int long long\nusing namespace std;\nvector<int>G[N];\nint n,K,S;\nstruct point{int x,y,z;};\n\nint Area(){return S*S*6;}\nint sArea(point a,point b){\n  int x = min(a.x+S, b.x+S), X = max(a.x, b.x);\n  int y = min(a.y+S, b.y+S), Y = max(a.y, b.y);\n  int z = min(a.z+S, b.z+S), Z = max(a.z, b.z);\n  if(y <= Y || x <= X || z <= Z) return 0;\n  int area=0;\n  area += 2*(x-X)*(y-Y);\n  area += 2*(y-Y)*(z-Z);\n  area += 2*(z-Z)*(x-X);\n  return area;\n}\n\nvector<point> A;\nint dfs(int pos,int k,int start,int prev){\n  if(prev!=-1 && pos==start) return 1LL<<55;\n  if(k == K) return prev==-1||prev==start? 0:-sArea(A[pos],A[start]);\n  \n  int res = 1e9;\n  for(int nx:G[pos]){\n    if(nx == prev)continue;\n    int area = Area() - sArea(A[pos],A[nx]);\n    res = min(res,area+dfs(nx,k+1,start,pos));\n  }\n  return res;\n}\n\nsigned main(){\n  while(1){\n    cin>>n>>K>>S;\n    if(!n&&!K&&!S)break;\n    \n    A.resize(n);\n    for(int i=0;i<n;i++)cin>>A[i].x>>A[i].y>>A[i].z;\n    \n    for(int i=0;i<N;i++) G[i].clear();\n\n    for(int i=0;i<n;i++)\n      for(int j=i+1;j<n;j++){\n\tif(!sArea(A[i],A[j]))continue;\n\tG[i].push_back(j);\n\tG[j].push_back(i);\n      }\n\n    int ans = 1e9;\n    for(int i=0;i<n;i++)ans = min(ans,Area()+dfs(i,1,i,-1));\n    if(ans == 1e9) ans = -1;\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <cmath>\n#include <cstdlib>\n#include <map>\nusing namespace std;\n\nclass Point {\npublic:\n    int x, y, z;\n    Point(int x = 0, int y = 0, int z = 0) : x(x), y(y), z(z) {}\n};\n\nclass Cube {\npublic:\n    Point p;\n    int s;\n    int vx[4] = {0, 1, 1, 0}, vy[4] = {0, 0, 1, 1}, vz[2] = {0, 1};\n    Cube(Point p = Point(), int s = 0) : p(p), s(s) {}\n\n    bool isIn(const Cube &c) {\n        /*\n        int nx, ny, nz;\n        for (int i = 0; i < 2; ++i) {\n            for (int j = 0; j < 4; ++j) {\n                nx = c.p.x + c.s * vx[j];\n                ny = c.p.y + c.s * vy[j];\n                nz = c.p.z + c.s * vz[i];\n\n                if (p.x <= nx && nx <= p.x + s &&\n                    p.y <= ny && ny <= p.y + s &&\n                    p.z <= nz && nz <= p.z + s) {\n                        return true;\n                    }\n            }\n        return false;\n        }*/\n        return ((abs(p.x - c.p.x) < s) && (abs(p.y - c.p.y) <= s) && (abs(p.z - c.p.z) <= s) &&\n                (abs(p.x - c.p.x) <= s) && (abs(p.y - c.p.y) < s) && (abs(p.z - c.p.z) <= s) &&\n                (abs(p.x - c.p.x) <= s) && (abs(p.y - c.p.y) <= s) && (abs(p.z - c.p.z) < s));\n    }\n\n    long long shareS(Cube &c) {\n        long long ret = 0;\n        Point a, b;\n        a = p; b = c.p;\n\n        if (a.x > b.x) swap(a.x, b.x);\n        if (a.y > b.y) swap(a.y, b.y);\n        if (a.z > b.z) swap(a.z, b.z);\n\n        ret += abs((a.x + s - b.x) * (a.z + s - b.z) * 2);\n        ret += abs((a.y + s - b.y) * (a.z + s - b.z) * 2);\n        ret += abs((a.x + s - b.x) * (a.y + s - b.y) * 2);\n        return ret;\n    }\n\n};\n\nint n, k, s, x, y, z;\nlong long ans;\nvector<Cube> c;\nvector<vector<int> > subg;\nvector<bool> used;\nvector<deque<int> > graph;\ndeque<int> que;\n\n// not clever\ninline void makegraph() {\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            if (c[i].isIn(c[j])) {\n                subg[j].push_back(i);\n                subg[i].push_back(j);\n            }\n        }\n    }\n}\n\n// make path\nvoid dfs(int v) {\n    used[v] = true;\n    int size_ = subg[v].size();\n    bool flag = false;\n\n    for (int i = 0; i < size_; ++i) {\n        if (!used[subg[v][i]]) {\n            dfs(subg[v][i]);\n            if (!flag) que.push_front(v);\n            flag = true;\n        }\n    }\n\n    if (!flag) que.push_front(v);\n}\n\n// is graph[graphid] cycle ?\ninline bool isCycle(int graphid) {\n    int size_ = graph[graphid].size();\n\n    // if all vertex's degree are two, this graph is cycle.\n    for (int i = 0; i < size_; ++i) {\n        if (subg[graph[graphid][i]].size() != 2) return false;\n    }\n\n    return true;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    while (cin >> n >> k >> s, n | k | s) {\n        //cout << \"---- begin ----\" << endl;\n        c.resize(n);\n        subg.resize(n);\n        que.clear();\n        used.assign(n, false);\n        ans = int(1e15);\n\n        for (int i = 0; i < n; ++i) {\n            cin >> x >> y >> z;\n            c[i] = {Point(x, y, z), s};    \n        }\n\n        makegraph();\n\n        for (int i = 0; i < n; ++i) {\n            if (!used[i]) {\n                dfs(i);\n                graph.push_back(que);\n                que.clear();\n            }\n        }\n\n        /*\n        for (int i = 0; i < graph.size(); ++i) {\n            for (int j = 0; j < graph[i].size(); ++j) {\n                cout << graph[i][j] << \" \";\n            }\n            cout << endl;\n        }\n        */\n\n        int gsize = graph.size(), qsize, upper;\n        long long share;\n        bool isGraphCycle = false;\n\n        //cout << \"k = \" << k << endl;\n\n        for (int i = 0; i < gsize; ++i) {\n            qsize = graph[i].size();\n            isGraphCycle = isCycle(i);\n            if (isGraphCycle) {\n                upper = qsize + k - 1;\n            }\n            else upper = qsize;\n\n            if (qsize < k) continue;\n\n            for (int j = 0; j + k - 1 < upper; ++j) {\n                share = 0;\n                /*for (int l = 0; l < k - 1; ++l) {\n                    cout << graph[i][(j + l) % qsize] << \" \" << graph[i][(j + l + 1) % qsize] << endl;\n                }*/\n                //cout << graph[i][(j + k - 1) % qsize] << \" \" << graph[i][(j + k) % qsize] << endl;\n                //cout << endl;\n\n                for (int l = 0; l < k - 1; ++l) {\n                    //Cube a = c[graph[i][j + l]],\n                    //    b = c[graph[i][j + l + 1]];\n                    //cout << a.p.x << \" \" << a.p.y << \" \" << a.p.z << endl;\n                    //cout << b.p.x << \" \" << b.p.y << \" \" << b.p.z << endl;\n\n                    share += c[graph[i][(j + l) % qsize]].shareS(c[graph[i][(j + l + 1) % qsize]]);\n\n                    //cout << graph[i][(j + l) % qsize] << \" & \" << graph[i][(j + l + 1) % qsize] << endl;\n                    //cout << \"share is \" << tmp << endl;\n                }\n\n                if (isGraphCycle && qsize == k) {\n                    //cout << \"this is cycle\" << endl;\n                    share += c[graph[i][j]].shareS(c[graph[i][(j + qsize - 1) % qsize]]);\n                }\n\n                ans = min(ans, 6 * s * s * k - share);\n                //cout << \"all - share = \" << 6*s*s*k << endl;\n            }\n        }\n\n        if (n == 1) ans = 6 * s * s;\n        if (ans == int(1e15)) ans = -1;\n\n        cout << ans << endl;\n\n        //cout << \"---- end ----\" << endl;\n\n        c.clear();\n        graph.clear();\n        subg.clear();\n        used.clear();\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <math.h>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <bitset>\n#include <algorithm>\nusing namespace std;\n\nstruct xyz_t {\n    int x;\n    int y;\n    int z;\n    double length;       //一乗\n};\n\nstruct first_t {\n    int sec;\n    long long w;\n};\n\nbool asc(const xyz_t& left,const xyz_t& right);\nint next(int p,int q);\nint root(int p);\nvoid unite(int p,int q);\nint same(int p,int q);\nvoid pr(vector<vector<int> > pri);\nvoid nnn();\n\nvector<xyz_t> a;\nvector<int> tree;\nvector<int> endd;\nvector<vector<int> > tree_f;\nvector<vector<int> > kaburi;\nvector<vector<int> > tree_r;\nvector<int> num;\nvector<int> flg;\nlong long ans;\nint n,k,s;\ndouble LE;\nlong long sum;\nint rr;\n\nint main(){\n  scanf (\"%d %d %d\",&n,&k,&s);\n  while(n){\n    ans=0;\n    LE=sqrt(s*s*3.0);\n    xyz_t aaa={0,0,0,0};\n    a.assign(n,aaa);\n    tree.assign(n,-1);\n    endd.assign(n,-1);\n    tree_f.assign(n,vector<int>(1,0));\n    kaburi.assign(n,vector<int>(n,0));\n    tree_r.assign(n,vector<int>(0,0));\n    num.assign(n,1);\n    flg.assign(n,0);\n    for(int t=0;t<n;t++){\n      scanf (\"%d %d %d\",&a[t].x,&a[t].y,&a[t].z);\n      a[t].length=sqrt(a[t].x*a[t].x*1.0+a[t].y*a[t].y*1.0+a[t].z*a[t].z*1.0);\n    }\n    sort(a.begin(),a.end(),asc);\n    for(int i=0;i<n;i++){\n      tree[i]=i;\n      endd[i]=i;\n    }\n\n    switch(k){\n      case 1:\n        printf(\"%d\\n\",s*s*6);\n        break;\n      case 3:\n        for(int t=0;t<n-1;++t){\n          for(int s=t+1;(a[s].length<a[t].length+LE&&s<n);++s){\n            int xx=next(a[t].x,a[s].x);\n            int yy=next(a[t].y,a[s].y);\n            int zz=next(a[t].z,a[s].z);\n            if(xx&&yy&&zz){\n              if(same(t,s)==0){\n                int ee;\n                int eee;\n                  if(tree[t]==t&&tree[s]==s){\n                    //printf(\"%d %d\\n\",endd[t],endd[s]);\n                    ee=num[tree[t]];\n                    eee=num[tree[s]];\n                    num[tree[t]]=0;\n                    num[tree[s]]=0;\n                    num[endd[t]]=ee+eee;\n                    tree[t]=endd[t];\n                    tree[endd[t]]=endd[t];\n                    endd[endd[t]]=endd[s];\n                    unite(s,t);\n                  }\n                  else if(tree[t]!=t&&tree[s]==s){\n                    num[tree[t]]=num[tree[t]]+num[s];\n                    num[tree[s]]=0;\n                    endd[tree[t]]=endd[s];\n                    unite(s,t);\n                    //printf(\"%d\\n\",tree[t]);\n                  }\n                  else if(tree[t]==t&&tree[s]!=s){\n                    num[tree[s]]=num[t]+num[tree[s]];\n                    num[tree[t]]=0;\n                    endd[tree[s]]=endd[t];\n                    unite(t,s);\n                    //printf(\"%d\\n\",tree[s]);\n                  }\n                  else if(tree[t]!=t&&tree[s]!=s){\n                    num[tree[t]]=num[tree[t]]+num[tree[s]];\n                    num[tree[s]]=0;\n                    endd[tree[t]]=tree[s];\n                    unite(s,t);\n                    //printf(\"%d %d %d %d\\n\",t,s,tree[t],endd[tree[t]]);\n                  }\n                kaburi[s][t]=xx*yy+yy*zz+zz*xx;\n                  kaburi[t][s]=kaburi[s][t];\n                  tree_r[t].push_back(s);\n                  tree_r[s].push_back(t);\n                  //printf(\"%d %d %d\\n\",kaburi[q].back());\n                  //printf(\"%d %d %d\\n\",xx,yy,zz);\n                }\n              else{\n                kaburi[s][t]=xx*yy+yy*zz+zz*xx;\n                kaburi[t][s]=kaburi[s][t];\n                tree_r[t].push_back(s);\n                tree_r[s].push_back(t);\n                flg[tree[t]]=1;\n              }\n            }\n          }\n        }\n        //pr(kaburi);\n        for(int t=0;t<n;++t){\n          sum=0;\n          if(num[t]>=k){\n            if(flg[t]==0){\n              int u=t;\n              int uu=t;\n              tree_f[t][0]=t;\n              for(int r=0;r<k-1;++r){\n                rr=0;\n                if(tree_r[u][rr]==uu){\n                  ++rr;\n                }\n                sum+=kaburi[u][tree_r[u][rr]];\n                tree_f[t].push_back(tree_r[u][rr]);\n                uu=u;\n                u=tree_r[u][rr];\n              }\n              for(int r=k-1;r<num[t]-1;++r){\n                rr=0;\n                if(tree_r[u][rr]==uu){\n                  ++rr;\n                }\n                tree_f[t].push_back(tree_r[u][rr]);\n                uu=u;\n                u=tree_r[u][rr];\n              }\n              if(ans<sum){\n                ans=sum;\n              }\n              for(int r=0;r+k<num[t];++r){\n                sum=sum-kaburi[tree_f[t][r]][tree_f[t][r+1]]+kaburi[tree_f[t][r+k-1]][tree_f[t][r+k]];\n                if(ans<sum){\n                  ans=sum;\n                }\n              }\n            }\n            else{\n              if(num[t]!=k){\n                int u=t;\n                int uu=t;\n                tree_f[t][0]=t;\n                for(int r=0;r<k-1;++r){\n                  rr=0;\n                  if(tree_r[u][rr]==uu){\n                    ++rr;\n                  }\n                  sum+=kaburi[u][tree_r[u][rr]];\n                  tree_f[t].push_back(tree_r[u][rr]);\n                  uu=u;\n                  u=tree_r[u][rr];\n                }\n                for(int r=k-1;r<num[t]*2;++r){\n                  rr=0;\n                  if(tree_r[u][rr]==uu){\n                    ++rr;\n                  }\n                  tree_f[t].push_back(tree_r[u][rr]);\n                  uu=u;\n                  u=tree_r[u][rr];\n                }\n                if(ans<sum){\n                  ans=sum;\n                }\n                for(int r=0;r<num[t];++r){\n                  sum=sum-kaburi[tree_f[t][r]][tree_f[t][r+1]]+kaburi[tree_f[t][r+k-1]][tree_f[t][r+k]];\n                  if(ans<sum){\n                    ans=sum;\n                  }\n                  //printf(\"%lld\\n\",sum);\n                }\n                //pr(tree_f);\n              }\n              else{\n                if(num[t]!=3){\n                  int u=t;\n                  int uu=t;\n                  tree_f[t][0]=t;\n                  for(int r=0;r<k;++r){\n                    rr=0;\n                    if(tree_r[u][rr]==uu){\n                      ++rr;\n                    }\n                    sum+=kaburi[u][tree_r[u][rr]];\n                    uu=u;\n                    u=tree_r[u][rr];\n                  }\n                  if(ans<sum){\n                    ans=sum;\n                  }\n                }\n                else{\n                  int u=t;\n                  int uu=t;\n                  tree_f[t][0]=t;\n                  for(int r=0;r<k;++r){\n                    rr=0;\n                    if(tree_r[u][rr]==uu){\n                      ++rr;\n                    }\n                    sum+=kaburi[u][tree_r[u][rr]];\n                    tree_f[t].push_back(tree_r[u][rr]);\n                    uu=u;\n                    u=tree_r[u][rr];\n                  }\n                  int xxx=s+min({a[tree_f[t][0]].x,a[tree_f[t][1]].x,a[tree_f[t][2]].x})-max({a[tree_f[t][0]].x,a[tree_f[t][1]].x,a[tree_f[t][2]].x});\n                  int yyy=s+min({a[tree_f[t][0]].y,a[tree_f[t][1]].y,a[tree_f[t][2]].y})-max({a[tree_f[t][0]].y,a[tree_f[t][1]].y,a[tree_f[t][2]].y});\n                  int zzz=s+min({a[tree_f[t][0]].z,a[tree_f[t][1]].z,a[tree_f[t][2]].z})-max({a[tree_f[t][0]].z,a[tree_f[t][1]].z,a[tree_f[t][2]].z});\n                  sum=sum-(xxx*yyy+yyy*zzz+zzz*xxx);\n                  if(ans<sum){\n                    ans=sum;\n                  }\n                }\n              }\n            }\n          }\n        }\n        if(ans==0){\n          printf(\"-1\\n\");\n        }\n        else{\n          printf(\"%lld\\n\",s*s*6*k-ans*2);\n        }\n        break;\n      default:\n        for(int t=0;t<n-1;++t){\n          for(int s=t+1;(a[s].length<a[t].length+LE&&s<n);++s){\n            int xx=next(a[t].x,a[s].x);\n            int yy=next(a[t].y,a[s].y);\n            int zz=next(a[t].z,a[s].z);\n            if(xx&&yy&&zz){\n              if(same(t,s)==0){\n                /*if(num[t]==1){\n                  ++num[tree[s]];\n                  num[t]=0;\n                  unite(t,s);\n                  endd[tree[s]]=t;\n                }\n                else if(num[s]==1){\n                  ++num[tree[t]];\n                  num[s]=0;\n                  unite(s,t);\n                  endd[tree[t]]=s;\n                }*/\n                int ee;\n                int eee;\n                  if(tree[t]==t&&tree[s]==s){\n                    //printf(\"%d %d\\n\",endd[t],endd[s]);\n                    ee=num[tree[t]];\n                    eee=num[tree[s]];\n                    num[tree[t]]=0;\n                    num[tree[s]]=0;\n                    num[endd[t]]=ee+eee;\n                    tree[t]=endd[t];\n                    tree[endd[t]]=endd[t];\n                    endd[endd[t]]=endd[s];\n                    unite(s,t);\n                  }\n                  else if(tree[t]!=t&&tree[s]==s){\n                    num[tree[t]]=num[tree[t]]+num[s];\n                    num[tree[s]]=0;\n                    endd[tree[t]]=endd[s];\n                    unite(s,t);\n                    //printf(\"%d\\n\",tree[t]);\n                  }\n                  else if(tree[t]==t&&tree[s]!=s){\n                    num[tree[s]]=num[t]+num[tree[s]];\n                    num[tree[t]]=0;\n                    endd[tree[s]]=endd[t];\n                    unite(t,s);\n                    //printf(\"%d\\n\",tree[s]);\n                  }\n                  else if(tree[t]!=t&&tree[s]!=s){\n                    num[tree[t]]=num[tree[t]]+num[tree[s]];\n                    num[tree[s]]=0;\n                    endd[tree[t]]=tree[s];\n                    unite(s,t);\n                    //printf(\"%d %d %d %d\\n\",t,s,tree[t],endd[tree[t]]);\n                  }\n                kaburi[s][t]=xx*yy+yy*zz+zz*xx;\n                kaburi[t][s]=kaburi[s][t];\n                tree_r[t].push_back(s);\n                tree_r[s].push_back(t);\n                //printf(\"%d %d %d\\n\",kaburi[q].back());\n                //printf(\"%d %d %d\\n\",xx,yy,zz);\n              }\n              else{\n                kaburi[s][t]=xx*yy+yy*zz+zz*xx;\n                kaburi[t][s]=kaburi[s][t];\n                flg[tree[t]]=1;\n                tree_r[t].push_back(s);\n                tree_r[s].push_back(t);\n              }\n              //nnn();\n            }\n          }\n        }\n        for(int t=0;t<n;++t){\n          root(t);\n        }\n        /*for(int t=0;t<n-1;++t){\n          printf(\"%d \",num[t]);\n        }\n        printf(\"%d\\n\",num[n-1]);\n        pr(tree_r);\n        printf(\"\\n\");\n        for(int t=0;t<n-1;++t){\n          printf(\"%d \",tree[t]);\n        }\n        printf(\"%d\\n\",tree[n-1]);\n        printf(\"\\n\");*/\n        //pr(kaburi);\n        //printf(\"\\n\");\n        //pr(tree_r);\n        for(int t=0;t<n;++t){\n          sum=0;\n          if(num[t]>=k){\n            //printf(\"%d\\n\",flg[t]);\n            //printf(\"%d\\n\",t);\n            if(flg[t]==0){\n              int u=t;\n              int uu=t;\n              tree_f[t][0]=t;\n              for(int r=0;r<k-1;++r){//k-1\n                rr=0;\n                if(tree_r[u][rr]==uu){\n                  ++rr;\n                }\n                sum+=kaburi[u][tree_r[u][rr]];\n                tree_f[t].push_back(tree_r[u][rr]);\n                uu=u;\n                u=tree_r[u][rr];\n              }\n\n              /*for(int t=0;t<1;++t){\n                printf(\"%d \",tree_r[u][t]);\n              }\n              printf(\"%d\\n\",tree_r[u][1]);\n              printf(\"%d\\n\",t);*/\n              for(int r=k-1;r<num[t]-1;++r){\n                rr=0;\n                if(tree_r[u][rr]==uu){\n                  ++rr;\n                }\n                tree_f[t].push_back(tree_r[u][rr]);\n                uu=u;\n                u=tree_r[u][rr];\n              }\n              if(ans<sum){\n                ans=sum;\n              }\n              //printf(\"%lld\\n\",sum);\n              for(int r=0;r+k<num[t];++r){\n                sum=sum-kaburi[tree_f[t][r]][tree_f[t][r+1]]+kaburi[tree_f[t][r+k-1]][tree_f[t][r+k]];\n                //printf(\"%lld\\n\",sum);\n                if(ans<sum){\n                  ans=sum;\n                }\n              }\n            }\n            else{\n              if(num[t]!=k||k==2){\n                int u=t;\n                int uu=t;\n                tree_f[t][0]=t;\n                for(int r=0;r<k-1;++r){\n                  rr=0;\n                  if(tree_r[u][rr]==uu){\n                    ++rr;\n                  }\n                  sum+=kaburi[u][tree_r[u][rr]];\n                  tree_f[t].push_back(tree_r[u][rr]);\n                  uu=u;\n                  u=tree_r[u][rr];\n                }\n                for(int r=k-1;r<num[t]*2;++r){\n                  rr=0;\n                  if(tree_r[u][rr]==uu){\n                    ++rr;\n                  }\n                  tree_f[t].push_back(tree_r[u][rr]);\n                  uu=u;\n                  u=tree_r[u][rr];\n                }\n                if(ans<sum){\n                  ans=sum;\n                }\n                for(int r=0;r<num[t];++r){\n                  sum=sum-kaburi[tree_f[t][r]][tree_f[t][r+1]]+kaburi[tree_f[t][r+k-1]][tree_f[t][r+k]];\n                  if(ans<sum){\n                    ans=sum;\n                  }\n                  //printf(\"%lld\\n\",sum);\n                }\n                //pr(tree_f);\n              }\n              else{\n                int u=t;\n                int uu=t;\n                tree_f[t][0]=t;\n                for(int r=0;r<k;++r){\n                  rr=0;\n                  if(tree_r[u][rr]==uu){\n                    ++rr;\n                  }\n                  sum+=kaburi[u][tree_r[u][rr]];\n                  uu=u;\n                  u=tree_r[u][rr];\n                  //printf(\"%lld\\n\",sum);\n                }\n                if(ans<sum){\n                  ans=sum;\n                }\n              }\n            }\n          }\n        }\n        if(ans==0){\n          printf(\"-1\\n\");\n        }\n        else{\n          printf(\"%lld\\n\",s*s*6*k-ans*2);\n        }\n    }\n    scanf (\"%d %d %d\",&n,&k,&s);\n  }\n}\n/*\n環状 k=3の時 それ以外の時\n\n\n*/\n\n\nbool asc(const xyz_t& left,const xyz_t& right){\n  return left.length<right.length;\n}\n\nint next(int p,int q){\n  if(-s<=(p-q)&&(p-q)<=s){\n    if((p-q)>=0){\n      return s-(p-q);\n    }\n    else{\n      return s-(q-p);\n    }\n  }\n  else{\n    return 0;\n  }\n}\n\nint root(int p){\n  if (tree[p] == p){// 根\n    return p;\n  }\n  else {\n    return tree[p] = root(tree[p]); // 経路圧縮\n  }\n}\n\nvoid unite(int p, int q){\n  p = root(p);\n  q = root(q);\n  if (p == q){}\n  else{\n    tree[p] = q;     //pの親をqの親にする\n  }\n}\n\nint same(int p, int q){\n  return root(p) == root(q);\n}\n\n\n\nvoid pr(vector<vector<int> > pri){\n  for(int t=0;t<int(pri.size());++t){\n    for(int s=0;s<int(pri[t].size())-1;++s){\n      printf(\"%d \",pri[t][s]);\n    }\n    printf(\"%d\\n\",pri[t][pri[t].size()-1]);\n  }\n  printf(\"\\n\");\n}\n\nvoid nnn(){\n  for(int t=0;t<n-1;++t){\n    printf(\"%d \",num[t]);\n  }\n  printf(\"%d\\n\",num[n-1]);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define dbg(...) do{cerr<<__LINE__<<\": \";dbgprint(#__VA_ARGS__, __VA_ARGS__);}while(0);\n\nusing namespace std;\n\nnamespace std{template<class S,class T>struct hash<pair<S,T>>{size_t operator()(const pair<S,T>&p)const{return ((size_t)1e9+7)*hash<S>()(p.first)+hash<T>()(p.second);}};template<class T>struct hash<vector<T>>{size_t operator()(const vector<T> &v)const{size_t h=0;for(auto i : v)h=h*((size_t)1e9+7)+hash<T>()(i)+1;return h;}};}\ntemplate<class T>ostream& operator<<(ostream &os, const vector<T> &v){os<<\"[ \";rep(i,v.size())os<<v[i]<<(i==v.size()-1?\" ]\":\", \");return os;}template<class T>ostream& operator<<(ostream &os,const set<T> &v){os<<\"{ \"; for(const auto &i:v)os<<i<<\", \";return os<<\"}\";}\ntemplate<class T,class U>ostream& operator<<(ostream &os,const map<T,U> &v){os<<\"{\";for(const auto &i:v)os<<\" \"<<i.first<<\": \"<<i.second<<\",\";return os<<\"}\";}template<class T,class U>ostream& operator<<(ostream &os,const pair<T,U> &p){return os<<\"(\"<<p.first<<\", \"<<p.second<<\")\";}\nvoid dbgprint(const string &fmt){cerr<<endl;}template<class H,class... T>void dbgprint(const string &fmt,const H &h,const T&... r){cerr<<fmt.substr(0,fmt.find(\",\"))<<\"= \"<<h<<\" \";dbgprint(fmt.substr(fmt.find(\",\")+1),r...);}\ntypedef long long ll;typedef vector<int> vi;typedef pair<int,int> pi;const int inf = (int)1e9;const double INF = 1e12, EPS = 1e-9;\n\nint main(){\n\tcin.tie(0); cin.sync_with_stdio(0);\n\tint n, k, s;\n\twhile(cin >> n >> k >> s, n){\n\t\tvi x(n), y(n), z(n);\n\t\trep(i, n) cin >> x[i] >> y[i] >> z[i];\n\t\t\n\t\tauto intersect = [&](int i, int j){\n\t\t\tll dx = s - abs(x[i] - x[j]);\n\t\t\tll dy = s - abs(y[i] - y[j]);\n\t\t\tll dz = s - abs(z[i] - z[j]);\n\t\t\tif(dx <= 0 || dy <= 0 || dz <= 0) return 0ll;\n\t\t\treturn (dx * dy + dy * dz + dz * dx) * 2;\n\t\t};\n\t\t\n\t\tvector<vi> e(n);\n\t\trep(i, n) rep(j, i) if(intersect(i, j)){\n\t\t\te[i].pb(j);\n\t\t\te[j].pb(i);\n\t\t\t//dbg(i, j);\n\t\t}\n\t\t\n\t\tfunction<bool(int,int,vector<bool>&,vi&)> rec = [&](int c, int p, vector<bool> &v, vi &idx){\n\t\t\tv[c] = 1;\n\t\t\tbool ans = 0;\n\t\t\tidx.pb(c);\n\t\t\tfor(int i : e[c]) if(i != p){\n\t\t\t\tif(v[i]) ans |= 1;\n\t\t\t\telse ans |= rec(i, c, v, idx); \n\t\t\t}\n\t\t\treturn ans;\n\t\t};\n\t\t\n\t\tll ans = 1e18;\n\t\tvector<bool> v(n);\n\t\trep(ii, n) if(!v[ii]){\n\t\t\tvi idx;\n\t\t\tbool loop = rec(ii, ii, v, idx);\n\t\t\tif(idx.size() < k) continue;\n\t\t\t\n\t\t\tif(loop && idx.size() == k){\n\t\t\t\tll sum = 6ll * k * s * s;\n\t\t\t\trep(i, (int)idx.size()){\n\t\t\t\t\tll c = intersect(idx[i], idx[(i + 1) % idx.size()]);\n\t\t\t\t\tsum -= c;\n\t\t\t\t}\n\t\t\t\tans = min(ans, sum);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tvector<ll> costs;\n\t\t\t\tif(loop){\n\t\t\t\t\trep(i, (int)idx.size())\n\t\t\t\t\t\tcosts.pb(intersect(idx[i], idx[(i + 1) % idx.size()]));\n\t\t\t\t\tint it = idx.size();\n\t\t\t\t\trep(i, it) idx.pb(idx[i]);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tint hasi = 0;\n\t\t\t\t\trep(i, idx.size()) if(e[idx[i]].size() == 1) hasi = idx[i];\n\t\t\t\t\tfor(int i : idx) v[i] = 0;\n\t\t\t\t\tidx.clear();\n\t\t\t\t\trec(hasi, hasi, v, idx);\n\t\t\t\t\t\n\t\t\t\t\trep(i, (int)idx.size()-1)\n\t\t\t\t\t\tcosts.pb(intersect(idx[i], idx[i + 1]));\n\t\t\t\t\t\n\t\t\t\t\trep(i, idx.size()){\n\t\t\t\t\t\t//if(i==0 || i==idx.size()-1) assert(e[idx[i]].size() <= 1);\n\t\t\t\t\t\t//else assert(e[idx[i]].size()==2);\n\t\t\t\t\t\tassert(e[idx[i]].size() <= 2);\n\t\t\t\t\t\tassert(e[idx[i]].size() >= 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//dbg(k, costs);\n\t\t\t\t\n\t\t\t\tll sum = 6ll * k * s * s;\n\t\t\t\tif(k == 1){\n\t\t\t\t\tans = min(ans, sum);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\trep(i, k-2) sum -= costs[i];\n\t\t\t\trep(i, (int)costs.size() - (k-1) + 1){\n\t\t\t\t\tsum -= costs[i + k-2];\n\t\t\t\t\tans = min(ans, sum);\n\t\t\t\t\tsum += costs[i];\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tif(ans >= 1e18) ans = -1;\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i,n) for(int i = 0;i < (n);i++)\nconst int INF = 1e+9;\nusing namespace std;\n\nint N, K, S;\n\nstruct Point{\n    int x, y, z;\n};\n\nPoint p[2103];\n\nbool used[2103];\nvector<int> graph[2003];\n\nint getS(int u, int v){\n    Point a = p[u], b = p[v];\n    if(a.x > b.x) swap(a.x, b.x);\n    if(a.y > b.y) swap(a.y, b.y);\n    if(a.z > b.z) swap(a.z, b.z);\n    return (a.x + S - b.x) * (a.y + S - b.y) * 2\n        +  (a.z + S - b.z) * (a.x + S - b.x) * 2\n        +  (a.y + S - b.y) * (a.z + S - b.z) * 2;\n}\n\nbool connected(int a,int b){\n    return (abs(p[a].x-p[b].x) <= S) && (abs(p[a].y-p[b].y) <= S) && (abs(p[a].z-p[b].z) <= S);\n}\n\nint main(){\n    while(cin >> N >> K >> S, N){\n        REP(i,N){\n            int x, y, z;\n            cin >> x >> y >> z;\n            p[i] = Point{x, y, z};\n            graph[i].clear();\n        }\n\n        if(K == 1){\n            cout << S*S*6 << endl;\n            continue;\n        }\n\n        REP(i,N){\n            for(int j = i + 1;j < N;j++){\n                if(connected(i, j)){\n                    graph[i].push_back(j);\n                    graph[j].push_back(i);\n                }\n            }     \n        }\n        \n        int ans = INF;\n        REP(firstv,N){\n            for(int secondv : graph[firstv]){\n                int res = S*S*6*K - getS(firstv, secondv);\n                int endindex = -1;\n                queue<int> que;\n                que.push(secondv);\n                fill_n(used, N, false);\n                used[firstv] = true;\n                used[secondv] = true;\n                int ct = 2;\n                while(!que.empty()){\n                    if(ct == K) break;\n                    int u = que.front();\n                    que.pop();\n                    for(int v : graph[u]){\n                        if(used[v]) continue;\n                        used[v] = true;\n                        que.push(v);\n                        endindex = v;\n                        ct++;\n                        res -= getS(u, v);\n                        break;\n                    }\n                }\n                if(connected(firstv,endindex) && K >= 3){\n                    res -= getS(firstv, endindex);\n                }\n                if(ct == K) ans = min(res, ans);\n            }\n        }\n        if(ans == INF) cout << -1 << endl;\n        else cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i, j) for(int i=0; i < (int)(j); i++)\ntemplate<class T> bool set_min(T &a, const T &b) { return a > b  ? a = b, true : false; }\nconst ll INFL = 1LL << 60;\n\nstruct UnionFind {\n    vector<int> p;\n    UnionFind(int n) {\n        p.resize(n);\n        rep(i,n) p[i] = i;\n    }\n    int root(int x){\n        if(p[x] == x) return x;\n        else return p[x] = root(p[x]);\n    }\n    void unite(int x,int y){\n        x = root(x);\n        y = root(y);\n        if(x != y) p[y] = x;\n    }\n    bool query(int x,int y){\n        return root(x) == root(y);\n    }\n    vector<vector<int>> group() {\n        vector<vector<int>> res;\n        vector<int> index(p.size(), -1);\n        rep(i, p.size()) {\n            int r = root(i);\n            if(index[r] < 0) {\n                index[r] = res.size();\n                res.push_back({});                \n            }\n            res[index[r]].push_back(i);\n        }\n        return res;\n    }\n};\n\nstruct Point {\n    int x, y, z;    \n};\nostream& operator << (ostream &os, const Point &a) {\n    return os << \"(\" << a.x << \", \" << a.y << \", \" << a.z << \")\";\n}\nusing Rectangle = Point;\n\nclass Solver {\n  public:\n    int N, K, S;\n    vector<Rectangle> P;\n    \n    vector<Point> get_points(Rectangle a) {\n        vector<Point> res;\n        for(int i = 0; i < (1 << 3); i++) {\n            auto b = a;\n            if(i & (1 << 0)) b.x += S;\n            if(i & (1 << 1)) b.y += S;\n            if(i & (1 << 2)) b.z += S;\n            res.push_back(b);\n        }\n        return res;\n    }\n    bool does_include(Rectangle a, Point p) {\n        bool ok = true;\n        ok &= a.x <= p.x and p.x <= a.x + S;\n        ok &= a.y <= p.y and p.y <= a.y + S;\n        ok &= a.z <= p.z and p.z <= a.z + S;\n        return ok;\n    }\n    bool does_cross(Rectangle a, Rectangle b) {\n        for(Point &p : get_points(b)) if(does_include(a, p)) return true;\n        return false;\n    }\n    Point get_in_point(Rectangle a, Rectangle b) {\n        for(Point &p : get_points(b)) if(does_include(a, p)) return p;\n        assert(false);\n    }\n    ll calc_surface(vector<vector<int>> &E, int now, int prev) {\n        if(E[now].size() == 0) return K == 1 ? 6 * S * S : INFL;\n        int first = now;\n        ll sum = 0;        \n        rep(i, K) {\n            sum += 6 * S * S;            \n            if(E[now].size() == 1 and E[now][0] == prev) return i == K - 1 ? sum : INFL;\n            \n            int nxt = E[now][ E[now][0] != prev ? 0 : 1];            \n            Point a = get_in_point(P[now], P[nxt]), b = get_in_point(P[nxt], P[now]);\n            int dx = abs(a.x - b.x), dy = abs(a.y - b.y), dz = abs(a.z - b.z);\n            if(dx == 0) dx = S;\n            if(dy == 0) dy = S;\n            if(dz == 0) dz = S;\n           \n            if(i < K - 1 or nxt == first) sum -= 2 * (dx * dy + dy * dz + dz * dx);\n\n            prev = now;\n            now = nxt;\n        }\n        return sum;\n    }\n    bool solve() {\n        cin >> N >> K >> S;\n        if(N == 0) return false;\n        P.resize(N);\n        rep(i, N) cin >> P[i].x >> P[i].y >> P[i].z;\n\n        vector<vector<int>> E(N);\n        UnionFind uf(N);\n\n        rep(i, N) rep(j, i) {\n            if(does_cross(P[i], P[j])) {\n                uf.unite(i, j);\n                E[i].push_back(j);\n                E[j].push_back(i);\n            }\n        }\n        ll ans = INFL;\n        for(vector<int> g : uf.group()) {\n            if(g.size() < K) continue;\n            int now = -1, prev = -1;\n            { // get end point (and set prev when g is circle)\n                for(int i : g) if(E[i].size() == 1) now = i;\n                if(now < 0) { // circle\n                    now = g.front();\n                    prev = E[now].size() == 2 ? E[now][1] : -1;\n                }\n            }\n            rep(i, g.size()) {\n                set_min(ans, calc_surface(E, now, prev));\n                int nxt;\n                if(E[now].size() == 1) {\n                    if(prev > 0) break;\n                    nxt = E[now][0];\n                }\n                else if(E[now].size() == 2) {\n                    nxt = E[now][ E[now][0] != prev ? 0 : 1];                    \n                }\n                prev = now;\n                now = nxt;\n            }\n        }\n        cout << (ans == INFL ? -1 : ans) << endl;\n        \n        return true;\n    }\n};\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while(Solver().solve());\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\nconst int INF = 1LL << 58;\n\nstruct edge\n{\n  int to, cost;\n};\n\nsigned main()\n{\n  int N, K, S;\n  int X[2000], Y[2000], Z[2000];\n\n  while(cin >> N >> K >> S, N) {\n    for(int i = 0; i < N; i++) {\n      cin >> X[i] >> Y[i] >> Z[i];\n    }\n\n    vector< edge > g[2000];\n    for(int i = 0; i < N; i++) {\n      for(int j = 0; j < i; j++) {\n        int latte = max(0LL, S - abs(X[i] - X[j]));\n        int malta = max(0LL, S - abs(Y[i] - Y[j]));\n        int beeet = max(0LL, S - abs(Z[i] - Z[j]));\n        int ukuku = latte * malta + malta * beeet + beeet * latte;\n        if(latte > 0 && malta > 0 && beeet > 0) {\n          g[i].emplace_back((edge) {j, ukuku});\n          g[j].emplace_back((edge) {i, ukuku});\n        }\n      }\n    }\n\n    int ret = -1;\n    for(int i = 0; i < N; i++) {\n      bool v[2000] = {};\n      function< void(int, int, int) > dfs = [&](int idx, int k, int sz)\n      {\n        if(v[idx]++) return;\n        if(k == 0) {\n          if(K >= 3) for(auto &e: g[idx]) if(e.to == i) sz += e.cost;\n          ret = max(ret, sz);\n        } else {\n          for(auto &e : g[idx]) dfs(e.to, k - 1, sz + e.cost);\n        }\n      };\n      dfs(i, K - 1, 0);\n    }\n    if(ret == -1) cout << -1 << endl;\n    else cout << 6 * S * S * K - ret * 2 << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <functional>\nusing namespace std;\n\nstruct cube {\n    int x, y, z, w;\n    cube() {}\n    cube(int a, int b, int c, int d): x(a), y(b), z(c), w(d) {}\n\n    int overlap_area(cube o) {\n        int ox = w - abs(x - o.x);\n        int oy = w - abs(y - o.y);\n        int oz = w - abs(z - o.z);\n\n        if (ox < 0 || oy < 0 || oz < 0) {\n            return -1;\n        }\n\n        return 2 * (ox * oy + oy * oz + oz * ox);\n    }\n};\n\nint main() {\n    int N, K, S;\n    while (true) {\n        cin >> N >> K >> S;\n        if (N == 0 && K == 0 && S == 0) break;\n\n        vector<cube> cubes;\n        vector<vector<int>> graph(N);\n\n        for (int j = 0; j < N; ++j) {\n            int x, y, z; cin >> x >> y >> z;\n            cubes.emplace_back(x, y, z, S);\n        }\n\n        if (K == 1) {\n            cout << 6*S*S << endl;\n            continue;\n        }\n\n        for (int j = 0; j < N; ++j) {\n            for (int k = j+1; k < N; ++k) {\n                int area = cubes[j].overlap_area(cubes[k]);\n                if (area >= 0) {\n                    graph[j].push_back(k);\n                    graph[k].push_back(j);\n                }\n            }\n        }\n\n        vector<int> visited(N, 0);\n        function<int(int)> get_start = [&](int v) -> int {\n            visited[v] = 1;\n            for (int w: graph[v]) {\n                if (!visited[w])\n                    return get_start(w);\n            }\n            return v;\n        };\n\n        int ans = -1;\n\n        for (int j = 0; j < N; ++j) {\n            if (visited[j])\n                continue;\n            int s = get_start(j);\n\n            vector<int> chain;\n            function<bool(int, int)> set_chain = [&](int v, int prev) -> bool {\n                chain.push_back(v);\n                visited[v] = 1;\n                for (int w: graph[v]) {\n                    if (w == prev) continue;\n                    if (w == s) return true; \n                    return set_chain(w, v);\n                }\n                return false;\n            };\n            bool loop = set_chain(s, -1);\n\n            const int L = chain.size();\n            if (L < K) continue;\n\n            int area = 6*S*S;\n            for (int j = 1; j < ((loop && L > K) ? 2*L : L); ++j) {\n                if (j >= K) {\n                    int v0 = chain[(j-K)%L], v1 = chain[(j-K+1)%L];\n                    area -= 6*S*S - cubes[v0].overlap_area(cubes[v1]);\n                }\n\n                area += 6*S*S - cubes[chain[(j-1)%L]].overlap_area(cubes[chain[j%L]]);\n                if (loop && L == K && j == L-1) {\n                    area -= cubes[chain[j%L]].overlap_area(cubes[chain[(j+1)%L]]);\n                }\n\n                if (j+1 >= K) ans = (ans == -1) ? area : min(ans, area);\n            }\n        }\n\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <cmath>\n#include <cstdlib>\n#include <map>\nusing namespace std;\n\nclass Point {\npublic:\n    int x, y, z;\n    Point(int x = 0, int y = 0, int z = 0) : x(x), y(y), z(z) {}\n\n    bool operator < (const Point &p) const {\n        if (x == p.x && y == p.y) return z < p.z;\n        if (x == p.x) return y < p.y;\n        return x < p.x;\n    }\n};\n\nclass Cube {\npublic:\n    Point p;\n    int s;\n    int vx[4] = {0, 1, 1, 0}, vy[4] = {0, 0, 1, 1}, vz[2] = {0, 1};\n    Cube(Point p = Point(), int s = 0) : p(p), s(s) {}\n\n    // c???????????¨????????£?????????????????????\n    bool isIn(const Cube &c) {\n        int nx, ny, nz;\n\n        for (int i = 0; i < 2; ++i) {\n            for (int j = 0; j < 4; ++j) {\n                nx = c.p.x + c.s * vx[j];\n                ny = c.p.y + c.s * vy[j];\n                nz = c.p.z + c.s * vz[i];\n\n                //cout << nx << \" \" << ny << \" \" << nz << endl;\n\n                if (p.x <= nx && nx <= p.x + s &&\n                    p.y <= ny && ny <= p.y + s &&\n                    p.z <= nz && nz <= p.z + s) {\n                        return true;\n                    }\n            }\n        }\n\n        return false;\n    }\n\n    int shareS(Cube &c) {\n        int ret = 0;\n        Point a, b;\n        a = p; b = c.p;\n\n        if (a.x > b.x) swap(a.x, b.x);\n        if (a.y > b.y) swap(a.y, b.y);\n        if (a.z > b.z) swap(a.z, b.z);\n\n        ret += abs((a.x + s - b.x) * (a.z + s - b.z) * 2);\n        ret += abs((a.y + s - b.y) * (a.z + s - b.z) * 2);\n        ret += abs((a.x + s - b.x) * (a.y + s - b.y) * 2);\n        return ret;\n    }\n\n};\n\nint n, k, s, x, y, z, ans, cnt;\nvector<Cube> c;\nvector<vector<int> > subg;\nvector<bool> used;\nvector<deque<int> > graph;\ndeque<int> que;\nmap<pair<int, int>, bool> mp, init;\n\ninline void makegraph(int v) {\n    for (int i = 0; i < n; ++i) {\n        if (!mp[make_pair(v, i)] && i != v && c[v].isIn(c[i])) {\n            subg[v].push_back(i);\n            subg[i].push_back(v);\n            mp[make_pair(v, i)] = true;\n            mp[make_pair(i, v)] = true;\n        }\n    }\n}\n\ninline bool isCycle(int graphid) {\n    int size_ = graph[graphid].size();\n    //cout << \"graph size = \" << graph[graphid].size() << endl;\n\n    for (int i = 0; i < size_; ++i) {\n        if (subg[graph[graphid][i]].size() != 2) return false;\n    }\n\n    return true;\n}\n\nvoid dfs(int v) {\n    used[v] = true;\n    int size_ = subg[v].size();\n    bool flag = false;\n\n    for (int i = 0; i < size_; ++i) {\n        if (!used[subg[v][i]]) {\n            dfs(subg[v][i]);\n            if (!flag) que.push_front(v);\n            flag = true;\n        }\n    }\n\n    if (!flag) que.push_front(v);\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    while (cin >> n >> k >> s, n | k | s) {\n        //cout << \"---- begin ----\" << endl;\n        c.resize(n);\n        subg.resize(n);\n        que.clear();\n        used.assign(n, false);\n        mp = init;\n        ans = int(1e9);\n\n        for (int i = 0; i < n; ++i) {\n            cin >> x >> y >> z;\n            c[i] = {Point(x, y, z), s};    \n        }\n\n        for (int i = 0; i < n; ++i) {\n            makegraph(i);\n        }\n\n        for (int i = 0; i < n; ++i) {\n            if (!used[i]) {\n                dfs(i);\n                graph.push_back(que);\n                que.clear();\n            }\n        }\n\n        //cout << isCycle(0) << endl;\n\n        int gsize = graph.size(), qsize, tmp, share, upper;\n        bool isGraphCycle = false;\n\n        for (int i = 0; i < gsize; ++i) {\n            qsize = graph[i].size();\n            tmp = 0;\n            isGraphCycle = isCycle(i);\n            //cout << \"isGraphCycle = \" << isGraphCycle << endl;\n            if (isGraphCycle) {\n                upper = qsize + k - 1;\n            }\n            else upper = qsize;\n\n            if (qsize < k) continue;\n\n            for (int j = 0; j + k - 1 < upper; ++j) {\n                share = 0;\n                for (int l = 0; l < k - 1; ++l) {\n                    //Cube a = c[graph[i][j + l]],\n                    //    b = c[graph[i][j + l + 1]];\n                    //cout << a.p.x << \" \" << a.p.y << \" \" << a.p.z << endl;\n                    //cout << b.p.x << \" \" << b.p.y << \" \" << b.p.z << endl;\n                    tmp = c[graph[i][(j + l) % qsize]].shareS(c[graph[i][(j + l + 1) % qsize]]);\n                    //cout << graph[i][(j + l) % qsize] << \" & \" << graph[i][(j + l + 1) % qsize] << endl;\n                    //cout << \"share is \" << tmp << endl;\n                    share += tmp;\n                }\n\n                if (isGraphCycle && qsize == k) {\n                    tmp = c[graph[i][0]].shareS(c[graph[i][qsize - 1]]);\n                    //cout << \"this is cycle : \" << tmp << endl;\n                    share += tmp;\n                }\n\n                //cout << endl;\n                ans = min(ans, 6 * s * s * k - share);\n                //cout << \"all - share = \" << 6*s*s*k-share << endl;\n            }\n        }\n\n        if (n == 1) ans = 6 * s * s;\n        if (ans == int(1e9)) ans = -1;\n\n        cout << ans << endl;\n\n        //cout << \"---- end ----\" << endl;\n        //cout << endl;\n\n        c.clear();\n        graph.clear();\n        subg.clear();\n        used.clear();\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct Edge {\n    int dst, w;\n    Edge() {}\n    Edge(int d, int w) : dst(d), w(w) {}\n};\nusing Graph = vector<vector<Edge>>;\nstruct Cube { int p[3]; };\n\n\nGraph MakeGraph(const int n, const int s, vector<Cube> &c) {\n    Graph g(n);\n    int d[3];\n\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            for (int k = 0; k < 3; ++k)\n                d[k] = s + ((c[i].p[k] < c[j].p[k]) ? (c[i].p[k] - c[j].p[k]) : (c[j].p[k] - c[i].p[k]));\n\n            if (d[0] <= 0 || d[1] <= 0 || d[2] <= 0) continue;\n\n            int w = 2 * d[0] * d[1] + 2 * d[0] * d[2] + 2 * d[1] * d[2];\n            g[i].emplace_back(Edge(j, w));\n            g[j].emplace_back(Edge(i, w));\n        }\n    }\n\n    return g;\n}\n\nint MinimumArea(const int n, const int k, const int s, const Graph &g) {\n    vector<bool> used(n, false);\n    int res = -1;\n\n    for (int u = 0; u < 2 * n; ++u) {\n        if (used[u % n] || (u < n && g[u % n].size() == 2)) continue;\n\n        const int v = u % n;\n\n        vector<int> sub;\n        int cur = v;\n        while (true) {\n            used[cur] = true;\n            sub.push_back(cur);\n            if (1 <= g[cur].size() && !used[g[cur][0].dst])\n                cur = g[cur][0].dst;\n            else if (g[cur].size() == 2 && !used[g[cur][1].dst])\n                cur = g[cur][1].dst;\n            else\n                break;\n        }\n\n        const int size = sub.size();\n        if (size < k) continue;\n\n        int sum = 0;\n        for (int i = 0; i < k - 1; ++i)\n            sum += ((g[sub[i]][0].dst == sub[i + 1]) ? g[sub[i]][0].w : g[sub[i]][1].w);\n\n        const bool is_cycle = (g[sub[0]].size() == 2);\n        if (size == k && is_cycle)\n            sum += ((g[sub[0]][0].dst == sub[size - 1]) ? g[sub[0]][0].w : g[sub[0]][1].w);\n        res = max(res, sum);\n\n        const int lim = (is_cycle ? size - 1 : size - k);\n        for (int i = 1; i <= lim; ++i) {\n            sum -= ((g[sub[i]][0].dst == sub[i - 1]) ? g[sub[i]][0].w : g[sub[i]][1].w);\n            const int j1 = (i + k - 2) % size, j2 = (i + k - 1) % size;\n            sum += ((g[sub[j1]][0].dst == j2) ? g[sub[j1]][0].w : g[sub[j1]][1].w);\n            res = max(res, sum);\n        }\n    }\n\n    return (res == -1) ? -1 : 6 * k * s * s - res;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int n, k, s;\n\n    while (cin >> n >> k >> s, n) {\n        vector<Cube> cube(n);\n        for (auto &c : cube)\n            for (int i = 0; i < 3; ++i) cin >> c.p[i];\n\n        cout << MinimumArea(n, k, s, MakeGraph(n, s, cube)) << '\\n';\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define dbg(...) do{cerr<<__LINE__<<\": \";dbgprint(#__VA_ARGS__, __VA_ARGS__);}while(0);\n\nusing namespace std;\n\nnamespace std{template<class S,class T>struct hash<pair<S,T>>{size_t operator()(const pair<S,T>&p)const{return ((size_t)1e9+7)*hash<S>()(p.first)+hash<T>()(p.second);}};template<class T>struct hash<vector<T>>{size_t operator()(const vector<T> &v)const{size_t h=0;for(auto i : v)h=h*((size_t)1e9+7)+hash<T>()(i)+1;return h;}};}\ntemplate<class T>ostream& operator<<(ostream &os, const vector<T> &v){os<<\"[ \";rep(i,v.size())os<<v[i]<<(i==v.size()-1?\" ]\":\", \");return os;}template<class T>ostream& operator<<(ostream &os,const set<T> &v){os<<\"{ \"; for(const auto &i:v)os<<i<<\", \";return os<<\"}\";}\ntemplate<class T,class U>ostream& operator<<(ostream &os,const map<T,U> &v){os<<\"{\";for(const auto &i:v)os<<\" \"<<i.first<<\": \"<<i.second<<\",\";return os<<\"}\";}template<class T,class U>ostream& operator<<(ostream &os,const pair<T,U> &p){return os<<\"(\"<<p.first<<\", \"<<p.second<<\")\";}\nvoid dbgprint(const string &fmt){cerr<<endl;}template<class H,class... T>void dbgprint(const string &fmt,const H &h,const T&... r){cerr<<fmt.substr(0,fmt.find(\",\"))<<\"= \"<<h<<\" \";dbgprint(fmt.substr(fmt.find(\",\")+1),r...);}\ntypedef long long ll;typedef vector<int> vi;typedef pair<int,int> pi;const int inf = (int)1e9;const double INF = 1e12, EPS = 1e-9;\n\nint main(){\n\tcin.tie(0); cin.sync_with_stdio(0);\n\tint n, k, s;\n\twhile(cin >> n >> k >> s, n){\n\t\tvi x(n), y(n), z(n);\n\t\trep(i, n) cin >> x[i] >> y[i] >> z[i];\n\t\t\n\t\tauto intersect = [&](int i, int j){\n\t\t\tll dx = s - abs(x[i] - x[j]);\n\t\t\tll dy = s - abs(y[i] - y[j]);\n\t\t\tll dz = s - abs(z[i] - z[j]);\n\t\t\tif(dx <= 0 || dy <= 0 || dz <= 0) return 0ll;\n\t\t\treturn (dx * dy + dy * dz + dz * dx) * 2;\n\t\t};\n\t\t\n\t\tvector<vi> e(n);\n\t\trep(i, n) rep(j, i) if(intersect(i, j)){\n\t\t\te[i].pb(j);\n\t\t\te[j].pb(i);\n\t\t\t//dbg(i, j);\n\t\t}\n\t\t\n\t\tfunction<bool(int,int,vector<bool>&,vi&)> rec = [&](int c, int p, vector<bool> &v, vi &idx){\n\t\t\tv[c] = 1;\n\t\t\tidx.pb(c);\n\t\t\tfor(int i : e[c]) if(i != p){\n\t\t\t\tif(v[i]) return true;\n\t\t\t\treturn (bool)rec(i, c, v, idx); \n\t\t\t}\n\t\t\treturn false;\n\t\t};\n\t\t\n\t\tll ans = 1e18;\n\t\tvector<bool> v(n);\n\t\trep(ii, n) if(!v[ii]){\n\t\t\tvi idx;\n\t\t\tbool loop = rec(ii, ii, v, idx);\n\t\t\tif(idx.size() < k) continue;\n\t\t\t\n\t\t\tif(loop && idx.size() == k){\n\t\t\t\tll sum = 6ll * k * s * s;\n\t\t\t\trep(i, (int)idx.size()){\n\t\t\t\t\tll c = intersect(idx[i], idx[(i + 1) % idx.size()]);\n\t\t\t\t\tsum -= c;\n\t\t\t\t}\n\t\t\t\tans = min(ans, sum);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tvector<ll> costs;\n\t\t\t\tif(loop){\n\t\t\t\t\trep(i, (int)idx.size())\n\t\t\t\t\t\tcosts.pb(intersect(idx[i], idx[(i + 1) % idx.size()]));\n\t\t\t\t\tint it = idx.size();\n\t\t\t\t\trep(i, it) idx.pb(idx[i]);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tint hasi = 0;\n\t\t\t\t\trep(i, idx.size()) if(e[idx[i]].size() == 1) hasi = idx[i];\n\t\t\t\t\tfor(int i : idx) v[i] = 0;\n\t\t\t\t\tidx.clear();\n\t\t\t\t\trec(hasi, hasi, v, idx);\n\t\t\t\t\t\n\t\t\t\t\trep(i, (int)idx.size()-1)\n\t\t\t\t\t\tcosts.pb(intersect(idx[i], idx[i + 1]));\n\t\t\t\t\t\n\t\t\t\t\trep(i, idx.size()){\n\t\t\t\t\t\tif(i==0 || i==idx.size()-1) assert(e[idx[i]].size() <= 1);\n\t\t\t\t\t\telse assert(e[idx[i]].size()==2);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//dbg(k, costs);\n\t\t\t\t\n\t\t\t\tll sum = 6ll * k * s * s;\n\t\t\t\tif(k == 1){\n\t\t\t\t\tans = min(ans, sum);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\trep(i, k-2) sum -= costs[i];\n\t\t\t\trep(i, (int)costs.size() - (k-1) + 1){\n\t\t\t\t\tsum -= costs[i + k-2];\n\t\t\t\t\tans = min(ans, sum);\n\t\t\t\t\tsum += costs[i];\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tif(ans >= 1e18) ans = -1;\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct point {\n  long long x, y, z;\n};\n\nstruct edge {\n  int to;\n  long long s;\n};\n\nlong long n, k, s;\nvector<point> v;\nvector<vector<edge>> edges;\nvector<bool> used;\n\nlong long solve();\nlong long dfs(long long now, long long sum);\n\nint main() {\n  while(1) {\n    cin >> n >> k >> s;\n    if(n == 0) break;\n    v.resize(n);\n    for(int i = 0; i < n; ++i)\n      cin >> v[i].x >> v[i].y >> v[i].z;\n    edges.assign(n, vector<edge>(0));\n    for(int i = 0; i < n; ++i)\n      for(int j = i + 1; j < n; ++j) {\n        long long x, y, z;\n        x = max(0LL, min(v[i].x, v[j].x) + s -\n                         max(v[i].x, v[j].x));\n        y = max(0LL, min(v[i].y, v[j].y) + s -\n                         max(v[i].y, v[j].y));\n        z = max(0LL, min(v[i].z, v[j].z) + s -\n                         max(v[i].z, v[j].z));\n        if(x * y * z > 0) {\n          edges[i].push_back(\n              {j, 2LL * (x * y + y * z + z * x)});\n          edges[j].push_back(\n              {i, 2LL * (x * y + y * z + z * x)});\n        }\n      }\n    cout << solve() << endl;\n  }\n  return 0;\n}\n\nlong long solve() {\n  long long res = -1;\n  used.assign(n, 0);\n  for(int i = 0; i < n; ++i) {\n    used[i] = 1;\n    res = max(res, dfs(i, 1));\n    used[i] = 0;\n  }\n  if(res == -1) return res;\n  return k * 6LL * s * s - res;\n}\n\nlong long dfs(long long now, long long sum) {\n  long long res = -1, nows = 0;\n  for(auto e : edges[now])\n    if(used[e.to]) nows += e.s;\n  if(sum == k) return nows;\n  for(auto e : edges[now])\n    if(!used[e.to]) {\n      used[e.to] = 1;\n      res = max(res, dfs(e.to, sum + 1) + nows);\n      used[e.to] = 0;\n    }\n  if(res == -1) return -1e16;\n  return res;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nstruct Info{\n\tint x,y,z;\n};\n\nint N,K,S;\nint adj_num[2000],adj_index[2000][2],lost_S[2000][2000];\nint boss[2000],height[2000],group_min_adj[2000];\nbool used[2000];\nInfo info[2000];\n\n//自分のボスのindexを取得しつつ、経路圧縮を行う関数\nint get_boss(int id){\n\tif(boss[id] == id)return id; //自分が代表なら、自分の値を返す\n\telse{\n\t\treturn boss[id] = get_boss(boss[id]); //代表でないなら、自分が所属する組織の代表を返しつつ、経路圧縮\n\t}\n}\n\nvoid unite(int x,int y){\n\tint boss_x = get_boss(x);\n\tint boss_y = get_boss(y);\n\n\t//既に同じグループなら何もしない\n\tif(boss_x == boss_y)return;\n\n\t//高さが高い方に吸収する\n\tif(height[x] > height[y]){\n\n\t\tboss[boss_y] = boss_x;\n\n\t}else if(height[x] < height[y]){\n\n\t\tboss[boss_x] = boss_y;\n\n\t}else{ //height[x] == height[y]\n\n\t\tboss[boss_y] = boss_x;\n\t\theight[x]++;\n\t}\n}\n\n\nvoid func(){\n\n\tfor(int i = 0; i < N; i++){\n\t\tadj_num[i] = 0;\n\t}\n\n\tfor(int i = 0; i < N; i++){\n\t\tscanf(\"%d %d %d\",&info[i].x,&info[i].y,&info[i].z);\n\t}\n\n\tif(K == 1){\n\t\tprintf(\"%d\\n\",6*S*S);\n\t\treturn;\n\t}\n\n\tfor(int i = 0; i < N; i++){\n\t\tboss[i] = i;\n\t\theight[i] = 0;\n\t}\n\n\tint diff_x,diff_y,diff_z;\n\n\tfor(int i = 0; i < N-1; i++){\n\t\tfor(int k = i+1; k < N; k++){\n\n\t\t\tif(info[i].x+S <= info[k].x || info[k].x+S <= info[i].x)continue;\n\t\t\tif(info[i].y+S <= info[k].y || info[k].y+S <= info[i].y)continue;\n\t\t\tif(info[i].z+S <= info[k].z || info[k].z+S <= info[i].z)continue;\n\n\t\t\tunite(i,k);\n\n\t\t\tadj_index[i][adj_num[i]++] = k;\n\t\t\tadj_index[k][adj_num[k]++] = i;\n\n\t\t\tdiff_x = S-abs(info[i].x-info[k].x);\n\t\t\tdiff_y = S-abs(info[i].y-info[k].y);\n\t\t\tdiff_z = S-abs(info[i].z-info[k].z);\n\n\t\t\tlost_S[i][k] = lost_S[k][i] = 2*(diff_x*diff_y+diff_x*diff_z+diff_y*diff_z);\n\t\t}\n\t}\n\n\t//各連結グループ内の、最小連結数を求める(輪構造対策)\n\tfor(int i = 0; i < N; i++)group_min_adj[i] = BIG_NUM;\n\tint boss_id;\n\tfor(int i = 0; i < N; i++){\n\t\tboss_id = get_boss(i);\n\t\tgroup_min_adj[boss_id] = min(group_min_adj[boss_id],adj_num[i]);\n\t}\n\n\tfor(int i = 0; i < N; i++)used[i] = false;\n\tint ans = BIG_NUM,tmp,last_cube,next_cube,remove_cube;\n\tqueue<int> Q;\n\n\tbool FLG;\n\n\tfor(int i = 0; i < N; i++){\n\t\tboss_id = get_boss(i);\n\t\tif((used[i] == true) || (group_min_adj[boss_id] != 2 && adj_num[i] == 2))continue; //輪対策\n\n\t\twhile(!Q.empty())Q.pop();\n\n\t\t//孤立、または連結の端の立方体\n\t\ttmp = 6*S*S;\n\t\tused[i] = true;\n\t\tlast_cube = i;\n\t\tQ.push(i);\n\n\t\twhile(!Q.empty()){\n\t\t\tif(Q.size() == K){ //連がK個になった場合\n\n\t\t\t\tFLG = false; //★★ちょうどK個の輪ができる場合あり!!★★\n\t\t\t\tfor(int k = 0; k < adj_num[last_cube]; k++){\n\t\t\t\t\tif(adj_index[last_cube][k] == Q.front()){\n\t\t\t\t\t\tFLG = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif(FLG){\n\t\t\t\t\tans = min(ans,tmp-lost_S[last_cube][Q.front()]);\n\t\t\t\t}else{\n\t\t\t\t\tans = min(ans,tmp);\n\t\t\t\t}\n\n\n\t\t\t\tnext_cube = -1;\n\t\t\t\tfor(int k = 0; k < adj_num[last_cube]; k++){\n\t\t\t\t\tif(used[adj_index[last_cube][k]])continue;\n\t\t\t\t\tnext_cube = adj_index[last_cube][k];\n\t\t\t\t}\n\t\t\t\tif(next_cube == -1)break;\n\t\t\t\tused[next_cube] = true;\n\n\t\t\t\t//一番古い立方体を削除\n\t\t\t\tremove_cube = Q.front();\n\t\t\t\tQ.pop();\n\n\t\t\t\ttmp += 6*S*S-lost_S[last_cube][next_cube];\n\t\t\t\ttmp -= 6*S*S-lost_S[remove_cube][Q.front()];\n\n\t\t\t\tlast_cube = next_cube;\n\t\t\t\tQ.push(last_cube);\n\n\t\t\t}else{\n\n\t\t\t\tnext_cube = -1;\n\t\t\t\tfor(int k = 0; k < adj_num[last_cube]; k++){\n\t\t\t\t\tif(used[adj_index[last_cube][k]])continue;\n\t\t\t\t\tnext_cube = adj_index[last_cube][k];\n\t\t\t\t}\n\t\t\t\tif(next_cube == -1)break;\n\t\t\t\tused[next_cube] = true;\n\n\t\t\t\ttmp += 6*S*S-lost_S[last_cube][next_cube];\n\n\t\t\t\tlast_cube = next_cube;\n\t\t\t\tQ.push(last_cube);\n\t\t\t}\n\t\t}\n\t}\n\n\tif(ans == BIG_NUM){\n\t\tprintf(\"-1\\n\");\n\t}else{\n\t\tprintf(\"%d\\n\",ans);\n\t}\n}\n\nint main(){\n\n\twhile(true){\n\t\tscanf(\"%d %d %d\",&N,&K,&S);\n\t\tif(N == 0 && K == 0 && S == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\nusing namespace std;\ntypedef long long ll;\nconst ll MOD = 1000000007;\nconst ll INF = (ll)1000000007 * 1000000007;\nconst double EPS = 1e-9;\ntypedef pair<int, int> P;\ntypedef unsigned int ui;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\nint n, k, s;\nstruct cube { int x, y, z; };\nint cap(cube a, cube b) {\n\tint da = s - abs(a.x - b.x);\n\tint db = s - abs(a.y - b.y);\n\tint dc = s - abs(a.z - b.z);\n\tif (da <= 0 || db <= 0 || dc <= 0)return 0;\n\treturn 2*(da * db +db* dc+dc*da);\n}\nstruct edge { int to,cost; };\nint main() {\n\twhile (cin >> n >> k >> s,n) {\n\t\tvector<edge> G[2000]; cube a[2000];\n\t\trep(i, n) {\n\t\t\tint x, y, z; cin >> x >> y >> z;\n\t\t\ta[i] = { x,y,z };\n\t\t}\n\t\tif (k == 1) {\n\t\t\tcout << 6 * s*s << endl; continue;\n\t\t}\n\t\trep(i, n) {\n\t\t\trep(j, n) {\n\t\t\t\tif (i == j)continue;\n\t\t\t\tint dis = cap(a[i], a[j]);\n\t\t\t\tif (dis > 0) {\n\t\t\t\t\tG[i].push_back({ j,dis });\n\t\t\t\t\tG[j].push_back({ i,dis });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ma = 0;\n\t\trep(sta, n) {\n\t\t\trep(i, (int)G[sta].size()) {\n\t\t\t\tint nf = G[sta][i].to;\n\t\t\t\tint sum = G[sta][i].cost;\n\t\t\t\tint used[2000] = {}; used[sta] = used[nf] = 1;\n\t\t\t\tbool f = false;\n\t\t\t\trep(aaa, k - 2) {\n\t\t\t\t\tf = false;\n\t\t\t\t\trep(b, (int)G[nf].size()) {\n\t\t\t\t\t\tif (!used[G[nf][b].to]) {\n\t\t\t\t\t\t\tf = true;\n\t\t\t\t\t\t\tused[G[nf][b].to] = 1;\n\t\t\t\t\t\t\tsum += G[nf][b].cost;\n\t\t\t\t\t\t\tnf = G[nf][b].to; break;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!f)continue;\n\t\t\t\tsum += cap(a[sta], a[nf]);\n\t\t\t\tma = max(ma, sum);\n\t\t\t}\n\t\t}\n\t\tif (ma == 0) {\n\t\t\tcout << -1 << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << 6 * s*s*k - ma << endl;\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define mp make_pair\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef pair<int,pii> pip;\ntypedef vector<pip>vip;\nconst double PI=acos(-1);\nconst double EPS=1e-8;\nconst int inf=1e8;\nvi used;\nint out;\nvvp area;\nbool h;\nvoid dfs(int a,int prev,int b,int c){\n\tif(b==0){\n\t\th=true;\n\t\tint t=0;\n\t\trep(i,area[a].size())if(area[a][i].first!=prev&&used[area[a][i].first]){\n\t\t\tt=area[a][i].second;\n\t\t}\n\t\tout=max(out,c+t);\n\t\treturn ;\n\t}\n\trep(i,area[a].size())if(used[area[a][i].first]==0){\n\t\tused[area[a][i].first]=true;\n\t\tc+=area[a][i].second;\n\t\tdfs(area[a][i].first,a,b-1,c);\n\t\tc-=area[a][i].second;\n\t\tused[area[a][i].first]=false;\n\t}\n}\nint main(){\n\tint n,m,s;\n\twhile(cin>>n>>m>>s,n+m+s){\n\t\tvvi in(n,vi(3));\n\t\trep(i,n)rep(j,3)cin>>in[i][j];\n\t\tarea=vvp(n);\n\t\trep(i,n)rep(j,n)if(i!=j){\n\t\t\tint x=min(in[i][0],in[j][0])+s-max(in[i][0],in[j][0]);\n\t\t\tint y=min(in[i][1],in[j][1])+s-max(in[i][1],in[j][1]);\n\t\t\tint z=min(in[i][2],in[j][2])+s-max(in[i][2],in[j][2]);\n\t\t\tif(x>0&&y>0&&z>0)area[i].pb(pii(j,2*(x*y+y*z+z*x)));\n\t\t}\n\t\th=out=0;\n\t\trep(i,n){\n\t\t\tused=vi(n);\n\t\t\tused[i]=true;\n\t\t\tdfs(i,-1,m-1,0);\n\t\t}\n\t\tif(!h)cout<<-1<<endl;\n\t\telse cout<<m*6*s*s-out<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cassert>\n\nusing namespace std;\nusing ll = long long;\nconstexpr ll INF = 1LL << 50;\nll s;\n\nstruct Cube {\n    ll x;\n    ll y;\n    ll z;\n};\nll connected(const Cube& c1, const Cube& c2)\n{\n    const ll x1 = c1.x;\n    const ll y1 = c1.y;\n    const ll z1 = c1.z;\n    for (int i = 0; i < 2; i++) {\n        const ll x2 = c2.x + i * s;\n        const ll dx = x2 - x1;\n        for (int j = 0; j < 2; j++) {\n            const ll y2 = c2.y + j * s;\n            const ll dy = y2 - y1;\n            for (int k = 0; k < 2; k++) {\n                const ll z2 = c2.z + k * s;\n                const ll dz = z2 - z1;\n                if (0 <= dx and dx <= s and 0 <= dy and dy <= s and 0 <= dz and dz <= s) {\n                    const ll lx = (i == 0) ? s - dx : dx;\n                    const ll ly = (j == 0) ? s - dy : dy;\n                    const ll lz = (k == 0) ? s - dz : dz;\n                    return (lx * ly + ly * lz + lz * lx) * 2;\n                }\n            }\n        }\n    }\n    return 0;\n}\n\nstruct Edge {\n    int from;\n    int to;\n    ll cost;\n};\nstruct Graph {\n    Graph(const int n)\n    {\n        edge.resize(n);\n    }\n    void addEdge(const int from, const int to, const ll cost)\n    {\n        edge[from].push_back(Edge{from, to, cost});\n        edge[to].push_back(Edge{to, from, cost});\n    }\n    vector<vector<Edge>> edge;\n};\n\nint getEdge(const Graph& g, const int s, vector<bool>& visited)\n{\n    visited[s] = true;\n    int child = 0;\n    for (const auto& e : g.edge[s]) {\n        if (not visited[e.to]) {\n            return getEdge(g, e.to, visited);\n        }\n    }\n    if (child == 0) {\n        return s;\n    }\n}\nstruct Chain {\n    bool ring = false;\n    vector<ll> edges;\n};\nostream& operator<<(ostream& os, const Chain& ch)\n{\n    os << \"Ring: \" << boolalpha << ch.ring << \"\\nEdge: {\";\n    for (int i = 0; i < ch.edges.size(); i++) {\n        if (i != 0) {\n            os << \",\";\n        }\n        os << ch.edges[i];\n    }\n    os << \"}\" << endl;\n}\nvoid dfs(const Graph& g, const int s, const int dep, vector<bool>& visited, Chain& chain)\n{\n    visited[s] = true;\n    for (const auto& e : g.edge[s]) {\n        if (e.to == dep and chain.edges.size() >= 2) {\n            if (not chain.ring) {\n                chain.edges.push_back(e.cost);\n                chain.ring = true;\n            }\n            return;\n        }\n        if (not visited[e.to]) {\n            chain.edges.push_back(e.cost);\n            dfs(g, e.to, dep, visited, chain);\n        }\n    }\n}\n\nint main()\n{\n    while (true) {\n        int n, k;\n        cin >> n >> k >> s;\n        if (n == 0 and k == 0 and s == 0) {\n            break;\n        }\n\n        const ll whole = 6 * s * s * k;\n        if (k == 1) {\n            cout << whole << endl;\n            continue;\n        }\n\n        vector<Cube> cube(n);\n        for (int i = 0; i < n; i++) {\n            cin >> cube[i].x >> cube[i].y >> cube[i].z;\n        }\n        Graph g(n);\n        for (int i = 0; i < n - 1; i++) {\n            for (int j = i + 1; j < n; j++) {\n                const ll cost = connected(cube[i], cube[j]);\n                if (cost > 0) {\n                    g.addEdge(i, j, cost);\n                }\n            }\n        }\n        vector<bool> visited(n, false);\n        vector<Chain> chains;\n        for (int i = 0; i < n; i++) {\n            if (not visited[i]) {\n                vector<bool> visited2(n, false);\n                const int dep = getEdge(g, i, visited2);\n                Chain chain;\n                chain.ring = false;\n                dfs(g, dep, dep, visited, chain);\n                chains.push_back(chain);\n            }\n        }\n        ll mini = INF;\n        for (const auto chain : chains) {\n\n            const bool ring = chain.ring;\n            const vector<ll>& costs = chain.edges;\n            if (costs.size() < k) {\n                continue;\n            }\n            if (ring) {\n                ll sum = 0;\n                for (int i = 0; i < k - 1; i++) {\n                    sum += costs[i];\n                }\n                if (costs.size() == k) {\n                    sum += costs[k - 1];\n                    mini = min(mini, whole - sum);\n                } else {\n                    mini = min(mini, whole - sum);\n                    int head = 0;\n                    int tail = k - 1;\n                    for (; head < costs.size(); head++, tail++, tail = tail % costs.size()) {\n                        sum += (costs[tail] - costs[head]);\n                        mini = min(mini, whole - sum);\n                    }\n                }\n            } else {\n                ll sum = 0;\n                for (int i = 0; i < k - 1; i++) {\n                    sum += costs[i];\n                }\n                mini = min(mini, whole - sum);\n                int head = 0;\n                int tail = k - 1;\n                for (; tail < costs.size(); head++, tail++) {\n                    sum += (costs[tail] - costs[head]);\n                    mini = min(mini, whole - sum);\n                }\n            }\n        }\n        cout << ((mini == INF) ? -1 : mini) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int INF = 1 << 30;\n\nstruct edge\n{\n  int to, cost;\n};\n\nint main()\n{\n  int N, K, S;\n  int X[2000], Y[2000], Z[2000];\n\n  while(cin >> N >> K >> S, N) {\n    for(int i = 0; i < N; i++) {\n      cin >> X[i] >> Y[i] >> Z[i];\n    }\n\n    vector< edge > g[2000];\n    for(int i = 0; i < N; i++) {\n      for(int j = 0; j < i; j++) {\n        int latte = max(0, S - abs(X[i] - X[j]));\n        int malta = max(0, S - abs(Y[i] - Y[j]));\n        int beeet = max(0, S - abs(Z[i] - Z[j]));\n        int ukuku = latte * malta + malta * beeet + beeet * latte;\n        if(latte > 0 && malta > 0 && beeet > 0) {\n          g[i].emplace_back((edge) {j, ukuku});\n          g[j].emplace_back((edge) {i, ukuku});\n        }\n      }\n    }\n\n    int ret = -1;\n    for(int i = 0; i < N; i++) {\n      bool v[2000] = {};\n      function< void(int, int, int) > dfs = [&](int idx, int k, int sz)\n      {\n        if(v[idx]++) return;\n        if(k == 0) {\n          if(K >= 2) for(auto &e: g[idx]) if(e.to == i) sz += e.cost;\n          ret = max(ret, sz);\n        } else {\n          for(auto &e : g[idx]) dfs(e.to, k - 1, sz + e.cost);\n        }\n      };\n      dfs(i, K - 1, 0);\n    }\n    if(ret == 0) cout << -1 << endl;\n    else cout << 6 * S * S * K - ret * 2 << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\nint N, K;\nlong long int S;\n\nstruct cube {\n\tvector<long long int>coors;\n};\n\nlong long int connect(const cube&l, const cube&r) {\n\tvector<long long int>ds;\n\tfor (int i = 0; i < 3; ++i) {\n\t\tif (abs(l.coors[i] - r.coors[i]) >= S)return 0;\n\t\telse ds.emplace_back(S-abs(l.coors[i] - r.coors[i]));\n\t}\n\treturn 2 * (ds[0] * ds[1] + ds[1] * ds[2] + ds[2] * ds[0]);\n}\nvoid dfs(const int now, const int from, const vector<vector<pair<int, long long int>>>&edges, vector<int>&used,vector<long long int>&v) {\n\tfor (auto e : edges[now]) {\n\t\tif (e.first == from)continue;\n\t\tif (used[e.first]) {\n\t\t\tv.push_back(e.second);\n\t\t}\n\t\telse {\n\t\t\tv.push_back(e.second);\n\t\t\tused[e.first] = true;\n\t\t\tdfs(e.first, now, edges, used, v);\n\t\t}\n\t}\n}\nint main() {\n\twhile (1) {\n\t\tcin >> N >> K >> S;\n\t\tif (!N)break;\n\t\tlong long int total = K*S*S * 6;\n\t\t\n\t\tvector<cube>cus;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tint x, y, z; cin >> x >> y >> z;\n\t\t\tcus.push_back(cube{ vector<long long int>{x,y,z} });\n\t\t}\n\t\tif (K == 1) {\n\t\t\tcout << total << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tvector<vector<pair<int, long long int>>>edges(N);\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tfor (int j = 0; j < N; ++j) {\n\t\t\t\tif (i == j)continue;\n\t\t\t\tlong long int sa = connect(cus[i], cus[j]);\n\t\t\t\tif (sa) {\n\t\t\t\t\tedges[i].push_back(make_pair(j, sa));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvector<int>used(N);\n\t\tlong long int hide_max = -1;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tif (!used[i]) {\n\t\t\t\tif (edges[i].size()==1) {\n\t\t\t\t\tused[i] = true;\n\t\t\t\t\tvector<long long int>v;\n\t\t\t\t\tdfs(i, -1, edges, used, v);\n\t\t\t\t\tif (v.size() < K-1)continue;\n\t\t\t\t\telse {\n\t\t\t\t\t\tlong long int sum = 0;\n\t\t\t\t\t\tfor (int i = 0; i < K - 1; ++i) {\n\t\t\t\t\t\t\tsum += v[i];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor (int i = K - 1; i <=v.size(); ++i) {\n\t\t\t\t\t\t\thide_max = max(hide_max, sum);\n\t\t\t\t\t\t\tsum -= v[(i - K + 1) % v.size()];\n\t\t\t\t\t\t\tsum += v[i%v.size()];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tif (!used[i]) {\n\t\t\t\tused[i] = true;\n\t\t\t\tif (!edges[i].empty()) {\n\t\t\t\t\tvector<long long int>v;\n\t\t\t\t\tdfs(i, edges[i][0].first, edges, used, v);\n\t\t\t\t\tif (v.size() < K)continue;\n\t\t\t\t\telse if (v.size() == K) {\n\t\t\t\t\t\thide_max = max(hide_max, accumulate(v.begin(), v.end(), 0ll));\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tlong long int sum = 0;\n\t\t\t\t\t\tfor (int i = 0; i < K-1; ++i) {\n\t\t\t\t\t\t\tsum += v[i];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor (int i = K-1; i <= v.size()+K; ++i) {\n\t\t\t\t\t\t\thide_max = max(hide_max, sum);\n\t\t\t\t\t\t\tsum -= v[(i - K+1) % v.size()];\n\t\t\t\t\t\t\tsum += v[i%v.size()];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t}\n\t\tif (hide_max == -1)cout << -1 << endl;\n\t\telse {\n\t\t\tcout << total - hide_max << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nstruct cube{\n  int x,y,z;\n  cube(){}\n  cube(int x,int y,int z):x(x),y(y),z(z){}\n};\n#define MAX 3000\nbool used[MAX];\nint c[MAX][MAX];\nvector<cube> vc;\nvector<int> vi;\nvector<vector<int> > G;\nbool dfs(int v,int p){\n  bool f=false;\n  if(used[v]) return true;\n  vi.push_back(v);used[v]=1;\n  for(int i=0;i<G[v].size();i++) {\n    if(i&&!~p) reverse(vi.begin(),vi.end());\n    if(G[v][i]!=p) f|=dfs(G[v][i],v);\n  }\n  return f;\n}\nint main(){\n  int n,k,s,i,j,l,t;\n  while(cin>>n>>k>>s,n||k||s){\n    int ans=-1;\n    memset(c,0,sizeof(c));\n    G.clear();G.resize(n);\n    vc.clear();vc.resize(n);\n    for(i=0;i<n;i++) cin>>vc[i].x>>vc[i].y>>vc[i].z;\n    for(i=0;i<n;i++){\n      for(j=i+1;j<n;j++){\n        int xx=s-abs(vc[i].x-vc[j].x),\n          yy=s-abs(vc[i].y-vc[j].y),\n          zz=s-abs(vc[i].z-vc[j].z);\n        if(xx>0&&yy>0&&zz>0){\n          G[i].push_back(j);\n          G[j].push_back(i);\n          c[i][j]=c[j][i]=(xx*yy+yy*zz+zz*xx)*2;\n        }\n      }\n    }\n    memset(used,0,sizeof(used));\n    for(i=0;i<n;i++){\n      if(used[i]) continue;\n      vi.clear();\n      bool f=dfs(i,-1);\n      if(vi.size()<k) continue;\n      t=0;\n      if(f){\n        if(vi.size()==k){\n          for(j=0;j<k;j++) t+=c[vi[j]][vi[(j+1)%k]];\n          ans=max(ans,t);\n        }else{\n          for(j=0;j<k-1;j++) t+=c[vi[j]][vi[j+1]];\n          ans=max(ans,t);\n          int si=vi.size();\n          for(j=0;j<si;j++){\n            t+=c[vi[(k-1+j)%si]][vi[(k+j)%si]]-c[vi[j%si]][vi[(j+1)%si]];\n            ans=max(ans,t);\n          } \n        }\n      }else{\n        for(j=0;j<k-1;j++) t+=c[vi[j]][vi[j+1]];\n        ans=max(ans,t);\n        for(j=0;j<vi.size()-k;j++){\n          t+=c[vi[k-1+j]][vi[k+j]]-c[vi[j]][vi[j+1]];\n          ans=max(ans,t);\n        } \n      }\n    }\n    if(~ans) cout << s*s*6*k-ans << endl;\n    else cout << -1 << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define int long long\n#define DBG 1\nusing VI=vector<int>;\nusing VVI = vector<VI>;\nconst int INF = 0x3f3f3f3f3f3f3f3fLL;\n\nsigned main(void) {\n\tfor (int n, k, s; cin >> n >> k >> s && n;) {\n\t\tint ans = INF;\n\t\tvector<int> x(n), y(n), z(n);\n\t\trep(i, 0, n)cin >> x[i] >> y[i] >> z[i];\n\n\t\tauto S = [&](int i, int j) {\n\t\t\tint ans = -1LL;\n\t\t\tint dx = s - abs(x[i] - x[j]);\n\t\t\tint dy = s - abs(y[i] - y[j]);\n\t\t\tint dz = s - abs(z[i] - z[j]);\n\t\t\tif (dx >= 0 && dy >= 0 && dz >= 0)\n\t\t\t\tans = 2 * ((dx * dy) + (dy * dz) + (dz * dx));\n\t\t\t//cerr << i << \" \" << j << \" \" << ans << endl;\n\t\t\treturn ans;\n\t\t};\n\n\t\tvector<vector<int>> G(n);\n\t\trep(i, 0, n)rep(j, i + 1, n) {\n\t\t\tif (S(i, j) > 0) {\n\t\t\t\tG[i].push_back(j);\n\t\t\t\tG[j].push_back(i);\n\t\t\t\t////cerr << i << \" \" << j << endl;\n\t\t\t}\n\t\t}\n\n\t\tvector<bool> vis(n);\n\n\t\tfunction<bool(int, vector<int>&)> dfs = [&](int u, vector<int>& list) {\n\t\t\tvis[u] = true;\n\t\t\tint p = list.size() ? list.back() : -1;\n\t\t\tlist.push_back(u);\n\t\t\tfor (auto v : G[u]) {\n\t\t\t\tif (p == v)continue;\n\t\t\t\tif (vis[v])return true;\n\t\t\t\treturn dfs(v, list);\n\t\t\t}\n\t\t\treturn false;\n\t\t};\n\t\t//cerr << \" \" << endl;\n\t\trep(i, 0, n) {\n\t\t\tif (vis[i])continue;\n\t\t\tvector<int> list;\n\t\t\tbool loop = dfs(i, list);\n\t\t\tif (!loop) {\n\t\t\t\tfor (auto u : list)vis[u] = false;\n\t\t\t\tint u = list.back();\n\t\t\t\tlist.clear();\n\t\t\t\tdfs(u, list);\n\t\t\t}\n\t\t\tint m = list.size();\n\n\t\t\tif (m < k)continue;\n\t\t\tint cs = 2 * s * s * 3 * k;\n\t\t\trep(j, 0, k - 1)\n\t\t\t\tcs -= S(list[j], list[(j + 1) % m]);\n\t\t\tans = min(ans, cs);\n\t\t\tif (loop && m == k && m >= 2) {\n\t\t\t\tcs -= S(list[k - 1], list[0]);\n\t\t\t\tans = min(ans, cs);\n\t\t\t\t//cerr << \" \" << endl;\n\t\t\t}\n\t\t\telse {\n\t\t\t\trep(j, 0, m) {\n\t\t\t\t\tint a = S(list[j], list[(j + 1) % m]);\n\t\t\t\t\tint b = S(list[(j + k - 1) % m], list[(j + k) % m]);\n\t\t\t\t\tif (b < 0)break;\n\t\t\t\t\tcs += a;\n\t\t\t\t\tcs -= b;\n\t\t\t\t\tans = min(ans, cs);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << (ans == INF ? -1 : ans) << endl;\n\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cassert>\n\nusing namespace std;\nusing ll = long long;\nconstexpr ll INF = 1LL << 50;\nll s;\n\nstruct Cube {\n    ll x;\n    ll y;\n    ll z;\n};\nll connected(const Cube& c1, const Cube& c2)\n{\n    const ll x1 = c1.x;\n    const ll y1 = c1.y;\n    const ll z1 = c1.z;\n    for (int i = 0; i < 2; i++) {\n        const ll x2 = c2.x + i * s;\n        const ll dx = x2 - x1;\n        for (int j = 0; j < 2; j++) {\n            const ll y2 = c2.y + j * s;\n            const ll dy = y2 - y1;\n            for (int k = 0; k < 2; k++) {\n                const ll z2 = c2.z + k * s;\n                const ll dz = z2 - z1;\n                if (0 <= dx and dx <= s and 0 <= dy and dy <= s and 0 <= dz and dz <= s) {\n                    const ll lx = (i == 0) ? s - dx : dx;\n                    const ll ly = (j == 0) ? s - dy : dy;\n                    const ll lz = (k == 0) ? s - dz : dz;\n                    if (lx > 0 and ly > 0 and lz > 0) {\n                        return (lx * ly + ly * lz + lz * lx) * 2;\n                    }\n                }\n            }\n        }\n    }\n    return 0;\n}\n\nstruct Edge {\n    int from;\n    int to;\n    ll cost;\n};\nstruct Graph {\n    Graph(const int n)\n    {\n        edge.resize(n);\n    }\n    void addEdge(const int from, const int to, const ll cost)\n    {\n        edge[from].push_back(Edge{from, to, cost});\n        edge[to].push_back(Edge{to, from, cost});\n    }\n    vector<vector<Edge>> edge;\n};\n\nint getEdge(const Graph& g, const int s, vector<bool>& visited)\n{\n    visited[s] = true;\n    int child = 0;\n    for (const auto& e : g.edge[s]) {\n        if (not visited[e.to]) {\n            return getEdge(g, e.to, visited);\n        }\n    }\n    if (child == 0) {\n        return s;\n    }\n}\nstruct Chain {\n    bool ring = false;\n    vector<ll> edges;\n};\nostream& operator<<(ostream& os, const Chain& ch)\n{\n    os << \"Ring: \" << boolalpha << ch.ring << \"\\nEdge: {\";\n    for (int i = 0; i < ch.edges.size(); i++) {\n        if (i != 0) {\n            os << \",\";\n        }\n        os << ch.edges[i];\n    }\n    os << \"}\" << endl;\n}\nvoid dfs(const Graph& g, const int s, const int dep, vector<bool>& visited, Chain& chain)\n{\n    visited[s] = true;\n    for (const auto& e : g.edge[s]) {\n        if (e.to == dep and chain.edges.size() >= 2) {\n            if (not chain.ring) {\n                chain.edges.push_back(e.cost);\n                chain.ring = true;\n            }\n            return;\n        }\n        if (not visited[e.to]) {\n            chain.edges.push_back(e.cost);\n            dfs(g, e.to, dep, visited, chain);\n        }\n    }\n}\n\nint main()\n{\n    while (true) {\n        int n, k;\n        cin >> n >> k >> s;\n        if (n == 0 and k == 0 and s == 0) {\n            break;\n        }\n\n        const ll whole = 6 * s * s * k;\n        if (k == 1) {\n            cout << whole << endl;\n            continue;\n        }\n\n        vector<Cube> cube(n);\n        for (int i = 0; i < n; i++) {\n            cin >> cube[i].x >> cube[i].y >> cube[i].z;\n        }\n        Graph g(n);\n        int e = 0;\n        for (int i = 0; i < n - 1; i++) {\n            for (int j = i + 1; j < n; j++) {\n                const ll cost = connected(cube[i], cube[j]);\n                if (cost > 0) {\n                    e++;\n                    g.addEdge(i, j, cost);\n                }\n            }\n        }\n        assert(e <= n);\n        vector<bool> visited(n, false);\n        vector<Chain> chains;\n        for (int i = 0; i < n; i++) {\n            if (not visited[i]) {\n                vector<bool> visited2(n, false);\n                const int dep = getEdge(g, i, visited2);\n                Chain chain;\n                chain.ring = false;\n                dfs(g, dep, dep, visited, chain);\n                chains.push_back(chain);\n            }\n        }\n        ll mini = INF;\n        for (const auto chain : chains) {\n            const bool ring = chain.ring;\n            const vector<ll>& costs = chain.edges;\n            if (costs.size() < k) {\n                continue;\n            }\n            if (ring) {\n                ll sum = 0;\n                for (int i = 0; i < k - 1; i++) {\n                    sum += costs[i];\n                }\n                if (costs.size() == k) {\n                    sum += costs[k - 1];\n                    mini = min(mini, whole - sum);\n                } else {\n                    mini = min(mini, whole - sum);\n                    int head = 0;\n                    int tail = k - 1;\n                    for (int j = 0; j < costs.size(); j++, head++, tail++, tail = tail % costs.size()) {\n                        sum += (costs[tail] - costs[head]);\n                        mini = min(mini, whole - sum);\n                    }\n                }\n            } else {\n                ll sum = 0;\n                for (int i = 0; i < k - 1; i++) {\n                    sum += costs[i];\n                }\n                mini = min(mini, whole - sum);\n                int head = 0;\n                int tail = k - 1;\n                for (; tail < costs.size(); head++, tail++) {\n                    sum += (costs[tail] - costs[head]);\n                    mini = min(mini, whole - sum);\n                }\n            }\n        }\n        cout << ((mini == INF) ? -1 : mini) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\n\nint N, K, S;\n\nclass cube{\n    public:\n    int x, y, z;\n    int cp(int a, int b){\n        if(abs(a-b)>=S)return 0;\n        return S - abs(a-b);\n    }\n    int compare(cube c){\n        int xx = cp(x, c.x);\n        int yy = cp(y, c.y);\n        int zz = cp(z, c.z);\n        if(xx==0 || yy==0 || zz==0)return 0;\n        return xx * yy * 2 + xx * zz * 2 + yy * zz * 2;\n    }\n};\n\nint main(){\n\n    for(;cin>>N>>K>>S, N;){\n        vector<cube>cubes(N);\n        for(int i=0;i<N;i++){\n            cin>>cubes[i].x;\n            cin>>cubes[i].y;\n            cin>>cubes[i].z;\n        }\n        if(K==1){\n            cout<<S*S*6<<endl;\n            continue;\n        }\n        int ans = 100*100*6*2000;\n        vector<int>link[N];\n        for(int i=0;i<N;i++){\n            for(int j=i+1;j<N;j++){\n                if(cubes[i].compare(cubes[j])){\n                    link[i].push_back(j);\n                    link[j].push_back(i);\n                }\n            }\n        }\n        for(int i=0;i<N;i++){\n            for(int j=0;j<link[i].size();j++){\n                int k=1;\n                int score = S*S*6;\n                int lst = -1;\n                int now = i;\n                int nxt = link[i][j];\n                for(;;){\n                    if(k==K){\n                        int f = 0;\n                        for(int l=0;l<link[now].size();l++){\n                            if(link[now][l]==i)f=1;\n                        }\n                        if(lst==i)f=0;\n                        if(f)score -= cubes[i].compare(cubes[now]);\n                        ans = min(ans, score);\n                        break;\n                    }\n                    if(nxt==-1)break;\n                    int tmp = -1;\n                    for(int l=0;l<link[nxt].size();l++){\n                        if(link[nxt][l]==i || link[nxt][l]==now)continue;\n                        tmp = link[nxt][l];\n                    }\n                    score += S*S*6 - cubes[now].compare(cubes[nxt]);\n                    int f = 0;\n                    lst = now;\n                    now = nxt;\n                    nxt = tmp;\n                    k++;\n                }\n            }\n        }\n        if(ans==100*100*6*2000)cout<<-1<<endl;\n        else cout<<ans<<endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define dbg(...) do{cerr<<__LINE__<<\": \";dbgprint(#__VA_ARGS__, __VA_ARGS__);}while(0);\n\nusing namespace std;\n\nnamespace std{template<class S,class T>struct hash<pair<S,T>>{size_t operator()(const pair<S,T>&p)const{return ((size_t)1e9+7)*hash<S>()(p.first)+hash<T>()(p.second);}};template<class T>struct hash<vector<T>>{size_t operator()(const vector<T> &v)const{size_t h=0;for(auto i : v)h=h*((size_t)1e9+7)+hash<T>()(i)+1;return h;}};}\ntemplate<class T>ostream& operator<<(ostream &os, const vector<T> &v){os<<\"[ \";rep(i,v.size())os<<v[i]<<(i==v.size()-1?\" ]\":\", \");return os;}template<class T>ostream& operator<<(ostream &os,const set<T> &v){os<<\"{ \"; for(const auto &i:v)os<<i<<\", \";return os<<\"}\";}\ntemplate<class T,class U>ostream& operator<<(ostream &os,const map<T,U> &v){os<<\"{\";for(const auto &i:v)os<<\" \"<<i.first<<\": \"<<i.second<<\",\";return os<<\"}\";}template<class T,class U>ostream& operator<<(ostream &os,const pair<T,U> &p){return os<<\"(\"<<p.first<<\", \"<<p.second<<\")\";}\nvoid dbgprint(const string &fmt){cerr<<endl;}template<class H,class... T>void dbgprint(const string &fmt,const H &h,const T&... r){cerr<<fmt.substr(0,fmt.find(\",\"))<<\"= \"<<h<<\" \";dbgprint(fmt.substr(fmt.find(\",\")+1),r...);}\ntypedef long long ll;typedef vector<int> vi;typedef pair<int,int> pi;const int inf = (int)1e9;const double INF = 1e12, EPS = 1e-9;\n\nint main(){\n\tcin.tie(0); cin.sync_with_stdio(0);\n\tint n, k, s;\n\twhile(cin >> n >> k >> s, n){\n\t\tvi x(n), y(n), z(n);\n\t\trep(i, n) cin >> x[i] >> y[i] >> z[i];\n\t\t\n\t\tauto intersect = [&](int i, int j){\n\t\t\tll dx = s - abs(x[i] - x[j]);\n\t\t\tll dy = s - abs(y[i] - y[j]);\n\t\t\tll dz = s - abs(z[i] - z[j]);\n\t\t\tif(dx <= 0 || dy <= 0 || dz <= 0) return 0ll;\n\t\t\treturn (dx * dy + dy * dz + dz * dx) * 2;\n\t\t};\n\t\t\n\t\tvector<vi> e(n);\n\t\trep(i, n) rep(j, i) if(intersect(i, j)){\n\t\t\te[i].pb(j);\n\t\t\te[j].pb(i);\n\t\t\t//dbg(i, j);\n\t\t}\n\t\trep(i, n) assert(e[i].size() <= 2);\n\t\t\n\t\tfunction<bool(int,int,vector<bool>&,vi&)> rec = [&](int c, int p, vector<bool> &v, vi &idx){\n\t\t\tv[c] = 1;\n\t\t\tbool ans = 0;\n\t\t\tidx.pb(c);\n\t\t\tfor(int i : e[c]) if(i != p){\n\t\t\t\tif(v[i]) ans |= 1;\n\t\t\t\telse ans |= rec(i, c, v, idx); \n\t\t\t}\n\t\t\treturn ans;\n\t\t};\n\t\t\n\t\tll ans = 1e18;\n\t\tvector<bool> v(n);\n\t\trep(ii, n) if(!v[ii]){\n\t\t\tvi idx;\n\t\t\tbool loop = rec(ii, ii, v, idx);\n\t\t\tif(idx.size() < k) continue;\n\t\t\t\n\t\t\tif(loop && idx.size() == k){\n\t\t\t\tll sum = 6ll * k * s * s;\n\t\t\t\trep(i, (int)idx.size()){\n\t\t\t\t\tll c = intersect(idx[i], idx[(i + 1) % idx.size()]);\n\t\t\t\t\tsum -= c;\n\t\t\t\t}\n\t\t\t\tans = min(ans, sum);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tll sum = 6ll * k * s * s;\n\t\t\tif(k == 1){\n\t\t\t\tans = min(ans, sum);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tvector<ll> costs;\n\t\t\tif(loop){\n\t\t\t\trep(i, (int)idx.size())\n\t\t\t\t\tcosts.pb(intersect(idx[i], idx[(i + 1) % idx.size()]));\n\t\t\t\tint it = idx.size();\n\t\t\t\trep(i, it+2) idx.pb(idx[i]);\n\t\t\t\t\n\t\t\t\trep(i, it) assert(count(all(e[idx[i]]), idx[i+1]));\n\t\t\t}\n\t\t\telse{\n\t\t\t\tint hasi = 0;\n\t\t\t\trep(i, idx.size()) if(e[idx[i]].size() == 1) hasi = idx[i];\n\t\t\t\tfor(int i : idx) v[i] = 0;\n\t\t\t\tidx.clear();\n\t\t\t\trec(hasi, hasi, v, idx);\n\t\t\t\t\n\t\t\t\trep(i, (int)idx.size()-1)\n\t\t\t\t\tcosts.pb(intersect(idx[i], idx[i + 1]));\n\t\t\t\t#if 1\n\t\t\t\tassert(idx.size() >= 2);\n\t\t\t\trep(i, idx.size()){\n\t\t\t\t\tif(i==0 || i==idx.size()-1) assert(e[idx[i]].size() == 1);\n\t\t\t\t\telse assert(e[idx[i]].size()==2);\n\t\t\t\t\tassert(e[idx[i]].size() <= 2);\n\t\t\t\t\tassert(e[idx[i]].size() >= 1);\n\t\t\t\t\t\n\t\t\t\t\tif(i < idx.size()-2) assert(count(all(e[idx[i]]), idx[i+1]));\n\t\t\t\t}\n\t\t\t\t#endif\n\t\t\t}\n\t\t\t//dbg(k, costs);\n\t\t\t\n\t\t\trep(i, k-2) sum -= costs[i];\n\t\t\trep(i, (int)costs.size() - (k-1) + 1){\n\t\t\t\tsum -= costs[i + k-2];\n\t\t\t\tans = min(ans, sum);\n\t\t\t\tsum += costs[i];\n\t\t\t}\n\t\t}\n\t\tif(ans >= 1e18) ans = -1;\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <functional>\nusing namespace std;\n\nstruct cube {\n    int x, y, z, w;\n    cube() {}\n    cube(int a, int b, int c, int d): x(a), y(b), z(c), w(d) {}\n\n    int overlap_area(cube o) {\n        int ox = w - abs(x - o.x);\n        int oy = w - abs(y - o.y);\n        int oz = w - abs(z - o.z);\n\n        if (ox < 0 || oy < 0 || oz < 0) {\n            return -1;\n        }\n\n        return 2 * (ox * oy + oy * oz + oz * ox);\n    }\n};\n\nint main() {\n    int N, K, S;\n    while (true) {\n        cin >> N >> K >> S;\n        if (N == 0 && K == 0 && S == 0) break;\n\n        vector<cube> cubes;\n        vector<vector<int>> graph(N);\n\n        for (int j = 0; j < N; ++j) {\n            int x, y, z; cin >> x >> y >> z;\n            cubes.emplace_back(x, y, z, S);\n        }\n\n        if (K == 1) {\n            cout << 6*S*S << endl;\n            continue;\n        }\n\n        for (int j = 0; j < N; ++j) {\n            for (int k = j+1; k < N; ++k) {\n                int area = cubes[j].overlap_area(cubes[k]);\n                if (area >= 0) {\n                    graph[j].push_back(k);\n                    graph[k].push_back(j);\n                }\n            }\n        }\n\n        vector<int> visited(N, 0);\n        function<int(int)> get_start = [&](int v) -> int {\n            visited[v] = 1;\n            for (int w: graph[v]) {\n                if (!visited[w])\n                    return get_start(w);\n            }\n            return v;\n        };\n\n        int ans = -1;\n\n        for (int j = 0; j < N; ++j) {\n            if (visited[j])\n                continue;\n            int s = get_start(j);\n\n            vector<int> chain;\n            function<bool(int, int)> set_chain = [&](int v, int prev) -> bool {\n                chain.push_back(v);\n                visited[v] = 1;\n                for (int w: graph[v]) {\n                    if (w == prev) continue;\n                    if (w == s) return true; \n                    return set_chain(w, v);\n                }\n                return false;\n            };\n            bool loop = set_chain(s, -1);\n\n            const int L = chain.size();\n            if (L < K) continue;\n\n            int area = 6*S*S;\n            for (int j = 1; j < (loop ? 2*L : L); ++j) {\n                if (j >= K) {\n                    int v0 = chain[(j-K)%L], v1 = chain[(j-K+1)%L];\n                    area -= 6*S*S - cubes[v0].overlap_area(cubes[v1]);\n                }\n\n                area += 6*S*S - cubes[chain[(j-1)%L]].overlap_area(cubes[chain[j%L]]);\n                if (loop && L == K && j == L-1) {\n                    area -= cubes[chain[j%L]].overlap_area(cubes[chain[(j+1)%L]]);\n                }\n\n                if (j+1 >= K)\n                    ans = (ans == -1) ? area : min(ans, area);\n            }\n        }\n\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i,n) for(int i = 0;i < (n);i++)\nconst int INF = 1e+9;\nusing namespace std;\n\nint N, K, S;\n\nstruct Point{\n    int x, y, z;\n};\n\nPoint p[2103];\n\nbool used[2103];\nvector<int> graph[2003];\n\nint getS(int u, int v){\n    Point a = p[u], b = p[v];\n    if(a.x > b.x) swap(a.x, b.x);\n    if(a.y > b.y) swap(a.y, b.y);\n    if(a.z > b.z) swap(a.z, b.z);\n    return (a.x + S - b.x) * (a.y + S - b.y) * 2\n        +  (a.z + S - b.z) * (a.x + S - b.x) * 2\n        +  (a.y + S - b.y) * (a.z + S - b.z) * 2;\n}\n\nbool connected(int a,int b){\n    return (abs(p[a].x-p[b].x) <= S) && (abs(p[a].y-p[b].y) <= S) && (abs(p[a].z-p[b].z) <= S);\n}\n\nint main(){\n    while(cin >> N >> K >> S, N){\n        REP(i,N){\n            int x, y, z;\n            cin >> x >> y >> z;\n            p[i] = Point{x, y, z};\n            graph[i].clear();\n        }\n\n        REP(i,N){\n            REP(j,N){\n                if(i == j) continue;\n                if(connected(i, j)){\n                    graph[i].push_back(j);\n                }\n            }     \n        }\n\n        int ans = INF;\n        REP(i,N){\n            fill_n(used, N, false);\n            int res = S*S*6*K;\n            int endindex = -1;\n            queue<int> que;// pre, now\n            used[i] = true;\n            que.push(i);\n            int ct = 1;\n            while(!que.empty()){\n                if(ct == K) break;\n                int u = que.front();\n                que.pop();\n                for(int v : graph[u]){\n                    if(used[v]) continue;\n                    used[v] = true;\n                    que.push(v);\n                    endindex = v;\n                    ct++;\n                    res -= getS(u, v);\n                    break;\n                }\n            }\n            if(connected(i,endindex) && K >= 3){\n                res -= getS(i, endindex);\n            }\n            if(ct == K) ans = min(res, ans);\n        }\n        if(ans == INF) cout << -1 << endl;\n        else cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i,n) for(int i = 0;i < (n);i++)\nconst long long INF = 2 * (int)(1e9);\nusing namespace std;\n\nint N, K, S;\n\nstruct Point{\n    int x, y, z;\n};\n\nPoint p[2103];\n\nbool iscycle[2103];\nbool used[2103];\ndeque<int> graph[2103];\n\nint getS(Point a,Point b){\n    if(a.x > b.x) swap(a.x, b.x);\n    if(a.y > b.y) swap(a.y, b.y);\n    if(a.z > b.z) swap(a.z, b.z);\n    return (a.x + S - b.x) * (a.y + S - b.y) * 2\n        +  (a.z + S - b.z) * (a.x + S - b.x) * 2\n        +  (a.y + S - b.y) * (a.z + S - b.z) * 2;\n}\n\nbool connected(int a,int b){\n    return (abs(p[a].x-p[b].x) <= S) && (abs(p[a].y-p[b].y) <= S) && (abs(p[a].z-p[b].z) <= S);\n}\n\nvoid makegraph(int graphct, int i, bool maincalled, bool back){\n    REP(j,N){\n        if(used[j])continue;\n        if(connected(i,j)){\n            used[j] = true;\n            if(graph[graphct].size() > 1 && (maincalled || back)){\n                graph[graphct].push_front(j);\n                makegraph(graphct, j, false, true);\n            }else{\n                graph[graphct].push_back(j);\n                makegraph(graphct, j, false, false);\n            }\n        }\n    }\n}\n\n\nint main(){\n    while(cin >> N >> K >> S, N){\n        REP(i,N){\n            int x, y, z;\n            cin >> x >> y >> z;\n            p[i] = Point{x, y, z};\n            graph[i].clear();\n            iscycle[i] = false;\n            used[i] = false;\n        }\n\n        //make graph\n        int graphct = 0;\n        REP(i,N){\n            if(used[i]) continue;\n            graph[graphct].push_back(i);\n            used[i] = true;\n            makegraph(graphct, i, true, true);\n            graphct++;\n        }\n        \n        //k == 1\n        if(K == 1){\n            cout << S*S*6 << endl;\n            continue;\n        }\n\n        //cycle check\n        REP(i,graphct){\n            if(graph[i].size() > 2 && connected(graph[i][0],graph[i][graph[i].size() - 1]))\n                iscycle[i] = true;\n        }\n        \n        long long ans = INF;\n        REP(i,graphct){\n            if((int)graph[i].size() < K) continue;\n            REP(j,graph[i].size()){\n                if(j + K - 1 > graph[i].size() - 1) break;\n                long long tmpans = 0;\n                for(int r = 0; r < K;r++){\n                    tmpans += S*S*6;\n                    if(r){\n                        tmpans -= getS(p[graph[i][j + r]], p[graph[i][j + r - 1]]);\n                    }else if(iscycle[i] && K == graph[i].size()){\n                        tmpans -= getS(p[graph[i][0]], p[graph[i][graph[i].size() - 1]]);\n                    }\n                }\n                ans = min(tmpans, ans);\n            }\n        }\n        if(ans == INF) cout << -1 << endl;\n        else cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing ll = long long;\nstruct Edge {\n    int dst;\n    ll w;\n    Edge() {}\n    Edge(ll d, ll w) : dst(d), w(w) {}\n};\nusing Graph = vector<vector<Edge>>;\nstruct Cube { ll p[3]; };\n\n// グラフを構成する\nGraph MakeGraph(const int n, const int s, vector<Cube> &c) {\n    Graph g(n);\n    ll d[3];\n\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            for (int k = 0; k < 3; ++k)\n                d[k] = s - abs(c[i].p[k] - c[j].p[k]);\n\n            // c[i]とc[j]は交差しない\n            if (min({d[0], d[1], d[2]}) <= 0) continue;\n\n            ll w = 2 * d[0] * d[1] + 2 * d[0] * d[2] + 2 * d[1] * d[2];\n            g[i].emplace_back(Edge(j, w));\n            g[j].emplace_back(Edge(i, w));\n        }\n    }\n\n    return g;\n}\n\nll Dfs(const int start, const int prev, const int cur, int size, const Graph &g) {\n    if (size == 0) {\n        if ((g[cur].size() == 2) && ((g[cur][0].dst == start && g[cur][0].dst != prev)\n             || (g[cur][1].dst == start && g[cur][1].dst != prev)))\n            return (g[cur][0].dst == start) ? g[cur][0].w : g[cur][1].w;\n        else\n            return 0;\n    }\n\n    ll max_w = -1;\n    for (const auto &e : g[cur])\n        if (e.dst != prev) {\n            const ll res = Dfs(start, cur, e.dst, size - 1, g);\n            if (res != -1) max_w = max(max_w, res + e.w);\n        }\n\n    return max_w;\n}\n\nint MinimumArea(const int n, const int k, const int s, const Graph &g) {\n    ll res = -1;\n\n    for (int v = 0; v < n; ++v)\n        res = max(res, Dfs(v, -1, v, k - 1, g));\n\n    return (res == -1) ? -1 : 6 * k * s * s - res;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int n, k, s;\n\n    while (cin >> n >> k >> s, n) {\n        vector<Cube> cube(n);\n        for (auto &c : cube)\n            for (int i = 0; i < 3; ++i) cin >> c.p[i];\n\n        cout << MinimumArea(n, k, s, MakeGraph(n, s, cube)) << '\\n';\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing ll = long long;\nstruct Edge {\n    ll dst, w;\n    Edge() {}\n    Edge(ll d, ll w) : dst(d), w(w) {}\n};\nusing Graph = vector<vector<Edge>>;\nstruct Cube { ll p[3]; };\n\n// グラフを構成する\nGraph MakeGraph(const int n, const int s, vector<Cube> &c) {\n    Graph g(n);\n    ll d[3];\n\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            for (int k = 0; k < 3; ++k)\n                d[k] = s - abs(c[i].p[k] - c[j].p[k]);\n\n            // c[i]とc[j]は交差しない\n            if (min({d[0], d[1], d[2]}) <= 0) continue;\n\n            ll w = 2 * d[0] * d[1] + 2 * d[0] * d[2] + 2 * d[1] * d[2];\n            g[i].emplace_back(Edge(j, w));\n            g[j].emplace_back(Edge(i, w));\n        }\n    }\n\n    return g;\n}\n\nll Dfs(const int start, const int prev, const int cur, int size, const Graph &g) {\n    if (size == 0) {\n        if (g[cur].size() <= 1) return 0;\n        else if (g[cur][0].dst == start || g[cur][1].dst == start) return g[cur][0].w;\n        else return 0;\n    }\n\n    ll max_w = -1;\n    for (const auto &e : g[cur])\n        if (e.dst != prev) {\n            const ll res = Dfs(start, cur, e.dst, size - 1, g);\n            if (res != -1) max_w = max(max_w, res + e.w);\n        }\n\n    return max_w;\n}\n\nint MinimumArea(const int n, const int k, const int s, const Graph &g) {\n    ll res = -1;\n\n    for (int v = 0; v < n; ++v)\n        res = max(res, Dfs(v, -1, v, k - 1, g));\n\n    return (res == -1) ? -1 : 6 * k * s * s - res;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int n, k, s;\n\n    while (cin >> n >> k >> s, n) {\n        vector<Cube> cube(n);\n        for (auto &c : cube)\n            for (int i = 0; i < 3; ++i) cin >> c.p[i];\n\n        cout << MinimumArea(n, k, s, MakeGraph(n, s, cube)) << '\\n';\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\nconst int INF = 1LL << 58;\n\nstruct edge\n{\n  int to, cost;\n};\n\nsigned main()\n{\n  int N, K, S;\n  int X[2000], Y[2000], Z[2000];\n\n  while(cin >> N >> K >> S, N) {\n    for(int i = 0; i < N; i++) {\n      cin >> X[i] >> Y[i] >> Z[i];\n    }\n\n    vector< edge > g[2000];\n    for(int i = 0; i < N; i++) {\n      for(int j = 0; j < i; j++) {\n        int latte = max(0LL, S - abs(X[i] - X[j]));\n        int malta = max(0LL, S - abs(Y[i] - Y[j]));\n        int beeet = max(0LL, S - abs(Z[i] - Z[j]));\n        int ukuku = latte * malta + malta * beeet + beeet * latte;\n        if(latte > 0 && malta > 0 && beeet > 0) {\n          g[i].emplace_back((edge) {j, ukuku});\n          g[j].emplace_back((edge) {i, ukuku});\n        }\n      }\n    }\n\n    int ret = -1;\n    for(int i = 0; i < N; i++) {\n      bool v[2000] = {};\n      function< void(int, int, int) > dfs = [&](int idx, int k, int sz)\n      {\n        if(v[idx]++) return;\n        if(k == 0) {\n          if(K >= 3) for(auto &e: g[idx]) if(e.to == i) sz += e.cost;\n          ret = max(ret, sz);\n        } else {\n          for(auto &e : g[idx]) dfs(e.to, k - 1, sz + e.cost);\n        }\n        v[idx] = false;\n      };\n      dfs(i, K - 1, 0);\n    }\n    if(ret == -1) cout << -1 << endl;\n    else cout << 6 * S * S * K - ret * 2 << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#define inf 1000000000\n\nusing namespace std;\n\nstruct edge{\n\tint to, cost;\n\tedge(){}\n\tedge(int a, int b){\n\t\tto = a, cost = b;\n\t}\n};\n\nint n, k, s;\nint x[2005], y[2005], z[2005];\nvector<edge> G[2005];\n\nint dfs(int v, int prev, int k)\n{\n\tif(k == 0) return 0;\n\t\n\tint ret = -inf;\n\tfor(int i = 0; i < G[v].size(); i++){\n\t\tif(G[v][i].to == prev) continue;\n\t\tret = max(ret, G[v][i].cost + dfs(G[v][i].to, v, k-1));\n\t}\n\treturn ret;\n}\n\nint main(void)\n{\n\twhile(1){\n\t\tcin >> n >> k >> s;\n\t\tif(n == 0 && k == 0 && s == 0) break;\n\t\tfor(int i = 1; i <= n; i++){\n\t\t\tcin >> x[i] >> y[i] >> z[i];\n\t\t}\n\t\t\n\t\tfor(int i = 1; i <= n; i++) G[i].clear();\n\t\tint dx, dy, dz, w;\n\t\tfor(int i = 1; i <= n; i++){\n\t\t\tfor(int j = 1; j <= n; j++){\n\t\t\t\tif(i >= j) continue;\n\t\t\t\tdx = s - abs(x[i] - x[j]);\n\t\t\t\tdy = s - abs(y[i] - y[j]);\n\t\t\t\tdz = s - abs(z[i] - z[j]);\n\t\t\t\tif(dx < 0 || dy < 0 || dz < 0) continue;\n\t\t\t\tw = 2 * (dx*dy + dy*dz + dz*dx);\n\t\t\t\tG[i].push_back( edge(j, w) );\n\t\t\t\tG[j].push_back( edge(i, w) );\n\t\t\t}\n\t\t}\n\t\t\n\t\tint ans = -inf;\n\t\tfor(int i = 1; i <= n; i++){\n\t\t\tans = max(ans, dfs(i, -1, k-1));\n\t\t}\n\t\t\n\t\tif(ans < 0) cout << -1 << endl;\n\t\telse cout << 6*s*s*k - ans << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing ll = long long;\nstruct Edge {\n    int dst;\n    ll w;\n    Edge() {}\n    Edge(int d, ll w) : dst(d), w(w) {}\n};\nusing Graph = vector<vector<Edge>>;\nstruct Cube { ll p[3]; };\n\n\nGraph MakeGraph(const int n, const int s, vector<Cube> &c) {\n    Graph g(n);\n    ll d[3];\n\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            for (int k = 0; k < 3; ++k)\n                d[k] = s + ((c[i].p[k] < c[j].p[k]) ? (c[i].p[k] - c[j].p[k]) : (c[j].p[k] - c[i].p[k]));\n\n            if (d[0] <= 0 || d[1] <= 0 || d[2] <= 0) continue;\n\n            ll w = 2 * d[0] * d[1] + 2 * d[0] * d[2] + 2 * d[1] * d[2];\n            g[i].emplace_back(Edge(j, w));\n            g[j].emplace_back(Edge(i, w));\n        }\n    }\n\n    return g;\n}\n\nint MinimumArea(const int n, const int k, const int s, const Graph &g) {\n    vector<bool> used(n, false);\n    ll res = -1;\n\n    for (int u = 0; u < 2 * n; ++u) {\n        if (used[u % n] || (u < n && g[u % n].size() == 2)) continue;\n\n        const int v = u % n;\n\n        vector<int> sub;\n        int cur = v;\n        while (true) {\n            used[cur] = true;\n            sub.push_back(cur);\n            if (1 <= g[cur].size() && !used[g[cur][0].dst])\n                cur = g[cur][0].dst;\n            else if (g[cur].size() == 2 && !used[g[cur][1].dst])\n                cur = g[cur][1].dst;\n            else\n                break;\n        }\n\n        const int size = sub.size();\n        if (size < k) continue;\n\n        ll sum = 0;\n        for (int i = 0; i < k - 1; ++i)\n            sum += ((g[sub[i]][0].dst == sub[i + 1]) ? g[sub[i]][0].w : g[sub[i]][1].w);\n\n        const bool is_cycle = (g[sub[0]].size() == 2);\n        // cout << \"size = \" << size << \", k = \" << k << \" cycle ?= \" << is_cycle << endl;\n        // cout << sub[0] << \" - \" << sub[size - 1] << \", sum = \" << sum << endl;\n        if (size == k && is_cycle) {\n            sum += ((g[sub[0]][0].dst == sub[size - 1]) ? g[sub[0]][0].w : g[sub[0]][1].w);\n            res = max(res, sum);\n            continue;\n        }\n        res = max(res, sum);\n\n        // cout << \" += \" << ((g[sub[0]][0].dst == sub[size - 1]) ? g[sub[0]][0].w : g[sub[0]][1].w) << endl;\n        // cout << \"sum = \" << sum << endl;\n\n        const int lim = (is_cycle ? size - 1 : size - k);\n//        cout << \"v = \" << v << \", lim = \" << lim << endl;\n        for (int i = 1; i <= lim; ++i) {\n//            cout << \"sum = \" << sum << \", - \" << ((g[sub[i]][0].dst == sub[i - 1]) ? g[sub[i]][0].w : g[sub[i]][1].w); \n            sum -= ((g[sub[i]][0].dst == sub[i - 1]) ? g[sub[i]][0].w : g[sub[i]][1].w);\n            const int j1 = (i + k - 2) % size, j2 = (i + k - 1) % size;\n            sum += ((g[sub[j1]][0].dst == sub[j2]) ? g[sub[j1]][0].w : g[sub[j1]][1].w);\n//            cout << \", + \" << ((g[sub[j1]][0].dst == sub[j2]) ? g[sub[j1]][0].w : g[sub[j1]][1].w) << endl;\n//            cout << \"sub[\" << j1 << \"] = \" << sub[j1] << \", sub[\" << j2 << \"] = \" << sub[j2] << endl;\n//            cout << \"sub[\" << i << \"] = \" << sub[i] << \", sub[\" << (i + 1) % n << \"] = \" << sub[(i + 1) % n]\n//                 << \", sum = \" << sum << endl << endl;;\n            res = max(res, sum);\n        }\n    }\n\n    // for (int v = 0; v < n; ++v) {\n    //     cout << v << \" : \";\n    //     for (auto e : g[v])\n    //         cout << \"(\" << e.dst << \", \" << e.w << \"), \";\n    //     cout << '\\n';\n    // }\n\n    return (res == -1) ? -1 : 6 * k * s * s - res;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int n, k, s;\n\n    while (cin >> n >> k >> s, n) {\n        vector<Cube> cube(n);\n        for (auto &c : cube)\n            for (int i = 0; i < 3; ++i) cin >> c.p[i];\n\n        cout << MinimumArea(n, k, s, MakeGraph(n, s, cube)) << '\\n';\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define dbg(...) do{cerr<<__LINE__<<\": \";dbgprint(#__VA_ARGS__, __VA_ARGS__);}while(0);\n\nusing namespace std;\n\nnamespace std{template<class S,class T>struct hash<pair<S,T>>{size_t operator()(const pair<S,T>&p)const{return ((size_t)1e9+7)*hash<S>()(p.first)+hash<T>()(p.second);}};template<class T>struct hash<vector<T>>{size_t operator()(const vector<T> &v)const{size_t h=0;for(auto i : v)h=h*((size_t)1e9+7)+hash<T>()(i)+1;return h;}};}\ntemplate<class T>ostream& operator<<(ostream &os, const vector<T> &v){os<<\"[ \";rep(i,v.size())os<<v[i]<<(i==v.size()-1?\" ]\":\", \");return os;}template<class T>ostream& operator<<(ostream &os,const set<T> &v){os<<\"{ \"; for(const auto &i:v)os<<i<<\", \";return os<<\"}\";}\ntemplate<class T,class U>ostream& operator<<(ostream &os,const map<T,U> &v){os<<\"{\";for(const auto &i:v)os<<\" \"<<i.first<<\": \"<<i.second<<\",\";return os<<\"}\";}template<class T,class U>ostream& operator<<(ostream &os,const pair<T,U> &p){return os<<\"(\"<<p.first<<\", \"<<p.second<<\")\";}\nvoid dbgprint(const string &fmt){cerr<<endl;}template<class H,class... T>void dbgprint(const string &fmt,const H &h,const T&... r){cerr<<fmt.substr(0,fmt.find(\",\"))<<\"= \"<<h<<\" \";dbgprint(fmt.substr(fmt.find(\",\")+1),r...);}\ntypedef long long ll;typedef vector<int> vi;typedef pair<int,int> pi;const int inf = (int)1e9;const double INF = 1e12, EPS = 1e-9;\n\nint main(){\n\tcin.tie(0); cin.sync_with_stdio(0);\n\tint n, k, s;\n\twhile(cin >> n >> k >> s, n){\n\t\tvi x(n), y(n), z(n);\n\t\trep(i, n) cin >> x[i] >> y[i] >> z[i];\n\t\t\n\t\tauto intersect = [&](int i, int j){\n\t\t\tll dx = s - abs(x[i] - x[j]);\n\t\t\tll dy = s - abs(y[i] - y[j]);\n\t\t\tll dz = s - abs(z[i] - z[j]);\n\t\t\tif(dx <= 0 || dy <= 0 || dz <= 0) return 0ll;\n\t\t\treturn (dx * dy + dy * dz + dz * dx) * 2;\n\t\t};\n\t\t\n\t\tvector<vi> e(n);\n\t\trep(i, n) rep(j, i) if(intersect(i, j)){\n\t\t\te[i].pb(j);\n\t\t\te[j].pb(i);\n\t\t\t//dbg(i, j);\n\t\t}\n\t\trep(i, n) assert(e[i].size() <= 2);\n\t\t\n\t\tfunction<bool(int,int,vector<bool>&,vi&)> rec = [&](int c, int p, vector<bool> &v, vi &idx){\n\t\t\tv[c] = 1;\n\t\t\tbool ans = 0;\n\t\t\tidx.pb(c);\n\t\t\tfor(int i : e[c]) if(i != p){\n\t\t\t\tif(v[i]) ans |= 1;\n\t\t\t\telse ans |= rec(i, c, v, idx); \n\t\t\t}\n\t\t\treturn ans;\n\t\t};\n\t\t\n\t\tll ans = 1e18;\n\t\tvector<bool> v(n);\n\t\trep(ii, n) if(!v[ii]){\n\t\t\tvi idx;\n\t\t\tbool loop = rec(ii, ii, v, idx);\n\t\t\tif(idx.size() < k) continue;\n\t\t\t\n\t\t\tif(loop && idx.size() == k){\n\t\t\t\tll sum = 6ll * k * s * s;\n\t\t\t\trep(i, (int)idx.size()){\n\t\t\t\t\tll c = intersect(idx[i], idx[(i + 1) % idx.size()]);\n\t\t\t\t\tsum -= c;\n\t\t\t\t}\n\t\t\t\tans = min(ans, sum);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tll sum = 6ll * k * s * s;\n\t\t\tif(k == 1){\n\t\t\t\tans = min(ans, sum);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tvector<ll> costs;\n\t\t\tif(loop){\n\t\t\t\trep(i, (int)idx.size())\n\t\t\t\t\tcosts.pb(intersect(idx[i], idx[(i + 1) % idx.size()]));\n\t\t\t\tint it = idx.size();\n\t\t\t\trep(i, it) idx.pb(idx[i]);\n\t\t\t\t\n\t\t\t\trep(i, it) assert(count(all(e[idx[i]]), idx[i+1]));\n\t\t\t}\n\t\t\telse{\n\t\t\t\tint hasi = 0;\n\t\t\t\trep(i, idx.size()) if(e[idx[i]].size() == 1) hasi = idx[i];\n\t\t\t\tfor(int i : idx) v[i] = 0;\n\t\t\t\tidx.clear();\n\t\t\t\trec(hasi, hasi, v, idx);\n\t\t\t\t\n\t\t\t\trep(i, (int)idx.size()-1)\n\t\t\t\t\tcosts.pb(intersect(idx[i], idx[i + 1]));\n\t\t\t\t#if 1\n\t\t\t\tassert(idx.size() >= 2);\n\t\t\t\trep(i, idx.size()){\n\t\t\t\t\tif(i==0 || i==idx.size()-1) assert(e[idx[i]].size() == 1);\n\t\t\t\t\telse assert(e[idx[i]].size()==2);\n\t\t\t\t\tassert(e[idx[i]].size() <= 2);\n\t\t\t\t\tassert(e[idx[i]].size() >= 1);\n\t\t\t\t\t\n\t\t\t\t\tif(i < idx.size()-2) assert(count(all(e[idx[i]]), idx[i+1]));\n\t\t\t\t}\n\t\t\t\t#endif\n\t\t\t}\n\t\t\t//dbg(k, costs);\n\t\t\t\n\t\t\trep(i, k-2) sum -= costs[i];\n\t\t\trep(i, (int)costs.size() - (k-1) + 1){\n\t\t\t\tsum -= costs[i + k-2];\n\t\t\t\tans = min(ans, sum);\n\t\t\t\tsum += costs[i];\n\t\t\t}\n\t\t}\n\t\tif(ans >= 1e18) ans = -1;\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <array>\n#include <cassert>\n#include <climits>\n#include <complex>\n#include <cstdio>\n#include <cstring>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <iterator>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <string>\n#include <tuple>\n#include <vector>\n\nusing namespace std;\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define ALL(x) (x).begin(), (x).end()\n\nint subcube(int len, int x0, int y0, int z0, int x1, int y1, int z1) {\n    int dx = x0 - x1, dy = y0 - y1, dz = z0 - z1;\n    int sx = max(min(len + dx, len - dx), 0);\n    int sy = max(min(len + dy, len - dy), 0);\n    int sz = max(min(len + dz, len - dz), 0);\n    return (sx * sy * sz == 0) ? 0 : 2 * (sx * sy + sy * sz + sz * sx);\n}\n\nint main(){\n    int n, k, s; \n    while(cin >> n >> k >> s, n != 0){\n    vector<int> xs(n), ys(n), zs(n);\n    REP(i, n) {\n        cin >> xs[i] >> ys[i] >> zs[i];\n    }\n\n    if (k == 1) cout << s * s * 6 * k << endl;\n    vector<vector<int>> subc(n, vector<int>(n));\n    REP(a, n) {\n        REP(b, n) {\n            if (a == b) {cout << \"--\\t\"; continue;}\n            subc[a][b] = subcube(s, xs[a], ys[a], zs[a], xs[b], ys[b], zs[b]);\n            cout << subc[a][b] << \"\\t\";\n        }\n        cout << endl;\n    }\n\n    vector<vector<int>> segs;\n    vector<int> used(n, false);\n\n    /// 4 8 12 16 20\n    REP(a, n){\n        if (used[a]) continue;\n        vector<int> seg;\n        int p = a; bool ok = true;\n        seg.push_back(p);\n        used[a] = true;\n        while(ok) {\n            ok = false;\n            REP(b, n) {\n                if (subc[p][b] > 0) {\n                    if (used[b]) continue;\n                    p = b;\n                    seg.push_back(p);\n                    used[b] = true;\n                    ok = true;\n                    break;\n                }\n            }\n        }\n        reverse(ALL(seg));\n        p = a;\n        ok = true;\n        while(ok) {\n            ok = false;\n            REP(b, n) {\n                //cout << \"?\" << a << \"->\" << b << endl;\n                if (subc[p][b] > 0) {\n                    if (used[b]) continue;\n                    p = b;\n                    seg.push_back(p);\n                    used[b] = true;\n                    ok = true;\n                    break;\n                }\n            }\n        }\n        segs.push_back(seg);\n    }\n\n    int res = -1;\n    REP(i, segs.size()) {\n        const vector<int> seg(segs[i]);\n        \n        /*cout << \"# \"; REP(a, seg.size()) {\n            cout << seg[a] << \" \";\n        } cout << endl;*/\n        \n        const int l = seg.size();\n        if (l < k) { continue; }\n        if (l == k) {\n            int sum = 0;\n            if (l == 2) {\n                res = max(res, subc[seg[0]][seg[1]]);\n                continue;\n            }\n            REP(a, l) {\n                //cout << \"+=\" << seg[a] << \" \" << seg[(a+1)%l] << endl;\n                //cout << \"   : \" << subc[seg[a]][seg[(a+1)%l]] << endl;\n                sum += subc[seg[a]][seg[(a+1)%l]];\n            }\n            res = max(res, sum);\n            continue;\n        }\n        int sum = 0;\n        REP(a, k - 1) {\n            sum += subc[seg[a]][seg[a+1]];\n        }\n        REP(a, l) {\n            res = max(res, sum);\n            int ad = subc[seg[(a + k - 1) % l]][seg[(a + k) % l]];\n            if (ad == 0) break;\n            sum += ad;\n            sum -= subc[seg[(a % l)]][seg[(a + 1) % l]];\n        }\n    }\n\n    // cout << \"$\" << subc[0][1] << endl;\n    // cout << res << endl;\n    if (res < 0) cout << res << endl;\n    else cout << s * s * 6 * k - res << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cmath>\n#include <map>\n\nusing namespace std;\n\ntypedef  long long ll;\nll inf = (ll)20000000000000;\nvector<ll>x,y,z;\nint n,k,s;\nll calc(int i,int j){\n    ll tx=0,ty=0,tz=0;    \n    if(x[i]<=x[j]&&x[j]<=x[i]+s){\n        tx = x[i]+s-x[j];\n    }\n    if(y[i]<=y[j]&&y[j]<=y[i]+s){\n        ty = y[i]+s-y[j];\n    }\n    if(z[i]<=z[j]&&z[j]<=z[i]+s){\n        tz = z[i]+s-z[j];\n    }\n    if(x[j]<=x[i]&&x[i]<=x[j]+s){\n        tx = x[j]+s-x[i];\n    }\n    if(y[j]<=y[i]&&y[i]<=y[j]+s){\n        ty = y[j]+s-y[i];\n    }\n    if(z[j]<=z[i]&&z[i]<=z[j]+s){\n        tz = z[j]+s-z[i];\n    }\n    if(tx==0||ty==0||tz==0){\n        return -1;\n    }\n    return 2*(tx*ty+ty*tz+tz*tx);\n}\n\nll saiki(int st,int i,int b,int c,vector<vector<pair<int,ll> > > &g){\n    if(c==k){\n        ll p = 0;\n        for(auto x:g[i]){\n            if(x.first==st){\n                p = x.second;\n            }\n        }\n        return p;\n    }\n    ll p = -inf;\n    for(auto x:g[i]){\n        if(x.first!=st&&x.first!=b){\n            p = max(p,x.second+saiki(st,x.first,i,c+1,g));\n        }\n    }\n    return p;\n}\n\nint main(){\n    \n    while(scanf(\"%d %d %d \",&n,&k,&s)&&n!=0){\n        x.resize(n);y.resize(n);z.resize(n);\n        for(int i=0;i<n;i++)scanf(\"%lld %lld %lld \",&x[i],&y[i],&z[i]);\n        vector<vector<pair<int,ll> > >g(n);\n\n        for(int i=0;i<n;i++){\n            for(int j=0;j<n;j++){\n                if(i!=j){\n                    ll sm = calc(i,j);\n                    if(sm!=-1){\n                        g[i].push_back(make_pair(j,sm));\n                        g[j].push_back(make_pair(i,sm));\n                    }\n                }\n            }\n        }\n        ll ans = -1;\n        if(k==1){\n            cout << s*s*6 << endl;\n            continue;\n        }\n        for(int i=0;i<n;i++){\n            ans = max(ans,saiki(i,i,-1,1,g));\n        }\n        if(ans ==-1)cout << -1 << endl;\n        else cout << s*s*k*6-ans << endl;\n\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <cmath>\n#include <cstdlib>\n#include <map>\nusing namespace std;\n\nclass Point {\npublic:\n    int x, y, z;\n    Point(int x = 0, int y = 0, int z = 0) : x(x), y(y), z(z) {}\n};\n\nclass Cube {\npublic:\n    Point p;\n    int s;\n    int vx[4] = {0, 1, 1, 0}, vy[4] = {0, 0, 1, 1}, vz[2] = {0, 1};\n    Cube(Point p = Point(), int s = 0) : p(p), s(s) {}\n\n    bool isIn(const Cube &c) {\n        return ((abs(p.x - c.p.x) < s) && (abs(p.y - c.p.y) <= s) && (abs(p.z - c.p.z) <= s) &&\n                (abs(p.x - c.p.x) <= s) && (abs(p.y - c.p.y) < s) && (abs(p.z - c.p.z) <= s) &&\n                (abs(p.x - c.p.x) <= s) && (abs(p.y - c.p.y) <= s) && (abs(p.z - c.p.z) < s));\n    }\n\n    long long shareS(Cube &c) {\n        long long ret = 0;\n        Point a, b;\n        a = p; b = c.p;\n\n        if (a.x > b.x) swap(a.x, b.x);\n        if (a.y > b.y) swap(a.y, b.y);\n        if (a.z > b.z) swap(a.z, b.z);\n\n        ret += abs((a.x + s - b.x) * (a.z + s - b.z) * 2);\n        ret += abs((a.y + s - b.y) * (a.z + s - b.z) * 2);\n        ret += abs((a.x + s - b.x) * (a.y + s - b.y) * 2);\n        return ret;\n    }\n\n};\n\nint n, k, s, x, y, z;\nlong long ans;\nvector<Cube> c;\nvector<vector<int> > subg;\nvector<bool> used;\nvector<deque<int> > graph;\ndeque<int> que;\n\ninline void makegraph() {\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            if (c[i].isIn(c[j])) {\n                subg[j].push_back(i);\n                subg[i].push_back(j);\n            }\n        }\n    }\n}\n\n// make path\nvoid dfs(int v) {\n    used[v] = true;\n    int size_ = subg[v].size();\n    bool flag = false;\n\n    for (int i = 0; i < size_; ++i) {\n        if (!used[subg[v][i]]) {\n            dfs(subg[v][i]);\n            if (!flag) que.push_front(v);\n            flag = true;\n        }\n    }\n\n    if (!flag) que.push_front(v);\n}\n\n// is graph[graphid] cycle ?\ninline bool isCycle(int graphid) {\n    int size_ = graph[graphid].size();\n\n    // if all vertex's degree are two, this graph has closed path.\n    for (int i = 0; i < size_; ++i) {\n        if (subg[graph[graphid][i]].size() != 2) return false;\n    }\n\n    return true;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    while (cin >> n >> k >> s, n | k | s) {\n        c.resize(n);\n        subg.resize(n);\n        que.clear();\n        used.assign(n, false);\n        ans = int(1e15);\n\n        for (int i = 0; i < n; ++i) {\n            cin >> x >> y >> z;\n            c[i] = {Point(x, y, z), s};    \n        }\n\n        makegraph();\n\n        for (int i = 0; i < n; ++i) {\n            if (!used[i]) {\n                dfs(i);\n                graph.push_back(que);\n                que.clear();\n            }\n        }\n\n        int gsize = graph.size(), qsize, upper;\n        long long share;\n        bool isGraphCycle = false;\n\n        for (int i = 0; i < gsize; ++i) {\n            qsize = graph[i].size();\n            isGraphCycle = isCycle(i);\n            if (isGraphCycle) {\n                upper = qsize + k - 1;\n            }\n            else upper = qsize;\n\n            if (qsize < k) continue;\n\n            for (int j = 0; j + k - 1 < upper; ++j) {\n                share = 0;\n\n                for (int l = 0; l < k - 1; ++l) {\n                    share += c[graph[i][(j + l) % qsize]].shareS(c[graph[i][(j + l + 1) % qsize]]);\n                }\n\n                if (isGraphCycle && qsize == k) {\n                    share += c[graph[i][j % qsize]].shareS(c[graph[i][(j + qsize - 1) % qsize]]);\n                }\n\n                ans = min(ans, 6 * s * s * k - share);\n            }\n        }\n\n        if (n == 1) ans = 6 * s * s;\n        if (ans == int(1e15)) ans = -1;\n\n        cout << ans << endl;\n\n        c.clear();\n        graph.clear();\n        subg.clear();\n        used.clear();\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define dbg(...) do{cerr<<__LINE__<<\": \";dbgprint(#__VA_ARGS__, __VA_ARGS__);}while(0);\n\nusing namespace std;\n\nnamespace std{template<class S,class T>struct hash<pair<S,T>>{size_t operator()(const pair<S,T>&p)const{return ((size_t)1e9+7)*hash<S>()(p.first)+hash<T>()(p.second);}};template<class T>struct hash<vector<T>>{size_t operator()(const vector<T> &v)const{size_t h=0;for(auto i : v)h=h*((size_t)1e9+7)+hash<T>()(i)+1;return h;}};}\ntemplate<class T>ostream& operator<<(ostream &os, const vector<T> &v){os<<\"[ \";rep(i,v.size())os<<v[i]<<(i==v.size()-1?\" ]\":\", \");return os;}template<class T>ostream& operator<<(ostream &os,const set<T> &v){os<<\"{ \"; for(const auto &i:v)os<<i<<\", \";return os<<\"}\";}\ntemplate<class T,class U>ostream& operator<<(ostream &os,const map<T,U> &v){os<<\"{\";for(const auto &i:v)os<<\" \"<<i.first<<\": \"<<i.second<<\",\";return os<<\"}\";}template<class T,class U>ostream& operator<<(ostream &os,const pair<T,U> &p){return os<<\"(\"<<p.first<<\", \"<<p.second<<\")\";}\nvoid dbgprint(const string &fmt){cerr<<endl;}template<class H,class... T>void dbgprint(const string &fmt,const H &h,const T&... r){cerr<<fmt.substr(0,fmt.find(\",\"))<<\"= \"<<h<<\" \";dbgprint(fmt.substr(fmt.find(\",\")+1),r...);}\ntypedef long long ll;typedef vector<int> vi;typedef pair<int,int> pi;const int inf = (int)1e9;const double INF = 1e12, EPS = 1e-9;\n\nint main(){\n\tcin.tie(0); cin.sync_with_stdio(0);\n\tint n, k, s;\n\twhile(cin >> n >> k >> s, n){\n\t\tvi x(n), y(n), z(n);\n\t\trep(i, n) cin >> x[i] >> y[i] >> z[i];\n\t\t\n\t\tauto intersect = [&](int i, int j){\n\t\t\tll dx = s - abs(x[i] - x[j]);\n\t\t\tll dy = s - abs(y[i] - y[j]);\n\t\t\tll dz = s - abs(z[i] - z[j]);\n\t\t\tif(dx <= 0 || dy <= 0 || dz <= 0) return 0ll;\n\t\t\treturn (dx * dy + dy * dz + dz * dx) * 2;\n\t\t};\n\t\t\n\t\tvector<vi> e(n);\n\t\trep(i, n) rep(j, i) if(intersect(i, j)){\n\t\t\te[i].pb(j);\n\t\t\te[j].pb(i);\n\t\t\t//dbg(i, j);\n\t\t}\n\t\t\n\t\tfunction<bool(int,int,vector<bool>&,vi&)> rec = [&](int c, int p, vector<bool> &v, vi &idx){\n\t\t\tv[c] = 1;\n\t\t\tidx.pb(c);\n\t\t\tfor(int i : e[c]) if(i != p){\n\t\t\t\tif(v[i]) return true;\n\t\t\t\treturn (bool)rec(i, c, v, idx); \n\t\t\t}\n\t\t\treturn false;\n\t\t};\n\t\t\n\t\tll ans = 1e18;\n\t\tvector<bool> v(n);\n\t\trep(ii, n) if(!v[ii]){\n\t\t\tvi idx;\n\t\t\tbool loop = rec(ii, ii, v, idx);\n\t\t\tif(idx.size() < k) continue;\n\t\t\t\n\t\t\tif(loop && idx.size() == k){\n\t\t\t\tll sum = 6ll * k * s * s;\n\t\t\t\trep(i, (int)idx.size()){\n\t\t\t\t\tll c = intersect(idx[i], idx[(i + 1) % idx.size()]);\n\t\t\t\t\tsum -= c;\n\t\t\t\t}\n\t\t\t\tans = min(ans, sum);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tvector<ll> costs;\n\t\t\t\tif(loop){\n\t\t\t\t\trep(i, (int)idx.size())\n\t\t\t\t\t\tcosts.pb(intersect(idx[i], idx[(i + 1) % idx.size()]));\n\t\t\t\t\tint it = idx.size();\n\t\t\t\t\trep(i, it) idx.pb(idx[i]);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tint hasi = 0;\n\t\t\t\t\trep(i, idx.size()) if(e[idx[i]].size() == 1) hasi = i;\n\t\t\t\t\trotate(idx.begin(), idx.begin() + hasi, idx.end());\n\t\t\t\t\tif(idx.size() > 2 && e[idx[1]].size() == 1)\n\t\t\t\t\t\trotate(idx.begin(), idx.begin() + 1, idx.end());\n\t\t\t\t\t\n\t\t\t\t\trep(i, idx.size() - 1)\n\t\t\t\t\t\tcosts.pb(intersect(idx[i], idx[i + 1]));\n\t\t\t\t}\n\t\t\t\t//dbg(k, costs);\n\t\t\t\t\n\t\t\t\tll sum = 6ll * k * s * s;\n\t\t\t\tif(k == 1){\n\t\t\t\t\tans = min(ans, sum);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\trep(i, k-2) sum -= costs[i];\n\t\t\t\trep(i, (int)costs.size() - (k-1) + 1){\n\t\t\t\t\tsum -= costs[i + k-2];\n\t\t\t\t\tans = min(ans, sum);\n\t\t\t\t\tsum += costs[i];\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tif(ans >= 1e18) ans = -1;\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iomanip>\n#include<limits>\n#include<thread>\n#include<utility>\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<numeric>\n#include<cassert>\n#include<random>\n#include<chrono>\n#include<unordered_set>\n#include<unordered_map>\n#include<fstream>\n#include<list>\n#include<functional>\n#include<bitset>\n#include<complex>\n#include<tuple>\nusing namespace std;\ntypedef unsigned long long int ull;\ntypedef long long int ll;\ntypedef pair<ll,ll> pll;\ntypedef pair<int,int> pi;\ntypedef pair<double,double> pd;\ntypedef pair<double,ll> pdl;\n#define F first\n#define S second\nconst ll E=1e18+7;\nconst ll MOD=1000000007;\n\nll n,k,s;\nvector<bool> used;\nvector<pair<pll,ll>> A;\n\nvector<ll> Ring;\nvector<ll> cnt;\nll ans=-E;\n\nll cross(ll a,ll b){\n    ll x=abs(A[a].F.F-A[b].F.F);\n    ll y=abs(A[a].F.S-A[b].F.S);\n    ll z=abs(A[a].S-A[b].S);\n    if(x>=s || y>=s || z>=s){return 0;}\n    if(A[a]==A[b]){return 6*s*s;}\n    return ((s-x)*(s-y)+(s-x)*(s-z)+(s-y)*(s-z))*2;\n}\n\n\nvoid dfs(ll w,ll p=-1){\n    Ring.push_back(w);\n    used[w]=true;\n    for(int i=0;i<n;i++){\n        if(i==w || i==p || used[i]){continue;}\n        if(cross(i,w)){dfs(i,w);}\n    }\n}\n\nvoid solve(ll w){\n    Ring.clear();\n    dfs(w);\n    if(Ring.size()<k){return;}\n    if(k==1){ans=0; return;}\n    if(cross(Ring[0],Ring.back())){\n        if(Ring.size()==k){\n            ll ret=0;\n            for(int i=1;i<k;i++){ret+=cross(Ring[i],Ring[i-1]);}\n            if(k!=2){\n                ret+=cross(Ring[0],Ring.back());\n            }\n            ans=max(ans,ret);\n            return;\n        }\n        else{\n            for(int i=0;i<Ring.size();i++){\n                ll ret=0;\n                for(int t=1;t<k;t++){\n                    ret+=cross(Ring[(i+t)%Ring.size()],Ring[(i+t-1)%Ring.size()]);\n                }\n                ans=max(ans,ret);\n            }\n            return;\n        }\n    }\n    else{\n        for(int i=0;i+k<=Ring.size();i++){\n            ll ret=0;\n            for(int t=1;t<k;t++){\n                ret+=cross(Ring[i+t],Ring[i+t-1]);\n            }\n            ans=max(ans,ret);\n        }\n    }\n}\n\n\n\nint main(){\n    while(cin>>n>>k>>s){\n        if(n==0){break;}\n    used.resize(n);\n    for(int i=0;i<n;i++){used[i]=false;}\n    A.resize(n);\n    cnt.resize(n);\n    for(int i=0;i<n;i++){cnt[i]=0;}\n    for(auto &I:A){cin>>I.F.F>>I.F.S>>I.S;}\n    for(int i=0;i<n;i++){\n        for(int t=0;t<n;t++){\n            if(i!=t){cnt[i]+=(cross(i,t)?1:0);}\n        }\n    }\n    ans=-E;\n    for(int i=0;i<n;i++){\n        if(!used[i] && cnt[i]<=1){solve(i);}\n    }\n    for(int i=0;i<n;i++){\n        if(!used[i]){solve(i);}\n    }\n    if(ans==-E){cout<<-1<<endl;}\n    else{cout<<s*s*6*k-ans<<endl;}\n    }\n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#define int long long\nusing namespace std;\n\nint n, k, s;\nint x[2000], y[2000], z[2000];\nvector<int> et[2000];\nvector<int> ec[2000];\n\nint f(int sid, int dir) {\n\tint ret = 0;\n\tbool used[2000] = {false};\n\tint id = sid;\n\t\n\tfor (int i = 0; i < k - 1; i++) {\n\t\tused[id] = true;\n\t\t\n\t\tint next = -1;\n\t\t\n\t\tif (dir == 0) {\n\t\t\tfor (int j = 0; j < et[id].size(); j++) {\n\t\t\t\tif (!used[et[id][j]]) { next = j; break; }\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tfor (int j = (int)et[id].size() - 1; j >= 0; j--) {\n\t\t\t\tif (!used[et[id][j]]) { next = j; break; }\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (next == -1) { return -1; }\n\t\tret += ec[id][next];\n\t\tid = et[id][next];\n\t}\n\t\n\tif (k >= 3) {\n\t\tfor (int j = 0; j < et[id].size(); j++) {\n\t\t\tif (et[id][j] == sid) {\n\t\t\t\tret += ec[id][j];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn ret;\n}\n\nsigned main() {\n\tint i, j;\n\t\n\twhile (cin >> n >> k >> s) {\n\t\tif (!n) break;\n\t\tfor (i = 0; i < n; i++) cin >> x[i] >> y[i] >> z[i];\n\t\t\n\t\tfor (i = 0; i < n; i++) { et[i].clear(); ec[i].clear(); }\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tfor (j = 0; j < n; j++) {\n\t\t\t\tif (i == j) continue;\n\t\t\t\tint sx = s - abs(x[i] - x[j]);\n\t\t\t\tint sy = s - abs(y[i] - y[j]);\n\t\t\t\tint sz = s - abs(z[i] - z[j]);\n\t\t\t\tif (sx < 0 || sy < 0 || sz < 0) continue;\n\t\t\t\tet[i].push_back(j);\n\t\t\t\tec[i].push_back(2 * (sx * sy + sy * sz + sz * sx));\n\t\t\t}\n\t\t}\n\t\t\n\t\tint maxi = -1;\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tmaxi = max(maxi, max(f(i, 0), f(i, 1)));\n\t\t}\n\t\tif (maxi == -1) { cout << -1 << endl; }\n\t\telse { cout << k * s * s * 6 - maxi << endl; }\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\nint N, K;\nlong long int S;\n\nstruct cube {\n\tvector<long long int>coors;\n};\n\nlong long int connect(const cube&l, const cube&r) {\n\tvector<long long int>ds;\n\tfor (int i = 0; i < 3; ++i) {\n\t\tif (abs(l.coors[i] - r.coors[i]) >= S)return 0;\n\t\telse ds.emplace_back(S-abs(l.coors[i] - r.coors[i]));\n\t}\n\treturn 2 * (ds[0] * ds[1] + ds[1] * ds[2] + ds[2] * ds[0]);\n}\nvoid dfs(const int now, const int from, const vector<vector<pair<int, long long int>>>&edges, vector<int>&used,vector<long long int>&v) {\n\tfor (auto e : edges[now]) {\n\t\tif (e.first == from)continue;\n\t\tif (used[e.first]) {\n\t\t\tv.push_back(e.second);\n\t\t}\n\t\telse {\n\t\t\tv.push_back(e.second);\n\t\t\tused[e.first] = true;\n\t\t\tdfs(e.first, now, edges, used, v);\n\t\t}\n\t}\n}\nint main() {\n\twhile (1) {\n\t\tcin >> N >> K >> S;\n\t\tif (!N)break;\n\t\tlong long int total = K*S*S * 6;\n\t\t\n\t\tvector<cube>cus;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tint x, y, z; cin >> x >> y >> z;\n\t\t\tcus.push_back(cube{ vector<long long int>{x,y,z} });\n\t\t}\n\t\tif (K == 1) {\n\t\t\tcout << total << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tvector<vector<pair<int, long long int>>>edges(N);\n\t\tvector<vector<long long int>>memo(N, vector<long long int>(N));\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tfor (int j = 0; j < N; ++j) {\n\t\t\t\tif (i == j)continue;\n\t\t\t\tlong long int sa = connect(cus[i], cus[j]);\n\t\t\t\tif (sa) {\n\t\t\t\t\tedges[i].push_back(make_pair(j, sa));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvector<int>used(N);\n\t\tlong long int hide_max = -1;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tif (!used[i]) {\n\t\t\t\tif (edges[i].size()==1) {\n\t\t\t\t\tused[i] = true;\n\t\t\t\t\tvector<long long int>v;\n\t\t\t\t\tdfs(i, -1, edges, used, v);\n\t\t\t\t\tif (v.size() < K-1)continue;\n\t\t\t\t\telse {\n\t\t\t\t\t\tlong long int sum = 0;\n\t\t\t\t\t\tfor (int i = 0; i < K - 1; ++i) {\n\t\t\t\t\t\t\tsum += v[i];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor (int i = K - 1; i <=v.size(); ++i) {\n\t\t\t\t\t\t\thide_max = max(hide_max, sum);\n\t\t\t\t\t\t\tsum -= v[(i - K + 1) % v.size()];\n\t\t\t\t\t\t\tsum += v[i%v.size()];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tif (!used[i]) {\n\t\t\t\tused[i] = true;\n\t\t\t\tif (!edges[i].empty()) {\n\t\t\t\t\tvector<long long int>v;\n\t\t\t\t\tdfs(i, edges[i][0].first, edges, used, v);\n\t\t\t\t\tif (v.size() < K)continue;\n\t\t\t\t\telse if (v.size() == K) {\n\t\t\t\t\t\thide_max = max(hide_max, accumulate(v.begin(), v.end(), 0ll));\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tlong long int sum = 0;\n\t\t\t\t\t\tfor (int i = 0; i < K-1; ++i) {\n\t\t\t\t\t\t\tsum += v[i];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor (int i = K-1; i <= N; ++i) {\n\t\t\t\t\t\t\thide_max = max(hide_max, sum);\n\t\t\t\t\t\t\tsum -= v[(i - K+1) % v.size()];\n\t\t\t\t\t\t\tsum += v[i%v.size()];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t}\n\t\tif (hide_max == -1)cout << -1 << endl;\n\t\telse {\n\t\t\tcout << total - hide_max << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\n\nstruct Cube {\n    Cube() = default;\n    Cube(ll x, ll y, ll z, ll size) : x{x}, y{y}, z{z}, size{size}\n    {\n    }\n\n    bool operator<(const Cube& c) const\n    {\n        return (x != c.x) ? (x < c.x) : (y != c.y) ? (y < c.y) : (z != c.z) ? (z < c.z) : true;\n    }\n    ll x;\n    ll y;\n    ll z;\n    ll size;\n};\n\nll intersection(const Cube& c1, const Cube& c2)\n{\n\n    ll x = min(c1.x, c2.x) - max(c1.x, c2.x) + c1.size;\n    if (x <= 0) {\n        return 0;\n    }\n    ll y = min(c1.y, c2.y) - max(c1.y, c2.y) + c1.size;\n    if (y <= 0) {\n        return 0;\n    }\n    ll z = min(c1.z, c2.z) - max(c1.z, c2.z) + c1.size;\n    if (z <= 0) {\n        return 0;\n    }\n    return 2 * ((x * y) + (y * z) + (z * x));\n}\n\nstruct Edge {\n    Edge() = default;\n    Edge(int f, int t, ll c) : from{f}, to{t}, cost{c}\n    {\n    }\n    int from;\n    int to;\n    ll cost;\n};\n\nstruct Graph {\n    Graph(int n)\n    {\n        edge.resize(n);\n    }\n    void addEdge(int from, int to, ll cost)\n    {\n        edge[to].push_back(Edge{to, from, cost});\n        edge[from].push_back(Edge{from, to, cost});\n    }\n    vector<vector<Edge>> edge;\n};\n\nvoid dfs(const Graph& g, vector<bool>& checked, int pos, int& num, bool& ring, int& representation)\n{\n    num++;\n    checked[pos] = true;\n    bool update = false;\n    for (const auto& e : g.edge[pos]) {\n        const int to = e.to;\n        if (not checked[to]) {\n            dfs(g, checked, to, num, ring, representation);\n            update = true;\n        }\n    }\n    if (not update) {\n        if (g.edge[pos].size() == 2) {\n            ring = true;\n        } else {\n            ring = false;\n        }\n        representation = pos;\n    }\n}\n\nint main()\n{\n\n    while (true) {\n        int n, k;\n        ll s;\n        cin >> n >> k >> s;\n        if (n == 0 and k == 0 and s == 0) {\n            break;\n        }\n        vector<Cube> cubes(n);\n        for (int i = 0; i < n; i++) {\n            ll x, y, z;\n            cin >> x >> y >> z;\n            cubes[i] = Cube{x, y, z, s};\n        }\n        Graph g{n};\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                ll inter = intersection(cubes[i], cubes[j]);\n                if (inter > 0) {\n                    g.addEdge(i, j, inter);\n                }\n            }\n        }\n\n        vector<bool> checked(n, false);\n        vector<pair<pair<int, int>, bool>> cc;\n        for (int i = 0; i < n; i++) {\n            if (not checked[i]) {\n                int num = 0;\n                bool ring = false;\n                int rep;\n                dfs(g, checked, i, num, ring, rep);\n                if (num >= k) {\n                    cc.push_back(make_pair(make_pair(rep, num), ring));\n                }\n            }\n        }\n\n        if (cc.empty()) {\n            cout << -1 << endl;\n            continue;\n        }\n\n        ll maxi = -1;\n        vector<bool> used_head(n, false);\n        vector<bool> used_tail(n, false);\n        for (const auto p : cc) {\n            int rep = p.first.first;\n            int num = p.first.second;\n            bool ring = p.second;\n            if (ring) {\n                int head = rep;\n                int tail = rep;\n                ll sum = 0;\n                for (int i = 0; i < k - 1; i++) {\n                    used_tail[tail] = true;\n                    for (const auto& e : g.edge[tail]) {\n                        if (not used_tail[e.to]) {\n                            tail = e.to;\n                            sum += e.cost;\n                            break;\n                        }\n                    }\n                }\n                if (k == num) {\n                    used_tail[head] = false;\n                    for (const auto& e : g.edge[tail]) {\n                        if (not used_tail[e.to]) {\n                            sum += e.cost;\n                            break;\n                        }\n                    }\n                    maxi = max(maxi, sum);\n                    continue;\n                }\n                maxi = max(maxi, sum);\n                for (int i = 0; i < num; i++) {\n                    used_head[head] = true;\n                    used_tail[tail] = true;\n                    for (const auto& e : g.edge[head]) {\n                        if (not used_head[e.to]) {\n                            head = e.to;\n                            sum -= e.cost;\n                            break;\n                        }\n                    }\n                    for (const auto& e : g.edge[tail]) {\n                        if (not used_tail[e.to]) {\n                            tail = e.to;\n                            sum += e.cost;\n                            break;\n                        }\n                    }\n                    maxi = max(maxi, sum);\n                }\n            } else {\n                int head = rep;\n                int tail = rep;\n                ll sum = 0;\n                for (int i = 0; i < k - 1; i++) {\n                    used_tail[tail] = false;\n                    for (const auto& e : g.edge[tail]) {\n                        if (not used_tail[e.to]) {\n                            tail = e.to;\n                            sum += e.cost;\n                            break;\n                        }\n                    }\n                }\n                maxi = max(maxi, sum);\n                for (int i = 0; i < num - k + 1; i++) {\n                    used_head[head] = true;\n                    used_tail[tail] = true;\n                    for (const auto& e : g.edge[head]) {\n                        if (not used_head[e.to]) {\n                            head = e.to;\n                            sum -= e.cost;\n                            break;\n                        }\n                    }\n                    for (const auto& e : g.edge[tail]) {\n                        if (not used_tail[e.to]) {\n                            tail = e.to;\n                            sum += e.cost;\n                            break;\n                        }\n                    }\n                    maxi = max(maxi, sum);\n                }\n            }\n        }\n        cout << (6 * s * s) * static_cast<ll>(k) - maxi << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i,n) for(int i = 0;i < (n);i++)\nconst long long INF = 1e+10;\nusing namespace std;\n\nint N, K, S;\n\nstruct Point{\n    int x, y, z;\n};\n\nPoint p[2103];\n\nbool iscycle[2103];\nbool used[2103];\ndeque<int> graph[2103];\n\nint getS(Point a,Point b){\n    if(a.x > b.x) swap(a.x, b.x);\n    if(a.y > b.y) swap(a.y, b.y);\n    if(a.z > b.z) swap(a.z, b.z);\n    return (a.x + S - b.x) * (a.y + S - b.y) * 2\n        +  (a.z + S - b.z) * (a.x + S - b.x) * 2\n        +  (a.y + S - b.y) * (a.z + S - b.z) * 2;\n}\n\nbool connected(int a,int b){\n    return (abs(p[a].x-p[b].x) <= S) && (abs(p[a].y-p[b].y) <= S) && (abs(p[a].z-p[b].z) <= S);\n}\n\nvoid makegraph(int graphct, int i, bool maincalled, bool back){\n    REP(j,N){\n        if(used[j])continue;\n        if(connected(i,j)){\n            used[j] = true;\n            if(graph[graphct].size() > 1 && (maincalled || back)){\n                graph[graphct].push_front(j);\n                makegraph(graphct, j, false, true);\n            }else{\n                graph[graphct].push_back(j);\n                makegraph(graphct, j, false, false);\n            }\n        }\n    }\n}\n\n\nint main(){\n    while(cin >> N >> K >> S, N){\n        REP(i,N){\n            int x, y, z;\n            cin >> x >> y >> z;\n            p[i] = Point{x, y, z};\n            graph[i].clear();\n            iscycle[i] = false;\n            used[i] = false;\n        }\n\n        //make graph\n        int graphct = 0;\n        REP(i,N){\n            if(used[i]) continue;\n            graph[graphct].push_back(i);\n            used[i] = true;\n            makegraph(graphct, i, true, true);\n            graphct++;\n        }\n        \n        //k == 1\n        if(K == 1){\n            cout << S*S*6 << endl;\n            continue;\n        }\n\n        //cycle check\n        REP(i,graphct){\n            if(graph[i].size() > 2 && connected(graph[i][0],graph[i][graph[i].size() - 1]))\n                iscycle[i] = true;\n        }\n        \n        long long ans = INF;\n        REP(i,graphct){\n            if((int)graph[i].size() < K) continue;\n            REP(j,graph[i].size()){\n                if(j + K - 1 > graph[i].size() - 1) break;\n                long long tmpans = 0;\n                for(int r = 0; r < K;r++){\n                    tmpans += S*S*6;\n                    if(r){\n                        tmpans -= getS(p[graph[i][j + r]], p[graph[i][j + r - 1]]);\n                    }else if(iscycle[i] && K == graph[i].size()){\n                        tmpans -= getS(p[graph[i][0]], p[graph[i][graph[i].size() - 1]]);\n                    }\n                }\n                ans = min(tmpans, ans);\n            }\n        }\n        if(ans == INF) cout << -1 << endl;\n        else cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nint n, k;\nll s;\nstruct N {\n  ll x, y, z;\n};\nvector<vector<int>> p;\nvector<N> ns;\nbool c;\nbool isc(N &l, N &r) {\n  ll x = abs(l.x - r.x);\n  ll y = abs(l.y - r.y);\n  ll z = abs(l.z - r.z);\n  ll w = s - x;\n  ll h = s - y;\n  ll d = s - z;\n  return w > 0 && h > 0 && d > 0;\n}\nll f(N &l, N &r) {\n  ll x = abs(l.x - r.x);\n  ll y = abs(l.y - r.y);\n  ll z = abs(l.z - r.z);\n  ll w = s - x;\n  ll h = s - y;\n  ll d = s - z;\n  return 2 * w * h + 2 * h * d + 2 * d * w;\n}\nvector<bool> used;\nint dfs(int i, int root, int from) {\n  if (used[i])\n    return 0;\n  used[i] = true;\n  int ret = 1;\n  for (auto &j : p[i]) {\n    if (j == root) {\n      if (root != from)\n        c = true;\n      continue;\n    }\n    ret += dfs(j, root, i);\n  }\n  return ret;\n}\n\nvector<int> buf;\nset<int> visit;\nvoid dfs2(int i, int from) {\n  if (visit.find(i) != visit.end())\n    return;\n  visit.insert(i);\n  if (from < 0) {\n    buf.push_back(i);\n    if (p[i].size() == 2) {\n      dfs2(p[i][1], i);\n      reverse(buf.begin(), buf.end());\n    }\n    if (p[i].size() > 0)\n      dfs2(p[i][0], i);\n  } else {\n    buf.push_back(i);\n    for (auto &j : p[i]) {\n      if (j == from)\n        continue;\n      dfs2(j, i);\n    }\n  }\n}\n\nll solve(int i, bool loop, bool spe) {\n  buf.clear();\n  visit.clear();\n  dfs2(i, -1);\n\n  if (loop && spe) {\n    ll ret = 6 * s * s * buf.size();\n    for (int j = 0; j < buf.size(); j++) {\n      ret -= f(ns[buf[j]], ns[buf[(j + 1) % buf.size()]]);\n    }\n    return ret;\n  } else if (loop) {\n    ll ret = 6 * s * s * k;\n    vector<ll> sum(2 * buf.size() + 1);\n    ll submax = 0;\n    for (int j = 0; j < buf.size() * 2; j++) {\n      sum[j + 1] =\n          sum[j] + f(ns[buf[j % buf.size()]], ns[buf[(j + 1) % buf.size()]]);\n    }\n    for (int j = 0; j < buf.size(); j++) {\n      submax = max(submax, sum[j + k - 1] - sum[j]);\n    }\n    ret -= submax;\n    return ret;\n  } else {\n    ll ret = 6 * s * s * k;\n    vector<ll> sum(buf.size() + 1);\n    ll submax = 0;\n    for (int j = 1; j < buf.size(); j++) {\n      sum[j] = sum[j - 1] + f(ns[buf[j - 1]], ns[buf[j]]);\n    }\n    for (int j = 0; j + k - 1 < buf.size(); j++) {\n      submax = max(submax, sum[j + k - 1] - sum[j]);\n    }\n    ret -= submax;\n    return ret;\n  }\n}\n\nint main() {\n  while (true) {\n    ll ans = 100000000000LL;\n    cin >> n >> k >> s;\n    if (n == 0)\n      break;\n    ns.resize(n);\n    p.clear();\n    p.resize(n);\n    used.clear();\n    used.resize(n);\n    for (int i = 0; i < n; i++)\n      cin >> ns[i].x >> ns[i].y >> ns[i].z;\n    for (int i = 0; i < n; i++)\n      for (int j = i + 1; j < n; j++) {\n        if (isc(ns[i], ns[j])) {\n          p[i].push_back(j);\n          p[j].push_back(i);\n        }\n      }\n    for (int i = 0; i < n; i++) {\n      if (used[i])\n        continue;\n      c = false;\n      int size = dfs(i, i, -1);\n      if (size < k)\n        continue;\n      ans = min(ans, solve(i, c, k == size));\n    }\n    if (ans == 100000000000LL)\n      cout << -1 << endl;\n    else\n      cout << ans << endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;++i)\n#define rep(i,n) REP(i,0,n)\n#define EPS (1e-8)\n#define equals(a,b) (fabs((a)-(b))<EPS)\n#define pb push_back\n\nusing namespace std;\n\ntypedef long long ll;\n\nbool LT(double a,double b) { return !equals(a,b) && a < b; }\nbool LTE(double a,double b) { return equals(a,b) || a < b; }\n\nstruct Edge {\n  int dst;\n  long long w;\n};\n\n#define MAX 2100\nint n,K;\nll s, x[MAX], y[MAX], z[MAX];\nvector<Edge> G[MAX];\n\nconst bool debug = 0;\n\nlong long calc_common_area(ll x1L, ll x1R, ll x2L, ll x2R) {\n  if( x1L <= x2L && x2L <= x1R ) return min(x2R,x1R)-x2L;\n  if( x1L <= x2R && x2R <= x1R ) return min(x2R,x1R)-x1L;\n  return 0;\n}\n\nlong long calc_area(int a,int b) {\n  ll wx = calc_common_area(x[a],x[a]+s,x[b],x[b]+s);\n  ll wy = calc_common_area(y[a],y[a]+s,y[b],y[b]+s);\n  ll wz = calc_common_area(z[a],z[a]+s,z[b],z[b]+s);\n  if( debug ) {\n    cout << \"(wx,wy,wz) = (\" << wx << \",\" << wy << \",\" << wz << \")\" << endl;\n  }\n  if( wx == 0LL || wy == 0LL || wz == 0LL ) return 0LL;\n  return wx * wy * 2LL + wx * wz * 2LL + wy * wz * 2LL;\n}\n\nvoid add_edge(int a,int b) {\n  long long w = calc_area(a,b);\n  assert( w >= 0LL );\n  if( w == 0 ) return;\n  G[a].push_back((Edge){b,w});\n  G[b].push_back((Edge){a,w});\n}\n\nbool used[MAX];\n\nvoid dfs(int cur, deque<int> &vs) {\n  rep(i,(int)G[cur].size()) {\n    Edge &e = G[cur][i];\n    if( used[e.dst] ) continue;\n    used[e.dst] = true;\n    vs.pb(e.dst);\n    dfs(e.dst,vs);\n  }\n}\n\nbool used2[MAX];\nvoid dfs2(int cur, deque<ll> &deq) {\n  rep(i,(int)G[cur].size()) {\n    Edge &e = G[cur][i];\n    if( used2[e.dst] ) continue;\n    used2[e.dst] = true;\n    deq.pb(e.w);\n    dfs2(e.dst,deq);\n  }\n}\n\n\nvoid solve() {\n  if( K == 1 ) {\n    cout << s * s * 6 << endl;\n    return;\n  }\n  rep(i,n) G[i].clear();\n  rep(i,n) {\n    REP(j,i+1,n) {\n      add_edge(i,j);\n    }\n  }\n  if( debug ) {\n    cout << \"Graph---\" << endl;\n    rep(i,n) {\n      cout << i << \"-th:\" << endl;\n      cout << \"  \";\n      rep(j,(int)G[i].size()) {\n\tcout << \"(\" << G[i][j].dst << \",\" << G[i][j].w << \")\";\n      } puts(\"\");\n    }\n  }\n\n  ll mini = LLONG_MAX;\n  memset(used,false,sizeof used);\n  rep(i,n) if( !used[i] ) {\n    deque<int> vs;\n    vs.pb(i);\n    used[i] = true;\n    dfs(i,vs);\n    if( debug ) {\n      cout << \"* Start \" << i << endl;\n      cout << \"  --[vs(\" << vs.size() << \")]--\" << endl;\n      cout << \"    \";\n      rep(kk,(int)vs.size()) {\n\tcout << vs[kk] << \", \";\n      } puts(\"\");\n    }\n\n    if( (int)vs.size() < K ) continue;\n    if( (int)vs.size() == 1 ) {\n      continue;\n    }\n\n    int sp = -1;\n    rep(j,(int)vs.size()) if( G[vs[j]].size() == 1 ) { sp = j; break; }\n    if( debug ) {\n      cout << \"* sp = \" << sp << endl;\n    }\n    if( sp == -1 ) { // loop\n      ll sum = 0;\n      int len = K-1;\n      if( (int)vs.size() == K ) ++len;\n      rep(j,len) {\n\tint cur = vs[j];\n\tint nex = vs[(j+1)%(int)vs.size()];\n\tif( debug ) {\n\t  cout << \"  ? cur = \" << cur << \", nex = \" << nex << endl;\n\t}\n\tll w = -1;\n\trep(k,(int)G[cur].size()) if( G[cur][k].dst == nex ) { w = G[cur][k].w; break; }\n\tassert( w != -1LL );\n\tsum += w;\n      }\n      if( (int)vs.size() == K ) {\n\tmini = min(mini,s*s*6LL*K-sum);\n\tcontinue;\n      }\n      rep(j,(int)vs.size()) {\n\tint cur = vs[j];\n\tint nex = vs[(j+1)%(int)vs.size()];\n\tll w = -1;\n\trep(k,(int)G[cur].size()) if( G[cur][k].dst == nex ) { w = G[cur][k].w; break; }\n\tassert( w != -1LL );\t\n\n\tint cur2 = vs[(j+K-1)%(int)vs.size()];\n\tint nex2 = vs[(j+K)%(int)vs.size()];\n\tll w2 = -1;\n\trep(k,(int)G[cur2].size()) if( G[cur2][k].dst == nex2 ) { w2 = G[cur2][k].w; break; }\n\tassert( w2 != -1LL );\n\tsum = sum - w + w2;\n\tmini = min(mini,s*s*6LL*K-sum);\t\n      }\n      \n    } else { // chain\n      memset(used2,false, sizeof used2);\n      used2[vs[sp]] = true;\n      deque<ll> deq;\n      dfs2(vs[sp],deq);\n      if( debug ) {\n\tcout << \"  ** this is chain...!\" << endl;\n\tcout << \"    chain :: deq[\";\n\trep(k,(int)deq.size()) {\n\t  cout << deq[k] << \" \";\n\t} cout << \"]\" << endl;\n      }\n      ll sum = 0;\n      rep(k,K-1) sum += deq[k];\n      ll maxi = sum;\n      rep(k,(int)deq.size()) {\n\tsum -= deq[k];\n\tif( k+K-1 < (int)deq.size() && deq[k+K-1] ) {\n\t  sum += deq[k+K-1];\n\t  maxi = max(maxi,sum);\n\t} else break;\n      }\n      \n      if( debug) {\n\tcout << \"  maxi = \" << maxi << endl;\n      }\n      mini = min(mini,s*s*6LL*K-maxi);\n    }\n    \n  }\n\n  if( mini == LLONG_MAX ) puts(\"-1\");\n  else cout << mini << endl;\n}\n\nint main() {\n  while( cin >> n >> K >> s, n | K | s ) {\n    rep(i,n) cin >> x[i] >> y[i] >> z[i];\n    solve();\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\n\nstruct Cube {\n    Cube() = default;\n    Cube(ll x, ll y, ll z, ll size) : x{x}, y{y}, z{z}, size{size}\n    {\n    }\n\n    bool operator<(const Cube& c) const\n    {\n        return (x != c.x) ? (x < c.x) : (y != c.y) ? (y < c.y) : (z != c.z) ? (z < c.z) : true;\n    }\n    ll x;\n    ll y;\n    ll z;\n    ll size;\n};\n\nll intersection(const Cube& c1, const Cube& c2)\n{\n\n    ll x = min(c1.x, c2.x) - max(c1.x, c2.x) + c1.size;\n    if (x <= 0) {\n        return 0;\n    }\n    ll y = min(c1.y, c2.y) - max(c1.y, c2.y) + c1.size;\n    if (y <= 0) {\n        return 0;\n    }\n    ll z = min(c1.z, c2.z) - max(c1.z, c2.z) + c1.size;\n    if (z <= 0) {\n        return 0;\n    }\n    return 2 * ((x * y) + (y * z) + (z * x));\n}\n\nstruct Edge {\n    Edge() = default;\n    Edge(int f, int t, ll c) : from{f}, to{t}, cost{c}\n    {\n    }\n    int from;\n    int to;\n    ll cost;\n};\n\nstruct Graph {\n    Graph(int n)\n    {\n        edge.resize(n);\n    }\n    void addEdge(int from, int to, ll cost)\n    {\n        edge[to].push_back(Edge{to, from, cost});\n        edge[from].push_back(Edge{from, to, cost});\n    }\n    vector<vector<Edge>> edge;\n};\n\nvoid dfs(const Graph& g, vector<bool>& checked, int pos, int& num, bool& ring, int& representation)\n{\n    num++;\n    checked[pos] = true;\n    bool update = false;\n    for (const auto& e : g.edge[pos]) {\n        const int to = e.to;\n        if (not checked[to]) {\n            dfs(g, checked, to, num, ring, representation);\n            update = true;\n        }\n    }\n    if (not update) {\n        if (g.edge[pos].size() == 2) {\n            ring = true;\n        } else {\n            ring = false;\n        }\n        representation = pos;\n    }\n}\n\nint main()\n{\n\n    while (true) {\n        int n, k;\n        ll s;\n        cin >> n >> k >> s;\n        if (n == 0 and k == 0 and s == 0) {\n            break;\n        }\n        vector<Cube> cubes(n);\n        for (int i = 0; i < n; i++) {\n            ll x, y, z;\n            cin >> x >> y >> z;\n            cubes[i] = Cube{x, y, z, s};\n        }\n        Graph g{n};\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                ll inter = intersection(cubes[i], cubes[j]);\n                if (inter > 0) {\n                    g.addEdge(i, j, inter);\n                }\n            }\n        }\n\n        vector<bool> checked(n, false);\n        vector<pair<pair<int, int>, bool>> cc;\n        for (int i = 0; i < n; i++) {\n            if (not checked[i]) {\n                int num = 0;\n                bool ring = false;\n                int rep;\n                dfs(g, checked, i, num, ring, rep);\n                if (num >= k) {\n                    cc.push_back(make_pair(make_pair(rep, num), ring));\n                }\n            }\n        }\n\n        if (cc.empty()) {\n            cout << -1 << endl;\n            continue;\n        }\n\n        ll maxi = -1;\n        vector<bool> used_head(n, false);\n        vector<bool> used_tail(n, false);\n        for (const auto p : cc) {\n            int rep = p.first.first;\n            int num = p.first.second;\n            bool ring = p.second;\n            if (ring) {\n                int head = rep;\n                int tail = rep;\n                ll sum = 0;\n                for (int i = 0; i < k - 1; i++) {\n                    used_tail[tail] = true;\n                    for (const auto& e : g.edge[tail]) {\n                        if (not used_tail[e.to]) {\n                            tail = e.to;\n                            sum += e.cost;\n                            break;\n                        }\n                    }\n                }\n                if (k == num) {\n                    used_tail[head] = false;\n                    for (const auto& e : g.edge[tail]) {\n                        if (not used_tail[e.to]) {\n                            sum += e.cost;\n                            break;\n                        }\n                    }\n                    maxi = max(maxi, sum);\n                    continue;\n                }\n                maxi = max(maxi, sum);\n                for (int i = 0; i < num; i++) {\n                    used_head[head] = true;\n                    used_tail[tail] = true;\n                    for (const auto& e : g.edge[head]) {\n                        if (not used_head[e.to]) {\n                            head = e.to;\n                            sum -= e.cost;\n                            break;\n                        }\n                    }\n                    for (const auto& e : g.edge[tail]) {\n                        if (not used_tail[e.to]) {\n                            tail = e.to;\n                            sum += e.cost;\n                            break;\n                        }\n                    }\n                    maxi = max(maxi, sum);\n                }\n            } else {\n                int head = rep;\n                int tail = rep;\n                ll sum = 0;\n                for (int i = 0; i < k - 1; i++) {\n                    used_tail[tail] = false;\n                    for (const auto& e : g.edge[tail]) {\n                        if (not used_tail[e.to]) {\n                            tail = e.to;\n                            sum += e.cost;\n                            break;\n                        }\n                    }\n                }\n                maxi = max(maxi, sum);\n                for (int i = 0; i < num - k + 1; i++) {\n                    used_head[head] = true;\n                    used_tail[tail] = true;\n                    for (const auto& e : g.edge[head]) {\n                        if (not used_head[e.to]) {\n                            head = e.to;\n                            sum -= e.cost;\n                            break;\n                        }\n                    }\n                    for (const auto& e : g.edge[tail]) {\n                        if (not used_tail[e.to]) {\n                            tail = e.to;\n                            sum += e.cost;\n                            break;\n                        }\n                    }\n                    maxi = max(maxi, sum);\n                }\n            }\n        }\n        cout << (6 * s * s) * static_cast<ll>(k) - maxi << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i, j) for(int i=0; i < (int)(j); i++)\ntemplate<class T> bool set_min(T &a, const T &b) { return a > b  ? a = b, true : false; }\nconst ll INFL = 1LL << 60;\n\nstruct UnionFind {\n    vector<int> p;\n    UnionFind(int n) {\n        p.resize(n);\n        rep(i,n) p[i] = i;\n    }\n    int root(int x){\n        if(p[x] == x) return x;\n        else return p[x] = root(p[x]);\n    }\n    void unite(int x,int y){\n        x = root(x);\n        y = root(y);\n        if(x != y) p[y] = x;\n    }\n    bool query(int x,int y){\n        return root(x) == root(y);\n    }\n    vector<vector<int>> group() {\n        vector<vector<int>> res;\n        vector<int> index(p.size(), -1);\n        rep(i, p.size()) {\n            int r = root(i);\n            if(index[r] < 0) {\n                index[r] = res.size();\n                res.push_back({});                \n            }\n            res[index[r]].push_back(i);\n        }\n        return res;\n    }\n};\n\nstruct Point {\n    int x, y, z;    \n};\nusing Rectangle = Point;\n\nclass Solver {\n  public:\n    int N, K, S;\n    vector<Rectangle> P;\n    \n    vector<Point> get_points(Rectangle a) {\n        vector<Point> res;\n        for(int i = 0; i < (1 << 3); i++) {\n            auto b = a;\n            if(i & (1 << 0)) b.x += S;\n            if(i & (1 << 1)) b.y += S;\n            if(i & (1 << 2)) b.z += S;\n            res.push_back(b);\n        }\n        return res;\n    }\n    bool does_include(Rectangle a, Point p) {\n        bool ok = true;\n        ok &= a.x <= p.x and p.x <= a.x + S;\n        ok &= a.y <= p.y and p.y <= a.y + S;\n        ok &= a.z <= p.z and p.z <= a.z + S;\n        return ok;\n    }\n    bool does_cross(Rectangle a, Rectangle b) {\n        for(Point &p : get_points(b)) if(does_include(a, p)) return true;\n        return false;\n    }\n    Point get_in_point(Rectangle a, Rectangle b) {\n        for(Point &p : get_points(b)) if(does_include(a, p)) return p;\n        assert(false);\n    }\n    ll calc_surface(vector<vector<int>> &E, int now, int prev) {\n        if(E[now].size() == 0) return K == 1 ? 6 * S * S : INFL;\n        int first = now;\n        ll sum = 0;        \n        rep(i, K) {\n            sum += 6 * S * S;            \n            if(E[now].size() == 1 and E[now][0] == prev) return i == K - 1 ? sum : INFL;\n            \n            int nxt = E[now][ E[now][0] != prev ? 0 : 1];            \n            Point a = get_in_point(P[now], P[nxt]), b = get_in_point(P[nxt], P[now]);\n            int dx = abs(a.x - b.x), dy = abs(a.y - b.y), dz = abs(a.z - b.z);\n            if(dx == 0) dx = S;\n            if(dy == 0) dy = S;\n            if(dz == 0) dz = S;\n           \n            if(i < K - 1 or nxt == first) sum -= 2 * (dx * dy + dy * dz + dz * dx);\n\n            prev = now;\n            now = nxt;\n        }\n        return sum;\n    }\n    bool solve() {\n        cin >> N >> K >> S;\n        if(N == 0) return false;\n        P.resize(N);\n        rep(i, N) cin >> P[i].x >> P[i].y >> P[i].z;\n\n        vector<vector<int>> E(N);\n        UnionFind uf(N);\n\n        rep(i, N) rep(j, i) {\n            if(does_cross(P[i], P[j])) {\n                uf.unite(i, j);\n                E[i].push_back(j);\n                E[j].push_back(i);\n            }\n        }\n        ll ans = INFL;\n        for(vector<int> g : uf.group()) {\n            if(g.size() < K) continue;\n            int now = -1, prev = -1;\n            { // get end point (and set prev when g is circle)\n                for(int i : g) if(E[i].size() == 1) now = i;\n                if(now < 0) { // circle\n                    now = g.front();\n                    prev = E[now].size() == 2 ? E[now][1] : -1;\n                }\n            }\n            rep(i, g.size()) {\n                set_min(ans, calc_surface(E, now, prev));\n                int nxt;\n                if(E[now].size() == 1) {\n                    if(prev > 0) break;\n                    nxt = E[now][0];\n                }\n                else if(E[now].size() == 2) {\n                    nxt = E[now][ E[now][0] != prev ? 0 : 1];                    \n                }\n                prev = now;\n                now = nxt;\n            }\n        }\n        cout << (ans == INFL ? -1 : ans) << endl;\n        \n        return true;\n    }\n};\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while(Solver().solve());\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing P = pair<int, ll>;\n\nint main()\n{\n\tll n, k, s;\n\twhile (cin >> n >> k >> s, n | k | s) {\n\t\tvector<ll> x(n), y(n), z(n);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcin >> x[i] >> y[i] >> z[i];\n\t\t}\n\t\tif (k == 1) {\n\t\t\tcout << s * s * 6 * k << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tvector<vector<P>> G(n);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tif (i != j) {\n\t\t\t\t\tll dx = s - abs(x[i] - x[j]), dy = s - abs(y[i] - y[j]), dz = s - abs(z[i] - z[j]);\n\t\t\t\t\tif (dx > 0 && dy > 0 && dz > 0) {\n\t\t\t\t\t\tG[i].push_back(P(j, dx * dy * 2 + dy * dz * 2 + dz * dx * 2));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tll res = s * s * 6 * k, d = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tpriority_queue<int> pq;\n\t\t\tvector<ll> used(n);\n\t\t\tll tmp = 0;\n\t\t\tbool flag = true;\n\t\t\tused[i] = -1;\n\t\t\tfor (auto p : G[i]) {\n\t\t\t\tused[p.first] += p.second;\n\t\t\t\tpq.push(p.first);\n\t\t\t}\n\t\t\tfor (int j = 0; j < k - 1; j++) {\n\t\t\t\tif (pq.empty()) {\n\t\t\t\t\tflag = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tauto ne = pq.top(); pq.pop();\n\t\t\t\ttmp += used[ne];\n\t\t\t\tused[ne] = -1;\n\t\t\t\tfor (auto p : G[ne]) {\n\t\t\t\t\tif (used[p.first] >= 0) {\n\t\t\t\t\t\tused[p.first] += p.second;\n\t\t\t\t\t\tpq.push(p.first);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (flag) {\n\t\t\t\td = max(d, tmp);\n\t\t\t}\n\t\t}\n\t\tcout << (d ? res - d : -1) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing ll = long long;\nstruct Edge {\n    int dst;\n    ll w;\n    Edge() {}\n    Edge(int d, ll w) : dst(d), w(w) {}\n};\nusing Graph = vector<vector<Edge>>;\nstruct Cube { ll p[3]; };\n\n// グラフを構成する\nGraph MakeGraph(const int n, const int s, vector<Cube> &c) {\n    Graph g(n);\n    ll d[3];\n\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            for (int k = 0; k < 3; ++k)\n                d[k] = s - abs(c[i].p[k] - c[j].p[k]);\n//                d[k] = s + ((c[i].p[k] < c[j].p[k]) ? (c[i].p[k] - c[j].p[k]) : (c[j].p[k] - c[i].p[k]));\n\n            // c[i]とc[j]は交差しない\n            if (min({d[0], d[1], d[2]}) <= 0) continue;\n\n            ll w = 2 * d[0] * d[1] + 2 * d[0] * d[2] + 2 * d[1] * d[2];\n            g[i].emplace_back(Edge(j, w));\n            g[j].emplace_back(Edge(i, w));\n        }\n    }\n\n    return g;\n}\n\nint MinimumArea(const int n, const int k, const int s, const Graph &g) {\n    vector<bool> used(n, false);\n    ll res = -1;\n\n    for (int u = 0; u < 2 * n; ++u) {\n        if (used[u % n] || (u < n && g[u % n].size() == 2)) continue;\n\n        const int v = u % n;\n\n        // vが含まれる連結成分を探す\n        vector<int> sub;\n        int cur = v;\n        while (true) {\n            used[cur] = true;\n            sub.push_back(cur);\n            if (1 <= g[cur].size() && !used[g[cur][0].dst])\n                cur = g[cur][0].dst;\n            else if (g[cur].size() == 2 && !used[g[cur][1].dst])\n                cur = g[cur][1].dst;\n            else\n                break;\n        }\n\n        const int size = sub.size();\n        if (size < k) continue;\n\n        ll sum = 0;\n        for (int i = 0; i < k - 1; ++i)\n            sum += ((g[sub[i]][0].dst == sub[i + 1]) ? g[sub[i]][0].w : g[sub[i]][1].w);\n\n        const bool is_cycle = (g[sub[0]].size() == 2);\n        if (size == k && is_cycle) {\n            sum += ((g[sub[0]][0].dst == sub[size - 1]) ? g[sub[0]][0].w : g[sub[0]][1].w);\n            res = max(res, sum);\n            continue;\n        }\n        res = max(res, sum);\n\n        // 連結成分内でサイズkの連結な辺部分集合を全探索する\n        const int lim = (is_cycle ? size - 1 : size - k);\n        for (int i = 1; i <= lim; ++i) {\n            sum -= ((g[sub[i]][0].dst == sub[i - 1]) ? g[sub[i]][0].w : g[sub[i]][1].w);\n            const int j1 = (i + k - 2) % size, j2 = (i + k - 1) % size;\n            sum += ((g[sub[j1]][0].dst == sub[j2]) ? g[sub[j1]][0].w : g[sub[j1]][1].w);\n            res = max(res, sum);\n        }\n    }\n\n    return (res == -1) ? -1 : 6 * k * s * s - res;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int n, k, s;\n\n    while (cin >> n >> k >> s, n) {\n        vector<Cube> cube(n);\n        for (auto &c : cube)\n            for (int i = 0; i < 3; ++i) cin >> c.p[i];\n\n        cout << MinimumArea(n, k, s, MakeGraph(n, s, cube)) << '\\n';\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int INF = 1 << 30;\n\nstruct edge\n{\n  int to, cost;\n};\n\nint main()\n{\n  int N, K, S;\n  int X[2000], Y[2000], Z[2000];\n\n  while(cin >> N >> K >> S, N) {\n    for(int i = 0; i < N; i++) {\n      cin >> X[i] >> Y[i] >> Z[i];\n    }\n\n    vector< edge > g[2000];\n    for(int i = 0; i < N; i++) {\n      for(int j = 0; j < i; j++) {\n        int latte = max(0LL, S - abs(X[i] - X[j]));\n        int malta = max(0LL, S - abs(Y[i] - Y[j]));\n        int beeet = max(0LL, S - abs(Z[i] - Z[j]));\n        int ukuku = latte * malta + malta * beeet + beeet * latte;\n        if(latte > 0 && malta > 0 && beeet > 0) {\n          g[i].emplace_back((edge) {j, ukuku});\n          g[j].emplace_back((edge) {i, ukuku});\n        }\n      }\n    }\n\n    int ret = -1;\n    for(int i = 0; i < N; i++) {\n      bool v[2000] = {};\n      function< void(int, int, int) > dfs = [&](int idx, int k, int sz)\n      {\n        if(v[idx]++) return;\n        if(k == 0) {\n          if(K >= 3) for(auto &e: g[idx]) if(e.to == i) sz += e.cost;\n          ret = max(ret, sz);\n        } else {\n          for(auto &e : g[idx]) dfs(e.to, k - 1, sz + e.cost);\n        }\n        v[idx] = false;\n      };\n      dfs(i, K - 1, 0);\n    }\n    if(ret == -1) cout << -1 << endl;\n    else cout << 6 * S * S * K - ret * 2 << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\nusing LL = long long;\nusing VL = vector<LL>;\nusing VVL = vector<VL>;\nusing PLL = pair<LL, LL>;\nusing VS = vector<string>;\n\n#define ALL(a)  begin((a)),end((a))\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define SORT(c) sort(ALL((c)))\n#define RSORT(c) sort(RALL((c)))\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n#define FF first\n#define SS second\ntemplate<class S, class T>\nistream& operator>>(istream& is, pair<S,T>& p){\n  return is >> p.FF >> p.SS;\n}\ntemplate<class S, class T>\nostream& operator<<(ostream& os, pair<S,T>& p){\n  return os << p.FF << \" \" << p.SS;\n}\ntemplate<class T>\nvoid maxi(T& x, T y){\n  if(x < y) x = y;\n}\ntemplate<class T>\nvoid mini(T& x, T y){\n  if(x > y) x = y;\n}\n\n\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst LL MOD = 1e9+7;\nconst LL INF = 1e17;\n\nLL dfs(const vector<vector<PLL>>& G, vector<bool>& used, int u, int p, int k){\n  if(k == 1){\n\tLL res = 0;\n\tfor(auto&& e: G[u]){\n\t  if(used[e.FF] && e.FF != p)\n\t\tres += e.SS;\n\t}\n\treturn res;\n  }\n\n  LL res = -INF;\n  used[u] = true;\n  for(auto&& e: G[u]){\n\tif(e.FF == p) continue;\n\tres = max(res, dfs(G, used, e.FF, u, k-1) + e.SS);\n  }\n  used[u] = false;\n\n  return res;\n}\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  LL N, K, S;\n  while(cin>>N>>K>>S,N){\n\tvector<vector<PLL>> G(N);\n\tvector<VL> ps(N, vector<LL>(3));\n\tREP(i,N) REP(j,3) cin >> ps[i][j];\n\tREP(i,N) REP(j,i){\n\t  VL ls(3), rs(3);\n\t  REP(k,3)\n\t\tls[k] = min(ps[i][k], ps[j][k]),\n\t\trs[k] = max(ps[i][k], ps[j][k]);\n\t  bool inter = true;\n\t  REP(k,3) inter = inter && (rs[k] <= ls[k] + S);\n\t  if(!inter) continue;\n\n\t  LL surf = 0;\n\t  REP(k1,3) REP(k2,3)\n\t\tif(k1 != k2)\n\t\t  surf += (ls[k1] + S - rs[k1]) * (ls[k2] + S - rs[k2]);\n\t  G[i].EB(j, surf);\n\t  G[j].EB(i, surf);\n\t}\n\n\tLL ans = -INF;\n\tvector<bool> used(N);\n\tREP(i,N){\n\t  LL ret = dfs(G, used, i, -1, K);\n\t  maxi(ans, ret);\n\t}\n\tcout << (ans<0? -1: S*S*6*K - ans) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef tuple<ll,ll,ll> T;\n\nvector<T> v;\nll N, K, S;\n    \nll connect(ll i, ll j){\n    ll x1,y1,z1,x2,y2,z2;\n    tie(x1,y1,z1) = v[i];\n    tie(x2,y2,z2) = v[j];\n    bool checkx = (x1 <= x2 && x2 <= x1 + S) || (x2 <= x1 && x1 <= x2 + S);\n    bool checky = (y1 <= y2 && y2 <= y1 + S) || (y2 <= y1 && y1 <= y2 + S);\n    bool checkz = (z1 <= z2 && z2 <= z1 + S) || (z2 <= z1 && z1 <= z2 + S);\n    ll wix=S-abs(x1-x2);\n    ll wiy=S-abs(y1-y2);\n    ll wiz=S-abs(z1-z2);\n    ll ans=wix*wiy+wiy*wiz+wiz*wix;\n    return (checkx&&checky&&checkz) *ans*2;\n}\nstruct Edge{\n    ll from;\n    ll to;\n    ll cost;\n};\nll ans=0;\nvector<ll>used;\nvoid dfschain(const ll now,const ll from,const vector<vector<Edge>>&edges,vector<ll>kasanari){\n    if(used[now]==true)assert(false);\n    \n    used[now]=true;\n\n    if(edges[now].size()==1&&from!=-1){\n        if(kasanari.size()<K-1){\n            return;\n        } \n        else{\n            ll sum=0;\n            for(ll i=0;i<K-1;++i){\n                sum+=kasanari[i];\n            }\n            for(ll j=0;j<kasanari.size();++j){\n                ans=max(ans,sum);\n                sum+=kasanari[(j+K-1)%kasanari.size()];\n                sum-=kasanari[j];\n            }\n\n        }\n        return;\n    }\n    bool flag=false;\n    for(auto e:edges[now]){\n        if(e.to!=from){\n\n            if(flag)assert(false);\n            flag=true;\n\n            kasanari.push_back(e.cost);\n            dfschain(e.to,now,edges,kasanari);\n        }\n    }\n}\n\nvoid dfscircle(const ll now,const ll from,const vector<vector<Edge>>&edges,vector<ll>kasanari){\n    if(used[now]==true){\n        if(kasanari.size()<K){\n            return;\n        } \n        else if(kasanari.size()==K){\n            ans=max(ans,accumulate(kasanari.begin(),kasanari.end(),0ll));\n        }else{\n            ll sum=0;\n            for(ll i=0;i<K-1;++i){\n                sum+=kasanari[i];\n            }\n            for(ll j=0;j<kasanari.size();++j){\n                ans=max(ans,sum);\n                sum+=kasanari[(j+K-1)%kasanari.size()];\n                sum-=kasanari[j];\n            }\n\n        }\n        return;\n    }\n    used[now]=true;\n\n    bool flag=false;\n    for(auto e:edges[now]){\n        if(e.to!=from){\n            if(flag)assert(false);\n            flag=true;\n\n            kasanari.push_back(e.cost);\n             dfscircle(e.to,now,edges,kasanari);\n             if(from==-1)break;\n        }\n            \n    }\n}\nint main(){\n    while(true){\n        v.clear();\n        ans=0;\n        cin >> N >> K >> S;\n        if(!N)break;\n        used.assign(N,0);\n        \n        for(ll i=0;i<N;i++){\n            ll x,y,z;\n            cin >> x >> y >> z;\n            v.push_back(T(x,y,z));\n        }\n        vector<vector<Edge>>edges(N);\n        for(ll i=0;i<N;++i){\n            for(ll j=0;j<N;++j){\n                if(i==j)continue;\n                if(connect(i,j)){\n                    ll k=connect(i,j);\n                    edges[i].push_back(Edge{i,j,k});\n                }\n            }\n        }\n      \n        for(ll i=0;i<N;++i){\n            if(used[i])continue;\n            if(edges[i].size()==1){\n                vector<ll>kasanari;\n                dfschain(i,-1,edges,kasanari);\n            }\n        }\n        for(ll i=0;i<N;++i){\n            if(used[i])continue;\n            if(edges[i].size()==2){\n                vector<ll>kasanari;\n                \n                dfscircle(i,-1,edges,kasanari);\n            }\n        }\n        if(K==1)cout<<S*S*6<<endl;\n\n        else if(ans==0)cout<<-1<<endl;\n        else cout<<S*S*6*K-ans<<endl;\n    }\n    \n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <array>\n#include <cassert>\n#include <climits>\n#include <complex>\n#include <cstdio>\n#include <cstring>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <iterator>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <string>\n#include <tuple>\n#include <vector>\n\nusing namespace std;\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define ALL(x) (x).begin(), (x).end()\n\nint subcube(int len, int x0, int y0, int z0, int x1, int y1, int z1) {\n    int dx = x0 - x1, dy = y0 - y1, dz = z0 - z1;\n    int sx = max(min(len + dx, len - dx), 0);\n    int sy = max(min(len + dy, len - dy), 0);\n    int sz = max(min(len + dz, len - dz), 0);\n    return (sx * sy * sz == 0) ? 0 : 2 * (sx * sy + sy * sz + sz * sx);\n}\n\nint main(){\n    int n, k, s; \n    while(cin >> n >> k >> s, n != 0){\n    vector<int> xs(n), ys(n), zs(n);\n    REP(i, n) {\n        cin >> xs[i] >> ys[i] >> zs[i];\n    }\n\n    if (k == 1) cout << s * s * 6 * k << endl;\n    vector<vector<int>> subc(n, vector<int>(n));\n    REP(a, n) {\n        REP(b, n) {\n            if (a == b) {/*cout << \"--\\t\";*/ continue;}\n            subc[a][b] = subcube(s, xs[a], ys[a], zs[a], xs[b], ys[b], zs[b]);\n            //cout << subc[a][b] << \"\\t\";\n        }\n        //cout << endl;\n    }\n\n    vector<vector<int>> segs;\n    vector<int> used(n, false);\n\n    /// 4 8 12 16 20\n    REP(a, n){\n        if (used[a]) continue;\n        vector<int> seg;\n        int p = a; bool ok = true;\n        seg.push_back(p);\n        used[a] = true;\n        while(ok) {\n            ok = false;\n            REP(b, n) {\n                if (subc[p][b] > 0) {\n                    if (used[b]) continue;\n                    p = b;\n                    seg.push_back(p);\n                    used[b] = true;\n                    ok = true;\n                    break;\n                }\n            }\n        }\n        reverse(ALL(seg));\n        p = a;\n        ok = true;\n        while(ok) {\n            ok = false;\n            REP(b, n) {\n                //cout << \"?\" << a << \"->\" << b << endl;\n                if (subc[p][b] > 0) {\n                    if (used[b]) continue;\n                    p = b;\n                    seg.push_back(p);\n                    used[b] = true;\n                    ok = true;\n                    break;\n                }\n            }\n        }\n        segs.push_back(seg);\n    }\n\n    int res = -1;\n    REP(i, segs.size()) {\n        const vector<int> seg(segs[i]);\n        \n        /*cout << \"# \"; REP(a, seg.size()) {\n            cout << seg[a] << \" \";\n        } cout << endl;*/\n        \n        const int l = seg.size();\n        if (l < k) { continue; }\n        if (l == k) {\n            int sum = 0;\n            if (l == 2) {\n                res = max(res, subc[seg[0]][seg[1]]);\n                continue;\n            }\n            REP(a, l) {\n                //cout << \"+=\" << seg[a] << \" \" << seg[(a+1)%l] << endl;\n                //cout << \"   : \" << subc[seg[a]][seg[(a+1)%l]] << endl;\n                sum += subc[seg[a]][seg[(a+1)%l]];\n            }\n            res = max(res, sum);\n            continue;\n        }\n        int sum = 0;\n        REP(a, k - 1) {\n            sum += subc[seg[a]][seg[a+1]];\n        }\n        REP(a, l) {\n            res = max(res, sum);\n            int ad = subc[seg[(a + k - 1) % l]][seg[(a + k) % l]];\n            if (ad == 0) break;\n            sum += ad;\n            sum -= subc[seg[(a % l)]][seg[(a + 1) % l]];\n        }\n    }\n\n    // cout << \"$\" << subc[0][1] << endl;\n    // cout << res << endl;\n    if (res < 0) cout << res << endl;\n    else cout << s * s * 6 * k - res << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint main()\n{\n    while(true){\n        int n, k, s;\n        cin >> n >> k >> s;\n        if(n == 0 && k == 0 && s == 0) break;\n        int x[2001], y[2001], z[2001];\n        for(int i = 0; i < n; i++) cin >> x[i] >> y[i] >> z[i];\n        if(k == 1){\n            cout << s * s * 6 << endl;\n            continue;\n        }\n        vector<int> v[2001];\n        for(int i = 0; i < n; i++){\n            for(int j = 0; j < n; j++){\n                if(i == j) continue;\n                if(abs(x[i] - x[j]) < s && abs(y[i] - y[j]) < s && abs(z[i] - z[j]) < s) v[i].push_back(j);\n            }\n        }\n        int ans = 1000000000;\n        for(int i = 0; i < n; i++){\n            if(v[i].size() == 0) continue;\n            int sum = s * s * 6;\n            bool f = true;\n            int last = i;\n            int next = v[i][0];\n            sum += s * s * 6 -\n                (s - abs(x[next] - x[last])) * (s - abs(y[next] - y[last])) * 2 -\n                (s - abs(x[next] - x[last])) * (s - abs(z[next] - z[last])) * 2 -\n                (s - abs(z[next] - z[last])) * (s - abs(y[next] - y[last])) * 2;\n            for(int j = 2; j < k; j++){\n                if(v[next].size() == 1){\n                    f = false;\n                    break;\n                }\n                if(j >= 3 && (v[next][0] == i || v[next][1] == i)){\n                    f = false;\n                    break;\n                }\n                if(v[next][0] == last){\n                    last = next;\n                    next = v[next][1];\n                }\n                else{\n                    last = next;\n                    next = v[next][0];\n                }\n                sum += s * s * 6 -\n                    (s - abs(x[next] - x[last])) * (s - abs(y[next] - y[last])) * 2 -\n                    (s - abs(x[next] - x[last])) * (s - abs(z[next] - z[last])) * 2 -\n                    (s - abs(z[next] - z[last])) * (s - abs(y[next] - y[last])) * 2;\n            }\n            if(!f) continue;\n            if(k >= 4 && (v[next][0] == i || v[next][1] == i)){\n                sum -=\n                    (s - abs(x[next] - x[i])) * (s - abs(y[next] - y[i])) * 2 +\n                    (s - abs(x[next] - x[i])) * (s - abs(z[next] - z[i])) * 2 +\n                    (s - abs(z[next] - z[i])) * (s - abs(y[next] - y[i])) * 2;\n            }\n            ans = min(ans, sum);\n        }\n        for(int i = 0; i < n; i++){\n            if(v[i].size() < 1) continue;\n            int sum = s * s * 6;\n            bool f = true;\n            int last = v[i][0];\n            int next = i;\n            for(int j = 1; j < k; j++){\n                if(v[next].size() == 1){\n                    f = false;\n                    break;\n                }\n                if(j >= 3 && (v[next][0] == i || v[next][1] == i)){\n                    f = false;\n                    break;\n                }\n                if(v[next][0] == last){\n                    last = next;\n                    next = v[next][1];\n                }\n                else{\n                    last = next;\n                    next = v[next][0];\n                }\n                sum += s * s * 6 -\n                    (s - abs(x[next] - x[last])) * (s - abs(y[next] - y[last])) * 2 -\n                    (s - abs(x[next] - x[last])) * (s - abs(z[next] - z[last])) * 2 -\n                    (s - abs(z[next] - z[last])) * (s - abs(y[next] - y[last])) * 2;\n            }\n            if(!f) continue;\n            if(k >= 4 && (v[next][0] == i || v[next][1] == i)){\n                sum -=\n                    (s - abs(x[next] - x[i])) * (s - abs(y[next] - y[i])) * 2 +\n                    (s - abs(x[next] - x[i])) * (s - abs(z[next] - z[i])) * 2 +\n                    (s - abs(z[next] - z[i])) * (s - abs(y[next] - y[i])) * 2;\n            }\n            ans = min(ans, sum);\n        }\n        if(ans == 1000000000) cout << -1 << endl;\n        else cout << ans << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (int)(k); i < (int)(n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1e9 + 7;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate<class T>\nistream& operator >> (istream& is, vector<T>& v)\n{\n\tfor (auto &i : v) is >> i;\n\treturn is;\n}\ntemplate<class T>\nostream& operator<<(ostream& os, vector<T>& v)\n{\n\tconst string delimiter = \"\\n\";\n\tREP(i, v.size())\n\t{\n\t\tos << v[i];\n\t\tif (i != v.size() - 1) os << delimiter;\n\t}\n\treturn os;\n}\n/*--------------------template--------------------*/\n\nstruct Data { int x, y, z; };\nint n, k, s;\n\nint cal(Data a, Data b)\n{\n\tint x = s - abs(a.x - b.x);\n\tint y = s - abs(a.y - b.y);\n\tint z = s - abs(a.z - b.z);\n\treturn 2 * (x * y + y * z + z * x);\n}\n\nint main()\n{\n\tcin.sync_with_stdio(false); cout << fixed << setprecision(10);\n\twhile (cin >> n >> k >> s, n)\n\t{\n\n\t\tvector<Data> v;\n\t\tREP(i, n)\n\t\t{\n\t\t\tint x, y, z; cin >> x >> y >> z;\n\t\t\tv.emplace_back(Data{ x,y,z });\n\t\t}\n\t\tif (k == 1)\n\t\t{\n\t\t\tcout << s * s * 6 << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tvector<vi> g(n);\n\t\tREP(i, n)REP(j, i)\n\t\t{\n\t\t\tData a = v[i], b = v[j];\n\t\t\tif (abs(a.x - b.x) < s && abs(a.y - b.y) < s && abs(a.z - b.z) < s)\n\t\t\t{\n\t\t\t\tg[i].push_back(j);\n\t\t\t\tg[j].push_back(i);\n\t\t\t}\n\t\t}\n\t\tvector<vi> vl, vc;\n\t\tvector<bool> vis(n);\n\t\tREP(i, n)\n\t\t{\n\t\t\tif (!vis[i] && g[i].size() == 1)\n\t\t\t{\n\t\t\t\tvi tmp;\n\t\t\t\ttmp.push_back(i);\n\t\t\t\tvis[i] = true;\n\t\t\t\tint t = i;\n\t\t\t\twhile (1)\n\t\t\t\t{\n\t\t\t\t\tbool f = true;\n\t\t\t\t\tfor (auto x : g[t])\n\t\t\t\t\t{\n\t\t\t\t\t\tif (!vis[x])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tf = false;\n\t\t\t\t\t\t\tt = x;\n\t\t\t\t\t\t\tvis[t] = true;\n\t\t\t\t\t\t\ttmp.push_back(t);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (f) break;\n\t\t\t\t}\n\t\t\t\tvl.push_back(tmp);\n\t\t\t}\n\t\t}\n\t\tREP(i, n)\n\t\t{\n\t\t\tif (!vis[i])\n\t\t\t{\n\t\t\t\tvi tmp;\n\t\t\t\ttmp.push_back(i);\n\t\t\t\tvis[i] = true;\n\t\t\t\tint t = i;\n\t\t\t\twhile (1)\n\t\t\t\t{\n\t\t\t\t\tbool f = true;\n\t\t\t\t\tfor (auto x : g[t])\n\t\t\t\t\t{\n\t\t\t\t\t\tif (!vis[x])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tf = false;\n\t\t\t\t\t\t\tt = x;\n\t\t\t\t\t\t\tvis[t] = true;\n\t\t\t\t\t\t\ttmp.push_back(t);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (f) break;\n\t\t\t\t}\n\t\t\t\tvc.push_back(tmp);\n\t\t\t}\n\t\t}\n\t\tint ans = 1e9;\n\t\tfor (auto l : vl)\n\t\t{\n\t\t\tif (l.size() < k) continue;\n\t\t\tREP(i, l.size() - k + 1)\n\t\t\t{\n\t\t\t\tint tmp = s * s * 6 * k;\n\t\t\t\tREP(j, k - 1)\n\t\t\t\t{\n\t\t\t\t\ttmp -= cal(v[l[i + j]], v[l[i + j + 1]]);\n\t\t\t\t}\n\t\t\t\tchmin(ans, tmp);\n\t\t\t}\n\t\t}\n\n\t\tfor (auto c : vc)\n\t\t{\n\t\t\tif (c.size() < k) continue;\n\t\t\tif (c.size() == k)\n\t\t\t{\n\t\t\t\tc.push_back(c[0]);\n\t\t\t\tint tmp = s * s * 6 * k;\n\t\t\t\tREP(j, k)\n\t\t\t\t{\n\t\t\t\t\ttmp -= cal(v[c[j]], v[c[j + 1]]);\n\t\t\t\t}\n\t\t\t\tchmin(ans, tmp);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tvi l = c;\n\t\t\t\tl.insert(l.end(), ALL(c));\n\t\t\t\tREP(i, l.size() - k + 1)\n\t\t\t\t{\n\t\t\t\t\tint tmp = s * s * 6 * k;\n\t\t\t\t\tREP(j, k - 1)\n\t\t\t\t\t{\n\t\t\t\t\t\ttmp -= cal(v[l[i + j]], v[l[i + j + 1]]);\n\t\t\t\t\t}\n\t\t\t\t\tchmin(ans, tmp);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (ans == 1e9) ans = -1;\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, n) for(int i = a; i < n; i++)\n#define int long long\nusing namespace std;\nconst int MAX_N = 2010;\nconst int INF = 1e18;\nint d[MAX_N][MAX_N];\nvector<int> G[MAX_N];\nint n, k, s;\n\nint calc(int x1, int y1, int z1, int x2, int y2, int z2){\n    int x = min(x1, x2) + s - max(x1, x2);\n    int y = min(y1, y2) + s - max(y1, y2);\n    int z = min(z1, z2) + s - max(z1, z2);\n    // cout << \" \" << x << ' ' << y << ' ' << z << endl;\n    if(x <= 0 || y <= 0 || z <= 0) return 0;\n    // if(x == 0) x = s;\n    // if(y == 0) y = s;\n    // if(z == 0) z = s;\n    int res = 2 * (x * y + y * z + z * x);\n    return res;\n}\n\nsigned main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    while(1){\n        cin >> n >> k >> s;\n        if(n + k + s == 0) break;\n        vector<int> x(n), y(n), z(n);\n        rep(i, 0, n){\n            cin >> x[i] >> y[i] >> z[i];\n        }\n        if(n == 1 || k == 1){\n            cout << 6 * s * s << endl;\n            continue;\n        }\n        rep(i, 0, n) rep(j, 0, n) d[i][j] = 0;  \n        rep(i, 0, n) G[i].clear();\n        rep(i, 0, n){\n            rep(j, i + 1, n){\n                d[i][j] = calc(x[i], y[i], z[i], x[j], y[j], z[j]);\n                    // cout << i << ' ' << j << ' ' << d[i][j] << endl;\n                d[j][i] = d[i][j];\n                if(d[i][j] > 0){\n                    G[i].push_back(j);\n                    G[j].push_back(i);\n                }\n            }\n        }\n        int ans = INF;\n        rep(i, 0, n){\n            rep(j, 0, G[i].size()){\n                int tmp = 0;\n                int now = G[i][j], nxt, pre = i;\n                // cout << i << ' ' << tmp << endl;\n                rep(l, 0, k - 1){\n                    if(now == i){\n                        tmp = INF; break;\n                    }\n                    tmp += d[pre][now];\n                    // cout << now << ' ' << d[pre][now] << \" \" << tmp << endl;                    \n                    if(G[now].size() == 1){\n                        if(l == k - 2){\n                            now = pre = -1;\n                        }else{\n                            tmp = INF;\n                        }\n                        break;\n                    }else{\n                        rep(p, 0, G[now].size()){\n                            if(G[now][p] != pre) nxt = G[now][p];\n                        }\n                        pre = now;\n                        now = nxt;\n                    }\n                }\n                // cout << endl;\n                if(tmp != INF){\n                    if(now == i) tmp += d[pre][now];\n                    // cout << now << \" \" << pre << \" \" << d[pre][now] << \" \" << tmp << endl;\n                    tmp = 6 * s * s * k - tmp;\n                    ans = min(ans, tmp);\n                    // cout << \" \" << tmp << endl;\n                }\n            }\n        }\n        if(ans == INF) cout << -1 << endl;\n        else cout << ans << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <cmath>\n#include <cstdlib>\n#include <map>\nusing namespace std;\n\nclass Point {\npublic:\n    int x, y, z;\n    Point(int x = 0, int y = 0, int z = 0) : x(x), y(y), z(z) {}\n};\n\nclass Cube {\npublic:\n    Point p;\n    int s;\n    int vx[4] = {0, 1, 1, 0}, vy[4] = {0, 0, 1, 1}, vz[2] = {0, 1};\n    Cube(Point p = Point(), int s = 0) : p(p), s(s) {}\n\n    bool isIn(const Cube &c) {\n        int nx, ny, nz;\n\n        for (int i = 0; i < 2; ++i) {\n            for (int j = 0; j < 4; ++j) {\n                nx = c.p.x + c.s * vx[j];\n                ny = c.p.y + c.s * vy[j];\n                nz = c.p.z + c.s * vz[i];\n\n                if (p.x <= nx && nx <= p.x + s &&\n                    p.y <= ny && ny <= p.y + s &&\n                    p.z <= nz && nz <= p.z + s) {\n                        return true;\n                    }\n            }\n        }\n\n        return false;\n    }\n\n    long long shareS(Cube &c) {\n        long long ret = 0;\n        Point a, b;\n        a = p; b = c.p;\n\n        if (a.x > b.x) swap(a.x, b.x);\n        if (a.y > b.y) swap(a.y, b.y);\n        if (a.z > b.z) swap(a.z, b.z);\n\n        ret += abs((a.x + s - b.x) * (a.z + s - b.z) * 2);\n        ret += abs((a.y + s - b.y) * (a.z + s - b.z) * 2);\n        ret += abs((a.x + s - b.x) * (a.y + s - b.y) * 2);\n        return ret;\n    }\n\n};\n\nint n, k, s, x, y, z;\nlong long ans;\nvector<Cube> c;\nvector<vector<int> > subg;\nvector<bool> used;\nvector<deque<int> > graph;\ndeque<int> que;\nmap<pair<int, int>, bool> mp, init;\n\n// not clever\ninline void makegraph(int v) {\n    for (int i = 0; i < n; ++i) {\n        if (!mp[make_pair(v, i)] && i != v && c[v].isIn(c[i])) {\n            subg[v].push_back(i);\n            subg[i].push_back(v);\n            mp[make_pair(v, i)] = true;\n            mp[make_pair(i, v)] = true;\n        }\n    }\n}\n\n// make path\nvoid dfs(int v) {\n    used[v] = true;\n    int size_ = subg[v].size();\n    bool flag = false;\n\n    for (int i = 0; i < size_; ++i) {\n        if (!used[subg[v][i]]) {\n            dfs(subg[v][i]);\n            if (!flag) que.push_front(v);\n            flag = true;\n        }\n    }\n\n    if (!flag) que.push_front(v);\n}\n\n// is graph[graphid] cycle ?\ninline bool isCycle(int graphid) {\n    int size_ = graph[graphid].size();\n\n    // if all vertex's degree are two, this graph is cycle.\n    for (int i = 0; i < size_; ++i) {\n        if (subg[graph[graphid][i]].size() != 2) return false;\n    }\n\n    return true;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    while (cin >> n >> k >> s, n | k | s) {\n        //cout << \"---- begin ----\" << endl;\n        c.resize(n);\n        subg.resize(n);\n        que.clear();\n        used.assign(n, false);\n        mp = init;\n        ans = int(1e9);\n\n        for (int i = 0; i < n; ++i) {\n            cin >> x >> y >> z;\n            c[i] = {Point(x, y, z), s};    \n        }\n\n        for (int i = 0; i < n; ++i) {\n            makegraph(i);\n        }\n\n        for (int i = 0; i < n; ++i) {\n            if (!used[i]) {\n                dfs(i);\n                graph.push_back(que);\n                que.clear();\n            }\n        }\n\n        /*\n        for (int i = 0; i < graph.size(); ++i) {\n            for (int j = 0; j < graph[i].size(); ++j) {\n                cout << graph[i][j] << \" \";\n            }\n            cout << endl;\n        }\n        */\n\n        int gsize = graph.size(), qsize, upper;\n        long long share;\n        bool isGraphCycle = false;\n\n        //cout << \"k = \" << k << endl;\n\n        for (int i = 0; i < gsize; ++i) {\n            qsize = graph[i].size();\n            isGraphCycle = isCycle(i);\n            if (isGraphCycle) {\n                upper = qsize + k - 1;\n            }\n            else upper = qsize;\n\n            if (qsize < k) continue;\n\n            for (int j = 0; j + k - 1 < upper; ++j) {\n                share = 0;\n                /*for (int l = 0; l < k - 1; ++l) {\n                    cout << graph[i][(j + l) % qsize] << \" \" << graph[i][(j + l + 1) % qsize] << endl;\n                }*/\n                //cout << graph[i][(j + k - 1) % qsize] << \" \" << graph[i][(j + k) % qsize] << endl;\n                //cout << endl;\n\n                for (int l = 0; l < k - 1; ++l) {\n                    //Cube a = c[graph[i][j + l]],\n                    //    b = c[graph[i][j + l + 1]];\n                    //cout << a.p.x << \" \" << a.p.y << \" \" << a.p.z << endl;\n                    //cout << b.p.x << \" \" << b.p.y << \" \" << b.p.z << endl;\n\n                    share += c[graph[i][(j + l) % qsize]].shareS(c[graph[i][(j + l + 1) % qsize]]);\n\n                    //cout << graph[i][(j + l) % qsize] << \" & \" << graph[i][(j + l + 1) % qsize] << endl;\n                    //cout << \"share is \" << tmp << endl;\n                }\n\n                if (isGraphCycle && qsize == k) {\n                    //cout << \"this is cycle\" << endl;\n                    share += c[graph[i][j]].shareS(c[graph[i][(j + qsize - 1) % qsize]]);\n                }\n\n                ans = min(ans, 6 * s * s * k - share);\n                //cout << \"all - share = \" << 6*s*s*k-share << endl;\n            }\n        }\n\n        if (n == 1) ans = 6 * s * s;\n        if (ans == int(1e9)) ans = -1;\n\n        cout << ans << endl;\n\n        //cout << \"---- end ----\" << endl;\n\n        c.clear();\n        graph.clear();\n        subg.clear();\n        used.clear();\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, n) for(int i = a; i < n; i++)\n#define int long long\nusing namespace std;\nconst int MAX_N = 2010;\nconst int INF = 1e18;\nint d[MAX_N][MAX_N];\nvector<int> G[MAX_N];\nint n, k, s;\n\nint calc(int x1, int y1, int z1, int x2, int y2, int z2){\n    int x = min(x1, x2) + s - max(x1, x2);\n    int y = min(y1, y2) + s - max(y1, y2);\n    int z = min(z1, z2) + s - max(z1, z2);\n    // cout << \" \" << x << ' ' << y << ' ' << z << endl;\n    if(x <= 0 || y <= 0 || z <= 0) return 0;\n    // if(x == 0) x = s;\n    // if(y == 0) y = s;\n    // if(z == 0) z = s;\n    int res = 2 * (x * y + y * z + z * x);\n    return res;\n}\n\nsigned main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    while(1){\n        cin >> n >> k >> s;\n        if(n + k + s == 0) break;\n        vector<int> x(n), y(n), z(n);\n        rep(i, 0, n){\n            cin >> x[i] >> y[i] >> z[i];\n        }\n        if(n == 1){\n            cout << 6 * s * s << endl;\n            continue;\n        }\n        rep(i, 0, n) rep(j, 0, n) d[i][j] = 0;  \n        rep(i, 0, n) G[i].clear();\n        rep(i, 0, n){\n            rep(j, i + 1, n){\n                d[i][j] = calc(x[i], y[i], z[i], x[j], y[j], z[j]);\n                    // cout << i << ' ' << j << ' ' << d[i][j] << endl;\n                d[j][i] = d[i][j];\n                if(d[i][j] > 0){\n                    G[i].push_back(j);\n                    G[j].push_back(i);\n                }\n            }\n        }\n        int ans = INF;\n        rep(i, 0, n){\n            rep(j, 0, G[i].size()){\n                int tmp = 0;\n                int now = G[i][j], nxt, pre = i;\n                // cout << i << ' ' << tmp << endl;\n                rep(l, 0, k - 1){\n                    if(now == i){\n                        tmp = INF; break;\n                    }\n                    tmp += d[pre][now];\n                    // cout << now << ' ' << d[pre][now] << \" \" << tmp << endl;                    \n                    if(G[now].size() == 1){\n                        if(l == k - 2){\n                            now = pre = -1;\n                        }else{\n                            tmp = INF;\n                        }\n                        break;\n                    }else{\n                        rep(p, 0, G[now].size()){\n                            if(G[now][p] != pre) nxt = G[now][p];\n                        }\n                        pre = now;\n                        now = nxt;\n                    }\n                }\n                // cout << endl;\n                if(tmp != INF){\n                    if(now == i) tmp += d[pre][now];\n                    // cout << now << \" \" << pre << \" \" << d[pre][now] << \" \" << tmp << endl;\n                    tmp = 6 * s * s * k - tmp;\n                    ans = min(ans, tmp);\n                    // cout << \" \" << tmp << endl;\n                }\n            }\n        }\n        if(ans == INF) cout << -1 << endl;\n        else cout << ans << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\ntypedef pair<int,int>P;\n\nint get(int ax,int ay,int az,int bx,int by,int bz,int len){\n  int res=0,x,y,z;\n  vector<P>X,Y,Z;\n  X.push_back(P(ax,ax+len));\n  X.push_back(P(bx,bx+len));\n  Y.push_back(P(ay,ay+len));\n  Y.push_back(P(by,by+len));\n  Z.push_back(P(az,az+len));\n  Z.push_back(P(bz,bz+len));\n  sort(X.begin(),X.end());\n  sort(Y.begin(),Y.end());\n  sort(Z.begin(),Z.end());\n  if(X[0].second<X[1].first)return 0;\n  if(Y[0].second<Y[1].first)return 0;\n  if(Z[0].second<Z[1].first)return 0;\n  x=X[0].second-X[1].first;\n  y=Y[0].second-Y[1].first;\n  z=Z[0].second-Z[1].first;\n  res+=x*y*2;\n  res+=z*y*2;\n  res+=x*z*2;\n  return res;\n}\n\nint n,k,s,a[2001][2001],ans;\nint x[2001],y[2001],z[2001];\nvector<int>v[2001];\nint root;\nbool used[2001];\n\nvoid dfs(int V,int d,int sum){\n  if(d==k){\n    sum+=a[root][V];\n    ans=max(ans,sum);\n    return;\n  }\n  used[V]=1;\n  r(i,v[V].size()){\n    int nxt=v[V][i];\n    if(used[nxt])continue;\n    dfs(nxt,d+1,sum+a[V][nxt]);\n  }\n  used[V]=0;\n}\n\nsigned main(){\n  while(cin>>n>>k>>s,n){\n    memset(a,0,sizeof(a));\n    r(i,n)cin>>x[i]>>y[i]>>z[i];\n    if(k==1){\n      cout<<s*s*6<<endl;\n      continue;\n    }\n    r(i,2001)v[i].clear();\n    for(int i=0;i<n;i++){\n      for(int j=i+1;j<n;j++){\n        int X=get(x[i],y[i],z[i],x[j],y[j],z[j],s);\n        if(!X)continue;\n        a[i][j]=a[j][i]=X;\n        v[i].push_back(j);\n        v[j].push_back(i);\n      }\n    }\n    ans=0;\n    r(i,n){\n      root=i;\n      memset(used,0,sizeof(used));\n      dfs(i,1,0);\n    }\n    if(ans)cout<<s*s*k*6-ans<<endl;\n    else cout<<-1<<endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct P {\n  long x, y, z;\n};\nusing VP = vector<P>;\nusing VI = vector<long>;\nusing VVI = vector<VI>;\n\nbool isConnected(P &p1, P &p2, long s) {\n  return abs(p1.x - p2.x) < s && abs(p1.y - p2.y) < s && abs(p1.z - p2.z) < s;\n}\n\nbool isConnected(long i, long j, VVI &adj) {\n  for (auto k: adj[i]) {\n    if (k == j) return true;\n  }\n  return false;\n}\n\nlong find(long i, VI &par, VI &size) {\n  if (par[i] == i) return i;\n  return par[i] = find(par[i], par, size);\n}\n\nlong getSize(long i, VI &par, VI &size) {\n  return size[find(i, par, size)];\n}\n\nvoid unite(long i, long j, VI &par, VI &size) {\n  i = find(i, par, size);\n  j = find(j, par, size);\n  if (i != j) {\n    par[j] = i;\n    size[i] += size[j];\n  }\n}\n\nlong addNode(VI &nodes, VI &adji) {\n  if (adji.size() == 1) {\n    nodes.push_back(adji.front());\n    return adji.front();\n  }\n  for (auto i: adji) {\n    if (nodes.size() < 2) {\n      nodes.push_back(i);\n      return i;\n    } else {\n      if (i != nodes[nodes.size() - 2]) {\n        nodes.push_back(i);\n        return i;\n      }\n    }\n  }\n  return -1;\n}\n\nvoid solve(long n, long k, long s) {\n  VP v;\n  for (int i = 0; i < n; i++) {\n    long x, y, z;\n    cin >> x >> y >> z;\n    v.push_back({x, y, z});\n  }\n  if (k == 1) {\n    cout << 6 * s * s << endl;\n    return;\n  }\n  VVI adj(n, VI());\n  // union find\n  VI par(n);\n  VI size(n);\n  for (int i = 0; i < n; i++) {\n    par[i] = i;\n    size[i] = 1;\n  }\n  for (int i = 0; i < n; i++) {\n    for (int j = i + 1; j < n; j++) {\n      if (isConnected(v[i], v[j], s)) {\n        adj[i].push_back(j);\n        adj[j].push_back(i);\n        unite(i, j, par, size);\n      }\n    }\n  }\n  unordered_map<long, long> rt;\n  VI roots;\n  for (int i = 0; i < n; i++) {\n    if (getSize(i, par, size) >= k) {\n      long r = find(i, par, size);\n      if (rt[r] == 0) {\n        roots.push_back(r);\n        rt[r]++;\n      }\n    }\n  }\n  if (roots.size() == 0) {\n    cout << -1 << endl;\n    return;\n  }\n  // has answer\n  long ans = 1e18;\n  for (auto root: roots) {\n    // connected components\n    VI con;\n    long st = -1;\n    long loopstart = -1;\n    for (int i = 0; i < n; i++) {\n      if (find(i, par, size) == root) {\n        if (adj[i].size() == 1) {\n          st = i;\n        }\n        loopstart = i;\n      }\n    }\n    if (st == -1) {\n      // loop\n      st = loopstart;\n    }\n    assert(st != -1);\n    con.push_back(st);\n    for (int i = 0; i < 2020; i++) {\n      st = addNode(con, adj[st]);\n      assert(st != -1);\n      if (adj[st].size() == 1) break;\n    }\n    assert(con.size() >= k);\n    VI diffs;\n\n    for (int i = 1; i < con.size(); i++) {\n      long dx = s - abs(v[con[i]].x - v[con[i - 1]].x);\n      long dy = s - abs(v[con[i]].y - v[con[i - 1]].y);\n      long dz = s - abs(v[con[i]].z - v[con[i - 1]].z);\n      diffs.push_back(\n        2 * (dx * dy) + 2 * (dy * dz) + 2 * (dz * dx)\n      );\n    }\n    long unit = 6 * s * s;\n    long area = unit;\n    for (int i = 1; i < k; i++) {\n      area += unit;\n      area -= diffs[i - 1];\n    }\n    for (int i = 0; i < 10; i++) {\n      // cout << i << \" \" << con[i] << endl;\n    }\n    if (con.size() > k && con[k] == con[0]) {\n      area -= diffs[k - 1];\n    }\n    ans = min(ans, area);\n    for (int i = 0; i < con.size() - k; i++) {\n      area += diffs[i];\n      area -= diffs[i + k - 1];\n      ans = min(ans, area);\n    }\n  }\n  cout << ans << endl;\n}\n\nint main() {\n  long n, k, s;\n  while (1) {\n    cin >> n >> k >> s;\n    if (n + k + s == 0) {\n      return 0;\n    }\n    solve(n, k, s);\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cassert>\n\nusing namespace std;\nusing ll = long long;\nconstexpr ll INF = 1LL << 50;\nll s;\n\nstruct Cube {\n    ll x;\n    ll y;\n    ll z;\n};\nll connected(const Cube& c1, const Cube& c2)\n{\n    const ll x1 = c1.x;\n    const ll y1 = c1.y;\n    const ll z1 = c1.z;\n    for (int i = 0; i < 2; i++) {\n        const ll x2 = c2.x + i * s;\n        const ll dx = x2 - x1;\n        for (int j = 0; j < 2; j++) {\n            const ll y2 = c2.y + j * s;\n            const ll dy = y2 - y1;\n            for (int k = 0; k < 2; k++) {\n                const ll z2 = c2.z + k * s;\n                const ll dz = z2 - z1;\n                if (0 < dx and dx <= s and 0 < dy and dy <= s and 0 < dz and dz <= s) {\n                    const ll lx = (i == 0) ? s - dx : dx;\n                    const ll ly = (j == 0) ? s - dy : dy;\n                    const ll lz = (k == 0) ? s - dz : dz;\n                    return (lx * ly + ly * lz + lz * lx) * 2;\n                }\n            }\n        }\n    }\n    return 0;\n}\n\nstruct Edge {\n    int from;\n    int to;\n    ll cost;\n};\nstruct Graph {\n    Graph(const int n)\n    {\n        edge.resize(n);\n    }\n    void addEdge(const int from, const int to, const ll cost)\n    {\n        edge[from].push_back(Edge{from, to, cost});\n        edge[to].push_back(Edge{to, from, cost});\n    }\n    vector<vector<Edge>> edge;\n};\n\nint getEdge(const Graph& g, const int s, vector<bool>& visited)\n{\n    visited[s] = true;\n    int child = 0;\n    for (const auto& e : g.edge[s]) {\n        if (not visited[e.to]) {\n            return getEdge(g, e.to, visited);\n        }\n    }\n    if (child == 0) {\n        return s;\n    }\n}\nstruct Chain {\n    bool ring = false;\n    vector<ll> edges;\n};\nostream& operator<<(ostream& os, const Chain& ch)\n{\n    os << \"Ring: \" << boolalpha << ch.ring << \"\\nEdge: {\";\n    for (int i = 0; i < ch.edges.size(); i++) {\n        if (i != 0) {\n            os << \",\";\n        }\n        os << ch.edges[i];\n    }\n    os << \"}\" << endl;\n}\nvoid dfs(const Graph& g, const int s, const int dep, vector<bool>& visited, Chain& chain)\n{\n    visited[s] = true;\n    for (const auto& e : g.edge[s]) {\n        if (e.to == dep and chain.edges.size() >= 2) {\n            if (not chain.ring) {\n                chain.edges.push_back(e.cost);\n                chain.ring = true;\n            }\n            return;\n        }\n        if (not visited[e.to]) {\n            chain.edges.push_back(e.cost);\n            dfs(g, e.to, dep, visited, chain);\n        }\n    }\n}\n\nint main()\n{\n    while (true) {\n        int n, k;\n        cin >> n >> k >> s;\n        if (n == 0 and k == 0 and s == 0) {\n            break;\n        }\n\n        const ll whole = 6 * s * s * k;\n        if (k == 1) {\n            cout << whole << endl;\n            continue;\n        }\n\n        vector<Cube> cube(n);\n        for (int i = 0; i < n; i++) {\n            cin >> cube[i].x >> cube[i].y >> cube[i].z;\n        }\n        Graph g(n);\n        int e = 0;\n        for (int i = 0; i < n - 1; i++) {\n            for (int j = i + 1; j < n; j++) {\n                const ll cost = connected(cube[i], cube[j]);\n                if (cost > 0) {\n                    e++;\n                    g.addEdge(i, j, cost);\n                }\n            }\n        }\n        assert(e <= n);\n        vector<bool> visited(n, false);\n        vector<Chain> chains;\n        for (int i = 0; i < n; i++) {\n            if (not visited[i]) {\n                vector<bool> visited2(n, false);\n                const int dep = getEdge(g, i, visited2);\n                Chain chain;\n                chain.ring = false;\n                dfs(g, dep, dep, visited, chain);\n                chains.push_back(chain);\n            }\n        }\n        ll mini = INF;\n        for (const auto chain : chains) {\n            const bool ring = chain.ring;\n            const vector<ll>& costs = chain.edges;\n            if (costs.size() < k) {\n                continue;\n            }\n            if (ring) {\n                ll sum = 0;\n                for (int i = 0; i < k - 1; i++) {\n                    sum += costs[i];\n                }\n                if (costs.size() == k) {\n                    sum += costs[k - 1];\n                    mini = min(mini, whole - sum);\n                } else {\n                    mini = min(mini, whole - sum);\n                    int head = 0;\n                    int tail = k - 1;\n                    for (int j = 0; j < costs.size(); j++, head++, tail++, tail = tail % costs.size()) {\n                        sum += (costs[tail] - costs[head]);\n                        mini = min(mini, whole - sum);\n                    }\n                }\n            } else {\n                ll sum = 0;\n                for (int i = 0; i < k - 1; i++) {\n                    sum += costs[i];\n                }\n                mini = min(mini, whole - sum);\n                int head = 0;\n                int tail = k - 1;\n                for (; tail < costs.size(); head++, tail++) {\n                    sum += (costs[tail] - costs[head]);\n                    mini = min(mini, whole - sum);\n                }\n            }\n        }\n        cout << ((mini == INF) ? -1 : mini) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cstring>\nusing namespace std;\nusing ll = long long;\n\nstruct Cube{\n    ll lx, rx;\n    ll ly, ry;\n    ll lz, rz;\n    ll S(){\n        ll dx = rx - lx;\n        ll dy = ry - ly;\n        ll dz = rz - lz;\n        return (dx * dy + dy * dz + dz * dx) * 2;\n    } \n};\n\nll f(Cube c1, Cube c2){\n    ll LX, LY, LZ, RX, RY, RZ;\n    LX = max(c1.lx, c2.lx);\n    RX = min(c1.rx, c2.rx);\n    LY = max(c1.ly, c2.ly);\n    RY = min(c1.ry, c2.ry);\n    LZ = max(c1.lz, c2.lz);\n    RZ = min(c1.rz, c2.rz);\n    if(RX <= LX) return 0;\n    if(RY <= LY) return 0;\n    if(RZ <= LZ) return 0;\n    ll dx = RX - LX;\n    ll dy = RY - LY;\n    ll dz = RZ - LZ;\n    return (dx * dy + dy * dz + dz * dx) * 2;\n}\n\nint n, k, s;\nCube c[2000];\nint vis[2000];\n\nvector<int> G[2000];\n\nvector<vector<int>> C;// ????????????\nvector<vector<int>> S;// ?????¬???\n\n// ????????????????????????\nvoid dfs(int v, int p, vector<int>& a){\n    vis[v] = 1;\n    a.push_back(v);\n    for(int c : G[v]){\n        if(c == p) continue;\n        if(vis[c]) continue;\n        dfs(c, v, a);\n        return;\n    }\n    return;\n}\n\n// ??±?????¢???;\nll X[2000][2000];\n\nint main(){\n    while(cin >> n >> k >> s, n){\n        for(int i = 0; i < n; i++){\n            cin >> c[i].lx  >> c[i].ly >> c[i].lz;\n            c[i].rx = c[i].lx + s;\n            c[i].ry = c[i].ly + s;\n            c[i].rz = c[i].lz + s;\n            G[i].clear();\n        }\n        C.clear();\n        S.clear();\n\n        for(int i = 0; i < n; i++){\n            for(int j = 0; j < n; j++){\n                if(i == j) continue;\n                ll res = f(c[i], c[j]);\n                X[i][j] = res;\n                if(res) G[i].push_back(j);\n            }\n        }\n\n        memset(vis, 0, sizeof vis);\n        for(int i = 0; i < n; i++){\n            if(vis[i]) continue;\n            if(G[i].size() <= 1){\n                vector<int> a;\n                dfs(i, -1, a);\n                if(a.size() < k) continue;\n                S.push_back(a);\n            }   \n        }\n        for(int i = 0; i < n; i++){\n            if(vis[i]) continue;\n            vector<int> a;\n            dfs(i, -1, a);\n            if(a.size() < k) continue;\n            C.push_back(a);\n        }\n\n        ll ans = 1LL << 61;\n        for(auto a : C){\n            int sz = a.size();\n            for(int i = 0; i < sz; i++) a.push_back(a[i]);\n            ll sum = 0;\n            for(int i = 0; i < k; i++){\n                sum += c[a[i]].S();\n                if(i != k - 1 || k == sz) sum -= X[a[i]][a[i + 1]];\n            }\n            for(int i = 0; i < sz; i++){\n                ans = min(ans, sum);\n                sum -= c[a[i]].S();\n                sum += X[a[i]][a[i+1]];\n                sum += c[a[i+k]].S();\n                sum -= X[a[i+k-1]][a[i+k]];\n            }\n            if(k != sz){\n                ans = min(ans, sum);\n            }\n        }\n        for(auto a : S){\n            ll sum = 0;\n            for(int i = 0; i < k; i++){\n                sum += c[a[i]].S();\n                if(i != k - 1) sum -= X[a[i]][a[i + 1]];\n            }\n            for(int i = 0; i < a.size() - k; i++){\n                ans = min(ans, sum);\n                sum -= c[a[i]].S();\n                sum += X[a[i]][a[i+1]];\n                sum += c[a[i+k]].S();\n                sum -= X[a[i+k-1]][a[i+k]];\n            }\n            ans = min(ans, sum);\n        }\n        if(ans == 1LL << 61) cout << -1 << endl;\n        else cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <tuple>\nusing namespace std;\ntypedef pair<int,int> P;//to, cov\nvector<P> E[2000];\nbool used[2000];\n\nint n,k,s,S,ans;\n\nvoid dfs(int st, int v, int len, int sur){\n    used[v]=true;\n    // cout<<v<<' '<<len<<endl;\n    if(len==k) ans = min(ans,sur);\n    for(auto p:E[v]){\n        int to, cov;\n        tie(to,cov)=p;\n        if(to==st&&len==k){\n            ans = min(ans, sur-cov);\n        }else if(len<k&&!used[to]){\n            dfs(st,to,len+1,sur+S-cov);\n        }\n    }\n    used[v]=false;\n}\n\nint main(){\n    while(cin>>n>>k>>s,n){\n        vector<int> X,Y,Z;\n        for(int i=0;i<2000;i++) E[i].clear();\n        S=s*s*6;\n        ans = 1000000000;\n        for(int i=0;i<n;i++){\n            int x,y,z;\n            cin>>x>>y>>z;\n            X.push_back(x);\n            Y.push_back(y);\n            Z.push_back(z);\n        }\n        if(k==1){\n            cout<<S<<endl;\n            continue;\n        }\n        for(int i=0;i<n;i++){\n            for(int j=i+1;j<n;j++){\n                int dx = abs(X[i]-X[j]);\n                int dy = abs(Y[i]-Y[j]);\n                int dz = abs(Z[i]-Z[j]);\n                if(dx<s&&dy<s&&dz<s){\n                    // cout<<i<<' '<<j<<':'<<dx<<' '<<dy<<' '<<dz<<endl;\n                    int cov=((s-dx)*(s-dy)+(s-dy)*(s-dz)+(s-dz)*(s-dx))*2;\n                    E[i].emplace_back(j,cov);\n                    E[j].emplace_back(i,cov);\n                }\n            }\n        }\n        for(int i=0;i<n;i++){\n            dfs(i,i,1,S);\n        }\n        if(ans==1000000000)ans=-1;\n        cout<<ans<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define dbg(...) do{cerr<<__LINE__<<\": \";dbgprint(#__VA_ARGS__, __VA_ARGS__);}while(0);\n\nusing namespace std;\n\nnamespace std{template<class S,class T>struct hash<pair<S,T>>{size_t operator()(const pair<S,T>&p)const{return ((size_t)1e9+7)*hash<S>()(p.first)+hash<T>()(p.second);}};template<class T>struct hash<vector<T>>{size_t operator()(const vector<T> &v)const{size_t h=0;for(auto i : v)h=h*((size_t)1e9+7)+hash<T>()(i)+1;return h;}};}\ntemplate<class T>ostream& operator<<(ostream &os, const vector<T> &v){os<<\"[ \";rep(i,v.size())os<<v[i]<<(i==v.size()-1?\" ]\":\", \");return os;}template<class T>ostream& operator<<(ostream &os,const set<T> &v){os<<\"{ \"; for(const auto &i:v)os<<i<<\", \";return os<<\"}\";}\ntemplate<class T,class U>ostream& operator<<(ostream &os,const map<T,U> &v){os<<\"{\";for(const auto &i:v)os<<\" \"<<i.first<<\": \"<<i.second<<\",\";return os<<\"}\";}template<class T,class U>ostream& operator<<(ostream &os,const pair<T,U> &p){return os<<\"(\"<<p.first<<\", \"<<p.second<<\")\";}\nvoid dbgprint(const string &fmt){cerr<<endl;}template<class H,class... T>void dbgprint(const string &fmt,const H &h,const T&... r){cerr<<fmt.substr(0,fmt.find(\",\"))<<\"= \"<<h<<\" \";dbgprint(fmt.substr(fmt.find(\",\")+1),r...);}\ntypedef long long ll;typedef vector<int> vi;typedef pair<int,int> pi;const int inf = (int)1e9;const double INF = 1e12, EPS = 1e-9;\n\nint main(){\n\tcin.tie(0); cin.sync_with_stdio(0);\n\tint n, k, s;\n\twhile(cin >> n >> k >> s, n){\n\t\tvi x(n), y(n), z(n);\n\t\trep(i, n) cin >> x[i] >> y[i] >> z[i];\n\t\t\n\t\tauto intersect = [&](int i, int j){\n\t\t\tll dx = s - abs(x[i] - x[j]);\n\t\t\tll dy = s - abs(y[i] - y[j]);\n\t\t\tll dz = s - abs(z[i] - z[j]);\n\t\t\tif(dx <= 0 || dy <= 0 || dz <= 0) return 0ll;\n\t\t\treturn (dx * dy + dy * dz + dz * dx) * 2;\n\t\t};\n\t\t\n\t\tvector<vi> e(n);\n\t\trep(i, n) rep(j, i) if(intersect(i, j)){\n\t\t\te[i].pb(j);\n\t\t\te[j].pb(i);\n\t\t\t//dbg(i, j);\n\t\t}\n\t\t\n\t\tfunction<bool(int,int,vector<bool>&,vi&)> rec = [&](int c, int p, vector<bool> &v, vi &idx){\n\t\t\tv[c] = 1;\n\t\t\tidx.pb(c);\n\t\t\tfor(int i : e[c]) if(i != p){\n\t\t\t\tif(v[i]) return true;\n\t\t\t\treturn (bool)rec(i, c, v, idx); \n\t\t\t}\n\t\t\treturn false;\n\t\t};\n\t\t\n\t\tll ans = 1e18;\n\t\tvector<bool> v(n);\n\t\trep(ii, n) if(!v[ii]){\n\t\t\tvi idx;\n\t\t\tbool loop = rec(ii, ii, v, idx);\n\t\t\tif(idx.size() < k) continue;\n\t\t\t\n\t\t\tif(loop && idx.size() == k){\n\t\t\t\tll sum = 6ll * k * s * s;\n\t\t\t\trep(i, (int)idx.size()){\n\t\t\t\t\tll c = intersect(idx[i], idx[(i + 1) % idx.size()]);\n\t\t\t\t\tsum -= c;\n\t\t\t\t}\n\t\t\t\tans = min(ans, sum);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tvector<ll> costs;\n\t\t\t\tif(loop){\n\t\t\t\t\trep(i, (int)idx.size())\n\t\t\t\t\t\tcosts.pb(intersect(idx[i], idx[(i + 1) % idx.size()]));\n\t\t\t\t\tint it = idx.size();\n\t\t\t\t\trep(i, it) idx.pb(idx[i]);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tint hasi = 0;\n\t\t\t\t\trep(i, idx.size()) if(e[idx[i]].size() == 1) hasi = idx[i];\n\t\t\t\t\tfor(int i : idx) v[i] = 0;\n\t\t\t\t\tidx.clear();\n\t\t\t\t\trec(hasi, hasi, v, idx);\n\t\t\t\t\t\n\t\t\t\t\trep(i, (int)idx.size()-1)\n\t\t\t\t\t\tcosts.pb(intersect(idx[i], idx[i + 1]));\n\t\t\t\t\t\n\t\t\t\t\trep(i, idx.size()){\n\t\t\t\t\t\tif(i==0 || i==idx.size()-1) assert(e[idx[i]].size() <= 1);\n\t\t\t\t\t\t//else assert(e[idx[i]].size()==2);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//dbg(k, costs);\n\t\t\t\t\n\t\t\t\tll sum = 6ll * k * s * s;\n\t\t\t\tif(k == 1){\n\t\t\t\t\tans = min(ans, sum);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\trep(i, k-2) sum -= costs[i];\n\t\t\t\trep(i, (int)costs.size() - (k-1) + 1){\n\t\t\t\t\tsum -= costs[i + k-2];\n\t\t\t\t\tans = min(ans, sum);\n\t\t\t\t\tsum += costs[i];\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tif(ans >= 1e18) ans = -1;\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n\n#include <iostream>\n#include <complex>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n\n#include <functional>\n#include <cassert>\n\ntypedef long long ll;\nusing namespace std;\n\n#define debug(x) cerr << __LINE__ << \" : \" << #x << \" = \" << (x) << endl;\n\n#define mod 1000000007 //1e9+7(prime number)\n#define INF 1000000000 //1e9\n#define LLINF 2000000000000000000LL //2e18\n#define SIZE 2010\n\nll asum[SIZE*2];\nbool visited[SIZE];\nvector<pair<int,ll> > vec[SIZE];\n\nll dfs(int i, int now, int back = -1, int area = 0){\n  ll res = -LLINF;\n\n  if(i == 0){\n    if(visited[now]) return area * 2;\n    else return 0;\n  }\n\n  \n  if(visited[now]) return -LLINF;\n  visited[now] = true;\n\n  if(i == 1) res = 0;\n  \n  for(int j=0;j<vec[now].size();j++){\n    if(vec[now][j].first != back)\n      res = max(res, dfs(i-1, vec[now][j].first, now, vec[now][j].second));\n  }\n  \n  visited[now] = false;\n  return res + area * 2;\n}\n\nbool solve(){\n  int n, q, s;\n  int p[SIZE][3];\n\n  scanf(\"%d%d%d\", &n, &q, &s);\n\n  if(n == 0) return false;\n  \n  for(int i=0;i<n;i++){\n    vec[i] = vector<pair<int, ll> >();\n    for(int j=0;j<3;j++)\n      scanf(\"%d\", p[i]+j);\n  }\n\n  for(int i=0;i<n;i++){\n    for(int j=i+1;j<n;j++){\n      int d[3];\n      for(int k=0;k<3;k++){\n        int minp = max(p[i][k], p[j][k]);\n        int maxp = min(p[i][k], p[j][k])+s;\n\n        d[k] = max(0, maxp - minp);\n      }\n\n      if(!d[0] || !d[1] || !d[2]) continue;\n\n      ll sum = (ll)d[0] * d[1] + (ll)d[1] * d[2] + (ll)d[2] * d[0];\n      //debug(sum);\n      vec[i].push_back({j, sum});\n      vec[j].push_back({i, sum});\n      //cerr << i << \" \" << j << \" \" << sum << endl;\n    }\n  }\n\n  ll ans = -LLINF;\n  \n  for(int i=0;i<n;i++){\n    ans = max(ans, dfs(q, i));\n  }\n  \n  if(ans + s * s * 6 * q < 0){\n    puts(\"-1\");\n  }else{\n    printf(\"%lld\\n\", (ll)s * s * 6 * q - ans);\n  }\n  \n  return true;\n}\n\nint main(){\n  while(solve());\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cassert>\n\nusing namespace std;\nusing ll = long long;\nconstexpr ll INF = 1LL << 50;\nll s;\n\nstruct Cube {\n    ll x;\n    ll y;\n    ll z;\n};\nll connected(const Cube& c1, const Cube& c2)\n{\n    const ll x1 = c1.x;\n    const ll y1 = c1.y;\n    const ll z1 = c1.z;\n    for (int i = 0; i < 2; i++) {\n        const ll x2 = c2.x + i * s;\n        const ll dx = x2 - x1;\n        for (int j = 0; j < 2; j++) {\n            const ll y2 = c2.y + j * s;\n            const ll dy = y2 - y1;\n            for (int k = 0; k < 2; k++) {\n                const ll z2 = c2.z + k * s;\n                const ll dz = z2 - z1;\n                if (0 <= dx and dx <= s and 0 <= dy and dy <= s and 0 <= dz and dz <= s) {\n                    const ll lx = (i == 0) ? s - dx : dx;\n                    const ll ly = (j == 0) ? s - dy : dy;\n                    const ll lz = (k == 0) ? s - dz : dz;\n                    return (lx * ly + ly * lz + lz * lx) * 2;\n                }\n            }\n        }\n    }\n    return 0;\n}\n\nstruct Edge {\n    int from;\n    int to;\n    ll cost;\n};\nstruct Graph {\n    Graph(const int n)\n    {\n        edge.resize(n);\n    }\n    void addEdge(const int from, const int to, const ll cost)\n    {\n        edge[from].push_back(Edge{from, to, cost});\n        edge[to].push_back(Edge{to, from, cost});\n    }\n    vector<vector<Edge>> edge;\n};\n\nint getEdge(const Graph& g, const int s, vector<bool>& visited)\n{\n    visited[s] = true;\n    int child = 0;\n    for (const auto& e : g.edge[s]) {\n        if (not visited[e.to]) {\n            return getEdge(g, e.to, visited);\n        }\n    }\n    if (child == 0) {\n        return s;\n    }\n}\nstruct Chain {\n    bool ring = false;\n    vector<ll> edges;\n};\nostream& operator<<(ostream& os, const Chain& ch)\n{\n    os << \"Ring: \" << boolalpha << ch.ring << \"\\nEdge: {\";\n    for (int i = 0; i < ch.edges.size(); i++) {\n        if (i != 0) {\n            os << \",\";\n        }\n        os << ch.edges[i];\n    }\n    os << \"}\" << endl;\n}\nvoid dfs(const Graph& g, const int s, const int dep, vector<bool>& visited, Chain& chain)\n{\n    visited[s] = true;\n    for (const auto& e : g.edge[s]) {\n        if (e.to == dep and chain.edges.size() >= 2) {\n            if (not chain.ring) {\n                chain.edges.push_back(e.cost);\n                chain.ring = true;\n            }\n            return;\n        }\n        if (not visited[e.to]) {\n            chain.edges.push_back(e.cost);\n            dfs(g, e.to, dep, visited, chain);\n        }\n    }\n}\n\nint main()\n{\n    while (true) {\n        int n, k;\n        cin >> n >> k >> s;\n        if (n == 0 and k == 0 and s == 0) {\n            break;\n        }\n\n        const ll whole = 6 * s * s * k;\n        if (k == 1) {\n            cout << whole << endl;\n            continue;\n        }\n\n        vector<Cube> cube(n);\n        for (int i = 0; i < n; i++) {\n            cin >> cube[i].x >> cube[i].y >> cube[i].z;\n        }\n        Graph g(n);\n        for (int i = 0; i < n - 1; i++) {\n            for (int j = i + 1; j < n; j++) {\n                const ll cost = connected(cube[i], cube[j]);\n                if (cost > 0) {\n                    g.addEdge(i, j, cost);\n                }\n            }\n        }\n        vector<bool> visited(n, false);\n        vector<Chain> chains;\n        for (int i = 0; i < n; i++) {\n            if (not visited[i]) {\n                vector<bool> visited2(n, false);\n                const int dep = getEdge(g, i, visited2);\n                Chain chain;\n                chain.ring = false;\n                dfs(g, dep, dep, visited, chain);\n                chains.push_back(chain);\n            }\n        }\n        ll mini = INF;\n        for (const auto chain : chains) {\n\n            const bool ring = chain.ring;\n            const vector<ll>& costs = chain.edges;\n            if (costs.size() < k) {\n                continue;\n            }\n            if (ring) {\n                ll sum = 0;\n                for (int i = 0; i < k - 1; i++) {\n                    sum += costs[i];\n                }\n                if (costs.size() == k) {\n                    sum += costs[k - 1];\n                    mini = min(mini, whole - sum);\n                } else {\n                    mini = min(mini, whole - sum);\n                    int head = 0;\n                    int tail = k - 1;\n                    for (int j = 0; j < costs.size(); j++, head++, tail++, tail = tail % costs.size()) {\n                        sum += (costs[tail] - costs[head]);\n                        mini = min(mini, whole - sum);\n                    }\n                }\n            } else {\n                ll sum = 0;\n                for (int i = 0; i < k - 1; i++) {\n                    sum += costs[i];\n                }\n                mini = min(mini, whole - sum);\n                int head = 0;\n                int tail = k - 1;\n                for (; tail < costs.size(); head++, tail++) {\n                    sum += (costs[tail] - costs[head]);\n                    mini = min(mini, whole - sum);\n                }\n            }\n        }\n        cout << ((mini == INF) ? -1 : mini) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 2001\n#define int long long\nusing namespace std;\nvector<int>G[N];\nint n,K,S;\nstruct point{int x,y,z;};\n\nint Area(){return S*S*6;}\nint sArea(point a,point b){\n  int x = min(a.x+S, b.x+S),X = max(a.x,b.x);\n  int y = min(a.y+S, b.y+S),Y = max(a.y,b.y);\n  int z = min(a.z+S, b.z+S),Z = max(a.z,b.z);\n  if(y <= Y || x <= X || z <= Z) return 0;\n  int area=0;\n  area += 2*(x-X)*(y-Y);\n  area += 2*(y-Y)*(z-Z);\n  area += 2*(z-Z)*(x-X);\n  return area;\n}\n\nvector<point> A;\n\nint dfs(int pos,int k,int start,int prev){\n  if(k == K) return prev==-1? 0:-sArea(A[pos],A[start]);\n  if(prev!=-1 && pos == start) return 1e9;\n  \n  int res = 1e9;\n  for(int nx:G[pos]){\n    if(nx == prev)continue;\n    int area = Area() - sArea(A[pos],A[nx]);\n    res = min(res,area+dfs(nx,k+1,start,pos));\n  }\n  return res;\n}\n\nsigned main(){\n  while(1){\n    cin>>n>>K>>S;\n    if(!n&&!K&&!S)break;\n    \n    A.resize(n);\n    for(int i=0;i<n;i++)cin>>A[i].x>>A[i].y>>A[i].z;\n    \n    for(int i=0;i<N;i++) G[i].clear();\n\n    for(int i=0;i<n;i++)\n      for(int j=i+1;j<n;j++){\n\tif(!sArea(A[i],A[j]))continue;\n\tG[i].push_back(j);\n\tG[j].push_back(i);\n      }\n\n    for(int i=0;i<n;i++) assert(G[i].size()<3);\n    int ans = 1e9;\n    for(int i=0;i<n;i++){\n      \n      ans = min(ans,Area()+dfs(i,1,i,-1));\n    }\n\n    if(ans == 1e9) ans = -1;\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\n\nlong long N, K, S, X[2009], Y[2009], Z[2009], col[2009], cnts; vector<int>x[2009], G[2009]; bool used[2009];\n\nvoid init() {\n\tfor (int i = 0; i < 2009; i++) {\n\t\tX[i] = 0; Y[i] = 0; Z[i] = 0; cnts = 0; col[i] = 0;\n\t\tx[i].clear(); G[i].clear(); used[i] = false;\n\t}\n}\n\nvoid dfs(int pos) {\n\tif (col[pos] >= 1) return;\n\tcol[pos] = cnts; G[cnts].push_back(pos);\n\tfor (int i = 0; i < x[pos].size(); i++) dfs(x[pos][i]);\n}\n\nlong long reduction(long long a, long long b) {\n\tlong long G1 = abs(X[a] - X[b]); G1 = S - G1;\n\tlong long G2 = abs(Y[a] - Y[b]); G2 = S - G2;\n\tlong long G3 = abs(Z[a] - Z[b]); G3 = S - G3;\n\treturn G1*G2 + G2*G3 + G3*G1;\n}\n\nlong long solve(vector<long long>A, bool ispath) {\n\tif (ispath == false) {\n\t\tlong long minx = (1LL << 60);\n\t\tfor (int i = 0; i < A.size(); i++) {\n\t\t\tint LL = i, RR = i + K - 1;\n\n\t\t\tlong long V = 0;\n\t\t\tfor (int j = LL; j <= RR; j++) V += S*S * 6;\n\t\t\tlong long E = 0; if (A.size() == K) E = 1;\n\t\t\tfor (int j = LL; j < RR + E; j++) V -= 2LL * reduction(A[j % A.size()], A[(j + 1) % A.size()]);\n\t\t\tminx = min(minx, V);\n\t\t}\n\t\treturn minx;\n\t}\n\tif (ispath == true) {\n\t\tlong long minx = (1LL << 60);\n\t\tfor (int i = 0; i < A.size(); i++) {\n\t\t\tint LL = i, RR = i + K - 1; if (RR >= A.size()) continue;\n\n\t\t\tlong long V = 0;\n\t\t\tfor (int j = LL; j <= RR; j++) V += S*S * 6;\n\t\t\tfor (int j = LL; j < RR; j++) V -= 2LL * reduction(A[j], A[j + 1]);\n\t\t\tminx = min(minx, V);\n\t\t}\n\t\treturn minx;\n\t}\n}\n\nint main() {\n\twhile (true) {\n\t\tcin >> N >> K >> S; init(); if (N + K + S == 0) break;\n\t\tfor (int i = 1; i <= N; i++) cin >> X[i] >> Y[i] >> Z[i];\n\t\tfor (int i = 1; i <= N; i++) {\n\t\t\tfor (int j = 1; j <= N; j++) {\n\t\t\t\tif (abs(X[i] - X[j]) <= S && abs(Y[i] - Y[j]) <= S && abs(Z[i] - Z[j]) <= S && i != j) {\n\t\t\t\t\tx[i].push_back(j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i <= N; i++) {\n\t\t\tif (col[i] == 0) { cnts++; dfs(i); }\n\t\t}\n\t\tlong long minx = (1LL << 60);\n\t\tfor (int i = 1; i <= cnts; i++) {\n\t\t\tvector<long long>A;\n\t\t\tint t = -1; bool ispath = true;\n\t\t\tfor (int j = 0; j < G[i].size(); j++) {\n\t\t\t\tif (x[G[i][j]].size() <= 1) t = G[i][j];\n\t\t\t}\n\t\t\tif (t == -1) { t = G[i][0]; ispath = false; }\n\n\t\t\twhile (true) {\n\t\t\t\tA.push_back(t); used[t] = true;\n\t\t\t\tint u = -1;\n\t\t\t\tfor (int j = 0; j < x[t].size(); j++) {\n\t\t\t\t\tif (used[x[t][j]] == false) u = x[t][j];\n\t\t\t\t}\n\t\t\t\tif (u == -1) break;\n\t\t\t\tt = u;\n\t\t\t}\n\t\t\tminx = min(minx, solve(A, ispath));\n\t\t}\n\t\tif (minx == (1LL << 60)) minx = -1;\n\t\tcout << minx << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define dbg(...) do{cerr<<__LINE__<<\": \";dbgprint(#__VA_ARGS__, __VA_ARGS__);}while(0);\n\nusing namespace std;\n\nnamespace std{template<class S,class T>struct hash<pair<S,T>>{size_t operator()(const pair<S,T>&p)const{return ((size_t)1e9+7)*hash<S>()(p.first)+hash<T>()(p.second);}};template<class T>struct hash<vector<T>>{size_t operator()(const vector<T> &v)const{size_t h=0;for(auto i : v)h=h*((size_t)1e9+7)+hash<T>()(i)+1;return h;}};}\ntemplate<class T>ostream& operator<<(ostream &os, const vector<T> &v){os<<\"[ \";rep(i,v.size())os<<v[i]<<(i==v.size()-1?\" ]\":\", \");return os;}template<class T>ostream& operator<<(ostream &os,const set<T> &v){os<<\"{ \"; for(const auto &i:v)os<<i<<\", \";return os<<\"}\";}\ntemplate<class T,class U>ostream& operator<<(ostream &os,const map<T,U> &v){os<<\"{\";for(const auto &i:v)os<<\" \"<<i.first<<\": \"<<i.second<<\",\";return os<<\"}\";}template<class T,class U>ostream& operator<<(ostream &os,const pair<T,U> &p){return os<<\"(\"<<p.first<<\", \"<<p.second<<\")\";}\nvoid dbgprint(const string &fmt){cerr<<endl;}template<class H,class... T>void dbgprint(const string &fmt,const H &h,const T&... r){cerr<<fmt.substr(0,fmt.find(\",\"))<<\"= \"<<h<<\" \";dbgprint(fmt.substr(fmt.find(\",\")+1),r...);}\ntypedef long long ll;typedef vector<int> vi;typedef pair<int,int> pi;const int inf = (int)1e9;const double INF = 1e12, EPS = 1e-9;\n\nint main(){\n\tcin.tie(0); cin.sync_with_stdio(0);\n\tint n, k, s;\n\twhile(cin >> n >> k >> s, n){\n\t\tvi x(n), y(n), z(n);\n\t\trep(i, n) cin >> x[i] >> y[i] >> z[i];\n\t\t\n\t\tauto intersect = [&](int i, int j){\n\t\t\tll dx = s - abs(x[i] - x[j]);\n\t\t\tll dy = s - abs(y[i] - y[j]);\n\t\t\tll dz = s - abs(z[i] - z[j]);\n\t\t\tif(dx <= 0 || dy <= 0 || dz <= 0) return 0ll;\n\t\t\treturn (dx * dy + dy * dz + dz * dx) * 2;\n\t\t};\n\t\t\n\t\tvector<vi> e(n);\n\t\trep(i, n) rep(j, i) if(intersect(i, j)){\n\t\t\te[i].pb(j);\n\t\t\te[j].pb(i);\n\t\t\t//dbg(i, j);\n\t\t}\n\t\trep(i, n) assert(e[i].size() <= 2);\n\t\t\n\t\tfunction<bool(int,int,vector<bool>&,vi&)> rec = [&](int c, int p, vector<bool> &v, vi &idx){\n\t\t\tv[c] = 1;\n\t\t\tbool ans = 0;\n\t\t\tidx.pb(c);\n\t\t\tfor(int i : e[c]) if(i != p){\n\t\t\t\tif(v[i]) ans |= 1;\n\t\t\t\telse ans |= rec(i, c, v, idx); \n\t\t\t}\n\t\t\treturn ans;\n\t\t};\n\t\t\n\t\tll ans = 1e18;\n\t\tvector<bool> v(n);\n\t\trep(ii, n) if(!v[ii]){\n\t\t\tvi idx;\n\t\t\tbool loop = rec(ii, ii, v, idx);\n\t\t\tif(idx.size() < k) continue;\n\t\t\t\n\t\t\tif(loop && idx.size() == k){\n\t\t\t\tll sum = 6ll * k * s * s;\n\t\t\t\trep(i, (int)idx.size()){\n\t\t\t\t\tll c = intersect(idx[i], idx[(i + 1) % idx.size()]);\n\t\t\t\t\tsum -= c;\n\t\t\t\t}\n\t\t\t\tans = min(ans, sum);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tvector<ll> costs;\n\t\t\t\tif(loop){\n\t\t\t\t\trep(i, (int)idx.size())\n\t\t\t\t\t\tcosts.pb(intersect(idx[i], idx[(i + 1) % idx.size()]));\n\t\t\t\t\tint it = idx.size();\n\t\t\t\t\trep(i, it) idx.pb(idx[i]);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tint hasi = 0;\n\t\t\t\t\trep(i, idx.size()) if(e[idx[i]].size() == 1) hasi = idx[i];\n\t\t\t\t\tfor(int i : idx) v[i] = 0;\n\t\t\t\t\tidx.clear();\n\t\t\t\t\trec(hasi, hasi, v, idx);\n\t\t\t\t\t\n\t\t\t\t\trep(i, (int)idx.size()-1)\n\t\t\t\t\t\tcosts.pb(intersect(idx[i], idx[i + 1]));\n\t\t\t\t\t#if 0\n\t\t\t\t\trep(i, idx.size()){\n\t\t\t\t\t\t//if(i==0 || i==idx.size()-1) assert(e[idx[i]].size() <= 1);\n\t\t\t\t\t\t//else assert(e[idx[i]].size()==2);\n\t\t\t\t\t\tassert(e[idx[i]].size() <= 2);\n\t\t\t\t\t\tassert(e[idx[i]].size() >= 1);\n\t\t\t\t\t}\n\t\t\t\t\t#endif\n\t\t\t\t}\n\t\t\t\t//dbg(k, costs);\n\t\t\t\t\n\t\t\t\tll sum = 6ll * k * s * s;\n\t\t\t\tif(k == 1){\n\t\t\t\t\tans = min(ans, sum);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\trep(i, k-2) sum -= costs[i];\n\t\t\t\trep(i, (int)costs.size() - (k-1) + 1){\n\t\t\t\t\tsum -= costs[i + k-2];\n\t\t\t\t\tans = min(ans, sum);\n\t\t\t\t\tsum += costs[i];\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tif(ans >= 1e18) ans = -1;\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\nusing namespace std;\n\nstruct cube {\n    int x, y, z, w;\n    cube() {}\n    cube(int a, int b, int c, int d): x(a), y(b), z(c), w(d) {}\n\n    int area() {\n        return 6 * w * w;\n    }\n\n    int overlap_area(cube o) {\n        int ox = w - abs(x - o.x);\n        int oy = w - abs(y - o.y);\n        int oz = w - abs(z - o.z);\n\n        if (ox < 0 || oy < 0 || oz < 0) {\n            return -1;\n        }\n\n        return 2 * (ox * oy + oy * oz + oz * ox);\n    }\n};\n\nint main() {\n    int N, K, S;\n    while (true) {\n        cin >> N >> K >> S;\n        if (N == 0 && K == 0 && S == 0) break;\n\n        vector<cube> cubes;\n        vector<vector<int>> graph(N);\n\n        for (int j = 0; j < N; ++j) {\n            int x, y, z; cin >> x >> y >> z;\n            cubes.emplace_back(x, y, z, S);\n        }\n\n        for (int j = 0; j < N; ++j) {\n            for (int k = j+1; k < N; ++k) {\n                int area = cubes[j].overlap_area(cubes[k]);\n                if (area >= 0) {\n                    graph[j].push_back(k);\n                    graph[k].push_back(j);\n                }\n            }\n        }\n\n        int ans = -1;\n\n        vector<int> visited(N, 0);\n        for (int a = 0; a < N; ++a) {\n            if (visited[a]) continue;\n            visited[a] = 1;\n\n            bool loop = false;\n            vector<int> chain;\n            for (int p = a; p != -1; ) {\n                visited[p] = 1;\n                int np = -1;\n                chain.push_back(p);\n                for (int q: graph[p]) {\n                    if (chain.size() > 2 && q == a) {\n                        loop = true;\n                    }\n                    if (!visited[q]) {\n                        np = q;\n                        break;\n                    }\n                }\n                p = np;\n            }\n\n            if (chain.size() < K) {\n                continue;\n            }\n\n            const int L = chain.size();\n\n            int area = cubes[chain[0]].area();\n            if (K <= 1) {\n                ans = (ans == -1) ? area : min(ans, area);\n            }\n            for (int j = 1; j < (loop ? 2*L : L); ++j) {\n                if (j >= K) {\n                    int va = chain[(j-K)%L], vb = chain[(j-K+1)%L];\n                    area -= cubes[va].area() - cubes[va].overlap_area(cubes[vb]);\n                }\n                area += cubes[chain[j%L]].area() - cubes[chain[(j-1)%L]].overlap_area(cubes[chain[j%L]]);\n                if (K == L && j == L-1) {\n                    area -= cubes[chain[0]].overlap_area(cubes[chain[L-1]]);\n                }\n                if (j+1 >= K) {\n                    ans = (ans == -1) ? area : min(ans, area);\n                }\n            }\n        }\n\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define dbg(...) do{cerr<<__LINE__<<\": \";dbgprint(#__VA_ARGS__, __VA_ARGS__);}while(0);\n\nusing namespace std;\n\nnamespace std{template<class S,class T>struct hash<pair<S,T>>{size_t operator()(const pair<S,T>&p)const{return ((size_t)1e9+7)*hash<S>()(p.first)+hash<T>()(p.second);}};template<class T>struct hash<vector<T>>{size_t operator()(const vector<T> &v)const{size_t h=0;for(auto i : v)h=h*((size_t)1e9+7)+hash<T>()(i)+1;return h;}};}\ntemplate<class T>ostream& operator<<(ostream &os, const vector<T> &v){os<<\"[ \";rep(i,v.size())os<<v[i]<<(i==v.size()-1?\" ]\":\", \");return os;}template<class T>ostream& operator<<(ostream &os,const set<T> &v){os<<\"{ \"; for(const auto &i:v)os<<i<<\", \";return os<<\"}\";}\ntemplate<class T,class U>ostream& operator<<(ostream &os,const map<T,U> &v){os<<\"{\";for(const auto &i:v)os<<\" \"<<i.first<<\": \"<<i.second<<\",\";return os<<\"}\";}template<class T,class U>ostream& operator<<(ostream &os,const pair<T,U> &p){return os<<\"(\"<<p.first<<\", \"<<p.second<<\")\";}\nvoid dbgprint(const string &fmt){cerr<<endl;}template<class H,class... T>void dbgprint(const string &fmt,const H &h,const T&... r){cerr<<fmt.substr(0,fmt.find(\",\"))<<\"= \"<<h<<\" \";dbgprint(fmt.substr(fmt.find(\",\")+1),r...);}\ntypedef long long ll;typedef vector<int> vi;typedef pair<int,int> pi;const int inf = (int)1e9;const double INF = 1e12, EPS = 1e-9;\n\nvector<vector<pi>> build_graph(int n, vi &x, vi &y, vi &z, int s){\n\tvector<vector<pi>> e(n);\n\tauto is = [&](int i, int j){\n\t\tint dx = s - abs(x[i] - x[j]);\n\t\tint dy = s - abs(y[i] - y[j]);\n\t\tint dz = s - abs(z[i] - z[j]);\n\t\tif(dx <= 0 || dy <= 0 || dz <= 0) return 0;\n\t\treturn 2 * (dx * dy + dy * dz + dz * dx);\n\t};\n\trep(i, n) rep(j, i){\n\t\tint x = is(i, j);\n\t\tif(!x) continue;\n\t\te[i].emplace_back(j, x);\n\t\te[j].emplace_back(i, x);\n\t\t//dbg(i, j, x);\n\t}\n\treturn e;\n}\nvector<pair<bool, vi>> composition(vector<vector<pi>> &e, int n){\n\tvector<bool> v(n);\n\tvector<pair<bool, vi>> res;\n\tfunction<bool(int,int,vi&)> rec = [&](int c, int p, vi &vs){\n\t\tvs.pb(c);\n\t\tv[c] = 1;\n\t\tbool res = 0;\n\t\tfor(auto i : e[c]) if(i.first != p){\n\t\t\tif(v[i.first]) res = 1;\n\t\t\telse res |= rec(i.first, c, vs);\n\t\t}\n\t\treturn res;\n\t};\n\trep(i, n) if(!v[i]){\n\t\tvi vs;\n\t\tbool lp = rec(i, i, vs);\n\t\tres.emplace_back(lp, vs);\n\t\t//dbg(lp, vs);\n\t}\n\treturn res;\n}\nll calc_loop(vi &vs, vector<vector<pi>> &e){\n\tll sum = 0;\n\tfor(int p = -1, c = vs[0], i = 0; i < vs.size(); i++){\n\t\tfor(auto j : e[c]) if(j.first != p){\n\t\t\tsum += j.second;\n\t\t\tp = c;\n\t\t\tc = j.first;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn sum;\n}\nvi calc_cost(bool loop, vi &vs, vector<vector<pi>> &e){\n\tvi cost;\n\tint c = vs[0];\n\tfor(int i : vs) if(e[i].size() == 1) c = i;\n\t\n\tfor(int p = -1, i = 0; i < (int)vs.size() - !loop; i++){\n\t\tint nc = -1;\n\t\tfor(auto j : e[c]) if(j.first != p){\n\t\t\tcost.pb((int)j.second);\n\t\t\tp = c;\n\t\t\tnc = j.first;\n\t\t\tbreak;\n\t\t}\n\t\tassert(nc != -1);\n\t\tc = nc;\n\t}\n\tif(loop){\n\t\t//dbg(cost);\n\t\trep(i, vs.size()) cost.pb(cost[i]);\n\t\t//dbg(cost);\n\t}\n\treturn cost;\n}\nint main(){\n\tcin.tie(0); cin.sync_with_stdio(0);\n\tint n, k, s;\n\twhile(cin >> n >> k >> s, n){\n\t\tvi x(n), y(n), z(n);\n\t\trep(i, n) cin >> x[i] >> y[i] >> z[i];\n\t\t\n\t\tif(k == 1){\n\t\t\tcout << 6ll * k * s * s << endl;\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tvector<vector<pi>> e = build_graph(n, x, y, z, s);\n\t\tvector<pair<bool, vi>> comp = composition(e, n);\n\t\tll mx = -1;\n\t\t\n\t\tfor(auto c : comp) if(c.second.size() >= k){\n\t\t\tbool loop = c.first;\n\t\t\tvi vs = c.second;\n\t\t\tif(loop && vs.size() == k) mx = max(mx, calc_loop(vs, e));\n\t\t\telse{\n\t\t\t\tvi costs = calc_cost(loop, vs, e);\n\t\t\t\t/*\n\t\t\t\tll sum = accumulate(costs.begin(), costs.begin() + k - 2, 0ll);\n\t\t\t\trep(i, (int)costs.size() - k + 2){\n\t\t\t\t\tsum += costs[i + k - 2];\n\t\t\t\t\tmx = max(mx, sum);\n\t\t\t\t\tsum -= costs[i];\n\t\t\t\t}\n\t\t\t\tdbg(loop, 6 * k * s * s);\n\t\t\t\tdbg(k, costs)\n\t\t\t\t*/;\n\t\t\t\trep(j, costs.size()){\n\t\t\t\t\tll sum = 0;\n\t\t\t\t\trep(i, k - 1) if(j + i < costs.size()) sum += costs[j + i];\n\t\t\t\t\telse{ sum = -1; break; }\n\t\t\t\t\t//dbg(sum, mx);\n\t\t\t\t\tmx = max(mx, sum);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << (mx < 0 ? -1ll : 6ll * k * s * s - mx) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cstring>\nusing namespace std;\nusing ll = long long;\n\nstruct Cube{\n    ll lx, rx;\n    ll ly, ry;\n    ll lz, rz;\n    ll S(){\n        ll dx = rx - lx;\n        ll dy = ry - ly;\n        ll dz = rz - lz;\n        return (dx * dy + dy * dz + dz * dx) * 2;\n    } \n};\n\nll f(Cube c1, Cube c2){\n    ll L[3][2] = {{c1.lx, c2.lx}, {c1.ly, c2.ly}, {c1.lz, c2.lz}};\n    ll R[3][2] = {{c1.rx, c2.rx}, {c1.ry, c2.ry}, {c1.rz, c2.rz}};\n    ll LX, LY, LZ, RX, RY, RZ;\n    ll sum = 0;\n    LX = max(c1.lx, c2.lx);\n    RX = min(c1.rx, c2.rx);\n    LY = max(c1.ly, c2.ly);\n    RY = min(c1.ry, c2.ry);\n    LZ = max(c1.lz, c2.lz);\n    RZ = min(c1.rz, c2.rz);\n    if(RX <= LX) return 0;\n    if(RY <= LY) return 0;\n    if(RZ <= LZ) return 0;\n    ll dx = RX - LX;\n    ll dy = RY - LY;\n    ll dz = RZ - LZ;\n    return (dx * dy + dy * dz + dz * dx) * 2;\n}\n\nint n, k, s;\nCube c[2000];\nint vis[2000];\n\nvector<int> G[2000];\n\nvector<vector<int>> C;// テ」ツつオテ」ツつ、テ」ツつッテ」ツδォ\nvector<vector<int>> S;// テ、ツクツ?ヲツ慊ャテゥツ??\n\n// テ」ツつオテ」ツつ、テ」ツつッテ」ツδォテ」ツ?凝」ツ?ゥテ」ツ??」ツ??\nbool dfs(int v, int p, vector<int>& a){\n    vis[v] = 1;\n    a.push_back(v);\n    for(int c : G[v]){\n        if(c == p) continue;\n        if(vis[c]) continue;\n        return dfs(c, v, a);\n    }\n    // \n    return G[v].size() == 2;\n}\n\n// テ・ツ?アテゥツ?堙ゥツ敖「テァツゥツ?\nll X[2000][2000];\n\nint main(){\n    while(cin >> n >> k >> s, n){\n        for(int i = 0; i < n; i++){\n            cin >> c[i].lx  >> c[i].ly >> c[i].lz;\n            c[i].rx = c[i].lx + s;\n            c[i].ry = c[i].ly + s;\n            c[i].rz = c[i].lz + s;\n            G[i].clear();\n        }\n        C.clear();\n        S.clear();\n\n        for(int i = 0; i < n; i++){\n            for(int j = 0; j < n; j++){\n                if(i == j) continue;\n                ll res = f(c[i], c[j]);\n                X[i][j] = res;\n                if(res) G[i].push_back(j);\n            }\n        }\n\n        memset(vis, 0, sizeof vis);\n        for(int i = 0; i < n; i++){\n            if(vis[i]) continue;\n            if(G[i].size() == 1){\n                vector<int> a;\n                bool res = dfs(i, -1, a);\n                if(a.size() < k) continue;\n                S.push_back(a);\n            }   \n        }\n        for(int i = 0; i < n; i++){\n            if(vis[i]) continue;\n            vector<int> a;\n            bool res = dfs(i, -1, a);\n            if(a.size() < k) continue;\n            C.push_back(a);\n        }\n\n        ll ans = 1LL << 55;\n        for(auto a : C){\n            int sz = a.size();\n            for(int i = 0; i < sz; i++) a.push_back(a[i]);\n            ll sum = 0;\n            for(int i = 0; i < k; i++){\n                sum += c[a[i]].S();\n                if(i != k - 1 || k == sz) sum -= X[a[i]][a[i + 1]];\n            }\n            for(int i = 0; i < sz; i++){\n                ans = min(ans, sum);\n                sum -= c[a[i]].S();\n                sum += X[a[i]][a[i+1]];\n                sum += c[a[i+k]].S();\n                sum -= X[a[i+k-1]][a[i+k]];\n            }\n            ans = min(ans, sum);\n        }\n        for(auto a : S){\n            ll sum = 0;\n            for(int i = 0; i < k; i++){\n                sum += c[a[i]].S();\n                if(i != k - 1) sum -= X[a[i]][a[i + 1]];\n            }\n            for(int i = 0; i < a.size() - k; i++){\n                ans = min(ans, sum);\n                sum -= c[a[i]].S();\n                sum += X[a[i]][a[i+1]];\n                sum += c[a[i+k]].S();\n                sum -= X[a[i+k-1]][a[i+k]];\n            }\n            ans = min(ans, sum);\n        }\n        if(ans == 1LL << 55) cout << -1 << endl;\n        else cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <math.h>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <bitset>\n#include <algorithm>\nusing namespace std;\n\nstruct xyz_t {\n    int x;\n    int y;\n    int z;\n    double length;       //一乗\n};\n\nstruct first_t {\n    int sec;\n    long long w;\n};\n\nbool asc(const xyz_t& left,const xyz_t& right);\nint next(int p,int q);\nint root(int p);\nvoid unite(int p,int q);\nint same(int p,int q);\nvoid pr(vector<vector<int> > pri);\n\nvector<xyz_t> a;\nvector<int> tree;\nvector<vector<int> > tree_f;\nvector<vector<int> > kaburi;\nvector<int> num;\nvector<int> flg;\nlong long ans;\nint n,k,s;\ndouble LE;\nlong long sum;\n\nint main(){\n  scanf (\"%d %d %d\",&n,&k,&s);\n  while(n){\n    ans=0;\n    LE=sqrt(s*s*3.0);\n    xyz_t aaa={0,0,0,0};\n    a.assign(n,aaa);\n    tree.assign(n,-1);\n    tree_f.assign(n,vector<int>(1,0));\n    kaburi.assign(n,vector<int>(n,0));\n    num.assign(n,1);\n    flg.assign(n,0);\n    for(int t=0;t<n;t++){\n      scanf (\"%d %d %d\",&a[t].x,&a[t].y,&a[t].z);\n      a[t].length=sqrt(a[t].x*a[t].x*1.0+a[t].y*a[t].y*1.0+a[t].z*a[t].z*1.0);\n    }\n    sort(a.begin(),a.end(),asc);\n    for(int i=0;i<n;i++){\n      tree[i]=i;\n    }\n    \n    switch(k){\n      case 1:\n        printf(\"%d\\n\",s*s*6);\n        break;\n      case 3:\n        for(int t=0;t<n-1;++t){\n          for(int s=t+1;(a[s].length<a[t].length+LE&&s<n);++s){\n            int xx=next(a[t].x,a[s].x);\n            int yy=next(a[t].y,a[s].y);\n            int zz=next(a[t].z,a[s].z);\n            if(xx&&yy&&zz){\n              if(same(t,s)==0){\n                if(num[s]!=1){\n                  num[t]+=num[tree[s]];\n                  num[tree[s]]=0;\n                  unite(s,t);\n                }\n                else{\n                  num[s]+=num[tree[t]];\n                  num[tree[t]]=0;\n                  unite(t,s);\n                }\n                kaburi[s][t]=xx*yy+yy*zz+zz*xx;\n                kaburi[t][s]=kaburi[s][t];\n                //printf(\"%d %d %d\\n\",kaburi[q].back());\n                //printf(\"%d %d %d\\n\",xx,yy,zz);\n              }\n              else{\n                kaburi[s][t]=xx*yy+yy*zz+zz*xx;\n                kaburi[t][s]=kaburi[s][t];\n                if(num[s]==0){\n                  flg[t]=1;\n                }\n                else{\n                  flg[s]=1;\n                }\n              }\n            }\n          }\n        }\n        //pr(kaburi);\n        for(int t=0;t<n;++t){\n          sum=0;\n          if(num[t]>=k){\n            if(flg[t]==0){\n              int u=t;\n              int v=0;\n              int uu=t;\n              tree_f[t][0]=t;\n              for(int r=0;r<k-1;++r){\n                while(kaburi[u][v]==0||v==uu){\n                  ++v;\n                }\n                sum+=kaburi[u][v];\n                tree_f[t].push_back(v);\n                uu=u;\n                u=v;\n                v=0;\n              }\n              for(int r=k-1;r<num[t]-1;++r){\n                while(kaburi[u][v]==0||v==uu){\n                  ++v;\n                }\n                tree_f[t].push_back(v);\n                uu=u;\n                u=v;\n                v=0;\n              }\n              if(ans<sum){\n                ans=sum;\n              }\n              for(int r=0;r+k<num[t];++r){\n                sum=sum-kaburi[tree_f[t][r]][tree_f[t][r+1]]+kaburi[tree_f[t][r+k-1]][tree_f[t][r+k]];\n\n                if(ans<sum){\n                  ans=sum;\n                }\n              }\n            }\n            else{\n              if(num[t]!=k){\n                int u=t;\n                int v=0;\n                int uu=t;\n                tree_f[t][0]=t;\n                for(int r=0;r<k-1;++r){\n                  while(kaburi[u][v]==0||v==uu){\n                    ++v;\n                  }\n                  sum+=kaburi[u][v];\n                  tree_f[t].push_back(v);\n                  uu=u;\n                  u=v;\n                  v=0;\n                }\n                for(int r=k-1;r<num[t]*2;++r){\n                  while(kaburi[u][v]==0||v==uu){\n                    ++v;\n                  }\n                  tree_f[t].push_back(v);\n                  uu=u;\n                  u=v;\n                  v=0;\n                }\n                if(ans<sum){\n                  ans=sum;\n                }\n                for(int r=0;r<num[t];++r){\n                  sum=sum-kaburi[tree_f[t][r]][tree_f[t][r+1]]+kaburi[tree_f[t][r+k-1]][tree_f[t][r+k]];\n                  if(ans<sum){\n                    ans=sum;\n                  }\n                  //printf(\"%lld\\n\",sum);\n                }\n                //pr(tree_f);\n              }\n              else{\n                if(k!=3){\n                  int u=t;\n                  int v=0;\n                  int uu=t;\n                  tree_f[t][0]=t;\n                  for(int r=0;r<k;++r){\n                    while(kaburi[u][v]==0||v==uu){\n                      ++v;\n                    }\n                    sum+=kaburi[u][v];\n                    uu=u;\n                    u=v;\n                    v=0;\n                  }\n                  if(ans<sum){\n                    ans=sum;\n                  }\n                }\n                else{\n                  int u=t;\n                  int v=0;\n                  int uu=t;\n                  tree_f[t][0]=t;\n                  for(int r=0;r<k;++r){\n                    while(kaburi[u][v]==0||v==uu){\n                      ++v;\n                    }\n                    sum+=kaburi[u][v];\n                    tree_f[t].push_back(v);\n                    uu=u;\n                    u=v;\n                    v=0;\n                  }\n                  int xxx=s+min({a[tree_f[t][0]].x,a[tree_f[t][1]].x,a[tree_f[t][2]].x})-max({a[tree_f[t][0]].x,a[tree_f[t][1]].x,a[tree_f[t][2]].x});\n                  int yyy=s+min({a[tree_f[t][0]].y,a[tree_f[t][1]].y,a[tree_f[t][2]].y})-max({a[tree_f[t][0]].y,a[tree_f[t][1]].y,a[tree_f[t][2]].y});\n                  int zzz=s+min({a[tree_f[t][0]].z,a[tree_f[t][1]].z,a[tree_f[t][2]].z})-max({a[tree_f[t][0]].z,a[tree_f[t][1]].z,a[tree_f[t][2]].z});\n                  sum=sum-(xxx*yyy+yyy*zzz+zzz*xxx);\n                  if(ans<sum){\n                    ans=sum;\n                  }\n                }\n              }\n            }\n          }\n        }\n        if(ans==0){\n          printf(\"-1\\n\");\n        }\n        else{\n          printf(\"%lld\\n\",s*s*6*k-ans*2);\n        }\n        break;\n      default:\n        for(int t=0;t<n-1;++t){\n          for(int s=t+1;(a[s].length<a[t].length+LE&&s<n);++s){\n            int xx=next(a[t].x,a[s].x);\n            int yy=next(a[t].y,a[s].y);\n            int zz=next(a[t].z,a[s].z);\n            if(xx&&yy&&zz){\n              if(same(t,s)==0){\n                if(num[s]!=1){\n                  num[t]+=num[tree[s]];\n                  num[tree[s]]=0;\n                  unite(s,t);\n                }\n                else{\n                  num[s]+=num[tree[t]];\n                  num[tree[t]]=0;\n                  unite(t,s);\n                }\n                kaburi[s][t]=xx*yy+yy*zz+zz*xx;\n                kaburi[t][s]=kaburi[s][t];\n                //printf(\"%d %d %d\\n\",kaburi[q].back());\n                //printf(\"%d %d %d\\n\",xx,yy,zz);\n              }\n              else{\n                kaburi[s][t]=xx*yy+yy*zz+zz*xx;\n                kaburi[t][s]=kaburi[s][t];\n                if(num[s]==0){\n                  flg[t]=1;\n                }\n                else{\n                  flg[s]=1;\n                }\n              }\n            }\n          }\n        }\n        //pr(kaburi);\n        for(int t=0;t<n;++t){\n          sum=0;\n          if(num[t]>=k){\n            if(flg[t]==0){\n              int u=t;\n              int v=0;\n              int uu=t;\n              tree_f[t][0]=t;\n              for(int r=0;r<k-1;++r){\n                while(kaburi[u][v]==0||v==uu){\n                  ++v;\n                }\n                sum+=kaburi[u][v];\n                tree_f[t].push_back(v);\n                uu=u;\n                u=v;\n                v=0;\n              }\n              for(int r=k-1;r<num[t]-1;++r){\n                while(kaburi[u][v]==0||v==uu){\n                  ++v;\n                }\n                tree_f[t].push_back(v);\n                uu=u;\n                u=v;\n                v=0;\n              }\n              if(ans<sum){\n                ans=sum;\n              }\n              for(int r=0;r+k<num[t];++r){\n                sum=sum-kaburi[tree_f[t][r]][tree_f[t][r+1]]+kaburi[tree_f[t][r+k-1]][tree_f[t][r+k]];\n\n                if(ans<sum){\n                  ans=sum;\n                }\n              }\n            }\n            else{\n              if(num[t]!=k){\n                int u=t;\n                int v=0;\n                int uu=t;\n                tree_f[t][0]=t;\n                for(int r=0;r<k-1;++r){\n                  while(kaburi[u][v]==0||v==uu){\n                    ++v;\n                  }\n                  sum+=kaburi[u][v];\n                  tree_f[t].push_back(v);\n                  uu=u;\n                  u=v;\n                  v=0;\n                }\n                for(int r=k-1;r<num[t]*2;++r){\n                  while(kaburi[u][v]==0||v==uu){\n                    ++v;\n                  }\n                  tree_f[t].push_back(v);\n                  uu=u;\n                  u=v;\n                  v=0;\n                }\n                if(ans<sum){\n                  ans=sum;\n                }\n                for(int r=0;r<num[t];++r){\n                  sum=sum-kaburi[tree_f[t][r]][tree_f[t][r+1]]+kaburi[tree_f[t][r+k-1]][tree_f[t][r+k]];\n                  if(ans<sum){\n                    ans=sum;\n                  }\n                  //printf(\"%lld\\n\",sum);\n                }\n                //pr(tree_f);\n              }\n              else{\n                int u=t;\n                int v=0;\n                int uu=t;\n                tree_f[t][0]=t;\n                for(int r=0;r<k;++r){\n                  while(kaburi[u][v]==0||v==uu){\n                    ++v;\n                  }\n                  sum+=kaburi[u][v];\n                  uu=u;\n                  u=v;\n                  v=0;\n                }\n                if(ans<sum){\n                  ans=sum;\n                }\n              }\n            }\n          }\n        }\n        if(ans==0){\n          printf(\"-1\\n\");\n        }\n        else{\n          printf(\"%lld\\n\",s*s*6*k-ans*2);\n        }\n    }\n    scanf (\"%d %d %d\",&n,&k,&s);\n  }\n}\n/*\n環状 k=3の時 それ以外の時\n\n\n*/\n\n\nbool asc(const xyz_t& left,const xyz_t& right){\n  return left.length<right.length;\n}\n\nint next(int p,int q){\n  if(-s<=(p-q)&&(p-q)<=s){\n    if((p-q)>=0){\n      return s-(p-q);\n    }\n    else{\n      return s-(q-p);\n    }\n  }\n  else{\n    return 0;\n  }\n}\n\nint root(int p){\n  if (tree[p] == p){// 根\n    return p;\n  }\n  else {\n    return tree[p] = root(tree[p]); // 経路圧縮\n  }\n}\n\nvoid unite(int p, int q){\n  p = root(p);\n  q = root(q);\n  if (p == q){}\n  else{\n    tree[p] = q;     //pの親をqの親にする\n  }\n}\n\nint same(int p, int q){\n  return root(p) == root(q);\n}\n\n\n\nvoid pr(vector<vector<int> > pri){\n  for(int t=0;t<int(pri.size());++t){\n    for(int s=0;s<int(pri[t].size())-1;++s){\n      printf(\"%d \",pri[t][s]);\n    }\n    printf(\"%d\\n\",pri[t][pri[t].size()-1]);\n  }\n  printf(\"\\n\");\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long   // <-----!!!!!!!!!!!!!!!!!!!\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n)-1;i>=0;i--)\n#define rrep2(i,a,b) for (int i=(a)-1;i>=b;i--)\n#define chmin(a,b) (a)=min((a),(b));\n#define chmax(a,b) (a)=max((a),(b));\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n#define printV(v) cout<<(#v)<<\":\";for(auto(x):(v)){cout<<\" \"<<(x);}cout<<endl;\n#define printVS(vs) cout<<(#vs)<<\":\"<<endl;for(auto(s):(vs)){cout<<(s)<< endl;}\n#define printVV(vv) cout<<(#vv)<<\":\"<<endl;for(auto(v):(vv)){for(auto(x):(v)){cout<<\" \"<<(x);}cout<<endl;}\n#define printP(p) cout<<(#p)<<(p).first<<\" \"<<(p).second<<endl;\n#define printVP(vp) cout<<(#vp)<<\":\"<<endl;for(auto(p):(vp)){cout<<(p).first<<\" \"<<(p).second<<endl;}\n\ninline void output(){ cout << endl; }\ntemplate<typename First, typename... Rest>\ninline void output(const First& first, const Rest&... rest) {\n    cout << first << \" \"; output(rest...);\n}\n\nusing ll = long long;\nusing Pii = pair<int, int>;\nusing TUPLE = tuple<int, int, int>;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vvvi = vector<vvi>;\nconst int inf = 1ll << 60;\nconst int mod = 1e9 + 7;\nusing Graph = vector<vector<int>>;\n\n// undirected\nvoid addEdge(Graph& G, int x, int y) {\n    G[x].emplace_back(y);\n    G[y].emplace_back(x);\n}\n\nstruct Point {\n    int x, y, z;\n    Point(){}\n    Point(int _x, int _y, int _z) : x(_x), y(_y), z(_z) {}\n};\n\nstruct Cube {\n    Point mi, ma;\n    Cube() : mi(inf, inf, inf), ma(-inf, -inf, -inf) {}\n    Cube(int x, int y, int z, int s) : mi(inf, inf, inf), ma(-inf, -inf, -inf) {\n        update(Point(x, y, z));\n        update(Point(x + s, y + s, z + s));\n    }\n    void update(Point p) {\n        chmin(mi.x, p.x); chmin(mi.y, p.y); chmin(mi.z, p.z);\n        chmax(ma.x, p.x); chmax(ma.y, p.y); chmax(ma.z, p.z);\n    }\n    bool inside(Point p) {\n        return mi.x <= p.x && p.x <= ma.x && mi.y <= p.y && p.y <= ma.y && mi.z <= p.z && p.z <= ma.z;\n    }\n    int surface() {\n        int wx = ma.x - mi.x;\n        int wy = ma.y - mi.y;\n        int wz = ma.z - mi.z;\n        if (wx <= 0 || wy <= 0 || wz <= 0) return -1;\n        return 2 * (wx * wy + wy * wz + wz * wx);\n    }\n    Point kthPoint(int k) {\n        switch(k) {\n            case 0: return Point(mi.x, mi.y, mi.z);\n            case 1: return Point(mi.x, mi.y, ma.z);\n            case 2: return Point(mi.x, ma.y, mi.z);\n            case 3: return Point(mi.x, ma.y, ma.z);\n            case 4: return Point(ma.x, mi.y, mi.z);\n            case 5: return Point(ma.x, mi.y, ma.z);\n            case 6: return Point(ma.x, ma.y, mi.z);\n            case 7: return Point(ma.x, ma.y, ma.z);\n        }\n    }\n    void print() {\n        cerr << \"mi: \"; output(mi.x, mi.y, mi.z);\n        cerr << \"ma: \"; output(ma.x, ma.y, ma.z);\n    }\n};\n\nint intersect(Cube c1, Cube c2) {\n    Cube c;\n    rep(k, 8) {\n        if (c2.inside(c1.kthPoint(k))) {\n            c.update(c1.kthPoint(k));\n        }\n    }\n    rep(k, 8) {\n        if (c1.inside(c2.kthPoint(k))) {\n            c.update(c2.kthPoint(k));\n        }\n    }\n    // c.print();\n    return c.surface();\n}\n\nint n, k, s;\nint ma;\nGraph G;\nvvi overlap;\n\nint sumOverlap(vi& vs) {\n    int t = 0;\n    rep(i, k - 1) {\n        t += overlap[vs[i]][vs[i + 1]];\n    }\n    if (k >= 4 && overlap[vs.back()][vs[0]] > 0) {\n        // cycle\n        t += overlap[vs.back()][vs[0]];\n    }\n    return t;\n}\n\nvoid dfs(int now, int pre, int start, vi& vs) {\n    vs.emplace_back(now);\n\n    if ((int)vs.size() == k) {\n        chmax(ma, sumOverlap(vs));\n        return;\n    }\n\n    for (auto nxt : G[now]) {\n        if (nxt == pre || nxt == start) continue;\n        dfs(nxt, now, start, vs);\n    }\n}\n\nmain() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n\n    int testcase = 0;\n    while (cin >> n >> k >> s, n) {\n        // cerr << \"--- testcase = \" << ++testcase << \" ---\" << endl;\n\n        vector<Cube> cube;\n        rep(i, n) {\n            int x, y, z;\n            cin >> x >> y >> z;\n            cube.emplace_back(x, y, z, s);\n        }\n        // rep(i, n) {\n        //     cerr << i << \":\" << endl;\n        //     cube[i].print();\n        // }\n\n        if (k == 1) {\n            cout << 6 * s * s << endl;\n            continue;\n        }\n\n        G.clear(); G.resize(n);\n        overlap.clear(); overlap.resize(n, vi(n));\n        rep(i, n) {\n            rep2(j, i + 1, n) {\n                int t = intersect(cube[i], cube[j]);\n                if (t > 0) {\n                    addEdge(G, i, j);\n                    overlap[i][j] = t;\n                    overlap[j][i] = t;\n                }\n            }\n        }\n        // printGraph(G);\n\n        ma = -1;\n        rep(i, n) {\n            vi vs;\n            dfs(i, -1, i, vs);\n        }\n\n        cout << (ma == -1 ? -1 : k * 6 * s * s - ma) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define sar(a,n) cout<<#a<<\":\";rep(pachico,n)cout<<\" \"<<a[pachico];cout<<endl\n#define svec(v) cout<<#v<<\":\";rep(pachico,v.size())cout<<\" \"<<v[pachico];cout<<endl\n#define svecp(v) cout<<#v<<\":\";each(pachico,v)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n#define sset(s) cout<<#s<<\":\";each(pachico,s)cout<<\" \"<<pachico;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(pachico,m)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 100005;\n\nstruct edge\n{\n    int to;\n    ll cost;\n};\n\nstruct data\n{\n    ll x,y,z;\n};\n\nvoid dfs(int u,int p,int& vc, int& ed, vector<int>& visit, vector<vector<edge> >& G, vector<int>& v)\n{\n    v.pb(u);\n    visit[u] = vc++;\n    each(e,G[u]){\n        if(visit[e.to] < 0){\n            ed++;\n            dfs(e.to,u,vc,ed,visit,G,v);\n        }else if(visit[e.to] < visit[u] && e.to != p){\n            ed++;\n        }\n    }\n}\n\nll solve(ll x,ll y,ll z)\n{\n    return 2*(x*y+y*z+z*x);\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while(1){\n        int n,K;\n        ll s;\n        cin >> n >> K >> s;\n        if(n == 0) break;\n        vector<vector<edge> > G(n);\n        vector<data> vec(n);\n        rep(i,n){\n            ll x,y,z;\n            cin >> x >> y >> z;\n            vec[i] = (data){x,y,z};\n        }\n        if(K == 1){\n            cout << 6*s*s*K << \"\\n\";\n            continue;\n        }\n        rep(i,n){\n            srep(j,i+1,n){\n                data& p = vec[i], q = vec[j];\n                if(p.x <= q.x){\n                    if(q.x < p.x+s){\n                        if(p.y <= q.y){\n                            if(q.y < p.y+s){\n                                if(p.z <= q.z){\n                                    if(q.z < p.z+s){\n                                        ll val = solve(p.x+s-q.x,p.y+s-q.y,p.z+s-q.z);\n                                        G[i].pb((edge){j,val}), G[j].pb((edge){i,val});\n                                    }\n                                }else{\n                                    if(p.z < q.z+s){\n                                        ll val = solve(p.x+s-q.x,p.y+s-q.y,q.z+s-p.z);\n                                        G[i].pb((edge){j,val}), G[j].pb((edge){i,val});\n                                    }\n                                }\n                            }\n                        }else{\n                            if(p.y < q.y+s){\n                                if(p.z <= q.z){\n                                    if(q.z < p.z+s){\n                                        ll val = solve(p.x+s-q.x,q.y+s-p.y,p.z+s-q.z);\n                                        G[i].pb((edge){j,val}), G[j].pb((edge){i,val});\n                                    }\n                                }else{\n                                    if(p.z < q.z+s){\n                                        ll val = solve(p.x+s-q.x,q.y+s-p.y,q.z+s-p.z);\n                                        G[i].pb((edge){j,val}), G[j].pb((edge){i,val});\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }else{\n                    if(p.x < q.x+s){\n                        if(p.y <= q.y){\n                            if(q.y < p.y+s){\n                                if(p.z <= q.z){\n                                    if(q.z < p.z+s){\n                                        ll val = solve(q.x+s-p.x,p.y+s-q.y,p.z+s-q.z);\n                                        G[i].pb((edge){j,val}), G[j].pb((edge){i,val});\n                                    }\n                                }else{\n                                    if(p.z < q.z+s){\n                                        ll val = solve(q.x+s-p.x,p.y+s-q.y,q.z+s-p.z);\n                                        G[i].pb((edge){j,val}), G[j].pb((edge){i,val});\n                                    }\n                                }\n                            }\n                        }else{\n                            if(p.y < q.y+s){\n                                if(p.z <= q.z){\n                                    if(q.z < p.z+s){\n                                        ll val = solve(q.x+s-p.x,q.y+s-p.y,p.z+s-q.z);\n                                        G[i].pb((edge){j,val}), G[j].pb((edge){i,val});\n                                    }\n                                }else{\n                                    if(p.z < q.z+s){\n                                        ll val = solve(q.x+s-p.x,q.y+s-p.y,q.z+s-p.z);\n                                        G[i].pb((edge){j,val}), G[j].pb((edge){i,val});\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        ll mx = -1;\n        vector<int> visit(n,-1);\n        rep(i,n){\n            if(visit[i] < 0){\n                int vc = 0, ed = 0;\n                vector<int> v;\n                dfs(i,-1,vc,ed,visit,G,v);\n                if(vc < K){\n                    continue;\n                }\n                int st = i, p = -1;\n                if(vc != ed){\n                    each(j,v){\n                        if(len(G[j]) == 1){\n                            st = j;\n                            break;\n                        }\n                    }\n                    assert(st >= 0);\n                    int cnt = 0;\n                    deque<ll> deq;\n                    ll val = 0;\n                    bool ok = true;\n                    while(ok){\n                        ok = false;\n                        cnt++;\n                        each(e,G[st]){\n                            if(e.to != p){\n                                if(cnt+1 > K){\n                                    val -= deq.front();\n                                    deq.pop_front();\n                                }\n                                deq.pb(e.cost);\n                                val += e.cost;\n                                cmx(mx,val);\n                                p = st;\n                                st = e.to;\n                                ok = true;\n                                break;\n                            }\n                        }\n                    }\n                    cmx(mx,val);\n                }else{\n                    int cnt = 0;\n                    deque<ll> deq;\n                    ll val = 0;\n                    int nw = st;\n                    ll al = 0;\n                    while(nw != st || cnt == 0){\n                        cnt++;\n                        each(e,G[nw]){\n                            if(e.to != p){\n                                if(cnt+1 > K){\n                                    val -= deq.front();\n                                    deq.pop_front();\n                                }\n                                al += e.cost;\n                                deq.pb(e.cost);\n                                val += e.cost;\n                                cmx(mx,val);\n                                p = nw;\n                                nw = e.to;\n                                break;\n                            }\n                        }\n                    }\n                    if(vc == K){\n                        cmx(mx,al);\n                    }\n                    cmx(mx,val);\n                }\n            }\n        }\n        if(mx < 0){\n            cout << \"-1\\n\";\n        }else{\n            cout << 6*s*s*K - mx << \"\\n\";\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// Ryo Kamoi\n// #define DEBUG\n\n#include<iostream>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<queue>\n\nusing namespace std;\n\n#define REP(i, n) for(int i=0; i<n; i++)\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntypedef pair<ll, ll> pll;\n\nint INF = 1000000000;\n\nstruct edge {\n  int to; int overlap;\n};\n\nint n, k, s;\nint xyz[2010][3];\nvector<edge> g[2010];\n\nvector<vector<int>> cube[2];\n\nvoid generate_cube(int idx1, int idx2) {\n  int addv[8][3] = {{0, 0, 0}, {s, 0, 0}, {0, s, 0}, {0, 0, s},\n    {s, s, 0}, {s, 0, s}, {0, s, s}, {s, s, s}};\n  int idx[2] = {idx1, idx2};\n\n  REP(i, 2) {\n    cube[i] = vector<vector<int>>();\n    REP(j, 8) {\n      vector<int> cur_cube = vector<int>();\n      REP(k, 3) {\n        cur_cube.push_back(xyz[idx[i]][k] + addv[j][k]);\n      }\n      cube[i].push_back(cur_cube);\n    }\n  }\n}\n\nbool is_inside_cube(int cube_idx, int point_idx) {\n  int point_cube_idx = (cube_idx+1) % 2;\n  REP(i, 3) {\n    if (cube[cube_idx][0][i] > cube[point_cube_idx][point_idx][i]) {\n      return false;\n    }\n    if (cube[cube_idx][7][i] < cube[point_cube_idx][point_idx][i]) {\n      return false;\n    }\n  }\n  return true;\n}\n\nint calc_overlap(int idx1, int idx2) {\n  generate_cube(idx1, idx2);\n  vector<int> overlap_idx[2];\n  REP(i, 2) {\n    REP(j, 8) {\n      if (is_inside_cube((i+1)%2, j)) {\n        overlap_idx[i].push_back(j);\n      }\n    }\n  }\n\n  int max_surface = 0;\n  REP(p, overlap_idx[0].size()) {\n    REP(q, overlap_idx[1].size()) {\n      int overlap_xyz[3];\n      REP(i, 3) {\n        overlap_xyz[i] = abs(cube[0][overlap_idx[0][p]][i]\n                          - cube[1][overlap_idx[1][q]][i]);\n      }\n\n      int surface = 0;\n      REP(i, 3) {\n        surface += 2 * overlap_xyz[i] * overlap_xyz[(i+1)%3];\n      }\n      max_surface = max(max_surface, surface);\n    }\n  }\n  return max_surface;\n}\n\nint graph_overlap(int idx, int e_idx) {\n  if (k==1) return 0;\n\n  int overlap = g[idx][e_idx].overlap;\n  int n_idx = g[idx][e_idx].to;\n  int from = idx;\n  REP(i, k-2) {\n    int to = -1;\n    REP(j, g[n_idx].size()) {\n      if (g[n_idx][j].to == from) continue;\n      to = g[n_idx][j].to;\n      overlap += g[n_idx][j].overlap;\n    }\n    if (to == -1) {\n      return 0;\n    }\n\n    from = n_idx;\n    n_idx = to;\n  }\n\n  // circuit\n  if (k>=3) {\n    int to = -1;\n    REP(j, g[n_idx].size()) {\n      if (g[n_idx][j].to == idx) {\n        overlap += g[n_idx][j].overlap;\n      }\n    }\n  }\n  return overlap;\n}\n\nint main(){\n  while(1) {\n    cin >> n >> k >> s;\n    if (n==0) break;\n\n    REP(i, n) {\n      cin >> xyz[i][0] >> xyz[i][1] >> xyz[i][2];\n      g[i] = vector<edge>();\n    }\n\n    REP(i, n) {\n      for(int j=i+1; j<n; j++) {\n        int overlap = calc_overlap(i, j);\n        if (overlap == 0) continue;\n\n        edge e1;\n        e1.to = j; e1.overlap = overlap;\n        g[i].push_back(e1);\n        \n        edge e2;\n        e2.to = i; e2.overlap = overlap;\n        g[j].push_back(e2);\n\n#ifdef DEBUG\n        cout << i << \" \" << j << \" \" << overlap << endl;\n#endif\n      }\n    }\n\n#ifdef DEBUG\n    cout << \"calc overlap\" << endl;\n#endif\n\n    int max_overlap = 0;\n    REP(i, n) {\n#ifdef DEBUG\n      cout << i << \" \" << g[i].size() << endl;\n#endif\n      REP(j, g[i].size()) {\n        int g_overlap = graph_overlap(i, j);\n        max_overlap = max(max_overlap, g_overlap);\n      }\n#ifdef DEBUG\n      cout << max_overlap << endl;\n#endif\n    }\n\n    int sum_surf = 6*s*s*k;\n    if (k>1 && max_overlap == 0) {\n      cout << -1 << endl;\n    } else {\n      cout << sum_surf - max_overlap << endl;\n    }\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int INF = 1 << 30;\n\nstruct edge\n{\n  int to, cost;\n};\n\nint main()\n{\n  int N, K, S;\n  int X[2000], Y[2000], Z[2000];\n\n  while(cin >> N >> K >> S, N) {\n    for(int i = 0; i < N; i++) {\n      cin >> X[i] >> Y[i] >> Z[i];\n    }\n\n    vector< edge > g[2000];\n    for(int i = 0; i < N; i++) {\n      for(int j = 0; j < i; j++) {\n        int latte = max(0, S - abs(X[i] - X[j]));\n        int malta = max(0, S - abs(Y[i] - Y[j]));\n        int beeet = max(0, S - abs(Z[i] - Z[j]));\n        int ukuku = latte * malta + malta * beeet + beeet * latte;\n        if(latte > 0 && malta > 0 && beeet > 0) {\n          g[i].emplace_back((edge) {j, ukuku});\n          g[j].emplace_back((edge) {i, ukuku});\n        }\n      }\n    }\n\n\n    bool v[2000] = {};\n    int ret = 0;\n\n    for(int i = 0; i < N; i++) {\n      if(v[i]++) continue;\n      vector< int > order;\n      bool looped = false;\n      function< void(int, int) > dfs = [&](int idx, int par)\n      {\n        for(auto &e : g[idx]) {\n          if(e.to == par) continue;\n          if(e.to == i) order.push_back(e.cost), looped = true;\n          if(v[e.to]++) continue;\n          order.push_back(e.cost);\n          dfs(e.to, idx);\n        }\n      };\n      dfs(i, -1);\n      //cout << looped << \" \" << order.size() << endl;\n\n      if(looped) {\n        if(order.size() < K) continue;\n        if(order.size() == K) {\n          ret = max(ret, accumulate(begin(order), end(order), 0));\n        } else {\n          int sum = 0;\n          for(int j = 0; j < K - 1; j++) sum += order[j];\n          ret = max(ret, sum);\n          for(int j = K - 1; j < 2 * order.size(); j++) {\n            sum -= order[(j - (K - 1)) % order.size()];\n            sum += order[j % order.size()];\n            ret = max(ret, sum);\n          }\n        }\n      } else {\n        int sum = 0;\n        for(int j = 0; j < K - 1; j++) sum += order[j];\n        ret = max(ret, sum);\n        for(int j = K - 1; j < order.size(); j++) {\n          sum -= order[j - (K - 1)];\n          sum += order[j];\n          ret = max(ret, sum);\n        }\n      }\n    }\n\n    if(ret == 0 && K > 1) cout << -1 << endl;\n    else cout << 6 * S * S * K - ret * 2 << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define _SILENCE_CXX17_C_HEADER_DEPRECATION_WARNING\n#define _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS\n#define _CRT_SECURE_NO_WARNINGS\n#include <bits/stdc++.h>\n#include<iostream>\n#include<unordered_set>\n\nusing namespace std;\n\n#define dprint(Exp,...) if(Exp){fprintf(stderr, __VA_ARGS__);}\n#define printe(...) fprintf(stderr, __VA_ARGS__);\n//#define printe(...) void();\n#define printE(...) fprintf(stderr, __VA_ARGS__);\n//#define printE(...) void();\n\n\n#define PrtExp(_Exp)  cerr<< #_Exp <<\" = \"<< (_Exp)\n#define PrtExpN(_Exp)  cerr<< #_Exp <<\" = \"<< (_Exp) <<\"\\n\"\n\n#define SINT(n) scanf(\"%d\",&n)\n#define SINT2(n,m) scanf(\"%d %d\",&n,&m)\n#define SINT3(n,m,o) scanf(\"%d %d %d\",&n,&m,&o)\n#define SINT4(n,m,o,P) scanf(\"%d %d %d %d\",&n,&m,&o,&P)\n#define SINT5(n,m,o,P,q) scanf(\"%d %d %d %d %d\",&n,&m,&o,&P,&q)\n#define SLL(n) scanf(\"%lld\",&n)\n#define SLL2(n,m) scanf(\"%lld %lld\",&n,&m)\n#define SLL3(n,m,o) scanf(\"%lld %lld %lld\",&n,&m,&o)\n#define SST(s) scanf(\"%s\",s)\n#define SCH(c) scanf(\"%c\",&c)\n\n#define GC() getchar()\n\n#define PINT(n) printf(\"%d\",(int)(n))\n#define PINT2(n,m) printf(\"%d %d\",(int)(n),(int)(m))\n#define PINT3(n,m,l) printf(\"%d %d %d\",(int)(n),(int)(m),(int)(l))\n#define PLL(n) printf(\"%lld\",(long long)(n))\n#define PST(s) printf(\"%s\",(s))\n#define PCH(s) printf(\"%c\",(s))\n\n#define PINTN(n) printf(\"%d\\n\",(int)(n))\n#define PINT2N(n,m) printf(\"%d %d\\n\",(int)(n),(int)(m))\n#define PINT3N(n,m,l) printf(\"%d %d %d\\n\",(int)(n),(int)(m),(int)(l))\n#define PLLN(n) printf(\"%lld\\n\",(long long)(n))\n#define PSTN(s) printf(\"%s\\n\",(s))\n#define PCHN(s) printf(\"%c\\n\",(s))\n\n#define PSP() printf(\" \")\n#define PN() printf(\"\\n\")\n\n#define PC(c) putchar(c)\n#define CSP (' ')\n#define SN (\"\\n\")\n\n#define rep(i,a) for(int i=0;i<a;i++)\n#define reP(i,a) for(int i=0;i<=a;i++)\n#define Rep(i,a) for(int i=a-1;i>=0;i--)\n#define ReP(i,a) for(int i=a;i>=0;i--)\n\n#define rEp(i,a) for(i=0;i<a;i++)\n#define rEP(i,a) for(i=0;i<=a;i++)\n#define REp(i,a) for(i=a-1;i>=0;i--)\n#define REP(i,a) for(i=a;i>=0;i--)\n\n#define repft(i,a,b) for(int i=a;i<b;i++)\n#define repfT(i,a,b) for(int i=a;i<=b;i++)\n#define Repft(i,a,b) for(int i=a-1;i>=b;i--)\n#define RepfT(i,a,b) for(int i=a;i>=b;i--)\n\n#define foreach(a,it) for(auto it = a.begin(); it != a.end(); ++it)\n\n#define FILL(a,v) fill(begin(a),end(a), v)\n#define FILL0(a) memset(a,0,sizeof(a))\n#define FILL1(a) memset(a,-1,sizeof(a))\n\ntypedef long long ll;\n\ntypedef unsigned long long ull;\ntypedef pair<int, int> Pi;\ntypedef pair<ll, ll>   Pll;\n\n\nconst int INF = 1'010'000'000; // 0x3C33'6080\nconst ll INFLL = 0x1f1f1f1f1f1f1f1fLL;//2,242,545,357,980,376,863\n\ntemplate <class A, class B> inline ostream& operator<<(ostream& st, const pair<A, B>& P) { return st << \"(\" << P.first << \",\" << P.second << \")\"; };\ntemplate <class A, class B> inline pair<A, B> operator+(const pair<A, B>& P, const pair<A, B>& Q) { return pair<A, B>(P.first + Q.first, P.second + Q.second); };\ntemplate <class A, class B> inline pair<A, B> operator-(const pair<A, B>& P, const pair<A, B>& Q) { return pair<A, B>(P.first - Q.first, P.second - Q.second); };\n\n#define fs  first\n#define sc  second\n\nint bitCount(unsigned int bits) {\n\tbits = (bits & 0x55555555) + (bits >> 1 & 0x55555555);    //  2bitごとに計算\n\tbits = (bits & 0x33333333) + (bits >> 2 & 0x33333333);    //  4bitごとに計算\n\tbits = (bits & 0x0f0f0f0f) + (bits >> 4 & 0x0f0f0f0f);    //  8bitごとに計算\n\tbits = (bits & 0x00ff00ff) + (bits >> 8 & 0x00ff00ff);    //  16ビットごとに計算   \n\treturn (bits & 0x0000ffff) + (bits >> 16);    //  32ビット分を計算   \n}\n\n\nint x[2003];\nint y[2003];\nint z[2003];\nbool used[2003];\n\nvector<Pi> G[2003];\nvector<int> d;\n\nvoid dfs(int i, int pre, bool f = false) {\n\tif(!f) used[i] = true;\n\n\tfor (auto&p : G[i]) {\n\t\tif (p.first == pre) continue;\n\t\tif (used[p.first]) continue;\n\t\td.push_back(p.second);\n\t\treturn dfs(p.first, i);\n\t}\n}\n\nint main() {\n\tint n, k, s;\n\twhile (cin >> n >> k >> s, n) {\n\t\trep(i, n) cin >> x[i] >> y[i] >> z[i];\n\t\trep(i, n) G[i].clear();\n\t\trep(i, n) used[i] = false;\n\n\t\tif (k == 1) {\n\t\t\tcout << s*s * 6 << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tint km1 = k - 1;\n\n\t\trep(i, n) repft(j, i + 1, n) {\n\t\t\tint dx = abs(x[i] - x[j]);\n\t\t\tint dy = abs(y[i] - y[j]);\n\t\t\tint dz = abs(z[i] - z[j]);\n\t\t\tif (dx >= s || dy >= s || dz >= s) continue;\n\t\t\tdx = s - dx;\n\t\t\tdy = s - dy;\n\t\t\tdz = s - dz;\n\t\t\tint v = (dx * dy + dy * dz + dz * dx)*2;\n\t\t\tG[i].emplace_back(j, v);\n\t\t\tG[j].emplace_back(i, v);\n\t\t}\n\t\tint ret = 0;\n\t\trep(i, n) {\n\t\t\tif (used[i]) continue;\n\t\t\tif (G[i].size() != 1) continue;\n\t\t\td.clear();\n\t\t\tdfs(i, -1);\n\t\t\tint s = 0;\n\t\t\t//cout << \"$\"; for (auto&p : d) cout << \" \" << p; cout << endl;\n\t\t\t\n\t\t\tif (d.size() < km1)continue;\n\t\t\trep(i, km1) s += d[i];\n\t\t\tret = max(ret, s);\n\t\t\tfor (int i = km1; i < d.size(); ++i) {\n\t\t\t\ts -= d[i - km1];\n\t\t\t\ts += d[i];\n\t\t\t\tret = max(ret, s);\n\t\t\t}\n\t\t\t/*\n\t\t\trep(i, d.size() - km1 + 1) {\n\t\t\t\tint s = 0;\n\t\t\t\trep(j, km1) {\n\t\t\t\t\ts += d[i+j];\n\t\t\t\t}\n\t\t\t\tret = max(ret, s);\n\t\t\t\tcout << \"S : \" << s << endl;\n\t\t\t}\n\t\t\t*/\n\t\t}\n\t\trep(i, n) {\n\t\t\tif (used[i]) continue;\n\t\t\td.clear();\n\t\t\tdfs(i, -1, true);\n\t\t\t//cout << \">\"; for (auto&p : d) cout << \" \" << p; cout << endl;\n\n\t\t\tint s = 0;\n\t\t\tif (d.size() < k)continue;\n\t\t\tif (d.size() == k) {\n\t\t\t\tint s = 0;\n\t\t\t\tfor (auto&v : d) s += v;\n\t\t\t\tret = max(ret, s);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint ds = d.size();\n\t\t\trep(i, ds) d.push_back(d[i]);\n\t\t\trep(i, km1) s += d[i];\n\t\t\tret = max(ret, s);\n\n\t\t\t//cout << \"Ss : \" << s << endl;\n\t\t\tfor (int i = km1; i < d.size(); ++i) {\n\t\t\t\ts -= d[i - km1];\n\t\t\t\ts += d[i];\n\t\t\t\tret = max(ret, s);\n\t\t\t\t//cout << \"S : \" << s << endl;\n\t\t\t}\n\t\t}\n\n\t\t//cout << \"# \" << k * s*s * 6 << \" \" << ret << endl;\n\n\t\tif (ret == 0) {\n\t\t\tcout << -1 << endl;\n\t\t} else {\n\t\t\tcout << k * s*s * 6 - ret << endl;\n\t\t}\n\n\n\n\t}\n\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\ntypedef pair<int,int>P;\n\nint get(int ax,int ay,int az,int bx,int by,int bz,int len){\n  int res=0,x,y,z;\n  vector<P>X,Y,Z;\n  X.push_back(P(ax,ax+len));\n  X.push_back(P(bx,bx+len));\n  Y.push_back(P(ay,ay+len));\n  Y.push_back(P(by,by+len));\n  Z.push_back(P(az,az+len));\n  Z.push_back(P(bz,bz+len));\n  sort(X.begin(),X.end());\n  sort(Y.begin(),Y.end());\n  sort(Z.begin(),Z.end());\n  if(X[0].second<X[1].first)return 0;\n  if(Y[0].second<Y[1].first)return 0;\n  if(Z[0].second<Z[1].first)return 0;\n  x=X[0].second-X[1].first;\n  y=Y[0].second-Y[1].first;\n  z=Z[0].second-Z[1].first;\n  res+=x*y*2;\n  res+=z*y*2;\n  res+=x*z*2;\n  return res;\n}\n\nint n,k,s,a[2001][2001],ans;\nint x[2001],y[2001],z[2001];\nvector<int>v[2001];\nint root;\nbool used[2001];\n\nvoid dfs(int V,int d,int sum){\n  if(d==k){\n    if(k>2)sum+=a[root][V];\n    ans=max(ans,sum);\n    return;\n  }\n  used[V]=1;\n  r(i,v[V].size()){\n    int nxt=v[V][i];\n    if(used[nxt])continue;\n    dfs(nxt,d+1,sum+a[V][nxt]);\n  }\n  used[V]=0;\n}\n\nsigned main(){\n  while(cin>>n>>k>>s,n){\n    memset(a,0,sizeof(a));\n    r(i,n)cin>>x[i]>>y[i]>>z[i];\n    if(k==1){\n      cout<<s*s*6<<endl;\n      continue;\n    }\n    r(i,2001)v[i].clear();\n    for(int i=0;i<n;i++){\n      for(int j=i+1;j<n;j++){\n        int X=get(x[i],y[i],z[i],x[j],y[j],z[j],s);\n        if(!X)continue;\n        a[i][j]=a[j][i]=X;\n        v[i].push_back(j);\n        v[j].push_back(i);\n      }\n    }\n    ans=0;\n    r(i,n){\n      root=i;\n      memset(used,0,sizeof(used));\n      dfs(i,1,0);\n    }\n    if(ans)cout<<s*s*k*6-ans<<endl;\n    else cout<<-1<<endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <iomanip>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n#include <vector>\n#include <string>\n#include <queue>\n#include <deque>\n#include <list>\n#include <set>\n#include <unordered_set>\n#include <map>\n#include <unordered_map>\n#include <bitset>\n#include <random>\n#include <complex>\n#include <assert.h>\n\nusing namespace std;\ntypedef long long ll;\n// #define endl '\\n'\n\ntemplate<typename T>\ninline bool chmin(T& x, T a) {\n\tif (x >= a) { x = a; return true; }\n\treturn false;\n}\n\ntemplate<typename T>\ninline bool chmax(T& x, T a) {\n\tif (x <= a) { x = a; return true; }\n\treturn false;\n}\n\nll s;\n\nstruct point3D {\n\tll x, y, z;\n};\nbool cross(point3D& a, point3D& b) {\n\tll p = abs(a.x - b.x);\n\tll q = abs(a.y - b.y);\n\tll r = abs(a.z - b.z);\n\tif (max(p, max(q, r)) < s) {\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nll score(point3D& a, point3D& b) {\n\tll p = abs(a.x - b.x);\n\tll q = abs(a.y - b.y);\n\tll r = abs(a.z - b.z);\n\n\tp = s - p;\n\tq = s - q;\n\tr = s - r;\n\treturn (p * q + q * r + r * p) * 2;\n}\n\nint main() {\n\twhile(1) {\n\t\tint N, K; cin >> N >> K;\n\t\tcin >> s;\n\n\t\tif (N == 0) { break; }\n\n\t\tvector<point3D> v(N);\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tcin >> v[i].x >> v[i].y >> v[i].z;\n\t\t}\n\n\t\tll ans = -1000000;\n\n\t\tvector<vector<pair<int, ll>>> next(N);\n\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tfor (int j = 0; j < i; j++) {\n\t\t\t\tif (cross(v[i], v[j])) {\n\t\t\t\t\tll x = score(v[i], v[j]);\n\t\t\t\t\tnext[i].push_back({ j, x });\n\t\t\t\t\tnext[j].push_back({ i, x });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\n\t\tvector<bool> used(N, false);\n\t\tvector<bool> checked(N, false);\n\n\t\tfor (int _i = 0; _i < N; _i++) {\n\t\t\tif (used[_i] == false) {\n\t\t\t\tif (next[_i].size() == 0) {\n\t\t\t\t\tif (K == 1) { chmax(ans, 0LL); }\n\t\t\t\t\tused[_i] = true; continue;\n\t\t\t\t}\n\t\t\t\tint j, k;\n\t\t\t\tif (next[_i].size() == 1) {\n\t\t\t\t\tj = _i;\n\t\t\t\t\tk = next[_i][0].first;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tj = next[_i][0].first;\n\t\t\t\t\tk = _i;\n\t\t\t\t\tchecked[_i] = true;\n\t\t\t\t\twhile (1) {\n\t\t\t\t\t\tif (next[j].size() == 1) { break; }\n\t\t\t\t\t\tchecked[j] = true;\n\t\t\t\t\t\tif (next[j][0].first == k) {\n\t\t\t\t\t\t\tk = j;\n\t\t\t\t\t\t\tj = next[j][1].first;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tk = j;\n\t\t\t\t\t\t\tj = next[j][0].first;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (checked[j] == true) { break; }\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tvector<int> arr;\n\t\t\t\tarr.push_back(j);\n\t\t\t\t{\n\t\t\t\t\tint tmp = j;\n\t\t\t\t\tj = next[j][0].first;\n\t\t\t\t\tk = tmp;\n\t\t\t\t}\n\t\t\t\twhile (1) {\n\t\t\t\t\tarr.push_back(j); used[j] = true;\n\t\t\t\t\tif (next[j].size() == 1) { break; }\n\t\t\t\t\tint x;\n\t\t\t\t\tif (next[j][0].first == k) { x = next[j][1].first; }\n\t\t\t\t\telse { x = next[j][0].first; }\n\t\t\t\t\tif (x == arr[0]) { break; }\n\n\t\t\t\t\tk = j;\n\t\t\t\t\tj = x;\n\t\t\t\t}\n\n\t\t\t\tint n = arr.size();\n\t\t\t\tif (n < K) { continue; }\n\n\t\t\t\tif (next[arr[0]].size() == 1) {// straight\n\t\t\t\t\tll x = 0;\n\t\t\t\t\tfor (int i = 1; i < K; i++) {\n\t\t\t\t\t\tx += score(v[arr[i - 1]], v[arr[i]]);\n\t\t\t\t\t}\n\t\t\t\t\tll y = x;\n\t\t\t\t\tfor (int i = K; i < n; i++) {\n\t\t\t\t\t\ty += score(v[arr[i - 1]], v[arr[i]]) - score(v[arr[i - K + 1]], v[arr[i - K]]);\n\t\t\t\t\t\tchmax(x, y);\n\t\t\t\t\t}\n\t\t\t\t\tchmax(ans, x);\n\t\t\t\t}\n\t\t\t\telse if (n == K) {\n\t\t\t\t\tll x = 0;\n\t\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\t\tx += score(v[arr[i]], v[arr[(i + 1) % n]]);\n\t\t\t\t\t}\n\t\t\t\t\tchmax(ans, x);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tll x = 0;\n\t\t\t\t\tfor (int i = 1; i < K; i++) {\n\t\t\t\t\t\tx += score(v[arr[i - 1]], v[arr[i]]);\n\t\t\t\t\t}\n\t\t\t\t\tll y = x;\n\t\t\t\t\tfor (int i = K; i <= n + K; i++) {\n\t\t\t\t\t\ty += score(v[arr[(i - 1) % n]], v[arr[i % n]]) - score(v[arr[(i - K + 1) % n]], v[arr[(i - K) % n]]);\n\t\t\t\t\t\tchmax(x, y);\n\t\t\t\t\t}\n\t\t\t\t\tchmax(ans, x);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (ans < 0) {\n\t\t\tcout << -1 << endl; continue;\n\t\t}\n\t\tcout << (s * s * 6 * K) - ans << endl;\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <array>\n#include <cassert>\n#include <climits>\n#include <complex>\n#include <cstdio>\n#include <cstring>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <iterator>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <string>\n#include <tuple>\n#include <vector>\n\nusing namespace std;\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define ALL(x) (x).begin(), (x).end()\n\nint subcube(int len, int x0, int y0, int z0, int x1, int y1, int z1) {\n    int dx = x0 - x1, dy = y0 - y1, dz = z0 - z1;\n    int sx = max(min(len + dx, len - dx), 0);\n    int sy = max(min(len + dy, len - dy), 0);\n    int sz = max(min(len + dz, len - dz), 0);\n    return (sx * sy * sz == 0) ? 0 : 2 * (sx * sy + sy * sz + sz * sx);\n}\n\nint main(){\n    int n, k, s; \n    while(cin >> n >> k >> s, n != 0){\n    vector<int> xs(n), ys(n), zs(n);\n    REP(i, n) {\n        cin >> xs[i] >> ys[i] >> zs[i];\n    }\n\n    if (k == 1) cout << s * s * 6 * k << endl;\n    vector<vector<int>> subc(n, vector<int>(n));\n    REP(a, n) {\n        REP(b, n) {\n            if (a == b) {cout << \"--\\t\"; continue;}\n            subc[a][b] = subcube(s, xs[a], ys[a], zs[a], xs[b], ys[b], zs[b]);\n            cout << subc[a][b] << \"\\t\";\n        }\n        cout << endl;\n    }\n\n    vector<vector<int>> segs;\n    vector<int> used(n, false);\n\n    /// 4 8 12 16 20\n    REP(a, n){\n        if (used[a]) continue;\n        vector<int> seg;\n        int p = a; bool ok = true;\n        seg.push_back(p);\n        used[a] = true;\n        while(ok) {\n            ok = false;\n            REP(b, n) {\n                if (subc[p][b] > 0) {\n                    if (used[b]) continue;\n                    p = b;\n                    seg.push_back(p);\n                    used[b] = true;\n                    ok = true;\n                    break;\n                }\n            }\n        }\n        reverse(ALL(seg));\n        p = a;\n        ok = true;\n        while(ok) {\n            ok = false;\n            REP(b, n) {\n                cout << \"?\" << a << \"->\" << b << endl;\n                if (subc[p][b] > 0) {\n                    if (used[b]) continue;\n                    p = b;\n                    seg.push_back(p);\n                    used[b] = true;\n                    ok = true;\n                    break;\n                }\n            }\n        }\n        segs.push_back(seg);\n    }\n\n    int res = -1;\n    REP(i, segs.size()) {\n        const vector<int> seg(segs[i]);\n        \n        cout << \"# \"; REP(a, seg.size()) {\n            cout << seg[a] << \" \";\n        } cout << endl;\n        \n        const int l = seg.size();\n        if (l < k) { continue; }\n        if (l == k) {\n            int sum = 0;\n            if (l == 2) {\n                res = max(res, subc[seg[0]][seg[1]]);\n                continue;\n            }\n            REP(a, l) {\n                //cout << \"+=\" << seg[a] << \" \" << seg[(a+1)%l] << endl;\n                //cout << \"   : \" << subc[seg[a]][seg[(a+1)%l]] << endl;\n                sum += subc[seg[a]][seg[(a+1)%l]];\n            }\n            res = max(res, sum);\n            continue;\n        }\n        int sum = 0;\n        REP(a, k - 1) {\n            sum += subc[seg[a]][seg[a+1]];\n        }\n        REP(a, l) {\n            res = max(res, sum);\n            int ad = subc[seg[(a + k - 1) % l]][seg[(a + k) % l]];\n            if (ad == 0) break;\n            sum += ad;\n            sum -= subc[seg[(a % l)]][seg[(a + 1) % l]];\n        }\n    }\n\n    // cout << \"$\" << subc[0][1] << endl;\n    // cout << res << endl;\n    if (res < 0) cout << res << endl;\n    else cout << s * s * 6 * k - res << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <tuple>\nusing namespace std;\ntypedef pair<int,int> P;//to, cov\nvector<P> E[2000];\nbool used[2000];\n\nint n,k,s,S,ans;\n\nvoid dfs(int st, int v, int len, int sur){\n    used[v]=true;\n    // cout<<v<<' '<<len<<endl;\n    if(len==k) ans = min(ans,sur);\n    for(auto p:E[v]){\n        int to, cov;\n        tie(to,cov)=p;\n        if(to==st&&len==k&&k>2){\n            ans = min(ans, sur-cov);\n        }else if(len<k&&!used[to]){\n            dfs(st,to,len+1,sur+S-cov);\n        }\n    }\n    used[v]=false;\n}\n\nint main(){\n    while(cin>>n>>k>>s,n){\n        vector<int> X,Y,Z;\n        for(int i=0;i<2000;i++) E[i].clear();\n        S=s*s*6;\n        ans = 1000000000;\n        for(int i=0;i<n;i++){\n            int x,y,z;\n            cin>>x>>y>>z;\n            X.push_back(x);\n            Y.push_back(y);\n            Z.push_back(z);\n        }\n        if(k==1){\n            cout<<S<<endl;\n            continue;\n        }\n        for(int i=0;i<n;i++){\n            for(int j=i+1;j<n;j++){\n                int dx = abs(X[i]-X[j]);\n                int dy = abs(Y[i]-Y[j]);\n                int dz = abs(Z[i]-Z[j]);\n                if(dx<s&&dy<s&&dz<s){\n                    // cout<<i<<' '<<j<<':'<<dx<<' '<<dy<<' '<<dz<<endl;\n                    int cov=((s-dx)*(s-dy)+(s-dy)*(s-dz)+(s-dz)*(s-dx))*2;\n                    E[i].emplace_back(j,cov);\n                    E[j].emplace_back(i,cov);\n                }\n            }\n        }\n        for(int i=0;i<n;i++){\n            dfs(i,i,1,S);\n        }\n        if(ans==1000000000)ans=-1;\n        cout<<ans<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <cmath>\n#include <cstdlib>\n#include <map>\nusing namespace std;\n\nclass Point {\npublic:\n    int x, y, z;\n    Point(int x = 0, int y = 0, int z = 0) : x(x), y(y), z(z) {}\n};\n\nclass Cube {\npublic:\n    Point p;\n    int s;\n    int vx[4] = {0, 1, 1, 0}, vy[4] = {0, 0, 1, 1}, vz[2] = {0, 1};\n    Cube(Point p = Point(), int s = 0) : p(p), s(s) {}\n\n    bool isIn(const Cube &c) {\n        return ((abs(p.x - c.p.x) < s) && (abs(p.y - c.p.y) <= s) && (abs(p.z - c.p.z) <= s) &&\n                (abs(p.x - c.p.x) <= s) && (abs(p.y - c.p.y) < s) && (abs(p.z - c.p.z) <= s) &&\n                (abs(p.x - c.p.x) <= s) && (abs(p.y - c.p.y) <= s) && (abs(p.z - c.p.z) < s));\n    }\n\n    long long shareS(Cube &c) {\n        long long ret = 0;\n        Point a, b;\n        a = p; b = c.p;\n\n        if (a.x > b.x) swap(a.x, b.x);\n        if (a.y > b.y) swap(a.y, b.y);\n        if (a.z > b.z) swap(a.z, b.z);\n\n        ret += abs((a.x + s - b.x) * (a.z + s - b.z) * 2);\n        ret += abs((a.y + s - b.y) * (a.z + s - b.z) * 2);\n        ret += abs((a.x + s - b.x) * (a.y + s - b.y) * 2);\n        return ret;\n    }\n\n};\n\nint n, k, s, x, y, z;\nlong long ans;\nvector<Cube> c;\nvector<vector<int> > subg;\nvector<bool> used;\nvector<deque<int> > graph;\ndeque<int> que;\n\ninline void makegraph() {\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            if (c[i].isIn(c[j])) {\n                subg[j].push_back(i);\n                subg[i].push_back(j);\n            }\n        }\n    }\n}\n\n// make path\nvoid dfs(int v) {\n    used[v] = true;\n    int size_ = subg[v].size();\n    bool flag = false;\n\n    for (int i = 0; i < size_; ++i) {\n        if (!used[subg[v][i]]) {\n            dfs(subg[v][i]);\n            if (!flag) que.push_front(v);\n            flag = true;\n        }\n    }\n\n    if (!flag) que.push_front(v);\n}\n\n// is graph[graphid] cycle ?\ninline bool isCycle(int graphid) {\n    int size_ = graph[graphid].size();\n\n    // if all vertex's degree are two, this graph has closed path.\n    for (int i = 0; i < size_; ++i) {\n        if (subg[graph[graphid][i]].size() != 2) return false;\n    }\n\n    return true;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    while (cin >> n >> k >> s, n | k | s) {\n        c.resize(n);\n        subg.resize(n);\n        que.clear();\n        used.assign(n, false);\n        ans = int(1e15);\n\n        for (int i = 0; i < n; ++i) {\n            cin >> x >> y >> z;\n            c[i] = {Point(x, y, z), s};    \n        }\n\n        makegraph();\n\n        for (int i = 0; i < n; ++i) {\n            if (!used[i]) {\n                dfs(i);\n                graph.push_back(que);\n                que.clear();\n            }\n        }\n\n        int gsize = graph.size(), qsize, upper;\n        long long share;\n        bool isGraphCycle = false;\n\n        for (int i = 0; i < gsize; ++i) {\n            qsize = graph[i].size();\n            isGraphCycle = isCycle(i);\n            \n            if (isGraphCycle && qsize == k) {\n                upper = k;\n            }\n            else upper = k - 1;\n            \n\n            if (qsize < k) continue;\n\n            for (int j = 0; j < qsize; ++j) {\n                share = 0;\n                //cout << \"isGraphCycle \" << isGraphCycle << endl;\n                if (!isGraphCycle && j + k - 1 >= qsize) continue;\n\n                for (int l = 0; l < upper; ++l) {\n                    //cout << (j + l) % qsize << \", \" << (j + l + 1) % qsize << endl;\n                    share += c[graph[i][(j + l) % qsize]].shareS(c[graph[i][(j + l + 1) % qsize]]);\n                }\n\n                /*\n                if (isGraphCycle && qsize == k) {\n                    share += c[graph[i][j % qsize]].shareS(c[graph[i][(j + qsize - 1) % qsize]]);\n                }\n                */\n                \n\n                ans = min(ans, 6 * s * s * k - share);\n            }\n        }\n\n        if (n == 1) ans = 6 * s * s;\n        if (ans == int(1e15)) ans = -1;\n\n        cout << ans << endl;\n        //cout << endl;\n\n        c.clear();\n        graph.clear();\n        subg.clear();\n        used.clear();\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\nstruct UnionFind{\n  int n;\n  vector<int> r,p;\n  UnionFind(){}\n  UnionFind(int sz):n(sz),r(sz,1),p(sz,0){iota(p.begin(),p.end(),0);}\n  int find(int x){\n    return (x==p[x]?x:p[x]=find(p[x]));\n  }\n  bool same(int x,int y){\n    return find(x)==find(y);\n  }\n  void unite(int x,int y){\n    x=find(x);y=find(y);\n    if(x==y) return;\n    if(r[x]<r[y]) swap(x,y);\n    r[x]+=r[y];\n    p[y]=x;\n  }\n  int size(int x){\n    return r[find(x)];\n  }\n};\n\nstruct P {\n  int x, y, z;\n  P() {}\n  P(int x, int y, int z) : x(x), y(y), z(z) {}  \n};\n\nint N, K, S;\nvector<P> dat;\nUnionFind uf;\nvector<vector<int> > G;\n\nbool contains(P a, P b) {\n  return abs(a.x-b.x) <= S && abs(a.y-b.y) <= S && abs(a.z-b.z) <= S;  \n}\n\nint area(P a, P b) {\n  int dx = S-abs(a.x-b.x), dy = S-abs(a.y-b.y), dz = S-abs(a.z-b.z);\n  return (dx*dy + dy*dz + dz*dx) * 2;  \n}\n\nint calc(vector<int> g) {\n  int sum = 0;\n  int gs = g.size();  \n  if ( gs == K ) {    \n    for ( int i : g ) {\n      P a = dat[i];\n      for ( int j : G[i] ) {\n\tP b = dat[j];\n\tsum += area(a, b)/2;\t\n      }      \n    }\n    return sum;    \n  }\n  \n  bool is_cycle = true;  \n  vector<int> path;\n  {\n    int st = g[0];\n    for ( int i : g ) {\n      if ( G[i].size() == 1 ) {\n\tst = i;\n\tis_cycle = false;\t\n\tbreak;\t\n      }\n    }    \n    int pre = -1;\n    int v = st;\n    path = {st};    \n    while ( path.size() < gs ) {\t\n      for ( int i : G[v] ) {\n\tif ( i == st || i == pre ) continue;\t\n\tpath.push_back(i);\t  \n\tpre = v;\n\tv = i;\t\n\tbreak;\n      }\n    }\n  }\n\n  // for ( int i : path ) cout << i << \" \" << G[i].size() << endl;\n  // cout << endl;  \n  \n  vector<int> cum(g.size(), 0);\n  for ( int i = 0; i < gs-1; i++ ) {\n    cum[i+1] = area(dat[path[i]], dat[path[i+1]]);\n    if ( i ) cum[i+1] += cum[i];    \n  }\n\n  // for ( int i = 0; i < gs; i++ ) cout << cum[i] << \" \";\n  // cout << endl;  \n\n  sum = cum[K-1];  \n  // if ( is_cycle ) sum += area(dat[path[0]], dat[path[gs-1]]);\n  // cout << is_cycle << endl;  \n  for ( int i = 1; i < gs; i++ ) {\n    if ( is_cycle ) {\n      if ( i+K-1 > gs-1 ) {\n\tint tmp = cum[gs-1]-cum[i] + area(dat[path[0]], dat[path[gs-1]]);\n\ttmp += cum[i+K - gs - 1];\n\tsum = max(sum, tmp);\t\n      } else {\n\tsum = max(sum, cum[i+K-1]-cum[i]);\n      }      \n    } else {\n      if ( i+K-1 > gs-1 ) continue;\n      // cout << cum[i+K-1]-cum[i] << endl;      \n      sum = max(sum, cum[i+K-1]-cum[i]);      \n    }\n  }\n\n  return sum;\n}\n\nsigned main() {\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);  \n\n  while ( cin >> N >> K >> S, N ) {\n    dat = vector<P>(N);    \n    for ( int i = 0; i < N; i++ ) {\n      cin >> dat[i].x >> dat[i].y >> dat[i].z;      \n    }    \n\n    uf = UnionFind(N);\n    G = vector<vector<int> >(N);    \n    for ( int i = 0; i < N; i++ ) {\n      int cnt = 0;      \n      for ( int j = i+1; j < N; j++ ) {\n\tP a = dat[i], b = dat[j];\t\n\tif ( cnt == 2 ) break;\n\tif ( contains(a, b) || contains(b, a) ) {\n\t  uf.unite(i, j);\n\t  G[i].push_back(j);\n\t  G[j].push_back(i);\n\t}\t\n      }\t           \n    }\n\n    vector<vector<int> > gr(N);    \n    for ( int i = 0; i < N; i++ ) {\n      gr[uf.find(i)].push_back(i);      \n    }\n\n    // for ( auto i : gr ) cout << i.size() << endl;    \n\n    int ans = -1;    \n    for ( int i = 0; i < N; i++ ) {\n      if ( gr[i].size() < K ) continue;\n      ans = max(ans, calc(gr[i]));      \n    }\n    // cout << S*S*6*K << endl;    \n    if ( ans < 0 ) cout << ans << endl;\n    else cout << S*S*6*K - ans << endl;    \n  }  \n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 2001\nusing namespace std;\ntypedef pair<int,int> P;\nvector<int>G[N];\nint n,K,S;\nstruct point{int x,y,z;};\n\nint Area(){return S*S*6;}\nint sArea(point a,point b){\n  int x = min(a.x+S, b.x+S),X = max(a.x,b.x);\n  int y = min(a.y+S, b.y+S),Y = max(a.y,b.y);\n  int z = min(a.z+S, b.z+S),Z = max(a.z,b.z);\n  if(y < Y || x < X || z < Z) return 0;\n  int area=0;\n  area += 2*(x-X)*(y-Y);\n  area += 2*(y-Y)*(z-Z);\n  area += 2*(z-Z)*(x-X);\n  return area;\n}\n\nvector<point> A;\nint used[N];\nint dfs(int pos,int k,int start,int prev){\n  if(k == K) return prev==-1? 0:-sArea(A[pos],A[start]);\n  if(used[pos]++) return 1e9;\n\n  int res = 1e9;\n  for(int npos:G[pos]){\n    if(npos == prev)continue;\n    int area = Area() - sArea(A[pos],A[npos]);\n    res = min(res,area+dfs(npos,k+1,start,pos));\n  }\n  return res;\n}\nint main(){\n  while(1){\n    cin>>n>>K>>S;\n    if(!n&&!K&&!S)break;\n    A.resize(n);\n    for(int i=0;i<n;i++)cin>>A[i].x>>A[i].y>>A[i].z;\n\n    for(int i=0;i<n;i++) G[i].clear();\n    for(int i=0;i<n;i++)\n      for(int j=i+1;j<n;j++){\n\tif(!sArea(A[i],A[j]))continue;\n\tG[i].push_back(j);\n\tG[j].push_back(i);\n      }\n    int ans = 1e9;\n    for(int i=0;i<n;i++){\n      memset(used,0,sizeof(used));\n      ans = min(ans,Area()+dfs(i,1,i,-1));\n    }\n    if(ans == 1e9) ans = -1;\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cassert>\n\nusing namespace std;\nusing ll = long long;\nconstexpr ll INF = 1LL << 50;\nll s;\n\nstruct Cube {\n    ll x;\n    ll y;\n    ll z;\n};\nll connected(const Cube& c1, const Cube& c2)\n{\n    const ll x1 = c1.x;\n    const ll y1 = c1.y;\n    const ll z1 = c1.z;\n    for (int i = 0; i < 2; i++) {\n        const ll x2 = c2.x + i * s;\n        const ll dx = x2 - x1;\n        for (int j = 0; j < 2; j++) {\n            const ll y2 = c2.y + j * s;\n            const ll dy = y2 - y1;\n            for (int k = 0; k < 2; k++) {\n                const ll z2 = c2.z + k * s;\n                const ll dz = z2 - z1;\n                if (0 <= dx and dx <= s and 0 <= dy and dy <= s and 0 <= dz and dz <= s) {\n                    const ll lx = (i == 0) ? s - dx : dx;\n                    const ll ly = (j == 0) ? s - dy : dy;\n                    const ll lz = (k == 0) ? s - dz : dz;\n                    return (lx * ly + ly * lz + lz * lx) * 2;\n                }\n            }\n        }\n    }\n    return 0;\n}\n\nstruct Edge {\n    int from;\n    int to;\n    ll cost;\n};\nstruct Graph {\n    Graph(const int n)\n    {\n        edge.resize(n);\n    }\n    void addEdge(const int from, const int to, const ll cost)\n    {\n        edge[from].push_back(Edge{from, to, cost});\n        edge[to].push_back(Edge{to, from, cost});\n    }\n    vector<vector<Edge>> edge;\n};\n\nint getEdge(const Graph& g, const int s, vector<bool>& visited)\n{\n    visited[s] = true;\n    int child = 0;\n    for (const auto& e : g.edge[s]) {\n        if (not visited[e.to]) {\n            return getEdge(g, e.to, visited);\n        }\n    }\n    if (child == 0) {\n        return s;\n    }\n}\nstruct Chain {\n    bool ring = false;\n    vector<ll> edges;\n};\nostream& operator<<(ostream& os, const Chain& ch)\n{\n    os << \"Ring: \" << boolalpha << ch.ring << \"\\nEdge: {\";\n    for (int i = 0; i < ch.edges.size(); i++) {\n        if (i != 0) {\n            os << \",\";\n        }\n        os << ch.edges[i];\n    }\n    os << \"}\" << endl;\n}\nvoid dfs(const Graph& g, const int s, const int dep, vector<bool>& visited, Chain& chain)\n{\n    visited[s] = true;\n    for (const auto& e : g.edge[s]) {\n        if (e.to == dep and chain.edges.size() >= 2) {\n            if (not chain.ring) {\n                chain.edges.push_back(e.cost);\n                chain.ring = true;\n            }\n            return;\n        }\n        if (not visited[e.to]) {\n            chain.edges.push_back(e.cost);\n            dfs(g, e.to, dep, visited, chain);\n        }\n    }\n}\n\nint main()\n{\n    while (true) {\n        int n, k;\n        cin >> n >> k >> s;\n        if (n == 0 and k == 0 and s == 0) {\n            break;\n        }\n\n        const ll whole = 6 * s * s * k;\n        if (k == 1) {\n            cout << whole << endl;\n            continue;\n        }\n\n        vector<Cube> cube(n);\n        for (int i = 0; i < n; i++) {\n            cin >> cube[i].x >> cube[i].y >> cube[i].z;\n        }\n        Graph g(n);\n        int e = 0;\n        for (int i = 0; i < n - 1; i++) {\n            for (int j = i + 1; j < n; j++) {\n                const ll cost = connected(cube[i], cube[j]);\n                if (cost > 0) {\n                    e++;\n                    g.addEdge(i, j, cost);\n                }\n            }\n        }\n        assert(e <= n);\n        vector<bool> visited(n, false);\n        vector<Chain> chains;\n        for (int i = 0; i < n; i++) {\n            if (not visited[i]) {\n                vector<bool> visited2(n, false);\n                const int dep = getEdge(g, i, visited2);\n                Chain chain;\n                chain.ring = false;\n                dfs(g, dep, dep, visited, chain);\n                chains.push_back(chain);\n            }\n        }\n        ll mini = INF;\n        for (const auto chain : chains) {\n            const bool ring = chain.ring;\n            const vector<ll>& costs = chain.edges;\n            if (costs.size() < k) {\n                continue;\n            }\n            if (ring) {\n                ll sum = 0;\n                for (int i = 0; i < k - 1; i++) {\n                    sum += costs[i];\n                }\n                if (costs.size() == k) {\n                    sum += costs[k - 1];\n                    mini = min(mini, whole - sum);\n                } else {\n                    mini = min(mini, whole - sum);\n                    int head = 0;\n                    int tail = k - 1;\n                    for (int j = 0; j < costs.size(); j++, head++, tail++, tail = tail % costs.size()) {\n                        sum += (costs[tail] - costs[head]);\n                        mini = min(mini, whole - sum);\n                    }\n                }\n            } else {\n                ll sum = 0;\n                for (int i = 0; i < k - 1; i++) {\n                    sum += costs[i];\n                }\n                mini = min(mini, whole - sum);\n                int head = 0;\n                int tail = k - 1;\n                for (; tail < costs.size(); head++, tail++) {\n                    sum += (costs[tail] - costs[head]);\n                    mini = min(mini, whole - sum);\n                }\n            }\n        }\n        cout << ((mini == INF) ? -1 : mini) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cassert>\n\nusing namespace std;\nusing ll = long long;\nconstexpr ll INF = 1LL << 50;\nll s;\n\nstruct Cube {\n    ll x;\n    ll y;\n    ll z;\n};\nll connected(const Cube& c1, const Cube& c2)\n{\n    const ll dx = abs(c1.x - c2.x);\n    const ll dy = abs(c1.y - c2.y);\n    const ll dz = abs(c1.z - c2.z);\n    if (dx < s and dy < s and dz < s) {\n        return ((s - dx) * (s - dy) + (s - dy) * (s - dz) + (s - dz) * (s - dx)) * 2;\n    }\n    return 0;\n}\n\nstruct Edge {\n    int from;\n    int to;\n    ll cost;\n};\nstruct Graph {\n    Graph(const int n)\n    {\n        edge.resize(n);\n    }\n    void addEdge(const int from, const int to, const ll cost)\n    {\n        edge[from].push_back(Edge{from, to, cost});\n        edge[to].push_back(Edge{to, from, cost});\n    }\n    vector<vector<Edge>> edge;\n};\n\nint getEdge(const Graph& g, const int s, vector<bool>& visited)\n{\n    visited[s] = true;\n    int child = 0;\n    for (const auto& e : g.edge[s]) {\n        if (not visited[e.to]) {\n            return getEdge(g, e.to, visited);\n        }\n    }\n    if (child == 0) {\n        return s;\n    }\n}\nstruct Chain {\n    bool ring = false;\n    vector<ll> edges;\n};\nostream& operator<<(ostream& os, const Chain& ch)\n{\n    os << \"Ring: \" << boolalpha << ch.ring << \"\\nEdge: {\";\n    for (int i = 0; i < ch.edges.size(); i++) {\n        if (i != 0) {\n            os << \",\";\n        }\n        os << ch.edges[i];\n    }\n    os << \"}\" << endl;\n}\nvoid dfs(const Graph& g, const int s, const int dep, vector<bool>& visited, Chain& chain)\n{\n    visited[s] = true;\n    for (const auto& e : g.edge[s]) {\n        if (e.to == dep and chain.edges.size() >= 2) {\n            if (not chain.ring) {\n                chain.edges.push_back(e.cost);\n                chain.ring = true;\n            }\n            return;\n        }\n        if (not visited[e.to]) {\n            chain.edges.push_back(e.cost);\n            dfs(g, e.to, dep, visited, chain);\n        }\n    }\n}\n\nint main()\n{\n    while (true) {\n        int n, k;\n        cin >> n >> k >> s;\n        if (n == 0 and k == 0 and s == 0) {\n            break;\n        }\n\n        const ll whole = 6 * s * s * k;\n        if (k == 1) {\n            cout << whole << endl;\n            continue;\n        }\n\n        vector<Cube> cube(n);\n        for (int i = 0; i < n; i++) {\n            cin >> cube[i].x >> cube[i].y >> cube[i].z;\n        }\n        Graph g(n);\n        for (int i = 0; i < n - 1; i++) {\n            for (int j = i + 1; j < n; j++) {\n                const ll cost = connected(cube[i], cube[j]);\n                if (cost > 0) {\n                    g.addEdge(i, j, cost);\n                }\n            }\n        }\n        vector<bool> visited(n, false);\n        vector<Chain> chains;\n        for (int i = 0; i < n; i++) {\n            if (not visited[i]) {\n                vector<bool> visited2(n, false);\n                const int dep = getEdge(g, i, visited2);\n                Chain chain;\n                chain.ring = false;\n                dfs(g, dep, dep, visited, chain);\n                chains.push_back(chain);\n            }\n        }\n        ll mini = INF;\n        for (const auto chain : chains) {\n            const bool ring = chain.ring;\n            const vector<ll>& costs = chain.edges;\n            if (costs.size() < k) {\n                continue;\n            }\n            if (ring) {\n                ll sum = 0;\n                for (int i = 0; i < k - 1; i++) {\n                    sum += costs[i];\n                }\n                if (costs.size() == k) {\n                    sum += costs[k - 1];\n                    mini = min(mini, whole - sum);\n                } else {\n                    mini = min(mini, whole - sum);\n                    int head = 0;\n                    int tail = k - 1;\n                    for (int j = 0; j < costs.size(); j++, head++, tail++, tail = tail % costs.size()) {\n                        sum += (costs[tail] - costs[head]);\n                        mini = min(mini, whole - sum);\n                    }\n                }\n            } else {\n                ll sum = 0;\n                for (int i = 0; i < k - 1; i++) {\n                    sum += costs[i];\n                }\n                mini = min(mini, whole - sum);\n                int head = 0;\n                int tail = k - 1;\n                for (; tail < costs.size(); head++, tail++) {\n                    sum += (costs[tail] - costs[head]);\n                    mini = min(mini, whole - sum);\n                }\n            }\n        }\n        cout << ((mini == INF) ? -1 : mini) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\n\nstruct Cube {\n    Cube() = default;\n    Cube(ll x, ll y, ll z, ll size) : x{x}, y{y}, z{z}, size{size}\n    {\n    }\n\n    bool operator<(const Cube& c) const\n    {\n        return (x != c.x) ? (x < c.x) : (y != c.y) ? (y < c.y) : (z != c.z) ? (z < c.z) : true;\n    }\n    ll x;\n    ll y;\n    ll z;\n    ll size;\n};\n\nll intersection(const Cube& c1, const Cube& c2)\n{\n\n    ll x = min(c1.x, c2.x) - max(c1.x, c2.x) + c1.size;\n    if (x <= 0) {\n        return 0;\n    }\n    ll y = min(c1.y, c2.y) - max(c1.y, c2.y) + c1.size;\n    if (y <= 0) {\n        return 0;\n    }\n    ll z = min(c1.z, c2.z) - max(c1.z, c2.z) + c1.size;\n    if (z <= 0) {\n        return 0;\n    }\n    return 2 * ((x * y) + (y * z) + (z * x));\n}\n\nstruct Edge {\n    Edge() = default;\n    Edge(int f, int t, ll c) : from{f}, to{t}, cost{c}\n    {\n    }\n    int from;\n    int to;\n    ll cost;\n};\n\nstruct Graph {\n    Graph(int n)\n    {\n        edge.resize(n);\n    }\n    void addEdge(int from, int to, ll cost)\n    {\n        edge[to].push_back(Edge{to, from, cost});\n        edge[from].push_back(Edge{from, to, cost});\n    }\n    vector<vector<Edge>> edge;\n};\n\nvoid dfs(const Graph& g, vector<bool>& checked, int pos, int& num, bool& ring, int& representation)\n{\n    num++;\n    checked[pos] = true;\n    bool update = false;\n    for (const auto& e : g.edge[pos]) {\n        const int to = e.to;\n        if (not checked[to]) {\n            dfs(g, checked, to, num, ring, representation);\n            update = true;\n        }\n    }\n    if (not update) {\n        if (g.edge[pos].size() == 2) {\n            ring = true;\n        } else {\n            ring = false;\n        }\n        representation = pos;\n    }\n}\n\nint main()\n{\n\n    while (true) {\n        int n, k;\n        ll s;\n        cin >> n >> k >> s;\n        if (n == 0 and k == 0 and s == 0) {\n            break;\n        }\n        vector<Cube> cubes(n);\n        for (int i = 0; i < n; i++) {\n            ll x, y, z;\n            cin >> x >> y >> z;\n            cubes[i] = Cube{x, y, z, s};\n        }\n        Graph g{n};\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                ll inter = intersection(cubes[i], cubes[j]);\n                if (inter > 0) {\n                    g.addEdge(i, j, inter);\n                }\n            }\n        }\n\n        vector<bool> checked(n, false);\n        vector<pair<pair<int, int>, bool>> cc;\n        for (int i = 0; i < n; i++) {\n            if (not checked[i]) {\n                int num = 0;\n                bool ring = false;\n                int rep;\n                dfs(g, checked, i, num, ring, rep);\n                if (num >= k) {\n                    cc.push_back(make_pair(make_pair(rep, num), ring));\n                }\n            }\n        }\n\n        if (cc.empty()) {\n            cout << -1 << endl;\n            continue;\n        }\n\n        ll maxi = -1;\n        vector<bool> used_head(n, false);\n        vector<bool> used_tail(n, false);\n        for (const auto p : cc) {\n            int rep = p.first.first;\n            int num = p.first.second;\n            bool ring = p.second;\n            if (ring) {\n                int head = rep;\n                int tail = rep;\n                ll sum = 0;\n                for (int i = 0; i < k - 1; i++) {\n                    used_tail[tail] = true;\n                    for (const auto& e : g.edge[tail]) {\n                        if (not used_tail[e.to]) {\n                            tail = e.to;\n                            sum += e.cost;\n                            break;\n                        }\n                    }\n                }\n                if (k == num) {\n                    used_tail[head] = false;\n                    for (const auto& e : g.edge[tail]) {\n                        if (not used_tail[e.to]) {\n                            sum += e.cost;\n                            break;\n                        }\n                    }\n                    maxi = max(maxi, sum);\n                    continue;\n                }\n                maxi = max(maxi, sum);\n                for (int i = 0; i < num; i++) {\n                    used_head[head] = true;\n                    used_tail[tail] = true;\n                    for (const auto& e : g.edge[head]) {\n                        if (not used_head[e.to]) {\n                            head = e.to;\n                            sum -= e.cost;\n                            break;\n                        }\n                    }\n                    for (const auto& e : g.edge[tail]) {\n                        if (not used_tail[e.to]) {\n                            tail = e.to;\n                            sum += e.cost;\n                            break;\n                        }\n                    }\n                    maxi = max(maxi, sum);\n                }\n            } else {\n                int head = rep;\n                int tail = rep;\n                ll sum = 0;\n                for (int i = 0; i < k - 1; i++) {\n                    used_tail[tail] = false;\n                    for (const auto& e : g.edge[tail]) {\n                        if (not used_tail[e.to]) {\n                            tail = e.to;\n                            sum += e.cost;\n                            break;\n                        }\n                    }\n                }\n                maxi = max(maxi, sum);\n                for (int i = 0; i < num - k + 1; i++) {\n                    used_head[head] = true;\n                    used_tail[tail] = true;\n                    for (const auto& e : g.edge[head]) {\n                        if (not used_head[e.to]) {\n                            head = e.to;\n                            sum -= e.cost;\n                            break;\n                        }\n                    }\n                    for (const auto& e : g.edge[tail]) {\n                        if (not used_tail[e.to]) {\n                            tail = e.to;\n                            sum += e.cost;\n                            break;\n                        }\n                    }\n                    maxi = max(maxi, sum);\n                }\n            }\n        }\n        cout << (6 * s * s) * static_cast<ll>(k) - maxi << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <math.h>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <bitset>\n#include <algorithm>\nusing namespace std;\n\nstruct xyz_t {\n    int x;\n    int y;\n    int z;\n    double length;       //一乗\n};\n\nstruct first_t {\n    int sec;\n    long long w;\n};\n\nbool asc(const xyz_t& left,const xyz_t& right);\nint next(int p,int q);\nint root(int p);\nvoid unite(int p,int q);\nint same(int p,int q);\nvoid pr(vector<vector<int> > pri);\nvoid nnn();\n\nvector<xyz_t> a;\nvector<int> tree;\nvector<int> endd;\nvector<vector<int> > tree_f;\nvector<vector<int> > kaburi;\nvector<vector<int> > tree_r;\nvector<int> num;\nvector<int> flg;\nlong long ans;\nint n,k,s;\ndouble LE;\nlong long sum;\nint rr;\n\nint main(){\n  scanf (\"%d %d %d\",&n,&k,&s);\n  while(n){\n    ans=0;\n    LE=sqrt(s*s*3.0);\n    xyz_t aaa={0,0,0,0};\n    a.assign(n,aaa);\n    tree.assign(n,-1);\n    endd.assign(n,-1);\n    tree_f.assign(n,vector<int>(1,0));\n    kaburi.assign(n,vector<int>(n,0));\n    tree_r.assign(n,vector<int>(0,0));\n    num.assign(n,1);\n    flg.assign(n,0);\n    for(int t=0;t<n;t++){\n      scanf (\"%d %d %d\",&a[t].x,&a[t].y,&a[t].z);\n      a[t].length=sqrt(a[t].x*a[t].x*1.0+a[t].y*a[t].y*1.0+a[t].z*a[t].z*1.0);\n    }\n    sort(a.begin(),a.end(),asc);\n    for(int i=0;i<n;i++){\n      tree[i]=i;\n      endd[i]=i;\n    }\n\n    switch(k){\n      case 1:\n        printf(\"%d\\n\",s*s*6);\n        break;\n      case 3:\n        for(int t=0;t<n-1;++t){\n          for(int s=t+1;(a[s].length<a[t].length+LE&&s<n);++s){\n            int xx=next(a[t].x,a[s].x);\n            int yy=next(a[t].y,a[s].y);\n            int zz=next(a[t].z,a[s].z);\n            if(xx&&yy&&zz){\n              if(same(t,s)==0){\n                int ee;\n                int eee;\n                  if(tree[t]==t&&tree[s]==s){\n                    //printf(\"%d %d\\n\",endd[t],endd[s]);\n                    ee=num[tree[t]];\n                    eee=num[tree[s]];\n                    num[tree[t]]=0;\n                    num[tree[s]]=0;\n                    num[endd[t]]=ee+eee;\n                    tree[t]=endd[t];\n                    tree[endd[t]]=endd[t];\n                    endd[endd[t]]=endd[s];\n                    unite(s,t);\n                  }\n                  else if(tree[t]!=t&&tree[s]==s){\n                    num[tree[t]]=num[tree[t]]+num[s];\n                    num[tree[s]]=0;\n                    endd[tree[t]]=endd[s];\n                    unite(s,t);\n                    //printf(\"%d\\n\",tree[t]);\n                  }\n                  else if(tree[t]==t&&tree[s]!=s){\n                    num[tree[s]]=num[t]+num[tree[s]];\n                    num[tree[t]]=0;\n                    endd[tree[s]]=endd[t];\n                    unite(t,s);\n                    //printf(\"%d\\n\",tree[s]);\n                  }\n                  else if(tree[t]!=t&&tree[s]!=s){\n                    num[tree[t]]=num[tree[t]]+num[tree[s]];\n                    num[tree[s]]=0;\n                    endd[tree[t]]=tree[s];\n                    unite(s,t);\n                    //printf(\"%d %d %d %d\\n\",t,s,tree[t],endd[tree[t]]);\n                  }\n                kaburi[s][t]=xx*yy+yy*zz+zz*xx;\n                  kaburi[t][s]=kaburi[s][t];\n                  tree_r[t].push_back(s);\n                  tree_r[s].push_back(t);\n                  //printf(\"%d %d %d\\n\",kaburi[q].back());\n                  //printf(\"%d %d %d\\n\",xx,yy,zz);\n                }\n              else{\n                kaburi[s][t]=xx*yy+yy*zz+zz*xx;\n                kaburi[t][s]=kaburi[s][t];\n                tree_r[t].push_back(s);\n                tree_r[s].push_back(t);\n                flg[tree[t]]=1;\n              }\n            }\n          }\n        }\n        //pr(kaburi);\n        for(int t=0;t<n;++t){\n          sum=0;\n          if(num[t]>=k){\n            if(flg[t]==0){\n              int u=t;\n              int uu=t;\n              tree_f[t][0]=t;\n              for(int r=0;r<k-1;++r){\n                rr=0;\n                if(tree_r[u][rr]==uu){\n                  ++rr;\n                }\n                sum+=kaburi[u][tree_r[u][rr]];\n                tree_f[t].push_back(tree_r[u][rr]);\n                uu=u;\n                u=tree_r[u][rr];\n              }\n              for(int r=k-1;r<num[t]-1;++r){\n                rr=0;\n                if(tree_r[u][rr]==uu){\n                  ++rr;\n                }\n                tree_f[t].push_back(tree_r[u][rr]);\n                uu=u;\n                u=tree_r[u][rr];\n              }\n              if(ans<sum){\n                ans=sum;\n              }\n              for(int r=0;r+k<num[t];++r){\n                sum=sum-kaburi[tree_f[t][r]][tree_f[t][r+1]]+kaburi[tree_f[t][r+k-1]][tree_f[t][r+k]];\n                if(ans<sum){\n                  ans=sum;\n                }\n              }\n            }\n            else{\n              if(num[t]!=k){\n                int u=t;\n                int uu=t;\n                tree_f[t][0]=t;\n                for(int r=0;r<k-1;++r){\n                  rr=0;\n                  if(tree_r[u][rr]==uu){\n                    ++rr;\n                  }\n                  sum+=kaburi[u][tree_r[u][rr]];\n                  tree_f[t].push_back(tree_r[u][rr]);\n                  uu=u;\n                  u=tree_r[u][rr];\n                }\n                for(int r=k-1;r<num[t]*2;++r){\n                  rr=0;\n                  if(tree_r[u][rr]==uu){\n                    ++rr;\n                  }\n                  tree_f[t].push_back(tree_r[u][rr]);\n                  uu=u;\n                  u=tree_r[u][rr];\n                }\n                if(ans<sum){\n                  ans=sum;\n                }\n                for(int r=0;r<num[t];++r){\n                  sum=sum-kaburi[tree_f[t][r]][tree_f[t][r+1]]+kaburi[tree_f[t][r+k-1]][tree_f[t][r+k]];\n                  if(ans<sum){\n                    ans=sum;\n                  }\n                  //printf(\"%lld\\n\",sum);\n                }\n                //pr(tree_f);\n              }\n              else{\n                if(num[t]!=3){\n                  int u=t;\n                  int uu=t;\n                  tree_f[t][0]=t;\n                  for(int r=0;r<k;++r){\n                    rr=0;\n                    if(tree_r[u][rr]==uu){\n                      ++rr;\n                    }\n                    sum+=kaburi[u][tree_r[u][rr]];\n                    uu=u;\n                    u=tree_r[u][rr];\n                  }\n                  if(ans<sum){\n                    ans=sum;\n                  }\n                }\n                else{\n                  int u=t;\n                  int uu=t;\n                  tree_f[t][0]=t;\n                  for(int r=0;r<k;++r){\n                    rr=0;\n                    if(tree_r[u][rr]==uu){\n                      ++rr;\n                    }\n                    sum+=kaburi[u][tree_r[u][rr]];\n                    tree_f[t].push_back(tree_r[u][rr]);\n                    uu=u;\n                    u=tree_r[u][rr];\n                  }\n                  int xxx=s+min({a[tree_f[t][0]].x,a[tree_f[t][1]].x,a[tree_f[t][2]].x})-max({a[tree_f[t][0]].x,a[tree_f[t][1]].x,a[tree_f[t][2]].x});\n                  int yyy=s+min({a[tree_f[t][0]].y,a[tree_f[t][1]].y,a[tree_f[t][2]].y})-max({a[tree_f[t][0]].y,a[tree_f[t][1]].y,a[tree_f[t][2]].y});\n                  int zzz=s+min({a[tree_f[t][0]].z,a[tree_f[t][1]].z,a[tree_f[t][2]].z})-max({a[tree_f[t][0]].z,a[tree_f[t][1]].z,a[tree_f[t][2]].z});\n                  sum=sum-(xxx*yyy+yyy*zzz+zzz*xxx);\n                  if(ans<sum){\n                    ans=sum;\n                  }\n                }\n              }\n            }\n          }\n        }\n        if(ans==0){\n          printf(\"-1\\n\");\n        }\n        else{\n          printf(\"%lld\\n\",s*s*6*k-ans*2);\n        }\n        break;\n      default:\n        for(int t=0;t<n-1;++t){\n          for(int s=t+1;(a[s].length<a[t].length+LE&&s<n);++s){\n            int xx=next(a[t].x,a[s].x);\n            int yy=next(a[t].y,a[s].y);\n            int zz=next(a[t].z,a[s].z);\n            if(xx&&yy&&zz){\n              if(same(t,s)==0){\n                /*if(num[t]==1){\n                  ++num[tree[s]];\n                  num[t]=0;\n                  unite(t,s);\n                  endd[tree[s]]=t;\n                }\n                else if(num[s]==1){\n                  ++num[tree[t]];\n                  num[s]=0;\n                  unite(s,t);\n                  endd[tree[t]]=s;\n                }*/\n                int ee;\n                int eee;\n                  if(tree[t]==t&&tree[s]==s){\n                    //printf(\"%d %d\\n\",endd[t],endd[s]);\n                    ee=num[tree[t]];\n                    eee=num[tree[s]];\n                    num[tree[t]]=0;\n                    num[tree[s]]=0;\n                    num[endd[t]]=ee+eee;\n                    tree[t]=endd[t];\n                    tree[endd[t]]=endd[t];\n                    endd[endd[t]]=endd[s];\n                    unite(s,t);\n                  }\n                  else if(tree[t]!=t&&tree[s]==s){\n                    num[tree[t]]=num[tree[t]]+num[s];\n                    num[tree[s]]=0;\n                    endd[tree[t]]=endd[s];\n                    unite(s,t);\n                    //printf(\"%d\\n\",tree[t]);\n                  }\n                  else if(tree[t]==t&&tree[s]!=s){\n                    num[tree[s]]=num[t]+num[tree[s]];\n                    num[tree[t]]=0;\n                    endd[tree[s]]=endd[t];\n                    unite(t,s);\n                    //printf(\"%d\\n\",tree[s]);\n                  }\n                  else if(tree[t]!=t&&tree[s]!=s){\n                    num[tree[t]]=num[tree[t]]+num[tree[s]];\n                    num[tree[s]]=0;\n                    endd[tree[t]]=tree[s];\n                    unite(s,t);\n                    //printf(\"%d %d %d %d\\n\",t,s,tree[t],endd[tree[t]]);\n                  }\n                kaburi[s][t]=xx*yy+yy*zz+zz*xx;\n                kaburi[t][s]=kaburi[s][t];\n                tree_r[t].push_back(s);\n                tree_r[s].push_back(t);\n                //printf(\"%d %d %d\\n\",kaburi[q].back());\n                //printf(\"%d %d %d\\n\",xx,yy,zz);\n              }\n              else{\n                kaburi[s][t]=xx*yy+yy*zz+zz*xx;\n                kaburi[t][s]=kaburi[s][t];\n                flg[tree[t]]=1;\n                tree_r[t].push_back(s);\n                tree_r[s].push_back(t);\n              }\n              //nnn();\n            }\n          }\n        }\n        for(int t=0;t<n;++t){\n          root(t);\n        }\n        /*for(int t=0;t<n-1;++t){\n          printf(\"%d \",num[t]);\n        }\n        printf(\"%d\\n\",num[n-1]);\n        pr(tree_r);\n        printf(\"\\n\");\n        for(int t=0;t<n-1;++t){\n          printf(\"%d \",tree[t]);\n        }\n        printf(\"%d\\n\",tree[n-1]);\n        printf(\"\\n\");*/\n        //pr(kaburi);\n        //printf(\"\\n\");\n        //pr(tree_r);\n        for(int t=0;t<n;++t){\n          sum=0;\n          if(num[t]>=k){\n            //printf(\"%d\\n\",flg[t]);\n            //printf(\"%d\\n\",t);\n            if(flg[t]==0){\n              int u=t;\n              int uu=t;\n              tree_f[t][0]=t;\n              for(int r=0;r<k-1;++r){//k-1\n                rr=0;\n                if(tree_r[u][rr]==uu){\n                  ++rr;\n                }\n                sum+=kaburi[u][tree_r[u][rr]];\n                tree_f[t].push_back(tree_r[u][rr]);\n                uu=u;\n                u=tree_r[u][rr];\n              }\n\n              /*for(int t=0;t<1;++t){\n                printf(\"%d \",tree_r[u][t]);\n              }\n              printf(\"%d\\n\",tree_r[u][1]);\n              printf(\"%d\\n\",t);*/\n              for(int r=k-1;r<num[t]-1;++r){\n                rr=0;\n                if(tree_r[u][rr]==uu){\n                  ++rr;\n                }\n                tree_f[t].push_back(tree_r[u][rr]);\n                uu=u;\n                u=tree_r[u][rr];\n              }\n              if(ans<sum){\n                ans=sum;\n              }\n              //printf(\"%lld\\n\",sum);\n              for(int r=0;r+k<num[t];++r){\n                sum=sum-kaburi[tree_f[t][r]][tree_f[t][r+1]]+kaburi[tree_f[t][r+k-1]][tree_f[t][r+k]];\n                //printf(\"%lld\\n\",sum);\n                if(ans<sum){\n                  ans=sum;\n                }\n              }\n            }\n            else{\n              if(num[t]!=k||k==2){\n                int u=t;\n                int uu=t;\n                tree_f[t][0]=t;\n                for(int r=0;r<k-1;++r){\n                  rr=0;\n                  if(tree_r[u][rr]==uu){\n                    ++rr;\n                  }\n                  sum+=kaburi[u][tree_r[u][rr]];\n                  tree_f[t].push_back(tree_r[u][rr]);\n                  uu=u;\n                  u=tree_r[u][rr];\n                }\n                for(int r=k-1;r<num[t]*2;++r){\n                  rr=0;\n                  if(tree_r[u][rr]==uu){\n                    ++rr;\n                  }\n                  tree_f[t].push_back(tree_r[u][rr]);\n                  uu=u;\n                  u=tree_r[u][rr];\n                }\n                if(ans<sum){\n                  ans=sum;\n                }\n                for(int r=0;r<num[t];++r){\n                  sum=sum-kaburi[tree_f[t][r]][tree_f[t][r+1]]+kaburi[tree_f[t][r+k-1]][tree_f[t][r+k]];\n                  if(ans<sum){\n                    ans=sum;\n                  }\n                  //printf(\"%lld\\n\",sum);\n                }\n                //pr(tree_f);\n              }\n              else{\n                int u=t;\n                int uu=t;\n                tree_f[t][0]=t;\n                for(int r=0;r<k;++r){\n                  rr=0;\n                  if(tree_r[u][rr]==uu){\n                    ++rr;\n                  }\n                  sum+=kaburi[u][tree_r[u][rr]];\n                  uu=u;\n                  u=tree_r[u][rr];\n                  //printf(\"%lld\\n\",sum);\n                }\n                if(ans<sum){\n                  ans=sum;\n                }\n              }\n            }\n          }\n        }\n        if(ans==0){\n          printf(\"-1\\n\");\n        }\n        else{\n          printf(\"%lld\\n\",s*s*6*k-ans*2);\n        }\n    }\n    scanf (\"%d %d %d\",&n,&k,&s);\n  }\n}\n/*\n環状 k=3の時 それ以外の時\n\n\n*/\n\n\nbool asc(const xyz_t& left,const xyz_t& right){\n  return left.length<right.length;\n}\n\nint next(int p,int q){\n  if(-s<=(p-q)&&(p-q)<=s){\n    if((p-q)>=0){\n      return s-(p-q);\n    }\n    else{\n      return s-(q-p);\n    }\n  }\n  else{\n    return 0;\n  }\n}\n\nint root(int p){\n  if (tree[p] == p){// 根\n    return p;\n  }\n  else {\n    return tree[p] = root(tree[p]); // 経路圧縮\n  }\n}\n\nvoid unite(int p, int q){\n  p = root(p);\n  q = root(q);\n  if (p == q){}\n  else{\n    tree[p] = q;     //pの親をqの親にする\n  }\n}\n\nint same(int p, int q){\n  return root(p) == root(q);\n}\n\n\n\nvoid pr(vector<vector<int> > pri){\n  for(int t=0;t<int(pri.size());++t){\n    for(int s=0;s<int(pri[t].size())-1;++s){\n      pri#include <stdio.h>\n#include <math.h>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <bitset>\n#include <algorithm>\nusing namespace std;\n\nstruct xyz_t {\n    int x;\n    int y;\n    int z;\n    double length;       //一乗\n};\n\nstruct first_t {\n    int sec;\n    long long w;\n};\n\nbool asc(const xyz_t& left,const xyz_t& right);\nint next(int p,int q);\nint root(int p);\nvoid unite(int p,int q);\nint same(int p,int q);\nvoid pr(vector<vector<int> > pri);\nvoid nnn();\n\nvector<xyz_t> a;\nvector<int> tree;\nvector<int> endd;\nvector<vector<int> > tree_f;\nvector<vector<int> > kaburi;\nvector<vector<int> > tree_r;\nvector<int> num;\nvector<int> flg;\nlong long ans;\nint n,k,s;\ndouble LE;\nlong long sum;\nint rr;\n\nint main(){\n  scanf (\"%d %d %d\",&n,&k,&s);\n  while(n){\n    ans=0;\n    LE=sqrt(s*s*3.0);\n    xyz_t aaa={0,0,0,0};\n    a.assign(n,aaa);\n    tree.assign(n,-1);\n    endd.assign(n,-1);\n    tree_f.assign(n,vector<int>(1,0));\n    kaburi.assign(n,vector<int>(n,0));\n    tree_r.assign(n,vector<int>(0,0));\n    num.assign(n,1);\n    flg.assign(n,0);\n    for(int t=0;t<n;t++){\n      scanf (\"%d %d %d\",&a[t].x,&a[t].y,&a[t].z);\n      a[t].length=sqrt(a[t].x*a[t].x*1.0+a[t].y*a[t].y*1.0+a[t].z*a[t].z*1.0);\n    }\n    sort(a.begin(),a.end(),asc);\n    for(int i=0;i<n;i++){\n      tree[i]=i;\n      endd[i]=i;\n    }\n\n    switch(k){\n      case 1:\n        printf(\"%d\\n\",s*s*6);\n        break;\n      case 3:\n        for(int t=0;t<n-1;++t){\n          for(int s=t+1;(a[s].length<a[t].length+LE&&s<n);++s){\n            int xx=next(a[t].x,a[s].x);\n            int yy=next(a[t].y,a[s].y);\n            int zz=next(a[t].z,a[s].z);\n            if(xx&&yy&&zz){\n              if(same(t,s)==0){\n                int ee;\n                int eee;\n                  if(tree[t]==t&&tree[s]==s){\n                    //printf(\"%d %d\\n\",endd[t],endd[s]);\n                    ee=num[tree[t]];\n                    eee=num[tree[s]];\n                    num[tree[t]]=0;\n                    num[tree[s]]=0;\n                    num[endd[t]]=ee+eee;\n                    tree[t]=endd[t];\n                    tree[endd[t]]=endd[t];\n                    endd[endd[t]]=endd[s];\n                    unite(s,t);\n                  }\n                  else if(tree[t]!=t&&tree[s]==s){\n                    num[tree[t]]=num[tree[t]]+num[s];\n                    num[tree[s]]=0;\n                    endd[tree[t]]=endd[s];\n                    unite(s,t);\n                    //printf(\"%d\\n\",tree[t]);\n                  }\n                  else if(tree[t]==t&&tree[s]!=s){\n                    num[tree[s]]=num[t]+num[tree[s]];\n                    num[tree[t]]=0;\n                    endd[tree[s]]=endd[t];\n                    unite(t,s);\n                    //printf(\"%d\\n\",tree[s]);\n                  }\n                  else if(tree[t]!=t&&tree[s]!=s){\n                    num[tree[t]]=num[tree[t]]+num[tree[s]];\n                    num[tree[s]]=0;\n                    endd[tree[t]]=tree[s];\n                    unite(s,t);\n                    //printf(\"%d %d %d %d\\n\",t,s,tree[t],endd[tree[t]]);\n                  }\n                kaburi[s][t]=xx*yy+yy*zz+zz*xx;\n                  kaburi[t][s]=kaburi[s][t];\n                  tree_r[t].push_back(s);\n                  tree_r[s].push_back(t);\n                  //printf(\"%d %d %d\\n\",kaburi[q].back());\n                  //printf(\"%d %d %d\\n\",xx,yy,zz);\n                }\n              else{\n                kaburi[s][t]=xx*yy+yy*zz+zz*xx;\n                kaburi[t][s]=kaburi[s][t];\n                tree_r[t].push_back(s);\n                tree_r[s].push_back(t);\n                flg[tree[t]]=1;\n              }\n            }\n          }\n        }\n        //pr(kaburi);\n        for(int t=0;t<n;++t){\n          sum=0;\n          if(num[t]>=k){\n            if(flg[t]==0){\n              int u=t;\n              int uu=t;\n              tree_f[t][0]=t;\n              for(int r=0;r<k-1;++r){\n                rr=0;\n                if(tree_r[u][rr]==uu){\n                  ++rr;\n                }\n                sum+=kaburi[u][tree_r[u][rr]];\n                tree_f[t].push_back(tree_r[u][rr]);\n                uu=u;\n                u=tree_r[u][rr];\n              }\n              for(int r=k-1;r<num[t]-1;++r){\n                rr=0;\n                if(tree_r[u][rr]==uu){\n                  ++rr;\n                }\n                tree_f[t].push_back(tree_r[u][rr]);\n                uu=u;\n                u=tree_r[u][rr];\n              }\n              if(ans<sum){\n                ans=sum;\n              }\n              for(int r=0;r+k<num[t];++r){\n                sum=sum-kaburi[tree_f[t][r]][tree_f[t][r+1]]+kaburi[tree_f[t][r+k-1]][tree_f[t][r+k]];\n                if(ans<sum){\n                  ans=sum;\n                }\n              }\n            }\n            else{\n              if(num[t]!=k){\n                int u=t;\n                int uu=t;\n                tree_f[t][0]=t;\n                for(int r=0;r<k-1;++r){\n                  rr=0;\n                  if(tree_r[u][rr]==uu){\n                    ++rr;\n                  }\n                  sum+=kaburi[u][tree_r[u][rr]];\n                  tree_f[t].push_back(tree_r[u][rr]);\n                  uu=u;\n                  u=tree_r[u][rr];\n                }\n                for(int r=k-1;r<num[t]*2;++r){\n                  rr=0;\n                  if(tree_r[u][rr]==uu){\n                    ++rr;\n                  }\n                  tree_f[t].push_back(tree_r[u][rr]);\n                  uu=u;\n                  u=tree_r[u][rr];\n                }\n                if(ans<sum){\n                  ans=sum;\n                }\n                for(int r=0;r<num[t];++r){\n                  sum=sum-kaburi[tree_f[t][r]][tree_f[t][r+1]]+kaburi[tree_f[t][r+k-1]][tree_f[t][r+k]];\n                  if(ans<sum){\n                    ans=sum;\n                  }\n                  //printf(\"%lld\\n\",sum);\n                }\n                //pr(tree_f);\n              }\n              else{\n                if(num[t]!=3){\n                  int u=t;\n                  int uu=t;\n                  tree_f[t][0]=t;\n                  for(int r=0;r<k;++r){\n                    rr=0;\n                    if(tree_r[u][rr]==uu){\n                      ++rr;\n                    }\n                    sum+=kaburi[u][tree_r[u][rr]];\n                    uu=u;\n                    u=tree_r[u][rr];\n                  }\n                  if(ans<sum){\n                    ans=sum;\n                  }\n                }\n                else{\n                  int u=t;\n                  int uu=t;\n                  tree_f[t][0]=t;\n                  for(int r=0;r<k;++r){\n                    rr=0;\n                    if(tree_r[u][rr]==uu){\n                      ++rr;\n                    }\n                    sum+=kaburi[u][tree_r[u][rr]];\n                    tree_f[t].push_back(tree_r[u][rr]);\n                    uu=u;\n                    u=tree_r[u][rr];\n                  }\n                  int xxx=s+min({a[tree_f[t][0]].x,a[tree_f[t][1]].x,a[tree_f[t][2]].x})-max({a[tree_f[t][0]].x,a[tree_f[t][1]].x,a[tree_f[t][2]].x});\n                  int yyy=s+min({a[tree_f[t][0]].y,a[tree_f[t][1]].y,a[tree_f[t][2]].y})-max({a[tree_f[t][0]].y,a[tree_f[t][1]].y,a[tree_f[t][2]].y});\n                  int zzz=s+min({a[tree_f[t][0]].z,a[tree_f[t][1]].z,a[tree_f[t][2]].z})-max({a[tree_f[t][0]].z,a[tree_f[t][1]].z,a[tree_f[t][2]].z});\n                  sum=sum-(xxx*yyy+yyy*zzz+zzz*xxx);\n                  if(ans<sum){\n                    ans=sum;\n                  }\n                }\n              }\n            }\n          }\n        }\n        if(ans==0){\n          printf(\"-1\\n\");\n        }\n        else{\n          printf(\"%lld\\n\",s*s*6*k-ans*2);\n        }\n        break;\n      default:\n        for(int t=0;t<n-1;++t){\n          for(int s=t+1;(a[s].length<a[t].length+LE&&s<n);++s){\n            int xx=next(a[t].x,a[s].x);\n            int yy=next(a[t].y,a[s].y);\n            int zz=next(a[t].z,a[s].z);\n            if(xx&&yy&&zz){\n              if(same(t,s)==0){\n                int ee;\n                int eee;\n                if(tree[t]==t&&tree[s]==s){\n                  //printf(\"%d %d\\n\",endd[t],endd[s]);\n                  ee=num[tree[t]];\n                  eee=num[tree[s]];\n                  num[tree[t]]=0;\n                  num[tree[s]]=0;\n                  num[endd[t]]=ee+eee;\n                  tree[t]=endd[t];\n                  tree[endd[t]]=endd[t];\n                  endd[endd[t]]=endd[s];\n                  unite(s,t);\n                }\n                else if(tree[t]!=t&&tree[s]==s){\n                  num[tree[t]]=num[tree[t]]+num[s];\n                  num[tree[s]]=0;\n                  endd[tree[t]]=endd[s];\n                  unite(s,t);\n                  //printf(\"%d\\n\",tree[t]);\n                }\n                else if(tree[t]==t&&tree[s]!=s){\n                  num[tree[s]]=num[t]+num[tree[s]];\n                  num[tree[t]]=0;\n                  endd[tree[s]]=endd[t];\n                  unite(t,s);\n                  //printf(\"%d\\n\",tree[s]);\n                }\n                else if(tree[t]!=t&&tree[s]!=s){\n                  num[tree[t]]=num[tree[t]]+num[tree[s]];\n                  num[tree[s]]=0;\n                  endd[tree[t]]=tree[s];\n                  unite(s,t);\n                  //printf(\"%d %d %d %d\\n\",t,s,tree[t],endd[tree[t]]);\n                }\n                kaburi[s][t]=xx*yy+yy*zz+zz*xx;\n                kaburi[t][s]=kaburi[s][t];\n                tree_r[t].push_back(s);\n                tree_r[s].push_back(t);\n                //printf(\"%d %d %d\\n\",kaburi[q].back());\n                //printf(\"%d %d %d\\n\",xx,yy,zz);\n              }\n              else{\n                kaburi[s][t]=xx*yy+yy*zz+zz*xx;\n                kaburi[t][s]=kaburi[s][t];\n                flg[tree[t]]=1;\n                tree_r[t].push_back(s);\n                tree_r[s].push_back(t);\n              }\n              //nnn();\n            }\n          }\n        }\n        for(int t=0;t<n;++t){\n          root(t);\n        }\n        for(int t=0;t<n;++t){\n          sum=0;\n          if(num[t]>=k){\n            if(flg[t]==0){\n              int u=t;\n              int uu=t;\n              tree_f[t][0]=t;\n              for(int r=0;r<k-1;++r){//k-1\n                rr=0;\n                if(tree_r[u][rr]==uu){\n                  ++rr;\n                }\n                sum+=kaburi[u][tree_r[u][rr]];\n                tree_f[t].push_back(tree_r[u][rr]);\n                uu=u;\n                u=tree_r[u][rr];\n              }\n              for(int r=k-1;r<num[t]-1;++r){\n                rr=0;\n                if(tree_r[u][rr]==uu){\n                  ++rr;\n                }\n                tree_f[t].push_back(tree_r[u][rr]);\n                uu=u;\n                u=tree_r[u][rr];\n              }\n              if(ans<sum){\n                ans=sum;\n              }\n              //printf(\"%lld\\n\",sum);\n              for(int r=0;r+k<num[t];++r){\n                sum=sum-kaburi[tree_f[t][r]][tree_f[t][r+1]]+kaburi[tree_f[t][r+k-1]][tree_f[t][r+k]];\n                //printf(\"%lld\\n\",sum);\n                if(ans<sum){\n                  ans=sum;\n                }\n              }\n            }\n            else{\n              if(num[t]!=k||k==2){\n                int u=t;\n                int uu=t;\n                tree_f[t][0]=t;\n                for(int r=0;r<k-1;++r){\n                  rr=0;\n                  if(tree_r[u][rr]==uu){\n                    ++rr;\n                  }\n                  sum+=kaburi[u][tree_r[u][rr]];\n                  tree_f[t].push_back(tree_r[u][rr]);\n                  uu=u;\n                  u=tree_r[u][rr];\n                }\n                for(int r=k-1;r<num[t]*2;++r){\n                  rr=0;\n                  if(tree_r[u][rr]==uu){\n                    ++rr;\n                  }\n                  tree_f[t].push_back(tree_r[u][rr]);\n                  uu=u;\n                  u=tree_r[u][rr];\n                }\n                if(ans<sum){\n                  ans=sum;\n                }\n                for(int r=0;r<num[t];++r){\n                  sum=sum-kaburi[tree_f[t][r]][tree_f[t][r+1]]+kaburi[tree_f[t][r+k-1]][tree_f[t][r+k]];\n                  if(ans<sum){\n                    ans=sum;\n                  }\n                  //printf(\"%lld\\n\",sum);\n                }\n                //pr(tree_f);\n              }\n              else{\n                int u=t;\n                int uu=t;\n                tree_f[t][0]=t;\n                for(int r=0;r<k;++r){\n                  rr=0;\n                  if(tree_r[u][rr]==uu){\n                    ++rr;\n                  }\n                  sum+=kaburi[u][tree_r[u][rr]];\n                  uu=u;\n                  u=tree_r[u][rr];\n                  //printf(\"%lld\\n\",sum);\n                }\n                if(ans<sum){\n                  ans=sum;\n                }\n              }\n            }\n          }\n        }\n        if(ans==0){\n          printf(\"-1\\n\");\n        }\n        else{\n          printf(\"%lld\\n\",s*s*6*k-ans*2);\n        }\n    }\n    scanf (\"%d %d %d\",&n,&k,&s);\n  }\n}\n/*\n環状 k=3の時 それ以外の時\n\n\n*/\n\n\nbool asc(const xyz_t& left,const xyz_t& right){\n  return left.length<right.length;\n}\n\nint next(int p,int q){\n  if(-s<=(p-q)&&(p-q)<=s){\n    if((p-q)>=0){\n      return s-(p-q);\n    }\n    else{\n      return s-(q-p);\n    }\n  }\n  else{\n    return 0;\n  }\n}\n\nint root(int p){\n  if (tree[p] == p){// 根\n    return p;\n  }\n  else {\n    return tree[p] = root(tree[p]); // 経路圧縮\n  }\n}\n\nvoid unite(int p, int q){\n  p = root(p);\n  q = root(q);\n  if (p == q){}\n  else{\n    tree[p] = q;     //pの親をqの親にする\n  }\n}\n\nint same(int p, int q){\n  return root(p) == root(q);\n}\n\n\n\nvoid pr(vector<vector<int> > pri){\n  for(int t=0;t<int(pri.size());++t){\n    for(int s=0;s<int(pri[t].size())-1;++s){\n      printf(\"%d \",pri[t][s]);\n    }\n    printf(\"%d\\n\",pri[t][pri[t].size()-1]);\n  }\n  printf(\"\\n\");\n}\n\nvoid nnn(){\n  for(int t=0;t<n-1;++t){\n    printf(\"%d \",num[t]);\n  }\n  printf(\"%d\\n\",num[n-1]);\n}\nntf(\"%d \",pri[t][s]);\n    }\n    printf(\"%d\\n\",pri[t][pri[t].size()-1]);\n  }\n  printf(\"\\n\");\n}\n\nvoid nnn(){\n  for(int t=0;t<n-1;++t){\n    printf(\"%d \",num[t]);\n  }\n  printf(\"%d\\n\",num[n-1]);\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define dbg(...) do{cerr<<__LINE__<<\": \";dbgprint(#__VA_ARGS__, __VA_ARGS__);}while(0);\n\nusing namespace std;\n\nnamespace std{template<class S,class T>struct hash<pair<S,T>>{size_t operator()(const pair<S,T>&p)const{return ((size_t)1e9+7)*hash<S>()(p.first)+hash<T>()(p.second);}};template<class T>struct hash<vector<T>>{size_t operator()(const vector<T> &v)const{size_t h=0;for(auto i : v)h=h*((size_t)1e9+7)+hash<T>()(i)+1;return h;}};}\ntemplate<class T>ostream& operator<<(ostream &os, const vector<T> &v){os<<\"[ \";rep(i,v.size())os<<v[i]<<(i==v.size()-1?\" ]\":\", \");return os;}template<class T>ostream& operator<<(ostream &os,const set<T> &v){os<<\"{ \"; for(const auto &i:v)os<<i<<\", \";return os<<\"}\";}\ntemplate<class T,class U>ostream& operator<<(ostream &os,const map<T,U> &v){os<<\"{\";for(const auto &i:v)os<<\" \"<<i.first<<\": \"<<i.second<<\",\";return os<<\"}\";}template<class T,class U>ostream& operator<<(ostream &os,const pair<T,U> &p){return os<<\"(\"<<p.first<<\", \"<<p.second<<\")\";}\nvoid dbgprint(const string &fmt){cerr<<endl;}template<class H,class... T>void dbgprint(const string &fmt,const H &h,const T&... r){cerr<<fmt.substr(0,fmt.find(\",\"))<<\"= \"<<h<<\" \";dbgprint(fmt.substr(fmt.find(\",\")+1),r...);}\ntypedef long long ll;typedef vector<int> vi;typedef pair<int,int> pi;const int inf = (int)1e9;const double INF = 1e12, EPS = 1e-9;\n\nint main(){\n\tcin.tie(0); cin.sync_with_stdio(0);\n\tint n, k, s;\n\twhile(cin >> n >> k >> s, n){\n\t\tvi x(n), y(n), z(n);\n\t\trep(i, n) cin >> x[i] >> y[i] >> z[i];\n\t\t\n\t\tauto intersect = [&](int i, int j){\n\t\t\tll dx = s - abs(x[i] - x[j]);\n\t\t\tll dy = s - abs(y[i] - y[j]);\n\t\t\tll dz = s - abs(z[i] - z[j]);\n\t\t\tif(dx <= 0 || dy <= 0 || dz <= 0) return 0ll;\n\t\t\treturn (dx * dy + dy * dz + dz * dx) * 2;\n\t\t};\n\t\t\n\t\tvector<vi> e(n);\n\t\trep(i, n) rep(j, i) if(intersect(i, j)){\n\t\t\te[i].pb(j);\n\t\t\te[j].pb(i);\n\t\t\t//dbg(i, j);\n\t\t}\n\t\t\n\t\tfunction<bool(int,int,vector<bool>&,vi&)> rec = [&](int c, int p, vector<bool> &v, vi &idx){\n\t\t\tv[c] = 1;\n\t\t\tidx.pb(c);\n\t\t\tfor(int i : e[c]) if(i != p){\n\t\t\t\tif(v[i]) return true;\n\t\t\t\treturn (bool)rec(i, c, v, idx); \n\t\t\t}\n\t\t\treturn false;\n\t\t};\n\t\t\n\t\tll ans = 1e18;\n\t\tvector<bool> v(n);\n\t\trep(ii, n) if(!v[ii]){\n\t\t\tvi idx;\n\t\t\tbool loop = rec(ii, ii, v, idx);\n\t\t\tif(idx.size() < k) continue;\n\t\t\t\n\t\t\tif(loop && idx.size() == k){\n\t\t\t\tll sum = 6ll * k * s * s;\n\t\t\t\trep(i, (int)idx.size()){\n\t\t\t\t\tll c = intersect(idx[i], idx[(i + 1) % idx.size()]);\n\t\t\t\t\tsum -= c;\n\t\t\t\t}\n\t\t\t\tans = min(ans, sum);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tvector<ll> costs;\n\t\t\t\tif(loop){\n\t\t\t\t\trep(i, (int)idx.size())\n\t\t\t\t\t\tcosts.pb(intersect(idx[i], idx[(i + 1) % idx.size()]));\n\t\t\t\t\tint it = idx.size();\n\t\t\t\t\trep(i, it) idx.pb(idx[i]);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tint hasi = 0;\n\t\t\t\t\trep(i, idx.size()) if(e[idx[i]].size() == 1) hasi = i;\n\t\t\t\t\trotate(idx.begin(), idx.begin() + hasi, idx.end());\n\t\t\t\t\tif(idx.size() > 2 && e[idx[1]].size() == 1)\n\t\t\t\t\t\trotate(idx.begin(), idx.begin() + 1, idx.end());\n\t\t\t\t\t\n\t\t\t\t\trep(i, idx.size()){\n\t\t\t\t\t\tif(i == 0 || i == idx.size() - 1) assert(e[idx[i]].size() <= 1);\n\t\t\t\t\t\telse assert(e[idx[i]].size() == 2);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\trep(i, idx.size() - 1)\n\t\t\t\t\t\tcosts.pb(intersect(idx[i], idx[i + 1]));\n\t\t\t\t}\n\t\t\t\t//dbg(k, costs);\n\t\t\t\t\n\t\t\t\tll sum = 6ll * k * s * s;\n\t\t\t\tif(k == 1){\n\t\t\t\t\tans = min(ans, sum);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\trep(i, k-2) sum -= costs[i];\n\t\t\t\trep(i, (int)costs.size() - (k-1) + 1){\n\t\t\t\t\tsum -= costs[i + k-2];\n\t\t\t\t\tans = min(ans, sum);\n\t\t\t\t\tsum += costs[i];\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tif(ans >= 1e18) ans = -1;\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF 1000000000000007LL\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,ll> P;\n\nint n,k,s;\nvector<P> G[101];\nbool flag[101];\nint x[101],y[101],z[101];\nint cnt=0;\nll sum=0;\n\nbool check(int i,int j){\n\tif(x[i]+s<=x[j] || x[j]+s<=x[i])return false;\n\tif(y[i]+s<=y[j] || y[j]+s<=y[i])return false;\n\tif(z[i]+s<=z[j] || z[j]+s<=z[i])return false;\n\treturn true;\n}\n\nvoid dfs(int v,int p){\n\tflag[v]=true;\n\tfor(int i=0;i<G[v].size();i++){\n\t\tif(G[v][i].first!=p){\n\t\t\tif(flag[G[v][i].first])sum-=(ll)G[v][i].second;\n\t\t\telse{\n\t\t\t\tif(cnt<k){\n\t\t\t\t\tsum+=(ll)6*s*s-G[v][i].second;\n\t\t\t\t\tcnt++;\n\t\t\t\t\tdfs(G[v][i].first,v);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d%d%d\",&n,&k,&s);\n\t\tif(n==0 && k==0 && s==0)return 0;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tG[i].clear();\n\t\t\tscanf(\"%d%d%d\",&x[i],&y[i],&z[i]);\n\t\t}\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=i+1;j<n;j++){\n\t\t\t\tif(check(i,j)){\n\t\t\t\t\tint v1=s-abs(x[i]-x[j]);\n\t\t\t\t\tint v2=s-abs(y[i]-y[j]);\n\t\t\t\t\tint v3=s-abs(z[i]-z[j]);\n\t\t\t\t\tll cost=2*(v1*v2+v2*v3+v3*v1);\n\t\t\t\t\tG[i].push_back(P(j,cost));\n\t\t\t\t\tG[j].push_back(P(i,cost));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tll res=INF;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tif(k==1){\n\t\t\t\tres=min(res,(ll)6*s*s);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor(int j=0;j<G[i].size();j++){\n\t\t\t\tmemset(flag,false,sizeof(flag));\n\t\t\t\tflag[i]=true;\n\t\t\t\tflag[G[i][j].first]=true;\n\t\t\t\tcnt=2;\n\t\t\t\tsum=12*s*s-G[i][j].second;\n\t\t\t\tdfs(G[i][j].first,i);\n\t\t\t\tif(cnt==k)res=min(res,sum);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%lld\\n\",res==INF?-1:res);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define dbg(...) do{cerr<<__LINE__<<\": \";dbgprint(#__VA_ARGS__, __VA_ARGS__);}while(0);\n\nusing namespace std;\n\nnamespace std{template<class S,class T>struct hash<pair<S,T>>{size_t operator()(const pair<S,T>&p)const{return ((size_t)1e9+7)*hash<S>()(p.first)+hash<T>()(p.second);}};template<class T>struct hash<vector<T>>{size_t operator()(const vector<T> &v)const{size_t h=0;for(auto i : v)h=h*((size_t)1e9+7)+hash<T>()(i)+1;return h;}};}\ntemplate<class T>ostream& operator<<(ostream &os, const vector<T> &v){os<<\"[ \";rep(i,v.size())os<<v[i]<<(i==v.size()-1?\" ]\":\", \");return os;}template<class T>ostream& operator<<(ostream &os,const set<T> &v){os<<\"{ \"; for(const auto &i:v)os<<i<<\", \";return os<<\"}\";}\ntemplate<class T,class U>ostream& operator<<(ostream &os,const map<T,U> &v){os<<\"{\";for(const auto &i:v)os<<\" \"<<i.first<<\": \"<<i.second<<\",\";return os<<\"}\";}template<class T,class U>ostream& operator<<(ostream &os,const pair<T,U> &p){return os<<\"(\"<<p.first<<\", \"<<p.second<<\")\";}\nvoid dbgprint(const string &fmt){cerr<<endl;}template<class H,class... T>void dbgprint(const string &fmt,const H &h,const T&... r){cerr<<fmt.substr(0,fmt.find(\",\"))<<\"= \"<<h<<\" \";dbgprint(fmt.substr(fmt.find(\",\")+1),r...);}\ntypedef long long ll;typedef vector<int> vi;typedef pair<int,int> pi;const int inf = (int)1e9;const double INF = 1e12, EPS = 1e-9;\n\nint main(){\n\tcin.tie(0); cin.sync_with_stdio(0);\n\tint n, k, s;\n\twhile(cin >> n >> k >> s, n){\n\t\tvi x(n), y(n), z(n);\n\t\trep(i, n) cin >> x[i] >> y[i] >> z[i];\n\t\t\n\t\tauto intersect = [&](int i, int j){\n\t\t\tll dx = s - abs(x[i] - x[j]);\n\t\t\tll dy = s - abs(y[i] - y[j]);\n\t\t\tll dz = s - abs(z[i] - z[j]);\n\t\t\tif(dx <= 0 || dy <= 0 || dz <= 0) return 0ll;\n\t\t\treturn (dx * dy + dy * dz + dz * dx) * 2;\n\t\t};\n\t\t\n\t\tvector<vi> e(n);\n\t\trep(i, n) rep(j, i) if(intersect(i, j)){\n\t\t\te[i].pb(j);\n\t\t\te[j].pb(i);\n\t\t\t//dbg(i, j);\n\t\t}\n\t\t\n\t\tfunction<bool(int,int,vector<bool>&,vi&)> rec = [&](int c, int p, vector<bool> &v, vi &idx){\n\t\t\tv[c] = 1;\n\t\t\tidx.pb(c);\n\t\t\tfor(int i : e[c]) if(i != p){\n\t\t\t\tif(v[i]) return true;\n\t\t\t\treturn (bool)rec(i, c, v, idx); \n\t\t\t}\n\t\t\treturn false;\n\t\t};\n\t\t\n\t\tll ans = 1e18;\n\t\tvector<bool> v(n);\n\t\trep(ii, n) if(!v[ii]){\n\t\t\tvi idx;\n\t\t\tbool loop = rec(ii, ii, v, idx);\n\t\t\tif(idx.size() < k) continue;\n\t\t\t\n\t\t\tif(loop && idx.size() == k){\n\t\t\t\tll sum = 6ll * k * s * s;\n\t\t\t\trep(i, (int)idx.size()){\n\t\t\t\t\tll c = intersect(idx[i], idx[(i + 1) % idx.size()]);\n\t\t\t\t\tsum -= c;\n\t\t\t\t}\n\t\t\t\tans = min(ans, sum);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tvector<ll> costs;\n\t\t\t\tif(loop){\n\t\t\t\t\trep(i, (int)idx.size())\n\t\t\t\t\t\tcosts.pb(intersect(idx[i], idx[(i + 1) % idx.size()]));\n\t\t\t\t\tint it = idx.size();\n\t\t\t\t\trep(i, it) idx.pb(idx[i]);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tint hasi = 0;\n\t\t\t\t\trep(i, idx.size()) if(e[idx[i]].size() == 1) hasi = idx[i];\n\t\t\t\t\tfor(int i : idx) v[i] = 0;\n\t\t\t\t\tidx.clear();\n\t\t\t\t\trec(hasi, hasi, v, idx);\n\t\t\t\t\t\n\t\t\t\t\trep(i, (int)idx.size()-1)\n\t\t\t\t\t\tcosts.pb(intersect(idx[i], idx[i + 1]));\n\t\t\t\t\t\n\t\t\t\t\trep(i, idx.size()){\n\t\t\t\t\t\t//if(i==0 || i==idx.size()-1) assert(e[idx[i]].size() <= 1);\n\t\t\t\t\t\t//else assert(e[idx[i]].size()==2);\n\t\t\t\t\t\tassert(e[idx[i]].size() <= 2);\n\t\t\t\t\t\t//assert(e[idx[i]].size() >= 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//dbg(k, costs);\n\t\t\t\t\n\t\t\t\tll sum = 6ll * k * s * s;\n\t\t\t\tif(k == 1){\n\t\t\t\t\tans = min(ans, sum);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\trep(i, k-2) sum -= costs[i];\n\t\t\t\trep(i, (int)costs.size() - (k-1) + 1){\n\t\t\t\t\tsum -= costs[i + k-2];\n\t\t\t\t\tans = min(ans, sum);\n\t\t\t\t\tsum += costs[i];\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tif(ans >= 1e18) ans = -1;\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;++i)\n\nint n,k,s;\nstruct Cube{\n\tint x,y,z;\n\tint node[2];\n\tint share;//with back cube\n\tint form;//-1:reseach now, 0:not visited, 1:line, 2:ring\n};\n\nvector<Cube> c;\nvector<int> graph;\n\n//return form\nint connect(int i,bool back){\n\t//it's found ring\n\tif(c[i].form == -1){\n\t\tgraph.push_back(i);\n\t\treturn 2;\n\t}\n\trep(j,n){\n\t\tif(i==j || c[j].form>0 || i==c[j].node[!back])continue;\n\t\tint sx = s-abs(c[i].x-c[j].x);\n\t\tint sy = s-abs(c[i].y-c[j].y);\n\t\tint sz = s-abs(c[i].z-c[j].z);\n\t\tif(sx<=0 || sy<=0 || sz<=0)continue;\n\t\t//connected\n\t\tc[i].node[!back] = j;\n\t\tc[j].node[back] = i;\n\t\tc[(back ? i : j)].share = 2*(sx*sy+sy*sz+sz*sx);\n\t\tc[i].form = -1;\n\t\tc[i].form = connect(j,back);\n\t\t//2:ring\n\t\tif(c[i].form==2)return 2;\n\t\t//1:line\n\t\tif(back)return 1;\n\t\tback=true;\n\t}\n\t//not found new connect\n\tif(back && c[i].node[0]==-1)graph.push_back(i);\n\treturn c[i].form = 1;\n}\n\nint main(){\n\twhile(cin>>n>>k>>s,n|k|s){\n\t\tc.clear();\n\t\tgraph.clear();\n\t\tint x,y,z;\n\t\trep(i,n){\n\t\t\tcin>>x>>y>>z;\n\t\t\tc.push_back(Cube{x,y,z,{-1,-1},0,0});\n\t\t}\n\t\trep(i,n)if(!c[i].form)connect(i,false);\n\t\tint maxsum = 0;\n\t\trep(i,(int)graph.size()){\n\t\t\tbool round = false;\n\t\t\tint tail = graph[i];\n\t\t\tint head = c[tail].node[1];\n\t\t\tint sum = 0, link = 0;\n\t\t\twhile(1){\n\t\t\t\tif(link+1==k)maxsum = max(sum,maxsum);\n\t\t\t\tif((round && tail==graph[i]) || head==-1)break;\n\t\t\t\tlink++;\n\t\t\t\tsum += c[head].share;\n\t\t\t\thead = c[head].node[1];\n\t\t\t\tround |= graph[i]==head;\n\t\t\t\t//(k or less)-ring\n\t\t\t\tif(round && link<k){\n\t\t\t\t\t//just k-ring\n\t\t\t\t\tif(link+1==k)maxsum = max(sum+c[head].share,maxsum);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(link == k){\n\t\t\t\t\ttail = c[tail].node[1];\n\t\t\t\t\tsum -= c[tail].share;\n\t\t\t\t\tlink--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<(maxsum||k==1 ? 6*s*s*k-maxsum : -1)<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\n#define int ll\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define PB push_back\n\nconst ll LLINF = (1LL<<60);\nconst int INF = (1LL<<30);\nconst int MOD = 1000000007;\n\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate <typename T> bool IN(T a, T b, T x) { return a<=x&&x<b; }\ntemplate<typename T> T ceil(T a, T b) { return a/b + !!(a%b); }\ntemplate<class S,class T>\nostream &operator <<(ostream& out,const pair<S,T>& a){\n  out<<'('<<a.first<<','<<a.second<<')';\n  return out;\n}\ntemplate<class T>\nostream &operator <<(ostream& out,const vector<T>& a){\n  out<<'[';\n  REP(i, a.size()) {out<<a[i];if(i!=a.size()-1)out<<',';}\n  out<<']';\n  return out;\n}\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\nvector<PII> g[2010];\nbool used[2010];\nint n, k, s, ans = -INF, st;\n\nint dfs(int x, int prev, int m, int cost) {\n  if(m == k) {\n    int tmp = 0;\n    for(auto e: g[x]) if(e.first == st) tmp = e.second;\n    if(3 <= k) cost += tmp;\n    chmax(ans, cost);\n    return cost;\n  }\n  int ans = INF;\n  for(auto e: g[x]) {\n    if(e.first == prev) continue;\n    chmax(ans, dfs(e.first, x, m+1, cost + e.second));\n  }\n  return ans;\n}\n\nsigned main(void)\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  while(true) {\n    cin >> n >> k >> s;\n    if(!n) break;\n    VI x(n), y(n), z(n);\n    REP(i, n) cin >> x[i] >> y[i] >> z[i];\n\n    REP(i, 2010) g[i].clear();\n    REP(i, n) FOR(j, i+1, n) {\n      // (i,j)が重複していたらその分の面積の重みの辺を張る\n      int dx = abs(x[i] - x[j]), dy = abs(y[i] - y[j]), dz = abs(z[i] - z[j]);\n      if(dx <= s && dy <= s && dz <= s) {\n        int cost = 2 * ((s-dx)*(s-dy) + (s-dy)*(s-dz) + (s-dz)*(s-dx));\n        g[i].PB({j, cost});\n        g[j].PB({i, cost});\n        // cout << i << \" \" << j << \" \" << cost << endl;\n      }\n    }\n\n    ans = -INF;\n    REP(i, n) {\n      // iからk個取る\n      memset(used, 0, sizeof(used));\n      st = i;\n      dfs(i, -1, 1, 0);\n    }\n\n    // cout << s*s*6*k << \" \" << ans << endl;\n    if(ans == -INF) cout << -1 << endl;\n    else cout << s*s*6*k - ans << endl;\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nconst int INF = 1e9;\nconst ll LINF = 1e18;\ntemplate<class S,class T> ostream& operator << (ostream& out,const pair<S,T>& o){ out << \"(\" << o.first << \",\" << o.second << \")\"; return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<T> V){ for(int i = 0; i < V.size(); i++){ out << V[i]; if(i!=V.size()-1) out << \" \";} return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<vector<T> > Mat){ for(int i = 0; i < Mat.size(); i++) { if(i != 0) out << endl; out << Mat[i];} return out; }\ntemplate<class S,class T> ostream& operator << (ostream& out,const map<S,T> mp){ out << \"{ \"; for(auto it = mp.begin(); it != mp.end(); it++){ out << it->first << \":\" << it->second; if(mp.size()-1 != distance(mp.begin(),it)) out << \", \"; } out << \" }\"; return out; }\n\n/*\n <url:>\n 問題文============================================================\n =================================================================\n 解説=============================================================\n ================================================================\n */\n\nint n,k,s;\nll area(ll x1,ll y1,ll z1,ll x2,ll y2,ll z2){\n    ll ret = -1;\n    ll dX = 0,dY = 0,dZ = 0;\n    if(x1 > x2) swap(x1,x2);\n    if(x1 <= x2 && x2 <= x1 + s){\n        dX = x1 + s - x2;\n    }else{\n        return ret;\n    }\n    if(y1 > y2) swap(y1,y2);\n    if(y1 <= y2 && y2 <= y1 + s){\n        dY = y1 + s - y2;\n    }else{\n        return ret;\n    }\n    if(z1 > z2) swap(z1,z2);\n    if(z1 <= z2 && z2 <= z1 + s){\n        dZ = z1 + s - z2;\n    }else{\n        return ret;\n    }\n  //  cout << dX << \" \" << dY << \" \" << dZ << endl;\n    ret = dX*dY*2 + dY*dZ*2 + dZ*dX*2;\n    return ret;\n}\n\nbool ok;\nvoid rec(ll n,int cnt,ll Sum,ll pre,vector<vector<pll>>& G,ll& ret,vector<int>& flag){\n  //  cout << n << \" \" << Sum << endl;\n    if(cnt == k){\n        ok = true;\n        ll maxV = 0;\n        for(auto next:G[n]){\n            if(next.first == pre) continue;\n            if(flag[next.first] == 1){\n                maxV = max(maxV,next.second);\n            }\n        }\n        ret = max(ret,Sum+maxV);\n        return;\n    }\n    for(auto next:G[n]){\n        if(flag[next.first] == 1) continue;\n        flag[next.first] = 1;\n        rec(next.first,cnt+1,Sum+next.second,n,G,ret,flag);\n        flag[next.first] = 0;\n    }\n}\nll solve(){\n    ll res = 0;\n    vector<ll> x(n),y(n),z(n);\n    for(int i = 0; i < n;i++) cin >> x[i] >> y[i] >> z[i];\n    res = s*s*6*k;\n    vector<vector<pll>> G(n);\n    for(int i = 0; i < n;i++){\n        for(int j = i + 1; j < n;j++){\n            ll Area = area(x[i],y[i],z[i],x[j],y[j],z[j]);\n            if(Area == -1) continue;\n          //  cout << i << \" -> \" << j << \" \" << Area << endl;\n            G[i].push_back({j,Area});\n            G[j].push_back({i,Area});\n        }\n    }\n    ll retMax = 0;\n    vector<int> flag(n,0);\n    ok = false;\n    for(int i = 0; i < n;i++){\n        flag[i] = 1;\n        rec(i,1,0,-1,G,retMax,flag);\n        flag[i] = 0;\n    }\n    if(ok == false) return -1;\n  //  cout << res << endl;\n   // cout << retMax << endl;\n    res -= retMax;\n    return res;\n}\nint main(void) {\n    cin.tie(0); ios_base::sync_with_stdio(false);\n    while(cin >> n >> k >> s,n){\n        cout << solve() << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 2005\nusing namespace std;\ntypedef pair<int,int> P;\n\nint n, k, s;\n\nint x[N], y[N], z[N];\nvector<int> G[N];\nvector<int> order;\nint edge[N][N];\n\nint find(int node){\n  \n  set<int> used;\n  \n  queue<int> q;\n\n  int res=node;\n\n  q.push(node);\n  \n  while(!q.empty()){\n    \n    int A=q.front(); q.pop();\n\n    if(used.count(A)) continue;\n\n    used.insert(A);\n\n    res=A;\n    \n    for(int i=0;i<G[A].size();i++){\n\n      int nA=G[A][i];\n\n      q.push(nA);\n      \n    }\n    \n  }\n  \n  return res;\n}\n\nint check(int A, int B){\n  \n  int X=min(x[A]+s,x[B]+s)-max(x[A],x[B]);\n  int Y=min(y[A]+s,y[B]+s)-max(y[A],y[B]);\n  int Z=min(z[A]+s,z[B]+s)-max(z[A],z[B]);\n  \n  if(X<=0||Y<=0||Z<=0) return 0;\n  \n  return X*Y*2+Y*Z*2+Z*X*2;\n}\n\nbool used[N];\n\nvoid dfs(int  node, int prev){\n\n  if(used[node]) return;\n  \n  used[node]=true;\n  \n  order.push_back(node);\n  \n  for(int i=0;i<G[node].size();i++){\n\n    int nnode=G[node][i];\n    \n    if(nnode==prev) continue;\n    \n    dfs(nnode, prev);\n    \n  }\n  \n}\n\nint main(){\n\n  while(1){\n  \n    cin>>n>>k>>s;\n    \n    if(!n&&!k&&!s) break;\n    \n    for(int i=0;i<n;i++) cin>>x[i]>>y[i]>>z[i];\n    \n    memset(edge,0,sizeof(edge));\n        \n    for(int i=0;i<n;i++)\n\n      for(int j=0;j<n;j++){\n      \n\tif(i==j) continue;\n\n\tint r=check(i,j);\n\t\n\tif(r>0){\n\t\n\t  G[i].push_back(j);\n\t  G[j].push_back(i);\n\n\t  edge[i][j]=edge[j][i]=r;\n\t  \n\t}\n      \n      }\n    \n    memset(used,0,sizeof(used));\n    \n    int ans=2e9;\n    \n    for(int i=0;i<n;i++){\n      \n      if(used[i]) continue;\n      \n      order.clear();\n      \n      dfs(find(i),find(i));\n      \n      int S=order.size();\n      \n      for(int j=0;j<S;j++){\n\t\n\tint sum=s*s*6*k;\n\t\n\tif(S<k) continue;\n\n\tint f=0;\n\t\n\tfor(int l=0;l<k-1;l++)\n\t  if(edge[order[(j+l)%S]][order[(j+l+1)%S]])\n\t    sum-=edge[order[(j+l)%S]][order[(j+l+1)%S]];\n\t  else f=1;\n\n\tif(f) continue;\n\t\n\tif(S>=3 && S==k && edge[order[j]][order[(j+k-1)%S]])\n\t  sum-=edge[order[j]][order[(j+k-1)%S]];\n\t\n\tans=min(ans, sum);\n\t\n      }\n    \n    }\n    \n    if(ans==2e9) ans=-1;\n\n    cout<<ans<<endl;\n\n    for(int i=0;i<n;i++) G[i].clear();\n    \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <tuple>\n\nusing namespace std;\n\nusing lint = long long;\nusing ldouble = long double;\n\nconst int INF = 1 << 30;\n\nstruct Point {\n    int x, y, z;\n};\n\nint N, K, S;\n\nint collision(Point a, Point b) {\n    if (max(a.x, b.x) - min(a.x, b.x) >= S ||\n        max(a.y, b.y) - min(a.y, b.y) >= S ||\n        max(a.z, b.z) - min(a.z, b.z) >= S) return 0;\n\n    int dx = min(a.x, b.x) + S - max(a.x, b.x),\n        dy = min(a.y, b.y) + S - max(a.y, b.y),\n        dz = min(a.z, b.z) + S - max(a.z, b.z);\n\n    return (dx * dy + dy * dz + dz * dx) * 2;\n}\n\nvector<vector<pair<int, int>>> graph;\nvector<bool> visited;\n\nint dfs(int v, int r, int K) {\n    if (K == 0) {\n        for (auto p : graph[v]) {\n            int sv, c;\n            tie(sv, c) = p;\n            if (sv == r) continue;\n            if (visited[sv]) return c;\n        }\n        return 0;\n    }\n\n    if (visited[v]) return -INF;\n\n    visited[v] = true;\n    int ret = -INF;\n    for (auto p : graph[v]) {\n        int sv, c;\n        tie(sv, c) = p;\n        if (sv == r) continue;\n        ret = max(ret, dfs(sv, v, K - 1) + c);\n    }\n    visited[v] = false;\n    return ret;\n}\n\nbool solve() {\n    cin >> N >> K >> S;\n    if (N == 0) return false;\n\n    vector<Point> cubes(N);\n    for (auto& c : cubes) cin >> c.x >> c.y >> c.z;\n\n    graph.clear();\n    graph.resize(N);\n    for (int u = 0; u < N; ++u) {\n        for (int v = 0; v < N; ++v) {\n            if (u == v) continue;\n            int elim = collision(cubes[u], cubes[v]);\n            if (elim > 0) graph[u].emplace_back(v, elim);\n        }\n    }\n\n    visited.assign(N, false);\n    int ans = -1;\n    for (int v = 0; v < N; ++v) {\n        ans = max(ans, dfs(v, -1, K - 1));\n    }\n    cout << (ans < 0 ? -1 : S * S * 6 * K - ans) << endl;\n    return true;\n}\n\nint main() {\n    while (solve()) {}\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <array>\n#include <cassert>\n#include <climits>\n#include <complex>\n#include <cstdio>\n#include <cstring>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <iterator>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <string>\n#include <tuple>\n#include <vector>\n\nusing namespace std;\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define ALL(x) (x).begin(), (x).end()\n\nint subcube(int len, int x0, int y0, int z0, int x1, int y1, int z1) {\n    int dx = x0 - x1, dy = y0 - y1, dz = z0 - z1;\n    int sx = max(min(len + dx, len - dx), 0);\n    int sy = max(min(len + dy, len - dy), 0);\n    int sz = max(min(len + dz, len - dz), 0);\n    return (sx * sy * sz == 0) ? 0 : 2 * (sx * sy + sy * sz + sz * sx);\n}\n\nint main(){\n    int n, k, s; \n    while(cin >> n >> k >> s, n != 0){\n    vector<int> xs(n), ys(n), zs(n);\n    REP(i, n) {\n        cin >> xs[i] >> ys[i] >> zs[i];\n    }\n\n    if (k == 1) cout << s * s * 6 * k << endl;\n    vector<vector<int>> subc(n, vector<int>(n));\n    REP(a, n) {\n        REP(b, n) {\n            if (a == b) {/*cout << \"--\\t\";*/ continue;}\n            subc[a][b] = subcube(s, xs[a], ys[a], zs[a], xs[b], ys[b], zs[b]);\n            //cout << subc[a][b] << \"\\t\";\n        }\n        cout << endl;\n    }\n\n    vector<vector<int>> segs;\n    vector<int> used(n, false);\n\n    /// 4 8 12 16 20\n    REP(a, n){\n        if (used[a]) continue;\n        vector<int> seg;\n        int p = a; bool ok = true;\n        seg.push_back(p);\n        used[a] = true;\n        while(ok) {\n            ok = false;\n            REP(b, n) {\n                if (subc[p][b] > 0) {\n                    if (used[b]) continue;\n                    p = b;\n                    seg.push_back(p);\n                    used[b] = true;\n                    ok = true;\n                    break;\n                }\n            }\n        }\n        reverse(ALL(seg));\n        p = a;\n        ok = true;\n        while(ok) {\n            ok = false;\n            REP(b, n) {\n                //cout << \"?\" << a << \"->\" << b << endl;\n                if (subc[p][b] > 0) {\n                    if (used[b]) continue;\n                    p = b;\n                    seg.push_back(p);\n                    used[b] = true;\n                    ok = true;\n                    break;\n                }\n            }\n        }\n        segs.push_back(seg);\n    }\n\n    int res = -1;\n    REP(i, segs.size()) {\n        const vector<int> seg(segs[i]);\n        \n        /*cout << \"# \"; REP(a, seg.size()) {\n            cout << seg[a] << \" \";\n        } cout << endl;*/\n        \n        const int l = seg.size();\n        if (l < k) { continue; }\n        if (l == k) {\n            int sum = 0;\n            if (l == 2) {\n                res = max(res, subc[seg[0]][seg[1]]);\n                continue;\n            }\n            REP(a, l) {\n                //cout << \"+=\" << seg[a] << \" \" << seg[(a+1)%l] << endl;\n                //cout << \"   : \" << subc[seg[a]][seg[(a+1)%l]] << endl;\n                sum += subc[seg[a]][seg[(a+1)%l]];\n            }\n            res = max(res, sum);\n            continue;\n        }\n        int sum = 0;\n        REP(a, k - 1) {\n            sum += subc[seg[a]][seg[a+1]];\n        }\n        REP(a, l) {\n            res = max(res, sum);\n            int ad = subc[seg[(a + k - 1) % l]][seg[(a + k) % l]];\n            if (ad == 0) break;\n            sum += ad;\n            sum -= subc[seg[(a % l)]][seg[(a + 1) % l]];\n        }\n    }\n\n    // cout << \"$\" << subc[0][1] << endl;\n    // cout << res << endl;\n    if (res < 0) cout << res << endl;\n    else cout << s * s * 6 * k - res << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nstruct Info{\n\tint x,y,z;\n};\n\nint N,K,S;\nint adj_num[2000],adj_index[2000][2],lost_S[2000][2000];\nint boss[2000],height[2000],group_min_adj[2000];\nbool used[2000];\nInfo info[2000];\n\n//自分のボスのindexを取得しつつ、経路圧縮を行う関数\nint get_boss(int id){\n\tif(boss[id] == id)return id; //自分が代表なら、自分の値を返す\n\telse{\n\t\treturn boss[id] = get_boss(boss[id]); //代表でないなら、自分が所属する組織の代表を返しつつ、経路圧縮\n\t}\n}\n\nvoid unite(int x,int y){\n\tint boss_x = get_boss(x);\n\tint boss_y = get_boss(y);\n\n\t//既に同じグループなら何もしない\n\tif(boss_x == boss_y)return;\n\n\t//高さが高い方に吸収する\n\tif(height[x] > height[y]){\n\n\t\tboss[boss_y] = boss_x;\n\n\t}else if(height[x] < height[y]){\n\n\t\tboss[boss_x] = boss_y;\n\n\t}else{ //height[x] == height[y]\n\n\t\tboss[boss_y] = boss_x;\n\t\theight[x]++;\n\t}\n}\n\n\nvoid func(){\n\n\tfor(int i = 0; i < N; i++){\n\t\tadj_num[i] = 0;\n\t}\n\n\tfor(int i = 0; i < N; i++){\n\t\tscanf(\"%d %d %d\",&info[i].x,&info[i].y,&info[i].z);\n\t}\n\n\tif(K == 1){\n\t\tprintf(\"%d\\n\",6*S*S);\n\t\treturn;\n\t}\n\n\tfor(int i = 0; i < N; i++){\n\t\tboss[i] = i;\n\t\theight[i] = 0;\n\t}\n\n\tint diff_x,diff_y,diff_z;\n\n\tfor(int i = 0; i < N-1; i++){\n\t\tfor(int k = i+1; k < N; k++){\n\n\t\t\tif(info[i].x+S <= info[k].x || info[k].x+S <= info[i].x)continue;\n\t\t\tif(info[i].y+S <= info[k].y || info[k].y+S <= info[i].y)continue;\n\t\t\tif(info[i].z+S <= info[k].z || info[k].z+S <= info[i].z)continue;\n\n\t\t\tunite(i,k);\n\n\t\t\tadj_index[i][adj_num[i]++] = k;\n\t\t\tadj_index[k][adj_num[k]++] = i;\n\n\t\t\tdiff_x = S-abs(info[i].x-info[k].x);\n\t\t\tdiff_y = S-abs(info[i].y-info[k].y);\n\t\t\tdiff_z = S-abs(info[i].z-info[k].z);\n\n\t\t\tlost_S[i][k] = lost_S[k][i] = 2*(diff_x*diff_y+diff_x*diff_z+diff_y*diff_z);\n\t\t}\n\t}\n\n\t//各連結グループ内の、最小連結数を求める(輪構造対策)\n\tfor(int i = 0; i < N; i++)group_min_adj[i] = BIG_NUM;\n\tint boss_id;\n\tfor(int i = 0; i < N; i++){\n\t\tboss_id = get_boss(i);\n\t\tgroup_min_adj[boss_id] = min(group_min_adj[boss_id],adj_num[i]);\n\t}\n\n\tint ans = BIG_NUM,tmp,last_cube,next_cube,remove_cube;\n\tqueue<int> Q;\n\n\tbool FLG;\n\n\tfor(int i = 0; i < N; i++){\n\t\tboss_id = get_boss(i);\n\t\tif((group_min_adj[boss_id] != 2 && adj_num[i] == 2))continue; //輪対策\n\n\t\twhile(!Q.empty())Q.pop();\n\t\tfor(int i = 0; i < N; i++)used[i] = false; //★★輪は重なりの都合で全探索が必要★★\n\n\t\t//孤立、または連結の端の立方体\n\t\ttmp = 6*S*S;\n\t\tused[i] = true;\n\t\tlast_cube = i;\n\t\tQ.push(i);\n\n\t\twhile(!Q.empty()){\n\t\t\tif(Q.size() == K){ //連がK個になった場合\n\n\t\t\t\tFLG = false; //★★ちょうどK個の輪ができる場合あり!!★★\n\n\t\t\t\tif(group_min_adj[boss_id] == 2 && K >= 3){ //輪の一部の場合\n\t\t\t\t\tfor(int k = 0; k < adj_num[last_cube]; k++){\n\t\t\t\t\t\tif(adj_index[last_cube][k] == Q.front()){\n\t\t\t\t\t\t\tFLG = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif(FLG){\n\t\t\t\t\tans = min(ans,tmp-lost_S[last_cube][Q.front()]);\n\t\t\t\t}else{\n\t\t\t\t\tans = min(ans,tmp);\n\t\t\t\t}\n\n\n\t\t\t\tnext_cube = -1;\n\t\t\t\tfor(int k = 0; k < adj_num[last_cube]; k++){\n\t\t\t\t\tif(used[adj_index[last_cube][k]])continue;\n\t\t\t\t\tnext_cube = adj_index[last_cube][k];\n\t\t\t\t}\n\t\t\t\tif(next_cube == -1)break;\n\t\t\t\tused[next_cube] = true;\n\n\t\t\t\t//一番古い立方体を削除\n\t\t\t\tremove_cube = Q.front();\n\t\t\t\tQ.pop();\n\n\t\t\t\ttmp += 6*S*S-lost_S[last_cube][next_cube];\n\t\t\t\ttmp -= 6*S*S-lost_S[remove_cube][Q.front()];\n\n\t\t\t\tlast_cube = next_cube;\n\t\t\t\tQ.push(last_cube);\n\n\t\t\t}else{\n\n\t\t\t\tnext_cube = -1;\n\t\t\t\tfor(int k = 0; k < adj_num[last_cube]; k++){\n\t\t\t\t\tif(used[adj_index[last_cube][k]])continue;\n\t\t\t\t\tnext_cube = adj_index[last_cube][k];\n\t\t\t\t}\n\t\t\t\tif(next_cube == -1)break;\n\t\t\t\tused[next_cube] = true;\n\n\t\t\t\ttmp += 6*S*S-lost_S[last_cube][next_cube];\n\n\t\t\t\tlast_cube = next_cube;\n\t\t\t\tQ.push(last_cube);\n\t\t\t}\n\t\t}\n\t}\n\n\tif(ans == BIG_NUM){\n\t\tprintf(\"-1\\n\");\n\t}else{\n\t\tprintf(\"%d\\n\",ans);\n\t}\n}\n\nint main(){\n\n\twhile(true){\n\t\tscanf(\"%d %d %d\",&N,&K,&S);\n\t\tif(N == 0 && K == 0 && S == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\nusing namespace std;\ntypedef long long ll;\nconst ll MOD = 1000000007;\nconst ll INF = (ll)1000000007 * 1000000007;\nconst double EPS = 1e-9;\ntypedef pair<int, int> P;\ntypedef unsigned int ui;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\nint n, k, s;\nstruct cube { int x, y, z; };\nint cap(cube a, cube b) {\n\tint da = s - abs(a.x - b.x);\n\tint db = s - abs(a.y - b.y);\n\tint dc = s - abs(a.z - b.z);\n\tif (da <= 0 || db <= 0 || dc <= 0)return 0;\n\treturn 2*(da * db +db* dc+dc*da);\n}\nstruct edge { int to,cost; };\nint main() {\n\twhile (cin >> n >> k >> s,n) {\n\t\tvector<edge> G[2000]; cube a[2000];\n\t\trep(i, n) {\n\t\t\tint x, y, z; cin >> x >> y >> z;\n\t\t\ta[i] = { x,y,z };\n\t\t}\n\t\tif (k == 1) {\n\t\t\tcout << 6 * s*s << endl; continue;\n\t\t}\n\t\trep(i, n) {\n\t\t\trep(j, n) {\n\t\t\t\tif (i == j)continue;\n\t\t\t\tint dis = cap(a[i], a[j]);\n\t\t\t\tif (dis > 0) {\n\t\t\t\t\tG[i].push_back({ j,dis });\n\t\t\t\t\tG[j].push_back({ i,dis });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ma = 0;\n\t\trep(sta, n) {\n\t\t\trep(i, (int)G[sta].size()) {\n\t\t\t\tvector<int> ad;\n\t\t\t\tint nf = G[sta][i].to;\n\t\t\t\tint used[2000] = {}; used[sta] = used[nf] = 1;\n\t\t\t\tbool f = false;\n\t\t\t\tif (k == 2)f = true;\n\t\t\t\tad.push_back(nf); ad.push_back(sta);\n\t\t\t\trep(aaa, k - 2) {\n\t\t\t\t\tf = false;\n\t\t\t\t\trep(b, (int)G[nf].size()) {\n\t\t\t\t\t\tif (!used[G[nf][b].to]) {\n\t\t\t\t\t\t\tf = true;\n\t\t\t\t\t\t\tused[G[nf][b].to] = 1;\n\t\t\t\t\t\t\tnf = G[nf][b].to; \n\t\t\t\t\t\t\tad.push_back(nf);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!f)continue;\n\t\t\t\tint sum = 0;\n\t\t\t\tint len = ad.size();\n\t\t\t\trep(i, len) {\n\t\t\t\t\trep(j, len) {\n\t\t\t\t\t\tif (i < j) {\n\t\t\t\t\t\t\tsum += cap(a[ad[i]], a[ad[j]]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tma = max(ma, sum);\n\t\t\t}\n\t\t}\n\t\tif (ma == 0) {\n\t\t\tcout << -1 << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << 6 * s*s*k - ma << endl;\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <cmath>\n#include <cstdlib>\n#include <map>\nusing namespace std;\n\nclass Point {\npublic:\n    int x, y, z;\n    Point(int x = 0, int y = 0, int z = 0) : x(x), y(y), z(z) {}\n};\n\nclass Cube {\npublic:\n    Point p;\n    int s;\n    int vx[4] = {0, 1, 1, 0}, vy[4] = {0, 0, 1, 1}, vz[2] = {0, 1};\n    Cube(Point p = Point(), int s = 0) : p(p), s(s) {}\n\n    bool isIn(const Cube &c) {\n        /*\n        int nx, ny, nz;\n        for (int i = 0; i < 2; ++i) {\n            for (int j = 0; j < 4; ++j) {\n                nx = c.p.x + c.s * vx[j];\n                ny = c.p.y + c.s * vy[j];\n                nz = c.p.z + c.s * vz[i];\n\n                if (p.x <= nx && nx <= p.x + s &&\n                    p.y <= ny && ny <= p.y + s &&\n                    p.z <= nz && nz <= p.z + s) {\n                        return true;\n                    }\n            }\n        return false;\n        }*/\n        return ((abs(p.x - c.p.x) < s) && (abs(p.y - c.p.y) <= s) && (abs(p.z - c.p.z) <= s) &&\n                (abs(p.x - c.p.x) <= s) && (abs(p.y - c.p.y) < s) && (abs(p.z - c.p.z) <= s) &&\n                (abs(p.x - c.p.x) <= s) && (abs(p.y - c.p.y) <= s) && (abs(p.z - c.p.z) < s));\n    }\n\n    long long shareS(Cube &c) {\n        long long ret = 0;\n        Point a, b;\n        a = p; b = c.p;\n\n        if (a.x > b.x) swap(a.x, b.x);\n        if (a.y > b.y) swap(a.y, b.y);\n        if (a.z > b.z) swap(a.z, b.z);\n\n        ret += abs((a.x + s - b.x) * (a.z + s - b.z) * 2);\n        ret += abs((a.y + s - b.y) * (a.z + s - b.z) * 2);\n        ret += abs((a.x + s - b.x) * (a.y + s - b.y) * 2);\n        return ret;\n    }\n\n};\n\nint n, k, s, x, y, z;\nlong long ans;\nvector<Cube> c;\nvector<vector<int> > subg;\nvector<bool> used;\nvector<deque<int> > graph;\ndeque<int> que;\n\n// not clever\ninline void makegraph() {\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            if (c[i].isIn(c[j])) {\n                subg[j].push_back(i);\n                subg[i].push_back(j);\n            }\n        }\n    }\n}\n\n// make path\nvoid dfs(int v) {\n    used[v] = true;\n    int size_ = subg[v].size();\n    bool flag = false;\n\n    for (int i = 0; i < size_; ++i) {\n        if (!used[subg[v][i]]) {\n            dfs(subg[v][i]);\n            if (!flag) que.push_front(v);\n            flag = true;\n        }\n    }\n\n    if (!flag) que.push_front(v);\n}\n\n// is graph[graphid] cycle ?\ninline bool isCycle(int graphid) {\n    int size_ = graph[graphid].size();\n\n    // if all vertex's degree are two, this graph is cycle.\n    for (int i = 0; i < size_; ++i) {\n        if (subg[graph[graphid][i]].size() != 2) return false;\n    }\n\n    return true;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    while (cin >> n >> k >> s, n | k | s) {\n        //cout << \"---- begin ----\" << endl;\n        c.resize(n);\n        subg.resize(n);\n        que.clear();\n        used.assign(n, false);\n        ans = int(1e15);\n\n        for (int i = 0; i < n; ++i) {\n            cin >> x >> y >> z;\n            c[i] = {Point(x, y, z), s};    \n        }\n\n        makegraph();\n\n        for (int i = 0; i < n; ++i) {\n            if (!used[i]) {\n                dfs(i);\n                graph.push_back(que);\n                que.clear();\n            }\n        }\n\n        /*\n        for (int i = 0; i < graph.size(); ++i) {\n            for (int j = 0; j < graph[i].size(); ++j) {\n                cout << graph[i][j] << \" \";\n            }\n            cout << endl;\n        }\n        */\n\n        int gsize = graph.size(), qsize, upper;\n        long long share;\n        bool isGraphCycle = false;\n\n        //cout << \"k = \" << k << endl;\n\n        for (int i = 0; i < gsize; ++i) {\n            qsize = graph[i].size();\n            isGraphCycle = isCycle(i);\n            if (isGraphCycle) {\n                upper = qsize + k - 1;\n            }\n            else upper = qsize;\n\n            if (qsize < k) continue;\n\n            for (int j = 0; j + k - 1 < upper; ++j) {\n                share = 0;\n                /*for (int l = 0; l < k - 1; ++l) {\n                    cout << graph[i][(j + l) % qsize] << \" \" << graph[i][(j + l + 1) % qsize] << endl;\n                }*/\n                //cout << graph[i][(j + k - 1) % qsize] << \" \" << graph[i][(j + k) % qsize] << endl;\n                //cout << endl;\n\n                for (int l = 0; l < k - 1; ++l) {\n                    //Cube a = c[graph[i][j + l]],\n                    //    b = c[graph[i][j + l + 1]];\n                    //cout << a.p.x << \" \" << a.p.y << \" \" << a.p.z << endl;\n                    //cout << b.p.x << \" \" << b.p.y << \" \" << b.p.z << endl;\n\n                    share += c[graph[i][(j + l) % qsize]].shareS(c[graph[i][(j + l + 1) % qsize]]);\n\n                    //cout << graph[i][(j + l) % qsize] << \" & \" << graph[i][(j + l + 1) % qsize] << endl;\n                    //cout << \"share is \" << tmp << endl;\n                }\n\n                if (isGraphCycle && qsize == k) {\n                    //cout << \"this is cycle\" << endl;\n                    share += c[graph[i][j]].shareS(c[graph[i][(j + qsize - 1) % qsize]]);\n                }\n\n                ans = min(ans, 6 * s * s * k - share);\n                //cout << \"all - share = \" << 6*s*s*k << endl;\n            }\n        }\n\n        if (n == 1) ans = 6 * s * s;\n        if (ans == int(1e15)) ans = -1;\n\n        cout << ans << endl;\n\n        //cout << \"---- end ----\" << endl;\n\n        c.clear();\n        graph.clear();\n        subg.clear();\n        used.clear();\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define  _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n\n#pragma comment (linker, \"/STACK:526000000\")\n\n#include \"bits/stdc++.h\"\n\nusing namespace std;\ntypedef string::const_iterator State;\n#define eps 1e-5L\n#define MAX_MOD 1000000007LL\n#define GYAKU 500000004LL\n#define MOD 998244353LL\n#define pb push_back\n#define mp make_pair\ntypedef long long ll;\n#define REP(a,b) for(long long (a) = 0;(a) < (b);++(a))\n#define ALL(x) (x).begin(),(x).end()\n\n// geometry library\n\n#define int long long\n\ntypedef complex<long double> Point;\ntypedef pair<complex<long double>, complex<long double>> Line;\n\ntypedef struct Circle {\n    complex<long double> center;\n    long double r;\n}Circle;\n\nlong double dot(Point a, Point b) {\n    return (a.real() * b.real() + a.imag() * b.imag());\n}\nlong double cross(Point a, Point b) {\n    return (a.real() * b.imag() - a.imag() * b.real());\n}\n\nlong double Dist_Line_Point(Line a, Point b) {\n    if (dot(a.second - a.first, b - a.first) < eps) return abs(b - a.first);\n    if (dot(a.first - a.second, b - a.second) < eps) return abs(b - a.second);\n    return abs(cross(a.second - a.first, b - a.first)) / abs(a.second - a.first);\n}\n\nint is_intersected_ls(Line a, Line b) {\n    return (cross(a.second - a.first, b.first - a.first) * cross(a.second - a.first, b.second - a.first) < eps) &&\n        (cross(b.second - b.first, a.first - b.first) * cross(b.second - b.first, a.second - b.first) < eps);\n}\n\nPoint intersection_l(Line a, Line b) {\n    Point da = a.second - a.first;\n    Point db = b.second - b.first;\n    return a.first + da * cross(db, b.first - a.first) / cross(db, da);\n}\n\nlong double Dist_Line_Line(Line a, Line b) {\n    if (is_intersected_ls(a, b) == 1) {\n        return 0;\n    }\n    return min({ Dist_Line_Point(a,b.first), Dist_Line_Point(a,b.second),Dist_Line_Point(b,a.first),Dist_Line_Point(b,a.second) });\n}\n\npair<Point, Point> intersection_Circle_Circle(Circle a, Circle b) {\n    long double dist = abs(a.center - b.center);\n    assert(dist <= eps + a.r + b.r);\n    assert(dist + eps >= abs(a.r - b.r));\n    Point target = b.center - a.center;\n    long double pointer = target.real() * target.real() + target.imag() * target.imag();\n    long double aa = pointer + a.r * a.r - b.r * b.r;\n    aa /= 2.0L;\n    Point l{ (aa * target.real() + target.imag() * sqrt(pointer * a.r * a.r - aa * aa)) / pointer,\n            (aa * target.imag() - target.real() * sqrt(pointer * a.r * a.r - aa * aa)) / pointer };\n    Point r{ (aa * target.real() - target.imag() * sqrt(pointer * a.r * a.r - aa * aa)) / pointer,\n        (aa * target.imag() + target.real() * sqrt(pointer * a.r * a.r - aa * aa)) / pointer };\n    r = r + a.center;\n    l = l + a.center;\n    return mp(l, r);\n}\n\n//end of geometry\n\ntemplate<typename A>\nA pows(A val, ll b) {\n    assert(b >= 1);\n    A ans = val;\n    b--;\n    while (b) {\n        if (b % 2) {\n            ans *= val;\n        }\n        val *= val;\n        b /= 2LL;\n    }\n    return ans;\n}\n\ntemplate<typename A>\nclass Compressor {\npublic:\n    bool is_zipped = false;\n    map<A, ll> zipper;\n    map<ll, A> unzipper;\n    queue<A> fetcher;\n    Compressor() {\n        is_zipped = false;\n        zipper.clear();\n        unzipper.clear();\n    }\n    void add(A now) {\n        assert(is_zipped == false);\n        zipper[now] = 1;\n        fetcher.push(now);\n    }\n    void exec() {\n        assert(is_zipped == false);\n        int cnt = 0;\n        for (auto i = zipper.begin(); i != zipper.end(); ++i) {\n            i->second = cnt;\n            unzipper[cnt] = i->first;\n            cnt++;\n        }\n        is_zipped = true;\n    }\n    ll fetch() {\n        assert(is_zipped == true);\n        A hoge = fetcher.front();\n        fetcher.pop();\n        return zipper[hoge];\n    }\n    ll zip(A now) {\n        assert(is_zipped == true);\n        assert(zipper.find(now) != zipper.end());\n        return zipper[now];\n    }\n    A unzip(ll a) {\n        assert(is_zipped == true);\n        assert(a < unzipper.size());\n        return unzipper[a];\n    }\n    ll next(A now) {\n        auto x = zipper.upper_bound(now);\n        if (x == zipper.end()) return zipper.size();\n        return (ll)((*x).second);\n    }\n    ll back(A now) {\n        auto x = zipper.lower_bound(now);\n        if (x == zipper.begin()) return -1;\n        x--;\n        return (ll)((*x).second);\n    }\n};\n\ntemplate<typename A>\nclass Matrix {\npublic:\n    vector<vector<A>> data;\n    Matrix(vector<vector<A>> a) :data(a) {\n\n    }\n    Matrix operator + (const Matrix obj) {\n        vector<vector<A>> ans;\n        assert(obj.data.size() == this->data.size());\n        assert(obj.data[0].size() == this->data[0].size());\n        REP(i, obj.data.size()) {\n            ans.push_back(vector<A>());\n            REP(q, obj.data[i].size()) {\n                A hoge = obj.data[i][q] + (this->data[i][q]);\n                ans.back().push_back(hoge);\n            }\n        }\n        return Matrix(ans);\n    }\n    Matrix operator - (const Matrix obj) {\n        vector<vector<A>> ans;\n        assert(obj.data.size() == this->data.size());\n        assert(obj.data[0].size() == this->data[0].size());\n        REP(i, obj.data.size()) {\n            ans.push_back(vector<A>());\n            REP(q, obj.data[i].size()) {\n                A hoge = this->data[i][q] - obj.data[i][q];\n                ans.back().push_back(hoge);\n            }\n        }\n        return Matrix(ans);\n    }\n    Matrix operator * (const Matrix obj) {\n        vector<vector<A>> ans;\n        assert(obj.data.size() == this->data[0].size());\n        REP(i, this -> data.size()) {\n            ans.push_back(vector<A>());\n            REP(q, obj.data[0].size()) {\n                A hoge = (this->data[i][0]) * (obj.data[0][q]);\n                for (int t = 1; t < obj.data[i].size(); ++t) {\n                    hoge += this->data[i][t] * obj.data[t][q];\n                }\n                ans.back().push_back(hoge);\n            }\n        }\n        return Matrix(ans);\n    }\n    Matrix& operator *= (const Matrix obj) {\n        *this = (*this * obj);\n        return *this;\n    }\n    Matrix& operator += (const Matrix obj) {\n        *this = (*this + obj);\n        return *this;\n    }\n    Matrix& operator -= (const Matrix obj) {\n        *this = (*this - obj);\n        return *this;\n    }\n};\n\ntemplate <std::uint_fast64_t mod>\nclass modint {\npublic:\n    using u64 = std::uint_fast64_t;\n    u64 value = 0;\n    modint(ll a) : value(((a% mod) + 2 * mod) % mod) {\n\n    }\n\n    constexpr modint operator+(const modint rhs) const {\n        return modint(*this) += rhs;\n    }\n    constexpr modint operator-(const modint rhs) const {\n        return modint(*this) -= rhs;\n    }\n    constexpr modint operator*(const modint rhs) const {\n        return modint(*this) *= rhs;\n    }\n    constexpr modint operator/(const modint rhs) const {\n        return modint(*this) /= rhs;\n    }\n    constexpr modint& operator+=(const modint rhs) {\n        value += rhs.value;\n        if (value >= mod) {\n            value -= mod;\n        }\n        return *this;\n    }\n    constexpr modint& operator-=(const modint rhs) {\n        if (value < rhs.value) {\n            value += mod;\n        }\n        value -= rhs.value;\n        return *this;\n    }\n    constexpr modint& operator*=(const modint rhs) {\n        value = (value * rhs.value) % mod;\n        return *this;\n    }\n    constexpr modint& operator/=(modint rhs) {\n        ll rem = mod - 2;\n        while (rem) {\n            if (rem % 2) {\n                *this *= rhs;\n            }\n            rhs *= rhs;\n            rem /= 2LL;\n        }\n        return *this;\n    }\n    bool operator <(modint rhs) const {\n        return value < rhs.value;\n    }\n    friend ostream& operator<<(ostream& os, modint& p) {\n        os << p.value;\n        return (os);\n    }\n};\n\nclass Dice {\npublic:\n    vector<ll> vertexs;\n    //Up: 0,Left: 1,Center: 2,Right: 3,Adj: 4, Down: 5\n    Dice(vector<ll> init) :vertexs(init) {\n\n    }\n    //Look from Center\n    void RtoL() {\n        for (int q = 1; q < 4; ++q) {\n            swap(vertexs[q], vertexs[q + 1]);\n        }\n    }\n    void LtoR() {\n        for (int q = 3; q >= 1; --q) {\n            swap(vertexs[q], vertexs[q + 1]);\n        }\n    }\n    void UtoD() {\n        swap(vertexs[5], vertexs[4]);\n        swap(vertexs[2], vertexs[5]);\n        swap(vertexs[0], vertexs[2]);\n    }\n    void DtoU() {\n        swap(vertexs[0], vertexs[2]);\n        swap(vertexs[2], vertexs[5]);\n        swap(vertexs[5], vertexs[4]);\n    }\n    bool ReachAble(Dice now) {\n        set<Dice> hoge;\n        queue<Dice> next;\n        next.push(now);\n        hoge.insert(now);\n        while (next.empty() == false) {\n            Dice seeing = next.front();\n            next.pop();\n            if (seeing == *this) return true;\n            seeing.RtoL();\n            if (hoge.count(seeing) == 0) {\n                hoge.insert(seeing);\n                next.push(seeing);\n            }\n            seeing.LtoR();\n            seeing.LtoR();\n            if (hoge.count(seeing) == 0) {\n                hoge.insert(seeing);\n                next.push(seeing);\n            }\n            seeing.RtoL();\n            seeing.UtoD();\n            if (hoge.count(seeing) == 0) {\n                hoge.insert(seeing);\n                next.push(seeing);\n            }\n            seeing.DtoU();\n            seeing.DtoU();\n            if (hoge.count(seeing) == 0) {\n                hoge.insert(seeing);\n                next.push(seeing);\n            }\n        }\n        return false;\n    }\n    bool operator ==(const Dice& a) {\n        for (int q = 0; q < 6; ++q) {\n            if (a.vertexs[q] != (*this).vertexs[q]) {\n                return false;\n            }\n        }\n        return true;\n    }\n    bool operator <(const Dice& a) const {\n        return (*this).vertexs < a.vertexs;\n    }\n};\n\npair<Dice, Dice> TwoDimDice(int center, int up) {\n    int target = 1;\n    while (true) {\n        if (center != target && 7 - center != target && up != target && 7 - up != target) {\n            break;\n        }\n        target++;\n    }\n    return mp(Dice(vector<ll>{up, target, center, 7 - target, 7 - center, 7 - up}), Dice(vector<ll>{up, 7 - target, center, target, 7 - center, 7 - up}));\n}\n\ntuple<Dice, Dice, Dice, Dice> OneDimDice(int center) {\n    int bo = min(center, 7 - center);\n    pair<int, int> goa;\n    if (bo == 1) {\n        goa = mp(2, 3);\n    }\n    else if (bo == 2) {\n        goa = mp(1, 3);\n    }\n    else if (bo == 3) {\n        goa = mp(1, 2);\n    }\n    tuple<Dice, Dice, Dice, Dice> now = make_tuple(Dice(vector<ll>{goa.first, goa.second, center, 7 - goa.second, 7 - center, 7 - goa.first}),\n        Dice(vector<ll>{goa.first, 7 - goa.second, center, goa.second, 7 - center, 7 - goa.first}),\n        Dice(vector<ll>{7 - goa.first, goa.second, center, 7 - goa.second, 7 - center, goa.first}),\n        Dice(vector<ll>{7 - goa.first, 7 - goa.second, center, goa.second, 7 - center, goa.first}));\n    return now;\n}\n\ntemplate<typename A, typename B>\nclass Dijkstra {\npublic:\n    vector<vector<pair<int, A>>> vertexs;\n    B Cost_Function;\n    Dijkstra(int n, B cost) : Cost_Function(cost) {\n        vertexs = vector<vector<pair<int, A>>>(n, vector<pair<int, A>>{});\n    }\n    ~Dijkstra() {\n        vertexs.clear();\n    }\n    void add_edge(int a, int b, A c) {\n        vertexs[a].push_back(mp(b, c));\n    }\n    vector<ll> build_result(int StartPoint) {\n        vector<ll> dist(vertexs.size(), 2e18);\n        dist[StartPoint] = 0;\n        priority_queue<pair<ll, int>, vector<pair<ll, int>>, greater<pair<ll, int>>> next;\n        next.push(make_pair(0, StartPoint));\n        while (next.empty() == false) {\n            pair<ll, int> now = next.top();\n            next.pop();\n            if (dist[now.second] != now.first) continue;\n            for (auto x : vertexs[now.second]) {\n                ll now_cost = now.first + Cost_Function(x.second);\n                if (dist[x.first] > now_cost) {\n                    dist[x.first] = now_cost;\n                    next.push(mp(now_cost, x.first));\n                }\n            }\n        }\n        return dist;\n    }\n};\n\nclass Dinic {\npublic:\n    struct edge {\n        int to;\n        int cap;\n        int rev;\n    };\n    vector<vector<edge>> Graph;\n    vector<int> level;\n    vector<int> itr;\n    Dinic(int n) {\n        Graph = vector<vector<edge>>(n, vector<edge>());\n    }\n    void add_edge(int a, int b, int cap) {\n        Graph[a].push_back(edge{ b, cap ,(int)Graph[b].size() });\n        Graph[b].push_back(edge{ a,0,(int)Graph[a].size() - 1 });\n    }\n    void bfs(int s) {\n        level = vector<int>(Graph.size(), -1);\n        level[s] = 0;\n        queue<int> next;\n        next.push(s);\n        while (next.empty() == false) {\n            int now = next.front();\n            next.pop();\n            for (auto x : Graph[now]) {\n                if (x.cap == 0) continue;\n                if (level[x.to] == -1) {\n                    level[x.to] = level[now] + 1;\n                    next.push(x.to);\n                }\n            }\n        }\n    }\n    int dfs(int now, int goal, int val) {\n        if (goal == now) return val;\n        for (int& i = itr[now]; i < (int)Graph[now].size(); ++i) {\n            edge& target = Graph[now][i];\n            if (target.cap > 0 && level[now] < level[target.to]) {\n                int d = dfs(target.to, goal, min(val, target.cap));\n                if (d > 0) {\n                    target.cap -= d;\n                    Graph[target.to][target.rev].cap += d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n    int run(int s, int t) {\n        int ans = 0;\n        int f = 0;\n        while (bfs(s), level[t] >= 0) {\n            itr = vector<int>(Graph.size(), 0);\n            while ((f = dfs(s, t, 1e9)) > 0) {\n                ans += f;\n            }\n        }\n        return ans;\n    }\n};\n\n\nclass HLDecomposition {\npublic:\n    vector<vector<int>> vertexs;\n    vector<int> depth;\n    vector<int> backs;\n    vector<int> connections;\n    vector<int> zip, unzip;\n    HLDecomposition(int n) {\n        vertexs = vector<vector<int>>(n, vector<int>());\n        depth = vector<int>(n);\n        zip = vector<int>(n);\n        unzip = zip;\n    }\n    void add_edge(int a,int b) {\n        vertexs[a].push_back(b);\n        vertexs[b].push_back(a);\n    }\n    int depth_dfs(int now, int back) {\n        depth[now] = 0;\n        for (auto x : vertexs[now]) {\n            if (x == back) continue;\n            depth[now] = max(depth[now], 1 + depth_dfs(x, now));\n        }\n        return depth[now];\n    }\n    void dfs(int now,int backing) {\n        zip[now] = backs.size();\n        unzip[backs.size()] = now;\n        backs.push_back(backing);\n        int now_max = -1;\n        int itr = -1;\n        for (auto x : vertexs[now]) {\n            if (depth[x] > depth[now]) continue;\n            if (now_max < depth[x]) {\n                now_max = depth[x];\n                itr = x;\n            }\n        }\n        if (itr == -1) return;\n        connections.push_back(connections.back());\n        dfs(itr,backing);\n        for (auto x : vertexs[now]) {\n            if (depth[x] > depth[now]) continue;\n            if (x == itr) continue;\n            connections.push_back(zip[now]);\n            dfs(x, backs.size());\n        }\n        return;\n    }\n    void build() {\n        depth_dfs(0, -1);\n        connections.push_back(-1);\n        dfs(0, -1);\n    }\n    vector<pair<int,int>> query(int a, int b) {\n        a = zip[a];\n        b = zip[b];\n        vector<pair<int, int>> ans;\n        while (backs[a] != backs[b]) {\n            if (a < b) swap(a, b);\n            ans.push_back(mp(backs[a], a + 1));\n            a = connections[a];\n        }\n        if (a > b) swap(a, b);\n        ans.push_back(mp(a, b + 1));\n        return ans;\n    } \n    int lca(int a, int b) {\n        a = zip[a];\n        b = zip[b];\n        while (backs[a] != backs[b]) {\n            if (a < b) swap(a, b);\n            a = connections[a];\n        }\n        return unzip[min(a, b)];\n    }\n};\n//by ei1333\n//https://ei1333.github.io/luzhiled/snippets/structure/segment-tree.html\ntemplate< typename Monoid >\nstruct SegmentTree {\n    using F = function< Monoid(Monoid, Monoid) >;\n\n    int sz;\n    vector< Monoid > seg;\n\n    const F f;\n    const Monoid M1;\n\n    SegmentTree(int n, const F f, const Monoid& M1) : f(f), M1(M1) {\n        sz = 1;\n        while (sz < n) sz <<= 1;\n        seg.assign(2 * sz + 1, M1);\n    }\n\n    void set(int k, const Monoid& x) {\n        seg[k + sz] = x;\n    }\n\n    void build() {\n        for (int k = sz - 1; k > 0; k--) {\n            seg[k] = f(seg[2 * k + 0], seg[2 * k + 1]);\n        }\n    }\n\n    void update(int k, const Monoid& x) {\n        k += sz;\n        seg[k] = x;\n        while (k >>= 1) {\n            seg[k] = f(seg[2 * k + 0], seg[2 * k + 1]);\n        }\n    }\n\n    Monoid query(int a, int b) {\n        Monoid L = M1, R = M1;\n        for (a += sz, b += sz; a < b; a >>= 1, b >>= 1) {\n            if (a & 1) L = f(L, seg[a++]);\n            if (b & 1) R = f(seg[--b], R);\n        }\n        return f(L, R);\n    }\n\n    Monoid operator[](const int& k) const {\n        return seg[k + sz];\n    }\n\n    template< typename C >\n    int find_subtree(int a, const C& check, Monoid& M, bool type) {\n        while (a < sz) {\n            Monoid nxt = type ? f(seg[2 * a + type], M) : f(M, seg[2 * a + type]);\n            if (check(nxt)) a = 2 * a + type;\n            else M = nxt, a = 2 * a + 1 - type;\n        }\n        return a - sz;\n    }\n\n\n    template< typename C >\n    int find_first(int a, const C& check) {\n        Monoid L = M1;\n        if (a <= 0) {\n            if (check(f(L, seg[1]))) return find_subtree(1, check, L, false);\n            return -1;\n        }\n        int b = sz;\n        for (a += sz, b += sz; a < b; a >>= 1, b >>= 1) {\n            if (a & 1) {\n                Monoid nxt = f(L, seg[a]);\n                if (check(nxt)) return find_subtree(a, check, L, false);\n                L = nxt;\n                ++a;\n            }\n        }\n        return -1;\n    }\n\n    template< typename C >\n    int find_last(int b, const C& check) {\n        Monoid R = M1;\n        if (b >= sz) {\n            if (check(f(seg[1], R))) return find_subtree(1, check, R, true);\n            return -1;\n        }\n        int a = sz;\n        for (b += sz; a < b; a >>= 1, b >>= 1) {\n            if (b & 1) {\n                Monoid nxt = f(seg[--b], R);\n                if (check(nxt)) return find_subtree(b, check, R, true);\n                R = nxt;\n            }\n        }\n        return -1;\n    }\n};\n\ntemplate< typename Monoid, typename OperatorMonoid = Monoid >\nstruct LazySegmentTree {\n    using F = function< Monoid(Monoid, Monoid) >;\n    using G = function< Monoid(Monoid, OperatorMonoid,int) >;\n    using H = function< OperatorMonoid(OperatorMonoid, OperatorMonoid) >;\n\n    int sz, height;\n    vector< Monoid > data;\n    vector< OperatorMonoid > lazy;\n    const F f;\n    const G g;\n    const H h;\n    const Monoid M1;\n    const OperatorMonoid OM0;\n\n\n    LazySegmentTree(int n, const F f, const G g, const H h,\n        const Monoid& M1, const OperatorMonoid OM0)\n        : f(f), g(g), h(h), M1(M1), OM0(OM0) {\n        sz = 1;\n        height = 0;\n        while (sz < n) sz <<= 1, height++;\n        data.assign(2 * sz, M1);\n        lazy.assign(2 * sz, OM0);\n    }\n\n    void set(int k, const Monoid& x) {\n        data[k + sz] = x;\n    }\n\n    void build() {\n        for (int k = sz - 1; k > 0; k--) {\n            data[k] = f(data[2 * k + 0], data[2 * k + 1]);\n        }\n    }\n\n    inline void propagate(int k) {\n        if (lazy[k] != OM0) {\n            lazy[2 * k + 0] = h(lazy[2 * k + 0], lazy[k]);\n            lazy[2 * k + 1] = h(lazy[2 * k + 1], lazy[k]);\n            data[k] = reflect(k);\n            lazy[k] = OM0;\n        }\n    }\n\n    inline Monoid reflect(int k) {\n        if (lazy[k] == OM0) return data[k];\n        for (int q = sz; q >= 0; q /= 2) {\n            if (q & k) {\n                return g(data[k], lazy[k], sz / q);\n            }\n        }\n    }\n\n    inline void recalc(int k) {\n        while (k >>= 1) data[k] = f(reflect(2 * k + 0), reflect(2 * k + 1));\n    }\n\n    inline void thrust(int k) {\n        for (int i = height; i > 0; i--) propagate(k >> i);\n    }\n\n    void update(int a, int b, const OperatorMonoid& x) {\n        thrust(a += sz);\n        thrust(b += sz - 1);\n        for (int l = a, r = b + 1; l < r; l >>= 1, r >>= 1) {\n            if (l & 1) lazy[l] = h(lazy[l], x), ++l;\n            if (r & 1) --r, lazy[r] = h(lazy[r], x);\n        }\n        recalc(a);\n        recalc(b);\n    }\n\n    Monoid query(int a, int b) {\n        thrust(a += sz);\n        thrust(b += sz - 1);\n        Monoid L = M1, R = M1;\n        for (int l = a, r = b + 1; l < r; l >>= 1, r >>= 1) {\n            if (l & 1) L = f(L, reflect(l++));\n            if (r & 1) R = f(reflect(--r), R);\n        }\n        return f(L, R);\n    }\n\n    Monoid operator[](const int& k) {\n        return query(k, k + 1);\n    }\n\n    template< typename C >\n    int find_subtree(int a, const C& check, Monoid& M, bool type) {\n        while (a < sz) {\n            propagate(a);\n            Monoid nxt = type ? f(reflect(2 * a + type), M) : f(M, reflect(2 * a + type));\n            if (check(nxt)) a = 2 * a + type;\n            else M = nxt, a = 2 * a + 1 - type;\n        }\n        return a - sz;\n    }\n\n    template< typename C >\n    int find_first(int a, const C& check) {\n        Monoid L = M1;\n        if (a <= 0) {\n            if (check(f(L, reflect(1)))) return find_subtree(1, check, L, false);\n            return -1;\n        }\n        thrust(a + sz);\n        int b = sz;\n        for (a += sz, b += sz; a < b; a >>= 1, b >>= 1) {\n            if (a & 1) {\n                Monoid nxt = f(L, reflect(a));\n                if (check(nxt)) return find_subtree(a, check, L, false);\n                L = nxt;\n                ++a;\n            }\n        }\n        return -1;\n    }\n\n\n    template< typename C >\n    int find_last(int b, const C& check) {\n        Monoid R = M1;\n        if (b >= sz) {\n            if (check(f(reflect(1), R))) return find_subtree(1, check, R, true);\n            return -1;\n        }\n        thrust(b + sz - 1);\n        int a = sz;\n        for (b += sz; a < b; a >>= 1, b >>= 1) {\n            if (b & 1) {\n                Monoid nxt = f(reflect(--b), R);\n                if (check(nxt)) return find_subtree(b, check, R, true);\n                R = nxt;\n            }\n        }\n        return -1;\n    }\n};\n\n\n\nunsigned long xor128() {\n    static unsigned long x = 123456789, y = 362436069, z = 521288629, w = 88675123;\n    unsigned long t = (x ^ (x << 11));\n    x = y; y = z; z = w;\n    return (w = (w ^ (w >> 19)) ^ (t ^ (t >> 8)));\n}\n\nvoid init() {\n    iostream::sync_with_stdio(false);\n    cout << fixed << setprecision(20);\n}\nvector<pair<int,int>> vertexs[3000];\nint visited[3000];\n\nvoid dfs(int now,vector<int> &adds) {\n    visited[now] = 1;\n    for (auto x : vertexs[now]) {\n        if (visited[x.first] == 1) continue;\n        adds.push_back(x.second);\n        dfs(x.first, adds);\n    }\n    return;\n}\nvoid solve() {\n    while (true) {\n        int n, k, s;\n        cin >> n >> k >> s;\n        if (n == 0) return;\n        vector<tuple<int, int, int>> inputs;\n        REP(i, n) {\n            int a, b, c;\n            cin >> a >> b >> c;\n            inputs.push_back(make_tuple(a, b, c));\n            vertexs[i].clear();\n            visited[i] = 0;\n        }\n        if (k == 1) {\n            cout << s * s * 6LL << endl;\n            continue;\n        }\n        REP(i, n) {\n            for (int q = i + 1; q < n; ++q) {\n                int x = abs(get<0>(inputs[q]) - get<0>(inputs[i]));\n                int y = abs(get<1>(inputs[q]) - get<1>(inputs[i]));\n                int z = abs(get<2>(inputs[q]) - get<2>(inputs[i]));\n                if (max({ x,y,z }) >= s) continue;\n                x = s - x;\n                y = s - y;\n                z = s - z;\n                vertexs[q].push_back(make_pair(i, 2LL * (x * y + y * z + z * x)));\n                vertexs[i].push_back(make_pair(q, 2LL * (x * y + y * z + z * x)));\n            }\n        }\n        k--;\n        int ans = 1e18;\n        REP(i, n) {\n            if (visited[i]) continue;\n            if (vertexs[i].size() == 1) {\n                vector<int> hoge;\n                dfs(i, hoge);\n                for (int q = 0; q < (int)hoge.size() - k + 1; ++q) {\n                    int sums = 0;\n                    for (int j = 0; j < k; ++j) {\n                        sums += hoge[q + j];\n                    }\n                    ans = min(ans, 6LL * s * s * (k + 1LL) - sums);\n                }\n            }\n        }\n        REP(i, n) {\n            if (visited[i]) continue;\n            if (vertexs[i].size() == 0) continue;\n            vector<int> hoge;\n            dfs(i, hoge);\n            if (hoge.size() < k) continue;\n            int tmp_k = k;\n            if (hoge.size() == k)tmp_k++;\n            hoge.push_back(vertexs[i][1].second);\n            for (int q = 0; q < hoge.size(); ++q) {\n                int sums = 0;\n                for (int j = 0; j < tmp_k; ++j) {\n                    sums += hoge[(q + j) % hoge.size()];\n                }\n                ans = min(ans, 6LL * s * s * (k + 1LL) - sums);\n            }\n        }\n        if (ans == 1e18) {\n            ans = -1;\n        }\n        cout << ans << endl;\n    }\n}\n\n#undef int\nint main() {\n    init();\n    solve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <cmath>\n#include <cstdlib>\n#include <map>\nusing namespace std;\n\nclass Point {\npublic:\n    int x, y, z;\n    Point(int x = 0, int y = 0, int z = 0) : x(x), y(y), z(z) {}\n};\n\nclass Cube {\npublic:\n    Point p;\n    int s;\n    int vx[4] = {0, 1, 1, 0}, vy[4] = {0, 0, 1, 1}, vz[2] = {0, 1};\n    Cube(Point p = Point(), int s = 0) : p(p), s(s) {}\n\n    bool isIn(const Cube &c) {\n        return ((abs(p.x - c.p.x) < s) && (abs(p.y - c.p.y) <= s) && (abs(p.z - c.p.z) <= s) &&\n                (abs(p.x - c.p.x) <= s) && (abs(p.y - c.p.y) < s) && (abs(p.z - c.p.z) <= s) &&\n                (abs(p.x - c.p.x) <= s) && (abs(p.y - c.p.y) <= s) && (abs(p.z - c.p.z) < s));\n    }\n\n    long long shareS(Cube &c) {\n        long long ret = 0;\n        Point a, b;\n        a = p; b = c.p;\n\n        if (a.x > b.x) swap(a.x, b.x);\n        if (a.y > b.y) swap(a.y, b.y);\n        if (a.z > b.z) swap(a.z, b.z);\n\n        ret += abs((a.x + s - b.x) * (a.z + s - b.z) * 2);\n        ret += abs((a.y + s - b.y) * (a.z + s - b.z) * 2);\n        ret += abs((a.x + s - b.x) * (a.y + s - b.y) * 2);\n        return ret;\n    }\n\n};\n\nint n, k, s, x, y, z;\nlong long ans;\nvector<Cube> c;\nvector<vector<int> > subg;\nvector<bool> used;\nvector<deque<int> > graph;\ndeque<int> que;\n\ninline void makegraph() {\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            if (c[i].isIn(c[j])) {\n                subg[j].push_back(i);\n                subg[i].push_back(j);\n            }\n        }\n    }\n}\n\n// make path\nvoid dfs(int v) {\n    used[v] = true;\n    int size_ = subg[v].size();\n    bool flag = false;\n\n    for (int i = 0; i < size_; ++i) {\n        if (!used[subg[v][i]]) {\n            dfs(subg[v][i]);\n            if (!flag) que.push_front(v);\n            flag = true;\n        }\n    }\n\n    if (!flag) que.push_front(v);\n}\n\n// is graph[graphid] cycle ?\ninline bool isCycle(int graphid) {\n    int size_ = graph[graphid].size();\n\n    // if all vertex's degree are two, this graph has closed path.\n    for (int i = 0; i < size_; ++i) {\n        if (subg[graph[graphid][i]].size() != 2) return false;\n    }\n\n    return true;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    while (cin >> n >> k >> s, n | k | s) {\n        c.resize(n);\n        subg.resize(n);\n        que.clear();\n        used.assign(n, false);\n        ans = int(1e15);\n\n        for (int i = 0; i < n; ++i) {\n            cin >> x >> y >> z;\n            c[i] = {Point(x, y, z), s};    \n        }\n\n        makegraph();\n\n        for (int i = 0; i < n; ++i) {\n            if (!used[i]) {\n                dfs(i);\n                graph.push_back(que);\n                que.clear();\n            }\n        }\n\n        int gsize = graph.size(), qsize, upper;\n        long long share;\n        bool isGraphCycle = false;\n\n        for (int i = 0; i < gsize; ++i) {\n            qsize = graph[i].size();\n            isGraphCycle = isCycle(i);\n            /*\n            if (isGraphCycle) {\n                upper = qsize + k - 1;\n            }\n            else upper = qsize;\n            */\n\n            if (qsize < k) continue;\n\n            for (int j = 0; j < qsize; ++j) {\n                share = 0;\n                //cout << \"isGraphCycle \" << isGraphCycle << endl;\n                if (!isGraphCycle && j + k - 1 >= qsize) continue;\n\n                for (int l = 0; l < k - 1; ++l) {\n                    //cout << (j + l) % qsize << \", \" << (j + l + 1) % qsize << endl;\n                    share += c[graph[i][(j + l) % qsize]].shareS(c[graph[i][(j + l + 1) % qsize]]);\n                }\n\n                if (isGraphCycle && qsize == k) {\n                    share += c[graph[i][j % qsize]].shareS(c[graph[i][(j + qsize - 1) % qsize]]);\n                }\n                \n\n                ans = min(ans, 6 * s * s * k - share);\n            }\n        }\n\n        if (n == 1) ans = 6 * s * s;\n        if (ans == int(1e15)) ans = -1;\n\n        cout << ans << endl;\n        //cout << endl;\n\n        c.clear();\n        graph.clear();\n        subg.clear();\n        used.clear();\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing pii = pair<int,int>;\nusing ll = long long;\n#define rep(i, j) for(int i=0; i < (int)(j); i++)\n#define repeat(i, j, k) for(int i = (j); i < (int)(k); i++)\n#define all(v) v.begin(),v.end()\n#define debug(x) cerr << #x << \" : \" << x << endl\n\ntemplate<class T> bool set_min(T &a, const T &b) { return a > b  ? a = b, true : false; }\ntemplate<class T> bool set_max(T &a, const T &b) { return a < b  ? a = b, true : false; }\n// vector\ntemplate<class T> istream& operator >> (istream &is , vector<T> &v) { for(T &a : v) is >> a; return is; }\ntemplate<class T> ostream& operator << (ostream &os , const vector<T> &v) { for(const T &t : v) os << \"\\t\" << t; return os << endl; }\n// pair\ntemplate<class T, class U> ostream& operator << (ostream &os , const pair<T, U> &v) { return os << \"<\" << v.first << \", \" << v.second << \">\"; }\n\nconst int INF = 1 << 30;\nconst ll INFL = 1LL << 60;\n\nstruct UnionFind{\n    vector<int> p;\n    UnionFind(int n) {\n        p.resize(n);\n        rep(i,n) p[i] = i;\n    }\n    int root(int x){\n        if(p[x] == x) return x;\n        else return p[x] = root(p[x]);\n    }\n    void unite(int x,int y){\n        x = root(x);\n        y = root(y);\n        if(x != y) p[y] = x;\n    }\n    bool query(int x,int y){\n        return root(x) == root(y);\n    }\n    vector<vector<int>> group() {\n        vector<vector<int>> res;\n        vector<int> index(p.size(), -1);\n        rep(i, p.size()) {\n            int r = root(i);\n            if(index[r] < 0) {\n                index[r] = res.size();\n                res.push_back({});                \n            }\n            res[index[r]].push_back(i);\n        }\n        return res;\n    }\n};\n\nstruct Point {\n    int x, y, z;    \n};\nostream& operator << (ostream &os, const Point &a) {\n    return os << \"(\" << a.x << \", \" << a.y << \", \" << a.z << \")\";\n}\nusing Rectangle = Point;\n\nclass Solver {\n  public:\n    int N, K, S;\n    vector<Rectangle> P;\n    \n    vector<Point> get_points(Rectangle a) {\n        vector<Point> res;\n        for(int i = 0; i < (1 << 3); i++) {\n            auto b = a;\n            if(i & (1 << 0)) b.x += S;\n            if(i & (1 << 1)) b.y += S;\n            if(i & (1 << 2)) b.z += S;\n            res.push_back(b);\n        }\n        return res;\n    }\n    bool does_include(Rectangle a, Point p) {\n        bool ok = true;\n        ok &= a.x <= p.x and p.x <= a.x + S;\n        ok &= a.y <= p.y and p.y <= a.y + S;\n        ok &= a.z <= p.z and p.z <= a.z + S;\n        return ok;\n    }\n    bool does_cross(Rectangle a, Rectangle b) {\n        for(Point &p : get_points(b)) if(does_include(a, p)) return true;\n        return false;\n    }\n    Point get_in_point(Rectangle a, Rectangle b) {\n        for(Point &p : get_points(b)) if(does_include(a, p)) return p;\n        assert(false);\n    }\n    ll calc_surface(vector<vector<int>> &E, int now, int prev) {\n        if(E[now].size() == 0) return K == 1 ? 6 * S * S : INFL;\n        int first = now;\n        ll sum = 0;        \n        rep(i, K) {\n            sum += 6 * S * S;            \n            if(E[now].size() == 1 and E[now][0] == prev) return i == K - 1 ? sum : INFL;\n            \n            int nxt = E[now][ E[now][0] != prev ? 0 : 1];            \n            Point a = get_in_point(P[now], P[nxt]), b = get_in_point(P[nxt], P[now]);\n            int dx = abs(a.x - b.x), dy = abs(a.y - b.y), dz = abs(a.z - b.z);\n            if(dx == 0) dx = S;\n            if(dy == 0) dy = S;\n            if(dz == 0) dz = S;\n           \n            if(i < K - 1 or nxt == first) sum -= 2 * (dx * dy + dy * dz + dz * dx);\n\n            prev = now;\n            now = nxt;\n        }\n        return sum;\n    }\n    bool solve() {\n        cin >> N >> K >> S;\n        if(N == 0) return false;\n        P.resize(N);\n        rep(i, N) cin >> P[i].x >> P[i].y >> P[i].z;\n\n        vector<vector<int>> E(N);\n        UnionFind uf(N);\n\n        rep(i, N) rep(j, i) {\n            if(does_cross(P[i], P[j])) {\n                uf.unite(i, j);\n                E[i].push_back(j);\n                E[j].push_back(i);\n            }\n        }\n        ll ans = INFL;\n        for(vector<int> g : uf.group()) {\n            if(g.size() < K) continue;\n            int now = -1, prev = -1;\n            { // get end point (and set prev when g is circle)\n                for(int i : g) if(E[i].size() == 1) now = i;\n                if(now < 0) { // circle\n                    now = g.front();\n                    prev = E[now].size() == 2 ? E[now][1] : -1;\n                }\n            }\n            rep(i, g.size()) {\n                set_min(ans, calc_surface(E, now, prev));\n                int nxt;\n                if(E[now].size() == 1) {\n                    if(prev > 0) break;\n                    nxt = E[now][0];\n                }\n                else if(E[now].size() == 2) {\n                    nxt = E[now][ E[now][0] != prev ? 0 : 1];                    \n                }\n                prev = now;\n                now = nxt;\n            }\n        }\n        cout << (ans == INFL ? -1 : ans) << endl;\n        \n        return true;\n    }\n};\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while(Solver().solve());\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ninline int abs(int a, int b) {return a<b ? b-a : a-b;}\n\nint n, k, s;\n\nstruct cube\n{\n    int x, y, z;\n    cube() : x(0),y(0),z(0) {}\n    cube(int p, int q, int r) : x(p), y(q), z(r) {}\n\n    int intersect(const cube &o)\n    {\n        int ix = s - abs(this->x, o.x);\n        int iy = s - abs(this->y, o.y);\n        int iz = s - abs(this->z, o.z);\n        return (ix>0 && iy>0 && ix>0) ? 2*(ix*iy + iy*iz + iz*ix) : 0;\n    }\n\n};\n\nstruct vertex {\n    int num, deg, es[2], ws[2];\n    vertex() : num(0), deg(0) {es[0] = es[1] = ws[0] = ws[1] = 0;}\n    vertex(int n) : num(n), deg(0) {es[0] = es[1] = ws[0] = ws[1] = 0;}\n\n    int append(int o, int w)\n    {\n        es[deg] = o;\n        ws[deg++] = w;\n    }\n\n    int another(int i)\n    {\n        if(deg<2) return -1;\n        return es[0]==i ? es[1] : es[0];\n    }\n\n    int weight(int i)\n    {\n        return es[0]==i ? ws[0] : ws[1];\n    }\n};\n\nint search(int i, int k, vertex *vs, bool *checked)\n{\n    if(checked[i]) return -1;\n    checked[i] = true;\n    if(vs[i].deg == 0) return -1;\n    int p = vs[i].es[0];\n    checked[p] = true;\n    int e = i;\n    int vc = 1;\n    bool is_cycle = false, force_cycle = true;\n    if(vs[i].deg == 1)\n    {\n        p = i;\n    }\n    if(vs[i].deg == 2)\n    {\n        while(true)\n        {\n            if(vs[p].deg == 1)\n            {\n                break;\n            }\n            if(p==i)\n            {\n                is_cycle = true;\n                if(vc<k) return -1;\n                if(vc==k) force_cycle = true;\n                break;\n            }\n            int q = vs[p].another(e);\n            e = p;\n            p = q;\n            checked[q] = true;\n            vc++;\n        }\n    }\n    // search\n    deque<int> deq;\n    int sum = 0;\n    int max_sum = 0;\n    if(is_cycle)\n    {\n        // for cycle\n        int q = vs[p].es[0];\n        int w = vs[p].ws[0];\n        sum += w;\n        deq.push_back(w);\n        for(int j=2; j<k; j++)\n        {\n            int r = vs[q].another(p);\n            w = vs[q].weight(r);\n            sum += w;\n            deq.push_back(w);\n            p = q;\n            q = r;\n        }\n        int qq = q;\n        max_sum = sum;\n        if(force_cycle) return sum + vs[q].weight(vs[q].another(p));\n        do\n        {\n            int r = vs[q].another(p);\n            w = vs[q].weight(r);\n            sum += w;\n            deq.push_back(w);\n            sum -= deq.front();\n            deq.pop_front();\n            max_sum = max(max_sum, sum);\n            p = q;\n            q = r;\n        }while(q != qq);\n    }\n    else\n    {\n        // for path\n        int q = vs[p].es[0];\n        checked[q] = true;\n        int w = vs[p].ws[0];\n        sum += w;\n        deq.push_back(w);\n        for(int j=2; j<k; j++)\n        {\n            if(vs[q].deg == 1) return -1;\n            int r = vs[q].another(p);\n            checked[r] = true;\n            w = vs[q].weight(r);\n            sum += w;\n            deq.push_back(w);\n            p = q;\n            q = r;\n        }\n        max_sum = sum;\n        while(vs[q].deg !=1)\n        {\n            int r = vs[q].another(p);\n            checked[r] = true;\n            w = vs[q].weight(r);\n            sum += w;\n            deq.push_back(w);\n            sum -= deq.front();\n            deq.pop_front();\n            max_sum = max(max_sum, sum);\n            p = q;\n            q = r;\n        }\n    }\n    return max_sum;\n}\n\nint main()\n{\n    while(cin >> n >> k >> s, n|k|s)\n    {\n        cube cs[n];\n        vertex vs[n];\n        for(int i=0; i<n; i++)\n        {\n            int x, y, z;\n            cin >> x >> y >> z;\n            cs[i] = cube(x,y,z);\n            vs[i] = vertex(i);\n            for(int j=0; j<i; j++)\n            {\n                int s = cs[j].intersect(cs[i]);\n                if(s>0)\n                {\n                    vs[j].append(i, s);\n                    vs[i].append(j, s);\n                }\n            }\n        }\n\n        if(k==1)\n        {\n            // k==1?\n            cout << 6 * s * s << endl;\n        }\n        else\n        {\n            // search\n            bool checked[n];\n            int result = -1;\n            for(int i=0; i<n; i++) checked[i] = false;\n            for(int i=0; i<n; i++)\n            {\n                result = max(result, search(i, k, vs, checked));\n            }\n            if(result>=0) result = 6 * s * s * k - result; \n            cout << result << endl;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int INF = 1 << 30;\n\nstruct edge\n{\n  int to, cost;\n};\n\nint main()\n{\n  int N, K, S;\n  int X[2000], Y[2000], Z[2000];\n\n  while(cin >> N >> K >> S, N) {\n    for(int i = 0; i < N; i++) {\n      cin >> X[i] >> Y[i] >> Z[i];\n    }\n\n    vector< edge > g[2000];\n    for(int i = 0; i < N; i++) {\n      for(int j = 0; j < i; j++) {\n        int latte = max(0, S - abs(X[i] - X[j]));\n        int malta = max(0, S - abs(Y[i] - Y[j]));\n        int beeet = max(0, S - abs(Z[i] - Z[j]));\n        int ukuku = latte * malta + malta * beeet + beeet * latte;\n        if(latte > 0 && malta > 0 && beeet > 0) {\n          g[i].emplace_back((edge) {j, ukuku});\n          g[j].emplace_back((edge) {i, ukuku});\n        }\n      }\n    }\n\n    int ret = -1;\n    for(int i = 0; i < N; i++) {\n      bool v[2000] = {};\n      function< void(int, int, int) > dfs = [&](int idx, int k, int sz)\n      {\n        if(v[idx]++) return;\n        if(k == 0) {\n          if(K >= 2) for(auto &e: g[idx]) if(e.to == i) sz += e.cost;\n          ret = max(ret, sz);\n        } else {\n          for(auto &e : g[idx]) dfs(e.to, k - 1, sz + e.cost);\n        }\n      };\n      dfs(i, K - 1, 0);\n    }\n    if(ret == -1) cout << -1 << endl;\n    else cout << 6 * S * S * K - ret * 2 << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, n) for(int i = a; i < n; i++)\nusing namespace std;\nconst int MAX_N = 2010;\nconst int INF = 1e9;\nint d[MAX_N][MAX_N];\nvector<int> G[MAX_N];\nint n, k, s;\n\nint calc(int x1, int y1, int z1, int x2, int y2, int z2){\n    int x = min(x1, x2) + s - max(x1, x2);\n    int y = min(y1, y2) + s - max(y1, y2);\n    int z = min(z1, z2) + s - max(z1, z2);\n    if(x <= 0 || y <= 0 || z <= 0) return 0;\n    int res = 2 * (x * y + y * z + z * x);\n    return res;\n}\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    while(1){\n        cin >> n >> k >> s;\n        if(n + k + s == 0) break;\n        vector<int> x(n), y(n), z(n);\n        rep(i, 0, n){\n            cin >> x[i] >> y[i] >> z[i];\n        }\n        if(n == 1 || k == 1){\n            cout << 6 * s * s << endl;\n            continue;\n        }\n        rep(i, 0, n) rep(j, 0, n) d[i][j] = 0;  \n        rep(i, 0, n) G[i].clear();\n        rep(i, 0, n){\n            rep(j, i + 1, n){\n                d[i][j] = calc(x[i], y[i], z[i], x[j], y[j], z[j]);\n                d[j][i] = d[i][j];\n                if(d[i][j] > 0){\n                    G[i].push_back(j);\n                    G[j].push_back(i);\n                }\n            }\n        }\n        int ans = INF;\n        rep(i, 0, n){\n            rep(j, 0, G[i].size()){\n                int tmp = 0;\n                int now = G[i][j], nxt, pre = i;\n                rep(l, 0, k - 1){\n                    if(now == i){\n                        tmp = INF; break;\n                    }\n                    tmp += d[pre][now];\n                    if(G[now].size() == 1){\n                        if(l == k - 2){\n                            now = pre = -1;\n                        }else{\n                            tmp = INF;\n                        }\n                        break;\n                    }else{\n                        rep(p, 0, G[now].size()){\n                            if(G[now][p] != pre) nxt = G[now][p];\n                        }\n                        pre = now;\n                        now = nxt;\n                    }\n                }\n                if(tmp != INF){\n                    if(now == i) tmp += d[pre][now];\n                    tmp = 6 * s * s * k - tmp;\n                    ans = min(ans, tmp);\n                }\n            }\n        }\n        if(ans == INF) cout << -1 << endl;\n        else cout << ans << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i,n) for(int i = 0;i < (n);i++)\nconst ll INF = 2 * (int)(1e9);\nusing namespace std;\n\nint N, K, S;\n\nstruct Point{\n    int x, y, z;\n};\n\nPoint p[2003];\n\nbool iscycle[2003];\nbool used[2003];\ndeque<int> graph[2003];\n\nint getS(Point a,Point b){\n    if(a.x > b.x) swap(a.x, b.x);\n    if(a.y > b.y) swap(a.y, b.y);\n    if(a.z > b.z) swap(a.z, b.z);\n    return (a.x + S - b.x) * (a.y + S - b.y) * 2\n        +  (a.z + S - b.z) * (a.x + S - b.x) * 2\n        +  (a.y + S - b.y) * (a.z + S - b.z) * 2;\n}\n\nbool connected(int a,int b){\n    REP(_,2){\n        int x2 = p[b].x;\n        int y2 = p[b].y;\n        int z2 = p[b].z;\n        int xs = S, ys = S;\n        REP(i,8){\n            if(i && (i % 4 == 0)){\n                z2 += S;\n            }\n            if(p[a].x <= x2 && x2 <= p[a].x + S\n               && p[a].y <= y2 && y2 <= p[a].y + S\n               && p[a].z <= z2 && z2 <= p[a].z + S){\n                return true;\n            }\n            if(i % 2 == 0){\n                x2 += xs;\n                xs = -xs;\n            }\n            if(i % 2 == 1){\n                y2 += ys;\n                ys = -ys;\n            }\n        }\n        swap(a,b);\n    }\n    return false;\n}\n\nvoid makegraph(int graphct, int i, bool maincalled, bool back){\n    REP(j,N){\n        if(used[j])continue;\n        if(connected(i,j)){\n            used[j] = true;\n            if(graph[graphct].size() > 1 && (maincalled || back)){\n                graph[graphct].push_front(j);\n                makegraph(graphct, j, false, true);\n            }else{\n                graph[graphct].push_back(j);\n                makegraph(graphct, j, false, false);\n            }\n        }\n    }\n}\n\n\nint main(){\n    while(cin >> N >> K >> S, N){\n        REP(i,N){\n            int x, y, z;\n            cin >> x >> y >> z;\n            p[i] = Point{x, y, z};\n            graph[i].clear();\n            iscycle[i] = false;\n            used[i] = false;\n        }\n\n        //make graph\n        int graphct = 0;\n        REP(i,N){\n            if(used[i]) continue;\n            graph[graphct].push_back(i);\n            used[i] = true;\n            makegraph(graphct, i, true, true);\n            graphct++;\n        }\n\n        //cycle check\n        REP(i,graphct){\n            if(graph[i].size() > 2 && connected(graph[i][0],graph[i][graph[i].size() - 1]))\n                iscycle[i] = true;\n        }\n        \n        long long ans = INF;\n        REP(i,graphct){\n            if((int)graph[i].size() < K) continue;\n            REP(j,graph[i].size()){\n                if(j + K - 1 > graph[i].size() - 1) break;\n                long long tmpans = 0;\n                for(int r = 0; r < K;r++){\n                    tmpans += S*S*6;\n                    if(r){\n                        tmpans -= getS(p[graph[i][j + r]], p[graph[i][j + r - 1]]);\n                    }else if(iscycle[i] && K == graph[i].size()){\n                        tmpans -= getS(p[graph[i][0]], p[graph[i][graph[i].size() - 1]]);\n                    }\n                }\n                ans = min(tmpans, ans);\n            }\n        }\n        if(ans == INF) cout << -1 << endl;\n        else cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define all(v) (v).begin(),(v).end()\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\n#define pb push_back\n#define fi first\n#define se second\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nint N,K,S;\nint X[2222][3];\n\nint table[2222][2222];\n\nint f(int a,int b){\n    if(a>b)swap(a,b);\n    return max(0ll,a+S-b);\n}\nvint G[2222];\n\nbool used[2222];\nint dfs(int v,int c){\n    if(c==K){\n        return 0;\n    }\n\n    used[v]=true;\n    int ret=LLONG_MIN;\n    for(auto u:G[v]){\n        if(used[u])continue;\n        int tmp=dfs(u,c+1);\n        if(tmp!=LLONG_MIN)chmax(ret,tmp+table[v][u]);\n    }\n    used[v]=false;\n    return ret;\n}\n\nvoid solve(){\n    rep(i,N)rep(j,3)cin>>X[i][j];\n    memset(table,0,sizeof(table));\n    rep(i,N)G[i].clear();\n    rep(i,N)rep(j,N)if(i!=j){\n        vint v;\n        bool flag=true;\n        rep(k,3){\n            int tmp=f(X[i][k],X[j][k]);\n            if(tmp==0){\n                flag=false;\n            }\n            v.pb(tmp);\n        }\n        if(!flag)continue;\n        G[i].pb(j);\n        rep(k,3)table[i][j]+=v[k]*v[(k+1)%3];\n    }\n\n    memset(used,0,sizeof(used));\n    int ma=LLONG_MIN;\n    rep(i,N){\n        chmax(ma,dfs(i,1));\n    }\n\n    if(ma==LLONG_MIN){\n        cout<<-1<<endl;\n        return;\n    }\n    cout<<(3*S*S*K-ma)*2<<endl;\n}\n\nsigned main(){\n    while(cin>>N>>K>>S,N||K||S)solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nstruct cube{\n  int x,y,z;\n  cube(){}\n  cube(int x,int y,int z):x(x),y(y),z(z){}\n};\n#define MAX 3000\nbool used[MAX];\nint c[MAX][MAX];\nvector<cube> vc;\nvector<int> vi;\nvector<vector<int> > G;\nbool dfs(int v,int p){\n  bool f=false;\n  if(used[v]) return true;\n  vi.push_back(v);used[v]=1;\n  for(int i=0;i<G[v].size();i++) {\n    if(i&&!~p) reverse(vi.begin(),vi.end());\n    if(G[v][i]!=p) f|=dfs(G[v][i],v);\n  }\n  return f;\n}\nint main(){\n  int n,k,s,i,j,l,t;\n  while(cin>>n>>k>>s,n||k||s){\n    int ans=-1;\n    memset(c,0,sizeof(c));\n    G.clear();G.resize(n);\n    vc.clear();vc.resize(n);\n    for(i=0;i<n;i++) cin>>vc[i].x>>vc[i].y>>vc[i].z;\n    for(i=0;i<n;i++){\n      for(j=i+1;j<n;j++){\n        int xx=s-abs(vc[i].x-vc[j].x),\n          yy=s-abs(vc[i].y-vc[j].y),\n          zz=s-abs(vc[i].z-vc[j].z);\n        if(xx>0&&yy>0&&zz>0){\n          G[i].push_back(j);\n          G[j].push_back(i);\n          c[i][j]=c[j][i]=(xx*yy+yy*zz+zz*xx)*2;\n        }\n      }\n    }\n    memset(used,0,sizeof(used));\n    for(i=0;i<n;i++){\n      if(used[i]) continue;\n      vi.clear();\n      bool f=dfs(i,-1);\n      if(vi.size()<k) continue;\n      t=0;\n      if(f){\n        if(vi.size()==k){\n          for(j=0;j<k;j++) t+=c[vi[j]][vi[(j+1)%k]];\n          ans=max(ans,t);\n        }else{\n          for(j=0;j<k-1;j++) t+=c[vi[j]][vi[j+1]];\n          ans=max(ans,t);\n          int si=vi.size();\n          for(j=0;j<si;j++){\n            t+=c[vi[(k-1+j)%si]][vi[(k+j)%si]]-c[vi[j%si]][vi[(j+1)%si]];\n            ans=max(ans,t);\n          } \n        }\n      }else{\n        for(j=0;j<k-1;j++) t+=c[vi[j]][vi[j+1]];\n        ans=max(ans,t);\n        for(j=0;j<vi.size()-k;j++){\n          t+=c[vi[k-1+j]][vi[k+j]]-c[vi[j]][vi[j+1]];\n          ans=max(ans,t);\n        } \n      }\n    }\n    if(~ans) cout << s*s*6*k-ans << endl;\n    else cout << -1 << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int, P > PP;\n\n#define MAX_N 2005\n\nvector<int> G[MAX_N];\nint t[MAX_N][MAX_N];\n\nint N,K,S;\nint x[MAX_N],y[MAX_N],z[MAX_N];\n/*\nbool incheck(int id,int px,int py,int pz){\n  if(x[id]<=px && px<x[id]+S)\n    if(y[id]<=py && py<y[id]+S)\n      if(z[id]<=pz && pz<z[id]+S)\n        return true;\n  return false;\n}\n*/\nint calc(int a,int b){\n  assert(a!=b);\n  int ax=x[a],ay=y[a],az=z[a];\n  int bx=x[b],by=y[b],bz=z[b];\n\n  int XY = max(0, min(ax+S,bx+S)-max(ax,bx) )* max(0, min(ay+S,by+S)-max(ay,by) );\n  XY=S*S*2-XY;\n\n  int YZ = max(0, min(ay+S,by+S)-max(ay,by) )* max(0, min(az+S,bz+S)-max(az,bz) );\n  YZ=S*S*2-YZ;\n\n  int ZX = max(0, min(az+S,bz+S)-max(az,bz) )* max(0, min(ax+S,bx+S)-max(ax,bx) );\n  ZX=S*S*2-ZX;\n\n  return S*S*12-XY*2-YZ*2-ZX*2;\n}\n\nbool isIntersect(int a,int b){\n  if(x[b]+S<=x[a] || x[a]+S<=x[b])return false;\n  if(y[b]+S<=y[a] || y[a]+S<=y[b])return false;\n  if(z[b]+S<=z[a] || z[a]+S<=z[b])return false;\n  return true;\n}\n\n\nvoid init(){\n  for(int i=0;i<MAX_N;i++){\n    G[i].clear();\n  }\n  memset(t,0,sizeof(t));\n}\n\nint Ans,flg;\n\nvoid dfs(int pos,int prev,int sum,int depth,int root){\n\n  if(depth==K){\n    flg=1;\n    for(int i=0;i<(int)G[pos].size();i++){\n      if(root==G[pos][i]){\n        sum+=( t[pos][root] );\n      }\n    }\n    Ans=max(Ans,sum);\n    return;\n  }\n\n  for(int i=0;i<(int)G[pos].size();i++){\n    int to=G[pos][i];\n    if(to==prev)continue;\n    if(to==root)continue;\n    dfs(to,pos,sum+t[pos][to],depth+1,root);\n  }\n}\n\n\n\nint solve(){\n  if(K==1)return S*S*6;\n  if(K==2){\n    int maxm=0;\n    for(int i=0;i<N;i++){\n      for(int j=0;j<N;j++){\n        maxm=max(maxm,t[i][j]);\n      }\n    }\n    if(maxm==0){\n      return -1;\n    }\n    return S*S*12-maxm;\n  }\n  Ans=flg=0;\n  for(int i=0;i<N;i++){\n    dfs(i,-1,0,1,i);\n  }\n  if(Ans==0)return -1;\n  return S*S*6*K-Ans;\n}\n\nint main(){\n  while(1){\n    cin>>N>>K>>S;\n    if(N==0&&K==0&&S==0)break;\n\n    init();\n    for(int i=0;i<N;i++){\n      cin>>x[i]>>y[i]>>z[i];\n      for(int j=0;j<i;j++){\n        assert( x[i]!=x[j] || y[i]!=y[j] || z[i]!=z[j] );\n      }\n    }\n\n\n    for(int i=0;i<N;i++){\n      for(int j=0;j<N;j++){\n        if(i==j)continue;\n\n        if(isIntersect(i,j)){\n          t[i][j]=calc(i,j);\n          G[i].push_back(j);\n        }\n      }\n    }\n    int output=solve();\n    cout<< output <<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <cmath>\n#include <cstdlib>\n#include <map>\nusing namespace std;\n\nclass Point {\npublic:\n    int x, y, z;\n    Point(int x = 0, int y = 0, int z = 0) : x(x), y(y), z(z) {}\n};\n\nclass Cube {\npublic:\n    Point p;\n    int s;\n    int vx[4] = {0, 1, 1, 0}, vy[4] = {0, 0, 1, 1}, vz[2] = {0, 1};\n    Cube(Point p = Point(), int s = 0) : p(p), s(s) {}\n\n    bool isIn(const Cube &c) {\n        /*\n        int nx, ny, nz;\n        for (int i = 0; i < 2; ++i) {\n            for (int j = 0; j < 4; ++j) {\n                nx = c.p.x + c.s * vx[j];\n                ny = c.p.y + c.s * vy[j];\n                nz = c.p.z + c.s * vz[i];\n\n                if (p.x <= nx && nx <= p.x + s &&\n                    p.y <= ny && ny <= p.y + s &&\n                    p.z <= nz && nz <= p.z + s) {\n                        return true;\n                    }\n            }\n        return false;\n        }*/\n        return ((abs(p.x - c.p.x) <= s) && (abs(p.y - c.p.y) <= s) && (abs(p.z - c.p.z) <= s));\n    }\n\n    long long shareS(Cube &c) {\n        long long ret = 0;\n        Point a, b;\n        a = p; b = c.p;\n\n        if (a.x > b.x) swap(a.x, b.x);\n        if (a.y > b.y) swap(a.y, b.y);\n        if (a.z > b.z) swap(a.z, b.z);\n\n        ret += abs((a.x + s - b.x) * (a.z + s - b.z) * 2);\n        ret += abs((a.y + s - b.y) * (a.z + s - b.z) * 2);\n        ret += abs((a.x + s - b.x) * (a.y + s - b.y) * 2);\n        return ret;\n    }\n\n};\n\nint n, k, s, x, y, z;\nlong long ans;\nvector<Cube> c;\nvector<vector<int> > subg;\nvector<bool> used;\nvector<deque<int> > graph;\ndeque<int> que;\n\n// not clever\ninline void makegraph() {\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            if (c[i].isIn(c[j])) {\n                subg[j].push_back(i);\n                subg[i].push_back(j);\n            }\n        }\n    }\n}\n\n// make path\nvoid dfs(int v) {\n    used[v] = true;\n    int size_ = subg[v].size();\n    bool flag = false;\n\n    for (int i = 0; i < size_; ++i) {\n        if (!used[subg[v][i]]) {\n            dfs(subg[v][i]);\n            if (!flag) que.push_front(v);\n            flag = true;\n        }\n    }\n\n    if (!flag) que.push_front(v);\n}\n\n// is graph[graphid] cycle ?\ninline bool isCycle(int graphid) {\n    int size_ = graph[graphid].size();\n\n    // if all vertex's degree are two, this graph is cycle.\n    for (int i = 0; i < size_; ++i) {\n        if (subg[graph[graphid][i]].size() != 2) return false;\n    }\n\n    return true;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    while (cin >> n >> k >> s, n | k | s) {\n        //cout << \"---- begin ----\" << endl;\n        c.resize(n);\n        subg.resize(n);\n        que.clear();\n        used.assign(n, false);\n        ans = int(1e15);\n\n        for (int i = 0; i < n; ++i) {\n            cin >> x >> y >> z;\n            c[i] = {Point(x, y, z), s};    \n        }\n\n        makegraph();\n\n        for (int i = 0; i < n; ++i) {\n            if (!used[i]) {\n                dfs(i);\n                graph.push_back(que);\n                que.clear();\n            }\n        }\n\n        /*\n        for (int i = 0; i < graph.size(); ++i) {\n            for (int j = 0; j < graph[i].size(); ++j) {\n                cout << graph[i][j] << \" \";\n            }\n            cout << endl;\n        }\n        */\n\n        int gsize = graph.size(), qsize, upper;\n        long long share;\n        bool isGraphCycle = false;\n\n        //cout << \"k = \" << k << endl;\n\n        for (int i = 0; i < gsize; ++i) {\n            qsize = graph[i].size();\n            isGraphCycle = isCycle(i);\n            if (isGraphCycle) {\n                upper = qsize + k - 1;\n            }\n            else upper = qsize;\n\n            if (qsize < k) continue;\n\n            for (int j = 0; j + k - 1 < upper; ++j) {\n                share = 0;\n                /*for (int l = 0; l < k - 1; ++l) {\n                    cout << graph[i][(j + l) % qsize] << \" \" << graph[i][(j + l + 1) % qsize] << endl;\n                }*/\n                //cout << graph[i][(j + k - 1) % qsize] << \" \" << graph[i][(j + k) % qsize] << endl;\n                //cout << endl;\n\n                for (int l = 0; l < k - 1; ++l) {\n                    //Cube a = c[graph[i][j + l]],\n                    //    b = c[graph[i][j + l + 1]];\n                    //cout << a.p.x << \" \" << a.p.y << \" \" << a.p.z << endl;\n                    //cout << b.p.x << \" \" << b.p.y << \" \" << b.p.z << endl;\n\n                    share += c[graph[i][(j + l) % qsize]].shareS(c[graph[i][(j + l + 1) % qsize]]);\n\n                    //cout << graph[i][(j + l) % qsize] << \" & \" << graph[i][(j + l + 1) % qsize] << endl;\n                    //cout << \"share is \" << tmp << endl;\n                }\n\n                if (isGraphCycle && qsize == k) {\n                    //cout << \"this is cycle\" << endl;\n                    share += c[graph[i][j]].shareS(c[graph[i][(j + qsize - 1) % qsize]]);\n                }\n\n                ans = min(ans, 6 * s * s * k - share);\n                //cout << \"all - share = \" << 6*s*s*k << endl;\n            }\n        }\n\n        if (n == 1) ans = 6 * s * s;\n        if (ans == int(1e15)) ans = -1;\n\n        cout << ans << endl;\n\n        //cout << \"---- end ----\" << endl;\n\n        c.clear();\n        graph.clear();\n        subg.clear();\n        used.clear();\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <cmath>\n#include <cstdlib>\n#include <map>\nusing namespace std;\n\nclass Point {\npublic:\n  int x, y, z;\n  Point(int x = 0, int y = 0, int z = 0) : x(x), y(y), z(z) {}\n};\n\nclass Cube {\npublic:\n  Point p;\n  int s;\n  int vx[4] = {0, 1, 1, 0}, vy[4] = {0, 0, 1, 1}, vz[2] = {0, 1};\n  Cube(Point p = Point(), int s = 0) : p(p), s(s) {}\n\n  bool isIn(const Cube &c) {\n    int nx, ny, nz;\n\n    for (int i = 0; i < 2; ++i) {\n      for (int j = 0; j < 4; ++j) {\n        nx = c.p.x + c.s * vx[j];\n        ny = c.p.y + c.s * vy[j];\n        nz = c.p.z + c.s * vz[i];\n\n        if (p.x < nx && nx < p.x + s &&\n          p.y < ny && ny < p.y + s &&\n          p.z < nz && nz < p.z + s) {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  }\n\n  long long shareS(Cube &c) {\n    long long ret = 0;\n    Point a, b;\n    a = p; b = c.p;\n\n    if (a.x > b.x) swap(a.x, b.x);\n    if (a.y > b.y) swap(a.y, b.y);\n    if (a.z > b.z) swap(a.z, b.z);\n\n    ret += abs((a.x + s - b.x) * (a.z + s - b.z) * 2);\n    ret += abs((a.y + s - b.y) * (a.z + s - b.z) * 2);\n    ret += abs((a.x + s - b.x) * (a.y + s - b.y) * 2);\n    return ret;\n  }\n\n};\n\nint n, k, s, x, y, z;\nlong long ans;\nvector<Cube> c;\nvector<vector<int> > subg;\nvector<bool> used;\nvector<deque<int> > graph;\ndeque<int> que;\nmap<pair<int, int>, bool> mp, init;\n\n// not clever\ninline void makegraph(int v) {\n  for (int i = 0; i < n; ++i) {\n    if (!mp[make_pair(v, i)] && i != v && c[v].isIn(c[i])) {\n      subg[v].push_back(i);\n      subg[i].push_back(v);\n      mp[make_pair(v, i)] = true;\n      mp[make_pair(i, v)] = true;\n    }\n  }\n}\n\n// make path\nvoid dfs(int v) {\n  used[v] = true;\n  int size_ = subg[v].size();\n  bool flag = false;\n\n  for (int i = 0; i < size_; ++i) {\n    if (!used[subg[v][i]]) {\n      dfs(subg[v][i]);\n      if (!flag) que.push_front(v);\n      flag = true;\n    }\n  }\n\n  if (!flag) que.push_front(v);\n}\n\n// is graph[graphid] cycle ?\ninline bool isCycle(int graphid) {\n  int size_ = graph[graphid].size();\n\n  // if all vertex's degree are two, this graph is cycle.\n  for (int i = 0; i < size_; ++i) {\n    if (subg[graph[graphid][i]].size() != 2) return false;\n  }\n\n  return true;\n}\n\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  while (cin >> n >> k >> s, n | k | s) {\n    //cout << \"---- begin ----\" << endl;\n    c.resize(n);\n    subg.resize(n);\n    que.clear();\n    used.assign(n, false);\n    mp = init;\n    ans = int(1e9);\n\n    for (int i = 0; i < n; ++i) {\n      cin >> x >> y >> z;\n      c[i] = {Point(x, y, z), s};    \n    }\n\n    for (int i = 0; i < n; ++i) {\n      makegraph(i);\n    }\n\n    for (int i = 0; i < n; ++i) {\n      if (!used[i]) {\n        dfs(i);\n        graph.push_back(que);\n        que.clear();\n      }\n    }\n\n    /*\n    for (int i = 0; i < graph.size(); ++i) {\n    for (int j = 0; j < graph[i].size(); ++j) {\n    cout << graph[i][j] << \" \";\n    }\n    cout << endl;\n    }\n    */\n\n    int gsize = graph.size(), qsize, upper;\n    long long share;\n    bool isGraphCycle = false;\n\n    //cout << \"k = \" << k << endl;\n\n    for (int i = 0; i < gsize; ++i) {\n      qsize = graph[i].size();\n      isGraphCycle = isCycle(i);\n      if (isGraphCycle) {\n        upper = qsize + k - 1;\n      }\n      else upper = qsize;\n\n      if (qsize < k) continue;\n\n      for (int j = 0; j + k - 1 < upper; ++j) {\n        share = 0;\n        /*for (int l = 0; l < k - 1; ++l) {\n        cout << graph[i][(j + l) % qsize] << \" \" << graph[i][(j + l + 1) % qsize] << endl;\n        }*/\n        //cout << graph[i][(j + k - 1) % qsize] << \" \" << graph[i][(j + k) % qsize] << endl;\n        //cout << endl;\n\n        for (int l = 0; l < k - 1; ++l) {\n          //Cube a = c[graph[i][j + l]],\n          //    b = c[graph[i][j + l + 1]];\n          //cout << a.p.x << \" \" << a.p.y << \" \" << a.p.z << endl;\n          //cout << b.p.x << \" \" << b.p.y << \" \" << b.p.z << endl;\n\n          share += c[graph[i][(j + l) % qsize]].shareS(c[graph[i][(j + l + 1) % qsize]]);\n\n          //cout << graph[i][(j + l) % qsize] << \" & \" << graph[i][(j + l + 1) % qsize] << endl;\n          //cout << \"share is \" << tmp << endl;\n        }\n\n        if (isGraphCycle && qsize == k) {\n          //cout << \"this is cycle\" << endl;\n          share += c[graph[i][0]].shareS(c[graph[i][qsize - 1]]);\n        }\n\n        ans = min(ans, 6 * s * s * k - share);\n        //cout << \"all - share = \" << 6*s*s*k-share << endl;\n      }\n    }\n\n    if (n == 1) ans = 6 * s * s;\n    if (ans == int(1e9)) ans = -1;\n\n    cout << ans << endl;\n\n    //cout << \"---- end ----\" << endl;\n\n    c.clear();\n    graph.clear();\n    subg.clear();\n    used.clear();\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <math.h>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <bitset>\n#include <algorithm>\nusing namespace std;\n\nstruct xyz_t {\n    int x;\n    int y;\n    int z;\n    double length;       //一乗\n};\n\nstruct first_t {\n    int sec;\n    long long w;\n};\n\nbool asc(const xyz_t& left,const xyz_t& right);\nint next(int p,int q);\nint root(int p);\nvoid unite(int p,int q);\nint same(int p,int q);\nvoid pr(vector<vector<int> > pri);\n\nvector<xyz_t> a;\nvector<int> tree;\nvector<vector<int> > tree_f;\nvector<int> num;\nvector<int> flg;\nlong long ans;\nint n,k,s;\ndouble LE;\nlong long sum;\n\nint main(){\n  scanf (\"%d %d %d\",&n,&k,&s);\n  while(n){\n    ans=0;\n    LE=sqrt(s*s*3.0);\n    xyz_t aaa={0,0,0,0};\n    a.assign(n,aaa);\n    tree.assign(n,-1);\n    tree_f.assign(n,vector<int>(1,0));\n    num.assign(n,1);\n    flg.assign(n,0);\n    for(int t=0;t<n;t++){\n      scanf (\"%d %d %d\",&a[t].x,&a[t].y,&a[t].z);\n      a[t].length=sqrt(a[t].x*a[t].x*1.0+a[t].y*a[t].y*1.0+a[t].z*a[t].z*1.0);\n    }\n    sort(a.begin(),a.end(),asc);\n    for(int i=0;i<n;i++){\n      tree[i]=i;\n    }\n    vector<vector<int> > kaburi(n,vector<int> (n,0));\n    switch(k){\n      case 1:\n        printf(\"%d\\n\",s*s*6);\n        break;\n      case 3:\n        for(int t=0;t<n-1;++t){\n          for(int s=t+1;(a[s].length<a[t].length+LE&&s<n);++s){\n            int xx=next(a[t].x,a[s].x);\n            int yy=next(a[t].y,a[s].y);\n            int zz=next(a[t].z,a[s].z);\n            if(xx&&yy&&zz){\n              if(same(t,s)==0){\n                if(num[s]!=1){\n                  num[t]+=num[tree[s]];\n                  num[tree[s]]=0;\n                  unite(s,t);\n                }\n                else{\n                  num[s]+=num[tree[t]];\n                  num[tree[t]]=0;\n                  unite(t,s);\n                }\n                kaburi[s][t]=xx*yy+yy*zz+zz*xx;\n                kaburi[t][s]=kaburi[s][t];\n                //printf(\"%d %d %d\\n\",kaburi[q].back());\n                //printf(\"%d %d %d\\n\",xx,yy,zz);\n              }\n              else{\n                kaburi[s][t]=xx*yy+yy*zz+zz*xx;\n                kaburi[t][s]=kaburi[s][t];\n                if(num[s]==0){\n                  flg[t]=1;\n                }\n                else{\n                  flg[s]=1;\n                }\n              }\n            }\n          }\n        }\n        //pr(kaburi);\n        for(int t=0;t<n;++t){\n          sum=0;\n          if(num[t]>=k){\n            if(flg[t]==0){\n              int u=t;\n              int v=0;\n              int uu=t;\n              tree_f[t][0]=t;\n              for(int r=0;r<k-1;++r){\n                while(kaburi[u][v]==0||v==uu){\n                  ++v;\n                }\n                sum+=kaburi[u][v];\n                tree_f[t].push_back(v);\n                uu=u;\n                u=v;\n                v=0;\n              }\n              for(int r=k-1;r<num[t]-1;++r){\n                while(kaburi[u][v]==0||v==uu){\n                  ++v;\n                }\n                tree_f[t].push_back(v);\n                uu=u;\n                u=v;\n                v=0;\n              }\n              if(ans<sum){\n                ans=sum;\n              }\n              for(int r=0;r+k<num[t];++r){\n                sum=sum-kaburi[tree_f[t][r]][tree_f[t][r+1]]+kaburi[tree_f[t][r+k-1]][tree_f[t][r+k]];\n\n                if(ans<sum){\n                  ans=sum;\n                }\n              }\n            }\n            else{\n              if(num[t]!=k){\n                int u=t;\n                int v=0;\n                int uu=t;\n                tree_f[t][0]=t;\n                for(int r=0;r<k-1;++r){\n                  while(kaburi[u][v]==0||v==uu){\n                    ++v;\n                  }\n                  sum+=kaburi[u][v];\n                  tree_f[t].push_back(v);\n                  uu=u;\n                  u=v;\n                  v=0;\n                }\n                for(int r=k-1;r<num[t]*2;++r){\n                  while(kaburi[u][v]==0||v==uu){\n                    ++v;\n                  }\n                  tree_f[t].push_back(v);\n                  uu=u;\n                  u=v;\n                  v=0;\n                }\n                if(ans<sum){\n                  ans=sum;\n                }\n                for(int r=0;r<num[t];++r){\n                  sum=sum-kaburi[tree_f[t][r]][tree_f[t][r+1]]+kaburi[tree_f[t][r+k-1]][tree_f[t][r+k]];\n                  if(ans<sum){\n                    ans=sum;\n                  }\n                  //printf(\"%lld\\n\",sum);\n                }\n                //pr(tree_f);\n              }\n              else{\n                if(k!=3){\n                  int u=t;\n                  int v=0;\n                  int uu=t;\n                  tree_f[t][0]=t;\n                  for(int r=0;r<k;++r){\n                    while(kaburi[u][v]==0||v==uu){\n                      ++v;\n                    }\n                    sum+=kaburi[u][v];\n                    uu=u;\n                    u=v;\n                    v=0;\n                  }\n                  if(ans<sum){\n                    ans=sum;\n                  }\n                }\n                else{\n                  int u=t;\n                  int v=0;\n                  int uu=t;\n                  tree_f[t][0]=t;\n                  for(int r=0;r<k;++r){\n                    while(kaburi[u][v]==0||v==uu){\n                      ++v;\n                    }\n                    sum+=kaburi[u][v];\n                    tree_f[t].push_back(v);\n                    uu=u;\n                    u=v;\n                    v=0;\n                  }\n                  int xxx=s+min({a[tree_f[t][0]].x,a[tree_f[t][1]].x,a[tree_f[t][2]].x})-max({a[tree_f[t][0]].x,a[tree_f[t][1]].x,a[tree_f[t][2]].x});\n                  int yyy=s+min({a[tree_f[t][0]].y,a[tree_f[t][1]].y,a[tree_f[t][2]].y})-max({a[tree_f[t][0]].y,a[tree_f[t][1]].y,a[tree_f[t][2]].y});\n                  int zzz=s+min({a[tree_f[t][0]].z,a[tree_f[t][1]].z,a[tree_f[t][2]].z})-max({a[tree_f[t][0]].z,a[tree_f[t][1]].z,a[tree_f[t][2]].z});\n                  sum=sum-(xxx*yyy+yyy*zzz+zzz*xxx);\n                  if(ans<sum){\n                    ans=sum;\n                  }\n                }\n              }\n            }\n          }\n        }\n        if(ans==0){\n          printf(\"-1\\n\");\n        }\n        else{\n          printf(\"%lld\\n\",s*s*6*k-ans*2);\n        }\n        break;\n      default:\n        for(int t=0;t<n-1;++t){\n          for(int s=t+1;(a[s].length<a[t].length+LE&&s<n);++s){\n            int xx=next(a[t].x,a[s].x);\n            int yy=next(a[t].y,a[s].y);\n            int zz=next(a[t].z,a[s].z);\n            if(xx&&yy&&zz){\n              if(same(t,s)==0){\n                if(num[s]!=1){\n                  num[t]+=num[tree[s]];\n                  num[tree[s]]=0;\n                  unite(s,t);\n                }\n                else{\n                  num[s]+=num[tree[t]];\n                  num[tree[t]]=0;\n                  unite(t,s);\n                }\n                kaburi[s][t]=xx*yy+yy*zz+zz*xx;\n                kaburi[t][s]=kaburi[s][t];\n                //printf(\"%d %d %d\\n\",kaburi[q].back());\n                //printf(\"%d %d %d\\n\",xx,yy,zz);\n              }\n              else{\n                kaburi[s][t]=xx*yy+yy*zz+zz*xx;\n                kaburi[t][s]=kaburi[s][t];\n                if(num[s]==0){\n                  flg[t]=1;\n                }\n                else{\n                  flg[s]=1;\n                }\n              }\n            }\n          }\n        }\n        //pr(kaburi);\n        for(int t=0;t<n;++t){\n          sum=0;\n          if(num[t]>=k){\n            if(flg[t]==0){\n              int u=t;\n              int v=0;\n              int uu=t;\n              tree_f[t][0]=t;\n              for(int r=0;r<k-1;++r){\n                while(kaburi[u][v]==0||v==uu){\n                  ++v;\n                }\n                sum+=kaburi[u][v];\n                tree_f[t].push_back(v);\n                uu=u;\n                u=v;\n                v=0;\n              }\n              for(int r=k-1;r<num[t]-1;++r){\n                while(kaburi[u][v]==0||v==uu){\n                  ++v;\n                }\n                tree_f[t].push_back(v);\n                uu=u;\n                u=v;\n                v=0;\n              }\n              if(ans<sum){\n                ans=sum;\n              }\n              for(int r=0;r+k<num[t];++r){\n                sum=sum-kaburi[tree_f[t][r]][tree_f[t][r+1]]+kaburi[tree_f[t][r+k-1]][tree_f[t][r+k]];\n\n                if(ans<sum){\n                  ans=sum;\n                }\n              }\n            }\n            else{\n              if(num[t]!=k){\n                int u=t;\n                int v=0;\n                int uu=t;\n                tree_f[t][0]=t;\n                for(int r=0;r<k-1;++r){\n                  while(kaburi[u][v]==0||v==uu){\n                    ++v;\n                  }\n                  sum+=kaburi[u][v];\n                  tree_f[t].push_back(v);\n                  uu=u;\n                  u=v;\n                  v=0;\n                }\n                for(int r=k-1;r<num[t]*2;++r){\n                  while(kaburi[u][v]==0||v==uu){\n                    ++v;\n                  }\n                  tree_f[t].push_back(v);\n                  uu=u;\n                  u=v;\n                  v=0;\n                }\n                if(ans<sum){\n                  ans=sum;\n                }\n                for(int r=0;r<num[t];++r){\n                  sum=sum-kaburi[tree_f[t][r]][tree_f[t][r+1]]+kaburi[tree_f[t][r+k-1]][tree_f[t][r+k]];\n                  if(ans<sum){\n                    ans=sum;\n                  }\n                  //printf(\"%lld\\n\",sum);\n                }\n                //pr(tree_f);\n              }\n              else{\n                int u=t;\n                int v=0;\n                int uu=t;\n                tree_f[t][0]=t;\n                for(int r=0;r<k;++r){\n                  while(kaburi[u][v]==0||v==uu){\n                    ++v;\n                  }\n                  sum+=kaburi[u][v];\n                  uu=u;\n                  u=v;\n                  v=0;\n                }\n                if(ans<sum){\n                  ans=sum;\n                }\n              }\n            }\n          }\n        }\n        if(ans==0){\n          printf(\"-1\\n\");\n        }\n        else{\n          printf(\"%lld\\n\",s*s*6*k-ans*2);\n        }\n    }\n    scanf (\"%d %d %d\",&n,&k,&s);\n  }\n}\n/*\n環状 k=3の時 それ以外の時\n\n\n*/\n\n\nbool asc(const xyz_t& left,const xyz_t& right){\n  return left.length<right.length;\n}\n\nint next(int p,int q){\n  if(-s<=(p-q)&&(p-q)<=s){\n    if((p-q)>=0){\n      return s-(p-q);\n    }\n    else{\n      return s-(q-p);\n    }\n  }\n  else{\n    return 0;\n  }\n}\n\nint root(int p){\n  if (tree[p] == p){// 根\n    return p;\n  }\n  else {\n    return tree[p] = root(tree[p]); // 経路圧縮\n  }\n}\n\nvoid unite(int p, int q){\n  p = root(p);\n  q = root(q);\n  if (p == q){}\n  else{\n    tree[p] = q;     //pの親をqの親にする\n  }\n}\n\nint same(int p, int q){\n  return root(p) == root(q);\n}\n\n\n\nvoid pr(vector<vector<int> > pri){\n  for(int t=0;t<int(pri.size());++t){\n    for(int s=0;s<int(pri[t].size())-1;++s){\n      printf(\"%d \",pri[t][s]);\n    }\n    printf(\"%d\\n\",pri[t][pri[t].size()-1]);\n  }\n  printf(\"\\n\");\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 2001\n#define int long long\nusing namespace std;\nvector<int>G[N];\nint n,K,S;\nstruct point{int x,y,z;};\n\nint Area(){return S*S*6;}\nint sArea(point a,point b){\n  int x = min(a.x+S, b.x+S), X = max(a.x, b.x);\n  int y = min(a.y+S, b.y+S), Y = max(a.y, b.y);\n  int z = min(a.z+S, b.z+S), Z = max(a.z, b.z);\n  if(y <= Y || x <= X || z <= Z) return 0;\n  int area=0;\n  area += 2*(x-X)*(y-Y);\n  area += 2*(y-Y)*(z-Z);\n  area += 2*(z-Z)*(x-X);\n  return area;\n}\n\nvector<point> A;\nint dfs(int pos,int k,int start,int prev){\n  if(prev!=-1 && pos==start) return 1LL<<55;\n  if(k == K) return prev==-1||prev==start? 0:-sArea(A[pos],A[start]);\n  \n  int res = 1e9;\n  for(int nx:G[pos]){\n    if(nx == prev)continue;\n    int area = Area() - sArea(A[pos],A[nx]);\n    res = min(res,area+dfs(nx,k+1,start,pos));\n  }\n  return res;\n}\n\nsigned main(){\n  while(1){\n    cin>>n>>K>>S;\n    if(!n&&!K&&!S)break;\n    \n    A.resize(n);\n    for(int i=0;i<n;i++)cin>>A[i].x>>A[i].y>>A[i].z;\n    for(int i=0;i<N;i++) G[i].clear();\n\n    for(int i=0;i<n;i++)\n      for(int j=i+1;j<n;j++){\n\tif(!sArea(A[i],A[j]))continue;\n\tG[i].push_back(j);\n\tG[j].push_back(i);\n      }\n\n    int ans = 1e9;\n    for(int i=0;i<n;i++)ans = min(ans,Area()+dfs(i,1,i,-1));\n    if(ans == 1e9) ans = -1;\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint INF = 1e9;\n\nint xyz[2010][3];\nint d[2010][2010];\nbool ch[2010];\n\nint main(){\n    int n,k,s;\n\n    while(true){\n        cin >> n >> k >> s;\n        int plus = (s*s) * 6;\n        if(n == 0)break;\n\n        vector<int> G[2010];\n        int ans = INF;\n        for(int i = 0;i < n;i++){\n            ch[i] = false;\n            for(int j = 0;j < 3;j++){\n                cin >> xyz[i][j];\n            }\n        }\n\n        if(k == 1){\n            cout << (s*s)*6 << endl;\n            continue;\n        }   \n        for(int i = 0;i < n;i++){\n            for(int j = 0;j < n;j++){\n                d[i][j] = -1;\n            }\n        }    \n        for(int i = 0;i < n;i++){\n            for(int j = 0;j < n;j++){\n                if(i == j) continue;\n                if(xyz[i][2] > xyz[j][2])continue;\n                if(xyz[i][2] == xyz[j][2] && i > j)continue;\n\n                if(xyz[i][2]+s >= xyz[j][2] && xyz[i][0]-s <= xyz[j][0] && xyz[i][0]+s >= xyz[j][0]\n                    && xyz[i][1]-s <= xyz[j][1] && xyz[i][1]+s >= xyz[j][1]){\n                        G[i].push_back(j);\n                        G[j].push_back(i);\n                        int xx;\n                        int yy;\n                        if(xyz[i][0] < xyz[j][0]){\n                            xx = xyz[i][0]+s - xyz[j][0];\n                        }else{\n                            xx = xyz[j][0]+s - xyz[i][0];\n                        }\n                        if(xyz[i][1] < xyz[j][1]){\n                            yy = xyz[i][1]+s-xyz[j][1];\n                        }else{\n                            yy = xyz[j][1]+s-xyz[i][1];\n                        }\n                        int zz = xyz[i][2]+s-xyz[j][2];\n                       \n                        d[i][j] = 2 * ( xx*zz + yy*zz + xx*yy);\n                        d[j][i] = d[i][j];\n                    }\n            }\n        }\n\n        for(int i = 0;i < n;i++){\n            if(ch[i] == true)continue;\n            if(G[i].size() == 1){\n                ch[i] = true;\n                int now = i;\n                int pre = -1;\n                int count = 1;\n                int sum = plus;\n                queue<int> que;\n                while(true){\n                    if(count == k){\n                        ans = min(ans,sum);\n                        bool flag = true;\n                        for(int j = 0;j < G[now].size();j++){\n                            if(pre != G[now][j] && ch[G[now][j]] == false){\n                                pre = now;\n                                now = G[pre][j];\n                                ch[now] = true;\n                                flag = false;\n                                break;\n                            }\n                        }\n                        if(flag)break;\n                        int q = que.front(); que.pop();\n                        que.push(d[pre][now]);\n                        sum += q;\n                        sum -= d[pre][now];\n                        ans = min(ans,sum);\n                    }else{\n                        sum += plus;\n                        count++;\n                        bool flag = true;\n                        for(int j = 0;j < G[now].size();j++){\n                            if(pre != G[now][j] && ch[G[now][j]] == false){\n                                pre = now;\n                                now = G[pre][j];\n                                ch[now] = true;\n                                flag = false;\n                                break;\n                            }\n                        }\n                        if(flag)break;\n                        que.push(d[pre][now]);\n                        sum -= d[pre][now];\n                    }\n                }\n            }\n        }\n        \n        for(int i = 0;i < n;i++){\n            if(ch[i] == true)continue;\n            if(G[i].size() != 2)continue;\n            ch[i] = true;\n            int count = 1;\n            int now = i;\n            int pre = -1;\n            int sum = (s*s)*6;\n            queue<int> que;\n            queue<int> num;\n            num.push(-1);\n            while(true){\n                if(count == k){\n                    ans = min(ans,sum);\n                    int q = num.front(); num.pop();\n                    if(q == -1 && d[now][i] != -1 && k != 2){\n                        ans = min(ans,sum-d[now][i]);\n                        break;\n                    } \n                    if(q == i)break;\n                    for(int j = 0;j < G[now].size();j++){\n                        if(pre != G[now][j]){\n                            pre = now;\n                            now = G[pre][j];\n                            que.push(d[now][pre]);\n                            num.push(now);\n                            ch[now] = true;\n                            break;\n                        }\n                    }\n                    q = que.front(); que.pop();\n                    sum += q;\n                    sum -= d[now][pre];\n                    ans = min(ans,sum);\n                }else{\n                    count++;\n                    bool endflag = false;\n                    for(int j = 0;j < G[now].size();j++){\n                        if(pre != G[now][j]){\n                            \n                            pre = now;\n                            now = G[pre][j];\n                            if(now == i){\n                                endflag = true;\n                                break;\n                            }\n                            que.push(d[now][pre]);\n                            num.push(now);\n                            ch[now] = true;\n                            break;\n                        }\n                    }\n                    if(endflag)break;\n                    sum += plus;\n                    sum -= d[now][pre];\n                }\n            }\n        }\n        if(ans == INF){\n            cout << -1 << endl;\n        }else{\n            cout << ans << endl;\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define dbg(...) do{cerr<<__LINE__<<\": \";dbgprint(#__VA_ARGS__, __VA_ARGS__);}while(0);\n\nusing namespace std;\n\nnamespace std{template<class S,class T>struct hash<pair<S,T>>{size_t operator()(const pair<S,T>&p)const{return ((size_t)1e9+7)*hash<S>()(p.first)+hash<T>()(p.second);}};template<class T>struct hash<vector<T>>{size_t operator()(const vector<T> &v)const{size_t h=0;for(auto i : v)h=h*((size_t)1e9+7)+hash<T>()(i)+1;return h;}};}\ntemplate<class T>ostream& operator<<(ostream &os, const vector<T> &v){os<<\"[ \";rep(i,v.size())os<<v[i]<<(i==v.size()-1?\" ]\":\", \");return os;}template<class T>ostream& operator<<(ostream &os,const set<T> &v){os<<\"{ \"; for(const auto &i:v)os<<i<<\", \";return os<<\"}\";}\ntemplate<class T,class U>ostream& operator<<(ostream &os,const map<T,U> &v){os<<\"{\";for(const auto &i:v)os<<\" \"<<i.first<<\": \"<<i.second<<\",\";return os<<\"}\";}template<class T,class U>ostream& operator<<(ostream &os,const pair<T,U> &p){return os<<\"(\"<<p.first<<\", \"<<p.second<<\")\";}\nvoid dbgprint(const string &fmt){cerr<<endl;}template<class H,class... T>void dbgprint(const string &fmt,const H &h,const T&... r){cerr<<fmt.substr(0,fmt.find(\",\"))<<\"= \"<<h<<\" \";dbgprint(fmt.substr(fmt.find(\",\")+1),r...);}\ntypedef long long ll;typedef vector<int> vi;typedef pair<int,int> pi;const int inf = (int)1e9;const double INF = 1e12, EPS = 1e-9;\n\nint main(){\n\tcin.tie(0); cin.sync_with_stdio(0);\n\tint n, k, s;\n\twhile(cin >> n >> k >> s, n){\n\t\tvi x(n), y(n), z(n);\n\t\trep(i, n) cin >> x[i] >> y[i] >> z[i];\n\t\t\n\t\tauto intersect = [&](int i, int j){\n\t\t\tll dx = s - abs(x[i] - x[j]);\n\t\t\tll dy = s - abs(y[i] - y[j]);\n\t\t\tll dz = s - abs(z[i] - z[j]);\n\t\t\tif(dx <= 0 || dy <= 0 || dz <= 0) return 0ll;\n\t\t\treturn (dx * dy + dy * dz + dz * dx) * 2;\n\t\t};\n\t\t\n\t\tvector<vi> e(n);\n\t\trep(i, n) rep(j, i) if(intersect(i, j)){\n\t\t\te[i].pb(j);\n\t\t\te[j].pb(i);\n\t\t\t//dbg(i, j);\n\t\t}\n\t\trep(i, n) assert(e[i].size() <= 2);\n\t\t\n\t\tfunction<bool(int,int,vector<bool>&,vi&)> rec = [&](int c, int p, vector<bool> &v, vi &idx){\n\t\t\tv[c] = 1;\n\t\t\tbool ans = 0;\n\t\t\tidx.pb(c);\n\t\t\tfor(int i : e[c]) if(i != p){\n\t\t\t\tif(v[i]) ans |= 1;\n\t\t\t\telse ans |= rec(i, c, v, idx); \n\t\t\t}\n\t\t\treturn ans;\n\t\t};\n\t\t\n\t\tll ans = 1e18;\n\t\tvector<bool> v(n);\n\t\trep(ii, n) if(!v[ii]){\n\t\t\tvi idx;\n\t\t\tbool loop = rec(ii, ii, v, idx);\n\t\t\tif(idx.size() < k) continue;\n\t\t\t\n\t\t\tif(loop && idx.size() == k){\n\t\t\t\tll sum = 6ll * k * s * s;\n\t\t\t\trep(i, (int)idx.size()){\n\t\t\t\t\tll c = intersect(idx[i], idx[(i + 1) % idx.size()]);\n\t\t\t\t\tsum -= c;\n\t\t\t\t}\n\t\t\t\tans = min(ans, sum);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tll sum = 6ll * k * s * s;\n\t\t\tif(k == 1){\n\t\t\t\tans = min(ans, sum);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tvector<ll> costs;\n\t\t\tif(loop){\n\t\t\t\trep(i, (int)idx.size())\n\t\t\t\t\tcosts.pb(intersect(idx[i], idx[(i + 1) % idx.size()]));\n\t\t\t\tint it = idx.size();\n\t\t\t\trep(i, it) idx.pb(idx[i]);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tint hasi = 0;\n\t\t\t\trep(i, idx.size()) if(e[idx[i]].size() == 1) hasi = idx[i];\n\t\t\t\tfor(int i : idx) v[i] = 0;\n\t\t\t\tidx.clear();\n\t\t\t\trec(hasi, hasi, v, idx);\n\t\t\t\t\n\t\t\t\trep(i, (int)idx.size()-1)\n\t\t\t\t\tcosts.pb(intersect(idx[i], idx[i + 1]));\n\t\t\t\t#if 1\n\t\t\t\tassert(idx.size() >= 2);\n\t\t\t\trep(i, idx.size()){\n\t\t\t\t\t//if(i==0 || i==idx.size()-1) assert(e[idx[i]].size() <= 1);\n\t\t\t\t\t//else assert(e[idx[i]].size()==2);\n\t\t\t\t\tassert(e[idx[i]].size() <= 2);\n\t\t\t\t\tassert(e[idx[i]].size() >= 1);\n\t\t\t\t}\n\t\t\t\t#endif\n\t\t\t}\n\t\t\t//dbg(k, costs);\n\t\t\t\n\t\t\trep(i, k-2) sum -= costs[i];\n\t\t\trep(i, (int)costs.size() - (k-1) + 1){\n\t\t\t\tsum -= costs[i + k-2];\n\t\t\t\tans = min(ans, sum);\n\t\t\t\tsum += costs[i];\n\t\t\t}\n\t\t}\n\t\tif(ans >= 1e18) ans = -1;\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nclass Solve {\nprivate:\n\tusing vpi = std::vector<std::pair<int, int64_t>>;\n\tusing i3 = std::array<int, 3>;\n\tusing vi64 = std::vector<int64_t>;\n\n\tint n, k, s;\n\tstd::vector<i3> box;\n\tstd::vector<vpi> edge;\n\tstd::vector<bool> visited;\n\n\tbool areAdjacent(int a, int b)\n\t{\n\t\tfor (int i{}; i < 3; i++)\n\t\t\tif (std::abs(box[a][i] - box[b][i]) >= s)\n\t\t\t\treturn false;\n\t\treturn true;\n\t}\n\n\tint64_t calcWeight(int a, int b)\n\t{\n\t\tint64_t sum{};\n\t\tfor (int i{}; i < 3; i++)\n\t\t\tsum += 2 * (s - std::abs(box[a][i] - box[b][i])) * (s - std::abs(box[a][(i + 1) % 3] - box[b][(i + 1) % 3]));\n\t\treturn sum;\n\t}\n\n\tvoid makeLine(int index, vi64& table)\n\t{\n\t\tvisited[index] = true;\n\t\tfor (auto& e: edge[index])\n\t\t\tif (!visited[e.first])\n\t\t\t{\n\t\t\t\ttable.push_back(e.second + table.back());\n\t\t\t\tmakeLine(e.first, table);\n\t\t\t}\n\t}\n\n\tvoid makeCircle(int index, int begin, int prev, vi64& table)\n\t{\n\t\tvisited[index] = true;\n\t\tfor (auto& e: edge[index])\n\t\t\tif (!visited[e.first] || (prev != begin && e.first == begin))\n\t\t\t{\n\t\t\t\ttable.push_back(e.second + table.back());\n\t\t\t\tmakeCircle(e.first, begin, index, table);\n\t\t\t}\n\t}\n\npublic:\n\tbool is_last_query{};\n\tSolve()\n\t{\n\t\tscanf(\"%d%d%d\", &n, &k, &s);\n\t\tif (n == 0)\n\t\t{\n\t\t\tis_last_query = true;\n\t\t\treturn;\n\t\t}\n\t\tbox.resize(n);\n\t\tfor (auto& e: box)\n\t\t\tfor (auto& f: e)\n\t\t\t\tscanf(\"%d\", &f);\n\t\t\n\t\tedge.resize(n);\n\t\tfor (int i{}; i < n; i++)\n\t\t\tfor (int j{i + 1}; j < n; j++)\n\t\t\t\tif (areAdjacent(i, j))\n\t\t\t\t{\n\t\t\t\t\tint64_t weight{calcWeight(i, j)};\n\t\t\t\t\tedge[i].push_back({j, weight});\n\t\t\t\t\tedge[j].push_back({i, weight});\n\t\t\t\t}\n\t\t\n\t\tvisited.resize(n);\n\t\tint64_t max{-1};\n\t\tfor (int i{}; i < n; i++)\n\t\t{\n\t\t\tif (visited[i] || edge[i].size() == 2) continue;\n\t\t\tvi64 table(1);\n\t\t\tmakeLine(i, table);\n\t\t\tfor (int j{k - 1}; j < (int)table.size(); j++)\n\t\t\t\tmax = std::max(max, table[j] - table[j - (k - 1)]);\n\t\t}\n\t\tfor (int i{}; i < n; i++)\n\t\t{\n\t\t\tif (visited[i]) continue;\n\t\t\tvi64 table(1);\n\t\t\tmakeCircle(i, i, -1, table);\n\t\t\tif (table.size() < k) continue;\n\t\t\tif (table.size() == k + 1)\n\t\t\t\tmax = std::max(max, table.back());\n\t\t\telse\n\t\t\t{\n\t\t\t\tint size{(int)table.size()};\n\t\t\t\tfor (int i{1}; i < size; i++)\n\t\t\t\t\ttable.push_back(table[size - 1] + table[i]);\n\t\t\t\tfor (int j{k - 1}; j < (int)table.size(); j++)\n\t\t\t\t\tmax = std::max(max, table[j] - table[j - (k - 1)]);\n\t\t\t}\n\t\t}\n\t\tif (max == -1) puts(\"-1\");\n\t\telse printf(\"%lld\\n\", (int64_t)6 * s * s * k - max);\n\t}\n};\n\nint main()\n{\n\twhile (!Solve().is_last_query);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i,n) for(int i = 0;i < (n);i++)\nconst int INF = 1e9;\nusing namespace std;\n\nint N, K, S;\n\nstruct Point{\n    int x, y, z;\n};\n\nPoint p[2003];\n\nbool iscycle[2003];\nbool used[2003];\ndeque<int> graph[2003];\n\nint getS(Point a,Point b){\n    if(a.x > b.x) swap(a.x, b.x);\n    if(a.y > b.y) swap(a.y, b.y);\n    if(a.z > b.z) swap(a.z, b.z);\n    return (a.x + S - b.x) * (a.y + S - b.y) * 2\n        +  (a.z + S - b.z) * (a.x + S - b.x) * 2\n        +  (a.y + S - b.y) * (a.z + S - b.z) * 2;\n}\n\nbool connected(int a,int b){\n    REP(_,2){\n        int x2 = p[b].x;\n        int y2 = p[b].y;\n        int z2 = p[b].z;\n        int xs = S, ys = S;\n        REP(i,8){\n            if(i && (i % 4 == 0)){\n                z2 += S;\n            }\n            if(p[a].x <= x2 && x2 <= p[a].x + S\n               && p[a].y <= y2 && y2 <= p[a].y + S\n               && p[a].z <= z2 && z2 <= p[a].z + S){\n                return true;\n            }\n            if(i % 2 == 0){\n                x2 += xs;\n                xs = -xs;\n            }\n            if(i % 2 == 1){\n                y2 += ys;\n                ys = -ys;\n            }\n        }\n        swap(a,b);\n    }\n    return false;\n}\n\nvoid makegraph(int graphct, int i, bool maincalled, bool back){\n    REP(j,N){\n        if(used[j])continue;\n        if(connected(i,j)){\n            used[j] = true;\n            if(graph[graphct].size() > 1 && (maincalled || back)){\n                graph[graphct].push_front(j);\n                makegraph(graphct, j, false, true);\n            }else{\n                graph[graphct].push_back(j);\n                makegraph(graphct, j, false, false);\n            }\n        }\n    }\n}\n\n\nint main(){\n    while(cin >> N >> K >> S, N){\n        REP(i,N){\n            int x, y, z;\n            cin >> x >> y >> z;\n            p[i] = Point{x, y, z};\n            graph[i].clear();\n            iscycle[i] = false;\n            used[i] = false;\n        }\n\n        //make graph\n        int graphct = 0;\n        REP(i,N){\n            if(used[i]) continue;\n            graph[graphct].push_back(i);\n            used[i] = true;\n            makegraph(graphct, i, true, true);\n            graphct++;\n        }\n\n        //cycle check\n        REP(i,graphct){\n            if(graph[i].size() > 1 && connected(graph[i][0],graph[i][graph[i].size() - 1]))\n                iscycle[i] = true;\n        }\n        \n        int ans = INF;\n        REP(i,graphct){\n            if((int)graph[i].size() < K) continue;\n            REP(j,graph[i].size()){\n                if(j + K - 1 > graph[i].size() - 1) continue;\n                int tmpans = 0;\n                for(int r = 0; r < K;r++){\n                    tmpans += S*S*6;\n                    if(r){\n                        tmpans -= getS(p[graph[i][j + r]], p[graph[i][j + r - 1]]);\n                    }else if(iscycle[i] && K == graph[i].size()){\n                        tmpans -= getS(p[graph[i][0]], p[graph[i][graph[i].size() - 1]]);\n                    }\n                }\n                ans = min(tmpans, ans);\n            }\n        }\n        if(ans == INF) cout << -1 << endl;\n        else cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\nusing namespace std;\n\n#define rep(i,a,n) for(int (i)=(a); (i)<(n); (i)++)\n#define repq(i,a,n) for(int (i)=(a); (i)<=(n); (i)++)\n#define repr(i,a,n) for(int (i)=(a); (i)>=(n); (i)--)\n#define all(v) begin(v), end(v)\n#define pb(a) push_back(a)\n#define fr first\n#define sc second\n#define INF 2000000000\n#define int long long int\n\n#define X real()\n#define Y imag()\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a) - (b)) < EPS)\n#define EQV(a,b) ( EQ((a).X, (b).X) && EQ((a).Y, (b).Y) )\n#define LE(n, m) ((n) < (m) + EPS)\n#define LEQ(n, m) ((n) <= (m) + EPS)\n#define GE(n, m) ((n) + EPS > (m))\n#define GEQ(n, m) ((n) + EPS >= (m))\n\ntypedef vector<int> VI;\ntypedef vector<VI> MAT;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\ntypedef complex<double> P;\ntypedef pair<P, P> L;\ntypedef pair<P, double> C;\n\nint dx[] = {1, 1, 0, 0, 1, 1, 0, 0};\nint dy[] = {1, 0, 1, 0, 1, 0, 1, 0};\nint dz[] = {0, 0, 0, 0, 1, 1, 1, 1};\nint const MOD = 1000000007;\n\nnamespace std {\n    bool operator<(const P& a, const P& b) {\n        return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n    }\n}\n\n// Union-Find ??¨ (Verified: AtCoder Typical Contest 001 B)\nstruct UnionFind {\nprivate:\n    const int n;\n    int __size;\n    vector<int> uf;\npublic:\n    // ????????? UnionFind uni(n) ??????????????£?¨?????????°??????\n    UnionFind(int _n) : n(_n), __size(_n), uf(_n, -1) {}\n    // find (??¨??????????±???????)\n    int find(int x) {return (uf[x] < 0) ? x : uf[x] = find(uf[x]);}\n    // x ??¨ y ???????????????????±???????????????????\n    bool same(int x, int y) {return find(x) == find(y);}\n    // x ????±????????????????????´???°\n    int size(int x) {return -uf[find(x)];}\n    // ???????????????????????????\n    int size()      {return __size;}\n    // x ??¨ y ????±??????????????????????\n    void unite(int x, int y) {\n        x = find(x); y = find(y);\n        if(x == y) return;\n        __size--;\n        if(uf[y] < uf[x]) swap(x, y);\n        uf[x] += uf[y]; uf[y] = x;\n    }\n};\n\n// ?§?????????¨????????¨???????????????????¨???????????§???????\ntemplate <typename T>\nstruct Edge {\n    int from, to;\n    T cost;\n    Edge(int s, T d) : to(s), cost(d) {}\n    Edge(int f, int s, T d) : from(f), to(s), cost(d) {}\n\n    bool operator<(const Edge &e) const {\n        return cost < e.cost;\n    }\n    bool operator>(const Edge &e) const {\n        return cost > e.cost;\n    }\n};\n#define Graph(type) vector< vector< Edge<type> > >\n\nbool incube(int a, int b, int x) {\n    return a <= x && x <= b;\n}\n\nint n, k, s;\nint x[1010], y[1010], z[1010];\nint temp, ans;\nvoid dfs(int p, Graph(int) &G, set<pii> S, set<int> T, int counter, int cur) {\n    T.insert(p);\n    rep(i,0,G[p].size()) {\n        int next = G[p][i].to;\n        if(counter == k && !T.count(next)) continue;\n        int mi = min(p, next), ma = max(p, next);\n        pii pr = pii(mi, ma);\n        if(S.count(pr)) continue;\n        int xx, yy, zz;\n        xx = min(x[p], x[next]) - max(x[p], x[next]) + s;\n        yy = min(y[p], y[next]) - max(y[p], y[next]) + s;\n        zz = min(z[p], z[next]) - max(z[p], z[next]) + s;\n        S.insert(pr);\n        cur -= 2 * (xx * yy + yy * zz + zz * xx);\n        // printf(\"p = %lld, next = %lld, cur = %lld\\n\", p, next, cur);\n        dfs(next, G, S, T, counter+1, cur);\n        S.erase(pr);\n        cur += 2 * (xx * yy + yy * zz + zz * xx);\n    }\n    if(counter >= k) {\n        // printf(\"cur = %lld\\n\", cur);\n        ans = min(ans, cur);\n        return;\n    }\n}\n\nsigned main() {\n    while(cin >> n >> k >> s, n || k || s) {\n        UnionFind uf(n);\n        Graph(int) G(n);\n        rep(i,0,n) {\n            cin >> x[i] >> y[i] >> z[i];\n        }\n        set<pii> edgepair;\n        rep(i,0,n) rep(j,0,n) {\n            if(i == j) continue;\n            pii temppair = pii( min(i,j), max(i,j) );\n            if(edgepair.count(temppair)) continue;\n            bool ok = false;\n            rep(k,0,8) {\n                if(ok) break;\n                if(incube(x[i], x[i]+s, x[j]+dx[k]*s) && incube(y[i], y[i]+s, y[j]+dy[k]*s) && incube(z[i], z[i]+s, z[j]+dz[k]*s)) {\n                    // printf(\"incube: i = %lld, j = %lld\\n\", i, j);\n                    uf.unite(i, j);\n                    G[i].pb(Edge<int>(j,1));\n                    G[j].pb(Edge<int>(i,1));\n                    edgepair.insert(temppair);\n                    ok = true;\n                }\n            }\n        }\n\n        ans = (int)1e18;\n        rep(i,0,n) {\n            // printf(\"uf.size(%lld) = %lld\\n\", i, uf.size(i));\n            if(uf.size(i) >= k) {\n                temp = 6 * s * s * k;\n                set<pii> S;\n                set<int> T;\n                dfs(i, G, S, T, 1, temp);\n            }\n        }\n        if(ans != (int)1e18) cout << ans << endl;\n        else cout << -1 << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cstring>\nusing namespace std;\nusing ll = long long;\n\nstruct Cube{\n    ll lx, rx;\n    ll ly, ry;\n    ll lz, rz;\n    ll S(){\n        ll dx = rx - lx;\n        ll dy = ry - ly;\n        ll dz = rz - lz;\n        return (dx * dy + dy * dz + dz * dx) * 2;\n    } \n};\n\nll f(Cube c1, Cube c2){\n    ll L[3][2] = {{c1.lx, c2.lx}, {c1.ly, c2.ly}, {c1.lz, c2.lz}};\n    ll R[3][2] = {{c1.rx, c2.rx}, {c1.ry, c2.ry}, {c1.rz, c2.rz}};\n    ll LX, LY, LZ, RX, RY, RZ;\n    ll sum = 0;\n    LX = max(c1.lx, c2.lx);\n    RX = min(c1.rx, c2.rx);\n    LY = max(c1.ly, c2.ly);\n    RY = min(c1.ry, c2.ry);\n    LZ = max(c1.lz, c2.lz);\n    RZ = min(c1.rz, c2.rz);\n    if(RX <= LX) return 0;\n    if(RY <= LY) return 0;\n    if(RZ <= LZ) return 0;\n    ll dx = RX - LX;\n    ll dy = RY - LY;\n    ll dz = RZ - LZ;\n    return (dx * dy + dy * dz + dz * dx) * 2;\n}\n\nint n, k, s;\nCube c[2000];\nint vis[2000];\n\nvector<int> G[2000];\n\nvector<vector<int>> C;// テ」ツつオテ」ツつ、テ」ツつッテ」ツδォ\nvector<vector<int>> S;// テ、ツクツ?ヲツ慊ャテゥツ??\n\n// テ」ツつオテ」ツつ、テ」ツつッテ」ツδォテ」ツ?凝」ツ?ゥテ」ツ??」ツ??\nbool dfs(int v, int p, vector<int>& a){\n    vis[v] = 1;\n    a.push_back(v);\n    for(int c : G[v]){\n        if(c == p) continue;\n        if(vis[c]) continue;\n        return dfs(c, v, a);\n    }\n    // \n    return G[v].size() == 2;\n}\n\n// テ・ツ?アテゥツ?堙ゥツ敖「テァツゥツ?\nll X[2000][2000];\n\nint main(){\n    while(cin >> n >> k >> s, n){\n        for(int i = 0; i < n; i++){\n            cin >> c[i].lx  >> c[i].ly >> c[i].lz;\n            c[i].rx = c[i].lx + s;\n            c[i].ry = c[i].ly + s;\n            c[i].rz = c[i].lz + s;\n            G[i].clear();\n        }\n        C.clear();\n        S.clear();\n\n        for(int i = 0; i < n; i++){\n            for(int j = 0; j < n; j++){\n                if(i == j) continue;\n                ll res = f(c[i], c[j]);\n                X[i][j] = res;\n                if(res) G[i].push_back(j);\n            }\n        }\n\n        memset(vis, 0, sizeof vis);\n        for(int i = 0; i < n; i++){\n            if(vis[i]) continue;\n            if(G[i].size() == 1){\n                vector<int> a;\n                bool res = dfs(i, -1, a);\n                if(a.size() < k) continue;\n                S.push_back(a);\n            }   \n        }\n        for(int i = 0; i < n; i++){\n            if(vis[i]) continue;\n            vector<int> a;\n            bool res = dfs(i, -1, a);\n            if(a.size() < k) continue;\n            C.push_back(a);\n        }\n\n        ll ans = 1LL << 55;\n        for(auto a : C){\n            int sz = a.size();\n            for(int i = 0; i < sz; i++) a.push_back(a[i]);\n            ll sum = 0;\n            for(int i = 0; i < k; i++){\n                sum += c[a[i]].S();\n                if(i != k - 1 || k == sz) sum -= X[a[i]][a[i + 1]];\n            }\n            for(int i = 0; i < sz; i++){\n                ans = min(ans, sum);\n                sum -= c[a[i]].S();\n                sum += X[a[i]][a[i+1]];\n                sum += c[a[i+k]].S();\n                sum -= X[a[i+k-1]][a[i+k]];\n            }\n            if(k != sz){\n                ans = min(ans, sum);\n            }\n        }\n        for(auto a : S){\n            ll sum = 0;\n            for(int i = 0; i < k; i++){\n                sum += c[a[i]].S();\n                if(i != k - 1) sum -= X[a[i]][a[i + 1]];\n            }\n            for(int i = 0; i < a.size() - k; i++){\n                ans = min(ans, sum);\n                sum -= c[a[i]].S();\n                sum += X[a[i]][a[i+1]];\n                sum += c[a[i+k]].S();\n                sum -= X[a[i+k-1]][a[i+k]];\n            }\n            ans = min(ans, sum);\n        }\n        if(ans == 1LL << 55) cout << -1 << endl;\n        else cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <tuple>\nusing namespace std;\n\nusing T = tuple<int,int,int>;\nusing P = pair<int,int>;\n\nvector<P> G[2000];\nbool visited[2000];\nint dfs(int current, int pre, int start, int k, int len, int sum){\n    visited[current]=true;\n    int ret=-1;\n    if(len==k)ret=sum;\n    for(auto p:G[current]){\n        int to,weight;\n        tie(to,weight)=p;\n        if(to==pre) continue;\n        if(to==start&&len==k){\n            ret=sum+weight;\n            continue;\n        }\n        if(len<k){\n            ret = max(ret,dfs(to,current,start,k,len+1,sum+weight));\n        }\n    }\n    visited[current]=false;\n    return ret;\n}\n\nint main(){\n    int n,k,s;\n    while(cin>>n>>k>>s,n){\n        vector<T> V;\n        for(int i=0;i<n;i++){\n            int x,y,z;\n            cin>>x>>y>>z;\n            V.emplace_back(x,y,z);\n        }\n        for(auto &g:G) g.clear();\n        for(int i=0;i<n;i++){\n            for(int j=i+1;j<n;j++){\n                int ix,iy,iz,jx,jy,jz;\n                tie(ix,iy,iz)=V[i];\n                tie(jx,jy,jz)=V[j];\n                int cx = max(0,s-abs(ix-jx));\n                int cy = max(0,s-abs(iy-jy));\n                int cz = max(0,s-abs(iz-jz));\n                if(cx&&cy&&cz){\n                    G[i].emplace_back(j,2*(cx*cy+cy*cz+cz*cx));\n                    G[j].emplace_back(i,2*(cx*cy+cy*cz+cz*cx));\n                }\n            }\n        }\n        \n        int ans = 0;\n        for(int i=0;i<n;i++){\n            fill(visited,visited+2000,false);\n            ans = max(ans,dfs(i,-1,i,k,1,0));\n        }\n        if(k>1&&!ans) ans=-1;\n        else ans = 6*s*s*k-ans;\n        cout<<ans<<endl;\n    }\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i,n) for(int i = 0;i < (n);i++)\nconst int INF = 1e9;\nusing namespace std;\n\nint N, K, S;\n\nstruct Point{\n    int x, y, z;\n};\n\nPoint p[2003];\n\nbool iscycle[2003];\nbool used[2003];\ndeque<int> graph[2003];\n\nint getS(Point a,Point b){\n    if(a.x > b.x) swap(a.x, b.x);\n    if(a.y > b.y) swap(a.y, b.y);\n    if(a.z > b.z) swap(a.z, b.z);\n    return (a.x + S - b.x) * (a.y + S - b.y) * 2\n        +  (a.z + S - b.z) * (a.x + S - b.x) * 2\n        +  (a.y + S - b.y) * (a.z + S - b.z) * 2;\n}\n\nbool connected(int a,int b){\n    REP(_,2){\n        int x2 = p[b].x;\n        int y2 = p[b].y;\n        int z2 = p[b].z;\n        int xs = S, ys = S;\n        REP(i,8){\n            if(i && (i % 4 == 0)){\n                z2 += S;\n            }\n            if(p[a].x <= x2 && x2 <= p[a].x + S\n               && p[a].y <= y2 && y2 <= p[a].y + S\n               && p[a].z <= z2 && z2 <= p[a].z + S){\n                return true;\n            }\n            if(i % 2 == 0){\n                x2 += xs;\n                xs = -xs;\n            }\n            if(i % 2 == 1){\n                y2 += ys;\n                ys = -ys;\n            }\n        }\n        swap(a,b);\n    }\n    return false;\n}\n\nvoid makegraph(int graphct, int i, bool maincalled, bool back){\n    REP(j,N){\n        if(used[j])continue;\n        if(connected(i,j)){\n            used[j] = true;\n            if(graph[graphct].size() > 1 && (maincalled || back)){\n                graph[graphct].push_front(j);\n                makegraph(graphct, j, false, true);\n            }else{\n                graph[graphct].push_back(j);\n                makegraph(graphct, j, false, false);\n            }\n        }\n    }\n}\n\n\nint main(){\n    while(cin >> N >> K >> S, N){\n        REP(i,N){\n            int x, y, z;\n            cin >> x >> y >> z;\n            p[i] = Point{x, y, z};\n            graph[i].clear();\n            iscycle[i] = false;\n            used[i] = false;\n        }\n\n        //make graph\n        int graphct = 0;\n        REP(i,N){\n            if(used[i]) continue;\n            graph[graphct].push_back(i);\n            used[i] = true;\n            makegraph(graphct, i, true, true);\n            graphct++;\n        }\n\n        //cycle check\n        REP(i,graphct){\n            if(graph[i].size() > 2 && connected(graph[i][0],graph[i][graph[i].size() - 1]))\n                iscycle[i] = true;\n        }\n        \n        int ans = INF;\n        REP(i,graphct){\n            if((int)graph[i].size() < K) continue;\n            REP(j,graph[i].size()){\n                if(j + K - 1 > graph[i].size() - 1) continue;\n                int tmpans = 0;\n                for(int r = 0; r < K;r++){\n                    tmpans += S*S*6;\n                    if(r){\n                        tmpans -= getS(p[graph[i][j + r]], p[graph[i][j + r - 1]]);\n                    }else if(iscycle[i] && K == graph[i].size()){\n                        tmpans -= getS(p[graph[i][0]], p[graph[i][graph[i].size() - 1]]);\n                    }\n                }\n                ans = min(tmpans, ans);\n            }\n        }\n        if(ans == INF) cout << -1 << endl;\n        else cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cstring>\n#include <cassert>\nusing namespace std;\nusing ll = long long;\n\nstruct Cube{\n    ll lx, rx;\n    ll ly, ry;\n    ll lz, rz;\n    ll S(){\n        ll dx = rx - lx;\n        ll dy = ry - ly;\n        ll dz = rz - lz;\n        return (dx * dy + dy * dz + dz * dx) * 2;\n    } \n};\n\nll f(Cube c1, Cube c2){\n    ll LX, LY, LZ, RX, RY, RZ;\n    LX = max(c1.lx, c2.lx);\n    RX = min(c1.rx, c2.rx);\n    LY = max(c1.ly, c2.ly);\n    RY = min(c1.ry, c2.ry);\n    LZ = max(c1.lz, c2.lz);\n    RZ = min(c1.rz, c2.rz);\n    if(RX <= LX) return 0;\n    if(RY <= LY) return 0;\n    if(RZ <= LZ) return 0;\n    ll dx = RX - LX;\n    ll dy = RY - LY;\n    ll dz = RZ - LZ;\n    return (dx * dy + dy * dz + dz * dx) * 2;\n}\n\nint n, k, s;\nCube c[2000];\nint vis[2000];\n\nvector<int> G[2000];\n\nvector<vector<int>> C;// ????????????\nvector<vector<int>> S;// ?????¬???\n\n// ????????????????????????\nvoid dfs(int v, int p, vector<int>& a){\n    vis[v] = 1;\n    a.push_back(v);\n    for(int c : G[v]){\n        if(c == p) continue;\n        if(vis[c]) continue;\n        dfs(c, v, a);\n        return;\n    }\n    return;\n}\n\n// ??±?????¢???;\nll X[2000][2000];\n\nint main(){\n    while(cin >> n >> k >> s, n){\n        for(int i = 0; i < n; i++){\n            cin >> c[i].lx  >> c[i].ly >> c[i].lz;\n            c[i].rx = c[i].lx + s;\n            c[i].ry = c[i].ly + s;\n            c[i].rz = c[i].lz + s;\n            G[i].clear();\n        }\n        C.clear();\n        S.clear();\n\n        for(int i = 0; i < n; i++){\n            for(int j = 0; j < n; j++){\n                if(i == j) continue;\n                ll res = f(c[i], c[j]);\n                X[i][j] = res;\n                if(res) G[i].push_back(j);\n            }\n        }\n\n        memset(vis, 0, sizeof vis);\n        for(int i = 0; i < n; i++){\n            if(vis[i]) continue;\n            if(G[i].size() <= 1){\n                vector<int> a;\n                dfs(i, -1, a);\n                if(a.size() < k) continue;\n                S.push_back(a);\n            }   \n        }\n        for(int i = 0; i < n; i++){\n            if(vis[i]) continue;\n            assert(G[i].size() <= 2);\n            vector<int> a;\n            dfs(i, -1, a);\n            if(a.size() < k) continue;\n            C.push_back(a);\n        }\n\n        ll ans = 1LL << 61;\n        for(auto a : C){\n            int sz = a.size();\n            for(int i = 0; i < sz; i++) a.push_back(a[i]);\n            ll sum = 0;\n            for(int i = 0; i < k; i++){\n                sum += c[a[i]].S();\n                if(i != k - 1 || k == sz) sum -= X[a[i]][a[i + 1]];\n            }\n            for(int i = 0; i < sz && sz != k; i++){\n                ans = min(ans, sum);\n                sum -= c[a[i]].S();\n                sum += X[a[i]][a[i+1]];\n                sum += c[a[i+k]].S();\n                sum -= X[a[i+k-1]][a[i+k]];\n            }\n            ans = min(ans, sum);\n        }\n        for(auto a : S){\n            ll sum = 0;\n            for(int i = 0; i < k; i++){\n                sum += c[a[i]].S();\n                if(i != k - 1) sum -= X[a[i]][a[i + 1]];\n            }\n            for(int i = 0; i < a.size() - k; i++){\n                ans = min(ans, sum);\n                sum -= c[a[i]].S();\n                sum += X[a[i]][a[i+1]];\n                sum += c[a[i+k]].S();\n                sum -= X[a[i+k-1]][a[i+k]];\n            }\n            ans = min(ans, sum);\n        }\n        if(ans == 1LL << 61) ans = -1;\n        //cout << ans << endl;\n        cout << ans << \" \" << n << \" \" << S.size() << \" \"  << C.size() << \" \" <<  k << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\nconst double EPS = 1e-12;\nconst int INF = numeric_limits<int>::max()/2;\nconst int MOD = 1e9+7;\n\nstruct UF {\n\tvector<int> data;\n\tUF(int size) : data(size, -1) { }\n\tbool unite(int x, int y) {\n\t\tx = root(x); y = root(y);\n\t\tif (x != y) {\n\t\t\tif (data[y] < data[x]) swap(x, y);\n\t\t\tdata[x] += data[y]; data[y] = x;\n\t\t}\n\t\treturn x != y;\n\t}\n\tbool find(int x, int y) {\n\t\treturn root(x) == root(y);\n\t}\n\tint root(int x) {\n\t\treturn data[x] < 0 ? x : data[x] = root(data[x]);\n\t}\n\tint size(int x) {\n\t\treturn -data[root(x)];\n\t}\n};\n\nll dfs(const vector<vector<P>> &v,int node,int pre, int depth,int k,int st){\n    if(depth==k){\n        if(k>2 && v[node].size()==2){\n            if(v[node][0].first==st) return v[node][0].second;\n            else if(v[node][1].first==st) return v[node][1].second;\n        } \n        return 0;\n    }\n    if(v[node].size()==1 && node!=st) return -INF;\n    for(int i=0;i<2;i++){\n        P p=v[node][i];\n        if(p.first==pre) continue;\n        else return p.second+dfs(v,p.first,node,depth+1,k,st);\n    }\n    return -INF;\n}\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int n,k,s;\n    while(cin>>n>>k>>s,n){\n        vector<ll> x(n),y(n),z(n);\n        vector<vector<P>> g(n);\n        UF uf(n);\n        for(int i=0;i<n;i++){\n            cin>>x[i]>>y[i]>>z[i];\n        }\n        for(int i=0;i<n;i++){\n            for(int j=i+1;j<n;j++){\n                if(abs(x[i]-x[j])>=s || abs(y[i]-y[j])>=s || abs(z[i]-z[j])>=s) continue;\n                ll dx=s-abs(x[i]-x[j]), dy=s-abs(y[i]-y[j]), dz=s-abs(z[i]-z[j]);\n                ll dif=2*(dx*dy+dy*dz+dz*dx);\n                g[i].push_back(P(j,dif));\n                g[j].push_back(P(i,dif));\n                uf.unite(i,j);\n                //cout<<i<<\" \"<<j<<\" \"<<dif<<endl;\n            }\n        }\n        bool f=false;\n        ll res=s*s*6*k, ma=res;\n        for(int i=0;i<n;i++){\n            if(uf.size(i)<k) continue;\n            f=true;\n            if(g[i].size()==0) continue;\n            if(g[i].size()==1) res=min(res,ma-dfs(g,i,-1,1,k,i));\n            else{\n                int p=g[i][0].first,q=g[i][1].first;\n                res=min(res,ma-dfs(g,i,p,1,k,i));\n                res=min(res,ma-dfs(g,i,q,1,k,i));\n            }\n        }\n        if(!f){\n            cout<<-1<<endl;\n            continue;\n        }\n        cout<<res<<endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\n\nstruct Cube {\n    Cube() = default;\n    Cube(ll x, ll y, ll z, ll size) : x{x}, y{y}, z{z}, size{size}\n    {\n    }\n\n    bool operator<(const Cube& c) const\n    {\n        return (x != c.x) ? (x < c.x) : (y != c.y) ? (y < c.y) : (z != c.z) ? (z < c.z) : true;\n    }\n    ll x;\n    ll y;\n    ll z;\n    ll size;\n};\n\nll intersection(const Cube& c1, const Cube& c2)\n{\n\n    ll x = min(c1.x, c2.x) - max(c1.x, c2.x) + c1.size;\n    if (x <= 0) {\n        return 0;\n    }\n    ll y = min(c1.y, c2.y) - max(c1.y, c2.y) + c1.size;\n    if (y <= 0) {\n        return 0;\n    }\n    ll z = min(c1.z, c2.z) - max(c1.z, c2.z) + c1.size;\n    if (z <= 0) {\n        return 0;\n    }\n    return 2 * ((x * y) + (y * z) + (z * x));\n}\n\nstruct Edge {\n    Edge() = default;\n    Edge(int f, int t, ll c) : from{f}, to{t}, cost{c}\n    {\n    }\n    int from;\n    int to;\n    ll cost;\n};\n\nstruct Graph {\n    Graph(int n)\n    {\n        edge.resize(n);\n    }\n    void addEdge(int from, int to, ll cost)\n    {\n        edge[to].push_back(Edge{to, from, cost});\n        edge[from].push_back(Edge{from, to, cost});\n    }\n    vector<vector<Edge>> edge;\n};\n\nvoid dfs(const Graph& g, vector<bool>& checked, int pos, int& num, bool& ring, int& representation)\n{\n    num++;\n    checked[pos] = true;\n    bool update = false;\n    for (const auto& e : g.edge[pos]) {\n        const int to = e.to;\n        if (not checked[to]) {\n            dfs(g, checked, to, num, ring, representation);\n            update = true;\n        }\n    }\n    if (not update) {\n        if (g.edge[pos].size() == 2) {\n            ring = true;\n        } else {\n            ring = false;\n        }\n        representation = pos;\n    }\n}\n\nint main()\n{\n\n    while (true) {\n        int n, k;\n        ll s;\n        cin >> n >> k >> s;\n        if (n == 0 and k == 0 and s == 0) {\n            break;\n        }\n        vector<Cube> cubes(n);\n        for (int i = 0; i < n; i++) {\n            ll x, y, z;\n            cin >> x >> y >> z;\n            cubes[i] = Cube{x, y, z, s};\n        }\n        Graph g{n};\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                ll inter = intersection(cubes[i], cubes[j]);\n                if (inter > 0) {\n                    g.addEdge(i, j, inter);\n                }\n            }\n        }\n\n        vector<bool> checked(n, false);\n        vector<pair<pair<int, int>, bool>> cc;\n        for (int i = 0; i < n; i++) {\n            if (not checked[i]) {\n                int num = 0;\n                bool ring = false;\n                int rep;\n                dfs(g, checked, i, num, ring, rep);\n                if (num >= k) {\n                    cc.push_back(make_pair(make_pair(rep, num), ring));\n                }\n            }\n        }\n\n        if (cc.empty()) {\n            cout << -1 << endl;\n            continue;\n        }\n\n        ll maxi = -1;\n        vector<bool> used_head(n, false);\n        vector<bool> used_tail(n, false);\n        for (const auto p : cc) {\n            int rep = p.first.first;\n            int num = p.first.second;\n            bool ring = p.second;\n            if (ring) {\n                int head = rep;\n                int tail = rep;\n                ll sum = 0;\n                for (int i = 0; i < k - 1; i++) {\n                    used_tail[tail] = true;\n                    for (const auto& e : g.edge[tail]) {\n                        if (not used_tail[e.to]) {\n                            tail = e.to;\n                            sum += e.cost;\n                            break;\n                        }\n                    }\n                }\n                if (k == num) {\n                    used_tail[head] = false;\n                    for (const auto& e : g.edge[tail]) {\n                        if (not used_tail[e.to]) {\n                            sum += e.cost;\n                            break;\n                        }\n                    }\n                    maxi = max(maxi, sum);\n                    continue;\n                }\n                maxi = max(maxi, sum);\n                for (int i = 0; i < num; i++) {\n                    used_head[head] = true;\n                    used_tail[tail] = true;\n                    for (const auto& e : g.edge[head]) {\n                        if (not used_head[e.to]) {\n                            head = e.to;\n                            sum -= e.cost;\n                            break;\n                        }\n                    }\n                    for (const auto& e : g.edge[tail]) {\n                        if (not used_tail[e.to]) {\n                            tail = e.to;\n                            sum += e.cost;\n                            break;\n                        }\n                    }\n                    maxi = max(maxi, sum);\n                }\n            } else {\n                int head = rep;\n                int tail = rep;\n                ll sum = 0;\n                for (int i = 0; i < k - 1; i++) {\n                    used_tail[tail] = false;\n                    for (const auto& e : g.edge[tail]) {\n                        if (not used_tail[e.to]) {\n                            tail = e.to;\n                            sum += e.cost;\n                            break;\n                        }\n                    }\n                }\n                maxi = max(maxi, sum);\n                for (int i = 0; i < num - k + 1; i++) {\n                    used_head[head] = true;\n                    used_tail[tail] = true;\n                    for (const auto& e : g.edge[head]) {\n                        if (not used_head[e.to]) {\n                            head = e.to;\n                            sum -= e.cost;\n                            break;\n                        }\n                    }\n                    for (const auto& e : g.edge[tail]) {\n                        if (not used_tail[e.to]) {\n                            tail = e.to;\n                            sum += e.cost;\n                            break;\n                        }\n                    }\n                    maxi = max(maxi, sum);\n                }\n            }\n        }\n        cout << (6 * s * s) * static_cast<ll>(k) - maxi << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb(s) push_back(s)\n#define mp(a,b) make_pair(a,b)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define maxch(x,y) x=max(x,y)\n#define minch(x,y) x=min(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt(x) bitset<32>(x).count()\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\n\n#define INF 1e16\n\nll n,k,s;\nll x[2222],y[2222],z[2222];\nbool used[2002];\nvector<int> g[2222];\n\nbool is_cross(int i,int j){\n  return (abs(x[i]-x[j])<=s)&&(abs(y[i]-y[j])<=s)&&(abs(z[i]-z[j])<=s);\n}\n\nll cross_surf(int i,int j){\n  ll xx=s-abs(x[i]-x[j]);\n  ll yy=s-abs(y[i]-y[j]);\n  ll zz=s-abs(z[i]-z[j]);\n  return 2*(xx*yy+yy*zz+zz*xx);\n}\n\nint main(){\n\tcin.sync_with_stdio(false);\n  while(1){\n    rep(i,2222)g[i].clear();\n    cin>>n>>k>>s;\n    if(n==0)break;\n    rep(i,n){\n      cin>>x[i]>>y[i]>>z[i];\n    }\n    if(k==1){\n      cout<<s*s*6<<endl;\n      continue;\n    }\n    rep(i,n)rep(j,i){\n      if(is_cross(i,j)){\n        g[i].pb(j);\n        g[j].pb(i);\n      }\n    }\n    ll res=INF;\n    rep(i,n){\n      for(int j: g[i]){\n        memset(used,0,sizeof(used));\n        used[i]=used[j]=true;\n        ll sum=s*s*6*2-cross_surf(i,j);\n        int cnt=2;\n        int last;\n        rep(hoge,k-2){\n          for(int nxt:g[j]){\n            if(used[nxt])continue;\n            used[nxt]=true;\n            sum+=s*s*6-cross_surf(j,nxt);\n            last=nxt;\n            cnt++;\n            j=nxt;\n          }\n        }\n        if(cnt==k)minch(res,sum-(k>2&&is_cross(i,last)?cross_surf(i,last):0));\n      }\n    }\n    if(res==INF)cout<<-1<<endl;\n    else cout<<res<<endl;\n  }\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "int main()\n{\nwhile(true){\n;}\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\nusing namespace std;\n\nstruct cube {\n    int x, y, z, w;\n    cube() {}\n    cube(int a, int b, int c, int d): x(a), y(b), z(c), w(d) {}\n\n    int area() {\n        return 6 * w * w;\n    }\n\n    int overlap_area(cube o) {\n        int ox = w - abs(x - o.x);\n        int oy = w - abs(y - o.y);\n        int oz = w - abs(z - o.z);\n\n        if (ox < 0 || oy < 0 || oz < 0) {\n            return -1;\n        }\n\n        return 2 * (ox * oy + oy * oz + oz * ox);\n    }\n};\n\nint main() {\n    int N, K, S;\n    while (true) {\n        cin >> N >> K >> S;\n        if (N == 0 && K == 0 && S == 0) break;\n\n        vector<cube> cubes;\n        vector<vector<int>> graph(N);\n\n        for (int j = 0; j < N; ++j) {\n            int x, y, z; cin >> x >> y >> z;\n            cubes.emplace_back(x, y, z, S);\n        }\n\n        for (int j = 0; j < N; ++j) {\n            for (int k = j+1; k < N; ++k) {\n                int area = cubes[j].overlap_area(cubes[k]);\n                if (area >= 0) {\n                    graph[j].push_back(k);\n                    graph[k].push_back(j);\n                }\n            }\n        }\n\n        int ans = -1;\n\n        vector<int> visited(N, 0);\n        for (int a = 0; a < N; ++a) {\n            if (visited[a]) continue;\n            visited[a] = 1;\n\n            bool loop = false;\n            int res = a;\n            for (int p = a, count = 1; p != -1; ++count) {\n                visited[p] = 1;\n                int np = -1;\n                for (int q: graph[p]) {\n                    if (count > 2 && q == a) {\n                        loop = true;\n                        break;\n                    }\n                    if (!visited[q]) {\n                        res = np = q;\n                        break;\n                    }\n                }\n                p = np;\n            }\n\n            vector<int> chain;\n            for (int p = res; p != -1; ) {\n                visited[p] = 1;\n                int np = -1;\n                chain.push_back(p);\n                for (int q: graph[p]) {\n                    if (chain.size() > 2 && q == res) {\n                        break; // loop\n                    }\n                    if (chain.size() <= 1 || chain[chain.size()-2] != q) {\n                        np = q;\n                        break;\n                    }\n                }\n                p = np;\n            }\n\n            if (chain.size() < K) {\n                continue;\n            }\n\n            const int L = chain.size();\n\n            int area = cubes[chain[0]].area();\n            if (K <= 1) {\n                ans = (ans == -1) ? area : min(ans, area);\n            }\n            for (int j = 1; j < (loop ? 2*L : L); ++j) {\n                if (j >= K) {\n                    int va = chain[(j-K)%L], vb = chain[(j-K+1)%L];\n                    area -= cubes[va].area() - cubes[va].overlap_area(cubes[vb]);\n                }\n                area += cubes[chain[j%L]].area() - cubes[chain[(j-1)%L]].overlap_area(cubes[chain[j%L]]);\n                if (loop && K == L && j == L-1) {\n                    area -= cubes[chain[0]].overlap_area(cubes[chain[L-1]]);\n                }\n                if (j+1 >= K) {\n                    ans = (ans == -1) ? area : min(ans, area);\n                }\n            }\n        }\n\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define all(v) (v).begin(),(v).end()\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\n#define pb push_back\n#define fi first\n#define se second\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nint N,K,S;\nint X[2222][3];\n\nint table[2222][2222];\n\nint f(int a,int b){\n    if(a>b)swap(a,b);\n    return max(0ll,a+S-b);\n}\nvint G[2222];\n\nbool used[2222];\nint dfs(int v,int c,int p){\n    if(c==K){\n        if(c<=2)return 0;\n        return table[v][p];\n    }\n\n    used[v]=true;\n    int ret=LLONG_MIN;\n    for(auto u:G[v]){\n        if(used[u])continue;\n        int tmp=dfs(u,c+1,p);\n        if(tmp!=LLONG_MIN)chmax(ret,tmp+table[v][u]);\n    }\n    used[v]=false;\n    return ret;\n}\n\nvoid solve(){\n    rep(i,N)rep(j,3)cin>>X[i][j];\n    memset(table,0,sizeof(table));\n    rep(i,N)G[i].clear();\n    rep(i,N)rep(j,N)if(i!=j){\n        vint v;\n        bool flag=true;\n        rep(k,3){\n            int tmp=f(X[i][k],X[j][k]);\n            if(tmp==0){\n                flag=false;\n            }\n            v.pb(tmp);\n        }\n        if(!flag)continue;\n        G[i].pb(j);\n        rep(k,3)table[i][j]+=v[k]*v[(k+1)%3];\n    }\n\n    memset(used,0,sizeof(used));\n    int ma=LLONG_MIN;\n    rep(i,N){\n        chmax(ma,dfs(i,1,i));\n    }\n\n    if(ma==LLONG_MIN){\n        cout<<-1<<endl;\n        return;\n    }\n    cout<<(3*S*S*K-ma)*2<<endl;\n}\n\nsigned main(){\n    while(cin>>N>>K>>S,N||K||S)solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string.h>\n#define mp make_pair\n#define pb push_back\n#define int long long\n\nconst int INF = 1e+18;\nusing LL = long long;\nusing namespace std;\n\ntypedef pair<int, int> pii;\n\nbool used[2010];\nint n, k, s, x[2010], y[2010], z[2010];\nvector<int> G[2010];\n\nint kasane(int a, int b) {\n\tint ax = x[a], ay = y[a], az = z[a];\n\tint bx = x[b], by = y[b], bz = z[b];\n\tint ret = 0, cx, cy, cz;\n\tcx = max(0ll,min(x[a],x[b]) - max(x[a],x[b]) + s);\n\tcy = max(0ll,min(y[a],y[b]) - max(y[a],y[b]) + s);\n\tcz = max(0ll,min(z[a],z[b]) - max(z[a],z[b]) + s);\n\tif (!cx || !cy || !cz) return 0;\n\treturn 2 * (cx * cy + cy * cz + cz * cx);\n}\n\nvector<vector<int>> sen;\nvector<int> tmpvec;\nvector<bool> isEn;\n\nvoid dfs(int v, int par) {\n\tused[v] = true;\n\ttmpvec.pb(v);\n\tfor (int to : G[v]) {\n\t\tif (to != par && !used[to]) {\n\t\t\tdfs(to, v);\n\t\t}\n\t}\n}\n\nint dp1[2010][2010][2][2];\n\nsigned main() {\n\twhile (cin >> n >> k >> s, n) {\n\t\tisEn.clear();\n\t\tsen.clear();\n\t\tfor (int i = 0; i < n; i++) cin >> x[i] >> y[i] >> z[i];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tG[i].clear();\n\t\t\tused[i] = false;\n\t\t}\n\t\tif (k == 1) {\n\t\t\tcout << 6 * s * s << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\t\tif (kasane(i, j)) {\n\t\t\t\t\tG[i].pb(j);\n\t\t\t\t\tG[j].pb(i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (!used[i] && G[i].size() == 1) {\n\t\t\t\ttmpvec.clear();\n\t\t\t\tdfs(i, -1);\n\t\t\t\tsen.pb(tmpvec);\n\t\t\t\tisEn.pb(false);\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (!used[i]) {\n\t\t\t\ttmpvec.clear();\n\t\t\t\tdfs(i, -1);\n\t\t\t\tsen.pb(tmpvec);\n\t\t\t\tisEn.pb(true);\n\t\t\t}\n\t\t}\n\t\tint mi = INF;\n\t\tfor (int i = 0; i < sen.size(); i++) {\n\t\t\tvector<int> vec = sen[i];\n\t\t\tint ans = s * s * 6 * k,_n = vec.size();\n\t\t\tif (_n < k) continue;\n\t\t\tif (_n == k && isEn[i]) {\n\t\t\t\tfor (int j = 0; j < _n; j++) ans -= kasane(vec[j],vec[(j + 1) % _n]);\n\t\t\t\tmi = min(mi,ans);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor(int j = 1;j < k;j++) ans -= kasane(vec[j],vec[j - 1]);\n\t\t\tfor(int j = 0;j < (isEn[i] ? _n : (_n - k + 1));j++){\n\t\t\t\tmi = min(mi,ans);\n\t\t\t\tans -= kasane(vec[(j + k) % _n],vec[(j + k - 1) % _n]);\n\t\t\t\tans += kasane(vec[j],vec[(j + 1) % _n]);\n\t\t\t}\n\t\t}\n\t\tif (mi == INF) cout << -1 << endl;\n\t\telse cout << mi << endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\nusing namespace std;\n\n#define rep(i,a,n) for(int (i)=(a); (i)<(n); (i)++)\n#define repq(i,a,n) for(int (i)=(a); (i)<=(n); (i)++)\n#define repr(i,a,n) for(int (i)=(a); (i)>=(n); (i)--)\n#define all(v) begin(v), end(v)\n#define pb(a) push_back(a)\n#define fr first\n#define sc second\n#define INF 2000000000\n#define int long long int\n\n#define X real()\n#define Y imag()\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a) - (b)) < EPS)\n#define EQV(a,b) ( EQ((a).X, (b).X) && EQ((a).Y, (b).Y) )\n#define LE(n, m) ((n) < (m) + EPS)\n#define LEQ(n, m) ((n) <= (m) + EPS)\n#define GE(n, m) ((n) + EPS > (m))\n#define GEQ(n, m) ((n) + EPS >= (m))\n\ntypedef vector<int> VI;\ntypedef vector<VI> MAT;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\ntypedef complex<double> P;\ntypedef pair<P, P> L;\ntypedef pair<P, double> C;\n\nint dx[] = {1, 1, 0, 0, 1, 1, 0, 0};\nint dy[] = {1, 0, 1, 0, 1, 0, 1, 0};\nint dz[] = {0, 0, 0, 0, 1, 1, 1, 1};\nint const MOD = 1000000007;\n\nnamespace std {\n    bool operator<(const P& a, const P& b) {\n        return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n    }\n}\n\n// Union-Find ??¨ (Verified: AtCoder Typical Contest 001 B)\nstruct UnionFind {\nprivate:\n    const int n;\n    int __size;\n    vector<int> uf;\npublic:\n    // ????????? UnionFind uni(n) ??????????????£?¨?????????°??????\n    UnionFind(int _n) : n(_n), __size(_n), uf(_n, -1) {}\n    // find (??¨??????????±???????)\n    int find(int x) {return (uf[x] < 0) ? x : uf[x] = find(uf[x]);}\n    // x ??¨ y ???????????????????±???????????????????\n    bool same(int x, int y) {return find(x) == find(y);}\n    // x ????±????????????????????´???°\n    int size(int x) {return -uf[find(x)];}\n    // ???????????????????????????\n    int size()      {return __size;}\n    // x ??¨ y ????±??????????????????????\n    void unite(int x, int y) {\n        x = find(x); y = find(y);\n        if(x == y) return;\n        __size--;\n        if(uf[y] < uf[x]) swap(x, y);\n        uf[x] += uf[y]; uf[y] = x;\n    }\n    // ???????????°??¨ (???????????????)\n    void debug() {for(auto e : uf) printf(\"UnionFind_debug: %lld\\n\", e);}\n};\n\n// ?§?????????¨????????¨???????????????????¨???????????§???????\ntemplate <typename T>\nstruct Edge {\n    int from, to;\n    T cost;\n    Edge(int s, T d) : to(s), cost(d) {}\n    Edge(int f, int s, T d) : from(f), to(s), cost(d) {}\n\n    bool operator<(const Edge &e) const {\n        return cost < e.cost;\n    }\n    bool operator>(const Edge &e) const {\n        return cost > e.cost;\n    }\n};\n#define Graph(type) vector< vector< Edge<type> > >\n\nbool incube(int a, int b, int x) {\n    return a <= x && x <= b;\n}\n\nint n, k, s;\nint x[1010], y[1010], z[1010];\nint temp, ans;\nvoid dfs(int p, Graph(int) &G, set<pii> S, set<int> T, int counter, int cur) {\n    T.insert(p);\n    rep(i,0,G[p].size()) {\n        int next = G[p][i].to;\n        if(counter == k && !T.count(next)) continue;\n        int mi = min(p, next), ma = max(p, next);\n        pii pr = pii(mi, ma);\n        if(S.count(pr)) continue;\n        int xx, yy, zz;\n        xx = min(x[p], x[next]) - max(x[p], x[next]) + s;\n        yy = min(y[p], y[next]) - max(y[p], y[next]) + s;\n        zz = min(z[p], z[next]) - max(z[p], z[next]) + s;\n        S.insert(pr);\n        cur -= 2 * (xx * yy + yy * zz + zz * xx);\n        // printf(\"p = %lld, next = %lld, cur = %lld\\n\", p, next, cur);\n        dfs(next, G, S, T, counter+1, cur);\n        S.erase(pr);\n        cur += 2 * (xx * yy + yy * zz + zz * xx);\n    }\n    if(counter >= k) {\n        // printf(\"cur = %lld\\n\", cur);\n        ans = min(ans, cur);\n        return;\n    }\n}\n\nsigned main() {\n    while(cin >> n >> k >> s, n || k || s) {\n        UnionFind uf(n);\n        Graph(int) G(n);\n        rep(i,0,n) {\n            cin >> x[i] >> y[i] >> z[i];\n        }\n        set<pii> edgepair;\n        rep(i,0,n) rep(j,0,n) {\n            if(i == j) continue;\n            pii temppair = pii( min(i,j), max(i,j) );\n            if(edgepair.count(temppair)) continue;\n            bool ok = false;\n            rep(k,0,8) {\n                if(ok) break;\n                if(incube(x[i], x[i]+s, x[j]+dx[k]*s) && incube(y[i], y[i]+s, y[j]+dy[k]*s) && incube(z[i], z[i]+s, z[j]+dz[k]*s)) {\n                    // printf(\"incube: i = %lld, j = %lld\\n\", i, j);\n                    uf.unite(i, j);\n                    G[i].pb(Edge<int>(j,1));\n                    G[j].pb(Edge<int>(i,1));\n                    edgepair.insert(temppair);\n                    ok = true;\n                }\n            }\n        }\n\n        ans = (int)1e18;\n        rep(i,0,n) {\n            // printf(\"uf.size(%lld) = %lld\\n\", i, uf.size(i));\n            if(uf.size(i) >= k) {\n                temp = 6 * s * s * k;\n                set<pii> S;\n                set<int> T;\n                dfs(i, G, S, T, 1, temp);\n            }\n        }\n        if(ans != (int)1e18) cout << ans << endl;\n        else cout << -1 << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <cmath>\n#include <cstdlib>\n#include <map>\nusing namespace std;\n\nclass Point {\npublic:\n    int x, y, z;\n    Point(int x = 0, int y = 0, int z = 0) : x(x), y(y), z(z) {}\n};\n\nclass Cube {\npublic:\n    Point p;\n    int s;\n    int vx[4] = {0, 1, 1, 0}, vy[4] = {0, 0, 1, 1}, vz[2] = {0, 1};\n    Cube(Point p = Point(), int s = 0) : p(p), s(s) {}\n\n    bool isIn(const Cube &c) {\n        return ((abs(p.x - c.p.x) < s) && (abs(p.y - c.p.y) <= s) && (abs(p.z - c.p.z) <= s) &&\n                (abs(p.x - c.p.x) <= s) && (abs(p.y - c.p.y) < s) && (abs(p.z - c.p.z) <= s) &&\n                (abs(p.x - c.p.x) <= s) && (abs(p.y - c.p.y) <= s) && (abs(p.z - c.p.z) < s));\n    }\n\n    long long shareS(Cube &c) {\n        long long ret = 0;\n        Point a, b;\n        a = p; b = c.p;\n\n        if (a.x > b.x) swap(a.x, b.x);\n        if (a.y > b.y) swap(a.y, b.y);\n        if (a.z > b.z) swap(a.z, b.z);\n\n        ret += abs((a.x + s - b.x) * (a.z + s - b.z) * 2);\n        ret += abs((a.y + s - b.y) * (a.z + s - b.z) * 2);\n        ret += abs((a.x + s - b.x) * (a.y + s - b.y) * 2);\n        return ret;\n    }\n\n};\n\nint n, k, s, x, y, z;\nlong long ans;\nvector<Cube> c;\nvector<vector<int> > subg;\nvector<bool> used;\nvector<deque<int> > graph;\ndeque<int> que;\n\n// not clever\ninline void makegraph() {\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            if (c[i].isIn(c[j])) {\n                subg[j].push_back(i);\n                subg[i].push_back(j);\n            }\n        }\n    }\n}\n\n// make path\nvoid dfs(int v) {\n    used[v] = true;\n    int size_ = subg[v].size();\n    bool flag = false;\n\n    for (int i = 0; i < size_; ++i) {\n        if (!used[subg[v][i]]) {\n            dfs(subg[v][i]);\n            if (!flag) que.push_front(v);\n            flag = true;\n        }\n    }\n\n    if (!flag) que.push_front(v);\n}\n\n// is graph[graphid] cycle ?\ninline bool isCycle(int graphid) {\n    int size_ = graph[graphid].size();\n\n    // if all vertex's degree are two, this graph is cycle.\n    for (int i = 0; i < size_; ++i) {\n        if (subg[graph[graphid][i]].size() != 2) return false;\n    }\n\n    return true;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    while (cin >> n >> k >> s, n | k | s) {\n        c.resize(n);\n        subg.resize(n);\n        que.clear();\n        used.assign(n, false);\n        ans = int(1e15);\n\n        for (int i = 0; i < n; ++i) {\n            cin >> x >> y >> z;\n            c[i] = {Point(x, y, z), s};    \n        }\n\n        makegraph();\n\n        for (int i = 0; i < n; ++i) {\n            if (!used[i]) {\n                dfs(i);\n                graph.push_back(que);\n                que.clear();\n            }\n        }\n\n        int gsize = graph.size(), qsize, upper;\n        long long share;\n        bool isGraphCycle = false;\n\n        for (int i = 0; i < gsize; ++i) {\n            qsize = graph[i].size();\n            isGraphCycle = isCycle(i);\n            if (isGraphCycle) {\n                upper = qsize + k - 1;\n            }\n            else upper = qsize;\n\n            if (qsize < k) continue;\n\n            for (int j = 0; j + k - 1 < upper; ++j) {\n                share = 0;\n\n                for (int l = 0; l < k - 1; ++l) {\n                    share += c[graph[i][(j + l) % qsize]].shareS(c[graph[i][(j + l + 1) % qsize]]);\n                }\n\n                if (isGraphCycle && qsize == k) {\n                    share += c[graph[i][j % qsize]].shareS(c[graph[i][(j + qsize - 1) % qsize]]);\n                }\n\n                ans = min(ans, 6 * s * s * k - share);\n            }\n        }\n\n        if (n == 1) ans = 6 * s * s;\n        if (ans == int(1e15)) ans = -1;\n\n        cout << ans << endl;\n\n        c.clear();\n        graph.clear();\n        subg.clear();\n        used.clear();\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\nusing namespace std;\n\nstruct cube {\n    int x, y, z, w;\n    cube() {}\n    cube(int a, int b, int c, int d): x(a), y(b), z(c), w(d) {}\n\n    int area() {\n        return 6 * w * w;\n    }\n\n    int overlap_area(cube o) {\n        int ox = w - abs(x - o.x);\n        int oy = w - abs(y - o.y);\n        int oz = w - abs(z - o.z);\n\n        if (ox < 0 || oy < 0 || oz < 0) {\n            return -1;\n        }\n\n        return 2 * (ox * oy + oy * oz + oz * ox);\n    }\n};\n\nint main() {\n    int N, K, S;\n    while (true) {\n        cin >> N >> K >> S;\n        if (N == 0 && K == 0 && S == 0) break;\n\n        vector<cube> cubes;\n        vector<vector<int>> graph(N);\n\n        for (int j = 0; j < N; ++j) {\n            int x, y, z; cin >> x >> y >> z;\n            cubes.emplace_back(x, y, z, S);\n        }\n\n        for (int j = 0; j < N; ++j) {\n            for (int k = j+1; k < N; ++k) {\n                int area = cubes[j].overlap_area(cubes[k]);\n                if (area >= 0) {\n                    graph[j].push_back(k);\n                    graph[k].push_back(j);\n                }\n            }\n        }\n\n        int ans = -1;\n\n        vector<int> visited(N, 0);\n        for (int a = 0; a < N; ++a) {\n            if (visited[a]) continue;\n            visited[a] = 1;\n\n            bool loop = false;\n            int res = a;\n            for (int p = a, count = 1; p != -1; ++count) {\n                visited[p] = 1;\n                int np = -1;\n                for (int q: graph[p]) {\n                    if (count > 2 && q == a) {\n                        loop = true;\n                        break;\n                    }\n                    if (!visited[q]) {\n                        res = np = q;\n                        break;\n                    }\n                }\n                p = np;\n            }\n\n            vector<int> chain;\n            for (int p = res; p != -1; ) {\n                int np = -1;\n                chain.push_back(p);\n                for (int q: graph[p]) {\n                    if (chain.size() > 2 && q == res) {\n                        break; // loop\n                    }\n                    if (chain.size() <= 1 || chain[chain.size()-2] != q) {\n                        np = q;\n                        break;\n                    }\n                }\n                p = np;\n            }\n\n            if (chain.size() < K) {\n                continue;\n            }\n\n            const int L = chain.size();\n\n            int area = cubes[chain[0]].area();\n            if (K <= 1) {\n                ans = (ans == -1) ? area : min(ans, area);\n            }\n            for (int j = 1; j < (loop ? 2*L : L); ++j) {\n                if (j >= K) {\n                    int va = chain[(j-K)%L], vb = chain[(j-K+1)%L];\n                    area -= cubes[va].area() - cubes[va].overlap_area(cubes[vb]);\n                }\n                area += cubes[chain[j%L]].area() - cubes[chain[(j-1)%L]].overlap_area(cubes[chain[j%L]]);\n                if (loop && K == L && j == L-1) {\n                    area -= cubes[chain[0]].overlap_area(cubes[chain[L-1]]);\n                }\n                if (j+1 >= K) {\n                    ans = (ans == -1) ? area : min(ans, area);\n                }\n            }\n        }\n\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nconst ll INF = LLONG_MAX/3;\n\nstruct edge{\n    int to;\n    ll cost;\n};\n\nconst int N = 2000;\nvector<edge> G[N];\n\nint main(){\n    int n,k,s;\n    while(scanf(\" %d %d %d\", &n, &k, &s),n){\n        rep(i,N) G[i].clear();\n\n        vector<int> x(n),y(n),z(n);\n        rep(i,n) scanf(\" %d %d %d\", &x[i], &y[i], &z[i]);\n\n        if(k==1){\n            printf(\"%d\\n\", 6*s*s);\n            continue;\n        }\n\n        rep(i,n)rep(j,i){\n            if(abs(x[i]-x[j])<s && abs(y[i]-y[j])<s && abs(z[i]-z[j])<s){\n                ll X = min(x[i],x[j])+s - max(x[i],x[j]);\n                ll Y = min(y[i],y[j])+s - max(y[i],y[j]);\n                ll Z = min(z[i],z[j])+s - max(z[i],z[j]);\n\n                ll w = 2*(X*Y+Y*Z+Z*X);\n                G[i].pb({j,w});\n                G[j].pb({i,w});\n            }\n        }\n\n        rep(i,n) assert(G[i].size()<=2);\n\n        vector<bool> vis(n);\n        ll ans = INF;\n        rep(cand,n){\n            if(vis[cand]) continue;\n            vis[cand] = true;\n\n            queue<int> que;\n            vector<int> cc;\n            que.push(cand);\n            cc.pb(cand);\n            while(!que.empty()){\n                int now = que.front();\n                que.pop();\n                for(const auto &e:G[now]){\n                    if(!vis[e.to]){\n                        vis[e.to] = true;\n                        que.push(e.to);\n                        cc.pb(e.to);\n                    }\n                }\n            }\n\n            int C = cc.size();\n            if(C<k) continue;\n\n            bool line = false;\n            int now = cc[0];\n            int prev = -1;\n            for(int v:cc){\n                if(G[v].size()==1){\n                    line = true;\n                    now = v;\n                    break;\n                }\n            }\n\n            vector<ll> w;\n            int start = now;\n            while(1){\n                bool out = true;\n                for(const auto &e:G[now]){\n                    if(e.to != prev){\n                        w.pb(e.cost);\n                        if(e.to == start){\n                            out = true;\n                            break;\n                        }\n                        prev = now;\n                        now = e.to;\n                        out = false;\n                        break;\n                    }\n                }\n                if(out) break;\n            }\n\n            int W = w.size();\n            ll base = (ll)6*s*s*k;\n            if(line){\n                rep(i,W-k+2){\n                    ll a = 0;\n                    rep(j,k-1) a += w[i+j];\n                    ans = min(ans, base - a);\n                }\n            }\n            else{\n                if(C == k){\n                    ll a = 0;\n                    rep(i,W) a += w[i];\n                    ans = min(ans, base - a);\n                }\n                else{\n                    rep(i,W){\n                        ll a = 0;\n                        rep(j,k-1) a += w[(i+j)%W];\n                        ans = min(ans, base - a);\n                    }\n                }\n            }\n        }\n\n        if(ans == INF) ans = -1;\n        printf(\"%lld\\n\", ans);\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\nconst double EPS = 1e-12;\nconst int INF = numeric_limits<int>::max()/2;\nconst int MOD = 1e9+7;\n\nstruct UF {\n\tvector<int> data;\n\tUF(int size) : data(size, -1) { }\n\tbool unite(int x, int y) {\n\t\tx = root(x); y = root(y);\n\t\tif (x != y) {\n\t\t\tif (data[y] < data[x]) swap(x, y);\n\t\t\tdata[x] += data[y]; data[y] = x;\n\t\t}\n\t\treturn x != y;\n\t}\n\tbool find(int x, int y) {\n\t\treturn root(x) == root(y);\n\t}\n\tint root(int x) {\n\t\treturn data[x] < 0 ? x : data[x] = root(data[x]);\n\t}\n\tint size(int x) {\n\t\treturn -data[root(x)];\n\t}\n};\n\nll dfs(const vector<vector<P>> &v,int node,int pre, int depth,int k,int st){\n    if(depth==k){\n        if(v[node].size()==2){\n            if(v[node][0].first==st) return v[node][0].second;\n            else if(v[node][1].first==st) return v[node][1].second;\n        } \n        return 0;\n    }\n    if(v[node].size()==1) return -INF;\n    for(int i=0;i<(int)v[node].size();i++){\n        P p=v[node][i];\n        if(p.first==pre) continue;\n        else return p.second+dfs(v,p.first,node,depth+1,k,st);\n    }\n    return -INF;\n}\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int n,k,s;\n    while(cin>>n>>k>>s,n){\n        vector<ll> x(n),y(n),z(n);\n        vector<vector<P>> g(n);\n        UF uf(n);\n        for(int i=0;i<n;i++){\n            cin>>x[i]>>y[i]>>z[i];\n        }\n        for(int i=0;i<n;i++){\n            for(int j=i+1;j<n;j++){\n                if(abs(x[i]-x[j])>=s || abs(y[i]-y[j])>=s || abs(z[i]-z[j])>=s) continue;\n                ll dx=s-abs(x[i]-x[j]), dy=s-abs(y[i]-y[j]), dz=s-abs(z[i]-z[j]);\n                ll dif=2*(dx*dy+dy*dz+dz*dx);\n                g[i].push_back(P(j,dif));\n                g[j].push_back(P(i,dif));\n                uf.unite(i,j);\n                //cout<<i<<\" \"<<j<<\" \"<<dif<<endl;\n            }\n        }\n        bool f=false;\n        ll res=s*s*6*k, ma=res;\n        for(int i=0;i<n;i++){\n            if(uf.size(i)<k) continue;\n            f=true;\n            if(g[i].size()==0) continue;\n            if(g[i].size()==1) res=min(res,ma-dfs(g,i,-1,1,k,-1));\n            else{\n                int p=g[i][0].first,q=g[i][1].first;\n                res=min(res,ma-dfs(g,i,p,1,k,i));\n                res=min(res,ma-dfs(g,i,q,1,k,i));\n            }\n        }\n        if(!f){\n            cout<<-1<<endl;\n            continue;\n        }\n        cout<<res<<endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\n\nlong long N, K, S, X[2009], Y[2009], Z[2009], col[2009], cnts; vector<int>x[2009], G[2009]; bool used[2009];\n\nvoid init() {\n\tfor (int i = 0; i < 2009; i++) {\n\t\tX[i] = 0; Y[i] = 0; Z[i] = 0; cnts = 0; col[i] = 0;\n\t\tx[i].clear(); G[i].clear(); used[i] = false;\n\t}\n}\n\nvoid dfs(int pos) {\n\tif (col[pos] >= 1) return;\n\tcol[pos] = cnts; G[cnts].push_back(pos);\n\tfor (int i = 0; i < x[pos].size(); i++) dfs(x[pos][i]);\n}\n\nlong long reduction(long long a, long long b) {\n\tlong long G1 = abs(X[a] - X[b]); G1 = S - G1;\n\tlong long G2 = abs(Y[a] - Y[b]); G2 = S - G2;\n\tlong long G3 = abs(Z[a] - Z[b]); G3 = S - G3;\n\treturn G1*G2 + G2*G3 + G3*G1;\n}\n\nlong long solve(vector<long long>A, bool ispath) {\n\tif (ispath == false) {\n\t\tlong long minx = (1LL << 60);\n\t\tfor (int i = 0; i < A.size(); i++) {\n\t\t\tint LL = i, RR = i + K - 1;\n\n\t\t\tlong long V = 0;\n\t\t\tfor (int j = LL; j <= RR; j++) V += S*S * 6;\n\t\t\tfor (int j = LL; j < RR; j++) V -= 2LL * reduction(A[j % A.size()], A[(j + 1) % A.size()]);\n\t\t\tminx = min(minx, V);\n\t\t}\n\t\treturn minx;\n\t}\n\tif (ispath == true) {\n\t\tlong long minx = (1LL << 60);\n\t\tfor (int i = 0; i < A.size(); i++) {\n\t\t\tint LL = i, RR = i + K - 1; if (RR >= A.size()) continue;\n\n\t\t\tlong long V = 0;\n\t\t\tfor (int j = LL; j <= RR; j++) V += S*S * 6;\n\t\t\tfor (int j = LL; j < RR; j++) V -= 2LL * reduction(A[j], A[j + 1]);\n\t\t\tminx = min(minx, V);\n\t\t}\n\t\treturn minx;\n\t}\n}\n\nint main() {\n\twhile (true) {\n\t\tcin >> N >> K >> S; init(); if (N + K + S == 0) break;\n\t\tfor (int i = 1; i <= N; i++) cin >> X[i] >> Y[i] >> Z[i];\n\t\tfor (int i = 1; i <= N; i++) {\n\t\t\tfor (int j = 1; j <= N; j++) {\n\t\t\t\tif (abs(X[i] - X[j]) <= S && abs(Y[i] - Y[j]) <= S && abs(Z[i] - Z[j]) <= S && i != j) {\n\t\t\t\t\tx[i].push_back(j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i <= N; i++) {\n\t\t\tif (col[i] == 0) { cnts++; dfs(i); }\n\t\t}\n\t\tlong long minx = (1LL << 60);\n\t\tfor (int i = 1; i <= cnts; i++) {\n\t\t\tvector<long long>A;\n\t\t\tint t = -1; bool ispath = true;\n\t\t\tfor (int j = 0; j < G[i].size(); j++) {\n\t\t\t\tif (x[G[i][j]].size() <= 1) t = G[i][j];\n\t\t\t}\n\t\t\tif (t == -1) { t = G[i][0]; ispath = false; }\n\n\t\t\twhile (true) {\n\t\t\t\tA.push_back(t); used[t] = true;\n\t\t\t\tint u = -1;\n\t\t\t\tfor (int j = 0; j < x[t].size(); j++) {\n\t\t\t\t\tif (used[x[t][j]] == false) u = x[t][j];\n\t\t\t\t}\n\t\t\t\tif (u == -1) break;\n\t\t\t\tt = u;\n\t\t\t}\n\t\t\tminx = min(minx, solve(A, ispath));\n\t\t}\n\t\tif (minx == (1LL << 60)) minx = -1;\n\t\tcout << minx << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define loop for(;;)\ntypedef std::vector<long> LI;\ntemplate<typename T> void scan1(T& x) { fprintf(stderr, \"unknown type\\n\"); }\ntemplate<> void scan1(long& x) { if( scanf(\"%ld\", &x) < 0 ) exit(0); }\ntemplate<> void scan1(std::string& x) { if( not ( std::cin >> x ) ) exit(0); }\nvoid scan() {}\ntemplate<typename Head, typename... Tail>\nvoid scan(Head& x, Tail&... xs) {\n  scan1(x); scan(xs...);\n}\n\nstruct Solver {\n   std::vector<long> nexts[2123];\n   std::vector<long> overlap[2123];\n   long n, len, s;\n   LI xs, ys, zs;\n   long f(long i, long k) {\n      long dx = std::max((long)0, s - std::abs(xs[k] - xs[i]));\n      long dy = std::max((long)0, s - std::abs(ys[k] - ys[i]));\n      long dz = std::max((long)0, s - std::abs(zs[k] - zs[i]));\n      if( dx == 0 or dy == 0 or dz == 0 ) return 0;\n      return 2 * (dx * dy + dy * dz + dz * dx);\n   }\n   void solve() {\n      scan(n, len, s);\n      if( n == 0 and len == 0 and s == 0 ) exit(0);\n      xs.resize(n), ys.resize(n), zs.resize(n);\n      for(long i = 0; i < n; ++i) scan(xs[i], ys[i], zs[i]);\n      for(long i = 0; i < n; ++i) {\n         for(long k = 0; k < n; ++k) {\n            if( i == k ) continue;\n            long over = f(i, k);\n            if( over == 0 ) continue;\n            nexts[i].push_back(k);\n            overlap[i].push_back(over);\n         }\n      }\n      long res = -(1LL << 53);\n      for(long i = 0; i < n; ++i) {\n         visited.resize(n, false);\n         res = std::max(res, dfs(i, len-1, i));\n      }\n      visited.resize(n);\n      printf(\"%ld\\n\", res >= 0 ? 6 * s * s * len - res : -1);\n   }\n   std::vector<bool> visited;\n   long dfs(long v, long d, long begin) {\n      if( d == 0 ) {\n         if( len >= 3 ) {\n            for(long i = 0; i < (long)nexts[v].size(); ++i) {\n               long next = nexts[v][i];\n               long over = overlap[v][i];\n               if( next == begin ) {\n                  return over;\n               }\n            }\n         }\n         return 0;\n      }\n      long res = -(1LL << 53);\n      visited[v] = true;\n      for(long i = 0; i < (long)nexts[v].size(); ++i) {\n         long next = nexts[v][i];\n         long over = overlap[v][i];\n         if( visited[next] ) continue;\n         res = std::max(res, dfs(next, d-1, begin) + over);\n      }\n      visited[v] = false;\n      return res;\n   }\n};\n\nint main() {\n   loop std::shared_ptr<Solver>(new Solver())->solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <array>\n#include <cassert>\n#include <climits>\n#include <complex>\n#include <cstdio>\n#include <cstring>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <iterator>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <string>\n#include <tuple>\n#include <vector>\n\nusing namespace std;\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define ALL(x) (x).begin(), (x).end()\n\nint subcube(int len, int x0, int y0, int z0, int x1, int y1, int z1) {\n    int dx = x0 - x1, dy = y0 - y1, dz = z0 - z1;\n    int sx = max(min(len + dx, len - dx), 0);\n    int sy = max(min(len + dy, len - dy), 0);\n    int sz = max(min(len + dz, len - dz), 0);\n    return (sx * sy * sz == 0) ? 0 : 2 * (sx * sy + sy * sz + sz * sx);\n}\n\nint main(){\n    int n, k, s; \n    while(cin >> n >> k >> s, n != 0){\n    vector<int> xs(n), ys(n), zs(n);\n    REP(i, n) {\n        cin >> xs[i] >> ys[i] >> zs[i];\n    }\n\n    if (k == 1) cout << s * s * 6 * k << endl;\n    vector<vector<int>> subc(n, vector<int>(n));\n    REP(a, n) {\n        REP(b, n) {\n            if (a == b) {/*cout << \"--\\t\";*/ continue;}\n            subc[a][b] = subcube(s, xs[a], ys[a], zs[a], xs[b], ys[b], zs[b]);\n            //cout << subc[a][b] << \"\\t\";\n        }\n        cout << endl;\n    }\n\n    vector<vector<int>> segs;\n    vector<int> used(n, false);\n\n    /// 4 8 12 16 20\n    REP(a, n){\n        if (used[a]) continue;\n        vector<int> seg;\n        int p = a; bool ok = true;\n        seg.push_back(p);\n        used[a] = true;\n        while(ok) {\n            ok = false;\n            REP(b, n) {\n                if (subc[p][b] > 0) {\n                    if (used[b]) continue;\n                    p = b;\n                    seg.push_back(p);\n                    used[b] = true;\n                    ok = true;\n                    break;\n                }\n            }\n        }\n        reverse(ALL(seg));\n        p = a;\n        ok = true;\n        while(ok) {\n            ok = false;\n            REP(b, n) {\n                //cout << \"?\" << a << \"->\" << b << endl;\n                if (subc[p][b] > 0) {\n                    if (used[b]) continue;\n                    p = b;\n                    seg.push_back(p);\n                    used[b] = true;\n                    ok = true;\n                    break;\n                }\n            }\n        }\n        segs.push_back(seg);\n    }\n\n    int res = -1;\n    REP(i, segs.size()) {\n        const vector<int> seg(segs[i]);\n        \n        /*cout << \"# \"; REP(a, seg.size()) {\n            cout << seg[a] << \" \";\n        } cout << endl;*/\n        \n        const int l = seg.size();\n        if (l < k) { continue; }\n        if (l == k) {\n            int sum = 0;\n            if (l == 2) {\n                res = max(res, subc[seg[0]][seg[1]]);\n                continue;\n            }\n            REP(a, l) {\n                //cout << \"+=\" << seg[a] << \" \" << seg[(a+1)%l] << endl;\n                //cout << \"   : \" << subc[seg[a]][seg[(a+1)%l]] << endl;\n                sum += subc[seg[a]][seg[(a+1)%l]];\n            }\n            res = max(res, sum);\n            continue;\n        }\n        int sum = 0;\n        REP(a, k - 1) {\n            sum += subc[seg[a]][seg[a+1]];\n        }\n        REP(a, l) {\n            res = max(res, sum);\n            int ad = subc[seg[(a + k - 1) % l]][seg[(a + k) % l]];\n            if (ad == 0) break;\n            sum += ad;\n            sum -= subc[seg[(a % l)]][seg[(a + 1) % l]];\n        }\n    }\n\n    // cout << \"$\" << subc[0][1] << endl;\n    // cout << res << endl;\n    if (res < 0) cout << res << endl;\n    else cout << s * s * 6 * k - res << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<P,int> PP;\n\nint N, K, S;\nvector<PP> V;\n\nbool check(PP a, PP b) {\n    if (!(a.first.first > b.first.first + S || a.first.first + S < b.first.first)) {\n        if (!(a.first.second > b.first.second + S || a.first.second + S < b.first.second)) {\n            if (a.second >= b.second + S || a.second + S <= b.second) return false;\n            else return true;\n        }\n    }\n\n    return false;\n}\n\nint diff(int a, int b) {\n    int sub_x = S - abs(V[a].first.first - V[b].first.first);\n    int sub_y = S - abs(V[a].first.second - V[b].first.second);\n    int sub_z = S - abs(V[a].second - V[b].second);\n\n    return (sub_x * sub_y + sub_z * sub_y + sub_z * sub_x) * 2;\n}\n\nint dfs(vector<vector<bool>>& inter, vector<bool>& used, int now, int k, int men, int pre) {\n    if (k == K- 1) {\n        for (int i = 0; i < N; i++) {\n            if (inter[now][i] && used[i] && pre != i) {\n                return diff(i, now);\n            }\n        }\n        return 0;\n    }\n    used[now] = true;\n\n    int res = -(1<<28);\n    for (int i = 0; i < N; i++) {\n        if (used[i] == false && inter[now][i])\n            res = max(res ,dfs(inter, used, i, k + 1, men, now) + diff(now, i));\n    }\n    used[now] = false;\n\n    return res;\n}\n\nvoid solve() {\n    V.resize(N);\n    for (int i = 0; i < N; i++) cin >> V[i].first.first >> V[i].first.second >> V[i].second;\n    vector<vector<bool>> inter(N, vector<bool>(N));\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            inter[i][j] = check(V[i], V[j]);\n        }\n    }\n\n    int ans = 1 << 28;\n    for (int i = 0; i < N; i++) {\n        vector<bool> used(N);\n        ans = min(ans, S * S * 6 * K - dfs(inter, used, i, 0, 0, -1));\n    }\n\n    if (ans == 1 << 28) {\n        cout << -1 << endl;\n    } else {\n        cout << ans << endl;\n    }\n}\n\nint main() {\n    while (cin >> N >> K >> S, N || K || S) {\n        solve();\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ninline int abs(int a, int b) {return a<b ? b-a : a-b;}\n\nint n, k, s;\n\nstruct cube\n{\n    int x, y, z;\n    cube() : x(0),y(0),z(0) {}\n    cube(int p, int q, int r) : x(p), y(q), z(r) {}\n\n    int intersect(const cube &o)\n    {\n        int ix = s - abs(this->x, o.x);\n        int iy = s - abs(this->y, o.y);\n        int iz = s - abs(this->z, o.z);\n        return (ix>0 && iy>0 && ix>0) ? 2*(ix*iy + iy*iz + iz*ix) : 0;\n    }\n\n};\n\nstruct vertex {\n    int num, deg, es[2], ws[2];\n    vertex() : num(0), deg(0) {es[0] = es[1] = ws[0] = ws[1] = 0;}\n    vertex(int n) : num(n), deg(0) {es[0] = es[1] = ws[0] = ws[1] = 0;}\n\n    int append(int o, int w)\n    {\n        es[deg] = o;\n        ws[deg++] = w;\n    }\n\n    int another(int i)\n    {\n        if(deg<2) return -1;\n        return es[0]==i ? es[1] : es[0];\n    }\n\n    int weight(int i)\n    {\n        return es[0]==i ? ws[0] : ws[1];\n    }\n};\n\nint search(int i, int k, vertex *vs, bool *checked)\n{\n    if(checked[i]) return -1;\n    checked[i] = true;\n    if(vs[i].deg == 0) return -1;\n    int p = vs[i].es[0];\n    checked[p] = true;\n    int e = i;\n    int vc = 1;\n    bool is_cycle = false, force_cycle = true;\n    if(vs[i].deg == 1)\n    {\n        p = i;\n    }\n    if(vs[i].deg == 2)\n    {\n        while(true)\n        {\n            if(vs[p].deg == 1)\n            {\n                break;\n            }\n            if(p==i)\n            {\n                is_cycle = true;\n                if(vc<k) return -1;\n                if(vc==k) force_cycle = true;\n                break;\n            }\n            int q = vs[p].another(e);\n            e = p;\n            p = q;\n            checked[q] = true;\n            vc++;\n        }\n    }\n    // search\n    deque<int> deq;\n    int sum = 0;\n    int max_sum = 0;\n    if(is_cycle)\n    {\n        // for cycle\n        int q = vs[p].es[0];\n        int w = vs[p].ws[0];\n        sum += w;\n        deq.push_back(w);\n        for(int j=(force_cycle ? 1 : 2); j<k; j++)\n        {\n            int r = vs[q].another(p);\n            w = vs[q].weight(r);\n            sum += w;\n            deq.push_back(w);\n            p = q;\n            q = r;\n        }\n        int qq = q;\n        max_sum = sum;\n        do\n        {\n            int r = vs[q].another(p);\n            w = vs[q].weight(r);\n            sum += w;\n            deq.push_back(w);\n            sum -= deq.front();\n            deq.pop_front();\n            max_sum = max(max_sum, sum);\n            p = q;\n            q = r;\n        }while(q != qq);\n    }\n    else\n    {\n        // for path\n        int q = vs[p].es[0];\n        checked[q] = true;\n        int w = vs[p].ws[0];\n        sum += w;\n        deq.push_back(w);\n        for(int j=2; j<k; j++)\n        {\n            if(vs[q].deg == 1) return -1;\n            int r = vs[q].another(p);\n            checked[r] = true;\n            w = vs[q].weight(r);\n            sum += w;\n            deq.push_back(w);\n            p = q;\n            q = r;\n        }\n        max_sum = sum;\n        while(vs[q].deg !=1)\n        {\n            int r = vs[q].another(p);\n            checked[r] = true;\n            w = vs[q].weight(r);\n            sum += w;\n            deq.push_back(w);\n            sum -= deq.front();\n            deq.pop_front();\n            max_sum = max(max_sum, sum);\n            p = q;\n            q = r;\n        }\n    }\n    return max_sum;\n}\n\nint main()\n{\n    while(cin >> n >> k >> s, n|k|s)\n    {\n        cube cs[n];\n        vertex vs[n];\n        for(int i=0; i<n; i++)\n        {\n            int x, y, z;\n            cin >> x >> y >> z;\n            cs[i] = cube(x,y,z);\n            vs[i] = vertex(i);\n            for(int j=0; j<i; j++)\n            {\n                int s = cs[j].intersect(cs[i]);\n                if(s>0)\n                {\n                    vs[j].append(i, s);\n                    vs[i].append(j, s);\n                }\n            }\n        }\n\n        if(k==1)\n        {\n            // k==1?\n            cout << 6 * s * s << endl;\n        }\n        else\n        {\n            // search\n            bool checked[n];\n            int result = -1;\n            for(int i=0; i<n; i++) checked[i] = false;\n            for(int i=0; i<n; i++)\n            {\n                result = max(result, search(i, k, vs, checked));\n            }\n            if(result>=0) result = 6 * s * s * k - result; \n            cout << result << endl;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;++i)\nstruct edge{int to,cost;};\nvector<vector<edge>> G;\n\nint dfs(int v,int p,int s,int k) {\n\tint res=INT_MIN;\n\tfor(auto e:G[v])if(e.to!=p){\n\t\tif(k>0 && e.to!=s) res=max(res,dfs(e.to,v,s,k-1)+e.cost);\n\t\tif(k==0 && e.to==s) return e.cost;\t//k-ring\n\t}\n\treturn (k==0 ? 0 : res);\n}\n\nint main(){\n\tint n,k,s;\n\twhile(cin>>n>>k>>s,n|k|s){\n\t\tvector<int> x(n),y(n),z(n);\n\t\trep(i,n) cin>>x[i]>>y[i]>>z[i];\n\t\tG.clear(), G.resize(n);\n\t\trep(i,n)rep(j,n)if(i!=j){\n\t\t\tint sx = s-abs(x[i]-x[j]);\n\t\t\tint sy = s-abs(y[i]-y[j]);\n\t\t\tint sz = s-abs(z[i]-z[j]);\n\t\t\tif(min({sx,sy,sz})>0){\n\t\t\t\tG[i].push_back({j,2*(sx*sy+sy*sz+sz*sx)});\n\t\t\t}\n\t\t}\n\t\tint res=-1;\n\t\trep(i,n) res=max(res,dfs(i,-1,i,k-1));\n\t\tcout<<(res>=0 ? s*s*6*k-res : -1)<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cmath>\n#include <map>\n\nusing namespace std;\n\ntypedef  long long ll;\nll inf = (ll)20000000000000;\nvector<ll>x,y,z;\nint n,k,s;\nll calc(int i,int j){\n    ll tx=0,ty=0,tz=0;    \n    if(x[i]<=x[j]&&x[j]<=x[i]+s){\n        tx = x[i]+s-x[j];\n    }\n    if(y[i]<=y[j]&&y[j]<=y[i]+s){\n        ty = y[i]+s-y[j];\n    }\n    if(z[i]<=z[j]&&z[j]<=z[i]+s){\n        tz = z[i]+s-z[j];\n    }\n    if(x[j]<=x[i]&&x[i]<=x[j]+s){\n        tx = x[j]+s-x[i];\n    }\n    if(y[j]<=y[i]&&y[i]<=y[j]+s){\n        ty = y[j]+s-y[i];\n    }\n    if(z[j]<=z[i]&&z[i]<=z[j]+s){\n        tz = z[j]+s-z[i];\n    }\n    if(tx==0||ty==0||tz==0){\n        return -1;\n    }\n    return 2*(tx*ty+ty*tz+tz*tx);\n}\n\nll saiki(int st,int i,int b,int c,vector<vector<pair<int,ll> > > &g){\n    if(c==k){\n        ll p = 0;\n        for(auto x:g[i]){\n            if(x.first==st&&k!=2){\n                p = x.second;\n            }\n        }\n        return p;\n    }\n    ll p = -inf;\n    for(auto x:g[i]){\n        if(x.first!=st&&x.first!=b){\n            p = max(p,x.second+saiki(st,x.first,i,c+1,g));\n        }\n    }\n    return p;\n}\n\nint main(){\n    \n    while(scanf(\"%d %d %d\",&n,&k,&s)&&n!=0){\n        x.resize(n);y.resize(n);z.resize(n);\n        for(int i=0;i<n;i++)scanf(\"%lld %lld %lld\",&x[i],&y[i],&z[i]);\n        vector<vector<pair<int,ll> > >g(n);\n        for(int i=0;i<n;i++){\n            for(int j=0;j<n;j++){\n                if(i<j){\n                    ll sm = calc(i,j);\n                    if(sm!=-1){\n                        g[i].push_back(make_pair(j,sm));\n                        g[j].push_back(make_pair(i,sm));\n                    }\n                }\n            }\n        }\n        ll ans = -1;\n        if(k==1){\n            cout << s*s*6 << endl;\n            continue;\n        }\n        for(int i=0;i<n;i++){\n            ans = max(ans,saiki(i,i,-1,1,g));\n        }\n        if(ans ==-1)cout << -1 << endl;\n        else cout << s*s*k*6-ans << endl;\n\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i,n) for(int i = 0;i < (n);i++)\nconst long long INF = 2 * (int)(1e9);\nusing namespace std;\n\nint N, K, S;\n\nstruct Point{\n    int x, y, z;\n};\n\nPoint p[2003];\n\nbool iscycle[2003];\nbool used[2003];\ndeque<int> graph[2003];\n\nint getS(Point a,Point b){\n    if(a.x > b.x) swap(a.x, b.x);\n    if(a.y > b.y) swap(a.y, b.y);\n    if(a.z > b.z) swap(a.z, b.z);\n    return (a.x + S - b.x) * (a.y + S - b.y) * 2\n        +  (a.z + S - b.z) * (a.x + S - b.x) * 2\n        +  (a.y + S - b.y) * (a.z + S - b.z) * 2;\n}\n\nbool connected(int a,int b){\n    return (abs(p[a].x-p[b].x) <= S) && (abs(p[a].y-p[b].y) <= S) && (abs(p[a].z-p[b].z) <= S);\n}\n\nvoid makegraph(int graphct, int i, bool maincalled, bool back){\n    REP(j,N){\n        if(used[j])continue;\n        if(connected(i,j)){\n            used[j] = true;\n            if(graph[graphct].size() > 1 && (maincalled || back)){\n                graph[graphct].push_front(j);\n                makegraph(graphct, j, false, true);\n            }else{\n                graph[graphct].push_back(j);\n                makegraph(graphct, j, false, false);\n            }\n        }\n    }\n}\n\n\nint main(){\n    while(cin >> N >> K >> S, N){\n        REP(i,N){\n            int x, y, z;\n            cin >> x >> y >> z;\n            p[i] = Point{x, y, z};\n            graph[i].clear();\n            iscycle[i] = false;\n            used[i] = false;\n        }\n\n        //make graph\n        int graphct = 0;\n        REP(i,N){\n            if(used[i]) continue;\n            graph[graphct].push_back(i);\n            used[i] = true;\n            makegraph(graphct, i, true, true);\n            graphct++;\n        }\n\n        //cycle check\n        REP(i,graphct){\n            if(graph[i].size() > 2 && connected(graph[i][0],graph[i][graph[i].size() - 1]))\n                iscycle[i] = true;\n        }\n        \n        long long ans = INF;\n        REP(i,graphct){\n            if((int)graph[i].size() < K) continue;\n            REP(j,graph[i].size()){\n                if(j + K - 1 > graph[i].size() - 1) break;\n                long long tmpans = 0;\n                for(int r = 0; r < K;r++){\n                    tmpans += S*S*6;\n                    if(r){\n                        tmpans -= getS(p[graph[i][j + r]], p[graph[i][j + r - 1]]);\n                    }else if(iscycle[i] && K == graph[i].size()){\n                        tmpans -= getS(p[graph[i][0]], p[graph[i][graph[i].size() - 1]]);\n                    }\n                }\n                ans = min(tmpans, ans);\n            }\n        }\n        if(ans == INF) cout << -1 << endl;\n        else cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cstring>\nusing namespace std;\nusing ll = long long;\n\nstruct Cube{\n    ll lx, rx;\n    ll ly, ry;\n    ll lz, rz;\n    ll S(){\n        ll dx = rx - lx;\n        ll dy = ry - ly;\n        ll dz = rz - lz;\n        return (dx * dy + dy * dz + dz * dx) * 2;\n    } \n};\n\nll f(Cube c1, Cube c2){\n    ll L[3][2] = {{c1.lx, c2.lx}, {c1.ly, c2.ly}, {c1.lz, c2.lz}};\n    ll R[3][2] = {{c1.rx, c2.rx}, {c1.ry, c2.ry}, {c1.rz, c2.rz}};\n    ll LX, LY, LZ, RX, RY, RZ;\n    ll sum = 0;\n    LX = max(c1.lx, c2.lx);\n    RX = min(c1.rx, c2.rx);\n    LY = max(c1.ly, c2.ly);\n    RY = min(c1.ry, c2.ry);\n    LZ = max(c1.lz, c2.lz);\n    RZ = min(c1.rz, c2.rz);\n    if(RX <= LX) return 0;\n    if(RY <= LY) return 0;\n    if(RZ <= LZ) return 0;\n    ll dx = RX - LX;\n    ll dy = RY - LY;\n    ll dz = RZ - LZ;\n    return (dx * dy + dy * dz + dz * dx) * 2;\n}\n\nint n, k, s;\nCube c[2000];\nint vis[2000];\n\nvector<int> G[2000];\n\nvector<vector<int>> C;// テ」ツつオテ」ツつ、テ」ツつッテ」ツδォ\nvector<vector<int>> S;// テ、ツクツ?ヲツ慊ャテゥツ??\n\n// テ」ツつオテ」ツつ、テ」ツつッテ」ツδォテ」ツ?凝」ツ?ゥテ」ツ??」ツ??\nbool dfs(int v, int p, vector<int>& a){\n    vis[v] = 1;\n    a.push_back(v);\n    for(int c : G[v]){\n        if(c == p) continue;\n        if(vis[c]) continue;\n        return dfs(c, v, a);\n    }\n    // \n    return G[v].size() == 2;\n}\n\n// テ・ツ?アテゥツ?堙ゥツ敖「テァツゥツ?\nll X[2000][2000];\n\nint main(){\n    while(cin >> n >> k >> s, n){\n        for(int i = 0; i < n; i++){\n            cin >> c[i].lx  >> c[i].ly >> c[i].lz;\n            c[i].rx = c[i].lx + s;\n            c[i].ry = c[i].ly + s;\n            c[i].rz = c[i].lz + s;\n            G[i].clear();\n        }\n        C.clear();\n        S.clear();\n\n        for(int i = 0; i < n; i++){\n            for(int j = 0; j < n; j++){\n                if(i == j) continue;\n                ll res = f(c[i], c[j]);\n                X[i][j] = res;\n                if(res) G[i].push_back(j);\n            }\n        }\n\n        memset(vis, 0, sizeof vis);\n        for(int i = 0; i < n; i++){\n            if(vis[i]) continue;\n            if(G[i].size() == 1){\n                vector<int> a;\n                bool res = dfs(i, -1, a);\n                if(a.size() < k) continue;\n                S.push_back(a);\n            }   \n        }\n        for(int i = 0; i < n; i++){\n            if(vis[i]) continue;\n            vector<int> a;\n            bool res = dfs(i, -1, a);\n            if(a.size() < k) continue;\n            C.push_back(a);\n        }\n\n        ll ans = 1LL << 61;\n        for(auto a : C){\n            int sz = a.size();\n            for(int i = 0; i < sz; i++) a.push_back(a[i]);\n            ll sum = 0;\n            for(int i = 0; i < k; i++){\n                sum += c[a[i]].S();\n                if(i != k - 1 || k == sz) sum -= X[a[i]][a[i + 1]];\n            }\n            for(int i = 0; i < sz; i++){\n                ans = min(ans, sum);\n                sum -= c[a[i]].S();\n                sum += X[a[i]][a[i+1]];\n                sum += c[a[i+k]].S();\n                sum -= X[a[i+k-1]][a[i+k]];\n            }\n            if(k != sz){\n                ans = min(ans, sum);\n            }\n        }\n        for(auto a : S){\n            ll sum = 0;\n            for(int i = 0; i < k; i++){\n                sum += c[a[i]].S();\n                if(i != k - 1) sum -= X[a[i]][a[i + 1]];\n            }\n            for(int i = 0; i < a.size() - k; i++){\n                ans = min(ans, sum);\n                sum -= c[a[i]].S();\n                sum += X[a[i]][a[i+1]];\n                sum += c[a[i+k]].S();\n                sum -= X[a[i+k-1]][a[i+k]];\n            }\n            ans = min(ans, sum);\n        }\n        if(ans == 1LL << 61) cout << -1 << endl;\n        else cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<iomanip>\n#include<sstream>\n#include<map>\n#include<queue>\nusing namespace std;\n#define int long long\nint N, K, S;\nvector<vector<int> >ne;\nvector<vector<int> >cost;\nint kasanari(int x1, int x2) {\n\tif (x1 > x2) {\n\t\tswap(x1, x2);\n\t}\n\tif (x1 + S <= x2)return 0;\n\treturn x1 + S - x2;\n}\n\nsigned main() {\n\twhile (true) {\n\t\tcin >> N >> K >> S;\n\t\tif (N == 0)break;\n\t\tvector<int> X(N);\n\t\tvector<int> Y(N);\n\t\tvector<int> Z(N);\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tcin >> X[i] >> Y[i] >> Z[i];\n\t\t}\n\t\tne.clear();\n\t\tne.resize(N);\n\t\tcost.clear();\n\t\tcost.resize(N);\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tfor (int j = 0; j < i; j++) {\n\t\t\t\tint dx = kasanari(X[i], X[j]);\n\t\t\t\tint dy = kasanari(Y[i], Y[j]);\n\t\t\t\tint dz = kasanari(Z[i], Z[j]);\n\t\t\t\tif (dx == 0 || dy == 0 || dz == 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tint c = 2 * (dx*dy + dy*dz + dz*dx);\n\t\t\t\tne[i].push_back(j);\n\t\t\t\tne[j].push_back(i);\n\t\t\t\tcost[i].push_back(c);\n\t\t\t\tcost[j].push_back(c);\n\t\t\t}\n\t\t}\n\t\t/*for (int i = 0; i < N; i++) {\n\t\t\tcerr << ne[i][0] << \" \" << ne[i][1] <<  endl;\n\t\t}*/\n\t\tint INF = (int)1 << 60;\n\t\tvector<int> A(N, 0);\n\n\n\t\tvector<pair<int, int> > deg(N);\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tdeg[i].first = ne[i].size();\n\t\t\tdeg[i].second = i;\n\t\t}\n\t\tsort(deg.begin(), deg.end());\n\t\tint nc;\n\t\tint snc = 0;\n\t\tint res = INF;\n\t\tfor (auto d : deg) {\n\t\t\tint ii = d.second;\n\t\t\tif (A[ii] == 0) {\n\n\t\t\t\tvector<int> cs;\n\t\t\t\tif ((int)cost[ii].size() == 2)cs.push_back(cost[ii][1]);\n\t\t\t\tint cur = ii;\n\t\t\t\tA[cur] = 1;\n\n\t\t\t\twhile (true) {\n\t\t\t\t\t//cerr << cur << endl;\n\t\t\t\t\tfor (int j = 0; j < ne[cur].size(); j++) {\n\t\t\t\t\t\tif (A[ne[cur][j]] == 0) {\n\t\t\t\t\t\t\tnc = cost[cur][j];\n\t\t\t\t\t\t\tcur = ne[cur][j];\n\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (A[cur] == 1)break;\n\t\t\t\t\tA[cur] = 1;\n\t\t\t\t\tcs.push_back(nc);\n\t\t\t\t}\n\t\t\t\tif ((int)cs.size() > K || ((int)cs.size() == K && cost[ii].size() <= 1)) {\n\t\t\t\t\t//cerr << \"ok\" << endl;\n\t\t\t\t\tint sm = 0;\n\t\t\t\t\tfor (int i = 0; i < K - 1; i++) {\n\t\t\t\t\t\tsm += cs[i];\n\t\t\t\t\t}\n\t\t\t\t\tres = min(res, 6 * K*S*S - sm);\n\t\t\t\t\tint l;\n\t\t\t\t\tif ((int)cost[ii].size() == 2) {\n\t\t\t\t\t\tl = cs.size();\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tl = cs.size() - K + 1;\n\t\t\t\t\t}\n\t\t\t\t\tfor (int i = 0; i < l; i++) {\n\t\t\t\t\t\tsm -= cs[i];\n\t\t\t\t\t\tsm += cs[(i + K - 1) % cs.size()];\n\t\t\t\t\t\tres = min(res, 6 * K*S*S - sm);\n\t\t\t\t\t}\n\t\t\t\t\tif (res == 1424) {\n\t\t\t\t\t\tcerr << \"1\" << endl;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (cs.size() == K) {\n\t\t\t\t\tint sm = 0;\n\t\t\t\t\tfor (int i = 0; i < cs.size(); i++) {\n\t\t\t\t\t\tsm += cs[i];\n\t\t\t\t\t}\n\t\t\t\t\tres = min(res, 6 * K*S*S - sm);\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\telse if (cs.size() == K - 1) {\n\t\t\t\t\t//cerr << \"ok\" << endl;\n\t\t\t\t\tif ((int)cost[ii].size() != 2) {\n\t\t\t\t\t\tint sm = 0;\n\t\t\t\t\t\tfor (int i = 0; i < cs.size(); i++) {\n\t\t\t\t\t\t\tsm += cs[i];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tres = min(res, 6 * K*S*S - sm);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\n\t\t\t\t}\n\n\n\t\t\t}\n\t\t}\n\t\tif (res == INF) {\n\t\t\tcout << -1 << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << res << endl;\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing ll = long long;\nstruct Edge {\n    int dst;\n    ll w;\n    Edge() {}\n    Edge(int d, ll w) : dst(d), w(w) {}\n};\nusing Graph = vector<vector<Edge>>;\nstruct Cube { ll p[3]; };\n\n\nGraph MakeGraph(const int n, const int s, vector<Cube> &c) {\n    Graph g(n);\n    ll d[3];\n\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            for (int k = 0; k < 3; ++k)\n                d[k] = s + ((c[i].p[k] < c[j].p[k]) ? (c[i].p[k] - c[j].p[k]) : (c[j].p[k] - c[i].p[k]));\n\n            if (d[0] <= 0 || d[1] <= 0 || d[2] <= 0) continue;\n\n            ll w = 2 * d[0] * d[1] + 2 * d[0] * d[2] + 2 * d[1] * d[2];\n            g[i].emplace_back(Edge(j, w));\n            g[j].emplace_back(Edge(i, w));\n        }\n    }\n\n    return g;\n}\n\nint MinimumArea(const int n, const int k, const int s, const Graph &g) {\n    vector<bool> used(n, false);\n    ll res = -1;\n\n    for (int u = 0; u < 2 * n; ++u) {\n        if (used[u % n] || (u < n && g[u % n].size() == 2)) continue;\n\n        const int v = u % n;\n\n        vector<int> sub;\n        int cur = v;\n        while (true) {\n            used[cur] = true;\n            sub.push_back(cur);\n            if (1 <= g[cur].size() && !used[g[cur][0].dst])\n                cur = g[cur][0].dst;\n            else if (g[cur].size() == 2 && !used[g[cur][1].dst])\n                cur = g[cur][1].dst;\n            else\n                break;\n        }\n\n        const int size = sub.size();\n        if (size < k) continue;\n\n        ll sum = 0;\n        for (int i = 0; i < k - 1; ++i)\n            sum += ((g[sub[i]][0].dst == sub[i + 1]) ? g[sub[i]][0].w : g[sub[i]][1].w);\n\n        const bool is_cycle = (g[sub[0]].size() == 2);\n        if (size == k && is_cycle)\n            sum += ((g[sub[0]][0].dst == sub[size - 1]) ? g[sub[0]][0].w : g[sub[0]][1].w);\n        res = max(res, sum);\n\n        const int lim = (is_cycle ? size - 1 : size - k);\n        for (int i = 1; i <= lim; ++i) {\n            sum -= ((g[sub[i]][0].dst == sub[i - 1]) ? g[sub[i]][0].w : g[sub[i]][1].w);\n            const int j1 = (i + k - 2) % size, j2 = (i + k - 1) % size;\n            sum += ((g[sub[j1]][0].dst == j2) ? g[sub[j1]][0].w : g[sub[j1]][1].w);\n            res = max(res, sum);\n        }\n    }\n\n    return (res == -1) ? -1 : 6 * k * s * s - res;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int n, k, s;\n\n    while (cin >> n >> k >> s, n) {\n        vector<Cube> cube(n);\n        for (auto &c : cube)\n            for (int i = 0; i < 3; ++i) cin >> c.p[i];\n\n        cout << MinimumArea(n, k, s, MakeGraph(n, s, cube)) << '\\n';\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n#include <climits>\n#include <cstring>\n\n#define rep(i, m, n) for(int i=int(m);i<int(n);i++)\n#define all(c) begin(c),end(c)\n\ntemplate<typename T1, typename T2>\ninline void chmin(T1 &a, T2 b) { if (a > b) a = b; }\n\ntemplate<typename T1, typename T2>\ninline void chmax(T1 &a, T2 b) { if (a < b) a = b; }\n\n//改造\ntypedef long long int ll;\nusing ll = long long int;\nusing ull = long long unsigned int;\nusing namespace std;\n#define INF (1 << 30) - 1\n#define INFl (ll)5e15\n#define DEBUG 0 //デバッグする時1にしてね\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\n#define MOD 1000000007\n\n\n//ここから編集する\nclass Solve {\npublic:\n    int n, k;\n    ll s;\n    vector<ll> X, Y, Z;\n    vector<vector<int>> G;\n\n    //共通部分を求める\n    tuple <ll, ll, ll> uni(int i, int j) {\n        tuple <ll, ll, ll> ret;\n        get<0>(ret) = s - abs(X[i] - X[j]);\n        get<1>(ret) = s - abs(Y[i] - Y[j]);\n        get<2>(ret) = s - abs(Z[i] - Z[j]);\n\n        if (get<0>(ret) < 0 || get<1>(ret) < 0 || get<2>(ret) < 0) {\n            return make_tuple(-1ll, -1ll, -1ll);\n        }\n        return ret;\n    }\n\n    // iにjを加えたときの増加する表面積\n    ll add_cube(int i, int j) {\n        ll ret = 6 * s * s;\n        auto tapi = uni(i, j);\n        ret -= 2 * get<0>(tapi) * get<1>(tapi);\n        ret -= 2 * get<1>(tapi) * get<2>(tapi);\n        ret -= 2 * get<2>(tapi) * get<0>(tapi);\n        return ret;\n    }\n\n    int dstart;\n\n    ll dfs(int v, int cnt = 1, ll square = 0, int p = -1) {\n        if (p == -1) dstart = v;\n\n        if (k == 1) {\n            return 6 * s * s;\n        }\n        if (v == dstart && cnt != 1) return INFl;\n\n        if (cnt == k) {\n            // dstartと重なっている場合はひく\n            ll ret = square;\n            if (cnt > 2 && get<0>(uni(dstart, v)) > 0) {\n                ret += add_cube(v, dstart);\n                ret -= 6 * s * s;\n            }\n            return ret;\n        }\n\n        ll ret = INFl;\n        if (cnt == 1) {\n            square += 6 * s * s;\n        }\n        for (auto e : G[v]) {\n            if (e == p) continue;\n            int nv = e;\n            int ncnt = cnt + 1;\n            ll nsquare = square + add_cube(v, e);\n            int np = v;\n            ll tmp = dfs(nv, ncnt, nsquare, np);\n            chmin(ret, tmp);\n        }\n\n        return ret;\n    }\n\n    bool solve() {\n        cin >> n >> k >> s;\n        if (n == 0 && k == 0 && s == 0) return false;\n        G.resize(n);\n\n        for (int i = 0; i < n; ++i) {\n            ll x, y, z;\n            cin >> x >> y >> z;\n            X.push_back(x);\n            Y.push_back(y);\n            Z.push_back(z);\n        }\n\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < n; ++j) {\n                if (i == j) continue;\n                auto tup = uni(i, j);\n                if (get<0>(tup) > 0) {\n                    G[i].push_back(j);\n                }\n            }\n        }\n\n        ll ans = INFl;\n        for (int i = 0; i < n; ++i) {\n            ll tmp = dfs(i);\n            chmin(ans, tmp);\n        }\n\n        if (ans == INFl) {\n            cout << -1 << endl;\n        } else {\n            cout << ans << endl;\n        }\n\n\n        return true;\n    }\n};\n\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n\n    while (Solve().solve());\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\ntypedef pair<int,int> P;//to, cov\nvector<P> E[2000];\nbool used[2000];\n\nint n,k,s,S,ans;\n\nvoid dfs(int start, int v, int len, int sur){\n    used[v]=true;\n    // cout<<v<<' '<<len<<endl;\n    if(len==k) ans = min(ans,sur);\n    for(auto p:E[v]){\n        int to, cov;\n        tie(to,cov)=p;\n        if(to==start&&len==k){\n            ans = min(ans, sur-cov);\n        }else if(!used[to]){\n            dfs(start,to,len+1,sur+S-cov);\n        }\n    }\n    used[v]=false;\n}\n\nint main(){\n    while(cin>>n>>k>>s,n){\n        vector<int> X,Y,Z;\n        for(int i=0;i<2000;i++) E[i].clear();\n        S=s*s*6;\n        ans = 1000000000;\n        for(int i=0;i<n;i++){\n            int x,y,z;\n            cin>>x>>y>>z;\n            X.push_back(x);\n            Y.push_back(y);\n            Z.push_back(z);\n        }\n        for(int i=0;i<n;i++){\n            for(int j=0;j<n;j++){\n                if(i!=j){\n                    int dx = abs(X[i]-X[j]);\n                    int dy = abs(Y[i]-Y[j]);\n                    int dz = abs(Z[i]-Z[j]);\n                    if(dx<s&&dy<s&&dz<s){\n                        // cout<<i<<' '<<j<<':'<<dx<<' '<<dy<<' '<<dz<<endl;\n                        int cov=((s-dx)*(s-dy)+(s-dy)*(s-dz)+(s-dz)*(s-dx))*2;\n                        E[i].emplace_back(j,cov);\n                    }\n                }\n            }\n        }\n        for(int i=0;i<n;i++){\n            fill(used,used+n,false);\n            dfs(i,i,1,S);\n        }\n        if(ans==1000000000)ans=-1;\n        cout<<ans<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\nusing namespace std;\nconst long long INF = 1LL << 60;    // 1.15x10^18\n\nint main() {\n    int N, K;\n    long long S;\n    while (cin >> N >> K >> S, N) {\n        vector<int> x(N), y(N), z(N);\n        for (int i = 0; i < N; i++) cin >> x[i] >> y[i] >> z[i];\n        #define dif(arr, i, j) abs(arr[i] - arr[j])\n        auto is_connected = [&](int i, int j) {\n            long long dx = dif(x, i, j), dy = dif(y, i, j), dz = dif(z, i, j);\n            return dx <= S && dy <= S && dz <= S;\n        };\n        auto isec_area = [&](int i, int j) {\n            long long dx = S - dif(x, i, j),\n                      dy = S - dif(y, i, j),\n                      dz = S - dif(z, i, j);\n            return (dx * dy + dy * dz + dz * dx) * 2;\n        };\n        vector<vector<int>> g(N);\n        for (int i = 0; i < N; i++) for (int j = 0; j < i; j++) {\n            if (is_connected(i, j)) g[i].emplace_back(j), g[j].emplace_back(i);\n        }\n        long long cube = 6 * S * S;\n        long long mi = INF;\n        auto dfs = [&](auto dfs, int u, int p, int s, int d, long long res) -> void {\n            if (d == K) {\n                if (K > 2 && is_connected(u, s)) res -= isec_area(u, s);\n                mi = min(mi, res);\n                return ;\n            }\n            for (int v: g[u]) if (v != p) {\n                dfs(dfs, v, u, s, d + 1, res - isec_area(v, u) + cube);\n            }\n        };\n        for (int s = 0; s < N; s++) dfs(dfs, s, -1, s, 1, cube);\n        if (mi == INF) mi = -1;\n        cout << mi << endl;\n    }\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\n#define int ll\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define PB push_back\n\nconst ll LLINF = (1LL<<60);\nconst int INF = (1LL<<30);\nconst int MOD = 1000000007;\n\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate <typename T> bool IN(T a, T b, T x) { return a<=x&&x<b; }\ntemplate<typename T> T ceil(T a, T b) { return a/b + !!(a%b); }\ntemplate<class S,class T>\nostream &operator <<(ostream& out,const pair<S,T>& a){\n  out<<'('<<a.first<<','<<a.second<<')';\n  return out;\n}\ntemplate<class T>\nostream &operator <<(ostream& out,const vector<T>& a){\n  out<<'[';\n  REP(i, a.size()) {out<<a[i];if(i!=a.size()-1)out<<',';}\n  out<<']';\n  return out;\n}\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\nvector<PII> g[2010];\nbool used[2010];\nint n, k, s, ans = -INF, st;\n\nvoid dfs(int x, int m, int cost) {\n  used[x] = true;\n  if(m == k) {\n    for(auto e: g[x]) {\n      if(e.first == st && m != 2) cost += e.second;\n    }\n    chmax(ans, cost);\n    return;\n  }\n  for(auto e: g[x]) {\n    if(used[e.first]) continue;\n    dfs(e.first, m+1, cost + e.second);\n  }\n}\n\nsigned main(void)\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  while(true) {\n    cin >> n >> k >> s;\n    if(!n) break;\n    VI x(n), y(n), z(n);\n    REP(i, n) cin >> x[i] >> y[i] >> z[i];\n\n    int dx[] = {0, s, 0, s, s, 0, s, 0},\n        dy[] = {0, 0, s, s, s, s, 0, 0},\n        dz[] = {0, 0, 0, 0, s, s, s, s};\n    ans = -INF;\n    REP(i, 2010) g[i].clear();\n    REP(i, n) FOR(j, i+1, n) {\n      // (i,j)が重複していたらその分の面積の重みの辺を張る\n      REP(k, 8) {\n        int nx = x[j] + dx[k], ny = y[j] + dy[k], nz = z[j] + dz[k];\n        if(x[i] <= nx && nx <= x[i]+s && y[i] <= ny && ny <= y[i]+s\n          && z[i] <= nz && nz <= z[i]+s) {\n          int nx1 = x[i] + dx[(k+4)%8], ny1 = y[i] + dy[(k+4)%8], nz1 = z[i] + dz[(k+4)%8];\n          int diffx = abs(nx - nx1), diffy = abs(ny - ny1), diffz = abs(nz - nz1);\n          int cost = 2*(diffx*diffy + diffy*diffz + diffz*diffx);\n          g[i].PB({j, cost});\n          g[j].PB({i, cost});\n          // cout << diffx << \",\" << diffy << \",\" << diffz << endl;\n          // cout << i << \" \" << j << \" \" << k << \" \" << cost << endl;\n          break;\n        }\n      }\n    }\n\n    REP(i, n) {\n      // iからk個取る\n      memset(used, 0, sizeof(used));\n      st = i;\n      dfs(i, 1, 0);\n    }\n\n    // cout << s*s*6*k << \" \" << ans << endl;\n    if(ans == -INF) cout << -1 << endl;\n    else cout << s*s*6*k - ans << endl;\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <cmath>\n#include <cstdlib>\n#include <map>\nusing namespace std;\n\nclass Point {\npublic:\n    int x, y, z;\n    Point(int x = 0, int y = 0, int z = 0) : x(x), y(y), z(z) {}\n};\n\nclass Cube {\npublic:\n    Point p;\n    int s;\n    int vx[4] = {0, 1, 1, 0}, vy[4] = {0, 0, 1, 1}, vz[2] = {0, 1};\n    Cube(Point p = Point(), int s = 0) : p(p), s(s) {}\n\n    bool isIn(const Cube &c) {\n        int nx, ny, nz;\n\n        for (int i = 0; i < 2; ++i) {\n            for (int j = 0; j < 4; ++j) {\n                nx = c.p.x + c.s * vx[j];\n                ny = c.p.y + c.s * vy[j];\n                nz = c.p.z + c.s * vz[i];\n\n                if (p.x <= nx && nx <= p.x + s &&\n                    p.y <= ny && ny <= p.y + s &&\n                    p.z <= nz && nz <= p.z + s) {\n                        return true;\n                    }\n            }\n        }\n\n        return false;\n    }\n\n    long long shareS(Cube &c) {\n        long long ret = 0;\n        Point a, b;\n        a = p; b = c.p;\n\n        if (a.x > b.x) swap(a.x, b.x);\n        if (a.y > b.y) swap(a.y, b.y);\n        if (a.z > b.z) swap(a.z, b.z);\n\n        ret += abs((a.x + s - b.x) * (a.z + s - b.z) * 2);\n        ret += abs((a.y + s - b.y) * (a.z + s - b.z) * 2);\n        ret += abs((a.x + s - b.x) * (a.y + s - b.y) * 2);\n        return ret;\n    }\n\n};\n\nint n, k, s, x, y, z;\nlong long ans;\nvector<Cube> c;\nvector<vector<int> > subg;\nvector<bool> used;\nvector<deque<int> > graph;\ndeque<int> que;\nmap<pair<int, int>, bool> mp, init;\n\n// not clever\ninline void makegraph(int v) {\n    for (int i = 0; i < n; ++i) {\n        if (!mp[make_pair(v, i)] && i != v && c[v].isIn(c[i])) {\n            subg[v].push_back(i);\n            subg[i].push_back(v);\n            mp[make_pair(v, i)] = true;\n            mp[make_pair(i, v)] = true;\n        }\n    }\n}\n\n// make path\nvoid dfs(int v) {\n    used[v] = true;\n    int size_ = subg[v].size();\n    bool flag = false;\n\n    for (int i = 0; i < size_; ++i) {\n        if (!used[subg[v][i]]) {\n            dfs(subg[v][i]);\n            if (!flag) que.push_front(v);\n            flag = true;\n        }\n    }\n\n    if (!flag) que.push_front(v);\n}\n\n// is graph[graphid] cycle ?\ninline bool isCycle(int graphid) {\n    int size_ = graph[graphid].size();\n\n    // if all vertex's degree are two, this graph is cycle.\n    for (int i = 0; i < size_; ++i) {\n        if (subg[graph[graphid][i]].size() != 2) return false;\n    }\n\n    return true;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    while (cin >> n >> k >> s, n | k | s) {\n        //cout << \"---- begin ----\" << endl;\n        c.resize(n);\n        subg.resize(n);\n        que.clear();\n        used.assign(n, false);\n        mp = init;\n        ans = int(1e9);\n\n        for (int i = 0; i < n; ++i) {\n            cin >> x >> y >> z;\n            c[i] = {Point(x, y, z), s};    \n        }\n\n        for (int i = 0; i < n; ++i) {\n            makegraph(i);\n        }\n\n        for (int i = 0; i < n; ++i) {\n            if (!used[i]) {\n                dfs(i);\n                graph.push_back(que);\n                que.clear();\n            }\n        }\n\n        /*\n        for (int i = 0; i < graph.size(); ++i) {\n            for (int j = 0; j < graph[i].size(); ++j) {\n                cout << graph[i][j] << \" \";\n            }\n            cout << endl;\n        }\n        */\n\n        int gsize = graph.size(), qsize, upper;\n        long long share;\n        bool isGraphCycle = false;\n\n        //cout << \"k = \" << k << endl;\n\n        for (int i = 0; i < gsize; ++i) {\n            qsize = graph[i].size();\n            isGraphCycle = isCycle(i);\n            if (isGraphCycle) {\n                upper = qsize + k - 1;\n            }\n            else upper = qsize;\n\n            if (qsize < k) continue;\n\n            for (int j = 0; j + k - 1 < upper; ++j) {\n                share = 0;\n                /*for (int l = 0; l < k - 1; ++l) {\n                    cout << graph[i][(j + l) % qsize] << \" \" << graph[i][(j + l + 1) % qsize] << endl;\n                }*/\n                //cout << graph[i][(j + k - 1) % qsize] << \" \" << graph[i][(j + k) % qsize] << endl;\n                //cout << endl;\n\n                for (int l = 0; l < k - 1; ++l) {\n                    //Cube a = c[graph[i][j + l]],\n                    //    b = c[graph[i][j + l + 1]];\n                    //cout << a.p.x << \" \" << a.p.y << \" \" << a.p.z << endl;\n                    //cout << b.p.x << \" \" << b.p.y << \" \" << b.p.z << endl;\n\n                    share += c[graph[i][(j + l) % qsize]].shareS(c[graph[i][(j + l + 1) % qsize]]);\n\n                    //cout << graph[i][(j + l) % qsize] << \" & \" << graph[i][(j + l + 1) % qsize] << endl;\n                    //cout << \"share is \" << tmp << endl;\n                }\n\n                if (isGraphCycle && qsize == k) {\n                    //cout << \"this is cycle\" << endl;\n                    share += c[graph[i][0]].shareS(c[graph[i][qsize - 1]]);\n                }\n\n                ans = min(ans, 6 * s * s * k - share);\n                //cout << \"all - share = \" << 6*s*s*k-share << endl;\n            }\n        }\n\n        if (n == 1) ans = 6 * s * s;\n        if (ans == int(1e9)) ans = -1;\n\n        cout << ans << endl;\n\n        //cout << \"---- end ----\" << endl;\n\n        c.clear();\n        graph.clear();\n        subg.clear();\n        used.clear();\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cassert>\n\nusing namespace std;\nusing ll = long long;\nconstexpr ll INF = 1LL << 50;\nll s;\n\nstruct Cube {\n    ll x;\n    ll y;\n    ll z;\n};\nll connected(const Cube& c1, const Cube& c2)\n{\n    const ll dx = abs(c1.x - c2.x);\n    const ll dy = abs(c1.y - c2.y);\n    const ll dz = abs(c1.z - c2.z);\n    if (dx < s and dy < s and dz < s) {\n        return ((s - dx) * (s - dy) + (s - dy) * (s - dz) + (s - dz) * (s - dx)) * 2;\n    }\n    return 0;\n}\n\nstruct Edge {\n    int from;\n    int to;\n    ll cost;\n};\nstruct Graph {\n    Graph(const int n)\n    {\n        edge.resize(n);\n    }\n    void addEdge(const int from, const int to, const ll cost)\n    {\n        edge[from].push_back(Edge{from, to, cost});\n        edge[to].push_back(Edge{to, from, cost});\n    }\n    vector<vector<Edge>> edge;\n};\n\nint getEdge(const Graph& g, const int s, vector<bool>& visited)\n{\n    visited[s] = true;\n    int child = 0;\n    for (const auto& e : g.edge[s]) {\n        if (not visited[e.to]) {\n            return getEdge(g, e.to, visited);\n        }\n    }\n    if (child == 0) {\n        return s;\n    }\n}\nstruct Chain {\n    bool ring = false;\n    vector<ll> edges;\n};\nostream& operator<<(ostream& os, const Chain& ch)\n{\n    os << \"Ring: \" << boolalpha << ch.ring << \"\\nEdge: {\";\n    for (int i = 0; i < ch.edges.size(); i++) {\n        if (i != 0) {\n            os << \",\";\n        }\n        os << ch.edges[i];\n    }\n    os << \"}\" << endl;\n}\nvoid dfs(const Graph& g, const int s, const int dep, vector<bool>& visited, Chain& chain)\n{\n    visited[s] = true;\n    for (const auto& e : g.edge[s]) {\n        if (e.to == dep and chain.edges.size() >= 2) {\n            if (not chain.ring) {\n                chain.edges.push_back(e.cost);\n                chain.ring = true;\n            }\n            return;\n        }\n        if (not visited[e.to]) {\n            chain.edges.push_back(e.cost);\n            dfs(g, e.to, dep, visited, chain);\n        }\n    }\n}\n\nint main()\n{\n    while (true) {\n        int n, k;\n        cin >> n >> k >> s;\n        if (n == 0 and k == 0 and s == 0) {\n            break;\n        }\n\n        const ll whole = 6 * s * s * k;\n        if (k == 1) {\n            cout << whole << endl;\n            continue;\n        }\n\n        vector<Cube> cube(n);\n        for (int i = 0; i < n; i++) {\n            cin >> cube[i].x >> cube[i].y >> cube[i].z;\n        }\n        Graph g(n);\n        int e = 0;\n        for (int i = 0; i < n - 1; i++) {\n            for (int j = i + 1; j < n; j++) {\n                const ll cost = connected(cube[i], cube[j]);\n                if (cost > 0) {\n                    e++;\n                    g.addEdge(i, j, cost);\n                }\n            }\n        }\n        assert(e <= n);\n        vector<bool> visited(n, false);\n        vector<Chain> chains;\n        for (int i = 0; i < n; i++) {\n            if (not visited[i]) {\n                vector<bool> visited2(n, false);\n                const int dep = getEdge(g, i, visited2);\n                Chain chain;\n                chain.ring = false;\n                dfs(g, dep, dep, visited, chain);\n                chains.push_back(chain);\n            }\n        }\n        ll mini = INF;\n        for (const auto chain : chains) {\n            const bool ring = chain.ring;\n            const vector<ll>& costs = chain.edges;\n            if (costs.size() < k) {\n                continue;\n            }\n            if (ring) {\n                ll sum = 0;\n                for (int i = 0; i < k - 1; i++) {\n                    sum += costs[i];\n                }\n                if (costs.size() == k) {\n                    sum += costs[k - 1];\n                    mini = min(mini, whole - sum);\n                } else {\n                    mini = min(mini, whole - sum);\n                    int head = 0;\n                    int tail = k - 1;\n                    for (int j = 0; j < costs.size(); j++, head++, tail++, tail = tail % costs.size()) {\n                        sum += (costs[tail] - costs[head]);\n                        mini = min(mini, whole - sum);\n                    }\n                }\n            } else {\n                ll sum = 0;\n                for (int i = 0; i < k - 1; i++) {\n                    sum += costs[i];\n                }\n                mini = min(mini, whole - sum);\n                int head = 0;\n                int tail = k - 1;\n                for (; tail < costs.size(); head++, tail++) {\n                    sum += (costs[tail] - costs[head]);\n                    mini = min(mini, whole - sum);\n                }\n            }\n        }\n        cout << ((mini == INF) ? -1 : mini) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cstring>\nusing namespace std;\nusing ll = long long;\n\nstruct Cube{\n    ll lx, rx;\n    ll ly, ry;\n    ll lz, rz;\n    ll S(){\n        ll dx = rx - lx;\n        ll dy = ry - ly;\n        ll dz = rz - lz;\n        return (dx * dy + dy * dz + dz * dx) * 2;\n    } \n};\n\nll f(Cube c1, Cube c2){\n    ll L[3][2] = {{c1.lx, c2.lx}, {c1.ly, c2.ly}, {c1.lz, c2.lz}};\n    ll R[3][2] = {{c1.rx, c2.rx}, {c1.ry, c2.ry}, {c1.rz, c2.rz}};\n    ll LX, LY, LZ, RX, RY, RZ;\n    ll sum = 0;\n    LX = max(c1.lx, c2.lx);\n    RX = min(c1.rx, c2.rx);\n    LY = max(c1.ly, c2.ly);\n    RY = min(c1.ry, c2.ry);\n    LZ = max(c1.lz, c2.lz);\n    RZ = min(c1.rz, c2.rz);\n    if(RX <= LX) return 0;\n    if(RY <= LY) return 0;\n    if(RZ <= LZ) return 0;\n    ll dx = RX - LX;\n    ll dy = RY - LY;\n    ll dz = RZ - LZ;\n    return (dx * dy + dy * dz + dz * dx) * 2;\n}\n\nint n, k, s;\nCube c[2000];\nint vis[2000];\n\nvector<int> G[2000];\n\nvector<vector<int>> C;// ????????????\nvector<vector<int>> S;// ?????¬???\n\n// ????????????????????????\nbool dfs(int v, int p, vector<int>& a){\n    vis[v] = 1;\n    a.push_back(v);\n    for(int c : G[v]){\n        if(c == p) continue;\n        if(vis[c]) continue;\n        return dfs(c, v, a);\n    }\n    // \n    return G[v].size() == 2;\n}\n\n// ??±?????¢???;\nll X[2000][2000];\n\nint main(){\n    while(cin >> n >> k >> s, n){\n        for(int i = 0; i < n; i++){\n            cin >> c[i].lx  >> c[i].ly >> c[i].lz;\n            c[i].rx = c[i].lx + s;\n            c[i].ry = c[i].ly + s;\n            c[i].rz = c[i].lz + s;\n            G[i].clear();\n        }\n        C.clear();\n        S.clear();\n\n        for(int i = 0; i < n; i++){\n            for(int j = 0; j < n; j++){\n                if(i == j) continue;\n                ll res = f(c[i], c[j]);\n                X[i][j] = res;\n                if(res) G[i].push_back(j);\n            }\n        }\n\n        memset(vis, 0, sizeof vis);\n        for(int i = 0; i < n; i++){\n            if(vis[i]) continue;\n            if(G[i].size() <= 1){\n                vector<int> a;\n                bool res = dfs(i, -1, a);\n                if(a.size() < k) continue;\n                S.push_back(a);\n            }   \n        }\n        for(int i = 0; i < n; i++){\n            if(vis[i]) continue;\n            vector<int> a;\n            bool res = dfs(i, -1, a);\n            if(a.size() < k) continue;\n            C.push_back(a);\n        }\n\n        ll ans = 1LL << 61;\n        for(auto a : C){\n            int sz = a.size();\n            for(int i = 0; i < sz; i++) a.push_back(a[i]);\n            ll sum = 0;\n            for(int i = 0; i < k; i++){\n                sum += c[a[i]].S();\n                if(i != k - 1 || k == sz) sum -= X[a[i]][a[i + 1]];\n            }\n            for(int i = 0; i < sz; i++){\n                ans = min(ans, sum);\n                sum -= c[a[i]].S();\n                sum += X[a[i]][a[i+1]];\n                sum += c[a[i+k]].S();\n                sum -= X[a[i+k-1]][a[i+k]];\n            }\n            if(k != sz){\n                ans = min(ans, sum);\n            }\n        }\n        for(auto a : S){\n            ll sum = 0;\n            for(int i = 0; i < k; i++){\n                sum += c[a[i]].S();\n                if(i != k - 1) sum -= X[a[i]][a[i + 1]];\n            }\n            for(int i = 0; i < a.size() - k; i++){\n                ans = min(ans, sum);\n                sum -= c[a[i]].S();\n                sum += X[a[i]][a[i+1]];\n                sum += c[a[i+k]].S();\n                sum -= X[a[i+k-1]][a[i+k]];\n            }\n            ans = min(ans, sum);\n        }\n        if(ans == 1LL << 61) cout << -1 << endl;\n        else cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define dbg(...) do{cerr<<__LINE__<<\": \";dbgprint(#__VA_ARGS__, __VA_ARGS__);}while(0);\n\nusing namespace std;\n\nnamespace std{template<class S,class T>struct hash<pair<S,T>>{size_t operator()(const pair<S,T>&p)const{return ((size_t)1e9+7)*hash<S>()(p.first)+hash<T>()(p.second);}};template<class T>struct hash<vector<T>>{size_t operator()(const vector<T> &v)const{size_t h=0;for(auto i : v)h=h*((size_t)1e9+7)+hash<T>()(i)+1;return h;}};}\ntemplate<class T>ostream& operator<<(ostream &os, const vector<T> &v){os<<\"[ \";rep(i,v.size())os<<v[i]<<(i==v.size()-1?\" ]\":\", \");return os;}template<class T>ostream& operator<<(ostream &os,const set<T> &v){os<<\"{ \"; for(const auto &i:v)os<<i<<\", \";return os<<\"}\";}\ntemplate<class T,class U>ostream& operator<<(ostream &os,const map<T,U> &v){os<<\"{\";for(const auto &i:v)os<<\" \"<<i.first<<\": \"<<i.second<<\",\";return os<<\"}\";}template<class T,class U>ostream& operator<<(ostream &os,const pair<T,U> &p){return os<<\"(\"<<p.first<<\", \"<<p.second<<\")\";}\nvoid dbgprint(const string &fmt){cerr<<endl;}template<class H,class... T>void dbgprint(const string &fmt,const H &h,const T&... r){cerr<<fmt.substr(0,fmt.find(\",\"))<<\"= \"<<h<<\" \";dbgprint(fmt.substr(fmt.find(\",\")+1),r...);}\ntypedef long long ll;typedef vector<int> vi;typedef pair<int,int> pi;const int inf = (int)1e9;const double INF = 1e12, EPS = 1e-9;\n\nint main(){\n\tcin.tie(0); cin.sync_with_stdio(0);\n\tint n, k, s;\n\twhile(cin >> n >> k >> s, n){\n\t\tvi x(n), y(n), z(n);\n\t\trep(i, n) cin >> x[i] >> y[i] >> z[i];\n\t\t\n\t\tauto intersect = [&](int i, int j){\n\t\t\tll dx = s - abs(x[i] - x[j]);\n\t\t\tll dy = s - abs(y[i] - y[j]);\n\t\t\tll dz = s - abs(z[i] - z[j]);\n\t\t\tif(dx <= 0 || dy <= 0 || dz <= 0) return 0ll;\n\t\t\treturn (dx * dy + dy * dz + dz * dx) * 2;\n\t\t};\n\t\t\n\t\tvector<vi> e(n);\n\t\trep(i, n) rep(j, i) if(intersect(i, j)){\n\t\t\te[i].pb(j);\n\t\t\te[j].pb(i);\n\t\t\t//dbg(i, j);\n\t\t}\n\t\t\n\t\tfunction<bool(int,int,vector<bool>&,vi&)> rec = [&](int c, int p, vector<bool> &v, vi &idx){\n\t\t\tv[c] = 1;\n\t\t\tidx.pb(c);\n\t\t\tfor(int i : e[c]) if(i != p){\n\t\t\t\tif(v[i]) return true;\n\t\t\t\treturn (bool)rec(i, c, v, idx); \n\t\t\t}\n\t\t\treturn false;\n\t\t};\n\t\t\n\t\tll ans = 1e18;\n\t\tvector<bool> v(n);\n\t\trep(ii, n) if(!v[ii]){\n\t\t\tvi idx;\n\t\t\tbool loop = rec(ii, ii, v, idx);\n\t\t\tif(idx.size() < k) continue;\n\t\t\t\n\t\t\tif(loop && idx.size() == k){\n\t\t\t\tll sum = 6ll * k * s * s;\n\t\t\t\trep(i, (int)idx.size()){\n\t\t\t\t\tll c = intersect(idx[i], idx[(i + 1) % idx.size()]);\n\t\t\t\t\tsum -= c;\n\t\t\t\t}\n\t\t\t\tans = min(ans, sum);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tvector<ll> costs;\n\t\t\t\tif(loop){\n\t\t\t\t\trep(i, (int)idx.size())\n\t\t\t\t\t\tcosts.pb(intersect(idx[i], idx[(i + 1) % idx.size()]));\n\t\t\t\t\tint it = idx.size();\n\t\t\t\t\trep(i, it) idx.pb(idx[i]);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tint hasi = 0;\n\t\t\t\t\trep(i, idx.size()) if(e[idx[i]].size() == 1) hasi = i;\n\t\t\t\t\trotate(idx.begin(), idx.begin() + hasi, idx.end());\n\t\t\t\t\trep(i, idx.size() - 1)\n\t\t\t\t\t\tcosts.pb(intersect(idx[i], idx[i + 1]));\n\t\t\t\t}\n\t\t\t\t//dbg(k, costs);\n\t\t\t\t\n\t\t\t\tll sum = 6ll * k * s * s;\n\t\t\t\tif(k == 1){\n\t\t\t\t\tans = min(ans, sum);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\trep(i, k-2) sum -= costs[i];\n\t\t\t\trep(i, (int)costs.size() - (k-1) + 1){\n\t\t\t\t\tsum -= costs[i + k-2];\n\t\t\t\t\tans = min(ans, sum);\n\t\t\t\t\tsum += costs[i];\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tif(ans >= 1e18) ans = -1;\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing P = pair<int, ll>;\n\nint main()\n{\n\tll n, k, s;\n\twhile (cin >> n >> k >> s, n | k | s) {\n\t\tvector<ll> x(n), y(n), z(n);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcin >> x[i] >> y[i] >> z[i];\n\t\t}\n\t\tif (k == 1) {\n\t\t\tcout << s * s * 6 << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tvector<vector<P>> G(n);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tif (i != j) {\n\t\t\t\t\tll dx = s - abs(x[i] - x[j]), dy = s - abs(y[i] - y[j]), dz = s - abs(z[i] - z[j]);\n\t\t\t\t\tif (dx > 0 && dy > 0 && dz > 0) {\n\t\t\t\t\t\tG[i].push_back(P(j, (dx * dy + dy * dz + dz * dx) * 2));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tll res = s * s * 6 * k, d = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tvector<int> v;\n\t\t\tvector<ll> used(n);\n\t\t\tll tmp = 0;\n\t\t\tbool flag = true;\n\t\t\tused[i] = -1;\n\t\t\tif (G[i].empty()) continue;\n\t\t\tfor (auto p : G[i]) {\n\t\t\t\tused[p.first] += p.second;\n\t\t\t}\n\t\t\tv.push_back(G[i][0].first);\n\t\t\tfor (int j = 0; j < k - 1; j++) {\n\t\t\t\twhile (!v.empty() && used[v.back()] < 0) {\n\t\t\t\t\tv.pop_back();\n\t\t\t\t}\n\t\t\t\tif (v.empty()) {\n\t\t\t\t\tflag = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tauto ne = v.back(); v.pop_back();\n\t\t\t\ttmp += used[ne];\n\t\t\t\tused[ne] = -1;\n\t\t\t\tfor (auto p : G[ne]) {\n\t\t\t\t\tif (used[p.first] >= 0) {\n\t\t\t\t\t\tused[p.first] += p.second;\n\t\t\t\t\t\tv.push_back(p.first);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (flag) {\n\t\t\t\td = max(d, tmp);\n\t\t\t}\n\t\t}\n\t\tcout << (d ? res - d : -1) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include<bits/stdc++.h>\n#define F first\n#define S second\nusing namespace std;\ntypedef pair<int,int> P;\nint n,m,r,s[2000][3],ans,ch[2000],t[3],L,A;\nvector<P> v[2000];\nvoid dfs(int a,int cnt,int tot){\n    if(cnt==m){\n        if(m!=2){\n        \tfor(P y:v[a]){\n            \tif(y.F==A)tot+=y.S;\n        \t}\n    }\n        ans=max(ans,tot);\n        return ;\n    }\n    for(P x:v[a]){\n        if(ch[x.F]==0){\n            ch[x.F]=1;\n            dfs(x.F,cnt+1,tot+x.S);\n            ch[x.F]=0;\n        }\n    }\n    return ;\n}\nint main(void){\n    while(1){\n    cin>>n>>m>>r;\n    if(n==0&&m==0&&r==0)return 0;\n    for(int i=0;i<n;i++)v[i]={};\n    for(int i=0;i<n;i++){\n        for(int j=0;j<3;j++){\n            cin>>s[i][j];\n        }\n    }\n    for(int i=0;i<n;i++){\n        for(int j=i+1;j<n;j++){\n            for(int k=0;k<3;k++){\n                t[k]=r-abs(s[i][k]-s[j][k]);\n            }\n            if(t[0]<0||t[1]<0||t[2]<0)continue;\n            L=t[0]*t[1]*2+t[1]*t[2]*2+t[2]*t[0]*2;\n            v[i].push_back({j,L});\n            v[j].push_back({i,L});\n        }\n    }\n    ans=-1;\n    for(int i=0;i<n;i++){\n        A=i;\n        ch[i]=1;\n        dfs(i,1,0);\n        ch[i]=0;\n    }\n    if(ans==-1)cout<<-1<<endl;\n    else cout<<r*r*6*m-ans<<endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<deque>\n#include<algorithm>\nusing namespace std;\nint N,K,S;\nint X[3][2000];\nstruct UF{\n\tint N;\n\tvector<int>p,sz;\n\tUF(int n):N(n),p(n),sz(n,1){\n\t\tfor(int i=0;i<N;i++)p[i]=i;\n\t}\n\tint find(int u)\n\t{\n\t\tif(p[u]==u)return u;\n\t\telse return p[u]=find(p[u]);\n\t}\n\tbool unite(int u,int v)\n\t{\n\t\tu=find(u),v=find(v);\n\t\tif(u==v)return false;\n\t\tif(sz[u]<sz[v])\n\t\t{\n\t\t\tp[u]=v;\n\t\t\tsz[v]+=sz[u];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tp[v]=u;\n\t\t\tsz[u]+=sz[v];\n\t\t}\n\t\treturn true;\n\t}\n};\nvector<long>A;\nbool dfs(int u,int p,int out,vector<vector<pair<int,long> > >&G)\n{\n\tif(u==out)\n\t{\n\t\treturn true;\n\t}\n\tbool ret=false;\n\tfor(pair<int,long>&q:G[u])\n\t{\n\t\tif(q.first!=p)\n\t\t{\n\t\t\tA.push_back(q.second);\n\t\t\tret|=dfs(q.first,u,out,G);\n\t\t}\n\t}\n\treturn ret;\n}\nmain()\n{\n\twhile(cin>>N>>K>>S,N)\n\t{\n\t\tfor(int i=0;i<N;i++)\n\t\t{\n\t\t\tfor(int j=0;j<3;j++)cin>>X[j][i];\n\t\t}\n\t\tvector<pair<pair<int,int>,long> >E;\n\t\tUF uf(N);\n\t\tvector<vector<pair<int,long> > >G(N);\n\t\tfor(int i=0;i<N;i++)for(int j=i+1;j<N;j++)\n\t\t{\n\t\t\tint d[3];\n\t\t\tbool flag=true;\n\t\t\tfor(int k=0;k<3;k++)\n\t\t\t{\n\t\t\t\td[k]=S-abs(X[k][i]-X[k][j]);\n\t\t\t\tif(d[k]<=0)flag=false;\n\t\t\t}\n\t\t\tif(flag)\n\t\t\t{\n\t\t\t\tlong t=d[0]*d[1]+d[1]*d[2]+d[2]*d[0];\n\t\t\t\tt*=2;\n\t\t\t\tE.push_back(make_pair(make_pair(i,j),t));\n\t\t\t\tuf.unite(i,j);\n\t\t\t\tG[i].push_back(make_pair(j,t));\n\t\t\t\tG[j].push_back(make_pair(i,t));\n\t\t\t}\n\t\t}\n\t\tlong ans=-1;\n\t\tvector<bool>vis(N,false);\n\t\tfor(int i=0;i<N;i++)\n\t\t{\n\t\t\tint u=uf.find(i);\n\t\t\tif(uf.sz[u]<K)vis[u]=true;\n\t\t\tif(vis[u])continue;\n\t\t\tA.clear();\n\t\t\tvis[u]=true;\n\t\t\tbool flag=false;\n\t\t\tfor(pair<int,long>&q:G[u])\n\t\t\t{\n\t\t\t\tA.push_back(q.second);\n\t\t\t\tif(dfs(q.first,u,u,G))\n\t\t\t\t{\n\t\t\t\t\tflag=true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\treverse(A.begin(),A.end());\n\t\t\t}\n\t\t\tif(flag)\n\t\t\t{\n\t\t\t\tint n=A.size();\n\t\t\t\tfor(int i=0;i<n;i++)A.push_back(A[i]);\n\t\t\t}\n\t\t\tint get=flag&&uf.sz[u]==K?K:K-1;\n\t\t\tvector<long>sum(A.size()+1,0);\n\t\t\tfor(int i=0;i<A.size();i++)sum[i+1]=sum[i]+A[i];\n\t\t\tfor(int i=get;i<=A.size();i++)ans=max(ans,sum[i]-sum[i-get]);\n\t\t}\n\t\tif(ans<0)cout<<-1<<endl;\n\t\telse cout<<6LL*S*S*K-ans<<endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n#define WRAP(y,x,h,w) (0<=y && y<h && 0<=x && x<w)\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef string str;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<double> vd;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef vector<vd> vvd;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1,0,1,0 }; const int dy[] = { 0,1,0,-1 };\nint N, K, S;\nvvi box;\nvector<vector<pii>> G(N);\nll ans;\nbool isconnect(int b1,int b2) {\n\treturn (abs(box[b1][0]- box[b2][0])<S)&& (abs(box[b1][1] - box[b2][1])<S) && (abs(box[b1][2] - box[b2][2])<S);\n}\n\nint calc(int b1, int b2) {\n\tint sub[3];\n\tREP(i,3)\n\t sub[i]=(S -abs(box[b1][i] - box[b2][i]));\n\treturn 2*(sub[0]*sub[1]+sub[1]*sub[2]+sub[2]*sub[0]);\n}\nvoid dfs(int now,int root,int pre,int depth,ll point) {\n\tif (depth == K-1) {\n\t\tif (!G[now].empty()) {\n\t\t\tREP(i, G[now].size()) {\n\t\t\t\tif (G[now][i].first == root) {\n\t\t\t\t\tpoint += G[now][i].second;\n\t\t\t}\n\t\t\t}\n\t\t}\n\t\tans=min(ans, 1LL * S*S * 6 * K - point);\n\t\treturn;\n\t}\n\tif (!G[now].empty()) {\n\t\tREP(i, G[now].size()) {\n\t\t\tif (G[now][i].first != pre&&G[now][i].first != root) {\n\t\t\t\tdfs(G[now][i].first, root, now, depth + 1, point + G[now][i].second);\n\t\t\t}\n\t\t}\n\t}\n}\nint main() {\n\twhile (cin>>N>>K>>S,N) {\n\t\tbox.clear();\n\t\tbox.resize(N, vi(3));\n\t\tREP(i,N) {\n\t\t\tREP(j, 3)\n\t\t\t\tcin >> box[i][j];\n\t\t}\n\t\tG.clear();\n\t\tG.resize(N);\n\t\tREP(i, N) {\n\t\t\tREP(j, N) {\n\t\t\t\tif(i!=j)\n\t\t\t\tif (isconnect(i, j)) {\n\t\t\t\t\tG[i].push_back({ j,calc(i,j) });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tans = 1e9;\n\t\tif (K == 1)\n\t\t\tans = S*S * 6;\n\t\tif(K==2)\n\t\t\tREP(i,N)\n\t\t\tif (!G[i].empty()) {\n\t\t\t\tREP(j, G[i].size())\n\t\t\t\t\tans = min(ans,1LL*S*S * 6*2 - G[i][j].second);\n\t\t\t}\n\t\tif(K>=3)\n\t\tREP(i, N) {\n\t\t\tdfs(i,i, -1, 0,0);\n\t\t}\n\t\tif (ans == 1e9) {\n\t\t\tcout << -1 << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << ans << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<P,int> PP;\n\nint N, K, S;\nvector<PP> V;\n\nbool check(PP a, PP b) {\n\n    if (!(a.first.first > b.first.first + S || a.first.first + S < b.first.first)) {\n        if (!(a.first.second > b.first.second + S || a.first.second + S < b.first.second)) {\n            if (a.second >= b.second + S || a.second + S <= b.second) return false;\n            else return true;\n        }\n    }\n\n    return false;\n}\n\nint diff(int a, int b) {\n    int sub_x = S - abs(V[a].first.first - V[b].first.first);\n    int sub_y = S - abs(V[a].first.second - V[b].first.second);\n    int sub_z = S - abs(V[a].second - V[b].second);\n\n    return (sub_x * sub_y + sub_z * sub_y + sub_z * sub_x) * 2;\n}\n\nint dfs(vector<vector<bool>>& inter, vector<bool>& used, int now, int k, int men, int pre) {\n    if (k == K- 1) {\n        for (int i = 0; i < N; i++) {\n            if (inter[now][i] && used[i] && pre != i) {\n                return diff(i, now);\n            }\n        }\n        return 0;\n    }\n\n    used[now] = true;\n\n\n    int res = -(1<<28);\n    for (int i = 0; i < N; i++) {\n        if (used[i] == false && inter[now][i])\n            res = max(res ,dfs(inter, used, i, k + 1, men, now) + diff(now, i));\n    }\n\n    used[now] = false;\n\n    return res;\n}\n\nvoid solve() {\n    V.resize(N);\n    for (int i = 0; i < N; i++) cin >> V[i].first.first >> V[i].first.second >> V[i].second;\n    vector<vector<bool>> inter(N, vector<bool>(N));\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            inter[i][j] = check(V[i], V[j]);\n        }\n    }\n\n    int ans = 1 << 28;\n    for (int i = 0; i < N; i++) {\n        vector<bool> used(N);\n        ans = min(ans, S * S * 6 * K - dfs(inter, used, i, 0, 0, -1));\n    }\n    cout << ans << endl;\n}\n\nint main() {\n    while (cin >> N >> K >> S, N || K || S) {\n        solve();\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <math.h>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <bitset>\n#include <algorithm>\nusing namespace std;\n\nstruct xyz_t {\n    int x;\n    int y;\n    int z;\n    double length;       //一乗\n};\n\nstruct first_t {\n    int sec;\n    long long w;\n};\n\nbool asc(const xyz_t& left,const xyz_t& right);\nint next(int p,int q);\nint root(int p);\nvoid unite(int p,int q);\nint same(int p,int q);\nvoid pr(vector<vector<int> > pri);\n\nvector<xyz_t> a;\nvector<int> tree;\nvector<vector<int> > tree_f;\nvector<vector<long long> > kaburi;\nvector<vector<int> > tree_r;\nvector<int> num;\nvector<int> flg;\nlong long ans;\nint n,k,s;\ndouble LE;\nlong long sum;\nint rr;\n\nint main(){\n  scanf (\"%d %d %d\",&n,&k,&s);\n  while(n){\n    ans=0;\n    LE=sqrt(s*s*3.0);\n    xyz_t aaa={0,0,0,0};\n    a.assign(n,aaa);\n    tree.assign(n,-1);\n    tree_f.assign(n,vector<int>(1,0));\n    kaburi.assign(n,vector<long long>(n,0));\n    tree_r.assign(n,vector<int>(0,0));\n    num.assign(n,1);\n    flg.assign(n,0);\n    for(int t=0;t<n;t++){\n      scanf (\"%d %d %d\",&a[t].x,&a[t].y,&a[t].z);\n      a[t].length=sqrt(a[t].x*a[t].x*1.0+a[t].y*a[t].y*1.0+a[t].z*a[t].z*1.0);\n    }\n    sort(a.begin(),a.end(),asc);\n    for(int i=0;i<n;i++){\n      tree[i]=i;\n    }\n\n    switch(k){\n      case 1:\n        printf(\"%d\\n\",s*s*6);\n        break;\n      case 3:\n        for(int t=0;t<n-1;++t){\n          for(int s=t+1;(a[s].length<a[t].length+LE&&s<n);++s){\n            int xx=next(a[t].x,a[s].x);\n            int yy=next(a[t].y,a[s].y);\n            int zz=next(a[t].z,a[s].z);\n            if(xx&&yy&&zz){\n              if(same(t,s)==0){\n                if(num[s]!=1){\n                  num[t]+=num[tree[s]];\n                  num[tree[s]]=0;\n                  unite(s,t);\n                }\n                else{\n                  num[s]+=num[tree[t]];\n                  num[tree[t]]=0;\n                  unite(t,s);\n                }\n                kaburi[s][t]=xx*yy+yy*zz+zz*xx;\n                kaburi[t][s]=kaburi[s][t];\n                tree_r[t].push_back(s);\n                tree_r[s].push_back(t);\n                //printf(\"%d %d %d\\n\",kaburi[q].back());\n                //printf(\"%d %d %d\\n\",xx,yy,zz);\n              }\n              else{\n                kaburi[s][t]=xx*yy+yy*zz+zz*xx;\n                kaburi[t][s]=kaburi[s][t];\n                tree_r[t].push_back(s);\n                tree_r[s].push_back(t);\n                flg[tree[t]]=1;\n              }\n            }\n          }\n        }\n        //pr(kaburi);\n        for(int t=0;t<n;++t){\n          sum=0;\n          if(num[t]>=k){\n            if(flg[t]==0){\n              int u=t;\n              int uu=t;\n              tree_f[t][0]=t;\n              for(int r=0;r<k-1;++r){\n                rr=0;\n                if(tree_r[u][rr]==uu){\n                  ++rr;\n                }\n                sum+=kaburi[u][tree_r[u][rr]];\n                tree_f[t].push_back(tree_r[u][rr]);\n                uu=u;\n                u=tree_r[u][rr];\n              }\n              for(int r=k-1;r<num[t]-1;++r){\n                rr=0;\n                if(tree_r[u][rr]==uu){\n                  ++rr;\n                }\n                tree_f[t].push_back(tree_r[u][rr]);\n                uu=u;\n                u=tree_r[u][rr];\n              }\n              if(ans<sum){\n                ans=sum;\n              }\n              for(int r=0;r+k<num[t];++r){\n                sum=sum-kaburi[tree_f[t][r]][tree_f[t][r+1]]+kaburi[tree_f[t][r+k-1]][tree_f[t][r+k]];\n                if(ans<sum){\n                  ans=sum;\n                }\n              }\n            }\n            else{\n              if(num[t]!=k){\n                int u=t;\n                int uu=t;\n                tree_f[t][0]=t;\n                for(int r=0;r<k-1;++r){\n                  rr=0;\n                  if(tree_r[u][rr]==uu){\n                    ++rr;\n                  }\n                  sum+=kaburi[u][tree_r[u][rr]];\n                  tree_f[t].push_back(tree_r[u][rr]);\n                  uu=u;\n                  u=tree_r[u][rr];\n                }\n                for(int r=k-1;r<num[t]*2;++r){\n                  rr=0;\n                  if(tree_r[u][rr]==uu){\n                    ++rr;\n                  }\n                  tree_f[t].push_back(tree_r[u][rr]);\n                  uu=u;\n                  u=tree_r[u][rr];\n                }\n                if(ans<sum){\n                  ans=sum;\n                }\n                for(int r=0;r<num[t];++r){\n                  sum=sum-kaburi[tree_f[t][r]][tree_f[t][r+1]]+kaburi[tree_f[t][r+k-1]][tree_f[t][r+k]];\n                  if(ans<sum){\n                    ans=sum;\n                  }\n                  //printf(\"%lld\\n\",sum);\n                }\n                //pr(tree_f);\n              }\n              else{\n                if(num[t]!=3){\n                  int u=t;\n                  int uu=t;\n                  tree_f[t][0]=t;\n                  for(int r=0;r<k;++r){\n                    rr=0;\n                    if(tree_r[u][rr]==uu){\n                      ++rr;\n                    }\n                    sum+=kaburi[u][tree_r[u][rr]];\n                    uu=u;\n                    u=tree_r[u][rr];\n                  }\n                  if(ans<sum){\n                    ans=sum;\n                  }\n                }\n                else{\n                  int u=t;\n                  int uu=t;\n                  tree_f[t][0]=t;\n                  for(int r=0;r<k;++r){\n                    rr=0;\n                    if(tree_r[u][rr]==uu){\n                      ++rr;\n                    }\n                    sum+=kaburi[u][tree_r[u][rr]];\n                    tree_f[t].push_back(tree_r[u][rr]);\n                    uu=u;\n                    u=tree_r[u][rr];\n                  }\n                  int xxx=s+min({a[tree_f[t][0]].x,a[tree_f[t][1]].x,a[tree_f[t][2]].x})-max({a[tree_f[t][0]].x,a[tree_f[t][1]].x,a[tree_f[t][2]].x});\n                  int yyy=s+min({a[tree_f[t][0]].y,a[tree_f[t][1]].y,a[tree_f[t][2]].y})-max({a[tree_f[t][0]].y,a[tree_f[t][1]].y,a[tree_f[t][2]].y});\n                  int zzz=s+min({a[tree_f[t][0]].z,a[tree_f[t][1]].z,a[tree_f[t][2]].z})-max({a[tree_f[t][0]].z,a[tree_f[t][1]].z,a[tree_f[t][2]].z});\n                  sum=sum-(xxx*yyy+yyy*zzz+zzz*xxx);\n                  if(ans<sum){\n                    ans=sum;\n                  }\n                }\n              }\n            }\n          }\n        }\n        if(ans==0){\n          printf(\"-1\\n\");\n        }\n        else{\n          printf(\"%lld\\n\",s*s*6*k-ans*2);\n        }\n        break;\n      default:\n        for(int t=0;t<n-1;++t){\n          for(int s=t+1;(a[s].length<a[t].length+LE&&s<n);++s){\n            int xx=next(a[t].x,a[s].x);\n            int yy=next(a[t].y,a[s].y);\n            int zz=next(a[t].z,a[s].z);\n            if(xx&&yy&&zz){\n              if(same(t,s)==0){\n                if(num[t]==1){\n                  num[t]+=num[tree[s]];\n                  num[tree[s]]=0;\n                  unite(s,t);\n                }\n                else if(num[s]==1){\n                  num[s]+=num[tree[t]];\n                  num[tree[t]]=0;\n                  unite(t,s);\n                }\n                else {\n                  num[tree[t]]+=num[tree[s]];\n                  num[tree[s]]=0;\n                  unite(s,t);\n                }\n                kaburi[s][t]=xx*yy+yy*zz+zz*xx;\n                kaburi[t][s]=kaburi[s][t];\n                tree_r[t].push_back(s);\n                tree_r[s].push_back(t);\n                //printf(\"%d %d %d\\n\",kaburi[q].back());\n                //printf(\"%d %d %d\\n\",xx,yy,zz);\n              }\n              else{\n                kaburi[s][t]=xx*yy+yy*zz+zz*xx;\n                kaburi[t][s]=kaburi[s][t];\n                flg[tree[t]]=1;\n                tree_r[t].push_back(s);\n                tree_r[s].push_back(t);\n                /*if(num[s]==0){\n                  flg[t]=1;\n                }\n                else{\n                  flg[s]=1;\n                }*/\n              }\n            }\n          }\n        }\n        /*for(int t=0;t<n;++t){\n          printf(\"%d \",num[t]);\n        }\n        printf(\"%d\\n\",num[n-1]);*/\n        //pr(kaburi);\n        for(int t=0;t<n;++t){\n          sum=0;\n          if(num[t]>=k){\n            if(flg[t]==0){\n              int u=t;\n              int uu=t;\n              tree_f[t][0]=t;\n              for(int r=0;r<k-1;++r){//\n                rr=0;\n                if(tree_r[u][rr]==uu){\n                  ++rr;\n                }\n                sum+=kaburi[u][tree_r[u][rr]];\n                tree_f[t].push_back(tree_r[u][rr]);\n                uu=u;\n                u=tree_r[u][rr];\n              }\n              for(int r=k-1;r<num[t]-1;++r){\n              rr=0;\n              if(tree_r[u][rr]==uu){\n                ++rr;\n              }\n              tree_f[t].push_back(tree_r[u][rr]);\n                uu=u;\n                u=tree_r[u][rr];\n              }\n              if(ans<sum){\n                ans=sum;\n              }\n              for(int r=0;r+k<num[t];++r){\n                sum=sum-kaburi[tree_f[t][r]][tree_f[t][r+1]]+kaburi[tree_f[t][r+k-1]][tree_f[t][r+k]];\n\n                if(ans<sum){\n                  ans=sum;\n                }\n              }\n            }\n            else{\n              if(num[t]!=k||k==2){\n                int u=t;\n                int uu=t;\n                tree_f[t][0]=t;\n                for(int r=0;r<k-1;++r){\n                  rr=0;\n                  if(tree_r[u][rr]==uu){\n                    ++rr;\n                  }\n                  sum+=kaburi[u][tree_r[u][rr]];\n                  tree_f[t].push_back(tree_r[u][rr]);\n                  uu=u;\n                  u=tree_r[u][rr];\n                }\n                for(int r=k-1;r<num[t]*2;++r){\n                  rr=0;\n                  if(tree_r[u][rr]==uu){\n                    ++rr;\n                  }\n                  tree_f[t].push_back(tree_r[u][rr]);\n                  uu=u;\n                  u=tree_r[u][rr];\n                }\n                if(ans<sum){\n                  ans=sum;\n                }\n                for(int r=0;r<num[t];++r){\n                  sum=sum-kaburi[tree_f[t][r]][tree_f[t][r+1]]+kaburi[tree_f[t][r+k-1]][tree_f[t][r+k]];\n                  if(ans<sum){\n                    ans=sum;\n                  }\n                  //printf(\"%lld\\n\",sum);\n                }\n                //pr(tree_f);\n              }\n              else{\n                int u=t;\n                int uu=t;\n                tree_f[t][0]=t;\n                for(int r=0;r<k;++r){\n                  rr=0;\n                  if(tree_r[u][rr]==uu){\n                    ++rr;\n                  }\n                  sum+=kaburi[u][tree_r[u][rr]];\n                  uu=u;\n                  u=tree_r[u][rr];\n                  //printf(\"%lld\\n\",sum);\n                }\n                if(ans<sum){\n                  ans=sum;\n                }\n              }\n            }\n          }\n        }\n        if(ans==0){\n          printf(\"-1\\n\");\n        }\n        else{\n          printf(\"%lld\\n\",s*s*6*k-ans*2);\n        }\n    }\n    scanf (\"%d %d %d\",&n,&k,&s);\n  }\n}\n/*\n環状 k=3の時 それ以外の時\n\n\n*/\n\n\nbool asc(const xyz_t& left,const xyz_t& right){\n  return left.length<right.length;\n}\n\nint next(int p,int q){\n  if(-s<=(p-q)&&(p-q)<=s){\n    if((p-q)>=0){\n      return s-(p-q);\n    }\n    else{\n      return s-(q-p);\n    }\n  }\n  else{\n    return 0;\n  }\n}\n\nint root(int p){\n  if (tree[p] == p){// 根\n    return p;\n  }\n  else {\n    return tree[p] = root(tree[p]); // 経路圧縮\n  }\n}\n\nvoid unite(int p, int q){\n  p = root(p);\n  q = root(q);\n  if (p == q){}\n  else{\n    tree[p] = q;     //pの親をqの親にする\n  }\n}\n\nint same(int p, int q){\n  return root(p) == root(q);\n}\n\n\n\nvoid pr(vector<vector<int> > pri){\n  for(int t=0;t<int(pri.size());++t){\n    for(int s=0;s<int(pri[t].size())-1;++s){\n      printf(\"%d \",pri[t][s]);\n    }\n    printf(\"%d\\n\",pri[t][pri[t].size()-1]);\n  }\n  printf(\"\\n\");\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <array>\n#include <cassert>\n#include <climits>\n#include <complex>\n#include <cstdio>\n#include <cstring>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <iterator>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <string>\n#include <tuple>\n#include <vector>\n\nusing namespace std;\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define ALL(x) (x).begin(), (x).end()\n\nint subcube(int len, int x0, int y0, int z0, int x1, int y1, int z1) {\n    int dx = x0 - x1, dy = y0 - y1, dz = z0 - z1;\n    int sx = max(min(len + dx, len - dx), 0);\n    int sy = max(min(len + dy, len - dy), 0);\n    int sz = max(min(len + dz, len - dz), 0);\n    return (sx * sy * sz == 0) ? 0 : 2 * (sx * sy + sy * sz + sz * sx);\n}\n\nint main(){\n    int n, k, s; \n    while(cin >> n >> k >> s, n != 0){\n    vector<int> xs(n), ys(n), zs(n);\n    REP(i, n) {\n        cin >> xs[i] >> ys[i] >> zs[i];\n    }\n\n    if (k == 1) cout << s * s * 6 * k << endl;\n    vector<vector<int>> subc(n, vector<int>(n));\n    REP(a, n) {\n        REP(b, n) {\n            if (a == b) continue;\n            subc[a][b] = subcube(s, xs[a], ys[a], zs[a], xs[b], ys[b], zs[b]);\n            //cout << subc[a][b] << \"\\t\";\n        }\n        //cout << endl;\n    }\n\n    vector<vector<int>> segs;\n    vector<int> used(n, false);\n\n    REP(a, n){\n        if (used[a]) continue;\n        vector<int> seg;\n        int p = a; bool ok = true, loop = false;\n        seg.push_back(p);\n        used[a] = true;\n        while(ok) {\n            ok = false;\n            REP(b, n) {\n                if (subc[p][b] > 0) {\n                    if (a == p) loop = true;\n                    if (used[b]) continue;\n                    p = b;\n                    seg.push_back(p);\n                    used[b] = true;\n                    ok = true;\n                    break;\n                }\n            }\n        }\n        reverse(ALL(seg));\n        if (!loop) {\n            p = a;\n            while(ok) {\n                ok = false;\n                REP(b, n) {\n                    if (subc[p][b] > 0) {\n                        if (used[b]) continue;\n                        p = b;\n                        seg.push_back(p);\n                        used[b] = true;\n                        ok = true;\n                        break;\n                    }\n                }\n            }\n        }\n        segs.push_back(seg);\n    }\n\n    int res = -1;\n    REP(i, segs.size()) {\n        const vector<int> seg(segs[i]);\n        /*\n        cout << \"# \"; REP(a, seg.size()) {\n            cout << seg[a] << \" \";\n        } cout << endl;\n        */\n        const int l = seg.size();\n        if (l < k) { continue; }\n        if (l == k) {\n            int sum = 0;\n            if (l == 2) {\n                res = max(res, subc[seg[0]][seg[1]]);\n                continue;\n            }\n            REP(a, l) {\n                //cout << \"+=\" << seg[a] << \" \" << seg[(a+1)%l] << endl;\n                //cout << \"   : \" << subc[seg[a]][seg[(a+1)%l]] << endl;\n                sum += subc[seg[a]][seg[(a+1)%l]];\n            }\n            res = max(res, sum);\n            continue;\n        }\n        int sum = 0;\n        REP(a, k - 1) {\n            sum += subc[seg[a]][seg[a+1]];\n        }\n        REP(a, l) {\n            res = max(res, sum);\n            int ad = subc[seg[(a + k - 1) % l]][seg[(a + k) % l]];\n            if (ad == 0) break;\n            sum += ad;\n            sum -= subc[seg[(a % l)]][seg[(a + 1) % l]];\n        }\n    }\n\n    // cout << \"$\" << subc[0][1] << endl;\n    // cout << res << endl;\n    if (res < 0) cout << res << endl;\n    else cout << s * s * 6 * k - res << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#define int long long\nusing namespace std;\n\nint n, k, s;\nint x[2000], y[2000], z[2000];\nvector<int> et[2000];\nvector<int> ec[2000];\n\nint f(int sid) {\n\tint ret = 0;\n\tbool used[2000] = {false};\n\tint id = sid;\n\t\n\tfor (int i = 0; i < k - 1; i++) {\n\t\tused[id] = true;\n\t\t\n\t\tint next = -1;\n\t\tfor (int j = 0; j < et[id].size(); j++) {\n\t\t\tif (!used[et[id][j]]) { next = j; break; }\n\t\t}\n\t\tif (next == -1) { return -1; }\n\t\tret += ec[id][next];\n\t\tid = et[id][next];\n\t}\n\t\n\tfor (int j = 0; j < et[id].size(); j++) {\n\t\tif (et[id][j] == sid) {\n\t\t\tret += ec[id][j];\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\treturn ret;\n}\n\nsigned main() {\n\tint i, j;\n\t\n\twhile (cin >> n >> k >> s) {\n\t\tif (!n) break;\n\t\tfor (i = 0; i < n; i++) cin >> x[i] >> y[i] >> z[i];\n\t\t\n\t\tfor (i = 0; i < n; i++) { et[i].clear(); ec[i].clear(); }\n\t\t\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tfor (j = 0; j < n; j++) {\n\t\t\t\tif (i == j) continue;\n\t\t\t\tint sx = s - abs(x[i] - x[j]);\n\t\t\t\tint sy = s - abs(y[i] - y[j]);\n\t\t\t\tint sz = s - abs(z[i] - z[j]);\n\t\t\t\tif (sx < 0 || sy < 0 || sz < 0) continue;\n\t\t\t\tet[i].push_back(j);\n\t\t\t\tec[i].push_back(2 * (sx * sy + sy * sz + sz * sx));\n\t\t\t}\n\t\t}\n\t\t\n\t\tint maxi = -1;\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tmaxi = max(maxi, f(i));\n\t\t}\n\t\tif (maxi == -1) { cout << -1 << endl; }\n\t\telse { cout << k * s * s * 6 - maxi << endl; }\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <functional>\nusing namespace std;\n\nstruct cube {\n    int x, y, z, w;\n    cube() {}\n    cube(int a, int b, int c, int d): x(a), y(b), z(c), w(d) {}\n\n    int overlap_area(cube o) {\n        int ox = w - abs(x - o.x);\n        int oy = w - abs(y - o.y);\n        int oz = w - abs(z - o.z);\n\n        if (ox <= 0 || oy <= 0 || oz <= 0) {\n            return -1;\n        }\n\n        return 2 * (ox * oy + oy * oz + oz * ox);\n    }\n};\n\nint main() {\n    int N, K, S;\n    while (true) {\n        cin >> N >> K >> S;\n        if (N == 0 && K == 0 && S == 0) break;\n\n        vector<cube> cubes;\n        vector<vector<int>> graph(N);\n\n        for (int j = 0; j < N; ++j) {\n            int x, y, z; cin >> x >> y >> z;\n            cubes.emplace_back(x, y, z, S);\n        }\n\n        if (K == 1) {\n            cout << 6*S*S << endl;\n            continue;\n        }\n\n        for (int j = 0; j < N; ++j) {\n            for (int k = j+1; k < N; ++k) {\n                int area = cubes[j].overlap_area(cubes[k]);\n                if (area >= 0) {\n                    graph[j].push_back(k);\n                    graph[k].push_back(j);\n                }\n            }\n        }\n\n        vector<int> visited(N, 0);\n        function<int(int)> get_start = [&](int v) -> int {\n            visited[v] = 1;\n            for (int w: graph[v]) {\n                if (!visited[w])\n                    return get_start(w);\n            }\n            return v;\n        };\n\n        int ans = -1;\n\n        for (int j = 0; j < N; ++j) {\n            if (visited[j])\n                continue;\n            int s = get_start(j);\n\n            vector<int> chain;\n            function<bool(int, int)> set_chain = [&](int v, int prev) -> bool {\n                chain.push_back(v);\n                visited[v] = 1;\n                for (int w: graph[v]) {\n                    if (w == prev) continue;\n                    if (w == s) return true; \n                    return set_chain(w, v);\n                }\n                return false;\n            };\n            bool loop = set_chain(s, -1);\n\n            const int L = chain.size();\n            if (L < K) continue;\n\n            int area = 6*S*S;\n            for (int j = 1; j < (loop ? 2*L : L); ++j) {\n                if (j >= K) {\n                    int v0 = chain[(j-K)%L], v1 = chain[(j-K+1)%L];\n                    area -= 6*S*S - cubes[v0].overlap_area(cubes[v1]);\n                }\n                area += 6*S*S - cubes[chain[(j-1)%L]].overlap_area(cubes[chain[j%L]]);\n\n                if (loop && L == K && j >= L-1)\n                    area -= cubes[chain[j%L]].overlap_area(cubes[chain[(j+1)%L]]);\n\n                if (j+1 >= K)\n                    ans = (ans == -1) ? area : min(ans, area);\n            }\n        }\n\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i,n) for(int i = 0;i < (n);i++)\nconst long long INF = 2 * (int)(1e9);\nusing namespace std;\n\nint N, K, S;\n\nstruct Point{\n    int x, y, z;\n};\n\nPoint p[2003];\n\nbool iscycle[2003];\nbool used[2003];\ndeque<int> graph[2003];\n\nint getS(Point a,Point b){\n    if(a.x > b.x) swap(a.x, b.x);\n    if(a.y > b.y) swap(a.y, b.y);\n    if(a.z > b.z) swap(a.z, b.z);\n    return (a.x + S - b.x) * (a.y + S - b.y) * 2\n        +  (a.z + S - b.z) * (a.x + S - b.x) * 2\n        +  (a.y + S - b.y) * (a.z + S - b.z) * 2;\n}\n\nbool connected(int a,int b){\n    REP(_,2){\n        int x2 = p[b].x;\n        int y2 = p[b].y;\n        int z2 = p[b].z;\n        int xs = S, ys = S;\n        REP(i,8){\n            if(i && (i % 4 == 0)){\n                z2 += S;\n            }\n            if(p[a].x <= x2 && x2 <= p[a].x + S\n               && p[a].y <= y2 && y2 <= p[a].y + S\n               && p[a].z <= z2 && z2 <= p[a].z + S){\n                return true;\n            }\n            if(i % 2 == 0){\n                x2 += xs;\n                xs = -xs;\n            }\n            if(i % 2 == 1){\n                y2 += ys;\n                ys = -ys;\n            }\n        }\n        swap(a,b);\n    }\n    return false;\n}\n\nvoid makegraph(int graphct, int i, bool maincalled, bool back){\n    REP(j,N){\n        if(used[j])continue;\n        if(connected(i,j)){\n            used[j] = true;\n            if(graph[graphct].size() > 1 && (maincalled || back)){\n                graph[graphct].push_front(j);\n                makegraph(graphct, j, false, true);\n            }else{\n                graph[graphct].push_back(j);\n                makegraph(graphct, j, false, false);\n            }\n        }\n    }\n}\n\n\nint main(){\n    while(cin >> N >> K >> S, N){\n        REP(i,N){\n            int x, y, z;\n            cin >> x >> y >> z;\n            p[i] = Point{x, y, z};\n            graph[i].clear();\n            iscycle[i] = false;\n            used[i] = false;\n        }\n\n        //make graph\n        int graphct = 0;\n        REP(i,N){\n            if(used[i]) continue;\n            graph[graphct].push_back(i);\n            used[i] = true;\n            makegraph(graphct, i, true, true);\n            graphct++;\n        }\n\n        //cycle check\n        REP(i,graphct){\n            if(graph[i].size() > 2 && connected(graph[i][0],graph[i][graph[i].size() - 1]))\n                iscycle[i] = true;\n        }\n        \n        long long ans = INF;\n        REP(i,graphct){\n            if((int)graph[i].size() < K) continue;\n            REP(j,graph[i].size()){\n                if(j + K - 1 > graph[i].size() - 1) break;\n                long long tmpans = 0;\n                for(int r = 0; r < K;r++){\n                    tmpans += S*S*6;\n                    if(r){\n                        tmpans -= getS(p[graph[i][j + r]], p[graph[i][j + r - 1]]);\n                    }else if(iscycle[i] && K == graph[i].size()){\n                        tmpans -= getS(p[graph[i][0]], p[graph[i][graph[i].size() - 1]]);\n                    }\n                }\n                ans = min(tmpans, ans);\n            }\n        }\n        if(ans == INF) cout << -1 << endl;\n        else cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n#include <vector>\n#include <iostream>\n#include <string>\n#include <string.h>\nusing namespace std;\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define sc second\ntypedef pair<int,int> P;\nint n,k,s;\nint x[2005],y[2005],z[2005];\nvector<P>edge[2005];\nbool used[2005];\nint main(){\n    while(1){\n        cin >> n >> k >>s; if(n==0) return 0;\n        for(int i=1;i<=n;i++){\n            cin >> x[i] >> y[i] >>z[i];\n        }\n        for(int i=1;i<=n;i++) edge[i].clear();\n        int ans = -1;\n        for(int i=1;i<=n;i++){\n            for(int j=i+1;j<=n;j++){\n                int X = abs(x[i]-x[j]);\n                int Y = abs(y[i]-y[j]);\n                int Z = abs(z[i]-z[j]);\n                if(X>=s || Y>=s || Z>=s) continue;\n                X = s-X; Y = s-Y; Z = s-Z;\n                edge[i].pb(mp(j,2*X*Y+2*Y*Z+2*Z*X));\n                edge[j].pb(mp(i,2*X*Y+2*Y*Z+2*Z*X));\n                //cout <<i <<\" \" << j <<endl;\n            }\n        }\n        if(k==1){\n            cout << 6*s*s <<endl; continue;\n        }\n        memset(used,0,sizeof(used));\n        //path\n        for(int i=1;i<=n;i++){\n            if(used[i] || edge[i].size() != 1) continue;\n            int cur = i;\n            vector<int>cs;\n            while(!used[cur]){\n                //cout<<cur<<endl;\n                used[cur] = 1;\n                for(int k=0;k<edge[cur].size();k++){\n                    if(used[edge[cur][k].fi]) continue;\n                    cs.pb(edge[cur][k].sc); cur = edge[cur][k].fi; break;\n                }\n            }\n            //for(int i=0;i<cs.size();i++) cout << cs[i] <<\" \"; cout <<endl;\n            if(cs.size() < k-1) continue;\n            int sum = 0;\n            for(int i=0;i<cs.size();i++){\n                sum += cs[i];\n                if(i>=k-2){\n                    ans = max(ans,sum);\n                    sum -= cs[i-k+2];\n                }\n            }\n        }\n        //cycle\n        for(int i=1;i<=n;i++){\n            if(used[i]) continue;\n            int cur = i;\n            vector<int>cs;\n            while(!used[cur]){\n                used[cur] = 1;\n                for(int k=0;k<edge[cur].size();k++){\n                    if(used[edge[cur][k].fi]) continue;\n                    cs.pb(edge[cur][k].sc); cur = edge[cur][k].fi; goto nxt;\n                }\n                for(int k=0;k<edge[cur].size();k++){\n                    if(edge[cur][k].fi == i){\n                        cs.pb(edge[cur][k].sc); break;\n                    }\n                }\n            nxt:;\n            }\n            //if(n==4) for(int i=0;i<cs.size();i++) cout << cs[i] <<\" \"; cout <<endl;\n            int sum = 0;\n            if(cs.size() < k) continue;\n            if(cs.size()==k){\n                for(int i=0;i<k;i++) sum+=cs[i];\n                ans = max(ans,sum);\n            }\n            else{\n                for(int i=0;i<2*cs.size();i++){\n                    sum += cs[i%cs.size()];\n                    if(i>=k-2){\n                        ans = max(ans,sum);\n                        sum -= cs[(i-k+2)%cs.size()];\n                    }\n                }\t\n            }\n\t\t}\n\t\t\n            if(ans==-1)puts(\"-1\");\n            else cout << k*6*s*s-ans <<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing LL = long long;\n\n#define fs first\n#define sc second\n\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return 1; } return 0; }\n\n\n// std::vector Declaration\ntemplate<typename T>\nvector<T> make_v(size_t a) { return vector<T>(a); }\ntemplate<typename T,typename... Ts>\nauto make_v(size_t a,Ts... ts) {\n    return vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));\n}\n\n// std::vector Initialization\ntemplate<typename T>\nvoid fill_all(T& arr, const T& v) { arr = v; }\ntemplate<typename T, typename U>\nvoid fill_all(T& arr, const U& v) { for (auto& i : arr) fill_all(i, v); }\n\n// std::vector Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n    os << \"[\";\n    bool a = 1;\n    for (auto e : v ) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"]\";\n    return os;\n}\n\n// std::pair Debug\ntemplate<typename T, typename U>\nostream& operator<<(ostream& os, const pair<T, U>& p) {\n    os << \"(\" << p.first << \" \" << p.second << \")\";\n    return os;\n}\n\n// std::set Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const set<T>& st) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : st) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n\n// std::multiset Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const multiset<T>& st) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : st) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n\n// std::map Debug\ntemplate<typename T, typename U>\nostream& operator<<(ostream& os, const map<T, U>& mp) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : mp) {\n        os << (a ? \"\" : \" \");\n        os << e.first << \":\" << e.second;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n\n// std::tuple Debug\ntemplate<int N, class Tuple>\nvoid out(ostream& os, const Tuple& t){}\ntemplate<int N, class Tuple, class H, class ...Ts>\nvoid out(ostream& os, const Tuple& t) {\n    if (N) os << \" \";\n    os << get<N>(t);\n    out<N+1,Tuple,Ts...>(os, t);\n}\ntemplate<class ...Ts>\nostream& operator<<(ostream& os, const tuple<Ts...>& t) {\n    os << \"(\";\n    out<0,tuple<Ts...>,Ts...>(os, t);\n    os << \")\";\n    return os;\n}\n\n// Debug\n#define DUMP(x) cerr<<#x<<\" = \"<<(x)<<endl\n\n\nstruct edge { int to, cost; };\nostream& operator<<(ostream& os, const edge& e) {\n    os << \"(\" << e.to << \", \" << e.cost << \")\";\n    return os;\n}\n\nconst LL LINF = 1LL<<60;\nconst int IINF = 1<<30;\nconst LL MOD = 1e9+7;\n\nvoid dfs(const auto& G, auto& visited, auto& costs, int v, int p, bool& cyclic) {\n    if (visited[v]) {\n        cyclic = true;\n        return;\n    }\n    visited[v] = true;\n    for (auto e : G[v]) {\n        if (e.to == p) continue;\n        costs.push_back(e.cost);\n        dfs(G, visited, costs, e.to, v, cyclic);\n        break;\n    }\n}\n\nint moveToLeaf(const auto& G, auto& visited, int v, int p) {\n    if (visited[v]) {\n        return v;\n    }\n    visited[v] = true;\n    int ret = v;\n    for (auto e : G[v]) {\n        if (e.to == p) continue;\n        ret = moveToLeaf(G, visited, e.to, v);\n    }\n    return ret;\n}\n\nvoid getCosts(const auto& G, auto& visited, auto& costs, int v, bool& cyclic)\n{\n    // cyclicじゃないときに, 葉に移動\n    map<int,bool> tmpvisited;\n    v = moveToLeaf(G, tmpvisited, v, -1);\n\n    dfs(G, visited, costs, v, -1, cyclic);\n}\n\nint main()\n{\n    vector<int> ns, ks, ss;\n    vector<vector<int>> xs, ys, zs;\n\n    while (true) {\n        int n, k, s; cin >> n >> k >> s;\n        if (n == 0 && k == 0 && s == 0) {\n            break;\n        }\n        vector<int> x(n), y(n), z(n);\n        for (int i = 0; i < n; ++i) {\n            cin >> x[i] >> y[i] >> z[i];\n        }\n\n        ns.push_back(n);\n        ks.push_back(k);\n        ss.push_back(s);\n        xs.push_back(x);\n        ys.push_back(y);\n        zs.push_back(z);\n    }\n\n    for (int t = 0; t < ns.size(); ++t) {\n        int n = ns[t], k = ks[t], s = ss[t];\n        auto x = xs[t], y = ys[t], z = zs[t];\n\n        vector<vector<edge>> G(n);\n\n        for (int i = 0; i < n; ++i) {\n            for (int j = i+1; j < n; ++j) {\n                int dx = abs(x[i] - x[j]),\n                    dy = abs(y[i] - y[j]),\n                    dz = abs(z[i] - z[j]);\n                if (dx < s && dy < s && dz < s) {\n                    int X = s - dx,\n                        Y = s - dy,\n                        Z = s - dz;\n                    int cost = 2 * (X*Y + Y*Z + Z*X);\n                    G[i].push_back(edge{ j, cost });\n                    G[j].push_back(edge{ i, cost });\n                }\n            }\n        }\n\n        LL Max = -1;\n\n        vector<bool> visited(n, false);\n        for (int i = 0; i < n; ++i) {\n            if (visited[i]) {\n                continue;\n            }\n            vector<int> costs;\n            bool cyclic = false;\n            getCosts(G, visited, costs, i, cyclic);\n\n            if (cyclic) {\n                int m = costs.size();\n                if (m < k-1) {\n                    continue;\n                }\n                vector<LL> sum(m+1);\n                for (int j = 0; j < m; ++j) {\n                    sum[j+1] = sum[j] + costs[j];\n                }\n\n                if (m == k) {\n                    chmax(Max, sum[m]);\n                }\n\n                for (int j = 0; j+k-1 <= m; ++j) {\n                    chmax(Max, sum[j+k-1] - sum[j]);\n                }\n                for (int j = 0; j <= k-1; ++j) {\n                    chmax(Max, sum[j] + (sum[m] - sum[m-(k-1-j)]));\n                }\n            }\n            else {\n                int m = costs.size();\n                if (m < k-1) {\n                    continue;\n                }\n                vector<LL> sum(m+1);\n                for (int j = 0; j < m; ++j) {\n                    sum[j+1] = sum[j] + costs[j];\n                }\n\n                for (int j = 0; j+k-1 <= m; ++j) {\n                    chmax(Max, sum[j+k-1] - sum[j]);\n                }\n            }\n        }\n        if (Max == -1) {\n            cout << -1 << endl;\n        } else {\n            LL ans = s*s*6 * k - Max;\n            cout << ans << endl;\n        }\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int INF = 1 << 30;\n\nstruct edge\n{\n  int to, cost;\n};\n\nint main()\n{\n  int N, K, S;\n  int X[2000], Y[2000], Z[2000];\n\n  while(cin >> N >> K >> S, N) {\n    for(int i = 0; i < N; i++) {\n      cin >> X[i] >> Y[i] >> Z[i];\n    }\n\n    vector< edge > g[2000];\n    for(int i = 0; i < N; i++) {\n      for(int j = 0; j < i; j++) {\n        int latte = max(0, S - abs(X[i] - X[j]));\n        int malta = max(0, S - abs(Y[i] - Y[j]));\n        int beeet = max(0, S - abs(Z[i] - Z[j]));\n        int ukuku = latte * malta + malta * beeet + beeet * latte;\n        if(latte > 0 && malta > 0 && beeet > 0) {\n          g[i].emplace_back((edge) {j, ukuku});\n          g[j].emplace_back((edge) {i, ukuku});\n        }\n      }\n    }\n\n    int ret = -1;\n    for(int i = 0; i < N; i++) {\n      bool v[2000] = {};\n      function< void(int, int, int) > dfs = [&](int idx, int k, int sz)\n      {\n        if(v[idx]++) return;\n        if(k == 0) {\n          if(K >= 3) for(auto &e: g[idx]) if(e.to == i) sz += e.cost;\n          ret = max(ret, sz);\n        } else {\n          for(auto &e : g[idx]) dfs(e.to, k - 1, sz + e.cost);\n        }\n        v[idx] = false;\n      };\n      dfs(i, K - 1, 0);\n    }\n    if(ret == -1) cout << -1 << endl;\n    else cout << 6 * S * S * K - ret * 2 << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing P = pair<int, int>;\n\ntemplate <typename T>\nclass SegmentTree {\n\tusing func_t = function<T(T, T)>;\n\tconst int n;\n\tconst T id;\n\tfunc_t merge;\n\tvector<T> data;\n\tint size(int n) {\n\t\tint res;\n\t\tfor (res = 1; res < n; res <<= 1);\n\t\treturn res;\n\t}\n\tT sub(int l, int r, int node, int lb, int ub) {\n\t\tif (ub <= l || r <= lb) return id;\n\t\tif (l <= lb && ub <= r) return data[node];\n\t\treturn merge(sub(l, r, node * 2, lb, (lb + ub) / 2), sub(l, r, node * 2 + 1, (lb + ub) / 2, ub));\n\t}\npublic:\n\tSegmentTree(int n_, T id_, func_t merge_) :\n\t\tn(size(n_)), id(id_), merge(merge_), data(size(n_) * 2, id_) {\n\t\tfor (int i = n; i < n * 2; i++) {\n\t\t\tdata[i].first = i - n;\n\t\t}\n\t\tfor (int i = n - 1; i >= 0; i--) {\n\t\t\tdata[i] = merge(data[i * 2], data[i * 2 + 1]);\n\t\t}\n\t}\n\tvoid Update(int p, int val) {\n\t\tp += n;\n\t\tdata[p].second = val;\n\t\twhile (p >>= 1) data[p] = merge(data[p * 2], data[p * 2 + 1]);\n\t}\n\tvoid Add(int p, int val) {\n\t\tp += n;\n\t\tdata[p].second += val;\n\t\twhile (p >>= 1) data[p] = merge(data[p * 2], data[p * 2 + 1]);\n\t}\n\tT Find(int l, int r) {\n\t\treturn sub(l, r + 1, 1, 0, n);\n\t}\n};\n\n\nint main()\n{\n\tint n, k, s;\n\twhile (cin >> n >> k >> s, n | k | s) {\n\t\tvector<int> x(n), y(n), z(n);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcin >> x[i] >> y[i] >> z[i];\n\t\t}\n\t\tvector<vector<P>> G(n);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tif (i != j) {\n\t\t\t\t\tint dx = s - abs(x[i] - x[j]), dy = s - abs(y[i] - y[j]), dz = s - abs(z[i] - z[j]);\n\t\t\t\t\tif (dx > 0 && dy > 0 && dz > 0) {\n\t\t\t\t\t\tG[i].push_back(P(j, dx * dy * 2 + dy * dz * 2 + dz * dx * 2));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tll res = s * s * 6 * k, d = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tSegmentTree<P> st(n, P(), [](P a, P b) {\n\t\t\t\treturn a.second >= b.second ? a : b;\n\t\t\t});\n\t\t\tvector<int> used(n, 1);\n\t\t\tll tmp = 0;\n\t\t\tbool flag = true;\n\t\t\tused[i] = 0;\n\t\t\tst.Update(i, 0);\n\t\t\tfor (auto p : G[i]) {\n\t\t\t\tst.Add(p.first, p.second);\n\t\t\t}\n\t\t\tfor (int j = 0; j < k - 1; j++) {\n\t\t\t\tauto ne = st.Find(0, n - 1);\n\t\t\t\tif (ne.second == 0) {\n\t\t\t\t\tflag = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\ttmp += ne.second;\n\t\t\t\tused[ne.first] = 0;\n\t\t\t\tst.Update(ne.first, 0);\n\t\t\t\tfor (auto p : G[ne.first]) {\n\t\t\t\t\tif (used[p.first]) {\n\t\t\t\t\t\tst.Add(p.first, p.second);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (flag) {\n\t\t\t\td = max(d, tmp);\n\t\t\t}\n\t\t}\n\t\tcout << (d || k == 1 ? res - d : -1) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, n) for(int i = a; i < n; i++)\n#define int long long\nusing namespace std;\nconst int MAX_N = 2010;\nconst int INF = 1e18;\nint d[MAX_N][MAX_N];\nvector<int> G[MAX_N];\nint n, k, s;\n\nint calc(int x1, int y1, int z1, int x2, int y2, int z2){\n    int x = min(x1, x2) + s - max(x1, x2);\n    int y = min(y1, y2) + s - max(y1, y2);\n    int z = min(z1, z2) + s - max(z1, z2);\n    // cout << \" \" << x << ' ' << y << ' ' << z << endl;\n    if(x <= 0 || y <= 0 || z <= 0) return 0;\n    // if(x == 0) x = s;\n    // if(y == 0) y = s;\n    // if(z == 0) z = s;\n    int res = 2 * (x * y + y * z + z * x);\n    return res;\n}\n\nsigned main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    while(1){\n        cin >> n >> k >> s;\n        if(n + k + s == 0) break;\n        vector<int> x(n), y(n), z(n);\n        rep(i, 0, n){\n            cin >> x[i] >> y[i] >> z[i];\n        }\n        if(n == 1){\n            cout << 6 * s * s << endl;\n            continue;\n        }\n        rep(i, 0, n) rep(j, 0, n) d[i][j] = 0;  \n        rep(i, 0, n) G[i].clear();\n        rep(i, 0, n){\n            rep(j, i + 1, n){\n                d[i][j] = calc(x[i], y[i], z[i], x[j], y[j], z[j]);\n                    // cout << i << ' ' << j << ' ' << d[i][j] << endl;\n                d[j][i] = d[i][j];\n                if(d[i][j] > 0){\n                    G[i].push_back(j);\n                    G[j].push_back(i);\n                }\n            }\n        }\n        int ans = INF;\n        rep(i, 0, n){\n            rep(j, 0, G[i].size()){\n                int tmp = 0;\n                int now = G[i][j], nxt, pre = i;\n                // cout << i << ' ' << tmp << endl;\n                rep(l, 0, k - 1){\n                    if(now == i){\n                        tmp = INF; break;\n                    }\n                    tmp += d[pre][now];\n                    // cout << now << ' ' << d[pre][now] << \" \" << tmp << endl;                    \n                    if(G[now].size() == 1){\n                        if(l == k - 2){\n                            now = pre = i;\n                        }else{\n                            tmp = INF;\n                        }\n                        break;\n                    }else{\n                        rep(p, 0, G[now].size()){\n                            if(G[now][p] != pre) nxt = G[now][p];\n                        }\n                        pre = now;\n                        now = nxt;\n                    }\n                }\n                // cout << endl;\n                if(tmp != INF){\n                    if(now == i) tmp += d[pre][now];\n                    // cout << now << \" \" << pre << \" \" << d[pre][now] << \" \" << tmp << endl;\n                    tmp = 6 * s * s * k - tmp;\n                    ans = min(ans, tmp);\n                    // cout << \" \" << tmp << endl;\n                }\n            }\n        }\n        if(ans == INF) cout << -1 << endl;\n        else cout << ans << endl;\n    }\n    \n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\nint N, K;\nlong long int S;\n\nstruct cube {\n\tvector<long long int>coors;\n};\n\nlong long int connect(const cube&l, const cube&r) {\n\tvector<long long int>ds;\n\tfor (int i = 0; i < 3; ++i) {\n\t\tif (abs(l.coors[i] - r.coors[i]) >= S)return 0;\n\t\telse ds.emplace_back(S-abs(l.coors[i] - r.coors[i]));\n\t}\n\treturn 2 * (ds[0] * ds[1] + ds[1] * ds[2] + ds[2] * ds[0]);\n}\nvoid dfs(const int now, const int from, const vector<vector<pair<int, long long int>>>&edges, vector<int>&used,vector<long long int>&v) {\n\tfor (auto e : edges[now]) {\n\t\tif (e.first == from)continue;\n\t\tif (used[e.first]) {\n\t\t\tv.push_back(e.second);\n\t\t}\n\t\telse {\n\t\t\tv.push_back(e.second);\n\t\t\tused[e.first] = true;\n\t\t\tdfs(e.first, now, edges, used, v);\n\t\t}\n\t}\n}\nint main() {\n\twhile (1) {\n\t\tcin >> N >> K >> S;\n\t\tif (!N)break;\n\t\tlong long int total = K*S*S * 6;\n\t\t\n\t\tvector<cube>cus;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tint x, y, z; cin >> x >> y >> z;\n\t\t\tcus.push_back(cube{ vector<long long int>{x,y,z} });\n\t\t}\n\t\tif (K == 1) {\n\t\t\tcout << total << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tvector<vector<pair<int, long long int>>>edges(N);\n\t\tvector<vector<long long int>>memo(N, vector<long long int>(N));\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tfor (int j = 0; j < N; ++j) {\n\t\t\t\tif (i == j)continue;\n\t\t\t\tlong long int sa = connect(cus[i], cus[j]);\n\t\t\t\tif (sa) {\n\t\t\t\t\tedges[i].push_back(make_pair(j, sa));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvector<int>used(N);\n\t\tlong long int hide_max = -1;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tif (!used[i]) {\n\t\t\t\tif (edges[i].size()==1) {\n\t\t\t\t\tused[i] = true;\n\t\t\t\t\tvector<long long int>v;\n\t\t\t\t\tdfs(i, -1, edges, used, v);\n\t\t\t\t\tif (v.size() < K-1)continue;\n\t\t\t\t\telse {\n\t\t\t\t\t\tlong long int sum = 0;\n\t\t\t\t\t\tfor (int i = 0; i < K - 1; ++i) {\n\t\t\t\t\t\t\tsum += v[i];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor (int i = K - 1; i <=v.size() + K; ++i) {\n\t\t\t\t\t\t\thide_max = max(hide_max, sum);\n\t\t\t\t\t\t\tsum -= v[(i - K + 1) % v.size()];\n\t\t\t\t\t\t\tsum += v[i%v.size()];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tif (!used[i]) {\n\t\t\t\tused[i] = true;\n\t\t\t\tif (!edges[i].empty()) {\n\t\t\t\t\tvector<long long int>v;\n\t\t\t\t\tdfs(i, edges[i][0].first, edges, used, v);\n\t\t\t\t\tif (v.size() < K)continue;\n\t\t\t\t\telse if (v.size() == K) {\n\t\t\t\t\t\thide_max = max(hide_max, accumulate(v.begin(), v.end(), 0ll));\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tlong long int sum = 0;\n\t\t\t\t\t\tfor (int i = 0; i < K-1; ++i) {\n\t\t\t\t\t\t\tsum += v[i];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor (int i = K-1; i <= v.size()+K; ++i) {\n\t\t\t\t\t\t\thide_max = max(hide_max, sum);\n\t\t\t\t\t\t\tsum -= v[(i - K+1) % v.size()];\n\t\t\t\t\t\t\tsum += v[i%v.size()];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t}\n\t\tif (hide_max == -1)cout << -1 << endl;\n\t\telse {\n\t\t\tcout << total - hide_max << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing P = pair<int, int>;\n\nint main()\n{\n\tint n, k, s;\n\twhile (cin >> n >> k >> s, n | k | s) {\n\t\tvector<int> x(n), y(n), z(n);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcin >> x[i] >> y[i] >> z[i];\n\t\t}\n\t\tvector<vector<P>> G(n);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tif (i != j) {\n\t\t\t\t\tint dx = s - abs(x[i] - x[j]), dy = s - abs(y[i] - y[j]), dz = s - abs(z[i] - z[j]);\n\t\t\t\t\tif (dx > 0 && dy > 0 && dz > 0) {\n\t\t\t\t\t\tG[i].push_back(P(j, dx * dy * 2 + dy * dz * 2 + dz * dx * 2));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tll res = s * s * 6 * k, d = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tpriority_queue<int> pq;\n\t\t\tvector<int> used(n, 0);\n\t\t\tll tmp = 0;\n\t\t\tbool flag = true;\n\t\t\tused[i] = -1;\n\t\t\tfor (auto p : G[i]) {\n\t\t\t\tused[p.first] += p.second;\n\t\t\t\tpq.push(p.first);\n\t\t\t}\n\t\t\tfor (int j = 0; j < k - 1; j++) {\n\t\t\t\tif (pq.empty()) {\n\t\t\t\t\tflag = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tauto ne = pq.top(); pq.pop();\n\t\t\t\ttmp += used[ne];\n\t\t\t\tused[ne] = -1;\n\t\t\t\tfor (auto p : G[ne]) {\n\t\t\t\t\tif (used[p.first] >= 0) {\n\t\t\t\t\t\tused[p.first] += p.second;\n\t\t\t\t\t\tpq.push(p.first);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (flag) {\n\t\t\t\td = max(d, tmp);\n\t\t\t}\n\t\t}\n\t\tcout << (d || k == 1 ? res - d : -1) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;++i)\n\nint n,k,s;\nstruct Cube{\n\tint x,y,z;\n\tint node[2];\n\tint share;//with back cube\n\tint form;//-1:reseach now, 0:not visited, 1:line, 2:ring\n};\n\nvector<Cube> c;\nvector<int> graph;\n\n//return form\nint connect(int i,bool back){\n\t//it's found ring\n\tif(c[i].form == -1){\n\t\tgraph.push_back(i);\n\t\treturn 2;\n\t}\n\trep(j,n){\n\t\tif(i==j || c[j].form>0 || i==c[j].node[!back])continue;\n\t\tint sx = s-abs(c[i].x-c[j].x);\n\t\tint sy = s-abs(c[i].y-c[j].y);\n\t\tint sz = s-abs(c[i].z-c[j].z);\n\t\tif(sx<=0 || sy<=0 || sz<=0)continue;\n\t\t//connected\n\t\tc[i].node[!back] = j;\n\t\tc[j].node[back] = i;\n\t\tc[(back ? i : j)].share = 2*(sx*sy+sy*sz+sz*sx);\n\t\tc[i].form = -1;\n\t\tc[i].form = connect(j,back);\n\t\t//2:ring\n\t\tif(c[i].form==2)return 2;\n\t\t//1:line\n\t\tif(back)return 1;\n\t\tback=true;\n\t}\n\t//not found new connect\n\tif(back && c[i].node[0]==-1)graph.push_back(i);\n\treturn c[i].form = 1;\n}\n\nint main(){\n\twhile(cin>>n>>k>>s,n|k|s){\n\t\tc.clear();\n\t\tgraph.clear();\n\t\tint x,y,z;\n\t\trep(i,n){\n\t\t\tcin>>x>>y>>z;\n\t\t\tc.push_back(Cube{x,y,z,{-1,-1},0,0});\n\t\t}\n\t\trep(i,n)if(!c[i].form)connect(i,false);\n\t\tint maxsum = 0;\n\t\trep(i,(int)graph.size()){\n\t\t\tbool round = false;\n\t\t\tint tail = graph[i];\n\t\t\tint head = c[tail].node[1];\n\t\t\tint sum = 0, link = 0;\n\t\t\twhile(1){\n\t\t\t\tif(link+1==k)maxsum = max(sum,maxsum);\n\t\t\t\tif((round && tail==graph[i]) || head==-1)break;\n\t\t\t\tlink++;\n\t\t\t\tsum += c[head].share;\n\t\t\t\thead = c[head].node[1];\n\t\t\t\tround |= graph[i]==head;\n\t\t\t\t//(k or less)-ring\n\t\t\t\tif(round && link<k){\n\t\t\t\t\t//just k-ring\n\t\t\t\t\tif(link+1==k)maxsum = max(sum+c[head].share,maxsum);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(link == k){\n\t\t\t\t\ttail = c[tail].node[1];\n\t\t\t\t\tsum -= c[tail].share;\n\t\t\t\t\tlink--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<(maxsum||k==1 ? 6*s*s*k-maxsum : -1)<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\nusing P = pair<int, int>;\nconst double eps = 1e-8;\nconst ll MOD = 1000000007;\nconst int INF = INT_MAX / 2;\nconst ll LINF = LLONG_MAX / 2;\ntemplate <typename T1, typename T2>\nbool chmax(T1 &a, const T2 &b) {\n  if(a < b) {a = b; return true;}\n  return false;\n}\ntemplate <typename T1, typename T2>\nbool chmin(T1 &a, const T2 &b) {\n  if(a > b) {a = b; return true;}\n  return false;\n}\ntemplate<typename T1, typename T2>\nostream& operator<<(ostream &os, const pair<T1, T2> p) {\n  os << p.first << \":\" << p.second;\n  return os;\n}\ntemplate<class T>\nostream &operator<<(ostream &os, const vector<T> &v) {\n  for(int i=0;i<((int)(v.size()));++i) {\n    if(i) os << \" \";\n    os << v[i];\n  }\n  return os;\n}\nvi x, y, z;\nbool is_edge(int i, int j, int s) {\n  return abs(x[i] - x[j]) < s &&\n        abs(y[i] - y[j]) < s &&\n        abs(z[i] - z[j]) < s;\n}\nint kasanari(int i, int j, int s) {\n  int nx = s - abs(x[i] - x[j]);\n  int ny = s - abs(y[i] - y[j]);\n  int nz = s - abs(z[i] - z[j]);\n  return 2 * (nx * ny + ny * nz + nz * nx);\n}\nint n;\nbool cycle;\nint calc(int now, int prev, int st, int res, int k, int cnt, int s, vvi &g) {\n  int mi = INF;\n  for(auto &nxt: g[now]) {\n    if(nxt == prev) continue;\n    if(nxt == st) {\n      res -= kasanari(now, nxt, s);\n      if(cnt == k) chmin(mi, res);\n      res += kasanari(now, nxt, s);\n    } else {\n      res += 6 * s * s;\n      res -= kasanari(now, nxt, s);\n      if(cnt != k) chmin(mi, calc(nxt, now, st, res, k, cnt+1, s, g));\n      res -= 6 * s * s;\n      res += kasanari(now, nxt, s);\n    }\n  }\n  if(cnt == k && (!cycle || k != n)) chmin(mi, res);\n  return mi;\n}\nbool solve() {\n  int k, s; cin >> n >> k >> s;\n  if(n == 0) return false;\n  x.clear();\n  y.clear();\n  z.clear();\n  x.resize(n);\n  y.resize(n);\n  z.resize(n);\n  for(int i=0;i<(n);++i) cin >> x[i] >> y[i] >> z[i];\n  if(k == 1) {\n    cout << 6 * s * s << endl;\n    return true;\n  }\n  vvi g(n);\n  vi d(n);\n  for(int i=0;i<(n);++i) {\n    for(int j=0;j<(n);++j) {\n      if(i == j) continue;\n      if(is_edge(i, j, s)) {\n        g[i].push_back(j);\n        d[i]++;\n        d[j]++;\n      }\n    }\n  }\n  cycle = true;\n  for(int i=0;i<(n);++i) {\n    cycle &= d[i] == 2;\n  }\n  int mi = INF;\n  for(int i=0;i<(n);++i) {\n    chmin(mi, calc(i, -1, i, 6 * s * s, k, 1, s, g));\n  }\n  cout << (mi == INF ? -1 : mi) << endl;\n  return true;\n}\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  cout << fixed << setprecision(10);\n  while(solve()) {}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <cmath>\n#include <cstdlib>\n#include <map>\nusing namespace std;\n \nclass Point {\npublic:\n    int x, y, z;\n    Point(int x = 0, int y = 0, int z = 0) : x(x), y(y), z(z) {}\n};\n \nclass Cube {\npublic:\n    Point p;\n    int s;\n    int vx[4] = {0, 1, 1, 0}, vy[4] = {0, 0, 1, 1}, vz[2] = {0, 1};\n    Cube(Point p = Point(), int s = 0) : p(p), s(s) {}\n \n    bool isIn(const Cube &c) {\n        return ((abs(p.x - c.p.x) < s) && (abs(p.y - c.p.y) <= s) && (abs(p.z - c.p.z) <= s) &&\n                (abs(p.x - c.p.x) <= s) && (abs(p.y - c.p.y) < s) && (abs(p.z - c.p.z) <= s) &&\n                (abs(p.x - c.p.x) <= s) && (abs(p.y - c.p.y) <= s) && (abs(p.z - c.p.z) < s));\n    }\n \n    long long shareS(Cube &c) {\n        long long ret = 0;\n        Point a, b;\n        a = p; b = c.p;\n \n        if (a.x > b.x) swap(a.x, b.x);\n        if (a.y > b.y) swap(a.y, b.y);\n        if (a.z > b.z) swap(a.z, b.z);\n \n        ret += abs((a.x + s - b.x) * (a.z + s - b.z) * 2);\n        ret += abs((a.y + s - b.y) * (a.z + s - b.z) * 2);\n        ret += abs((a.x + s - b.x) * (a.y + s - b.y) * 2);\n        return ret;\n    }\n \n};\n \nint n, k, s, x, y, z;\nlong long ans;\nvector<Cube> c;\nvector<vector<int> > subg;\nvector<bool> used;\nvector<deque<int> > graph;\ndeque<int> que;\n \ninline void makegraph() {\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            if (c[i].isIn(c[j])) {\n                subg[j].push_back(i);\n                subg[i].push_back(j);\n            }\n        }\n    }\n}\n \n// make path\nvoid dfs(int v) {\n    used[v] = true;\n    int size_ = subg[v].size();\n    bool flag = false;\n \n    for (int i = 0; i < size_; ++i) {\n        if (!used[subg[v][i]]) {\n            dfs(subg[v][i]);\n            if (!flag) que.push_front(v);\n            flag = true;\n        }\n    }\n \n    if (!flag) que.push_front(v);\n}\n \n// is graph[graphid] cycle ?\ninline bool isCycle(int graphid) {\n    int size_ = graph[graphid].size();\n \n    // if all vertex's degree are two, this graph has closed path.\n    for (int i = 0; i < size_; ++i) {\n        if (subg[graph[graphid][i]].size() != 2) return false;\n    }\n \n    return true;\n}\n \nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n \n    while (cin >> n >> k >> s, n | k | s) {\n        c.resize(n);\n        subg.resize(n);\n        que.clear();\n        used.assign(n, false);\n        ans = int(1e15);\n \n        for (int i = 0; i < n; ++i) {\n            cin >> x >> y >> z;\n            c[i] = {Point(x, y, z), s};    \n        }\n \n        makegraph();\n \n        for (int i = 0; i < n; ++i) {\n            if (!used[i]) {\n                dfs(i);\n                graph.push_back(que);\n                que.clear();\n            }\n        }\n \n        int gsize = graph.size(), qsize, upper;\n        long long share;\n        bool isGraphCycle = false;\n \n        for (int i = 0; i < gsize; ++i) {\n            qsize = graph[i].size();\n            isGraphCycle = isCycle(i);\n            if (isGraphCycle) {\n                upper = qsize + k - 1;\n            }\n            else upper = qsize;\n \n            if (qsize < k) continue;\n \n            for (int j = 0; j + k - 1 < upper; ++j) {\n                share = 0;\n \n                for (int l = 0; l < k - 1; ++l) {\n                    share += c[graph[i][(j + l) % qsize]].shareS(c[graph[i][(j + l + 1) % qsize]]);\n                }\n \n                if (isGraphCycle && qsize == k) {\n                    share += c[graph[i][j % qsize]].shareS(c[graph[i][(j + qsize - 1) % qsize]]);\n                }\n \n                ans = min(ans, 6 * s * s * k - share);\n            }\n        }\n \n        if (k == 1) ans = 6 * s * s;\n        if (ans == int(1e15)) ans = -1;\n \n        cout << ans << endl;\n \n        c.clear();\n        graph.clear();\n        subg.clear();\n        used.clear();\n    }\n \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\ntypedef long long ll;\n\nll n, k, s, x[2000], y[2000], z[2000], e[2000][2], cost[2000][2], counter[2000], used[2000], temp[5000];\nconst ll INF = 100000000000LL;\n\nll dfs(ll num, ll before, ll c, ll sum) {\n  if (used[num] >= 2) return INF;\n  //printf(\"%lld, %lld, %lld, %lld\\n\", num, before, c, sum);\n  used[num]++;\n  ll ans = INF;\n  if (c >= k-1) ans = s * s * 6 * k - sum;\n  for (ll i = 0; i < counter[num]; i++) if (e[num][i] != before) {\n    temp[c] = cost[num][i];\n    sum += cost[num][i];\n    if (c == k-1 && used[i] == 1 && used[e[num][i]] == 1) return s * s * 6 * k - sum;\n    if (c >= k-1) sum -= temp[c-k+1];\n    ans = min(ans, dfs(e[num][i], num, c+1, sum));\n  }\n  return ans;\n}\n\nint main() {\n  while (scanf(\"%lld%lld%lld\", &n, &k, &s), n) {\n    for (ll i = 0; i < n; i++) scanf(\"%lld%lld%lld\", &x[i], &y[i], &z[i]), counter[i] = 0;\n    for (ll i = 0; i < n; i++) {\n      for (ll j = i+1; j < n; j++) {\n        if (i == j) continue;\n        ll xdiff = s - abs(x[i] - x[j]);\n        ll ydiff = s - abs(y[i] - y[j]);\n        ll zdiff = s - abs(z[i] - z[j]);\n        if (xdiff < 0 || ydiff < 0 || zdiff < 0) continue;\n        e[i][counter[i]] = j;\n        cost[i][counter[i]] = (xdiff * ydiff + ydiff * zdiff + zdiff * xdiff) * 2;\n        counter[i]++;\n        e[j][counter[j]] = i;\n        cost[j][counter[j]] = (xdiff * ydiff + ydiff * zdiff + zdiff * xdiff) * 2;\n        counter[j]++;\n      }\n    }\n    for (ll i = 0; i < n; i++) used[i] = 0;\n    ll ans = INF;\n    for (ll i = 0; i < n; i++) if (!used[i] && counter[i] == 1) ans = min(ans, dfs(i, -1, 0, 0));\n    for (ll i = 0; i < n; i++) if (!used[i] && counter[i] == 2) ans = min(ans, dfs(i, e[i][0], 0, 0));\n    for (ll i = 0; i < n; i++) if (!used[i]) ans = min(ans, dfs(i, -1, 0, 0));\n    if (ans == INF) ans = -1;\n    printf(\"%lld\\n\", ans);\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#define int long long\nusing namespace std;\n\nint n, k, s;\nint x[2000], y[2000], z[2000];\nvector<int> et[2000];\nvector<int> ec[2000];\n\nint f(int sid, int dir) {\n\tint ret = 0;\n\tbool used[2000] = {false};\n\tint id = sid;\n\t\n\tfor (int i = 0; i < k - 1; i++) {\n\t\tused[id] = true;\n\t\t\n\t\tint next = -1;\n\t\t\n\t\tif (dir == 0) {\n\t\t\tfor (int j = 0; j < et[id].size(); j++) {\n\t\t\t\tif (!used[et[id][j]]) { next = j; break; }\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tfor (int j = (int)et[id].size() - 1; j >= 0; j--) {\n\t\t\t\tif (!used[et[id][j]]) { next = j; break; }\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (next == -1) { return -1; }\n\t\tret += ec[id][next];\n\t\tid = et[id][next];\n\t}\n\t\n\tfor (int j = 0; j < et[id].size(); j++) {\n\t\tif (et[id][j] == sid) {\n\t\t\tret += ec[id][j];\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\treturn ret;\n}\n\nsigned main() {\n\tint i, j;\n\t\n\twhile (cin >> n >> k >> s) {\n\t\tif (!n) break;\n\t\tfor (i = 0; i < n; i++) cin >> x[i] >> y[i] >> z[i];\n\t\t\n\t\tfor (i = 0; i < n; i++) { et[i].clear(); ec[i].clear(); }\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tfor (j = 0; j < n; j++) {\n\t\t\t\tif (i == j) continue;\n\t\t\t\tint sx = s - abs(x[i] - x[j]);\n\t\t\t\tint sy = s - abs(y[i] - y[j]);\n\t\t\t\tint sz = s - abs(z[i] - z[j]);\n\t\t\t\tif (sx < 0 || sy < 0 || sz < 0) continue;\n\t\t\t\tet[i].push_back(j);\n\t\t\t\tec[i].push_back(2 * (sx * sy + sy * sz + sz * sx));\n\t\t\t}\n\t\t}\n\t\t\n\t\tint maxi = -1;\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tmaxi = max(maxi, max(f(i, 0), f(i, 1)));\n\t\t}\n\t\tif (maxi == -1) { cout << -1 << endl; }\n\t\telse { cout << k * s * s * 6 - maxi << endl; }\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define sar(a,n) cout<<#a<<\":\";rep(pachico,n)cout<<\" \"<<a[pachico];cout<<endl\n#define svec(v) cout<<#v<<\":\";rep(pachico,v.size())cout<<\" \"<<v[pachico];cout<<endl\n#define svecp(v) cout<<#v<<\":\";each(pachico,v)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n#define sset(s) cout<<#s<<\":\";each(pachico,s)cout<<\" \"<<pachico;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(pachico,m)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 100005;\n\nstruct edge\n{\n    int to;\n    ll cost;\n};\n\nstruct data\n{\n    ll x,y,z;\n};\n\nvoid dfs(int u,int p,int& vc, int& ed, vector<int>& visit, vector<vector<edge> >& G, vector<int>& v)\n{\n    v.pb(u);\n    visit[u] = vc++;\n    each(e,G[u]){\n        if(visit[e.to] < 0){\n            ed++;\n            dfs(e.to,u,vc,ed,visit,G,v);\n        }else if(visit[e.to] < visit[u] && e.to != p){\n            ed++;\n        }\n    }\n}\n\nll solve(ll x,ll y,ll z)\n{\n    return 2*(x*y+y*z+z*x);\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while(1){\n        int n,K;\n        ll s;\n        cin >> n >> K >> s;\n        if(n == 0) break;\n        vector<vector<edge> > G(n);\n        vector<data> vec(n);\n        rep(i,n){\n            ll x,y,z;\n            cin >> x >> y >> z;\n            vec[i] = (data){x,y,z};\n        }\n        if(K == 1){\n            cout << 6*s*s*K << \"\\n\";\n            continue;\n        }\n        rep(i,n){\n            srep(j,i+1,n){\n                data& p = vec[i], q = vec[j];\n                if(p.x <= q.x){\n                    if(q.x < p.x+s){\n                        if(p.y <= q.y){\n                            if(q.y < p.y+s){\n                                if(p.z <= q.z){\n                                    if(q.z < p.z+s){\n                                        ll val = solve(p.x+s-q.x,p.y+s-q.y,p.z+s-q.z);\n                                        G[i].pb((edge){j,val}), G[j].pb((edge){i,val});\n                                    }\n                                }else{\n                                    if(p.z < q.z+s){\n                                        ll val = solve(p.x+s-q.x,p.y+s-q.y,q.z+s-p.z);\n                                        G[i].pb((edge){j,val}), G[j].pb((edge){i,val});\n                                    }\n                                }\n                            }\n                        }else{\n                            if(p.y < q.y+s){\n                                if(p.z <= q.z){\n                                    if(q.z < p.z+s){\n                                        ll val = solve(p.x+s-q.x,q.y+s-p.y,p.z+s-q.z);\n                                        G[i].pb((edge){j,val}), G[j].pb((edge){i,val});\n                                    }\n                                }else{\n                                    if(p.z < q.z+s){\n                                        ll val = solve(p.x+s-q.x,q.y+s-p.y,q.z+s-p.z);\n                                        G[i].pb((edge){j,val}), G[j].pb((edge){i,val});\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }else{\n                    if(p.x < q.x+s){\n                        if(p.y <= q.y){\n                            if(q.y < p.y+s){\n                                if(p.z <= q.z){\n                                    if(q.z < p.z+s){\n                                        ll val = solve(q.x+s-p.x,p.y+s-q.y,p.z+s-q.z);\n                                        G[i].pb((edge){j,val}), G[j].pb((edge){i,val});\n                                    }\n                                }else{\n                                    if(p.z < q.z+s){\n                                        ll val = solve(q.x+s-p.x,p.y+s-q.y,q.z+s-p.z);\n                                        G[i].pb((edge){j,val}), G[j].pb((edge){i,val});\n                                    }\n                                }\n                            }\n                        }else{\n                            if(p.y < q.y+s){\n                                if(p.z <= q.z){\n                                    if(q.z < p.z+s){\n                                        ll val = solve(q.x+s-p.x,q.y+s-p.y,p.z+s-q.z);\n                                        G[i].pb((edge){j,val}), G[j].pb((edge){i,val});\n                                    }\n                                }else{\n                                    if(p.z < q.z+s){\n                                        ll val = solve(q.x+s-p.x,q.y+s-p.y,q.z+s-p.z);\n                                        G[i].pb((edge){j,val}), G[j].pb((edge){i,val});\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        ll mx = -1;\n        vector<int> visit(n,-1);\n        rep(i,n){\n            if(visit[i] < 0){\n                int vc = 0, ed = 0;\n                vector<int> v;\n                dfs(i,-1,vc,ed,visit,G,v);\n                if(vc < K){\n                    continue;\n                }\n                // cout << vc << \" \" << ed << \" \" << K << \"\\n\";\n                int st = i, p = -1;\n                if(vc != ed){\n                    each(j,v){\n                        if(len(G[j]) == 1){\n                            st = j;\n                            break;\n                        }\n                    }\n                    assert(st >= 0);\n                    int cnt = 0;\n                    deque<ll> deq;\n                    ll val = 0;\n                    bool ok = true;\n                    while(ok){\n                        ok = false;\n                        cnt++;\n                        each(e,G[st]){\n                            if(e.to != p){\n                                if(cnt+1 > K){\n                                    val -= deq.front();\n                                    deq.pop_front();\n                                }\n                                deq.pb(e.cost);\n                                val += e.cost;\n                                cmx(mx,val);\n                                p = st;\n                                st = e.to;\n                                ok = true;\n                                break;\n                            }\n                        }\n                    }\n                    cmx(mx,val);\n                }else{\n                    int cnt = 0;\n                    deque<ll> deq;\n                    ll val = 0;\n                    int ad = 0;\n                    while(ad < vc){\n                        cnt++;\n                        each(e,G[st]){\n                            if(e.to != p){\n                                deq.pb(e.cost);\n                                val += e.cost;\n                                if(cnt+1 > K){\n                                    if(vc == K) cmx(mx,val);\n                                    ad++;\n                                    val -= deq.front();\n                                    deq.pop_front();\n                                }\n                                cmx(mx,val);\n                                p = st;\n                                st = e.to;\n                                break;\n                            }\n                        }\n                    }\n                    cmx(mx,val);\n                }\n            }\n        }\n        if(mx < 0){\n            cout << \"-1\\n\";\n        }else{\n            cout << 6*s*s*K - mx << \"\\n\";\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cassert>\n\nusing namespace std;\nusing ll = long long;\nconstexpr ll INF = 1LL << 50;\nll s;\n\nstruct Cube {\n    ll x;\n    ll y;\n    ll z;\n};\ninline ll connected(const Cube& c1, const Cube& c2)\n{\n    const ll dx = abs(c1.x - c2.x);\n    const ll dy = abs(c1.y - c2.y);\n    const ll dz = abs(c1.z - c2.z);\n    if (dx < s and dy < s and dz < s) {\n        return ((s - dx) * (s - dy) + (s - dy) * (s - dz) + (s - dz) * (s - dx)) * 2;\n    }\n    return 0;\n}\n\nstruct Edge {\n    int from;\n    int to;\n    ll cost;\n};\nstruct Graph {\n    Graph(const int n)\n    {\n        edge.resize(n);\n    }\n    void addEdge(const int from, const int to, const ll cost)\n    {\n        edge[from].push_back(Edge{from, to, cost});\n        edge[to].push_back(Edge{to, from, cost});\n    }\n    vector<vector<Edge>> edge;\n};\n\nint getEdge(const Graph& g, const int s, vector<bool>& visited)\n{\n    visited[s] = true;\n    int child = 0;\n    for (const auto& e : g.edge[s]) {\n        if (not visited[e.to]) {\n            return getEdge(g, e.to, visited);\n        }\n    }\n    if (child == 0) {\n        return s;\n    }\n}\nstruct Chain {\n    bool ring = false;\n    vector<ll> edges;\n};\nostream& operator<<(ostream& os, const Chain& ch)\n{\n    os << \"Ring: \" << boolalpha << ch.ring << \"\\nEdge: {\";\n    for (int i = 0; i < ch.edges.size(); i++) {\n        if (i != 0) {\n            os << \",\";\n        }\n        os << ch.edges[i];\n    }\n    os << \"}\" << endl;\n    return os;\n}\nvoid dfs(const Graph& g, const int s, const int dep, vector<bool>& visited, Chain& chain)\n{\n    visited[s] = true;\n    for (const auto& e : g.edge[s]) {\n        if (e.to == dep and chain.edges.size() >= 2) {\n            if (not chain.ring) {\n                chain.edges.push_back(e.cost);\n                chain.ring = true;\n            }\n            return;\n        }\n        if (not visited[e.to]) {\n            chain.edges.push_back(e.cost);\n            dfs(g, e.to, dep, visited, chain);\n        }\n    }\n}\n\nint main()\n{\n    while (true) {\n        int n, k;\n        cin >> n >> k >> s;\n        if (n == 0 and k == 0 and s == 0) {\n            break;\n        }\n\n        const ll whole = 6 * s * s * k;\n        vector<Cube> cube(n);\n        for (int i = 0; i < n; i++) {\n            cin >> cube[i].x >> cube[i].y >> cube[i].z;\n        }\n        if (k == 1) {\n            cout << whole << endl;\n            continue;\n        }\n\n        Graph g(n);\n        int e = 0;\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                const ll cost = connected(cube[i], cube[j]);\n                if (cost > 0) {\n                    e++;\n                    g.addEdge(i, j, cost);\n                }\n            }\n        }\n        assert(e <= n);\n        vector<bool> visited(n, false);\n        vector<Chain> chains;\n        for (int i = 0; i < n; i++) {\n            if (not visited[i]) {\n                vector<bool> visited2(n, false);\n                const int dep = getEdge(g, i, visited2);\n                Chain chain;\n                chain.ring = false;\n                dfs(g, dep, dep, visited, chain);\n                chains.push_back(chain);\n            }\n        }\n        ll mini = INF;\n        for (const auto chain : chains) {\n            const bool ring = chain.ring;\n            const vector<ll>& costs = chain.edges;\n            if (costs.size() < k) {\n                continue;\n            }\n            if (ring) {\n                ll sum = 0;\n                for (int i = 0; i < k - 1; i++) {\n                    sum += costs[i];\n                }\n                if (costs.size() == k) {\n                    sum += costs[k - 1];\n                    mini = min(mini, whole - sum);\n                } else {\n                    mini = min(mini, whole - sum);\n                    int head = 0;\n                    int tail = k - 1;\n                    for (int j = 0; j < costs.size(); j++, head++, tail++, tail = tail % costs.size()) {\n                        sum += (costs[tail] - costs[head]);\n                        mini = min(mini, whole - sum);\n                    }\n                }\n            } else {\n                ll sum = 0;\n                for (int i = 0; i < k - 1; i++) {\n                    sum += costs[i];\n                }\n                mini = min(mini, whole - sum);\n                int head = 0;\n                int tail = k - 1;\n                for (; tail < costs.size(); head++, tail++) {\n                    sum += (costs[tail] - costs[head]);\n                    mini = min(mini, whole - sum);\n                }\n            }\n        }\n        cout << ((mini == INF) ? -1 : mini) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\nusing namespace std;\n\nusing i64 = int64_t;\n\nstruct cube {\n    int x, y, z, w;\n    cube() {}\n    cube(int a, int b, int c, int d): x(a), y(b), z(c), w(d) {}\n\n    i64 area() {\n        return 6 * w * w;\n    }\n\n    i64 overlap_area(cube o) {\n        i64 ox = w - abs(x - o.x);\n        i64 oy = w - abs(y - o.y);\n        i64 oz = w - abs(z - o.z);\n\n        if (ox < 0 || oy < 0 || oz < 0) {\n            return -1;\n        }\n\n        return 2 * (ox * oy + oy * oz + oz * ox);\n    }\n};\n\nint main() {\n    int N, K, S;\n    while (true) {\n        cin >> N >> K >> S;\n        if (N == 0 && K == 0 && S == 0) break;\n\n        vector<cube> cubes;\n        vector<vector<int>> graph(N);\n\n        for (int j = 0; j < N; ++j) {\n            int x, y, z; cin >> x >> y >> z;\n            cubes.emplace_back(x, y, z, S);\n        }\n\n        for (int j = 0; j < N; ++j) {\n            for (int k = j+1; k < N; ++k) {\n                int area = cubes[j].overlap_area(cubes[k]);\n                if (area >= 0) {\n                    graph[j].push_back(k);\n                    graph[k].push_back(j);\n                }\n            }\n        }\n\n        i64 ans = -1;\n\n        vector<int> visited(N, 0);\n        for (int a = 0; a < N; ++a) {\n            if (visited[a]) continue;\n            visited[a] = 1;\n\n            bool loop = false;\n            int res = a;\n            for (int p = a, count = 1; p != -1; ++count) {\n                visited[p] = 1;\n                int np = -1;\n                for (int q: graph[p]) {\n                    if (count > 2 && q == a) {\n                        loop = true;\n                        break;\n                    }\n                    if (!visited[q]) {\n                        res = np = q;\n                        break;\n                    }\n                }\n                p = np;\n            }\n\n            vector<int> chain;\n            for (int p = res; p != -1; ) {\n                visited[p] = 1;\n                int np = -1;\n                chain.push_back(p);\n                for (int q: graph[p]) {\n                    if (chain.size() > 2 && q == res) {\n                        break; // loop\n                    }\n                    if (chain.size() <= 1 || chain[chain.size()-2] != q) {\n                        np = q;\n                        break;\n                    }\n                }\n                p = np;\n            }\n\n            if (chain.size() < K) {\n                continue;\n            }\n\n            const int L = chain.size();\n\n            i64 area = cubes[chain[0]].area();\n            if (K <= 1) {\n                ans = (ans == -1) ? area : min(ans, area);\n            }\n            for (int j = 1; j < (loop ? 2*L : L); ++j) {\n                if (j >= K) {\n                    int va = chain[(j-K)%L], vb = chain[(j-K+1)%L];\n                    area -= cubes[va].area() - cubes[va].overlap_area(cubes[vb]);\n                }\n                area += cubes[chain[j%L]].area() - cubes[chain[(j-1)%L]].overlap_area(cubes[chain[j%L]]);\n                if (loop && K == L && j == L-1) {\n                    area -= cubes[chain[0]].overlap_area(cubes[chain[L-1]]);\n                }\n                if (j+1 >= K) {\n                    ans = (ans == -1) ? area : min(ans, area);\n                }\n            }\n        }\n\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n#define REP(i, n) for (int i = 0; i < (n); i++)\n#define FOR(i, m, n) for (int i = (m); i < (n); i++)\n\nconstexpr int MAX = 3000;\nint siz[MAX], par[MAX], Rank[MAX];\n\nvoid init(int n) {\n    REP(i, n) {\n        par[i] = i;\n        Rank[i] = 0;\n        siz[i] = 1;\n    }\n}\nint find(int x) {\n    if (par[x] == x)\n        return x;\n    else {\n        return par[x] = find(par[x]);\n    }\n}\nvoid unite(int x, int y) {\n    x = find(x);\n    y = find(y);\n    if (x == y) return;\n    if (Rank[x] < Rank[y]) {\n        par[x] = y;\n        siz[x] += siz[y];\n        siz[y] = siz[x];\n    } else {\n        siz[y] += siz[x];\n        siz[x] = siz[y];\n        par[y] = x;\n        if (Rank[x] == Rank[y]) Rank[x]++;\n    }\n}\nbool same(int x, int y) { return find(x) == find(y); }\n\nint X[2020], Y[2020], Z[2020];\n\nvector<int> G[2020];\n\nint N, K, S;\n\nbool connected(int i, int j) {\n    if (abs(X[i] - X[j]) < S && abs(Y[i] - Y[j]) < S && abs(Z[i] - Z[j]) < S)\n        return true;\n    else\n        return false;\n}\n\nint over(int i, int j) {\n    int dx = S - abs(X[i] - X[j]);\n    int dy = S - abs(Y[i] - Y[j]);\n    int dz = S - abs(Z[i] - Z[j]);\n    return 2 * (dx * dy + dy * dz + dz * dx);\n}\n\nint dfs(int n, int pre, int s, int cnt, int res) {\n    if (K == 1) {\n        return 6 * S * S;\n    }\n    if (cnt == 0) {\n        int ret = 1e18;\n        for (auto v : G[n]) {\n            ret = min(ret, dfs(v, n, n, cnt + 1, 2 * 6 * S * S - over(n, v)));\n        }\n        return ret;\n    } else {\n        int ret = 1e18;\n        if (cnt == K) return res;\n        if (cnt == K - 1) {\n            if (siz[find(n)] > K || K <= 2)\n                return res;\n            else if (siz[find(n)] == K) {\n                if (connected(n, s)) {\n                    ret = min(ret, dfs(s, n, s, cnt + 1, res - over(n, s)));\n                } else\n                    ret = res;\n\n                return ret;\n            }\n        } else {\n            for (auto v : G[n]) {\n                if (v == pre) continue;\n                ret = min(ret, dfs(v, n, s, cnt + 1, res + 6 * S * S - over(n, v)));\n            }\n            return ret;\n        }\n    }\n    return 1e18;\n}\n\nbool solve() {\n    cin >> N >> K >> S;\n    if (N == 0) return false;\n    REP(i, N) {\n        G[i].clear();\n        cin >> X[i] >> Y[i] >> Z[i];\n    }\n\n    init(N);\n    REP(i, N) FOR(j, i + 1, N) {\n        if (connected(i, j)) {\n            unite(i, j);\n            G[i].push_back(j);\n            G[j].push_back(i);\n        }\n    }\n    int mx = 0;\n    REP(i, N) { mx = max(mx, siz[find(i)]); }\n    if (mx < K) {\n        cout << -1 << endl;\n        return true;\n    }\n    int ans = 1e18;\n    REP(i, N) {\n        if (siz[find(i)] >= K) {\n            ans = min(ans, dfs(i, i, i, 0, 0));\n        }\n    }\n    cout << ans << endl;\n    return true;\n}\nsigned main() {\n    // init();\n    while (solve())\n        ;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define dbg(...) do{cerr<<__LINE__<<\": \";dbgprint(#__VA_ARGS__, __VA_ARGS__);}while(0);\n\nusing namespace std;\n\nnamespace std{template<class S,class T>struct hash<pair<S,T>>{size_t operator()(const pair<S,T>&p)const{return ((size_t)1e9+7)*hash<S>()(p.first)+hash<T>()(p.second);}};template<class T>struct hash<vector<T>>{size_t operator()(const vector<T> &v)const{size_t h=0;for(auto i : v)h=h*((size_t)1e9+7)+hash<T>()(i)+1;return h;}};}\ntemplate<class T>ostream& operator<<(ostream &os, const vector<T> &v){os<<\"[ \";rep(i,v.size())os<<v[i]<<(i==v.size()-1?\" ]\":\", \");return os;}template<class T>ostream& operator<<(ostream &os,const set<T> &v){os<<\"{ \"; for(const auto &i:v)os<<i<<\", \";return os<<\"}\";}\ntemplate<class T,class U>ostream& operator<<(ostream &os,const map<T,U> &v){os<<\"{\";for(const auto &i:v)os<<\" \"<<i.first<<\": \"<<i.second<<\",\";return os<<\"}\";}template<class T,class U>ostream& operator<<(ostream &os,const pair<T,U> &p){return os<<\"(\"<<p.first<<\", \"<<p.second<<\")\";}\nvoid dbgprint(const string &fmt){cerr<<endl;}template<class H,class... T>void dbgprint(const string &fmt,const H &h,const T&... r){cerr<<fmt.substr(0,fmt.find(\",\"))<<\"= \"<<h<<\" \";dbgprint(fmt.substr(fmt.find(\",\")+1),r...);}\ntypedef long long ll;typedef vector<int> vi;typedef pair<int,int> pi;const int inf = (int)1e9;const double INF = 1e12, EPS = 1e-9;\n\nint main(){\n\tcin.tie(0); cin.sync_with_stdio(0);\n\tint n, k, s;\n\twhile(cin >> n >> k >> s, n){\n\t\tvi x(n), y(n), z(n);\n\t\trep(i, n) cin >> x[i] >> y[i] >> z[i];\n\t\t\n\t\tauto intersect = [&](int i, int j){\n\t\t\tll dx = s - abs(x[i] - x[j]);\n\t\t\tll dy = s - abs(y[i] - y[j]);\n\t\t\tll dz = s - abs(z[i] - z[j]);\n\t\t\tif(dx <= 0 || dy <= 0 || dz <= 0) return 0ll;\n\t\t\treturn (dx * dy + dy * dz + dz * dx) * 2;\n\t\t};\n\t\t\n\t\tvector<vi> e(n);\n\t\trep(i, n) rep(j, i) if(intersect(i, j)){\n\t\t\te[i].pb(j);\n\t\t\te[j].pb(i);\n\t\t\t//dbg(i, j);\n\t\t}\n\t\t\n\t\tfunction<bool(int,int,vector<bool>&,vi&)> rec = [&](int c, int p, vector<bool> &v, vi &idx){\n\t\t\tv[c] = 1;\n\t\t\tidx.pb(c);\n\t\t\tfor(int i : e[c]) if(i != p){\n\t\t\t\tif(v[i]) return true;\n\t\t\t\treturn (bool)rec(i, c, v, idx); \n\t\t\t}\n\t\t\treturn false;\n\t\t};\n\t\t\n\t\tll ans = 1e18;\n\t\tvector<bool> v(n);\n\t\trep(ii, n) if(!v[ii]){\n\t\t\tvi idx;\n\t\t\tbool loop = rec(ii, ii, v, idx);\n\t\t\tif(idx.size() < k) continue;\n\t\t\t\n\t\t\tif(loop && idx.size() == k){\n\t\t\t\tll sum = 6ll * k * s * s;\n\t\t\t\trep(i, (int)idx.size()){\n\t\t\t\t\tll c = intersect(idx[i], idx[(i + 1) % idx.size()]);\n\t\t\t\t\tsum -= c;\n\t\t\t\t}\n\t\t\t\tans = min(ans, sum);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tvector<ll> costs;\n\t\t\t\tif(loop){\n\t\t\t\t\trep(i, (int)idx.size())\n\t\t\t\t\t\tcosts.pb(intersect(idx[i], idx[(i + 1) % idx.size()]));\n\t\t\t\t\tint it = idx.size();\n\t\t\t\t\trep(i, it) idx.pb(idx[i]);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tint hasi = 0;\n\t\t\t\t\trep(i, idx.size()) if(e[idx[i]].size() == 1) hasi = idx[i];\n\t\t\t\t\tfor(int i : idx) v[i] = 0;\n\t\t\t\t\tidx.clear();\n\t\t\t\t\trec(hasi, hasi, v, idx);\n\t\t\t\t\t\n\t\t\t\t\trep(i, (int)idx.size()-1)\n\t\t\t\t\t\tcosts.pb(intersect(idx[i], idx[i + 1]));\n\t\t\t\t\t\n\t\t\t\t\trep(i, idx.size()){\n\t\t\t\t\t\t//if(i==0 || i==idx.size()-1) assert(e[idx[i]].size() <= 1);\n\t\t\t\t\t\t//else assert(e[idx[i]].size()==2);\n\t\t\t\t\t\tassert(e[idx[i]].size() <= 2);\n\t\t\t\t\t\tassert(e[idx[i]].size() >= 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//dbg(k, costs);\n\t\t\t\t\n\t\t\t\tll sum = 6ll * k * s * s;\n\t\t\t\tif(k == 1){\n\t\t\t\t\tans = min(ans, sum);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\trep(i, k-2) sum -= costs[i];\n\t\t\t\trep(i, (int)costs.size() - (k-1) + 1){\n\t\t\t\t\tsum -= costs[i + k-2];\n\t\t\t\t\tans = min(ans, sum);\n\t\t\t\t\tsum += costs[i];\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tif(ans >= 1e18) ans = -1;\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<deque>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<set>\n#include<cmath>\n#include<tuple>\n#include<string>\n#include<chrono>\n#include<functional>\n#include<iterator>\n#include<random>\n#include<unordered_set>\n#include<array>\n#include<map>\n#include<iomanip>\n#include<assert.h>\n#include<bitset>\n#include<stack>\n#include<memory>\nusing namespace std;\nusing namespace std::chrono;\ntypedef long long int llint;\ntypedef double lldo;\n#define mp make_pair\n#define mt make_tuple\n#define pub push_back\n#define puf push_front\n#define pob pop_back\n#define pof pop_front\n#define fir first\n#define sec second\n#define res resize\n#define ins insert\n#define era erase\n/*cout<<fixed<<setprecision(20);cin.tie(0);ios::sync_with_stdio(false);*/\nconst llint mod=998244353;\nconst llint big=2.19e17+1;\nconst long double pai=3.141592653589793238462643383279502884197;\nconst long double eps=1e-15;\ntemplate <class T,class U>bool mineq(T& a,U b){if(a>b){a=b;return true;}return false;}\ntemplate <class T,class U>bool maxeq(T& a,U b){if(a<b){a=b;return true;}return false;}\nllint gcd(llint a,llint b){if(a%b==0){return b;}else return gcd(b,a%b);}\nllint lcm(llint a,llint b){if(a==0){return b;}return a/gcd(a,b)*b;}\ntemplate<class T> void SO(T& ve){sort(ve.begin(),ve.end());}\ntemplate<class T> void REV(T& ve){reverse(ve.begin(),ve.end());}\ntemplate<class T>llint LBI(vector<T>&ar,T in){return lower_bound(ar.begin(),ar.end(),in)-ar.begin();}\ntemplate<class T>llint UBI(vector<T>&ar,T in){return upper_bound(ar.begin(),ar.end(),in)-ar.begin();}\n//  17:50-\n//A 17:54 AC\n//B 17:58 AC\n//C 18:05 AC\n//D 18:23 AC\n\n/*\n\n*/\nbool solve(void){\n\tint n,i,j,k,s;cin>>n>>k>>s;\n\tif(n==0){return false;}\n\tvector<tuple<int,int,int>>zaa(n);\n\tfor(i=0;i<n;i++){cin>>get<0>(zaa[i])>>get<1>(zaa[i])>>get<2>(zaa[i]);}\n\tif(k==1){cout<<s*s*6<<endl;return true;}\n\tvector<vector<int>>hen(n,vector<int>(n));\n\tvector<vector<int>>go(n);\n\tfor(i=0;i<n;i++){\n\t\tfor(j=i+1;j<n;j++){\n\t\t\t\n\t\t\tint xa,ya,za;tie(xa,ya,za)=zaa[i];\n\t\t\tint xb,yb,zb;tie(xb,yb,zb)=zaa[j];\n\t\t\t\n\t\t\tint xr=s-abs(xa-xb),yr=s-abs(ya-yb),zr=s-abs(za-zb);\n\t\t\tif(xr<0||yr<0||zr<0){continue;}\n\t\t\then[i][j]=(xr*yr+yr*zr+zr*xr)*2;\n\t\t\then[j][i]=(xr*yr+yr*zr+zr*xr)*2;\n\t\t\tgo[i].pub(j);go[j].pub(i);\n\t\t}\n\t}\n\tint ans=mod;\n\t//線 か ドーナツ\n\tfor(i=0;i<n;i++){\n\t\tfor(auto sta:go[i]){\n\t\t\tint mae=i,now=sta,mta=2,gen=s*s*12-hen[i][sta];\n\t\t\twhile(mta<k){\n\t\t\t\tif(go[now].size()<2){break;}\n\t\t\t\tint aa=now;\n\t\t\t\tnow=go[now][0]+go[now][1]-mae;\n\t\t\t\tmae=aa;\n\t\t\t\tgen+=s*s*6-hen[now][mae];\n\t\t\t\tmta++;\n\t\t\t}\n\t\t\tif(mta<k){continue;}\n\t\t\tif(go[now].size()==2&&go[now][0]+go[now][1]-mae==i){gen-=hen[now][i];}\n\t\t\tmineq(ans,gen);\n\t\t}\n\t}\n\tif(ans==mod){ans=-1;}\n\tcout<<ans<<endl;\n\treturn true;\n}\nint main(void){\n\twhile(solve()){}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <array>\n#include <cassert>\n#include <climits>\n#include <complex>\n#include <cstdio>\n#include <cstring>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <iterator>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <string>\n#include <tuple>\n#include <vector>\n\nusing namespace std;\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define ALL(x) (x).begin(), (x).end()\n\nint subcube(int len, int x0, int y0, int z0, int x1, int y1, int z1) {\n    int dx = x0 - x1, dy = y0 - y1, dz = z0 - z1;\n    int sx = max(min(len + dx, len - dx), 0);\n    int sy = max(min(len + dy, len - dy), 0);\n    int sz = max(min(len + dz, len - dz), 0);\n    return (sx * sy * sz == 0) ? 0 : 2 * (sx * sy + sy * sz + sz * sx);\n}\n\nint main(){\n    int n, k, s; \n    while(cin >> n >> k >> s, n != 0){\n    vector<int> xs(n), ys(n), zs(n);\n    REP(i, n) {\n        cin >> xs[i] >> ys[i] >> zs[i];\n    }\n\n    vector<vector<int>> subc(n, vector<int>(n));\n    REP(a, n) {\n        REP(b, n) {\n            if (a == b) continue;\n            subc[a][b] = subcube(s, xs[a], ys[a], zs[a], xs[b], ys[b], zs[b]);\n            //cout << subc[a][b] << \"\\t\";\n        }\n        //cout << endl;\n    }\n\n    vector<vector<int>> segs;\n    vector<int> used(n, false);\n\n    REP(a, n){\n        if (used[a]) continue;\n        vector<int> seg;\n        int p = a; bool ok = true, loop = false;\n        seg.push_back(p);\n        used[a] = true;\n        while(ok) {\n            ok = false;\n            REP(b, n) {\n                if (subc[p][b] > 0) {\n                    if (a == p) loop = true;\n                    if (used[b]) continue;\n                    p = b;\n                    seg.push_back(p);\n                    used[b] = true;\n                    ok = true;\n                    break;\n                }\n            }\n        }\n        reverse(ALL(seg));\n        if (!loop) {\n            p = a;\n            while(ok) {\n                ok = false;\n                REP(b, n) {\n                    if (subc[p][b] > 0) {\n                        if (used[b]) continue;\n                        p = b;\n                        seg.push_back(p);\n                        used[b] = true;\n                        ok = true;\n                        break;\n                    }\n                }\n            }\n        }\n        segs.push_back(seg);\n    }\n\n    int res = -1;\n    REP(i, segs.size()) {\n        const vector<int> seg(segs[i]);\n        /*\n        cout << \"# \"; REP(a, seg.size()) {\n            cout << seg[a] << \" \";\n        } cout << endl;\n        */\n        const int l = seg.size();\n        if (l < k) { continue; }\n        if (l == k) {\n            int sum = 0;\n            if (l == 1) {\n                res = max(res, 0);\n                continue;\n            }\n            if (l == 2) {\n                res = max(res, subc[seg[0]][seg[1]]);\n                continue;\n            }\n            REP(a, l) {\n                //cout << \"+=\" << seg[a] << \" \" << seg[(a+1)%l] << endl;\n                //cout << \"   : \" << subc[seg[a]][seg[(a+1)%l]] << endl;\n                sum += subc[seg[a]][seg[(a+1)%l]];\n            }\n            res = max(res, sum);\n            continue;\n        }\n        int sum = 0;\n        REP(a, k - 1) {\n            sum += subc[seg[a]][seg[a+1]];\n        }\n        REP(a, l) {\n            sum += subc[seg[(a + k - 1) % l]][seg[(a + k) % l]];\n            sum -= subc[seg[(a % l)]][seg[(a + 1) % l]];\n            res = max(res, sum);\n        }\n    }\n\n    // cout << \"$\" << subc[0][1] << endl;\n    // cout << res << endl;\n    if (res < 0) cout << res << endl;\n    else cout << s * s * 6 * k - res << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;++i)\nstruct edge{int to,cost;};\nvector<vector<edge>> G;\n\nint dfs(int v,int p,int s,int k) {\n\tint res=INT_MIN;\n\tfor(auto e:G[v])if(e.to!=p){\n\t\tif(k>0 && e.to!=s) res=max(res,dfs(e.to,v,s,k-1)+e.cost);\n\t\tif(k==0 && e.to==s) return e.cost;\t//k-ring\n\t}\n\treturn (k==0 ? 0 : res);\n}\n\nint main(){\n\tint n,k,s;\n\twhile(cin>>n>>k>>s,n|k|s){\n\t\tvector<int> x(n),y(n),z(n);\n\t\trep(i,n) cin>>x[i]>>y[i]>>z[i];\n\t\tG.clear(), G.resize(n);\n\t\trep(i,n)rep(j,n)if(i!=j){\n\t\t\tint sx = s-abs(x[i]-x[j]);\n\t\t\tint sy = s-abs(y[i]-y[j]);\n\t\t\tint sz = s-abs(z[i]-z[j]);\n\t\t\tif(min({sx,sy,sz})>0){\n\t\t\t\tG[i].push_back({j,2*(sx*sy+sy*sz+sz*sx)});\n\t\t\t}\n\t\t}\n\t\tint res=-1;\n\t\trep(i,n) res=max(res,dfs(i,-1,i,k-1));\n\t\tcout<<(res>=0 ? s*s*6*k-res : -1)<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\nconst int INF = 1LL << 58;\n\nstruct edge\n{\n  int to, cost;\n};\n\nsigned main()\n{\n  int N, K, S;\n  int X[2000], Y[2000], Z[2000];\n\n  while(cin >> N >> K >> S, N) {\n    for(int i = 0; i < N; i++) {\n      cin >> X[i] >> Y[i] >> Z[i];\n    }\n\n    vector< edge > g[2000];\n    for(int i = 0; i < N; i++) {\n      for(int j = 0; j < i; j++) {\n        int latte = max(0LL, S - abs(X[i] - X[j]));\n        int malta = max(0LL, S - abs(Y[i] - Y[j]));\n        int beeet = max(0LL, S - abs(Z[i] - Z[j]));\n        int ukuku = latte * malta + malta * beeet + beeet * latte;\n        if(latte > 0 && malta > 0 && beeet > 0) {\n          g[i].emplace_back((edge) {j, ukuku});\n          g[j].emplace_back((edge) {i, ukuku});\n        }\n      }\n    }\n\n    int ret = -1;\n    for(int i = 0; i < N; i++) {\n      bool v[2000] = {};\n      function< void(int, int, int, int) > dfs = [&](int idx, int k, int sz, int par = -1)\n      {\n        if(v[idx]++) return;\n        if(k == 0) {\n          for(auto &e: g[idx]) if(e.to != par && v[e.to]) sz += e.cost;\n          ret = max(ret, sz);\n        } else {\n          for(auto &e : g[idx]) dfs(e.to, k - 1, sz + e.cost, idx);\n        }\n      };\n      dfs(i, K - 1, 0, -1);\n    }\n    if(ret == -1) cout << -1 << endl;\n    else cout << 6 * S * S * K - ret * 2 << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cassert>\n\nusing namespace std;\nusing ll = long long;\nconstexpr ll INF = 1LL << 50;\nll s;\n\nstruct Cube {\n    ll x;\n    ll y;\n    ll z;\n};\ninline ll connected(const Cube& c1, const Cube& c2)\n{\n    const ll dx = abs(c1.x - c2.x);\n    const ll dy = abs(c1.y - c2.y);\n    const ll dz = abs(c1.z - c2.z);\n    if (dx < s and dy < s and dz < s) {\n        return ((s - dx) * (s - dy) + (s - dy) * (s - dz) + (s - dz) * (s - dx)) * 2;\n    }\n    return 0;\n}\n\nstruct Edge {\n    int from;\n    int to;\n    ll cost;\n};\nstruct Graph {\n    Graph(const int n)\n    {\n        edge.resize(n);\n    }\n    void addEdge(const int from, const int to, const ll cost)\n    {\n        edge[from].push_back(Edge{from, to, cost});\n        edge[to].push_back(Edge{to, from, cost});\n    }\n    vector<vector<Edge>> edge;\n};\n\nint getEdge(const Graph& g, const int s, vector<bool>& visited)\n{\n    visited[s] = true;\n    int child = 0;\n    for (const auto& e : g.edge[s]) {\n        if (not visited[e.to]) {\n            return getEdge(g, e.to, visited);\n        }\n    }\n    if (child == 0) {\n        return s;\n    }\n}\nstruct Chain {\n    bool ring = false;\n    vector<ll> edges;\n};\nostream& operator<<(ostream& os, const Chain& ch)\n{\n    os << \"Ring: \" << boolalpha << ch.ring << \"\\nEdge: {\";\n    for (int i = 0; i < ch.edges.size(); i++) {\n        if (i != 0) {\n            os << \",\";\n        }\n        os << ch.edges[i];\n    }\n    os << \"}\" << endl;\n    return os;\n}\nvoid dfs(const Graph& g, const int s, const int dep, vector<bool>& visited, Chain& chain)\n{\n    visited[s] = true;\n    for (const auto& e : g.edge[s]) {\n        if (not visited[e.to]) {\n            chain.edges.push_back(e.cost);\n            dfs(g, e.to, dep, visited, chain);\n        }\n    }\n}\n\nint main()\n{\n    while (true) {\n        int n, k;\n        cin >> n >> k >> s;\n        if (n == 0 and k == 0 and s == 0) {\n            break;\n        }\n\n        const ll whole = 6 * s * s * k;\n        vector<Cube> cube(n);\n        for (int i = 0; i < n; i++) {\n            cin >> cube[i].x >> cube[i].y >> cube[i].z;\n        }\n        if (k == 1) {\n            cout << whole << endl;\n            continue;\n        }\n\n        Graph g(n);\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                const ll cost = connected(cube[i], cube[j]);\n                if (cost > 0) {\n                    g.addEdge(i, j, cost);\n                }\n            }\n        }\n        vector<bool> visited(n, false);\n        vector<Chain> chains;\n        for (int i = 0; i < n; i++) {\n            if (not visited[i]) {\n                vector<bool> visited2(n, false);\n                const int dep = getEdge(g, i, visited2);\n                Chain chain;\n                chain.ring = g.edge[dep].size() == 2;\n                if (chain.ring) {\n                    chain.edges.push_back(g.edge[dep][1].cost);\n                }\n                dfs(g, dep, dep, visited, chain);\n                chains.push_back(chain);\n            }\n        }\n        ll mini = INF;\n        for (const auto chain : chains) {\n            const bool ring = chain.ring;\n            const vector<ll>& costs = chain.edges;\n            if (costs.size() < k - 1) {\n                continue;\n            }\n            if (ring) {\n                ll sum = 0;\n                for (int i = 0; i < k - 1; i++) {\n                    sum += costs[i];\n                }\n                if (costs.size() == k) {\n                    sum += costs[k - 1];\n                    mini = min(mini, whole - sum);\n                } else {\n                    mini = min(mini, whole - sum);\n                    int head = 0;\n                    int tail = k - 1;\n                    for (int j = 0; j < costs.size(); j++, head++, tail++, tail = tail % costs.size()) {\n                        sum += (costs[tail] - costs[head]);\n                        mini = min(mini, whole - sum);\n                    }\n                }\n            } else {\n                ll sum = 0;\n                for (int i = 0; i < k - 1; i++) {\n                    sum += costs[i];\n                }\n                mini = min(mini, whole - sum);\n                int head = 0;\n                int tail = k - 1;\n                for (; tail < costs.size(); head++, tail++) {\n                    sum += (costs[tail] - costs[head]);\n                    mini = min(mini, whole - sum);\n                }\n            }\n        }\n        cout << ((mini == INF) ? -1 : mini) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cassert>\n\nusing namespace std;\nusing ll = long long;\nconstexpr ll INF = 1LL << 50;\nll s;\n\nstruct Cube {\n    ll x;\n    ll y;\n    ll z;\n};\ninline ll connected(const Cube& c1, const Cube& c2)\n{\n    const ll dx = abs(c1.x - c2.x);\n    const ll dy = abs(c1.y - c2.y);\n    const ll dz = abs(c1.z - c2.z);\n    if (dx < s and dy < s and dz < s) {\n        return ((s - dx) * (s - dy) + (s - dy) * (s - dz) + (s - dz) * (s - dx)) * 2;\n    }\n    return 0;\n}\n\nstruct Edge {\n    int from;\n    int to;\n    ll cost;\n};\nstruct Graph {\n    Graph(const int n)\n    {\n        edge.resize(n);\n    }\n    void addEdge(const int from, const int to, const ll cost)\n    {\n        edge[from].push_back(Edge{from, to, cost});\n        edge[to].push_back(Edge{to, from, cost});\n    }\n    vector<vector<Edge>> edge;\n};\n\nint getEdge(const Graph& g, const int s, vector<bool>& visited)\n{\n    visited[s] = true;\n    int child = 0;\n    for (const auto& e : g.edge[s]) {\n        if (not visited[e.to]) {\n            return getEdge(g, e.to, visited);\n        }\n    }\n    if (child == 0) {\n        return s;\n    }\n}\nstruct Chain {\n    bool ring = false;\n    vector<ll> edges;\n};\nostream& operator<<(ostream& os, const Chain& ch)\n{\n    os << \"Ring: \" << boolalpha << ch.ring << \"\\nEdge: {\";\n    for (int i = 0; i < ch.edges.size(); i++) {\n        if (i != 0) {\n            os << \",\";\n        }\n        os << ch.edges[i];\n    }\n    os << \"}\" << endl;\n    return os;\n}\nvoid dfs(const Graph& g, const int s, const int dep, vector<bool>& visited, Chain& chain)\n{\n    visited[s] = true;\n    for (const auto& e : g.edge[s]) {\n        if (e.to == dep and chain.edges.size() >= 2) {\n            if (not chain.ring) {\n                chain.edges.push_back(e.cost);\n                chain.ring = true;\n            }\n            return;\n        }\n        if (not visited[e.to]) {\n            chain.edges.push_back(e.cost);\n            dfs(g, e.to, dep, visited, chain);\n        }\n    }\n}\n\nint main()\n{\n    while (true) {\n        int n, k;\n        cin >> n >> k >> s;\n        if (n == 0 and k == 0 and s == 0) {\n            break;\n        }\n\n        const ll whole = 6 * s * s * k;\n        vector<Cube> cube(n);\n        for (int i = 0; i < n; i++) {\n            cin >> cube[i].x >> cube[i].y >> cube[i].z;\n        }\n        if (k == 1) {\n            cout << whole << endl;\n            continue;\n        }\n\n        Graph g(n);\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                const ll cost = connected(cube[i], cube[j]);\n                if (cost > 0) {\n                    g.addEdge(i, j, cost);\n                }\n            }\n        }\n        vector<bool> visited(n, false);\n        vector<Chain> chains;\n        for (int i = 0; i < n; i++) {\n            if (not visited[i]) {\n                vector<bool> visited2(n, false);\n                const int dep = getEdge(g, i, visited2);\n                Chain chain;\n                chain.ring = false;\n                dfs(g, dep, dep, visited, chain);\n                chains.push_back(chain);\n            }\n        }\n        ll mini = INF;\n        for (const auto chain : chains) {\n            const bool ring = chain.ring;\n            const vector<ll>& costs = chain.edges;\n            if (costs.size() < k) {\n                continue;\n            }\n            if (ring) {\n                ll sum = 0;\n                for (int i = 0; i < k - 1; i++) {\n                    sum += costs[i];\n                }\n                if (costs.size() == k) {\n                    sum += costs[k - 1];\n                    mini = min(mini, whole - sum);\n                } else {\n                    mini = min(mini, whole - sum);\n                    int head = 0;\n                    int tail = k - 1;\n                    for (int j = 0; j < costs.size(); j++, head++, tail++, tail = tail % costs.size()) {\n                        sum += (costs[tail] - costs[head]);\n                        mini = min(mini, whole - sum);\n                    }\n                }\n            } else {\n                ll sum = 0;\n                for (int i = 0; i < k - 1; i++) {\n                    sum += costs[i];\n                }\n                mini = min(mini, whole - sum);\n                int head = 0;\n                int tail = k - 1;\n                for (; tail < costs.size(); head++, tail++) {\n                    sum += (costs[tail] - costs[head]);\n                    mini = min(mini, whole - sum);\n                }\n            }\n        }\n        cout << ((mini == INF) ? -1 : mini) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//c++ -std=gnu++14 a.cpp\n#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\n#include <tuple>\n#include <iomanip>\n#include <climits>\n#include <fstream>\nusing namespace std;\n\ntypedef long long ll;\n\nconst int INF = 1<<30;\nconst ll INFL = 1LL<<60;\n#define rep(i, n) for(int i = 0; i < (n); i++)\n\nint N, K, S;\nint x[2010], y[2010], z[2010];\n\nint atari(int i, int j){\n  return abs(x[i] - x[j]) < S && abs(y[i] - y[j]) < S && abs(z[i] - z[j]) < S;\n}\n\nint inter(int i, int j){\n  if(!atari(i, j)) return -1;\n  int X = S - abs(x[i] - x[j]);\n  int Y = S - abs(y[i] - y[j]);\n  int Z = S - abs(z[i] - z[j]);\n  return 2 * (X*Y+Y*Z+Z*X);\n}\n\nstruct edge{int to, cost;};\nvector<edge> E[2010];\nint used[2010];\nvector<int> xs;\nvoid dfs(int now){\n  if(used[now]) return;\n  xs.push_back(now);\n  used[now] = 1;\n  for(edge e: E[now]){\n    dfs(e.to);\n  }\n}\nint sub(){\n  int res = 0;\n  //xsでなんかやる\n  int v = xs.size();\n  int e = 0;\n  rep(i, v) e += E[xs[i]].size();\n  e /= 2;\n  if(v == e){//円\n    if(v == K){//全て使う\n      int sum = 0;\n      rep(i, v) for(edge e: E[xs[i]])if(xs[i] > e.to) sum += e.cost;\n      res = sum;\n    }else{//一部だけ使う\n      int now = xs[0], from = -1;\n      int ne;\n      vector<int> costs;\n      rep(_, v){\n        for(edge nv: E[now])if(nv.to != from){\n          ne = nv.to;\n          costs.push_back(nv.cost);\n        }\n        from = now;\n        now = ne;\n        ne = -1;\n      }\n      int sum = 0;\n      rep(i, K-1){\n        sum += costs[i];\n      }\n      res = sum;\n      rep(i, v){\n        sum += costs[(i+K-1)%v] - costs[i];\n        res = max(res, sum);\n      }\n    }\n  }else{//直線\n    int s = -1;\n    rep(i, v)if(E[xs[i]].size() == 1) s = xs[i];\n    int now = s, from = -1;\n    int ne;\n    vector<int> costs;\n    rep(_, v-1){\n      for(edge nv: E[now])if(nv.to != from){\n        ne = nv.to;\n        costs.push_back(nv.cost);\n      }\n      from = now;\n      now = ne;\n      ne = -1;\n    }\n    int sum = 0;\n    rep(i, K-1){\n      sum += costs[i];\n    }\n    res = sum;\n    for(int i = K-1; i < costs.size(); i++){\n      sum += costs[i] - costs[i-K+1];\n      res = max(res, sum);\n    }\n  }\n  return res;\n}\n\nvoid solve(){\n  rep(i, N)rep(j, N)if(i != j){\n    int m = inter(i, j);\n    if(m != -1){\n      E[i].push_back({j, m});\n    }\n  }\n  int ans = -INF;\n  rep(i, N){\n    if(used[i]) continue;\n    xs.resize(0);\n    dfs(i);\n    if((int)xs.size() < K) continue;\n    ans = max(ans, sub());\n  }\n  if(ans == -INF) cout << -1 << endl;\n  else cout << S * S * 6 * K - ans << endl;\n}\n\n\nint main(){\n  while(true){\n    cin >> N >> K >> S;\n    if(N + K + S == 0) return 0;\n    rep(i, N) cin >> x[i] >> y[i] >> z[i];\n    solve();\n    rep(i, N) used[i] = 0;\n    rep(i, N) E[i].resize(0);\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\n\nstruct Cube {\n    Cube() = default;\n    Cube(ll x, ll y, ll z, ll size) : x{x}, y{y}, z{z}, size{size}\n    {\n    }\n\n    bool operator<(const Cube& c) const\n    {\n        return (x != c.x) ? (x < c.x) : (y != c.y) ? (y < c.y) : (z != c.z) ? (z < c.z) : true;\n    }\n    ll x;\n    ll y;\n    ll z;\n    ll size;\n};\n\nll intersection(const Cube& c1, const Cube& c2)\n{\n\n    ll x = min(c1.x, c2.x) - max(c1.x, c2.x) + c1.size;\n    if (x <= 0) {\n        return 0;\n    }\n    ll y = min(c1.y, c2.y) - max(c1.y, c2.y) + c1.size;\n    if (y <= 0) {\n        return 0;\n    }\n    ll z = min(c1.z, c2.z) - max(c1.z, c2.z) + c1.size;\n    if (z <= 0) {\n        return 0;\n    }\n    return 2 * ((x * y) + (y * z) + (z * x));\n}\n\nstruct Edge {\n    Edge() = default;\n    Edge(int f, int t, ll c) : from{f}, to{t}, cost{c}\n    {\n    }\n    int from;\n    int to;\n    ll cost;\n};\n\nstruct Graph {\n    Graph(int n)\n    {\n        edge.resize(n);\n    }\n    void addEdge(int from, int to, ll cost)\n    {\n        edge[to].push_back(Edge{to, from, cost});\n        edge[from].push_back(Edge{from, to, cost});\n    }\n    vector<vector<Edge>> edge;\n};\n\nvoid dfs(const Graph& g, vector<bool>& checked, int pos, int& num, bool& ring, int& representation)\n{\n    num++;\n    checked[pos] = true;\n    bool update = false;\n    for (const auto& e : g.edge[pos]) {\n        const int to = e.to;\n        if (not checked[to]) {\n            dfs(g, checked, to, num, ring, representation);\n            update = true;\n        }\n    }\n    if (not update) {\n        if (g.edge[pos].size() == 2) {\n            ring = true;\n        } else {\n            ring = false;\n        }\n        representation = pos;\n    }\n}\n\nint main()\n{\n\n    while (true) {\n        int n, k;\n        ll s;\n        cin >> n >> k >> s;\n        if (n == 0 and k == 0 and s == 0) {\n            break;\n        }\n        vector<Cube> cubes(n);\n        for (int i = 0; i < n; i++) {\n            ll x, y, z;\n            cin >> x >> y >> z;\n            cubes[i] = Cube{x, y, z, s};\n        }\n        Graph g{n};\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                ll inter = intersection(cubes[i], cubes[j]);\n                if (inter > 0) {\n                    g.addEdge(i, j, inter);\n                }\n            }\n        }\n\n        vector<bool> checked(n, false);\n        vector<pair<pair<int, int>, bool>> cc;\n        for (int i = 0; i < n; i++) {\n            if (not checked[i]) {\n                int num = 0;\n                bool ring = false;\n                int rep;\n                dfs(g, checked, i, num, ring, rep);\n                if (num >= k) {\n                    cc.push_back(make_pair(make_pair(rep, num), ring));\n                }\n            }\n        }\n\n        if (cc.empty()) {\n            cout << -1 << endl;\n            continue;\n        }\n\n        ll maxi = -1;\n        vector<bool> used_head(n, false);\n        vector<bool> used_tail(n, false);\n        for (const auto p : cc) {\n            int rep = p.first.first;\n            int num = p.first.second;\n            bool ring = p.second;\n            if (ring) {\n                int head = rep;\n                int tail = rep;\n                ll sum = 0;\n                for (int i = 0; i < k - 1; i++) {\n                    used_tail[tail] = true;\n                    for (const auto& e : g.edge[tail]) {\n                        if (not used_tail[e.to]) {\n                            tail = e.to;\n                            sum += e.cost;\n                            break;\n                        }\n                    }\n                }\n                if (k == num) {\n                    used_tail[head] = false;\n                    for (const auto& e : g.edge[tail]) {\n                        if (not used_tail[e.to]) {\n                            sum += e.cost;\n                            break;\n                        }\n                    }\n                    maxi = max(maxi, sum);\n                    continue;\n                }\n                maxi = max(maxi, sum);\n                for (int i = 0; i < num; i++) {\n                    used_head[head] = true;\n                    used_tail[tail] = true;\n                    for (const auto& e : g.edge[head]) {\n                        if (not used_head[e.to]) {\n                            head = e.to;\n                            sum -= e.cost;\n                            break;\n                        }\n                    }\n                    for (const auto& e : g.edge[tail]) {\n                        if (not used_tail[e.to]) {\n                            tail = e.to;\n                            sum += e.cost;\n                            break;\n                        }\n                    }\n                    maxi = max(maxi, sum);\n                }\n            } else {\n                int head = rep;\n                int tail = rep;\n                ll sum = 0;\n                for (int i = 0; i < k - 1; i++) {\n                    used_tail[tail] = false;\n                    for (const auto& e : g.edge[tail]) {\n                        if (not used_tail[e.to]) {\n                            tail = e.to;\n                            sum += e.cost;\n                            break;\n                        }\n                    }\n                }\n                maxi = max(maxi, sum);\n                for (int i = 0; i < num - k + 1; i++) {\n                    used_head[head] = true;\n                    used_tail[tail] = true;\n                    for (const auto& e : g.edge[head]) {\n                        if (not used_head[e.to]) {\n                            head = e.to;\n                            sum -= e.cost;\n                            break;\n                        }\n                    }\n                    for (const auto& e : g.edge[tail]) {\n                        if (not used_tail[e.to]) {\n                            tail = e.to;\n                            sum += e.cost;\n                            break;\n                        }\n                    }\n                    maxi = max(maxi, sum);\n                }\n            }\n        }\n        cout << (6 * s * s) * static_cast<ll>(k) - maxi << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define dbg(...) do{cerr<<__LINE__<<\": \";dbgprint(#__VA_ARGS__, __VA_ARGS__);}while(0);\n\nusing namespace std;\n\nnamespace std{template<class S,class T>struct hash<pair<S,T>>{size_t operator()(const pair<S,T>&p)const{return ((size_t)1e9+7)*hash<S>()(p.first)+hash<T>()(p.second);}};template<class T>struct hash<vector<T>>{size_t operator()(const vector<T> &v)const{size_t h=0;for(auto i : v)h=h*((size_t)1e9+7)+hash<T>()(i)+1;return h;}};}\ntemplate<class T>ostream& operator<<(ostream &os, const vector<T> &v){os<<\"[ \";rep(i,v.size())os<<v[i]<<(i==v.size()-1?\" ]\":\", \");return os;}template<class T>ostream& operator<<(ostream &os,const set<T> &v){os<<\"{ \"; for(const auto &i:v)os<<i<<\", \";return os<<\"}\";}\ntemplate<class T,class U>ostream& operator<<(ostream &os,const map<T,U> &v){os<<\"{\";for(const auto &i:v)os<<\" \"<<i.first<<\": \"<<i.second<<\",\";return os<<\"}\";}template<class T,class U>ostream& operator<<(ostream &os,const pair<T,U> &p){return os<<\"(\"<<p.first<<\", \"<<p.second<<\")\";}\nvoid dbgprint(const string &fmt){cerr<<endl;}template<class H,class... T>void dbgprint(const string &fmt,const H &h,const T&... r){cerr<<fmt.substr(0,fmt.find(\",\"))<<\"= \"<<h<<\" \";dbgprint(fmt.substr(fmt.find(\",\")+1),r...);}\ntypedef long long ll;typedef vector<int> vi;typedef pair<int,int> pi;const int inf = (int)1e9;const double INF = 1e12, EPS = 1e-9;\n\nvector<vector<pi>> build_graph(int n, vi &x, vi &y, vi &z, int s){\n\tvector<vector<pi>> e(n);\n\tauto is = [&](int i, int j){\n\t\tint dx = s - abs(x[i] - x[j]);\n\t\tint dy = s - abs(y[i] - y[j]);\n\t\tint dz = s - abs(z[i] - z[j]);\n\t\tif(dx <= 0 || dy <= 0 || dz <= 0) return 0;\n\t\treturn 2 * (dx * dy + dy * dz + dz * dx);\n\t};\n\trep(i, n) rep(j, i){\n\t\tint x = is(i, j);\n\t\tif(!x) continue;\n\t\te[i].emplace_back(j, x);\n\t\te[j].emplace_back(i, x);\n\t\t//dbg(i, j, x);\n\t}\n\treturn e;\n}\nvector<pair<bool, vi>> composition(vector<vector<pi>> &e, int n){\n\tvector<bool> v(n);\n\tvector<pair<bool, vi>> res;\n\tfunction<bool(int,int,vi&)> rec = [&](int c, int p, vi &vs){\n\t\tvs.pb(c);\n\t\tv[c] = 1;\n\t\tbool res = 0;\n\t\tfor(auto i : e[c]) if(i.first != p){\n\t\t\tif(v[i.first]) res = 1;\n\t\t\telse res |= rec(i.first, c, vs);\n\t\t}\n\t\treturn res;\n\t};\n\trep(i, n) if(!v[i]){\n\t\tvi vs;\n\t\tbool lp = rec(i, i, vs);\n\t\tres.emplace_back(lp, vs);\n\t\t//dbg(lp, vs);\n\t}\n\treturn res;\n}\nll calc_loop(vi &vs, vector<vector<pi>> &e){\n\tll sum = 0;\n\tfor(int p = -1, c = vs[0], i = 0; i < vs.size(); i++){\n\t\tfor(auto j : e[c]) if(j.first != p){\n\t\t\tsum += j.second;\n\t\t\tp = c;\n\t\t\tc = j.first;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn sum;\n}\nvi calc_cost(bool loop, vi &vs, vector<vector<pi>> &e){\n\tvi cost;\n\tint c = vs[0];\n\tfor(int i : vs) if(e[i].size() == 1) c = i;\n\t\n\tfor(int p = -1, i = 0; i < (int)vs.size() - !loop; i++){\n\t\tint nc = -1;\n\t\tfor(auto j : e[c]) if(j.first != p){\n\t\t\tcost.pb((int)j.second);\n\t\t\tp = c;\n\t\t\tnc = j.first;\n\t\t\tbreak;\n\t\t}\n\t\tassert(nc != -1);\n\t\tc = nc;\n\t}\n\tif(loop){\n\t\t//dbg(cost);\n\t\trep(i, vs.size()) cost.pb(cost[i]);\n\t\t//dbg(cost);\n\t}\n\treturn cost;\n}\nint main(){\n\tcin.tie(0); cin.sync_with_stdio(0);\n\tint n, k, s;\n\twhile(cin >> n >> k >> s, n){\n\t\tvi x(n), y(n), z(n);\n\t\trep(i, n) cin >> x[i] >> y[i] >> z[i];\n\t\t\n\t\tif(k == 1){\n\t\t\tcout << 6ll * k * s * s << endl;\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tvector<vector<pi>> e = build_graph(n, x, y, z, s);\n\t\tvector<pair<bool, vi>> comp = composition(e, n);\n\t\tll mx = -1;\n\t\t\n\t\tfor(auto c : comp) if(c.second.size() >= k){\n\t\t\tbool loop = c.first;\n\t\t\tvi vs = c.second;\n\t\t\tif(loop && vs.size() == k) mx = max(mx, calc_loop(vs, e));\n\t\t\telse{\n\t\t\t\tvi costs = calc_cost(loop, vs, e);\n\t\t\t\tll sum = accumulate(costs.begin(), costs.begin() + k - 2, 0ll);\n\t\t\t\trep(i, (int)costs.size() - k + 2){\n\t\t\t\t\tsum += costs[i + k - 2];\n\t\t\t\t\tmx = max(mx, sum);\n\t\t\t\t\tsum -= costs[i];\n\t\t\t\t}\n\t\t\t\t/*\n\t\t\t\tdbg(loop, 6 * k * s * s);\n\t\t\t\tdbg(k, costs);\n\t\t\t\trep(j, costs.size()){\n\t\t\t\t\tll sum = 0;\n\t\t\t\t\trep(i, k - 1) if(j + i < costs.size()) sum += costs[j + i];\n\t\t\t\t\telse{ sum = -1; break; }\n\t\t\t\t\t//dbg(sum, mx);\n\t\t\t\t\tmx = max(mx, sum);\n\t\t\t\t}\n\t\t\t\t*/\n\t\t\t}\n\t\t}\n\t\tcout << (mx < 0 ? -1ll : 6ll * k * s * s - mx) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\n\nstruct Cube {\n    Cube() = default;\n    Cube(ll x, ll y, ll z, ll size) : x{x}, y{y}, z{z}, size{size}\n    {\n    }\n\n    bool operator<(const Cube& c) const\n    {\n        return (x != c.x) ? (x < c.x) : (y != c.y) ? (y < c.y) : (z != c.z) ? (z < c.z) : true;\n    }\n    ll x;\n    ll y;\n    ll z;\n    ll size;\n};\n\nll intersection(const Cube& c1, const Cube& c2)\n{\n\n    ll x = min(c1.x, c2.x) - max(c1.x, c2.x) + c1.size;\n    if (x <= 0) {\n        return 0;\n    }\n    ll y = min(c1.y, c2.y) - max(c1.y, c2.y) + c1.size;\n    if (y <= 0) {\n        return 0;\n    }\n    ll z = min(c1.z, c2.z) - max(c1.z, c2.z) + c1.size;\n    if (z <= 0) {\n        return 0;\n    }\n    return 2 * ((x * y) + (y * z) + (z * x));\n}\n\nstruct Edge {\n    Edge() = default;\n    Edge(int f, int t, ll c) : from{f}, to{t}, cost{c}\n    {\n    }\n    int from;\n    int to;\n    ll cost;\n};\n\nstruct Graph {\n    Graph(int n)\n    {\n        edge.resize(n);\n    }\n    void addEdge(int from, int to, ll cost)\n    {\n        edge[to].push_back(Edge{to, from, cost});\n        edge[from].push_back(Edge{from, to, cost});\n    }\n    vector<vector<Edge>> edge;\n};\n\nvoid dfs(const Graph& g, vector<bool>& checked, int pos, int& num, bool& ring, int& representation)\n{\n    num++;\n    checked[pos] = true;\n    bool update = false;\n    for (const auto& e : g.edge[pos]) {\n        const int to = e.to;\n        if (not checked[to]) {\n            dfs(g, checked, to, num, ring, representation);\n            update = true;\n        }\n    }\n    if (not update) {\n        if (g.edge[pos].size() == 2) {\n            ring = true;\n        } else {\n            ring = false;\n        }\n        representation = pos;\n    }\n}\n\nint main()\n{\n\n    while (true) {\n        int n, k;\n        ll s;\n        cin >> n >> k >> s;\n        if (n == 0 and k == 0 and s == 0) {\n            break;\n        }\n        vector<Cube> cubes(n);\n        for (int i = 0; i < n; i++) {\n            ll x, y, z;\n            cin >> x >> y >> z;\n            cubes[i] = Cube{x, y, z, s};\n        }\n        Graph g{n};\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                ll inter = intersection(cubes[i], cubes[j]);\n                if (inter > 0) {\n                    g.addEdge(i, j, inter);\n                }\n            }\n        }\n\n        vector<bool> checked(n, false);\n        vector<pair<pair<int, int>, bool>> cc;\n        for (int i = 0; i < n; i++) {\n            if (not checked[i]) {\n                int num = 0;\n                bool ring = false;\n                int rep;\n                dfs(g, checked, i, num, ring, rep);\n                if (num >= k) {\n                    cc.push_back(make_pair(make_pair(rep, num), ring));\n                }\n            }\n        }\n\n        if (cc.empty()) {\n            cout << -1 << endl;\n            continue;\n        }\n\n        ll maxi = -1;\n        vector<bool> used_head(n, false);\n        vector<bool> used_tail(n, false);\n        for (const auto p : cc) {\n            int rep = p.first.first;\n            int num = p.first.second;\n            bool ring = p.second;\n            if (ring) {\n                int head = rep;\n                int tail = rep;\n                ll sum = 0;\n                for (int i = 0; i < k - 1; i++) {\n                    used_tail[tail] = true;\n                    for (const auto& e : g.edge[tail]) {\n                        if (not used_tail[e.to]) {\n                            tail = e.to;\n                            sum += e.cost;\n                            break;\n                        }\n                    }\n                }\n                if (k == num) {\n                    used_tail[head] = false;\n                    for (const auto& e : g.edge[tail]) {\n                        if (not used_tail[e.to]) {\n                            sum += e.cost;\n                            break;\n                        }\n                    }\n                    maxi = max(maxi, sum);\n                    continue;\n                }\n                maxi = max(maxi, sum);\n                for (int i = 0; i < num; i++) {\n                    used_head[head] = true;\n                    used_tail[tail] = true;\n                    for (const auto& e : g.edge[head]) {\n                        if (not used_head[e.to]) {\n                            head = e.to;\n                            sum -= e.cost;\n                            break;\n                        }\n                    }\n                    for (const auto& e : g.edge[tail]) {\n                        if (not used_tail[e.to]) {\n                            tail = e.to;\n                            sum += e.cost;\n                            break;\n                        }\n                    }\n                    maxi = max(maxi, sum);\n                }\n            } else {\n                int head = rep;\n                int tail = rep;\n                ll sum = 0;\n                for (int i = 0; i < k - 1; i++) {\n                    used_tail[tail] = false;\n                    for (const auto& e : g.edge[tail]) {\n                        if (not used_tail[e.to]) {\n                            tail = e.to;\n                            sum += e.cost;\n                            break;\n                        }\n                    }\n                }\n                maxi = max(maxi, sum);\n                for (int i = 0; i < num - k + 1; i++) {\n                    used_head[head] = true;\n                    used_tail[tail] = true;\n                    for (const auto& e : g.edge[head]) {\n                        if (not used_head[e.to]) {\n                            head = e.to;\n                            sum -= e.cost;\n                            break;\n                        }\n                    }\n                    for (const auto& e : g.edge[tail]) {\n                        if (not used_tail[e.to]) {\n                            tail = e.to;\n                            sum += e.cost;\n                            break;\n                        }\n                    }\n                    maxi = max(maxi, sum);\n                }\n            }\n        }\n        cout << (6 * s * s) * static_cast<ll>(k) - maxi << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define sar(a,n) cout<<#a<<\":\";rep(pachico,n)cout<<\" \"<<a[pachico];cout<<endl\n#define svec(v) cout<<#v<<\":\";rep(pachico,v.size())cout<<\" \"<<v[pachico];cout<<endl\n#define svecp(v) cout<<#v<<\":\";each(pachico,v)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n#define sset(s) cout<<#s<<\":\";each(pachico,s)cout<<\" \"<<pachico;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(pachico,m)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 100005;\n\nstruct edge\n{\n    int to;\n    ll cost;\n};\n\nstruct data\n{\n    ll x,y,z;\n};\n\nvoid dfs(int u,int p,int& vc, int& ed, vector<int>& visit, vector<vector<edge> >& G, vector<int>& v)\n{\n    v.pb(u);\n    visit[u] = vc++;\n    each(e,G[u]){\n        if(visit[e.to] < 0){\n            ed++;\n            dfs(e.to,u,vc,ed,visit,G,v);\n        }else if(visit[e.to] < visit[u] && e.to != p){\n            ed++;\n        }\n    }\n}\n\nll solve(ll x,ll y,ll z)\n{\n    return 2*(x*y+y*z+z*x);\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while(1){\n        int n,K;\n        ll s;\n        cin >> n >> K >> s;\n        if(n == 0) break;\n        vector<vector<edge> > G(n);\n        vector<data> vec(n);\n        rep(i,n){\n            ll x,y,z;\n            cin >> x >> y >> z;\n            vec[i] = (data){x,y,z};\n        }\n        if(K == 1){\n            cout << 6*s*s*K << \"\\n\";\n            continue;\n        }\n        rep(i,n){\n            srep(j,i+1,n){\n                data& p = vec[i], q = vec[j];\n                if(p.x <= q.x){\n                    if(q.x < p.x+s){\n                        if(p.y <= q.y){\n                            if(q.y < p.y+s){\n                                if(p.z <= q.z){\n                                    if(q.z < p.z+s){\n                                        ll val = solve(p.x+s-q.x,p.y+s-q.y,p.z+s-q.z);\n                                        G[i].pb((edge){j,val}), G[j].pb((edge){i,val});\n                                    }\n                                }else{\n                                    if(p.z < q.z+s){\n                                        ll val = solve(p.x+s-q.x,p.y+s-q.y,q.z+s-p.z);\n                                        G[i].pb((edge){j,val}), G[j].pb((edge){i,val});\n                                    }\n                                }\n                            }\n                        }else{\n                            if(p.y < q.y+s){\n                                if(p.z <= q.z){\n                                    if(q.z < p.z+s){\n                                        ll val = solve(p.x+s-q.x,q.y+s-p.y,p.z+s-q.z);\n                                        G[i].pb((edge){j,val}), G[j].pb((edge){i,val});\n                                    }\n                                }else{\n                                    if(p.z < q.z+s){\n                                        ll val = solve(p.x+s-q.x,q.y+s-p.y,q.z+s-p.z);\n                                        G[i].pb((edge){j,val}), G[j].pb((edge){i,val});\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }else{\n                    if(p.x < q.x+s){\n                        if(p.y <= q.y){\n                            if(q.y < p.y+s){\n                                if(p.z <= q.z){\n                                    if(q.z < p.z+s){\n                                        ll val = solve(q.x+s-p.x,p.y+s-q.y,p.z+s-q.z);\n                                        G[i].pb((edge){j,val}), G[j].pb((edge){i,val});\n                                    }\n                                }else{\n                                    if(p.z < q.z+s){\n                                        ll val = solve(q.x+s-p.x,p.y+s-q.y,q.z+s-p.z);\n                                        G[i].pb((edge){j,val}), G[j].pb((edge){i,val});\n                                    }\n                                }\n                            }\n                        }else{\n                            if(p.y < q.y+s){\n                                if(p.z <= q.z){\n                                    if(q.z < p.z+s){\n                                        ll val = solve(q.x+s-p.x,q.y+s-p.y,p.z+s-q.z);\n                                        G[i].pb((edge){j,val}), G[j].pb((edge){i,val});\n                                    }\n                                }else{\n                                    if(p.z < q.z+s){\n                                        ll val = solve(q.x+s-p.x,q.y+s-p.y,q.z+s-p.z);\n                                        G[i].pb((edge){j,val}), G[j].pb((edge){i,val});\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        ll mx = -1;\n        vector<int> visit(n,-1);\n        rep(i,n){\n            if(visit[i] < 0){\n                int vc = 0, ed = 0;\n                vector<int> v;\n                dfs(i,-1,vc,ed,visit,G,v);\n                if(vc < K){\n                    continue;\n                }\n                // cout << vc << \" \" << ed << \" \" << K << \"\\n\";\n                int st = i, p = -1;\n                if(vc != ed){\n                    each(j,v){\n                        if(len(G[j]) == 1){\n                            st = j;\n                            break;\n                        }\n                    }\n                    assert(st >= 0);\n                    int cnt = 0;\n                    deque<ll> deq;\n                    ll val = 0;\n                    bool ok = true;\n                    while(ok){\n                        ok = false;\n                        cnt++;\n                        each(e,G[st]){\n                            if(e.to != p){\n                                if(cnt+1 > K){\n                                    val -= deq.front();\n                                    deq.pop_front();\n                                }\n                                deq.pb(e.cost);\n                                val += e.cost;\n                                cmx(mx,val);\n                                p = st;\n                                st = e.to;\n                                ok = true;\n                                break;\n                            }\n                        }\n                    }\n                    cmx(mx,val);\n                }else{\n                    int cnt = 0;\n                    deque<ll> deq;\n                    ll val = 0;\n                    ll al = 0;\n                    int ad = 0;\n                    while(ad < vc){\n                        cnt++;\n                        each(e,G[st]){\n                            if(e.to != p){\n                                if(cnt+1 > K){\n                                    ad++;\n                                    val -= deq.front();\n                                    deq.pop_front();\n                                }\n                                al += e.cost;\n                                deq.pb(e.cost);\n                                val += e.cost;\n                                cmx(mx,val);\n                                p = st;\n                                st = e.to;\n                                break;\n                            }\n                        }\n                    }\n                    if(vc == K){\n                        cmx(mx,al);\n                    }\n                    cmx(mx,val);\n                }\n            }\n        }\n        if(mx < 0){\n            cout << \"-1\\n\";\n        }else{\n            cout << 6*s*s*K - mx << \"\\n\";\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\nusing namespace std;\n\nstruct cube {\n    int x, y, z, w;\n    cube() {}\n    cube(int a, int b, int c, int d): x(a), y(b), z(c), w(d) {}\n\n    int area() {\n        return 6 * w * w;\n    }\n\n    int overlap_area(cube o) {\n        int ox = w - abs(x - o.x);\n        int oy = w - abs(y - o.y);\n        int oz = w - abs(z - o.z);\n\n        if (ox < 0 || oy < 0 || oz < 0) {\n            return -1;\n        }\n\n        return 2 * (ox * oy + oy * oz + oz * ox);\n    }\n};\n\nint main() {\n    int N, K, S;\n    while (true) {\n        cin >> N >> K >> S;\n        if (N == 0 && K == 0 && S == 0) break;\n\n        vector<cube> cubes;\n        vector<vector<int>> graph(N);\n\n        for (int j = 0; j < N; ++j) {\n            int x, y, z; cin >> x >> y >> z;\n            cubes.emplace_back(x, y, z, S);\n        }\n\n        for (int j = 0; j < N; ++j) {\n            for (int k = j+1; k < N; ++k) {\n                int area = cubes[j].overlap_area(cubes[k]);\n                if (area >= 0) {\n                    graph[j].push_back(k);\n                    graph[k].push_back(j);\n                }\n            }\n        }\n\n        int ans = -1;\n\n        vector<int> visited(N, 0);\n        for (int a = 0; a < N; ++a) {\n            if (visited[a]) continue;\n            visited[a] = 1;\n\n            bool loop = false;\n            int res = a;\n            for (int p = a, count = 1; p != -1; ++count) {\n                visited[p] = 1;\n                int np = -1;\n                for (int q: graph[p]) {\n                    if (count > 2 && q == a) {\n                        loop = true;\n                        break;\n                    }\n                    if (!visited[q]) {\n                        res = np = q;\n                        break;\n                    }\n                }\n                p = np;\n            }\n\n            vector<int> chain;\n            for (int p = res; p != -1; ) {\n                int np = -1;\n                chain.push_back(p);\n                for (int q: graph[p]) {\n                    if (chain.size() >= 2 && q == res) {\n                        break; // loop\n                    }\n                    if (chain.size() <= 1 || chain[chain.size()-2] != q) {\n                        np = q;\n                        break;\n                    }\n                }\n                p = np;\n            }\n\n            if (chain.size() < K) {\n                continue;\n            }\n\n            const int L = chain.size();\n\n            int area = cubes[chain[0]].area();\n            if (K <= 1) {\n                ans = (ans == -1) ? area : min(ans, area);\n            }\n            for (int j = 1; j < (loop ? 2*L : L); ++j) {\n                if (j >= K) {\n                    int va = chain[(j-K)%L], vb = chain[(j-K+1)%L];\n                    area -= cubes[va].area() - cubes[va].overlap_area(cubes[vb]);\n                }\n                area += cubes[chain[j%L]].area() - cubes[chain[(j-1)%L]].overlap_area(cubes[chain[j%L]]);\n                if (loop && K == L && j == L-1) {\n                    area -= cubes[chain[0]].overlap_area(cubes[chain[L-1]]);\n                }\n                if (j+1 >= K) {\n                    ans = (ans == -1) ? area : min(ans, area);\n                }\n            }\n        }\n\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing ll = long long;\nstruct Edge {\n    int dst;\n    ll w;\n    Edge() {}\n    Edge(int d, ll w) : dst(d), w(w) {}\n};\nusing Graph = vector<vector<Edge>>;\nstruct Cube { ll p[3]; };\n\n\nGraph MakeGraph(const int n, const int s, vector<Cube> &c) {\n    Graph g(n);\n    ll d[3];\n\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            for (int k = 0; k < 3; ++k)\n                d[k] = s + ((c[i].p[k] < c[j].p[k]) ? (c[i].p[k] - c[j].p[k]) : (c[j].p[k] - c[i].p[k]));\n\n            if (d[0] <= 0 || d[1] <= 0 || d[2] <= 0) continue;\n\n            ll w = 2 * d[0] * d[1] + 2 * d[0] * d[2] + 2 * d[1] * d[2];\n            g[i].emplace_back(Edge(j, w));\n            g[j].emplace_back(Edge(i, w));\n        }\n    }\n\n    return g;\n}\n\nint MinimumArea(const int n, const int k, const int s, const Graph &g) {\n    vector<bool> used(n, false);\n    ll res = -1;\n\n    for (int u = 0; u < 2 * n; ++u) {\n        if (used[u % n] || (u < n && g[u % n].size() == 2)) continue;\n\n        const int v = u % n;\n\n        vector<int> sub;\n        int cur = v;\n        while (true) {\n            used[cur] = true;\n            sub.push_back(cur);\n            if (1 <= g[cur].size() && !used[g[cur][0].dst])\n                cur = g[cur][0].dst;\n            else if (g[cur].size() == 2 && !used[g[cur][1].dst])\n                cur = g[cur][1].dst;\n            else\n                break;\n        }\n\n        const int size = sub.size();\n        if (size < k) continue;\n\n        ll sum = 0;\n        for (int i = 0; i < k - 1; ++i)\n            sum += ((g[sub[i]][0].dst == sub[i + 1]) ? g[sub[i]][0].w : g[sub[i]][1].w);\n\n        const bool is_cycle = (g[sub[0]].size() == 2);\n        if (size == k && is_cycle) {\n            sum += ((g[sub[0]][0].dst == sub[size - 1]) ? g[sub[0]][0].w : g[sub[0]][1].w);\n            res = max(res, sum);\n            continue;\n        }\n        res = max(res, sum);\n\n        const int lim = (is_cycle ? size - 1 : size - k);\n        for (int i = 1; i <= lim; ++i) {\n            sum -= ((g[sub[i]][0].dst == sub[i - 1]) ? g[sub[i]][0].w : g[sub[i]][1].w);\n            const int j1 = (i + k - 2) % size, j2 = (i + k - 1) % size;\n            sum += ((g[sub[j1]][0].dst == sub[j2]) ? g[sub[j1]][0].w : g[sub[j1]][1].w);\n            res = max(res, sum);\n        }\n    }\n\n    return (res == -1) ? -1 : 6 * k * s * s - res;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int n, k, s;\n\n    while (cin >> n >> k >> s, n) {\n        vector<Cube> cube(n);\n        for (auto &c : cube)\n            for (int i = 0; i < 3; ++i) cin >> c.p[i];\n\n        cout << MinimumArea(n, k, s, MakeGraph(n, s, cube)) << '\\n';\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <array>\n#include <cassert>\n#include <climits>\n#include <complex>\n#include <cstdio>\n#include <cstring>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <iterator>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <string>\n#include <tuple>\n#include <vector>\n\nusing namespace std;\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define ALL(x) (x).begin(), (x).end()\n\nint subcube(int len, int x0, int y0, int z0, int x1, int y1, int z1) {\n    int dx = x0 - x1, dy = y0 - y1, dz = z0 - z1;\n    int sx = max(min(len + dx, len - dx), 0);\n    int sy = max(min(len + dy, len - dy), 0);\n    int sz = max(min(len + dz, len - dz), 0);\n    return (sx * sy * sz == 0) ? 0 : 2 * (sx * sy + sy * sz + sz * sx);\n}\n\nint main(){\n    int n, k, s; \n    while(cin >> n >> k >> s, n != 0){\n    vector<int> xs(n), ys(n), zs(n);\n    REP(i, n) {\n        cin >> xs[i] >> ys[i] >> zs[i];\n    }\n\n    if (k == 1) cout << s * s * 6 * k << endl;\n    vector<vector<int>> subc(n, vector<int>(n));\n    REP(a, n) {\n        REP(b, n) {\n            if (a == b) continue;\n            subc[a][b] = subcube(s, xs[a], ys[a], zs[a], xs[b], ys[b], zs[b]);\n            //cout << subc[a][b] << \"\\t\";\n        }\n        //cout << endl;\n    }\n\n    vector<vector<int>> segs;\n    vector<int> used(n, false);\n\n    REP(a, n){\n        if (used[a]) continue;\n        vector<int> seg;\n        int p = a; bool ok = true, loop = false;\n        seg.push_back(p);\n        used[a] = true;\n        while(ok) {\n            ok = false;\n            REP(b, n) {\n                if (subc[p][b] > 0) {\n                    if (a == p) loop = true;\n                    if (used[b]) continue;\n                    p = b;\n                    seg.push_back(p);\n                    used[b] = true;\n                    ok = true;\n                    break;\n                }\n            }\n        }\n        reverse(ALL(seg));\n        if (!loop) {\n            p = a;\n            while(ok) {\n                ok = false;\n                REP(b, n) {\n                    if (subc[p][b] > 0) {\n                        if (used[b]) continue;\n                        p = b;\n                        seg.push_back(p);\n                        used[b] = true;\n                        ok = true;\n                        break;\n                    }\n                }\n            }\n        }\n        segs.push_back(seg);\n    }\n\n    int res = -1;\n    REP(i, segs.size()) {\n        const vector<int> seg(segs[i]);\n        /*\n        cout << \"# \"; REP(a, seg.size()) {\n            cout << seg[a] << \" \";\n        } cout << endl;\n        */\n        const int l = seg.size();\n        if (l < k) { continue; }\n        if (l == k) {\n            int sum = 0;\n            if (l == 2) {\n                res = max(res, subc[seg[0]][seg[1]]);\n                continue;\n            }\n            REP(a, l) {\n                //cout << \"+=\" << seg[a] << \" \" << seg[(a+1)%l] << endl;\n                //cout << \"   : \" << subc[seg[a]][seg[(a+1)%l]] << endl;\n                sum += subc[seg[a]][seg[(a+1)%l]];\n            }\n            res = max(res, sum);\n            continue;\n        }\n        int sum = 0;\n        REP(a, k - 1) {\n            sum += subc[seg[a]][seg[a+1]];\n        }\n        REP(a, l) {\n            sum += subc[seg[(a + k - 1) % l]][seg[(a + k) % l]];\n            sum -= subc[seg[(a % l)]][seg[(a + 1) % l]];\n            res = max(res, sum);\n        }\n    }\n\n    // cout << \"$\" << subc[0][1] << endl;\n    // cout << res << endl;\n    if (res < 0) cout << res << endl;\n    else cout << s * s * 6 * k - res << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing ll = long long;\nstruct Edge {\n    ll dst, w;\n    Edge() {}\n    Edge(ll d, ll w) : dst(d), w(w) {}\n};\nusing Graph = vector<vector<Edge>>;\nstruct Cube { ll p[3]; };\n\n// グラフを構成する\nGraph MakeGraph(const int n, const int s, vector<Cube> &c) {\n    Graph g(n);\n    ll d[3];\n\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            for (int k = 0; k < 3; ++k)\n                d[k] = s - abs(c[i].p[k] - c[j].p[k]);\n\n            // c[i]とc[j]は交差しない\n            if (min({d[0], d[1], d[2]}) <= 0) continue;\n\n            ll w = 2 * d[0] * d[1] + 2 * d[0] * d[2] + 2 * d[1] * d[2];\n            g[i].emplace_back(Edge(j, w));\n            g[j].emplace_back(Edge(i, w));\n        }\n    }\n\n    return g;\n}\n\nll Dfs(const int start, const int prev, const int cur, int size, const Graph &g) {\n    if (size == 0) {\n        if ((g[cur].size() == 2) && (g[cur][0].dst == start || g[cur][1].dst == start))\n            return (g[cur][0].dst == start) ? g[cur][0].w : g[cur][1].w;\n        else\n            return 0;\n    }\n\n    ll max_w = -1;\n    for (const auto &e : g[cur])\n        if (e.dst != prev) {\n            const ll res = Dfs(start, cur, e.dst, size - 1, g);\n            if (res != -1) max_w = max(max_w, res + e.w);\n        }\n\n    return max_w;\n}\n\nint MinimumArea(const int n, const int k, const int s, const Graph &g) {\n    ll res = -1;\n\n    for (int v = 0; v < n; ++v)\n        res = max(res, Dfs(v, -1, v, k - 1, g));\n\n    return (res == -1) ? -1 : 6 * k * s * s - res;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int n, k, s;\n\n    while (cin >> n >> k >> s, n) {\n        vector<Cube> cube(n);\n        for (auto &c : cube)\n            for (int i = 0; i < 3; ++i) cin >> c.p[i];\n\n        cout << MinimumArea(n, k, s, MakeGraph(n, s, cube)) << '\\n';\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing P = pair<int, ll>;\n\nint main()\n{\n\tll n, k, s;\n\twhile (cin >> n >> k >> s, n | k | s) {\n\t\tvector<ll> x(n), y(n), z(n);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcin >> x[i] >> y[i] >> z[i];\n\t\t}\n\t\tif (k == 1) {\n\t\t\tcout << s * s * 6 << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tvector<vector<P>> G(n);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tif (i != j) {\n\t\t\t\t\tll dx = s - abs(x[i] - x[j]), dy = s - abs(y[i] - y[j]), dz = s - abs(z[i] - z[j]);\n\t\t\t\t\tif (dx > 0 && dy > 0 && dz > 0) {\n\t\t\t\t\t\tG[i].push_back(P(j, (dx * dy + dy * dz + dz * dx) * 2));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tll res = s * s * 6 * k, d = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tvector<int> v;\n\t\t\tvector<ll> used(n);\n\t\t\tll tmp = 0;\n\t\t\tbool flag = true;\n\t\t\tused[i] = -1;\n\t\t\tif (G[i].empty()) continue;\n\t\t\tused[G[i][0].first] += G[i][0].second;\n\t\t\tv.push_back(G[i][0].first);\n\t\t\tfor (int j = 0; j < k - 1; j++) {\n\t\t\t\twhile (!v.empty() && used[v.back()] < 0) {\n\t\t\t\t\tv.pop_back();\n\t\t\t\t}\n\t\t\t\tif (v.empty()) {\n\t\t\t\t\tflag = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tauto ne = v.back(); v.pop_back();\n\t\t\t\ttmp += used[ne];\n\t\t\t\tused[ne] = -1;\n\t\t\t\tfor (auto p : G[ne]) {\n\t\t\t\t\tif (used[p.first] >= 0) {\n\t\t\t\t\t\tused[p.first] += p.second;\n\t\t\t\t\t\tv.push_back(p.first);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (flag) {\n\t\t\t\td = max(d, tmp);\n\t\t\t}\n\t\t}\n\t\tcout << (d ? res - d : -1) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,k,n) for(int i=(k);i<(int)(n);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(x) begin(x),end(x)\n\nusing namespace std;\n\nstruct Edge {\n  int src, dest; int64_t weight;\n};\nusing Edges = vector<Edge>;\nusing Graph = vector<Edges>;\nvoid add_edge(Graph &g, int src, int dest, int64_t weight) {\n  g[src].push_back((Edge){src, dest, weight});\n  g[dest].push_back((Edge){dest, src, weight});\n}\n\nstruct UnionFind {\n  vector<int> parent;\n  UnionFind (int n) : parent(n, -1) {}\n  int root(int x) { return parent[x] < 0 ? x : parent[x] = root(parent[x]); }\n  int size(int x) { return -parent[root(x)]; }\n  bool merge(int x, int y) {\n    x = root(x); y = root(y);\n    if (x == y) return false;\n    if (parent[y] < parent[x]) swap(x, y);\n    parent[x] += parent[y];\n    parent[y] = x;\n    return true;\n  }\n};\n\nvector<int> dfs(const Graph &g, int now, int prev, vector<bool>& visited) {\n  visited[now] = true;\n  vector<int> res;\n  for (const auto& e : g[now]) {\n    if (e.dest == prev) continue;\n    if (visited[e.dest]) res.push_back(e.weight);\n    else {\n      res = dfs(g, e.dest, now, visited);\n      res.push_back(e.weight);\n    }\n  }\n  return res;\n}\n\nint main() {\n  while (true) {\n    int64_t n,k,s;\n    cin>>n>>k>>s;\n    if(!n) break;\n    using C = tuple<int64_t,int64_t,int64_t>;\n    vector<C> vc;\n    REP(i,n) {\n      int64_t x,y,z;\n      cin>>x>>y>>z;\n      vc.emplace_back(x,y,z);\n    }\n    if (k == 1) {\n      cout << (6 * s * s) << endl;\n      continue;\n    }\n    Graph g(n);\n    UnionFind uf(n);\n    vector<bool> is_circle(n, false);\n    REP(i,n) REP(j,i) {\n      int64_t x1,y1,z1,x2,y2,z2;\n      tie(x1,y1,z1) = vc[i];\n      tie(x2,y2,z2) = vc[j];\n      int64_t lx, ly, lz;\n      lx = s - abs(x1-x2);\n      ly = s - abs(y1-y2);\n      lz = s - abs(z1-z2);\n      if (lx <= 0 || ly <= 0 || lz <= 0) continue;\n      int64_t ov = 2 * (lx * ly + ly * lz + lz * lx);\n      add_edge(g, i, j, ov);\n      bool c = uf.merge(i, j);\n      if (!c) is_circle[uf.root(i)] = true;\n    }\n    vector<bool> visited(n, false);\n    int64_t res = -1;\n    bool ok = false;\n    REP(i,n) {\n      if (g[i].size() == 1 && !visited[i]) {\n        auto v = dfs(g, i, -1, visited);\n        int m = v.size();\n        REP(j,m-k+2) {\n          int64_t sum = 0;\n          REP(l,k-1) {\n            sum += v[j+l];\n          }\n          res = max(res, sum);\n          ok = true;\n        }\n      }\n      if (is_circle[uf.root(i)] && !visited[i]) {\n        auto v = dfs(g, i, g[i][0].dest, visited);\n        int m = v.size();\n        if (m == k) {\n          int64_t sum = 0;\n          REP(j,m) sum += v[j];\n          res = max(res, sum);\n          ok = true;\n        } else {\n          REP(j,m) {\n            int64_t sum = 0;\n            REP(l,k-1) {\n              sum += v[(j+l)%m];\n            }\n            res = max(res, sum);\n            ok = true;\n          }\n        }\n      }\n    }\n    if (ok) {\n      cout << (6 * s * s * k - res) << endl;\n    } else {\n      cout << -1 << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define loop for(;;)\ntypedef std::vector<long> LI;\ntemplate<typename T> void scan1(T& x) { fprintf(stderr, \"unknown type\\n\"); }\ntemplate<> void scan1(long& x) { if( scanf(\"%ld\", &x) < 0 ) exit(0); }\ntemplate<> void scan1(std::string& x) { if( not ( std::cin >> x ) ) exit(0); }\nvoid scan() {}\ntemplate<typename Head, typename... Tail>\nvoid scan(Head& x, Tail&... xs) {\n  scan1(x); scan(xs...);\n}\n\nstruct Solver {\n   std::vector<long> nexts[2123];\n   std::vector<long> overlap[2123];\n   long n, len, s;\n   LI xs, ys, zs;\n   long f(long i, long k) {\n      long dx = std::max((long)0, s - std::abs(xs[k] - xs[i]));\n      long dy = std::max((long)0, s - std::abs(ys[k] - ys[i]));\n      long dz = std::max((long)0, s - std::abs(zs[k] - zs[i]));\n      if( dx == 0 or dy == 0 or dz == 0 ) return 0;\n      return 2 * (dx * dy + dy * dz + dz * dx);\n   }\n   void solve() {\n      scan(n, len, s);\n      if( n == 0 and len == 0 and s == 0 ) exit(0);\n      xs.resize(n), ys.resize(n), zs.resize(n);\n      for(long i = 0; i < n; ++i) scan(xs[i], ys[i], zs[i]);\n      for(long i = 0; i < n; ++i) {\n         for(long k = 0; k < n; ++k) {\n            if( i == k ) continue;\n            long over = f(i, k);\n            if( over == 0 ) continue;\n            nexts[i].push_back(k);\n            overlap[i].push_back(over);\n         }\n      }\n      long res = 0;\n      for(long i = 0; i < n; ++i) {\n         visited.resize(n, false);\n         res = std::max(res, dfs(i, len-1, i));\n      }\n      visited.resize(n);\n      printf(\"%ld\\n\", res > 0 ? 6 * s * s * len - res : -1);\n   }\n   std::vector<bool> visited;\n   long dfs(long v, long d, long begin) {\n      if( d == 0 ) {\n         for(long i = 0; i < (long)nexts[v].size(); ++i) {\n            long next = nexts[v][i];\n            long over = overlap[v][i];\n            if( next == begin ) {\n               return over;\n            }\n         }\n         return 0;\n      }\n      long res = -(1LL << 53);\n      visited[v] = true;\n      for(long i = 0; i < (long)nexts[v].size(); ++i) {\n         long next = nexts[v][i];\n         long over = overlap[v][i];\n         if( visited[next] ) continue;\n         res = std::max(res, dfs(next, d-1, begin) + over);\n      }\n      visited[v] = false;\n      return res;\n   }\n};\n\nint main() {\n   loop std::shared_ptr<Solver>(new Solver())->solve();\n}"
  },
  {
    "language": "C++",
    "code": "        #include <bits/stdc++.h>\n        #include<iostream>\n        #include<cstdio>\n        #include<vector>\n        #include<queue>\n        #include<map>\n        #include<cstring>\n        #include<string>\n        #include <math.h>\n        #include<algorithm>\n        #include<functional>\n       #define int long long\n        #define inf  1000000007\n        #define pa pair<int,int>\n#define ll long long\n        #define pal pair<ll,ll>\n   //     #define ppa pair<int,pa>\n        #define EPS (1e-10)\n        #define equals(a,b) (fabs((a)-(b))<EPS)\n\n        using namespace std;\n\n        class Point{\n        \tpublic:\n        \tdouble x,y;\n        \tPoint(double x=0,double y=0):x(x),y(y) {}\n        \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n        \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n        \tPoint operator * (double a) {return Point(x*a,y*a);}\n        \tPoint operator / (double a) {return Point(x/a,y/a);}\n        \tdouble absv() {return sqrt(norm());}\n        \tdouble norm() {return x*x+y*y;}\n        \tbool operator < (const Point &p) const{\n        \t\treturn x != p.x ? x<p.x: y<p.y;\n        \t}\n        \tbool operator == (const Point &p) const{\n        \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n        \t}\n        };\n        typedef Point Vector;\n\n        struct Segment{\n        Point p1,p2;\n        };\n\n    double hen(Vector a){\n    if(fabs(a.x)<EPS && a.y>0) return acos(0);\n    else if(fabs(a.x)<EPS && a.y<0) return 3*acos(0);\n    else if(fabs(a.y)<EPS && a.x<0) return 2*acos(0);\n    else if(fabs(a.y)<EPS && a.x>0) return 0.0;\n    else if(a.y>0) return acos(a.x/a.absv());\n    else return 2*acos(0)+acos(-a.x/a.absv());\n\n    }\n\n        double dot(Vector a,Vector b){\n        \treturn a.x*b.x+a.y*b.y;\n        }\n        double cross(Vector a,Vector b){\n        \treturn a.x*b.y-a.y*b.x;\n        }\n        /*\n        int dx[8] = {1, 0, -1, 0,1,1,-1,-1};\n        int dy[8] = {0, 1, 0, -1,1,-1,1,-1};\n        */\n        //----------------kokomade temple------------\n\n\nint n,k,s;\nint dx,dy,dz,dd;\nsigned main(){\n\twhile(cin>>n>>k>>s){\n\t\tif(n==0) break;\n\t\t\n\t\tif(k==1){\n\t\t\tcout<<6*s*s<<endl;\n\t\t\tcin>>n>>k>>s;\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\t\n\t\tint x[2010],y[2010],z[2010];\n\t\tfor(int i=0;i<n;i++)cin>>x[i]>>y[i]>>z[i];\n\t\tvector<pal> G[2002];\n\t\tfor(int i=0;i<n;i++) for(int j=i+1;j<n;j++){\n\t\t\tdx=abs(x[i]-x[j]);\n\t\t\tdy=abs(y[i]-y[j]);\n\t\t\tdz=abs(z[i]-z[j]);\n\t\t\tif(!(dx<s && dy<s&& dz<s)) continue;\n\t\t\tdx=s-dx;\n\t\t\tdy=s-dy;\n\t\t\tdz=s-dz;\n\t\t\tdd=2*(dx*dy+dy*dz+dx*dz);\n\t//\t\tcout<<i<<\" \"<<j<<endl;\n\t\t\tG[i].push_back(make_pair(j,dd));\n\t\t\tG[j].push_back(make_pair(i,dd));\n\t\t}\n\t\tbool ch[2010]={0};\n\t\tint sennum[2010],wanum[2010];\n\t\tvector< vector<int> > sen;\n\t\tvector< vector<int> > wa;\n\t\tvector< int > ten;\n\t\n\t\t\n\t\tfor(int i=0;i<n;i++){\n\t\t\tif(ch[i]) continue;\n\t\t\tif(G[i].size()==0){\n\t\t\t\tten.push_back(i);\n\t\t\t\tch[i]=1;\n\t\t\t}\n\t\t\telse if(G[i].size()==1){\n\t\t\t\tint r=i,mae=i;\n\t\t\t\tvector<int> vten;\n\t\t\t\t//vten.push_back(i);\n\t\t\t\tr=G[i][0].first;\n\t\t\t\tvten.push_back(G[i][0].second);\n\t\t\t\tch[i]=1;\n\t\t\t\twhile(G[r].size()==2){\n\t\t\t\t\tch[r]=1;\n\t\t\t\t\tfor(int j=0;j<2;j++){\n\t\t\t\t\t\tif(G[r][j].first==mae) continue;\n\t\t\t\t\t\tvten.push_back(G[r][j].second);\n\t\t\t\t\t\tmae=r;\n\t\t\t\t\t\tr=G[r][j].first;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tch[r]=1;\n\t\t\t\tsen.push_back(vten);\n\t\t\t\tsennum[sen.size()-1]=vten.size()+1;\n\t\t\t}\n\t\t}\n\t\n\t\tfor(int i=0;i<n;i++){\n\t\t\n\t\t\tif(ch[i])continue;\n\t\t\tvector<int> vten;\n\t\t\tint st=i,mae=i;\n\t\t\tint r=G[i][0].first;\n\t\t\tvten.push_back(G[i][0].second);\n\t\t\tch[i]=true;\n\t\t\twhile(ch[r]==false){\n\t\t//\t\tcout<<r<<endl;\n\t\t\t\tch[r]=true;\n\t\t\t\tfor(int j=0;j<2;j++){\n\t\t\t\t\t\tif(G[r][j].first==mae) continue;\n\t\t\t\t\t\tvten.push_back(G[r][j].second);\n\t\t\t\t\t\tmae=r;\n\t\t\t\t\t\tr=G[r][j].first;\n\t\t\t\t\t}\n\t\t\t\t\n\t\t\t}\t\n\t\t//\tvten.push_back(G[st][1].second);\n\t\t\twanum[wa.size()]=vten.size();\n\t\t\twa.push_back(vten);\n\t\t//\tcout<<vten.size()<<endl;\n\t\t}\n\t\t/*\n\t\tcout<<ten.size()<<endl;\n\t\tcout<<wa.size()<<endl;\n\t\tcout<<sen.size()<<endl;\n\t\t*/\n\t\tint ans=-1;\n\t\t\n\t\tint kosuu=sen.size();\n\t\tfor(int i=0;i<kosuu;i++){\n\t\t\tif(sennum[i]<k) continue;\n\t\t\tint y=0;\n\t\t\tfor(int j=0;j<=sennum[i]-k;j++){\n\t\t\ty=0;\n\t\t\t\tfor(int h=j;h<j+k-1;h++) y+= sen[i][h];\n\t\t\tans=max(ans,y);\n\t\t\t}\n\t\t\tans=max(ans,y);\n\t\t\t//cout<<ans<<endl;\n\t\t}\n\t//\tcout<<wanum[0]<<endl;\n\t\t\tkosuu=wa.size();\n\t\tfor(int i=0;i<kosuu;i++){\n\t\t//\tcout<<\"s\"<<endl;\n\t\t\tif(wanum[i]<k) continue;\n\t\t\tint y=0;\n\t\t\tif(wanum[i]==k){\n\t\t\t\ty=0;\n\t\t\t\tfor(int j=0;j<k;j++) y+= wa[i][j];\n\t\t\t\tans=max(ans,y);\n\t\t\t}\n\t\t\telse{\n\t\t\t\n\t\t\tfor(int j=0;j<wanum[i];j++){\n\t\t//\t\tcout<<\"s\"<<endl;\n\t\t\t\ty=0;\n\t\t\t\tfor(int h=j;h<j+k-1;h++){\n\t\t\t\t//\ty=0;\n\t\t\t\t\ty+= wa[i][h%(wanum[i])];\n\t\t\t//\t\tcout<<y<<endl;\n\t\t\t\t\n\t\t\t\t}\n\t\t//\t\tcout<<y<<endl;\n\t\t\t\tans=max(ans,y);\n\t\t\t}\n\t\t\tans=max(ans,y);\n\t\t\t}\n\t//\t\tcout<<ans<<endl;\n\t\t\n\t\t}\n\t//\tcout<<ans<<endl;\n\t\tif(ans==-1) cout<<-1<<endl;\n\t\telse{\n\t\t\tcout<<6ll*k*s*s-ans<<endl;\n\t\t}\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t}\n\nreturn 0;\n}\n// printf(\"%.10f\\n\", ans);"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF 1000000000000007LL\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,ll> P;\n\nint n,k,s;\nvector<P> G[2001];\nbool flag[2001];\nint x[2001],y[2001],z[2001];\nint cnt=0;\nll sum=0;\n\nbool check(int i,int j){\n\tif(x[i]+s<=x[j] || x[j]+s<=x[i])return false;\n\tif(y[i]+s<=y[j] || y[j]+s<=y[i])return false;\n\tif(z[i]+s<=z[j] || z[j]+s<=z[i])return false;\n\treturn true;\n}\n\nvoid dfs(int v,int p){\n\tflag[v]=true;\n\tfor(int i=0;i<G[v].size();i++){\n\t\tif(G[v][i].first!=p){\n\t\t\tif(flag[G[v][i].first])sum-=(ll)G[v][i].second;\n\t\t\telse{\n\t\t\t\tif(cnt<k){\n\t\t\t\t\tsum+=(ll)6*s*s-G[v][i].second;\n\t\t\t\t\tcnt++;\n\t\t\t\t\tdfs(G[v][i].first,v);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d%d%d\",&n,&k,&s);\n\t\tif(n==0 && k==0 && s==0)return 0;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tG[i].clear();\n\t\t\tscanf(\"%d%d%d\",&x[i],&y[i],&z[i]);\n\t\t}\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=i+1;j<n;j++){\n\t\t\t\tif(check(i,j)){\n\t\t\t\t\tint v1=s-abs(x[i]-x[j]);\n\t\t\t\t\tint v2=s-abs(y[i]-y[j]);\n\t\t\t\t\tint v3=s-abs(z[i]-z[j]);\n\t\t\t\t\tll cost=2*(v1*v2+v2*v3+v3*v1);\n\t\t\t\t\tG[i].push_back(P(j,cost));\n\t\t\t\t\tG[j].push_back(P(i,cost));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tll res=INF;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tif(k==1){\n\t\t\t\tres=min(res,(ll)6*s*s);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor(int j=0;j<G[i].size();j++){\n\t\t\t\tmemset(flag,false,sizeof(flag));\n\t\t\t\tflag[i]=true;\n\t\t\t\tflag[G[i][j].first]=true;\n\t\t\t\tcnt=2;\n\t\t\t\tsum=12*s*s-G[i][j].second;\n\t\t\t\tdfs(G[i][j].first,i);\n\t\t\t\tif(cnt==k)res=min(res,sum);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%lld\\n\",res==INF?-1:res);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb(s) push_back(s)\n#define mp(a,b) make_pair(a,b)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define maxch(x,y) x=max(x,y)\n#define minch(x,y) x=min(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt(x) bitset<32>(x).count()\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\n\n#define INF 1e16\n\nstruct UnionFind{\n  vector<int> v;\n  UnionFind(int n) : v(n, -1) {}\n  int find(int x) { return v[x] < 0 ? x : v[x] = find(v[x]); }\n  bool unite(int x, int y) {\n    x = find(x); y = find(y);\n    if (x == y) return false;\n    if (-v[x] < -v[y]) swap(x, y);\n    v[x] += v[y]; v[y] = x;\n    return true;\n  }\n  bool same(int x, int y) { return find(x) == find(y); }\n};\n\nll n,k,s;\nll x[2222],y[2222],z[2222];\nvector<int> g[2222];\nbool lused[2222],rused[2222];\n\nbool is_cross(int i,int j){\n  return (abs(x[i]-x[j])<=s)&&(abs(y[i]-y[j])<=s)&&(abs(z[i]-z[j])<=s);\n}\n\nll cross_surf(int i,int j){\n  ll xx=s-abs(x[i]-x[j]);\n  ll yy=s-abs(y[i]-y[j]);\n  ll zz=s-abs(z[i]-z[j]);\n  return 2*(xx*yy+yy*zz+zz*xx);\n}\n\nint main(){\n\tcin.sync_with_stdio(false);\n  while(1){\n    rep(i,2222)g[i].clear();\n    cin>>n>>k>>s;\n    if(n==0)break;\n    rep(i,n){\n      cin>>x[i]>>y[i]>>z[i];\n    }\n    if(k==1){\n      cout<<s*s*6<<endl;\n      continue;\n    }\n    UnionFind uf(n);\n    rep(i,n)rep(j,i){\n      if(is_cross(i,j)&&!uf.same(i,j)){\n        g[i].pb(j);\n        g[j].pb(i);\n        uf.unite(i,j);\n        //printf(\"%d %d\\n\", i,j);\n      }\n    }\n    ll res=INF;\n    memset(lused,0,sizeof(lused));\n    memset(rused,0,sizeof(rused));\n    rep(i,n){\n      if(lused[i]||rused[i]||g[i].size()!=1)continue;\n      lused[i]=rused[i]=true;\n      int l=i,r=i,cnt=1;\n      ll sum=s*s*6;\n      while(1){\n        if(cnt==k){\n          if(k>2&&is_cross(l,r))minch(res,sum-cross_surf(l,r));\n          else minch(res,sum);\n        }\n        int pcnt=cnt;\n        if(cnt<=k){\n          for(int nxt:g[r]){\n            if(rused[nxt])continue;\n            rused[nxt]=true;\n            cnt++;\n            sum+=s*s*6-cross_surf(r,nxt);\n            r=nxt;\n          }\n        }\n        if(pcnt==cnt)break;\n        if(cnt>k){\n          for(int nxt:g[l]){\n            if(lused[nxt])continue;\n            lused[nxt]=true;\n            cnt--;\n            sum-=s*s*6-cross_surf(l,nxt);\n            l=nxt;\n          }\n        }\n      }\n    }\n    if(res==INF)cout<<-1<<endl;\n    else cout<<res<<endl;\n  }\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <cmath>\n#include <cstdlib>\n#include <map>\nusing namespace std;\n\nclass Point {\npublic:\n    int x, y, z;\n    Point(int x = 0, int y = 0, int z = 0) : x(x), y(y), z(z) {}\n};\n\nclass Cube {\npublic:\n    Point p;\n    int s;\n    int vx[4] = {0, 1, 1, 0}, vy[4] = {0, 0, 1, 1}, vz[2] = {0, 1};\n    Cube(Point p = Point(), int s = 0) : p(p), s(s) {}\n\n    bool isIn(const Cube &c) {\n        /*\n        int nx, ny, nz;\n        for (int i = 0; i < 2; ++i) {\n            for (int j = 0; j < 4; ++j) {\n                nx = c.p.x + c.s * vx[j];\n                ny = c.p.y + c.s * vy[j];\n                nz = c.p.z + c.s * vz[i];\n\n                if (p.x <= nx && nx <= p.x + s &&\n                    p.y <= ny && ny <= p.y + s &&\n                    p.z <= nz && nz <= p.z + s) {\n                        return true;\n                    }\n            }\n        return false;\n        }*/\n        return ((abs(p.x - c.p.x) < s) && (abs(p.y - c.p.y) <= s) && (abs(p.z - c.p.z) <= s) &&\n                (abs(p.x - c.p.x) <= s) && (abs(p.y - c.p.y) < s) && (abs(p.z - c.p.z) <= s) &&\n                (abs(p.x - c.p.x) <= s) && (abs(p.y - c.p.y) <= s) && (abs(p.z - c.p.z) < s));\n    }\n\n    long long shareS(Cube &c) {\n        long long ret = 0;\n        Point a, b;\n        a = p; b = c.p;\n\n        if (a.x > b.x) swap(a.x, b.x);\n        if (a.y > b.y) swap(a.y, b.y);\n        if (a.z > b.z) swap(a.z, b.z);\n\n        ret += abs((a.x + s - b.x) * (a.z + s - b.z) * 2);\n        ret += abs((a.y + s - b.y) * (a.z + s - b.z) * 2);\n        ret += abs((a.x + s - b.x) * (a.y + s - b.y) * 2);\n        return ret;\n    }\n\n};\n\nint n, k, s, x, y, z;\nlong long ans;\nvector<Cube> c;\nvector<vector<int> > subg;\nvector<bool> used;\nvector<deque<int> > graph;\ndeque<int> que;\n\n// not clever\ninline void makegraph() {\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            if (c[i].isIn(c[j])) {\n                subg[j].push_back(i);\n                subg[i].push_back(j);\n            }\n        }\n    }\n}\n\n// make path\nvoid dfs(int v) {\n    used[v] = true;\n    int size_ = subg[v].size();\n    bool flag = false;\n\n    for (int i = 0; i < size_; ++i) {\n        if (!used[subg[v][i]]) {\n            dfs(subg[v][i]);\n            if (!flag) que.push_front(v);\n            flag = true;\n        }\n    }\n\n    if (!flag) que.push_front(v);\n}\n\n// is graph[graphid] cycle ?\ninline bool isCycle(int graphid) {\n    int size_ = graph[graphid].size();\n\n    // if all vertex's degree are two, this graph is cycle.\n    for (int i = 0; i < size_; ++i) {\n        if (subg[graph[graphid][i]].size() != 2) return false;\n    }\n\n    return true;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    while (cin >> n >> k >> s, n | k | s) {\n        //cout << \"---- begin ----\" << endl;\n        c.resize(n);\n        subg.resize(n);\n        que.clear();\n        used.assign(n, false);\n        ans = int(1e15);\n\n        for (int i = 0; i < n; ++i) {\n            cin >> x >> y >> z;\n            c[i] = {Point(x, y, z), s};    \n        }\n\n        makegraph();\n\n        for (int i = 0; i < n; ++i) {\n            if (!used[i]) {\n                dfs(i);\n                graph.push_back(que);\n                que.clear();\n            }\n        }\n\n        /*\n        for (int i = 0; i < graph.size(); ++i) {\n            for (int j = 0; j < graph[i].size(); ++j) {\n                cout << graph[i][j] << \" \";\n            }\n            cout << endl;\n        }\n        */\n\n        int gsize = graph.size(), qsize, upper;\n        long long share;\n        bool isGraphCycle = false;\n\n        //cout << \"k = \" << k << endl;\n\n        for (int i = 0; i < gsize; ++i) {\n            qsize = graph[i].size();\n            isGraphCycle = isCycle(i);\n            if (isGraphCycle) {\n                upper = qsize + k - 1;\n            }\n            else upper = qsize;\n\n            if (qsize < k) continue;\n\n            for (int j = 0; j + k - 1 < upper + 1; ++j) {\n                share = 0;\n                /*for (int l = 0; l < k - 1; ++l) {\n                    cout << graph[i][(j + l) % qsize] << \" \" << graph[i][(j + l + 1) % qsize] << endl;\n                }*/\n                //cout << graph[i][(j + k - 1) % qsize] << \" \" << graph[i][(j + k) % qsize] << endl;\n                //cout << endl;\n\n                for (int l = 0; l < k - 1; ++l) {\n                    //Cube a = c[graph[i][j + l]],\n                    //    b = c[graph[i][j + l + 1]];\n                    //cout << a.p.x << \" \" << a.p.y << \" \" << a.p.z << endl;\n                    //cout << b.p.x << \" \" << b.p.y << \" \" << b.p.z << endl;\n\n                    share += c[graph[i][(j + l) % qsize]].shareS(c[graph[i][(j + l + 1) % qsize]]);\n\n                    //cout << graph[i][(j + l) % qsize] << \" & \" << graph[i][(j + l + 1) % qsize] << endl;\n                    //cout << \"share is \" << tmp << endl;\n                }\n\n                if (isGraphCycle && qsize == k) {\n                    //cout << \"this is cycle\" << endl;\n                    share += c[graph[i][j % qsize]].shareS(c[graph[i][(j + k - 1) % qsize]]);\n                }\n\n                ans = min(ans, 6 * s * s * k - share);\n                //cout << \"all - share = \" << 6*s*s*k << endl;\n            }\n        }\n\n        if (n == 1) ans = 6 * s * s;\n        if (ans == int(1e15)) ans = -1;\n\n        cout << ans << endl;\n\n        //cout << \"---- end ----\" << endl;\n\n        c.clear();\n        graph.clear();\n        subg.clear();\n        used.clear();\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <cmath>\n#include <cstdlib>\n#include <map>\nusing namespace std;\n\nclass Point {\npublic:\n    int x, y, z;\n    Point(int x = 0, int y = 0, int z = 0) : x(x), y(y), z(z) {}\n};\n\nclass Cube {\npublic:\n    Point p;\n    int s;\n    int vx[4] = {0, 1, 1, 0}, vy[4] = {0, 0, 1, 1}, vz[2] = {0, 1};\n    Cube(Point p = Point(), int s = 0) : p(p), s(s) {}\n\n    bool isIn(const Cube &c) {\n        /*\n        int nx, ny, nz;\n        for (int i = 0; i < 2; ++i) {\n            for (int j = 0; j < 4; ++j) {\n                nx = c.p.x + c.s * vx[j];\n                ny = c.p.y + c.s * vy[j];\n                nz = c.p.z + c.s * vz[i];\n\n                if (p.x <= nx && nx <= p.x + s &&\n                    p.y <= ny && ny <= p.y + s &&\n                    p.z <= nz && nz <= p.z + s) {\n                        return true;\n                    }\n            }\n        return false;\n        }*/\n        return ((abs(p.x - c.p.x) <= s) && (abs(p.y - c.p.y) <= s) && (abs(p.z - c.p.z) <= s));\n    }\n\n    long long shareS(Cube &c) {\n        long long ret = 0;\n        Point a, b;\n        a = p; b = c.p;\n\n        if (a.x > b.x) swap(a.x, b.x);\n        if (a.y > b.y) swap(a.y, b.y);\n        if (a.z > b.z) swap(a.z, b.z);\n\n        ret += abs((a.x + s - b.x) * (a.z + s - b.z) * 2);\n        ret += abs((a.y + s - b.y) * (a.z + s - b.z) * 2);\n        ret += abs((a.x + s - b.x) * (a.y + s - b.y) * 2);\n        return ret;\n    }\n\n};\n\nint n, k, s, x, y, z;\nlong long ans;\nvector<Cube> c;\nvector<vector<int> > subg;\nvector<bool> used;\nvector<deque<int> > graph;\ndeque<int> que;\nmap<pair<int, int>, bool> mp, init;\n\n// not clever\ninline void makegraph(int v) {\n    for (int i = 0; i < n; ++i) {\n        if (!mp[make_pair(v, i)] && i != v && c[v].isIn(c[i])) {\n            subg[v].push_back(i);\n            subg[i].push_back(v);\n            mp[make_pair(v, i)] = true;\n            mp[make_pair(i, v)] = true;\n        }\n    }\n}\n\n// make path\nvoid dfs(int v) {\n    used[v] = true;\n    int size_ = subg[v].size();\n    bool flag = false;\n\n    for (int i = 0; i < size_; ++i) {\n        if (!used[subg[v][i]]) {\n            dfs(subg[v][i]);\n            if (!flag) que.push_front(v);\n            flag = true;\n        }\n    }\n\n    if (!flag) que.push_front(v);\n}\n\n// is graph[graphid] cycle ?\ninline bool isCycle(int graphid) {\n    int size_ = graph[graphid].size();\n\n    // if all vertex's degree are two, this graph is cycle.\n    for (int i = 0; i < size_; ++i) {\n        if (subg[graph[graphid][i]].size() != 2) return false;\n    }\n\n    return true;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    while (cin >> n >> k >> s, n | k | s) {\n        //cout << \"---- begin ----\" << endl;\n        c.resize(n);\n        subg.resize(n);\n        que.clear();\n        used.assign(n, false);\n        mp = init;\n        ans = int(1e15);\n\n        for (int i = 0; i < n; ++i) {\n            cin >> x >> y >> z;\n            c[i] = {Point(x, y, z), s};    \n        }\n\n        for (int i = 0; i < n; ++i) {\n            makegraph(i);\n        }\n\n        for (int i = 0; i < n; ++i) {\n            if (!used[i]) {\n                dfs(i);\n                graph.push_back(que);\n                que.clear();\n            }\n        }\n\n        /*\n        for (int i = 0; i < graph.size(); ++i) {\n            for (int j = 0; j < graph[i].size(); ++j) {\n                cout << graph[i][j] << \" \";\n            }\n            cout << endl;\n        }\n        */\n\n        int gsize = graph.size(), qsize, upper;\n        long long share;\n        bool isGraphCycle = false;\n\n        //cout << \"k = \" << k << endl;\n\n        for (int i = 0; i < gsize; ++i) {\n            qsize = graph[i].size();\n            isGraphCycle = isCycle(i);\n            if (isGraphCycle) {\n                upper = qsize + k - 1;\n            }\n            else upper = qsize;\n\n            if (qsize < k) continue;\n\n            for (int j = 0; j + k - 1 < upper; ++j) {\n                share = 0;\n                /*for (int l = 0; l < k - 1; ++l) {\n                    cout << graph[i][(j + l) % qsize] << \" \" << graph[i][(j + l + 1) % qsize] << endl;\n                }*/\n                //cout << graph[i][(j + k - 1) % qsize] << \" \" << graph[i][(j + k) % qsize] << endl;\n                //cout << endl;\n\n                for (int l = 0; l < k - 1; ++l) {\n                    //Cube a = c[graph[i][j + l]],\n                    //    b = c[graph[i][j + l + 1]];\n                    //cout << a.p.x << \" \" << a.p.y << \" \" << a.p.z << endl;\n                    //cout << b.p.x << \" \" << b.p.y << \" \" << b.p.z << endl;\n\n                    share += c[graph[i][(j + l) % qsize]].shareS(c[graph[i][(j + l + 1) % qsize]]);\n\n                    //cout << graph[i][(j + l) % qsize] << \" & \" << graph[i][(j + l + 1) % qsize] << endl;\n                    //cout << \"share is \" << tmp << endl;\n                }\n\n                if (isGraphCycle && qsize == k) {\n                    //cout << \"this is cycle\" << endl;\n                    share += c[graph[i][j]].shareS(c[graph[i][(j + qsize - 1) % qsize]]);\n                }\n\n                ans = min(ans, 6 * s * s * k - share);\n                //cout << \"all - share = \" << 6*s*s*k << endl;\n            }\n        }\n\n        if (n == 1) ans = 6 * s * s;\n        if (ans == int(1e15)) ans = -1;\n\n        cout << ans << endl;\n\n        //cout << \"---- end ----\" << endl;\n\n        c.clear();\n        graph.clear();\n        subg.clear();\n        used.clear();\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\nconst int INF = 1LL << 58;\n\nstruct edge\n{\n  int to, cost;\n};\n\nsigned main()\n{\n  int N, K, S;\n  int X[2000], Y[2000], Z[2000];\n\n  while(cin >> N >> K >> S, N) {\n    for(int i = 0; i < N; i++) {\n      cin >> X[i] >> Y[i] >> Z[i];\n    }\n\n    vector< edge > g[2000];\n    for(int i = 0; i < N; i++) {\n      for(int j = 0; j < i; j++) {\n        int latte = max(0LL, S - abs(X[i] - X[j]));\n        int malta = max(0LL, S - abs(Y[i] - Y[j]));\n        int beeet = max(0LL, S - abs(Z[i] - Z[j]));\n        int ukuku = latte * malta + malta * beeet + beeet * latte;\n        if(latte > 0 && malta > 0 && beeet > 0) {\n          g[i].emplace_back((edge) {j, ukuku});\n          g[j].emplace_back((edge) {i, ukuku});\n        }\n      }\n    }\n\n    int ret = -1;\n    for(int i = 0; i < N; i++) {\n      bool v[2000] = {};\n      function< void(int, int, int) > dfs = [&](int idx, int k, int sz)\n      {\n        if(v[idx]++) return;\n        if(k == 0) {\n          if(K >= 2) for(auto &e: g[idx]) if(e.to == i) sz += e.cost;\n          ret = max(ret, sz);\n        } else {\n          for(auto &e : g[idx]) dfs(e.to, k - 1, sz + e.cost);\n        }\n      };\n      dfs(i, K - 1, 0);\n    }\n    if(ret == -1) cout << -1 << endl;\n    else cout << 6 * S * S * K - ret * 2 << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define sar(a,n) cout<<#a<<\":\";rep(pachico,n)cout<<\" \"<<a[pachico];cout<<endl\n#define svec(v) cout<<#v<<\":\";rep(pachico,v.size())cout<<\" \"<<v[pachico];cout<<endl\n#define svecp(v) cout<<#v<<\":\";each(pachico,v)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n#define sset(s) cout<<#s<<\":\";each(pachico,s)cout<<\" \"<<pachico;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(pachico,m)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 100005;\n\nstruct edge\n{\n    int to;\n    ll cost;\n};\n\nstruct data\n{\n    ll x,y,z;\n};\n\nvoid dfs(int u,int p,int& vc, int& ed, vector<int>& visit, vector<vector<edge> >& G, vector<int>& v)\n{\n    v.pb(u);\n    visit[u] = vc++;\n    each(e,G[u]){\n        if(visit[e.to] < 0){\n            ed++;\n            dfs(e.to,u,vc,ed,visit,G,v);\n        }else if(visit[e.to] < visit[u] && e.to != p){\n            ed++;\n        }\n    }\n}\n\nll solve(ll x,ll y,ll z)\n{\n    return 2*(x*y+y*z+z*x);\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while(1){\n        int n,K;\n        ll s;\n        cin >> n >> K >> s;\n        if(n == 0) break;\n        vector<vector<edge> > G(n);\n        vector<data> vec(n);\n        rep(i,n){\n            ll x,y,z;\n            cin >> x >> y >> z;\n            vec[i] = (data){x,y,z};\n        }\n        rep(i,n){\n            srep(j,i+1,n){\n                data& p = vec[i], q = vec[j];\n                if(p.x <= q.x){\n                    if(q.x < p.x+s){\n                        if(p.y <= q.y){\n                            if(q.y < p.y+s){\n                                if(p.z <= q.z){\n                                    if(q.z < p.z+s){\n                                        ll val = solve(p.x+s-q.x,p.y+s-q.y,p.z+s-q.z);\n                                        G[i].pb((edge){j,val}), G[j].pb((edge){i,val});\n                                    }\n                                }else{\n                                    if(p.z < q.z+s){\n                                        ll val = solve(p.x+s-q.x,p.y+s-q.y,q.z+s-p.z);\n                                        G[i].pb((edge){j,val}), G[j].pb((edge){i,val});\n                                    }\n                                }\n                            }\n                        }else{\n                            if(p.y < q.y+s){\n                                if(p.z <= q.z){\n                                    if(q.z < p.z+s){\n                                        ll val = solve(p.x+s-q.x,q.y+s-p.y,p.z+s-q.z);\n                                        G[i].pb((edge){j,val}), G[j].pb((edge){i,val});\n                                    }\n                                }else{\n                                    if(p.z < q.z+s){\n                                        ll val = solve(p.x+s-q.x,q.y+s-p.y,q.z+s-p.z);\n                                        G[i].pb((edge){j,val}), G[j].pb((edge){i,val});\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }else{\n                    if(p.x < q.x+s){\n                        if(p.y <= q.y){\n                            if(q.y < p.y+s){\n                                if(p.z <= q.z){\n                                    if(q.z < p.z+s){\n                                        ll val = solve(q.x+s-p.x,p.y+s-q.y,p.z+s-q.z);\n                                        G[i].pb((edge){j,val}), G[j].pb((edge){i,val});\n                                    }\n                                }else{\n                                    if(p.z < q.z+s){\n                                        ll val = solve(q.x+s-p.x,p.y+s-q.y,q.z+s-p.z);\n                                        G[i].pb((edge){j,val}), G[j].pb((edge){i,val});\n                                    }\n                                }\n                            }\n                        }else{\n                            if(p.y < q.y+s){\n                                if(p.z <= q.z){\n                                    if(q.z < p.z+s){\n                                        ll val = solve(q.x+s-p.x,q.y+s-p.y,p.z+s-q.z);\n                                        G[i].pb((edge){j,val}), G[j].pb((edge){i,val});\n                                    }\n                                }else{\n                                    if(p.z < q.z+s){\n                                        ll val = solve(q.x+s-p.x,q.y+s-p.y,q.z+s-p.z);\n                                        G[i].pb((edge){j,val}), G[j].pb((edge){i,val});\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        ll mx = -1;\n        vector<int> visit(n,-1);\n        rep(i,n){\n            if(visit[i] < 0){\n                int vc = 0, ed = 0;\n                vector<int> v;\n                dfs(i,-1,vc,ed,visit,G,v);\n                if(vc < K){\n                    continue;\n                }\n                int st = i, p = -1;\n                if(vc != ed){\n                    each(j,v){\n                        if(len(G[j]) == 1){\n                            st = j;\n                            break;\n                        }\n                    }\n                    assert(st >= 0);\n                    int cnt = 0;\n                    deque<ll> deq;\n                    ll val = 0;\n                    bool ok = true;\n                    while(ok){\n                        show(st);\n                        ok = false;\n                        cnt++;\n                        each(e,G[st]){\n                            if(e.to != p){\n                                if(cnt+1 > K){\n                                    val -= deq.front();\n                                    deq.pop_front();\n                                }\n                                deq.pb(e.cost);\n                                val += e.cost;\n                                cmx(mx,val);\n                                p = st;\n                                st = e.to;\n                                ok = true;\n                                break;\n                            }\n                        }\n                    }\n                    cmx(mx,val);\n                }else{\n                    int cnt = 0;\n                    deque<ll> deq;\n                    ll val = 0;\n                    int nw = st;\n                    while(nw != st || cnt == 0){\n                        cnt++;\n                        each(e,G[nw]){\n                            if(e.to != p){\n                                if(cnt+1 > K){\n                                    val -= deq.front();\n                                    deq.pop_front();\n                                }\n                                deq.pb(e.cost);\n                                val += e.cost;\n                                cmx(mx,val);\n                                p = nw;\n                                nw = e.to;\n                                break;\n                            }\n                        }\n                    }\n                    cmx(mx,val);\n                }\n            }\n        }\n        if(mx < 0){\n            cout << \"-1\\n\";\n        }else{\n            cout << 6*s*s*K - mx << \"\\n\";\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;++i)\n\nint n,k,s;\nstruct Cube{\n\tint x,y,z;\n\tint node[2];\n\tint share;//with back cube\n\tint form;//-1:reseach now, 0:not visited, 1:line, 2:ring\n};\n\nvector<Cube> c;\nvector<int> graph;\n\n//return form\nint connect(int i,bool back){\n\t//it's found ring\n\tif(c[i].form == -1){\n\t\tgraph.push_back(i);\n\t\treturn 2;\n\t}\n\trep(j,n){\n\t\tif(i==j || c[j].form>0 || i==c[j].node[!back])continue;\n\t\tint sx = s-abs(c[i].x-c[j].x);\n\t\tint sy = s-abs(c[i].y-c[j].y);\n\t\tint sz = s-abs(c[i].z-c[j].z);\n\t\tif(sx<=0 || sy<=0 || sz<=0)continue;\n\t\t//connected\n\t\tc[i].node[!back] = j;\n\t\tc[j].node[back] = i;\n\t\tc[(back ? i : j)].share = 2*(sx*sy+sy*sz+sz*sx);\n\t\tc[i].form = -1;\n\t\tc[i].form = connect(j,back);\n\t\t//2:ring\n\t\tif(c[i].form==2)return 2;\n\t\t//1:line\n\t\tif(back)return 1;\n\t\tback=true;\n\t}\n\t//not found new connect\n\tif(back && c[i].node[0]==-1)graph.push_back(i);\n\treturn c[i].form = 1;\n}\n\nint main(){\n\twhile(cin>>n>>k>>s,n|k|s){\n\t\tc.clear();\n\t\tgraph.clear();\n\t\tint x,y,z;\n\t\trep(i,n){\n\t\t\tcin>>x>>y>>z;\n\t\t\tc.push_back(Cube{x,y,z,{-1,-1},0,0});\n\t\t}\n\t\trep(i,n)if(!c[i].form)connect(i,false);\n\t\tint maxsum = 0;\n\t\trep(i,(int)graph.size()){\n\t\t\tbool round = false;\n\t\t\tint tail = graph[i];\n\t\t\tint head = c[tail].node[1];\n\t\t\tint sum = 0, link = 0;\n\t\t\twhile(1){\n\t\t\t\tif(link+1==k)maxsum = max(sum,maxsum);\n\t\t\t\tif((round && tail==graph[i]) || head==-1)break;\n\t\t\t\tlink++;\n\t\t\t\tsum += c[head].share;\n\t\t\t\thead = c[head].node[1];\n\t\t\t\tround |= graph[i]==head;\n\t\t\t\t//(k or less)-ring\n\t\t\t\tif(round && link<k){\n\t\t\t\t\t//just k-ring\n\t\t\t\t\tif(link+1==k)maxsum = max(sum+c[head].share,maxsum);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(link == k){\n\t\t\t\t\ttail = c[tail].node[1];\n\t\t\t\t\tsum -= c[tail].share;\n\t\t\t\t\tlink--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<(maxsum||k==1 ? 6*s*s*k-maxsum : -1)<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <tuple>\nusing namespace std;\ntypedef pair<int,int> P;//to, cov\nvector<P> E[2000];\nbool used[2000];\n\nint n,k,s,S,ans;\n\nvoid dfs(int start, int v, int len, int sur){\n    used[v]=true;\n    // cout<<v<<' '<<len<<endl;\n    if(len==k) ans = min(ans,sur);\n    for(auto p:E[v]){\n        int to, cov;\n        tie(to,cov)=p;\n        if(to==start&&len==k){\n            ans = min(ans, sur-cov);\n        }else if(!used[to]){\n            dfs(start,to,len+1,sur+S-cov);\n        }\n    }\n    used[v]=false;\n}\n\nint main(){\n    while(cin>>n>>k>>s,n){\n        vector<int> X,Y,Z;\n        for(int i=0;i<2000;i++) E[i].clear();\n        S=s*s*6;\n        ans = 1000000000;\n        for(int i=0;i<n;i++){\n            int x,y,z;\n            cin>>x>>y>>z;\n            X.push_back(x);\n            Y.push_back(y);\n            Z.push_back(z);\n        }\n        for(int i=0;i<n;i++){\n            for(int j=0;j<n;j++){\n                if(i!=j){\n                    int dx = abs(X[i]-X[j]);\n                    int dy = abs(Y[i]-Y[j]);\n                    int dz = abs(Z[i]-Z[j]);\n                    if(dx<s&&dy<s&&dz<s){\n                        // cout<<i<<' '<<j<<':'<<dx<<' '<<dy<<' '<<dz<<endl;\n                        int cov=((s-dx)*(s-dy)+(s-dy)*(s-dz)+(s-dz)*(s-dx))*2;\n                        E[i].emplace_back(j,cov);\n                    }\n                }\n            }\n        }\n        for(int i=0;i<n;i++){\n            fill(used,used+n,false);\n            dfs(i,i,1,S);\n        }\n        if(ans==1000000000)ans=-1;\n        cout<<ans<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ninline int abs(int a, int b) {return a<b ? b-a : a-b;}\n\nint n, k, s;\n\nstruct cube\n{\n    int x, y, z;\n    cube() : x(0),y(0),z(0) {}\n    cube(int p, int q, int r) : x(p), y(q), z(r) {}\n\n    int intersect(const cube &o)\n    {\n        int ix = s - abs(this->x, o.x);\n        int iy = s - abs(this->y, o.y);\n        int iz = s - abs(this->z, o.z);\n        return (ix>0 && iy>0 && ix>0) ? 2*(ix*iy + iy*iz + iz*ix) : 0;\n    }\n\n};\n\nstruct vertex {\n    int num, deg, es[2], ws[2];\n    vertex() : num(0), deg(0) {es[0] = es[1] = ws[0] = ws[1] = 0;}\n    vertex(int n) : num(n), deg(0) {es[0] = es[1] = ws[0] = ws[1] = 0;}\n\n    int append(int o, int w)\n    {\n        es[deg] = o;\n        ws[deg++] = w;\n    }\n\n    int another(int i)\n    {\n        if(deg<2) return -1;\n        return es[0]==i ? es[1] : es[0];\n    }\n\n    int weight(int i)\n    {\n        return es[0]==i ? ws[0] : ws[1];\n    }\n};\n\nint search(int i, int k, vertex *vs, bool *checked)\n{\n    if(checked[i]) return -1;\n    checked[i] = true;\n    if(vs[i].deg == 0) return -1;\n    int p = vs[i].es[0];\n    checked[p] = true;\n    int e = i;\n    int vc = 1;\n    bool is_cycle = false, force_cycle = true;\n    if(vs[i].deg == 1)\n    {\n        p = i;\n    }\n    if(vs[i].deg == 2)\n    {\n        while(true)\n        {\n            if(vs[p].deg == 1)\n            {\n                break;\n            }\n            if(p==i)\n            {\n                is_cycle = true;\n                if(vc<k) return -1;\n                if(vc==k) force_cycle = true;\n                break;\n            }\n            int q = vs[p].another(e);\n            e = p;\n            p = q;\n            checked[q] = true;\n            vc++;\n        }\n    }\n    // search\n    deque<int> deq;\n    int sum = 0;\n    int max_sum = 0;\n    if(is_cycle)\n    {\n        // for cycle\n        int q = vs[p].es[0];\n        int w = vs[p].ws[0];\n        sum += w;\n        deq.push_back(w);\n        for(int j=(force_cycle ? 1 : 2); j<k; j++)\n        {\n            int r = vs[q].another(p);\n            w = vs[q].weight(r);\n            sum += w;\n            deq.push_back(w);\n            p = q;\n            q = r;\n        }\n        int qq = q;\n        max_sum = sum;\n        do\n        {\n            int r = vs[q].another(p);\n            w = vs[q].weight(r);\n            sum += w;\n            deq.push_back(w);\n            sum -= deq.front();\n            deq.pop_front();\n            max_sum = max(max_sum, sum);\n//            p = q;\n//            q = r;\n        }while(q != qq);\n    }\n    else\n    {\n        // for path\n        int q = vs[p].es[0];\n        checked[q] = true;\n        int w = vs[p].ws[0];\n        sum += w;\n        deq.push_back(w);\n        for(int j=2; j<k; j++)\n        {\n            if(vs[q].deg == 1) return -1;\n            int r = vs[q].another(p);\n            checked[r] = true;\n            w = vs[q].weight(r);\n            sum += w;\n            deq.push_back(w);\n            p = q;\n            q = r;\n        }\n        max_sum = sum;\n        while(vs[q].deg !=1)\n        {\n            int r = vs[q].another(p);\n            checked[r] = true;\n            w = vs[q].weight(r);\n            sum += w;\n            deq.push_back(w);\n            sum -= deq.front();\n            deq.pop_front();\n            max_sum = max(max_sum, sum);\n            p = q;\n            q = r;\n        }\n    }\n    return max_sum;\n}\n\nint main()\n{\n    while(cin >> n >> k >> s, n|k|s)\n    {\n        cube cs[n];\n        vertex vs[n];\n        for(int i=0; i<n; i++)\n        {\n            int x, y, z;\n            cin >> x >> y >> z;\n            cs[i] = cube(x,y,z);\n            vs[i] = vertex(i);\n            for(int j=0; j<i; j++)\n            {\n                int s = cs[j].intersect(cs[i]);\n                if(s>0)\n                {\n                    vs[j].append(i, s);\n                    vs[i].append(j, s);\n                }\n            }\n        }\n\n        if(k==1)\n        {\n            // k==1?\n            cout << 6 * s * s << endl;\n        }\n        else\n        {\n            // search\n            bool checked[n];\n            int result = -1;\n            for(int i=0; i<n; i++) checked[i] = false;\n            for(int i=0; i<n; i++)\n            {\n                result = max(result, search(i, k, vs, checked));\n            }\n            if(result>=0) result = 6 * s * s * k - result; \n            cout << result << endl;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\nusing namespace std;\n\nusing i64 = int64_t;\n\nstruct cube {\n    int x, y, z, w;\n    cube() {}\n    cube(int a, int b, int c, int d): x(a), y(b), z(c), w(d) {}\n\n    i64 area() {\n        return 6 * (i64)w * w;\n    }\n\n    i64 overlap_area(cube o) {\n        i64 ox = w - abs(x - o.x);\n        i64 oy = w - abs(y - o.y);\n        i64 oz = w - abs(z - o.z);\n\n        if (ox < 0 || oy < 0 || oz < 0) {\n            return -1;\n        }\n\n        return 2 * (ox * oy + oy * oz + oz * ox);\n    }\n};\n\nint main() {\n    int N, K, S;\n    while (true) {\n        cin >> N >> K >> S;\n        if (N == 0 && K == 0 && S == 0) break;\n\n        vector<cube> cubes;\n        vector<vector<int>> graph(N);\n\n        for (int j = 0; j < N; ++j) {\n            int x, y, z; cin >> x >> y >> z;\n            cubes.emplace_back(x, y, z, S);\n        }\n\n        for (int j = 0; j < N; ++j) {\n            for (int k = j+1; k < N; ++k) {\n                int area = cubes[j].overlap_area(cubes[k]);\n                if (area >= 0) {\n                    graph[j].push_back(k);\n                    graph[k].push_back(j);\n                }\n            }\n        }\n\n        i64 ans = -1;\n\n        vector<int> visited(N, 0);\n        for (int a = 0; a < N; ++a) {\n            if (visited[a]) continue;\n            visited[a] = 1;\n\n            bool loop = false;\n            int res = a;\n            for (int p = a, count = 1; p != -1; ++count) {\n                visited[p] = 1;\n                int np = -1;\n                for (int q: graph[p]) {\n                    if (count > 2 && q == a) {\n                        loop = true;\n                        break;\n                    }\n                    if (!visited[q]) {\n                        res = np = q;\n                        break;\n                    }\n                }\n                p = np;\n            }\n\n            vector<int> chain;\n            for (int p = res; p != -1; ) {\n                visited[p] = 1;\n                int np = -1;\n                chain.push_back(p);\n                for (int q: graph[p]) {\n                    if (chain.size() > 2 && q == res) {\n                        break; // loop\n                    }\n                    if (chain.size() <= 1 || chain[chain.size()-2] != q) {\n                        np = q;\n                        break;\n                    }\n                }\n                p = np;\n            }\n\n            if (chain.size() < K) {\n                continue;\n            }\n\n            const int L = chain.size();\n\n            i64 area = cubes[chain[0]].area();\n            if (K <= 1) {\n                ans = (ans == -1) ? area : min(ans, area);\n            }\n            for (int j = 1; j < (loop ? 2*L : L); ++j) {\n                if (j >= K) {\n                    int va = chain[(j-K)%L], vb = chain[(j-K+1)%L];\n                    area -= cubes[va].area() - cubes[va].overlap_area(cubes[vb]);\n                }\n                area += cubes[chain[j%L]].area() - cubes[chain[(j-1)%L]].overlap_area(cubes[chain[j%L]]);\n                if (loop && K == L && j == L-1) {\n                    area -= cubes[chain[0]].overlap_area(cubes[chain[L-1]]);\n                }\n                if (j+1 >= K) {\n                    ans = (ans == -1) ? area : min(ans, area);\n                }\n            }\n        }\n\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nstruct cube{\n  int x,y,z;\n  cube(){}\n  cube(int x,int y,int z):x(x),y(y),z(z){}\n};\n#define MAX 3000\nbool used[MAX];\nint c[MAX][MAX];\nvector<cube> vc;\nvector<int> vi;\nvector<vector<int> > G;\nbool dfs(int v,int g,int p){\n  bool f=false;\n  if(used[v]) return true;\n  vi.push_back(v);used[v]=1;\n  for(int i=0;i<G[v].size();i++) {\n    if(i&&!~p) reverse(vi.begin(),vi.end());\n    if(G[v][i]!=p) f|=dfs(G[v][i],g,v);\n  }\n  return f;\n}\nint main(){\n  int n,k,s,i,j,l,t;\n  while(cin>>n>>k>>s,n||k||s){\n    int ans=-1;\n    memset(c,0,sizeof(c));\n    G.clear();G.resize(n);\n    vc.clear();vc.resize(n);\n    for(i=0;i<n;i++) cin>>vc[i].x>>vc[i].y>>vc[i].z;\n    for(i=0;i<n;i++){\n      for(j=i+1;j<n;j++){\n        int xx=s-abs(vc[i].x-vc[j].x),\n          yy=s-abs(vc[i].y-vc[j].y),\n          zz=s-abs(vc[i].z-vc[j].z);\n        if(xx>0&&yy>0&&zz>0){\n          G[i].push_back(j);\n          G[j].push_back(i);\n          c[i][j]=c[j][i]=(xx*yy+yy*zz+zz*xx)*2;\n        }\n      }\n    }\n    memset(used,0,sizeof(used));\n    for(i=0;i<n;i++){\n      if(used[i]) continue;\n      vi.clear();\n      bool f=dfs(i,i,-1);\n      if(vi.size()<k) continue;\n      t=0;\n      if(f&&vi.size()==k){\n        for(j=0;j<k;j++) t+=c[vi[j]][vi[(j+1)%k]];\n        ans=max(ans,t);\n      }else{\n        for(j=0;j<k-1;j++) t+=c[vi[j]][vi[j+1]];\n        ans=max(ans,t);\n        for(j=0;j<vi.size()-k;j++){\n          t+=c[vi[k-1+j]][vi[k+j]]-c[vi[j]][vi[j+1]];\n          ans=max(ans,t);\n        } \n      }\n    }\n    if(~ans) cout << s*s*6*k-ans << endl;\n    else cout << -1 << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cassert>\n\nusing namespace std;\nusing ll = long long;\nconstexpr ll INF = 1LL << 50;\nll s;\n\nstruct Cube {\n    ll x;\n    ll y;\n    ll z;\n};\ninline ll connected(const Cube& c1, const Cube& c2)\n{\n    const ll dx = abs(c1.x - c2.x);\n    const ll dy = abs(c1.y - c2.y);\n    const ll dz = abs(c1.z - c2.z);\n    if (dx < s and dy < s and dz < s) {\n        return ((s - dx) * (s - dy) + (s - dy) * (s - dz) + (s - dz) * (s - dx)) * 2;\n    }\n    return 0;\n}\n\nstruct Edge {\n    int from;\n    int to;\n    ll cost;\n};\nstruct Graph {\n    Graph(const int n)\n    {\n        edge.resize(n);\n    }\n    void addEdge(const int from, const int to, const ll cost)\n    {\n        edge[from].push_back(Edge{from, to, cost});\n        edge[to].push_back(Edge{to, from, cost});\n    }\n    vector<vector<Edge>> edge;\n};\n\nint getEdge(const Graph& g, const int s, vector<bool>& visited)\n{\n    visited[s] = true;\n    int child = 0;\n    for (const auto& e : g.edge[s]) {\n        if (not visited[e.to]) {\n            return getEdge(g, e.to, visited);\n        }\n    }\n    if (child == 0) {\n        return s;\n    }\n}\nstruct Chain {\n    bool ring = false;\n    vector<ll> edges;\n};\nostream& operator<<(ostream& os, const Chain& ch)\n{\n    os << \"Ring: \" << boolalpha << ch.ring << \"\\nEdge: {\";\n    for (int i = 0; i < ch.edges.size(); i++) {\n        if (i != 0) {\n            os << \",\";\n        }\n        os << ch.edges[i];\n    }\n    os << \"}\" << endl;\n    return os;\n}\nvoid dfs(const Graph& g, const int s, const int dep, vector<bool>& visited, Chain& chain)\n{\n    visited[s] = true;\n    for (const auto& e : g.edge[s]) {\n        if (not visited[e.to]) {\n            chain.edges.push_back(e.cost);\n            dfs(g, e.to, dep, visited, chain);\n        }\n    }\n}\n\nint main()\n{\n    while (true) {\n        int n, k;\n        cin >> n >> k >> s;\n        if (n == 0 and k == 0 and s == 0) {\n            break;\n        }\n\n        const ll whole = 6 * s * s * k;\n        vector<Cube> cube(n);\n        for (int i = 0; i < n; i++) {\n            cin >> cube[i].x >> cube[i].y >> cube[i].z;\n        }\n        if (k == 1) {\n            cout << whole << endl;\n            continue;\n        }\n\n        Graph g(n);\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                const ll cost = connected(cube[i], cube[j]);\n                if (cost > 0) {\n                    g.addEdge(i, j, cost);\n                }\n            }\n        }\n        vector<bool> visited(n, false);\n        vector<Chain> chains;\n        for (int i = 0; i < n; i++) {\n            if (not visited[i]) {\n                vector<bool> visited2(n, false);\n                const int dep = getEdge(g, i, visited2);\n                Chain chain;\n                chain.ring = g.edge[dep].size() == 2;\n                if (chain.ring) {\n                    chain.edges.push_back(g.edge[dep][1].cost);\n                }\n                dfs(g, dep, dep, visited, chain);\n                chains.push_back(chain);\n            }\n        }\n        ll mini = INF;\n        for (const auto chain : chains) {\n            const bool ring = chain.ring;\n            const vector<ll>& costs = chain.edges;\n            if (costs.size() < k) {\n                continue;\n            }\n            if (ring) {\n                ll sum = 0;\n                for (int i = 0; i < k - 1; i++) {\n                    sum += costs[i];\n                }\n                if (costs.size() == k) {\n                    sum += costs[k - 1];\n                    mini = min(mini, whole - sum);\n                } else {\n                    mini = min(mini, whole - sum);\n                    int head = 0;\n                    int tail = k - 1;\n                    for (int j = 0; j < costs.size(); j++, head++, tail++, tail = tail % costs.size()) {\n                        sum += (costs[tail] - costs[head]);\n                        mini = min(mini, whole - sum);\n                    }\n                }\n            } else {\n                ll sum = 0;\n                for (int i = 0; i < k - 1; i++) {\n                    sum += costs[i];\n                }\n                mini = min(mini, whole - sum);\n                int head = 0;\n                int tail = k - 1;\n                for (; tail < costs.size(); head++, tail++) {\n                    sum += (costs[tail] - costs[head]);\n                    mini = min(mini, whole - sum);\n                }\n            }\n        }\n        cout << ((mini == INF) ? -1 : mini) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\n#define int ll\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define PB push_back\n\nconst ll LLINF = (1LL<<60);\nconst int INF = (1LL<<30);\nconst int MOD = 1000000007;\n\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate <typename T> bool IN(T a, T b, T x) { return a<=x&&x<b; }\ntemplate<typename T> T ceil(T a, T b) { return a/b + !!(a%b); }\ntemplate<class S,class T>\nostream &operator <<(ostream& out,const pair<S,T>& a){\n  out<<'('<<a.first<<','<<a.second<<')';\n  return out;\n}\ntemplate<class T>\nostream &operator <<(ostream& out,const vector<T>& a){\n  out<<'[';\n  REP(i, a.size()) {out<<a[i];if(i!=a.size()-1)out<<',';}\n  out<<']';\n  return out;\n}\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\nvector<PII> g[2010];\nbool used[2010];\nint n, k, s, ans = -INF, st;\n\nvoid dfs(int x, int m, int cost) {\n  used[x] = true;\n  if(m == k) {\n    for(auto e: g[x]) {\n      if(e.first == st) cost += e.second;\n    }\n    chmax(ans, cost);\n    return;\n  }\n  for(auto e: g[x]) {\n    if(used[e.first]) continue;\n    dfs(e.first, m+1, cost + e.second);\n  }\n}\n\nsigned main(void)\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  while(true) {\n    cin >> n >> k >> s;\n    if(!n) break;\n    VI x(n), y(n), z(n);\n    REP(i, n) cin >> x[i] >> y[i] >> z[i];\n\n    int dx[] = {0, s, 0, s, s, 0, s, 0},\n        dy[] = {0, 0, s, s, s, s, 0, 0},\n        dz[] = {0, 0, 0, 0, s, s, s, s};\n    ans = -INF;\n    REP(i, 2010) g[i].clear();\n    REP(i, n) FOR(j, i+1, n) {\n      // (i,j)が重複していたらその分の面積の重みの辺を張る\n      REP(k, 8) {\n        int nx = x[j] + dx[k], ny = y[j] + dy[k], nz = z[j] + dz[k];\n        if(x[i] <= nx && nx <= x[i]+s && y[i] <= ny && ny <= y[i]+s\n          && z[i] <= nz && nz <= z[i]+s) {\n          int nx1 = x[i] + dx[(k+4)%8], ny1 = y[i] + dy[(k+4)%8], nz1 = z[i] + dz[(k+4)%8];\n          int diffx = abs(nx - nx1), diffy = abs(ny - ny1), diffz = abs(nz - nz1);\n          int cost = 2*(diffx*diffy + diffy*diffz + diffz*diffx);\n          g[i].PB({j, cost});\n          g[j].PB({i, cost});\n          // cout << diffx << \",\" << diffy << \",\" << diffz << endl;\n          // cout << i << \" \" << j << \" \" << k << \" \" << cost << endl;\n          break;\n        }\n      }\n    }\n\n    REP(i, n) {\n      // iからk個取る\n      memset(used, 0, sizeof(used));\n      st = i;\n      dfs(i, 1, 0);\n    }\n\n    if(ans == -INF) cout << -1 << endl;\n    else cout << s*s*6*k - ans << endl;\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <math.h>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <bitset>\n#include <algorithm>\nusing namespace std;\n\nstruct xyz_t {\n    int x;\n    int y;\n    int z;\n    double length;       //一乗\n};\n\nstruct first_t {\n    int sec;\n    long long w;\n};\n\nbool asc(const xyz_t& left,const xyz_t& right);\nint next(int p,int q);\nint root(int p);\nvoid unite(int p,int q);\nint same(int p,int q);\nvoid pr(vector<vector<int> > pri);\n\nvector<xyz_t> a;\nvector<int> tree;\nvector<vector<int> > tree_f;\nvector<int> num;\nvector<int> flg;\nlong long ans;\nint n,k,s;\ndouble LE;\nlong long sum;\n\nint main(){\n  scanf (\"%d %d %d\",&n,&k,&s);\n  while(n){\n    ans=0;\n    LE=sqrt(s*s*3.0);\n    xyz_t aaa={0,0,0,0};\n    a.assign(n,aaa);\n    tree.assign(n,-1);\n    tree_f.assign(n,vector<int>(1,0));\n    num.assign(n,1);\n    flg.assign(n,0);\n    for(int t=0;t<n;t++){\n      scanf (\"%d %d %d\",&a[t].x,&a[t].y,&a[t].z);\n      a[t].length=sqrt(a[t].x*a[t].x*1.0+a[t].y*a[t].y*1.0+a[t].z*a[t].z*1.0);\n    }\n    sort(a.begin(),a.end(),asc);\n    for(int i=0;i<n;i++){\n      tree[i]=i;\n    }\n    vector<vector<int> > kaburi(n,vector<int> (n,0));\n    switch(k){\n      case 1:\n        printf(\"%d\\n\",s*s*6);\n        break;\n      case 3:\n        for(int t=0;t<n-1;++t){\n          for(int s=t+1;(a[s].length<a[t].length+LE&&s<n);++s){\n            int xx=next(a[t].x,a[s].x);\n            int yy=next(a[t].y,a[s].y);\n            int zz=next(a[t].z,a[s].z);\n            if(xx&&yy&&zz){\n              if(same(t,s)==0){\n                if(num[s]!=1){\n                  num[t]+=num[tree[s]];\n                  num[tree[s]]=0;\n                  unite(s,t);\n                }\n                else{\n                  num[s]+=num[tree[t]];\n                  num[tree[t]]=0;\n                  unite(t,s);\n                }\n                kaburi[s][t]=xx*yy+yy*zz+zz*xx;\n                kaburi[t][s]=kaburi[s][t];\n                //printf(\"%d %d %d\\n\",kaburi[q].back());\n                //printf(\"%d %d %d\\n\",xx,yy,zz);\n              }\n              else{\n                kaburi[s][t]=xx*yy+yy*zz+zz*xx;\n                kaburi[t][s]=kaburi[s][t];\n                if(num[s]==0){\n                  flg[t]=1;\n                }\n                else{\n                  flg[s]=1;\n                }\n              }\n            }\n          }\n        }\n        //pr(kaburi);\n        for(int t=0;t<n;++t){\n          sum=0;\n          if(num[t]>=k){\n            if(flg[t]==0){\n              int u=t;\n              int v=0;\n              int uu=t;\n              tree_f[t][0]=t;\n              for(int r=0;r<k-1;++r){\n                while(kaburi[u][v]==0||v==uu){\n                  ++v;\n                }\n                sum+=kaburi[u][v];\n                tree_f[t].push_back(v);\n                uu=u;\n                u=v;\n                v=0;\n              }\n              for(int r=k-1;r<num[t]-1;++r){\n                while(kaburi[u][v]==0||v==uu){\n                  ++v;\n                }\n                tree_f[t].push_back(v);\n                uu=u;\n                u=v;\n                v=0;\n              }\n              if(ans<sum){\n                ans=sum;\n              }\n              for(int r=0;r+k<num[t];++r){\n                sum=sum-kaburi[tree_f[t][r]][tree_f[t][r+1]]+kaburi[tree_f[t][r+k-1]][tree_f[t][r+k]];\n\n                if(ans<sum){\n                  ans=sum;\n                }\n              }\n            }\n            else{\n              if(num[t]!=k){\n                int u=t;\n                int v=0;\n                int uu=t;\n                tree_f[t][0]=t;\n                for(int r=0;r<k-1;++r){\n                  while(kaburi[u][v]==0||v==uu){\n                    ++v;\n                  }\n                  sum+=kaburi[u][v];\n                  tree_f[t].push_back(v);\n                  uu=u;\n                  u=v;\n                  v=0;\n                }\n                for(int r=k-1;r<num[t]*2;++r){\n                  while(kaburi[u][v]==0||v==uu){\n                    ++v;\n                  }\n                  tree_f[t].push_back(v);\n                  uu=u;\n                  u=v;\n                  v=0;\n                }\n                if(ans<sum){\n                  ans=sum;\n                }\n                for(int r=0;r<num[t];++r){\n                  sum=sum-kaburi[tree_f[t][r]][tree_f[t][r+1]]+kaburi[tree_f[t][r+k-1]][tree_f[t][r+k]];\n                  if(ans<sum){\n                    ans=sum;\n                  }\n                  //printf(\"%lld\\n\",sum);\n                }\n                //pr(tree_f);\n              }\n              else{\n                if(k!=3){\n                  int u=t;\n                  int v=0;\n                  int uu=t;\n                  tree_f[t][0]=t;\n                  for(int r=0;r<k;++r){\n                    while(kaburi[u][v]==0||v==uu){\n                      ++v;\n                    }\n                    sum+=kaburi[u][v];\n                    uu=u;\n                    u=v;\n                    v=0;\n                  }\n                  if(ans<sum){\n                    ans=sum;\n                  }\n                }\n                else{\n                  int u=t;\n                  int v=0;\n                  int uu=t;\n                  tree_f[t][0]=t;\n                  for(int r=0;r<k;++r){\n                    while(kaburi[u][v]==0||v==uu){\n                      ++v;\n                    }\n                    sum+=kaburi[u][v];\n                    tree_f[t].push_back(v);\n                    uu=u;\n                    u=v;\n                    v=0;\n                  }\n                  int xxx=s+min({a[tree_f[t][0]].x,a[tree_f[t][1]].x,a[tree_f[t][2]].x})-max({a[tree_f[t][0]].x,a[tree_f[t][1]].x,a[tree_f[t][2]].x});\n                  int yyy=s+min({a[tree_f[t][0]].y,a[tree_f[t][1]].y,a[tree_f[t][2]].y})-max({a[tree_f[t][0]].y,a[tree_f[t][1]].y,a[tree_f[t][2]].y});\n                  int zzz=s+min({a[tree_f[t][0]].z,a[tree_f[t][1]].z,a[tree_f[t][2]].z})-max({a[tree_f[t][0]].z,a[tree_f[t][1]].z,a[tree_f[t][2]].z});\n                  sum=sum-(xxx*yyy+yyy*zzz+zzz*xxx);\n                  if(ans<sum){\n                    ans=sum;\n                  }\n                }\n              }\n            }\n          }\n        }\n        if(ans==0){\n          printf(\"-1\\n\");\n        }\n        else{\n          printf(\"%lld\\n\",s*s*6*k-ans*2);\n        }\n        break;\n      default:\n        for(int t=0;t<n-1;++t){\n          for(int s=t+1;(a[s].length<a[t].length+LE&&s<n);++s){\n            int xx=next(a[t].x,a[s].x);\n            int yy=next(a[t].y,a[s].y);\n            int zz=next(a[t].z,a[s].z);\n            if(xx&&yy&&zz){\n              if(same(t,s)==0){\n                if(num[s]!=1){\n                  num[t]+=num[tree[s]];\n                  num[tree[s]]=0;\n                  unite(s,t);\n                }\n                else{\n                  num[s]+=num[tree[t]];\n                  num[tree[t]]=0;\n                  unite(t,s);\n                }\n                kaburi[s][t]=xx*yy+yy*zz+zz*xx;\n                kaburi[t][s]=kaburi[s][t];\n                //printf(\"%d %d %d\\n\",kaburi[q].back());\n                //printf(\"%d %d %d\\n\",xx,yy,zz);\n              }\n              else{\n                kaburi[s][t]=xx*yy+yy*zz+zz*xx;\n                kaburi[t][s]=kaburi[s][t];\n                if(num[s]==0){\n                  flg[t]=1;\n                }\n                else{\n                  flg[s]=1;\n                }\n              }\n            }\n          }\n        }\n        //pr(kaburi);\n        for(int t=0;t<n;++t){\n          sum=0;\n          if(num[t]>=k){\n            if(flg[t]==0){\n              int u=t;\n              int v=0;\n              int uu=t;\n              tree_f[t][0]=t;\n              for(int r=0;r<k-1;++r){\n                while(kaburi[u][v]==0||v==uu){\n                  ++v;\n                }\n                sum+=kaburi[u][v];\n                tree_f[t].push_back(v);\n                uu=u;\n                u=v;\n                v=0;\n              }\n              for(int r=k-1;r<num[t]-1;++r){\n                while(kaburi[u][v]==0||v==uu){\n                  ++v;\n                }\n                tree_f[t].push_back(v);\n                uu=u;\n                u=v;\n                v=0;\n              }\n              if(ans<sum){\n                ans=sum;\n              }\n              for(int r=0;r+k<num[t];++r){\n                sum=sum-kaburi[tree_f[t][r]][tree_f[t][r+1]]+kaburi[tree_f[t][r+k-1]][tree_f[t][r+k]];\n\n                if(ans<sum){\n                  ans=sum;\n                }\n              }\n            }\n            else{\n              if(num[t]!=k){\n                int u=t;\n                int v=0;\n                int uu=t;\n                tree_f[t][0]=t;\n                for(int r=0;r<k-1;++r){\n                  while(kaburi[u][v]==0||v==uu){\n                    ++v;\n                  }\n                  sum+=kaburi[u][v];\n                  tree_f[t].push_back(v);\n                  uu=u;\n                  u=v;\n                  v=0;\n                }\n                for(int r=k-1;r<num[t]*2;++r){\n                  while(kaburi[u][v]==0||v==uu){\n                    ++v;\n                  }\n                  tree_f[t].push_back(v);\n                  uu=u;\n                  u=v;\n                  v=0;\n                }\n                if(ans<sum){\n                  ans=sum;\n                }\n                for(int r=0;r<num[t];++r){\n                  sum=sum-kaburi[tree_f[t][r]][tree_f[t][r+1]]+kaburi[tree_f[t][r+k-1]][tree_f[t][r+k]];\n                  if(ans<sum){\n                    ans=sum;\n                  }\n                  //printf(\"%lld\\n\",sum);\n                }\n                //pr(tree_f);\n              }\n              else{\n                int u=t;\n                int v=0;\n                int uu=t;\n                tree_f[t][0]=t;\n                for(int r=0;r<k;++r){\n                  while(kaburi[u][v]==0||v==uu){\n                    ++v;\n                  }\n                  sum+=kaburi[u][v];\n                  uu=u;\n                  u=v;\n                  v=0;\n                }\n                if(ans<sum){\n                  ans=sum;\n                }\n              }\n            }\n          }\n        }\n        if(ans==0){\n          printf(\"-1\\n\");\n        }\n        else{\n          printf(\"%lld\\n\",s*s*6*k-ans*2);\n        }\n    }\n    scanf (\"%d %d %d\",&n,&k,&s);\n  }\n}\n/*\n環状 k=3の時 それ以外の時\n\n\n*/\n\n\nbool asc(const xyz_t& left,const xyz_t& right){\n  return left.length<right.length;\n}\n\nint next(int p,int q){\n  if(-s<=(p-q)&&(p-q)<=s){\n    if((p-q)>=0){\n      return s-(p-q);\n    }\n    else{\n      return s-(q-p);\n    }\n  }\n  else{\n    return 0;\n  }\n}\n\nint root(int p){\n  if (tree[p] == p){// 根\n    return p;\n  }\n  else {\n    return tree[p] = root(tree[p]); // 経路圧縮\n  }\n}\n\nvoid unite(int p, int q){\n  p = root(p);\n  q = root(q);\n  if (p == q){}\n  else{\n    tree[p] = q;     //pの親をqの親にする\n  }\n}\n\nint same(int p, int q){\n  return root(p) == root(q);\n}\n\n\n\nvoid pr(vector<vector<int> > pri){\n  for(int t=0;t<int(pri.size());++t){\n    for(int s=0;s<int(pri[t].size())-1;++s){\n      printf(\"%d \",pri[t][s]);\n    }\n    printf(\"%d\\n\",pri[t][pri[t].size()-1]);\n  }\n  printf(\"\\n\");\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\n#define int ll\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define PB push_back\n\nconst ll LLINF = (1LL<<60);\nconst int INF = (1LL<<30);\nconst int MOD = 1000000007;\n\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate <typename T> bool IN(T a, T b, T x) { return a<=x&&x<b; }\ntemplate<typename T> T ceil(T a, T b) { return a/b + !!(a%b); }\ntemplate<class S,class T>\nostream &operator <<(ostream& out,const pair<S,T>& a){\n  out<<'('<<a.first<<','<<a.second<<')';\n  return out;\n}\ntemplate<class T>\nostream &operator <<(ostream& out,const vector<T>& a){\n  out<<'[';\n  REP(i, a.size()) {out<<a[i];if(i!=a.size()-1)out<<',';}\n  out<<']';\n  return out;\n}\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\nvector<PII> g[2010];\nbool used[2010];\nint n, k, s, ans = -INF, st;\n\nvoid dfs(int x, int m, int cost) {\n  used[x] = true;\n  if(m == k) {\n    for(auto e: g[x]) {\n      if(e.first == st && m > 2) cost += e.second;\n    }\n    chmax(ans, cost);\n    return;\n  }\n  for(auto e: g[x]) {\n    if(used[e.first]) continue;\n    dfs(e.first, m+1, cost + e.second);\n  }\n}\n\nsigned main(void)\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  while(true) {\n    cin >> n >> k >> s;\n    if(!n) break;\n    VI x(n), y(n), z(n);\n    REP(i, n) cin >> x[i] >> y[i] >> z[i];\n\n    ans = -INF;\n    REP(i, 2010) g[i].clear();\n    REP(i, n) FOR(j, i+1, n) {\n      // (i,j)が重複していたらその分の面積の重みの辺を張る\n      int dx = abs(x[i] - x[j]), dy = abs(y[i] - y[j]), dz = abs(z[i] - z[j]);\n      if(dx <= s && dy <= s && dz <= s) {\n        int cost = 2 * ((s-dx)*(s-dy) + (s-dy)*(s-dz) + (s-dz)*(s-dx));\n        g[i].PB({j, cost});\n        g[j].PB({i, cost});\n        // cout << i << \" \" << j << \" \" << cost << endl;\n      }\n    }\n\n    REP(i, n) {\n      // iからk個取る\n      memset(used, 0, sizeof(used));\n      st = i;\n      dfs(i, 1, 0);\n    }\n\n    // cout << s*s*6*k << \" \" << ans << endl;\n    if(ans == -INF) cout << -1 << endl;\n    else cout << s*s*6*k - ans << endl;\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nstruct edge {\n\tconst int to, cost;\n\tedge(const int to_, const int cost_):to(to_), cost(cost_) {}\n};\nusing Graph = vector<vector<edge>>;\nconstexpr int INF = (1 << 29);\nconstexpr int MAX_N = 2000;\nbool used[MAX_N];\n\ninline int calc(const int x1, const int y1, const int z1, const int x2, const int y2, const int z2, const int s) {\n\tconst int dx = s - abs(x1 - x2);\n\tconst int dy = s - abs(y1 - y2);\n\tconst int dz = s - abs(z1 - z2);\n\tif(min({dx, dy, dz}) <= 0) return 0;\n\treturn 2 * (dx * dy + dy * dz + dz * dx);\n}\n\nint dfs(const int v, const int p, const int rest, const Graph &G) {\n\tif(rest == 0) {\n\t\tint res = 0;\n\t\tfor(const auto &e : G[v]) {\n\t\t\tif(used[e.to] && e.to != p) res += e.cost;\n\t\t}\n\t\treturn res;\n\t}\n\tused[v] = true;\n\tint res = -INF;\n\tfor(const auto &e : G[v]) {\n\t\tif(!used[e.to]) res = max(res, dfs(e.to, v, rest - 1, G) + e.cost);\n\t}\n\tused[v] = false;\n\treturn res;\n}\n\nint main() {\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\tfor(int n, k, s; cin >> n >> k >> s && n;) {\n\t\tvector<int> x(n), y(n), z(n);\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\tcin >> x[i] >> y[i] >> z[i];\n\t\t}\n\n\t\tGraph G(n);\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\tfor(int j = i + 1; j < n; ++j) {\n\t\t\t\tconst int area = calc(x[i], y[i], z[i], x[j], y[j], z[j], s);\n\t\t\t\tif(area) {\n\t\t\t\t\tG[i].emplace_back(j, area);\n\t\t\t\t\tG[j].emplace_back(i, area);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint mx = -INF;\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\tmx = max(mx, dfs(i, -1, k - 1, G));\n\t\t}\n\t\tcout << (mx < 0 ? -1 : s * s * 6 * k - mx) << endl;\n\t}\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define pb push_back\nvoid dump(vector<int> &v){\n\tfor(int i=0;i<v.size();i++){\n\t\tcout << v[i] << ' ';\n\t}\n\tcout << endl;\n}\nint n,k,s;\nint x[2010],y[2010],z[2010];\nint c[2010][2010];\nstruct edge{\n\tint to,cost;\n\tedge(){}\n\tedge(int to,int cost):to(to),cost(cost){}\n};\nbool used[2010];\nvector<edge> g[2010];\nint lap(int *w,int a,int b){\n\tint d = abs(w[a]-w[b]);\n\tif(d<s)return s-d;\n\telse return -1;\n}\nint f(int a,int b){\n\tint X = lap(x,a,b);\n\tint Y = lap(y,a,b);\n\tint Z= lap(z,a,b);\n\tif(X==-1||Y==-1||Z==-1)return 0;\n\treturn 2*X*Y+2*Y*Z+2*Z*X;\n}\nvector<int> path;\nvoid dfs(int v,int p){\n\tused[v]=true;\n\tpath.pb(v);\n\tfor(int i=0;i<g[v].size();i++){\n\t\tint u = g[v][i].to;\n\t\tif(u==p)continue;\n\t\tif(!used[u])dfs(u,v);\n\t}\n}\nint sol_sub_path(){\n\tint s = 0;\n\tint t = 0;\n\tint res = 0;\n\tint cur = 0;\n\tint ps = path.size();\n\tif(k==1)return 0;\n\tif(ps<k)return -1;\n\telse{\n\t\tfor(int i=0;i<(k-1);i++){\n\t\t\tcur += c[path[i]][path[i+1]];\n\t\t}\n\t\tres = cur;\n\t\tfor(int i=0;i<ps-k;i++){\n\t\t\tcur -= c[path[i]][path[i+1]];\n\t\t\tcur += c[path[i+k-1]][path[(i+k)]];\n\t\t\tres = max(res,cur);\n\t\t}\n\t}\n\treturn res;\n}\nint sol_sub_loop(){\n\tint s = 0;\n\tint t = 0;\n\tint res = 0;\n\tint cur = 0;\n\tint ps = path.size();\n\tif(k==1)return 0;\n\tif(ps<k)return -1;\n\telse if(ps==k){\n\t\tfor(int i=0;i<ps;i++){\n\t\t\tres += c[path[i]][path[(i+1)%ps]];\n\t\t}\n\t\treturn res;\n\t}else{\n\t\t/*while(t<path.size()){\n\t\t\twhile(t<path.size()&&t-s+1<k){\n\t\t\t\tcur += c[path[t]][path[(t+1)%ps]];\n\t\t\t\tt++;\n\t\t\t}\n\t\t\t//cout << s << ' ' << t << ' ' << cur << endl;\n\t\t\tif(t-s+1<k)return res;\n\t\t\tres = max(res,cur);\n\t\t\tcur -= c[path[s]][path[s+1]];\n\t\t\ts++;\n\t\t}*/\n\t\tfor(int i=0;i<(k-1);i++){\n\t\t\tcur += c[path[i]][path[i+1]];\n\t\t}\n\t\tres = cur;\n\t\tfor(int i=0;i<ps;i++){\n\t\t\tcur -= c[path[i]][path[(i+1)%ps]];\n\t\t\tcur += c[path[(i+k-1)%ps]][path[(i+k)%ps]];\n\t\t\tres = max(res,cur);\n\t\t}\n\t}\n\treturn res;\n}\nbool solve(){\n\tscanf(\"%d %d %d\",&n,&k,&s);\n\tif(n==0&&k==0&&s==0)return false;\n\tfor(int i=0;i<n;i++){\n\t\tscanf(\"%d %d %d\",&x[i],&y[i],&z[i]);\n\t}\n\tmemset(used,false,sizeof(used));\n\tfor(int i=0;i<n;i++)g[i].clear();\n\tmemset(c,0,sizeof(c));\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=i+1;j<n;j++){\n\t\t\tc[i][j] = c[j][i] = f(i,j);\n\t\t\tif(c[i][j]!=0){\n\t\t\t\tg[i].pb(edge(j,c[i][j]));\n\t\t\t\tg[j].pb(edge(i,c[i][j]));\n\t\t\t}\n\t\t}\n\t}\n\t/*for(int i=0;i<n;i++){\n\t\tcout << i << \": \";\n\t\tfor(int j=0;j<g[i].size();i++){\n\t\t\tcout << g[i][j].to << ' ';\n\t\t}\n\t\tcout << endl;\n\t}*/\n\t/*for(int i=0;i<n;i++){\n\t\tfor(int j=0;j<n;j++){\n\t\t\tcout << c[i][j] << ' ';\n\t\t}\n\t\tcout << endl;\n\t}*/\n\tint ans = -1;\n\tfor(int i=0;i<n;i++){\n\t\tif(!used[i]&&g[i].size()==1){\n\t\t\tused[i]=true;\n\t\t\tpath.clear();\n\t\t\tdfs(i,-1);\n\t\t\t//dump(path);\n\t\t\tint res = sol_sub_path();\n\t\t\t//cout << res << endl;\n\t\t\tans = max(ans,res);\n\t\t}\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tif(!used[i]){\n\t\t\tused[i]=true;\n\t\t\tpath.clear();\n\t\t\tdfs(i,-1);\n\t\t\t//dump(path);\n\t\t\tint res = sol_sub_loop();\n\t\t\t//cout << res << endl;\n\t\t\tans = max(ans,res);\n\t\t}\n\t}\n\tif(ans==-1)printf(\"-1\\n\");\n\telse printf(\"%d\\n\",s*s*6*k-ans);\n\treturn true;\n}\nint main() {\n\twhile (solve());\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nstruct cube{\n  int x,y,z;\n  cube(){}\n  cube(int x,int y,int z):x(x),y(y),z(z){}\n};\n#define MAX 3000\nbool used[MAX];\nint c[MAX][MAX];\nvector<cube> vc;\nvector<int> vi;\nvector<vector<int> > G;\nbool dfs(int v,int g,int p){\n  bool f=false;\n  if(used[v]) return true;\n  vi.push_back(v);used[v]=1;\n  for(int i=0;i<G[v].size();i++) {\n    if(i&&v==g) reverse(vi.begin(),vi.end());\n    if(G[v][i]!=p) f|=dfs(G[v][i],g,v);\n  }\n  return f;\n}\nint main(){\n  int n,k,s,i,j,l,t;\n  while(cin>>n>>k>>s,n||k||s){\n    int ans=-1;\n    memset(c,0,sizeof(c));\n    G.clear();G.resize(n);\n    vc.clear();vc.resize(n);\n    for(i=0;i<n;i++) cin>>vc[i].x>>vc[i].y>>vc[i].z;\n    for(i=0;i<n;i++){\n      for(j=i+1;j<n;j++){\n        int xx=s-abs(vc[i].x-vc[j].x),\n          yy=s-abs(vc[i].y-vc[j].y),\n          zz=s-abs(vc[i].z-vc[j].z);\n        if(xx>0&&yy>0&&zz>0){\n          G[i].push_back(j);\n          G[j].push_back(i);\n          c[i][j]=c[j][i]=(xx*yy+yy*zz+zz*xx)*2;\n        }\n      }\n    }\n    memset(used,0,sizeof(used));\n    for(i=0;i<n;i++){\n      if(used[i]) continue;\n      vi.clear();\n      bool f=dfs(i,i,-1);\n      if(vi.size()<k) continue;\n      t=0;\n      if(f&&vi.size()==k){\n        for(j=0;j<k;j++) t+=c[vi[j]][vi[(j+1)%k]];\n        ans=max(ans,t);\n      }else{\n        for(j=0;j<k-1;j++) t+=c[vi[j]][vi[j+1]];\n        ans=max(ans,t);\n        for(j=0;j<vi.size()-k;j++){\n          t+=c[vi[k-1+j]][vi[k+j]]-c[vi[j]][vi[j+1]];\n          ans=max(ans,t);\n        } \n      }\n    }\n    if(~ans) cout << s*s*6*k-ans << endl;\n    else cout << -1 << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing P = pair<int, ll>;\n\nint main()\n{\n\tll n, k, s;\n\twhile (cin >> n >> k >> s, n | k | s) {\n\t\tvector<ll> x(n), y(n), z(n);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcin >> x[i] >> y[i] >> z[i];\n\t\t}\n\t\tif (k == 1) {\n\t\t\tcout << s * s * 6 << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tvector<vector<P>> G(n);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tif (i != j) {\n\t\t\t\t\tll dx = s - abs(x[i] - x[j]), dy = s - abs(y[i] - y[j]), dz = s - abs(z[i] - z[j]);\n\t\t\t\t\tif (dx > 0 && dy > 0 && dz > 0) {\n\t\t\t\t\t\tG[i].push_back(P(j, dx * dy * 2 + dy * dz * 2 + dz * dx * 2));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tll res = s * s * 6 * k, d = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tvector<int> v;\n\t\t\tvector<ll> used(n);\n\t\t\tll tmp = 0;\n\t\t\tbool flag = true;\n\t\t\tused[i] = -1;\n\t\t\tfor (auto p : G[i]) {\n\t\t\t\tused[p.first] += p.second;\n\t\t\t\tv.push_back(p.first);\n\t\t\t}\n\t\t\tfor (int j = 0; j < k - 1; j++) {\n\t\t\t\twhile (!v.empty() && used[v.back()] < 0) {\n\t\t\t\t\tv.pop_back();\n\t\t\t\t}\n\t\t\t\tif (v.empty()) {\n\t\t\t\t\tflag = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tauto ne = v.back(); v.pop_back();\n\t\t\t\ttmp += used[ne];\n\t\t\t\tused[ne] = -1;\n\t\t\t\tfor (auto p : G[ne]) {\n\t\t\t\t\tif (used[p.first] >= 0) {\n\t\t\t\t\t\tused[p.first] += p.second;\n\t\t\t\t\t\tv.push_back(p.first);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (flag) {\n\t\t\t\td = max(d, tmp);\n\t\t\t}\n\t\t}\n\t\tcout << (d ? res - d : -1) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "s\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i,n) for(int i = 0;i < (n);i++)\nconst long long INF = 1e+10;\nusing namespace std;\n\nint N, K, S;\n\nstruct Point{\n    int x, y, z;\n};\n\nPoint p[2103];\n\nbool iscycle[2103];\nbool used[2103];\ndeque<int> graph[2103];\n\nint getS(Point a,Point b){\n    if(a.x > b.x) swap(a.x, b.x);\n    if(a.y > b.y) swap(a.y, b.y);\n    if(a.z > b.z) swap(a.z, b.z);\n    return (a.x + S - b.x) * (a.y + S - b.y) * 2\n        +  (a.z + S - b.z) * (a.x + S - b.x) * 2\n        +  (a.y + S - b.y) * (a.z + S - b.z) * 2;\n}\n\nbool connected(int a,int b){\n    return (abs(p[a].x-p[b].x) <= S) && (abs(p[a].y-p[b].y) <= S) && (abs(p[a].z-p[b].z) <= S);\n}\n\nvoid makegraph(int graphct, int i, bool maincalled, bool back){\n    REP(j,N){\n        if(used[j])continue;\n        if(connected(i,j)){\n            used[j] = true;\n            if(graph[graphct].size() > 1 && (maincalled || back)){\n                graph[graphct].push_front(j);\n                makegraph(graphct, j, false, true);\n            }else{\n                graph[graphct].push_back(j);\n                makegraph(graphct, j, false, false);\n            }\n        }\n    }\n}\n\n\nint main(){\n    while(cin >> N >> K >> S, N){\n        REP(i,N){\n            int x, y, z;\n            cin >> x >> y >> z;\n            p[i] = Point{x, y, z};\n            graph[i].clear();\n            iscycle[i] = false;\n            used[i] = false;\n        }\n\n        //make graph\n        int graphct = 0;\n        REP(i,N){\n            if(used[i]) continue;\n            graph[graphct].push_back(i);\n            used[i] = true;\n            makegraph(graphct, i, true, true);\n            graphct++;\n        }\n        \n        //k == 1\n        if(K == 1){\n            cout << S*S*6 << endl;\n            continue;\n        }\n\n        //cycle check\n        REP(i,graphct){\n            if(graph[i].size() > 2 && connected(graph[i][0],graph[i][graph[i].size() - 1]))\n                iscycle[i] = true;\n        }\n        \n        long long ans = INF;\n        REP(i,graphct){\n            if((int)graph[i].size() < K) continue;\n            REP(j,graph[i].size()){\n                if(j + K - 1 > graph[i].size() - 1) break;\n                long long tmpans = 0;\n                for(int r = 0; r < K;r++){\n                    tmpans += S*S*6;\n                    if(r){\n                        tmpans -= getS(p[graph[i][j + r]], p[graph[i][j + r - 1]]);\n                    }else if(iscycle[i] && (K == (int)graph[i].size())){\n                        tmpans -= getS(p[graph[i][0]], p[graph[i][graph[i].size() - 1]]);\n                    }\n                }\n                ans = min(tmpans, ans);\n            }\n        }\n        if(ans == INF) cout << -1 << endl;\n        else cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<deque>\n#include<algorithm>\nusing namespace std;\nint N,K,S;\nint X[3][2000];\nstruct UF{\n\tint N;\n\tvector<int>p,sz;\n\tUF(int n):N(n),p(n),sz(n,1){\n\t\tfor(int i=0;i<N;i++)p[i]=i;\n\t}\n\tint find(int u)\n\t{\n\t\tif(p[u]==u)return u;\n\t\telse return p[u]=find(p[u]);\n\t}\n\tbool unite(int u,int v)\n\t{\n\t\tu=find(u),v=find(v);\n\t\tif(u==v)return false;\n\t\tif(sz[u]<sz[v])\n\t\t{\n\t\t\tp[u]=v;\n\t\t\tsz[v]+=sz[u];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tp[v]=u;\n\t\t\tsz[u]+=sz[v];\n\t\t}\n\t\treturn true;\n\t}\n};\nvector<long>A;\nbool dfs(int u,int p,int out,vector<vector<pair<int,long> > >&G)\n{\n\tif(u==out)\n\t{\n\t\treturn true;\n\t}\n\tbool ret=false;\n\tfor(pair<int,long>&q:G[u])\n\t{\n\t\tif(q.first!=p)\n\t\t{\n\t\t\tA.push_back(q.second);\n\t\t\tret|=dfs(q.first,u,out,G);\n\t\t}\n\t}\n\treturn ret;\n}\nmain()\n{\n\twhile(cin>>N>>K>>S,N)\n\t{\n\t\tfor(int i=0;i<N;i++)\n\t\t{\n\t\t\tfor(int j=0;j<3;j++)cin>>X[j][i];\n\t\t}\n\t\tvector<pair<pair<int,int>,long> >E;\n\t\tUF uf(N);\n\t\tvector<vector<pair<int,long> > >G(N);\n\t\tfor(int i=0;i<N;i++)for(int j=i+1;j<N;j++)\n\t\t{\n\t\t\tint d[3];\n\t\t\tbool flag=true;\n\t\t\tfor(int k=0;k<3;k++)\n\t\t\t{\n\t\t\t\td[k]=S-abs(X[k][i]-X[k][j]);\n\t\t\t\tif(d[k]<=0)flag=false;\n\t\t\t}\n\t\t\tif(flag)\n\t\t\t{\n\t\t\t\tlong t=d[0]*d[1]+d[1]*d[2]+d[2]*d[0];\n\t\t\t\tt*=2;\n\t\t\t\tE.push_back(make_pair(make_pair(i,j),t));\n\t\t\t\tuf.unite(i,j);\n\t\t\t\tG[i].push_back(make_pair(j,t));\n\t\t\t\tG[j].push_back(make_pair(i,t));\n\t\t\t}\n\t\t}\n\t\tlong ans=-1;\n\t\tvector<bool>vis(N,false);\n\t\tfor(int i=0;i<N;i++)\n\t\t{\n\t\t\tint u=uf.find(i);\n\t\t\tif(uf.sz[u]<K)vis[u]=true;\n\t\t\tif(vis[u])continue;\n\t\t\tA.clear();\n\t\t\tvis[u]=true;\n\t\t\tbool flag=false;\n\t\t\tfor(pair<int,long>&q:G[u])\n\t\t\t{\n\t\t\t\tA.push_back(q.second);\n\t\t\t\tif(dfs(q.first,u,u,G))\n\t\t\t\t{\n\t\t\t\t\tflag=true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\treverse(A.begin(),A.end());\n\t\t\t}\n\t\t\tif(flag)\n\t\t\t{\n\t\t\t\tint n=A.size();\n\t\t\t\tfor(int i=0;i<n;i++)A.push_back(A[i]);\n\t\t\t}\n\t\t\tint get=flag&&uf.sz[u]==K?K:K-1;\n\t\t\tvector<long>sum(A.size()+1,0);\n\t\t\tfor(int i=0;i<A.size();i++)sum[i+1]=sum[i]+A[i];\n\t\t\tfor(int i=get;i<=A.size();i++)ans=max(ans,sum[i]-sum[i-get]);\n\t\t}\n\t\tif(ans<0)cout<<-1<<endl;\n\t\telse cout<<6LL*S*S*K-ans<<endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\nusing namespace std;\n\nstruct cube {\n    int x, y, z, w;\n    cube() {}\n    cube(int a, int b, int c, int d): x(a), y(b), z(c), w(d) {}\n\n    int area() {\n        return 6 * w * w;\n    }\n\n    int overlap_area(cube o) {\n        int ox = w - abs(x - o.x);\n        int oy = w - abs(y - o.y);\n        int oz = w - abs(z - o.z);\n\n        if (ox < 0 || oy < 0 || oz < 0) {\n            return -1;\n        }\n\n        return 2 * (ox * oy + oy * oz + oz * ox);\n    }\n};\n\nint main() {\n    int N, K, S;\n    while (true) {\n        cin >> N >> K >> S;\n        if (N == 0 && K == 0 && S == 0) break;\n\n        vector<cube> cubes;\n        vector<vector<int>> graph(N);\n\n        for (int j = 0; j < N; ++j) {\n            int x, y, z; cin >> x >> y >> z;\n            cubes.emplace_back(x, y, z, S);\n        }\n\n        for (int j = 0; j < N; ++j) {\n            for (int k = j+1; k < N; ++k) {\n                int area = cubes[j].overlap_area(cubes[k]);\n                if (area >= 0) {\n                    graph[j].push_back(k);\n                    graph[k].push_back(j);\n                }\n            }\n        }\n\n        int ans = -1;\n\n        vector<int> visited(N, 0);\n        for (int a = 0; a < N; ++a) {\n            if (visited[a]) continue;\n            visited[a] = 1;\n\n            bool loop = false;\n            vector<int> chain;\n            for (int p = a; p != -1; ) {\n                visited[p] = 1;\n                int np = -1;\n                chain.push_back(p);\n                for (int q: graph[p]) {\n                    if (chain.size() > 2 && q == a) {\n                        loop = true;\n                    }\n                    if (!visited[q]) {\n                        np = q;\n                        break;\n                    }\n                }\n                p = np;\n            }\n\n            if (chain.size() < K) {\n                continue;\n            }\n\n            const int L = chain.size();\n\n            int area = cubes[chain[0]].area();\n            if (K <= 1) {\n                ans = (ans == -1) ? area : min(ans, area);\n            }\n            for (int j = 1; j < (loop ? 2*L : L); ++j) {\n                if (j >= K) {\n                    int va = chain[(j-K)%L], vb = chain[(j-K+1)%L];\n                    area -= cubes[va].area() - cubes[va].overlap_area(cubes[vb]);\n                }\n                area += cubes[chain[j%L]].area() - cubes[chain[(j-1)%L]].overlap_area(cubes[chain[j%L]]);\n                if (loop && K == L && j == L-1) {\n                    area -= cubes[chain[0]].overlap_area(cubes[chain[L-1]]);\n                }\n                if (j+1 >= K) {\n                    ans = (ans == -1) ? area : min(ans, area);\n                }\n            }\n        }\n\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\nusing namespace std;\n\n#define rep(i,a,n) for(int (i)=(a); (i)<(n); (i)++)\n#define repq(i,a,n) for(int (i)=(a); (i)<=(n); (i)++)\n#define repr(i,a,n) for(int (i)=(a); (i)>=(n); (i)--)\n#define all(v) begin(v), end(v)\n#define pb(a) push_back(a)\n#define fr first\n#define sc second\n#define INF 2000000000\n#define int long long int\n\n#define X real()\n#define Y imag()\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a) - (b)) < EPS)\n#define EQV(a,b) ( EQ((a).X, (b).X) && EQ((a).Y, (b).Y) )\n#define LE(n, m) ((n) < (m) + EPS)\n#define LEQ(n, m) ((n) <= (m) + EPS)\n#define GE(n, m) ((n) + EPS > (m))\n#define GEQ(n, m) ((n) + EPS >= (m))\n\ntypedef vector<int> VI;\ntypedef vector<VI> MAT;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\ntypedef complex<double> P;\ntypedef pair<P, P> L;\ntypedef pair<P, double> C;\n\nint dx[] = {1, 1, 0, 0, 1, 1, 0, 0};\nint dy[] = {1, 0, 1, 0, 1, 0, 1, 0};\nint dz[] = {0, 0, 0, 0, 1, 1, 1, 1};\nint const MOD = 1000000007;\n\nnamespace std {\n    bool operator<(const P& a, const P& b) {\n        return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n    }\n}\n\n// Union-Find ??¨ (Verified: AtCoder Typical Contest 001 B)\nstruct UnionFind {\nprivate:\n    const int n;\n    int __size;\n    vector<int> uf;\npublic:\n    // ????????? UnionFind uni(n) ??????????????£?¨?????????°??????\n    UnionFind(int _n) : n(_n), __size(_n), uf(_n, -1) {}\n    // find (??¨??????????±???????)\n    int find(int x) {return (uf[x] < 0) ? x : uf[x] = find(uf[x]);}\n    // x ??¨ y ???????????????????±???????????????????\n    bool same(int x, int y) {return find(x) == find(y);}\n    // x ????±????????????????????´???°\n    int size(int x) {return -uf[find(x)];}\n    // ???????????????????????????\n    int size()      {return __size;}\n    // x ??¨ y ????±??????????????????????\n    void unite(int x, int y) {\n        x = find(x); y = find(y);\n        if(x == y) return;\n        __size--;\n        if(uf[y] < uf[x]) swap(x, y);\n        uf[x] += uf[y]; uf[y] = x;\n    }\n    // ???????????°??¨ (???????????????)\n    void debug() {for(auto e : uf) printf(\"UnionFind_debug: %lld\\n\", e);}\n};\n\n// ?§?????????¨????????¨???????????????????¨???????????§???????\ntemplate <typename T>\nstruct Edge {\n    int from, to;\n    T cost;\n    Edge(int s, T d) : to(s), cost(d) {}\n    Edge(int f, int s, T d) : from(f), to(s), cost(d) {}\n\n    bool operator<(const Edge &e) const {\n        return cost < e.cost;\n    }\n    bool operator>(const Edge &e) const {\n        return cost > e.cost;\n    }\n};\n#define Graph(type) vector< vector< Edge<type> > >\n\nbool incube(int a, int b, int x) {\n    return a <= x && x <= b;\n}\n\nint n, k, s;\nint x[1010], y[1010], z[1010];\nint temp, ans;\nvoid dfs(int p, Graph(int) &G, set<pii> S, set<int> T, int counter, int cur) {\n    T.insert(p);\n    rep(i,0,G[p].size()) {\n        int next = G[p][i].to;\n        if(counter == k && !T.count(next)) continue;\n        int mi = min(p, next), ma = max(p, next);\n        pii pr = pii(mi, ma);\n        if(S.count(pr)) continue;\n        int xx, yy, zz;\n        xx = min(x[p], x[next]) - max(x[p], x[next]) + s;\n        yy = min(y[p], y[next]) - max(y[p], y[next]) + s;\n        zz = min(z[p], z[next]) - max(z[p], z[next]) + s;\n        S.insert(pr);\n        cur -= 2 * (xx * yy + yy * zz + zz * xx);\n        // printf(\"p = %lld, next = %lld, cur = %lld\\n\", p, next, cur);\n        dfs(next, G, S, T, counter+1, cur);\n        S.erase(pr);\n        cur += 2 * (xx * yy + yy * zz + zz * xx);\n    }\n    if(counter >= k) {\n        // printf(\"cur = %lld\\n\", cur);\n        ans = min(ans, cur);\n        return;\n    }\n}\n\nsigned main() {\n    while(cin >> n >> k >> s, n || k || s) {\n        UnionFind uf(n);\n        Graph(int) G(n);\n        rep(i,0,n) {\n            cin >> x[i] >> y[i] >> z[i];\n        }\n        set<pii> edgepair;\n        rep(i,0,n) rep(j,0,n) {\n            if(i == j) continue;\n            pii temppair = pii( min(i,j), max(i,j) );\n            if(edgepair.count(temppair)) continue;\n            bool ok = false;\n            rep(k,0,8) {\n                if(ok) break;\n                if(incube(x[i], x[i]+s, x[j]+dx[k]*s) && incube(y[i], y[i]+s, y[j]+dy[k]*s) && incube(z[i], z[i]+s, z[j]+dz[k]*s)) {\n                    // printf(\"incube: i = %lld, j = %lld\\n\", i, j);\n                    uf.unite(i, j);\n                    G[i].pb(Edge<int>(j,1));\n                    G[j].pb(Edge<int>(i,1));\n                    edgepair.insert(temppair);\n                    ok = true;\n                }\n            }\n        }\n\n        ans = (int)1e18;\n        rep(i,0,n) {\n            // printf(\"uf.size(%lld) = %lld\\n\", i, uf.size(i));\n            if(uf.size(i) >= k) {\n                temp = 6 * s * s * k;\n                set<pii> S;\n                set<int> T;\n                dfs(i, G, S, T, 1, temp);\n            }\n        }\n        if(ans != (int)1e18) cout << ans << endl;\n        else cout << -1 << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define rep(i,n) for(int i = 0; i < (n); ++i)\n#define reps(i,a,n) for(int i = (a); i < (n); ++i)\nusing namespace std;\n\nusing ll = long long;\nusing pi = pair<int, ll>;\n\nll x[2003];\nll y[2003];\nll z[2003];\nvector<pi> d[2003];\nbool u[2003];\n\nvector<ll> v;\n\nvoid dfs(int i, int pre){\n    for(auto&p:d[i]){\n        if(p.first == pre) continue;\n        if(u[p.first]) continue;\n        v.push_back(p.second);\n        u[p.first] = true;\n        return dfs(p.first, i);\n    }\n}\n\nint main(){\n    ll n,k,s;\n    while(cin >> n >> k >> s){\n        if(n == 0) return 0;\n        rep(i, n){\n            cin >> x[i] >> y[i] >> z[i];\n        }\n        if(k == 1){\n            cout << s * s * 6 << endl;\n            continue;\n        }\n\n        const int k1 = k - 1;\n\n        rep(i, n) d[i].clear();\n        rep(i, n) reps(j, i+1, n){\n            ll X = abs(x[i]-x[j]);\n            ll Y = abs(y[i]-y[j]);\n            ll Z = abs(z[i]-z[j]);\n            if(X <= s && Y <= s && Z <= s){\n                X = s-X;\n                Y = s-Y;\n                Z = s-Z;\n                ll v = 2*(X*Y + Y*Z + Z*X);\n                d[i].push_back(pi{j,v});\n                d[j].push_back(pi{i,v});\n\n                // cout << \"#\" << i << \" \" << j << \" : \" << X << \" \" << Y << \" \" << Z << \" : \" << v << endl;\n            }\n        }\n\n        rep(i,n) u[i] = false;\n        ll ret = 0;\n        rep(i,n){\n            if(u[i]) continue;\n            if(d[i].size() != 1) continue;\n            v.clear();\n            u[i] = true;\n            dfs(i, -1);\n            // cout << \"$\"; for(auto&q:v) cout << \" \" << q; cout << endl;\n\n            if(v.size() +1 < k) continue;\n            ll l = 0;\n            rep(i, k1) l += v[i];\n            ret = max(ret, l);\n            reps(i, k1, v.size()) {\n                l -= v[i-k1];\n                l += v[i];\n                ret = max(ret, l);\n            }\n        }\n        rep(i,n){ // ring\n            if(u[i]) continue;\n            v.clear();\n            dfs(i, -1);\n            // cout << \"$\"; for(auto&q:v) cout << \" \" << q; cout << endl;\n            if(v.size() < k) continue;\n            if(v.size() == k){\n                ll l = 0;\n                rep(i, k) l += v[i];\n                ret = max(ret, l);\n            }\n            int ss = v.size();\n            rep(i, ss) v.push_back(v[i]);\n\n            ll l = 0;\n            rep(i, k1) l += v[i];\n            ret = max(ret, l);\n            reps(i, k1, v.size()) {\n                l -= v[i-k1];\n                l += v[i];\n                ret = max(ret, l);\n            }\n        }\n        // cerr << \"ret : \" << ret << endl;\n        if(ret == 0){\n            cout << -1 << endl;\n        }else{\n            cout << s * s * 6 * k - ret << endl;\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\n\nstruct Cube {\n    Cube() = default;\n    Cube(ll x, ll y, ll z, ll size) : x{x}, y{y}, z{z}, size{size}\n    {\n    }\n\n    bool operator<(const Cube& c) const\n    {\n        return (x != c.x) ? (x < c.x) : (y != c.y) ? (y < c.y) : (z != c.z) ? (z < c.z) : true;\n    }\n    ll x;\n    ll y;\n    ll z;\n    ll size;\n};\n\nll intersection(const Cube& c1, const Cube& c2)\n{\n\n    ll x = min(c1.x, c2.x) - max(c1.x, c2.x) + c1.size;\n    if (x <= 0) {\n        return 0;\n    }\n    ll y = min(c1.y, c2.y) - max(c1.y, c2.y) + c1.size;\n    if (y <= 0) {\n        return 0;\n    }\n    ll z = min(c1.z, c2.z) - max(c1.z, c2.z) + c1.size;\n    if (z <= 0) {\n        return 0;\n    }\n    return 2 * ((x * y) + (y * z) + (z * x));\n}\n\nstruct Edge {\n    Edge() = default;\n    Edge(int f, int t, ll c) : from{f}, to{t}, cost{c}\n    {\n    }\n    int from;\n    int to;\n    ll cost;\n};\n\nstruct Graph {\n    Graph(int n)\n    {\n        edge.resize(n);\n    }\n    void addEdge(int from, int to, ll cost)\n    {\n        edge[to].push_back(Edge{to, from, cost});\n        edge[from].push_back(Edge{from, to, cost});\n    }\n    vector<vector<Edge>> edge;\n};\n\nvoid dfs(const Graph& g, vector<bool>& checked, int pos, int& num, bool& ring, int& representation)\n{\n    num++;\n    checked[pos] = true;\n    bool update = false;\n    for (const auto& e : g.edge[pos]) {\n        const int to = e.to;\n        if (not checked[to]) {\n            dfs(g, checked, to, num, ring, representation);\n            update = true;\n        }\n    }\n    if (not update) {\n        if (g.edge[pos].size() == 2) {\n            ring = true;\n        } else {\n            ring = false;\n        }\n        representation = pos;\n    }\n}\n\nint main()\n{\n\n    while (true) {\n        int n, k;\n        ll s;\n        cin >> n >> k >> s;\n        if (n == 0 and k == 0 and s == 0) {\n            break;\n        }\n        vector<Cube> cubes(n);\n        for (int i = 0; i < n; i++) {\n            ll x, y, z;\n            cin >> x >> y >> z;\n            cubes[i] = Cube{x, y, z, s};\n        }\n        Graph g{n};\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                ll inter = intersection(cubes[i], cubes[j]);\n                if (inter > 0) {\n                    g.addEdge(i, j, inter);\n                }\n            }\n        }\n\n        vector<bool> checked(n, false);\n        vector<pair<pair<int, int>, bool>> cc;\n        for (int i = 0; i < n; i++) {\n            if (not checked[i]) {\n                int num = 0;\n                bool ring = false;\n                int rep;\n                dfs(g, checked, i, num, ring, rep);\n                if (num >= k) {\n                    cc.push_back(make_pair(make_pair(rep, num), ring));\n                }\n            }\n        }\n\n        if (cc.empty()) {\n            cout << -1 << endl;\n            continue;\n        }\n\n        ll maxi = -1;\n        vector<bool> used_head(n, false);\n        vector<bool> used_tail(n, false);\n        for (const auto p : cc) {\n            int rep = p.first.first;\n            int num = p.first.second;\n            bool ring = p.second;\n            if (ring) {\n                int head = rep;\n                int tail = rep;\n                ll sum = 0;\n                for (int i = 0; i < k - 1; i++) {\n                    used_tail[tail] = true;\n                    for (const auto& e : g.edge[tail]) {\n                        if (not used_tail[e.to]) {\n                            tail = e.to;\n                            sum += e.cost;\n                            break;\n                        }\n                    }\n                }\n                if (k == num) {\n                    used_tail[head] = false;\n                    for (const auto& e : g.edge[tail]) {\n                        if (not used_tail[e.to]) {\n                            sum += e.cost;\n                            break;\n                        }\n                    }\n                    maxi = max(maxi, sum);\n                    continue;\n                }\n                maxi = max(maxi, sum);\n                for (int i = 0; i < num; i++) {\n                    used_head[head] = true;\n                    used_tail[tail] = true;\n                    for (const auto& e : g.edge[head]) {\n                        if (not used_head[e.to]) {\n                            head = e.to;\n                            sum -= e.cost;\n                            break;\n                        }\n                    }\n                    for (const auto& e : g.edge[tail]) {\n                        if (not used_tail[e.to]) {\n                            tail = e.to;\n                            sum += e.cost;\n                            break;\n                        }\n                    }\n                    maxi = max(maxi, sum);\n                }\n            } else {\n                int head = rep;\n                int tail = rep;\n                ll sum = 0;\n                for (int i = 0; i < k - 1; i++) {\n                    used_tail[tail] = false;\n                    for (const auto& e : g.edge[tail]) {\n                        if (not used_tail[e.to]) {\n                            tail = e.to;\n                            sum += e.cost;\n                            break;\n                        }\n                    }\n                }\n                maxi = max(maxi, sum);\n                for (int i = 0; i < num - k + 1; i++) {\n                    used_head[head] = true;\n                    used_tail[tail] = true;\n                    for (const auto& e : g.edge[head]) {\n                        if (not used_head[e.to]) {\n                            head = e.to;\n                            sum -= e.cost;\n                            break;\n                        }\n                    }\n                    for (const auto& e : g.edge[tail]) {\n                        if (not used_tail[e.to]) {\n                            tail = e.to;\n                            sum += e.cost;\n                            break;\n                        }\n                    }\n                    maxi = max(maxi, sum);\n                }\n            }\n        }\n        cout << (6 * s * s) * static_cast<ll>(k) - maxi << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#define inf 1000000000\n\nusing namespace std;\n\nstruct edge{\n\tint to, cost;\n\tedge(){}\n\tedge(int a, int b){\n\t\tto = a, cost = b;\n\t}\n};\n\nint n, k, s;\nint x[2005], y[2005], z[2005];\n\nbool used[2005];\nvector<edge> G[2005];\n\nint dfs(int v, int prev, int k)\n{\n\tif(k == 0){\n\t\tfor(int i = 0; i < G[v].size(); i++){\n\t\t\tif(used[G[v][i].to] && G[v][i].to != prev) return G[v][i].cost;\n\t\t}\n\t\treturn 0;\n\t}\n\tused[v] = true;\n\t\n\tint ret = -inf;\n\tfor(int i = 0; i < G[v].size(); i++){\n\t\tif(used[G[v][i].to]) continue;\n\t\tret = max(ret, G[v][i].cost + dfs(G[v][i].to, v, k-1));\n\t}\n\tused[v] = false;\n\treturn ret;\n}\n\nint main(void)\n{\n\twhile(1){\n\t\tcin >> n >> k >> s;\n\t\tif(n == 0 && k == 0 && s == 0) break;\n\t\tfor(int i = 1; i <= n; i++){\n\t\t\tcin >> x[i] >> y[i] >> z[i];\n\t\t}\n\t\t\n\t\tfor(int i = 1; i <= n; i++) G[i].clear();\n\t\tint dx, dy, dz, w;\n\t\tfor(int i = 1; i <= n; i++){\n\t\t\tfor(int j = 1; j <= n; j++){\n\t\t\t\tif(i >= j) continue;\n\t\t\t\tdx = s - abs(x[i] - x[j]);\n\t\t\t\tdy = s - abs(y[i] - y[j]);\n\t\t\t\tdz = s - abs(z[i] - z[j]);\n\t\t\t\tif(dx < 0 || dy < 0 || dz < 0) continue;\n\t\t\t\tw = 2 * (dx*dy + dy*dz + dz*dx);\n\t\t\t\tG[i].push_back( edge(j, w) );\n\t\t\t\tG[j].push_back( edge(i, w) );\n\t\t\t}\n\t\t}\n\t\t\n\t\tint ans = -inf;\n\t\tfor(int i = 1; i <= n; i++){\n\t\t\tfor(int j = 1; j <= n; j++) used[j] = false;\n\t\t\tans = max(ans, dfs(i, -1, k-1));\n\t\t}\n\t\t\n\t\tif(ans < 0) cout << -1 << endl;\n\t\telse cout << 6*s*s*k - ans << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 2001\n#define int long long\nusing namespace std;\nvector<int>G[N];\nint n,K,S;\nstruct point{int x,y,z;};\n\nint Area(){return S*S*6;}\nint sArea(point a,point b){\n  int x = min(a.x+S, b.x+S),X = max(a.x,b.x);\n  int y = min(a.y+S, b.y+S),Y = max(a.y,b.y);\n  int z = min(a.z+S, b.z+S),Z = max(a.z,b.z);\n  if(y <= Y || x <= X || z <= Z) return 0;\n  int area=0;\n  area += 2*(x-X)*(y-Y);\n  area += 2*(y-Y)*(z-Z);\n  area += 2*(z-Z)*(x-X);\n  return area;\n}\n\nvector<point> A;\n\nint dfs(int pos,int k,int start,int prev){\n  if(prev!=-1 && pos==start) return 1LL<<55;\n  if(k == K) return prev==-1? 0:-sArea(A[pos],A[start]);\n \n  \n  int res = 1e9;\n  for(int nx:G[pos]){\n    if(nx == prev)continue;\n    int area = Area() - sArea(A[pos],A[nx]);\n    res = min(res,area+dfs(nx,k+1,start,pos));\n  }\n  return res;\n}\n\nsigned main(){\n  while(1){\n    cin>>n>>K>>S;\n    if(!n&&!K&&!S)break;\n    \n    A.resize(n);\n    for(int i=0;i<n;i++)cin>>A[i].x>>A[i].y>>A[i].z;\n    \n    for(int i=0;i<N;i++) G[i].clear();\n\n    for(int i=0;i<n;i++)\n      for(int j=i+1;j<n;j++){\n\tif(!sArea(A[i],A[j]))continue;\n\tG[i].push_back(j);\n\tG[j].push_back(i);\n      }\n\n    for(int i=0;i<n;i++) assert(G[i].size()<3);\n    int ans = 1e9;\n    for(int i=0;i<n;i++)ans = min(ans,Area()+dfs(i,1,i,-1));\n    if(ans == 1e9) ans = -1;\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <math.h>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <bitset>\n#include <algorithm>\nusing namespace std;\n\nstruct xyz_t {\n    int x;\n    int y;\n    int z;\n    double length;       //一乗\n};\n\nstruct first_t {\n    int sec;\n    long long w;\n};\n\nbool asc(const xyz_t& left,const xyz_t& right);\nint next(int p,int q);\nint root(int p);\nvoid unite(int p,int q);\nint same(int p,int q);\nvoid pr(vector<vector<int> > pri);\nvoid nnn();\n\nvector<xyz_t> a;\nvector<int> tree;\nvector<int> endd;\nvector<vector<int> > tree_f;\nvector<vector<int> > kaburi;\nvector<vector<int> > tree_r;\nvector<int> num;\nvector<int> flg;\nlong long ans;\nint n,k,s;\ndouble LE;\nlong long sum;\nint rr;\n\nint main(){\n  scanf (\"%d %d %d\",&n,&k,&s);\n  while(n){\n    ans=0;\n    LE=sqrt(s*s*3.0);\n    xyz_t aaa={0,0,0,0};\n    a.assign(n,aaa);\n    tree.assign(n,-1);\n    endd.assign(n,-1);\n    tree_f.assign(n,vector<int>(1,0));\n    kaburi.assign(n,vector<int>(n,0));\n    tree_r.assign(n,vector<int>(0,0));\n    num.assign(n,1);\n    flg.assign(n,0);\n    for(int t=0;t<n;t++){\n      scanf (\"%d %d %d\",&a[t].x,&a[t].y,&a[t].z);\n      a[t].length=sqrt(a[t].x*a[t].x*1.0+a[t].y*a[t].y*1.0+a[t].z*a[t].z*1.0);\n    }\n    sort(a.begin(),a.end(),asc);\n    for(int i=0;i<n;i++){\n      tree[i]=i;\n      endd[i]=i;\n    }\n\n    switch(k){\n      case 1:\n        printf(\"%d\\n\",s*s*6);\n        break;\n      case 3:\n        for(int t=0;t<n-1;++t){\n          for(int s=t+1;(a[s].length<a[t].length+LE&&s<n);++s){\n            int xx=next(a[t].x,a[s].x);\n            int yy=next(a[t].y,a[s].y);\n            int zz=next(a[t].z,a[s].z);\n            if(xx&&yy&&zz){\n              if(same(t,s)==0){\n                int ee;\n                int eee;\n                  if(tree[t]==t&&tree[s]==s){\n                    //printf(\"%d %d\\n\",endd[t],endd[s]);\n                    ee=num[tree[t]];\n                    eee=num[tree[s]];\n                    num[tree[t]]=0;\n                    num[tree[s]]=0;\n                    num[endd[t]]=ee+eee;\n                    tree[t]=endd[t];\n                    tree[endd[t]]=endd[t];\n                    endd[endd[t]]=endd[s];\n                    unite(s,t);\n                  }\n                  else if(tree[t]!=t&&tree[s]==s){\n                    num[tree[t]]=num[tree[t]]+num[s];\n                    num[tree[s]]=0;\n                    endd[tree[t]]=endd[s];\n                    unite(s,t);\n                    //printf(\"%d\\n\",tree[t]);\n                  }\n                  else if(tree[t]==t&&tree[s]!=s){\n                    num[tree[s]]=num[t]+num[tree[s]];\n                    num[tree[t]]=0;\n                    endd[tree[s]]=endd[t];\n                    unite(t,s);\n                    //printf(\"%d\\n\",tree[s]);\n                  }\n                  else if(tree[t]!=t&&tree[s]!=s){\n                    num[tree[t]]=num[tree[t]]+num[tree[s]];\n                    num[tree[s]]=0;\n                    endd[tree[t]]=tree[s];\n                    unite(s,t);\n                    //printf(\"%d %d %d %d\\n\",t,s,tree[t],endd[tree[t]]);\n                  }\n                kaburi[s][t]=xx*yy+yy*zz+zz*xx;\n                  kaburi[t][s]=kaburi[s][t];\n                  tree_r[t].push_back(s);\n                  tree_r[s].push_back(t);\n                  //printf(\"%d %d %d\\n\",kaburi[q].back());\n                  //printf(\"%d %d %d\\n\",xx,yy,zz);\n                }\n              else{\n                kaburi[s][t]=xx*yy+yy*zz+zz*xx;\n                kaburi[t][s]=kaburi[s][t];\n                tree_r[t].push_back(s);\n                tree_r[s].push_back(t);\n                flg[tree[t]]=1;\n              }\n            }\n          }\n        }\n        //pr(kaburi);\n        for(int t=0;t<n;++t){\n          sum=0;\n          if(num[t]>=k){\n            if(flg[t]==0){\n              int u=t;\n              int uu=t;\n              tree_f[t][0]=t;\n              for(int r=0;r<k-1;++r){\n                rr=0;\n                if(tree_r[u][rr]==uu){\n                  ++rr;\n                }\n                sum+=kaburi[u][tree_r[u][rr]];\n                tree_f[t].push_back(tree_r[u][rr]);\n                uu=u;\n                u=tree_r[u][rr];\n              }\n              for(int r=k-1;r<num[t]-1;++r){\n                rr=0;\n                if(tree_r[u][rr]==uu){\n                  ++rr;\n                }\n                tree_f[t].push_back(tree_r[u][rr]);\n                uu=u;\n                u=tree_r[u][rr];\n              }\n              if(ans<sum){\n                ans=sum;\n              }\n              for(int r=0;r+k<num[t];++r){\n                sum=sum-kaburi[tree_f[t][r]][tree_f[t][r+1]]+kaburi[tree_f[t][r+k-1]][tree_f[t][r+k]];\n                if(ans<sum){\n                  ans=sum;\n                }\n              }\n            }\n            else{\n              if(num[t]!=k){\n                int u=t;\n                int uu=t;\n                tree_f[t][0]=t;\n                for(int r=0;r<k-1;++r){\n                  rr=0;\n                  if(tree_r[u][rr]==uu){\n                    ++rr;\n                  }\n                  sum+=kaburi[u][tree_r[u][rr]];\n                  tree_f[t].push_back(tree_r[u][rr]);\n                  uu=u;\n                  u=tree_r[u][rr];\n                }\n                for(int r=k-1;r<num[t]*2;++r){\n                  rr=0;\n                  if(tree_r[u][rr]==uu){\n                    ++rr;\n                  }\n                  tree_f[t].push_back(tree_r[u][rr]);\n                  uu=u;\n                  u=tree_r[u][rr];\n                }\n                if(ans<sum){\n                  ans=sum;\n                }\n                for(int r=0;r<num[t];++r){\n                  sum=sum-kaburi[tree_f[t][r]][tree_f[t][r+1]]+kaburi[tree_f[t][r+k-1]][tree_f[t][r+k]];\n                  if(ans<sum){\n                    ans=sum;\n                  }\n                  //printf(\"%lld\\n\",sum);\n                }\n                //pr(tree_f);\n              }\n              else{\n                if(num[t]!=3){\n                  int u=t;\n                  int uu=t;\n                  tree_f[t][0]=t;\n                  for(int r=0;r<k;++r){\n                    rr=0;\n                    if(tree_r[u][rr]==uu){\n                      ++rr;\n                    }\n                    sum+=kaburi[u][tree_r[u][rr]];\n                    uu=u;\n                    u=tree_r[u][rr];\n                  }\n                  if(ans<sum){\n                    ans=sum;\n                  }\n                }\n                else{\n                  int u=t;\n                  int uu=t;\n                  tree_f[t][0]=t;\n                  for(int r=0;r<k;++r){\n                    rr=0;\n                    if(tree_r[u][rr]==uu){\n                      ++rr;\n                    }\n                    sum+=kaburi[u][tree_r[u][rr]];\n                    tree_f[t].push_back(tree_r[u][rr]);\n                    uu=u;\n                    u=tree_r[u][rr];\n                  }\n                  int xxx=s+min({a[tree_f[t][0]].x,a[tree_f[t][1]].x,a[tree_f[t][2]].x})-max({a[tree_f[t][0]].x,a[tree_f[t][1]].x,a[tree_f[t][2]].x});\n                  int yyy=s+min({a[tree_f[t][0]].y,a[tree_f[t][1]].y,a[tree_f[t][2]].y})-max({a[tree_f[t][0]].y,a[tree_f[t][1]].y,a[tree_f[t][2]].y});\n                  int zzz=s+min({a[tree_f[t][0]].z,a[tree_f[t][1]].z,a[tree_f[t][2]].z})-max({a[tree_f[t][0]].z,a[tree_f[t][1]].z,a[tree_f[t][2]].z});\n                  sum=sum-(xxx*yyy+yyy*zzz+zzz*xxx);\n                  if(ans<sum){\n                    ans=sum;\n                  }\n                }\n              }\n            }\n          }\n        }\n        if(ans==0){\n          printf(\"-1\\n\");\n        }\n        else{\n          printf(\"%lld\\n\",s*s*6*k-ans*2);\n        }\n        break;\n      default:\n        for(int t=0;t<n-1;++t){\n          for(int s=t+1;(a[s].length<a[t].length+LE&&s<n);++s){\n            int xx=next(a[t].x,a[s].x);\n            int yy=next(a[t].y,a[s].y);\n            int zz=next(a[t].z,a[s].z);\n            if(xx&&yy&&zz){\n              if(same(t,s)==0){\n                int ee;\n                int eee;\n                if(tree[t]==t&&tree[s]==s){\n                  //printf(\"%d %d\\n\",endd[t],endd[s]);\n                  ee=num[tree[t]];\n                  eee=num[tree[s]];\n                  num[tree[t]]=0;\n                  num[tree[s]]=0;\n                  num[endd[t]]=ee+eee;\n                  tree[t]=endd[t];\n                  tree[endd[t]]=endd[t];\n                  endd[endd[t]]=endd[s];\n                  unite(s,t);\n                }\n                else if(tree[t]!=t&&tree[s]==s){\n                  num[tree[t]]=num[tree[t]]+num[s];\n                  num[tree[s]]=0;\n                  endd[tree[t]]=endd[s];\n                  unite(s,t);\n                  //printf(\"%d\\n\",tree[t]);\n                }\n                else if(tree[t]==t&&tree[s]!=s){\n                  num[tree[s]]=num[t]+num[tree[s]];\n                  num[tree[t]]=0;\n                  endd[tree[s]]=endd[t];\n                  unite(t,s);\n                  //printf(\"%d\\n\",tree[s]);\n                }\n                else if(tree[t]!=t&&tree[s]!=s){\n                  num[tree[t]]=num[tree[t]]+num[tree[s]];\n                  num[tree[s]]=0;\n                  endd[tree[t]]=tree[s];\n                  unite(s,t);\n                  //printf(\"%d %d %d %d\\n\",t,s,tree[t],endd[tree[t]]);\n                }\n                kaburi[s][t]=xx*yy+yy*zz+zz*xx;\n                kaburi[t][s]=kaburi[s][t];\n                tree_r[t].push_back(s);\n                tree_r[s].push_back(t);\n                //printf(\"%d %d %d\\n\",kaburi[q].back());\n                //printf(\"%d %d %d\\n\",xx,yy,zz);\n              }\n              else{\n                kaburi[s][t]=xx*yy+yy*zz+zz*xx;\n                kaburi[t][s]=kaburi[s][t];\n                flg[tree[t]]=1;\n                tree_r[t].push_back(s);\n                tree_r[s].push_back(t);\n              }\n              //nnn();\n            }\n          }\n        }\n        for(int t=0;t<n;++t){\n          root(t);\n        }\n        for(int t=0;t<n;++t){\n          sum=0;\n          if(num[t]>=k){\n            if(flg[t]==0){\n              int u=t;\n              int uu=t;\n              tree_f[t][0]=t;\n              for(int r=0;r<k-1;++r){//k-1\n                rr=0;\n                if(tree_r[u][rr]==uu){\n                  ++rr;\n                }\n                sum+=kaburi[u][tree_r[u][rr]];\n                tree_f[t].push_back(tree_r[u][rr]);\n                uu=u;\n                u=tree_r[u][rr];\n              }\n              for(int r=k-1;r<num[t]-1;++r){\n                rr=0;\n                if(tree_r[u][rr]==uu){\n                  ++rr;\n                }\n                tree_f[t].push_back(tree_r[u][rr]);\n                uu=u;\n                u=tree_r[u][rr];\n              }\n              if(ans<sum){\n                ans=sum;\n              }\n              //printf(\"%lld\\n\",sum);\n              for(int r=0;r+k<num[t];++r){\n                sum=sum-kaburi[tree_f[t][r]][tree_f[t][r+1]]+kaburi[tree_f[t][r+k-1]][tree_f[t][r+k]];\n                //printf(\"%lld\\n\",sum);\n                if(ans<sum){\n                  ans=sum;\n                }\n              }\n            }\n            else{\n              if(num[t]!=k||k==2){\n                int u=t;\n                int uu=t;\n                tree_f[t][0]=t;\n                for(int r=0;r<k-1;++r){\n                  rr=0;\n                  if(tree_r[u][rr]==uu){\n                    ++rr;\n                  }\n                  sum+=kaburi[u][tree_r[u][rr]];\n                  tree_f[t].push_back(tree_r[u][rr]);\n                  uu=u;\n                  u=tree_r[u][rr];\n                }\n                for(int r=k-1;r<num[t]*2;++r){\n                  rr=0;\n                  if(tree_r[u][rr]==uu){\n                    ++rr;\n                  }\n                  tree_f[t].push_back(tree_r[u][rr]);\n                  uu=u;\n                  u=tree_r[u][rr];\n                }\n                if(ans<sum){\n                  ans=sum;\n                }\n                for(int r=0;r<num[t];++r){\n                  sum=sum-kaburi[tree_f[t][r]][tree_f[t][r+1]]+kaburi[tree_f[t][r+k-1]][tree_f[t][r+k]];\n                  if(ans<sum){\n                    ans=sum;\n                  }\n                  //printf(\"%lld\\n\",sum);\n                }\n                //pr(tree_f);\n              }\n              else{\n                int u=t;\n                int uu=t;\n                tree_f[t][0]=t;\n                for(int r=0;r<k;++r){\n                  rr=0;\n                  if(tree_r[u][rr]==uu){\n                    ++rr;\n                  }\n                  sum+=kaburi[u][tree_r[u][rr]];\n                  uu=u;\n                  u=tree_r[u][rr];\n                  //printf(\"%lld\\n\",sum);\n                }\n                if(ans<sum){\n                  ans=sum;\n                }\n              }\n            }\n          }\n        }\n        if(ans==0){\n          printf(\"-1\\n\");\n        }\n        else{\n          printf(\"%lld\\n\",s*s*6*k-ans*2);\n        }\n    }\n    scanf (\"%d %d %d\",&n,&k,&s);\n  }\n}\n/*\n環状 k=3の時 それ以外の時\n\n\n*/\n\n\nbool asc(const xyz_t& left,const xyz_t& right){\n  return left.length<right.length;\n}\n\nint next(int p,int q){\n  if(-s<=(p-q)&&(p-q)<=s){\n    if((p-q)>=0){\n      return s-(p-q);\n    }\n    else{\n      return s-(q-p);\n    }\n  }\n  else{\n    return 0;\n  }\n}\n\nint root(int p){\n  if (tree[p] == p){// 根\n    return p;\n  }\n  else {\n    return tree[p] = root(tree[p]); // 経路圧縮\n  }\n}\n\nvoid unite(int p, int q){\n  p = root(p);\n  q = root(q);\n  if (p == q){}\n  else{\n    tree[p] = q;     //pの親をqの親にする\n  }\n}\n\nint same(int p, int q){\n  return root(p) == root(q);\n}\n\n\n\nvoid pr(vector<vector<int> > pri){\n  for(int t=0;t<int(pri.size());++t){\n    for(int s=0;s<int(pri[t].size())-1;++s){\n      printf(\"%d \",pri[t][s]);\n    }\n    printf(\"%d\\n\",pri[t][pri[t].size()-1]);\n  }\n  printf(\"\\n\");\n}\n\nvoid nnn(){\n  for(int t=0;t<n-1;++t){\n    printf(\"%d \",num[t]);\n  }\n  printf(\"%d\\n\",num[n-1]);\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define sar(a,n) cout<<#a<<\":\";rep(pachico,n)cout<<\" \"<<a[pachico];cout<<endl\n#define svec(v) cout<<#v<<\":\";rep(pachico,v.size())cout<<\" \"<<v[pachico];cout<<endl\n#define svecp(v) cout<<#v<<\":\";each(pachico,v)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n#define sset(s) cout<<#s<<\":\";each(pachico,s)cout<<\" \"<<pachico;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(pachico,m)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 100005;\n\nstruct edge\n{\n    int to;\n    ll cost;\n};\n\nstruct data\n{\n    ll x,y,z;\n};\n\nvoid dfs(int u,int p,int& vc, int& ed, vector<int>& visit, vector<vector<edge> >& G, vector<int>& v)\n{\n    v.pb(u);\n    visit[u] = vc++;\n    each(e,G[u]){\n        if(visit[e.to] < 0){\n            ed++;\n            dfs(e.to,u,vc,ed,visit,G,v);\n        }else if(visit[e.to] < visit[u] && e.to != p){\n            ed++;\n        }\n    }\n}\n\nll solve(ll x,ll y,ll z)\n{\n    return 2*(x*y+y*z+z*x);\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while(1){\n        int n,K;\n        ll s;\n        cin >> n >> K >> s;\n        if(n == 0) break;\n        vector<vector<edge> > G(n);\n        vector<data> vec(n);\n        rep(i,n){\n            ll x,y,z;\n            cin >> x >> y >> z;\n            vec[i] = (data){x,y,z};\n        }\n        if(K == 1){\n            cout << 6*s*s*K << \"\\n\";\n            continue;\n        }\n        rep(i,n){\n            srep(j,i+1,n){\n                data& p = vec[i], q = vec[j];\n                if(p.x <= q.x){\n                    if(q.x < p.x+s){\n                        if(p.y <= q.y){\n                            if(q.y < p.y+s){\n                                if(p.z <= q.z){\n                                    if(q.z < p.z+s){\n                                        ll val = solve(p.x+s-q.x,p.y+s-q.y,p.z+s-q.z);\n                                        G[i].pb((edge){j,val}), G[j].pb((edge){i,val});\n                                    }\n                                }else{\n                                    if(p.z < q.z+s){\n                                        ll val = solve(p.x+s-q.x,p.y+s-q.y,q.z+s-p.z);\n                                        G[i].pb((edge){j,val}), G[j].pb((edge){i,val});\n                                    }\n                                }\n                            }\n                        }else{\n                            if(p.y < q.y+s){\n                                if(p.z <= q.z){\n                                    if(q.z < p.z+s){\n                                        ll val = solve(p.x+s-q.x,q.y+s-p.y,p.z+s-q.z);\n                                        G[i].pb((edge){j,val}), G[j].pb((edge){i,val});\n                                    }\n                                }else{\n                                    if(p.z < q.z+s){\n                                        ll val = solve(p.x+s-q.x,q.y+s-p.y,q.z+s-p.z);\n                                        G[i].pb((edge){j,val}), G[j].pb((edge){i,val});\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }else{\n                    if(p.x < q.x+s){\n                        if(p.y <= q.y){\n                            if(q.y < p.y+s){\n                                if(p.z <= q.z){\n                                    if(q.z < p.z+s){\n                                        ll val = solve(q.x+s-p.x,p.y+s-q.y,p.z+s-q.z);\n                                        G[i].pb((edge){j,val}), G[j].pb((edge){i,val});\n                                    }\n                                }else{\n                                    if(p.z < q.z+s){\n                                        ll val = solve(q.x+s-p.x,p.y+s-q.y,q.z+s-p.z);\n                                        G[i].pb((edge){j,val}), G[j].pb((edge){i,val});\n                                    }\n                                }\n                            }\n                        }else{\n                            if(p.y < q.y+s){\n                                if(p.z <= q.z){\n                                    if(q.z < p.z+s){\n                                        ll val = solve(q.x+s-p.x,q.y+s-p.y,p.z+s-q.z);\n                                        G[i].pb((edge){j,val}), G[j].pb((edge){i,val});\n                                    }\n                                }else{\n                                    if(p.z < q.z+s){\n                                        ll val = solve(q.x+s-p.x,q.y+s-p.y,q.z+s-p.z);\n                                        G[i].pb((edge){j,val}), G[j].pb((edge){i,val});\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        ll mx = -1;\n        vector<int> visit(n,-1);\n        rep(i,n){\n            if(visit[i] < 0){\n                int vc = 0, ed = 0;\n                vector<int> v;\n                dfs(i,-1,vc,ed,visit,G,v);\n                if(vc < K){\n                    continue;\n                }\n                int st = i, p = -1;\n                if(vc != ed){\n                    each(j,v){\n                        if(len(G[j]) == 1){\n                            st = j;\n                            break;\n                        }\n                    }\n                    assert(st >= 0);\n                    int cnt = 0;\n                    deque<ll> deq;\n                    ll val = 0;\n                    bool ok = true;\n                    while(ok){\n                        ok = false;\n                        cnt++;\n                        each(e,G[st]){\n                            if(e.to != p){\n                                if(cnt+1 > K){\n                                    val -= deq.front();\n                                    deq.pop_front();\n                                }\n                                deq.pb(e.cost);\n                                val += e.cost;\n                                cmx(mx,val);\n                                p = st;\n                                st = e.to;\n                                ok = true;\n                                break;\n                            }\n                        }\n                    }\n                    cmx(mx,val);\n                }else{\n                    int cnt = 0;\n                    deque<ll> deq;\n                    ll val = 0;\n                    int nw = st;\n                    while(nw != st || cnt == 0){\n                        cnt++;\n                        each(e,G[nw]){\n                            if(e.to != p){\n                                if(cnt+1 > K){\n                                    val -= deq.front();\n                                    deq.pop_front();\n                                }\n                                deq.pb(e.cost);\n                                val += e.cost;\n                                cmx(mx,val);\n                                p = nw;\n                                nw = e.to;\n                                break;\n                            }\n                        }\n                    }\n                    cmx(mx,val);\n                }\n            }\n        }\n        if(mx < 0){\n            cout << \"-1\\n\";\n        }else{\n            cout << 6*s*s*K - mx << \"\\n\";\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define dbg(...) do{cerr<<__LINE__<<\": \";dbgprint(#__VA_ARGS__, __VA_ARGS__);}while(0);\n\nusing namespace std;\n\nnamespace std{template<class S,class T>struct hash<pair<S,T>>{size_t operator()(const pair<S,T>&p)const{return ((size_t)1e9+7)*hash<S>()(p.first)+hash<T>()(p.second);}};template<class T>struct hash<vector<T>>{size_t operator()(const vector<T> &v)const{size_t h=0;for(auto i : v)h=h*((size_t)1e9+7)+hash<T>()(i)+1;return h;}};}\ntemplate<class T>ostream& operator<<(ostream &os, const vector<T> &v){os<<\"[ \";rep(i,v.size())os<<v[i]<<(i==v.size()-1?\" ]\":\", \");return os;}template<class T>ostream& operator<<(ostream &os,const set<T> &v){os<<\"{ \"; for(const auto &i:v)os<<i<<\", \";return os<<\"}\";}\ntemplate<class T,class U>ostream& operator<<(ostream &os,const map<T,U> &v){os<<\"{\";for(const auto &i:v)os<<\" \"<<i.first<<\": \"<<i.second<<\",\";return os<<\"}\";}template<class T,class U>ostream& operator<<(ostream &os,const pair<T,U> &p){return os<<\"(\"<<p.first<<\", \"<<p.second<<\")\";}\nvoid dbgprint(const string &fmt){cerr<<endl;}template<class H,class... T>void dbgprint(const string &fmt,const H &h,const T&... r){cerr<<fmt.substr(0,fmt.find(\",\"))<<\"= \"<<h<<\" \";dbgprint(fmt.substr(fmt.find(\",\")+1),r...);}\ntypedef long long ll;typedef vector<int> vi;typedef pair<int,int> pi;const int inf = (int)1e9;const double INF = 1e12, EPS = 1e-9;\n\nint main(){\n\tcin.tie(0); cin.sync_with_stdio(0);\n\tint n, k, s;\n\twhile(cin >> n >> k >> s, n){\n\t\tvi x(n), y(n), z(n);\n\t\trep(i, n) cin >> x[i] >> y[i] >> z[i];\n\t\t\n\t\tauto intersect = [&](int i, int j){\n\t\t\tll dx = s - abs(x[i] - x[j]);\n\t\t\tll dy = s - abs(y[i] - y[j]);\n\t\t\tll dz = s - abs(z[i] - z[j]);\n\t\t\tif(dx <= 0 || dy <= 0 || dz <= 0) return 0ll;\n\t\t\treturn (dx * dy + dy * dz + dz * dx) * 2;\n\t\t};\n\t\t\n\t\tvector<vi> e(n);\n\t\trep(i, n) rep(j, i) if(intersect(i, j)){\n\t\t\te[i].pb(j);\n\t\t\te[j].pb(i);\n\t\t\t//dbg(i, j);\n\t\t}\n\t\trep(i, n) assert(e[i].size() <= 2);\n\t\t\n\t\tfunction<bool(int,int,vector<bool>&,vi&)> rec = [&](int c, int p, vector<bool> &v, vi &idx){\n\t\t\tv[c] = 1;\n\t\t\tbool ans = 0;\n\t\t\tidx.pb(c);\n\t\t\tfor(int i : e[c]) if(i != p){\n\t\t\t\tif(v[i]) ans |= 1;\n\t\t\t\telse ans |= rec(i, c, v, idx); \n\t\t\t}\n\t\t\treturn ans;\n\t\t};\n\t\t\n\t\tll ans = 1e18;\n\t\tvector<bool> v(n);\n\t\trep(ii, n) if(!v[ii]){\n\t\t\tvi idx;\n\t\t\tbool loop = rec(ii, ii, v, idx);\n\t\t\tif(idx.size() < k) continue;\n\t\t\t\n\t\t\tif(loop && idx.size() == k){\n\t\t\t\tll sum = 6ll * k * s * s;\n\t\t\t\trep(i, (int)idx.size()){\n\t\t\t\t\tll c = intersect(idx[i], idx[(i + 1) % idx.size()]);\n\t\t\t\t\tsum -= c;\n\t\t\t\t}\n\t\t\t\tans = min(ans, sum);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tll sum = 6ll * k * s * s;\n\t\t\tif(k == 1){\n\t\t\t\tans = min(ans, sum);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tvector<ll> costs;\n\t\t\tif(loop){\n\t\t\t\trep(i, (int)idx.size())\n\t\t\t\t\tcosts.pb(intersect(idx[i], idx[(i + 1) % idx.size()]));\n\t\t\t\tint it = idx.size();\n\t\t\t\trep(i, it) idx.pb(idx[i]);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tint hasi = 0;\n\t\t\t\trep(i, idx.size()) if(e[idx[i]].size() == 1) hasi = idx[i];\n\t\t\t\tfor(int i : idx) v[i] = 0;\n\t\t\t\tidx.clear();\n\t\t\t\trec(hasi, hasi, v, idx);\n\t\t\t\t\n\t\t\t\trep(i, (int)idx.size()-1)\n\t\t\t\t\tcosts.pb(intersect(idx[i], idx[i + 1]));\n\t\t\t\t#if 1\n\t\t\t\trep(i, idx.size()){\n\t\t\t\t\t//if(i==0 || i==idx.size()-1) assert(e[idx[i]].size() <= 1);\n\t\t\t\t\t//else assert(e[idx[i]].size()==2);\n\t\t\t\t\tassert(e[idx[i]].size() <= 2);\n\t\t\t\t\tassert(e[idx[i]].size() >= 1);\n\t\t\t\t}\n\t\t\t\t#endif\n\t\t\t}\n\t\t\t//dbg(k, costs);\n\t\t\t\n\t\t\trep(i, k-2) sum -= costs[i];\n\t\t\trep(i, (int)costs.size() - (k-1) + 1){\n\t\t\t\tsum -= costs[i + k-2];\n\t\t\t\tans = min(ans, sum);\n\t\t\t\tsum += costs[i];\n\t\t\t}\n\t\t}\n\t\tif(ans >= 1e18) ans = -1;\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\nusing namespace std;\n\nstruct cube {\n    int x, y, z, w;\n    cube() {}\n    cube(int a, int b, int c, int d): x(a), y(b), z(c), w(d) {}\n\n    int area() {\n        return 6 * (int)w * w;\n    }\n\n    int overlap_area(cube o) {\n        int ox = w - abs(x - o.x);\n        int oy = w - abs(y - o.y);\n        int oz = w - abs(z - o.z);\n\n        if (ox <= 0 || oy <= 0 || oz <= 0) {\n            return -1;\n        }\n\n        return 2 * (ox * oy + oy * oz + oz * ox);\n    }\n};\n\nint main() {\n    int N, K, S;\n    while (true) {\n        cin >> N >> K >> S;\n        if (N == 0 && K == 0 && S == 0) break;\n\n        vector<cube> cubes;\n        vector<vector<int>> graph(N);\n\n        for (int j = 0; j < N; ++j) {\n            int x, y, z; cin >> x >> y >> z;\n            cubes.emplace_back(x, y, z, S);\n        }\n\n        for (int j = 0; j < N; ++j) {\n            for (int k = j+1; k < N; ++k) {\n                int area = cubes[j].overlap_area(cubes[k]);\n                if (area >= 0) {\n                    graph[j].push_back(k);\n                    graph[k].push_back(j);\n                }\n            }\n        }\n\n        int ans = -1;\n\n        vector<int> visited(N, 0);\n        for (int a = 0; a < N; ++a) {\n            if (visited[a]) continue;\n            visited[a] = 1;\n\n            bool loop = false;\n            int res = a;\n            for (int p = a, count = 1; p != -1; ++count) {\n                visited[p] = 1;\n                int np = -1;\n                for (int q: graph[p]) {\n                    if (count > 2 && q == a) {\n                        loop = true;\n                        break;\n                    }\n                    if (!visited[q]) {\n                        res = np = q;\n                        break;\n                    }\n                }\n                p = np;\n            }\n\n            vector<int> chain;\n            for (int p = res; p != -1; ) {\n                visited[p] = 1;\n                int np = -1;\n                chain.push_back(p);\n                for (int q: graph[p]) {\n                    if (chain.size() > 2 && q == res) {\n                        break; // loop\n                    }\n                    if (chain.size() <= 1 || chain[chain.size()-2] != q) {\n                        np = q;\n                        break;\n                    }\n                }\n                p = np;\n            }\n\n            if (chain.size() < K) {\n                continue;\n            }\n\n            const int L = chain.size();\n\n            int area = cubes[chain[0]].area();\n            if (K <= 1) {\n                ans = (ans == -1) ? area : min(ans, area);\n            }\n            for (int j = 1; j < (loop ? 2*L : L); ++j) {\n                if (j >= K) {\n                    int va = chain[(j-K)%L], vb = chain[(j-K+1)%L];\n                    area -= cubes[va].area() - cubes[va].overlap_area(cubes[vb]);\n                }\n                area += cubes[chain[j%L]].area() - cubes[chain[(j-1)%L]].overlap_area(cubes[chain[j%L]]);\n                if (loop && K == L && j == L-1) {\n                    area -= cubes[chain[0]].overlap_area(cubes[chain[L-1]]);\n                }\n                if (j+1 >= K) {\n                    ans = (ans == -1) ? area : min(ans, area);\n                }\n            }\n        }\n\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "      if(f&&vi.size()==k){\n        for(j=0;j<k;j++) t+=c[vi[j]][vi[(j+1)%k]];\n        ans=max(ans,t);\n      }else{\n        for(j=0;j<k-1;j++) t+=c[vi[j]][vi[j+1]];\n        ans=max(ans,t);\n        for(j=0;j<vi.size()-k;j++){\n          t+=c[vi[k-1+j]][vi[k+j]]-c[vi[j]][vi[j+1]];\n          ans=max(ans,t);\n        } \n      }\n    }\n    if(~ans) cout << s*s*6*k-ans << endl;\n    else cout << -1 << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nusing ll = long long;\nstruct E {\n  ll to;\n  ll c;\n};\n\nll n;\nll k;\nll s;\nll x[3000],y[3000],z[3000];\nvector<vector<E>> G;\nvector<bool> used;\n\n\nvoid dfs(int i, vector<ll>& m){\n  for (auto v : G[i]) {\n    if (!used[v.to]) {\n      used[v.to] = true;\n      m.push_back(v.to);\n      dfs(v.to, m);\n      break;\n    }\n  }\n}\n\nll con (int i, int j) {\n  for (auto e : G[i]) {\n    if (j == e.to) {\n      return e.c;\n    }\n  }\n  return 0;\n}\n\nvoid solve(void) {\n  G.clear();\n\n  rep (i,n) G.push_back(vector<E>());\n\n  rep(i,n) {\n    rep (j,n) {\n      if (i >= j) continue;\n\n      ll xd = s - abs(x[i] - x[j]);\n      ll yd = s - abs(y[i] - y[j]);\n      ll zd = s - abs(z[i] - z[j]);\n      if (xd <= 0 || yd <= 0 || zd <= 0) continue;\n      ll cm = -2 * (xd * yd + yd * zd + zd * xd);\n      G[i].push_back((E){j,cm});\n      G[j].push_back((E){i,cm});\n    }\n  }\n\n  used.resize(n);\n  ll ans = 0;\n  rep (i,n) {\n    vector<ll> vs;\n    fill(used.begin(), used.end(), false);\n    vs.push_back(i);\n    used[i] = true;\n    dfs(i, vs);\n\n    if (vs.size() < k || k == 1) continue;\n    bool flag = false;\n    if (k >= 3 && con(vs[0],vs.back()) != 0) {\n      flag = true;\n    }\n\n    if (flag && vs.size() == k) {\n      ll sum = 0;\n      rep (i,vs.size() - 1) {\n        sum += con(vs[i],vs[i+1]);\n      }\n      sum += con(vs[0], vs.back());\n      ans = min(ans, sum);\n    } else {\n      ll sum = 0;\n      rep (i, vs.size()) {\n        if (i == 0) {\n          rep (j, k-1) {\n            sum += con(vs[j], vs[j+1]);\n          }\n        } else {\n          if (!flag && i + k - 1 >= vs.size()) break;\n          sum += con(vs[(i + k - 2) % vs.size()], vs[(i + k - 1) % vs.size()]) - con(vs[i - 1], vs[i]);\n        }\n        ans = min(sum, ans);\n      }\n    }\n  }\n  if (k > 1 && ans == 0) cout << -1 << endl;\n  else cout << s * s * 6 * k + ans << endl;\n}\n\nsigned main (void) {\n  while(true) {\n    cin >> n >> k >> s;\n    if (n == 0) break;\n\n    rep (i,n) cin >> x[i] >> y[i] >> z[i];\n    solve();\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define dbg(...) do{cerr<<__LINE__<<\": \";dbgprint(#__VA_ARGS__, __VA_ARGS__);}while(0);\n\nusing namespace std;\n\nnamespace std{template<class S,class T>struct hash<pair<S,T>>{size_t operator()(const pair<S,T>&p)const{return ((size_t)1e9+7)*hash<S>()(p.first)+hash<T>()(p.second);}};template<class T>struct hash<vector<T>>{size_t operator()(const vector<T> &v)const{size_t h=0;for(auto i : v)h=h*((size_t)1e9+7)+hash<T>()(i)+1;return h;}};}\ntemplate<class T>ostream& operator<<(ostream &os, const vector<T> &v){os<<\"[ \";rep(i,v.size())os<<v[i]<<(i==v.size()-1?\" ]\":\", \");return os;}template<class T>ostream& operator<<(ostream &os,const set<T> &v){os<<\"{ \"; for(const auto &i:v)os<<i<<\", \";return os<<\"}\";}\ntemplate<class T,class U>ostream& operator<<(ostream &os,const map<T,U> &v){os<<\"{\";for(const auto &i:v)os<<\" \"<<i.first<<\": \"<<i.second<<\",\";return os<<\"}\";}template<class T,class U>ostream& operator<<(ostream &os,const pair<T,U> &p){return os<<\"(\"<<p.first<<\", \"<<p.second<<\")\";}\nvoid dbgprint(const string &fmt){cerr<<endl;}template<class H,class... T>void dbgprint(const string &fmt,const H &h,const T&... r){cerr<<fmt.substr(0,fmt.find(\",\"))<<\"= \"<<h<<\" \";dbgprint(fmt.substr(fmt.find(\",\")+1),r...);}\ntypedef long long ll;typedef vector<int> vi;typedef pair<int,int> pi;const int inf = (int)1e9;const double INF = 1e12, EPS = 1e-9;\n\nint main(){\n\tcin.tie(0); cin.sync_with_stdio(0);\n\tint n, k, s;\n\twhile(cin >> n >> k >> s, n){\n\t\tvi x(n), y(n), z(n);\n\t\trep(i, n) cin >> x[i] >> y[i] >> z[i];\n\t\t\n\t\tauto intersect = [&](int i, int j){\n\t\t\tll dx = s - abs(x[i] - x[j]);\n\t\t\tll dy = s - abs(y[i] - y[j]);\n\t\t\tll dz = s - abs(z[i] - z[j]);\n\t\t\tif(dx <= 0 || dy <= 0 || dz <= 0) return 0ll;\n\t\t\treturn (dx * dy + dy * dz + dz * dx) * 2;\n\t\t};\n\t\t\n\t\tvector<vi> e(n);\n\t\trep(i, n) rep(j, i) if(intersect(i, j)){\n\t\t\te[i].pb(j);\n\t\t\te[j].pb(i);\n\t\t\t//dbg(i, j);\n\t\t}\n\t\trep(i, n) assert(e[i].size() <= 2);\n\t\t\n\t\tfunction<bool(int,int,vector<bool>&,vi&)> rec = [&](int c, int p, vector<bool> &v, vi &idx){\n\t\t\tv[c] = 1;\n\t\t\tbool ans = 0;\n\t\t\tidx.pb(c);\n\t\t\tfor(int i : e[c]) if(i != p){\n\t\t\t\tif(v[i]) ans |= 1;\n\t\t\t\telse ans |= rec(i, c, v, idx); \n\t\t\t}\n\t\t\treturn ans;\n\t\t};\n\t\t\n\t\tll ans = 1e18;\n\t\tvector<bool> v(n);\n\t\trep(ii, n) if(!v[ii]){\n\t\t\tvi idx;\n\t\t\tbool loop = rec(ii, ii, v, idx);\n\t\t\tif(idx.size() < k) continue;\n\t\t\t\n\t\t\tif(loop && idx.size() == k){\n\t\t\t\tll sum = 6ll * k * s * s;\n\t\t\t\trep(i, (int)idx.size()){\n\t\t\t\t\tll c = intersect(idx[i], idx[(i + 1) % idx.size()]);\n\t\t\t\t\tsum -= c;\n\t\t\t\t}\n\t\t\t\tans = min(ans, sum);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tll sum = 6ll * k * s * s;\n\t\t\tif(k == 1){\n\t\t\t\tans = min(ans, sum);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tvector<ll> costs;\n\t\t\tif(loop){\n\t\t\t\trep(i, (int)idx.size())\n\t\t\t\t\tcosts.pb(intersect(idx[i], idx[(i + 1) % idx.size()]));\n\t\t\t\tint it = idx.size();\n\t\t\t\trep(i, it) idx.pb(idx[i]);\n\t\t\t\t\n\t\t\t\trep(i, it) assert(count(all(e[idx[i]]), idx[i+1]));\n\t\t\t}\n\t\t\telse{\n\t\t\t\tint hasi = 0;\n\t\t\t\trep(i, idx.size()) if(e[idx[i]].size() == 1) hasi = idx[i];\n\t\t\t\tfor(int i : idx) v[i] = 0;\n\t\t\t\tidx.clear();\n\t\t\t\trec(hasi, hasi, v, idx);\n\t\t\t\t\n\t\t\t\trep(i, (int)idx.size()-1)\n\t\t\t\t\tcosts.pb(intersect(idx[i], idx[i + 1]));\n\t\t\t\t#if 1\n\t\t\t\tassert(idx.size() >= 2);\n\t\t\t\trep(i, idx.size()){\n\t\t\t\t\tif(i==0 || i==idx.size()-1) assert(e[idx[i]].size() == 1);\n\t\t\t\t\telse assert(e[idx[i]].size()==2);\n\t\t\t\t\tassert(e[idx[i]].size() <= 2);\n\t\t\t\t\tassert(e[idx[i]].size() >= 1);\n\t\t\t\t}\n\t\t\t\t#endif\n\t\t\t}\n\t\t\t//dbg(k, costs);\n\t\t\t\n\t\t\trep(i, k-2) sum -= costs[i];\n\t\t\trep(i, (int)costs.size() - (k-1) + 1){\n\t\t\t\tsum -= costs[i + k-2];\n\t\t\t\tans = min(ans, sum);\n\t\t\t\tsum += costs[i];\n\t\t\t}\n\t\t}\n\t\tif(ans >= 1e18) ans = -1;\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing P = pair<int, ll>;\n\nint main()\n{\n\tll n, k, s;\n\twhile (cin >> n >> k >> s, n | k | s) {\n\t\tvector<ll> x(n), y(n), z(n);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcin >> x[i] >> y[i] >> z[i];\n\t\t}\n\t\tif (k == 1) {\n\t\t\tcout << s * s * 6 << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tvector<vector<P>> G(n);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tif (i != j) {\n\t\t\t\t\tll dx = s - abs(x[i] - x[j]), dy = s - abs(y[i] - y[j]), dz = s - abs(z[i] - z[j]);\n\t\t\t\t\tif (dx > 0 && dy > 0 && dz > 0) {\n\t\t\t\t\t\tG[i].push_back(P(j, (dx * dy + dy * dz + dz * dx) * 2));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tll res = s * s * 6 * k, d = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int l = 0; l < 2; l++) {\n\t\t\t\tvector<int> v;\n\t\t\t\tvector<ll> used(n);\n\t\t\t\tll tmp = 0;\n\t\t\t\tbool flag = true;\n\t\t\t\tused[i] = -1;\n\t\t\t\tif (G[i].size() <= l) continue;\n\t\t\t\tfor (auto p : G[i]) {\n\t\t\t\t\tused[p.first] += p.second;\n\t\t\t\t}\n\t\t\t\tv.push_back(G[i][l].first);\n\t\t\t\tfor (int j = 0; j < k - 1; j++) {\n\t\t\t\t\twhile (!v.empty() && used[v.back()] < 0) {\n\t\t\t\t\t\tv.pop_back();\n\t\t\t\t\t}\n\t\t\t\t\tif (v.empty()) {\n\t\t\t\t\t\tflag = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tauto ne = v.back(); v.pop_back();\n\t\t\t\t\ttmp += used[ne];\n\t\t\t\t\tused[ne] = -1;\n\t\t\t\t\tfor (auto p : G[ne]) {\n\t\t\t\t\t\tif (used[p.first] >= 0) {\n\t\t\t\t\t\t\tused[p.first] += p.second;\n\t\t\t\t\t\t\tv.push_back(p.first);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (flag) {\n\t\t\t\t\td = max(d, tmp);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << (d ? res - d : -1) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\nconst int INF = 1LL << 58;\n\nstruct edge\n{\n  int to, cost;\n};\n\nsigned main()\n{\n  int N, K, S;\n  int X[2000], Y[2000], Z[2000];\n\n  while(cin >> N >> K >> S, N) {\n    for(int i = 0; i < N; i++) {\n      cin >> X[i] >> Y[i] >> Z[i];\n    }\n\n    vector< edge > g[2000];\n    for(int i = 0; i < N; i++) {\n      for(int j = 0; j < i; j++) {\n        int latte = max(0, S - abs(X[i] - X[j]));\n        int malta = max(0, S - abs(Y[i] - Y[j]));\n        int beeet = max(0, S - abs(Z[i] - Z[j]));\n        int ukuku = latte * malta + malta * beeet + beeet * latte;\n        if(latte > 0 && malta > 0 && beeet > 0) {\n          g[i].emplace_back((edge) {j, ukuku});\n          g[j].emplace_back((edge) {i, ukuku});\n        }\n      }\n    }\n\n    int ret = -1;\n    for(int i = 0; i < N; i++) {\n      bool v[2000] = {};\n      function< void(int, int, int) > dfs = [&](int idx, int k, int sz)\n      {\n        if(v[idx]++) return;\n        if(k == 0) {\n          if(K >= 2) for(auto &e: g[idx]) if(e.to == i) sz += e.cost;\n          ret = max(ret, sz);\n        } else {\n          for(auto &e : g[idx]) dfs(e.to, k - 1, sz + e.cost);\n        }\n      };\n      dfs(i, K - 1, 0);\n    }\n    if(ret == -1) cout << -1 << endl;\n    else cout << 6 * S * S * K - ret * 2 << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <math.h>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <bitset>\n#include <algorithm>\nusing namespace std;\n\nstruct xyz_t {\n    int x;\n    int y;\n    int z;\n    double length;       //一乗\n};\n\nstruct first_t {\n    int sec;\n    long long w;\n};\n\nbool asc(const xyz_t& left,const xyz_t& right);\nint next(int p,int q);\nint root(int p);\nvoid unite(int p,int q);\nint same(int p,int q);\nvoid pr(vector<vector<int> > pri);\n\nvector<xyz_t> a;\nvector<int> tree;\nvector<vector<int> > tree_f;\nvector<int> num;\nvector<int> flg;\nlong long ans;\nint n,k,s;\ndouble LE;\nlong long sum;\n\nint main(){\n  scanf (\"%d %d %d\",&n,&k,&s);\n  while(n){\n    ans=0;\n    LE=sqrt(s*s*3.0);\n    xyz_t aaa={0,0,0,0};\n    a.assign(n,aaa);\n    tree.assign(n,-1);\n    tree_f.assign(n,vector<int>(1,0));\n    num.assign(n,1);\n    flg.assign(n,0);\n    for(int t=0;t<n;t++){\n      scanf (\"%d %d %d\",&a[t].x,&a[t].y,&a[t].z);\n      a[t].length=sqrt(a[t].x*a[t].x*1.0+a[t].y*a[t].y*1.0+a[t].z*a[t].z*1.0);\n    }\n    sort(a.begin(),a.end(),asc);\n    for(int i=0;i<n;i++){\n      tree[i]=i;\n    }\n    vector<vector<int> > kaburi(n,vector<int> (n,0));\n    switch(k){\n      case 1:\n        printf(\"%d\\n\",s*s*6);\n        break;\n      case 3:\n        for(int t=0;t<n-1;++t){\n          for(int s=t+1;(a[s].length<a[t].length+LE&&s<n);++s){\n            int xx=next(a[t].x,a[s].x);\n            int yy=next(a[t].y,a[s].y);\n            int zz=next(a[t].z,a[s].z);\n            if(xx&&yy&&zz){\n              if(same(t,s)==0){\n                if(num[s]!=1){\n                  num[t]+=num[tree[s]];\n                  num[tree[s]]=0;\n                  unite(s,t);\n                }\n                else{\n                  num[s]+=num[tree[t]];\n                  num[tree[t]]=0;\n                  unite(t,s);\n                }\n                kaburi[s][t]=xx*yy+yy*zz+zz*xx;\n                kaburi[t][s]=kaburi[s][t];\n                //printf(\"%d %d %d\\n\",kaburi[q].back());\n                //printf(\"%d %d %d\\n\",xx,yy,zz);\n              }\n              else{\n                kaburi[s][t]=xx*yy+yy*zz+zz*xx;\n                kaburi[t][s]=kaburi[s][t];\n                if(num[s]==0){\n                  flg[t]=1;\n                }\n                else{\n                  flg[s]=1;\n                }\n              }\n            }\n          }\n        }\n        //pr(kaburi);\n        for(int t=0;t<n;++t){\n          sum=0;\n          if(num[t]>=k){\n            if(flg[t]==0){\n              int u=t;\n              int v=0;\n              int uu=t;\n              tree_f[t][0]=t;\n              for(int r=0;r<k-1;++r){\n                while(kaburi[u][v]==0||v==uu){\n                  ++v;\n                }\n                sum+=kaburi[u][v];\n                tree_f[t].push_back(v);\n                uu=u;\n                u=v;\n                v=0;\n              }\n              for(int r=k-1;r<num[t]-1;++r){\n                while(kaburi[u][v]==0||v==uu){\n                  ++v;\n                }\n                tree_f[t].push_back(v);\n                uu=u;\n                u=v;\n                v=0;\n              }\n              if(ans<sum){\n                ans=sum;\n              }\n              for(int r=0;r+k<num[t];++r){\n                sum=sum-kaburi[tree_f[t][r]][tree_f[t][r+1]]+kaburi[tree_f[t][r+k-1]][tree_f[t][r+k]];\n\n                if(ans<sum){\n                  ans=sum;\n                }\n              }\n            }\n            else{\n              if(num[t]!=k){\n                int u=t;\n                int v=0;\n                int uu=t;\n                tree_f[t][0]=t;\n                for(int r=0;r<k-1;++r){\n                  while(kaburi[u][v]==0||v==uu){\n                    ++v;\n                  }\n                  sum+=kaburi[u][v];\n                  tree_f[t].push_back(v);\n                  uu=u;\n                  u=v;\n                  v=0;\n                }\n                for(int r=k-1;r<num[t]*2;++r){\n                  while(kaburi[u][v]==0||v==uu){\n                    ++v;\n                  }\n                  tree_f[t].push_back(v);\n                  uu=u;\n                  u=v;\n                  v=0;\n                }\n                if(ans<sum){\n                  ans=sum;\n                }\n                for(int r=0;r<num[t];++r){\n                  sum=sum-kaburi[tree_f[t][r]][tree_f[t][r+1]]+kaburi[tree_f[t][r+k-1]][tree_f[t][r+k]];\n                  if(ans<sum){\n                    ans=sum;\n                  }\n                  //printf(\"%lld\\n\",sum);\n                }\n                //pr(tree_f);\n              }\n              else{\n                if(k!=3){\n                  int u=t;\n                  int v=0;\n                  int uu=t;\n                  tree_f[t][0]=t;\n                  for(int r=0;r<k;++r){\n                    while(kaburi[u][v]==0||v==uu){\n                      ++v;\n                    }\n                    sum+=kaburi[u][v];\n                    uu=u;\n                    u=v;\n                    v=0;\n                  }\n                  if(ans<sum){\n                    ans=sum;\n                  }\n                }\n                else{\n                  int u=t;\n                  int v=0;\n                  int uu=t;\n                  tree_f[t][0]=t;\n                  for(int r=0;r<k;++r){\n                    while(kaburi[u][v]==0||v==uu){\n                      ++v;\n                    }\n                    sum+=kaburi[u][v];\n                    tree_f[t].push_back(v);\n                    uu=u;\n                    u=v;\n                    v=0;\n                  }\n                  int xxx=s+min({a[tree_f[t][0]].x,a[tree_f[t][1]].x,a[tree_f[t][2]].x})-max({a[tree_f[t][0]].x,a[tree_f[t][1]].x,a[tree_f[t][2]].x});\n                  int yyy=s+min({a[tree_f[t][0]].y,a[tree_f[t][1]].y,a[tree_f[t][2]].y})-max({a[tree_f[t][0]].y,a[tree_f[t][1]].y,a[tree_f[t][2]].y});\n                  int zzz=s+min({a[tree_f[t][0]].z,a[tree_f[t][1]].z,a[tree_f[t][2]].z})-max({a[tree_f[t][0]].z,a[tree_f[t][1]].z,a[tree_f[t][2]].z});\n                  sum=sum-(xxx*yyy+yyy*zzz+zzz*xxx);\n                  if(ans<sum){\n                    ans=sum;\n                  }\n                }\n              }\n            }\n          }\n        }\n        if(ans==0){\n          printf(\"-1\\n\");\n        }\n        else{\n          printf(\"%lld\\n\",s*s*6*k-ans*2);\n        }\n        break;\n      default:\n        for(int t=0;t<n-1;++t){\n          for(int s=t+1;(a[s].length<a[t].length+LE&&s<n);++s){\n            int xx=next(a[t].x,a[s].x);\n            int yy=next(a[t].y,a[s].y);\n            int zz=next(a[t].z,a[s].z);\n            if(xx&&yy&&zz){\n              if(same(t,s)==0){\n                if(num[s]!=1){\n                  num[t]+=num[tree[s]];\n                  num[tree[s]]=0;\n                  unite(s,t);\n                }\n                else{\n                  num[s]+=num[tree[t]];\n                  num[tree[t]]=0;\n                  unite(t,s);\n                }\n                kaburi[s][t]=xx*yy+yy*zz+zz*xx;\n                kaburi[t][s]=kaburi[s][t];\n                //printf(\"%d %d %d\\n\",kaburi[q].back());\n                //printf(\"%d %d %d\\n\",xx,yy,zz);\n              }\n              else{\n                kaburi[s][t]=xx*yy+yy*zz+zz*xx;\n                kaburi[t][s]=kaburi[s][t];\n                if(num[s]==0){\n                  flg[t]=1;\n                }\n                else{\n                  flg[s]=1;\n                }\n              }\n            }\n          }\n        }\n        //pr(kaburi);\n        for(int t=0;t<n;++t){\n          sum=0;\n          if(num[t]>=k){\n            if(flg[t]==0){\n              int u=t;\n              int v=0;\n              int uu=t;\n              tree_f[t][0]=t;\n              for(int r=0;r<k-1;++r){\n                while(kaburi[u][v]==0||v==uu){\n                  ++v;\n                }\n                sum+=kaburi[u][v];\n                tree_f[t].push_back(v);\n                uu=u;\n                u=v;\n                v=0;\n              }\n              for(int r=k-1;r<num[t]-1;++r){\n                while(kaburi[u][v]==0||v==uu){\n                  ++v;\n                }\n                tree_f[t].push_back(v);\n                uu=u;\n                u=v;\n                v=0;\n              }\n              if(ans<sum){\n                ans=sum;\n              }\n              for(int r=0;r+k<num[t];++r){\n                sum=sum-kaburi[tree_f[t][r]][tree_f[t][r+1]]+kaburi[tree_f[t][r+k-1]][tree_f[t][r+k]];\n\n                if(ans<sum){\n                  ans=sum;\n                }\n              }\n            }\n            else{\n              if(num[t]!=k){\n                int u=t;\n                int v=0;\n                int uu=t;\n                tree_f[t][0]=t;\n                for(int r=0;r<k-1;++r){\n                  while(kaburi[u][v]==0||v==uu){\n                    ++v;\n                  }\n                  sum+=kaburi[u][v];\n                  tree_f[t].push_back(v);\n                  uu=u;\n                  u=v;\n                  v=0;\n                }\n                for(int r=k-1;r<num[t]*2;++r){\n                  while(kaburi[u][v]==0||v==uu){\n                    ++v;\n                  }\n                  tree_f[t].push_back(v);\n                  uu=u;\n                  u=v;\n                  v=0;\n                }\n                if(ans<sum){\n                  ans=sum;\n                }\n                for(int r=0;r<num[t];++r){\n                  sum=sum-kaburi[tree_f[t][r]][tree_f[t][r+1]]+kaburi[tree_f[t][r+k-1]][tree_f[t][r+k]];\n                  if(ans<sum){\n                    ans=sum;\n                  }\n                  //printf(\"%lld\\n\",sum);\n                }\n                //pr(tree_f);\n              }\n              else{\n                int u=t;\n                int v=0;\n                int uu=t;\n                tree_f[t][0]=t;\n                for(int r=0;r<k;++r){\n                  while(kaburi[u][v]==0||v==uu){\n                    ++v;\n                  }\n                  sum+=kaburi[u][v];\n                  uu=u;\n                  u=v;\n                  v=0;\n                }\n                if(ans<sum){\n                  ans=sum;\n                }\n              }\n            }\n          }\n        }\n        if(ans==0){\n          printf(\"-1\\n\");\n        }\n        else{\n          printf(\"%lld\\n\",s*s*6*k-ans*2);\n        }\n    }\n    scanf (\"%d %d %d\",&n,&k,&s);\n  }\n}\n/*\n環状 k=3の時 それ以外の時\n\n\n*/\n\n\nbool asc(const xyz_t& left,const xyz_t& right){\n  return left.length<right.length;\n}\n\nint next(int p,int q){\n  if(-s<=(p-q)&&(p-q)<=s){\n    if((p-q)>=0){\n      return s-(p-q);\n    }\n    else{\n      return s-(q-p);\n    }\n  }\n  else{\n    return 0;\n  }\n}\n\nint root(int p){\n  if (tree[p] == p){// 根\n    return p;\n  }\n  else {\n    return tree[p] = root(tree[p]); // 経路圧縮\n  }\n}\n\nvoid unite(int p, int q){\n  p = root(p);\n  q = root(q);\n  if (p == q){}\n  else{\n    tree[p] = q;     //pの親をqの親にする\n  }\n}\n\nint same(int p, int q){\n  return root(p) == root(q);\n}\n\n\n\nvoid pr(vector<vector<int> > pri){\n  for(int t=0;t<int(pri.size());++t){\n    for(int s=0;s<int(pri[t].size())-1;++s){\n      printf(\"%d \",pri[t][s]);\n    }\n    printf(\"%d\\n\",pri[t][pri[t].size()-1]);\n  }\n  printf(\"\\n\");\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define all(v) (v).begin(),(v).end()\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\n#define pb push_back\n#define fi first\n#define se second\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nint N,K,S;\nint X[2222][3];\n\nint table[2222][2222];\n\nint f(int a,int b){\n    if(a>b)swap(a,b);\n    return max(0ll,a+S-b);\n}\nvint G[2222];\n\nbool used[2222];\nint dfs(int v,int c,int p){\n    if(c==K){\n        return table[p][v];\n    }\n\n    used[v]=true;\n    int ret=LLONG_MIN;\n    for(auto u:G[v]){\n        if(used[u])continue;\n        int tmp=dfs(u,c+1,p);\n        if(tmp!=LLONG_MIN)chmax(ret,tmp+table[v][u]);\n    }\n    used[v]=false;\n    return ret;\n}\n\nvoid solve(){\n    rep(i,N)rep(j,3)cin>>X[i][j];\n    memset(table,0,sizeof(table));\n    rep(i,N)G[i].clear();\n    rep(i,N)rep(j,N)if(i!=j){\n        vint v;\n        bool flag=true;\n        rep(k,3){\n            int tmp=f(X[i][k],X[j][k]);\n            if(tmp==0){\n                flag=false;\n            }\n            v.pb(tmp);\n        }\n        if(!flag)continue;\n        G[i].pb(j);\n        rep(k,3)table[i][j]+=v[k]*v[(k+1)%3];\n    }\n\n    memset(used,0,sizeof(used));\n    int ma=LLONG_MIN;\n    rep(i,N){\n        chmax(ma,dfs(i,1,i));\n    }\n\n    if(ma==LLONG_MIN){\n        cout<<-1<<endl;\n        return;\n    }\n    cout<<(3*S*S*K-ma)*2<<endl;\n}\n\nsigned main(){\n    while(cin>>N>>K>>S,N||K||S)solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include\"bits/stdc++.h\"\n#define FOR(i, a, b) for (int i = a; i < b; i++)\n#define REP(i, n) FOR(i, 0, n)\n#define RFOR(i, a, b) for (int i = b - 1; i >= a; i--)\n#define RREP(i, n) RFOR(i, 0, n)\n#define rep(i, a, b) for (auto i = a; i < b; i++)\n#define rrep(i, a, b) for (auto i = a; i > b; i--)\n#define range(i, a, b) (a <= i && i < b)\n#define ll long long\n#define fi first\n#define fs first\n#define se second\n#define sc second\n//#define int long long\nusing namespace std;\nusing vec = vector<int>;\nusing mat = vector<vec>;\ntypedef pair<int, int> P;\n\nint n, k, s, en;\nvector<pair<int, int>> v[2001];\n\nint tmp;\nvoid dfs(int no, int dep, int par) {\n\tif (no == en && dep > 1) tmp = -(1 << 30);\n\tif (dep == k) {\n\t\tfor (auto to : v[no]) {\n\t\t\tif (to.fs == en && k > 2) tmp += to.sc;\n\t\t}\n\t\treturn;\n\t}\n\tbool flag = true;\n\tfor (auto to : v[no]) {\n\t\tif (to.fs == par) continue;\n\t\ttmp += to.sc;\n\t\tdfs(to.fs, dep+1, no);\n\t\tflag = false;\n\t}\n\tif (flag) tmp = -(1 << 30);\n}\n\nvoid solve() {\n\trep(i, 0, 2001) v[i].clear();\n\tint x[2001], y[2001], z[2001];\n\trep(i, 0, n) {\n\t\tcin >> x[i] >> y[i] >> z[i];\n\t}\n\trep(i, 0, n) {\n\t\trep(j, 0, n) {\n\t\t\tif (i == j) continue;\n\t\t\tint dx = s - abs(x[i] - x[j]);\n\t\t\tint dy = s - abs(y[i] - y[j]);\n\t\t\tint dz = s - abs(z[i] - z[j]);\n\t\t\tif (dx < 0 || dy < 0 || dz < 0) continue;\n\t\t\tv[i].push_back(make_pair(j, 2 * (dx * dy + dy * dz + dz * dx)));\n\t\t}\n\t}\n\n\tint res = -1;\n\tREP(i, n) {\n\t\tif (v[i].size() == 2) for (auto to : v[i]) tmp = 0, en = i, dfs(i, 1, to.fs), res = max(res, tmp);\n\t\telse tmp = 0, en = -1, dfs(i,1,-1), res = max(res, tmp);\n\t}\n\n\tif (res == -1) cout << -1 << endl;\n\telse cout << 6 * s*s*k - res << endl;\n\n}\n\nint main() {\n\twhile (cin >> n >> k >> s, n) solve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <array>\n#include <cassert>\n#include <climits>\n#include <complex>\n#include <cstdio>\n#include <cstring>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <iterator>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <string>\n#include <tuple>\n#include <vector>\n\nusing namespace std;\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define ALL(x) (x).begin(), (x).end()\n\nint subcube(int len, int x0, int y0, int z0, int x1, int y1, int z1) {\n    int dx = x0 - x1, dy = y0 - y1, dz = z0 - z1;\n    int sx = max(min(len + dx, len - dx), 0);\n    int sy = max(min(len + dy, len - dy), 0);\n    int sz = max(min(len + dz, len - dz), 0);\n    return (sx * sy * sz == 0) ? 0 : 2 * (sx * sy + sy * sz + sz * sx);\n}\n\nint main(){\n    int n, k, s; \n    while(cin >> n >> k >> s, n != 0){\n    vector<int> xs(n), ys(n), zs(n);\n    REP(i, n) {\n        cin >> xs[i] >> ys[i] >> zs[i];\n    }\n\n    if (k == 1) cout << s * s * 6 * k << endl;\n    vector<vector<int>> subc(n, vector<int>(n));\n    REP(a, n) {\n        REP(b, n) {\n            if (a == b) {/*cout << \"--\\t\";*/ continue;}\n            subc[a][b] = subcube(s, xs[a], ys[a], zs[a], xs[b], ys[b], zs[b]);\n            //cout << subc[a][b] << \"\\t\";\n        }\n        cout << endl;\n    }\n\n    vector<vector<int>> segs;\n    vector<int> used(n, false);\n\n    /// 4 8 12 16 20\n    REP(a, n){\n        if (used[a]) continue;\n        vector<int> seg;\n        int p = a; bool ok = true;\n        seg.push_back(p);\n        used[a] = true;\n        while(ok) {\n            ok = false;\n            REP(b, n) {\n                if (subc[p][b] > 0) {\n                    if (used[b]) continue;\n                    p = b;\n                    seg.push_back(p);\n                    used[b] = true;\n                    ok = true;\n                    break;\n                }\n            }\n        }\n        reverse(ALL(seg));\n        p = a;\n        ok = true;\n        while(ok) {\n            ok = false;\n            REP(b, n) {\n                //cout << \"?\" << a << \"->\" << b << endl;\n                if (subc[p][b] > 0) {\n                    if (used[b]) continue;\n                    p = b;\n                    seg.push_back(p);\n                    used[b] = true;\n                    ok = true;\n                    break;\n                }\n            }\n        }\n        segs.push_back(seg);\n    }\n\n    int res = -1;\n    REP(i, segs.size()) {\n        const vector<int> seg(segs[i]);\n        \n        /*cout << \"# \"; REP(a, seg.size()) {\n            cout << seg[a] << \" \";\n        } cout << endl;*/\n        \n        const int l = seg.size();\n        if (l < k) { continue; }\n        if (l == k) {\n            int sum = 0;\n            if (l == 2) {\n                res = max(res, subc[seg[0]][seg[1]]);\n                continue;\n            }\n            REP(a, l) {\n                //cout << \"+=\" << seg[a] << \" \" << seg[(a+1)%l] << endl;\n                //cout << \"   : \" << subc[seg[a]][seg[(a+1)%l]] << endl;\n                sum += subc[seg[a]][seg[(a+1)%l]];\n            }\n            res = max(res, sum);\n            continue;\n        }\n        int sum = 0;\n        REP(a, k - 1) {\n            sum += subc[seg[a]][seg[a+1]];\n        }\n        REP(a, l) {\n            res = max(res, sum);\n            int ad = subc[seg[(a + k - 1) % l]][seg[(a + k) % l]];\n            if (ad == 0) break;\n            sum += ad;\n            sum -= subc[seg[(a % l)]][seg[(a + 1) % l]];\n        }\n    }\n\n    // cout << \"$\" << subc[0][1] << endl;\n    // cout << res << endl;\n    if (res < 0) cout << res << endl;\n    else cout << s * s * 6 * k - res << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cmath>\n#include <map>\n\nusing namespace std;\n\ntypedef  long long ll;\nll inf = (ll)20000000000000;\nvector<ll>x,y,z;\nint n,k,s;\nll calc(int i,int j){\n    ll tx=0,ty=0,tz=0;    \n    if(x[i]<=x[j]&&x[j]<=x[i]+s){\n        tx = x[i]+s-x[j];\n    }\n    if(y[i]<=y[j]&&y[j]<=y[i]+s){\n        ty = y[i]+s-y[j];\n    }\n    if(z[i]<=z[j]&&z[j]<=z[i]+s){\n        tz = z[i]+s-z[j];\n    }\n    if(x[j]<=x[i]&&x[i]<=x[j]+s){\n        tx = x[j]+s-x[i];\n    }\n    if(y[j]<=y[i]&&y[i]<=y[j]+s){\n        ty = y[j]+s-y[i];\n    }\n    if(z[j]<=z[i]&&z[i]<=z[j]+s){\n        tz = z[j]+s-z[i];\n    }\n    if(tx==0||ty==0||tz==0){\n        return -1;\n    }\n    return 2*(tx*ty+ty*tz+tz*tx);\n}\n\nll saiki(int st,int i,int b,int c,vector<vector<pair<int,ll> > > &g){\n    if(c==k){\n        ll p = 0;\n        for(auto x:g[i]){\n            if(x.first==st){\n                p = x.second;\n            }\n        }\n        return p;\n    }\n    ll p = -inf;\n    for(auto x:g[i]){\n        if(x.first!=st&&x.first!=b){\n            p = max(p,x.second+saiki(st,x.first,i,c+1,g));\n        }\n    }\n    return p;\n}\n\nint main(){\n    \n    while(cin >> n >> k >> s&&n!=0){\n        x.resize(n);y.resize(n);z.resize(n);\n        for(int i=0;i<n;i++)cin >> x[i] >> y[i] >> z[i];\n        vector<vector<pair<int,ll> > >g(n);\n\n        for(int i=0;i<n;i++){\n            for(int j=0;j<n;j++){\n                if(i!=j){\n                    ll sm = calc(i,j);\n                    if(sm!=-1){\n                        g[i].push_back(make_pair(j,sm));\n                        g[j].push_back(make_pair(i,sm));\n                    }\n                }\n            }\n        }\n        ll ans = -1;\n        if(k==1){\n            cout << s*s*6 << endl;\n            continue;\n        }\n        for(int i=0;i<n;i++){\n            ans = max(ans,saiki(i,i,-1,1,g));\n        }\n        if(ans ==-1)cout << -1 << endl;\n        else cout << s*s*k*6-ans << endl;\n\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <array>\n#include <list>\n#include <string>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <unordered_map>\n#include <unordered_set>\n#include <tuple>\n#include <memory>\n#include <cmath>\n#include <algorithm>\n#include <functional>\n#include <iomanip>\n#include <numeric>\n#include <climits>\n#include <cfloat>\n#include <cassert>\n#include <random>\n#include <set>\n\nstruct Cube {\n\tint x, y, z, size;\n\tint intersect_area(const Cube& that) const {\n\t\tconst auto height = std::min(x + size, that.x + size) - std::max(x, that.x);\n\t\tconst auto width = std::min(y + size, that.y + size) - std::max(y, that.y);\n\t\tconst auto depth = std::min(z + size, that.z + size) - std::max(z, that.z);\n\t\tif (height <= 0 || width <= 0 || depth <= 0) return 0;\n\t\treturn (height * width + width * depth + depth * height) * 2;\n\t}\n};\nint main() {\n\twhile (true) {\n\t\tint n, k, s; std::cin >> n >> k >> s; if (n == 0 && k == 0 && s == 0) break;\n\t\tstd::vector<Cube> cubes(n); for (auto& c : cubes) {\n\t\t\tstd::cin >> c.x >> c.y >> c.z;\n\t\t\tc.size = s;\n\t\t}\n\t\tif (k == 1) {\n\t\t\tstd::cout << s * s * 6 << std::endl;\n\t\t\tcontinue;\n\t\t}\n\t\tstd::vector<std::vector<int>> nodes(n);\n\t\tfor (auto i = 0; i < n; ++i) {\n\t\t\tfor (auto j = 0; j < i; ++j) {\n\t\t\t\tif (cubes[i].intersect_area(cubes[j]) > 0) {\n\t\t\t\t\tnodes[i].push_back(j);\n\t\t\t\t\tnodes[j].push_back(i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tstd::vector<bool> searching(n, false);\n\t\tstd::vector<Cube> temp;\n\t\tstd::vector<int> sum;\n\t\tstd::stack<int> stack;\n\t\tint max_reduce = -1;\n\t\tfor (auto i = 0; i < n; ++i) if (!searching[i] && nodes[i].size() == 1) {\n\t\t\ttemp.clear();\n\t\t\tstack.push(i);\n\t\t\twhile (!stack.empty()) {\n\t\t\t\tconst auto top = stack.top(); stack.pop();\n\t\t\t\ttemp.push_back(cubes[top]);\n\t\t\t\tsearching[top] = true;\n\t\t\t\tfor (const auto next : nodes[top]) if (!searching[next]) {\n\t\t\t\t\tstack.push(next);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (temp.size() < k) continue;\n\t\t\tsum.clear(); sum.push_back(0);\n\t\t\tfor (auto j = 1; j < temp.size(); ++j) {\n\t\t\t\tsum.push_back(sum.back() + temp[j].intersect_area(temp[j - 1]));\n\t\t\t}\n\t\t\tfor (auto j = k - 1; j < temp.size(); ++j) {\n\t\t\t\tmax_reduce = std::max(max_reduce, sum[j] - sum[j - k + 1]);\n\t\t\t}\n\t\t}\n\t\tfor (auto i = 0; i < n; ++i) if (!searching[i] && nodes[i].size() == 2) {\n\t\t\ttemp.clear();\n\t\t\ttemp.push_back(cubes[i]);\n\t\t\tsearching[i] = true;\n\t\t\tstack.push(nodes[i].front());\n\t\t\twhile (!stack.empty()) {\n\t\t\t\tconst auto top = stack.top(); stack.pop();\n\t\t\t\ttemp.push_back(cubes[top]);\n\t\t\t\tsearching[top] = true;\n\t\t\t\tfor (const auto next : nodes[top]) if (!searching[next]) {\n\t\t\t\t\tstack.push(next);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (temp.size() < k) continue;\n\t\t\tsum.clear(); sum.push_back(0);\n\t\t\tfor (auto j = 1; j < temp.size(); ++j) {\n\t\t\t\tsum.push_back(sum.back() + temp[j].intersect_area(temp[j - 1]));\n\t\t\t}\n\t\t\tsum.push_back(sum.back() + temp.front().intersect_area(temp.back()));\n\t\t\tif (temp.size() == k) {\n\t\t\t\tmax_reduce = std::max(max_reduce, sum.back());\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor (auto j = 1; j < temp.size(); ++j) {\n\t\t\t\tsum.push_back(sum.back() + temp[j].intersect_area(temp[j - 1]));\n\t\t\t}\n\t\t\tfor (auto j = k - 1; j < sum.size(); ++j) {\n\t\t\t\tmax_reduce = std::max(max_reduce, sum[j] - sum[j - k + 1]);\n\t\t\t}\n\t\t}\n\t\tif (max_reduce == -1) {\n\t\t\tstd::cout << -1 << std::endl;\n\t\t}\n\t\telse {\n\t\t\tstd::cout << k * s * s * 6 - max_reduce << std::endl;\n\t\t}\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing ll = long long;\nstruct Edge {\n    ll dst, w;\n    Edge() {}\n    Edge(ll d, ll w) : dst(d), w(w) {}\n};\nusing Graph = vector<vector<Edge>>;\nstruct Cube { ll p[3]; };\n\n// グラフを構成する\nGraph MakeGraph(const int n, const int s, vector<Cube> &c) {\n    Graph g(n);\n    ll d[3];\n\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            for (int k = 0; k < 3; ++k)\n                d[k] = s - abs(c[i].p[k] - c[j].p[k]);\n\n            // c[i]とc[j]は交差しない\n            if (min({d[0], d[1], d[2]}) <= 0) continue;\n\n            ll w = 2 * d[0] * d[1] + 2 * d[0] * d[2] + 2 * d[1] * d[2];\n            g[i].emplace_back(Edge(j, w));\n            g[j].emplace_back(Edge(i, w));\n        }\n    }\n\n    return g;\n}\n\nll Dfs(const int start, const int prev, const int cur, int size, const Graph &g) {\n    if (size == 0) {\n        if ((g[cur].size() == 2) && ((g[cur][0].dst == start && g[cur][0].dst != prev)\n             || (g[cur][1].dst == start && g[cur][1].dst != prev)))\n            return (g[cur][0].dst == start) ? g[cur][0].w : g[cur][1].w;\n        else\n            return 0;\n    }\n\n    ll max_w = -1;\n    for (const auto &e : g[cur])\n        if (e.dst != prev) {\n            const ll res = Dfs(start, cur, e.dst, size - 1, g);\n            if (res != -1) max_w = max(max_w, res + e.w);\n        }\n\n    return max_w;\n}\n\nint MinimumArea(const int n, const int k, const int s, const Graph &g) {\n    ll res = -1;\n\n    for (int v = 0; v < n; ++v)\n        res = max(res, Dfs(v, -1, v, k - 1, g));\n\n    return (res == -1) ? -1 : 6 * k * s * s - res;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int n, k, s;\n\n    while (cin >> n >> k >> s, n) {\n        vector<Cube> cube(n);\n        for (auto &c : cube)\n            for (int i = 0; i < 3; ++i) cin >> c.p[i];\n\n        cout << MinimumArea(n, k, s, MakeGraph(n, s, cube)) << '\\n';\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\n\nconstexpr ll INF = 1e18;\n\nstruct edge {\n    int to;\n    ll cost;\n};\n\nusing edges = vector<edge>;\nusing graph = vector<edges>;\n\nint main() {\n    ll n, k, s;\n    while(cin >> n >> k >> s, n) {\n        vector<ll> x(n), y(n), z(n);\n        for(int i=0; i<n; ++i) {\n            cin >> x[i] >> y[i] >> z[i];\n        }\n        if(k == 1) {\n            cout << s*s*6 << endl;\n            continue;\n        }\n        graph g(n);\n        for(int i=0; i<n; ++i) {\n            for(int j=i+1; j<n; ++j) {\n                ll dx = abs(x[i] - x[j]), dy = abs(y[i] - y[j]), dz = abs(z[i] - z[j]);\n                if(dx <= s && dy <= s && dz <= s) {\n                    ll S = ((s - dx)*(s - dy) + (s - dy)*(s - dz) + (s - dz)*(s - dx)) * 2;\n                    g[i].push_back(edge{j, -S});\n                    g[j].push_back(edge{i, -S});\n                }\n            }\n        }\n        vector<bool> chain(n);\n        vector<bool> cycle(n, true);\n        for(int i=0; i<n; ++i) {\n            if(g[i].size() == 1) {\n                chain[i] = true;\n                cycle[i] = false;\n                int now = i, prev = -1;\n                bool update = true;\n                while(update) {\n                    update = false;\n                    for(auto& e : g[now]) {\n                        if(prev != e.to) {\n                            update = true;\n                            prev = now;\n                            now = e.to;\n                            chain[now] = cycle[now] = false;\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n        ll res = INF;\n        vector<int> cnt(n);\n        for(int i=0; i<n; ++i) {\n            if(chain[i] || cycle[i]) {\n                if(cnt[i]) {\n                    continue;\n                }\n                cnt[i] = 1;\n                deque<ll> usedv;\n                deque<ll> cost;\n                int now = i, prev = -1;\n                usedv.push_back(now);\n                ll t = s * s * 6;\n                bool update = true;\n                while(true) {\n                    if(usedv.size() == k) {\n                        res = min(res, t);\n                    }\n                    if(!update) {\n                        break;\n                    }\n                    update = false;\n                    for(auto& e : g[now]) {\n                        if(prev != e.to) {\n                            if(usedv.size() == k && e.to == usedv.front()) {\n                                t += e.cost;\n                                break;\n                            }\n                            usedv.push_back(e.to);\n                            t += s * s * 6 + e.cost;\n                            cost.push_back(s*s*6 + e.cost);\n                            if(usedv.size() > k) {\n                                usedv.pop_front();\n                                t -= cost.front();\n                                cost.pop_front();\n                            }\n                            prev = now;\n                            now = e.to;\n                            cnt[now] += 1;\n                            update = cnt[usedv.front()] <= 1;\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n        cout << (res == INF ? -1 : res) << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 2001\n#define int long long\nusing namespace std;\nvector<int>G[N];\nint n,K,S;\nstruct point{int x,y,z;};\n\nint Area(){return S*S*6;}\nint sArea(point a,point b){\n  int x = min(a.x+S, b.x+S),X = max(a.x,b.x);\n  int y = min(a.y+S, b.y+S),Y = max(a.y,b.y);\n  int z = min(a.z+S, b.z+S),Z = max(a.z,b.z);\n  if(y <= Y || x <= X || z <= Z) return 0;\n  int area=0;\n  area += 2*(x-X)*(y-Y);\n  area += 2*(y-Y)*(z-Z);\n  area += 2*(z-Z)*(x-X);\n  return area;\n}\n\nvector<point> A;\n\nint dfs(int pos,int k,int start,int prev){\n  if(k == K) return prev==-1? 0:-sArea(A[pos],A[start]);\n  if(prev!=-1 && pos == start) return 1e15;\n  \n  int res = 1e9;\n  for(int nx:G[pos]){\n    if(nx == prev)continue;\n    int area = Area() - sArea(A[pos],A[nx]);\n    res = min(res,area+dfs(nx,k+1,start,pos));\n  }\n  return res;\n}\n\nsigned main(){\n  while(1){\n    cin>>n>>K>>S;\n    if(!n&&!K&&!S)break;\n    \n    A.resize(n);\n    for(int i=0;i<n;i++)cin>>A[i].x>>A[i].y>>A[i].z;\n    \n    for(int i=0;i<N;i++) G[i].clear();\n\n    for(int i=0;i<n;i++)\n      for(int j=i+1;j<n;j++){\n\tif(!sArea(A[i],A[j]))continue;\n\tG[i].push_back(j);\n\tG[j].push_back(i);\n      }\n\n    for(int i=0;i<n;i++) assert(G[i].size()<3);\n    int ans = 1e9;\n    for(int i=0;i<n;i++){\n      \n      ans = min(ans,Area()+dfs(i,1,i,-1));\n    }\n\n    if(ans == 1e9) ans = -1;\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <cmath>\n#include <cstdlib>\n#include <map>\nusing namespace std;\n\nclass Point {\npublic:\n    int x, y, z;\n    Point(int x = 0, int y = 0, int z = 0) : x(x), y(y), z(z) {}\n};\n\nclass Cube {\npublic:\n    Point p;\n    int s;\n    int vx[4] = {0, 1, 1, 0}, vy[4] = {0, 0, 1, 1}, vz[2] = {0, 1};\n    Cube(Point p = Point(), int s = 0) : p(p), s(s) {}\n\n    bool isIn(const Cube &c) {\n        return ((abs(p.x - c.p.x) < s) && (abs(p.y - c.p.y) <= s) && (abs(p.z - c.p.z) <= s) &&\n                (abs(p.x - c.p.x) <= s) && (abs(p.y - c.p.y) < s) && (abs(p.z - c.p.z) <= s) &&\n                (abs(p.x - c.p.x) <= s) && (abs(p.y - c.p.y) <= s) && (abs(p.z - c.p.z) < s));\n    }\n\n    long long shareS(Cube &c) {\n        long long ret = 0;\n        Point a, b;\n        a = p; b = c.p;\n\n        if (a.x > b.x) swap(a.x, b.x);\n        if (a.y > b.y) swap(a.y, b.y);\n        if (a.z > b.z) swap(a.z, b.z);\n\n        ret += abs((a.x + s - b.x) * (a.z + s - b.z) * 2);\n        ret += abs((a.y + s - b.y) * (a.z + s - b.z) * 2);\n        ret += abs((a.x + s - b.x) * (a.y + s - b.y) * 2);\n        return ret;\n    }\n\n};\n\nint n, k, s, x, y, z;\nlong long ans;\nvector<Cube> c;\nvector<vector<int> > subg;\nvector<bool> used;\nvector<deque<int> > graph;\ndeque<int> que;\n\ninline void makegraph() {\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            if (c[i].isIn(c[j])) {\n                subg[j].push_back(i);\n                subg[i].push_back(j);\n            }\n        }\n    }\n}\n\n// make path\nvoid dfs(int v, bool f) {\n    used[v] = true;\n    int size_ = subg[v].size();\n    bool flag = false;\n\n    for (int i = 0; i < size_; ++i) {\n        if (!used[subg[v][i]]) {\n            // ???????????¢?´¢?????????????????£??????\n            if (!flag && !f) {\n                dfs(subg[v][i], false);\n                que.push_front(v);\n                flag = true;\n            }\n            else {\n                que.push_front(subg[v][i]);\n                dfs(subg[v][i], true);\n            }\n        }\n    }\n\n    if (!flag && !f) que.push_front(v);\n}\n\n// is graph[graphid] cycle ?\ninline bool isCycle(int graphid) {\n    int size_ = graph[graphid].size();\n\n    // if all vertex's degree are two, this graph has closed path.\n    for (int i = 0; i < size_; ++i) {\n        if (subg[graph[graphid][i]].size() != 2) return false;\n    }\n\n    return true;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    while (cin >> n >> k >> s, n | k | s) {\n        c.resize(n);\n        subg.resize(n);\n        que.clear();\n        used.assign(n, false);\n        ans = int(1e15);\n\n        for (int i = 0; i < n; ++i) {\n            cin >> x >> y >> z;\n            c[i] = {Point(x, y, z), s};    \n        }\n\n        makegraph();\n\n        for (int i = 0; i < n; ++i) {\n            if (!used[i]) {\n                dfs(i, false);\n                graph.push_back(que);\n                que.clear();\n            }\n        }\n\n        int gsize = graph.size(), qsize, upper;\n        long long share;\n        bool isGraphCycle = false;\n\n        for (int i = 0; i < gsize; ++i) {\n            qsize = graph[i].size();\n            isGraphCycle = isCycle(i);\n\n            if (qsize < k) continue;\n\n            for (int j = 0; j < qsize; ++j) {\n                share = 0;\n                //cout << \"isGraphCycle \" << isGraphCycle << endl;\n                if (!isGraphCycle && j + k - 1 >= qsize) continue;\n\n                for (int l = 0; l < k - 1; ++l) {\n                    //cout << (j + l) % qsize << \", \" << (j + l + 1) % qsize << endl;\n                    share += c[graph[i][(j + l) % qsize]].shareS(c[graph[i][(j + l + 1) % qsize]]);\n                }\n\n\n                if (isGraphCycle && qsize == k) {\n                    share += c[graph[i][j % qsize]].shareS(c[graph[i][(j + qsize - 1) % qsize]]);\n                }\n\n                ans = min(ans, 6 * s * s * k - share);\n            }\n        }\n\n        if (n == 1) ans = 6 * s * s;\n        if (ans == int(1e15)) ans = -1;\n\n        cout << ans << endl;\n        //cout << endl;\n\n        c.clear();\n        graph.clear();\n        subg.clear();\n        used.clear();\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#define rep(i,n) for(int i=0;(i)<(n);(i)++)\n#define setmin(x,y) if(x>y){x=y;}\nint n,k,s;\nint tmp;\nint x[2000],y[2000],z[2000],p[2000];\nint inf = 1e9+7;\nint g[2000][2000];\nint is_connected(int i, int j) {\n    int dx = abs(x[j] - x[i]);\n    int dy = abs(y[j] - y[i]);\n    int dz = abs(z[j] - z[i]);\n    return dx <= s && dy <= s && dz <= s;\n}\nint intersecting_area(int i, int j) {\n    if (!is_connected(i, j)) return 0;\n    int dx = s - abs(x[j] - x[i]);\n    int dy = s - abs(y[j] - y[i]);\n    int dz = s - abs(z[j] - z[i]);\n    return 2 * (dx * dy + dy * dz + dz * dx);\n}\nint dfs(int i, int prev, int depth, int first) {\n    if (depth == k) {\n        if (3 <= k && is_connected(i, first)) {\n            return 6*s*s - intersecting_area(i, first);\n        }\n        return 6*s*s;\n    } else {\n        int ans = inf;\n        for (int j=0;j<p[i];j++) if (g[i][j] != prev) {\n            setmin(ans, 6*s*s - intersecting_area(i, g[i][j]) + dfs(g[i][j], i, depth + 1, first));\n        }\n        return ans;\n    }\n}\nint main(void){\n    while(1){\n        scanf(\"%d%d%d\",&n,&k,&s);\n        if(n==0&&k==0&&s==0) break;\n        rep(i,n) scanf(\"%d %d %d\",&x[i],&y[i],&z[i]);\n        rep(i,n){\n            tmp=0;\n            rep(j,n)\n            if (i != j) {\n                if (is_connected(i, j)) {g[i][tmp]=j; tmp++;}\n            }\n            p[i]=tmp;\n        }\n        int ans = inf;\n        rep(i,n) setmin(ans, dfs(i, -1, 1, i));\n        if (ans == inf) ans = -1;\n        printf(\"%d\\n\",ans);\n        /*rep(i,n){\n            rep(j,p[i]){\n                printf(\"%d \",g[i][j]);\n            }\n            puts(\"\");\n        }*/\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.*;\nimport java.util.function.BiFunction;\nimport java.util.function.Function;\nimport java.util.function.Supplier;\n\npublic class Main {\n  final static int INF = 1 << 28;\n  final static long LNF = 1L << 60;\n  final static long MOD = 1_000_000_007;\n  final static double EPS = 1e-9;\n  final static double GOLDEN_RATIO = (1.0 + Math.sqrt(5)) / 2.0;\n  Scanner sc = new Scanner(System.in);\n\n  public static void main(String[] args) {\n    new Main().run();\n  }\n\n  class Iku {\n    int dist;\n    long cost;\n\n    @Override\n    public String toString() {\n      return \"{\" + dist + \", \" + cost + \"}\";\n    }\n  }\n\n  class Node {\n    int index;\n    List<Iku> adj = new LinkedList<>();\n  }\n\n  class Group {\n    int n;\n    long[] arr;\n    boolean loop;\n  }\n\n  long kasanari(long[] p1, long[] p2, int s) {\n    boolean flag = true;\n    long[] d = new long[3];\n    for (int i = 0; i < 3; ++i) {\n      long min = Math.min(p1[i], p2[i]);\n      long max = Math.max(p1[i], p2[i]);\n      flag &= max < min + s;\n      d[i] = min + s - max;\n    }\n    if (!flag) {\n      return 0;\n    }\n    long sum = 0;\n    for (int i = 0; i < 3; ++i) {\n      for (int j = i + 1; j < 3; ++j) {\n        sum += (d[i] * d[j]) * 2;\n      }\n    }\n    return sum;\n  }\n\n  void run() {\n    for (; ; ) {\n      int n = ni();\n      int k = ni();\n      int s = ni();\n      if (n == 0) {\n        break;\n      }\n      long[][] p = new long[n][3];\n      for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < 3; ++j) {\n          p[i][j] = ni();\n        }\n      }\n      ArrayList<Node> list = new ArrayList<>();\n      for (int i = 0; i < n; ++i) {\n        Node node = new Node();\n        node.index = i;\n        list.add(node);\n      }\n      for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n          if (i == j) {\n            continue;\n          }\n          long menseki = kasanari(p[i], p[j], s);\n          if (menseki == 0) {\n            continue;\n          }\n          Iku iku = new Iku();\n          iku.dist = j;\n          iku.cost = menseki;\n          list.get(i).adj.add(iku);\n        }\n      }\n      ArrayList<Node> sorted = new ArrayList<>(list);\n      sorted.sort(Comparator.comparingInt(a -> a.adj.size()));\n      ArrayList<Group> groups = new ArrayList<>();\n      boolean[] done = new boolean[n];\n      for (Node node : sorted) {\n        if (done[node.index]) {\n          continue;\n        }\n        done[node.index] = true;\n        ArrayList<Long> arr = new ArrayList<>();\n        Node now = node;\n        for (; ; ) {\n          Node next = null;\n          for (Iku iku : now.adj) {\n            if (!done[iku.dist]) {\n              next = list.get(iku.dist);\n              arr.add(iku.cost);\n              break;\n            }\n          }\n          if (next == null) {\n            break;\n          }\n          done[next.index] = true;\n          now = next;\n        }\n        Group group = new Group();\n        group.loop = node.adj.size() == 2;\n        if (group.loop) {\n          Node next = null;\n          for (Iku iku : now.adj) {\n            if (iku.dist == node.index) {\n              next = list.get(iku.dist);\n              arr.add(iku.cost);\n              break;\n            }\n          }\n          assert next != null;\n        }\n        group.n = arr.size();\n        group.arr = new long[group.n];\n        for (int i = 0; i < group.n; ++i) {\n          group.arr[i] = arr.get(i);\n        }\n        groups.add(group);\n      }\n      long max = 0;\n      boolean ok = false;\n      for (Group g : groups) {\n        if (g.loop) {\n          if (g.n < k) {\n            continue;\n          }\n          ok = true;\n          if (g.n == k) {\n            for (int i = 0; i < g.n; ++i) {\n              long sum = 0;\n              for (int j = 0; j < k; ++j) {\n                sum += g.arr[(i + j) % g.n];\n              }\n              max = Math.max(max, sum);\n            }\n          } else {\n            for (int i = 0; i < g.n; ++i) {\n              long sum = 0;\n              for (int j = 0; j < k - 1; ++j) {\n                sum += g.arr[(i + j) % g.n];\n              }\n              max = Math.max(max, sum);\n            }\n          }\n        } else {\n          if (g.n + 1 < k) {\n            continue;\n          }\n          ok = true;\n          for (int i = 0; i < g.n - k + 2; ++i) {\n            long sum = 0;\n            for (int j = 0; j < k - 1; ++j) {\n              sum += g.arr[i + j];\n            }\n            max = Math.max(max, sum);\n          }\n        }\n      }\n      System.out.println(ok ? s * s * k * 6 - max : -1);\n    }\n  }\n\n  int ni() {\n    return Integer.parseInt(sc.next());\n  }\n\n  void debug(Object... os) {\n    System.err.println(Arrays.deepToString(os));\n  }\n}"
  },
  {
    "language": "Ruby",
    "code": "require 'set'\n\nloop do\n  n, m, s = gets.split.map(&:to_i)\n  break if n == 0\n\n  points = (1..n).map { gets.split.map(&:to_i) }\n\n  if m == 1\n    puts 6 * s * s\n    next\n  end\n\n  g = {}\n  (0..n-1).to_a.combination(2) do |i, j|\n    x1, y1, z1 = points[i]\n    x2, y2, z2 = points[j]\n    lx = [x1, x2].min + s - [x1, x2].max\n    ly = [y1, y2].min + s - [y1, y2].max\n    lz = [z1, z2].min + s - [z1, z2].max\n    if lx > 0 && ly > 0 && lz > 0\n      decrease = 2 * (lx * ly + ly * lz + lz * lx)\n      g[i] ||= {}\n      g[i][j] = decrease\n      g[j] ||= {}\n      g[j][i] = decrease\n    end\n  end\n\n  connected_group = []\n  reached = Set.new\n  (0..n-1).each do |i|\n    next if reached.include?(i)\n    reached << i\n    connected_group << [i]\n    queue = [i]\n    until queue.empty?\n      j = queue.shift\n      if g[j]\n        g[j].each_key do |k|\n          next if reached.include?(k)\n          reached << k\n          connected_group[-1] << k\n          queue << k\n        end\n      end\n    end\n  end\n\n  connected_group.select! {|group| group.size >= m }\n  if connected_group.empty?\n    puts -1\n    next\n  end\n\n  max_dec = 0\n  connected_group.each do |group|\n    i = group.find {|i| g[i].size == 1 }\n    decs = []\n    dec = 0\n    if i\n      j = g[i].keys[0]\n      (m - 1).times do\n        decs << g[i][j]\n        dec += g[i][j]\n        i, j = j, g[j].keys.select {|k| k != i }[0]\n      end\n      max_dec = dec if dec > max_dec\n      (group.size - m).times do\n        dec -= decs.shift\n        decs << g[i][j]\n        dec += g[i][j]\n        max_dec = dec if dec > max_dec\n        i, j = j, g[j].keys.select {|k| k != i }[0]\n      end\n    else\n      i = group[0]\n      j = g[i].keys[0]\n      (m - 1).times do\n        decs << g[i][j]\n        dec += g[i][j]\n        i, j = j, g[j].keys.select {|k| k != i }[0]\n      end\n      if group.size == m\n        dec += g[i][j]\n        max_dec = dec if dec > max_dec\n      else\n        max_dec = dec if dec > max_dec\n        (group.size - 1).times do\n          dec -= decs.shift\n          decs << g[i][j]\n          dec += g[i][j]\n          max_dec = dec if dec > max_dec\n          i, j = j, g[j].keys.select {|k| k != i }[0]\n        end\n      end\n\n    end\n  end\n  p m * 6 * s * s - max_dec\nend\n\n"
  },
  {
    "language": "Python",
    "code": "from collections import deque\nwhile 1:\n    n, k, s = map(int, raw_input().split())\n    if n==0:break\n    ps = [map(int, raw_input().split()) for i in xrange(n)]\n\n    G = [[] for i in xrange(n)]\n    for i in xrange(n):\n        xi, yi, zi = ps[i]\n        for j in xrange(i+1, n):\n            if i==j: continue\n            xj, yj, zj = ps[j]\n\n            dx = abs(xi-xj)\n            dy = abs(yi-yj)\n            dz = abs(zi-zj)\n\n            if dx < s and dy < s and dz < s:\n                cost = 2*((s-dx)*(s-dy)+(s-dy)*(s-dz)+(s-dz)*(s-dx))\n                G[i].append((j, cost))\n                G[j].append((i, cost))\n    if k == 1:\n        print 6*s*s\n        continue\n\n    ans = -1\n    leaf = set()\n    used = [0]*n\n    for i in xrange(n):\n        if len(G[i]) == 0:\n            used[i] = 1\n        elif len(G[i]) == 1:\n            leaf.add(i)\n    for v in leaf:\n        if used[v]:\n            continue\n        used[v] = 1\n        prev = t = None\n        deq = deque()\n        su = 0\n        while 1:\n            if prev is not None and len(G[v]) == 1:\n                break\n            for t, cost in G[v]:\n                if t == prev:\n                    continue\n                used[t] = 1\n                if len(deq) < k-1:\n                    deq.append(cost)\n                    su += cost\n                else:\n                    su -= deq.popleft()\n                    deq.append(cost)\n                    su += cost\n                break\n            if len(deq) == k-1:\n                ans = max(ans, su)\n            v, prev = t, v\n    for v in xrange(n):\n        if used[v]:\n            continue\n        prev = t = None\n        used[v] = 1\n        u = set([v])\n        while v is not None and used[v] < 3:\n            for t, cost in G[v]:\n                if t == prev:\n                    continue\n                used[t] += 1\n                u.add(t)\n                break\n            v, prev = t, v\n        cont = k if len(u) == k else k-1\n        prev = t = None\n        deq = deque(); su = 0\n        for i in xrange(2*len(u)):\n            for t, cost in G[v]:\n                if t == prev:\n                    continue\n                if len(deq) < cont:\n                    deq.append(cost)\n                    su += cost\n                else:\n                    su -= deq.popleft()\n                    su += cost\n                    deq.append(cost)\n                break\n            if len(deq) == cont:\n                ans = max(ans, su)\n            v, prev = t, v\n\n    if ans == -1:\n        print -1\n    else:\n        print 6*k*s*s - ans"
  },
  {
    "language": "Python",
    "code": "class Cube:\n    def __init__(self, x, y, z, s):\n        self.x, self.y, self.z = x, y, z\n        self.s = s\n\n    def is_in_cube(self, x, y, z):\n        return self.x <= x <= self.x + self.s and self.y <= y <= self.y + self.s and self.z <= z <= self.z + self.s\n\n    def intersect(self, C):\n        dxyz = [(0, 0, 0),\n                (C.s, 0, 0), (0, C.s, 0), (0, 0, C.s),\n                (C.s, C.s, 0), (C.s, 0, C.s), (0, C.s, C.s),\n                (C.s, C.s, C.s)]\n        for dx1, dy1, dz1 in dxyz:\n            nx1, ny1, nz1 = C.x + dx1, C.y + dy1, C.z + dz1\n            if self.is_in_cube(nx1, ny1, nz1):\n                for dx2, dy2, dz2 in dxyz:\n                    nx2, ny2, nz2 = self.x + dx2, self.y + dy2, self.z + dz2\n                    if C.is_in_cube(nx2, ny2, nz2):\n                        a, b, c = abs(nx1 - nx2), abs(ny1 - ny2), abs(nz1 - nz2)\n                        if a * b * c == 0:\n                            continue\n                        # print(a, b, c, end=':')\n                        return 2 * (a * b + b * c + c * a)\n        return 0\n\nINF = 10 ** 9\nwhile True:\n    N, K, S = map(int, input().split())\n    # print((N, K, S))\n    if not (N | K | S):\n        break\n    cubes = []\n    for _ in range(N):\n        x, y, z = map(int, input().split())\n        cubes.append(Cube(x, y, z, S))\n    # cubes = [Cube(*map(int, input().split()), S) for _ in range(N)]\n    if K == 1:\n        print(6 * S ** 2)\n        continue\n\n    edge = [[] for _ in range(N)]\n    for i in range(N):\n        for j in range(i + 1, N):\n            if cubes[i].intersect(cubes[j]):\n                # print(i, j, cubes[i].intersect(cubes[j]))\n                edge[i].append(j)\n                edge[j].append(i)\n\n    ans = INF\n    used = [False] * N\n\n    for i in range(N):\n        if not used[i] and len(edge[i]) == 1:\n            con_c = [i]\n            used[i] = True\n            now = edge[i][0]\n            while not used[now]:\n                used[now] = True\n                con_c.append(now)\n                for e in edge[now]:\n                    if not used[e]:\n                        now = e\n\n            # print(con_c, now, len(edge[i]), len(edge[now]))\n            if len(con_c) < K:\n                continue\n\n            con_s = [0]\n            for i in range(len(con_c) - 1):\n                a, b = cubes[con_c[i]], cubes[con_c[i + 1]]\n                con_s.append(a.intersect(b))\n\n            # print(con_s)\n            base = 6 * (S ** 2) * K\n            for i in range(len(con_s) - 1):\n                con_s[i + 1] += con_s[i]\n\n            for i in range(len(con_s) - K + 1):\n                ans = min(ans, base - (con_s[i + K - 1] - con_s[i]))\n\n    for i in range(N):\n        if not used[i] and len(edge[i]) == 2:\n            con_c = [i]\n            used[i] = True\n            now = edge[i][0]\n            while not used[now]:\n                used[now] = True\n                con_c.append(now)\n                for e in edge[now]:\n                    if not used[e]:\n                        now = e\n\n            # print(con_c, now, len(edge[i]), len(edge[now]))\n            if len(con_c) < K:\n                continue\n\n            con_s = [0]\n            for i in range(len(con_c) - 1):\n                a, b = cubes[con_c[i]], cubes[con_c[i + 1]]\n                con_s.append(a.intersect(b))\n\n            a, b = cubes[con_c[0]], cubes[con_c[-1]]\n            con_s.append(a.intersect(b))\n\n            # print(con_s)\n            if len(con_c) == K:\n                ans = min(ans, base - sum(con_s))\n                continue\n\n            con_s += con_s[1:]\n\n            for i in range(len(con_s) - 1):\n                con_s[i + 1] += con_s[i]\n\n            base = 6 * (S ** 2) * K\n            for i in range(len(con_c)):\n                ans = min(ans, base - (con_s[i + K - 1] - con_s[i]))\n\n    print(ans if ans != INF else -1)"
  },
  {
    "language": "Python",
    "code": "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,copy,functools\ninput = sys.stdin.readline\nINF = 10**20\nEPS = 1.0 / 10**10\nMOD = 10**9 + 7\ndef LI(): return [int(x) for x in input().split()]\ndef LF(): return [float(x) for x in input().split()]\ndef LS(): return input().split()\ndef I(): return int(input())\ndef F(): return float(input())\ndef S(): return input()\n\nclass Graph:\n  def __init__(self, _n):\n    self.n = _n\n    self.m = 0\n    self.g = [[] for i in range(_n)]\n  def add_edge(self, s, t, c = 1):\n    self.g[s].append((t,c))\n    self.g[t].append((s,c))\n  def __getitem__(self, v):\n    return self.g[v]\n\ndef edge_cost(i,j):\n  L = [s - abs(ps[i][k]-ps[j][k]) for k in range(3)]\n  if len([x for x in L if x <= 0]) > 0:\n    return -1\n  return 2*(L[0]*L[1]+L[1]*L[2]+L[2]*L[0])\n\ndef dfs(v, pv, k):\n  if k == 0:\n    for e in G[v]:\n      if e[0] != pv and used[e[0]]:\n        return e[1]\n    return 0\n  if used[v]:\n    return INF\n  used[v] = True\n  res = INF\n  for e in G[v]:\n    if e[0] == pv:\n      continue\n    dd = dfs(e[0],v,k-1)\n    if dd < INF:\n      res = min(res,dd+e[1])\n  used[v] = False\n  return res\n\n\nif __name__ == '__main__':\n  while True:\n    n,k,s = LI()\n    if n == 0:\n      break\n    ps = [LI() for i in range(n)]\n\n    G = Graph(n)\n    for i in range(n-1):\n      for j in range(i+1,n):\n        c = edge_cost(i,j)\n        if c > 0:\n          G.add_edge(i,j,-c)\n\n    used = [False] * n\n    sub = INF\n    for i in range(n):\n      sub = min(sub,dfs(i,-1,k-1))\n    if sub == INF:\n      print(-1)\n    else:\n      print(6*k*s*s+sub)\n\n"
  },
  {
    "language": "Python",
    "code": "from collections import deque\ndef ipt():\n    while 1:\n        try:\n            return raw_input()\n        except:pass\nwhile 1:\n    n, k, s = map(int, ipt().split())\n    if n==0:break\n    ps = [map(int, ipt().split()) for i in xrange(n)]\n\n    G = [[] for i in xrange(n)]\n    for i in xrange(n):\n        xi, yi, zi = ps[i]\n        for j in xrange(i, n):\n            if i==j: continue\n            xj, yj, zj = ps[j]\n\n            dx = abs(xi-xj)\n            dy = abs(yi-yj)\n            dz = abs(zi-zj)\n\n            if dx < s and dy < s and dz < s:\n                cost = 2*((s-dx)*(s-dy)+(s-dy)*(s-dz)+(s-dz)*(s-dx))\n                G[i].append((j, cost))\n                G[j].append((i, cost))\n                print i, j, cost\n\n    ans = -1\n    used = [0]*n\n    for i in xrange(n):\n        if not used[i]:\n            used[i] = 1\n            deq = deque()\n            deq.append((i, -1))\n            loop = 0\n            cnt = 1\n            leaf = i\n            while deq:\n                v, prev = deq.popleft()\n                if len(G[v]) == 1:\n                    leaf = v\n                for t, co in G[v]:\n                    if not used[t]:\n                        used[t] = 1\n                        deq.append((t, v))\n                        cnt += 1\n                    elif prev != t:\n                        loop = 1\n            d_used = [0]*n\n            if cnt < k:\n                continue\n            deq_c = deque()\n            res = 0\n            if not loop:\n                deq.append(leaf)\n                d_used[leaf] = 1\n                while deq:\n                    v = deq.popleft()\n                    for t, co in G[v]:\n                        if not d_used[t]:\n                            deq.append(t)\n                            d_used[t] = 1\n                            if len(deq_c) >= k-1:\n                                res -= deq_c.popleft()\n                            res += co\n                            ans = max(ans, res)\n                            deq_c.append(co)\n            else:\n                t, co = G[i][0]\n                d_used[t] = 1\n                res = co\n                deq.append((t, i))\n                deq_c.append(co)\n                ans = max(ans, res)\n                while deq:\n                    v, prev = deq.popleft()\n                    for t, co in G[v]:\n                        if not d_used[t] and t != prev:\n                            deq.append((t, v))\n                            d_used[t] = 1\n                            if len(deq_c) >= k-1 and cnt > k:\n                                res -= deq_c.popleft()\n                            res += co\n                            ans = max(ans, res)\n                            deq_c.append(co)\n    if ans == -1:\n        print -1\n    else:\n        print 6*k*s*s - ans"
  },
  {
    "language": "Python",
    "code": "class Cube:\n    def __init__(self, x, y, z, s):\n        self.x, self.y, self.z = x, y, z\n        self.s = s\n\n    def is_in_cube(self, x, y, z):\n        return self.x <= x <= self.x + self.s and self.y <= y <= self.y + self.s and self.z <= z <= self.z + self.s\n\n    def intersect(self, C):\n        dxyz = [(0, 0, 0),\n                (C.s, 0, 0), (0, C.s, 0), (0, 0, C.s),\n                (C.s, C.s, 0), (C.s, 0, C.s), (0, C.s, C.s),\n                (C.s, C.s, C.s)]\n        for dx1, dy1, dz1 in dxyz:\n            nx1, ny1, nz1 = C.x + dx1, C.y + dy1, C.z + dz1\n            if self.is_in_cube(nx1, ny1, nz1):\n                for dx2, dy2, dz2 in dxyz:\n                    nx2, ny2, nz2 = self.x + dx2, self.y + dy2, self.z + dz2\n                    if C.is_in_cube(nx2, ny2, nz2):\n                        a, b, c = abs(nx1 - nx2), abs(ny1 - ny2), abs(nz1 - nz2)\n                        if a * b * c == 0:\n                            continue\n                        # print(a, b, c, end=':')\n                        return 2 * (a * b + b * c + c * a)\n        return 0\n\nINF = 10 ** 9\nwhile True:\n    N, K, S = map(int, input().split())\n    # print((N, K, S))\n    if not (N | K | S):\n        break\n    cubes = []\n    for _ in range(N):\n        x, y, z = map(int, input().split())\n        cubes.append(Cube(x, y, z, S))\n    # cubes = [Cube(*map(int, input().split()), S) for _ in range(N)]\n    if K == 1:\n        print(6 * S ** 2)\n        continue\n\n    edge = [[] for _ in range(N)]\n    for i in range(N):\n        for j in range(i + 1, N):\n            if cubes[i].intersect(cubes[j]):\n                # print(i, j, cubes[i].intersect(cubes[j]))\n                edge[i].append(j)\n                edge[j].append(i)\n\n    ans = INF\n    used = [False] * N\n\n    for i in range(N):\n        if not used[i] and len(edge[i]) == 1:\n            con_c = [i]\n            used[i] = True\n            now = edge[i][0]\n            while not used[now]:\n                used[now] = True\n                con_c.append(now)\n                for e in edge[now]:\n                    if not used[e]:\n                        now = e\n\n            # print(con_c, now, len(edge[i]), len(edge[now]))\n            if len(con_c) < K:\n                continue\n\n            con_s = [0]\n            for i in range(len(con_c) - 1):\n                a, b = cubes[con_c[i]], cubes[con_c[i + 1]]\n                con_s.append(a.intersect(b))\n\n            # print(con_s)\n            base = 6 * (S ** 2) * K\n            for i in range(len(con_s) - 1):\n                con_s[i + 1] += con_s[i]\n\n            for i in range(len(con_s) - K + 1):\n                ans = min(ans, base - (con_s[i + K - 1] - con_s[i]))\n\n    for i in range(N):\n        if not used[i] and len(edge[i]) == 2:\n            con_c = [i]\n            used[i] = True\n            now = edge[i][0]\n            while not used[now]:\n                used[now] = True\n                con_c.append(now)\n                for e in edge[now]:\n                    if not used[e]:\n                        now = e\n\n            # print(con_c, now, len(edge[i]), len(edge[now]))\n            if len(con_c) < K:\n                continue\n\n            con_s = [0]\n            for i in range(len(con_c) - 1):\n                a, b = cubes[con_c[i]], cubes[con_c[i + 1]]\n                con_s.append(a.intersect(b))\n\n            a, b = cubes[con_c[0]], cubes[con_c[-1]]\n            con_s.append(a.intersect(b))\n            assert(con_s[-1] != 0)\n\n            # print(con_s)\n            if len(con_c) == K:\n                ans = min(ans, base - sum(con_s))\n                continue\n\n            con_s += con_s[1:]\n\n            for i in range(len(con_s) - 1):\n                con_s[i + 1] += con_s[i]\n\n            base = 6 * (S ** 2) * K\n            for i in range(len(con_c)):\n                ans = min(ans, base - (con_s[i + K - 1] - con_s[i]))\n\n    print(ans if ans != INF else -1)"
  },
  {
    "language": "Python",
    "code": "from collections import deque\nwhile 1:\n    n, k, s = map(int, raw_input().split())\n    if n==0:\n        break\n    ps = [map(int, raw_input().split()) for i in xrange(n)]\n\n    G = [[] for i in xrange(n)]\n    for i in xrange(n):\n        xi, yi, zi = ps[i]\n        for j in xrange(i, n):\n            if i==j: continue\n            xj, yj, zj = ps[j]\n\n            dx = abs(xi-xj)\n            dy = abs(yi-yj)\n            dz = abs(zi-zj)\n\n            if dx < s and dy < s and dz < s:\n                cost = 2*((s-dx)*(s-dy)+(s-dy)*(s-dz)+(s-dz)*(s-dx))\n                G[i].append((j, cost))\n                G[j].append((i, cost))\n                print i, j, cost\n\n    ans = -1\n    used = [0]*n\n    for i in xrange(n):\n        if not used[i]:\n            used[i] = 1\n            deq = deque()\n            deq.append((i, -1))\n            loop = 0\n            cnt = 1\n            leaf = i\n            while deq:\n                v, prev = deq.popleft()\n                if len(G[v]) == 1:\n                    leaf = v\n                for t, co in G[v]:\n                    if not used[t]:\n                        used[t] = 1\n                        deq.append((t, v))\n                        cnt += 1\n                    elif prev != t:\n                        loop = 1\n            d_used = [0]*n\n            if cnt < k:\n                continue\n            deq_c = deque()\n            res = 0\n            if not loop:\n                deq.append(leaf)\n                d_used[leaf] = 1\n                while deq:\n                    v = deq.popleft()\n                    for t, co in G[v]:\n                        if not d_used[t]:\n                            deq.append(t)\n                            d_used[t] = 1\n                            if len(deq_c) >= k-1:\n                                res -= deq_c.popleft()\n                            res += co\n                            ans = max(ans, res)\n                            deq_c.append(co)\n            else:\n                t, co = G[i][0]\n                d_used[t] = 1\n                res = co\n                deq.append((t, i))\n                deq_c.append(co)\n                ans = max(ans, res)\n                while deq:\n                    v, prev = deq.popleft()\n                    for t, co in G[v]:\n                        if not d_used[t] and t != prev:\n                            deq.append((t, v))\n                            d_used[t] = 1\n                            if len(deq_c) >= k-1 and cnt > k:\n                                res -= deq_c.popleft()\n                            res += co\n                            ans = max(ans, res)\n                            deq_c.append(co)\n    if ans == -1:\n        print -1\n    else:\n        print 6*k*s*s - ans"
  },
  {
    "language": "Python",
    "code": "from collections import deque\nwhile 1:\n    n, k, s = map(int, raw_input().split())\n    if n==0:break\n    ps = [map(int, raw_input().split()) for i in xrange(n)]\n\n    G = [[] for i in xrange(n)]\n    for i in xrange(n):\n        xi, yi, zi = ps[i]\n        for j in xrange(i+1, n):\n            if i==j: continue\n            xj, yj, zj = ps[j]\n\n            dx = abs(xi-xj)\n            dy = abs(yi-yj)\n            dz = abs(zi-zj)\n\n            if dx < s and dy < s and dz < s:\n                cost = 2*((s-dx)*(s-dy)+(s-dy)*(s-dz)+(s-dz)*(s-dx))\n                G[i].append((j, cost))\n                G[j].append((i, cost))\n\n    ans = -1\n    used = [0]*n\n    for i in xrange(n):\n        if not used[i]:\n            used[i] = 1\n            deq = deque()\n            deq.append((i, -1))\n            loop = 0\n            cnt = 1\n            leaf = i\n            while deq:\n                v, prev = deq.popleft()\n                if len(G[v]) == 1:\n                    leaf = v\n                for t, co in G[v]:\n                    if not used[t]:\n                        used[t] = 1\n                        deq.append((t, v))\n                        cnt += 1\n                    elif prev != t:\n                        loop = 1\n            d_used = [0]*n\n            if cnt == 1:\n                break\n            if cnt < k:\n                continue\n            deq_c = deque()\n            res = 0\n            if not loop:\n                deq.append(leaf)\n                d_used[leaf] = 1\n                while deq:\n                    v = deq.popleft()\n                    for t, co in G[v]:\n                        if not d_used[t]:\n                            deq.append(t)\n                            d_used[t] = 1\n                            if len(deq_c) >= k-1 and deq_c:\n                                res -= deq_c.popleft()\n                            res += co\n                            ans = max(ans, res)\n                            deq_c.append(co)\n            else:\n                t, co = G[i][0]\n                d_used[t] = 1\n                res = co\n                deq.append((t, i))\n                deq_c.append(co)\n                ans = max(ans, res)\n                while deq:\n                    v, prev = deq.popleft()\n                    for t, co in G[v]:\n                        if not d_used[t] and t != prev:\n                            deq.append((t, v))\n                            d_used[t] = 1\n                            if len(deq_c) >= k-1 and cnt > k:\n                                res -= deq_c.popleft()\n                            res += co\n                            ans = max(ans, res)\n                            deq_c.append(co)\n    if ans == -1:\n        print -1\n    else:\n        print 6*k*s*s - ans"
  },
  {
    "language": "Python",
    "code": "class Cube:\n    def __init__(self, x, y, z, s):\n        self.x, self.y, self.z = x, y, z\n        self.s = s\n\n    def is_in_cube(self, x, y, z):\n        return self.x <= x <= self.x + self.s and self.y <= y <= self.y + self.s and self.z <= z <= self.z + self.s\n\n    def intersect(self, C):\n        dxyz = [(0, 0, 0),\n                (C.s, 0, 0), (0, C.s, 0), (0, 0, C.s),\n                (C.s, C.s, 0), (C.s, 0, C.s), (0, C.s, C.s),\n                (C.s, C.s, C.s)]\n        for dx1, dy1, dz1 in dxyz:\n            nx1, ny1, nz1 = C.x + dx1, C.y + dy1, C.z + dz1\n            if self.is_in_cube(nx1, ny1, nz1):\n                for dx2, dy2, dz2 in dxyz:\n                    nx2, ny2, nz2 = self.x + dx2, self.y + dy2, self.z + dz2\n                    if C.is_in_cube(nx2, ny2, nz2):\n                        a, b, c = abs(nx1 - nx2), abs(ny1 - ny2), abs(nz1 - nz2)\n                        if a * b * c == 0:\n                            continue\n                        # print(a, b, c, end=':')\n                        return 2 * (a * b + b * c + c * a)\n        return 0\n\n\nedges = list()\ninters = dict()\n\n\ndef calc_overlap(vs):\n    ret = sum(inters.get((vs[i], vs[i + 1]), 0) for i in range(len(vs) - 1))\n    if len(vs) > 2:\n        ret += inters.get((vs[-1], vs[0]), 0)\n    return ret\n\n\ndef dfs(v, par, vs, res):\n    if res == 0:\n        return calc_overlap(vs)\n\n    ret = -1\n\n    for e in edges[v]:\n        if e != par:\n            vs.append(e)\n            ret = max(ret, dfs(e, v, vs, res - 1))\n            vs.pop()\n    return ret\n\n\nwhile True:\n    N, K, S = map(int, input().split())\n    # print((N, K, S))\n    if not (N | K | S):\n        break\n    cubes = []\n    for _ in range(N):\n        x, y, z = map(int, input().split())\n        cubes.append(Cube(x, y, z, S))\n    # cubes = [Cube(*map(int, input().split()), S) for _ in range(N)]\n    edges = [[] for _ in range(N)]\n    inters = dict()\n    for i in range(N):\n        for j in range(i + 1, N):\n            sur = cubes[i].intersect(cubes[j])\n            if sur > 0:\n                # print(i, j, cubes[i].intersect(cubes[j]))\n                inters[i, j] = inters[j, i] = sur\n                edges[i].append(j)\n                edges[j].append(i)\n    # print(edges, inters)\n\n    ans = -1\n    for i in range(N):\n        ans = max(ans, dfs(i, -1, [i], K - 1))\n\n    print(-1 if ans == -1 else S * S * 6 * K - ans)"
  },
  {
    "language": "Python",
    "code": "class Cube:\n    def __init__(self, x, y, z, s):\n        self.x, self.y, self.z = x, y, z\n        self.s = s\n\n    def is_in_cube(self, x, y, z):\n        return self.x <= x <= self.x + self.s and self.y <= y <= self.y + self.s and self.z <= z <= self.z + self.s\n\n    def intersect(self, C):\n        dxyz = [(0, 0, 0),\n                (C.s, 0, 0), (0, C.s, 0), (0, 0, C.s),\n                (C.s, C.s, 0), (C.s, 0, C.s), (0, C.s, C.s),\n                (C.s, C.s, C.s)]\n        for dx1, dy1, dz1 in dxyz:\n            nx1, ny1, nz1 = C.x + dx1, C.y + dy1, C.z + dz1\n            if self.is_in_cube(nx1, ny1, nz1):\n                for dx2, dy2, dz2 in dxyz:\n                    nx2, ny2, nz2 = self.x + dx2, self.y + dy2, self.z + dz2\n                    if C.is_in_cube(nx2, ny2, nz2):\n                        a, b, c = abs(nx1 - nx2), abs(ny1 - ny2), abs(nz1 - nz2)\n                        if a * b * c == 0:\n                            continue\n                        # print(a, b, c, end=':')\n                        return 2 * (a * b + b * c + c * a)\n        return 0\n\nINF = 10 ** 9\nwhile True:\n    N, K, S = map(int, input().split())\n    # print((N, K, S))\n    if not (N | K | S):\n        break\n    cubes = []\n    for _ in range(N):\n        x, y, z = map(int, input().split())\n        cubes.append(Cube(x, y, z, S))\n    # cubes = [Cube(*map(int, input().split()), S) for _ in range(N)]\n    if K == 1:\n        # print(6 * S ** 2)\n        continue\n\n    edge = [[] for _ in range(N)]\n    for i in range(N):\n        for j in range(i + 1, N):\n            if cubes[i].intersect(cubes[j]):\n                # print(i, j, cubes[i].intersect(cubes[j]))\n                edge[i].append(j)\n                edge[j].append(i)\n\n    ans = INF\n    used = [False] * N\n\n    for i in range(N):\n        if not used[i] and len(edge[i]) == 1:\n            con_c = [i]\n            used[i] = True\n            now = edge[i][0]\n            while not used[now]:\n                used[now] = True\n                con_c.append(now)\n                for e in edge[now]:\n                    if not used[e]:\n                        now = e\n\n            # print(con_c, now, len(edge[i]), len(edge[now]))\n            if len(con_c) < K:\n                continue\n\n            con_s = [0]\n            for i in range(len(con_c) - 1):\n                a, b = cubes[con_c[i]], cubes[con_c[i + 1]]\n                con_s.append(a.intersect(b))\n\n            # print(con_s)\n            base = 6 * (S ** 2) * K\n            for i in range(len(con_s) - 1):\n                con_s[i + 1] += con_s[i]\n\n            for i in range(len(con_s) - K + 1):\n                ans = min(ans, base - (con_s[i + K - 1] - con_s[i]))\n\n    for i in range(N):\n        if not used[i] and len(edge[i]) == 2:\n            con_c = [i]\n            used[i] = True\n            now = edge[i][0]\n            while not used[now]:\n                used[now] = True\n                con_c.append(now)\n                for e in edge[now]:\n                    if not used[e]:\n                        now = e\n\n            # print(con_c, now, len(edge[i]), len(edge[now]))\n            if len(con_c) < K:\n                continue\n\n            con_s = [0]\n            for i in range(len(con_c) - 1):\n                a, b = cubes[con_c[i]], cubes[con_c[i + 1]]\n                con_s.append(a.intersect(b))\n\n            a, b = cubes[con_c[0]], cubes[con_c[-1]]\n            con_s.append(a.intersect(b))\n\n            # print(con_s)\n            if len(con_c) == K:\n                ans = min(ans, base - sum(con_s))\n                continue\n\n            con_s += con_s[1:]\n\n            for i in range(len(con_s) - 1):\n                con_s[i + 1] += con_s[i]\n\n            base = 6 * (S ** 2) * K\n            for i in range(len(con_c)):\n                ans = min(ans, base - (con_s[i + K - 1] - con_s[i]))\n\n    print(ans if ans != INF else -1)"
  },
  {
    "language": "Python",
    "code": "class Cube:\n    def __init__(self, x, y, z, s):\n        self.x, self.y, self.z = x, y, z\n        self.s = s\n\n    def is_in_cube(self, x, y, z):\n        return self.x <= x <= self.x + self.s and self.y <= y <= self.y + self.s and self.z <= z <= self.z + self.s\n\n    def intersect(self, C):\n        dxyz = [(0, 0, 0),\n                (C.s, 0, 0), (0, C.s, 0), (0, 0, C.s),\n                (C.s, C.s, 0), (C.s, 0, C.s), (0, C.s, C.s),\n                (C.s, C.s, C.s)]\n        for dx1, dy1, dz1 in dxyz:\n            nx1, ny1, nz1 = C.x + dx1, C.y + dy1, C.z + dz1\n            if self.is_in_cube(nx1, ny1, nz1):\n                for dx2, dy2, dz2 in dxyz:\n                    nx2, ny2, nz2 = self.x + dx2, self.y + dy2, self.z + dz2\n                    if C.is_in_cube(nx2, ny2, nz2):\n                        a, b, c = abs(nx1 - nx2), abs(ny1 - ny2), abs(nz1 - nz2)\n                        if a * b * c == 0:\n                            continue\n                        # print(a, b, c, end=':')\n                        return 2 * (a * b + b * c + c * a)\n        return 0\n\nINF = 10 ** 9\nwhile True:\n    N, K, S = map(int, input().split())\n    # print((N, K, S))\n    if not (N | K | S):\n        break\n    cubes = [Cube(*map(int, input().split()), S) for _ in range(N)]\n    if K == 1:\n        # print(6 * S ** 2)\n        continue\n\n    edge = [[] for _ in range(N)]\n    for i in range(N):\n        for j in range(i + 1, N):\n            if cubes[i].intersect(cubes[j]):\n                # print(i, j, cubes[i].intersect(cubes[j]))\n                edge[i].append(j)\n                edge[j].append(i)\n\n    ans = INF\n    used = [False] * N\n\n    for i in range(N):\n        if not used[i] and len(edge[i]) == 1:\n            con_c = [i]\n            used[i] = True\n            now = edge[i][0]\n            while not used[now]:\n                used[now] = True\n                con_c.append(now)\n                for e in edge[now]:\n                    if not used[e]:\n                        now = e\n\n            # print(con_c, now, len(edge[i]), len(edge[now]))\n            if len(con_c) < K:\n                continue\n\n            con_s = [0]\n            for i in range(len(con_c) - 1):\n                a, b = cubes[con_c[i]], cubes[con_c[i + 1]]\n                con_s.append(a.intersect(b))\n\n            # print(con_s)\n            base = 6 * (S ** 2) * K\n            for i in range(len(con_s) - 1):\n                con_s[i + 1] += con_s[i]\n\n            for i in range(len(con_s) - K + 1):\n                ans = min(ans, base - (con_s[i + K - 1] - con_s[i]))\n\n    for i in range(N):\n        if not used[i] and len(edge[i]) == 2:\n            con_c = [i]\n            used[i] = True\n            now = edge[i][0]\n            while not used[now]:\n                used[now] = True\n                con_c.append(now)\n                for e in edge[now]:\n                    if not used[e]:\n                        now = e\n\n            # print(con_c, now, len(edge[i]), len(edge[now]))\n            if len(con_c) < K:\n                continue\n\n            con_s = [0]\n            for i in range(len(con_c) - 1):\n                a, b = cubes[con_c[i]], cubes[con_c[i + 1]]\n                con_s.append(a.intersect(b))\n\n            a, b = cubes[con_c[0]], cubes[con_c[-1]]\n            con_s.append(a.intersect(b))\n\n            # print(con_s)\n            if len(con_c) == K:\n                ans = min(ans, base - sum(con_s))\n                continue\n\n            con_s += con_s[1:]\n\n            for i in range(len(con_s) - 1):\n                con_s[i + 1] += con_s[i]\n\n            base = 6 * (S ** 2) * K\n            for i in range(len(con_c)):\n                ans = min(ans, base - (con_s[i + K - 1] - con_s[i]))\n\n    print(ans if ans != INF else -1)"
  },
  {
    "language": "Python",
    "code": "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,copy,functools\ninput = sys.stdin.readline\nINF = 10**20\nEPS = 1.0 / 10**10\nMOD = 10**9 + 7\ndef LI(): return [int(x) for x in input().split()]\ndef LF(): return [float(x) for x in input().split()]\ndef LS(): return input().split()\ndef I(): return int(input())\ndef F(): return float(input())\ndef S(): return input()\n\nclass Graph:\n  def __init__(self, _n):\n    self.n = _n\n    self.m = 0\n    self.g = [[] for i in range(_n)]\n  def add_edge(self, s, t, c = 1):\n    self.g[s].append((t,c))\n    self.g[t].append((s,c))\n  def __getitem__(self, v):\n    return self.g[v]\n\ndef edge_cost(i,j):\n  L = [s - abs(ps[i][k]-ps[j][k]) for k in range(3)]\n  if len([x for x in L if x <= 0]) > 0:\n    return -1\n  return 2*(L[0]*L[1]+L[1]*L[2]+L[2]*L[0])\n\ndef dfs(v, pv, k):\n  if k == 0:\n    for e in G[v]:\n      if e[0] != pv and used[e[0]]:\n        return e[1]\n    return 0\n  if used[v]:\n    return INF\n  used[v] = True\n  res = INF\n  for e in G[v]:\n    if e[0] == pv:\n      continue\n    dd = dfs(e[0],v,k-1)\n    if dd < INF:\n      res = min(res,dd+e[1])\n  used[v] = False\n  return res\n\n\nif __name__ == '__main__':\n  while True:\n    n,k,s = LI()\n    if n == 0:\n      break\n    ps = [LI() for i in range(n)]\n\n    G = Graph(n)\n    for i in range(n-1):\n      for j in range(i+1,n):\n        c = edge_cost(i,j)\n        if c > 0:\n          G.add_edge(i,j,-c)\n\n    used = [False] * n\n    sub = INF\n    for i in range(n):\n      sub = min(sub,dfs(i,-1,k-1))\n    if sub == INF:\n      print(-1)\n    else:\n      print(6*k*s*s+sub)\n"
  },
  {
    "language": "Python",
    "code": "from collections import deque\nwhile 1:\n    n, k, s = map(int, raw_input().split())\n    if n==0:break\n    ps = [map(int, raw_input().split()) for i in xrange(n)]\n\n    G = [[] for i in xrange(n)]\n    for i in xrange(n):\n        xi, yi, zi = ps[i]\n        for j in xrange(i+1, n):\n            if i==j: continue\n            xj, yj, zj = ps[j]\n\n            dx = abs(xi-xj)\n            dy = abs(yi-yj)\n            dz = abs(zi-zj)\n\n            if dx < s and dy < s and dz < s:\n                cost = 2*((s-dx)*(s-dy)+(s-dy)*(s-dz)+(s-dz)*(s-dx))\n                G[i].append((j, cost))\n                G[j].append((i, cost))\n    ans = -1\n    leaf = set()\n    used = [0]*n\n    for i in xrange(n):\n        if len(G[i]) == 0:\n            if k == 1:\n                ans = 0\n            used[i] = 1\n        elif len(G[i]) == 1:\n            leaf.add(i)\n    for v in leaf:\n        if used[v]:\n            continue\n        used[v] = 1\n        prev = t = None\n        deq = deque()\n        su = 0\n        while 1:\n            if prev is not None and len(G[v]) == 1:\n                break\n            for t, cost in G[v]:\n                if t == prev:\n                    continue\n                used[t] = 1\n                if len(deq) < k-1:\n                    deq.append(cost)\n                    su += cost\n                else:\n                    su -= deq.popleft()\n                    deq.append(cost)\n                    su += cost\n                break\n            if len(deq) == k-1:\n                ans = max(ans, su)\n            v, prev = t, v\n    for v in xrange(n):\n        if used[v]:\n            continue\n        prev = t = None\n        used[v] = 1\n        u = set([v])\n        while used[v] < 3:\n            for t, cost in G[v]:\n                if t == prev:\n                    continue\n                used[t] += 1\n                u.add(t)\n                break\n            v, prev = t, v\n        cont = k if len(u) == k else k-1\n        prev = t = None\n        deq = deque(); su = 0\n        for i in xrange(2*len(u)):\n            for t, cost in G[v]:\n                if t == prev:\n                    continue\n                if len(deq) < cont:\n                    deq.append(cost)\n                    su += cost\n                else:\n                    su -= deq.popleft()\n                    su += cost\n                    deq.append(cost)\n                break\n            if len(deq) == cont:\n                ans = max(ans, su)\n            v, prev = t, v\n\n    if ans == -1:\n        print -1\n    else:\n        print 6*k*s*s - ans"
  },
  {
    "language": "Python",
    "code": "class Cube:\n    def __init__(self, x, y, z, s):\n        self.x, self.y, self.z = x, y, z\n        self.s = s\n\n    def is_in_cube(self, x, y, z):\n        return self.x <= x <= self.x + self.s and self.y <= y <= self.y + self.s and self.z <= z <= self.z + self.s\n\n    def intersect(self, C):\n        dxyz = [(0, 0, 0),\n                (C.s, 0, 0), (0, C.s, 0), (0, 0, C.s),\n                (C.s, C.s, 0), (C.s, 0, C.s), (0, C.s, C.s),\n                (C.s, C.s, C.s)]\n        for dx1, dy1, dz1 in dxyz:\n            nx1, ny1, nz1 = C.x + dx1, C.y + dy1, C.z + dz1\n            if self.is_in_cube(nx1, ny1, nz1):\n                for dx2, dy2, dz2 in dxyz:\n                    nx2, ny2, nz2 = self.x + dx2, self.y + dy2, self.z + dz2\n                    if C.is_in_cube(nx2, ny2, nz2):\n                        a, b, c = abs(nx1 - nx2), abs(ny1 - ny2), abs(nz1 - nz2)\n                        if a * b * c == 0:\n                            continue\n                        # print(a, b, c, end=':')\n                        return 2 * (a * b + b * c + c * a)\n        return 0\n\n\nedges = list()\ninters = dict()\n\n\ndef calc_overlap(vs):\n    ret = sum(inters.get((vs[i], vs[i + 1]), 0) for i in range(len(vs) - 1))\n    if len(vs) > 2:\n        ret += inters.get((vs[-1], vs[0]), 0)\n    return ret\n\n\ndef dfs(v, par, vs, res):\n    if res == 0:\n        return calc_overlap(vs)\n\n    ret = -1\n\n    for e in edges[v]:\n        if e != par:\n            vs.append(e)\n            ret = max(ret, dfs(e, v, vs, res - 1))\n            vs.pop()\n    return ret\n\n\nINF = 10 ** 9\nwhile True:\n    N, K, S = map(int, input().split())\n    # print((N, K, S))\n    if not (N | K | S):\n        break\n    cubes = []\n    for _ in range(N):\n        x, y, z = map(int, input().split())\n        cubes.append(Cube(x, y, z, S))\n    # cubes = [Cube(*map(int, input().split()), S) for _ in range(N)]\n    edges = [[] for _ in range(N)]\n    inters = dict()\n    for i in range(N):\n        for j in range(i + 1, N):\n            sur = cubes[i].intersect(cubes[j])\n            if sur > 0:\n                # print(i, j, cubes[i].intersect(cubes[j]))\n                inters[i, j] = inters[j, i] = sur\n                edges[i].append(j)\n                edges[j].append(i)\n    # print(edges, inters)\n\n    ans = -1\n    for i in range(N):\n        ans = max(ans, dfs(i, -1, [i], K - 1))\n\n    print(-1 if ans == -1 else S * S * 6 * K - ans)"
  }
]