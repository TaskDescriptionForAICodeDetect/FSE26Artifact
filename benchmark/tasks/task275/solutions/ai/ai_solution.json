[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_SAMPLES 100\n\ntypedef struct {\n    int parent;\n    int weight_diff;\n} UnionFind;\n\nUnionFind uf[MAX_SAMPLES];\n\nvoid initialize() {\n    for (int i = 0; i < MAX_SAMPLES; i++) {\n        uf[i].parent = i;\n        uf[i].weight_diff = 0;\n    }\n}\n\nint find(int x) {\n    if (uf[x].parent != x) {\n        int root = find(uf[x].parent);\n        uf[x].weight_diff += uf[uf[x].parent].weight_diff;\n        uf[x].parent = root;\n    }\n    return uf[x].parent;\n}\n\nvoid union_sets(int x, int y, int diff) {\n    int root_x = find(x);\n    int root_y = find(y);\n    if (root_x != root_y) {\n        uf[root_y].parent = root_x;\n        uf[root_y].weight_diff = uf[x].weight_diff + diff - uf[y].weight_diff;\n    }\n}\n\nint main() {\n    int n, m;\n    while (scanf(\"%d %d\", &n, &m) == 2) {\n        if (n == 0 && m == 0) break;\n        initialize();\n        \n        for (int i = 0; i < m; i++) {\n            char op;\n            scanf(\" %c\", &op);\n            if (op == '!') {\n                int a, b, w;\n                scanf(\"%d %d %d\", &a, &b, &w);\n                union_sets(a, b, w);\n            } else {\n                int a, b;\n                scanf(\"%d %d\", &a, &b);\n                if (find(a) != find(b)) {\n                    printf(\"UNKNOWN\\n\");\n                } else {\n                    printf(\"%d\\n\", uf[b].weight_diff - uf[a].weight_diff);\n                }\n            }\n        }\n    }\n    return 0;\n}",
    "timestamp": "2025-08-05 20:52:33"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <string>\nusing namespace std;\n\nstruct UnionFind {\n    map<string, string> parent;\n    map<string, int> weight;\n\n    string find(const string &x) {\n        if (parent.find(x) == parent.end()) {\n            parent[x] = x;\n            weight[x] = 0;\n            return x;\n        }\n        if (parent[x] == x) return x;\n        string orig_parent = parent[x];\n        parent[x] = find(parent[x]);\n        weight[x] += weight[orig_parent];\n        return parent[x];\n    }\n\n    void unite(const string &a, const string &b, int w) {\n        string ra = find(a);\n        string rb = find(b);\n        if (ra == rb) return;\n        parent[ra] = rb;\n        weight[ra] = w + weight[b] - weight[a];\n    }\n\n    bool same(const string &a, const string &b) {\n        return find(a) == find(b);\n    }\n\n    int diff(const string &a, const string &b) {\n        if (!same(a, b)) return INT_MAX;\n        return weight[a] - weight[b];\n    }\n};\n\nvoid solve() {\n    int n, m;\n    while (cin >> n >> m, n || m) {\n        UnionFind uf;\n        for (int i = 0; i < m; ++i) {\n            char op;\n            cin >> op;\n            if (op == '!') {\n                string a, b;\n                int w;\n                cin >> a >> b >> w;\n                uf.unite(a, b, w);\n            } else {\n                string a, b;\n                cin >> a >> b;\n                int diff = uf.diff(a, b);\n                if (diff == INT_MAX) {\n                    cout << \"UNKNOWN\" << endl;\n                } else {\n                    cout << diff << endl;\n                }\n            }\n        }\n    }\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    solve();\n    return 0;\n}",
    "timestamp": "2025-08-05 20:52:54"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\nclass UnionFind {\n    private int[] parent;\n    private int[] rank;\n    private long[] weightDiff;\n\n    public UnionFind(int size) {\n        parent = new int[size];\n        rank = new int[size];\n        weightDiff = new long[size];\n        for (int i = 0; i < size; i++) {\n            parent[i] = i;\n        }\n    }\n\n    public int find(int x) {\n        if (parent[x] != x) {\n            int root = find(parent[x]);\n            weightDiff[x] += weightDiff[parent[x]];\n            parent[x] = root;\n        }\n        return parent[x];\n    }\n\n    public boolean union(int x, int y, long diff) {\n        int rootX = find(x);\n        int rootY = find(y);\n        if (rootX == rootY) {\n            return false;\n        }\n        if (rank[rootX] < rank[rootY]) {\n            parent[rootX] = rootY;\n            weightDiff[rootX] = diff + weightDiff[y] - weightDiff[x];\n        } else {\n            parent[rootY] = rootX;\n            weightDiff[rootY] = -diff + weightDiff[x] - weightDiff[y];\n            if (rank[rootX] == rank[rootY]) {\n                rank[rootX]++;\n            }\n        }\n        return true;\n    }\n\n    public long getDiff(int x, int y) {\n        if (find(x) != find(y)) {\n            return Long.MIN_VALUE;\n        }\n        return weightDiff[x] - weightDiff[y];\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        while (true) {\n            int n = scanner.nextInt();\n            int m = scanner.nextInt();\n            if (n == 0 && m == 0) break;\n            UnionFind uf = new UnionFind(n + 1);\n            for (int i = 0; i < m; i++) {\n                String op = scanner.next();\n                if (op.equals(\"!\")) {\n                    int a = scanner.nextInt();\n                    int b = scanner.nextInt();\n                    long w = scanner.nextLong();\n                    uf.union(a, b, w);\n                } else {\n                    int a = scanner.nextInt();\n                    int b = scanner.nextInt();\n                    long diff = uf.getDiff(a, b);\n                    if (diff == Long.MIN_VALUE) {\n                        System.out.println(\"UNKNOWN\");\n                    } else {\n                        System.out.println(diff);\n                    }\n                }\n            }\n        }\n        scanner.close();\n    }\n}",
    "timestamp": "2025-08-05 20:53:29"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class WeightDifference {\n    static class Graph {\n        private Map<String, Map<String, Double>> adjacencyList;\n\n        public Graph() {\n            adjacencyList = new HashMap<>();\n        }\n\n        public void addEdge(String from, String to, double weight) {\n            adjacencyList.putIfAbsent(from, new HashMap<>());\n            adjacencyList.get(from).put(to, weight);\n        }\n\n        public Double findWeightDifference(String from, String to) {\n            Set<String> visited = new HashSet<>();\n            return dfs(from, to, visited, 0.0);\n        }\n\n        private Double dfs(String current, String target, Set<String> visited, double currentWeight) {\n            if (current.equals(target)) {\n                return currentWeight;\n            }\n\n            visited.add(current);\n\n            if (adjacencyList.containsKey(current)) {\n                for (Map.Entry<String, Double> neighbor : adjacencyList.get(current).entrySet()) {\n                    if (!visited.contains(neighbor.getKey())) {\n                        Double result = dfs(neighbor.getKey(), target, visited, currentWeight + neighbor.getValue());\n                        if (result != null) {\n                            return result;\n                        }\n                    }\n                }\n            }\n\n            return null;\n        }\n    }\n\n    public static void processDataset(Scanner scanner) {\n        Graph graph = new Graph();\n        int n = scanner.nextInt();\n        int m = scanner.nextInt();\n\n        for (int i = 0; i < n; i++) {\n            String sample = scanner.next();\n        }\n\n        for (int i = 0; i < m; i++) {\n            String from = scanner.next();\n            String to = scanner.next();\n            double weight = scanner.nextDouble();\n            graph.addEdge(from, to, weight);\n        }\n\n        int q = scanner.nextInt();\n        for (int i = 0; i < q; i++) {\n            String from = scanner.next();\n            String to = scanner.next();\n            Double diff = graph.findWeightDifference(from, to);\n            System.out.println(diff != null ? diff : \"UNKNOWN\");\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int datasets = scanner.nextInt();\n\n        for (int i = 0; i < datasets; i++) {\n            processDataset(scanner);\n        }\n    }\n}",
    "timestamp": "2025-08-05 20:53:38"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\n#define MAX_SAMPLES 200\n\nint parent[MAX_SAMPLES];\nint rank[MAX_SAMPLES];\nint weight[MAX_SAMPLES];\n\nvoid initialize(int n) {\n    for (int i = 0; i < n; i++) {\n        parent[i] = i;\n        rank[i] = 0;\n        weight[i] = 0;\n    }\n}\n\nint find(int x) {\n    if (parent[x] != x) {\n        int px = find(parent[x]);\n        weight[x] += weight[parent[x]];\n        parent[x] = px;\n    }\n    return parent[x];\n}\n\nvoid unionSet(int x, int y, int w) {\n    int px = find(x);\n    int py = find(y);\n    \n    if (px == py) return;\n    \n    if (rank[px] < rank[py]) {\n        parent[px] = py;\n        weight[px] = w - weight[x] + weight[y];\n    } else {\n        parent[py] = px;\n        weight[py] = -w - weight[y] + weight[x];\n        \n        if (rank[px] == rank[py]) {\n            rank[px]++;\n        }\n    }\n}\n\nint main() {\n    int T;\n    scanf(\"%d\", &T);\n    \n    while (T--) {\n        int n, m;\n        scanf(\"%d %d\", &n, &m);\n        \n        initialize(n);\n        \n        while (m--) {\n            char op;\n            int a, b, w;\n            scanf(\" %c\", &op);\n            \n            if (op == '!') {\n                scanf(\"%d %d %d\", &a, &b, &w);\n                a--; b--;\n                unionSet(a, b, w);\n            } else if (op == '?') {\n                scanf(\"%d %d\", &a, &b);\n                a--; b--;\n                \n                if (find(a) != find(b)) {\n                    printf(\"UNKNOWN\\n\");\n                } else {\n                    printf(\"%d\\n\", weight[a] - weight[b]);\n                }\n            }\n        }\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 20:53:46"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <unordered_map>\n#include <limits>\n#include <algorithm>\n\nusing namespace std;\n\nclass WeightComparator {\nprivate:\n    unordered_map<string, unordered_map<string, int>> weightDifferences;\n\npublic:\n    void addMeasurement(const string& heavier, const string& lighter, int weightDiff) {\n        weightDifferences[heavier][lighter] = weightDiff;\n        weightDifferences[lighter][heavier] = -weightDiff;\n    }\n\n    int computeWeightDifference(const string& sample1, const string& sample2) {\n        vector<string> visited;\n        return findDifference(sample1, sample2, visited);\n    }\n\n    int findDifference(const string& start, const string& end, vector<string>& visited) {\n        if (start == end) return 0;\n        visited.push_back(start);\n\n        for (const auto& pair : weightDifferences[start]) {\n            if (find(visited.begin(), visited.end(), pair.first) == visited.end()) {\n                int subDiff = findDifference(pair.first, end, visited);\n                if (subDiff != numeric_limits<int>::min()) {\n                    return pair.second + subDiff;\n                }\n            }\n        }\n\n        visited.pop_back();\n        return numeric_limits<int>::min();\n    }\n};\n\nint main() {\n    int datasets;\n    cin >> datasets;\n\n    for (int dataset = 1; dataset <= datasets; ++dataset) {\n        WeightComparator comparator;\n        int measurements, queries;\n        cin >> measurements >> queries;\n\n        for (int i = 0; i < measurements; ++i) {\n            string heavier, lighter;\n            int weightDiff;\n            cin >> heavier >> lighter >> weightDiff;\n            comparator.addMeasurement(heavier, lighter, weightDiff);\n        }\n\n        cout << \"Dataset \" << dataset << \":\" << endl;\n        for (int i = 0; i < queries; ++i) {\n            string sample1, sample2;\n            cin >> sample1 >> sample2;\n            int diff = comparator.computeWeightDifference(sample1, sample2);\n\n            if (diff == numeric_limits<int>::min()) {\n                cout << \"Unknown\" << endl;\n            } else {\n                cout << diff << endl;\n            }\n        }\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 20:53:54"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def solve_measurements(num_measurements, measurements, num_queries, queries):\n    from collections import defaultdict, deque\n\n    graph = defaultdict(list)\n    weight_diff = {}\n\n    # Construct the graph\n    for s1, s2, diff in measurements:\n        graph[s1].append((s2, diff))\n        graph[s2].append((s1, -diff))\n        weight_diff[(s1, s2)] = diff\n        weight_diff[(s2, s1)] = -diff\n\n    # Function to get the weight difference using BFS\n    def get_weight_difference(start, end):\n        if start == end:\n            return 0\n        queue = deque([(start, 0)])\n        visited = {start}\n        while queue:\n            current, current_weight = queue.popleft()\n            for neighbor, weight in graph[current]:\n                if neighbor not in visited:\n                    visited.add(neighbor)\n                    new_weight = current_weight + weight\n                    if neighbor == end:\n                        return new_weight\n                    queue.append((neighbor, new_weight))\n        return \"UNKNOWN\"\n\n    results = []\n    for s1, s2 in queries:\n        result = get_weight_difference(s1, s2)\n        results.append(result)\n\n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().splitlines()\n    \n    line_idx = 0\n    num_datasets = int(data[line_idx])\n    line_idx += 1\n    results = []\n\n    for _ in range(num_datasets):\n        num_measurements = int(data[line_idx])\n        line_idx += 1\n        measurements = []\n        \n        for _ in range(num_measurements):\n            parts = data[line_idx].split()\n            s1, s2, diff = int(parts[0]), int(parts[1]), int(parts[2])\n            measurements.append((s1, s2, diff))\n            line_idx += 1\n\n        num_queries = int(data[line_idx])\n        line_idx += 1\n        queries = []\n\n        for _ in range(num_queries):\n            parts = data[line_idx].split()\n            s1, s2 = int(parts[0]), int(parts[1])\n            queries.append((s1, s2))\n            line_idx += 1\n\n        dataset_results = solve_measurements(num_measurements, measurements, num_queries, queries)\n        results.extend(dataset_results)\n\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
    "timestamp": "2025-08-13 03:58:39"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class WeightDifferenceCalculator {\n\n    static class Edge {\n        int to;\n        int weight;\n\n        public Edge(int to, int weight) {\n            this.to = to;\n            this.weight = weight;\n        }\n    }\n\n    private static void processQueries(Scanner scanner) {\n        while (scanner.hasNext()) {\n            int n = scanner.nextInt();\n            int m = scanner.nextInt();\n            if (n == 0 && m == 0) break;\n\n            List<List<Edge>> graph = new ArrayList<>(n);\n            for (int i = 0; i < n; i++) {\n                graph.add(new ArrayList<>());\n            }\n\n            for (int i = 0; i < m; i++) {\n                int u = scanner.nextInt() - 1;\n                int v = scanner.nextInt() - 1;\n                int d = scanner.nextInt();\n                graph.get(u).add(new Edge(v, d));\n                graph.get(v).add(new Edge(u, -d));\n            }\n\n            int q = scanner.nextInt();\n            for (int i = 0; i < q; i++) {\n                int start = scanner.nextInt() - 1;\n                int end = scanner.nextInt() - 1;\n                Integer result = getWeightDifference(graph, start, end, n);\n                System.out.println(result != null ? result : \"UNKNOWN\");\n            }\n        }\n    }\n\n    private static Integer getWeightDifference(List<List<Edge>> graph, int start, int end, int n) {\n        int[] dist = new int[n];\n        Arrays.fill(dist, Integer.MAX_VALUE);\n        Queue<Integer> queue = new LinkedList<>();\n        boolean[] inQueue = new boolean[n];\n\n        dist[start] = 0;\n        queue.offer(start);\n        inQueue[start] = true;\n\n        while (!queue.isEmpty()) {\n            int u = queue.poll();\n            inQueue[u] = false;\n\n            for (Edge edge : graph.get(u)) {\n                int v = edge.to;\n                int weight = edge.weight;\n\n                if (dist[u] != Integer.MAX_VALUE && dist[u] + weight < dist[v]) {\n                    dist[v] = dist[u] + weight;\n                    if (!inQueue[v]) {\n                        queue.offer(v);\n                        inQueue[v] = true;\n                    }\n                }\n            }\n        }\n\n        return dist[end] == Integer.MAX_VALUE ? null : dist[end];\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        processQueries(scanner);\n        scanner.close();\n    }\n}",
    "timestamp": "2025-08-13 03:58:59"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <string.h>\n\n#define MAX_SAMPLES 100\n\nint weight_differences[MAX_SAMPLES][MAX_SAMPLES];\n\nvoid floydWarshall(int n) {\n    for (int k = 0; k < n; k++) {\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                if (weight_differences[i][k] != 1e9 && weight_differences[k][j] != 1e9) {\n                    if (weight_differences[i][j] > weight_differences[i][k] + weight_differences[k][j]) {\n                        weight_differences[i][j] = weight_differences[i][k] + weight_differences[k][j];\n                    }\n                }\n            }\n        }\n    }\n}\n\nint main() {\n    int num_datasets, num_samples, num_measurements, num_queries;\n    scanf(\"%d\", &num_datasets);\n\n    while (num_datasets--) {\n        scanf(\"%d %d %d\", &num_samples, &num_measurements, &num_queries);\n\n        for (int i = 0; i < num_samples; i++) {\n            for (int j = 0; j < num_samples; j++) {\n                if (i == j) {\n                    weight_differences[i][j] = 0;\n                } else {\n                    weight_differences[i][j] = 1e9;\n                }\n            }\n        }\n\n        for (int m = 0; m < num_measurements; m++) {\n            int s1, s2, weight;\n            scanf(\"%d %d %d\", &s1, &s2, &weight);\n            weight_differences[s1][s2] = weight;\n        }\n\n        floydWarshall(num_samples);\n\n        for (int q = 0; q < num_queries; q++) {\n            int s1, s2;\n            scanf(\"%d %d\", &s1, &s2);\n            if (weight_differences[s1][s2] == 1e9) {\n                printf(\"UNKNOWN\\n\");\n            } else {\n                printf(\"%d\\n\", weight_differences[s1][s2]);\n            }\n        }\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-13 03:59:05"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def solve_weight_measurements():\n    while True:\n        # Number of samples\n        n = int(input())\n        if n == 0:\n            break\n\n        # Track weight differences\n        graph = {}\n        \n        # Process measurements\n        m = int(input())\n        for _ in range(m):\n            s1, s2, w = map(str.split, input().split())\n            s1, s2 = s1, s2\n            w = int(w)\n            \n            if s1 not in graph:\n                graph[s1] = {}\n            if s2 not in graph:\n                graph[s2] = {}\n            \n            graph[s1][s2] = w\n            graph[s2][s1] = -w\n\n        # Floyd-Warshall to compute all weight differences\n        samples = list(graph.keys())\n        for k in samples:\n            for i in samples:\n                for j in samples:\n                    if k in graph[i] and j in graph[k]:\n                        graph[i][j] = graph[i][k] + graph[k][j]\n\n        # Process queries\n        q = int(input())\n        for _ in range(q):\n            s1, s2 = input().split()\n            \n            if s1 not in graph or s2 not in graph or s2 not in graph[s1]:\n                print(\"Unknown\")\n            else:\n                print(graph[s1][s2])\n\nsolve_weight_measurements()",
    "timestamp": "2025-08-13 03:59:17"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\nfrom collections import defaultdict\n\ndef solve():\n    input = sys.stdin.read().split()\n    ptr = 0\n    while True:\n        N, M = map(int, input[ptr:ptr+2])\n        ptr +=2\n        if N ==0 and M ==0:\n            break\n        parent = defaultdict(lambda: None)\n        diff = defaultdict(int)  # diff[u] = weight[u] - weight[parent[u]]\n        \n        def find(u):\n            if parent[u] is None:\n                return u\n            orig_parent = parent[u]\n            root = find(parent[u])\n            if parent[u] != orig_parent:\n                diff[u] += diff[orig_parent]\n                parent[u] = root\n            return root\n        \n        def union(u, v, delta):\n            # u is heavier than v by delta: u = v + delta\n            root_u = find(u)\n            root_v = find(v)\n            if root_u == root_v:\n                return\n            parent[root_v] = root_u\n            diff[root_v] = diff[u] - diff[v] - delta\n        \n        for _ in range(M):\n            parts = input[ptr]\n            ptr +=1\n            if parts == '!':\n                u, v, w = map(int, input[ptr:ptr+3])\n                ptr +=3\n                union(u, v, w)\n            else:\n                u, v = map(int, input[ptr:ptr+2])\n                ptr +=2\n                root_u = find(u)\n                root_v = find(v)\n                if root_u != root_v:\n                    print(\"UNKNOWN\")\n                else:\n                    print(diff[v] - diff[u])\n\nsolve()",
    "timestamp": "2025-08-13 03:59:33"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <unordered_map>\n#include <string>\nusing namespace std;\n\nclass UnionFind {\npublic:\n    vector<int> parent, rank;\n    vector<long long> weight_diff;\n\n    UnionFind(int n) : parent(n), rank(n, 0), weight_diff(n, 0) {\n        for (int i = 0; i < n; ++i) {\n            parent[i] = i;\n        }\n    }\n\n    int find(int x) {\n        if (parent[x] != x) {\n            int orig_parent = parent[x];\n            parent[x] = find(parent[x]);\n            weight_diff[x] += weight_diff[orig_parent];\n        }\n        return parent[x];\n    }\n\n    void unite(int x, int y, int w) {\n        int rootX = find(x);\n        int rootY = find(y);\n        if (rootX == rootY) return;\n\n        if (rank[rootX] < rank[rootY]) {\n            parent[rootX] = rootY;\n            weight_diff[rootX] = weight_diff[y] - weight_diff[x] + w;\n        } else if (rank[rootX] > rank[rootY]) {\n            parent[rootY] = rootX;\n            weight_diff[rootY] = weight_diff[x] - weight_diff[y] - w;\n        } else {\n            parent[rootY] = rootX;\n            weight_diff[rootY] = weight_diff[x] - weight_diff[y] - w;\n            ++rank[rootX];\n        }\n    }\n\n    bool connected(int x, int y) {\n        return find(x) == find(y);\n    }\n\n    long long diff(int x, int y) {\n        if (connected(x, y)) {\n            return weight_diff[y] - weight_diff[x];\n        }\n        return LLONG_MAX; // represent unknown difference\n    }\n};\n\nint main() {\n    int n, m, q;\n    while (cin >> n >> m >> q) {\n        UnionFind uf(n);\n\n        for (int i = 0; i < m; ++i) {\n            int a, b, w;\n            cin >> a >> b >> w;\n            --a; --b;\n            uf.unite(a, b, w);\n        }\n\n        for (int i = 0; i < q; ++i) {\n            int a, b;\n            cin >> a >> b;\n            --a; --b;\n            if (uf.connected(a, b)) {\n                cout << uf.diff(a, b) << endl;\n            } else {\n                cout << \"UNKNOWN\" << endl;\n            }\n        }\n    }\n    return 0;\n}",
    "timestamp": "2025-08-13 11:16:02"
  }
]