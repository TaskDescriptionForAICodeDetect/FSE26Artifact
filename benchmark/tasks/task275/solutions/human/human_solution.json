[
  {
    "language": "Scala",
    "code": "import scala.annotation.tailrec\nimport scala.io.StdIn._\n\nobject Main extends App {\n  solve()\n  @tailrec def solve(): Unit = {\n    val Array(n, m) = readLine.trim.split(' ').map(_.toInt)\n    if (n == 0 && m == 0) return\n    val union = new DiffUnionFind(n)\n    for (_ ← 0 until m) {\n      readLine.trim.split(' ') match {\n        case Array(\"!\", a, b, w) ⇒ union.setRelation(a.toInt - 1, b.toInt - 1, w.toInt)\n        case Array(\"?\", a, b) ⇒\n          union.findDiff(a.toInt - 1, b.toInt - 1) match {\n            case Some(d) ⇒ println(d)\n            case None ⇒ println(\"UNKNOWN\")\n          }\n        case _ ⇒ ???\n      }\n    }\n    solve()\n  }\n}\n\n\nclass DiffUnionFind(val size: Int) {\n  private val parent = Array.fill(size){-1}\n  private val diff = Array.fill(size){0L}\n  private def find(a: Int): (Int, Long) = {\n    if (parent(a) < 0) {\n      (a, 0L)\n    }else {\n      val (p, d) = find(parent(a))\n      parent(a) = p\n      diff(a) += d\n      (p, diff(a))\n    }\n  }\n  def setRelation(a: Int, b: Int, w: Int): Boolean = {\n    val (ar, ad) = find(a)\n    val (br, bd) = find(b)\n    if (ar != br) {\n      if (parent(ar) < parent(br)) {\n        parent(ar) += parent(br)\n        parent(br) = ar\n        diff(br) = ad + w - bd\n      }else {\n        parent(br) += parent(ar)\n        parent(ar) = br\n        diff(ar) = bd - ad - w\n      }\n    }\n    ar != br || ad + w == bd\n  }\n  def findDiff(a: Int, b: Int): Option[Long] = {\n    val (ar, ad) = find(a)\n    val (br, bd) = find(b)\n    if (ar == br) Some(bd - ad)\n    else None\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define PI       3.1415926535897932384626433832795028841971\n#define INF 1000000000\n#define EPS      1e-10\n#define MOD      1000000\nusing namespace std;\ntypedef long long ll;\ntypedef pair<double,double> P;\ntypedef pair<double,P> PQ;\n\nstruct UF{\n\tint par[100000];\n\tint rank[100000];\n    ll si[100000];\n\n\tvoid init(int n){\n\t\trep(i,n){\n\t\t\tpar[i] = i;\n\t\t\trank[i] = 0;\n\t\t\tsi[i] = 0;\n\t\t}\n\t}\n\n\tint find(int x){\n\t\tif(par[x] == x) return x;\n\t\telse return find(par[x]);\n\t}\n    \n    ll value(int x, ll ret){\n        if(par[x] == x) return ret+si[x];\n        else return value(par[x],ret+si[x]);\n    }\n\n\tvoid unite(int x, int y, int w){\n        ll vx = value(x,0);\n        ll vy = value(y,0);\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif(x == y) return;\n\t\t\n\t\tif(rank[x] < rank[y]){\n\t\t\tpar[x] = y;\n            si[x] = vy-w-vx;\n\t\t} else{\n\t\t\tpar[y] = x;\n            si[y] = vx+w-vy;\n\t\t\tif(rank[x] == rank[y]) rank[x]++;\n\t\t}\n\t}\n\n\tbool same(int x, int y){\n\t\treturn find(x) == find(y);\n\t}\n} uf;\n\nint n, m;\n\nint main(){\n    while(cin >> n >> m){\n        if(n == 0 && m == 0) break;\n        uf.init(n);\n        rep(i,m){\n            char hoge;\n            int a, b, w;\n            cin >> hoge;\n            if(hoge == '!'){\n                cin >> a >> b >> w;\n                a--; b--;\n                uf.unite(a,b,w);\n                //rep(j,n) cout << uf.si[j] << \" \";\n                //cout << endl;\n            } else{\n                cin >> a >> b;\n                a--; b--;\n                if(!uf.same(a,b)){\n                    cout << \"UNKNOWN\" << endl;\n                    continue;\n                }\n                ll numa = uf.si[a];\n                ll numb = uf.si[b];\n                while(uf.par[a] != a){\n                    a = uf.par[a];\n                    numa += uf.si[a];\n                }\n                while(uf.par[b] != b){\n                    b = uf.par[b];\n                    numb += uf.si[b];\n                }\n                //cout << numb << \" \" << numa << endl;\n                cout << numb-numa << endl;\n            }\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\ntypedef long long ll;\n#define rep(i,n) for(int i=0;i<n;i++)\n\nint n,m;\ntemplate<typename T> class Weighted_UnionFind\n{\npublic:\n    vector<int> par,nrank;\n    vector<T> wd;\n    int V;\n    Weighted_UnionFind(int node_size){\n        V = node_size;\n        par.resize(V),wd.resize(V,0),nrank.resize(V,0);\n        rep(i,V){\n            par[i] = i;\n        }\n    }\n    int find(int x){\n        if(par[x] == x){\n            return x;\n        }else{\n            int parent = find(par[x]);\n            wd[x] += wd[par[x]];\n            return par[x] = parent;\n        }\n    }\n    T weight(int x){\n        find(x);\n        return wd[x];\n    }\n    void unite(int x,int y,T w){\n        w += weight(x), w -= weight(y);\n        x = find(x),y = find(y);\n        if(x == y) return;\n    \tif(nrank[x] < nrank[y]){\n            swap(x,y);\n            w = -w;\n        }\n        nrank[x] += (nrank[x] == nrank[y]);\n        par[y] = x;\n        wd[y] = w;\n    }\n    bool same(int x,int y){\n        return find(x)==find(y);\n    }\n    T diff(int x,int y){\n        return weight(y)-weight(x);\n    }\n};\n\n\nint main(){\n    while(cin>>n>>m&&n!=0){\n        Weighted_UnionFind<ll> wuf(n);\n        rep(t,m){\n            char c;\n            cin >> c;\n            if(c=='!'){\n                int a,b;\n                ll w;\n                cin >> a>> b >> w;\n                a--,b--;\n                wuf.unite(a,b,w);\n            }else{\n                int a,b;\n                cin >> a >> b;\n                a--,b--;\n                if(wuf.same(a,b)){\n                    cout << wuf.diff(a,b) << endl;\n                }else{\n                    cout << \"UNKNOWN\" << endl;\n                }\n            }\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define MAX_N 200005\nusing namespace std;\ntypedef pair<int,int> P;\nP par[MAX_N];\n\nvoid init(int n){\n  for(int i=0;i<n;i++)\n    par[i]=P(i,0);\n}\n\nP find(int x){\n  if(par[x].first==x)return P(x,0);\n  P r=find(par[x].first);\n  return par[x]=P(r.first,par[x].second+r.second);\n}\n\nvoid unite(int x,int y,int cost){\n  x=find(x).first;\n  y=find(y).first;\n  if(x==y)return;\n  par[x]=P(y,cost);\n}\n\nbool same(int x,int y){return find(x).first==find(y).first;}\n\nint n,m,a,b,cost;\nchar c;\n\nint main(){\n  while(1){\n    cin>>n>>m;\n    if(!n&&!m)break;\n    init(n);\n    rep(i,m){\n      cin>>c>>a>>b;\n      if(c=='!'){\n\tcin>>cost;\n\tunite(a-1,b-1,cost);\n      }else{\n\tif(!same(a-1,b-1))cout<<\"UNKNOWN\"<<endl;\n\telse cout<<find(a-1).second-find(b-1).second<<endl;\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<vector>\n#include<utility>\n\nusing namespace std;\n\nvector<pair<int, int> > UFtree(100010);\nvector<int> treeSize;\n\nint root_Diff(int i) {\n  if(UFtree[i].first == i) return 0;\n  else return UFtree[i].second + root_Diff(UFtree[i].first);\n}\n\nint root(int i) {\n  if(UFtree[i].first == i) return i;\n  else {\n    UFtree[i].second = root_Diff(i);\n    return (UFtree[i].first = root(UFtree[i].first));\n  }\n}\n\nbool is_same_set(int i, int j) {\n  return root(i) == root(j);\n}\n\n\n\nvoid unite(int i, int j, int w) {//w_i-w_j = w\n  int x, y, tmp1, tmp2;\n  x = root(i); y = root(j);\n  tmp1 = treeSize[x];\n  tmp2 = treeSize[y];\n  if(tmp1 > tmp2) {\n    UFtree[y].first = x;\n    UFtree[y].second = w + UFtree[i].second - UFtree[j].second;\n  }\n  else {\n    UFtree[x].first = y;\n    UFtree[x].second = -w - UFtree[i].second + UFtree[j].second;\n  }\n  if(x != i) {\n    treeSize[i] += tmp2;\n    treeSize[x] += tmp2;\n  }\n  else treeSize[i] += tmp2;\n  if(y != j) {\n    treeSize[y] += tmp1;\n    treeSize[j] += tmp1;\n  }\n  else treeSize[j] += tmp1;\n}\n\nint main() {\n  int N, M;\n  vector<int> c(100010, 1);\n  while(cin >> N >> M) {\n    if(!N) break;\n    for(int i = 1; i <= N; i++){\n      UFtree[i] = make_pair(i, 0);\n    }\n    treeSize = c;\n    string word;\n    int a, b, w;\n    for(int i = 0; i < M; i++) {\n      cin >> word >> a >> b;\n      if(word == \"!\") {\n\tcin >> w;\n\tunite(b, a, w);\n      }\n      else {\n\tif(is_same_set(a, b)) cout << root_Diff(a) - root_Diff(b) << endl;\n\telse cout << \"UNKNOWN\" << endl;\n      }\n    }\n    UFtree.clear();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define f first\n#define s second\n#define mp make_pair\n#define inf 1<<30\n#define MAX 1000010\nusing namespace std;\n\nlong long p[MAX],w[MAX];\n\nint Find(int a){\n  if(p[a]==a)return a;\n  return Find(p[a]);\n}\n\npair<int,int> find(int a){\n  pair<int,int> pii;\n  if(p[a]==a){\n    pii.f=a;pii.s=0;\n    return pii;\n  }\n  pii=find(p[a]);\n  pii.s+=w[a];\n  p[a]=pii.f;\n  w[a]=pii.s;\n  return pii;\n}\n\nint main()\n{\n  int n,q,a,b,d;\n  char c;\n\n  while(cin>>n>>q && n ){\n\n    for(int i=0;i<n;i++){\n      p[i]=i;\n      w[i]=0;\n    }\n\n    for(int i=0;i<q;i++){\n      cin>>c;\n      if(c=='!'){\n\tcin>>a>>b>>d;\n\ta--;b--;\n\tpair<int,int> pa=find(a),pb=find(b);\n\tp[pa.f]=b;\n\tw[pa.f]=pb.s+d-pa.s;\n\tp[a]=pb.f;\n\tw[a]=pb.s+d;\n      }\n      else {\n\tcin>>a>>b;\n\ta--;b--;\n\tpair<int,int> pa=find(a),pb=find(b);\n\tif(pa.f!=pb.f)cout<<\"UNKNOWM\"<<endl;\n\telse {\n\t  p[a]=pa.f;\n\t  w[a]=pa.s;\n\t  p[b]=pb.f;\n\t  w[b]=pb.s;\n\t  cout<<pa.s-pb.s<<endl;\n\t}\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<string>\n#include<cstring>\n#include<functional>\n#include<stack>\n#include<queue>\n#include <iomanip>\n#include<map>\n#include<limits>\n#include<cmath>\n#include<algorithm>\n#include<bitset>\n#include<utility>\n#include<complex>\n#include<cstdlib>\n#include<set>\n#include<cctype>\n\n#define DBG cerr << '!' << endl;\n#define REP(i,n) for(int (i) = (0);(i) < (n);++i)\n#define rep(i,s,g) for(int (i) = (s);(i) < (g);++i)\n#define rrep(i,s,g) for(int (i) = (s);i >= (g);--(i))\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {for(int W = 0;W < (n);W++)cerr << v[W] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,i,j) {for(int aaa = 0;aaa < i;aaa++){for(int bbb = 0;bbb < j;bbb++)cerr << v[aaa][bbb] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(10)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> iv;\ntypedef vector<iv> iiv;\ntypedef vector<string> sv;\n\n#define INF 10000000000\n\nstruct UF\n{\n\tvector<int> par; // ???\n\tvector<int> sz; // ??°\n\tvector<ll> value; // ???\n\t// ?????????\n\tUF(int n):par(n),sz(n),value(n) {\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tpar[i] = i;sz[i] = 1;value[i] = 0;\n\t\t}\n\t}\n\t// ??¨??????????±???????\n\tint find(int x) {\n\t\tif (par[x] == x)\n\t\t{\n\t\t\tvalue[x] = 0;\n\t\t\treturn x;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tint tmp = par[x];\n\t\t\tpar[x] = find(par[x]);\n\t\t\tvalue[x] += value[tmp];\n\t\t\t//cout << x << ' ' << value[x] << endl;\n\t\t\treturn par[x];\n\t\t}\n\t}\n\tll retValue(int n)\n\t{\n\t\tfind(n);\n\t//\tcout << n << \"s par is\" << par[n] << ' ' << value[n] << endl;\n\t\treturn value[n];\n\t}\n\t\n\t// x??¨y????±??????????????????????\n\tvoid unite(int x, int y,ll weight = 0) {\n\t\tint tmpx = x;int tmpy = y;\n\t\tx = find(x); y = find(y);\n\t\tif (x == y) return;\n\t\tpar[x] = y;\n\t\tvalue[x] = -value[tmpx] + weight + value[tmpy];\n\t//\tcout << \"after unite\" << x << \"value is\" << value[x] << \",par is\" << par[x] << endl;\n\t\tsz[y] += sz[x];\n\t}\n\t// x??¨y?????????????????????true\n\tbool same(int x, int y) { return find(x) == find(y); }\n\tint size(int n){return sz[find(n)];}\n};\n\nint n,m;\n\nint main()\n{\n\twhile(cin >> n >> m,n)\n\t{\n\t\t\n\t\tUF uf(n);\n\t\t\n\t\tREP(i,m)\n\t\t{\n\t\t\tchar c;int a,b;\n\t\t\tcin >> c >> a >> b;\n\t\t\ta--;b--;\n\t\t\tif(c == '!')\n\t\t\t{\n\t\t\t\tint w;cin >> w;\n\t\t\t\tuf.unite(a,b,w);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(!uf.same(a,b))\n\t\t\t\t{\n\t\t\t\t\tcout << \"UNKNOWN\" << endl;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tll A = uf.retValue(a);\n\t\t\t\t\tll B = uf.retValue(b);\n\t\t\t\t\tcout << A-B << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\t\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<map>\nusing namespace std;\n \n#define N 100000\n#define fs first\n#define sc second\ntypedef pair<int,int> P;\n\nP par[N],x,y,tmp;\nint rank[N];\n\nP find(int a){\n  if(par[a].fs == a)return par[a];\n  tmp = find(par[a].fs);\n  return par[a] = P(tmp.fs,tmp.sc + par[a].sc);\n}\n\nint main(){\n  char c;\n  int a,b,w,n,m;\n  while(scanf(\"%d%d\",&n,&m),(n||m)){\n    for(int i=0;i<n;i++)par[i] = P(i,0);\n\n    for(int i=0;i<m;i++){\n      scanf(\" %c \",&c);\n      if(c=='?'){\n\tscanf(\"%d%d\",&a,&b);\n\ta--; b--;\n\tif(find(a).fs==find(b).fs)printf(\"%d\\n\",par[b].sc - par[a].sc);\n\telse printf(\"UNKNOWN\\n\");\n      }else{\n\tscanf(\"%d%d%d\",&a,&b,&w);\n\ta--; b--;\n\n\tx = find(a);\n\ty = find(b);\n\t\n\tif(x.fs!=y.fs){\n\t  if(rank[x.fs]<rank[y.fs]){\n\t    par[x.fs] = P(y.fs,y.sc-x.sc-w);\n\t  }else{\n\t    par[y.fs] = P(x.fs,x.sc-y.sc+w);\n\t    if(rank[x.fs] == rank[y.fs])rank[x.fs]++;\n\t  }\n\t}\n      }\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\ntypedef long long int ll;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000001\nusing namespace std;\n\nint* parent; //????????°?????????????±?????????????????????????????????????????????????????????¨\nint* height; //????????°?????????????±?????????????????????????????????????????????????????????¨\n\n\nint* calc_parent;\nint* relative_weight; //?????????????????¨??????????????????????????????????????????\n\nint find_parent(int id){\n\tif(parent[id] == id)return id;\n\telse{\n\t\treturn parent[id] = find_parent(parent[id]);\n\t}\n}\n\nint find_calc_parent(int id){\n\tif(calc_parent[id] == id)return id;\n\telse{\n\t\t//return calc_parent[id] = find_calc_parent(calc_parent[id]);\n\t\treturn calc_parent[id] = find_calc_parent(calc_parent[id]); //?????????????????§??????????????????\n\t}\n}\n\n//calc_parent???????????§????????????\nint compress_calc_parent(int id){\n\tif(calc_parent[id] == id)return id;\n\telse{\n\t\treturn calc_parent[id] = find_calc_parent(calc_parent[id]);\n\t}\n}\n\n//??????????????????????????????????¨??????????\nint calc_relative_weight(int id){\n\n\tint calc_p = find_calc_parent(id);\n\tif(calc_parent[id] == calc_p){ //????????§??????????????????????????´???\n\t\treturn relative_weight[id];\n\t}else{ //????????§?????????????????????????????´???\n\t\tif(calc_parent[id] == id){\n\t\t\treturn 0; //????????????????????????0\n\t\t}else{\n\t\t\t//return relative_weight[id] = relative_weight[id] + calc_relative_weight(calc_parent[id]);\n\t\t\treturn relative_weight[id] + calc_relative_weight(calc_parent[id]);\n\t\t}\n\t}\n}\n\n//??°??????????????±????????????????????????????????¨?????±????????????\nvoid unite(int a,int b,int w){\n\n\t//?????????\n\tint a_parent = find_parent(a);\n\tint b_parent = find_parent(b);\n\n\tif(a_parent == b_parent)return; //????????°???????????????calc_parent??¨?????±??????????????????????????????\n\n\t//??±?????????\n\tif(height[a_parent] == height[b_parent]){\n\t\tparent[b_parent] = a_parent;\n\t\theight[a_parent]++;\n\t}else if(height[a_parent] > height[b_parent]){\n\t\tparent[b_parent] = a_parent;\n\t}else{\n\t\tparent[a_parent] = b_parent;\n\t}\n\n\tint relative_a = calc_relative_weight(a);\n\tint relative_b = calc_relative_weight(b);\n\n\t//printf(\"relative_a:%d relative_b:%d\\n\",relative_a,relative_b);\n\n\tif((relative_b-relative_a) -w <= 0){ //a????????????????????????????????????????????????????????¨???\n\t\t//printf(\"???[a]-???[b]:%d\\n\",(relative_b-relative_a) -w);\n\t\t//a?????¨???b?????¨???????????????\n\t\trelative_weight[calc_parent[b]] = w-(relative_b-relative_a);\n\t\tcalc_parent[calc_parent[b]] = calc_parent[a];\n\n\t}else{\n\t\t//printf(\"???[a]-???[b]:%d\\n\",(relative_b-relative_a) -w);\n\t\t//b?????¨???a?????¨???????????????\n\t\trelative_weight[calc_parent[a]] = (relative_b-relative_a) -w;\n\t\tcalc_parent[calc_parent[a]] = calc_parent[b];\n\n\t\tif(b == 3 && a == 2){\n\t\t\t//printf(\"calc_parent[3]:%d relative_weight[3]:%d\\n\",calc_parent[3],relative_weight[3]);\n\t\t}\n\t}\n}\n\nbool isSame(int a,int b){\n\treturn find_parent(a) == find_parent(b);\n}\n\nint main(){\n\n\tint N,M,a,b,w;\n\tparent = new int[100001];\n\theight = new int[100001];\n\tcalc_parent = new int[100001];\n\trelative_weight = new int[100001];\n\tchar command[2];\n\n\twhile(true){\n\t\tscanf(\"%d %d\",&N,&M);\n\t\tif(N == 0 && M == 0)break;\n\n\t\tfor(int i = 1; i <= N; i++){\n\t\t\tparent[i] = i;\n\t\t\theight[i] = 0;\n\t\t\tcalc_parent[i] = i;\n\t\t\trelative_weight[i] = 0; //????????????0???????????????\n\t\t}\n\n\t\tfor(int loop = 0; loop < M; loop++){\n\t\t\tscanf(\"%s %d %d\",command,&a,&b);\n\t\t\tif(command[0] == '!'){ //??¬?????????\n\t\t\t\tscanf(\"%d\",&w);\n\t\t\t\tunite(a,b,w);\n\t\t\t}else{ //???????????????\n\t\t\t\tif(!isSame(a,b)){\n\t\t\t\t\tprintf(\"UNKNOWN\\n\");\n\t\t\t\t}else{\n\t\t\t\t\tprintf(\"%d\\n\",calc_relative_weight(b)-calc_relative_weight(a));\n\t\t\t\t\t//compress_calc_parent(b);\n\t\t\t\t\t//compress_calc_parent(a);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\nlong long dist[1 << 18];\nlong long group[1 << 18]; char q;\nlong long n, Q, a, b, c;\nvector<long long>gr[1 << 18];\nint main() {\n\twhile (true) {\n\t\tfor (int i = 0; i < (1 << 18); i++) {\n\t\t\tdist[i] = 0; group[i] = i; gr[i].clear(); gr[i].push_back(i);\n\t\t}\n\t\tcin >> n >> Q; if (n == 0 && Q == 0)break;\n\t\tfor (int i = 0; i < Q; i++) {\n\t\t\tcin >> q;\n\t\t\tif (q == '?') {\n\t\t\t\tcin >> a >> b;\n\t\t\t\tif (group[a] != group[b])cout << \"UNKNOWN\" << endl;\n\t\t\t\telse cout << dist[b] - dist[a] << endl;\n\t\t\t}\n\t\t\tif (q == '!') {\n\t\t\t\tcin >> a >> b >> c;\n\t\t\t\tif (group[a] != group[b]) {\n\t\t\t\t\tlong long K = dist[a] + c - dist[b];\n\t\t\t\t\tlong long L = group[a], M = group[b];\n\t\t\t\t\tfor (int j = 0; j < gr[M].size(); j++) {\n\t\t\t\t\t\tgroup[gr[M][j]] = L;\n\t\t\t\t\t\tgr[L].push_back(gr[M][j]);\n\t\t\t\t\t\tdist[gr[M][j]] += K;\n\t\t\t\t\t}\n\t\t\t\t\tgr[M].clear();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> P;\nconst double EPS = 1e-12;\nconst int INF = numeric_limits<int>::max()/2;\nconst int MOD = 1e9+7;\n\nstruct UFW { // union-find with weight\n\tvector<int> par,w; // w := weight between parent\n\tUFW(int size) : par(size, -1), w(size,0) { }\n\tbool unite(int x, int y, int d) {\n\t\tif (root(x) != root(y)) {\n            if (par[y] < par[x]){\n                swap(x, y);\n                d *= -1;\n            }\n            w[root(y)] = d+weight(x)-weight(y);\n\t\t\tpar[root(y)] = root(x);\n            \n\t\t}\n\t\treturn x != y;\n\t}\n    void init(int size){\n        for(int i=0;i<size;i++){\n            par[i]=-1;\n            w[i]=0;\n        }\n    }\n\tbool same(int x, int y) {\n\t\treturn root(x) == root(y);\n\t}\n\tint root(int x) {\n\t\treturn par[x] < 0 ? x : root(par[x]);\n\t}\n    int weight(int x){\n        //cout<<x<<endl;\n        if(root(x)==x) return 0;\n        return w[x]+weight(par[x]);\n    }\n    void print(int size){\n        for(int i=0;i<size;i++) cout<<\" \"<<i;\n        cout<<endl;\n        for(int i=0;i<size;i++) cout<<\" \"<<par[i];\n        cout<<endl;\n        for(int i=0;i<size;i++) cout<<\" \"<<w[i];\n        cout<<endl;\n    }\n};\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int n,m;\n    string s;\n    int a,b;\n    ll w;\n    UFW uf(111111);\n    while(cin>>n>>m,n){\n        uf.init(n);\n        for(int i=0;i<m;i++){\n            cin>>s;\n            if(s==\"!\"){\n                cin>>a>>b>>w;\n                a--;b--;\n                uf.unite(a,b,w);\n            }\n            else{\n                cin>>a>>b;\n                a--;b--;\n                //uf.print(n);\n                if(!uf.same(a,b)) cout<<\"UNKNOWN\"<<endl;\n                else{\n                    cout<<uf.weight(b)-uf.weight(a)<<endl;\n                    //cout<<uf.weight(b)<<\" \"<<uf.weight(a)<<endl;\n                }\n                \n            }\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass uf {\n    vector<int> par;\npublic:\n    uf(int n) {\n        par.resize(n);\n        for (int i = 0; i < n; i++) {\n            par[i] = i;\n        }\n    }\n\n    int find(int x) {\n        if (par[x] == x) return x;\n        else return (par[x] = find(par[x]));\n    }\n\n    void unite(int x, int y) {\n        x = find(x);\n        y = find(y);\n\n        if (x < y) {\n            par[y] = x;\n        } else {\n            par[x] = y;\n        }\n    }\n};\n\nint main() {\n    int N, M;\n    while (cin >> N >> M, N || M) {\n        vector<char> c(M);\n        vector<int> a(M);\n        vector<int> b(M);\n        vector<int> w(M);\n        vector<map<int,int> > dict(N+1);\n        set<int> s;\n        for (int i = 0; i < M; i++) {\n            cin >> c[i] >> a[i] >> b[i];\n            if (c[i] == '!') {\n                cin >> w[i];\n                s.insert(a[i]);\n                s.insert(b[i]);\n                dict[a[i]][b[i]] = w[i];\n                dict[b[i]][a[i]] = -w[i];\n            }\n        }\n\n        vector<int> dist(N+1, 1111111);\n        vector<int> used(N+1);\n        for (auto i : s) {\n            if (dist[i] != 1111111) continue;\n\n            dist[i] = 0;\n            queue<int> que;\n            que.push(i);\n\n            while (que.size()) {\n                int k = que.front();\n                que.pop();\n                if (used[k]) continue;\n\n                used[k] = true;\n                for (auto p : dict[k]) {\n                    if (used[p.first]) continue;\n                    dist[p.first] = dist[k] + p.second;\n                    que.push(p.first);\n                }\n            }\n        }\n\n        uf t(N+1);\n        for (int i = 0; i < M; i++) {\n            if (c[i] == '?') {\n                if (t.find(a[i]) == t.find(b[i])) {\n                    cout << dist[b[i]] - dist[a[i]] << endl;\n                } else {\n                    cout << \"UNKNOWN\" << endl;\n                }\n            } else {\n                t.unite(a[i], b[i]);\n            }\n        }\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <deque>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <vector>\n#include <set>\n#include <limits>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < (int)(j); ++i)\n#define FOR(i, j, k) for(int i = (int)(j); i < (int)(k); ++i)\n#define SORT(v) sort((v).begin(), (v).end())\n#define REVERSE(v) reverse((v).begin(), (v).end())\ntypedef pair<int, int> P;\n\nvector<int> v, parent, dist;\n\n// P(parent, dist)\nP find(int a){\n  if(parent[a] == a) return P(a, dist[a]);\n  P p = find(parent[a]);\n  parent[a] = p.first;\n  dist[a] += p.second;\n  return P(p.first, dist[a]);\n}\n\nbool same(int a, int b){\n  return find(a).first == find(b).first;\n}\n\nvoid merge(int a, int b, int _d){\n  if(same(a, b)) return ;\n  P pa = find(a), pb = find(b);\n  int d = _d - pb.second + pa.second;\n  if(d < 0){\n    d *= -1;\n    swap(pa, pb);\n  }\n  parent[pb.first] = pa.first;\n  dist[pb.first] = d;\n}\n\nvoid init_union_find(int V){\n  v = vector<int>(V);\n  parent = vector<int>(V);\n  dist = vector<int>(V, 0);\n  REP(i, V) parent[i] = i;\n}\n\nint main() {\n  int N, M;\n  while(cin >>N >>M && N){\n    init_union_find(N);\n    REP(i, M){\n      char c; cin >>c;\n      if(c == '!'){\n        int x, y, z; cin >>x >>y >>z;\n        merge(x - 1, y - 1, z);\n      } else{\n        int x, y; cin >>x >>y;\n        P xp = find(x - 1), yp = find(y - 1);\n        if(!same(x - 1, y - 1)) cout <<\"UNKNOWN\" <<endl;\n        else cout <<yp.second - xp.second <<endl;\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint n,q;\nint p[100010] = {0},r[100010] = {0};\nint diff_weight[100010] = {0};\nvoid init(int N){\n\tfor(int i=0;i<=N;++i){\n\t\tp[i] = i;\n\t\tdiff_weight[i] = 0;\n\t}\n}\n\nint root(int a){\n\tif(p[a] == a) return a;\n\telse{\n\t\tint r = root(p[a]);\n\t\tdiff_weight[a] += diff_weight[p[a]];\n\t\treturn (p[a] = r);\n\t}\n}\n\nbool is_same_set(int a,int b){\n\treturn root(a) == root(b);\n}\n\nint weight(int a){\n\troot(a);\n\treturn diff_weight[a];\n}\n\nint diff(int a, int b){\n\treturn weight(b) - weight(a);\n}\n\nvoid unite(int a, int b, int w){\n\tw += weight(a);\n\tw -= weight(b);\n\ta = root(a);\n\tb = root(b);\n\tif(a==b) return;\n\tif(r[a]<r[b]){\n\t\tp[a] = b;\n\t\tw = -w;\n\t}else{\n\t\tp[b] = a;\n\t\tif(r[a] == r[b]) r[a]++;\n\t}\n\tdiff_weight[b] = w;\n}\n\nint main(){\n\twhile(cin >> n >> q && n>0){;\n\t\tinit(n);\n\t\tfor(int i=0;i<q;i++){\n\t\t\tchar c;\n\t\t\tint w,a,b;\n\t\t\tcin >> c;\n\t\t\tif(c=='!'){\n\t\t\t\tcin >> a >> b >> w;\n\t\t\t\tunite(a,b,w);\n\t\t\t}else{\n\t\t\t\tcin >> a >> b;\n\t\t\t\tif(is_same_set(a,b)) cout << diff(a,b) << endl;\n\t\t\t\telse cout << \"UNKNOWN\" << endl;\n\t\t\t}\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\ntemplate <typename T>\nstruct WeightedUnionFind{\n  T d;\n  vector<int> r,p;\n  vector<T> ws;\n\n  WeightedUnionFind(){}\n  WeightedUnionFind(int n,T d):\n    d(d),r(n,1),p(n),ws(n,d){iota(p.begin(),p.end(),0);}\n\n  int find(int x){\n    if(x==p[x]) return x;\n    int t=find(p[x]);\n    ws[x]+=ws[p[x]];\n    return p[x]=t;\n  }\n\n  T weight(int x){\n    find(x);\n    return ws[x];\n  }\n\n  bool same(int x,int y){\n    return find(x)==find(y);\n  }\n\n  void unite(int x,int y,T w){\n    w+=weight(x);\n    w-=weight(y);\n    x=find(x);y=find(y);\n    if(x==y) return;\n    if(r[x]<r[y]) swap(x,y),w=-w;\n    r[x]+=r[y];\n    p[y]=x;\n    ws[y]=w;\n  }\n\n  T diff(int x,int y){\n    return weight(y)-weight(x);\n  }\n};\n\n\nstruct FastIO{\n  FastIO(){\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n  }\n}fastio_beet;\n\n//INSERT ABOVE HERE\nsigned main(){\n  int n,m;\n  while(cin>>n>>m,n){\n    using ll = long long;\n    WeightedUnionFind<ll> wf(n,0);\n    for(int i=0;i<m;i++){\n      char t;\n      cin>>t;\n      if(t=='!'){\n        int a,b,w;\n        cin>>a>>b>>w;\n        a--;b--;\n        wf.unite(a,b,w);\n      }\n      if(t=='?'){\n        int a,b;\n        cin>>a>>b;\n        a--;b--;\n        if(wf.same(a,b))\n          cout<<wf.diff(a,b)<<\"\\n\";\n        else\n          cout<<\"UNKNOWN\\n\";\n      }\n    }\n  }\n  cout<<flush;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\n\nstruct UnionFind {\n    ll node[100010], weight[100010];\n    UnionFind() {\n        memset(node, -1, sizeof(node));\n        memset(weight, 0, sizeof(weight));\n    }\n    void unite(int u, int v, ll w) {\n        // printf(\"(u, v) = (%d, %d)\\n\", u, v);\n        // printf(\"find(u, v) = (%d, %d)\\n\", find(u), find(v));\n        if(find(u) == find(v)) return;\n        if(find(u) > find(v)) swap(u, v), w *= -1;\n        ll new_weight = get_weight(u);\n\n        // printf(\"new_weight = %d\\n\", new_weight);\n        // v ????????? (u ??????) ???????????????\n        u = find(u);\n        node[u] += node[v];\n        node[v] = u;\n        weight[v] += new_weight + w;\n    }\n\n    ll get_weight(int u) {\n        ll ret = 0;\n        for(; node[u] >= 0; u = node[u]) ret += weight[u];\n        return ret;\n    }\n\n    int find(int u) {\n        return (node[u] < 0 ? u : node[u] = find(node[u]));\n    }\n};\n\nint main() {\n    int N, M;\n    while(cin >> N >> M, N) {\n        UnionFind uf;\n        for(int i=0; i<M; i++) {\n            char c; cin >> c;\n            if(c == '!') {\n                int a, b, d; cin >> a >> b >> d;\n                a--; b--;\n                uf.unite(a, b, d);\n            }\n            else {\n                int a, b; cin >> a >> b;\n                a--; b--;\n                if(uf.find(a) != uf.find(b)) cout << \"UNKNOWN\" << endl;\n                else {\n                    ll wa = uf.weight[a];\n                    ll wb = uf.weight[b];\n                    // printf(\"wa = %d, wb = %d\\n\", wa, wb);\n                    cout << wb - wa << endl;\n                }\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <deque>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <unordered_map>\n#include <unordered_set>\n#include <utility>\n#include <vector>\n#include <cfloat>\n\nusing std::cerr;\nusing std::cin;\nusing std::cout;\nusing std::endl;\n\nconst int UNKNOWN=INT32_MIN;\n\n// Manages Weighted Union-Find Forest.\nclass WeightedUnionFindForest {\n  std::vector<int> parent_;\n  std::vector<int> rank_;\n  std::vector<int> size_;\n  std::vector<int> weight_;\n\npublic:\n  // Initialize forest.\n  // parent_[i]=i, rank_[i]=0, size_[i]=1, weight_[i]=0.\n  WeightedUnionFindForest(const int &n);\n  // Get the number of the root of the node q.\n  int Root(const int &q);\n  // Return true if the roots of x and y is same.\n  bool IsSame(const int &x, const int &y);\n  // Unite the tree x and tree y(weight is w).\n  // If x and y already have been united, return false.\n  // Weight(y)-Weight(x)=w\n  bool Unite(int x, int y, int w);\n  // Get the number of nodes which are the same group as node q.\n  int Size(const int &q);\n  // Get the weight of node q.\n  int Weight(const int &q);\n  // Get the weights' difference of node x and y(Weight(y)-Weight(x)).\n  int Diff(const int &x, const int &y);\n};\n\nWeightedUnionFindForest::WeightedUnionFindForest(const int &n) {\n  parent_.resize(n);\n  rank_.resize(n);\n  size_.resize(n);\n  weight_.resize(n);\n  for (int i = 0; i < n; i++) {\n    parent_[i] = i;\n    rank_[i]   = 0;\n    size_[i]   = 1;\n    weight_[i] = 0;\n  }\n}\nint WeightedUnionFindForest::Size(const int &q) {\n  return size_[Root(q)];\n}\nint WeightedUnionFindForest::Root(const int &q) {\n  if (parent_[q] == q) {\n    return q;\n  } else {\n    const int r = Root(parent_[q]);\n    weight_[q] += weight_[parent_[q]];\n    return parent_[q] = r;\n  }\n}\n\nbool WeightedUnionFindForest::IsSame(const int &x, const int &y) {\n  return Root(x) == Root(y);\n}\n\nint WeightedUnionFindForest::Weight(const int &q) {\n  Root(q);  // compress path\n  return weight_[q];\n}\nint WeightedUnionFindForest::Diff(const int &x, const int &y) {\n  if (Root(x) != Root(y)) {\n    cerr << \"WeightedUnionFindForest: Error\" << endl;\n    cerr << \"Roots of node x and y aren't same\" << endl;\n    return INT32_MAX;\n  }\n  return Weight(y) - Weight(x);\n}\n\nbool WeightedUnionFindForest::Unite(int x, int y, int w) {\n  w += Weight(x);\n  w -= Weight(y);\n  x = Root(x);\n  y = Root(y);\n\n  if (x == y) return false;\n  if (rank_[x] < rank_[y]) {\n    weight_[x] = w * (-1);\n    parent_[x] = y;\n    size_[y] += size_[x];\n    size_[x] = 0;\n\n  } else {\n    weight_[y] = w;\n    parent_[y] = x;\n    size_[x] += size_[y];\n    size_[y] = 0;\n    if (rank_[x] == rank_[y]) rank_[x]++;\n  }\n  return true;\n}\n\nvoid Solve(int n,int m){\n  WeightedUnionFindForest wf(n+1);\n  for(int i=0;i<m;i++){\n    char c;\n    cin>>c;\n    if(c=='!'){\n      int a,b,w;\n      cin>>a>>b>>w;\n      wf.Unite(b,a,w);\n    }else{\n      int a,b;\n      cin>>a>>b;\n      if(wf.IsSame(a,b)){\n        cout<<wf.Diff(b,a)<<endl;\n      }else{\n        cout<<\"UNKNOWN\"<<endl;\n      }\n    }\n  }\n\n}\n\nint main(){\n  cout << std::fixed << std::setprecision(16);\n  cin.tie(nullptr);\n  std::ios::sync_with_stdio(false);\n\n  while(true){\n    int n,m;\n    cin>>n>>m;\n    if(n==0) break;\n    Solve(n,m);\n  }\n\n\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nconst int MAX = 100010;\n\nint n, m;\nchar s[10];\nint a, b, c;\nint father[MAX], Rank[MAX];\n\n\nvoid init(){\n\tfor(int i=1; i<=n; i++){\n\t\tfather[i] = i;\n\t\tRank[i] = 0;\n\t}\n}\n\nint find(int x){\n\tif(x != father[x]){\n\t\tRank[x] += Rank[father[x]];\n\t\tfather[x] = find(father[x]);\n\t}\n\treturn father[x];\n}\n\nvoid Union(int a, int b, int c){\n\tint aa = find(a), bb = find(b);\n\tif(aa != bb){\n\t\tif(!Rank[a] && !Rank[b]) father[bb] = aa, Rank[bb] = c + Rank[a];\n\t\telse if(!Rank[b]) father[bb] = aa, Rank[bb] = c + Rank[a];\n\t\telse father[aa] = bb, Rank[aa] = -c + Rank[b];\n\t}\n}\n\nint main(){\n\twhile(scanf(\"%d%d\", &n, &m) == 2){\n\t\tif(!n && !m) break;\n\t\tinit();\n\t\tfor(int i=0; i<m; i++){\n\t\t\tscanf(\"%s\", s);\n\t\t\tif(s[0] == '!'){\n\t\t\t\tscanf(\"%d%d%d\", &a, &b, &c);\n\t\t\t\tUnion(a, b, c);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tscanf(\"%d%d\", &a, &b);\n\t\t\t\tint aa = find(a), bb = find(b);\n\t\t\t\tif(aa != bb) puts(\"UNKNOWN\");\n\t\t\t\telse printf(\"%d\\n\", Rank[b]-Rank[a]);\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long int;\ntemplate<class T = int> using V = vector<T>;\ntemplate<class T = int> using VV = V< V<T> >;\ntemplate<class T> void assign(V<T>& v, int n, const T& a = T()) { v.assign(n, a); }\ntemplate<class T, class... Args> void assign(V<T>& v, int n, const Args&... args) { v.resize(n); for (auto&& e : v) assign(e, args...); }\n\n\n#ifdef __linux__\n#define getchar getchar_unlocked\n#define putchar putchar_unlocked\n#endif\nint read_int(){int c,r;while((c=getchar())<48);r=c-48;while((c=getchar())>47)r=r*10+c-48;return r;}\nvoid write_int(int x){int b[10],*p=b;do*p++=48+x%10,x/=10;while(x);do putchar(*--p);while(p>b);}\n\nstruct AdditiveGroup {\n  using T = int;\n  static T op(const T& lhs, const T& rhs) { return lhs + rhs; }\n  static constexpr T e() { return 0; }\n  static T inv(const T& val) { return -val; }\n};\n\ntemplate<class AbelianGroup> struct UnionFind {\n  using T = typename AbelianGroup::T;\n\n  V<> dat;\n  V<T> pot;\n\n  UnionFind(int n) : dat(n, -1), pot(n, AbelianGroup::e()) {}\n\n  T sub(const T& lhs, const T& rhs) { return AbelianGroup::op(lhs, AbelianGroup::inv(rhs)); }\n\n  T diff(int u, int v) {\n    assert(same(u, v));\n    return sub(pot[v], pot[u]);\n  }\n\n  int find(int v) {\n    if (dat[v] < 0) return v;\n    else {\n      int r = find(dat[v]);\n      pot[v] = AbelianGroup::op(pot[v], pot[dat[v]]);\n      return dat[v] = r;\n    }\n  }\n\n  bool same(int u, int v) { return find(u) == find(v); }\n\n  int size(int v) { return -dat[find(v)]; }\n\n  void unite(int u, int v, T d) {\n    assert(!same(u, v));\n    d = sub(d, sub(pot[v], pot[u]));\n    if (dat[u] >= 0) u = dat[u];\n    if (dat[v] >= 0) v = dat[v];\n    if (-dat[u] < -dat[v]) {\n      dat[v] += dat[u];\n      dat[u] = v;\n      pot[u] = AbelianGroup::inv(d);\n    } else {\n      dat[u] += dat[v];\n      dat[v] = u;\n      pot[v] = d;\n    }\n  }\n};\n\nint main() {\n  while (true) {\n    int n = read_int(), m = read_int();\n    if (!n) break;\n    UnionFind<AdditiveGroup> uf(n);\n    for (int i = 0; i < m; ++i) {\n      char c = getchar();\n      if (c == '!') {\n        int u = read_int(), v = read_int(), d = read_int(); --u, --v;\n        if (!uf.same(u, v)) uf.unite(u, v, d);\n      } else {\n        int u = read_int(), v = read_int(); --u, --v;\n        if (uf.same(u, v)) {\n          printf(\"%d\\n\", uf.diff(u, v));\n        } else printf(\"UNKNOWN\\n\");\n      }\n    }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<bitset>\n#include<algorithm>\nusing namespace std;\n#define MAX_N 100\n\nclass union_find{\nprivate:\n\tint parents[MAX_N];\n\tint rank[MAX_N];\n\tint weight[MAX_N];\npublic:\n\tunion_find(){\n\t\tfor(int i=0;i<MAX_N;i++){\n\t\t\tparents[i]=i;\n\t\t\trank[i]=0;\n\t\t\tweight[i]=0;\n\t\t}\n\t}\n\tunion_find(int n){\n\t\tfor(int i=0;i<n;i++){\n\t\t\tparents[i]=i;\n\t\t\trank[i]=0;\n\t\t\tweight[i]=0;\n\t\t}\n\t}\n\tint find(int x){\n\t\tif(parents[x]==x){\n\t\t\treturn x;\n\t\t}else{\n\t\t\tint tmp=find(parents[x]);\n\t\t\tweight[x]=weight[x]+weight[parents[x]];\n\t\t\treturn parents[x]=tmp;\n\t\t}\n\t}\n\tvoid unite(int x,int y,int w){\n\t\tint tmpx=find(x);\n\t\tint tmpy=find(y);\n\t\tif(tmpx==tmpy)return;\n\t\t//cout<<\"weight list\"<<weight[x]<<\" \"<<weight[y]<<\" \"<<w<<endl;\n\t\tif(rank[tmpx]<rank[tmpy]){\n\t\t\tweight[tmpx]=w-weight[x]+weight[y];\n\t\t\tparents[tmpx]=tmpy;\n\t\t}else{\n\t\t\tweight[tmpy]=-w-weight[y]+weight[x];\n\t\t\tparents[tmpy]=tmpx;\n\t\t\tif(rank[tmpx]==rank[tmpy])rank[tmpx]++;\n\t\t}\n\t}\n\tbool same(int x,int y){\n\t\treturn (find(x)==find(y));\n\t}\n\t\n\tint get_weight(int x,int y){\n\t\tif(find(x)==find(y)){\n\t\t\t//cout<<\"get weight \"<<weight[x]<<\" \"<<weight[y]<<endl;\n\t\t\treturn weight[x]-weight[y];\n\t\t}else{\n\t\t\treturn -2000000;\n\t\t}\n\t}\n};\nint main(){\n\tchar c;\n\tint a,b,w;\n\tint n,m;\n\twhile(cin>>n>>m,n!=0||m!=0){\n\t\tunion_find uf(n+1);\n\t\tfor(int i=0;i<m;i++){\n\t\t\tcin>>c;\n\t\t\tif(c=='!'){\n\t\t\t\tcin>>a>>b>>w;\n\t\t\t\tuf.unite(a,b,w);\n\t\t\t}else if(c=='?'){\n\t\t\t\tcin>>a>>b;\n\t\t\t\tif(uf.same(a,b)){\n\t\t\t\t\tint tmp=uf.get_weight(a,b);\n\t\t\t\t\tif(tmp!=-2000000){\n\t\t\t\t\t\tcout<<tmp<<endl;\n\t\t\t\t\t}else{\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tcout<<\"UNKNOWN\"<<endl;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tcout<<\"???\"<<endl;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint pre[100001], value[100001];\n\nint find(int x)\n{\n\tif (x != pre[x]){\n\t\tint t = pre[x];\n\t\tpre[x] = find(pre[x]);\n\t\tvalue[x] += value[t];\n\t\treturn pre[x];\n\t}\n\treturn x;\n}\n\nvoid unite(int a, int b, int c)\n{\n\tint fa = find(a), fb = find(b);\n\tif (fa != fb){\n\t\tvalue[fa] = c + value[b] - value[a];\n\t\tpre[fa] = fb;\n\t}\n}\n\nint main()\n{\n\tint n, m, a, b, c;\n\twhile (~scanf(\"%d%d\", &n, &m)){\n\t\tif (!n && !m)return 0;\n\t\tfor (int i = 1; i <= n; ++i){\n\t\t\tpre[i] = i;\n\t\t\tvalue[i] = 0;\n\t\t}\n\t\tchar ch;\n\t\twhile (m--){\n\t\t\tcin >> ch;\n\t\t\tif (ch == '?'){\n\t\t\t\tscanf(\"%d%d\", &a, &b);\n\t\t\t\tif (find(a) == find(b))cout << value[a] - value[b] << endl;\n\t\t\t\telse cout << \"UNKNOWN\" << endl;\n\t\t\t}else{\n\t\t\t\tscanf(\"%d%d%d\", &a, &b, &c);\n\t\t\t\tunite(a, b, c);\n\t\t\t}\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\nlong long dist[1 << 18];\nlong long group[1 << 18]; char q;\nlong long n, Q, a, b, c;\nvector<long long>gr[1 << 18];\nint main() {\n\twhile (true) {\n\t\tfor (int i = 0; i < 1 << 18; i++) {\n\t\t\tdist[i] = 0; group[i] = i; gr[i].clear(); gr[i].push_back(i);\n\t\t}\n\t\tcin >> n >> Q; if (n == 0 && Q == 0)break;\n\t\tfor (int i = 0; i < Q; i++) {\n\t\t\tcin >> q;\n\t\t\tif (q == '?') {\n\t\t\t\tcin >> a >> b;\n\t\t\t\tif (group[a] != group[b])cout << \"UNKNOWN\" << endl;\n\t\t\t\telse cout << dist[b] - dist[a] << endl;\n\t\t\t}\n\t\t\tif (q == '!') {\n\t\t\t\tcin >> a >> b >> c;\n\t\t\t\tif (group[a] != group[b]) {\n\t\t\t\t\tint K = dist[a] + c - dist[b];\n\t\t\t\t\tint L = group[a], M = group[b];\n\t\t\t\t\tfor (int j = 0; j < gr[M].size(); j++) {\n\t\t\t\t\t\tgroup[gr[M][j]] = L;\n\t\t\t\t\t\tgr[L].push_back(gr[M][j]);\n\t\t\t\t\t\tdist[gr[M][j]] += K;\n\t\t\t\t\t}\n\t\t\t\t\tgr[M].clear();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#define maxlen 200010\nusing namespace std;\nint father[maxlen];\nlong long  dist[maxlen];\nint n,m;\nchar cmd;\nvoid init()\n{\n    for(int i=0; i<=n; ++i)\n    {\n        father[i]=i;\n        dist[i]=0;\n    }\n}\nint Find(int x)\n{\n    if(father[x]==x)\n        return x;\n    else\n    {\n        int root=Find(father[x]);\n        dist[x]+=dist[father[x]];\n        return father[x]=root;\n    }\n}\nint main ()\n{\n    //freopen(\"in.txt\",\"r\",stdin);\n    //freopen(\"out.txt\",\"w\",stdout);\n    int x,y;\n    long long w;\n    char cmd;\n    while(scanf(\"%d%d\",&n,&m)!=EOF)\n    {\n        if(n==0&&m==0)\n            break;\n        init();\n        for(int i=0; i<m; ++i)\n        {\n            cin>>cmd;\n            if(cmd=='!')\n            {\n                scanf(\"%d%d%lld\",&x,&y,&w);\n                x = Find(x);\n                y = Find(y);\n                if(x!=y)\n                {\n                    father[x]=y;//合并\n                    dist[x]=w-dist[x];\n                    //dist[y]=0;\n                }\n            }\n            else if(cmd=='?')\n            {\n                scanf(\"%d%d\",&x,&y);\n                if(Find(x)!=Find(y))\n                {\n                    printf(\"UNKNOWN\\n\");\n                    continue;\n                }\n                printf(\"%lld\\n\",dist[x]-dist[y]);\n            }\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\n#define int ll\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define PB push_back\n\nconst ll LLINF = (1LL<<60);\nconst int INF = (1LL<<30);\nconst int MOD = 1000000007;\n\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate <typename T> bool IN(T a, T b, T x) { return a<=x&&x<b; }\ntemplate<typename T> T ceil(T a, T b) { return a/b + !!(a%b); }\ntemplate<class S,class T>\nostream &operator <<(ostream& out,const pair<S,T>& a){\n  out<<'('<<a.first<<','<<a.second<<')';\n  return out;\n}\ntemplate<class T>\nostream &operator <<(ostream& out,const vector<T>& a){\n  out<<'[';\n  REP(i, a.size()) {out<<a[i];if(i!=a.size()-1)out<<',';}\n  out<<']';\n  return out;\n}\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\nclass UnionFind {\npublic:\n  const static int MAX_N = 100010;\n  int par[MAX_N];\n  int s[MAX_N];\n  UnionFind() { init(); }\n  UnionFind(int n) { init(n); }\n  void init() { for(int i=0; i<MAX_N; ++i) par[i] = i, s[i] = 1; }\n  void init(int n) { for(int i=0; i<n; ++i) par[i] = i, s[i] = 1; }\n  int find(int x) {\n    if(par[x] == x) return x;\n    return par[x] = find(par[x]);\n  }\n  void unite(int x, int y) {\n    x = find(x);\n    y = find(y);\n    if(x == y) return;\n    if(s[x] < s[y]) par[x] = y, s[y] = s[x] + s[y];\n    else par[y] = x, s[x] = s[x] + s[y];\n  }\n  bool same(int x, int y) { return find(x) == find(y);}\n};\nUnionFind uf;\n\nclass LCA {\nprivate:\n  const int n = 0;\n  const int log2_n = 0;\n  VVI par;\n  vector<vector<PII>> g;\n  VI depth, d;\n\n  // parとdを構築する\n  void dfs(int v, int p, int dist, int n_depth) {\n    par[0][v] = p; d[v] = dist; depth[v] = n_depth;\n    for (auto e : g[v]) {\n      if (e.first != p) dfs(e.first, v, dist + e.second, n_depth+1);\n    }\n  }\n\npublic:\n  LCA(int n_=1e5) :\n    n(n_), log2_n(log2(n)+1), par(log2_n, VI(n)), g(n, vector<PII>()), depth(n), d(n) {}\n\n  // u->vに重みcostの辺を張る 一方向なのに注意\n  void add_edge(int u, int v, int cost) { g[u].PB({v, cost}); }\n  // rootを根としてparとdを構築\n  void build(int root = 0) {\n    dfs(root, -1, 0, 0);\n    REP(k, log2_n-1) {\n      REP(v, n) {\n        if(par[k][v] < 0) par[k+1][v] = -1;\n        else par[k+1][v] = par[k][par[k][v]];\n      }\n    }\n  }\n\n  int get(int u, int v) {\n    if (depth[u] > depth[v]) std::swap(u, v);\n    for (int k = 0; k < log2_n; k++) {\n      if ((depth[v] - depth[u]) >> k & 1) {\n        v = par[k][v];\n      }\n    }\n    if (u == v) return u;\n    for (int k = log2_n - 1; k >= 0; k--) {\n      if (par[k][u] != par[k][v]) {\n        u = par[k][u];\n        v = par[k][v];\n      }\n    }\n    return par[0][u];\n  }\n\n  int length(int u, int v) {\n    int lca = get(u, v);\n    return d[u] - d[v];\n  }\n};\n\nsigned main(void)\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  while(true) {\n    int n, m;\n    cin >> n >> m;\n    if(!n) break;\n    LCA lca(n);\n    vector<PII> query;\n    VI ans(n);\n    int idx = 0;\n    REP(i, m) {\n      char c;\n      int a, b;\n      cin >> c >> a >> b; a--, b--;\n      if(c == '!') {\n        int w; cin >> w;\n        uf.unite(a, b);\n        lca.add_edge(a, b, -w);\n        lca.add_edge(b, a, w);\n      } else {\n        query.PB({a, b});\n        if(!uf.same(a, b)) ans[idx] = INF;\n        idx++;\n      }\n    }\n    lca.build();\n    // cout << \"a\" << endl;\n    // cout << query << endl;\n\n    REP(i, query.size()){\n      if(ans[i] == INF) continue;\n      // cout << \"i:\" << i << \" \" << query[i].first << \" \" << query[i].second << endl;\n      ans[i] = lca.length(query[i].first, query[i].second);\n    }\n\n    REP(i, query.size()) {\n      if(ans[i]==INF) cout << \"UNKNOWN\" << endl;\n      else cout << ans[i] << endl;\n    }\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//#define _GLIBCXX_DEBUG\n#include <bits/stdc++.h>\n#define rep(i, n) for(int i=0; i<n; ++i)\n#define all(v) v.begin(), v.end()\n#define rall(v) v.rbegin(), v.rend()\nusing namespace std;\nusing ll = int64_t;\nusing ld = long double;\nusing P = pair<int, int>;\nusing vs = vector<string>;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\ntemplate<class T> using PQ = priority_queue<T>;\ntemplate<class T> using PQG = priority_queue<T, vector<T>, greater<T> >;\nconst int INF = 100010001;\nconst ll LINF = (ll)INF*INF*10;\ntemplate<typename T1, typename T2>\ninline bool chmax(T1 &a, T2 b) {return a < b && (a = b, true);}\ntemplate<typename T1, typename T2>\ninline bool chmin(T1 &a, T2 b) {return a > b && (a = b, true);}\ntemplate<typename T1, typename T2>\nistream &operator>>(istream &is, pair<T1, T2> &p) { return is >> p.first >> p.second;}\ntemplate<typename T1, typename T2>\nostream &operator<<(ostream &os, const pair<T1, T2> &p) { return os << p.first << ' ' << p.second;}\n\ntemplate<class Abel>\nstruct wUnionFind {\n    vector<int> par;\n    vector<Abel> diff_weight;\n    wUnionFind(int n):par(n, -1), diff_weight(n) {}\n    int root(int x) {\n        if(par[x] < 0) return x;\n        int r = root(par[x]);\n        diff_weight[x] += diff_weight[par[x]];\n        return par[x] = r;\n    }\n    bool unite(int x, int y, Abel w) { //weight(y) - weight(x) = w となるようにする\n        w += weight(x)-weight(y);\n        x = root(x); y = root(y);\n        if(x == y) {\n            assert(diff(x, y) == w);\n            return false;\n        }\n        if(par[x] > par[y]) swap(x, y), w = -w;\n        par[x] += par[y];\n        par[y] = x;\n        diff_weight[y] = w;\n        return true;\n    }\n    bool same(int x, int y) {return root(x) == root(y);}\n    bool size(int x) {return -par[root(x)];}\n    Abel weight(int x) {\n        root(x);\n        return diff_weight[x];\n    }\n    Abel diff(int x, int y) {\n        assert(same(x, y));\n        return weight(y)-weight(x);\n    }\n};\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    int n, m;\n    cin >> n >> m;\n    while(n) {\n        wUnionFind<int> wft(n);\n        char c;\n        rep(i, m) {\n            cin >> c;\n            if(c == '!') {\n                int a, b, w;\n                cin >> a >> b >> w;\n                --a; --b;\n                wft.unite(a, b, w);\n            } else {\n                int a, b;\n                cin >> a >> b;\n                --a; --b;\n                if(wft.same(a, b)) {\n                    cout << wft.diff(a, b) << '\\n';\n                } else {\n                    cout << \"UNKNOWN\" << '\\n';\n                }\n            }\n        }\n        cin >> n >> m;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define PI       3.1415926535897932384626433832795028841971\n#define INF 1000000000\n#define EPS      1e-10\n#define MOD      1000000\nusing namespace std;\ntypedef long long ll;\ntypedef pair<double,double> P;\ntypedef pair<double,P> PQ;\n\nstruct Q{\n    int time,a, b;\n};\n\nstruct edge{\n    int time, to, w;\n};\n\nint n, m;\nint bss[100000];\nint par[100000];\nint rnk[100000];\nint num[100000];\nbool saw[100000];\nvector<edge> e[100000];\nvector<Q> q;\nint up[20][100000];\n\nvoid dfs(int v, int bos){\n    saw[v] = true;\n    rep(i,e[v].size()){\n        edge E = e[v][i];\n        if(saw[E.to]) continue;\n        up[0][E.to] = E.time;\n        rnk[E.to] = rnk[v]+1;\n        num[E.to] = num[v]+E.w;\n        bss[E.to] = bos;\n        par[E.to] = v;\n        dfs(E.to,bos);\n    }\n}\n\nint main(){\n    while(cin >> n >> m){\n        if(n == 0 && m == 0) break;\n        memset(bss,0,sizeof(bss));\n        memset(rnk,0,sizeof(rnk));\n        memset(num,0,sizeof(num));\n        memset(saw,0,sizeof(saw));\n        rep(i,n) e[i].clear();\n        q.clear();\n        memset(up,0,sizeof(up));\n        rep(i,m){\n            char hoge;\n            int a, b, w;\n            cin >> hoge;\n            if(hoge == '!'){\n                cin >> a >> b >> w;\n                a--; b--;\n                e[a].push_back((edge){i,b,w});\n                e[b].push_back((edge){i,a,-w});\n            } else{\n                cin >> a >> b;\n                a--; b--;\n                q.push_back((Q){i,a,b});\n            }\n        }\n        rep(i,n) par[i] = i;\n        rep(i,n){\n            if(saw[i]) continue;\n            dfs(i,i);\n        }\n        rep(i,q.size()){\n            Q p = q[i];\n            bool done = false;\n            if(bss[p.a] != bss[p.b]){\n                cout << \"UNKNOWN\" << endl;\n                continue;\n            }\n            int ans = num[p.b]-num[p.a];\n            while(rnk[p.a] != rnk[p.b]){\n                if(rnk[p.a] > rnk[p.b]){\n                    if(up[0][p.a] > p.time){\n                        cout << \"UNKNOWN\" << endl;\n                        done = true;\n                        break;\n                    }\n                    p.a = par[p.a];\n                } else{\n                    if(up[0][p.b] > p.time){\n                        cout << \"UNKNOWN\" << endl;\n                        done = true;\n                        break;\n                    }\n                    p.b = par[p.b];\n                }\n            }\n            if(done) continue;\n            while(p.a != p.b){\n                if(up[0][p.a] > p.time || up[0][p.b] > p.time){\n                    cout << \"UNKNOWN\" << endl;\n                    done = true;\n                    break;\n                }\n                p.a = par[p.a];\n                p.b = par[p.b];\n            }\n            if(done) continue;\n            cout << ans << endl;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define llint long long\n#define inf (int)1e18\n\nusing namespace std;\n\nint N, M;\n\nint parent[100005];\nllint difW[100005];\n\nvoid init(){\n\tfor(int i = 1; i <= N; i++){\n\t\tparent[i] = i;\n\t\tdifW[i] = 0;\n\t}\n}\n\nint root(int i){\n\tif(parent[i] == i) return i;\n\tint pre_parent = parent[i];\n\tparent[i] = root(parent[i]);\n\tdifW[i] += difW[pre_parent];\n\treturn parent[i];\n}\n\nbool same(int i, int j){\n\treturn root(i) == root(j);\n}\n\nvoid unite(int i, int j){\n\tint root_i = root(i);\n\tint root_j = root(j);\n\tif(root_i == root_j) return;\n\tparent[root_j] = root_i;\n}\n\nint difRoot(int i){\n\tif(root(i) == i) return 0;\n\treturn difRoot(parent[i]) + difW[i];\n}\n\nint main(void)\n{\n\twhile(1){\n\t\tcin >> N >> M;\n\t\tif(N == 0 && M == 0) break;\n\t\tinit();\n\t\t\n\t\tchar c; int a, b, w;\n\t\tfor(int i = 0; i < M; i++){\n\t\t\tcin >> c;\n\t\t\tif(c == '?'){\n\t\t\t\tcin >> a >> b;\n\t\t\t\tif(!same(a, b)) cout << \"UNKNOWN\" << endl;\n\t\t\t\telse cout << difRoot(b) - difRoot(a) << endl;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tcin >> a >> b >> w;\n\t\t\t\tif(!same(a, b)){\n\t\t\t\t\tint root_b = root(b);\n\t\t\t\t\tint dif = difRoot(a) - difRoot(b) + w;\n\t\t\t\t\tunite(a, b);\n\t\t\t\t\tdifW[root_b] = dif;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcount\n\n#define INF 1e16\n#define mod 1000000007\n\nll n,m;\nvector<ll> par,sz,dep;\nvector<vector<ll> > child;\n\nll find(ll x){\n  if(par[x]==-1)return x;\n  else return find(par[x]);\n}\n\nvoid rec(ll v,ll pre,ll add){\n  dep[v]+=add;\n  for(ll nv : child[v]){\n    if(nv==v)continue;\n    rec(nv,v,add);\n  }\n}\n\nint main(){\n  while(1){\n    cin>>n>>m;\n    if(n==0)break;\n    par.resize(n);\n    sz.resize(n);\n    dep.resize(n);\n    child.resize(n);\n    rep(i,n){\n      par[i]=-1;\n      sz[i]=1;\n      dep[i]=0;\n      child[i].clear();\n    }\n    rep(i,m){\n      char t;\n      cin>>t;\n      if(t=='!'){\n        ll a,b,c;\n        cin>>a>>b>>c;\n        a--;b--;\n        ll pa=find(a);\n        ll pb=find(b);\n        if(pa==pb)continue;\n        if(sz[pa]<sz[pb]){\n          swap(pa,pb);\n          swap(a,b);\n          c=-c;\n        }\n        par[pb]=pa;\n        ll x=dep[a]-dep[b]+c;\n        rec(pb,pa,x);\n        child[pa].push_back(pb);\n        sz[pa]+=sz[pb];\n      }else{ \n        ll a,b;\n        cin>>a>>b;\n        a--;b--;\n        ll pa=find(a);\n        ll pb=find(b);\n        if(pa!=pb){\n          cout<<\"UNKNOWN\"<<endl;\n        }else{\n          cout<<-dep[a]+dep[b]<<endl;\n        }\n      }\n    }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<stdio.h>\n\nusing namespace std;\nint p[100000];\nint rank[100000];\nint weight[100000];\n\n  void makeSet(int x){\n    p[x]=x;\n    rank[x]=0;\n    weight[x]=0;\n  }\n  bool same(int x,int y){\n    return findSet(x)==findSet(y);\n  }\n  void unite(int x,int y,int w){\n    weight[x]=w;\n    link(x,y);\n  }\n  void link(int x,int y){   \n    p[x]=y;\n    if(rank[x]>=rank[y]){  \n      rank[y]=rank[x]+1;\n    }\n  }\n  int findSet(int x){\n    if(x==p[x]){\n      return x;\n    }else{\n      return findSet(p[x]);\n    }\n  }\n  int depth(int x){\n    int ans=0;\n    ans+=weight[x];\n    while(x!=p[x]){\n      ans+=weight[p[x]];\n      x=p[x];\n    }\n    return ans;\n  }\n\nint main(){\n  int n,m;\n  while(scanf(\"%d%d\",&n,&m)){\n    if(!n&&!m){\n      break;\n    }else{\n      char query[5];\n     for(int I=0;i<n;i++){\nmakeSet(i);\n}\n      for(int i=0;i<m;i++){\n        scanf(\"%s\",query);\n        if(query[0]=='!'){\n          int a,b,w;\n          scanf(\"%d%d%d\",&a,&b,&w);\n          ds.unite(a,b,w);\n        }else{\n          int c,d;\n          scanf(\"%d%d\",&c,&d);\n          if(!ds.same(c,d)){\n            printf(\"UNKNOWN\\n\");\n          }else{\n            printf(\"%d\\n\",ds.depth(c)-ds.depth(d));\n          }\n        }\n      }\n    }\n  }\n  return 0;\n}\n      "
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int M = 1000000007;\n\nvector<int> grp, val;\nvector<vector<int>> lis;\nvoid init(int n) {\n    grp.resize(n);\n    val.resize(n, 0);\n    lis.resize(n);\n    for (int i = 0; i < n; ++i) {\n        grp[i] = i;\n        lis[i].push_back(i);\n    }\n}\nvoid merge(int p, int q, int w) {\n    if (grp[p] == grp[q]) return;\n    if (lis[grp[p]].size() < lis[grp[q]].size()) {\n        merge(q, p, -w);\n        return;\n    }\n    int d = w + val[p] - val[q];\n    int g = grp[q];\n    for (int i : lis[g]) {\n        grp[i] = grp[p];\n        val[i] += d;\n        lis[grp[p]].emplace_back(i);\n    }\n    lis[g].clear();\n}\n\nint main() {\n    while (1) {\n        int n, m;\n        cin >> n >> m;\n        if (!n) return 0;\n        init(n);\n        for (int i = 0; i < m; ++i) {\n            char c;\n            cin >> c;\n            if (c == '!') {\n                int p, q, w;\n                cin >> p >> q >> w;\n                merge(p - 1, q - 1, w);\n            }\n            else {\n                int p, q;\n                cin >> p >> q;\n                --p;\n                --q;\n                if (grp[p] != grp[q])\n                    puts(\"UNKNOWN\");\n                else\n                    printf(\"%d\\n\", val[q] - val[p]);\n            }\n        }\n        for (int i = 0; i < n; ++i)\n            lis[i].clear();\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef double D;\ntypedef pair<ll,ll> P;\n#define M 1000000007\n#define F first\n#define S second\n#define PB push_back\n#define INF 100000000000000000\nll n,m,par[100005],dw[100005];\nll find(ll x){\n\tif(par[x]==x)return x;\n\tll r=find(par[x]);\n\tdw[x]+=dw[par[x]];\n\treturn par[x]=r;\n}\nbool same(ll x,ll y){\n\treturn find(x)==find(y);\n}\nvoid unit(ll x,ll y,ll w){\n\tfind(x),find(y);\n\tw+=dw[x],w-=dw[y];\n\tx=find(x),y=find(y);\n\tif(x==y)return;\n\tpar[y]=x;\n\tdw[y]+=w;\n}\nll diff(ll x,ll y){\n\tfind(x),find(y);\n\treturn dw[y]-dw[x];\n}\nint main(void){\n\twhile(1){\t\n\t\tscanf(\"%lld%lld\",&n,&m);\n\t\tif(n==0&&m==0)return 0;\n\t\tfor(int i=0;i<n;i++)par[i]=i,dw[i]=0;\n\t\twhile(m--){\n\t\t\tchar c;\n\t\t\tscanf(\" %c\",&c);\n\t\t\tif(c=='!'){\n\t\t\t\tll a,b,w;\n\t\t\t\tscanf(\"%lld%lld%lld\",&a,&b,&w);\n\t\t\t\ta--,b--;\n\t\t\t\tunit(a,b,w);\n\t\t\t}else{\n\t\t\t\tll a,b;\n\t\t\t\tscanf(\"%lld%lld\",&a,&b);\n\t\t\t\ta--,b--;\n\t\t\t\tif(!same(a,b))printf(\"UNKNOWN\\n\");\n\t\t\t\telse printf(\"%lld\\n\",diff(a,b));\n\t\t\t}\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define EACH(i,a) for (auto& i : a)\n#define FOR(i,a,b) for(int i=(int)a;i<(int)b;++i)\n#define RFOR(i,a,b) for(int i=(int)b-1;i>=(int)a;--i)\n#define REP(i,n) FOR(i,0,n)\n#define RREP(i,n) RFOR(i,0,n)\n#define ALL(a) (a).begin(),(a).end()\n#define debug(x) cerr << #x << \":\" << x << endl;\n#define OK(ok) cout << (ok ? \"Yes\" : \"No\") << endl;\ntypedef long long ll;\n\nvoid CINT(){}\ntemplate <class Head,class... Tail>\nvoid CINT(Head&& head,Tail&&... tail) {\n  cin >> head; CINT(move(tail)...);\n}\n#define CIN(...) int __VA_ARGS__;CINT(__VA_ARGS__)\n#define LCIN(...) ll __VA_ARGS__;CINT(__VA_ARGS__)\n#define SCIN(...) string __VA_ARGS__;CINT(__VA_ARGS__)\n\nconst int INF = 1e9 + 1;\nconst int MOD = 1e9 + 7;\nconst int MAX_N = 1e5 + 1;\n\n/*\ntemplate< class Abel > struct WeightedUnionFind {\n  vector< int > par;\n  vector< int > rank;\n  vector< Abel > diff_weight;\n\n  WeightedUnionFind(int n = 1, Abel SUM_UNITY = 0) {\n    init(n, SUM_UNITY);\n  }\n\n  void init(int n = 1, Abel SUM_UNITY = 0) {\n    par.resize(n); rank.resize(n); diff_weight.resize(n);\n    REP(i, n) {\n      par[i] = i;\n      rank[i] = 0;\n      diff_weight[i] = SUM_UNITY;\n    }\n  }\n\n  int root(int x) {\n    if (par[x] == x) {\n      // 根がそれ自身だった時にそれを返す\n      return x;\n    } else {\n      int r = root(par[x]);\n      diff_weight[x] += diff_weight[par[x]];\n      return par[x] = r;\n    }\n  }\n\n  bool issame(int x, int y) {\n    return root(x) == root(y);\n  }\n\n  Abel weight(int x) {\n    // 経路圧縮\n    root(x);\n    return diff_weight[x];\n  }\n\n  Abel diff(int x, int y) {\n    return weight(y) - weight(x);\n  }\n\n  // xにyをつなぐ\n  // weight(y) - weight(x) = wとなるようにmergeする\n  bool merge(int x, int y, Abel w) {\n    // xとyそれぞれについて、rootとの重み差分を補正\n    w += weight(x); w-= weight(y);\n    x = root(x); y = root(y);\n    if (x == y) {\n      // 既に連結である\n      return false;\n    }\n    if (rank[x] < rank[y]) {\n      // xにyを連結する設定\n      swap(x, y);\n      w *= -1;\n    }\n    if (rank[x] == rank[y]) {\n      // xとyが同じ時、xの根にyの根を連結する\n      ++rank[x];\n    }\n    par[y] = x;\n\n    diff_weight[y] = w;\n    return true;\n  }\n};\n*/\n\n\ntemplate< class Abel > struct WeightedUnionFind {\n  vector< int > par;\n  vector< Abel > diff_weight;\n  WeightedUnionFind(int n = 1, Abel SUM_UNITY = 0) {\n    init(n, SUM_UNITY);\n  }\n\n  void init(int n, Abel SUM_UNITY = 0) {\n    par.resize(n); diff_weight.resize(n);\n    for(int i = 0; i < n; i++) {\n      par[i] = -1;\n      diff_weight[i] = SUM_UNITY;\n    }\n  }\n  \n  int root(int n) {\n    if (par[n] < 0) return n;\n    diff_weight[n] += diff_weight[par[n]];\n    return par[n] = root(par[n]);\n  }\n\n  Abel weight(int n) {\n    root(n);\n    return diff_weight[n];\n  }\n\n  Abel diff(int x, int y) {\n    return weight(y) - weight(x);\n  }\n\n  bool issame(int x, int y) {\n    return root(x) == root(y);\n  }\n  \n  bool unite(int x, int y, Abel w) {\n    w += weight(x); w -= weight(y);\n    x = root(x); y = root(y);\n    if (x == y) return false;\n    if (par[x] > par[y]) {\n      swap(x, y);\n      w = -w;\n    }\n    par[x] += par[y];\n    par[y] = x;\n    diff_weight[y] = w;\n    return true;\n  }\n};\n\n\nint main()\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  int N, M;\n  while (cin >> N >> M) {\n              if (N == 0) break;\n              WeightedUnionFind<int> uf(N);\n              for (int i = 0; i < M; ++i) {\n                     char c; int a, b, w;\n                     cin >> c;\n                     if (c == '!') {\n                           cin >> a >> b >> w; --a, --b;\n                           uf.unite(a, b, w);\n                     }\n                     else {\n                           cin >> a >> b; --a, --b;\n                           if (!uf.issame(a, b)) puts(\"UNKNOWN\");\n                           else cout << uf.diff(a, b) << endl;\n                     }\n              }\n       }\n\n  return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define f first\n#define s second\n#define mp make_pair\n#define inf 1<<30\n#define MAX 1000010\nusing namespace std;\n\nlong long p[MAX],w[MAX];\n\npair<int,int> find(int a){\n  pair<int,int> pii;\n  if(p[a]==a){\n    pii.f=a;pii.s=0;\n    return pii;\n  }\n  pii=find(p[a]);\n  pii.s+=w[a];\n  p[a]=pii.f;\n  w[a]=pii.s;\n  return pii;\n}\n\nint main()\n{\n  int n,q,a,b,d;\n  char c;\n\n  while(cin>>n>>q && n ){\n\n    for(int i=0;i<n;i++){\n      p[i]=i;\n      w[i]=0;\n    }\n\n    for(int i=0;i<q;i++){\n      cin>>c;\n      if(c=='!'){\n\tcin>>a>>b>>d;\n\ta--;b--;\n\tpair<int,int> pa=find(a),pb=find(b);\n\tp[pa.f]=pb.f;\n\tw[pa.f]=d-pa.s;\n\tp[a]=pb.f;\n\tw[a]=pb.s+d;\n      }\n      else {\n\tcin>>a>>b;\n\ta--;b--;\n\tpair<int,int> pa=find(a),pb=find(b);\n\tif(pa.f!=pb.f)cout<<\"UNKNOWM\"<<endl;\n\telse {\n\t  p[a]=pa.f;\n\t  w[a]=pa.s;\n\t  p[b]=pb.f;\n\t  w[b]=pb.s;\n\t  cout<<pa.s-pb.s<<endl;\n\t}\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\nlong long dist[1 << 18];\nlong long group[1 << 18]; char q;\nlong long n, Q, a, b, c;\nvector<long long>gr[1 << 18];\nint main() {\n\twhile (true) {\n\t\tfor (int i = 0; i < (1 << 18); i++) {\n\t\t\tdist[i] = 0; group[i] = i; gr[i].clear(); gr[i].push_back(i);\n\t\t}\n\t\tcin >> n >> Q; if (n == 0 && Q == 0)break;\n\t\tfor (int i = 0; i < Q; i++) {\n\t\t\tcin >> q;\n\t\t\tif (q == '?') {\n\t\t\t\tcin >> a >> b;\n\t\t\t\tif (group[a] != group[b])cout << \"UNKNOWN\" << endl;\n\t\t\t\telse cout << dist[b] - dist[a] << endl;\n\t\t\t}\n\t\t\tif (q == '!') {\n\t\t\t\tcin >> a >> b >> c;\n\t\t\t\tlong long L = group[a], M = group[b];\n\t\t\t\tif (group[a] != group[b] && gr[L].size() <= gr[M].size()) {\n\t\t\t\t\tlong long K = dist[a] + c - dist[b];\n\t\t\t\t\tfor (int j = 0; j < gr[M].size(); j++) {\n\t\t\t\t\t\tgroup[gr[M][j]] = L;\n\t\t\t\t\t\tgr[L].push_back(gr[M][j]);\n\t\t\t\t\t\tdist[gr[M][j]] += K;\n\t\t\t\t\t}\n\t\t\t\t\tgr[M].clear();\n\t\t\t\t}\n\t\t\t\telse if (group[a] != group[b]) {\n\t\t\t\t\tlong long K = dist[b] - c - dist[a];\n\t\t\t\t\tfor (int j = 0; j < gr[L].size(); j++) {\n\t\t\t\t\t\tgroup[gr[L][j]] = M;\n\t\t\t\t\t\tgr[M].push_back(gr[L][j]);\n\t\t\t\t\t\tdist[gr[L][j]] += K;\n\t\t\t\t\t}\n\t\t\t\t\tgr[L].clear();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// 問題名: Never Wait for Weights\n// URL: http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1330&lang=jp\n// 所要時間: 30分\n// --感想--\n// Disjoint Setはネットから拾ったものをほぼそのまま使っていたが、この問題を特にあたって一から書き直す必要が\n// あったため、構造体への理解が深まって良かった。\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n// root: 代表元を取得\n// unite: 重い代表元を軽い代表元の下につける\n// distance: 重さの差を取得\nstruct UnionFind\n{\n    vector<int> par, dist;\n\n    UnionFind(int sz)\n    {\n        par.assign(sz, -1);\n        dist.assign(sz, 0); \n    }\n\n    int root(int k)\n    {\n        if (par[k] == -1)\n            return (k);\n        int r = root(par[k]);\n        dist[k] += dist[par[k]];\n        return (par[k] = r);\n    }\n\n    void unite(int x, int y, int w)\n    {\n        int rx = root(x), ry = root(y);\n        if (rx == ry)\n            return;\n        if(dist[x] + w > dist[y]){\n            par[ry] = rx;\n            dist[ry] = dist[x] + w - dist[y];\n        }\n        else{\n            par[rx] = ry;\n            dist[rx] = dist[y] - dist[x] - w;\n        }\n    }    \n\n    int distance(int x, int y)\n    {\n        if(root(x) == root(y))\n            return (dist[y] - dist[x]);\n        else\n            return 10000000;\n    }\n\n};\n\nint main(){\n    while(1){\n        int n, m;\n        cin >> n >> m;\n        if(n == 0)\n            break;\n        UnionFind uf(n + 1);\n        for (int i = 0; i < m; i++){\n            char s; \n            cin >> s;\n            if(s=='!'){\n                int a, b, w;\n                cin >> a >> b >> w;\n                uf.unite(a, b, w);\n            }\n            else{\n                int a, b;\n                cin >> a >> b;\n                int d = uf.distance(a, b);\n                if(d > 1000000)\n                    cout << \"UNKNOWN\" << endl;\n                else\n                    cout << d << endl;\n            }\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <string>\nusing namespace std;\n\nstruct QuickFind {\n    int N;\n    vector<int> i2g;\n    vector< vector<int> > g2i;\n    vector<long long int> weight;\n\n    QuickFind(int N_) {\n        N = N_;\n        i2g.resize(N);\n        g2i.resize(N);\n        weight.resize(N);\n\n        for(int i=0; i<N; i++) {\n            i2g[i] = i;\n            g2i[i] = vector<int>{i};\n        }\n    }\n\n    bool same(int u, int v) {\n        return i2g[u] == i2g[v];\n    }\n\n    // v の方が w だけ大きい\n    void unite(int u, int v, int w) {\n        int ru = i2g[u], rv = i2g[v];\n        if(ru == rv) return;\n\n        if(g2i[rv].size() > g2i[ru].size()) {\n            swap(ru, rv);\n            swap(u, v);\n            w = -w;\n        }\n\n        long long int prev = weight[v];\n        weight[v] = weight[u] + w;\n\n        for(auto e : g2i[rv]) {\n            i2g[e] = ru;\n            long long int diff = weight[e] - prev;\n            if(e != v) weight[e] = weight[v] + diff;\n        }\n\n        for(auto e : g2i[rv]) {\n            g2i[ru].push_back(e);\n        }\n        g2i[rv].clear();\n    }\n\n    long long int query(int u, int v) {\n        assert(same(u, v));\n        return weight[v] - weight[u];\n    }\n};\n\nint N, Q;\n\nint main() {\n    while(cin >> N >> Q, N || Q) {\n        QuickFind qf(N);\n        for(int i=0; i<Q; i++) {\n            char query; cin >> query;\n            if(query == '!') {\n                int u, v, w; cin >> u >> v >> w;\n                u--; v--;\n                qf.unite(u, v, w);\n            }\n            else {\n                int u, v; cin >> u >> v;\n                u--; v--;\n                if(qf.same(u, v)) {\n                    cout << qf.query(u, v) << endl;\n                }\n                else {\n                    cout << \"UNKNOWN\" << endl;\n                }\n            }\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "class in{struct It{int it;const bool rev;explicit constexpr It(int it_, bool rev=false):it(it_),rev(rev){}int operator*(){return it;}bool operator!=(It& r){return it!=r.it;}void operator++(){rev?--it:++it;}};const It i,n;public:explicit constexpr in(int n):i(0),n(n<0?0:n){}explicit constexpr in(int i,int n):i(i,n<i),n(n){}const It& begin(){return i;}const It& end(){return n;}};\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nusing i64 = long long;\n\nstruct UnionFind {\n    vector<int> data;\n    vector<i64> rootd;//rootd[i] : dist from node[i] to node[root(i)]\n    explicit UnionFind() {}\n    void init(int N) {\n        data.assign(N, -1);\n        rootd.assign(N, 0);\n    }\n    void unite(int x_, int y_, i64 weight) {\n        int x = root(x_), y = root(y_);\n        if(x != y){\n            data[x] += data[y];\n            data[y] = x;\n            rootd[y] = weight - rootd[y_] + rootd[x_];\n        }\n    }\n    int root(int x) {\n        vector<int> memo;\n        while(data[x] >= 0) {\n            memo.emplace_back(x);\n            x = data[x];\n        }\n        int res = x;\n        for(int i = memo.size() - 1; i >= 0; --i) {\n            int k = memo[i];\n            rootd[k] += rootd[data[k]];\n            data[k] = res;\n        }\n        return res;\n    }\n    i64 dist(int a, int b) { return rootd[b] - rootd[a];}\n    bool same(int a, int b) { return root(a) == root(b);}\n};\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n, m;\n    UnionFind uf;\n    while(cin >> n >> m && n) {\n        uf.init(n);\n        char q; int a, b; i64 w;\n        for(int _ : in(m)) {\n            cin >> q >> a >> b;\n            --a; --b;\n            if(q == '?') {\n                if(uf.same(a, b))\n                    cout << uf.dist(a, b) << '\\n';\n                else\n                    cout << \"UNKNOWN\" << '\\n';;\n            }\n            else {\n                cin >> w;\n                uf.unite(a, b, w);\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define f first\n#define s second\n#define mp make_pair\n#define inf 1<<30\n#define MAX 100001\nusing namespace std;\n\nint p[MAX],w[MAX];\nmap<pair<int,int>,int> M;\n\npair<int,int> find(int a){\n  pair<int,int> pii;\n  if(p[a]==a){\n    pii.f=a;pii.s=0;\n    return pii;\n  }\n  pii=find(p[a]);\n  pii.s+=w[a];\n  p[a]=pii.f;\n  w[a]=pii.s;\n  return pii;\n}\n\nint main()\n{\n  int n,q,a,b,d;\n  char c;\n\n  while(cin>>n>>q && n ){\n    for(int i=0;i<n;i++){\n      p[i]=i;\n      w[i]=0;\n    }\n    M.clear();\n\n    for(int i=0;i<q;i++){\n      cin>>c;\n      if(c=='!'){\n\tcin>>a>>b>>d;\n\ta--;b--;\n\tp[a]=b;\n\tw[a]=d;\n      }\n      else {\n\tcin>>a>>b;\n\ta--;b--;\n\tpair<int,int> pa=find(a),pb=find(b);\n\tif(pa.f!=pb.f)cout<<\"UNKNOWM\"<<endl;\n\telse {\n\t  p[a]=pa.f;\n\t  w[a]=pa.s;\n\t  p[b]=pb.f;\n\t  w[b]=pb.s;\n\t  cout<<pa.s-pb.s<<endl;\n\t}\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define MAX_N 100005\nusing namespace std;\ntypedef pair<int,int> P;\nP par[MAX_N];\n\nvoid init(int n){\n  for(int i=0;i<n;i++)\n    par[i]=P(i,0);\n}\n\nP find(int x){\n  if(par[x].first==x)return P(x,0);\n  P r=find(par[x].first);\n  return par[x]=P(r.first,par[x].second+r.second);\n}\n\nvoid unite(int x,int y,int cost){\n  P r1=find(x);\n  P r2=find(y);\n  if(r1.first==r2.first)return;\n  par[r1.first]=P(r2.first,r2.second-r1.second+cost);\n}\n\nbool same(int x,int y){return find(x).first==find(y).first;}\n\nint n,m,a,b,cost;\nchar c;\n\nint main(){\n  while(1){\n    cin>>n>>m;\n    if(!n&&!m)break;\n    init(n);\n    rep(i,m){\n      cin>>c>>a>>b;\n      if(c=='!'){\n\tcin>>cost;\n\tunite(b-1,a-1,cost);\n      }else{\n\tif(!same(a-1,b-1))cout<<\"UNKNOWN\"<<endl;\n\telse cout<<find(b-1).second-find(a-1).second<<endl;\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include <iostream>\n#include <math.h>\n#include <numeric>\n#include <vector>\n#include <map>\n#include <functional>\n#include <stdio.h>\n#include <array>\n#include <algorithm>\n#include <string>\n#include <string.h>\n#include <assert.h>\n#include <stdio.h>\n#include <queue>\n#include<iomanip>\n#include<bitset>\n#include<stack>\n#include<set>\n#include<limits>\n#include <complex>\n#include<cstdlib>\nusing namespace std;\n\nstruct UnionFind {\n\tvector<int> data;\n\tUnionFind(int size) : data(size, -1) { }\n\tbool unionSet(int x, int y) {\n\t\tx = root(x); y = root(y);\n\t\tif (x != y) {\n\t\t\tif (data[y] < data[x]) swap(x, y);\n\t\t\tdata[x] += data[y]; data[y] = x;\n\t\t}\n\t\treturn x != y;\n\t}\n\tbool findSet(int x, int y) {\n\t\treturn root(x) == root(y);\n\t}\n\tint root(int x) {\n\t\treturn data[x] < 0 ? x : data[x] = root(data[x]);\n\t}\n\tint size(int x) {\n\t\treturn -data[root(x)];\n\t}\n};\nstruct aUnionFind {\n\tvector<pair<int, int>> data;\n\taUnionFind(int size) : data(size, make_pair(-1, 0)) { }\n\tbool unionSet(int x, int y, int w) {\n\t\tint fx(x), fy(y);\n\t\tx = root(x).first; y = root(y).first;\n\t\tif (x != y) {\n\t\t\tdata[x].first += data[y].first; data[y].first = x;\n\t\t\tdata[y].second =-data[fy].second - w + data[fx].second;\n\t\t}\n\t\treturn x != y;\n\t}\n\tbool findSet(int x, int y) {\n\t\treturn root(x) == root(y);\n\t}\n\tpair<int, int> root(int x) {\n\t\tif (data[x].first < 0) {\n\t\t\treturn make_pair(x, 0);\n\t\t}\n\t\telse {\n\t\t\tpair<int, int>ndata;\n\t\t\tndata.first = root(data[x].first).first;\n\t\t\tndata.second =data[x].second+ root(data[x].first).second;\n\t\t\treturn data[x]=ndata;\n\t\t}\n\t}\n\tint size(int x) {\n\t\treturn -data[root(x).first].first;\n\t}\n};\n\n\n\nint main() {\n\twhile (1) {\n\t\tint N, M; cin >> N >> M;\n\t\tif (!N)break;\n\t\tvector<pair<int,int>>weis(N,make_pair(-1,-1));\n\t\taUnionFind uf(N);\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\tchar c; cin >> c;\n\t\t\tif (c == '!') {\n\t\t\t\tint a, b, w; cin >> a >> b >> w;\n\t\t\t\ta--; b--;\n\t\t\t\tuf.unionSet(a, b,w);\n\t\t\t\t\n\t\t\t\t\n\t\t\t}\n\t\t\telse {\n\t\t\t\tint a, b; cin >> a >> b;\n\t\t\t\ta--; b--;\n\t\t\t\tif (uf.root(a).first == uf.root(b).first) {\n\t\t\t\t\tint aa=uf.root(a).second - uf.root(b).second;\n\t\t\t\t\tcout << aa << endl;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tcout << \"UNKNOWN\" << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <cstdio>\nusing namespace std;\n\ntemplate<class Abel> struct UnionFind {\n    vector<int> par;\n    vector<int> rank;\n    vector<Abel> diff_weight;\n\n    UnionFind(int n = 1, Abel SUM_UNITY = 0) {\n        init(n, SUM_UNITY);\n    }\n\n    void init(int n = 1, Abel SUM_UNITY = 0) {\n        par.resize(n); rank.resize(n); diff_weight.resize(n);\n        for (int i = 0; i < n; ++i) par[i] = i, rank[i] = 0, diff_weight[i] = SUM_UNITY;\n    }\n\n    int root(int x) {\n        if (par[x] == x) {\n            return x;\n        }\n        else {\n            int r = root(par[x]);\n            diff_weight[x] += diff_weight[par[x]];\n            return par[x] = r;\n        }\n    }\n\n    Abel weight(int x) {\n        root(x);\n        return diff_weight[x];\n    }\n\n    bool issame(int x, int y) {\n        return root(x) == root(y);\n    }\n\n    bool merge(int x, int y, Abel w) {\n        w += weight(x); w -= weight(y);\n        x = root(x); y = root(y);\n        if (x == y) return false;\n        if (rank[x] < rank[y]) swap(x, y), w = -w;\n        if (rank[x] == rank[y]) ++rank[x];\n        par[y] = x;\n        diff_weight[y] = w;\n        return true;\n    }\n\n    Abel diff(int x, int y) {\n        return weight(y) - weight(x);\n    }\n};\n\nint main(){\n    int N, M;\n\n    while(cin >> N >> M){\n        if(N ==0) break;\n        UnionFind<int> UF(N);\n        for(int i=0; i<M; ++i){\n            char sign;\n            int l, r, w;\n            cin >> sign;\n            if(sign=='?'){\n                cin >> l >> r;\n                --l, --r;\n                if(!UF.issame(l, r)){\n                    puts(\"UNKNOWN\");\n                }else{\n                    cout << UF.diff(l, r) << endl;\n                }\n            }else{\n                cin >> l >> r >> w;\n                --l, --r;\n                UF.merge(l, r, w);\n            }\n        }\n    }    \n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define f first\n#define s second\n#define mp make_pair\n#define inf 1<<30\n#define MAX 1000010\nusing namespace std;\n\nlong long p[MAX],w[MAX];\n\npair<int,int> find(int a){\n  if(p[a]==a)return mp(a,0);\n  pair<int,int> pii=find(p[a]);\n  pii.s+=w[a];\n  p[a]=pii.f;\n  w[a]=pii.s;\n  return pii;\n}\n\nvoid unit(int a,int b,int d){\n  pair<int,int> pa=find(a),pb=find(b);\n  if(pa.f==pb.f)return;\n  p[pa.f]=b;\n  w[pa.f]=d-w[a]+w[b];\n}\n\nint main()\n{\n  int n,q,a,b,d;\n  char c;\n\n  while(cin>>n>>q && n ){\n\n    for(int i=0;i<n;i++){\n      p[i]=i;\n      w[i]=0;\n    }\n\n    for(int i=0;i<q;i++){\n      cin>>c;\n      if(c=='!'){\n\tcin>>a>>b>>d;\n\ta--;b--;\n        unit(a,b,d);\n      }\n      else {\n\tcin>>a>>b;\n\ta--;b--;\n\tpair<int,int> pa=find(a),pb=find(b);\n\tif(pa.f!=pb.f)cout<<\"UNKNOWM\"<<endl;\n\telse cout<<pa.s-pb.s<<endl;\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define INF 100000000\n\nclass weightedUnionFind{\npublic:\n  vector<int> par; // 親の番号\n  vector<int> ws; // 親との重みの差\n\n  weightedUnionFind(int n){\n    par = vector<int>(n);\n    ws = vector<int>(n);\n    rep(i,n)par[i] = -1;\n  }\n\n  int find(int x){\n    if(par[x]<0) return x;\n    else {\n      int parent = find(par[x]);\n      ws[x] += ws[par[x]];\n      return par[x] = parent;\n    }\n  }\n\n  int weight(int x){\n    int dummy = find(x);\n    return ws[x];\n  }\n\n  bool unite(int x, int y, int w){\n    int ww = w + weight(x);\n    ww -= weight(y);\n    x = find(x);\n    y = find(y);\n\n    if(x != y){\n      if(par[y] < par[x]){\n        swap(x,y);\n        ww = -ww;\n      }\n      par[x] += par[y];\n      par[y] = x;\n      ws[y] = ww;\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  bool same(int x, int y){\n    return find(x) == find(y);\n  }\n\n  int diff(int x, int y){\n    if(!same(x,y)) return INF;\n    return weight(y) - weight(x);\n  }\n};\n\nint main(){\n\n  while(1){\n    int n,m;\n    cin >> n >> m;\n    if(!n)break;\n    weightedUnionFind wuf(n);\n    rep(i,m){\n      char sign;\n      cin >> sign;\n      if(sign == '!'){\n        int a,b,w;\n        cin >> a >> b >> w;\n        a--;b--;\n        wuf.unite(a,b,w);\n      } else {\n        int a,b;\n        cin >> a >> b;\n        a--;b--;\n        int w = wuf.diff(a,b);\n        if(w==INF)cout << \"UNKNOWN\" << endl;\n        else {cout << w << endl;}\n      }\n    }\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\nconst int INF = 1000000000;\n#define REP(i,s,n) for(int i=(int)(s);i<(int)(n);i++)\n#define rep(i,n) REP(i, 0, n)\nstruct UnionFind {\n    vector<int> data;\n    vector<ll> rootd;//rootd[i] : dist from node[i] to node[root(i)]\n    UnionFind(int N) : data(N, -1), rootd(N, 0) {}\n    void unite(int x_, int y_, ll weight) {\n        int x = root(x_), y = root(y_);\n        if(x != y){\n            data[x] += data[y];\n            data[y] = x;\n            rootd[y] = weight;\n        }\n    }\n    int root(int x_) {\n        int x = x_;\n        vector<int> memo;\n        while(data[x] >= 0) {\n            memo.push_back(x);\n            x = data[x];\n        }\n        int res = x;\n        for(int k : memo) {\n            rootd[k] += rootd[data[k]];\n            data[k] = res;\n        }\n        return res;\n    }\n    ll dist(int a, int b) { return rootd[b] - rootd[a];}\n    bool same(int a, int b) { return root(a) == root(b);}\n};\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int N, M;\n    while(cin >> N >> M && N) {\n        UnionFind uf(N);\n        char q; int a, b; ll w;\n        rep(i, M) {\n            cin >> q >> a >> b;\n            --a; --b;\n            if(q == '?') {\n                if(uf.same(a, b)) cout << uf.dist(a, b) << '\\n';\n                else cout << \"UNKNOWN\" << '\\n';\n            }else {\n                cin >> w;\n                uf.unite(b, a, -w);\n            }\n        }\n        \n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <algorithm>\n#include <set>\n#include <vector>\n\ntypedef long long ll;\nusing namespace std;\n\nvector< set<int> > group;\nint gid[100005]; //group? 是?个int\nint belong[100005];  // 下?int 属于?个group\nint sub[100005];  // 下?int 跟group?差多少\nint gcnt = 0;\nint main()\n{\n    int N,M;\n\n   // freopen(\"in.txt\",\"r\",stdin);\n\n    while(~scanf(\"%d%d\",&N,&M)) {\n        if ( !N && !M ) break;\n        char c[10];\n        int a,b,w;\n\n        memset(gid, -1, sizeof(gid));\n        memset(belong, -1, sizeof(belong));\n        memset(sub, -1, sizeof(sub));\n        gcnt = 0;\n        for(int i=0;i<M;i++) {\n            scanf(\"%s%d%d\", c,&a,&b);\n            if ( c[0] == '!') {\n                scanf(\"%d\",&w);\n\n                if ( belong[a] == -1 && belong[b] == -1 ) {\n                    gcnt++;\n                    belong[a] = gcnt;\n                    belong[b] = gcnt;\n                    gid[ belong[a] ] = a;\n                    sub[a] = 0;\n                    sub[b] = w;\n                }\n                else if ( belong[a] == -1 ) {\n                    belong[a] = belong[b];\n                    sub[a] =  - w + sub[ b ];\n\n                }\n                else if ( belong[b] == -1 ) {\n                    belong[b] = belong[a];\n                    sub[b] = w + sub[ a ];\n                }\n            }\n            else if ( c[0] == '?' ) {\n                if ( belong[a] == -1 || belong[b] == -1 ) {\n                    printf(\"UNKNOWN\\n\");\n                }\n                else if ( belong[a] == belong[b]) {\n                    printf(\"%d\\n\", sub[b] - sub[a]);\n                }\n                else if ( belong[a] != belong[b] ) {\n                    printf(\"UNKNOWN\\n\");\n                }\n            }\n        }\n\n//        for(int i=1;i<=N;i++) {\n//            printf(\"i=%d root=%d sub=%d\\n\",i, gid[ belong[i] == -1? 0 : belong[i] ], sub[i] );\n//        }\n\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define EACH(i,a) for (auto& i : a)\n#define FOR(i,a,b) for(int i=(int)a;i<(int)b;++i)\n#define RFOR(i,a,b) for(int i=(int)b-1;i>=(int)a;--i)\n#define REP(i,n) FOR(i,0,n)\n#define RREP(i,n) RFOR(i,0,n)\n#define ALL(a) (a).begin(),(a).end()\n#define debug(x) cerr << #x << \":\" << x << endl;\n#define OK(ok) cout << (ok ? \"Yes\" : \"No\") << endl;\ntypedef long long ll;\n \nvoid CINT(){}\ntemplate <class Head,class... Tail>\nvoid CINT(Head&& head,Tail&&... tail) {\n  cin >> head; CINT(move(tail)...);\n}\n#define CIN(...) int __VA_ARGS__;CINT(__VA_ARGS__)\n#define LCIN(...) ll __VA_ARGS__;CINT(__VA_ARGS__)\n#define SCIN(...) string __VA_ARGS__;CINT(__VA_ARGS__)\n \nconst int INF = 1e9 + 1;\nconst int MOD = 1e9 + 7;\nconst int MAX_N = 1e5 + 1;\n \n/*\ntemplate< class Abel > struct WeightedUnionFind {\n  vector< int > par;\n  vector< int > rank;\n  vector< Abel > diff_weight;\n \n  WeightedUnionFind(int n = 1, Abel SUM_UNITY = 0) {\n    init(n, SUM_UNITY);\n  }\n \n  void init(int n = 1, Abel SUM_UNITY = 0) {\n    par.resize(n); rank.resize(n); diff_weight.resize(n);\n    REP(i, n) {\n      par[i] = i;\n      rank[i] = 0;\n      diff_weight[i] = SUM_UNITY;\n    }\n  }\n \n  int root(int x) {\n    if (par[x] == x) {\n      // 根がそれ自身だった時にそれを返す\n      return x;\n    } else {\n      int r = root(par[x]);\n      diff_weight[x] += diff_weight[par[x]];\n      return par[x] = r;\n    }\n  }\n \n  bool issame(int x, int y) {\n    return root(x) == root(y);\n  }\n \n  Abel weight(int x) {\n    // 経路圧縮\n    root(x);\n    return diff_weight[x];\n  }\n \n  Abel diff(int x, int y) {\n    return weight(y) - weight(x);\n  }\n \n  // xにyをつなぐ\n  // weight(y) - weight(x) = wとなるようにmergeする\n  bool merge(int x, int y, Abel w) {\n    // xとyそれぞれについて、rootとの重み差分を補正\n    w += weight(x); w-= weight(y);\n    x = root(x); y = root(y);\n    if (x == y) {\n      // 既に連結である\n      return false;\n    }\n    if (rank[x] < rank[y]) {\n      // xにyを連結する設定\n      swap(x, y);\n      w *= -1;\n    }\n    if (rank[x] == rank[y]) {\n      // xとyが同じ時、xの根にyの根を連結する\n      ++rank[x];\n    }\n    par[y] = x;\n \n    diff_weight[y] = w;\n    return true;\n  }\n};\n*/\n \n \ntemplate< class Abel > struct WeightedUnionFind {\n  vector< int > par;\n  vector< Abel > diff_weight;\n  WeightedUnionFind(int n = 1, Abel SUM_UNITY = 0) {\n    init(n, SUM_UNITY);\n  }\n \n  void init(int n, Abel SUM_UNITY = 0) {\n    par.resize(n); diff_weight.resize(n);\n    for(int i = 0; i < n; i++) {\n      par[i] = -1;\n      diff_weight[i] = SUM_UNITY;\n    }\n  }\n   \n  int root(int n) {\n    if (par[n] < 0) return n;\n    diff_weight[n] += diff_weight[par[n]];\n    return par[n] = root(par[n]);\n  }\n \n  Abel weight(int n) {\n    root(n);\n    return diff_weight[n];\n  }\n \n  Abel diff(int x, int y) {\n    return weight(y) - weight(x);\n  }\n \n  bool issame(int x, int y) {\n    return root(x) == root(y);\n  }\n   \n  bool unite(int x, int y, Abel w) {\n    w += weight(x); w -= weight(y);\n    x = root(x); y = root(y);\n    if (x == y) return false;\n    if (par[x] > par[y]) {\n      swap(x, y);\n      w = -w;\n    }\n    par[x] += par[y];\n    par[y] = x;\n    diff_weight[y] = w;\n    return true;\n  }\n};\n \n \nint main()\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n \n  int N, M;\n  while (cin >> N >> M) {\n              if (N == 0) break;\n              WeightedUnionFind<int> uf(N);\n              for (int i = 0; i < M; ++i) {\n                     char c; int a, b, w;\n                     cin >> c;\n                     if (c == '!') {\n                           cin >> a >> b >> w; --a, --b;\n                           uf.unite(a, b, w);\n                     }\n                     else {\n                           cin >> a >> b; --a, --b;\n                           if (!uf.issame(a, b)) printf(\"UNKNOWN\\n\");\n                           else printf(\"%d\\n\", uf.diff(a, b));\n                     }\n              }\n       }\n \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <set>\n#include <algorithm>\n#include <cstdio>\n#define SENTINEL 99999999\nusing namespace std;\ntypedef pair<int,int> pii;\nclass union_find{\n\tvector<pii>parent;\n\tpii root(int a){\n\t\tif(parent[a].first==a)return parent[a];\n\t\tpii ret=root(parent[a].first);\n\t\treturn parent[a]=make_pair(ret.first,ret.second+parent[a].second);\n\t}\npublic:\n\tunion_find(int n): parent(n){for(int i=0;i<n;i++)parent[i]=make_pair(i,0);}\n\tint dist(int a,int b){\n\t\tpii x=root(a),y=root(b);\n\t\tif(x.first!=y.first)return SENTINEL;\n\t\treturn x.second-y.second;\n\t}\n\tint unite(int a,int b,int w){\n\t\tpii x=root(a),y=root(b);\n\t\tif(x.first==y.first)return 0;\n\t\tparent[x.first]=make_pair(y.first,y.second-x.second+w);\n\t\treturn 1;\n\t}\n};\nint main(){\n\tchar s[2];\n\tint N,Q,a,b,w;\n\tfor(;scanf(\"%d%d\",&N,&Q),N;)for(union_find uf(N);Q--;){\n\t\tscanf(\"%s\",s);if(*s=='!'){\n\t\t\tscanf(\"%d%d%d\",&a,&b,&w),a--,b--;\n\t\t\tuf.unite(a,b,w);\n\t\t}else{\n\t\t\tscanf(\"%d%d\",&a,&b),a--,b--;\n\t\t\tw=uf.dist(a,b);\n\t\t\tprintf(w==SENTINEL?\"UNKNOWN\\n\":\"%d\\n\",w);\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int M = 1000000007;\n\nvector<int> grp, val;\nvector<vector<int>> lis;\nvoid init(int n) {\n    grp.resize(n);\n    val.resize(n, 0);\n    lis.resize(n, vector<int>(1));\n    for (int i = 0; i < n; ++i) {\n        grp[i] = i;\n        lis[i][0] = i;\n    }\n}\nvoid merge(int p, int q, int w) {\n    if (grp[p] == grp[q]) return;\n    if (lis[grp[p]].size() < lis[grp[q]].size()) {\n        merge(q, p, -w);\n        return;\n    }\n    int d = w + val[p] - val[q];\n    int g = grp[q];\n    for (int i : lis[g]) {\n        grp[i] = grp[p];\n        val[i] += d;\n        lis[grp[p]].emplace_back(i);\n    }\n    lis[g].clear();\n}\n\nint main() {\n    while (1) {\n        int n, m;\n        cin >> n >> m;\n        if (!n) return 0;\n        init(n);\n        for (int i = 0; i < m; ++i) {\n            char c;\n            cin >> c;\n            if (c == '!') {\n                int p, q, w;\n                cin >> p >> q >> w;\n                merge(p - 1, q - 1, w);\n            }\n            else {\n                int p, q;\n                cin >> p >> q;\n                --p;\n                --q;\n                if (grp[p] != grp[q])\n                    puts(\"UNKNOWN\");\n                else\n                    printf(\"%lld\\n\", val[q] - val[p]);\n            }\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define mp(a,b) make_pair((a),(b))\n#define pb(a) push_back((a))\n#define all(x) (x).begin(),(x).end()\n#define uniq(x) sort(all(x)),(x).erase(unique(all(x)),end(x))\n#define fi first\n#define se second\n#define dbg(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\nvoid _dbg(string){cout<<endl;}\ntemplate<class H,class... T> void _dbg(string s,H h,T... t){int l=s.find(',');cout<<s.substr(0,l)<<\" = \"<<h<<\", \";_dbg(s.substr(l+1),t...);}\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\n#define INF 1120000000\n\ntemplate <class T>\nclass WeightedUnionFind {\n  int n;\n  vector<int> par,sz;\n  vector<T> w;\n  // weight[i] : iがpar[i]よりどれだけ重いか\npublic:\n  WeightedUnionFind(){}\n  WeightedUnionFind(int _n) : n(_n) {\n    par.resize(n, -1);\n    sz.resize(n, 1);\n    w.resize(n, 0);\n  }\n  int find(int i){\n    if(par[i] < 0){\n      return i;\n    } else {\n      int p = find(par[i]);\n      w[i] += w[p];\n      par[i] = p;\n      return p;\n    }\n  }\n  T weight(int x){\n    find(x);\n    return w[x];\n  }\n  bool same(int x, int y){\n    return find(x) == find(y);\n  }\n  // weight[i] +w の位置に j を配置\n  void unite(int i, int j, T nw){\n    nw += weight(i) - weight(j);\n    int x = find(i), y = find(j);\n    if(x == y) return;\n    if(sz[x] < sz[y]){\n      swap(x, y);\n      nw = -nw;\n    }\n    par[y] = x;\n    w[y] = nw;\n  }\n  // x からみた y の相対位置\n  T diff(int x, int y){\n    return weight(y) - weight(x);\n  }\n};\n\nint main(){\n  int n,m;\n  while(cin>>n>>m, n|m){\n    WeightedUnionFind<long> uf(n);\n    rep(i,m){\n      char s[5];\n      int a,b;\n      cin>>s>>a>>b;\n      a--;b--;\n      if(s[0]=='?'){\n        if(uf.same(a,b)) cout << uf.diff(a,b) << endl;\n        else cout << \"UNKNOWN\" << endl;\n      } else {\n        long c;\n        cin>>c;\n        uf.unite(a, b, c);\n      }\n    }\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define f first\n#define s second\n#define mp make_pair\n#define inf 1<<30\n#define MAX 1000010\nusing namespace std;\n\nlong long p[MAX],w[MAX];\n\npair<int,int> find(int a){\n  if(p[a]==a)return mp(a,0);\n  pair<int,int> pii=find(p[a]);\n  p[a]=pii.f;\n  w[a]+=pii.s;\n  return mp(p[a],w[a]);\n}\n\nvoid unit(int a,int b,int d){\n  pair<int,int> pa=find(a),pb=find(b);\n  if(pa.f==pb.f)return;\n  d-=w[b]-w[a];\n  p[pa.f]=pb.f;\n  w[pa.f]=-d;\n}\n\nint main()\n{\n  int n,q,a,b,d;\n  char c;\n\n  while(cin>>n>>q && n ){\n\n    for(int i=0;i<n;i++){\n      p[i]=i;\n      w[i]=0;\n    }\n\n    for(int i=0;i<q;i++){\n      cin>>c;\n      if(c=='!'){\n\tcin>>a>>b>>d;\n\ta--;b--;\n        unit(a,b,d);\n      }\n      else {\n\tcin>>a>>b;\n\ta--;b--;\n\tpair<int,int> pa=find(a),pb=find(b);\n\tif(pa.f!=pb.f)cout<<\"UNKNOWN\"<<endl;\n\telse cout<<w[b]-w[a]<<endl;\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint n,m,x,sum,flg;\nstring str;\nint t[100001],u[100001];\nint dfs(int x){\n  if(u[x]==1)return x;\n  return dfs(t[x]);\n}\nint main(){\n  while(cin>>n>>m,n){\n    for(int i=0;i<100001;i++)u[i]=0;\n    t[1]=u[1]=1;\n    sum=0;\n    for(int i=0;i<n-1;i++)cin>>t[i+2];\n    for(int i=0;i<m;i++){\n      cin>>str>>x;\n      if(str==\"Q\"){\n\tsum+=dfs(t[x]);\n      }else{\n\tu[x]=1;\n      }\n    }\n    cout<<sum<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define PI       3.1415926535897932384626433832795028841971\n#define INF 1000000000\n#define EPS      1e-10\n#define MOD      1000000\nusing namespace std;\ntypedef long long ll;\ntypedef pair<double,double> P;\ntypedef pair<double,P> PQ;\n\nstruct Q{\n    int time,a, b;\n};\n\nstruct edge{\n    int time, to, w;\n};\n\nint n, m;\nint bss[100000];\nint rnk[100000];\nint num[100000];\nbool saw[100000];\nvector<edge> e[100000];\nvector<Q> q;\nint up[20][100000];\nint par[20][100000];\n\nvoid dfs(int v, int bos){\n    saw[v] = true;\n    rep(i,e[v].size()){\n        edge E = e[v][i];\n        if(saw[E.to]) continue;\n        up[0][E.to] = E.time;\n        rnk[E.to] = rnk[v]+1;\n        num[E.to] = num[v]+E.w;\n        bss[E.to] = bos;\n        par[0][E.to] = v;\n        dfs(E.to,bos);\n    }\n}\n\nint main(){\n    while(cin >> n >> m){\n        if(n == 0 && m == 0) break;\n        memset(bss,0,sizeof(bss));\n        memset(rnk,0,sizeof(rnk));\n        memset(num,0,sizeof(num));\n        memset(saw,0,sizeof(saw));\n        rep(i,100000) e[i].clear();\n        q.clear();\n        memset(up,0,sizeof(up));\n        rep(i,m){\n            char hoge;\n            int a, b, w;\n            cin >> hoge;\n            if(hoge == '!'){\n                cin >> a >> b >> w;\n                a--; b--;\n                e[a].push_back((edge){i,b,w});\n                e[b].push_back((edge){i,a,-w});\n            } else{\n                cin >> a >> b;\n                a--; b--;\n                q.push_back((Q){i,a,b});\n            }\n        }\n        rep(i,20){\n            rep(j,n) par[i][j] = i;\n        }\n        rep(i,n){\n            if(saw[i]) continue;\n            dfs(i,i);\n        }\n        for(int i = 1; i < 20; i++){\n            rep(j,n){\n                par[i][j] = par[i-1][par[i-1][j]];\n                up[i][j] = max(up[i-1][j],up[i-1][par[i-1][j]]);\n            }\n        }\n        rep(i,q.size()){\n            Q p = q[i];\n            bool done = false;\n            if(bss[p.a] != bss[p.b]){\n                cout << \"UNKNOWN\" << endl;\n                continue;\n            }\n            int ans = num[p.b]-num[p.a];\n            if(rnk[p.a] > rnk[p.b]){\n                int dis = rnk[p.a]-rnk[p.b];\n                int z = 0;\n                while(dis > 0){\n                    if(dis&1){\n                        if(up[z][p.a] > p.time){\n                            done = true;\n                            cout << \"UNKNOWN\" << endl;\n                            break;\n                        }\n                        p.a = par[z][p.a];\n                    }\n                    z++;\n                    dis /= 2;\n                }\n            } else if(rnk[p.a] < rnk[p.b]){\n                int dis = rnk[p.b]-rnk[p.a];\n                int z = 0;\n                while(dis > 0){\n                    if(dis&1){\n                        if(up[z][p.b] > p.time){\n                            done = true;\n                            cout << \"UNKNOWN\" << endl;\n                            break;\n                        }\n                        p.b = par[z][p.b];\n                    }\n                    z++;\n                    dis /= 2;\n                }\n            }\n            if(done) continue;\n            if(p.a == p.b){\n                cout << ans << endl;\n                continue;\n            }\n            int common = 0;\n            for(int j = 19; j >= 0; j--){\n                if(par[j][p.a] == par[j][p.b]) continue;\n                common += (1<<j);\n            }\n            common++;\n            int z = 0;\n            while(common > 0){\n                if(common&1){\n                    if(up[z][p.a] > p.time){\n                        done = true;\n                        cout << \"UNKNOWN\" << endl;\n                        break;\n                    }\n                    if(up[z][p.b] > p.time){\n                        done = true;\n                        cout << \"UNKNOWN\" << endl;\n                        break;\n                    }\n                    p.a = par[z][p.a];\n                    p.b = par[z][p.b];\n                }\n                common /= 2;\n                z++;\n            }\n            if(done) continue;\n            cout << ans << endl;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=a;i<b;++i)\n#define for_rev(i,a,b) for(int i=a;i>=b;--i)\n#define allof(a) a.begin(),a.end()\n#define minit(a,b) memset(a,b,sizeof(a))\n#define size_of(a) (int)a.size()\n\ntypedef long long lint;\ntypedef pair<int, int> pii;\n\nconst int iINF = 1L << 30;\nconst lint lINF = 1LL << 60;\n\nint N, M;\n\nstruct UnionFind {\n\tvector<int> data;\n\tvector<int> dist;\n\tUnionFind(int _size) : data(_size, -1), dist(_size, iINF) {}\n\t\n\tbool unionSet(int x, int y, int d) {\n\t\tpii px = root(x), py = root(y);\n\t\tx = px.first; y = py.first;\n\n\t\tif (x != y) {\n\t\t\tdata[x] += data[y];\n\t\t\tdata[y] = x;\n\t\t\tdist[y] = d + px.second - py.second;\n\t\t}\n\t\t\n\t\treturn x != y;\n\t}\n\t\n\tpii root(int x) {\n\t\tif (data[x] < 0) {\n\t\t\tdist[x] = 0;\n\t\t\treturn pii(x, 0);\n\t\t}\n\t\t\n\t\tpii p = root(data[x]);\n\t\tdata[x] = p.first;\n\t\tdist[x] += p.second;\n\t\treturn pii(data[x], dist[x]);\n\t}\n\t\n\tint dist_of(int i) { return dist[i]; }\n};\n\nvoid solve() {\n\tUnionFind uf(N + 10);\n\t\n\tfor_(i,0,M) {\n\t\tchar c;\n\t\tint a, b, w;\n\t\tcin >> c;\n\t\t\n\t\tif (c == '!') {\n\t\t\tcin >> a >> b >> w;\n\t\t\tpii pa = uf.root(a), pb = uf.root(b);\n\t\t\tif (pa.first != pb.first) uf.unionSet(a, b, -w);\n\t\t} else {\n\t\t\tcin >> a >> b;\n\t\t\tpii pa = uf.root(a), pb = uf.root(b);\n\t\t\tif (pa.first == pb.first) {\n\t\t\t\tcout << ( uf.dist_of(a) - uf.dist_of(b) ) << endl;\n\t\t\t} else {\n\t\t\t\tcout << \"UNKNOWN\" << endl;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\twhile (cin >> N >> M, N) {\n\t\tsolve();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <utility>\n#include <set>\n#include <map>\n#include <deque>\n#include <queue>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio>\n#include <stdio.h>\n\nusing namespace std;\n\n#define fo(i,n) for(int i=0; i<(int)n; i++)\n#define rep(it,s) for(__typeof((s).begin()) it=(s).begin();it!=(s).end();it++)\n#define mp(a,b) make_pair(a,b)\n#define pb(x) push_back(x)\n#define pii pair<int,int>\n\nint n,m;\nint par[100010];\nlong long w[100010];\n\nint get(int a) {\n\tif (a==par[a]) return a;\n\tint p = par[a];\n\tp = get(p);\n\tw[a] += w[par[a]];\n\tpar[a] = p;\n\treturn par[a];\n}\n\nvoid connect(int a, int b, int c) {\n\tint i = get(a);\n\tint j = get(b);\n\tpar[i] = j;\n\tw[i] = -(w[a] - c - w[b]);\n}\n\nint main() {\n\n    //freopen(\"input.txt\",\"r\",stdin);\n    //freopen(\"output.txt\",\"w\",stdout);\n\n\twhile (scanf(\"%d%d\",&n,&m) && n!=0) {\n\t\tfor (int i=0; i<n; i++) par[i] = i;\n\t\tfor (int i=0; i<n; i++) w[i] = 0;\n\t\t\n\t\tfor (int i=0; i<m; i++) {\n\t\t\tchar c[5];\n\t\t\tscanf(\"%s\",c);\n\t\t\tif (c[0]=='!') {\n\t\t\t\tint a,b,d;\n\t\t\t\tscanf(\"%d%d%d\",&a,&b,&d);\n\t\t\t\ta--; b--;\n\t\t\t\tif (get(a)==get(b)) continue;\n\t\t\t\tconnect(a,b,d);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tint a,b;\n\t\t\t\tscanf(\"%d%d\",&a,&b);\n\t\t\t\ta--; b--;\n\t\t\t\tif (get(a)!=get(b)) {\n\t\t\t\t\tprintf(\"UNKNOWN\\n\");\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tprintf(\"%lld\\n\",w[a]-w[b]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n    return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing VI = vector<ll>;\nusing VV = vector<VI>;\nusing VS = vector<string>;\nusing PII = pair<ll, ll>;\n\n// tourist set\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p);\n\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p);\n\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p);\n\nstring to_string(const string& s) {\n  return '\"' + s + '\"';\n}\n\nstring to_string(const char* s) {\n  return to_string((string) s);\n}\n\nstring to_string(bool b) {\n  return (b ? \"true\" : \"false\");\n}\n\nstring to_string(vector<bool> v) {\n  bool first = true;\n  string res = \"{\";\n  for (int i = 0; i < static_cast<int>(v.size()); i++) {\n    if (!first) {\n      res += \", \";\n    }\n    first = false;\n    res += to_string(v[i]);\n  }\n  res += \"}\";\n  return res;\n}\n\ntemplate <size_t N>\nstring to_string(bitset<N> v) {\n  string res = \"\";\n  for (size_t i = 0; i < N; i++) {\n    res += static_cast<char>('0' + v[i]);\n  }\n  return res;\n}\n\ntemplate <typename A>\nstring to_string(A v) {\n  bool first = true;\n  string res = \"{\";\n  for (const auto &x : v) {\n    if (!first) {\n      res += \", \";\n    }\n    first = false;\n    res += to_string(x);\n  }\n  res += \"}\";\n  return res;\n}\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p) {\n  return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\";\n}\n\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p) {\n  return \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" + to_string(get<2>(p)) + \")\";\n}\n\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p) {\n  return \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" + to_string(get<2>(p)) + \", \" + to_string(get<3>(p)) + \")\";\n}\n\nvoid debug_out() { cerr << '\\n'; }\n\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << \" \" << to_string(H);\n  debug_out(T...);\n}\n\n#ifdef LOCAL\n#define debug(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n// tourist set end\n\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return 1; } return 0; }\n\n#define FOR(i,a,b) for(ll i=(a);i<(b);++i)\n#define rep(i,b) FOR(i, 0, b)\n#define ALL(v) (v).begin(), (v).end()\n#define p(s) cout<<(s)<<'\\n'\n#define p2(s, t) cout << (s) << \" \" << (t) << '\\n'\n#define br() p(\"\")\n#define pn(s) cout << (#s) << \" \" << (s) << '\\n'\n#define p_yes() p(\"YES\")\n#define p_no() p(\"NO\")\n#define SZ(x) ((int)(x).size())\n#define SORT(A) sort(ALL(A))\n#define RSORT(A) sort(ALL(A), greater<ll>())\n#define MP make_pair\n\nvoid no(){p_no(); exit(0);}\nvoid yes(){p_yes(); exit(0);}\n\nconst ll mod = 1e9 + 7;\nconst ll inf = 1e18;\nconst double PI = acos(-1);\n\n// けんちょんさん\n// https://qiita.com/drken/items/cce6fc5c579051e64fab\nstruct WeightedUnionFind{\n    VI par;\n    VI rank;\n    VI diff_weight;\n\n    WeightedUnionFind(ll sz){\n        init(sz);\n    }\n\n    void init(ll sz){\n        par.resize(sz);\n        rank.resize(sz);\n        diff_weight.resize(sz);\n        FOR(i, 0, sz){\n            par[i] = i;\n            rank[i] = 0;\n            diff_weight[i] = 0;\n        }\n    }\n\n    int root(ll x) {\n        if (par[x] == x) {\n            return x;\n        }\n        else {\n            ll r = root(par[x]);\n            diff_weight[x] += diff_weight[par[x]];\n            return par[x] = r;\n        }\n    }\n\n    ll weight(ll x) {\n        root(x);\n        return diff_weight[x];\n    }\n\n    bool is_same(ll x, ll y) {\n        return root(x) == root(y);\n    }\n\n    // weight(y) - weight(x) = w となるように merge する\n    bool merge(ll x, ll y, ll w) {\n        w += weight(x); w -= weight(y);\n        x = root(x); y = root(y);\n        if (x == y) return false;\n        if (rank[x] < rank[y]) swap(x, y), w = -w;\n        if (rank[x] == rank[y]) ++rank[x];\n        par[y] = x;\n        diff_weight[y] = w;\n        return true;\n    }\n\n    ll diff(int x, int y) {\n        return weight(y) - weight(x);\n    }\n};\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    // input\n    ll N, M;\n\n    while(cin>>N>>M){\n      if(N==0) return 0;\n\n      WeightedUnionFind uf(N);\n      while(M--){\n        char c;cin>>c;\n        if(c=='!'){\n          ll a,b,c;cin>>a>>b>>c;\n          a--;b--;\n          uf.merge(a,b,c); // a+c==b\n        }\n        else{\n          ll a,b;cin>>a>>b;\n          a--;b--;\n          if(uf.is_same(a,b)){\n            ll d = uf.diff(a,b);\n            p(d);\n          }else{\n            p(\"UNKNOWN\");\n          }\n        }\n      }\n    }    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nstruct UnionFind {\n#define rep(i,n) for (int i=0; i < int(n); i++)\n  vector<int> par;\n  vector<int> dw;\n  vector<int> sizes;\n\n  UnionFind(int n) : par(n), dw(n), sizes(n, 1) {\n    rep(i,n) par[i] = i;\n  }\n\n  int find(int x) {\n    if (x == par[x]) return x;\n    int xp = find(par[x]);\n    dw[x] += dw[par[x]];\n    return par[x] = xp;\n  }\n\n  void unite(int x, int y, int w) {\n    int xp = find(x);\n    int yp = find(y);\n\n    if (xp == yp) return;\n\n    if (sizes[xp] >= sizes[yp]) {\n        par[yp] = xp;\n        dw[yp] = dw[x] - dw[y] + w;\n        dw[y] += dw[x] - dw[y] + w;\n        sizes[x] += sizes[y];\n    } else {\n        swap(x, y);\n        swap(xp, yp);\n        par[yp] = xp;\n        dw[yp] = dw[x] - dw[y] - w;\n        dw[y] += dw[x] - dw[y] - w;\n        sizes[x] += sizes[y];\n    }\n\n  }\n\n  bool same(int x, int y) {\n    return find(x) == find(y);\n  }\n\n  int size(int x) {\n    return sizes[find(x)];\n  }\n#undef rep\n};\n\nint main()\n{\n    for (;;) {\n        int n, m;\n        scanf(\"%d %d\", &n, &m);\n        if (n == 0 && m == 0)\n            break;\n\n        UnionFind uf(n);\n        for (int i = 0; i < m; ++i) {\n            //for (int i = 0; i < n; ++i) printf(\"%d: par=%d, dw=%d\\n\", i+1, uf.par[i]+1, uf.dw[i]);\n            char c;\n            scanf(\" %c\", &c);\n            if (c == '!') {\n                int a, b, w;\n                scanf(\"%d %d %d\", &a, &b, &w);\n                uf.unite(a - 1, b - 1, w);\n            } else /* if (c == '?') */ {\n                int a, b;\n                scanf(\"%d %d\", &a, &b);\n                if (uf.same(a - 1, b - 1))\n                    printf(\"%d\\n\", uf.dw[b - 1] - uf.dw[a - 1]);\n                else\n                    printf(\"UNKNOWN\\n\");\n            }\n        }\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define f first\n#define s second\n#define mp make_pair\n#define inf 1<<30\n#define MAX 1000010\nusing namespace std;\n\nlong long p[MAX],w[MAX];\n\npair<int,int> find(int a){\n  if(p[a]==a)return mp(a,0);\n  pair<int,int> pii=find(p[a]);\n  pii.s+=w[a];\n  p[a]=pii.f;\n  w[a]=pii.s;\n  return pii;\n}\n\nvoid unit(int a,int b,int d){\n  pair<int,int> pa=find(a),pb=find(b);\n  if(pa.f==pb.f)return;\n  p[pa.f]=b;\n  w[pa.f]=d-pa.s+pb.s;\n}\n\nint main()\n{\n  int n,q,a,b,d;\n  char c;\n\n  while(cin>>n>>q && n ){\n\n    for(int i=0;i<n;i++){\n      p[i]=i;\n      w[i]=0;\n    }\n\n    for(int i=0;i<q;i++){\n      cin>>c;\n      if(c=='!'){\n\tcin>>a>>b>>d;\n\ta--;b--;\n        unit(a,b,d);\n      }\n      else {\n\tcin>>a>>b;\n\ta--;b--;\n\tpair<int,int> pa=find(a),pb=find(b);\n\tif(pa.f!=pb.f)cout<<\"UNKNOWM\"<<endl;\n\telse cout<<pa.s-pb.s<<endl;\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint n;\nint m;\nint par[114514];\nint grp[114514];\nint myws[114514];\nint height[114514];\nvector<int> belong[114514];\n\nint find(int v) {\n  if (par[v] != v) return par[v] = find(par[v]);\n  return v;\n}\n\nbool same(int v, int u) {\n  return find(v) == find(u);\n}\n\nvoid unite(int u, int v) {\n  u = find(u);\n  v = find(v);\n  if (u == v) return;\n\n  if (height[u] > height[v]) par[v] = u;\n  else if (height[u] < height[v]) par[u] = v;\n  else {\n    par[v] = u;\n    height[v]++;\n  }\n}\n\nint main() {\n  while (1) {\n    scanf(\"%d%d\", &n, &m);\n    if (n == 0 && m == 0) return 0;\n\n    for (int i=0; i<=n; i++) {\n      myws[i] = 0;\n      par[i] = i;\n      height[i] = 0;\n      belong[i].clear();\n      belong[i].push_back(i);\n      grp[i] = i;\n    }\n\n    for (int i=0; i<m; i++) {\n      char cmd;\n      int a, b;\n      scanf(\" %c%d%d\", &cmd, &a, &b);\n      if (cmd == '!') {\n        int w;\n        scanf(\"%d\", &w);\n        if (!same(a, b)) {\n          if (belong[grp[a]].size() < belong[grp[b]].size()) {\n            swap(a, b);\n            w = -w;\n          }\n\n          int d = myws[b]-(myws[a]+w);\n          for (int v : belong[grp[b]]) {\n            belong[grp[a]].push_back(v);\n            grp[v] = grp[a];\n            myws[v] -= d;\n          }\n          unite(a, b);\n        }\n      } else {\n        if (!same(a, b)) puts(\"UNKNOWN\");\n        else {\n          printf(\"%d\\n\", myws[b]-myws[a]);\n        }\n      }\n    } \n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\n#include <cassert>\n#include <queue>\n#include <set>\n#include <map>\n#include <valarray>\n#include <bitset>\n#include <stack>\n#include <iomanip>\n#include <fstream>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define chmax(a,b) (a<b?(a=b,1):0)\n#define chmin(a,b) (a>b?(a=b,1):0)\n#define valid(y,x,h,w) (0<=y&&y<h&&0<=x&&x<w)\nconst int INF = 1<<29;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n\nstruct UnionFind {\n  vector<int> data;\n  vector<ll> dis;\n  UnionFind(int size) : data(size, -1), dis(size,0) { }\n  bool unionSet(int x, int y, ll d) {\n    ll disx = dist(x);\n    ll disy = dist(y);\n    x = root(x); y = root(y);\n    if (x != y) {\n      if (data[y] < data[x]) {\n        swap(x, y), d=-d;\n        swap(disx,disy);\n      }\n      data[x] += data[y]; data[y] = x;\n      dis[y] = disx + d - disy;\n    }\n    return x != y;\n  }\n  bool findSet(int x, int y) {\n    return root(x) == root(y);\n  }\n  int root(int x) {\n    if (data[x]<0) return x;\n    else {\n      int r = root(data[x]);\n      dis[x] += dis[data[x]];\n      return data[x] = r; // root(data[x]);\n    }\n    // return data[x] < 0 ? x : data[x] = root(data[x]);\n  }\n  int size(int x) {\n    return -data[root(x)];\n  }\n  int dist(int x) {\n    root(x);\n    return dis[x];\n  }\n};\n\nint main() {\n  int n,m;\n  while(cin>>n>>m,n||m) {\n    UnionFind uf(n);\n    REP(i,m) {\n      // REP(j,n) cout << uf.data[j] << \" \"; cout << endl;\n      // REP(j,n) cout << uf.dis[j] << \" \"; cout << endl;\n      char c; cin >> c;\n      if (c == '!') {\n        int a, b, d;\n        cin >> a >> b >> d;\n        a--;b--;\n        uf.unionSet(a,b,d);\n      } else {\n        int a, b;\n        cin >> a >> b;\n        a--;b--;\n        if (uf.findSet(a,b)) {\n          ll d1 = uf.dist(a);\n          ll d2 = uf.dist(b);\n          cout << d2-d1 << endl;\n        } else {\n          puts(\"UNKNOWN\");\n        }\n      }\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, a, n) for(ll i = ((ll) a); i < ((ll) n); i++)\nusing namespace std;\ntypedef long long ll;\n\nclass UnionFind {\npublic:\n  vector<ll> parent, weight;\n\n  UnionFind(ll n): parent(n), weight(n) {\n    REP(i, 0, n) parent[i] = i;\n  }\n\n  ll find(ll i) {\n    if(parent[i] == i) return i;\n    ll p = parent[i];\n    ll t = find(p);\n    parent[i] = t;\n    weight[i] += weight[p];\n    return t;\n  }\n\n  void unite(ll i, ll j, ll w) {\n    parent[i] = j;\n    weight[i] = -w;\n  }\n};\n\nint main(void) {\n  ll N, M;\n  while(cin >> N >> M, N && M) {\n    UnionFind uf(N);\n    REP(i, 0, M) {\n      char T;\n      ll A, B, W;\n      cin >> T;\n      if(T == '!') {\n        cin >> A >> B >> W; A--; B--;\n        uf.unite(A, B, W);\n      } else {\n        cin >> A >> B; A--; B--;\n        if(uf.find(A) != uf.find(B)) cout << \"UNKNOWN\" << endl;\n        else cout << uf.weight[B] - uf.weight[A] << endl;\n      }\n    }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#define  _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n\n#pragma comment (linker, \"/STACK:526000000\")\n\n#include \"bits/stdc++.h\"\n\nusing namespace std;\ntypedef string::const_iterator State;\n#define eps 1e-10L\n#define MAX_MOD 1000000007LL\n#define GYAKU 500000004LL\n#define seg_size 262144LL\n#define MOD 998244353LL\n#define pb push_back\n#define mp make_pair\ntypedef long long ll;\n#define REP(a,b) for(long long (a) = 0;(a) < (b);++(a))\n#define ALL(x) (x).begin(),(x).end()\n\ntypedef complex<long double> Point;\ntypedef pair<complex<long double>, complex<long double>> Line;\n\ntypedef struct Circle {\n    complex<long double> center;\n    long double r;\n}Circle;\n\nlong double dot(Point a, Point b) {\n    return (a.real() * b.real() + a.imag() * b.imag());\n}\nlong double cross(Point a, Point b) {\n    return (a.real() * b.imag() - a.imag() * b.real());\n}\n\nlong double Dist_Line_Point(Line a, Point b) {\n    if (dot(a.second - a.first, b - a.first) < eps) return abs(b - a.first);\n    if (dot(a.first - a.second, b - a.second) < eps) return abs(b - a.second);\n    return abs(cross(a.second - a.first, b - a.first)) / abs(a.second - a.first);\n}\n\nint is_intersected_ls(Line a, Line b) {\n    return (cross(a.second - a.first, b.first - a.first) * cross(a.second - a.first, b.second - a.first) < 0) &&\n        (cross(b.second - b.first, a.first - b.first) * cross(b.second - b.first, a.second - b.first) < 0);\n}\n\nPoint intersection_l(Line a, Line b) {\n    Point da = a.second - a.first;\n    Point db = b.second - b.first;\n    return a.first + da * cross(db, b.first - a.first) / cross(db, da);\n}\n\nlong double Dist_Line_Line(Line a, Line b) {\n    if (is_intersected_ls(a, b) == 1) {\n        return 0;\n    }\n    return min({ Dist_Line_Point(a,b.first), Dist_Line_Point(a,b.second),Dist_Line_Point(b,a.first),Dist_Line_Point(b,a.second) });\n}\n\npair<Point, Point> intersection_Circle_Circle(Circle a, Circle b) {\n    long double dist = abs(a.center - b.center);\n    assert(dist <= eps + a.r + b.r);\n    assert(dist+eps >= abs(a.r - b.r));\n    Point target = b.center - a.center;\n    long double pointer = target.real() * target.real() + target.imag() * target.imag();\n    long double aa = pointer + a.r * a.r - b.r * b.r;\n    aa /= 2.0L;\n    Point l{ (aa * target.real() + target.imag() * sqrt(pointer * a.r * a.r - aa * aa))/pointer,\n            (aa* target.imag() - target.real() * sqrt(pointer * a.r * a.r - aa * aa)) / pointer};\n    Point r{ (aa * target.real() - target.imag() * sqrt(pointer * a.r * a.r - aa * aa)) / pointer,\n        (aa * target.imag() + target.real() * sqrt(pointer * a.r * a.r - aa * aa)) / pointer };\n    r = r + a.center;\n    l = l + a.center;\n    return mp(l, r);\n}\nvoid init() {\n    iostream::sync_with_stdio(false);\n    cout << fixed << setprecision(20);\n}\n\nunsigned long xor128() {\n    static unsigned long x = 123456789, y = 362436069, z = 521288629, w = 88675123;\n    unsigned long t = (x ^ (x << 11));\n    x = y; y = z; z = w;\n    return (w = (w ^ (w >> 19)) ^ (t ^ (t >> 8)));\n}\n\n#define int ll\npair<int, int> union_tree[200000];\npair<int, int> union_find(int now) {\n    if (union_tree[now].first == now) return union_tree[now];\n    pair<int, int> neko = union_find(union_tree[now].first);\n    union_tree[now].second += neko.second;\n    union_tree[now].first = neko.first;\n    return union_tree[now];\n}\nvoid union_merge(int a, int b,int c) {\n    union_find(a);\n    union_find(b);\n    c += union_tree[a].second;\n    c -= union_tree[b].second;\n    a = union_tree[a].first;\n    b = union_tree[b].first;\n    if (a == b) return;\n    union_tree[b].second = c;\n    union_tree[b].first = a;\n    return;\n}\nvoid solve(){\n    while (true) {\n        int n, m;\n        cin >> n >> m;\n        if (n == 0) return;\n        REP(i, n) {\n            union_tree[i] = mp(i, 0);\n        }\n        REP(i, m) {\n            string s;\n            cin >> s;\n            if (s == \"!\") {\n                int a, b, c;\n                cin >> a >> b >> c;\n                a--; b--;\n                union_merge(a, b, c);\n            }\n            else {\n                int a, b;\n                cin >> a >> b;\n                a--; b--;\n                if (union_find(a).first != union_find(b).first) {\n                    cout << \"UNKNOWN\" << endl;\n                }\n                else {\n                    cout << union_tree[b].second - union_tree[a].second << endl;\n                }\n            }\n        }\n    }\n}\n\n#undef int\nint main() {\n    init();\n    solve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int M = 1000000007;\n\nvector<int> grp;\nvector<long long>val;\nvector<vector<int>> lis;\nvoid init(int n) {\n    grp.resize(n);\n    val.resize(n, 0);\n    lis.resize(n);\n    for (int i = 0; i < n; ++i) {\n        grp[i] = i;\n        lis[i].push_back(i);\n    }\n}\nvoid merge(int p, int q, long long w) {\n    if (grp[p] == grp[q]) return;\n    if (lis[grp[p]].size() < lis[grp[q]].size()) {\n        merge(q, p, -w);\n        return;\n    }\n    long long d = w + val[p] - val[q];\n    int g = grp[q];\n    for (int i : lis[g]) {\n        grp[i] = grp[p];\n        val[i] += d;\n        lis[grp[p]].push_back(i);\n    }\n    lis[g].clear();\n}\n\nint main() {\n    while (1) {\n        int n, m;\n        cin >> n >> m;\n        if (!n) return 0;\n        init(n);\n        for (int i = 0; i < m; ++i) {\n            char c;\n            cin >> c;\n            if (c == '!') {\n                int p, q, w;\n                cin >> p >> q >> w;\n                merge(p - 1, q - 1, w);\n            }\n            else {\n                int p, q;\n                cin >> p >> q;\n                --p;\n                --q;\n                if (grp[p] != grp[q])\n                    puts(\"UNKNOWN\");\n                else\n                    printf(\"%lld\\n\", val[q] - val[p]);\n            }\n        }\n        for (int i = 0; i < n; ++i) {\n            lis[i].clear();\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntypedef long double ld;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-10;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\nstruct union_find\n{\n\tvector<pii> par;\n\tunion_find(int n)\n\t{\n\t\tREP(i, n) par.emplace_back(i, 0);\n\t}\n\tpii find(int x)\n\t{\n\t\tif (par[x].first == x) return par[x];\n\t\telse\n\t\t{\n\t\t\tpii t = find(par[x].first);\n\t\t\treturn pii(par[x].first = t.first, par[x].second += t.second);\n\t\t}\n\t}\n\tvoid unite(int x, int y, int w)\n\t{\n\t\tint dif = w + par[x].second - par[y].second;\n\t\tx = find(x).first; y = find(y).first;\n\t\tif (x == y) return;\n\t\tpar[y].first = x;\n\t\tpar[y].second += dif;\n\t}\n\tbool same(int x, int y)\n\t{\n\t\treturn find(x).first == find(y).first;\n\t}\n};\n\nint main()\n{\n\tint n, m;\n\twhile (cin >> n >> m, n)\n\t{\n\t\tunion_find uf(n);\n\t\tREP(i, m)\n\t\t{\n\t\t\tchar c;\n\t\t\tcin >> c;\n\t\t\tif (c == '!')\n\t\t\t{\n\t\t\t\tint a, b, w;\n\t\t\t\tcin >> a >> b >> w;\n\t\t\t\ta--; b--;\n\t\t\t\tuf.unite(a, b, w);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tint a, b;\n\t\t\t\tcin >> a >> b;\n\t\t\t\ta--; b--;\n\t\t\t\tif (!uf.same(a, b))\n\t\t\t\t\tputs(\"UNKNOWN\");\n\t\t\t\telse cout << uf.par[b].second - uf.par[a].second << endl;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "                                        #include <bits/stdc++.h>\n                                        #include<iostream>\n                                        #include<cstdio>\n                                        #include<vector>\n                                        #include<queue>\n                                        #include<map>\n                                        #include<cstring>\n                                        #include<string>\n                                        #include <math.h>\n                                        #include<algorithm>\n                                    //    #include <boost/multiprecision/cpp_int.hpp>\n                                        #include<functional>\n                                #define int long long\n                                        #define inf  1000000007\n                                        #define pa pair<int,int>\n                                        #define ll long long\n                                        #define pal pair<double,int>\n                                        #define ppa pair<int,int>\n                                        #define ppap pair<int,pa>\n                                        #define ssa pair<string,int>\n                                        #define  mp make_pair\n                                        #define  pb push_back\n                                        #define EPS (1e-12)\n                                        #define equals(a,b) (fabs((a)-(b))<EPS)\n                                  #define VI vector<int>\n                                        using namespace std;\n                                        \n                                  class pas{\n                                    \tpublic:\n                                    \tint x,y;\n                                    \tpas(int x=0,int y=0):x(x),y(y) {}\n                                    \tpas operator + (pas p) {return pas(x+p.x,y+p.y);}\n                                    \tpas operator - (pas p) {return pas(x-p.x,y-p.y);}\n                                    \tpas operator * (int a) {return pas(x*a,y*a);}\n                                    \tpas operator / (int a) {return pas(x/a,y/a);}\n                                    //\tdouble absv() {return sqrt(norm());}\n                                    \tint norm() {return x*x+y*y;}\n                                    \tbool operator < (const pas &p) const{\n                                   \t\treturn x != p.x ? x<p.x: y<p.y;\n                                   \t}\n                                  //\t\tbool operator < (const pas &p) const{\n                                    //\t\treturn y != p.y ? y<p.y: x<p.x;\n                                    //\t}\n                                    \tbool operator == (const pas &p) const{\n                                    \t\treturn x==p.x && y==p.y;\n                                    \t}\n                                    };\n\n                                        class Point{\n                                        \tpublic:\n                                        \tdouble x,y;\n                                        \tPoint(double x=0,double y=0):x(x),y(y) {}\n                                        \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                                        \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                                        \tPoint operator * (double a) {return Point(x*a,y*a);}\n                                        \tPoint operator / (double a) {return Point(x/a,y/a);}\n                                        \tdouble absv() {return sqrt(norm());}\n                                        \tdouble norm() {return x*x+y*y;}\n                                        \tbool operator < (const Point &p) const{\n                                        \t\treturn x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const Point &p) const{\n                                        \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                                        \t}\n                                        };\n                                        typedef Point Vector;\n                                 #define pl pair<int,pas>\n                                        struct Segment{\n                                        Point p1,p2;\n                                        };\n                                         double dot(Vector a,Vector b){\n                                        \treturn a.x*b.x+a.y*b.y;\n                                        }\n                                        double cross(Vector a,Vector b){\n                                        \treturn a.x*b.y-a.y*b.x;\n                                        }\n                                    \n            bool parareru(Point a,Point b,Point c,Point d){\n            //\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n            \treturn abs(cross(a-b,d-c))<EPS;\n            }\n            double distance_ls_p(Point a, Point b, Point c) {\n              if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n              if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n              return abs(cross(b-a, c-a)) / (b-a).absv();\n            }\n            bool is_intersected_ls(Segment a,Segment b) {\n            \tif(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n            \tif(parareru((a.p2),(a.p1),(a.p1),(b.p2))&&parareru((a.p2),(a.p1),(a.p1),(b.p1))){\n            //\t\tcout<<\"sss\"<<endl;\n            \t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n            \t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n            \t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n            \t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n            \t\treturn false;\n            \t}\n              else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n            }\n            double segment_len(Segment a){\n            \t\n            \treturn (a.p1-a.p2).absv();\n            }\n            double segment_dis(Segment a,Segment b){\n            \tif(is_intersected_ls(a,b))return 0;\n            \tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n            \tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n            \tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n            \tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n            \treturn r;\n            }\n            Point intersection_ls(Segment a, Segment b) {\n              Point ba = b.p2-b.p1;\n              double d1 = abs(cross(ba, a.p1-b.p1));\n              double d2 = abs(cross(ba, a.p2-b.p1));\n              double t = d1 / (d1 + d2);\n             \n              return a.p1 + (a.p2-a.p1) * t;\n            }\n\t\t\tpair<Point,Point> circle_intersection(Point c1,double r1,Point c2,double r2){\n\t\t\t\tdouble d=(c1-c2).absv();\n\t\t\t\tdouble h=(r1*r1-r2*r2+d*d)/2.0/d;\n\t\t\t\tdouble l=sqrt(r1*r1-h*h);\n\t\t\t//\tcout<<d<<\" \"<<h<<\" \"<<l<<endl;\n\t\t\t\tPoint asi=c1+(c2-c1)*h/((c2-c1).absv());\n\t\t\t\tVector r1r2=(c2-c1)/((c2-c1).absv());\n\t\t\t\tVector sui={r1r2.y,-r1r2.x};\n\t\t\t//\tcout<<sui.x<<\" \"<<sui.y<<endl;\n\t\t\t\tpair<Point,Point> z=mp(asi+sui*l,asi-sui*l);\n\t\t\t\tif(z.first.x>z.second.x) swap(z.first,z.second);\n\t\t\t\treturn z;\n\t\t\t}\n         \nint par[500100],ranks[500100],kosuu[500100];     \nint dep[500100];\nvector<int> ve[100020];\nvoid shoki(int n){\n\tfor(int i=0;i<n;i++){\n\t\tpar[i]=i;\n\t\tranks[i]=0;\n\t\tkosuu[i]=1;\n\t\tdep[i]=0;\n\t\tve[i].clear();\n\t\tve[i].pb(i);\n\t}\n}\n\nint root(int x){\n\treturn par[x]==x ? x : par[x]=root(par[x]);\n}\n\nbool same(int x,int y){\nreturn root(x)==root(y);\n}\n\nvoid unite(int x,int y,int dif){\n\tint x1=x,y1=y;\n x=root(x);\n y=root(y);\n\tint xx=kosuu[x],yy=kosuu[y];\n if(x==y) return;\n\tint id;\n\tint l=dep[y1]-dep[x1];\n\tif(xx>yy){\n\t\tfor(auto v:ve[y]){\n\t\t\tve[x].pb(v);\n\t\t\tdep[v]+=dif-l;\n\t\t}\n\t\tid=x;\n\t\t\n\t}\n\telse {\n\t\tfor(auto v:ve[x]){\n\t\t\tve[y].pb(v);\n\t\t\tdep[v]-= dif-l;\n\t\t}\n\t\tid=y;\n\t}\n\t\n\tif(ranks[x]<ranks[y]){\n\t\tpar[x]=y;\n\t\tkosuu[y]=yy+xx;\n\t\tve[y]=ve[id];\n\t}\n else {\n\tpar[y]=x;\n\tif(ranks[x]==ranks[y]) ranks[x]=ranks[x]+1;\n \tkosuu[x]=yy+xx;\n \tve[x]=ve[id];\n }\n\t\n\treturn;\n}\n\n\n            \n         signed main(){\n\tint n,m;\n         \tshoki(100010);\n         \twhile(1){\n         \tcin>>n>>m;\n         \t\tif(n==0 && m==0) return 0;\n         \t\n         \t\tfor(int k=0;k<m;k++){\n         \t\t\tchar c;\n         \t\t\tcin>>c;\n         \t\t\tif(c=='!'){\n         \t\t\tint a,b,c;\n         \t\t\t\tcin>>a>>b>>c;\n         \t\t\t\tif(same(a,b)) continue;\n         \t\t\t\tunite(a,b,c);\n         \t\t\t}\n         \t\t\telse{\n         \t\t\t\tint a,b;\n         \t\t\t\tcin>>a>>b;\n         \t\t\t\tif(!same(a,b))cout<<\"UNKNOWN\"<<endl;\n         \t\t\t\telse cout<<dep[b]-dep[a]<<endl;\n         \t\t\t}\n         \t\t\t\n         \t\t}\n         \t\t\n         \t\t\n         \t\t\n         \t\t\n         \t\t\n         \t\t\n         \t\t\n         \t\tshoki(n+10);\n         \t}\n\t\n           \treturn 0;\n           }\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntypedef long double ld;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-10;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\nstruct union_find\n{\n\tvector<pii> par;\n\tunion_find(int n)\n\t{\n\t\tREP(i, n) par.emplace_back(i, 0);\n\t}\n\tpii find(int x)\n\t{\n\t\tif (par[x].first == x) return par[x];\n\t\telse\n\t\t{\n\t\t\tpii t = find(par[x].first);\n\t\t\tpar[x].second += t.second;\n\t\t\tpar[x].first = t.first;\n\t\t\treturn par[x];\n\t\t}\n\t}\n\tvoid unite(int x, int y, int w)\n\t{\n\t\tint dif = w + par[x].second - par[y].second;\n\t\tx = find(x).first; y = find(y).first;\n\t\tif (x == y) return;\n\t\tpar[y].first = x;\n\t\tpar[y].second += dif;\n\t}\n\tbool same(int x, int y)\n\t{\n\t\treturn find(x).first == find(y).first;\n\t}\n};\n\nint main()\n{\n\tint n, m;\n\twhile (cin >> n >> m, n)\n\t{\n\t\tunion_find uf(n);\n\t\tREP(i, m)\n\t\t{\n\t\t\tchar c;\n\t\t\tcin >> c;\n\t\t\tif (c == '!')\n\t\t\t{\n\t\t\t\tint a, b, w;\n\t\t\t\tcin >> a >> b >> w;\n\t\t\t\ta--; b--;\n\t\t\t\tuf.unite(a, b, w);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tint a, b;\n\t\t\t\tcin >> a >> b;\n\t\t\t\ta--; b--;\n\t\t\t\tif (!uf.same(a, b))\n\t\t\t\t\tputs(\"UNKNOWN\");\n\t\t\t\telse cout << uf.par[b].second - uf.par[a].second << endl;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\ntypedef long long int ll;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000001\nusing namespace std;\n\nint* parent; //????????°?????????????±?????????????????????????????????????????????????????????¨\nint* height; //????????°?????????????±?????????????????????????????????????????????????????????¨\n\n\nint* calc_parent;\nint* relative_weight; //?????????????????¨??????????????????????????????????????????\n\nint find_parent(int id){\n\tif(parent[id] == id)return id;\n\telse{\n\t\treturn parent[id] = find_parent(parent[id]);\n\t}\n}\n\nint find_calc_parent(int id){\n\tif(calc_parent[id] == id)return id;\n\telse{\n\t\t//return calc_parent[id] = find_calc_parent(calc_parent[id]);\n\t\treturn calc_parent[id] = find_calc_parent(calc_parent[id]); //?????????????????§??????????????????\n\t}\n}\n\n//calc_parent???????????§????????????\nint compress_calc_parent(int id){\n\tif(calc_parent[id] == id)return id;\n\telse{\n\t\treturn calc_parent[id] = find_calc_parent(calc_parent[id]);\n\t}\n}\n\n//??????????????????????????????????¨??????????\nint calc_relative_weight(int id){\n\n\tif(calc_parent[id] == id){\n\t\treturn 0; //????????????????????????0\n\t}else{\n\t\t//return relative_weight[id] = relative_weight[id] + calc_relative_weight(calc_parent[id]);\n\t\treturn relative_weight[id] + calc_relative_weight(calc_parent[id]);\n\t}\n}\n\n//??°??????????????±????????????????????????????????¨?????±????????????\nvoid unite(int a,int b,int w){\n\n\t//?????????\n\tint a_parent = find_parent(a);\n\tint b_parent = find_parent(b);\n\n\tif(a_parent == b_parent)return; //????????°???????????????calc_parent??¨?????±??????????????????????????????\n\n\t//??±?????????\n\tif(height[a_parent] == height[b_parent]){\n\t\tparent[b_parent] = a_parent;\n\t\theight[a_parent]++;\n\t}else if(height[a_parent] > height[b_parent]){\n\t\tparent[b_parent] = a_parent;\n\t}else{\n\t\tparent[a_parent] = b_parent;\n\t}\n\n\tint relative_a = calc_relative_weight(a);\n\tint relative_b = calc_relative_weight(b);\n\n\tif((relative_b-relative_a) -w <= 0){ //a????????????????????????????????????????????????????????¨???\n\t\t//a?????¨???b?????¨???????????????\n\t\trelative_weight[calc_parent[b]] = w-(relative_b-relative_a);\n\t\tcalc_parent[calc_parent[b]] = calc_parent[a];\n\n\t}else{\n\t\t//b?????¨???a?????¨???????????????\n\t\trelative_weight[calc_parent[a]] = (relative_b-relative_a) -w;\n\t\tcalc_parent[calc_parent[a]] = calc_parent[b];\n\n\t}\n}\n\nbool isSame(int a,int b){\n\treturn find_parent(a) == find_parent(b);\n}\n\nint main(){\n\n\tint N,M,a,b,w;\n\tparent = new int[100001];\n\theight = new int[100001];\n\tcalc_parent = new int[100001];\n\trelative_weight = new int[100001];\n\tchar command[2];\n\n\twhile(true){\n\t\tscanf(\"%d %d\",&N,&M);\n\t\tif(N == 0 && M == 0)break;\n\n\t\tfor(int i = 1; i <= N; i++){\n\t\t\tparent[i] = i;\n\t\t\theight[i] = 0;\n\t\t\tcalc_parent[i] = i;\n\t\t\trelative_weight[i] = 0; //????????????0???????????????\n\t\t}\n\n\t\tfor(int loop = 0; loop < M; loop++){\n\t\t\tscanf(\"%s %d %d\",command,&a,&b);\n\t\t\tif(command[0] == '!'){ //??¬?????????\n\t\t\t\tscanf(\"%d\",&w);\n\t\t\t\tunite(a,b,w);\n\t\t\t}else{ //???????????????\n\t\t\t\tif(!isSame(a,b)){\n\t\t\t\t\tprintf(\"UNKNOWN\\n\");\n\t\t\t\t}else{\n\t\t\t\t\tprintf(\"%d\\n\",calc_relative_weight(b)-calc_relative_weight(a));\n\t\t\t\t\t//compress_calc_parent(b);\n\t\t\t\t\t//compress_calc_parent(a);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MAX_N 100010\n#define rank dfasoifd\n#define f first\n#define s second\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> P;\nP par[MAX_N];\nint rank[MAX_N];\n\nvoid init(int n){\n  for(int i=0;i<n;i++)par[i]=P(i,0),rank[i]=0;\n}\n\nP find(int x){\n  if(par[x].f==x)return par[x];\n  P r=find(par[x].f);\n  return  par[x]=P(r.f,r.s+par[x].s);\n}\n\nvoid unite(int x,int y,ll c){\n  P X=find(x),Y=find(y);\n  x=X.f,y=Y.f;\n  if(x==y)return;\n  if(rank[x]<rank[y])par[x]=P(y,c+(-X.s+Y.s));\n  else{\n    par[y]=P(x,-c+(+X.s-Y.s));\n    if(rank[x]==rank[y])rank[x]++;\n  }\n}\n\nbool same(int x,int y){return find(x).f==find(y).f;}\n\nint main(){\n  while(1){\n    int n,m;\n    cin>>n>>m;\n    if(!n&&!m)break;\n    init(n);  \n    while(m--){\n      char ch;\n      int a,b,c;\n      cin>>ch>>a>>b;a--,b--;\n      if(ch=='!')cin>>c,unite(a,b,c);      \n      else{\n\tif(same(a,b))printf(\"%lld\\n\",par[a].s-par[b].s);\n\telse printf(\"UNKNOWN\\n\");\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <climits>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <set>\n#include <map>\n#include <iostream>\n#include <deque>\n#include <complex>\n#include <string>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <valarray>\n#include <iterator>\nusing namespace std;\ntypedef long long int lli;\ntypedef unsigned int uint;\ntypedef unsigned char uchar;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\n#define REP(i,x) for(int i=0;i<(int)(x);i++)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n#define RREP(i,x) for(int i=(x);i>=0;i--)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();i++)\n#define ALL(container) container.begin(), container.end()\n#define SZ(container) ((int)container.size())\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"[\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"]\"; return os;\n}\ntemplate<class T> ostream& operator<<(ostream &os, const set<T> &t) {\nos<<\"{\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"}\"; return os;\n}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\n\nconst int INF = 1<<28;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\n\n\nint n, m;\n\nstruct UnionFind {\n\tvector<int> data;\n\tvector<vi> g;\n\tvector<int> W;\n\tUnionFind(int size) : data(size, -1), g(size), W(size, 0) {REP(i, n)g[i].push_back(i);}\n\tbool unionSet(int x, int y, int w) {\n\t\tint rx = root(x), ry = root(y);\n\t\tif (rx != ry) {\n\t\t\tif (data[ry] < data[rx]){\n\t\t\t\tswap(x, y);\n\t\t\t\tswap(rx, ry);\n\t\t\t\tw = -w;\n\t\t\t}\n//\t\t\tprintf(\"%d %d %d %d\\n\", x, y ,rx, ry);\n\t\t\tint rW = W[x] - w - W[y];\n\t\t\tFOR(it, g[ry]) W[*it] += rW;\n\t\t\tg[rx].insert(g[rx].end(), ALL(g[ry]));\n\t\t\tg[ry].clear();\n\t\t\tdata[rx] += data[ry]; data[ry] = rx;\n\t\t}\n\t\treturn rx != ry;\n\t}\n\tbool findSet(int x, int y) {\n\t\treturn root(x) == root(y);\n\t}\n\tint root(int x) {\n\t\treturn data[x] < 0 ? x : data[x] = root(data[x]);\n\t}\n\tint size(int x) {\n\t\treturn -data[root(x)];\n\t}\n\tint query(int x, int y){\n//\t\tprintf(\"%d %d\\n\", W[x], W[y]);\n\t\treturn W[x] - W[y];\n\t}\n};\n\nmain(){\n\tint i,j;\n\twhile(scanf(\"%d%d\", &n, &m), n){\n\t\tUnionFind uf(n);\n\t\tREP(i, m){\n\t\t\tchar c;\n\t\t\tint a, b, w;\n\t\t\tscanf(\" %c %d %d\", &c, &a, &b);\n\t\t\ta--;b--;\n\t\t\tif(c == '?'){\n\t\t\t\tif(uf.findSet(a, b)){\n\t\t\t\t\tprintf(\"%d\\n\", uf.query(a, b));\n\t\t\t\t}else puts(\"UNKNOWN\");\n\t\t\t}else{\n\t\t\t\tscanf(\"%d\", &w);\n\t\t\t\tuf.unionSet(a, b, w);\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, n) for(int i = a; i < n; i++)\n#define int long long\nusing namespace std;\ntypedef pair<int, int> P;\nconst int INF = 1e15;\n\nstruct UF{\n   vector<int> par;\n   vector<int> sz;\n   UF(){}\n   UF(int n){\n       par.resize(n);\n       sz.resize(n, 1);\n       rep(i, 0, n) par[i] = i;\n   }\n   int find(int x){\n       if(x == par[x]) return x;\n       return par[x] = find(par[x]);\n   }\n   void unite(int x, int y){\n       x = find(x); y = find(y);\n       if(x == y) return;\n       if(sz[x] < sz[y]) swap(x, y);\n       sz[x] += sz[y];\n       par[y] = x;\n   }\n   bool same(int x, int y){\n       return find(x) == find(y);\n   }\n};\n\nsigned main(){\n    int n, m;\n    while(cin >> n >> m, n){\n        UF uf(n);\n        vector<int> d(n, INF);\n        rep(i, 0, m){\n            char c;\n            int x, y, w;\n            cin >> c >> x >> y;\n            x--; y--;\n            if(c == '!'){\n                cin >> w;\n                if(!uf.same(x, y)){\n                    uf.unite(x, y);\n                    if(d[x] == INF && d[y] == INF){\n                        d[x] = 0; d[y] = w;\n                    }else if(d[x] == INF){\n                        d[x] = d[y] - w;\n                    }else if(d[y] == INF){\n                        d[y] = d[x] + w;\n                    }\n                }\n            }else{\n                if(!uf.same(x, y)){\n                    cout << \"UNKNOWN\" << endl;\n                }else{\n                    cout << d[y] - d[x] << endl;\n                }\n            }\n        }\n    }   \n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstruct WeightedUnionFind{\n  int n;\n  vector<int>r,p;\n  vector<int>ws;\n  WeightedUnionFind(int sz):n(sz),ws(n,0),r(n,0),p(n,0){iota(p.begin(),p.end(),0);}\n  int find(int x){\n    if(x==p[x])return x;\n    else{\n      int t=find(p[x]);\n      ws[x]+=ws[p[x]];\n      return p[x]=t;\n    }\n  }\n  int weight(int x){\n    find(x);\n    return ws[x];\n  }\n  bool same(int x,int y){\n    return find(x)==find(y);\n  }\n  void unite(int x,int y,int w){\n    w+=weight(x);\n    w-=weight(y);\n    x=find(x);\n    y=find(y);\n    if(x==y)return;\n    if(r[x]<r[y])swap(x,y),w=-w;\n    r[x]+=r[y];\n    p[y]=x;\n    ws[y]=w;\n  }\n  int diff(int x,int y){\n    return weight(y)-weight(x);\n  }\n};\n\nsigned main(){\n  int n,m;\n  while(cin>>n>>m,n||m){\n    WeightedUnionFind U(n+1);\n    while(m--){\n      char c;\n      int x,y,z;\n      cin>>c>>x>>y;\n      if(c=='!'){\n        cin>>z;\n        U.unite(x,y,z);\n      }\n      else{\n        if(!U.same(x,y))cout<<\"UNKNOWN\"<<endl;\n        else cout<<U.diff(x,y)<<endl;\n      }\n    }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <memory.h>\n\nusing namespace std;\n\n//FILE *in = freopen(\"input.txt\", \"r\", stdin);\n//FILE *out = freopen(\"output.txt\", \"w\", stdout);\n\nint n, m;\n\nstruct UnionFind {\n\tvector<int> par; vector<int> rank;\n\tUnionFind(int n){\n\t\tpar = vector<int>(n);\n\t\trank = vector<int>(n);\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tpar[i] = i;\n\t\t}\n\t}\n\tint find(int x) {\n\t\tif(par[x]==x) return x;\n\t\telse return find(par[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif(x == y) return;\n\t\tif(rank[x]<rank[y])\n\t\t\tpar[x] = y;\n\t\telse {\n\t\t\tpar[y] = x;\n\t\t\tif(rank[x]==rank[y])rank[x]++;\n\t\t}\n\t}\n\tinline bool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n};\n\nint bfs(vector<vector<pair<int,int>>> data, int a, int b) {\n\tbool chk[100001];\n\tmemset(chk, 0, sizeof(chk));\n\tqueue<pair<int,int>> que;\n\tque.push(make_pair(a, 0));\n\tchk[a] = true;\n\twhile(!que.empty()){\n\t\tint cur = que.front().first;\n\t\tint val = que.front().second;\n\t\tque.pop();\n\t\tif(cur == b)\n\t\t\treturn val;\n\n\t\tfor(int i = 0; i < data[cur].size(); i++) {\n\t\t\tif(chk[data[cur][i].first]) continue;\n\t\t\tif(data[cur][i].first == b) {\n\t\t\t\treturn val+data[cur][i].second;\n\t\t\t}\n\t\t\tchk[data[cur][i].first] = true;\n\t\t\tque.push(make_pair(data[cur][i].first, val + data[cur][i].second));\n\t\t}\n\t}\n\treturn -1;\n}\n\nvoid process() {\n\tUnionFind uf(n+1);\n\tvector<vector<pair<int,int>>> data(n+1);\n\tchar tt[10];\n\tint a, b, c;\n\tfor(int k = 0; k < m; k++) {\n\t\tscanf(\"%s%d%d\", tt, &a, &b);\n\t\tif(tt[0] == '!') {\n\t\t\tscanf(\"%d\", &c);\n\t\t\tif(uf.same(a,b)) continue;\n\t\t\tdata[a].push_back(make_pair(b, c));\n\t\t\tdata[b].push_back(make_pair(a, -c));\n\t\t\tuf.unite(a,b);\n\t\t}\n\t\telse {\n\t\t\tif(!uf.same(a, b)) {\n\t\t\t\tprintf(\"UNKNOWN\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tprintf(\"%d\\n\", bfs(data, a, b));\n\t\t}\n\t}\n}\n\nint main() {\n\twhile(true){\n\t\tscanf(\"%d%d\", &n, &m);\n\t\tif(n == 0)break;\n\t\tprocess();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcount\n\n#define INF 1e16\n#define mod 1000000007\n\nll n,m;\nvector<ll> par,sz,dep;\nvector<vector<ll> > child;\n\nll find(ll x){\n  if(par[x]==-1)return x;\n  else return find(par[x]);\n}\n\nvoid rec(ll v,ll pre,ll add){\n  dep[v]+=add;\n  for(ll nv : child[v]){\n    if(nv==v)continue;\n    rec(nv,v,add);\n  }\n}\n\nint main(){\n  while(1){\n    cin>>n>>m;\n    if(n==0)break;\n    par.resize(n);\n    sz.resize(n);\n    dep.resize(n);\n    child.resize(n);\n    rep(i,n){\n      par[i]=-1;\n      sz[i]=1;\n      dep[i]=0;\n    }\n    rep(i,m){\n      char t;\n      cin>>t;\n      if(t=='!'){\n        ll a,b,c;\n        cin>>a>>b>>c;\n        a--;b--;\n        ll pa=find(a);\n        ll pb=find(b);\n        if(pa==pb)continue;\n        if(sz[pa]<sz[pb]){\n          swap(pa,pb);\n          swap(a,b);\n          c=-c;\n        }\n        par[pb]=pa;\n        ll x=dep[a]-dep[b]+c;\n        rec(pb,pa,x);\n        child[pa].push_back(pb);\n        sz[pa]+=sz[pb];\n      }else{ \n        ll a,b;\n        cin>>a>>b;\n        a--;b--;\n        ll pa=find(a);\n        ll pb=find(b);\n        if(pa!=pb){\n          cout<<\"UNKNOWN\"<<endl;\n        }else{\n          cout<<-dep[a]+dep[b]<<endl;\n        }\n      }\n    }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// Wrongri-La Shower\n\n#include <cstdio>\n#include <queue>\n#include <stack>\n#include <tuple>\n\ntypedef long long ll;\ntypedef std::tuple<int,ll> P;\n\ntemplate <int n>\nclass UnionFind{\npublic:\n    UnionFind(){\n        init();\n    }\n    void init(){\n        for(int i=0;i<n;i++){\n            par[i] = i;\n            rank[i] = 0;\n            weight[i] = 0ll;\n        }\n    }\n    P find(int x){\n        if(x == par[x])return std::make_tuple(x, weight[x]);\n\n        std::stack<int> v_stack;\n        std::queue<ll> w_queue;\n        ll w = 0;\n        while(x != par[x]){\n            w += weight[x];\n            w_queue.push(w);\n            v_stack.push(x);\n\n            x = par[x];\n        }\n        \n        while(!v_stack.empty()){\n            int a; ll b;\n            a = v_stack.top(); v_stack.pop();\n            b = w_queue.front(); w_queue.pop();\n            \n            par[a] = x;\n            weight[a] = b;\n        }\n        \n        return std::make_tuple(x, w);\n    }\n    bool same(int x, int y){\n        return std::get<0>(find(x)) == std::get<0>(find(y));\n    }\n    void unite(int x, int y, int l){\n        P xp = find(x), yp = find(y);\n        ll wx, wy;\n        std::tie(x, wx) = xp;\n        std::tie(y, wy) = yp;\n        \n        if(x == y){return;}\n        \n        if(rank[x] > rank[y]){\n            par[y] = x;\n            weight[y] = wx + l;\n        }else{\n            par[x] = y;\n            weight[x] = wy - l;\n            if(rank[x] == rank[y]){rank[y]++;}\n        }\n    }\n    int rank[n], par[n];\n    ll weight[n];\n};\n\nUnionFind<100001> uf;\n\nint main(){\n    int N, M;\n    while(scanf(\"%d %d\", &N, &M), N || M){\n        uf.init();\n\n        for(int i=0;i<M;i++){\n            char c;\n            scanf(\"%*c%c\", &c);\n            \n            if(c == '!'){\n                int a, b, c;\n                scanf(\"%d %d %d\", &a, &b, &c);\n\n                uf.unite(a, b, c);\n            }else{\n                int a, b;\n                scanf(\"%d %d\", &a, &b);\n\n                if(!uf.same(a, b)){\n                    puts(\"UNKNOWN\");\n                }else{\n                    P ap = uf.find(a), bp = uf.find(b);\n                    ll wa = std::get<1>(ap), wb = std::get<1>(bp);\n\n                    printf(\"%lld\\n\", wb - wa);\n                }\n            }\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<map>\nusing namespace std;\n\n#define fs first\n#define sc second\ntypedef pair<int,int> P;\n\nP par[100001],x,y,tmp;\nint rank[100001];\n\nP find(int a){\n  if(par[a].fs == a)return par[a];\n  tmp = find(par[a].fs);\n  return par[a] = P(tmp.fs,tmp.sc + par[a].sc);\n}\n\nint main(){\n  char c;\n  int a,b,w,n,m;\n  while(scanf(\"%d%d\",&n,&m),(n||m)){\n    for(int i=1;i<=n;i++){\n      par[i] = P(i,0); rank[i] = 0;\n    }\n\n    for(int i=0;i<m;i++){\n      scanf(\" %c \",&c);\n      if(c=='?'){\n\tscanf(\"%d%d\",&a,&b);\n\tif(find(a).fs==find(b).fs)printf(\"%d\\n\",par[b].sc - par[a].sc);\n\telse printf(\"UNKNOWN\\n\");\n      }else{\n\tscanf(\"%d%d%d\",&a,&b,&w);\n\n\tx = find(a); y = find(b);\n\t\n\tif(x.fs!=y.fs){\n\t  if(rank[x.fs]<rank[y.fs]){\n\t    par[x.fs] = P(y.fs,y.sc-x.sc-w);\n\t  }else{\n\t    par[y.fs] = P(x.fs,x.sc-y.sc+w);\n\t    if(rank[x.fs] == rank[y.fs])rank[x.fs]++;\n\t  }\n\t}\n      }\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<map>\nusing namespace std;\n\nclass UF {\n    public:\n    vector<pair<int,int> > l;\n    UF(int n) {\n        for(int i=0; i<n; i++)\n            l.push_back(pair<int,int>(i,0));\n    }\n    pair<int,int> root(int x) {\n        if(x == l[x].first) return l[x];\n        pair<int,int> t = root(l[x].first);\n        l[x].first = t.first ;\n        l[x].second+= t.second;\n        return l[x];\n    }\n    void unite(int x, int y, int xMy) {\n        x = root(x).first;\n        pair<int,int> t = root(y);\n        y = t.first;\n        if(x == y) return;\n        l[y].first = l[x].first;\n        l[y].second= -(-xMy + t.second);\n    }\n    int weight(int x, int y) { // x - y else 123456\n        pair<int,int> s,t;\n        s = root(x);\n        t = root(y);\n        if(s.first != t.first) return 123456;\n        return s.second - t.second;\n    }\n};\n\n\nint main(void) {\n    while(1) {\n        int n,m;\n        scanf(\"%d%d\",&n,&m);\n        if(!n) break;\n        UF uf(n);\n        for(int i=0; i<m; i++) {\n            int a,b;\n            char s[3];\n            scanf(\"%s%d%d\",s,&a,&b);\n            a--, b--;\n            if(s[0] == '?') {\n                int w = uf.weight(b,a);\n                if(w == 123456)\n                    printf(\"UNKNOWN\\n\");\n                else\n                    printf(\"%d\\n\", w);\n            }\n            else {\n                int w;\n                scanf(\"%d\",&w);\n                uf.unite(b, a, w);\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <utility>\n#include <string>\n#include <iostream>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,ll> P;\nint n,m;\nP par[100001];\nP operator +(P p1,P p2){\n\treturn P(p1.first+p2.first,p1.second+p2.second);\n}\nint rank[100001];\n\nvoid init(){\n\tfor(int i=1;i<=n;i++){\n\t\tpar[i]=P(i,0);\n\t\trank[i]=0;\n\t}\n}\n\nP find(int x){\n\tif(par[x].first==x)return par[x];\n\treturn par[x]=(find(par[x].first)+P(0,par[x].second));\n}\n\nbool same(int a,int b){\n\treturn find(a).first==find(b).first;\n}\n\nvoid unite(int a,int b,int w){\n\tP da=find(a);\n\tP db=find(b);\n\ta=da.first;\n\tb=db.first;\n\tll aa=da.second,bb=db.second;\n\tif(rank[a]<rank[b]){\n\t\tpar[a]=P(b,-w-aa+bb);\n\t}else{\n\t\tpar[b]=P(a,w-bb+aa);\n\t\tif(rank[a]==rank[b])rank[a]++;\n\t}\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d %d\",&n,&m);\n\t\tif(n+m==0)break;\n\t\tinit();\n\t\tfor(int i=0;i<m;i++){\n\t\t\tstring q;\n\t\t\tcin >> q;\n\t\t\tint a,b,w;\n\t\t\tif(q==\"!\"){\n\t\t\t\tscanf(\"%d %d %d\",&a,&b,&w);\n\t\t\t\tunite(a,b,w);\n\t\t\t}else if(q==\"?\"){\n\t\t\t\tscanf(\"%d %d\",&a,&b);\n\t\t\t\tif(!same(a,b))printf(\"UNKNOWN\\n\");\n\t\t\t\telse printf(\"%lld\\n\",par[b].second-par[a].second);\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)n;++i)\n#define each(a, b) for(auto (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout <<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout <<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define svec(v) cout<<#v<<\":\";rep(i,v.size())cout<<\" \"<<v[i];cout<<endl\n#define sset(s) cout<<#s<<\":\";each(i,s)cout <<\" \"<<i;cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int>P;\n\nconst int MAX_N = 100005;\n\nint par[MAX_N];\nint nrank[MAX_N];\nint weight[MAX_N];\n\nvoid initial(int n){\t\t//?????????\n\tfor(int i=0;i<n;i++){\n\t\tpar[i] = i;\n\t\tnrank[i] = 0;\n        weight[i] = 0;\n\t}\n}\n\nP find(int x){\t\t//??¨??????????±???????\n\tif(par[x] == x){\n\t\treturn P(x,0);\n\t}else{\n\t\tP p = find(par[x]);\n\t\tpar[x] = p.fi;\n\t\tweight[x] = p.se + weight[x];\n\t\treturn P(par[x],weight[x]);\n\t}\n}\n\nvoid unite(int x,int y,int w){\n\tint bx = x;\n\tint by = y;\n\tx = (find(x)).fi;\n\ty = (find(y)).fi;\n\tif(x == y) return;\n\tif(nrank[x] < nrank[y]){\n\t\tpar[x] = y;\n\t\tweight[x] = -weight[bx] - w + weight[by];\n\t}else{\n\t\tpar[y] = x;\n        weight[y] = weight[bx] + w - weight[by];\n\t\tif(nrank[x] == nrank[y])\n\t\t\tnrank[x]++;\n\t}\n}\n\nbool same(int x,int y){\n\treturn (find(x)).fi == (find(y)).fi;\n}\n\nint main()\n{\n    while(1){\n        int n,m;\n        cin >> n >> m;\n        if(n == 0){\n            break;\n        }\n        initial(n+1);\n        rep(i,m){\n            int a,b,w;\n            char hoge,c;\n            scanf(\"%c%c\",&hoge,&c);\n            if(c == '!'){\n                scanf(\"%d%d%d\",&a,&b,&w);\n                unite(a,b,w);\n            }else{\n                scanf(\"%d%d\",&a,&b);\n                if(same(a,b)){\n                    cout << weight[b]-weight[a] << \"\\n\";\n                }else{\n                    cout << \"UNKNOWN\\n\";\n                }\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MAX_N 100010\n#define rank dfasoifd\n#define f first\n#define s second\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> P;\nP par[MAX_N];\nint rank[MAX_N];\n\nvoid init(int n){\n  for(int i=0;i<n;i++)par[i]=P(i,0),rank[i]=0;\n}\n\nP find(int x){\n  if(par[x].f==x)return par[x];\n  P r=find(par[x].f);\n  return  par[x]=P(r.f,r.s+par[x].s);\n}\n\nvoid unite(int x,int y,ll c){\n  P X=find(x),Y=find(y);\n  x=X.f,y=Y.f;\n  if(x==y)return;\n  if(rank[x]<rank[y])par[x]=P(y,c+(-X.s+Y.s));\n  else{\n    par[y]=P(x,-c+(+X.s-Y.s));\n    if(rank[x]==rank[y])rank[x]++;\n  }\n}\n\nbool same(int x,int y){return find(x).f==find(y).f;}\n\nint main(){\n  while(1){\n    int n,m;\n    cin>>n>>m;\n    if(!n&&!m)break;\n    init(n);  \n    while(m--){\n      char ch;\n      int a,b,c;\n      cin>>ch>>a>>b;a--,b--;\n      if(ch=='!')cin>>c,unite(a,b,c);      \n      else{\n\tif(same(a,b))printf(\"%lld\\n\",par[a].s-par[b].s);\n\telse printf(\"UNKNOWN\\n\");\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n\nusing namespace std;\nusing T = int;\n\nstruct WeightedUnionFind {\n    vector<int> parent;\n    vector<T> weight;\n    //親は小さい\n\n    WeightedUnionFind(int n){\n        parent = vector<int>(n, -1);\n        weight = vector<T>(n,0);\n    }\n    bool Find(int x, int y){\n        return root(x) == root(y); \n    }\n    int root(int x){\n        if(parent[x] < 0){\n            return x;\n        }else{\n            int pare = root(parent[x]);\n            weight[x] += weight[parent[x]];\n            return parent[x] = pare;\n        }\n    }\n    T Weight(int x){\n        root(x);\n        return weight[x];\n    }\n    //x <= y \n    bool Union(int x, int y, int w){\n        w += Weight(x);\n        w -= Weight(y);\n        x = root(x); y = root(y);\n\n        if(x != y){\n            if(parent[y] < parent[x]){\n                swap(x,y); w = -w;\n            }\n            parent[x] += parent[y]; parent[y] = x;\n            weight[y] = w;\n            return true;\n        }else{\n            return false;\n        }\n    }\n    int size(int x){\n        return -parent[root(x)];\n    }\n    T diff(int x, int y){\n        return Weight(x) - Weight(y);\n    }\n};\n\nint main() {\n    for(;;){\n        int N, M;\n        int a, b, d;\n        char str;\n        cin >> N >> M;\n        if (N==0) break;\n        WeightedUnionFind wuf(N);\n        for(int i=0; i< M ;i++){\n            cin >> str;\n            if(str=='!'){\n                cin >> a >> b >> d;\n                wuf.Union(a,b,d);\n            }else{\n                cin >> a >> b;\n                if(wuf.Find(a,b)){\n                    cout << wuf.diff(b,a) << endl;\n                }else{\n                    cout << \"UNKNOWN\" << endl;\n                }\n            }\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cassert>\n#include<algorithm>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<28)\n#define MAX 1000000\nusing namespace std;\nstruct P\n{\n  int color,w;\n  P(int color=-inf,int w=-inf):color(color),w(w){}\n};\nP par[MAX];\nvoid init(){ rep(i,MAX)par[i] = P(i); }\n\nP find(int x)\n{\n  if(x == par[x].color)return par[x];\n  P p = find(par[x].color);\n  if(par[x].color == -inf)par[x].color = 0;\n  par[x].w += p.w,par[x].color = p.color;\n  return par[x];\n}\n\nvoid unit(int x,int y,int w)//x <= y\n{\n  P X = find(x);\n  P Y = find(y);\n  assert(X.color != Y.color);\n  par[X.color].color = par[Y.color].color;\n  if(par[X.color].w == -inf)par[X.color].w = 0;\n  if(par[Y.color].w == -inf)par[Y.color].w = 0;\n  par[X.color].w = par[X.color].w - w + (Y.w != -inf?Y.w:0);\n}\n\nint N,M;\n\nint main()\n{\n  while(cin >> N >> M,N|M)\n    {\n      init();\n      char c;\n      int a,b,w;\n      rep(_,M)\n\t{\n\t  cin >> c;\n\t  if(c == '!')\n\t    {\n\t      cin >> a >> b >> w;\n\t      unit(a,b,w);\n\t    }\n\t  else\n\t    {\n\t      cin >> a >> b;\n\t      int B = find(b).w;\n\t      int A = find(a).w;\n\t      if(B == -inf || A == -inf)cout << \"UNKNOWN\" << endl;\n\t      else cout << B-A << endl;\n\t    }\n\t\n\t}\n    }\n  return 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <utility>\n#include <set>\n#include <map>\n#include <deque>\n#include <queue>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio>\n#include <stdio.h>\n\nusing namespace std;\n\n#define fo(i,n) for(int i=0; i<(int)n; i++)\n#define rep(it,s) for(__typeof((s).begin()) it=(s).begin();it!=(s).end();it++)\n#define mp(a,b) make_pair(a,b)\n#define pb(x) push_back(x)\n#define pii pair<int,int>\n\nint n,m;\nint par[100010];\nlong long w[100010];\n\nint get(int a) {\n\tif (a==par[a]) return a;\n\tint p = par[a];\n\tp = get(p);\n\tw[a] += w[par[a]];\n\tpar[a] = p;\n\treturn par[a];\n}\n\nvoid connect(int a, int b, int c) {\n\tint i = get(a);\n\tint j = get(b);\n\tpar[i] = j;\n\tw[i] = -(w[j] - c - w[i]);\n}\n\nint main() {\n\n    //freopen(\"input.txt\",\"r\",stdin);\n    //freopen(\"output.txt\",\"w\",stdout);\n\n\twhile (scanf(\"%d%d\",&n,&m) && n!=0) {\n\t\tfor (int i=0; i<n; i++) par[i] = i;\n\t\tfor (int i=0; i<n; i++) w[i] = 0;\n\t\t\n\t\tfor (int i=0; i<m; i++) {\n\t\t\tchar c[5];\n\t\t\tscanf(\"%s\",c);\n\t\t\tif (c[0]=='!') {\n\t\t\t\tint a,b,d;\n\t\t\t\tscanf(\"%d%d%d\",&a,&b,&d);\n\t\t\t\ta--; b--;\n\t\t\t\tif (get(a)==get(b)) continue;\n\t\t\t\tconnect(a,b,d);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tint a,b;\n\t\t\t\tscanf(\"%d%d\",&a,&b);\n\t\t\t\ta--; b--;\n\t\t\t\tif (get(a)!=get(b)) {\n\t\t\t\t\tprintf(\"UNKNOWN\\n\");\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tprintf(\"%lld\\n\",w[a]-w[b]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n    return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define all(v) (v).begin(),(v).end()\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\n#define pb push_back\n#define fi first\n#define se second\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nstruct UF{\n    vint par,sz;\n    vector<set<int>>st;\n    vint dif;\n    void init(int n){\n        par=sz=dif=vint(n);\n        st=vector<set<int>>(n);\n        rep(i,n){\n            par[i]=i;\n            sz[i]=1;\n            dif[i]=0;\n            st[i].insert(i);\n        }\n    }\n    int find(int x){\n        return x==par[x]?x:par[x]=find(par[x]);\n    }\n    void update(int a,int b,int w){\n        int x=find(a),y=find(b);\n        if(x==y)return;\n        if(sz[x]>sz[y]){\n            swap(x,y);\n            swap(a,b);\n            w*=-1;\n        }\n\n        for(auto v:st[x]){\n            dif[v]+=dif[b]-dif[a]-w;\n            st[y].insert(v);\n        }\n        sz[y]+=sz[x];\n        par[x]=y;\n    }\n    int query(int a,int b){\n        int x=find(a),y=find(b);\n        if(x!=y)return 1001001001;\n        return dif[b]-dif[a];\n    }\n};\n\nsigned main(){\n    int N,Q;\n    while(scanf(\"%lld%lld\",&N,&Q),N||Q){\n        UF uf;uf.init(N);\n        rep(i,Q){\n            char c;\n            scanf(\" %c\",&c);\n            if(c=='!'){\n                int a,b,w;\n                scanf(\"%lld%lld%lld\",&a,&b,&w);\n                a--;b--;\n                uf.update(a,b,w);\n            }\n            else{\n                int a,b;\n                scanf(\"%lld%lld\",&a,&b);\n                a--;b--;\n                int tmp=uf.query(a,b);\n                if(tmp==1001001001)puts(\"UNKNOWN\");\n                else printf(\"%lld\\n\",tmp);\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <list>\n#include <set>\n#include <map>\n#include <queue>\n\nusing namespace std;\n#define DEBUG(x) cout<<#x<<\": \"<<x<<endl\n\n#define PB push_back\n#define MP make_pair\n#define F first\n#define S second\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n#define INT(a) int((a)+1e-9)\nint DX[4]={1,0,-1,0};\nint DY[4]={0,1,0,-1};\n\ntypedef pair<int,int> Pii;\n\n\n#define SUPnl 100002\n\nint nl;\nPii pt[SUPnl];\t//pt[n].F == n's parent, pt[n].S == w[pt[n].F]-w[n]\n\nvoid init(){REP(ni,nl){pt[ni]=MP(ni,0);}}\n\nPii getRoot(int n){\n\tif(pt[n].F==n) return pt[n];\n\tPii rpnt = getRoot(pt[n].F);\n\tpt[n]= MP(rpnt.F, rpnt.S+pt[n].S);\n\treturn pt[n];\n}\n\nvoid printW(int a, int b){\n\tPii rat=getRoot(a); Pii rbt=getRoot(b);\n\tif(rat.F!=rbt.F) printf(\"UNKNOWN\\n\");\n\telse printf(\"%d\\n\", rbt.S - rat.S );\n}\n\nvoid setW(int a, int b, int w){\n\tPii rat=getRoot(a); Pii rbt=getRoot(b);\n\tif(rat.F==rbt.F) return;\n\tif(rat.S+w>=rbt.S){\n\t\tpt[rbt.F]=MP(rat.F, rat.S+w-rbt.S);\n\t}else{\n\t\tpt[rat.F]=MP(rbt.F, rbt.S-w-rat.S);\n\t}\n}\n\nint main(){\n\twhile(true){\n\t\tint ol;\n\t\tscanf(\"%d%d\", &nl, &ol);\n\t\t\t\t\t\t\tif(!nl) return 0;\n\t\tinit();\n\t\tREP(oi,ol){\n\t\t\tchar ot; int a,b,w;\n\t\t\tscanf(\" %c \", &ot);\n\t\t\tif(ot=='!'){\n\t\t\t\tscanf(\"%d%d%d\",&a,&b,&w);\n\t\t\t\tsetW(a-1,b-1,w);\n\t\t\t}\n\t\t\tif(ot=='?'){\n\t\t\t\tscanf(\"%d%d\",&a,&b);\n\t\t\t\tprintW(a-1,b-1);\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<cstdio>\n\nusing namespace std;\nusing T = int;\n\nstruct WeightedUnionFind {\n    vector<int> parent;\n    vector<T> weight;\n    vector<int> myrank;\n    //親は小さい\n    WeightedUnionFind(int n) : parent(n,-1), weight(n,0), myrank(n,0) { }\n    bool Find(int x, int y){\n        return find_root(x) == find_root(y); \n    }\n    int find_root(int x){\n        if(parent[x] < 0){\n            return x;\n        }else{\n            int pare = find_root(parent[x]);\n            weight[x] += weight[parent[x]];\n            return parent[x] = pare;\n        }\n    }\n    T Weight(int x){\n        find_root(x);\n        return weight[x];\n    }\n    //x <= y \n    bool Union(int x, int y, int w){\n        w += Weight(x);\n        w -= Weight(y);\n        x = find_root(x); y = find_root(y);\n\n        if(x != y){\n            if(myrank[y] < myrank[x]){\n                swap(x,y); w = -w;\n            }\n            parent[x] += parent[y]; parent[y] = x;\n            weight[y] = w;\n            if(myrank[x] == myrank[y]) myrank[x]++;\n            return true;\n        }else{\n            return false;\n        }\n    }\n    int size(int x){\n        return -parent[find_root(x)];\n    }\n    T diff(int x, int y){\n        return Weight(x) - Weight(y);\n    }\n};\n\nint main() {\n    int N, M;\n    int a, b, d;\n    //string str;\n    char str;\n    for(;;){\n        cin >> N >> M;\n        \n        if (N==0) break;\n        WeightedUnionFind wuf(N);\n        for(int i=0; i< M ;i++){\n            cin >> str;\n            if(str=='!'){\n                cin >> a >> b >> d;\n                a--;b--;\n                wuf.Union(a,b,d);\n            }else{\n                cin >> a >> b;\n                a--;b--;\n                if(wuf.Find(a,b)){\n                    cout << wuf.diff(b,a) << \"\\n\";\n                }else{\n                    cout << \"UNKNOWN\" << \"\\n\";\n                }\n            }\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <map>\n#include <vector>\n#include <queue>\nusing namespace std;\ntypedef pair<int,int> P;\nvector<int> V[100000+10];\nint main() {\n    int n, m;\n    char input[100];\n    while(~scanf(\"%d%d\", &n, &m)) {\n        if (n == 0 && m == 0) break;\n        for (int i = 0; i <= n; i++) {V[i].pop_back();}\n        map<P, int> M;\n        for (int i = 0; i < m; i++) {\n            scanf(\"%s\", input);\n            if (input[0] == '!') {\n                int a, b, w;\n                scanf(\"%d%d%d\", &a, &b, &w);\n                P tmpP;\n                tmpP.first = a; tmpP.second = b;\n                V[a].push_back(b);V[b].push_back(a);\n                M[tmpP] = w;\n                tmpP.first = b; tmpP.second = a;\n                M[tmpP] = -w;\n            } else { // ?\n                P tmpP;\n                scanf(\"%d%d\", &tmpP.first, &tmpP.second);\n                if (M.find(tmpP) != M.end()) {\n                    printf(\"%d\\n\", M[tmpP]);\n                } else {\n                    int st = tmpP.first, ed = tmpP.second;\n                    queue< P > Q;\n                    queue<int> COST;\n                    P OAO; OAO.second = st;\n                    for (int i = 0; i < V[st].size(); i++) {\n                        OAO.first = V[st][i];\n                        COST.push(M[OAO]);\n                        Q.push(OAO);\n                    }\n                    int cost = -1;\n                    while(!Q.empty()) {\n                        P QAQ = Q.front(); Q.pop();\n                        int ccc = COST.front(); COST.pop();\n                        if (QAQ.first == ed) {cost = ccc; break;}\n                        for (int i = 0; i < V[QAQ.first].size(); i++) {\n                            if (V[QAQ.first][i] != QAQ.second) {\n                                P ttt; ttt.first = V[QAQ.first][i]; ttt.second = QAQ.first;\n                                Q.push(ttt);\n                                COST.push(M[ttt] + ccc);\n                            }\n                        }\n                    }\n                    if (cost == -1)\n                        printf(\"UNKNOWN\\n\");\n                    else\n                        printf(\"%d\\n\", cost);\n                }\n            }\n        }\n    }\n    return 0;\n}\n/*\n2 2\n! 1 2 1\n? 1 2\n2 2\n! 1 2 1\n? 2 1\n4 7\n! 1 2 100\n? 2 3\n! 2 3 100\n? 2 3\n? 1 3\n! 4 3 150\n? 4 1\n0 0\n*/"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cassert>\n#include<algorithm>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<29)\n#define MAX 1000000\nusing namespace std;\ntypedef long long ll;\nstruct P\n{\n  ll color,w;\n  P(ll color=-inf,ll w=-inf):color(color),w(w){}\n};\nP par[MAX];\nvoid init(){ rep(i,MAX)par[i] = P(i); }\n\nP find(int x)\n{\n  if(x == par[x].color)return par[x];\n  P p = find(par[x].color);\n  if(par[x].color == -inf)par[x].color = 0;\n  par[x].w += p.w,par[x].color = p.color;\n  return par[x];\n}\n\nvoid unit(int x,int y,ll w)//x <= y\n{\n  P X = find(x); \n  P Y = find(y);\n  if(X.color == Y.color)return;\n  par[X.color].color = par[Y.color].color;\n  if(par[X.color].w == -inf)par[X.color].w = 0;\n  if(par[Y.color].w == -inf)par[Y.color].w = 0;\n  par[X.color].w = par[X.color].w + (par[y].w-w - par[x].w);\n  //par[x].w -= par[y].w;\n}\n\nint N,M;\n\nint main()\n{\n  while(cin >> N >> M,N|M)\n    {\n      init();\n      char c;\n      ll a,b,w;\n      rep(_,M)\n\t{\n\t  cin >> c;\n\t  if(c == '!')\n\t    {\n\t      cin >> a >> b >> w;\n\t      unit(a,b,w);\n\t    }\n\t  else\n\t    {\n\t      cin >> a >> b;\n\t      ll B = find(b).w;\n\t      ll A = find(a).w;\n\t      if(B == -inf || A == -inf)cout << \"UNKNOWN\" << endl;\n\t      else cout << B-A << endl;\n\t    }\n\n\t  rep(i,10)\n\t    {\n\t      // cout << i << \" = \" << par[i].color << \",\" << par[i].w << endl;\n\t    }\t\n\t  //cout << endl;\n\n\t}\n    }\n  return 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<vector>\n#include<cassert>\nusing namespace std;\n\nclass DisjointSet{\n public:\n  vector<int> rank, p, w;\n\n  DisjointSet(){}\n  DisjointSet(int size){\n    rank.resize(size, 0);\n    p.resize(size, 0);\n    w.resize(size, 0);\n    for(int i=0; i<size; i++) makeSet(i);\n  }\n\n  void makeSet(int x){\n    p[x] = x;\n    rank[x] = 0;\n    w[x] = 0;\n  }\n\n  void unite(int x, int y){\n    link(findSet(x).first, findSet(y).first);\n  }\n\n  void uniteW(int x, int y, int v){\n    pair<int, int> px = findSet(x);\n    pair<int, int> py = findSet(y);\n    if ( px.first == py.first ) return;\n    x = px.first;\n    y = py.first;\n    if ( rank[x] < rank[y] ){\n      p[x] = y;\n      w[x] = (v - px.second + py.second);\n    } else {\n      p[y] = x;\n      w[y] = -(v - px.second + py.second);\n      if ( rank[x] == rank[y] ) rank[x]++;\n    }\n  }\n\n  bool same(int x, int y){\n    return findSet(x).first == findSet(y).first;\n  }\n int getDiff(int x, int y){\n    return findSet(x).second - findSet(y).second;\n  }\n\n  void link(int x, int y){\n    if(rank[x] > rank[y]){\n      p[y] = x;\n    }else{\n      p[x] = y;\n      if(rank[x] == rank[y]){\n        rank[y] = rank[y] + 1;\n      }\n    }\n  }\n\n  pair<int, int> findSet(int x){\n    if(x != p[x]){\n      pair<int,int> tmp =  findSet(p[x]);\n      p[x] = tmp.first;\n      w[x] += tmp.second;\n    }\n    return make_pair(p[x], w[x]);\n  }\n};\n\nint main(){\n  int N, M;\n  char com;\n  int  a, b, w;\n\n  while(1){\n    cin >> N >> M;\n    if ( N == 0 && M == 0 ) break;\n\n    DisjointSet ds = DisjointSet(N);\n\n    for ( int i = 0; i < M; i++ ){\n      cin >> com;\n      if ( com == '!' ){\n        cin >>  a >> b >> w;\n        ds.uniteW(a, b, w);\n      } else if ( com == '?' ){\n        cin >> a >> b;\n        if ( ds.same(a, b) ) {\n          cout << ds.getDiff(a, b) << endl;\n        } else {\n          cout << \"UNKNOWN\" << endl;\n        }\n      }\n    }\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\nclass UnionFind {\n\tvector<int> data;\n\tvector<ll> val;\n\tint root(int a) {\n\t\treturn data[a] < 0 ? a : root(data[a]);\n\t}\npublic:\n\tUnionFind(int n) : data(n, -1), val(n, 0) {}\n\tbool Find(int a, int b) {\n\t\treturn root(a) == root(b);\n\t}\n\tvoid Union(int a, int b, ll v) {\n\t\tv += dis(a);\n\t\ta = root(a);\n\t\tv -= dis(b);\n\t\tb = root(b);\n\t\tif (a == b) return;\n\t\tif (data[a] < data[b]) {\n\t\t\tdata[a] += data[b];\n\t\t\tdata[b] = a;\n\t\t\tval[b] = v;\n\t\t}\n\t\telse {\n\t\t\tdata[b] += data[a];\n\t\t\tdata[a] = b;\n\t\t\tval[a] = -v;\n\t\t}\n\t}\n\tll dis(int a) {\n\t\treturn data[a] < 0 ? 0 : val[a] + dis(data[a]);\n\t}\n\tint Size(int a) {\n\t\treturn -data[root(a)];\n\t}\n};\n\nint main()\n{\n\tcin.sync_with_stdio(false);\n\tint N, M, a, b, w;\n\tchar c;\n\twhile (cin >> N >> M, N | M) {\n\t\tUnionFind uf(N);\n\t\tfor (int i = 0; i < M; i++) {\n\t\t\tcin >> c >> a >> b; a--; b--;\n\t\t\tif (c == '!') {\n\t\t\t\tcin >> w;\n\t\t\t\tuf.Union(a, b, w);\n\t\t\t}\n\t\t\telse if (uf.Find(a, b)) {\n\t\t\t\tprintf(\"%lld\\n\", uf.dis(b) - uf.dis(a));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tputs(\"UNKNOWN\");\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\ntypedef long long int ll;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000001\nusing namespace std;\n\nint* parent; //????????°?????????????±?????????????????????????????????????????????????????????¨\nint* height; //????????°?????????????±?????????????????????????????????????????????????????????¨\n\n\nint* calc_parent;\nint* relative_weight; //?????????????????¨??????????????????????????????????????????\n\nint find_parent(int id){\n\tif(parent[id] == id)return id;\n\telse{\n\t\treturn parent[id] = find_parent(parent[id]);\n\t}\n}\n\nint find_calc_parent(int id){\n\tif(calc_parent[id] == id)return id;\n\telse{\n\t\t//return calc_parent[id] = find_calc_parent(calc_parent[id]);\n\t\treturn calc_parent[id] = find_calc_parent(calc_parent[id]); //?????????????????§??????????????????\n\t}\n}\n\n//calc_parent???????????§????????????\nint compress_calc_parent(int id){\n\tif(calc_parent[id] == id)return id;\n\telse{\n\t\treturn calc_parent[id] = find_calc_parent(calc_parent[id]);\n\t}\n}\n\n//??????????????????????????????????¨??????????\nint calc_relative_weight(int id){\n\n\tint calc_p = find_calc_parent(id);\n\tif(calc_parent[id] == calc_p){ //????????§??????????????????????????´???\n\t\treturn relative_weight[id];\n\t}else{ //????????§?????????????????????????????´???\n\t\tif(calc_parent[id] == id){\n\t\t\treturn 0; //????????????????????????0\n\t\t}else{\n\t\t\treturn relative_weight[id] = relative_weight[id] + calc_relative_weight(calc_parent[id]);\n\t\t}\n\t}\n}\n\n//??°??????????????±????????????????????????????????¨?????±????????????\nvoid unite(int a,int b,int w){\n\n\t//?????????\n\tint a_parent = find_parent(a);\n\tint b_parent = find_parent(b);\n\n\tif(a_parent == b_parent)return; //????????°???????????????calc_parent??¨?????±??????????????????????????????\n\n\t//??±?????????\n\tif(height[a_parent] == height[b_parent]){\n\t\tparent[b_parent] = a_parent;\n\t\theight[a_parent]++;\n\t}else if(height[a_parent] > height[b_parent]){\n\t\tparent[b_parent] = a_parent;\n\t}else{\n\t\tparent[a_parent] = b_parent;\n\t}\n\n\tint relative_a = calc_relative_weight(a);\n\tint relative_b = calc_relative_weight(b);\n\n\t//printf(\"relative_a:%d relative_b:%d\\n\",relative_a,relative_b);\n\n\tif((relative_b-relative_a) -w <= 0){ //a????????????????????????????????????????????????????????¨???\n\t\t//printf(\"???[a]-???[b]:%d\\n\",(relative_b-relative_a) -w);\n\t\t//a?????¨???b?????¨???????????????\n\t\trelative_weight[calc_parent[b]] = w-(relative_b-relative_a);\n\t\tcalc_parent[calc_parent[b]] = calc_parent[a];\n\n\n\t\tif(b == 3 && a == 2){\n\t\t\t//printf(\"calc_parent[3]:%d relative_weight[3]:%d\\n\",calc_parent[3],relative_weight[3]);\n\t\t}\n\t}else{\n\t\t//printf(\"???[a]-???[b]:%d\\n\",(relative_b-relative_a) -w);\n\t\t//b?????¨???a?????¨???????????????\n\t\trelative_weight[calc_parent[a]] = (relative_b-relative_a) -w;\n\t\tcalc_parent[calc_parent[a]] = calc_parent[b];\n\n\t\tif(b == 3 && a == 2){\n\t\t\t//printf(\"calc_parent[3]:%d relative_weight[3]:%d\\n\",calc_parent[3],relative_weight[3]);\n\t\t}\n\t}\n}\n\nbool isSame(int a,int b){\n\treturn find_parent(a) == find_parent(b);\n}\n\nint main(){\n\n\tint N,M,a,b,w;\n\tparent = new int[100001];\n\theight = new int[100001];\n\tcalc_parent = new int[100001];\n\trelative_weight = new int[100001];\n\tchar command[2];\n\n\twhile(true){\n\t\tscanf(\"%d %d\",&N,&M);\n\t\tif(N == 0 && M == 0)break;\n\n\t\tfor(int i = 1; i <= N; i++){\n\t\t\tparent[i] = i;\n\t\t\theight[i] = 0;\n\t\t\tcalc_parent[i] = i;\n\t\t\trelative_weight[i] = 0; //????????????0???????????????\n\t\t}\n\n\t\tfor(int loop = 0; loop < M; loop++){\n\t\t\tscanf(\"%s %d %d\",command,&a,&b);\n\t\t\tif(command[0] == '!'){ //??¬?????????\n\t\t\t\tscanf(\"%d\",&w);\n\t\t\t\tunite(a,b,w);\n\t\t\t}else{ //???????????????\n\t\t\t\tif(!isSame(a,b)){\n\t\t\t\t\tprintf(\"UNKNOWN\\n\");\n\t\t\t\t}else{\n\t\t\t\t\tprintf(\"%d\\n\",calc_relative_weight(b)-calc_relative_weight(a));\n\t\t\t\t\t//compress_calc_parent(b);\n\t\t\t\t\t//compress_calc_parent(a);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cassert>// c\n#include <ctime>\n#include <iostream>// io\n#include <iomanip>\n#include <fstream>\n#include <sstream>\n#include <vector>// container\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <algorithm>// other\n#include <complex>\n#include <numeric>\n#include <functional>\n#include <random>\n#include <regex>\n\nusing namespace std;\ntypedef long long ll;\n\n#define ALL(c) (c).begin(),(c).end()\n#define FOR(i,l,r) for(int i=(int)l;i<(int)r;++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORr(i,l,r) for(int i=(int)r-1;i>=(int)l;--i)\n#define REPr(i,n) FORr(i,0,n)\n#define EACH(i,c) for(__typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define IN(l,v,r) ((l)<=(v) && (v)<(r))\n#define UNIQUE(v) v.erase(unique(ALL(v)),v.end())\n//debug\n#define DUMP(x)  cerr << #x << \" = \" << (x)\n#define LINE()    cerr<< \" (L\" << __LINE__ << \")\"\n\ntemplate<typename T,typename U> T pmod(T x,U M){return (x%M+M)%M;}\n\n//verified by AOJ0118 \nstruct UnionFind{\n    vector<int> par,rank,ss;int size;\n    vector<int> ws;\n    UnionFind(int n){\n        REP(i,n) par.push_back(i);\n        rank = vector<int>(n);ss=vector<int>(n,1);size=n;\n\n        ws=vector<int>(n);\n    }\n    int root(int x){\n        if(par[x] == x)return x;\n        int r = root(par[x]); ws[x] += ws[par[x]];\n        return par[x] = r;\n    }\n    int val(int x){\n    \troot(x);return ws[x];\n    }\n    bool same(int x,int y){\n        return root(x) == root(y);\n    }\n    void unite(int x,int y,int w=0){\n    \tint vx=val(x),vy=val(y);\n        x = root(x);y = root(y);\n        if(x==y)return;\n        if(rank[x] < rank[y]){//root y\n        \tws[x] = w + vy - vx;\n             par[x] = y;ss[y]+=ss[x];\n        }else{//root x\n        \tws[y] = -w +vx - vy;\n            par[y] = x;ss[x]+=ss[y];\n        }\n        if(rank[x] == rank[y]) rank[x]++;\n        size--;\n    }\n    int getS(int x){\n        return ss[root(x)];\n    }\n};\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tcerr << fixed <<setprecision(20);\n\tcout << fixed <<setprecision(20);\n  while (true) {\n  \tint N,M;cin >> N >> M;if(N==0)break;\n  \tUnionFind uf(N);\n  \tREP(i,M){\n  \t\tchar c;int a,b,w;cin >> c >> a >> b;a--;b--;\n\t\n\t\t// REP(i,N)cerr <<uf.par[i] <<\" \";cerr <<endl;\n  // \t\tREP(i,N)cerr <<uf.val(i) <<\" \";cerr <<endl;\n  \t\tif(c=='!'){\n  \t\t\tcin >> w;\n  \t\t\tuf.unite(a,b,w);\n  \t\t}else{\n  \t\t\tif(!uf.same(a,b)){\n  \t\t\t\tcout <<\"UNKNOWN\"<<endl;\n  \t\t\t}else{\n  \t\t\t\tcout << uf.val(a)-uf.val(b) <<endl;\n  \t\t\t}\n  \t\t}\n  \t\t// cerr <<\"aaa\"<<endl;\n  \t}\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX = 100001;\n\ntypedef pair<int,int> P;\n\nclass UnionFind{\n  P par[MAX];\n  int rank[MAX];\n\npublic:\n  UnionFind(int n = MAX){\n    clear(n);\n  }\n\n  void clear(int n = MAX){\n    for(int i=0;i<n;i++){\n      par[i] = P(i,0);\n      rank[i] = 0;\n    }\n  }\n\n  P find(int x){\n    if(par[x].first == x) return par[x];\n    else {\n      P res = find(par[x].first);\n      return par[x] = P(res.first, res.second + par[x].second);\n    }\n  }\n\n  void unite(int x, int y, int cost){\n    P px = find(x);\n    P py = find(y);\n    if(px.first == py.first) return;\n    if(rank[px.first] < rank[py.first]) {\n      par[x] = P(y, -cost);\n    }\n    else{\n      par[y] = P(x, cost);\n      if(rank[px.first] == rank[py.first]) rank[px.first]++;\n    }\n  }\n\n  bool same(int x, int y){ return find(x).first == find(y).first;}\n  int calc(int x, int y) { return par[y].second - par[x].second;}\n};\n\n\nint n,m;\nUnionFind uf;\n\nint main(){\n  while(cin >> n >> m && (n|m)){\n    uf.clear();\n    for(int i=0;i<m;i++){\n      char c;\n      int x,y,z;\n      cin >> c >> x >> y;\n\n      if(c == '!'){\n        cin >> z;\n        uf.unite(x, y, z);\n\n      } else {\n        if(uf.same(x, y)) cout << uf.calc(x, y) << endl;\n        else cout << \"UNKNOWN\" << endl;        \n        /*\n        cout << endl;\n        for(int i=1;i<=n;i++){\n          cout << i << \": \" << uf.par[i].first << ' ' << uf.par[i].second << endl;\n        }\n        */\n      }\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\nlong long dist[1 << 18];\nlong long group[1 << 18]; char q;\nlong long n, Q, a, b, c;\nvector<long long>gr[1 << 18];\nint main() {\n\tfor (int t = 0; t < 10; t++) {\n\t\tfor (int i = 0; i < 1 << 18; i++) {\n\t\t\tdist[i] = 0; group[i] = i; gr[i].clear(); gr[i].push_back(i);\n\t\t}\n\t\tcin >> n >> Q; if (n == 0 && Q == 0)break;\n\t\tfor (int i = 0; i < Q; i++) {\n\t\t\tcin >> q;\n\t\t\tif (q == '?') {\n\t\t\t\tcin >> a >> b;\n\t\t\t\tif (group[a] != group[b])cout << \"UNKNOWN\" << endl;\n\t\t\t\telse cout << dist[b] - dist[a] << endl;\n\t\t\t}\n\t\t\tif (q == '!') {\n\t\t\t\tcin >> a >> b >> c;\n\t\t\t\tif (group[a] != group[b]) {\n\t\t\t\t\tint K = dist[a] + c - dist[b];\n\t\t\t\t\tint L = group[a], M = group[b];\n\t\t\t\t\tfor (int j = 0; j < gr[M].size(); j++) {\n\t\t\t\t\t\tgroup[gr[M][j]] = L;\n\t\t\t\t\t\tgr[L].push_back(gr[M][j]);\n\t\t\t\t\t\tdist[gr[M][j]] += K;\n\t\t\t\t\t}\n\t\t\t\t\tgr[M].clear();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define MAX_N 100005\nusing namespace std;\ntypedef pair<int,int> P;\nP par[MAX_N];\n\nvoid init(int n){\n  for(int i=0;i<n;i++)\n    par[i]=P(i,0);\n}\n\nP find(int x){\n  if(par[x].first==x)return P(x,0);\n  P r=find(par[x].first);\n  return par[x]=P(r.first,par[x].second+r.second);\n}\n\nvoid unite(int x,int y,int cost){\n  x=find(x).first;\n  y=find(y).first;\n  if(x==y)return;\n  par[x]=P(y,cost);\n}\n\nbool same(int x,int y){return find(x).first==find(y).first;}\n\nint n,m,a,b,cost;\nchar c;\n\nint main(){\n  while(1){\n    cin>>n>>m;\n    if(!n&&!m)break;\n    init(n);\n    rep(i,m){\n      cin>>c>>a>>b;\n      if(c=='!'){\n\tcin>>cost;\n\tunite(a-1,b-1,cost);\n      }else{\n\tif(!same(a-1,b-1))cout<<\"UNKNOWN\"<<endl;\n\telse cout<<find(a-1).second-find(b-1).second<<endl;\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return true; } return false; }\nusing ll = long long;\nusing P = pair<ll, ll>;\nll GCD(ll a, ll b) { return b?GCD(b, a%b):a; }\nll LCM(ll a, ll b) { return a/GCD(a, b)*b; }\n\ntemplate<class Abel> struct UnionFind {\n    vector<int> par;\n    vector<int> rank;\n    vector<Abel> diff_weight;\n\n    UnionFind(int n = 1, Abel SUM_UNITY = 0) {\n        init(n, SUM_UNITY);\n    }\n\n    void init(int n = 1, Abel SUM_UNITY = 0) {\n        par.resize(n); rank.resize(n); diff_weight.resize(n);\n        for(int i = 0; i < n; ++i) {\n            par[i] = i; rank[i] = 0; diff_weight[i] = SUM_UNITY;\n        }\n    }\n\n    int find(int x) {\n        if(par[x] == x) return x;\n        else {\n            int r = find(par[x]);\n            diff_weight[x] += diff_weight[par[x]];  // 累積和を取る\n            return par[x] = r;\n        }\n    }\n\n    Abel weight(int x) {\n        find(x);\n        return diff_weight[x];\n    }\n\n    bool same(int x, int y) {\n        return find(x) == find(y);\n    }\n\n    bool unite(int x, int y, Abel w) {\n        w += weight(x); w -= weight(y); // xとyそれぞれについて、rootとの重み差分を補正\n        x = find(x); y = find(y);\n        if(x == y) return false;\n        if(rank[x] < rank[y]) swap(x, y), w = -w;   // rank[x] >= rank[y]になるようにswap\n        if(rank[x] == rank[y]) ++rank[x];\n        par[y] = x;\n        diff_weight[y] = w; // xがyの親になるので、xとyの差分をdiff_weight[y]に記録\n        return true;\n    }\n\n    // 重みを取得する\n    Abel diff(int x, int y) {\n        return weight(y) - weight(x);\n    }\n};\n\nint n, m;\n\nint main() {\n    while(1) {\n        cin >> n >> m;\n        if(n == 0 && m == 0) break;\n        UnionFind<int> uf(n);\n        for(int i = 0; i < m; ++i) {\n            char c;\n            int a, b, w;\n            cin >> c >> a >> b;\n            a--; b--;\n            if(c == '!') {\n                cin >> w;\n                uf.unite(a, b, w);\n            }else {\n                if(uf.same(a, b)) cout << uf.diff(a, b) << endl;\n                else cout << \"UNKNOWN\" << endl;\n            }\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint n,q;\nint p[100010] = {0},r[100010] = {0};\nint diff_weight[100010] = {0};\n\nvoid init(int N){\n\tfor(int i=0;i<=N;++i){\n\t\tp[i] = i;\n\t\tdiff_weight[i] = 0;\n\t\tr[i] = 0;\n\t}\n}\n\nint root(int a){\n\tif(p[a] == a) return a;\n\telse{\n\t\tint r = root(p[a]);\n\t\tdiff_weight[a] += diff_weight[p[a]];\n\t\treturn (p[a] = r);\n\t}\n}\n\nbool is_same_set(int a,int b){\n\treturn root(a) == root(b);\n}\n\nint weight(int a){\n\troot(a);\n\treturn diff_weight[a];\n}\n\nint diff(int a, int b){\n\treturn weight(b) - weight(a);\n}\n\nvoid unite(int a, int b, int w){\n\tw += weight(a);\n\tw -= weight(b);\n\ta = root(a);\n\tb = root(b);\n\tif(a==b) return;\n\tif(r[a]<r[b]){\n\t\tint t = a;\n\t\ta = b;\n\t\tb = t;\n\t\tw = -w;\n\t}\n\t//}else{\n\tif(r[a] == r[b]) r[a]++;\n\tp[b] = a;\n\tdiff_weight[b] = w;\n}\n\nint main(){\n\twhile(cin >> n >> q && n>0){;\n\t\tinit(n);\n\t\tfor(int i=0;i<q;i++){\n\t\t\tchar c;\n\t\t\tint w,a,b;\n\t\t\tcin >> c;\n\t\t\tif(c=='!'){\n\t\t\t\tcin >> a >> b >> w;\n\t\t\t\tunite(a,b,w);\n\t\t\t}else{\n\t\t\t\tcin >> a >> b;\n\t\t\t\tif(is_same_set(a,b)) cout << diff(a,b) << endl;\n\t\t\t\telse cout << \"UNKNOWN\" << endl;\n\t\t\t}\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#define ll long long\nusing namespace std;\n\nstruct UnionFind{\n  vector< pair<ll int, ll int> > data;\n  UnionFind(int n) : data(n, pair<int,ll int>(-1,0)) {}\n  bool unite(int x, int y, ll int w){//weight(y)-weight(x) = w;\n    int x_ = find(x), y_ = find(y);\n    if(x_ == y_) return true;\n    if(x_ != y_){\n      if(data[y_].first < data[x_].first){\n\tswap(x_,y_);\n\tswap(x,y);\n\tw *= -1;\n      }\n      data[x_].first += data[y_].first;//???????????´??°\n      data[y_].first = x_;//????????´??°\n      data[y_].second += w + rel_weight(x);\n    }\n    return true;\n  }\n  bool same(int x, int y){ return find(x) == find(y); }\n  int find(int x){\n    if(data[x].first < 0) return x;\n    int p = find(data[x].first);\n    data[x].second += data[p].second;\n    data[x].first = p;\n    return data[x].first;\n  }\n  ll int rel_weight(int x){\n    return data[x].second;\n  }\n};\n\nint main(){\n  int N, M;\n  while(cin >> N >> M, N){\n    UnionFind uf(N);\n    char q;\n    int a, b;\n    ll int w;\n    for(int i = 0; i < M; ++i){\n      cin >> q >> a >> b;\n      --a;--b;\n      if(q == '!'){\n\tcin >> w;\n\tuf.unite(a,b,w);\n      }else{\n\t//cout << uf.find(a) << \" \" << uf.find(b) << endl;\n\tif(uf.same(a,b)){\n\t  cout << uf.rel_weight(b) - uf.rel_weight(a) << endl;\n\t}else{\n\t  cout << \"Unknown\" << endl;\n\t}\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<bitset>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n\nclass union_find{\nprivate:\n\tvector<int> parents;\n\tvector<int> weight;\npublic:\n\tunion_find(int n){\n\t\tfor(int i=0;i<n;i++){\n\t\t\tparents.push_back(i);\n\t\t\tweight.push_back(0);\n\t\t}\n\t}\n\tint find(int x){\n\t\tif(parents[x]==x){\n\t\t\treturn x;\n\t\t}else{\n\t\t\tint tmp=find(parents[x]);\n\t\t\tweight[x]=weight[x]+weight[parents[x]];\n\t\t\treturn parents[x]=tmp;\n\t\t}\n\t}\n\tvoid unite(int x,int y,int w){\n\t\tint tmpx=find(x);\n\t\tint tmpy=find(y);\n\t\tif(tmpx==tmpy)return;\n\t\tweight[tmpx]=w-weight[x]+weight[y];\n\t\tparents[tmpx]=tmpy;\n\t}\n\tint get_weight(int x,int y){\n\t\tif(find(x)==find(y)){\n\t\t\treturn weight[x]-weight[y];\n\t\t}else{\n\t\t\treturn -2000000;\n\t\t}\n\t}\n};\nint main(){\n\tchar c;\n\tint a,b,w;\n\tint n,m;\n\twhile(cin>>n>>m,n!=0||m!=0){\n\t\tunion_find uf(n+1);\n\t\tfor(int i=0;i<m;i++){\n\t\t\tcin>>c;\n\t\t\tif(c=='!'){\n\t\t\t\tcin>>a>>b>>w;\n\t\t\t\tuf.unite(a,b,w);\n\t\t\t}else if(c=='?'){\n\t\t\t\tcin>>a>>b;\n\t\t\t\tint tmp=uf.get_weight(a,b);\n\t\t\t\tif(tmp!=-2000000){\n\t\t\t\t\tcout<<tmp<<endl;\n\t\t\t\t}else{\n\t\t\t\t\tcout<<\"UNKNOWN\"<<endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> P;\nconst double EPS = 1e-12;\nconst int INF = numeric_limits<int>::max()/2;\nconst int MOD = 1e9+7;\n\nstruct UFW { // union-find with weight\n\tvector<int> par,w; // w := weight between parent\n\tUFW(int size) : par(size, -1), w(size,0) { }\n\tbool unite(int x, int y, int d) {\n\t\tif (root(x) != root(y)) {\n            w[root(y)] = d+weight(x)-weight(y);\n\t\t\tpar[root(y)] = root(x);\n            \n\t\t}\n\t\treturn x != y;\n\t}\n    void init(int size){\n        for(int i=0;i<size;i++){\n            par[i]=-1;\n            w[i]=0;\n        }\n    }\n\tbool same(int x, int y) {\n\t\treturn root(x) == root(y);\n\t}\n\tint root(int x) {\n\t\treturn par[x] < 0 ? x : par[x] = root(par[x]);\n\t}\n    int weight(int x){\n        if(root(x)==x) return 0;\n        return w[x]+weight(root(x));\n    }\n};\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int n,m;\n    string s;\n    int a,b;\n    ll w;\n    UFW uf(111111);\n    while(cin>>n>>m,n){\n        uf.init(n);\n        for(int i=0;i<m;i++){\n            cin>>s;\n            if(s==\"!\"){\n                cin>>a>>b>>w;\n                a--;b--;\n                uf.unite(a,b,w);\n            }\n            else{\n                cin>>a>>b;\n                a--;b--;\n                if(!uf.same(a,b)) cout<<\"UNKNOWN\"<<endl;\n                else{\n                    cout<<uf.weight(b)-uf.weight(a)<<endl;\n                }\n            }\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n//#include<cctype>\n#include<climits>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n//#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n//#include<numeric>\n#include<utility>\n//#include<memory>\n#include<functional>\n#include<cassert>\n#include<set>\n#include<stack>\n#include<random>\n\nconst int dx[] = {1, 0, -1, 0};\nconst int dy[] = {0, -1, 0, 1};\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef pair<int, int> pii;\n\nint N, M;\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while (cin >> N >> M) {\n        if (N==0 && M==0) break;\n        vector<int> W(N), i2g(N);\n        vector<vector<int> > g2i(N);\n        // init\n        for (int i = 0; i < N; i++) {\n            i2g[i] = i;\n            g2i[i].push_back(i);\n        }\n        while (M--) {\n            char c;\n            cin >> c;\n            if (c == '!') {\n                int a, b, w;\n                cin >> a >> b >> w;\n                a--; b--;\n                if (i2g[a] == i2g[b]) {\n                    assert(W[b]-W[a] == w);\n                } else {\n                    // merge\n                    if (g2i[i2g[a]].size() < g2i[i2g[b]].size()) {\n                        swap(a, b);\n                        w = -w;\n                    }\n                    int ga = i2g[a], gb = i2g[b];\n                    int diff = (W[a]+w) - W[b];\n                    for (int el : g2i[b]) {\n                        i2g[el] = ga; \n                        W[el] += diff;\n                    }\n                    g2i[ga].insert(g2i[ga].end(), g2i[gb].begin(), g2i[gb].end());\n                    g2i[gb].clear();\n                }\n            } else {\n                int a, b;\n                cin >> a >> b;\n                a--; b--;\n                if (i2g[a] != i2g[b]) {\n                    cout << \"UNKNOWN\" << endl;\n                } else {\n                    cout << W[b]-W[a] << endl;\n                }\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint n;\nint m;\nint par[114514];\nint grp[114514];\nint myws[114514];\nint height[114514];\nvector<int> belong[114514];\n\nint find(int v) {\n  if (par[v] != v) return par[v] = find(par[v]);\n  return v;\n}\n\nbool same(int v, int u) {\n  return find(v) == find(u);\n}\n\nvoid unite(int u, int v) {\n  u = find(u);\n  v = find(v);\n  if (u == v) return;\n\n  if (height[u] > height[v]) par[v] = u;\n  else if (height[u] < height[v]) par[u] = v;\n  else {\n    par[v] = u;\n    height[v]++;\n  }\n}\n\nint main() {\n  while (1) {\n    scanf(\"%d%d\", &n, &m);\n    if (n == 0 && m == 0) return 0;\n\n    for (int i=0; i<=n; i++) {\n      myws[i] = 0;\n      par[i] = i;\n      height[i] = 0;\n      belong[i].clear();\n      belong[i].push_back(i);\n      grp[i] = i;\n    }\n\n    for (int i=0; i<m; i++) {\n      char cmd;\n      int a, b;\n      scanf(\" %c%d%d\", &cmd, &a, &b);\n      if (cmd == '!') {\n        int w;\n        scanf(\"%d\", &w);\n        if (!same(a, b)) {\n          if (belong[grp[a]].size() < belong[grp[b]].size()) {\n            swap(a, b);\n            w = -w;\n          }\n\n          int d = myws[b]-(myws[a]+w);\n          for (int v : belong[grp[b]]) {\n            belong[grp[a]].push_back(v);\n            grp[v] = grp[a];\n            myws[v] -= d;\n          }\n          unite(a, b);\n        }\n      } else {\n        if (!same(a, b)) puts(\"UNKNOWN\");\n        else {\n          printf(\"%d\\n\", myws[b]-myws[a]);\n        }\n      }\n    } \n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n//BEGIN CUT HERE\ntemplate <typename T> \nstruct WeightedUnionFind{\n  int n;\n  T d;\n  vector<int> r,p;\n  vector<T> ws;\n  WeightedUnionFind(){}\n  WeightedUnionFind(int sz,T d_):\n    n(sz),d(d_),r(n,1),p(n),ws(n,d){iota(p.begin(),p.end(),0);}\n  int find(int x){\n    if(x==p[x]){\n      return x;\n    }else{\n      int t=find(p[x]);\n      ws[x]+=ws[p[x]];\n      return p[x]=t;\n    }\n  }\n  T weight(int x){\n    find(x);\n    return ws[x];\n  }\n  bool same(int x,int y){\n    return find(x)==find(y);\n  }\n  void unite(int x,int y,T w){\n    w+=weight(x);\n    w-=weight(y);\n    x=find(x);y=find(y);\n    if(x==y) return;\n    if(r[x]<r[y]) swap(x,y),w=-w;\n    r[x]+=r[y];\n    p[y]=x;\n    ws[y]=w;\n  }\n  T diff(int x,int y){\n    return weight(y)-weight(x);\n  }\n};\n//END CUT HERE\nsigned AOJ_1330(){\n  int n,m;\n  while(cin>>n>>m,n||m){\n    WeightedUnionFind<Int> u(n,0);\n    for(int i=0;i<m;i++){\n      int a,b;\n      char c;\n      cin>>c>>a>>b;\n      a--;b--;\n      if(c=='!'){\n\tInt w;\n\tcin>>w;\n\tu.unite(a,b,w);\n      }else{\n\tif(!u.same(a,b)) cout<<\"UNKNOWN\"<<endl;\n\telse cout<<u.diff(a,b)<<endl;\n      }\n    }\n  }\n  return 0;\n}\n/*\n  verified on 2017/10/29\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1330\n*/\n\nsigned DSL_1_B(){\n  Int n,q;\n  cin>>n>>q;\n  WeightedUnionFind<Int> wuf(n,0);\n  \n  for(Int i=0;i<q;i++){\n    Int t,x,y,z;\n    cin>>t>>x>>y;\n    //cout<<t<<\":\"<<x<<\" \"<<y<<endl;\n    if(t){\n      if(wuf.same(x,y)) cout<<wuf.diff(x,y)<<endl;\n      else cout<<\"?\"<<endl;\n    }else{\n      cin>>z;\n      wuf.unite(x,y,z);\n    }\n  }\n}\n/*\n  verified on 2018/04/16\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=DSL_1_B&lang=jp\n*/\n\nsigned main(){\n  AOJ_1330();\n  //DSL_1_B();\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define f first\n#define s second\n#define mp make_pair\n#define inf 1<<30\n#define MAX 1000010\nusing namespace std;\n\nlong long p[MAX],w[MAX];\n\npair<int,int> find(int a){\n  if(p[a]==a)return mp(a,0);\n  pair<int,int> pii=find(p[a]);\n  pii.s+=w[a];\n  p[a]=pii.f;\n  w[a]=pii.s;\n  return pii;\n}\n\nvoid unit(int a,int b,int d){\n  pair<int,int> pa=find(a),pb=find(b);\n  if(pa.f==pb.f)return;\n  d-=w[b]-w[a];\n  p[pa.f]=b;\n  w[pa.f]=d;\n}\n\nint main()\n{\n  int n,q,a,b,d;\n  char c;\n\n  while(cin>>n>>q && n ){\n\n    for(int i=0;i<n;i++){\n      p[i]=i;\n      w[i]=0;\n    }\n\n    for(int i=0;i<q;i++){\n      cin>>c;\n      if(c=='!'){\n\tcin>>a>>b>>d;\n\ta--;b--;\n        unit(a,b,d);\n      }\n      else {\n\tcin>>a>>b;\n\ta--;b--;\n\tpair<int,int> pa=find(a),pb=find(b);\n\tif(pa.f!=pb.f)cout<<\"UNKNOWM\"<<endl;\n\telse cout<<w[a]-w[b]<<endl;\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define PI       3.1415926535897932384626433832795028841971\n#define INF 1000000000\n#define EPS      1e-10\n#define MOD      1000000\nusing namespace std;\ntypedef long long ll;\ntypedef pair<double,double> P;\ntypedef pair<double,P> PQ;\n\nstruct Q{\n    int time,a, b;\n};\n\nstruct edge{\n    int time, to, w;\n};\n\nint n, m;\nint bss[100000];\nint rnk[100000];\nint num[100000];\nbool saw[100000];\nvector<edge> e[100000];\nvector<Q> q;\nint up[20][100000];\nint par[20][100000];\n\nvoid dfs(int v, int bos){\n    saw[v] = true;\n    rep(i,e[v].size()){\n        edge E = e[v][i];\n        if(saw[E.to]) continue;\n        up[0][E.to] = E.time;\n        rnk[E.to] = rnk[v]+1;\n        num[E.to] = num[v]+E.w;\n        bss[E.to] = bos;\n        par[0][E.to] = v;\n        dfs(E.to,bos);\n    }\n}\n\nint main(){\n    while(cin >> n >> m){\n        if(n == 0 && m == 0) break;\n        memset(bss,0,sizeof(bss));\n        memset(rnk,0,sizeof(rnk));\n        memset(num,0,sizeof(num));\n        memset(saw,0,sizeof(saw));\n        rep(i,n) e[i].clear();\n        q.clear();\n        memset(up,0,sizeof(up));\n        rep(i,m){\n            char hoge;\n            int a, b, w;\n            cin >> hoge;\n            if(hoge == '!'){\n                cin >> a >> b >> w;\n                a--; b--;\n                e[a].push_back((edge){i,b,w});\n                e[b].push_back((edge){i,a,-w});\n            } else{\n                cin >> a >> b;\n                a--; b--;\n                q.push_back((Q){i,a,b});\n            }\n        }\n        rep(i,20){\n            rep(j,n) par[i][j] = i;\n        }\n        rep(i,n){\n            if(saw[i]) continue;\n            dfs(i,i);\n        }\n        for(int i = 1; i < 20; i++){\n            rep(j,n){\n                par[i][j] = par[i-1][j];\n                up[i][j] = max(up[i-1][j],up[i-1][par[i-1][j]]);\n            }\n        }\n        rep(i,q.size()){\n            Q p = q[i];\n            bool done = false;\n            if(bss[p.a] != bss[p.b]){\n                cout << \"UNKNOWN\" << endl;\n                continue;\n            }\n            int ans = num[p.b]-num[p.a];\n            if(rnk[p.a] > rnk[p.b]){\n                int dis = rnk[p.a]-rnk[p.b];\n                int z = 0;\n                while(dis > 0){\n                    if(dis&1){\n                        if(up[z][p.a] > p.time){\n                            done = true;\n                            cout << \"UNKNOWN\" << endl;\n                            break;\n                        }\n                        p.a = par[z][p.a];\n                    }\n                    z++;\n                    dis /= 2;\n                }\n            } else if(rnk[p.a] < rnk[p.b]){\n                int dis = rnk[p.b]-rnk[p.a];\n                int z = 0;\n                while(dis > 0){\n                    if(dis&1){\n                        if(up[z][p.b] > p.time){\n                            done = true;\n                            cout << \"UNKNOWN\" << endl;\n                            break;\n                        }\n                        p.b = par[z][p.b];\n                    }\n                    z++;\n                    dis /= 2;\n                }\n            }\n            if(done) continue;\n            if(p.a == p.b){\n                cout << ans << endl;\n                continue;\n            }\n            int common = 0;\n            for(int j = 19; j >= 0; j--){\n                if(par[j][p.a] == par[j][p.b]) continue;\n                common += (1<<j);\n            }\n            common++;\n            int z = 0;\n            while(common > 0){\n                if(common&1){\n                    if(up[z][p.a] > p.time){\n                        done = true;\n                        cout << \"UNKNOWN\" << endl;\n                        break;\n                    }\n                    if(up[z][p.b] > p.time){\n                        done = true;\n                        cout << \"UNKNOWN\" << endl;\n                        break;\n                    }\n                    p.a = par[z][p.a];\n                    p.b = par[z][p.b];\n                }\n                common /= 2;\n                z++;\n            }\n            if(done) continue;\n            cout << ans << endl;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\nconst int S = 100010;\n\nstruct UnionFind {\n    vector<int> node, weight;\n    UnionFind() : node(S, -1), weight(S, 0) {}\n    void unite(int u, int v, ll w) {\n        // printf(\"(u, v) = (%d, %d)\\n\", u, v);\n        // printf(\"find(u, v) = (%d, %d)\\n\", find(u), find(v));\n        if(find(u) == find(v)) return;\n        if(find(u) > find(v)) swap(u, v), w *= -1;\n        ll new_weight = get_weight(u);\n\n        // printf(\"new_weight = %d\\n\", new_weight);\n        // v ????????? (u ??????) ???????????????\n        u = find(u);\n        node[u] += node[v];\n        node[v] = u;\n        weight[v] += new_weight + w;\n    }\n\n    ll get_weight(int u) {\n        ll ret = 0;\n        while(node[u] >= 0) {\n            ret += weight[u];\n            u = node[u];\n        }\n        return ret;\n    }\n\n    int find(int u) {\n        return (node[u] < 0 ? u : node[u] = find(node[u]));\n    }\n};\n\nint main() {\n    int N, M;\n    while(cin >> N >> M, N) {\n        UnionFind uf;\n        for(int i=0; i<M; i++) {\n            char c; cin >> c;\n            if(c == '!') {\n                int a, b, d; cin >> a >> b >> d;\n                a--; b--;\n                uf.unite(a, b, d);\n            }\n            else {\n                int a, b; cin >> a >> b;\n                a--; b--;\n                if(uf.find(a) != uf.find(b)) cout << \"UNKNOWN\" << endl;\n                else {\n                    ll wa = uf.weight[a];\n                    ll wb = uf.weight[b];\n                    // printf(\"wa = %d, wb = %d\\n\", wa, wb);\n                    cout << wb - wa << endl;\n                }\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<numeric>\n#include<utility>\n\nusing namespace std;\n\nint par[100001];\nlong long d[100001];\n\nint find(int x){\n  if(par[x]==x)return x;\n  find(par[x]);\n  d[x]+=d[par[x]];\n  return par[x]=par[par[x]];\n}\n\nvoid unite(int a,int b,int w){\n  find(a);\n  find(b);\n  d[par[b]]=w+d[a]-d[b];\n  par[par[b]]=par[a];\n}\n\nint main(){\n  for(int n,m;cin>>n>>m,n;){\n    iota(begin(par),end(par),0);\n    fill(begin(d),end(d),0);\n    while(m--){\n      char c;\n      int a,b;\n      cin>>c>>a>>b;\n      if(c=='!'){\n\tint w;\n\tcin>>w;\n\tunite(a,b,w);\n      }else{\n\tif(find(a)!=find(b)){\n\t  cout<<\"UNKNOWN\"<<endl;\n\t}else{\n\t  cout<<d[b]-d[a]<<endl;\n\t}\n      }\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int M = 1000000007;\n\nvector<int> grp;\nvector<long long>val;\nvector<vector<int>> lis;\nvoid init(int n) {\n    grp.resize(n);\n    val.resize(n, 0);\n    lis.resize(n);\n    for (int i = 0; i < n; ++i) {\n        grp[i] = i;\n        lis[i].push_back(i);\n    }\n}\nvoid merge(int p, int q, long long w) {\n    if (grp[p] == grp[q]) return;\n    if (lis[grp[p]].size() < lis[grp[q]].size()) {\n        merge(q, p, -w);\n        return;\n    }\n    long long d = w + val[p] - val[q];\n    int g = grp[q];\n    for (int i : lis[g]) {\n        grp[i] = grp[p];\n        val[i] += d;\n        lis[grp[p]].push_back(i);\n    }\n    lis[g].clear();\n}\n\nint main() {\n    while (1) {\n        int n, m;\n        cin >> n >> m;\n        if (!n) return 0;\n        init(n);\n        for (int i = 0; i < m; ++i) {\n            char c;\n            cin >> c;\n            if (c == '!') {\n                int p, q, w;\n                cin >> p >> q >> w;\n                merge(p - 1, q - 1, w);\n            }\n            else {\n                int p, q;\n                cin >> p >> q;\n                --p;\n                --q;\n                if (grp[p] != grp[q])\n                    puts(\"UNKNOWN\");\n                else\n                    printf(\"%lld\\n\", val[q] - val[p]);\n            }\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \n#define rep(i, j, n) for(int i=j;i<n;++i)\n#define all(i) i.begin(),i.end()\n#define rall(i) i.rbegin(),i.rend()\n#define INF 1e9\n#define LINF 1e18\nconst int mod = 1e9 + 7;\n \ntypedef long long i64;\ntypedef pair<int, int> pi;\n \ntemplate <class T> using vt = vector<T>;\ntemplate <class T> using vvt = vector<vector<T>>;\n \ntemplate <class Abel> struct UnionFind {\n  vector<int> par;\n  vector<int> rank;\n  vector<Abel> diff_weight;\n\n  UnionFind(int n, Abel SUM_UNITY = 0) : par(n), rank(n, 0), diff_weight(n, SUM_UNITY) {\n    for(int i = 0; i < n; ++i) par[i] = i;\n  }\n\n  Abel weight(int x) {\n    find(x);\n    return diff_weight[x];\n  }\n\n  int find(int x) {\n    if(x == par[x]) return x;\n\n    int r = find(par[x]);\n    diff_weight[x] += diff_weight[par[x]];\n    return par[x] = r;\n  }\n\n  void unite(int x, int y, Abel w) {\n    w += weight(x); w -= weight(y);\n    x = find(x); y = find(y);\n\n    if(x == y) return;\n    if(rank[x] < rank[y]) swap(x, y), w = -w;\n    if(rank[x] == rank[y]) ++rank[x];\n\n    par[y] = x;\n    diff_weight[y] = w;\n  }\n\n  bool same(int x, int y) {\n    return find(x) == find(y);\n  }\n\n  Abel diff(int x, int y) {\n    return weight(y) - weight(x);\n  }\n};\n\ni64 gcd(i64 n, i64 m) {return (m == 0? n : gcd(m, n % m));}\ni64 lcm(i64 n, i64 m) {return (n / gcd(n, m) * m);}\nint dx[] = {0, -1, 0, 1, 1, 1, -1, -1};\nint dy[] = {-1, 0, 1, 0, 1, -1, 1, -1};\n\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  int n, m;\n  while(cin >> n >> m, n && m) {\n    UnionFind<int> uf(n + 1);\n\n    rep(i, 0, m) {\n      char c;\n      int a, b, w;\n      cin >> c;\n\n      if(c == '!') {\n        cin >> a >> b >> w;\n        uf.unite(a, b, w);\n      }\n      else {\n        cin >> a >> b;\n        if(!uf.same(a, b)) cout << \"UNKNOWN\" << endl;\n        else cout << uf.diff(a, b) << endl;\n      }\n    }\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cstring>\n\nusing namespace std;\n\nconst int MAX = 100005;\n\nclass UnionFind{\npublic:\n \n  int par[MAX];\n  int rank[MAX];\n\n  void init(int n){\n    for(int i = 0; i < n; i++){\n      par[i] = i;\n      rank[i] = 0;\n    }\n  }\n\n  int find(int x){\n    if(par[x] == x) return x;\n    else return par[x] = find(par[x]);\n  }\n\n  void unite(int x, int y){\n    x = find(x);\n    y = find(y);\n    if(x == y) return;\n\n    if(rank[x] < rank[y]) par[x] = par[y];\n    else{\n      par[y] = par[x];\n      if(rank[x] == rank[y]) rank[x]++;\n    }\n  }\n  \n  bool same(int x, int y){\n    return find(x) == find(y);\n  }\n};\n\nint N,M,val[MAX];\nbool used[MAX];\nUnionFind uf;\nvector<int> V;\n\nvoid init(){\n  memset(used,false,sizeof(used));\n  memset(val,0,sizeof(val));\n  uf.init(N+1);\n  V.clear();\n}\n\n\nvoid update(){\n  \n  int a,b,c;\n  cin >> a >> b >> c;\n  if(!uf.same(a,b)){\n    if(!used[a]){\n      V.push_back(a);\n      used[a] = true;\n    }\n    if(!used[b]){\n      V.push_back(b);\n      used[b] = true;\n    }\n    \n    int diff = val[a]-val[b]+c;\n    for(int i = 0; i < V.size(); i++){\n      if(uf.same(V[i],b)) val[V[i]]+=diff;\n    }\n    uf.unite(a,b);\n  }\n}\n\nvoid print(){\n  int a,b;\n  cin >> a >> b;\n  if(uf.same(a,b)) cout << val[b]-val[a] << endl;\n  else cout << \"UNKNOWN\" << endl;\n}\n\nint main(){\n  \n  while(cin >> N >> M && N+M){\n    init();\n    for(int i = 0; i < M; i++){\n      char c;\n      cin >> c;\n      if(c == '!') update();\n      else print();\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 29;\n\nconst int nmax=100010;\nint par[nmax],ranks[nmax],weight[nmax];\n\nvoid init(int n){rep(i,n) par[i]=i,ranks[i]=0,weight[i]=0;}\nint find(int x,int &w){\n\tif(par[x]==x)\n\t\treturn x;\n\telse{\n\t\tw+=weight[x];\n\t\treturn find(par[x],w);\n\t}\n}\n\nvoid unite(int a,int b,int c){\n\tint wa=0,wb=0;\n\tint pa=find(a,wa);\n\tint pb=find(b,wb);\n\tif(ranks[pa]<ranks[pb]){\n\t\tpar[pa]=pb;\n\t\tweight[pa]=wb-wa+c;\n\t}else{\n\t\tpar[pb]=pa;\n\t\tweight[pb]=wa-wb-c;\n\t\tif(ranks[pa]==ranks[pb]) ranks[pa]++;\n\t}\n}\n\nbool same(int a,int b,int& ans){\n\tint wa=0,wb=0;\n\tint pa=find(a,wa);\n\tint pb=find(b,wb);\n\tans=wa-wb;\n\treturn pa==pb;\n}\n\nint main(void){\n\tint n,m;\n\twhile(cin >> n >> m,n){\n\t\tinit(n);\n\t\trep(i,m){\n\t\t\tchar cmd;\n\t\t\tcin >> cmd;\n\t\t\tif(cmd=='!'){\n\t\t\t\tint a,b,c;\n\t\t\t\tcin >> a >> b >> c;\n\t\t\t\tunite(a-1,b-1,c);\n\t\t\t}else{\n\t\t\t\tint a,b,ans;\n\t\t\t\tcin >> a >> b;\n\t\t\t\tif(same(a-1,b-1,ans))\n\t\t\t\t\tcout << ans << endl;\n\t\t\t\telse\n\t\t\t\t\tcout << \"UNKNOWN\" << endl;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\n#define int ll\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define PB push_back\n\nconst ll LLINF = (1LL<<60);\n\nclass UnionFind {\npublic:\n  const static int MAX_N = 100010;\n  int par[MAX_N];\n  int s[MAX_N];\n  UnionFind() { init(); }\n  UnionFind(int n) { init(n); }\n  void init() { for(int i=0; i<MAX_N; ++i) par[i] = i, s[i] = 1; }\n  void init(int n) { for(int i=0; i<n; ++i) par[i] = i, s[i] = 1; }\n  int find(int x) {\n    if(par[x] == x) return x;\n    return par[x] = find(par[x]);\n  }\n  void unite(int x, int y) {\n    x = find(x);\n    y = find(y);\n    if(x == y) return;\n    if(s[x] < s[y]) par[x] = y, s[y] = s[x] + s[y];\n    else par[y] = x, s[x] = s[x] + s[y];\n  }\n  bool same(int x, int y) { return find(x) == find(y);}\n};\nUnionFind uf;\n\nvector<PII> g[100010];\nint d[100010];\nvoid dfs(int x, int p, int dist) {\n  d[x] = dist;\n  for(auto e: g[x]) {\n    if(e.first != p) dfs(e.first, x, dist + e.second);\n  }\n}\n\nsigned main(void)\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  while(true) {\n    int n, m;\n    cin >> n >> m;\n    if(!n) break;\n\n    REP(i, n) g[i].clear();\n    memset(d, 0, sizeof(d));\n    uf.init(n);\n\n    vector<PII> query;\n    VI ans(m+5);\n    int idx = 0;\n    REP(i, m) {\n      char c;\n      int a, b;\n      cin >> c >> a >> b; a--, b--;\n      if(c == '!') {\n        int w; cin >> w;\n        if(!uf.same(a, b)) {\n          uf.unite(a, b);\n          g[a].PB({b, -w});\n          g[b].PB({a, w});\n        }\n      } else {\n        query.PB({a, b});\n        if(!uf.same(a, b)) ans[idx] = LLINF;\n        idx++;\n      }\n    }\n\n    REP(i, n) if(d[i] == 0) dfs(i, -1, 0);\n\n    REP(i, query.size()){\n      if(ans[i]==LLINF) cout << \"UNKNOWN\" << endl;\n      else cout << d[query[i].first] - d[query[i].second] << endl;\n    }\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\n#define MAX (100000)\nstruct uni{\n  P d[100001];\n  void init(){\n    fill(d,d+MAX,P(-1,0));\n  }\n  int find(int a){\n    if( d[a].first<0 ) return a;\n    else {\n      int b = find(d[a].first);\n      int w1 = d[a].second;\n      int w2 = d[d[a].first].second;\n      d[a] = P(b,w1+w2);\n      return b;\n    }\n  }\n  void marge(int x,int y,int k){\n    int bk = get(x);\n    x = find(x);\n    d[x].second = k - bk;\n    d[x].first = y;\n    find(x);\n  }\n  bool same(int a,int b){\n    if( find(a)==find(b) ) return true;\n    return false;\n  }\n  int get(int x){\n    find(x);\n    return d[x].second;\n  }\n  int size(int x){\n    x = find(x);\n    return d[x].first;\n  }\n};\n\nint N,M;\nuni U;\nint main(){\n  while(cin >> N >> M && (N||M) ){\n    char c;\n    int a,b,k;\n    U.init();\n    for(int i=0;i<M;i++){\n      cin >> c;\n      if( c == '!' ){\n\tcin  >> a >> b  >> k;\n\ta--;b--;\n\tif( !U.same( a, b ) ) \n\t  U.marge(a,b,k);\n\n\t//\tcout << \"marge \" << a << \" \" << b << \" \" << k << endl;\n\t//cout << U.get(a) << \" \" << U.size(a) << \"   \"  << U.get(b)<< \" \" << U.size(b) << endl;\n      } else {\n\tcin >> a >> b;\n\ta--;b--;\n\tif( U.same( a,b ) ) {\n\t  cout << U.get(a) - U.get(b) << endl;\n\t} else \n\t  cout << \"UNKNOWN\" << endl;\n      }\n    }  \n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <cstring>\n#include <sstream>\n#include <algorithm>\n#include <cstdlib>\n#include <map>\n#include <queue>\n#include <utility>\n#include <vector>\n#include <set>\n#include <memory.h>\n#include <iomanip>\n#include <bitset>\n#include <list>\n#include <stack>\n#include <deque>\n#include <complex>\n\nusing namespace std;\n\n#define mod 1000000007\n\nclass UnionFind\n{\n    vector<int> root;\n    vector<vector<int> > child;\n    vector<long long int> dist;\n    public:\n    UnionFind(int n)\n    {\n    \tchild = vector<vector<int> >(n);\n        for(int i=0;i<n;i++)\n        {\n            root.push_back(i);\n            child[i].push_back(i);\n            dist.push_back(0);\n        }\n    }\n\n    int getroot(int n)\n    {\n        if(root[n]==n) return n;\n        return root[n]=getroot(root[n]);\n    }\n\n    void set(int x,int y, long long int w)\n    {\n        int rx = getroot(x);\n        int ry = getroot(y);\n        if(rx == ry) return;\n        if(child[rx].size() < child[ry].size()){\n        \tswap(x, y);\n        \tswap(rx, ry);\n        \tw = -w;\n        }\n        root[ry] = rx;\n        int disty = dist[y];\n        while(!child[ry].empty()){\n        \tint now = child[ry].back();\n        \tdist[now] = dist[now] - disty + dist[x] + w;\n        \tchild[rx].push_back(now);\n        \tchild[ry].pop_back();\n        }\n        // cout << \"connect \" << ry << \" to \" << rx << endl;\n        // cout << \"child of \" << rx << \" : \" << endl;\n        // for(int i = 0; i < child[rx].size(); i++){\n        // \tcout << child[rx][i] << \" (dist : \" << dist[child[rx][i]] << \" ) \" << endl;\n        // }\n    }\n\n    long long int getdist(int x)\n    {\n    \treturn dist[x];\n    }\n};\n\nint main()\n{\n\twhile(1){\n\t\tint n, m;\n\t\tcin >> n >> m;\n\t\tif(n == 0) break;\n\t\tUnionFind uf(n);\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tchar c;\n\t\t\tcin >> c;\n\t\t\tif(c == '!'){\n\t\t\t\tint a, b, w;\n\t\t\t\tcin >> a >> b >> w;\n\t\t\t\ta--;\n\t\t\t\tb--;\n\t\t\t\tuf.set(a, b, w);\n\t\t\t} else {\n\t\t\t\tint a, b;\n\t\t\t\tcin >> a >> b;\n\t\t\t\ta--;\n\t\t\t\tb--;\n\t\t\t\tif(uf.getroot(a) != uf.getroot(b)) cout << \"UNKNOWN\" << endl;\n\t\t\t\telse cout << uf.getdist(b) - uf.getdist(a) << endl;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// \n// UnionFind \n// \n// Description:\n//   An union-find data structure (aka. disjoint set data structure) \n//   maintains a disjoint sets and supports the following operations.\n//   - unite(u, v): merge sets containing u and v.\n//   - find(u, v) : return true if u and v are in the same set\n//   - size(u)    : size of the set containing u.\n//\n//   The weighted version additionally maintains the values for the\n//   elements and supports the following operations:\n//   - add(u, a)   : value[u] += a\n//   - addSet(u, a): value[v] += a for v in set(u)\n//   - get(u)      : return value[u]\n//   - getSet(u)   : return sum(value[v] for v in set(u))\n//\n// Complexity:\n//   Amortized O(a(n)) for all operations.\n//   Here, a(n) is the inverse Ackermann function, which is\n//   less than five for a realistic size input.\n//\n// Verify:\n//\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1330\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define fst first\n#define snd second\n#define all(c) ((c).begin()), ((c).end())\n\nstruct UnionFind {\n  vector<int> parent; // parent[root] is the negative of the size.\n  UnionFind(int n) : parent(n, -1) { };\n  bool unite(int u, int v) { \n    u = root(u); v = root(v);\n    if (u == v) return false;\n    if (parent[u] > parent[v]) swap(u, v);\n    parent[u] += parent[v]; parent[v] += u;\n    return true;\n  }\n  bool find(int u, int v) { return root(u) == root(v); }\n  int root(int u) { return parent[u] < 0 ? u : parent[u] = root(parent[u]); }\n  int size(int u) { return -parent[root(u)]; }\n};\n\ntemplate <class T>\nstruct WeightedUnionFind {\n  struct Data {\n    int parent = -1;\n    T value = 0, delta = 0, total = 0;\n  };\n  vector<Data> data;\n  WeightedUnionFind(int n) : data(n) { }\n\n  void add(int u, T a) {\n    data[u].value += a;\n    data[root(u)].total += a;\n  }\n  void addSet(int u, T a) {\n    data[root(u)].delta += a;\n    data[root(u)].total -= data[root(u)].parent * a;\n  }\n  T get(int u) {\n    return data[u].value + root_(u).snd;\n  }\n  T getSet(int u) {\n    return data[root(u)].total;\n  }\n  bool unite(int u, int v) { \n    u = root(u); v = root(v);\n    if (u == v) return false;\n    if (data[u].parent > data[v].parent) swap(u, v);\n    data[u].parent += data[v].parent; \n    data[v].parent = u;\n    data[v].delta -= data[u].delta;\n    data[u].total += data[v].total;\n    return true;\n  }\n  pair<int, T> root_(int u) {\n    if (data[u].parent < 0) return {u, data[u].delta};\n    auto p = root_(data[u].parent);\n    p.snd += data[u].delta;\n    data[u].parent = p.fst;\n    data[u].delta = p.snd - data[p.fst].delta;\n    return p;\n  }\n  int root(int u) { return root_(u).fst; } \n  bool find(int u, int v) { \n    return root(u) == root(v); \n  }\n  int size(int u) { \n    return -data[root(u)].parent;\n  }\n};\n\nint test() {\n  int n = 5;\n  WeightedUnionFind<int> uf(n);\n  for (int i = 0; i < n; ++i) {\n    uf.add(i, i);\n  }\n  uf.unite(2, 4);\n  for (int i = 0; i < n; ++i) {\n    cout << uf.get(i) << \" \" << uf.getSet(i) << endl;\n  }\n  cout << endl;\n  uf.unite(3, 4);\n  for (int i = 0; i < n; ++i) {\n    cout << uf.get(i) << \" \" << uf.getSet(i) << endl;\n  }\n  cout << endl;\n  uf.add(3,10);\n  for (int i = 0; i < n; ++i) {\n    cout << uf.get(i) << \" \" << uf.getSet(i) << endl;\n  }\n  cout << endl;\n  uf.addSet(4,5);\n  for (int i = 0; i < n; ++i) {\n    cout << uf.get(i) << \" \" << uf.getSet(i) << endl;\n  }\n}\n\nvoid AOJ1330() {\n  for (int n, m; cin >> n >> m && n; ) {\n    WeightedUnionFind<long long> uf(n);\n    for (int i = 0; i < m; ++i) {\n      char c[2];\n      int a, b;\n      scanf(\"%s %d %d\", c, &a, &b);\n      --a; --b;\n      if (c[0] == '!') {\n        long long x;\n        scanf(\"%Ld\", &x);\n        uf.addSet(b, uf.get(a)-uf.get(b)-x);\n        uf.unite(a, b);\n      } else {\n        if (uf.find(a, b)) {\n          printf(\"%Ld\\n\", uf.get(a)-uf.get(b));\n        } else {\n          printf(\"UNKNOWN\\n\");\n        }\n      }\n    }\n  }\n}\nint main() { AOJ1330(); }\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\nconst int INF = 1000000000;\n#define REP(i,s,n) for(int i=(int)(s);i<(int)(n);i++)\n#define rep(i,n) REP(i, 0, n)\nstruct UnionFind {\n    vector<int> data;\n    vector<ll> rootd;//rootd[i] : dist from node[i] to node[root(i)]\n    UnionFind(int N) : data(N, -1), rootd(N, 0) {}\n    void unite(int x_, int y_, ll weight) {\n        int x = root(x_), y = root(y_);\n        if(x != y){\n            data[x] += data[y];\n            data[y] = x;\n            rootd[y] = weight - rootd[y_] + rootd[x_];\n        }\n    }\n    int root(int x_) {\n        int x = x_;\n        vector<int> memo;\n        while(data[x] >= 0) {\n            memo.push_back(x);\n            x = data[x];\n        }\n        int res = x;\n        for(int k : memo) {\n            rootd[k] += rootd[data[k]];\n            data[k] = res;\n        }\n        return res;\n    }\n    ll dist(int a, int b) { return rootd[b] - rootd[a];}\n    bool same(int a, int b) { return root(a) == root(b);}\n};\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int N, M;\n    while(cin >> N >> M && N) {\n        UnionFind uf(N);\n        char q; int a, b; ll w;\n        rep(i, M) {\n            cin >> q >> a >> b;\n            --a; --b;\n            if(q == '?') {\n                if(uf.same(a, b)) cout << uf.dist(a, b) << '\\n';\n                else cout << \"UNKNOWN\" << '\\n';;\n            }else {\n                cin >> w;\n                uf.unite(b, a, -w);\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<bitset>\n#include<algorithm>\nusing namespace std;\n#define MAX_N 100100\n\nclass union_find{\nprivate:\n\tint parents[MAX_N];\n\tint rank[MAX_N];\n\tint weight[MAX_N];\npublic:\n\tunion_find(int n){\n\t\tfor(int i=0;i<n;i++){\n\t\t\tparents[i]=i;\n\t\t\trank[i]=0;\n\t\t\tweight[i]=0;\n\t\t}\n\t}\n\tint find(int x){\n\t\tif(parents[x]==x){\n\t\t\treturn x;\n\t\t}else{\n\t\t\tint tmp=find(parents[x]);\n\t\t\tweight[x]=weight[x]+weight[parents[x]];\n\t\t\treturn parents[x]=tmp;\n\t\t}\n\t}\n\tvoid unite(int x,int y,int w){\n\t\tint tmpx=find(x);\n\t\tint tmpy=find(y);\n\t\tif(tmpx==tmpy)return;\n\t\tif(rank[tmpx]<rank[tmpy]){\n\t\t\tweight[tmpx]=w-weight[x]+weight[y];\n\t\t\tparents[tmpx]=tmpy;\n\t\t}else{\n\t\t\tweight[tmpy]=-w-weight[y]+weight[x];\n\t\t\tparents[tmpy]=tmpx;\n\t\t\tif(rank[tmpx]==rank[tmpy])rank[tmpx]++;\n\t\t}\n\t}\n\tint get_weight(int x,int y){\n\t\tif(find(x)==find(y)){\n\t\t\treturn weight[x]-weight[y];\n\t\t}else{\n\t\t\treturn -2000000;\n\t\t}\n\t}\n};\nint main(){\n\tchar c;\n\tint a,b,w;\n\tint n,m;\n\twhile(cin>>n>>m,n!=0||m!=0){\n\t\tunion_find uf(n+1);\n\t\tfor(int i=0;i<m;i++){\n\t\t\tcin>>c;\n\t\t\tif(c=='!'){\n\t\t\t\tcin>>a>>b>>w;\n\t\t\t\tuf.unite(a,b,w);\n\t\t\t}else if(c=='?'){\n\t\t\t\tcin>>a>>b;\n\t\t\t\tint tmp=uf.get_weight(a,b);\n\t\t\t\tif(tmp!=-2000000){\n\t\t\t\t\tcout<<tmp<<endl;\n\t\t\t\t}else{\n\t\t\t\t\tcout<<\"UNKNOWN\"<<endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<string>\n#include<cstring>\n#include<functional>\n#include<stack>\n#include<queue>\n#include <iomanip>\n#include<map>\n#include<limits>\n#include<cmath>\n#include<algorithm>\n#include<bitset>\n#include<utility>\n#include<complex>\n#include<cstdlib>\n#include<set>\n#include<cctype>\n\n#define DBG cerr << '!' << endl;\n#define REP(i,n) for(int (i) = (0);(i) < (n);++i)\n#define rep(i,s,g) for(int (i) = (s);(i) < (g);++i)\n#define rrep(i,s,g) for(int (i) = (s);i >= (g);--(i))\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {for(int W = 0;W < (n);W++)cerr << v[W] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,i,j) {for(int aaa = 0;aaa < i;aaa++){for(int bbb = 0;bbb < j;bbb++)cerr << v[aaa][bbb] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(10)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> iv;\ntypedef vector<iv> iiv;\ntypedef vector<string> sv;\n\n#define INF 10000000000\n\nstruct UF\n{\n\tvector<int> par; // ???\n\tvector<int> sz; // ??°\n\tvector<ll> value; // ???\n\t// ?????????\n\tUF(int n):par(n),sz(n),value(n) {\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tpar[i] = i;sz[i] = 1;value[i] = 0;\n\t\t}\n\t}\n\t// ??¨??????????±???????\n\tint find(int x) {\n\t\tif (par[x] == x)\n\t\t{\n\t\t\tvalue[x] = 0;\n\t\t\treturn x;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tint tmp = par[x];\n\t\t\tpar[x] = find(par[x]);\n\t\t\tvalue[x] += value[tmp];\n\t\t\t//cout << x << ' ' << value[x] << endl;\n\t\t\treturn par[x];\n\t\t}\n\t}\n\tll retValue(int n)\n\t{\n\t\tfind(n);\n\t\treturn value[n];\n\t}\n\t\n\t// x??¨y????±??????????????????????\n\tvoid unite(int x, int y,ll weight = 0) {\n\t\tint tmpx = x;\n\t\tx = find(x); y = find(y);\n\t\tif (x == y) return;\n\t\tpar[x] = y;\n\t\tvalue[x] = -value[tmpx] + weight;\n\t\tsz[y] += sz[x];\n\t}\n\t// x??¨y?????????????????????true\n\tbool same(int x, int y) { return find(x) == find(y); }\n\tint size(int n){return sz[find(n)];}\n};\n\nint n,m;\n\nint main()\n{\n\twhile(cin >> n >> m,n)\n\t{\n\t\t\n\t\tUF uf(n);\n\t\t\n\t\tREP(i,m)\n\t\t{\n\t\t\tchar c;int a,b;\n\t\t\tcin >> c >> a >> b;\n\t\t\ta--;b--;\n\t\t\tif(c == '!')\n\t\t\t{\n\t\t\t\tint w;cin >> w;\n\t\t\t\tuf.unite(a,b,w);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(!uf.same(a,b))\n\t\t\t\t{\n\t\t\t\t\tcout << \"UNKNOWN\" << endl;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tll A = uf.retValue(a);\n\t\t\t\t\tll B = uf.retValue(b);\n\t\t\t\t\tcout << A-B << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\t\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long long ll;\nusing namespace std;\n\n//BEGIN CUT HERE\n//重み付きUnion_find\n//typename Tには重みの型を入力する\ntemplate <typename T>\nclass Potential_UF{\npublic:\n    explicit Potential_UF(int n):size(n){\n        Rank.resize(static_cast<unsigned long>(n), 0);\n        parent.resize(static_cast<unsigned long>(n));\n        weight.resize(n,unity);\n        cont.resize(static_cast<unsigned long>(n), 1);\n        for(int i=0;i<size;i++){parent[i]=i;}\n    }\n\n    //xの属しているグループの番号を返します\n    int find(int x) {\n        if (parent[x] == x)return x;\n        else {\n            int r = find(parent[x]);\n            weight[x] += weight[parent[x]];\n            return parent[x] = r;\n        }\n    }\n\n    //xにつけられている重みを返します\n    T get_weight(int x){\n        find(x);\n        return weight[x];\n    }\n\n    //xとyの重みの差を返します\n    //weight(y)-weight(x)\n    T diff(int x,int y){\n        return get_weight(y)-get_weight(x);\n    }\n\n    //xとyが同じグループかどうかの判定をします\n    bool same(int x,int y){\n        return find(x)==find(y);\n    }\n\n    //xとyを同じグループにします\n    //既に同じなら何もしません\n    //weight(y)-weight(x)==wとなるように構成します\n    void Unite(int x,int y,T w){\n        w+=get_weight(x);\n        w-=get_weight(y);\n        x=find(x);\n        y=find(y);\n        if(x==y)return;\n        if(Rank[x]>Rank[y]){\n            parent[y]=x;\n            weight[y]=w;\n            cont[x]+=cont[y];\n            cont[y]=0;\n        }else{\n            parent[x]=y;\n            if(Rank[x]==Rank[y])Rank[y]++;\n            weight[x]=-w;\n            cont[y]+=cont[x];\n            cont[x]=0;\n        }\n    }\n\n    //xが属するグループの要素数を返します\n    int group_size(int x){\n        return cont[find(x)];\n    }\n\n    //デバッグ用\n    void visual(){\n        for(int i=0;i<size;i++)find(i);\n        for(int i=0;i<size;i++){\n            cout<<\"   par[\"<<i<<\"]=\"<<parent[i]<<\",\";\n        }\n        cout<<endl;\n        for(int i=0;i<size;i++){\n            cout<<\"weight[\"<<i<<\"]=\"<<weight[i]<<\",\";\n        }\n        cout<<endl;\n        for(int i=0;i<size;i++){\n            cout<<\"cont[\"<<i<<\"]=\"<<cont[i]<<\",\";\n        }\n        cout<<endl;\n    }\nprivate:\n    int size;\n    const T unity=0;//型Tの単位元\n    vector<int> parent;//親\n    vector<int> Rank;\n    vector<int> cont;//グループに属する要素の個数\n    vector<T> weight;//ポテンシャル\n};\n\n\nint main(){\n\tint n,m;\n\twhile(cin>>n>>m,n){\n\t\tPotential_UF<ll> uf(n);\n\t\tfor(int i=0;i<m;i++){\n\t\t\tchar a;cin>>a;\n\t\t\tif(a=='!'){\n\t\t\t\tint b,c;\n\t\t\t\tll d;\n\t\t\t\tcin>>b>>c>>d;\n\t\t\t\tb--;c--;\n\t\t\t\tuf.Unite(b,c,d);\n\t\t\t}else{\n\t\t\t\tint b,c;cin>>b>>c;\n\t\t\t\tb--;c--;\n\t\t\t\tif(!uf.same(b,c)){\n\t\t\t\t\tcout<<\"UNKNOWN\"<<endl;\n\t\t\t\t}else{\n\t\t\t\t\tcout<<uf.diff(b,c)<<endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\ntemplate<typename T>\nostream& operator << (ostream& os, vector<T>& v){\n\trep(i,v.size()){ os << v[i] << (i == v.size() - 1 ? \"\" : \" \"); } return os;\n}\ntemplate<typename T>\nistream& operator >> (istream& is, vector<T>& v){\n\tfor(T& x: v){ is >> x; } return is;\n}\n\ntemplate<typename T> struct sumGroup {\n\tusing value_type = T;\n\tconstexpr value_type id() { return 0; }\n\tconstexpr value_type operator()(const value_type &a, const value_type &b) { return a + b; }\n\tconstexpr value_type inv(const value_type &x) { return -x; }\n};\n\ntemplate<typename CommutativeGroup> class WeightedUnionFind {\n\tusing T = typename CommutativeGroup::value_type;\n\tCommutativeGroup g;\n\n\tvector<int> tree, rank;\n\tvector<T> diffWeight;\n\n\tpublic:\n\tWeightedUnionFind(const int &n) : tree(n), rank(n), diffWeight(n, g.id()) { iota(all(tree), 0); }\n\n\tint root(const int &x) {\n\t\tif (tree[x] == x) {\n\t\t\treturn x;\n\t\t} else {\n\t\t\tint r = root(tree[x]);\n\t\t\tdiffWeight[x] += diffWeight[tree[x]];\n\t\t\treturn tree[x] = r;\n\t\t}\n\t}\n\n\tT weight(const int &x) {\n\t\troot(x);\n\t\treturn diffWeight[x];\n\t}\n\n\tbool same(const int &a, const int &b) { return root(a) == root(b); }\n\n\tbool unite(int a, int b, T w) {\n\t\tw = g(w, g(weight(a), g.inv(weight(b))));\n\t\ta = root(a), b = root(b);\n\t\tif (a == b) return false;\n\t\tif (rank[a] < rank[b]) swap(a, b), w = g.inv(w);\n\t\ttree[b] = a;\n\t\tdiffWeight[b] = w;\n\t\tif (rank[a] == rank[b]) ++rank[a];\n\t\treturn true;\n\t}\n\n\tT diff(int x, int y) { return g(weight(y), g.inv(weight(x))); }\n};\n\nint main(){\n\tint n, m;\n\twhile(cin >> n >> m, n||m){\n\t\tWeightedUnionFind<sumGroup<int>> uf(n);\n\t\trep(i,m){\n\t\t\tchar c;\n\t\t\tcin >> c;\n\t\t\tif(c == '!'){\n\t\t\t\tint a, b, w;\n\t\t\t\tcin >> a >> b >> w;\n\t\t\t\tuf.unite(--a, --b, w);\n\t\t\t}else{\n\t\t\t\tint a, b;\n\t\t\t\tcin >> a >> b;\n\t\t\t\ta--; b--;\n\t\t\t\tif(not uf.same(a,b)){\n\t\t\t\t\tcout << \"UNKNOWN\" << endl;\n\t\t\t\t}else{\n\t\t\t\t\tcout << uf.diff(a, b) << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "        return ret;\n    }\n\n    int find(int u) {\n      if(node[u] < 0) return u;\n      int val = get_weight(node[u]);\n      weight[u] += val;\n      return node[u] = find(node[u]);\n    }\n};\n\nint main() {\n    int N, M;\n    while(cin >> N >> M, N) {\n        UnionFind uf;\n        for(int i=0; i<M; i++) {\n            char c; cin >> c;\n            if(c == '!') {\n                int a, b, d; cin >> a >> b >> d;\n                a--; b--;\n                uf.unite(a, b, d);\n            }\n            else {\n                int a, b; cin >> a >> b;\n                a--; b--;\n                if(uf.find(a) != uf.find(b)) cout << \"UNKNOWN\" << endl;\n                else {\n                    ll wa = uf.get_weight(a);\n                    ll wb = uf.get_weight(b);\n                    // printf(\"wa = %d, wb = %d\\n\", wa, wb);\n                    cout << wb - wa << endl;\n                }\n            }\n        }\n\n        /*\n        for(int i=0; i<N; i++) {\n          printf(\"%d: parent = %d, weight = %lld, value = %lld\\n\", i, uf.node[i], uf.\nweight[i], uf.get_weight(i));\n        }\n        */\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> l_l;\ntypedef pair<int, int> i_i;\n\n#define EPS (1e-7)\n#define INF (1e9)\n#define PI (acos(-1))\n//const ll mod = 1000000007;\ntemplate<class Abel> struct UnionFind {\n    vector<int> par;\n    vector<int> rank;\n    vector<Abel> diff_weight;\n\n    UnionFind(int n = 1, Abel SUM_UNITY = 0) {\n        init(n, SUM_UNITY);\n    }\n\n    void init(int n = 1, Abel SUM_UNITY = 0) {\n        par.resize(n + 1); rank.resize(n + 1); diff_weight.resize(n + 1);\n        for (int i = 0; i <= n; ++i) par[i] = i, rank[i] = 0, diff_weight[i] = SUM_UNITY;\n    }\n\n    int root(int x) {\n        if (par[x] == x) {\n            return x;\n        }\n        else {\n            int r = root(par[x]);\n            diff_weight[x] += diff_weight[par[x]];\n            return par[x] = r;\n        }\n    }\n\n    Abel weight(int x) {\n        root(x);\n        return diff_weight[x];\n    }\n\n    bool issame(int x, int y) {\n        return root(x) == root(y);\n    }\n\n    bool merge(int x, int y, Abel w) {\n        w += weight(x); w -= weight(y);\n        x = root(x); y = root(y);\n        if (x == y) return false;\n        if (rank[x] < rank[y]) swap(x, y), w = -w;\n        if (rank[x] == rank[y]) ++rank[x];\n        par[y] = x;\n        diff_weight[y] = w;\n        return true;\n    }\n\n    Abel diff(int x, int y) {\n        return weight(y) - weight(x);\n    }\n};\n\nint N, M;\n\nvoid solve() {\n    UnionFind<int> uni(N);\n    while(M--) {\n        char query;\n        cin >> query;\n        if(query == '!') {\n            int a, b, w;\n            cin >> a >> b >> w;\n            uni.merge(a, b, w);\n        } else {\n            int a, b;\n            cin >> a >> b;\n            if(uni.issame(a, b)) {\n                cout << uni.diff(a, b) << endl;\n            } else {\n                cout << \"UNKNOWN\" << endl;\n            }\n        }\n    }\n}\n\nint main() {\n    //cout.precision(10);\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while(cin >> N >> M) {\n        if(N == 0) break;\n        solve();\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define f first\n#define s second\n#define mp make_pair\n#define inf 1<<30\n#define MAX 1000010\nusing namespace std;\n\nlong long p[MAX],w[MAX];\n\npair<int,int> find(int a){\n  pair<int,int> pii;\n  if(p[a]==a){\n    pii.f=a;pii.s=0;\n    return pii;\n  }\n  pii=find(p[a]);\n  pii.s+=w[a];\n  p[a]=pii.f;\n  w[a]=pii.s;\n  return pii;\n}\n\nint main()\n{\n  int n,q,a,b,d;\n  char c;\n\n  while(cin>>n>>q && n ){\n\n    for(int i=0;i<n;i++){\n      p[i]=i;\n      w[i]=0;\n    }\n\n    for(int i=0;i<q;i++){\n      cin>>c;\n      if(c=='!'){\n\tcin>>a>>b>>d;\n\ta--;b--;\n\tpair<int,int> pa=find(a),pb=find(b);\n\tp[a]=pb.f;\n\tw[a]=pb.s+d;\n      }\n      else {\n\tcin>>a>>b;\n\ta--;b--;\n\tpair<int,int> pa=find(a),pb=find(b);\n\tif(pa.f!=pb.f)cout<<\"UNKNOWM\"<<endl;\n\telse {\n\t  p[a]=pa.f;\n\t  w[a]=pa.s;\n\t  p[b]=pb.f;\n\t  w[b]=pb.s;\n\t  cout<<pa.s-pb.s<<endl;\n\t}\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (int)(k); i < (int)(n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<ll> vi;\ntypedef vector<string> vs;\ntypedef pair <int, ll> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\n\nstruct UnionFind\n{\n\tvector<int> par;\n\tUnionFind(int n) :par(n, -1) {}\n\tint find(int x) { return par[x] < 0 ? x : par[x] = find(par[x]); }\n\tvoid unite(int x, int y)\n\t{\n\t\tx = find(x); y = find(y);\n\t\tif (x == y) return;\n\t\tif (par[y] < par[x]) swap(x, y);\n\t\tif (par[x] == par[y]) par[x]--;\n\t\tpar[y] = x;\n\t\tif (find(x) != find(y)) par[find(y)] = x;\n\t}\n\tint count()\n\t{\n\t\tint cnt = 0;\n\t\tREP(i, par.size()) if (par[i] < 0) cnt++;\n\t\treturn cnt;\n\t}\n\tbool same(int x, int y)\n\t{\n\t\treturn find(x) == find(y);\n\t}\n};\n\ntypedef tuple<char, vi> query;\n\nvector<query> q;\nvector<vector<pii>> es;\n\nint main()\n{\n\tcin.sync_with_stdio(false);\n\tint n, m;\n\twhile (cin >> n >> m, n)\n\t{\n\t\tUnionFind uf1(n);\n\t\tq.clear();\n\t\tes.clear(); es.resize(n);\n\t\tREP(i, m)\n\t\t{\n\t\t\tchar c;\n\t\t\tcin >> c;\n\t\t\tint p = (c == '!' ? 3 : 2);\n\t\t\tvi v(p);\n\t\t\tREP(i, p) cin >> v[i];\n\t\t\tv[0]--; v[1]--;\n\t\t\tq.emplace_back(c, v);\n\t\t\tif (c == '!')\n\t\t\t{\n\t\t\t\tuf1.unite(v[0], v[1]);\n\t\t\t\tes[v[0]].emplace_back(v[1], v[2]);\n\t\t\t\tes[v[1]].emplace_back(v[0], -v[2]);\n\t\t\t}\n\t\t}\n\t\tvi dist(n, INF);\n\t\tREP(i, n)\n\t\t{\n\t\t\tif (uf1.par[i] >= 0) continue;\n\t\t\tdist[i] = 0;\n\t\t\tqueue<int> que;\n\t\t\tque.push(i);\n\t\t\twhile (que.size())\n\t\t\t{\n\t\t\t\tint t = que.front();\n\t\t\t\tque.pop();\n\t\t\t\tfor (auto j: es[t])\n\t\t\t\t{\n\t\t\t\t\tif (dist[j.first] != INF) continue;\n\t\t\t\t\tdist[j.first] = dist[t] + j.second;\n\t\t\t\t\tque.push(j.first);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tUnionFind uf2(n);\n\t\tfor (auto i: q)\n\t\t{\n\t\t\tvi v = get<1>(i);\n\t\t\tif (get<0>(i) == '!') uf2.unite(v[0], v[1]);\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (uf2.same(v[0], v[1]))\n\t\t\t\t{\n\t\t\t\t\tcout << dist[v[1]] - dist[v[0]] << endl;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tcout << \"UNKNOWN\" << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cassert>\n#include<algorithm>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<29)\n#define MAX 3000000\nusing namespace std;\ntypedef long long ll;\nstruct P\n{\n  ll color,w;\n  P(ll color=-inf,ll w=-inf):color(color),w(w){}\n};\nP par[MAX];\nvoid init(){ rep(i,MAX)par[i] = P(i); }\n\nP find(int x)\n{\n  if(x == par[x].color)return par[x];\n  P p = find(par[x].color);\n  if(par[x].w == -inf)par[x].w = 0;\n  par[x].w += p.w,par[x].color = p.color;\n  return par[x];\n}\n\nvoid unit(int x,int y,ll w)//x <= y\n{\n  P X = find(x); \n  P Y = find(y);\n  //if(X.color == Y.color)return;\n  par[X.color].color = par[Y.color].color;\n  if(par[X.color].w == -inf)par[X.color].w = 0;\n  if(par[Y.color].w == -inf)par[Y.color].w = 0;\n  par[X.color].w = par[X.color].w + (par[y].w-w - par[x].w);\n  //par[x].w -= par[y].w;\n}\n\nint N,M;\n\nint main()\n{\n  while(cin >> N >> M,N|M)\n    {\n      init();\n      char c;\n      ll a,b,w;\n      rep(_,M)\n\t{\n\t  cin >> c;\n\t  if(c == '!')\n\t    {\n\t      cin >> a >> b >> w;\n\t      unit(a,b,w);\n\t    }\n\t  else\n\t    {\n\t      cin >> a >> b;\n\t      P B = find(b);\n\t      P A = find(a);\n\t      if(B.color != A.color)cout << \"UNKNOWN\" << endl;\n\t      else cout << B.w-A.w << endl;\n\t    }\n\n\n\t}\n    }\n  return 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, a, n) for(ll i = ((ll) a); i < ((ll) n); i++)\nusing namespace std;\ntypedef long long ll;\n\nclass UnionFind {\npublic:\n  vector<ll> parent, weight;\n\n  UnionFind(ll n): parent(n), weight(n) {\n    REP(i, 0, n) parent[i] = i;\n  }\n\n  ll diff(ll i, ll j) {\n    find(i);\n    find(j);\n    return weight[j] - weight[i];\n  }\n\n  ll find(ll i) {\n    if(parent[i] == i) return i;\n    ll root = find(parent[i]);\n    weight[i] += weight[parent[i]];\n    parent[i] = root;\n    return root;\n  }\n\n  /* weight[j] = weight[i] + w */\n  bool unite(ll i, ll j, ll w) {\n    ll pi = find(i), pj = find(j);\n    if(pi == pj) return false;\n    parent[pj] = pi;\n    weight[pj] = w - weight[j] + weight[i];\n    return true;\n  }\n};\n\nint main(void) {\n  ll N, M;\n  while(cin >> N >> M, N && M) {\n    UnionFind uf(N);\n    REP(i, 0, M) {\n      string T; cin >> T;\n      if(T == \"!\") {\n        ll A, B, W; cin >> A >> B >> W; A--; B--;\n        uf.unite(A, B, W);\n      } else {\n        ll A, B; cin >> A >> B; A--; B--;\n        if(uf.find(A) != uf.find(B)) cout << \"UNKNOWN\" << endl;\n        else cout << uf.diff(A, B) << endl;\n      }\n    }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\n#define int long long\nconst int INF = 1e8;\n\n\nstatic const int MAX_V = 100005;\nstatic const int MAX_M = 100005;\n\nclass Topological{\n\tpublic:\n\t\tvector<int> g[MAX_V]; //??°??????\n\t\tvector<int> tp; //????????????????????????????????????\n\n\t\tvoid bfs(int s, int indeg[MAX_V], bool used[MAX_V]){\n\t\t\tqueue<int> q;\n\n\t\t\tq.push(s);\n\t\t\tused[s] = true;\n\n\t\t\twhile(not q.empty()){\n\t\t\t\tint u = q.front(); q.pop();\n\t\t\t\ttp.emplace_back(u);\n\t\t\t\trep(i,g[u].size()){\n\t\t\t\t\tint v = g[u][i];\n\t\t\t\t\tindeg[v]--;\n\t\t\t\t\tif(indeg[v] == 0 && not used[v]){\n\t\t\t\t\t\tused[v] = true;\n\t\t\t\t\t\tq.push(v);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t//??°??????????????????????????´??????0?????????\n\t\tbool topologicalSort(int v){\n\t\t\tint indeg[MAX_V]; //??\\?¬???°\n\t\t\tbool used[MAX_V];\n\t\t\tmemset(indeg, 0, sizeof(indeg));\n\t\t\tmemset(used, 0, sizeof(used));\n\n\t\t\trep(i,v) rep(j,g[i].size()) indeg[ g[i][j] ]++;\n\t\t\trep(i,v) if(indeg[i] == 0 && not used[i]) bfs(i, indeg, used);\n\n\t\t\tfor(auto it:tp) cout << it << endl;\n\n\t\t\tif(tp.size() == v) return true;\n\t\t\telse return false;\n\t\t}\n};\n\n\nclass Union{\n\tpublic:\n\t\tint par[MAX_M]; //???\n\t\tint depth[MAX_M];//??¨?????±???\n\n\t\tvoid init(int n){\n\t\t\trep(i,n){\n\t\t\t\tpar[i] = i;\n\t\t\t\tdepth[i] = 0;\n\t\t\t}\n\t\t}\n\n\t\tint find(int x){\n\t\t\tif(par[x] == x){\n\t\t\t\treturn x;\n\t\t\t}else {\n\t\t\t\treturn par[x] = find(par[x]);\n\t\t\t}\n\t\t}\n\n\t\tvoid unite(int x, int y){\n\t\t\tx = find(x);\n\t\t\ty = find(y);\n\t\t\tif(x == y) return;\n\n\t\t\tif(depth[x] < depth[y]){\n\t\t\t\tpar[x] = y;\n\t\t\t}else{\n\t\t\t\tpar[y] = x;\n\t\t\t\tif(depth[x] == depth[y]) depth[x]++;\n\t\t\t}\n\t\t}\n\n\t\tbool same(int x, int y){\n\t\t\treturn find(x) == find(y);\n\t\t}\n};\n\nclass Edge{\n\tpublic:\n\t\tint to, cost;\n\t\tEdge(int to, int cost) : to(to) ,cost(cost) {}\n};\n\nclass Node{\n\tpublic:\n\t\tint dis;\n\t\tbool isUsed;\n\t\tint label;\n\t\tNode(){\n\t\t\tthis->dis = INF;\n\t\t\tthis->isUsed = 0;\n\t\t}\n};\n\ntypedef vector<vector<Edge>> AdjList;\n\nvoid dfs(AdjList& g, int cur, vector<Node>& node){\n\tnode[cur].isUsed = true;\n\tfor(auto e : g[cur]){\n\t\tif(node[e.to].isUsed) continue;\n\t\tnode[e.to].dis = node[cur].dis + e.cost;\n\t\tdfs(g, e.to, node);\n\t}\n}\n\nvoid dijkstra(AdjList g, int start, int n, vector<Node>& node){\n\tpriority_queue<int, vector<pair<int, int>>, greater<pair<int, int>>> q;\n\n\tq.push(make_pair(0, start));\n\tnode[start].dis = 0;\n\n\tpair<int, int> u;\n\twhile(not q.empty()){\n\t\tu = q.top(); q.pop();\n\t\tint current = u.second;\n\t\tnode[current].isUsed = 1;\n\n\t\trep(i,g[current].size()){\n\t\t\tint next = g[current][i].to;\n\t\t\tif(node[next].isUsed == 0){\n\t\t\t\tif(node[next].dis > node[current].dis + g[current][i].cost){\n\t\t\t\t\tnode[next].dis = node[current].dis + g[current][i].cost;\n\t\t\t\t\tq.push(make_pair(node[next].dis, next));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nsigned main(){\n\tint n, q;\n\twhile(cin >> n >> q,n){\n\t\tint a[MAX_M], b[MAX_M], c[MAX_M];\n\t\tchar com[MAX_M];\n\n\t\tAdjList g(n);\n\t\tvector<int> in(n,0);\n\t\trep(i,q){\n\t\t\tcin >> com[i];\n\t\t\tif(com[i] == '!'){\n\t\t\t\tcin >> a[i] >> b[i] >> c[i];\n\t\t\t\ta[i]--; b[i]--;\n\t\t\t\tg[b[i]].emplace_back(Edge{a[i],c[i]});\n\t\t\t\tin[a[i]]++;\n\t\t\t}else{\n\t\t\t\tcin >> a[i] >> b[i];\n\t\t\t\ta[i]--; b[i]--;\n\t\t\t}\n\t\t}\n\n\t\tvector<Node> node(n);\n\t\trep(i,n){\n\t\t\tif(in[i] == 0){ //??\\?¬???°???0\n\t\t\t\tnode[i].dis = 0;\n\t\t\t\tdfs(g, i, node);\n\t\t\t}\n\t\t}\n\n\t\t//for(auto i : node){ cout << i.dis << ' '; } cout << endl;\n\n\t\tUnion uni;\n\t\tuni.init(n);\n\t\trep(i,q){\n\t\t\tif(com[i] == '!'){\n\t\t\t\tuni.unite(a[i], b[i]);\n\t\t\t}else{\n\t\t\t\tif(uni.same(a[i], b[i])){\n\t\t\t\t\t//show(a[i])\n\t\t\t\t\tcout << node[a[i]].dis - node[b[i]].dis << endl;\n\t\t\t\t}else{\n\t\t\t\t\tcout << \"UNKNOWN\" << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<string>\n#include<algorithm>\n#include<iostream>\n#include<vector>\n#include<queue>\n#include<map>\n#include<set>\n#include<stack>\n\n#define msn(x) (memset((x),0,sizeof((x))))\n#define msx(x) (memset((x),0x7f,sizeof((x))))\n#define fuck(x) cerr << #x << \" <- \" << x << endl\n#define acer cout<<\"sb\"<<endl\ntypedef long long ll;\nusing namespace std;\nconst int maxn=1e5+7;\nstruct node\n{\n    int v,d;\n};\nvector<int>g[maxn];\nint n,m;\n\nint fa[maxn],siz[maxn];\nint dis[maxn];\nint anc(int a)////謇セ辷ク辷ク\n{\n\tif(fa[a]==a)return a;\n\tfa[a]=anc(fa[a]);\n\treturn fa[a];\n}\nvoid uni(int aa,int bb,int w)///霑樊磁\n{\n\tint a=anc(aa);\n\tint b=anc(bb);\n\tif(siz[a]<=siz[b])swap(a,b),swap(aa,bb),w=-w;\n\tint sb=w+dis[aa]-dis[bb];\n\tfa[b]=a;\n\tfor(int i=0;i<g[b].size();i++)\n    {\n        dis[g[b][i]]=sb+dis[g[b][i]];\n        g[a].push_back(g[b][i]);\n    }\n\tsiz[a]+=siz[b];\n}\nvoid ini1()//蟷カ譟・髮??蟋句喧\n{\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfa[i]=i;\n\t\tsiz[i]=1;\n\t\tdis[i]=0;\n\t\tg[i].clear();\n\t\tg[i].push_back(i);\n\t}\n}\nint main()\n{\n    while(~scanf(\"%d%d\",&n,&m))\n    {\n        if(n==0&&m==0)break;\n    ini1();\n    char ope[5];\n    int u,v,w;\n    for(int i=0;i<m;i++)\n    {\n        scanf(\"%s\",ope);\n        if(ope[0]=='!')\n        {\n            scanf(\"%d%d%d\",&u,&v,&w);\n            if(anc(u)!=anc(v))\n            {\n                uni(u,v,-w);\n            }\n        }\n        else\n        {\n            scanf(\"%d%d\",&u ,&v);\n            if(anc(u)!=anc(v))printf(\"UNKNOWN\\n\");\n            else printf(\"%d\\n\",dis[u]-dis[v]);\n       }\n    }\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long LL;\nLL W[100000];\nstruct UnionFind {\n\tint *par;\n\tint *rank;\n\tvector<vector<int>> group;\n\tUnionFind(int n) {\n\t\tpar = new int[n];\n\t\trank = new int[n];\n\t\tgroup = vector<vector<int>>(n, vector<int>());\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tgroup[i].push_back(i);\n\t\t\tpar[i] = i;\n\t\t\trank[i] = 0;\n\t\t}\n\t}\n\tint find(int x) {\n\t\tif (x == par[x]) return x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif (x == y) return;\n\t\tif (rank[x] < rank[y]) {\n\t\t\tpar[x] = y;\n\t\t\tfor (int i = 0; i < group[x].size(); i++) {\n\t\t\t\tgroup[y].push_back(group[x][i]);\n\t\t\t}\n\t\t\tgroup[x].clear();\n\t\t}\n\t\telse {\n\t\t\tpar[y] = x;\n\t\t\tfor (int i = 0; i < group[y].size(); i++) {\n\t\t\t\tgroup[x].push_back(group[y][i]);\n\t\t\t}\n\t\t\tgroup[y].clear();\n\t\t\tif (rank[x] == rank[y]) rank[x]++;\n\t\t}\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\tint count(int x) {\n\t\treturn group[find(x)].size();\n\t}\n};\nint main() {\n\tint N, M;\n\twhile (cin >> N >> M, N) {\n\t\tUnionFind U(N);\n\t\tfill(W, W + N, 0);\n\t\tfor (int i = 0; i < M; i++) {\n\t\t\tchar type[2];\n\t\t\tint a, b, w;\n\t\t\tcin >> type;\n\t\t\tif (type[0] == '?') {\n\t\t\t\tcin >> a >> b;\n\t\t\t\ta--; b--;\n\t\t\t\tif (!U.same(a, b)) {\n\t\t\t\t\tcout << \"UNKNOWN\" << endl;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tcout << W[b] - W[a] << endl;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcin >> a >> b >> w;\n\t\t\t\ta--; b--;\n\t\t\t\tif (U.same(a, b)) continue;\n\t\t\t\tif (U.count(a) <= U.count(b)) {\n\t\t\t\t\tLL diff = (W[b] - w) - W[a];\n\t\t\t\t\ta = U.find(a);\n\t\t\t\t\tfor (int j = 0; j < U.group[a].size(); j++) {\n\t\t\t\t\t\tW[U.group[a][j]] += diff;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tLL diff = (W[a] + w) - W[b];\n\t\t\t\t\tb = U.find(b);\n\t\t\t\t\tfor (int j = 0; j < U.group[b].size(); j++) {\n\t\t\t\t\t\tW[U.group[b][j]] += diff;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tU.unite(a, b);\n\t\t\t}\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <iomanip>\n#include <math.h>\n#include <unistd.h>\n#include <stdio.h>\n#define all(a) (a).begin(),(a).end()\n#define vecin(a) rep(i,a.size())cin >> a[i]\n#define vecout(a) rep(i,a.size()){cout << a[i];cout << (i == a.size() - 1 ? \"\\n\":\" \");}\n#define rep(i,x) for(ll i = 0;i<x;i++)\n#define REP(i,x) for(ll i = 1;i<=x;i++)\n#define mp make_pair\nusing ll = long long;\nusing ld = long double;\nusing namespace std;\nusing dou = double;\nconst ll inf = 2147483647;\nconst ll INF = 1LL << 60;\nconst dou pi = 3.14159265358;\nconst ll mod = 1000000007LL;\n//const ll mod = 998244353LL;\ntypedef pair<ll,ll> P;\nusing graph = vector<vector<ll>>;\ntemplate<class T> inline bool chmax(T& a, T b){if(a < b){a = b; return true;}return false;}\ntemplate<class T> inline bool chmin(T& a, T b){if(a > b){a = b; return true;}return false;}\ntemplate<class T> inline bool change(T a,T b){if(a > b){swap(a,b);return true;}return false;}\ntemplate<class T>\nT gcd(T a,T b){\n    if(a < b)swap(a,b);\n    if(a % b == 0)return b;\n    else return gcd(b,a%b);\n}\ntemplate<class T>\nT lcm(T a,T b){\n    return a / gcd(a,b) * b;\n}\n\n//素数判定O(sqrt(N))\ntemplate<class T>\ninline bool isp(T n){\n    bool res = true;\n    if(n == 1)return false;\n    else{\n        for(ll i = 2;i * i <= n;i++){\n            if(n % i == 0){\n                res = false;\n                break;\n            }\n        }\n        return res;\n    }\n}\nconst ll cmax = 1000000;\nll fac[cmax], finv[cmax], inv[cmax];\n\n// テーブルを作る前処理\nvoid COMinit() {\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    for (ll i = 2; i < cmax; i++){\n        fac[i] = fac[i - 1] * i % mod;\n        inv[i] = mod - inv[mod%i] * (mod / i) % mod;\n        finv[i] = finv[i - 1] * inv[i] % mod;\n    }\n}\n\n// 二項係数計算\nll nCk(ll n, ll k){\n    if (n < k) return 0;\n    if (n < 0 || k < 0) return 0;\n    return fac[n] * (finv[k] * finv[n - k] % mod) % mod;\n}\n//nのm乗をMODで割ったあまりO(logm)\nll modpow(ll n,ll m,ll MOD){\n    if(m == 0)return 1;\n    if(m < 0)return -1;\n    ll res = 1;\n    while(m){\n        if(m & 1)res = (res * n) % MOD;\n        m >>= 1;\n        n *= n;\n        n %= MOD;\n    }\n    return res;\n}\nll mypow(ll n,ll m){\n    if(m == 0)return 1;\n    if(m < 0)return -1;\n    ll res = 1;\n    while(m){\n        if(m & 1)res = (res * n);\n        m >>= 1;\n        n *= n;\n    }\n    return res;\n}\n\ntemplate<class Abel,class T>//重さの型,それ以外の型(メモリあるならllでOK)\nstruct UnionFind {\n    vector<T> par;\n    vector<T> rank;\n    vector<Abel> diff_weight;\n\n    UnionFind(T n = 1,Abel SUM_UNITY = 0){\n        init(n, SUM_UNITY);\n    }\n\n    void init(T n = 1,Abel SUM_UNITY = 0){\n        par.resize(n); rank.resize(n); diff_weight.resize(n);\n        rep(i,n){\n            par[i] = i, rank[i] = 0, diff_weight[i] = SUM_UNITY;\n        }\n    }\n\n    T root(T x) {\n        if (par[x] == x) {\n            return x;\n        }\n        else {\n            T r = root(par[x]);\n            diff_weight[x] += diff_weight[par[x]];\n            return par[x] = r;\n        }\n    }\n\n    Abel weight(T x) {\n        root(x);\n        return diff_weight[x];\n    }\n\n    bool same(T x, T y) {\n        return root(x) == root(y);\n    }\n\n    bool unite(T x,T y,Abel w) {\n        w += weight(x); w -= weight(y);\n        x = root(x); y = root(y);\n        if (x == y) return false;\n        if (rank[x] < rank[y]) swap(x, y), w = -w;\n        if (rank[x] == rank[y]) ++rank[x];\n        par[y] = x;\n        diff_weight[y] = w;\n        return true;\n    }\n\n    Abel diff(T x,T y) {\n        return weight(y) - weight(x);\n    }\n};\n\nll N,M;\nvoid solve(ll N,ll M){\n    UnionFind<ll,ll> UF(N);\n    char tipe;\n    rep(i,M){\n        cin >> tipe;\n        if(tipe == '!'){\n            ll a,b,c;\n            cin >> a >> b >> c;\n            a--;b--;\n            UF.unite(a,b,c);\n        }\n        else{\n            ll a,b;\n            cin >> a >> b;\n            a--;b--;\n            if(!UF.same(a,b)){\n                cout << \"UNKNOWN\\n\";\n            }\n            else{\n                cout << UF.diff(a,b) << \"\\n\";\n            }\n        }\n    }\n}\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);cout.tie(0);\n    while(1){\n        cin >> N >> M;\n        if(N == 0 && M == 0)break;\n        solve(N,M);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\nlong long dist[1 << 18];\nlong long group[1 << 18]; char q;\nlong long n, Q, a, b, c;\nvector<long long>gr[1 << 18];\nint main() {\n\tfor (int t = 0; t < 20; t++) {\n\t\tfor (int i = 0; i < 1 << 18; i++) {\n\t\t\tdist[i] = 0; group[i] = i; gr[i].clear(); gr[i].push_back(i);\n\t\t}\n\t\tcin >> n >> Q; if (n == 0 && Q == 0)break;\n\t\tfor (int i = 0; i < Q; i++) {\n\t\t\tcin >> q;\n\t\t\tif (q == '?') {\n\t\t\t\tcin >> a >> b;\n\t\t\t\tif (group[a] != group[b])cout << \"UNKNOWN\" << endl;\n\t\t\t\telse cout << dist[b] - dist[a] << endl;\n\t\t\t}\n\t\t\tif (q == '!') {\n\t\t\t\tcin >> a >> b >> c;\n\t\t\t\tif (group[a] != group[b]) {\n\t\t\t\t\tint K = dist[a] + c - dist[b];\n\t\t\t\t\tint L = group[a], M = group[b];\n\t\t\t\t\tfor (int j = 0; j < gr[M].size(); j++) {\n\t\t\t\t\t\tgroup[gr[M][j]] = L;\n\t\t\t\t\t\tgr[L].push_back(gr[M][j]);\n\t\t\t\t\t\tdist[gr[M][j]] += K;\n\t\t\t\t\t}\n\t\t\t\t\tgr[M].clear();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define all(v) (v).begin(),(v).end()\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\n#define pb push_back\n#define fi first\n#define se second\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nstruct UF{\n    vint par,sz;\n    vector<set<int>>st;\n    vint dif;\n    void init(int n){\n        par=sz=dif=vint(n);\n        st=vector<set<int>>(n);\n        rep(i,n){\n            par[i]=i;\n            sz[i]=1;\n            dif[i]=0;\n            st[i].insert(i);\n        }\n    }\n    int find(int x){\n        return x==par[x]?x:par[x]=find(par[x]);\n    }\n    void update(int a,int b,int w){\n        int x=find(a),y=find(b);\n        if(x==y)return;\n        if(sz[x]>sz[y]){\n            swap(x,y);\n            swap(a,b);\n            w*=-1;\n        }\n\n        each(it,st[x]){\n            int v=*it;\n            dif[v]+=dif[b]-dif[a]-w;\n            st[y].insert(v);\n        }\n        sz[y]+=sz[x];\n        par[x]=y;\n    }\n    int query(int a,int b){\n        int x=find(a),y=find(b);\n        if(x!=y)return 1001001001;\n        return dif[b]-dif[a];\n    }\n};\n\nsigned main(){\n    int N,Q;\n    while(scanf(\"%lld%lld\",&N,&Q),N||Q){\n        UF uf;uf.init(N);\n        rep(i,Q){\n            char c;\n            scanf(\" %c\",&c);\n            if(c=='!'){\n                int a,b,w;\n                scanf(\"%lld%lld%lld\",&a,&b,&w);\n                a--;b--;\n                uf.update(a,b,w);\n            }\n            else{\n                int a,b;\n                scanf(\"%lld%lld\",&a,&b);\n                a--;b--;\n                int tmp=uf.query(a,b);\n                if(tmp==1001001001)puts(\"UNKNOWN\");\n                else printf(\"%lld\\n\",tmp);\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,n) for(long long i = 0; i < (long long)(n); i++)\nusing ll = long long; using vll = vector<ll>; \n\nstruct UnionFind {\n    // ?????????????????????????????????\n    // ????????????-1 * ????????¨????????????\n    vector<int> data;\n    // ????????????????????????-??????????????´?????????????????????\n    // ?????????0\n    // \n    // w[i]????????????????????????????????¨?????????i??????-???????????¨??????\n    vector<ll> w; \n\n    UnionFind(int size) : data(size, -1), w(size, 0) { }\n    // x, y????????????\n    // O(log n)\n    void unite(int x, int y, int k) {\n        x = root(x); y = root(y); if (x == y) return;\n        ll wx = getWeight(x), wy = getWeight(y);\n\n        if (data[y] < data[x]) {\n            swap(x, y);\n            swap(wx, wy);\n            k *= -1;\n        }\n        data[x] += data[y]; \n        data[y] = x;\n        w[y] = -k + wx - wy;\n    }\n    // x, y?????????????????????1\n    // O(log n)\n    bool find(int x, int y) {\n        return root(x) == root(y);\n    }\n    // x???????????¢??????????????????????????????????????°???\n    // O(log n)\n    int root(int x) {\n        return data[x] < 0 ? x : root(data[x]);\n//        return data[x] < 0 ? x : data[x] = root(data[x]); // ????´??????????????????¢????????????????¨????????????????????????????????????´??°??¢???????????§?????£??¨???\n    }\n    // x??????????????§???w?????????\n    // O(log n)\n    ll getWeight(int x) {\n        return data[x] < 0 ? 0 : w[x] + getWeight(data[x]);\n    }\n};\n\nint main(void) {\n    cin.tie(0); ios::sync_with_stdio(false);\n\n    ll n, m; \n    while (cin >> n >> m && n && m) {\n        UnionFind uf(n);\n        rep(i, m) {\n            char c; cin >> c;\n            if (c == '!') {\n                ll x, y, w; cin >> x >> y >> w; x--; y--;\n                uf.unite(x, y, w);\n            } else {\n                ll x, y; cin >> x >> y; x--; y--;\n                if (!uf.find(x, y))\n                    cout << \"UNKNOWN\" << endl;\n                else \n                    cout << uf.getWeight(x) - uf.getWeight(y) << endl;\n            }\n        }\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<map>\nusing namespace std;\n \n#define N 100000\n#define fs first\n#define sc second\ntypedef pair<int,int> P;\n\nP par[N];\nint rank[N];\n \nvoid init(int n){\n  for(int i=0;i<n;i++)par[i] = P(i,0);\n}\n \nP find(int a){\n  if(par[a].fs == a)return par[a];\n  P tmp = find(par[a].fs);\n  return par[a] = P(tmp.fs,tmp.sc + par[a].sc);\n}\n \nbool same(int a,int b){\n  return (find(a).fs == find(b).fs);\n}\n\nbool unite(int a,int b,int cost){\n  P x = find(a);\n  P y = find(b);\n     \n  if(same(x.fs,y.fs)){\n    if(y.sc - x.sc != cost)return false;\n  }else{\n    if(rank[x.fs]<rank[y.fs]){\n      par[x.fs] = P(y.fs,y.sc-x.sc-cost);\n    }else{\n      par[y.fs] = P(x.fs,x.sc-y.sc+cost);\n      if(rank[x.fs] == rank[y.fs])rank[x.fs]++;\n    }\n  }\n  return true;\n}\n\nint main(){\n  char c;\n  int a,b,w,n,m;\n\n  while(scanf(\"%d%d\",&n,&m),(n||m)){\n    init(n);\n    for(int i=0;i<m;i++){\n      scanf(\" %c \",&c);\n      if(c=='?'){\n\tscanf(\"%d%d\",&a,&b);\n\ta--; b--;\n\tif(same(a,b))printf(\"%d\\n\",par[b].sc - par[a].sc);\n\telse printf(\"UNKNOWN\\n\");\n      }else{\n\tscanf(\"%d%d%d\",&a,&b,&w);\n\ta--; b--;\n\tunite(a,b,w);\n      }\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<bitset>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n\nclass union_find{\nprivate:\n\tvector<int> parents;\n\tvector<int> rank;\n\tvector<int> weight;\npublic:\n\tunion_find(int n){\n\t\tfor(int i=0;i<n;i++){\n\t\t\tparents.push_back(i);\n\t\t\trank.push_back(0);\n\t\t\tweight.push_back(0);\n\t\t}\n\t}\n\tint find(int x){\n\t\tif(parents[x]==x){\n\t\t\treturn x;\n\t\t}else{\n\t\t\tint tmp=find(parents[x]);\n\t\t\tweight[x]=weight[x]+weight[parents[x]];\n\t\t\treturn parents[x]=tmp;\n\t\t}\n\t}\n\tvoid unite(int x,int y,int w){\n\t\tint tmpx=find(x);\n\t\tint tmpy=find(y);\n\t\tif(tmpx==tmpy)return;\n\t\tif(rank[tmpx]<rank[tmpy]){\n\t\t\tweight[tmpx]=w-weight[x]+weight[y];\n\t\t\tparents[tmpx]=tmpy;\n\t\t}else{\n\t\t\tweight[tmpy]=-w-weight[y]+weight[x];\n\t\t\tparents[tmpy]=tmpx;\n\t\t\tif(rank[tmpx]==rank[tmpy])rank[tmpx]++;\n\t\t}\n\t}\n\tint get_weight(int x,int y){\n\t\tif(find(x)==find(y)){\n\t\t\treturn weight[x]-weight[y];\n\t\t}else{\n\t\t\treturn -2000000;\n\t\t}\n\t}\n};\nint main(){\n\tchar c;\n\tint a,b,w;\n\tint n,m;\n\twhile(cin>>n>>m,n!=0||m!=0){\n\t\tunion_find uf(n+1);\n\t\tfor(int i=0;i<m;i++){\n\t\t\tcin>>c;\n\t\t\tif(c=='!'){\n\t\t\t\tcin>>a>>b>>w;\n\t\t\t\tuf.unite(a,b,w);\n\t\t\t}else if(c=='?'){\n\t\t\t\tcin>>a>>b;\n\t\t\t\tint tmp=uf.get_weight(a,b);\n\t\t\t\tif(tmp!=-2000000){\n\t\t\t\t\tcout<<tmp<<endl;\n\t\t\t\t}else{\n\t\t\t\t\tcout<<\"UNKNOWN\"<<endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX = 100001;\n\ntypedef pair<int,int> P;\n\nclass UnionFind{\n  P par[MAX];\n  int rank[MAX];\n\npublic:\n  UnionFind(int n = MAX){\n    clear(n);\n  }\n\n  void clear(int n = MAX){\n    for(int i=0;i<n;i++){\n      par[i] = P(i,0);\n      rank[i] = 0;\n    }\n  }\n\n  P find(int x){\n    if(par[x].first == x) return par[x];\n    else {\n      P res = find(par[x].first);\n      return par[x] = P(res.first, res.second + par[x].second);\n    }\n  }\n\n  void unite(int x, int y, int cost){\n    P px = find(x);\n    P py = find(y);\n    if(px.first == py.first) return;\n    if(rank[px.first] < rank[py.first]) {\n      par[px.first] = P(py.first, py.second - px.second - cost);\n    }\n    else{\n      par[py.first] = P(px.first, px.second - py.second + cost);\n      if(rank[px.first] == rank[py.first]) rank[px.first]++;\n    }\n  }\n\n  bool same(int x, int y){ return find(x).first == find(y).first;}\n  int calc(int x, int y) { return par[y].second - par[x].second;}\n};\n\n\nint n,m;\nUnionFind uf;\n\nint main(){\n  while(cin >> n >> m && (n|m)){\n    uf.clear();\n    for(int i=0;i<m;i++){\n      char c;\n      int x,y,z;\n      cin >> c >> x >> y;\n\n      if(c == '!'){\n        cin >> z;\n        uf.unite(x, y, z);\n\n      } else {\n        if(uf.same(x, y)) cout << uf.calc(x, y) << endl;\n        else cout << \"UNKNOWN\" << endl;        \n        /*\n        cout << endl;\n        for(int i=1;i<=n;i++){\n          cout << i << \": \" << uf.par[i].first << ' ' << uf.par[i].second << endl;\n        }\n        */\n      }\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\nusing namespace std;\n \nint main(){\n  string str[4];\n  while(cin >> str[0] && str[0] != \"Q\"){\n    int ans = 0, a[4] = {0,1,2,3};\n    for(int i=1;i<4;i++) cin >> str[i];\n \n    bool f = true;\n    do{\n      for(int i2=-11;i2<12;i2++){\n        for(int i=1;i<11;i++){\n          if(i + i2 < 1) continue;\n          if(i + i2 >= 11) break;\n          for(int j=1;j<11;j++){\n            if(j + i2 < 1) continue;\n            if(j + i2 >= 11) break;\n            for(int k2=-11;k2<12;k2++){\n              for(int k=1;k<11;k++){\n                if(k + k2 < 1) continue;\n                if(k + k2 >= 11) break;\n                for(int l=1;l<11;l++){\n                  if(l + k2 < 1) continue;\n                  if(l + k2 >= 11) break;\n                  if(str[a[0]][k+k2] == str[a[2]][i+i2] && str[a[0]][l+k2] == str[a[3]][i] && str[a[1]][k] == str[a[2]][j+i2] && str[a[1]][l] == str[a[3]][j])\n                    ans = max(ans, (j-i-1)*(l-k-1));\n                }\n              }\n            }\n          }\n        }\n      }\n    }while(next_permutation(a,a+4));\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nint UF[110000];\nint w[110000];\nchar str[10];\npair<int,int> FIND(int a){\n\tif(UF[a]<0)return make_pair(a,0);\n\tpair<int,int> ret=FIND(UF[a]);\n\tw[a]+=ret.second;\n\tUF[a]=ret.first;\n\treturn make_pair(UF[a],w[a]);\n}\nvoid UNION(int a,int b,int c){\n\tif(FIND(a).first==FIND(b).first)return ;\n\tint p=FIND(b).first;\n\tif(b==p){\n\t\tUF[b]=a;\n\t\tw[b]=c;\n\t}else{\n\t\tUF[p]=a;\n\t\tw[p]=c-w[b];\n\t}\n}\nint main(){\n\tint a,b;\n\twhile(scanf(\"%d%d\",&a,&b),a){\n\t\tfor(int i=0;i<a;i++)UF[i]=-1;\n\t\tfor(int i=0;i<a;i++)w[i]=0;\n\t\tfor(int i=0;i<b;i++){\n\t\t\tscanf(\"%s\",str);\n\t\t\tif(str[0]=='!'){\n\t\t\t\tint p,q,r;scanf(\"%d%d%d\",&p,&q,&r);\n\t\t\t\tp--;q--;\n\t\t\t\tUNION(p,q,r);\n\t\t\t}else{\n\t\t\t\tint p,q;\n\t\t\t\tscanf(\"%d%d\",&p,&q);p--;q--;\n\t\t\t\tif(FIND(p).first!=FIND(q).first)printf(\"UNKNOWN\\n\");\n\t\t\t\telse printf(\"%d\\n\",FIND(q).second-FIND(p).second);\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<map>\n#include<set>\n#include<vector>\n#include<algorithm>\n#include<string.h>\n#include<queue>\n#include<stack>\n#include<climits>\n#include<cmath>\nusing namespace std;\n\nmap<int,vector<pair<int,int> > >ma;\nset<int>visited;\nint ans=0;\nbool dfs(int a,int b,int c,bool p){\n    if(a==b){\n        ans=c;\n        return true;\n    }\n    for(auto i : ma[a]){\n        if(!visited.count(i.first)){\n            if(dfs(i.first,b,p?c+i.second:c-i.second,p)){\n                return true;\n            }\n        }\n    }\n    for(auto i : ma[b]){\n        if(!visited.count(i.first)){\n            if(dfs(i.first,a,p?c-i.second:c+i.second,!p)){\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\nint main(){\n    int n,m;\n    while(cin>>n>>m,n){\n        ma.clear();\n        for(int i=0;i<m;i++){\n            char c;\n            cin>>c;\n            if(c=='!'){\n                int a,b,d;\n                cin>>a>>b>>d;\n                ma[a].push_back(make_pair(b, d));\n            } else {\n                int a,b;\n                cin>>a>>b;\n                if(dfs(a,b,0,1)){\n                    cout<<ans<<endl;\n                } else {\n                    cout<<\"UNKNOWN\"<<endl;\n                }\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define mp(a,b) make_pair((a),(b))\n#define pb(a) push_back((a))\n#define all(x) (x).begin(),(x).end()\n#define uniq(x) sort(all(x)),(x).erase(unique(all(x)),end(x))\n#define fi first\n#define se second\n#define dbg(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\nvoid _dbg(string){cout<<endl;}\ntemplate<class H,class... T> void _dbg(string s,H h,T... t){int l=s.find(',');cout<<s.substr(0,l)<<\" = \"<<h<<\", \";_dbg(s.substr(l+1),t...);}\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\n#define INF 1120000000\n\ntemplate <class T>\nclass WeightedUnionFind {\n  int n;\n  vector<int> par,sz;\n  vector<T> w;\n  // weight[i] : iがpar[i]よりどれだけ重いか\npublic:\n  WeightedUnionFind(){}\n  WeightedUnionFind(int _n) : n(_n) {\n    par.resize(n, -1);\n    sz.resize(n, 1);\n    w.resize(n, 0);\n  }\n  int find(int i){\n    if(par[i] < 0){\n      return i;\n    } else {\n      int p = find(par[i]);\n      w[i] += w[par[i]];\n      par[i] = p;\n      return p;\n    }\n  }\n  T weight(int x){\n    find(x);\n    return w[x];\n  }\n  bool same(int x, int y){\n    return find(x) == find(y);\n  }\n  // weight[i] +w の位置に j を配置\n  void unite(int i, int j, T nw){\n    nw += weight(i) - weight(j);\n    int x = find(i), y = find(j);\n    if(x == y) return;\n    if(sz[x] < sz[y]){\n      swap(x, y);\n      nw = -nw;\n    }\n    sz[x] += sz[y];\n    par[y] = x;\n    w[y] = nw;\n  }\n  // x からみた y の相対位置\n  T diff(int x, int y){\n    return weight(y) - weight(x);\n  }\n};\n\nint main(){\n  int n,m;\n  while(cin>>n>>m, n|m){\n    WeightedUnionFind<long> uf(n);\n    rep(i,m){\n      char s[5];\n      int a,b;\n      cin>>s>>a>>b;\n      a--;b--;\n      if(s[0]=='?'){\n        if(uf.same(a,b)) cout << uf.diff(a,b) << endl;\n        else cout << \"UNKNOWN\" << endl;\n      } else {\n        long c;\n        cin>>c;\n        uf.unite(a, b, c);\n      }\n    }\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <list>\n#include <set>\n#include <map>\n#include <queue>\n\nusing namespace std;\n#define DEBUG(x) cout<<#x<<\": \"<<x<<endl\n\n#define PB push_back\n#define MP make_pair\n#define F first\n#define S second\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n#define INT(a) int((a)+1e-9)\nint DX[4]={1,0,-1,0};\nint DY[4]={0,1,0,-1};\n\ntypedef pair<int,int> Pii;\n\n\n#define SUPnl 100002\n\nint nl;\nPii pt[SUPnl];\t//pt[n].F == n's parent, pt[n].S == w[pt[n].F]-w[n]\n\nvoid init(){REP(ni,nl){pt[ni]=MP(ni,0);}}\n\nPii getRoot(int n){\n\tif(pt[n].F==n) return pt[n];\n\tPii rpnt = getRoot(pt[n].F);\n\tpt[n]= MP(rpnt.F, rpnt.S+pt[n].S);\n\treturn pt[n];\n}\n\nvoid printW(int a, int b){\n\tPii rat=getRoot(a); Pii rbt=getRoot(b);\n\tif(rat.F!=rbt.F) //cout<<\"UNKNOWN\"<<endl;\n\t\t\t\t\tprintf(\"UNKNOWN\\n\");\n\telse //cout<< rbt.S - rat.S << endl;\n\t\tprintf(\"%d\\n\", rbt.S - rat.S );\n}\n\nvoid setW(int a, int b, int w){\n\tPii rat=getRoot(a); Pii rbt=getRoot(b);\n\tif(rat.F==rbt.F) return;\n\tif(rat.S+w>=rbt.S){\n\t\tpt[rbt.F]=MP(rat.F, rat.S+w-rbt.S);\n\t}else{\n\t\tpt[rat.F]=MP(rbt.F, rbt.S-w-rat.S);\n\t}\n}\n\nint main(){\n\twhile(true){\n\t\tint ol;\n\t\tcin>>nl>>ol;\t//scanf(\"%d%d\", &nl, &ol);\n\t\t\t\t\t\t\tif(!nl) return 0;\n\t\tinit();\n\t\tREP(oi,ol){\n\t\t\tchar ot; int a,b,w;\n\t\t\tcin>>ot;\t\t//scanf(\" %c \", &ot);\n\t\t\tif(ot=='!'){\n\t\t\t\tcin>>a>>b>>w;\t\t//scanf(\"%d%d%d\",&a,&b,&w);\n\t\t\t\tsetW(a-1,b-1,w);\n\t\t\t}\n\t\t\tif(ot=='?'){\n\t\t\t\tcin>>a>>b;\t\t\t//scanf(\"%d%d\",&a,&b);\n\t\t\t\tprintW(a-1,b-1);\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "// Wrongri-La Shower\n\n#include <iostream>\n#include <queue>\n#include <stack>\n#include <tuple>\n\ntypedef long long ll;\ntypedef std::tuple<int,ll> P;\n\ntemplate <int n>\nclass UnionFind{\npublic:\n    UnionFind(){\n        init();\n    }\n    void init(){\n        for(int i=0;i<n;i++){\n            par[i] = i;\n            rank[i] = 0;\n            weight[i] = 0ll;\n        }\n    }\n    P find(int x){\n        if(x == par[x])return std::make_tuple(x, weight[x]);\n\n        std::stack<int> v_stack;\n        std::queue<ll> w_queue;\n        ll w = 0;\n        while(x != par[x]){\n            w += weight[x];\n            w_queue.push(w);\n            v_stack.push(x);\n\n            x = par[x];\n        }\n        \n        while(!v_stack.empty()){\n            int a; ll b;\n            a = v_stack.top(); v_stack.pop();\n            b = w_queue.front(); w_queue.pop();\n            \n            par[a] = x;\n            weight[a] = b;\n        }\n        \n        return std::make_tuple(x, w);\n    }\n    bool same(int x, int y){\n        return std::get<0>(find(x)) == std::get<0>(find(y));\n    }\n    void unite(int x, int y, int l){\n        P xp = find(x), yp = find(y);\n        ll wx, wy;\n        std::tie(x, wx) = xp;\n        std::tie(y, wy) = yp;\n        \n        if(x == y){return;}\n        \n        if(rank[x] > rank[y]){\n            par[y] = x;\n            weight[y] = wx - wy + l;\n        }else{\n            par[x] = y;\n            weight[x] = wy - wx - l;\n            if(rank[x] == rank[y]){rank[y]++;}\n        }\n    }\n    int rank[n], par[n];\n    ll weight[n];\n};\n\nUnionFind<100001> uf;\n\nint main(){\n    std::ios_base::sync_with_stdio(false);\n    \n    int N, M;\n    while(std::cin >> N >> M, N || M){\n        uf.init();\n\n        for(int i=0;i<M;i++){\n            char c;\n            std::cin >> c;\n            \n            if(c == '!'){\n                int a, b, c;\n                std::cin >> a >> b >> c;\n\n                uf.unite(a, b, c);\n            }else{\n                int a, b;\n                std::cin >> a >> b;\n\n                if(!uf.same(a, b)){\n                    std::cout << \"UNKNOWN\" << std::endl;\n                }else{\n                    P ap = uf.find(a), bp = uf.find(b);\n                    ll wa = std::get<1>(ap), wb = std::get<1>(bp);\n\n                    std::cout << wb-wa << std::endl;\n                }\n            }\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<string>\n#include<map>\n#include<vector>\n#include<cstring>\n#include<cmath>\nusing namespace std;\nconst int maxn=100010;\nint set[maxn];\nint value[maxn];\nint weight[maxn];\nvoid Init(int n){\n\tfor(int i=0;i<=n;i++){\n\t\tset[i]=i;\n\t\tvalue[i]=0;\n\t\tweight[i]=0;\n\t}\n}\nint Find(int x){\n\tif(x==set[x]){\n\t\treturn x;\n\t}\n\tint temp=Find(set[x]);\n\tvalue[x]=value[set[x]]+weight[x];\n\tweight[x]=value[x]-value[temp];\n\tset[x]=temp;\n\treturn temp;\n}\nvoid Bin(int a,int b,int w){\n\ta=Find(a);\n\tb=Find(b);\n\tset[a]=b;\n\tweight[a]=w;\n}\nvoid Solve(){\n\tint n,m;\n\twhile(cin>>n>>m){\n\t\tif(n==0&&m==0){\n\t\t\treturn;\n\t\t}\n\t\tInit(n);\n\t\tint a,b,w;\n\t\tchar s[2];\n\t\tfor(int i=0;i<m;i++){\n\t\t\tcin>>s;\n\t\t\tif(s[0]=='!'){\n\t\t\t\tcin>>a>>b>>w;\n\t\t\t\tint fa,fb;\n\t\t\t\tfa=Find(a),fb=Find(b);\n\t\t\t\tif(fa==fb){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(value[b]+w>value[a]){\n\t\t\t\t\tBin(a,b,w);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tBin(b,a,w);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tcin>>a>>b;\n\t\t\t\tif(Find(a)!=Find(b)){\n\t\t\t\t\tcout<<\"UNKNOWN\"<<endl;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tcout<<value[a]-value[b]<<endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nint main(){\n\tSolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include <iostream>\n#include <math.h>\n#include <numeric>\n#include <vector>\n#include <map>\n#include <functional>\n#include <stdio.h>\n#include <array>\n#include <algorithm>\n#include <string>\n#include <string.h>\n#include <assert.h>\n#include <stdio.h>\n#include <queue>\n#include<iomanip>\n#include<bitset>\n#include<stack>\n#include<set>\n#include<limits>\n#include <complex>\n#include<cstdlib>\nusing namespace std;\n\nstruct UnionFind {\n\tvector<int> data;\n\tUnionFind(int size) : data(size, -1) { }\n\tbool unionSet(int x, int y) {\n\t\tx = root(x); y = root(y);\n\t\tif (x != y) {\n\t\t\tif (data[y] < data[x]) swap(x, y);\n\t\t\tdata[x] += data[y]; data[y] = x;\n\t\t}\n\t\treturn x != y;\n\t}\n\tbool findSet(int x, int y) {\n\t\treturn root(x) == root(y);\n\t}\n\tint root(int x) {\n\t\treturn data[x] < 0 ? x : data[x] = root(data[x]);\n\t}\n\tint size(int x) {\n\t\treturn -data[root(x)];\n\t}\n};\nstruct aUnionFind {\n\tvector<pair<int, long long int>> data;\n\taUnionFind(int size) : data(size, make_pair(-1, 0)) { }\n\tbool unionSet(int x, int y, long long int w) {\n\t\tconst int rx(root(x).first), ry(root(y).first);\n\t\tif (rx != ry) {\n\t\t\tdata[rx].first += data[ry].first; data[ry].first = rx;\n\t\t\tdata[ry].second =-data[y].second - w + data[x].second;\n\t\t}\n\t\treturn rx != ry;\n\t}\n\tbool findSet(int x, int y) {\n\t\treturn root(x) == root(y);\n\t}\n\tpair<int, int> root(int x) {\n\t\tif (data[x].first < 0) {\n\t\t\treturn make_pair(x, 0);\n\t\t}\n\t\telse {\n\t\t\tpair<int, long long int>ndata;\n\t\t\tndata.first = root(data[x].first).first;\n\t\t\tndata.second =data[x].second+ root(data[x].first).second;\n\t\t\treturn data[x]=ndata;\n\t\t}\n\t}\n\tint size(int x) {\n\t\treturn -data[root(x).first].first;\n\t}\n};\n\n\n\nint main() {\n\twhile (1) {\n\t\tint N, M; cin >> N >> M;\n\t\tif (!N)break;\n\t\tvector<pair<int,int>>weis(N,make_pair(-1,-1));\n\t\taUnionFind uf(N);\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\tchar c; cin >> c;\n\t\t\tif (c == '!') {\n\t\t\t\tint a, b, w; cin >> a >> b >> w;\n\t\t\t\ta--; b--;\n\t\t\t\tuf.unionSet(a, b,w);\n\t\t\t\t\n\t\t\t\t\n\t\t\t}\n\t\t\telse {\n\t\t\t\tint a, b; cin >> a >> b;\n\t\t\t\ta--; b--;\n\t\t\t\tif (uf.root(a).first == uf.root(b).first) {\n\t\t\t\t\tint aa=uf.root(a).second - uf.root(b).second;\n\t\t\t\t\tcout << aa << endl;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tcout << \"UNKNOWN\" << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\nlong long dist[1 << 18];\nlong long group[1 << 18]; char q;\nlong long n, Q, a, b, c;\nvector<long long>gr[1 << 18];\nint main() {\n\tfor (int t = 0; t < 13; t++) {\n\t\tfor (int i = 0; i < 1 << 18; i++) {\n\t\t\tdist[i] = 0; group[i] = i; gr[i].clear(); gr[i].push_back(i);\n\t\t}\n\t\tcin >> n >> Q; if (n == 0 && Q == 0)break;\n\t\tfor (int i = 0; i < Q; i++) {\n\t\t\tcin >> q;\n\t\t\tif (q == '?') {\n\t\t\t\tcin >> a >> b;\n\t\t\t\tif (group[a] != group[b])cout << \"UNKNOWN\" << endl;\n\t\t\t\telse cout << dist[b] - dist[a] << endl;\n\t\t\t}\n\t\t\tif (q == '!') {\n\t\t\t\tcin >> a >> b >> c;\n\t\t\t\tif (group[a] != group[b]) {\n\t\t\t\t\tint K = dist[a] + c - dist[b];\n\t\t\t\t\tint L = group[a], M = group[b];\n\t\t\t\t\tfor (int j = 0; j < gr[M].size(); j++) {\n\t\t\t\t\t\tgroup[gr[M][j]] = L;\n\t\t\t\t\t\tgr[L].push_back(gr[M][j]);\n\t\t\t\t\t\tdist[gr[M][j]] += K;\n\t\t\t\t\t}\n\t\t\t\t\tgr[M].clear();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <cstdint>\n\nclass UnionFind {\n  std::vector<int> vertex;\n  std::vector<intmax_t> weight;\n\npublic:\n  UnionFind(size_t V): vertex(V+1, -1), weight(V+1, 0) {}\n\n  bool unite(size_t u, size_t v, intmax_t w) {\n    //if (u >= 0) u = find(u);\n    //if (v >= 0) v = find(v);\n    if (u == v) return false;\n    if (vertex[find(u)] > vertex[find(v)]) {\n      std::swap(u, v);\n      w = -w;\n    }\n\n    // u:parent, v:child\n    vertex[find(u)] += vertex[find(v)];\n    vertex[v] = u;\n    weight[v] = w;\n    return true;\n  }\n\n  int find(size_t v) const {\n    while (vertex[v] >= 0)\n      v = vertex[v];\n\n    return v;\n  }\n\n  bool connected(size_t u, size_t v) const {\n    return find(u) == find(v);\n  }\n\n  intmax_t relweight(size_t u) const {\n    if (vertex[u] < 0) {\n      return 0;\n    }\n\n    return weight[u] + relweight(vertex[u]);\n  }\n};\n\nint testcase_ends() {\n  int N, M;\n  scanf(\"%d %d\", &N, &M);\n\n  if (N == 0)\n    return 1;\n\n  UnionFind uf(N);\n\n  for (int i=0; i<M; ++i) {\n    char ch;\n    scanf(\" %c\", &ch);\n\n    if (ch == '?') {\n      int a, b;\n      scanf(\"%d %d\", &a, &b);\n      //--a, --b;\n      if (uf.connected(a, b)) {\n        printf(\"%jd\\n\", uf.relweight(b)-uf.relweight(a));\n      } else {\n        printf(\"UNKNOWN\\n\");\n      }\n    } else if (ch == '!') {\n      int a, b, w;\n      //--a, --b;\n      scanf(\"%d %d %d\", &a, &b, &w);\n      uf.unite(a, b, w);\n    }\n  }\n\n  return 0;\n}\n\nint main() {\n  while (!testcase_ends()) {}\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nclass union_find{\n\tvector<int> a,h;\npublic:\n\tunion_find(int n):a(n,-1),h(n){}\n\tint find(int x){\n\t\tif(a[x]<0) return x;\n\t\th[x]+=h[a[x]];\n\t\treturn a[x]=find(a[x]);\n\t}\n\tvoid update(int x,int y,int w){\n\t\tint rx=find(x);\n\t\tint ry=find(y);\n\t\tif(rx!=ry){\n\t\t\ta[rx]+=a[ry];\n\t\t\ta[ry]=rx;\n\t\t\th[ry]=w-h[y]+h[x];\n\t\t}\n\t}\n\tint query(int x,int y){\n\t\treturn h[y]-h[x];\n\t}\n};\n\nint main(){\n\tfor(int n,q;scanf(\"%d%d\",&n,&q),n;){\n\t\tunion_find U(n);\n\t\twhile(q--){\n\t\t\tchar c;\n\t\t\tint a,b; scanf(\" %c%d%d\",&c,&a,&b); a--; b--;\n\t\t\tif(c=='!'){ // update\n\t\t\t\tint w; scanf(\"%d\",&w);\n\t\t\t\tU.update(a,b,w);\n\t\t\t}\n\t\t\telse{ // query\n\t\t\t\tif(U.find(a)!=U.find(b)) puts(\"UNKNOWN\"); else printf(\"%d\\n\",U.query(a,b));\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n//#include<cctype>\n#include<climits>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n//#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n//#include<numeric>\n#include<utility>\n//#include<memory>\n#include<functional>\n#include<cassert>\n#include<set>\n#include<stack>\n#include<random>\n\nconst int dx[] = {1, 0, -1, 0};\nconst int dy[] = {0, -1, 0, 1};\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef pair<int, int> pii;\n\nint N, M;\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while (cin >> N >> M) {\n        if (N==0 && M==0) break;\n        vector<int> W(N), i2g(N);\n        vector<vector<int> > g2i(N);\n        // init\n        for (int i = 0; i < N; i++) {\n            i2g[i] = i;\n            g2i[i].push_back(i);\n        }\n        while (M--) {\n            char c;\n            cin >> c;\n            if (c == '!') {\n                int a, b, w;\n                cin >> a >> b >> w;\n                a--; b--;\n                if (i2g[a] == i2g[b]) {\n                    assert(W[b]-W[a] == w);\n                } else {\n                    // merge\n                    if (g2i[i2g[a]].size() < g2i[i2g[b]].size()) {\n                        swap(a, b);\n                        w = -w;\n                    }\n                    int ga = i2g[a], gb = i2g[b];\n                    int diff = (W[a]+w) - W[b];\n                    for (int el : g2i[gb]) {\n                        i2g[el] = ga; \n                        W[el] += diff;\n                    }\n                    g2i[ga].insert(g2i[ga].end(), g2i[gb].begin(), g2i[gb].end());\n                    g2i[gb].clear();\n                }\n            } else {\n                int a, b;\n                cin >> a >> b;\n                a--; b--;\n                if (i2g[a] != i2g[b]) {\n                    cout << \"UNKNOWN\" << endl;\n                } else {\n                    cout << W[b]-W[a] << endl;\n                }\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <array>\n#include <bitset>\n#include <cassert>\n#include <cfloat>\n#include <cmath>\n#include <cstdint>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <forward_list>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <regex>\n#include <set>\n#include <stack>\n#include <string>\n#include <tuple>\n#include <type_traits>\n#include <unordered_map>\n#include <unordered_set>\n#include <utility>\n#include <vector>\n#ifdef DEBUG\n#include <fmt/format.h>\n#include <fmt/ostream.h>\n#endif\nusing namespace std;\nusing i8 = int8_t;\nusing u8 = uint8_t;\nusing i16 = int16_t;\nusing u16 = uint16_t;\nusing i32 = int32_t;\nusing u32 = uint32_t;\nusing i64 = int64_t;\nusing u64 = uint64_t;\ntemplate<typename T>\nusing max_heap = priority_queue<T, vector<T>, less<T>>;\ntemplate<typename T>\nusing min_heap = priority_queue<T, vector<T>, greater<T>>;\n#ifdef __clang__\n#pragma clang diagnostic push\n#pragma clang diagnostic ignored \"-Wunused-const-variable\"\n#endif\nconstexpr bool AUTOFLUSH = false;\nconstexpr bool STDIO_ENABLE = false;\nconstexpr int IOS_PREC = 12;\nconstexpr int INF_I32 = 1'010'000'000;\nconstexpr i64 INF_I64 = 1'010'000'000'000'000'000LL;\nconstexpr auto INF = INF_I64;\nconstexpr double EPS = 1e-12;\nconstexpr i64 MOD = 1'000'000'007;\n#ifdef __clang__\n#pragma clang diagnostic pop\n#endif\nconstexpr i32 I32_MAX = numeric_limits<i32>::max();\nconstexpr i32 I32_MIN = numeric_limits<i32>::min();\nconstexpr i64 I64_MAX = numeric_limits<i64>::max();\nconstexpr i64 I64_MIN = numeric_limits<i64>::min();\ntemplate<typename T, size_t N, size_t... NS>\nstruct ArrayStruct {\n using type = array<typename ArrayStruct<T,NS...>::type,N>;\n};\ntemplate<typename T, size_t N>\nstruct ArrayStruct<T,N> {\n using type = array<T,N>;\n};\ntemplate<typename T, size_t N, size_t... NS>\nusing Array = typename ArrayStruct<T,N,NS...>::type;\ntemplate<typename T>\nint GETBIT(T x, int i) {\n return (x>>i) & 1;\n}\ntemplate<typename T>\nvoid SETBIT(T& x, int i) {\n x |= (T(1)<<i);\n}\ntemplate<typename T>\nvoid CLEARBIT(T& x, int i) {\n x &= ~(T(1)<<i);\n}\ntemplate<typename T>\nconstexpr T ABS(T x) {\n static_assert(is_signed<T>::value, \"ABS(): argument must be signed\");\n return x < 0 ? -x : x;\n}\ntemplate<typename T>\nconstexpr T abs_diff(T x, T y) {\n return x < y ? y-x : x-y;\n}\nconstexpr i64 MID(i64 x, i64 y) {\n i64 lo = min(x, y);\n i64 hi = max(x, y);\n return (lo < 0 && hi >= 0) ? (lo+hi)/2 : lo + (hi-lo)/2;\n}\ntemplate<typename Pred>\ni64 bin_search(i64 lo, i64 hi, Pred pred) {\n assert(lo < hi);\n while(lo+1 < hi) {\n i64 mid = MID(lo, hi);\n if(pred(mid))\n lo = mid;\n else\n hi = mid;\n }\n return lo;\n}\ntemplate<typename Pred>\ndouble bin_search_real(double lo, double hi, Pred pred, int iter=100) {\n assert(lo < hi);\n for(int i = 0; i < iter; ++i) {\n double mid = (lo+hi) / 2.0;\n if(pred(mid))\n lo = mid;\n else\n hi = mid;\n }\n return lo;\n}\ntemplate<typename T>\nconstexpr bool is_odd(T x) {\n return x % 2 != 0;\n}\ntemplate<typename T>\nconstexpr bool is_even(T x) {\n return x % 2 == 0;\n}\ntemplate<typename T>\nconstexpr bool parity_same(T x, T y) {\n return (is_odd(x) && is_odd(y)) || (is_even(x) && is_even(y));\n}\ntemplate<typename T>\nconstexpr int cmp(T x, T y) {\n return (y < x) - (x < y);\n}\ntemplate<typename T>\nconstexpr int sgn(T x) {\n return cmp(x, T(0));\n}\ntemplate<typename T>\nconstexpr T ipow(T a, T b) {\n assert(b >= 0);\n T res(1);\n for(T i = 0; i < b; ++i)\n res *= a;\n return res;\n}\ntemplate<\n typename T,\n std::enable_if_t<\n std::is_integral<T>::value &&\n std::is_signed<T>::value, std::nullptr_t> = nullptr>\nconstexpr T div_ceil(T a, T b) {\n return a/b + (((a<0)^(b>0)) && (a%b));\n}\ntemplate<\n typename T,\n std::enable_if_t<\n std::is_integral<T>::value &&\n std::is_unsigned<T>::value, std::nullptr_t> = nullptr>\nconstexpr T div_ceil(T a, T b) {\n return a/b + !!(a%b);\n}\ntemplate<\n typename T,\n std::enable_if_t<\n std::is_integral<T>::value &&\n std::is_signed<T>::value, std::nullptr_t> = nullptr>\nconstexpr T div_floor(T a, T b) {\n return a/b - (((a>0)^(b>0)) && (a%b));\n}\ntemplate<\n typename T,\n std::enable_if_t<\n std::is_integral<T>::value &&\n std::is_unsigned<T>::value, std::nullptr_t> = nullptr>\nconstexpr T div_floor(T a, T b) {\n return a/b;\n}\ntemplate<typename T, typename U>\nconstexpr auto modulo(T a, U b) {\n using R = common_type_t<T,U>;\n assert(0 < b);\n R r = a % b;\n return r >= 0 ? r : r+b;\n}\ntemplate<typename T>\nconstexpr T clamp(T x, T lo, T hi) {\n assert(lo <= hi);\n if(x < lo)\n return lo;\n else if(hi < x)\n return hi;\n else\n return x;\n}\ni64 isqrt(i64 x) {\n assert(x >= 0);\n i64 lo = 0;\n i64 hi = 3037000500LL;\n return bin_search(lo, hi, [x](i64 r) { return r*r <= x; });\n}\ntemplate<typename T, typename U>\nbool chmax(T& xmax, const U& x) {\n if(xmax < x) {\n xmax = x;\n return true;\n }\n else {\n return false;\n }\n}\ntemplate<typename T, typename U>\nbool chmin(T& xmin, const U& x) {\n if(x < xmin) {\n xmin = x;\n return true;\n }\n else {\n return false;\n }\n}\ntemplate<typename T>\nconstexpr int SIZE(const T& c) {\n return static_cast<int>(c.size());\n}\ntemplate<typename T, size_t N>\nconstexpr int SIZE(const T (&)[N]) {\n return static_cast<int>(N);\n}\ntemplate<typename InputIt, typename T>\nint argfind(InputIt first, InputIt last, const T& x) {\n auto it = find(first, last, x);\n return distance(first, it);\n}\ntemplate<typename InputIt>\nint argmax(InputIt first, InputIt last) {\n auto it = max_element(first, last);\n return distance(first, it);\n}\ntemplate<typename InputIt>\nint argmin(InputIt first, InputIt last) {\n auto it = min_element(first, last);\n return distance(first, it);\n}\ntemplate<typename InputIt>\nbool alltrue(InputIt first, InputIt last) {\n return all_of(first, last, [](bool b) { return b; });\n}\ntemplate<typename InputIt>\nbool anytrue(InputIt first, InputIt last) {\n return any_of(first, last, [](bool b) { return b; });\n}\ntemplate<typename InputIt>\nbool allfalse(InputIt first, InputIt last) {\n return !anytrue(first, last);\n}\ntemplate<typename InputIt>\nbool anyfalse(InputIt first, InputIt last) {\n return !alltrue(first, last);\n}\ntemplate<typename T>\narray<pair<T,T>,4> neighbor4(const T& x, const T& y) {\n return array<pair<T,T>,4> {{\n { x, y-1 },\n { x-1, y }, { x+1, y },\n { x, y+1 },\n }};\n}\ntemplate<typename T>\narray<pair<T,T>,8> neighbor8(const T& x, const T& y) {\n return array<pair<T,T>,8> {{\n { x-1, y-1 }, { x, y-1 }, { x+1, y-1 },\n { x-1, y }, { x+1, y },\n { x-1, y+1 }, { x, y+1 }, { x+1, y+1 },\n }};\n}\ntemplate<typename T>\nbool in_bounds(const T& x, const T& minx, const T& maxx) {\n return !(x < minx) && !(maxx < x);\n}\ntemplate<typename T>\nbool in_bounds_2(\n const T& x, const T& y,\n const T& minx, const T& miny,\n const T& maxx, const T& maxy) {\n return in_bounds(x, minx, maxx) && in_bounds(y, miny, maxy);\n}\ntemplate<typename T>\nbool in_bounds_wh(const T& x, const T& y, const T& w, const T& h) {\n return in_bounds_2(x, y, 0, 0, w-1, h-1);\n}\nstruct pairhash {\n template<typename T1, typename T2>\n size_t operator()(const pair<T1,T2>& p) const {\n size_t res = 17;\n res = 31*res + hash<T1>()(p.first);\n res = 31*res + hash<T2>()(p.second);\n return res;\n }\n};\nstruct vectorhash {\n template<typename T>\n size_t operator()(const vector<T>& v) const {\n size_t res = 17;\n res = 31*res + hash<size_t>()(v.size());\n for(const auto& e : v) {\n res = 31*res + hash<T>()(e);\n }\n return res;\n }\n};\ntemplate<typename K, typename V>\npair<typename map<K,V>::iterator, bool> insert_or_assign(map<K,V>& m, const K& k, const V& v) {\n auto it = m.lower_bound(k);\n if(it != end(m) && !m.key_comp()(k,it->first)) {\n it->second = v;\n return make_pair(it, false);\n }\n else {\n auto it_ins = m.insert(it, make_pair(k,v));\n return make_pair(it_ins, true);\n }\n}\ntemplate<typename K, typename V>\npair<typename unordered_map<K,V>::iterator, bool>\ninsert_or_assign(unordered_map<K,V>& m, const K& k, const V& v) {\n auto it = m.find(k);\n if(it != end(m)) {\n it->second = v;\n return make_pair(it, false);\n }\n else {\n auto it_ins = m.insert(it, make_pair(k,v));\n return make_pair(it_ins, true);\n }\n}\ntemplate<typename T>\nstring TO_STRING(const T& x) {\n ostringstream out;\n out << x;\n return out.str();\n}\ntemplate<typename InputIt>\nstring JOIN(InputIt first, InputIt last, const string& sep) {\n ostringstream out;\n while(first != last) {\n out << *first++;\n if(first != last)\n out << sep;\n }\n return out.str();\n}\ntemplate<typename InputIt>\nauto SUM(InputIt first, InputIt last) {\n using T = typename iterator_traits<InputIt>::value_type;\n return accumulate(first, last, T());\n}\ntemplate<typename T>\nvoid UNIQ(T& c) {\n c.erase(unique(begin(c), end(c)), end(c));\n}\ntemplate<typename T>\nvoid RD(T& x) {\n cin >> x;\n#ifdef DEBUG\n if(!cin) assert(false);\n#endif\n}\ntemplate<typename T>\nvoid RD(vector<T>& v, int n) {\n v.reserve(n);\n for(int i = 0; i < n; ++i) {\n T e; RD(e);\n v.emplace_back(e);\n }\n}\ntemplate<typename InputIt>\nostream& FPRINTSEQ(ostream& out, InputIt first, InputIt last) {\n for(InputIt it = first; it != last; ++it) {\n if(it != first) out << ' ';\n out << *it;\n }\n return out;\n}\ntemplate<typename InputIt>\nostream& PRINTSEQ(InputIt first, InputIt last) {\n return FPRINTSEQ(cout, first, last);\n}\ntemplate<typename InputIt>\nostream& DPRINTSEQ(InputIt first, InputIt last) {\n#ifdef DEBUG\n FPRINTSEQ(cerr, first, last);\n#endif\n return cerr;\n}\ntemplate<typename T, size_t N>\nostream& FPRINTARRAY1(ostream& out, const T (&c)[N]) {\n return FPRINTSEQ(out, cbegin(c), cend(c));\n}\ntemplate<typename T, size_t N>\nostream& PRINTARRAY1(const T (&c)[N]) {\n return FPRINTARRAY1(cout, c);\n}\ntemplate<typename T, size_t N>\nostream& DPRINTARRAY1(const T (&c)[N]) {\n#ifdef DEBUG\n FPRINTARRAY1(cerr, c);\n#endif\n return cerr;\n}\ntemplate<typename T, size_t N1, size_t N2>\nostream& FPRINTARRAY2(ostream& out, const T (&c)[N1][N2]) {\n out << '\\n';\n for(const auto& e : c) {\n FPRINTARRAY1(out, e) << '\\n';\n }\n return out;\n}\ntemplate<typename T, size_t N1, size_t N2>\nostream& PRINTARRAY2(const T (&c)[N1][N2]) {\n return FPRINTARRAY2(cout, c);\n}\ntemplate<typename T, size_t N1, size_t N2>\nostream& DPRINTARRAY2(const T (&c)[N1][N2]) {\n#ifdef DEBUG\n FPRINTARRAY2(cerr, c);\n#endif\n return cerr;\n}\ntemplate<typename T>\nostream& operator<<(ostream& out, const vector<T>& c) {\n return FPRINTSEQ(out, cbegin(c), cend(c));\n}\ntemplate<typename T>\nostream& operator<<(ostream& out, const vector<vector<T>>& c) {\n out << '\\n';\n for(const auto& e : c) {\n out << e << '\\n';\n }\n return out;\n}\nostream& operator<<(ostream& out, const vector<string>& c) {\n out << '\\n';\n for(const string& e : c) {\n out << e << '\\n';\n }\n return out;\n}\ntemplate<typename T>\nostream& operator<<(ostream& out, const deque<T>& c) {\n return FPRINTSEQ(out, cbegin(c), cend(c));\n}\ntemplate<typename T>\nostream& operator<<(ostream& out, const list<T>& c) {\n return FPRINTSEQ(out, cbegin(c), cend(c));\n}\ntemplate<typename T>\nostream& operator<<(ostream& out, const forward_list<T>& c) {\n return FPRINTSEQ(out, cbegin(c), cend(c));\n}\ntemplate<typename T>\nostream& operator<<(ostream& out, const set<T>& c) {\n return FPRINTSEQ(out, cbegin(c), cend(c));\n}\ntemplate<typename T>\nostream& operator<<(ostream& out, const unordered_set<T>& c) {\n return out << set<T>(cbegin(c), cend(c));\n}\ntemplate<typename T>\nostream& operator<<(ostream& out, const multiset<T>& c) {\n return FPRINTSEQ(out, cbegin(c), cend(c));\n}\ntemplate<typename T>\nostream& operator<<(ostream& out, const unordered_multiset<T>& c) {\n return out << multiset<T>(cbegin(c), cend(c));\n}\ntemplate<typename T, size_t N>\nostream& operator<<(ostream& out, const array<T,N>& c) {\n return FPRINTSEQ(out, cbegin(c), cend(c));\n}\ntemplate<typename InputIt>\nostream& FPRINTMAP(ostream& out, InputIt first, InputIt last) {\n out << \"{\\n\";\n for(auto it = first; it != last; ++it) {\n out << \"  \" << it->first << \" : \" << it->second << '\\n';\n }\n out << \"}\\n\";\n return out;\n}\ntemplate<typename InputIt>\nostream& PRINTMAP(InputIt first, InputIt last) {\n return FPRINTMAP(cout, first, last);\n}\ntemplate<typename InputIt>\nostream& DPRINTMAP(InputIt first, InputIt last) {\n#ifdef DEBUG\n FPRINTMAP(cerr, first, last);\n#endif\n return cerr;\n}\ntemplate<typename K, typename V>\nostream& operator<<(ostream& out, const map<K,V>& c) {\n return FPRINTMAP(out, cbegin(c), cend(c));\n}\ntemplate<typename K, typename V>\nostream& operator<<(ostream& out, const unordered_map<K,V>& c) {\n return out << map<K,V>(cbegin(c), cend(c));\n}\ntemplate<typename K, typename V>\nostream& operator<<(ostream& out, const multimap<K,V>& c) {\n return FPRINTMAP(out, cbegin(c), cend(c));\n}\ntemplate<typename K, typename V>\nostream& operator<<(ostream& out, const unordered_multimap<K,V>& c) {\n return out << multimap<K,V>(cbegin(c), cend(c));\n}\ntemplate<typename T, typename C>\nostream& operator<<(ostream& out, stack<T,C> c) {\n while(!c.empty()) {\n out << c.top();\n c.pop();\n if(!c.empty()) out << ' ';\n }\n return out;\n}\ntemplate<typename T, typename C>\nostream& operator<<(ostream& out, queue<T,C> c) {\n while(!c.empty()) {\n out << c.front();\n c.pop();\n if(!c.empty()) out << ' ';\n }\n return out;\n}\ntemplate<typename T, typename Cont, typename Cmp>\nostream& operator<<(ostream& out, priority_queue<T,Cont,Cmp> c) {\n while(!c.empty()) {\n out << c.top();\n c.pop();\n if(!c.empty()) out << ' ';\n }\n return out;\n}\ntemplate<typename T1, typename T2>\nostream& operator<<(ostream& out, const pair<T1,T2>& p) {\n return out << '(' << p.first << ',' << p.second << ')';\n}\ntemplate<typename Tuple, size_t Pos>\nostream& FPRINTTUPLE(ostream& out, const Tuple&) {\n return out;\n}\ntemplate<typename Tuple, size_t Pos, typename T, typename... TS>\nostream& FPRINTTUPLE(ostream& out, const Tuple& t) {\n if(Pos != 0)\n out << ',';\n out << get<Pos>(t);\n return FPRINTTUPLE<Tuple,Pos+1,TS...>(out, t);\n}\ntemplate<typename... TS>\nostream& operator<<(ostream& out, const tuple<TS...>& t) {\n out << '(';\n FPRINTTUPLE<tuple<TS...>,0,TS...>(out, t);\n out << ')';\n return out;\n}\nostream& FPRINT(ostream& out) { return out; }\ntemplate<typename T, typename... TS>\nostream& FPRINT(ostream& out, const T& x, const TS& ...args) {\n out << x;\n if(sizeof...(args))\n out << ' ';\n return FPRINT(out, args...);\n}\ntemplate<typename... TS>\nostream& FPRINTLN(ostream& out, const TS& ...args) {\n FPRINT(out, args...);\n return out << '\\n';\n}\ntemplate<typename... TS>\nostream& PRINT(const TS& ...args) {\n return FPRINT(cout, args...);\n}\ntemplate<typename... TS>\nostream& PRINTLN(const TS& ...args) {\n return FPRINTLN(cout, args...);\n}\ntemplate<typename... TS>\nostream& DPRINT(const TS& ...args) {\n#ifdef DEBUG\n FPRINT(cerr, args...);\n#endif\n return cerr;\n}\ntemplate<typename... TS>\nostream& DPRINTLN(const TS& ...args) {\n#ifdef DEBUG\n FPRINTLN(cerr, args...);\n#endif\n return cerr;\n}\nvoid FLUSH() {\n if(STDIO_ENABLE)\n fflush(stdout);\n else\n cout.flush();\n}\n[[noreturn]] void EXIT() {\n#ifdef DEBUG\n fflush(stdout);\n fflush(stderr);\n cout.flush();\n cerr.flush();\n#else\n FLUSH();\n#endif\n _Exit(0);\n}\nstruct IoInit {\n IoInit() {\n#ifndef DEBUG\n cin.tie(nullptr);\n if(!STDIO_ENABLE)\n ios::sync_with_stdio(false);\n#endif\n cout << fixed << setprecision(IOS_PREC);\n if(AUTOFLUSH) {\n if(STDIO_ENABLE)\n setvbuf(stdout, nullptr, _IONBF, 0);\n cout << unitbuf;\n }\n }\n} IOINIT;\n#define FOR(i,start,end) for(i64 i = (start); i < (end); ++i)\n#define REP(i,n) FOR(i, 0, n)\n#define ALL(f,c,...) (([&](decltype((c)) cc) { return (f)(begin(cc), end(cc), ## __VA_ARGS__); })(c))\n#define GENERIC(f) ([](auto&&... args) -> decltype(auto) { return (f)(forward<decltype(args)>(args)...); })\n#define MEMSET(a,v) memset((a), (v), sizeof(a))\n#define DBG(x) DPRINTLN('L', __LINE__, ':', #x, ':', (x))\nclass WeightedUnionFind {\npublic:\n vector<i64> p;\n vector<i64> w;\n i64 n_set;\n WeightedUnionFind(i64 n) : p(n, -1), w(n, 0), n_set(n) {}\n i64 node_count() const { return SIZE(p); }\n i64 set_count() const { return n_set; }\n i64 set_size(i64 x) { return -p[root(x)]; }\n bool is_root(i64 x) const { return p[x] < 0; }\n i64 root(i64 x) {\n i64 res; tie(res,ignore) = compress(x);\n return res;\n }\n i64 weight(i64 x) {\n i64 res; tie(ignore,res) = compress(x);\n return res;\n }\n bool unite(i64 x, i64 y, i64 d) {\n i64 rx = root(x);\n i64 ry = root(y);\n i64 wx = weight(x);\n i64 wy = weight(y);\n if(rx == ry) {\n return wx + d == wy;\n }\n if(set_size(rx) < set_size(ry)) {\n swap(rx, ry);\n swap(wx, wy);\n d *= -1;\n }\n p[rx] += p[ry];\n p[ry] = rx;\n w[ry] = wx - wy + d;\n return true;\n }\n bool same(i64 x, i64 y) {\n return root(x) == root(y);\n }\nprivate:\n tuple<i64,i64> compress(i64 x) {\n if(is_root(x)) return make_tuple(x, 0);\n i64 r,d; tie(r,d) = compress(p[x]);\n p[x] = r;\n w[x] += d;\n return make_tuple(r, w[x]);\n }\n};\nvoid solve(i64 N, i64 M) {\n WeightedUnionFind uf(N);\n REP(_, M) {\n char c; RD(c);\n i64 a,b; RD(a); RD(b); --a; --b;\n if(c == '!') {\n i64 w; RD(w);\n if(!uf.unite(a, b, w)) {\n assert(false);\n }\n }\n else if(c == '?') {\n if(!uf.same(a, b)) {\n PRINTLN(\"UNKNOWN\");\n }\n else {\n i64 ans = uf.weight(b) - uf.weight(a);\n PRINTLN(ans);\n }\n }\n else {\n assert(false);\n }\n }\n}\nsigned main(signed , char** ) {\n while(true) {\n i64 N, M; RD(N); RD(M);\n if(N == 0 && M == 0) break;\n solve(N, M);\n }\n EXIT();\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n\nusing namespace std;\n\ntypedef long long LL;\nstruct Node {\n    int root;\n    LL diff;\n};\n\nint root(int n, vector<Node> &nodes) {\n    if(nodes[n].root == n) return n;\n    const int tmp = nodes[n].root;\n    const int r = root(nodes[n].root, nodes);\n    nodes[n].diff += nodes[tmp].diff;\n    return nodes[n].root = nodes[r].root;\n}\n\nbool unite(int a, int b, vector<Node> &nodes, int w) {\n    const int ra = root(a, nodes);\n    const int rb = root(b, nodes);\n    if(nodes[ra].root == nodes[rb].root) return false;\n    nodes[ra].root = nodes[rb].root;\n    nodes[ra].diff = w - nodes[a].diff;\n    return true;\n}\n\nbool solve() {\n    int N, M;\n    cin >> N >> M;\n    if(!N && !M) return false;\n\n    vector<Node> nodes(N);\n    for(int i = 0; i < N; ++i) {\n        nodes[i].root = i;\n        nodes[i].diff = 0;\n    }\n    for(int i = 0; i < M; ++i) {\n        string cmd;\n        cin >> cmd;\n        if(cmd == \"!\") {\n            int a, b, w;\n            cin >> a >> b >> w;\n            --a; --b;\n            unite(a, b, nodes, w);\n        } else {\n            int a, b;\n            cin >> a >> b;\n            --a; --b;\n            const int ra = root(a, nodes);\n            const int rb = root(b, nodes);\n            if(nodes[ra].root != nodes[rb].root) {\n                cout << \"UNKNOWN\" << endl;\n            } else {\n                const LL diff = nodes[a].diff - nodes[b].diff;\n                cout << diff << endl;\n            }\n        }\n    }\n    return true;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n\n    while(solve()) ;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nclass WeightedDisjointSets\n{\nprivate:\n    using T = ll;\n    vector<int> parent, rank;\n    vector<T> weight;\n\npublic:\n    WeightedDisjointSets(const int v) : parent(v), rank(v, 0), weight(v, 0) { iota(parent.begin(), parent.end(), 0); }\n    bool same(const int a, const int b) { return find(a) == find(b); }\n    int find(const int a) { return parent[a] == a ? a : (weight[a] += weight[parent[a]], parent[a] = find(parent[a])); }\n    T getWeight(const int a) { return find(a), weight[a]; }\n    void unite(int a, int b, T d)\n    {\n        d += getWeight(a) - getWeight(b);\n        a = find(a), b = find(b);\n        if (a == b) { return; }\n        if (rank[a] < rank[b]) { swap(a, b), d = -d; }\n        rank[a] += rank[b], parent[b] = a, weight[b] = d;\n    }\n    T diff(const int a, const int b) { return getWeight(b) - getWeight(a); }\n};\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while (true) {\n        int N, M;\n        cin >> N >> M;\n        if (N == 0 and M == 0) { break; }\n        WeightedDisjointSets uf(N);\n        for (int i = 0; i < M; i++) {\n            char c;\n            int a, b;\n            cin >> c >> a >> b;\n            a--, b--;\n            if (c == '!') {\n                ll c;\n                cin >> c;\n                uf.unite(a, b, c);\n            } else {\n                if (uf.same(a, b)) { cout << uf.diff(a, b) << \"\\n\"; }\n                if (not uf.same(a, b)) { cout << \"UNKNOWN\\n\"; }\n                // cout << (uf.same(a, b) ? to_string(uf.diff(a, b)) : \"UNKNOWN\") << \"\\n\";\n            }\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int M = 1000000007;\n\nvector<int> grp, val;\nvector<vector<int>> lis;\nvoid init(int n) {\n    grp.resize(n);\n    val.resize(n, 0);\n    lis.resize(n, vector<int>(1));\n    for (int i = 0; i < n; ++i) {\n        grp[i] = i;\n        lis[i][0] = i;\n    }\n}\nvoid merge(int p, int q, int w) {\n    if (grp[p] == grp[q]) return;\n    if (lis[grp[p]].size() < lis[grp[q]].size()) {\n        merge(q, p, -w);\n        return;\n    }\n    int d = w + val[p] - val[q];\n    int g = grp[q];\n    for (int i : lis[g]) {\n        grp[i] = grp[p];\n        val[i] += d;\n        lis[grp[p]].emplace_back(i);\n    }\n    lis[g].clear();\n}\n\nint main() {\n    while (1) {\n        int n, m;\n        cin >> n >> m;\n        if (!n) return 0;\n        init(n);\n        for (int i = 0; i < m; ++i) {\n            char c;\n            cin >> c;\n            if (c == '!') {\n                int p, q, w;\n                cin >> p >> q >> w;\n                merge(p - 1, q - 1, w);\n            }\n            else {\n                int p, q;\n                cin >> p >> q;\n                --p;\n                --q;\n                if (grp[p] != grp[q])\n                    puts(\"UNKNOWN\");\n                else\n                    printf(\"%lld\\n\", val[q] - val[p]);\n            }\n        }\n        for (int i = 0; i < n; ++i)\n            lis[i].clear();\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n#include <fstream>\n#include <bitset>\n   \nusing namespace std;\n   \n \n#define rep(i, n) for (int i = 0; i < (int)(n); ++i)\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define rforeach(it, c) for (__typeof__((c).rbegin()) it=(c).rbegin(); it != (c).rend(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define CL(arr, val) memset(arr, val, sizeof(arr))\n#define COPY(dest, src) memcpy(dest, src, sizeof(dest))\n#define ten(n) ((long long)(1e##n))\n#define bin(n) (1LL << (n))\n#define erep(i, n) for (int i = 0; i <= (int)(n); ++i)\n#define revrep(i, n) for (int i = (n); i >= 0; --i)\n#define pb push_back\n\ntemplate <class T> void chmax(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void chmin(T& a, const T& b) { a = min(a, b); }\n \ntemplate <class T> void uniq(vector<T>& c) { sort(c.begin(), c.end()); c.erase(unique(c.begin(), c.end()), c.end()); }\n \ntemplate <class T> string to_s(const T& a) { ostringstream os; os << a; return os.str(); }\ntemplate <class T> T to_T(const string& s) { istringstream is(s); T res; is >> res; return res; }\n  \ntemplate <class T, class U> ostream& operator<<(ostream& os, pair<T, U>& p) { os << \"( \" << p.first << \", \" << p.second << \" )\"; return os; }\n  \ntemplate <class T> void print(T a, int n, const string& deli = \" \", int br = 1) { for (int i = 0; i < n; ++i) { cout << a[i]; if (i + 1 != n) cout << deli; } while (br--) cout << endl; }\ntemplate <class T> void print(const T& c, const string& deli = \" \", int br = 1) { foreach (it, c) { cout << *it; if (++it != c.end()) cout << deli;--it; } while (br--) cout << endl; }\ntemplate <class T> void print2d(T a, int w, int h, int width = -1, int br = 1) { for (int i = 0; i < h; ++i) { for (int j = 0; j < w; ++j) {    if (width != -1) cout.width(width); cout << a[i][j] << ' '; } cout << endl; } while (br--) cout << endl; }\n   \ntemplate <class T> void input(T& a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\ntemplate <class T> void input(T* a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\n\nvoid fix_pre(int n) { cout.setf(ios::fixed, ios::floatfield); cout.precision(10); }\nvoid fast_io() { cin.tie(0); ios::sync_with_stdio(false); }\n#define trace(x) (cout << #x << \": \" << (x) << endl)\n \nbool in_rect(int x, int y, int w, int h) { return 0 <= x && x < w && 0 <= y && y < h; }\n \n\ntypedef long long ll;\ntypedef pair<int, int> pint;\n \n// y(v): v>^<  y(^): ^>v<\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\n\nconst double PI = acos(-1.0);\n\n#define F first\n#define S second\n\n\n\nclass WeightUnionFind\n{\nprivate:\n    vector<pint> e; // (parent, diff)\n\npublic:\n    \n    WeightUnionFind(int n)\n        : e(n, pint(-1, 0)) {}\n\n    void unite(int a, int b, int w)\n    {\n        if (!same(a, b))\n        {\n            pint ra = find(a);\n            pint rb = find(b);\n            e[ra.first] = pint(rb.first, rb.second - ra.second - w);\n        }\n    }\n\n    // (root, diff)\n    pint find(int a)\n    {\n        if (e[a].first == -1)\n            return pint(a, 0);\n        else\n        {\n            pint r = find(e[a].first);\n            return e[a] = pint(r.first, r.second + e[a].second);\n        }\n    }\n\n    bool same(int a, int b)\n    {\n        return find(a).first == find(b).first;\n    }\n};\nint main()\n{\n    int n, m;\n    while (scanf(\"%d%d\", &n, &m), n)\n    {\n        WeightUnionFind uf(n + 1);\n        while (m--)\n        {\n            char op;\n            int a, b;\n            scanf(\" %c%d%d\", &op, &a, &b);\n\n            if (op == '!')\n            {\n                int w;\n                scanf(\"%d\", &w);\n                uf.unite(a, b, w);\n            }\n            else\n            {\n                if (uf.same(a, b))\n                {\n                    pint ra = uf.find(a);\n                    pint rb = uf.find(b);\n                    printf(\"%d\\n\", rb.second - ra.second);\n                }\n                else\n                    puts(\"UNKNOWN\");\n            }\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#ifdef _WIN32\n#define scanfll(x) scanf(\"%I64d\", x)\n#define printfll(x) printf(\"%I64d\", x)\n#else\n#define scanfll(x) scanf(\"%lld\", x)\n#define printfll(x) printf(\"%lld\", x)\n#endif\n#define rep(i,n) for(long long i = 0; i < (long long)(n); i++)\n#define repi(i,a,b) for(long long i = (long long)(a); i < (long long)(b); i++)\n#define pb push_back\n#define all(x) (x).begin(), (x).end()\n#define fi first\n#define se second\n#define mt make_tuple\n#define mp make_pair\ntemplate<class T1, class T2> bool chmin(T1 &a, T2 b) { return b < a && (a = b, true); }\ntemplate<class T1, class T2> bool chmax(T1 &a, T2 b) { return a < b && (a = b, true); }\n\nusing ll = long long; using ld = long double; using vll = vector<ll>; using vvll = vector<vll>; using vld = vector<ld>; \nusing vi = vector<int>; using vvi = vector<vi>;\nvll conv(vi& v) { vll r(v.size()); rep(i, v.size()) r[i] = v[i]; return r; }\nusing P = pair<ll, ll>;\n\ntemplate <typename T, typename U> ostream &operator<<(ostream &o, const pair<T, U> &v) {  o << \"(\" << v.first << \", \" << v.second << \")\"; return o; }\ntemplate<size_t...> struct seq{}; template<size_t N, size_t... Is> struct gen_seq : gen_seq<N-1, N-1, Is...>{}; template<size_t... Is> struct gen_seq<0, Is...> : seq<Is...>{};\ntemplate<class Ch, class Tr, class Tuple, size_t... Is>\nvoid print_tuple(basic_ostream<Ch,Tr>& os, Tuple const& t, seq<Is...>){ using s = int[]; (void)s{0, (void(os << (Is == 0? \"\" : \", \") << get<Is>(t)), 0)...}; }\ntemplate<class Ch, class Tr, class... Args> \nauto operator<<(basic_ostream<Ch, Tr>& os, tuple<Args...> const& t) -> basic_ostream<Ch, Tr>& { os << \"(\"; print_tuple(os, t, gen_seq<sizeof...(Args)>()); return os << \")\"; }\nostream &operator<<(ostream &o, const vvll &v) { rep(i, v.size()) { rep(j, v[i].size()) o << v[i][j] << \" \"; cout << endl; } return o; }\ntemplate <typename T> ostream &operator<<(ostream &o, const vector<T> &v) { o << '['; rep(i, v.size()) o << v[i] << (i != v.size()-1 ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T>  ostream &operator<<(ostream &o, const set<T> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it << (next(it) != m.end() ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T, typename U>  ostream &operator<<(ostream &o, const map<T, U> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it << (next(it) != m.end() ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T, typename U>  ostream &operator<<(ostream &o, const unordered_map<T, U> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it; o << \"]\";  return o; }\nvoid printbits(ll mask, ll n) { rep(i, n) { cout << !!(mask & (1ll << i)); } cout << endl; }\n#define ldout fixed << setprecision(40) \n\nstatic const double EPS = 1e-14;\nstatic const long long INF = 1e18;\nstatic const long long mo = 1e9+7;\n\nstruct UnionFind {\n    // ?????????????????????????????????\n    // ????????????-1 * ????????¨????????????\n    vector<int> data;\n    \n    // ????????????????????????-???\n    // ?????????INF\n    vector<ll> w; \n\n    UnionFind(int size) : data(size, -1), w(size, 0) { }\n    // x, y????????????\n    bool unite(int x, int y, int k) {\n        ll wx = getWeight(x), wy = getWeight(y);\n        x = root(x); y = root(y);\n        if (x == y) \n            return 0;\n        if (data[y] < data[x]) {\n            swap(x, y);\n            swap(wx, wy);\n            k *= -1;\n        }\n        data[x] += data[y]; \n        data[y] = x;\n//        cout << k << \" \" << wx << \" \" << wy << endl;\n        w[y] = -k + wx - wy;\n        return true;\n    }\n    // x, y?????????????????????1\n    bool find(int x, int y) {\n        return root(x) == root(y);\n    }\n    // x???????????¢??????????????????????????????????????°???\n    int root(int x) {\n        return data[x] < 0 ? x : root(data[x]);\n//        return data[x] < 0 ? x : data[x] = root(data[x]);\n    }\n    ll getWeight(int x) {\n        return data[x] < 0 ? 0 : w[x] + getWeight(data[x]);\n    }\n    // x??????????????????????????§???????????????\n    int size(int x) {\n        return -data[root(x)];\n    }\n    // ?????¢??????????????????????????°?????????\n    int setNum(void) {\n        map<int, int> c;\n        rep(i, data.size()) {\n            c[root(i)]++;\n        }\n        return c.size();\n    }\n    // O(n)\n    // ???????????¨?????¨??¨???????´??????????\n    vector<vector<int>> getUnionList(void) {\n        map<int, vector<int>> c;\n        for (int i = 0; i < data.size(); i++) \n            c[root(i)].pb(i);\n        vector<vector<int>> v;\n        for (auto x : c) \n            v.push_back(x.second);\n        return v;\n    }\n    void print(void) {\n        auto c = getUnionList();\n        for (auto x : c) {\n            for (auto y : x) \n                cout << y << \" \";\n            cout << endl;\n        }\n    }\n};\n\nint main(void) {\n    cin.tie(0); ios::sync_with_stdio(false);\n\n    ll n, m; \n    while (cin >> n >> m && n && m) {\n        UnionFind uf(n);\n        rep(i, m) {\n            char c; cin >> c;\n            if (c == '!') {\n                ll x, y, w; cin >> x >> y >> w; x--; y--;\n                uf.unite(x, y, w);\n            } else {\n                ll x, y; cin >> x >> y; x--; y--;\n                if (!uf.find(x, y)) {\n                    cout << \"UNKNOWN\" << endl;\n                } else {\n                    cout << uf.getWeight(x) - uf.getWeight(y) << endl;\n                }\n            }\n            /*\n            cout << uf.data << endl;\n            cout << uf.w << endl;\n            */\n        }\n\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define MAX_N 100005\nusing namespace std;\ntypedef pair<int,int> P;\nP par[MAX_N];\n\nvoid init(int n){\n  for(int i=0;i<n;i++)\n    par[i]=P(i,0);\n}\n\nP find(int x){\n  if(par[x].first==x)return P(x,0);\n  P r=find(par[x].first);\n  return par[x]=P(r.first,par[x].second+r.second);\n}\n\nvoid unite(int x,int y,int cost){\n  P r1=find(x);\n  P r2=find(y);\n  if(r1.first==r2.first)return;\n  par[r1.first]=P(r2.first,r2.second-r1.second+cost);\n}\n\nbool same(int x,int y){return find(x).first==find(y).first;}\n\nint n,m,a,b,cost;\nchar c;\n\nint main(){\n  while(1){\n    cin>>n>>m;\n    if(!n&&!m)break;\n    init(n);\n    rep(i,m){\n      scanf(\"%c%d%d\",&c,&a,&b);\n      if(c=='!'){\n\tscanf(\"%d\",&cost);\n\tunite(b-1,a-1,cost);\n      }else{\n\tif(!same(a-1,b-1))printf(\"UNKNOWN\\n\");\n\telse printf(\"%d\\n\",find(b-1).second-find(a-1).second);\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <algorithm>\n#include <cstring>\n#define eps 1e-5\nusing namespace std;\n\nint node[100005],d[100005];\n\nint findroot(int x)\n{\n    if(node[x]!=x)\n    {\n        int root=findroot(node[x]);\n\n        d[x]+=d[node[x]];\n\n        return node[x]=root;\n    }\n\n    return x;\n}\n\nint main()\n{\n    int n,m,i,a,b,c,ra,rb;\n    char s[5];\n\n    while(~scanf(\"%d%d\",&n,&m) && n+m)\n    {\n        for(i=0;i<=n;i++) node[i]=i,d[i]=0;\n\n        while(m--)\n        {\n            scanf(\"%s\",s);\n\n            if(s[0]=='!')\n            {\n                scanf(\"%d%d%d\",&a,&b,&c);\n\n                ra=findroot(a);\n\n                d[ra]=c-d[a];\n\n                node[ra]=b;\n            }\n            else\n            {\n                scanf(\"%d%d\",&a,&b);\n\n                ra=findroot(a);\n                rb=findroot(b);\n\n                if(ra!=rb) puts(\"UNKNOWN\");\n                else printf(\"%d\\n\",d[a]-d[b]);\n            }\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<vector>\n#include<cassert>\nusing namespace std;\n\nclass DisjointSet{\n public:\n  vector<int> rank, p, w;\n\n  DisjointSet(){}\n  DisjointSet(int size){\n    rank.resize(size, 0);\n    p.resize(size, 0);\n    w.resize(size, 0);\n    for(int i=0; i<size; i++) makeSet(i);\n  }\n\n  void makeSet(int x){\n    p[x] = x;\n    rank[x] = 0;\n    w[x] = 0;\n  }\n\n  void unite(int x, int y){\n    link(findSet(x).first, findSet(y).first);\n  }\n\n  void uniteW(int x, int y, int v){\n    pair<int, int> px = findSet(x);\n    pair<int, int> py = findSet(y);\n    if ( px.first == py.first ) return;\n    x = px.first;\n    y = py.first;\n    if ( rank[x] < rank[y] ){\n      p[x] = y;\n      w[x] = (v - px.second + py.second);\n    } else {\n      p[y] = x;\n      w[y] = -(v - px.second + py.second);\n      if ( rank[x] == rank[y] ) rank[x]++;\n    }\n  }\n\n  bool same(int x, int y){\n    return findSet(x).first == findSet(y).first;\n  }\n int getDiff(int x, int y){\n    return findSet(x).second - findSet(y).second;\n  }\n\n  void link(int x, int y){\n    if(rank[x] > rank[y]){\n      p[y] = x;\n    }else{\n      p[x] = y;\n      if(rank[x] == rank[y]){\n        rank[y] = rank[y] + 1;\n      }\n    }\n  }\n\n  pair<int, int> findSet(int x){\n    if(x != p[x]){\n      pair<int,int> tmp =  findSet(p[x]);\n      p[x] = tmp.first;\n      w[x] += tmp.second;\n    }\n    return make_pair(p[x], w[x]);\n  }\n};\n\nint main(){\n  int N, M;\n  char com;\n  int  a, b, w;\n\n  while(1){\n    cin >> N >> M;\n    if ( N == 0 && M == 0 ) break;\n\n    DisjointSet ds = DisjointSet(N);\n\n    for ( int i = 0; i < M; i++ ){\n      cin >> com;\n      if ( com == '!' ){\n        cin >>  a >> b >> w; a--; b--;\n        ds.uniteW(a, b, w);\n      } else if ( com == '?' ){\n        cin >> a >> b; a--; b--;\n        if ( ds.same(a, b) ) {\n          cout << ds.getDiff(a, b) << endl;\n        } else {\n          cout << \"UNKNOWN\" << endl;\n        }\n      }\n    }\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\nlong long dist[1 << 18];\nlong long group[1 << 18]; char q;\nlong long n, Q, a, b, c;\nvector<long long>gr[1 << 18];\nint main() {\n\tfor (int t = 0; t < 5; t++) {\n\t\tfor (int i = 0; i < 1 << 18; i++) {\n\t\t\tdist[i] = 0; group[i] = i; gr[i].clear(); gr[i].push_back(i);\n\t\t}\n\t\tcin >> n >> Q; if (n == 0 && Q == 0)break;\n\t\tfor (int i = 0; i < Q; i++) {\n\t\t\tcin >> q;\n\t\t\tif (q == '?') {\n\t\t\t\tcin >> a >> b;\n\t\t\t\tif (group[a] != group[b])cout << \"UNKNOWN\" << endl;\n\t\t\t\telse cout << dist[b] - dist[a] << endl;\n\t\t\t}\n\t\t\tif (q == '!') {\n\t\t\t\tcin >> a >> b >> c;\n\t\t\t\tif (group[a] != group[b]) {\n\t\t\t\t\tint K = dist[a] + c - dist[b];\n\t\t\t\t\tint L = group[a], M = group[b];\n\t\t\t\t\tfor (int j = 0; j < gr[M].size(); j++) {\n\t\t\t\t\t\tgroup[gr[M][j]] = L;\n\t\t\t\t\t\tgr[L].push_back(gr[M][j]);\n\t\t\t\t\t\tdist[gr[M][j]] += K;\n\t\t\t\t\t}\n\t\t\t\t\tgr[M].clear();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cassert>// c\n#include <ctime>\n#include <iostream>// io\n#include <iomanip>\n#include <fstream>\n#include <sstream>\n#include <vector>// container\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <algorithm>// other\n#include <complex>\n#include <numeric>\n#include <functional>\n#include <random>\n#include <regex>\n\nusing namespace std;\ntypedef long long ll;\n\n#define ALL(c) (c).begin(),(c).end()\n#define FOR(i,l,r) for(int i=(int)l;i<(int)r;++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORr(i,l,r) for(int i=(int)r-1;i>=(int)l;--i)\n#define REPr(i,n) FORr(i,0,n)\n#define EACH(i,c) for(__typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define IN(l,v,r) ((l)<=(v) && (v)<(r))\n#define UNIQUE(v) v.erase(unique(ALL(v)),v.end())\n//debug\n#define DUMP(x)  cerr << #x << \" = \" << (x)\n#define LINE()    cerr<< \" (L\" << __LINE__ << \")\"\n\ntemplate<typename T,typename U> T pmod(T x,U M){return (x%M+M)%M;}\n\n//verified by AOJ0118 \nstruct UnionFind{\n    vector<int> par,rank,ss;int size;\n    vector<int> ws;\n    UnionFind(int n){\n        REP(i,n) par.push_back(i);\n        rank = vector<int>(n);ss=vector<int>(n,1);size=n;\n\n        ws=vector<int>(n);\n    }\n    int root(int x){\n        if(par[x] == x)return x;\n        int r = root(par[x]); ws[x] += ws[par[x]];\n        return par[x] = r;\n    }\n    int val(int x){\n    \troot(x);return ws[x];\n    }\n    bool same(int x,int y){\n        return root(x) == root(y);\n    }\n    void unite(int x,int y,int w=0){\n        int wx=ws[x],wy=ws[y];\n        x = root(x);y = root(y);\n        if(x==y)return;\n        if(rank[x] < rank[y]){//root y\n        \tws[x] = w+wy;\n            par[x] = y;ss[y]+=ss[x];\n        }else{//root x\n        \tws[y] = -w+wx;\n            par[y] = x;ss[x]+=ss[y];\n        }\n        if(rank[x] == rank[y]) rank[x]++;\n        size--;\n    }\n    int getS(int x){\n        return ss[root(x)];\n    }\n};\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tcerr << fixed <<setprecision(20);\n\tcout << fixed <<setprecision(20);\n  while (true) {\n  \tint N,M;cin >> N >> M;if(N==0)break;\n  \tUnionFind uf(N);\n  \tREP(i,M){\n  \t\tchar c;int a,b,w;cin >> c >> a >> b;a--;b--;\n\t\n\t\t// REP(i,N)cerr <<uf.par[i] <<\" \";cerr <<endl;\n  \t\t// REP(i,N)cerr <<uf.val(i) <<\" \";cerr <<endl;\n  \t\tif(c=='!'){\n  \t\t\tcin >> w;\n  \t\t\tuf.unite(a,b,w);\n  \t\t}else{\n  \t\t\tif(!uf.same(a,b)){\n  \t\t\t\tcout <<\"UNKNOWN\"<<endl;\n  \t\t\t}else{\n  \t\t\t\tcout << uf.val(a)-uf.val(b) <<endl;\n  \t\t\t}\n  \t\t}\n  \t\t// cerr <<\"aaa\"<<endl;\n  \t}\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,n) for(i = 0;i < n;++i)\n#define all(v) v.begin(), v.end()\nusing ll = long long;\n\nstruct UFweight\n{\n    int i;\n    vector<int> par;\n    vector<int> size;\n    vector<int> rank;\n    vector<ll> diff_weight;\n    UFweight(int n, ll sum_unity = 0){\n        par.resize(n);  rank.resize(n); size.resize(n); diff_weight.resize(n);\n        for(i = 0;i < n;++i){\n            par.at(i) = i;\n            rank.at(i) = 0;\n            size.at(i) = 1;\n            diff_weight.at(i) = sum_unity;\n        }\n    }\n    \n    int root(int x){\n        if(par.at(x) == x){\n            return x;\n        }else{\n            int r = root(par.at(x));\n            diff_weight.at(x) += diff_weight.at(par.at(x));\n            return par.at(x) = r;\n        }\n    }\n\n    ll weight(int x){\n        root(x);\n        return diff_weight.at(x);\n    }\n\n    ll get_diff(int x, int y){\n        return weight(y) - weight(x);\n    }\n    \n    // weight(y) - weight(x) = wとなるようにmerge\n    bool merge(int x, int y, ll w){\n        w += weight(x); w -= weight(y);\n        int rx = root(x);\n        int ry = root(y);\n        if(rx == ry){\n            ll weight_diff = get_diff(rx, ry);\n            if(weight_diff == w) return true;\n            else return false;\n        }\n\n        if(rank.at(rx) < rank.at(ry)){\n            swap(rx,ry);\n            w *= -1;\n        }\n        if(rank.at(rx) == rank.at(ry)) ++rank.at(rx);\n        par.at(ry) = rx;\n        diff_weight.at(ry) = w;\n        size.at(rx) += size.at(ry);\n\n        return true;\n    }\n    \n    bool same(int x, int y){\n        int rx = root(x);\n        int ry = root(y);\n        return rx == ry;\n    }\n    \n    int get_size(int x){\n        return size.at(root(x));\n    }\n};\n\nint main()\n{\n    ll i,j;\n    while(true){\n        ll n,m;\n        cin >> n >> m;\n        if(n == 0 && m == 0) break;\n        UFweight ufw(n);\n        for(i = 0;i < m;++i){\n            char c;\n            cin >> c;\n            if(c == '!'){\n                ll a,b,w;\n                cin >> a >> b >> w;\n                --a;    --b;\n                ufw.merge(a, b, w);\n            }else{\n                ll a,b;\n                cin >> a >> b;\n                --a;    --b;\n                if(ufw.same(a,b)){\n                    ll w = ufw.get_diff(a,b);\n                    cout << w << endl;\n                }else{\n                    cout << \"UNKNOWN\" << endl;\n                }\n            }\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <cassert>\n#include <memory>\n#include <time.h>\nusing namespace std;\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\nconst double EPS = 1e-9;\nconst double PI  = acos(-1.0);\n\nconst int MAX_N=100010;\nint par[MAX_N];\nint myrank[MAX_N];\n\nvoid init(int n){\n\tfor(int i=0;i<n;i++){\n\t\tpar[i]=i;\n\t\tmyrank[i]=0;\n\t}\n}\n\nint find(int x){\n\tif(par[x]==x){\n\t\treturn x;\n\t}else{\n\t\tmyrank[x]+=myrank[par[x]];\n\t\treturn par[x]=find(par[x]);\n\t}\n}\n\nvoid unite(int x,int y,int w){\n\tint px=find(x);\n\tint py=find(y);\n\tint w2=w-(myrank[y]-myrank[py])+(myrank[x]-myrank[px]);\n\tif(px==py)return;\n\tif(w2<0){\n\t\tw2=-w2;\n\t\tswap(px,py);\n\t}\n\n\tpar[py]=px;\n\tmyrank[py]=w2;\n}\n\nbool same(int x,int y){\n\treturn find(x)==find(y);\n}\n\nint main(){\n\tint n,m;\n\twhile(cin>>n>>m,n|m){\n\t\tinit(n+1);\n\t\tREP(i,m){\n\t\t\tchar q;\n\t\t\tint a,b,w;\n\t\t\tcin>>q>>a>>b;\n\t\t\tif(q=='!'){\n\t\t\t\tcin>>w;\n\t\t\t\tunite(a,b,w);\n\t\t\t}else{\n\t\t\t\tif(same(a,b)){\n\t\t\t\t\tcout<<myrank[b]-myrank[a]<<endl;\n\t\t\t\t}else{\n\t\t\t\t\tcout<<\"UNKNOWN\"<<endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long   // <-----!!!!!!!!!!!!!!!!!!!\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n)-1;i>=0;i--)\n#define rrep2(i,a,b) for (int i=(a)-1;i>=b;i--)\n#define chmin(a,b) (a)=min((a),(b));\n#define chmax(a,b) (a)=max((a),(b));\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n#define printV(v) cout<<(#v)<<\":\";for(auto(x):(v)){cout<<\" \"<<(x);}cout<<endl;\n#define printVS(vs) cout<<(#vs)<<\":\"<<endl;for(auto(s):(vs)){cout<<(s)<< endl;}\n#define printVV(vv) cout<<(#vv)<<\":\"<<endl;for(auto(v):(vv)){for(auto(x):(v)){cout<<\" \"<<(x);}cout<<endl;}\n#define printP(p) cout<<(#p)<<(p).first<<\" \"<<(p).second<<endl;\n#define printVP(vp) cout<<(#vp)<<\":\"<<endl;for(auto(p):(vp)){cout<<(p).first<<\" \"<<(p).second<<endl;}\n\ninline void output(){ cout << endl; }\ntemplate<typename First, typename... Rest>\ninline void output(const First& first, const Rest&... rest) {\n    cout << first << \" \"; output(rest...);\n}\n\nusing ll = long long;\nusing Pii = pair<int, int>;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vvvi = vector<vvi>;\nconst int inf = 2e9;\nconst int mod = 1e9 + 7;\n\nstruct edge {\n    int to, cost;\n    edge(){}\n    edge(int _to, int _cost) : to(_to), cost(_cost) {}\n};\nusing Graph = vector<vector<edge>>;\n\nclass LCA {\nprivate:\n    static const int MAX_LOG = 20;\n    const int n;\n    Graph G;\n    vector<vector<int>> par;\n    vector<int> depth;\n    vector<int> cost;\n\n    void dfs(int v, int p, int d, int c = 0) {\n        par[0][v] = p;\n        depth[v] = d;\n        cost[v] = c;\n        for (auto e : G[v]) {\n            if (e.to != p) {\n                dfs(e.to, v, d + 1, c + e.cost);\n            }\n        }\n    }\n\npublic:\n    LCA(int _n) : n(_n), G(_n), par(MAX_LOG, vector<int>(_n)), depth(_n), cost(_n) {}\n    void addEdge(int a, int b, int c) {\n        G[a].emplace_back(b, c);\n        G[b].emplace_back(a, -c);\n    }\n    void init() {\n        dfs(0, -1, 0);\n        rep(i, MAX_LOG - 1) {\n            rep(j, n) {\n                if (par[i][j] == -1) {\n                    par[i + 1][j] = -1;\n                } else {\n                    par[i + 1][j] = par[i][par[i][j]];\n                }\n            }\n        }\n    }\n    int lca(int a, int b) {\n        if (depth[a] > depth[b]) {\n            swap(a, b);\n        }\n        rep(i, MAX_LOG) {\n            if ((depth[b] - depth[a]) >> i & 1) {\n                b = par[i][b];\n            }\n        }\n        if (a == b) return a;\n\n        rrep(i, MAX_LOG) {\n            if (par[i][a] != par[i][b]) {\n                a = par[i][a];\n                b = par[i][b];\n            }\n        }\n        return par[0][a];\n    }\n    int query(int a, int b) {\n        int v = lca(a, b);\n        return - (cost[a] - cost[v]) + cost[b] - cost[v];\n    }\n};\n\nclass UnionFind {\nprivate:\n    const int n;\n    vector<int> uni;\npublic:\n    UnionFind(int _n) : n(_n), uni(_n, -1) {}\n    int root(int x) {\n        if (uni[x] < 0) return x;\n        return uni[x] = root(uni[x]);\n    }\n    bool same(int x, int y) {\n        return root(x) == root(y);\n    }\n    bool unite(int x, int y) {\n        x = root(x);\n        y = root(y);\n        if (x == y) return false;\n        if (uni[x] > uni[y]) swap(x, y);\n        uni[x] += uni[y];\n        uni[y] = x;\n        return true;\n    }\n    int getSize(int x) {\n        return -uni[root(x)];\n    }\n    void print() {\n        for (auto x : uni) cout << x << \" \";\n        cout << endl;\n    }\n};\n\nstruct Query {\n    char t;\n    int a, b;\n    Query(){}\n    Query(char t, int a, int b) : t(t), a(a), b(b) {}\n    void disp() {\n        output(t, a, b);\n    }\n};\n\nsigned main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n\n    int n, m;\n    while (cin >> n >> m, n) {\n        LCA lca(n);\n        vector<Query> queries;\n        {\n            UnionFind uf(n);\n            rep(i, m) {\n                char t;\n                int a, b;\n                cin >> t >> a >> b;\n                a--, b--;\n                queries.emplace_back(t, a, b);\n                if (t == '!') {\n                    int c;\n                    cin >> c;\n                    if (uf.unite(a, b)) {\n                        lca.addEdge(a, b, c);\n                    }\n                }\n            }\n        }\n\n        lca.init();\n\n        {\n            UnionFind uf(n);\n            for (const auto& q : queries) {\n                if (q.t == '!') {\n                    uf.unite(q.a, q.b);\n                }\n                else {\n                    if (uf.same(q.a, q.b)) {\n                        cout << lca.query(q.a, q.b) << endl;\n                    }\n                    else {\n                        cout << \"UNKNOWN\" << endl;\n                    }\n                }\n            }\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <memory.h>\n\nusing namespace std;\n\n//FILE *in = freopen(\"input.txt\", \"r\", stdin);\n//FILE *out = freopen(\"output.txt\", \"w\", stdout);\n\nint n, m;\n\nstruct UnionFind {\n\tvector<int> par; vector<int> rank;\n\tUnionFind(int n){\n\t\tpar = vector<int>(n);\n\t\trank = vector<int>(n);\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tpar[i] = i;\n\t\t}\n\t}\n\tint find(int x) {\n\t\tif(par[x]==x) return x;\n\t\telse return find(par[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif(x == y) return;\n\t\tif(rank[x]<rank[y])\n\t\t\tpar[x] = y;\n\t\telse {\n\t\t\tpar[y] = x;\n\t\t\tif(rank[x]==rank[y])rank[x]++;\n\t\t}\n\t}\n\tinline bool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n};\n\nint bfs(vector<vector<pair<int,int>>>& data, int a, int b) {\n\tbool chk[100001];\n\tmemset(chk, 0, sizeof(chk));\n\tqueue<pair<int,int>> que;\n\tque.push(make_pair(a, 0));\n\tchk[a] = true;\n\twhile(!que.empty()){\n\t\tint cur = que.front().first;\n\t\tint val = que.front().second;\n\t\tque.pop();\n\t\tif(cur == b)\n\t\t\treturn val;\n\n\t\tfor(int i = 0; i < data[cur].size(); i++) {\n\t\t\tif(chk[data[cur][i].first]) continue;\n\t\t\tif(data[cur][i].first == b) {\n\t\t\t\treturn val+data[cur][i].second;\n\t\t\t}\n\t\t\tchk[data[cur][i].first] = true;\n\t\t\tque.push(make_pair(data[cur][i].first, val + data[cur][i].second));\n\t\t}\n\t}\n\treturn -1;\n}\n\nvoid process() {\n\tUnionFind uf(n+1);\n\tvector<vector<pair<int,int>>> data(n+1);\n\tchar tt[10];\n\tint a, b, c;\n\tfor(int k = 0; k < m; k++) {\n\t\tscanf(\"%s%d%d\", tt, &a, &b);\n\t\tif(tt[0] == '!') {\n\t\t\tscanf(\"%d\", &c);\n\t\t\tif(uf.same(a,b)) continue;\n\t\t\tdata[a].push_back(make_pair(b, c));\n\t\t\tdata[b].push_back(make_pair(a, -c));\n\t\t\tuf.unite(a,b);\n\t\t}\n\t\telse {\n\t\t\tif(!uf.same(a, b)) {\n\t\t\t\tprintf(\"UNKNOWN\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tprintf(\"%d\\n\", bfs(data, a, b));\n\t\t}\n\t}\n}\n\nint main() {\n\twhile(true){\n\t\tscanf(\"%d%d\", &n, &m);\n\t\tif(n == 0)break;\n\t\tprocess();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<stdio.h>\n\nusing namespace std;\nint weight[100000];\n\nclass DisjointSet{\npublic:\n  vector<int> rank,p;\n\n  DisjointSet(){}\n  DisjointSet(int size){\n    rank.resize(size,0);\n    p.resize(size,0);\n    for(int i=0;i<size;i++){\n      makeSet(i);\n      weight[i]=0;\n    }\n  }\n\n  void makeSet(int x){\n    p[x]=x;\n    rank[x]=0;\n  }\n  bool same(int x,int y){\n    return findSet(x)==findSet(y);\n  }\n  void unite(int x,int y,int w){\n    weight[x]=w;\n    link(x,y);\n  }\n  void link(int x,int y){   \n    p[x]=y;\n    if(rank[x]>=rank[y]){  \n      rank[y]=rank[x]+1;\n    }\n  }\n  int findSet(int x){\n    if(x==p[x]){\n      return x;\n    }else{\n      return findSet(p[x]);\n    }\n  }\n  int depth(int x){\n    int ans=0;\n    ans+=weight[x];\n    while(x!=p[x]){\n      ans+=weight[p[x]];\n      x=p[x];\n    }\n    return ans;\n  }\n};\nint main(){\n  int n,m;\n  while(scanf(\"%d%d\",&n,&m)){\n    if(!n&&!m){\n      break;\n    }else{\n      char query[5];\n      DisjointSet ds=DisjointSet(n);\n      for(int i=0;i<m;i++){\n        scanf(\"%s\",query);\n        if(query[0]=='!'){\n          int a,b,w;\n          scanf(\"%d%d%d\",&a,&b,&w);\n          ds.unite(a,b,w);\n        }else{\n          int c,d;\n          scanf(\"%d%d\",&c,&d);\n          if(!ds.same(c,d)){\n            printf(\"UNKNOWN\\n\");\n          }else{\n            printf(\"%d\\n\",ds.depth(c)-ds.depth(d));\n          }\n        }\n      }\n    }\n  }\n  return 0;\n}\n      "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define mp(a,b) make_pair((a),(b))\n#define pb(a) push_back((a))\n#define all(x) (x).begin(),(x).end()\n#define uniq(x) sort(all(x)),(x).erase(unique(all(x)),end(x))\n#define fi first\n#define se second\n#define dbg(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\nvoid _dbg(string){cout<<endl;}\ntemplate<class H,class... T> void _dbg(string s,H h,T... t){int l=s.find(',');cout<<s.substr(0,l)<<\" = \"<<h<<\", \";_dbg(s.substr(l+1),t...);}\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\n#define INF 1120000000\n\ntemplate <class T>\nclass WeightedUnionFind {\n  int n;\n  vector<int> par,sz;\n  vector<T> w;\n  // weight[i] : iがpar[i]よりどれだけ重いか\npublic:\n  WeightedUnionFind(){}\n  WeightedUnionFind(int _n) : n(_n) {\n    par.resize(n, -1);\n    sz.resize(n, 1);\n    w.resize(n, 0);\n  }\n  int find(int i){\n    if(par[i] < 0){\n      return i;\n    } else {\n      int p = find(par[i]);\n      w[i] += w[p];\n      par[i] = p;\n      return p;\n    }\n  }\n  T weight(int x){\n    find(x);\n    return w[x];\n  }\n  bool same(int x, int y){\n    return find(x) == find(y);\n  }\n  // weight[i] +w の位置に j を配置\n  void unite(int i, int j, T nw){\n    int x = find(i), y = find(j);\n    if(x == y) return;\n    if(sz[x] < sz[y]){\n      swap(x, y);\n      nw = -nw;\n    }\n    par[y] = x;\n    w[y] = weight(i) - weight(j) + nw;\n  }\n  // x からみた y の相対位置\n  T diff(int x, int y){\n    return weight(y) - weight(x);\n  }\n};\n\nint main(){\n  int n,m;\n  while(cin>>n>>m, n|m){\n    WeightedUnionFind<long> uf(n);\n    rep(i,m){\n      char s[5];\n      int a,b;\n      cin>>s>>a>>b;\n      a--;b--;\n      if(s[0]=='?'){\n        if(uf.same(a,b)) cout << uf.diff(a,b) << endl;\n        else cout << \"UNKNOWN\" << endl;\n      } else {\n        long c;\n        cin>>c;\n        uf.unite(a, b, c);\n      }\n    }\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include<vector>\n#include<algorithm>\n#include<utility>\n\n#define mod 1000000007\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> P;\nvector<P> par;//???????????¨??????\nvector<int> ran;//??¨????????????\n\nP find(int a) {\n\tif (par[a].first == a)return P(a,0);\n\telse {\n\t\tint ap=find(par[a].first).first;\n\t\tint ad = find(par[a].first).second + par[a].second;\n\t\treturn par[a] = P(ap,ad);\n\t}\n}\nbool same(int a, int b) {\n\tif (find(a).first == find(b).first)return true;\n\telse return false;\n}\nint unite(int a, int b, int d) {\n\tint ra = find(a).first;\n\tint rb = find(b).first;\n\tif (ran[ra] < ran[rb]) {\n\t\tpar[ra] = P(rb, d + find(b).second - find(a).second);\n\t}\n\telse {\n\t\tpar[rb] = P(ra, -d - find(b).second + find(a).second);\n\t}\n\treturn 0;\n}\nint diff(int a, int b) {\n\treturn find(a).second - find(b).second;\n}\n\nint main() {\n\twhile (true) {\n\t\tint n, m;\n\t\tcin >> n >> m;//100,000\n\t\tif (n == 0 && m == 0)return 0;\n\t\tpar.resize(0); ran.resize(0);\n\t\tpar.resize(n);  ran.resize(n,1);\n\t\tfor (int i = 0; i < n; i++)par[i] = P(i,0);\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tchar L;\n\t\t\tcin >> L;\n\t\t\tif (L == '!') {\n\t\t\t\tint a, b, d;\n\t\t\t\tcin >> a >> b >> d;\n\t\t\t\ta--; b--;\n\t\t\t\tif (!same(a, b)) {\n\t\t\t\t\tunite(a, b, d);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {//????????¨??????outuput??????\n\t\t\t\tint a, b;\n\t\t\t\tcin >> a >> b;\n\t\t\t\ta--; b--;\n\t\t\t\tif (!same(a, b)) {\n\t\t\t\t\tcout << \"UNKNOWN\"<<endl;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tcout << diff(a, b)<<endl;\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\t\t\n\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n\n#define reps(i,f,n) for(int i=f;i<int(n);i++)\n#define rep(i,n) reps(i,0,n)\n\ntypedef pair<int,int> pii;\n\n#define x first\n#define y second\n\nclass UF{\npublic:\n  vector<pii> per;\n  void init(int n){\n    per = vector<pii>(n+1);\n    rep(i,per.size()){\n      per[i].x = i;\n      per[i].y=0;\n    }\n  }\n\n  int find(int a){\n    if(per[a].x == a)return a;\n\n    int ret = find(per[a].x);\n    per[a].y += per[per[a].x].y;\n    per[a].x = ret;\n    return ret;\n  }\n\n  void uni(int a, int b, int dist){\n    int s = find(a);\n    int t = find(b);\n\n    if(s==t)return;//assert(0);\n\n    int c = per[b].y - per[a].y;\n    per[t].x = s;\n    per[t].y = -(c+dist);\n  }\n\n  bool same(int a, int b){\n    return find(a)==find(b);\n  }\n\n  void print(){\n    reps(i,1,per.size())printf(\"(%d,%d) \",per[i].x,per[i].y);puts(\"\");\n  }\n\n};\n\n\nUF uf;\nint n,m;\n\nbool input(){\n  cin>>n>>m;\n  return n!=0;\n}\n\nvoid uni(int a, int b, int c){\n  uf.uni(a,b,c);\n}\n\nstring itostr(int n){\n  stringstream s;\n  s<<n;\n  return s.str();\n}\n\nstring compare(int a, int b){\n  if(!uf.same(a,b))return \"UNKNOWN\";\n  int ans = -(uf.per[b].y - uf.per[a].y);\n  return itostr(ans);\n}\n\nvoid solve(){\n  uf.init(n);\n\n  rep(i,m){\n    char ch;\n    int a,b,c;\n\n    cin>>ch;\n    if(ch=='!'){\n      cin>>a>>b>>c;\n      uni(a,b,c);\n    }else{\n      cin>>a>>b;\n      cout<<compare(a,b)<<endl;\n    }\n    //uf.print();\n  }\n}\n\n\nint main(){\n  while(input())solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=a;i<b;++i)\n#define for_rev(i,a,b) for(int i=a;i>=b;--i)\n#define allof(a) a.begin(),a.end()\n#define minit(a,b) memset(a,b,sizeof(a))\n#define size_of(a) (int)a.size()\n\ntypedef long long lint;\ntypedef pair<int, int> pii;\n\nconst int iINF = 1L << 30;\nconst lint lINF = 1LL << 60;\n\nint N, M;\n\nstruct UnionFind {\n\tvector<int> data;\n\tvector<int> dist;\n\tUnionFind(int _size) : data(_size, -1), dist(_size, iINF) {}\n\t\n\tbool unionSet(int x, int y, int d) {\n\t\tpii px = root(x), py = root(y);\n\t\tx = px.first; y = py.first;\n\n\t\tif (x != y) {\n\t\t\t//if (data[y] < data[x]) swap(x, y);\n\t\t\tdata[x] += data[y];\n\t\t\tdata[y] = x;\n\t\t\tdist[y] = d - py.second;\n\t\t}\n\t\t\n\t\treturn x != y;\n\t}\n\t\n\tpii root(int x) {\n\t\tif (data[x] < 0) {\n\t\t\tdist[x] = 0;\n\t\t\treturn pii(x, 0);\n\t\t}\n\t\t\n\t\tpii p = root(data[x]);\n\t\tdata[x] = p.first;\n\t\tdist[x] += p.second;\n\t\treturn pii(data[x], dist[x]);\n\t}\n\t\n\tint dist_of(int i) { return dist[i]; }\n};\n\nvoid solve() {\n\tUnionFind uf(N + 10);\n\t\n\tfor_(i,0,M) {\n\t\tchar c;\n\t\tint a, b, w;\n\t\tcin >> c;\n\t\t\n\t\tif (c == '!') {\n\t\t\tcin >> a >> b >> w;\n\t\t\tpii pa = uf.root(a), pb = uf.root(b);\n\t\t\tif (pa.first != pb.first) uf.unionSet(b, a, -w);\n\t\t} else {\n\t\t\tcin >> a >> b;\n\t\t\tpii pa = uf.root(a), pb = uf.root(b);\n\t\t\tif (pa.first == pb.first) {\n\t\t\t\tcout << ( uf.dist_of(b) - uf.dist_of(a) ) << endl;\n\t\t\t} else {\n\t\t\t\tcout << \"UNKNOWN\" << endl;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\twhile (cin >> N >> M, N) {\n\t\tsolve();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)n;++i)\n#define each(a, b) for(auto (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout <<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout <<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define svec(v) cout<<#v<<\":\";rep(i,v.size())cout<<\" \"<<v[i];cout<<endl\n#define sset(s) cout<<#s<<\":\";each(i,s)cout <<\" \"<<i;cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int>P;\n\nconst int MAX_N = 100005;\n\nint par[MAX_N];\nint nrank[MAX_N];\nll weight[MAX_N];\n\nvoid initial(int n){\t\t//?????????\n\tfor(int i=0;i<n;i++){\n\t\tpar[i] = i;\n\t\tnrank[i] = 0;\n        weight[i] = 0;\n\t}\n}\n\nint find(int x){\t\t//??¨??????????±???????\n\tif(par[x] == x){\n\t\treturn x;\n\t}else{\n\t\treturn par[x] = find(par[x]);\n\t}\n}\n\nll root_weight(int x)\n{\n    int root = find(x);\n    int res = weight[x];\n    while(x != root){\n        x = par[x];\n        res += weight[x];\n    }\n    return res;\n}\n\nvoid unite(int x,int y,int w){\n\tll wx = root_weight(x);\n\tll wy = root_weight(y);\n\tx = find(x);\n\ty = find(y);\n\tif(x == y) return;\n\tif(nrank[x] < nrank[y]){\n\t\tpar[x] = y;\n        weight[x] = -wx - w + wy;\n\t}else{\n\t\tpar[y] = x;\n        weight[y] = wx + w - wy;\n\t\tif(nrank[x] == nrank[y])\n\t\t\tnrank[x]++;\n\t}\n}\n\nbool same(int x,int y){\n\treturn find(x) == find(y);\n}\n\nint main()\n{\n    while(1){\n        int n,m;\n        cin >> n >> m;\n        if(n == 0){\n            break;\n        }\n        initial(n+1);\n        rep(i,m){\n            int a,b,w;\n            string s;\n            cin >> s ;\n            if(s == \"!\"){\n                cin >> a >> b >> w;\n                unite(a,b,w);\n            }else{\n                cin >> a >> b;\n                if(same(a,b)){\n                    ll wa = root_weight(a);\n                    ll wb = root_weight(b);\n                    cout << wb - wa << \"\\n\";\n                }else{\n                    cout << \"UNKNOWN\\n\";\n                }\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<bitset>\n#include<algorithm>\nusing namespace std;\n#define MAX_N 100\n\nclass uf_extention{\nprivate:\n\tint parents[MAX_N];\n\tint rank[MAX_N];\n\t//extention\n\tint dis[MAX_N][MAX_N];\npublic:\n\tuf_extention(){\n\t\tfor(int i=0;i<MAX_N;i++){\n\t\t\tparents[i]=i;\n\t\t\trank[i]=0;\n\t\t\t//extention\n\t\t\tfor(int j=0;j<MAX_N;j++){\n\t\t\t\tdis[i][j]=0;\n\t\t\t}\n\t\t}\n\t}\n\tuf_extention(int n){\n\t\tfor(int i=0;i<n;i++){\n\t\t\tparents[i]=i;\n\t\t\trank[i]=0;\n\t\t\t//extention\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tdis[i][j]=0;\n\t\t\t}\n\t\t\t\n\t\t}\n\t}\n\tint find(int x){\n\t\tif(parents[x]==x){\n\t\t\treturn x;\n\t\t}else{\n\t\t\t//extention\n\t\t\tint tmp=find(parents[x]);\n\t\t\t//cout<<\"find \"<<dis[x][parents[x]]<<\" \"<<dis[parents[x]][tmp]<<\" x=\"<<x<<\" p[x]=\"<<parents[x]<<\" tmp=\"<<tmp<<endl;\n\t\t\tdis[x][tmp]=dis[x][parents[x]]+dis[parents[x]][tmp];\n\t\t\tdis[tmp][x]=dis[x][tmp]*(-1);\n\t\t\treturn parents[x]=tmp;\n\t\t}\n\t}\n\tvoid unite(int x,int y,int distance){\n\t\t//cout<<\"unite\"<<x<<\" \"<<y<<\" dis=\"<<distance<<endl;\n\t\tdis[x][y]=distance;\n\t\tdis[y][x]=distance*(-1);\n\t\tint parx=find(x);\n\t\tint pary=find(y);\n\t\tif(parx==pary)return;\n\t\tdis[parx][pary]=dis[parx][x]+dis[x][y]+dis[y][pary];\n\t\tdis[pary][parx]=(-1)*dis[parx][pary];\n\t\tif(rank[parx]<rank[pary]){\n\t\t\t//cout<<parx<<\"'s parents is\"<<pary<<endl;\n\t\t\tparents[parx]=pary;\n\t\t}else{\n\t\t\t//cout<<pary<<\"'s parents is\"<<parx<<endl;\n\t\t\tparents[pary]=x;\n\t\t\tif(rank[parx]==rank[pary])rank[parx]++;\n\t\t}\n\t}\n\tint same(int x,int y){\n\t\t//cout<<\"same\"<<x<<\" \"<<y<<endl;\n\t\tint tmpx=find(x);\n\t\tint tmpy=find(y);\n\t\tif(tmpx==tmpy){\n\t\t\t//cout<<dis[x][tmpx]<<\" x=\"<<x<<\" tmpx=\"<<tmpx<<\" \"<<dis[tmpx][y]<<\" tmpy=\"<<tmpy<<\" y=\"<<y<<endl;\n\t\t\treturn dis[x][tmpx]+dis[tmpx][y];\n\t\t}else{\n\t\t\treturn -2000000;\n\t\t}\n\t}\n};\n\n\nint main(){\n\tchar c;\n\tint a,b,w;\n\tint n,m;\n\twhile(cin>>n>>m,n!=0||m!=0){\n\t\tuf_extention uf(n+1);\n\t\tfor(int i=0;i<m;i++){\n\t\t\tcin>>c;\n\t\t\tif(c=='!'){\n\t\t\t\tcin>>a>>b>>w;\n\t\t\t\tuf.unite(a,b,w);\n\t\t\t}else if(c=='?'){\n\t\t\t\tcin>>a>>b;\n\t\t\t\tint tmp=uf.same(a,b);\n\t\t\t\tif(tmp==-2000000){\n\t\t\t\t\tcout<<\"UNKNOWN\"<<endl;\n\t\t\t\t}else{\n\t\t\t\t\tcout<<tmp<<endl;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tcout<<\"???\"<<endl;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\n#define MAX (100000)\nstruct uni{\n  P d[100001];\n  void init(){\n    fill(d,d+MAX,P(-1,0));\n  }\n  int find(int a){\n    if( d[a].first<0 ) return a;\n    else {\n      int b = find(d[a].first);\n      int w1 = d[a].second;\n      int w2 = d[d[a].first].second;\n      d[a] = P(b,w1+w2);\n      return b;\n    }\n  }\n  void marge(int x,int y,int k){\n    x = find(x);\n    int bk = get(y);\n    d[x].second = k + bk;\n    d[x].first = y;\n  }\n  bool same(int a,int b){\n    if( find(a)==find(b) ) return true;\n    return false;\n  }\n  int get(int x){\n    find(x);\n    return d[x].second;\n  }\n  int size(int x){\n    x = find(x);\n    return d[x].first;\n  }\n};\n\nint N,M;\nuni U;\nint main(){\n  while(cin >> N >> M && (N||M) ){\n    char c;\n    int a,b,k;\n    U.init();\n    for(int i=0;i<M;i++){\n      cin >> c;\n      if( c == '!' ){\n\tcin  >> a >> b  >> k;\n\ta--;b--;\n\tif( !U.same( a, b ) ) \n\t  U.marge(a,b,k);\n\n\t//\tcout << \"marge \" << a << \" \" << b << \" \" << k << endl;\n\t//cout << U.get(a) << \" \" << U.size(a) << \"   \"  << U.get(b)<< \" \" << U.size(b) << endl;\n      } else {\n\tcin >> a >> b;\n\ta--;b--;\n\tif( U.same( a,b ) ) {\n\t  cout << U.get(a) - U.get(b) << endl;\n\t} else \n\t  cout << \"UNKNOWN\" << endl;\n      }\n    }  \n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <map>\n#define MAX_N 100005\nusing namespace std;\n\n\nclass Union_Find {\n  int par[MAX_N];  // 親\n  int rank[MAX_N]; // 木の深さ\n  int w[MAX_N];\npublic:\n  // n要素で初期化\n  void init(int n) {\n    for(int i = 0; i < n; ++i) {\n      par[i] = i;\n      rank[i] = 0;\n      w[i] = 0;\n    }\n  }\n  \n  // 木の根を求める\n  pair<int,int> find(int x) {\n    if(par[x] == x) {\n      return make_pair(x, 0);\n    } else  {\n      pair<int,int> p = find(par[x]);\n      par[x] = p.first;\n      p.second += w[x];\n      w[x] = p.second;\n      return p;\n    }\n  }\n  \n  // xとyの属する集合を併合\n  void unite(int x, int y, int dw) { // dw = wy - wx\n    pair<int,int> px = find(x);\n    pair<int,int> py = find(y);\n    x = px.first;\n    y = py.first;\n    int wx = px.second;\n    int wy = py.second;\n    dw = dw - wx + wy;\n    if(x == y) return;\n    \n    if(rank[x] < rank[y]) {\n      par[x] = y;\n      w[x] = dw;\n    } else {\n      par[y] = x;\n      w[y] = -dw;\n      if(rank[x] == rank[y]) ++rank[x];\n    }\n  }\n  \n  // xとyが同じ集合に属するか否か\n  bool same(int x, int y) {\n    return find(x).first == find(y).first;\n  }\n};\n\nint main() {\n  int N, M;\n  while(cin >> N >> M && (N|M)) {\n    Union_Find uf;\n    uf.init(N);  \n    while(M--) {\n      char c;\n      int a, b, w;\n      cin >> c;\n      if(c == '!') {\n        cin >> a >> b >> w;\n        --a; --b;\n        uf.unite(a, b, w);\n      } else {\n        cin >> a >> b;\n        --a; --b;\n        if(uf.same(a, b)) {\n          cout << uf.find(a).second - uf.find(b).second << endl;\n        } else {\n          cout << \"UNKNOWN\" << endl;\n        }\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<sstream>\n#include<map>\nusing namespace std;\n \n#define N 100000\n#define fs first\n#define sc second\ntypedef pair<int,int> P;\n\nP par[N];\nint rank[N];\n \nvoid init(int n){\n  for(int i=0;i<n;i++)par[i] = P(i,0);\n}\n \nP find(int a){\n  if(par[a].fs == a)return par[a];\n  P tmp = find(par[a].fs);\n  return par[a] = P(tmp.fs,tmp.sc + par[a].sc);\n}\n \nbool same(int a,int b){\n  return (find(a).fs == find(b).fs);\n}\n \nint dis(int a, int b){\n  if(!same(a,b))return 100000000;\n  return par[b].sc - par[a].sc;\n}\n\nbool unite(int a,int b,int cost){\n  P x = find(a);\n  P y = find(b);\n   \n  \n  if(same(x.fs,y.fs)){\n    if(dis(a,b) != cost)return false;\n  }else{\n    if(rank[x.fs]<rank[y.fs]){\n      par[x.fs] = P(y.fs,y.sc-x.sc-cost);\n    }else{\n      par[y.fs] = P(x.fs,x.sc-y.sc+cost);\n      if(rank[x.fs] == rank[y.fs])rank[x.fs]++;\n    }\n  }\n  return true;\n}\n\nint main(){\n  char c;\n  int a,b,w,n,m;\n\n  while(cin >> n >> m,n||m){\n    init(n);\n    for(int i=0;i<m;i++){\n      cin >> c;\n      if(c=='?'){\n\tcin >> a >> b;\n\ta--; b--;\n\tif(same(a,b))cout << par[b].sc - par[a].sc << endl;\n\telse cout << \"UNKNOWN\\n\";\n      }else{\n\tcin >> a >> b >> w;\n\ta--; b--;\n\tunite(a,b,w);\n      }\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\nconst int INF = 1000000000;\n#define REP(i,s,n) for(int i=(int)(s);i<(int)(n);i++)\n#define rep(i,n) REP(i, 0, n)\nstruct UnionFind {\n    vector<int> data;\n    vector<ll> rootd;//rootd[i] : dist from node[i] to node[root(i)]\n    UnionFind(int N) : data(N, -1), rootd(N, 0) {}\n    void unite(int x_, int y_, ll weight) {\n        int x = root(x_), y = root(y_);\n        if(x != y){\n            data[x] += data[y];\n            data[y] = x;\n            if(y == y_) rootd[y] = weight + rootd[x_];\n            else rootd[y] = weight - rootd[y_];\n        }\n    }\n    int root(int x_) {\n        int x = x_;\n        vector<int> memo;\n        while(data[x] >= 0) {\n            memo.push_back(x);\n            x = data[x];\n        }\n        int res = x;\n        for(int k : memo) {\n            rootd[k] += rootd[data[k]];\n            data[k] = res;\n        }\n        return res;\n    }\n    ll dist(int a, int b) { return rootd[b] - rootd[a];}\n    bool same(int a, int b) { return root(a) == root(b);}\n};\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int N, M;\n    while(cin >> N >> M && N) {\n        UnionFind uf(N);\n        char q; int a, b; ll w;\n        rep(i, M) {\n            cin >> q >> a >> b;\n            --a; --b;\n            if(q == '?') {\n                if(uf.same(a, b)) cout << uf.dist(a, b) << '\\n';\n                else cout << \"UNKNOWN\" << '\\n';\n            }else {\n                cin >> w;\n                uf.unite(a, b, w);\n            }\n        }\n        \n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint parent[1<<17],rank[1<<17],weight[1<<17];\nint root(int x)\n{\n\tif(parent[x]==x)return x;\n\telse\n\t{\n\t\tint r=root(parent[x]);\n\t\tweight[x]+=weight[parent[x]];\n\t\treturn parent[x]=r;\n\t}\n}\nint get_weight(int x)\n{\n\troot(x);\n\treturn weight[x];\n}\nbool issame(int x,int y)\n{\n\treturn root(x)==root(y);\n}\nvoid diff(int x,int y)\n{\n\tif(!issame(x,y))\n\t{\n\t\tcout<<\"UNKNOWN\"<<endl;\n\t}\n\telse cout<<get_weight(y)-get_weight(x)<<endl;\n}\nvoid merge(int x,int y,int w)\n{\n\tw+=get_weight(x)-get_weight(y);\n\tx=root(x);y=root(y);\n\tif(rank[x]<rank[y])swap(x,y),w*=-1;\n\tif(rank[x]==rank[y])rank[x]++;\n\tparent[y]=x;\n\tweight[y]=w;\n}\nmain()\n{\n\tint n,m;\n\twhile(cin>>n>>m,n)\n\t{\n\t\tfor(int i=0;i++<n;)parent[i]=i,rank[i]=0,weight[i]=0;\n\t\tfor(int i=0;i<m;i++)\n\t\t{\n\t\t\tchar c;cin>>c;\n\t\t\tif(c=='!')\n\t\t\t{\n\t\t\t\tint a,b,w;cin>>a>>b>>w;\n\t\t\t\tmerge(a,b,w);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tint a,b;cin>>a>>b;\n\t\t\t\tdiff(a,b);\n\t\t\t}\n\t\t}\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<map>\nusing namespace std;\n\nclass UF {\n    public:\n    vector<pair<int,int> > l;\n    UF(int n) {\n        for(int i=0; i<n; i++)\n            l.push_back(pair<int,int>(i,0));\n    }\n    pair<int,int> root(int x) {\n        if(x == l[x].first) return l[x];\n        pair<int,int> t = root(l[x].first);\n        l[x].first = t.first ;\n        l[x].second+= t.second;\n        return l[x];\n    }\n    void unite(int x, int y, int xMy) {\n        x = root(x).first;\n        pair<int,int> t = root(y);\n        y = t.first;\n        if(x == y) return;\n        l[y].first = l[x].first;\n        l[y].second= -xMy - t.second;\n    }\n    int weight(int x, int y) { // x - y else 123456\n        pair<int,int> s,t;\n        s = root(x);\n        t = root(y);\n        if(s.first != t.first) return 123456;\n        return s.second - t.second;\n    }\n};\n\n\nint main(void) {\n    while(1) {\n        int n,m;\n        scanf(\"%d%d\",&n,&m);\n        if(!n) break;\n        UF uf(n);\n        for(int i=0; i<m; i++) {\n            int a,b;\n            char s[3];\n            scanf(\"%s%d%d\",s,&a,&b);\n            a--, b--;\n            if(s[0] == '?') {\n                int w = uf.weight(b,a);\n                if(w == 123456)\n                    printf(\"UNKNOWN\\n\");\n                else\n                    printf(\"%d\\n\", w);\n            }\n            else {\n                int w;\n                scanf(\"%d\",&w);\n                uf.unite(b, a, w);\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cassert>\n#include <typeinfo>\n#include <vector>\n#include <stack>\n#include <cmath>\n#include <set>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n#include <queue>\n#include <iomanip>\n#include <cctype>\n#include <random>\n#include <complex>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<string> vs;\ntypedef vector<bool> vb;\ntypedef vector<vb> vvb;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<P,int> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<29;\nconst ll INF=1ll<<50;\nconst double pi=acos(-1);\nconst double eps=1e-8;\nconst ll mod=1e9+7;\nconst int dx[4]={0,1,0,-1},dy[4]={1,0,-1,0};\n\nclass Union_Find_Tree{\n\tpublic:\n\tvi Par,Rank,Size;\n\tUnion_Find_Tree(int n){\n\t\tPar=Rank=vi(n);\n\t\tSize=vi(n,1);\n\t\tfor(int i=0;i<n;i++) Par[i]=i;\n\t}\n\tint Find_Par(int x){\n\t\tif(Par[x]==x) return x;\n\t\treturn Par[x]=Find_Par(Par[x]);\n\t}\n\tint Find_Size(int x){\n\t\treturn Size[Find_Par(x)];\n\t}\n\tbool Unite(int x,int y){\n\t\tx=Find_Par(x);\n\t\ty=Find_Par(y);\n\t\tif(x==y) return 0;\n\t\tif(Rank[x]<Rank[y]){\n\t\t\tPar[x]=y;\n\t\t\tSize[y]+=Size[x];\n\t\t}\n\t\telse{\n\t\t\tPar[y]=x;\n\t\t\tSize[x]+=Size[y];\n\t\t\tif(Rank[x]==Rank[y]) Rank[x]++;\n\t\t}\n\t\treturn 1;\n\t}\n\tbool Same(int x,int y){\n\t\treturn Find_Par(x)==Find_Par(y);\n\t}\n};\n\nint n,m;\nvvp g;\nvl p;\n\nvoid dfs(int v,int c){\n\tp[v]=c;\n\tfor(int i=0;i<g[v].size();i++){\n\t\tint u=g[v][i].first;\n\t\tif(p[u]==INF) dfs(u,c+g[v][i].second);\n\t}\n}\n\nint main(){\n\twhile(1){\n\t\tcin>>n>>m;\n\t\tif(!n) break;\n\t\tg=vvp(n);\n\t\tp=vl(n,INF);\n\t\tvi t(m);\n\t\tvp a(m);\n\t\tUnion_Find_Tree uft(n);\n\t\tfor(int i=0;i<m;i++){\n\t\t\tchar c;\n\t\t\tcin>>c;\n\t\t\tif(c=='!'){\n\t\t\t\tint v,u,c;\n\t\t\t\tcin>>v>>u>>c;\n\t\t\t\tv--;u--;\n\t\t\t\tg[v].push_back({u,c});\n\t\t\t\tg[u].push_back({v,-c});\n\t\t\t\ta[i]={v,u};\n\t\t\t}\n\t\t\telse{\n\t\t\t\tt[i]=1;\n\t\t\t\tint v,u;\n\t\t\t\tcin>>v>>u;\n\t\t\t\ta[i]={v-1,u-1};\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<n;i++) if(p[i]==INF) dfs(i,0);\n\t\tfor(int i=0;i<m;i++){\n\t\t\tif(!t[i]) uft.Unite(a[i].first,a[i].second);\n\t\t\telse{\n\t\t\t\tint v=a[i].first,u=a[i].second;\n\t\t\t\tif(!uft.Same(u,v)) cout<<\"UNKNOWN\"<<endl;\n\t\t\t\telse{\n\t\t\t\t\tcout<<p[u]-p[v]<<endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cassert>\n#include <functional>\n#include <iostream>\n#include <iomanip>\n#include <iterator>\n#include <map>\n#include <queue>\n#include <utility>\n#include <vector>\n\nusing namespace std;\n\ntypedef long long Long;\n#define whole(xs) xs.begin(), xs.end()\n\n/* 重みつきUnionFind木 */\nstruct UnionFindW {\n    vector<int> parent;\n    vector<int> value;\n    static const int INF = 1<<28;\n    UnionFindW(int N) {\n        parent.clear(); parent.resize(N + 1, -1);\n        value.clear(); value.resize(N + 1, 0);\n    }\n    /* \n     * root :: インデックス -> (ルートのインデックス, ルートとの距離)\n     */\n    pair<int, int> root(int x) {\n        if (parent[x] == -1) return make_pair(x, 0);\n        int p = parent[x];\n        int v = value[x];\n        pair<int, int> proot = root(p);\n        parent[x] = proot.first;\n        value[x] = v + proot.second;\n        return make_pair(parent[x], value[x]);\n    }\n    /* \n     * query :: (インデックスx, インデックスy) -> yとxの差\n     */\n    int query(int x, int y) {\n        pair<int, int> xroot = root(x),\n                       yroot = root(y);\n        if (xroot.first != yroot.first) return INF;\n        return yroot.second - xroot.second;\n    }\n    /*\n     * merge :: (インデックスx, インデックスy, yとxの差w) -> ()\n     *\n     * xとyがすでに親子関係を持っていて,その差がwでなければ異常終了\n     */\n    void merge(int x, int y, int w) {\n        pair<int, int> xroot = root(x),\n                       yroot = root(y);\n        if (xroot.first == yroot.first) {\n            assert(query(x, y) == w);\n            return;\n        }\n        int px = xroot.first, py = yroot.first;\n        int dx = xroot.second, dy = yroot.second;\n        /* value[y] - value[x] = w\n         * value[x] - value[px] = dx\n         * value[y] - value[py] = dy\n         * value[py] - value[px] = (value[y] - dy) - (value[x] - dx)\n         *                       = (value[y] - value[x]) - (dy - dx)\n         *                       = w - dy + dx\n         */\n        parent[py] = px;\n        value[py] = w - dy + dx;\n    }\n};\n\nint main() {\n    int N, M;\n    while (cin >> N >> M, N || M) {\n        UnionFindW uf(N);\n        char c; int a, b, w;\n        for (int i = 0; i < M; i++) {\n            cin >> c;\n            if (c == '?') {\n                cin >> a >> b;\n                int ans = uf.query(a, b);\n                if (ans == UnionFindW::INF) {\n                    cout << \"UNKNOWN\" << endl;\n                } else {\n                    cout << ans << endl;\n                }\n            } else {\n                assert(c == '!');\n                cin >> a >> b >> w;\n                uf.merge(a, b, w);\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,n) for(int i=0; i<n; i++)\n\nint par[100001];\nint we[100001];\nint rnk[100001];\n\nint find(int x) {\n\tif(par[x] == x) return x;\n\tint res = find(par[x]);\n\tpar[x] = res;\n\twe[x] += we[res];\n\treturn res;\n}\n\nvoid uni(int x, int y, int w) {\n\tint a = find(x);\n\tint b = find(y);\n\tif(a == b) return;\n\tif(rnk[a] > rnk[b]) {\n\t\tpar[b] = a;\n\t\twe[y] = w - we[y] + we[x];\n\t} else {\n\t\tpar[a] = b;\n\t\twe[x] = -(w - we[y] + we[x]);\n\t\tif(rnk[a] == rnk[b]) rnk[b]++;\n\t}\n}\n\n\nint main() {\n\tint n, m;\n\twhile(cin >> n >> m, n and m) {\n\t\trep(i,n+1) {par[i] = i; we[i] = 0; rnk[i]=1;}\n\t\trep(i, m) {\n\t\t\tchar c;\n\t\t\tint x, y;\n\t\t\tcin >> c >> x >> y;\n\t\t\tif(c == '!') {\n\t\t\t\tint w;\n\t\t\t\tcin >> w;\n\t\t\t\tuni(x, y, w);\n\t\t\t} else {\n\t\t\t\tint a = find(x), b = find(y);\n\t\t\t\tif(a != b) cout << \"UNKNOWN\" << endl;\n\t\t\t\telse cout << we[y] - we[x] << endl;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define all(v) (v).begin(),(v).end()\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\n#define pb push_back\n#define fi first\n#define se second\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nstruct UF{\n    vint par,sz;\n    vector<set<int>>st;\n    vint dif;\n    void init(int n){\n        par=sz=dif=vint(n);\n        st=vector<set<int>>(n);\n        rep(i,n){\n            par[i]=i;\n            sz[i]=1;\n            dif[i]=0;\n            st[i].insert(i);\n        }\n    }\n    int find(int x){\n        return x==par[x]?x:par[x]=find(par[x]);\n    }\n    void update(int a,int b,int w){\n        int x=find(a),y=find(b);\n        if(x==y)return;\n        if(sz[x]>sz[y]){\n            swap(x,y);\n            swap(a,b);\n            w*=-1;\n        }\n        \n        int d=dif[b]-dif[a];\n        each(it,st[x]){\n            int v=*it;\n            dif[v]+=d-w;\n            st[y].insert(v);\n        }\n        sz[y]+=sz[x];\n        par[x]=y;\n    }\n    int query(int a,int b){\n        int x=find(a),y=find(b);\n        if(x!=y)return 1001001001;\n        return dif[b]-dif[a];\n    }\n};\n\nsigned main(){\n\n    int N,Q;\n    while(scanf(\"%lld%lld\",&N,&Q),N||Q){\n        UF uf;uf.init(N);\n        rep(i,Q){\n            char c;\n            scanf(\" %c\",&c);\n            if(c=='!'){\n                int a,b,w;\n                scanf(\"%lld%lld%lld\",&a,&b,&w);\n                a--;b--;\n                uf.update(a,b,w);\n            }\n            else{\n                int a,b;\n                scanf(\"%lld%lld\",&a,&b);\n                a--;b--;\n                int tmp=uf.query(a,b);\n                if(tmp==1001001001)puts(\"UNKNOWN\");\n                else printf(\"%lld\\n\",tmp);\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define f first\n#define s second\n#define mp make_pair\n#define inf 1<<30\n#define MAX 100001\nusing namespace std;\n\nint p[MAX],w[MAX];\nmap<pair<int,int>,int> M;\n\npair<int,int> find(int a){\n  pair<int,int> pii;\n  if(p[a]==a){\n    pii.f=a;pii.s=0;\n    return pii;\n  }\n  pii=find(p[a]);\n  pii.s+=w[a];\n  return pii;\n}\n\nint main()\n{\n  int n,q,a,b,d;\n  char c;\n\n  while(1){\n    cin>>n>>q;\n    if(n+q==0)break;\n    for(int i=0;i<n;i++){\n      p[i]=i;\n      w[i]=0;\n    }\n    M.clear();\n\n    for(int i=0;i<q;i++){\n      cin>>c;\n      if(c=='!'){\n\tcin>>a>>b>>d;\n\ta--;b--;\n\tp[a]=b;\n\tw[a]=d;\n      }\n      else {\n\tcin>>a>>b;\n\ta--;b--;\n\tpair<int,int> pa=find(a),pb=find(b);\n\tif(pa.f!=pb.f)cout<<\"UNKNOWM\"<<endl;\n\telse {\n\t  p[a]=pa.f;\n\t  w[a]=pa.s;\n\t  p[b]=pb.f;\n\t  w[b]=pb.s;\n\t  cout<<pa.s-pb.s<<endl;\n\t}\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define mp(a,b) make_pair((a),(b))\n#define pb(a) push_back((a))\n#define all(x) (x).begin(),(x).end()\n#define uniq(x) sort(all(x)),(x).erase(unique(all(x)),end(x))\n#define fi first\n#define se second\n#define dbg(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\nvoid _dbg(string){cout<<endl;}\ntemplate<class H,class... T> void _dbg(string s,H h,T... t){int l=s.find(',');cout<<s.substr(0,l)<<\" = \"<<h<<\", \";_dbg(s.substr(l+1),t...);}\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\n#define INF 1120000000\n\nint main(){\n  int n,m;\n  while(cin>>n>>m, n|m){\n    vector<int> par(n,-1);\n    vector<int> sz(n,1);\n    vector<long> weight(n,0); // weight[i] : par[i]?????????i??????????????????????\n\n    // <parent-id, weight>\n    function<pair<int,long>(int)> find = [&](int i){\n      if(par[i]<0) return mp(i, 0L);\n      else {\n        auto p = find(par[i]);\n        weight[i] += p.se;\n        par[i] = p.fi;\n        return mp(p.fi, weight[i]);\n      }\n    };\n\n    // j is heavier than i by w.\n    auto unite = [&](int i, int j, long w){\n      auto pi = find(i), pj = find(j);\n      int x = pi.fi, y = pj.fi;\n      if(x == y) return;\n      if(sz[x] >= sz[y]) {\n        par[y] = x;\n        weight[y] = pi.se + w - pj.se;\n        sz[x] += sz[y];\n      }\n      else {\n        par[x] = y;\n        weight[x] = pj.se - w - pi.se;\n        sz[y] += sz[x];\n      }\n    };\n\n    rep(i,m){\n      char s[5];\n      int a,b;\n      cin>>s>>a>>b;\n      a--;b--;\n      if(s[0]=='?'){\n        auto pa = find(a), pb = find(b);\n        if(pa.fi == pb.fi) cout << pb.se - pa.se << endl;\n        else cout << \"UNKNOWN\" << endl;\n      } else {\n        long c;\n        cin>>c;\n        unite(a,b,c);\n      }\n    }\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconstexpr int INF = 1e9;\n\nclass union_find {\npublic:\n    union_find(int N)\n        : par(N, -1), rank(N), w(N)\n    {}\n\n    pair<int, int> root(int x) {\n        if(par[x] < 0) {\n            return make_pair(x, 0);\n        }\n        pair<int, int> p = root(par[x]);\n        w[x] += p.second;\n        p.second = w[x];\n        par[x] = p.first;\n        return p;\n    }\n\n    void unite(int x, int y, int v) {\n        int rx = root(x).first, ry = root(y).first;\n        if(rx == ry) {\n            return;\n        }\n        if(rank[rx] > rank[ry]) {\n            par[ry] = rx;\n            w[ry] = v - w[y] + w[x];\n        } else {\n            par[rx] = ry;\n            w[rx] = -v + w[y] - w[x];\n            if(rank[rx] == rank[ry]) {\n                rank[ry]++;\n            }\n        }\n    }\n\n    int calc(int x, int y) {\n        if(root(x).first != root(y).first) {\n            return INF;\n        }\n        return w[y] - w[x];\n    }\n        \nprivate:\n    vector<int> par;\n    vector<int> rank;\n    vector<int> w;\n};\n\nint main() {\n    int N, M;\n    while(cin >> N >> M, N) {\n        union_find uf(N);\n        for(int i=0; i<M; ++i) {\n            char op; cin >> op;\n            if(op == '!') {\n                int a, b, v;\n                cin >> a >> b >> v;\n                a--; b--;\n                uf.unite(a, b, v);\n            } else {\n                int a, b;\n                cin >> a >> b;\n                a--; b--;\n                if(uf.calc(a, b) == INF) {\n                    cout << \"UNKNOWN\" << endl;\n                } else {\n                    cout << uf.calc(a, b) << endl;\n                }\n            }\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint uf[100100];\nint weight[100100];\n\nint root(int x){\n\tif( uf[x] < 0 ){\n\t\twhile( weight[x] != 0 );\n\t\treturn x;\n\t}else{\n\t\tweight[x] += weight[uf[x]];\n\t\treturn uf[x]=root(uf[x]);\n\t}\n}\n\n// x-y=w (x,y,w)\nint unite(int x,int y,int w){\n\tint x2 = root(x);\n\tint y2 = root(y);\n\tw = weight[x] + w - weight[y]; \n\tif( x2 != y2 ){\n\t\tuf[x2] += uf[y2];\n\t\tuf[y2] = x2;\n\t\tweight[y2] = w;\n\t\treturn true;\n\t}\n\treturn false;\n}\nint wei(int x){\n\troot(x);\n\treturn weight[x];\n}\n\nint main(){\n\tint N,M;\n\twhile(cin >> N >> M && N){\n\t\tfor(int i = 0 ; i < N ; i++ ) uf[i] = -1, weight[i] = 0;\n\t\tfor(int i = 0 ; i < M ; i++){\n\t\t\tchar c;\n\t\t\tcin >> c;\n\t\t\tint a,b;\n\t\t\tcin >> a >> b;\n\t\t\t--a,--b;\n\t\t\tif( c == '!' ){\n\t\t\t\tint w;\n\t\t\t\tcin >> w;\n\t\t\t\tunite(a,b,w);\n\t\t\t}else{\n\t\t\t\tif( root(a) != root(b) ) cout << \"UNKNOWN\" << endl;\n\t\t\t\telse cout << wei(b) - wei(a) << endl;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\ntypedef long long int lli;\n\nclass UnionFindTree{\npublic:\n    vector<int> v;\n    vector<int> rank;\n \n    UnionFindTree(int n){\n        v = vector<int>(n);\n        rank = vector<int>(n, 0);\n        for(int i=0; i<n; i++) v[i]=i;\n    }\n    int Find(int x){\n        if(v[x] != x){\n            v[x] = Find(v[x]);\n        }\n        return v[x];\n    }\n    void Union(int a, int b){\n        a = Find(a);\n        b = Find(b);\n        if(a == b) return;\n        if(rank[a] < rank[b]){\n            v[a] = b;\n        }else{\n            v[b] = a;\n            if(rank[a] == rank[b]){\n                rank[a]++;\n            }\n        }\n    }\n};\n\nint main(){\n    while(1){\n        int n,m;\n        cin >> n >> m;\n        if(n==0) break;\n\n        vector<lli> w(n+1);\n        vector<bool> decided(n+1, false);\n        UnionFindTree uft(n+1);\n        for(int i=0; i<m; i++){\n            char c;\n            cin >> c;\n            if(c=='!'){\n                int a,b,diff;\n                cin >> a >> b >> diff;\n                if(!decided[a] && !decided[b]){\n                    w[a] = 0;\n                    decided[a] = true;\n                }\n                if(decided[a]){\n                    w[b] = w[a]+diff;\n                }else{\n                    w[a] = w[b]-diff;\n                }\n                decided[a] = decided[b] = true;\n                uft.Union(a,b);\n            }else{\n                int a,b;\n                cin >> a >> b;\n                if(uft.Find(a) == uft.Find(b)){\n                    cout << w[b] -w[a] << endl;\n                }else{\n                    cout << \"UNKNOWN\" << endl;\n                }\n            }\n        }\n\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nvoid solve(int n,int m){\n    vector<map<int,int>> wmp(n);//idx to w\n    vector<int> pos(n);\n    iota(pos.begin(),pos.end(),0);\n    while(m--){\n        char type;\n        int a,b;\n        cin>>type>>a>>b;\n        a--,b--;\n        if(type=='?'){\n            if(pos[a]==pos[b]){\n                cout<<wmp[pos[a]][b]-wmp[pos[b]][a]<<\"\\n\";\n            }\n            else{\n                cout<<\"UNKNOWN\\n\";\n            }\n        }\n        else{\n            int w;\n            cin>>w;\n            if(pos[b]==pos[a]) continue;\n            //b-a=w b=a+w\n            //merge to a\n            if(wmp[pos[a]].size()<wmp[pos[b]].size()){\n                w=-w;\n                swap(a,b);\n            }\n            int wa=wmp[pos[a]][a];\n            int wb=wmp[pos[b]][b];\n            for(auto &e:wmp[pos[b]]){\n                int idx=e.first;\n                int we=e.second;\n                wmp[pos[a]][idx]=(we-wb)+wa+w;\n                pos[idx]=pos[a];\n            }\n        }\n    }\n    return;\n}\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    int n,m;\n    while(cin>>n>>m,n){\n        solve(n,m);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define all(c) (c).begin(),(c).end()\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;i--)\n#define REP(i,m,n) for(int i=(int)(m);i<(int)(n);i++)\n#define rep(i,n) REP(i,0,n)\n#define iter(c) __typeof((c).begin())\n#define tr(it,c) for(iter(c) it=(c).begin();it!=(c).end();it++)\n#define pb(a) push_back(a)\n#define pr(a) cout<<(a)<<endl\n#define PR(a,b) cout<<(a)<<\" \"<<(b)<<endl\n#define R cin>>\n#define F first\n#define S second\n#define ll long long\nbool check(int n,int m,int x,int y){return x>=0&&x<n&&y>=0&&y<m;}\nconst ll MAX=1000000007,MAXL=1LL<<60,dx[4]={-1,0,1,0},dy[4]={0,1,0,-1};\ntypedef pair<int,int> P;\n\nP p[100001];\nint r[100001];\nvoid init() {\n  for(int i=0; i<100001; i++) {\n    p[i]=P(i,0);\n    r[i]=0;\n  }\n}\nP find(int x) {\n  if(p[x].F==x) return p[x];\n  else {\n    P q=find(p[x].F);\n    p[x]=P(q.F,p[x].S+q.S);\n    return p[x];\n  }\n}\nvoid unite(int xx,int yy, int w) {\n  P x=find(xx);\n  P y=find(yy);\n  if(x.F==y.F) return;\n  \n  if(r[x.F]<r[y.F]) p[x.F]=P(y.F,y.S-x.S+w);\n  else {\n    p[y.F]=P(x.F,x.S-y.S-w);\n    if(r[x.F]==r[y.F]) r[x.F]++;\n  }\n}\n\nint main() {\n  int n,m;\n  while(cin >> n >> m && n) {\n    init();\n    while(m--) {\n      char c;\n      cin >> c;\n      if(c=='?') {\n\tint x,y;\n\tcin >> x >> y;\n\tP xx=find(x),yy=find(y);\n\tif(xx.F==yy.F) pr(xx.S-yy.S);\n\telse pr(\"UNKNOWN\");\n      } else {\n\tint x,y,w;\n\tcin >> x >> y >> w;\n\tunite(x,y,w);\n      }\n    }\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nconst int INF = 1e8;\nusing namespace std;\n\n\nstatic const int MAX_V = 100005;\nstatic const int MAX_M = 100005;\n\nclass Topological{\n\tpublic:\n\t\tvector<int> g[MAX_V]; //??°??????\n\t\tvector<int> tp; //????????????????????????????????????\n\n\t\tvoid bfs(int s, int indeg[MAX_V], bool used[MAX_V]){\n\t\t\tqueue<int> q;\n\n\t\t\tq.push(s);\n\t\t\tused[s] = true;\n\n\t\t\twhile(not q.empty()){\n\t\t\t\tint u = q.front(); q.pop();\n\t\t\t\ttp.emplace_back(u);\n\t\t\t\trep(i,g[u].size()){\n\t\t\t\t\tint v = g[u][i];\n\t\t\t\t\tindeg[v]--;\n\t\t\t\t\tif(indeg[v] == 0 && not used[v]){\n\t\t\t\t\t\tused[v] = true;\n\t\t\t\t\t\tq.push(v);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t//??°??????????????????????????´??????0?????????\n\t\tbool topologicalSort(int v){\n\t\t\tint indeg[MAX_V]; //??\\?¬???°\n\t\t\tbool used[MAX_V];\n\t\t\tmemset(indeg, 0, sizeof(indeg));\n\t\t\tmemset(used, 0, sizeof(used));\n\n\t\t\trep(i,v) rep(j,g[i].size()) indeg[ g[i][j] ]++;\n\t\t\trep(i,v) if(indeg[i] == 0 && not used[i]) bfs(i, indeg, used);\n\n\t\t\tfor(auto it:tp) cout << it << endl;\n\n\t\t\tif(tp.size() == v) return true;\n\t\t\telse return false;\n\t\t}\n};\n\n\nclass Union{\n\tpublic:\n\t\tint par[MAX_M]; //???\n\t\tint depth[MAX_M];//??¨?????±???\n\n\t\tvoid init(int n){\n\t\t\trep(i,n){\n\t\t\t\tpar[i] = i;\n\t\t\t\tdepth[i] = 0;\n\t\t\t}\n\t\t}\n\n\t\tint find(int x){\n\t\t\tif(par[x] == x){\n\t\t\t\treturn x;\n\t\t\t}else {\n\t\t\t\treturn par[x] = find(par[x]);\n\t\t\t}\n\t\t}\n\n\t\tvoid unite(int x, int y){\n\t\t\tx = find(x);\n\t\t\ty = find(y);\n\t\t\tif(x == y) return;\n\n\t\t\tif(depth[x] < depth[y]){\n\t\t\t\tpar[x] = y;\n\t\t\t}else{\n\t\t\t\tpar[y] = x;\n\t\t\t\tif(depth[x] == depth[y]) depth[x]++;\n\t\t\t}\n\t\t}\n\n\t\tbool same(int x, int y){\n\t\t\treturn find(x) == find(y);\n\t\t}\n};\n\nclass Edge{\n\tpublic:\n\t\tint to, cost;\n\t\tEdge(int to, int cost) : to(to) ,cost(cost) {}\n};\n\nclass Node{\n\tpublic:\n\t\tint dis;\n\t\tbool isUsed;\n\t\tint label;\n\t\tNode(){\n\t\t\tthis->dis = INF;\n\t\t\tthis->isUsed = 0;\n\t\t}\n};\n\ntypedef vector<vector<Edge>> AdjList;\n\nvoid dfs(AdjList& g, int cur, vector<Node>& node){\n\tnode[cur].isUsed = true;\n\tfor(auto e : g[cur]){\n\t\tif(node[e.to].isUsed) continue;\n\t\tnode[e.to].dis = node[cur].dis + e.cost;\n\t\tdfs(g, e.to, node);\n\t}\n}\n\nvoid dijkstra(AdjList g, int start, int n, vector<Node>& node){\n\tpriority_queue<int, vector<pair<int, int>>, greater<pair<int, int>>> q;\n\n\tq.push(make_pair(0, start));\n\tnode[start].dis = 0;\n\n\tpair<int, int> u;\n\twhile(not q.empty()){\n\t\tu = q.top(); q.pop();\n\t\tint current = u.second;\n\t\tnode[current].isUsed = 1;\n\n\t\trep(i,g[current].size()){\n\t\t\tint next = g[current][i].to;\n\t\t\tif(node[next].isUsed == 0){\n\t\t\t\tif(node[next].dis > node[current].dis + g[current][i].cost){\n\t\t\t\t\tnode[next].dis = node[current].dis + g[current][i].cost;\n\t\t\t\t\tq.push(make_pair(node[next].dis, next));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\tint n, q;\n\twhile(cin >> n >> q,n){\n\t\tint a[MAX_M], b[MAX_M], c[MAX_M];\n\t\tchar com[MAX_M];\n\n\t\tAdjList g(n);\n\t\tvector<int> in(n,0);\n\t\trep(i,q){\n\t\t\tcin >> com[i];\n\t\t\tif(com[i] == '!'){\n\t\t\t\tcin >> a[i] >> b[i] >> c[i];\n\t\t\t\ta[i]--; b[i]--;\n\t\t\t\tg[b[i]].emplace_back(Edge{a[i],c[i]});\n\t\t\t\tin[a[i]]++;\n\t\t\t}else{\n\t\t\t\tcin >> a[i] >> b[i];\n\t\t\t\ta[i]--; b[i]--;\n\t\t\t}\n\t\t}\n\n\t\tvector<Node> node(n);\n\t\trep(i,n){\n\t\t\tif(in[i] == 0){ //??\\?¬???°???0\n\t\t\t\tnode[i].dis = 0;\n\t\t\t\tdfs(g, i, node);\n\t\t\t}\n\t\t}\n\n\t\t//for(auto i : node){ cout << i.dis << ' '; } cout << endl;\n\n\t\tUnion uni;\n\t\tuni.init(n);\n\t\trep(i,q){\n\t\t\tif(com[i] == '!'){\n\t\t\t\tuni.unite(a[i], b[i]);\n\t\t\t}else{\n\t\t\t\tif(uni.same(a[i], b[i])){\n\t\t\t\t\t//show(a[i])\n\t\t\t\t\tcout << node[a[i]].dis - node[b[i]].dis << endl;\n\t\t\t\t}else{\n\t\t\t\t\tcout << \"UNKNOWN\" << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "// Wrongri-La Shower\n\n#include <iostream>\n#include <queue>\n#include <stack>\n#include <tuple>\n\ntypedef long long ll;\ntypedef std::tuple<int,ll> P;\n\ntemplate <int n>\nclass UnionFind{\npublic:\n    UnionFind(){\n        init();\n    }\n    void init(){\n        for(int i=0;i<n;i++){\n            par[i] = i;\n            rank[i] = 0;\n            weight[i] = 0ll;\n        }\n    }\n    P find(int x){\n        if(x == par[x])return std::make_tuple(x, weight[x]);\n\n        int prev_x = x;\n        ll w = 0;\n        while(x != par[x]){\n            w += weight[x];\n            // w_queue.push(w);\n            // v_stack.push(x);\n\n            x = par[x];\n        }\n\n        par[prev_x] = x;\n        weight[prev_x] = w;\n        \n        return std::make_tuple(x, w);\n    }\n    bool same(int x, int y){\n        return std::get<0>(find(x)) == std::get<0>(find(y));\n    }\n    void unite(int x, int y, int l){\n        P xp = find(x), yp = find(y);\n        ll wx, wy;\n        std::tie(x, wx) = xp;\n        std::tie(y, wy) = yp;\n        \n        if(x == y){return;}\n        \n        if(rank[x] > rank[y]){\n            par[y] = x;\n            weight[y] = wx - wy + l;\n        }else{\n            par[x] = y;\n            weight[x] = wy - wx - l;\n            if(rank[x] == rank[y]){rank[y]++;}\n        }\n    }\n    int rank[n], par[n];\n    ll weight[n];\n};\n\nUnionFind<100001> uf;\n\nint main(){\n    std::ios_base::sync_with_stdio(false);\n    \n    int N, M;\n    while(std::cin >> N >> M, N || M){\n        uf.init();\n\n        for(int i=0;i<M;i++){\n            char c;\n            std::cin >> c;\n            \n            if(c == '!'){\n                int a, b, c;\n                std::cin >> a >> b >> c;\n\n                uf.unite(a, b, c);\n            }else{\n                int a, b;\n                std::cin >> a >> b;\n\n                if(!uf.same(a, b)){\n                    std::cout << \"UNKNOWN\" << std::endl;\n                }else{\n                    P ap = uf.find(a), bp = uf.find(b);\n                    ll wa = std::get<1>(ap), wb = std::get<1>(bp);\n\n                    std::cout << wb-wa << std::endl;\n                }\n            }\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <algorithm>\n#include <iomanip>\n#include <cmath>\n#include <cassert>\n#include <map>\n#include <set>\nusing namespace std;\ntypedef pair<int, int> P;\n\nstruct UnionFind {\n\tvector<int> par;\n\tvector<int> d;\n\tint cnt;\n\tUnionFind(int size_) : par(size_, -1), d(size_), cnt(size_) {}\n\tvoid unite(int x, int y, int w) {\n\t\tP px = find(x), py = find(y);\n\t\tif(px.first != py.first) {\n\t\t\tif(par[py.first] < par[px.first]) swap(px, py), w *= -1;\n\t\t\tpar[px.first] += par[py.first];\n\t\t\tpar[py.first] = px.first;\n\t\t\td[py.first] = px.second - py.second - w;\n\t\t\tcnt--;\n\t\t}\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x).first == find(y).first;\n\t}\n\tP find(int x) {\n\t\tif(par[x] < 0) return P(x, 0);\n\t\tP res = find(par[x]);\n\t\tpar[x] = res.first;\n\t\td[x] += res.second;\n\t\treturn P(par[x], d[x]);\n\t}\n\tint size() { return cnt; }\n};\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint N, M;\n\twhile(cin >> N >> M, N | M) {\n\t\tUnionFind uf(N);\n\t\twhile(M--) {\n\t\t\tchar c; int a, b, diff;\n\t\t\tcin >> c >> a >> b;\n\t\t\ta--, b--;\n\t\t\tif(c == '!') {\n\t\t\t\tcin >> diff;\n\t\t\t\tif(uf.same(a, b)) continue;\n\t\t\t\tuf.unite(a, b, diff);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif(uf.same(a, b)) {\n\t\t\t\t\tint w1 = uf.find(a).second, w2 = uf.find(b).second;\n\t\t\t\t\tcout << w1 - w2 << endl;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tcout << \"UNKNOWN\" << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> P;\nconst double EPS = 1e-12;\nconst int INF = numeric_limits<int>::max()/2;\nconst int MOD = 1e9+7;\n\nstruct UFW { // union-find with weight\n\tvector<int> par,w; // w := weight between parent\n\tUFW(int size) : par(size, -1), w(size,0) { }\n\tbool unite(int x, int y, int d) {\n\t\tif (root(x) != root(y)) {\n            w[root(y)] = d+weight(x)-weight(y);\n\t\t\tpar[root(y)] = root(x);\n            \n\t\t}\n\t\treturn x != y;\n\t}\n    void init(int size){\n        for(int i=0;i<size;i++){\n            par[i]=i;\n            w[i]=0;\n        }\n    }\n\tbool same(int x, int y) {\n\t\treturn root(x) == root(y);\n\t}\n\tint root(int x) {\n        if(par[x]!=x) return root(par[x]);\n        return x;\n\t}\n    int weight(int x){\n        //cout<<x<<endl;\n        if(root(x)==x) return 0;\n        return w[x]+weight(par[x]);\n    }\n    /*\n    void print(int size){\n        for(int i=0;i<size;i++) cout<<\" \"<<i;\n        cout<<endl;\n        for(int i=0;i<size;i++) cout<<\" \"<<par[i];\n        cout<<endl;\n        for(int i=0;i<size;i++) cout<<\" \"<<w[i];\n        cout<<endl;\n    }*/\n};\n\nstruct WeightedUnionFind{\n    vector<int> par; // 親の番号\n    vector<int> ws;  // 親との重みの差\n    \n    WeightedUnionFind(int n) : par(n,-1), ws(n,0){}\n    \n    int find(int x){\n        if(par[x] < 0){\n            return x;\n        }else{\n            int parent = find(par[x]);\n            ws[x] += ws[par[x]];\n            return par[x] = parent;\n        }\n    }\n    \n    int weight(int x){\n        find(x); \n        return ws[x];\n    }\n    \n    bool unite(int x, int y, int w){ // x <-(w)- y (x + w = y)\n        w += weight(x); \n        w -= weight(y);\n        x = find(x); y = find(y);\n        \n        if(x != y){\n            if(par[y] < par[x]) {  // 多い方が根になるようにスワップする.\n                int tmp = x; x = y; y = tmp; w = -w;\n            }\n            par[x] += par[y]; par[y] = x;\n            ws[y] = w;\n            return true;\n        }else{\n            return false;\n        }\n    }\n    \n    bool same(int x, int y){\n        return find(x) == find(y);\n    }\n    \n    void init(int size){\n        for(int i=0;i<size;i++){\n            par[i]=-1;\n            ws[i]=0;\n        }\n    }\n};\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int n,m;\n    string s;\n    int a,b;\n    ll w;\n    WeightedUnionFind ufw(111111);\n    while(cin>>n>>m,n){\n        ufw.init(n);\n        for(int i=0;i<m;i++){\n            cin>>s;\n            if(s==\"!\"){\n                cin>>a>>b>>w;\n                a--;b--;\n                ufw.unite(a,b,w);\n            }\n            else{\n                cin>>a>>b;\n                a--;b--;\n                //uf.print(n);\n                if(!ufw.same(a,b)) cout<<\"UNKNOWN\"<<endl;\n                else{\n                    cout<<ufw.weight(b)-ufw.weight(a)<<endl;\n                    //cout<<uf.weight(b)<<\" \"<<uf.weight(a)<<endl;\n                }\n                \n            }\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <list>\n#include <set>\n#include <map>\n#include <queue>\n\nusing namespace std;\n#define DEBUG(x) cout<<#x<<\": \"<<x<<endl\n\n#define PB push_back\n#define MP make_pair\n#define F first\n#define S second\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n#define INT(a) int((a)+1e-9)\nint DX[4]={1,0,-1,0};\nint DY[4]={0,1,0,-1};\n\ntypedef pair<int,int> Pii;\n\n\n#define SUPnl 100002\n\nint nl;\nPii p[SUPnl];\t//p[n].F == n's parent, p[n].S == w[p[n].F]-w[n]\n\nvoid init(){REP(ni,nl){p[ni]=MP(-1,0);}}\n\nPii getRoot(int n){\n\tint rn=n; int w=0;\n\twhile(p[rn].F!=-1){\n\t\tw+=p[rn].S;\n\t\trn=p[rn].F;\n\t}\n\tif(rn!=n)p[n]=MP(rn,w);\n\treturn MP(rn,w);\n}\n\nvoid printW(int a, int b){\n\tPii rat=getRoot(a); Pii rbt=getRoot(b);\n\tif(rat.F!=rbt.F) cout<<\"UNKNOWN\"<<endl;\n\telse cout<< rbt.S - rat.S <<endl;\n}\n\nvoid setW(int a, int b, int w){\n\tPii rat=getRoot(a); Pii rbt=getRoot(b);\n\tif(rat.F==rbt.F) return;\n\tif(rat.S+w>=rbt.S){\n\t\tp[rbt.F]=MP(rat.F, rat.S+w-rbt.S);\n\t}else{\n\t\tp[rat.F]=MP(rbt.F, rbt.S-w-rat.S);\n\t}\n}\n\nint main(){\n\twhile(true){\n\t\tint ol;\n\t\tcin>>nl>>ol;\t\tif(!nl) return 0;\n\t\tinit();\n\t\tREP(oi,ol){\n\t\t\tchar ot; int a,b,w;\n\t\t\tcin>>ot;\n\t\t\tif(ot=='!'){\n\t\t\t\tcin>>a>>b>>w;\n\t\t\t\tsetW(a-1,b-1,w);\n\t\t\t}\n\t\t\tif(ot=='?'){\n\t\t\t\tcin>>a>>b;\n\t\t\t\tprintW(a-1,b-1);\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "     #include <bits/stdc++.h>\n\n//    #include <boost/multiprecision/cpp_int.hpp>\n #define int long long\n #define inf  1000000007\n #define pa pair<int,int>\n #define ll long long\n #define pal pair<double,double>\n #define ppap pair<pa,int>\n  #define PI 3.14159265358979323846\n  #define paa pair<int,char>\n  #define  mp make_pair\n  #define  pb push_back\n  #define EPS (1e-10)\n                                          \n    int dx[8]={0,1,0,-1,1,1,-1,-1};\n    int dy[8]={1,0,-1,0,-1,1,1,-1};\n                                            using namespace std;\n                                   \t\t\tclass pa3{\n                                            \tpublic:\n                                            \tint x,y,z;\n                                            \tpa3(int x=0,int y=0,int z=0):x(x),y(y),z(z) {}\n                                            \tbool operator < (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\t return z<p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                   \t\t\t\tbool operator > (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\t return z>p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa3 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z;\n                                            \t}\n                                            \t\tbool operator != (const pa3 &p) const{\n                                            \t\t\treturn !( x==p.x && y==p.y && z==p.z);\n                                            \t}\n                                            \n                                            };\n                                            \n                                            class pa4{\n                                            \tpublic:\n                                            \tint x;\n                                            \tint y,z,w;\n                                            \tpa4(int x=0,int y=0,int z=0,int w=0):x(x),y(y),z(z),w(w) {}\n                                            \tbool operator < (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\tif(z!=p.z)return z<p.z;\n                                            \t\treturn w<p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator > (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\tif(z!=p.z)return z>p.z;\n                                            \t\treturn w>p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa4 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z &&w==p.w;\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            class pa2{\n                                            \tpublic:\n                                            \tint x,y;\n                                            \tpa2(int x=0,int y=0):x(x),y(y) {}\n                                            \tpa2 operator + (pa2 p) {return pa2(x+p.x,y+p.y);}\n                                            \tpa2 operator - (pa2 p) {return pa2(x-p.x,y-p.y);}\n                                            \tbool operator < (const pa2 &p) const{\n                                            \t\treturn y != p.y ? y<p.y: x<p.x;\n                                            \t}\n                                            \tbool operator > (const pa2 &p) const{\n                                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa2 &p) const{\n                                            \t\treturn abs(x-p.x)==0 && abs(y-p.y)==0;\n                                            \t}\n                                            \tbool operator != (const pa2 &p) const{\n                                            \t\treturn !(abs(x-p.x)==0 && abs(y-p.y)==0);\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            \n/*\n                                            class Point{\n                                            \tpublic:\n                                            \tdouble x,y;\n                                            \tPoint(double x=0,double y=0):x(x),y(y) {}\n                                            \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                                            \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                                            \tPoint operator * (double a) {return Point(x*a,y*a);}\n                                            \tPoint operator / (double a) {return Point(x/a,y/a);}\n                                            \tdouble absv() {return sqrt(norm());}\n                                            \tdouble norm() {return x*x+y*y;}\n                                            \tbool operator < (const Point &p) const{\n                                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const Point &p) const{\n                                            \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                                            \t}\n                                            };\n                                            typedef Point Vector;\n                                     #define pl pair<int,pas>\n                                            struct Segment{\n                                            Point p1,p2;\n                                            };\n                                             double dot(Vector a,Vector b){\n                                            \treturn a.x*b.x+a.y*b.y;\n                                            }\n                                            double cross(Vector a,Vector b){\n                                            \treturn a.x*b.y-a.y*b.x;\n                                            }\n                                        \n                bool parareru(Point a,Point b,Point c,Point d){\n                //\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n                \treturn abs(cross(a-b,d-c))<EPS;\n                }\n                double distance_ls_p(Point a, Point b, Point c) {\n                  if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n                  if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n                  return abs(cross(b-a, c-a)) / (b-a).absv();\n                }\n                bool is_intersected_ls(Segment a,Segment b) {\n                \tif(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n                \tif(parareru((a.p2),(a.p1),(a.p1),(b.p2))&&parareru((a.p2),(a.p1),(a.p1),(b.p1))){\n                //\t\tcout<<\"sss\"<<endl;\n                \t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n                \t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n                \t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n                \t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n                \t\treturn false;\n                \t}\n                  else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n                }\n                 \n                double segment_dis(Segment a,Segment b){\n                \tif(is_intersected_ls(a,b))return 0;\n                \tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n                \tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n                \tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n                \tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n                \treturn r;\n                }\n                Point intersection_ls(Segment a, Segment b) {\n                  Point ba = b.p2-b.p1;\n                  double d1 = abs(cross(ba, a.p1-b.p1));\n                  double d2 = abs(cross(ba, a.p2-b.p1));\n                  double t = d1 / (d1 + d2);\n                 \n                  return a.p1 + (a.p2-a.p1) * t;\n                }\n */                \n                                string itos( int i ) {\n                                ostringstream s ;\n                                s << i ;\n                                return s.str() ;\n                                }\n                                 \n                                int gcd(int v,int b){\n                                \tif(v>b) return gcd(b,v);\n                                \tif(v==b) return b;\n                                \tif(b%v==0) return v;\n                                \treturn gcd(v,b%v);\n                                }\n                 \n                                double distans(double x1,double y1,double x2,double y2){\n                                \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                                \treturn sqrt(rr);\n                                \t\n                                }\n                                int mod;\nint extgcd(int a, int b, int &x, int &y) {\n    if (b == 0) {\n        x = 1;\n        y = 0;\n        return a;\n    }\n    int d = extgcd(b, a%b, y, x);\n    y -= a/b * x;\n    return d;\n}\n    \n                                \n                int pr[1000010];\n                int inv[1000010];\n                \n                int beki(int wa,int rr,int warukazu){\n                \tif(rr==0) return 1%warukazu;\n                \tif(rr==1) return wa%warukazu;\n                \twa%=warukazu;\n                \tif(rr%2==1) return ((ll)beki(wa,rr-1,warukazu)*(ll)wa)%warukazu;\n                \tll zx=beki(wa,rr/2,warukazu);\n                \treturn (zx*zx)%warukazu;\n                }\n    double bekid(double w,int r){\n    \tif(r==0) return 1.0;\n    \tif(r==1) return w;\n    \tif(r%2) return bekid(w,r-1)*w;\n    \tdouble f=bekid(w,r/2);\n    \treturn f*f;\n    }\n                \n    \t\t\tint comb(int nn,int rr){\n    \t\t\t\tint r=pr[nn]*inv[rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\tr*=inv[nn-rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\treturn r;\n    \t\t\t}\n                \n                void gya(int ert){\n                \tpr[0]=1;\n                \tfor(int i=1;i<ert;i++){\n                \t\tpr[i]=(pr[i-1]*i)%mod;\n                \t}\n                \tfor(int i=0;i<ert;i++) inv[i]=beki(pr[i],mod-2,mod);\n                \t\n                }\n                \n              //   cin.tie(0);\n    \t\t//\tios::sync_with_stdio(false);\n    \t\t\t//priority_queue<pa3,vector<pa3>,greater<pa3>> pq;            \n                 //sort(ve.begin(),ve.end(),greater<int>());\n    \n                                     //----------------kokomade tenpure------------\n                                     \nstruct weight_unionfind{\n\tprivate:\n\tpublic:\n\t\nvector<int> par,ranks,kosuu,dif;\n\t\n\tvoid shoki(int N){\n\t\tpar.resize(N+1,0);\n\t\tranks.resize(N+1,0);\n\t\tkosuu.resize(N+1,1);\n\t\tdif.resize(N+1,0);\n\t\t\n\t\tfor(int i=0;i<=N;i++){\n\t\t\tpar[i]=i;\n\t\t}\n\t}\n\n\tint root(int x){\n\t\tif(par[x]==x) return x;\n\t\tint r=root(par[x]);\n\t\tdif[x]+=dif[par[x]];\n\t\tpar[x]=r;\n\t\treturn r;\n\t}\n\t\n\tint poten(int x){\n\t\troot(x);\n\t\treturn dif[x];\n\t}\n\t\n\tint diff(int x,int y){//po[y]-po[x]\n\t\treturn poten(y)-poten(x);\n\t}\n\t\n\tbool same(int x,int y){\n\t\treturn root(x)==root(y);\n\t}\n\t\n\t\n\t\n\tbool is_root(int x){\n\t\treturn x==root(x);\n\t}\n\tvoid unite(int x,int y,int val){\n\t\t//矛盾がないかsameとdiffから確認してから使う！！\n\t\t//po[x]+val=po[y]\n\t\tint px=poten(x),py=poten(y);\n\t\tx=root(x);\n\t \ty=root(y);\n\t\tint xx=kosuu[x],yy=kosuu[y];\n\t \tif(x==y) return;\n\t\tif(ranks[x]<ranks[y]){\n\t\t\tval=py-px-val;\n\t\t\tpar[x]=y;\n\t\t\tdif[x]=val;\n\t\t\tkosuu[y]=yy+xx;\n\t\t}\n\t \telse {\n\t \t\tval=val+px-py;\n\t\t\tpar[y]=x;\n\t \t\tdif[y]=val;\n\t\t\tif(ranks[x]==ranks[y]) ranks[x]=ranks[x]+1;\n\t \t\tkosuu[x]=yy+xx;\n\t \t}\n\t\treturn;\n\t}\n};\n\nvoid solve(){\n\tint n,m;\n\tcin>>n>>m;\n\tif(n==0 && m==0) exit(0);\n\tweight_unionfind UF;\n\tUF.shoki(n+1);\n\tfor(int i=0;i<m;i++){\n\t\tstring s;\n\t\tcin>>s;\n\t\tif(s==\"!\"){\n\t\t\tint a,b,w;\n\t\t\tcin>>a>>b>>w;\n\t\t\tUF.unite(a,b,w);\n\t\t}\n\t\telse{\n\t\t\tint a,b;\n\t\t\tcin>>a>>b;\n\t\t\tif(!UF.same(a,b)){\n\t\t\t\tcout<<\"UNKNOWN\"<<endl;\n\t\t\t}\n\t\t\telse cout<<UF.diff(a,b)<<endl;\n\t\t}\n\t}\n}\n\n signed main(){\n\n    \t       cin.tie(0);\n   \t\t\tios::sync_with_stdio(false);\n\n \n \twhile(1){\n \t\tsolve();\n \t}\n \treturn 0;\n  }\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cassert>\n#include<algorithm>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<29)\n#define MAX 3000000\nusing namespace std;\nstruct P\n{\n  int color,w;\n  P(int color=-inf,int w=-inf):color(color),w(w){}\n};\nP par[MAX];\nvoid init(){ rep(i,MAX)par[i] = P(i); }\n\nP find(int x)\n{\n  if(x == par[x].color)return par[x];\n  P p = find(par[x].color);\n  if(par[x].w == -inf)par[x].w = 0;\n  par[x].w += p.w,par[x].color = p.color;\n  return par[x];\n}\n\nvoid unit(int x,int y,int w)//x <= y\n{\n  P X = find(x); \n  P Y = find(y);\n  par[X.color].color = par[Y.color].color;\n  if(par[X.color].w == -inf)par[X.color].w = 0;\n  if(par[Y.color].w == -inf)par[Y.color].w = 0;\n  par[X.color].w = par[X.color].w + (par[y].w-w - par[x].w);\n}\n\nint N,M;\n\nint main()\n{\n  while(cin >> N >> M,N|M)\n    {\n      init();\n      char c;\n      int a,b,w;\n      rep(_,M)\n\t{\n\t  cin >> c;\n\t  if(c == '!')\n\t    {\n\t      cin >> a >> b >> w;\n\t      unit(a,b,w);\n\t    }\n\t  else\n\t    {\n\t      cin >> a >> b;\n\t      P B = find(b);\n\t      P A = find(a);\n\t      if(B.color != A.color)cout << \"UNKNOWN\" << endl;\n\t      else cout << B.w-A.w << endl;\n\t    }\n\t}\n    }\n  return 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)n;++i)\n#define each(a, b) for(auto (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout <<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout <<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define svec(v) cout<<#v<<\":\";rep(i,v.size())cout<<\" \"<<v[i];cout<<endl\n#define sset(s) cout<<#s<<\":\";each(i,s)cout <<\" \"<<i;cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int>P;\n\nconst int MAX_N = 100005;\n\nint par[MAX_N];\nint nrank[MAX_N];\nint weight[MAX_N];\n\nvoid initial(int n){\t\t//?????????\n\tfor(int i=0;i<n;i++){\n\t\tpar[i] = i;\n\t\tnrank[i] = 0;\n        weight[i] = 0;\n\t}\n}\n\nP find(int x){\t\t//??¨??????????±???????\n\tif(par[x] == x){\n\t\treturn P(x,0);\n\t}else{\n\t\tP p = find(par[x]);\n\t\tpar[x] = p.fi;\n\t\tweight[x] = p.se + weight[x];\n\t\treturn P(par[x],weight[x]);\n\t}\n}\n\nvoid unite(int x,int y,int w){\n\tx = (find(x)).fi;\n\ty = (find(y)).fi;\n\tif(x == y) return;\n\tif(nrank[x] < nrank[y]){\n\t\tpar[x] = y;\n        weight[x] = -w;\n\t}else{\n\t\tpar[y] = x;\n        weight[y] = w;\n\t\tif(nrank[x] == nrank[y])\n\t\t\tnrank[x]++;\n\t}\n}\n\nbool same(int x,int y){\n\treturn (find(x)).fi == (find(y)).fi;\n}\n\nint main()\n{\n    while(1){\n        int n,m;\n        cin >> n >> m;\n        if(n == 0){\n            break;\n        }\n        initial(n+1);\n        rep(i,m){\n            int a,b,w;\n            string s;\n            cin >> s ;\n            if(s == \"!\"){\n                cin >> a >> b >> w;\n                unite(a,b,w);\n            }else{\n                cin >> a >> b;\n                if(same(a,b)){\n                    cout << weight[b] - weight[a] << \"\\n\";\n                }else{\n                    cout << \"UNKNOWN\\n\";\n                }\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define f first\n#define s second\n#define mp make_pair\n#define inf 1<<30\n#define MAX 100001\nusing namespace std;\n\nint p[MAX],w[MAX];\nmap<pair<int,int>,int> M;\n\npair<int,int> find(int a){\n  pair<int,int> pii;\n  if(p[a]==a){\n    pii.f=a;pii.s=0;\n    return pii;\n  }\n  pii=find(p[a]);\n  pii.s+=w[a];\n  return pii;\n}\n\nint main()\n{\n  int n,q,a,b,d;\n  char c;\n\n  while(cin>>n>>q && n ){\n    for(int i=0;i<n;i++){\n      p[i]=i;\n      w[i]=0;\n    }\n    M.clear();\n\n    for(int i=0;i<q;i++){\n      cin>>c;\n      if(c=='!'){\n\tcin>>a>>b>>d;\n\ta--;b--;\n\tp[a]=b;\n\tw[a]=d;\n      }\n      else {\n\tcin>>a>>b;\n\ta--;b--;\n\tpair<int,int> pa=find(a),pb=find(b);\n\tif(pa.f!=pb.f)cout<<\"UNKNOWM\"<<endl;\n\telse {\n\t  p[a]=pa.f;\n\t  w[a]=pa.s;\n\t  p[b]=pb.f;\n\t  w[b]=pb.s;\n\t  cout<<pa.s-pb.s<<endl;\n\t}\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <cassert>\n#include <memory>\n#include <time.h>\nusing namespace std;\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\nconst double EPS = 1e-9;\nconst double PI  = acos(-1.0);\n\nconst int MAX_N=100010;\nint par[MAX_N];\nint myrank[MAX_N];\n\nvoid init(int n){\n\tfor(int i=0;i<n;i++){\n\t\tpar[i]=i;\n\t\tmyrank[i]=0;\n\t}\n}\n\nint find(int x){\n\tif(par[x]==x){\n\t\treturn x;\n\t}else{\n\t\tmyrank[x]+=myrank[par[x]];\n\t\treturn par[x]=find(par[x]);\n\t}\n}\n\nvoid unite(int x,int y,int w){\n\tint px=find(x);\n\tint py=find(y);\n\tint w2=w-(myrank[y]-myrank[py])+(myrank[x]-myrank[px]);\n\tif(px==py)return;\n\n\tpar[py]=px;\n\tmyrank[py]=w2;\n}\n\nbool same(int x,int y){\n\treturn find(x)==find(y);\n}\n\nint main(){\n\tint n,m;\n\twhile(cin>>n>>m,n|m){\n\t\tinit(n+1);\n\t\tREP(i,m){\n\t\t\tchar q;\n\t\t\tint a,b,w;\n\t\t\tcin>>q>>a>>b;\n\t\t\tif(q=='!'){\n\t\t\t\tcin>>w;\n\t\t\t\tunite(a,b,w);\n\t\t\t}else{\n\t\t\t\tif(same(a,b)){\n\t\t\t\t\tcout<<myrank[b]-myrank[a]<<endl;\n\t\t\t\t}else{\n\t\t\t\t\tcout<<\"UNKNOWN\"<<endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cassert>\n#include<algorithm>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<29)\n#define MAX 3000000\nusing namespace std;\ntypedef long long ll;\nstruct P\n{\n  ll color,w;\n  P(ll color=-inf,ll w=-inf):color(color),w(w){}\n};\nP par[MAX];\nvoid init(){ rep(i,MAX)par[i] = P(i); }\n\nP find(int x)\n{\n  if(x == par[x].color)return par[x];\n  P p = find(par[x].color);\n  if(par[x].w == -inf)par[x].w = 0;\n  par[x].w += p.w,par[x].color = p.color;\n  return par[x];\n}\n\nvoid unit(int x,int y,ll w)//x <= y\n{\n  P X = find(x); \n  P Y = find(y);\n  //if(X.color == Y.color)return;\n  par[X.color].color = par[Y.color].color;\n  if(par[X.color].w == -inf)par[X.color].w = 0;\n  if(par[Y.color].w == -inf)par[Y.color].w = 0;\n  par[X.color].w = par[X.color].w + (par[y].w-w - par[x].w);\n  //par[x].w -= par[y].w;\n}\n\nint N,M;\n\nint main()\n{\n  while(cin >> N >> M,N|M)\n    {\n      init();\n      char c;\n      ll a,b,w;\n      rep(_,M)\n\t{\n\t  cin >> c;\n\t  if(c == '!')\n\t    {\n\t      cin >> a >> b >> w;\n\t      unit(a,b,w);\n\t    }\n\t  else\n\t    {\n\t      cin >> a >> b;\n\t      ll B = find(b).w;\n\t      ll A = find(a).w;\n\t      if(B == -inf || A == -inf)cout << \"UNKNOWN\" << endl;\n\t      else cout << B-A << endl;\n\t    }\n\n\t  rep(i,10)\n\t    {\n\t      // cout << i << \" = \" << par[i].color << \",\" << par[i].w << endl;\n\t    }\t\n\t  //cout << endl;\n\n\t}\n    }\n  return 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,n) for(int i=0; i<n; i++)\n\nint par[100001];\nint we[100001];\nint rnk[100001];\n\nint find(int x) {\n\tif(par[x] == x) return x;\n\tint res = find(par[x]);\n\tpar[x] = res;\n\twe[x] += we[res];\n\treturn res;\n}\n\nvoid uni(int x, int y, int w) {\n\tint a = find(x);\n\tint b = find(y);\n\tif(rnk[a] > rnk[b]) {\n\t\tpar[y] = a;\n\t\twe[y] = w - we[y] + we[x];\n\t} else {\n\t\tpar[x] = b;\n\t\twe[x] = -(w - we[y] + we[x]);\n\t\tif(rnk[a] == rnk[b]) rnk[b]++;\n\t}\n}\n\n\nint main() {\n\tint n, m;\n\twhile(cin >> n >> m, n and m) {\n\t\trep(i,n+1) {par[i] = i; we[i] = 0; rnk[i]=1;}\n\t\trep(i, m) {\n\t\t\tchar c;\n\t\t\tint x, y;\n\t\t\tcin >> c >> x >> y;\n\t\t\tif(c == '!') {\n\t\t\t\tint w;\n\t\t\t\tcin >> w;\n\t\t\t\tuni(x, y, w);\n\t\t\t} else {\n\t\t\t\tint a = find(x), b = find(y);\n\t\t\t\tif(a != b) cout << \"UNKNOWN\" << endl;\n\t\t\t\telse cout << we[y] - we[x] << endl;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include <iostream>\n#include <math.h>\n#include <numeric>\n#include <vector>\n#include <map>\n#include <functional>\n#include <stdio.h>\n#include <array>\n#include <algorithm>\n#include <string>\n#include <string.h>\n#include <assert.h>\n#include <stdio.h>\n#include <queue>\n#include<iomanip>\n#include<bitset>\n#include<stack>\n#include<set>\n#include<limits>\n#include <complex>\n#include<cstdlib>\nusing namespace std;\n\nstruct UnionFind {\n\tvector<int> data;\n\tUnionFind(int size) : data(size, -1) { }\n\tbool unionSet(int x, int y) {\n\t\tx = root(x); y = root(y);\n\t\tif (x != y) {\n\t\t\tif (data[y] < data[x]) swap(x, y);\n\t\t\tdata[x] += data[y]; data[y] = x;\n\t\t}\n\t\treturn x != y;\n\t}\n\tbool findSet(int x, int y) {\n\t\treturn root(x) == root(y);\n\t}\n\tint root(int x) {\n\t\treturn data[x] < 0 ? x : data[x] = root(data[x]);\n\t}\n\tint size(int x) {\n\t\treturn -data[root(x)];\n\t}\n};\nstruct aUnionFind {\n\tvector<pair<int, long long int>> data;\n\taUnionFind(int size) : data(size, make_pair(-1, 0)) { }\n\tbool unionSet(const int x, const int y, const long long int w) {\n\t\tconst int rx(root(x).first), ry(root(y).first);\n\t\tif (rx != ry) {\n\t\t\tdata[rx].first += data[ry].first; data[ry].first = rx;\n\t\t\tdata[ry].second =-data[y].second + w + data[x].second;\n\t\t}\n\t\treturn rx != ry;\n\t}\n\tbool findSet(const int x, const int y) {\n\t\treturn root(x) == root(y);\n\t}\n\tpair<int,long long int> root(const int x) {\n\t\tif (data[x].first < 0) {\n\t\t\treturn make_pair(x, 0);\n\t\t}\n\t\telse {\n\t\t\tpair<int, long long int>ndata;\n\t\t\tndata.first = root(data[x].first).first;\n\t\t\tndata.second =data[x].second+ root(data[x].first).second;\n\t\t\treturn data[x]=ndata;\n\t\t}\n\t}\n\tint size(const int x) {\n\t\treturn -data[root(x).first].first;\n\t}\n};\n\n\n\nint main() {\n\twhile (1) {\n\t\tint N, M; cin >> N >> M;\n\t\tif (!N)break;\n\t\tvector<pair<int,int>>weis(N,make_pair(-1,-1));\n\t\taUnionFind uf(N);\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\tchar c; cin >> c;\n\t\t\tif (c == '!') {\n\t\t\t\tint a, b, w; cin >> a >> b >> w;\n\t\t\t\ta--; b--;\n\t\t\t\tuf.unionSet(a, b,w);\n\t\t\t\t\n\t\t\t\t\n\t\t\t}\n\t\t\telse {\n\t\t\t\tint a, b; cin >> a >> b;\n\t\t\t\ta--; b--;\n\t\t\t\tif (uf.root(a).first == uf.root(b).first) {\n\t\t\t\t\tint aa=uf.root(a).second - uf.root(b).second;\n\t\t\t\t\tcout << -aa << endl;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tcout << \"UNKNOWN\" << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\ntypedef long long ll;\nusing namespace std;\n\nconst int C = 100010;\nconst ll infty = 100010100010100010;\npair<int, ll> P[C]; // root, diff: w_self - w_root\n\nvoid init(int N) {\n  for (auto i=0; i<N; i++) {\n    P[i] = make_pair(i, 0);\n  }\n}\n\npair<int, ll> root(int a) {\n  if (P[a].first == a) return P[a];\n  pair<int, ll> t = root(P[a].first);\n  return (P[a] = make_pair(t.first, t.second + P[a].second));\n}\n\nll diff(int a, int b) { // a, bが同じ根を持つならw_b-w_aを、そうでないならinftyを返す。\n  if (root(a).first == root(b).first) {\n    return root(b).second - root(a).second;\n  }\n  return infty;\n}\n\nvoid weight(int a, int b, int w) { // w_b - w_aの値を登録する\n  pair<int, ll> ta = root(a);\n  pair<int, ll> tb = root(b);\n  P[root(b).first] = make_pair(ta.first, -tb.second + w + ta.second);\n}\n\nint main() {\n  int n, m;\n  while (cin >> n >> m && n) {\n    init(n);\n    for (auto i=0; i<m; i++) {\n      char c;\n      int a, b, w;\n      cin >> c;\n      if (c == '!') {\n        cin >> a >> b >> w;\n        a--; b--;\n        weight(a, b, w);\n      } else {\n        cin >> a >> b;\n        a--; b--;\n        ll d = diff(a, b);\n        if (d < infty) {\n          cout << d << endl;\n        } else {\n          cout << \"UNKNOWN\" << endl;\n        }\n      }\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\n\nstruct UnionFind {\n    ll node[100010], weight[100010];\n    UnionFind() {\n        memset(node, -1, sizeof(node));\n        memset(weight, 0, sizeof(weight));\n    }\n    void unite(int u, int v, ll w) {\n        // printf(\"(u, v) = (%d, %d)\\n\", u, v);\n        // printf(\"find(u, v) = (%d, %d)\\n\", find(u), find(v));\n        if(find(u) == find(v)) return;\n        if(find(u) > find(v)) swap(u, v), w *= -1;\n        ll new_weight = get_weight(u);\n\n        // printf(\"new_weight = %d\\n\", new_weight);\n        // v ????????? (u ??????) ???????????????\n        u = find(u);\n        node[u] += node[v];\n        node[v] = u;\n        weight[v] += new_weight + w;\n    }\n\n    ll get_weight(int u) {\n        ll ret = 0;\n        for(; node[u] >= 0; u = node[u]) {\n            if(u < 0) break;\n            ret += weight[u];\n        }\n        return ret;\n    }\n\n    int find(int u) {\n        return (node[u] < 0 ? u : node[u] = find(node[u]));\n    }\n};\n\nint main() {\n    int N, M;\n    while(cin >> N >> M, N) {\n        UnionFind uf;\n        for(int i=0; i<M; i++) {\n            char c; cin >> c;\n            if(c == '!') {\n                int a, b, d; cin >> a >> b >> d;\n                a--; b--;\n                uf.unite(a, b, d);\n            }\n            else {\n                int a, b; cin >> a >> b;\n                a--; b--;\n                if(uf.find(a) != uf.find(b)) cout << \"UNKNOWN\" << endl;\n                else {\n                    ll wa = uf.weight[a];\n                    ll wb = uf.weight[b];\n                    // printf(\"wa = %d, wb = %d\\n\", wa, wb);\n                    cout << wb - wa << endl;\n                }\n            }\n        }\n        for(int i=0; i<N; i++) {\n            // printf(\"parent[%d] = %d, weight[%d] = %d\\n\", i, uf.node[i], i, uf.weight[i]);\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for (int i = 0; i < (n); ++i)\n#define repr(i, n) for (int i = (n); i >= 0; --i)\n#define FOR(i, m, n) for (int i = (m); i < (n); ++i)\n#define FORR(i, m, n) for (int i = (m); i >= (n); --i)\n#define equals(a, b) (fabs((a) - (b)) < EPS)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\nconst ll mod = 1000000007;\n//const ll mod = 998244353;\nconst int inf = 1e9 + 10;\nconst ll INF = 1e18;\nconst ld EPS = 1e-10;\nconst int dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nconst int dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\n\ntemplate<class T> struct UnionFind {\n  vector<ll> par; \n  vector<ll> siz;\n  vector<T> diff_weight;\n    \n  UnionFind(ll sz_, T sum_unity = 0): par(sz_), siz(sz_, 1), diff_weight(sz_, sum_unity) {\n    for (ll i = 0; i < sz_; ++i) par[i] = i;\n\n  }\n  void init(ll sz_, T sum_unity) {\n    par.resize(sz_);\n    siz.resize(sz_, 1);\n    diff_weight.resize(sz_, sum_unity);\n    for (ll i = 0; i < sz_; ++i) par[i] = i;\n  }\n\n  ll root(ll x) { \n    if (par[x] == x) {\n      return x;\n    }\n    else {\n      ll r = root(par[x]);\n      diff_weight[x] += diff_weight[par[x]];\n      return par[x] = r;\n    }\n  }\n\n  T weight(ll x) {\n    root(x);\n    return diff_weight[x];\n  }\n\n  bool merge(ll x, ll y, T w) {\n    w += weight(x);\n    w -= weight(y);\n    x = root(x);\n    y = root(y);\n    if (x == y) return false;\n    if (siz[x] < siz[y]) {\n      swap(x, y);\n      w = -w;\n    }\n    siz[x] += siz[y];\n    par[y] = x;\n    diff_weight[y] = w;\n    return true;\n  }\n\n  bool issame(ll x, ll y) {\n    return root(x) == root(y);\n  }\n\n  ll size(ll x) {\n    return siz[root(x)];\n  }\n\n  T diff(ll x, ll y) {\n    return weight(y) - weight(x);\n  }\n};\n\nll n, m;\n\nvoid solve() {\n  UnionFind<ll> uf(n, 0);\n  while (m--) {\n    char t;\n    cin >> t;\n\n    if (t == '!') {\n      ll a, b, w;\n      cin >> a >> b >> w;\n      a--, b--;\n\n      uf.merge(a, b, w);\n    }\n    else {\n      ll a, b;\n      cin >> a >> b;\n      a--, b--;\n\n      if (uf.issame(a, b)) cout << uf.diff(a, b) << '\\n';\n      else cout << \"UNKNOWN\\n\";\n    }\n  }\n}\n\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  cout << fixed << setprecision(25);\n\n  while (cin >> n >> m, n && m) {\n    solve();\n  }\n\n  \n\n\n\n\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\ntemplate<typename Abel>\nstruct WeightedUnionFind{\n    int num;\n    vector<int> par,rank;\n    vector<Abel> diff_weight;\n    WeightedUnionFind(int n,Abel id=0):\n        num(n),par(n),rank(n,1),diff_weight(n,Abel(0)){\n        iota(par.begin(),par.end(),0);\n    }\n    int root(int x){\n        if (x==par[x]) return x;\n        int t=root(par[x]);\n        diff_weight[x]+=diff_weight[par[x]];\n        return par[x]=t;\n    }\n    bool merge(int x,int y,Abel w){\n        w+=weight(x),w-=weight(y);\n        x=root(x),y=root(y);\n        if (x==y) return false;\n        if (rank[x]<rank[y]) swap(x,y),w=-w;\n        par[y]=x;\n        rank[x]+=rank[y];\n        diff_weight[y]=w;\n        --num;\n        return true;\n    }\n    Abel weight(int x){\n        root(x);\n        return diff_weight[x];\n    }\n    Abel diff(int x,int y){return weight(y)-weight(x);}\n    bool same(int x,int y){return root(x)==root(y);}\n    int size(int x){return rank[root(x)];}\n    int count(){return num;}\n};\n\nint N,M,a,b;\nchar c; ll w;\n\nvoid solve(){\n    WeightedUnionFind<int> uf(N);\n    for (;M--;){\n        cin >> c >> a >> b; --a,--b;\n        if (c=='!'){\n            cin >> w;\n            uf.merge(a,b,w);\n        } else {\n            if (!uf.same(a,b)) cout << \"UNKNOWN\" << '\\n';\n            else cout << uf.diff(a,b) << '\\n';\n        }\n    }\n}\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while(cin >> N >> M,N,M){\n        solve();\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<utility>\n#include<cstring>\n#include<vector>\n\nusing namespace std;\n\nstruct parent{\n  int id, weightDiff;\n};\n\nvector<parent> UFtree;\n\nint root_Diff(int i) {\n  if(UFtree[i].id == i) return 0;\n  else return UFtree[i].weightDiff + root_Diff(UFtree[i].id);\n}\n\nint root(int i) {\n  if(UFtree[i].id == i) return i;\n  else {\n    UFtree[i].weightDiff = root_Diff(i);\n    return (UFtree[i].id = root(UFtree[i].id));\n  }\n}\n\nbool is_same_set(int i, int j) {\n  return root(i) == root(j);\n}\n\n\n\nvoid unite(int i, int j, int w) {//w_i-w_j = w\n  int x, y;\n  x = root(i); y = root(j);\n  UFtree[y].id = x;\n  UFtree[y].weightDiff = w + UFtree[i].weightDiff - UFtree[j].weightDiff;\n}\n\nint main() {\n  int N, M;\n  while(cin >> N >> M) {\n    if(!N) break;\n    parent zero;\n    UFtree.push_back(zero);\n    for(int i = 1; i <= N; i++){\n      parent p = {i, 0};\n      UFtree.push_back(p);\n    }\n    string word;\n    int a, b, w;\n    for(int i = 0; i < M; i++) {\n      cin >> word >> a >> b;\n      if(word == \"!\") {\n\tcin >> w;\n\tunite(b, a, w);\n      }\n      else {\n\tif(is_same_set(a, b)) cout << root_Diff(a) - root_Diff(b) << endl;\n\telse cout << \"UNKNOWN\" << endl;\n      }\n    }\n    UFtree.clear();\n    UFtree.shrink_to_fit();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define PI       3.1415926535897932384626433832795028841971\n#define INF 1000000000\n#define EPS      1e-10\n#define MOD      1000000\nusing namespace std;\ntypedef long long ll;\ntypedef pair<double,double> P;\ntypedef pair<double,P> PQ;\n\nstruct UF{\n\tint par[100000];\n\tint rank[100000];\n    ll si[100000];\n\n\tvoid init(int n){\n\t\trep(i,n){\n\t\t\tpar[i] = i;\n\t\t\trank[i] = 0;\n\t\t\tsi[i] = 0;\n\t\t}\n\t}\n\n\tint find(int x){\n\t\tif(par[x] == x) return x;\n\t\telse return find(par[x]);\n\t}\n    \n    ll value(int x, ll ret){\n        if(par[x] == x) return ret+si[x];\n        else return value(par[x],ret+si[x]);\n    }\n\n\tvoid unite(int x, int y, int w){\n        ll vx = value(x,0);\n        ll vy = value(y,0);\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif(x == y) return;\n\t\t\n\t\tif(rank[x] < rank[y]){\n\t\t\tpar[x] = y;\n            si[x] = vy-si[y]-w+vx;\n\t\t} else{\n\t\t\tpar[y] = x;\n            si[y] = vx-si[x]+w-vy;\n\t\t\tif(rank[x] == rank[y]) rank[x]++;\n\t\t}\n\t}\n\n\tbool same(int x, int y){\n\t\treturn find(x) == find(y);\n\t}\n} uf;\n\nint n, m;\n\nint main(){\n    while(cin >> n >> m){\n        if(n == 0 && m == 0) break;\n        uf.init(n);\n        rep(i,m){\n            char hoge;\n            int a, b, w;\n            cin >> hoge;\n            if(hoge == '!'){\n                cin >> a >> b >> w;\n                a--; b--;\n                if(uf.same(a,b)) continue;\n                uf.unite(a,b,w);\n                //rep(j,n) cout << uf.si[j] << \" \";\n                //cout << endl;\n            } else{\n                cin >> a >> b;\n                a--; b--;\n                if(!uf.same(a,b)){\n                    cout << \"UNKNOWN\" << endl;\n                    continue;\n                }\n                int numa = uf.si[a];\n                int numb = uf.si[b];\n                while(uf.par[a] != a){\n                    a = uf.par[a];\n                    numa += uf.si[a];\n                }\n                while(uf.par[b] != b){\n                    b = uf.par[b];\n                    numb += uf.si[b];\n                }\n                //cout << numb << \" \" << numa << endl;\n                cout << numb-numa << endl;\n            }\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<stdio.h>\nusing namespace std;\nint weight[10000];\n\nclass DisjointSet{\npublic:\n  vector<int> rank,p;\n\n  DisjointSet(){}\n  DisjointSet(int size){\n    rank.resize(size,0);\n    p.resize(size,0);\n    for(int i=0;i<size;i++){\n      makeSet(i);\n      weight[i]=0;\n    }\n  }\n\n  void makeSet(int x){\n    p[x]=x;\n    rank[x]=0;\n  }\n  bool same(int x,int y){\n    return findSet(x)==findSet(y);\n  }\n  void unite(int x,int y,int w){\n    weight[x]=w;\n    link(x,y);\n  }\n  void link(int x,int y){   \n    p[x]=y;\n    if(rank[x]==rank[y]){  \n      rank[y]++;\n    }else if(rank[x]>rank[y]){\n      rank[y]=rank[x]+1;\n    }\n  }\n  int findSet(int x){\n    if(x==p[x]){\n      return x;\n    }else{\n      return findSet(p[x]);\n    }\n  }\n  int depth(int x){\n    int ans=0;\n    ans+=weight[x];\n    while(x!=p[x]){\n      ans+=weight[p[x]];\n      x=p[x];\n    }\n    return ans;\n  }\n};\nint main(){\n  int n,m;\n  while(scanf(\"%d%d\",&n,&m)){\n    if(!n&&!m){\n      break;\n    }else{\n      string query;\n      DisjointSet ds=DisjointSet(n);\n      for(int i=0;i<m;i++){\n        cin>>query;\n        if(query==\"!\"){\n          int a,b,w;\n          scanf(\"%d%d%d\",&a,&b,&w);\n          ds.unite(a,b,w);\n        }else{\n          int c,d;\n          scanf(\"%d%d\",&c,&d);\n          if(!ds.same(c,d)){\n            printf(\"UNKNOWN\\n\");\n          }else{\n            printf(\"%d\\n\",ds.depth(c)-ds.depth(d));\n          }\n        }\n      }\n    }\n  }\n  return 0;\n}\n      "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\n#include <cassert>\n#include <queue>\n#include <set>\n#include <map>\n#include <valarray>\n#include <bitset>\n#include <stack>\n#include <iomanip>\n#include <fstream>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define chmax(a,b) (a<b?(a=b,1):0)\n#define chmin(a,b) (a>b?(a=b,1):0)\n#define valid(y,x,h,w) (0<=y&&y<h&&0<=x&&x<w)\nconst int INF = 1<<29;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n\nstruct UnionFind {\n  vector<int> data;\n  vector<int> dis;\n  UnionFind(int size) : data(size, -1), dis(size,0) { }\n  bool unionSet(int x, int y, int d) {\n    int disx = dis[x];\n    int disy = dis[y];\n    x = root(x); y = root(y);\n    if (x != y) {\n      if (data[y] < data[x]) {\n        swap(x, y), d=-d;\n        swap(disx,disy);\n      }\n      data[x] += data[y]; data[y] = x;\n      dis[y] = disx + d + disy;\n    }\n    return x != y;\n  }\n  bool findSet(int x, int y) {\n    return root(x) == root(y);\n  }\n  int root(int x) {\n    if (data[x]<0) return x;\n    else {\n      dis[x] += dis[data[x]];\n      return data[x] = root(data[x]);\n    }\n    // return data[x] < 0 ? x : data[x] = root(data[x]);\n  }\n  int size(int x) {\n    return -data[root(x)];\n  }\n  int dist(int x) {\n    root(x);\n    return dis[x];\n  }\n};\n\nint main() {\n  int n,m;\n  while(cin>>n>>m,n||m) {\n    UnionFind uf(n);\n    REP(i,m) {\n      // REP(j,n) cout << uf.data[j] << \" \"; cout << endl;\n      // REP(j,n) cout << uf.dis[j] << \" \"; cout << endl;\n      char c; cin >> c;\n      if (c == '!') {\n        int a, b, d;\n        cin >> a >> b >> d;\n        a--;b--;\n        uf.unionSet(a,b,d);\n      } else {\n        int a, b;\n        cin >> a >> b;\n        a--;b--;\n        if (uf.findSet(a,b)) {\n          int d1 = uf.dist(a);\n          int d2 = uf.dist(b);\n          cout << d2-d1 << endl;\n        } else {\n          puts(\"UNKNOWN\");\n        }\n      }\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#define ll long long\nusing namespace std;\n\nstruct UnionFind{\n  vector< pair<int, ll int> > data;\n  UnionFind(int n) : data(n, pair<int,ll int>(-1,0LL)) {}\n  bool unite(int x, int y, ll int w){//weight(y)-weight(x) = w;\n    int x_ = find(x), y_ = find(y);\n    if(x_ == y_){\n      \n      return true;\n    }\n    if(data[y_].first < data[x_].first){\n      swap(x_,y_);\n      swap(x,y);\n      w *= -1LL;\n    }\n    data[x_].first += data[y_].first;//???????????´??°\n    data[y_].first = x_;//????????´??°\n    data[y_].second += w + rel_weight(x) - rel_weight(y);\n    return true;\n  }\n  bool same(int x, int y){ return find(x) == find(y); }\n  int find(int x){\n    if(data[x].first < 0) return x;\n    int p = find(data[x].first);\n    data[x].second += data[data[x].first].second;\n    data[x].first = p;\n    return data[x].first;\n  }\n  ll int rel_weight(int x){\n    return data[x].second;\n  }\n};\n\nint main(){\n  int N, M;\n  while(cin >> N >> M, N){\n    UnionFind uf(N);\n    char q;\n    int a, b;\n    ll int w;\n    for(int i = 0; i < M; ++i){\n      cin >> q >> a >> b;\n      --a;--b;\n      if(q == '!'){\n\tcin >> w;\n\tuf.unite(a,b,w);\n      }else{\n\t//cout << uf.find(a) << \" \" << uf.find(b) << endl;\n\tif(uf.same(a,b)){\n\t  cout << uf.rel_weight(b) - uf.rel_weight(a) << endl;\n\t}else{\n\t  cout << \"UNKNOWN\" << endl;\n\t}\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)n;++i)\n#define each(a, b) for(auto (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout <<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout <<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define svec(v) cout<<#v<<\":\";rep(i,v.size())cout<<\" \"<<v[i];cout<<endl\n#define sset(s) cout<<#s<<\":\";each(i,s)cout <<\" \"<<i;cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int>P;\n\nconst int MAX_N = 100005;\n\nint par[MAX_N];\nint nrank[MAX_N];\nint weight[MAX_N];\n\nvoid initial(int n){\t\t//?????????\n\tfor(int i=0;i<n;i++){\n\t\tpar[i] = i;\n\t\tnrank[i] = 0;\n        weight[i] = 0;\n\t}\n}\n\nP find(int x){\t\t//??¨??????????±???????\n\tif(par[x] == x){\n\t\treturn P(x,0);\n\t}else{\n\t\tP p = find(par[x]);\n\t\tpar[x] = p.fi;\n\t\tweight[x] = p.se + weight[x];\n\t\treturn P(par[x],weight[x]);\n\t}\n}\n\nvoid unite(int x,int y,int w){\n\tint bx = x;\n\tint by = y;\n\tx = (find(x)).fi;\n\ty = (find(y)).fi;\n\tif(x == y) return;\n\tif(nrank[x] < nrank[y]){\n\t\tpar[x] = y;\n\t\tweight[x] = -weight[bx] - w + weight[by];\n\t}else{\n\t\tpar[y] = x;\n        weight[y] = weight[bx] + w - weight[by];\n\t\tif(nrank[x] == nrank[y])\n\t\t\tnrank[x]++;\n\t}\n}\n\nbool same(int x,int y){\n\treturn (find(x)).fi == (find(y)).fi;\n}\n\nint main()\n{\n    while(1){\n        int n,m;\n        cin >> n >> m;\n        if(n == 0){\n            break;\n        }\n        initial(n+1);\n        rep(i,m){\n            int a,b,w;\n            string s;\n            cin >> s ;\n            if(s == \"!\"){\n                cin >> a >> b >> w;\n                unite(a,b,w);\n            }else{\n                cin >> a >> b;\n                if(same(a,b)){\n                    cout << weight[b] - weight[a] << \"\\n\";\n                }else{\n                    cout << \"UNKNOWN\\n\";\n                }\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <list>\n#include <set>\n#include <map>\n#include <queue>\n\nusing namespace std;\n#define DEBUG(x) cout<<#x<<\": \"<<x<<endl\n\n#define PB push_back\n#define MP make_pair\n#define F first\n#define S second\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n#define INT(a) int((a)+1e-9)\nint DX[4]={1,0,-1,0};\nint DY[4]={0,1,0,-1};\n\ntypedef pair<int,int> Pii;\n\n\n#define SUPnl 10002\n\nint nl;\nPii p[SUPnl];\t//p[n].F == n's parent, p[n].S == w[p[n].F]-w[n]\n\nvoid init(){REP(ni,nl){p[ni]=MP(-1,0);}}\n\nPii getRoot(int n){\n\tint rn=n; int w=0;\n\twhile(p[rn].F!=-1){\n\t\tw+=p[rn].S;\n\t\trn=p[rn].F;\n\t}\n\tif(rn!=n)p[n]=MP(rn,w);\n\treturn MP(rn,w);\n}\n\nvoid printW(int a, int b){\n\tPii rat=getRoot(a); Pii rbt=getRoot(b);\n\tif(rat.F!=rbt.F) cout<<\"UNKNOWN\"<<endl;\n\telse cout<< rbt.S - rat.S <<endl;\n}\n\nvoid setW(int a, int b, int w){\n\tPii rat=getRoot(a); Pii rbt=getRoot(b);\n\tif(rat.F==rbt.F) return;\n\tif(rat.S+w>=rbt.S){\n\t\tp[rbt.F]=MP(rat.F, rat.S+w-rbt.S);\n\t}else{\n\t\tp[rat.F]=MP(rbt.F, rbt.S-w-rat.S);\n\t}\n}\n\nint main(){\n\twhile(true){\n\t\tint ol;\n\t\tcin>>nl>>ol;\t\tif(!nl) return 0;\n\t\tinit();\n\t\tREP(oi,ol){\n\t\t\tchar ot; int a,b,w;\n\t\t\tcin>>ot;\n\t\t\tif(ot=='!'){\n\t\t\t\tcin>>a>>b>>w;\n\t\t\t\tsetW(a-1,b-1,w);\n\t\t\t}\n\t\t\tif(ot=='?'){\n\t\t\t\tcin>>a>>b;\n\t\t\t\tprintW(a-1,b-1);\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nstruct UnionFind{\n  vector<int> r,p,ws;\n  UnionFind(){}\n  UnionFind(int size){init(size);}\n  void init(int size){\n    r.resize(size,0);\n    p.resize(size,0);\n    ws.resize(size,0);\n    for(int i=0;i<size;i++) r[i]=1,p[i]=i;\n  }\n  int find(int x){\n    if(x==p[x]){\n      return x;\n    }else{\n      int t=find(p[x]);\n      ws[x]+=ws[t];\n      return p[x]=t;\n    }\n  }\n  int weight(int x){\n    find(x);\n    return ws[x];\n  }\n  bool same(int x,int y){\n    return find(x)==find(y);\n  }\n  void unite(int x,int y,int w){\n    w+=weight(x);\n    w-=weight(y);\n    x=find(x);y=find(y);\n    if(x==y) return;\n    if(r[x]<r[y]) swap(x,y),w=-w;\n    r[x]+=r[y];\n    p[y]=x;\n    ws[y]=w;\n  }\n  int diff(int x,int y){\n    return weight(y)-weight(x);\n  }\n};\nint main(){\n  int n,m;\n  while(cin>>n>>m,n||m){\n    UnionFind u(n);\n    for(int i=0;i<m;i++){\n      int a,b;\n      char c;\n      cin>>c>>a>>b;\n      a--;b--;\n      if(c=='!'){\n\tint w;\n\tcin>>w;\n\tu.unite(a,b,w);\n      }else{\n\tif(!u.same(a,b)) cout<<\"UNKNOWN\"<<endl;\n\telse cout<<u.diff(a,b)<<endl;\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct WeightedUnionFind\n{\n  vector< int > data, weight;\n\n  WeightedUnionFind(int sz) : data(sz, -1), weight(sz, 0) {}\n\n  void unite(int x, int y, int w)\n  {\n    auto a = find(x), b = find(y);\n    if(data[a.first] > data[b.first]) {\n      swap(a, b);\n      w *= -1;\n    }\n    x = a.first, y = b.first;\n    if(x == y) return;\n    data[x] += data[y];\n    data[y] = x;\n    weight[y] = a.second - b.second - w;\n  }\n\n  pair< int, int > find(int k)\n  {\n    if(data[k] < 0) return (make_pair(k, 0));\n    auto par = find(data[k]);\n    data[k] = par.first;\n    weight[k] = (par.second += weight[k]);\n    return (par);\n  }\n\n  void diff(int a, int b)\n  {\n    if(find(a).first != find(b).first) cout << \"UNKNOWN\" << endl;\n    else cout << weight[a] - weight[b] << endl;\n  }\n};\n\nint main()\n{\n  int N, M;\n  while(cin >> N >> M, N) {\n    WeightedUnionFind tree(N);\n    while(M--) {\n      char A;\n      int B, C, D;\n      cin >> A >> B >> C;\n      --B, --C;\n      if(A == '!') {\n        cin >> D;\n        tree.unite(B, C, D);\n      } else {\n        tree.diff(B, C);\n      }\n    }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#define mp(a, b) make_pair(a, b)\nusing namespace std;\ntypedef long long ll;\nconst int N = 110000;\nint fa[N];\nint fd(int x)\n{\n    if ( fa[x] == -1 ) return x;\n    return fa[x] = fd(fa[x]);\n}\nll w[N];\nbool ss[N];\nint a[N], b[N], od[N];\nvector<pair<int, ll> >bj[N];\nvoid dfs(int st, ll wt)\n{\n    w[st] = wt;\n    ss[st] = true;\n    vector<pair<int, ll> >::iterator pa;\n    for ( pa = bj[st].begin(); pa != bj[st].end(); pa ++ )\n    {\n        int tt = pa->first;\n        ll ad = pa->second;\n        if ( !ss[tt] ) dfs(tt, ad + wt);\n    }\n}\nint main()\n{\n    int n, m;\n    while ( cin >> n >> m )\n    {\n        if ( !n ) break;\n        for ( int i = 1; i <= n; i ++ )\n        {\n            fa[i] = -1;\n            bj[i].clear();\n            ss[i] = false;\n        }\n        for ( int i = 0; i < m; i ++ )\n        {\n            char s[5];\n            scanf(\"%s%d%d\", s, &a[i], &b[i]);\n            if ( s[0] == '!' )\n            {\n                ll c;\n                od[i] = 0;\n                scanf(\"%lld\", &c);\n                //cd[b[i]] ++;\n                bj[a[i]].push_back(mp(b[i], c));\n                bj[b[i]].push_back(mp(a[i], -c));\n            }\n            else od[i] = 1;\n        }\n        //memset(w, -1, sizeof w);\n        for ( int i = 1; i <= n; i ++ )\n        {\n            if ( !ss[i] )\n            {\n                dfs(i, 0);\n            }\n        }\n        //for ( int i = 1; i <= n; i ++ ) printf(\"%d\\n\", w[i]);\n        for ( int i = 0; i < m; i ++ )\n        {\n            if ( od[i] == 0 )\n            {\n                int sa = fd(a[i]), sb = fd(b[i]);\n                if ( sa != sb ) fa[sa] = sb;\n            } else {\n                int sa = fd(a[i]), sb = fd(b[i]);\n                if ( sa == sb ) printf(\"%lld\\n\", w[b[i]] - w[a[i]]);\n                else puts(\"UNKNOWN\");\n            }\n        }\n    }\n    return 0;\n}\n/*\n3 4\n! 1 3 5\n! 1 2 2\n? 1 2\n? 1 3\n*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define FOR(i,n,m) for(int i=(int)(n); i<=(int)(m); i++)\n#define RFOR(i,n,m) for(int i=(int)(n); i>=(int)(m); i--)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define RITR(x,c) for(__typeof(c.rbegin()) x=c.rbegin();x!=c.rend();x++)\n#define setp(n) fixed << setprecision(n)\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\n\n#define ld long double\n#define ll long long\n#define vll vector<ll>\n#define vi vector<int>\n#define pll pair<ll,ll>\n#define pi pair<int,int>\n\n#define all(a) (a.begin()),(a.end())\n#define rall(a) (a.rbegin()),(a.rend())\n#define fi first\n#define se second\n#define pb push_back\n#define mp make_pair\n#define ins insert\n\nusing namespace std;\n\n//-------------------------------------------------\n//--Union Find tree with potential\n//-------------------------------------------------\ntemplate<typename T>\nclass pUnionFind\n{\nprivate:\n    ::std::vector<int> par;\n    ::std::vector<int> rank;\n    ::std::vector<T> diff;\npublic:\n    pUnionFind(int n):par(n), rank(n), diff(n){\n        for(int i=0; i<n; i++){\n            par[i] = i;\n            rank[i] = 0;\n            diff[i] = 0;\n        }\n    }\n    int root(int x){\n        if (par[x]==x) return x;\n        int rx = root(par[x]);\n        diff[x] += diff[par[x]];\n        return par[x] = rx;\n    }\n    T weight(int x){\n        root(x);\n        return diff[x];\n    }\n    T climb(int x, int y){\n        return weight(y)-weight(x);\n    }\n    bool same(int x, int y){\n        return root(x)==root(y);\n    }\n    void unite(int x, int y, T w){\n        int rx = root(x);\n        int ry = root(y);\n        if (rx==ry) return;\n        w += weight(x)-weight(y);\n        if (rank[rx]>rank[ry]){\n            diff[ry] = w;\n            par[ry] = rx;\n        }else{\n            diff[rx] = -w;\n            par[rx] = ry;\n            if (rx==ry) rank[ry]++;\n        }\n    }\n};\n\n//-------------------------------------------------\n\nint main(void)\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n,m;\n    while(cin>>n>>m, n>0){\n        pUnionFind<int> uf(n);\n        while(m--){\n            char c; cin>>c;\n            if (c=='!'){\n                int a,b,w; cin>>a>>b>>w; a--; b--;\n                uf.unite(a,b,w);\n            }else{\n                int a,b; cin>>a>>b; a--; b--;\n                if (uf.same(a,b)){\n                    cout<<uf.climb(a,b)<<\"\\n\";\n                }else{\n                    cout<<\"UNKNOWN\\n\";\n                }\n            }\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cmath>\n#include<queue>\n\nusing namespace std;\n\nconst int INF=0x3f3f3f3f;\nconst int top=100000+100;\n\n\nint w[top];\nint father[top];\nint dis[top],vis[top],head[top];\nint n;\nstruct edge\n{\n    int u,v,cost,next;\n}e[top*2];\nint cnt;\n\nvoid AddEdge(int u,int v,int c)\n{\n    e[cnt].u=u;\n    e[cnt].v=v;\n    e[cnt].cost=c;\n    e[cnt].next=head[u];\n    head[u]=cnt++;\n}\n\nint ser(int a,int b)\n{\n    memset(vis,0,n*sizeof(int));\n    int p1,p2,i;\n    queue<int> q;\n    vis[a]=1;\n    q.push(a);\n    dis[a]=0;\n    int ans=INF;\n    while(!q.empty())\n    {\n        p1=q.front();\n        q.pop();\n        for(i=head[p1];i!=-1;i=e[i].next)\n        {\n\n            p2=e[i].v;\n            if(!vis[p2])\n            {\n                dis[p2]=dis[p1]+e[i].cost;\n                q.push(p2);\n                if(p2==b)\n                {\n                    ans=dis[p2];\n                    break;\n                }\n                vis[p2]=1;\n            }\n        }\n        if(ans!=INF)\n            break;\n    }\n    return ans;\n}\nint main()\n{\n    int m;\n    int a,b,d;\n    int i;\n    char order[2];\n    while(scanf(\"%d%d\",&n,&m)&&n+m)\n    {\n        memset(head,-1,sizeof(head));\n        cnt=0;\n        for(i=0;i<m;i++)\n        {\n            scanf(\"%s\",order);\n            if(order[0]=='!')\n            {\n                scanf(\"%d%d%d\",&a,&b,&d);\n                AddEdge(a,b,d);\n                AddEdge(b,a,-d);\n            }\n            else\n            {\n                scanf(\"%d%d\",&a,&b);\n                int ans =ser(a,b);\n                if(ans==INF)\n                    printf(\"UNKNOWN\\n\");\n                else\n                    printf(\"%d\\n\",ans);\n            }\n        }\n    }\n    return 0;\n}\n\n/*\n4 7\n! 1 2 100\n! 2 3 100\n? 2 3\n? 1 3\n! 4 3 150\n? 4 1\n0 0\n*/\n\n/*#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cmath>\n#include<queue>\n\nusing namespace std;\n\nconst int INF=0x3f3f3f3f;\nconst int top=100000+100;\n\n\nint w[top];\nint father[top];\nint dis[top],vis[top],head[top];\nint n;\nint Find(int a,int &cost)\n{\n    while(a!=father[a])\n    {\n        cost+=dis[a];\n       //printf(\"a=%d,dis[a]=%d,cost=%d\\n\",a,dis[a],cost);\n        a=father[a];\n    }\n    vis[a]=0;\n    return a;\n}\n\nvoid Merge(int _a,int _b,int _cost)\n{\n    int c1=0,c2=0;\n    int a=Find(_a,c1),b=Find(_b,c2);\n    if(a<b)\n    {\n        father[b]=a;\n        dis[b]=c1-c2+_cost;\n    }\n\n    else\n    {\n        father[a]=b;\n        dis[a]=-c1+c2-_cost;\n    }\n}\n\nint main()\n{\n    int m;\n    int a,b,d;\n    int i;\n    char order[2];\n    while(scanf(\"%d%d\",&n,&m)&&n+m)\n    {\n\n        for(i=1;i<=n;i++)\n        {\n            father[i]=i;\n        }\n        for(i=0;i<m;i++)\n        {\n            scanf(\"%s\",order);\n            if(order[0]=='!')\n            {\n                scanf(\"%d%d%d\",&a,&b,&d);\n                Merge(a,b,d);\n            }\n            else\n            {\n                scanf(\"%d%d\",&a,&b);\n                int c1=0,c2=0;\n                int fa=Find(a,c1),fb=Find(b,c2);\n                if(fa!=fb)\n                {\n                    printf(\"UNKNOWN\\n\");\n                }\n                else\n                {\n                  //  printf(\"c1=%d,c2=%d\\n\",c1,c2);\n                    printf(\"%d\\n\",c2-c1);\n                }\n            }\n        }\n    }\n    return 0;\n}\n*/\n/*\n4 7\n! 1 2 100\n! 2 3 100\n! 4 3 150\n? 1 3\n0 0\n*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define PI       3.1415926535897932384626433832795028841971\n#define INF 1000000000\n#define EPS      1e-10\n#define MOD      1000000\nusing namespace std;\ntypedef long long ll;\ntypedef pair<double,double> P;\ntypedef pair<double,P> PQ;\n\nstruct Q{\n    int time,a, b;\n};\n\nstruct edge{\n    int time, from, to, w;\n    bool operator<(const edge& right) const {\n        return time < right.time;\n    }\n    bool operator>(const edge& right) const {\n        return time > right.time;\n    }\n};\n\nint n, m;\nint bss[100000];\nint rnk[100000];\nll num[100000];\nbool saw[100000];\nvector<edge> e[100000];\nvector<Q> q;\nint up[20][100000];\nint par[20][100000];\n\nvoid dfs(int v, int bos){\n    saw[v] = true;\n    priority_queue<edge, vector<edge>,greater<edge> > que;\n    rep(i,e[v].size()) que.push(e[v][i]);\n    while(que.size() != 0){\n        edge E = que.top();\n        que.pop();\n        if(saw[E.to]) continue;\n       // cout << E.to << endl;\n        saw[E.to] = true;\n        up[0][E.to] = E.time;\n        rnk[E.to] = rnk[E.from]+1;\n        bss[E.to] = v;\n        par[0][E.to] = E.from;\n        num[E.to] = num[E.from]+E.w;\n        rep(i,e[E.to].size()){\n            que.push(e[E.to][i]);\n        }\n    }\n}\n\nint main(){\n    while(cin >> n >> m){\n        if(n == 0 && m == 0) break;\n        memset(bss,0,sizeof(bss));\n        memset(rnk,0,sizeof(rnk));\n        memset(num,0,sizeof(num));\n        memset(saw,0,sizeof(saw));\n        rep(i,100000) e[i].clear();\n        q.clear();\n        memset(up,0,sizeof(up));\n        rep(i,m){\n            char hoge;\n            int a, b, w;\n            cin >> hoge;\n            if(hoge == '!'){\n                cin >> a >> b >> w;\n                a--; b--;\n                e[a].push_back((edge){i,a,b,w});\n                e[b].push_back((edge){i,b,a,-w});\n            } else{\n                cin >> a >> b;\n                a--; b--;\n                q.push_back((Q){i,a,b});\n            }\n        }\n        rep(i,20){\n            rep(j,n) par[i][j] = j;\n        }\n        rep(i,n){\n            if(saw[i]) continue;\n            dfs(i,i);\n        }\n        for(int i = 1; i < 20; i++){\n            rep(j,n){\n                par[i][j] = par[i-1][par[i-1][j]];\n                up[i][j] = max(up[i-1][j],up[i-1][par[i-1][j]]);\n            }\n        }\n        rep(i,q.size()){\n            Q p = q[i];\n            bool done = false;\n            if(bss[p.a] != bss[p.b]){\n                cout << \"UNKNOWN\" << endl;\n                continue;\n            }\n            ll ans = num[p.b]-num[p.a];\n           // cout << rnk[p.a] << \" \" << rnk[p.b] << endl;\n            if(rnk[p.a] > rnk[p.b]){\n                int dis = rnk[p.a]-rnk[p.b];\n                int z = 0;\n                while(dis > 0){\n                    if(dis&1){\n                        if(up[z][p.a] > p.time){\n                            done = true;\n                            cout << \"UNKNOWN\" << endl;\n                            break;\n                        }\n                        p.a = par[z][p.a];\n                    }\n                    z++;\n                    dis /= 2;\n                }\n            } else if(rnk[p.a] < rnk[p.b]){\n                int dis = rnk[p.b]-rnk[p.a];\n                int z = 0;\n                while(dis > 0){\n                    if(dis&1){\n                        if(up[z][p.b] > p.time){\n                            done = true;\n                            cout << \"UNKNOWN\" << endl;\n                            break;\n                        }\n                        p.b = par[z][p.b];\n                    }\n                    z++;\n                    dis /= 2;\n                }\n            }\n            if(done) continue;\n            if(p.a == p.b){\n                cout << ans << endl;\n                continue;\n            }\n            int common = 0;\n            for(int j = 19; j >= 0; j--){\n                if(par[j][p.a] == par[j][p.b]) continue;\n                common += (1<<j);\n            }\n            common++;\n            int z = 0;\n            while(common > 0){\n                if(common&1){\n                    if(up[z][p.a] > p.time){\n                        done = true;\n                        cout << \"UNKNOWN\" << endl;\n                        break;\n                    }\n                    if(up[z][p.b] > p.time){\n                        done = true;\n                        cout << \"UNKNOWN\" << endl;\n                        break;\n                    }\n                    p.a = par[z][p.a];\n                    p.b = par[z][p.b];\n                }\n                common /= 2;\n                z++;\n            }\n            if(done) continue;\n            cout << ans << endl;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<cmath>\n#include<climits>\n#include<string>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reg(i,a,b) for(int i=(a);i<=(b);i++)\n#define irep(i,n) for(int i=((int)(n))-1;i>=0;i--)\n#define ireg(i,a,b) for(int i=(b);i>=(a);i--)\ntypedef long long int lli;\ntypedef pair<int,int> mp;\n#define fir first\n#define sec second\n#define IINF INT_MAX\n#define LINF LLONG_MAX\n\nint uni[100005];\nint find(int a){\n  if(uni[a]==a)return a;\n  return (uni[a]=find(uni[a]));\n}\nbool same(int a,int b){\n  return find(a)==find(b);\n}\nvoid merge(int a,int b){\n  uni[find(a)]=find(b);\n}\n\nlli h[100005];\nvector<mp> vs[100005];\nint gone[100005];\nvoid dfs(int no,lli d){\n    //printf(\"%d %lld\\n\",no,d);\n    h[no] = d;\n    gone[no]=1;\n    rep(i,vs[no].size()){\n        int to=vs[no][i].fir;\n        if(gone[to])continue;\n        dfs(to,d+vs[no][i].sec);\n    }\n}\n\nint main(void){\n    for(;;){\n        int m,n;\n        scanf(\"%d%d\",&n,&m);\n        if(n==0 && m==0)break;\n        typedef pair<mp,mp> mmp;\n        vector<mmp> dat;\n        memset(gone,0,sizeof(gone));\n        memset(h,0,sizeof(h));\n        rep(i,n+1)uni[i]=i;\n        rep(i,n+1)vs[i].clear();\n        rep(iii,m){\n            char cc[2];\n            scanf(\"%s \",cc);\n            int a,b,c;\n            scanf(\"%d%d\",&a,&b); a--; b--;\n            if(cc[0]=='!')scanf(\"%d\",&c);\n            else c=-1;\n            //printf(\"\\n%c %d %d %d . \\n\",cc,a,b,c);\n            dat.push_back(mmp(mp(cc[0]=='!'?1:0,a),mp(b,c)));\n            if(cc[0]=='!'){\n            vs[a].push_back(mp(b,c));\n            vs[b].push_back(mp(a,-c));\n            }\n        }\n        rep(i,n+1)if(!gone[i])dfs(i,0);\n        //puts(\"df\");\n        rep(iii,m){\n            mmp pa=dat[iii];\n           int a=pa.fir.sec,          \n               b=pa.sec.fir,\n               c=pa.sec.sec;\n           //printf(\"abc :: %d %d %d %d\\n\",pa.fir.fir,a,b,c); \n           if(pa.fir.fir==0){\n                if(same(a,b))printf(\"%lld\\n\",h[b]-h[a]);\n                else puts(\"UNKNOWN\");\n            }\n            else{\n                merge(a,b);\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#define maxlen 200010\nusing namespace std;\nint father[maxlen];\nlong long  dist[maxlen];\nint n,m;\nchar cmd;\nvoid init()\n{\n    for(int i=0; i<=n; ++i)\n    {\n        father[i]=i;\n        dist[i]=0;\n    }\n}\nint Find(int x)\n{\n    if(father[x]==x)\n        return x;\n    else\n    {\n        int root=Find(father[x]);\n        dist[x]+=dist[father[x]];\n        return father[x]=root;\n    }\n}\nint main ()\n{\n    //freopen(\"in.txt\",\"r\",stdin);\n    //freopen(\"out.txt\",\"w\",stdout);\n    int x,y;\n    long long w;\n    char cmd;\n    while(scanf(\"%d%d\",&n,&m)!=EOF)\n    {\n        if(n==0&&m==0)\n            break;\n        init();\n        for(int i=0; i<m; ++i)\n        {\n            cin>>cmd;\n            if(cmd=='!')\n            {\n                scanf(\"%d%d%lld\",&x,&y,&w);\n                x = Find(x);\n                y = Find(y);\n                if(x!=y)\n                {\n                    father[x]=y;//合并\n                    dist[x]=w-dist[x]+dist[y];\n                    //dist[y]=0;\n                }\n            }\n            else if(cmd=='?')\n            {\n                scanf(\"%d%d\",&x,&y);\n                if(Find(x)!=Find(y))\n                {\n                    printf(\"UNKNOWN\\n\");\n                    continue;\n                }\n                printf(\"%lld\\n\",dist[x]-dist[y]);\n            }\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n\nusing namespace std;\n\ntypedef long long LL;\nstruct Node {\n    int root;\n    LL diff;\n};\n\nint root(int n, vector<Node> &nodes) {\n    if(nodes[n].root == n) return n;\n    root(nodes[n].root, nodes);\n    nodes[n].diff += nodes[nodes[n].root].diff;\n    return nodes[n].root = nodes[nodes[n].root].root;\n}\n\nbool unite(int a, int b, vector<Node> &nodes, LL w) {\n    const int ra = root(a, nodes);\n    const int rb = root(b, nodes);\n    if(nodes[ra].root == nodes[rb].root) return false;\n    nodes[ra].root = nodes[rb].root;\n    nodes[ra].diff = w - nodes[a].diff;\n    return true;\n}\n\nbool solve() {\n    int N, M;\n    cin >> N >> M;\n    if(!N && !M) return false;\n\n    vector<Node> nodes(N);\n    for(int i = 0; i < N; ++i) {\n        nodes[i].root = i;\n        nodes[i].diff = 0;\n    }\n    for(int i = 0; i < M; ++i) {\n        string cmd;\n        cin >> cmd;\n        if(cmd == \"!\") {\n            int a, b, w;\n            cin >> a >> b >> w;\n            --a; --b;\n            unite(a, b, nodes, w);\n        } else {\n            int a, b;\n            cin >> a >> b;\n            --a; --b;\n            const int ra = root(a, nodes);\n            const int rb = root(b, nodes);\n            if(nodes[ra].root != nodes[rb].root) {\n                cout << \"UNKNOWN\" << endl;\n            } else {\n                const LL diff = nodes[a].diff - nodes[b].diff;\n                cout << diff << endl;\n            }\n        }\n    }\n    return true;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n\n    while(solve()) ;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\ntemplate<class Abel> struct UnionFind {\n    vector<int> par;\n    vector<int> rank;\n    vector<Abel> diff_weight;\n\n    UnionFind(int n, Abel SUM_UNITY) {\n        init(n, SUM_UNITY);\n    }\n\n    void init(int n, Abel SUM_UNITY) {\n        par.resize(n+1); rank.resize(n+1); diff_weight.resize(n+1);\n        for (int i = 0; i <= n; ++i) par[i] = i, rank[i] = 0, diff_weight[i] = SUM_UNITY;\n    }\n\n    int root(int x) {\n        if (par[x] == x) {\n            return x;\n        }\n        else {\n            int r = root(par[x]);\n            diff_weight[x] += diff_weight[par[x]];\n            return par[x] = r;\n        }\n    }\n\n    Abel weight(int x) {\n        root(x);\n        return diff_weight[x];\n    }\n\n    bool issame(int x, int y) {\n        return root(x) == root(y);\n    }\n\n    bool merge(int x, int y, Abel w) {\n        w += weight(x); w -= weight(y);\n        x = root(x); y = root(y);\n        if (x == y) return false;\n        if (rank[x] < rank[y]) swap(x, y), w = -w;\n        if (rank[x] == rank[y]) ++rank[x];\n        par[y] = x;\n        diff_weight[y] = w;\n        return true;\n    }\n\n    Abel diff(int x, int y) {\n        return weight(y) - weight(x);\n    }\n};\n\nint main(){\n    int N,M;\n    cin >> N >> M;\n    while(N>0){\n        UnionFind<int> uf(N,0);\n        char c;\n        int a,b,w;\n        int i;\n        for(i=0; i<M; i++){\n            cin >> c;\n            if(c=='!'){\n                cin >> a >> b >> w;\n                uf.merge(a,b,w);\n            }else{\n                cin >> a >> b;\n                if(uf.issame(a,b)){\n                    cout << uf.diff(a,b) << endl;\n                }else{\n                    cout << \"UNKNOWN\" << endl;\n                }\n            }\n        }\n        cin >> N >> M;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define UNKNOWN 1000000009\n\nint N, M;\n\nint par[100010];\nint unir[100010];\nint weight[100010];\n\nvoid init(int n){\n\tfor(int i = 0; i < n; i++){\n\t\tpar[i] = i;\n\t\tunir[i] = 0;\n\t\tweight[i] = 0;\n\t}\n}\n\nint find(int x){\n\tif(par[x] == x){\n\t\treturn x;\n\t}else{\n\t\tint pp = par[x];\n\t\tint np = find(par[x]);\n\t\tweight[x] = weight[x] + weight[pp];\n\t\tpar[x] = np;\n\t\treturn np;\n\t}\n}\n\nint calcw(int x){\n\tfind(x);\n\tif(par[x] == x){\n\t\treturn 0;\n\t}else{\n\t\treturn weight[x];\n\t}\n}\n\nint calcw(int x, int y){\n\tif(find(x) != find(y)){\n\t\treturn UNKNOWN;\n\t}\n\treturn calcw(y) - calcw(x);\n}\n\nvoid unite(int x, int y, int w){\n\tint px = find(x);\n\tint py = find(y);\n\tif(px == py){\n\t\treturn;\n\t}\n\tint nw = calcw(x) - calcw(y) + w;\n\tif(unir[px] < unir[py]){\n\t\tswap(px, py);\n\t\tnw = -nw;\n\t}\n\tpar[py] = px;\n\tweight[py] = nw;\n\tif(unir[px] == unir[py]) unir[px]++;\n}\n\nbool same(int x, int y){\n\treturn find(x) == find(y);\n}\n\nvoid outtree(){\n\tcout << \"-----\" << endl;\n\tfor(int i = 0; i <= N; i++){\n\t\tcout << par[i] << \" \" ;\n\t}\n\tcout << endl;\n\tfor(int i = 0; i <= N; i++){\n\t\tcout << weight[i] << \" \" ;\n\t}\n\tcout << endl;\n\tfor(int i = 0; i <= N; i++){\n\t\tcout << unir[i] << \" \" ;\n\t}\n\tcout << endl;\n}\t\n\n\nint main(){\n\twhile(cin >> N >> M, N){\n\t\tinit(N + 1);\n\t\tfor(int i = 0; i < M; i++){\n\t//\t\touttree();\n\t\t\tchar c;\n\t\t\tint a, b, w;\n\t\t\tcin >> c;\n\t\t\tif(c == '!'){\n\t\t\t\tcin >> a >> b >> w;\n\t\t\t\tunite(a, b, w);\n\t\t\t}else{\n\t\t\t\tcin >> a >> b;\n\t\t\t\tint ret = calcw(a, b);\n\t\t\t\tif(ret == UNKNOWN){\n\t\t\t\t\tcout << \"UNKNOWN\" << endl;\n\t\t\t\t}else{\n\t\t\t\t\tcout << ret << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nstruct Weighted_Union_Find {\n    std::vector<int> par;\n    std::vector<int> rank;\n    std::vector<long long> wdiff;\n    //初期化\n    void init( int n ) {\n        par.resize( n );\n        rank.resize( n );\n        wdiff.resize( n );\n        for ( int i = 0; i < n; ++i ) {\n            par[ i ] = i;\n            rank[ i ] = 0;\n            wdiff[ i ] = 0;\n        }\n    }\n    \n    //木の根を探す\n    int find( int s ) {\n        if ( par[ s ] == s ) {\n            return s;\n        }\n        int r = find(par[ s ]);\n        wdiff[s] += wdiff[par[s]];\n        return par[s] = r;\n    }\n    \n    long long weight(int x) {\n        find(x); // 経路圧縮\n        return wdiff[x];\n    }\n\n    long long diff(int x, int y) {\n        return weight(y) - weight(x);\n    }\n\n    //結合\n    bool unite( int x, int y, long long w ) {\n        w += weight(x);\n        w -= weight(y);\n        x = find( x );\n        y = find( y );\n        if ( x == y ) {\n            return false;\n        }\n        if ( rank[ x ] < rank[ y ] ) {\n            std::swap(x, y);\n            w = -w;\n        }\n        if ( rank[x] == rank[y] ) ++rank[x];\n        par[y] = x;\n        wdiff[y] = w;\n        return true;\n    }\n    \n    //二つの数の根が同じかどうか\n    bool same( int x, int y ) {\n        return find( x ) == find( y );\n    }\n    \n    //サイズを返す\n    unsigned int size() {\n        return par.size();\n    }\n};\n\nusing namespace std;\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    int n, q;\n    Weighted_Union_Find wuf;\n    while(cin >> n >> q && n && q){\n        wuf.init(n);\n        while(q--){\n            char query;\n            cin >> query;\n            if(query == '!'){\n                int a, b, w;\n                cin >> a >> b >> w;\n                wuf.unite(a - 1, b - 1, w);\n            }else{\n                int a, b;\n                cin >> a >> b;\n                if(wuf.same(a - 1, b - 1)){\n                    cout << wuf.diff(a - 1, b - 1) << \"\\n\";\n                }else{\n                    cout << \"UNKNOWN\\n\";\n                }\n            }\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define f first\n#define s second\n#define mp make_pair\n#define inf 1<<30\n#define MAX 1000010\nusing namespace std;\n\nlong long p[MAX],w[MAX];\n\npair<int,int> find(int a){\n  if(p[a]==a)return mp(a,0);\n  pair<int,int> pii=find(p[a]);\n  pii.s+=w[a];\n  p[a]=pii.f;\n  w[a]=pii.s;\n  return pii;\n}\n\nvoid unit(int a,int b,int d){\n  pair<int,int> pa=find(a),pb=find(b);\n  if(pa.f==pb.f)return;\n  p[pa.f]=b;\n  w[pa.f]=d-w[a];\n}\n\nint main()\n{\n  int n,q,a,b,d;\n  char c;\n\n  while(cin>>n>>q && n ){\n\n    for(int i=0;i<n;i++){\n      p[i]=i;\n      w[i]=0;\n    }\n\n    for(int i=0;i<q;i++){\n      cin>>c;\n      if(c=='!'){\n\tcin>>a>>b>>d;\n\ta--;b--;\n        unit(a,b,d);\n      }\n      else {\n\tcin>>a>>b;\n\ta--;b--;\n\tpair<int,int> pa=find(a),pb=find(b);\n\tif(pa.f!=pb.f)cout<<\"UNKNOWM\"<<endl;\n\telse cout<<pa.s-pb.s<<endl;\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int M = 1000000007;\n\nvector<int> grp;\nvector<long long> val;\nvector<vector<int>> lis;\nvoid init(int n) {\n    grp.resize(n);\n    val.resize(n, 0);\n    lis.resize(n, vector<int>(1));\n    for (int i = 0; i < n; ++i) {\n        grp[i] = i;\n        lis[i][0] = i;\n    }\n}\nvoid merge(int p, int q, long long w) {\n    if (grp[p] == grp[q]) return;\n    if (lis[grp[p]].size() < lis[grp[q]].size()) {\n        merge(q, p, -w);\n        return;\n    }\n    long long d = w + val[p] - val[q];\n    int g = grp[q];\n    for (int i : lis[g]) {\n        grp[i] = grp[p];\n        val[i] += d;\n        lis[grp[p]].emplace_back(i);\n    }\n    lis[g].clear();\n}\n\nint main() {\n    while (1) {\n        int n, m;\n        cin >> n >> m;\n        if (!n) return 0;\n        init(n);\n        for (int i = 0; i < m; ++i) {\n            char c;\n            cin >> c;\n            if (c == '!') {\n                int p, q, w;\n                cin >> p >> q >> w;\n                merge(p - 1, q - 1, w);\n            }\n            else {\n                int p, q;\n                cin >> p >> q;\n                --p;\n                --q;\n                if (grp[p] != grp[q])\n                    puts(\"UNKNOWN\");\n                else\n                    printf(\"%lld\\n\", val[q] - val[p]);\n            }\n        }\n        for (int i = 0; i < n; ++i)\n            lis[i].clear();\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <array>\n#include <bitset>\n#include <cassert>\n#include <cfloat>\n#include <cmath>\n#include <cstdint>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <forward_list>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <regex>\n#include <set>\n#include <stack>\n#include <string>\n#include <tuple>\n#include <type_traits>\n#include <unordered_map>\n#include <unordered_set>\n#include <utility>\n#include <vector>\n#ifdef DEBUG\n#include <fmt/format.h>\n#include <fmt/ostream.h>\n#endif\nusing namespace std;\nusing i8 = int8_t;\nusing u8 = uint8_t;\nusing i16 = int16_t;\nusing u16 = uint16_t;\nusing i32 = int32_t;\nusing u32 = uint32_t;\nusing i64 = int64_t;\nusing u64 = uint64_t;\ntemplate<typename T>\nusing max_heap = priority_queue<T, vector<T>, less<T>>;\ntemplate<typename T>\nusing min_heap = priority_queue<T, vector<T>, greater<T>>;\n#ifdef __clang__\n#pragma clang diagnostic push\n#pragma clang diagnostic ignored \"-Wunused-const-variable\"\n#endif\nconstexpr bool AUTOFLUSH = false;\nconstexpr bool STDIO_ENABLE = false;\nconstexpr int IOS_PREC = 12;\nconstexpr int INF_I32 = 1'010'000'000;\nconstexpr i64 INF_I64 = 1'010'000'000'000'000'000LL;\nconstexpr auto INF = INF_I64;\nconstexpr double EPS = 1e-12;\nconstexpr i64 MOD = 1'000'000'007;\n#ifdef __clang__\n#pragma clang diagnostic pop\n#endif\nconstexpr i32 I32_MAX = numeric_limits<i32>::max();\nconstexpr i32 I32_MIN = numeric_limits<i32>::min();\nconstexpr i64 I64_MAX = numeric_limits<i64>::max();\nconstexpr i64 I64_MIN = numeric_limits<i64>::min();\ntemplate<typename T, size_t N, size_t... NS>\nstruct ArrayStruct {\n using type = array<typename ArrayStruct<T,NS...>::type,N>;\n};\ntemplate<typename T, size_t N>\nstruct ArrayStruct<T,N> {\n using type = array<T,N>;\n};\ntemplate<typename T, size_t N, size_t... NS>\nusing Array = typename ArrayStruct<T,N,NS...>::type;\ntemplate<typename T>\nint GETBIT(T x, int i) {\n return (x>>i) & 1;\n}\ntemplate<typename T>\nvoid SETBIT(T& x, int i) {\n x |= (T(1)<<i);\n}\ntemplate<typename T>\nvoid CLEARBIT(T& x, int i) {\n x &= ~(T(1)<<i);\n}\ntemplate<typename T>\nconstexpr T ABS(T x) {\n static_assert(is_signed<T>::value, \"ABS(): argument must be signed\");\n return x < 0 ? -x : x;\n}\ntemplate<typename T>\nconstexpr T abs_diff(T x, T y) {\n return x < y ? y-x : x-y;\n}\nconstexpr i64 MID(i64 x, i64 y) {\n i64 lo = min(x, y);\n i64 hi = max(x, y);\n return (lo < 0 && hi >= 0) ? (lo+hi)/2 : lo + (hi-lo)/2;\n}\ntemplate<typename Pred>\ni64 bin_search(i64 lo, i64 hi, Pred pred) {\n assert(lo < hi);\n while(lo+1 < hi) {\n i64 mid = MID(lo, hi);\n if(pred(mid))\n lo = mid;\n else\n hi = mid;\n }\n return lo;\n}\ntemplate<typename Pred>\ndouble bin_search_real(double lo, double hi, Pred pred, int iter=100) {\n assert(lo < hi);\n for(int i = 0; i < iter; ++i) {\n double mid = (lo+hi) / 2.0;\n if(pred(mid))\n lo = mid;\n else\n hi = mid;\n }\n return lo;\n}\ntemplate<typename T>\nconstexpr bool is_odd(T x) {\n return x % 2 != 0;\n}\ntemplate<typename T>\nconstexpr bool is_even(T x) {\n return x % 2 == 0;\n}\ntemplate<typename T>\nconstexpr bool parity_same(T x, T y) {\n return (is_odd(x) && is_odd(y)) || (is_even(x) && is_even(y));\n}\ntemplate<typename T>\nconstexpr int cmp(T x, T y) {\n return (y < x) - (x < y);\n}\ntemplate<typename T>\nconstexpr int sgn(T x) {\n return cmp(x, T(0));\n}\ntemplate<typename T>\nconstexpr T ipow(T a, T b) {\n assert(b >= 0);\n T res(1);\n for(T i = 0; i < b; ++i)\n res *= a;\n return res;\n}\ntemplate<\n typename T,\n std::enable_if_t<\n std::is_integral<T>::value &&\n std::is_signed<T>::value, std::nullptr_t> = nullptr>\nconstexpr T div_ceil(T a, T b) {\n return a/b + (((a<0)^(b>0)) && (a%b));\n}\ntemplate<\n typename T,\n std::enable_if_t<\n std::is_integral<T>::value &&\n std::is_unsigned<T>::value, std::nullptr_t> = nullptr>\nconstexpr T div_ceil(T a, T b) {\n return a/b + !!(a%b);\n}\ntemplate<\n typename T,\n std::enable_if_t<\n std::is_integral<T>::value &&\n std::is_signed<T>::value, std::nullptr_t> = nullptr>\nconstexpr T div_floor(T a, T b) {\n return a/b - (((a>0)^(b>0)) && (a%b));\n}\ntemplate<\n typename T,\n std::enable_if_t<\n std::is_integral<T>::value &&\n std::is_unsigned<T>::value, std::nullptr_t> = nullptr>\nconstexpr T div_floor(T a, T b) {\n return a/b;\n}\ntemplate<typename T, typename U>\nconstexpr auto modulo(T a, U b) {\n using R = common_type_t<T,U>;\n assert(0 < b);\n R r = a % b;\n return r >= 0 ? r : r+b;\n}\ntemplate<typename T>\nconstexpr T clamp(T x, T lo, T hi) {\n assert(lo <= hi);\n if(x < lo)\n return lo;\n else if(hi < x)\n return hi;\n else\n return x;\n}\ni64 isqrt(i64 x) {\n assert(x >= 0);\n i64 lo = 0;\n i64 hi = 3037000500LL;\n return bin_search(lo, hi, [x](i64 r) { return r*r <= x; });\n}\ntemplate<typename T, typename U>\nbool chmax(T& xmax, const U& x) {\n if(xmax < x) {\n xmax = x;\n return true;\n }\n else {\n return false;\n }\n}\ntemplate<typename T, typename U>\nbool chmin(T& xmin, const U& x) {\n if(x < xmin) {\n xmin = x;\n return true;\n }\n else {\n return false;\n }\n}\ntemplate<typename T>\nconstexpr int SIZE(const T& c) {\n return static_cast<int>(c.size());\n}\ntemplate<typename T, size_t N>\nconstexpr int SIZE(const T (&)[N]) {\n return static_cast<int>(N);\n}\ntemplate<typename InputIt, typename T>\nint argfind(InputIt first, InputIt last, const T& x) {\n auto it = find(first, last, x);\n return distance(first, it);\n}\ntemplate<typename InputIt>\nint argmax(InputIt first, InputIt last) {\n auto it = max_element(first, last);\n return distance(first, it);\n}\ntemplate<typename InputIt>\nint argmin(InputIt first, InputIt last) {\n auto it = min_element(first, last);\n return distance(first, it);\n}\ntemplate<typename InputIt>\nbool alltrue(InputIt first, InputIt last) {\n return all_of(first, last, [](bool b) { return b; });\n}\ntemplate<typename InputIt>\nbool anytrue(InputIt first, InputIt last) {\n return any_of(first, last, [](bool b) { return b; });\n}\ntemplate<typename InputIt>\nbool allfalse(InputIt first, InputIt last) {\n return !anytrue(first, last);\n}\ntemplate<typename InputIt>\nbool anyfalse(InputIt first, InputIt last) {\n return !alltrue(first, last);\n}\ntemplate<typename T>\narray<pair<T,T>,4> neighbor4(const T& x, const T& y) {\n return array<pair<T,T>,4> {{\n { x, y-1 },\n { x-1, y }, { x+1, y },\n { x, y+1 },\n }};\n}\ntemplate<typename T>\narray<pair<T,T>,8> neighbor8(const T& x, const T& y) {\n return array<pair<T,T>,8> {{\n { x-1, y-1 }, { x, y-1 }, { x+1, y-1 },\n { x-1, y }, { x+1, y },\n { x-1, y+1 }, { x, y+1 }, { x+1, y+1 },\n }};\n}\ntemplate<typename T>\nbool in_bounds(const T& x, const T& minx, const T& maxx) {\n return !(x < minx) && !(maxx < x);\n}\ntemplate<typename T>\nbool in_bounds_2(\n const T& x, const T& y,\n const T& minx, const T& miny,\n const T& maxx, const T& maxy) {\n return in_bounds(x, minx, maxx) && in_bounds(y, miny, maxy);\n}\ntemplate<typename T>\nbool in_bounds_wh(const T& x, const T& y, const T& w, const T& h) {\n return in_bounds_2(x, y, 0, 0, w-1, h-1);\n}\nstruct pairhash {\n template<typename T1, typename T2>\n size_t operator()(const pair<T1,T2>& p) const {\n size_t res = 17;\n res = 31*res + hash<T1>()(p.first);\n res = 31*res + hash<T2>()(p.second);\n return res;\n }\n};\nstruct vectorhash {\n template<typename T>\n size_t operator()(const vector<T>& v) const {\n size_t res = 17;\n res = 31*res + hash<size_t>()(v.size());\n for(const auto& e : v) {\n res = 31*res + hash<T>()(e);\n }\n return res;\n }\n};\ntemplate<typename K, typename V>\npair<typename map<K,V>::iterator, bool> insert_or_assign(map<K,V>& m, const K& k, const V& v) {\n auto it = m.lower_bound(k);\n if(it != end(m) && !m.key_comp()(k,it->first)) {\n it->second = v;\n return make_pair(it, false);\n }\n else {\n auto it_ins = m.insert(it, make_pair(k,v));\n return make_pair(it_ins, true);\n }\n}\ntemplate<typename K, typename V>\npair<typename unordered_map<K,V>::iterator, bool>\ninsert_or_assign(unordered_map<K,V>& m, const K& k, const V& v) {\n auto it = m.find(k);\n if(it != end(m)) {\n it->second = v;\n return make_pair(it, false);\n }\n else {\n auto it_ins = m.insert(it, make_pair(k,v));\n return make_pair(it_ins, true);\n }\n}\ntemplate<typename T>\nstring TO_STRING(const T& x) {\n ostringstream out;\n out << x;\n return out.str();\n}\ntemplate<typename InputIt>\nstring JOIN(InputIt first, InputIt last, const string& sep) {\n ostringstream out;\n while(first != last) {\n out << *first++;\n if(first != last)\n out << sep;\n }\n return out.str();\n}\ntemplate<typename InputIt>\nauto SUM(InputIt first, InputIt last) {\n using T = typename iterator_traits<InputIt>::value_type;\n return accumulate(first, last, T());\n}\ntemplate<typename T>\nvoid UNIQ(T& c) {\n c.erase(unique(begin(c), end(c)), end(c));\n}\ntemplate<typename T>\nvoid RD(T& x) {\n cin >> x;\n#ifdef DEBUG\n if(!cin) assert(false);\n#endif\n}\ntemplate<typename T>\nvoid RD(vector<T>& v, int n) {\n v.reserve(n);\n for(int i = 0; i < n; ++i) {\n T e; RD(e);\n v.emplace_back(e);\n }\n}\ntemplate<typename InputIt>\nostream& FPRINTSEQ(ostream& out, InputIt first, InputIt last) {\n for(InputIt it = first; it != last; ++it) {\n if(it != first) out << ' ';\n out << *it;\n }\n return out;\n}\ntemplate<typename InputIt>\nostream& PRINTSEQ(InputIt first, InputIt last) {\n return FPRINTSEQ(cout, first, last);\n}\ntemplate<typename InputIt>\nostream& DPRINTSEQ(InputIt first, InputIt last) {\n#ifdef DEBUG\n FPRINTSEQ(cerr, first, last);\n#endif\n return cerr;\n}\ntemplate<typename T, size_t N>\nostream& FPRINTARRAY1(ostream& out, const T (&c)[N]) {\n return FPRINTSEQ(out, cbegin(c), cend(c));\n}\ntemplate<typename T, size_t N>\nostream& PRINTARRAY1(const T (&c)[N]) {\n return FPRINTARRAY1(cout, c);\n}\ntemplate<typename T, size_t N>\nostream& DPRINTARRAY1(const T (&c)[N]) {\n#ifdef DEBUG\n FPRINTARRAY1(cerr, c);\n#endif\n return cerr;\n}\ntemplate<typename T, size_t N1, size_t N2>\nostream& FPRINTARRAY2(ostream& out, const T (&c)[N1][N2]) {\n out << '\\n';\n for(const auto& e : c) {\n FPRINTARRAY1(out, e) << '\\n';\n }\n return out;\n}\ntemplate<typename T, size_t N1, size_t N2>\nostream& PRINTARRAY2(const T (&c)[N1][N2]) {\n return FPRINTARRAY2(cout, c);\n}\ntemplate<typename T, size_t N1, size_t N2>\nostream& DPRINTARRAY2(const T (&c)[N1][N2]) {\n#ifdef DEBUG\n FPRINTARRAY2(cerr, c);\n#endif\n return cerr;\n}\ntemplate<typename T>\nostream& operator<<(ostream& out, const vector<T>& c) {\n return FPRINTSEQ(out, cbegin(c), cend(c));\n}\ntemplate<typename T>\nostream& operator<<(ostream& out, const vector<vector<T>>& c) {\n out << '\\n';\n for(const auto& e : c) {\n out << e << '\\n';\n }\n return out;\n}\nostream& operator<<(ostream& out, const vector<string>& c) {\n out << '\\n';\n for(const string& e : c) {\n out << e << '\\n';\n }\n return out;\n}\ntemplate<typename T>\nostream& operator<<(ostream& out, const deque<T>& c) {\n return FPRINTSEQ(out, cbegin(c), cend(c));\n}\ntemplate<typename T>\nostream& operator<<(ostream& out, const list<T>& c) {\n return FPRINTSEQ(out, cbegin(c), cend(c));\n}\ntemplate<typename T>\nostream& operator<<(ostream& out, const forward_list<T>& c) {\n return FPRINTSEQ(out, cbegin(c), cend(c));\n}\ntemplate<typename T>\nostream& operator<<(ostream& out, const set<T>& c) {\n return FPRINTSEQ(out, cbegin(c), cend(c));\n}\ntemplate<typename T>\nostream& operator<<(ostream& out, const unordered_set<T>& c) {\n return out << set<T>(cbegin(c), cend(c));\n}\ntemplate<typename T>\nostream& operator<<(ostream& out, const multiset<T>& c) {\n return FPRINTSEQ(out, cbegin(c), cend(c));\n}\ntemplate<typename T>\nostream& operator<<(ostream& out, const unordered_multiset<T>& c) {\n return out << multiset<T>(cbegin(c), cend(c));\n}\ntemplate<typename T, size_t N>\nostream& operator<<(ostream& out, const array<T,N>& c) {\n return FPRINTSEQ(out, cbegin(c), cend(c));\n}\ntemplate<typename InputIt>\nostream& FPRINTMAP(ostream& out, InputIt first, InputIt last) {\n out << \"{\\n\";\n for(auto it = first; it != last; ++it) {\n out << \"  \" << it->first << \" : \" << it->second << '\\n';\n }\n out << \"}\\n\";\n return out;\n}\ntemplate<typename InputIt>\nostream& PRINTMAP(InputIt first, InputIt last) {\n return FPRINTMAP(cout, first, last);\n}\ntemplate<typename InputIt>\nostream& DPRINTMAP(InputIt first, InputIt last) {\n#ifdef DEBUG\n FPRINTMAP(cerr, first, last);\n#endif\n return cerr;\n}\ntemplate<typename K, typename V>\nostream& operator<<(ostream& out, const map<K,V>& c) {\n return FPRINTMAP(out, cbegin(c), cend(c));\n}\ntemplate<typename K, typename V>\nostream& operator<<(ostream& out, const unordered_map<K,V>& c) {\n return out << map<K,V>(cbegin(c), cend(c));\n}\ntemplate<typename K, typename V>\nostream& operator<<(ostream& out, const multimap<K,V>& c) {\n return FPRINTMAP(out, cbegin(c), cend(c));\n}\ntemplate<typename K, typename V>\nostream& operator<<(ostream& out, const unordered_multimap<K,V>& c) {\n return out << multimap<K,V>(cbegin(c), cend(c));\n}\ntemplate<typename T, typename C>\nostream& operator<<(ostream& out, stack<T,C> c) {\n while(!c.empty()) {\n out << c.top();\n c.pop();\n if(!c.empty()) out << ' ';\n }\n return out;\n}\ntemplate<typename T, typename C>\nostream& operator<<(ostream& out, queue<T,C> c) {\n while(!c.empty()) {\n out << c.front();\n c.pop();\n if(!c.empty()) out << ' ';\n }\n return out;\n}\ntemplate<typename T, typename Cont, typename Cmp>\nostream& operator<<(ostream& out, priority_queue<T,Cont,Cmp> c) {\n while(!c.empty()) {\n out << c.top();\n c.pop();\n if(!c.empty()) out << ' ';\n }\n return out;\n}\ntemplate<typename T1, typename T2>\nostream& operator<<(ostream& out, const pair<T1,T2>& p) {\n return out << '(' << p.first << ',' << p.second << ')';\n}\ntemplate<typename Tuple, size_t Pos>\nostream& FPRINTTUPLE(ostream& out, const Tuple&) {\n return out;\n}\ntemplate<typename Tuple, size_t Pos, typename T, typename... TS>\nostream& FPRINTTUPLE(ostream& out, const Tuple& t) {\n if(Pos != 0)\n out << ',';\n out << get<Pos>(t);\n return FPRINTTUPLE<Tuple,Pos+1,TS...>(out, t);\n}\ntemplate<typename... TS>\nostream& operator<<(ostream& out, const tuple<TS...>& t) {\n out << '(';\n FPRINTTUPLE<tuple<TS...>,0,TS...>(out, t);\n out << ')';\n return out;\n}\nostream& FPRINT(ostream& out) { return out; }\ntemplate<typename T, typename... TS>\nostream& FPRINT(ostream& out, const T& x, const TS& ...args) {\n out << x;\n if(sizeof...(args))\n out << ' ';\n return FPRINT(out, args...);\n}\ntemplate<typename... TS>\nostream& FPRINTLN(ostream& out, const TS& ...args) {\n FPRINT(out, args...);\n return out << '\\n';\n}\ntemplate<typename... TS>\nostream& PRINT(const TS& ...args) {\n return FPRINT(cout, args...);\n}\ntemplate<typename... TS>\nostream& PRINTLN(const TS& ...args) {\n return FPRINTLN(cout, args...);\n}\ntemplate<typename... TS>\nostream& DPRINT(const TS& ...args) {\n#ifdef DEBUG\n FPRINT(cerr, args...);\n#endif\n return cerr;\n}\ntemplate<typename... TS>\nostream& DPRINTLN(const TS& ...args) {\n#ifdef DEBUG\n FPRINTLN(cerr, args...);\n#endif\n return cerr;\n}\nvoid FLUSH() {\n if(STDIO_ENABLE)\n fflush(stdout);\n else\n cout.flush();\n}\n[[noreturn]] void EXIT() {\n#ifdef DEBUG\n fflush(stdout);\n fflush(stderr);\n cout.flush();\n cerr.flush();\n#else\n FLUSH();\n#endif\n _Exit(0);\n}\nstruct IoInit {\n IoInit() {\n#ifndef DEBUG\n cin.tie(nullptr);\n if(!STDIO_ENABLE)\n ios::sync_with_stdio(false);\n#endif\n cout << fixed << setprecision(IOS_PREC);\n if(AUTOFLUSH) {\n if(STDIO_ENABLE)\n setvbuf(stdout, nullptr, _IONBF, 0);\n cout << unitbuf;\n }\n }\n} IOINIT;\n#define FOR(i,start,end) for(i64 i = (start); i < (end); ++i)\n#define REP(i,n) FOR(i, 0, n)\n#define ALL(f,c,...) (([&](decltype((c)) cc) { return (f)(begin(cc), end(cc), ## __VA_ARGS__); })(c))\n#define GENERIC(f) ([](auto&&... args) -> decltype(auto) { return (f)(forward<decltype(args)>(args)...); })\n#define MEMSET(a,v) memset((a), (v), sizeof(a))\n#define DBG(x) DPRINTLN('L', __LINE__, ':', #x, ':', (x))\nclass WeightedUnionFind {\npublic:\n vector<i64> p;\n vector<i64> w;\n i64 n_set;\n WeightedUnionFind(i64 n) : p(n, -1), w(n, 0), n_set(n) {}\n i64 node_count() const { return SIZE(p); }\n i64 set_count() const { return n_set; }\n i64 set_size(i64 x) { return -p[root(x)]; }\n bool is_root(i64 x) const { return p[x] < 0; }\n i64 root(i64 x) {\n i64 res; tie(res,ignore) = compress(x);\n return res;\n }\n i64 weight(i64 x) {\n i64 res; tie(ignore,res) = compress(x);\n return res;\n }\n bool unite(i64 x, i64 y, i64 d) {\n i64 rx = root(x);\n i64 ry = root(y);\n i64 wx = weight(x);\n i64 wy = weight(y);\n if(rx == ry) {\n return wx + d == wy;\n }\n if(set_size(rx) < set_size(ry)) {\n swap(rx, ry);\n swap(wx, wy);\n d *= -1;\n }\n p[rx] += p[ry];\n p[ry] = rx;\n w[ry] = wx - wy + d;\n return true;\n }\n bool same(i64 x, i64 y) {\n return root(x) == root(y);\n }\nprivate:\n tuple<i64,i64> compress(i64 x) {\n if(is_root(x)) return make_tuple(x, 0);\n i64 r,d; tie(r,d) = compress(p[x]);\n p[x] = r;\n w[x] += d;\n return make_tuple(r, w[x]);\n }\n};\nvoid solve(i64 N, i64 M) {\n WeightedUnionFind uf(N);\n REP(_, M) {\n char c; RD(c);\n i64 a,b; RD(a); RD(b); --a; --b;\n if(c == '!') {\n i64 w; RD(w);\n if(!uf.unite(a, b, w)) {\n assert(false);\n }\n }\n else if(c == '?') {\n if(!uf.same(a, b)) {\n PRINTLN(\"UNKNOWN\");\n }\n else {\n i64 ans = uf.weight(b) - uf.weight(a);\n PRINTLN(ans);\n }\n }\n else {\n assert(false);\n }\n }\n}\nsigned main(signed , char** ) {\n while(true) {\n i64 N, M; RD(N); RD(M);\n if(N == 0 && M == 0) break;\n solve(N, M);\n }\n EXIT();\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// g++ -std=c++11 a.cpp\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<random>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#include<typeinfo>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\n//#define int ll\ntypedef ll Def;\n//typedef ll Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n#define mt make_tuple\ntypedef tuple<int,int,int> tp;\ntypedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\n//template<class C>constexpr int size(const C &c){return (int)c.size();}\n//template<class T,size_t N> constexpr int size(const T (&xs)[N])noexcept{return (int)N;}\nconst double PI=acos(-1);\nconst double EPS=1e-7;\nDef inf = sizeof(Def) == sizeof(long long) ? 2e18 : 1e9+10;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\nstruct UnionFind{\n  vector<int> parent;\n  vector< ll > dist;\n  UnionFind(int x=1){\n    parent.clear();\n    parent.resize(x,-1);\n    dist.clear();\n    dist.resize(x,0);\n  }\n  int find(int x){\n    if(parent[x]<0)return x;\n    int r=find(parent[x]);\n    dist[x]+=dist[ parent[x] ];\n    return parent[x]=r;    \n  }\n  ll depth(int x){\n    find(x);\n    return dist[x];\n  }\n  bool same(int x,int y){\n    return (find(x)==find(y));\n  }\n  int size(int x){\n    return -parent[find(x)];\n  }\n  void unite(int x,int y,ll k=0){\n    k+=depth(y);\n    k-=depth(x);\n    k*=-1;\n    x=find(x);\n    y=find(y);\n    if(x==y)return;\n    if(size(x)<size(y)){\n      swap(x,y);\n      k*=-1;\n    }\n    parent[x]+=parent[y];\n    parent[y]=x;\n    dist[y]=k;\n  }\n};\nint main(){\n  int n,q;\n  while(cin>>n>>q,n){\n\t  UnionFind T(n);\n\t  for(int i=0;i<q;i++){\n\t\tchar type;\n\t\tint x,y;\n\t\tcin>>type>>x>>y;\n\t\tx--;y--;\n\t\tif(type=='!'){\n\t\t  int a;\n\t\t  scanf(\"%d\",&a);\n\t\t  T.unite(x,y,a);\n\t\t}else{\n\t\t  if(!T.same(x,y)){\n\t\t\tprintf(\"UNKNOWN\\n\");\n\t\t  }else{\n\t\t\tprintf(\"%lld\\n\",T.depth(x)-T.depth(y));\n\t\t  }\n\t\t}\n\t  }\n  }\n  return 0;\n}\n\n/*\nint n;\nvi in;\nint dp[310][310];\nint f(int l,int r){\n\tif(dp[l][r]+inf)return dp[l][r];\n\tif(r-l<2)return dp[l][r]=0;\n\tint out=-inf;\n\tloop(i,l,r-1)if(abs(in[i]-in[i+1])<2){\n\t\tout=max(out,f(l,i)+2+f(i+2,r));\n\t}\n\tint t=f(l+1,r-1);\n\tif(t==r-l-2){\n\t\tif(abs(in[l]-in[r-1])<2)out=max(out,r-l);\n\t}\n\tout=max(out,f(l+1,r));\n\tout=max(out,f(l,r-1));\n//\tcout<<l<<\" \"<<r<<\" \"<<out<<endl;\n\treturn dp[l][r]=out;\n}\nint main(){\n\twhile(cin>>n,n){\n\t\tin=vi(n);\n\t\trep(i,n)cin>>in[i];\n\t\trep(i,310)rep(j,310)dp[i][j]=-inf;\n\t\tcout<<f(0,n)<<endl;;\n\t}\n}\n*/\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Benri { Benri() { std::cin.tie(0); ios::sync_with_stdio(false); cout << fixed << setprecision(12);}} benri;\n\nusing ll = long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing pii = pair<int, int>;\nusing vll = vector<long long>;\nusing pll = pair<ll, ll>;\nusing ull = unsigned long long;\n\ntemplate <typename T> using PQ = priority_queue<T>;\ntemplate <typename T> using minPQ = priority_queue<T, vector<T>, greater<T>>;\n\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define mp make_pair\n#define F first\n#define S second\n\ntemplate<class T>bool chmax(T &a, const T &b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b < a) { a = b; return 1; } return 0; }\n\nconstexpr long long MOD = 1000000007;\n//constexpr long long MOD = 998244353;\nconstexpr double EPS = 1e-10;\nconstexpr int INF = 1001001001;\n//constexpr ll INF = 1001001001001001001ll;\n\n\ntemplate<class Abel> struct WUF {\n    vector<int> par, rank;\n    vector<Abel> diff_weight;\n\n    WUF(int n, Abel SUM_UNITY = 0) {\n        init(n, SUM_UNITY);\n    }\n    void init(int n, Abel SUM_UNITY = 0) {\n        par.resize(n); rank.resize(n); diff_weight.resize(n);\n        for (int i = 0; i < n; ++i) {\n            par[i] = i, rank[i] = 0, diff_weight[i] = SUM_UNITY;\n        }\n    }\n\n    int root(int x) {\n        if (par[x] == x) return x;\n        else {\n            int r = root(par[x]); //ここで再帰\n            diff_weight[x] += diff_weight[par[x]];\n            return par[x] = r;\n        }\n    }\n\n    bool same(int x, int y) {\n        return root(x) == root(y);\n    }\n\n    Abel weight(int x) {\n        root(x); //diff_weight[x]の計算\n        return diff_weight[x];\n    }\n\n    bool unite(int x, int y, Abel w) {\n        w += weight(x); w -= weight(y);\n        x = root(x); y = root(y);\n        if (x == y) return false;\n        if (rank[x] < rank[y]) swap(x, y), w = -w;\n        if (rank[x] == rank[y]) ++rank[x];\n        par[y] = x;\n        diff_weight[y] = w;\n        return true;\n    }\n\n    Abel diff(int x, int y) {\n        return weight(y) - weight(x);\n    }\n};\n\n\nint main() {\n    ll N, M;\n\n    while (1) {\n        cin >> N >> M;\n\n        if (N == 0) break;\n\n        WUF<ll> wuf(N);\n        rep(i, M) {\n            char x;\n            ll a, b, w;\n            cin  >> x;\n            if (x == '!') {\n                cin >> a >> b >> w;\n                a--, b--;\n                wuf.unite(a, b, w);\n            }\n            else {\n                cin >> a >> b;\n                a--, b--;\n                if (wuf.same(a, b)) cout << wuf.diff(a, b) << endl;\n                else cout << \"UNKNOWN\" << endl;\n            }\n        }\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <utility>\nusing namespace std;\ntypedef long long int lli;\n\nclass exUnionFindTree{\npublic:\n    vector<int> v;\n    vector<int> rank;\n    vector<lli> diff;\n    \n    exUnionFindTree(int n){\n        v = vector<int>(n);\n        rank = vector<int>(n, 0);\n        diff = vector<lli>(n, 0);\n        for(int i=0; i<n; i++) v[i]=i;\n    }\n    int Find(int x){\n        return _find(x).first;\n    }\n    pair<int, lli> _find(int x){\n        if(v[x] != x){\n            pair<int, lli> ret = _find(v[x]);\n            v[x] = ret.first;\n            diff[x] += ret.second;\n        }\n        return make_pair(v[x], diff[x]);\n    }\n    void Union(int a, int b, lli w){\n        int ra = Find(a);\n        int rb = Find(b);\n        if(ra == rb) return;\n        if(rank[ra] < rank[rb]){\n            v[ra] = rb;\n            diff[ra] = diff[b] -diff[a] -w;\n        }else{\n            v[rb] = ra;\n            diff[rb] = diff[a] -diff[b] +w;\n            if(rank[ra] == rank[rb]){\n                rank[ra]++;\n            }\n        }\n    }\n};\n\nint main(){\n\twhile(1){\n\t\tint n,m;\n\t\tcin >> n >> m;\n\t\tif(n==0) break;\n\t\t\n\t\texUnionFindTree uft(n+1);\n\t\tfor(int i=0; i<m; i++){\n\t\t\tchar c;\n\t\t\tcin >> c;\n\t\t\tif(c=='?'){\n\t\t\t\tint a,b;\n\t\t\t\tcin >> a >> b;\n\t\t\t\tif(uft.Find(a) == uft.Find(b)){\n\t\t\t\t\tcout << uft.diff[b] -uft.diff[a] << endl;\n\t\t\t\t}else{\n\t\t\t\t\tcout << \"UNKNOWN\" << endl;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tint a,b;\n\t\t\t\tlli diff;\n\t\t\t\tcin >> a >> b >> diff;\n\t\t\t\tuft.Union(a, b, diff);\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<stdio.h>\n\nusing namespace std;\n\n  void makeSet(int x, int p[], int rank[],int weight[]){\n    p[x]=x;\n    rank[x]=0;\n    weight[x]=0;\n  }\n int findSet(int x, int p[]){\n    if(x==p[x]){\n      return x;\n    }else{\n      return findSet(p[x],p);\n    }\n  }\n  bool same(int x,int y, int p[]){\n    return findSet(x,p)==findSet(y,p);\n  }\n  void link(int x,int y, int p[],int rank[]){   \n    p[x]=y;\n    if(rank[x]>=rank[y]){  \n      rank[y]=rank[x]+1;\n    }\n  }\n   void unite(int x,int y,int w, int weight[],int p[],int rank[]){\n    weight[x]=w;\n    link(x,y,p,rank);\n  }\n\n  int depth(int x, int weight[],int p[]){\n    int ans=0;\n    ans+=weight[x];\n    while(x!=p[x]){\n      ans+=weight[p[x]];\n      x=p[x];\n    }\n    return ans;\n  }\n\nint main(){\n  int n,m;\n  while(scanf(\"%d%d\",&n,&m)){\nint p[n];\nint weight[n];\nint rank[n];\n    if(!n&&!m){\n      break;\n    }else{\n      char query[5];\n     for(int i=0;i<n;i++){\n    makeSet(i,p,rank,weight);\n    }\n      for(int i=0;i<m;i++){\n        scanf(\"%s\",query);\n        if(query[0]=='!'){\n          int a,b,w;\n          scanf(\"%d%d%d\",&a,&b,&w);\n          unite(a,b,w,weight,p,rank);\n        }else{\n          int c,d;\n          scanf(\"%d%d\",&c,&d);\n          if(!same(c,d,p)){\n            printf(\"UNKNOWN\\n\");\n          }else{\n            printf(\"%d\\n\",depth(c, weight,p)-depth(d, weight,p));\n          }\n        }\n      }\n    }\n  }\n  return 0;\n}\n      "
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <cstdint>\n\nclass UnionFind {\n  std::vector<int> vertex;\n  std::vector<intmax_t> weight;\n\npublic:\n  UnionFind(size_t V): vertex(V, -1), weight(V, 0) {}\n\n  bool unite(size_t u, size_t v, intmax_t w) {\n    size_t u_orig=u, v_orig=v;\n    if (u >= 0) u = find(u);\n    if (v >= 0) v = find(v);\n    if (u == v) return false;\n    if (vertex[u] > vertex[v]) {\n      std::swap(u, v);\n      std::swap(u_orig, v_orig);\n      w = -w;\n    }\n\n    // u:parent, v:child\n    vertex[u] += vertex[v];\n    vertex[v] = u;\n    weight[v] = w - relweight(v_orig) + relweight(u_orig);\n    return true;\n  }\n\n  int find(size_t v) const {\n    if (vertex[v] < 0)\n      return v;\n\n    return find(vertex[v]);\n  }\n\n  bool connected(size_t u, size_t v) const {\n    return find(u) == find(v);\n  }\n\n  intmax_t relweight(size_t u) {\n    if (vertex[u] < 0) {\n      return 0;\n    }\n\n    weight[u] += relweight(vertex[u]);\n    if (vertex[vertex[u]] >= 0)\n      vertex[u] = vertex[vertex[u]];\n\n    return weight[u];\n  }\n};\n\nint testcase_ends() {\n  int N, M;\n  scanf(\"%d %d\", &N, &M);\n\n  if (N == 0)\n    return 1;\n\n  UnionFind uf(N);\n\n  for (int i=0; i<M; ++i) {\n    char ch;\n    scanf(\" %c\", &ch);\n\n    if (ch == '?') {\n      int a, b;\n      scanf(\"%d %d\", &a, &b);\n      --a, --b;\n      if (uf.connected(a, b)) {\n        printf(\"%jd\\n\", uf.relweight(b)-uf.relweight(a));\n      } else {\n        printf(\"UNKNOWN\\n\");\n      }\n    } else if (ch == '!') {\n      int a, b;\n      intmax_t w;\n      scanf(\"%d %d %jd\", &a, &b, &w);\n      --a, --b;\n      uf.unite(a, b, w);\n    }\n  }\n\n  return 0;\n}\n\nint main() {\n  while (!testcase_ends()) {}\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define f first\n#define s second\n#define mp make_pair\n#define inf 1<<30\n#define MAX 1000010\nusing namespace std;\n\nlong long p[MAX],w[MAX];\n\npair<int,int> find(int a){\n  pair<int,int> pii;\n  if(p[a]==a){\n    pii.f=a;pii.s=0;\n    return pii;\n  }\n  pii=find(p[a]);\n  pii.s+=w[a];\n  p[a]=pii.f;\n  w[a]=pii.s;\n  return pii;\n}\n\nint main()\n{\n  int n,q,a,b,d;\n  char c;\n\n  while(cin>>n>>q && n ){\n\n    for(int i=0;i<n;i++){\n      p[i]=i;\n      w[i]=0;\n    }\n\n    for(int i=0;i<q;i++){\n      cin>>c;\n      if(c=='!'){\n\tcin>>a>>b>>d;\n\ta--;b--;\n\tpair<int,int> pa=find(a),pb=find(b);\n\tif(pa==pb)continue;\n\tp[pa.f]=b;\n\tw[pa.f]=d-pa.s;\n\tp[a]=pb.f;\n\tw[a]=pb.s+d;\n      }\n      else {\n\tcin>>a>>b;\n\ta--;b--;\n\tpair<int,int> pa=find(a),pb=find(b);\n\tif(pa.f!=pb.f)cout<<\"UNKNOWM\"<<endl;\n\telse {\n\t  p[a]=pa.f;\n\t  w[a]=pa.s;\n\t  p[b]=pb.f;\n\t  w[b]=pb.s;\n\t  cout<<pa.s-pb.s<<endl;\n\t}\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n\nstruct CWW{CWW(){ios::sync_with_stdio(false);cin.tie(0);}}cww;\n\nnamespace _UF{\n    #define SZ 100010\n    int mem[2][SZ];\n};\nclass UnionFind{\npublic:\n    int *par,*rank;\n    int find(int x){\n\tif(par[x]==x)return x;\n\telse{\n\t    int p=find(par[x]);\n\t    rank[x]+=rank[par[x]];\n\t    return par[x]=p;\n\t}\n    }\n    UnionFind(int n):par(_UF::mem[0]),rank(_UF::mem[1]){\n\tfor(int i=0;i<n;i++)par[i]=i,rank[i]=0;\n    }\n    bool unite(int x,int y,int diff){\n\tint xp=find(x),yp=find(y);\n\tif(xp==yp)return false;\n\tdiff-=rank[x];\n\tdiff+=rank[y];\n\tif(diff<0){\n\t    diff*=-1;\n\t    swap(xp,yp);\n\t}\n\tpar[xp]=yp;\n\trank[xp]=diff;\n\treturn true;\n    }\n    bool same(int x,int y){\n\treturn find(x)==find(y);\n    }\n    int  get(int x,int y){\n\tint p=find(x);\n\treturn rank[x]-rank[y];\n    }\n};\n\n\n\nint main(){\n    for(int N,Q;cin>>N>>Q,N+Q;){\n\tUnionFind uf(N+1);\n\twhile(Q--){\n\t    string s;\n\t    cin>>s;\n\t    int x,y;\n\t    cin>>x>>y;\n\t    if(s==\"!\"){\n\t\tint w;cin>>w;\n\t\tuf.unite(x,y,w);\n\t    }\n\t    else{\n\t\tif(uf.same(x,y)){\n\t\t    cout<<uf.get(x,y)<<endl;\n\t\t}\n\t\telse{\n\t\t    cout<<\"UNKNOWN\"<<endl;\n\t\t}\n\t\t    \n\t    }\n\t}\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nconst int MAXN = 100005;\nint n, m;\nint c[MAXN], L[MAXN];\nvector <int> v[MAXN];\nint main() {\n\tfreopen(\"input.txt\", \"r\", stdin);\n\twhile (scanf(\"%d%d\", &n, &m) != EOF) {\n\t\tif (n == 0 && m == 0) break;\n\t\tfor (int i = 1; i <= n; i++) c[i] = i, L[i] = 0, v[i].push_back(i);\n\t\tfor (int i = 1; i <= m; i++) {\n\t\t\tchar op; scanf(\" %c\", &op);\n\t\t\tif (op == '?') {\n\t\t\t\tint x, y; scanf(\"%d%d\", &x, &y);\n\t\t\t\tif (c[x] != c[y]) puts(\"UNKNOWN\");\n\t\t\t\telse printf(\"%d\\n\", L[y] - L[x]);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tint x, y, cx, cy, z; scanf(\"%d%d%d\", &x, &y, &z); //y = x+z\n\t\t\t\tcx = c[x]; cy = c[y];\n\t\t\t\tif (cx == cy) continue;\n\t\t\t\telse {\n\t\t\t\t\tif (v[cx].size() > v[cy].size()) {\n\t\t\t\t\t\tint Ly = L[y];\n\t\t\t\t\t\tfor (auto &t : v[cy]) L[t] = -(Ly - L[t]) + L[x] + z;\n\t\t\t\t\t\tfor (auto &t : v[cy]) c[t] = cx, v[cx].push_back(t);\n\t\t\t\t\t\tv[cy].clear();\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tint Lx = L[x];\n\t\t\t\t\t\tfor (auto &t : v[cx]) L[t] = -(Lx - L[t]) + L[y] - z;\n\t\t\t\t\t\tfor (auto &t : v[cx]) c[t] = cy, v[cy].push_back(t);\n\t\t\t\t\t\tv[cx].clear();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i <= n; i++) v[i].clear();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define f first\n#define s second\n#define mp make_pair\n#define inf 1<<30\n#define MAX 100001\nusing namespace std;\n\nint p[MAX];\nmap<pair<int,int>,int> M;\n\npair<int,int> find(int a){\n  pair<int,int> pii;\n  if(p[a]==a){\n    pii.f=a;pii.s=0;\n    return pii;\n  }\n  pii=find(p[a]);\n  pii.s+=M[mp(p[a],a)];\n  return pii;\n}\n\nint main()\n{\n  int n,q,a,b,w;\n  char c;\n\n  while(1){\n    cin>>n>>q;\n    if(n+q==0)break;\n    for(int i=0;i<n;i++)p[i]=i;\n    M.clear();\n\n    for(int i=0;i<q;i++){\n      cin>>c;\n      if(c=='!'){\n\tcin>>a>>b>>w;\n\ta--;b--;\n\tM[mp(b,a)]=w;\n\tp[a]=b;\n      }\n      else {\n\tcin>>a>>b;\n\ta--;b--;\n\tpair<int,int> pa=find(a),pb=find(b);\n\tif(pa.f!=pb.f)cout<<\"UNKNOWM\"<<endl;\n\telse cout<<pa.s-pb.s<<endl;\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <utility>\n#include <vector>\nusing namespace std;\n\nclass dist_unionfind {\n private:\n  vector<pair<int, int>> tree;  // parent, (w_parent-w_this)\n  pair<int, int> getR(int a) {  //\n    if (tree[a].first == -1) {\n      return make_pair(a, 0);\n    } else {\n      return tree[a] = make_pair(getR(tree[a].first).first,\n                                 getR(tree[a].first).second + tree[a].second);\n    }\n  }\n\n public:\n  dist_unionfind(int size) {\n    tree = vector<pair<int, int>>(size, make_pair(-1, 0));\n  }\n  pair<bool, int> check(int a, int b) {\n    pair<int, int> ra = getR(a), rb = getR(b);\n    return make_pair(ra.first == rb.first, ra.second - rb.second);\n  }\n  void unite(int a, int b, int dist) {  // dist = w_b-w_a\n    pair<int, int> ra = getR(a), rb = getR(b);\n    if (ra.first == rb.first) return;\n    tree[ra.first].first = rb.first;\n    tree[ra.first].second = dist - ra.second + rb.second;\n  }\n};\n\nint main() {\n  int n, m;\n  while (cin >> n >> m, n > 0) {\n    int a, b, w;\n    char s;\n    dist_unionfind DU = dist_unionfind(n);\n    pair<bool, int> ret;\n    for (int i = 0; i < m; i++) {\n      cin >> s;\n      if (s == '!') {\n        cin >> a >> b >> w;\n        DU.unite(--a, --b, w);\n      } else {\n        cin >> a >> b;\n        ret = DU.check(--a, --b);\n        if (ret.first)\n          cout << ret.second << endl;\n        else\n          cout << \"UNKNOWN\" << endl;\n      }\n    }\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\n#include <cassert>\n#include <queue>\n#include <set>\n#include <map>\n#include <valarray>\n#include <bitset>\n#include <stack>\n#include <iomanip>\n#include <fstream>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define chmax(a,b) (a<b?(a=b,1):0)\n#define chmin(a,b) (a>b?(a=b,1):0)\n#define valid(y,x,h,w) (0<=y&&y<h&&0<=x&&x<w)\nconst int INF = 1<<29;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n\nstruct UnionFind {\n  vector<int> data;\n  vector<ll> dis;\n  UnionFind(int size) : data(size, -1), dis(size,0) { }\n  bool unionSet(int x, int y, ll d) {\n    ll disx = dist(x);\n    ll disy = dist(y);\n    x = root(x); y = root(y);\n    if (x != y) {\n      if (data[y] < data[x]) {\n        swap(x, y), d=-d;\n        swap(disx,disy);\n      }\n      data[x] += data[y]; data[y] = x;\n      dis[y] = disx + d - disy;\n    }\n    return x != y;\n  }\n  bool findSet(int x, int y) {\n    return root(x) == root(y);\n  }\n  int root(int x) {\n    if (data[x]<0) return x;\n    else {\n      dis[x] += dis[data[x]];\n      return data[x] = root(data[x]);\n    }\n    // return data[x] < 0 ? x : data[x] = root(data[x]);\n  }\n  int size(int x) {\n    return -data[root(x)];\n  }\n  int dist(int x) {\n    root(x);\n    return dis[x];\n  }\n};\n\nint main() {\n  int n,m;\n  while(cin>>n>>m,n||m) {\n    UnionFind uf(n);\n    REP(i,m) {\n      // REP(j,n) cout << uf.data[j] << \" \"; cout << endl;\n      // REP(j,n) cout << uf.dis[j] << \" \"; cout << endl;\n      char c; cin >> c;\n      if (c == '!') {\n        int a, b, d;\n        cin >> a >> b >> d;\n        a--;b--;\n        uf.unionSet(a,b,d);\n      } else {\n        int a, b;\n        cin >> a >> b;\n        a--;b--;\n        if (uf.findSet(a,b)) {\n          ll d1 = uf.dist(a);\n          ll d2 = uf.dist(b);\n          cout << d2-d1 << endl;\n        } else {\n          puts(\"UNKNOWN\");\n        }\n      }\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\nconst ll MOD = 1000000007;\nconst int IINF = INT_MAX;\nconst ll LLINF = LLONG_MAX;\nconst int MAX_N = int(2e5 + 5);\nconst double EPS = 1e-8;\nconst int di[] = {0, 1, 0, -1}, dj[] = {1, 0, -1, 0};\n#define REP(i, n) for (int i = 0; i < n; i++)\n#define REPR(i, n) for (int i = n; i >= 0; i--)\n#define SORT(v) sort((v).begin(), (v).end())\n#define ALL(v) (v).begin(), (v).end()\n\ntemplate<class Abel> struct UnionFind {\n    vector<int> par;\n    vector<int> rank;\n    vector<Abel> diff_weight;\n\n    UnionFind(int n = 1, Abel SUM_UNITY = 0) {\n        init(n, SUM_UNITY);\n    }\n\n    void init(int n = 1, Abel SUM_UNITY = 0) {\n        par.resize(n); rank.resize(n); diff_weight.resize(n);\n        for (int i = 0; i < n; ++i) par[i] = i, rank[i] = 0, diff_weight[i] = SUM_UNITY;\n    }\n\n    int root(int x) {\n        if (par[x] == x) {\n            return x;\n        }\n        else {\n            int r = root(par[x]);\n            diff_weight[x] += diff_weight[par[x]];\n            return par[x] = r;\n        }\n    }\n\n    Abel weight(int x) {\n        root(x);\n        return diff_weight[x];\n    }\n\n    bool issame(int x, int y) {\n        return root(x) == root(y);\n    }\n\n    bool merge(int x, int y, Abel w) {\n        w += weight(x); w -= weight(y);\n        x = root(x); y = root(y);\n        if (x == y) return false;\n        if (rank[x] < rank[y]) swap(x, y), w = -w;\n        if (rank[x] == rank[y]) ++rank[x];\n        par[y] = x;\n        diff_weight[y] = w;\n        return true;\n    }\n\n    Abel diff(int x, int y) {\n        return weight(y) - weight(x);\n    }\n};\n\n\n\nint main() {\n    int n, m;\n    while(cin >> n >> m, n){\n        UnionFind<ll> g(n+1);\n        REP(i,m){\n            string s;\n            cin >> s;\n            if(s==\"!\"){\n                ll a, b, w;\n                cin >> a >> b >> w;\n                g.merge(a,b,w);\n            }\n            else {\n                ll a, b;\n                cin >> a >> b;\n                if(g.issame(a,b)){\n                    cout << g.diff(a,b) << endl;\n                }\n                else cout << \"UNKNOWN\" << endl;\n            }\n\n        }\n\n    }\n    return 0;\n}   \n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define PI       3.1415926535897932384626433832795028841971\n#define INF 1000000000\n#define EPS      1e-10\n#define MOD      1000000\nusing namespace std;\ntypedef long long ll;\ntypedef pair<double,double> P;\ntypedef pair<double,P> PQ;\n\nstruct Q{\n    int time,a, b;\n};\n\nstruct edge{\n    int time, from, to, w;\n    bool operator<(const edge& right) const {\n        return time < right.time;\n    }\n    bool operator>(const edge& right) const {\n        return time > right.time;\n    }\n};\n\nstruct UF{\n\tint par[100000];\n\tint rank[100000];\n\tint si[100000];\n\n\tvoid init(int n){\n\t\trep(i,n){\n\t\t\tpar[i] = i;\n\t\t\trank[i] = 0;\n\t\t\tsi[i] = 1;\n\t\t}\n\t}\n\n\tint find(int x){\n\t\tif(par[x] == x) return x;\n\t\telse return par[x] = find(par[x]);\n\t}\n\n\tvoid unite(int x, int y){\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif(x == y) return;\n\t\t\n\t\tif(rank[x] < rank[y]){\n\t\t\tpar[x] = y;\n\t\t\tsi[y] += si[x];\n\t\t} else{\n\t\t\tpar[y] = x;\n\t\t\tif(rank[x] == rank[y]) rank[x]++;\n\t\t\tsi[x] += si[y];\n\t\t}\n\t}\n\n\tbool same(int x, int y){\n\t\treturn find(x) == find(y);\n\t}\n} uf;\n\nint n, m;\nint bss[100000];\nint rnk[100000];\nll num[100000];\nbool saw[100000];\nvector<edge> e[100000];\nvector<Q> q;\nint up[20][100000];\nint par[20][100000];\n\nvoid dfs(int v, int bos){\n    saw[v] = true;\n    priority_queue<edge, vector<edge>,greater<edge> > que;\n    rep(i,e[v].size()) que.push(e[v][i]);\n    while(que.size() != 0){\n        edge E = que.top();\n        que.pop();\n        if(saw[E.to]) continue;\n       // cout << E.to << endl;\n        saw[E.to] = true;\n        up[0][E.to] = E.time;\n        rnk[E.to] = rnk[E.from]+1;\n        bss[E.to] = v;\n        par[0][E.to] = E.from;\n        num[E.to] = num[E.from]+E.w;\n        rep(i,e[E.to].size()){\n            que.push(e[E.to][i]);\n        }\n    }\n}\n\nint main(){\n    while(cin >> n >> m){\n        if(n == 0 && m == 0) break;\n        uf.init(n);\n        memset(bss,0,sizeof(bss));\n        memset(rnk,0,sizeof(rnk));\n        memset(num,0,sizeof(num));\n        memset(saw,0,sizeof(saw));\n        rep(i,100000) e[i].clear();\n        q.clear();\n        memset(up,0,sizeof(up));\n        rep(i,m){\n            char hoge;\n            int a, b, w;\n            cin >> hoge;\n            if(hoge == '!'){\n                cin >> a >> b >> w;\n                a--; b--;\n                if(uf.same(a,b)) continue;\n                uf.unite(a,b);\n                e[a].push_back((edge){i,a,b,w});\n                e[b].push_back((edge){i,b,a,-w});\n            } else{\n                cin >> a >> b;\n                a--; b--;\n                q.push_back((Q){i,a,b});\n            }\n        }\n        rep(i,20){\n            rep(j,n) par[i][j] = j;\n        }\n        rep(i,n){\n            if(saw[i]) continue;\n            dfs(i,i);\n        }\n        for(int i = 1; i < 20; i++){\n            rep(j,n){\n                par[i][j] = par[i-1][par[i-1][j]];\n                up[i][j] = max(up[i-1][j],up[i-1][par[i-1][j]]);\n            }\n        }\n        rep(i,q.size()){\n            Q p = q[i];\n            bool done = false;\n            if(bss[p.a] != bss[p.b]){\n                cout << \"UNKNOWN\" << endl;\n                continue;\n            }\n            ll ans = num[p.b]-num[p.a];\n           // cout << rnk[p.a] << \" \" << rnk[p.b] << endl;\n            if(rnk[p.a] > rnk[p.b]){\n                int dis = rnk[p.a]-rnk[p.b];\n                int z = 0;\n                while(dis > 0){\n                    if(dis&1){\n                        if(up[z][p.a] > p.time){\n                            done = true;\n                            cout << \"UNKNOWN\" << endl;\n                            break;\n                        }\n                        p.a = par[z][p.a];\n                    }\n                    z++;\n                    dis /= 2;\n                }\n            } else if(rnk[p.a] < rnk[p.b]){\n                int dis = rnk[p.b]-rnk[p.a];\n                int z = 0;\n                while(dis > 0){\n                    if(dis&1){\n                        if(up[z][p.b] > p.time){\n                            done = true;\n                            cout << \"UNKNOWN\" << endl;\n                            break;\n                        }\n                        p.b = par[z][p.b];\n                    }\n                    z++;\n                    dis /= 2;\n                }\n            }\n            if(done) continue;\n            if(p.a == p.b){\n                cout << ans << endl;\n                continue;\n            }\n            int common = 0;\n            for(int j = 19; j >= 0; j--){\n                if(par[j][p.a] == par[j][p.b]) continue;\n                common += (1<<j);\n            }\n            common++;\n            int z = 0;\n            while(common > 0){\n                if(common&1){\n                    if(up[z][p.a] > p.time){\n                        done = true;\n                        cout << \"UNKNOWN\" << endl;\n                        break;\n                    }\n                    if(up[z][p.b] > p.time){\n                        done = true;\n                        cout << \"UNKNOWN\" << endl;\n                        break;\n                    }\n                    p.a = par[z][p.a];\n                    p.b = par[z][p.b];\n                }\n                common /= 2;\n                z++;\n            }\n            if(done) continue;\n            cout << ans << endl;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n#include <fstream>\n#include <bitset>\n   \nusing namespace std;\n   \n \n#define rep(i, n) for (int i = 0; i < (int)(n); ++i)\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define rforeach(it, c) for (__typeof__((c).rbegin()) it=(c).rbegin(); it != (c).rend(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define CL(arr, val) memset(arr, val, sizeof(arr))\n#define COPY(dest, src) memcpy(dest, src, sizeof(dest))\n#define ten(n) ((long long)(1e##n))\n#define bin(n) (1LL << (n))\n#define erep(i, n) for (int i = 0; i <= (int)(n); ++i)\n#define revrep(i, n) for (int i = (n); i >= 0; --i)\n#define pb push_back\n\ntemplate <class T> void chmax(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void chmin(T& a, const T& b) { a = min(a, b); }\n \ntemplate <class T> void uniq(vector<T>& c) { sort(c.begin(), c.end()); c.erase(unique(c.begin(), c.end()), c.end()); }\n \ntemplate <class T> string to_s(const T& a) { ostringstream os; os << a; return os.str(); }\ntemplate <class T> T to_T(const string& s) { istringstream is(s); T res; is >> res; return res; }\n  \ntemplate <class T, class U> ostream& operator<<(ostream& os, pair<T, U>& p) { os << \"( \" << p.first << \", \" << p.second << \" )\"; return os; }\n  \ntemplate <class T> void print(T a, int n, const string& deli = \" \", int br = 1) { for (int i = 0; i < n; ++i) { cout << a[i]; if (i + 1 != n) cout << deli; } while (br--) cout << endl; }\ntemplate <class T> void print(const T& c, const string& deli = \" \", int br = 1) { foreach (it, c) { cout << *it; if (++it != c.end()) cout << deli;--it; } while (br--) cout << endl; }\ntemplate <class T> void print2d(T a, int w, int h, int width = -1, int br = 1) { for (int i = 0; i < h; ++i) { for (int j = 0; j < w; ++j) {    if (width != -1) cout.width(width); cout << a[i][j] << ' '; } cout << endl; } while (br--) cout << endl; }\n   \ntemplate <class T> void input(T& a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\ntemplate <class T> void input(T* a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\n\nvoid fix_pre(int n) { cout.setf(ios::fixed, ios::floatfield); cout.precision(10); }\nvoid fast_io() { cin.tie(0); ios::sync_with_stdio(false); }\n#define trace(x) (cout << #x << \": \" << (x) << endl)\n \nbool in_rect(int x, int y, int w, int h) { return 0 <= x && x < w && 0 <= y && y < h; }\n \n\ntypedef long long ll;\ntypedef pair<int, int> pint;\n \n// y(v): v>^<  y(^): ^>v<\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\n\nconst double PI = acos(-1.0);\n\n#define F first\n#define S second\n\n\n\nclass UnionFind\n{\nprivate:\n    vector<int> data;\n    int _groups;\npublic:\n    int n;\n    UnionFind(int n) : data(n, -1), n(n), _groups(n) { }\n\n    void unite(int x, int y)\n    {\n        x = root(x), y = root(y);\n        if (x != y)\n        {\n            --_groups;\n            if (data[x] > data[y])\n                swap(x, y);\n            data[x] += data[y];\n            data[y] = x;\n        }\n    }\n    bool same(int x, int y) { return root(x) == root(y); }\n    int root(int x) { return data[x] < 0 ? x : data[x] = root(data[x]); }\n    int size(int x) { return -data[root(x)]; }\n    int groups() const { return _groups; }\n};\nint main()\n{\n    const int M = ten(5) + 100;\n\n    int n, m;\n    while (scanf(\"%d%d\", &n, &m), n)\n    {\n        char query[M];\n        int qa[M], qb[M];\n        vector<vector<pint> > g(n + 1); // (to, diff)\n        rep(i, m)\n        {\n            char op;\n            int a, b;\n            scanf(\" %c%d%d\", &op, &a, &b);\n            if (op == '!')\n            {\n                int w;\n                scanf(\"%d\", &w);\n                g[a].pb(pint(b, w));\n                g[b].pb(pint(a, -w));\n            }\n\n            query[i] = op;\n            qa[i] = a, qb[i] = b;\n        }\n\n        const int undef = ten(9);\n        int weight[M];\n        fill_n(weight, n + 1, undef);\n        for (int s = 1; s <= n; ++s)\n        {\n            if (weight[s] == undef)\n            {\n                queue<int> q;\n                weight[s] = 0;\n                q.push(s);\n                while (!q.empty())\n                {\n                    int v = q.front();\n                    q.pop();\n\n                    foreach (it, g[v])\n                    {\n                        int to = it->first, diff = it->second;\n                        if (weight[to] == undef)\n                        {\n                            weight[to] = weight[v] + diff;\n                            q.push(to);\n                        }\n                    }\n                }\n            }\n        }\n\n        UnionFind uf(n + 1);\n        rep(i, m)\n        {\n            int a = qa[i], b = qb[i];\n\n            if (query[i] == '!')\n                uf.unite(a, b);\n            else\n            {\n                if (uf.same(a, b))\n                    printf(\"%d\\n\", weight[b] - weight[a]);\n                else\n                    puts(\"UNKNOWN\");\n            }\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\n#define int ll\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define PB push_back\n\nconst ll LLINF = (1LL<<60);\nconst int INF = (1LL<<30);\nconst int MOD = 1000000007;\n\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate <typename T> bool IN(T a, T b, T x) { return a<=x&&x<b; }\ntemplate<typename T> T ceil(T a, T b) { return a/b + !!(a%b); }\ntemplate<class S,class T>\nostream &operator <<(ostream& out,const pair<S,T>& a){\n  out<<'('<<a.first<<','<<a.second<<')';\n  return out;\n}\ntemplate<class T>\nostream &operator <<(ostream& out,const vector<T>& a){\n  out<<'[';\n  REP(i, a.size()) {out<<a[i];if(i!=a.size()-1)out<<',';}\n  out<<']';\n  return out;\n}\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\nclass UnionFind {\npublic:\n  const static int MAX_N = 100010;\n  int par[MAX_N];\n  int s[MAX_N];\n  UnionFind() { init(); }\n  UnionFind(int n) { init(n); }\n  void init() { for(int i=0; i<MAX_N; ++i) par[i] = i, s[i] = 1; }\n  void init(int n) { for(int i=0; i<n; ++i) par[i] = i, s[i] = 1; }\n  int find(int x) {\n    if(par[x] == x) return x;\n    return par[x] = find(par[x]);\n  }\n  void unite(int x, int y) {\n    x = find(x);\n    y = find(y);\n    if(x == y) return;\n    if(s[x] < s[y]) par[x] = y, s[y] = s[x] + s[y];\n    else par[y] = x, s[x] = s[x] + s[y];\n  }\n  bool same(int x, int y) { return find(x) == find(y);}\n};\nUnionFind uf;\n\nvector<PII> g[100010];\nint d[100010];\nvoid dfs(int x, int p, int dist) {\n  d[x] = dist;\n  for(auto e: g[x]) {\n    if(e.first != p) dfs(e.first, x, dist + e.second);\n  }\n}\n\nsigned main(void)\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  while(true) {\n    int n, m;\n    cin >> n >> m;\n    if(!n) break;\n    REP(i, n) g[i].clear();\n    memset(d, 0, sizeof(d));\n    vector<PII> query;\n    VI ans(m);\n    int idx = 0;\n    REP(i, m) {\n      char c;\n      int a, b;\n      cin >> c >> a >> b; a--, b--;\n      if(c == '!') {\n        int w; cin >> w;\n        uf.unite(a, b);\n        g[a].PB({b, -w});\n        g[b].PB({a, w});\n      } else {\n        query.PB({a, b});\n        if(!uf.same(a, b)) ans[idx] = INF;\n        idx++;\n      }\n    }\n    dfs(0, -1, 0);\n\n    REP(i, query.size()){\n      if(ans[i] == INF) continue;\n      // cout << \"i:\" << i << \" \" << query[i].first << \" \" << query[i].second << endl;\n      ans[i] = d[query[i].first] - d[query[i].second];\n    }\n\n    REP(i, query.size()) {\n      if(ans[i]==INF) cout << \"UNKNOWN\" << endl;\n      else cout << ans[i] << endl;\n    }\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cassert>// c\n#include <ctime>\n#include <iostream>// io\n#include <iomanip>\n#include <fstream>\n#include <sstream>\n#include <vector>// container\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <algorithm>// other\n#include <complex>\n#include <numeric>\n#include <functional>\n#include <random>\n#include <regex>\n\nusing namespace std;\ntypedef long long ll;\n\n#define ALL(c) (c).begin(),(c).end()\n#define FOR(i,l,r) for(int i=(int)l;i<(int)r;++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORr(i,l,r) for(int i=(int)r-1;i>=(int)l;--i)\n#define REPr(i,n) FORr(i,0,n)\n#define EACH(i,c) for(__typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define IN(l,v,r) ((l)<=(v) && (v)<(r))\n#define UNIQUE(v) v.erase(unique(ALL(v)),v.end())\n//debug\n#define DUMP(x)  cerr << #x << \" = \" << (x)\n#define LINE()    cerr<< \" (L\" << __LINE__ << \")\"\n\ntemplate<typename T,typename U> T pmod(T x,U M){return (x%M+M)%M;}\n\n//verified by AOJ0118 \nstruct UnionFind{\n    vector<int> par,rank,ss;int size;\n    vector<int> ws;\n    UnionFind(int n){\n        REP(i,n) par.push_back(i);\n        rank = vector<int>(n);ss=vector<int>(n,1);size=n;\n\n        ws=vector<int>(n);\n    }\n    int root(int x){\n        if(par[x] == x)return x;\n        int r = root(par[x]); ws[x] += ws[par[x]];\n        return par[x] = r;\n    }\n    int val(int x){\n    \troot(x);return ws[x];\n    }\n    bool same(int x,int y){\n        return root(x) == root(y);\n    }\n    void unite(int x,int y,int w=0){\n        int wx=val(x),wy=val(y);\n        x = root(x);y = root(y);\n        if(x==y)return;\n        if(rank[x] < rank[y]){//root y\n        \tws[x] = w+wy;\n            par[x] = y;ss[y]+=ss[x];\n        }else{//root x\n        \tws[y] = -w+wx;\n            par[y] = x;ss[x]+=ss[y];\n        }\n        if(rank[x] == rank[y]) rank[x]++;\n        size--;\n    }\n    int getS(int x){\n        return ss[root(x)];\n    }\n};\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tcerr << fixed <<setprecision(20);\n\tcout << fixed <<setprecision(20);\n  while (true) {\n  \tint N,M;cin >> N >> M;if(N==0)break;\n  \tUnionFind uf(N);\n  \tREP(i,M){\n  \t\tchar c;int a,b,w;cin >> c >> a >> b;a--;b--;\n\t\n\t\t// REP(i,N)cerr <<uf.par[i] <<\" \";cerr <<endl;\n  \t\t// REP(i,N)cerr <<uf.val(i) <<\" \";cerr <<endl;\n  \t\tif(c=='!'){\n  \t\t\tcin >> w;\n  \t\t\tuf.unite(a,b,w);\n  \t\t}else{\n  \t\t\tif(!uf.same(a,b)){\n  \t\t\t\tcout <<\"UNKNOWN\"<<endl;\n  \t\t\t}else{\n  \t\t\t\tcout << uf.val(a)-uf.val(b) <<endl;\n  \t\t\t}\n  \t\t}\n  \t\t// cerr <<\"aaa\"<<endl;\n  \t}\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define PI       3.1415926535897932384626433832795028841971\n#define INF 1000000000\n#define EPS      1e-10\n#define MOD      1000000\nusing namespace std;\ntypedef long long ll;\ntypedef pair<double,double> P;\ntypedef pair<double,P> PQ;\n\nstruct Q{\n    int time,a, b;\n};\n\nstruct edge{\n    int time, from, to, w;\n    bool operator<(const edge& right) const {\n        return time < right.time;\n    }\n    bool operator>(const edge& right) const {\n        return time > right.time;\n    }\n};\n\nint n, m;\nint bss[100000];\nint rnk[100000];\nll num[100000];\nbool saw[100000];\nvector<edge> e[100000];\nvector<Q> q;\nint up[20][100000];\nint par[20][100000];\n\nvoid dfs(int v, int bos){\n    saw[v] = true;\n    priority_queue<edge, vector<edge>,greater<edge> > que;\n    rep(i,e[v].size()) que.push(e[v][i]);\n    while(que.size() != 0){\n        edge E = que.top();\n        que.pop();\n        if(saw[E.to]) continue;\n       // cout << E.to << endl;\n        saw[E.to] = true;\n        up[0][E.to] = E.time;\n        rnk[E.to] = rnk[E.from]+1;\n        bss[E.to] = v;\n        par[0][E.to] = E.from;\n        num[E.to] = num[E.from]+E.w;\n        rep(i,e[E.to].size()){\n            que.push(e[E.to][i]);\n        }\n    }\n}\n\nint main(){\n    while(cin >> n >> m){\n        if(n == 0 && m == 0) break;\n        memset(bss,0,sizeof(bss));\n        memset(rnk,0,sizeof(rnk));\n        memset(num,0,sizeof(num));\n        memset(saw,0,sizeof(saw));\n        rep(i,100000) e[i].clear();\n        q.clear();\n        memset(up,0,sizeof(up));\n        rep(i,m){\n            char hoge;\n            int a, b, w;\n            cin >> hoge;\n            if(hoge == '!'){\n                cin >> a >> b >> w;\n                a--; b--;\n                e[a].push_back((edge){i,a,b,w});\n                e[b].push_back((edge){i,b,a,-w});\n            } else{\n                cin >> a >> b;\n                a--; b--;\n                q.push_back((Q){i,a,b});\n            }\n        }\n        rep(i,20){\n            rep(j,n) par[i][j] = j;\n        }\n        rep(i,n){\n            if(saw[i]) continue;\n            dfs(i,i);\n        }\n        for(int i = 1; i < 20; i++){\n            rep(j,n){\n                par[i][j] = par[i-1][par[i-1][j]];\n                up[i][j] = max(up[i-1][j],up[i-1][par[i-1][j]]);\n            }\n        }\n        rep(i,q.size()){\n            Q p = q[i];\n            bool done = false;\n            if(bss[p.a] != bss[p.b]){\n                cout << \"UNKNOWN\" << endl;\n                continue;\n            }\n            ll ans = num[p.b]-num[p.a];\n           // cout << rnk[p.a] << \" \" << rnk[p.b] << endl;\n            if(rnk[p.a] > rnk[p.b]){\n                int dis = rnk[p.a]-rnk[p.b];\n                int z = 0;\n                while(dis > 0){\n                    if(dis&1){\n                        if(up[z][p.a] > p.time){\n                            done = true;\n                            cout << \"UNKNOWN\" << endl;\n                            break;\n                        }\n                        p.a = par[z][p.a];\n                    }\n                    z++;\n                    dis /= 2;\n                }\n            } else if(rnk[p.a] < rnk[p.b]){\n                int dis = rnk[p.b]-rnk[p.a];\n                int z = 0;\n                while(dis > 0){\n                    if(dis&1){\n                        if(up[z][p.b] > p.time){\n                            done = true;\n                            cout << \"UNKNOWN\" << endl;\n                            break;\n                        }\n                        p.b = par[z][p.b];\n                    }\n                    z++;\n                    dis /= 2;\n                }\n            }\n            if(done) continue;\n            if(p.a == p.b){\n                cout << ans << endl;\n                continue;\n            }\n            int common = 0;\n            for(int j = 19; j >= 0; j--){\n                if(par[j][p.a] == par[j][p.b]) continue;\n                common += (1<<j);\n            }\n            common++;\n            int z = 0;\n            while(common > 0){\n                if(common&1){\n                    if(up[z][p.a] > p.time){\n                        done = true;\n                        cout << \"UNKNOWN\" << endl;\n                        break;\n                    }\n                    if(up[z][p.b] > p.time){\n                        done = true;\n                        cout << \"UNKNOWN\" << endl;\n                        break;\n                    }\n                    p.a = par[z][p.a];\n                    p.b = par[z][p.b];\n                }\n                common /= 2;\n                z++;\n            }\n            if(done) continue;\n            cout << ans << endl;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cassert>\n#include <utility>\nusing namespace std;\ntypedef pair<int,int> pii;\n#define repeat(i,n) for (int i = 0; i < n; ++i)\n#define repeat_from(i,m,n) for (int i = m; i < n; ++i)\n\n#define MAX_N 100000\n#define MAX_M 100000\nint N, M;\n\npii tree[MAX_N];\nvoid init_tree(int n) { repeat (i,n) { tree[i] = pii(i,0); } }\npii find_root(int a) {\n    /*   d1   d2\n     * a -> b -> c\n     *\n     *   d1+d2\n     * +---------+\n     * |      d2 v\n     * a -> b -> c\n     */\n    if (tree[a].first != a) {\n        pii pb = find_root(tree[a].first);\n        tree[a].first = pb.first;\n        tree[a].second += pb.second;\n    }\n    return tree[a];\n}\nvoid union_tree(int a, int b, int w) {\n    /*    d1\n     *  a -> ra\n     * w|     | d3\n     *  v d2  v   (w + d2 = d1 + d3)\n     *  b -> rb\n     */\n    pii ra = find_root(a), rb = find_root(b);\n    if (ra.first != rb.first) {\n        tree[ra.first].first = rb.first;\n        tree[ra.first].second = w + rb.second - ra.second;\n    } else {\n        assert(ra.second - rb.second == w);\n    }\n}\n\nint main(void) {\n    while (true) {\n        cin >> N >> M; cin.ignore();\n        if (not N or not M) break;\n        init_tree(N);\n        repeat (i,M) {\n            char c; cin >> c;\n            if (c == '!') {\n                int a, b, w; cin >> a >> b >> w; cin.ignore(); -- a; -- b;\n                union_tree(a,b,w);\n            } else if (c == '?') {\n                int a, b; cin >> a >> b; cin.ignore(); -- a; -- b;\n                pii ra = find_root(a), rb = find_root(b);\n                if (ra.first == rb.first) {\n                    cout << ra.second - rb.second << endl;\n                } else {\n                    cout << \"UNKNOWN\" << endl;\n                }\n            } else {\n                assert(false);\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <algorithm>\n#include <iostream>\n#include <cstdio>\n#include <cstring>\n\nusing namespace std;\n\ntypedef long long ll;\n\n#define SIZE 100010\n\n\nstruct LCA {\n  int n;\n  vector<vector<int>> tree, parent;\n  vector<int> depth;\n  int max_log;\n\n  LCA(int n): n(n), tree(n), depth(n, -1) {\n    max_log = 0;\n    for (int i=1; i<=n*2; i*=2) max_log++;\n    parent.assign(max_log, vector<int>(n, -1));\n  }\n\n  void add_edge(int u, int v) {\n    tree[u].push_back(v);\n    tree[v].push_back(u);\n  }\n\n  void dfs(int now, int p, int d) {\n    parent[0][now] = p;\n    depth[now] = d;\n\n    for (int to : tree[now])\n      if (to != p) dfs(to, now, d+1);\n  }\n\n  void build(int root) {\n    dfs(root, -1, 0);\n  }\n\n  void build2() {\n    for (int i=0; i<max_log-1; i++) {\n      for (int j=0; j<n; j++)\n        parent[i+1][j] = parent[i][j] == -1 ?\n          -1 : parent[i][parent[i][j]];\n    }\n  }\n\n  int query(int a, int b) {\n    if (depth[a] > depth[b]) swap(a, b);\n\n    for (int i=0; i<max_log; i++)\n      if ((depth[b] - depth[a]) >> i & 1)\n        b = parent[i][b];\n\n    if (a == b) return a;\n\n    for (int i=max_log-1; i>=0; i--) {\n      if (parent[i][a] != parent[i][b]) {\n        a = parent[i][a];\n        b = parent[i][b];\n      }\n    }\n\n    return parent[0][a];\n  }\n};\n\nstruct UnionFind{\n  vector<int> data;\n  UnionFind(int s): data(s, -1) {};\n\n  int root(int x) {\n    if (data[x] < 0) return x;\n    return data[x] = root(data[x]);\n  }\n\n  bool set(int x, int y) {\n    x = root(x);\n    y = root(y);\n\n    if (x == y) return false;\n\n    data[x] += data[y];\n    data[y] = x;\n    return true;\n  }\n\n  bool check(int x, int y) {\n    return root(x) == root(y);\n  }\n};\n\nbool visited[SIZE];\nll dist[SIZE];\nvector<pair<int,int> > G[SIZE];\npair<char, pair<int,int> > queries[SIZE];\n\nbool dfs(int now, int back = -1, ll d=0) {\n  if (visited[now]) return false;\n  visited[now] = true;\n  dist[now] = d;\n\n  for (auto p : G[now]) {\n    if (p.first == back) continue;\n    dfs(p.first, now, d + p.second);\n  }\n\n  return true;\n}\n\nbool solve() {\n  int N, M;\n\n  scanf(\"%d%d\", &N, &M);\n\n  if (N == 0) return false;\n\n  UnionFind uf(N);\n  LCA lca(N);\n  for (int i=0; i<N; i++) G[i].clear();\n\n\n  for (int i=0; i<M; i++) {\n    char c;\n    int a, b, w;\n\n    scanf(\" %c%d%d\", &c, &a, &b);\n    a--; b--;\n\n    if (c == '!') {\n      scanf(\"%d\", &w);\n\n      bool f = uf.set(a, b);\n\n      if (f) {\n        G[a].push_back({b, w});\n        G[b].push_back({a, -w});\n        lca.add_edge(a, b);\n      }\n    }\n\n    queries[i] = {c, {a, b}};\n  }\n\n  memset(visited, 0, sizeof(visited));\n  for (int i=0; i<N; i++) {\n    if (!visited[i]) {\n      dfs(i);\n      lca.build(i);\n    }\n  }\n  lca.build2();\n\n  UnionFind uf2(N);\n\n  for (int i=0; i<M; i++) {\n    char c = queries[i].first;\n    int a = queries[i].second.first;\n    int b = queries[i].second.second;\n\n    if (c == '!') {\n      uf2.set(a, b);\n    } else {\n      if (!uf2.check(a, b)) {\n        puts(\"UNKNOWN\");\n      } else {\n        int r = lca.query(a, b);\n        ll A = dist[a] - dist[r];\n        ll B = dist[b] - dist[r];\n        ll ans = B - A;\n\n        printf(\"%lld\\n\", ans);\n      }\n    }\n  }\n\n  return true;\n}\n\nint main() {\n\n  while(solve());\n\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntypedef long double ld;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-10;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\nstruct union_find\n{\n\tvector<pii> par;\n\tunion_find(int n)\n\t{\n\t\tREP(i, n) par.emplace_back(i, 0);\n\t}\n\tpii find(int x)\n\t{\n\t\tif (par[x].first == x) return par[x];\n\t\telse\n\t\t{\n\t\t\tpii t = find(par[x].first);\n\t\t\treturn pii(par[x].first = t.first, par[x].second += t.second);\n\t\t}\n\t}\n\tvoid unite(int x, int y, int w)\n\t{\n\t\tint dif = w + par[x].second - par[y].second;\n\t\tx = find(x).first; y = find(y).first;\n\t\tif (x == y) return;\n\t\tpar[y].first = x;\n\t\tpar[y].second += dif;\n\t}\n\tbool same(int x, int y)\n\t{\n\t\treturn find(x).first == find(y).first;\n\t}\n};\n\nint main()\n{\n\tint n, m;\n\twhile (cin >> n >> m, n)\n\t{\n\t\tunion_find uf(n);\n\t\tREP(i, m)\n\t\t{\n\t\t\tchar c;\n\t\t\tcin >> c;\n\t\t\tif (c == '!')\n\t\t\t{\n\t\t\t\tint a, b, w;\n\t\t\t\tcin >> a >> b >> w;\n\t\t\t\ta--; b--;\n\t\t\t\tuf.unite(a, b, w);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tint a, b;\n\t\t\t\tcin >> a >> b;\n\t\t\t\ta--; b--;\n\t\t\t\tif (!uf.same(a, b))\n\t\t\t\t\tputs(\"UNKNOWN\");\n\t\t\t\telse cout << uf.par[b].second - uf.par[a].second << endl;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint a[100100][100100],b[100100],c[100100];\n\n\nint main(){\nstring a;\nwhile(cin>>a);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,n) for(long long i = 0; i < (long long)(n); i++)\nusing ll = long long; using vll = vector<ll>; \n\nstruct UnionFind {\n    // ?????????????????????????????????\n    // ????????????-1 * ????????¨????????????\n    vector<int> data;\n    // ????????????????????????-??????????????´?????????????????????\n    // ?????????0\n    // \n    // w[i]????????????????????????????????¨?????????i??????-???????????¨??????\n    vector<ll> w; \n\n    UnionFind(int size) : data(size, -1), w(size, 0) { }\n    // x, y????????????\n    // O(log n)\n    void unite(int x, int y, int k) {\n        x = root(x); y = root(y); if (x == y) return;\n        ll wx = getWeight(x), wy = getWeight(y);\n\n        if (data[y] < data[x]) {\n            swap(x, y);\n            swap(wx, wy);\n            k *= -1;\n        }\n        data[x] += data[y]; \n        data[y] = x;\n        w[y] = -k + wx - wy;\n    }\n    // x, y?????????????????????1\n    // O(log n)\n    bool find(int x, int y) {\n        return root(x) == root(y);\n    }\n    // x???????????¢??????????????????????????????????????°???\n    // O(log n)\n    int root(int x) {\n        return data[x] < 0 ? x : root(data[x]);\n//        return data[x] < 0 ? x : data[x] = root(data[x]); // ????´??????????????????¢????????????????¨????????????????????????????????????´??°??¢???????????§?????£??¨???\n    }\n    // x??????????????§???w?????????\n    // O(log n)\n    ll getWeight(int x) {\n        return data[x] < 0 ? 0 : w[x] + getWeight(data[x]);\n    }\n};\n\nint main(void) {\n    cin.tie(0); ios::sync_with_stdio(false);\n\n    ll n, m; \n    while (cin >> n >> m && n && m) {\n        UnionFind uf(n);\n        rep(i, m) {\n            char c; cin >> c;\n            if (c == '!') {\n                ll x, y, w; cin >> x >> y >> w; x--; y--;\n                uf.unite(x, y, w);\n            } else {\n                ll x, y; cin >> x >> y; x--; y--;\n                if (!uf.find(x, y))\n                    cout << \"UNKNOWN\" << endl;\n                else \n                    cout << uf.getWeight(x) - uf.getWeight(y) << endl;\n            }\n        }\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cassert>\n#include<algorithm>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<29)\n#define MAX 100001\nusing namespace std;\nstruct P\n{\n  int color,w;\n  P(int color=-inf,int w=-inf):color(color),w(w){}\n};\nP par[MAX];\nvoid init(){ rep(i,MAX)par[i] = P(i); }\n\nP find(int x)\n{\n  if(x == par[x].color)return par[x];\n  P p = find(par[x].color);\n  if(par[x].w == -inf)par[x].w = 0;\n  par[x].w += p.w,par[x].color = p.color;\n  return par[x];\n}\n\nvoid unit(int x,int y,int w)//x <= y\n{\n  P X = find(x); \n  P Y = find(y);\n  par[X.color].color = par[Y.color].color;\n  if(par[X.color].w == -inf)par[X.color].w = 0;\n  if(par[Y.color].w == -inf)par[Y.color].w = 0;\n  par[X.color].w = par[X.color].w + (par[y].w-w - par[x].w);\n}\n\nint N,M;\n\nint main()\n{\n  while(cin >> N >> M,N|M)\n    {\n      init();\n      char c;\n      int a,b,w;\n      rep(_,M)\n\t{\n\t  cin >> c;\n\t  if(c == '!')\n\t    {\n\t      cin >> a >> b >> w;\n\t      unit(a,b,w);\n\t    }\n\t  else\n\t    {\n\t      cin >> a >> b;\n\t      P B = find(b),A = find(a);\n\t      if(B.color != A.color)cout << \"UNKNOWN\" << endl;\n\t      else cout << B.w-A.w << endl;\n\t    }\n\t}\n    }\n  return 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define f first\n#define s second\n#define mp make_pair\n#define inf 1<<30\n#define MAX 1000010\nusing namespace std;\n\nlong long p[MAX],w[MAX];\n\npair<int,int> find(int a){\n  pair<int,int> pii;\n  if(p[a]==a){\n    pii.f=a;pii.s=0;\n    return pii;\n  }\n  pii=find(p[a]);\n  pii.s+=w[a];\n  return pii;\n}\n\nint main()\n{\n  int n,q,a,b,d;\n  char c;\n\n  while(cin>>n>>q && n ){\n\n    for(int i=0;i<n;i++){\n      p[i]=i;\n      w[i]=0;\n    }\n\n    for(int i=0;i<q;i++){\n      cin>>c;\n      if(c=='!'){\n\tcin>>a>>b>>d;\n\ta--;b--;\n\tpair<int,int> pa=find(a),pb=find(b);\n\tp[pa.f]=b;\n\tw[pa.f]=pb.s+d-pa.s;\n\tp[a]=pb.f;\n\tw[a]=pb.s+d;\n      }\n      else {\n\tcin>>a>>b;\n\ta--;b--;\n\tpair<int,int> pa=find(a),pb=find(b);\n\tif(pa.f!=pb.f)cout<<\"UNKNOWM\"<<endl;\n\telse {\n\t  p[a]=pa.f;\n\t  w[a]=pa.s;\n\t  p[b]=pb.f;\n\t  w[b]=pb.s;\n\t  cout<<pa.s-pb.s<<endl;\n\t}\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n\tw[x]-w[y]=d ?????????????????¨???????????£??±?????\\???\n\t????????????,w[x]-w[y]?????????????????¨??????????????§??????\n\td[x]=w[par[x]]-w[x]\n\n\n\tw[x]=?????° ??????????????????????????????,w[0]:=0??¨??????w[x]-w[0]=?????° ?????????\n\tw[x]+w[y]??¨????????????????????§\n*/\n#include <bits/stdc++.h>\n#define rep(i,N) for(int i=0;i<N;i++)\nusing namespace std;\ntypedef long long ll;\nstruct unionfind{\n\tint par[100000];\n\tll d[100000];\n\tvoid init(int n) { rep(i,n) par[i]=i,d[i]=0; }\n\tint find(int x){\n\t\tif(x==par[x]) return x;\n\t\tint r=find(par[x]);\n\t\td[x]+=d[par[x]];\n\t\treturn par[x]=r;\n\t}\n\tvoid unite(int x,int y,int z){\t\t//w[x]-w[y]=z\t\n\t\tint rx=find(x),ry=find(y);\n\t\tif(rx==ry) return;\n\t\td[ry]=d[x]-d[y]-z;\n\t\tpar[ry]=rx;\n\t}\n\tint diff(int x,int y){\t\t//w[x]-w[y]=?\n\t\tassert(same(x,y));\n\t\tfind(x),find(y);\t\t\t//??????!!\n\t\treturn d[x]-d[y];\n\t}\n\tbool same(int x,int y) { return find(x)==find(y); }\n}UF;\n\nint main(){\n\twhile(true){\n\t\tint N,M;\n\t\tcin>>N>>M;\n\t\tif(N==0) break;\n\t\tUF.init(N);\n\t\trep(t,M){\n\t\t\tchar c;\n\t\t\tcin>>c;\n\t\t\tif(c=='!'){\n\t\t\t\tint x,y,z;\n\t\t\t\tcin>>x>>y>>z;\n\t\t\t\tx--,y--;\n\t\t\t\tUF.unite(y,x,z);\n\t\t\t}else{\n\t\t\t\tint x,y;\n\t\t\t\tcin>>x>>y;\n\t\t\t\tx--,y--;\n\t\t\t\tif(!UF.same(x,y)) puts(\"UNKNOWN\");\n\t\t\t\telse cout<<UF.diff(y,x)<<endl;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n \n#define DEBUG(x) cout<<#x<<\": \"<<x<<endl;\n#define DEBUG_VEC(v) cout<<#v<<\":\";for(int i=0;i<v.size();i++) cout<<\" \"<<v[i]; cout<<endl\n \ntypedef long long ll;\n#define vi vector<int>\n#define vl vector<ll>\n#define vii vector< vector<int> >\n#define vll vector< vector<ll> >\n#define vs vector<string>\n#define pii pair<int,int>\n#define pis pair<int,string>\n#define psi pair<string,int>\n#define pll pair<ll,ll>\n#define fi first\n#define se second\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define all(c) c.begin(),c.end()\n#define in(x, a, b) a <= x && x < b\nconst int inf = 1000000001;\nconst ll INF = 2e18;\nconst ll MOD = 1000000007;\n//const ll mod = 1000000009;\nconst double pi = 3.14159265358979323846;\n#define Sp(p) cout<<setprecision(15)<< fixed<<p <<endl;\nint dx[4] = { 1,0, -1,0 }, dy[4] = { 0,1,0,-1 };\nint dx2[8] = { 1,1,0,-1,-1,-1,0,1 }, dy2[8] = { 0,1,1,1,0,-1,-1,-1 };\n\n\n\n\nclass WeightedUF {\npublic:\n  vi par, ran, num;\n  vl diff_weight; //親ノード(根ノードではない)との値の差分\n  \n  WeightedUF(int n) {\n    par.resize(n); ran.resize(n);\n    num.resize(n); diff_weight.resize(n);\n    for (int i = 0; i < n; i++) {\n      par[i] = i; ran[i] = 0;\n      num[i] = 1; diff_weight[i] = 0;\n    }\n  }\n\n  //木の根を求める\n  int find(int x) {\n    if (par[x] == x) {\n      return x;\n    }\n    else {\n      int root = find(par[x]);\n      diff_weight[x] += diff_weight[par[x]];\n      return par[x] = root;\n    }\n  }\n\n  ll weight(int x) {\n    find(x); //経路圧縮\n    return diff_weight[x];\n  }\n\n  //xからみたyの重み\n  ll diff(int x, int y) {\n    if (!same(x, y)) {\n      return -INF;\n    }\n    else {\n      return weight(y) - weight(x);\n    }\n  }\n  \n  //xからみたyの重みがwになるように併合\n  bool unite(int x, int y, ll w) {\n    w += weight(x); w -= weight(y);\n    x = find(x); y = find(y);\n    int numsum = num[x] + num[y];\n    if (x == y) {\n      if (diff(x, y) == w) {\n\treturn true;\n      }\n      else {\n\treturn false;\n      }\n    }\n    if (ran[x]<ran[y]) {\n      swap(x, y);\n      w = -w;\n    }\n    par[y] = x;\n    if (ran[x] == ran[y]) {\n\tran[x]++;\n    }\n    diff_weight[y] = w;\n    num[x] = num[y] = numsum;\n    return true;\n  }\n\n  //xとyが同じ集合に属するか否か\n  bool same(int x, int y) {\n    return find(x) == find(y);\n  }\n\n};\n\n\nint main() {\n  while (true) {\n    int n, m;\n    cin >> n >> m;\n    if (n == 0 && m == 0) {\n      return 0;\n    }\n    WeightedUF uf(n);\n    rep (i, m) {\n      char c;\n      cin >> c;\n      if (c == '!') {\n\tint l, r, d;\n\tcin >> l >> r >> d;\n\tl--; r--;\n\tassert(uf.unite(l, r, d));\n      }\n      else {\n\tint l, r;\n\tcin >> l >> r;\n\tl--; r--;\n\tll res = uf.diff(l, r);\n\tif (res == -INF) {\n\t  cout << \"UNKNOWN\" << endl;\n\t}\n\telse {\n\t  cout << res << endl;\n\t}\n      }\n    }\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<map>\nusing namespace std;\n\nclass UF {\n    public:\n    vector<pair<int,int> > l;\n    UF(int n) {\n        for(int i=0; i<n; i++)\n            l.push_back(pair<int,int>(i,0));\n    }\n    pair<int,int> root(int x) {\n        if(x == l[x].first) return l[x];\n        pair<int,int> t = root(l[x].first);\n        l[x].first = t.first ;\n        l[x].second+= t.second;\n        return l[x];\n    }\n    void unite(int x, int y, int xMy) {\n        x = root(x).first;\n        pair<int,int> t = root(y);\n        y = t.first;\n        if(x == y) return;\n        l[y].first = l[x].first;\n        l[y].second= -xMy + t.second;\n    }\n    int weight(int x, int y) { // x - y else 123456\n        pair<int,int> s,t;\n        s = root(x);\n        t = root(y);\n        if(s.first != t.first) return 123456;\n        return s.second - t.second;\n    }\n};\n\n\nint main(void) {\n    while(1) {\n        int n,m;\n        scanf(\"%d%d\",&n,&m);\n        if(!n) break;\n        UF uf(n);\n        for(int i=0; i<m; i++) {\n            int a,b;\n            char s[3];\n            scanf(\"%s%d%d\",s,&a,&b);\n            a--, b--;\n            if(s[0] == '?') {\n                int w = uf.weight(b,a);\n                if(w == 123456)\n                    printf(\"UNKNOWN\\n\");\n                else\n                    printf(\"%d\\n\", w);\n            }\n            else {\n                int w;\n                scanf(\"%d\",&w);\n                uf.unite(b, a, w);\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntypedef long double ld;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-10;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\nstruct union_find\n{\n\tvector<pii> par;\n\tunion_find(int n)\n\t{\n\t\tREP(i, n) par.emplace_back(i, 0);\n\t}\n\tpii find(int x)\n\t{\n\t\tif (par[x].first == x) return par[x];\n\t\telse\n\t\t{\n\t\t\tpii t = find(par[x].first);\n\t\t\tpar[x].first = t.first;\n\t\t\tpar[x].second += t.second;\n\t\t\treturn t;\n\t\t}\n\t}\n\tvoid unite(int x, int y, int w)\n\t{\n\t\tint dif = w + par[x].second - par[y].second;\n\t\tx = find(x).first; y = find(y).first;\n\t\tif (x == y) return;\n\t\tpar[y].first = x;\n\t\tpar[y].second += dif;\n\t}\n\tbool same(int x, int y)\n\t{\n\t\treturn find(x).first == find(y).first;\n\t}\n};\n\nint main()\n{\n\tint n, m;\n\twhile (cin >> n >> m, n)\n\t{\n\t\tunion_find uf(n);\n\t\tREP(i, m)\n\t\t{\n\t\t\tchar c;\n\t\t\tcin >> c;\n\t\t\tif (c == '!')\n\t\t\t{\n\t\t\t\tint a, b, w;\n\t\t\t\tcin >> a >> b >> w;\n\t\t\t\ta--; b--;\n\t\t\t\tuf.unite(a, b, w);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tint a, b;\n\t\t\t\tcin >> a >> b;\n\t\t\t\ta--; b--;\n\t\t\t\tif (!uf.same(a, b)) puts(\"UNKNOWN\");\n\t\t\t\telse cout << uf.par[b].second - uf.par[a].second << endl;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n#define SZ(x) (x).size()\n#define ALL(x) (x).begin(),(x).end()\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef pair<int,int> PII;\n#define MP make_pair\n\nstruct Edge{\n  int to, cost;\n  Edge(int to_, int cost_) : to(to_), cost(cost_){\n  }\n};\ntypedef vector<vector<Edge>> Graph;\n\n\nclass UnionFind{\nprivate:\n  vector<int> par, rank;\npublic:\n  UnionFind(int n){\n\tpar.assign(n, 0);\n\trank.assign(n, 0);\n\tfor(int i=0;i<n;++i)\n\t  par[i] = i;\n  }\n\n  //find root of x\n  int find(int x){\n\tif(par[x] == x)\n\t  return x;\n\treturn (par[x] = find(par[x]));\n  }\n\n  void unite(int x, int y){\n\tx = find(x);\n\ty = find(y);\n\tif(x == y) return;\n\n\tif(rank[x] < rank[y])\n\t  par[x] = y;\n\telse{\n\t  par[y] = x;\n\t  if(rank[x] == rank[y])\n\t\t++rank[x];\n\t}\n  }\n\n  bool same(int x, int y){\n\treturn find(x) == find(y);\n  }\n};\n\nconst int INF = 1e9;\n\nvoid dfs(int u, VI& dist, Graph& G){\n  for(auto& e: G[u]){\n\tif(dist[e.to] == INF){\n\t  dist[e.to] = dist[u] + e.cost;\n\t  dfs(e.to, dist, G);\n\t}\n  }\n}\n\nint main(){\n  int N, M;\n  while(cin>>N>>M,N&&M){\n\tVI kind;\n\tvector<PII> query;\n\tGraph G(N);\n\tUnionFind after(N), tmp(N);\n\tfor(int i=0;i<M;++i){\n\t  char c; cin >> c;\n\t  if(c == '!'){\n\t\tint a, b, c;\n\t\tcin >> a >> b >> c;\n\t\t--a, --b;\n\t\tkind.push_back(0);\n\t\tquery.push_back(MP(a,b));\n\t\tG[a].emplace_back(b,c);\n\t\tG[b].emplace_back(a,-c);\n\t\tafter.unite(a, b);\n\t  }\n\t  else{\n\t\tint a, b; cin >> a >> b;\n\t\t--a, --b;\n\t\tkind.push_back(1);\n\t\tquery.push_back(MP(a,b));\n\t  }\n\t}\n\n\tVI dist(N, INF);\n\tfor(int i=0;i<N;++i){\n\t  if(dist[i] == INF){\n\t\tint rt = after.find(i);\n\t\tdist[rt] = 0;\n\t\tdfs(rt, dist, G);\n\t  }\n\t}\n\n\tfor(int i=0;i<SZ(query);++i){\n\t  if(kind[i]){\n\t\tint a = query[i].first;\n\t\tint b = query[i].second;\n\t\tint u = tmp.find(a);\n\t\tif(u != tmp.find(b)){\n\t\t  cout << \"UNKNOWN\" << endl;\n\t\t}\n\t\telse{\n\t\t  cout << dist[b] - dist[a] << endl;\n\t\t}\n\t  }\n\t  else{\n\t\ttmp.unite(query[i].first, query[i].second);\n\t  }\n\t}\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <numeric>\n#include <utility>\n#include <cassert>\n#include <functional>\n#include <stack>\n\ntemplate<typename T>\nstruct PotentializedUnionFind {\npublic:\n\tusing value_type = T;\n\tusing const_reference = const value_type &;\n\tusing size_type = std::size_t;\n\tusing F = std::function<T(T, T)>;\n\t\n\tPotentializedUnionFind(size_type n, const F &f, const_reference id_elem)\n\t\t\t: n(n), f(f), id_elem(id_elem), size_(n, 1), val(n, id_elem) {\n\t\tpar.resize(n);\n\t\tstd::iota(par.begin(), par.end(), 0);\n\t}\n\t\n\tsize_type size(size_type x) { return size_[find(x)]; }\n\t\n\tvalue_type get(size_type x) {\n\t\tfind(x);\n\t\tif (par[x] == x) return val[x];\n\t\treturn f(val[par[x]], val[x]);\n\t}\n\t\n\tsize_type add(const_reference v) {\n\t\tsize_.emplace_back(1);\n\t\tpar.emplace_back(n);\n\t\tval.emplace_back(v);\n\t\treturn n++;\n\t}\n\t\n\tsize_type find(size_type x) {\n\t\tassert(x < n);\n\t\tstd::stack<size_type> stk;\n\t\tstk.push(x);\n\t\twhile (par[stk.top()] != stk.top()) stk.push(par[stk.top()]);\n\t\t\n\t\tsize_type r = stk.top();\n\t\tstk.pop();\n\t\tbool r_child = true;\n\t\twhile (!stk.empty()) {\n\t\t\tconst size_type &t = stk.top();\n\t\t\tif (!r_child) val[t] = f(val[par[t]], val[t]);\n\t\t\tpar[t] = r;\n\t\t\tr_child = false;\n\t\t\tstk.pop();\n\t\t}\n\t\treturn r;\n\t}\n\t\n\tvoid link(size_type p, size_type x) {\n\t\tassert(par[x] == x);\n\t\tpar[x] = p;\n\t\tsize_[find(p)] += size_[x];\n\t}\n\t\n\tbool issame(size_type x, size_type y) { return find(x) == find(y); }\n\t\nprivate:\n\tsize_type n;\n\tvalue_type id_elem;\n\tF f;\n\tstd::vector<size_type> size_, par;\n\tstd::vector<value_type> val;\n};\n\n\n#include <cstdio>\n\nint main() {\n\tint N, M;\n\twhile(scanf(\"%d %d\", &N, &M), N && M) {\n\t\tPotentializedUnionFind<int> puf(N, [](int a, int b){ return a + b; }, 0);\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\tchar c;\n\t\t\tint a, b;\n\t\t\tscanf(\" %c %d %d\", &c, &a, &b);\n\t\t\t--a; --b;\n\t\t\t\n\t\t\tif (c == '!') {\n\t\t\t\tint w;\n\t\t\t\tscanf(\"%d\", &w);\n\t\t\t\tif (!puf.issame(a, b)) {\n\t\t\t\t\tint u = puf.add(w - puf.get(b));\n\t\t\t\t\tpuf.link(a, u);\n\t\t\t\t\tpuf.link(u, puf.find(b));\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (puf.issame(a, b)) printf(\"%d\\n\", puf.get(b) - puf.get(a));\n\t\t\t\telse puts(\"UNKNOWN\");\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <algorithm>\n#include <set>\n#include <vector>\n\ntypedef long long ll;\nusing namespace std;\n\nint gid[100005]; //group? 是?个int\nint belong[100005];  // 下?int 属于?个group\nll sub[100005];  // 下?int 跟group?差多少\nint gcnt = 0;\nint main()\n{\n    int N,M;\n\n    //freopen(\"in.txt\",\"r\",stdin);\n\n    while(~scanf(\"%d%d\",&N,&M)) {\n        if ( !N && !M ) break;\n        char c[10];\n        int a,b;\n        ll w;\n\n        memset(gid, -1, sizeof(gid));\n        memset(belong, -1, sizeof(belong));\n        memset(sub, 0, sizeof(sub));\n        gcnt = 0;\n        for(int i=0;i<M;i++) {\n            scanf(\"%s%d%d\", c,&a,&b);\n            if ( c[0] == '!') {\n                scanf(\"%lld\",&w);\n\n                if ( belong[a] == -1 && belong[b] == -1 ) {\n                    gcnt++;\n                    belong[a] = gcnt;\n                    belong[b] = gcnt;\n                    gid[ belong[a] ] = a;\n                    sub[a] = 0;\n                    sub[b] = w;\n                }\n                else if ( belong[a] == -1 ) {\n                    belong[a] = belong[b];\n                    sub[a] =  - w + sub[ b ];\n\n                }\n                else if ( belong[b] == -1 ) {\n                    belong[b] = belong[a];\n                    sub[b] = w + sub[ a ];\n                }\n\n            }\n            else if ( c[0] == '?' ) {\n                if ( a == b ) {\n                    printf(\"0\\n\");\n                }\n                else if ( belong[a] == -1 || belong[b] == -1 ) {\n                    printf(\"UNKNOWN\\n\");\n                }\n                else if ( belong[a] == belong[b]) {\n                    printf(\"%lld\\n\", sub[b] - sub[a]);\n                }\n                else if ( belong[a] != belong[b] ) {\n                    printf(\"UNKNOWN\\n\");\n                }\n            }\n        }\n\n//        for(int i=1;i<=N;i++) {\n//            printf(\"i=%d group=%d root=%d sub=%lld\\n\",i, belong[i], gid[ belong[i] == -1? 0 : belong[i] ], sub[i] );\n//        }\n\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nclass WeightedDisjointSets\n{\nprivate:\n    using T = ll;\n    vector<int> parent, rank;\n    vector<T> weight;\n\npublic:\n    WeightedDisjointSets(const int v) : parent(v), rank(v, 0), weight(v, 0) { iota(parent.begin(), parent.end(), 0); }\n    bool same(const int a, const int b) { return find(a) == find(b); }\n    int find(const int a) { return parent[a] == a ? a : (weight[a] += weight[parent[a]], parent[a] = find(parent[a])); }\n    T getWeight(const int a) { return find(a), weight[a]; }\n    void unite(int a, int b, T d)\n    {\n        d += getWeight(a) - getWeight(b);\n        a = find(a), b = find(b);\n        if (a == b) { return; }\n        if (rank[a] < rank[b]) { swap(a, b), d = -d; }\n        rank[a] += rank[b], parent[b] = a, weight[b] = d;\n    }\n    T diff(const int a, const int b) { return getWeight(b) - getWeight(a); }\n};\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while (true) {\n        int N, M;\n        cin >> N >> M;\n        if (N == 0 and M == 0) { break; }\n        WeightedDisjointSets uf(N);\n        for (int i = 0; i < M; i++) {\n            char c;\n            int a, b;\n            cin >> c >> a >> b;\n            a--, b--;\n            if (c == '!') {\n                ll c;\n                cin >> c;\n                uf.unite(a, b, c);\n            } else {\n                if (uf.same(a, b)) { cout << uf.diff(a, b) << \"\\n\"; }\n                if (not uf.same(a, b)) { cout << \"UNKNOWN\\n\"; }\n                // cout << (uf.same(a, b) ? to_string(uf.diff(a, b)) : \"UNKNOWN\") << \"\\n\";\n            }\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define f first\n#define s second\n#define mp make_pair\n#define inf 1<<30\n#define MAX 1000010\nusing namespace std;\n\nlong long p[MAX],w[MAX];\n\nint Find(int a){\n  if(p[a]==a)return a;\n  return Find(p[a]);\n}\n\npair<int,int> find(int a){\n  pair<int,int> pii;\n  if(p[a]==a){\n    pii.f=a;pii.s=0;\n    return pii;\n  }\n  pii=find(p[a]);\n  pii.s+=w[a];\n  p[a]=pii.f;\n  w[a]=pii.s;\n  return pii;\n}\n\nint main()\n{\n  int n,q,a,b,d;\n  char c;\n\n  while(cin>>n>>q && n ){\n    for(int i=0;i<n;i++){\n      p[i]=i;\n      w[i]=0;\n    }\n\n    for(int i=0;i<q;i++){\n      cin>>c;\n      if(c=='!'){\n\tcin>>a>>b>>d;\n\ta--;b--;\n\tint pa=Find(a);\n\tp[pa]=b;\n\tw[pa]=d;\n      }\n      else {\n\tcin>>a>>b;\n\ta--;b--;\n\tpair<int,int> pa=find(a),pb=find(b);\n\tif(pa.f!=pb.f)cout<<\"UNKNOWM\"<<endl;\n\telse {\n\t  p[a]=pa.f;\n\t  w[a]=pa.s;\n\t  p[b]=pb.f;\n\t  w[b]=pb.s;\n\t  cout<<pa.s-pb.s<<endl;\n\t}\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> P;\nconst double EPS = 1e-12;\nconst int INF = numeric_limits<int>::max()/2;\nconst int MOD = 1e9+7;\n\nstruct UFW { // union-find with weight\n\tvector<int> par,w; // w := weight between parent\n\tUFW(int size) : par(size, -1), w(size,0) { }\n\tbool unite(int x, int y, int d) {\n\t\tif (root(x) != root(y)) {\n            w[root(y)] = d+weight(x)-weight(y);\n\t\t\tpar[root(y)] = root(x);\n            \n\t\t}\n\t\treturn x != y;\n\t}\n    void init(int size){\n        for(int i=0;i<size;i++){\n            par[i]=-1;\n            w[i]=0;\n        }\n    }\n\tbool same(int x, int y) {\n\t\treturn root(x) == root(y);\n\t}\n\tint root(int x) {\n\t\treturn par[x] < 0 ? x : root(par[x]);\n\t}\n    int weight(int x){\n        //cout<<x<<endl;\n        if(root(x)==x) return 0;\n        return w[x]+weight(par[x]);\n    }\n    void print(int size){\n        for(int i=0;i<size;i++) cout<<\" \"<<i;\n        cout<<endl;\n        for(int i=0;i<size;i++) cout<<\" \"<<par[i];\n        cout<<endl;\n        for(int i=0;i<size;i++) cout<<\" \"<<w[i];\n        cout<<endl;\n    }\n};\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int n,m;\n    string s;\n    int a,b;\n    ll w;\n    UFW uf(111111);\n    while(cin>>n>>m,n){\n        uf.init(n);\n        for(int i=0;i<m;i++){\n            cin>>s;\n            if(s==\"!\"){\n                cin>>a>>b>>w;\n                a--;b--;\n                uf.unite(a,b,w);\n            }\n            else{\n                cin>>a>>b;\n                a--;b--;\n                //uf.print(n);\n                if(!uf.same(a,b)) cout<<\"UNKNOWN\"<<endl;\n                else{\n                    cout<<uf.weight(b)-uf.weight(a)<<endl;\n                    //cout<<uf.weight(b)<<\" \"<<uf.weight(a)<<endl;\n                }\n                \n            }\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <utility>\nusing namespace std;\ntypedef long long int lli;\n\nclass exUnionFindTree{\npublic:\n    vector<int> v;\n    vector<int> rank;\n    vector<lli> diff;\n    \n    exUnionFindTree(int n){\n        v = vector<int>(n);\n        rank = vector<int>(n, 0);\n        diff = vector<lli>(n, 0);\n        for(int i=0; i<n; i++) v[i]=i;\n    }\n    int Find(int x){\n        return _find(x).first;\n    }\n    pair<int, lli> _find(int x){\n        if(v[x] != x){\n            pair<int, lli> ret = _find(v[x]);\n            v[x] = ret.first;\n            diff[x] += ret.second;\n        }\n        return make_pair(v[x], diff[x]);\n    }\n    void Union(int a, int b, lli w){\n        int ra = Find(a);\n        int rb = Find(b);\n        if(ra == rb) return;\n        if(rank[ra] < rank[rb]){\n            v[ra] = rb;\n            diff[ra] = diff[b] -w;\n        }else{\n            v[rb] = ra;\n            diff[rb] = diff[a] +w;\n            if(rank[ra] == rank[rb]){\n                rank[ra]++;\n            }\n        }\n    }\n};\n\nint main(){\n\twhile(1){\n\t\tint n,m;\n\t\tcin >> n >> m;\n\t\tif(n==0) break;\n\t\t\n\t\texUnionFindTree uft(n+1);\n\t\tfor(int i=0; i<m; i++){\n\t\t\tchar c;\n\t\t\tcin >> c;\n\t\t\tif(c=='?'){\n\t\t\t\tint a,b;\n\t\t\t\tcin >> a >> b;\n\t\t\t\tif(uft.Find(a) == uft.Find(b)){\n\t\t\t\t\tcout << uft.diff[b] -uft.diff[a] << endl;\n\t\t\t\t}else{\n\t\t\t\t\tcout << \"UNKNOWN\" << endl;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tint a,b;\n\t\t\t\tlli diff;\n\t\t\t\tcin >> a >> b >> diff;\n\t\t\t\tuft.Union(a, b, diff);\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nconst int MAX = 100010;\n\nint n, m;\nchar s[10];\nint a, b, c;\nint father[MAX], Rank[MAX];\n\n\nvoid init(){\n\tfor(int i=1; i<=n; i++){\n\t\tfather[i] = i;\n\t\tRank[i] = 0;\n\t}\n}\n\nint find(int x){\n\tif(x != father[x]){\n\t\tRank[x] += Rank[father[x]];\n\t\tfather[x] = find(father[x]);\n\t}\n\treturn father[x];\n}\n\nvoid Union(int a, int b, int c){\n\tint aa = find(a), bb = find(b);\n\tif(aa != bb){\n\t\tif(!Rank[a] && !Rank[b]) father[bb] = aa, Rank[b] = c + Rank[a];\n\t\telse if(!Rank[b]) father[bb] = aa, Rank[b] = c + Rank[a];\n\t\telse father[aa] = bb, Rank[a] = -c + Rank[b];\n\t}\n}\n\nint main(){\n\twhile(scanf(\"%d%d\", &n, &m) == 2){\n\t\tif(!n && !m) break;\n\t\tinit();\n\t\tfor(int i=0; i<m; i++){\n\t\t\tscanf(\"%s\", s);\n\t\t\tif(s[0] == '!'){\n\t\t\t\tscanf(\"%d%d%d\", &a, &b, &c);\n\t\t\t\tUnion(a, b, c);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tscanf(\"%d%d\", &a, &b);\n\t\t\t\tint aa = find(a), bb = find(b);\n\t\t\t\tif(aa != bb) puts(\"UNKNOWN\");\n\t\t\t\telse printf(\"%d\\n\", Rank[b]-Rank[a]);\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#pragma warning(disable : 4996)\nusing namespace std;\npair<int, long long> par[100000];\npair<int, long long> root(int x) {\n\tif (par[x].first == x) return par[x];\n\tpair<int, long long> ret = root(par[x].first);\n\treturn par[x] = make_pair(ret.first, ret.second + par[x].second);\n}\nbool same(int x, int y) {\n\treturn root(x).first == root(y).first;\n}\nvoid unite(int x, int y, int w) { \n\tx = root(x).first; y = root(y).first;\n\tif (x != y) {\n\t\tpar[x] = make_pair(y, w);\n\t}\n}\nlong long query(int a, int b) {\n\treturn root(a).second - root(b).second;\n}\nint N, Q, a, b, w; char c;\nint main() {\n\twhile (true) {\n\t\tscanf(\"%d%d\", &N, &Q);\n\t\tif (N == 0 && Q == 0) break;\n\t\tfor (int i = 0; i < N; i++) par[i] = make_pair(i, 0);\n\t\tfor (int i = 0; i < Q; i++) {\n\t\t\tcin >> c;\n\t\t\tif (c == '!') {\n\t\t\t\tscanf(\"%d%d%d\", &a, &b, &w);\n\t\t\t\tunite(a - 1, b - 1, w);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tscanf(\"%d%d\", &a, &b);\n\t\t\t\tif (!same(a - 1, b - 1)) {\n\t\t\t\t\tprintf(\"UNKNOWN\\n\");\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tprintf(\"%lld\\n\", query(a - 1, b - 1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n\nusing namespace std;\n\ntypedef long long LL;\nstruct Node {\n    int root;\n    LL diff;\n};\n\nint root(int n, vector<Node> &nodes) {\n    if(nodes[n].root == n) return n;\n    nodes[n].diff += nodes[nodes[n].root].diff;\n    const int r = root(nodes[n].root, nodes);\n    return nodes[n].root = nodes[r].root;\n}\n\nbool unite(int a, int b, vector<Node> &nodes) {\n    const int ra = root(a, nodes);\n    const int rb = root(b, nodes);\n    if(nodes[ra].root == nodes[rb].root) return false;\n    nodes[ra].diff += nodes[rb].diff;\n    nodes[ra].root = nodes[rb].root;\n    return true;\n}\n\nbool solve() {\n    int N, M;\n    cin >> N >> M;\n    if(!N && !M) return false;\n\n    vector<Node> nodes(N);\n    for(int i = 0; i < N; ++i) {\n        nodes[i].root = i;\n        nodes[i].diff = 0;\n    }\n    for(int i = 0; i < M; ++i) {\n        string cmd;\n        cin >> cmd;\n        if(cmd == \"!\") {\n            int a, b, w;\n            cin >> a >> b >> w;\n            --a; --b;\n            if(unite(a, b, nodes)) {\n                nodes[a].diff += w;\n            }\n        } else {\n            int a, b;\n            cin >> a >> b;\n            --a; --b;\n            const int ra = root(a, nodes);\n            const int rb = root(b, nodes);\n            if(nodes[ra].root != nodes[rb].root) {\n                cout << \"UNKNOWN\" << endl;\n            } else {\n                const LL diff = nodes[a].diff - nodes[b].diff;\n                cout << diff << endl;\n            }\n        }\n    }\n    return true;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n\n    while(solve()) ;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define PI       3.1415926535897932384626433832795028841971\n#define INF 1000000000\n#define EPS      1e-10\n#define MOD      1000000\nusing namespace std;\ntypedef long long ll;\ntypedef pair<double,double> P;\ntypedef pair<double,P> PQ;\n\nstruct Q{\n    int time,a, b;\n};\n\nstruct edge{\n    int time, to, w;\n};\n\nint n, m;\nint bss[100000];\nint rnk[100000];\nint num[100000];\nbool saw[100000];\nvector<edge> e[100000];\nvector<Q> q;\nint up[20][100000];\nint par[20][100000];\n\nvoid dfs(int v, int bos){\n    saw[v] = true;\n    rep(i,e[v].size()){\n        edge E = e[v][i];\n        if(saw[E.to]) continue;\n        up[0][E.to] = E.time;\n        rnk[E.to] = rnk[v]+1;\n        num[E.to] = num[v]+E.w;\n        bss[E.to] = bos;\n        par[0][E.to] = v;\n        dfs(E.to,bos);\n    }\n}\n\nint main(){\n    while(cin >> n >> m){\n        if(n == 0 && m == 0) break;\n        memset(bss,0,sizeof(bss));\n        memset(rnk,0,sizeof(rnk));\n        memset(num,0,sizeof(num));\n        memset(saw,0,sizeof(saw));\n        rep(i,100000) e[i].clear();\n        q.clear();\n        memset(up,0,sizeof(up));\n        rep(i,m){\n            char hoge;\n            int a, b, w;\n            cin >> hoge;\n            if(hoge == '!'){\n                cin >> a >> b >> w;\n                a--; b--;\n                e[a].push_back((edge){i,b,w});\n                e[b].push_back((edge){i,a,-w});\n            } else{\n                cin >> a >> b;\n                a--; b--;\n                q.push_back((Q){i,a,b});\n            }\n        }\n        rep(i,20){\n            rep(j,n) par[i][j] = j;\n        }\n        rep(i,n){\n            if(saw[i]) continue;\n            dfs(i,i);\n        }\n        for(int i = 1; i < 20; i++){\n            rep(j,n){\n                par[i][j] = par[i-1][par[i-1][j]];\n                up[i][j] = max(up[i-1][j],up[i-1][par[i-1][j]]);\n            }\n        }\n        rep(i,q.size()){\n            Q p = q[i];\n            bool done = false;\n            if(bss[p.a] != bss[p.b]){\n                cout << \"UNKNOWN\" << endl;\n                continue;\n            }\n            int ans = num[p.b]-num[p.a];\n            if(rnk[p.a] > rnk[p.b]){\n                int dis = rnk[p.a]-rnk[p.b];\n                int z = 0;\n                while(dis > 0){\n                    if(dis&1){\n                        if(up[z][p.a] > p.time){\n                            done = true;\n                            cout << \"UNKNOWN\" << endl;\n                            break;\n                        }\n                        p.a = par[z][p.a];\n                    }\n                    z++;\n                    dis /= 2;\n                }\n            } else if(rnk[p.a] < rnk[p.b]){\n                int dis = rnk[p.b]-rnk[p.a];\n                int z = 0;\n                while(dis > 0){\n                    if(dis&1){\n                        if(up[z][p.b] > p.time){\n                            done = true;\n                            cout << \"UNKNOWN\" << endl;\n                            break;\n                        }\n                        p.b = par[z][p.b];\n                    }\n                    z++;\n                    dis /= 2;\n                }\n            }\n            if(done) continue;\n            if(p.a == p.b){\n                cout << ans << endl;\n                continue;\n            }\n            int common = 0;\n            for(int j = 19; j >= 0; j--){\n                if(par[j][p.a] == par[j][p.b]) continue;\n                common += (1<<j);\n            }\n            common++;\n            int z = 0;\n            while(common > 0){\n                if(common&1){\n                    if(up[z][p.a] > p.time){\n                        done = true;\n                        cout << \"UNKNOWN\" << endl;\n                        break;\n                    }\n                    if(up[z][p.b] > p.time){\n                        done = true;\n                        cout << \"UNKNOWN\" << endl;\n                        break;\n                    }\n                    p.a = par[z][p.a];\n                    p.b = par[z][p.b];\n                }\n                common /= 2;\n                z++;\n            }\n            if(done) continue;\n            cout << ans << endl;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define MAX 100010\ntypedef pair<int,int> pii;\n \nclass Union_Find{\npublic:\n    int par[MAX],rank[MAX],W[MAX];\n    Union_Find(int N){\n\tfor(int i = 0 ; i < N ; i++){\n\t    par[i] = i;\n\t    rank[i] = W[i] = 0;\n\t}\n    }\n \n    pii find(int x){\n\tif(par[x] == x) return pii(x,0);\n\tpii p = find(par[x]);\n\tpar[x] = p.first;\n\tW[x] = (p.second += W[x]);\n\treturn p;\n    }\n \n    void unite(int x,int y,int w){\n\tpii nx = find(x), ny = find(y);\n\tx = nx.first; y = ny.first;\n\tif(x == y) return;\n\tw -= nx.second-ny.second;\n\tif(rank[x] < rank[y]){\n\t    par[x] = y; W[x] = w;\n\t}else{\n\t    par[y] = x; W[y] = -w;\n\t    if(rank[x] == rank[y]){\n\t\trank[x]++;\n\t    }\n\t}\n    }\n \n    bool same(int x,int y){\n\treturn (find(x).first == find(y).first);\n    }\n \n    int diff(int a,int b){\n\treturn W[a]-W[b];\n    }\n};\n \nint main(){\n    int N,M,a,b,c;\n    while(cin >> N >> M,N){\n\tUnion_Find uf(N);\n\tfor(int i = 0 ; i < M ; i++){\n\t    char ch;\n\t    cin >> ch >> a >> b;\n\t    a--; b--;\n\t    if(ch == '!'){\n\t\tcin >> c;\n\t\tuf.unite(a,b,c);\n\t    }else{\n\t\tif(uf.same(a,b)){\n\t\t    cout << uf.diff(a,b) << endl;\n\t\t}else{\n\t\t    puts(\"UNKNOWN\");\n\t\t}\n\t    }\n\t}\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<map>\n#include<set>\n#include<vector>\n#include<algorithm>\n#include<string.h>\n#include<queue>\n#include<stack>\n#include<climits>\n#include<cmath>\nusing namespace std;\n\nmap<int,vector<pair<int,int> > >ma;\nmap<pair<int,int>,int>ma2;\nset<int>visited;\nint ans=0;\nbool dfs(int a,int b,int c,bool p){\n    if(a==b){\n        ans=c;\n        return true;\n    }\n    if(ma2[make_pair(a,b)]){\n        ans = (p?1:-1)*ma2[make_pair(a,b)]+c;\n        return true;\n    }\n    for(auto i : ma[a]){\n        if(!visited.count(i.first)){\n            if(dfs(i.first,b,p?c+i.second:c-i.second,p)){\n                ma2[make_pair(a,b)] = ans-c;\n                return true;\n            }\n        }\n    }\n    for(auto i : ma[b]){\n        if(!visited.count(i.first)){\n            if(dfs(i.first,a,p?c-i.second:c+i.second,!p)){\n                ma2[make_pair(a,b)] = ans-c;\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\nint main(){\n    int n,m;\n    while(cin>>n>>m,n){\n        ma.clear();\n        ma2.clear();\n        visited.clear();\n        for(int i=0;i<m;i++){\n            char c;\n            cin>>c;\n            if(c=='!'){\n                int a,b,d;\n                cin>>a>>b>>d;\n                ma[a].push_back(make_pair(b, d));\n                ma2[make_pair(a, b)]=d;\n            } else {\n                int a,b;\n                cin>>a>>b;\n                if(dfs(a,b,0,1)){\n                    cout<<ans<<endl;\n                } else {\n                    cout<<\"UNKNOWN\"<<endl;\n                }\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cassert>\n#include<algorithm>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<29)\n#define MAX 1000000\nusing namespace std;\ntypedef long long ll;\nstruct P\n{\n  ll color,w;\n  P(ll color=-inf,ll w=-inf):color(color),w(w){}\n};\nP par[MAX];\nvoid init(){ rep(i,MAX)par[i] = P(i); }\n\nP find(int x)\n{\n  if(x == par[x].color)return par[x];\n  P p = find(par[x].color);\n  if(par[x].color == -inf)par[x].color = 0;\n  par[x].w += p.w,par[x].color = p.color;\n  return par[x];\n}\n\nvoid unit(int x,int y,ll w)//x <= y\n{\n  P X = find(x);\n  P Y = find(y);\n  if(X.color == Y.color)return;\n  par[X.color].color = par[Y.color].color;\n  if(par[X.color].w == -inf)par[X.color].w = 0;\n  if(par[Y.color].w == -inf)par[Y.color].w = 0;\n  par[X.color].w = par[X.color].w - w + (Y.w != -inf?Y.w:0);\n}\n\nint N,M;\n\nint main()\n{\n  while(cin >> N >> M,N|M)\n    {\n      init();\n      char c;\n      ll a,b,w;\n      rep(_,M)\n\t{\n\t  cin >> c;\n\t  if(c == '!')\n\t    {\n\t      cin >> a >> b >> w;\n\t      unit(a,b,w);\n\t    }\n\t  else\n\t    {\n\t      cin >> a >> b;\n\t      ll B = find(b).w;\n\t      ll A = find(a).w;\n\t      if(B == -inf || A == -inf)cout << \"UNKNOWN\" << endl;\n\t      else cout << B-A << endl;\n\t    }\n\t\n\t}\n    }\n  return 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\nlong long dist[1 << 18];\nlong long group[1 << 18]; char q;\nlong long n, Q, a, b, c;\nvector<long long>gr[1 << 18];\nint main() {\n\tfor (int t = 0; t < 17; t++) {\n\t\tfor (int i = 0; i < 1 << 18; i++) {\n\t\t\tdist[i] = 0; group[i] = i; gr[i].clear(); gr[i].push_back(i);\n\t\t}\n\t\tcin >> n >> Q; if (n == 0 && Q == 0)break;\n\t\tfor (int i = 0; i < Q; i++) {\n\t\t\tcin >> q;\n\t\t\tif (q == '?') {\n\t\t\t\tcin >> a >> b;\n\t\t\t\tif (group[a] != group[b])cout << \"UNKNOWN\" << endl;\n\t\t\t\telse cout << dist[b] - dist[a] << endl;\n\t\t\t}\n\t\t\tif (q == '!') {\n\t\t\t\tcin >> a >> b >> c;\n\t\t\t\tif (group[a] != group[b]) {\n\t\t\t\t\tint K = dist[a] + c - dist[b];\n\t\t\t\t\tint L = group[a], M = group[b];\n\t\t\t\t\tfor (int j = 0; j < gr[M].size(); j++) {\n\t\t\t\t\t\tgroup[gr[M][j]] = L;\n\t\t\t\t\t\tgr[L].push_back(gr[M][j]);\n\t\t\t\t\t\tdist[gr[M][j]] += K;\n\t\t\t\t\t}\n\t\t\t\t\tgr[M].clear();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cassert>\n#include <functional>\n#include <iostream>\n#include <iomanip>\n#include <iterator>\n#include <map>\n#include <queue>\n#include <utility>\n#include <vector>\n\nusing namespace std;\n\ntypedef long long Long;\n#define whole(xs) xs.begin(), xs.end()\n\nstruct UnionFind {\n    int* parent;\n    int* value;\n    UnionFind(int N) {\n        parent = new int[N + 1]; fill(parent, parent + N + 1, -1);\n        value = new int[N + 1]; fill(value, value + N + 1, 0);\n    }\n    ~UnionFind() {\n        delete[] parent;\n        delete[] value;\n    }\n    /* \n     * root :: インデックス -> (ルートのインデックス, ルートとの距離)\n     */\n    pair<int, int> root(int x) {\n        if (parent[x] == -1) return make_pair(x, 0);\n        int p = parent[x];\n        int v = value[x];\n        pair<int, int> proot = root(p);\n        parent[x] = proot.first;\n        value[x] = v + proot.second;\n        return make_pair(parent[x], value[x]);\n    }\n    static const int INF = 1<<28;\n    /* \n     * query :: (インデックスx, インデックスy) -> yとxの差\n     */\n    int query(int x, int y) {\n        pair<int, int> xroot = root(x),\n                       yroot = root(y);\n        if (xroot.first != yroot.first) return INF;\n        return yroot.second - xroot.second;\n    }\n    /*\n     * merge :: (インデックスx, インデックスy, yとxの差w) -> ()\n     *\n     * xとyがすでに親子関係を持っていて,その差がwでなければ異常終了\n     */\n    void merge(int x, int y, int w) {\n        pair<int, int> xroot = root(x),\n                       yroot = root(y);\n        if (xroot.first == yroot.first) {\n            assert(query(x, y) == w);\n            return;\n        }\n        int px = xroot.first, py = yroot.first;\n        int dx = xroot.second, dy = yroot.second;\n        /* value[y] - value[x] = w\n         * value[x] - value[px] = dx\n         * value[y] - value[py] = dy\n         * value[py] - value[px] = (value[y] - dy) - (value[x] - dx)\n         *                       = (value[y] - value[x]) - (dy - dx)\n         *                       = w - dy + dx\n         */\n        parent[py] = px;\n        value[py] = w - dy + dx;\n    }\n};\n\nint main() {\n    int N, M;\n    while (cin >> N >> M, N || M) {\n        UnionFind uf(N);\n        char c; int a, b, w;\n        for (int i = 0; i < M; i++) {\n            cin >> c;\n            if (c == '?') {\n                cin >> a >> b;\n                int ans = uf.query(a, b);\n                //cerr << \"?\" << \" \" << a << \" \" << b << endl;\n                if (ans == UnionFind::INF) {\n                    cout << \"UNKNOWN\" << endl;\n                } else {\n                    cout << ans << endl;\n                }\n            } else {\n                assert(c == '!');\n                cin >> a >> b >> w;\n                //cerr << \"!\" << \" \" << a << \" \" << b << \" \" << w << endl;\n                uf.merge(a, b, w);\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint parent[1<<17],myrank[1<<17],weight[1<<17];\nint root(int x)\n{\n\tif(parent[x]==x)return x;\n\telse\n\t{\n\t\tint r=root(parent[x]);\n\t\tweight[x]+=weight[parent[x]];\n\t\treturn parent[x]=r;\n\t}\n}\nint get_weight(int x)\n{\n\troot(x);\n\treturn weight[x];\n}\nbool issame(int x,int y)\n{\n\treturn root(x)==root(y);\n}\nvoid diff(int x,int y)\n{\n\tif(!issame(x,y))\n\t{\n\t\tcout<<\"UNKNOWN\"<<endl;\n\t}\n\telse cout<<get_weight(y)-get_weight(x)<<endl;\n}\nvoid mymerge(int x,int y,int w)\n{\n\tw+=get_weight(x)-get_weight(y);\n\tx=root(x);y=root(y);\n\tif(myrank[x]<myrank[y])swap(x,y),w*=-1;\n\tif(myrank[x]==myrank[y])myrank[x]++;\n\tparent[y]=x;\n\tweight[y]=w;\n}\nmain()\n{\n\tint n,m;\n\twhile(cin>>n>>m,n)\n\t{\n\t\tfor(int i=0;i++<n;)parent[i]=i,myrank[i]=0,weight[i]=0;\n\t\tfor(int i=0;i<m;i++)\n\t\t{\n\t\t\tchar c;cin>>c;\n\t\t\tif(c=='!')\n\t\t\t{\n\t\t\t\tint a,b,w;cin>>a>>b>>w;\n\t\t\t\tmymerge(a,b,w);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tint a,b;cin>>a>>b;\n\t\t\t\tdiff(a,b);\n\t\t\t}\n\t\t}\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <cstdint>\n\nclass UnionFind {\n  std::vector<int> vertex;\n  std::vector<intmax_t> weight;\n\npublic:\n  UnionFind(size_t V): vertex(V, -1), weight(V, 0) {}\n\n  bool unite(size_t u, size_t v, intmax_t w) {\n    //if (u >= 0) u = find(u);\n    //if (v >= 0) v = find(v);\n    if (u == v) return false;\n    if (vertex[find(u)] > vertex[find(v)]) {\n      std::swap(u, v);\n      w = -w;\n    }\n\n    // u:parent, v:child\n    vertex[find(u)] += vertex[find(v)];\n    vertex[v] = u;\n    weight[v] = w;\n    return true;\n  }\n\n  int find(size_t v) const {\n    while (vertex[v] >= 0)\n      v = vertex[v];\n\n    return v;\n  }\n\n  bool connected(size_t u, size_t v) const {\n    return find(u) == find(v);\n  }\n\n  intmax_t relweight(size_t u) const {\n    if (vertex[u] < 0) {\n      return 0;\n    }\n\n    return weight[u] + relweight(vertex[u]);\n  }\n};\n\nint testcase_ends() {\n  int N, M;\n  scanf(\"%d %d\", &N, &M);\n\n  if (N == 0)\n    return 1;\n\n  UnionFind uf(N);\n\n  for (int i=0; i<M; ++i) {\n    char ch;\n    scanf(\" %c\", &ch);\n\n    if (ch == '?') {\n      int a, b;\n      scanf(\"%d %d\", &a, &b);\n      if (uf.connected(a, b)) {\n        printf(\"%jd\\n\", uf.relweight(b)-uf.relweight(a));\n      } else {\n        printf(\"UNKNOWN\\n\");\n      }\n    } else if (ch == '!') {\n      int a, b, w;\n      scanf(\"%d %d %d\", &a, &b, &w);\n      uf.unite(a, b, w);\n    }\n  }\n\n  return 0;\n}\n\nint main() {\n  while (!testcase_ends()) {}\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cmath>\n#include<queue>\n\nusing namespace std;\n\nconst int INF=0x3f3f3f3f;\nconst int top=100000+100;\n\n\nint w[top];\nint father[top];\nint dis[top],vis[top],head[top];\nint n;\nstruct edge\n{\n    int u,v,cost,next;\n}e[top*2];\nint cnt;\n\nvoid AddEdge(int u,int v,int c)\n{\n    e[cnt].u=u;\n    e[cnt].v=v;\n    e[cnt].cost=c;\n    e[cnt].next=head[u];\n    head[u]=cnt++;\n}\n\nint ser(int a,int b)\n{\n    memset(vis,0,(n+1)*sizeof(int));\n    int p1,p2,i;\n    queue<int> q;\n    vis[a]=1;\n    q.push(a);\n    dis[a]=0;\n    int ans=INF;\n    while(!q.empty())\n    {\n        p1=q.front();\n        q.pop();\n        for(i=head[p1];i!=-1;i=e[i].next)\n        {\n            p2=e[i].v;\n            if(!vis[p2])\n            {\n                dis[p2]=dis[p1]+e[i].cost;\n                q.push(p2);\n                if(p2==b)\n                {\n                    ans=dis[p2];\n                    break;\n                }\n                vis[p2]=1;\n            }\n        }\n        if(ans!=INF)\n            break;\n    }\n    return ans;\n}\nint main()\n{\n    int m;\n    int a,b,d;\n    int i;\n    char order[2];\n    while(scanf(\"%d%d\",&n,&m)&&n+m)\n    {\n        memset(head,-1,sizeof(head));\n        cnt=0;\n        for(i=0;i<m;i++)\n        {\n            scanf(\"%s\",order);\n            if(order[0]=='!')\n            {\n                scanf(\"%d%d%d\",&a,&b,&d);\n                AddEdge(a,b,d);\n                AddEdge(b,a,-d);\n            }\n            else\n            {\n                scanf(\"%d%d\",&a,&b);\n                int ans =ser(a,b);\n                if(ans==INF)\n                    printf(\"UNKNOWN\\n\");\n                else\n                {\n                    bool flag=true;\n                    for(int i1=head[a];i1!=-1;i1=e[i1].next)\n                    {\n                        if(e[i].v==b)\n                        {\n                            flag=false;\n                            break;\n                        }\n                    }\n                    if(flag)\n                    {\n                        AddEdge(a,b,ans);\n                        AddEdge(b,a,ans);\n                    }\n                    printf(\"%d\\n\",ans);\n                }\n            }\n        }\n    }\n    return 0;\n}\n\n/*\n4 7\n! 1 2 100\n! 2 3 100\n? 2 3\n? 1 3\n! 4 3 150\n? 4 1\n0 0\n*/"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\ntypedef long long lli;\ntypedef pair<int,lli> P;\n#define MAX 100001\n \n \nP par[MAX];\nlli rank[MAX];\n \nvoid init(int n=MAX){\n  for(int i=0;i<n;i++){\n    par[i]=P(i,0);\n    rank[i]=0;\n  }\n}\n\nP find(int x){\n  if(par[x].first==x)return par[x];\n  else {\n    lli tmp=par[x].second;\n    par[x]=find(par[x].first);\n    par[x].second+=tmp;\n    return par[x];\n  }\n}\n \nvoid unite(int x,int y,lli z){\n  P X=find(x),Y=find(y);\n  x=X.first;\n  y=Y.first;\n  if(x==y)return;\n  if(rank[x]<rank[y]){\n    par[x].first = y;\n    par[x].second = (z - X.second + Y.second);\n  }else{\n    par[y].first = x;\n    par[y].second = -(z - X.second + Y.second);\n    if(rank[x]==rank[y])rank[x]++;\n  }\n}\n \nint N,M;\n \nint main(){\n  while(cin>>N>>M){\n    if(N==0&&M==0)break;\n    init();\n    for(int i=0;i<M;i++){\n      char ch;\n      lli a,b,c;\n      cin>>ch>>a>>b;\n      if(ch=='?'){\n\tP A=find(a);\n\tP B=find(b);\n\tif(A.first!=B.first)cout<<\"UNKNOWN\"<<endl;\n\telse {\n\t  cout<< A.second - B.second <<endl;\n\t}\n      }else{\n\tcin>>c;\n\tunite(a,b,c);\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, a, n) for(ll i = ((ll) a); i < ((ll) n); i++)\nusing namespace std;\ntypedef long long ll;\n\nclass UnionFind {\npublic:\n  vector<ll> parent, weight;\n\n  UnionFind(ll n): parent(n), weight(n) {\n    REP(i, 0, n) parent[i] = i;\n  }\n\n  ll diff(ll i, ll j) {\n    find(i);\n    find(j);\n    return weight[j] - weight[i];\n  }\n\n  ll find(ll i) {\n    if(parent[i] == i) return i;\n    ll root = find(parent[i]);\n    weight[i] += weight[parent[i]];\n    parent[i] = root;\n    return root;\n  }\n\n  bool unite(ll i, ll j, ll w) {\n    ll pi = find(i), pj = find(j);\n    if(pi == pj) return false;\n\n    parent[j] = i;\n    weight[j] = w;\n    return true;\n  }\n};\n\nint main(void) {\n  ll N, M;\n  while(cin >> N >> M, N && M) {\n    UnionFind uf(N);\n    REP(i, 0, M) {\n      string T; cin >> T;\n      if(T != \"!\" && T != \"?\") while(1);\n      if(T == \"!\") {\n        ll A, B, W; cin >> A >> B >> W; A--; B--;\n        uf.unite(A, B, W);\n      } else {\n        ll A, B; cin >> A >> B; A--; B--;\n        if(uf.find(A) != uf.find(B)) cout << \"UNKNOWN\" << endl;\n        else cout << uf.diff(A, B) << endl;\n      }\n    }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <utility>\n#include <set>\n#include <map>\n#include <deque>\n#include <queue>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio>\n#include <stdio.h>\n\nusing namespace std;\n\n#define fo(i,n) for(int i=0; i<(int)n; i++)\n#define rep(it,s) for(__typeof((s).begin()) it=(s).begin();it!=(s).end();it++)\n#define mp(a,b) make_pair(a,b)\n#define pb(x) push_back(x)\n#define pii pair<int,int>\n\nint n,m;\nint par[100010];\nlong long w[100010];\n\nint get(int a) {\n\tif (a==par[a]) return a;\n\tint p = par[a];\n\tp = get(p);\n\tw[a] += w[par[a]];\n\tpar[a] = p;\n\treturn par[a];\n}\n\nvoid connect(int a, int b, int c) {\n\tpar[a] = b;\n\tw[a] = c;\n\tget(a);\n}\n\nint main() {\n\n    //freopen(\"input.txt\",\"r\",stdin);\n    //freopen(\"output.txt\",\"w\",stdout);\n\n\twhile (scanf(\"%d%d\",&n,&m) && n!=0) {\n\t\tfor (int i=0; i<n; i++) par[i] = i;\n\t\tfor (int i=0; i<n; i++) w[i] = 0;\n\t\t\n\t\tfor (int i=0; i<m; i++) {\n\t\t\tchar c[5];\n\t\t\tscanf(\"%s\",c);\n\t\t\tif (c[0]=='!') {\n\t\t\t\tint a,b,d;\n\t\t\t\tscanf(\"%d%d%d\",&a,&b,&d);\n\t\t\t\ta--; b--;\n\t\t\t\tif (get(a)==get(b)) continue;\n\t\t\t\tconnect(a,b,d);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tint a,b;\n\t\t\t\tscanf(\"%d%d\",&a,&b);\n\t\t\t\ta--; b--;\n\t\t\t\tif (get(a)!=get(b)) {\n\t\t\t\t\tprintf(\"UNKNOWN\\n\");\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tprintf(\"%lld\\n\",w[a]-w[b]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n    return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define all(v) (v).begin(), (v).end()\n#define reps(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define rep(i, n) reps(i, 0, n)\n\ntemplate<class T1, class T2> void chmin(T1 &a, T2 b){if(a>b)a=b;}\ntemplate<class T1, class T2> void chmax(T1 &a, T2 b){if(a<b)a=b;}\n\ntypedef pair<int, int> Pi;\ntypedef tuple<int, int, int> Ti;\ntypedef vector<int> vint;\n\nconst int inf = 1LL << 55;\nconst int mod = 1e9 + 7;\n\nstruct UF {\n  vector<Pi> data;\n  UF(int n):data(n, Pi(-1, 0)){}\n  Pi find(int x) {\n    //cout<<x<<\" \"<<data[x].first<<\" \"<<data[x].second<<endl;\n    if(data[x].first < 0) return Pi(x, 0);\n    Pi p = find(data[x].first);\n    //cout<<p.first<<\" \"<<p.second<<endl;\n    data[x].first = p.first;\n    data[x].second += p.second;\n    return data[x];//Pi(p.first, data[x].second);\n  }\n  void unite(int a, int b, int w) {\n    int x = find(a).first, y = find(b).first;\n    if(x == y) return;\n    if(data[x].first > data[y].first) swap(x, y), swap(a, b), w = -w;\n    w += data[a].second-data[b].second;\n    data[x].first += data[y].first;\n    data[y].first = x;\n    data[y].second += w;\n  }\n};\n\nsigned main()\n{\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  int N, M;\n  while(cin >> N >> M, N || M) {\n    UF uf(N);\n    rep(i, M) {\n      //cout << i << endl;\n      char c; int a, b, w;\n      cin >> c >> a >> b;\n      --a, --b;\n      if(c == '!') {\n\tcin >> w;\n\tuf.unite(a, b, w);\n      } else if(c == '?') {\n\tPi x = uf.find(a), y = uf.find(b);\n\tif(x.first != y.first) {\n\t  cout << \"UNKNOWN\" << endl;\n\t} else {\n\t  cout << y.second - x.second << endl;\n\t}\n      }\n    }\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n//#define _GLIBCXX_DEBUG\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n#define all(c) (c).begin(), (c).end()\n#define loop(i,a,b) for(ll i=a; i<ll(b); i++)\n#define rep(i,b) loop(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\ntemplate<class T> ostream & operator<<(ostream & os, vector<T> const &);\ntemplate<int n, class...T> typename enable_if<(n>=sizeof...(T))>::type _ot(ostream &, tuple<T...> const &){}\ntemplate<int n, class...T> typename enable_if<(n< sizeof...(T))>::type _ot(ostream & os, tuple<T...> const & t){ os << (n==0?\"\":\" \") << get<n>(t); _ot<n+1>(os, t); }\ntemplate<class...T> ostream & operator<<(ostream & os, tuple<T...> const & t){ _ot<0>(os, t); return os; }\ntemplate<class T, class U> ostream & operator<<(ostream & os, pair<T,U> const & p){ return os << \"(\" << p.first << \", \" << p.second << \") \"; }\ntemplate<class T> ostream & operator<<(ostream & os, vector<T> const & v){ rep(i,v.size()) os << v[i] << (i+1==(int)v.size()?\"\":\" \"); return os; }\n#ifdef DEBUG\n#define dump(...) (cerr<<#__VA_ARGS__<<\" = \"<<mt(__VA_ARGS__)<<\" [\"<<__LINE__<<\"]\"<<endl)\n#else\n#define dump(...)\n#endif\n\nll const inf = 1LL<<60;\n\ntypedef ll Weight;\nstruct UnionFindWeighted {\n    vector<int> par;\n    vector<Weight> ws;\n    int cnt;\n    UnionFindWeighted(int size_) : par(size_, -1), ws(size_, 0), cnt(size_) { }\n    bool set(int x, int y, Weight w) {\n        w += weight(x) - weight(y);\n        x = find(x); y = find(y);\n        if (x != y) {\n            if (par[y] < par[x]) swap(x, y), w = -w;\n            par[x] += par[y]; par[y] = x;\n            cnt--;\n            ws[y] = w;\n        }\n        return x != y;\n    }\n    bool get(int x, int y) {\n        return find(x) == find(y);\n    }\n    int find(int x) {\n        if(par[x] < 0){\n            return x;\n        } else {\n            int d = find(par[x]);\n            ws[x] += ws[par[x]];\n            return par[x] = d;\n        }\n    }\n    int size(int x) {\n        return -par[find(x)];\n    }\n    int size() {\n        return cnt;\n    }\n    Weight weight(int x){\n        find(x);\n        return ws[x];\n    }\n    Weight dist(int x, int y){ // x -> y の距離\n        return get(x,y) ? weight(x) - weight(y) : inf;\n    }\n};\n\nint main(){\n    int n,m;\n    while(cin >> n >> m && n){\n        UnionFindWeighted t(n+1);\n        rep(i,m){\n            char c;cin >> c;\n            if(c=='!'){\n                int a,b,w;\n                cin >> a >> b >> w;\n                t.set(a,b,w);\n            } else {\n                int a,b;\n                cin >> a >> b;\n                Weight ans = t.dist(b,a);\n                if(ans == inf) cout << \"UNKNOWN\";\n                else cout << ans;\n                cout << endl;\n            }\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <climits>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <queue>\n#include <random>\n#include <cctype>\n#include <complex>\n#include <regex>\n\nusing namespace std;\n\n#define C_MAX(a, b) ((a)>(b)?(a):(b))\n#define SHOW_VECTOR(v) {std::cerr << #v << \"\\t:\";for(const auto& xxx : v){std::cerr << xxx << \" \";}std::cerr << \"\\n\";}\n#define SHOW_MAP(v){std::cerr << #v << endl; for(const auto& xxx: v){std::cerr << xxx.first << \" \" << xxx.second << \"\\n\";}}\n\nstruct edge {\n    int to;\n    int cost;\n};\n\n#define MAX_N 100010\n\nstruct UnionFind {\n    vector<int> par;\n    vector<int> sizes;\n\n    UnionFind(int N) :\n            par(N), sizes(N, 1) {\n        for (int i = 0; i < N; i++) par[i] = i;\n    }\n\n    int find(int x) {\n        if (x == par[x]) return x;\n        else return par[x] = find(par[x]);\n    }\n\n    bool same(int x, int y) {\n        return find(x) == find(y);\n    }\n\n    void unite(int x, int y) {\n        x = find(x);\n        y = find(y);\n        if (x == y) return;\n        if (sizes[x] < sizes[y]) swap(x, y);\n        par[y] = x;\n        sizes[x] += sizes[y];\n    }\n\n    int getSize(int x) {\n        return sizes[x];\n    }\n\n};\n\nvector<vector<edge>> G;\n\nint dfs(int v, int t, int p, int cost) {\n    if (v == t) return cost;\n    for (int i = 0; i < G[v].size(); i++) {\n        if (G[v][i].to != p) {\n            int ret = dfs(G[v][i].to, t, v, cost + G[v][i].cost);\n            if (ret != INT_MAX) return ret;\n        }\n    }\n    return INT_MAX;\n}\n\nint main() {\n\n    while (true) {\n        int N, M;\n        cin >> N >> M;\n\n        if (!(N | M)) break;\n\n        UnionFind UF(N);\n        G = vector<vector<edge>>(MAX_N, vector<edge>());\n\n        for (int i = 0; i < M; i++) {\n\n            char ch;\n            cin >> ch;\n\n            if (ch == '!') {\n                int a, b, w;\n                cin >> a >> b >> w;\n                a--, b--;\n                if (!UF.same(a, b)) {\n                    G[a].push_back((edge) {b, w});\n                    G[b].push_back((edge) {a, -w});\n                    UF.unite(a, b);\n                }\n            }\n            if (ch == '?') {\n                int a, b;\n                cin >> a >> b;\n                a--, b--;\n                if (UF.same(a, b)) {\n                    int cost = 0;\n                    cost = dfs(a, b, -1, cost);\n                    cout << cost << endl;\n                } else {\n                    cout << \"UNKNOWN\" << endl;\n                }\n            }\n        }\n\n    }\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nclass WeightedDisjointSets\n{\nprivate:\n    using T = int;\n    vector<int> parent, rank;\n    vector<T> weight;\n\npublic:\n    WeightedDisjointSets(const int v) : parent(v), rank(v, 0), weight(v, 0) { iota(parent.begin(), parent.end(), 0); }\n    bool same(const int a, const int b) { return find(a) == find(b); }\n    int find(const int a)\n    {\n        if (parent[a] == a) { return a; }\n        const int r = find(parent[a]);\n        weight[a] += weight[parent[a]];\n        return parent[a] = find(r);\n        // return parent[a] == a ? a : (weight[a] += weight[parent[a]], parent[a] = find(parent[a]));\n    }\n    T getWeight(const int a) { return find(a), weight[a]; }\n    void unite(int a, int b, T d)\n    {\n        d += getWeight(a) - getWeight(b);\n        a = find(a), b = find(b);\n        if (a == b) { return; }\n        if (rank[a] < rank[b]) { swap(a, b), d = -d; }\n        if (rank[a] == rank[b]) { rank[a]++; }\n        parent[b] = a, weight[b] = d;\n    }\n    T diff(const int a, const int b) { return getWeight(b) - getWeight(a); }\n};\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while (true) {\n        int N, M;\n        cin >> N >> M;\n        if (N == 0 and M == 0) { break; }\n        WeightedDisjointSets uf(N);\n        for (int i = 0; i < M; i++) {\n            char c;\n            int a, b;\n            cin >> c >> a >> b;\n            a--, b--;\n            if (c == '!') {\n                int c;\n                cin >> c;\n                uf.unite(a, b, c);\n            } else {\n                cout << (uf.same(a, b) ? to_string(uf.diff(a, b)) : \"UNKNOWN\") << \"\\n\";\n            }\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cassert>\n#include<algorithm>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<29)\n#define MAX 1000000\nusing namespace std;\ntypedef long long ll;\nstruct P\n{\n  ll color,w;\n  P(ll color=-inf,ll w=-inf):color(color),w(w){}\n};\nP par[MAX];\nvoid init(){ rep(i,MAX)par[i] = P(i); }\n\nP find(int x)\n{\n  if(x == par[x].color)return par[x];\n  P p = find(par[x].color);\n  if(par[x].color == -inf)par[x].color = 0;\n  par[x].w += p.w,par[x].color = p.color;\n  return par[x];\n}\n\nvoid unit(int x,int y,ll w)//x <= y\n{\n  //cout << \"unit(\" << x << \",\" << y << \")\" << endl;\n  P X = find(x); \n  P Y = find(y);\n  //cout << \"X(\" << X.color << \",\" << X.w << \")\" << endl;\n  //cout << \"Y(\" << Y.color << \",\" << Y.w << \")\" << endl;\n  if(X.color == Y.color)return;\n  par[X.color].color = par[Y.color].color;\n  if(par[X.color].w == -inf)par[X.color].w = 0;\n  if(par[Y.color].w == -inf)par[Y.color].w = 0;\n  par[X.color].w = par[X.color].w - w/* + (Y.w != -inf?Y.w:0)*/;\n}\n\nint N,M;\n\nint main()\n{\n  while(cin >> N >> M,N|M)\n    {\n      init();\n      char c;\n      ll a,b,w;\n      rep(_,M)\n\t{\n\t  cin >> c;\n\t  if(c == '!')\n\t    {\n\t      cin >> a >> b >> w;\n\t      unit(a,b,w);\n\t    }\n\t  else\n\t    {\n\t      cin >> a >> b;\n\t      ll B = find(b).w;\n\t      ll A = find(a).w;\n\t      if(B == -inf || A == -inf)cout << \"UNKNOWN\" << endl;\n\t      else cout << B-A << endl;\n\t    }\n\n\t  rep(i,10)\n\t    {\n\t      // cout << i << \" = \" << par[i].color << \",\" << par[i].w << endl;\n\t    }\t\n\t  //cout << endl;\n\n\t}\n    }\n  return 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n#include <stack>\n#include <climits>\n#include <deque>\n#include <bitset>\n#include <cassert>\n#include <ctime>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int dy[]={-1,0,1,0},dx[]={0,1,0,-1};\n// adjust problem by problem\nconst double EPS=1e-8;\nconst double PI=acos(-1.0);\n#ifdef __GNUC__\nint popcount(int n){return __builtin_popcount(n);}\nint popcount(ll n){return __builtin_popcountll(n);}\n#endif\n#ifndef __GNUC__\ntemplate<class T> int popcount(T n){int cnt=0;while(n){if(n%2)cnt++;n/=2;}return cnt;}\n#endif\ntemplate<class T>int SIZE(T a){return a.size();}\ntemplate<class T>string IntToString(T num){string res;stringstream ss;ss<<num;return ss.str();}\ntemplate<class T>T StringToInt(string str){T res=0;for(int i=0;i<SIZE(str);i++)res=(res*10+str[i]-'0');return res;}\ntemplate<class T>T gcd(T a,T b){if(b==0)return a;return gcd(b,a%b);}\ntemplate<class T>T lcm(T a,T b){return a/gcd(a,b)*b;}\ntemplate<class T> void PrintSeq(T &a,int sz){for(int i=0;i<sz;i++){cout<<a[i];if(sz==i+1)cout<<endl;else cout<<' ';}}\nbool EQ(double a,double b){return abs(a-b)<EPS;}\nvoid fastStream(){cin.tie(0);std::ios_base::sync_with_stdio(0);}\nvector<string> split(string str,char del){\n  vector<string> res;\n  for(int i=0,s=0;i<SIZE(str);i++){\n    if(str[i]==del){if(i-s!=0)res.push_back(str.substr(s,i-s));s=i+1;}\n    else if(i==SIZE(str)-1){res.push_back(str.substr(s));}\n  }\n  return res;\n}\n\nstruct Query{\n  int a,b,c;\n  char kind;\n};\nQuery qs[200001];\n\nclass UnionFindTree{\nprivate:\n  // indexの数の親ノード(ある集合の親を見つけたいときはここを直接参照せず、findを使う)\n  vector<int> par;\n  // indexを根とする木のランク\n  vector<int> rank;\n  // 集合のサイズ\n  vector<int> cnts;\n  // 木の最大値\n  int treeSize;\npublic:\n  UnionFindTree(int initTreeSize = 1000){\n    // 引数で与えられた値を最大格納数とするUnionFindTreeの作成\n    treeSize = initTreeSize;\n    init();\n  }\n  void clear(){\n    for(int i=0;i<treeSize;i++)\n      par[i]=i,rank[i]=0,cnts[i]=1;\n  }\n  void init(){\n    for(int i = 0; i < treeSize; i++){\n      par.push_back(i);\n      rank.push_back(0);\n      cnts.push_back(1);\n    }\n  }\n  // 与えられた数が格納されている木のルートを探索\n  int find(int x){  \n    if(par[x] == x)return x;\n    else return par[x] = find(par[x]);\n  }\n  // 和集合をとる。ただしここでは各集合の親の付け替えは起こらない\n  void unite(int x,int y){\n    x = find(x);\n    y = find(y);\n    if(x == y)return;\n    if(rank[x] < rank[y]){\n      par[x] = y;\n      cnts[y]+=cnts[x];\n    }\n    else{\n      par[y] = x;\n      cnts[x]+=cnts[y];\n      if(rank[y] == rank[x])rank[x]++;\n    }\n  }\n  // xの属する集合のサイズ\n  int getCnt(int x){\n    return cnts[find(x)];\n  }\n  bool same(int x,int y){\n    return find(x) == find(y);\n  }\n    \n};\n\nstruct edge{\n  int to,cost;\n};\n\nint N,M;\nUnionFindTree uft(200001);\nvector<edge> G[200001];\nbool isConnected[200001];\nint vals[200001];\nbool used[200001];\n\nvoid bfs(int now){\n  queue<pii> q;\n  vals[now]=0;\n  used[now]=true;\n  q.push(pii(0,now));\n  while(q.size()){\n    pii p=q.front();q.pop();\n    int ccost=p.first;\n    int cpos=p.second;\n    for(int i=0;i<(int)G[cpos].size();i++){\n      edge &e=G[cpos][i];\n      int to=e.to;\n      int ncost=e.cost+ccost;\n      if(!used[to]){\n        vals[to]=ncost;\n        used[to]=true;\n        q.push(pii(ncost,to));\n      }\n    }\n  }\n}\n\nint main(){\n  fastStream();\n  while(cin>>N>>M&&(N|M)){\n    uft.clear();\n    for(int i=0;i<N;i++)G[i].clear();\n    for(int i=0;i<M;i++){\n      char ch;\n      int a,b,c;\n      cin>>ch;\n      if(ch=='?'){\n        cin>>a>>b;\n        a--,b--;\n        isConnected[i]=uft.same(a,b);\n        qs[i].a=a,qs[i].b=b,qs[i].kind=ch;\n      }\n      else{\n        cin>>a>>b>>c;\n        a--,b--;\n        qs[i].a=a,qs[i].b=b,qs[i].kind=ch;\n        qs[i].c=c;\n        edge e;\n        e.to=b;e.cost=c;\n        G[a].push_back(e);e.cost*=-1;e.to=a;\n        G[b].push_back(e);\n        uft.unite(a,b);\n      }\n    }\n    memset(vals,-1,sizeof(vals));\n    memset(used,0,sizeof(used));\n    for(int i=0;i<N;i++)if(!used[i])bfs(i);\n    for(int i=0;i<M;i++){\n      if(qs[i].kind=='!')continue;\n      if(!isConnected[i])cout<<\"UNKNOWN\"<<endl;\n      else{\n        int a=qs[i].a,b=qs[i].b;\n        cout<<-vals[a]+vals[b]<<endl;\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb push_back\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\n/*\ntime: less than O(NlogN+Q) amortized\nbased on weighted union heuristic\n*/\nstruct UnionFindTree{\n    vector<int>par,sz;\n\tvector<map<int,int>>diff;\n   UnionFindTree(int n){\n        par.resize(n);\n        sz.resize(n);\n\t\tdiff.resize(n);\n\t\n        for(int i=0;i<n;i++){\n            par[i]=i;\n            sz[i]=1;\n\t\t\tdiff[i][i]=0;\n        }\n    }\n    int find(int x){\n        return x==par[x]?x:par[x]=find(par[x]);\n    }\n    void unite(int a,int b,int w){\n        int x=find(a),y=find(b);\n        if(x==y)return;\n\t\tif(sz[x]<sz[y]){\n\t\t\tswap(x,y);\n\t\t\tswap(a,b);\n\t\t\tw*=-1;\n\t\t}\n\n\t\tw+=diff[x][a]-diff[y][b];\n\n\t\tfor(auto &p:diff[y]){\n\t\t\tdiff[x][p.fi]=p.se+w;\n\t\t}\n\t\tsz[x]+=sz[y];\n\t\tpar[y]=x;\n    }\n};\n\nint N,M;\n\n\n\nsigned main(){\n\twhile(scanf(\"%lld%lld\",&N,&M),N){\n\t\tUnionFindTree uf(N);\n\t\trep(i,M){\n\t\t\tchar c;\n\t\t\tscanf(\" %c\",&c);\n\t\t\tif(c=='!'){\n\t\t\t\tint a,b,w;\n\t\t\t\tscanf(\"%lld%lld%lld\",&a,&b,&w);\n\t\t\t\ta--;b--;\n\t\t\t\tuf.unite(a,b,w);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tint a,b;\n\t\t\t\tscanf(\"%lld%lld\",&a,&b);\n\t\t\t\ta--;b--;\n\t\t\t\tif(uf.find(a)!=uf.find(b)){\n\t\t\t\t\tputs(\"UNKNOWN\");\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tprintf(\"%lld\\n\",uf.diff[uf.find(b)][b]-uf.diff[uf.find(a)][a]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nconst int MAX = 100010;\n\nint n, m;\nchar s[10];\nint a, b, c;\nint father[MAX], Rank[MAX];\n\n\nvoid init(){\n\tfor(int i=1; i<=n; i++){\n\t\tfather[i] = i;\n\t\tRank[i] = 0;\n\t}\n}\n\nint find(int x){\n\tif(x != father[x]){\n\t\tfather[x] = find(father[x]);\n\t\tRank[x] += Rank[father[x]];\n\t}\n\treturn father[x];\n}\n\nvoid Union(int a, int b, int c){\n\tint aa = find(a), bb = find(b);\n\tif(aa != bb){\n\t\tif(!Rank[a] && !Rank[b]) father[bb] = aa, Rank[bb] = c + Rank[a];\n\t\telse if(!Rank[b]) father[bb] = aa, Rank[bb] = c + Rank[a];\n\t\telse father[aa] = bb, Rank[aa] = -c + Rank[b];\n\t}\n}\n\nint main(){\n\twhile(scanf(\"%d%d\", &n, &m) == 2){\n\t\tif(!n && !m) break;\n\t\tinit();\n\t\tfor(int i=0; i<m; i++){\n\t\t\tscanf(\"%s\", s);\n\t\t\tif(s[0] == '!'){\n\t\t\t\tscanf(\"%d%d%d\", &a, &b, &c);\n\t\t\t\tUnion(a, b, c);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tscanf(\"%d%d\", &a, &b);\n\t\t\t\tint aa = find(a), bb = find(b);\n\t\t\t\tif(aa != bb) puts(\"UNKNOWN\");\n\t\t\t\telse printf(\"%d\\n\", Rank[b]-Rank[a]);\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define f first\n#define s second\n#define mp make_pair\n#define inf 1<<30\n#define MAX 1000010\nusing namespace std;\n\nlong long p[MAX],w[MAX];\n\nint Find(int a){\n  if(p[a]==a)return a;\n  return Find(p[a]);\n}\n\npair<int,int> find(int a){\n  pair<int,int> pii;\n  if(p[a]==a){\n    pii.f=a;pii.s=0;\n    return pii;\n  }\n  pii=find(p[a]);\n  pii.s+=w[a];\n  p[a]=pii.f;\n  w[a]=pii.s;\n  return pii;\n}\n\nint main()\n{\n  int n,q,a,b,d;\n  char c;\n\n  while(cin>>n>>q && n ){\n\n    for(int i=0;i<n;i++){\n      p[i]=i;\n      w[i]=0;\n    }\n\n    for(int i=0;i<q;i++){\n      cin>>c;\n      if(c=='!'){\n\tcin>>a>>b>>d;\n\ta--;b--;\n\tint pa=Find(a);\n\tp[pa]=b;\n\tw[pa]=d;\n      }\n      else {\n\tcin>>a>>b;\n\ta--;b--;\n\tpair<int,int> pa=find(a),pb=find(b);\n\tif(pa.f!=pb.f)cout<<\"UNKNOWM\"<<endl;\n\telse {\n\t  p[a]=pa.f;\n\t  w[a]=pa.s;\n\t  p[b]=pb.f;\n\t  w[b]=pb.s;\n\t  cout<<pa.s-pb.s<<endl;\n\t}\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, a, n) for(ll i = ((ll) a); i < ((ll) n); i++)\nusing namespace std;\ntypedef long long ll;\n\nclass UnionFind {\npublic:\n  vector<ll> parent, weight;\n\n  UnionFind(ll n): parent(n), weight(n) {\n    REP(i, 0, n) parent[i] = i;\n  }\n\n  ll find(ll i) {\n    if(parent[i] == i) return i;\n    ll p = parent[i];\n    ll t = find(p);\n    parent[i] = t;\n    weight[i] += weight[p];\n    return t;\n  }\n\n  void unite(ll i, ll j, ll w) {\n    parent[i] = j;\n    weight[i] = -w;\n  }\n};\n\nint main(void) {\n  ll N, M;\n  while(cin >> N >> M, N && M) {\n    UnionFind uf(N);\n    REP(i, 0, M) {\n      string T; cin >> T;\n      if(T != \"!\" && T != \"?\") while(1);\n      if(T == \"!\") {\n        ll A, B, W; cin >> A >> B >> W; A--; B--;\n        uf.unite(A, B, W);\n      } else {\n        ll A, B; cin >> A >> B; A--; B--;\n        if(uf.find(A) != uf.find(B)) cout << \"UNKNOWN\" << endl;\n        else cout << uf.weight[B] - uf.weight[A] << endl;\n      }\n    }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<bitset>\n#include<algorithm>\nusing namespace std;\n#define MAX_N 100100\n\nclass uf_extention{\nprivate:\n\tint parents[MAX_N];\n\tint rank[MAX_N];\n\t//extention\n\tint dis[MAX_N][MAX_N];\npublic:\n\tuf_extention(){\n\t\tfor(int i=0;i<MAX_N;i++){\n\t\t\tparents[i]=i;\n\t\t\trank[i]=0;\n\t\t\t//extention\n\t\t\tfor(int j=0;j<MAX_N;j++){\n\t\t\t\tdis[i][j]=0;\n\t\t\t}\n\t\t}\n\t}\n\tuf_extention(int n){\n\t\tfor(int i=0;i<n;i++){\n\t\t\tparents[i]=i;\n\t\t\trank[i]=0;\n\t\t\t//extention\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tdis[i][j]=0;\n\t\t\t}\n\t\t\t\n\t\t}\n\t}\n\tint find(int x){\n\t\tif(parents[x]==x){\n\t\t\treturn x;\n\t\t}else{\n\t\t\t//extention\n\t\t\tint tmp=find(parents[x]);\n\t\t\t//cout<<\"find \"<<dis[x][parents[x]]<<\" \"<<dis[parents[x]][tmp]<<\" x=\"<<x<<\" p[x]=\"<<parents[x]<<\" tmp=\"<<tmp<<endl;\n\t\t\tdis[x][tmp]=dis[x][parents[x]]+dis[parents[x]][tmp];\n\t\t\tdis[tmp][x]=dis[x][tmp]*(-1);\n\t\t\treturn parents[x]=tmp;\n\t\t}\n\t}\n\tvoid unite(int x,int y,int distance){\n\t\t//cout<<\"unite\"<<x<<\" \"<<y<<\" dis=\"<<distance<<endl;\n\t\tdis[x][y]=distance;\n\t\tdis[y][x]=distance*(-1);\n\t\tint parx=find(x);\n\t\tint pary=find(y);\n\t\tif(parx==pary)return;\n\t\tdis[parx][pary]=dis[parx][x]+dis[x][y]+dis[y][pary];\n\t\tdis[pary][parx]=(-1)*dis[parx][pary];\n\t\tif(rank[parx]<rank[pary]){\n\t\t\t//cout<<parx<<\"'s parents is\"<<pary<<endl;\n\t\t\tparents[parx]=pary;\n\t\t}else{\n\t\t\t//cout<<pary<<\"'s parents is\"<<parx<<endl;\n\t\t\tparents[pary]=x;\n\t\t\tif(rank[parx]==rank[pary])rank[parx]++;\n\t\t}\n\t}\n\tint same(int x,int y){\n\t\t//cout<<\"same\"<<x<<\" \"<<y<<endl;\n\t\tint tmpx=find(x);\n\t\tint tmpy=find(y);\n\t\tif(tmpx==tmpy){\n\t\t\t//cout<<dis[x][tmpx]<<\" x=\"<<x<<\" tmpx=\"<<tmpx<<\" \"<<dis[tmpx][y]<<\" tmpy=\"<<tmpy<<\" y=\"<<y<<endl;\n\t\t\treturn dis[x][tmpx]+dis[tmpx][y];\n\t\t}else{\n\t\t\treturn -2000000;\n\t\t}\n\t}\n};\n\n\nint main(){\n\tchar c;\n\tint a,b,w;\n\tint n,m;\n\twhile(cin>>n>>m,n!=0||m!=0){\n\t\tuf_extention uf(n+1);\n\t\tfor(int i=0;i<m;i++){\n\t\t\tcin>>c;\n\t\t\tif(c=='!'){\n\t\t\t\tcin>>a>>b>>w;\n\t\t\t\tuf.unite(a,b,w);\n\t\t\t}else if(c=='?'){\n\t\t\t\tcin>>a>>b;\n\t\t\t\tint tmp=uf.same(a,b);\n\t\t\t\tif(tmp==-2000000){\n\t\t\t\t\tcout<<\"UNKNOWN\"<<endl;\n\t\t\t\t}else{\n\t\t\t\t\tcout<<tmp<<endl;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tcout<<\"???\"<<endl;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define each(itr,c) for(__typeof(c.begin()) itr=c.begin(); itr!=c.end(); ++itr)\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n\nstruct UF{\n    int n;\n    //??£?????£????????????????????????,????????£???????????§??£?????????????????°\n    vector<int> d;\n    // root??¨?????????????????????????????????\n    vector<int> w;\n\n    UF() {}\n    UF(int N):n(N), d(N,-1), w(N,0){}\n\n    int root(int v){\n        if(d[v]<0) return v;\n\n        int par = d[v];\n\n        int r = root(d[v]);\n        d[v] = r;\n        w[v] += w[par];\n\n        return d[v];\n    }\n    bool unite(int X,int Y,int W){\n        int rx = root(X), ry = root(Y);\n        if(rx==ry) return false;\n\n        int RW = -w[Y] + w[X] + W;\n\n        if(size(rx) < size(ry))\n        {\n            swap(rx,ry);\n            swap(X,Y);\n            RW = -RW;\n        }\n\n\n        d[rx]+=d[ry];\n        d[ry]=rx;\n\n        w[ry] = RW;\n\n        // printf(\" UNITE : %d -> %d : w[%d]=%d\\n\", ry,rx, ry, w[ry]);\n        return true;\n    }\n    int size(int v){ return -d[root(v)]; }\n    bool same(int X,int Y){ return root(X)==root(Y); }\n\n    int query(int X, int Y){\n        root(X);\n        root(Y);\n        // printf(\" query : %d -> %d  = %d\\n\", X,Y,w[Y]-w[X]);\n        return w[Y]-w[X];\n    }\n};\n\nint main()\n{\n    int n,m;\n    while(scanf(\" %d %d\", &n, &m),n)\n    {\n        UF uf(n);\n\n        while(m--)\n        {\n            char q;\n            int a,b;\n            scanf(\" %c %d %d\", &q, &a, &b);\n            --a;\n            --b;\n\n            if(q=='?')\n            {\n                if(!uf.same(a,b)) printf(\"UNKNOWN\\n\");\n                else printf(\"%d\\n\", uf.query(b,a));\n            }\n            else\n            {\n                int w;\n                scanf(\" %d\", &w);\n                uf.unite(b,a,w);\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for (int (i)=(0);(i)<(int)(n);++(i))\nusing ll = long long;\nusing P = pair<int, int>;\nusing namespace std;\n\n\n// 重み付きUnionFind\nstruct WeightUnionFind {\n    static const int Max = 101010;\n    int par[Max];\n    int ws[Max];\n\n    void init(int n) {\n        for (int i = 0; i < Max; ++i) {\n            par[i] = -1;\n            ws[i] = 0;\n        }\n    }\n\n    int find(int x) {\n        if (par[x] < 0) {\n            return x;\n        }\n        else {\n            int parent = find(par[x]);\n            ws[x] += ws[par[x]];\n            return par[x] = parent;\n        }\n    }\n\n    int weight(int x) {\n        find(x);\n        return ws[x];\n    }\n\n    void unite(int x, int y, int w) {\n        w += weight(x);\n        w -= weight(y);\n        x = find(x);\n        y = find(y);\n        if (x == y) return;\n        if (par[y] < par[x]) {\n            int tmp = x;\n            x = y;\n            y = tmp;\n            w = -w;\n        }\n        par[x] += par[y];\n        par[y] = x;\n        ws[y] = w;\n    }\n\n    bool same(int x, int y) {\n        return find(x) == find(y);\n    }\n\n    int diff(int x, int y) {\n        if (!same(x, y)) return -1e8;\n        return weight(y) - weight(x);\n    }\n    int size(int x) {\n        return -par[find(x)];\n    }\n};\n\nint main() {\n    int n, q;\n    WeightUnionFind uf;\n    while (cin >> n >> q and n and q) {\n        uf.init(n);\n        rep(i, q) {\n            char ch;\n            cin >> ch;\n            if (ch == '!') {\n                int x, y, z;\n                x--; y--;\n                cin >> x >> y >> z;\n                uf.unite(x, y, z);\n            }\n            else {\n                int x, y;\n                x--; y--;\n                cin >> x >> y;\n                if (uf.same(x, y)) {\n                    cout << uf.diff(x, y) << endl;\n                }\n                else {\n                    cout << \"UNKNOWN\" << endl;\n                }\n            }\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n//#define int long long\n#define reps(i,s,n) for(int (i)=(s);(i)<(n);++(i))\n#define rep(i,n) reps(i,0,n)\n#define rept(i,n) rep(i,(n)+1)\n#define repst(i,s,n) reps(i,s,(n)+1)\n#define reprt(i,n,t) for(int (i)=(n);(i)>=(t);--(i))\n#define repr(i,n) reprt(i,n,0)\n#define each(itr,v) for(auto &(itr):(v))\n#define all(c) (c).begin(),(c).end()\n#define rall(c) (c).rbegin(),(c).rend()\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define tmax(x,y,z) max(x,max(y,z))\n#define tmin(x,y,z) min(x,min(y,z))\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\n#define ln '\\n'\n#define bln(i,n) (((i)==(n)-1)?'\\n':' ')\n#define dbg(x) cout<<#x\" = \"<<(x)<<ln<<flush\n#define dbga(x,n) {cout<<#x\" : \";for(int (i)=0;i<(n);++i){cout<<((x)[i])<<(i==((n)-1)?'\\n':' ')<<flush;}}\n#define zero(a) memset(a,0,sizeof(a))\n#define unq(a) sort(all(a)),a.erase(unique(all(a)),a.end())\n\ntypedef complex<double> P;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<string> vst;\ntypedef vector<pii> vpii;\ntypedef vector<pll> vpll;\ntypedef vector<vector<int> > mat;\n\nconst ll inf = (ll)1e9+10;\nconst ll linf = (ll)1e18+10;\nconst ll mod = (ll)(1e9+7);\nconst int dx[] = {0, 1, 0, -1};\nconst int dy[] = {1, 0, -1, 0};\nconst int ddx[] = {0, 1, 1, 1, 0, -1, -1, -1};\nconst int ddy[] = {1, 1, 0, -1, -1, -1, 0, 1};\nconst double eps = 1e-10;\n\nll mop(ll a,ll b,ll m=mod) {ll r=1;a%=m;for(;b;b>>=1){if(b&1)r=r*a%m;a=a*a%m;}return r;}\nll gcd(ll a,ll b) {return b?gcd(b,a%b):a;}\nll lcm(ll a,ll b) {return a*b/gcd(a,b);}\nbool ool(int x,int y,int h,int w) {return((x<0)||(h<=x)||(y<0)||(w<=y));}\nbool deq(double a,double b) {return abs(a-b)<eps;}\n\nstruct oreno_initializer {\n\toreno_initializer() {\n\t\tcin.tie(0);\n\t\tios::sync_with_stdio(0);\n\t}\n} oreno_initializer;\n\n// ━━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…\n// .｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋\n// ・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・\n\n// !の時点で2点がufで繋がってなければUNKNOWN\n// そうじゃなければわかる わかるやつは最初にクエリ全部読み込んで距離求めておけばいい\n\nstruct UF {\n\tvector<int> p;\n\tUF(int n) : p(n, -1) {};\n\tbool unite(int u, int v) {\n\t\tif ((u = find(u)) == (v = find(v))) return false;\n\t\tif (p[u] > p[v]) swap(u, v);\n\t\tp[u] += p[v]; p[v] = u;\n\t\treturn true;\n\t}\n\tbool same(int u, int v) { return find(u) == find(v); }\n\tint find(int u) { return p[u] < 0 ? u : p[u] = find(p[u]); }\n\tint usize(int u) { return -p[find(u)]; }\n};\n\nint n, m, a[114514], b[114514], w[114514], ny[114514], d[114514];\nchar c[114514];\nbool ok[114514], us[114514];\nvpii e[114514];\n\nvoid rec(int v) {\n\tus[v] = 1;\n\teach(i,e[v]) if (!us[i.fi]) d[i.fi] = d[v] + i.se, rec(i.fi);\n}\n\nsigned main() {\n\twhile (1) {\n\t\tcin >> n >> m;\n\t\tif (n==0) break;\n\t\tUF uf(n);\n\t\tzero(ok), zero(us);\n\t\trep(i,n) e[i].clear();\n\t\trep (i,m) {\n\t\t\tcin >> c[i] >> a[i] >> b[i];\n\t\t\ta[i]--, b[i]--;\n\t\t\tif (c[i]=='!') {\n\t\t\t\tcin >> w[i];\n\t\t\t\tuf.unite(a[i],b[i]);\n\t\t\t\te[a[i]].pb({b[i],w[i]}), e[b[i]].pb({a[i],-w[i]});\n\t\t\t} else ok[i] = uf.same(a[i],b[i]);\n\t\t}\n\t\trep(i,n) if (!us[i]) d[i] = 0, rec(i);\n\t\trep(i,m) if (c[i]=='?') {\n\t\t\tif (ok[i]) cout << d[b[i]] - d[a[i]] << ln;\n\t\t\telse cout << \"UNKNOWN\" << ln;\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<bitset>\n#include<algorithm>\nusing namespace std;\n\nclass union_find{\nprivate:\n\tvector<int> parents;\n\tvector<int> rank;\n\tvector<int> weight;\npublic:\n\tunion_find(int n){\n\t\tfor(int i=0;i<n;i++){\n\t\t\tparents.push_back(i);\n\t\t\trank.push_back(0);\n\t\t\tweight.push_back(0);\n\t\t}\n\t}\n\tint find(int x){\n\t\tif(parents[x]==x){\n\t\t\treturn x;\n\t\t}else{\n\t\t\tint tmp=find(parents[x]);\n\t\t\tweight[x]=weight[x]+weight[parents[x]];\n\t\t\treturn parents[x]=tmp;\n\t\t}\n\t}\n\tvoid unite(int x,int y,int w){\n\t\tint tmpx=find(x);\n\t\tint tmpy=find(y);\n\t\tif(tmpx==tmpy)return;\n\t\tif(rank[tmpx]<rank[tmpy]){\n\t\t\tweight[tmpx]=w-weight[x]+weight[y];\n\t\t\tparents[tmpx]=tmpy;\n\t\t}else{\n\t\t\tweight[tmpy]=-w-weight[y]+weight[x];\n\t\t\tparents[tmpy]=tmpx;\n\t\t\tif(rank[tmpx]==rank[tmpy])rank[tmpx]++;\n\t\t}\n\t}\n\tint get_weight(int x,int y){\n\t\tif(find(x)==find(y)){\n\t\t\treturn weight[x]-weight[y];\n\t\t}else{\n\t\t\treturn -2000000;\n\t\t}\n\t}\n};\nint main(){\n\tchar c;\n\tint a,b,w;\n\tint n,m;\n\twhile(cin>>n>>m,n!=0||m!=0){\n\t\tunion_find uf(n+1);\n\t\tfor(int i=0;i<m;i++){\n\t\t\tcin>>c;\n\t\t\tif(c=='!'){\n\t\t\t\tcin>>a>>b>>w;\n\t\t\t\tuf.unite(a,b,w);\n\t\t\t}else if(c=='?'){\n\t\t\t\tcin>>a>>b;\n\t\t\t\tint tmp=uf.get_weight(a,b);\n\t\t\t\tif(tmp!=-2000000){\n\t\t\t\t\tcout<<tmp<<endl;\n\t\t\t\t}else{\n\t\t\t\t\tcout<<\"UNKNOWN\"<<endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(ll i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define show(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define show(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<ll,ll> pii;\ntemplate<typename T> using vec=std::vector<T>;\n\nconst int inf=1<<30;\nconst long long int infll=1LL<<62;\nconst double eps=1e-9;\nconst ll dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nclass union_find{\n\tprivate:\n\tvector<ll> parent,diff;\n    ll size;\n\tpublic:\n    union_find()=default;\n    union_find(ll n){ init(n); }\n\n    void init(ll n){\n\t\tsize=n;\n\t\tparent.resize(size);\n        diff.resize(size);\n\t\tfor(ll i=0; i<size; ++i){\n\t\t\tparent[i]=i;\n            diff[i]=0;\n\t\t}\n\t}\n\n\tpii find(ll x){\n\t\tif(parent[x]==x) return make_pair(x,0);\n        pii p=find(parent[x]);\n        parent[x]=p.first;\n        diff[x]+=p.second;\n        return make_pair(parent[x],diff[x]);\n\t}\n\n\tvoid unite(ll x,ll y,ll w){\n\t\tpii a=find(x),b=find(y);\n\t\tif(a.first==b.first) return;\n        parent[a.first]=b.first;\n        diff[a.first]=w;\n\t}\n\n\tbool is_same(ll x,ll y){\n\t\treturn find(x).first==find(y).first;\n\t}\n\n    ll calc_diff(ll x,ll y){\n        return find(x).second-find(y).second;\n    }\n};\n\nvoid solve(ll n,ll m){\n    union_find uf(n);\n\n    rep(i,0,m){\n        char ch;\n        ll a,b;\n        cin >> ch >> a >> b;\n        --a;\n        --b;\n        if(ch=='!'){\n            ll w;\n            cin >> w;\n            uf.unite(a,b,w);\n        }else{\n            if(!uf.is_same(a,b)) cout << \"UNKNOWN\" << endl;\n            else cout << uf.calc_diff(a,b) << endl;\n        }\n    }\n}\n\nint main(){\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    cout.setf(ios::fixed);\n    cout.precision(10);\n    while(true){\n        ll n,m;\n        cin >> n >> m;\n        if(!n and !m) break;\n        solve(n,m);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <memory.h>\n\nusing namespace std;\n\n//FILE *in = freopen(\"input.txt\", \"r\", stdin);\n//FILE *out = freopen(\"output.txt\", \"w\", stdout);\n\nint n, m;\n\nstruct UnionFind {\n\tvector<int> par; vector<int> rank;\n\tUnionFind(int n){\n\t\tpar = vector<int>(n);\n\t\trank = vector<int>(n);\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tpar[i] = i;\n\t\t}\n\t}\n\tint find(int x) {\n\t\tif(par[x]==x) return x;\n\t\telse return find(par[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif(x == y) return;\n\t\tif(rank[x]<rank[y])\n\t\t\tpar[x] = y;\n\t\telse {\n\t\t\tpar[y] = x;\n\t\t\tif(rank[x]==rank[y])rank[x]++;\n\t\t}\n\t}\n\tinline bool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n};\n\nint bfs(vector<vector<pair<int,int>>> data, int a, int b) {\n\tbool chk[100001];\n\tmemset(chk, 0, sizeof(chk));\n\tqueue<pair<int,int>> que;\n\tque.push(make_pair(a, 0));\n\tchk[a] = true;\n\twhile(!que.empty()){\n\t\tint cur = que.front().first;\n\t\tint val = que.front().second;\n\t\tque.pop();\n\t\tif(cur == b)\n\t\t\treturn val;\n\n\t\tfor(int i = 0; i < data[cur].size(); i++) {\n\t\t\tif(chk[data[cur][i].first]) continue;\n\t\t\tchk[data[cur][i].first] = true;\n\t\t\tque.push(make_pair(data[cur][i].first, val + data[cur][i].second));\n\t\t}\n\t}\n\treturn -1;\n}\n\nvoid process() {\n\tUnionFind uf(n+1);\n\tvector<vector<pair<int,int>>> data(n+1);\n\tchar tt[10];\n\tint a, b, c;\n\tfor(int k = 0; k < m; k++) {\n\t\tscanf(\"%s%d%d\", tt, &a, &b);\n\t\tif(tt[0] == '!') {\n\t\t\tscanf(\"%d\", &c);\n\t\t\tif(uf.same(a,b)) continue;\n\t\t\tdata[a].push_back(make_pair(b, c));\n\t\t\tdata[b].push_back(make_pair(a, -c));\n\t\t\tuf.unite(a,b);\n\t\t}\n\t\telse {\n\t\t\tif(!uf.same(a, b)) {\n\t\t\t\tprintf(\"UNKNOWN\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tprintf(\"%d\\n\", bfs(data, a, b));\n\t\t}\n\t}\n}\n\nint main() {\n\twhile(true){\n\t\tscanf(\"%d%d\", &n, &m);\n\t\tif(!n)break;\n\t\tprocess();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<stdio.h>\n\nusing namespace std;\nint p[100000];\nint rank[100000];\nint weight[100000];\n\n  void makeSet(int x){\n    p[x]=x;\n    rank[x]=0;\n    weight[x]=0;\n  }\n int findSet(int x){\n    if(x==p[x]){\n      return x;\n    }else{\n      return findSet(p[x]);\n    }\n  }\n  bool same(int x,int y){\n    return findSet(x)==findSet(y);\n  }\n  void link(int x,int y){   \n    p[x]=y;\n    if(rank[x]>=rank[y]){  \n      rank[y]=rank[x]+1;\n    }\n  }\n   void unite(int x,int y,int w){\n    weight[x]=w;\n    link(x,y);\n  }\n\n  int depth(int x){\n    int ans=0;\n    ans+=weight[x];\n    while(x!=p[x]){\n      ans+=weight[p[x]];\n      x=p[x];\n    }\n    return ans;\n  }\n\nint main(){\n  int n,m;\n  while(scanf(\"%d%d\",&n,&m)){\n    if(!n&&!m){\n      break;\n    }else{\n      char query[5];\n     for(int i=0;i<n;i++){\nmakeSet(i);\n}\n      for(int i=0;i<m;i++){\n        scanf(\"%s\",query);\n        if(query[0]=='!'){\n          int a,b,w;\n          scanf(\"%d%d%d\",&a,&b,&w);\n          unite(a,b,w);\n        }else{\n          int c,d;\n          scanf(\"%d%d\",&c,&d);\n          if(!same(c,d)){\n            printf(\"UNKNOWN\\n\");\n          }else{\n            printf(\"%d\\n\",depth(c)-depth(d));\n          }\n        }\n      }\n    }\n  }\n  return 0;\n}\n      "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\ntypedef long long ll;\nusing namespace std;\n\nconst int C = 100010;\nconst ll infty = 1e18;\npair<int, ll> P[C]; // root, diff: w_self - w_root\n\nvoid init(int N) {\n  for (auto i=0; i<N; i++) {\n    P[i] = make_pair(i, 0);\n  }\n}\n\npair<int, int> root(int a) {\n  if (P[a].first == a) return P[a];\n  pair<int, ll> t = root(P[a].first);\n  return (P[a] = make_pair(t.first, t.second + P[a].second));\n}\n\nll diff(int a, int b) { // a, bが同じ根を持つならw_b-w_aを、そうでないならinftyを返す。\n  if (root(a).first == root(b).first) {\n    return root(b).second - root(a).second;\n  }\n  return infty;\n}\n\nvoid weight(int a, int b, int w) { // w_b - w_aの値を登録する\n  pair<int, ll> ta = root(a);\n  pair<int, ll> tb = root(b);\n  P[root(b).first] = make_pair(ta.first, -tb.second + w + ta.second);\n}\n\nint main() {\n  int n, m;\n  while (cin >> n >> m && n) {\n    init(n);\n    for (auto i=0; i<m; i++) {\n      char c;\n      int a, b, w;\n      cin >> c;\n      if (c == '!') {\n        cin >> a >> b >> w;\n        weight(a, b, w);\n      } else {\n        cin >> a >> b;\n        int d = diff(a, b);\n        if (d < infty) {\n          cout << d << endl;\n        } else {\n          cout << \"UNKNOWN\" << endl;\n        }\n      }\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define PI       3.1415926535897932384626433832795028841971\n#define INF 1000000000\n#define EPS      1e-10\n#define MOD      1000000\nusing namespace std;\ntypedef long long ll;\ntypedef pair<double,double> P;\ntypedef pair<double,P> PQ;\n\nstruct Q{\n    int time,a, b;\n};\n\nstruct edge{\n    int time, to, w;\n};\n\nint n, m;\nint bss[100000];\nint rnk[100000];\nint num[100000];\nbool saw[100000];\nvector<edge> e[100000];\nvector<Q> q;\nint up[20][100000];\nint par[20][100000];\n\nvoid dfs(int v, int bos){\n    saw[v] = true;\n    rep(i,e[v].size()){\n        edge E = e[v][i];\n        if(saw[E.to]) continue;\n        up[0][E.to] = E.time;\n        rnk[E.to] = rnk[v]+1;\n        num[E.to] = num[v]+E.w;\n        bss[E.to] = bos;\n        par[0][E.to] = v;\n        dfs(E.to,bos);\n    }\n}\n\nint main(){\n    while(cin >> n >> m){\n        if(n == 0 && m == 0) break;\n        memset(bss,0,sizeof(bss));\n        memset(rnk,0,sizeof(rnk));\n        memset(num,0,sizeof(num));\n        memset(saw,0,sizeof(saw));\n        rep(i,100000) e[i].clear();\n        q.clear();\n        memset(up,0,sizeof(up));\n        rep(i,m){\n            char hoge;\n            int a, b, w;\n            cin >> hoge;\n            if(hoge == '!'){\n                cin >> a >> b >> w;\n                a--; b--;\n                e[a].push_back((edge){i,b,w});\n                e[b].push_back((edge){i,a,-w});\n            } else{\n                cin >> a >> b;\n                a--; b--;\n                q.push_back((Q){i,a,b});\n            }\n        }\n        rep(i,20){\n            rep(j,n) par[i][j] = i;\n        }\n        rep(i,n){\n            if(saw[i]) continue;\n            dfs(i,i);\n        }\n        for(int i = 1; i < 20; i++){\n            rep(j,n){\n                par[i][j] = par[i-1][j];\n                up[i][j] = max(up[i-1][j],up[i-1][par[i-1][j]]);\n            }\n        }\n        rep(i,q.size()){\n            Q p = q[i];\n            bool done = false;\n            if(bss[p.a] != bss[p.b]){\n                cout << \"UNKNOWN\" << endl;\n                continue;\n            }\n            int ans = num[p.b]-num[p.a];\n            if(rnk[p.a] > rnk[p.b]){\n                int dis = rnk[p.a]-rnk[p.b];\n                int z = 0;\n                while(dis > 0){\n                    if(dis&1){\n                        if(up[z][p.a] > p.time){\n                            done = true;\n                            cout << \"UNKNOWN\" << endl;\n                            break;\n                        }\n                        p.a = par[z][p.a];\n                    }\n                    z++;\n                    dis /= 2;\n                }\n            } else if(rnk[p.a] < rnk[p.b]){\n                int dis = rnk[p.b]-rnk[p.a];\n                int z = 0;\n                while(dis > 0){\n                    if(dis&1){\n                        if(up[z][p.b] > p.time){\n                            done = true;\n                            cout << \"UNKNOWN\" << endl;\n                            break;\n                        }\n                        p.b = par[z][p.b];\n                    }\n                    z++;\n                    dis /= 2;\n                }\n            }\n            if(done) continue;\n            if(p.a == p.b){\n                cout << ans << endl;\n                continue;\n            }\n            int common = 0;\n            for(int j = 19; j >= 0; j--){\n                if(par[j][p.a] == par[j][p.b]) continue;\n                common += (1<<j);\n            }\n            common++;\n            int z = 0;\n            while(common > 0){\n                if(common&1){\n                    if(up[z][p.a] > p.time){\n                        done = true;\n                        cout << \"UNKNOWN\" << endl;\n                        break;\n                    }\n                    if(up[z][p.b] > p.time){\n                        done = true;\n                        cout << \"UNKNOWN\" << endl;\n                        break;\n                    }\n                    p.a = par[z][p.a];\n                    p.b = par[z][p.b];\n                }\n                common /= 2;\n                z++;\n            }\n            if(done) continue;\n            cout << ans << endl;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define f first\n#define s second\n#define mp make_pair\n#define inf 1<<30\n#define MAX 1000010\nusing namespace std;\n\nlong long p[MAX],w[MAX];\n\npair<int,int> find(int a){\n  if(p[a]==a)return mp(a,0);\n  pair<int,int> pii=find(p[a]);\n  pii.s;\n  p[a]=pii.f;\n  w[a]+=pii.s;\n  return mp(p[a],w[a]);\n}\n\nvoid unit(int a,int b,int d){\n  pair<int,int> pa=find(a),pb=find(b);\n  if(pa.f==pb.f)return;\n  d-=w[b]-w[a];\n  p[pa.f]=pb.f;\n  w[pa.f]=d;\n}\n\nint main()\n{\n  int n,q,a,b,d;\n  char c;\n\n  while(cin>>n>>q && n ){\n\n    for(int i=0;i<n;i++){\n      p[i]=i;\n      w[i]=0;\n    }\n\n    for(int i=0;i<q;i++){\n      cin>>c;\n      if(c=='!'){\n\tcin>>a>>b>>d;\n\ta--;b--;\n        unit(a,b,d);\n      }\n      else {\n\tcin>>a>>b;\n\ta--;b--;\n\tpair<int,int> pa=find(a),pb=find(b);\n\tif(pa.f!=pb.f)cout<<\"UNKNOWN\"<<endl;\n\telse cout<<w[a]-w[b]<<endl;\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cassert>// c\n#include <ctime>\n#include <iostream>// io\n#include <iomanip>\n#include <fstream>\n#include <sstream>\n#include <vector>// container\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <algorithm>// other\n#include <complex>\n#include <numeric>\n#include <functional>\n#include <random>\n#include <regex>\n\nusing namespace std;\ntypedef long long ll;\n\n#define ALL(c) (c).begin(),(c).end()\n#define FOR(i,l,r) for(int i=(int)l;i<(int)r;++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORr(i,l,r) for(int i=(int)r-1;i>=(int)l;--i)\n#define REPr(i,n) FORr(i,0,n)\n#define EACH(i,c) for(__typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define IN(l,v,r) ((l)<=(v) && (v)<(r))\n#define UNIQUE(v) v.erase(unique(ALL(v)),v.end())\n//debug\n#define DUMP(x)  cerr << #x << \" = \" << (x)\n#define LINE()    cerr<< \" (L\" << __LINE__ << \")\"\n\ntemplate<typename T,typename U> T pmod(T x,U M){return (x%M+M)%M;}\n\n//verified by AOJ0118 \nstruct UnionFind{\n    vector<int> par,rank,ss;int size;\n    vector<int> ws;\n    UnionFind(int n){\n        REP(i,n) par.push_back(i);\n        rank = vector<int>(n);ss=vector<int>(n,1);size=n;\n\n        ws=vector<int>(n);\n    }\n    int root(int x){\n        if(par[x] == x)return x;\n        int r = root(par[x]); ws[x] += ws[par[x]];\n        return par[x] = r;\n    }\n    int val(int x){\n    \troot(x);return ws[x];\n    }\n    bool same(int x,int y){\n        return root(x) == root(y);\n    }\n    void unite(int x,int y,int w=0){\n    \tint vx=val(x),vy=val(y);\n        x = root(x);y = root(y);\n        if(x==y)return;\n        if(rank[x] < rank[y]){//root y\n        \tws[x] += w + vy;\n            par[x] = y;ss[y]+=ss[x];\n        }else{//root x\n        \tws[y] += -w +vx;\n            par[y] = x;ss[x]+=ss[y];\n        }\n        if(rank[x] == rank[y]) rank[x]++;\n        size--;\n    }\n    int getS(int x){\n        return ss[root(x)];\n    }\n};\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tcerr << fixed <<setprecision(20);\n\tcout << fixed <<setprecision(20);\n  while (true) {\n  \tint N,M;cin >> N >> M;if(N==0)break;\n  \tUnionFind uf(N);\n  \tREP(i,M){\n  \t\tchar c;int a,b,w;cin >> c >> a >> b;a--;b--;\n\t\n\t\tREP(i,N)cerr <<uf.par[i] <<\" \";cerr <<endl;\n  \t\tREP(i,N)cerr <<uf.val(i) <<\" \";cerr <<endl;\n  \t\tif(c=='!'){\n  \t\t\tcin >> w;\n  \t\t\tuf.unite(a,b,w);\n  \t\t}else{\n  \t\t\tif(!uf.same(a,b)){\n  \t\t\t\tcout <<\"UNKNOWN\"<<endl;\n  \t\t\t}else{\n  \t\t\t\tcout << uf.val(a)-uf.val(b) <<endl;\n  \t\t\t}\n  \t\t}\n  \t\t// cerr <<\"aaa\"<<endl;\n  \t}\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\ntypedef long long int lli;\n\nclass UnionFindTree{\npublic:\n    vector<int> v;\n    vector<int> rank;\n  \n    UnionFindTree(int n){\n        v = vector<int>(n);\n        rank = vector<int>(n, 0);\n        for(int i=0; i<n; i++) v[i]=i;\n    }\n    int Find(int x){\n        if(v[x] != x){\n            v[x] = Find(v[x]);\n        }\n        return v[x];\n    }\n    void Union(int a, int b){\n        a = Find(a);\n        b = Find(b);\n        if(rank[a] < rank[b]){\n            v[a] = b;\n        }else{\n            v[b] = a;\n            if(rank[a] == rank[b]){\n                rank[a]++;\n            }\n        }\n    }\n};\n\nint main(){\n\twhile(1){\n\t\tint n,m;\n\t\tcin >> n >> m;\n\t\tif(n==0) break;\n\t\t\n\t\tvector<lli> w(n+1);\n\t\tvector<bool> defined(n+1, false);\n\t\tUnionFindTree uft(n+1);\n\t\tfor(int i=0; i<m; i++){\n\t\t\tchar c;\n\t\t\tcin >> c;\n\t\t\tif(c=='?'){\n\t\t\t\tint a,b;\n\t\t\t\tcin >> a >> b;\n\t\t\t\tif(uft.Find(a) == uft.Find(b)){\n\t\t\t\t\tcout << w[b] -w[a] << endl;\n\t\t\t\t}else{\n\t\t\t\t\tcout << \"UNKNOWN\" << endl;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tint a,b;\n\t\t\t\tlli diff;\n\t\t\t\tcin >> a >> b >> diff;\n\t\t\t\tif(!defined[a]){\n\t\t\t\t\tswap(a, b);\n\t\t\t\t\tdiff = -diff;\n\t\t\t\t}\n\t\t\t\tif(!defined[a]){\n\t\t\t\t\tw[a] = 0;\n\t\t\t\t}\n\t\t\t\tdefined[a] = defined[b] = true;\n\t\t\t\tw[b] = w[a] +diff;\n\t\t\t\tuft.Union(a, b);\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define f first\n#define s second\n#define mp make_pair\n#define inf 1<<30\n#define MAX 1000010\nusing namespace std;\n\nlong long p[MAX],w[MAX];\n\npair<int,int> find(int a){\n  if(p[a]==a)return mp(a,0);\n  pair<int,int> pii=find(p[a]);\n  pii.s+=w[a];\n  p[a]=pii.f;\n  w[a]=pii.s;\n  return pii;\n}\n\nvoid unit(int a,int b,int d){\n  pair<int,int> pa=find(a),pb=find(b);\n  // if(pa.f==pb.f)return;\n  p[pa.f]=b;\n  w[pa.f]=d-pa.s+pb.s;\n}\n\nint main()\n{\n  int n,q,a,b,d;\n  char c;\n\n  while(cin>>n>>q && n ){\n\n    for(int i=0;i<n;i++){\n      p[i]=i;\n      w[i]=0;\n    }\n\n    for(int i=0;i<q;i++){\n      cin>>c;\n      if(c=='!'){\n\tcin>>a>>b>>d;\n\ta--;b--;\n        unit(a,b,d);\n      }\n      else {\n\tcin>>a>>b;\n\ta--;b--;\n\tpair<int,int> pa=find(a),pb=find(b);\n\tif(pa.f!=pb.f)cout<<\"UNKNOWM\"<<endl;\n\telse cout<<pa.s-pb.s<<endl;\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <deque>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <vector>\n#include <set>\n#include <limits>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < (int)(j); ++i)\n#define FOR(i, j, k) for(int i = (int)(j); i < (int)(k); ++i)\n#define SORT(v) sort((v).begin(), (v).end())\n#define REVERSE(v) reverse((v).begin(), (v).end())\ntypedef pair<int, int> P;\n#define DEBUG\n\nvector<int> v, parent, depth, dist;\n\n// P(parent, dist)\nP find(int a){\n  if(parent[a] == a) return P(a, 0);\n  P p = find(parent[a]);\n  parent[a] = p.first;\n  dist[a] += p.second;\n  return P(p.first, dist[a]);\n}\n\nvoid merge(int a, int b, int d){\n  P pa = find(a), pb = find(b);\n  if(pa.first == pb.first) return ;\n\n  if(depth[a] <= depth[b]){\n    parent[pb.first] = pa.first;\n    dist[pb.first] = d + pa.second;\n    if(depth[pa.first] == depth[pb.first]) ++depth[pb.first];\n  } else{\n    parent[pa.first] = pb.first;\n    dist[pa.first] = -(d + pa.second);\n  }\n}\n\nbool same(int a, int b){\n  return find(a).first == find(b).first;\n}\n\nvoid init_union_find(int V){\n  v = vector<int>(V);\n  parent = vector<int>(V);\n  depth = vector<int>(V, 0);\n  dist = vector<int>(V, 0);\n  REP(i, V) parent[i] = i;\n}\n\nint main() {\n  int N, M;\n  while(cin >>N >>M && N){\n    init_union_find(N);\n    REP(i, M){\n      char c; cin >>c;\n      if(c == '!'){\n        int x, y, z; cin >>x >>y >>z;\n        merge(x - 1, y - 1, z);\n      } else{\n        int x, y; cin >>x >>y;\n        P xp = find(x - 1), yp = find(y - 1);\n        if(xp.first != yp.first) cout <<\"UNKNOWN\" <<endl;\n        else cout <<yp.second - xp.second <<endl;\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include <sys/timeb.h>\n#include <fstream>\n\nusing namespace std;\n\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define replrev(i,a,b) for(int i=(int)(b)-1;i>=(int)(a);i--)\n#define reprev(i,n) replrev(i,0,n)\n#define repi(itr,ds) for(auto itr=ds.begin();itr!=ds.end();itr++)\n#define all(a) a.begin(),a.end()\n#define mp make_pair\n#define mt make_tuple\n#define INF 2000000000\n#define INFL 1000000000000000000LL\n#define EPS (1e-10)\n#define MOD 1000000007\n#define PI 3.1415926536\n#define RMAX 4294967295\n\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<bool> vb;\ntypedef vector<char> vc;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<P> vP;\ntypedef vector<vector<int> > vvi;\ntypedef vector<vector<bool> > vvb;\ntypedef vector<vector<ll> > vvll;\ntypedef vector<vector<char> > vvc;\ntypedef vector<vector<string> > vvs;\ntypedef vector<vector<double> > vvd;\ntypedef vector<vector<P> > vvP;\ntypedef priority_queue<int, vector<int>, greater<int> > pqli;\ntypedef priority_queue<ll, vector<ll>, greater<ll> > pqlll;\ntypedef priority_queue<P, vector<P>, greater<P> > pqlP;\nstruct Edge {\n\tint from, to, cost;\n\n\tbool operator<(Edge e) {\n\t\treturn cost < e.cost;\n\t}\n};\n\nvvi g2i;\nvi i2g;\nvi weight;\n\n\nint main() {\n\twhile (true) {\n\t\tint N, Q;\n\t\tcin >> N >> Q;\n\t\tif (N == 0)break;\n\t\tg2i = vvi(N);\n\t\ti2g = vi(N);\n\t\tweight = vi(N, 0);\n\n\t\trep(i, N) {\n\t\t\tg2i[i].push_back(i);\n\t\t\ti2g[i] = i;\n\t\t}\n\n\t\trep(q, Q) {\n\t\t\tchar ch;\n\t\t\tcin >> ch;\n\t\t\tif (ch == '!') {\n\t\t\t\tint a, b, w;\n\t\t\t\tcin >> a >> b >> w;\n\t\t\t\ta--; b--;\n\t\t\t\tif (i2g[a] == i2g[b])continue;\n\t\t\t\t//wb-wa=w\n\t\t\t\tif (g2i[i2g[a]].size() < g2i[i2g[b]].size()) {\n\t\t\t\t\tswap(a, b);\n\t\t\t\t\tw = -w;\n\t\t\t\t}\n\t\t\t\tw += weight[a] - weight[b];\n\t\t\t\t// gb???ga????§???????b?????°???????????¨??????w????????????\n\t\t\t\tint ga = i2g[a], gb = i2g[b];\n\t\t\t\trep(i, g2i[gb].size()) {\n\t\t\t\t\tweight[g2i[gb][i]] += w;\n\t\t\t\t\ti2g[g2i[gb][i]] = ga;\n\t\t\t\t}\n\t\t\t\tg2i[ga].insert(g2i[ga].end(), g2i[gb].begin(), g2i[gb].end());\n\t\t\t\tg2i[gb].clear();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tint a, b;\n\t\t\t\tcin >> a >> b;\n\t\t\t\ta--; b--;\n\t\t\t\tif (i2g[a] != i2g[b]) {\n\t\t\t\t\tcout << \"UNKNOWN\" << endl;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tcout << weight[b] - weight[a] << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<vector>\n\nusing namespace std;\n\nstruct parent{\n  int id, weightDiff;\n};\n\nvector<parent> UFtree;\n\nint root_Diff(int i) {\n  if(UFtree[i].id == i) return 0;\n  else return UFtree[i].weightDiff + root_Diff(UFtree[i].id);\n}\n\nint root(int i) {\n  if(UFtree[i].id == i) return i;\n  else {\n    UFtree[i].weightDiff = root_Diff(i);\n    return (UFtree[i].id = root(UFtree[i].id));\n  }\n}\n\nbool is_same_set(int i, int j) {\n  return root(i) == root(j);\n}\n\n\n\nvoid unite(int i, int j, int w) {//w_i-w_j = w\n  int x, y;\n  x = root(i); y = root(j);\n  UFtree[y].id = x;\n  UFtree[y].weightDiff = w + UFtree[i].weightDiff - UFtree[j].weightDiff;\n}\n\nint main() {\n  int N, M;\n  while(cin >> N >> M) {\n    if(!N) break;\n    parent zero;\n    UFtree.push_back(zero);\n    for(int i = 1; i <= N; i++){\n      parent p = {i, 0};\n      UFtree.push_back(p);\n    }\n    string word;\n    int a, b, w;\n    for(int i = 0; i < M; i++) {\n      cin >> word >> a >> b;\n      if(word == \"!\") {\n\tcin >> w;\n\tunite(b, a, w);\n      }\n      else {\n\tif(is_same_set(a, b)) cout << root_Diff(a) - root_Diff(b) << endl;\n\telse cout << \"UNKNOWN\" << endl;\n      }\n    }\n    UFtree.clear();\n    UFtree.shrink_to_fit();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<cassert>\n#include<cctype>\n#include<climits>\n#include<cmath>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<iostream>\n#include<iomanip>\n#include<map>\n#include<numeric>\n#include<queue>\n#include<vector>\n#include<set>\n#include<string>\n#include<stack>\n#include<sstream>\n#include<complex>\n\n#define pb push_back\n#define clr clear()\n#define sz size()\n#define fs first\n#define sc second\n\n#define rep(i,a) for(int i=0;i<(int)(a);i++)\n#define rrep(i,a) for(int i=(int)(a)−1;i>=0;i−−)\n#define all(a) (a).begin(),(a).end()\n#define EQ(a,b) (abs((a)−(b)) < EPS)\n#define INIT(a) memset(a,0,sizeof(a))\n\nusing namespace std;\ntypedef double D;\ntypedef pair<int,int> P;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\n\nconst D EPS = 1e-7;\nconst D INF = 1e9;\nconst D PI = acos(-1);\nconst int N = 100100;\n\nP par[N];\nint r[N];\n\nvoid init(int n){\n  for(int i=0;i<n;i++)par[i] = P(i,0);\n}\n\nP find(int a){\n  if(par[a].fs == a)return par[a];\n  P tmp = find(par[a].fs);\n  return par[a] = P(tmp.fs,tmp.sc + par[a].sc);\n}\n\nbool same(int a,int b){\n  return (find(a).fs == find(b).fs);\n}\n\nbool unite(int a,int b,int cost){\n  P x = find(a);\n  P y = find(b);\n  if(same(x.fs,y.fs)){\n    if(y.sc - x.sc != cost)return false;\n  }else{\n    if(r[x.fs]<r[y.fs]){\n      par[x.fs] = P(y.fs,y.sc-x.sc-cost);\n    }else{\n      par[y.fs] = P(x.fs,x.sc-y.sc+cost);\n      if(r[x.fs] == r[y.fs])r[x.fs]++;\n    }\n  }\n  return true;\n}\n\nint dis(int a, int b){\n  return find(b).sc - find(a).sc;\n}\n\nint main(){\n  int n,m;\n  int a,b,w;\n  char c;\n\n  while(cin >> n >> m,n){\n    init(n+1);\n    rep(i,m){\n      cin >> c;\n      if(c == '!'){\n\tcin >> a >> b >> w;\n\tunite(a,b,w);\n      }else{\n\tcin >> a >> b;\n\tif(!same(a,b))cout << \"UNKNOW\" << endl;\n\telse cout << dis(a,b) << endl;\n      }\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <utility>\n\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nconst int UNKNOWN=2000000;\nconst int MAX_N=100000,MAX_M=100000;\n\nint N,M;\nchar type[MAX_M+1];\nint a[MAX_M],b[MAX_M],w[MAX_M];\n\nint p[MAX_N],cost[MAX_N],height[MAX_N];\t//union find??¨\n\nvector<int> out;\n\nvoid init(int n){\n\tfor (int i=0;i<n;i++){\n\t\tp[i]=i;\n\t\tcost[i]=0;\n\t\theight[i]=0;\n\t}\n\treturn;\n}\n\nP find(int i){\n\t//????????????????????????\n\tif (i==p[i]){\n\t\treturn P(i,0);\t//first=?????????,second=?????????\n\t}\n\tP pa=find(p[i]);\n\tp[i]=pa.first;\n\tcost[i]+=pa.second;\n\treturn P(p[i],cost[i]);\n}\n\nvoid solve(){\n\tinit(N);\n\tfor (int i=0;i<M;i++){\n\t\tP roota=find(a[i]);\n\t\tP rootb=find(b[i]);\n\t\tif (type[i]=='!'){\n\t\t\tif (height[roota.first]<height[rootb.first]){\n\t\t\t\tp[roota.first]=rootb.first;\n\t\t\t\tcost[roota.first]=w[i]+rootb.second-roota.second;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tp[rootb.first]=roota.first;\n\t\t\t\tcost[rootb.first]=roota.second-rootb.second-w[i];\n\t\t\t\tif (height[roota.first]==height[rootb.first]){\n\t\t\t\t\theight[roota.first]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tif (roota.first!=rootb.first){\n\t\t\t\tout.push_back(UNKNOWN);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tout.push_back(roota.second-rootb.second);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\tdo{\n\t\tscanf(\"%d %d\",&N,&M);\n\t\tif (N || M){\n\t\t\tfor (int i=0;i<M;i++){\n\t\t\t\tscanf(\" %c %d %d\",&type[i],&a[i],&b[i]);\n\t\t\t\ta[i]--;\n\t\t\t\tb[i]--;\n\t\t\t\tif (type[i]=='!'){\n\t\t\t\t\tscanf(\"%d\",&w[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tsolve();\n\t\t}\n\t}while(N || M);\n\tfor (int i=0;i<out.size();i++){\n\t\tif (out[i]==UNKNOWN){\n\t\t\tprintf(\"%s\\n\",\"UNKNOWN\");\n\t\t}\n\t\telse{\n\t\t\tprintf(\"%d\\n\",out[i]);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/**\n * \n */\n\n// #include {{{\n#include <algorithm>\n#include <array>\n#include <bitset>\n#include <cassert>\n#include <cfloat>\n#include <cmath>\n#include <cstdint>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <forward_list>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <regex>\n#include <set>\n#include <stack>\n#include <string>\n#include <tuple>\n#include <type_traits>\n#include <unordered_map>\n#include <unordered_set>\n#include <utility>\n#include <vector>\n\n#ifdef DEBUG\n#include <fmt/format.h>\n#include <fmt/ostream.h>\n#endif\n\nusing namespace std;\n// }}}\n\n// type {{{\nusing  i8 =   int8_t;\nusing  u8 =  uint8_t;\nusing i16 =  int16_t;\nusing u16 = uint16_t;\nusing i32 =  int32_t;\nusing u32 = uint32_t;\nusing i64 =  int64_t;\nusing u64 = uint64_t;\n\ntemplate<typename T>\nusing max_heap = priority_queue<T, vector<T>, less<T>>;\ntemplate<typename T>\nusing min_heap = priority_queue<T, vector<T>, greater<T>>;\n// }}}\n\n// hide {{{\n#ifdef __clang__\n#pragma clang diagnostic push\n#pragma clang diagnostic ignored \"-Wunused-const-variable\"\n#endif\n// }}}\n\n// 適宜調整\n//#define int i64\n//#define double long double\n\nconstexpr bool AUTOFLUSH = false;\n\nconstexpr bool STDIO_ENABLE = false;\n\nconstexpr int IOS_PREC = 12;\n\nconstexpr int INF_I32 =             1'010'000'000;\nconstexpr i64 INF_I64 = 1'010'000'000'000'000'000LL;\n\nconstexpr auto   INF = INF_I64;\nconstexpr double EPS = 1e-12;\n\nconstexpr i64 MOD = 1'000'000'007;\n\n// hide {{{\n#ifdef __clang__\n#pragma clang diagnostic pop\n#endif\n// }}}\n\n// util {{{\nconstexpr i32 I32_MAX = numeric_limits<i32>::max();\nconstexpr i32 I32_MIN = numeric_limits<i32>::min();\n\nconstexpr i64 I64_MAX = numeric_limits<i64>::max();\nconstexpr i64 I64_MIN = numeric_limits<i64>::min();\n\ntemplate<typename T, size_t N, size_t... NS>\nstruct ArrayStruct {\n    using type = array<typename ArrayStruct<T,NS...>::type,N>;\n};\n\ntemplate<typename T, size_t N>\nstruct ArrayStruct<T,N> {\n    using type = array<T,N>;\n};\n\ntemplate<typename T, size_t N, size_t... NS>\nusing Array = typename ArrayStruct<T,N,NS...>::type;\n\ntemplate<typename T>\nint GETBIT(T x, int i) {\n    return (x>>i) & 1;\n}\n\ntemplate<typename T>\nvoid SETBIT(T& x, int i) {\n    x |= (T(1)<<i);\n}\n\ntemplate<typename T>\nvoid CLEARBIT(T& x, int i) {\n    x &= ~(T(1)<<i);\n}\n\ntemplate<typename T>\nconstexpr T ABS(T x) {\n    static_assert(is_signed<T>::value, \"ABS(): argument must be signed\");\n    return x < 0 ? -x : x;\n}\n\ntemplate<typename T>\nconstexpr T abs_diff(T x, T y) {\n    return x < y ? y-x : x-y;\n}\n\nconstexpr i64 MID(i64 x, i64 y) {\n    i64 lo = min(x, y);\n    i64 hi = max(x, y);\n\n    return (lo < 0 && hi >= 0) ? (lo+hi)/2 : lo + (hi-lo)/2;\n}\n\n// lo:OK, hi:NG\ntemplate<typename Pred>\ni64 bin_search(i64 lo, i64 hi, Pred pred) {\n    assert(lo < hi);\n\n    while(lo+1 < hi) {\n        i64 mid = MID(lo, hi);\n        if(pred(mid))\n            lo = mid;\n        else\n            hi = mid;\n    }\n    return lo;\n}\n\ntemplate<typename Pred>\ndouble bin_search_real(double lo, double hi, Pred pred, int iter=100) {\n    assert(lo < hi);\n\n    for(int i = 0; i < iter; ++i) {\n        double mid = (lo+hi) / 2.0;\n        if(pred(mid))\n            lo = mid;\n        else\n            hi = mid;\n    }\n    return lo;\n}\n\ntemplate<typename T>\nconstexpr bool is_odd(T x) {\n    return x % 2 != 0;\n}\n\ntemplate<typename T>\nconstexpr bool is_even(T x) {\n    return x % 2 == 0;\n}\n\ntemplate<typename T>\nconstexpr bool parity_same(T x, T y) {\n    return (is_odd(x) && is_odd(y)) || (is_even(x) && is_even(y));\n}\n\ntemplate<typename T>\nconstexpr int cmp(T x, T y) {\n    return (y < x) - (x < y);\n}\n\ntemplate<typename T>\nconstexpr int sgn(T x) {\n    return cmp(x, T(0));\n}\n\ntemplate<typename T>\nconstexpr T ipow(T a, T b) {\n    assert(b >= 0);\n    T res(1);\n    for(T i = 0; i < b; ++i)\n        res *= a;\n    return res;\n}\n\ntemplate<\n    typename T,\n    std::enable_if_t<\n        std::is_integral<T>::value &&\n        std::is_signed<T>::value, std::nullptr_t> = nullptr>\nconstexpr T div_ceil(T a, T b) {\n    return a/b + (((a<0)^(b>0)) && (a%b));\n}\n\ntemplate<\n    typename T,\n    std::enable_if_t<\n        std::is_integral<T>::value &&\n        std::is_unsigned<T>::value, std::nullptr_t> = nullptr>\nconstexpr T div_ceil(T a, T b) {\n    return a/b + !!(a%b);\n}\n\ntemplate<\n    typename T,\n    std::enable_if_t<\n        std::is_integral<T>::value &&\n        std::is_signed<T>::value, std::nullptr_t> = nullptr>\nconstexpr T div_floor(T a, T b) {\n    return a/b - (((a>0)^(b>0)) && (a%b));\n}\n\ntemplate<\n    typename T,\n    std::enable_if_t<\n        std::is_integral<T>::value &&\n        std::is_unsigned<T>::value, std::nullptr_t> = nullptr>\nconstexpr T div_floor(T a, T b) {\n    return a/b;\n}\n\ntemplate<typename T, typename U>\nconstexpr auto modulo(T a, U b) {\n    using R = common_type_t<T,U>;\n    assert(0 < b);\n    R r = a % b;\n    return r >= 0 ? r : r+b;\n}\n\ntemplate<typename T>\nconstexpr T clamp(T x, T lo, T hi) {\n    assert(lo <= hi);\n    if(x < lo)\n        return lo;\n    else if(hi < x)\n        return hi;\n    else\n        return x;\n}\n\ni64 isqrt(i64 x) {\n    assert(x >= 0);\n\n    i64 lo = 0;\n    i64 hi = 3037000500LL;\n    return bin_search(lo, hi, [x](i64 r) { return r*r <= x; });\n}\n\ntemplate<typename T, typename U>\nbool chmax(T& xmax, const U& x) {\n    if(xmax < x) {\n        xmax = x;\n        return true;\n    }\n    else {\n        return false;\n    }\n}\n\ntemplate<typename T, typename U>\nbool chmin(T& xmin, const U& x) {\n    if(x < xmin) {\n        xmin = x;\n        return true;\n    }\n    else {\n        return false;\n    }\n}\n\ntemplate<typename T>\nconstexpr int SIZE(const T& c) {\n    return static_cast<int>(c.size());\n}\n\ntemplate<typename T, size_t N>\nconstexpr int SIZE(const T (&)[N]) {\n    return static_cast<int>(N);\n}\n\ntemplate<typename InputIt, typename T>\nint argfind(InputIt first, InputIt last, const T& x) {\n    auto it = find(first, last, x);\n    return distance(first, it);\n}\n\ntemplate<typename InputIt>\nint argmax(InputIt first, InputIt last) {\n    auto it = max_element(first, last);\n    return distance(first, it);\n}\n\ntemplate<typename InputIt>\nint argmin(InputIt first, InputIt last) {\n    auto it = min_element(first, last);\n    return distance(first, it);\n}\n\ntemplate<typename InputIt>\nbool alltrue(InputIt first, InputIt last) {\n    return all_of(first, last, [](bool b) { return b; });\n}\n\ntemplate<typename InputIt>\nbool anytrue(InputIt first, InputIt last) {\n    return any_of(first, last, [](bool b) { return b; });\n}\n\ntemplate<typename InputIt>\nbool allfalse(InputIt first, InputIt last) {\n    return !anytrue(first, last);\n}\n\ntemplate<typename InputIt>\nbool anyfalse(InputIt first, InputIt last) {\n    return !alltrue(first, last);\n}\n\ntemplate<typename T>\narray<pair<T,T>,4> neighbor4(const T& x, const T& y) {\n    return array<pair<T,T>,4> {{\n                    { x, y-1 },\n        { x-1, y },             { x+1, y },\n                    { x, y+1 },\n    }};\n}\n\ntemplate<typename T>\narray<pair<T,T>,8> neighbor8(const T& x, const T& y) {\n    return array<pair<T,T>,8> {{\n        { x-1, y-1 }, { x, y-1 }, { x+1, y-1 },\n        { x-1, y   },             { x+1, y   },\n        { x-1, y+1 }, { x, y+1 }, { x+1, y+1 },\n    }};\n}\n\ntemplate<typename T>\nbool in_bounds(const T& x, const T& minx, const T& maxx) {\n    return !(x < minx) && !(maxx < x);\n}\n\ntemplate<typename T>\nbool in_bounds_2(\n    const T& x,    const T& y,\n    const T& minx, const T& miny,\n    const T& maxx, const T& maxy) {\n    return in_bounds(x, minx, maxx) && in_bounds(y, miny, maxy);\n}\n\ntemplate<typename T>\nbool in_bounds_wh(const T& x, const T& y, const T& w, const T& h) {\n    return in_bounds_2(x, y, 0, 0, w-1, h-1);\n}\n\nstruct pairhash {\n    template<typename T1, typename T2>\n    size_t operator()(const pair<T1,T2>& p) const {\n        size_t res = 17;\n        res = 31*res + hash<T1>()(p.first);\n        res = 31*res + hash<T2>()(p.second);\n        return res;\n    }\n};\n\nstruct vectorhash {\n    template<typename T>\n    size_t operator()(const vector<T>& v) const {\n        size_t res = 17;\n        res = 31*res + hash<size_t>()(v.size());\n        for(const auto& e : v) {\n            res = 31*res + hash<T>()(e);\n        }\n        return res;\n    }\n};\n\ntemplate<typename K, typename V>\npair<typename map<K,V>::iterator, bool> insert_or_assign(map<K,V>& m, const K& k, const V& v) {\n    auto it = m.lower_bound(k);\n    if(it != end(m) && !m.key_comp()(k,it->first)) {\n        it->second = v;\n        return make_pair(it, false);\n    }\n    else {\n        auto it_ins = m.insert(it, make_pair(k,v));\n        return make_pair(it_ins, true);\n    }\n}\n\ntemplate<typename K, typename V>\npair<typename unordered_map<K,V>::iterator, bool>\ninsert_or_assign(unordered_map<K,V>& m, const K& k, const V& v) {\n    auto it = m.find(k);\n    if(it != end(m)) {\n        it->second = v;\n        return make_pair(it, false);\n    }\n    else {\n        auto it_ins = m.insert(it, make_pair(k,v));\n        return make_pair(it_ins, true);\n    }\n}\n\ntemplate<typename T>\nstring TO_STRING(const T& x) {\n    ostringstream out;\n    out << x;\n    return out.str();\n}\n\ntemplate<typename InputIt>\nstring JOIN(InputIt first, InputIt last, const string& sep) {\n    ostringstream out;\n    while(first != last) {\n        out << *first++;\n        if(first != last)\n            out << sep;\n    }\n    return out.str();\n}\n\ntemplate<typename InputIt>\nauto SUM(InputIt first, InputIt last) {\n    using T = typename iterator_traits<InputIt>::value_type;\n    return accumulate(first, last, T());\n}\n\ntemplate<typename T>\nvoid UNIQ(T& c) {\n    c.erase(unique(begin(c), end(c)), end(c));\n}\n\ntemplate<typename T>\nvoid RD(T& x) {\n    cin >> x;\n#ifdef DEBUG\n    if(!cin) assert(false);\n#endif\n}\n\ntemplate<typename T>\nvoid RD(vector<T>& v, int n) {\n    v.reserve(n);\n    for(int i = 0; i < n; ++i) {\n        T e; RD(e);\n        v.emplace_back(e);\n    }\n}\n\n// 出力 {{{\n// FPRINTSEQ {{{\ntemplate<typename InputIt>\nostream& FPRINTSEQ(ostream& out, InputIt first, InputIt last) {\n    for(InputIt it = first; it != last; ++it) {\n        if(it != first) out << ' ';\n        out << *it;\n    }\n    return out;\n}\ntemplate<typename InputIt>\nostream& PRINTSEQ(InputIt first, InputIt last) {\n    return FPRINTSEQ(cout, first, last);\n}\ntemplate<typename InputIt>\nostream& DPRINTSEQ(InputIt first, InputIt last) {\n#ifdef DEBUG\n    FPRINTSEQ(cerr, first, last);\n#endif\n    return cerr;\n}\n// }}}\n\n// 1次元生配列 {{{\ntemplate<typename T, size_t N>\nostream& FPRINTARRAY1(ostream& out, const T (&c)[N]) {\n    return FPRINTSEQ(out, cbegin(c), cend(c));\n}\ntemplate<typename T, size_t N>\nostream& PRINTARRAY1(const T (&c)[N]) {\n    return FPRINTARRAY1(cout, c);\n}\ntemplate<typename T, size_t N>\nostream& DPRINTARRAY1(const T (&c)[N]) {\n#ifdef DEBUG\n    FPRINTARRAY1(cerr, c);\n#endif\n    return cerr;\n}\n// }}}\n\n// 2次元生配列 {{{\ntemplate<typename T, size_t N1, size_t N2>\nostream& FPRINTARRAY2(ostream& out, const T (&c)[N1][N2]) {\n    out << '\\n';\n    for(const auto& e : c) {\n        FPRINTARRAY1(out, e) << '\\n';\n    }\n    return out;\n}\ntemplate<typename T, size_t N1, size_t N2>\nostream& PRINTARRAY2(const T (&c)[N1][N2]) {\n    return FPRINTARRAY2(cout, c);\n}\ntemplate<typename T, size_t N1, size_t N2>\nostream& DPRINTARRAY2(const T (&c)[N1][N2]) {\n#ifdef DEBUG\n    FPRINTARRAY2(cerr, c);\n#endif\n    return cerr;\n}\n// }}}\n\n// 非mapコンテナ {{{\ntemplate<typename T>\nostream& operator<<(ostream& out, const vector<T>& c) {\n    return FPRINTSEQ(out, cbegin(c), cend(c));\n}\n\n// 特別扱い\ntemplate<typename T>\nostream& operator<<(ostream& out, const vector<vector<T>>& c) {\n    out << '\\n';\n    for(const auto& e : c) {\n        out << e << '\\n';\n    }\n    return out;\n}\n\n// 特別扱い\nostream& operator<<(ostream& out, const vector<string>& c) {\n    out << '\\n';\n    for(const string& e : c) {\n        out << e << '\\n';\n    }\n    return out;\n}\n\ntemplate<typename T>\nostream& operator<<(ostream& out, const deque<T>& c) {\n    return FPRINTSEQ(out, cbegin(c), cend(c));\n}\n\ntemplate<typename T>\nostream& operator<<(ostream& out, const list<T>& c) {\n    return FPRINTSEQ(out, cbegin(c), cend(c));\n}\n\ntemplate<typename T>\nostream& operator<<(ostream& out, const forward_list<T>& c) {\n    return FPRINTSEQ(out, cbegin(c), cend(c));\n}\n\ntemplate<typename T>\nostream& operator<<(ostream& out, const set<T>& c) {\n    return FPRINTSEQ(out, cbegin(c), cend(c));\n}\n\ntemplate<typename T>\nostream& operator<<(ostream& out, const unordered_set<T>& c) {\n    return out << set<T>(cbegin(c), cend(c));\n}\n\ntemplate<typename T>\nostream& operator<<(ostream& out, const multiset<T>& c) {\n    return FPRINTSEQ(out, cbegin(c), cend(c));\n}\n\ntemplate<typename T>\nostream& operator<<(ostream& out, const unordered_multiset<T>& c) {\n    return out << multiset<T>(cbegin(c), cend(c));\n}\n\ntemplate<typename T, size_t N>\nostream& operator<<(ostream& out, const array<T,N>& c) {\n    return FPRINTSEQ(out, cbegin(c), cend(c));\n}\n// }}}\n\n// mapコンテナ {{{\ntemplate<typename InputIt>\nostream& FPRINTMAP(ostream& out, InputIt first, InputIt last) {\n    out << \"{\\n\";\n    for(auto it = first; it != last; ++it) {\n        out << \"  \" << it->first << \" : \" << it->second << '\\n';\n    }\n    out << \"}\\n\";\n    return out;\n}\ntemplate<typename InputIt>\nostream& PRINTMAP(InputIt first, InputIt last) {\n    return FPRINTMAP(cout, first, last);\n}\ntemplate<typename InputIt>\nostream& DPRINTMAP(InputIt first, InputIt last) {\n#ifdef DEBUG\n    FPRINTMAP(cerr, first, last);\n#endif\n    return cerr;\n}\n\ntemplate<typename K, typename V>\nostream& operator<<(ostream& out, const map<K,V>& c) {\n    return FPRINTMAP(out, cbegin(c), cend(c));\n}\n\ntemplate<typename K, typename V>\nostream& operator<<(ostream& out, const unordered_map<K,V>& c) {\n    return out << map<K,V>(cbegin(c), cend(c));\n}\n\ntemplate<typename K, typename V>\nostream& operator<<(ostream& out, const multimap<K,V>& c) {\n    return FPRINTMAP(out, cbegin(c), cend(c));\n}\n\ntemplate<typename K, typename V>\nostream& operator<<(ostream& out, const unordered_multimap<K,V>& c) {\n    return out << multimap<K,V>(cbegin(c), cend(c));\n}\n// }}}\n\n// stack/queue/priority_queue {{{\ntemplate<typename T, typename C>\nostream& operator<<(ostream& out, stack<T,C> c) {\n    while(!c.empty()) {\n        out << c.top();\n        c.pop();\n        if(!c.empty()) out << ' ';\n    }\n    return out;\n}\n\ntemplate<typename T, typename C>\nostream& operator<<(ostream& out, queue<T,C> c) {\n    while(!c.empty()) {\n        out << c.front();\n        c.pop();\n        if(!c.empty()) out << ' ';\n    }\n    return out;\n}\n\ntemplate<typename T, typename Cont, typename Cmp>\nostream& operator<<(ostream& out, priority_queue<T,Cont,Cmp> c) {\n    while(!c.empty()) {\n        out << c.top();\n        c.pop();\n        if(!c.empty()) out << ' ';\n    }\n    return out;\n}\n// }}}\n\n// pair/tuple {{{\ntemplate<typename T1, typename T2>\nostream& operator<<(ostream& out, const pair<T1,T2>& p) {\n    return out << '(' << p.first << ',' << p.second << ')';\n}\n\ntemplate<typename Tuple, size_t Pos>\nostream& FPRINTTUPLE(ostream& out, const Tuple&) {\n    return out;\n}\n\ntemplate<typename Tuple, size_t Pos, typename T, typename... TS>\nostream& FPRINTTUPLE(ostream& out, const Tuple& t) {\n    if(Pos != 0)\n        out << ',';\n    out << get<Pos>(t);\n    return FPRINTTUPLE<Tuple,Pos+1,TS...>(out, t);\n}\n\ntemplate<typename... TS>\nostream& operator<<(ostream& out, const tuple<TS...>& t) {\n    out << '(';\n    FPRINTTUPLE<tuple<TS...>,0,TS...>(out, t);\n    out << ')';\n    return out;\n}\n// }}}\n\n// PRINT {{{\nostream& FPRINT(ostream& out) { return out; }\n\ntemplate<typename T, typename... TS>\nostream& FPRINT(ostream& out, const T& x, const TS& ...args) {\n    out << x;\n    if(sizeof...(args))\n        out << ' ';\n    return FPRINT(out, args...);\n}\n\ntemplate<typename... TS>\nostream& FPRINTLN(ostream& out, const TS& ...args) {\n    FPRINT(out, args...);\n    return out << '\\n';\n}\n\ntemplate<typename... TS>\nostream& PRINT(const TS& ...args) {\n    return FPRINT(cout, args...);\n}\n\ntemplate<typename... TS>\nostream& PRINTLN(const TS& ...args) {\n    return FPRINTLN(cout, args...);\n}\n\ntemplate<typename... TS>\nostream& DPRINT(const TS& ...args) {\n#ifdef DEBUG\n    FPRINT(cerr, args...);\n#endif\n    return cerr;\n}\n\ntemplate<typename... TS>\nostream& DPRINTLN(const TS& ...args) {\n#ifdef DEBUG\n    FPRINTLN(cerr, args...);\n#endif\n    return cerr;\n}\n// }}}\n// }}}\n\nvoid FLUSH() {\n    if(STDIO_ENABLE)\n        fflush(stdout);\n    else\n        cout.flush();\n}\n\n[[noreturn]] void EXIT() {\n#ifdef DEBUG\n    fflush(stdout);\n    fflush(stderr);\n    cout.flush();\n    cerr.flush();\n#else\n    FLUSH();\n#endif\n    //quick_exit(0); // does not work on codeforces\n    _Exit(0);\n}\n\nstruct IoInit {\n    IoInit() {\n#ifndef DEBUG\n        cin.tie(nullptr);\n        if(!STDIO_ENABLE)\n            ios::sync_with_stdio(false);\n#endif\n        cout << fixed << setprecision(IOS_PREC);\n\n        if(AUTOFLUSH) {\n            if(STDIO_ENABLE)\n                setvbuf(stdout, nullptr, _IONBF, 0);\n            cout << unitbuf;\n        }\n    }\n} IOINIT;\n\n#define FOR(i, start, end) for(i64 i = (start); i < (end); ++i)\n#define REP(i, n) FOR(i, 0, n)\n\n#define ALL(f,c,...) (([&](decltype((c)) cc) { return (f)(begin(cc), end(cc), ## __VA_ARGS__); })(c))\n\n#define GENERIC(f) ([](auto&&... args) -> decltype(auto) { return (f)(forward<decltype(args)>(args)...); })\n\n#define MEMSET(a,v) memset((a), (v), sizeof(a))\n\n#define DBG(x) DPRINTLN('L', __LINE__, ':', #x, ':', (x))\n// }}}\n\nclass WeightedUnionFind {\npublic:\n    vector<i64> p;\n    vector<i64> w;\n    i64         n_set;\n\n    WeightedUnionFind(i64 n) : p(n, -1), w(n, 0), n_set(n) {}\n\n    i64 node_count() const { return SIZE(p); }\n\n    i64 set_count() const { return n_set; }\n\n    i64 set_size(i64 x) { return -p[root(x)]; }\n\n    bool is_root(i64 x) const { return p[x] < 0; }\n\n    i64 root(i64 x) {\n        if(is_root(x)) return x;\n        compress(x);\n        return p[x];\n    }\n\n    i64 weight(i64 x) {\n        compress(x);\n        return w[x];\n    }\n\n    bool unite(i64 x, i64 y, i64 d) {\n        i64 rx = root(x);\n        i64 ry = root(y);\n        i64 wx = weight(x);\n        i64 wy = weight(y);\n\n        if(rx == ry) {\n            return wx + d == wy;\n        }\n\n        if(set_size(rx) < set_size(ry)) {\n            swap(rx, ry);\n            swap(wx, wy);\n            d *= -1;\n        }\n        p[rx] += p[ry];\n        p[ry]  = rx;\n        w[ry]  = wx - wy + d;\n\n        return true;\n    }\n\n    bool same(i64 x, i64 y) {\n        return root(x) == root(y);\n    }\n\nprivate:\n    void compress(i64 x) {\n        if(is_root(x)) return;\n        while(!is_root(p[x])) {\n            i64 pnew = p[p[x]];\n            i64 wnew = w[p[x]] + w[x];\n            p[x] = pnew;\n            w[x] = wnew;\n        }\n    }\n};\n\nvoid solve(i64 N, i64 M) {\n    WeightedUnionFind uf(N);\n\n    REP(_, M) {\n        char c;  RD(c);\n        i64 a,b; RD(a); RD(b); --a; --b; // 0-based\n        if(c == '!') {\n            i64 w; RD(w);\n            if(!uf.unite(a, b, w)) {\n                assert(false);\n            }\n        }\n        else if(c == '?') {\n            if(!uf.same(a, b)) {\n                PRINTLN(\"UNKNOWN\");\n            }\n            else {\n                i64 ans = uf.weight(b) - uf.weight(a);\n                PRINTLN(ans);\n            }\n        }\n        else {\n            assert(false);\n        }\n    }\n}\n\nsigned main(signed /*argc*/, char** /*argv*/) {\n    while(true) {\n        i64 N, M; RD(N); RD(M);\n        if(N == 0 && M == 0) break;\n        solve(N, M);\n    }\n\n    EXIT();\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int MAXN=110000;\n\nint n,m;\nchar str[5];\n\nint p[MAXN];\nlong long weight[MAXN];\nint find(int u)\n{\n\tif(u==p[u])return u;\n\telse\n\t{\n\t\tint root=find(p[u]);\n\t\tweight[u]+=weight[p[u]];\n\t\treturn p[u]=root;\n\t}\n\n}\n\nint main()\n{\n\twhile(scanf(\"%d%d\",&n,&m))\n\t{\n\t\tif(0==n&&0==m)break;\n\n\t\tint i;\n\t\t//init;\n\t\tfor(i=1;i<=n;i++)\n\t\t{\n\t\t\tp[i]=i;\n\t\t\tweight[i]=0;\n\t\t}\n\n\t\tint start,end,w;\n\t\tfor(i=0;i<m;i++)\n\t\t{\n\t\t\tscanf(\"%s\",str);\n\t\t\tif(!strcmp(str,\"!\"))\n\t\t\t{\n\t\t\t\tscanf(\"%d%d%d\",&start,&end,&w);\n\t\t\t\tint x=find(start);\n\t\t\t\tint y=find(end);\n\t\t\t\tif(y!=x)\n\t\t\t\t{\n\t\t\t\t\tp[y]=x;\n\t\t\t\t\tweight[y]=w+weight[start]-weight[end];\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(!strcmp(str,\"?\"))\n\t\t\t{\n\t\t\t\tscanf(\"%d%d\",&start,&end);\n\t\t\t\tint x=find(start);\n\t\t\t\tint y=find(end);\n\t\t\t\tif(x!=y)printf(\"UNKNOWN\\n\");\n\t\t\t\telse printf(\"%d\\n\",weight[end]-weight[start]);\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<map>\nusing namespace std;\n\nclass UF {\n    public:\n    vector<pair<int,int> > l;\n    UF(int n) {\n        for(int i=0; i<n; i++)\n            l.push_back(pair<int,int>(i,0));\n    }\n    pair<int,int> root(int x) {\n        if(x == l[x].first) return l[x];\n        pair<int,int> t = root(l[x].first);\n        l[x].first = t.first ;\n        l[x].second+= t.second;\n        return l[x];\n    }\n    void unite(int x, int y, int xMy) {\n        pair<int,int> s=root(x),t = root(y);\n        x = s.first;\n        y = t.first;\n        if(x == y) return;\n        l[y].first = l[x].first;\n        l[y].second= -xMy + s.second - t.second;\n    }\n    int weight(int x, int y) { // x - y else 123456\n        pair<int,int> s,t;\n        s = root(x);\n        t = root(y);\n        if(s.first != t.first) return 123456;\n        return s.second - t.second;\n    }\n};\n\n\nint main(void) {\n    while(1) {\n        int n,m;\n        scanf(\"%d%d\",&n,&m);\n        if(!n) break;\n        UF uf(n);\n        for(int i=0; i<m; i++) {\n            int a,b;\n            char s[3];\n            scanf(\"%s%d%d\",s,&a,&b);\n            a--, b--;\n            if(s[0] == '?') {\n                int w = uf.weight(b,a);\n                if(w == 123456)\n                    printf(\"UNKNOWN\\n\");\n                else\n                    printf(\"%d\\n\", w);\n            }\n            else {\n                int w;\n                scanf(\"%d\",&w);\n                uf.unite(b, a, w);\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 29;\n\nconst int nmax=100010;\nint par[nmax],ranks[nmax],weight[nmax];\n\nvoid init(int n){rep(i,n) par[i]=i,ranks[i]=0,weight[i]=0;}\nint find(int x,int &w){\n\tif(par[x]==x)\n\t\treturn x;\n\telse{\n\t\tw+=weight[x];\n\t\treturn find(par[x],w);\n\t}\n}\n\nvoid unite(int a,int b,int c){\n\tint wa=0,wb=0;\n\tint pa=find(a,wa);\n\tint pb=find(b,wb);\n\tif(ranks[pa]<ranks[pb]){\n\t\tpar[pa]=pb;\n\t\tweight[pa]=wb-wa+c;\n\t}else{\n\t\tpar[pb]=pa;\n\t\tweight[pb]=wa-wb-c;\n\t\tif(ranks[pa]==ranks[pb]) ranks[pb]++;\n\t}\n}\n\nbool same(int a,int b,int& ans){\n\tint wa=0,wb=0;\n\tint pa=find(a,wa);\n\tint pb=find(b,wb);\n\tans=wa-wb;\n\tcout << \" \" <<  pa << \" \" << pb << endl;\n\treturn pa==pb;\n}\n\nint main(void){\n\tint n,m;\n\twhile(cin >> n >> m,n){\n\t\tinit(n);\n\t\trep(i,m){\n\t\t\tchar cmd;\n\t\t\tcin >> cmd;\n\t\t\tif(cmd=='!'){\n\t\t\t\tint a,b,c;\n\t\t\t\tcin >> a >> b >> c;\n\t\t\t\tunite(a-1,b-1,c);\n\t\t\t}else{\n\t\t\t\tint a,b,ans;\n\t\t\t\tcin >> a >> b;\n\t\t\t\tif(same(a-1,b-1,ans))\n\t\t\t\t\tcout << ans << endl;\n\t\t\t\telse\n\t\t\t\t\tcout << \"UNKNOWN\" << endl;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\nconst int S = 100010;\n\nstruct UnionFind {\n    vector<int> node;\n    vector<ll> weight;\n    UnionFind() : node(S, -1), weight(S, 0) {}\n    void unite(int u, int v, ll w) {\n      int wa = weight[v], wb = weight[u];\n      u = find(u), v = find(v);  \n      if(u == v) return;\n\n        // (v テ」ツ?ョティツヲツェ) テ」ツつ?(u テ」ツ?ョティツヲツェ) テ」ツ?ォテ」ツ?、テ」ツ?ェテ」ツ?津」ツつ?\n        node[u] += node[v];\n        node[v] = u;\n        weight[v] += w + wb - wa;\n    }\n\n    ll get_weight(int u) {\n        ll ret = 0;\n        while(node[u] >= 0) {\n            ret += weight[u];\n            u = node[u];\n        }\n        return ret;\n    }\n\n    int find(int u) {\n      if(node[u] < 0) return u;\n      int par = node[u], root = find(node[u]);\n      weight[u] += weight[par];\n      return node[u] = root;\n    }\n};\n\nint main() {\n    int N, M;\n    while(cin >> N >> M, N) {\n        UnionFind uf;\n        for(int i=0; i<M; i++) {\n            char c; cin >> c;\n            if(c == '!') {\n                int a, b, d; cin >> a >> b >> d;\n                a--; b--;\n                uf.unite(a, b, d);\n            }\n            else {\n                int a, b; cin >> a >> b;\n                a--; b--;\n                if(uf.find(a) != uf.find(b)) cout << \"UNKNOWN\" << endl;\n                else {\n                    ll wa = uf.get_weight(a);\n                    ll wb = uf.get_weight(b);\n                    // printf(\"wa = %d, wb = %d\\n\", wa, wb);\n                    cout << wb - wa << endl;\n                }\n            }\n        }\n\n\t/*\n\tfor(int i=0; i<N; i++) {\n\t  printf(\"%d: parent = %d, weight = %lld, value = %lld\\n\", i, uf.node[i], uf.weight[i], uf.get_weight(i));\n\t}\n\t*/\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <cassert>\n#include <memory>\n#include <time.h>\nusing namespace std;\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\nconst double EPS = 1e-9;\nconst double PI  = acos(-1.0);\n\nconst int MAX_N=100010;\nint par[MAX_N];\nint myrank[MAX_N];\n\nvoid init(int n){\n\tfor(int i=0;i<n;i++){\n\t\tpar[i]=i;\n\t\tmyrank[i]=0;\n\t}\n}\n\npii find(int x){\n\tif(par[x]==x){\n\t\treturn make_pair(x,myrank[x]);\n\t}else{\n\t\tpii p=find(par[x]);\n\t\tmyrank[x]+=p.second;\n\t\tpar[x]=p.first;\n\t\treturn make_pair(par[x],myrank[x]);\n\t}\n}\n\nvoid unite(int x,int y,int w){\n\tint px=find(x).first;\n\tint py=find(y).first;\n\tint w2=w-(myrank[y]-myrank[py])+(myrank[x]-myrank[px]);\n\tif(px==py)return;\n\tif(w2<0){\n\t\tw2=-w2;\n\t\tswap(px,py);\n\t}\n\n\tpar[py]=px;\n\tmyrank[py]=w2;\n}\n\nbool same(int x,int y){\n\treturn find(x).first==find(y).first;\n}\n\nint main(){\n\tint n,m;\n\twhile(cin>>n>>m,n|m){\n\t\tinit(n+1);\n\t\tREP(i,m){\n\t\t\tchar q;\n\t\t\tint a,b,w;\n\t\t\tcin>>q>>a>>b;\n\t\t\tif(q=='!'){\n\t\t\t\tcin>>w;\n\t\t\t\tunite(a,b,w);\n\t\t\t}else{\n\t\t\t\tif(same(a,b)){\n\t\t\t\t\tcout<<myrank[b]-myrank[a]<<endl;\n\t\t\t\t}else{\n\t\t\t\t\tcout<<\"UNKNOWN\"<<endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": " \n#include <bits/stdc++.h>\nusing namespace std;\nusing ll=long long;\nusing vi=vector<int>;\nusing vvi=vector<vi>;\nusing vs=vector<string>;\nusing msi=map<string,int>;\nusing mii=map<int,int>;\nusing psi=pair<string,int>;\nusing pii=pair<int,int>;\nusing vlai=valarray<int>;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define range(i,s,n) for(int i=s;i<n;i++)\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\n#define fs first\n#define sc second\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define INF 1e9\n#define EPS 1e-9\n#define MOD ((ll)1e9+7)\nvoid get(){}template<class H,class...T>void get(H&h,T&...t){cin>>h;get(t...);}\ntemplate<class T>void geti(T&a){for(auto&_:a)cin>>_;}\ntemplate<class T>void getii(T&a){for(auto&_:a)geti(_);}\nvoid put(string d){}template<class H,class...T>void put(string d,H&h,T&...t){cout<<h;if(sizeof...(t))cout<<d;put(d,t...);}\ntemplate<class T>void puti(T&a,string d=\" \"){bool f=1;for(auto&_:a)cout<<(exchange(f,0)?\"\":d)<<_;cout<<endl;}\ntemplate<class T>void putii(T&a,string d=\" \"){for(auto&_:a)puti(_,d);}\n#define dcl(...) ll __VA_ARGS__;get(__VA_ARGS__)\n#define dclt(t,...) t __VA_ARGS__;get(__VA_ARGS__)\ntemplate<class F,class S>void add(map<F,S>&mp,F f,S s){if(mp.find(f)==mp.end())mp[f]=F();mp[f]+=s;}\n \nint main(){\n    int n,m;\n    while(cin>>n>>m,n){\n        vi where(n+1,-1);\n        vector<map<int,ll>> w;\n        char c;\n        rep(i,m){\n            cin>>c;\n            if(c=='!'){\n                ll a,b,x;\n                cin>>a>>b>>x;\n                if(where[a]==-1 && where[b]==-1){\n                    int i=w.size();\n                    where[a]=where[b]=i;\n                    w.eb();\n                    w[i][a]=0ll;\n                    w[i][b]=x;\n                }else if(where[a]==-1 || where[b]==-1){\n                    if(where[a]==-1){\n                        swap(a,b);\n                        x*=-1;\n                    }\n                    int i=where[a];\n                    where[b]=i;\n                    w[i][b]=w[i][a]+x;\n                }else{\n                    int sa=w[where[a]].size();\n                    int sb=w[where[b]].size();\n                    if(sa<sb){\n                        swap(a,b);\n                        x*=-1;\n                    }\n                    int i=where[a];\n                    int j=where[b];\n                    int diff=w[i][a]+x-w[j][b];\n                    for(auto data:w[j]){\n                        where[data.fs]=i;\n                        w[i].emplace(data.fs,data.sc+diff);\n                    }\n                }\n            }else{\n                int a,b;\n                cin>>a>>b;\n                if(where[a]!=where[b] || where[a]==-1){\n                    cout<<\"UNKNOWN\"<<endl;\n                }else{\n                    int i=where[a];\n                    cout<<w[i][b]-w[i][a]<<endl;\n                }\n            }\n        }\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#ifdef LOCAL\n#define _GLIBCXX_DEBUG\n#endif\n#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,s,t) for(ll i = (ll)(s); i < (ll)(t); i++)\n#define rrep(i,s,t) for(ll i = (ll)(s-1);(ll)(t) <= i; i--)\n#define all(x) (x).begin(), (x).end()\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<ll,ll> Pll;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<vvl> vvvl;\nconstexpr ll INF = numeric_limits<ll>::max()/4;\nconstexpr ll n_max = 2e5+10;\n#define int ll\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p);\nstring to_string(const string &s) {return '\"' + s + '\"';}\nstring to_string(const char *c) {return to_string((string) c);}\nstring to_string(bool b) {return (b ? \"true\" : \"false\");}\ntemplate <size_t N>\nstring to_string(bitset<N> v){\n    string res = \"\";\n    for(size_t i = 0; i < N; i++) res += static_cast<char>('0' + v[i]);\n    return res;\n}\ntemplate <typename A>\nstring to_string(A v) {\n    bool first = true;\n    string res = \"{\";\n    for(const auto &x : v) {\n        if(!first) res += \", \";\n        first = false;\n        res += to_string(x);\n    }\n    res += \"}\";\n    return res;\n}\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p){return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\";}\n\nvoid debug_out() {cerr << endl;}\ntemplate<typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n    cerr << \" \" << to_string(H);\n    debug_out(T...);\n}\n\n#ifdef LOCAL\n#define debug(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\ntemplate<class T>\nbool chmax(T &a, T b){if(a < b){a = b; return true;} return false;}\ntemplate<class T>\nbool chmin(T &a, T b){if(a > b){a = b; return true;} return false;}\n\n\ntemplate< typename T>\nstruct UnionFind{\nprivate:\n    vector<T> par;\n    vector<T> rank;\n    vector<T> sz;\n    int n;\n\npublic:\n    //n要素で親を初期化、par[x]はxの親を表す\n    UnionFind(int n): n(n) {\n        par.resize(n,0);\n        rank.resize(n,0);\n        sz.resize(n,1);\n        for(int i = 0; i < n; i++){\n            par[i] = i;\n        }\n    }\n\n    //木の根を求める\n    int root(int x){\n        if(par[x] == x) return x;\n        else return par[x] = root(par[x]);\n    }\n\n    //xとyの属する集合を併合\n    void unite(int x, int y){\n        x = root(x);\n        y = root(y);\n        if(x == y) return;\n        \n        if(rank[x] < rank[y]){\n            swap(x,y);\n        }\n        \n        par[y] = x;\n        sz[x] += sz[y];\n        if(rank[x] == rank[y]) rank[x]++; \n    }\n\n    //xとyが同じ集合に属するか否か\n    bool same(int x, int y){\n        return root(x) == root(y);\n    }\n\n    //xが属する集合のサイズを返す\n    int size(int x){\n        return sz[root(x)];\n    }\n\n    // 集合の数を返す\n    int num_of_s(){\n        vector<int> cnt(n);\n        int ans = 0;\n        for(int i = 0; i < n;i++){\n            if(!cnt[root(i)])ans++, cnt[root(i)] = 1;\n        }\n        return ans;\n    }\n};\n\ntemplate<class Abel>\nstruct WeightedUnionFind{\n    vector<int> par;\n    vector<int> rank;\n    vector<Abel> diff_weight;\n    int n;\n    Abel M0;\n\n    WeightedUnionFind(int n, Abel M0 = 0):n(n), M0(M0){\n        init(n, M0);\n    }\n\n    void init(int n, Abel M0 = 0){\n        par.resize(n);\n        rank.resize(n);\n        diff_weight.resize(n);\n        for(int i = 0; i < n; i++){\n            par[i] = i;\n            rank[i] = 0;\n            diff_weight[i] = M0;\n        }\n    }\n\n    int root(int x){\n        if(par[x] == x) return x;\n        else{\n            int r = root(par[x]);\n            diff_weight[x] += diff_weight[par[x]];\n            return par[x] = r;\n        }\n    }\n\n    Abel weight(int x){\n        root(x);\n        return diff_weight[x];\n    }\n\n    // w(x) + w == w(y)となるように併合\n    bool unite(int x, int y, Abel &w){\n        w += weight(x) - weight(y);\n        x = root(x);\n        y = root(y);\n        if(x == y) return w == 0;\n\n        if(rank[x] < rank[y]){\n            swap(x, y);\n            w = -w;\n        }\n\n        par[y] = x;\n        diff_weight[y] = w;\n        if(rank[x] == rank[y])rank[x]++;\n        return true;\n    }\n\n    bool same(int x, int y){\n        return root(x) == root(y);\n    }\n\n\n    Abel diff(int x, int y){\n        return weight(y) - weight(x);\n    }\n};\n\nsigned main(){\n    while(true){\n        ll n,m; cin >> n >> m;\n        if(n == 0 && m == 0)return 0;\n        WeightedUnionFind<ll> uf(n);\n        rep(i,0,m){\n            string s;cin >> s;\n            if(s == \"!\"){\n                ll a,b,w; cin >> a >> b >> w;\n                a--;b--;\n                uf.unite(a, b, w);\n            }\n            else{\n                ll a,b; cin >> a >> b;\n                a--;b--;\n                if(uf.same(a, b))cout << uf.diff(a, b) << \"\\n\";\n                else cout << \"UNKNOWN\" << \"\\n\";\n            }\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n#include<numeric>\n#include<utility>\n#include<complex>\n#include<functional>\n \nusing namespace std;\n\n/* constant */\n\n#define MAX_N\t(100000)\n\n/* typedef */\n\n/* global variables */\n\nint uts[MAX_N + 1];\nint dfs[MAX_N + 1];\n\n/* subroutines */\n\nint rootd(int k, int& rd) {\n  int rk = k;\n  rd = 0;\n\n  while (uts[rk]) {\n    rd += dfs[rk];\n    rk = uts[rk];\n  }\n\n  if (rk != k) {\n    uts[k] = rk;\n    dfs[k] = rd;\n  }\n  return rk;\n}\n\n/* main */\n\nint main() {\n  for (;;) {\n    int n, m;\n    cin >> n >> m;\n    if ((n | m) == 0) break;\n\n    bzero(uts, sizeof(int) * (n + 1));\n    bzero(dfs, sizeof(int) * (n + 1));\n\n    for (int i = 0; i < m; i++) {\n      char op;\n      int a, b;\n\n      cin >> op >> a >> b;\n\n      int ra, rb, da = 0, db = 0;\n      ra = rootd(a, da);\n      rb = rootd(b, db);\n    \n      if (op == '!') {\n\tint w;\n\tcin >> w;\n\tint rd = w + db - da;\n\n\tif (ra == rb) {\n\t  if (rd == 0) continue;\n\t  cout << \"Error\" << endl;\n\t  exit(0);\n\t}\n\n\tif (rd >= 0) {\n\t  uts[ra] = rb;\n\t  dfs[ra] = rd;\n\t}\n\telse {\n\t  uts[rb] = ra;\n\t  dfs[rb] = -rd;\n\t}\n      }\n      else {\n\tif (ra != rb)\n\t  cout << \"UNKNOWN\" << endl;\n\telse {\n\t  int d = da - db;\n\t  cout << d << endl;\n\t}\n      }\n    }\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <set>\n#include <algorithm>\n#include <cstdio>\n#define SENTINEL 99999999\nusing namespace std;\ntypedef pair<int,int> pii;\nclass union_find{\n\tvector<pii>parent;\n\tpii root(int a){\n\t\tif(parent[a].first==a)return parent[a];\n\t\tpii ret=root(parent[a].first);\n\t\treturn parent[a]=make_pair(ret.first,ret.second+parent[a].second);\n\t}\npublic:\n\tunion_find(int n): parent(n){for(int i=0;i<n;i++)parent[i]=make_pair(i,0);}\n\tint dist(int a,int b){\n\t\tpii x=root(a),y=root(b);\n\t\tif(x.first!=y.first)return SENTINEL;\n\t\treturn x.second-y.second;\n\t}\n\tint unite(int a,int b,int w){\n\t\tpii x=root(a),y=root(b);\n\t\tif(x.first==y.first)return 0;\n\t\tparent[x.first]=make_pair(y.first,y.second-x.second+w);\n\t\treturn 1;\n\t}\n};\nint main(){\n\tchar s[2];\n\tint N,Q,a,b,w;\n\tfor(;scanf(\"%d%d\",&N,&Q),N;)for(union_find uf(N);Q--;){\n\t\tscanf(\"%s\",s);if(*s=='!'){\n\t\t\tscanf(\"%d%d%d\",&a,&b,&w),a--,b--;\n\t\t\tuf.unite(a,b,w);\n\t\t}else{\n\t\t\tscanf(\"%d%d\",&a,&b),a--,b--;\n\t\t\tw=uf.dist(a,b);\n\t\t\tprintf(w==SENTINEL?\"UNKNOWN\\n\":\"%d\\n\",w);\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\ntypedef long long int ll;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000001\nusing namespace std;\n\nint* height;\nint* calc_parent;\nint* relative_weight;\n\nstruct Info{\n\tvoid set(int arg_parent_id,int arg_weight_sum){\n\t\tparent_id = arg_parent_id;\n\t\tweight_sum = arg_weight_sum;\n\t}\n\tint parent_id,weight_sum;\n};\n\nInfo find_parent_and_calc_weight(int id){\n\tif(calc_parent[id] == id){\n\t\tInfo ret;\n\t\tret.set(id,0);\n\t\treturn ret;\n\t}\n\telse{\n\t\tInfo ret = find_parent_and_calc_weight(calc_parent[id]);\n\t\tcalc_parent[id] = ret.parent_id;\n\t\trelative_weight[id] += ret.weight_sum;\n\t\tret.weight_sum = relative_weight[id];\n\n\t\treturn ret;\n\t}\n}\n\n\nvoid unite(int a,int b,int w){\n\n\tInfo a_info = find_parent_and_calc_weight(a);\n\tInfo b_info = find_parent_and_calc_weight(b);\n\n\tif(a_info.parent_id == b_info.parent_id)return;\n\n\tif(height[a_info.parent_id] == height[b_info.parent_id]){\n\n\t\trelative_weight[b_info.parent_id] = w-(relative_weight[b]-relative_weight[a]);\n\t\tcalc_parent[b_info.parent_id] = a_info.parent_id;\n\n\t}else if(height[a_info.parent_id] == height[b_info.parent_id]){\n\t\trelative_weight[b_info.parent_id] = w-(relative_weight[b]-relative_weight[a]);\n\t\tcalc_parent[b_info.parent_id] = a_info.parent_id;\n\t\theight[a_info.parent_id]++;\n\t}else{\n\n\t\trelative_weight[a_info.parent_id] = (relative_weight[b]-relative_weight[a])-w;\n\t\tcalc_parent[a_info.parent_id] = b_info.parent_id;\n\t}\n}\n\nbool isSame(int a,int b){\n\tInfo left = find_parent_and_calc_weight(a);\n\tInfo right = find_parent_and_calc_weight(b);\n\n\treturn left.parent_id == right.parent_id;\n}\n\nint main(){\n\n\tint N,M,a,b,w;\n\theight = new int[100001];\n\tcalc_parent = new int[100001];\n\trelative_weight = new int[100001];\n\tchar command[2];\n\n\twhile(true){\n\t\tscanf(\"%d %d\",&N,&M);\n\t\tif(N == 0 && M == 0)break;\n\n\t\tfor(int i = 0; i <= N; i++){\n\t\t\theight[i] = 0;\n\t\t\tcalc_parent[i] = i;\n\t\t\trelative_weight[i] = 0;\n\t\t}\n\n\t\tfor(int loop = 0; loop < M; loop++){\n\t\t\tscanf(\"%s %d %d\",command,&a,&b);\n\t\t\tif(command[0] == '!'){\n\t\t\t\tscanf(\"%d\",&w);\n\t\t\t\tunite(a,b,w);\n\t\t\t}else{\n\t\t\t\tif(!isSame(a,b)){\n\t\t\t\t\tprintf(\"UNKNOWN\\n\");\n\t\t\t\t}else{\n\t\t\t\t\tprintf(\"%d\\n\",relative_weight[b]-relative_weight[a]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<stdio.h>\n\nusing namespace std;\n\nclass DisjointSet{\npublic:\n  vector<int> rank,p,weight;\n\n  DisjointSet(){}\n  DisjointSet(int size){\n    rank.resize(size,0);\n    p.resize(size,0);\n    weight.resize(size,0);\n    for(int i=0;i<size;i++){\n      makeSet(i);\n    }\n  }\n\n  void makeSet(int x){\n    p[x]=x;\n    rank[x]=0;\n    weight[x]=0;\n  }\n  bool same(int x,int y){\n    return findSet(x)==findSet(y);\n  }\n  void unite(int x,int y,int w){\n    weight[x]=w;\n    link(x,y);\n  }\n  void link(int x,int y){   \n    p[x]=y;\n    if(rank[x]>=rank[y]){  \n      rank[y]=rank[x]+1;\n    }\n  }\n  int findSet(int x){\n    if(x==p[x]){\n      return x;\n    }else{\n      return findSet(p[x]);\n    }\n  }\n  int depth(int x){\n    int ans=0;\n    ans+=weight[x];\n    while(x!=p[x]){\n      ans+=weight[p[x]];\n      x=p[x];\n    }\n    return ans;\n  }\n};\nint main(){\n  int n,m;\n  while(scanf(\"%d%d\",&n,&m)){\n    if(!n&&!m){\n      break;\n    }else{\n      char query[5];\n      DisjointSet ds=DisjointSet(n);\n      for(int i=0;i<m;i++){\n        scanf(\"%s\",query);\n        if(query[0]=='!'){\n          int a,b,w;\n          scanf(\"%d%d%d\",&a,&b,&w);\n          ds.unite(a,b,w);\n        }else{\n          int c,d;\n          scanf(\"%d%d\",&c,&d);\n          if(!ds.same(c,d)){\n            printf(\"UNKNOWN\\n\");\n          }else{\n            printf(\"%d\\n\",ds.depth(c)-ds.depth(d));\n          }\n        }\n      }\n    }\n  }\n  return 0;\n}\n      "
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n//BEGIN CUT HERE\nstruct WeightedUnionFind{\n  int n;\n  vector<int> r,p,ws;\n  WeightedUnionFind(){}\n  WeightedUnionFind(int sz):\n    n(sz),r(sz,1),p(sz),ws(sz,0){iota(p.begin(),p.end(),0);}\n  int find(int x){\n    if(x==p[x]){\n      return x;\n    }else{\n      int t=find(p[x]);\n      ws[x]+=ws[p[x]];\n      return p[x]=t;\n    }\n  }\n  int weight(int x){\n    find(x);\n    return ws[x];\n  }\n  bool same(int x,int y){\n    return find(x)==find(y);\n  }\n  void unite(int x,int y,int w){\n    w+=weight(x);\n    w-=weight(y);\n    x=find(x);y=find(y);\n    if(x==y) return;\n    if(r[x]<r[y]) swap(x,y),w=-w;\n    r[x]+=r[y];\n    p[y]=x;\n    ws[y]=w;\n  }\n  int diff(int x,int y){\n    return weight(x)-weight(y);\n  }\n};\n//END CUT HERE\nsigned main(){\n  int n,m;\n  while(cin>>n>>m,n||m){\n    WeightedUnionFind u(n);\n    for(int i=0;i<m;i++){\n      int a,b;\n      char c;\n      cin>>c>>a>>b;\n      a--;b--;\n      if(c=='!'){\n\tint w;\n\tcin>>w;\n\tu.unite(a,b,w);\n      }else{\n\tif(!u.same(a,b)) cout<<\"UNKNOWN\"<<endl;\n\telse cout<<u.diff(a,b)<<endl;\n      }\n    }\n  }\n  return 0;\n}\n/*\n  verified on 2017/10/29\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1330\n*/"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\nconst int MAX = 100005;\n\nclass UnionFind{\npublic:\n \n  int par[MAX];\n  int rank[MAX];\n\n  void init(int n){\n    for(int i = 0; i < n; i++){\n      par[i] = i;\n      rank[i] = 0;\n    }\n  }\n\n  int find(int x){\n    if(par[x] == x) return x;\n    else return par[x] = find(par[x]);\n  }\n\n  void unite(int x, int y){\n    x = find(x);\n    y = find(y);\n    if(x == y) return;\n\n    if(rank[x] < rank[y]) par[x] = par[y];\n    else{\n      par[y] = par[x];\n      if(rank[x] == rank[y]) rank[x]++;\n    }\n  }\n  \n  bool same(int x, int y){\n    return find(x) == find(y);\n  }\n};\n\nint N,M,val[MAX];\nbool used[MAX];\nUnionFind uf;\nvector<int> V;\n\nvoid init(){\n  memset(used,false,sizeof(used));\n  memset(val,0,sizeof(val));\n  uf.init(N+1);\n  V.clear();\n}\n\n\nvoid update(){\n  \n  int a,b,c;\n  cin >> a >> b >> c;\n  if(!uf.same(a,b)){\n    if(!used[a]){\n      V.push_back(a);\n      used[a] = true;\n    }\n    if(!used[b]){\n      V.push_back(b);\n      used[b] = true;\n    }\n    \n    int diff = val[a]-val[b]+c;\n    for(int i = 0; i < V.size(); i++){\n      if(uf.same(V[i],b)) val[V[i]]+=diff;\n    }\n    uf.unite(a,b);\n  }\n}\n\nvoid print(){\n  int a,b;\n  cin >> a >> b;\n  if(uf.same(a,b)) cout << val[b]-val[a] << endl;\n  else cout << \"UNKNOWN\" << endl;\n}\n\nint main(){\n  \n  while(cin >> N >> M && N+M){\n    init();\n    for(int i = 0; i < M; i++){\n      char c;\n      cin >> c;\n      if(c == '!') update();\n      else print();\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint n,q;\nint p[100010] = {0},r[100010] = {0};\nint diff_weight[100010] = {0};\n\nvoid init(int N){\n\tfor(int i=0;i<=N;++i){\n\t\tp[i] = i;\n\t\tdiff_weight[i] = 0;\n\t\tr[i] = 0;\n\t}\n}\n\nint root(int a){\n\tif(p[a] == a) return a;\n\telse{\n\t\tint r = root(p[a]);\n\t\tdiff_weight[a] += diff_weight[p[a]];\n\t\treturn (p[a] = r);\n\t}\n}\n\nbool is_same_set(int a,int b){\n\treturn root(a) == root(b);\n}\n\nint weight(int a){\n\troot(a);\n\treturn diff_weight[a];\n}\n\nint diff(int a, int b){\n\treturn weight(b) - weight(a);\n}\n\nvoid unite(int a, int b, int w){\n\tw += weight(a);\n\tw -= weight(b);\n\ta = root(a);\n\tb = root(b);\n\tif(a==b) return;\n\tif(r[a]<r[b]){\n\t\tp[a] = b;\n\t\tw = -w;\n\t}else{\n\t\tp[b] = a;\n\t\tif(r[a] == r[b]) r[a]++;\n\t}\n\tdiff_weight[b] = w;\n}\n\nint main(){\n\twhile(cin >> n >> q && n>0){;\n\t\tinit(n);\n\t\tfor(int i=0;i<q;i++){\n\t\t\tchar c;\n\t\t\tint w,a,b;\n\t\t\tcin >> c;\n\t\t\tif(c=='!'){\n\t\t\t\tcin >> a >> b >> w;\n\t\t\t\tunite(a,b,w);\n\t\t\t}else{\n\t\t\t\tcin >> a >> b;\n\t\t\t\tif(is_same_set(a,b)) cout << diff(a,b) << endl;\n\t\t\t\telse cout << \"UNKNOWN\" << endl;\n\t\t\t}\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n\nconst int MAXN = 110000;\nstruct Node{\n    int next;\n    long long num;\n    }list[MAXN];\nint fa[MAXN],sum[MAXN],ed[MAXN];\n\ninline int Getfa(int k){\n    if (fa[k] == k) return k;\n    else return fa[k] = Getfa(fa[k]);\n    }\ninline void Union(int ta,int tb){\n    int a = Getfa(ta),b = Getfa(tb);\n    sum[a] += sum[b];\n    fa[b] = a;\n    }\ninline bool Judge(int a,int b){\n    return Getfa(a) == Getfa(b);\n    }\ninline void Update(int now,int k){\n    while(now != -1){\n        list[now].num += k;\n        now = list[now].next;\n        }\n    }\ninline void Link(int a,int b){\n    list[ed[a]].next = b;\n    ed[a] = ed[b];\n    }\nint Work(){\n    int i,n,m,a,b,c,fa_a,fa_b;\n    char op[10];\n    scanf(\"%d%d\",&n,&m);\n    if (n + m == 0) return 0;\n    for(i = 1;i <= n;i++) fa[i] = i;\n    for(i = 1;i <= n;i++) ed[i] = i;\n    for(i = 1;i <= n;i++) sum[i] = 1;\n    for(i = 1;i <= n;i++) {\n        list[i].next = -1;\n        list[i].num = 0;\n        }\n\n    for(i = 1;i <= m;i++) {\n        scanf(\"%s\",op);\n        if (op[0] == '!') {\n            scanf(\"%d%d%d\",&a,&b,&c);\n            fa_a = Getfa(a);\n            fa_b = Getfa(b);\n            if (!Judge(a,b)){\n                if (sum[fa_a] > sum[fa_b]){\n                    Update(fa_b,list[a].num+c-list[b].num);\n                    Link(fa_a,fa_b);\n                    }\n                else {\n                    Update(fa_a,-list[a].num-c+list[b].num);\n                    Link(fa_b,fa_a);\n                    }\n                Union(a,b);\n                }\n            }\n        else {\n            scanf(\"%d%d\",&a,&b);\n            if (Judge(a,b))\n                printf(\"%lld\\n\",list[b].num-list[a].num);\n            else\n                printf(\"UNKNOWN\\n\");\n            }\n        }\n        return 1;\n    }\n\nint main(){\n    while(Work());\n    return 0;\n    }"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stdio.h>\n#include<queue>\n#include<stack>\n#include<algorithm>\n#define ll long long\n#define MAXN 100005\nusing namespace std;\nint father[MAXN];\nll d[MAXN];\nint getfather(int x){\n    if (father[x]==x) return x;\n    int f=father[x];\n    father[x]=getfather(father[x]);\n    d[x]+=d[f];\n    return father[x];\n}\nint main(){\n    int n,m,i,x,y;\n    ll dis;\n    char c;\n    while (~scanf(\"%d%d\",&n,&m) && n){\n        for (i=1;i<=n;i++) father[i]=i,d[i]=0;\n        while (m--){\n            do{\n                c=getchar();\n            }\n            while (c!='!' && c!='?');\n            scanf(\"%d%d\",&x,&y);\n            if (c=='?'){\n                if (getfather(x)!=getfather(y))\n                    printf(\"UNKNOWN\\n\");\n                else\n                    printf(\"%lld\\n\",d[y]-d[x]);\n            }\n            else{\n                scanf(\"%lld\",&dis);\n                if (getfather(y)==getfather(x)) continue;\n                d[father[y]]+=dis-d[y];\n                father[father[y]]=x;\n            }\n         }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define show(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define show(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\ntemplate<typename T> using vec=std::vector<T>;\n\nconst int inf=1<<30;\nconst long long int infll=1LL<<62;\nconst double eps=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nclass union_find{\n\tprivate:\n\tvector<int> parent,diff;\n    int size;\n\tpublic:\n    int cnt_group;\n    union_find()=default;\n    union_find(int n){ init(n); }\n\n    void init(int n){\n\t\tsize=n;\n\t\tcnt_group=n;\n\t\tparent.resize(size);\n        diff.resize(size);\n\t\tfor(int i=0; i<size; ++i){\n\t\t\tparent[i]=i;\n            diff[i]=0;\n\t\t}\n\t}\n\n\tpii find(int x){\n\t\tif(parent[x]==x) return make_pair(x,0);\n        pii p=find(parent[x]);\n        parent[x]=p.first;\n        diff[x]+=p.second;\n        return make_pair(parent[x],diff[x]);\n\t}\n\n\tvoid unite(int x,int y,int w){\n\t\tpii a=find(x),b=find(y);\n\t\tif(a.first==b.first) return;\n        parent[a.first]=b.first;\n        diff[a.first]=w;\n\t\t--cnt_group;\n\t}\n\n\tbool is_same(int x,int y){\n\t\treturn find(x).first==find(y).first;\n\t}\n\n    int calc_diff(int x,int y){\n        return find(x).second-find(y).second;\n    }\n};\n\nvoid solve(int n,int m){\n    union_find uf(n);\n\n    rep(i,0,m){\n        char ch;\n        int a,b;\n        cin >> ch >> a >> b;\n        --a;\n        --b;\n        if(ch=='!'){\n            int w;\n            cin >> w;\n            uf.unite(a,b,w);\n        }else{\n            if(!uf.is_same(a,b)) cout << \"UNKNOWN\" << endl;\n            else cout << uf.calc_diff(a,b) << endl;\n        }\n    }\n}\n\nint main(){\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    cout.setf(ios::fixed);\n    cout.precision(10);\n    while(true){\n        int n,m;\n        cin >> n >> m;\n        if(!n and !m) break;\n        solve(n,m);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <vector>\n#include <queue>\n#include <algorithm>\n\nusing namespace std;\n\n//FILE *in = freopen(\"input.txt\", \"r\", stdin);\n//FILE *out = freopen(\"output.txt\", \"w\", stdout);\n\nint n, m;\n\nstruct UnionFind {\n\tvector<int> par; vector<int> rank;\n\tUnionFind(int n){\n\t\tpar = vector<int>(n);\n\t\trank = vector<int>(n);\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tpar[i] = i;\n\t\t}\n\t}\n\tint find(int x) {\n\t\tif(par[x]==x) return x;\n\t\telse return find(par[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif(x == y) return;\n\t\tif(rank[x]<rank[y])\n\t\t\tpar[x] = y;\n\t\telse {\n\t\t\tpar[y] = x;\n\t\t\tif(rank[x]==rank[y])rank[x]++;\n\t\t}\n\t}\n\tinline bool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n};\n\nint bfs(vector<vector<pair<int,int>>> data, int a, int b) {\n\tvector<bool> chk(n+1);\n\tfill(chk.begin(), chk.end(), false);\n\tqueue<pair<int,int>> que;\n\tque.push(make_pair(a, 0));\n\tchk[a] = true;\n\twhile(!que.empty()){\n\t\tint cur = que.front().first;\n\t\tint val = que.front().second;\n\t\tque.pop();\n\t\tif(cur == b)\n\t\t\treturn val;\n\n\t\tfor(int i = 0; i < data[cur].size(); i++) {\n\t\t\tif(chk[data[cur][i].first]) continue;\n\t\t\tchk[data[cur][i].first] = true;\n\t\t\tque.push(make_pair(data[cur][i].first, val + data[cur][i].second));\n\t\t}\n\t}\n\treturn -1;\n}\n\nvoid process() {\n\tUnionFind uf(n+1);\n\tvector<vector<pair<int,int>>> data(n+1);\n\tchar tt[10];\n\tint a, b, c;\n\tfor(int k = 0; k < m; k++) {\n\t\tscanf(\"%s%d%d\", tt, &a, &b);\n\t\tif(tt[0] == '!') {\n\t\t\tscanf(\"%d\", &c);\n\t\t\tif(uf.same(a,b)) continue;\n\t\t\tdata[a].push_back(make_pair(b, c));\n\t\t\tdata[b].push_back(make_pair(a, -c));\n\t\t\tuf.unite(a,b);\n\t\t}\n\t\telse {\n\t\t\tif(!uf.same(a, b)) {\n\t\t\t\tprintf(\"UNKNOWN\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tprintf(\"%d\\n\", bfs(data, a, b));\n\t\t}\n\t}\n}\n\nint main() {\n\twhile(true){\n\t\tscanf(\"%d%d\", &n, &m);\n\t\tif(!n)break;\n\t\tprocess();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 29;\n\nconst int nmax=100010;\nint par[nmax],ranks[nmax],weight[nmax];\n\nvoid init(int n){rep(i,n) par[i]=i,ranks[i]=0,weight[i]=0;}\nint find(int x,int &w){\n\tif(par[x]==x)\n\t\treturn x;\n\telse{\n\t\tw+=weight[x];\n\t\treturn find(par[x],w);\n\t}\n}\n\nvoid unite(int a,int b,int c){\n\tint wa=0,wb=0;\n\tint pa=find(a,wa);\n\tint pb=find(b,wb);\n\tif(ranks[pa]<ranks[pb]){\n\t\tpar[pa]=pb;\n\t\tweight[pa]=wb-wa+c;\n\t}else{\n\t\tpar[pb]=pa;\n\t\tweight[pb]=wa-wb-c;\n\t\tif(ranks[pa]==ranks[pb]) ranks[pa]++;\n\t}\n}\n\nbool same(int a,int b,int& ans){\n\tint wa=0,wb=0;\n\tint pa=find(a,wa);\n\tint pb=find(b,wb);\n\tans=wa-wb;\n\tcout << \" \" <<  pa << \" \" << pb << endl;\n\treturn pa==pb;\n}\n\nint main(void){\n\tint n,m;\n\twhile(cin >> n >> m,n){\n\t\tinit(n);\n\t\trep(i,m){\n\t\t\tchar cmd;\n\t\t\tcin >> cmd;\n\t\t\tif(cmd=='!'){\n\t\t\t\tint a,b,c;\n\t\t\t\tcin >> a >> b >> c;\n\t\t\t\tunite(a-1,b-1,c);\n\t\t\t}else{\n\t\t\t\tint a,b,ans;\n\t\t\t\tcin >> a >> b;\n\t\t\t\tif(same(a-1,b-1,ans))\n\t\t\t\t\tcout << ans << endl;\n\t\t\t\telse\n\t\t\t\t\tcout << \"UNKNOWN\" << endl;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconstexpr int INF = 1e9;\n\nclass union_find {\npublic:\n    union_find(int N)\n        : par(N, -1), w(N)\n    {}\n\n    pair<int, int> root(int x) {\n        if(par[x] < 0) {\n            return make_pair(x, 0);\n        }\n        pair<int, int> p = root(par[x]);\n        w[x] += p.second;\n        p.second = w[x];\n        par[x] = p.first;\n        return p;\n    }\n\n    void unite(int x, int y, int v) {\n        int rx = root(x).first, ry = root(y).first;\n        if(rx == ry) {\n            return;\n        }\n        if(par[rx] < par[ry]) { // size(x) > size(y)\n            par[rx] += par[ry];\n            par[ry] = rx;\n            w[ry] = v - w[y] + w[x];\n        } else {\n            par[ry] += par[rx];\n            par[rx] = ry;\n            w[rx] = -v + w[y] - w[x];\n        }\n    }\n\n    int calc(int x, int y) {\n        if(root(x).first != root(y).first) {\n            return INF;\n        }\n        return w[y] - w[x];\n    }\n        \nprivate:\n    vector<int> par;\n    vector<int> w;\n};\n\nint main() {\n    int N, M;\n    while(cin >> N >> M, N) {\n        union_find uf(N);\n        for(int i=0; i<M; ++i) {\n            char op; cin >> op;\n            if(op == '!') {\n                int a, b, v;\n                cin >> a >> b >> v;\n                a--; b--;\n                uf.unite(a, b, v);\n            } else {\n                int a, b;\n                cin >> a >> b;\n                a--; b--;\n                if(uf.calc(a, b) == INF) {\n                    cout << \"UNKNOWN\" << endl;\n                } else {\n                    cout << uf.calc(a, b) << endl;\n                }\n            }\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<stdio.h>\n\nusing namespace std;\n\n  void makeSet(int x, int p[], int rank[],int weight[]){\n    p[x]=x;\n    rank[x]=0;\n    weight[x]=0;\n  }\n int findSet(int x, int p[]){\n    if(x==p[x]){\n      return x;\n    }else{\n      return findSet(p[x],p);\n    }\n  }\n  bool same(int x,int y, int p[]){\n    return findSet(x,p)==findSet(y,p);\n  }\n  void link(int x,int y, int p[],int rank[]){   \n    p[x]=y;\n    if(rank[x]>=rank[y]){  \n      rank[y]=rank[x]+1;\n    }\n  }\n   void unite(int x,int y,int w, int weight[],int p[],int rank[]){\n    weight[x]=w;\n    link(x,y,p,rank);\n  }\n\n  int depth(int x, int weight[],int p[]){\n    int ans=0;\n    ans+=weight[x];\n    while(x!=p[x]){\n      ans+=weight[p[x]];\n      x=p[x];\n    }\n    return ans;\n  }\n\nint main(){\n  int n,m;\n  while(scanf(\"%d%d\",&n,&m)){\nint p[n];\nint weight[n];\nint rank[n];\n    if(!n&&!m){\n      break;\n    }else{\n      char query[5];\n     for(int i=0;i<n;i++){\n    makeSet(i,p,rank,weight);\n    }\n      for(int i=0;i<m;i++){\n        scanf(\"%s\",query);\n        if(query[0]=='!'){\n          int a,b,w;\n          scanf(\"%d%d%d\",&a,&b,&w);\n          unite(a,b,w,weight,p,rank);\n        }else{\n          int c,d;\n          scanf(\"%d%d\",&c,&d);\n          if(!same(c,d,p)){\n            printf(\"UNKNOWN\\n\");\n          }else{\n            printf(\"%d\\n\",depth(c, weight,p)-depth(d, weight,p));\n          }\n        }\n      }\n    }\n  }\n  return 0;\n}\n      "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define pii pair<int,int>\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(c) (c).begin(),(c).end()\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n#define MINF(a) memset(a,0x3f,sizeof(a))\n#define POW(n) (1LL<<(n))\n#define IN(i,a,b) (a <= i && i <= b)\nusing namespace std;\ntemplate <typename T> inline bool CHMIN(T& a,T b) { if(a>b) { a=b; return 1; } return 0; }\ntemplate <typename T> inline bool CHMAX(T& a,T b) { if(a<b) { a=b; return 1; } return 0; }\ntemplate <typename T> inline void SORT(T& a) { sort(ALL(a)); }\ntemplate <typename T> inline void REV(T& a) { reverse(ALL(a)); }\ntemplate <typename T> inline void UNI(T& a) { sort(ALL(a)); a.erase(unique(ALL(a)),a.end()); }\nconst int MOD = 1000000007;\nconst int INF = 0x3f3f3f3f3f3f3f3f;\nconst double EPS = 1e-10;\n/* ---------------------------------------------------------------------------------------------------- */\n\ntemplate <typename T>\nstruct WeightedUnionFind {\n  int n,num;\n  vector<int> r,p;\n  vector<T> diff_weight;\n  WeightedUnionFind() {}\n  WeightedUnionFind(int n) : n(n), num(n), r(n,1), p(n,0), diff_weight(n) {\n    iota(p.begin(),p.end(),0);\n  }\n  int find(int x) {\n    if (p[x] == x) return x;\n    int r = find(p[x]);\n    diff_weight[x] += diff_weight[p[x]];\n    return p[x] = r;\n  }\n  void unite(int x, int y, T w) {\n    w += weight(x); w -= weight(y);\n    x = find(x); y = find(y);\n    if (x == y) return;\n    if (r[x] < r[y]) swap(x,y), w = -w;\n    r[x] += r[y];\n    p[y] = x;\n    diff_weight[y] = w;\n    num--;\n  }\n  T weight(int x) {\n    find(x);\n    return diff_weight[x];\n  }\n  T diff(int x, int y) {\n    assert(same(x,y));\n    return weight(y) - weight(x);\n  }\n  bool same(int x, int y) {\n    return find(x) == find(y);\n  }\n  int size(int x) {\n    return r[find(x)];\n  }\n  int count() {\n    return num;\n  }\n};\n\nsigned main() {\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n  cout << fixed << setprecision(10);\n\n  int N,M;\n  while (cin >> N >> M, N) {\n    WeightedUnionFind<int> wuf(N);\n    REP(i,M) {\n      char c;\n      cin >> c;\n      if (c == '!') {\n        int a,b,w;\n        cin >> a >> b >> w;\n        a--; b--;\n        wuf.unite(a,b,w);\n      } else {\n        int a,b;\n        cin >> a >> b;\n        a--; b--;\n        if (wuf.same(a,b)) {\n          cout << wuf.diff(a,b) << endl;\n        } else {\n          cout << \"UNKNOWN\" << endl;\n        }\n      }\n    }\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n\n#define ALL(c) c.begin(), c.end()\n#define SZ(c) ((int)c.size())\n#define REP(i, n) for (int i = 0, loop_num_##i = n; i < loop_num_##i; i++)\n\n\ntemplate<class Abel> struct UnionFind {\n    vector<int> par;\n    vector<int> rank;\n    vector<Abel> diff_weight;\n\n    UnionFind(int n = 1, Abel SUM_UNITY = 0) {\n        init(n, SUM_UNITY);\n    }\n\n    void init(int n = 1, Abel SUM_UNITY = 0) {\n        par.resize(n); rank.resize(n); diff_weight.resize(n);\n        for (int i = 0; i < n; ++i) par[i] = i, rank[i] = 0, diff_weight[i] = SUM_UNITY;\n    }\n\n    int root(int x) {\n        if (par[x] == x) {\n            return x;\n        }\n        else {\n            int r = root(par[x]);\n            diff_weight[x] += diff_weight[par[x]];\n            return par[x] = r;\n        }\n    }\n\n    Abel weight(int x) {\n        root(x);\n        return diff_weight[x];\n    }\n\n    bool issame(int x, int y) {\n        return root(x) == root(y);\n    }\n\n    bool merge(int x, int y, Abel w) {\n        w += weight(x); w -= weight(y);\n        x = root(x); y = root(y);\n        if (x == y) return false;\n        if (rank[x] < rank[y]) swap(x, y), w = -w;\n        if (rank[x] == rank[y]) ++rank[x];\n        par[y] = x;\n        diff_weight[y] = w;\n        return true;\n    }\n\n    Abel diff(int x, int y) {\n        return weight(y) - weight(x);\n    }\n};\n// quoted from: https://qiita.com/drken/items/cce6fc5c579051e64fab\n\nsigned main() {\n\twhile (1) {\n\t\tint N, M;\n\t\tcin >> N >> M;\n\t\tif (N == 0 && M == 0) break;\n\t\tUnionFind<int> uf(N);\n\t\tREP(i, M) {\n\t\t\tchar q;\n\t\t\tcin >> q;\n\t\t\tint a, b, w;\n\t\t\tif (q == '!') {\n\t\t\t\tcin >> a >> b >> w;\n\t\t\t\ta--, b--;\n\t\t\t\tuf.merge(a, b, w);\n\t\t\t} else {\n\t\t\t\tcin >> a >> b;\n\t\t\t\ta--, b--;\n\t\t\t\tif (uf.issame(a, b)) {\n\t\t\t\t\tcout << uf.diff(a, b) << endl;\n\t\t\t\t} else {\n\t\t\t\t\tcout << \"UNKNOWN\" << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define rep(n) for(int i=0;i<n;i++)\n#define repp(j, n) for(int j=0;j<n;j++)\n#define reppp(i, m, n) for(int i=m;i<n;i++)\n#define all(c) c.begin(), c.end()\n#define rall(c) c.rbegin(), c.rend()\n#define debug(x) cerr << #x << \": \" << x << endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> Pll;\ntypedef pair<int, int> Pii;\nstruct edge{int from, to; ll cost;};\n\nconst ll MOD = 1000000007;\nconst long double EPS = 1e-10;\n\ntemplate<class Abel> class UnionFind {\n    public:\n    int n;\n    vector<int> par, rank;\n    vector<Abel> diff_weight;\n\n    UnionFind(int n, Abel SUM_UNITY = 0) {\n        rep(n) {\n            par.push_back(i);\n            rank.push_back(0);\n            diff_weight.push_back(SUM_UNITY);\n        }\n    }\n\n    int find(int x) {\n        if(par[x] == x){\n            return x;\n        }\n        int root = find(par[x]);\n        diff_weight[x] += diff_weight[par[x]];\n        return par[x] = root;\n    }\n\n    Abel weight(int x) {\n        find(x);\n        return diff_weight[x];\n    }\n\n    bool unite(int x, int y, Abel w) {\n        w = w + weight(x) - weight(y);\n        x = find(x);\n        y = find(y);\n\n        if(x == y) return false;\n\n        if(rank[x] < rank[y]){\n            par[x] = y;\n            diff_weight[x] = -w;\n        }else{\n            par[y] = x;\n            diff_weight[y] = w;\n            if(rank[x] == rank[y]) rank[x]++;\n        }\n\n        return true;\n    }\n\n    Abel diff(int x, int y) {\n        return weight(y) - weight(x);\n    }\n\n    bool is_same(int x, int y) {\n        return find(x) == find(y);\n    }\n};\n\nint main() {\n    std::ios::sync_with_stdio(0); cin.tie(0);\n    int n,m,a,b,w;\n    char q;\n    cin >> n >> m;\n    while(n != 0 || m != 0){\n        UnionFind<int> uf(n+1);\n\n        rep(m){\n            cin >> q >> a >> b;\n            if(q == '!'){\n                cin >> w;\n                uf.unite(a,b,w);\n            }else{\n                if(uf.is_same(a,b)){\n                    cout << uf.diff(a,b) << endl;\n                }else{\n                    cout << \"UNKNOWN\" << endl;\n                }\n            }\n        }\n\n        cin >> n >> m;\n    }\n    \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, a, n) for(ll i = ((ll) a); i < ((ll) n); i++)\nusing namespace std;\ntypedef long long ll;\n\nclass UnionFind {\npublic:\n  vector<ll> parent, weight;\n\n  UnionFind(ll n): parent(n), weight(n) {\n    REP(i, 0, n) parent[i] = i;\n  }\n\n  ll find(ll i) {\n    if(parent[i] == i) return i;\n    ll p = parent[i];\n    ll t = find(p);\n    parent[i] = t;\n    weight[i] += weight[p];\n    return t;\n  }\n\n  void unite(ll i, ll j, ll w) {\n    parent[i] = j;\n    weight[i] = -w;\n  }\n};\n\nint main(void) {\n  ll N, M;\n  while(cin >> N >> M, N && M) {\n    UnionFind uf(N);\n    REP(i, 0, M) {\n      string T; cin >> T;\n      if(T == \"!\") {\n        ll A, B, W; cin >> A >> B >> W; A--; B--;\n        uf.unite(A, B, W);\n      } else {\n        ll A, B; cin >> A >> B; A--; B--;\n        if(uf.find(A) != uf.find(B)) cout << \"UNKNOWN\" << endl;\n        else cout << uf.weight[B] - uf.weight[A] << endl;\n      }\n    }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\ntemplate <typename T> \nstruct WeightedUnionFind{\t\n  int n;\n  T d;\n  vector<int> r,p;\n  vector<T> ws;\n  WeightedUnionFind(){}\n  WeightedUnionFind(int sz,T d_):\n    n(sz),d(d_),r(n,1),p(n),ws(n,d){iota(p.begin(),p.end(),0);}\n  int find(int x){\n    if(x==p[x]){\n      return x;\n    }else{\n      int t=find(p[x]);\n      ws[x]+=ws[p[x]];\n      return p[x]=t;\n    }\n  }\n  T weight(int x){\n    find(x);\n    return ws[x];\n  }\n  bool same(int x,int y){\n    return find(x)==find(y);\n  }\n  void unite(int x,int y,T w){\n    w+=weight(x);\n    w-=weight(y);\n    x=find(x);y=find(y);\n    if(x==y) return;\n    if(r[x]<r[y]) swap(x,y),w=-w;\n    r[x]+=r[y];\n    p[y]=x;\n    ws[y]=w;\n  }\n  T diff(int x,int y){\n    return weight(y)-weight(x);\n  }\n};\n\nsigned main() {\n\tint n, m;\n\twhile ( cin >> n >> m, n ) {\n\t\n\t\tWeightedUnionFind<int> uf(n, 0);\n\t\tfor ( int i = 0; i < m; i++ ) {\n\t\t\tchar c;\n\t\t\tcin >> c;\n\t\t\tint a, b;\n\t\t\tcin >> a >> b;\n\t\t\ta--; b--;\n\t\t\tif ( c == '!' ) {\n\t\t\t\tint c;\n\t\t\t\tcin >> c;\n\t\t\t\tuf.unite(a, b, c);\n\t\t\t} else {\n\t\t\t\tif ( !uf.same(a, b) ) cout << \"UNKNOWN\" << endl;\n\t\t\t\telse cout << uf.diff(a, b) << endl;\t\t\t\n\t\t\t}\n\t\t}\n\t}\n\t\n}\n\n\t\t\t\t\t\t\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nstruct UnionFind {\n#define rep(i,n) for (int i=0; i < int(n); i++)\n  vector<int> par;\n  vector<int> dw;\n  vector<int> sizes;\n\n  UnionFind(int n) : par(n), dw(n), sizes(n, 1) {\n    rep(i,n) par[i] = i;\n  }\n\n  int find(int x) {\n    if (x == par[x]) return x;\n    int xp = find(par[x]);\n    dw[x] += dw[par[x]];\n    return par[x] = xp;\n  }\n\n  void unite(int x, int y, int w) {\n    int xp = find(x);\n    int yp = find(y);\n\n    if (xp == yp) return;\n\n    if (sizes[xp] >= sizes[yp]) {\n        par[yp] = xp;\n        dw[yp] = dw[x] - dw[y] + w;\n        //dw[y] += dw[x] - dw[y] + w;\n        sizes[x] += sizes[y];\n    } else {\n        swap(x, y);\n        swap(xp, yp);\n        par[yp] = xp;\n        dw[yp] = dw[x] - dw[y] - w;\n        //dw[y] += dw[x] - dw[y] - w;\n        sizes[x] += sizes[y];\n    }\n\n  }\n\n  bool same(int x, int y) {\n    return find(x) == find(y);\n  }\n\n  int size(int x) {\n    return sizes[find(x)];\n  }\n#undef rep\n};\n\nint main()\n{\n    for (;;) {\n        int n, m;\n        scanf(\"%d %d\", &n, &m);\n        if (n == 0 && m == 0)\n            break;\n\n        UnionFind uf(n);\n        for (int i = 0; i < m; ++i) {\n            //for (int i = 0; i < n; ++i) printf(\"%d: par=%d, dw=%d\\n\", i+1, uf.par[i]+1, uf.dw[i]);\n            char c;\n            scanf(\" %c\", &c);\n            if (c == '!') {\n                int a, b, w;\n                scanf(\"%d %d %d\", &a, &b, &w);\n                uf.unite(a - 1, b - 1, w);\n            } else /* if (c == '?') */ {\n                int a, b;\n                scanf(\"%d %d\", &a, &b);\n                if (uf.same(a - 1, b - 1))\n                    printf(\"%d\\n\", uf.dw[b - 1] - uf.dw[a - 1]);\n                else\n                    printf(\"UNKNOWN\\n\");\n            }\n        }\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n//BEGIN CUT HERE\ntemplate <typename T> \nstruct WeightedUnionFind{\n  int n;\n  T d;\n  vector<int> r,p;\n  vector<T> ws;\n  WeightedUnionFind(){}\n  WeightedUnionFind(int sz,T d_):\n    n(sz),d(d_),r(n,1),p(n),ws(n,d){iota(p.begin(),p.end(),0);}\n  int find(int x){\n    if(x==p[x]){\n      return x;\n    }else{\n      int t=find(p[x]);\n      ws[x]+=ws[p[x]];\n      return p[x]=t;\n    }\n  }\n  T weight(int x){\n    find(x);\n    return ws[x];\n  }\n  bool same(int x,int y){\n    return find(x)==find(y);\n  }\n  void unite(int x,int y,T w){\n    w+=weight(x);\n    w-=weight(y);\n    x=find(x);y=find(y);\n    if(x==y) return;\n    if(r[x]<r[y]) swap(x,y),w=-w;\n    r[x]+=r[y];\n    p[y]=x;\n    ws[y]=w;\n  }\n  T diff(int x,int y){\n    return weight(x)-weight(y);\n  }\n};\n//END CUT HERE\nsigned main(){\n  int n,m;\n  while(cin>>n>>m,n||m){\n    WeightedUnionFind<Int> u(n,0);\n    for(int i=0;i<m;i++){\n      int a,b;\n      char c;\n      cin>>c>>a>>b;\n      a--;b--;\n      if(c=='!'){\n\tInt w;\n\tcin>>w;\n\tu.unite(a,b,w);\n      }else{\n\tif(!u.same(a,b)) cout<<\"UNKNOWN\"<<endl;\n\telse cout<<u.diff(a,b)<<endl;\n      }\n    }\n  }\n  return 0;\n}\n/*\n  verified on 2017/10/29\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1330\n*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\nconst int INF = 1000000000;\n#define REP(i,s,n) for(int i=(int)(s);i<(int)(n);i++)\n#define rep(i,n) REP(i, 0, n)\nstruct UnionFind {\n    vector<int> data;\n    vector<ll> rootd;//rootd[i] : dist from node[i] to node[root(i)]\n    UnionFind(int N) : data(N, -1), rootd(N, 0) {}\n    void unite(int x_, int y_, ll weight) {\n        int x = root(x_), y = root(y_);\n        if(x != y){\n            data[x] += data[y];\n            data[y] = x;\n            rootd[y] = weight - rootd[y_] + rootd[x_];\n        }\n    }\n    int root(int x_) {\n        int x = x_;\n        vector<int> memo;\n        while(data[x] >= 0) {\n            memo.push_back(x);\n            x = data[x];\n        }\n        int res = x;\n        for(int i = memo.size() - 1; i >= 0; --i) {\n            int k = memo[i];\n            rootd[k] += rootd[data[k]];\n            data[k] = res;\n        }\n        return res;\n    }\n    ll dist(int a, int b) { return rootd[b] - rootd[a];}\n    bool same(int a, int b) { return root(a) == root(b);}\n};\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int N, M;\n    while(cin >> N >> M && N) {\n        UnionFind uf(N);\n        char q; int a, b; ll w;\n        rep(i, M) {\n            cin >> q >> a >> b;\n            --a; --b;\n            if(q == '?') {\n                if(uf.same(a, b)) cout << uf.dist(a, b) << '\\n';\n                else cout << \"UNKNOWN\" << '\\n';;\n            }else {\n                cin >> w;\n                uf.unite(a, b, w);\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\nconst int maxn = 100000 + 10;\nint pre[maxn], dist[maxn], n;\n\nint Find(int a)\n{\n    if(pre[a] != a)\n    {\n        int tem = Find(pre[a]);\n        dist[a] = dist[pre[a]] + dist[a];\n        return pre[a] = tem;\n    }\n    else\n        return a;\n}\nint main()\n{\n//    freopen(\"test.in\",\"r\",stdin);\n    int i,m,n,a,b,fa,fb,w,cha;\n    char op;\n    while(~scanf(\"%d%d\",&m,&n)){\n        if(m+n==0) break;\n        for(i=1;i<=m;i++){\n            pre[i]=i;\n            dist[i]=0;\n        }\n        while(n--){\n            getchar();\n            scanf(\"%c\",&op);\n            if(op=='!'){\n                scanf(\"%d%d%d\",&a,&b,&w);\n                fa=Find(a);\n                fb=Find(b);\n                if(fa!=fb){\n                    pre[fb]=fa;\n                    dist[fb]=dist[a]+w-dist[b];\n                }\n            }else if(op=='?'){\n                scanf(\"%d%d\",&a,&b);\n                fa=Find(a);\n                fb=Find(b);\n                if(fa!=fb)\n                    puts(\"UNKNOWN\");\n                else\n                    printf(\"%d\\n\",dist[b]-dist[a]);\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<bitset>\n#include<algorithm>\nusing namespace std;\n#define MAX_N 100100\n\nclass union_find{\nprivate:\n\tint parents[MAX_N];\n\tint rank[MAX_N];\n\tint weight[MAX_N];\npublic:\n\tunion_find(){\n\t\tfor(int i=0;i<MAX_N;i++){\n\t\t\tparents[i]=i;\n\t\t\trank[i]=0;\n\t\t\tweight[i]=0;\n\t\t}\n\t}\n\tunion_find(int n){\n\t\tfor(int i=0;i<n;i++){\n\t\t\tparents[i]=i;\n\t\t\trank[i]=0;\n\t\t\tweight[i]=0;\n\t\t}\n\t}\n\tint find(int x){\n\t\tif(parents[x]==x){\n\t\t\treturn x;\n\t\t}else{\n\t\t\tint tmp=find(parents[x]);\n\t\t\tweight[x]=weight[x]+weight[parents[x]];\n\t\t\treturn parents[x]=tmp;\n\t\t}\n\t}\n\tvoid unite(int x,int y,int w){\n\t\tint tmpx=find(x);\n\t\tint tmpy=find(y);\n\t\tif(tmpx==tmpy)return;\n\t\t//cout<<\"weight list\"<<weight[x]<<\" \"<<weight[y]<<\" \"<<w<<endl;\n\t\tif(rank[tmpx]<rank[tmpy]){\n\t\t\tweight[tmpx]=w-weight[x]+weight[y];\n\t\t\tparents[tmpx]=tmpy;\n\t\t}else{\n\t\t\tweight[tmpy]=-w-weight[y]+weight[x];\n\t\t\tparents[tmpy]=tmpx;\n\t\t\tif(rank[tmpx]==rank[tmpy])rank[tmpx]++;\n\t\t}\n\t}\n\tbool same(int x,int y){\n\t\treturn (find(x)==find(y));\n\t}\n\t\n\tint get_weight(int x,int y){\n\t\tif(find(x)==find(y)){\n\t\t\t//cout<<\"get weight \"<<weight[x]<<\" \"<<weight[y]<<endl;\n\t\t\treturn weight[x]-weight[y];\n\t\t}else{\n\t\t\treturn -2000000;\n\t\t}\n\t}\n};\nint main(){\n\tchar c;\n\tint a,b,w;\n\tint n,m;\n\twhile(cin>>n>>m,n!=0||m!=0){\n\t\tunion_find uf(n+1);\n\t\tfor(int i=0;i<m;i++){\n\t\t\tcin>>c;\n\t\t\tif(c=='!'){\n\t\t\t\tcin>>a>>b>>w;\n\t\t\t\tuf.unite(a,b,w);\n\t\t\t}else if(c=='?'){\n\t\t\t\tcin>>a>>b;\n\t\t\t\tif(uf.same(a,b)){\n\t\t\t\t\tint tmp=uf.get_weight(a,b);\n\t\t\t\t\tif(tmp!=-2000000){\n\t\t\t\t\t\tcout<<tmp<<endl;\n\t\t\t\t\t}else{\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tcout<<\"UNKNOWN\"<<endl;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tcout<<\"???\"<<endl;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int, int> pii;\n\nclass UnionFind{\nprivate:\n    //root, weight\n    vector<pii> _root;\n    \npublic:\n    UnionFind(int n){\n        _root.resize(n);\n        for(int i=0; i<n; i++){\n            _root[i] = pii(i, 0);\n        }\n    }\n    \n    pii root(int x){\n        if(_root[x].first == x)\n            return _root[x];\n        \n        auto e = root(_root[x].first);\n        _root[x].first = e.first;\n        _root[x].second += e.second;\n        \n        return _root[x];\n    }\n    \n    bool unite(int x, int y, int w){\n        if(is_same_group(x, y))\n            return false;\n        \n        auto xv = root(x);\n        auto yv = root(y);\n        \n        _root[yv.first] = pii(xv.first, w + xv.second - yv.second);\n        \n        return true;\n    }\n    \n    bool is_same_group(int x, int y){\n        return root(x).first == root(y).first;\n    }\n};\n\nint N, M;\n\nvoid solve(){\n    auto uf = UnionFind(N);\n    for(int i=0; i<M; i++){\n        char c; cin >> c;\n        \n        if(c == '!'){ //unite\n            int a, b, w; cin >> a >> b >> w; a--; b--;\n            uf.unite(a, b, w);\n        }\n        if(c == '?'){ //root\n            int a, b; cin >> a >> b; a--; b--;\n            if(!uf.is_same_group(a, b)){\n                cout << \"UNKNOWN\" << endl;\n            }else{\n                auto av = uf.root(a);\n                auto bv = uf.root(b);\n                cout << bv.second - av.second << endl;\n            }\n        }\n    }\n}\n\nint main(){\n    while(cin >> N >> M, N|M){\n        solve();\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n\n#define reps(i,f,n) for(int i=f;i<int(n);i++)\n#define rep(i,n) reps(i,0,n)\n\ntypedef pair<int,int> pii;\n\n#define x first\n#define y second\n\nclass UF{\npublic:\n  vector<pii> per;\n  void init(int n){\n    per = vector<pii>(n+1);\n    rep(i,per.size()){\n      per[i].x = i;\n      per[i].y=0;\n    }\n  }\n\n  int find(int a){\n    if(per[a].x == a)return a;\n\n    int ret = find(per[a].x);\n    per[a].y += per[per[a].x].y;\n    per[a].x = ret;\n    return ret;\n  }\n\n  int uni(int a, int b, int dist){\n    int s = find(a);\n    int t = find(b);\n\n    if(s==t)assert(0);\n\n    int c = per[b].y - per[a].y;\n    per[t].x = s;\n    per[t].y = -(c+dist);\n  }\n\n  bool same(int a, int b){\n    return find(a)==find(b);\n  }\n\n  void print(){\n    reps(i,1,per.size())printf(\"%d,%d \",per[i].x,per[i].y);puts(\"\");\n  }\n\n};\n\n\nUF uf;\nint n,m;\n\nbool input(){\n  cin>>n>>m;\n  return n!=0;\n}\n\nvoid uni(int a, int b, int c){\n  uf.uni(a,b,c);\n}\n\nstring itostr(int n){\n  stringstream s;\n  s<<n;\n  return s.str();\n}\n\nstring compare(int a, int b){\n  if(!uf.same(a,b))return \"UNKNOWN\";\n  int ans = -(uf.per[b].y - uf.per[a].y);\n  return itostr(ans);\n}\n\nvoid solve(){\n  uf.init(n);\n\n  rep(i,m){\n    char ch;\n    int a,b,c;\n\n    cin>>ch;\n    if(ch=='!'){\n      cin>>a>>b>>c;\n      uni(a,b,c);\n    }else{\n      cin>>a>>b;\n      cout<<compare(a,b)<<endl;\n    }\n  }\n}\n\n\nint main(){\n  while(input())solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\n#include <cassert>\n#include <queue>\n#include <set>\n#include <map>\n#include <valarray>\n#include <bitset>\n#include <stack>\n#include <iomanip>\n#include <fstream>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define chmax(a,b) (a<b?(a=b,1):0)\n#define chmin(a,b) (a>b?(a=b,1):0)\n#define valid(y,x,h,w) (0<=y&&y<h&&0<=x&&x<w)\nconst int INF = 1<<29;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n\nstruct UnionFind {\n  vector<int> data;\n  vector<int> dis;\n  UnionFind(int size) : data(size, -1), dis(size,0) { }\n  bool unionSet(int x, int y, int d) {\n    int disx = dist(x);\n    int disy = dist(y);\n    x = root(x); y = root(y);\n    if (x != y) {\n      if (data[y] < data[x]) {\n        swap(x, y), d=-d;\n        swap(disx,disy);\n      }\n      data[x] += data[y]; data[y] = x;\n      dis[y] = disx + d + disy;\n    }\n    return x != y;\n  }\n  bool findSet(int x, int y) {\n    return root(x) == root(y);\n  }\n  int root(int x) {\n    if (data[x]<0) return x;\n    else {\n      dis[x] += dis[data[x]];\n      return data[x] = root(data[x]);\n    }\n    // return data[x] < 0 ? x : data[x] = root(data[x]);\n  }\n  int size(int x) {\n    return -data[root(x)];\n  }\n  int dist(int x) {\n    root(x);\n    return dis[x];\n  }\n};\n\nint main() {\n  int n,m;\n  while(cin>>n>>m,n||m) {\n    UnionFind uf(n);\n    REP(i,m) {\n      // REP(j,n) cout << uf.data[j] << \" \"; cout << endl;\n      // REP(j,n) cout << uf.dis[j] << \" \"; cout << endl;\n      char c; cin >> c;\n      if (c == '!') {\n        int a, b, d;\n        cin >> a >> b >> d;\n        a--;b--;\n        uf.unionSet(a,b,d);\n      } else {\n        int a, b;\n        cin >> a >> b;\n        a--;b--;\n        if (uf.findSet(a,b)) {\n          int d1 = uf.dist(a);\n          int d2 = uf.dist(b);\n          cout << d2-d1 << endl;\n        } else {\n          puts(\"UNKNOWN\");\n        }\n      }\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <cstring>\n#include <sstream>\n#include <algorithm>\n#include <cstdlib>\n#include <map>\n#include <queue>\n#include <utility>\n#include <vector>\n#include <set>\n#include <memory.h>\n#include <iomanip>\n#include <bitset>\n#include <list>\n#include <stack>\n#include <deque>\n#include <complex>\n\nusing namespace std;\n\n#define mod 1000000007\n\nclass UnionFind\n{\n    vector<int> root;\n    vector<vector<int> > child;\n    vector<long long int> dist;\n    public:\n    UnionFind(int n)\n    {\n    \tchild = vector<vector<int> >(n);\n        for(int i=0;i<n;i++)\n        {\n            root.push_back(i);\n            child[i].push_back(i);\n            dist.push_back(0);\n        }\n    }\n\n    int getroot(int n)\n    {\n        if(root[n]==n) return n;\n        return root[n]=getroot(root[n]);\n    }\n\n    void set(int x,int y, long long int w)\n    {\n        int rx = getroot(x);\n        int ry = getroot(y);\n        if(rx == ry) return;\n        if(child[rx].size() < child[ry].size()){\n        \tswap(x, y);\n        \tswap(rx, ry);\n        \tw = -w;\n        }\n        root[ry] = rx;\n        for(int i = 0; i < child[ry].size(); i++){\n        \tint now = child[ry][i];\n        \tdist[now] = dist[x] + w;\n        \tchild[rx].push_back(now);\n        }\n        // cout << \"connect \" << ry << \" to \" << rx << endl;\n        // cout << \"child of \" << rx << \" : \" << endl;\n        // for(int i = 0; i < child[rx].size(); i++){\n        // \tcout << child[rx][i] << \" (dist : \" << dist[child[rx][i]] << \" ) \" << endl;\n        // }\n        child[ry].clear();\n    }\n\n    long long int getdist(int x)\n    {\n    \treturn dist[x];\n    }\n};\n\nint main()\n{\n\twhile(1){\n\t\tint n, m;\n\t\tcin >> n >> m;\n\t\tif(n == 0) break;\n\t\tUnionFind uf(n);\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tchar c;\n\t\t\tcin >> c;\n\t\t\tif(c == '!'){\n\t\t\t\tint a, b, w;\n\t\t\t\tcin >> a >> b >> w;\n\t\t\t\ta--;\n\t\t\t\tb--;\n\t\t\t\tuf.set(a, b, w);\n\t\t\t} else {\n\t\t\t\tint a, b;\n\t\t\t\tcin >> a >> b;\n\t\t\t\ta--;\n\t\t\t\tb--;\n\t\t\t\tif(uf.getroot(a) != uf.getroot(b)) cout << \"UNKNOWN\" << endl;\n\t\t\t\telse cout << uf.getdist(b) - uf.getdist(a) << endl;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\nconst int S = 100010;\n\nstruct UnionFind {\n    vector<int> node;\n    vector<ll> weight;\n    UnionFind() : node(S, -1), weight(S, 0) {}\n    void unite(int u, int v, ll w) {\n        if(find(u) == find(v)) return;\n        if(find(u) > find(v)) swap(u, v), w *= -1;\n\n        // v テ」ツ?ョティツヲツェテ」ツつ?(u テ」ツ?ョティツヲツェ) テ」ツ?ォテ」ツ?、テ」ツ?ェテ」ツ?津」ツつ?\n        ll prev_weight = get_weight(u);\n\tu = find(u);\n        node[u] += node[v];\n        node[v] = u;\n        weight[v] += prev_weight + w;\n    }\n\n    ll get_weight(int u) {\n        ll ret = 0;\n        while(node[u] >= 0) {\n            ret += weight[u];\n            u = node[u];\n        }\n        return ret;\n    }\n\n    int find(int u) {\n      if(node[u] < 0) return u;\n      int par = node[u], root = find(node[u]);\n      weight[u] += weight[par];\n      return node[u] = root;\n    }\n};\n\nint main() {\n    int N, M;\n    while(cin >> N >> M, N) {\n        UnionFind uf;\n        for(int i=0; i<M; i++) {\n            char c; cin >> c;\n            if(c == '!') {\n                int a, b, d; cin >> a >> b >> d;\n                a--; b--;\n                uf.unite(a, b, d);\n            }\n            else {\n                int a, b; cin >> a >> b;\n                a--; b--;\n                if(uf.find(a) != uf.find(b)) cout << \"UNKNOWN\" << endl;\n                else {\n                    ll wa = uf.get_weight(a);\n                    ll wb = uf.get_weight(b);\n                    // printf(\"wa = %d, wb = %d\\n\", wa, wb);\n                    cout << wb - wa << endl;\n                }\n            }\n        }\n\n\t/*\n\tfor(int i=0; i<N; i++) {\n\t  printf(\"%d: parent = %d, weight = %lld, value = %lld\\n\", i, uf.node[i], uf.weight[i], uf.get_weight(i));\n\t}\n\t*/\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<stdio.h>\n\nusing namespace std;\nint weight[100000];\n\nclass DisjointSet{\npublic:\n  int rank[100000],p[100000];\n\n  DisjointSet(){}\n  DisjointSet(int size){\n    rank.resize(size,0);\n    p.resize(size,0);\n    for(int i=0;i<size;i++){\n      makeSet(i);\n      weight[i]=0;\n    }\n  }\n\n  void makeSet(int x){\n    p[x]=x;\n    rank[x]=0;\n  }\n  bool same(int x,int y){\n    return findSet(x)==findSet(y);\n  }\n  void unite(int x,int y,int w){\n    weight[x]=w;\n    link(x,y);\n  }\n  void link(int x,int y){   \n    p[x]=y;\n    if(rank[x]>=rank[y]){  \n      rank[y]=rank[x]+1;\n    }\n  }\n  int findSet(int x){\n    if(x==p[x]){\n      return x;\n    }else{\n      return findSet(p[x]);\n    }\n  }\n  int depth(int x){\n    int ans=0;\n    ans+=weight[x];\n    while(x!=p[x]){\n      ans+=weight[p[x]];\n      x=p[x];\n    }\n    return ans;\n  }\n};\nint main(){\n  int n,m;\n  while(scanf(\"%d%d\",&n,&m)){\n    if(!n&&!m){\n      break;\n    }else{\n      string query;\n      DisjointSet ds=DisjointSet(n);\n      for(int i=0;i<m;i++){\n        cin>>query;\n        if(query==\"!\"){\n          int a,b,w;\n          scanf(\"%d%d%d\",&a,&b,&w);\n          ds.unite(a,b,w);\n        }else{\n          int c,d;\n          scanf(\"%d%d\",&c,&d);\n          if(!ds.same(c,d)){\n            printf(\"UNKNOWN\\n\");\n          }else{\n            printf(\"%d\\n\",ds.depth(c)-ds.depth(d));\n          }\n        }\n      }\n    }\n  }\n  return 0;\n}\n      "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define range(i, a, n) for(int (i) = (a); (i) < (n); (i)++)\n#define rep(i, n) for(int (i) = 0; (i) < (n); (i)++)\nusing namespace std;\n\nusing pii = pair<int, int>;\n#define fst first\n#define snd second\n\nstruct UnionFind {\n    vector<int> data;\n    vector<int> diff_w;\n    UnionFind(int size) : data(size, -1), diff_w(size) { }\n\n    bool unionSet(int x, int y, int w) {\n        pii xx = _root(x), yy = _root(y);\n        x = xx.fst, y = yy.fst;\n        if (x != y) {\n            if (data[y] < data[x]) swap(x, y), swap(xx, yy), w *= -1;\n            data[x] += data[y]; data[y] = x;\n            diff_w[y] = xx.snd - yy.snd + w;\n        }\n        return x != y;\n    }\n    bool findSet(int x, int y) {\n        return root(x) == root(y);\n    }\n    int root(int x){\n        return _root(x).fst;\n    }\n    int diff(int x, int y){\n        root(x);\n        root(y);\n\n        return diff_w[y] - diff_w[x];\n    }\n    pii _root(int x) {\n        pii ret;\n\n        if(data[x] < 0){\n            ret = pii(x, diff_w[x]);\n        }\n        else {\n            ret = _root(data[x]);\n            ret.snd += diff_w[x];\n\n            data[x]    = ret.fst;\n            diff_w[x]  = ret.snd;\n        }\n\n        return ret;\n    }\n    int size(int x) {\n        return -data[root(x)];\n    }\n};\n\nint main(void){\n    for(int n, m; cin >> n >> m, n;){\n        UnionFind uf(n);\n\n        rep(_, m){\n            char op; cin >> op;\n\n            if(op == '!'){\n                int a, b, w; cin >> a >> b >> w;\n                a--, b--;\n                uf.unionSet(a, b, w);\n            }\n            else {\n                int a, b; cin >> a >> b;\n                a--, b--;\n                if(not uf.findSet(a, b)) cout << \"UNKNOWN\" << endl;\n                else cout << uf.diff(a, b) << endl;\n            }\n        }\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nstruct UnionFind{\n  vector<int> r,p,ws;\n  UnionFind(){}\n  UnionFind(int size){init(size);}\n  void init(int size){\n    r.resize(size,0);\n    p.resize(size,0);\n    ws.resize(size,0);\n    for(int i=0;i<size;i++) r[i]=1,p[i]=i;\n  }\n  int find(int x){\n    if(x==p[x]){\n      return x;\n    }else{\n      int t=find(p[x]);\n      ws[x]+=ws[p[x]];\n      return p[x]=t;\n    }\n  }\n  int weight(int x){\n    find(x);\n    return ws[x];\n  }\n  bool same(int x,int y){\n    return find(x)==find(y);\n  }\n  void unite(int x,int y,int w){\n    w+=weight(x);\n    w-=weight(y);\n    x=find(x);y=find(y);\n    if(x==y) return;\n    if(r[x]<r[y]) swap(x,y),w=-w;\n    r[x]+=r[y];\n    p[y]=x;\n    ws[y]=w;\n  }\n  int diff(int x,int y){\n    return weight(y)-weight(x);\n  }\n};\nint main(){\n  int n,m;\n  while(cin>>n>>m,n||m){\n    UnionFind u(n);\n    for(int i=0;i<m;i++){\n      int a,b;\n      char c;\n      cin>>c>>a>>b;\n      a--;b--;\n      if(c=='!'){\n\tint w;\n\tcin>>w;\n\tu.unite(a,b,w);\n      }else{\n\tif(!u.same(a,b)) cout<<\"UNKNOWN\"<<endl;\n\telse cout<<u.diff(a,b)<<endl;\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\nclass WeightedUF\n{\n\tpublic:\n\tvector<int> data;\n\tvector<int> diff_weight;\n\n\tWeightedUF(int s):data(s,-1),diff_weight(s,0){}\n\n\t//y-x=w\n\tbool unite(int x,int y,int w)\n\t{\n\t\tw+=weight(x);\n\t\tw-=weight(y);\n\t\tx=find(x);\n\t\ty=find(y);\n\t\tbool isunion=(x!=y);\n\t\tif(isunion)\n\t\t{\n\t\t\tif(data[x]>data[y])\n\t\t\t{\n\t\t\t\tswap(x,y);\n\t\t\t\tw=-w;\n\t\t\t}\n\t\t\tdata[x]+=data[y];\n\t\t\tdata[y]=x;\n\t\t\tdiff_weight[y]=w;\n\t\t}\n\t\treturn isunion;\n\t}\n\n\tint find(int x)\n\t{\n\t\tif(data[x]<0)\n\t\t\treturn x;\n\t\telse{\n\t\t\tint par=data[x];\n\t\t\tdata[x]=find(data[x]);\n\t\t\tdiff_weight[x]+=diff_weight[par];\n\t\t\treturn data[x];\n\t\t}\n\t}\n\tint weight(int x)\n\t{\n\t\tfind(x);\n\t\treturn diff_weight[x];\n\t}\n\tbool same(int x,int y)\n\t{\n\t\treturn find(x)==find(y);\n\t}\n};\n\nint main()\n{\n\twhile(1)\n\t{\n\t\tint n,m;\n\t\tcin>>n>>m;\n\t\tif(n==0)\n\t\t\tbreak;\n\t\tWeightedUF u=WeightedUF(n);\n\t\tfor(int i=0;i<m;i++)\n\t\t{\n\t\t\tchar q;\n\t\t\tcin>>q;\n\t\t\tif(q=='!')\n\t\t\t{\n\t\t\t\tint a,b,w;\n\t\t\t\tcin>>a>>b>>w;\n\t\t\t\ta--;b--;\n\t\t\t\tu.unite(a,b,w);\n\t\t\t}else{\n\t\t\t\tint a,b;\n\t\t\t\tcin>>a>>b;\n\t\t\t\ta--;b--;\n\t\t\t\tif(!u.same(a,b))\n\t\t\t\t\tcout<<\"UNKNOWN\"<<endl;\n\t\t\t\telse\n\t\t\t\t\tcout<<u.weight(b)-u.weight(a)<<endl;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cassert>\n#include<algorithm>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<29)\n#define MAX 1000000\nusing namespace std;\ntypedef long long ll;\nstruct P\n{\n  ll color,w;\n  P(ll color=-inf,ll w=-inf):color(color),w(w){}\n};\nP par[MAX];\nvoid init(){ rep(i,MAX)par[i] = P(i); }\n\nP find(int x)\n{\n  if(x == par[x].color)return par[x];\n  P p = find(par[x].color);\n  if(par[x].color == -inf)par[x].color = 0;\n  par[x].w += p.w,par[x].color = p.color;\n  return par[x];\n}\n\nvoid unit(int x,int y,ll w)//x <= y\n{\n  //cout << \"unit(\" << x << \",\" << y << \")\" << endl;\n  P X = find(x); \n  P Y = find(y);\n  //cout << \"X(\" << X.color << \",\" << X.w << \")\" << endl;\n  //cout << \"Y(\" << Y.color << \",\" << Y.w << \")\" << endl;\n  if(X.color == Y.color)return;\n  par[X.color].color = par[Y.color].color;\n  if(par[X.color].w == -inf)par[X.color].w = 0;\n  if(par[Y.color].w == -inf)par[Y.color].w = 0;\n  par[X.color].w = par[X.color].w - w + (par[y].w - par[x].w);\n}\n\nint N,M;\n\nint main()\n{\n  while(cin >> N >> M,N|M)\n    {\n      init();\n      char c;\n      ll a,b,w;\n      rep(_,M)\n\t{\n\t  cin >> c;\n\t  if(c == '!')\n\t    {\n\t      cin >> a >> b >> w;\n\t      unit(a,b,w);\n\t    }\n\t  else\n\t    {\n\t      cin >> a >> b;\n\t      ll B = find(b).w;\n\t      ll A = find(a).w;\n\t      if(B == -inf || A == -inf)cout << \"UNKNOWN\" << endl;\n\t      else cout << B-A << endl;\n\t    }\n\n\t  rep(i,10)\n\t    {\n\t      // cout << i << \" = \" << par[i].color << \",\" << par[i].w << endl;\n\t    }\t\n\t  //cout << endl;\n\n\t}\n    }\n  return 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define f first\n#define s second\n#define mp make_pair\n#define inf 1<<30\n#define MAX 100001\nusing namespace std;\n\nint p[MAX];\nmap<pair<int,int>,int> M;\n\npair<int,int> find(int a){\n  pair<int,int> pii;\n  if(p[a]==a){\n    pii.f=a;pii.s=0;\n    return pii;\n  }\n  pii=find(p[a]);\n  pii.s+=M[mp(p[a],a)];\n  return pii;\n}\n\nint main()\n{\n  int n,q,a,b,w;\n  char c;\n\n  while(1){\n    cin>>n>>q;\n    if(n+q==0)break;\n    for(int i=0;i<n;i++)p[i]=i;\n    M.clear();\n\n    for(int i=0;i<q;i++){\n      cin>>c;\n      if(c=='!'){\n\tcin>>a>>b>>w;\n\ta--;b--;\n\tM[mp(b,a)]=w;\n\tp[a]=b;\n      }\n      else {\n\tcin>>a>>b;\n\ta--;b--;\n\tpair<int,int> pa=find(a),pb=find(b);\n\tif(pa.f!=pb.f)cout<<\"UNKNOWM\"<<endl;\n\telse {\n\t  M.erase(mp(a,p[a]));\n\t  M.erase(mp(b,p[b]));\n\t  M[mp(a,pa.f)]=pa.s;\n\t  M[mp(a,pb.f)]=pb.s;\n\t  cout<<pa.s-pb.s<<endl;\n\t}\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": " \n#include <bits/stdc++.h>\nusing namespace std;\nusing ll=long long;\nusing vi=vector<int>;\nusing vvi=vector<vi>;\nusing vs=vector<string>;\nusing msi=map<string,int>;\nusing mii=map<int,int>;\nusing psi=pair<string,int>;\nusing pii=pair<int,int>;\nusing vlai=valarray<int>;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define range(i,s,n) for(int i=s;i<n;i++)\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\n#define fs first\n#define sc second\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define INF 1e9\n#define EPS 1e-9\n#define MOD ((ll)1e9+7)\nvoid get(){}template<class H,class...T>void get(H&h,T&...t){cin>>h;get(t...);}\ntemplate<class T>void geti(T&a){for(auto&_:a)cin>>_;}\ntemplate<class T>void getii(T&a){for(auto&_:a)geti(_);}\nvoid put(string d){}template<class H,class...T>void put(string d,H&h,T&...t){cout<<h;if(sizeof...(t))cout<<d;put(d,t...);}\ntemplate<class T>void puti(T&a,string d=\" \"){bool f=1;for(auto&_:a)cout<<(exchange(f,0)?\"\":d)<<_;cout<<endl;}\ntemplate<class T>void putii(T&a,string d=\" \"){for(auto&_:a)puti(_,d);}\n#define dcl(...) ll __VA_ARGS__;get(__VA_ARGS__)\n#define dclt(t,...) t __VA_ARGS__;get(__VA_ARGS__)\ntemplate<class F,class S>void add(map<F,S>&mp,F f,S s){if(mp.find(f)==mp.end())mp[f]=F();mp[f]+=s;}\n \nint main(){\n    int n,m;\n    while(cin>>n>>m,n){\n        vi where(n+1,-1);\n        vector<map<int,ll>> w;\n        char c;\n        rep(i,m){\n            cin>>c;\n            if(c=='!'){\n                ll a,b,x;\n                cin>>a>>b>>x;\n                if(where[a]==-1 && where[b]==-1){\n                    int i=w.size();\n                    where[a]=where[b]=i;\n                    w.eb();\n                    w[i][a]=0ll;\n                    w[i][b]=x;\n                }else if(where[a]==-1 || where[b]==-1){\n                    if(where[a]==-1){\n                        swap(a,b);\n                        x*=-1;\n                    }\n                    int i=where[a];\n                    where[b]=i;\n                    w[i][b]=w[i][a]+x;\n                }else{\n\n                    int i=where[a];\n                    int j=where[b];\n                    int diff=w[i][a]+x-w[j][b];\n                    for(auto data:w[j]){\n                        where[data.fs]=i;\n                        w[i].emplace(data.fs,data.sc+diff);\n                    }\n                }\n            }else{\n                int a,b;\n                cin>>a>>b;\n                if(where[a]!=where[b] || where[a]==-1){\n                    cout<<\"UNKNOWN\"<<endl;\n                }else{\n                    int i=where[a];\n                    cout<<w[i][b]-w[i][a]<<endl;\n                }\n            }\n        }\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define PI       3.1415926535897932384626433832795028841971\n#define INF 1000000000\n#define EPS      1e-10\n#define MOD      1000000\nusing namespace std;\ntypedef long long ll;\ntypedef pair<double,double> P;\ntypedef pair<double,P> PQ;\n\nstruct UF{\n\tint par[100000];\n\tint rank[100000];\n    ll si[100000];\n\n\tvoid init(int n){\n\t\trep(i,n){\n\t\t\tpar[i] = i;\n\t\t\trank[i] = 0;\n\t\t\tsi[i] = 0;\n\t\t}\n\t}\n\n\tint find(int x){\n\t\tif(par[x] == x) return x;\n\t\telse return find(par[x]);\n\t}\n    \n    ll value(int x, ll ret){\n        if(par[x] == x) return ret+si[x];\n        else return value(par[x],ret+si[x]);\n    }\n\n\tvoid unite(int x, int y, int w){\n        ll vx = value(x,0);\n        ll vy = value(y,0);\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif(x == y) return;\n\t\t\n\t\tif(rank[x] < rank[y]){\n\t\t\tpar[x] = y;\n            si[x] = vy-w;\n\t\t} else{\n\t\t\tpar[y] = x;\n            si[y] = vx+w;\n\t\t\tif(rank[x] == rank[y]) rank[x]++;\n\t\t}\n\t}\n\n\tbool same(int x, int y){\n\t\treturn find(x) == find(y);\n\t}\n} uf;\n\nint n, m;\n\nint main(){\n    while(cin >> n >> m){\n        if(n == 0 && m == 0) break;\n        uf.init(n);\n        rep(i,m){\n            char hoge;\n            int a, b, w;\n            cin >> hoge;\n            if(hoge == '!'){\n                cin >> a >> b >> w;\n                a--; b--;\n                if(uf.same(a,b)) continue;\n                uf.unite(a,b,w);\n            } else{\n                cin >> a >> b;\n                a--; b--;\n                if(!uf.same(a,b)){\n                    cout << \"UNKNOWN\" << endl;\n                    continue;\n                }\n                int numa = uf.si[a];\n                int numb = uf.si[b];\n                while(uf.par[a] != a){\n                    a = uf.par[a];\n                    numa -= uf.si[a];\n                }\n                while(uf.par[b] != b){\n                    b = uf.par[b];\n                    numb -= uf.si[b];\n                }\n                cout << numb-numa << endl;\n            }\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nconstexpr long long INF = 0xffffffffffff;\n\nclass union_find {\nprivate:\n\tvector<int> uf;\n\tvector<long long> pd;\n\npublic:\n\tunion_find(int n):uf(n, -1), pd(n, 0) {}\n\t\n\tinline int find(int x) {\n\t\tif(uf[x] < 0)\n\t\t\treturn x;\n\n\t\tconst int tmp = uf[x];\n\t\tuf[x] = find(uf[x]);\n\t\tpd[x] += pd[tmp];\n\t\treturn uf[x];\n\t}\n\n\tinline void unite(int xx, int yy, int d) {\n\t\tint x = find(xx), y = find(yy);\n\t\tif(x == y)\n\t\t\treturn;\n\t\t\n\t\td += pd[yy] - pd[xx];\n\t\tif(uf[x] < uf[y]) {\n\t\t\tswap(x, y);\n\t\t\td = -d;\n\t\t}\n\n\t\telse if(uf[x] == uf[y])\n\t\t\t--uf[y];\n\t\t\n\t\tuf[x] = y;\n\t\tpd[x] = d;\n\t}\n\t\n\tinline bool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\n\tinline long long get_dist(int x, int y) {\n\t\treturn same(x, y) ? pd[x] - pd[y] : INF;\n\t}\n};\n\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tfor(int n, m; cin >> n >> m && n;) {\n\t\tunion_find uf(n);\n\t\tfor(int i = 0; i < m; ++i) {\n\t\t\tchar q;\n\t\t\tint a, b;\n\t\t\tcin >> q >> a >> b;\n\n\t\t\tif(q == '!') {\n\t\t\t\tint d;\n\t\t\t\tcin >> d;\n\t\t\t\tuf.unite(a - 1, b - 1, d);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tconst long long ans = uf.get_dist(a - 1, b - 1);\n\t\t\t\tif(ans == INF)\n\t\t\t\t\tcout << \"UNKNOWN\" << endl;\n\t\t\t\telse\n\t\t\t\t\tcout << ans << endl;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\nusing namespace std;\n#define N 100010\n#define cl(xx,yy) memset((xx),(yy),sizeof((xx)))\n\nint n;\nint p[N],val[N];\n\nint find(int x){\n    int fa = p[x];\n    if(x == fa) return x;\n    int rt = find(p[x]);\n    val[x] += val[fa];\n    p[x] = rt;\n    return rt;\n}\n\nvoid updata(int a,int b,int w){\n    int rtb = find(b);\n    int delta = w - val[b];\n    p[rtb] = a;\n    val[rtb] += delta;\n}\n\nint main(){\n\n    //freopen(\"input.txt\",\"r\",stdin);\n\n    int m;\n    while(scanf(\"%d%d\",&n,&m)!=EOF){\n        if(!n && !m) break;\n        for(int i = 1; i <= n; i++){\n            val[i] = 0; p[i] = i;\n        }\n        while(m--){\n            char op[10]; int a,b,w;\n            scanf(\"%s\",op);\n            if(op[0] == '!'){\n                scanf(\"%d%d%d\",&a,&b,&w);\n                updata(a,b,w);\n            }\n            else{\n                scanf(\"%d%d\",&a,&b);\n                int rta = find(a);\n                int rtb = find(b);\n                if(rta != rtb)\n                    puts(\"UNKNOWN\");\n                else\n                    printf(\"%d\\n\",val[b] - val[a]);\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nconst long long UNKNOWN = LLONG_MAX;\n\nclass UnionFindTree\n{\n    int n;\n    vector<int> parent; // 親ノード\n    vector<int> rank;   // 木の高さの上限\n    vector<int> num;    // グループの要素数\n    vector<long long> weight;\n    int find(int x){\n        if(parent[x] == x)\n            return x;\n\n        int y = find(parent[x]);\n        weight[x] += weight[parent[x]];\n        parent[x] = y;\n        return y;\n    }\npublic:\n    UnionFindTree(int n0){ // コンストラクタ\n        n = n0;\n        parent.resize(n);\n        for(int i=0; i<n; ++i)\n            parent[i] = i;\n        rank.assign(n, 0);\n        num.assign(n, 1);\n        weight.assign(n, 0);\n    }\n    void unite(int x, int y, long long w){ // xとyのグループを併合\n        int x2 = find(x);\n        int y2 = find(y);\n        if(x2 != y2){\n            if(rank[x2] < rank[y2]){\n                parent[x2] = y2;\n                num[y2] += num[x2];\n                weight[x2] = w - weight[x] + weight[y];\n            }else{\n                parent[y2] = x2;\n                if(rank[x2] == rank[y2])\n                    ++ rank[x2];\n                num[x2] += num[y2];\n                weight[y2] = -w - weight[y] + weight[x];\n            }\n            -- n;\n        }\n    }\n    long long same(int x, int y){ // xとyのグループが同じかを調べる\n        if(find(x) == find(y))\n            return weight[x] - weight[y];\n        else\n            return UNKNOWN;\n    }\n};\n\nint main()\n{\n    for(;;){\n        int n, m;\n        cin >> n >> m;\n        if(n == 0)\n            return 0;\n\n        UnionFindTree uft(n+1);\n        while(--m >= 0){\n            char c;\n            int a, b;\n            cin >> c >> a >> b;\n\n            if(c == '!'){\n                long long w;\n                cin >> w;\n                uft.unite(a, b, w);\n            }else{\n                long long ret = uft.same(a, b);\n                if(ret == UNKNOWN)\n                    cout << \"UNKNOWN\" << endl;\n                else\n                    cout << ret << endl;\n            }\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\n#define int ll\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define PB push_back\n\nconst ll LLINF = (1LL<<60);\nconst int INF = (1LL<<30);\nconst int MOD = 1000000007;\n\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate <typename T> bool IN(T a, T b, T x) { return a<=x&&x<b; }\ntemplate<typename T> T ceil(T a, T b) { return a/b + !!(a%b); }\ntemplate<class S,class T>\nostream &operator <<(ostream& out,const pair<S,T>& a){\n  out<<'('<<a.first<<','<<a.second<<')';\n  return out;\n}\ntemplate<class T>\nostream &operator <<(ostream& out,const vector<T>& a){\n  out<<'[';\n  REP(i, a.size()) {out<<a[i];if(i!=a.size()-1)out<<',';}\n  out<<']';\n  return out;\n}\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\nclass UnionFind {\npublic:\n  const static int MAX_N = 100010;\n  int par[MAX_N];\n  int s[MAX_N];\n  UnionFind() { init(); }\n  UnionFind(int n) { init(n); }\n  void init() { for(int i=0; i<MAX_N; ++i) par[i] = i, s[i] = 1; }\n  void init(int n) { for(int i=0; i<n; ++i) par[i] = i, s[i] = 1; }\n  int find(int x) {\n    if(par[x] == x) return x;\n    return par[x] = find(par[x]);\n  }\n  void unite(int x, int y) {\n    x = find(x);\n    y = find(y);\n    if(x == y) return;\n    if(s[x] < s[y]) par[x] = y, s[y] = s[x] + s[y];\n    else par[y] = x, s[x] = s[x] + s[y];\n  }\n  bool same(int x, int y) { return find(x) == find(y);}\n};\nUnionFind uf;\n\nvector<PII> g[100010];\nint d[100010];\nvoid dfs(int x, int p, int dist) {\n  d[x] = dist;\n  for(auto e: g[x]) {\n    if(e.first != p) dfs(e.first, x, dist + e.second);\n  }\n}\n\nsigned main(void)\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  while(true) {\n    int n, m;\n    cin >> n >> m;\n    if(!n) break;\n\n    REP(i, n) g[i].clear();\n    memset(d, 0, sizeof(d));\n\n    vector<PII> query;\n    VI ans(m+5);\n    int idx = 0;\n    REP(i, m) {\n      char c;\n      int a, b;\n      cin >> c >> a >> b; a--, b--;\n      if(c == '!') {\n        int w; cin >> w;\n        uf.unite(a, b);\n        g[a].PB({b, -w});\n        g[b].PB({a, w});\n      } else {\n        query.PB({a, b});\n        if(!uf.same(a, b)) ans[idx] = LLINF;\n        idx++;\n      }\n    }\n    dfs(0, -1, 0);\n\n    REP(i, query.size()){\n      if(ans[i]==LLINF) cout << \"UNKNOWN\" << endl;\n      else cout << d[query[i].first] - d[query[i].second] << endl;\n    }\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <list>\n#include <set>\n#include <map>\n#include <queue>\n\nusing namespace std;\n#define DEBUG(x) cout<<#x<<\": \"<<x<<endl\n\n#define PB push_back\n#define MP make_pair\n#define F first\n#define S second\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n#define INT(a) int((a)+1e-9)\nint DX[4]={1,0,-1,0};\nint DY[4]={0,1,0,-1};\n\ntypedef pair<int,int> Pii;\n\n\n#define SUPnl 10002\n\nint nl;\nPii p[SUPnl];\t//p[n].F == n's parent, p[n].S == w[p[n].F]-w[n]\n\nvoid init(){REP(ni,nl){p[ni]=MP(-1,0);}}\n\nPii getRoot(int n){\n\tint rn=n; int w=0;\n\twhile(p[rn].F!=-1){\n\t\tw+=p[rn].S;\n\t\trn=p[rn].F;\n\t}\n\tif(rn!=n)p[n]=MP(rn,w);\n\treturn MP(rn,w);\n}\n\nvoid printW(int a, int b){\n\tPii rat=getRoot(a); Pii rbt=getRoot(b);\n\tif(rat.F!=rbt.F) cout<<\"UNKNOWN\"<<endl;\n\telse cout<< rbt.S - rat.S <<endl;\n}\n\nvoid setW(int a, int b, int w){\n\tPii rat=getRoot(a); Pii rbt=getRoot(b);\n\tif(rat.F==rbt.F) return;\n\tif(rat.S+w>=rbt.S){\n\t\tp[rbt.F]=MP(rat.F, rat.S+w-rbt.S);\n\t}else{\n\t\tp[rat.F]=MP(rbt.F, rbt.S-w-rat.S);\n\t}\n}\n\nint main(){\n\twhile(true){\n\t\tint ol;\n\t\tcin>>nl>>ol;\t\tif(!nl) return 0;\n\t\tinit();\n\t\tREP(oi,ol){\n\t\t\tchar ot; int a,b,w;\n\t\t\tcin>>ot;\n\t\t\tif(ot=='!'){\n\t\t\t\tcin>>a>>b>>w;\n\t\t\t\tsetW(a-1,b-1,w);\n\t\t\t}\n\t\t\tif(ot=='?'){\n\t\t\t\tcin>>a>>b;\n\t\t\t\tprintW(a-1,b-1);\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<map>\nusing namespace std;\n\nclass UF {\n    public:\n    vector<pair<int,int> > l;\n    UF(int n) {\n        for(int i=0; i<n; i++)\n            l.push_back(pair<int,int>(i,0));\n    }\n    pair<int,int> root(int x) {\n        if(x == l[x].first) return l[x];\n        pair<int,int> t = root(l[x].first);\n        l[x].first = t.first ;\n        l[x].second+= t.second;\n        return l[x];\n    }\n    void unite(int x, int y, int xMy) {\n        x = root(x).first;\n        pair<int,int> t = root(y);\n        y = t.first;\n        if(x == y) return;\n        l[y].first = l[x].first;\n        l[y].second= -(-xMy - t.second);\n    }\n    int weight(int x, int y) { // x - y else 123456\n        pair<int,int> s,t;\n        s = root(x);\n        t = root(y);\n        if(s.first != t.first) return 123456;\n        return s.second - t.second;\n    }\n};\n\n\nint main(void) {\n    while(1) {\n        int n,m;\n        scanf(\"%d%d\",&n,&m);\n        if(!n) break;\n        UF uf(n);\n        for(int i=0; i<m; i++) {\n            int a,b;\n            char s[3];\n            scanf(\"%s%d%d\",s,&a,&b);\n            a--, b--;\n            if(s[0] == '?') {\n                int w = uf.weight(b,a);\n                if(w == 123456)\n                    printf(\"UNKNOWN\\n\");\n                else\n                    printf(\"%d\\n\", w);\n            }\n            else {\n                int w;\n                scanf(\"%d\",&w);\n                uf.unite(b, a, w);\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,n) for(int i=0; i<n; i++)\ntypedef pair<int,int> pii;\n\nint par[100001];\nint we[100001];\nint rnk[100001];\n\npii getW(int x) {\n\tif(x == par[x]) return pii(x,0);\n\tpii res = getW(par[x]);\n\tpar[x] = res.first;\n\twe[x] += res.second;\n\treturn pii(par[x], we[x]);\n}\n\nint find(int x) {\n\treturn getW(x).first;\n}\n\nvoid uni(int x, int y, int w) {\n\tint a = find(x);\n\tint b = find(y);\n\tif(a == b) return;\n\tif(rnk[a] > rnk[b]) {\n\t\tpar[b] = a;\n\t\twe[b] = w - we[y] + we[x];\n\t} else {\n\t\tpar[a] = b;\n\t\twe[a] = -(w - we[y] + we[x]);\n\t\tif(rnk[a] == rnk[b]) rnk[b]++;\n\t}\n}\n\n\nint main() {\n\tint n, m;\n\twhile(cin >> n >> m, n and m) {\n\t\trep(i,n+1) {par[i] = i; we[i] = 0; rnk[i]=1;}\n\t\trep(i, m) {\n\t\t\tchar c;\n\t\t\tint x, y;\n\t\t\tx--; y--;\n\t\t\tcin >> c >> x >> y;\n\t\t\tif(c == '!') {\n\t\t\t\tint w;\n\t\t\t\tcin >> w;\n\t\t\t\tuni(x, y, w);\n\t\t\t} else {\n\t\t\t\tint a = find(x), b = find(y);\n\t\t\t\tif(a != b) cout << \"UNKNOWN\" << endl;\n\t\t\t\telse cout << we[y] - we[x] << endl;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cstdio>\nusing namespace std;\n\ntemplate<class Abel> struct UnionFind {\n\tvector<int> par;\n\tvector<int> rank;\n\tvector<Abel> diff_weight;\n\n\tUnionFind(int n = 1, Abel SUM_UNITY = 0) {\n\t\tinit(n, SUM_UNITY);\n\t}\n\n\tvoid init(int n = 1, Abel SUM_UNITY = 0) {\n\t\tpar.resize(n); rank.resize(n); diff_weight.resize(n);\n\t\tfor (int i = 0; i < n; ++i) par[i] = i, rank[i] = 0, diff_weight[i] = SUM_UNITY;\n\t}\n\n\tint root(int x) {\n\t\tif (par[x] == x) {\n\t\t\treturn x;\n\t\t}\n\t\telse {\n\t\t\tint r = root(par[x]);\n\t\t\tdiff_weight[x] += diff_weight[par[x]];\n\t\t\treturn par[x] = r;\n\t\t}\n\t}\n\n\tAbel weight(int x) {\n\t\troot(x);\n\t\treturn diff_weight[x];\n\t}\n\n\tbool issame(int x, int y) {\n\t\treturn root(x) == root(y);\n\t}\n\n\tbool merge(int x, int y, Abel w) {\n\t\tw += weight(x); w -= weight(y);\n\t\tx = root(x); y = root(y);\n\t\tif (x == y) return false;\n\t\tif (rank[x] < rank[y]) swap(x, y), w = -w;\n\t\tif (rank[x] == rank[y]) ++rank[x];\n\t\tpar[y] = x;\n\t\tdiff_weight[y] = w;\n\t\treturn true;\n\t}\n\n\tAbel diff(int x, int y) {\n\t\treturn weight(y) - weight(x);\n\t}\n};\n\nint main() {\n\tint N, M;\n\twhile (cin >> N >> M) {\n\t\tif (N == 0) break;\n\t\tUnionFind<int> uf(N);\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\tchar c; int a, b, w;\n\t\t\tcin >> c;\n\t\t\tif (c == '!') {\n\t\t\t\tcin >> a >> b >> w; --a, --b;\n\t\t\t\tuf.merge(a, b, w);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcin >> a >> b; --a, --b;\n\t\t\t\tif (!uf.issame(a, b)) puts(\"UNKNOWN\");\n\t\t\t\telse cout << uf.diff(a, b) << endl;\n\t\t\t}\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#define maxn 100100\nusing namespace std;\nlong long high[maxn],f[maxn],num[maxn];//f隶ー蠖穂ク贋ク?アゑシ敬igh隶ー蠖穂ク矩擇譛牙?蝮礼??系um隶ー蠖穂サ・i荳コ譬ケ逧??蟄占鰍轤ケ荳ェ謨ー (豺ア蠎ヲ??\nvoid init()//蛻晏ァ句喧 \n{\n\tfor(int i=0;i<maxn;i++)\n\t{\n\t\tf[i]=i;\n\t\thigh[i]=0;//譬ケ闃らせ逧?ォ伜コヲ荳コ0 \n\t}\n}\nint find(int x)\n{\n\tif(x==f[x]) return f[x];\n\tint r=f[x];\n\tf[x]=find(f[x]);\n\thigh[x]+=high[r];//霍晄?闃らせ逧?キ晉ヲサ \n\treturn f[x];//x逧??闃らせ \n}\nvoid unio(int x,int y,int w)\n{\n\tint fx=find(x);\n\tint fy=find(y);\n\tif(fx==fy)  return;\n\tf[fx]=fy;//fx逧??闃らせ蜿倅クコfy \n\thigh[fx]=high[y]-high[x]-w;\n\t//cout<<fx<<\" \"<<fy<<\"  \"<<high[fx]<<endl;\n}\nint main()\n{\n\tint t,n,m;\n\tchar s[5];\n\tint a,b,w;\n\twhile(scanf(\"%d%d\",&n,&m)!=EOF)\n\t{\n\t\tif(n==0&&m==0)\n\t\t{\n\t\t\treturn 0;\n\t\t}\n\t\tinit();\n\t\twhile(m--)\n\t\t{\n\t\t\tscanf(\"%s\",s);\n\t\t\tif(s[0]=='!')\n\t\t\t{\n\t\t\t\tscanf(\"%d%d%d\",&a,&b,&w);\n\t\t\t\tunio(a,b,w);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tscanf(\"%d%d\",&a,&b);\n\t\t\t\tint fx=find(a);\n\t\t\t\tint fy=find(b);\n\t\t\t\tif(fx==fy)\n\t\t\t\t{\n\t\t\t\t\tprintf(\"%lld\\n\",high[b]-high[a]);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tputs(\"UNKNOWN\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate<class T>\nstruct WeightedUnionFind{\n\tvector<int> par,rnk;\n\tvector<T> pardiff;\n\n\tWeightedUnionFind(int n) : par(n),rnk(n),pardiff(n){\n\t\tfor(int i = 0;i < n;i++) par[i] = i;\n\t}\n\n\tint find(int x){\n\t\tif(x == par[x]) return x;\n\t\tint root = find(par[x]);\n\t\tpardiff[x] += pardiff[par[x]];\n\t\treturn par[x] = root;\n\t}\n\n\tbool unite(int x,int y,T w){\n\t\tif(same(x,y)) return diff(x,y) == w;\n\t\tw = w + weight(x) - weight(y);\n\t\tx = find(x); y = find(y);\n\t\tif(rnk[x] < rnk[y]) swap(x,y), w = -w;\n\t\tif(rnk[x] == rnk[y]) rnk[x]++;\n\t\tpar[y] = x;\n\t\tpardiff[y] = w;\n\t\treturn true;\n\t}\n\t\n\tinline bool same(int x,int y){\n\t\treturn find(x) == find(y);\n\t}\n\n\tT diff(int x,int y){\n\t\tassert(same(x,y));\n\t\treturn weight(y) - weight(x);\n\t}\n\n\tT weight(int x){\n\t\tfind(x);\n\t\treturn pardiff[x];\n\t}\n};\n\nusing ll = long long;\n\nint n,m;\n\nvoid solve(){\n\tWeightedUnionFind<ll> wuf(n);\n\tfor(int i = 0;i < m;i++){\n\t\tchar c[1];\n\t\tint a,b;\n\t\tscanf(\"%s %d %d\",c,&a,&b); a--;b--;\n\t\tif(c[0] == '!'){\n\t\t\tll w;\n\t\t\tscanf(\"%lld\",&w);\n\t\t\twuf.unite(a,b,w);\n\t\t}else{\n\t\t\tif(!wuf.same(a,b)) puts(\"UNKNOWN\");\n\t\t\telse printf(\"%lld\\n\",wuf.diff(a,b));\n\t\t}\n\t}\n}\n\nsigned main(){\n\twhile(scanf(\"%d %d\",&n,&m),n) solve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cassert>\n#include<algorithm>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<29)\n#define MAX 1000000\nusing namespace std;\ntypedef long long ll;\nstruct P\n{\n  ll color,w;\n  P(ll color=-inf,ll w=-inf):color(color),w(w){}\n};\nP par[MAX];\nvoid init(){ rep(i,MAX)par[i] = P(i); }\n\nP find(int x)\n{\n  if(x == par[x].color)return par[x];\n  P p = find(par[x].color);\n  if(par[x].w == -inf)par[x].w = 0;\n  par[x].w += p.w,par[x].color = p.color;\n  return par[x];\n}\n\nvoid unit(int x,int y,ll w)//x <= y\n{\n  P X = find(x); \n  P Y = find(y);\n  if(X.color == Y.color)return;\n  par[X.color].color = par[Y.color].color;\n  if(par[X.color].w == -inf)par[X.color].w = 0;\n  if(par[Y.color].w == -inf)par[Y.color].w = 0;\n  par[X.color].w = par[X.color].w + (par[y].w-w - par[x].w);\n  //par[x].w -= par[y].w;\n}\n\nint N,M;\n\nint main()\n{\n  while(cin >> N >> M,N|M)\n    {\n      init();\n      char c;\n      ll a,b,w;\n      rep(_,M)\n\t{\n\t  cin >> c;\n\t  if(c == '!')\n\t    {\n\t      cin >> a >> b >> w;\n\t      unit(a,b,w);\n\t    }\n\t  else\n\t    {\n\t      cin >> a >> b;\n\t      ll B = find(b).w;\n\t      ll A = find(a).w;\n\t      if(B == -inf || A == -inf)cout << \"UNKNOWN\" << endl;\n\t      else cout << B-A << endl;\n\t    }\n\n\t  rep(i,10)\n\t    {\n\t      // cout << i << \" = \" << par[i].color << \",\" << par[i].w << endl;\n\t    }\t\n\t  //cout << endl;\n\n\t}\n    }\n  return 0;\n} "
  },
  {
    "language": "C++",
    "code": "// 2012アジア地区予選 F : Never Wait for Weights\n\n#include <iostream>\n#include <vector>\n#include <queue>\n#include <cstring>\n#include <cstdio>\n\nusing namespace std;\n\nstruct Query{\n\tchar type; int a, b, w;\n};\n\nint weight[100000];\nint root[100000];\nint getRoot(int v){ return root[v]==-1 ? v : root[v] = getRoot(root[v]); }\n\nint main(){\n\tint N, M;\n\twhile(cin >> N >> M && N){\n\t\tvector< vector< pair<int, int> > > vp(N);\n\t\tvector<Query> vq(M);\n\t\tfor(int i=0;i<M;i++){\n\t\t\tcin >> vq[i].type;\n\t\t\tif(vq[i].type == '!') cin >> vq[i].a >> vq[i].b >> vq[i].w;\n\t\t\telse                  cin >> vq[i].a >> vq[i].b;\n\t\t\t--vq[i].a;\n\t\t\t--vq[i].b;\n\t\t}\n\t\tfor(int i=0;i<M;i++){\n\t\t\tif(vq[i].type == '?') continue;\n\t\t\tvp[vq[i].a].push_back(make_pair(vq[i].b,  vq[i].w));\n\t\t\tvp[vq[i].b].push_back(make_pair(vq[i].a, -vq[i].w));\n\t\t}\n\t\tmemset(root, 0, sizeof(root));\n\t\tfor(int i=0;i<N;i++){\n\t\t\tif(root[i]) continue;\n\t\t\tweight[i] = 0;\n\t\t\troot[i] = 1;\n\t\t\tqueue<int> qu; qu.push(i);\n\t\t\twhile(!qu.empty()){\n\t\t\t\tint pos = qu.front(); qu.pop();\n\t\t\t\tfor(int j=0;j<vp[pos].size();j++){\n\t\t\t\t\tint next = vp[pos][j].first;\n\t\t\t\t\tif(root[next]) continue;\n\t\t\t\t\tweight[next] = weight[pos] + vp[pos][j].second;\n\t\t\t\t\tqu.push(next);\n\t\t\t\t\troot[next] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmemset(root, -1, sizeof(root));\n\t\tfor(int i=0;i<M;i++){\n\t\t\tif(vq[i].type == '?'){\n\t\t\t\tif(getRoot(vq[i].a) == getRoot(vq[i].b)) printf(\"%d\\n\", weight[vq[i].b] - weight[vq[i].a]);\n\t\t\t\telse                                     printf(\"UNKNOWN\\n\");\n\t\t\t} else {\n\t\t\t\tint p = getRoot(vq[i].a);\n\t\t\t\tint q = getRoot(vq[i].b);\n\t\t\t\tif(p != q) root[q] = p;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "/* #include <bits/stdc++.h> */\n#include <iostream>\n#include <vector>\nusing namespace std;\n#define _GLIBCXX_DEBUG\n\nvector<pair<int, int>> rW; // <base, relative weight>\nint n;\n\nvoid init() {\n  for (int i = 1; i <= n; i++)\n    rW[i] = make_pair(i, 0);\n}\npair<int, int> get_weight(int x) {\n  if (rW[x].first == x) {\n    return {x, 0};\n  } else {\n    pair<int, int> res = get_weight(rW[x].first);\n    res.second += rW[x].second;\n    return (rW[x] = res);\n  }\n}\nbool is_same_set(int a, int b) {\n  return get_weight(a).first == get_weight(b).first;\n}\nvoid punite(int parent, int child, int w) {\n  pair<int, int> b = get_weight(parent);\n  b.second += w - get_weight(child).second;\n  rW[get_weight(child).first] = b;\n}\n\nint main() {\n  int m;\n  while (cin >> n >> m) {\n    if (!n && !m) {\n      break;\n    }\n    rW = vector<pair<int, int>>(n + 1);\n    vector<bool> checked(n + 1, false);\n    init();\n    for (int i = 0; i < m; i++) {\n      char ope;\n      cin >> ope;\n      if (ope == '!') {\n        int a, b, w;\n        cin >> a >> b >> w;\n        punite(a, b, w);\n        checked[a] = true;\n        checked[b] = true;\n      } else {\n        int a, b;\n        cin >> a >> b;\n        if (!checked[a] || !checked[b] || !is_same_set(a, b)) {\n          cout << \"UNKNOWN\" << endl;\n        } else {\n          cout << get_weight(b).second - get_weight(a).second << endl;\n        }\n      }\n    }\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<utility>\n#include<string>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<map>\n#include<climits>\n#include<queue>\n\n#define REP(i, n) for(int i = 0;i < n;i++)\n#define REPR(i, n) for(int i = n;i >= 0;i--)\n#define FOR(i, m, n) for(int i = m;i < n;i++)\n#define FORR(i, m, n) for(int i = m;i >= n;i--)\n#define SORT(v, n) sort(v, v+n);\n#define VSORT(v) sort(v.begin(), v.end());\n#define llong long long\n#define pb(a) push_back(a)\nusing namespace std;\ntypedef pair<int, int> P;\ntypedef long long int ll;\ntypedef pair<ll,ll> LLP;\nint dx[4] = {1,0,0,-1};\nint dy[4] = {0,1,-1,0};\n#define INF 1000000000007\n#define MOD 1000000007\n#define ARRAY_MAX 3005\n\n\n//重み付きUnion-Find\nstruct Potential_UnionFind{\n\n    vector<int> par;//親\n    vector<int> rank;//高さ\n    vector<int> diff_weight;//根からの重み\n\n    void init(int n) {\n        par.resize(n);\n        rank.resize(n);\n        diff_weight.resize(n);\n        REP(i,n){\n            par[i] = i;\n            rank[i] = 0;\n            diff_weight[i] = 0;\n        }\n    }\n\n    int root(int x) {//親を探す\n        if (par[x] == x) {\n            return x;\n        }\n        else {\n            int r = root(par[x]);\n            diff_weight[x] += diff_weight[par[x]];\n            return par[x] = r;\n        }\n    }\n\n    int weight(int x) {\n        //親からの重みを返す\n        root(x);\n        return diff_weight[x];\n    }\n\n    bool issame(int x,int y) {\n        //同じ親を持つ要素かどうか\n        return root(x) == root(y);\n    }\n\n    void merge(int x, int y,int w) {\n        //weight(y) - weight(x) = wとなるようにつなげる\n        int rx = root(x);\n        int ry = root(y);\n        \n        if(rank[rx] < rank[ry]){\n            diff_weight[rx] = -w - weight(x) + weight(y);\n            par[rx] = ry;\n        }else{\n            diff_weight[ry] = w + weight(x) - weight(y);\n            par[ry] = rx;\n            if(rank[rx] == rank[ry]){\n                rank[rx]++;\n            }\n        }\n    }\n\n    int diff(int x, int y) {\n        //weight(y) - weight(x)を返す\n        return weight(y) - weight(x);\n    }\n};\n\n\nint main(){\n\n    \n    int n,m;\n    while(cin >> n >> m,n|m){\n        Potential_UnionFind tree;\n        tree.init(n);\n        bool ans = true;\n\n        for(int i = 0;i < m;i++){\n\n            char ch;\n            int a,b,w;\n            cin >> ch;\n            if(ch == '?'){\n                cin >> a >> b;\n                a--;\n                b--;\n                if(tree.issame(a,b)){\n                    cout << tree.diff(a,b) << endl;\n                }else{\n                    cout << \"UNKNOWN\" << endl;\n                }\n            }else{\n                cin >> a >> b >> w;\n                a--;\n                b--;\n                tree.merge(a,b,w);\n            }\n        }\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <cstdint>\n\nclass UnionFind {\n  std::vector<int> vertex;\n  std::vector<intmax_t> weight;\n\npublic:\n  UnionFind(size_t V): vertex(V, -1), weight(V, 0) {}\n\n  bool unite(size_t u, size_t v, intmax_t w) {\n    size_t pu=u, pv=v;\n    if (u >= 0) u = find(u);\n    if (v >= 0) v = find(v);\n    if (u == v) return false;\n    if (vertex[u] > vertex[v]) {\n      std::swap(u, v);\n      std::swap(pu, pv);\n      w = -w;\n    }\n\n    // u:parent, v:child\n    vertex[u] += vertex[v];\n    vertex[v] = u;\n    weight[v] = w + weight[pu];\n    return true;\n  }\n\n  /*\n  int find(size_t v) {\n    size_t pv=v;\n    while (vertex[v] >= 0) {\n      weight[pv] += weight[vertex[v]];\n      v = vertex[v];\n    }\n\n    return vertex[pv] = v;\n    }\n  */\n  int find(size_t v) {\n    if (vertex[v] < 0)\n      return v;\n\n    size_t u;\n    for (u=v; vertex[u]>=0; u=vertex[u]) {\n      weight[v] += weight[vertex[u]];\n    }\n\n    return (vertex[v] = find(vertex[v]));\n  }\n\n  bool connected(size_t u, size_t v) {\n    return find(u) == find(v);\n  }\n\n  intmax_t relweight(size_t u) const {\n    if (vertex[u] < 0) {\n      return 0;\n    }\n\n    return weight[u] + relweight(vertex[u]);\n  }\n};\n\nint testcase_ends() {\n  int N, M;\n  scanf(\"%d %d\", &N, &M);\n\n  if (N == 0)\n    return 1;\n\n  UnionFind uf(N);\n\n  for (int i=0; i<M; ++i) {\n    char ch;\n    scanf(\" %c\", &ch);\n\n    if (ch == '?') {\n      int a, b;\n      scanf(\"%d %d\", &a, &b);\n      --a, --b;\n      if (uf.connected(a, b)) {\n        printf(\"%jd\\n\", uf.relweight(b)-uf.relweight(a));\n      } else {\n        printf(\"UNKNOWN\\n\");\n      }\n    } else if (ch == '!') {\n      int a, b, w;\n      scanf(\"%d %d %d\", &a, &b, &w);\n      --a, --b;\n      uf.unite(a, b, w);\n    }\n  }\n\n  return 0;\n}\n\nint main() {\n  while (!testcase_ends()) {}\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cassert>\n#include<algorithm>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<29)\n#define MAX 3000000\nusing namespace std;\ntypedef long long ll;\nstruct P\n{\n  ll color,w;\n  P(ll color=-inf,ll w=-inf):color(color),w(w){}\n};\nP par[MAX];\nvoid init(){ rep(i,MAX)par[i] = P(i); }\n\nP find(int x)\n{\n  if(x == par[x].color)return par[x];\n  P p = find(par[x].color);\n  if(par[x].w == -inf)par[x].w = 0;\n  par[x].w += p.w,par[x].color = p.color;\n  return par[x];\n}\n\nvoid unit(int x,int y,ll w)//x <= y\n{\n  P X = find(x); \n  P Y = find(y);\n  //if(X.color == Y.color)return;\n  par[X.color].color = par[Y.color].color;\n  if(par[X.color].w == -inf)par[X.color].w = 0;\n  if(par[Y.color].w == -inf)par[Y.color].w = 0;\n  par[X.color].w = par[X.color].w + (par[y].w-w - par[x].w);\n  //par[x].w -= par[y].w;\n}\n\nint N,M;\n\nint main()\n{\n  while(cin >> N >> M,N|M)\n    {\n      init();\n      char c;\n      ll a,b,w;\n      rep(_,M)\n\t{\n\t  cin >> c;\n\t  if(c == '!')\n\t    {\n\t      cin >> a >> b >> w;\n\t      unit(a,b,w);\n\t    }\n\t  else\n\t    {\n\t      cin >> a >> b;\n\t      P B = find(b);\n\t      P A = find(a);\n\t      if(B.w == -inf || A.w == -inf)cout << \"UNKNOWN\" << endl;\n\t      else if(B.color != A.color)cout << \"UNKNOWN\" << endl;\n\t      else cout << B.w-A.w << endl;\n\t    }\n\n\t  rep(i,10)\n\t    {\n\t      // cout << i << \" = \" << par[i].color << \",\" << par[i].w << endl;\n\t    }\t\n\t  //cout << endl;\n\n\t}\n    }\n  return 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#pragma warning(disable : 4996)\nusing namespace std;\npair<int, int> par[100000];\npair<int, int> root(int x) {\n\tif (par[x].first == x) return make_pair(x, 0);\n\tpair<int, int> ret = root(par[x].first);\n\treturn par[x] = make_pair(ret.first, ret.second + par[x].second);\n}\nbool same(int x, int y) {\n\treturn root(x).first == root(y).first;\n}\nvoid unite(int x, int y, int w) { \n\tx = root(x).first; y = root(y).first;\n\tif (x != y) {\n\t\tpar[x] = make_pair(y, w);\n\t}\n}\nint query(int a, int b) {\n\treturn root(a).second - root(b).second;\n}\nint N, Q, a, b, w; char c;\nint main() {\n\twhile (true) {\n\t\tscanf(\"%d%d\", &N, &Q);\n\t\tif (N == 0 && Q == 0) break;\n\t\tfor (int i = 0; i < N; i++) par[i] = make_pair(i, 0);\n\t\tfor (int i = 0; i < Q; i++) {\n\t\t\tcin >> c;\n\t\t\tif (c == '!') {\n\t\t\t\tscanf(\"%d%d%d\", &a, &b, &w);\n\t\t\t\tunite(a - 1, b - 1, w);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tscanf(\"%d%d\", &a, &b);\n\t\t\t\tif (!same(a - 1, b - 1)) {\n\t\t\t\t\tprintf(\"UNKNOWN\\n\");\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tprintf(\"%d\\n\", query(a - 1, b - 1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#define maxlen 200010\nusing namespace std;\nint father[maxlen];\nlong long  dist[maxlen];\nint n,m;\nchar cmd;\nvoid init()\n{\n    for(int i=0; i<=n; ++i)\n    {\n        father[i]=i;\n        dist[i]=0;\n    }\n}\nint Find(int x)\n{\n    if(father[x]==x)\n        return x;\n    else\n    {\n        int root=Find(father[x]);\n        dist[x]+=dist[father[x]];//更新dist\n        return father[x]=root;\n    }\n}\nint main ()\n{\n    //freopen(\"in.txt\",\"r\",stdin);\n    //freopen(\"out.txt\",\"w\",stdout);\n    int x,y,w;\n    char cmd;\n    while(scanf(\"%d%d\",&n,&m)!=EOF)\n    {\n        if(n==0&&m==0)\n            break;\n        init();\n        for(int i=0; i<m; ++i)\n        {\n            cin>>cmd;\n            if(cmd=='!')\n            {\n                scanf(\"%d%d%d\",&x,&y,&w);\n                //if(Find(x)!=Find(y))\n                //{\n                    father[x]=y;//合并\n                    dist[x]=w;\n                    dist[y]=0;\n                //}\n            }\n            else if(cmd=='?')\n            {\n                scanf(\"%d%d\",&x,&y);\n                if(Find(x)!=Find(y))\n                {\n                    printf(\"UNKNOWN\\n\");\n                    continue;\n                }\n                //Find(x);\n                //Find(y);\n                printf(\"%lld\\n\",dist[x]-dist[y]);\n            }\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long   // <-----!!!!!!!!!!!!!!!!!!!\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n)-1;i>=0;i--)\n#define rrep2(i,a,b) for (int i=(a)-1;i>=b;i--)\n#define chmin(a,b) (a)=min((a),(b));\n#define chmax(a,b) (a)=max((a),(b));\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n#define printV(v) cout<<(#v)<<\":\";for(auto(x):(v)){cout<<\" \"<<(x);}cout<<endl;\n#define printVS(vs) cout<<(#vs)<<\":\"<<endl;for(auto(s):(vs)){cout<<(s)<< endl;}\n#define printVV(vv) cout<<(#vv)<<\":\"<<endl;for(auto(v):(vv)){for(auto(x):(v)){cout<<\" \"<<(x);}cout<<endl;}\n#define printP(p) cout<<(#p)<<(p).first<<\" \"<<(p).second<<endl;\n#define printVP(vp) cout<<(#vp)<<\":\"<<endl;for(auto(p):(vp)){cout<<(p).first<<\" \"<<(p).second<<endl;}\n\ninline void output(){ cerr << endl; }\ntemplate<typename First, typename... Rest>\ninline void output(const First& first, const Rest&... rest) {\n    cerr << first << \" \"; output(rest...);\n}\n\nusing ll = long long;\nusing Pii = pair<int, int>;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vvvi = vector<vvi>;\nconst int inf = 2e9;\nconst int mod = 1e9 + 7;\n\nstruct edge {\n    int to, cost;\n    edge(){}\n    edge(int _to, int _cost) : to(_to), cost(_cost) {}\n};\nusing Graph = vector<vector<edge>>;\n\nclass LCA {\nprivate:\n    static const int MAX_LOG = 20;\n    const int n;\n    Graph G;\n    vector<vector<int>> par;\n    vector<int> depth;\n    vector<int> cost;\n\npublic:\n    void bfs() {\n        // v, p, d, c\n        using State = tuple<int, int, int, int>;\n        queue<State> que;\n        que.push(State(0, -1, 0, 0));\n        while (!que.empty()) {\n            int v, p, d, c;\n            tie(v, p, d, c) = que.front(); que.pop();\n            par[0][v] = p;\n            depth[v] = d;\n            cost[v] = c;\n            for (auto e : G[v]) {\n                if (e.to != p) {\n                    que.push(State(e.to, v, d + 1, c + e.cost));\n                }\n            }\n        }\n    }\n    LCA(int _n) : n(_n), G(_n), par(MAX_LOG, vector<int>(_n)), depth(_n), cost(_n) {}\n    void addEdge(int a, int b, int c) {\n        G[a].emplace_back(b, c);\n        G[b].emplace_back(a, -c);\n    }\n    void init(bool debug = false) {\n        bfs();\n        rep(i, MAX_LOG - 1) {\n            rep(j, n) {\n                if (par[i][j] == -1) {\n                    par[i + 1][j] = -1;\n                } else {\n                    par[i + 1][j] = par[i][par[i][j]];\n                }\n            }\n        }\n    }\n    int lca(int a, int b) {\n        if (depth[a] > depth[b]) {\n            swap(a, b);\n        }\n        rep(i, MAX_LOG) {\n            if ((depth[b] - depth[a]) >> i & 1) {\n                b = par[i][b];\n            }\n        }\n        if (a == b) return a;\n\n        rrep(i, MAX_LOG) {\n            if (par[i][a] != par[i][b]) {\n                a = par[i][a];\n                b = par[i][b];\n            }\n        }\n        return par[0][a];\n    }\n    int query(int a, int b) {\n        int v = lca(a, b);\n        return - (cost[a] - cost[v]) + cost[b] - cost[v];\n    }\n};\n\nclass UnionFind {\nprivate:\n    const int n;\n    vector<int> uni;\npublic:\n    UnionFind(int _n) : n(_n), uni(_n, -1) {}\n    int root(int x) {\n        if (uni[x] < 0) return x;\n        return uni[x] = root(uni[x]);\n    }\n    bool same(int x, int y) {\n        return root(x) == root(y);\n    }\n    bool unite(int x, int y) {\n        x = root(x);\n        y = root(y);\n        if (x == y) return false;\n        if (uni[x] > uni[y]) swap(x, y);\n        uni[x] += uni[y];\n        uni[y] = x;\n        return true;\n    }\n    int getSize(int x) {\n        return -uni[root(x)];\n    }\n    void print() {\n        for (auto x : uni) cout << x << \" \";\n        cout << endl;\n    }\n};\n\nstruct Query {\n    char t;\n    int a, b;\n    Query(){}\n    Query(char t, int a, int b) : t(t), a(a), b(b) {}\n    void disp() {\n        output(t, a, b);\n    }\n};\n\nsigned main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n\n    int n, m;\n    while (cin >> n >> m, n) {\n        // s = 0: super root\n        // v = 1, 2, ...: items\n        const int s = 0;\n        LCA lca(n + 1);\n        UnionFind uf(n + 1);\n        vector<Query> queries;\n        rep(i, m) {\n            char t;\n            int a, b;\n            cin >> t >> a >> b;\n            queries.emplace_back(t, a, b);\n            if (t == '!') {\n                int c;\n                cin >> c;\n                if (uf.unite(a, b)) {\n                    lca.addEdge(a, b, c);\n                }\n            }\n        }\n\n        rep2(i, 1, n + 1) {\n            // connect s and the one of groups\n            if (uf.unite(s, i)) {\n                lca.addEdge(s, i, 0);\n            }\n        }\n\n        lca.init();\n\n        {\n            UnionFind uf(n + 1);\n            for (const auto& q : queries) {\n                if (q.t == '!') {\n                    uf.unite(q.a, q.b);\n                }\n                else {\n                    if (uf.same(q.a, q.b)) {\n                        cout << lca.query(q.a, q.b) << endl;\n                    }\n                    else {\n                        cout << \"UNKNOWN\" << endl;\n                    }\n                }\n            }\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\nusing namespace std;\n\nstruct UnionFind{\n  vector< pair<int, int> > data;\n  UnionFind(int n) : data(n, pair<int,int>(-1,0)) {}\n  bool unite(int x, int y, int w){//weight(y)-weight(x) = w;\n    int x_ = find(x), y_ = find(y);\n    if(x_ == y_) return true;\n    if(x_ != y_){\n      if(data[y_].first < data[x_].first){\n\tswap(x_,y_);\n\tswap(x,y);\n\tw *= -1;\n      }\n      data[x_].first += data[y_].first;//???????????´??°\n      data[y_].first = x_;//????????´??°\n      data[y_].second += w + rel_weight(x);\n    }\n    return true;\n  }\n  bool same(int x, int y){ return find(x) == find(y); }\n  int find(int x){\n    if(data[x].first < 0) return x;\n    int p = find(data[x].first);\n    data[x].second += data[p].second;\n    data[x].first = p;\n    return data[x].first;\n  }\n  int rel_weight(int x){\n    return data[x].second;\n  }\n};\n\nint main(){\n  int N, M;\n  while(cin >> N >> M, N){\n    UnionFind uf(N);\n    char q;\n    int a, b, w;\n    for(int i = 0; i < M; ++i){\n      cin >> q >> a >> b;\n      --a;--b;\n      if(q == '!'){\n\tcin >> w;\n\tuf.unite(a,b,w);\n      }else{\n\t//cout << uf.find(a) << \" \" << uf.find(b) << endl;\n\tif(uf.same(a,b)){\n\t  cout << uf.rel_weight(b) - uf.rel_weight(a) << endl;\n\t}else{\n\t  cout << \"Unknown\" << endl;\n\t}\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nstatic const int maxm = 100002;\n\nstruct sample {\n\tint num, par, diff, rank;//this - par\n};\n\n//1-origin\nsample s[maxm];\n//int mrank[maxm]; //child - parent\n\nvoid init(int n) {\n\tfor (int i = 1; i <= n; i++) {\n\t\ts[i].num = i;\n\t\ts[i].par = i;\n\t\ts[i].diff = 0;\n\t\ts[i].rank = 0;\n\t}\n}\n\nsample find(int x) {\n\tif (s[x].par == x) {\n\t\treturn s[x];\n\t} else {\n\t\tsample root = find(s[x].par);\n\t\ts[x].par = root.par;\n\t\ts[x].diff += root.diff;\n\t\troot.diff = s[x].diff;\n\t\treturn root;\n\t}\n}\n\nvoid unite(int x, int y, int d) {//d = y - x\n\tsample rootx = find(x);\n\tsample rooty = find(y);\n\n\t\n\tif (rootx.num == rooty.num)return;\n\n\tif (s[rootx.num].rank < s[rooty.num].rank) {\n\t\ts[rootx.num].par = rooty.num;\n\t\ts[rootx.num].diff = (-1) * (d - rooty.diff + rootx.diff);\n\t} else {\n\t\ts[rooty.num].par = rootx.num;\n\t\ts[rooty.num].diff = d - rooty.diff + rootx.diff;\n\t\tif (s[rootx.num].rank == s[rooty.num].rank)s[rootx.num].rank++;\n\t}\n}\n\nbool isSame(int x, int y) {\n\treturn find(x).num == find(y).num;\n}\n\n\n\nint main() {\n\twhile (1) {\n\t\tint i, j, k;\n\t\tint n, m;\n\n\t\tcin >> n >> m;\n\t\tif (n == 0 && m == 0)break;\n\n\t\tinit(n);\n\n\t\tchar cmd;\n\t\tint a, b, w;\n\t\tfor (i = 0; i < m; i++) {\n\t\t\tcin >> cmd >> a >> b;\n\t\t\tif (cmd == '!') {\n\t\t\t\tcin >> w;\n\t\t\t\tunite(a, b, w); //w = b - a\n\t\t\t} else if (cmd == '?') {\n\t\t\t\tif (!isSame(a, b)) {\n\t\t\t\t\tcout << \"UNKNOWN\" << endl;\n\t\t\t\t} else {\n\t\t\t\t\tcout << find(b).diff - find(a).diff << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\n\n\n\n\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\nconst int S = 100010;\n\nstruct UnionFind {\n  vector<int> node;\n  vector<ll> weight;\n  UnionFind() : node(S, -1), weight(S, 0) {}\n  void unite(int u, int v, ll w) {\n    int ov = v, ou = u;\n    u = find(u), v = find(v);\n    int wa = weight[ov], wb = weight[ou];\n    if(u == v) return;\n    \n    // (v ??????) ??? (u ??????) ???????????????\n    node[u] += node[v];\n    node[v] = u;\n    weight[v] += w + wb - wa;\n  }\n  \n  int find(int u) {\n    if(node[u] < 0) return u;\n    int par = node[u], root = find(node[u]);\n    weight[u] += weight[par];\n    return node[u] = root;\n  }\n};\n\nint main() {\n  int N, M;\n  while(cin >> N >> M, N) {\n    UnionFind uf;\n    for(int i=0; i<M; i++) {\n      char c; cin >> c;\n      if(c == '!') {\n\tint a, b, d; cin >> a >> b >> d;\n\ta--; b--;\n\tuf.unite(a, b, d);\n      }\n      else {\n\tint a, b; cin >> a >> b;\n\ta--; b--;\n\tif(uf.find(a) != uf.find(b)) cout << \"UNKNOWN\" << endl;\n\telse {\n\t  ll wa = uf.get_weight(a);\n\t  ll wb = uf.get_weight(b);\n\t  cout << wb - wa << endl;\n\t}\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <utility>\n#include <set>\n#include <map>\n#include <deque>\n#include <queue>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio>\n#include <stdio.h>\n\nusing namespace std;\n\n#define fo(i,n) for(int i=0; i<(int)n; i++)\n#define rep(it,s) for(__typeof((s).begin()) it=(s).begin();it!=(s).end();it++)\n#define mp(a,b) make_pair(a,b)\n#define pb(x) push_back(x)\n#define pii pair<int,int>\n\nint n,m;\nint par[100010];\nint w[100010];\n\nint get(int a) {\n\tif (a==par[a]) return a;\n\tint p = par[a];\n\tp = get(p);\n\tw[a] += w[par[a]];\n\tpar[a] = p;\n\treturn par[a];\n}\n\nvoid connect(int a, int b, int c) {\n\tpar[a] = b;\n\tw[a] = c;\n\tget(a);\n}\n\nint main() {\n\n    //freopen(\"input.txt\",\"r\",stdin);\n    //freopen(\"output.txt\",\"w\",stdout);\n\n\twhile (scanf(\"%d%d\",&n,&m) && n!=0) {\n\t\tfor (int i=0; i<n; i++) par[i] = i;\n\t\tfor (int i=0; i<n; i++) w[i] = 0;\n\t\t\n\t\tfor (int i=0; i<m; i++) {\n\t\t\tchar c[5];\n\t\t\tscanf(\"%s\",c);\n\t\t\tif (c[0]=='!') {\n\t\t\t\tint a,b,d;\n\t\t\t\tscanf(\"%d%d%d\",&a,&b,&d);\n\t\t\t\ta--; b--;\n\t\t\t\tif (get(a)==get(b)) continue;\n\t\t\t\tconnect(a,b,d);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tint a,b;\n\t\t\t\tscanf(\"%d%d\",&a,&b);\n\t\t\t\ta--; b--;\n\t\t\t\tif (get(a)!=get(b)) {\n\t\t\t\t\tprintf(\"UNKNOWN\\n\");\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tprintf(\"%d\\n\",w[a]-w[b]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n    return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define f first\n#define s second\n#define mp make_pair\n#define inf 1<<30\n#define MAX 100001\nusing namespace std;\n\nint p[MAX];\nmap<pair<int,int>,int> M;\n\npair<int,int> find(int a){\n  pair<int,int> pii;\n  if(p[a]==a){\n    pii.f=a;pii.s=0;\n    return pii;\n  }\n  pii=find(p[a]);\n  pii.s+=M[mp(p[a],a)];\n  return pii;\n}\n\nint main()\n{\n  int n,q,a,b,w;\n  char c;\n\n  while(1){\n    cin>>n>>q;\n    if(n+q==0)break;\n    for(int i=0;i<n;i++)p[i]=i;\n    M.clear();\n\n    for(int i=0;i<q;i++){\n      cin>>c;\n      if(c=='!'){\n\tcin>>a>>b>>w;\n\ta--;b--;\n\tp[a]=b;\n\tM[mp(b,a)]=w;\n      }\n      else {\n\tcin>>a>>b;\n\ta--;b--;\n\tpair<int,int> pa=find(a),pb=find(b);\n\tif(pa.f!=pb.f)cout<<\"UNKNOWM\"<<endl;\n\telse {\n\t  if(p[a]!=pa.f){\n\t    M.erase(mp(a,p[a]));\n\t    p[a]=pa.f;\n\t    M[mp(pa.f,a)]=pa.s;\n\t  }\n\t  if(p[b]!=pb.f){\n\t    M.erase(mp(b,p[b]));\n\t    p[b]=pb.f;\n\t    M[mp(pb.f,b)]=pb.s;\n\t  }\n\t  cout<<pa.s-pb.s<<endl;\n\t}\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<vector>\n\nusing namespace std;\n\nstruct parent{\n  int id, weightDiff;\n};\n\nvector<parent> UFtree;\n\nint root_Diff(int i) {\n  if(UFtree[i].id == i) return 0;\n  else return UFtree[i].weightDiff + root_Diff(UFtree[i].id);\n}\n\nint root(int i) {\n  if(UFtree[i].id == i) return i;\n  else {\n    UFtree[i].weightDiff = root_Diff(i);\n    return (UFtree[i].id = root(UFtree[i].id));\n  }\n}\n\nbool is_same_set(int i, int j) {\n  return root(i) == root(j);\n}\n\n\n\nvoid unite(int i, int j, int w) {//w_i-w_j = w\n  int x, y;\n  x = root(i); y = root(j);\n  UFtree[y].id = x;\n  UFtree[y].weightDiff = w + UFtree[i].weightDiff - UFtree[j].weightDiff;\n}\n\nint main() {\n  int N, M;\n  while(cin >> N >> M) {\n    if(!N) break;\n    parent zero;\n    UFtree.push_back(zero);\n    for(int i = 1; i <= N; i++){\n      parent p = {i, 0};\n      UFtree.push_back(p);\n    }\n    string word;\n    int a, b, w;\n    for(int i = 0; i < M; i++) {\n      cin >> word >> a >> b;\n      if(word == \"!\") {\n\tcin >> w;\n\tunite(b, a, w);\n      }\n      else {\n\tif(is_same_set(a, b)) cout << root_Diff(a) - root_Diff(b) << endl;\n\telse cout << \"UNKNOWN\" << endl;\n      }\n    }\n    UFtree.clear();\n    UFtree.shrink_to_fit();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nconst int C = 100010;\nconst int infty = 1e9;\npair<int,int> P[C]; // root, diff: w_self - w_root\n\nvoid init(int N) {\n  for (auto i=0; i<N; i++) {\n    P[i] = make_pair(i, 0);\n  }\n}\n\npair<int, int> root(int a) {\n  if (P[a].first == a) return P[a];\n  pair<int, int> t = root(P[a].first);\n  return (P[a] = make_pair(t.first, t.second + P[a].second));\n}\n\nint diff(int a, int b) { // a, bが同じ根を持つならw_b-w_aを、そうでないならinftyを返す。\n  if (root(a).first == root(b).first) {\n    return root(b).second - root(a).second;\n  }\n  return infty;\n}\n\nvoid weight(int a, int b, int w) { // w_b - w_aの値を登録する\n  pair<int, int> ta = root(a);\n  pair<int, int> tb = root(b);\n  P[root(b).first] = make_pair(ta.first, -tb.second + w + ta.second);\n}\n\nint main() {\n  int n, m;\n  while (cin >> n >> m && n) {\n    init(n);\n    for (auto i=0; i<m; i++) {\n      char c;\n      int a, b, w;\n      cin >> c;\n      if (c == '!') {\n        cin >> a >> b >> w;\n        weight(a, b, w);\n      } else {\n        cin >> a >> b;\n        int d = diff(a, b);\n        if (d < infty) {\n          cout << d << endl;\n        } else {\n          cout << \"UNKNOWN\" << endl;\n        }\n      }\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\ntypedef long long int ll;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000001\nusing namespace std;\n\nint* parent; //????????°?????????????±?????????????????????????????????????????????????????????¨\nint* height; //????????°?????????????±?????????????????????????????????????????????????????????¨\n\n\nint* calc_parent;\nint* relative_weight; //?????????????????¨??????????????????????????????????????????\n\nint find_parent(int id){\n\tif(parent[id] == id)return id;\n\telse{\n\t\treturn parent[id] = find_parent(parent[id]);\n\t}\n}\n\nint find_calc_parent(int id){\n\tif(calc_parent[id] == id)return id;\n\telse{\n\t\t//return calc_parent[id] = find_calc_parent(calc_parent[id]);\n\t\treturn calc_parent[id] = find_calc_parent(calc_parent[id]); //?????????????????§??????????????????\n\t}\n}\n\n//calc_parent???????????§????????????\nint compress_calc_parent(int id){\n\tif(calc_parent[id] == id)return id;\n\telse{\n\t\treturn calc_parent[id] = find_calc_parent(calc_parent[id]);\n\t}\n}\n\n//??????????????????????????????????¨??????????\nint calc_relative_weight(int id){\n\n\tint calc_p = find_calc_parent(id);\n\tif(calc_parent[id] == calc_p){ //????????§??????????????????????????´???\n\t\treturn relative_weight[id];\n\t}else{ //????????§?????????????????????????????´???\n\t\tif(calc_parent[id] == id){\n\t\t\treturn 0; //????????????????????????0\n\t\t}else{\n\t\t\treturn relative_weight[id] = relative_weight[id] + calc_relative_weight(calc_parent[id]);\n\t\t}\n\t}\n}\n\n//??°??????????????±????????????????????????????????¨?????±????????????\nvoid unite(int a,int b,int w){\n\n\t//?????????\n\tint a_parent = find_parent(a);\n\tint b_parent = find_parent(b);\n\n\tif(a_parent == b_parent)return; //????????°???????????????calc_parent??¨?????±??????????????????????????????\n\n\t//??±?????????\n\tif(height[a_parent] == height[b_parent]){\n\t\tparent[b_parent] = a_parent;\n\t\theight[a_parent]++;\n\t}else if(height[a_parent] > height[b_parent]){\n\t\tparent[b_parent] = a_parent;\n\t}else{\n\t\tparent[a_parent] = b_parent;\n\t}\n\n\tint relative_a = calc_relative_weight(a);\n\tint relative_b = calc_relative_weight(b);\n\n\t//printf(\"relative_a:%d relative_b:%d\\n\",relative_a,relative_b);\n\n\tif((relative_b-relative_a) -w <= 0){ //a????????????????????????????????????????????????????????¨???\n\t\t//printf(\"???[a]-???[b]:%d\\n\",(relative_b-relative_a) -w);\n\t\t//a?????¨???b?????¨???????????????\n\t\trelative_weight[calc_parent[b]] = w-(relative_b-relative_a);\n\t\tcalc_parent[calc_parent[b]] = calc_parent[a];\n\n\n\t\tif(b == 3 && a == 2){\n\t\t\t//printf(\"calc_parent[3]:%d relative_weight[3]:%d\\n\",calc_parent[3],relative_weight[3]);\n\t\t}\n\t}else{\n\t\t//printf(\"???[a]-???[b]:%d\\n\",(relative_b-relative_a) -w);\n\t\t//b?????¨???a?????¨???????????????\n\t\trelative_weight[calc_parent[a]] = (relative_b-relative_a) -w;\n\t\tcalc_parent[calc_parent[a]] = calc_parent[b];\n\n\t\tif(b == 3 && a == 2){\n\t\t\t//printf(\"calc_parent[3]:%d relative_weight[3]:%d\\n\",calc_parent[3],relative_weight[3]);\n\t\t}\n\t}\n}\n\nbool isSame(int a,int b){\n\treturn find_parent(a) == find_parent(b);\n}\n\nint main(){\n\n\tint N,M,a,b,w;\n\tparent = new int[100001];\n\theight = new int[100001];\n\tcalc_parent = new int[100001];\n\trelative_weight = new int[100001];\n\tchar command[2];\n\n\twhile(true){\n\t\tscanf(\"%d %d\",&N,&M);\n\t\tif(N == 0 && M == 0)break;\n\n\t\tfor(int i = 1; i <= N; i++){\n\t\t\tparent[i] = i;\n\t\t\theight[i] = 0;\n\t\t\tcalc_parent[i] = i;\n\t\t\trelative_weight[i] = 0; //????????????0???????????????\n\t\t}\n\n\t\tfor(int loop = 0; loop < M; loop++){\n\t\t\tscanf(\"%s %d %d\",command,&a,&b);\n\t\t\tif(command[0] == '!'){ //??¬?????????\n\t\t\t\tscanf(\"%d\",&w);\n\t\t\t\tunite(a,b,w);\n\t\t\t}else{ //???????????????\n\t\t\t\tif(!isSame(a,b)){\n\t\t\t\t\tprintf(\"UNKNOWN\\n\");\n\t\t\t\t}else{\n\t\t\t\t\tprintf(\"%d\\n\",calc_relative_weight(b)-calc_relative_weight(a));\n\t\t\t\t\tcompress_calc_parent(b);\n\t\t\t\t\tcompress_calc_parent(a);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#pragma warning(disable : 4996)\nusing namespace std;\npair<int, long long> par[100000];\npair<int, long long> root(int x) {\n\tif (par[x].first == x) return make_pair(x, 0);\n\tpair<int, long long> ret = root(par[x].first);\n\treturn par[x] = make_pair(ret.first, ret.second + par[x].second);\n}\nbool same(int x, int y) {\n\treturn root(x).first == root(y).first;\n}\nvoid unite(int x, int y, int w) { \n\tx = root(x).first; y = root(y).first;\n\tif (x != y) {\n\t\tpar[x] = make_pair(y, w);\n\t}\n}\nlong long query(int a, int b) {\n\treturn root(a).second - root(b).second;\n}\nint N, Q, a, b, w; char c;\nint main() {\n\twhile (true) {\n\t\tscanf(\"%d%d\", &N, &Q);\n\t\tif (N == 0 && Q == 0) break;\n\t\tfor (int i = 0; i < N; i++) par[i] = make_pair(i, 0);\n\t\tfor (int i = 0; i < Q; i++) {\n\t\t\tcin >> c;\n\t\t\tif (c == '!') {\n\t\t\t\tscanf(\"%d%d%d\", &a, &b, &w);\n\t\t\t\tunite(a - 1, b - 1, w);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tscanf(\"%d%d\", &a, &b);\n\t\t\t\tif (!same(a - 1, b - 1)) {\n\t\t\t\t\tprintf(\"UNKNOWN\\n\");\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tprintf(\"%lld\\n\", query(a - 1, b - 1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define f first\n#define s second\n#define mp make_pair\n#define inf 1<<30\n#define MAX 1000010\nusing namespace std;\n\nlong long p[MAX],w[MAX];\n\npair<int,int> find(int a){\n  if(p[a]==a)return mp(a,0);\n  pair<int,int> pii=find(p[a]);\n  pii.s+=w[a];\n  p[a]=pii.f;\n  w[a]=pii.s;\n  return pii;\n}\n\nvoid unit(int a,int b,int d){\n  pair<int,int> pa=find(a),pb=find(b);\n  if(pa.f==pb.f)return;\n  d-=w[b]-w[a];\n  p[pa.f]=pb.f;\n  w[pa.f]=d;\n}\n\nint main()\n{\n  int n,q,a,b,d;\n  char c;\n\n  while(cin>>n>>q && n ){\n\n    for(int i=0;i<n;i++){\n      p[i]=i;\n      w[i]=0;\n    }\n\n    for(int i=0;i<q;i++){\n      cin>>c;\n      if(c=='!'){\n\tcin>>a>>b>>d;\n\ta--;b--;\n        unit(a,b,d);\n      }\n      else {\n\tcin>>a>>b;\n\ta--;b--;\n\tpair<int,int> pa=find(a),pb=find(b);\n\tif(pa.f!=pb.f)cout<<\"UNKNOWM\"<<endl;\n\telse cout<<w[a]-w[b]<<endl;\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nint P[100100],v[100100];\n\nvoid init(int N)\n{\n\tfor(int i=0; i<=N; ++i) \n\t    P[i] = i;\n} \n\nint root(int a)\n{\n    if(P[a]==a)   \n\t   return a;\n    int x=P[a];\n    P[a]=root(P[a]);\n    v[a]+=v[x];\n    return P[a];    \n}\n \nbool is_same_set(int a,int b)\n{\n\treturn(root(a)==root(b));\n}\n\nvoid unite(int a,int b,int w)\n{\n\tint u=root(a);\n\tint m=root(b);\n\tP[m]=u;\n\tv[m]=v[a]-v[b]+w;\n}\n\nint main()\n{\n    int M,N;\n    while(cin >> N >> M)\n    {\n        if(!N && !M)\n          break;\n        init(N);\n        for(int i=1;i<=N;i++)\n           v[i]=0;\n        for(int i=0;i<M;i++)\n        {\n            char c;\n            int a,b,w;\n            cin >> c;\n            if(c=='?')\n            {\n                cin >> a >> b;\n                if(!is_same_set(a,b))\n                   cout << \"UNKNOWN\" << endl;\n                else\n                   cout << v[b]-v[a] << endl;\n            }\n            else if(c=='!')\n            {\n                cin >> a >> b >> w;\n                unite(a,b,w);\n            }\n        }\n     }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\nlong long dist[1 << 18];\nlong long group[1 << 18]; char q;\nlong long n, Q, a, b, c;\nvector<long long>gr[1 << 18];\nint main() {\n\twhile (true) {\n\t\tfor (int i = 0; i < (1 << 18); i++) {\n\t\t\tdist[i] = 0; group[i] = i; gr[i].clear(); gr[i].push_back(i);\n\t\t}\n\t\tcin >> n >> Q; if (n == 0 && Q == 0)break;\n\t\tfor (int i = 0; i < Q; i++) {\n\t\t\tcin >> q;\n\t\t\tif (q == '?') {\n\t\t\t\tcin >> a >> b;\n\t\t\t\tif (group[a] != group[b])cout << \"UNKNOWN\" << endl;\n\t\t\t\telse cout << dist[b] - dist[a] << endl;\n\t\t\t}\n\t\t\tif (q == '!') {\n\t\t\t\tcin >> a >> b >> c;\n\t\t\t\tlong long L = group[a], M = group[b];\n\t\t\t\tif (group[a] != group[b] && gr[L].size() >= gr[M].size()) {\n\t\t\t\t\tlong long K = dist[a] + c - dist[b];\n\t\t\t\t\tfor (int j = 0; j < gr[M].size(); j++) {\n\t\t\t\t\t\tgroup[gr[M][j]] = L;\n\t\t\t\t\t\tgr[L].push_back(gr[M][j]);\n\t\t\t\t\t\tdist[gr[M][j]] += K;\n\t\t\t\t\t}\n\t\t\t\t\tgr[M].clear();\n\t\t\t\t}\n\t\t\t\telse if (group[a] != group[b]) {\n\t\t\t\t\tlong long K = dist[b] - c - dist[a];\n\t\t\t\t\tfor (int j = 0; j < gr[L].size(); j++) {\n\t\t\t\t\t\tgroup[gr[L][j]] = M;\n\t\t\t\t\t\tgr[M].push_back(gr[L][j]);\n\t\t\t\t\t\tdist[gr[L][j]] += K;\n\t\t\t\t\t}\n\t\t\t\t\tgr[L].clear();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <cstdint>\n\nclass UnionFind {\n  std::vector<int> vertex;\n  std::vector<intmax_t> weight;\n\npublic:\n  UnionFind(size_t V): vertex(V+1, -1), weight(V+1, 0) {}\n\n  bool unite(size_t u, size_t v, intmax_t w) {\n    //if (u >= 0) u = find(u);\n    //if (v >= 0) v = find(v);\n    if (u == v) return false;\n    if (vertex[find(u)] > vertex[find(v)]) {\n      std::swap(u, v);\n      w = -w;\n    }\n\n    // u:parent, v:child\n    vertex[find(u)] += vertex[find(v)];\n    vertex[v] = u;\n    weight[v] = w;\n    return true;\n  }\n\n  /*\n  int find(size_t v) {\n    size_t pv=v;\n    while (vertex[v] >= 0) {\n      weight[pv] += weight[vertex[v]];\n      v = vertex[v];\n    }\n\n    return vertex[pv] = v;\n    }\n  */\n  int find(size_t v) {\n    if (vertex[v] < 0)\n      return v;\n\n    size_t parent=vertex[v];\n    size_t root=find(parent);\n    weight[v] += weight[parent];\n    return (vertex[v] = root);\n  }\n\n  bool connected(size_t u, size_t v) {\n    return find(u) == find(v);\n  }\n\n  intmax_t relweight(size_t u) const {\n    if (vertex[u] < 0) {\n      return 0;\n    }\n\n    return weight[u] + relweight(vertex[u]);\n  }\n};\n\nint testcase_ends() {\n  int N, M;\n  scanf(\"%d %d\", &N, &M);\n\n  if (N == 0)\n    return 1;\n\n  UnionFind uf(N);\n\n  for (int i=0; i<M; ++i) {\n    char ch;\n    scanf(\" %c\", &ch);\n\n    if (ch == '?') {\n      int a, b;\n      scanf(\"%d %d\", &a, &b);\n      //--a, --b;\n      if (uf.connected(a, b)) {\n        printf(\"%jd\\n\", uf.relweight(b)-uf.relweight(a));\n      } else {\n        printf(\"UNKNOWN\\n\");\n      }\n    } else if (ch == '!') {\n      int a, b, w;\n      //--a, --b;\n      scanf(\"%d %d %d\", &a, &b, &w);\n      uf.unite(a, b, w);\n    }\n  }\n\n  return 0;\n}\n\nint main() {\n  while (!testcase_ends()) {}\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define PI       3.1415926535897932384626433832795028841971\n#define INF 1000000000\n#define EPS      1e-10\n#define MOD      1000000\nusing namespace std;\ntypedef long long ll;\ntypedef pair<double,double> P;\ntypedef pair<double,P> PQ;\n\nstruct Q{\n    int time,a, b;\n};\n\nstruct edge{\n    int time, to, w;\n};\n\nint n, m;\nint bss[100000];\nint rnk[100000];\nll num[100000];\nbool saw[100000];\nvector<edge> e[100000];\nvector<Q> q;\nint up[20][100000];\nint par[20][100000];\n\nvoid dfs(int v, int bos){\n    saw[v] = true;\n    rep(i,e[v].size()){\n        edge E = e[v][i];\n        if(saw[E.to]) continue;\n        up[0][E.to] = E.time;\n        rnk[E.to] = rnk[v]+1;\n        num[E.to] = num[v]+E.w;\n        bss[E.to] = bos;\n        par[0][E.to] = v;\n        dfs(E.to,bos);\n    }\n}\n\nint main(){\n    while(cin >> n >> m){\n        if(n == 0 && m == 0) break;\n        memset(bss,0,sizeof(bss));\n        memset(rnk,0,sizeof(rnk));\n        memset(num,0,sizeof(num));\n        memset(saw,0,sizeof(saw));\n        rep(i,100000) e[i].clear();\n        q.clear();\n        memset(up,0,sizeof(up));\n        rep(i,m){\n            char hoge;\n            int a, b, w;\n            cin >> hoge;\n            if(hoge == '!'){\n                cin >> a >> b >> w;\n                a--; b--;\n                e[a].push_back((edge){i,b,w});\n                e[b].push_back((edge){i,a,-w});\n            } else{\n                cin >> a >> b;\n                a--; b--;\n                q.push_back((Q){i,a,b});\n            }\n        }\n        rep(i,20){\n            rep(j,n) par[i][j] = j;\n        }\n        rep(i,n){\n            if(saw[i]) continue;\n            dfs(i,i);\n        }\n        for(int i = 1; i < 20; i++){\n            rep(j,n){\n                par[i][j] = par[i-1][par[i-1][j]];\n                up[i][j] = max(up[i-1][j],up[i-1][par[i-1][j]]);\n            }\n        }\n        rep(i,q.size()){\n            Q p = q[i];\n            bool done = false;\n            if(bss[p.a] != bss[p.b]){\n                cout << \"UNKNOWN\" << endl;\n                continue;\n            }\n            ll ans = num[p.b]-num[p.a];\n            if(rnk[p.a] > rnk[p.b]){\n                int dis = rnk[p.a]-rnk[p.b];\n                int z = 0;\n                while(dis > 0){\n                    if(dis&1){\n                        if(up[z][p.a] > p.time){\n                            done = true;\n                            cout << \"UNKNOWN\" << endl;\n                            break;\n                        }\n                        p.a = par[z][p.a];\n                    }\n                    z++;\n                    dis /= 2;\n                }\n            } else if(rnk[p.a] < rnk[p.b]){\n                int dis = rnk[p.b]-rnk[p.a];\n                int z = 0;\n                while(dis > 0){\n                    if(dis&1){\n                        if(up[z][p.b] > p.time){\n                            done = true;\n                            cout << \"UNKNOWN\" << endl;\n                            break;\n                        }\n                        p.b = par[z][p.b];\n                    }\n                    z++;\n                    dis /= 2;\n                }\n            }\n            if(done) continue;\n            if(p.a == p.b){\n                cout << ans << endl;\n                continue;\n            }\n            int common = 0;\n            for(int j = 19; j >= 0; j--){\n                if(par[j][p.a] == par[j][p.b]) continue;\n                common += (1<<j);\n            }\n            common++;\n            int z = 0;\n            while(common > 0){\n                if(common&1){\n                    if(up[z][p.a] > p.time){\n                        done = true;\n                        cout << \"UNKNOWN\" << endl;\n                        break;\n                    }\n                    if(up[z][p.b] > p.time){\n                        done = true;\n                        cout << \"UNKNOWN\" << endl;\n                        break;\n                    }\n                    p.a = par[z][p.a];\n                    p.b = par[z][p.b];\n                }\n                common /= 2;\n                z++;\n            }\n            if(done) continue;\n            cout << ans << endl;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nconstexpr long long INF = 0xffffffffffff;\n\nclass union_find {\nprivate:\n\tvector<int> uf;\n\tvector<long long> pd;\n\npublic:\n\tunion_find(int n):uf(n, -1), pd(n, 0) {}\n\t\n\tinline int find(int x) {\n\t\tif(uf[x] < 0)\n\t\t\treturn x;\n\n\t\tconst int tmp = uf[x];\n\t\tuf[x] = find(uf[x]);\n\t\tpd[x] += pd[tmp];\n\t\treturn uf[x];\n\t}\n\n\tinline void unite(int xx, int yy, int d) {\n\t\tint x = find(xx), y = find(yy);\n\t\tif(x == y)\n\t\t\treturn;\n\t\t\n\t\td += pd[yy] - pd[xx];\n\t\tif(uf[x] < uf[y]) {\n\t\t\tswap(x, y);\n\t\t\td = -d;\n\t\t}\n\n\t\telse if(uf[x] == uf[y])\n\t\t\t--uf[y];\n\t\t\n\t\tuf[x] = y;\n\t\tpd[x] = d;\n\t}\n\t\n\tinline bool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\n\tinline long long get_dist(int x, int y) {\n\t\treturn same(x, y) ? pd[x] - pd[y] : INF;\n\t}\n};\n\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tfor(int n, m; cin >> n >> m && n;) {\n\t\tunion_find uf(n + 1);\n\t\tfor(int i = 0; i < m; ++i) {\n\t\t\tchar q;\n\t\t\tint a, b;\n\t\t\tcin >> q >> a >> b;\n\n\t\t\tif(q == '!') {\n\t\t\t\tint d;\n\t\t\t\tcin >> d;\n\t\t\t\tuf.unite(a, b, d);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tconst long long ans = uf.get_dist(a, b);\n\t\t\t\tif(ans == INF)\n\t\t\t\t\tcout << \"UNKNOWN\" << endl;\n\t\t\t\telse\n\t\t\t\t\tcout << ans << endl;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n\n\n\n\nstruct Dsu {\n  vector<int> pa, w, rk;\n  int n;\n  Dsu(int n) : n(n) {\n    pa.resize(n);\n    iota(pa.begin(), pa.end(), 0);\n    rk.assign(n, 0);\n    w.assign(n, 0);\n  }\n\n  pair<int, int> anc(int u) {\n    if (u == pa[u]) return {u, w[u]};\n    int a, t; tie(a, t) = anc(pa[u]);\n    return {a, t + w[u]};\n  }\n\n  void merge(int a, int b, int wt) { // w = wb - wa\n    int wb, wa;\n    tie(a, wa) = anc(a);\n    tie(b, wb) = anc(b);\n    wt += wb - wa;\n    if (rk[b] < rk[a]) swap(a, b), wt = -wt;\n    pa[a] = b;\n    w[a] = wt;\n    rk[b] += rk[a] == rk[b];\n  }\n  int ask(int a, int b) {\n    int wb, wa;\n    tie(a, wa) = anc(a);\n    tie(b, wb) = anc(b);\n    if (a != b) return INT_MAX;\n    return wa - wb;\n  }\n};\n\n\n\nint main() {\n  ios_base::sync_with_stdio(false); cin.tie(0);\n  int N, M; \n  while (cin >> N >> M) {\n    Dsu djs(N);\n    while (M--) {\n      string s; cin >> s;\n      int a, b, w;\n      if (s == \"!\") {\n        cin >> a >> b >> w;\n        --a, --b;\n        djs.merge(a, b, w);\n      }\n      else {\n        cin >> a >> b;\n        --a, --b;\n        int ans = djs.ask(a, b);\n        if (ans == INT_MAX) cout << \"UNKNOWN\\n\";\n        else cout << ans << '\\n';\n      }\n    }\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\nconst int S = 100010;\n\nstruct UnionFind {\n    vector<int> node;\n    vector<ll> weight;\n    UnionFind() : node(S, -1), weight(S, 0) {}\n    void unite(int u, int v, ll w) {\n      int ov = v, ou = u;\n      u = find(u), v = find(v);\n      int wa = weight[ov], wb = weight[ou];\n      if(u == v) return;\n\n        // (v テ」ツ?ョティツヲツェ) テ」ツつ?(u テ」ツ?ョティツヲツェ) テ」ツ?ォテ」ツ?、テ」ツ?ェテ」ツ?津」ツつ?\n        node[u] += node[v];\n        node[v] = u;\n        weight[v] += w + wb - wa;\n    }\n\n    ll get_weight(int u) {\n        ll ret = 0;\n        while(node[u] >= 0) {\n            ret += weight[u];\n            u = node[u];\n        }\n        return ret;\n    }\n\n    int find(int u) {\n      if(node[u] < 0) return u;\n      int par = node[u], root = find(node[u]);\n      weight[u] += weight[par];\n      return node[u] = root;\n    }\n};\n\nint main() {\n    int N, M;\n    while(cin >> N >> M, N) {\n        UnionFind uf;\n        for(int i=0; i<M; i++) {\n            char c; cin >> c;\n            if(c == '!') {\n                int a, b, d; cin >> a >> b >> d;\n                a--; b--;\n                uf.unite(a, b, d);\n            }\n            else {\n                int a, b; cin >> a >> b;\n                a--; b--;\n                if(uf.find(a) != uf.find(b)) cout << \"UNKNOWN\" << endl;\n                else {\n                    ll wa = uf.get_weight(a);\n                    ll wb = uf.get_weight(b);\n                    // printf(\"wa = %d, wb = %d\\n\", wa, wb);\n                    cout << wb - wa << endl;\n                }\n            }\n        }\n\n\t/*\n\tfor(int i=0; i<N; i++) {\n\t  printf(\"%d: parent = %d, weight = %lld, value = %lld\\n\", i, uf.node[i], uf.weight[i], uf.get_weight(i));\n\t}\n\t*/\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nstatic const int maxm = 100002;\n\nstruct sample {\n\tint num, par, diff, rank;//this - par\n};\n\n//1-origin\nsample s[maxm];\n//int mrank[maxm]; //child - parent\n\nvoid init(int n) {\n\tfor (int i = 1; i <= n; i++) {\n\t\ts[i].num = i;\n\t\ts[i].par = i;\n\t\ts[i].diff = 0;\n\t\ts[i].rank = 0;\n\t}\n}\n\nsample find(int x) {\n\tif (s[x].par == x) {\n\t\treturn s[x];\n\t} else {\n\t\tsample root = find(s[x].par);\n\t\ts[x].par = root.par;\n\t\ts[x].diff += root.diff;\n\t\troot.diff = s[x].diff;\n\t\treturn root;\n\t}\n}\n\nvoid unite(int x, int y, int d) {//d = y - x\n\tint rootx = find(x).num;\n\tint rooty = find(y).num;\n\n\t\n\tif (rootx == rooty)return;\n\n\tif (s[rootx].rank < s[rooty].rank) {\n\t\ts[x].par = y;\n\t\ts[x].diff = (-1) * d;\n\t} else {\n\t\ts[y].par = x;\n\t\ts[y].diff = d;\n\t\tif (s[rootx].rank == s[rooty].rank)s[x].rank++;\n\t}\n}\n\nbool isSame(int x, int y) {\n\treturn find(x).num == find(y).num;\n}\n\n\n\nint main() {\n\twhile (1) {\n\t\tint i, j, k;\n\t\tint n, m;\n\n\t\tcin >> n >> m;\n\t\tif (n == 0 && m == 0)break;\n\n\t\tinit(n);\n\n\t\tchar cmd;\n\t\tint a, b, w;\n\t\tfor (i = 0; i < m; i++) {\n\t\t\tcin >> cmd >> a >> b;\n\t\t\tif (cmd == '!') {\n\t\t\t\tcin >> w;\n\t\t\t\tunite(a, b, w); //w = b - a\n\t\t\t} else if (cmd == '?') {\n\t\t\t\tif (!isSame(a, b)) {\n\t\t\t\t\tcout << \"UNKNOWN\" << endl;\n\t\t\t\t} else {\n\t\t\t\t\tcout << find(b).diff - find(a).diff << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\n\n\n\n\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n#define rep(i,n) for (int i=0; i < int(n); i++)\n\n\nstruct UnionFind\n{\n  // par[i]：データiが属する木の親の番号。i == par[i]のとき、データiは木の根ノードである\n  vector<int> par;\n  // sizes[i]：根ノードiの木に含まれるデータの数。iが根ノードでない場合は無意味な値となる\n  vector<int> sizes;\n  // weight_diffs[i]: ノードpar[i]とノードiの重さの差。親ノードの方が重いとき正値をとる\n  vector<int> weight_diffs;\n\n  UnionFind(int n) : par(n), sizes(n, 1), weight_diffs(n) {\n    rep(i,n) par[i] = i;\n  }\n\n  // データxが属する木の根を得る\n  int find(int x) {\n    if (x == par[x]) return x;\n    int p = find(par[x]);\n    weight_diffs[x] += weight_diffs[par[x]];  // 重み差を伝搬する\n    return par[x] = p;\n  }\n\n  // xの方がyよりwだけ重い\n  void unite(int x, int y, int w) {\n    int nx = find(x);\n    int ny = find(y);\n    if (nx == ny) return;\n\n    // xの重み差は増幅され、yの重み差は相殺される\n    w += weight_diffs[x];\n    w -= weight_diffs[y];\n\n    x = nx;\n    y = ny;\n\n    if (sizes[x] < sizes[y]) {\n      swap(x, y);\n      w *= -1;\n    }\n\n    // xがyの親になるように連結する\n    par[y] = x;\n    weight_diffs[y] = w;\n    sizes[x] += sizes[y];\n  }\n\n  // 2つのデータx, yが属する木が同じならtrueを返す\n  bool same(int x, int y) {\n    return find(x) == find(y);\n  }\n\n  // w_x - w_y を求める\n  int getdiff(int x, int y) {\n    int nx = find(x);\n    int ny = find(y);\n    if (nx != ny) throw \"bug\";\n\n    // w_x - w_y\n    // = -(w_root - w_x) + (w_root - w_y)\n    // = -weight_diffs[x] + weight_diffs[y]\n    return -weight_diffs[x] + weight_diffs[y];\n  }\n};\n\nint n, m;\n\nint solve() {\n  UnionFind uf(n);\n  \n  rep(qi, m) {\n    char com;\n    int a, b;\n    cin >> com >> a >> b;\n    a--;\n    b--;\n    if (com == '!') {\n      int w;\n      cin >> w;\n      uf.unite(a, b, w);\n    }\n    else {\n      if (uf.same(a, b)) {\n        cout << uf.getdiff(a, b) << endl;\n      }\n      else {\n        cout << \"UNKNOWN\" << endl;\n      }\n    }\n  }\n}\n\nint main() {\n  ios::sync_with_stdio(false);\n  while (cin >> n >> m, n||m) solve();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define all(v) (v).begin(),(v).end()\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\n#define pb push_back\n#define fi first\n#define se second\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nstruct UF{\n    vint par,sz;\n    vector<set<int>>st;\n    vint dif;\n    void init(int n){\n        par=sz=dif=vint(n);\n        st=vector<set<int>>(n);\n        rep(i,n){\n            par[i]=i;\n            sz[i]=1;\n            dif[i]=0;\n            st[i].insert(i);\n        }\n    }\n    int find(int x){\n        return x==par[x]?x:par[x]=find(par[x]);\n    }\n    void update(int a,int b,int w){\n        int x=find(a),y=find(b);\n        if(x==y)return;\n        if(sz[x]>sz[y]){\n            swap(x,y);\n            swap(a,b);\n            w*=-1;\n        }\n\n        for(auto v:st[x]){\n            dif[v]+=dif[b]-dif[a]-w;\n            st[y].insert(v);\n        }\n        sz[y]+=sz[x];\n        par[x]=y;\n    }\n    int query(int a,int b){\n        int x=find(a),y=find(b);\n        if(x!=y)return 1001001001;\n        return dif[b]-dif[a];\n    }\n};\n\nsigned main(){\n    int N,Q;\n    while(scanf(\"%lld%lld\",&N,&Q),N||Q){\n        UF uf;uf.init(N);\n        rep(i,Q){\n            char c;\n            scanf(\" %c\",&c);\n            if(c=='!'){\n                int a,b,w;\n                scanf(\"%lld%lld%lld\",&a,&b,&w);\n                a--;b--;\n                uf.update(a,b,w);\n            }\n            else{\n                int a,b;\n                scanf(\"%lld%lld\",&a,&b);\n                a--;b--;\n                int tmp=uf.query(a,b);\n                if(tmp==1001001001)puts(\"UNKNOWN\");\n                else printf(\"%lld\\n\",tmp);\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define llint long long\n#define inf (int)1e18\n\nusing namespace std;\n\nint N, M;\n\nint parent[100005];\nllint difW[100005];\n\nvoid init(){\n\tfor(int i = 1; i <= N; i++){\n\t\tparent[i] = i;\n\t\tdifW[i] = 0;\n\t}\n}\n\nint root(int i){\n\tif(parent[i] == i) return i;\n\tint pre_parent = parent[i];\n\tparent[i] = root(parent[i]);\n\tdifW[i] += difW[pre_parent];\n\treturn parent[i];\n}\n\nbool same(int i, int j){\n\treturn root(i) == root(j);\n}\n\nvoid unite(int i, int j){\n\tint root_i = root(i);\n\tint root_j = root(j);\n\tif(root_i == root_j) return;\n\tparent[root_j] = root_i;\n}\n\nint difRoot(int i){\n\tif(root(i) == i) return 0;\n\treturn difRoot(parent[i]) + difW[i];\n}\n\nint main(void)\n{\n\twhile(1){\n\t\tcin >> N >> M;\n\t\tif(N == 0 && M == 0) break;\n\t\tinit();\n\t\t\n\t\tchar c; int a, b, w;\n\t\tfor(int i = 0; i < M; i++){\n\t\t\tcin >> c;\n\t\t\tif(c == '?'){\n\t\t\t\tcin >> a >> b;\n\t\t\t\tif(!same(a, b)) cout << \"UNKNOWN\" << endl;\n\t\t\t\telse cout << difRoot(b) - difRoot(a) << endl;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tcin >> a >> b >> w;\n\t\t\t\tif(!same(a, b)){\n\t\t\t\t\tdifW[root(b)] = difRoot(a) - difRoot(b) + w;\n\t\t\t\t\tunite(a, b);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// Enjoy your stay.\n\n#include <bits/stdc++.h>\n\n#define EPS 1e-9\n#define INF 1070000000LL\n#define MOD 1000000007LL\n#define fir first\n#define foreach(it,X) for(auto it=(X).begin();it!=(X).end();it++)\n#define ite iterator\n#define mp make_pair\n#define mt make_tuple\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define pb push_back\n#define sec second\n#define sz(x) ((int)(x).size())\n\nusing namespace std;\n\ntypedef istringstream iss;\ntypedef long long ll;\ntypedef pair<ll,ll> pi;\ntypedef stringstream sst;\ntypedef vector<ll> vi;\n\nint par[100010],rnk[100010],dif[100010];\n\nvoid init(int n){\n\trep(i,n){\n\t\tpar[i] = i; rnk[i] = 0; dif[i] = 0;\n\t}\n}\n\npi find(int x){\n\tif(par[x] == x) return mp(x, 0);\n\telse{\n\t\tpi res = find(par[x]);\n\t\tpar[x] = res.fir;\n\t\tdif[x] += res.sec;\n\t\treturn mp(par[x], dif[x]);\n\t}\n}\n\nvoid unite(int x,int y,int d){\n\tpi res0 = find(x), res1 = find(y);\n\tx = res0.fir, y = res1.fir;\n\tif(x == y) return;\n\tif(rnk[x] < rnk[y]){\n\t\tpar[x] = y;\n\t\tdif[x] = d - res0.sec + res1.sec;\n\t}\n\telse{\n\t\tpar[y] = x;\n\t\tdif[y] = -d + res0.sec - res1.sec;\n\t\tif(rnk[x] == rnk[y]) rnk[x]++;\n\t}\n}\n\npi query(int x,int y){\n\tpi res0 = find(x), res1 = find(y);\n\tx = res0.fir, y = res1.fir;\n\tif(x != y) return mp(0, 0);\n\telse return mp(1, res0.sec - res1.sec);\n}\n\nint N,M;\n\nint main(){\n\tcin.tie(0);\n\tios_base::sync_with_stdio(0);\n\t\n\twhile(cin>>N>>M && N){\n\t\tinit(N);\n\t\trep(i,M){\n\t\t\tchar c;\n\t\t\tcin>>c;\n\t\t\tif(c=='!'){\n\t\t\t\tint a,b,w;\n\t\t\t\tcin>>a>>b>>w,a--,b--;\n\t\t\t\tunite(a,b,w);\n\t\t\t}else{\n\t\t\t\tint a,b;\n\t\t\t\tcin>>a>>b,a--,b--;\n\t\t\t\tpi p = query(a,b);\n\t\t\t\tif(p.fir == 0)cout<<\"UNKNOWN\"<<endl;\n\t\t\t\telse cout<<p.sec<<endl;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n//#include <utility>\n#include <set>\n#include <iostream>\n//#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n//#include <functional>\n#include <sstream>\n//#include <deque>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstdio>\n//#include <cctype>\n#include <cstring>\n//#include <ctime>\n#include <iterator>\n#include <bitset>\n//#include <numeric>\n//#include <list>\n//#include <iomanip>\n\n#if __cplusplus >= 201103L\n#include <array>\n#include <tuple>\n#include <initializer_list>\n#include <unordered_set>\n#include <unordered_map>\n#include <forward_list>\n\n#define cauto const auto&\n#else\n\n#endif\n\nusing namespace std;\n\n\nnamespace{\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef vector<int> vint;\ntypedef vector<vector<int> > vvint;\ntypedef vector<long long> vll, vLL;\ntypedef vector<vector<long long> > vvll, vvLL;\n\n#define VV(T) vector<vector< T > >\n\ntemplate <class T>\nvoid initvv(vector<vector<T> > &v, int a, int b, const T &t = T()){\n    v.assign(a, vector<T>(b, t));\n}\n\ntemplate <class F, class T>\nvoid convert(const F &f, T &t){\n    stringstream ss;\n    ss << f;\n    ss >> t;\n}\n\n\n#define reep(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n) reep((i),0,(n))\n#define ALL(v) (v).begin(),(v).end()\n#define PB push_back\n#define F first\n#define S second\n#define mkp make_pair\n#define RALL(v) (v).rbegin(),(v).rend()\n\n\n#define MOD 1000000007LL\n#define EPS 1e-8\nstatic const int INF=1<<24;\nvector<pii> v;\nvint w;\npii foo(int x){\n\tif(v[x].F==x) return v[x];\n\tpii t=foo(v[x].F);\n\treturn v[x]=mkp(t.F,v[x].S-t.S);\n}\n\nvoid mainmain(){\n\tint n,m;\n\twhile(cin>>n>>m,n||m){\n\t\tv=vector<pii>(n);\n\t\tw=vint(n);\n\t\trep(i,n){\n\t\t\tv[i]=mkp(i,0);\n\t\t\tw[i]=0;\n\t\t}\n\t\t// cout<<\"hoge\";\n\t\trep(i,m){\n\t\t\tchar t;\n\t\t\tcin>>t;\n\t\t\tif(t=='!'){\n\t\t\t\tint a,b,r;\n\t\t\t\tcin>>a>>b>>r;\n\t\t\t\t// cout<<a<<\" \"<<b<<\" \"<<r<<endl;\n\t\t\t\tpii c=foo(a-1),d=foo(b-1);\n\t\t\t\t// cout<<c.F<<endl;\n\t\t\t\tif(w[c.F]<w[d.F]){\n\t\t\t\t\tv[c.F]=mkp(v[d.F].F,v[b-1].S-r);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tv[d.F]=mkp(v[c.F].F,v[a-1].S+r);\n\t\t\t\t\tif(w[c.F]==w[d.F]){\n\t\t\t\t\t\tw[c.F]++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tint a,b;\n\t\t\t\tcin>>a>>b;\n\t\t\t\t// cout<<a<<\" \"<<b<<endl;\n\t\t\t\tpii c=foo(a-1),d=foo(b-1);\n\t\t\t\tif(c.F==d.F){\n\t\t\t\t\tcout<<-c.S+d.S<<endl;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tcout<<\"UNKNOWN\\n\";\n\t\t\t\t}\n\t\t\t}\n\t\t\t/*\n\t\t\tcout<<endl<<\"--------\\n\";\n\t\t\trep(i,n){\n\t\t\t\tcout<<v[i].F<<\" \"<<v[i].S<<\" \"<<w[i]<<endl;\n\t\t\t}\n\t\t\tcout<<\"-----------\\n\";\n\t\t\t*/\n\t\t}\n\t}\n}\n\n\n\n}\nmain() try{\n    mainmain();\n}\ncatch(...){\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\ntypedef long long ll;\nint n,q;\nclass Potentialized_UnionFind{\nprivate:\n\tvector<int> p,r;\n\tvector<ll> diff_weight;\npublic:\n\tPotentialized_UnionFind(int N){\n\t\tp = r = vector<int>(N+1,0);\n\t\tdiff_weight = vector<ll>(N+1,0);\n\t\tfor(int i=1;i<=N;i++){\n\t\t\tp[i] = i;\n\t\t\tdiff_weight[i] = 0;\n\t\t\tr[i] = 0;\n\t\t}\n\t}\n\tint root(int a){\n\t\tif(p[a] == a) return a;\n\t\telse{\n\t\t\tint r = root(p[a]);\n\t\t\tdiff_weight[a] += diff_weight[p[a]];\n\t\t\treturn (p[a] = r);\n\t\t}\n\t}\n\tbool is_same_set(int a,int b){\n\t\treturn root(a) == root(b);\n\t}\n\tll weight(int a){\n\t\troot(a);\n\t\treturn diff_weight[a];\n\t}\n\tll diff(int a, int b){\n\t\treturn weight(b) - weight(a);\n\t}\n\tvoid unite(int a, int b, int w){\n\t\tw += weight(a);\n\t\tw -= weight(b);\n\t\ta = root(a);\n\t\tb = root(b);\n\t\tif(a==b) return;\n\t\tif(r[a]<r[b]){\n\t\t\tint t = a;\n\t\t\ta = b;\n\t\t\tb = t;\n\t\t\tw = -w;\n\t\t}\n\t\tif(r[a] == r[b]) r[a]++;\n\t\tp[b] = a;\n\t\tdiff_weight[b] = w;\n\t}\n};\n\nint main(){\n\twhile(cin >> n >> q && n>0){\n\t\tPotentialized_UnionFind uf(n);\n\t\tfor(int i=0;i<q;i++){\n\t\t\tchar c;\n\t\t\tll w,a,b;\n\t\t\tcin >> c;\n\t\t\tif(c=='!'){\n\t\t\t\tcin >> a >> b >> w;\n\t\t\t\tuf.unite(a,b,w);\n\t\t\t}else{\n\t\t\t\tcin >> a >> b;\n\t\t\t\tif(uf.is_same_set(a,b)) cout << uf.diff(a,b) << endl;\n\t\t\t\telse cout << \"UNKNOWN\" << endl;\n\t\t\t}\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "// g++ -std=c++11 a.cpp\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<random>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#include<typeinfo>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\n//#define int ll\ntypedef ll Def;\n//typedef ll Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n#define mt make_tuple\ntypedef tuple<int,int,int> tp;\ntypedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\n//template<class C>constexpr int size(const C &c){return (int)c.size();}\n//template<class T,size_t N> constexpr int size(const T (&xs)[N])noexcept{return (int)N;}\nconst double PI=acos(-1);\nconst double EPS=1e-9;\nDef inf = sizeof(Def) == sizeof(long long) ? 2e18 : 1e9+10;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\nclass UnionFind{\n\tpublic:\n\tvi parent;\n\tvi dist;\n\tUnionFind(int x=1){\n\t\tparent=vi(x,-1);\n\t\tdist=vi(x);\n\t}\n\tint find(int x){\n\t\tif(parent[x]<0)return x;\n\t\tint r=find(parent[x]);\n\t\tdist[x]+=dist[parent[x]];\n\t\treturn parent[x]=r;\n\t}\n\tDef depth(int x){\n\t\tfind(x);\n\t\treturn dist[x];\n\t}\n\tbool same(int x,int y){\n\t\treturn find(x)==find(y);\n\t}\n\tint size(int x){\n\t\treturn -parent[find(x)];\n\t}\n\tvoid unite(int x,int y,Def k=0){\n\t\tk+=depth(y);\n\t\tk-=depth(x);\n\t\tk*=-1;\n\t\tx=find(x);\n\t\ty=find(y);\n\t\tif(x==y)return;\n\t\tif(size(x)<size(y)){\n\t\t\tswap(x,y);\n\t\t\tk*=-1;\n\t\t}\n\t\tparent[x]+=parent[y];\n\t\tparent[y]=x;\n\t\tdist[y]=k;\n\t}\n};\nint main(){\n\tint n,q;\n\twhile(cin>>n>>q,n){\n\t\tUnionFind T(n);\n\t\tfor(int i=0;i<q;i++){\n\t\t\tchar type;\n\t\t\tint x,y;\n\t\t\tcin>>type>>x>>y;\n\t\t\tx--;y--;\n\t\t\tif(type=='!'){\n\t\t\t\tint a;\n\t\t\t\tcin>>a;\n\t\t\t\tT.unite(x,y,a);\n\t\t\t}else{\n\t\t\t\tif(!T.same(x,y))printf(\"UNKNOWN\\n\");\n\t\t\t\telse printf(\"%lld\\n\",T.depth(x)-T.depth(y));\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n\nstruct UnionFind {\n  vector<int> rank, par, W;\n  \n  UnionFind(int n)\n  {\n    rank.resize(n);\n    par.resize(n);\n    rep(i, n) rank[i] = 1, par[i] = i;\n    W.resize(n);\n  }\n\n  pair<int, int> find(int x) {\n    if(x == par[x]) { return make_pair(x, 0); }\n    pair<int, int> ret = find(par[x]);\n    par[x] = ret.first;\n    W[x] += ret.second;\n    return make_pair(par[x], W[x]);\n  }\n  \n  void unite(int u, int v, int c) {\n    pair<int, int> px = find(u), py = find(v);\n    int x = px.first, y = py.first;\n    if(x == y) return;\n    if(rank[x] > rank[y]) {\n      par[y] = x;\n      W[y] = c+W[u]-W[v];\n    }\n    else {\n      par[x] = y;\n      W[x] = -(c+W[u]-W[v]);\n      if(rank[x] == rank[y]) { rank[y] ++; }\n    }\n  }\n\n  bool same(int u, int v) { return find(u).first == find(v).first; }\n  \n  // テゥツ?催」ツ?ソテ」ツ?ョテ・ツキツョテ」ツつ津ァツュツ氾」ツ?暗」ツつ?\n  int diff(int u, int v) {\n    return W[v]-W[u];\n  }\n  \n};\n\nint main() {\n\n  for(int N, M; cin >> N >> M && (N|M);) {\n    UnionFind uf(N*2);\n    rep(i, M) {\n      char op; cin >> op;\n      int u, v; cin >> u >> v;\n      if(op == '!') {\n        int c; cin >> c;\n        uf.unite(u, v, c);\n      }\n      else {\n        if(uf.same(u, v)) {\n          cout << uf.diff(u, v) << endl;\n        }\n        else {\n          puts(\"UNKNOWN\");\n        }\n      }\n    }\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct WeightedUnionFind\n{\n  vector< int > data, weight;\n\n  WeightedUnionFind(int sz) : data(sz, -1), weight(sz, 0) {}\n\n  void unite(int x, int y, int w)\n  {\n    auto a = find(x), b = find(y);\n    x = a.first, y = b.first;\n    if(x == y) return;\n    data[x] += data[y];\n    data[y] = x;\n    weight[y] = a.second - b.second - w;\n  }\n\n  pair< int, int > find(int k)\n  {\n    if(data[k] < 0) return (make_pair(k, 0));\n    auto par = find(data[k]);\n    data[k] = par.first;\n    weight[k] = (par.second += weight[k]);\n    return (par);\n  }\n\n  void diff(int a, int b)\n  {\n    if(find(a).first != find(b).first) cout << \"UNKNOWN\" << endl;\n    else cout << weight[a] - weight[b] << endl;\n  }\n};\n\nint main()\n{\n  int N, M;\n  while(cin >> N >> M, N) {\n    WeightedUnionFind tree(N);\n    while(M--) {\n      char A;\n      int B, C, D;\n      cin >> A >> B >> C;\n      --B, --C;\n      if(A == '!') {\n        cin >> D;\n        tree.unite(B, C, D);\n      } else {\n        tree.diff(B, C);\n      }\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int maxn = 1e5+7;\nint pre[maxn];\nll num[maxn];\nint Find(int x){\n\tif(pre[x] == x) return x;\n\tint ppx = Find(pre[x]);\n\tnum[x] += num[pre[x]];\n\tpre[x] = ppx;\n\treturn pre[x];\n}\n\nvoid join(int x,int y, ll w)\n{\n\tint fx = Find(x);\n\tint fy = Find(y);\n\tif(fx != fy)\n\t{\n\t\tnum[fy] = w+num[x]-num[y];\n\t\tpre[fy] = fx;\n\t}\n}\n\nint main()\n{\n    int n,m;\n    while(scanf(\"%d%d\",&n,&m)&&m+n)\n    {\n    \tfor(int i = 1; i <= n; i++)\n    \t{\n    \t\tpre[i] = i;\n    \t\tnum[i] = 0;\n    \t}\n    \tchar s[10];\n    \tint a,b;\n    \tll w;\n    \twhile(m--)\n    \t{\n    \t\tscanf(\"%s%d%d\",s,&a,&b);\n    \t\tif(s[0] == '?'){\n    \t\t\tint fx = Find(a);\n    \t\t\tint fy = Find(b);\n    \t\t\tif(fx!=fy) puts(\"UNKNOWN\");\n    \t\t\telse\n    \t\t\tprintf(\"%lld\\n\",num[b]-num[a]);\n    \t\t}\n    \t\telse\n    \t\t{\n    \t\t\tscanf(\"%lld\",&w);\n    \t\t\tjoin(a,b,w);\n    \t\t}\n    \t}\n    }\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nclass WeightedDisjointSets\n{\nprivate:\n    using T = int;\n    vector<int> parent, rank;\n    vector<T> weight;\n\npublic:\n    WeightedDisjointSets(const int v) : parent(v), rank(v, 0), weight(v, 0) { iota(parent.begin(), parent.end(), 0); }\n    bool same(const int a, const int b) { return find(a) == find(b); }\n    int find(const int a) { return parent[a] == a ? a : (weight[a] += weight[parent[a]], parent[a] = find(parent[a])); }\n    T getWeight(const int a) { return find(a), weight[a]; }\n    void unite(int a, int b, T d)\n    {\n        d += getWeight(a) - getWeight(b);\n        a = find(a), b = find(b);\n        if (a == b) { return; }\n        if (rank[a] > rank[b]) { swap(a, b), d = -d; }\n        rank[a] += rank[b], parent[b] = a, weight[b] = d;\n    }\n    T diff(const int a, const int b) { return getWeight(b) - getWeight(a); }\n};\n\nint main()\n{\n    while (true) {\n        int N, M;\n        cin >> N >> M;\n        if (N == 0 and M == 0) { break; }\n        WeightedDisjointSets uf(N);\n        for (int i = 0; i < M; i++) {\n            char c;\n            int a, b;\n            cin >> c >> a >> b;\n            a--, b--;\n            if (c == '!') {\n                int c;\n                cin >> c;\n                uf.unite(a, b, c);\n            } else {\n                cout << (uf.same(a, b) ? to_string(uf.diff(a, b)) : \"UNKNOWN\") << endl;\n            }\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\ntypedef long long ll;\n\nconst int UF_SZ_MX = 1e5+10;\nint uf[UF_SZ_MX];\nint rnk[UF_SZ_MX];\nint diff[UF_SZ_MX];\n\nvoid uf_init() {\n\tfor(int i = 0; i < UF_SZ_MX; i++) {\n\t\tuf[i] = i;\n\t\trnk[i] = 0;\n\t\tdiff[i] = 0;\n\t}\n}\n\nint uf_find(int n) {\n\tif(n == uf[n])\n\t\treturn n;\n\treturn uf_find(uf[n]);\n}\n\nbool uf_same(int a, int b) {\n\tint pa, pb;\n\tpa = uf_find(a);\n\tpb = uf_find(b);\n\tif(pa == pb)\n\t\treturn true;\n\treturn false;\n}\n\nll uf_cost(int n) {\n\tif(uf[n] == n)\n\t\treturn 0ll;\n\treturn (ll)diff[n] + uf_cost(uf[n]);\n}\n\nvoid uf_marge(int a, int b, int d) {\n\tint pa, pb;\n\tint ca, cb;\n\tpa = uf_find(a);\n\tpb = uf_find(b);\n\tca = uf_cost(a);\n\tcb = uf_cost(b);\n\tif(pa == pb)\n\t\treturn;\n\tif(rnk[pa] > rnk[pb]) {\n\t\tuf[pb] = pa;\n\t\tdiff[pb] = ca - cb + d;\n\t}\n\telse {\n\t\tuf[pa] = pb;\n\t\tdiff[pa] = cb - ca -d;\n\t\tif(rnk[pa] == rnk[pb])\n\t\t\trnk[pb]++;\n\t}\n}\n\nint main() {\n\tint N, M;\n\twhile(cin >> N >> M, N || M) {\n\t\tuf_init();\n\t\tfor(int i = 0; i < M; i++) {\n\t\t\tstring s;\n\t\t\tcin >> s;\n\n\t\t\tif(s == \"!\") {\n\t\t\t\tint a, b, w;\n\t\t\t\tcin >> a >> b >> w;\n\t\t\t\tif(!uf_same(a,b)) {\n\t\t\t\t\tuf_marge(a,b,w);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tint a, b;\n\t\t\t\tcin >> a >> b;\n\t\t\t\tif(uf_same(a,b)) {\n\t\t\t\t\tcout << uf_cost(b) - uf_cost(a) << endl;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tcout << \"UNKNOWN\" << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define PI       3.1415926535897932384626433832795028841971\n#define INF 1000000000\n#define EPS      1e-10\n#define MOD      1000000\nusing namespace std;\ntypedef long long ll;\ntypedef pair<double,double> P;\ntypedef pair<double,P> PQ;\n\nstruct Q{\n    int time,a, b;\n};\n\nstruct edge{\n    int time, to, w;\n};\n\nint n, m;\nint bss[100000];\nint rnk[100000];\nll num[100000];\nbool saw[100000];\nvector<edge> e[100000];\nvector<Q> q;\nint up[20][100000];\nint par[20][100000];\n\nvoid dfs(int v, int bos){\n    saw[v] = true;\n    rep(i,e[v].size()){\n        edge E = e[v][i];\n        if(saw[E.to]) continue;\n        up[0][E.to] = E.time;\n        rnk[E.to] = rnk[v]+1;\n        num[E.to] = num[v]+E.w;\n        bss[E.to] = bos;\n        par[0][E.to] = v;\n        dfs(E.to,bos);\n    }\n}\n\nint main(){\n    while(cin >> n >> m){\n        if(n == 0 && m == 0) break;\n        memset(bss,0,sizeof(bss));\n        memset(rnk,0,sizeof(rnk));\n        memset(num,0,sizeof(num));\n        memset(saw,0,sizeof(saw));\n        rep(i,100000) e[i].clear();\n        q.clear();\n        memset(up,0,sizeof(up));\n        rep(i,m){\n            char hoge;\n            int a, b, w;\n            cin >> hoge;\n            if(hoge == '!'){\n                cin >> a >> b >> w;\n                a--; b--;\n                e[a].push_back((edge){i,b,w});\n                e[b].push_back((edge){i,a,-w});\n            } else{\n                cin >> a >> b;\n                a--; b--;\n                q.push_back((Q){i,a,b});\n            }\n        }\n        rep(i,20){\n            rep(j,n) par[i][j] = j;\n        }\n        rep(i,n){\n            if(saw[i]) continue;\n            dfs(i,i);\n        }\n        for(int i = 1; i < 20; i++){\n            rep(j,n){\n                par[i][j] = par[i-1][par[i-1][j]];\n                up[i][j] = max(up[i-1][j],up[i-1][par[i-1][j]]);\n            }\n        }\n        rep(i,q.size()){\n            Q p = q[i];\n            bool done = false;\n            if(bss[p.a] != bss[p.b]){\n                cout << \"UNKNOWN\" << endl;\n                continue;\n            }\n            ll ans = num[p.b]-num[p.a];\n            if(rnk[p.a] > rnk[p.b]){\n                int dis = rnk[p.a]-rnk[p.b];\n                int z = 0;\n                while(dis > 0){\n                    if(dis&1){\n                        if(up[z][p.a] > p.time){\n                            done = true;\n                            cout << \"UNKNOWN\" << endl;\n                            break;\n                        }\n                        p.a = par[z][p.a];\n                    }\n                    z++;\n                    dis /= 2;\n                }\n            } else if(rnk[p.a] < rnk[p.b]){\n                int dis = rnk[p.b]-rnk[p.a];\n                int z = 0;\n                while(dis > 0){\n                    if(dis&1){\n                        if(up[z][p.b] > p.time){\n                            done = true;\n                            cout << \"UNKNOWN\" << endl;\n                            break;\n                        }\n                        p.b = par[z][p.b];\n                    }\n                    z++;\n                    dis /= 2;\n                }\n            }\n            if(done) continue;\n            if(p.a == p.b){\n                cout << ans << endl;\n                continue;\n            }\n            int common = 0;\n            for(int j = 19; j >= 0; j--){\n                if(par[j][p.a] == par[j][p.b]) continue;\n                common += (1<<j);\n            }\n            common++;\n            int z = 0;\n            while(common > 0){\n                if(common&1){\n                    if(up[z][p.a] > p.time){\n                        done = true;\n                        cout << \"UNKNOWN\" << endl;\n                        break;\n                    }\n                    if(up[z][p.b] > p.time){\n                        done = true;\n                        cout << \"UNKNOWN\" << endl;\n                        break;\n                    }\n                    p.a = par[z][p.a];\n                    p.b = par[z][p.b];\n                }\n                common /= 2;\n                z++;\n            }\n            if(done) continue;\n            cout << ans << endl;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define max(a,b) ((a)>(b)?(a):(b))\n#define min(a,b) ((a)<(b)?(a):(b))\n#define abs(a) max((a),-(a))\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define repe(i,n) rep(i,(n)+1)\n#define per(i,n) for(int i=(int)(n)-1;i>=0;i--)\n#define pere(i,n) rep(i,(n)+1)\n#define all(x) (x).begin(),(x).end()\n#define SP <<\" \"<<\n#define RET return 0\n#define MOD 1000000007\n#define INF 1000000000000000000\n\ntypedef long long LL;\ntypedef long double LD;\n\nvector<pair<int,pair<int,LL>>> uf;\n\nint root(int x){\n  if(uf[x].first==x) return x;\n  else{\n    int rt=root(uf[x].first);\n    uf[x].second.second+=uf[uf[x].first].second.second;\n    return uf[x].first=rt;\n  }\n}\n\nLL dist(int x){\n  root(x);\n  return uf[x].second.second;\n}\n\nvoid uni(int x,int y,LL d){\n  LL tmp=dist(x)-dist(y);\n  x=root(x);\n  y=root(y);\n  if(x!=y){\n    if(uf[x].second.first>uf[y].second.first){\n      uf[y].first=x;\n      uf[y].second.second+=d+tmp;\n    }else if(uf[x].second.first<uf[y].second.first){\n      uf[x].first=y;\n      uf[x].second.second-=d+tmp;\n    }else{\n      uf[y].first=x;\n      uf[y].second.second+=d+tmp;\n      uf[x].second.first++;\n    }\n  }\n}\n\n\nint main(){\n  while(1){\n    int n,m;\n    cin >> n >> m;\n    if(n==0) return 0;\n    uf=vector<pair<int,pair<int,LL>>>(n);\n    for(int i=0;i<n;i++){\n      uf[i]={i,{0,0}};\n    }\n    char c;\n    LL a,b,w;\n    for(int i=0;i<m;i++){\n      cin >> c;\n      if(c=='!'){\n        cin >> a >> b >> w;\n        uni(a-1,b-1,w);\n      }else{\n        cin >> a >> b;\n        // for(int i=0;i<n;i++) cout << dist(i) << \" \";\n        // cout << endl;\n        if(root(a-1)==root(b-1)){\n          cout << dist(b-1)-dist(a-1) << endl;\n        }else{\n          cout << \"UNKNOWN\" << endl;\n        }\n      }\n    }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cstring>\n \nusing namespace std;\ntypedef long long ll;\nstruct Info{int par, weight;};\nconst int MAX = 100005;\nconst int INF = (1<<28);\n\nclass UnionFind{\npublic:\n  \n  Info info[MAX];\n\n  void init(int n){\n    for(int i = 0; i < n; i++) info[i] = (Info){i,0};\n  }\n \n  Info find(int x){\n    if(info[x].par == x) return info[x];\n    \n    Info tmp = find(info[x].par);\n    info[x].weight += tmp.weight;\n    info[x].par = tmp.par;\n    return info[x];\n  }\n\n \n  \n  void unite(int x, int y, int w){\n    Info X = find(x);\n    Info Y = find(y);\n    //W[x]+w = W[y]\n    \n    info[Y.par].par = X.par;\n    info[Y.par].weight += w+info[x].weight-info[y].weight;\n  }\n   \n  bool same(int x, int y){\n    return find(x).par == find(y).par;\n  }\n\n  int getValue(int x){return info[x].weight;}\n};\n \nint N,M;\nbool used[MAX];\nUnionFind uf;\n \nvoid init(){\n  memset(used,false,sizeof(used));\n  uf.init(N+1);\n}\n \n \nvoid update(){\n   \n  int a,b,c;\n  cin >> a >> b >> c;\n  uf.unite(a,b,c);\n}\n \nvoid print(){\n  int a,b;\n  cin >> a >> b;\n  if(uf.same(a,b)) cout << uf.getValue(b)-uf.getValue(a) << endl;\n  else cout << \"UNKNOWN\" << endl;\n}\n \nint main(){\n   \n  while(cin >> N >> M && N+M){\n    init();\n    for(int i = 0; i < M; i++){\n      char c;\n      cin >> c;\n      if(c == '!') update();\n      else print();\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntypedef long double ld;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-10;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\nstruct union_find\n{\n\tvector<pii> par;\n\tunion_find(int n)\n\t{\n\t\tREP(i, n) par.emplace_back(i, 0);\n\t}\n\tpii find(int x)\n\t{\n\t\tif (par[x].first == x) return par[x];\n\t\telse\n\t\t{\n\t\t\tpii t = par[par[x].first];\n\t\t\tpar[x].first = t.first;\n\t\t\tpar[x].second += t.second;\n\t\t\treturn t;\n\t\t}\n\t}\n\tvoid unite(int x, int y, int w)\n\t{\n\t\tint dif = w + par[x].second - par[y].second;\n\t\tx = find(x).first; y = find(y).first;\n\t\tif (x == y) return;\n\t\tpar[y].first = x;\n\t\tpar[y].second += dif;\n\t}\n\tbool same(int x, int y)\n\t{\n\t\treturn find(x).first == find(y).first;\n\t}\n};\n\nint main()\n{\n\tint n, m;\n\twhile (cin >> n >> m, n)\n\t{\n\t\tunion_find uf(n);\n\t\tREP(i, m)\n\t\t{\n\t\t\tchar c;\n\t\t\tcin >> c;\n\t\t\tif (c == '!')\n\t\t\t{\n\t\t\t\tint a, b, w;\n\t\t\t\tcin >> a >> b >> w;\n\t\t\t\ta--; b--;\n\t\t\t\tuf.unite(a, b, w);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tint a, b;\n\t\t\t\tcin >> a >> b;\n\t\t\t\ta--; b--;\n\t\t\t\tif (!uf.same(a, b))\n\t\t\t\t\tputs(\"UNKNOWN\");\n\t\t\t\telse cout << uf.par[b].second - uf.par[a].second << endl;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#if 0\n\n\n\n#endif // 0\n\n#include<cstdlib>\n#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<set>\n#include<cstring>\n#include<cmath>\nusing namespace std;\nconst int MAXN = (int) 1e5 + 10;\nconst int INF = (int) 0x3f3f3f3f;\ntypedef long long LL;\nint M,N;\nint p[MAXN],d[MAXN];\n\npair<int,int> Find(int x){\n    if(x==p[x]) return make_pair(p[x],d[x]);\n    pair<int,int> tmp=Find(p[x]);\n    p[x]=tmp.first;\n    d[x]+=tmp.second;\n    return make_pair(p[x],d[x]);\n}\n\nint same(int u,int v){\n    return Find(u)==Find(v);\n}\n\nvoid unite(int u,int v,int w){\n    pair<int,int> x=Find(u);\n    pair<int,int> y=Find(v);\n    if(x.first!=y.first){\n        d[x.first]=w+y.second-x.second;\n        p[x.first]=y.first;\n    }\n}\n\nvoid work(){\n    while(~scanf(\"%d%d\",&N,&M)){\n        if(N==0&&M==0) break;\n        for(int i=1;i<=N;i++) p[i]=i,d[i]=0;\n        while(M--){\n            char s[10];\n            int x,y,z;\n            scanf(\"%s%d%d\",s,&x,&y);\n            if(s[0]=='!'){\n                scanf(\"%d\",&z);\n                unite(x,y,z);\n            }\n            else{\n                pair<int,int> t1=Find(x);\n                pair<int,int> t2=Find(y);\n                if(t1.first!=t2.first) printf(\"UNKNOWN\\n\");\n                else printf(\"%d\\n\",t1.second-t2.second);\n            }\n        }\n    }\n}\n\nint main(){\n    work();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef double D;\ntypedef pair<ll,ll> P;\n#define M 1000000007\n#define F first\n#define S second\n#define PB push_back\n#define INF 100000000000000000\nll n,m,par[100005],dw[100005];\nll find(ll x){\n\tif(par[x]==x)return x;\n\tll r=find(par[x]);\n\tdw[x]+=dw[par[x]];\n\treturn par[x]=r;\n}\nbool same(ll x,ll y){\n\treturn find(x)==find(y);\n}\nvoid unit(ll x,ll y,ll w){\n\tfind(x),find(y);\n\tw+=dw[x],w-=dw[y];\n\tx=find(x),y=find(y);\n\tif(x==y)return;\n\tpar[y]=x;\n\tdw[y]+=w;\n}\nll diff(ll x,ll y){\n\tfind(x),find(y);\n\treturn dw[y]-dw[x];\n}\nint main(void){\n\twhile(1){\t\n\t\tscanf(\"%lld%lld\",&n,&m);\n\t\tif(n==0&&m==0)return 0;\n\t\tfor(int i=0;i<n;i++)par[i]=i,dw[i]=0;\n\t\twhile(m--){\n\t\t\tchar c;\n\t\t\tscanf(\" %c\",&c);\n\t\t\tif(c=='!'){\n\t\t\t\tll a,b,w;\n\t\t\t\tscanf(\"%lld%lld%lld\",&a,&b,&w);\n\t\t\t\tunit(a,b,w);\n\t\t\t}else{\n\t\t\t\tll a,b;\n\t\t\t\tscanf(\"%lld%lld\",&a,&b);\n\t\t\t\tif(!same(a,b))printf(\"UNKNOWN\\n\");\n\t\t\t\telse printf(\"%lld\\n\",diff(a,b));\n\t\t\t}\n\t\t}\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cassert>\n#include <utility>\nusing namespace std;\ntypedef pair<int,int> pii;\n#define repeat(i,n) for (int i = 0; i < n; ++i)\n#define repeat_from(i,m,n) for (int i = m; i < n; ++i)\n\n#define MAX_N 100000\n#define MAX_M 100000\nint N, M;\n\npii tree[MAX_N];\nvoid init_tree(int n) { repeat (i,n) { tree[i] = pii(i,0); } }\npii find_root(int a) {\n    if (tree[a].first != a) {\n        pii pb = find_root(tree[a].first);\n        tree[a].first = pb.first;\n        tree[a].second += pb.second;\n    }\n    return tree[a];\n}\nvoid union_tree(int a, int b, int w) {\n    pii pa = find_root(a), pb = find_root(b);\n    if (pa.first != pb.first) {\n        tree[pa.first].first = pb.first;\n        tree[pa.first].second -= pb.second + w;\n    } else {\n        // assert(false);\n    }\n}\n\nint main(void) {\n    while (true) {\n        cin >> N >> M; cin.ignore();\n        if (not N or not M) break;\n        init_tree(N);\n        repeat (i,M) {\n            char c; cin >> c;\n            if (c == '!') {\n                int a, b, w; cin >> a >> b >> w; cin.ignore(); -- a; -- b;\n                union_tree(a,b,w);\n            } else if (c == '?') {\n                int a, b; cin >> a >> b; cin.ignore(); -- a; -- b;\n                pii pa = find_root(a), pb = find_root(b);\n                if (pa.first == pb.first) {\n                    cout << pb.second - pa.second << endl;\n                } else {\n                    cout << \"UNKNOWN\" << endl;\n                }\n            } else {\n                assert(false);\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdio>\nusing namespace std;\n\nconst int M=100005;\nint n,m,x,y,tmp;\nlong long p[M];\nint fa[M];\nchar c[5];\n\nvoid init(){\n    for(int i=0;i<M;i++) fa[i]=i;\n    memset(p,0,sizeof(p));\n}\n\nint getfa(int x){\n    if(fa[x]==x) return fa[x];\n    else {\n        int root=getfa(fa[x]);\n        p[x]+=p[fa[x]];\n        return fa[x]=root;\n    }\n}\n\nint main(){\n    while(scanf(\"%d %d\",&n,&m),n){\n        init();\n        while(m--){\n            scanf(\"%s %d %d\",c,&x,&y);\n            if(c[0]=='!'){\n                scanf(\"%d\",&tmp);\n                int xx=getfa(x);\n                int yy=getfa(y);\n                if(xx!=yy) {\n                    int tmp1=p[x]-p[xx];\n                    int tmp2=p[y]-p[yy];\n                    fa[xx]=yy;\n                    p[xx]+=tmp2-tmp-tmp1;\n                }\n            }\n            else {\n                int xx=getfa(x);\n                int yy=getfa(y);\n                if(xx==yy) printf(\"%lld\\n\",p[y]-p[x]);\n                else puts(\"UNKNOWN\");\n            }\n            //for(int i=1;i<=4;i++) cout<<p[i]<<' ';cout<<endl;\n        }\n    }\n    return 0;\n}\n\n/*\n4 7\n! 1 2 100\n! 2 3 100\n! 4 3 150\n? 4 1\n*/"
  },
  {
    "language": "C++",
    "code": "// g++ -std=c++11 a.cpp\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<random>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#include<typeinfo>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\n//#define int ll\ntypedef ll Def;\n//typedef ll Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n#define mt make_tuple\ntypedef tuple<int,int,int> tp;\ntypedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\n//template<class C>constexpr int size(const C &c){return (int)c.size();}\n//template<class T,size_t N> constexpr int size(const T (&xs)[N])noexcept{return (int)N;}\nconst double PI=acos(-1);\nconst double EPS=1e-9;\nDef inf = sizeof(Def) == sizeof(long long) ? 2e18 : 1e9+10;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\nclass UnionFind{\n\tpublic:\n\tvi parent;\n\tvi dist;\n\tUnionFind(int x=1){\n\t\tparent=vi(x,-1);\n\t\tdist=vi(x);\n\t}\n\tint find(int x){\n\t\tif(parent[x]<0)return x;\n\t\tint r=find(parent[x]);\n\t\tdist[x]+=dist[parent[x]];\n\t\treturn parent[x]=r;\n\t}\n\tDef depth(int x){\n\t\tfind(x);\n\t\treturn dist[x];\n\t}\n\tbool same(int x,int y){\n\t\treturn find(x)==find(y);\n\t}\n\tint size(int x){\n\t\treturn -parent[find(x)];\n\t}\n\tvoid unite(int x,int y,Def k=0){\n\t\tk+=depth(y);\n\t\tk-=depth(x);\n\t\tk*=-1;\n\t\tx=find(x);\n\t\ty=find(y);\n\t\tif(x==y)return;\n\t\tif(size(x)<size(y)){\n\t\t\tswap(x,y);\n\t\t\tk*=-1;\n\t\t}\n\t\tparent[x]+=parent[y];\n\t\tparent[y]=x;\n\t\tdist[y]=k;\n\t}\n};\nint main(){\n\tint n,q;\n\twhile(cin>>n>>q,n){\n\t\tUnionFind T(n);\n\t\tfor(int i=0;i<q;i++){\n\t\t\tchar type;\n\t\t\tint x,y;\n\t\t\tcin>>type>>x>>y;\n\t\t\tx--;y--;\n\t\t\tif(type=='!'){\n\t\t\t\tint a;\n\t\t\t\tcin>>a;\n\t\t\t\tT.unite(x,y,a);\n\t\t\t}else{\n\t\t\t\tif(!T.same(x,y))printf(\"UNKNOWN\\n\");\n\t\t\t\telse printf(\"%lld\\n\",T.depth(x)-T.depth(y));\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nconst int INF = 1e8;\nusing namespace std;\n\n\nstatic const int MAX_V = 100005;\nstatic const int MAX_M = 100005;\n\nclass Topological{\n\tpublic:\n\t\tvector<int> g[MAX_V]; //??°??????\n\t\tvector<int> tp; //????????????????????????????????????\n\n\t\tvoid bfs(int s, int indeg[MAX_V], bool used[MAX_V]){\n\t\t\tqueue<int> q;\n\n\t\t\tq.push(s);\n\t\t\tused[s] = true;\n\n\t\t\twhile(not q.empty()){\n\t\t\t\tint u = q.front(); q.pop();\n\t\t\t\ttp.emplace_back(u);\n\t\t\t\trep(i,g[u].size()){\n\t\t\t\t\tint v = g[u][i];\n\t\t\t\t\tindeg[v]--;\n\t\t\t\t\tif(indeg[v] == 0 && not used[v]){\n\t\t\t\t\t\tused[v] = true;\n\t\t\t\t\t\tq.push(v);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t//??°??????????????????????????´??????0?????????\n\t\tbool topologicalSort(int v){\n\t\t\tint indeg[MAX_V]; //??\\?¬???°\n\t\t\tbool used[MAX_V];\n\t\t\tmemset(indeg, 0, sizeof(indeg));\n\t\t\tmemset(used, 0, sizeof(used));\n\n\t\t\trep(i,v) rep(j,g[i].size()) indeg[ g[i][j] ]++;\n\t\t\trep(i,v) if(indeg[i] == 0 && not used[i]) bfs(i, indeg, used);\n\n\t\t\tfor(auto it:tp) cout << it << endl;\n\n\t\t\tif(tp.size() == v) return true;\n\t\t\telse return false;\n\t\t}\n};\n\n\nclass Union{\n\tpublic:\n\t\tint par[MAX_M]; //???\n\t\tint depth[MAX_M];//??¨?????±???\n\n\t\tvoid init(int n){\n\t\t\trep(i,n){\n\t\t\t\tpar[i] = i;\n\t\t\t\tdepth[i] = 0;\n\t\t\t}\n\t\t}\n\n\t\tint find(int x){\n\t\t\tif(par[x] == x){\n\t\t\t\treturn x;\n\t\t\t}else {\n\t\t\t\treturn par[x] = find(par[x]);\n\t\t\t}\n\t\t}\n\n\t\tvoid unite(int x, int y){\n\t\t\tx = find(x);\n\t\t\ty = find(y);\n\t\t\tif(x == y) return;\n\n\t\t\tif(depth[x] < depth[y]){\n\t\t\t\tpar[x] = y;\n\t\t\t}else{\n\t\t\t\tpar[y] = x;\n\t\t\t\tif(depth[x] == depth[y]) depth[x]++;\n\t\t\t}\n\t\t}\n\n\t\tbool same(int x, int y){\n\t\t\treturn find(x) == find(y);\n\t\t}\n};\n\nclass Edge{\n\tpublic:\n\t\tint to, cost;\n\t\tEdge(int to, int cost) : to(to) ,cost(cost) {}\n};\n\nclass Node{\n\tpublic:\n\t\tint dis;\n\t\tbool isUsed;\n\t\tint label;\n\t\tNode(){\n\t\t\tthis->dis = INF;\n\t\t\tthis->isUsed = 0;\n\t\t}\n};\n\ntypedef vector<vector<Edge>> AdjList;\n\nvoid dijkstra(AdjList g, int start, int n, vector<Node>& node){\n\tpriority_queue<int, vector<pair<int, int>>, greater<pair<int, int>>> q;\n\n\tq.push(make_pair(0, start));\n\tnode[start].dis = 0;\n\n\tpair<int, int> u;\n\twhile(not q.empty()){\n\t\tu = q.top(); q.pop();\n\t\tint current = u.second;\n\t\tnode[current].isUsed = 1;\n\n\t\trep(i,g[current].size()){\n\t\t\tint next = g[current][i].to;\n\t\t\tif(node[next].isUsed == 0){\n\t\t\t\tif(node[next].dis > node[current].dis + g[current][i].cost){\n\t\t\t\t\tnode[next].dis = node[current].dis + g[current][i].cost;\n\t\t\t\t\tq.push(make_pair(node[next].dis, next));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\tint n, q;\n\twhile(cin >> n >> q,n){\n\t\tint a[MAX_M], b[MAX_M], c[MAX_M];\n\t\tchar com[MAX_M];\n\n\n\t\tAdjList g(n);\n\t\tvector<int> in(n,0);\n\t\trep(i,q){\n\t\t\tcin >> com[i];\n\t\t\tif(com[i] == '!'){\n\t\t\t\tcin >> a[i] >> b[i] >> c[i];\n\t\t\t\ta[i]--; b[i]--;\n\t\t\t\tg[b[i]].emplace_back(Edge{a[i],c[i]});\n\t\t\t\tin[a[i]]++;\n\t\t\t}else{\n\t\t\t\tcin >> a[i] >> b[i];\n\t\t\t\ta[i]--; b[i]--;\n\t\t\t}\n\t\t}\n\n\t\tvector<Node> node(n);\n\t\trep(i,n){\n\t\t\tif(in[i] == 0){ //??\\?¬???°???0\n\t\t\t\tdijkstra(g, i, n, node);\n\t\t\t}\n\t\t}\n\n\t\t//for(auto i : node){ cout << i.dis << endl; }\n\n\t\tUnion uni;\n\t\tuni.init(n);\n\t\trep(i,q){\n\t\t\tif(com[i] == '!'){\n\t\t\t\tuni.unite(a[i], b[i]);\n\t\t\t}else{\n\t\t\t\tif(uni.same(a[i], b[i])){\n\t\t\t\t\t//show(a[i])\n\t\t\t\t\tcout << node[a[i]].dis - node[b[i]].dis << endl;\n\t\t\t\t}else{\n\t\t\t\t\tcout << \"UNKNOWN\" << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#define MAX_V 1000000\n#define f first\n#define s second\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nP par[MAX_V];\nint rank[MAX_V];\n\nvoid init(int n){\n  for(int i=0;i<n;i++)\n    par[i].f=i,par[i].s=0,rank[i]=0;\n}\n\nP find(int x){\n\n  if(par[x].f==x)return par[x];\n  P p=find(par[x].f);\n  par[x].s+=p.s,par[x].f=p.f;\n  return par[x];\n}\n\nvoid unite(int x,int y,int w){\n  P px=find(x);\n  P py=find(y);\n  par[px.f].f=py.f;\n  par[px.f].s+=par[y].s-w-par[x].s;\n}\n\nbool same(int x,int y){return find(x).f==find(y).f;}\n\nint main(void){\n\n  int n,m;\n  while(cin >> n >> m,n|m){\n    init(n+1);\n    int a,b,w;\n    char c;\n    for(int i=0;i<m;i++){\n      cin >> c >> a >> b;\n      if(c=='!'){\n        cin >> w;\n        unite(a,b,w);\n      }\n      else {\n        if(!same(a,b))cout << \"UNKNOWN\" << endl;\n        else cout << par[b].s-par[a].s << endl;\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\ntypedef pair<int, int> P;\nstruct UF{\n  vector<int> data;\n  vector<int> weight;\n  UF(int N) : data(N, -1), weight(N, 0) {}\n  void uni(int x, int y, int w){\n    P px = root(x), py = root(y);\n    if(px.first != py.first){\n      if(data[px.first] > data[px.first]){\n        swap(px, py);\n        w *= -1;\n      }\n      data[px.first] += data[py.first];\n      data[py.first] = px.first;\n      weight[py.first] = px.second - py.second + w;\n    }\n  }\n  P root(int x){\n    if(data[x] < 0) return P(x, 0);\n    P p = root(data[x]);\n    data[x] = p.first;\n    weight[x] += p.second;\n    return P(data[x], weight[x]);\n  }\n};\n\nint main(){\n  int N, M;\n  while(cin>>N>>M && N){\n    UF uf(N);\n    string s; int x, y, z;\n    REP(i, M){\n      cin>>s;\n      if(s == \"!\"){\n        scanf(\"%d %d %d\", &x, &y, &z);\n        x--; y--;\n        uf.uni(x, y, z);\n      }else{\n        scanf(\"%d %d\", &x, &y);\n        x--; y--;\n        P px = uf.root(x);\n        P py = uf.root(y);\n        if(px.first == py.first){\n          printf(\"%d\\n\", py.second - px.second);\n        }else{\n          printf(\"UNKNOWN\\n\");\n        }\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#pragma warning(disable : 4996)\nusing namespace std;\nint par[100000], dat[100000];\nint root(int x) {\n\treturn par[x] == x ? x : root(par[x]);\n}\nint dist(int x) {\n\treturn par[x] == x ? 0 : dist(par[x]) + dat[x];\n}\nint same(int x, int y) {\n\treturn root(x) == root(y);\n}\nvoid unite(int x, int y, int w) { \n\tx = root(x); y = root(y);\n\tif (x != y) {\n\t\tpar[x] = y;\n\t\tdat[x] = w;\n\t}\n}\nint query(int a, int b) {\n\treturn dist(a) - dist(b);\n}\nint N, Q, a, b, w; char c;\nint main() {\n\twhile (true) {\n\t\tscanf(\"%d%d\", &N, &Q);\n\t\tif (N == 0 && Q == 0) break;\n\t\tfor (int i = 0; i < N; i++) par[i] = i, dat[i] = 0;\n\t\tfor (int i = 0; i < Q; i++) {\n\t\t\tcin >> c;\n\t\t\tif (c == '!') {\n\t\t\t\tscanf(\"%d%d%d\", &a, &b, &w);\n\t\t\t\tunite(a - 1, b - 1, w);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tscanf(\"%d%d\", &a, &b);\n\t\t\t\tif (!same(a - 1, b - 1)) {\n\t\t\t\t\tprintf(\"UNKNOWN\\n\");\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tprintf(\"%d\\n\", query(a - 1, b - 1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <utility>\nusing namespace std;\n\ntypedef pair<int,int> pii;\n\npii par[100001];\nint rank[100001];\n\npii find(int x){\n\tif(par[x].first != x){\n\t\tpii p = find(par[x].first);\n\t\tpar[x] = pii(p.first, par[x].second + p.second);\n\t}\n\treturn par[x];\n}\n\nint main(){\n\tint m, n, a, b, w;\n\tchar cmd;\n\twhile(scanf(\"%d%d\", &n, &m), m != 0){\n\t\tfor(int i = 1; i <= n; ++i){\n\t\t\tpar[i] = pii(i, 0);\n\t\t\trank[i] = 0;\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < m; ++i){\n\t\t\tscanf(\" %c\", &cmd);\n\t\t\tif(cmd == '!'){\n\t\t\t\tscanf(\"%d%d%d\", &a, &b, &w);\n\t\t\t\tpii pa = find(a), pb = find(b);\n\t\t\t\tif(pa.first != pb.first){\n\t\t\t\t\tif(rank[pa.first] < rank[pb.first]){\n\t\t\t\t\t\tpar[pa.first] = pii(pb.first, pb.second - pa.second + w);\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tpar[pb.first] = pii(pa.first, pa.second - pb.second - w);\n\t\t\t\t\t\tif(rank[pa.first] == rank[pb.first]){\n\t\t\t\t\t\t\t++rank[pa.first];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tscanf(\"%d%d\", &a, &b);\n\t\t\t\tpii pa = find(a), pb = find(b);\n\t\t\t\tif(pa.first != pb.first){\n\t\t\t\t\tputs(\"UNKNOWN\");\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tprintf(\"%d\\n\", pa.second - pb.second);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(ll i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define show(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define show(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<ll,ll> pii;\ntemplate<typename T> using vec=std::vector<T>;\n\nconst int inf=1<<30;\nconst long long int infll=1LL<<62;\nconst double eps=1e-9;\nconst ll dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nclass union_find{\n\tprivate:\n\tvector<ll> parent,diff;\n    ll size;\n\tpublic:\n    union_find()=default;\n    union_find(ll n){ init(n); }\n\n    void init(ll n){\n\t\tsize=n;\n\t\tparent.resize(size);\n        diff.resize(size);\n\t\tfor(ll i=0; i<size; ++i){\n\t\t\tparent[i]=i;\n            diff[i]=0;\n\t\t}\n\t}\n\n\tpii find(ll x){\n\t\tif(parent[x]==x) return make_pair(x,0);\n        pii p=find(parent[x]);\n        parent[x]=p.first;\n        diff[x]+=p.second;\n        return make_pair(parent[x],diff[x]);\n\t}\n\n\tvoid unite(ll x,ll y,ll w){\n\t\tpii a=find(x),b=find(y);\n\t\tif(a.first==b.first) return;\n        parent[a.first]=b.first;\n        diff[a.first]=w-diff[x];\n\t}\n\n\tbool is_same(ll x,ll y){\n\t\treturn find(x).first==find(y).first;\n\t}\n\n    ll calc_diff(ll x,ll y){\n        auto a=find(x),b=find(y);\n        return find(x).second-find(y).second;\n    }\n};\n\nvoid solve(ll n,ll m){\n    union_find uf(n);\n\n    rep(i,0,m){\n        char ch;\n        ll a,b;\n        cin >> ch >> a >> b;\n        --a;\n        --b;\n        if(ch=='!'){\n            int w;\n            cin >> w;\n            uf.unite(a,b,w);\n        }else{\n            if(!uf.is_same(a,b)) cout << \"UNKNOWN\" << endl;\n            else cout << uf.calc_diff(a,b) << endl;\n        }\n    }\n}\n\nint main(){\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    cout.setf(ios::fixed);\n    cout.precision(10);\n    while(true){\n        ll n,m;\n        cin >> n >> m;\n        if(!n and !m) break;\n        solve(n,m);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nclass WeightedDisjointSets\n{\nprivate:\n    using T = ll;\n    vector<int> parent, rank;\n    vector<T> weight;\n\npublic:\n    WeightedDisjointSets(const int v) : parent(v), rank(v, 0), weight(v, 0) { iota(parent.begin(), parent.end(), 0); }\n    bool same(const int a, const int b) { return find(a) == find(b); }\n    int find(const int a) { return parent[a] == a ? a : (weight[a] += weight[parent[a]], parent[a] = find(parent[a])); }\n    T getWeight(const int a) { return find(a), weight[a]; }\n    void unite(int a, int b, T d)\n    {\n        d += getWeight(a) - getWeight(b);\n        a = find(a), b = find(b);\n        if (a == b) { return; }\n        if (rank[a] > rank[b]) { swap(a, b), d = -d; }\n        rank[a] += rank[b], parent[b] = a, weight[b] = d;\n    }\n    T diff(const int a, const int b) { return getWeight(b) - getWeight(a); }\n};\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while (true) {\n        int N, M;\n        cin >> N >> M;\n        if (N == 0 and M == 0) { break; }\n        WeightedDisjointSets uf(N);\n        for (int i = 0; i < M; i++) {\n            char c;\n            int a, b;\n            cin >> c >> a >> b;\n            a--, b--;\n            if (c == '!') {\n                ll c;\n                cin >> c;\n                uf.unite(a, b, c);\n            } else {\n                cout << (uf.same(a, b) ? to_string(uf.diff(a, b)) : \"UNKNOWN\") << endl;\n            }\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\n//------------------------------- Libraries --------------------------------//\n\ntemplate <class T>\nclass WeightedUnionFind\n{\n    vector<int> par;\n    vector<T> dist;\n\npublic:\n    WeightedUnionFind(int n) : par(n, -1), dist(n, 0) {}\n\n    int root(int x)\n    {\n        if (par[x] < 0)\n            return x;\n        else\n        {\n            //rootから降りて足していく\n            int r = root(par[x]);\n            //親までの累積和は計算し終わっている\n            dist[x] += dist[par[x]];\n            return par[x] = r;\n        }\n    }\n\n    //d[y] = d[x] + w\n    bool merge(int x, int y, T w)\n    {\n        //par[y] = x\n        w += weight(x) - weight(y);\n        x = root(x);\n        y = root(y);\n        if (x == y)\n            return false;\n        if (par[x] > par[y])\n        {\n            w = -w;\n            swap(x, y);\n        }\n        par[x] += par[y];\n        par[y] = x;\n        dist[y] = w;\n        return true;\n    }\n\n    T weight(int x)\n    {\n        root(x);\n        return dist[x];\n    }\n\n    T dis(int x, int y) { return weight(y) - weight(x); }\n\n    int size(int x) { return -par[root(x)]; }\n};\n\n//verified @ https://onlinejudge.u-aizu.ac.jp/solutions/problem/DSL_1_B/review/3922525/sifi_border/C++14\n\n//------------------------------- Type Names -------------------------------//\n\nusing i64 = int_fast64_t;\n\nusing seika = string;\n//akari : 1D, yukari : 2D, maki : 3D vector\ntemplate <class kizuna>\nusing akari = vector<kizuna>;\ntemplate <class yuzuki>\nusing yukari = akari<akari<yuzuki>>;\ntemplate <class tsurumaki>\nusing maki = akari<yukari<tsurumaki>>;\n//akane : ascending order, aoi : decending order\ntemplate <class kotonoha>\nusing akane = priority_queue<kotonoha, akari<kotonoha>, greater<kotonoha>>;\ntemplate <class kotonoha>\nusing aoi = priority_queue<kotonoha>;\n\n//------------------------------- Dubug Functions ---------------------------//\ninline void print()\n{\n    cout << endl;\n}\ntemplate <typename First, typename... Rest>\nvoid print(const First &first, const Rest &... rest)\n{\n    cout << first << ' ';\n    print(rest...);\n}\n//------------------------------- Solver ------------------------------------//\n\nvoid solve()\n{\n    int n, m;\n    char c;\n    while (cin >> n >> m && n)\n    {\n        WeightedUnionFind<int> wuf(n);\n        while (m--)\n        {\n            int a, b, w;\n            cin >> c;\n            if (c == '!')\n            {\n                cin >> a >> b >> w;\n                a--, b--;\n                wuf.merge(a, b, w);\n            }\n            else\n            {\n                cin >> a >> b;\n                a--, b--;\n                if (wuf.root(a) == wuf.root(b))\n                {\n                    cout << wuf.dis(a, b) << '\\n';\n                }\n                else\n                {\n                    cout << \"UNKNOWN\\n\";\n                }\n            }\n        }\n    }\n}\n\nint main()\n{\n    solve();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nusing int64 = long long;\nconst int mod = 1e9 + 7;\n\nconst int64 infll = (1LL << 62) - 1;\nconst int inf = (1 << 30) - 1;\n\nstruct IoSetup {\n  IoSetup() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n    cerr << fixed << setprecision(10);\n  }\n} iosetup;\n\n\ntemplate< typename T1, typename T2 >\nostream &operator<<(ostream &os, const pair< T1, T2 > &p) {\n  os << p.first << \" \" << p.second;\n  return os;\n}\n\ntemplate< typename T1, typename T2 >\nistream &operator>>(istream &is, pair< T1, T2 > &p) {\n  is >> p.first >> p.second;\n  return is;\n}\n\ntemplate< typename T >\nostream &operator<<(ostream &os, const vector< T > &v) {\n  for(int i = 0; i < (int) v.size(); i++) {\n    os << v[i] << (i + 1 != v.size() ? \" \" : \"\");\n  }\n  return os;\n}\n\ntemplate< typename T >\nistream &operator>>(istream &is, vector< T > &v) {\n  for(T &in : v) is >> in;\n  return is;\n}\n\ntemplate< typename T1, typename T2 >\ninline bool chmax(T1 &a, T2 b) { return a < b && (a = b, true); }\n\ntemplate< typename T1, typename T2 >\ninline bool chmin(T1 &a, T2 b) { return a > b && (a = b, true); }\n\ntemplate< typename T = int64 >\nvector< T > make_v(size_t a) {\n  return vector< T >(a);\n}\n\ntemplate< typename T, typename... Ts >\nauto make_v(size_t a, Ts... ts) {\n  return vector< decltype(make_v< T >(ts...)) >(a, make_v< T >(ts...));\n}\n\ntemplate< typename T, typename V >\ntypename enable_if< is_class< T >::value == 0 >::type fill_v(T &t, const V &v) {\n  t = v;\n}\n\ntemplate< typename T, typename V >\ntypename enable_if< is_class< T >::value != 0 >::type fill_v(T &t, const V &v) {\n  for(auto &e : t) fill_v(e, v);\n}\n\ntemplate< typename T >\nstruct WeightedUnionFind {\n  vector< int > data;\n  vector< T > ws;\n\n  WeightedUnionFind() {}\n\n  WeightedUnionFind(int sz) : data(sz, -1), ws(sz) {}\n\n  int find(int k) {\n    if(data[k] < 0) return k;\n    auto par = find(data[k]);\n    ws[k] += ws[data[k]];\n    return data[k] = par;\n  }\n\n  T weight(int t) {\n    find(t);\n    return ws[t];\n  }\n\n  bool unite(int x, int y, T w) {\n    w += weight(x);\n    w -= weight(y);\n    x = find(x), y = find(y);\n    if(x == y) return false;\n    if(data[x] > data[y]) {\n      swap(x, y);\n      w *= -1;\n    }\n    data[x] += data[y];\n    data[y] = x;\n    ws[y] = w;\n    return true;\n  }\n\n  T diff(int x, int y) {\n    return weight(y) - weight(x);\n  }\n};\n\n\nint main() {\n  int N, M;\n  while(cin >> N >> M, N) {\n    WeightedUnionFind< int > tree(N);\n    while(M--) {\n      char A;\n      int B, C, D;\n      cin >> A >> B >> C;\n      --B, --C;\n      if(A == '!') {\n        cin >> D;\n        tree.unite(B, C, D);\n      } else {\n        if(tree.find(B) == tree.find(C)) {\n          cout << tree.diff(B, C) << endl;\n        } else {\n          cout << \"UNKNOWN\" << endl;\n        }\n      }\n    }\n  }\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define PI       3.1415926535897932384626433832795028841971\n#define INF 1000000000\n#define EPS      1e-10\n#define MOD      1000000\nusing namespace std;\ntypedef long long ll;\ntypedef pair<double,double> P;\ntypedef pair<double,P> PQ;\n\nstruct Q{\n    int time,a, b;\n};\n\nstruct edge{\n    int time, to, w;\n};\n\nint n, m;\nint bss[100000];\nint rnk[100000];\nint num[100000];\nbool saw[100000];\nvector<edge> e[100000];\nvector<Q> q;\nint up[20][100000];\nint par[20][100000];\n\nvoid dfs(int v, int bos){\n    saw[v] = true;\n    rep(i,e[v].size()){\n        edge E = e[v][i];\n        if(saw[E.to]) continue;\n        up[0][E.to] = E.time;\n        rnk[E.to] = rnk[v]+1;\n        num[E.to] = num[v]+E.w;\n        bss[E.to] = bos;\n        par[0][E.to] = v;\n        dfs(E.to,bos);\n    }\n}\n\nint main(){\n    while(cin >> n >> m){\n        if(n == 0 && m == 0) break;\n        memset(bss,0,sizeof(bss));\n        memset(rnk,0,sizeof(rnk));\n        memset(num,0,sizeof(num));\n        memset(saw,0,sizeof(saw));\n        rep(i,n) e[i].clear();\n        q.clear();\n        memset(up,0,sizeof(up));\n        rep(i,m){\n            char hoge;\n            int a, b, w;\n            cin >> hoge;\n            if(hoge == '!'){\n                cin >> a >> b >> w;\n                a--; b--;\n                e[a].push_back((edge){i,b,w});\n                e[b].push_back((edge){i,a,-w});\n            } else{\n                cin >> a >> b;\n                a--; b--;\n                q.push_back((Q){i,a,b});\n            }\n        }\n        rep(i,20){\n            rep(j,n) par[i][j] = i;\n        }\n        rep(i,n){\n            if(saw[i]) continue;\n            dfs(i,i);\n        }\n        for(int i = 1; i < 20; i++){\n            rep(j,n){\n                par[i][j] = par[i-1][j];\n                up[i][j] = max(up[i-1][j],up[i-1][par[i-1][j]]);\n            }\n        }\n        rep(i,q.size()){\n            Q p = q[i];\n            bool done = false;\n            if(bss[p.a] != bss[p.b]){\n                cout << \"UNKNOWN\" << endl;\n                continue;\n            }\n            int ans = num[p.b]-num[p.a];\n            if(rnk[p.a] > rnk[p.b]){\n                int dis = rnk[p.a]-rnk[p.b];\n                int z = 0;\n                while(dis > 0){\n                    if(dis&1){\n                        if(up[z][p.a] > p.time){\n                            done = true;\n                            cout << \"UNKNOWN\" << endl;\n                            break;\n                        }\n                        p.a = par[z][p.a];\n                    }\n                    z++;\n                    dis /= 2;\n                }\n            } else if(rnk[p.a] < rnk[p.b]){\n                int dis = rnk[p.b]-rnk[p.a];\n                int z = 0;\n                while(dis > 0){\n                    if(dis&1){\n                        if(up[z][p.b] > p.time){\n                            done = true;\n                            cout << \"UNKNOWN\" << endl;\n                            break;\n                        }\n                        p.b = par[z][p.b];\n                    }\n                    z++;\n                    dis /= 2;\n                }\n            }\n            if(done) continue;\n            int common = 0;\n            for(int j = 19; j >= 0; j--){\n                if(par[j][p.a] == par[j][p.b]) continue;\n                common += (1<<j);\n            }\n            common++;\n            int z = 0;\n            while(common > 0){\n                if(common&1){\n                    if(up[z][p.a] > p.time){\n                        done = true;\n                        cout << \"UNKNOWN\" << endl;\n                        break;\n                    }\n                    if(up[z][p.b] > p.time){\n                        done = true;\n                        cout << \"UNKNOWN\" << endl;\n                        break;\n                    }\n                    p.a = par[z][p.a];\n                    p.b = par[z][p.b];\n                }\n                common /= 2;\n                z++;\n            }\n            if(done) continue;\n            cout << ans << endl;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cassert>\n#include <utility>\nusing namespace std;\ntypedef pair<int,int> pii;\n#define repeat(i,n) for (int i = 0; i < n; ++i)\n#define repeat_from(i,m,n) for (int i = m; i < n; ++i)\n\n#define MAX_N 100000\n#define MAX_M 100000\nint N, M;\n\npii tree[MAX_N];\nvoid init_tree(int n) { repeat (i,n) { tree[i] = pii(i,0); } }\npii find_root(int a) {\n    if (tree[a].first != a) {\n        pii pb = find_root(tree[a].first);\n        tree[a].first = pb.first;\n        tree[a].second += pb.second;\n    }\n    return tree[a];\n}\nvoid union_tree(int a, int b, int w) {\n    pii pa = find_root(a), pb = find_root(b);\n    if (pa.first != pb.first) {\n        tree[pa.first].first = pb.first;\n        tree[pa.first].second -= pb.second + w;\n    } else {\n        assert(false);\n    }\n}\n\nint main(void) {\n    while (true) {\n        cin >> N >> M; cin.ignore();\n        if (not N or not M) break;\n        init_tree(N);\n        repeat (i,M) {\n            char c; cin >> c;\n            if (c == '!') {\n                int a, b, w; cin >> a >> b >> w; cin.ignore(); -- a; -- b;\n                union_tree(a,b,w);\n            } else if (c == '?') {\n                int a, b; cin >> a >> b; cin.ignore(); -- a; -- b;\n                pii pa = find_root(a), pb = find_root(b);\n                if (pa.first == pb.first) {\n                    cout << pb.second - pa.second << endl;\n                } else {\n                    cout << \"UNKNOWN\" << endl;\n                }\n            } else {\n                assert(false);\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <map>\n#include <algorithm>\n#define  pb  push_back\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef vector<P> Graph;\n\nbool used[100001];\n\nint main(void){\n\tint N,M;\n\twhile(cin >> N >> M,N|M){\n\t\tGraph graph[100001];\n\t\tfor(int i=0;i<M;i++){\n\t\t\tchar q;\n\t\t\tint a,b,w;\n\t\t\tcin >> q;\n\t\t\tif(q=='!'){\n\t\t\t\tcin >> a >> b >> w;\n\t\t\t\tP froma=make_pair(b,w);\n\t\t\t\tP fromb=make_pair(a,-w);\n\t\t\t\tgraph[a].pb(froma);\n\t\t\t\tgraph[b].pb(fromb);\n\t\t\t}else{\n\t\t\t\tcin >> a >> b;\n\t\t\t\tbool unknown=true;\n\t\t\t\tP start=make_pair(a,0);\n\t\t\t\tqueue<P> q;\n\t\t\t\tq.push(start);\n\t\t\t\tfill(used,used+N,false);\n\t\t\t\twhile(!q.empty()){\n\t\t\t\t\tP cur=q.front();q.pop();\n\t\t\t\t\tint ncur=cur.first;\n\t\t\t\t\tused[ncur]=true;\n\t\t\t\t\tif(ncur==b){\n\t\t\t\t\t\tunknown=false;\n\t\t\t\t\t\tcout << cur.second << endl;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tfor(int i=0;i<graph[ncur].size();i++){\n\t\t\t\t\t\tint to=graph[ncur][i].first;\n\t\t\t\t\t\tint dis=graph[ncur][i].second;\n\t\t\t\t\t\tif(!used[to]){\n\t\t\t\t\t\t\tP next=cur;\n\t\t\t\t\t\t\tnext.first=to;next.second+=dis;\n\t\t\t\t\t\t\tq.push(next);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(unknown)\n\t\t\t\t\tcout << \"UNKNOWN\" << endl;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cmath>\n#include<queue>\n\nusing namespace std;\n\nconst int INF=0x3f3f3f3f;\nconst int top=100000+100;\n\n\nint w[top];\nint father[top];\nint dis[top],vis[top],head[top];\nint n;\nint Find(int a,int &cost)\n{\n    int ta=a;\n    while(a!=father[a])\n    {\n        cost+=dis[a];\n        a=father[a];\n    }\n    father[ta]=a;\n    dis[ta]=cost;\n    return a;\n}\n\nvoid Merge(int _a,int _b,int _cost)\n{\n    int c1=0,c2=0;\n    int a=Find(_a,c1),b=Find(_b,c2);\n   // printf(\"In Function Merge,a=%d,b=%d,c1=%d,c2=%d,_cost=%d\\n\",a,b,c1,c2,_cost);\n    if(a<b)\n    {\n        father[b]=a;\n        dis[b]=c1-c2+_cost;\n    }\n\n    else\n    {\n        father[a]=b;\n        dis[a]=-c1+c2-_cost;\n    }\n    //    printf(\"In Function Merge,a=%d,b=%d,c1=%d,c2=%d,_cost=%d\\n\",a,b,c1,c2,_cost);\n    // printf(\"dis[a]=%d,dis[b]=%d\\n\",dis[a],dis[b]);\n\n}\n\nint main()\n{\n    int m;\n    int a,b,d;\n    int i;\n    char order[2];\n    while(scanf(\"%d%d\",&n,&m)&&n+m)\n    {\n        memset(w,INF,sizeof(w));\n        memset(head,-1,sizeof(head));\n     //   cnt=0;\n        for(i=1;i<=n;i++)\n        {\n            father[i]=i;\n        }\n        for(i=0;i<m;i++)\n        {\n            scanf(\"%s\",order);\n            if(order[0]=='!')\n            {\n                scanf(\"%d%d%d\",&a,&b,&d);\n                Merge(a,b,d);\n            }\n            else\n            {\n                scanf(\"%d%d\",&a,&b);\n                int c1=0,c2=0;\n                int fa=Find(a,c1),fb=Find(b,c2);\n                if(fa!=fb)\n                {\n                    printf(\"UNKNOWN\\n\");\n                }\n                else\n                {\n                  //  printf(\"c1=%d,c2=%d\\n\",c1,c2);\n                    printf(\"%d\\n\",c2-c1);\n                }\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n#include<numeric>\n#include<utility>\n#include<complex>\n#include<functional>\n \nusing namespace std;\n\n/* constant */\n\n#define MAX_N\t(100000)\n\n/* typedef */\n\n/* global variables */\n\nint uft[MAX_N + 1], dfs[MAX_N + 1], lvls[MAX_N + 1];\n\n/* subroutines */\n\nint rootd(int k, int& d) {\n  int rk = k;\n  d = 0;\n  \n  while (rk != uft[rk]) {\n    d += dfs[rk];\n    rk = uft[rk];\n  }\n\n  return rk;\n}\n\n/* main */\n\nint main() {\n  for (;;) {\n    int n, m;\n    cin >> n >> m;\n    if ((n | m) == 0) break;\n\n    for (int i = 1; i <= n; i++) {\n      uft[i] = i;\n      dfs[i] = 0;\n      lvls[i] = 1;\n    }\n\n    for (int i = 0; i < m; i++) {\n      char op;\n      int a, b;\n\n      cin >> op >> a >> b;\n\n      int ra, rb, da, db;\n      ra = rootd(a, da);\n      rb = rootd(b, db);\n    \n      if (op == '!') {\n\tint w;\n\tcin >> w;\n\tint rd = w + db - da;\n\n\tif (ra == rb) {\n\t  if (rd == 0) continue;\n\t  cout << \"Error\" << endl;\n\t  exit(0);\n\t}\n\n\tif (lvls[ra] <= lvls[rb]) {\n\t  uft[ra] = rb;\n\t  dfs[ra] = rd;\n\t  if (lvls[ra] == lvls[rb]) lvls[rb]++;\n\t}\n\telse {\n\t  uft[rb] = ra;\n\t  dfs[rb] = -rd;\n\t}\n      }\n      else {\n\tif (ra != rb)\n\t  cout << \"UNKNOWN\" << endl;\n\telse {\n\t  int d = da - db;\n\t  cout << d << endl;\n\t}\n      }\n    }\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <queue>\n#include <cmath>\n#include <algorithm>\n#include <functional>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define rep1(i,n) for(int i=1;i<=(n);++i)\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl;\nvector<int> i2g;\nvector<vector<int> > g2i;\nint w[100000];\nvoid init(int n){\n\ti2g.resize(n);\n\tg2i.resize(n);\n\trep(i,n){\n\t\ti2g[i]=i;\n\t\tg2i[i].assign(1,i);\n\t\tw[i]=0;\n\t}\n}\nvoid unite(int ia,int ib,int ww){\n\tint dif=ww+w[ia]-w[ib];\n\tif(g2i[i2g[ia]].size() < g2i[i2g[ib]].size()) swap(ia,ib),dif*=-1;\n\tint ga=i2g[ia],gb=i2g[ib];\n\trep(i,g2i[gb].size()){\n\t\ti2g[g2i[gb][i]]=ga;\n\t\tw[g2i[gb][i]]+=dif;\n\t}\n\tg2i[ga].insert(g2i[ga].end(),all(g2i[gb]));\n}\nbool same(int ia,int ib){\n\treturn i2g[ia]==i2g[ib];\n}\nint main(){\n\twhile(true){\n\t\tint n,m;\n\t\tcin>>n>>m;\n\t\tif(n==0) break;\n\t\tinit(n);\n\t\trep(i,m){\n\t\t\tchar c;\n\t\t\tcin>>c;\n\t\t\tif(c=='!'){\n\t\t\t\tint a,b,dif;\n\t\t\t\tcin>>a>>b>>dif;\n\t\t\t\ta--,b--;\n\t\t\t\tif(same(a,b)) continue;\n\t\t\t\tunite(a,b,dif);\n\t\t\t}else{\n\t\t\t\tint a,b;\n\t\t\t\tcin>>a>>b;\n\t\t\t\ta--,b--;\n\t\t\t\tif(same(a,b)){\n\t\t\t\t\tcout << w[b]-w[a]<<endl;\n\t\t\t\t}else{\n\t\t\t\t\tcout << \"UNKNOWN\\n\";\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nstruct UnionFind {\n    int sz;\n    std::vector<int> par;\n    UnionFind(int sz) {\n        this->sz = sz;\n        par.clear();\n        par.resize(sz, -1);\n    }\n    int root(int x) {\n        return par[x] < 0 ? x : par[x] = root(par[x]);\n    }\n    void unite(int a, int b) {\n        int roota = root(a);\n        int rootb = root(b);\n        if(roota == rootb) return;\n        if(par[rootb] < par[roota]) std::swap(roota, rootb);\n        par[roota] += par[rootb];\n        par[rootb] = roota;\n    }\n    bool same(int a, int b) {\n        return (root(a) == root(b));\n    }\n    int size(int a) {\n        return -par[root(a)];\n    }\n};\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing P = pair<int, int>;\nusing vi = vector<int>;\nusing vvi = vector<vector<int>>;\nusing vll = vector<ll>;\nusing vvll = vector<vector<ll>>;\nconst double eps = 1e-10;\nconst int MOD = 1000000007;\nconst int INF = 1000000000;\nconst ll LINF = 1000000000010ll;\ntemplate<typename T>\nvoid printv(const vector<T>& s) {\n  for(int i=0;i<(int)(s.size());++i) {\n    cout << s[i];\n    if(i == (int)(s.size())-1) cout << endl;\n    else cout << \" \";\n  }\n}\nstruct Weight {\n  int n;\n  vector<int> prev;\n  vector<ll> w;\n  Weight(int n): n(n) {\n    prev.clear();\n    prev.resize(n, -1);\n    w.clear();\n    w.resize(n, 0);\n  }\n  int root(int x) {\n    if(prev[x] < 0) {\n      assert(x >= 0);\n      return x;\n    } else {\n      int tmpr = root(prev[x]);\n      int tmpw = weight(prev[x]);\n      w[x] += tmpw;\n      prev[x] = tmpr;\n      return tmpr;\n    }\n  }\n  int size(int x) {\n    return prev[x] < 0 ? -prev[x] : size(prev[x]);\n  }\n  ll weight(int x) {\n    root(x);\n    return w[x];\n  }\n  int root(int x, int y) {\n    if(x == y) return y;\n    else return prev[x] < 0 ? x : root(prev[x], y);\n  }\n  void update(int a, int b, ll wa) {\n    int ra = root(a);\n    int rb = root(b);\n    int sa = size(a);\n    int sb = size(b);\n    if(ra == rb) return;\n    if(sa < sb) {\n      wa -= weight(a);\n      wa += weight(b);\n      prev[rb] += prev[ra];\n      prev[ra] = rb;\n      w[ra] = wa;\n    } else {\n      wa = - wa;\n      wa -= weight(b);\n      wa += weight(a);\n      prev[ra] += prev[rb];\n      prev[rb] = ra;\n      w[rb] = wa;\n    }\n  }\n  ll query(int a, int b) {\n    int ra = root(a);\n    int rb = root(b);\n    if(ra != rb) return LINF;\n    return weight(b) - weight(a);\n  }\n};\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  cout << fixed << setprecision(10);\n  while(1) {\n    int n, m; cin >> n >> m;\n    if(n == 0) break;\n    Weight wgt(n);\n    for(int i=0;i<m;++i) {\n      char c; cin >> c;\n      if(c == '!') {\n        int a, b, w; cin >> a >> b >> w;\n        a--; b--;\n        wgt.update(a, b, w);\n      } else {\n        int a, b; cin >> a >> b;\n        a--; b--;\n        ll tmp = wgt.query(a, b);\n        if(tmp == LINF) cout << \"UNKNOWN\" << endl;\n        else cout << -tmp << endl;\n      }\n    }\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <deque>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <vector>\n#include <set>\n#include <limits>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < (int)(j); ++i)\n#define FOR(i, j, k) for(int i = (int)(j); i < (int)(k); ++i)\n#define SORT(v) sort((v).begin(), (v).end())\n#define REVERSE(v) reverse((v).begin(), (v).end())\ntypedef pair<int, int> P;\n//#define DEBUG\n\nvector<int> v, parent, depth, dist;\n\n// P(parent, dist)\nP find(int a){\n  if(parent[a] == a) return P(a, 0);\n  P p = find(parent[a]);\n  parent[a] = p.first;\n  dist[a] += p.second;\n  return P(p.first, dist[a]);\n}\n\nvoid merge(int a, int b, int d){\n  P pa = find(a), pb = find(b);\n  if(pa.first == pb.first) return ;\n\n  if(depth[a] < depth[b]){\n    parent[pb.first] = pa.first;\n    dist[pb.first] = pb.second - pa.second + d;\n  } else{\n    parent[pa.first] = pb.first;\n    dist[pa.first] = pa.second - pb.second - d;\n    if(depth[pa.first] == depth[pb.first]) ++depth[pb.first];\n  }\n}\n\nbool same(int a, int b){\n  return find(a).first == find(b).first;\n}\n\nvoid init_union_find(int V){\n  v = vector<int>(V);\n  parent = vector<int>(V);\n  depth = vector<int>(V, 0);\n  dist = vector<int>(V, 0);\n  REP(i, V) parent[i] = i;\n}\n\nint main() {\n  int N, M;\n  while(cin >>N >>M && N){\n    init_union_find(N);\n    REP(i, M){\n      char c; cin >>c;\n      if(c == '!'){\n        int x, y, z; cin >>x >>y >>z;\n        merge(x - 1, y - 1, z);\n      } else{\n        int x, y; cin >>x >>y;\n        P xp = find(x - 1), yp = find(y - 1);\n        if(xp.first != yp.first) cout <<\"UNKNOWN\" <<endl;\n        else cout <<yp.second - xp.second <<endl;\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<cassert>\n#include<cctype>\n#include<climits>\n#include<cmath>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<iostream>\n#include<iomanip>\n#include<map>\n#include<numeric>\n#include<queue>\n#include<vector>\n#include<set>\n#include<string>\n#include<stack>\n#include<sstream>\n#include<complex>\n\n#define pb push_back\n#define clr clear()\n#define sz size()\n#define fs first\n#define sc second\n\n#define rep(i,a) for(int i=0;i<(int)(a);i++)\n#define rrep(i,a) for(int i=(int)(a)−1;i>=0;i−−)\n#define all(a) (a).begin(),(a).end()\n#define EQ(a,b) (abs((a)−(b)) < EPS)\n#define INIT(a) memset(a,0,sizeof(a))\n\nusing namespace std;\ntypedef double D;\ntypedef pair<int,int> P;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\n\nconst D EPS = 1e-7;\nconst D INF = 1e9;\nconst D PI = acos(-1);\nconst int N = 100100;\n\nP par[N];\nint r[N];\n\nvoid init(int n){\n  rep(i,n)par[i] = P(i,0);\n  INIT(r);\n}\n\nP find(int a){\n  if(par[a].fs == a)return par[a];\n  P tmp = find(par[a].fs);\n  return par[a] = P(tmp.fs,tmp.sc + par[a].sc);\n}\n\nbool same(int a,int b){\n  return (find(a).fs == find(b).fs);\n}\n\nbool unite(int a,int b,int cost){\n  P x = find(a);\n  P y = find(b);\n  if(same(x.fs,y.fs)){\n    if(y.sc - x.sc != cost)return false;\n  }else{\n    if(r[x.fs]<r[y.fs]){\n      par[x.fs] = P(y.fs,y.sc-x.sc-cost);\n    }else{\n      par[y.fs] = P(x.fs,x.sc-y.sc+cost);\n      if(r[x.fs] == r[y.fs])r[x.fs]++;\n    }\n  }\n  return true;\n}\n\nint dis(int a, int b){\n  return find(b).sc - find(a).sc;\n}\n\nint main(){\n  int n,m;\n  int a,b,w;\n  char c;\n\n  while(cin >> n >> m,n){\n    init(n+1);\n    rep(i,m){\n      cin >> c;\n      if(c == '!'){\n\tcin >> a >> b >> w;\n\tunite(a,b,w);\n      }else{\n\tcin >> a >> b;\n\tif(!same(a,b))cout << \"UNKNOWN\" << endl;\n\telse cout << dis(a,b) << endl;\n      }\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <utility>\n#include <iostream>\n#include <algorithm>\n#include <string>\nusing namespace std;\nint P[100001],value[100001];\nvoid Init(int n)\n{\n    int i;\n    for(i=0;i<=n;i++)\n        {P[i] = i;value[i]=0;}\n}\nint find(int x)\n{\n    if(P[x] == x)\n        return x;\n    else    {\n                int temp = P[x];\n                P[x] = find(P[x]);\n                value[x] += value[temp];\n                return P[x];\n            }\n}\n\nint main()\n{\n    int N,M;\n    cin >> N >> M;\n    //Init(N);\n    while(N && M)\n    {\n        Init(N);\n        while(M)\n        {\n            M--;\n            char st;\n            int a,b,w;\n            cin >> st;\n            if(st == '!')\n            {\n                cin >> a >> b >> w;\n                int u = find(a);\n                int v = find(b);\n                P[v] = u;\n                value[v] = value[a]-value[b]+w;\n            }\n            else    if(st == '?')\n                    {\n                        cin >> a >> b;\n                        if(find(a) != find(b))\n                            cout << \"UNKNOWN\" << endl;\n                        else    cout << value[b]-value[a] << endl; \n                    }\n        }\n        cin >> N >> M;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\nusing namespace std;\ntypedef long long ll;\nconst int MAXN = 100005;\nint n, m;\nint c[MAXN];\nll L[MAXN];\nvector <int> v[MAXN];\nint main() {\n\twhile (scanf(\"%d%d\", &n, &m) != EOF) {\n\t\tif (n == 0 && m == 0) break;\n\t\tfor (int i = 1; i <= n; i++) c[i] = i, L[i] = 0, v[i].push_back(i);\n\t\tfor (int i = 1; i <= m; i++) {\n\t\t\tchar op; scanf(\" %c\", &op);\n\t\t\tif (op == '?') {\n\t\t\t\tint x, y; scanf(\"%d%d\", &x, &y);\n\t\t\t\tif (c[x] != c[y]) puts(\"UNKNOWN\");\n\t\t\t\telse printf(\"%lld\\n\", L[y] - L[x]);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tint x, y, cx, cy, z; scanf(\"%d%d%d\", &x, &y, &z); //y = x+z\n\t\t\t\tcx = c[x]; cy = c[y];\n\t\t\t\tif (cx == cy) continue;\n\t\t\t\telse {\n\t\t\t\t\tif (v[cx].size() > v[cy].size()) {\n\t\t\t\t\t\tll Ly = L[y];\n\t\t\t\t\t\tfor (auto &t : v[cy]) L[t] = -(Ly - L[t]) + L[x] + z;\n\t\t\t\t\t\tfor (auto &t : v[cy]) c[t] = cx, v[cx].push_back(t);\n\t\t\t\t\t\tv[cy].clear();\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tll Lx = L[x];\n\t\t\t\t\t\tfor (auto &t : v[cx]) L[t] = -(Lx - L[t]) + L[y] - z;\n\t\t\t\t\t\tfor (auto &t : v[cx]) c[t] = cy, v[cy].push_back(t);\n\t\t\t\t\t\tv[cx].clear();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i <= n; i++) v[i].clear();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cstdio>\nusing namespace std;\ntemplate<class Abel> struct UnionFind {\n       vector<int> par;\n       vector<int> rank;\n       vector<Abel> diff_weight;\n       UnionFind(int n = 1, Abel SUM_UNITY = 0) {\n              init(n, SUM_UNITY);\n       }\n       void init(int n = 1, Abel SUM_UNITY = 0) {\n              par.resize(n); rank.resize(n); diff_weight.resize(n);\n              for (int i = 0; i < n; ++i) par[i] = i, rank[i] = 0, diff_weight[i] = SUM_UNITY;\n       }\n       int root(int x) {\n              if (par[x] == x) {\n                     return x;\n              }\n              else {\n                     int r = root(par[x]);\n                     diff_weight[x] += diff_weight[par[x]];\n                     return par[x] = r;\n              }\n       }\n       Abel weight(int x) {\n              root(x);\n              return diff_weight[x];\n       }\n       bool issame(int x, int y) {\n              return root(x) == root(y);\n       }\n       bool merge(int x, int y, Abel w) {\n              w += weight(x); w -= weight(y);\n              x = root(x); y = root(y);\n              if (x == y) return false;\n              if (rank[x] < rank[y]) swap(x, y), w = -w;\n              if (rank[x] == rank[y]) ++rank[x];\n              par[y] = x;\n              diff_weight[y] = w;\n              return true;\n       }\n       Abel diff(int x, int y) {\n              return weight(y) - weight(x);\n       }\n};\nint main() {\n       int N, M;\n       while (cin >> N >> M) {\n              if (N == 0) break;\n              UnionFind<int> uf(N);\n              for (int i = 0; i < M; ++i) {\n                     char c; int a, b, w;\n                     cin >> c;\n                     if (c == '!') {\n                           cin >> a >> b >> w; --a, --b;\n                           uf.merge(a, b, w);\n                     }\n                     else {\n                           cin >> a >> b; --a, --b;\n                           if (!uf.issame(a, b)) puts(\"UNKNOWN\");\n                           else cout << uf.diff(a, b) << endl;\n                     }\n              }\n       }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <vector>\n#include <queue>\n#include <algorithm>\n\nusing namespace std;\n\n//FILE *in = freopen(\"input.txt\", \"r\", stdin);\n//FILE *out = freopen(\"output.txt\", \"w\", stdout);\n\nint n, m;\n\nstruct UnionFind {\n\tvector<int> par; vector<int> rank;\n\tUnionFind(int n){\n\t\tpar = vector<int>(n);\n\t\trank = vector<int>(n);\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tpar[i] = i;\n\t\t}\n\t}\n\tint find(int x) {\n\t\tif(par[x]==x) return x;\n\t\telse return find(par[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif(x == y) return;\n\t\tif(rank[x]<rank[y])\n\t\t\tpar[x] = y;\n\t\telse {\n\t\t\tpar[y] = x;\n\t\t\tif(rank[x]==rank[y])rank[x]++;\n\t\t}\n\t}\n\tinline bool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n};\n\nint bfs(vector<vector<pair<int,int>>> data, int a, int b) {\n\tbool chk[100001];\n\tmemset(chk, 0, sizeof(chk));\n\tqueue<pair<int,int>> que;\n\tque.push(make_pair(a, 0));\n\tchk[a] = true;\n\twhile(!que.empty()){\n\t\tint cur = que.front().first;\n\t\tint val = que.front().second;\n\t\tque.pop();\n\t\tif(cur == b)\n\t\t\treturn val;\n\n\t\tfor(int i = 0; i < data[cur].size(); i++) {\n\t\t\tif(chk[data[cur][i].first]) continue;\n\t\t\tchk[data[cur][i].first] = true;\n\t\t\tque.push(make_pair(data[cur][i].first, val + data[cur][i].second));\n\t\t}\n\t}\n\treturn -1;\n}\n\nvoid process() {\n\tUnionFind uf(n+1);\n\tvector<vector<pair<int,int>>> data(n+1);\n\tchar tt[10];\n\tint a, b, c;\n\tfor(int k = 0; k < m; k++) {\n\t\tscanf(\"%s%d%d\", tt, &a, &b);\n\t\tif(tt[0] == '!') {\n\t\t\tscanf(\"%d\", &c);\n\t\t\tif(uf.same(a,b)) continue;\n\t\t\tdata[a].push_back(make_pair(b, c));\n\t\t\tdata[b].push_back(make_pair(a, -c));\n\t\t\tuf.unite(a,b);\n\t\t}\n\t\telse {\n\t\t\tif(!uf.same(a, b)) {\n\t\t\t\tprintf(\"UNKNOWN\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tprintf(\"%d\\n\", bfs(data, a, b));\n\t\t}\n\t}\n}\n\nint main() {\n\twhile(true){\n\t\tscanf(\"%d%d\", &n, &m);\n\t\tif(!n)break;\n\t\tprocess();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n\nusing namespace std;\n\ntypedef long long LL;\nstruct Node {\n    int root;\n    LL diff;\n};\n\nint root(int n, vector<Node> &nodes) {\n    if(nodes[n].root == n) return n;\n    const int r = root(nodes[n].root, nodes);\n    nodes[n].diff += nodes[nodes[n].root].diff;\n    return nodes[n].root = r;\n}\n\nbool unite(int a, int b, vector<Node> &nodes, LL w) {\n    const int ra = root(a, nodes);\n    const int rb = root(b, nodes);\n    if(nodes[ra].root == nodes[rb].root) return false;\n    nodes[ra].root = nodes[rb].root;\n    nodes[ra].diff = w - nodes[a].diff + nodes[b].diff;\n    return true;\n}\n\nbool solve() {\n    int N, M;\n    cin >> N >> M;\n    if(!N && !M) return false;\n\n    vector<Node> nodes(N);\n    for(int i = 0; i < N; ++i) {\n        nodes[i].root = i;\n        nodes[i].diff = 0;\n    }\n    for(int i = 0; i < M; ++i) {\n        string cmd;\n        cin >> cmd;\n        if(cmd == \"!\") {\n            int a, b, w;\n            cin >> a >> b >> w;\n            --a; --b;\n            unite(a, b, nodes, w);\n        } else {\n            int a, b;\n            cin >> a >> b;\n            --a; --b;\n            root(a, nodes);\n            root(b, nodes);\n            if(nodes[a].root != nodes[b].root) {\n                cout << \"UNKNOWN\" << endl;\n            } else {\n                const LL diff = nodes[a].diff - nodes[b].diff;\n                cout << diff << endl;\n            }\n        }\n    }\n    return true;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n\n    while(solve()) ;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct UnionFind {\n    int node[100010], weight[100010];\n    UnionFind() {\n        memset(node, -1, sizeof(node));\n        memset(weight, 0, sizeof(weight));\n    }\n    void unite(int u, int v, int w) {\n        // printf(\"(u, v) = (%d, %d)\\n\", u, v);\n        // printf(\"find(u, v) = (%d, %d)\\n\", find(u), find(v));\n        if(find(u) == find(v)) return;\n        if(find(u) > find(v)) swap(u, v), w *= -1;\n        int new_weight = get_weight(u);\n\n        // printf(\"new_weight = %d\\n\", new_weight);\n        // v ????????? (u ??????) ???????????????\n        u = find(u);\n        node[u] += node[v];\n        node[v] = u;\n        weight[v] += new_weight + w;\n    }\n\n    int get_weight(int u) {\n        int ret = 0;\n        for(; node[u] >= 0; u = node[u]) {\n            if(u < 0) break;\n            ret += weight[u];\n        }\n        return ret;\n    }\n\n    int find(int u) {\n        return (node[u] < 0 ? u : node[u] = find(node[u]));\n    }\n};\n\nint main() {\n    int N, M;\n    while(cin >> N >> M, N) {\n        UnionFind uf;\n        for(int i=0; i<M; i++) {\n            char c; cin >> c;\n            if(c == '!') {\n                int a, b, d; cin >> a >> b >> d;\n                a--; b--;\n                uf.unite(a, b, d);\n            }\n            else {\n                int a, b; cin >> a >> b;\n                a--; b--;\n                if(uf.find(a) != uf.find(b)) cout << \"UNKNOWN\" << endl;\n                else {\n                    int wa = uf.weight[a];\n                    int wb = uf.weight[b];\n                    // printf(\"wa = %d, wb = %d\\n\", wa, wb);\n                    cout << wb - wa << endl;\n                }\n            }\n        }\n        for(int i=0; i<N; i++) {\n            // printf(\"parent[%d] = %d, weight[%d] = %d\\n\", i, uf.node[i], i, uf.weight[i]);\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\n#define frs first\n#define scn second\n#define mkp make_pair\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair< int, ll > Pr;\n\nint N, M;\nPr nset[100010];\n\nvoid soups_on();\nvoid union_set(int, int, ll);\nPr find_set(int);\n\nint main() {\n  ios::sync_with_stdio(false);\n  while (cin >> N >> M, N + M)\n    soups_on();\n\n  return 0;\n}\n\nvoid soups_on() {\n  char c;\n  int a, b;\n  ll w;\n\n  fill(&nset[0], &nset[N + 1], mkp(-1, 0));\n  for (int i = 0; i < M; ++i) {\n    cin >> c >> a >> b;\n    if (c == '!') {\n      cin >> w;\n      union_set(a, b, w);\n    }\n    else {\n      Pr pa = find_set(a), pb = find_set(b);\n      if (pa.frs == pb.frs)\n        cout << pa.scn - pb.scn << \"\\n\";\n      else\n        cout << \"UNKNOWN\\n\";\n    }\n  }\n}\n\nvoid union_set(int x, int y, ll w) {\n  if (find_set(x).frs != find_set(y).frs) {\n    Pr px = find_set(x), py = find_set(y);\n    nset[py.frs] = mkp(px.frs, -w + px.scn - py.scn);\n  }\n}\n\nPr find_set(int x) {\n  if (nset[x].frs == -1)\n    return mkp(x, 0);\n  else {\n    Pr px = find_set(nset[x].frs);\n    return nset[x] = mkp(px.frs, nset[x].scn + px.scn);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<bitset>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n\nclass union_find{\nprivate:\n\tvector<int> parents;\n\tvector<int> weight;\npublic:\n\tunion_find(int n){\n\t\tfor(int i=0;i<n;i++){\n\t\t\tparents.push_back(i);\n\t\t\trank.push_back(0);\n\t\t\tweight.push_back(0);\n\t\t}\n\t}\n\tint find(int x){\n\t\tif(parents[x]==x){\n\t\t\treturn x;\n\t\t}else{\n\t\t\tint tmp=find(parents[x]);\n\t\t\tweight[x]=weight[x]+weight[parents[x]];\n\t\t\treturn parents[x]=tmp;\n\t\t}\n\t}\n\tvoid unite(int x,int y,int w){\n\t\tint tmpx=find(x);\n\t\tint tmpy=find(y);\n\t\tif(tmpx==tmpy)return;\n\t\tweight[tmpx]=w-weight[x]+weight[y];\n\t\tparents[tmpx]=tmpy;\n\t}\n\tint get_weight(int x,int y){\n\t\tif(find(x)==find(y)){\n\t\t\treturn weight[x]-weight[y];\n\t\t}else{\n\t\t\treturn -2000000;\n\t\t}\n\t}\n};\nint main(){\n\tchar c;\n\tint a,b,w;\n\tint n,m;\n\twhile(cin>>n>>m,n!=0||m!=0){\n\t\tunion_find uf(n+1);\n\t\tfor(int i=0;i<m;i++){\n\t\t\tcin>>c;\n\t\t\tif(c=='!'){\n\t\t\t\tcin>>a>>b>>w;\n\t\t\t\tuf.unite(a,b,w);\n\t\t\t}else if(c=='?'){\n\t\t\t\tcin>>a>>b;\n\t\t\t\tint tmp=uf.get_weight(a,b);\n\t\t\t\tif(tmp!=-2000000){\n\t\t\t\t\tcout<<tmp<<endl;\n\t\t\t\t}else{\n\t\t\t\t\tcout<<\"UNKNOWN\"<<endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n\nusing namespace std;\nint weight[10000];\n\nclass DisjointSet{\npublic:\n  vector<int> rank,p;\n\n  DisjointSet(){}\n  DisjointSet(int size){\n    rank.resize(size,0);\n    p.resize(size,0);\n    for(int i=0;i<size;i++){\n      makeSet(i);\n      weight[i]=0;\n    }\n  }\n\n  void makeSet(int x){\n    p[x]=x;\n    rank[x]=0;\n  }\n  bool same(int x,int y){\n    return findSet(x)==findSet(y);\n  }\n  void unite(int x,int y,int w){\n    weight[x]=w;\n    link(x,y);\n  }\n  void link(int x,int y){   \n    p[x]=y;\n    if(rank[x]==rank[y]){  \n      rank[y]++;\n    }else if(rank[x]>rank[y]){\n      rank[y]=rank[x]+1;\n    }\n  }\n  int findSet(int x){\n    if(x==p[x]){\n      return x;\n    }else{\n      return findSet(p[x]);\n    }\n  }\n  int depth(int x){\n    int ans=0;\n    ans+=weight[x];\n    while(x!=p[x]){\n      ans+=weight[p[x]];\n      x=p[x];\n    }\n    return ans;\n  }\n};\nint main(){\n  int n,m;\n  while(scanf(\"%d%d\",&n,&m)){\n    string query;\n    DisjointSet ds=DisjointSet(n);\n    for(int i=0;i<m;i++){\n      cin>>query;\n      if(query==\"!\"){\n        int a,b,w;\n        scanf(\"%d%d%d\",&a,&b,&w);\n        ds.unite(a,b,w);\n      }else{\n        int c,d;\n        scanf(\"%d%d\",&c,&d);\n        if(!ds.same(c,d)){\n       \t  printf(\"UNKNOWN\\n\");\n        }else{\n          printf(\"%d\\n\",ds.depth(c)-ds.depth(d));\n        }\n      }\n    }\n  }\n  return 0;\n}\n      "
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <array>\n#include <bitset>\n#include <cassert>\n#include <cfloat>\n#include <cmath>\n#include <cstdint>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <forward_list>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <regex>\n#include <set>\n#include <stack>\n#include <string>\n#include <tuple>\n#include <type_traits>\n#include <unordered_map>\n#include <unordered_set>\n#include <utility>\n#include <vector>\n#ifdef DEBUG\n#include <fmt/format.h>\n#include <fmt/ostream.h>\n#endif\nusing namespace std;\nusing i8 = int8_t;\nusing u8 = uint8_t;\nusing i16 = int16_t;\nusing u16 = uint16_t;\nusing i32 = int32_t;\nusing u32 = uint32_t;\nusing i64 = int64_t;\nusing u64 = uint64_t;\ntemplate<typename T>\nusing max_heap = priority_queue<T, vector<T>, less<T>>;\ntemplate<typename T>\nusing min_heap = priority_queue<T, vector<T>, greater<T>>;\n#ifdef __clang__\n#pragma clang diagnostic push\n#pragma clang diagnostic ignored \"-Wunused-const-variable\"\n#endif\nconstexpr bool AUTOFLUSH = false;\nconstexpr bool STDIO_ENABLE = false;\nconstexpr int IOS_PREC = 12;\nconstexpr int INF_I32 = 1'010'000'000;\nconstexpr i64 INF_I64 = 1'010'000'000'000'000'000LL;\nconstexpr auto INF = INF_I64;\nconstexpr double EPS = 1e-12;\nconstexpr i64 MOD = 1'000'000'007;\n#ifdef __clang__\n#pragma clang diagnostic pop\n#endif\nconstexpr i32 I32_MAX = numeric_limits<i32>::max();\nconstexpr i32 I32_MIN = numeric_limits<i32>::min();\nconstexpr i64 I64_MAX = numeric_limits<i64>::max();\nconstexpr i64 I64_MIN = numeric_limits<i64>::min();\ntemplate<typename T, size_t N, size_t... NS>\nstruct ArrayStruct {\n using type = array<typename ArrayStruct<T,NS...>::type,N>;\n};\ntemplate<typename T, size_t N>\nstruct ArrayStruct<T,N> {\n using type = array<T,N>;\n};\ntemplate<typename T, size_t N, size_t... NS>\nusing Array = typename ArrayStruct<T,N,NS...>::type;\ntemplate<typename T>\nint GETBIT(T x, int i) {\n return (x>>i) & 1;\n}\ntemplate<typename T>\nvoid SETBIT(T& x, int i) {\n x |= (T(1)<<i);\n}\ntemplate<typename T>\nvoid CLEARBIT(T& x, int i) {\n x &= ~(T(1)<<i);\n}\ntemplate<typename T>\nconstexpr T ABS(T x) {\n static_assert(is_signed<T>::value, \"ABS(): argument must be signed\");\n return x < 0 ? -x : x;\n}\ntemplate<typename T>\nconstexpr T abs_diff(T x, T y) {\n return x < y ? y-x : x-y;\n}\nconstexpr i64 MID(i64 x, i64 y) {\n i64 lo = min(x, y);\n i64 hi = max(x, y);\n return (lo < 0 && hi >= 0) ? (lo+hi)/2 : lo + (hi-lo)/2;\n}\ntemplate<typename Pred>\ni64 bin_search(i64 lo, i64 hi, Pred pred) {\n assert(lo < hi);\n while(lo+1 < hi) {\n i64 mid = MID(lo, hi);\n if(pred(mid))\n lo = mid;\n else\n hi = mid;\n }\n return lo;\n}\ntemplate<typename Pred>\ndouble bin_search_real(double lo, double hi, Pred pred, int iter=100) {\n assert(lo < hi);\n for(int i = 0; i < iter; ++i) {\n double mid = (lo+hi) / 2.0;\n if(pred(mid))\n lo = mid;\n else\n hi = mid;\n }\n return lo;\n}\ntemplate<typename T>\nconstexpr bool is_odd(T x) {\n return x % 2 != 0;\n}\ntemplate<typename T>\nconstexpr bool is_even(T x) {\n return x % 2 == 0;\n}\ntemplate<typename T>\nconstexpr bool parity_same(T x, T y) {\n return (is_odd(x) && is_odd(y)) || (is_even(x) && is_even(y));\n}\ntemplate<typename T>\nconstexpr int cmp(T x, T y) {\n return (y < x) - (x < y);\n}\ntemplate<typename T>\nconstexpr int sgn(T x) {\n return cmp(x, T(0));\n}\ntemplate<typename T>\nconstexpr T ipow(T a, T b) {\n assert(b >= 0);\n T res(1);\n for(T i = 0; i < b; ++i)\n res *= a;\n return res;\n}\ntemplate<\n typename T,\n std::enable_if_t<\n std::is_integral<T>::value &&\n std::is_signed<T>::value, std::nullptr_t> = nullptr>\nconstexpr T div_ceil(T a, T b) {\n return a/b + (((a<0)^(b>0)) && (a%b));\n}\ntemplate<\n typename T,\n std::enable_if_t<\n std::is_integral<T>::value &&\n std::is_unsigned<T>::value, std::nullptr_t> = nullptr>\nconstexpr T div_ceil(T a, T b) {\n return a/b + !!(a%b);\n}\ntemplate<\n typename T,\n std::enable_if_t<\n std::is_integral<T>::value &&\n std::is_signed<T>::value, std::nullptr_t> = nullptr>\nconstexpr T div_floor(T a, T b) {\n return a/b - (((a>0)^(b>0)) && (a%b));\n}\ntemplate<\n typename T,\n std::enable_if_t<\n std::is_integral<T>::value &&\n std::is_unsigned<T>::value, std::nullptr_t> = nullptr>\nconstexpr T div_floor(T a, T b) {\n return a/b;\n}\ntemplate<typename T, typename U>\nconstexpr auto modulo(T a, U b) {\n using R = common_type_t<T,U>;\n assert(0 < b);\n R r = a % b;\n return r >= 0 ? r : r+b;\n}\ntemplate<typename T>\nconstexpr T clamp(T x, T lo, T hi) {\n assert(lo <= hi);\n if(x < lo)\n return lo;\n else if(hi < x)\n return hi;\n else\n return x;\n}\ni64 isqrt(i64 x) {\n assert(x >= 0);\n i64 lo = 0;\n i64 hi = 3037000500LL;\n return bin_search(lo, hi, [x](i64 r) { return r*r <= x; });\n}\ntemplate<typename T, typename U>\nbool chmax(T& xmax, const U& x) {\n if(xmax < x) {\n xmax = x;\n return true;\n }\n else {\n return false;\n }\n}\ntemplate<typename T, typename U>\nbool chmin(T& xmin, const U& x) {\n if(x < xmin) {\n xmin = x;\n return true;\n }\n else {\n return false;\n }\n}\ntemplate<typename T>\nconstexpr int SIZE(const T& c) {\n return static_cast<int>(c.size());\n}\ntemplate<typename T, size_t N>\nconstexpr int SIZE(const T (&)[N]) {\n return static_cast<int>(N);\n}\ntemplate<typename InputIt, typename T>\nint argfind(InputIt first, InputIt last, const T& x) {\n auto it = find(first, last, x);\n return distance(first, it);\n}\ntemplate<typename InputIt>\nint argmax(InputIt first, InputIt last) {\n auto it = max_element(first, last);\n return distance(first, it);\n}\ntemplate<typename InputIt>\nint argmin(InputIt first, InputIt last) {\n auto it = min_element(first, last);\n return distance(first, it);\n}\ntemplate<typename InputIt>\nbool alltrue(InputIt first, InputIt last) {\n return all_of(first, last, [](bool b) { return b; });\n}\ntemplate<typename InputIt>\nbool anytrue(InputIt first, InputIt last) {\n return any_of(first, last, [](bool b) { return b; });\n}\ntemplate<typename InputIt>\nbool allfalse(InputIt first, InputIt last) {\n return !anytrue(first, last);\n}\ntemplate<typename InputIt>\nbool anyfalse(InputIt first, InputIt last) {\n return !alltrue(first, last);\n}\ntemplate<typename T>\narray<pair<T,T>,4> neighbor4(const T& x, const T& y) {\n return array<pair<T,T>,4> {{\n { x, y-1 },\n { x-1, y }, { x+1, y },\n { x, y+1 },\n }};\n}\ntemplate<typename T>\narray<pair<T,T>,8> neighbor8(const T& x, const T& y) {\n return array<pair<T,T>,8> {{\n { x-1, y-1 }, { x, y-1 }, { x+1, y-1 },\n { x-1, y }, { x+1, y },\n { x-1, y+1 }, { x, y+1 }, { x+1, y+1 },\n }};\n}\ntemplate<typename T>\nbool in_bounds(const T& x, const T& minx, const T& maxx) {\n return !(x < minx) && !(maxx < x);\n}\ntemplate<typename T>\nbool in_bounds_2(\n const T& x, const T& y,\n const T& minx, const T& miny,\n const T& maxx, const T& maxy) {\n return in_bounds(x, minx, maxx) && in_bounds(y, miny, maxy);\n}\ntemplate<typename T>\nbool in_bounds_wh(const T& x, const T& y, const T& w, const T& h) {\n return in_bounds_2(x, y, 0, 0, w-1, h-1);\n}\nstruct pairhash {\n template<typename T1, typename T2>\n size_t operator()(const pair<T1,T2>& p) const {\n size_t res = 17;\n res = 31*res + hash<T1>()(p.first);\n res = 31*res + hash<T2>()(p.second);\n return res;\n }\n};\nstruct vectorhash {\n template<typename T>\n size_t operator()(const vector<T>& v) const {\n size_t res = 17;\n res = 31*res + hash<size_t>()(v.size());\n for(const auto& e : v) {\n res = 31*res + hash<T>()(e);\n }\n return res;\n }\n};\ntemplate<typename K, typename V>\npair<typename map<K,V>::iterator, bool> insert_or_assign(map<K,V>& m, const K& k, const V& v) {\n auto it = m.lower_bound(k);\n if(it != end(m) && !m.key_comp()(k,it->first)) {\n it->second = v;\n return make_pair(it, false);\n }\n else {\n auto it_ins = m.insert(it, make_pair(k,v));\n return make_pair(it_ins, true);\n }\n}\ntemplate<typename K, typename V>\npair<typename unordered_map<K,V>::iterator, bool>\ninsert_or_assign(unordered_map<K,V>& m, const K& k, const V& v) {\n auto it = m.find(k);\n if(it != end(m)) {\n it->second = v;\n return make_pair(it, false);\n }\n else {\n auto it_ins = m.insert(it, make_pair(k,v));\n return make_pair(it_ins, true);\n }\n}\ntemplate<typename T>\nstring TO_STRING(const T& x) {\n ostringstream out;\n out << x;\n return out.str();\n}\ntemplate<typename InputIt>\nstring JOIN(InputIt first, InputIt last, const string& sep) {\n ostringstream out;\n while(first != last) {\n out << *first++;\n if(first != last)\n out << sep;\n }\n return out.str();\n}\ntemplate<typename InputIt>\nauto SUM(InputIt first, InputIt last) {\n using T = typename iterator_traits<InputIt>::value_type;\n return accumulate(first, last, T());\n}\ntemplate<typename T>\nvoid UNIQ(T& c) {\n c.erase(unique(begin(c), end(c)), end(c));\n}\ntemplate<typename T>\nvoid RD(T& x) {\n cin >> x;\n#ifdef DEBUG\n if(!cin) assert(false);\n#endif\n}\ntemplate<typename T>\nvoid RD(vector<T>& v, int n) {\n v.reserve(n);\n for(int i = 0; i < n; ++i) {\n T e; RD(e);\n v.emplace_back(e);\n }\n}\ntemplate<typename InputIt>\nostream& FPRINTSEQ(ostream& out, InputIt first, InputIt last) {\n for(InputIt it = first; it != last; ++it) {\n if(it != first) out << ' ';\n out << *it;\n }\n return out;\n}\ntemplate<typename InputIt>\nostream& PRINTSEQ(InputIt first, InputIt last) {\n return FPRINTSEQ(cout, first, last);\n}\ntemplate<typename InputIt>\nostream& DPRINTSEQ(InputIt first, InputIt last) {\n#ifdef DEBUG\n FPRINTSEQ(cerr, first, last);\n#endif\n return cerr;\n}\ntemplate<typename T, size_t N>\nostream& FPRINTARRAY1(ostream& out, const T (&c)[N]) {\n return FPRINTSEQ(out, cbegin(c), cend(c));\n}\ntemplate<typename T, size_t N>\nostream& PRINTARRAY1(const T (&c)[N]) {\n return FPRINTARRAY1(cout, c);\n}\ntemplate<typename T, size_t N>\nostream& DPRINTARRAY1(const T (&c)[N]) {\n#ifdef DEBUG\n FPRINTARRAY1(cerr, c);\n#endif\n return cerr;\n}\ntemplate<typename T, size_t N1, size_t N2>\nostream& FPRINTARRAY2(ostream& out, const T (&c)[N1][N2]) {\n out << '\\n';\n for(const auto& e : c) {\n FPRINTARRAY1(out, e) << '\\n';\n }\n return out;\n}\ntemplate<typename T, size_t N1, size_t N2>\nostream& PRINTARRAY2(const T (&c)[N1][N2]) {\n return FPRINTARRAY2(cout, c);\n}\ntemplate<typename T, size_t N1, size_t N2>\nostream& DPRINTARRAY2(const T (&c)[N1][N2]) {\n#ifdef DEBUG\n FPRINTARRAY2(cerr, c);\n#endif\n return cerr;\n}\ntemplate<typename T>\nostream& operator<<(ostream& out, const vector<T>& c) {\n return FPRINTSEQ(out, cbegin(c), cend(c));\n}\ntemplate<typename T>\nostream& operator<<(ostream& out, const vector<vector<T>>& c) {\n out << '\\n';\n for(const auto& e : c) {\n out << e << '\\n';\n }\n return out;\n}\nostream& operator<<(ostream& out, const vector<string>& c) {\n out << '\\n';\n for(const string& e : c) {\n out << e << '\\n';\n }\n return out;\n}\ntemplate<typename T>\nostream& operator<<(ostream& out, const deque<T>& c) {\n return FPRINTSEQ(out, cbegin(c), cend(c));\n}\ntemplate<typename T>\nostream& operator<<(ostream& out, const list<T>& c) {\n return FPRINTSEQ(out, cbegin(c), cend(c));\n}\ntemplate<typename T>\nostream& operator<<(ostream& out, const forward_list<T>& c) {\n return FPRINTSEQ(out, cbegin(c), cend(c));\n}\ntemplate<typename T>\nostream& operator<<(ostream& out, const set<T>& c) {\n return FPRINTSEQ(out, cbegin(c), cend(c));\n}\ntemplate<typename T>\nostream& operator<<(ostream& out, const unordered_set<T>& c) {\n return out << set<T>(cbegin(c), cend(c));\n}\ntemplate<typename T>\nostream& operator<<(ostream& out, const multiset<T>& c) {\n return FPRINTSEQ(out, cbegin(c), cend(c));\n}\ntemplate<typename T>\nostream& operator<<(ostream& out, const unordered_multiset<T>& c) {\n return out << multiset<T>(cbegin(c), cend(c));\n}\ntemplate<typename T, size_t N>\nostream& operator<<(ostream& out, const array<T,N>& c) {\n return FPRINTSEQ(out, cbegin(c), cend(c));\n}\ntemplate<typename InputIt>\nostream& FPRINTMAP(ostream& out, InputIt first, InputIt last) {\n out << \"{\\n\";\n for(auto it = first; it != last; ++it) {\n out << \"  \" << it->first << \" : \" << it->second << '\\n';\n }\n out << \"}\\n\";\n return out;\n}\ntemplate<typename InputIt>\nostream& PRINTMAP(InputIt first, InputIt last) {\n return FPRINTMAP(cout, first, last);\n}\ntemplate<typename InputIt>\nostream& DPRINTMAP(InputIt first, InputIt last) {\n#ifdef DEBUG\n FPRINTMAP(cerr, first, last);\n#endif\n return cerr;\n}\ntemplate<typename K, typename V>\nostream& operator<<(ostream& out, const map<K,V>& c) {\n return FPRINTMAP(out, cbegin(c), cend(c));\n}\ntemplate<typename K, typename V>\nostream& operator<<(ostream& out, const unordered_map<K,V>& c) {\n return out << map<K,V>(cbegin(c), cend(c));\n}\ntemplate<typename K, typename V>\nostream& operator<<(ostream& out, const multimap<K,V>& c) {\n return FPRINTMAP(out, cbegin(c), cend(c));\n}\ntemplate<typename K, typename V>\nostream& operator<<(ostream& out, const unordered_multimap<K,V>& c) {\n return out << multimap<K,V>(cbegin(c), cend(c));\n}\ntemplate<typename T, typename C>\nostream& operator<<(ostream& out, stack<T,C> c) {\n while(!c.empty()) {\n out << c.top();\n c.pop();\n if(!c.empty()) out << ' ';\n }\n return out;\n}\ntemplate<typename T, typename C>\nostream& operator<<(ostream& out, queue<T,C> c) {\n while(!c.empty()) {\n out << c.front();\n c.pop();\n if(!c.empty()) out << ' ';\n }\n return out;\n}\ntemplate<typename T, typename Cont, typename Cmp>\nostream& operator<<(ostream& out, priority_queue<T,Cont,Cmp> c) {\n while(!c.empty()) {\n out << c.top();\n c.pop();\n if(!c.empty()) out << ' ';\n }\n return out;\n}\ntemplate<typename T1, typename T2>\nostream& operator<<(ostream& out, const pair<T1,T2>& p) {\n return out << '(' << p.first << ',' << p.second << ')';\n}\ntemplate<typename Tuple, size_t Pos>\nostream& FPRINTTUPLE(ostream& out, const Tuple&) {\n return out;\n}\ntemplate<typename Tuple, size_t Pos, typename T, typename... TS>\nostream& FPRINTTUPLE(ostream& out, const Tuple& t) {\n if(Pos != 0)\n out << ',';\n out << get<Pos>(t);\n return FPRINTTUPLE<Tuple,Pos+1,TS...>(out, t);\n}\ntemplate<typename... TS>\nostream& operator<<(ostream& out, const tuple<TS...>& t) {\n out << '(';\n FPRINTTUPLE<tuple<TS...>,0,TS...>(out, t);\n out << ')';\n return out;\n}\nostream& FPRINT(ostream& out) { return out; }\ntemplate<typename T, typename... TS>\nostream& FPRINT(ostream& out, const T& x, const TS& ...args) {\n out << x;\n if(sizeof...(args))\n out << ' ';\n return FPRINT(out, args...);\n}\ntemplate<typename... TS>\nostream& FPRINTLN(ostream& out, const TS& ...args) {\n FPRINT(out, args...);\n return out << '\\n';\n}\ntemplate<typename... TS>\nostream& PRINT(const TS& ...args) {\n return FPRINT(cout, args...);\n}\ntemplate<typename... TS>\nostream& PRINTLN(const TS& ...args) {\n return FPRINTLN(cout, args...);\n}\ntemplate<typename... TS>\nostream& DPRINT(const TS& ...args) {\n#ifdef DEBUG\n FPRINT(cerr, args...);\n#endif\n return cerr;\n}\ntemplate<typename... TS>\nostream& DPRINTLN(const TS& ...args) {\n#ifdef DEBUG\n FPRINTLN(cerr, args...);\n#endif\n return cerr;\n}\nvoid FLUSH() {\n if(STDIO_ENABLE)\n fflush(stdout);\n else\n cout.flush();\n}\n[[noreturn]] void EXIT() {\n#ifdef DEBUG\n fflush(stdout);\n fflush(stderr);\n cout.flush();\n cerr.flush();\n#else\n FLUSH();\n#endif\n _Exit(0);\n}\nstruct IoInit {\n IoInit() {\n#ifndef DEBUG\n cin.tie(nullptr);\n if(!STDIO_ENABLE)\n ios::sync_with_stdio(false);\n#endif\n cout << fixed << setprecision(IOS_PREC);\n if(AUTOFLUSH) {\n if(STDIO_ENABLE)\n setvbuf(stdout, nullptr, _IONBF, 0);\n cout << unitbuf;\n }\n }\n} IOINIT;\n#define FOR(i,start,end) for(i64 i = (start); i < (end); ++i)\n#define REP(i,n) FOR(i, 0, n)\n#define ALL(f,c,...) (([&](decltype((c)) cc) { return (f)(begin(cc), end(cc), ## __VA_ARGS__); })(c))\n#define GENERIC(f) ([](auto&&... args) -> decltype(auto) { return (f)(forward<decltype(args)>(args)...); })\n#define MEMSET(a,v) memset((a), (v), sizeof(a))\n#define DBG(x) DPRINTLN('L', __LINE__, ':', #x, ':', (x))\nclass WeightedUnionFind {\npublic:\n vector<i64> p;\n vector<i64> w;\n i64 n_set;\n WeightedUnionFind(i64 n) : p(n, -1), w(n, 0), n_set(n) {}\n i64 node_count() const { return SIZE(p); }\n i64 set_count() const { return n_set; }\n i64 set_size(i64 x) { return -p[root(x)]; }\n bool is_root(i64 x) const { return p[x] < 0; }\n i64 root(i64 x) {\n i64 res; tie(res,ignore) = compress(x);\n return res;\n }\n i64 weight(i64 x) {\n i64 res; tie(ignore,res) = compress(x);\n return res;\n }\n bool unite(i64 x, i64 y, i64 d) {\n i64 rx = root(x);\n i64 ry = root(y);\n i64 wx = weight(x);\n i64 wy = weight(y);\n if(rx == ry) {\n return wx + d == wy;\n }\n if(set_size(rx) < set_size(ry)) {\n swap(rx, ry);\n swap(wx, wy);\n d *= -1;\n }\n p[rx] += p[ry];\n p[ry] = rx;\n w[ry] = wx - wy + d;\n return true;\n }\n bool same(i64 x, i64 y) {\n return root(x) == root(y);\n }\nprivate:\n tuple<i64,i64> compress(i64 x) {\n if(is_root(x)) return { x, 0 };\n i64 r,d; tie(r,d) = compress(p[x]);\n p[x] = r;\n w[x] += d;\n return { r, w[x] };\n }\n};\nvoid solve(i64 N, i64 M) {\n WeightedUnionFind uf(N);\n REP(_, M) {\n char c; RD(c);\n i64 a,b; RD(a); RD(b); --a; --b;\n if(c == '!') {\n i64 w; RD(w);\n if(!uf.unite(a, b, w)) {\n assert(false);\n }\n }\n else if(c == '?') {\n if(!uf.same(a, b)) {\n PRINTLN(\"UNKNOWN\");\n }\n else {\n i64 ans = uf.weight(b) - uf.weight(a);\n PRINTLN(ans);\n }\n }\n else {\n assert(false);\n }\n }\n}\nsigned main(signed , char** ) {\n while(true) {\n i64 N, M; RD(N); RD(M);\n if(N == 0 && M == 0) break;\n solve(N, M);\n }\n EXIT();\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nclass UnionFind {\nprivate:\n\tvector<int> parent;\n\tvector<ll> weight;\n\npublic:\n\tUnionFind(int n) {\n\t\tparent.resize(n);\n\t\tfor (int i = 0; i < n; ++i) parent[i] = i;\n\t\tweight = vector<ll>(n, 0);\n\t}\n\tvoid unite(int a, int b, int w) {\n\t\tint ra = root(a), rb = root(b);\n\t\tparent[ra] = rb;\n\t\tweight[ra] = w - weight[a] + weight[b];\n\t}\n\tint root(int n) {\n\t\tif (parent[n] == n) return n;\n\t\telse {\n\t\t\tint res = root(parent[n]);\n\t\t\tweight[n] += weight[parent[n]];\n\t\t\tparent[n] = res;\n\t\t\treturn res;\n\t\t}\n\t}\n\tll getWeight(int n) {\n\t\treturn weight[root(n)] + weight[n];\n\t}\n\tbool isUnited(int a, int b) {\n\t\treturn root(a) == root(b);\n\t}\n};\n\nint main() {\n\tint N, M;\n\twhile ( cin >> N >> M, N || M ) {\n\t\tUnionFind uf(N);\n\t\tfor (int q = 0; q < M; ++q) {\n\t\t\tchar c; cin >> c;\n\t\t\tif (c == '!') {\n\t\t\t\tint a, b, dw; cin >> a >> b >> dw; --a, --b;\n\t\t\t\tuf.unite(a, b, dw);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tint a, b; cin >> a >> b; --a, --b;\n\t\t\t\tif (uf.isUnited(a, b)) cout << uf.getWeight(a)-uf.getWeight(b) << endl;\n\t\t\t\telse cout << \"UNKNOWN\" << endl;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cmath>\n#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <memory>\n#include <cstring>\n#include <cassert>\n#include <numeric>\n#include <sstream>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <cctype>\n#include <unordered_map>\n#include <unordered_set>\nusing namespace std;\n\n#define REP2(i, m, n) for (int i = (int)(m); i < (int)(n); i++)\n#define REP(i, n) REP2(i, 0, n)\n#define ALL(S) (S).begin(), (S).end()\ntypedef long long ll;\n\nclass UnionFind{\n  int num_components;\n  std::vector<int> parent;\n  std::vector<int> weight;\n  std::vector<int> rank;\npublic:\n  UnionFind(int N) : num_components(N),\n                     parent(std::vector<int>(N)),\n                     weight(std::vector<int>(N, 1)),\n                     rank(std::vector<int>(N, 0)){\n    for(int i = 0; i < N; i++) parent[i] = i;\n  }\n  \n  int find(int x){\n    if(x == parent[x]) return x;\n    else return parent[x] = find(parent[x]);\n  }\n  \n  int size(int x){\n    return weight[find(x)];\n  }\n  \n  \n  bool same(int x, int y){\n    return find(x) == find(y);\n  }\n    \n  void unite(int x, int y){\n    x = find(x);\n    y = find(y);\n    if(x == y) return;\n    \n    num_components--;\n    if(rank[x] < rank[y]){\n      weight[y] += weight[x];\n      parent[x] = y;\n    }else{\n      weight[x] += weight[y];\n      parent[y] = x;\n      if(rank[x] == rank[y]) rank[y]++;\n    }\n  }\n  \n  int count(){\n    return num_components;\n  }\n};\n\nint main(){\n  ios::sync_with_stdio(false);\n\n  int n, m;\n  while (cin >> n >> m && n + m){\n    UnionFind  union_find(n);\n    vector<ll> diff(n);\n    vector<vector<pair<int, int> > > G(n);\n    \n    REP(i, m){\n      char op;\n      int a, b, w;\n      cin >> op >> a >> b; a--, b--;\n\n      if (op == '?'){\n        if (union_find.same(a, b)){\n          cout << diff[b] - diff[a] << endl;\n        } else {\n          cout << \"UNKNOWN\" << endl;\n        }\n        \n      } else {\n        cin >> w;\n        if (union_find.same(a, b)) {\n          continue;\n        }\n\n        int start_vertex = union_find.size(a) > union_find.size(b) ? b : a;\n        int start_weight = start_vertex == a ? diff[b] - w : diff[a] + w;\n\n        diff[start_vertex] = start_weight;\n        queue<int> que;\n        que.push(start_vertex);\n        while (!que.empty()){\n          int v = que.front(); que.pop();\n          for (const auto &p : G[v]){\n            int w = p.first;\n            int c = diff[v] + p.second;\n            if (diff[w] != c){\n              diff[w] = c;\n              que.push(w);\n            }\n          }\n        }\n        \n        G[a].push_back(make_pair(b, w));\n        G[b].push_back(make_pair(a, -w));\n        union_find.unite(a, b);\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define MAX_N 100005\nusing namespace std;\ntypedef pair<int,int> P;\nP par[MAX_N];\n\nvoid init(int n){\n  for(int i=0;i<n;i++)\n    par[i]=P(i,0);\n}\n\nP find(int x){\n  if(par[x].first==x)return P(x,0);\n  P r=find(par[x].first);\n  return par[x]=P(r.first,par[x].second+r.second);\n}\n\nvoid unite(int x,int y,int cost){\n  P r1=find(x);\n  P r2=find(y);\n  if(r1.first==r2.first)return;\n  par[r1.first]=P(r2.first,r2.second-r1.second+cost);\n}\n\nbool same(int x,int y){return find(x).first==find(y).first;}\n\nint n,m,a,b,cost;\nchar c;\n\nint main(){\n  while(1){\n    cin>>n>>m;\n    if(!n&&!m)break;\n    init(n);\n    rep(i,m){\n      scanf(\"%c\",&c);\n      scanf(\"%c%d%d\",&c,&a,&b);\n      if(c=='!'){\n\tscanf(\"%d\",&cost);\n\tunite(b-1,a-1,cost);\n      }else{\n\tif(!same(a-1,b-1))printf(\"UNKNOWN\\n\");\n\telse printf(\"%d\\n\",find(b-1).second-find(a-1).second);\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<vector>\n\nusing namespace std;\n\nstruct parent{\n  int id, weightDiff;\n};\n\nvector<parent> UFtree(100010);\n\nint root_Diff(int i) {\n  if(UFtree[i].id == i) return 0;\n  else return UFtree[i].weightDiff + root_Diff(UFtree[i].id);\n}\n\nint root(int i) {\n  if(UFtree[i].id == i) return i;\n  else {\n    UFtree[i].weightDiff = root_Diff(i);\n    return (UFtree[i].id = root(UFtree[i].id));\n  }\n}\n\nbool is_same_set(int i, int j) {\n  return root(i) == root(j);\n}\n\n\n\nvoid unite(int i, int j, int w) {//w_i-w_j = w\n  int x, y;\n  x = root(i); y = root(j);\n  UFtree[y].id = x;\n  UFtree[y].weightDiff = w + UFtree[i].weightDiff - UFtree[j].weightDiff;\n}\n\nint main() {\n  int N, M;\n  while(cin >> N >> M) {\n    if(!N) break;\n    for(int i = 1; i <= N; i++){\n      parent p = {i, 0};\n      UFtree[i] = p;\n    }\n    string word;\n    int a, b, w;\n    for(int i = 0; i < M; i++) {\n      cin >> word >> a >> b;\n      if(word == \"!\") {\n\tcin >> w;\n\tunite(b, a, w);\n      }\n      else {\n\tif(is_same_set(a, b)) cout << root_Diff(a) - root_Diff(b) << endl;\n\telse cout << \"UNKNOWN\" << endl;\n      }\n    }\n    UFtree.clear();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define repi(i,a,b) for(int i = (int)(a); i < (int)(b); i++)\n#define rep(i,a) repi(i,0,a)\nconst int MAX = 100010;\nint N, M;\ntypedef pair<int,int> pii;\n\nstruct union_find{\n    int rnk[MAX], par[MAX], w[MAX];\n\n    union_find(int n){ rep(i,n) rnk[i] = 1, par[i] = i, w[i] = 0;}\n\n    pii weight(int x){\n        if(x == par[x]) return pii(x,0);\n        pii ret = weight(par[x]);\n        return pii((par[x]=ret.first), (w[x]+=ret.second));\n    }\n    int find(int x){ return weight(x).first;}\n    void unite(int a, int b, int k){\n        int x = find(a), y = find(b);\n        k -= w[b]-w[a];\n        if(x == y) return;\n        if(rnk[x] > rnk[y]){\n            par[y] = x;\n            w[y] = k;\n        }\n        else{\n            par[x] = y;\n            w[x] = -k;\n            if(rnk[x] == rnk[y]) rnk[y]++;\n        }\n    }\n    bool same(int x, int y){ return find(x)==find(y);}\n};\n\nvoid solve(){\n    union_find uf(N);\n    int a, b, w; char c;\n    rep(i,M){\n        cin >> c >> a >> b; a--; b--;\n        if(c=='!'){\n            cin >> w;\n            uf.unite(a,b,w);\n        }\n        else {\n            if(!uf.same(a,b)) puts(\"UNKNOWN\");\n            else cout << uf.w[b]-uf.w[a] << endl;\n        }\n    }\n}\n\nint main(){\n    while(cin >> N >> M, N and M) solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\nlong long dist[1 << 18];\nlong long group[1 << 18]; char q;\nlong long n, Q, a, b, c;\nvector<long long>gr[1 << 18];\nint main() {\n\tfor (int t = 0; t < 1; t++) {\n\t\tfor (int i = 0; i < 1 << 18; i++) {\n\t\t\tdist[i] = 0; group[i] = i; gr[i].clear(); gr[i].push_back(i);\n\t\t}\n\t\tcin >> n >> Q; if (n == 0 && Q == 0)break;\n\t\tfor (int i = 0; i < Q; i++) {\n\t\t\tcin >> q;\n\t\t\tif (q == '?') {\n\t\t\t\tcin >> a >> b;\n\t\t\t\tif (group[a] != group[b])cout << \"UNKNOWN\" << endl;\n\t\t\t\telse cout << dist[b] - dist[a] << endl;\n\t\t\t}\n\t\t\tif (q == '!') {\n\t\t\t\tcin >> a >> b >> c;\n\t\t\t\tif (group[a] != group[b]) {\n\t\t\t\t\tint K = dist[a] + c - dist[b];\n\t\t\t\t\tint L = group[a], M = group[b];\n\t\t\t\t\tfor (int j = 0; j < gr[M].size(); j++) {\n\t\t\t\t\t\tgroup[gr[M][j]] = L;\n\t\t\t\t\t\tgr[L].push_back(gr[M][j]);\n\t\t\t\t\t\tdist[gr[M][j]] += K;\n\t\t\t\t\t}\n\t\t\t\t\tgr[M].clear();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing P = pair<int, int>;\nconst ll MOD = 1000000007;\n\nclass DistUnionFind{\npublic:\n    vector<int> par;\n    vector<int> dist;\n    DistUnionFind(int n){\n        init(n);\n    }\n    void init(int n){\n        par.resize(n);\n        for(int i=0;i<n;i++){\n            par[i] = i;\n        }\n        dist.assign(n, 0);\n    }\n    int find(int x){\n        if(par[x] == x){\n            return x;\n        }else{\n            int prev_par = par[x];\n            par[x] = find(par[x]);\n            dist[x] += dist[prev_par];\n            return par[x];\n        }\n    }\n    void unite(int x, int y, int diff){\n        // w_y - w_x = diff\n        if(diff < 0){\n            swap(x, y);\n            diff = -diff;\n        }\n        if(find(y) != y){\n            unite(x, par[y], diff - dist[y]);\n            return;\n        }\n        par[y] = x;\n        dist[y] = diff;\n    }\n    bool same(int x, int y){\n        return find(x)==find(y);\n    }\n};\n\nint main(){\n    while(true){\n        int N, M;\n        cin >> N >> M;\n        if(N == 0) break;\n\n        DistUnionFind uf(N);\n        for(int i=0;i<M;i++){\n            char c;\n            int a, b;\n            cin >> c >> a >> b;\n            a--; b--;\n            if(c == '!'){\n                int w;\n                cin >> w;\n                if(uf.same(a, b)){\n                    assert(uf.dist[b] - uf.dist[a] == w);\n                }else{\n                    uf.unite(a, b, w);\n                }\n            }else{\n                if(!uf.same(a, b)){\n                    cout << \"UNKNOWN\" << endl;\n                }else{\n                    cout << uf.dist[b] - uf.dist[a] << endl;\n                }\n            }\n        }\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<vector>\n\nusing namespace std;\n\nstruct parent{\n  int id, weightDiff;\n};\n\nvector<parent> UFtree;\n\nint root_Diff(int i) {\n  if(UFtree[i].id == i) return 0;\n  else return UFtree[i].weightDiff + root_Diff(UFtree[i].id);\n}\n\nint root(int i) {\n  if(UFtree[i].id == i) return i;\n  else {\n    UFtree[i].weightDiff = root_Diff(i);\n    return (UFtree[i].id = root(UFtree[i].id));\n  }\n}\n\nbool is_same_set(int i, int j) {\n  return root(i) == root(j);\n}\n\n\n\nvoid unite(int i, int j, int w) {//w_i-w_j = w\n  int x, y;\n  x = root(i); y = root(j);\n  UFtree[y].id = x;\n  UFtree[y].weightDiff = w + UFtree[i].weightDiff - UFtree[j].weightDiff;\n}\n\nint main() {\n  int N, M;\n  while(cin >> N >> M) {\n    if(!N) break;\n    parent zero;\n    UFtree.push_back(zero);\n    for(int i = 1; i <= N; i++){\n      parent p = {i, 0};\n      UFtree.push_back(p);\n    }\n    string word;\n    int a, b, w;\n    for(int i = 0; i < M; i++) {\n      cin >> word >> a >> b;\n      if(word == \"!\") {\n\tcin >> w;\n\tunite(b, a, w);\n      }\n      else {\n\tif(is_same_set(a, b)) cout << root_Diff(a) - root_Diff(b) << endl;\n\telse cout << \"UNKNOWN\" << endl;\n      }\n    }\n    UFtree.clear();\n    UFtree.shrink_to_fit();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\ntemplate<typename T>\nstruct WeightedUnionFind {\n    vector<int> data;\n    vector<T> ws;\n    WeightedUnionFind(int sz) : data(sz, -1), ws(sz) { }\n    bool merge(int x, int y, T w) {             // ws(y) = ws(x) + w\n        w += weight(x); w -= weight(y);\n        if ((x = root(x)) == (y = root(y))) return false;\n        if (data[x] > data[y]) swap(x, y), w = -w;\n        data[x] += data[y]; data[y] = x; ws[y] = w;\n        return true;\n    }\n    bool find(int x, int y) { return root(x) == root(y); }\n    T diff(int x, int y) { return weight(y) - weight(x); }\n    T weight(int t) { root(t); return ws[t]; }\n    int root(int k) {\n        if (data[k] < 0) return k;\n        int par = root(data[k]);\n        ws[k] += ws[data[k]];\n        return data[k] = par;\n    }\n};\n\nint main() {\n    int N, M;\n    while (cin >> N >> M, N) {\n        WeightedUnionFind<int> wuf(N);\n        while (M--) {\n            char c; cin >> c;\n            if (c == '!') {\n                int a, b, w; cin >> a >> b >> w; a--, b--;\n                wuf.merge(a, b, w);\n            } else {\n                int a, b; cin >> a >> b; a--, b--;\n                if (!wuf.find(a, b)) puts(\"UNKNOWN\");\n                else cout << wuf.diff(a, b) << endl;\n            }\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)n;++i)\n#define each(a, b) for(auto (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout <<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout <<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define svec(v) cout<<#v<<\":\";rep(i,v.size())cout<<\" \"<<v[i];cout<<endl\n#define sset(s) cout<<#s<<\":\";each(i,s)cout <<\" \"<<i;cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int>P;\n\nconst int MAX_N = 100005;\n\nint par[MAX_N];\nint nrank[MAX_N];\nint weight[MAX_N];\n\nvoid initial(int n){\t\t//?????????\n\tfor(int i=0;i<n;i++){\n\t\tpar[i] = i;\n\t\tnrank[i] = 0;\n        weight[i] = 0;\n\t}\n}\n\nP find(int x){\t\t//??¨??????????±???????\n\tif(par[x] == x){\n\t\treturn P(x,0);\n\t}else{\n\t\tP p = find(par[x]);\n\t\tpar[x] = p.fi;\n\t\tweight[x] = p.se + weight[x];\n\t\treturn P(par[x],weight[x]);\n\t}\n}\n\nvoid unite(int x,int y,int w){\n\tint bx = x;\n\tint by = y;\n\tx = (find(x)).fi;\n\ty = (find(y)).fi;\n\tif(x == y) return;\n\tif(nrank[x] < nrank[y]){\n\t\tpar[x] = y;\n\t\tweight[x] = -weight[bx] - w + weight[by];\n\t}else{\n\t\tpar[y] = x;\n        weight[y] = weight[bx] + w - weight[by];\n\t\tif(nrank[x] == nrank[y])\n\t\t\tnrank[x]++;\n\t}\n}\n\nbool same(int x,int y){\n\treturn (find(x)).fi == (find(y)).fi;\n}\n\nint main()\n{\n    while(1){\n        int n,m;\n        cin >> n >> m;\n        if(n == 0){\n            break;\n        }\n        initial(n+1);\n        rep(i,m){\n            int a,b,w;\n            char hoge,c;\n            scanf(\"%c%c\",&hoge,&c);\n            if(c == '!'){\n                scanf(\"%d%d%d\",&a,&b,&w);\n                unite(a,b,w);\n            }else{\n                scanf(\"%d%d\",&a,&b);\n                if(same(a,b)){\n                    printf(\"%d\\n\",weight[b]-weight[a]);\n                }else{\n                    printf(\"UNKNOWN\\n\");\n                }\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\nlong long dist[1 << 18];\nlong long group[1 << 18]; char q;\nlong long n, Q, a, b, c;\nvector<long long>gr[1 << 18];\nint main() {\n\tfor (int t = 0; t < 19; t++) {\n\t\tfor (int i = 0; i < 1 << 18; i++) {\n\t\t\tdist[i] = 0; group[i] = i; gr[i].clear(); gr[i].push_back(i);\n\t\t}\n\t\tcin >> n >> Q; if (n == 0 && Q == 0)break;\n\t\tfor (int i = 0; i < Q; i++) {\n\t\t\tcin >> q;\n\t\t\tif (q == '?') {\n\t\t\t\tcin >> a >> b;\n\t\t\t\tif (group[a] != group[b])cout << \"UNKNOWN\" << endl;\n\t\t\t\telse cout << dist[b] - dist[a] << endl;\n\t\t\t}\n\t\t\tif (q == '!') {\n\t\t\t\tcin >> a >> b >> c;\n\t\t\t\tif (group[a] != group[b]) {\n\t\t\t\t\tint K = dist[a] + c - dist[b];\n\t\t\t\t\tint L = group[a], M = group[b];\n\t\t\t\t\tfor (int j = 0; j < gr[M].size(); j++) {\n\t\t\t\t\t\tgroup[gr[M][j]] = L;\n\t\t\t\t\t\tgr[L].push_back(gr[M][j]);\n\t\t\t\t\t\tdist[gr[M][j]] += K;\n\t\t\t\t\t}\n\t\t\t\t\tgr[M].clear();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <complex>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <string>\n#include <cstring>\n#include <stack>\n#include <cmath>\n#include <iomanip>\n#include <sstream>\n#include <cassert>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef ll li;\ntypedef pair<int,int> PInt;\n#define EPS (1e-10L)\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define REP(i,m,n) for(int i=m; i<=(int)(n); ++i)\n#define F first\n#define S second\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SZ(a) (int)((a).size())\n#define ALL(a) a.begin(),a.end()\n#define FOR(it,a) for(__typeof(a.begin())it=a.begin();it!=a.end();++it)\nint dx[]={0,1,0,-1,1,1,-1,-1};\nint dy[]={1,0,-1,0,-1,1,1,-1};\n\nint parent[1000010];\nint weight[1000010];\nint find(int a) {\n  if (parent[a] == a) return a;\n  int p = parent[a];\n  parent[a] = find(p);\n  weight[a] += weight[p];\n  return parent[a];\n}\n\nint main() {\n  int N, M;\n  while(cin >> N >> M, N) {\n    rep(i, N) parent[i] = i;\n    rep(i, N) weight[i] = 0;\n    rep(i, M) {\n      char req;\n      cin >> req;\n      if (req == '!') {\n        int a, b, w;\n        cin >> a >> b >> w;\n        a--, b--;\n\n        if (find(a) == find(b)) continue;\n        int ap = find(a);\n        int bp = find(b);\n        parent[bp] = ap;\n        weight[bp] = w + weight[a] - weight[b];\n      } else {\n        int a, b;\n        cin >> a >> b;\n        a--, b--;\n\n        if (find(a) == find(b)) {\n          cout << weight[b] - weight[a] << endl;\n        } else {\n          cout << \"UNKNOWN\" << endl;\n        }\n      }\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nclass union_find{\n\tvector<int> a,h;\npublic:\n\tunion_find(int n):a(n,-1),h(n){}\n\tint find(int x){\n\t\tif(a[x]<0) return x;\n\t\tint p=find(a[x]);\n\t\th[x]+=h[a[x]];\n\t\treturn a[x]=p;\n\t}\n\tvoid update(int x,int y,int w){\n\t\tint rx=find(x);\n\t\tint ry=find(y);\n\t\tif(rx!=ry){\n\t\t\ta[rx]+=a[ry];\n\t\t\ta[ry]=rx;\n\t\t\th[ry]=w-h[y]+h[x];\n\t\t}\n\t}\n\tint query(int x,int y){\n\t\treturn h[y]-h[x];\n\t}\n};\n\nint main(){\n\tfor(int n,q;scanf(\"%d%d\",&n,&q),n;){\n\t\tunion_find U(n);\n\t\twhile(q--){\n\t\t\tchar c;\n\t\t\tint a,b; scanf(\" %c%d%d\",&c,&a,&b); a--; b--;\n\t\t\tif(c=='!'){ // update\n\t\t\t\tint w; scanf(\"%d\",&w);\n\t\t\t\tU.update(a,b,w);\n\t\t\t}\n\t\t\telse{ // query\n\t\t\t\tif(U.find(a)!=U.find(b)) puts(\"UNKNOWN\"); else printf(\"%d\\n\",U.query(a,b));\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct UnionFind {\n    int node[100010], weight[100010];\n    UnionFind() {\n        memset(node, -1, sizeof(node));\n        memset(weight, 0, sizeof(weight));\n    }\n    void unite(int u, int v, int w) {\n        // printf(\"(u, v) = (%d, %d)\\n\", u, v);\n        // printf(\"find(u, v) = (%d, %d)\\n\", find(u), find(v));\n        if(find(u) == find(v)) return;\n        if(find(u) > find(v)) swap(u, v), w *= -1;\n        int new_weight = get_weight(u);\n\n        // printf(\"new_weight = %d\\n\", new_weight);\n        // v ????????? (u ??????) ???????????????\n        u = find(u);\n        node[u] += node[v];\n        node[v] = u;\n        weight[v] += new_weight + w;\n    }\n\n    int get_weight(int u) {\n        int ret = 0;\n        for(; node[u] >= 0; u = node[u]) {\n            ret += weight[u];\n        }\n        return ret;\n    }\n\n    int find(int u) {\n        return (node[u] < 0 ? u : node[u] = find(node[u]));\n    }\n};\n\nint main() {\n    int N, M;\n    while(cin >> N >> M, N) {\n        UnionFind uf;\n        for(int i=0; i<M; i++) {\n            char c; cin >> c;\n            if(c == '!') {\n                int a, b, d; cin >> a >> b >> d;\n                a--; b--;\n                uf.unite(a, b, d);\n            }\n            else {\n                int a, b; cin >> a >> b;\n                a--; b--;\n                if(uf.find(a) != uf.find(b)) cout << \"UNKNOWN\" << endl;\n                else {\n                    int wa = uf.weight[a];\n                    int wb = uf.weight[b];\n                    // printf(\"wa = %d, wb = %d\\n\", wa, wb);\n                    cout << wb - wa << endl;\n                }\n            }\n        }\n        for(int i=0; i<N; i++) {\n            // printf(\"parent[%d] = %d, weight[%d] = %d\\n\", i, uf.node[i], i, uf.weight[i]);\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cassert>\n#include<algorithm>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<28)\n#define MAX 1000000\nusing namespace std;\nstruct P\n{\n  int color,w;\n  P(int color=-inf,int w=-inf):color(color),w(w){}\n};\nP par[MAX];\nvoid init(){ rep(i,MAX)par[i] = P(i); }\n\nP find(int x)\n{\n  if(x == par[x].color)return par[x];\n  P p = find(par[x].color);\n  if(par[x].color == -inf)par[x].color = 0;\n  par[x].w += p.w,par[x].color = p.color;\n  return par[x];\n}\n\nvoid unit(int x,int y,int w)//x <= y\n{\n  P X = find(x);\n  P Y = find(y);\n  if(X.color == Y.color)return;\n  par[X.color].color = par[Y.color].color;\n  if(par[X.color].w == -inf)par[X.color].w = 0;\n  if(par[Y.color].w == -inf)par[Y.color].w = 0;\n  par[X.color].w = par[X.color].w - w + (Y.w != -inf?Y.w:0);\n}\n\nint N,M;\n\nint main()\n{\n  while(cin >> N >> M,N|M)\n    {\n      init();\n      char c;\n      int a,b,w;\n      rep(_,M)\n\t{\n\t  cin >> c;\n\t  if(c == '!')\n\t    {\n\t      cin >> a >> b >> w;\n\t      unit(a,b,w);\n\t    }\n\t  else\n\t    {\n\t      cin >> a >> b;\n\t      int B = find(b).w;\n\t      int A = find(a).w;\n\t      if(B == -inf || A == -inf)cout << \"UNKNOWN\" << endl;\n\t      else cout << B-A << endl;\n\t    }\n\t\n\t}\n    }\n  return 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<map>\nusing namespace std;\n\nclass UF {\n    public:\n    vector<pair<int,int> > l;\n    UF(int n) {\n        for(int i=0; i<n; i++)\n            l.push_back(pair<int,int>(i,0));\n    }\n    pair<int,int> root(int x) {\n        if(x == l[x].first) return l[x];\n        pair<int,int> t = root(l[x].first);\n        l[x].first = t.first ;\n        l[x].second+= t.second;\n        return l[x];\n    }\n    void unite(int x, int y, int xMy) {\n        x = root(x).first;\n        pair<int,int> t = root(y);\n        y = t.first;\n        if(x == y) return;\n        l[y].first = l[x].first;\n        l[y].second= -xMy - t.second;\n    }\n    int weight(int x, int y) { // x - y else 123456\n        pair<int,int> s,t;\n        s = root(x);\n        t = root(y);\n        if(s.first != t.first) return 123456;\n        return s.second - t.second;\n    }\n};\n\n\nint main(void) {\n    while(1) {\n        int n,m;\n        scanf(\"%d%d\",&n,&m);\n        if(!n) break;\n        UF uf(n);\n        for(int i=0; i<m; i++) {\n            int a,b;\n            char s[3];\n            scanf(\"%s%d%d\",s,&a,&b);\n            if(s[0] == '?') {\n                int w = uf.weight(b,a);\n                if(w == 123456)\n                    printf(\"UNKNOWN\\n\");\n                else\n                    printf(\"%d\\n\", w);\n            }\n            else {\n                int w;\n                scanf(\"%d\",&w);\n                uf.unite(b, a, w);\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// Wrongri-La Shower\n\n#include <iostream>\n#include <queue>\n#include <stack>\n#include <tuple>\n\ntypedef long long ll;\ntypedef std::tuple<int,ll> P;\n\ntemplate <int n>\nclass UnionFind{\npublic:\n    UnionFind(){\n        init();\n    }\n    void init(){\n        for(int i=0;i<n;i++){\n            par[i] = i;\n            rank[i] = 0;\n            weight[i] = 0ll;\n        }\n    }\n    P find(int x){\n        if(x == par[x])return std::make_tuple(x, weight[x]);\n\n        std::stack<int> v_stack;\n        std::queue<ll> w_queue;\n        ll w = 0;\n        while(x != par[x]){\n            w += weight[x];\n            w_queue.push(w);\n            v_stack.push(x);\n\n            x = par[x];\n        }\n        \n        while(!v_stack.empty()){\n            int a; ll b;\n            a = v_stack.top(); v_stack.pop();\n            b = w_queue.front(); w_queue.pop();\n            \n            par[a] = x;\n            weight[a] = b;\n        }\n        \n        return std::make_tuple(x, w);\n    }\n    bool same(int x, int y){\n        return std::get<0>(find(x)) == std::get<0>(find(y));\n    }\n    void unite(int x, int y, int l){\n        P xp = find(x), yp = find(y);\n        ll wx, wy;\n        std::tie(x, wx) = xp;\n        std::tie(y, wy) = yp;\n        \n        if(x == y){return;}\n        \n        if(rank[x] > rank[y]){\n            par[y] = x;\n            weight[y] = wx + l;\n        }else{\n            par[x] = y;\n            weight[x] = wy - l;\n            if(rank[x] == rank[y]){rank[y]++;}\n        }\n    }\n    int rank[n], par[n];\n    ll weight[n];\n};\n\nUnionFind<100001> uf;\n\nint main(){\n    std::ios_base::sync_with_stdio(false);\n    \n    int N, M;\n    while(std::cin >> N >> M, N || M){\n        uf.init();\n\n        for(int i=0;i<M;i++){\n            char c;\n            std::cin >> c;\n            \n            if(c == '!'){\n                int a, b, c;\n                std::cin >> a >> b >> c;\n\n                uf.unite(a, b, c);\n            }else{\n                int a, b;\n                std::cin >> a >> b;\n\n                if(!uf.same(a, b)){\n                    std::cout << \"UNKNOWN\" << std::endl;\n                }else{\n                    P ap = uf.find(a), bp = uf.find(b);\n                    ll wa = std::get<1>(ap), wb = std::get<1>(bp);\n\n                    std::cout << wb-wa << std::endl;\n                }\n            }\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<map>\nusing namespace std;\n\nclass UF {\n    public:\n    vector<pair<int,int> > l;\n    UF(int n) {\n        for(int i=0; i<n; i++)\n            l.push_back(pair<int,int>(i,0));\n    }\n    pair<int,int> root(int x) {\n        if(x == l[x].first) return l[x];\n        pair<int,int> t = root(l[x].first);\n        l[x].first = t.first ;\n        l[x].second+= t.second;\n        return l[x];\n    }\n    void unite(int x, int y, int xMy) {\n        x = root(x).first;\n        pair<int,int> t = root(y);\n        y = t.first;\n        if(x == y) return;\n        l[y].first = l[x].first;\n        l[y].second= -xMy - t.second;\n    }\n    int weight(int x, int y) { // x - y else 123456\n        pair<int,int> s,t;\n        s = root(x);\n        t = root(y);\n        if(s.first != t.first) return 123456;\n        return s.second - t.second;\n    }\n};\n\n\nint main(void) {\n    while(1) {\n        int n,m;\n        scanf(\"%d%d\",&n,&m);\n        if(!n) break;\n        UF uf(n);\n        for(int i=0; i<m; i++) {\n            int a,b;\n            char s[3];\n            scanf(\"%s%d%d\",s,&a,&b);\n            a--, b--;\n            if(s[0] == '?') {\n                int w = uf.weight(b,a);\n                if(w == 123456)\n                    printf(\"UNKNOWN\\n\");\n                else\n                    printf(\"%d\\n\", w);\n            }\n            else {\n                int w;\n                scanf(\"%d\",&w);\n                uf.unite(b, a, w);\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntypedef long double ld;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-10;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\nstruct union_find\n{\n\tvector<pii> par;\n\tunion_find(int n)\n\t{\n\t\tREP(i, n) par.emplace_back(i, 0);\n\t}\n\tpii find(int x)\n\t{\n\t\tif (par[x].first == x) return par[x];\n\t\telse\n\t\t{\n\t\t\tpii t = find(par[x].first);\n\t\t\treturn pii(par[x].first = t.first, par[x].second += t.second);\n\t\t}\n\t}\n\tvoid unite(int x, int y, int w)\n\t{\n\t\tint dif = w + par[x].second - par[y].second;\n\t\tx = find(x).first; y = find(y).first;\n\t\tif (x == y) return;\n\t\tpar[y].first = x;\n\t\tpar[y].second = dif;\n\t}\n\tbool same(int x, int y)\n\t{\n\t\treturn find(x).first == find(y).first;\n\t}\n};\n\nint main()\n{\n\tint n, m;\n\twhile (cin >> n >> m, n)\n\t{\n\t\tunion_find uf(n);\n\t\tREP(i, m)\n\t\t{\n\t\t\tchar c;\n\t\t\tcin >> c;\n\t\t\tif (c == '!')\n\t\t\t{\n\t\t\t\tint a, b, w;\n\t\t\t\tcin >> a >> b >> w;\n\t\t\t\ta--; b--;\n\t\t\t\tuf.unite(a, b, w);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tint a, b;\n\t\t\t\tcin >> a >> b;\n\t\t\t\ta--; b--;\n\t\t\t\tif (!uf.same(a, b))\n\t\t\t\t\tputs(\"UNKNOWN\");\n\t\t\t\telse cout << uf.par[b].second - uf.par[a].second << endl;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\nconst int S = 100010;\n\nstruct UnionFind {\n  vector<int> node;\n  vector<ll> weight;\n  UnionFind() : node(S, -1), weight(S, 0) {}\n  void unite(int u, int v, ll w) {\n    int ov = v, ou = u;\n    u = find(u), v = find(v);\n    int wa = weight[ov], wb = weight[ou];\n    if(u == v) return;\n    \n    // (v ??????) ??? (u ??????) ???????????????\n    node[u] += node[v];\n    node[v] = u;\n    weight[v] += w + wb - wa;\n  }\n  \n  int find(int u) {\n    if(node[u] < 0) return u;\n    int par = node[u], root = find(node[u]);\n    weight[u] += weight[par];\n    return node[u] = root;\n  }\n};\n\nint main() {\n  int N, M;\n  while(cin >> N >> M, N) {\n    UnionFind uf;\n    for(int i=0; i<M; i++) {\n      char c; cin >> c;\n      if(c == '!') {\n\tint a, b, d; cin >> a >> b >> d;\n\ta--; b--;\n\tuf.unite(a, b, d);\n      }\n      else {\n\tint a, b; cin >> a >> b;\n\ta--; b--;\n\tif(uf.find(a) != uf.find(b)) cout << \"UNKNOWN\" << endl;\n\telse {\n\t  ll wa = uf.weight[a];\n\t  ll wb = uf.weight[b];\n\t  cout << wb - wa << endl;\n\t}\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstruct WeightedUnionFind{\n  int n;\n  vector<int>r,p;\n  vector<int>ws;\n  WeightedUnionFind(int sz):n(sz),ws(n,0),r(n,0),p(n,0){iota(p.begin(),p.end(),0);}\n  int find(int x){\n    if(x==p[x])return x;\n    else{\n      int t=find(p[x]);\n      ws[x]+=ws[p[x]];\n      return p[x]=t;\n    }\n  }\n  int weight(int x){\n    find(x);\n    return ws[x];\n  }\n  bool same(int x,int y){\n    return find(x)==find(y);\n  }\n  void unite(int x,int y,int w){\n    w+=weight(x);\n    w-=weight(y);\n    x=find(x);\n    y=find(y);\n    if(x==y)return;\n    if(r[x]<r[y])swap(x,y),w=-w;\n    r[x]+=r[y];\n    p[y]=x;\n    ws[y]=w;\n  }\n  int diff(int x,int y){\n    return weight(y)-weight(x);\n  }\n};\n\nsigned main(){\n  int n,m;\n  while(cin>>n>>m,n||m){\n    WeightedUnionFind U(n+1);\n    while(m--){\n      char c;\n      int x,y,z;\n      cin>>c>>x>>y;\n      if(c=='!'){\n        cin>>z;\n        U.unite(x,y,z);\n      }\n      else{\n        if(!U.same(x,y))cout<<\"UNKNOWN\"<<endl;\n        else cout<<U.diff(x,y)<<endl;\n      }\n    }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\nconst int INF = 1000000000;\n#define REP(i,s,n) for(int i=(int)(s);i<(int)(n);i++)\n#define rep(i,n) REP(i, 0, n)\nstruct UnionFind {\n    vector<int> data;\n    vector<ll> rootd;//rootd[i] : dist from node[i] to node[root(i)]\n    UnionFind(int N) : data(N, -1), rootd(N, 0) {}\n    void unite(int x_, int y_, ll weight) {\n        int x = root(x_), y = root(y_);\n        if(x != y){\n            data[x] += data[y];\n            data[y] = x;\n            rootd[y] = weight - rootd[y_];\n        }\n    }\n    int root(int x_) {\n        int x = x_;\n        vector<int> memo;\n        while(data[x] >= 0) {\n            memo.push_back(x);\n            x = data[x];\n        }\n        int res = x;\n        for(int k : memo) {\n            rootd[k] += rootd[data[k]];\n            data[k] = res;\n        }\n        return res;\n    }\n    ll dist(int a, int b) { return rootd[b] - rootd[a];}\n    bool same(int a, int b) { return root(a) == root(b);}\n};\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int N, M;\n    while(cin >> N >> M && N) {\n        UnionFind uf(N);\n        char q; int a, b; ll w;\n        rep(i, M) {\n            cin >> q >> a >> b;\n            --a; --b;\n            if(q == '?') {\n                if(uf.same(a, b)) cout << uf.dist(a, b) << '\\n';\n                else cout << \"UNKNOWN\" << '\\n';;\n            }else {\n                cin >> w;\n                uf.unite(b, a, -w);\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int M = 1000000007;\n\nvector<int> grp, val;\nvector<vector<int>> lis;\nvoid init(int n) {\n    grp.resize(n);\n    val.resize(n, 0);\n    lis.resize(n);\n    for (int i = 0; i < n; ++i) {\n        grp[i] = i;\n        lis[i].push_back(i);\n    }\n}\nvoid merge(int p, int q, int w) {\n    if (grp[p] == grp[q]) return;\n    if (lis[grp[p]].size() < lis[grp[q]].size()) {\n        merge(q, p, -w);\n        return;\n    }\n    int d = w + val[p] - val[q];\n    int g = grp[q];\n    for (int i : lis[g]) {\n        grp[i] = grp[p];\n        val[i] += d;\n        lis[grp[p]].push_back(i);\n    }\n    lis[g].clear();\n}\n\nint main() {\n    while (1) {\n        int n, m;\n        cin >> n >> m;\n        if (!n) return 0;\n        init(n);\n        for (int i = 0; i < m; ++i) {\n            char c;\n            cin >> c;\n            if (c == '!') {\n                int p, q, w;\n                cin >> p >> q >> w;\n                merge(p - 1, q - 1, w);\n            }\n            else {\n                int p, q;\n                cin >> p >> q;\n                --p;\n                --q;\n                if (grp[p] != grp[q])\n                    puts(\"UNKNOWN\");\n                else\n                    printf(\"%d\\n\", val[q] - val[p]);\n            }\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX 100010\ntypedef pair<int,int> pii;\n\nclass Union_Find{\npublic:\n  int par[MAX],rank[MAX],W[MAX];\n  Union_Find(int N){\n    for(int i = 0 ; i < N ; i++){\n      par[i] = i;\n      rank[i] = W[i] = 0;\n    }\n  }\n\n  pii find(int x){\n    if(par[x] == x){ return pii(x,0); }\n    pii p = find(par[x]);\n    par[x] = p.first;\n    W[x] = (p.second += W[x]);\n    return p;\n  }\n\n  void unite(int x,int y,int w){\n    pii nx = find(x), ny = find(y);\n    x = nx.first; y = ny.first;\n    if(x == y){ return; }\n    w -= nx.second-ny.second;\n    if(rank[x] < rank[y]){\n      par[x] = y; W[x] = w;\n    }else{\n      par[y] = x; W[y] = -w;\n      if(rank[x] == rank[y]){\n        rank[x]++;\n      }\n    }\n  }\n\n  bool same(int x,int y){\n    return (find(x).first == find(y).first);\n  }\n\n  int diff(int a,int b){\n    return W[a]-W[b];\n  }\n};\n\nint main(){\n  int N,M,a,b,c;\n  while(cin >> N >> M,N){\n    Union_Find uf(N);\n    for(int i = 0 ; i < M ; i++){\n      char ch;\n      cin >> ch >> a >> b;\n      a--; b--;\n      if(ch == '!'){\n        cin >> c;\n        uf.unite(a,b,c);\n      }else{\n        if(uf.same(a,b)){\n          cout << uf.diff(a,b) << endl;\n        }else{\n          puts(\"UNKNOWN\");\n        }\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<complex>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define each(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<__LINE__<<\": \"<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf = (int)1e9;\nconst double INF = 1e12, EPS = 1e-9;\n\nint n, m, p[100000], w[1000000];\nset<int> s[100000];\nint root(int x){\n\tif(x == p[x]) return x;\n\treturn p[x] = root(p[x]);\n}\nint main(){\n\twhile(scanf(\"%d%d\", &n, &m), n){\n\t\trep(i, n) s[i].clear(), s[i].insert(i);\n\t\trep(i, n) p[i] = i, w[i] = 0;\n\t\trep(i, m){\n\t\t\tchar c;\n\t\t\tint a, b, x;\n\t\t\tscanf(\" %c%d%d\", &c, &a, &b);\n\t\t\ta--; b--;\n\t\t\tif(c == '!'){\n\t\t\t\tscanf(\"%d\", &x);\n\t\t\t\tint ra = root(a), rb = root(b);\n\t\t\t\tif(ra == rb) continue;\n\t\t\t\tif(s[ra].size() > s[rb].size()){\n\t\t\t\t\tswap(ra, rb);\n\t\t\t\t\tswap(a, b);\n\t\t\t\t\tx *= -1;\n\t\t\t\t}\n\t\t\t\tp[ra] = rb;\n\t\t\t\tx += w[a] - w[b];\n\t\t\t\teach(i, s[ra]){\n\t\t\t\t\ts[rb].insert(*i);\n\t\t\t\t\tw[*i] -= x;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif(root(a) != root(b)) puts(\"UNKNOWN\");\n\t\t\t\telse printf(\"%d\\n\", w[b] - w[a]);\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<28)\n#define MAX 1000000\nusing namespace std;\nstruct P\n{\n  int color,w;\n  P(int color=-inf,int w=-inf):color(color),w(w){}\n};\nP par[MAX];\nvoid init(){ rep(i,MAX)par[i] = P(i); }\n\nP find(int x)\n{\n  if(x == par[x].color)return par[x];\n  P p = find(par[x].color);\n  if(par[x].color == -inf)par[x].color = 0;\n  par[x].w += p.w,par[x].color = p.color;\n  return par[x];\n}\n\nvoid unit(int x,int y,int w)//x <= y\n{\n  //cout << \"unit (\" << x << \",\" << y << \")\" << endl;\n  P X = find(x);\n  P Y = find(y);\n  //cout << \"X = \" << X.color << \",\" << X.w << endl;\n  //cout << \"Y = \" << Y.color << \",\" << Y.w << endl;\n  if(X.color == Y.color)return;//??? www !!!??!!!!\n  par[X.color].color = par[Y.color].color;\n  if(par[X.color].w == -inf)par[X.color].w = 0;\n  if(par[Y.color].w == -inf)par[Y.color].w = 0;\n  par[X.color].w = par[X.color].w - w + (Y.w != -inf?Y.w:0);\n}\n\nint N,M;\n\nint main()\n{\n  while(cin >> N >> M,N|M)\n    {\n      init();\n      char c;\n      int a,b,w;\n      rep(_,M)\n\t{\n\t  cin >> c;\n\t  if(c == '!')\n\t    {\n\t      cin >> a >> b >> w;\n\t      unit(a,b,w);\n\t    }\n\t  else\n\t    {\n\t      cin >> a >> b;\n\t      int B = find(b).w;\n\t      int A = find(a).w;\n\t      if(B == -inf || A == -inf)cout << \"UNKNOWN\" << endl;\n\t      else cout << B-A << endl;\n\t    }\n\t\n\t}\n    }\n  return 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\n#define rep(i, n) for(int i = 0 ; i < n ; i++)\n\ntypedef pair<int, int> P;\n\nconst int MAX = 100010;\n\nstruct Union_find{\n  int parents[MAX];\n  int rank[MAX];\n  int w[MAX];\n  \n  void init(int n){\n    rep(i, n){\n      parents[i] = i;\n      rank[i] = 0;\n      w[i] = 0;\n    }\n  }\n  \n  P find(int x){\n    if(parents[x] == x) return P(x, 0);\n    else{\n      P tmp = find(parents[x]);\n      parents[x] = tmp.first;\n      tmp.second += w[x];\n      w[x] = tmp.second;\n      return tmp;\n    }\n  }\n  \n  void unite(int x, int y, int diff){\n    P dx = find(x);\n    P dy = find(y);\n    \n    x = dx.first;\n    y = dy.first;\n    \n    //cout << \"x = \" << x << \", y = \" << y << endl;\n    \n    diff = (diff - dx.second) + dy.second;\n    \n    //cout << \"diff = \" << diff << endl;\n    \n    if(x == y) return;\n    \n    if(rank[x] < rank[y]){\n      parents[x] = y;\n      w[x] = diff;\n    }\n    else{\n      parents[y] = x;\n      w[y] = -diff;\n      if(rank[x] == rank[y]) rank[x]++;\n    }\n  }\n  \n  bool same(int x, int y){\n    return find(x).first == find(y).first;\n  }\n\n};\n\nint main(){\n  int N, Q;\n  while(cin >> N >> Q, N|Q){\n    Union_find uf;\n    uf.init(N);\n    char op;\n    int a, b, w;\n    while(Q--){\n      cin >> op;\n      if(op == '!'){\n\tcin >> a >> b >> w;\n\ta--, b--;\n\tuf.unite(a, b, w);\n      }\n      else if(op == '?'){\n\tcin >> a >> b;\n\ta--, b--;\n\tif(uf.same(a, b)){\n\t  cout << uf.find(a).second - uf.find(b).second << endl;\n\t}\n\telse{\n\t  cout << \"UNKNOWN\" << endl;\n\t}\n      }\n    }\n  } \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//https://atcoder.jp/contests/code-thanks-festival-2017-open/tasks/code_thanks_festival_2017_h\n#include <iostream>\n#include <vector>\n#include <limits>\n#include <numeric>\n//cut begin\ntemplate<typename T>\nstruct PotentializedUnionFind{\nprivate:\n    private:\n    std::vector<int> par;\n    std::vector<int> size;\n    std::vector<T> diff;\npublic:\n    PotentializedUnionFind(int n){\n        par.resize(n);\n        std::iota(par.begin(),par.end(),0);\n        size.resize(n);\n        std::iota(size.begin(),size.end(),0);\n        diff.assign(n,0);\n    }\n\n    int root(int x){\n        if(par[x]==x){\n            return x;\n        }\n        else{\n            int r=root(par[x]);\n            diff[x]+=diff[par[x]];\n            return par[x]=r;\n        }\n    }\n\n    T potential(int x){\n        root(x);\n        return diff[x];\n    }\n\n    T potential_diff(int x,int y){\n        return potential(y)-potential(x);\n    }\n\n    bool same(int x,int y){//0-indexed\n        return root(x)==root(y);\n    }\n\n    void unite(int x,int y,T w){//0-indexed,potential(y)-potential(x)=w\n        w+=potential(x);\n        w-=potential(y);\n        \n        x=root(x);\n        y=root(y);\n        if(x==y)return;\n\n        if(size[x]<size[y]){\n            par[x]=y;\n            size[y]+=size[x];\n            diff[x]=-w;\n        }\n        else{\n            par[y]=x;\n            size[x]+=size[y];\n            diff[y]=w;\n        }\n    }\n};\n//cut end\n\nint solve(){\n    int n,m;\n    std::cin>>n>>m;\n    if(n==0&&m==0)return 1;\n    PotentializedUnionFind<long long> pu(n);\n    for (int i = 0; i < m; ++i){\n        char c;\n        std::cin>>c;\n        int x,y,z;\n        std::cin>>x>>y;\n        --x;--y;\n        if(c=='!'){\n            std::cin>>z;\n            pu.unite(x,y,z);\n        }\n        else{\n            if(pu.same(x,y))std::cout<<pu.potential_diff(x,y)<<std::endl;\n            else std::cout<<\"UNKNOWN\"<<std::endl;\n        }\n    }\n    return 0;\n}\n\nint main(){\n    while(solve()==0);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\ntemplate <typename T> \nstruct WeightedUnionFind{\t\n  int n;\n  T d;\n  vector<int> r,p;\n  vector<T> ws;\n  WeightedUnionFind(){}\n  WeightedUnionFind(int sz,T d_):\n    n(sz),d(d_),r(n,1),p(n),ws(n,d){iota(p.begin(),p.end(),0);}\n  int find(int x){\n    if(x==p[x]){\n      return x;\n    }else{\n      int t=find(p[x]);\n      ws[x]+=ws[p[x]];\n      return p[x]=t;\n    }\n  }\n  T weight(int x){\n    find(x);\n    return ws[x];\n  }\n  bool same(int x,int y){\n    return find(x)==find(y);\n  }\n  void unite(int x,int y,T w){\n    w+=weight(x);\n    w-=weight(y);\n    x=find(x);y=find(y);\n    if(x==y) return;\n    if(r[x]<r[y]) swap(x,y),w=-w;\n    r[x]+=r[y];\n    p[y]=x;\n    ws[y]=w;\n  }\n  T diff(int x,int y){\n    return weight(y)-weight(x);\n  }\n};\n\nsigned main() {\n\tint n, m;\n\twhile ( cin >> n >> m, n ) {\n\t\n\t\tWeightedUnionFind<int> uf(n, 0);\n\t\tfor ( int i = 0; i < m; i++ ) {\n\t\t\tchar c;\n\t\t\tcin >> c;\n\t\t\tint a, b;\n\t\t\tcin >> a >> b;\n\t\t\ta--; b--;\n\t\t\tif ( c == '!' ) {\n\t\t\t\tint c;\n\t\t\t\tcin >> c;\n\t\t\t\tuf.unite(a, b, c);\n\t\t\t} else {\n\t\t\t\tif ( !uf.same(a, b) ) cout << \"UNKNOWN\" << endl;\n\t\t\t\telse cout << uf.diff(a, b) << endl;\t\t\t\n\t\t\t}\n\t\t}\n\t}\n\t\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <cstdint>\n\nclass UnionFind {\n  std::vector<int> vertex;\n  std::vector<intmax_t> weight;\n\npublic:\n  UnionFind(size_t V): vertex(V, -1), weight(V, 0) {}\n\n  bool unite(size_t u, size_t v, intmax_t w) {\n    size_t pu=u, pv=v;\n    if (u >= 0) u = find(u);\n    if (v >= 0) v = find(v);\n    if (u == v) return false;\n    if (vertex[u] > vertex[v]) {\n      std::swap(u, v);\n      std::swap(pu, pv);\n      w = -w;\n    }\n\n    // u:parent, v:child\n    vertex[u] += vertex[v];\n    vertex[v] = u;\n    weight[v] = -w + weight[pu];\n    return true;\n  }\n\n  /*\n  int find(size_t v) {\n    size_t pv=v;\n    while (vertex[v] >= 0) {\n      weight[pv] += weight[vertex[v]];\n      v = vertex[v];\n    }\n\n    return vertex[pv] = v;\n    }\n  */\n  int find(size_t v) {\n    if (vertex[v] < 0)\n      return v;\n\n    size_t u;\n    for (u=v; vertex[u]>=0; u=vertex[u]) {\n      weight[v] += weight[vertex[u]];\n    }\n\n    return (vertex[v] = find(vertex[v]));\n  }\n\n  bool connected(size_t u, size_t v) {\n    return find(u) == find(v);\n  }\n\n  intmax_t relweight(size_t u) const {\n    if (vertex[u] < 0) {\n      return 0;\n    }\n\n    return weight[u] + relweight(vertex[u]);\n  }\n};\n\nint testcase_ends() {\n  int N, M;\n  scanf(\"%d %d\", &N, &M);\n\n  if (N == 0)\n    return 1;\n\n  UnionFind uf(N);\n\n  for (int i=0; i<M; ++i) {\n    char ch;\n    scanf(\" %c\", &ch);\n\n    if (ch == '?') {\n      int a, b;\n      scanf(\"%d %d\", &a, &b);\n      --a, --b;\n      if (uf.connected(a, b)) {\n        printf(\"%jd\\n\", uf.relweight(a)-uf.relweight(b));\n      } else {\n        printf(\"UNKNOWN\\n\");\n      }\n    } else if (ch == '!') {\n      int a, b, w;\n      scanf(\"%d %d %d\", &a, &b, &w);\n      --a, --b;\n      uf.unite(a, b, w);\n    }\n  }\n\n  return 0;\n}\n\nint main() {\n  while (!testcase_ends()) {}\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define f first\n#define s second\n#define mp make_pair\n#define inf 1<<30\n#define MAX 1000010\nusing namespace std;\n\nlong long p[MAX],w[MAX];\n\npair<int,int> find(int a){\n  pair<int,int> pii;\n  if(p[a]==a){\n    pii.f=a;pii.s=0;\n    return pii;\n  }\n  pii=find(p[a]);\n  pii.s+=w[a];\n  p[a]=pii.f;\n  w[a]=pii.s;\n  return pii;\n}\n\nint main()\n{\n  int n,q,a,b,d;\n  char c;\n\n  while(cin>>n>>q && n ){\n\n    for(int i=0;i<n;i++){\n      p[i]=i;\n      w[i]=0;\n    }\n\n    for(int i=0;i<q;i++){\n      cin>>c;\n      if(c=='!'){\n\tcin>>a>>b>>d;\n\ta--;b--;\n\tpair<int,int> pa=find(a),pb=find(b);\n\tif(pa.f==pb.f)continue;\n\tp[pa.f]=b;\n\tw[pa.f]=d-pa.s;\n\tp[a]=pb.f;\n\tw[a]=pb.s+d;\n      }\n      else {\n\tcin>>a>>b;\n\ta--;b--;\n\tpair<int,int> pa=find(a),pb=find(b);\n\tif(pa.f!=pb.f)cout<<\"UNKNOWM\"<<endl;\n\telse {\n\t  p[a]=pa.f;\n\t  w[a]=pa.s;\n\t  p[b]=pb.f;\n\t  w[b]=pb.s;\n\t  cout<<pa.s-pb.s<<endl;\n\t}\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\nconst int S = 100010;\n\nstruct UnionFind {\n    vector<int> node;\n    vector<ll> weight;\n    UnionFind() : node(S, -1), weight(S, 0) {}\n    void unite(int u, int v, ll w) {\n        if(find(u) == find(v)) return;\n        if(find(u) > find(v)) swap(u, v), w *= -1;\n\n        // v テ」ツ?ョティツヲツェテ」ツつ?(u テ」ツ?ョティツヲツェ) テ」ツ?ォテ」ツ?、テ」ツ?ェテ」ツ?津」ツつ?\n        ll prev_weight = get_weight(u);\n\tu = find(u);\n        node[u] += node[v];\n        node[v] = u;\n        weight[v] += prev_weight + w;\n    }\n\n    ll get_weight(int u) {\n        ll ret = 0;\n        while(node[u] >= 0) {\n            ret += weight[u];\n            u = node[u];\n        }\n        return ret;\n    }\n\n    int find(int u) {\n      if(node[u] < 0) return u;\n      int val = get_weight(node[u]);\n      weight[u] += val;\n      return node[u] = find(node[u]);\n    }\n};\n\nint main() {\n    int N, M;\n    while(cin >> N >> M, N) {\n        UnionFind uf;\n        for(int i=0; i<M; i++) {\n            char c; cin >> c;\n            if(c == '!') {\n                int a, b, d; cin >> a >> b >> d;\n                a--; b--;\n                uf.unite(a, b, d);\n            }\n            else {\n                int a, b; cin >> a >> b;\n                a--; b--;\n                if(uf.find(a) != uf.find(b)) cout << \"UNKNOWN\" << endl;\n                else {\n                    ll wa = uf.get_weight(a);\n                    ll wb = uf.get_weight(b);\n                    // printf(\"wa = %d, wb = %d\\n\", wa, wb);\n                    cout << wb - wa << endl;\n                }\n            }\n        }\n\n\t/*\n\tfor(int i=0; i<N; i++) {\n\t  printf(\"%d: parent = %d, weight = %lld, value = %lld\\n\", i, uf.node[i], uf.weight[i], uf.get_weight(i));\n\t}\n\t*/\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cstring>\n#include<cstdio>\n\nusing namespace std;\nstruct Info{int par, weight;};\nconst int MAX = 100005;\n\nclass UnionFind{\npublic:\n  \n  Info info[MAX];\n\n  void init(int n){\n    for(int i = 0; i < n; i++) info[i] = (Info){i,0};\n  }\n \n  Info find(int x){\n    if(info[x].par == x) return info[x];\n    \n    Info tmp = find(info[x].par);\n    info[x].weight += tmp.weight;\n    info[x].par = tmp.par;\n    return info[x];\n  }\n\n   void unite(int x, int y, int w){\n    Info X = find(x);\n    Info Y = find(y);\n    //W[x]+w = W[y]\n    \n    info[Y.par].par = X.par;\n    info[Y.par].weight += w+info[x].weight-info[y].weight;\n  }\n   \n  bool same(int x, int y){\n    return find(x).par == find(y).par;\n  }\n\n  int getValue(int x){return info[x].weight;}\n};\n \nint N,M;\nUnionFind uf;\n \nvoid update(){\n  int a,b,c;\n  scanf(\"%d %d %d\\n\",&a,&b,&c);\n  uf.unite(a,b,c);\n}\n \nvoid print(){\n  int a,b;\n  scanf(\"%d %d\\n\",&a,&b);\n  if(uf.same(a,b)) printf(\"%d\\n\",uf.getValue(b)-uf.getValue(a));\n  else printf(\"UNKNOWN\\n\");\n}\n \nint main(){\n   \n \n  while(scanf(\"%d %d\\n\",&N,&M) && N+M){\n    uf.init(N+1);\n    for(int i = 0; i < M; i++){\n      char c;\n      scanf(\"%c\",&c);\n      if(c == '!') update();\n      else print();\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <cassert>\n#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <list>\n#include <set>\n#include <map>\n#include <bitset>\n#include <functional>\n#include <iterator>\n\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<'='<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define iter(c) __typeof__((c).begin())\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();++i)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\nconst int INFTY=1<<29;\nconst double EPS=1e-9;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n\tos<<'[';\n\trep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n\treturn os<<']';\n}\n\nstruct Edge{\n\tint src,dst,weight;\n\tEdge(){};\n\tEdge(int s,int d,int w):src(s),dst(d),weight(w){}\n};\ntypedef vector<vector<Edge>> Graph;\n\nstruct UnionFind{\n\tvi data;\n\tUnionFind(int size):data(size,-1){}\n\tint Find(int n){\n\t\treturn data[n]<0?n:(data[n]=Find(data[n]));\n\t}\n\tvoid Unite(int a,int b){\n\t\tint ra=Find(a),rb=Find(b);\n\t\tif(ra!=rb){\n\t\t\tif(-data[ra]<-data[rb])\n\t\t\t\tswap(ra,rb);\n\t\t\tdata[ra]+=data[rb];\n\t\t\tdata[rb]=ra;\n\t\t}\n\t}\n\tint Size(int n){\n\t\treturn -data[Find(n)];\n\t}\n};\n\nint main()\n{\n\tfor(int n,m;cin>>n>>m;){\n\t\tvi as(m),bs(m),ws(m,-1);\n\t\trep(i,m){\n\t\t\tchar t; cin>>t>>as[i]>>bs[i];\n\t\t\tas[i]--,bs[i]--;\n\t\t\tif(t=='!') cin>>ws[i];\n\t\t}\n\t\t\n\t\tGraph g(n);\n\t\trep(i,m) if(ws[i]!=-1){\n\t\t\tg[as[i]].emplace_back(as[i],bs[i],ws[i]);\n\t\t\tg[bs[i]].emplace_back(bs[i],as[i],-ws[i]);\n\t\t}\n\t\t\n\t\tvi vis(n),ps(n);\n\t\trep(s,n) if(!vis[s]){\n\t\t\tqueue<pii> q; q.emplace(s,0);\n\t\t\twhile(q.size()){\n\t\t\t\tint u,w; tie(u,w)=q.front(); q.pop();\n\t\t\t\tif(vis[u]) continue;\n\t\t\t\tvis[u]=1,ps[u]=w;\n\t\t\t\tfor(Edge e:g[u])\n\t\t\t\t\tq.emplace(e.dst,w+e.weight);\n\t\t\t}\n\t\t}\n\t\t\n\t\tUnionFind uf(n);\n\t\trep(i,m){\n\t\t\tif(ws[i]!=-1) // ! a b w\n\t\t\t\tuf.Unite(as[i],bs[i]);\n\t\t\telse{         // ? a b\n\t\t\t\tif(uf.Find(as[i])==uf.Find(bs[i]))\n\t\t\t\t\tcout<<ps[bs[i]]-ps[as[i]]<<endl;\n\t\t\t\telse\n\t\t\t\t\tcout<<\"UNKNOWN\"<<endl;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, n) for(int i = a; i < n; i++)\n#define int long long\nusing namespace std;\ntypedef pair<int, int> P;\nconst int INF = 1e15;\n\nstruct WeightedUnionFind{\n    vector<int> par;\n    vector<int> sz;\n    vector<int> diff_weight;\n    WeightedUnionFind(int n){\n        par.resize(n);\n        sz.resize(n, 1);\n        diff_weight.resize(n);\n        for(int i = 0; i < n; i++) par[i] = i;\n    }\n    int root(int x){\n        if(x == par[x]) return x;\n        int r = root(par[x]);\n        diff_weight[x] += diff_weight[par[x]];\n        return par[x] = r;\n    }\n    int weight(int x){\n        root(x);\n        return diff_weight[x];\n    }\n    int diff(int x, int y){\n        return weight(y) - weight(x);\n    }\n    bool unite(int x, int y, int w){\n        w += weight(x) - weight(y);\n        x = root(x); y = root(y);\n        if(x == y) return false;\n        if(sz[x] < sz[y]) swap(x, y), w = -w;\n        sz[x] += sz[y];\n        par[y] = x;\n        diff_weight[y] = w;\n        return true;\n    }\n    bool same(int x, int y){\n        return root(x) == root(y);\n    }\n};\n\nsigned main(){\n    int n, m;\n    while(cin >> n >> m, n){\n        WeightedUnionFind uf(n);\n        rep(i, 0, m){\n            char c;\n            int x, y, w;\n            cin >> c >> x >> y;\n            x--; y--;\n            if(c == '!'){\n                cin >> w;\n                uf.unite(x, y, w);\n            }else{\n                if(!uf.same(x, y)){\n                    cout << \"UNKNOWN\" << endl;\n                }else{\n                    cout << uf.diff(x, y) << endl;\n                }\n            }\n        }\n    }   \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n \nusing namespace std;\n \n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n \ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n \ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\ntypedef pair<int, int> P;\nstruct UF{\n  vector<int> data;\n  vector<int> weight;\n  UF(int N) : data(N, -1), weight(N, 0) {}\n  void uni(int x, int y, int w){\n    P px = root(x), py = root(y);\n    if(px.first != py.first){\n      if(data[px.first] > data[px.first]){\n        swap(px, py);\n        w *= -1;\n      }\n      data[px.first] += data[py.first];\n      data[py.first] = px.first;\n      weight[py.first] = px.second - py.second + w;\n    }\n  }\n  P root(int x){\n    if(data[x] < 0) return P(x, 0);\n    P p = root(data[x]);\n    data[x] = p.first;\n    weight[x] += p.second;\n    return P(data[x], weight[x]);\n  }\n};\n \nint main(){\n  int N, M;\n  while(cin>>N>>M && N){\n    UF uf(N);\n    string s; int x, y, z;\n    REP(i, M){\n      cin>>s;\n      if(s == \"!\"){\n        scanf(\"%d %d %d\", &x, &y, &z);\n        x--; y--;\n        uf.uni(x, y, z);\n      }else{\n        scanf(\"%d %d\", &x, &y);\n        x--; y--;\n        P px = uf.root(x);\n        P py = uf.root(y);\n        if(px.first == py.first){\n          printf(\"%d\\n\", py.second - px.second);\n        }else{\n          printf(\"UNKNOWN\\n\");\n        }\n      }\n    }\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\n#include<cstdlib>\n#include<cmath>\nusing namespace std;\nconst int N = 100000+10;\ntypedef long long LL;\nint n,m;\nint f[N];\nLL dis[N];\nint find(int x) {\n    if (x != f[x]) {\n        int pa = f[x];\n        f[x] = find(f[x]);\n        dis[x] += dis[pa];\n    }\n    return f[x];\n}\nvoid solve() {\n    while (m--) {\n        char s[2];\n        int u,v,w;\n        scanf(\"%s\",s);\n        if (s[0] == '!') {\n            scanf(\"%d%d%d\",&u,&v,&w);\n            int x = find(u), y = find(v);\n            if (x != y) {\n                f[x] = y;\n                dis[x] = w;\n            }\n        }else {\n            scanf(\"%d%d\",&u,&v);\n            int x = find(u), y = find(v);\n            if (x == y) {\n                printf(\"%lld\\n\",dis[u] - dis[v]);\n            }else printf(\"UNKNOWN\\n\");\n        }\n    }\n}\nint main(){\n    while (~scanf(\"%d%d\",&n,&m),n+m) {\n        for (int i = 0; i <= n; i++) f[i] = i;\n        memset(dis,0,sizeof(dis));\n        solve();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\nconst int INF = 1000000000;\n#define REP(i,s,n) for(int i=(int)(s);i<(int)(n);i++)\n#define rep(i,n) REP(i, 0, n)\nstruct UnionFind {\n    vector<int> data;\n    vector<ll> rootd;//rootd[i] : dist from node[i] to node[root(i)]\n    UnionFind(int N) : data(N, -1), rootd(N, 0) {}\n    void unite(int x_, int y_, ll weight) {\n        int x = root(x_), y = root(y_);\n        if(x != y){\n            data[x] += data[y];\n            data[y] = x;\n            rootd[y] = weight - rootd[y_];\n        }\n    }\n    int root(int x_) {\n        int x = x_;\n        vector<int> memo;\n        while(data[x] >= 0) {\n            memo.push_back(x);\n            x = data[x];\n        }\n        int res = x;\n        for(int k : memo) {\n            rootd[k] += rootd[data[k]];\n            data[k] = res;\n        }\n        return res;\n    }\n    ll dist(int a, int b) { return rootd[b] - rootd[a];}\n    bool same(int a, int b) { return root(a) == root(b);}\n};\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int N, M;\n    while(cin >> N >> M && N) {\n        UnionFind uf(N);\n        char q; int a, b; ll w;\n        rep(i, M) {\n            cin >> q >> a >> b;\n            --a; --b;\n            if(q == '?') {\n                if(uf.same(a, b)) cout << uf.dist(a, b) << endl;\n                else cout << \"UNKNOWN\" << endl;;\n            }else {\n                cin >> w;\n                uf.unite(b, a, -w);\n            }\n        }\n        rep(i, N) cout << uf.root(i) << ' ' << uf.rootd[i] << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\n#define int ll\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define PB push_back\n\nconst ll LLINF = (1LL<<60);\nconst int INF = (1LL<<30);\nconst int MOD = 1000000007;\n\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate <typename T> bool IN(T a, T b, T x) { return a<=x&&x<b; }\ntemplate<typename T> T ceil(T a, T b) { return a/b + !!(a%b); }\ntemplate<class S,class T>\nostream &operator <<(ostream& out,const pair<S,T>& a){\n  out<<'('<<a.first<<','<<a.second<<')';\n  return out;\n}\ntemplate<class T>\nostream &operator <<(ostream& out,const vector<T>& a){\n  out<<'[';\n  REP(i, a.size()) {out<<a[i];if(i!=a.size()-1)out<<',';}\n  out<<']';\n  return out;\n}\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\nclass UnionFind {\npublic:\n  const static int MAX_N = 100010;\n  int par[MAX_N];\n  int s[MAX_N];\n  UnionFind() { init(); }\n  UnionFind(int n) { init(n); }\n  void init() { for(int i=0; i<MAX_N; ++i) par[i] = i, s[i] = 1; }\n  void init(int n) { for(int i=0; i<n; ++i) par[i] = i, s[i] = 1; }\n  int find(int x) {\n    if(par[x] == x) return x;\n    return par[x] = find(par[x]);\n  }\n  void unite(int x, int y) {\n    x = find(x);\n    y = find(y);\n    if(x == y) return;\n    if(s[x] < s[y]) par[x] = y, s[y] = s[x] + s[y];\n    else par[y] = x, s[x] = s[x] + s[y];\n  }\n  bool same(int x, int y) { return find(x) == find(y);}\n};\nUnionFind uf;\n\nvector<PII> g[100010];\nint d[100010];\nvoid dfs(int x, int p, int dist) {\n  d[x] = dist;\n  for(auto e: g[x]) {\n    if(e.first != p) dfs(e.first, x, dist + e.second);\n  }\n}\n\nsigned main(void)\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  while(true) {\n    int n, m;\n    cin >> n >> m;\n    if(!n) break;\n\n    REP(i, n) g[i].clear();\n    memset(d, 0, sizeof(d));\n    uf.init(n);\n\n    vector<PII> query;\n    VI ans(m+5);\n    int idx = 0;\n    REP(i, m) {\n      char c;\n      int a, b;\n      cin >> c >> a >> b; a--, b--;\n      if(c == '!') {\n        int w; cin >> w;\n        if(!uf.same(a, b)) {\n          uf.unite(a, b);\n          g[a].PB({b, -w});\n          g[b].PB({a, w});\n        }\n      } else {\n        query.PB({a, b});\n        if(!uf.same(a, b)) ans[idx] = LLINF;\n        idx++;\n      }\n    }\n\n    // cout << query << endl;\n    REP(i, n) {\n      if(d[i] == 0) dfs(i, -1, 0);\n      // cout << \"i:\" << i << endl;\n    }\n    // REP(i, n) cout << d[i] << \" \";\n    // cout << endl;\n\n    REP(i, query.size()){\n      if(ans[i]==LLINF) cout << \"UNKNOWN\" << endl;\n      else cout << d[query[i].first] - d[query[i].second] << endl;\n    }\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <set>\n#include <algorithm>\n#include <cstdio>\n#define SENTINEL 99999999\nusing namespace std;\ntypedef pair<int,int> pii;\nclass union_find{\n\tvector<pii>parent;\n\tpii root(int a){\n\t\tif(parent[a].first==a)return parent[a];\n\t\tpii ret=root(parent[a].first);\n\t\treturn parent[a]=make_pair(ret.first,ret.second+parent[a].second);\n\t}\npublic:\n\tunion_find(int n): parent(n){for(int i=0;i<n;i++)parent[i]=make_pair(i,0);}\n\tint dist(int a,int b){\n\t\tpii x=root(a),y=root(b);\n\t\tif(x.first!=y.first)return SENTINEL;\n\t\treturn x.second-y.second;\n\t}\n\tint unite(int a,int b,int w){\n\t\tpii x=root(a),y=root(b);\n\t\tif(x.first==y.first)return 0;\n\t\tif(x.first>y.first)swap(x,y);\n\t\tparent[x.first]=make_pair(y.first,y.second-x.second+w);\n\t\treturn 1;\n\t}\n};\nint main(){\n\tchar s[2];\n\tint N,Q,a,b,w;\n\tfor(;scanf(\"%d%d\",&N,&Q),N;)for(union_find uf(N);Q--;){\n\t\tscanf(\"%s\",s);if(*s=='!'){\n\t\t\tscanf(\"%d%d%d\",&a,&b,&w),a--,b--;\n\t\t\tuf.unite(a,b,w);\n\t\t}else{\n\t\t\tscanf(\"%d%d\",&a,&b),a--,b--;\n\t\t\tw=uf.dist(a,b);\n\t\t\tprintf(w==SENTINEL?\"UNKNOWN\\n\":\"%d\\n\",w);\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define all(v) (v).begin(),(v).end()\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\n#define pb push_back\n#define fi first\n#define se second\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nstruct UF{\n    vint par,sz;\n    vector<set<int>>st;\n    vint dif;\n    void init(int n){\n        par=sz=dif=vint(n);\n        st=vector<set<int>>(n);\n        rep(i,n){\n            par[i]=i;\n            sz[i]=1;\n            dif[i]=0;\n            st[i].insert(i);\n        }\n    }\n    int find(int x){\n        return x==par[x]?x:par[x]=find(par[x]);\n    }\n    void update(int a,int b,int w){\n        int x=find(a),y=find(b);\n        if(x==y)return;\n        if(sz[x]>sz[y]){\n            swap(x,y);\n            swap(a,b);\n            w*=-1;\n        }\n\n        for(auto v:st[x]){\n            dif[v]+=dif[b]-dif[a]-w;\n            st[y].insert(v);\n        }\n        sz[y]+=sz[x];\n        par[x]=y;\n    }\n    int query(int a,int b){\n        int x=find(a),y=find(b);\n        if(x!=y)return 1001001001;\n        return dif[b]-dif[a];\n    }\n};\n\nsigned main(){\n    int N,Q;\n    while(scanf(\"%lld%lld\",&N,&Q),N||Q){\n        UF uf;uf.init(N);\n        rep(i,Q){\n            char c;\n            scanf(\" %c\",&c);\n            if(c=='!'){\n                int a,b,w;\n                scanf(\"%lld%lld%lld\",&a,&b,&w);\n                a--;b--;\n                uf.update(a,b,w);\n            }\n            else{\n                int a,b;\n                scanf(\"%lld%lld\",&a,&b);\n                a--;b--;\n                int tmp=uf.query(a,b);\n                if(tmp==1001001001)puts(\"UNKNOWN\");\n                else printf(\"%lld\\n\",tmp);\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <set>\n#include <algorithm>\n#include <cstdio>\n#define SENTINEL 99999999\nusing namespace std;\ntypedef pair<int,int> pii;\nclass union_find{\n\tvector<pii>parent;\n\tpii root(int a){\n\t\tif(parent[a].first==a)return parent[a];\n\t\tpii ret=root(parent[a].first);\n\t\treturn parent[a]=make_pair(ret.first,ret.second+parent[a].second);\n\t}\npublic:\n\tunion_find(int n): parent(n){for(int i=0;i<n;i++)parent[i]=make_pair(i,0);}\n\tint dist(int a,int b){\n\t\tpii x=root(a),y=root(b);\n\t\tif(x.first!=y.first)return SENTINEL;\n\t\treturn y.second-x.second;\n\t}\n\tint unite(int a,int b,int w){\n\t\tpii x=root(a),y=root(b);\n\t\tif(x.first==y.first)return 0;\n\t\tparent[x.first]=make_pair(y.first,x.second-y.second+w);\n\t\treturn 1;\n\t}\n};\nint main(){\n\tchar s[2];\n\tint N,Q,a,b,w;\n\tfor(;scanf(\"%d%d\",&N,&Q),N;)for(union_find uf(N);Q--;){\n\t\tscanf(\"%s\",s);if(*s=='!'){\n\t\t\tscanf(\"%d%d%d\",&a,&b,&w),a--,b--;\n\t\t\tuf.unite(a,b,w);\n\t\t}else{\n\t\t\tscanf(\"%d%d\",&a,&b),a--,b--;\n\t\t\tw=uf.dist(a,b);\n\t\t\tprintf(w==SENTINEL?\"UNKNOWN\\n\":\"%d\\n\",w);\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n//#include <utility>\n#include <set>\n#include <iostream>\n//#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n//#include <functional>\n#include <sstream>\n//#include <deque>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstdio>\n//#include <cctype>\n#include <cstring>\n//#include <ctime>\n#include <iterator>\n#include <bitset>\n//#include <numeric>\n//#include <list>\n//#include <iomanip>\n\n#if __cplusplus >= 201103L\n#include <array>\n#include <tuple>\n#include <initializer_list>\n#include <unordered_set>\n#include <unordered_map>\n#include <forward_list>\n\n#define cauto const auto&\n#else\n\n#endif\n\nusing namespace std;\n\n\nnamespace{\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef vector<int> vint;\ntypedef vector<vector<int> > vvint;\ntypedef vector<long long> vll, vLL;\ntypedef vector<vector<long long> > vvll, vvLL;\n\n#define VV(T) vector<vector< T > >\n\ntemplate <class T>\nvoid initvv(vector<vector<T> > &v, int a, int b, const T &t = T()){\n    v.assign(a, vector<T>(b, t));\n}\n\ntemplate <class F, class T>\nvoid convert(const F &f, T &t){\n    stringstream ss;\n    ss << f;\n    ss >> t;\n}\n\n\n#define reep(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n) reep((i),0,(n))\n#define ALL(v) (v).begin(),(v).end()\n#define PB push_back\n#define F first\n#define S second\n#define mkp make_pair\n#define RALL(v) (v).rbegin(),(v).rend()\n\n\n#define MOD 1000000007LL\n#define EPS 1e-8\nstatic const int INF=1<<24;\nvector<pii> v;\nvint w;\npii foo(int x){\n\tif(v[x].F==x) return v[x];\n\tpii t=foo(v[x].F);\n\treturn v[x]=mkp(t.F,v[x].S+t.S);\n}\n\nvoid mainmain(){\n\tint n,m;\n\twhile(cin>>n>>m,n||m){\n\t\tv=vector<pii>(n);\n\t\tw=vint(n);\n\t\trep(i,n){\n\t\t\tv[i]=mkp(i,0);\n\t\t\tw[i]=0;\n\t\t}\n\t\t// cout<<\"hoge\";\n\t\trep(i,m){\n\t\t\tchar t;\n\t\t\tcin>>t;\n\t\t\tif(t=='!'){\n\t\t\t\tint a,b,r;\n\t\t\t\tcin>>a>>b>>r;\n\t\t\t\trep(i,n){\n\t\t\t\t}\n\t\t\t\t// cout<<a<<\" \"<<b<<\" \"<<r<<endl;\n\t\t\t\tpii c=foo(a-1),d=foo(b-1);\n\t\t\t\t// cout<<c.F<<endl;\n\t\t\t\tif(w[c.F]<w[d.F]){\n\t\t\t\t\tv[c.F]=mkp(d.F,d.S-c.S-r);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tv[d.F]=mkp(c.F,c.S-d.S+r);\n\t\t\t\t\tif(w[c.F]==w[d.F]){\n\t\t\t\t\t\tw[c.F]++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tint a,b;\n\t\t\t\tcin>>a>>b;\n\t\t\t\trep(i,n){\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\t// cout<<a<<\" \"<<b<<endl;\n\t\t\t\tpii c=foo(a-1),d=foo(b-1);\n\t\t\t\tif(c.F==d.F){\n\t\t\t\t\tcout<<-c.S+d.S<<endl;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tcout<<\"UNKNOWN\\n\";\n\t\t\t\t}\n\t\t\t}\n\t\t\t/*\n\t\t\tcout<<endl<<\"--------\\n\";\n\t\t\trep(i,n){\n\t\t\t\tcout<<v[i].F<<\" \"<<v[i].S<<\" \"<<w[i]<<endl;\n\t\t\t}\n\t\t\tcout<<\"-----------\\n\";\n\t\t\t*/\n\t\t}\n\t}\n}\n\n\n\n}\nmain() try{\n    mainmain();\n}\ncatch(...){\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int ui;\nconst ll mod = 1000000009;\nconst ll INF = (ll)1000000007 * 1000000007;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ld eps = 1e-4;\nconst ld pi = acos(-1.0);\ntypedef pair<ll, ll> LP;\ntypedef pair<ld, ld> LDP;\ntypedef vector<vector<ll>> mat;\ntypedef vector<ll> vec;\n\nint par[100000];\nint rank1[100000];\nll d[1 << 17];\nvoid init(int n) {\n\tfor (int i = 0; i < n; i++) {\n\t\tpar[i] = i;\n\t\trank1[i] = 0;\n\t\td[i] = 0;\n\t}\n}\npair<int,ll> find(int x) {\n\tif (par[x] == x) {\n\t\treturn { x,0 };\n\t}\n\telse {\n\t\td[x] += find(par[x]).second;\n\t\tpar[x] = find(par[x]).first;\n\t\treturn { par[x],d[x] };\n\t}\n}\nvoid unite(int x, int y,ll c) {\n\tll mx = x, my = y;\n\tx = find(x).first;\n\ty = find(y).first;\n\tll m1 = d[mx], m2 = d[my];\n\tif (x == y) {\n\t\t/*if (m2 - m1 != c) {\n\t\t\tcout << \"?????!\" << endl;\n\t\t}*/\n\t\treturn;\n\t}\n\tif (rank1[x] < rank1[y]) {\n\t\tpar[x] = y;\n\t\td[x] = m2-m1- c;\n\t}\n\telse {\n\t\tpar[y] = x;\n\t\tif (rank1[x] == rank1[y])rank1[x]++;\n\t\td[y] = m1-m2 +c;\n\t}\n}\nbool same(int x, int y) {\n\treturn find(x).first == find(y).first;\n}\nint main() {\n\tint n, m;\n\twhile (cin >> n >> m, n) {\n\t\tinit(n);\n\t\trep(i, m) {\n\t\t\tchar ord; cin >> ord;\n\t\t\tif (ord == '!') {\n\t\t\t\tint le, ri; ll z; cin >> le >> ri >> z; le--; ri--;\n\t\t\t\tunite(le, ri, z);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tint le, ri; cin >> le >> ri; le--; ri--;\n\t\t\t\tif (!same(le, ri)) {\n\t\t\t\t\tcout << \"UNKNOWN\" << endl;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tcout << d[ri] - d[le] << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}/*\n\t\trep(i, n) {\n\t\t\tcout << d[i] << endl;\n\t\t}*/\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// Wrongri-La Shower\n\n#include <cstdio>\n#include <queue>\n#include <stack>\n#include <tuple>\n\ntypedef std::tuple<int,int> P;\n\ntemplate <int n>\nclass UnionFind{\npublic:\n    UnionFind(){\n        init();\n    }\n    void init(){\n        for(int i=0;i<n;i++){\n            par[i] = i;\n            rank[i] = 0;\n            weight[i] = 0;\n        }\n    }\n    P find(int x){\n        if(x == par[x])return std::make_tuple(x, weight[x]);\n\n        std::stack<int> v_stack;\n        std::queue<int> w_queue;\n        int w = 0;\n        while(x != par[x]){\n            w += weight[x];\n            w_queue.push(w);\n            v_stack.push(x);\n\n            x = par[x];\n        }\n        \n        while(!v_stack.empty()){\n            int a, b;\n            a = v_stack.top(); v_stack.pop();\n            b = w_queue.front(); w_queue.pop();\n            \n            par[a] = x;\n            weight[a] = b;\n        }\n        \n        return std::make_tuple(x, w);\n    }\n    bool same(int x, int y){\n        return std::get<0>(find(x)) == std::get<0>(find(y));\n    }\n    void unite(int x, int y, int l){\n        P xp = find(x), yp = find(y);\n        int wx, wy;\n        std::tie(x, wx) = xp;\n        std::tie(y, wy) = yp;\n        \n        if(x == y){return;}\n        \n        if(rank[x] > rank[y]){\n            par[y] = x;\n            weight[y] = wx + l;\n        }else{\n            par[x] = y;\n            weight[x] = wy - l;\n            if(rank[x] == rank[y]){rank[y]++;}\n        }\n    }\n    int rank[n], par[n], weight[n];\n};\n\nUnionFind<100001> uf;\n\nint main(){\n    int N, M;\n    while(scanf(\"%d %d\", &N, &M), N || M){\n        uf.init();\n\n        for(int i=0;i<M;i++){\n            char c;\n            scanf(\"%*c%c\", &c);\n\n            if(c == '!'){\n                int a, b, c;\n                scanf(\"%d %d %d\", &a, &b, &c);\n\n                uf.unite(a, b, c);\n            }else{\n                int a, b;\n                scanf(\"%d %d\", &a, &b);\n\n                if(!uf.same(a, b)){\n                    puts(\"UNKNOWN\");\n                }else{\n                    P ap = uf.find(a), bp = uf.find(b);\n                    int wa = std::get<1>(ap), wb = std::get<1>(bp);\n\n                    printf(\"%d\\n\", wb - wa);\n                }\n            }\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cassert>\n#include<algorithm>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<28)\n#define MAX 1000000\nusing namespace std;\nstruct P\n{\n  int color,w;\n  P(int color=-inf,int w=-inf):color(color),w(w){}\n};\nP par[MAX];\nvoid init(){ rep(i,MAX)par[i] = P(i); }\n\nP find(int x)\n{\n  if(x == par[x].color)return par[x];\n  P p = find(par[x].color);\n  if(par[x].color == -inf)par[x].color = 0;\n  par[x].w += p.w,par[x].color = p.color;\n  return par[x];\n}\n\nvoid unit(int x,int y,int w)//x <= y\n{\n  P X = find(x);\n  P Y = find(y);\n  assert(X.color != Y.color);\n  par[X.color].color = par[Y.color].color;\n  if(par[X.color].w == -inf)par[X.color].w = 0;\n  if(par[Y.color].w == -inf)par[Y.color].w = 0;\n  par[X.color].w = par[X.color].w - w + (Y.w != -inf?Y.w:0);\n}\n\nint N,M;\n\nint main()\n{\n  while(cin >> N >> M,N|M)\n    {\nassert(false);\n      init();\n      char c;\n      int a,b,w;\n      rep(_,M)\n\t{\n\t  cin >> c;\n\t  if(c == '!')\n\t    {\n\t      cin >> a >> b >> w;\n\t      unit(a,b,w);\n\t    }\n\t  else\n\t    {\n\t      cin >> a >> b;\n\t      int B = find(b).w;\n\t      int A = find(a).w;\n\t      if(B == -inf || A == -inf)cout << \"UNKNOWN\" << endl;\n\t      else cout << B-A << endl;\n\t    }\n\t\n\t}\n    }\n  return 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <cstdint>\n\nclass UnionFind {\n  std::vector<int> vertex;\n  std::vector<intmax_t> weight;\n\npublic:\n  UnionFind(size_t V): vertex(V, -1), weight(V, 0) {}\n\n  bool unite(size_t u, size_t v, intmax_t w) {\n    //if (u >= 0) u = find(u);\n    //if (v >= 0) v = find(v);\n    if (u == v) return false;\n    if (vertex[find(u)] > vertex[find(v)]) {\n      std::swap(u, v);\n      w = -w;\n    }\n\n    // u:parent, v:child\n    vertex[find(u)] += vertex[find(v)];\n    vertex[find(v)] = u;\n    weight[v] = w;\n    return true;\n  }\n\n  int find(size_t v) const {\n    while (vertex[v] >= 0)\n      v = vertex[v];\n\n    return v;\n  }\n\n  bool connected(size_t u, size_t v) const {\n    return find(u) == find(v);\n  }\n\n  intmax_t relweight(size_t u) const {\n    if (vertex[u] < 0) {\n      return 0;\n    }\n\n    return weight[u] + relweight(vertex[u]);\n  }\n};\n\nint testcase_ends() {\n  int N, M;\n  scanf(\"%d %d\", &N, &M);\n\n  if (N == 0)\n    return 1;\n\n  UnionFind uf(N);\n\n  for (int i=0; i<M; ++i) {\n    char ch;\n    scanf(\" %c\", &ch);\n\n    if (ch == '?') {\n      int a, b;\n      scanf(\"%d %d\", &a, &b);\n      if (uf.connected(a, b)) {\n        printf(\"%jd\\n\", uf.relweight(b)-uf.relweight(a));\n      } else {\n        printf(\"UNKNOWN\\n\");\n      }\n    } else if (ch == '!') {\n      int a, b, w;\n      scanf(\"%d %d %d\", &a, &b, &w);\n      uf.unite(a, b, w);\n    }\n  }\n\n  return 0;\n}\n\nint main() {\n  while (!testcase_ends()) {}\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define f first\n#define s second\n#define mp make_pair\n#define inf 1<<30\n#define MAX 100001\nusing namespace std;\n\nint p[MAX],w[MAX];\nmap<pair<int,int>,int> M;\n\npair<int,int> find(int a){\n  pair<int,int> pii;\n  if(p[a]==a){\n    pii.f=a;pii.s=0;\n    return pii;\n  }\n  pii=find(p[a]);\n  pii.s+=w[a];\n  p[a]=pii.f;\n  w[a]=pii.s;\n  return pii;\n}\n\nint main()\n{\n  int n,q,a,b,d;\n  char c;\n\n  while(cin>>n>>q && n ){\n    for(int i=0;i<n;i++){\n      p[i]=i;\n      w[i]=0;\n    }\n    M.clear();\n\n    for(int i=0;i<q;i++){\n      cin>>c;\n      if(c=='!'){\n\tcin>>a>>b>>d;\n\ta--;b--;\n\tpair<int,int> pa=find(a);\n\tp[pa.f]=b;\n\tw[pa.f]=d-w[a]+w[b];\n      }\n      else {\n\tcin>>a>>b;\n\ta--;b--;\n\tpair<int,int> pa=find(a),pb=find(b);\n\tif(pa.f!=pb.f)cout<<\"UNKNOWM\"<<endl;\n\telse {\n\t  p[a]=pa.f;\n\t  w[a]=pa.s;\n\t  p[b]=pb.f;\n\t  w[b]=pb.s;\n\t  cout<<pa.s-pb.s<<endl;\n\t}\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define f first\n#define s second\n#define mp make_pair\n#define inf 1<<30\n#define MAX 1000010\nusing namespace std;\n\nlong long p[MAX],w[MAX];\n\npair<int,int> find(int a){\n  pair<int,int> pii;\n  if(p[a]==a){\n    pii.f=a;pii.s=0;\n    return pii;\n  }\n  pii=find(p[a]);\n  pii.s+=w[a];\n  p[a]=pii.f;\n  w[a]=pii.s;\n  return pii;\n}\n\nint main()\n{\n  int n,q,a,b,d;\n  char c;\n\n  while(cin>>n>>q && n ){\n    for(int i=0;i<n;i++){\n      p[i]=i;\n      w[i]=0;\n    }\n    M.clear();\n\n    for(int i=0;i<q;i++){\n      cin>>c;\n      if(c=='!'){\n\tcin>>a>>b>>d;\n\ta--;b--;\n\tpair<int,int> pa=find(a);\n\tp[pa.f]=b;\n\tw[pa.f]=d+w[a]+w[b];\n      }\n      else {\n\tcin>>a>>b;\n\ta--;b--;\n\tpair<int,int> pa=find(a),pb=find(b);\n\tif(pa.f!=pb.f)cout<<\"UNKNOWM\"<<endl;\n\telse {\n\t  p[a]=pa.f;\n\t  w[a]=pa.s;\n\t  p[b]=pb.f;\n\t  w[b]=pb.s;\n\t  cout<<pa.s-pb.s<<endl;\n\t}\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<vector>\n#include<utility>\n\nusing namespace std;\n\nvector<pair<int, int> > UFtree(100010);\n\nint root_Diff(int i) {\n  if(UFtree[i].first == i) return 0;\n  else return UFtree[i].second + root_Diff(UFtree[i].first);\n}\n\nint root(int i) {\n  if(UFtree[i].first == i) return i;\n  else {\n    UFtree[i].second = root_Diff(i);\n    return (UFtree[i].first = root(UFtree[i].first));\n  }\n}\n\nbool is_same_set(int i, int j) {\n  return root(i) == root(j);\n}\n\n\n\nvoid unite(int i, int j, int w) {//w_i-w_j = w\n  int x, y;\n  x = root(i); y = root(j);\n  UFtree[y].first = x;\n  UFtree[y].second = w + UFtree[i].second - UFtree[j].second;\n}\n\nint main() {\n  int N, M;\n  while(cin >> N >> M) {\n    if(!N) break;\n    for(int i = 1; i <= N; i++){\n      UFtree[i] = make_pair(i, 0);\n    }\n    string word;\n    int a, b, w;\n    for(int i = 0; i < M; i++) {\n      cin >> word >> a >> b;\n      if(word == \"!\") {\n\tcin >> w;\n\tunite(b, a, w);\n      }\n      else {\n\tif(is_same_set(a, b)) cout << root_Diff(a) - root_Diff(b) << endl;\n\telse cout << \"UNKNOWN\" << endl;\n      }\n    }\n    UFtree.clear();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// Wrongri-La Shower\n\n#include <iostream>\n#include <queue>\n#include <stack>\n#include <tuple>\n\ntypedef long long ll;\ntypedef std::tuple<int,ll> P;\n\ntemplate <int n>\nclass UnionFind{\npublic:\n    UnionFind(){\n        init();\n    }\n    void init(){\n        for(int i=0;i<n;i++){\n            par[i] = i;\n            rank[i] = 0;\n            weight[i] = 0ll;\n        }\n    }\n    P find(int x){\n        if(x == par[x])return std::make_tuple(x, weight[x]);\n        P p = find(par[x]);\n        int y, w;\n        std::tie(y, w) = p;\n        \n        return std::make_tuple(par[x] = y, weight[x] += w);\n    }\n    bool same(int x, int y){\n        return std::get<0>(find(x)) == std::get<0>(find(y));\n    }\n    void unite(int x, int y, int l){\n        P xp = find(x), yp = find(y);\n        ll wx, wy;\n        std::tie(x, wx) = xp;\n        std::tie(y, wy) = yp;\n        \n        if(x == y){return;}\n        \n        if(rank[x] > rank[y]){\n            par[y] = x;\n            weight[y] = wx - wy + l;\n        }else{\n            par[x] = y;\n            weight[x] = wy - wx - l;\n            if(rank[x] == rank[y]){rank[y]++;}\n        }\n    }\n    int rank[n], par[n];\n    ll weight[n];\n};\n\nUnionFind<100001> uf;\n\nint main(){\n    std::ios_base::sync_with_stdio(false);\n    \n    int N, M;\n    while(std::cin >> N >> M, N || M){\n        uf.init();\n\n        for(int i=0;i<M;i++){\n            char c;\n            std::cin >> c;\n\n            if(c == '!'){\n                int a, b, c;\n                std::cin >> a >> b >> c;\n\n                uf.unite(a, b, c);\n            }else{\n                int a, b;\n                std::cin >> a >> b;\n\n                if(!uf.same(a, b)){\n                    std::cout << \"UNKNOWN\" << std::endl;\n                }else{\n                    P ap = uf.find(a), bp = uf.find(b);\n                    ll wa = std::get<1>(ap), wb = std::get<1>(bp);\n\n                    std::cout << wb-wa << std::endl;\n                }\n            }\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> lpair;\nconst ll MOD = 1e9 + 7;\nconst ll INF = 1e18;\n#define rep(i,m,n) for(ll i = (m); i < (n); i++)\n#define rrep(i,m,n) for(ll i = (m); i >= (n); i--)\n#define print(x) cout << (x) << endl;\n#define print2(x,y) cout << (x) << \" \" << (y) << endl;\n#define printa(x,n) for(ll i = 0; i < n; i++){ cout << (x[i]) << \" \";} cout<<endl;\nstruct UnionFind {\nprivate:\n    ll N;\n    vector<ll> parent;\n    vector<ll> num;\n    vector<ll> diff_weight;\n\npublic:\n    UnionFind(ll n){\n        N = n;\n        rep(i,0,N) parent.push_back(i);\n        rep(i,0,N) num.push_back(1);\n        rep(i,0,N) diff_weight.push_back(0);\n    }\n    ll root(ll x){\n        if(x == parent[x]){\n            return x;\n        }else{\n            ll r = root(parent[x]);\n            diff_weight[x] += diff_weight[parent[x]];\n            return parent[x] = r;\n        }\n    }\n    void unite(ll a, ll b, ll w = 0){\n        w += weight(a); w -= weight(b);\n        a = root(a); b = root(b);\n        if(a == b) return;\n        parent[b] = a;\n        ll sum = num[a] + num[b];\n        num[a] = sum;\n        num[b] = sum;\n        diff_weight[b] = w;\n    }\n\n    bool same(ll a, ll b){ return root(a) == root(b);}\n    ll sz(ll x){ return num[x];}\n\n    ll weight(ll x){\n        root(x);\n        return diff_weight[x];\n    }\n\n    ll diff(ll a, ll b){\n        return weight(b) - weight(a);\n    }\n};\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    ll N,M;\n    while(cin >> N >> M){\n        UnionFind uf(100010);\n        while(M--){\n            char c;\n            cin >> c;\n            if(c == '!'){\n                ll a,b,c;\n                cin >> a >> b >> c;\n                a--; b--;\n                uf.unite(a,b,c);\n\n            }else{\n                ll a,b;\n                cin >> a >> b;\n                a--; b--;\n                if(not uf.same(a,b)){\n                    print(\"UNKNOWN\");\n                }else{\n                    print(uf.diff(a,b));\n                }\n            }\n\n        }\n\n    }\n    \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define sz(a) ((int)(a).size())\n\ntypedef long long ll;\n\nconst int INF = 1e9;\n\nstruct UFnode\n{\n  int value_;\n  int rank_, p_, index_, size_, weight_;\n  UFnode(int value) : value_(value), rank_(0), p_(-1), size_(1), weight_(0) {}\n  int size() const { return size_; }\n};\n\nstruct UF\n{\n  vector<UFnode> ufnodes_;\n  map<int, int> value_to_index_;\n  int size_;\n\n  UF() : size_(0) {}\n  int size() const { return size_; }\n  int tree_size(int value)\n  {\n    if (value_to_index_.count(value) == 0) { return 0; }\n    int pix = ufnodes_[value_to_index_[value]].p_;\n    return ufnodes_[pix].size();\n  }\n\n  void make_set(int value)\n  {\n    UFnode node(value);\n    ufnodes_.push_back(node);\n    int ix = ufnodes_.size() - 1;\n    ufnodes_[ix].index_ = ufnodes_[ix].p_ = value_to_index_[value] = ix;\n    ++size_;\n  }\n\n  int find_set(int value, int index = -1)\n  {\n    pair<int, int> p = find_set2(value, index);\n    return p.first;\n  }\n\n  pair<int, int> find_set2(int value, int index = -1)\n  {\n    if (index == -1) {\n      if (value_to_index_.count(value) == 0) { return make_pair(-1, -1); }\n      index = value_to_index_[value];\n    }\n    if (ufnodes_[index].p_ != index) {\n      pair<int, int> p = find_set2(ufnodes_[ufnodes_[index].p_].value_, ufnodes_[index].p_);\n      ufnodes_[index].p_ = p.first;\n      ufnodes_[index].weight_ += p.second;\n    }\n    return make_pair(ufnodes_[index].p_, ufnodes_[index].weight_);\n  }\n\n  int find_weight(int value)\n  {\n    pair<int, int> p = find_set2(value);\n    if (p.first == -1) { return -1; }\n    return p.second;\n  }\n\n  // w[y] - w[x] = weight\n  void unite(int x, int y, int weight)\n  {\n    pair<int, int> p1 = find_set2(x), p2 = find_set2(y);\n    int s1 = p1.first, s2 = p2.first;\n    int w = weight + p1.second - p2.second;\n    if ((s1 == s2) || (s1 == -1) || (s2 == -1)) { return; }\n    if (ufnodes_[s1].rank_ > ufnodes_[s2].rank_) {\n      ufnodes_[s2].p_ = s1;\n      ufnodes_[s2].weight_ = w;\n      ufnodes_[s1].size_ += ufnodes_[s2].size_;\n    }\n    else {\n      ufnodes_[s1].p_ = s2;\n      ufnodes_[s1].weight_ = -w;\n      ufnodes_[s2].size_ += ufnodes_[s1].size_;\n      if (ufnodes_[s1].rank_ == ufnodes_[s2].rank_) { ++ufnodes_[s2].rank_; }\n    }\n    --size_;\n  }\n\n  bool is_connected(int x, int y) { return find_set(x) == find_set(y); }\n};\n\nint main()\n{\n  while (true) {\n    int n = 0, m = 0;\n    fscanf(stdin, \"%d %d\", &n, &m);\n    if (n == 0 && m == 0) { break; }\n    UF uf;\n    for (int i = 1; i <= n; ++i) {\n      uf.make_set(i);\n    }\n    for (int i = 0; i < m; ++i) {\n      char ch;\n      int a, b, d;\n      fscanf(stdin, \" %c\", &ch);\n      if (ch == '!') {\n        fscanf(stdin, \" %d %d %d\", &a, &b, &d);\n        uf.unite(a, b, d);\n      }\n      else if (ch == '?') {\n        fscanf(stdin, \" %d %d\", &a, &b);\n        if (uf.is_connected(a, b)) {\n          int wb = uf.find_weight(b);\n          int wa = uf.find_weight(a);\n          fprintf(stdout, \"%d\\n\", wb - wa);\n        }\n        else {\n          fprintf(stdout, \"UNKNOWN\\n\");\n        }\n      }\n      else {\n        return -1;\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define all(v) (v).begin(),(v).end()\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\n#define pb push_back\n#define fi first\n#define se second\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nstruct UF{\n    vint par,sz;\n    vector<set<int>>st;\n    vint dif;\n    void init(int n){\n        par=sz=dif=vint(n);\n        st=vector<set<int>>(n);\n        rep(i,n){\n            par[i]=i;\n            sz[i]=1;\n            dif[i]=0;\n            st[i].insert(i);\n        }\n    }\n    int find(int x){\n        return x==par[x]?x:par[x]=find(par[x]);\n    }\n    void update(int a,int b,int w){\n        int x=find(a),y=find(b);\n        if(x==y)return;\n        if(sz[x]>sz[y]){\n            swap(x,y);\n            swap(a,b);\n            w*=-1;\n        }\n        \n        int d=dif[b]-dif[a];\n        each(it,st[x]){\n            int v=*it;\n            dif[v]+=d-w;\n            st[y].insert(v);\n        }\n        sz[y]+=sz[x];\n        par[x]=y;\n    }\n    int query(int a,int b){\n        int x=find(a),y=find(b);\n        if(x!=y)return 1001001001;\n        return dif[b]-dif[a];\n    }\n};\n\nsigned main(){\n    UF uf;uf.init(10);\n    uf.update(0,1,111);\n    uf.update(2,3,111);\n    uf.update(1,3,111);\n    for(auto v:uf.st[uf.find(0)])cout<<v<<\" \";cout<<endl;\n\n    int N,Q;\n    while(scanf(\"%lld%lld\",&N,&Q),N||Q){\n        UF uf;uf.init(N);\n        rep(i,Q){\n            char c;\n            scanf(\" %c\",&c);\n            if(c=='!'){\n                int a,b,w;\n                scanf(\"%lld%lld%lld\",&a,&b,&w);\n                a--;b--;\n                uf.update(a,b,w);\n            }\n            else{\n                int a,b;\n                scanf(\"%lld%lld\",&a,&b);\n                a--;b--;\n                int tmp=uf.query(a,b);\n                if(tmp==1001001001)puts(\"UNKNOWN\");\n                else printf(\"%lld\\n\",tmp);\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nclass WeightedDisjointSets\n{\nprivate:\n    using T = int;\n    vector<int> parent, rank;\n    vector<T> weight;\n\npublic:\n    WeightedDisjointSets(const int v) : parent(v), rank(v, 0), weight(v, 0) { iota(parent.begin(), parent.end(), 0); }\n    bool same(const int a, const int b) { return find(a) == find(b); }\n    int find(const int a) { return parent[a] == a ? a : (weight[a] += weight[parent[a]], parent[a] = find(parent[a])); }\n    T getWeight(const int a) { return find(a), weight[a]; }\n    void unite(int a, int b, T d)\n    {\n        d += getWeight(a) - getWeight(b);\n        a = find(a), b = find(b);\n        if (a == b) { return; }\n        if (rank[a] < rank[b]) { swap(a, b), d = -d; }\n        if (rank[a] == rank[b]) { rank[a]++; }\n        parent[b] = a, weight[b] = d;\n    }\n    T diff(const int a, const int b) { return getWeight(b) - getWeight(a); }\n};\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while (true) {\n        int N, M;\n        cin >> N >> M;\n        if (N == 0 and M == 0) { break; }\n        WeightedDisjointSets uf(N);\n        for (int i = 0; i < M; i++) {\n            char c;\n            int a, b;\n            cin >> c >> a >> b;\n            a--, b--;\n            if (c == '!') {\n                int c;\n                cin >> c;\n                uf.unite(a, b, c);\n            } else {\n                cout << (uf.same(a, b) ? to_string(uf.diff(a, b)) : \"UNKNOWN\") << \"\\n\";\n            }\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "class in{struct It{int it;const bool rev;explicit constexpr It(int it_, bool rev=false):it(it_),rev(rev){}int operator*(){return it;}bool operator!=(It& r){return it!=r.it;}void operator++(){rev?--it:++it;}};const It i,n;public:explicit constexpr in(int n):i(0),n(n<0?0:n){}explicit constexpr in(int i,int n):i(i,n<i),n(n){}const It& begin(){return i;}const It& end(){return n;}};\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nusing i64 = long long;\n\nstruct UnionFind {\n    vector<int> data;\n    vector<i64> rootd;//rootd[i] : dist from node[i] to node[root(i)]\n    vector<int> memo;\n    explicit UnionFind() {}\n    void init(int N) {\n        data.assign(N, -1);\n        rootd.assign(N, 0);\n    }\n    void unite(int x_, int y_, i64 weight) {\n        int x = root(x_), y = root(y_);\n        if(x != y){\n            data[x] += data[y];\n            data[y] = x;\n            rootd[y] = weight - rootd[y_] + rootd[x_];\n        }\n    }\n    int root(int x) {\n        memo.clear();\n        while(data[x] >= 0) {\n            memo.emplace_back(x);\n            x = data[x];\n        }\n        int res = x;\n        for(int i = memo.size() - 1; i >= 0; --i) {\n            int k = memo[i];\n            rootd[k] += rootd[data[k]];\n            data[k] = res;\n        }\n        return res;\n    }\n    i64 dist(int a, int b) { return rootd[b] - rootd[a];}\n    bool same(int a, int b) { return root(a) == root(b);}\n};\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n, m;\n    UnionFind uf;\n    while(cin >> n >> m && n) {\n        uf.init(n);\n        char q; int a, b; i64 w;\n        for(int _ : in(m)) {\n            cin >> q >> a >> b;\n            --a; --b;\n            if(q == '?') {\n                if(uf.same(a, b))\n                    cout << uf.dist(a, b) << '\\n';\n                else\n                    cout << \"UNKNOWN\" << '\\n';;\n            }\n            else {\n                cin >> w;\n                uf.unite(a, b, w);\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<map>\n#include<set>\n#include<vector>\n#include<algorithm>\n#include<string.h>\n#include<queue>\n#include<stack>\n#include<climits>\n#include<cmath>\nusing namespace std;\n\nmap<int,vector<pair<int,int> > >ma;\nset<int>visited;\nint ans=0;\nbool dfs(int a,int b,int c,bool p){\n    if(a==b){\n        ans=c;\n        return true;\n    }\n    for(auto i : ma[a]){\n        if(!visited.count(i.first)){\n            if(dfs(i.first,b,p?c+i.second:c-i.second,p)){\n                return true;\n            }\n        }\n    }\n    for(auto i : ma[b]){\n        if(!visited.count(i.first)){\n            if(dfs(i.first,a,p?c-i.second:c+i.second,!p)){\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\nint main(){\n    int n,m;\n    while(cin>>n>>m,n){\n        ma.clear();\n        for(int i=0;i<m;i++){\n            char c;\n            cin>>c;\n            if(c=='!'){\n                int a,b,d;\n                cin>>a>>b>>d;\n                ma[a].push_back(make_pair(b, d));\n            } else {\n                int a,b;\n                cin>>a>>b;\n                if(dfs(a,b,0,1)){\n                    cout<<ans<<endl;\n                } else {\n                    cout<<\"UNKNOWN\"<<endl;\n                }\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<bitset>\n#include<algorithm>\nusing namespace std;\n#define MAX_N 100100\n\nclass uf_extention{\nprivate:\n\tint parents[MAX_N];\n\tint rank[MAX_N];\n\t//extention\n\tint dis[MAX_N][MAX_N];\npublic:\n\tuf_extention(){\n\t\tfor(int i=0;i<MAX_N;i++){\n\t\t\tparents[i]=i;\n\t\t\trank[i]=0;\n\t\t\t//extention\n\t\t\tfor(int j=0;j<MAX_N;j++){\n\t\t\t\tdis[i][j]=0;\n\t\t\t}\n\t\t}\n\t}\n\tuf_extention(int n){\n\t\tfor(int i=0;i<n;i++){\n\t\t\tparents[i]=i;\n\t\t\trank[i]=0;\n\t\t\t//extention\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tdis[i][j]=0;\n\t\t\t}\n\t\t\t\n\t\t}\n\t}\n\tint find(int x){\n\t\tif(parents[x]==x){\n\t\t\treturn x;\n\t\t}else{\n\t\t\t//extention\n\t\t\tint tmp=find(parents[x]);\n\t\t\t//cout<<\"find \"<<dis[x][parents[x]]<<\" \"<<dis[parents[x]][tmp]<<\" x=\"<<x<<\" p[x]=\"<<parents[x]<<\" tmp=\"<<tmp<<endl;\n\t\t\tdis[x][tmp]=dis[x][parents[x]]+dis[parents[x]][tmp];\n\t\t\tdis[tmp][x]=dis[x][tmp]*(-1);\n\t\t\treturn parents[x]=tmp;\n\t\t}\n\t}\n\tvoid unite(int x,int y,int distance){\n\t\t//cout<<\"unite\"<<x<<\" \"<<y<<\" dis=\"<<distance<<endl;\n\t\tdis[x][y]=distance;\n\t\tdis[y][x]=distance*(-1);\n\t\tint parx=find(x);\n\t\tint pary=find(y);\n\t\tif(parx==pary)return;\n\t\tdis[parx][pary]=dis[parx][x]+dis[x][y]+dis[y][pary];\n\t\tdis[pary][parx]=(-1)*dis[parx][pary];\n\t\tif(rank[parx]<rank[pary]){\n\t\t\t//cout<<parx<<\"'s parents is\"<<pary<<endl;\n\t\t\tparents[parx]=pary;\n\t\t}else{\n\t\t\t//cout<<pary<<\"'s parents is\"<<parx<<endl;\n\t\t\tparents[pary]=x;\n\t\t\tif(rank[parx]==rank[pary])rank[parx]++;\n\t\t}\n\t}\n\tint same(int x,int y){\n\t\t//cout<<\"same\"<<x<<\" \"<<y<<endl;\n\t\tint tmpx=find(x);\n\t\tint tmpy=find(y);\n\t\tif(tmpx==tmpy){\n\t\t\t//cout<<dis[x][tmpx]<<\" x=\"<<x<<\" tmpx=\"<<tmpx<<\" \"<<dis[tmpx][y]<<\" tmpy=\"<<tmpy<<\" y=\"<<y<<endl;\n\t\t\treturn dis[x][tmpx]+dis[tmpx][y];\n\t\t}else{\n\t\t\treturn -2000000;\n\t\t}\n\t}\n};\n\n\nint main(){\n\tchar c;\n\tint a,b,w;\n\tint n,m;\n\twhile(cin>>n>>m,n!=0||m!=0){\n\t\tuf_extention uf(n+1);\n\t\tfor(int i=0;i<m;i++){\n\t\t\tcin>>c;\n\t\t\tif(c=='!'){\n\t\t\t\tcin>>a>>b>>w;\n\t\t\t\tuf.unite(a,b,w);\n\t\t\t}else if(c=='?'){\n\t\t\t\tcin>>a>>b;\n\t\t\t\tint tmp=uf.same(a,b);\n\t\t\t\tif(tmp==-2000000){\n\t\t\t\t\tcout<<\"UNKNOWN\"<<endl;\n\t\t\t\t}else{\n\t\t\t\t\tcout<<tmp<<endl;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tcout<<\"???\"<<endl;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\n#define int long long \nint uf[100100];\nint weight[100100];\n\nint root(int x){\n\tif( uf[x] < 0 ){\n\t\twhile( weight[x] != 0 );\n\t\treturn x;\n\t}else{\n\t\tweight[x] += weight[uf[x]];\n\t\treturn uf[x]=root(uf[x]);\n\t}\n}\n\n// x-y=w (x,y,w)\nint unite(int x,int y,int w){\n\tint x2 = root(x);\n\tint y2 = root(y);\n\tw = weight[x] + w - weight[y]; \n\tif( x2 != y2 ){\n\t\tuf[x2] += uf[y2];\n\t\tuf[y2] = x2;\n\t\tweight[y2] = w;\n\t\treturn true;\n\t}\n\treturn false;\n}\nint wei(int x){\n\troot(x);\n\treturn weight[x];\n}\n\nsigned main(){\n\tint N,M;\n\twhile(cin >> N >> M && N){\n\t\tfor(int i = 0 ; i < N ; i++ ) uf[i] = -1, weight[i] = 0;\n\t\tfor(int i = 0 ; i < M ; i++){\n\t\t\tchar c;\n\t\t\tcin >> c;\n\t\t\tint a,b;\n\t\t\tcin >> a >> b;\n\t\t\t--a,--b;\n\t\t\tif( c == '!' ){\n\t\t\t\tint w;\n\t\t\t\tcin >> w;\n\t\t\t\tunite(a,b,w);\n\t\t\t}else{\n\t\t\t\tif( root(a) != root(b) ) cout << \"UNKNOWN\" << endl;\n\t\t\t\telse cout << wei(b) - wei(a) << endl;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<stdio.h>\n\nusing namespace std;\nint p[100000];\nint rank[100000];\nint weight[100000];\n\n  void makeSet(int x){\n    p[x]=x;\n    rank[x]=0;\n    weight[x]=0;\n  }\n int findSet(int x){\n    if(x==p[x]){\n      return x;\n    }else{\n      return findSet(p[x]);\n    }\n  }\n  bool same(int x,int y){\n    return findSet(x)==findSet(y);\n  }\n  void link(int x,int y){   \n    p[x]=y;\n    if(rank[x]>=rank[y]){  \n      rank[y]=rank[x]+1;\n    }\n  }\n   void unite(int x,int y,int w){\n    weight[x]=w;\n    link(x,y);\n  }\n\n  int depth(int x){\n    int ans=0;\n    ans+=weight[x];\n    while(x!=p[x]){\n      ans+=weight[p[x]];\n      x=p[x];\n    }\n    return ans;\n  }\n\nint main(){\n  int n,m;\n  while(scanf(\"%d%d\",&n,&m)){\n    if(!n&&!m){\n      break;\n    }else{\n      char query[5];\n     for(int I=0;i<n;i++){\nmakeSet(i);\n}\n      for(int i=0;i<m;i++){\n        scanf(\"%s\",query);\n        if(query[0]=='!'){\n          int a,b,w;\n          scanf(\"%d%d%d\",&a,&b,&w);\n          ds.unite(a,b,w);\n        }else{\n          int c,d;\n          scanf(\"%d%d\",&c,&d);\n          if(!ds.same(c,d)){\n            printf(\"UNKNOWN\\n\");\n          }else{\n            printf(\"%d\\n\",ds.depth(c)-ds.depth(d));\n          }\n        }\n      }\n    }\n  }\n  return 0;\n}\n      "
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<unordered_map>\n#include<queue>\n#include<iomanip>\n#include<math.h>\n#include<bitset>\n#include<cassert>\n#include<random>\n#include<time.h>\nusing namespace std;\nusing ll=long long;\nusing ld=long double;\nusing P=pair<int,int>;\n#define MOD 1000000007LL\n#define INF 1000000000LL\n#define EPS 1e-10\n#define FOR(i,n,m) for(ll i=n;i<(ll)m;i++)\n#define REP(i,n) FOR(i,0,n)\n#define DUMP(a) REP(d,a.size()){cout<<a[d];if(d!=a.size()-1)cout<<\" \";else cout<<endl;}\n#define ALL(v) v.begin(),v.end()\n#define UNIQUE(v)  sort(ALL(v));v.erase(unique(ALL(v)),v.end());\n#define pb push_back\n\n/* --------------------------------------- */\n\nclass union_find {\npublic:\n\tunion_find(int n)\n\t: par_(n, P(-1, 0))\n\t{}\n\n\tP root(int x) {\n\t\tif(par_[x].first < 0) return P(x, 0);\n\t\tP tmp = root(par_[x].first);\n\t\tpar_[x].first = tmp.first;\n\t\tpar_[x].second += tmp.second;\n\t\treturn par_[x];\n\t}\n\n\tbool unite(int x, int y, int w) {\n\t\tll px = root(x).first, py = root(y).first;\n\t\tif(px == py) {\n\t\t\treturn false;\n\t\t} else {\n\t\t\tif(par_[px].first < par_[py].first) {\n\t\t\t\tpar_[px].first += par_[py].first;\n\t\t\t\tpar_[py].first = px;\n\t\t\t\tpar_[py].second = (par_[x].second + w) - par_[y].second;\n\t\t\t} else {\n\t\t\t\tpar_[py].first += par_[px].first;\n\t\t\t\tpar_[px].first = py;\n\t\t\t\tpar_[px].second = (par_[y].second - w) - par_[x].second;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tbool same(int x, int y) {\n\t\treturn root(x).first == root(y).first;\n\t}\n\n\tbool compare(int x, int y, ll& result) {\n\t\tif(!same(x, y)) return false;\n\t\tresult = root(y).second - root(x).second;\n\t\treturn true;\n\t}\n\tstd::vector<P> par_;\n};\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\twhile(1) {\n\t\tll n, m;\n\t\tcin >> n >> m;\n\t\tif(n == 0 && m == 0) break;\n\t\tunion_find uf(n);\n\t\tREP(i,m) {\n\t\t\tchar c;\n\t\t\tcin >> c;\n\t\t\tif(c == '!') {\n\t\t\t\tll a, b, w;\n\t\t\t\tcin >> a >> b >> w;\n\t\t\t\ta--; b--;\n\t\t\t\tuf.unite(a, b, w);\n\t\t\t}\n\t\t\tif(c == '?') {\n\t\t\t\tll a, b;\n\t\t\t\tcin >> a >> b;\n\t\t\t\ta--; b--;\n\t\t\t\tll result = 0;\n\t\t\t\tif(!uf.compare(a, b, result)) {\n\t\t\t\t\tcout << \"UNKNOWN\" << endl;\n\t\t\t\t} else {\n\t\t\t\t\tcout << result << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\n/* --------------------------------------- */\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <utility>\n\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nconst int UNKNOWN=2000000;\nconst int MAX_N=100000,MAX_M=100000;\n\nint N,M;\nchar type[MAX_M+1];\nint a[MAX_M],b[MAX_M],w[MAX_M];\n\nint p[MAX_N],cost[MAX_N],height[MAX_N];\t//union find??¨\n\nvector<int> out;\n\nvoid init(int n){\n\tfor (int i=0;i<n;i++){\n\t\tp[i]=i;\n\t\tcost[i]=0;\n\t\theight[i]=0;\n\t}\n\treturn;\n}\n\nP find(int i){\n\t//????????????????????????\n\tif (i==p[i]){\n\t\treturn P(i,0);\t//first=?????????,second=?????????\n\t}\n\tP pa=find(p[i]);\n\tp[i]=pa.first;\n\tcost[i]+=pa.second;\n\treturn P(p[i],cost[i]);\n}\n\nvoid solve(){\n\tinit(N);\n\tfor (int i=0;i<M;i++){\n\t\tP roota=find(a[i]);\n\t\tP rootb=find(b[i]);\n\t\tif (type[i]=='!'){\n\t\t\tif (height[roota.first]<height[rootb.first]){\n\t\t\t\tp[roota.first]=rootb.first;\n\t\t\t\tcost[roota.first]=w[i]+rootb.second-roota.second;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tp[rootb.first]=roota.first;\n\t\t\t\tcost[rootb.first]=roota.second-rootb.second-w[i];\n\t\t\t\tif (height[roota.first]==height[rootb.first]){\n\t\t\t\t\theight[roota.first]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tif (roota.first!=rootb.first){\n\t\t\t\tout.push_back(UNKNOWN);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tout.push_back(roota.second-rootb.second);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\tdo{\n\t\tscanf(\"%d %d\",&N,&M);\n\t\tif (N || M){\n\t\t\tfor (int i=0;i<M;i++){\n\t\t\t\tscanf(\" %c %d %d\",&type[i],&a[i],&b[i]);\n\t\t\t\tif (type[i]=='!'){\n\t\t\t\t\tscanf(\"%d\",&w[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tsolve();\n\t\t}\n\t}while(N || M);\n\tfor (int i=0;i<out.size();i++){\n\t\tif (out[i]==UNKNOWN){\n\t\t\tprintf(\"%s\\n\",\"UNKNOWN\");\n\t\t}\n\t\telse{\n\t\t\tprintf(\"%d\\n\",out[i]);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdio>\nusing namespace std;\n\nconst int M=1000005;\nint n,m,x,y,tmp;\nint p[M];\nint fa[M];\nchar c[5];\n\nvoid init(){\n    for(int i=0;i<M;i++) fa[i]=i;\n    memset(p,0,sizeof(p));\n}\n\nint getfa(int x){\n    if(fa[x]==x) return fa[x];\n    else {\n        int t=fa[x];\n        getfa(fa[x]);\n        p[x]+=p[t];\n        return fa[x]=getfa(fa[x]);\n    }\n}\n\nint main(){\n    while(scanf(\"%d %d\",&n,&m),n){\n        init();\n        while(m--){\n            scanf(\"%s %d %d\",c,&x,&y);\n            if(c[0]=='!'){\n                scanf(\"%d\",&tmp);\n                int xx=getfa(x);\n                int yy=getfa(y);\n                if(xx!=yy) {\n                    fa[xx]=yy;\n                    //cout<<getfa(x)<<' '<<getfa(y)<<endl;\n                    p[x]-=tmp;\n                }\n            }\n            else {\n                int xx=getfa(x);\n                int yy=getfa(y);\n                if(xx==yy) printf(\"%d\\n\",p[y]-p[x]);\n                else puts(\"UNKNOWN\");\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nclass WeightedDisjointSets\n{\nprivate:\n    using T = ll;\n    vector<int> parent, rank;\n    vector<T> weight;\n\npublic:\n    WeightedDisjointSets(const int v) : parent(v), rank(v, 0), weight(v, 0) { iota(parent.begin(), parent.end(), 0); }\n    bool same(const int a, const int b) { return find(a) == find(b); }\n    int find(const int a) { return parent[a] == a ? a : (weight[a] += weight[parent[a]], parent[a] = find(parent[a])); }\n    T getWeight(const int a) { return find(a), weight[a]; }\n    void unite(int a, int b, T d)\n    {\n        d += getWeight(a) - getWeight(b);\n        a = find(a), b = find(b);\n        if (a == b) { return; }\n        if (rank[a] < rank[b]) { swap(a, b), d = -d; }\n        rank[a] += rank[b], parent[b] = a, weight[b] = d;\n    }\n    T diff(const int a, const int b) { return getWeight(b) - getWeight(a); }\n};\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while (true) {\n        int N, M;\n        cin >> N >> M;\n        if (N == 0 and M == 0) { break; }\n        WeightedDisjointSets uf(N);\n        for (int i = 0; i < M; i++) {\n            char c;\n            int a, b;\n            cin >> c >> a >> b;\n            a--, b--;\n            if (c == '!') {\n                ll c;\n                cin >> c;\n                uf.unite(a, b, c);\n            } else {\n                cout << (uf.same(a, b) ? to_string(uf.diff(a, b)) : \"UNKNOWN\") << \"\\n\";\n            }\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define MOD 1000000007\n#define INF 1e9\n#define rep(i,n) for (int i = 0; i < (n); ++i)\n#define all(x) (x).begin(),(x).end()\n\ntemplate<class Abel> struct UnionFind {\n    vector<int> par;\n    vector<int> rank;\n    vector<Abel> diff_weight;\n\n    UnionFind(int n = 1, Abel SUM_UNITY = 0) {\n        init(n, SUM_UNITY);\n    }\n\n    void init(int n = 1, Abel SUM_UNITY = 0) {\n        par.resize(n); rank.resize(n); diff_weight.resize(n);\n        for (int i = 0; i < n; ++i) par[i] = i, rank[i] = 0, diff_weight[i] = SUM_UNITY;\n    }\n\n    int root(int x) {\n        if (par[x] == x) {\n            return x;\n        }\n        else {\n            int r = root(par[x]);\n            diff_weight[x] += diff_weight[par[x]];\n            return par[x] = r;\n        }\n    }\n\n    Abel weight(int x) {\n        root(x);\n        return diff_weight[x];\n    }\n\n    bool issame(int x, int y) {\n        return root(x) == root(y);\n    }\n\n    bool merge(int x, int y, Abel w) {\n        w += weight(x); w -= weight(y);\n        x = root(x); y = root(y);\n        if (x == y) return false;\n        if (rank[x] < rank[y]) swap(x, y), w = -w;\n        if (rank[x] == rank[y]) ++rank[x];\n        par[y] = x;\n        diff_weight[y] = w;\n        return true;\n    }\n\n    Abel diff(int x, int y) {\n        return weight(y) - weight(x);\n    }\n};\n\nint main(){\n    while(1){\n        int n,m;\n        cin>>n>>m;\n        if(n==0 && m==0) break;\n        UnionFind<int> uf(n);\n        rep(i,m){\n            char s;\n            cin>>s;\n            if(s=='!'){\n                int a,b,w;\n                cin>>a>>b>>w;\n                a--,b--;\n                uf.merge(a,b,w);\n            }\n            else{\n                int a,b;\n                cin>>a>>b;\n                a--,b--;\n                if(!uf.issame(a,b)) cout<<\"UNKNOWN\"<<endl;\n                else cout<<uf.diff(a,b)<<endl;\n            }\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#pragma warning(disable : 4996)\nusing namespace std;\npair<int, long long> par[100000];\npair<int, long long> root(int x) {\n\tif (par[x].first == x) return par[x];\n\tpair<int, long long> ret = root(par[x].first);\n\treturn par[x] = make_pair(ret.first, ret.second + par[x].second);\n}\nbool same(int x, int y) {\n\treturn root(x).first == root(y).first;\n}\nvoid unite(int x, int y, int w) { \n\tpair<int, long long> tx = root(x);\n\tpair<int, long long> ty = root(y);\n\tif (tx.first != ty.first) {\n\t\tpar[tx.first] = make_pair(ty.first, ty.second - tx.second + w);\n\t}\n}\nlong long query(int a, int b) {\n\treturn root(a).second - root(b).second;\n}\nint N, Q, a, b, w; char c;\nint main() {\n\twhile (true) {\n\t\tscanf(\"%d%d\", &N, &Q);\n\t\tif (N == 0 && Q == 0) break;\n\t\tfor (int i = 0; i < N; i++) par[i] = make_pair(i, 0);\n\t\tfor (int i = 0; i < Q; i++) {\n\t\t\tcin >> c;\n\t\t\tif (c == '!') {\n\t\t\t\tscanf(\"%d%d%d\", &a, &b, &w);\n\t\t\t\tunite(a - 1, b - 1, w);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tscanf(\"%d%d\", &a, &b);\n\t\t\t\tif (!same(a - 1, b - 1)) {\n\t\t\t\t\tprintf(\"UNKNOWN\\n\");\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tprintf(\"%lld\\n\", query(a - 1, b - 1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cassert>\n#include<algorithm>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<28)\n#define MAX 1000000\nusing namespace std;\nstruct P\n{\n  int color,w;\n  P(int color=-inf,int w=-inf):color(color),w(w){}\n};\nP par[MAX];\nvoid init(){ rep(i,MAX)par[i] = P(i); }\n\nP find(int x)\n{\n  if(x == par[x].color)return par[x];\n  P p = find(par[x].color);\n  if(par[x].color == -inf)par[x].color = 0;\n  par[x].w += p.w,par[x].color = p.color;\n  return par[x];\n}\n\nvoid unit(int x,int y,int w)//x <= y\n{\n  P X = find(x);\n  P Y = find(y);\n  if(X.color == Y.color)assert(false);\n  par[X.color].color = par[Y.color].color;\n  if(par[X.color].w == -inf)par[X.color].w = 0;\n  if(par[Y.color].w == -inf)par[Y.color].w = 0;\n  par[X.color].w = par[X.color].w - w + (Y.w != -inf?Y.w:0);\n}\n\nint N,M;\n\nint main()\n{\n  while(cin >> N >> M,N|M)\n    {\n      init();\n      char c;\n      int a,b,w;\n      rep(_,M)\n\t{\n\t  cin >> c;\n\t  if(c == '!')\n\t    {\n\t      cin >> a >> b >> w;\n\t      unit(a,b,w);\n\t    }\n\t  else\n\t    {\n\t      cin >> a >> b;\n\t      int B = find(b).w;\n\t      int A = find(a).w;\n\t      if(B == -inf || A == -inf)cout << \"UNKNOWN\" << endl;\n\t      else cout << B-A << endl;\n\t    }\n\t\n\t}\n    }\n  return 0;\n} "
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n\n#include <cstdio>\n#include <cstdlib>\n#include <string.h>\n#include <iostream>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n\nusing namespace std;\n\ntypedef pair<long long int, long long int> P;\nlong long int INF = 1e18;\nlong long int MOD = 1000000007;\n\n#define MAX_N 200000\n\nusing namespace std;\n\nint par[MAX_N];\nint rnk[MAX_N];\nlong long int diff[MAX_N];\n\n// 初期化\nvoid init(int n){\n\tfor(int i = 0; i < n; i++){\n\t\tpar[i] = i;\n\t\trnk[i] = 0;\n\t\tdiff[i] = 0;\n\t}\n}\n\n// x の親を返す\nP find(int x){\n\tP p;\n\tif(par[x] == x){\n\t\tp.first = x;\n\t\tp.second = 0;\n\t\treturn p;\n\t}\n\tp = find(par[x]);\n\tdiff[x] += p.second;\n\tp.second = diff[x];\n\tpar[x] = p.first;\n\treturn p;\n}\n\n// x と y を併合する\nvoid unite(int x, int y, int z){\n\tP px = find(x);\n\tP py = find(y);\n\tint x_par = px.first;\n\tint y_par = py.first;\n\tif(x_par == y_par){\n\t\treturn;\n\t}\n\t\n\tif(rnk[x_par] < rnk[y_par]){\n\t\tpar[x_par] = y_par;\n\t\tdiff[x_par] = diff[y_par] - px.second + py.second + z;\n\t}else{\n\t\tpar[y_par] = x_par;\n\t\tdiff[y_par] = diff[x_par] + px.second - py.second - z;\n\t\tif(rnk[x_par] == rnk[y_par]){\n\t\t\trnk[x_par]++;\n\t\t}\n\t}\n}\n\n// x, y が同じグループか判定\nbool same(int x, int y){\n\tP px = find(x);\n\tP py = find(y);\n\tint x_par = px.first;\n\tint y_par = py.first;\n\treturn (x_par == y_par);\n}\n\nint main(){\n\t\n\twhile(true){\n\t\tint n, q;\n\t\tcin >> n >> q;\n\t\tif(n == 0){\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tinit(n + 1);\n\t\t\n\t\tfor(int i = 0; i < q; i++){\n\t\t\tstring str;\n\t\t\tcin >> str;\n\t\t\tint a, b, c;\n\t\t\t\n\t\t\tif(str == \"!\"){\n\t\t\t\tcin >> a >> b >> c;\n\t\t\t\tunite(a, b, c);\n\t\t\t}else{\n\t\t\t\tcin >> a >> b;\n\t\t\t\tif(!same(a, b)){\n\t\t\t\t\tcout << \"UNKNOWN\" << endl;\n\t\t\t\t}else{\n\t\t\t\t\tcout << diff[a] - diff[b] << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <array>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <iterator>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <tuple>\n#include <unordered_map>\n#include <unordered_set>\n#include <utility>\n#include <vector>\nusing namespace std;\n\n#define dump(a) (cerr << (#a) << \" = \" << (a) << endl)\n\ntemplate<class T> inline void chmax(T& a, const T& b) { if(b > a) a = b; }\ntemplate<class T> inline void chmin(T& a, const T& b) { if(b < a) a = b; }\n\ntemplate<typename T, typename U>\nostream& operator<<(ostream& os, const pair<T, U>& p) {\n\tos << '(' << p.first << \", \" << p.second << ')';\n\treturn os;\n}\n\ntemplate<class Tuple, unsigned Index>\nvoid print_tuple(ostream& os, const Tuple& t) {}\n\ntemplate<class Tuple, unsigned Index, class Type, class... Types>\nvoid print_tuple(ostream& os, const Tuple& t) {\n\tif(Index > 0) os << \", \";\n\tos << get<Index>(t);\n\tprint_tuple<Tuple, Index + 1, Types...>(os, t);\n}\n\ntemplate<class... Types>\nostream& operator<<(ostream& os, const tuple<Types...>& t) {\n\tos << '(';\n\tprint_tuple<tuple<Types...>, 0, Types...>(os, t);\n\treturn os << ')';\n}\n\ntemplate<class Iterator>\nostream& dump_range(ostream&, Iterator, const Iterator&);\n\ntemplate<typename T>\nostream& operator<<(ostream& os, vector<T> c) {\n\treturn dump_range(os, c.cbegin(), c.cend());\n}\n\ntemplate<class Iterator>\nostream& dump_range(ostream& os, Iterator first, const Iterator& last) {\n\tos << '[';\n\tfor(int i = 0; first != last; ++i, ++first) {\n\t\tif(i) os << \", \";\n\t\tos << *first;\n\t}\n\treturn os << ']';\n}\n\nconstexpr long long INF = 0xffffffffffff;\n\nclass union_find {\nprivate:\n\tvector<int> uf;\n\tvector<long long> pd;\n\npublic:\n\tunion_find(int n):uf(n, -1), pd(n, 0) {}\n\t\n\tinline int find(int x) {\n\t\tif(uf[x] < 0)\n\t\t\treturn x;\n\n\t\tconst int tmp = uf[x];\n\t\tuf[x] = find(uf[x]);\n\t\tpd[x] += pd[tmp];\n\t\treturn uf[x];\n\t}\n\n\tinline int dist_root(int x) {\n\t\tfind(x);\n\t\treturn pd[x];\n\t}\n\t\n\tinline void unite(int xx, int yy, int d) {\n\t\tint x = find(xx), y = find(yy);\n\t\tif(x == y)\n\t\t\treturn;\n\t\t\n\t\td += pd[yy] - pd[xx];\n\t\tif(uf[x] < uf[y]) {\n\t\t\tswap(x, y);\n\t\t\td = -d;\n\t\t}\n\n\t\telse if(uf[x] == uf[y])\n\t\t\t--uf[y];\n\t\t\n\t\tuf[x] = y;\n\t\tpd[x] = d;\n\t}\n\t\n\tinline bool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\n\tinline long long get_dist(int x, int y) {\n\t\treturn !same(x, y) ? INF : dist_root(x) - dist_root(y);\n\t}\n};\n\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tfor(int n, m; cin >> n >> m && n;) {\n\t\tunion_find uf(n);\n\t\tfor(int i = 0; i < m; ++i) {\n\t\t\tchar q;\n\t\t\tint a, b;\n\t\t\tcin >> q >> a >> b;\n\n\t\t\t--a;\n\t\t\t--b;\n\n\t\t\tif(q == '!') {\n\t\t\t\tint d;\n\t\t\t\tcin >> d;\n\t\t\t\tuf.unite(a, b, d);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tconst long long ans = uf.get_dist(a, b);\n\t\t\t\tif(ans == INF)\n\t\t\t\t\tcout << \"UNKNOWN\" << endl;\n\t\t\t\telse\n\t\t\t\t\tcout << ans << endl;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(ll i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define show(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define show(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<ll,ll> pii;\ntemplate<typename T> using vec=std::vector<T>;\n\nconst int inf=1<<30;\nconst long long int infll=1LL<<62;\nconst double eps=1e-9;\nconst ll dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nclass union_find{\n\tprivate:\n\tvector<ll> parent,diff;\n    ll size;\n\tpublic:\n    union_find()=default;\n    union_find(ll n){ init(n); }\n\n    void init(int n){\n\t\tsize=n;\n\t\tparent.resize(size);\n        diff.resize(size);\n\t\tfor(ll i=0; i<size; ++i){\n\t\t\tparent[i]=i;\n            diff[i]=0;\n\t\t}\n\t}\n\n\tpii find(int x){\n\t\tif(parent[x]==x) return make_pair(x,0);\n        pii p=find(parent[x]);\n        parent[x]=p.first;\n        diff[x]+=p.second;\n        return make_pair(parent[x],diff[x]);\n\t}\n\n\tvoid unite(int x,int y,int w){\n\t\tpii a=find(x),b=find(y);\n\t\tif(a.first==b.first) return;\n        if(diff[y]+w-diff[x]>=0){\n            parent[a.first]=b.first;\n            diff[a.first]=diff[y]+w-diff[x];\n        }else{\n            parent[b.first]=a.first;\n            diff[b.first]=-diff[y]-w+diff[x];\n        }\n\t}\n\n\tbool is_same(int x,int y){\n\t\treturn find(x).first==find(y).first;\n\t}\n\n    ll calc_diff(int x,int y){\n        auto a=find(x),b=find(y);\n        return find(x).second-find(y).second;\n    }\n};\n\nvoid solve(int n,int m){\n    union_find uf(n);\n\n    rep(i,0,m){\n        char ch;\n        ll a,b;\n        cin >> ch >> a >> b;\n        --a;\n        --b;\n        if(ch=='!'){\n            int w;\n            cin >> w;\n            uf.unite(a,b,w);\n        }else{\n            if(!uf.is_same(a,b)) cout << \"UNKNOWN\" << endl;\n            else cout << uf.calc_diff(a,b) << endl;\n        }\n    }\n}\n\nint main(){\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    cout.setf(ios::fixed);\n    cout.precision(10);\n    while(true){\n        ll n,m;\n        cin >> n >> m;\n        if(!n and !m) break;\n        solve(n,m);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\nlong long dist[1 << 18];\nlong long group[1 << 18]; char q;\nlong long n, Q, a, b, c;\nvector<long long>gr[1 << 18];\nint main() {\n\tfor (int t = 0; t < 15; t++) {\n\t\tfor (int i = 0; i < 1 << 18; i++) {\n\t\t\tdist[i] = 0; group[i] = i; gr[i].clear(); gr[i].push_back(i);\n\t\t}\n\t\tcin >> n >> Q; if (n == 0 && Q == 0)break;\n\t\tfor (int i = 0; i < Q; i++) {\n\t\t\tcin >> q;\n\t\t\tif (q == '?') {\n\t\t\t\tcin >> a >> b;\n\t\t\t\tif (group[a] != group[b])cout << \"UNKNOWN\" << endl;\n\t\t\t\telse cout << dist[b] - dist[a] << endl;\n\t\t\t}\n\t\t\tif (q == '!') {\n\t\t\t\tcin >> a >> b >> c;\n\t\t\t\tif (group[a] != group[b]) {\n\t\t\t\t\tint K = dist[a] + c - dist[b];\n\t\t\t\t\tint L = group[a], M = group[b];\n\t\t\t\t\tfor (int j = 0; j < gr[M].size(); j++) {\n\t\t\t\t\t\tgroup[gr[M][j]] = L;\n\t\t\t\t\t\tgr[L].push_back(gr[M][j]);\n\t\t\t\t\t\tdist[gr[M][j]] += K;\n\t\t\t\t\t}\n\t\t\t\t\tgr[M].clear();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst double pi=3.141592653589793;\ntypedef unsigned long long ull;\ntypedef long double ldouble;\nconst ll INF=1e18;\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\n#define rep2(i, s, n) for (int i = (s); i < (int)(n); i++)\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\n\ntemplate<class Abel> struct UnionFind {\n    vector<int> par;\n    vector<int> rank;\n    vector<Abel> diff_weight;\n\n    UnionFind(int n = 1, Abel SUM_UNITY = 0) {\n        init(n, SUM_UNITY);\n    }\n\n    void init(int n = 1, Abel SUM_UNITY = 0) {\n        par.resize(n); rank.resize(n); diff_weight.resize(n);\n        for (int i = 0; i < n; ++i) par[i] = i, rank[i] = 0, diff_weight[i] = SUM_UNITY;\n    }\n\n    int root(int x) {\n        if (par[x] == x) {\n            return x;\n        }\n        else {\n            int r = root(par[x]);\n            diff_weight[x] += diff_weight[par[x]];\n            return par[x] = r;\n        }\n    }\n\n    Abel weight(int x) {\n        root(x);\n        return diff_weight[x];\n    }\n\n    bool issame(int x, int y) {\n        return root(x) == root(y);\n    }\n\n    bool merge(int x, int y, Abel w) {\n        w += weight(x); w -= weight(y);\n        x = root(x); y = root(y);\n        if (x == y) return false;\n        if (rank[x] < rank[y]) swap(x, y), w = -w;\n        if (rank[x] == rank[y]) ++rank[x];\n        par[y] = x;\n        diff_weight[y] = w;\n        return true;\n    }\n\n    Abel diff(int x, int y) {\n        return weight(y) - weight(x);\n    }\n};\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1330\n\nint main(){\n    int n, m, a, b, d;\n    char c;\n    while(cin >> n >> m){\n        if(n == 0) break;\n        UnionFind<int> uf(n);\n        rep(i, m){\n            cin >> c;\n            if(c == '!'){\n                cin >> a >> b >> d;\n                --a;\n                --b;\n                uf.merge(a, b, d);\n            }\n            else if(c == '?'){\n                cin >> a >> b;\n                a--;\n                b--;\n                if(uf.issame(a, b)){\n                    cout << uf.diff(a, b) << endl;\n                }\n                else {\n                    puts(\"UNKNOWN\");\n                }\n            }\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n\nusing namespace std;\nint weight[10000];\n\nclass DisjointSet{\npublic:\n  vector<int> rank,p;\n\n  DisjointSet(){}\n  DisjointSet(int size){\n    rank.resize(size,0);\n    p.resize(size,0);\n    for(int i=0;i<size;i++){\n      makeSet(i);\n      weight[i]=0;\n    }\n  }\n\n  void makeSet(int x){\n    p[x]=x;\n    rank[x]=0;\n  }\n  bool same(int x,int y){\n    return findSet(x)==findSet(y);\n  }\n  void unite(int x,int y,int w){\n    weight[x]=w;\n    link(x,y);\n  }\n  void link(int x,int y){   \n    p[x]=y;\n    if(rank[x]==rank[y]){  \n      rank[y]++;\n    }else if(rank[x]>rank[y]){\n      rank[y]=rank[x]+1;\n    }\n  }\n  int findSet(int x){\n    if(x==p[x]){\n      return x;\n    }else{\n      return findSet(p[x]);\n    }\n  }\n  int depth(int x){\n    int ans=0;\n    ans+=weight[x];\n    while(x!=p[x]){\n      ans+=weight[p[x]];\n      x=p[x];\n    }\n    return ans;\n  }\n};\nint main(){\n  int n,m;\n  while(scanf(\"%d%d\",&n,&m)){\n    if(!n&&!m){\n      break;\n    }else{\n      string query;\n      DisjointSet ds=DisjointSet(n);\n      for(int i=0;i<m;i++){\n        cin>>query;\n        if(query==\"!\"){\n          int a,b,w;\n          scanf(\"%d%d%d\",&a,&b,&w);\n          ds.unite(a,b,w);\n        }else{\n          int c,d;\n          scanf(\"%d%d\",&c,&d);\n          if(!ds.same(c,d)){\n            printf(\"UNKNOWN\\n\");\n          }else{\n            printf(\"%d\\n\",ds.depth(c)-ds.depth(d));\n          }\n        }\n      }\n    }\n  }\n  return 0;\n}\n      "
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n//BEGIN CUT HERE\ntemplate <typename T> \nstruct WeightedUnionFind{\n  int n;\n  T d;\n  vector<int> r,p;\n  vector<T> ws;\n  WeightedUnionFind(){}\n  WeightedUnionFind(int sz,T d_):\n    n(sz),d(d_),r(n,1),p(n),ws(n,d){iota(p.begin(),p.end(),0);}\n  int find(int x){\n    if(x==p[x]){\n      return x;\n    }else{\n      int t=find(p[x]);\n      ws[x]+=ws[p[x]];\n      return p[x]=t;\n    }\n  }\n  T weight(int x){\n    find(x);\n    return ws[x];\n  }\n  bool same(int x,int y){\n    return find(x)==find(y);\n  }\n  void unite(int x,int y,T w){\n    w+=weight(x);\n    w-=weight(y);\n    x=find(x);y=find(y);\n    if(x==y) return;\n    if(r[x]<r[y]) swap(x,y),w=-w;\n    r[x]+=r[y];\n    p[y]=x;\n    ws[y]=w;\n  }\n  T diff(int x,int y){\n    return weight(y)-weight(x);\n  }\n};\n//END CUT HERE\nsigned main(){\n  int n,m;\n  while(cin>>n>>m,n||m){\n    WeightedUnionFind<Int> u(n,0);\n    for(int i=0;i<m;i++){\n      int a,b;\n      char c;\n      cin>>c>>a>>b;\n      a--;b--;\n      if(c=='!'){\n\tInt w;\n\tcin>>w;\n\tu.unite(a,b,w);\n      }else{\n\tif(!u.same(a,b)) cout<<\"UNKNOWN\"<<endl;\n\telse cout<<u.diff(a,b)<<endl;\n      }\n    }\n  }\n  return 0;\n}\n/*\n  verified on 2017/10/29\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1330\n*/"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nstruct UnionFind{\n\t// (parent, offset_from_parent)\n\tvector<P> uf;\n\t\n\tUnionFind(int N){\n\t\tfor(int i=0 ; i < N ; i++ ){\n\t\t\tuf.push_back( P(i, 0) );\n\t\t}\n\t}\n\t\n\t// Returns (root, offset_from_root> while compressing the path.\n\tP find(int x){\n\t\tif( uf[x].first != x ){\n\t\t\tP p = find(uf[x].first);\n\t\t\tuf[x] = P(p.first, uf[x].second + p.second);\n\t\t}\n\t\treturn uf[x];\n\t}\n\t\n\tvoid unite(int a, int b, int w){ // [a] + w = [b]\n\t\tP aa = find(a); // [aa.first] + aa.second = [a]\n\t\tP bb = find(b); // [bb.first] + bb.second = [b]\n\t\t// Then, [bb.first] + (bb.second - w - aa.second) = [aa.first]\n\t\tif( aa.first != bb.first ){\n\t\t\tuf[aa.first] = P(bb.first, bb.second - w - aa.second);\n\t\t}\n\t}\n};\n\nint main(){\n\tint N, M;\n\twhile( cin >> N >> M , N || M ){\n\t\tUnionFind uf(N);\n\t\t\n\t\tfor(int i=0 ; i < M ; i++ ){\n\t\t\tchar q;\n\t\t\tcin >> q;\n\t\t\tif( q == '!' ){\n\t\t\t\tint a, b, w;\n\t\t\t\tcin >> a >> b >> w;\n\t\t\t\ta--; b--;\n\t\t\t\tuf.unite(a, b, w);\n\t\t\t}else if( q == '?' ){\n\t\t\t\tint a, b;\n\t\t\t\tcin >> a >> b;\n\t\t\t\ta--; b--;\n\t\t\t\tP aa = uf.find(a);\n\t\t\t\tP bb = uf.find(b);\n\t\t\t\tif( aa.first != bb.first ){\n\t\t\t\t\tcout << \"UNKNOWN\" << endl;\n\t\t\t\t}else{\n\t\t\t\t\tcout << bb.second - aa.second << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define f first\n#define s second\n#define mp make_pair\n#define inf 1<<30\n#define MAX 100001\nusing namespace std;\n\nint p[MAX];\nmap<pair<int,int>,int> M;\n\npair<int,int> find(int a){\n  pair<int,int> pii;\n  if(p[a]==a){\n    pii.f=a;pii.s=0;\n    return pii;\n  }\n  pii=find(p[a]);\n  pii.s+=M[mp(p[a],a)];\n  return pii;\n}\n\nint main()\n{\n  int n,q,a,b,w;\n  char c;\n\n  while(1){\n    cin>>n>>q;\n    if(n+q==0)break;\n    for(int i=0;i<n;i++)p[i]=i;\n    M.clear();\n\n    for(int i=0;i<q;i++){\n      cin>>c;\n      if(c=='!'){\n\tcin>>a>>b>>w;\n\ta--;b--;\n\tM[mp(b,a)]=w;\n\tp[a]=b;\n      }\n      else {\n\tcin>>a>>b;\n\ta--;b--;\n\tpair<int,int> pa=find(a),pb=find(b);\n\tif(pa.f!=pb.f)cout<<\"UNKNOWM\"<<endl;\n\telse {\n\t  M.erase(mp(a,p[a]));\n\t  M.erase(mp(b,p[b]));\n\t  p[a]=pa.f;\n\t  p[b]=pb.f;\n\t  M[mp(a,pa.f)]=pa.s;\n\t  M[mp(a,pb.f)]=pb.s;\n\t  cout<<pa.s-pb.s<<endl;\n\t}\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\ntypedef pair<int, int> P;\nstruct UF{\n  vector<int> data;\n  vector<int> weight;\n  UF(int N) : data(N, -1), weight(N, 0) {}\n  void uni(int x, int y, int w){\n    P px = root(x), py = root(y);\n    if(px.first != py.first){\n      if(data[px.first] > data[px.first]){\n        swap(px, py);\n        w *= -1;\n      }\n      data[px.first] += data[py.first];\n      data[py.first] = px.first;\n      weight[py.first] = px.second - py.second + w;\n    }\n  }\n  P root(int x){\n    if(data[x] < 0) return P(x, 0);\n    P p = root(data[x]);\n    data[x] = p.first;\n    weight[x] += p.second;\n    return P(data[x], weight[x]);\n  }\n};\n\nint main(){\n  int N, M;\n  while(cin>>N>>M && N){\n    UF uf(N);\n    string s; int x, y, z;\n    REP(i, M){\n      cin>>s;\n      if(s == \"!\"){\n        scanf(\"%d %d %d\", &x, &y, &z);\n        uf.uni(x, y, z);\n      }else{\n        scanf(\"%d %d\", &x, &y);\n        P px = uf.root(x);\n        P py = uf.root(y);\n        if(px.first == py.first){\n          printf(\"%d\\n\", py.second - px.second);\n        }else{\n          printf(\"UNKNOWN\\n\");\n        }\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing LL = long long;\n\n#define fs first\n#define sc second\n\nconst LL MOD = 1e9+7;\nconst double EPS = 1e-10;\n\ntemplate<class T>bool chmax(T &a, const T &b) {\n    if (a < b) { a = b; return true; }\n    return false;\n}\ntemplate<class T>bool chmin(T &a, const T &b) {\n    if (b < a) { a = b; return true; }\n    return false;\n}\n\n// std::vector Declaration\ntemplate<typename T>\nvector<T> make_v(size_t a) { return vector<T>(a); }\ntemplate<typename T,typename... Ts>\nauto make_v(size_t a,Ts... ts) {\n    return vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));\n}\n\n// std::vector Declaration and Initialization\ntemplate<typename T>\nvector<T> make_vector(size_t a, T x) { return vector<T>(a, x); }\ntemplate<typename T, typename U, typename... Ts>\nauto make_vector(size_t a, U b, Ts... ts) {\n    return vector<decltype(make_vector<T>(b,ts...))>(a,make_vector<T>(b,ts...));\n}\n\n// std::vector Input\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& v) {\n    for (auto &e : v) {\n        is >> e;\n    }\n    return is;\n}\n\n// std::vector Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n    os << \"[\";\n    bool a = 1;\n    for (auto e : v) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"]\";\n    return os;\n}\n\n// std::array Debug\ntemplate<typename T, size_t n>\nostream& operator<<(ostream& os, const array<T, n>& v) {\n    os << \"[\";\n    bool a = 1;\n    for (auto e : v) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"]\";\n    return os;\n}\n\n// std::deque Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const deque<T>& d) {\n    os << \"[\";\n    bool a = 1;\n    for (auto e : d) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"]\";\n    return os;\n}\n\n// std::pair Debug\ntemplate<typename T, typename U>\nostream& operator<<(ostream& os, const pair<T, U>& p) {\n    os << \"(\" << p.first << \" \" << p.second << \")\";\n    return os;\n}\n\n// std::set Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const set<T>& st) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : st) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n\n// std::multiset Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const multiset<T>& st) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : st) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n\n// std::map Debug\ntemplate<typename T, typename U>\nostream& operator<<(ostream& os, const map<T, U>& mp) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : mp) {\n        os << (a ? \"\" : \" \");\n        os << e.first << \":\" << e.second;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n\n// std::tuple Debug\ntemplate<int N, class Tuple>\nvoid out(ostream& os, const Tuple& t){}\ntemplate<int N, class Tuple, class H, class ...Ts>\nvoid out(ostream& os, const Tuple& t) {\n    if (N) os << \" \";\n    os << get<N>(t);\n    out<N+1,Tuple,Ts...>(os, t);\n}\ntemplate<class ...Ts>\nostream& operator<<(ostream& os, const tuple<Ts...>& t) {\n    os << \"(\";\n    out<0,tuple<Ts...>,Ts...>(os, t);\n    os << \")\";\n    return os;\n}\n\n// Debug\n#define DUMP(x) cerr<<#x<<\" = \"<<(x)<<endl\n\n// Weighted edge\ntemplate<typename T>\nstruct edge {\n    int src, to;\n    T cost;\n\n    edge(int to, T cost) : src(-1), to(to), cost(cost) {}\n    edge(int src, int to, T cost) : src(src), to(to), cost(cost) {}\n\n    edge &operator=(const int &x) {\n        to = x;\n        return *this;\n    }\n\n    operator int() const { return to; }\n\n    friend ostream& operator<<(ostream& os, const edge& e) {\n        return os << \"(\" << e.src << \"->\" << e.to << \":\" << e.cost << \")\";\n    }\n};\n\ntemplate<typename T>\nusing Edges = vector<edge<T>>;\ntemplate<typename T>\nusing WeightedGraph = vector<Edges<T>>;\nusing UnWeightedGraph = vector<vector<int>>;\ntemplate<typename T>\nusing MatrixGraph = vector<vector<T>>;\n\ntemplate<typename Abel>\nstruct WeightedUnionFind\n{\n    vector<int> par, myrank;\n    vector<Abel> diff_weight;\n    WeightedUnionFind(int n, Abel SUM_UNITY=0) {\n        par.resize(n); myrank.resize(n, 0); diff_weight.resize(n);\n        for (int i = 0; i < n; ++i) { par[i] = i; diff_weight[i] = SUM_UNITY; }\n    }\n    int root(int x) {\n        if (par[x] == x) return x;\n        int r = root(par[x]);\n        diff_weight[x] += diff_weight[par[x]];\n        return par[x] = r;\n    }\n    Abel weight(int x) {\n        root(x);\n        return diff_weight[x];\n    }\n    Abel diff(int x, int y) {\n        return weight(y) - weight(x);\n    }\n    bool merge(int x, int y, Abel w) {\n        w += weight(x); w -= weight(y);\n        x = root(x); y = root(y);\n        if (x == y) return false;\n        if (myrank[x] < myrank[y]) swap(x, y), w = -w;\n        par[y] = x;\n        if(myrank[x] == myrank[y]) ++myrank[x];\n        diff_weight[y] = w;\n        return true;\n    }\n    bool issame(int x, int y) {\n        return root(x) == root(y);\n    }\n};\n\nint main()\n{\n    while (true) {\n        int n, m; cin >> n >> m;\n        if (n == 0 && m == 0) {\n            break;\n        }\n\n        auto uf = WeightedUnionFind<int>(n);\n\n        for (int i = 0; i < m; ++i) {\n            char t; cin >> t;\n            if (t == '!') {\n                int a, b, w; cin >> a >> b >> w;\n                --a, --b;\n                uf.merge(a, b, w);\n            } else {\n                int a, b; cin >> a >> b;\n                --a, --b;\n                if (!uf.issame(a, b)) {\n                    printf(\"UNKNOWN\\n\");\n                } else {\n                    printf(\"%d\\n\", uf.diff(a, b));\n                }\n            }\n        }\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <memory.h>\n\n#define UNKNOWN -2000000\n\nusing namespace std;\n\n//FILE *in = freopen(\"input.txt\", \"r\", stdin);\n//FILE *out = freopen(\"output.txt\", \"w\", stdout);\n\nint n, m, M;\n\nvector<vector<pair<int,int>>> data;\nbool chk[100001];\n\nint res[100001];\nint query[100001][2];\nint dist[100001];\n\nstruct UnionFind {\n\tvector<int> par; vector<int> rank;\n\tUnionFind(int n){\n\t\tpar = vector<int>(n);\n\t\trank = vector<int>(n);\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tpar[i] = i;\n\t\t}\n\t}\n\tint find(int x) {\n\t\tif(par[x]==x) return x;\n\t\telse return find(par[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif(x == y) return;\n\t\tif(rank[x]<rank[y])\n\t\t\tpar[x] = y;\n\t\telse {\n\t\t\tpar[y] = x;\n\t\t\tif(rank[x]==rank[y])rank[x]++;\n\t\t}\n\t}\n\tinline bool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n};\n\nvoid bfs(int a) {\n\tqueue<pair<int,int>> que;\n\tque.push(make_pair(a, 0));\n\tchk[a] = true;\n\twhile(!que.empty()){\n\t\tint cur = que.front().first;\n\t\tint val = que.front().second;\n\t\tque.pop();\n\t\tdist[cur] = val;\n\n\t\tfor(int i = 0; i < data[cur].size(); i++) {\n\t\t\tif(chk[data[cur][i].first]) continue;\n\t\t\tchk[data[cur][i].first] = true;\n\t\t\tque.push(make_pair(data[cur][i].first, val + data[cur][i].second));\n\t\t}\n\t}\n}\n\nvoid process() {\n\tUnionFind uf(n+1);\n\tdata.clear();\n\tdata.resize(n+1);\n\tmemset(chk, 0, sizeof(chk));\n\tmemset(res, 0, sizeof(res));\n\tmemset(dist, 0, sizeof(dist));\n\tM = 0;\n\tchar tt[10];\n\tint a, b, c;\n\tfor(int k = 0; k < m; k++) {\n\t\tscanf(\"%s%d%d\", tt, &a, &b);\n\t\tif(tt[0] == '!') {\n\t\t\tscanf(\"%d\", &c);\n\t\t\tif(uf.same(a,b)) continue;\n\t\t\tdata[a].push_back(make_pair(b, c));\n\t\t\tdata[b].push_back(make_pair(a, -c));\n\t\t\tuf.unite(a,b);\n\t\t}\n\t\telse {\n\t\t\tquery[M][0] = a;\n\t\t\tquery[M][1] = b;\n\t\t\tif(!uf.same(a, b)) {\n\t\t\t\tres[M] = UNKNOWN;\n\t\t\t}\n\t\t\tM++;\n\t\t}\n\t}\n\n\tfor(int i = 1; i <= n; i++) {\n\t\tif(!chk[i]) {\n\t\t\tbfs(i);\n\t\t}\n\t}\n\n\tfor(int i = 0; i < M; i++) {\n\t\tif(res[i] == UNKNOWN) {\n\t\t\tprintf(\"UNKNOWN\\n\");\n\t\t} else {\n\t\t\tprintf(\"%d\\n\", dist[query[i][1]]-dist[query[i][0]]);\n\t\t}\n\t}\n}\n\nint main() {\n\twhile(true){\n\t\tscanf(\"%d%d\", &n, &m);\n\t\tif(n == 0)break;\n\t\tprocess();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <numeric>\n\n#define rep(i, n) for(int i = 0; i < (n); i++)\n#define FOR(i, a, b) for(int i = (a); i < (b); i++)\n#define ALL(v) (v).begin(), (v).end()\n#define REV(s) (s).rbegin(), (s).rend()\n#define MEMSET(v, s) memset(v, s, sizeof(v));\n#define MP make_pair\n#define X first\n#define Y second\n\nusing namespace std;\n\nconst double EPS = 1e-8;\n\ntypedef pair<int, int> P;\ntypedef long long ll;\n\ntemplate<class T> inline T sq(T a){return a*a;}\ntemplate<class T> T gcd(T m, T n){return n?gcd(n, m%n):m;}\n\nconst int N = 100010;\nint par[N];\nint dw[N];\n\nvoid init(int n){\n\trep(i, n) par[i] = i, dw[i] = 0;\n}\n\nint find(int x){\n\tif(x == par[x]) return x;\n\tint p = find(par[x]);\n\tdw[x] += dw[par[x]];\n\treturn par[x] = p;\n}\n\nbool same(int x, int y){\n\treturn find(x) == find(y);\n}\n\nvoid unite(int x, int y, int d){\n\tint rx = find(x), ry = find(y);\n\t// dw[x] = w[x]-w[rx]\n\t// dw[y] = w[y]-w[ry]\n\t// dw[x]-dw[y] = (w[x]-w[y])-(w[rx]-w[ry])\n\t// dw[x]-dw[y] = -d-(w[rx]-w[ry]) ∵w[x]+d = w[y]\n\t// dw[x]-dw[y] = -d+dw[ry] ∵dw[ry] = w[ry]-w[rx]\n\t// dw[ry] = dw[x]-dw[y]+d\n\tdw[ry] = dw[x]-dw[y]+d;\n\tpar[ry] = rx;\n}\n\nint main(){\n\tint n, m;\n\twhile(cin >> n >> m, n|m){\n\t\tinit(n);\n\t\twhile(m--){\n\t\t\tchar c;\n\t\t\tcin >> c;\n\t\t\tif(c == '!'){\n\t\t\t\tint a, b, w;\n\t\t\t\tcin >> a >> b >> w;\n\t\t\t\ta--, b--;\n\t\t\t\tunite(a, b, w);\n\t\t\t}else{\n\t\t\t\tint a, b;\n\t\t\t\tcin >> a >> b;\n\t\t\t\ta--, b--;\n\t\t\t\tif(!same(a, b)){\n\t\t\t\t\tcout << \"UNKNOWN\" << endl;\n\t\t\t\t}else{\n\t\t\t\t\tcout << dw[b]-dw[a] << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<map>\n#include<set>\n#include<vector>\n#include<algorithm>\n#include<string.h>\n#include<queue>\n#include<stack>\n#include<climits>\n#include<cmath>\nusing namespace std;\n\nmap<int,vector<pair<int,int> > >ma;\nmap<pair<int,int>,int>ma2;\nset<int>visited;\nint ans=0;\nbool dfs(int a,int b,int c,bool p){\n    if(a==b){\n        ans=c;\n        return true;\n    }\n    if(ma2[make_pair(a,b)]){\n        ans = (p?1:-1)*ma2[make_pair(a,b)]+c;\n        return true;\n    }\n    for(auto i : ma[a]){\n        if(!visited.count(i.first)){\n            if(dfs(i.first,b,p?c+i.second:c-i.second,p)){\n                ma2[make_pair(a,b)] = ans-c;\n                return true;\n            }\n        }\n    }\n    for(auto i : ma[b]){\n        if(!visited.count(i.first)){\n            if(dfs(i.first,a,p?c-i.second:c+i.second,!p)){\n                ma2[make_pair(a,b)] = ans-c;\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\nint main(){\n    int n,m;\n    while(cin>>n>>m,n){\n        ma.clear();\n        ma2.clear();\n        visited.clear();\n        for(int i=0;i<m;i++){\n            char c;\n            cin>>c;\n            if(c=='!'){\n                int a,b,d;\n                cin>>a>>b>>d;\n                ma[a].push_back(make_pair(b, d));\n                ma2[make_pair(a, b)]=d;\n            } else {\n                int a,b;\n                cin>>a>>b;\n                if(dfs(a,b,0,1)){\n                    cout<<ans<<endl;\n                } else {\n                    cout<<\"UNKNOWN\"<<endl;\n                }\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\n#include <cassert>\n#include <queue>\n#include <set>\n#include <map>\n#include <valarray>\n#include <bitset>\n#include <stack>\n#include <iomanip>\n#include <fstream>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define chmax(a,b) (a<b?(a=b,1):0)\n#define chmin(a,b) (a>b?(a=b,1):0)\n#define valid(y,x,h,w) (0<=y&&y<h&&0<=x&&x<w)\nconst int INF = 1<<29;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n\nstruct UnionFind {\n  vector<int> data;\n  vector<int> dis;\n  UnionFind(int size) : data(size, -1), dis(size,0) { }\n  bool unionSet(int x, int y, int d) {\n    int disx = dist(x);\n    int disy = dist(y);\n    x = root(x); y = root(y);\n    if (x != y) {\n      if (data[y] < data[x]) {\n        swap(x, y), d=-d;\n        swap(disx,disy);\n      }\n      data[x] += data[y]; data[y] = x;\n      dis[y] = disx + d - disy;\n    }\n    return x != y;\n  }\n  bool findSet(int x, int y) {\n    return root(x) == root(y);\n  }\n  int root(int x) {\n    if (data[x]<0) return x;\n    else {\n      dis[x] += dis[data[x]];\n      return data[x] = root(data[x]);\n    }\n    // return data[x] < 0 ? x : data[x] = root(data[x]);\n  }\n  int size(int x) {\n    return -data[root(x)];\n  }\n  int dist(int x) {\n    root(x);\n    return dis[x];\n  }\n};\n\nint main() {\n  int n,m;\n  while(cin>>n>>m,n||m) {\n    UnionFind uf(n);\n    REP(i,m) {\n      // REP(j,n) cout << uf.data[j] << \" \"; cout << endl;\n      // REP(j,n) cout << uf.dis[j] << \" \"; cout << endl;\n      char c; cin >> c;\n      if (c == '!') {\n        int a, b, d;\n        cin >> a >> b >> d;\n        a--;b--;\n        uf.unionSet(a,b,d);\n      } else {\n        int a, b;\n        cin >> a >> b;\n        a--;b--;\n        if (uf.findSet(a,b)) {\n          int d1 = uf.dist(a);\n          int d2 = uf.dist(b);\n          cout << d2-d1 << endl;\n        } else {\n          puts(\"UNKNOWN\");\n        }\n      }\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MAX_N 100010\n#define rank dfasoifd\n#define f first\n#define s second\nusing namespace std;\ntypedef pair<int,int> P;\nP par[MAX_N];\nint rank[MAX_N];\n\nvoid init(int n){\n  for(int i=0;i<n;i++)par[i]=P(i,0),rank[i]=0;\n}\n\nP find(int x){\n  if(par[x].f==x)return P(x,0);\n  P r=find(par[x].f);\n  return  par[x]=P(r.f,r.s+par[x].s);\n}\n\nvoid unite(int x,int y,int c){\n  P X=find(x),Y=find(y);\n  x=find(x).f,y=find(y).f;\n  if(x==y)return;\n  if(rank[x]<rank[y])par[x]=P(y,c+Y.s);\n  else{\n    par[y]=P(x,-c+X.s);\n    if(rank[x]==rank[y])rank[x]++;\n  }\n}\n\nbool same(int x,int y){return find(x).f==find(y).f;}\n\nint main(){\n  while(1){\n    int n,m;\n    cin>>n>>m;\n    if(!n&&!m)break;\n    init(n);  \n    while(m--){\n      char ch;\n      int a,b,c;\n      cin>>ch>>a>>b;a--,b--;\n      if(ch=='!'){\n\tcin>>c;\n\tif(!same(a,b))unite(a,b,c);      \n      }\n      if(ch=='?'){\n\tif(same(a,b)) cout <<find(a).s-find(b).s<<endl;\n\telse cout<<\"UNKNOWN\"<<endl;\n      }\n\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,k,n) for(int i=(k);i<(int)(n);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(x) begin(x),end(x)\n\nusing namespace std;\n\nstruct UnionFind {\n  vector<int> parent;\n  vector<int> diff;\n  UnionFind (int n) : parent(n, -1), diff(n, 0) {}\n  int root(int x) {\n    if (parent[x] < 0) {\n      return x;\n    } else {\n      int r = root(parent[x]);\n      diff[x] += diff[parent[x]];\n      parent[x] = r;\n      return r;\n    }\n  }\n  bool merge(int x, int y, int diff_xy) {\n    int oldx = x, oldy = y;\n    x = root(x); y = root(y);\n    if (x == y) return false;\n    diff_xy += diff[oldy] - diff[oldx];\n    if (parent[y] < parent[x]) {\n      diff_xy = -diff_xy;\n      swap(x, y);\n    }\n    if (parent[x] == parent[y]) --parent[x];\n    parent[y] = x;\n    diff[y] = -diff_xy;\n    return true;\n  }\n};\n\nint main() {\n  while(1){\n    int n,m;\n    cin>>n>>m;\n    if (!n) break;\n    UnionFind uf(n);\n    REP(i,m) {\n      string c;\n      cin>>c;\n      if (c == \"!\") {\n        int a,b,w;\n        cin>>a>>b>>w;\n        --a;--b;\n        uf.merge(a,b,w);\n      } else {\n        int a,b;\n        cin>>a>>b;\n        --a;--b;\n        if (uf.root(a) != uf.root(b)) {\n          cout << \"UNKNOWN\" << endl;\n        } else {\n          cout << (uf.diff[a] - uf.diff[b]) << endl;\n        }\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n\nusing namespace std;\n\ntypedef long long LL;\nstruct Node {\n    int root;\n    LL diff;\n};\n\nint root(int n, vector<Node> &nodes) {\n    if(nodes[n].root == n) return n;\n    const int tmp = nodes[n].root;\n    const int r = root(nodes[n].root, nodes);\n    nodes[n].diff += nodes[tmp].diff;\n    return nodes[n].root = nodes[r].root;\n}\n\nbool unite(int a, int b, vector<Node> &nodes) {\n    const int ra = root(a, nodes);\n    const int rb = root(b, nodes);\n    if(nodes[ra].root == nodes[rb].root) return false;\n    nodes[ra].root = nodes[rb].root;\n    return true;\n}\n\nbool solve() {\n    int N, M;\n    cin >> N >> M;\n    if(!N && !M) return false;\n\n    vector<Node> nodes(N);\n    for(int i = 0; i < N; ++i) {\n        nodes[i].root = i;\n        nodes[i].diff = 0;\n    }\n    for(int i = 0; i < M; ++i) {\n        string cmd;\n        cin >> cmd;\n        if(cmd == \"!\") {\n            int a, b, w;\n            cin >> a >> b >> w;\n            --a; --b;\n            if(unite(a, b, nodes)) {\n                nodes[a].diff += w;\n            }\n        } else {\n            int a, b;\n            cin >> a >> b;\n            --a; --b;\n            const int ra = root(a, nodes);\n            const int rb = root(b, nodes);\n            if(nodes[ra].root != nodes[rb].root) {\n                cout << \"UNKNOWN\" << endl;\n            } else {\n                const LL diff = nodes[a].diff - nodes[b].diff;\n                cout << diff << endl;\n            }\n        }\n    }\n    return true;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n\n    while(solve()) ;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define f first\n#define s second\n#define mp make_pair\n#define inf 1<<30\n#define MAX 1000010\nusing namespace std;\n\nlong long p[MAX],w[MAX];\n\npair<int,int> find(int a){\n  pair<int,int> pii;\n  if(p[a]==a){\n    pii.f=a;pii.s=0;\n    return pii;\n  }\n  pii=find(p[a]);\n  pii.s+=w[a];\n  p[a]=pii.f;\n  w[a]=pii.s;\n  return pii;\n}\n\nint main()\n{\n  int n,q,a,b,d;\n  char c;\n\n  while(cin>>n>>q && n ){\n    for(int i=0;i<n;i++){\n      p[i]=i;\n      w[i]=0;\n    }\n\n    for(int i=0;i<q;i++){\n      cin>>c;\n      if(c=='!'){\n\tcin>>a>>b>>d;\n\ta--;b--;\n\tpair<int,int> pa=find(a);\n\tp[pa.f]=b;\n\tw[pa.f]=d+w[a]+w[b];\n      }\n      else {\n\tcin>>a>>b;\n\ta--;b--;\n\tpair<int,int> pa=find(a),pb=find(b);\n\tif(pa.f!=pb.f)cout<<\"UNKNOWM\"<<endl;\n\telse {\n\t  p[a]=pa.f;\n\t  w[a]=pa.s;\n\t  p[b]=pb.f;\n\t  w[b]=pb.s;\n\t  cout<<pa.s-pb.s<<endl;\n\t}\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "/*\n  AOJ 1330\n  Title:Never Wait for Weights\n  @kankichi573\n  14/03/20 TLE\n*/\n#include <stdio.h>\n#include <setjmp.h>\njmp_buf jb;\n#define QUERY   100000\n#define SAMPLES 100000\nint cnt; //! query count\nint N,M;\nint a[QUERY],b[QUERY],c[QUERY],d[SAMPLES+1];\nint modified;\nint answer;\nint buf[SAMPLES+1];\nint buflen[SAMPLES+1];\nvoid clear()\n{\n  int i;\n  for(i=0;i<QUERY;i++)\n    d[i]=-1;\n\n}\nvoid step(int level,int target)\n{\n  int i,p,j,diff;\n\n  buflen[level+1]=0;\n  for(i=0;i<buflen[level];i++)\n    {\n      p=buf[i];\n      {\n\t//printf(\"::%d\\n\",p);\n\tfor(j=0;j<cnt;j++)\n\t  {\n\t    if(a[j]==p && d[b[j]]<0)\n\t      {\n\t\tdiff=d[p]+c[j];\n\t\td[b[j]]=diff;\n\t\tif(b[j]==target)\n\t\t  {\n\t\t    answer=diff;\n\t\t      //printf(\"LONGJUMP=%d %d %d\\n\",answer,d[i],c[j]);  \n\t\t    longjmp(jb,1);\n\t\t  }\n\t\tbuf[buflen[level+1]++]=b[j];\n\t\tmodified=-1;\n\t      }\n\t    if(b[j]==p && d[a[j]]<0)\n\t      {\n\t\tdiff=d[p]-c[j];\n\t\td[a[j]]=diff;\n\t\tif(a[j]==target)\n\t\t  {\n\t\t    answer=diff;\n\t\t    longjmp(jb,1);\n\t\t  }\n\t\tbuf[buflen[level+1]++]=a[j];\n\t\tmodified=-1;\n\t      }\n\t  }\n\t}\n    }\n}\nvoid solve(int from,int to)\n{\n  int level;\n  clear();\n  \n  d[from]=0;buf[0]=from;buflen[0]=1;modified=-1;\n  for(level=0;modified;level++)\n    {\n      modified=0;\n      if(setjmp( jb ) == 0 ) \n\t{\n\t  step(level,to);\n\t}\n      else\n\treturn;\n    }\n\n}\ndump()\n{\n  int i;\n\n  for(i=0;i<cnt;i++)\n    printf(\"%d~%d = %d\\n\",a[i],b[i],c[i]);\n  for(i=1;i<=N;i++)\n    printf(\"%d:%d\\n\",i,d[i]);\n}\nmain()\n{\n  int i,x,y;\n  char q;\n\n  while(scanf(\"%d %d \",&N,&M) && (N||M))\n    {\n\n      cnt=0;\n      for(i=0;i<M;i++)\n\t{\n\t  scanf(\"%c\",&q);\n\t  if(q=='!')\n\t    {\n\t      scanf(\"%d %d %d \",&a[cnt],&b[cnt],&c[cnt]);\n\t      cnt++;\n\t    }\n\t  else if(q=='?')\n\t    {\n\t      scanf(\"%d %d \",&x,&y);\n\t      answer=-1;\n\t      solve(x,y);\n\t      if(answer!=-1)\n\t\tprintf(\"%d\\n\",answer);\n\t      else\n\t\tprintf(\"UNKNOWN\\n\");\n\t    }\n\t}\n      //dump();\n    }\n  return(0);\n}"
  },
  {
    "language": "C",
    "code": "/*\n  AOJ 1330\n  Title:Never Wait for Weights\n  @kankichi573\n*/\n#include <stdio.h>\n#include <setjmp.h>\njmp_buf jb;\n#define QUERY   100000\n#define SAMPLES 100000\nint cnt; //! query count\nint N,M;\nint a[QUERY],b[QUERY],c[QUERY],d[SAMPLES+1],l[SAMPLES+1];\nint modified;\nint answer;\nvoid clear()\n{\n  int i;\n  for(i=0;i<QUERY;i++)\n    d[i]=l[i]=-1;\n\n}\nvoid step(int level,int target)\n{\n  int i,j,diff;\n\n  for(i=0;i<=N;i++)\n    {\n      if(l[i]==level)\n\t{\n\tfor(j=0;j<cnt;j++)\n\t  {\n\t    if(a[j]==i && d[b[j]]<0)\n\t      {\n\t\tdiff=d[i]+c[j];\n\t\td[b[j]]=diff;\n\t\tif(b[j]==target)\n\t\t  {\n\t\t    answer=diff;\n\t\t      //printf(\"LONGJUMP=%d %d %d\\n\",answer,d[i],c[j]);  \n\t\t    longjmp(jb,1);\n\t\t  }\n\t\tl[b[j]]=level+1;\n\t\tmodified=-1;\n\t      }\n\t    if(b[j]==i && d[a[j]]<0)\n\t      {\n\t\tdiff=d[i]-c[j];\n\t\td[a[j]]=diff;\n\t\tl[a[j]]=level+1;\n\t\tif(a[j]==target)\n\t\t  {\n\t\t    answer=diff;\n\t\t    longjmp(jb,1);\n\t\t  }\n\t\tmodified=-1;\n\t      }\n\t  }\n\t}\n    }\n}\nvoid solve(int from,int to)\n{\n  int level;\n  clear();\n  \n  d[from]=0;l[from]=0;modified=-1;\n  for(level=0;modified;level++)\n    {\n      modified=0;\n      if(setjmp( jb ) == 0 ) \n\t{\n\t  step(level,to);\n\t}\n      else\n\treturn;\n    }\n\n}\ndump()\n{\n  int i;\n\n  for(i=0;i<cnt;i++)\n    printf(\"%d~%d = %d\\n\",a[i],b[i],c[i]);\n  for(i=1;i<=N;i++)\n    printf(\"%d:%d %d\\n\",i,d[i],l[i]);\n}\nmain()\n{\n  int i,x,y;\n  char q;\n\n  while(scanf(\"%d %d \",&N,&M) && (N||M))\n    {\n\n      cnt=0;\n      for(i=0;i<M;i++)\n\t{\n\t  scanf(\"%c\",&q);\n\t  if(q=='!')\n\t    {\n\t      scanf(\"%d %d %d \",&a[cnt],&b[cnt],&c[cnt]);\n\t      cnt++;\n\t    }\n\t  else if(q=='?')\n\t    {\n\t      scanf(\"%d %d \",&x,&y);\n\t      answer=-1;\n\t      solve(x,y);\n\t      if(answer!=-1)\n\t\tprintf(\"%d\\n\",answer);\n\t      else\n\t\tprintf(\"UNKNOWN\\n\");\n\t    }\n\t}\n      //dump();\n    }\n  return(0);\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define N 100000\n\nint main()\n{\n  int i, n, q, v, x, y, z, dx, dy, x0, y0, ex, rx, sx, tmp;\n  char *p, buf[32];\n  buf[31]=0;\n  buf[30]='\\n';\n  int *s = (int*)malloc(sizeof(int)*N);\n  int *d = (int*)malloc(sizeof(int)*N);\n  while (fgets(buf, 32, stdin)) {\n    for (n=0,p=buf; *p!=' '; n=n*10+*(p++)-'0'); \n    for (q=0,p++; *p!='\\n'; q=q*10+*(p++)-'0'); \n    if (n==0 && q==0) break;\n    for (i=1; i<=n; s[i]=i,d[i++]=0);\n    for (int t=0; t<q; t++) {\n      fgets(buf, 32, stdin);\n      for (x=0,p=buf+2; *p!=' '; x=x*10+*(p++)-'0');\n      for (y=0,p++; *p>='0'; y=y*10+*(p++)-'0');\n\n      if (buf[0]=='!') { // relate x y z\n\tfor (z=0,p++; *p!='\\n'; z=z*10+*(p++)-'0');\n\tfor (x0=x,dx=0; s[x]!=x; dx+=d[x], x=s[x]);\n\tfor (y0=y,dy=0; s[y]!=y; dy+=d[y], y=s[y]);\n\ts[x0]=x;\n\td[x0]=dx;\n\ts[y0]=y;\n\td[y0]=dy;\n\tif (x<y) {\n\t  s[y] = x;\n\t  d[y] = z + dx - dy;\n\t} else if (x>y) {\n\t  s[x] = y;\n\t  d[x] = -z - dx + dy;\n\t} else continue;\n\t\n      } else { // diff\n\n\tfor (x0=x,dx=dy=0; s[x]!=x; dx+=d[x], x=s[x]);\n\tfor (rx=x, x=x0, ex=dx; s[x]!=x; x=sx) {\n\t  sx=s[x];\n\t  s[x]=rx;\n\t  tmp=d[x];\n\t  d[x]=ex;\n\t  ex-=tmp;\n\t}\n\tfor (y0=y; s[y]!=y; dy+=d[y], y=s[y]);\n\tv=-dx+dy;\n\tif (x!=y) {\n\t  fputs(\"UNKNOWN\\n\", stdout);\n\t} else {\n\t  i=30;\n\t  if (v>0)  for (; v>0; buf[--i]='0'+v%10,v/=10);\n\t  else if (v<0) {\n\t    for (; v<0; buf[--i]='0'-v%10,v/=10);\n\t    buf[--i] = '-';\n\t  } else  buf[--i] = '0';\n\t  fputs(buf+i, stdout);\n\t}\n      }\n    }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define N 100000\n\nint main()\n{\n  int i, n, q, v, x, y, z, dx, dy, x0, y0, ex, rx, sx, tmp;\n  char *p, buf[32];\n  buf[31]=0;\n  buf[30]='\\n';\n  int *s = (int*)malloc(sizeof(int)*N+1);\n  int *d = (int*)malloc(sizeof(int)*N+1);\n  while (fgets(buf, 32, stdin)) {\n    for (n=0,p=buf; *p!=' '; n=n*10+*(p++)-'0'); \n    for (q=0,p++; *p!='\\n'; q=q*10+*(p++)-'0'); \n    if (n==0 && q==0) break;\n    for (i=1; i<=n; s[i]=i,d[i++]=0);\n    for (int t=0; t<q; t++) {\n      fgets(buf, 32, stdin);\n      for (x=0,p=buf+2; *p!=' '; x=x*10+*(p++)-'0');\n      for (y=0,p++; *p>='0'; y=y*10+*(p++)-'0');\n\n      if (buf[0]=='!') { // relate x y z\n\tfor (z=0,p++; *p!='\\n'; z=z*10+*(p++)-'0');\n\tfor (x0=x,dx=0; s[x]!=x; dx+=d[x], x=s[x]);\n\tfor (y0=y,dy=0; s[y]!=y; dy+=d[y], y=s[y]);\n\ts[x0]=x;\n\td[x0]=dx;\n\ts[y0]=y;\n\td[y0]=dy;\n\tif (x<y) {\n\t  s[y] = x;\n\t  d[y] = z + dx - dy;\n\t} else if (x>y) {\n\t  s[x] = y;\n\t  d[x] = -z - dx + dy;\n\t} else continue;\n\t\n      } else { // diff\n\n\tfor (x0=x,dx=dy=0; s[x]!=x; dx+=d[x], x=s[x]);\n\tfor (rx=x, x=x0, ex=dx; s[x]!=x; x=sx) {\n\t  sx=s[x];\n\t  s[x]=rx;\n\t  tmp=d[x];\n\t  d[x]=ex;\n\t  ex-=tmp;\n\t}\n\tfor (y0=y; s[y]!=y; dy+=d[y], y=s[y]);\n\tv=-dx+dy;\n\tif (x!=y) {\n\t  fputs(\"UNKNOWN\\n\", stdout);\n\t} else {\n\t  i=30;\n\t  if (v>0)  for (; v>0; buf[--i]='0'+v%10,v/=10);\n\t  else if (v<0) {\n\t    for (; v<0; buf[--i]='0'-v%10,v/=10);\n\t    buf[--i] = '-';\n\t  } else  buf[--i] = '0';\n\t  fputs(buf+i, stdout);\n\t}\n      }\n    }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define N 100000\n\nint main()\n{\n  int i, n, q, v, x, y, z, dx, dy, x0, y0, ex, rx, sx, tmp;\n  char *p, buf[32];\n  buf[31]=0;\n  buf[30]='\\n';\n  int *s = (int*)malloc(sizeof(int)*N+1);\n  int *d = (int*)malloc(sizeof(int)*N+1);\n  while (fgets(buf, 32, stdin)) {\n    for (n=0,p=buf; *p!=' '; n=n*10+*(p++)-'0'); \n    for (q=0,p++; *p!='\\n'; q=q*10+*(p++)-'0'); \n    if (n==0 && q==0) break;\n    for (i=1; i<=n; s[i]=i,d[i++]=0);\n    for (int t=0; t<q; t++) {\n      fgets(buf, 32, stdin);\n      for (x=0,p=buf+2; *p!=' '; x=x*10+*(p++)-'0');\n      for (y=0,p++; *p>='0'; y=y*10+*(p++)-'0');\n\n      if (buf[0]=='!') { // relate x y z\n\tfor (z=0,p++; *p!='\\n'; z=z*10+*(p++)-'0');\n\tfor (x0=x,dx=0; s[x]!=x; dx+=d[x], x=s[x]);\n\tfor (y0=y,dy=0; s[y]!=y; dy+=d[y], y=s[y]);\n\ts[x0]=x;\n\td[x0]=dx;\n\ts[y0]=y;\n\td[y0]=dy;\n\tif (x<y) {\n\t  s[y] = x;\n\t  d[y] = z + dx - dy;\n\t} else if (x>y) {\n\t  s[x] = y;\n\t  d[x] = -z - dx + dy;\n\t} else continue;\n\t\n      } else { // diff\n\n\tfor (x0=x,dx=dy=0; s[x]!=x; dx+=d[x], x=s[x]);\n\tfor (rx=x, x=x0, ex=dx; s[x]!=x; x=sx) {\n\t  sx=s[x];\n\t  s[x]=rx;\n\t  tmp=d[x];\n\t  d[x]=ex;\n\t  ex-=tmp;\n\t}\n\tfor (y0=y; s[y]!=y; dy+=d[y], y=s[y]);\n\tv=-dx+dy;\n\tif (x!=y) {\n\t  fputs(\"UNKNOWN\\n\", stdout);\n\t} else {\n\t  i=30;\n\t  if (v>0)  for (; v>0; buf[--i]='0'+v%10,v/=10);\n\t  else if (v<0) {\n\t    for (; v<0; buf[--i]='0'-v%10,v/=10);\n\t    buf[--i] = '-';\n\t  } else  buf[--i] = '0';\n\t  fputs(buf+i, stdout);\n\t}\n      }\n    }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define N 100000\n\nint main()\n{\n  int i, n, q, v, x, y, z, dx, dy;\n  char *p, buf[32];\n  buf[31]=0;\n  buf[30]='\\n';\n  int *s = (int*)malloc(sizeof(int)*N);\n  int *d = (int*)malloc(sizeof(int)*N);\n  while (1) {\n    fgets(buf, 32, stdin);\n    for (n=0,p=buf; *p!=' '; n=n*10+*(p++)-'0'); \n    for (q=0,p++; *p!='\\n'; q=q*10+*(p++)-'0'); \n    if (n==0 && q==0) break;\n    for (i=0; i<n; s[i]=i,d[i++]=0);\n    for (int t=0; t<q; t++) {\n      fgets(buf, 32, stdin);\n      for (x=0,p=buf+2; *p!=' '; x=x*10+*(p++)-'0');\n      for (y=0,p++; *p>='0'; y=y*10+*(p++)-'0');\n      x--;\n      y--;\n      if (buf[0]=='!') { // relate x y z\n\tfor (z=0,p++; *p!='\\n'; z=z*10+*(p++)-'0');\n\tfor (dx=0; s[x]!=x; dx+=d[x],x=s[x]);\n\tfor (dy=0; s[y]!=y; dy+=d[y],y=s[y]);\n\tif (x<y) {\n\t  s[y] = x;\n\t  d[y] = dx + z - dy;\n\t}\telse if (x>y) {\n\t  s[x] = y;\n\t  d[x] = dy - z - dx;\n\t} else continue;\n      } else { // diff\n\tfor (v=0; s[x]!=x; v-=d[x], x=s[x]);\n\tfor (;s[y]!=y; v+=d[y], y=s[y]);\n\tif (x!=y) {\n\t  fputs_unlocked(\"UNKNOWN\\n\", stdout);\n\t} else {\n\t  i=30;\n\t  if (v>0)  for (; v>0; buf[--i]='0'+v%10,v/=10);\n\t  else if (v<0) {\n\t    for (; v<0; buf[--i]='0'-v%10,v/=10);\n\t    buf[--i] = '-';\n\t  } else  buf[--i] = '0';\n\t  fputs_unlocked(buf+i, stdout);\n\t}\n      }\n    }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define N 100000\n\nint main()\n{\n  int i, n, q, v, x, y, z, dx, dy, x0, y0, ex, rx, sx, tmp;\n  char *p, buf[32];\n  buf[31]=0;\n  buf[30]='\\n';\n  int *s = (int*)malloc(sizeof(int)*N+1);\n  int *d = (int*)malloc(sizeof(int)*N+1);\n  while (fgets(buf, 32, stdin)) {\n    for (n=0,p=buf; *p!=' '; n=n*10+*(p++)-'0'); \n    for (q=0,p++; *p!='\\n'; q=q*10+*(p++)-'0'); \n    if (n==0 && q==0) break;\n    for (i=1; i<=n; s[i]=i,d[i++]=0);\n    for (int t=0; t<q; t++) {\n      fgets(buf, 32, stdin);\n      for (x=0,p=buf+2; *p!=' '; x=x*10+*(p++)-'0');\n      for (y=0,p++; *p>='0'; y=y*10+*(p++)-'0');\n\n      if (buf[0]=='!') { // relate x y z\n\tfor (z=0,p++; *p!='\\n'; z=z*10+*(p++)-'0');\n\tfor (x0=x,dx=0; s[x]!=x; dx+=d[x], x=s[x]);\n\tfor (y0=y,dy=0; s[y]!=y; dy+=d[y], y=s[y]);\n\ts[x0]=x;\n\td[x0]=dx;\n\ts[y0]=y;\n\td[y0]=dy;\n\tif (x==y) continue;\n\ts[y] = x;\n        d[y] = z + dx - dy;\n\t\n      } else { // diff\n\n\tfor (x0=x,dx=dy=0; s[x]!=x; dx+=d[x], x=s[x]);\n\tfor (rx=x, x=x0, ex=dx; s[x]!=x; x=sx) {\n\t  sx=s[x];\n\t  s[x]=rx;\n\t  tmp=d[x];\n\t  d[x]=ex;\n\t  ex-=tmp;\n\t}\n\tfor (y0=y; s[y]!=y; dy+=d[y], y=s[y]);\n\tv=-dx+dy;\n\tif (x!=y) {\n\t  fputs(\"UNKNOWN\\n\", stdout);\n\t} else {\n\t  i=30;\n\t  if (v>0)  for (; v>0; buf[--i]='0'+v%10,v/=10);\n\t  else if (v<0) {\n\t    for (; v<0; buf[--i]='0'-v%10,v/=10);\n\t    buf[--i] = '-';\n\t  } else  buf[--i] = '0';\n\t  fputs(buf+i, stdout);\n\t}\n      }\n    }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<math.h>\n#include<string.h>\n#include<stdbool.h>\n#include<assert.h>\ntypedef long long ll;\ntypedef long double ld;\n#define rep(i,l,r)for(ll i=(l);i<(r);i++)\n#define repp(i,l,r,k)for(ll i=(l);i<(r);i+=(k))\n#define rrep(i,l,r)for(ll i=(l);i>=(r);i--)\n#define INF (1LL<<60)\n#define MOD1 1000000007\n#define MOD2 998244353\n#define MAX_N (1 << 17)\n#define YES printf(\"Yes\\n\")\n#define NO printf(\"No\\n\")\n#define PN printf(\"\\n\")\n#define charsize 100005 //10^5+5\n#define PI 3.141592653589793238\n\nvoid swap(ll *a, ll *b){ll c;c=*b;*b=*a;*a= c;}\nvoid cin(ll *n){ scanf(\"%lld\",&(*n)); }\nvoid cin2(ll *a, ll *b){ scanf(\"%lld%lld\",&(*a),&(*b)); }\nvoid cin3(ll *a, ll *b, ll *c){ scanf(\"%lld%lld%lld\",&(*a),&(*b),&(*c)); }\nll max2(ll a,ll b){return a>=b?a:b;}\nll min2(ll a,ll b){return a>=b?b:a;}\nll min3(ll a, ll b, ll c){return (a<=b && a<=c) ? a : b<=c ? b : c;}\nll max3(ll a, ll b, ll c){return (a>=b && a>=c) ? a : b>=c ? b : c;}\nll minn(ll n, ll a[n]){ll b=INF;rep(i,0,n) b=min2(b,a[i]);return b;}\nll maxn(ll n, ll a[n]){ll b=-INF;rep(i,0,n) b=max2(b,a[i]);return b;}\nll ABS(ll a){return a>=0?a:(-a);}\nll POW(ll a, ll b){ll c=1;rep(i,0,b) c*=a;return c;}\ndouble POW_d(double a, double b){double c=1;rep(i,0,b) c*=a;return c;}\nll gcd(ll a,ll b){return b?gcd(b,a%b):a;}\nll lcm(ll a,ll b){return a/gcd(a,b)*b;}\nll mod_MOD1(ll n){n+= n<0?((-n)/MOD1+1)*MOD1:0; return n%=MOD1;}\nll mod_p(ll n ,ll p){n+= n<0?((-n)/p+1)*p:0; return n%=p;}\nll change_into_num(char s[] , ll len, ll p){ return !p ? 0 : POW(10,p-1)*(s[len-p]-'0') + change_into_num(s,len,p-1); }\n\nvoid lr_lower( int *l, int *r, ll am, ll val , int type ){ (type<3) ? ( am < val ?  ( *l = (*l+*r)/2 ) : ( *r= (*l+*r)/2 ) ) : ( am <= val ? ( *l = (*l+*r)/2 ) : ( *r= (*l+*r)/2 ) ); }\nvoid lr_upper( int *l, int *r, ll am, ll val , int type ){ (type<3) ? ( am <= val ?  ( *l = (*l+*r)/2 ) : ( *r= (*l+*r)/2 ) ) : ( am < val ? ( *l = (*l+*r)/2 ) : ( *r= (*l+*r)/2 ) ); }\nint cmp_lower( ll a, ll b, int type ){ return (type==1) ? ( a==b ? 1 : 0 ) : (type==2) ? ( a>=b ? 1 : 0 ) : ( a>b ? 1 : 0 ) ; }\nint cmp_upper( ll a, ll b, int type ){ return (type==1) ? ( a==b ? 1 : 0 ) : (type==2) ? ( a<=b ? 1 : 0 ) : ( a<b ? 1 : 0 ) ; }\n// return smallest p  which meets  a[p]==val :1  >=:2   >:3\nll lower_bound( ll a[], int l, int r, ll val , int type ){  while(r-l>1) lr_lower(&l,&r,a[ (l+r)/2 ],val,type);  return cmp_lower(a[l],val,type) ? l : cmp_lower(a[r],val,type) ? r : -1;  }\n// return biggest p  which meets   a[p]==val :1  <=:2   <:3\nll upper_bound( ll a[], int l, int r, ll val , int type ){  while(r-l>1) lr_upper(&l,&r,a[ (l+r)/2 ],val,type); return cmp_upper(a[r],val,type) ? r : cmp_upper(a[l],val,type) ? l : -1; }\n// count i  which meets ai==x\nll count(ll a[], int l, int r, ll x){  int p = lower_bound(a,l,r,x,1);  return p==-1 ? 0 : upper_bound(a,p,r,x,1)-p+1; }\n\nint upll(const void*a, const void*b){return*(ll*)a<*(ll*)b?-1:*(ll*)a>*(ll*)b?1:0;}\nint downll(const void*a, const void*b){return*(ll*)a<*(ll*)b?1:*(ll*)a>*(ll*)b?-1:0;}\nint cmp_string( const void * a , const void * b ) {  return strcmp( (char *)a , (char *)b ); }  // qsort((void*)s,n,sizeof(s[0]),int_sort );\nint cmp_char(const void * a, const void * b) { return *(char *)a - *(char *)b;}\nvoid sortup(ll*a,int n){qsort(a,n,sizeof(ll),upll);}\nvoid sortdown(ll*a,int n){qsort(a,n,sizeof(ll),downll);}\nvoid sort_string(int n,int size,char s[][size]){ qsort( (void*)s , n , sizeof(s[0]) , cmp_string ); }\nvoid sort_char(char *s){ qsort( (void *)s , strlen(s) , sizeof(char) , cmp_char ); }\nll unique_string(ll n ,ll size, char s[][size]){ ll ans=1; rep(i,1,n) if( strcmp(s[i],s[i-1]) ) ans++; return ans; }\nll unique_num(ll n , ll a[]){ ll ans=1; rep(i,1,n) if( a[i]!=a[i-1] ) ans++; return ans; }\n\ntypedef struct{ ll a , b;}fr;\nint cmp1( const void *p, const void *q ) { return ((fr*)p) ->a - ((fr*)q)->a;}\nint cmp2( const void *p, const void *q ) { return ((fr*)q) ->a - ((fr*)p)->a;}\nvoid strsortup(fr*a,int n){qsort(a,n,sizeof(fr),cmp1);}\nvoid strsortdown(fr*a,int n){qsort(a,n,sizeof(fr),cmp2);}\n\n/*-------------------Weighted Union Find tree (start)----------------------*/\n\ntypedef struct{ ll num , par , hei;  ll wdif , wei ;} WUF;\nvoid WUFmake(ll n, WUF b[]){ rep(i,0,n){ b[i].par = b[i].num = i;  b[i].hei = 1;  b[i].wdif = b[i].wei = 0; } }\n\nll WUFroot(ll n, ll a, WUF b[]){\n    ll c= a==b[a].par ? a : WUFroot(n,b[a].par,b) ;\n    b[a].wei = b[b[a].par].wei + b[a].wdif;\n    return c;\n}\n// b[x]+z=b[y]\nvoid WUFunite(ll n, ll x, ll y, ll z, WUF b[]){\n    ll xroot = WUFroot(n,x,b), yroot = WUFroot(n,y,b);\n    if(b[xroot].hei > b[yroot].hei){ b[yroot].par = xroot;  b[yroot].wdif = b[x].wei+z-b[y].wei;\n    }else{ b[xroot].par = yroot;  b[yroot].hei = max2(b[yroot].hei,b[xroot].hei+1);  b[xroot].wdif = b[y].wei-b[x].wei-z;}\n}\nll WUFsame(ll n, ll x, ll y, WUF b[]){ return WUFroot(n,x,b) == WUFroot(n,y,b) ? 1 : 0; }\n\n/*-------------------Weighted Union Find tree (end)----------------------*/\n\n\n\n\n\nint main(void){\n    // fgets(s,sizeof(s),stdin); \n    // char ;\n    ll n,m;\n    // ll ans=0;\n\n    while(1){\n        cin(&n);\n        cin(&m);\n        if(!n&&!m) break;\n        WUF samp[n];\n        WUFmake(n,samp);\n\n        char s[5];\n        ll a,b,w;\n        rep(i,0,m){\n            scanf(\"%s\",s);\n            if(s[0]=='!'){\n                cin3(&a,&b,&w);\n                if(!WUFsame(n,a-1,b-1,samp)){\n                    WUFunite(n,a-1,b-1,w,samp);\n                }\n            }else{\n                cin2(&a,&b);\n                if( WUFsame(n,a-1,b-1,samp) ){\n                    printf(\"%lld\\n\",samp[b-1].wei - samp[a-1].wei );\n                }else{\n                    printf(\"UNKNOWN\\n\");\n                }\n            }\n        }\n    }\n\n    \n    // printf(\"%lld\\n\");\n    return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "// AOJ 1330: Never Wait for Weights\n// 2017.12.3 bal4u@uu\n\n#include <stdio.h>\n#include <string.h>\n\n// <????????????Union Find>\n#define MAX 100003\n\nint par[MAX], ws[MAX];\n\n#if 0\nvoid initWeightedUnionFind()\n{\n\tint i;\n\tfor (i = 0; i < n; i++) par[i] = -1;\n}\n#endif\n\nint find(int x)\n{\n\tint p;\n\tif (par[x] < 0) return x;\n    p = find(par[x]), ws[x] += ws[par[x]];\n    return par[x] = p;\n}\n    \nint weight(int x)\n{\n    find(x); \n    return ws[x];\n}\n    \nint unite(int x, int y, int w)  // x <-(w)- y (x + w = y)\n{\n\tint tmp;\n\n    w += weight(x), w -= weight(y);\n    x = find(x), y = find(y);\n    if (x == y) return 0;\n    if (par[y] < par[x]) // ???????????????????????????????????????????????????.\n        tmp = x, x = y, y = tmp, w = -w;\n    \n    par[x] += par[y], par[y] = x;\n    ws[y] = w;\n    return 1;\n}\n    \nint same(int x, int y)\n{\n\treturn find(x) == find(y);\n}\n\n// *ans = x - y. ?????????????????? return 0.\nint diff(int *ans, int x, int y)\n{\n    if (find(x) != find(y)) return 0;\n\t*ans = ws[x] - ws[y];\n\treturn 1;\n}\n// </????????????Union Find>\n\nchar buf[40], *p;\nint getint()\n{\n\tint n = 0;\n\twhile (*p >= '0') n = (n<<3) + (n<<1) + (*p++ & 0xf);\n\tp++;\n\treturn n;\n}\n\nint main()\n{\n\tint n, m, q, a, b;\n\n\twhile (fgets(p=buf, 40, stdin) && *p != '0') {\n\t\tn = getint(), m = getint();\n\t\tmemset(par, 0xff, (n+1)*sizeof(int));\n\t\tmemset(ws, 0, (n+1)*sizeof(int));\n\t\twhile (m--) {\n\t\t\tfgets(p=buf, 40, stdin);\n\t\t\tq = *p, p += 2, a = getint(), b = getint();\n\t\t\tif (q == '!') unite(b, a, getint());\n\t\t\telse {\n\t\t\t\tif (find(a) != find(b)) puts(\"UNKNOWN\");\n\t\t\t\telse printf(\"%d\\n\", ws[a] - ws[b]);\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define N 100000\n\nint main()\n{\n  int i, n, q, v, x, y, z, dx, dy, x0, y0, ex, rx, sx, tmp;\n  char *p, buf[32];\n  buf[31]=0;\n  buf[30]='\\n';\n  int *s = (int*)malloc(sizeof(int)*N+1);\n  int *d = (int*)malloc(sizeof(int)*N+1);\n  while (fgets(buf, 32, stdin)) {\n    for (n=0,p=buf; *p!=' '; n=n*10+*(p++)-'0'); \n    for (q=0,p++; *p!='\\n'; q=q*10+*(p++)-'0'); \n    if (n==0 && q==0) break;\n    for (i=1; i<=n; s[i]=i,d[i++]=0);\n    for (int t=0; t<q; t++) {\n      fgets(buf, 32, stdin);\n      for (x=0,p=buf+2; *p!=' '; x=x*10+*(p++)-'0');\n      for (y=0,p++; *p>='0'; y=y*10+*(p++)-'0');\n\n      if (buf[0]=='!') { // relate x y z\n\tfor (z=0,p++; *p!='\\n'; z=z*10+*(p++)-'0');\n\tfor (x0=x,dx=0; s[x]!=x; dx+=d[x], x=s[x]);\n\tfor (y0=y,dy=0; s[y]!=y; dy+=d[y], y=s[y]);\n\tif (x<y) {\n\t  s[y] = x;\n\t  d[y] = z + dx - dy;\n\t} else if (x>y) {\n\t  s[x] = y;\n\t  d[x] = -z - dx + dy;\n\t} else continue;\n\t\n      } else { // diff\n\n\tfor (x0=x,dx=dy=0; s[x]!=x; dx+=d[x], x=s[x]);\n\tfor (rx=x, x=x0, ex=dx; s[x]!=x; x=sx) {\n\t  sx=s[x];\n\t  s[x]=rx;\n\t  tmp=d[x];\n\t  d[x]=ex;\n\t  ex-=tmp;\n\t}\n\tfor (y0=y; s[y]!=y; dy+=d[y], y=s[y]);\n\tv=-dx+dy;\n\tif (x!=y) {\n\t  fputs(\"UNKNOWN\\n\", stdout);\n\t} else {\n\t  i=30;\n\t  if (v>0)  for (; v>0; buf[--i]='0'+v%10,v/=10);\n\t  else if (v<0) {\n\t    for (; v<0; buf[--i]='0'-v%10,v/=10);\n\t    buf[--i] = '-';\n\t  } else  buf[--i] = '0';\n\t  fputs(buf+i, stdout);\n\t}\n      }\n    }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <cmath>\n#include <string>\n#include <cctype>\n#include <vector>\n#include <cstdio>\n#include <climits>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef long long LL;\n\nLL a[110000];\nint f[110000];\n\nint gf(int x){\n\tint y=f[x];\n\tif (x==y) return x;\n\tf[x]=gf(y); a[x]+=a[y];\n\treturn f[x];\n}\n\nint main(){\n\tint N,M,i;\n\twhile (scanf(\"%d%d\",&N,&M),N || M){\n\t\tfor (i=1;i<=N;i++){\n\t\t\tf[i]=i; a[i]=0;\n\t\t}\n\t\twhile (M--){\n\t\t\tchar s[110];\n\t\t\tint u,v,d,x,y;\n\t\t\tscanf(\"%s\",s);\n\t\t\tif (*s=='!'){\n\t\t\t\tscanf(\"%d%d%d\",&u,&v,&d);\n\t\t\t\tx=gf(u); y=gf(v);\n\t\t\t\tif (x==y) continue;\n\t\t\t\ta[y]=a[u]-a[v]+d; f[y]=x;\n\t\t\t}else{\n\t\t\t\tscanf(\"%d%d\",&u,&v);\n\t\t\t\tx=gf(u); y=gf(v);\n\t\t\t\tprintf(x==y?\"%lld\\n\":\"UNKNOWN\\n\",a[v]-a[u]);\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define N 100000\n\nint main()\n{\n  int i, n, q, v, x, y, z, dx, dy, x0, y0, ex, rx, sx, tmp;\n  char *p, buf[32];\n  buf[31]=0;\n  buf[30]='\\n';\n  int *s = (int*)malloc(sizeof(int)*N+1);\n  int *d = (int*)malloc(sizeof(int)*N+1);\n  while (fgets(buf, 32, stdin)) {\n    for (n=0,p=buf; *p!=' '; n=n*10+*(p++)-'0'); \n    for (q=0,p++; *p!='\\n'; q=q*10+*(p++)-'0'); \n    if (n==0 && q==0) break;\n    for (i=1; i<=n; s[i]=i,d[i++]=0);\n    for (int t=0; t<q; t++) {\n      fgets(buf, 32, stdin);\n      for (x=0,p=buf+2; *p!=' '; x=x*10+*(p++)-'0');\n      for (y=0,p++; *p>='0'; y=y*10+*(p++)-'0');\n\n      if (buf[0]=='!') { // relate x y z\n\tfor (z=0,p++; *p!='\\n'; z=z*10+*(p++)-'0');\n\tfor (x0=x,dx=0; s[x]!=x; dx+=d[x], x=s[x]);\n\tfor (y0=y,dy=0; s[y]!=y; dy+=d[y], y=s[y]);\n\tif (x<y) {\n\t  s[y] = x;\n\t  d[y] = z + dx - dy;\n\t} else if (x>y) {\n\t  s[x] = y;\n\t  d[x] = -z - dx + dy;\n\t} else continue;\n\t\n      } else { // diff\n\n\tfor (x0=x,dx=dy=0; s[x]!=x; dx+=d[x], x=s[x]);\n\tfor (rx=x, x=x0, ex=dx; s[x]!=x; x=sx) {\n\t  sx=s[x];\n\t  s[x]=rx;\n\t  tmp=d[x];\n\t  d[x]=ex;\n\t  ex-=tmp;\n\t}\n\tfor (y0=y; s[y]!=y; dy+=d[y], y=s[y]);\n\tv=-dx+dy;\n\tif (x!=y) {\n\t  fputs(\"UNKNOWN\\n\", stdout);\n\t} else {\n\t  i=30;\n\t  if (v>0)  for (; v>0; buf[--i]='0'+v%10,v/=10);\n\t  else if (v<0) {\n\t    for (; v<0; buf[--i]='0'-v%10,v/=10);\n\t    buf[--i] = '-';\n\t  } else  buf[--i] = '0';\n\t  fputs(buf+i, stdout);\n\t}\n      }\n    }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define N 100000\n\nint main()\n{\n  int i, n, q, v, x, y, z, dx, dy, x0, y0, ex, rx, sx, tmp;\n  char *p, buf[32];\n  buf[31]=0;\n  buf[30]='\\n';\n  int *s = (int*)malloc(sizeof(int)*N+1);\n  int *d = (int*)malloc(sizeof(int)*N+1);\n  while (1) {\n    fgets(buf, 32, stdin);\n    for (n=0,p=buf; *p!=' '; n=n*10+*(p++)-'0'); \n    for (q=0,p++; *p!='\\n'; q=q*10+*(p++)-'0'); \n    if (n==0 && q==0) break;\n    for (i=1; i<=n; s[i]=i,d[i++]=0);\n    for (int t=0; t<q; t++) {\n      fgets(buf, 32, stdin);\n      for (x=0,p=buf+2; *p!=' '; x=x*10+*(p++)-'0');\n      for (y=0,p++; *p>='0'; y=y*10+*(p++)-'0');\n\n      if (buf[0]=='!') { // relate x y z\n\tfor (z=0,p++; *p!='\\n'; z=z*10+*(p++)-'0');\n\tx0=x;\n\ty0=y;\n\tfor (dx=0; s[x]!=x; dx+=d[x], x=s[x]);\n\tfor (dy=0; s[y]!=y; dy+=d[y], y=s[y]);\n\ts[x0]=x;\n\td[x0]=dx;\n\ts[y0]=y;\n\td[y0]=dy;\n\t\n\tif (x<y) {\n\t  s[y] = x;\n\t  d[y] = z + dx - dy;\n\t} else if (x>y) {\n\t  s[x] = y;\n\t  d[x] = -z - dx + dy;\n\t} else continue;\n\t\n      } else { // diff\n\n\tfor (x0=x,dx=dy=0; s[x]!=x; dx += d[x], x=s[x]);\n\tfor (rx=x, x=x0, ex=dx; s[x]!=x; x=sx) {\n\t  sx=s[x];\n\t  s[x]=rx;\n\t  tmp = d[x];\n\t  d[x]=ex;\n\t  ex-=tmp;\n\t}\n\tfor (y0 = y; s[y]!=y; dy+=d[y], y = s[y]);\n\tv=-dx+dy;\n\tif (x!=y) {\n\t  fputs(\"UNKNOWN\\n\", stdout);\n\t} else {\n\t  i=30;\n\t  if (v>0)  for (; v>0; buf[--i]='0'+v%10,v/=10);\n\t  else if (v<0) {\n\t    for (; v<0; buf[--i]='0'-v%10,v/=10);\n\t    buf[--i] = '-';\n\t  } else  buf[--i] = '0';\n\t  fputs(buf+i, stdout);\n\t}\n      }\n    }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\nint main()\n{\n  int i, n, q, v, x, y, z, dx, dy;\n  char *p, buf[32];\n  buf[31]=0;\n  buf[30]='\\n';\n  int *s, *d;\n  while (1) {\n    fgets(buf, 32, stdin);\n    for (n=0,p=buf; *p!=' '; n=n*10+*(p++)-'0'); \n    for (q=0,p++; *p!='\\n'; q=q*10+*(p++)-'0'); \n    if (n==0 && q==0) break;\n    s = (int*)malloc(sizeof(int)*n);\n    d = (int*)malloc(sizeof(int)*n);\n    for (i=0; i<n; s[i]=i,d[i++]=0);\n    for (int t=0; t<q; t++) {\n      fgets(buf, 32, stdin);\n      for (x=0,p=buf+2; *p!=' '; x=x*10+*(p++)-'0');\n      for (y=0,p++; *p>='0'; y=y*10+*(p++)-'0');\n      x--;\n      y--;\n      if (buf[0]=='!') { // relate x y z\n\tfor (z=0,p++; *p!='\\n'; z=z*10+*(p++)-'0');\n\tfor (dx=0; s[x]!=x; dx+=d[x],x=s[x]);\n\tfor (dy=0; s[y]!=y; dy+=d[y],y=s[y]);\n\tif (x<y) {\n\t  s[y] = x;\n\t  d[y] = dx + z - dy;\n\t}\telse if (x>y) {\n\t  s[x] = y;\n\t  d[x] = dy - z - dx;\n\t} else continue;\n      } else { // diff\n\tfor (v=0; s[x]!=x; v-=d[x], x=s[x]);\n\tfor (;s[y]!=y; v+=d[y], y=s[y]);\n\tif (x!=y) {\n\t  fputs(\"UNKNOWN\\n\", stdout);\n\t} else {\n\t  i=30;\n\t  if (v>0)  for (; v>0; buf[--i]='0'+v%10,v/=10);\n\t  else if (v<0) {\n\t    for (; v<0; buf[--i]='0'-v%10,v/=10);\n\t    buf[--i] = '-';\n\t  } else  buf[--i] = '0';\n\t  fputs(buf+i, stdout);\n\t}\n      }\n    }\n    free(s);\n    free(d);\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\nimport java.util.Arrays;\n\npublic class Main {\n\tMyScanner sc = new MyScanner();\n\tScanner sc2 = new Scanner(System.in);\n\tfinal int MOD = 1000000007;\n\tint[] dx = { 1, 0, 0, -1 };\n\tint[] dy = { 0, 1, -1, 0 };\n\n\tint N, M, a, b, w;\n\tint[] parent;\n\tNode[] node;\n\n\tvoid run() {\n\t\tfor (;;) {\n\t\t\tN = sc.nextInt(); // 荷物数\n\t\t\tM = sc.nextInt(); // クエリ数\n\t\t\tif ((N | M) == 0) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tparent = new int[N + 1];\n\t\t\tnode = new Node[N + 1];\n\t\t\tinit();\n\n\t\t\tfor (int i = 0; i < M; i++) {\n\t\t\t\tString query = sc.next();\n\t\t\t\ta = sc.nextInt();\n\t\t\t\tb = sc.nextInt();\n\t\t\t\tif (query.equals(\"!\")) {\n\t\t\t\t\tw = sc.nextInt();\n\t\t\t\t\tunion(a, b, w);\n\t\t\t\t} else if (query.equals(\"?\")) {\n\t\t\t\t\tSystem.out.println(same(a, b) ? node[b].weight\n\t\t\t\t\t\t\t- node[a].weight : \"UNKNOWN\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid init() {\n\t\tfor (int i = 0; i <= N; i++) {\n\t\t\tparent[i] = i;\n\t\t\tnode[i] = new Node(0, 0);\n\t\t}\n\t}\n\n\tvoid union(int x, int y, int w) {\n\t\tint rootX = find(x);\n\t\tint rootY = find(y);\n\t\tif (rootX == rootY) {\n\t\t\treturn;\n\t\t}\n\t\tif (node[rootX].rank < node[rootY].rank) {\n\t\t\tnode[rootX].weight = -w - node[x].weight + node[y].weight;\n\t\t\tparent[rootX] = rootY;\n\t\t} else {\n\t\t\tnode[rootY].weight = w - node[y].weight + node[x].weight;\n\t\t\tparent[rootY] = rootX;\n\n\t\t\tif (node[rootX].rank == node[rootY].rank) {\n\t\t\t\tnode[rootX].rank++;\n\t\t\t}\n\t\t}\n\t}\n\n\tint find(int target) {\n\t\tif (parent[target] == target) {\n\t\t\treturn target;\n\t\t} else {\n\t\t\tint update = find(parent[target]);\n\t\t\tnode[target].weight += node[parent[target]].weight;\n\t\t\treturn update;\n\t\t}\n\t}\n\n\tboolean same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\n\tclass Node {\n\t\tint weight;\n\t\tint rank;\n\n\t\t/**\n\t\t * @param weight\n\t\t * @param rank\n\t\t */\n\t\tpublic Node(int weight, int rank) {\n\t\t\tsuper();\n\t\t\tthis.weight = weight;\n\t\t\tthis.rank = rank;\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tvoid debug(Object... o) {\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n\n\tvoid debug2(int[][] array) {\n\t\tfor (int i = 0; i < array.length; i++) {\n\t\t\tfor (int j = 0; j < array[i].length; j++) {\n\t\t\t\tSystem.out.print(array[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\n\tclass MyScanner {\n\t\tint nextInt() {\n\t\t\ttry {\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (c != '-' && (c < '0' || '9' < c))\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tif (c == '-')\n\t\t\t\t\treturn -nextInt();\n\t\t\t\tint res = 0;\n\t\t\t\tdo {\n\t\t\t\t\tres *= 10;\n\t\t\t\t\tres += c - '0';\n\t\t\t\t\tc = System.in.read();\n\t\t\t\t} while ('0' <= c && c <= '9');\n\t\t\t\treturn res;\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tString next() {\n\t\t\ttry {\n\t\t\t\tStringBuilder res = new StringBuilder(\"\");\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (Character.isWhitespace(c))\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tdo {\n\t\t\t\t\tres.append((char) c);\n\t\t\t\t} while (!Character.isWhitespace(c = System.in.read()));\n\t\t\t\treturn res.toString();\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n \npublic class Main {\n    public static int N;\n    public static int M;\n    public static int[] p;\n    public static int[] rank;\n    public static int[] weight;\n\n    public static boolean same(int x, int y) {\n        return findSet(x) == findSet(y);\n    }\n \n    public static void unite(int x, int y, int w) {\n        int i = findSet(x);\n        int j = findSet(y);\n        w -= weight[j] - weight[i];\n\n        if (i == j){\n\t    return;\n\t}\n        if (rank[i] > rank[j]){\n            p[j] = p[i];\n            weight[j] = w;\n        } else {\n            p[i] = p[j];\n            weight[i] = -w;\n            if(rank[i] == rank[j]){\n            rank[j]++;\n            }\n        }\t\n    }\n \n    public static int findSet(int i) {\n       if(p[i] == i){ \n           return i;\n        }else{\n          return p[i] = findSet(p[i]);\n        }\n    }\n \n    public static void DisjointSet() {\n        p = new int[N];\n        rank = new int[N];\n        weight = new int[N];\n \n        for (int i = 0; i < N; i++) {\n            p[i] = i;\n            rank[i] = 0;\n            weight[i] = 0;\n        }\n    }\n \n \n    public static void main (String[] args){\n        Scanner scanner = new Scanner(System.in);\n        while(true){\n        N = scanner.nextInt();\n        M = scanner.nextInt();\n\n        if(N==0 |M==0){\n           break;\n        }\n \n        DisjointSet();\n\n        for (int i = 0; i < M; i++) {\n            if(scanner.next().equals(\"!\")){\n            int a = scanner.nextInt();\n            int b = scanner.nextInt();\n            int w = scanner.nextInt();\n \n            a--; b--;   \n            unite(a, b, w);\n            }else{\n               if(same(a,b)){\n                    System.out.println(weight[b] - weight[a]);\n                }else{\n                    System.out.println(\"UNKNOWN\");\n\t\t}\n            }\n        }\n       }\n      \n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.ListIterator;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\t\n\tpublic static class WeightUnionFind{\n\t\tint[] parent;\n\t\tint[] rank;\n\t\tint[] diff_weight;\n\t\t\n\t\tWeightUnionFind(int n){\n\t\t\tparent=new int[n];\n\t\t\trank = new int[n];\n\t\t\tdiff_weight = new int[n];\n\t\t\t\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tparent[i]=i;\n\t\t\t\trank[i] = 0;\n\t\t\t\tdiff_weight[i] = 0;\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic int find(int x){\n\t\t\tif(parent[x]==x){\n\t\t\t\treturn x;\n\t\t\t}\n\t\t\t\n\t\t\treturn find(parent[x]);\n\t\t}\n\t\t\n\t\tpublic int find_diff(int x){\n\t\t\tif(parent[x] == x){\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\t\n\t\t\treturn find_diff(parent[x]) + diff_weight[x];\n\t\t}\n\t\t\n\t\tpublic Boolean same(int x,int y){\n\t\t\treturn find(x)==find(y);\n\t\t}\n\t\t\n\t\tpublic int get_diff(int x, int y){\n\t\t\tif(!same(x, y)){\n\t\t\t\treturn Integer.MIN_VALUE;\n\t\t\t}else{\n\t\t\t\treturn find_diff(x) - find_diff(y);\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic void unite(int x,int y){\n\t\t\tx = find(x);\n\t\t\ty = find(y);\n\t\t\t\n\t\t\tif(x == y){\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tif(rank[x] < rank[y]){\n\t\t\t\tparent[x] = y;\n\t\t\t}else{\n\t\t\t\tparent[y] = x;\n\t\t\t\tif(rank[x] == rank[y]){\n\t\t\t\t\trank[x]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic void set_diff(int x,int y, int d){\n\t\t\tfinal int find_x = find(x);\n\t\t\tfinal int find_y = find(y);\n\t\t\t\n\t\t\tif(find_x == find_y){\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tif(rank[find_x] < rank[find_y]){\n\t\t\t\tdiff_weight[x] = d + find_diff(y);\n\t\t\t\t\n\t\t\t\tparent[find_x] = find_y;\n\t\t\t}else{\n\t\t\t\tdiff_weight[y] = - d + find_diff(x);\n\t\t\t\t\n\t\t\t\tparent[find_y] = find_x;\n\t\t\t\tif(rank[find_x] == rank[find_y]){\n\t\t\t\t\trank[find_x]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile (true) {\n\t\t\tfinal int N = sc.nextInt();\n\t\t\tfinal int M = sc.nextInt();\n\n\t\t\tif (N == 0 && M == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tSystem.gc();\n\t\t\t\n\t\t\tWeightUnionFind wuf = new WeightUnionFind(N);\n\t\t\t\n\t\t\tfor(int i = 0; i < M; i++){\n\t\t\t\tString op = sc.next();\n\t\t\t\t\n\t\t\t\tif(op.equals(\"!\")){\n\t\t\t\t\tfinal int from = sc.nextInt() - 1;\n\t\t\t\t\tfinal int to = sc.nextInt() - 1;\n\t\t\t\t\tfinal int w = sc.nextInt();\n\t\t\t\t\t\n\t\t\t\t\twuf.set_diff(from, to, w);\n\t\t\t\t\t//System.out.println(\"DIFF \" + from + \" \" + to + \" \" + w);\n\t\t\t\t}else{\n\t\t\t\t\tfinal int from = sc.nextInt() - 1;\n\t\t\t\t\tfinal int to = sc.nextInt() - 1;\n\t\t\t\t\t\n\t\t\t\t\tif(!wuf.same(from, to)){\n\t\t\t\t\t\tSystem.out.println(\"UNKOWN\");\n\t\t\t\t\t}else{\n\t\t\t\t\t\tSystem.out.println(wuf.get_diff(from, to));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t//System.out.println(\"P : \" + Arrays.toString(wuf.parent));\n\t\t\t\t//System.out.println(\"D : \" + Arrays.toString(wuf.diff_weight));\n\t\t\t}\n\t\t\t\n\t\t}\n\n\t\tsc.close();\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.io.Reader;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\n\npublic class Main {\n\tstatic FastScanner sc = new FastScanner(System.in);\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tint[] A = new int[100000];\n\t\tint[] B = new int[100000];\n\t\tint[] W = new int[100000];\n\t\tboolean[] type = new boolean[100000];\n\t\tint[] dist = new int[100000];\n\t\tArrayList<ArrayList<Edge>> graph = new ArrayList<ArrayList<Edge>>();\n\t\tfor (int i = 0; i < 100000; ++i) {\n\t\t\tgraph.add(new ArrayList<Edge>());\n\t\t}\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\twhile (true) {\n\t\t\tint N = sc.nextInt();\n\t\t\tint M = sc.nextInt();\n\t\t\tif (N == 0 || M == 0) break;\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tgraph.get(i).clear();\n\t\t\t}\n\t\t\tfor (int i = 0; i < M; ++i) {\n\t\t\t\ttype[i] = sc.nextChar() == '!';\n\t\t\t\tA[i] = sc.nextInt() - 1;\n\t\t\t\tB[i] = sc.nextInt() - 1;\n\t\t\t\tif (type[i]) {\n\t\t\t\t\tW[i] = sc.nextInt();\n\t\t\t\t\tgraph.get(A[i]).add(new Edge(B[i], W[i]));\n\t\t\t\t\tgraph.get(B[i]).add(new Edge(A[i], -W[i]));\n\t\t\t\t}\n\t\t\t}\n\t\t\tArrays.fill(dist, Integer.MIN_VALUE);\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tif (dist[i] != Integer.MIN_VALUE) continue;\n\t\t\t\tArrayDeque<Integer> q = new ArrayDeque<Integer>();\n\t\t\t\tq.add(i);\n\t\t\t\tdist[i] = 0;\n\t\t\t\twhile (!q.isEmpty()) {\n\t\t\t\t\tint cur = q.poll();\n\t\t\t\t\tfor (Edge e : graph.get(cur)) {\n\t\t\t\t\t\tint next = e.to;\n\t\t\t\t\t\tif (dist[next] != Integer.MIN_VALUE) continue;\n\t\t\t\t\t\tdist[next] = dist[cur] + e.w;\n\t\t\t\t\t\tq.add(next);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tUnionFind uf = new UnionFind(N);\n\t\t\tfor (int i = 0; i < M; ++i) {\n\t\t\t\tif (type[i]) {\n\t\t\t\t\tuf.union(A[i], B[i]);\n\t\t\t\t} else {\n\t\t\t\t\tif (!uf.find(A[i], B[i])) {\n\t\t\t\t\t\tout.println(\"UNKNOWN\");\n\t\t\t\t\t} else {\n\t\t\t\t\t\tout.println(dist[B[i]] - dist[A[i]]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tout.flush();\n\t}\n\n\tstatic class Edge {\n\t\tint to, w;\n\n\t\tEdge(int to, int w) {\n\t\t\tthis.to = to;\n\t\t\tthis.w = w;\n\t\t}\n\t}\n\n\tstatic class UnionFind {\n\t\tint[] set;\n\t\tint[] buf;\n\n\t\tUnionFind(int n) {\n\t\t\tset = new int[n];\n\t\t\tArrays.fill(set, -1);\n\t\t\tbuf = new int[n];\n\t\t}\n\n\t\tvoid union(int a, int b) {\n\t\t\tint rtA = root(a);\n\t\t\tint rtb = root(b);\n\t\t\tif (rtA == rtb) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tset[rtA] += set[rtb];\n\t\t\tset[rtb] = rtA;\n\t\t}\n\n\t\tboolean find(int a, int b) {\n\t\t\treturn root(a) == root(b);\n\t\t}\n\n\t\tint root(int a) {\n\t\t\tif (set[a] < 0) return a;\n\t\t\tbuf[0] = a;\n\t\t\tint bs = 1;\n\t\t\twhile (true) {\n\t\t\t\tint parent = set[buf[bs - 1]];\n\t\t\t\tif (parent < 0) {\n\t\t\t\t\tint rt = buf[bs - 1];\n\t\t\t\t\tfor (int i = 0; i < bs - 1; ++i) {\n\t\t\t\t\t\tset[buf[i]] = rt;\n\t\t\t\t\t}\n\t\t\t\t\treturn rt;\n\t\t\t\t}\n\t\t\t\tbuf[bs++] = parent;\n\t\t\t}\n\t\t}\n\n\t\tint size(int a) {\n\t\t\treturn -set[root(a)];\n\t\t}\n\t}\n\n\tstatic class FastScanner {\n\t\tReader input;\n\n\t\tFastScanner() {\n\t\t\tthis(System.in);\n\t\t}\n\n\t\tFastScanner(InputStream stream) {\n\t\t\tthis.input = new BufferedReader(new InputStreamReader(stream));\n\t\t}\n\n\t\tint nextInt() throws IOException {\n\t\t\tint sign = 1;\n\t\t\tint b = input.read();\n\t\t\twhile ((b < '0' || '9' < b) && b != '-' && b != '+') {\n\t\t\t\tif (b == -1) return 0;\n\t\t\t\tb = input.read();\n\t\t\t}\n\t\t\tif (b == '-') {\n\t\t\t\tsign = -1;\n\t\t\t\tb = input.read();\n\t\t\t} else if (b == '+') {\n\t\t\t\tb = input.read();\n\t\t\t}\n\t\t\tint ret = b - '0';\n\t\t\twhile (true) {\n\t\t\t\tb = input.read();\n\t\t\t\tif (b < '0' || '9' < b) return ret * sign;\n\t\t\t\tret *= 10;\n\t\t\t\tret += b - '0';\n\t\t\t}\n\t\t}\n\n\t\tchar nextChar() throws IOException {\n\t\t\tint b = input.read();\n\t\t\twhile (Character.isWhitespace((char) b)) {\n\t\t\t\tb = input.read();\n\t\t\t}\n\t\t\treturn (char) b;\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.Reader;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\n\npublic class Main {\n\tstatic FastScanner sc = new FastScanner(System.in);\n\n\tpublic static void main(String[] args) throws Exception {\n\t\twhile (true) {\n\t\t\tint N = sc.nextInt();\n\t\t\tif (N == 0) break;\n\t\t\tint M = sc.nextInt();\n\t\t\tint[] A = new int[M];\n\t\t\tint[] B = new int[M];\n\t\t\tint[] W = new int[M];\n\t\t\tboolean[] type = new boolean[M];\n\t\t\tint[] dist = new int[N];\n\t\t\tArrayList<ArrayList<Edge>> graph = new ArrayList<ArrayList<Edge>>();\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tgraph.add(new ArrayList<Edge>());\n\t\t\t}\n\t\t\tfor (int i = 0; i < M; ++i) {\n\t\t\t\ttype[i] = sc.nextChar() == '!';\n\t\t\t\tA[i] = sc.nextInt() - 1;\n\t\t\t\tB[i] = sc.nextInt() - 1;\n\t\t\t\tif (type[i]) {\n\t\t\t\t\tW[i] = sc.nextInt();\n\t\t\t\t\tgraph.get(A[i]).add(new Edge(B[i], W[i]));\n\t\t\t\t\tgraph.get(B[i]).add(new Edge(A[i], -W[i]));\n\t\t\t\t}\n\t\t\t}\n\t\t\tArrays.fill(dist, Integer.MIN_VALUE);\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tif (dist[i] != Integer.MIN_VALUE) continue;\n\t\t\t\tArrayDeque<Integer> q = new ArrayDeque<Integer>();\n\t\t\t\tq.add(i);\n\t\t\t\tdist[i] = 0;\n\t\t\t\twhile (!q.isEmpty()) {\n\t\t\t\t\tint cur = q.poll();\n\t\t\t\t\tfor (Edge e : graph.get(cur)) {\n\t\t\t\t\t\tint next = e.to;\n\t\t\t\t\t\tif (dist[next] != Integer.MIN_VALUE) continue;\n\t\t\t\t\t\tdist[next] = dist[cur] + e.w;\n\t\t\t\t\t\tq.add(next);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tUnionFind uf = new UnionFind(N);\n\t\t\t\tfor (int i = 0; i < M; ++i) {\n\t\t\t\t\tif (type[i]) {\n\t\t\t\t\t\tuf.union(A[i], B[i]);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (!uf.find(A[i], B[i])) {\n\t\t\t\t\t\t\tSystem.out.println(\"UNKNOWN\");\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tSystem.out.println(dist[B[i]] - dist[A[i]]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} catch (RuntimeException e) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic class Edge {\n\t\tint to, w;\n\n\t\tEdge(int to, int w) {\n\t\t\tthis.to = to;\n\t\t\tthis.w = w;\n\t\t}\n\t}\n\n\tstatic class UnionFind {\n\t\tint[] set;\n\n\t\tUnionFind(int n) {\n\t\t\tset = new int[n];\n\t\t\tArrays.fill(set, -1);\n\t\t}\n\n\t\tvoid union(int a, int b) {\n\t\t\tint rtA = root(a);\n\t\t\tint rtb = root(b);\n\t\t\tif (rtA == rtb) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tset[rtA] += set[rtb];\n\t\t\tset[rtb] = rtA;\n\t\t}\n\n\t\tboolean find(int a, int b) {\n\t\t\treturn root(a) == root(b);\n\t\t}\n\n\t\tint root(int a) {\n\t\t\tif (set[a] < 0) {\n\t\t\t\treturn a;\n\t\t\t} else {\n\t\t\t\tset[a] = root(set[a]);\n\t\t\t\treturn set[a];\n\t\t\t}\n\t\t}\n\n\t\tint size(int a) {\n\t\t\treturn -set[root(a)];\n\t\t}\n\t}\n\n\tstatic class FastScanner {\n\t\tReader input;\n\n\t\tFastScanner() {\n\t\t\tthis(System.in);\n\t\t}\n\n\t\tFastScanner(InputStream stream) {\n\t\t\tthis.input = new BufferedReader(new InputStreamReader(stream));\n\t\t}\n\n\t\tint nextInt() throws IOException {\n\t\t\tint sign = 1;\n\t\t\tint b = input.read();\n\t\t\twhile ((b < '0' || '9' < b) && b != '-' && b != '+') {\n\t\t\t\tb = input.read();\n\t\t\t}\n\t\t\tif (b == '-') {\n\t\t\t\tsign = -1;\n\t\t\t\tb = input.read();\n\t\t\t} else if (b == '+') {\n\t\t\t\tb = input.read();\n\t\t\t}\n\t\t\tint ret = b - '0';\n\t\t\twhile (true) {\n\t\t\t\tb = input.read();\n\t\t\t\tif (b < '0' || '9' < b) return ret * sign;\n\t\t\t\tret *= 10;\n\t\t\t\tret += b - '0';\n\t\t\t}\n\t\t}\n\n\t\tchar nextChar() throws IOException {\n\t\t\tint b = input.read();\n\t\t\twhile (Character.isWhitespace((char) b)) {\n\t\t\t\tb = input.read();\n\t\t\t}\n\t\t\treturn (char) b;\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "public class Main {\n\tMyScanner sc = new MyScanner();\n\tint N, M, a, b, w;\n\tint[] parent;\n\tNode[] node;\n\n\tvoid run() {\n\t\tfor (;;) {\n\t\t\tN = sc.nextInt(); // 荷物数\n\t\t\tM = sc.nextInt(); // クエリ数\n\t\t\tif ((N | M) == 0) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tparent = new int[N + 1];\n\t\t\tnode = new Node[N + 1];\n\t\t\tinit();\n\n\t\t\tfor (int i = 0; i < M; i++) {\n\t\t\t\tString query = sc.next();\n\t\t\t\ta = sc.nextInt();\n\t\t\t\tb = sc.nextInt();\n\t\t\t\tif (query.equals(\"!\")) {\n\t\t\t\t\tw = sc.nextInt();\n\t\t\t\t\tunion(a, b, w);\n\t\t\t\t} else if (query.equals(\"?\")) {\n\t\t\t\t\tSystem.out.println(same(a, b) ? node[b].weight\n\t\t\t\t\t\t\t- node[a].weight : \"UNKNOWN\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid init() {\n\t\tfor (int i = 0; i <= N; i++) {\n\t\t\tparent[i] = i;\n\t\t\tnode[i] = new Node(0, 0);\n\t\t}\n\t}\n\n\tvoid union(int x, int y, int w) {\n\t\tint rootX = find(x);\n\t\tint rootY = find(y);\n\t\tif (rootX == rootY) {\n\t\t\treturn;\n\t\t}\n\t\tif (node[rootX].rank < node[rootY].rank) {\n\t\t\tnode[rootX].weight = -w - node[x].weight + node[y].weight;\n\t\t\tparent[rootX] = rootY;\n\t\t} else {\n\t\t\tnode[rootY].weight = w - node[y].weight + node[x].weight;\n\t\t\tparent[rootY] = rootX;\n\n\t\t\tif (node[rootX].rank == node[rootY].rank) {\n\t\t\t\tnode[rootY].rank++;\n\t\t\t}\n\t\t}\n\t}\n\n\tint find(int target) {\n\t\tif (parent[target] == target) {\n\t\t\treturn target;\n\t\t} else {\n\t\t\tint tmp = find(parent[target]);\n\t\t\tnode[target].weight += node[parent[target]].weight;\n\t\t\treturn parent[target] = tmp;\n\t\t}\n\t}\n\n\tboolean same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\n\tclass Node {\n\t\tint weight;\n\t\tint rank;\n\n\t\t/**\n\t\t * @param weight\n\t\t * @param rank\n\t\t */\n\t\tpublic Node(int weight, int rank) {\n\t\t\tsuper();\n\t\t\tthis.weight = weight;\n\t\t\tthis.rank = rank;\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tclass MyScanner {\n\t\tint nextInt() {\n\t\t\ttry {\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (c != '-' && (c < '0' || '9' < c))\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tif (c == '-')\n\t\t\t\t\treturn -nextInt();\n\t\t\t\tint res = 0;\n\t\t\t\tdo {\n\t\t\t\t\tres *= 10;\n\t\t\t\t\tres += c - '0';\n\t\t\t\t\tc = System.in.read();\n\t\t\t\t} while ('0' <= c && c <= '9');\n\t\t\t\treturn res;\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\n\t\tString next() {\n\t\t\ttry {\n\t\t\t\tStringBuilder res = new StringBuilder(\"\");\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (Character.isWhitespace(c))\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tdo {\n\t\t\t\t\tres.append((char) c);\n\t\t\t\t} while (!Character.isWhitespace(c = System.in.read()));\n\t\t\t\treturn res.toString();\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n   \npublic class Main {\n    public static int N;\n    public static int M;\n    public static int[] p;\n    public static int[] rank;\n    public static int[] weight;\n  \n    public static boolean same(int x, int y) {\n        return findSet(x) == findSet(y);\n    }\n   \n    public static void unite(int x, int y, int w) {\n        int i = findSet(x);\n        int j = findSet(y);\n        \n  \n        if (i == j){\n        return;\n    }\n        if (rank[i] > rank[j]){\n            p[j] = i;      \n            weight[j] =  w - weight[y] + weight[x];\n            weight[y] += weight[j]; \n        } else {\n            p[i] = j;\n            weight[i] =  -w - weight[x] + weight[y];\n            weight[x] += weight[i]; \n            if(rank[i] == rank[j]){\n        rank[j]++;\n            }\n        }   \n    }\n   \n    public static int findSet(int i) {\n    if(p[i] == i){ \n        return i;\n        }else{      \n          return p[i] = findSet(p[i]);;\n        }\n    }\n   \n    public static void DisjointSet() {\n        p = new int[N];\n        rank = new int[N];\n        weight = new int[N];\n   \n        for (int i = 0; i < N; i++) {\n            p[i] = i;\n            rank[i] = 0;\n            weight[i] = 0;\n        }\n    }\n   \n   \n    public static void main (String[] args){\n        Scanner scanner = new Scanner(System.in);\n        while(true){\n        N = scanner.nextInt();\n        M = scanner.nextInt();\n  \n        if(N==0 && M==0){\n        break;\n        }\n   \n        DisjointSet();\n  \n        for (int i = 0; i < M; i++) {\n        String c = scanner.next();\n        int a = scanner.nextInt();\n        int b = scanner.nextInt();\n        a--; b--; \n          \n        if(c.equals(\"!\")){\n            int w = scanner.nextInt();\n            unite(a, b, w);\n        }else{ \n            if(same(a,b)){\n            System.out.println(weight[b] - weight[a]);\n            }else{\n            System.out.println(\"UNKNOWN\");\n            }\n        }\n        }\n    }\n        \n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n \npublic class Main {\n    public static int N;\n    public static int M;\n    public static int[] p;\n    public static int[] rank;\n    public static int[] weight;\n\n    public static boolean same(int a, int b) {\n        return findSet(a) == findSet(b);\n    }\n \n    public static void unite(int x, int y, int w) {\n        int i = findSet(x);\n        int j = findSet(y);\n        w -= weight[j] - weight[i];\n\n        if (i == j){\n\t    return;\n\t}\n        if (rank[i] > rank[j]){\n            p[j] = p[i];\n            weight[j] = w;\n        } else {\n            p[i] = p[j];\n            weight[i] = -w;\n            if(rank[i] == rank[j]){\n            rank[j]++;\n            }\n        }\t\n    }\n \n    public static int findSet(int i) {\n       if(p[i] == i){ \n           return i;\n        }else{\n          return p[i] = findSet(p[i]);\n        }\n    }\n \n    public static void DisjointSet() {\n        p = new int[N];\n        rank = new int[N];\n        weight = new int[N];\n \n        for (int i = 0; i < N; i++) {\n            p[i] = i;\n            rank[i] = 0;\n            weight[i] = 0;\n        }\n    }\n \n \n    public static void main (String[] args){\n        Scanner scanner = new Scanner(System.in);\n        while(true){\n        N = scanner.nextInt();\n        M = scanner.nextInt();\n\n        if(N==0 & M==0){\n           break;\n        }\n \n        DisjointSet();\n\n        for (int i = 0; i < M; i++) {\n            if(scanner.next().equals(\"!\")){\n            int a = scanner.nextInt();\n            int b = scanner.nextInt();\n            int w = scanner.nextInt();\n \n            a--; b--;   \n            unite(a, b, w);\n            }else{\n               if(same(a,b)){\n                    System.out.println(weight[b] - weight[a]);\n                }else{\n                    System.out.println(\"UNKNOWN\");\n\t\t}\n            }\n        }\n       }\n      \n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.io.Reader;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\n\npublic class Main {\n\tstatic FastScanner sc = new FastScanner(System.in);\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tint[] A = new int[100000];\n\t\tint[] B = new int[100000];\n\t\tint[] W = new int[100000];\n\t\tboolean[] type = new boolean[100000];\n\t\tint[] dist = new int[100000];\n\t\tArrayList<ArrayList<Edge>> graph = new ArrayList<ArrayList<Edge>>();\n\t\tfor (int i = 0; i < 100000; ++i) {\n\t\t\tgraph.add(new ArrayList<Edge>());\n\t\t}\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\twhile (true) {\n\t\t\tint N = sc.nextInt();\n\t\t\tint M = sc.nextInt();\n\t\t\tif (N == 0 || M == 0) break;\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tgraph.get(i).clear();\n\t\t\t}\n\t\t\tfor (int i = 0; i < M; ++i) {\n\t\t\t\ttype[i] = sc.nextChar() == '!';\n\t\t\t\tA[i] = sc.nextInt() - 1;\n\t\t\t\tB[i] = sc.nextInt() - 1;\n\t\t\t\tif (type[i]) {\n\t\t\t\t\tW[i] = sc.nextInt();\n\t\t\t\t\tgraph.get(A[i]).add(new Edge(B[i], W[i]));\n\t\t\t\t\tgraph.get(B[i]).add(new Edge(A[i], -W[i]));\n\t\t\t\t}\n\t\t\t}\n\t\t\tArrays.fill(dist, Integer.MIN_VALUE);\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tif (dist[i] != Integer.MIN_VALUE) continue;\n\t\t\t\tArrayDeque<Integer> q = new ArrayDeque<Integer>();\n\t\t\t\tq.add(i);\n\t\t\t\tdist[i] = 0;\n\t\t\t\twhile (!q.isEmpty()) {\n\t\t\t\t\tint cur = q.poll();\n\t\t\t\t\tfor (Edge e : graph.get(cur)) {\n\t\t\t\t\t\tint next = e.to;\n\t\t\t\t\t\tif (dist[next] != Integer.MIN_VALUE) continue;\n\t\t\t\t\t\tdist[next] = dist[cur] + e.w;\n\t\t\t\t\t\tq.add(next);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tUnionFind uf = new UnionFind(100000);\n\t\t\tfor (int i = 0; i < M; ++i) {\n\t\t\t\tif (type[i]) {\n\t\t\t\t\tif (A[i] == -1 || B[i] == -1) continue; \n\t\t\t\t\tuf.union(A[i], B[i]);\n\t\t\t\t} else {\n\t\t\t\t\tif (A[i] == -1 || B[i] == -1 || !uf.find(A[i], B[i])) {\n\t\t\t\t\t\tout.println(\"UNKNOWN\");\n\t\t\t\t\t} else {\n\t\t\t\t\t\tout.println(dist[B[i]] - dist[A[i]]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic class Edge {\n\t\tint to, w;\n\n\t\tEdge(int to, int w) {\n\t\t\tthis.to = to;\n\t\t\tthis.w = w;\n\t\t}\n\t}\n\n\tstatic class UnionFind {\n\t\tint[] set;\n\n\t\tUnionFind(int n) {\n\t\t\tset = new int[n];\n\t\t\tArrays.fill(set, -1);\n\t\t}\n\n\t\tvoid union(int a, int b) {\n\t\t\tint rtA = root(a);\n\t\t\tint rtb = root(b);\n\t\t\tif (rtA == rtb) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tset[rtA] += set[rtb];\n\t\t\tset[rtb] = rtA;\n\t\t}\n\n\t\tboolean find(int a, int b) {\n\t\t\treturn root(a) == root(b);\n\t\t}\n\n\t\tint root(int a) {\n\t\t\tif (set[a] < 0) {\n\t\t\t\treturn a;\n\t\t\t} else {\n\t\t\t\tset[a] = root(set[a]);\n\t\t\t\treturn set[a];\n\t\t\t}\n\t\t}\n\n\t\tint size(int a) {\n\t\t\treturn -set[root(a)];\n\t\t}\n\t}\n\n\tstatic class FastScanner {\n\t\tReader input;\n\n\t\tFastScanner() {\n\t\t\tthis(System.in);\n\t\t}\n\n\t\tFastScanner(InputStream stream) {\n\t\t\tthis.input = new BufferedReader(new InputStreamReader(stream));\n\t\t}\n\n\t\tint nextInt() throws IOException {\n\t\t\tint sign = 1;\n\t\t\tint b = input.read();\n\t\t\twhile ((b < '0' || '9' < b) && b != '-' && b != '+') {\n\t\t\t\tif (b == -1) return 0;\n\t\t\t\tb = input.read();\n\t\t\t}\n\t\t\tif (b == '-') {\n\t\t\t\tsign = -1;\n\t\t\t\tb = input.read();\n\t\t\t} else if (b == '+') {\n\t\t\t\tb = input.read();\n\t\t\t}\n\t\t\tint ret = b - '0';\n\t\t\twhile (true) {\n\t\t\t\tb = input.read();\n\t\t\t\tif (b < '0' || '9' < b) return ret * sign;\n\t\t\t\tret *= 10;\n\t\t\t\tret += b - '0';\n\t\t\t}\n\t\t}\n\n\t\tchar nextChar() throws IOException {\n\t\t\tint b = input.read();\n\t\t\twhile (Character.isWhitespace((char) b)) {\n\t\t\t\tb = input.read();\n\t\t\t}\n\t\t\treturn (char) b;\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.Reader;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic FastScanner sc = new FastScanner(System.in);\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tint[] A = new int[100000];\n\t\tint[] B = new int[100000];\n\t\tint[] W = new int[100000];\n\t\tboolean[] type = new boolean[100000];\n//\t\tint[] dist = new int[100000];\n//\t\tArrayList<ArrayList<Edge>> graph = new ArrayList<ArrayList<Edge>>();\n//\t\tfor (int i = 0; i < 100000; ++i) {\n//\t\t\tgraph.add(new ArrayList<Edge>());\n//\t\t}\n\t\twhile (true) {\n\t\t\tint N = sc.nextInt();\n\t\t\tint M = sc.nextInt();\n\t\t\tif (N == 0 || M == 0) break;\n//\t\t\tsc.nextLine();\n//\t\t\tfor (int i = 0; i < 100000; ++i) {\n//\t\t\t\tgraph.get(i).clear();\n//\t\t\t}\n\t\t\tfor (int i = 0; i < M; ++i) {\n//\t\t\t\tif (!sc.hasNextLine()) {\n//\t\t\t\t\tM = i;\n//\t\t\t\t\tbreak;\n//\t\t\t\t}\n//\t\t\t\tif (!sc.hasNextLine()) return;\n//\t\t\t\tString line = sc.nextLine();\n//\t\t\t\tString[] line = sc.nextLine().split(\" \");\n\t\t\t\ttype[i] = sc.nextChar() == '!';\n\t\t\t\tA[i] = sc.nextInt();\n\t\t\t\tB[i] = sc.nextInt();\n//\t\t\t\ttype[i] = line[0].charAt(0) == '!';\n//\t\t\t\tA[i] = Integer.parseInt(line[1]) - 1;\n//\t\t\t\tB[i] = Integer.parseInt(line[2]) - 1;\n\t\t\t\tif (type[i]) {\n\t\t\t\t\tW[i] = sc.nextInt();\n//\t\t\t\t\tW[i] = Integer.parseInt(line[3]);\n//\t\t\t\t\tgraph.get(A[i]).add(new Edge(B[i], W[i]));\n//\t\t\t\t\tgraph.get(B[i]).add(new Edge(A[i], -W[i]));\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.gc();\n//\t\t\tArrays.fill(dist, Integer.MIN_VALUE);\n//\t\t\tfor (int i = 0; i < N; ++i) {\n//\t\t\t\tif (dist[i] != Integer.MIN_VALUE) continue;\n//\t\t\t\tArrayDeque<Integer> q = new ArrayDeque<Integer>();\n//\t\t\t\tq.add(i);\n//\t\t\t\tdist[i] = 0;\n//\t\t\t\twhile (!q.isEmpty()) {\n//\t\t\t\t\tint cur = q.poll();\n//\t\t\t\t\tfor (Edge e : graph.get(cur)) {\n//\t\t\t\t\t\tint next = e.to;\n//\t\t\t\t\t\tif (dist[next] != Integer.MIN_VALUE) continue;\n//\t\t\t\t\t\tdist[next] = dist[cur] + e.w;\n//\t\t\t\t\t\tq.add(next);\n//\t\t\t\t\t}\n//\t\t\t\t}\n//\t\t\t}\n//\n//\t\t\tUnionFind uf = new UnionFind(100000);\n//\t\t\tfor (int i = 0; i < M; ++i) {\n//\t\t\t\tif (type[i]) {\n//\t\t\t\t\tuf.union(A[i], B[i]);\n//\t\t\t\t} else {\n//\t\t\t\t\tif (!uf.find(A[i], B[i])) {\n//\t\t\t\t\t\tSystem.out.println(\"UNKNOWN\");\n//\t\t\t\t\t} else {\n//\t\t\t\t\t\tSystem.out.println(dist[B[i]] - dist[A[i]]);\n//\t\t\t\t\t}\n//\t\t\t\t}\n//\t\t\t}\n\t\t}\n\t}\n\n\tstatic class Edge {\n\t\tint to, w;\n\n\t\tEdge(int to, int w) {\n\t\t\tthis.to = to;\n\t\t\tthis.w = w;\n\t\t}\n\t}\n\n\tstatic class UnionFind {\n\t\tint[] set;\n\n\t\tUnionFind(int n) {\n\t\t\tset = new int[n];\n\t\t\tArrays.fill(set, -1);\n\t\t}\n\n\t\tvoid union(int a, int b) {\n\t\t\tint rtA = root(a);\n\t\t\tint rtb = root(b);\n\t\t\tif (rtA == rtb) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tset[rtA] += set[rtb];\n\t\t\tset[rtb] = rtA;\n\t\t}\n\n\t\tboolean find(int a, int b) {\n\t\t\treturn root(a) == root(b);\n\t\t}\n\n\t\tint root(int a) {\n\t\t\tif (set[a] < 0) {\n\t\t\t\treturn a;\n\t\t\t} else {\n\t\t\t\tset[a] = root(set[a]);\n\t\t\t\treturn set[a];\n\t\t\t}\n\t\t}\n\n\t\tint size(int a) {\n\t\t\treturn -set[root(a)];\n\t\t}\n\t}\n\n\tstatic class FastScanner {\n\t\tReader input;\n\n\t\tFastScanner() {\n\t\t\tthis(System.in);\n\t\t}\n\n\t\tFastScanner(InputStream stream) {\n\t\t\tthis.input = new BufferedReader(new InputStreamReader(stream));\n\t\t}\n\n\t\tint nextInt() throws IOException {\n\t\t\tint sign = 1;\n\t\t\tint b = input.read();\n\t\t\twhile ((b < '0' || '9' < b) && b != '-' && b != '+') {\n\t\t\t\tif (b == -1) return 0;\n\t\t\t\tb = input.read();\n\t\t\t}\n\t\t\tif (b == '-') {\n\t\t\t\tsign = -1;\n\t\t\t\tb = input.read();\n\t\t\t} else if (b == '+') {\n\t\t\t\tb = input.read();\n\t\t\t}\n\t\t\tint ret = b - '0';\n\t\t\twhile (true) {\n\t\t\t\tb = input.read();\n\t\t\t\tif (b < '0' || '9' < b) return ret * sign;\n\t\t\t\tret *= 10;\n\t\t\t\tret += b - '0';\n\t\t\t}\n\t\t}\n\n\t\tchar nextChar() throws IOException {\n\t\t\tint b = input.read();\n\t\t\twhile (Character.isWhitespace((char) b)) {\n\t\t\t\tb = input.read();\n\t\t\t}\n\t\t\treturn (char) b;\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.Reader;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic Scanner sc = new Scanner(System.in);\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tint[] A = new int[100000];\n\t\tint[] B = new int[100000];\n\t\tint[] W = new int[100000];\n\t\tboolean[] type = new boolean[100000];\n\t\tint[] dist = new int[100000];\n\t\tArrayList<ArrayList<Edge>> graph = new ArrayList<ArrayList<Edge>>();\n\t\tfor (int i = 0; i < 100000; ++i) {\n\t\t\tgraph.add(new ArrayList<Edge>());\n\t\t}\n\t\twhile (sc.hasNextInt()) {\n\t\t\tint N = sc.nextInt();\n\t\t\tif (N == 0) break;\n\t\t\tint M = sc.nextInt();\n\t\t\tsc.nextLine();\n//\t\t\tfor (int i = 0; i < 100000; ++i) {\n//\t\t\t\tgraph.get(i).clear();\n//\t\t\t}\n\t\t\tfor (int i = 0; i < M; ++i) {\n//\t\t\t\tif (!sc.hasNextLine()) {\n//\t\t\t\t\tM = i;\n//\t\t\t\t\tbreak;\n//\t\t\t\t}\n\t\t\t\tString line = sc.nextLine();\n//\t\t\t\tString[] line = sc.nextLine().split(\" \");\n//\t\t\t\ttype[i] = line[0].charAt(0) == '!';\n//\t\t\t\tA[i] = Integer.parseInt(line[1]) - 1;\n//\t\t\t\tB[i] = Integer.parseInt(line[2]) - 1;\n//\t\t\t\tif (type[i]) {\n//\t\t\t\t\tW[i] = Integer.parseInt(line[3]);\n//\t\t\t\t\tgraph.get(A[i]).add(new Edge(B[i], W[i]));\n//\t\t\t\t\tgraph.get(B[i]).add(new Edge(A[i], -W[i]));\n//\t\t\t\t}\n\t\t\t}\n//\t\t\tArrays.fill(dist, Integer.MIN_VALUE);\n//\t\t\tfor (int i = 0; i < N; ++i) {\n//\t\t\t\tif (dist[i] != Integer.MIN_VALUE) continue;\n//\t\t\t\tArrayDeque<Integer> q = new ArrayDeque<Integer>();\n//\t\t\t\tq.add(i);\n//\t\t\t\tdist[i] = 0;\n//\t\t\t\twhile (!q.isEmpty()) {\n//\t\t\t\t\tint cur = q.poll();\n//\t\t\t\t\tfor (Edge e : graph.get(cur)) {\n//\t\t\t\t\t\tint next = e.to;\n//\t\t\t\t\t\tif (dist[next] != Integer.MIN_VALUE) continue;\n//\t\t\t\t\t\tdist[next] = dist[cur] + e.w;\n//\t\t\t\t\t\tq.add(next);\n//\t\t\t\t\t}\n//\t\t\t\t}\n//\t\t\t}\n//\n//\t\t\tUnionFind uf = new UnionFind(100000);\n//\t\t\tfor (int i = 0; i < M; ++i) {\n//\t\t\t\tif (type[i]) {\n//\t\t\t\t\tuf.union(A[i], B[i]);\n//\t\t\t\t} else {\n//\t\t\t\t\tif (!uf.find(A[i], B[i])) {\n//\t\t\t\t\t\tSystem.out.println(\"UNKNOWN\");\n//\t\t\t\t\t} else {\n//\t\t\t\t\t\tSystem.out.println(dist[B[i]] - dist[A[i]]);\n//\t\t\t\t\t}\n//\t\t\t\t}\n//\t\t\t}\n\t\t}\n\t}\n\n\tstatic class Edge {\n\t\tint to, w;\n\n\t\tEdge(int to, int w) {\n\t\t\tthis.to = to;\n\t\t\tthis.w = w;\n\t\t}\n\t}\n\n\tstatic class UnionFind {\n\t\tint[] set;\n\n\t\tUnionFind(int n) {\n\t\t\tset = new int[n];\n\t\t\tArrays.fill(set, -1);\n\t\t}\n\n\t\tvoid union(int a, int b) {\n\t\t\tint rtA = root(a);\n\t\t\tint rtb = root(b);\n\t\t\tif (rtA == rtb) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tset[rtA] += set[rtb];\n\t\t\tset[rtb] = rtA;\n\t\t}\n\n\t\tboolean find(int a, int b) {\n\t\t\treturn root(a) == root(b);\n\t\t}\n\n\t\tint root(int a) {\n\t\t\tif (set[a] < 0) {\n\t\t\t\treturn a;\n\t\t\t} else {\n\t\t\t\tset[a] = root(set[a]);\n\t\t\t\treturn set[a];\n\t\t\t}\n\t\t}\n\n\t\tint size(int a) {\n\t\t\treturn -set[root(a)];\n\t\t}\n\t}\n\n\tstatic class FastScanner {\n\t\tReader input;\n\n\t\tFastScanner() {\n\t\t\tthis(System.in);\n\t\t}\n\n\t\tFastScanner(InputStream stream) {\n\t\t\tthis.input = new BufferedReader(new InputStreamReader(stream));\n\t\t}\n\n\t\tint nextInt() throws IOException {\n\t\t\tint sign = 1;\n\t\t\tint b = input.read();\n\t\t\twhile ((b < '0' || '9' < b) && b != '-' && b != '+') {\n\t\t\t\tif (b == -1) return 0;\n\t\t\t\tb = input.read();\n\t\t\t}\n\t\t\tif (b == '-') {\n\t\t\t\tsign = -1;\n\t\t\t\tb = input.read();\n\t\t\t} else if (b == '+') {\n\t\t\t\tb = input.read();\n\t\t\t}\n\t\t\tint ret = b - '0';\n\t\t\twhile (true) {\n\t\t\t\tb = input.read();\n\t\t\t\tif (b < '0' || '9' < b) return ret * sign;\n\t\t\t\tret *= 10;\n\t\t\t\tret += b - '0';\n\t\t\t}\n\t\t}\n\n\t\tchar nextChar() throws IOException {\n\t\t\tint b = input.read();\n\t\t\twhile (Character.isWhitespace((char) b)) {\n\t\t\t\tb = input.read();\n\t\t\t}\n\t\t\treturn (char) b;\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.Reader;\nimport java.util.Arrays;\nimport java.util.Scanner;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\n\tpublic static class WeightedUnionFind{\n\t    int[] par; // 親の番号\n\t    int[] ws;  // 親との重みの差\n\t    \n\t    public WeightedUnionFind(int n){\n\t        par = new int[n];\n\t        ws  = new int[n];\n\t        for(int i = 0; i < n; i++){ \n\t        \tpar[i] = -1;\n\t        }\n\t    }\n\t    \n\t    public int find(int x){\n\t    \tif(par[x] < 0){\n\t    \t\treturn x;\n\t    \t}else{\n\t    \t\tfinal int parent = find(par[x]);\n\t    \t\tws[x] += ws[par[x]];\n\t    \t\tpar[x] = parent;\n\t    \t\treturn parent;\n\t    \t}\n\t    }\n\t    \n\t    public int weight(int x){\n\t    \tfind(x);\n\t    \treturn ws[x];\n\t    }\n\t    \n\t    public boolean union(int x, int y, int w){ // x <-(w)- y (x + w = y)\n\t    \tw += weight(x);\n\t    \tw -= weight(y);\n\t        x = find(x);\n\t        y = find(y);\n\t        \n\t        if(x != y){\n\t            if(par[y] < par[x]) {  // 多い方が根になるようにスワップする.\n\t                int tmp = x; x = y; y = tmp;\n\t                w = -w;\n\t            }\n\t            par[x] += par[y];\n\t            par[y] = x;\n\t            ws[y] = w;\n\t            \n\t            return true;\n\t        }else{\n\t            return false;\n\t        }\n\t    }\n\t    \n\t    public boolean same(int x, int y){\n\t        return find(x) == find(y);\n\t    }\n\t    \n\t    public Integer diff(int x, int y){ // x - y を求める. 比較不能ならnull.\n\t    \tif(!same(x, y)){\n\t    \t\treturn null;\n\t    \t}else{\n\t    \t\treturn this.weight(x) - this.weight(y);\n\t    \t}\n\t    }\n\t    \n\t    public int size(int x){\n\t        return -par[find(x)];\n\t    }\n\t}\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tScanner sc = new Scanner(System.in);\n\n\t\twhile(true){\n\t\t\tfinal int n = sc.nextInt();\n\t\t\tfinal int m = sc.nextInt();\n\t\t\t\n\t\t\tif(n == 0 && m == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tWeightedUnionFind uf = new WeightedUnionFind(n);\n\t\t\t\n\t\t\tfor(int i = 0; i < m; i++){\n\t\t\t\tfinal char ops = sc.nextChar();\n\t\t\t\t\n\t\t\t\tif('?' == ops){\n\t\t\t\t\tfinal int r = sc.nextInt() - 1;\n\t\t\t\t\tfinal int l = sc.nextInt() - 1;\n\t\t\t\t\tfinal Integer ret = uf.diff(r, l);\n\t\t\t\t\tSystem.out.println(ret == null ? \"UNKNOWN\" : -ret);\n\t\t\t\t}else{\n\t\t\t\t\tfinal int r = sc.nextInt() - 1;\n\t\t\t\t\tfinal int l = sc.nextInt() - 1;\n\t\t\t\t\tfinal int w = sc.nextInt();\n\t\t\t\t\t\n\t\t\t\t\tuf.union(r, l, w);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tsc.close();\n\t}\n\t\n\tpublic static class Scanner {\n\t    private Reader br;\n\n\t    public Scanner(InputStream is) throws IOException {\n\t        br = new BufferedReader(new InputStreamReader(is));\n\t    }\n\t    \n\t    public int nextInt() throws IOException {\n\t    \tint sign = 1;\n\t    \tint b = br.read();\n\t    \t\n\t    \twhile(((b < '0') || ('9' < b)) && b != '-' && b != '+'){\n\t    \t\tif(b == -1){ return 0; }\n\t    \t\tb = br.read();\n\t    \t}\n\t    \t\n\t    \tif(b == '-'){\n\t    \t\tsign = -1;\n\t    \t\tb = br.read();\n\t    \t}else if(b == '+'){\n\t    \t\tb = br.read();\n\t    \t}\n\t    \t\n\t    \tint ret = b - '0';\n\t    \twhile(true){\n\t    \t\tb = br.read();\n\t    \t\tif(b < '0' || b > '9'){ return sign * ret; }\n\t    \t\tret *= 10;\n\t    \t\tret += b - '0';\n\t    \t}\n\t    }\n\t    \n\t    public char nextChar() throws IOException{\n\t    \tint b = br.read();\n\t    \twhile(Character.isWhitespace(b)){\n\t    \t\tb = br.read();\n\t    \t}\n\t    \treturn (char)(b);\n\t    }\n\t    \n\t    public void close() throws IOException {\n\t        br.close();\n\t    }\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.Reader;\nimport java.util.Arrays;\nimport java.util.Scanner;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\n\tpublic static class WeightedUnionFind{\n\t    int[] par; // 親の番号\n\t    int[] ws;  // 親との重みの差\n\t    \n\t    public WeightedUnionFind(int n){\n\t        par = new int[n];\n\t        ws  = new int[n];\n\t        for(int i = 0; i < n; i++){ \n\t        \tpar[i] = -1;\n\t        }\n\t    }\n\t    \n\t    public int find(int x){\n\t    \tif(par[x] < 0){\n\t    \t\treturn x;\n\t    \t}else{\n\t    \t\tfinal int parent = find(par[x]);\n\t    \t\tws[x] += ws[par[x]];\n\t    \t\tpar[x] = parent;\n\t    \t\treturn parent;\n\t    \t}\n\t    }\n\t    \n\t    public int weight(int x){\n\t    \tfind(x);\n\t    \treturn ws[x];\n\t    }\n\t    \n\t    public boolean union(int x, int y, int w){ // x <-(w)- y (x + w = y)\n\t    \tw += weight(x);\n\t    \tw -= weight(y);\n\t        x = find(x);\n\t        y = find(y);\n\t        \n\t        if(x != y){\n\t            if(par[y] < par[x]) {  // 多い方が根になるようにスワップする.\n\t                int tmp = x; x = y; y = tmp;\n\t                w = -w;\n\t            }\n\t            par[x] += par[y];\n\t            par[y] = x;\n\t            ws[y] = w;\n\t            \n\t            return true;\n\t        }else{\n\t            return false;\n\t        }\n\t    }\n\t    \n\t    public boolean same(int x, int y){\n\t        return find(x) == find(y);\n\t    }\n\t    \n\t    public Integer diff(int x, int y){ // x - y を求める. 比較不能ならnull.\n\t    \tif(!same(x, y)){\n\t    \t\treturn null;\n\t    \t}else{\n\t    \t\treturn this.weight(x) - this.weight(y);\n\t    \t}\n\t    }\n\t    \n\t    public int size(int x){\n\t        return -par[find(x)];\n\t    }\n\t}\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tScanner sc = new Scanner(System.in);\n\n\t\twhile(true){\n\t\t\tfinal int n = sc.nextInt();\n\t\t\tfinal int m = sc.nextInt();\n\t\t\t\n\t\t\tif(n == 0 && m == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tWeightedUnionFind uf = new WeightedUnionFind(n);\n\t\t\t\n\t\t\tfor(int i = 0; i < m; i++){\n\t\t\t\tfinal String ops = sc.next();\n\t\t\t\t\n\t\t\t\tif(\"?\".equals(ops)){\n\t\t\t\t\tfinal int r = sc.nextInt() - 1;\n\t\t\t\t\tfinal int l = sc.nextInt() - 1;\n\t\t\t\t\t\n\t\t\t\t\tif(!uf.same(r, l)){\n\t\t\t\t\t\tSystem.out.println(\"UNKNOWN\");\n\t\t\t\t\t}else{\n\t\t\t\t\t\tSystem.out.println(uf.weight(l) - uf.weight(r));\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tfinal int r = sc.nextInt() - 1;\n\t\t\t\t\tfinal int l = sc.nextInt() - 1;\n\t\t\t\t\tfinal int w = sc.nextInt();\n\t\t\t\t\t\n\t\t\t\t\tuf.union(r, l, w);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tsc.close();\n\t}\n\t\n\tpublic static class Scanner {\n\t    private BufferedReader br;\n\t    private StringTokenizer tok;\n\n\t    public Scanner(InputStream is) throws IOException {\n\t        br = new BufferedReader(new InputStreamReader(is));\n\t    }\n\n\t    private void getLine() throws IOException {\n\t        while (!hasNext()) { tok = new StringTokenizer(br.readLine()); }\n\t    }\n\n\t    private boolean hasNext() {\n\t        return tok != null && tok.hasMoreTokens();\n\t    }\n\n\t    public String next() throws IOException {\n\t        getLine(); return tok.nextToken();\n\t    }\n\n\t    public int nextInt() throws IOException {\n\t        return Integer.parseInt(next());\n\t    }\n\t    // 他のnextXXXもXXX.parseXXX()メソッドを使って作れるので省略\n\t    \n\t    public void close() throws IOException {\n\t        br.close();\n\t    }\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.io.Reader;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\n\npublic class Main {\n\tstatic FastScanner sc = new FastScanner(System.in);\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tint[] A = new int[100000];\n\t\tint[] B = new int[100000];\n\t\tint[] W = new int[100000];\n\t\tboolean[] type = new boolean[100000];\n\t\tint[] dist = new int[100000];\n\t\tArrayList<ArrayList<Edge>> graph = new ArrayList<ArrayList<Edge>>();\n\t\tfor (int i = 0; i < 100000; ++i) {\n\t\t\tgraph.add(new ArrayList<Edge>());\n\t\t}\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\twhile (true) {\n\t\t\tint N = sc.nextInt();\n\t\t\tint M = sc.nextInt();\n\t\t\tif (N == 0 || M == 0) break;\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tgraph.get(i).clear();\n\t\t\t}\n\t\t\tfor (int i = 0; i < M; ++i) {\n\t\t\t\ttype[i] = sc.nextChar() == '!';\n\t\t\t\tA[i] = sc.nextInt() - 1;\n\t\t\t\tB[i] = sc.nextInt() - 1;\n\t\t\t\tif (type[i]) {\n\t\t\t\t\tW[i] = sc.nextInt();\n\t\t\t\t\tgraph.get(A[i]).add(new Edge(B[i], W[i]));\n\t\t\t\t\tgraph.get(B[i]).add(new Edge(A[i], -W[i]));\n\t\t\t\t}\n\t\t\t}\n\t\t\tArrays.fill(dist, Integer.MIN_VALUE);\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tif (dist[i] != Integer.MIN_VALUE) continue;\n\t\t\t\tArrayDeque<Integer> q = new ArrayDeque<Integer>();\n\t\t\t\tq.add(i);\n\t\t\t\tdist[i] = 0;\n\t\t\t\twhile (!q.isEmpty()) {\n\t\t\t\t\tint cur = q.poll();\n\t\t\t\t\tfor (Edge e : graph.get(cur)) {\n\t\t\t\t\t\tint next = e.to;\n\t\t\t\t\t\tif (dist[next] != Integer.MIN_VALUE) continue;\n\t\t\t\t\t\tdist[next] = dist[cur] + e.w;\n\t\t\t\t\t\tq.add(next);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tUnionFind uf = new UnionFind(N);\n\t\t\tfor (int i = 0; i < M; ++i) {\n\t\t\t\tif (type[i]) {\n\t\t\t\t\tif (A[i] < 0 || A[i] >= N || B[i] < 0 || B[i] >= N) continue;\n\t\t\t\t\tuf.union(A[i], B[i]);\n\t\t\t\t} else {\n\t\t\t\t\tif (A[i] < 0 || A[i] >= N || B[i] < 0 || B[i] >= N || !uf.find(A[i], B[i])) {\n\t\t\t\t\t\tout.println(\"UNKNOWN\");\n\t\t\t\t\t} else {\n\t\t\t\t\t\tout.println(dist[B[i]] - dist[A[i]]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic class Edge {\n\t\tint to, w;\n\n\t\tEdge(int to, int w) {\n\t\t\tthis.to = to;\n\t\t\tthis.w = w;\n\t\t}\n\t}\n\n\tstatic class UnionFind {\n\t\tint[] set;\n\n\t\tUnionFind(int n) {\n\t\t\tset = new int[n];\n\t\t\tArrays.fill(set, -1);\n\t\t}\n\n\t\tvoid union(int a, int b) {\n\t\t\tint rtA = root(a);\n\t\t\tint rtb = root(b);\n\t\t\tif (rtA == rtb) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tset[rtA] += set[rtb];\n\t\t\tset[rtb] = rtA;\n\t\t}\n\n\t\tboolean find(int a, int b) {\n\t\t\treturn root(a) == root(b);\n\t\t}\n\n\t\tint root(int a) {\n\t\t\tif (set[a] < 0) {\n\t\t\t\treturn a;\n\t\t\t} else {\n\t\t\t\tArrayList<Integer> pos = new ArrayList<Integer>();\n\t\t\t\tpos.add(a);\n\t\t\t\tint rt = -1;\n\t\t\t\twhile (true) {\n\t\t\t\t\tint parent = set[pos.get(pos.size() - 1)];\n\t\t\t\t\tif (parent < 0) {\n\t\t\t\t\t\trt = pos.get(pos.size() - 1);\n\t\t\t\t\t\tfor (int i = 0; i < pos.size() - 1; ++i) {\n\t\t\t\t\t\t\tset[pos.get(i)] = rt;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn rt;\n\t\t\t\t\t}\n\t\t\t\t\tpos.add(parent);\n\t\t\t\t}\n//\t\t\t\tset[a] = root(set[a]);\n//\t\t\t\treturn set[a];\n\t\t\t}\n\t\t}\n\n\t\tint size(int a) {\n\t\t\treturn -set[root(a)];\n\t\t}\n\t}\n\n\tstatic class FastScanner {\n\t\tReader input;\n\n\t\tFastScanner() {\n\t\t\tthis(System.in);\n\t\t}\n\n\t\tFastScanner(InputStream stream) {\n\t\t\tthis.input = new BufferedReader(new InputStreamReader(stream));\n\t\t}\n\n\t\tint nextInt() throws IOException {\n\t\t\tint sign = 1;\n\t\t\tint b = input.read();\n\t\t\twhile ((b < '0' || '9' < b) && b != '-' && b != '+') {\n\t\t\t\tif (b == -1) return 0;\n\t\t\t\tb = input.read();\n\t\t\t}\n\t\t\tif (b == '-') {\n\t\t\t\tsign = -1;\n\t\t\t\tb = input.read();\n\t\t\t} else if (b == '+') {\n\t\t\t\tb = input.read();\n\t\t\t}\n\t\t\tint ret = b - '0';\n\t\t\twhile (true) {\n\t\t\t\tb = input.read();\n\t\t\t\tif (b < '0' || '9' < b) return ret * sign;\n\t\t\t\tret *= 10;\n\t\t\t\tret += b - '0';\n\t\t\t}\n\t\t}\n\n\t\tchar nextChar() throws IOException {\n\t\t\tint b = input.read();\n\t\t\twhile (Character.isWhitespace((char) b)) {\n\t\t\t\tb = input.read();\n\t\t\t}\n\t\t\treturn (char) b;\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n \npublic class Main {\n    public static int N;\n    public static int M;\n    public static int[] p;\n    public static int[] rank;\n    public static int[] weight;\n\n    public static boolean same(int x, int y) {\n        return findSet(x) == findSet(y);\n    }\n \n    public static void unite(int x, int y, int w) {\n        int i = findSet(x);\n        int j = findSet(y);\n        w -= weight[b] - weight[a];\n\n        if (i == j){\n\t    return;\n\t}\n        if (rank[i] > rank[j]){\n            p[j] = p[i];\n            weight[j] = w;\n        } else {\n            p[i] = p[j];\n            weight[i] = -w;\n            if(rank[i] == rank[j]){\n            rank[j]++;\n            }\n        }\t\n    }\n \n    public static int findSet(int i) {\n       if(p[i] == i){ \n           return i;\n        }else{\n          return p[i] = findSet(p[i]);\n        }\n    }\n \n    public static void DisjointSet() {\n        p = new int[N];\n        rank = new int[N];\n        weight = new int[N];\n \n        for (int i = 0; i < N; i++) {\n            p[i] = i;\n            rank[i] = 0;\n            weight[i] = 0;\n        }\n    }\n \n \n    public static void main (String[] args){\n        Scanner scanner = new Scanner(System.in);\n        while(true){\n        N = scanner.nextInt();\n        M = scanner.nextInt();\n\n        if(N==0 & M==0){\n           break;\n        }\n \n        DisjointSet();\n\n        for (int i = 0; i < M; i++) {\n            if(scanner.next().equals(\"!\")){\n            int a = scanner.nextInt();\n            int b = scanner.nextInt();\n            int w = scanner.nextInt();\n \n            a--; b--;   \n            unite(a, b, w);\n            }else{\n               if(same(x, y)){\n                    System.out.println(\"UNKNOWN\");\n                }else{\n                    System.out.println(weight[b]-weight[a]);\n\t\t}\n            }\n        }\n       }\n      \n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\n@SuppressWarnings(\"unchecked\")\nclass Main{\n\n    int n, m;\n    int INF = Integer.MAX_VALUE/2;\n    ArrayList[] list;\n\n    class P{\n\tint to, weight;\n\tP(int to, int weight){\n\t    this.to = to;\n\t    this.weight = weight;\n\t}\n    }\n\n    void solve(){\n\tScanner sc = new Scanner(System.in);\n\twhile(true){\n\t    n = sc.nextInt(); m = sc.nextInt();\n\t    if(n==0 && m==0) break;\n\n\t    list = new ArrayList[n+1];\n\t    for(int i=0; i<=n; i++) list[i] = new ArrayList<P>();\n\t    for(int i=0; i<m; i++){\n\t\tchar command = sc.next().charAt(0);\n\t\tif(command=='!'){\n\t\t    int a = sc.nextInt(), b = sc.nextInt(), w = sc.nextInt();\n\t\t    list[a].add(new P(b, w));\n\t\t    list[b].add(new P(a, -w));\n\t\t}else{\n\t\t    int b = dijkstra(sc.nextInt(), sc.nextInt());\n\t\t    if(b==INF) System.out.println(\"UNKNOWN\");\n\t\t    else System.out.println(b);\n\t\t}\n\t    }\n\t}\n    }\n\n    int dijkstra(int start, int goal){\n\t//pos, cost\n\t/*\n\tPriorityQueue<int[]> q = new PriorityQueue<int[]>(10, new Comparator<int[]>(){\n\t\tpublic int compare(int[] p1, int[] p2){\n\t\t    return p1[1] - p2[1];\n\t\t}\n\t    });\n\t*/\n\tLinkedList<int[]> q = new LinkedList<int[]>();\n\tq.add(new int[]{start, 0});\n\tboolean[] v = new boolean[n+1];\n\n\twhile(q.size()>0){\n\t    int[] qq = q.poll();\n\t    int pos = qq[0], cost = qq[1];\n\n\t    if(pos==goal) return cost;\n\t    if(v[pos]) continue;\n\t    v[pos] = true;\n\n\t    for(int i=0; i<list[pos].size(); i++){\n\t\tP p = (P)list[pos].get(i);\n\t\tq.add(new int[]{p.to, cost+p.weight});\n\t    }\n\t}\n\treturn INF;\n    }\n\n    public static void main(String[] args){\n\tnew Main().solve();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n \npublic class Main {\n    public static int N;\n    public static int M;\n    public static int[] p;\n    public static int[] rank;\n    public static int[] weight;\n\n    public static boolean same(int x, int y) {\n        return findSet(x) == findSet(y);\n    }\n \n    public static void unite(int x, int y, int w) {\n        int i = findSet(x);\n        int j = findSet(y);\n        w -= weight[j] - weight[i];\n\n        if (i == j){\n\t    return;\n\t}\n        if (rank[i] > rank[j]){\n            p[j] = p[i];\n            weight[j] = w;\n        } else {\n            p[i] = p[j];\n            weight[i] = -w;\n            if(rank[i] == rank[j]){\n\t\trank[j]++;\n            }\n        }\t\n    }\n \n    public static int findSet(int i) {\n\tif(p[i] == i){ \n\t    return i;\n        }else{\n\t    return p[i] = findSet(p[i]);\n        }\n    }\n \n    public static void DisjointSet() {\n        p = new int[N];\n        rank = new int[N];\n        weight = new int[N];\n \n        for (int i = 0; i < N; i++) {\n            p[i] = i;\n            rank[i] = 0;\n            weight[i] = 0;\n        }\n    }\n \n \n    public static void main (String[] args){\n        Scanner scanner = new Scanner(System.in);\n        while(true){\n\t    N = scanner.nextInt();\n\t    M = scanner.nextInt();\n\n\t    if(N==0 |M==0){\n\t\tbreak;\n\t    }\n \n\t    DisjointSet();\n\n\t    for (int i = 0; i < M; i++) {\n\t\tString c = scanner.next();\n\t\tint a = scanner.nextInt();\n\t\tint b = scanner.nextInt();\n\t\ta--; b--; \n\t\t\n\t\tif(c.equals(\"!\")){\n\t\t    int w = scanner.nextInt();\n\t\t    unite(a, b, w);\n\t\t}else{ \n\t\t    if(same(a,b)){\n\t\t\tSystem.out.println(weight[b] - weight[a]);\n\t\t    }else{\n\t\t\tSystem.out.println(\"UNKNOWN\");\n\t\t    }\n\t\t}\n\t    }\n\t}\n      \n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n  \npublic class Main {\n    public static int N;\n    public static int M;\n    public static int[] p;\n    public static int[] rank;\n    public static int[] weight;\n \n    public static boolean same(int x, int y) {\n        return findSet(x) == findSet(y);\n    }\n  \n    public static void unite(int x, int y, int w) {\n        int i = findSet(x);\n        int j = findSet(y);\n       \n \n        if (i == j){\n\t    return;\n\t}\n        if (rank[i] > rank[j]){\n            p[j] = i;\t   \n            weight[j] =  w - weight[y] + weight[x];\n        } else {\n            p[i] = j;\n            weight[i] =  -w - weight[x] + weight[y];\n            if(rank[i] == rank[j]){\n\t\trank[j]++;\n            }\n        }   \n    }\n  \n    public static int findSet(int i) {\n\tif(p[i] == i){ \n\t    return i;\n        }else{\n\t    int tmp = findSet(p[i]);\n\t    weight[i] += weight[p[i]];\n\t    return p[i] = tmp;\n        }\n    }\n  \n    public static void DisjointSet() {\n        p = new int[N];\n        rank = new int[N];\n        weight = new int[N];\n  \n        for (int i = 0; i < N; i++) {\n            p[i] = i;\n            rank[i] = 0;\n            weight[i] = 0;\n        }\n    }\n  \n  \n    public static void main (String[] args){\n        Scanner scanner = new Scanner(System.in);\n        while(true){\n\t    N = scanner.nextInt();\n\t    M = scanner.nextInt();\n \n\t    if(N==0 && M==0){\n\t\tbreak;\n\t    }\n  \n\t    DisjointSet();\n \n\t    for (int i = 0; i < M; i++) {\n\t\tString c = scanner.next();\n\t\tint a = scanner.nextInt();\n\t\tint b = scanner.nextInt();\n\t\ta--; b--; \n         \n\t\tif(c.equals(\"!\")){\n\t\t    int w = scanner.nextInt();\n\t\t    unite(a, b, w);\n\t\t}else{ \n\t\t    if(same(a,b)){\n\t\t\tSystem.out.println(weight[b] - weight[a]);\n\t\t    }else{\n\t\t\tSystem.out.println(\"UNKNOWN\");\n\t\t    }\n\t\t}\n\t    }\n\t}\n       \n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.Reader;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\n\npublic class Main {\n\tstatic FastScanner sc = new FastScanner(System.in);\n\tstatic int N;\n\n\tpublic static void main(String[] args) throws Exception {\n\t\twhile (true) {\n\t\t\tN = sc.nextInt();\n\t\t\tif (N == 0) break;\n\t\t\tint M = sc.nextInt();\n\t\t\tint[] A = new int[M];\n\t\t\tint[] B = new int[M];\n\t\t\tint[] W = new int[M];\n\t\t\tboolean[] type = new boolean[M];\n\t\t\tArrayList<ArrayList<Edge>> graph = new ArrayList<ArrayList<Edge>>();\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tgraph.add(new ArrayList<Edge>());\n\t\t\t}\n\t\t\tfor (int i = 0; i < M; ++i) {\n\t\t\t\ttype[i] = sc.nextChar() == '!';\n\t\t\t\tA[i] = sc.nextInt() - 1;\n\t\t\t\tB[i] = sc.nextInt() - 1;\n\t\t\t\tif (type[i]) {\n\t\t\t\t\tW[i] = sc.nextInt();\n\t\t\t\t\tgraph.get(A[i]).add(new Edge(B[i], W[i]));\n\t\t\t\t\tgraph.get(B[i]).add(new Edge(A[i], -W[i]));\n\t\t\t\t}\n\t\t\t}\n\t\t\tint[] dist = new int[N];\n\t\t\tArrays.fill(dist, Integer.MIN_VALUE);\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tif (dist[i] != Integer.MIN_VALUE) continue;\n\t\t\t\tArrayDeque<Integer> q = new ArrayDeque<Integer>();\n\t\t\t\tq.add(i);\n\t\t\t\tdist[i] = 0;\n\t\t\t\twhile (!q.isEmpty()) {\n\t\t\t\t\tint cur = q.poll();\n\t\t\t\t\tfor (Edge e : graph.get(cur)) {\n\t\t\t\t\t\tint next = e.to;\n\t\t\t\t\t\tif (dist[next] != Integer.MIN_VALUE) continue;\n\t\t\t\t\t\tdist[next] = dist[cur] + e.w;\n\t\t\t\t\t\tq.add(next);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tUnionFind uf = new UnionFind(N);\n\t\t\tfor (int i = 0; i < M; ++i) {\n\t\t\t\tif (type[i]) {\n\t\t\t\t\tuf.union(A[i], B[i]);\n\t\t\t\t} else {\n\t\t\t\t\tif (!uf.find(A[i], B[i])) {\n\t\t\t\t\t\tSystem.out.println(\"UNKNOWN\");\n\t\t\t\t\t} else {\n\t\t\t\t\t\tSystem.out.println(dist[B[i]] - dist[A[i]]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic class Edge {\n\t\tint to, w;\n\n\t\tEdge(int to, int w) {\n\t\t\tthis.to = to;\n\t\t\tthis.w = w;\n\t\t}\n\t}\n\n\tstatic class UnionFind {\n\t\tint[] set;\n\n\t\tUnionFind(int n) {\n\t\t\tset = new int[n];\n\t\t\tArrays.fill(set, -1);\n\t\t}\n\n\t\tvoid union(int a, int b) {\n\t\t\tint rtA = root(a);\n\t\t\tint rtb = root(b);\n\t\t\tif (rtA == rtb) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tset[rtA] += set[rtb];\n\t\t\tset[rtb] = rtA;\n\t\t}\n\n\t\tboolean find(int a, int b) {\n\t\t\treturn root(a) == root(b);\n\t\t}\n\n\t\tint root(int a) {\n\t\t\tif (set[a] < 0) {\n\t\t\t\treturn a;\n\t\t\t} else {\n\t\t\t\tset[a] = root(set[a]);\n\t\t\t\treturn set[a];\n\t\t\t}\n\t\t}\n\n\t\tint size(int a) {\n\t\t\treturn -set[root(a)];\n\t\t}\n\t}\n\n\tstatic class FastScanner {\n\t\tReader input;\n\n\t\tFastScanner() {\n\t\t\tthis(System.in);\n\t\t}\n\n\t\tFastScanner(InputStream stream) {\n\t\t\tthis.input = new BufferedReader(new InputStreamReader(stream));\n\t\t}\n\n\t\tint nextInt() throws IOException {\n\t\t\tint sign = 1;\n\t\t\tint b = input.read();\n\t\t\twhile ((b < '0' || '9' < b) && b != '-' && b != '+') {\n\t\t\t\tb = input.read();\n\t\t\t}\n\t\t\tif (b == '-') {\n\t\t\t\tsign = -1;\n\t\t\t\tb = input.read();\n\t\t\t} else if (b == '+') {\n\t\t\t\tb = input.read();\n\t\t\t}\n\t\t\tint ret = b - '0';\n\t\t\twhile (true) {\n\t\t\t\tb = input.read();\n\t\t\t\tif (b < '0' || '9' < b) return ret * sign;\n\t\t\t\tret *= 10;\n\t\t\t\tret += b - '0';\n\t\t\t}\n\t\t}\n\n\t\tchar nextChar() throws IOException {\n\t\t\tint b = input.read();\n\t\t\twhile (Character.isWhitespace((char) b)) {\n\t\t\t\tb = input.read();\n\t\t\t}\n\t\t\treturn (char) b;\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.ListIterator;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\t\n\tpublic static class WeightUnionFind{\n\t\tint[] par;\n\t\tint[] diff_weight;\n\t\t\n\t\tWeightUnionFind(int n){\n\t\t\tpar=new int[n];\n\t\t\tdiff_weight = new int[n];\n\t\t\t\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tpar[i]=i;\n\t\t\t\tdiff_weight[i] = 0;\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic int find(int x){\n\t\t\tif(par[x]==x){\n\t\t\t\treturn x;\n\t\t\t}\n\t\t\t\n\t\t\tint old_par = par[x];\n\t\t\t\n\t\t\tpar[x]=find(par[x]);\n\t\t\tdiff_weight[x] += diff_weight[old_par];\n\t\t\treturn par[x];\n\t\t}\n\t\t\n\t\tpublic Boolean same(int x,int y){\n\t\t\treturn find(x)==find(y);\n\t\t}\n\t\t\n\t\tpublic int get_diff(int x, int y){\n\t\t\treturn diff_weight[x] - diff_weight[y];\n\t\t}\n\t\t\n\t\tpublic void unite(int x,int y){\n\t\t\tif(find(x)==find(y)){\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tpar[find(x)]=find(y);\n\t\t}\n\t\t\n\t\tpublic void set_diff(int x,int y, int d){\n\t\t\tif(find(x)==find(y)){\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tdiff_weight[x] = d;\n\t\t\tpar[x]=y;\n\t\t\tpar[find(x)]=find(y);\n\t\t}\n\t}\n\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile (true) {\n\t\t\tfinal int N = sc.nextInt();\n\t\t\tfinal int M = sc.nextInt();\n\n\t\t\tif (N == 0 && M == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tWeightUnionFind wuf = new WeightUnionFind(N);\n\t\t\t\n\t\t\tfor(int i = 0; i < M; i++){\n\t\t\t\tString op = sc.next();\n\t\t\t\t\n\t\t\t\tif(op.equals(\"!\")){\n\t\t\t\t\tfinal int from = sc.nextInt() - 1;\n\t\t\t\t\tfinal int to = sc.nextInt() - 1;\n\t\t\t\t\tfinal int w = sc.nextInt();\n\t\t\t\t\t\n\t\t\t\t\twuf.set_diff(from, to, w);\n\t\t\t\t\t\n\t\t\t\t}else{\n\t\t\t\t\tfinal int from = sc.nextInt() - 1;\n\t\t\t\t\tfinal int to = sc.nextInt() - 1;\n\t\t\t\t\t\n\t\t\t\t\tif(!wuf.same(from, to)){\n\t\t\t\t\t\tSystem.out.println(\"UNKOWN\");\n\t\t\t\t\t}else{\n\t\t\t\t\t\tSystem.out.println(wuf.get_diff(from, to));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t}\n\n\t\tsc.close();\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tnew Main().solver();\n\t}\n\n\tvoid solver() {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint N = sc.nextInt();\n\t\t\tint M = sc.nextInt();\n\t\t\tif (N == 0 && M == 0)\n\t\t\t\tbreak;\n\t\t\tWeightedUnionFind uf = new WeightedUnionFind(N);\n\t\t\tfor (int i = 0; i < M; i++) {\n\t\t\t\tString s = sc.next();\n\t\t\t\tint x = sc.nextInt() - 1;\n\t\t\t\tint y = sc.nextInt() - 1;\n\t\t\t\tif (s.equals(\"!\")) {\n\t\t\t\t\tint w = sc.nextInt();\n\t\t\t\t\tuf.union(x, y, w);\n\t\t\t\t} else {\n\t\t\t\t\tif (!uf.same(x, y)) {\n\t\t\t\t\t\tSystem.out.println(\"UNKNOWN\");\n\t\t\t\t\t} else {\n\t\t\t\t\t\tSystem.out.println(-uf.diff(x, y));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsc.close();\n\t}\n\n\tclass WeightedUnionFind {\n\t\tint[] par;\n\t\tint[] wd;\n\n\t\tpublic WeightedUnionFind(int n) {\n\t\t\tpar = new int[n];\n\t\t\twd = new int[n];\n\t\t\tArrays.fill(par, -1);\n\t\t}\n\n\t\tint find(int x) {\n\t\t\tif (par[x] < 0)\n\t\t\t\treturn x;\n\t\t\telse {\n\t\t\t\tfinal int parent = find(par[x]);\n\t\t\t\twd[x] += wd[par[x]];\n\t\t\t\tpar[x] = parent;\n\t\t\t\treturn parent;\n\t\t\t}\n\t\t}\n\n\t\tboolean same(int x, int y) {\n\t\t\treturn find(x) == find(y);\n\t\t}\n\n\t\tint weight(int x) {\n\t\t\tfind(x);\n\t\t\treturn wd[x];\n\t\t}\n\n\t\t// y - x = w ??? y = x + w;\n\t\tboolean union(int x, int y, int w) {\n\t\t\tif (find(x) == find(y))\n\t\t\t\treturn false;\n\t\t\telse {\n\t\t\t\tw += (weight(x) - weight(y));\n\t\t\t\tx = find(x);\n\t\t\t\ty = find(y);\n\t\t\t\tpar[y] = x;\n\t\t\t\twd[y] = w;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\t// return x-y\n\t\tint diff(int x, int y) {\n\t\t\tif (!same(x, y)) {\n\t\t\t\tthrow new AssertionError();\n\t\t\t} else {\n\t\t\t\treturn weight(x) - weight(y);\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.Reader;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic Scanner sc = new Scanner(System.in);\n\n\tpublic static void main(String[] args) throws Exception {\n//\t\tint[] A = new int[100000];\n//\t\tint[] B = new int[100000];\n//\t\tint[] W = new int[100000];\n//\t\tboolean[] type = new boolean[100000];\n//\t\tint[] dist = new int[100000];\n//\t\tArrayList<ArrayList<Edge>> graph = new ArrayList<ArrayList<Edge>>();\n//\t\tfor (int i = 0; i < 100000; ++i) {\n//\t\t\tgraph.add(new ArrayList<Edge>());\n//\t\t}\n\t\twhile (sc.hasNextInt()) {\n\t\t\tint N = sc.nextInt();\n\t\t\tif (N == 0) break;\n\t\t\tint M = sc.nextInt();\n\t\t\tsc.nextLine();\n//\t\t\tfor (int i = 0; i < 100000; ++i) {\n//\t\t\t\tgraph.get(i).clear();\n//\t\t\t}\n\t\t\tfor (int i = 0; i < M; ++i) {\n//\t\t\t\tif (!sc.hasNextLine()) {\n//\t\t\t\t\tM = i;\n//\t\t\t\t\tbreak;\n//\t\t\t\t}\n\t\t\t\tString line = sc.nextLine();\n//\t\t\t\tString[] line = sc.nextLine().split(\" \");\n//\t\t\t\ttype[i] = line[0].charAt(0) == '!';\n//\t\t\t\tA[i] = Integer.parseInt(line[1]) - 1;\n//\t\t\t\tB[i] = Integer.parseInt(line[2]) - 1;\n//\t\t\t\tif (type[i]) {\n//\t\t\t\t\tW[i] = Integer.parseInt(line[3]);\n//\t\t\t\t\tgraph.get(A[i]).add(new Edge(B[i], W[i]));\n//\t\t\t\t\tgraph.get(B[i]).add(new Edge(A[i], -W[i]));\n//\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.gc();\n//\t\t\tArrays.fill(dist, Integer.MIN_VALUE);\n//\t\t\tfor (int i = 0; i < N; ++i) {\n//\t\t\t\tif (dist[i] != Integer.MIN_VALUE) continue;\n//\t\t\t\tArrayDeque<Integer> q = new ArrayDeque<Integer>();\n//\t\t\t\tq.add(i);\n//\t\t\t\tdist[i] = 0;\n//\t\t\t\twhile (!q.isEmpty()) {\n//\t\t\t\t\tint cur = q.poll();\n//\t\t\t\t\tfor (Edge e : graph.get(cur)) {\n//\t\t\t\t\t\tint next = e.to;\n//\t\t\t\t\t\tif (dist[next] != Integer.MIN_VALUE) continue;\n//\t\t\t\t\t\tdist[next] = dist[cur] + e.w;\n//\t\t\t\t\t\tq.add(next);\n//\t\t\t\t\t}\n//\t\t\t\t}\n//\t\t\t}\n//\n//\t\t\tUnionFind uf = new UnionFind(100000);\n//\t\t\tfor (int i = 0; i < M; ++i) {\n//\t\t\t\tif (type[i]) {\n//\t\t\t\t\tuf.union(A[i], B[i]);\n//\t\t\t\t} else {\n//\t\t\t\t\tif (!uf.find(A[i], B[i])) {\n//\t\t\t\t\t\tSystem.out.println(\"UNKNOWN\");\n//\t\t\t\t\t} else {\n//\t\t\t\t\t\tSystem.out.println(dist[B[i]] - dist[A[i]]);\n//\t\t\t\t\t}\n//\t\t\t\t}\n//\t\t\t}\n\t\t}\n\t}\n\n\tstatic class Edge {\n\t\tint to, w;\n\n\t\tEdge(int to, int w) {\n\t\t\tthis.to = to;\n\t\t\tthis.w = w;\n\t\t}\n\t}\n\n\tstatic class UnionFind {\n\t\tint[] set;\n\n\t\tUnionFind(int n) {\n\t\t\tset = new int[n];\n\t\t\tArrays.fill(set, -1);\n\t\t}\n\n\t\tvoid union(int a, int b) {\n\t\t\tint rtA = root(a);\n\t\t\tint rtb = root(b);\n\t\t\tif (rtA == rtb) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tset[rtA] += set[rtb];\n\t\t\tset[rtb] = rtA;\n\t\t}\n\n\t\tboolean find(int a, int b) {\n\t\t\treturn root(a) == root(b);\n\t\t}\n\n\t\tint root(int a) {\n\t\t\tif (set[a] < 0) {\n\t\t\t\treturn a;\n\t\t\t} else {\n\t\t\t\tset[a] = root(set[a]);\n\t\t\t\treturn set[a];\n\t\t\t}\n\t\t}\n\n\t\tint size(int a) {\n\t\t\treturn -set[root(a)];\n\t\t}\n\t}\n\n\tstatic class FastScanner {\n\t\tReader input;\n\n\t\tFastScanner() {\n\t\t\tthis(System.in);\n\t\t}\n\n\t\tFastScanner(InputStream stream) {\n\t\t\tthis.input = new BufferedReader(new InputStreamReader(stream));\n\t\t}\n\n\t\tint nextInt() throws IOException {\n\t\t\tint sign = 1;\n\t\t\tint b = input.read();\n\t\t\twhile ((b < '0' || '9' < b) && b != '-' && b != '+') {\n\t\t\t\tif (b == -1) return 0;\n\t\t\t\tb = input.read();\n\t\t\t}\n\t\t\tif (b == '-') {\n\t\t\t\tsign = -1;\n\t\t\t\tb = input.read();\n\t\t\t} else if (b == '+') {\n\t\t\t\tb = input.read();\n\t\t\t}\n\t\t\tint ret = b - '0';\n\t\t\twhile (true) {\n\t\t\t\tb = input.read();\n\t\t\t\tif (b < '0' || '9' < b) return ret * sign;\n\t\t\t\tret *= 10;\n\t\t\t\tret += b - '0';\n\t\t\t}\n\t\t}\n\n\t\tchar nextChar() throws IOException {\n\t\t\tint b = input.read();\n\t\t\twhile (Character.isWhitespace((char) b)) {\n\t\t\t\tb = input.read();\n\t\t\t}\n\t\t\treturn (char) b;\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\t//@start\n\tpublic static class WeightedUnionFind{\n\t    int[] par; // 親の番号\n\t    int[] ws;  // 親との重みの差\n\t    \n\t    public WeightedUnionFind(int n){\n\t        par = new int[n];\n\t        ws  = new int[n];\n\t        for(int i = 0; i < n; i++){ \n\t        \tpar[i] = -1;\n\t        }\n\t    }\n\t    \n\t    public int find(int x){\n\t    \tif(par[x] < 0){\n\t    \t\treturn x;\n\t    \t}else{\n\t    \t\tfinal int parent = find(par[x]);\n\t    \t\tws[x] += ws[par[x]];\n\t    \t\tpar[x] = parent;\n\t    \t\treturn parent;\n\t    \t}\n\t    }\n\t    \n\t    public int weight(int x){\n\t    \tfind(x);\n\t    \treturn ws[x];\n\t    }\n\t    \n\t    public boolean union(int x, int y, int w){ // x <-(w)- y (x + w = y)\n\t    \tw += weight(x);\n\t    \tw -= weight(y);\n\t        x = find(x);\n\t        y = find(y);\n\t        \n\t        if(x != y){\n\t            if(par[y] < par[x]) {  // 多い方が根になるようにスワップする.\n\t                int tmp = x; x = y; y = tmp;\n\t                w = -w;\n\t            }\n\t            par[x] += par[y];\n\t            par[y] = x;\n\t            ws[y] = w;\n\t            \n\t            return true;\n\t        }else{\n\t            return false;\n\t        }\n\t    }\n\t    \n\t    public boolean same(int x, int y){\n\t        return find(x) == find(y);\n\t    }\n\t    \n\t    public Integer diff(int x, int y){ // x - y を求める. 比較不能ならnull.\n\t    \tif(!same(x, y)){\n\t    \t\treturn null;\n\t    \t}else{\n\t    \t\treturn this.weight(x) - this.weight(y);\n\t    \t}\n\t    }\n\t    \n\t\tpublic int size(int x){\n\t\t\treturn -par[find(x)];\n\t\t}\n\t}\n\t//@end\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile(true){\n\t\t\tfinal int n = sc.nextInt();\n\t\t\tfinal int m = sc.nextInt();\n\t\t\t\n\t\t\tif(n == 0 && m == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tWeightedUnionFind uf = new WeightedUnionFind(n);\n\t\t\t\n\t\t\tfor(int i = 0; i < m; i++){\n\t\t\t\tfinal String ops = sc.next();\n\t\t\t\t\n\t\t\t\tif(\"?\".equals(ops)){\n\t\t\t\t\tfinal int r = sc.nextInt() - 1;\n\t\t\t\t\tfinal int l = sc.nextInt() - 1;\n\t\t\t\t\t\n\t\t\t\t\tif(!uf.same(r, l)){\n\t\t\t\t\t\tSystem.out.println(\"UNKNOWN\");\n\t\t\t\t\t}else{\n\t\t\t\t\t\tSystem.out.println(uf.weight(l) - uf.weight(r));\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tfinal int r = sc.nextInt() - 1;\n\t\t\t\t\tfinal int l = sc.nextInt() - 1;\n\t\t\t\t\tfinal int w = sc.nextInt();\n\t\t\t\t\t\n\t\t\t\t\tuf.union(r, l, w);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tsc.close();\n\t}\n\t\n\tpublic static class Scanner {\n\t    private BufferedReader br;\n\t    private StringTokenizer tok;\n\n\t    public Scanner(InputStream is) throws IOException {\n\t        br = new BufferedReader(new InputStreamReader(is));\n\t    }\n\n\t    private void getLine() throws IOException {\n\t        while (!hasNext()) { tok = new StringTokenizer(br.readLine()); }\n\t    }\n\n\t    private boolean hasNext() {\n\t        return tok != null && tok.hasMoreTokens();\n\t    }\n\n\t    public String next() throws IOException {\n\t        getLine(); return tok.nextToken();\n\t    }\n\n\t    public int nextInt() throws IOException {\n\t        return Integer.parseInt(next());\n\t    }\n\t    // 他のnextXXXもXXX.parseXXX()メソッドを使って作れるので省略\n\t    \n\t    public void close() throws IOException {\n\t        br.close();\n\t    }\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n \npublic class Main {\n    public static int N;\n    public static int M;\n    public static int[] p;\n    public static int[] rank;\n    public static int[] weight;\n\n    public static boolean same(int x, int y) {\n        return findSet(x) == findSet(y);\n    }\n \n    public static void unite(int x, int y, int w) {\n        int i = findSet(x);\n        int j = findSet(y);\n        w -= weight[y] - weight[x];\n\n        if (i == j){\n\t    return;\n\t}\n        if (rank[i] > rank[j]){\n            p[j] = p[i];\n            weight[j] = w;\n        } else {\n            p[i] = p[j];\n            weight[i] = -w;\n            if(rank[i] == rank[j]){\n\t\trank[j]++;\n            }\n        }\t\n    }\n \n    public static int findSet(int i) {\n\tif(p[i] == i){ \n\t    return i;\n        }else{\n\t    return p[i] = findSet(p[i]);\n        }\n    }\n \n    public static void DisjointSet() {\n        p = new int[N];\n        rank = new int[N];\n        weight = new int[N];\n \n        for (int i = 0; i < N; i++) {\n            p[i] = i;\n            rank[i] = 0;\n            weight[i] = 0;\n        }\n    }\n \n \n    public static void main (String[] args){\n        Scanner scanner = new Scanner(System.in);\n        while(true){\n\t    N = scanner.nextInt();\n\t    M = scanner.nextInt();\n\n\t    if(N==0 |M==0){\n\t\tbreak;\n\t    }\n \n\t    DisjointSet();\n\n\t    for (int i = 0; i < M; i++) {\n\t\tString c = scanner.next();\n\t\tint a = scanner.nextInt();\n\t\tint b = scanner.nextInt();\n\t\ta--; b--; \n\t\t\n\t\tif(c.equals(\"!\")){\n\t\t    int w = scanner.nextInt();\n\t\t    unite(a, b, w);\n\t\t}else{ \n\t\t    if(same(a,b)){\n\t\t\tSystem.out.println(weight[b] - weight[a]);\n\t\t    }else{\n\t\t\tSystem.out.println(\"UNKNOWN\");\n\t\t    }\n\t\t}\n\t    }\n\t}\n      \n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main{\n\tpublic static void main(String[] args) {\n\t\tnew Main().solver();\n\t}\n\n\tvoid solver() {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint N = sc.nextInt();\n\t\t\tint M = sc.nextInt();\n\t\t\tif (N == 0 && M == 0)\n\t\t\t\tbreak;\n\t\t\tWeightedUnionFind uf = new WeightedUnionFind(N);\n\t\t\tfor (int i = 0; i < M; i++) {\n\t\t\t\tString s = sc.next();\n\t\t\t\tint x = sc.nextInt() - 1;\n\t\t\t\tint y = sc.nextInt() - 1;\n\t\t\t\tif (s.equals(\"!\")) {\n\t\t\t\t\tint w = sc.nextInt();\n\t\t\t\t\tuf.union(x, y, w);\n\t\t\t\t} else {\n\t\t\t\t\tif (!uf.same(x, y)) {\n\t\t\t\t\t\tSystem.out.println(\"UNKNOWN\");\n\t\t\t\t\t} else {\n\t\t\t\t\t\tSystem.out.println(-uf.diff(x, y));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsc.close();\n\t}\n\n\tclass WeightedUnionFind {\n\t\tint[] par;\n\t\tint[] wd;\n\n\t\tpublic WeightedUnionFind(int n) {\n\t\t\tpar = new int[n];\n\t\t\twd = new int[n];\n\t\t\tArrays.fill(par, -1);\n\t\t}\n\n\t\tint find(int x) {\n\t\t\tif (par[x] < 0)\n\t\t\t\treturn x;\n\t\t\telse {\n\t\t\t\tfinal int parent = find(par[x]);\n\t\t\t\twd[x] += wd[par[x]];\n\t\t\t\tpar[x] = parent;\n\t\t\t\treturn parent;\n\t\t\t}\n\t\t}\n\n\t\tboolean same(int x, int y) {\n\t\t\treturn find(x) == find(y);\n\t\t}\n\n\t\tint weight(int x) {\n\t\t\tfind(x);\n\t\t\treturn wd[x];\n\t\t}\n\n\t\t// y - x = w ??? y = x + w;\n\t\tboolean union(int x, int y, int w) {\n\t\t\tif (find(x) == find(y))\n\t\t\t\treturn false;\n\t\t\telse {\n\t\t\t\tw += (weight(x) - weight(y));\n\t\t\t\tx = find(x);\n\t\t\t\ty = find(y);\n\t\t\t\tif (par[y] < par[x]) { // ???????????????????????????????????????????????????.\n\t\t\t\t\tint tmp = x;\n\t\t\t\t\tx = y;\n\t\t\t\t\ty = tmp;\n\t\t\t\t\tw = -w;\n\t\t\t\t}\n\t\t\t\tpar[y] = x;\n\t\t\t\twd[y] = w;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\t// return x-y\n\t\tint diff(int x, int y) {\n//\t\t\tif (!same(x, y)) {\n//\t\t\t\tthrow new AssertionError();\n//\t\t\t} else {\n\t\t\t\treturn weight(x) - weight(y);\n//\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "public class Main {\n\tMyScanner sc = new MyScanner();\n\tint N, M, a, b, w;\n\tint[] parent;\n\tNode[] node;\n\n\tvoid run() {\n\t\tfor (;;) {\n\t\t\tN = sc.nextInt(); // 荷物数\n\t\t\tM = sc.nextInt(); // クエリ数\n\t\t\tif ((N | M) == 0) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tparent = new int[N + 1];\n\t\t\tnode = new Node[N + 1];\n\t\t\tinit();\n\n\t\t\tfor (int i = 0; i < M; i++) {\n\t\t\t\tString query = sc.next();\n\t\t\t\ta = sc.nextInt();\n\t\t\t\tb = sc.nextInt();\n\t\t\t\tif (query.equals(\"!\")) {\n\t\t\t\t\tw = sc.nextInt();\n\t\t\t\t\tunion(a, b, w);\n\t\t\t\t} else if (query.equals(\"?\")) {\n\t\t\t\t\tSystem.out.println(same(a, b) ? node[b].weight\n\t\t\t\t\t\t\t- node[a].weight : \"UNKNOWN\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid init() {\n\t\tfor (int i = 0; i <= N; i++) {\n\t\t\tparent[i] = i;\n\t\t\tnode[i] = new Node(0, 0);\n\t\t}\n\t}\n\n\tvoid union(int x, int y, int w) {\n\t\tint rootX = find(x);\n\t\tint rootY = find(y);\n\t\tif (rootX == rootY) {\n\t\t\treturn;\n\t\t}\n\t\tif (node[rootX].rank < node[rootY].rank) {\n\t\t\tnode[rootX].weight = -w - node[x].weight + node[y].weight;\n\t\t\tparent[rootX] = rootY;\n\t\t} else {\n\t\t\tnode[rootY].weight = w - node[y].weight + node[x].weight;\n\t\t\tparent[rootY] = rootX;\n\n\t\t\tif (node[rootX].rank == node[rootY].rank) {\n\t\t\t\tnode[rootX].rank++;\n\t\t\t}\n\t\t}\n\t}\n\n\tint find(int target) {\n\t\tif (parent[target] == target) {\n\t\t\treturn target;\n\t\t} else {\n\t\t\tint tmp = find(parent[target]);\n\t\t\tnode[target].weight += node[parent[target]].weight;\n\t\t\treturn parent[target] = tmp;\n\t\t}\n\t}\n\n\tboolean same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\n\tclass Node {\n\t\tint weight;\n\t\tint rank;\n\n\t\t/**\n\t\t * @param weight\n\t\t * @param rank\n\t\t */\n\t\tpublic Node(int weight, int rank) {\n\t\t\tsuper();\n\t\t\tthis.weight = weight;\n\t\t\tthis.rank = rank;\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tclass MyScanner {\n\t\tint nextInt() {\n\t\t\ttry {\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (c != '-' && (c < '0' || '9' < c))\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tif (c == '-')\n\t\t\t\t\treturn -nextInt();\n\t\t\t\tint res = 0;\n\t\t\t\tdo {\n\t\t\t\t\tres *= 10;\n\t\t\t\t\tres += c - '0';\n\t\t\t\t\tc = System.in.read();\n\t\t\t\t} while ('0' <= c && c <= '9');\n\t\t\t\treturn res;\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\n\t\tString next() {\n\t\t\ttry {\n\t\t\t\tStringBuilder res = new StringBuilder(\"\");\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (Character.isWhitespace(c))\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tdo {\n\t\t\t\t\tres.append((char) c);\n\t\t\t\t} while (!Character.isWhitespace(c = System.in.read()));\n\t\t\t\treturn res.toString();\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n \npublic class Main {\n    public static int N;\n    public static int M;\n    public static int[] p;\n    public static int[] rank;\n    public static int[] w;\n \n    public static boolean same(int x, int y) {\n        return findSet(x) == findSet(y);\n    }\n \n    public static void unite(int a, int b, int w) {\n        int i = findSet(a);\n        int j = findSet(b);\n\tw -= w[b] - w[a];\n\t\n        if (i == j){\n\t    return;\n\t}\n        if (rank[i] > rank[j]){\n            p[j] = p[i];\n\t    w[j] = w;\n        } else {\n            p[i] = p[j];\n\t    w[x] = -w;\n            if(rank[i] == rank[j]){\n            rank[j]++;\n            }\n        }\t\n    }\n \n    public static int findSet(int i) {\n       if(p[i] == i){ \n           return i;\n        }else{\n          return p[i] = findSet(p[i]);\n        }\n    }\n \n    public static void DisjointSet() {\n        p = new int[N];\n        rank = new int[N];\n\tw = new int[N]\n \n        for (int i = 0; i < N; i++) {\n            p[i] = i;\n            rank[i] = 0;\n\t    w[i] = 0;\n        }\n    }\n \n \n    public static void main (String[] args){\n        Scanner scanner = new Scanner(System.in);\n\twhile(true){   \n        N = scanner.nextInt();\n        M = scanner.nextInt();\n\tif(N==0 & M == 0) break;\n\n        DisjointSet();\n\tSolve();\n\t}\n    }\n    \n    public static Solve(){\n        for (int i = 0; i < M; i++) {\n\t    if(scanner.next().equals(\"!\")){\n\t\tint a = scanner.nextInt();\n\t\tint b = scanner.nextInt();\n\t\tint w = scanner.nextInt();\n\t\t\n\t\ta--;\n\t\tb--;\n\t\tunite(a, b, w);\n\t    }else{\n\t        if(!same(a,b)){\n\t\t    System.out.println(\"UNKNOWN\");\n\t\t}else{\n\t\t    System.out.println(w[b]-w[a]);\n\t\t}\n\t    }\n\t}\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tnew Main().solver();\n\t}\n\n\tvoid solver() {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile (sc.hasNext()) {\n\t\t\tint N = sc.nextInt();\n\t\t\tint M = sc.nextInt();\n\t\t\tif (N == 0 && M == 0)\n\t\t\t\tbreak;\n\t\t\tWeightedUnionFind uf = new WeightedUnionFind(N);\n\t\t\tfor (int i = 0; i < M; i++) {\n\t\t\t\tString s = sc.next();\n\t\t\t\tint x = sc.nextInt() - 1;\n\t\t\t\tint y = sc.nextInt() - 1;\n\t\t\t\tif (s.equals(\"!\")) {\n\t\t\t\t\tint w = sc.nextInt();\n\t\t\t\t\tuf.union(x, y, w);\n\t\t\t\t} else {\n\t\t\t\t\tif (!uf.same(x, y)) {\n\t\t\t\t\t\tSystem.out.println(\"UNKNOWN\");\n\t\t\t\t\t} else {\n\t\t\t\t\t\tSystem.out.println(-uf.diff(x, y));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsc.close();\n\t}\n\n\tclass WeightedUnionFind {\n\t\tint[] par;\n\t\tint[] wd;\n\n\t\tpublic WeightedUnionFind(int n) {\n\t\t\tpar = new int[n];\n\t\t\twd = new int[n];\n\t\t\tArrays.fill(par, -1);\n\t\t}\n\n\t\tint find(int x) {\n\t\t\tif (par[x] < 0)\n\t\t\t\treturn x;\n\t\t\telse {\n\t\t\t\tfinal int parent = find(par[x]);\n\t\t\t\twd[x] += wd[par[x]];\n\t\t\t\tpar[x] = parent;\n\t\t\t\treturn parent;\n\t\t\t}\n\t\t}\n\n\t\tboolean same(int x, int y) {\n\t\t\treturn find(x) == find(y);\n\t\t}\n\n\t\tint weight(int x) {\n\t\t\tfind(x);\n\t\t\treturn wd[x];\n\t\t}\n\n\t\t// y - x = w ??? y = x + w;\n\t\tboolean union(int x, int y, int w) {\n\t\t\tif (find(x) == find(y))\n\t\t\t\treturn false;\n\t\t\telse {\n\t\t\t\tw += (weight(x) - weight(y));\n\t\t\t\tx = find(x);\n\t\t\t\ty = find(y);\n\t\t\t\tpar[y] = x;\n\t\t\t\twd[y]=w;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\t// return x-y\n\t\tint diff(int x, int y) {\n\t\t\tif (!same(x, y)) {\n\t\t\t\tthrow new AssertionError();\n\t\t\t} else {\n\t\t\t\treturn weight(x) - weight(y);\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n \npublic class Main {\n    public static int N;\n    public static int M;\n    public static int[] p;\n    public static int[] rank;\n    public static int[] weight;\n\n    public static boolean same(int x, int y) {\n        return findSet(x) == findSet(y);\n    }\n \n    public static void unite(int x, int y, int w) {\n        int i = findSet(x);\n        int j = findSet(y);\n        w -= weight[j] - weight[i];\n\n        if (i == j){\n\t    return;\n\t}\n        if (rank[i] > rank[j]){\n            p[j] = p[i];\n            weight[j] = w;\n        } else {\n            p[i] = p[j];\n            weight[i] = -w;\n            if(rank[i] == rank[j]){\n            rank[j]++;\n            }\n        }\t\n    }\n \n    public static int findSet(int i) {\n       if(p[i] == i){ \n           return i;\n        }else{\n          return p[i] = findSet(p[i]);\n        }\n    }\n \n    public static void DisjointSet() {\n        p = new int[N];\n        rank = new int[N];\n        weight = new int[N];\n \n        for (int i = 0; i < N; i++) {\n            p[i] = i;\n            rank[i] = 0;\n            weight[i] = 0;\n        }\n    }\n \n \n    public static void main (String[] args){\n        Scanner scanner = new Scanner(System.in);\n        while(true){\n        N = scanner.nextInt();\n        M = scanner.nextInt();\n\n        if(N==0 |M==0){\n           break;\n        }\n \n        DisjointSet();\n\n        for (int i = 0; i < M; i++) {\n            if(scanner.next().equals(\"!\")){\n            int a = scanner.nextInt();\n            int b = scanner.nextInt();\n            int w = scanner.nextInt();\n \n            a--; b--;   \n            unite(a, b, w);\n            }else if(same(a,b)){\n              System.out.println(weight[b] - weight[a]);\n            }else{\n              System.out.println(\"UNKNOWN\");\n\t    }\n           }\n        \n       }\n      \n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n  \npublic class Main {\n    public static int N;\n    public static int M;\n    public static int[] p;\n    public static int[] rank;\n    public static int[] weight;\n \n    public static boolean same(int x, int y) {\n        return findSet(x) == findSet(y);\n    }\n  \n    public static void unite(int x, int y, int w) {\n        int i = findSet(x);\n        int j = findSet(y);\n        w -= (weight[y] - weight[x]);\n \n        if (i == j){\n        return;\n    }\n        if (rank[i] > rank[j]){\n            p[j] = i;\n            weight[j] = w;\n        } else {\n            p[i] = j;\n            weight[i] = -w;\n            if(rank[i] == rank[j]){\n        rank[j]++;\n            }\n        }   \n    }\n  \n    public static int findSet(int i) {\n    if(p[i] == i){ \n        return i;\n        }else{\n        return p[i] = findSet(p[i]);\n        }\n    }\n  \n    public static void DisjointSet() {\n        p = new int[N];\n        rank = new int[N];\n        weight = new int[N];\n  \n        for (int i = 0; i < N; i++) {\n            p[i] = i;\n            rank[i] = 0;\n            weight[i] = 0;\n        }\n    }\n  \n  \n    public static void main (String[] args){\n        Scanner scanner = new Scanner(System.in);\n        while(true){\n        N = scanner.nextInt();\n        M = scanner.nextInt();\n \n        if(N==0 |M==0){\n        break;\n        }\n  \n        DisjointSet();\n \n        for (int i = 0; i < M; i++) {\n        String c = scanner.next();\n        int a = scanner.nextInt();\n        int b = scanner.nextInt();\n        a--; b--; \n         \n        if(c.equals(\"!\")){\n            int w = scanner.nextInt();\n            unite(a, b, w);\n        }else{ \n            if(same(a,b)){\n            System.out.println(weight[b] - weight[a]);\n            }else{\n            System.out.println(\"UNKNOWN\");\n            }\n        }\n        }\n    }\n       \n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\n@SuppressWarnings(\"unchecked\")\n    class Main{\n        \n        int n, m;\n        int INF = Integer.MAX_VALUE/2;\n        HashSet[] list;\n        long mod = 10000000;        \n\n        void solve(){\n            Scanner sc = new Scanner(System.in);\n            while(true){\n                n = sc.nextInt(); m = sc.nextInt();\n                if(n==0 && m==0) break;\n \n                list = new HashSet[n+1];\n                for(int i=0; i<=n; i++) list[i] = new HashSet<Long>();\n                for(int i=0; i<m; i++){\n                    char command = sc.next().charAt(0);\n                    if(command=='!'){\n                        long a = sc.nextLong(), b = sc.nextLong(), w = sc.nextLong();\n                        list[(int)a].add(b * mod + w);\n                        list[(int)b].add(-(a * mod + w));\n                    }else{\n                        int b = dijkstra(sc.nextInt(), sc.nextInt());\n                        if(b==INF) System.out.println(\"UNKNOWN\");\n                        else System.out.println(b);\n                    }\n                }\n            }\n        }\n        \n        int dijkstra(int start, int goal){\n            //pos, cost\n            LinkedList<int[]> q = new LinkedList<int[]>();\n            q.add(new int[]{start, 0});\n            boolean[] v = new boolean[n+1];\n \n            while(q.size()>0){\n                int[] qq = q.poll();\n                int pos = qq[0], cost = qq[1];\n \n                if(pos==goal) return cost;\n                if(v[pos]) continue;\n                v[pos] = true;\n\n                for(Iterator i=list[pos].iterator(); i.hasNext();){\n                    //P p = (P)i.next();\n                    long X = (long)(Long)i.next();\n                    int to = 0, weight = 0;\n                    if(X<0){\n                        X = -X;\n                        to = (int)(X / mod); weight = (int)-(X % mod);\n                    }else{\n                        to = (int)(X / mod); weight = (int)(X % mod);\n                    }\n                    q.add(new int[]{to, cost+weight});\n                }\n                /*\n                for(int i=0; i<list[pos].size(); i++){\n                    P p = (P)list[pos].get(i);\n                    q.add(new int[]{p.to, cost+p.weight});\n                }\n                */\n            }\n            return INF;\n        }\n \n        public static void main(String[] args){\n            new Main().solve();\n        }\n    }"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.Map.Entry;\nimport java.util.Set;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tIO io = new IO();\n\t\twhile(true) {\n\t\t\tint n = io.nextInt();\n\t\t\tint m = io.nextInt();\n\t\t\tif (n == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tUnionFind p = new UnionFind(n);\n\t\t\tfor(int i=0;i<m;i++) {\n\t\t\t\tchar c = io.next().charAt(0);\n\t\t\t\tif (c == '!') {\n\t\t\t\t\tint a = io.nextInt()-1;\n\t\t\t\t\tint b = io.nextInt()-1;\n\t\t\t\t\tint w = io.nextInt();\n\t\t\t\t\tp.union(a, b, w);\n\t\t\t\t}else{\n\t\t\t\t\tint a = io.nextInt()-1;\n\t\t\t\t\tint b = io.nextInt()-1;\n\t\t\t\t\tif (!p.isConnected(a, b)) {\n\t\t\t\t\t\tio.println(\"UNKNOWN\");\n\t\t\t\t\t}else{\n\t\t\t\t\t\tint root = p.root(a);\n\t\t\t\t\t\tlong diff = p.data[root].get(b) - p.data[root].get(a);\n\t\t\t\t\t\tio.println(diff);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tio.flush();\n\t}\n\n}\n\nclass UnionFind {\n\tint[] root;\n\tHashMap<Integer,Long>[] data;\n\n\t@SuppressWarnings(\"unchecked\")\n\tpublic UnionFind(int size) {\n\t\troot = new int[size];\n\t\tArrays.fill(root, -1);\n\t\tdata = new HashMap[size];\n\t\tfor(int i=0;i<size;i++) {\n\t\t\tdata[i] = new HashMap<Integer, Long>();\n\t\t\tdata[i].put(i, 0L);\n\t\t}\n\t}\n\tpublic void union(int a_,int b_,int w) {\n\t\tint a = root(a_);\n\t\tint b = root(b_);\n\t\tif (a!=b) {\n\t\t\tif (root[b] < root[a]) {\n\t\t\t\tint tmp = b;\n\t\t\t\tb = a;\n\t\t\t\ta = tmp;\n\t\t\t\tw *= -1;\n\t\t\t\ttmp = b_;\n\t\t\t\tb_ = a_;\n\t\t\t\ta_ = tmp;\n\t\t\t}\n\t\t\troot[a] += root[b];\n\t\t\troot[b] = a;\n\t\t\tlong w2 = w + data[a].get(a_);\n\t\t\tSet<Entry<Integer, Long>> entrySet = data[b].entrySet();\n\t\t\tfor(Entry<Integer, Long> entry: entrySet) {\n\t\t\t\tdata[a].put(entry.getKey(), entry.getValue() + w2);\n\t\t\t}\n\t\t\tdata[b] = null;\n//\t\t\tSystem.out.println(\"----\");\n//\t\t\tfor(int i=0;i<data.length;i++) {\n//\t\t\t\tSystem.out.println(data[i]);\n//\t\t\t}\n\t\t}\n\t}\n\tpublic boolean isConnected(int x,int y) {\n\t\treturn root(x)==root(y);\n\t}\n\tpublic int root(int x) {\n\t\treturn root[x] < 0 ? x : (root[x] = root(root[x]));\n\t}\n\tpublic int size(int x) {\n\t\treturn -root[root(x)];\n\t}\n\tpublic String toString() {\n\t\treturn Arrays.toString(root);\n\t}\n}\n\nclass IO {\n\tBufferedReader bi = new BufferedReader(new InputStreamReader(System.in));\n\tStringBuilder out = new StringBuilder();\n\tint index = 0;\n\tString bfl = null;\n\tString[] bf = new String[0];\n\tprivate boolean read() {\n\t\ttry {\n\t\t\tbfl = bi.readLine();\n\t\t\tif (bfl == null) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tbf = bfl.split(\"\\\\s\");\n\t\t\tindex = 0;\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\treturn true;\n\t}\n\tpublic boolean hasNext() { return index < bf.length ? true : read(); }\n\tpublic boolean hasNextLine() { return read(); }\n\tpublic String next() { return hasNext() ? bf[index++] : null; }\n\tpublic String nextLine() { return hasNextLine() ? bfl : null; }\n\tpublic int nextInt() { return Integer.parseInt(next()); }\n\tpublic long nextLong() { return Long.parseLong(next()); }\n\tpublic double nextDouble() { return Double.parseDouble(next()); };\n\tpublic void println(long x) { out.append(x); out.append(\"\\n\"); }\n\tpublic void println(double x) { out.append(x); out.append(\"\\n\"); }\n\tpublic void println(String s) { out.append(s); out.append(\"\\n\"); }\n\tpublic void print(long x) { out.append(x); }\n\tpublic void print(double x) { out.append(x); }\n\tpublic void print(String s) { out.append(s); }\n\tpublic void flush() {System.out.print(out); out = new StringBuilder(); }\n\tpublic int[] arrayInt(int n) {\n\t\tint[] a = new int[n];\n\t\tfor(int i=0;i<n;i++) {\n\t\t\ta[i] = nextInt();\n\t\t}\n\t\treturn a;\n\t}\n\tpublic long[] arrayLong(int n) {\n\t\tlong[] a = new long[n];\n\t\tfor(int i=0;i<n;i++) {\n\t\t\ta[i] = nextLong();\n\t\t}\n\t\treturn a;\n\t}\n\tpublic double[] arrayDouble(int n) {\n\t\tdouble[] a = new double[n];\n\t\tfor(int i=0;i<n;i++) {\n\t\t\ta[i] = nextDouble();\n\t\t}\n\t\treturn a;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\n\tvoid solver()\n\t{\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint N = sc.nextInt();\n\t\t\tint M = sc.nextInt();\n\t\t\tif (N == 0 && M == 0)\n\t\t\t\tbreak;\n\t\t\tWeightedUnionFind uf = new WeightedUnionFind(N);\n\t\t\tfor (int i = 0; i < M; i++) {\n\t\t\t\tString s = sc.next();\n\t\t\t\tint x = sc.nextInt() - 1;\n\t\t\t\tint y = sc.nextInt() - 1;\n\t\t\t\tif (s.equals(\"!\")) {\n\t\t\t\t\tlong w = sc.nextLong();\n\t\t\t\t\tuf.union(x, y, w);\n\t\t\t\t} else {\n\t\t\t\t\tif (!uf.same(x, y)) {\n\t\t\t\t\t\tSystem.out.println(\"UNKNOWN\");\n\t\t\t\t\t} else {\n\t\t\t\t\t\tSystem.out.println(-uf.diff(x, y));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsc.close();\n\t}\n\n\tpublic static void main(String[] args) throws Exception\n\t{\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\n\t\tnew Main().solver();\n\t\tout.flush();\n\t}\n\n\tstatic long nl()\n\t{\n\t\ttry {\n\t\t\tlong num = 0;\n\t\t\tboolean minus = false;\n\t\t\twhile((num = is.read()) != -1 && !((num >= '0' && num <= '9') || num == '-'));\n\t\t\tif(num == '-'){\n\t\t\t\tnum = 0;\n\t\t\t\tminus = true;\n\t\t\t}else{\n\t\t\t\tnum -= '0';\n\t\t\t}\n\n\t\t\twhile(true){\n\t\t\t\tint b = is.read();\n\t\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t\t}else{\n\t\t\t\t\treturn minus ? -num : num;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn -1;\n\t}\n\n\tstatic char nc()\n\t{\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tif(b == -1)return 0;\n\t\t\treturn (char)b;\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn 0;\n\t}\n\n\tstatic double nd()\n\t{\n\t\ttry {\n\t\t\treturn Double.parseDouble(ns());\n\t\t}catch(Exception e) {\n\t\t}\n\t\treturn 0;\n\t}\n\n\tstatic String ns()\n\t{\n\t\ttry{\n\t\t\tint b = skip();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tif(b == -1)return \"\";\n\t\t\tsb.append((char)b);\n\t\t\twhile(true){\n\t\t\t\tb = is.read();\n\t\t\t\tif(b == -1)return sb.toString();\n\t\t\t\tif(b <= ' ')return sb.toString();\n\t\t\t\tsb.append((char)b);\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn \"\";\n\t}\n\n\tpublic static char[] ns(int n)\n\t{\n\t\tchar[] buf = new char[n];\n\t\ttry{\n\t\t\tint b = skip(), p = 0;\n\t\t\tif(b == -1)return null;\n\t\t\tbuf[p++] = (char)b;\n\t\t\twhile(p < n){\n\t\t\t\tb = is.read();\n\t\t\t\tif(b == -1 || b <= ' ')break;\n\t\t\t\tbuf[p++] = (char)b;\n\t\t\t}\n\t\t\treturn Arrays.copyOf(buf, p);\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn null;\n\t}\n\n\tpublic static byte[] nse(int n)\n\t{\n\t\tbyte[] buf = new byte[n];\n\t\ttry{\n\t\t\tint b = skip();\n\t\t\tif(b == -1)return null;\n\t\t\tis.read(buf);\n\t\t\treturn buf;\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn null;\n\t}\n\n\tstatic int skip() throws IOException\n\t{\n\t\tint b;\n\t\twhile((b = is.read()) != -1 && !(b >= 33 && b <= 126));\n\t\treturn b;\n\t}\n\n\tstatic boolean eof()\n\t{\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\tint b = skip();\n\t\t\tis.reset();\n\t\t\treturn b == -1;\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tstatic int ni()\n\t{\n\t\ttry {\n\t\t\tint num = 0;\n\t\t\tboolean minus = false;\n\t\t\twhile((num = is.read()) != -1 && !((num >= '0' && num <= '9') || num == '-'));\n\t\t\tif(num == '-'){\n\t\t\t\tnum = 0;\n\t\t\t\tminus = true;\n\t\t\t}else{\n\t\t\t\tnum -= '0';\n\t\t\t}\n\n\t\t\twhile(true){\n\t\t\t\tint b = is.read();\n\t\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t\t}else{\n\t\t\t\t\treturn minus ? -num : num;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn -1;\n\t}\n\n\tclass WeightedUnionFind {\n\t\tint[] par;\n\t\tlong[] wd;\n\n\t\tpublic WeightedUnionFind(int n) {\n\t\t\tpar = new int[n];\n\t\t\twd = new long[n];\n\t\t\tArrays.fill(par, -1);\n\t\t}\n\n\t\tint find(int x) {\n\t\t\tif (par[x] < 0)\n\t\t\t\treturn x;\n\t\t\telse {\n\t\t\t\tfinal int parent = find(par[x]);\n\t\t\t\twd[x] += wd[par[x]];\n\t\t\t\tpar[x] = parent;\n\t\t\t\treturn parent;\n\t\t\t}\n\t\t}\n\n\t\tboolean same(int x, int y) {\n\t\t\treturn find(x) == find(y);\n\t\t}\n\n\t\tlong weight(int x) {\n\t\t\tfind(x);\n\t\t\treturn wd[x];\n\t\t}\n\n\t\t// y - x = w ??? y = x + w;\n\t\tboolean union(int x, int y, long w) {\n\t\t\tif (find(x) == find(y))\n\t\t\t\treturn false;\n\t\t\telse {\n\t\t\t\tw += (weight(x) - weight(y));\n\t\t\t\tx = find(x);\n\t\t\t\ty = find(y);\n\t\t\t\tif (par[y] < par[x]) { // ???????????????????????????????????????????????????.\n\t\t\t\t\tint tmp = x;\n\t\t\t\t\tx = y;\n\t\t\t\t\ty = tmp;\n\t\t\t\t\tw = -w;\n\t\t\t\t}\n\t\t\t\tpar[y] = x;\n\t\t\t\twd[y] = w;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\t// return x-y\n\t\tlong diff(int x, int y) {\n\t\t\tif (!same(x, y)) {\n\t\t\t\tthrow new AssertionError();\n\t\t\t} else {\n\t\t\t\treturn this.weight(x) - this.weight(y);\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n \npublic class Main {\n    public static int n;\n    public static int q;\n    public static int[] p;\n    public static int[] rank;\n \n    public static boolean same(int x, int y) {\n        return findSet(x) == findSet(y);\n    }\n \n    public static void unite(int x, int y) {\n        int i = findSet(x);\n        int j = findSet(y);\n \n        if (i == j){\n\t    return;\n\t}\n        if (rank[i] > rank[j]){\n            p[j] = p[i];\n        } else {\n            p[i] = p[j];\n            if(rank[i] == rank[j]){\n            rank[j]++;\n            }\n        }\t\n    }\n \n    public static int findSet(int i) {\n       if(p[i] == i){ \n           return i;\n        }else{\n          return p[i] = findSet(p[i]);\n        }\n    }\n \n    public static void DisjointSet() {\n        p = new int[n];\n        rank = new int[n];\n \n        for (int i = 0; i < n; i++) {\n            p[i] = i;\n            rank[i] = 0;\n        }\n    }\n \n \n    public static void main (String[] args){\n        Scanner scanner = new Scanner(System.in);\n        n = scanner.nextInt();\n        q = scanner.nextInt();\n \n        DisjointSet();\n        for (int i = 0; i < q; i++) {\n            int com = scanner.nextInt();\n            int x = scanner.nextInt();\n            int y = scanner.nextInt();\n \n            if (com == 0){\n                unite(x, y);\n            }\n            if (com == 1){\n                if (same(x, y)){\n                    System.out.println(1);\n                }else{\n                    System.out.println(0);\n\t\t}\n            }\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\t//@start\n\tpublic static class WeightedUnionFind{\n\t    int[] par; // 親の番号\n\t    int[] ws;  // 親との重みの差\n\t    \n\t    public WeightedUnionFind(int n){\n\t        par = new int[n];\n\t        ws  = new int[n];\n\t        for(int i = 0; i < n; i++){ \n\t        \tpar[i] = -1;\n\t        }\n\t    }\n\t    \n\t    public int find(int x){\n\t    \tif(par[x] < 0){\n\t    \t\treturn x;\n\t    \t}else{\n\t    \t\tfinal int parent = find(par[x]);\n\t    \t\tws[x] += ws[par[x]];\n\t    \t\tpar[x] = parent;\n\t    \t\treturn parent;\n\t    \t}\n\t    }\n\t    \n\t    public int weight(int x){\n\t    \tfind(x);\n\t    \treturn ws[x];\n\t    }\n\t    \n\t    public boolean union(int x, int y, int w){ // x <-(w)- y (x + w = y)\n\t    \tw += weight(x);\n\t    \tw -= weight(y);\n\t        x = find(x);\n\t        y = find(y);\n\t        \n\t        if(x != y){\n\t            par[x] += par[y];\n\t            par[y] = x;\n\t            ws[y] = w;\n\t            \n\t            return true;\n\t        }else{\n\t            return false;\n\t        }\n\t    }\n\t    \n\t    public boolean same(int x, int y){\n\t        return find(x) == find(y);\n\t    }\n\t    \n\t    public Integer diff(int x, int y){ // x - y を求める. 比較不能ならnull.\n\t    \tif(!same(x, y)){\n\t    \t\treturn null;\n\t    \t}else{\n\t    \t\treturn this.weight(x) - this.weight(y);\n\t    \t}\n\t    }\n\t    \n\t\tpublic int size(int x){\n\t\t\treturn -par[find(x)];\n\t\t}\n\t}\n\t//@end\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile(true){\n\t\t\tfinal int n = sc.nextInt();\n\t\t\tfinal int m = sc.nextInt();\n\t\t\t\n\t\t\tif(n == 0 && m == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tWeightedUnionFind uf = new WeightedUnionFind(n);\n\t\t\t\n\t\t\tfor(int i = 0; i < m; i++){\n\t\t\t\tfinal String ops = sc.next();\n\t\t\t\t\n\t\t\t\tif(\"?\".equals(ops)){\n\t\t\t\t\tfinal int r = sc.nextInt() - 1;\n\t\t\t\t\tfinal int l = sc.nextInt() - 1;\n\t\t\t\t\t\n\t\t\t\t\tif(!uf.same(r, l)){\n\t\t\t\t\t\tSystem.out.println(\"UNKNOWN\");\n\t\t\t\t\t}else{\n\t\t\t\t\t\tSystem.out.println(uf.weight(l) - uf.weight(r));\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tfinal int r = sc.nextInt() - 1;\n\t\t\t\t\tfinal int l = sc.nextInt() - 1;\n\t\t\t\t\tfinal int w = sc.nextInt();\n\t\t\t\t\t\n\t\t\t\t\tuf.union(r, l, w);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tsc.close();\n\t}\n\t\n\tpublic static class Scanner {\n\t    private BufferedReader br;\n\t    private StringTokenizer tok;\n\n\t    public Scanner(InputStream is) throws IOException {\n\t        br = new BufferedReader(new InputStreamReader(is));\n\t    }\n\n\t    private void getLine() throws IOException {\n\t        while (!hasNext()) { tok = new StringTokenizer(br.readLine()); }\n\t    }\n\n\t    private boolean hasNext() {\n\t        return tok != null && tok.hasMoreTokens();\n\t    }\n\n\t    public String next() throws IOException {\n\t        getLine(); return tok.nextToken();\n\t    }\n\n\t    public int nextInt() throws IOException {\n\t        return Integer.parseInt(next());\n\t    }\n\t    // 他のnextXXXもXXX.parseXXX()メソッドを使って作れるので省略\n\t    \n\t    public void close() throws IOException {\n\t        br.close();\n\t    }\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.ListIterator;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\t\n\tpublic static class WeightUnionFind{\n\t\tint[] par;\n\t\tint[] diff_weight;\n\t\t\n\t\tWeightUnionFind(int n){\n\t\t\tpar=new int[n];\n\t\t\tdiff_weight = new int[n];\n\t\t\t\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tpar[i]=i;\n\t\t\t\tdiff_weight[i] = 0;\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic int find(int x){\n\t\t\tif(par[x]==x){\n\t\t\t\treturn x;\n\t\t\t}\n\t\t\t\n\t\t\tint old_par = par[x];\n\t\t\t\n\t\t\tpar[x]=find(par[x]);\n\t\t\tdiff_weight[x] += diff_weight[old_par];\n\t\t\treturn par[x];\n\t\t}\n\t\t\n\t\tpublic Boolean same(int x,int y){\n\t\t\treturn find(x)==find(y);\n\t\t}\n\t\t\n\t\tpublic int get_diff(int x, int y){\n\t\t\treturn diff_weight[x] - diff_weight[y];\n\t\t}\n\t\t\n\t\tpublic void unite(int x,int y){\n\t\t\tif(find(x)==find(y)){\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tpar[find(x)]=find(y);\n\t\t}\n\t\t\n\t\tpublic void set_diff(int x,int y, int d){\n\t\t\tif(find(x)==find(y)){\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tdiff_weight[x] = d;\n\t\t\tpar[x]=y;\n\t\t}\n\t}\n\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile (true) {\n\t\t\tfinal int N = sc.nextInt();\n\t\t\tfinal int M = sc.nextInt();\n\n\t\t\tif (N == 0 && M == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tWeightUnionFind wuf = new WeightUnionFind(N);\n\t\t\t\n\t\t\tfor(int i = 0; i < M; i++){\n\t\t\t\tString op = sc.next();\n\t\t\t\t\n\t\t\t\tif(op.equals(\"!\")){\n\t\t\t\t\tfinal int from = sc.nextInt() - 1;\n\t\t\t\t\tfinal int to = sc.nextInt() - 1;\n\t\t\t\t\tfinal int w = sc.nextInt();\n\t\t\t\t\t\n\t\t\t\t\twuf.set_diff(from, to, w);\n\t\t\t\t\t\n\t\t\t\t}else{\n\t\t\t\t\tfinal int from = sc.nextInt() - 1;\n\t\t\t\t\tfinal int to = sc.nextInt() - 1;\n\t\t\t\t\t\n\t\t\t\t\tif(!wuf.same(from, to)){\n\t\t\t\t\t\tSystem.out.println(\"UNKOWN\");\n\t\t\t\t\t}else{\n\t\t\t\t\t\tSystem.out.println(wuf.get_diff(from, to));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t}\n\n\t\tsc.close();\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n  \npublic class saisyu2 {\n    public static int N;\n    public static int M;\n    public static int[] p;\n    public static int[] rank;\n    public static int[] weight;\n \n    public static boolean same(int x, int y) {\n        return findSet(x) == findSet(y);\n    }\n  \n    public static void unite(int x, int y, int w) {\n        int i = findSet(x);\n        int j = findSet(y);\n       \n \n        if (i == j){\n\t    return;\n\t}\n        if (rank[i] > rank[j]){\n            p[j] = i;\t   \n            weight[j] =  w - weight[y] + weight[x];\n        } else {\n            p[i] = j;\n            weight[i] =  -w - weight[x] + weight[y];\n            if(rank[i] == rank[j]){\n\t\trank[j]++;\n            }\n        }   \n    }\n  \n    public static int findSet(int i) {\n\tif(p[i] == i){ \n\t    return i;\n        }else{\n\t    int tmp = findSet(p[i]);\n\t    weight[i] += weight[p[i]];\n\t    return p[i] = tmp;\n        }\n    }\n  \n    public static void DisjointSet() {\n        p = new int[N];\n        rank = new int[N];\n        weight = new int[N];\n  \n        for (int i = 0; i < N; i++) {\n            p[i] = i;\n            rank[i] = 0;\n            weight[i] = 0;\n        }\n    }\n  \n  \n    public static void main (String[] args){\n        Scanner scanner = new Scanner(System.in);\n        while(true){\n\t    N = scanner.nextInt();\n\t    M = scanner.nextInt();\n \n\t    if(N==0 && M==0){\n\t\tbreak;\n\t    }\n  \n\t    DisjointSet();\n \n\t    for (int i = 0; i < M; i++) {\n\t\tString c = scanner.next();\n\t\tint a = scanner.nextInt();\n\t\tint b = scanner.nextInt();\n\t\ta--; b--; \n         \n\t\tif(c.equals(\"!\")){\n\t\t    int w = scanner.nextInt();\n\t\t    unite(a, b, w);\n\t\t}else{ \n\t\t    if(same(a,b)){\n\t\t\tSystem.out.println(weight[b] - weight[a]);\n\t\t    }else{\n\t\t\tSystem.out.println(\"UNKNOWN\");\n\t\t    }\n\t\t}\n\t    }\n\t}\n       \n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport static java.lang.Math.*;\n\npublic class Main {\n\tfinal Scanner sc = new Scanner(System.in);\n\tpublic static void main(String[] args) {\n\t\tnew Main().init();\n\t}\n\tvoid init(){\n\t\tfinal long stackSize = 8*1024*1024;\n\t\tnew Thread(null, new AOJ1330(), \"RUN\", stackSize).start();\n\t}\n\t\n\tclass AOJ1330 implements Runnable{\n\t\tAOJ1330(){}\n\t\t@Override public void run(){\n//\t\t\tlong start = System.currentTimeMillis();\n\t\t\twhile(sc.hasNext()){\n\t\t\t\tN=sc.nextInt();\n\t\t\t\tM=sc.nextInt();\n\t\t\t\tif((N|M)==0)\tbreak;\n\t\t\t\tsolve();\n\t\t\t}\n//\t\t\tSystem.out.println( (System.currentTimeMillis()-start)+\"ms\");\n\t\t}\n\t\t\n\t\tint N,M;\n\t\t\n\t\tvoid solve(){\n\t\t\tUnionFind uf = new UnionFind(N);\n\t\t\tfor(int i=0; i<M; ++i){\n\t\t\t\tif(sc.next().equals(\"!\")){\n\t\t\t\t\tint a=sc.nextInt(), b=sc.nextInt(), w=sc.nextInt();\n\t\t\t\t\t--a;\n\t\t\t\t\t--b;\n\t\t\t\t\tuf.unite(a, b, w);\n\t\t\t\t}else{\n\t\t\t\t\tint a=sc.nextInt(), b=sc.nextInt();\n\t\t\t\t\tint ret = uf.getWeight(--a, --b);\n\t\t\t\t\tSystem.out.println(ret>=uf.INF? \"UNKNOWN\" : ret);\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.gc();\n\t\t}\n\t\t\n//\t\t// Union-Find Tree\n\t\tclass UnionFind{\n\t\t\tint[] par,w;\n\t\t\tfinal int INF = Integer.MAX_VALUE/4;\n\t\t\t\n\t\t\tUnionFind(int n){\n\t\t\t\tpar = new int[n];\n\t\t\t\tw = new int[n];\n\t\t\t\tfor(int i=0; i<n; ++i)\tpar[i]=i;\n\t\t\t}\n\t\t\t\n\t\t\tint find(int x){\n\t\t\t\tif(par[x] == x)\treturn x;\n\t\t\t\telse{\n\t\t\t\t\tint tmp = find(par[x]);\n\t\t\t\t\tw[x] += w[par[x]];\n\t\t\t\t\treturn par[x] = tmp;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tvoid unite(int x,int y,int ww){\n\t\t\t\tint px=find(x),\n\t\t\t\t\tpy=find(y);\n\t\t\t\tif(px==py)\treturn;\n\t\t\t\t\n\t\t\t\tw[px] = ww - w[x];\n\t\t\t\tpar[px] = y;\n\t\t\t}\n\t\t\t\n\t\t\tint getWeight(int x,int y){\n\t\t\t\tint xx = find(x),\n\t\t\t\t\tyy = find(y);\n\t\t\t\treturn (xx==yy? w[x]-w[y] : INF);\n\t\t\t}\n\t\t\t\n\t\t}\n}}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n \npublic class ouyou2 {\n    public static int N;\n    public static int M;\n    public static int[] p;\n    public static int[] rank;\n    public static int[] weight;\n\n    public static boolean same(int x, int y) {\n        return findSet(x) == findSet(y);\n    }\n \n    public static void unite(int x, int y, int w) {\n        int i = findSet(x);\n        int j = findSet(y);\n        w -= weight[j] - weight[i];\n\n        if (i == j){\n\t    return;\n\t}\n        if (rank[i] > rank[j]){\n            p[j] = p[i];\n            weight[j] = w;\n        } else {\n            p[i] = p[j];\n            weight[i] = -w;\n            if(rank[i] == rank[j]){\n\t\trank[j]++;\n            }\n        }\t\n    }\n \n    public static int findSet(int i) {\n\tif(p[i] == i){ \n\t    return i;\n        }else{\n\t    return p[i] = findSet(p[i]);\n        }\n    }\n \n    public static void DisjointSet() {\n        p = new int[N];\n        rank = new int[N];\n        weight = new int[N];\n \n        for (int i = 0; i < N; i++) {\n            p[i] = i;\n            rank[i] = 0;\n            weight[i] = 0;\n        }\n    }\n \n \n    public static void main (String[] args){\n        Scanner scanner = new Scanner(System.in);\n        while(true){\n\t    N = scanner.nextInt();\n\t    M = scanner.nextInt();\n\n\t    if(N==0 |M==0){\n\t\tbreak;\n\t    }\n \n\t    DisjointSet();\n\n\t    for (int i = 0; i < M; i++) {\n\t\tString c = scanner.next();\n\t\tint a = scanner.nextInt();\n\t\tint b = scanner.nextInt();\n\t\ta--; b--; \n\t\t\n\t\tif(c.equals(\"!\")){\n\t\t    int w = scanner.nextInt();\n\t\t    unite(a, b, w);\n\t\t}else{ \n\t\t    if(same(a,b)){\n\t\t\tSystem.out.println(weight[b] - weight[a]);\n\t\t    }else{\n\t\t\tSystem.out.println(\"UNKNOWN\");\n\t\t    }\n\t\t}\n\t    }\n\t}\n      \n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.ListIterator;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\t\n\tpublic static class WeightUnionFind{\n\t\tint[] parent;\n\t\tint[] rank;\n\t\tint[] diff_weight;\n\t\t\n\t\tWeightUnionFind(int n){\n\t\t\tparent=new int[n];\n\t\t\trank = new int[n];\n\t\t\tdiff_weight = new int[n];\n\t\t\t\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tparent[i]=i;\n\t\t\t\trank[i] = 0;\n\t\t\t\tdiff_weight[i] = 0;\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic int find(int x){\n\t\t\tif(parent[x]==x){\n\t\t\t\treturn x;\n\t\t\t}\n\t\t\t\n\t\t\treturn find(parent[x]);\n\t\t}\n\t\t\n\t\tpublic int find_diff(int x){\n\t\t\tif(parent[x] == x){\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\t\n\t\t\treturn find_diff(parent[x]) + diff_weight[x];\n\t\t}\n\t\t\n\t\tpublic Boolean same(int x,int y){\n\t\t\treturn find(x)==find(y);\n\t\t}\n\t\t\n\t\tpublic int get_diff(int x, int y){\n\t\t\tif(!same(x, y)){\n\t\t\t\treturn Integer.MIN_VALUE;\n\t\t\t}else{\n\t\t\t\treturn find_diff(x) - find_diff(y);\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic void unite(int x,int y){\n\t\t\tx = find(x);\n\t\t\ty = find(y);\n\t\t\t\n\t\t\tif(x == y){\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tif(rank[x] < rank[y]){\n\t\t\t\tparent[x] = y;\n\t\t\t}else{\n\t\t\t\tparent[y] = x;\n\t\t\t\tif(rank[x] == rank[y]){\n\t\t\t\t\trank[x]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic void set_diff(int x,int y, int d){\n\t\t\tfinal int find_x = find(x);\n\t\t\tfinal int find_y = find(y);\n\t\t\t\n\t\t\tif(find_x == find_y){\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tif(rank[find_x] < rank[find_y]){\n\t\t\t\tdiff_weight[x] = d + find_diff(y);\n\t\t\t\t\n\t\t\t\tparent[find_x] = find_y;\n\t\t\t}else{\n\t\t\t\tdiff_weight[y] = - d + find_diff(x);\n\t\t\t\t\n\t\t\t\tparent[find_y] = find_x;\n\t\t\t\tif(rank[find_x] == rank[find_y]){\n\t\t\t\t\trank[find_x]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile (true) {\n\t\t\tfinal int N = sc.nextInt();\n\t\t\tfinal int M = sc.nextInt();\n\n\t\t\tif (N == 0 && M == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tWeightUnionFind wuf = new WeightUnionFind(N);\n\t\t\t\n\t\t\tfor(int i = 0; i < M; i++){\n\t\t\t\tString op = sc.next();\n\t\t\t\t\n\t\t\t\tif(op.equals(\"!\")){\n\t\t\t\t\tfinal int from = sc.nextInt() - 1;\n\t\t\t\t\tfinal int to = sc.nextInt() - 1;\n\t\t\t\t\tfinal int w = sc.nextInt();\n\t\t\t\t\t\n\t\t\t\t\twuf.set_diff(from, to, w);\n\t\t\t\t\t//System.out.println(\"DIFF \" + from + \" \" + to + \" \" + w);\n\t\t\t\t}else{\n\t\t\t\t\tfinal int from = sc.nextInt() - 1;\n\t\t\t\t\tfinal int to = sc.nextInt() - 1;\n\t\t\t\t\t\n\t\t\t\t\tif(!wuf.same(from, to)){\n\t\t\t\t\t\tSystem.out.println(\"UNKOWN\");\n\t\t\t\t\t}else{\n\t\t\t\t\t\tSystem.out.println(wuf.get_diff(from, to));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t//System.out.println(\"P : \" + Arrays.toString(wuf.parent));\n\t\t\t\t//System.out.println(\"D : \" + Arrays.toString(wuf.diff_weight));\n\t\t\t}\n\t\t\t\n\t\t}\n\n\t\tsc.close();\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tnew Main().solver();\n\t}\n\n\tvoid solver() {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile (sc.hasNext()) {\n\t\t\tint N = sc.nextInt();\n\t\t\tint M = sc.nextInt();\n\t\t\tif (N == 0 && M == 0)\n\t\t\t\tbreak;\n\t\t\tWeightedUnionFind uf = new WeightedUnionFind(N);\n\t\t\tfor (int i = 0; i < M; i++) {\n\t\t\t\tString s = sc.next();\n\t\t\t\tint x = sc.nextInt() - 1;\n\t\t\t\tint y = sc.nextInt() - 1;\n\t\t\t\tif (s.equals(\"!\")) {\n\t\t\t\t\tint w = sc.nextInt();\n\t\t\t\t\tuf.union(x, y, w);\n\t\t\t\t} else {\n\t\t\t\t\tif (!uf.same(x, y)) {\n\t\t\t\t\t\tSystem.out.println(\"UNKNOWN\");\n\t\t\t\t\t} else {\n\t\t\t\t\t\tSystem.out.println(-uf.diff(x, y));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsc.close();\n\t}\n\n\tclass WeightedUnionFind {\n\t\tint[] par;\n\t\tint[] wd;\n\n\t\tpublic WeightedUnionFind(int n) {\n\t\t\tpar = new int[n];\n\t\t\twd = new int[n];\n\t\t\tArrays.fill(par, -1);\n\t\t}\n\n\t\tint find(int x) {\n\t\t\tif (par[x] < 0)\n\t\t\t\treturn x;\n\t\t\telse {\n\t\t\t\tint parent = find(par[x]);\n\t\t\t\twd[x] += wd[par[x]];\n\t\t\t\tpar[x] = parent;\n\t\t\t\treturn x;\n\t\t\t}\n\t\t}\n\n\t\tboolean same(int x, int y) {\n\t\t\treturn find(x) == find(y);\n\t\t}\n\n\t\tint weight(int x) {\n\t\t\tfind(x);\n\t\t\treturn wd[x];\n\t\t}\n\n\t\t// y - x = w ??? y = x + w;\n\t\tboolean union(int x, int y, int w) {\n\t\t\tif (find(x) == find(y))\n\t\t\t\treturn false;\n\t\t\telse {\n\t\t\t\tx = find(x);\n\t\t\t\ty = find(y);\n\t\t\t\tpar[y] = x;\n\t\t\t\twd[y] = w + (weight(x) - weight(y));\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\t// return x-y\n\t\tint diff(int x, int y) {\n\t\t\tif (!same(x, y)) {\n\t\t\t\tthrow new AssertionError();\n\t\t\t} else {\n\t\t\t\treturn weight(x) - weight(y);\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.Reader;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\n\npublic class Main {\n\tstatic FastScanner sc = new FastScanner(System.in);\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tint[] A = new int[100000];\n\t\tint[] B = new int[100000];\n\t\tint[] W = new int[100000];\n\t\tboolean[] type = new boolean[100000];\n\t\twhile (true) {\n\t\t\tint N = sc.nextInt();\n\t\t\tif (N == 0) break;\n\t\t\tint M = sc.nextInt();\n\t\t\tint[] dist = new int[N];\n\t\t\tArrayList<ArrayList<Edge>> graph = new ArrayList<ArrayList<Edge>>();\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tgraph.add(new ArrayList<Edge>());\n\t\t\t}\n\t\t\tfor (int i = 0; i < M; ++i) {\n\t\t\t\ttype[i] = sc.nextChar() == '!';\n\t\t\t\tA[i] = sc.nextInt() - 1;\n\t\t\t\tB[i] = sc.nextInt() - 1;\n\t\t\t\tif (type[i]) {\n\t\t\t\t\tW[i] = sc.nextInt();\n\t\t\t\t\tgraph.get(A[i]).add(new Edge(B[i], W[i]));\n\t\t\t\t\tgraph.get(B[i]).add(new Edge(A[i], -W[i]));\n\t\t\t\t}\n\t\t\t}\n\t\t\tArrays.fill(dist, Integer.MIN_VALUE);\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tif (dist[i] != Integer.MIN_VALUE) continue;\n\t\t\t\tArrayDeque<Integer> q = new ArrayDeque<Integer>();\n\t\t\t\tq.add(i);\n\t\t\t\tdist[i] = 0;\n\t\t\t\twhile (!q.isEmpty()) {\n\t\t\t\t\tint cur = q.poll();\n\t\t\t\t\tfor (Edge e : graph.get(cur)) {\n\t\t\t\t\t\tint next = e.to;\n\t\t\t\t\t\tif (dist[next] != Integer.MIN_VALUE) continue;\n\t\t\t\t\t\tdist[next] = dist[cur] + e.w;\n\t\t\t\t\t\tq.add(next);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tUnionFind uf = new UnionFind(100000);\n\t\t\tfor (int i = 0; i < M; ++i) {\n\t\t\t\tif (A[i] == -1 || B[i] == -1) return;\n\t\t\t\tif (type[i]) {\n\t\t\t\t\tuf.union(A[i], B[i]);\n\t\t\t\t} else {\n\t\t\t\t\tif (!uf.find(A[i], B[i])) {\n\t\t\t\t\t\tSystem.out.println(\"UNKNOWN\");\n\t\t\t\t\t} else {\n\t\t\t\t\t\tSystem.out.println(dist[B[i]] - dist[A[i]]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic class Edge {\n\t\tint to, w;\n\n\t\tEdge(int to, int w) {\n\t\t\tthis.to = to;\n\t\t\tthis.w = w;\n\t\t}\n\t}\n\n\tstatic class UnionFind {\n\t\tint[] set;\n\n\t\tUnionFind(int n) {\n\t\t\tset = new int[n];\n\t\t\tArrays.fill(set, -1);\n\t\t}\n\n\t\tvoid union(int a, int b) {\n\t\t\tint rtA = root(a);\n\t\t\tint rtb = root(b);\n\t\t\tif (rtA == rtb) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tset[rtA] += set[rtb];\n\t\t\tset[rtb] = rtA;\n\t\t}\n\n\t\tboolean find(int a, int b) {\n\t\t\treturn root(a) == root(b);\n\t\t}\n\n\t\tint root(int a) {\n\t\t\tif (set[a] < 0) {\n\t\t\t\treturn a;\n\t\t\t} else {\n\t\t\t\tset[a] = root(set[a]);\n\t\t\t\treturn set[a];\n\t\t\t}\n\t\t}\n\n\t\tint size(int a) {\n\t\t\treturn -set[root(a)];\n\t\t}\n\t}\n\n\tstatic class FastScanner {\n\t\tReader input;\n\n\t\tFastScanner() {\n\t\t\tthis(System.in);\n\t\t}\n\n\t\tFastScanner(InputStream stream) {\n\t\t\tthis.input = new BufferedReader(new InputStreamReader(stream));\n\t\t}\n\n\t\tint nextInt() throws IOException {\n\t\t\tint sign = 1;\n\t\t\tint b = input.read();\n\t\t\twhile ((b < '0' || '9' < b) && b != '-' && b != '+') {\n\t\t\t\tif (b == -1) return 0;\n\t\t\t\tb = input.read();\n\t\t\t}\n\t\t\tif (b == '-') {\n\t\t\t\tsign = -1;\n\t\t\t\tb = input.read();\n\t\t\t} else if (b == '+') {\n\t\t\t\tb = input.read();\n\t\t\t}\n\t\t\tint ret = b - '0';\n\t\t\twhile (true) {\n\t\t\t\tb = input.read();\n\t\t\t\tif (b < '0' || '9' < b) return ret * sign;\n\t\t\t\tret *= 10;\n\t\t\t\tret += b - '0';\n\t\t\t}\n\t\t}\n\n\t\tchar nextChar() throws IOException {\n\t\t\tint b = input.read();\n\t\t\twhile (Character.isWhitespace((char) b)) {\n\t\t\t\tb = input.read();\n\t\t\t}\n\t\t\treturn (char) b;\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.Reader;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\n\npublic class Main {\n\tstatic FastScanner sc = new FastScanner(System.in);\n\tstatic int N;\n\n\tpublic static void main(String[] args) throws Exception {\n\t\twhile (true) {\n\t\t\tN = sc.nextInt();\n\t\t\tif (N == 0) break;\n\t\t\tint M = sc.nextInt();\n\t\t\tint[] A = new int[M];\n\t\t\tint[] B = new int[M];\n\t\t\tint[] W = new int[M];\n\t\t\tboolean[] type = new boolean[M];\n\t\t\tArrayList<ArrayList<Edge>> graph = new ArrayList<>();\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tgraph.add(new ArrayList<Edge>());\n\t\t\t}\n\t\t\tfor (int i = 0; i < M; ++i) {\n\t\t\t\ttype[i] = sc.nextChar() == '!';\n\t\t\t\tA[i] = sc.nextInt() - 1;\n\t\t\t\tB[i] = sc.nextInt() - 1;\n\t\t\t\tif (type[i]) {\n\t\t\t\t\tW[i] = sc.nextInt();\n\t\t\t\t\tgraph.get(A[i]).add(new Edge(B[i], W[i]));\n\t\t\t\t\tgraph.get(B[i]).add(new Edge(A[i], -W[i]));\n\t\t\t\t}\n\t\t\t}\n\t\t\tint[] dist = new int[N];\n\t\t\tArrays.fill(dist, Integer.MIN_VALUE);\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tif (dist[i] != Integer.MIN_VALUE) continue;\n\t\t\t\tArrayDeque<Integer> q = new ArrayDeque<Integer>();\n\t\t\t\tq.add(i);\n\t\t\t\tdist[i] = 0;\n\t\t\t\twhile (!q.isEmpty()) {\n\t\t\t\t\tint cur = q.poll();\n\t\t\t\t\tfor (Edge e : graph.get(cur)) {\n\t\t\t\t\t\tint next = e.to;\n\t\t\t\t\t\tif (dist[next] != Integer.MIN_VALUE) continue;\n\t\t\t\t\t\tdist[next] = dist[cur] + e.w;\n\t\t\t\t\t\tq.add(next);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tUnionFind uf = new UnionFind(N);\n\t\t\tfor (int i = 0; i < M; ++i) {\n\t\t\t\tif (type[i]) {\n\t\t\t\t\tuf.union(A[i], B[i]);\n\t\t\t\t} else {\n\t\t\t\t\tif (!uf.find(A[i], B[i])) {\n\t\t\t\t\t\tSystem.out.println(\"UNKNOWN\");\n\t\t\t\t\t} else {\n\t\t\t\t\t\tSystem.out.println(dist[B[i]] - dist[A[i]]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic class Edge {\n\t\tint to, w;\n\n\t\tEdge(int to, int w) {\n\t\t\tthis.to = to;\n\t\t\tthis.w = w;\n\t\t}\n\t}\n\n\tstatic class UnionFind {\n\t\tint[] set;\n\n\t\tUnionFind(int n) {\n\t\t\tset = new int[n];\n\t\t\tArrays.fill(set, -1);\n\t\t}\n\n\t\tvoid union(int a, int b) {\n\t\t\tint rtA = root(a);\n\t\t\tint rtb = root(b);\n\t\t\tif (rtA == rtb) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tset[rtA] += set[rtb];\n\t\t\tset[rtb] = rtA;\n\t\t}\n\n\t\tboolean find(int a, int b) {\n\t\t\treturn root(a) == root(b);\n\t\t}\n\n\t\tint root(int a) {\n\t\t\tif (set[a] < 0) {\n\t\t\t\treturn a;\n\t\t\t} else {\n\t\t\t\tset[a] = root(set[a]);\n\t\t\t\treturn set[a];\n\t\t\t}\n\t\t}\n\n\t\tint size(int a) {\n\t\t\treturn -set[root(a)];\n\t\t}\n\t}\n\n\tstatic class FastScanner {\n\t\tReader input;\n\n\t\tFastScanner() {\n\t\t\tthis(System.in);\n\t\t}\n\n\t\tFastScanner(InputStream stream) {\n\t\t\tthis.input = new BufferedReader(new InputStreamReader(stream));\n\t\t}\n\n\t\tint nextInt() throws IOException {\n\t\t\tint sign = 1;\n\t\t\tint b = input.read();\n\t\t\twhile ((b < '0' || '9' < b) && b != '-' && b != '+') {\n\t\t\t\tb = input.read();\n\t\t\t}\n\t\t\tif (b == '-') {\n\t\t\t\tsign = -1;\n\t\t\t\tb = input.read();\n\t\t\t} else if (b == '+') {\n\t\t\t\tb = input.read();\n\t\t\t}\n\t\t\tint ret = b - '0';\n\t\t\twhile (true) {\n\t\t\t\tb = input.read();\n\t\t\t\tif (b < '0' || '9' < b) return ret * sign;\n\t\t\t\tret *= 10;\n\t\t\t\tret += b - '0';\n\t\t\t}\n\t\t}\n\n\t\tchar nextChar() throws IOException {\n\t\t\tint b = input.read();\n\t\t\twhile (Character.isWhitespace((char) b)) {\n\t\t\t\tb = input.read();\n\t\t\t}\n\t\t\treturn (char) b;\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.Reader;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic Scanner sc = new Scanner(System.in);\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tint[] A = new int[100000];\n\t\tint[] B = new int[100000];\n\t\tint[] W = new int[100000];\n\t\tboolean[] type = new boolean[100000];\n\t\tint[] dist = new int[100000];\n\t\tArrayList<ArrayList<Edge>> graph = new ArrayList<ArrayList<Edge>>();\n\t\tfor (int i = 0; i < 100000; ++i) {\n\t\t\tgraph.add(new ArrayList<Edge>());\n\t\t}\n\t\twhile (sc.hasNextInt()) {\n\t\t\tint N = sc.nextInt();\n\t\t\tif (N == 0) break;\n\t\t\tint M = sc.nextInt();\n//\t\t\tSystem.err.println(\"N:\" + N + \" M:\" + M);\n\t\t\tsc.nextLine();\n//\t\t\tfor (int i = 0; i < N; ++i) {\n//\t\t\t\tA[i] = -1;\n//\t\t\t\tB[i] = -1;\n//\t\t\t}\n\t\t\tfor (int i = 0; i < 100000; ++i) {\n\t\t\t\tgraph.get(i).clear();\n\t\t\t}\n\t\t\tfor (int i = 0; i < M; ++i) {\n//\t\t\t\tif (!sc.hasNextLine()) break;\n\t\t\t\tString[] line = sc.nextLine().split(\" \");\n\t\t\t\ttype[i] = line[0].charAt(0) == '!';\n\t\t\t\tA[i] = Integer.parseInt(line[1]) - 1;\n\t\t\t\tB[i] = Integer.parseInt(line[2]) - 1;\n\t\t\t\tif (type[i]) {\n\t\t\t\t\tW[i] = Integer.parseInt(line[3]);\n\t\t\t\t\tgraph.get(A[i]).add(new Edge(B[i], W[i]));\n\t\t\t\t\tgraph.get(B[i]).add(new Edge(A[i], -W[i]));\n\t\t\t\t}\n\t\t\t}\n\t\t\tArrays.fill(dist, Integer.MIN_VALUE);\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tif (dist[i] != Integer.MIN_VALUE) continue;\n\t\t\t\tArrayDeque<Integer> q = new ArrayDeque<Integer>();\n\t\t\t\tq.add(i);\n\t\t\t\tdist[i] = 0;\n\t\t\t\twhile (!q.isEmpty()) {\n\t\t\t\t\tint cur = q.poll();\n\t\t\t\t\tfor (Edge e : graph.get(cur)) {\n\t\t\t\t\t\tint next = e.to;\n\t\t\t\t\t\tif (dist[next] != Integer.MIN_VALUE) continue;\n\t\t\t\t\t\tdist[next] = dist[cur] + e.w;\n\t\t\t\t\t\tq.add(next);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tUnionFind uf = new UnionFind(100000);\n\t\t\tfor (int i = 0; i < M; ++i) {\n//\t\t\t\tif (A[i] == -1 || B[i] == -1) {\n//\t\t\t\t\tSystem.out.println(\"UNKNOWN\");\n//\t\t\t\t\tcontinue;\n//\t\t\t\t}\n\t\t\t\tif (type[i]) {\n\t\t\t\t\tuf.union(A[i], B[i]);\n\t\t\t\t} else {\n\t\t\t\t\tif (!uf.find(A[i], B[i])) {\n\t\t\t\t\t\tSystem.out.println(\"UNKNOWN\");\n\t\t\t\t\t} else {\n\t\t\t\t\t\tSystem.out.println(dist[B[i]] - dist[A[i]]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic class Edge {\n\t\tint to, w;\n\n\t\tEdge(int to, int w) {\n\t\t\tthis.to = to;\n\t\t\tthis.w = w;\n\t\t}\n\t}\n\n\tstatic class UnionFind {\n\t\tint[] set;\n\n\t\tUnionFind(int n) {\n\t\t\tset = new int[n];\n\t\t\tArrays.fill(set, -1);\n\t\t}\n\n\t\tvoid union(int a, int b) {\n\t\t\tint rtA = root(a);\n\t\t\tint rtb = root(b);\n\t\t\tif (rtA == rtb) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tset[rtA] += set[rtb];\n\t\t\tset[rtb] = rtA;\n\t\t}\n\n\t\tboolean find(int a, int b) {\n\t\t\treturn root(a) == root(b);\n\t\t}\n\n\t\tint root(int a) {\n\t\t\tif (set[a] < 0) {\n\t\t\t\treturn a;\n\t\t\t} else {\n\t\t\t\tset[a] = root(set[a]);\n\t\t\t\treturn set[a];\n\t\t\t}\n\t\t}\n\n\t\tint size(int a) {\n\t\t\treturn -set[root(a)];\n\t\t}\n\t}\n\n\tstatic class FastScanner {\n\t\tReader input;\n\n\t\tFastScanner() {\n\t\t\tthis(System.in);\n\t\t}\n\n\t\tFastScanner(InputStream stream) {\n\t\t\tthis.input = new BufferedReader(new InputStreamReader(stream));\n\t\t}\n\n\t\tint nextInt() throws IOException {\n\t\t\tint sign = 1;\n\t\t\tint b = input.read();\n\t\t\twhile ((b < '0' || '9' < b) && b != '-' && b != '+') {\n\t\t\t\tif (b == -1) return 0;\n\t\t\t\tb = input.read();\n\t\t\t}\n\t\t\tif (b == '-') {\n\t\t\t\tsign = -1;\n\t\t\t\tb = input.read();\n\t\t\t} else if (b == '+') {\n\t\t\t\tb = input.read();\n\t\t\t}\n\t\t\tint ret = b - '0';\n\t\t\twhile (true) {\n\t\t\t\tb = input.read();\n\t\t\t\tif (b < '0' || '9' < b) return ret * sign;\n\t\t\t\tret *= 10;\n\t\t\t\tret += b - '0';\n\t\t\t}\n\t\t}\n\n\t\tchar nextChar() throws IOException {\n\t\t\tint b = input.read();\n\t\t\twhile (Character.isWhitespace((char) b)) {\n\t\t\t\tb = input.read();\n\t\t\t}\n\t\t\treturn (char) b;\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n \npublic class Main {\n    public static int N;\n    public static int M;\n    public static int[] p;\n    public static int[] rank;\n    public static int[] weight;\n\n    public static boolean same(int x, int y) {\n        return findSet(x) == findSet(y);\n    }\n \n    public static void unite(int x, int y, int w) {\n        int i = findSet(x);\n        int j = findSet(y);\n        w -= weight[b] - weight[a];\n\n        if (i == j){\n\t    return;\n\t}\n        if (rank[i] > rank[j]){\n            p[j] = p[i];\n            weight[j] = w;\n        } else {\n            p[i] = p[j];\n            weight[i] = -w;\n            if(rank[i] == rank[j]){\n            rank[j]++;\n            }\n        }\t\n    }\n \n    public static int findSet(int i) {\n       if(p[i] == i){ \n           return i;\n        }else{\n          return p[i] = findSet(p[i]);\n        }\n    }\n \n    public static void DisjointSet() {\n        p = new int[N];\n        rank = new int[N];\n        weight = new int[N]\n \n        for (int i = 0; i < N; i++) {\n            p[i] = i;\n            rank[i] = 0;\n            weight[i] = 0;\n        }\n    }\n \n \n    public static void main (String[] args){\n        Scanner scanner = new Scanner(System.in);\n        while(true){\n        N = scanner.nextInt();\n        M = scanner.nextInt();\n\n        if(N==0 & M==0){\n           break;\n        }\n \n        DisjointSet();\n\n        for (int i = 0; i < M; i++) {\n            if(scanner.next().equals(\"!\")){\n            int a = scanner.nextInt();\n            int b = scanner.nextInt();\n            int w = scanner.nextInt();\n \n            a--; b--;   \n            unite(a, b, w);\n            }else{\n               if(same(x, y)){\n                    System.out.println(\"UNKNOWN\");\n                }else{\n                    System.out.println(weight[b]-weight[a]);\n\t\t}\n            }\n        }\n       }\n      }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\nimport java.util.Scanner;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\n\tpublic static class WeightedUnionFind{\n\t    int[] par; // 親の番号\n\t    int[] ws;  // 親との重みの差\n\t    \n\t    public WeightedUnionFind(int n){\n\t        par = new int[n];\n\t        ws  = new int[n];\n\t        for(int i = 0; i < n; i++){ \n\t        \tpar[i] = -1;\n\t        \tws[i]  = 0;\n\t        }\n\t    }\n\t    \n\t    public int find(int x){\n\t    \tif(par[x] < 0){\n\t    \t\treturn x;\n\t    \t}else{\n\t    \t\tfinal int parent = find(par[x]);\n\t    \t\tws[x] += ws[par[x]];\n\t    \t\tpar[x] = parent;\n\t    \t\treturn parent;\n\t    \t}\n\t    }\n\t    \n\t    public int weight(int x){\n\t    \tfind(x);\n\t    \treturn ws[x];\n\t    }\n\t    \n\t    public boolean union(int x, int y, int w){ // x <-(w)- y (x + w = y)\n\t    \tw += weight(x);\n\t    \tw -= weight(y);\n\t        x = find(x);\n\t        y = find(y);\n\t        \n\t        if(x != y){\n\t            if(par[y] < par[x]) {  // 多い方が根になるようにスワップする.\n\t                int tmp = x; x = y; y = tmp;\n\t                w = -w;\n\t            }\n\t            par[x] += par[y];\n\t            par[y] = x;\n\t            ws[y] = w;\n\t            \n\t            return true;\n\t        }else{\n\t            return false;\n\t        }\n\t    }\n\t    \n\t    public boolean same(int x, int y){\n\t        return find(x) == find(y);\n\t    }\n\t    \n\t    public Integer diff(int x, int y){ // x - y を求める. 比較不能ならnull.\n\t    \tif(!same(x, y)){\n\t    \t\treturn null;\n\t    \t}else{\n\t    \t\treturn this.weight(x) - this.weight(y);\n\t    \t}\n\t    }\n\t    \n\t    public int size(int x){\n\t        return -par[find(x)];\n\t    }\n\t}\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tScanner sc = new Scanner(System.in);\n\n\t\twhile(true){\n\t\t\tfinal int n = sc.nextInt();\n\t\t\tfinal int m = sc.nextInt();\n\t\t\t\n\t\t\tif(n == 0 && m == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tWeightedUnionFind uf = new WeightedUnionFind(n);\n\t\t\t\n\t\t\tfor(int i = 0; i < m; i++){\n\t\t\t\tfinal String ops = sc.next();\n\t\t\t\t\n\t\t\t\tif(\"?\".equals(ops)){\n\t\t\t\t\tfinal int r = sc.nextInt() - 1;\n\t\t\t\t\tfinal int l = sc.nextInt() - 1;\n\t\t\t\t\tfinal Integer ret = uf.diff(r, l);\n\t\t\t\t\tSystem.out.println(ret == null ? \"UNKNOWN\" : -ret);\n\t\t\t\t}else{\n\t\t\t\t\tfinal int r = sc.nextInt() - 1;\n\t\t\t\t\tfinal int l = sc.nextInt() - 1;\n\t\t\t\t\tfinal int w = sc.nextInt();\n\t\t\t\t\t\n\t\t\t\t\tuf.union(r, l, w);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tsc.close();\n\t}\n\t\n\tpublic static class Scanner {\n\t    private BufferedReader br;\n\t    private StringTokenizer tok;\n\n\t    public Scanner(InputStream is) throws IOException {\n\t        br = new BufferedReader(new InputStreamReader(is));\n\t    }\n\n\t    private void getLine() throws IOException {\n\t        while (!hasNext()) { tok = new StringTokenizer(br.readLine()); }\n\t    }\n\n\t    private boolean hasNext() {\n\t        return tok != null && tok.hasMoreTokens();\n\t    }\n\n\t    public String next() throws IOException {\n\t        getLine(); return tok.nextToken();\n\t    }\n\n\t    public int nextInt() throws IOException {\n\t        return Integer.parseInt(next());\n\t    }\n\t    \n\t    public void close() throws IOException {\n\t        br.close();\n\t    }\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\n\npublic class Main {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\n\tclass WeightedUnionFind {\n\t\tint[] par;\n\t\tlong[] wd;\n\n\t\tpublic WeightedUnionFind(int n) {\n\t\t\tpar = new int[n];\n\t\t\twd = new long[n];\n\t\t\tArrays.fill(par, -1);\n\t\t}\n\n\t\tint find(int x) {\n\t\t\tif (par[x] < 0)\n\t\t\t\treturn x;\n\t\t\telse {\n\t\t\t\tfinal int parent = find(par[x]);\n\t\t\t\twd[x] += wd[par[x]];\n\t\t\t\tpar[x] = parent;\n\t\t\t\treturn parent;\n\t\t\t}\n\t\t}\n\n\t\tboolean same(int x, int y) {\n\t\t\treturn find(x) == find(y);\n\t\t}\n\n\t\tlong weight(int x) {\n\t\t\tfind(x);\n\t\t\treturn wd[x];\n\t\t}\n\n\t\t// y - x = w ??? y = x + w;\n\t\tboolean union(int x, int y, long w) {\n\t\t\tw += (weight(x) - weight(y));\n\t\t\tx = find(x);\n\t\t\ty = find(y);\n\t\t\tif (x == y)\n\t\t\t\treturn false;\n\t\t\telse {\n\t\t\t\tif (par[y] < par[x]) {\n\t\t\t\t\tint tmp = x;\n\t\t\t\t\tx = y;\n\t\t\t\t\ty = tmp;\n\t\t\t\t\tw = -w;\n\t\t\t\t}\n\t\t\t\tpar[x] += par[y];\n\t\t\t\tpar[y] = x;\n\t\t\t\twd[y] = w;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\t// return x-y\n\t\tlong diff(int x, int y) {\n\t\t\tif (!same(x, y)) {\n\t\t\t\tthrow new AssertionError();\n\t\t\t} else {\n\t\t\t\treturn this.weight(x) - this.weight(y);\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid solver() {\n\t\twhile (true) {\n\t\t\tint N = ni();\n\t\t\tint M = ni();\n\t\t\tif (N == 0 && M == 0)\n\t\t\t\tbreak;\n\t\t\tWeightedUnionFind uf = new WeightedUnionFind(N);\n\t\t\tfor (int i = 0; i < M; i++) {\n\t\t\t\tString s = ns();\n\t\t\t\tint x = ni() - 1;\n\t\t\t\tint y = ni() - 1;\n\t\t\t\tif (s.equals(\"!\")) {\n\t\t\t\t\tlong w = nl();\n\t\t\t\t\tuf.union(x, y, w);\n\t\t\t\t} else {\n\t\t\t\t\tif (!uf.same(x, y)) {\n\t\t\t\t\t\tout.println(\"UNKNOWN\");\n\t\t\t\t\t} else {\n\t\t\t\t\t\tout.println(-uf.diff(x, y));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\n\t\tnew Main().solver();\n\t\tout.flush();\n\t}\n\n\tstatic long nl() {\n\t\ttry {\n\t\t\tlong num = 0;\n\t\t\tboolean minus = false;\n\t\t\twhile ((num = is.read()) != -1 && !((num >= '0' && num <= '9') || num == '-'))\n\t\t\t\t;\n\t\t\tif (num == '-') {\n\t\t\t\tnum = 0;\n\t\t\t\tminus = true;\n\t\t\t} else {\n\t\t\t\tnum -= '0';\n\t\t\t}\n\n\t\t\twhile (true) {\n\t\t\t\tint b = is.read();\n\t\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t\t} else {\n\t\t\t\t\treturn minus ? -num : num;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn -1;\n\t}\n\n\tstatic char nc() {\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tif (b == -1)\n\t\t\t\treturn 0;\n\t\t\treturn (char) b;\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn 0;\n\t}\n\n\tstatic double nd() {\n\t\ttry {\n\t\t\treturn Double.parseDouble(ns());\n\t\t} catch (Exception e) {\n\t\t}\n\t\treturn 0;\n\t}\n\n\tstatic String ns() {\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tif (b == -1)\n\t\t\t\treturn \"\";\n\t\t\tsb.append((char) b);\n\t\t\twhile (true) {\n\t\t\t\tb = is.read();\n\t\t\t\tif (b == -1)\n\t\t\t\t\treturn sb.toString();\n\t\t\t\tif (b <= ' ')\n\t\t\t\t\treturn sb.toString();\n\t\t\t\tsb.append((char) b);\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn \"\";\n\t}\n\n\tpublic static char[] ns(int n) {\n\t\tchar[] buf = new char[n];\n\t\ttry {\n\t\t\tint b = skip(), p = 0;\n\t\t\tif (b == -1)\n\t\t\t\treturn null;\n\t\t\tbuf[p++] = (char) b;\n\t\t\twhile (p < n) {\n\t\t\t\tb = is.read();\n\t\t\t\tif (b == -1 || b <= ' ')\n\t\t\t\t\tbreak;\n\t\t\t\tbuf[p++] = (char) b;\n\t\t\t}\n\t\t\treturn Arrays.copyOf(buf, p);\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn null;\n\t}\n\n\tpublic static byte[] nse(int n) {\n\t\tbyte[] buf = new byte[n];\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tif (b == -1)\n\t\t\t\treturn null;\n\t\t\tis.read(buf);\n\t\t\treturn buf;\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn null;\n\t}\n\n\tstatic int skip() throws IOException {\n\t\tint b;\n\t\twhile ((b = is.read()) != -1 && !(b >= 33 && b <= 126))\n\t\t\t;\n\t\treturn b;\n\t}\n\n\tstatic boolean eof() {\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\tint b = skip();\n\t\t\tis.reset();\n\t\t\treturn b == -1;\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tstatic int ni() {\n\t\ttry {\n\t\t\tint num = 0;\n\t\t\tboolean minus = false;\n\t\t\twhile ((num = is.read()) != -1 && !((num >= '0' && num <= '9') || num == '-'))\n\t\t\t\t;\n\t\t\tif (num == '-') {\n\t\t\t\tnum = 0;\n\t\t\t\tminus = true;\n\t\t\t} else {\n\t\t\t\tnum -= '0';\n\t\t\t}\n\n\t\t\twhile (true) {\n\t\t\t\tint b = is.read();\n\t\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t\t} else {\n\t\t\t\t\treturn minus ? -num : num;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn -1;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.StringTokenizer;\n\npublic class Main implements Runnable {\n\t//@start\n\tpublic static class WeightedUnionFind {\n\t\tint[] par; // 親の番号\n\t\tint[] ws; // 親との重みの差\n\n\t\tpublic WeightedUnionFind(int n) {\n\t\t\tpar = new int[n];\n\t\t\tws = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tpar[i] = -1;\n\t\t\t}\n\t\t}\n\n\t\tpublic int find(int x) {\n\t\t\tif (par[x] < 0) {\n\t\t\t\treturn x;\n\t\t\t} else {\n\t\t\t\tfinal int parent = find(par[x]);\n\t\t\t\tws[x] += ws[par[x]];\n\t\t\t\treturn par[x] = parent;\n\t\t\t}\n\t\t}\n\n\t\tpublic int weight(int x) {\n\t\t\tfind(x);\n\t\t\treturn ws[x];\n\t\t}\n\n\t\tpublic boolean union(int x, int y, int w) { // x <-(w)- y (x + w = y)\n\t\t\tw += weight(x);\n\t\t\tw -= weight(y);\n\t\t\tx = find(x);\n\t\t\ty = find(y);\n\n\t\t\tif (x != y) {\n\t\t\t\tpar[x] += par[y];\n\t\t\t\tpar[y] = x;\n\t\t\t\tws[y] = w;\n\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tpublic boolean same(int x, int y) {\n\t\t\treturn find(x) == find(y);\n\t\t}\n\n\t\tpublic Integer diff(int x, int y) { // x - y を求める. 比較不能ならnull.\n\t\t\tif (!same(x, y)) {\n\t\t\t\treturn null;\n\t\t\t} else {\n\t\t\t\treturn this.weight(x) - this.weight(y);\n\t\t\t}\n\t\t}\n\n\t\tpublic int size(int x) {\n\t\t\treturn -par[find(x)];\n\t\t}\n\t}\n\t//@end\n\t\n\tpublic void run() {\n\n\t\ttry {\n\t\t\tScanner sc = new Scanner(System.in);\n\n\t\t\twhile (true) {\n\t\t\t\tfinal int n = sc.nextInt();\n\t\t\t\tfinal int m = sc.nextInt();\n\n\t\t\t\tif (n == 0 && m == 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tWeightedUnionFind uf = new WeightedUnionFind(n);\n\n\t\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\t\tfinal String ops = sc.next();\n\n\t\t\t\t\tif (\"?\".equals(ops)) {\n\t\t\t\t\t\tfinal int r = sc.nextInt() - 1;\n\t\t\t\t\t\tfinal int l = sc.nextInt() - 1;\n\n\t\t\t\t\t\tif (!uf.same(r, l)) {\n\t\t\t\t\t\t\tSystem.out.println(\"UNKNOWN\");\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tSystem.out.println(uf.weight(l) - uf.weight(r));\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfinal int r = sc.nextInt() - 1;\n\t\t\t\t\t\tfinal int l = sc.nextInt() - 1;\n\t\t\t\t\t\tfinal int w = sc.nextInt();\n\n\t\t\t\t\t\tuf.union(r, l, w);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tsc.close();\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tnew Thread(null, new Main(), \"RUN\", 8 * 1024 * 1024).start();\n\t}\n\n\tpublic static class Scanner {\n\t\tprivate BufferedReader br;\n\t\tprivate StringTokenizer tok;\n\n\t\tpublic Scanner(InputStream is) throws IOException {\n\t\t\tbr = new BufferedReader(new InputStreamReader(is));\n\t\t}\n\n\t\tprivate void getLine() throws IOException {\n\t\t\twhile (!hasNext()) {\n\t\t\t\ttok = new StringTokenizer(br.readLine());\n\t\t\t}\n\t\t}\n\n\t\tprivate boolean hasNext() {\n\t\t\treturn tok != null && tok.hasMoreTokens();\n\t\t}\n\n\t\tpublic String next() throws IOException {\n\t\t\tgetLine();\n\t\t\treturn tok.nextToken();\n\t\t}\n\n\t\tpublic int nextInt() throws IOException {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\t// 他のnextXXXもXXX.parseXXX()メソッドを使って作れるので省略\n\n\t\tpublic void close() throws IOException {\n\t\t\tbr.close();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport static java.lang.Math.*;\n\npublic class Main {\n\tfinal Scanner sc = new Scanner(System.in);\n\tpublic static void main(String[] args) {\n\t\tnew Main().init();\n\t}\n\tvoid init(){\n\t\tfinal long stackSize = 8*1024*1024;\n\t\tnew Thread(null, new AOJ1330(), \"RUN\", stackSize).start();\n\t}\n\t\n\tclass AOJ1330 implements Runnable{\n\t\tAOJ1330(){}\n\t\t@Override public void run(){\n//\t\t\tlong start = System.currentTimeMillis();\n\t\t\twhile(sc.hasNext()){\n\t\t\t\tN=sc.nextInt();\n\t\t\t\tM=sc.nextInt();\n\t\t\t\tif((N|M)==0)\tbreak;\n\t\t\t\tsolve();\n\t\t\t}\n//\t\t\tSystem.out.println( (System.currentTimeMillis()-start)+\"ms\");\n\t\t}\n\t\t\n\t\tint N,M;\n\t\t\n\t\tvoid solve(){\n\t\t\tUnionFind uf = new UnionFind(N);\n\t\t\tfor(int i=0; i<M; ++i){\n\t\t\t\tif(sc.next().equals(\"!\")){\n\t\t\t\t\tint a=sc.nextInt(), b=sc.nextInt(), w=sc.nextInt();\n\t\t\t\t\t--a;\n\t\t\t\t\t--b;\n\t\t\t\t\tuf.unite(a, b, w);\n\t\t\t\t}else{\n\t\t\t\t\tint a=sc.nextInt(), b=sc.nextInt();\n\t\t\t\t\tUnionFind.Node aa = uf.find(--a),\n\t\t\t\t\t\t\tbb = uf.find(--b);\n\t\t\t\t\tSystem.out.println(aa.par!=bb.par ? \"UNKNOWN\" : aa.w-bb.w);\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.gc();\n\t\t}\n\t\t\n\t\t// Union-Find Tree\n\t\tclass UnionFind{\n\t\t\tclass Node{\n\t\t\t\tint par,w;\n\t\t\t\tNode(int par,int w){\n\t\t\t\t\tthis.par=par;\n\t\t\t\t\tthis.w=w;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tNode[] node;\n\t\t\tfinal int INF = Integer.MAX_VALUE/4;\n\t\t\t\n\t\t\tUnionFind(int n){\n\t\t\t\tnode=new Node[n];\n\t\t\t\tfor(int i=0; i<n; ++i)\tnode[i]=new Node(i,0);\n\t\t\t}\n\t\t\t\n\t\t\tNode find(int x){\n\t\t\t\tif(node[x].par == x)\treturn node[x];\n\t\t\t\telse{\n\t\t\t\t\tNode tmp = find(node[x].par);\n\t\t\t\t\tnode[x].par = tmp.par;\n\t\t\t\t\tnode[x].w += tmp.w;\n\t\t\t\t\treturn node[x];\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tvoid unite(int x,int y,int w){\n\t\t\t\tNode tx=find(x);\n\t\t\t\tNode ty=find(y);\n\t\t\t\tif(tx.par==ty.par)\treturn;\n\t\t\t\t\n\t\t\t\tnode[tx.par].w = w - tx.w;\n\t\t\t\tnode[tx.par].par = y;\n\t\t\t}\n\t\t\t\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.ListIterator;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\t\n\tpublic static class WeightUnionFind{\n\t\tint[] parent;\n\t\tint[] weight;\n\t\t\n\t\tWeightUnionFind(int n){\n\t\t\tparent=new int[n];\n\t\t\tweight = new int[n];\n\t\t\t\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tparent[i] = i;\n\t\t\t\tweight[i] = 0;\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic int find(int x){\n\t\t\tif(parent[x]==x){\n\t\t\t\treturn x;\n\t\t\t}\n\t\t\t\n\t\t\tint next = find(parent[x]);\n\t\t\tweight[x] += weight[parent[x]];\n\t\t\treturn parent[x] = next;\n\t\t}\n\t\t\n\t\tpublic Boolean same(int x,int y){\n\t\t\treturn find(x)==find(y);\n\t\t}\n\t\t\n\t\tpublic int get_diff(int x, int y){\n\t\t\tif(!same(x, y)){\n\t\t\t\treturn 0;\n\t\t\t}else{\n\t\t\t\treturn weight[x] - weight[y];\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic void set_rank(int x,int y, int d){\n\t\t\tfinal int find_x = find(x);\n\t\t\tfinal int find_y = find(y);\n\t\t\t\n\t\t\tif(find_x == find_y){\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tweight[find_x] = d - weight[x];\n\t\t\tparent[find_x] = y;\n\t\t}\n\t}\n\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile (true) {\n\t\t\tfinal int N = sc.nextInt();\n\t\t\tfinal int M = sc.nextInt();\n\n\t\t\tif (N == 0 && M == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tSystem.gc();\n\t\t\t\n\t\t\tWeightUnionFind wuf = new WeightUnionFind(N);\n\t\t\t\n\t\t\tfor(int i = 0; i < M; i++){\n\t\t\t\tString op = sc.next();\n\t\t\t\t\n\t\t\t\tif(op.equals(\"!\")){\n\t\t\t\t\tfinal int from = sc.nextInt() - 1;\n\t\t\t\t\tfinal int to = sc.nextInt() - 1;\n\t\t\t\t\tfinal int w = sc.nextInt();\n\t\t\t\t\t\n\t\t\t\t\twuf.set_rank(from, to, w);\n\t\t\t\t\t//System.out.println(\"DIFF \" + from + \" \" + to + \" \" + w);\n\t\t\t\t}else{\n\t\t\t\t\tfinal int from = sc.nextInt() - 1;\n\t\t\t\t\tfinal int to = sc.nextInt() - 1;\n\t\t\t\t\t\n\t\t\t\t\tif(!wuf.same(from, to)){\n\t\t\t\t\t\tSystem.out.println(\"UNKNOWN\");\n\t\t\t\t\t}else{\n\t\t\t\t\t\tSystem.out.println(wuf.get_diff(from, to));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t//System.out.println(\"P : \" + Arrays.toString(wuf.parent));\n\t\t\t\t//System.out.println(\"D : \" + Arrays.toString(wuf.diff_weight));\n\t\t\t}\n\t\t\t\n\t\t}\n\n\t\tsc.close();\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n \npublic class Main {\n    public static int N;\n    public static int M;\n    public static int[] p;\n    public static int[] rank;\n    public static int[] weight;\n\n    public static boolean same(int x, int y) {\n        return findSet(x) == findSet(y);\n    }\n \n    public static void unite(int x, int y, int w) {\n        int i = findSet(x);\n        int j = findSet(y);\n        w -= weight[j] - weight[i];\n\n        if (i == j){\n\t    return;\n\t}\n        if (rank[i] > rank[j]){\n            p[j] = p[i];\n            weight[j] = w;\n        } else {\n            p[i] = p[j];\n            weight[i] = -w;\n            if(rank[i] == rank[j]){\n            rank[j]++;\n            }\n        }\t\n    }\n \n    public static int findSet(int i) {\n       if(p[i] == i){ \n           return i;\n        }else{\n          return p[i] = findSet(p[i]);\n        }\n    }\n \n    public static void DisjointSet() {\n        p = new int[N];\n        rank = new int[N];\n        weight = new int[N];\n \n        for (int i = 0; i < N; i++) {\n            p[i] = i;\n            rank[i] = 0;\n            weight[i] = 0;\n        }\n    }\n \n \n    public static void main (String[] args){\n        Scanner scanner = new Scanner(System.in);\n        while(true){\n        N = scanner.nextInt();\n        M = scanner.nextInt();\n\n        if(N==0 & M==0){\n           break;\n        }\n \n        DisjointSet();\n\n        for (int i = 0; i < M; i++) {\n            if(scanner.next().equals(\"!\")){\n            int a = scanner.nextInt();\n            int b = scanner.nextInt();\n            int w = scanner.nextInt();\n \n            a--; b--;   \n            unite(a, b, w);\n            }else{\n               if(same(a,b)){\n                    System.out.println(weight[b] - weight[a]);\n                }else{\n                    System.out.println(\"UNKNOWN\");\n\t\t}\n            }\n        }\n       }\n      \n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.ListIterator;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\t\n\tpublic static class WeightUnionFind{\n\t\tint[] parent;\n\t\tint[] rank;\n\t\t\n\t\tWeightUnionFind(int n){\n\t\t\tparent=new int[n];\n\t\t\trank = new int[n];\n\t\t\t\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tparent[i]=i;\n\t\t\t\trank[i] = 0;\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic int find(int x){\n\t\t\tif(parent[x]==x){\n\t\t\t\treturn x;\n\t\t\t}\n\t\t\t\n\t\t\tint old = parent[x];\n\t\t\tparent[x] = find(parent[x]);\n\t\t\trank[x] += rank[old];\n\t\t\t\n\t\t\treturn parent[x];\n\t\t}\n\t\t\n\t\tpublic Boolean same(int x,int y){\n\t\t\treturn find(x)==find(y);\n\t\t}\n\t\t\n\t\tpublic int get_diff(int x, int y){\n\t\t\tif(!same(x, y)){\n\t\t\t\treturn Integer.MIN_VALUE;\n\t\t\t}else{\n\t\t\t\treturn rank[y] - rank[x];\n\t\t\t}\n\t\t}\n\t\t/*\n\t\tpublic void unite(int x,int y){\n\t\t\tx = find(x);\n\t\t\ty = find(y);\n\t\t\t\n\t\t\tif(x == y){\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tif(rank[x] < rank[y]){\n\t\t\t\tparent[x] = y;\n\t\t\t}else{\n\t\t\t\tparent[y] = x;\n\t\t\t\tif(rank[x] == rank[y]){\n\t\t\t\t\trank[x]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t*/\n\t\tpublic void set_rank(int x,int y, int d){\n\t\t\tfinal int find_x = find(x);\n\t\t\tfinal int find_y = find(y);\n\t\t\t\n\t\t\tif(find_x == find_y){\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tparent[find_y] = find_x;\n\t\t\trank[find_y] = rank[x] + d - rank[y]; \n\t\t}\n\t}\n\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile (true) {\n\t\t\tfinal int N = sc.nextInt();\n\t\t\tfinal int M = sc.nextInt();\n\n\t\t\tif (N == 0 && M == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tSystem.gc();\n\t\t\t\n\t\t\tWeightUnionFind wuf = new WeightUnionFind(N);\n\t\t\t\n\t\t\tfor(int i = 0; i < M; i++){\n\t\t\t\tString op = sc.next();\n\t\t\t\t\n\t\t\t\tif(op.equals(\"!\")){\n\t\t\t\t\tfinal int from = sc.nextInt() - 1;\n\t\t\t\t\tfinal int to = sc.nextInt() - 1;\n\t\t\t\t\tfinal int w = sc.nextInt();\n\t\t\t\t\t\n\t\t\t\t\twuf.set_rank(from, to, w);\n\t\t\t\t\t//System.out.println(\"DIFF \" + from + \" \" + to + \" \" + w);\n\t\t\t\t}else{\n\t\t\t\t\tfinal int from = sc.nextInt() - 1;\n\t\t\t\t\tfinal int to = sc.nextInt() - 1;\n\t\t\t\t\t\n\t\t\t\t\tif(!wuf.same(from, to)){\n\t\t\t\t\t\tSystem.out.println(\"UNKNOWN\");\n\t\t\t\t\t}else{\n\t\t\t\t\t\tSystem.out.println(wuf.get_diff(from, to));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t//System.out.println(\"P : \" + Arrays.toString(wuf.parent));\n\t\t\t\t//System.out.println(\"D : \" + Arrays.toString(wuf.diff_weight));\n\t\t\t}\n\t\t\t\n\t\t}\n\n\t\tsc.close();\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n  \npublic class Main {\n    public static int N;\n    public static int M;\n    public static int[] p;\n    public static int[] rank;\n    public static int[] weight;\n \n    public static boolean same(int x, int y) {\n        return findSet(x) == findSet(y);\n    }\n  \n    public static void unite(int x, int y, int w) {\n        int i = findSet(x);\n        int j = findSet(y);\n        w -= weight[y] - weight[x];\n \n        if (i == j){\n        return;\n    }\n        if (rank[i] > rank[j]){\n            p[j] = i;\n            weight[j] = w;\n        } else {\n            p[i] = j;\n            weight[i] = -w;\n            if(rank[i] == rank[j]){\n        rank[j]++;\n            }\n        }   \n    }\n  \n    public static int findSet(int i) {\n    if(p[i] == i){ \n        return i;\n        }else{\n        return p[i] = findSet(p[i]);\n        }\n    }\n  \n    public static void DisjointSet() {\n        p = new int[N];\n        rank = new int[N];\n        weight = new int[N];\n  \n        for (int i = 0; i < N; i++) {\n            p[i] = i;\n            rank[i] = 0;\n            weight[i] = 0;\n        }\n    }\n  \n  \n    public static void main (String[] args){\n        Scanner scanner = new Scanner(System.in);\n        while(true){\n        N = scanner.nextInt();\n        M = scanner.nextInt();\n \n        if(N==0 |M==0){\n        break;\n        }\n  \n        DisjointSet();\n \n        for (int i = 0; i < M; i++) {\n        String c = scanner.next();\n        int a = scanner.nextInt();\n        int b = scanner.nextInt();\n        a--; b--; \n         \n        if(c.equals(\"!\")){\n            int w = scanner.nextInt();\n            unite(a, b, w);\n        }else{ \n            if(same(a,b)){\n            System.out.println(weight[b] - weight[a]);\n            }else{\n            System.out.println(\"UNKNOWN\");\n            }\n        }\n        }\n    }\n       \n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main{\n\tpublic static void main(String[] args) {\n\t\tnew Main().solver();\n\t}\n\n\tvoid solver() {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint N = sc.nextInt();\n\t\t\tint M = sc.nextInt();\n\t\t\tif (N == 0 && M == 0)\n\t\t\t\tbreak;\n\t\t\tWeightedUnionFind uf = new WeightedUnionFind(N);\n\t\t\tfor (int i = 0; i < M; i++) {\n\t\t\t\tString s = sc.next();\n\t\t\t\tint x = sc.nextInt() - 1;\n\t\t\t\tint y = sc.nextInt() - 1;\n\t\t\t\tif (s.equals(\"!\")) {\n\t\t\t\t\tint w = sc.nextInt();\n\t\t\t\t\tuf.union(x, y, w);\n\t\t\t\t} else {\n\t\t\t\t\tif (!uf.same(x, y)) {\n\t\t\t\t\t\tSystem.out.println(\"UNKNOWN\");\n\t\t\t\t\t} else {\n\t\t\t\t\t\tSystem.out.println(-uf.diff(x, y));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsc.close();\n\t}\n\n\tclass WeightedUnionFind {\n\t\tint[] par;\n\t\tint[] wd;\n\n\t\tpublic WeightedUnionFind(int n) {\n\t\t\tpar = new int[n];\n\t\t\twd = new int[n];\n\t\t\tArrays.fill(par, -1);\n\t\t}\n\n\t\tint find(int x) {\n\t\t\tif (par[x] < 0)\n\t\t\t\treturn x;\n\t\t\telse {\n\t\t\t\tfinal int parent = find(par[x]);\n\t\t\t\twd[x] += wd[par[x]];\n\t\t\t\tpar[x] = parent;\n\t\t\t\treturn parent;\n\t\t\t}\n\t\t}\n\n\t\tboolean same(int x, int y) {\n\t\t\treturn find(x) == find(y);\n\t\t}\n\n\t\tint weight(int x) {\n\t\t\tfind(x);\n\t\t\treturn wd[x];\n\t\t}\n\n\t\t// y - x = w ??? y = x + w;\n\t\tboolean union(int x, int y, int w) {\n\t\t\tif (find(x) == find(y))\n\t\t\t\treturn false;\n\t\t\telse {\n\t\t\t\tw += (weight(x) - weight(y));\n\t\t\t\tx = find(x);\n\t\t\t\ty = find(y);\n\t\t\t\tif (par[y] < par[x]) { // ???????????????????????????????????????????????????.\n\t\t\t\t\tint tmp = x;\n\t\t\t\t\tx = y;\n\t\t\t\t\ty = tmp;\n\t\t\t\t\tw = -w;\n\t\t\t\t}\n\t\t\t\tpar[y] = x;\n\t\t\t\twd[y] = w;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\t// return x-y\n\t\tint diff(int x, int y) {\n\t\t\tif (!same(x, y)) {\n\t\t\t\tthrow new AssertionError();\n\t\t\t} else {\n\t\t\t\treturn weight(x) - weight(y);\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n  \npublic class Main {\n    public static int N;\n    public static int M;\n    public static int[] p;\n    public static int[] rank;\n    public static int[] weight;\n \n    public static boolean same(int x, int y) {\n        return findSet(x) == findSet(y);\n    }\n  \n    public static void unite(int x, int y, int w) {\n        int i = findSet(x);\n        int j = findSet(y);\n       \n \n        if (i == j){\n        return;\n    }\n        if (rank[i] > rank[j]){\n            p[j] = i;\t   \n            weight[j] =  weight[x] + w;\n        } else {\n            p[i] = j;\n            weight[i] = weight[y] - w;\n            if(rank[i] == rank[j]){\n        rank[j]++;\n            }\n        }   \n    }\n  \n    public static int findSet(int i) {\n    if(p[i] == i){ \n        return i;\n        }else{\n        return p[i] = findSet(p[i]);\n        }\n    }\n  \n    public static void DisjointSet() {\n        p = new int[N];\n        rank = new int[N];\n        weight = new int[N];\n  \n        for (int i = 0; i < N; i++) {\n            p[i] = i;\n            rank[i] = 0;\n            weight[i] = 0;\n        }\n    }\n  \n  \n    public static void main (String[] args){\n        Scanner scanner = new Scanner(System.in);\n        while(true){\n        N = scanner.nextInt();\n        M = scanner.nextInt();\n \n        if(N==0 && M==0){\n        break;\n        }\n  \n        DisjointSet();\n \n        for (int i = 0; i < M; i++) {\n        String c = scanner.next();\n        int a = scanner.nextInt();\n        int b = scanner.nextInt();\n        a--; b--; \n         \n        if(c.equals(\"!\")){\n            int w = scanner.nextInt();\n            unite(a, b, w);\n        }else{ \n            if(same(a,b)){\n\t\tSystem.out.println(weight[b] - weight[a]);\n            }else{\n            System.out.println(\"UNKNOWN\");\n            }\n        }\n        }\n    }\n       \n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n \npublic class Main {\n    public static int N;\n    public static int M;\n    public static int[] p;\n    public static int[] rank;\n    public static int[] weight;\n\n    public static boolean same(int x, int y) {\n        return findSet(x) == findSet(y);\n    }\n \n    public static void unite(int x, int y, int w) {\n        int i = findSet(x);\n        int j = findSet(y);\n        w -= weight[y] - weight[x];\n\n        if (i == j){\n\t    return;\n\t}\n        if (rank[i] > rank[j]){\n            p[j] = i;\n            weight[j] = w;\n        } else {\n            p[i] = j;\n            weight[i] = -w;\n            if(rank[i] == rank[j]){\n\t\trank[j]++;\n            }\n        }\t\n    }\n \n    public static int findSet(int i) {\n\tif(p[i] == i){ \n\t    return i;\n        }else{\n\t    return p[i] = findSet(p[i]);\n        }\n    }\n \n    public static void DisjointSet() {\n        p = new int[N];\n        rank = new int[N];\n        weight = new int[N];\n \n        for (int i = 0; i < N; i++) {\n            p[i] = i;\n            rank[i] = 0;\n            weight[i] = 0;\n        }\n    }\n \n \n    public static void main (String[] args){\n        Scanner scanner = new Scanner(System.in);\n        while(true){\n\t    N = scanner.nextInt();\n\t    M = scanner.nextInt();\n\n\t    if(N==0 |M==0){\n\t\tbreak;\n\t    }\n \n\t    DisjointSet();\n\n\t    for (int i = 0; i < M; i++) {\n\t\tString c = scanner.next();\n\t\tint a = scanner.nextInt();\n\t\tint b = scanner.nextInt();\n\t\ta--; b--; \n\t\t\n\t\tif(c.equals(\"!\")){\n\t\t    int w = scanner.nextInt();\n\t\t    unite(a, b, w);\n\t\t}else{ \n\t\t    if(same(a,b)){\n\t\t\tSystem.out.println(weight[b] - weight[a]);\n\t\t    }else{\n\t\t\tSystem.out.println(\"UNKNOWN\");\n\t\t    }\n\t\t}\n\t    }\n\t}\n      \n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\n\npublic class Main {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\n\tvoid solver()\n\t{\n\t\twhile (true) {\n\t\t\tint N =ni();\n\t\t\tint M = ni();\n\t\t\tif (N == 0 && M == 0)\n\t\t\t\tbreak;\n\t\t\tWeightedUnionFind uf = new WeightedUnionFind(N);\n\t\t\tfor (int i = 0; i < M; i++) {\n\t\t\t\tString s = ns();\n\t\t\t\tint x = ni() - 1;\n\t\t\t\tint y = ni() - 1;\n\t\t\t\tif (s.equals(\"!\")) {\n\t\t\t\t\tlong w = nl();\n\t\t\t\t\tuf.union(x, y, w);\n\t\t\t\t} else {\n\t\t\t\t\tif (!uf.same(x, y)) {\n\t\t\t\t\t\tSystem.out.println(\"UNKNOWN\");\n\t\t\t\t\t} else {\n\t\t\t\t\t\tSystem.out.println(-uf.diff(x, y));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) throws Exception\n\t{\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\n\t\tnew Main().solver();\n\t\tout.flush();\n\t}\n\n\tstatic long nl()\n\t{\n\t\ttry {\n\t\t\tlong num = 0;\n\t\t\tboolean minus = false;\n\t\t\twhile((num = is.read()) != -1 && !((num >= '0' && num <= '9') || num == '-'));\n\t\t\tif(num == '-'){\n\t\t\t\tnum = 0;\n\t\t\t\tminus = true;\n\t\t\t}else{\n\t\t\t\tnum -= '0';\n\t\t\t}\n\n\t\t\twhile(true){\n\t\t\t\tint b = is.read();\n\t\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t\t}else{\n\t\t\t\t\treturn minus ? -num : num;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn -1;\n\t}\n\n\tstatic char nc()\n\t{\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tif(b == -1)return 0;\n\t\t\treturn (char)b;\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn 0;\n\t}\n\n\tstatic double nd()\n\t{\n\t\ttry {\n\t\t\treturn Double.parseDouble(ns());\n\t\t}catch(Exception e) {\n\t\t}\n\t\treturn 0;\n\t}\n\n\tstatic String ns()\n\t{\n\t\ttry{\n\t\t\tint b = skip();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tif(b == -1)return \"\";\n\t\t\tsb.append((char)b);\n\t\t\twhile(true){\n\t\t\t\tb = is.read();\n\t\t\t\tif(b == -1)return sb.toString();\n\t\t\t\tif(b <= ' ')return sb.toString();\n\t\t\t\tsb.append((char)b);\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn \"\";\n\t}\n\n\tpublic static char[] ns(int n)\n\t{\n\t\tchar[] buf = new char[n];\n\t\ttry{\n\t\t\tint b = skip(), p = 0;\n\t\t\tif(b == -1)return null;\n\t\t\tbuf[p++] = (char)b;\n\t\t\twhile(p < n){\n\t\t\t\tb = is.read();\n\t\t\t\tif(b == -1 || b <= ' ')break;\n\t\t\t\tbuf[p++] = (char)b;\n\t\t\t}\n\t\t\treturn Arrays.copyOf(buf, p);\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn null;\n\t}\n\n\tpublic static byte[] nse(int n)\n\t{\n\t\tbyte[] buf = new byte[n];\n\t\ttry{\n\t\t\tint b = skip();\n\t\t\tif(b == -1)return null;\n\t\t\tis.read(buf);\n\t\t\treturn buf;\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn null;\n\t}\n\n\tstatic int skip() throws IOException\n\t{\n\t\tint b;\n\t\twhile((b = is.read()) != -1 && !(b >= 33 && b <= 126));\n\t\treturn b;\n\t}\n\n\tstatic boolean eof()\n\t{\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\tint b = skip();\n\t\t\tis.reset();\n\t\t\treturn b == -1;\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tstatic int ni()\n\t{\n\t\ttry {\n\t\t\tint num = 0;\n\t\t\tboolean minus = false;\n\t\t\twhile((num = is.read()) != -1 && !((num >= '0' && num <= '9') || num == '-'));\n\t\t\tif(num == '-'){\n\t\t\t\tnum = 0;\n\t\t\t\tminus = true;\n\t\t\t}else{\n\t\t\t\tnum -= '0';\n\t\t\t}\n\n\t\t\twhile(true){\n\t\t\t\tint b = is.read();\n\t\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t\t}else{\n\t\t\t\t\treturn minus ? -num : num;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn -1;\n\t}\n\n\tclass WeightedUnionFind {\n\t\tint[] par;\n\t\tlong[] wd;\n\n\t\tpublic WeightedUnionFind(int n) {\n\t\t\tpar = new int[n];\n\t\t\twd = new long[n];\n\t\t\tArrays.fill(par, -1);\n\t\t}\n\n\t\tint find(int x) {\n\t\t\tif (par[x] < 0)\n\t\t\t\treturn x;\n\t\t\telse {\n\t\t\t\tfinal int parent = find(par[x]);\n\t\t\t\twd[x] += wd[par[x]];\n\t\t\t\tpar[x] = parent;\n\t\t\t\treturn parent;\n\t\t\t}\n\t\t}\n\n\t\tboolean same(int x, int y) {\n\t\t\treturn find(x) == find(y);\n\t\t}\n\n\t\tlong weight(int x) {\n\t\t\tfind(x);\n\t\t\treturn wd[x];\n\t\t}\n\n\t\t// y - x = w ??? y = x + w;\n\t\tboolean union(int x, int y, long w) {\n\t\t\tif (find(x) == find(y))\n\t\t\t\treturn false;\n\t\t\telse {\n\t\t\t\tw += (weight(x) - weight(y));\n\t\t\t\tx = find(x);\n\t\t\t\ty = find(y);\n\t\t\t\tif (par[y] < par[x]) { // ???????????????????????????????????????????????????.\n\t\t\t\t\tint tmp = x;\n\t\t\t\t\tx = y;\n\t\t\t\t\ty = tmp;\n\t\t\t\t\tw = -w;\n\t\t\t\t}\n\t\t\t\tpar[y] = x;\n\t\t\t\twd[y] = w;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\t// return x-y\n\t\tlong diff(int x, int y) {\n\t\t\tif (!same(x, y)) {\n\t\t\t\tthrow new AssertionError();\n\t\t\t} else {\n\t\t\t\treturn this.weight(x) - this.weight(y);\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.Reader;\nimport java.util.Arrays;\nimport java.util.Scanner;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\n\tpublic static class WeightedUnionFind{\n\t    int[] par; // 親の番号\n\t    int[] ws;  // 親との重みの差\n\t    \n\t    public WeightedUnionFind(int n){\n\t        par = new int[n];\n\t        ws  = new int[n];\n\t        for(int i = 0; i < n; i++){ \n\t        \tpar[i] = -1;\n\t        }\n\t    }\n\t    \n\t    public int find(int x){\n\t    \tif(par[x] < 0){\n\t    \t\treturn x;\n\t    \t}else{\n\t    \t\tfinal int parent = find(par[x]);\n\t    \t\tws[x] += ws[par[x]];\n\t    \t\tpar[x] = parent;\n\t    \t\treturn parent;\n\t    \t}\n\t    }\n\t    \n\t    public int weight(int x){\n\t    \treturn ws[x];\n\t    }\n\t    \n\t    public boolean union(int x, int y, int w){ // x <-(w)- y (x + w = y)\n\t    \tfind(x); find(y);\n\t    \tw += weight(x);\n\t    \tw -= weight(y);\n\t        x = find(x);\n\t        y = find(y);\n\t        \n\t        if(x != y){\n\t            if(par[y] < par[x]) {  // 多い方が根になるようにスワップする.\n\t                int tmp = x; x = y; y = tmp;\n\t                w = -w;\n\t            }\n\t            par[x] += par[y];\n\t            par[y] = x;\n\t            ws[y] = w;\n\t            \n\t            return true;\n\t        }else{\n\t            return false;\n\t        }\n\t    }\n\t    \n\t    public boolean same(int x, int y){\n\t        return find(x) == find(y);\n\t    }\n\t    \n\t    public Integer diff(int x, int y){ // x - y を求める. 比較不能ならnull.\n\t    \tif(!same(x, y)){\n\t    \t\treturn null;\n\t    \t}else{\n\t    \t\treturn this.weight(x) - this.weight(y);\n\t    \t}\n\t    }\n\t    \n\t    public int size(int x){\n\t        return -par[find(x)];\n\t    }\n\t}\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tScanner sc = new Scanner(System.in);\n\n\t\twhile(true){\n\t\t\tfinal int n = sc.nextInt();\n\t\t\tfinal int m = sc.nextInt();\n\t\t\t\n\t\t\tif(n == 0 && m == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tWeightedUnionFind uf = new WeightedUnionFind(n);\n\t\t\t\n\t\t\tfor(int i = 0; i < m; i++){\n\t\t\t\tfinal String ops = sc.next();\n\t\t\t\t\n\t\t\t\tif(\"?\".equals(ops)){\n\t\t\t\t\tfinal int r = sc.nextInt() - 1;\n\t\t\t\t\tfinal int l = sc.nextInt() - 1;\n\t\t\t\t\t\n\t\t\t\t\tif(!uf.same(r, l)){\n\t\t\t\t\t\tSystem.out.println(\"UNKNOWN\");\n\t\t\t\t\t}else{\n\t\t\t\t\t\tSystem.out.println(uf.weight(l) - uf.weight(r));\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tfinal int r = sc.nextInt() - 1;\n\t\t\t\t\tfinal int l = sc.nextInt() - 1;\n\t\t\t\t\tfinal int w = sc.nextInt();\n\t\t\t\t\t\n\t\t\t\t\tuf.union(r, l, w);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tsc.close();\n\t}\n\t\n\tpublic static class Scanner {\n\t    private BufferedReader br;\n\t    private StringTokenizer tok;\n\n\t    public Scanner(InputStream is) throws IOException {\n\t        br = new BufferedReader(new InputStreamReader(is));\n\t    }\n\n\t    private void getLine() throws IOException {\n\t        while (!hasNext()) { tok = new StringTokenizer(br.readLine()); }\n\t    }\n\n\t    private boolean hasNext() {\n\t        return tok != null && tok.hasMoreTokens();\n\t    }\n\n\t    public String next() throws IOException {\n\t        getLine(); return tok.nextToken();\n\t    }\n\n\t    public int nextInt() throws IOException {\n\t        return Integer.parseInt(next());\n\t    }\n\t    // 他のnextXXXもXXX.parseXXX()メソッドを使って作れるので省略\n\t    \n\t    public void close() throws IOException {\n\t        br.close();\n\t    }\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n \npublic class Main {\n    public static int N;\n    public static int M;\n    public static int[] p;\n    public static int[] rank;\n    public static int[] w;\n \n    public static boolean same(int x, int y) {\n        return findSet(x) == findSet(y);\n    }\n \n    public static void unite(int a, int b, int w) {\n        int i = findSet(a);\n        int j = findSet(b);\n\tw -= w[b] - w[a];\n\t\n        if (i == j){\n\t    return;\n\t}\n        if (rank[i] > rank[j]){\n            p[j] = p[i];\n\t    w[j] = w;\n        } else {\n            p[i] = p[j];\n\t    w[x] = -w;\n            if(rank[i] == rank[j]){\n            rank[j]++;\n            }\n        }\t\n    }\n \n    public static int findSet(int i) {\n       if(p[i] == i){ \n           return i;\n        }else{\n          return p[i] = findSet(p[i]);\n        }\n    }\n \n    public static void DisjointSet() {\n        p = new int[N];\n        rank = new int[N];\n\tw = new int[N];\n \n        for (int i = 0; i < N; i++) {\n            p[i] = i;\n            rank[i] = 0;\n\t    w[i] = 0;\n        }\n    }\n \n \n    public static void main (String[] args){\n        Scanner scanner = new Scanner(System.in);\n\twhile(true){   \n        N = scanner.nextInt();\n        M = scanner.nextInt();\n\tif(N==0 & M == 0) break;\n\n        DisjointSet();\n\tSolve();\n\t}\n    }\n    \n    public static void Solve(){\n        for (int i = 0; i < M; i++) {\n\t    if(scanner.next().equals(\"!\")){\n\t\tint a = scanner.nextInt();\n\t\tint b = scanner.nextInt();\n\t\tint w = scanner.nextInt();\n\t\t\n\t\ta--;\n\t\tb--;\n\t\tunite(a, b, w);\n\t    }else{\n\t        if(!same(a,b)){\n\t\t    System.out.println(\"UNKNOWN\");\n\t\t}else{\n\t\t    System.out.println(w[b]-w[a]);\n\t\t}\n\t    }\n\t}\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n \npublic class Main {\n    public static int N;\n    public static int M;\n    public static int[] p;\n    public static int[] rank;\n    public static int[] w;\n \n    public static boolean same(int a, int b) {\n        return findSet(a) == findSet(b);\n    }\n \n    public static void unite(int a, int b, int k) {\n        int i = findSet(a);\n        int j = findSet(b);\n\tk -= w[b] - w[a];\n\t\n        if (i == j){\n\t    return;\n\t}\n        if (rank[i] > rank[j]){\n            p[j] = p[i];\n\t    w[j] = k;\n        } else {\n            p[i] = p[j];\n\t    w[i] = -k;\n            if(rank[i] == rank[j]){\n            rank[j]++;\n            }\n        }\t\n    }\n \n    public static int findSet(int i) {\n       if(p[i] == i){ \n           return i;\n        }else{\n          return p[i] = findSet(p[i]);\n        }\n    }\n \n    public static void DisjointSet() {\n        p = new int[N];\n        rank = new int[N];\n\tw = new int[N];\n \n        for (int i = 0; i < N; i++) {\n            p[i] = i;\n            rank[i] = 0;\n\t    w[i] = 0;\n        }\n    }\n    \n    public static void main (String[] args){\n        Scanner scanner = new Scanner(System.in);\n\twhile(true){   \n\t    N = scanner.nextInt();\n\t    DisjointSet();\n\t    M = scanner.nextInt();\n\t    if(N==0 & M == 0) break;\n\t    \n\t    for (int i = 0; i < M; i++) {\n\t\tif(scanner.next().equals(\"!\")){\n\t\t    int a = scanner.nextInt();\n\t\t    int b = scanner.nextInt();\n\t\t    int w = scanner.nextInt();\n\t\t    \n\t\t    a--;\n\t\t    b--;\n\t\t    unite(a, b, w);\n\t\t}else{\n\t\t    if(same(a,b)==false){\n\t\t\tSystem.out.println(\"UNKNOWN\");\n\t\t    }else{\n\t\t\tSystem.out.println(w[b]-w[a]);\n\t\t    }\n\t\t}\n\t    }\n\t}\t\n    }\n}\n \n    public static int findSet(int i) {\n       if(p[i] == i){ \n           return i;\n        }else{\n          return p[i] = findSet(p[i]);\n        }\n    }\n \n    public static void DisjointSet() {\n        p = new int[N];\n        rank = new int[N];\n\tw = new int[N];\n \n        for (int i = 0; i < N; i++) {\n            p[i] = i;\n            rank[i] = 0;\n\t    w[i] = 0;\n        }\n    }\n    \n    public static void main (String[] args){\n        Scanner scanner = new Scanner(System.in);\n\twhile(true){   \n\t    N = scanner.nextInt();\n\t    DisjointSet();\n\t    M = scanner.nextInt();\n\t    if(N==0 & M == 0) break;\n\t    \n\t    for (int i = 0; i < M; i++) {\n\t\tif(scanner.next().equals(\"!\")){\n\t\t    int a = scanner.nextInt();\n\t\t    int b = scanner.nextInt();\n\t\t    int w = scanner.nextInt();\n\t\t    \n\t\t    a--;\n\t\t    b--;\n\t\t    unite(a, b, w);\n\t\t}else{\n\t\t    if(same(a,b)==false){\n\t\t\tSystem.out.println(\"UNKNOWN\");\n\t\t    }else{\n\t\t\tSystem.out.println(w[b]-w[a]);\n\t\t    }\n\t\t}\n\t    }\n\t}\t\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n \npublic class Main {\n    public static int N;\n    public static int M;\n    public static int[] p;\n    public static int[] rank;\n    public static int[] weight;\n\n    public static boolean same(int x, int y) {\n        return findSet(x) == findSet(y);\n    }\n \n    public static void unite(int x, int y, int w) {\n        int i = findSet(x);\n        int j = findSet(y);\n        w -= weight[j] - weight[i];\n\n        if (i == j){\n\t    return;\n\t}\n        if (rank[i] > rank[j]){\n            p[j] = p[i];\n            weight[j] = w;\n        } else {\n            p[i] = p[j];\n            weight[i] = -w;\n            if(rank[i] == rank[j]){\n            rank[j]++;\n            }\n        }\t\n    }\n \n    public static int findSet(int i) {\n       if(p[i] == i){ \n           return i;\n        }else{\n          return p[i] = findSet(p[i]);\n        }\n    }\n \n    public static void DisjointSet() {\n        p = new int[N];\n        rank = new int[N];\n        weight = new int[N];\n \n        for (int i = 0; i < N; i++) {\n            p[i] = i;\n            rank[i] = 0;\n            weight[i] = 0;\n        }\n    }\n \n \n    public static void main (String[] args){\n        Scanner scanner = new Scanner(System.in);\n        while(true){\n        N = scanner.nextInt();\n        M = scanner.nextInt();\n\n        if(N==0 & M==0){\n           break;\n        }\n \n        DisjointSet();\n\n        for (int i = 0; i < M; i++) {\n            if(scanner.next().equals(\"!\")){\n            int a = scanner.nextInt();\n            int b = scanner.nextInt();\n            int w = scanner.nextInt();\n \n            a--; b--;   \n            unite(a, b, w);\n            }else{\n               if(same(a, b)){\n                    System.out.println(weight[b]-weight[a]);\n                }else{\n                    System.out.println(\"UNKNOWN\");\n\t\t}\n            }\n        }\n       }\n      \n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\n\npublic class Main {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\n\tvoid solver()\n\t{\n\t\twhile (true) {\n\t\t\tint N =ni();\n\t\t\tint M = ni();\n\t\t\tif (N == 0 && M == 0)\n\t\t\t\tbreak;\n\t\t\tWeightedUnionFind uf = new WeightedUnionFind(N);\n\t\t\tfor (int i = 0; i < M; i++) {\n\t\t\t\tString s = ns();\n\t\t\t\tint x = ni() - 1;\n\t\t\t\tint y = ni() - 1;\n\t\t\t\tif (s.equals(\"!\")) {\n\t\t\t\t\tlong w = nl();\n\t\t\t\t\tuf.union(x, y, w);\n\t\t\t\t} else {\n\t\t\t\t\tif (!uf.same(x, y)) {\n\t\t\t\t\t\tSystem.out.println(\"UNKNOWN\");\n\t\t\t\t\t} else {\n\t\t\t\t\t\tSystem.out.println(-uf.diff(x, y));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) throws Exception\n\t{\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\n\t\tnew Main().solver();\n\t\tout.flush();\n\t}\n\n\tstatic long nl()\n\t{\n\t\ttry {\n\t\t\tlong num = 0;\n\t\t\tboolean minus = false;\n\t\t\twhile((num = is.read()) != -1 && !((num >= '0' && num <= '9') || num == '-'));\n\t\t\tif(num == '-'){\n\t\t\t\tnum = 0;\n\t\t\t\tminus = true;\n\t\t\t}else{\n\t\t\t\tnum -= '0';\n\t\t\t}\n\n\t\t\twhile(true){\n\t\t\t\tint b = is.read();\n\t\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t\t}else{\n\t\t\t\t\treturn minus ? -num : num;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn -1;\n\t}\n\n\tstatic char nc()\n\t{\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tif(b == -1)return 0;\n\t\t\treturn (char)b;\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn 0;\n\t}\n\n\tstatic double nd()\n\t{\n\t\ttry {\n\t\t\treturn Double.parseDouble(ns());\n\t\t}catch(Exception e) {\n\t\t}\n\t\treturn 0;\n\t}\n\n\tstatic String ns()\n\t{\n\t\ttry{\n\t\t\tint b = skip();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tif(b == -1)return \"\";\n\t\t\tsb.append((char)b);\n\t\t\twhile(true){\n\t\t\t\tb = is.read();\n\t\t\t\tif(b == -1)return sb.toString();\n\t\t\t\tif(b <= ' ')return sb.toString();\n\t\t\t\tsb.append((char)b);\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn \"\";\n\t}\n\n\tpublic static char[] ns(int n)\n\t{\n\t\tchar[] buf = new char[n];\n\t\ttry{\n\t\t\tint b = skip(), p = 0;\n\t\t\tif(b == -1)return null;\n\t\t\tbuf[p++] = (char)b;\n\t\t\twhile(p < n){\n\t\t\t\tb = is.read();\n\t\t\t\tif(b == -1 || b <= ' ')break;\n\t\t\t\tbuf[p++] = (char)b;\n\t\t\t}\n\t\t\treturn Arrays.copyOf(buf, p);\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn null;\n\t}\n\n\tpublic static byte[] nse(int n)\n\t{\n\t\tbyte[] buf = new byte[n];\n\t\ttry{\n\t\t\tint b = skip();\n\t\t\tif(b == -1)return null;\n\t\t\tis.read(buf);\n\t\t\treturn buf;\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn null;\n\t}\n\n\tstatic int skip() throws IOException\n\t{\n\t\tint b;\n\t\twhile((b = is.read()) != -1 && !(b >= 33 && b <= 126));\n\t\treturn b;\n\t}\n\n\tstatic boolean eof()\n\t{\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\tint b = skip();\n\t\t\tis.reset();\n\t\t\treturn b == -1;\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tstatic int ni()\n\t{\n\t\ttry {\n\t\t\tint num = 0;\n\t\t\tboolean minus = false;\n\t\t\twhile((num = is.read()) != -1 && !((num >= '0' && num <= '9') || num == '-'));\n\t\t\tif(num == '-'){\n\t\t\t\tnum = 0;\n\t\t\t\tminus = true;\n\t\t\t}else{\n\t\t\t\tnum -= '0';\n\t\t\t}\n\n\t\t\twhile(true){\n\t\t\t\tint b = is.read();\n\t\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t\t}else{\n\t\t\t\t\treturn minus ? -num : num;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn -1;\n\t}\n\n\tclass WeightedUnionFind {\n\t\tint[] par;\n\t\tlong[] wd;\n\n\t\tpublic WeightedUnionFind(int n) {\n\t\t\tpar = new int[n];\n\t\t\twd = new long[n];\n\t\t\tArrays.fill(par, -1);\n\t\t}\n\n\t\tint find(int x) {\n\t\t\tif (par[x] < 0)\n\t\t\t\treturn x;\n\t\t\telse {\n\t\t\t\tfinal int parent = find(par[x]);\n\t\t\t\twd[x] += wd[par[x]];\n\t\t\t\tpar[x] = parent;\n\t\t\t\treturn parent;\n\t\t\t}\n\t\t}\n\n\t\tboolean same(int x, int y) {\n\t\t\treturn find(x) == find(y);\n\t\t}\n\n\t\tlong weight(int x) {\n\t\t\tfind(x);\n\t\t\treturn wd[x];\n\t\t}\n\n\t\t// y - x = w ??? y = x + w;\n\t\tboolean union(int x, int y, long w) {\n\t\t\tif (find(x) == find(y))\n\t\t\t\treturn false;\n\t\t\telse {\n\t\t\t\tw += (weight(x) - weight(y));\n\t\t\t\tx = find(x);\n\t\t\t\ty = find(y);\n\t\t\t\tif (par[y] < par[x]) { // ???????????????????????????????????????????????????.\n\t\t\t\t\tint tmp = x;\n\t\t\t\t\tx = y;\n\t\t\t\t\ty = tmp;\n\t\t\t\t\tw = -w;\n\t\t\t\t}\n\t\t\t\tpar[y] = x;\n\t\t\t\twd[y] = w;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\t// return x-y\n\t\tlong diff(int x, int y) {\n\t\t\tif (!same(x, y)) {\n\t\t\t\tthrow new AssertionError();\n\t\t\t} else {\n\t\t\t\treturn this.weight(x) - this.weight(y);\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n \npublic class Main {\n    public static int N;\n    public static int M;\n    public static int[] p;\n    public static int[] rank;\n    public static int[] w;\n \n    public static boolean same(int x, int y) {\n        return findSet(x) == findSet(y);\n    }\n \n    public static void unite(int a, int b, int k) {\n        int i = findSet(a);\n        int j = findSet(b);\n\t\n        if (i == j){\n\t    return;\n\t}\n        if (rank[i] > rank[j]){\n            p[j] = p[i];\n\t    w[j] = k;\n        } else {\n            p[i] = p[j];\n\t    w[i] = -k;\n            if(rank[i] == rank[j]){\n            rank[j]++;\n            }\n        }\t\n    }\n \n    public static int findSet(int i) {\n       if(p[i] == i){ \n           return i;\n        }else{\n          return p[i] = findSet(p[i]);\n        }\n    }\n \n    public static void DisjointSet() {\n        p = new int[N];\n        rank = new int[N];\n\tw = new int[N];\n \n        for (int i = 0; i < N; i++) {\n            p[i] = i;\n            rank[i] = 0;\n\t    w[i] = 0;\n        }\n    }\n    \n    public static void main (String[] args){\n        Scanner scanner = new Scanner(System.in);\n\twhile(true){   \n\t    N = scanner.nextInt();\n\t    DisjointSet();\n\t    M = scanner.nextInt();\n\t    if(N==0 & M == 0) break;\n\t    \n\t    for (int i = 0; i < M; i++) {\n\t\tif(scanner.next().equals(\"!\")){\n\t\t    int a = scanner.nextInt();\n\t\t    int b = scanner.nextInt();\n\t\t    int w = scanner.nextInt();\n\t\t    \n\t\t    a--;\n\t\t    b--;\n\t\t    unite(a, b, w);\n\t\t}else{\n\t\t    if(same(a,b)==false){\n\t\t\tSystem.out.println(\"UNKNOWN\");\n\t\t    }else{\n\t\t\tSystem.out.println(w[b]-w[a]);\n\t\t    }\n\t\t}\n\t    }\n\t}\t\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n \npublic class Main {\n    public static int N;\n    public static int M;\n    public static int[] p;\n    public static int[] rank;\n    public static int[] w;\n \n    public static boolean same(int x, int y) {\n        return findSet(x) == findSet(y);\n    }\n \n    public static void unite(int a, int b, int w) {\n        int i = findSet(a);\n        int j = findSet(b);\n\tw -= w[b] - w[a];\n\t\n        if (i == j){\n\t    return;\n\t}\n        if (rank[i] > rank[j]){\n            p[j] = p[i];\n\t    w[j] = w;\n        } else {\n            p[i] = p[j];\n\t    w[i] = -w;\n            if(rank[i] == rank[j]){\n            rank[j]++;\n            }\n        }\t\n    }\n \n    public static int findSet(int i) {\n       if(p[i] == i){ \n           return i;\n        }else{\n          return p[i] = findSet(p[i]);\n        }\n    }\n \n    public static void DisjointSet() {\n        p = new int[N];\n        rank = new int[N];\n\tw = new int[N];\n \n        for (int i = 0; i < N; i++) {\n            p[i] = i;\n            rank[i] = 0;\n\t    w[i] = 0;\n        }\n    }\n    \n    public static void main (String[] args){\n        Scanner scanner = new Scanner(System.in);\n\twhile(true){   \n\t    N = scanner.nextInt();\n\t    DisjointSet();\n\t    M = scanner.nextInt();\n\t    if(N==0 & M == 0) break;\n\t    \n\t    for (int i = 0; i < M; i++) {\n\t\tif(scanner.next().equals(\"!\")){\n\t\t    int a = scanner.nextInt();\n\t\t    int b = scanner.nextInt();\n\t\t    int w = scanner.nextInt();\n\t\t    \n\t\t    a--;\n\t\t    b--;\n\t\t    unite(a, b, w);\n\t\t}else{\n\t\t    if(same(a,b)==false){\n\t\t\tSystem.out.println(\"UNKNOWN\");\n\t\t    }else{\n\t\t\tSystem.out.println(w[b]-w[a]);\n\t\t    }\n\t\t}\n\t    }\n\t}\t\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.io.Reader;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\n\npublic class Main {\n\tstatic FastScanner sc = new FastScanner(System.in);\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tint[] A = new int[100000];\n\t\tint[] B = new int[100000];\n\t\tint[] W = new int[100000];\n\t\tboolean[] type = new boolean[100000];\n\t\tint[] dist = new int[100000];\n\t\tArrayList<ArrayList<Edge>> graph = new ArrayList<ArrayList<Edge>>();\n\t\tfor (int i = 0; i < 100000; ++i) {\n\t\t\tgraph.add(new ArrayList<Edge>());\n\t\t}\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\twhile (true) {\n\t\t\tint N = sc.nextInt();\n\t\t\tint M = sc.nextInt();\n\t\t\tif (N == 0 || M == 0) break;\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tgraph.get(i).clear();\n\t\t\t}\n\t\t\tfor (int i = 0; i < M; ++i) {\n\t\t\t\ttype[i] = sc.nextChar() == '!';\n\t\t\t\tA[i] = sc.nextInt() - 1;\n\t\t\t\tB[i] = sc.nextInt() - 1;\n\t\t\t\tif (type[i]) {\n\t\t\t\t\tW[i] = sc.nextInt();\n\t\t\t\t\tgraph.get(A[i]).add(new Edge(B[i], W[i]));\n\t\t\t\t\tgraph.get(B[i]).add(new Edge(A[i], -W[i]));\n\t\t\t\t}\n\t\t\t}\n\t\t\tArrays.fill(dist, Integer.MIN_VALUE);\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tif (dist[i] != Integer.MIN_VALUE) continue;\n\t\t\t\tArrayDeque<Integer> q = new ArrayDeque<Integer>();\n\t\t\t\tq.add(i);\n\t\t\t\tdist[i] = 0;\n\t\t\t\twhile (!q.isEmpty()) {\n\t\t\t\t\tint cur = q.poll();\n\t\t\t\t\tfor (Edge e : graph.get(cur)) {\n\t\t\t\t\t\tint next = e.to;\n\t\t\t\t\t\tif (dist[next] != Integer.MIN_VALUE) continue;\n\t\t\t\t\t\tdist[next] = dist[cur] + e.w;\n\t\t\t\t\t\tq.add(next);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n//\t\t\tUnionFind uf = new UnionFind(100000);\n//\t\t\tfor (int i = 0; i < M; ++i) {\n//\t\t\t\tif (type[i]) {\n//\t\t\t\t\tuf.union(A[i], B[i]);\n//\t\t\t\t} else {\n//\t\t\t\t\tif (!uf.find(A[i], B[i])) {\n//\t\t\t\t\t\tout.println(\"UNKNOWN\");\n//\t\t\t\t\t} else {\n//\t\t\t\t\t\tout.println(dist[B[i]] - dist[A[i]]);\n//\t\t\t\t\t}\n//\t\t\t\t}\n//\t\t\t}\n\t\t}\n\t}\n\n\tstatic class Edge {\n\t\tint to, w;\n\n\t\tEdge(int to, int w) {\n\t\t\tthis.to = to;\n\t\t\tthis.w = w;\n\t\t}\n\t}\n\n\tstatic class UnionFind {\n\t\tint[] set;\n\n\t\tUnionFind(int n) {\n\t\t\tset = new int[n];\n\t\t\tArrays.fill(set, -1);\n\t\t}\n\n\t\tvoid union(int a, int b) {\n\t\t\tint rtA = root(a);\n\t\t\tint rtb = root(b);\n\t\t\tif (rtA == rtb) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tset[rtA] += set[rtb];\n\t\t\tset[rtb] = rtA;\n\t\t}\n\n\t\tboolean find(int a, int b) {\n\t\t\treturn root(a) == root(b);\n\t\t}\n\n\t\tint root(int a) {\n\t\t\tif (set[a] < 0) {\n\t\t\t\treturn a;\n\t\t\t} else {\n\t\t\t\tset[a] = root(set[a]);\n\t\t\t\treturn set[a];\n\t\t\t}\n\t\t}\n\n\t\tint size(int a) {\n\t\t\treturn -set[root(a)];\n\t\t}\n\t}\n\n\tstatic class FastScanner {\n\t\tReader input;\n\n\t\tFastScanner() {\n\t\t\tthis(System.in);\n\t\t}\n\n\t\tFastScanner(InputStream stream) {\n\t\t\tthis.input = new BufferedReader(new InputStreamReader(stream));\n\t\t}\n\n\t\tint nextInt() throws IOException {\n\t\t\tint sign = 1;\n\t\t\tint b = input.read();\n\t\t\twhile ((b < '0' || '9' < b) && b != '-' && b != '+') {\n\t\t\t\tif (b == -1) return 0;\n\t\t\t\tb = input.read();\n\t\t\t}\n\t\t\tif (b == '-') {\n\t\t\t\tsign = -1;\n\t\t\t\tb = input.read();\n\t\t\t} else if (b == '+') {\n\t\t\t\tb = input.read();\n\t\t\t}\n\t\t\tint ret = b - '0';\n\t\t\twhile (true) {\n\t\t\t\tb = input.read();\n\t\t\t\tif (b < '0' || '9' < b) return ret * sign;\n\t\t\t\tret *= 10;\n\t\t\t\tret += b - '0';\n\t\t\t}\n\t\t}\n\n\t\tchar nextChar() throws IOException {\n\t\t\tint b = input.read();\n\t\t\twhile (Character.isWhitespace((char) b)) {\n\t\t\t\tb = input.read();\n\t\t\t}\n\t\t\treturn (char) b;\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\n\npublic class Main {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\n\tvoid solver()\n\t{\n\t\twhile (true) {\n\t\t\tint N =ni();\n\t\t\tint M = ni();\n\t\t\tif (N == 0 && M == 0)\n\t\t\t\tbreak;\n\t\t\tWeightedUnionFind uf = new WeightedUnionFind(N);\n\t\t\tfor (int i = 0; i < M; i++) {\n\t\t\t\tString s = ns();\n\t\t\t\tint x = ni() - 1;\n\t\t\t\tint y = ni() - 1;\n\t\t\t\tif (s.equals(\"!\")) {\n\t\t\t\t\tlong w = nl();\n\t\t\t\t\tuf.union(x, y, w);\n\t\t\t\t} else {\n\t\t\t\t\tif (!uf.same(x, y)) {\n\t\t\t\t\t\tSystem.out.println(\"UNKNOWN\");\n\t\t\t\t\t} else {\n\t\t\t\t\t\tSystem.out.println(-uf.diff(x, y));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) throws Exception\n\t{\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\n\t\tnew Main().solver();\n\t\tout.flush();\n\t}\n\n\tstatic long nl()\n\t{\n\t\ttry {\n\t\t\tlong num = 0;\n\t\t\tboolean minus = false;\n\t\t\twhile((num = is.read()) != -1 && !((num >= '0' && num <= '9') || num == '-'));\n\t\t\tif(num == '-'){\n\t\t\t\tnum = 0;\n\t\t\t\tminus = true;\n\t\t\t}else{\n\t\t\t\tnum -= '0';\n\t\t\t}\n\n\t\t\twhile(true){\n\t\t\t\tint b = is.read();\n\t\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t\t}else{\n\t\t\t\t\treturn minus ? -num : num;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn -1;\n\t}\n\n\tstatic char nc()\n\t{\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tif(b == -1)return 0;\n\t\t\treturn (char)b;\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn 0;\n\t}\n\n\tstatic double nd()\n\t{\n\t\ttry {\n\t\t\treturn Double.parseDouble(ns());\n\t\t}catch(Exception e) {\n\t\t}\n\t\treturn 0;\n\t}\n\n\tstatic String ns()\n\t{\n\t\ttry{\n\t\t\tint b = skip();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tif(b == -1)return \"\";\n\t\t\tsb.append((char)b);\n\t\t\twhile(true){\n\t\t\t\tb = is.read();\n\t\t\t\tif(b == -1)return sb.toString();\n\t\t\t\tif(b <= ' ')return sb.toString();\n\t\t\t\tsb.append((char)b);\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn \"\";\n\t}\n\n\tpublic static char[] ns(int n)\n\t{\n\t\tchar[] buf = new char[n];\n\t\ttry{\n\t\t\tint b = skip(), p = 0;\n\t\t\tif(b == -1)return null;\n\t\t\tbuf[p++] = (char)b;\n\t\t\twhile(p < n){\n\t\t\t\tb = is.read();\n\t\t\t\tif(b == -1 || b <= ' ')break;\n\t\t\t\tbuf[p++] = (char)b;\n\t\t\t}\n\t\t\treturn Arrays.copyOf(buf, p);\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn null;\n\t}\n\n\tpublic static byte[] nse(int n)\n\t{\n\t\tbyte[] buf = new byte[n];\n\t\ttry{\n\t\t\tint b = skip();\n\t\t\tif(b == -1)return null;\n\t\t\tis.read(buf);\n\t\t\treturn buf;\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn null;\n\t}\n\n\tstatic int skip() throws IOException\n\t{\n\t\tint b;\n\t\twhile((b = is.read()) != -1 && !(b >= 33 && b <= 126));\n\t\treturn b;\n\t}\n\n\tstatic boolean eof()\n\t{\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\tint b = skip();\n\t\t\tis.reset();\n\t\t\treturn b == -1;\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tstatic int ni()\n\t{\n\t\ttry {\n\t\t\tint num = 0;\n\t\t\tboolean minus = false;\n\t\t\twhile((num = is.read()) != -1 && !((num >= '0' && num <= '9') || num == '-'));\n\t\t\tif(num == '-'){\n\t\t\t\tnum = 0;\n\t\t\t\tminus = true;\n\t\t\t}else{\n\t\t\t\tnum -= '0';\n\t\t\t}\n\n\t\t\twhile(true){\n\t\t\t\tint b = is.read();\n\t\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t\t}else{\n\t\t\t\t\treturn minus ? -num : num;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn -1;\n\t}\n\n\tclass WeightedUnionFind {\n\t\tint[] par;\n\t\tlong[] wd;\n\n\t\tpublic WeightedUnionFind(int n) {\n\t\t\tpar = new int[n];\n\t\t\twd = new long[n];\n\t\t\tArrays.fill(par, -1);\n\t\t}\n\n\t\tint find(int x) {\n\t\t\tif (par[x] < 0)\n\t\t\t\treturn x;\n\t\t\telse {\n\t\t\t\tfinal int parent = find(par[x]);\n\t\t\t\twd[x] += wd[par[x]];\n\t\t\t\tpar[x] = parent;\n\t\t\t\treturn parent;\n\t\t\t}\n\t\t}\n\n\t\tboolean same(int x, int y) {\n\t\t\treturn find(x) == find(y);\n\t\t}\n\n\t\tlong weight(int x) {\n\t\t\tfind(x);\n\t\t\treturn wd[x];\n\t\t}\n\n\t\t// y - x = w ??? y = x + w;\n\t\tboolean union(int x, int y, long w) {\n\t\t\tif (find(x) == find(y))\n\t\t\t\treturn false;\n\t\t\telse {\n\t\t\t\tw += (weight(x) - weight(y));\n\t\t\t\tx = find(x);\n\t\t\t\ty = find(y);\n\t\t\t\tif (par[y] < par[x]) { // ???????????????????????????????????????????????????.\n\t\t\t\t\tint tmp = x;\n\t\t\t\t\tx = y;\n\t\t\t\t\ty = tmp;\n\t\t\t\t\tw = -w;\n\t\t\t\t}\n\t\t\t\tpar[y] = x;\n\t\t\t\twd[y] = w;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\t// return x-y\n\t\tlong diff(int x, int y) {\n\t\t\tif (!same(x, y)) {\n\t\t\t\tthrow new AssertionError();\n\t\t\t} else {\n\t\t\t\treturn this.weight(x) - this.weight(y);\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\n@SuppressWarnings(\"unchecked\")\n    class Main{\n        \n        int n, m;\n        int INF = Integer.MAX_VALUE/2;\n        HashSet[] list;\n        long mod = 10000000;        \n\n        void solve(){\n            Scanner sc = new Scanner(System.in);\n            while(true){\n                n = sc.nextInt(); m = sc.nextInt();\n                if(n==0 && m==0) break;\n \n                list = new HashSet[n+1];\n                for(int i=0; i<=n; i++) list[i] = new HashSet<Long>();\n                for(int i=0; i<m; i++){\n                    char command = sc.next().charAt(0);\n                    if(command=='!'){\n                        long a = sc.nextLong(), b = sc.nextLong(), w = sc.nextLong();\n                        list[(int)a].add(b * mod + w);\n                        list[(int)b].add(-(a * mod + w));\n                    }else{\n                        int b = dijkstra(sc.nextInt(), sc.nextInt());\n                        if(b==INF) System.out.println(\"UNKNOWN\");\n                        else System.out.println(b);\n                    }\n                }\n            }\n        }\n        \n        int dijkstra(int start, int goal){\n            //pos, cost\n            LinkedList<int[]> q = new LinkedList<int[]>();\n            q.add(new int[]{start, 0});\n            boolean[] v = new boolean[n+1];\n \n            while(q.size()>0){\n                int[] qq = q.poll();\n                int pos = qq[0], cost = qq[1];\n \n                if(pos==goal) return cost;\n                if(v[pos]) continue;\n                v[pos] = true;\n\n                for(Iterator i=list[pos].iterator(); i.hasNext();){\n                    //P p = (P)i.next();\n                    long X = (long)i.next();\n                    int to = 0, weight = 0;\n                    if(X<0){\n                        X = -X;\n                        to = (int)(X / mod); weight = (int)-(X % mod);\n                    }else{\n                        to = (int)(X / mod); weight = (int)(X % mod);\n                    }\n                    q.add(new int[]{to, cost+weight});\n                }\n                /*\n                for(int i=0; i<list[pos].size(); i++){\n                    P p = (P)list[pos].get(i);\n                    q.add(new int[]{p.to, cost+p.weight});\n                }\n                */\n            }\n            return INF;\n        }\n \n        public static void main(String[] args){\n            new Main().solve();\n        }\n    }"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n \npublic class Main {\n    public static int N;\n    public static int M;\n    public static int[] p;\n    public static int[] rank;\n    public static int[] weight;\n\n    public static boolean same(int x, int y) {\n        return findSet(x) == findSet(y);\n    }\n \n    public static void unite(int x, int y, int w) {\n        int i = findSet(x);\n        int j = findSet(y);\n        w -= weight[j] - weight[i];\n\n        if (i == j){\n\t    return;\n\t}\n        if (rank[i] > rank[j]){\n            p[j] = p[i];\n            weight[j] = w;\n        } else {\n            p[i] = p[j];\n            weight[i] = -w;\n            if(rank[i] == rank[j]){\n            rank[j]++;\n            }\n        }\t\n    }\n \n    public static int findSet(int i) {\n       if(p[i] == i){ \n           return i;\n        }else{\n          return p[i] = findSet(p[i]);\n        }\n    }\n \n    public static void DisjointSet() {\n        p = new int[N];\n        rank = new int[N];\n        weight = new int[N];\n \n        for (int i = 0; i < N; i++) {\n            p[i] = i;\n            rank[i] = 0;\n            weight[i] = 0;\n        }\n    }\n \n \n    public static void main (String[] args){\n        Scanner scanner = new Scanner(System.in);\n        while(true){\n        N = scanner.nextInt();\n        M = scanner.nextInt();\n\n        if(N==0 & M==0){\n           break;\n        }\n \n        DisjointSet();\n\n        for (int i = 0; i < M; i++) {\n            if(scanner.next().equals(\"!\")){\n            int a = scanner.nextInt();\n            int b = scanner.nextInt();\n            int w = scanner.nextInt();\n \n            a--; b--;   \n            unite(a, b, w);\n            }else{\n               if(same(a,b)){\n                    System.out.println(weight[b]-weight[a]);\n                }else{\n                    System.out.println(\"UNKNOWN\");\n\t\t}\n            }\n        }\n       }\n      \n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\nimport java.util.Arrays;\n\npublic class Main {\n\tMyScanner sc = new MyScanner();\n\tScanner sc2 = new Scanner(System.in);\n\tfinal int MOD = 1000000007;\n\tint[] dx = { 1, 0, 0, -1 };\n\tint[] dy = { 0, 1, -1, 0 };\n\n\tint N, M, a, b, w;\n\tint[] parent;\n\tNode[] node;\n\n\tvoid run() {\n\t\tfor (;;) {\n\t\t\tN = sc.nextInt(); // 荷物数\n\t\t\tM = sc.nextInt(); // クエリ数\n\t\t\tif ((N | M) == 0) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tparent = new int[N + 1];\n\t\t\tnode = new Node[N + 1];\n\t\t\tinit();\n\n\t\t\tfor (int i = 0; i < M; i++) {\n\t\t\t\tString query = sc.next();\n\t\t\t\ta = sc.nextInt();\n\t\t\t\tb = sc.nextInt();\n\t\t\t\tif (query.equals(\"!\")) {\n\t\t\t\t\tw = sc.nextInt();\n\t\t\t\t\tunion(a, b, w);\n\t\t\t\t} else if (query.equals(\"?\")) {\n\t\t\t\t\tSystem.out.println(same(a, b) ? node[b].weight\n\t\t\t\t\t\t\t- node[a].weight : \"UNKNOWN\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid init() {\n\t\tfor (int i = 0; i <= N; i++) {\n\t\t\tparent[i] = i;\n\t\t\tnode[i] = new Node(0, 0);\n\t\t}\n\t}\n\n\tvoid union(int x, int y, int w) {\n\t\tint rootX = find(x);\n\t\tint rootY = find(y);\n\t\tif (rootX == rootY) {\n\t\t\treturn;\n\t\t}\n\t\tif (node[rootX].rank < node[rootY].rank) {\n\t\t\tnode[rootX].weight = -w - node[x].weight + node[y].weight;\n\t\t\tparent[rootX] = rootY;\n\t\t} else {\n\t\t\tnode[rootY].weight = w - node[y].weight + node[x].weight;\n\t\t\tparent[rootY] = rootX;\n\n\t\t\tif (node[rootX].rank == node[rootY].rank) {\n\t\t\t\tnode[rootX].rank++;\n\t\t\t}\n\t\t}\n\t}\n\n\tint find(int target) {\n\t\tif (parent[target] == target) {\n\t\t\treturn target;\n\t\t} else {\n\t\t\tint tmp = find(parent[target]);\n\t\t\tnode[target].weight += node[parent[target]].weight;\n\t\t\treturn parent[target] = tmp;\n\t\t}\n\t}\n\n\tboolean same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\n\tclass Node {\n\t\tint weight;\n\t\tint rank;\n\n\t\t/**\n\t\t * @param weight\n\t\t * @param rank\n\t\t */\n\t\tpublic Node(int weight, int rank) {\n\t\t\tsuper();\n\t\t\tthis.weight = weight;\n\t\t\tthis.rank = rank;\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tvoid debug(Object... o) {\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n\n\tvoid debug2(int[][] array) {\n\t\tfor (int i = 0; i < array.length; i++) {\n\t\t\tfor (int j = 0; j < array[i].length; j++) {\n\t\t\t\tSystem.out.print(array[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\n\tclass MyScanner {\n\t\tint nextInt() {\n\t\t\ttry {\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (c != '-' && (c < '0' || '9' < c))\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tif (c == '-')\n\t\t\t\t\treturn -nextInt();\n\t\t\t\tint res = 0;\n\t\t\t\tdo {\n\t\t\t\t\tres *= 10;\n\t\t\t\t\tres += c - '0';\n\t\t\t\t\tc = System.in.read();\n\t\t\t\t} while ('0' <= c && c <= '9');\n\t\t\t\treturn res;\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tString next() {\n\t\t\ttry {\n\t\t\t\tStringBuilder res = new StringBuilder(\"\");\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (Character.isWhitespace(c))\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tdo {\n\t\t\t\t\tres.append((char) c);\n\t\t\t\t} while (!Character.isWhitespace(c = System.in.read()));\n\t\t\t\treturn res.toString();\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.Reader;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\n\npublic class Main {\n\tstatic FastScanner sc = new FastScanner(System.in);\n\tstatic int N;\n\n\tpublic static void main(String[] args) throws Exception {\n\t\ttry {\n\t\t\twhile (true) {\n\t\t\t\tN = sc.nextInt();\n\t\t\t\tif (N == 0) break;\n\t\t\t\tint M = sc.nextInt();\n\t\t\t\tint[] A = new int[M];\n\t\t\t\tint[] B = new int[M];\n\t\t\t\tint[] W = new int[M];\n\t\t\t\tboolean[] type = new boolean[M];\n\t\t\t\tArrayList<ArrayList<Edge>> graph = new ArrayList<ArrayList<Edge>>();\n\t\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\t\tgraph.add(new ArrayList<Edge>());\n\t\t\t\t}\n\t\t\t\tfor (int i = 0; i < M; ++i) {\n\t\t\t\t\ttype[i] = sc.nextChar() == '!';\n\t\t\t\t\tA[i] = sc.nextInt() - 1;\n\t\t\t\t\tB[i] = sc.nextInt() - 1;\n\t\t\t\t\tif (type[i]) {\n\t\t\t\t\t\tW[i] = sc.nextInt();\n\t\t\t\t\t\tgraph.get(A[i]).add(new Edge(B[i], W[i]));\n\t\t\t\t\t\tgraph.get(B[i]).add(new Edge(A[i], -W[i]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tint[] dist = new int[N];\n\t\t\t\tArrays.fill(dist, Integer.MIN_VALUE);\n\t\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\t\tif (dist[i] != Integer.MIN_VALUE) continue;\n\t\t\t\t\tArrayDeque<Integer> q = new ArrayDeque<Integer>();\n\t\t\t\t\tq.add(i);\n\t\t\t\t\tdist[i] = 0;\n\t\t\t\t\twhile (!q.isEmpty()) {\n\t\t\t\t\t\tint cur = q.poll();\n\t\t\t\t\t\tfor (Edge e : graph.get(cur)) {\n\t\t\t\t\t\t\tint next = e.to;\n\t\t\t\t\t\t\tif (dist[next] != Integer.MIN_VALUE) continue;\n\t\t\t\t\t\t\tdist[next] = dist[cur] + e.w;\n\t\t\t\t\t\t\tq.add(next);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tUnionFind uf = new UnionFind(N);\n\t\t\t\tfor (int i = 0; i < M; ++i) {\n\t\t\t\t\tif (type[i]) {\n\t\t\t\t\t\tuf.union(A[i], B[i]);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (!uf.find(A[i], B[i])) {\n\t\t\t\t\t\t\tSystem.out.println(\"UNKNOWN\");\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tSystem.out.println(dist[B[i]] - dist[A[i]]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\n\tstatic class Edge {\n\t\tint to, w;\n\n\t\tEdge(int to, int w) {\n\t\t\tthis.to = to;\n\t\t\tthis.w = w;\n\t\t}\n\t}\n\n\tstatic class UnionFind {\n\t\tint[] set;\n\n\t\tUnionFind(int n) {\n\t\t\tset = new int[n];\n\t\t\tArrays.fill(set, -1);\n\t\t}\n\n\t\tvoid union(int a, int b) {\n\t\t\tint rtA = root(a);\n\t\t\tint rtb = root(b);\n\t\t\tif (rtA == rtb) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tset[rtA] += set[rtb];\n\t\t\tset[rtb] = rtA;\n\t\t}\n\n\t\tboolean find(int a, int b) {\n\t\t\treturn root(a) == root(b);\n\t\t}\n\n\t\tint root(int a) {\n\t\t\tif (set[a] < 0) {\n\t\t\t\treturn a;\n\t\t\t} else {\n\t\t\t\tset[a] = root(set[a]);\n\t\t\t\treturn set[a];\n\t\t\t}\n\t\t}\n\n\t\tint size(int a) {\n\t\t\treturn -set[root(a)];\n\t\t}\n\t}\n\n\tstatic class FastScanner {\n\t\tReader input;\n\n\t\tFastScanner() {\n\t\t\tthis(System.in);\n\t\t}\n\n\t\tFastScanner(InputStream stream) {\n\t\t\tthis.input = new BufferedReader(new InputStreamReader(stream));\n\t\t}\n\n\t\tint nextInt() throws IOException {\n\t\t\tint sign = 1;\n\t\t\tint b = input.read();\n\t\t\twhile ((b < '0' || '9' < b) && b != '-' && b != '+') {\n\t\t\t\tb = input.read();\n\t\t\t}\n\t\t\tif (b == '-') {\n\t\t\t\tsign = -1;\n\t\t\t\tb = input.read();\n\t\t\t} else if (b == '+') {\n\t\t\t\tb = input.read();\n\t\t\t}\n\t\t\tint ret = b - '0';\n\t\t\twhile (true) {\n\t\t\t\tb = input.read();\n\t\t\t\tif (b < '0' || '9' < b) return ret * sign;\n\t\t\t\tret *= 10;\n\t\t\t\tret += b - '0';\n\t\t\t}\n\t\t}\n\n\t\tchar nextChar() throws IOException {\n\t\t\tint b = input.read();\n\t\t\twhile (Character.isWhitespace((char) b)) {\n\t\t\t\tb = input.read();\n\t\t\t}\n\t\t\treturn (char) b;\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\n@SuppressWarnings(\"unchecked\")\n    class Main{\n        \n        int n, m;\n        int INF = Integer.MAX_VALUE/2;\n        ArrayList[] list;\n        long mod = 10000000;        \n\n        void solve(){\n            Scanner sc = new Scanner(System.in);\n            while(true){\n                n = sc.nextInt(); m = sc.nextInt();\n                if(n==0 && m==0) break;\n \n                list = new ArrayList[n+1];\n                for(int i=0; i<=n; i++) list[i] = new ArrayList<Long>();\n                for(int i=0; i<m; i++){\n                    char command = sc.next().charAt(0);\n                    if(command=='!'){\n                        long a = sc.nextLong(), b = sc.nextLong(), w = sc.nextLong();\n                        list[(int)a].add(b * mod + w);\n                        list[(int)b].add(-(a * mod + w));\n                    }else{\n                        int b = dijkstra(sc.nextInt(), sc.nextInt());\n                        if(b==INF) System.out.println(\"UNKNOWN\");\n                        else System.out.println(b);\n                    }\n                }\n            }\n        }\n        \n        int dijkstra(int start, int goal){\n            //pos, cost\n            LinkedList<int[]> q = new LinkedList<int[]>();\n            q.add(new int[]{start, 0});\n            boolean[] v = new boolean[n+1];\n \n            while(q.size()>0){\n                int[] qq = q.poll();\n                int pos = qq[0], cost = qq[1];\n \n                if(pos==goal) return cost;\n                if(v[pos]) continue;\n                v[pos] = true;\n\n                for(int i=0; i<list[pos].size(); i++){\n                    long X = (long)(Long)list[pos].get(i);\n                    int to = 0, weight = 0;\n                    if(X<0){\n                        X = -X;\n                        to = (int)(X / mod); weight = (int)-(X % mod);\n                    }else{\n                        to = (int)(X / mod); weight = (int)(X % mod);\n                    }\n                    q.add(new int[]{to, cost+weight});\n                }\n            }\n            return INF;\n        }\n \n        public static void main(String[] args){\n            new Main().solve();\n        }\n    }"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.io.Reader;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\n\npublic class Main {\n\tstatic FastScanner sc = new FastScanner(System.in);\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tint[] A = new int[100000];\n\t\tint[] B = new int[100000];\n\t\tint[] W = new int[100000];\n\t\tboolean[] type = new boolean[100000];\n\t\tint[] dist = new int[100000];\n\t\tArrayList<ArrayList<Edge>> graph = new ArrayList<ArrayList<Edge>>();\n\t\tfor (int i = 0; i < 100000; ++i) {\n\t\t\tgraph.add(new ArrayList<Edge>());\n\t\t}\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\twhile (true) {\n\t\t\tint N = sc.nextInt();\n\t\t\tint M = sc.nextInt();\n\t\t\tif (N == 0 || M == 0) break;\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tgraph.get(i).clear();\n\t\t\t}\n\t\t\tfor (int i = 0; i < M; ++i) {\n\t\t\t\ttype[i] = sc.nextChar() == '!';\n\t\t\t\tA[i] = sc.nextInt() - 1;\n\t\t\t\tB[i] = sc.nextInt() - 1;\n\t\t\t\tif (type[i]) {\n\t\t\t\t\tW[i] = sc.nextInt();\n\t\t\t\t\tgraph.get(A[i]).add(new Edge(B[i], W[i]));\n\t\t\t\t\tgraph.get(B[i]).add(new Edge(A[i], -W[i]));\n\t\t\t\t}\n\t\t\t}\n\t\t\tArrays.fill(dist, Integer.MIN_VALUE);\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tif (dist[i] != Integer.MIN_VALUE) continue;\n\t\t\t\tArrayDeque<Integer> q = new ArrayDeque<Integer>();\n\t\t\t\tq.add(i);\n\t\t\t\tdist[i] = 0;\n\t\t\t\twhile (!q.isEmpty()) {\n\t\t\t\t\tint cur = q.poll();\n\t\t\t\t\tfor (Edge e : graph.get(cur)) {\n\t\t\t\t\t\tint next = e.to;\n\t\t\t\t\t\tif (dist[next] != Integer.MIN_VALUE) continue;\n\t\t\t\t\t\tdist[next] = dist[cur] + e.w;\n\t\t\t\t\t\tq.add(next);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tUnionFind uf = new UnionFind(100000);\n\t\t\tfor (int i = 0; i < M; ++i) {\n\t\t\t\tif (type[i]) {\n\t\t\t\t\tuf.union(A[i], B[i]);\n\t\t\t\t} else {\n\t\t\t\t\tif (!uf.find(A[i], B[i])) {\n\t\t\t\t\t\tout.println(\"UNKNOWN\");\n\t\t\t\t\t} else {\n\t\t\t\t\t\tout.println(dist[B[i]] - dist[A[i]]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic class Edge {\n\t\tint to, w;\n\n\t\tEdge(int to, int w) {\n\t\t\tthis.to = to;\n\t\t\tthis.w = w;\n\t\t}\n\t}\n\n\tstatic class UnionFind {\n\t\tint[] set;\n\n\t\tUnionFind(int n) {\n\t\t\tset = new int[n];\n\t\t\tArrays.fill(set, -1);\n\t\t}\n\n\t\tvoid union(int a, int b) {\n\t\t\tint rtA = root(a);\n\t\t\tint rtb = root(b);\n\t\t\tif (rtA == rtb) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tset[rtA] += set[rtb];\n\t\t\tset[rtb] = rtA;\n\t\t}\n\n\t\tboolean find(int a, int b) {\n\t\t\treturn root(a) == root(b);\n\t\t}\n\n\t\tint root(int a) {\n\t\t\tif (set[a] < 0) {\n\t\t\t\treturn a;\n\t\t\t} else {\n\t\t\t\tset[a] = root(set[a]);\n\t\t\t\treturn set[a];\n\t\t\t}\n\t\t}\n\n\t\tint size(int a) {\n\t\t\treturn -set[root(a)];\n\t\t}\n\t}\n\n\tstatic class FastScanner {\n\t\tReader input;\n\n\t\tFastScanner() {\n\t\t\tthis(System.in);\n\t\t}\n\n\t\tFastScanner(InputStream stream) {\n\t\t\tthis.input = new BufferedReader(new InputStreamReader(stream));\n\t\t}\n\n\t\tint nextInt() throws IOException {\n\t\t\tint sign = 1;\n\t\t\tint b = input.read();\n\t\t\twhile ((b < '0' || '9' < b) && b != '-' && b != '+') {\n\t\t\t\tif (b == -1) return 0;\n\t\t\t\tb = input.read();\n\t\t\t}\n\t\t\tif (b == '-') {\n\t\t\t\tsign = -1;\n\t\t\t\tb = input.read();\n\t\t\t} else if (b == '+') {\n\t\t\t\tb = input.read();\n\t\t\t}\n\t\t\tint ret = b - '0';\n\t\t\twhile (true) {\n\t\t\t\tb = input.read();\n\t\t\t\tif (b < '0' || '9' < b) return ret * sign;\n\t\t\t\tret *= 10;\n\t\t\t\tret += b - '0';\n\t\t\t}\n\t\t}\n\n\t\tchar nextChar() throws IOException {\n\t\t\tint b = input.read();\n\t\t\twhile (Character.isWhitespace((char) b)) {\n\t\t\t\tb = input.read();\n\t\t\t}\n\t\t\treturn (char) b;\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.Reader;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic Scanner sc = new Scanner(System.in);\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tint[] A = new int[100000];\n\t\tint[] B = new int[100000];\n\t\tint[] W = new int[100000];\n\t\tboolean[] type = new boolean[100000];\n\t\tint[] dist = new int[100000];\n\t\tArrayList<ArrayList<Edge>> graph = new ArrayList<ArrayList<Edge>>();\n\t\tfor (int i = 0; i < 100000; ++i) {\n\t\t\tgraph.add(new ArrayList<Edge>());\n\t\t}\n\t\twhile (sc.hasNextInt()) {\n\t\t\tint N = sc.nextInt();\n\t\t\tif (N == 0) break;\n\t\t\tint M = sc.nextInt();\n//\t\t\tSystem.err.println(\"N:\" + N + \" M:\" + M);\n\t\t\tsc.nextLine();\n//\t\t\tfor (int i = 0; i < N; ++i) {\n//\t\t\t\tA[i] = -1;\n//\t\t\t\tB[i] = -1;\n//\t\t\t}\n\t\t\tfor (int i = 0; i < 100000; ++i) {\n\t\t\t\tgraph.get(i).clear();\n\t\t\t}\n\t\t\tfor (int i = 0; i < M; ++i) {\n\t\t\t\tif (!sc.hasNextLine()) {\n\t\t\t\t\tM = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tString[] line = sc.nextLine().split(\" \");\n\t\t\t\ttype[i] = line[0].charAt(0) == '!';\n\t\t\t\tA[i] = Integer.parseInt(line[1]) - 1;\n\t\t\t\tB[i] = Integer.parseInt(line[2]) - 1;\n\t\t\t\tif (type[i]) {\n\t\t\t\t\tW[i] = Integer.parseInt(line[3]);\n\t\t\t\t\tgraph.get(A[i]).add(new Edge(B[i], W[i]));\n\t\t\t\t\tgraph.get(B[i]).add(new Edge(A[i], -W[i]));\n\t\t\t\t}\n\t\t\t}\n\t\t\tArrays.fill(dist, Integer.MIN_VALUE);\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tif (dist[i] != Integer.MIN_VALUE) continue;\n\t\t\t\tArrayDeque<Integer> q = new ArrayDeque<Integer>();\n\t\t\t\tq.add(i);\n\t\t\t\tdist[i] = 0;\n\t\t\t\twhile (!q.isEmpty()) {\n\t\t\t\t\tint cur = q.poll();\n\t\t\t\t\tfor (Edge e : graph.get(cur)) {\n\t\t\t\t\t\tint next = e.to;\n\t\t\t\t\t\tif (dist[next] != Integer.MIN_VALUE) continue;\n\t\t\t\t\t\tdist[next] = dist[cur] + e.w;\n\t\t\t\t\t\tq.add(next);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tUnionFind uf = new UnionFind(100000);\n\t\t\tfor (int i = 0; i < M; ++i) {\n//\t\t\t\tif (A[i] == -1 || B[i] == -1) {\n//\t\t\t\t\tSystem.out.println(\"UNKNOWN\");\n//\t\t\t\t\tcontinue;\n//\t\t\t\t}\n\t\t\t\tif (type[i]) {\n\t\t\t\t\tuf.union(A[i], B[i]);\n\t\t\t\t} else {\n\t\t\t\t\tif (!uf.find(A[i], B[i])) {\n\t\t\t\t\t\tSystem.out.println(\"UNKNOWN\");\n\t\t\t\t\t} else {\n\t\t\t\t\t\tSystem.out.println(dist[B[i]] - dist[A[i]]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic class Edge {\n\t\tint to, w;\n\n\t\tEdge(int to, int w) {\n\t\t\tthis.to = to;\n\t\t\tthis.w = w;\n\t\t}\n\t}\n\n\tstatic class UnionFind {\n\t\tint[] set;\n\n\t\tUnionFind(int n) {\n\t\t\tset = new int[n];\n\t\t\tArrays.fill(set, -1);\n\t\t}\n\n\t\tvoid union(int a, int b) {\n\t\t\tint rtA = root(a);\n\t\t\tint rtb = root(b);\n\t\t\tif (rtA == rtb) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tset[rtA] += set[rtb];\n\t\t\tset[rtb] = rtA;\n\t\t}\n\n\t\tboolean find(int a, int b) {\n\t\t\treturn root(a) == root(b);\n\t\t}\n\n\t\tint root(int a) {\n\t\t\tif (set[a] < 0) {\n\t\t\t\treturn a;\n\t\t\t} else {\n\t\t\t\tset[a] = root(set[a]);\n\t\t\t\treturn set[a];\n\t\t\t}\n\t\t}\n\n\t\tint size(int a) {\n\t\t\treturn -set[root(a)];\n\t\t}\n\t}\n\n\tstatic class FastScanner {\n\t\tReader input;\n\n\t\tFastScanner() {\n\t\t\tthis(System.in);\n\t\t}\n\n\t\tFastScanner(InputStream stream) {\n\t\t\tthis.input = new BufferedReader(new InputStreamReader(stream));\n\t\t}\n\n\t\tint nextInt() throws IOException {\n\t\t\tint sign = 1;\n\t\t\tint b = input.read();\n\t\t\twhile ((b < '0' || '9' < b) && b != '-' && b != '+') {\n\t\t\t\tif (b == -1) return 0;\n\t\t\t\tb = input.read();\n\t\t\t}\n\t\t\tif (b == '-') {\n\t\t\t\tsign = -1;\n\t\t\t\tb = input.read();\n\t\t\t} else if (b == '+') {\n\t\t\t\tb = input.read();\n\t\t\t}\n\t\t\tint ret = b - '0';\n\t\t\twhile (true) {\n\t\t\t\tb = input.read();\n\t\t\t\tif (b < '0' || '9' < b) return ret * sign;\n\t\t\t\tret *= 10;\n\t\t\t\tret += b - '0';\n\t\t\t}\n\t\t}\n\n\t\tchar nextChar() throws IOException {\n\t\t\tint b = input.read();\n\t\t\twhile (Character.isWhitespace((char) b)) {\n\t\t\t\tb = input.read();\n\t\t\t}\n\t\t\treturn (char) b;\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n \npublic class Main {\n    public static int N;\n    public static int M;\n    public static int[] p;\n    public static int[] rank;\n    public static int[] w;\n \n    public static boolean same(int a, int b) {\n        return findSet(a) == findSet(b);\n    }\n    \n    public static void unite(int a, int b, int k) {\n        int i = findSet(a);\n        int j = findSet(b);\n\tk -= w[b] - w[a];\n\t\n        if (i == j){\n\t    return;\n\t}\n        if (rank[i] > rank[j]){\n            p[j] = p[i];\n\t    w[j] = k;\n        } else {\n            p[i] = p[j];\n\t    w[i] = -k;\n            if(rank[i] == rank[j]){\n\t\trank[j]++;\n            }\n        }\t\n    }\n    \n    public static int findSet(int i) {\n\tif(p[i] == i){ \n\t    return i;\n        }else{\n\t    return p[i] = findSet(p[i]);\n        }\n    }\n    \n    public static void DisjointSet() {\n        p = new int[N];\n        rank = new int[N];\n\tw = new int[N];\n\t\n        for (int i = 0; i < N; i++) {\n            p[i] = i;\n            rank[i] = 0;\n\t    w[i] = 0;\n        }\n    }\n    \n    public static void main (String[] args){\n        Scanner scanner = new Scanner(System.in);\n\twhile(true){   \n\t    N = scanner.nextInt();\n\t    DisjointSet();\n\t    M = scanner.nextInt();\n\t    if(N==0 & M == 0) break;\n\t    \n\t    for (int i = 0; i < M; i++) {\n\t\tif(scanner.next().equals(\"!\")){\n\t\t    int a = scanner.nextInt();\n\t\t    int b = scanner.nextInt();\n\t\t    int w = scanner.nextInt();\n\t\t    \n\t\t    a--;\n\t\t    b--;\n\t\t    unite(a, b, w);\n\t\t}else{\n\t\t    if(same(a,b)==false){\n\t\t\tSystem.out.println(\"UNKNOWN\");\n\t\t    }else{\n\t\t\tSystem.out.println(w[b]-w[a]);\n\t\t    }\n\t\t}\n\t    }\n\t}\t\n    }\n}\n\n \n    public static int findSet(int i) {\n       if(p[i] == i){ \n           return i;\n        }else{\n          return p[i] = findSet(p[i]);\n        }\n    }\n \n    public static void DisjointSet() {\n        p = new int[N];\n        rank = new int[N];\n\tw = new int[N];\n \n        for (int i = 0; i < N; i++) {\n            p[i] = i;\n            rank[i] = 0;\n\t    w[i] = 0;\n        }\n    }\n    \n    public static void main (String[] args){\n        Scanner scanner = new Scanner(System.in);\n\twhile(true){   \n\t    N = scanner.nextInt();\n\t    DisjointSet();\n\t    M = scanner.nextInt();\n\t    if(N==0 & M == 0) break;\n\t    \n\t    for (int i = 0; i < M; i++) {\n\t\tif(scanner.next().equals(\"!\")){\n\t\t    int a = scanner.nextInt();\n\t\t    int b = scanner.nextInt();\n\t\t    int w = scanner.nextInt();\n\t\t    \n\t\t    a--;\n\t\t    b--;\n\t\t    unite(a, b, w);\n\t\t}else{\n\t\t    if(same(a,b)==false){\n\t\t\tSystem.out.println(\"UNKNOWN\");\n\t\t    }else{\n\t\t\tSystem.out.println(w[b]-w[a]);\n\t\t    }\n\t\t}\n\t    }\n\t}\t\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.io.Reader;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\n\npublic class Main {\n\tstatic FastScanner sc = new FastScanner(System.in);\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tint[] A = new int[100000];\n\t\tint[] B = new int[100000];\n\t\tint[] W = new int[100000];\n\t\tboolean[] type = new boolean[100000];\n\t\tint[] dist = new int[100000];\n\t\tArrayList<ArrayList<Edge>> graph = new ArrayList<ArrayList<Edge>>();\n\t\tfor (int i = 0; i < 100000; ++i) {\n\t\t\tgraph.add(new ArrayList<Edge>());\n\t\t}\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\twhile (true) {\n\t\t\tint N = sc.nextInt();\n\t\t\tint M = sc.nextInt();\n\t\t\tif (N == 0 || M == 0) break;\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tgraph.get(i).clear();\n\t\t\t}\n\t\t\tfor (int i = 0; i < M; ++i) {\n\t\t\t\ttype[i] = sc.nextChar() == '!';\n\t\t\t\tA[i] = sc.nextInt() - 1;\n\t\t\t\tB[i] = sc.nextInt() - 1;\n\t\t\t\tif (type[i]) {\n\t\t\t\t\tW[i] = sc.nextInt();\n\t\t\t\t\tgraph.get(A[i]).add(new Edge(B[i], W[i]));\n\t\t\t\t\tgraph.get(B[i]).add(new Edge(A[i], -W[i]));\n\t\t\t\t}\n\t\t\t}\n\t\t\tArrays.fill(dist, Integer.MIN_VALUE);\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tif (dist[i] != Integer.MIN_VALUE) continue;\n\t\t\t\tArrayDeque<Integer> q = new ArrayDeque<Integer>();\n\t\t\t\tq.add(i);\n\t\t\t\tdist[i] = 0;\n\t\t\t\twhile (!q.isEmpty()) {\n\t\t\t\t\tint cur = q.poll();\n\t\t\t\t\tfor (Edge e : graph.get(cur)) {\n\t\t\t\t\t\tint next = e.to;\n\t\t\t\t\t\tif (dist[next] != Integer.MIN_VALUE) continue;\n\t\t\t\t\t\tdist[next] = dist[cur] + e.w;\n\t\t\t\t\t\tq.add(next);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tUnionFind uf = new UnionFind(N);\n\t\t\tfor (int i = 0; i < M; ++i) {\n\t\t\t\tif (type[i]) {\n\t\t\t\t\tif (A[i] < 0 || A[i] >= N || B[i] < 0 || B[i] >= N) continue;\n//\t\t\t\t\tuf.union(A[i], B[i]);\n\t\t\t\t} else {\n\t\t\t\t\tif (A[i] < 0 || A[i] >= N || B[i] < 0 || B[i] >= N || !uf.find(A[i], B[i])) {\n//\t\t\t\t\t\tout.println(\"UNKNOWN\");\n\t\t\t\t\t} else {\n//\t\t\t\t\t\tout.println(dist[B[i]] - dist[A[i]]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic class Edge {\n\t\tint to, w;\n\n\t\tEdge(int to, int w) {\n\t\t\tthis.to = to;\n\t\t\tthis.w = w;\n\t\t}\n\t}\n\n\tstatic class UnionFind {\n\t\tint[] set;\n\n\t\tUnionFind(int n) {\n\t\t\tset = new int[n];\n\t\t\tArrays.fill(set, -1);\n\t\t}\n\n\t\tvoid union(int a, int b) {\n\t\t\tint rtA = root(a);\n\t\t\tint rtb = root(b);\n\t\t\tif (rtA == rtb) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tset[rtA] += set[rtb];\n\t\t\tset[rtb] = rtA;\n\t\t}\n\n\t\tboolean find(int a, int b) {\n\t\t\treturn root(a) == root(b);\n\t\t}\n\n\t\tint root(int a) {\n\t\t\tif (set[a] < 0) {\n\t\t\t\treturn a;\n\t\t\t} else {\n\t\t\t\tset[a] = root(set[a]);\n\t\t\t\treturn set[a];\n\t\t\t}\n\t\t}\n\n\t\tint size(int a) {\n\t\t\treturn -set[root(a)];\n\t\t}\n\t}\n\n\tstatic class FastScanner {\n\t\tReader input;\n\n\t\tFastScanner() {\n\t\t\tthis(System.in);\n\t\t}\n\n\t\tFastScanner(InputStream stream) {\n\t\t\tthis.input = new BufferedReader(new InputStreamReader(stream));\n\t\t}\n\n\t\tint nextInt() throws IOException {\n\t\t\tint sign = 1;\n\t\t\tint b = input.read();\n\t\t\twhile ((b < '0' || '9' < b) && b != '-' && b != '+') {\n\t\t\t\tif (b == -1) return 0;\n\t\t\t\tb = input.read();\n\t\t\t}\n\t\t\tif (b == '-') {\n\t\t\t\tsign = -1;\n\t\t\t\tb = input.read();\n\t\t\t} else if (b == '+') {\n\t\t\t\tb = input.read();\n\t\t\t}\n\t\t\tint ret = b - '0';\n\t\t\twhile (true) {\n\t\t\t\tb = input.read();\n\t\t\t\tif (b < '0' || '9' < b) return ret * sign;\n\t\t\t\tret *= 10;\n\t\t\t\tret += b - '0';\n\t\t\t}\n\t\t}\n\n\t\tchar nextChar() throws IOException {\n\t\t\tint b = input.read();\n\t\t\twhile (Character.isWhitespace((char) b)) {\n\t\t\t\tb = input.read();\n\t\t\t}\n\t\t\treturn (char) b;\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n \npublic class Main {\n    public static int N;\n    public static int M;\n    public static int[] p;\n    public static int[] rank;\n    public static int[] w;\n \n    public static boolean same(int a, int b) {\n        return findSet(a) == findSet(b);\n    }\n \n    public static void unite(int a, int b, int k) {\n        int i = findSet(a);\n        int j = findSet(b);\n\tk -= w[b] - w[a];\n\t\n        if (i == j){\n\t    return;\n\t}\n        if (rank[i] > rank[j]){\n            p[j] = p[i];\n\t    w[j] = k;\n        } else {\n            p[i] = p[j];\n\t    w[i] = -k;\n            if(rank[i] == rank[j]){\n            rank[j]++;\n            }\n        }\t\n    }\n \n    public static int findSet(int i) {\n       if(p[i] == i){ \n           return i;\n        }else{\n          return p[i] = findSet(p[i]);\n        }\n    }\n \n    public static void DisjointSet() {\n        p = new int[N];\n        rank = new int[N];\n\tw = new int[N];\n \n        for (int i = 0; i < N; i++) {\n            p[i] = i;\n            rank[i] = 0;\n\t    w[i] = 0;\n        }\n    }\n    \n    public static void main (String[] args){\n        Scanner scanner = new Scanner(System.in);\n\twhile(true){   \n\t    N = scanner.nextInt();\n\t    DisjointSet();\n\t    M = scanner.nextInt();\n\t    if(N==0 & M == 0) break;\n\t    \n\t    for (int i = 0; i < M; i++) {\n\t\tif(scanner.next().equals(\"!\")){\n\t\t    int a = scanner.nextInt();\n\t\t    int b = scanner.nextInt();\n\t\t    int k = scanner.nextInt();\n\t\t    \n\t\t    a--;\n\t\t    b--;\n\t\t    unite(a, b, k);\n\t\t}else{\n\t\t    if(same(a,b)==false){\n\t\t\tSystem.out.println(\"UNKNOWN\");\n\t\t    }else{\n\t\t\tSystem.out.println(w[b]-w[a]);\n\t\t    }\n\t\t}\n\t    }\n\t}\t\n    }\n}\n \n    public static int findSet(int i) {\n       if(p[i] == i){ \n           return i;\n        }else{\n          return p[i] = findSet(p[i]);\n        }\n    }\n \n    public static void DisjointSet() {\n        p = new int[N];\n        rank = new int[N];\n\tw = new int[N];\n \n        for (int i = 0; i < N; i++) {\n            p[i] = i;\n            rank[i] = 0;\n\t    w[i] = 0;\n        }\n    }\n    \n    public static void main (String[] args){\n        Scanner scanner = new Scanner(System.in);\n\twhile(true){   \n\t    N = scanner.nextInt();\n\t    DisjointSet();\n\t    M = scanner.nextInt();\n\t    if(N==0 & M == 0) break;\n\t    \n\t    for (int i = 0; i < M; i++) {\n\t\tif(scanner.next().equals(\"!\")){\n\t\t    int a = scanner.nextInt();\n\t\t    int b = scanner.nextInt();\n\t\t    int w = scanner.nextInt();\n\t\t    \n\t\t    a--;\n\t\t    b--;\n\t\t    unite(a, b, w);\n\t\t}else{\n\t\t    if(same(a,b)==false){\n\t\t\tSystem.out.println(\"UNKNOWN\");\n\t\t    }else{\n\t\t\tSystem.out.println(w[b]-w[a]);\n\t\t    }\n\t\t}\n\t    }\n\t}\t\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n   \npublic class Main {\n    public static int N;\n    public static int M;\n    public static int[] p;\n    public static int[] rank;\n    public static int[] weight;\n  \n    public static boolean same(int x, int y) {\n        return findSet(x) == findSet(y);\n    }\n   \n    public static void unite(int x, int y, int w) {\n        int i = findSet(x);\n        int j = findSet(y);\n        \n  \n        if (i == j){\n        return;\n    }\n        if (rank[i] > rank[j]){\n            p[j] = i;      \n            weight[j] =  w - weight[y] + weight[x];\n            weight[y] += weight[p[j]]; \n        } else {\n            p[i] = j;\n            weight[i] =  -w - weight[x] + weight[y];\n            weight[x] += weight[p[i]]; \n            if(rank[i] == rank[j]){\n        rank[j]++;\n            }\n        }   \n    }\n   \n    public static int findSet(int i) {\n    if(p[i] == i){ \n        return i;\n        }else{      \n          return p[i] = findSet(p[i]);\n        }\n    }\n   \n    public static void DisjointSet() {\n        p = new int[N];\n        rank = new int[N];\n        weight = new int[N];\n   \n        for (int i = 0; i < N; i++) {\n            p[i] = i;\n            rank[i] = 0;\n            weight[i] = 0;\n        }\n    }\n   \n   \n    public static void main (String[] args){\n        Scanner scanner = new Scanner(System.in);\n        while(true){\n        N = scanner.nextInt();\n        M = scanner.nextInt();\n  \n        if(N==0 && M==0){\n        break;\n        }\n   \n        DisjointSet();\n  \n        for (int i = 0; i < M; i++) {\n        String c = scanner.next();\n        int a = scanner.nextInt();\n        int b = scanner.nextInt();\n        a--; b--; \n          \n        if(c.equals(\"!\")){\n            int w = scanner.nextInt();\n            unite(a, b, w);\n        }else{ \n            if(same(a,b)){\n            System.out.println(weight[b] - weight[a]);\n            }else{\n            System.out.println(\"UNKNOWN\");\n            }\n        }\n        }\n    }\n        \n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.io.Reader;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\n\npublic class Main {\n\tstatic FastScanner sc = new FastScanner(System.in);\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tint[] A = new int[100000];\n\t\tint[] B = new int[100000];\n\t\tint[] W = new int[100000];\n\t\tboolean[] type = new boolean[100000];\n\t\tint[] dist = new int[100000];\n\t\tArrayList<ArrayList<Edge>> graph = new ArrayList<ArrayList<Edge>>();\n\t\tfor (int i = 0; i < 100000; ++i) {\n\t\t\tgraph.add(new ArrayList<Edge>());\n\t\t}\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\twhile (true) {\n\t\t\tint N = sc.nextInt();\n\t\t\tint M = sc.nextInt();\n\t\t\tif (N == 0 || M == 0) break;\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tgraph.get(i).clear();\n\t\t\t}\n\t\t\tfor (int i = 0; i < M; ++i) {\n\t\t\t\ttype[i] = sc.nextChar() == '!';\n\t\t\t\tA[i] = sc.nextInt() - 1;\n\t\t\t\tB[i] = sc.nextInt() - 1;\n\t\t\t\tif (type[i]) {\n\t\t\t\t\tW[i] = sc.nextInt();\n\t\t\t\t\tgraph.get(A[i]).add(new Edge(B[i], W[i]));\n\t\t\t\t\tgraph.get(B[i]).add(new Edge(A[i], -W[i]));\n\t\t\t\t}\n\t\t\t}\n\t\t\tArrays.fill(dist, Integer.MIN_VALUE);\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tif (dist[i] != Integer.MIN_VALUE) continue;\n\t\t\t\tArrayDeque<Integer> q = new ArrayDeque<Integer>();\n\t\t\t\tq.add(i);\n\t\t\t\tdist[i] = 0;\n\t\t\t\twhile (!q.isEmpty()) {\n\t\t\t\t\tint cur = q.poll();\n\t\t\t\t\tfor (Edge e : graph.get(cur)) {\n\t\t\t\t\t\tint next = e.to;\n\t\t\t\t\t\tif (dist[next] != Integer.MIN_VALUE) continue;\n\t\t\t\t\t\tdist[next] = dist[cur] + e.w;\n\t\t\t\t\t\tq.add(next);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tUnionFind uf = new UnionFind(N);\n\t\t\tfor (int i = 0; i < M; ++i) {\n\t\t\t\tif (type[i]) {\n\t\t\t\t\tif (A[i] < 0 || A[i] >= N || B[i] < 0 || B[i] >= N) continue;\n\t\t\t\t\tuf.union(A[i], B[i]);\n\t\t\t\t} else {\n\t\t\t\t\tif (A[i] < 0 || A[i] >= N || B[i] < 0 || B[i] >= N || !uf.find(A[i], B[i])) {\n//\t\t\t\t\t\tout.println(\"UNKNOWN\");\n\t\t\t\t\t} else {\n//\t\t\t\t\t\tout.println(dist[B[i]] - dist[A[i]]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic class Edge {\n\t\tint to, w;\n\n\t\tEdge(int to, int w) {\n\t\t\tthis.to = to;\n\t\t\tthis.w = w;\n\t\t}\n\t}\n\n\tstatic class UnionFind {\n\t\tint[] set;\n\n\t\tUnionFind(int n) {\n\t\t\tset = new int[n];\n\t\t\tArrays.fill(set, -1);\n\t\t}\n\n\t\tvoid union(int a, int b) {\n\t\t\tint rtA = root(a);\n\t\t\tint rtb = root(b);\n\t\t\tif (rtA == rtb) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tset[rtA] += set[rtb];\n\t\t\tset[rtb] = rtA;\n\t\t}\n\n\t\tboolean find(int a, int b) {\n\t\t\treturn root(a) == root(b);\n\t\t}\n\n\t\tint root(int a) {\n\t\t\tif (set[a] < 0) {\n\t\t\t\treturn a;\n\t\t\t} else {\n\t\t\t\tset[a] = root(set[a]);\n\t\t\t\treturn set[a];\n\t\t\t}\n\t\t}\n\n\t\tint size(int a) {\n\t\t\treturn -set[root(a)];\n\t\t}\n\t}\n\n\tstatic class FastScanner {\n\t\tReader input;\n\n\t\tFastScanner() {\n\t\t\tthis(System.in);\n\t\t}\n\n\t\tFastScanner(InputStream stream) {\n\t\t\tthis.input = new BufferedReader(new InputStreamReader(stream));\n\t\t}\n\n\t\tint nextInt() throws IOException {\n\t\t\tint sign = 1;\n\t\t\tint b = input.read();\n\t\t\twhile ((b < '0' || '9' < b) && b != '-' && b != '+') {\n\t\t\t\tif (b == -1) return 0;\n\t\t\t\tb = input.read();\n\t\t\t}\n\t\t\tif (b == '-') {\n\t\t\t\tsign = -1;\n\t\t\t\tb = input.read();\n\t\t\t} else if (b == '+') {\n\t\t\t\tb = input.read();\n\t\t\t}\n\t\t\tint ret = b - '0';\n\t\t\twhile (true) {\n\t\t\t\tb = input.read();\n\t\t\t\tif (b < '0' || '9' < b) return ret * sign;\n\t\t\t\tret *= 10;\n\t\t\t\tret += b - '0';\n\t\t\t}\n\t\t}\n\n\t\tchar nextChar() throws IOException {\n\t\t\tint b = input.read();\n\t\t\twhile (Character.isWhitespace((char) b)) {\n\t\t\t\tb = input.read();\n\t\t\t}\n\t\t\treturn (char) b;\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "public class Main {\n\tMyScanner sc = new MyScanner();\n\tint N, M, a, b, w;\n\tint[] parent;\n\tNode[] node;\n\n\tvoid run() {\n\t\tfor (;;) {\n\t\t\tN = sc.nextInt(); // 荷物数\n\t\t\tM = sc.nextInt(); // クエリ数\n\t\t\tif ((N | M) == 0) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tparent = new int[N + 1];\n\t\t\tnode = new Node[N + 1];\n\t\t\tinit();\n\n\t\t\tfor (int i = 0; i < M; i++) {\n\t\t\t\tString query = sc.next();\n\t\t\t\ta = sc.nextInt();\n\t\t\t\tb = sc.nextInt();\n\t\t\t\tif (query.equals(\"!\")) {\n\t\t\t\t\tw = sc.nextInt();\n\t\t\t\t\tunion(a, b, w);\n\t\t\t\t} else if (query.equals(\"?\")) {\n\t\t\t\t\tSystem.out.println(same(a, b) ? node[b].weight\n\t\t\t\t\t\t\t- node[a].weight : \"UNKNOWN\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid init() {\n\t\tfor (int i = 0; i <= N; i++) {\n\t\t\tparent[i] = i;\n\t\t\tnode[i] = new Node(0, 0);\n\t\t}\n\t}\n\n\tvoid union(int x, int y, int w) {\n\t\tint rootX = find(x);\n\t\tint rootY = find(y);\n\t\tif (rootX == rootY) {\n\t\t\treturn;\n\t\t}\n\t\tif (node[rootX].rank < node[rootY].rank) {\n\t\t\tnode[rootX].weight = -w - node[x].weight + node[y].weight;\n\t\t\tparent[rootX] = rootY;\n\t\t} else {\n\t\t\tnode[rootY].weight = w - node[y].weight + node[x].weight;\n\t\t\tparent[rootY] = rootX;\n\n\t\t\tif (node[rootX].rank == node[rootY].rank) {\n\t\t\t\tnode[rootX].rank++;\n\t\t\t}\n\t\t}\n\t}\n\n\tint find(int target) {\n\t\tif (parent[target] == target) {\n\t\t\treturn target;\n\t\t} else {\n\t\t\tint tmp = find(parent[target]);\n\t\t\tnode[target].weight += node[parent[target]].weight;\n\t\t\treturn parent[target] = tmp;\n\t\t}\n\t}\n\n\tboolean same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\n\tclass Node {\n\t\tint weight;\n\t\tint rank;\n\n\t\t/**\n\t\t * @param weight\n\t\t * @param rank\n\t\t */\n\t\tpublic Node(int weight, int rank) {\n\t\t\tsuper();\n\t\t\tthis.weight = weight;\n\t\t\tthis.rank = rank;\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tclass MyScanner {\n\t\tint nextInt() {\n\t\t\ttry {\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (c != '-' && (c < '0' || '9' < c))\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tif (c == '-')\n\t\t\t\t\treturn -nextInt();\n\t\t\t\tint res = 0;\n\t\t\t\tdo {\n\t\t\t\t\tres *= 10;\n\t\t\t\t\tres += c - '0';\n\t\t\t\t\tc = System.in.read();\n\t\t\t\t} while ('0' <= c && c <= '9');\n\t\t\t\treturn res;\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\n\t\tString next() {\n\t\t\ttry {\n\t\t\t\tStringBuilder res = new StringBuilder(\"\");\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (Character.isWhitespace(c))\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tdo {\n\t\t\t\t\tres.append((char) c);\n\t\t\t\t} while (!Character.isWhitespace(c = System.in.read()));\n\t\t\t\treturn res.toString();\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.Reader;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic int N;\n\n\tpublic static void main(String[] args) throws Exception {\n\t\twhile (true) {\n\t\t\tN = sc.nextInt();\n\t\t\tif (N == 0) break;\n\t\t\tint M = sc.nextInt();\n\t\t\tint[] A = new int[M];\n\t\t\tint[] B = new int[M];\n\t\t\tint[] W = new int[M];\n\t\t\tboolean[] type = new boolean[M];\n\t\t\tArrayList<ArrayList<Edge>> graph = new ArrayList<ArrayList<Edge>>();\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tgraph.add(new ArrayList<Edge>());\n\t\t\t}\n\t\t\tfor (int i = 0; i < M; ++i) {\n\t\t\t\ttype[i] = sc.next().charAt(0) == '!';\n\t\t\t\tA[i] = sc.nextInt() - 1;\n\t\t\t\tB[i] = sc.nextInt() - 1;\n\t\t\t\tif (type[i]) {\n\t\t\t\t\tW[i] = sc.nextInt();\n\t\t\t\t\tgraph.get(A[i]).add(new Edge(B[i], W[i]));\n\t\t\t\t\tgraph.get(B[i]).add(new Edge(A[i], -W[i]));\n\t\t\t\t}\n\t\t\t}\n\t\t\tint[] dist = new int[N];\n\t\t\tArrays.fill(dist, Integer.MIN_VALUE);\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tif (dist[i] != Integer.MIN_VALUE) continue;\n\t\t\t\tArrayDeque<Integer> q = new ArrayDeque<Integer>();\n\t\t\t\tq.add(i);\n\t\t\t\tdist[i] = 0;\n\t\t\t\twhile (!q.isEmpty()) {\n\t\t\t\t\tint cur = q.poll();\n\t\t\t\t\tfor (Edge e : graph.get(cur)) {\n\t\t\t\t\t\tint next = e.to;\n\t\t\t\t\t\tif (dist[next] != Integer.MIN_VALUE) continue;\n\t\t\t\t\t\tdist[next] = dist[cur] + e.w;\n\t\t\t\t\t\tq.add(next);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tUnionFind uf = new UnionFind(N);\n\t\t\tfor (int i = 0; i < M; ++i) {\n\t\t\t\tif (type[i]) {\n\t\t\t\t\tuf.union(A[i], B[i]);\n\t\t\t\t} else {\n\t\t\t\t\tif (!uf.find(A[i], B[i])) {\n\t\t\t\t\t\tSystem.out.println(\"UNKNOWN\");\n\t\t\t\t\t} else {\n\t\t\t\t\t\tSystem.out.println(dist[B[i]] - dist[A[i]]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic class Edge {\n\t\tint to, w;\n\n\t\tEdge(int to, int w) {\n\t\t\tthis.to = to;\n\t\t\tthis.w = w;\n\t\t}\n\t}\n\n\tstatic class UnionFind {\n\t\tint[] set;\n\n\t\tUnionFind(int n) {\n\t\t\tset = new int[n];\n\t\t\tArrays.fill(set, -1);\n\t\t}\n\n\t\tvoid union(int a, int b) {\n\t\t\tint rtA = root(a);\n\t\t\tint rtb = root(b);\n\t\t\tif (rtA == rtb) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tset[rtA] += set[rtb];\n\t\t\tset[rtb] = rtA;\n\t\t}\n\n\t\tboolean find(int a, int b) {\n\t\t\treturn root(a) == root(b);\n\t\t}\n\n\t\tint root(int a) {\n\t\t\tif (set[a] < 0) {\n\t\t\t\treturn a;\n\t\t\t} else {\n\t\t\t\tset[a] = root(set[a]);\n\t\t\t\treturn set[a];\n\t\t\t}\n\t\t}\n\n\t\tint size(int a) {\n\t\t\treturn -set[root(a)];\n\t\t}\n\t}\n\n\tstatic class FastScanner {\n\t\tReader input;\n\n\t\tFastScanner() {\n\t\t\tthis(System.in);\n\t\t}\n\n\t\tFastScanner(InputStream stream) {\n\t\t\tthis.input = new BufferedReader(new InputStreamReader(stream));\n\t\t}\n\n\t\tint nextInt() throws IOException {\n\t\t\tint sign = 1;\n\t\t\tint b = input.read();\n\t\t\twhile ((b < '0' || '9' < b) && b != '-' && b != '+') {\n\t\t\t\tb = input.read();\n\t\t\t}\n\t\t\tif (b == '-') {\n\t\t\t\tsign = -1;\n\t\t\t\tb = input.read();\n\t\t\t} else if (b == '+') {\n\t\t\t\tb = input.read();\n\t\t\t}\n\t\t\tint ret = b - '0';\n\t\t\twhile (true) {\n\t\t\t\tb = input.read();\n\t\t\t\tif (b < '0' || '9' < b) return ret * sign;\n\t\t\t\tret *= 10;\n\t\t\t\tret += b - '0';\n\t\t\t}\n\t\t}\n\n\t\tchar nextChar() throws IOException {\n\t\t\tint b = input.read();\n\t\t\twhile (Character.isWhitespace((char) b)) {\n\t\t\t\tb = input.read();\n\t\t\t}\n\t\t\treturn (char) b;\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "public class Main {\n\tMyScanner sc = new MyScanner();\n\tint N, M, a, b, w;\n\tint[] parent;\n\tNode[] node;\n\n\tvoid run() {\n\t\tfor (;;) {\n\t\t\tN = sc.nextInt(); // 荷物数\n\t\t\tM = sc.nextInt(); // クエリ数\n\t\t\tif ((N | M) == 0) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tparent = new int[N + 1];\n\t\t\tnode = new Node[N + 1];\n\t\t\tinit();\n\n\t\t\tfor (int i = 0; i < M; i++) {\n\t\t\t\tString query = sc.next();\n\t\t\t\ta = sc.nextInt();\n\t\t\t\tb = sc.nextInt();\n\t\t\t\tif (query.equals(\"!\")) {\n\t\t\t\t\tw = sc.nextInt();\n\t\t\t\t\tunion(a, b, w);\n\t\t\t\t} else if (query.equals(\"?\")) {\n\t\t\t\t\tSystem.out.println(same(a, b) ? node[b].weight\n\t\t\t\t\t\t\t- node[a].weight : \"UNKNOWN\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid init() {\n\t\tfor (int i = 0; i <= N; i++) {\n\t\t\tparent[i] = i;\n\t\t\tnode[i] = new Node(0, 0);\n\t\t}\n\t}\n\n\tvoid union(int x, int y, int w) {\n\t\tint rootX = find(x);\n\t\tint rootY = find(y);\n\t\tif (rootX == rootY) {\n\t\t\treturn;\n\t\t}\n\t\tif (node[rootX].rank < node[rootY].rank) {\n\t\t\tnode[rootX].weight = -w  + node[y].weight;\n\t\t\tparent[rootX] = rootY;\n\t\t} else {\n\t\t\tnode[rootY].weight = w  + node[x].weight;\n\t\t\tparent[rootY] = rootX;\n\n\t\t\tif (node[rootX].rank == node[rootY].rank) {\n\t\t\t\tnode[rootX].rank++;\n\t\t\t}\n\t\t}\n\t}\n\n\tint find(int target) {\n\t\tif (parent[target] == target) {\n\t\t\treturn target;\n\t\t} else {\n\t\t\tint tmp = find(parent[target]);\n\t\t\tnode[target].weight += node[parent[target]].weight;\n\t\t\treturn parent[target] = tmp;\n\t\t}\n\t}\n\n\tboolean same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\n\tclass Node {\n\t\tint weight;\n\t\tint rank;\n\n\t\t/**\n\t\t * @param weight\n\t\t * @param rank\n\t\t */\n\t\tpublic Node(int weight, int rank) {\n\t\t\tsuper();\n\t\t\tthis.weight = weight;\n\t\t\tthis.rank = rank;\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tclass MyScanner {\n\t\tint nextInt() {\n\t\t\ttry {\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (c != '-' && (c < '0' || '9' < c))\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tif (c == '-')\n\t\t\t\t\treturn -nextInt();\n\t\t\t\tint res = 0;\n\t\t\t\tdo {\n\t\t\t\t\tres *= 10;\n\t\t\t\t\tres += c - '0';\n\t\t\t\t\tc = System.in.read();\n\t\t\t\t} while ('0' <= c && c <= '9');\n\t\t\t\treturn res;\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\n\t\tString next() {\n\t\t\ttry {\n\t\t\t\tStringBuilder res = new StringBuilder(\"\");\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (Character.isWhitespace(c))\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tdo {\n\t\t\t\t\tres.append((char) c);\n\t\t\t\t} while (!Character.isWhitespace(c = System.in.read()));\n\t\t\t\treturn res.toString();\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.io.Reader;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\n\npublic class Main {\n\tstatic FastScanner sc = new FastScanner(System.in);\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tint[] A = new int[100000];\n\t\tint[] B = new int[100000];\n\t\tint[] W = new int[100000];\n\t\tboolean[] type = new boolean[100000];\n\t\tint[] dist = new int[100000];\n\t\tArrayList<ArrayList<Edge>> graph = new ArrayList<ArrayList<Edge>>();\n\t\tfor (int i = 0; i < 100000; ++i) {\n\t\t\tgraph.add(new ArrayList<Edge>());\n\t\t}\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\twhile (true) {\n\t\t\tint N = sc.nextInt();\n\t\t\tint M = sc.nextInt();\n\t\t\tif (N == 0 || M == 0) break;\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tgraph.get(i).clear();\n\t\t\t}\n\t\t\tfor (int i = 0; i < M; ++i) {\n\t\t\t\ttype[i] = sc.nextChar() == '!';\n\t\t\t\tA[i] = sc.nextInt() - 1;\n\t\t\t\tB[i] = sc.nextInt() - 1;\n\t\t\t\tif (type[i]) {\n\t\t\t\t\tW[i] = sc.nextInt();\n\t\t\t\t\tgraph.get(A[i]).add(new Edge(B[i], W[i]));\n\t\t\t\t\tgraph.get(B[i]).add(new Edge(A[i], -W[i]));\n\t\t\t\t}\n\t\t\t}\n\t\t\tArrays.fill(dist, Integer.MIN_VALUE);\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tif (dist[i] != Integer.MIN_VALUE) continue;\n\t\t\t\tArrayDeque<Integer> q = new ArrayDeque<Integer>();\n\t\t\t\tq.add(i);\n\t\t\t\tdist[i] = 0;\n\t\t\t\twhile (!q.isEmpty()) {\n\t\t\t\t\tint cur = q.poll();\n\t\t\t\t\tfor (Edge e : graph.get(cur)) {\n\t\t\t\t\t\tint next = e.to;\n\t\t\t\t\t\tif (dist[next] != Integer.MIN_VALUE) continue;\n\t\t\t\t\t\tdist[next] = dist[cur] + e.w;\n\t\t\t\t\t\tq.add(next);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tUnionFind uf = new UnionFind(N);\n\t\t\tfor (int i = 0; i < M; ++i) {\n\t\t\t\tif (type[i]) {\n\t\t\t\t\tuf.union(A[i], B[i]);\n\t\t\t\t} else {\n\t\t\t\t\tif (!uf.find(A[i], B[i])) {\n\t\t\t\t\t\tout.println(\"UNKNOWN\");\n\t\t\t\t\t} else {\n\t\t\t\t\t\tout.println(dist[B[i]] - dist[A[i]]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tout.flush();\n\t}\n\n\tstatic class Edge {\n\t\tint to, w;\n\n\t\tEdge(int to, int w) {\n\t\t\tthis.to = to;\n\t\t\tthis.w = w;\n\t\t}\n\t}\n\n\tstatic class UnionFind {\n\t\tint[] set;\n\n\t\tUnionFind(int n) {\n\t\t\tset = new int[n];\n\t\t\tArrays.fill(set, -1);\n\t\t}\n\n\t\tvoid union(int a, int b) {\n\t\t\tint rtA = root(a);\n\t\t\tint rtb = root(b);\n\t\t\tif (rtA == rtb) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tset[rtA] += set[rtb];\n\t\t\tset[rtb] = rtA;\n\t\t}\n\n\t\tboolean find(int a, int b) {\n\t\t\treturn root(a) == root(b);\n\t\t}\n\n\t\tint root(int a) {\n\t\t\tif (set[a] < 0) {\n\t\t\t\treturn a;\n\t\t\t} else {\n\t\t\t\tArrayList<Integer> pos = new ArrayList<Integer>();\n\t\t\t\tpos.add(a);\n\t\t\t\tint rt = -1;\n\t\t\t\twhile (true) {\n\t\t\t\t\tint parent = set[pos.get(pos.size() - 1)];\n\t\t\t\t\tif (parent < 0) {\n\t\t\t\t\t\trt = pos.get(pos.size() - 1);\n\t\t\t\t\t\tfor (int i = 0; i < pos.size() - 1; ++i) {\n\t\t\t\t\t\t\tset[pos.get(i)] = rt;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn rt;\n\t\t\t\t\t}\n\t\t\t\t\tpos.add(parent);\n\t\t\t\t}\n//\t\t\t\tset[a] = root(set[a]);\n//\t\t\t\treturn set[a];\n\t\t\t}\n\t\t}\n\n\t\tint size(int a) {\n\t\t\treturn -set[root(a)];\n\t\t}\n\t}\n\n\tstatic class FastScanner {\n\t\tReader input;\n\n\t\tFastScanner() {\n\t\t\tthis(System.in);\n\t\t}\n\n\t\tFastScanner(InputStream stream) {\n\t\t\tthis.input = new BufferedReader(new InputStreamReader(stream));\n\t\t}\n\n\t\tint nextInt() throws IOException {\n\t\t\tint sign = 1;\n\t\t\tint b = input.read();\n\t\t\twhile ((b < '0' || '9' < b) && b != '-' && b != '+') {\n\t\t\t\tif (b == -1) return 0;\n\t\t\t\tb = input.read();\n\t\t\t}\n\t\t\tif (b == '-') {\n\t\t\t\tsign = -1;\n\t\t\t\tb = input.read();\n\t\t\t} else if (b == '+') {\n\t\t\t\tb = input.read();\n\t\t\t}\n\t\t\tint ret = b - '0';\n\t\t\twhile (true) {\n\t\t\t\tb = input.read();\n\t\t\t\tif (b < '0' || '9' < b) return ret * sign;\n\t\t\t\tret *= 10;\n\t\t\t\tret += b - '0';\n\t\t\t}\n\t\t}\n\n\t\tchar nextChar() throws IOException {\n\t\t\tint b = input.read();\n\t\t\twhile (Character.isWhitespace((char) b)) {\n\t\t\t\tb = input.read();\n\t\t\t}\n\t\t\treturn (char) b;\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.Reader;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic Scanner sc = new Scanner(System.in);\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tint[] A = new int[100000];\n\t\tint[] B = new int[100000];\n\t\tint[] W = new int[100000];\n\t\tboolean[] type = new boolean[100000];\n\t\tint[] dist = new int[100000];\n\t\twhile (sc.hasNextInt()) {\n\t\t\tint N = sc.nextInt();\n\t\t\tif (N == 0) break;\n\t\t\tint M = sc.nextInt();\n\t\t\tSystem.err.println(\"N:\" + N + \" M:\" + M);\n\t\t\tArrayList<ArrayList<Edge>> graph = new ArrayList<ArrayList<Edge>>();\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tgraph.add(new ArrayList<Edge>());\n\t\t\t}\n\t\t\tsc.nextLine();\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tA[i] = -1;\n\t\t\t\tB[i] = -1;\n\t\t\t}\n\t\t\tfor (int i = 0; i < M; ++i) {\n\t\t\t\tif (!sc.hasNextLine()) break;\n\t\t\t\tString[] line = sc.nextLine().split(\" \");\n\t\t\t\ttype[i] = line[0].charAt(0) == '!';\n\t\t\t\tA[i] = Integer.parseInt(line[1]) - 1;\n\t\t\t\tB[i] = Integer.parseInt(line[2]) - 1;\n\t\t\t\tif (type[i]) {\n\t\t\t\t\tW[i] = Integer.parseInt(line[3]);\n\t\t\t\t\tgraph.get(A[i]).add(new Edge(B[i], W[i]));\n\t\t\t\t\tgraph.get(B[i]).add(new Edge(A[i], -W[i]));\n\t\t\t\t}\n\t\t\t}\n\t\t\tArrays.fill(dist, Integer.MIN_VALUE);\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tif (dist[i] != Integer.MIN_VALUE) continue;\n\t\t\t\tArrayDeque<Integer> q = new ArrayDeque<Integer>();\n\t\t\t\tq.add(i);\n\t\t\t\tdist[i] = 0;\n\t\t\t\twhile (!q.isEmpty()) {\n\t\t\t\t\tint cur = q.poll();\n\t\t\t\t\tfor (Edge e : graph.get(cur)) {\n\t\t\t\t\t\tint next = e.to;\n\t\t\t\t\t\tif (dist[next] != Integer.MIN_VALUE) continue;\n\t\t\t\t\t\tdist[next] = dist[cur] + e.w;\n\t\t\t\t\t\tq.add(next);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tUnionFind uf = new UnionFind(100000);\n\t\t\tfor (int i = 0; i < M; ++i) {\n\t\t\t\tif (A[i] == -1 || B[i] == -1) {\n\t\t\t\t\tSystem.out.println(\"UNKNOWN\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (type[i]) {\n\t\t\t\t\tuf.union(A[i], B[i]);\n\t\t\t\t} else {\n\t\t\t\t\tif (!uf.find(A[i], B[i])) {\n\t\t\t\t\t\tSystem.out.println(\"UNKNOWN\");\n\t\t\t\t\t} else {\n\t\t\t\t\t\tSystem.out.println(dist[B[i]] - dist[A[i]]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic class Edge {\n\t\tint to, w;\n\n\t\tEdge(int to, int w) {\n\t\t\tthis.to = to;\n\t\t\tthis.w = w;\n\t\t}\n\t}\n\n\tstatic class UnionFind {\n\t\tint[] set;\n\n\t\tUnionFind(int n) {\n\t\t\tset = new int[n];\n\t\t\tArrays.fill(set, -1);\n\t\t}\n\n\t\tvoid union(int a, int b) {\n\t\t\tint rtA = root(a);\n\t\t\tint rtb = root(b);\n\t\t\tif (rtA == rtb) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tset[rtA] += set[rtb];\n\t\t\tset[rtb] = rtA;\n\t\t}\n\n\t\tboolean find(int a, int b) {\n\t\t\treturn root(a) == root(b);\n\t\t}\n\n\t\tint root(int a) {\n\t\t\tif (set[a] < 0) {\n\t\t\t\treturn a;\n\t\t\t} else {\n\t\t\t\tset[a] = root(set[a]);\n\t\t\t\treturn set[a];\n\t\t\t}\n\t\t}\n\n\t\tint size(int a) {\n\t\t\treturn -set[root(a)];\n\t\t}\n\t}\n\n\tstatic class FastScanner {\n\t\tReader input;\n\n\t\tFastScanner() {\n\t\t\tthis(System.in);\n\t\t}\n\n\t\tFastScanner(InputStream stream) {\n\t\t\tthis.input = new BufferedReader(new InputStreamReader(stream));\n\t\t}\n\n\t\tint nextInt() throws IOException {\n\t\t\tint sign = 1;\n\t\t\tint b = input.read();\n\t\t\twhile ((b < '0' || '9' < b) && b != '-' && b != '+') {\n\t\t\t\tif (b == -1) return 0;\n\t\t\t\tb = input.read();\n\t\t\t}\n\t\t\tif (b == '-') {\n\t\t\t\tsign = -1;\n\t\t\t\tb = input.read();\n\t\t\t} else if (b == '+') {\n\t\t\t\tb = input.read();\n\t\t\t}\n\t\t\tint ret = b - '0';\n\t\t\twhile (true) {\n\t\t\t\tb = input.read();\n\t\t\t\tif (b < '0' || '9' < b) return ret * sign;\n\t\t\t\tret *= 10;\n\t\t\t\tret += b - '0';\n\t\t\t}\n\t\t}\n\n\t\tchar nextChar() throws IOException {\n\t\t\tint b = input.read();\n\t\t\twhile (Character.isWhitespace((char) b)) {\n\t\t\t\tb = input.read();\n\t\t\t}\n\t\t\treturn (char) b;\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static class WeightedUnionFind{\n\t    int[] par; // 親の番号\n\t    int[] ws;  // 親との重みの差\n\t    \n\t    public WeightedUnionFind(int n){\n\t        par = new int[n];\n\t        ws  = new int[n];\n\t        for(int i = 0; i < n; i++){ \n\t        \tpar[i] = -1;\n\t        \tws[i]  = 0;\n\t        }\n\t    }\n\t    \n\t    public int find(int x){\n\t    \tif(par[x] < 0){\n\t    \t\treturn x;\n\t    \t}else{\n\t    \t\tfinal int parent = find(par[x]);\n\t    \t\tws[x] += ws[par[x]];\n\t    \t\tpar[x] = parent;\n\t    \t\treturn parent;\n\t    \t}\n\t    }\n\t    \n\t    public int weight(int x){\n\t    \tfind(x);\n\t    \treturn ws[x];\n\t    }\n\t    \n\t    public boolean union(int x, int y, int w){ // x <-(w)- y (x + w = y)\n\t    \tw += weight(x);\n\t    \tw -= weight(y);\n\t        x = find(x);\n\t        y = find(y);\n\t        \n\t        if(x != y){\n\t            if(par[y] < par[x]) {  // 多い方が根になるようにスワップする.\n\t                int tmp = x; x = y; y = tmp;\n\t                w = -w;\n\t            }\n\t            par[x] += par[y];\n\t            par[y] = x;\n\t            ws[y] = w;\n\t            \n\t            return true;\n\t        }else{\n\t            return false;\n\t        }\n\t    }\n\t    \n\t    public boolean same(int x, int y){\n\t        return find(x) == find(y);\n\t    }\n\t    \n\t    public Integer diff(int x, int y){ // x - y を求める. 比較不能ならnull.\n\t    \tif(!same(x, y)){\n\t    \t\treturn null;\n\t    \t}else{\n\t    \t\treturn this.weight(x) - this.weight(y);\n\t    \t}\n\t    }\n\t    \n\t    public int size(int x){\n\t        return -par[find(x)];\n\t    }\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\n\t\twhile(true){\n\t\t\tfinal int n = sc.nextInt();\n\t\t\tfinal int m = sc.nextInt();\n\t\t\t\n\t\t\tif(n == 0 && m == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tWeightedUnionFind uf = new WeightedUnionFind(n);\n\t\t\t\n\t\t\tfor(int i = 0; i < m; i++){\n\t\t\t\tfinal String ops = sc.next();\n\t\t\t\t\n\t\t\t\tif(\"?\".equals(ops)){\n\t\t\t\t\tfinal int r = sc.nextInt() - 1;\n\t\t\t\t\tfinal int l = sc.nextInt() - 1;\n\t\t\t\t\tfinal Integer ret = uf.diff(r, l);\n\t\t\t\t\tSystem.out.println(ret == null ? \"UNKNOWN\" : -ret);\n\t\t\t\t}else{\n\t\t\t\t\tfinal int r = sc.nextInt() - 1;\n\t\t\t\t\tfinal int l = sc.nextInt() - 1;\n\t\t\t\t\tfinal int w = sc.nextInt();\n\t\t\t\t\t\n\t\t\t\t\tuf.union(r, l, w);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tsc.close();\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.io.Reader;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\n\npublic class Main {\n\tstatic FastScanner sc = new FastScanner(System.in);\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tint[] A = new int[100000];\n\t\tint[] B = new int[100000];\n\t\tint[] W = new int[100000];\n\t\tboolean[] type = new boolean[100000];\n\t\tint[] dist = new int[100000];\n\t\tArrayList<ArrayList<Edge>> graph = new ArrayList<ArrayList<Edge>>();\n\t\tfor (int i = 0; i < 100000; ++i) {\n\t\t\tgraph.add(new ArrayList<Edge>());\n\t\t}\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\twhile (true) {\n\t\t\tint N = sc.nextInt();\n\t\t\tint M = sc.nextInt();\n\t\t\tif (N == 0 || M == 0) break;\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tgraph.get(i).clear();\n\t\t\t}\n\t\t\tfor (int i = 0; i < M; ++i) {\n\t\t\t\ttype[i] = sc.nextChar() == '!';\n\t\t\t\tA[i] = sc.nextInt() - 1;\n\t\t\t\tB[i] = sc.nextInt() - 1;\n\t\t\t\tif (type[i]) {\n\t\t\t\t\tW[i] = sc.nextInt();\n\t\t\t\t\tgraph.get(A[i]).add(new Edge(B[i], W[i]));\n\t\t\t\t\tgraph.get(B[i]).add(new Edge(A[i], -W[i]));\n\t\t\t\t}\n\t\t\t}\n\t\t\tArrays.fill(dist, Integer.MIN_VALUE);\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tif (dist[i] != Integer.MIN_VALUE) continue;\n\t\t\t\tArrayDeque<Integer> q = new ArrayDeque<Integer>();\n\t\t\t\tq.add(i);\n\t\t\t\tdist[i] = 0;\n\t\t\t\twhile (!q.isEmpty()) {\n\t\t\t\t\tint cur = q.poll();\n\t\t\t\t\tfor (Edge e : graph.get(cur)) {\n\t\t\t\t\t\tint next = e.to;\n\t\t\t\t\t\tif (dist[next] != Integer.MIN_VALUE) continue;\n\t\t\t\t\t\tdist[next] = dist[cur] + e.w;\n\t\t\t\t\t\tq.add(next);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tUnionFind uf = new UnionFind(100000);\n\t\t\tfor (int i = 0; i < M; ++i) {\n\t\t\t\tif (type[i]) {\n\t\t\t\t\tuf.union(A[i], B[i]);\n\t\t\t\t} else {\n\t\t\t\t\tif (!uf.find(A[i], B[i])) {\n\t\t\t\t\t\tout.println(\"UNKNOWN\");\n\t\t\t\t\t} else {\n//\t\t\t\t\t\tout.println(dist[B[i]] - dist[A[i]]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic class Edge {\n\t\tint to, w;\n\n\t\tEdge(int to, int w) {\n\t\t\tthis.to = to;\n\t\t\tthis.w = w;\n\t\t}\n\t}\n\n\tstatic class UnionFind {\n\t\tint[] set;\n\n\t\tUnionFind(int n) {\n\t\t\tset = new int[n];\n\t\t\tArrays.fill(set, -1);\n\t\t}\n\n\t\tvoid union(int a, int b) {\n\t\t\tint rtA = root(a);\n\t\t\tint rtb = root(b);\n\t\t\tif (rtA == rtb) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tset[rtA] += set[rtb];\n\t\t\tset[rtb] = rtA;\n\t\t}\n\n\t\tboolean find(int a, int b) {\n\t\t\treturn root(a) == root(b);\n\t\t}\n\n\t\tint root(int a) {\n\t\t\tif (set[a] < 0) {\n\t\t\t\treturn a;\n\t\t\t} else {\n\t\t\t\tset[a] = root(set[a]);\n\t\t\t\treturn set[a];\n\t\t\t}\n\t\t}\n\n\t\tint size(int a) {\n\t\t\treturn -set[root(a)];\n\t\t}\n\t}\n\n\tstatic class FastScanner {\n\t\tReader input;\n\n\t\tFastScanner() {\n\t\t\tthis(System.in);\n\t\t}\n\n\t\tFastScanner(InputStream stream) {\n\t\t\tthis.input = new BufferedReader(new InputStreamReader(stream));\n\t\t}\n\n\t\tint nextInt() throws IOException {\n\t\t\tint sign = 1;\n\t\t\tint b = input.read();\n\t\t\twhile ((b < '0' || '9' < b) && b != '-' && b != '+') {\n\t\t\t\tif (b == -1) return 0;\n\t\t\t\tb = input.read();\n\t\t\t}\n\t\t\tif (b == '-') {\n\t\t\t\tsign = -1;\n\t\t\t\tb = input.read();\n\t\t\t} else if (b == '+') {\n\t\t\t\tb = input.read();\n\t\t\t}\n\t\t\tint ret = b - '0';\n\t\t\twhile (true) {\n\t\t\t\tb = input.read();\n\t\t\t\tif (b < '0' || '9' < b) return ret * sign;\n\t\t\t\tret *= 10;\n\t\t\t\tret += b - '0';\n\t\t\t}\n\t\t}\n\n\t\tchar nextChar() throws IOException {\n\t\t\tint b = input.read();\n\t\t\twhile (Character.isWhitespace((char) b)) {\n\t\t\t\tb = input.read();\n\t\t\t}\n\t\t\treturn (char) b;\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n \npublic class Main {\n    public static int N;\n    public static int M;\n    public static int[] p;\n    public static int[] rank;\n    public static int[] weight;\n\n    public static boolean same(int x, int y) {\n        return findSet(x) == findSet(y);\n    }\n \n    public static void unite(int x, int y, int w) {\n        int i = findSet(x);\n        int j = findSet(y);\n        w -= weight[j] - weight[i];\n\n        if (i == j){\n\t    return;\n\t}\n        if (rank[i] > rank[j]){\n            p[j] = p[i];\n            weight[j] = w;\n        } else {\n            p[i] = p[j];\n            weight[i] = -w;\n            if(rank[i] == rank[j]){\n            rank[j]++;\n            }\n        }\t\n    }\n \n    public static int findSet(int i) {\n       if(p[i] == i){ \n           return i;\n        }else{\n          return p[i] = findSet(p[i]);\n        }\n    }\n \n    public static void DisjointSet() {\n        p = new int[N];\n        rank = new int[N];\n        weight = new int[N];\n \n        for (int i = 0; i < N; i++) {\n            p[i] = i;\n            rank[i] = 0;\n            weight[i] = 0;\n        }\n    }\n \n \n    public static void main (String[] args){\n        Scanner scanner = new Scanner(System.in);\n        while(true){\n        N = scanner.nextInt();\n        M = scanner.nextInt();\n\n        if(N==0 |M==0){\n           break;\n        }\n \n        DisjointSet();\n\n        for (int i = 0; i < M; i++) {\n            int a = scanner.nextInt();\n            int b = scanner.nextInt();\n            \n            if(scanner.next().equals(\"!\")){\n            int w = scanner.nextInt();\n \n            a--; b--;   \n            unite(a, b, w);\n            }else{ \n               if(same(a,b)){\n                    System.out.println(weight[b] - weight[a]);\n               }else{\n                    System.out.println(\"UNKNOWN\");\n\t       }\n            }\n          }\n       }\n      \n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tnew Main().solver();\n\t}\n\n\tvoid solver() {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint N = sc.nextInt();\n\t\t\tint M = sc.nextInt();\n\t\t\tif (N == 0 && M == 0)\n\t\t\t\tbreak;\n\t\t\tWeightedUnionFind uf = new WeightedUnionFind(N);\n\t\t\tfor (int i = 0; i < M; i++) {\n\t\t\t\tString s = sc.next();\n\t\t\t\tint x = sc.nextInt() - 1;\n\t\t\t\tint y = sc.nextInt() - 1;\n\t\t\t\tif (s.equals(\"!\")) {\n\t\t\t\t\tint w = sc.nextInt();\n\t\t\t\t\tuf.union(x, y, w);\n\t\t\t\t} else {\n\t\t\t\t\tif (!uf.same(x, y)) {\n\t\t\t\t\t\tSystem.out.println(\"UNKNOWN\");\n\t\t\t\t\t} else {\n\t\t\t\t\t\tSystem.out.println(-uf.diff(x, y));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsc.close();\n\t}\n\n\tclass WeightedUnionFind {\n\t\tint[] par;\n\t\tint[] wd;\n\n\t\tpublic WeightedUnionFind(int n) {\n\t\t\tpar = new int[n];\n\t\t\twd = new int[n];\n\t\t\tArrays.fill(par, -1);\n\t\t}\n\n\t\tint find(int x) {\n\t\t\tif (par[x] < 0)\n\t\t\t\treturn x;\n\t\t\telse {\n\t\t\t\tfinal int parent = find(par[x]);\n\t\t\t\twd[x] += wd[par[x]];\n\t\t\t\tpar[x] = parent;\n\t\t\t\treturn parent;\n\t\t\t}\n\t\t}\n\n\t\tboolean same(int x, int y) {\n\t\t\treturn find(x) == find(y);\n\t\t}\n\n\t\tint weight(int x) {\n\t\t\tfind(x);\n\t\t\treturn wd[x];\n\t\t}\n\n\t\t// y - x = w ??? y = x + w;\n\t\tboolean union(int x, int y, int w) {\n\t\t\tif (find(x) == find(y))\n\t\t\t\treturn false;\n\t\t\telse {\n\t\t\t\tw += (weight(x) - weight(y));\n\t\t\t\tx = find(x);\n\t\t\t\ty = find(y);\n\t\t\t\tif (par[y] < par[x]) { // ???????????????????????????????????????????????????.\n\t\t\t\t\tint tmp = x;\n\t\t\t\t\tx = y;\n\t\t\t\t\ty = tmp;\n\t\t\t\t\tw = -w;\n\t\t\t\t}\n\t\t\t\tpar[y] = x;\n\t\t\t\twd[y] = w;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\t// return x-y\n\t\tint diff(int x, int y) {\n\t\t\tif (!same(x, y)) {\n\t\t\t\tthrow new AssertionError();\n\t\t\t} else {\n\t\t\t\treturn this.weight(x) - this.weight(y);\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.Reader;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic Scanner sc = new Scanner(System.in);\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tint[] A = new int[100000];\n\t\tint[] B = new int[100000];\n\t\tint[] W = new int[100000];\n\t\tboolean[] type = new boolean[100000];\n\t\tint[] dist = new int[100000];\n\t\twhile (sc.hasNextInt()) {\n\t\t\tint N = sc.nextInt();\n\t\t\tif (N == 0) break;\n\t\t\tint M = sc.nextInt();\n//\t\t\tSystem.err.println(\"N:\" + N + \" M:\" + M);\n\t\t\tArrayList<ArrayList<Edge>> graph = new ArrayList<ArrayList<Edge>>();\n\t\t\tfor (int i = 0; i < 100000; ++i) {\n\t\t\t\tgraph.add(new ArrayList<Edge>());\n\t\t\t}\n\t\t\tsc.nextLine();\n//\t\t\tfor (int i = 0; i < N; ++i) {\n//\t\t\t\tA[i] = -1;\n//\t\t\t\tB[i] = -1;\n//\t\t\t}\n\t\t\tfor (int i = 0; i < M; ++i) {\n//\t\t\t\tif (!sc.hasNextLine()) break;\n\t\t\t\tString[] line = sc.nextLine().split(\" \");\n\t\t\t\ttype[i] = line[0].charAt(0) == '!';\n\t\t\t\tA[i] = Integer.parseInt(line[1]) - 1;\n\t\t\t\tB[i] = Integer.parseInt(line[2]) - 1;\n\t\t\t\tif (type[i]) {\n\t\t\t\t\tW[i] = Integer.parseInt(line[3]);\n\t\t\t\t\tgraph.get(A[i]).add(new Edge(B[i], W[i]));\n\t\t\t\t\tgraph.get(B[i]).add(new Edge(A[i], -W[i]));\n\t\t\t\t}\n\t\t\t}\n\t\t\tArrays.fill(dist, Integer.MIN_VALUE);\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tif (dist[i] != Integer.MIN_VALUE) continue;\n\t\t\t\tArrayDeque<Integer> q = new ArrayDeque<Integer>();\n\t\t\t\tq.add(i);\n\t\t\t\tdist[i] = 0;\n\t\t\t\twhile (!q.isEmpty()) {\n\t\t\t\t\tint cur = q.poll();\n\t\t\t\t\tfor (Edge e : graph.get(cur)) {\n\t\t\t\t\t\tint next = e.to;\n\t\t\t\t\t\tif (dist[next] != Integer.MIN_VALUE) continue;\n\t\t\t\t\t\tdist[next] = dist[cur] + e.w;\n\t\t\t\t\t\tq.add(next);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tUnionFind uf = new UnionFind(100000);\n\t\t\tfor (int i = 0; i < M; ++i) {\n//\t\t\t\tif (A[i] == -1 || B[i] == -1) {\n//\t\t\t\t\tSystem.out.println(\"UNKNOWN\");\n//\t\t\t\t\tcontinue;\n//\t\t\t\t}\n\t\t\t\tif (type[i]) {\n\t\t\t\t\tuf.union(A[i], B[i]);\n\t\t\t\t} else {\n\t\t\t\t\tif (!uf.find(A[i], B[i])) {\n\t\t\t\t\t\tSystem.out.println(\"UNKNOWN\");\n\t\t\t\t\t} else {\n\t\t\t\t\t\tSystem.out.println(dist[B[i]] - dist[A[i]]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic class Edge {\n\t\tint to, w;\n\n\t\tEdge(int to, int w) {\n\t\t\tthis.to = to;\n\t\t\tthis.w = w;\n\t\t}\n\t}\n\n\tstatic class UnionFind {\n\t\tint[] set;\n\n\t\tUnionFind(int n) {\n\t\t\tset = new int[n];\n\t\t\tArrays.fill(set, -1);\n\t\t}\n\n\t\tvoid union(int a, int b) {\n\t\t\tint rtA = root(a);\n\t\t\tint rtb = root(b);\n\t\t\tif (rtA == rtb) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tset[rtA] += set[rtb];\n\t\t\tset[rtb] = rtA;\n\t\t}\n\n\t\tboolean find(int a, int b) {\n\t\t\treturn root(a) == root(b);\n\t\t}\n\n\t\tint root(int a) {\n\t\t\tif (set[a] < 0) {\n\t\t\t\treturn a;\n\t\t\t} else {\n\t\t\t\tset[a] = root(set[a]);\n\t\t\t\treturn set[a];\n\t\t\t}\n\t\t}\n\n\t\tint size(int a) {\n\t\t\treturn -set[root(a)];\n\t\t}\n\t}\n\n\tstatic class FastScanner {\n\t\tReader input;\n\n\t\tFastScanner() {\n\t\t\tthis(System.in);\n\t\t}\n\n\t\tFastScanner(InputStream stream) {\n\t\t\tthis.input = new BufferedReader(new InputStreamReader(stream));\n\t\t}\n\n\t\tint nextInt() throws IOException {\n\t\t\tint sign = 1;\n\t\t\tint b = input.read();\n\t\t\twhile ((b < '0' || '9' < b) && b != '-' && b != '+') {\n\t\t\t\tif (b == -1) return 0;\n\t\t\t\tb = input.read();\n\t\t\t}\n\t\t\tif (b == '-') {\n\t\t\t\tsign = -1;\n\t\t\t\tb = input.read();\n\t\t\t} else if (b == '+') {\n\t\t\t\tb = input.read();\n\t\t\t}\n\t\t\tint ret = b - '0';\n\t\t\twhile (true) {\n\t\t\t\tb = input.read();\n\t\t\t\tif (b < '0' || '9' < b) return ret * sign;\n\t\t\t\tret *= 10;\n\t\t\t\tret += b - '0';\n\t\t\t}\n\t\t}\n\n\t\tchar nextChar() throws IOException {\n\t\t\tint b = input.read();\n\t\t\twhile (Character.isWhitespace((char) b)) {\n\t\t\t\tb = input.read();\n\t\t\t}\n\t\t\treturn (char) b;\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n  \npublic class saisyu2 {\n    public static int N;\n    public static int M;\n    public static int[] p;\n    public static int[] rank;\n    public static int[] weight;\n \n    public static boolean same(int x, int y) {\n        return findSet(x) == findSet(y);\n    }\n  \n    public static void unite(int x, int y, int w) {\n        int i = findSet(x);\n        int j = findSet(y);\n       \n \n        if (i == j){\n        return;\n    }\n        if (rank[i] > rank[j]){\n            p[j] = i;\t   \n            weight[j] =  weight[x] + w;\n        } else {\n            p[i] = j;\n            weight[i] = weight[y] - w;\n            if(rank[i] == rank[j]){\n        rank[j]++;\n            }\n        }   \n    }\n  \n    public static int findSet(int i) {\n    if(p[i] == i){ \n        return i;\n        }else{\n        return p[i] = findSet(p[i]);\n        }\n    }\n  \n    public static void DisjointSet() {\n        p = new int[N];\n        rank = new int[N];\n        weight = new int[N];\n  \n        for (int i = 0; i < N; i++) {\n            p[i] = i;\n            rank[i] = 0;\n            weight[i] = 0;\n        }\n    }\n  \n  \n    public static void main (String[] args){\n        Scanner scanner = new Scanner(System.in);\n        while(true){\n        N = scanner.nextInt();\n        M = scanner.nextInt();\n \n        if(N==0 && M==0){\n        break;\n        }\n  \n        DisjointSet();\n \n        for (int i = 0; i < M; i++) {\n        String c = scanner.next();\n        int a = scanner.nextInt();\n        int b = scanner.nextInt();\n        a--; b--; \n         \n        if(c.equals(\"!\")){\n            int w = scanner.nextInt();\n            unite(a, b, w);\n        }else{ \n            if(same(a,b)){\n\t\tSystem.out.println(weight[b] - weight[a]);\n            }else{\n            System.out.println(\"UNKNOWN\");\n            }\n        }\n        }\n    }\n       \n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\tint N, M, a, b, w;\n\tint[] parent;\n\tNode[] node;\n\n\tvoid run() {\n\t\tfor (;;) {\n\t\t\tN = sc.nextInt(); // 荷物数\n\t\t\tM = sc.nextInt(); // クエリ数\n\t\t\tif ((N | M) == 0) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tparent = new int[N + 1];\n\t\t\tnode = new Node[N + 1];\n\t\t\tinit();\n\n\t\t\tfor (int i = 0; i < M; i++) {\n\t\t\t\tString query = sc.next();\n\t\t\t\ta = sc.nextInt();\n\t\t\t\tb = sc.nextInt();\n\t\t\t\tif (query.equals(\"!\")) {\n\t\t\t\t\tw = sc.nextInt();\n\t\t\t\t\tunion(a, b, w);\n\t\t\t\t} else if (query.equals(\"?\")) {\n\t\t\t\t\tSystem.out.println(same(a, b) ? node[b].weight\n\t\t\t\t\t\t\t- node[a].weight : \"UNKNOWN\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid init() {\n\t\tfor (int i = 0; i <= N; i++) {\n\t\t\tparent[i] = i;\n\t\t\tnode[i] = new Node(0, 0);\n\t\t}\n\t}\n\n\tvoid union(int x, int y, int w) {\n\t\tint rootX = find(x);\n\t\tint rootY = find(y);\n\t\tif (rootX == rootY) {\n\t\t\treturn;\n\t\t}\n\t\tif (node[rootX].rank < node[rootY].rank) {\n\t\t\tnode[rootX].weight = -w - node[x].weight + node[y].weight;\n\t\t\tparent[rootX] = rootY;\n\t\t} else {\n\t\t\tnode[rootY].weight = w - node[y].weight + node[x].weight;\n\t\t\tparent[rootY] = rootX;\n\n\t\t\tif (node[rootX].rank == node[rootY].rank) {\n\t\t\t\tnode[rootX].rank++;\n\t\t\t}\n\t\t}\n\t}\n\n\tint find(int target) {\n\t\tif (parent[target] == target) {\n\t\t\treturn target;\n\t\t} else {\n\t\t\tint tmp = find(parent[target]);\n\t\t\tnode[target].weight += node[parent[target]].weight;\n\t\t\treturn parent[target] = tmp;\n\t\t}\n\t}\n\n\tboolean same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\n\tclass Node {\n\t\tint weight;\n\t\tint rank;\n\n\t\tpublic Node(int weight, int rank) {\n\t\t\tsuper();\n\t\t\tthis.weight = weight;\n\t\t\tthis.rank = rank;\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.io.Reader;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\n\npublic class Main {\n\tstatic FastScanner sc = new FastScanner(System.in);\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tint[] A = new int[100000];\n\t\tint[] B = new int[100000];\n\t\tint[] W = new int[100000];\n\t\tboolean[] type = new boolean[100000];\n\t\tint[] dist = new int[100000];\n\t\tArrayList<ArrayList<Edge>> graph = new ArrayList<ArrayList<Edge>>();\n\t\tfor (int i = 0; i < 100000; ++i) {\n\t\t\tgraph.add(new ArrayList<Edge>());\n\t\t}\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\twhile (true) {\n\t\t\tint N = sc.nextInt();\n\t\t\tint M = sc.nextInt();\n\t\t\tif (N == 0 || M == 0) break;\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tgraph.get(i).clear();\n\t\t\t}\n\t\t\tfor (int i = 0; i < M; ++i) {\n\t\t\t\ttype[i] = sc.nextChar() == '!';\n\t\t\t\tA[i] = sc.nextInt() - 1;\n\t\t\t\tB[i] = sc.nextInt() - 1;\n\t\t\t\tif (type[i]) {\n\t\t\t\t\tW[i] = sc.nextInt();\n\t\t\t\t\tgraph.get(A[i]).add(new Edge(B[i], W[i]));\n\t\t\t\t\tgraph.get(B[i]).add(new Edge(A[i], -W[i]));\n\t\t\t\t}\n\t\t\t}\n\t\t\tArrays.fill(dist, Integer.MIN_VALUE);\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tif (dist[i] != Integer.MIN_VALUE) continue;\n\t\t\t\tArrayDeque<Integer> q = new ArrayDeque<Integer>();\n\t\t\t\tq.add(i);\n\t\t\t\tdist[i] = 0;\n\t\t\t\twhile (!q.isEmpty()) {\n\t\t\t\t\tint cur = q.poll();\n\t\t\t\t\tfor (Edge e : graph.get(cur)) {\n\t\t\t\t\t\tint next = e.to;\n\t\t\t\t\t\tif (dist[next] != Integer.MIN_VALUE) continue;\n\t\t\t\t\t\tdist[next] = dist[cur] + e.w;\n\t\t\t\t\t\tq.add(next);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tUnionFind uf = new UnionFind(100000);\n\t\t\tfor (int i = 0; i < M; ++i) {\n\t\t\t\tif (type[i]) {\n\t\t\t\t\tif (A[i] < 0 || A[i] >= N || B[i] < 0 || B[i] >= N) continue;\n\t\t\t\t\tuf.union(A[i], B[i]);\n\t\t\t\t} else {\n\t\t\t\t\tif (A[i] < 0 || A[i] >= N || B[i] < 0 || B[i] >= N || !uf.find(A[i], B[i])) {\n\t\t\t\t\t\tout.println(\"UNKNOWN\");\n\t\t\t\t\t} else {\n\t\t\t\t\t\tout.println(dist[B[i]] - dist[A[i]]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic class Edge {\n\t\tint to, w;\n\n\t\tEdge(int to, int w) {\n\t\t\tthis.to = to;\n\t\t\tthis.w = w;\n\t\t}\n\t}\n\n\tstatic class UnionFind {\n\t\tint[] set;\n\n\t\tUnionFind(int n) {\n\t\t\tset = new int[n];\n\t\t\tArrays.fill(set, -1);\n\t\t}\n\n\t\tvoid union(int a, int b) {\n\t\t\tint rtA = root(a);\n\t\t\tint rtb = root(b);\n\t\t\tif (rtA == rtb) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tset[rtA] += set[rtb];\n\t\t\tset[rtb] = rtA;\n\t\t}\n\n\t\tboolean find(int a, int b) {\n\t\t\treturn root(a) == root(b);\n\t\t}\n\n\t\tint root(int a) {\n\t\t\tif (set[a] < 0) {\n\t\t\t\treturn a;\n\t\t\t} else {\n\t\t\t\tset[a] = root(set[a]);\n\t\t\t\treturn set[a];\n\t\t\t}\n\t\t}\n\n\t\tint size(int a) {\n\t\t\treturn -set[root(a)];\n\t\t}\n\t}\n\n\tstatic class FastScanner {\n\t\tReader input;\n\n\t\tFastScanner() {\n\t\t\tthis(System.in);\n\t\t}\n\n\t\tFastScanner(InputStream stream) {\n\t\t\tthis.input = new BufferedReader(new InputStreamReader(stream));\n\t\t}\n\n\t\tint nextInt() throws IOException {\n\t\t\tint sign = 1;\n\t\t\tint b = input.read();\n\t\t\twhile ((b < '0' || '9' < b) && b != '-' && b != '+') {\n\t\t\t\tif (b == -1) return 0;\n\t\t\t\tb = input.read();\n\t\t\t}\n\t\t\tif (b == '-') {\n\t\t\t\tsign = -1;\n\t\t\t\tb = input.read();\n\t\t\t} else if (b == '+') {\n\t\t\t\tb = input.read();\n\t\t\t}\n\t\t\tint ret = b - '0';\n\t\t\twhile (true) {\n\t\t\t\tb = input.read();\n\t\t\t\tif (b < '0' || '9' < b) return ret * sign;\n\t\t\t\tret *= 10;\n\t\t\t\tret += b - '0';\n\t\t\t}\n\t\t}\n\n\t\tchar nextChar() throws IOException {\n\t\t\tint b = input.read();\n\t\t\twhile (Character.isWhitespace((char) b)) {\n\t\t\t\tb = input.read();\n\t\t\t}\n\t\t\treturn (char) b;\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\n@SuppressWarnings(\"unchecked\")\n    class Main{\n        \n        int n, m;\n        int INF = Integer.MAX_VALUE/2;\n        ArrayList[] list;\n        long mod = 10000000;        \n\n        void solve(){\n            Scanner sc = new Scanner(System.in);\n            while(true){\n                n = sc.nextInt(); m = sc.nextInt();\n                if(n==0 && m==0) break;\n \n                list = new ArrayList[n+1];\n                for(int i=0; i<=n; i++) list[i] = new ArrayList<Long>();\n                for(int i=0; i<m; i++){\n                    char command = sc.next().charAt(0);\n                    if(command=='!'){\n                        long a = sc.nextLong(), b = sc.nextLong(), w = sc.nextLong();\n                        list[(int)a].add(b * mod + w);\n                        list[(int)b].add(-(a * mod + w));\n                    }else{\n                        int b = dijkstra(sc.nextInt(), sc.nextInt());\n                        if(b==INF) System.out.println(\"UNKNOWN\");\n                        else System.out.println(b);\n                    }\n                }\n            }\n        }\n        \n        int dijkstra(int start, int goal){\n            //pos, cost\n            LinkedList<int[]> q = new LinkedList<int[]>();\n            q.add(new int[]{start, 0});\n            boolean[] v = new boolean[n+1];\n \n            while(q.size()>0){\n                int[] qq = q.poll();\n                int pos = qq[0], cost = qq[1];\n \n                if(pos==goal) return cost;\n                if(v[pos]) continue;\n                v[pos] = true;\n\n                for(int i=0; i<list[pos].size(); i++){\n                    long X = (long)list[pos].get(i);\n                    int to = 0, weight = 0;\n                    if(X<0){\n                        X = -X;\n                        to = (int)(X / mod); weight = (int)-(X % mod);\n                    }else{\n                        to = (int)(X / mod); weight = (int)(X % mod);\n                    }\n                    q.add(new int[]{to, cost+weight});\n                }\n            }\n            return INF;\n        }\n \n        public static void main(String[] args){\n            new Main().solve();\n        }\n    }"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.io.Reader;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\n\npublic class Main {\n\tstatic FastScanner sc = new FastScanner(System.in);\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tint[] A = new int[100000];\n\t\tint[] B = new int[100000];\n\t\tint[] W = new int[100000];\n\t\tboolean[] type = new boolean[100000];\n\t\tint[] dist = new int[100000];\n\t\tArrayList<ArrayList<Edge>> graph = new ArrayList<ArrayList<Edge>>();\n\t\tfor (int i = 0; i < 100000; ++i) {\n\t\t\tgraph.add(new ArrayList<Edge>());\n\t\t}\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\twhile (true) {\n\t\t\tint N = sc.nextInt();\n\t\t\tint M = sc.nextInt();\n\t\t\tif (N == 0 || M == 0) break;\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tgraph.get(i).clear();\n\t\t\t}\n\t\t\tfor (int i = 0; i < M; ++i) {\n\t\t\t\ttype[i] = sc.nextChar() == '!';\n\t\t\t\tA[i] = sc.nextInt() - 1;\n\t\t\t\tB[i] = sc.nextInt() - 1;\n\t\t\t\tif (type[i]) {\n\t\t\t\t\tW[i] = sc.nextInt();\n\t\t\t\t\tgraph.get(A[i]).add(new Edge(B[i], W[i]));\n\t\t\t\t\tgraph.get(B[i]).add(new Edge(A[i], -W[i]));\n\t\t\t\t}\n\t\t\t}\n\t\t\tArrays.fill(dist, Integer.MIN_VALUE);\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tif (dist[i] != Integer.MIN_VALUE) continue;\n\t\t\t\tArrayDeque<Integer> q = new ArrayDeque<Integer>();\n\t\t\t\tq.add(i);\n\t\t\t\tdist[i] = 0;\n\t\t\t\twhile (!q.isEmpty()) {\n\t\t\t\t\tint cur = q.poll();\n\t\t\t\t\tfor (Edge e : graph.get(cur)) {\n\t\t\t\t\t\tint next = e.to;\n\t\t\t\t\t\tif (dist[next] != Integer.MIN_VALUE) continue;\n\t\t\t\t\t\tdist[next] = dist[cur] + e.w;\n\t\t\t\t\t\tq.add(next);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tUnionFind uf = new UnionFind(N);\n\t\t\tfor (int i = 0; i < M; ++i) {\n\t\t\t\tif (type[i]) {\n\t\t\t\t\tif (A[i] < 0 || A[i] >= N || B[i] < 0 || B[i] >= N) continue;\n\t\t\t\t\tuf.union(A[i], B[i]);\n\t\t\t\t} else {\n\t\t\t\t\tif (A[i] < 0 || A[i] >= N || B[i] < 0 || B[i] >= N /*|| !uf.find(A[i], B[i])*/) {\n\t\t\t\t\t\tout.println(\"UNKNOWN\");\n\t\t\t\t\t} else {\n\t\t\t\t\t\t//\t\t\t\t\t\tout.println(dist[B[i]] - dist[A[i]]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic class Edge {\n\t\tint to, w;\n\n\t\tEdge(int to, int w) {\n\t\t\tthis.to = to;\n\t\t\tthis.w = w;\n\t\t}\n\t}\n\n\tstatic class UnionFind {\n\t\tint[] set;\n\n\t\tUnionFind(int n) {\n\t\t\tset = new int[n];\n\t\t\tArrays.fill(set, -1);\n\t\t}\n\n\t\tvoid union(int a, int b) {\n\t\t\tint rtA = root(a);\n\t\t\tint rtb = root(b);\n\t\t\tif (rtA == rtb) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tset[rtA] += set[rtb];\n\t\t\tset[rtb] = rtA;\n\t\t}\n\n\t\tboolean find(int a, int b) {\n\t\t\treturn root(a) == root(b);\n\t\t}\n\n\t\tint root(int a) {\n\t\t\tif (set[a] < 0) {\n\t\t\t\treturn a;\n\t\t\t} else {\n\t\t\t\tset[a] = root(set[a]);\n\t\t\t\treturn set[a];\n\t\t\t}\n\t\t}\n\n\t\tint size(int a) {\n\t\t\treturn -set[root(a)];\n\t\t}\n\t}\n\n\tstatic class FastScanner {\n\t\tReader input;\n\n\t\tFastScanner() {\n\t\t\tthis(System.in);\n\t\t}\n\n\t\tFastScanner(InputStream stream) {\n\t\t\tthis.input = new BufferedReader(new InputStreamReader(stream));\n\t\t}\n\n\t\tint nextInt() throws IOException {\n\t\t\tint sign = 1;\n\t\t\tint b = input.read();\n\t\t\twhile ((b < '0' || '9' < b) && b != '-' && b != '+') {\n\t\t\t\tif (b == -1) return 0;\n\t\t\t\tb = input.read();\n\t\t\t}\n\t\t\tif (b == '-') {\n\t\t\t\tsign = -1;\n\t\t\t\tb = input.read();\n\t\t\t} else if (b == '+') {\n\t\t\t\tb = input.read();\n\t\t\t}\n\t\t\tint ret = b - '0';\n\t\t\twhile (true) {\n\t\t\t\tb = input.read();\n\t\t\t\tif (b < '0' || '9' < b) return ret * sign;\n\t\t\t\tret *= 10;\n\t\t\t\tret += b - '0';\n\t\t\t}\n\t\t}\n\n\t\tchar nextChar() throws IOException {\n\t\t\tint b = input.read();\n\t\t\twhile (Character.isWhitespace((char) b)) {\n\t\t\t\tb = input.read();\n\t\t\t}\n\t\t\treturn (char) b;\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.ListIterator;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\t\n\tpublic static class WeightUnionFind{\n\t\tint[] parent;\n\t\tint[] rank;\n\t\tint[] diff_weight;\n\t\t\n\t\tWeightUnionFind(int n){\n\t\t\tparent=new int[n];\n\t\t\trank = new int[n];\n\t\t\tdiff_weight = new int[n];\n\t\t\t\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tparent[i]=i;\n\t\t\t\trank[i] = 0;\n\t\t\t\tdiff_weight[i] = 0;\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic int find(int x){\n\t\t\tif(parent[x]==x){\n\t\t\t\treturn x;\n\t\t\t}\n\t\t\t\n\t\t\treturn find(parent[x]);\n\t\t}\n\t\t\n\t\tpublic int find_diff(int x){\n\t\t\tif(parent[x] == x){\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\t\n\t\t\treturn find_diff(parent[x]) + diff_weight[x];\n\t\t}\n\t\t\n\t\tpublic Boolean same(int x,int y){\n\t\t\treturn find(x)==find(y);\n\t\t}\n\t\t\n\t\tpublic int get_diff(int x, int y){\n\t\t\tif(!same(x, y)){\n\t\t\t\treturn Integer.MIN_VALUE;\n\t\t\t}else{\n\t\t\t\treturn find_diff(x) - find_diff(y);\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic void unite(int x,int y){\n\t\t\tx = find(x);\n\t\t\ty = find(y);\n\t\t\t\n\t\t\tif(x == y){\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tif(rank[x] < rank[y]){\n\t\t\t\tparent[x] = y;\n\t\t\t}else{\n\t\t\t\tparent[y] = x;\n\t\t\t\tif(rank[x] == rank[y]){\n\t\t\t\t\trank[x]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic void set_diff(int x,int y, int d){\n\t\t\tfinal int find_x = find(x);\n\t\t\tfinal int find_y = find(y);\n\t\t\t\n\t\t\tif(find_x == find_y){\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tif(rank[find_x] < rank[find_y]){\n\t\t\t\tdiff_weight[x] += d + find_diff(y);\n\t\t\t\t\n\t\t\t\tparent[find_x] = find_y;\n\t\t\t}else{\n\t\t\t\tdiff_weight[y] += - d + find_diff(x);\n\t\t\t\t\n\t\t\t\tparent[find_y] = find_x;\n\t\t\t\tif(rank[find_x] == rank[find_y]){\n\t\t\t\t\trank[find_x]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile (true) {\n\t\t\tfinal int N = sc.nextInt();\n\t\t\tfinal int M = sc.nextInt();\n\n\t\t\tif (N == 0 && M == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tSystem.gc();\n\t\t\t\n\t\t\tWeightUnionFind wuf = new WeightUnionFind(N);\n\t\t\t\n\t\t\tfor(int i = 0; i < M; i++){\n\t\t\t\tString op = sc.next();\n\t\t\t\t\n\t\t\t\tif(op.equals(\"!\")){\n\t\t\t\t\tfinal int from = sc.nextInt() - 1;\n\t\t\t\t\tfinal int to = sc.nextInt() - 1;\n\t\t\t\t\tfinal int w = sc.nextInt();\n\t\t\t\t\t\n\t\t\t\t\twuf.set_diff(from, to, w);\n\t\t\t\t\t//System.out.println(\"DIFF \" + from + \" \" + to + \" \" + w);\n\t\t\t\t}else{\n\t\t\t\t\tfinal int from = sc.nextInt() - 1;\n\t\t\t\t\tfinal int to = sc.nextInt() - 1;\n\t\t\t\t\t\n\t\t\t\t\tif(!wuf.same(from, to)){\n\t\t\t\t\t\tSystem.out.println(\"UNKOWN\");\n\t\t\t\t\t}else{\n\t\t\t\t\t\tSystem.out.println(wuf.get_diff(from, to));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t//System.out.println(\"P : \" + Arrays.toString(wuf.parent));\n\t\t\t\t//System.out.println(\"D : \" + Arrays.toString(wuf.diff_weight));\n\t\t\t}\n\t\t\t\n\t\t}\n\n\t\tsc.close();\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport static java.lang.Math.*;\n\npublic class Main {\n\tfinal Scanner sc = new Scanner(System.in);\n\tpublic static void main(String[] args) {\n\t\tnew Main().init();\n\t}\n\tvoid init(){\n\t\tfinal long stackSize = 8*1024*1024;\n\t\tnew Thread(null, new AOJ1330(), \"RUN\", stackSize).start();\n//\t\tnew AOJ1330();\n\t}\n\t\n\tclass AOJ1330 implements Runnable{\n\t\tAOJ1330(){\n//\t\t\twhile(sc.hasNext()){\n//\t\t\t\tN=sc.nextInt();\n//\t\t\t\tM=sc.nextInt();\n//\t\t\t\tif((N|M)==0)\tbreak;\n//\t\t\t\tsolve();\n//\t\t\t}\n\t\t}\n\t\t@Override public void run(){\n//\t\t\tlong start = System.currentTimeMillis();\n\t\t\twhile(sc.hasNext()){\n\t\t\t\tN=sc.nextInt();\n\t\t\t\tM=sc.nextInt();\n\t\t\t\tif((N|M)==0)\tbreak;\n\t\t\t\tsolve();\n\t\t\t}\n//\t\t\tSystem.out.println( (System.currentTimeMillis()-start)+\"ms\");\n\t\t}\n\t\t\n\t\tint N,M;\n\t\t\n\t\tvoid solve(){\n\t\t\tUnionFind uf = new UnionFind(N);\n\t\t\tfor(int i=0; i<M; ++i){\n\t\t\t\tif(sc.next().equals(\"!\")){\n\t\t\t\t\tint a=sc.nextInt(), b=sc.nextInt(), w=sc.nextInt();\n\t\t\t\t\t--a;\n\t\t\t\t\t--b;\n\t\t\t\t\tuf.unite(a, b, w);\n\t\t\t\t}else{\n\t\t\t\t\tint a=sc.nextInt(), b=sc.nextInt();\n\t\t\t\t\t--a;\n\t\t\t\t\t--b;\n\t\t\t\t\tint ret = uf.getWeight(a, b);\n\t\t\t\t\tSystem.out.println(ret>=uf.INF ? \"UNKNOWN\" : ret);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Union-Find Tree\n\t\tclass UnionFind{\n\t\t\tclass Node{\n\t\t\t\tint par,w;\n\t\t\t\tNode(int par,int w){\n\t\t\t\t\tthis.par=par;\n\t\t\t\t\tthis.w=w;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tNode[] node;\n\t\t\tfinal int INF = Integer.MAX_VALUE/4;\n\t\t\t\n\t\t\tUnionFind(int n){\n\t\t\t\tnode=new Node[n];\n\t\t\t\tfor(int i=0; i<n; ++i)\tnode[i]=new Node(i,0);\n\t\t\t}\n\t\t\t\n\t\t\tNode find(int x){\n\t\t\t\tif(node[x].par == x)\treturn node[x];\n\t\t\t\telse{\n\t\t\t\t\tNode tmp = find(node[x].par);\n\t\t\t\t\tnode[x].par = tmp.par;\n\t\t\t\t\tnode[x].w += tmp.w;\n\t\t\t\t\treturn node[x];\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tvoid unite(int x,int y,int w){\n\t\t\t\tNode tx=find(x);\n\t\t\t\tNode ty=find(y);\n\t\t\t\tif(tx.par==ty.par)\treturn;\n\t\t\t\t\n\t\t\t\tnode[tx.par].w = w - tx.w;\n\t\t\t\tnode[tx.par].par = y;\n\t\t\t}\n\t\t\t\n\t\t\tint getWeight(int x,int y){\n\t\t\t\tNode tx = find(x);\n\t\t\t\tNode ty = find(y);\n\t\t\t\treturn (tx.par==ty.par ? tx.w-ty.w : INF);\n\t\t\t}\n\t\t\t\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n \npublic class Main {\n    public static int N;\n    public static int M;\n    public static int[] p;\n    public static int[] rank;\n    public static int[] weight;\n\n    public static boolean same(int x, int y) {\n        return findSet(x) == findSet(y);\n    }\n \n    public static void unite(int x, int y, int w) {\n        int i = findSet(x);\n        int j = findSet(y);\n        w -= weight[b] - weight[a];\n\n        if (i == j){\n\t    return;\n\t}\n        if (rank[i] > rank[j]){\n            p[j] = p[i];\n            weight[j] = w;\n        } else {\n            p[i] = p[j];\n            weight[i] = -w;\n            if(rank[i] == rank[j]){\n            rank[j]++;\n            }\n        }\t\n    }\n \n    public static int findSet(int i) {\n       if(p[i] == i){ \n           return i;\n        }else{\n          return p[i] = findSet(p[i]);\n        }\n    }\n \n    public static void DisjointSet() {\n        p = new int[N];\n        rank = new int[N];\n        weight = new int[N]\n \n        for (int i = 0; i < N; i++) {\n            p[i] = i;\n            rank[i] = 0;\n            weight[i] = 0;\n        }\n    }\n \n \n    public static void main (String[] args){\n        Scanner scanner = new Scanner(System.in);\n        while(true){\n        N = scanner.nextInt();\n        M = scanner.nextInt();\n\n        if(N==0 & M==0){\n           break;\n        }\n \n        DisjointSet();\n\n        for (int i = 0; i < M; i++) {\n            if(scanner.next().equals(\"!\")){\n            int a = scanner.nextInt();\n            int b = scanner.nextInt();\n            int w = scanner.nextInt();\n \n            a--; b--;   \n            unite(a, b, w);\n            }else{\n               if(same(x, y)){\n                    System.out.println(\"UNKNOWN\");\n                }else{\n                    System.out.println(weight[b]-weight[a]);\n\t\t}\n            }\n        }\n       }\n      }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.Reader;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\n\npublic class Main {\n\tstatic FastScanner sc = new FastScanner(System.in);\n\n\tpublic static void main(String[] args) throws Exception {\n\t\ttry {\n\t\t\twhile (true) {\n\t\t\t\tint N = sc.nextInt();\n\t\t\t\tif (N == 0) break;\n\t\t\t\tint M = sc.nextInt();\n\t\t\t\tint[] A = new int[M];\n\t\t\t\tint[] B = new int[M];\n\t\t\t\tint[] W = new int[M];\n\t\t\t\tboolean[] type = new boolean[M];\n\t\t\t\tArrayList<ArrayList<Edge>> graph = new ArrayList<ArrayList<Edge>>();\n\t\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\t\tgraph.add(new ArrayList<Edge>());\n\t\t\t\t}\n\t\t\t\tfor (int i = 0; i < M; ++i) {\n\t\t\t\t\ttype[i] = sc.nextChar() == '!';\n\t\t\t\t\tA[i] = sc.nextInt() - 1;\n\t\t\t\t\tB[i] = sc.nextInt() - 1;\n\t\t\t\t\tif (type[i]) {\n\t\t\t\t\t\tW[i] = sc.nextInt();\n\t\t\t\t\t\tgraph.get(A[i]).add(new Edge(B[i], W[i]));\n\t\t\t\t\t\tgraph.get(B[i]).add(new Edge(A[i], -W[i]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tint[] dist = new int[N];\n\t\t\t\tArrays.fill(dist, Integer.MIN_VALUE);\n\t\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\t\tif (dist[i] != Integer.MIN_VALUE) continue;\n\t\t\t\t\tArrayDeque<Integer> q = new ArrayDeque<Integer>();\n\t\t\t\t\tq.add(i);\n\t\t\t\t\tdist[i] = 0;\n\t\t\t\t\twhile (!q.isEmpty()) {\n\t\t\t\t\t\tint cur = q.poll();\n\t\t\t\t\t\tfor (Edge e : graph.get(cur)) {\n\t\t\t\t\t\t\tint next = e.to;\n\t\t\t\t\t\t\tif (dist[next] != Integer.MIN_VALUE) continue;\n\t\t\t\t\t\t\tdist[next] = dist[cur] + e.w;\n\t\t\t\t\t\t\tq.add(next);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tUnionFind uf = new UnionFind(N);\n\t\t\t\tfor (int i = 0; i < M; ++i) {\n\t\t\t\t\tif (type[i]) {\n\t\t\t\t\t\tuf.union(A[i], B[i]);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (!uf.find(A[i], B[i])) {\n\t\t\t\t\t\t\tSystem.out.println(\"UNKNOWN\");\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tSystem.out.println(dist[B[i]] - dist[A[i]]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (ArrayIndexOutOfBoundsException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\n\tstatic class Edge {\n\t\tint to, w;\n\n\t\tEdge(int to, int w) {\n\t\t\tthis.to = to;\n\t\t\tthis.w = w;\n\t\t}\n\t}\n\n\tstatic class UnionFind {\n\t\tint[] set;\n\n\t\tUnionFind(int n) {\n\t\t\tset = new int[n];\n\t\t\tArrays.fill(set, -1);\n\t\t}\n\n\t\tvoid union(int a, int b) {\n\t\t\tint rtA = root(a);\n\t\t\tint rtb = root(b);\n\t\t\tif (rtA == rtb) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tset[rtA] += set[rtb];\n\t\t\tset[rtb] = rtA;\n\t\t}\n\n\t\tboolean find(int a, int b) {\n\t\t\treturn root(a) == root(b);\n\t\t}\n\n\t\tint root(int a) {\n\t\t\tif (set[a] < 0) {\n\t\t\t\treturn a;\n\t\t\t} else {\n\t\t\t\tset[a] = root(set[a]);\n\t\t\t\treturn set[a];\n\t\t\t}\n\t\t}\n\n\t\tint size(int a) {\n\t\t\treturn -set[root(a)];\n\t\t}\n\t}\n\n\tstatic class FastScanner {\n\t\tReader input;\n\n\t\tFastScanner() {\n\t\t\tthis(System.in);\n\t\t}\n\n\t\tFastScanner(InputStream stream) {\n\t\t\tthis.input = new BufferedReader(new InputStreamReader(stream));\n\t\t}\n\n\t\tint nextInt() throws IOException {\n\t\t\tint sign = 1;\n\t\t\tint b = input.read();\n\t\t\twhile ((b < '0' || '9' < b) && b != '-' && b != '+') {\n\t\t\t\tb = input.read();\n\t\t\t}\n\t\t\tif (b == '-') {\n\t\t\t\tsign = -1;\n\t\t\t\tb = input.read();\n\t\t\t} else if (b == '+') {\n\t\t\t\tb = input.read();\n\t\t\t}\n\t\t\tint ret = b - '0';\n\t\t\twhile (true) {\n\t\t\t\tb = input.read();\n\t\t\t\tif (b < '0' || '9' < b) return ret * sign;\n\t\t\t\tret *= 10;\n\t\t\t\tret += b - '0';\n\t\t\t}\n\t\t}\n\n\t\tchar nextChar() throws IOException {\n\t\t\tint b = input.read();\n\t\t\twhile (Character.isWhitespace((char) b)) {\n\t\t\t\tb = input.read();\n\t\t\t}\n\t\t\treturn (char) b;\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.ListIterator;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n  \npublic class Main {\n      \n    public static class WeightUnionFind{\n        int[] parent;\n        int[] rank;\n        int[] diff_weight;\n          \n        WeightUnionFind(int n){\n            parent=new int[n];\n            rank = new int[n];\n            diff_weight = new int[n];\n              \n            for(int i=0;i<n;i++){\n                parent[i]=i;\n                rank[i] = 0;\n                diff_weight[i] = 0;\n            }\n        }\n          \n        public int find(int x){\n            if(parent[x]==x){\n                return x;\n            }\n              \n            return find(parent[x]);\n        }\n          \n        public int find_diff(int x){\n            if(parent[x] == x){\n                return 0;\n            }\n              \n            return find_diff(parent[x]) + diff_weight[x];\n        }\n          \n        public Boolean same(int x,int y){\n            return find(x)==find(y);\n        }\n          \n        public int get_diff(int x, int y){\n            if(!same(x, y)){\n                return Integer.MIN_VALUE;\n            }else{\n                return find_diff(x) - find_diff(y);\n            }\n        }\n        /*\n        public void unite(int x,int y){\n            x = find(x);\n            y = find(y);\n              \n            if(x == y){\n                return;\n            }\n              \n            if(rank[x] < rank[y]){\n                parent[x] = y;\n            }else{\n                parent[y] = x;\n                if(rank[x] == rank[y]){\n                    rank[x]++;\n                }\n            }\n        }\n        */\n        public void set_diff(int x,int y, int d){\n            final int find_x = find(x);\n            final int find_y = find(y);\n              \n            if(find_x == find_y){\n                return;\n            }\n              \n            //System.out.println(x + \" \" + find_x + \" \" + y + \" \" + find_y + \" \" + diff_weight[y] + \" \" + diff_weight[x]);\n            d -= find_diff(x) - find_diff(y);\n              \n            if(rank[find_x] < rank[find_y]){\n                //diff_weight[x] += d + find_diff(y);\n                diff_weight[find_x] = d;\n                  \n                parent[find_x] = find_y;\n            }else{\n                diff_weight[find_y] = -d;\n                  \n                parent[find_y] = find_x;\n                if(rank[find_x] == rank[find_y]){\n                    rank[find_x]++;\n                }\n            }\n        }\n    }\n  \n      \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n          \n        while (true) {\n            final int N = sc.nextInt();\n            final int M = sc.nextInt();\n  \n            if (N == 0 && M == 0) {\n                break;\n            }\n              \n            System.gc();\n              \n            WeightUnionFind wuf = new WeightUnionFind(N);\n              \n            for(int i = 0; i < M; i++){\n                String op = sc.next();\n                  \n                if(op.equals(\"!\")){\n                    final int from = sc.nextInt() - 1;\n                    final int to = sc.nextInt() - 1;\n                    final int w = sc.nextInt();\n                      \n                    wuf.set_diff(from, to, w);\n                    //System.out.println(\"DIFF \" + from + \" \" + to + \" \" + w);\n                }else{\n                    final int from = sc.nextInt() - 1;\n                    final int to = sc.nextInt() - 1;\n                      \n                    if(!wuf.same(from, to)){\n                        System.out.println(\"UNKNOWN\");\n                    }else{\n                        System.out.println(wuf.get_diff(from, to));\n                    }\n                }\n                  \n                //System.out.println(\"P : \" + Arrays.toString(wuf.parent));\n                //System.out.println(\"D : \" + Arrays.toString(wuf.diff_weight));\n            }\n              \n        }\n  \n        sc.close();\n    }\n  \n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\n@SuppressWarnings(\"unchecked\")\n    class Main{\n        \n        int n, m;\n        int INF = Integer.MAX_VALUE/2;\n        ArrayList[] list;\n        long mod = 10000000;        \n\n        void solve(){\n            Scanner sc = new Scanner(System.in);\n            while(true){\n                n = sc.nextInt(); m = sc.nextInt();\n                if(n==0 && m==0) break;\n \n                list = new ArrayList[n+1];\n                for(int i=0; i<=n; i++) list[i] = new ArrayList<Long>();\n                for(int i=0; i<m; i++){\n                    char command = sc.next().charAt(0);\n                    if(command=='!'){\n                        long a = sc.nextLong(), b = sc.nextLong(), w = sc.nextLong();\n                        list[(int)a].add(b * mod + w);\n                        list[(int)b].add(-(a * mod + w));\n                    }else{\n                        int b = dijkstra(sc.nextInt(), sc.nextInt());\n                        if(b==INF) System.out.println(\"UNKNOWN\");\n                        else System.out.println(b);\n                    }\n                }\n            }\n        }\n        \n        int dijkstra(int start, int goal){\n            //pos, cost\n            LinkedList<Long> q = new LinkedList<Long>();\n            q.add((long)start*mod);\n            boolean[] v = new boolean[n+1];\n \n            while(q.size()>0){\n                long qq = q.poll();\n                long pos = 0, cost = 0;\n                if(qq<0){\n                    qq = -qq;\n                    pos = qq/mod; cost = -(qq%mod);\n                }else{\n                    pos = qq/mod; cost = qq%mod;\n                }\n \n                if(pos==goal) return (int)cost;\n                if(v[(int)pos]) continue;\n                v[(int)pos] = true;\n\n                for(int i=0; i<list[(int)pos].size(); i++){\n                    long X = (long)(Long)list[(int)pos].get(i);\n                    long to = 0, weight = 0;\n                    if(X<0){\n                        X = -X;\n                        to = X / mod; weight = -(X % mod);\n                    }else{\n                        to = X / mod; weight = X % mod;\n                    }\n                    long neww = cost + weight;\n                    if(neww<0){\n                        long newl = to * mod + (-neww);\n                        q.add(-newl);\n                    }else{\n                        long newl = to * mod + neww;\n                        q.add(newl);\n                    }\n                }\n            }\n            return INF;\n        }\n \n        public static void main(String[] args){\n            new Main().solve();\n        }\n    }"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.Reader;\nimport java.util.Arrays;\nimport java.util.Scanner;\nimport java.util.StringTokenizer;\n \npublic class Main {\n \n    public static class WeightedUnionFind{\n        int[] par; // ????????????\n        int[] ws;  // ?????¨???????????????\n         \n        public WeightedUnionFind(int n){\n            par = new int[n];\n            ws  = new int[n];\n            for(int i = 0; i < n; i++){ \n                par[i] = -1;\n            }\n        }\n         \n        public int find(int x){\n            if(par[x] < 0){\n                return x;\n            }else{\n                final int parent = find(par[x]);\n                ws[x] += ws[par[x]];\n                par[x] = parent;\n                return parent;\n            }\n        }\n         \n        public int weight(int x){\n            find(x);\n            return ws[x];\n        }\n         \n        public boolean union(int x, int y, int w){ // x <-(w)- y (x + w = y)\n            w += weight(x);\n            w -= weight(y);\n            x = find(x);\n            y = find(y);\n             \n            if(x != y){\n                if(par[y] < par[x]) {  // ???????????????????????????????????????????????????.\n                    int tmp = x; x = y; y = tmp;\n                    w = -w;\n                }\n                par[x] += par[y];\n                par[y] = x;\n                ws[y] = w;\n                 \n                return true;\n            }else{\n                return false;\n            }\n        }\n         \n        public boolean same(int x, int y){\n            return find(x) == find(y);\n        }\n         \n        public Integer diff(int x, int y){ // x - y ????±???????. ??????????????????null.\n            if(!same(x, y)){\n                return null;\n            }else{\n                return this.weight(x) - this.weight(y);\n            }\n        }\n         \n        public int size(int x){\n            return -par[find(x)];\n        }\n    }\n     \n    public static void main(String[] args) throws IOException {\n        Scanner sc = new Scanner(System.in);\n \n        while(true){\n            final int n = sc.nextInt();\n            final int m = sc.nextInt();\n             \n            if(n == 0 && m == 0){\n                break;\n            }\n             \n            WeightedUnionFind uf = new WeightedUnionFind(n);\n             \n            for(int i = 0; i < m; i++){\n                final char ops = sc.nextChar();\n                 \n                if('?' == ops){\n                    final int r = sc.nextInt() - 1;\n                    final int l = sc.nextInt() - 1;\n                    final Integer ret = uf.diff(r, l);\n                    System.out.println(ret == null ? \"UNKNOWN\" : -ret);\n                }else{\n                    final int r = sc.nextInt() - 1;\n                    final int l = sc.nextInt() - 1;\n                    final int w = sc.nextInt();\n                     \n                    uf.union(r, l, w);\n                }\n            }\n        }\n         \n        sc.close();\n    }\n     \n    public static class Scanner {\n        private Reader br;\n \n        public Scanner(InputStream is) throws IOException {\n            br = new BufferedReader(new InputStreamReader(is));\n        }\n         \n        public int nextInt() throws IOException {\n            int sign = 1;\n            int b = br.read();\n             \n            while(((b < '0') || ('9' < b)) && b != '-' && b != '+'){\n                if(b == -1){ return 0; }\n                b = br.read();\n            }\n             \n            if(b == '-'){\n                sign = -1;\n                b = br.read();\n            }else if(b == '+'){\n                b = br.read();\n            }\n             \n            int ret = b - '0';\n            while(true){\n                b = br.read();\n                if(b < '0' || b > '9'){ return sign * ret; }\n                ret *= 10;\n                ret += b - '0';\n            }\n        }\n         \n        public char nextChar() throws IOException{\n            int b = br.read();\n            while(Character.isWhitespace(b)){\n                b = br.read();\n            }\n            return (char)(b);\n        }\n         \n        public void close() throws IOException {\n            br.close();\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.Reader;\nimport java.util.Arrays;\nimport java.util.Scanner;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\n\tpublic static class WeightedUnionFind{\n\t    int[] par; // 親の番号\n\t    int[] ws;  // 親との重みの差\n\t    \n\t    public WeightedUnionFind(int n){\n\t        par = new int[n];\n\t        ws  = new int[n];\n\t        for(int i = 0; i < n; i++){ \n\t        \tpar[i] = -1;\n\t        }\n\t    }\n\t    \n\t    public int find(int x){\n\t    \tif(par[x] < 0){\n\t    \t\treturn x;\n\t    \t}else{\n\t    \t\tfinal int parent = find(par[x]);\n\t    \t\tws[x] += ws[par[x]];\n\t    \t\tpar[x] = parent;\n\t    \t\treturn parent;\n\t    \t}\n\t    }\n\t    \n\t    public int weight(int x){\n\t    \tfind(x);\n\t    \treturn ws[x];\n\t    }\n\t    \n\t    public boolean union(int x, int y, int w){ // x <-(w)- y (x + w = y)\n\t    \tw += weight(x);\n\t    \tw -= weight(y);\n\t        x = find(x);\n\t        y = find(y);\n\t        \n\t        if(x != y){\n\t            if(par[y] < par[x]) {  // 多い方が根になるようにスワップする.\n\t                int tmp = x; x = y; y = tmp;\n\t                w = -w;\n\t            }\n\t            par[x] += par[y];\n\t            par[y] = x;\n\t            ws[y] = w;\n\t            \n\t            return true;\n\t        }else{\n\t            return false;\n\t        }\n\t    }\n\t    \n\t    public boolean same(int x, int y){\n\t        return find(x) == find(y);\n\t    }\n\t    \n\t    public Integer diff(int x, int y){ // x - y を求める. 比較不能ならnull.\n\t    \tif(!same(x, y)){\n\t    \t\treturn null;\n\t    \t}else{\n\t    \t\treturn this.weight(x) - this.weight(y);\n\t    \t}\n\t    }\n\t    \n\t    public int size(int x){\n\t        return -par[find(x)];\n\t    }\n\t}\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tScanner sc = new Scanner(System.in);\n\n\t\twhile(true){\n\t\t\tfinal int n = sc.nextInt();\n\t\t\tfinal int m = sc.nextInt();\n\t\t\t\n\t\t\tif(n == 0 && m == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tWeightedUnionFind uf = new WeightedUnionFind(n);\n\t\t\t\n\t\t\tfor(int i = 0; i < m; i++){\n\t\t\t\tfinal String ops = sc.next();\n\t\t\t\t\n\t\t\t\tif(\"?\".equals(ops)){\n\t\t\t\t\tfinal int r = sc.nextInt() - 1;\n\t\t\t\t\tfinal int l = sc.nextInt() - 1;\n\t\t\t\t\t\n\t\t\t\t\tif(!uf.same(r, l)){\n\t\t\t\t\t\tSystem.out.println(\"UNKNOWN\");\n\t\t\t\t\t}else{\n\t\t\t\t\t\tSystem.out.println(uf.weight(l) - uf.weight(r));\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tfinal int r = sc.nextInt() - 1;\n\t\t\t\t\tfinal int l = sc.nextInt() - 1;\n\t\t\t\t\tfinal int w = sc.nextInt();\n\t\t\t\t\t\n\t\t\t\t\tuf.union(r, l, w);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tsc.close();\n\t}\n\t\n\tpublic static class Scanner {\n\t    private BufferedReader br;\n\t    private StringTokenizer tok;\n\n\t    public Scanner(InputStream is) throws IOException {\n\t        br = new BufferedReader(new InputStreamReader(is));\n\t    }\n\n\t    private void getLine() throws IOException {\n\t        while (!hasNext()) { tok = new StringTokenizer(br.readLine()); }\n\t    }\n\n\t    private boolean hasNext() {\n\t        return tok != null && tok.hasMoreTokens();\n\t    }\n\n\t    public String next() throws IOException {\n\t        getLine(); return tok.nextToken();\n\t    }\n\n\t    public int nextInt() throws IOException {\n\t        return Integer.parseInt(next());\n\t    }\n\t    // 他のnextXXXもXXX.parseXXX()メソッドを使って作れるので省略\n\t    \n\t    public void close() throws IOException {\n\t        br.close();\n\t    }\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.Reader;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic Scanner sc = new Scanner(System.in);\n\n\tpublic static void main(String[] args) throws Exception {\n//\t\tint[] A = new int[100000];\n//\t\tint[] B = new int[100000];\n//\t\tint[] W = new int[100000];\n//\t\tboolean[] type = new boolean[100000];\n//\t\tint[] dist = new int[100000];\n//\t\tArrayList<ArrayList<Edge>> graph = new ArrayList<ArrayList<Edge>>();\n//\t\tfor (int i = 0; i < 100000; ++i) {\n//\t\t\tgraph.add(new ArrayList<Edge>());\n//\t\t}\n\t\twhile (sc.hasNextInt()) {\n\t\t\tint N = sc.nextInt();\n\t\t\tint M = sc.nextInt();\n\t\t\tif (N == 0 || M == 0) break;\n\t\t\tsc.nextLine();\n//\t\t\tfor (int i = 0; i < 100000; ++i) {\n//\t\t\t\tgraph.get(i).clear();\n//\t\t\t}\n\t\t\tfor (int i = 0; i < M; ++i) {\n//\t\t\t\tif (!sc.hasNextLine()) {\n//\t\t\t\t\tM = i;\n//\t\t\t\t\tbreak;\n//\t\t\t\t}\n\t\t\t\tif (!sc.hasNextLine()) return;\n\t\t\t\tString line = sc.nextLine();\n//\t\t\t\tString[] line = sc.nextLine().split(\" \");\n//\t\t\t\ttype[i] = line[0].charAt(0) == '!';\n//\t\t\t\tA[i] = Integer.parseInt(line[1]) - 1;\n//\t\t\t\tB[i] = Integer.parseInt(line[2]) - 1;\n//\t\t\t\tif (type[i]) {\n//\t\t\t\t\tW[i] = Integer.parseInt(line[3]);\n//\t\t\t\t\tgraph.get(A[i]).add(new Edge(B[i], W[i]));\n//\t\t\t\t\tgraph.get(B[i]).add(new Edge(A[i], -W[i]));\n//\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.gc();\n//\t\t\tArrays.fill(dist, Integer.MIN_VALUE);\n//\t\t\tfor (int i = 0; i < N; ++i) {\n//\t\t\t\tif (dist[i] != Integer.MIN_VALUE) continue;\n//\t\t\t\tArrayDeque<Integer> q = new ArrayDeque<Integer>();\n//\t\t\t\tq.add(i);\n//\t\t\t\tdist[i] = 0;\n//\t\t\t\twhile (!q.isEmpty()) {\n//\t\t\t\t\tint cur = q.poll();\n//\t\t\t\t\tfor (Edge e : graph.get(cur)) {\n//\t\t\t\t\t\tint next = e.to;\n//\t\t\t\t\t\tif (dist[next] != Integer.MIN_VALUE) continue;\n//\t\t\t\t\t\tdist[next] = dist[cur] + e.w;\n//\t\t\t\t\t\tq.add(next);\n//\t\t\t\t\t}\n//\t\t\t\t}\n//\t\t\t}\n//\n//\t\t\tUnionFind uf = new UnionFind(100000);\n//\t\t\tfor (int i = 0; i < M; ++i) {\n//\t\t\t\tif (type[i]) {\n//\t\t\t\t\tuf.union(A[i], B[i]);\n//\t\t\t\t} else {\n//\t\t\t\t\tif (!uf.find(A[i], B[i])) {\n//\t\t\t\t\t\tSystem.out.println(\"UNKNOWN\");\n//\t\t\t\t\t} else {\n//\t\t\t\t\t\tSystem.out.println(dist[B[i]] - dist[A[i]]);\n//\t\t\t\t\t}\n//\t\t\t\t}\n//\t\t\t}\n\t\t}\n\t}\n\n\tstatic class Edge {\n\t\tint to, w;\n\n\t\tEdge(int to, int w) {\n\t\t\tthis.to = to;\n\t\t\tthis.w = w;\n\t\t}\n\t}\n\n\tstatic class UnionFind {\n\t\tint[] set;\n\n\t\tUnionFind(int n) {\n\t\t\tset = new int[n];\n\t\t\tArrays.fill(set, -1);\n\t\t}\n\n\t\tvoid union(int a, int b) {\n\t\t\tint rtA = root(a);\n\t\t\tint rtb = root(b);\n\t\t\tif (rtA == rtb) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tset[rtA] += set[rtb];\n\t\t\tset[rtb] = rtA;\n\t\t}\n\n\t\tboolean find(int a, int b) {\n\t\t\treturn root(a) == root(b);\n\t\t}\n\n\t\tint root(int a) {\n\t\t\tif (set[a] < 0) {\n\t\t\t\treturn a;\n\t\t\t} else {\n\t\t\t\tset[a] = root(set[a]);\n\t\t\t\treturn set[a];\n\t\t\t}\n\t\t}\n\n\t\tint size(int a) {\n\t\t\treturn -set[root(a)];\n\t\t}\n\t}\n\n\tstatic class FastScanner {\n\t\tReader input;\n\n\t\tFastScanner() {\n\t\t\tthis(System.in);\n\t\t}\n\n\t\tFastScanner(InputStream stream) {\n\t\t\tthis.input = new BufferedReader(new InputStreamReader(stream));\n\t\t}\n\n\t\tint nextInt() throws IOException {\n\t\t\tint sign = 1;\n\t\t\tint b = input.read();\n\t\t\twhile ((b < '0' || '9' < b) && b != '-' && b != '+') {\n\t\t\t\tif (b == -1) return 0;\n\t\t\t\tb = input.read();\n\t\t\t}\n\t\t\tif (b == '-') {\n\t\t\t\tsign = -1;\n\t\t\t\tb = input.read();\n\t\t\t} else if (b == '+') {\n\t\t\t\tb = input.read();\n\t\t\t}\n\t\t\tint ret = b - '0';\n\t\t\twhile (true) {\n\t\t\t\tb = input.read();\n\t\t\t\tif (b < '0' || '9' < b) return ret * sign;\n\t\t\t\tret *= 10;\n\t\t\t\tret += b - '0';\n\t\t\t}\n\t\t}\n\n\t\tchar nextChar() throws IOException {\n\t\t\tint b = input.read();\n\t\t\twhile (Character.isWhitespace((char) b)) {\n\t\t\t\tb = input.read();\n\t\t\t}\n\t\t\treturn (char) b;\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tnew Main().solver();\n\t}\n\n\tvoid solver() {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint N = sc.nextInt();\n\t\t\tint M = sc.nextInt();\n\t\t\tif (N == 0 && M == 0)\n\t\t\t\tbreak;\n\t\t\tWeightedUnionFind uf = new WeightedUnionFind(N);\n\t\t\tfor (int i = 0; i < M; i++) {\n\t\t\t\tString s = sc.next();\n\t\t\t\tint x = sc.nextInt() - 1;\n\t\t\t\tint y = sc.nextInt() - 1;\n\t\t\t\tif (s.equals(\"!\")) {\n\t\t\t\t\tlong w = sc.nextLong();\n\t\t\t\t\tuf.union(x, y, w);\n\t\t\t\t} else {\n\t\t\t\t\tif (!uf.same(x, y)) {\n\t\t\t\t\t\tSystem.out.println(\"UNKNOWN\");\n\t\t\t\t\t} else {\n\t\t\t\t\t\tSystem.out.println(-uf.diff(x, y));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsc.close();\n\t}\n\n\tclass WeightedUnionFind {\n\t\tint[] par;\n\t\tlong[] wd;\n\n\t\tpublic WeightedUnionFind(int n) {\n\t\t\tpar = new int[n];\n\t\t\twd = new long[n];\n\t\t\tArrays.fill(par, -1);\n\t\t}\n\n\t\tint find(int x) {\n\t\t\tif (par[x] < 0)\n\t\t\t\treturn x;\n\t\t\telse {\n\t\t\t\tfinal int parent = find(par[x]);\n\t\t\t\twd[x] += wd[par[x]];\n\t\t\t\tpar[x] = parent;\n\t\t\t\treturn parent;\n\t\t\t}\n\t\t}\n\n\t\tboolean same(int x, int y) {\n\t\t\treturn find(x) == find(y);\n\t\t}\n\n\t\tlong weight(int x) {\n\t\t\tfind(x);\n\t\t\treturn wd[x];\n\t\t}\n\n\t\t// y - x = w ??? y = x + w;\n\t\tboolean union(int x, int y, long w) {\n\t\t\tif (find(x) == find(y))\n\t\t\t\treturn false;\n\t\t\telse {\n\t\t\t\tw += (weight(x) - weight(y));\n\t\t\t\tx = find(x);\n\t\t\t\ty = find(y);\n\t\t\t\tif (par[y] < par[x]) { // ???????????????????????????????????????????????????.\n\t\t\t\t\tint tmp = x;\n\t\t\t\t\tx = y;\n\t\t\t\t\ty = tmp;\n\t\t\t\t\tw = -w;\n\t\t\t\t}\n\t\t\t\tpar[y] = x;\n\t\t\t\twd[y] = w;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\t// return x-y\n\t\tlong diff(int x, int y) {\n\t\t\tif (!same(x, y)) {\n\t\t\t\tthrow new AssertionError();\n\t\t\t} else {\n\t\t\t\treturn this.weight(x) - this.weight(y);\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.Reader;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\n\npublic class Main {\n\tstatic FastScanner sc = new FastScanner(System.in);\n\n\tpublic static void main(String[] args) throws Exception {\n\t\twhile (true) {\n\t\t\tint N = sc.nextInt();\n\t\t\tif (N == 0) break;\n\t\t\tint M = sc.nextInt();\n\t\t\tint[] A = new int[M];\n\t\t\tint[] B = new int[M];\n\t\t\tint[] W = new int[M];\n\t\t\tboolean[] type = new boolean[M];\n\t\t\tint[] dist = new int[N];\n\t\t\tArrayList<ArrayList<Edge>> graph = new ArrayList<ArrayList<Edge>>();\n\t\t\ttry {\n\t\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\t\tgraph.add(new ArrayList<Edge>());\n\t\t\t\t}\n\t\t\t\tfor (int i = 0; i < M; ++i) {\n\t\t\t\t\ttype[i] = sc.nextChar() == '!';\n\t\t\t\t\tA[i] = sc.nextInt() - 1;\n\t\t\t\t\tB[i] = sc.nextInt() - 1;\n\t\t\t\t\tif (type[i]) {\n\t\t\t\t\t\tW[i] = sc.nextInt();\n\t\t\t\t\t\tgraph.get(A[i]).add(new Edge(B[i], W[i]));\n\t\t\t\t\t\tgraph.get(B[i]).add(new Edge(A[i], -W[i]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tArrays.fill(dist, Integer.MIN_VALUE);\n\t\t\t} catch (RuntimeException e) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\t\tif (dist[i] != Integer.MIN_VALUE) continue;\n\t\t\t\t\tArrayDeque<Integer> q = new ArrayDeque<Integer>();\n\t\t\t\t\tq.add(i);\n\t\t\t\t\tdist[i] = 0;\n\t\t\t\t\twhile (!q.isEmpty()) {\n\t\t\t\t\t\tint cur = q.poll();\n\t\t\t\t\t\tfor (Edge e : graph.get(cur)) {\n\t\t\t\t\t\t\tint next = e.to;\n\t\t\t\t\t\t\tif (dist[next] != Integer.MIN_VALUE) continue;\n\t\t\t\t\t\t\tdist[next] = dist[cur] + e.w;\n\t\t\t\t\t\t\tq.add(next);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} catch (RuntimeException e) {\n\t\t\t\tfor (int i = 0;; ++i) {\n\t\t\t\t\t;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tUnionFind uf = new UnionFind(N);\n\t\t\tfor (int i = 0; i < M; ++i) {\n\t\t\t\tif (type[i]) {\n\t\t\t\t\tuf.union(A[i], B[i]);\n\t\t\t\t} else {\n\t\t\t\t\tif (!uf.find(A[i], B[i])) {\n\t\t\t\t\t\tSystem.out.println(\"UNKNOWN\");\n\t\t\t\t\t} else {\n\t\t\t\t\t\tSystem.out.println(dist[B[i]] - dist[A[i]]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic class Edge {\n\t\tint to, w;\n\n\t\tEdge(int to, int w) {\n\t\t\tthis.to = to;\n\t\t\tthis.w = w;\n\t\t}\n\t}\n\n\tstatic class UnionFind {\n\t\tint[] set;\n\n\t\tUnionFind(int n) {\n\t\t\tset = new int[n];\n\t\t\tArrays.fill(set, -1);\n\t\t}\n\n\t\tvoid union(int a, int b) {\n\t\t\tint rtA = root(a);\n\t\t\tint rtb = root(b);\n\t\t\tif (rtA == rtb) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tset[rtA] += set[rtb];\n\t\t\tset[rtb] = rtA;\n\t\t}\n\n\t\tboolean find(int a, int b) {\n\t\t\treturn root(a) == root(b);\n\t\t}\n\n\t\tint root(int a) {\n\t\t\tif (set[a] < 0) {\n\t\t\t\treturn a;\n\t\t\t} else {\n\t\t\t\tset[a] = root(set[a]);\n\t\t\t\treturn set[a];\n\t\t\t}\n\t\t}\n\n\t\tint size(int a) {\n\t\t\treturn -set[root(a)];\n\t\t}\n\t}\n\n\tstatic class FastScanner {\n\t\tReader input;\n\n\t\tFastScanner() {\n\t\t\tthis(System.in);\n\t\t}\n\n\t\tFastScanner(InputStream stream) {\n\t\t\tthis.input = new BufferedReader(new InputStreamReader(stream));\n\t\t}\n\n\t\tint nextInt() throws IOException {\n\t\t\tint sign = 1;\n\t\t\tint b = input.read();\n\t\t\twhile ((b < '0' || '9' < b) && b != '-' && b != '+') {\n\t\t\t\tb = input.read();\n\t\t\t}\n\t\t\tif (b == '-') {\n\t\t\t\tsign = -1;\n\t\t\t\tb = input.read();\n\t\t\t} else if (b == '+') {\n\t\t\t\tb = input.read();\n\t\t\t}\n\t\t\tint ret = b - '0';\n\t\t\twhile (true) {\n\t\t\t\tb = input.read();\n\t\t\t\tif (b < '0' || '9' < b) return ret * sign;\n\t\t\t\tret *= 10;\n\t\t\t\tret += b - '0';\n\t\t\t}\n\t\t}\n\n\t\tchar nextChar() throws IOException {\n\t\t\tint b = input.read();\n\t\t\twhile (Character.isWhitespace((char) b)) {\n\t\t\t\tb = input.read();\n\t\t\t}\n\t\t\treturn (char) b;\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\n\npublic class Main {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\n\tclass WeightedUnionFind {\n\t\tint[] par;\n\t\tlong[] wd;\n\n\t\tpublic WeightedUnionFind(int n) {\n\t\t\tpar = new int[n];\n\t\t\twd = new long[n];\n\t\t\tArrays.fill(par, -1);\n\t\t}\n\n\t\tint find(int x) {\n\t\t\tif (par[x] < 0)\n\t\t\t\treturn x;\n\t\t\telse {\n\t\t\t\tfinal int parent = find(par[x]);\n\t\t\t\twd[x] += wd[par[x]];\n\t\t\t\tpar[x] = parent;\n\t\t\t\treturn parent;\n\t\t\t}\n\t\t}\n\n\t\tboolean same(int x, int y) {\n\t\t\treturn find(x) == find(y);\n\t\t}\n\n\t\tlong weight(int x) {\n\t\t\tfind(x);\n\t\t\treturn wd[x];\n\t\t}\n\n\t\t// y - x = w ??? y = x + w;\n\t\tboolean union(int x, int y, long w) {\n\t\t\tw += (weight(x) - weight(y));\n\t\t\tx = find(x);\n\t\t\ty = find(y);\n\t\t\tif (x == y)\n\t\t\t\treturn false;\n\t\t\telse {\n\n\t\t\t\tif (par[y] < par[x]) { // ???????????????????????????????????????????????????.\n\t\t\t\t\tint tmp = x;\n\t\t\t\t\tx = y;\n\t\t\t\t\ty = tmp;\n\t\t\t\t\tw = -w;\n\t\t\t\t}\n\t\t\t\tpar[y] = x;\n\t\t\t\twd[y] = w;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\t// return x-y\n\t\tlong diff(int x, int y) {\n\t\t\tif (!same(x, y)) {\n\t\t\t\tthrow new AssertionError();\n\t\t\t} else {\n\t\t\t\treturn this.weight(x) - this.weight(y);\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid solver() {\n\t\twhile (true) {\n\t\t\tint N = ni();\n\t\t\tint M = ni();\n\t\t\tif (N == 0 && M == 0)\n\t\t\t\tbreak;\n\t\t\tWeightedUnionFind uf = new WeightedUnionFind(N);\n\t\t\tfor (int i = 0; i < M; i++) {\n\t\t\t\tString s = ns();\n\t\t\t\tint x = ni() - 1;\n\t\t\t\tint y = ni() - 1;\n\t\t\t\tif (s.equals(\"!\")) {\n\t\t\t\t\tlong w = nl();\n\t\t\t\t\tuf.union(x, y, w);\n\t\t\t\t} else {\n\t\t\t\t\tif (!uf.same(x, y)) {\n\t\t\t\t\t\tout.println(\"UNKNOWN\");\n\t\t\t\t\t} else {\n\t\t\t\t\t\tout.println(-uf.diff(x, y));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\n\t\tnew Main().solver();\n\t\tout.flush();\n\t}\n\n\tstatic long nl() {\n\t\ttry {\n\t\t\tlong num = 0;\n\t\t\tboolean minus = false;\n\t\t\twhile ((num = is.read()) != -1 && !((num >= '0' && num <= '9') || num == '-'))\n\t\t\t\t;\n\t\t\tif (num == '-') {\n\t\t\t\tnum = 0;\n\t\t\t\tminus = true;\n\t\t\t} else {\n\t\t\t\tnum -= '0';\n\t\t\t}\n\n\t\t\twhile (true) {\n\t\t\t\tint b = is.read();\n\t\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t\t} else {\n\t\t\t\t\treturn minus ? -num : num;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn -1;\n\t}\n\n\tstatic char nc() {\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tif (b == -1)\n\t\t\t\treturn 0;\n\t\t\treturn (char) b;\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn 0;\n\t}\n\n\tstatic double nd() {\n\t\ttry {\n\t\t\treturn Double.parseDouble(ns());\n\t\t} catch (Exception e) {\n\t\t}\n\t\treturn 0;\n\t}\n\n\tstatic String ns() {\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tif (b == -1)\n\t\t\t\treturn \"\";\n\t\t\tsb.append((char) b);\n\t\t\twhile (true) {\n\t\t\t\tb = is.read();\n\t\t\t\tif (b == -1)\n\t\t\t\t\treturn sb.toString();\n\t\t\t\tif (b <= ' ')\n\t\t\t\t\treturn sb.toString();\n\t\t\t\tsb.append((char) b);\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn \"\";\n\t}\n\n\tpublic static char[] ns(int n) {\n\t\tchar[] buf = new char[n];\n\t\ttry {\n\t\t\tint b = skip(), p = 0;\n\t\t\tif (b == -1)\n\t\t\t\treturn null;\n\t\t\tbuf[p++] = (char) b;\n\t\t\twhile (p < n) {\n\t\t\t\tb = is.read();\n\t\t\t\tif (b == -1 || b <= ' ')\n\t\t\t\t\tbreak;\n\t\t\t\tbuf[p++] = (char) b;\n\t\t\t}\n\t\t\treturn Arrays.copyOf(buf, p);\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn null;\n\t}\n\n\tpublic static byte[] nse(int n) {\n\t\tbyte[] buf = new byte[n];\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tif (b == -1)\n\t\t\t\treturn null;\n\t\t\tis.read(buf);\n\t\t\treturn buf;\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn null;\n\t}\n\n\tstatic int skip() throws IOException {\n\t\tint b;\n\t\twhile ((b = is.read()) != -1 && !(b >= 33 && b <= 126))\n\t\t\t;\n\t\treturn b;\n\t}\n\n\tstatic boolean eof() {\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\tint b = skip();\n\t\t\tis.reset();\n\t\t\treturn b == -1;\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tstatic int ni() {\n\t\ttry {\n\t\t\tint num = 0;\n\t\t\tboolean minus = false;\n\t\t\twhile ((num = is.read()) != -1 && !((num >= '0' && num <= '9') || num == '-'))\n\t\t\t\t;\n\t\t\tif (num == '-') {\n\t\t\t\tnum = 0;\n\t\t\t\tminus = true;\n\t\t\t} else {\n\t\t\t\tnum -= '0';\n\t\t\t}\n\n\t\t\twhile (true) {\n\t\t\t\tint b = is.read();\n\t\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t\t} else {\n\t\t\t\t\treturn minus ? -num : num;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn -1;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.Reader;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\n\npublic class Main {\n\tstatic FastScanner sc = new FastScanner(System.in);\n\n\tpublic static void main(String[] args) throws Exception {\n\t\twhile (true) {\n\t\t\tint N = sc.nextInt();\n\t\t\tif (N == 0) break;\n\t\t\tint M = sc.nextInt();\n\t\t\tint[] A = new int[M];\n\t\t\tint[] B = new int[M];\n\t\t\tint[] W = new int[M];\n\t\t\tboolean[] type = new boolean[M];\n\t\t\tint[] dist = new int[N];\n\t\t\tArrayList<ArrayList<Edge>> graph = new ArrayList<ArrayList<Edge>>();\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tgraph.add(new ArrayList<Edge>());\n\t\t\t}\n\t\t\tfor (int i = 0; i < M; ++i) {\n\t\t\t\ttype[i] = sc.nextChar() == '!';\n\t\t\t\tA[i] = sc.nextInt() - 1;\n\t\t\t\tB[i] = sc.nextInt() - 1;\n\t\t\t\tif (type[i]) {\n\t\t\t\t\tW[i] = sc.nextInt();\n\t\t\t\t\tgraph.get(A[i]).add(new Edge(B[i], W[i]));\n\t\t\t\t\tgraph.get(B[i]).add(new Edge(A[i], -W[i]));\n\t\t\t\t}\n\t\t\t}\n\t\t\tArrays.fill(dist, Integer.MIN_VALUE);\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tif (dist[i] != Integer.MIN_VALUE) continue;\n\t\t\t\tArrayDeque<Integer> q = new ArrayDeque<Integer>();\n\t\t\t\tq.add(i);\n\t\t\t\tdist[i] = 0;\n\t\t\t\twhile (!q.isEmpty()) {\n\t\t\t\t\tint cur = q.poll();\n\t\t\t\t\tfor (Edge e : graph.get(cur)) {\n\t\t\t\t\t\tint next = e.to;\n\t\t\t\t\t\tif (dist[next] != Integer.MIN_VALUE) continue;\n\t\t\t\t\t\tdist[next] = dist[cur] + e.w;\n\t\t\t\t\t\tq.add(next);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tUnionFind uf = new UnionFind(N);\n\t\t\tfor (int i = 0; i < M; ++i) {\n\t\t\t\tif (A[i] == -1 || B[i] == -1) return;\n\t\t\t\tif (type[i]) {\n\t\t\t\t\tuf.union(A[i], B[i]);\n\t\t\t\t} else {\n\t\t\t\t\tif (!uf.find(A[i], B[i])) {\n\t\t\t\t\t\tSystem.out.println(\"UNKNOWN\");\n\t\t\t\t\t} else {\n\t\t\t\t\t\tSystem.out.println(dist[B[i]] - dist[A[i]]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic class Edge {\n\t\tint to, w;\n\n\t\tEdge(int to, int w) {\n\t\t\tthis.to = to;\n\t\t\tthis.w = w;\n\t\t}\n\t}\n\n\tstatic class UnionFind {\n\t\tint[] set;\n\n\t\tUnionFind(int n) {\n\t\t\tset = new int[n];\n\t\t\tArrays.fill(set, -1);\n\t\t}\n\n\t\tvoid union(int a, int b) {\n\t\t\tint rtA = root(a);\n\t\t\tint rtb = root(b);\n\t\t\tif (rtA == rtb) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tset[rtA] += set[rtb];\n\t\t\tset[rtb] = rtA;\n\t\t}\n\n\t\tboolean find(int a, int b) {\n\t\t\treturn root(a) == root(b);\n\t\t}\n\n\t\tint root(int a) {\n\t\t\tif (set[a] < 0) {\n\t\t\t\treturn a;\n\t\t\t} else {\n\t\t\t\tset[a] = root(set[a]);\n\t\t\t\treturn set[a];\n\t\t\t}\n\t\t}\n\n\t\tint size(int a) {\n\t\t\treturn -set[root(a)];\n\t\t}\n\t}\n\n\tstatic class FastScanner {\n\t\tReader input;\n\n\t\tFastScanner() {\n\t\t\tthis(System.in);\n\t\t}\n\n\t\tFastScanner(InputStream stream) {\n\t\t\tthis.input = new BufferedReader(new InputStreamReader(stream));\n\t\t}\n\n\t\tint nextInt() throws IOException {\n\t\t\tint sign = 1;\n\t\t\tint b = input.read();\n\t\t\twhile ((b < '0' || '9' < b) && b != '-' && b != '+') {\n\t\t\t\tif (b == -1) return 0;\n\t\t\t\tb = input.read();\n\t\t\t}\n\t\t\tif (b == '-') {\n\t\t\t\tsign = -1;\n\t\t\t\tb = input.read();\n\t\t\t} else if (b == '+') {\n\t\t\t\tb = input.read();\n\t\t\t}\n\t\t\tint ret = b - '0';\n\t\t\twhile (true) {\n\t\t\t\tb = input.read();\n\t\t\t\tif (b < '0' || '9' < b) return ret * sign;\n\t\t\t\tret *= 10;\n\t\t\t\tret += b - '0';\n\t\t\t}\n\t\t}\n\n\t\tchar nextChar() throws IOException {\n\t\t\tint b = input.read();\n\t\t\twhile (Character.isWhitespace((char) b)) {\n\t\t\t\tb = input.read();\n\t\t\t}\n\t\t\treturn (char) b;\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n \npublic class Main {\n    public static int N;\n    public static int M;\n    public static int[] p;\n    public static int[] rank;\n    public static int[] w;\n \n    public static boolean same(int x, int y) {\n        return findSet(x) == findSet(y);\n    }\n \n    public static void unite(int a, int b, int w) {\n        int i = findSet(a);\n        int j = findSet(b);\n\tw -= w[b] - w[a];\n\t\n        if (i == j){\n\t    return;\n\t}\n        if (rank[i] > rank[j]){\n            p[j] = p[i];\n\t    w[j] = w;\n        } else {\n            p[i] = p[j];\n\t    w[i] = -w;\n            if(rank[i] == rank[j]){\n            rank[j]++;\n            }\n        }\t\n    }\n \n    public static int findSet(int i) {\n       if(p[i] == i){ \n           return i;\n        }else{\n          return p[i] = findSet(p[i]);\n        }\n    }\n \n    public static void DisjointSet() {\n        p = new int[N];\n        rank = new int[N];\n\tw = new int[N];\n \n        for (int i = 0; i < N; i++) {\n            p[i] = i;\n            rank[i] = 0;\n\t    w[i] = 0;\n        }\n    }\n    \n    public static void main (String[] args){\n        Scanner scanner = new Scanner(System.in);\n\twhile(true){   \n\t    N = scanner.nextInt();\n\t    DisjointSet();\n\t    M = scanner.nextInt();\n\t    if(N==0 & M == 0) break;\n\t    \n\t    for (int i = 0; i < M; i++) {\n\t\tif(scanner.next().equals(\"!\")){\n\t\t    int a = scanner.nextInt();\n\t\t    int b = scanner.nextInt();\n\t\t    int w = scanner.nextInt();\n\t\t    \n\t\t    a--;\n\t\t    b--;\n\t\t    unite(a, b, w);\n\t\t}else{\n\t\t    if(!same(a,b)){\n\t\t\tSystem.out.println(\"UNKNOWN\");\n\t\t    }else{\n\t\t\tSystem.out.println(w[b]-w[a]);\n\t\t    }\n\t\t}\n\t    }\n\t}\t\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.ListIterator;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n \npublic class Main {\n     \n    public static class WeightUnionFind{\n        int[] parent;\n        int[] rank;\n        int[] diff_weight;\n         \n        WeightUnionFind(int n){\n            parent=new int[n];\n            rank = new int[n];\n            diff_weight = new int[n];\n             \n            for(int i=0;i<n;i++){\n                parent[i]=i;\n                rank[i] = 0;\n                diff_weight[i] = 0;\n            }\n        }\n         \n        public int find(int x){\n            if(parent[x]==x){\n                return x;\n            }\n             \n            return find(parent[x]);\n        }\n         \n        public int find_diff(int x){\n            if(parent[x] == x){\n                return 0;\n            }\n             \n            return find_diff(parent[x]) + diff_weight[x];\n        }\n         \n        public Boolean same(int x,int y){\n            return find(x)==find(y);\n        }\n         \n        public int get_diff(int x, int y){\n            if(!same(x, y)){\n                return Integer.MIN_VALUE;\n            }else{\n                return find_diff(x) - find_diff(y);\n            }\n        }\n        /*\n        public void unite(int x,int y){\n            x = find(x);\n            y = find(y);\n             \n            if(x == y){\n                return;\n            }\n             \n            if(rank[x] < rank[y]){\n                parent[x] = y;\n            }else{\n                parent[y] = x;\n                if(rank[x] == rank[y]){\n                    rank[x]++;\n                }\n            }\n        }\n        */\n        public void set_diff(int x,int y, int d){\n            final int find_x = find(x);\n            final int find_y = find(y);\n             \n            if(find_x == find_y){\n                return;\n            }\n             \n            //System.out.println(x + \" \" + find_x + \" \" + y + \" \" + find_y + \" \" + diff_weight[y] + \" \" + diff_weight[x]);\n            d -= find_diff(x) - find_diff(y);\n             \n            if(rank[find_x] < rank[find_y]){\n                //diff_weight[x] += d + find_diff(y);\n                diff_weight[find_x] = d;\n                 \n                parent[find_x] = find_y;\n            }else{\n                diff_weight[find_y] = -d;\n                 \n                parent[find_y] = find_x;\n                if(rank[find_x] == rank[find_y]){\n                    rank[find_x]++;\n                }\n            }\n        }\n    }\n \n     \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n         \n        while (true) {\n            final int N = sc.nextInt();\n            final int M = sc.nextInt();\n \n            if (N == 0 && M == 0) {\n                break;\n            }\n             \n            System.gc();\n             \n            WeightUnionFind wuf = new WeightUnionFind(N);\n             \n            for(int i = 0; i < M; i++){\n                String op = sc.next();\n                 \n                if(op.equals(\"!\")){\n                    final int from = sc.nextInt() - 1;\n                    final int to = sc.nextInt() - 1;\n                    final int w = sc.nextInt();\n                     \n                    wuf.set_diff(from, to, w);\n                    //System.out.println(\"DIFF \" + from + \" \" + to + \" \" + w);\n                }else{\n                    final int from = sc.nextInt() - 1;\n                    final int to = sc.nextInt() - 1;\n                     \n                    if(!wuf.same(from, to)){\n                        System.out.println(\"UNKNOWN\");\n                    }else{\n                        System.out.println(wuf.get_diff(from, to));\n                    }\n                }\n                 \n                //System.out.println(\"P : \" + Arrays.toString(wuf.parent));\n                //System.out.println(\"D : \" + Arrays.toString(wuf.diff_weight));\n            }\n             \n        }\n \n        sc.close();\n    }\n \n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n   \npublic class Main {\n    public static int N;\n    public static int M;\n    public static int[] p;\n    public static int[] rank;\n    public static int[] weight;\n  \n    public static boolean same(int x, int y) {\n        return findSet(x) == findSet(y);\n    }\n   \n    public static void unite(int x, int y, int w) {\n        int i = findSet(x);\n        int j = findSet(y);\n        \n  \n        if (i == j){\n        return;\n    }\n        if (rank[i] > rank[j]){\n            p[j] = i;      \n            weight[j] =  w - weight[y] + weight[x];\n            weight[x] += weight[j]; \n        } else {\n            p[i] = j;\n            weight[i] =  -w - weight[x] + weight[y];\n            weight[x] += weight[i]; \n            if(rank[i] == rank[j]){\n        rank[j]++;\n            }\n        }   \n    }\n   \n    public static int findSet(int i) {\n    if(p[i] == i){ \n        return i;\n        }else{      \n          return p[i] = findSet(p[i]);\n        }\n    }\n   \n    public static void DisjointSet() {\n        p = new int[N];\n        rank = new int[N];\n        weight = new int[N];\n   \n        for (int i = 0; i < N; i++) {\n            p[i] = i;\n            rank[i] = 0;\n            weight[i] = 0;\n        }\n    }\n   \n   \n    public static void main (String[] args){\n        Scanner scanner = new Scanner(System.in);\n        while(true){\n        N = scanner.nextInt();\n        M = scanner.nextInt();\n  \n        if(N==0 && M==0){\n        break;\n        }\n   \n        DisjointSet();\n  \n        for (int i = 0; i < M; i++) {\n        String c = scanner.next();\n        int a = scanner.nextInt();\n        int b = scanner.nextInt();\n        a--; b--; \n          \n        if(c.equals(\"!\")){\n            int w = scanner.nextInt();\n            unite(a, b, w);\n        }else{ \n            if(same(a,b)){\n            System.out.println(weight[b] - weight[a]);\n            }else{\n            System.out.println(\"UNKNOWN\");\n            }\n        }\n        }\n    }\n        \n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport static java.lang.Math.*;\n\npublic class Main {\n\tfinal Scanner sc = new Scanner(System.in);\n\tpublic static void main(String[] args) {\n\t\tnew Main().init();\n\t}\n\tvoid init(){\n\t\tfinal long stackSize = 8*1024*1024;\n\t\tnew Thread(null, new AOJ1330(), \"RUN\", stackSize).start();\n\t}\n\t\n\tclass AOJ1330 implements Runnable{\n\t\tAOJ1330(){}\n\t\t@Override public void run(){\n//\t\t\tlong start = System.currentTimeMillis();\n\t\t\twhile(sc.hasNext()){\n\t\t\t\tN=sc.nextInt();\n\t\t\t\tM=sc.nextInt();\n\t\t\t\tif((N|M)==0)\tbreak;\n\t\t\t\tsolve();\n\t\t\t}\n//\t\t\tSystem.out.println( (System.currentTimeMillis()-start)+\"ms\");\n\t\t}\n\t\t\n\t\tint N,M;\n\t\t\n\t\tvoid solve(){\n\t\t\tUnionFind uf = new UnionFind(N);\n\t\t\tfor(int i=0; i<M; ++i){\n\t\t\t\tif(sc.next().equals(\"!\")){\n\t\t\t\t\tint a=sc.nextInt(), b=sc.nextInt(), w=sc.nextInt();\n\t\t\t\t\t--a;\n\t\t\t\t\t--b;\n\t\t\t\t\tuf.unite(a, b, w);\n\t\t\t\t}else{\n\t\t\t\t\tint a=sc.nextInt(), b=sc.nextInt();\n\t\t\t\t\t--a;\n\t\t\t\t\t--b;\n\t\t\t\t\tint ret = uf.getWeight(a, b);\n\t\t\t\t\tSystem.out.println(ret>=uf.INF ? \"UNKNOWN\" : ret);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Union-Find Tree\n\t\tclass UnionFind{\n\t\t\tclass Node{\n\t\t\t\tint par,rank,w;\n\t\t\t\tNode(int par,int rank,int w){\n\t\t\t\t\tthis.par=par;\n\t\t\t\t\tthis.rank=rank;\n\t\t\t\t\tthis.w=w;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tNode[] node;\n\t\t\tfinal int INF = Integer.MAX_VALUE/4;\n\t\t\t\n\t\t\tUnionFind(int n){\n\t\t\t\tnode=new Node[n];\n\t\t\t\tfor(int i=0; i<n; ++i)\tnode[i]=new Node(i,0,0);\n\t\t\t}\n\t\t\t\n\t\t\tNode find(int x){\n\t\t\t\tif(node[x].par == x)\treturn node[x];\n\t\t\t\telse{\n\t\t\t\t\tNode tmp = find(node[x].par);\n\t\t\t\t\tnode[x].par = tmp.par;\n\t\t\t\t\tnode[x].w += tmp.w;\n\t\t\t\t\treturn node[x];\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tvoid unite(int x,int y,int w){\n\t\t\t\tNode tx=find(x);\n\t\t\t\tNode ty=find(y);\n\t\t\t\tif(tx.par==ty.par)\treturn;\n\t\t\t\t\n\t\t\t\tint px = tx.par,\n\t\t\t\t\tpy = ty.par;\n\t\t\t\t\n\t\t\t\tif(node[px].rank <= node[py].rank){\n\t\t\t\t\tnode[tx.par].w = w - tx.w;\n\t\t\t\t\tnode[tx.par].par = y;\n\t\t\t\t\tif(node[px].rank == node[py].rank)\t++node[py].rank;\n\t\t\t\t}else{\n\t\t\t\t\tnode[ty.par].w = -w - ty.w;\n\t\t\t\t\tnode[ty.par].par = x;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint getWeight(int x,int y){\n\t\t\t\tNode tx = find(x);\n\t\t\t\tNode ty = find(y);\n\t\t\t\treturn (tx.par==ty.par ? tx.w-ty.w : INF);\n\t\t\t}\n\t\t\t\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n \npublic class Main {\n    public static int N;\n    public static int M;\n    public static int[] p;\n    public static int[] rank;\n    public static int[] weight;\n\n    public static boolean same(int x, int y) {\n        return findSet(x) == findSet(y);\n    }\n \n    public static void unite(int x, int y, int w) {\n        int i = findSet(x);\n        int j = findSet(y);\n        w -= weight[j] - weight[i];\n\n        if (i == j){\n\t    return;\n\t}\n        if (rank[i] > rank[j]){\n            p[j] = p[i];\n            weight[j] = w;\n        } else {\n            p[i] = p[j];\n            weight[i] = -w;\n            if(rank[i] == rank[j]){\n            rank[j]++;\n            }\n        }\t\n    }\n \n    public static int findSet(int i) {\n       if(p[i] == i){ \n           return i;\n        }else{\n          return p[i] = findSet(p[i]);\n        }\n    }\n \n    public static void DisjointSet() {\n        p = new int[N];\n        rank = new int[N];\n        weight = new int[N];\n \n        for (int i = 0; i < N; i++) {\n            p[i] = i;\n            rank[i] = 0;\n            weight[i] = 0;\n        }\n    }\n \n \n    public static void main (String[] args){\n        Scanner scanner = new Scanner(System.in);\n        while(true){\n        N = scanner.nextInt();\n        M = scanner.nextInt();\n\n        if(N==0 & M==0){\n           break;\n        }\n \n        DisjointSet();\n\n        for (int i = 0; i < M; i++) {\n            if(scanner.next().equals(\"!\")){\n            int a = scanner.nextInt();\n            int b = scanner.nextInt();\n            int w = scanner.nextInt();\n \n            a--; b--;   \n            unite(a, b, w);\n            }else{\n               if(same(x, y)){\n                    System.out.println(\"UNKNOWN\");\n                }else{\n                    System.out.println(weight[b]-weight[a]);\n\t\t}\n            }\n        }\n       }\n      \n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\n\npublic class Main {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\n\tvoid solver()\n\t{\n\t\twhile (true) {\n\t\t\tint N =ni();\n\t\t\tint M = ni();\n\t\t\tif (N == 0 && M == 0)\n\t\t\t\tbreak;\n\t\t\tWeightedUnionFind uf = new WeightedUnionFind(N);\n\t\t\tfor (int i = 0; i < M; i++) {\n\t\t\t\tString s = ns();\n\t\t\t\tint x = ni() - 1;\n\t\t\t\tint y = ni() - 1;\n\t\t\t\tif (s.equals(\"!\")) {\n\t\t\t\t\tlong w = nl();\n\t\t\t\t\tuf.union(x, y, w);\n\t\t\t\t} else {\n\t\t\t\t\tif (!uf.same(x, y)) {\n\t\t\t\t\t\tSystem.out.println(\"UNKNOWN\");\n\t\t\t\t\t} else {\n\t\t\t\t\t\tSystem.out.println(-uf.diff(x, y));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) throws Exception\n\t{\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\n\t\tnew Main().solver();\n\t\tout.flush();\n\t}\n\n\tstatic long nl()\n\t{\n\t\ttry {\n\t\t\tlong num = 0;\n\t\t\tboolean minus = false;\n\t\t\twhile((num = is.read()) != -1 && !((num >= '0' && num <= '9') || num == '-'));\n\t\t\tif(num == '-'){\n\t\t\t\tnum = 0;\n\t\t\t\tminus = true;\n\t\t\t}else{\n\t\t\t\tnum -= '0';\n\t\t\t}\n\n\t\t\twhile(true){\n\t\t\t\tint b = is.read();\n\t\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t\t}else{\n\t\t\t\t\treturn minus ? -num : num;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn -1;\n\t}\n\n\tstatic char nc()\n\t{\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tif(b == -1)return 0;\n\t\t\treturn (char)b;\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn 0;\n\t}\n\n\tstatic double nd()\n\t{\n\t\ttry {\n\t\t\treturn Double.parseDouble(ns());\n\t\t}catch(Exception e) {\n\t\t}\n\t\treturn 0;\n\t}\n\n\tstatic String ns()\n\t{\n\t\ttry{\n\t\t\tint b = skip();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tif(b == -1)return \"\";\n\t\t\tsb.append((char)b);\n\t\t\twhile(true){\n\t\t\t\tb = is.read();\n\t\t\t\tif(b == -1)return sb.toString();\n\t\t\t\tif(b <= ' ')return sb.toString();\n\t\t\t\tsb.append((char)b);\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn \"\";\n\t}\n\n\tpublic static char[] ns(int n)\n\t{\n\t\tchar[] buf = new char[n];\n\t\ttry{\n\t\t\tint b = skip(), p = 0;\n\t\t\tif(b == -1)return null;\n\t\t\tbuf[p++] = (char)b;\n\t\t\twhile(p < n){\n\t\t\t\tb = is.read();\n\t\t\t\tif(b == -1 || b <= ' ')break;\n\t\t\t\tbuf[p++] = (char)b;\n\t\t\t}\n\t\t\treturn Arrays.copyOf(buf, p);\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn null;\n\t}\n\n\tpublic static byte[] nse(int n)\n\t{\n\t\tbyte[] buf = new byte[n];\n\t\ttry{\n\t\t\tint b = skip();\n\t\t\tif(b == -1)return null;\n\t\t\tis.read(buf);\n\t\t\treturn buf;\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn null;\n\t}\n\n\tstatic int skip() throws IOException\n\t{\n\t\tint b;\n\t\twhile((b = is.read()) != -1 && !(b >= 33 && b <= 126));\n\t\treturn b;\n\t}\n\n\tstatic boolean eof()\n\t{\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\tint b = skip();\n\t\t\tis.reset();\n\t\t\treturn b == -1;\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tstatic int ni()\n\t{\n\t\ttry {\n\t\t\tint num = 0;\n\t\t\tboolean minus = false;\n\t\t\twhile((num = is.read()) != -1 && !((num >= '0' && num <= '9') || num == '-'));\n\t\t\tif(num == '-'){\n\t\t\t\tnum = 0;\n\t\t\t\tminus = true;\n\t\t\t}else{\n\t\t\t\tnum -= '0';\n\t\t\t}\n\n\t\t\twhile(true){\n\t\t\t\tint b = is.read();\n\t\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t\t}else{\n\t\t\t\t\treturn minus ? -num : num;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn -1;\n\t}\n\n\tclass WeightedUnionFind {\n\t\tint[] par;\n\t\tlong[] wd;\n\n\t\tpublic WeightedUnionFind(int n) {\n\t\t\tpar = new int[n];\n\t\t\twd = new long[n];\n\t\t\tArrays.fill(par, -1);\n\t\t}\n\n\t\tint find(int x) {\n\t\t\tif (par[x] < 0)\n\t\t\t\treturn x;\n\t\t\telse {\n\t\t\t\tfinal int parent = find(par[x]);\n\t\t\t\twd[x] += wd[par[x]];\n\t\t\t\tpar[x] = parent;\n\t\t\t\treturn parent;\n\t\t\t}\n\t\t}\n\n\t\tboolean same(int x, int y) {\n\t\t\treturn find(x) == find(y);\n\t\t}\n\n\t\tlong weight(int x) {\n\t\t\tfind(x);\n\t\t\treturn wd[x];\n\t\t}\n\n\t\t// y - x = w ??? y = x + w;\n\t\tboolean union(int x, int y, long w) {\n\t\t\tif (find(x) == find(y))\n\t\t\t\treturn false;\n\t\t\telse {\n\t\t\t\tw += (weight(x) - weight(y));\n\t\t\t\tx = find(x);\n\t\t\t\ty = find(y);\n\t\t\t\tif (par[y] < par[x]) { // ???????????????????????????????????????????????????.\n\t\t\t\t\tint tmp = x;\n\t\t\t\t\tx = y;\n\t\t\t\t\ty = tmp;\n\t\t\t\t\tw = -w;\n\t\t\t\t}\n\t\t\t\tpar[y] = x;\n\t\t\t\twd[y] = w;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\t// return x-y\n\t\tlong diff(int x, int y) {\n\t\t\tif (!same(x, y)) {\n\t\t\t\tthrow new AssertionError();\n\t\t\t} else {\n\t\t\t\treturn this.weight(x) - this.weight(y);\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n   \npublic class Main {\n    public static int N;\n    public static int M;\n    public static int[] p;\n    public static int[] rank;\n    public static int[] weight;\n  \n    public static boolean same(int x, int y) {\n        return findSet(x) == findSet(y);\n    }\n   \n    public static void unite(int x, int y, int w) {\n        int i = findSet(x);\n        int j = findSet(y);\n        \n  \n        if (i == j){\n        return;\n    }\n        if (rank[i] > rank[j]){\n            p[j] = i;      \n            weight[j] =  w - weight[y] + weight[x];\n            weight[y] += weight[j]; \n        } else {\n            p[i] = j;\n            weight[i] =  -w - weight[x] + weight[y];\n            weight[x] += weight[i]; \n            if(rank[i] == rank[j]){\n        rank[j]++;\n            }\n        }   \n    }\n   \n    public static int findSet(int i) {\n    if(p[i] == i){ \n        return i;\n        }else{      \n          return p[i] = findSet(p[i]);\n        }\n    }\n   \n    public static void DisjointSet() {\n        p = new int[N];\n        rank = new int[N];\n        weight = new int[N];\n   \n        for (int i = 0; i < N; i++) {\n            p[i] = i;\n            rank[i] = 0;\n            weight[i] = 0;\n        }\n    }\n   \n   \n    public static void main (String[] args){\n        Scanner scanner = new Scanner(System.in);\n        while(true){\n        N = scanner.nextInt();\n        M = scanner.nextInt();\n  \n        if(N==0 && M==0){\n        break;\n        }\n   \n        DisjointSet();\n  \n        for (int i = 0; i < M; i++) {\n        String c = scanner.next();\n        int a = scanner.nextInt();\n        int b = scanner.nextInt();\n        a--; b--; \n          \n        if(c.equals(\"!\")){\n            int w = scanner.nextInt();\n            unite(a, b, w);\n        }else{ \n            if(same(a,b)){\n            System.out.println(weight[b] - weight[a]);\n            }else{\n            System.out.println(\"UNKNOWN\");\n            }\n        }\n        }\n    }\n        \n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n  \npublic class Main {\n    public static int N;\n    public static int M;\n    public static int[] p;\n    public static int[] rank;\n    public static int[] weight;\n \n    public static boolean same(int x, int y) {\n        return findSet(x) == findSet(y);\n    }\n  \n    public static void unite(int x, int y, int w) {\n        int i = findSet(x);\n        int j = findSet(y);\n        w -= weight[y] - weight[x];\n \n        if (i == j){\n        return;\n    }\n        if (rank[i] > rank[j]){\n            p[j] = i;\n            weight[j] = w;\n        } else {\n            p[i] = j;\n            weight[i] = -w;\n            if(rank[i] == rank[j]){\n        rank[j]++;\n            }\n        }   \n    }\n  \n    public static int findSet(int i) {\n    if(p[i] == i){ \n        return i;\n        }else{\n        return p[i] = findSet(p[i]);\n        }\n    }\n  \n    public static void DisjointSet() {\n        p = new int[100010];\n        rank = new int[100010];\n        weight = new int[100010];\n  \n        for (int i = 0; i < N; i++) {\n            p[i] = i;\n            rank[i] = 0;\n            weight[i] = 0;\n        }\n    }\n  \n  \n    public static void main (String[] args){\n        Scanner scanner = new Scanner(System.in);\n        while(true){\n        N = scanner.nextInt();\n        M = scanner.nextInt();\n \n        if(N==0 |M==0){\n        break;\n        }\n  \n        DisjointSet();\n \n        for (int i = 0; i < M; i++) {\n        String c = scanner.next();\n        int a = scanner.nextInt();\n        int b = scanner.nextInt();\n        a--; b--; \n         \n        if(c.equals(\"!\")){\n            int w = scanner.nextInt();\n            unite(a, b, w);\n        }else{ \n            if(same(a,b)){\n            System.out.println(weight[b] - weight[a]);\n            }else{\n            System.out.println(\"UNKNOWN\");\n            }\n        }\n        }\n    }\n       \n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n \npublic class Main {\n    public static int N;\n    public static int M;\n    public static int[] p;\n    public static int[] rank;\n    public static int[] w;\n \n    public static boolean same(int x, int y) {\n        return findSet(x) == findSet(y);\n    }\n    \n    public static void unite(int a, int b, int k) {\n        int i = findSet(a);\n        int j = findSet(b);\n\tk -= w[b] - w[a];\n\t\n        if (i == j){\n\t    return;\n\t}\n        if (rank[i] > rank[j]){\n            p[j] = p[i];\n\t    w[j] = k;\n        } else {\n            p[i] = p[j];\n\t    w[i] = -k;\n            if(rank[i] == rank[j]){\n\t\trank[j]++;\n            }\n        }\t\n    }\n    \n    public static int findSet(int i) {\n\tif(p[i] == i){ \n\t    return i;\n        }else{\n\t    return p[i] = findSet(p[i]);\n        }\n    }\n    \n    public static void DisjointSet() {\n        p = new int[N];\n        rank = new int[N];\n\tw = new int[N];\n\t\n        for (int i = 0; i < N; i++) {\n            p[i] = i;\n            rank[i] = 0;\n\t    w[i] = 0;\n        }\n    }\n    \n    public static void main (String[] args){\n        Scanner scanner = new Scanner(System.in);\n\twhile(true){   \n\t    N = scanner.nextInt();\n\t    DisjointSet();\n\t    M = scanner.nextInt();\n\t    if(N==0 & M == 0) break;\n\t    \n\t    for (int i = 0; i < M; i++) {\n\t\tif(scanner.next().equals(\"!\")){\n\t\t    int a = scanner.nextInt();\n\t\t    int b = scanner.nextInt();\n\t\t    int w = scanner.nextInt();\n\t\t    \n\t\t    a--;\n\t\t    b--;\n\t\t    unite(a, b, w);\n\t\t}else{\n\t\t    if(same(a,b)==false){\n\t\t\tSystem.out.println(\"UNKNOWN\");\n\t\t    }else{\n\t\t\tSystem.out.println(w[b]-w[a]);\n\t\t    }\n\t\t}\n\t    }\n\t}\t\n    }\n}\n\n \n    public static int findSet(int i) {\n       if(p[i] == i){ \n           return i;\n        }else{\n          return p[i] = findSet(p[i]);\n        }\n    }\n \n    public static void DisjointSet() {\n        p = new int[N];\n        rank = new int[N];\n\tw = new int[N];\n \n        for (int i = 0; i < N; i++) {\n            p[i] = i;\n            rank[i] = 0;\n\t    w[i] = 0;\n        }\n    }\n    \n    public static void main (String[] args){\n        Scanner scanner = new Scanner(System.in);\n\twhile(true){   \n\t    N = scanner.nextInt();\n\t    DisjointSet();\n\t    M = scanner.nextInt();\n\t    if(N==0 & M == 0) break;\n\t    \n\t    for (int i = 0; i < M; i++) {\n\t\tif(scanner.next().equals(\"!\")){\n\t\t    int a = scanner.nextInt();\n\t\t    int b = scanner.nextInt();\n\t\t    int w = scanner.nextInt();\n\t\t    \n\t\t    a--;\n\t\t    b--;\n\t\t    unite(a, b, w);\n\t\t}else{\n\t\t    if(same(a,b)==false){\n\t\t\tSystem.out.println(\"UNKNOWN\");\n\t\t    }else{\n\t\t\tSystem.out.println(w[b]-w[a]);\n\t\t    }\n\t\t}\n\t    }\n\t}\t\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n \npublic class Main {\n    public static int N;\n    public static int M;\n    public static int[] p;\n    public static int[] rank;\n    public static int[] weight;\n\n    public static boolean same(int x, int y) {\n        return findSet(x) == findSet(y);\n    }\n \n    public static void unite(int x, int y, int w) {\n        int i = findSet(x);\n        int j = findSet(y);\n        w -= weight[j] - weight[i];\n\n        if (i == j){\n\t    return;\n\t}\n        if (rank[i] > rank[j]){\n            p[j] = p[i];\n            weight[j] = w;\n        } else {\n            p[i] = p[j];\n            weight[i] = -w;\n            if(rank[i] == rank[j]){\n            rank[j]++;\n            }\n        }\t\n    }\n \n    public static int findSet(int i) {\n       if(p[i] == i){ \n           return i;\n        }else{\n          return p[i] = findSet(p[i]);\n        }\n    }\n \n    public static void DisjointSet() {\n        p = new int[N];\n        rank = new int[N];\n        weight = new int[N];\n \n        for (int i = 0; i < N; i++) {\n            p[i] = i;\n            rank[i] = 0;\n            weight[i] = 0;\n        }\n    }\n \n \n    public static void main (String[] args){\n        Scanner scanner = new Scanner(System.in);\n        while(true){\n        N = scanner.nextInt();\n        M = scanner.nextInt();\n\n        if(N==0 |M==0){\n           break;\n        }\n \n        DisjointSet();\n\n        for (int i = 0; i < M; i++) {\n            if(scanner.next().equals(\"!\")){\n            int a = scanner.nextInt();\n            int b = scanner.nextInt();\n            int w = scanner.nextInt();\n \n            a--; b--;   \n            unite(a, b, w);\n            }else if(same(a,b)){\n              System.out.println(weight[b] - weight[a]);\n            }else{\n              System.out.println(\"UNKNOWN\");\n\t    }\n           }\n        }\n       }\n      \n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n \npublic class Main {\n    public static int N;\n    public static int M;\n    public static int[] p;\n    public static int[] rank;\n    public static int[] weight;\n\n    public static boolean same(int x, int y) {\n        return findSet(x) == findSet(y);\n    }\n \n    public static void unite(int x, int y, int w) {\n        int i = findSet(x);\n        int j = findSet(y);\n        w -= weight[j] - weight[i];\n\n        if (i == j){\n\t    return;\n\t}\n        if (rank[i] > rank[j]){\n            p[j] = p[i];\n            weight[j] = w;\n        } else {\n            p[i] = p[j];\n            weight[i] = -w;\n            if(rank[i] == rank[j]){\n\t\trank[j]++;\n            }\n        }\t\n    }\n \n    public static int findSet(int i) {\n\tif(p[i] == i){ \n\t    return i;\n        }else{\n\t    return p[i] = findSet(p[i]);\n        }\n    }\n \n    public static void DisjointSet() {\n        p = new int[N];\n        rank = new int[N];\n        weight = new int[N];\n \n        for (int i = 0; i < N; i++) {\n            p[i] = i;\n            rank[i] = 0;\n            weight[i] = 0;\n        }\n    }\n \n \n    public static void main (String[] args){\n        Scanner scanner = new Scanner(System.in);\n        while(true){\n\t    N = scanner.nextInt();\n\t    M = scanner.nextInt();\n\n\t    if(N==0 |M==0){\n\t\tbreak;\n\t    }\n \n\t    DisjointSet();\n\n\t    for (int i = 0; i < M; i++) {       \n\t\tif(scanner.next().equals(\"!\")){\n\t\t    int a = scanner.nextInt();\n\t\t    int b = scanner.nextInt();\n\t\t    int w = scanner.nextInt();\n \n\t\t    a--; b--;   \n\t\t    unite(a, b, w);\n\t\t}else{ \n\t\t    int a = scanner.nextInt();\n\t\t    int b = scanner.nextInt();\n                    a--; b--;\n\t\t    if(same(a,b)){\n\t\t\tSystem.out.println(weight[b] - weight[a]);\n\t\t    }else{\n\t\t\tSystem.out.println(\"UNKNOWN\");\n\t\t    }\n\t\t}\n\t    }\n\t}\n      \n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.Reader;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic Scanner sc = new Scanner(System.in);\n\n\tpublic static void main(String[] args) throws Exception {\n//\t\tint[] A = new int[100000];\n//\t\tint[] B = new int[100000];\n//\t\tint[] W = new int[100000];\n//\t\tboolean[] type = new boolean[100000];\n//\t\tint[] dist = new int[100000];\n//\t\tArrayList<ArrayList<Edge>> graph = new ArrayList<ArrayList<Edge>>();\n//\t\tfor (int i = 0; i < 100000; ++i) {\n//\t\t\tgraph.add(new ArrayList<Edge>());\n//\t\t}\n\t\twhile (sc.hasNextInt()) {\n\t\t\tint N = sc.nextInt();\n\t\t\tif (N == 0) break;\n\t\t\tint M = sc.nextInt();\n\t\t\tsc.nextLine();\n//\t\t\tfor (int i = 0; i < 100000; ++i) {\n//\t\t\t\tgraph.get(i).clear();\n//\t\t\t}\n\t\t\tfor (int i = 0; i < M; ++i) {\n//\t\t\t\tif (!sc.hasNextLine()) {\n//\t\t\t\t\tM = i;\n//\t\t\t\t\tbreak;\n//\t\t\t\t}\n\t\t\t\tString line = sc.nextLine();\n//\t\t\t\tString[] line = sc.nextLine().split(\" \");\n//\t\t\t\ttype[i] = line[0].charAt(0) == '!';\n//\t\t\t\tA[i] = Integer.parseInt(line[1]) - 1;\n//\t\t\t\tB[i] = Integer.parseInt(line[2]) - 1;\n//\t\t\t\tif (type[i]) {\n//\t\t\t\t\tW[i] = Integer.parseInt(line[3]);\n//\t\t\t\t\tgraph.get(A[i]).add(new Edge(B[i], W[i]));\n//\t\t\t\t\tgraph.get(B[i]).add(new Edge(A[i], -W[i]));\n//\t\t\t\t}\n\t\t\t}\n//\t\t\tArrays.fill(dist, Integer.MIN_VALUE);\n//\t\t\tfor (int i = 0; i < N; ++i) {\n//\t\t\t\tif (dist[i] != Integer.MIN_VALUE) continue;\n//\t\t\t\tArrayDeque<Integer> q = new ArrayDeque<Integer>();\n//\t\t\t\tq.add(i);\n//\t\t\t\tdist[i] = 0;\n//\t\t\t\twhile (!q.isEmpty()) {\n//\t\t\t\t\tint cur = q.poll();\n//\t\t\t\t\tfor (Edge e : graph.get(cur)) {\n//\t\t\t\t\t\tint next = e.to;\n//\t\t\t\t\t\tif (dist[next] != Integer.MIN_VALUE) continue;\n//\t\t\t\t\t\tdist[next] = dist[cur] + e.w;\n//\t\t\t\t\t\tq.add(next);\n//\t\t\t\t\t}\n//\t\t\t\t}\n//\t\t\t}\n//\n//\t\t\tUnionFind uf = new UnionFind(100000);\n//\t\t\tfor (int i = 0; i < M; ++i) {\n//\t\t\t\tif (type[i]) {\n//\t\t\t\t\tuf.union(A[i], B[i]);\n//\t\t\t\t} else {\n//\t\t\t\t\tif (!uf.find(A[i], B[i])) {\n//\t\t\t\t\t\tSystem.out.println(\"UNKNOWN\");\n//\t\t\t\t\t} else {\n//\t\t\t\t\t\tSystem.out.println(dist[B[i]] - dist[A[i]]);\n//\t\t\t\t\t}\n//\t\t\t\t}\n//\t\t\t}\n\t\t}\n\t}\n\n\tstatic class Edge {\n\t\tint to, w;\n\n\t\tEdge(int to, int w) {\n\t\t\tthis.to = to;\n\t\t\tthis.w = w;\n\t\t}\n\t}\n\n\tstatic class UnionFind {\n\t\tint[] set;\n\n\t\tUnionFind(int n) {\n\t\t\tset = new int[n];\n\t\t\tArrays.fill(set, -1);\n\t\t}\n\n\t\tvoid union(int a, int b) {\n\t\t\tint rtA = root(a);\n\t\t\tint rtb = root(b);\n\t\t\tif (rtA == rtb) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tset[rtA] += set[rtb];\n\t\t\tset[rtb] = rtA;\n\t\t}\n\n\t\tboolean find(int a, int b) {\n\t\t\treturn root(a) == root(b);\n\t\t}\n\n\t\tint root(int a) {\n\t\t\tif (set[a] < 0) {\n\t\t\t\treturn a;\n\t\t\t} else {\n\t\t\t\tset[a] = root(set[a]);\n\t\t\t\treturn set[a];\n\t\t\t}\n\t\t}\n\n\t\tint size(int a) {\n\t\t\treturn -set[root(a)];\n\t\t}\n\t}\n\n\tstatic class FastScanner {\n\t\tReader input;\n\n\t\tFastScanner() {\n\t\t\tthis(System.in);\n\t\t}\n\n\t\tFastScanner(InputStream stream) {\n\t\t\tthis.input = new BufferedReader(new InputStreamReader(stream));\n\t\t}\n\n\t\tint nextInt() throws IOException {\n\t\t\tint sign = 1;\n\t\t\tint b = input.read();\n\t\t\twhile ((b < '0' || '9' < b) && b != '-' && b != '+') {\n\t\t\t\tif (b == -1) return 0;\n\t\t\t\tb = input.read();\n\t\t\t}\n\t\t\tif (b == '-') {\n\t\t\t\tsign = -1;\n\t\t\t\tb = input.read();\n\t\t\t} else if (b == '+') {\n\t\t\t\tb = input.read();\n\t\t\t}\n\t\t\tint ret = b - '0';\n\t\t\twhile (true) {\n\t\t\t\tb = input.read();\n\t\t\t\tif (b < '0' || '9' < b) return ret * sign;\n\t\t\t\tret *= 10;\n\t\t\t\tret += b - '0';\n\t\t\t}\n\t\t}\n\n\t\tchar nextChar() throws IOException {\n\t\t\tint b = input.read();\n\t\t\twhile (Character.isWhitespace((char) b)) {\n\t\t\t\tb = input.read();\n\t\t\t}\n\t\t\treturn (char) b;\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n \npublic class Main {\n    public static int N;\n    public static int M;\n    public static int[] p;\n    public static int[] rank;\n    public static int[] weight;\n\n    public static boolean same(int x, int y) {\n        return findSet(x) == findSet(y);\n    }\n \n    public static void unite(int x, int y, int w) {\n        int i = findSet(x);\n        int j = findSet(y);\n        w -= weight[j] - weight[i];\n\n        if (i == j){\n\t    return;\n\t}\n        if (rank[i] > rank[j]){\n            p[j] = p[i];\n            weight[j] = w;\n        } else {\n            p[i] = p[j];\n            weight[i] = -w;\n            if(rank[i] == rank[j]){\n            rank[j]++;\n            }\n        }\t\n    }\n \n    public static int findSet(int i) {\n       if(p[i] == i){ \n           return i;\n        }else{\n          return p[i] = findSet(p[i]);\n        }\n    }\n \n    public static void DisjointSet() {\n        p = new int[N];\n        rank = new int[N];\n        weight = new int[N];\n \n        for (int i = 0; i < N; i++) {\n            p[i] = i;\n            rank[i] = 0;\n            weight[i] = 0;\n        }\n    }\n \n \n    public static void main (String[] args){\n        Scanner scanner = new Scanner(System.in);\n        while(true){\n        N = scanner.nextInt();\n        M = scanner.nextInt();\n\n        if(N==0 |M==0){\n           break;\n        }\n \n        DisjointSet();\n\n        for (int i = 0; i < M; i++) {\n            if(scanner.next().equals(\"!\")){\n            int a = scanner.nextInt();\n            int b = scanner.nextInt();\n            int w = scanner.nextInt();\n \n            a--; b--;   \n            unite(a, b, w);\n            }else{ \n               if(same(a,b)){\n                    System.out.println(weight[b] - weight[a]);\n               }else{\n                    System.out.println(\"UNKNOWN\");\n\t       }\n            }\n          }\n       }\n      \n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n \npublic class Main {\n    public static int N;\n    public static int M;\n    public static int[] p;\n    public static int[] rank;\n    public static int[] weight;\n\n    public static boolean same(int x, int y) {\n        return findSet(x) == findSet(y);\n    }\n \n    public static void unite(int x, int y, int w) {\n        int i = findSet(x);\n        int j = findSet(y);\n        w -= weight[j] - weight[i];\n\n        if (i == j){\n\t    return;\n\t}\n        if (rank[i] > rank[j]){\n            p[j] = p[i];\n            weight[j] = w;\n        } else {\n            p[i] = p[j];\n            weight[i] = -w;\n            if(rank[i] == rank[j]){\n            rank[j]++;\n            }\n        }\t\n    }\n \n    public static int findSet(int i) {\n       if(p[i] == i){ \n           return i;\n        }else{\n          return p[i] = findSet(p[i]);\n        }\n    }\n \n    public static void DisjointSet() {\n        p = new int[N];\n        rank = new int[N];\n        weight = new int[N];\n \n        for (int i = 0; i < N; i++) {\n            p[i] = i;\n            rank[i] = 0;\n            weight[i] = 0;\n        }\n    }\n \n \n    public static void main (String[] args){\n        Scanner scanner = new Scanner(System.in);\n        while(true){\n        N = scanner.nextInt();\n        M = scanner.nextInt();\n\n        if(N==0 |M==0){\n           break;\n        }\n \n        DisjointSet();\n\n        for (int i = 0; i < M; i++) {\n            if(scanner.next().equals(\"!\")){\n            int a = scanner.nextInt();\n            int b = scanner.nextInt();\n            \n            int w = scanner.nextInt();\n \n            a--; b--;   \n            unite(a, b, w);\n            }else{ \n               int a = scanner.nextInt();\n               int b = scanner.nextInt();\n            \n               if(same(a,b)){\n                    System.out.println(weight[b] - weight[a]);\n               }else{\n                    System.out.println(\"UNKNOWN\");\n\t       }\n            }\n          }\n       }\n      \n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.ListIterator;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\t\n\tpublic static class WeightUnionFind{\n\t\tint[] parent;\n\t\tint[] weight;\n\t\t\n\t\tWeightUnionFind(int n){\n\t\t\tparent=new int[n];\n\t\t\tweight = new int[n];\n\t\t\t\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tparent[i] = i;\n\t\t\t\tweight[i] = 0;\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic int find(int x){\n\t\t\tif(parent[x]==x){\n\t\t\t\treturn x;\n\t\t\t}\n\t\t\t\n\t\t\tint next = find(parent[x]);\n\t\t\tweight[x] += weight[parent[x]];\n\t\t\treturn parent[x] = next;\n\t\t}\n\t\t\n\t\tpublic Boolean same(int x,int y){\n\t\t\treturn find(x)==find(y);\n\t\t}\n\t\t\n\t\tpublic int get_diff(int x, int y){\n\t\t\tif(!same(x, y)){\n\t\t\t\treturn Integer.MIN_VALUE;\n\t\t\t}else{\n\t\t\t\treturn weight[x] - weight[y];\n\t\t\t}\n\t\t}\n\t\t/*\n\t\tpublic void unite(int x,int y){\n\t\t\tx = find(x);\n\t\t\ty = find(y);\n\t\t\t\n\t\t\tif(x == y){\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tif(rank[x] < rank[y]){\n\t\t\t\tparent[x] = y;\n\t\t\t}else{\n\t\t\t\tparent[y] = x;\n\t\t\t\tif(rank[x] == rank[y]){\n\t\t\t\t\trank[x]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t*/\n\t\tpublic void set_rank(int x,int y, int d){\n\t\t\tfinal int find_x = find(x);\n\t\t\tfinal int find_y = find(y);\n\t\t\t\n\t\t\tif(find_x == find_y){\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tweight[find_x] = d - weight[x];\n\t\t\tparent[find_x] = y;\n\t\t}\n\t}\n\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile (true) {\n\t\t\tfinal int N = sc.nextInt();\n\t\t\tfinal int M = sc.nextInt();\n\n\t\t\tif (N == 0 && M == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tSystem.gc();\n\t\t\t\n\t\t\tWeightUnionFind wuf = new WeightUnionFind(N);\n\t\t\t\n\t\t\tfor(int i = 0; i < M; i++){\n\t\t\t\tString op = sc.next();\n\t\t\t\t\n\t\t\t\tif(op.equals(\"!\")){\n\t\t\t\t\tfinal int from = sc.nextInt() - 1;\n\t\t\t\t\tfinal int to = sc.nextInt() - 1;\n\t\t\t\t\tfinal int w = sc.nextInt();\n\t\t\t\t\t\n\t\t\t\t\twuf.set_rank(from, to, w);\n\t\t\t\t\t//System.out.println(\"DIFF \" + from + \" \" + to + \" \" + w);\n\t\t\t\t}else{\n\t\t\t\t\tfinal int from = sc.nextInt() - 1;\n\t\t\t\t\tfinal int to = sc.nextInt() - 1;\n\t\t\t\t\t\n\t\t\t\t\tif(!wuf.same(from, to)){\n\t\t\t\t\t\tSystem.out.println(\"UNKNOWN\");\n\t\t\t\t\t}else{\n\t\t\t\t\t\tSystem.out.println(wuf.get_diff(from, to));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t//System.out.println(\"P : \" + Arrays.toString(wuf.parent));\n\t\t\t\t//System.out.println(\"D : \" + Arrays.toString(wuf.diff_weight));\n\t\t\t}\n\t\t\t\n\t\t}\n\n\t\tsc.close();\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n \npublic class Main {\n    public static int N;\n    public static int M;\n    public static int[] p;\n    public static int[] rank;\n    public static int[] w;\n \n    public static boolean same(int x, int y) {\n        return findSet(x) == findSet(y);\n    }\n \n    public static void unite(int a, int b, int w) {\n        int i = findSet(a);\n        int j = findSet(b);\n\t\n        if (i == j){\n\t    return;\n\t}\n        if (rank[i] > rank[j]){\n            p[j] = p[i];\n\t    w[j] = w;\n        } else {\n            p[i] = p[j];\n\t    w[i] = -w;\n            if(rank[i] == rank[j]){\n            rank[j]++;\n            }\n        }\t\n    }\n \n    public static int findSet(int i) {\n       if(p[i] == i){ \n           return i;\n        }else{\n          return p[i] = findSet(p[i]);\n        }\n    }\n \n    public static void DisjointSet() {\n        p = new int[N];\n        rank = new int[N];\n\tw = new int[N];\n \n        for (int i = 0; i < N; i++) {\n            p[i] = i;\n            rank[i] = 0;\n\t    w[i] = 0;\n        }\n    }\n    \n    public static void main (String[] args){\n        Scanner scanner = new Scanner(System.in);\n\twhile(true){   \n\t    N = scanner.nextInt();\n\t    DisjointSet();\n\t    M = scanner.nextInt();\n\t    if(N==0 & M == 0) break;\n\t    \n\t    for (int i = 0; i < M; i++) {\n\t\tif(scanner.next().equals(\"!\")){\n\t\t    int a = scanner.nextInt();\n\t\t    int b = scanner.nextInt();\n\t\t    int w = scanner.nextInt();\n\t\t    \n\t\t    a--;\n\t\t    b--;\n\t\t    unite(a, b, w);\n\t\t}else{\n\t\t    if(same(a,b)==false){\n\t\t\tSystem.out.println(\"UNKNOWN\");\n\t\t    }else{\n\t\t\tSystem.out.println(w[b]-w[a]);\n\t\t    }\n\t\t}\n\t    }\n\t}\t\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.StringTokenizer;\n\npublic class Main implements Runnable {\n\t//@start\n\tpublic static class WeightedUnionFind {\n\t\tint[] par; // 親の番号\n\t\tint[] ws; // 親との重みの差\n\n\t\tpublic WeightedUnionFind(int n) {\n\t\t\tpar = new int[n];\n\t\t\tws = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tpar[i] = -1;\n\t\t\t}\n\t\t}\n\n\t\tpublic int find(int x) {\n\t\t\tif (par[x] < 0) {\n\t\t\t\treturn x;\n\t\t\t} else {\n\t\t\t\tfinal int parent = find(par[x]);\n\t\t\t\tws[x] += ws[par[x]];\n\t\t\t\treturn par[x] = parent;\n\t\t\t}\n\t\t}\n\n\t\tpublic int weight(int x) {\n\t\t\tfind(x);\n\t\t\treturn ws[x];\n\t\t}\n\n\t\tpublic boolean union(int x, int y, int w) { // x <-(w)- y (x + w = y)\n\t\t\tw += weight(x);\n\t\t\tw -= weight(y);\n\t\t\tx = find(x);\n\t\t\ty = find(y);\n\n\t\t\tif (x != y) {\n\t\t\t\tif(par[y] < par[x]) {  // 多い方が根になるようにスワップする.\n\t                int tmp = x; x = y; y = tmp; w = -w;\n\t            }\n\t\t\t\tpar[x] += par[y];\n\t\t\t\tpar[y] = x;\n\t\t\t\tws[y] = w;\n\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tpublic boolean same(int x, int y) {\n\t\t\treturn find(x) == find(y);\n\t\t}\n\n\t\tpublic Integer diff(int x, int y) { // x - y を求める. 比較不能ならnull.\n\t\t\tif (!same(x, y)) {\n\t\t\t\treturn null;\n\t\t\t} else {\n\t\t\t\treturn this.weight(x) - this.weight(y);\n\t\t\t}\n\t\t}\n\n\t\tpublic int size(int x) {\n\t\t\treturn -par[find(x)];\n\t\t}\n\t}\n\t//@end\n\t\n\tpublic void run() {\n\n\t\ttry {\n\t\t\tScanner sc = new Scanner(System.in);\n\n\t\t\twhile (true) {\n\t\t\t\tfinal int n = sc.nextInt();\n\t\t\t\tfinal int m = sc.nextInt();\n\n\t\t\t\tif (n == 0 && m == 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tWeightedUnionFind uf = new WeightedUnionFind(n);\n\n\t\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\t\tfinal String ops = sc.next();\n\n\t\t\t\t\tif (\"?\".equals(ops)) {\n\t\t\t\t\t\tfinal int r = sc.nextInt() - 1;\n\t\t\t\t\t\tfinal int l = sc.nextInt() - 1;\n\n\t\t\t\t\t\tif (!uf.same(r, l)) {\n\t\t\t\t\t\t\tSystem.out.println(\"UNKNOWN\");\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tSystem.out.println(uf.weight(l) - uf.weight(r));\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfinal int r = sc.nextInt() - 1;\n\t\t\t\t\t\tfinal int l = sc.nextInt() - 1;\n\t\t\t\t\t\tfinal int w = sc.nextInt();\n\n\t\t\t\t\t\tuf.union(r, l, w);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tsc.close();\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tnew Thread(null, new Main(), \"RUN\", 8 * 1024 * 1024).start();\n\t}\n\n\tpublic static class Scanner {\n\t\tprivate BufferedReader br;\n\t\tprivate StringTokenizer tok;\n\n\t\tpublic Scanner(InputStream is) throws IOException {\n\t\t\tbr = new BufferedReader(new InputStreamReader(is));\n\t\t}\n\n\t\tprivate void getLine() throws IOException {\n\t\t\twhile (!hasNext()) {\n\t\t\t\ttok = new StringTokenizer(br.readLine());\n\t\t\t}\n\t\t}\n\n\t\tprivate boolean hasNext() {\n\t\t\treturn tok != null && tok.hasMoreTokens();\n\t\t}\n\n\t\tpublic String next() throws IOException {\n\t\t\tgetLine();\n\t\t\treturn tok.nextToken();\n\t\t}\n\n\t\tpublic int nextInt() throws IOException {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\t// 他のnextXXXもXXX.parseXXX()メソッドを使って作れるので省略\n\n\t\tpublic void close() throws IOException {\n\t\t\tbr.close();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.Map.Entry;\nimport java.util.Set;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tIO io = new IO();\n\t\twhile(true) {\n\t\t\tint n = io.nextInt();\n\t\t\tint m = io.nextInt();\n\t\t\tif (n == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tUnionFind p = new UnionFind(n);\n\t\t\tfor(int i=0;i<m;i++) {\n\t\t\t\tchar c = io.next().charAt(0);\n\t\t\t\tif (c == '!') {\n\t\t\t\t\tint a = io.nextInt()-1;\n\t\t\t\t\tint b = io.nextInt()-1;\n\t\t\t\t\tint w = io.nextInt();\n\t\t\t\t\tp.union(a, b, w);\n\t\t\t\t}else{\n\t\t\t\t\tint a = io.nextInt()-1;\n\t\t\t\t\tint b = io.nextInt()-1;\n\t\t\t\t\tif (!p.isConnected(a, b)) {\n\t\t\t\t\t\tio.println(\"UNKNOWN\");\n\t\t\t\t\t}else{\n\t\t\t\t\t\tint root = p.root(a);\n\t\t\t\t\t\tlong diff = p.data[root].get(b) - p.data[root].get(a);\n\t\t\t\t\t\tio.println(diff);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tio.flush();\n\t}\n\n}\n\nclass UnionFind {\n\tint[] root;\n\tHashMap<Integer,Long>[] data;\n\n\t@SuppressWarnings(\"unchecked\")\n\tpublic UnionFind(int size) {\n\t\troot = new int[size];\n\t\tArrays.fill(root, -1);\n\t\tdata = new HashMap[size];\n\t\tfor(int i=0;i<size;i++) {\n\t\t\tdata[i] = new HashMap<Integer, Long>();\n\t\t\tdata[i].put(i, 0L);\n\t\t}\n\t}\n\tpublic void union(int a_,int b_,int w) {\n\t\tint a = root(a_);\n\t\tint b = root(b_);\n\t\tif (a!=b) {\n\t\t\tif (root[b] < root[a]) {\n\t\t\t\tint tmp = b;\n\t\t\t\tb = a;\n\t\t\t\ta = tmp;\n\t\t\t\tw *= -1;\n\t\t\t\ttmp = b_;\n\t\t\t\tb_ = a_;\n\t\t\t\ta_ = tmp;\n\t\t\t}\n\t\t\troot[a] += root[b];\n\t\t\troot[b] = a;\n\t\t\tlong w2 = w + data[a].get(a_) - data[b].get(b_);\n\t\t\tSet<Entry<Integer, Long>> entrySet = data[b].entrySet();\n\t\t\tfor(Entry<Integer, Long> entry: entrySet) {\n\t\t\t\tdata[a].put(entry.getKey(), entry.getValue() + w2);\n\t\t\t}\n\t\t\tdata[b] = null;\n//\t\t\tSystem.out.println(\"----\");\n//\t\t\tfor(int i=0;i<data.length;i++) {\n//\t\t\t\tSystem.out.println(data[i]);\n//\t\t\t}\n\t\t}\n\t}\n\tpublic boolean isConnected(int x,int y) {\n\t\treturn root(x)==root(y);\n\t}\n\tpublic int root(int x) {\n\t\treturn root[x] < 0 ? x : (root[x] = root(root[x]));\n\t}\n\tpublic int size(int x) {\n\t\treturn -root[root(x)];\n\t}\n\tpublic String toString() {\n\t\treturn Arrays.toString(root);\n\t}\n}\n\nclass IO {\n\tBufferedReader bi = new BufferedReader(new InputStreamReader(System.in));\n\tStringBuilder out = new StringBuilder();\n\tint index = 0;\n\tString bfl = null;\n\tString[] bf = new String[0];\n\tprivate boolean read() {\n\t\ttry {\n\t\t\tbfl = bi.readLine();\n\t\t\tif (bfl == null) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tbf = bfl.split(\"\\\\s\");\n\t\t\tindex = 0;\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\treturn true;\n\t}\n\tpublic boolean hasNext() { return index < bf.length ? true : read(); }\n\tpublic boolean hasNextLine() { return read(); }\n\tpublic String next() { return hasNext() ? bf[index++] : null; }\n\tpublic String nextLine() { return hasNextLine() ? bfl : null; }\n\tpublic int nextInt() { return Integer.parseInt(next()); }\n\tpublic long nextLong() { return Long.parseLong(next()); }\n\tpublic double nextDouble() { return Double.parseDouble(next()); };\n\tpublic void println(long x) { out.append(x); out.append(\"\\n\"); }\n\tpublic void println(double x) { out.append(x); out.append(\"\\n\"); }\n\tpublic void println(String s) { out.append(s); out.append(\"\\n\"); }\n\tpublic void print(long x) { out.append(x); }\n\tpublic void print(double x) { out.append(x); }\n\tpublic void print(String s) { out.append(s); }\n\tpublic void flush() {System.out.print(out); out = new StringBuilder(); }\n\tpublic int[] arrayInt(int n) {\n\t\tint[] a = new int[n];\n\t\tfor(int i=0;i<n;i++) {\n\t\t\ta[i] = nextInt();\n\t\t}\n\t\treturn a;\n\t}\n\tpublic long[] arrayLong(int n) {\n\t\tlong[] a = new long[n];\n\t\tfor(int i=0;i<n;i++) {\n\t\t\ta[i] = nextLong();\n\t\t}\n\t\treturn a;\n\t}\n\tpublic double[] arrayDouble(int n) {\n\t\tdouble[] a = new double[n];\n\t\tfor(int i=0;i<n;i++) {\n\t\t\ta[i] = nextDouble();\n\t\t}\n\t\treturn a;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\nimport java.util.Arrays;\n\npublic class Main {\n\tMyScanner sc = new MyScanner();\n\tScanner sc2 = new Scanner(System.in);\n\tfinal int MOD = 1000000007;\n\tint[] dx = { 1, 0, 0, -1 };\n\tint[] dy = { 0, 1, -1, 0 };\n\n\tint N, M, a, b, w;\n\tint[] parent;\n\tNode[] node;\n\n\tvoid run() {\n\t\tfor (;;) {\n\t\t\tN = sc.nextInt(); // 荷物数\n\t\t\tM = sc.nextInt(); // クエリ数\n\t\t\tif ((N | M) == 0) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tparent = new int[N + 1];\n\t\t\tnode = new Node[N + 1];\n\t\t\tinit();\n\t\t\tfor (int i = 0; i < M; i++) {\n\t\t\t\tString query = sc.next();\n\t\t\t\ta = sc.nextInt();\n\t\t\t\tb = sc.nextInt();\n\t\t\t\tif (query.equals(\"!\")) {\n\t\t\t\t\tw = sc.nextInt();\n\t\t\t\t\tunion(a, b, w);\n\t\t\t\t} else if (query.equals(\"?\")) {\n\t\t\t\t\tSystem.out.println(same(a, b) ? node[a].weight\n\t\t\t\t\t\t\t- node[b].weight : \"UNKNOWN\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid init() {\n\t\tfor (int i = 0; i <= N; i++) {\n\t\t\tparent[i] = i;\n\t\t\tnode[i] = new Node(0, 0);\n\t\t}\n\t}\n\n\tvoid union(int x, int y, int w) {\n\t\tint rootX = find(x);\n\t\tint rootY = find(y);\n\t\tif (rootX == rootY) {\n\t\t\treturn;\n\t\t}\n\t\tif (node[rootX].rank < node[rootY].rank) {\n\t\t\tnode[rootX].weight = w - node[x].weight + node[y].weight;\n\t\t\tparent[rootX] = rootY;\n\t\t} else {\n\t\t\tnode[rootY].weight = -w - node[y].weight + node[x].weight;\n\t\t\tparent[rootY] = rootX;\n\n\t\t\tif (node[rootX].rank == node[rootY].rank) {\n\t\t\t\tnode[rootX].rank++;\n\t\t\t}\n\t\t}\n\t}\n\n\tint find(int target) {\n\t\tif (parent[target] == target) {\n\t\t\treturn target;\n\t\t} else {\n\t\t\tnode[target].weight += node[parent[target]].weight;\n\t\t\treturn find(parent[target]);\n\t\t}\n\t}\n\n\tboolean same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\n\tclass Node {\n\t\tint weight;\n\t\tint rank;\n\n\t\t/**\n\t\t * @param weight\n\t\t * @param rank\n\t\t */\n\t\tpublic Node(int weight, int rank) {\n\t\t\tsuper();\n\t\t\tthis.weight = weight;\n\t\t\tthis.rank = rank;\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tvoid debug(Object... o) {\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n\n\tvoid debug2(int[][] array) {\n\t\tfor (int i = 0; i < array.length; i++) {\n\t\t\tfor (int j = 0; j < array[i].length; j++) {\n\t\t\t\tSystem.out.print(array[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\n\tclass MyScanner {\n\t\tint nextInt() {\n\t\t\ttry {\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (c != '-' && (c < '0' || '9' < c))\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tif (c == '-')\n\t\t\t\t\treturn -nextInt();\n\t\t\t\tint res = 0;\n\t\t\t\tdo {\n\t\t\t\t\tres *= 10;\n\t\t\t\t\tres += c - '0';\n\t\t\t\t\tc = System.in.read();\n\t\t\t\t} while ('0' <= c && c <= '9');\n\t\t\t\treturn res;\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tString next() {\n\t\t\ttry {\n\t\t\t\tStringBuilder res = new StringBuilder(\"\");\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (Character.isWhitespace(c))\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tdo {\n\t\t\t\t\tres.append((char) c);\n\t\t\t\t} while (!Character.isWhitespace(c = System.in.read()));\n\t\t\t\treturn res.toString();\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n \npublic class Main {\n    public static int N;\n    public static int M;\n    public static int[] p;\n    public static int[] rank;\n    public static int[] weight;\n\n    public static boolean same(int x, int y) {\n        return findSet(x) == findSet(y);\n    }\n \n    public static void unite(int x, int y, int w) {\n        int i = findSet(x);\n        int j = findSet(y);\n        w -= weight[j] - weight[i];\n\n        if (i == j){\n\t    return;\n\t}\n        if (rank[i] > rank[j]){\n            p[j] = p[i];\n            weight[j] = w;\n        } else {\n            p[i] = p[j];\n            weight[i] = -w;\n            if(rank[i] == rank[j]){\n            rank[j]++;\n            }\n        }\t\n    }\n \n    public static int findSet(int i) {\n       if(p[i] == i){ \n           return i;\n        }else{\n          return p[i] = findSet(p[i]);\n        }\n    }\n \n    public static void DisjointSet() {\n        p = new int[N];\n        rank = new int[N];\n        weight = new int[N];\n \n        for (int i = 0; i < N; i++) {\n            p[i] = i;\n            rank[i] = 0;\n            weight[i] = 0;\n        }\n    }\n \n \n    public static void main (String[] args){\n        Scanner scanner = new Scanner(System.in);\n        while(true){\n        N = scanner.nextInt();\n        M = scanner.nextInt();\n\n        if(N==0 & M==0){\n           break;\n        }\n \n        DisjointSet();\n\n        for (int i = 0; i < M; i++) {\n            if(scanner.next().equals(\"!\")){\n            int a = scanner.nextInt();\n            int b = scanner.nextInt();\n            int w = scanner.nextInt();\n \n            a--; b--;   \n            unite(a, b, w);\n            }else{\n               if(same(x, y)){\n                    System.out.println(\"UNKNOWN\");\n                }else{\n                    System.out.println(weight[b]-weight[a]);\n\t\t}\n            }\n        }\n       }\n      \n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n \npublic class Main {\n    public static int N;\n    public static int M;\n    public static int[] p;\n    public static int[] rank;\n    public static int[] w;\n \n    public static boolean same(int x, int y) {\n        return findSet(x) == findSet(y);\n    }\n \n    public static void unite(int a, int b, int w) {\n        int i = findSet(a);\n        int j = findSet(b);\n\tw -= w[b] - w[a];\n\t\n        if (i == j){\n\t    return;\n\t}\n        if (rank[i] > rank[j]){\n            p[j] = p[i];\n\t    w[j] = w;\n        } else {\n            p[i] = p[j];\n\t    w[x] = -w;\n            if(rank[i] == rank[j]){\n            rank[j]++;\n            }\n        }\t\n    }\n \n    public static int findSet(int i) {\n       if(p[i] == i){ \n           return i;\n        }else{\n          return p[i] = findSet(p[i]);\n        }\n    }\n \n    public static void DisjointSet() {\n        p = new int[N];\n        rank = new int[N];\n\tw = new int[N];\n \n        for (int i = 0; i < N; i++) {\n            p[i] = i;\n            rank[i] = 0;\n\t    w[i] = 0;\n        }\n    }\n    \n    public static void main (String[] args){\n        Scanner scanner = new Scanner(System.in);\n\twhile(true){   \n\t    N = scanner.nextInt();\n\t    DisjointSet();\n\t    M = scanner.nextInt();\n\t    if(N==0 & M == 0) break;\n\t    \n\t    for (int i = 0; i < M; i++) {\n\t\tif(scanner.next().equals(\"!\")){\n\t\t    int a = scanner.nextInt();\n\t\t    int b = scanner.nextInt();\n\t\t    int w = scanner.nextInt();\n\t\t    \n\t\t    a--;\n\t\t    b--;\n\t\t    unite(a, b, w);\n\t\t}else{\n\t\t    if(!same(a,b)){\n\t\t\tSystem.out.println(\"UNKNOWN\");\n\t\t    }else{\n\t\t\tSystem.out.println(w[b]-w[a]);\n\t\t    }\n\t\t}\n\t    }\n\t}\t\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.io.Reader;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\n\npublic class Main {\n\tstatic FastScanner sc = new FastScanner(System.in);\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tint[] A = new int[100000];\n\t\tint[] B = new int[100000];\n\t\tint[] W = new int[100000];\n\t\tboolean[] type = new boolean[100000];\n\t\tint[] dist = new int[100000];\n\t\tArrayList<ArrayList<Edge>> graph = new ArrayList<ArrayList<Edge>>();\n\t\tfor (int i = 0; i < 100000; ++i) {\n\t\t\tgraph.add(new ArrayList<Edge>());\n\t\t}\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\twhile (true) {\n\t\t\tint N = sc.nextInt();\n\t\t\tint M = sc.nextInt();\n\t\t\tif (N == 0 || M == 0) break;\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tgraph.get(i).clear();\n\t\t\t}\n\t\t\tfor (int i = 0; i < M; ++i) {\n\t\t\t\ttype[i] = sc.nextChar() == '!';\n\t\t\t\tA[i] = sc.nextInt() - 1;\n\t\t\t\tB[i] = sc.nextInt() - 1;\n\t\t\t\tif (type[i]) {\n\t\t\t\t\tW[i] = sc.nextInt();\n\t\t\t\t\tgraph.get(A[i]).add(new Edge(B[i], W[i]));\n\t\t\t\t\tgraph.get(B[i]).add(new Edge(A[i], -W[i]));\n\t\t\t\t}\n\t\t\t}\n\t\t\tArrays.fill(dist, Integer.MIN_VALUE);\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tif (dist[i] != Integer.MIN_VALUE) continue;\n\t\t\t\tArrayDeque<Integer> q = new ArrayDeque<Integer>();\n\t\t\t\tq.add(i);\n\t\t\t\tdist[i] = 0;\n\t\t\t\twhile (!q.isEmpty()) {\n\t\t\t\t\tint cur = q.poll();\n\t\t\t\t\tfor (Edge e : graph.get(cur)) {\n\t\t\t\t\t\tint next = e.to;\n\t\t\t\t\t\tif (dist[next] != Integer.MIN_VALUE) continue;\n\t\t\t\t\t\tdist[next] = dist[cur] + e.w;\n\t\t\t\t\t\tq.add(next);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tUnionFind uf = new UnionFind(100000);\n\t\t\tfor (int i = 0; i < M; ++i) {\n\t\t\t\tif (type[i]) {\n\t\t\t\t\tif (A[i] < 0 || A[i] >= N || B[i] < 0 || B[i] >= N) continue;\n\t\t\t\t\tuf.union(A[i], B[i]);\n\t\t\t\t} else {\n//\t\t\t\t\tif (A[i] < 0 || A[i] >= N || B[i] < 0 || B[i] >= N || !uf.find(A[i], B[i])) {\n//\t\t\t\t\t\tout.println(\"UNKNOWN\");\n//\t\t\t\t\t} else {\n//\t\t\t\t\t\tout.println(dist[B[i]] - dist[A[i]]);\n//\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic class Edge {\n\t\tint to, w;\n\n\t\tEdge(int to, int w) {\n\t\t\tthis.to = to;\n\t\t\tthis.w = w;\n\t\t}\n\t}\n\n\tstatic class UnionFind {\n\t\tint[] set;\n\n\t\tUnionFind(int n) {\n\t\t\tset = new int[n];\n\t\t\tArrays.fill(set, -1);\n\t\t}\n\n\t\tvoid union(int a, int b) {\n\t\t\tint rtA = root(a);\n\t\t\tint rtb = root(b);\n\t\t\tif (rtA == rtb) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tset[rtA] += set[rtb];\n\t\t\tset[rtb] = rtA;\n\t\t}\n\n\t\tboolean find(int a, int b) {\n\t\t\treturn root(a) == root(b);\n\t\t}\n\n\t\tint root(int a) {\n\t\t\tif (set[a] < 0) {\n\t\t\t\treturn a;\n\t\t\t} else {\n\t\t\t\tset[a] = root(set[a]);\n\t\t\t\treturn set[a];\n\t\t\t}\n\t\t}\n\n\t\tint size(int a) {\n\t\t\treturn -set[root(a)];\n\t\t}\n\t}\n\n\tstatic class FastScanner {\n\t\tReader input;\n\n\t\tFastScanner() {\n\t\t\tthis(System.in);\n\t\t}\n\n\t\tFastScanner(InputStream stream) {\n\t\t\tthis.input = new BufferedReader(new InputStreamReader(stream));\n\t\t}\n\n\t\tint nextInt() throws IOException {\n\t\t\tint sign = 1;\n\t\t\tint b = input.read();\n\t\t\twhile ((b < '0' || '9' < b) && b != '-' && b != '+') {\n\t\t\t\tif (b == -1) return 0;\n\t\t\t\tb = input.read();\n\t\t\t}\n\t\t\tif (b == '-') {\n\t\t\t\tsign = -1;\n\t\t\t\tb = input.read();\n\t\t\t} else if (b == '+') {\n\t\t\t\tb = input.read();\n\t\t\t}\n\t\t\tint ret = b - '0';\n\t\t\twhile (true) {\n\t\t\t\tb = input.read();\n\t\t\t\tif (b < '0' || '9' < b) return ret * sign;\n\t\t\t\tret *= 10;\n\t\t\t\tret += b - '0';\n\t\t\t}\n\t\t}\n\n\t\tchar nextChar() throws IOException {\n\t\t\tint b = input.read();\n\t\t\twhile (Character.isWhitespace((char) b)) {\n\t\t\t\tb = input.read();\n\t\t\t}\n\t\t\treturn (char) b;\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.ListIterator;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\t\n\tpublic static class WeightUnionFind{\n\t\tint[] parent;\n\t\tint[] rank;\n\t\tint[] diff_weight;\n\t\t\n\t\tWeightUnionFind(int n){\n\t\t\tparent=new int[n];\n\t\t\trank = new int[n];\n\t\t\tdiff_weight = new int[n];\n\t\t\t\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tparent[i]=i;\n\t\t\t\trank[i] = 0;\n\t\t\t\tdiff_weight[i] = 0;\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic int find(int x){\n\t\t\tif(parent[x]==x){\n\t\t\t\treturn x;\n\t\t\t}\n\t\t\t\n\t\t\treturn find(parent[x]);\n\t\t}\n\t\t\n\t\tpublic int find_diff(int x){\n\t\t\tif(parent[x] == x){\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\t\n\t\t\treturn find_diff(parent[x]) + diff_weight[x];\n\t\t}\n\t\t\n\t\tpublic Boolean same(int x,int y){\n\t\t\treturn find(x)==find(y);\n\t\t}\n\t\t\n\t\tpublic int get_diff(int x, int y){\n\t\t\tif(!same(x, y)){\n\t\t\t\treturn Integer.MIN_VALUE;\n\t\t\t}else{\n\t\t\t\treturn find_diff(x) - find_diff(y);\n\t\t\t}\n\t\t}\n\t\t/*\n\t\tpublic void unite(int x,int y){\n\t\t\tx = find(x);\n\t\t\ty = find(y);\n\t\t\t\n\t\t\tif(x == y){\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tif(rank[x] < rank[y]){\n\t\t\t\tparent[x] = y;\n\t\t\t}else{\n\t\t\t\tparent[y] = x;\n\t\t\t\tif(rank[x] == rank[y]){\n\t\t\t\t\trank[x]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t*/\n\t\tpublic void set_diff(int x,int y, int d){\n\t\t\tfinal int find_x = find(x);\n\t\t\tfinal int find_y = find(y);\n\t\t\t\n\t\t\tif(find_x == find_y){\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\t//System.out.println(x + \" \" + find_x + \" \" + y + \" \" + find_y + \" \" + diff_weight[y] + \" \" + diff_weight[x]);\n\t\t\td -= find_diff(x) - find_diff(y);\n\t\t\t\n\t\t\tif(rank[find_x] < rank[find_y]){\n\t\t\t\t//diff_weight[x] += d + find_diff(y);\n\t\t\t\tdiff_weight[find_x] = d;\n\t\t\t\t\n\t\t\t\tparent[find_x] = find_y;\n\t\t\t}else{\n\t\t\t\tdiff_weight[find_y] = -d;\n\t\t\t\t\n\t\t\t\tparent[find_y] = find_x;\n\t\t\t\tif(rank[find_x] == rank[find_y]){\n\t\t\t\t\trank[find_x]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile (true) {\n\t\t\tfinal int N = sc.nextInt();\n\t\t\tfinal int M = sc.nextInt();\n\n\t\t\tif (N == 0 && M == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tSystem.gc();\n\t\t\t\n\t\t\tWeightUnionFind wuf = new WeightUnionFind(N);\n\t\t\t\n\t\t\tfor(int i = 0; i < M; i++){\n\t\t\t\tString op = sc.next();\n\t\t\t\t\n\t\t\t\tif(op.equals(\"!\")){\n\t\t\t\t\tfinal int from = sc.nextInt() - 1;\n\t\t\t\t\tfinal int to = sc.nextInt() - 1;\n\t\t\t\t\tfinal int w = sc.nextInt();\n\t\t\t\t\t\n\t\t\t\t\twuf.set_diff(from, to, w);\n\t\t\t\t\t//System.out.println(\"DIFF \" + from + \" \" + to + \" \" + w);\n\t\t\t\t}else{\n\t\t\t\t\tfinal int from = sc.nextInt() - 1;\n\t\t\t\t\tfinal int to = sc.nextInt() - 1;\n\t\t\t\t\t\n\t\t\t\t\tif(!wuf.same(from, to)){\n\t\t\t\t\t\tSystem.out.println(\"UNKOWN\");\n\t\t\t\t\t}else{\n\t\t\t\t\t\tSystem.out.println(wuf.get_diff(from, to));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t//System.out.println(\"P : \" + Arrays.toString(wuf.parent));\n\t\t\t\t//System.out.println(\"D : \" + Arrays.toString(wuf.diff_weight));\n\t\t\t}\n\t\t\t\n\t\t}\n\n\t\tsc.close();\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n \npublic class Main {\n    public static int N;\n    public static int M;\n    public static int[] p;\n    public static int[] rank;\n    public static int[] weight;\n\n    public static boolean same(int x, int y) {\n        return findSet(x) == findSet(y);\n    }\n \n    public static void unite(int x, int y, int w) {\n        int i = findSet(x);\n        int j = findSet(y);\n        w -= weight[j] - weight[i];\n\n        if (i == j){\n\t    return;\n\t}\n        if (rank[i] > rank[j]){\n            p[j] = p[i];\n            weight[j] = w;\n        } else {\n            p[i] = p[j];\n            weight[i] = -w;\n            if(rank[i] == rank[j]){\n\t\trank[j]++;\n            }\n        }\t\n    }\n \n    public static int findSet(int i) {\n\tif(p[i] == i){ \n\t    return i;\n        }else{\n\t    return p[i] = findSet(p[i]);\n        }\n    }\n \n    public static void DisjointSet() {\n        p = new int[N];\n        rank = new int[N];\n        weight = new int[N];\n \n        for (int i = 0; i < N; i++) {\n            p[i] = i;\n            rank[i] = 0;\n            weight[i] = 0;\n        }\n    }\n \n \n    public static void main (String[] args){\n        Scanner scanner = new Scanner(System.in);\n        while(true){\n\t    N = scanner.nextInt();\n\t    M = scanner.nextInt();\n\n\t    if(N==0 |M==0){\n\t\tbreak;\n\t    }\n \n\t    DisjointSet();\n\n\t    for (int i = 0; i < M; i++) {       \n\t\tif(scanner.next().equals(\"!\")){\n\t\t    int a = scanner.nextInt();\n\t\t    int b = scanner.nextInt();\n\t\t    int w = scanner.nextInt();\n \n\t\t    a--; b--;   \n\t\t    unite(a, b, w);\n\t\t}else{ \n\t\t    int a = scanner.nextInt();\n\t\t    int b = scanner.nextInt();\n\t\t    if(same(a,b)){\n\t\t\tSystem.out.println(weight[b] - weight[a]);\n\t\t    }else{\n\t\t\tSystem.out.println(\"UNKNOWN\");\n\t\t    }\n\t\t}\n\t    }\n\t}\n      \n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\nusing Debug = System.Diagnostics.Debug;\nusing SB = System.Text.StringBuilder;\nusing System.Numerics;\nusing static System.Math;\nusing P = System.Numerics.Complex;\nnamespace Program {\n    public class Solver {\n        Random rnd = new Random();\n        public void Solve() {\n            for (; ; )\n            {\n                var n = ri; var m = ri;\n                if (n == 0) return;\n                var group = Enumerate(n, x => new List<int>() { x });\n                var w = new long[n];\n                for (int i = 0; i < m; i++)\n                {\n                    if (rs == \"!\")\n                    {\n                        var u = ri - 1;\n                        var v = ri - 1;\n                        var x = rl;\n                        if (group[u] == group[v]) continue;\n                        x -= w[v] - w[u];\n                        if (group[u].Count < group[v].Count)\n                        {\n                            Swap(ref u, ref v);\n                            x *= -1;\n                        }\n                        //w[v]-w[u]=x\n                        var G = group[v];\n                        foreach (var id in G)\n                        {\n                            group[id] = group[u];\n                            w[id] += x;\n                            group[u].Add(id);\n                        }\n\n                    }\n                    else\n                    {\n                        var u = ri - 1;\n                        var v = ri - 1;\n                        if (group[u] != group[v]) Console.WriteLine(\"UNKNOWN\");\n                        else Console.WriteLine(w[v] - w[u]);\n                    }\n                }\n            }\n\n        }\n        const long INF = 1L << 60;\n        int ri { get { return sc.Integer(); } }\n        long rl { get { return sc.Long(); } }\n        double rd { get { return sc.Double(); } }\n        string rs { get { return sc.Scan(); } }\n        public IO.StreamScanner sc = new IO.StreamScanner(Console.OpenStandardInput());\n\n        static T[] Enumerate<T>(int n, Func<int, T> f) {\n            var a = new T[n];\n            for (int i = 0; i < n; ++i) a[i] = f(i);\n            return a;\n        }\n        static public void Swap<T>(ref T a, ref T b) { var tmp = a; a = b; b = tmp; }\n    }\n}\n\n#region main\nstatic class Ex {\n    static public string AsString(this IEnumerable<char> ie) { return new string(ie.ToArray()); }\n    static public string AsJoinedString<T>(this IEnumerable<T> ie, string st = \" \") {\n        return string.Join(st, ie);\n    }\n    static public void Main() {\n        Console.SetOut(new Program.IO.Printer(Console.OpenStandardOutput()) { AutoFlush = false });\n        var solver = new Program.Solver();\n        solver.Solve();\n        Console.Out.Flush();\n    }\n}\n#endregion\n#region Ex\nnamespace Program.IO {\n    using System.IO;\n    using System.Text;\n    using System.Globalization;\n\n    public class Printer: StreamWriter {\n        public override IFormatProvider FormatProvider { get { return CultureInfo.InvariantCulture; } }\n        public Printer(Stream stream) : base(stream, new UTF8Encoding(false, true)) { }\n    }\n\n    public class StreamScanner {\n        public StreamScanner(Stream stream) { str = stream; }\n\n        public readonly Stream str;\n        private readonly byte[] buf = new byte[1024];\n        private int len, ptr;\n        public bool isEof = false;\n        public bool IsEndOfStream { get { return isEof; } }\n\n        private byte read() {\n            if (isEof) return 0;\n            if (ptr >= len)\n            {\n                ptr = 0;\n                if ((len = str.Read(buf, 0, 1024)) <= 0)\n                {\n                    isEof = true;\n                    return 0;\n                }\n            }\n            return buf[ptr++];\n        }\n\n        public char Char() {\n            byte b = 0;\n            do b = read(); while ((b < 33 || 126 < b) && !isEof);\n            return (char)b;\n        }\n        public string Scan() {\n            var sb = new StringBuilder();\n            for (var b = Char(); b >= 33 && b <= 126; b = (char)read()) sb.Append(b);\n            return sb.ToString();\n        }\n        public string ScanLine() {\n            var sb = new StringBuilder();\n            for (var b = Char(); b != '\\n' && b != 0; b = (char)read()) if (b != '\\r') sb.Append(b);\n            return sb.ToString();\n        }\n        public long Long() { return isEof ? long.MinValue : long.Parse(Scan()); }\n        public int Integer() { return isEof ? int.MinValue : int.Parse(Scan()); }\n        public double Double() { return isEof ? double.NaN : double.Parse(Scan(), CultureInfo.InvariantCulture); }\n    }\n}\n\n#endregion\n"
  },
  {
    "language": "Ruby",
    "code": "### subroutines\n\ndef rootd(k)\n  rk = k\n  rd = 0\n  while $uts[rk] != rk\n    rd += $dfs[rk]\n    rk = $uts[rk]\n  end\n  $uts[k] = rk\n  $dfs[k] = rd\n  [rk, rd]\nend\n\n### main\n\nloop do\n  n, m = gets.split.map(&:to_i)\n  break if (n | m) == 0\n\n  $uts = Array.new(n + 1){|i| i}\n  $dfs = Array.new(n + 1){0}\n\n  m.times do\n    cols = gets.strip.split\n    \n    op, a, b = cols\n    a = a.to_i\n    b = b.to_i\n    ra, da = rootd(a)\n    rb, db = rootd(b)\n    #p [\"rootd\", a, ra, da]\n    #p [\"rootd\", b, rb, db]\n    \n    if op == '!'\n      if ra == rb\n        next if w == da - db\n        puts \"Error\"\n        exit\n      end\n\n      w = cols[3].to_i\n      rd = w + da - db\n      if rd >= 0\n        $uts[ra] = rb\n        $dfs[ra] = rd\n      else\n        $uts[rb] = ra\n        $dfs[rb] = -rd\n      end\n    else\n      if ra != rb\n        puts \"UNKNOWN\"\n      else\n        d = da - db\n        puts d\n      end\n    end\n\n    #p cols\n    #p $uts\n    #p $dfs\n  end\nend"
  },
  {
    "language": "Ruby",
    "code": "class UnionFind\n\tdef initialize\n\t\t@node = []\n\tend\n\n\tclass Node\n\t\tdef initialize(obj)\n\t\t\t@obj = obj\n\t\t\t@parent = self\n\t\t\t@dw = 0\n\t\tend\n\n\t\tattr_accessor :parent, :dw\n\tend\n\n\tdef union(x, y, dw0)\n\t\tu, dw1 = root_and_dw(@node[x] ||= Node.new(x))\n\t\tv, dw2 = root_and_dw(@node[y] ||= Node.new(y))\n\t\treturn if u == v\n\t\tv.parent, v.dw = u, dw0 + dw1 - dw2\n\tend\n\n\tdef weight_diff(x, y)\n\t\treturn nil unless u = @node[x]\n\t\treturn nil unless v = @node[y]\n\t\tr1, dw1 = root_and_dw(u)\n\t\tr2, dw2 = root_and_dw(v)\n\t\treturn nil if r1 != r2\n\t\tdw2 - dw1\n\tend\nend\n\ndef root_and_dw(u)\n\treturn [u, 0] if u.parent == u\n\tpath = [u]\n\tpath << path[-1].parent until path[-1].parent == path[-1]\n\troot = path[-1]\n\tdw = 0\n\tuntil path.empty?\n\t\tv = path.pop\n\t\tv.parent, v.dw = root, dw += v.dw\n\tend\n\t[root, u.dw]\nend\t\n\n\nloop do\n\tn, m = gets.split.map &:to_i\n\tbreak if n == 0\n\tuf = UnionFind.new\n\n\tm.times do\n\t\tq, a, b, dw = gets.chomp.split\n\t\ta, b = a.to_i, b.to_i\n\t\tif q == ?!\n\t\t\tuf.union(a, b, dw.to_i)\n\t\telse\n\t\t\tdw = uf.weight_diff(a, b)\n\t\t\tputs dw ? dw : 'UNKNOWN'\n\t\tend\n\tend\nend"
  },
  {
    "language": "Ruby",
    "code": "class UnionFind\n\tdef initialize\n\t\t@obj_to_node = {}\n\tend\n\n\tdef add(obj)\n\t\t@obj_to_node[obj] ||= Node.new(obj)\n\tend\n\n\tclass Node\n\t\tdef initialize(obj)\n\t\t\t@obj = obj\n\t\t\t@parent = self\n\t\t\t@dw = 0\n\t\tend\n\n\t\tdef root_and_dw\n\t\t\treturn [self, 0] if @parent == self\n\t\t\tr, dw = @parent.root_and_dw\n\t\t\t[@parent = r, @dw += dw]\n\t\tend\t\n\n\t\tattr_accessor :parent, :dw\n\tend\n\n\tdef union(x, y, dw0)\n\t\tu, dw1 = (@obj_to_node[x] ||= Node.new(x)).root_and_dw\n\t\tv, dw2 = (@obj_to_node[y] ||= Node.new(y)).root_and_dw\n\t\treturn if u == v\n\t\tv.parent, v.dw = u, dw0 + dw1 - dw2\n\tend\n\n\tdef weight_diff(x, y)\n\t\treturn nil unless u = @obj_to_node[x]\n\t\treturn nil unless v = @obj_to_node[y]\n\t\tr1, dw1 = u.root_and_dw\n\t\tr2, dw2 = v.root_and_dw\n\t\treturn nil if r1 != r2\n\t\tdw2 - dw1\n\tend\nend\n\n\nloop do\n\tn, m = gets.split.map &:to_i\n\tbreak if n == 0\n\tuf = UnionFind.new\n\n\tm.times do\n\t\tq, a, b, dw = gets.chomp.split\n\t\tif q == ?!\n\t\t\tdw = dw.to_i\n\t\t\tuf.union(a, b, dw)\n\t\telse\n\t\t\tdw = uf.weight_diff(a, b)\n\t\t\tputs dw ? dw : 'UNKNOWN'\n\t\tend\n\tend\nend"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.ascii;\nimport std.range;\nimport std.array;\nimport std.functional;\nimport std.algorithm;\nimport std.conv;\nimport std.container;\nimport std.math;\nimport std.numeric;\nimport std.string;\nimport std.c.string;\nimport std.random;\nimport std.regex;\nimport std.typecons;\n\n/* 重みつきUnionFind木 */\nclass UnionFindW {\n    alias long INT;\n    static const INT INF = long.max / 4;\n    struct Pair {\n        int index;\n        INT value;\n    }\n    int[] parent;\n    INT[] value;\n    this(int N) {\n        parent = new int[N + 1]; parent[] = -1;\n        value = new INT[N + 1];  value[] = 0;\n    }\n    /* \n     * root :: インデックス -> (ルートのインデックス, ルートとの距離)\n     */\n    Pair root(int x) {\n        if (parent[x] == -1) return Pair(x, 0);\n        int p = parent[x];\n        auto v = value[x];\n        auto proot = root(p);\n        parent[x] = proot.index;\n        value[x] = v + proot.value;\n        return Pair(parent[x], value[x]);\n    }\n    /* \n     * query :: (インデックスx, インデックスy) -> yとxの差\n     */\n    INT query(int x, int y) {\n        auto xroot = root(x),\n             yroot = root(y);\n        if (xroot.index != yroot.index) return INF;\n        return yroot.value - xroot.value;\n    }\n    /*\n     * merge :: (インデックスx, インデックスy, yとxの差w) -> ()\n     *\n     * xとyがすでに親子関係を持っていて,その差がwでなければ異常終了\n     */\n    void merge(int x, int y, INT w) {\n        auto xroot = root(x),\n             yroot = root(y);\n        if (xroot.index == yroot.index) {\n            assert(query(x, y) == w);\n            return;\n        }\n        auto px = xroot.index, py = yroot.index;\n        auto dx = xroot.value, dy = yroot.value;\n        /* value[y] - value[x] = w\n         * value[x] - value[px] = dx\n         * value[y] - value[py] = dy\n         * value[py] - value[px] = (value[y] - dy) - (value[x] - dx)\n         *                       = (value[y] - value[x]) - (dy - dx)\n         *                       = w - dy + dx\n         */\n        parent[py] = px;\n        value[py] = w - dy + dx;\n    }\n}\n\nvoid main() {\n    int N, M;\n    UnionFindW uf;\n\n    bool solve() {\n        scanf(\"%d %d\\n\", &N, &M);\n        if (N == 0 && M == 0) return false;\n        uf = new UnionFindW(N);\n        foreach (i; 0 .. M) {\n            string s; readf(\"%s \", &s);\n            int a, b, w;\n            if (s == \"!\") {\n                scanf(\"%d %d %d\\n\", &a, &b, &w);\n                a--; b--;\n                uf.merge(a, b, w);\n            } else {\n                scanf(\"%d %d\\n\", &a, &b);\n                a--; b--;\n                auto ans = uf.query(a, b);\n                if (ans == UnionFindW.INF) {\n                    writeln(\"UNKNOWN\");\n                } else {\n                    writeln(ans);\n                }\n            }\n        }\n        return true;\n    }\n    \n    while (solve) {}\n}"
  },
  {
    "language": "D",
    "code": "import std.algorithm;\nimport std.array;\nimport std.ascii;\nimport std.container;\nimport std.conv;\nimport std.math;\nimport std.numeric;\nimport std.range;\nimport std.stdio;\nimport std.string;\nimport std.typecons;\n\nvoid log(A...)(A arg) {\n    stderr.writeln(arg);\n}\nint size(T)(in T s) {\n    return cast(int)s.length;\n}\n\n/* ??\\??????????????????nionFind?????¨ */\nconst int INF = 1<<28;\nclass UnionFindW {\n    int[] parent;\n    int[] value;\n    this(int N) {\n        parent = new int[N + 1]; parent[] = -1;\n        value = new int[N + 1];\n    }\n    alias P = Tuple!(int, \"index\", int, \"dist\");\n    /* \n     * root :: ??§?????????????????£??§?????§??? -> (???????????????????????§?????????????????£??§?????§???, ??????????????????????????????????±¬)\n     */\n    P root(int x) {\n        if (parent[x] == -1) return P(x, 0);\n        int p = parent[x];\n        int v = value[x];\n        P proot = root(p);\n        parent[x] = proot.index;\n        value[x] = v + proot.dist;\n        return P(parent[x], value[x]);\n    }\n    /* \n     * query :: (??§?????????????????£??§?????§???x, ??§?????????????????£??§?????§???y) -> y?????¨x????????????\n     */\n    int query(int x, int y) {\n        P xroot = root(x),\n          yroot = root(y);\n        if (xroot.index != yroot.index) return INF;\n        return yroot.dist - xroot.dist;\n    }\n    /*\n     * merge :: (??§?????????????????£??§?????§???x, ??§?????????????????£??§?????§???y, y?????¨x????????????w(=y-x)) -> ()\n     *\n     * x?????¨y??????????????§?????????????????£?????????????¬??????????????????????,?????´??????????????£?????§???????????£????????°?????°??¶?????¨?????????     */\n    void merge(int x, int y, int w) {\n        P xroot = root(x),\n          yroot = root(y);\n        if (xroot.index == yroot.index) {\n            assert(query(x, y) == w);\n            return;\n        }\n        int px = xroot.index, py = yroot.index;\n        int dx = xroot.dist, dy = yroot.dist;\n        /* value[y] - value[x] = w\n         * value[x] - value[px] = dx\n         * value[y] - value[py] = dy\n         * value[py] - value[px] = (value[y] - dy) - (value[x] - dx)\n         *                       = (value[y] - value[x]) - (dy - dx)\n         *                       = w - dy + dx\n         */\n        parent[py] = px;\n        value[py] = w - dy + dx;\n    }\n}\n\nvoid main() {\n    int N, M;\n    bool input() {\n        readf(\"%d %d\\n\", &N, &M);\n        if (N == 0 && M == 0) return false;\n        return true;\n    }\n    void solve() {\n        auto uf = new UnionFindW(N);\n        foreach (_; 0 .. M) {\n            auto input = readln.chomp.split(\" \").array;\n            int a = input[1].to!int;\n            int b = input[2].to!int;\n            if (input[0] == \"!\") {\n                int w = input[3].to!int;\n                uf.merge(a, b, w);\n            } else { assert(input[0] == \"?\");\n                int ans = uf.query(a, b);\n                if (ans == INF) {\n                    writeln(\"UNKNOWN\");\n                } else {\n                    writeln(ans);\n                }\n            }\n        }\n    }\n    while (input()) solve();\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.ascii;\nimport std.range;\nimport std.array;\nimport std.functional;\nimport std.algorithm;\nimport std.conv;\nimport std.container;\nimport std.math;\nimport std.numeric;\nimport std.string;\nimport std.c.string;\nimport std.random;\nimport std.regex;\nimport std.typecons;\n\n/* 重みつきUnionFind木 */\nclass UnionFindW {\n    struct Pair {\n        int index, value;\n    }\n    int[] parent;\n    int[] value;\n    static const int INF = 1<<28;\n    this(int N) {\n        parent = new int[N + 1]; parent[] = -1;\n        value = new int[N + 1];  value[] = 0;\n    }\n    /* \n     * root :: インデックス -> (ルートのインデックス, ルートとの距離)\n     */\n    Pair root(int x) {\n        if (parent[x] == -1) return Pair(x, 0);\n        int p = parent[x];\n        int v = value[x];\n        auto proot = root(p);\n        parent[x] = proot.index;\n        value[x] = v + proot.value;\n        return Pair(parent[x], value[x]);\n    }\n    /* \n     * query :: (インデックスx, インデックスy) -> yとxの差\n     */\n    int query(int x, int y) {\n        auto xroot = root(x),\n             yroot = root(y);\n        if (xroot.index != yroot.index) return INF;\n        return yroot.value - xroot.value;\n    }\n    /*\n     * merge :: (インデックスx, インデックスy, yとxの差w) -> ()\n     *\n     * xとyがすでに親子関係を持っていて,その差がwでなければ異常終了\n     */\n    void merge(int x, int y, int w) {\n        auto xroot = root(x),\n             yroot = root(y);\n        if (xroot.index == yroot.index) {\n            assert(query(x, y) == w);\n            return;\n        }\n        int px = xroot.index, py = yroot.index;\n        int dx = xroot.value, dy = yroot.value;\n        /* value[y] - value[x] = w\n         * value[x] - value[px] = dx\n         * value[y] - value[py] = dy\n         * value[py] - value[px] = (value[y] - dy) - (value[x] - dx)\n         *                       = (value[y] - value[x]) - (dy - dx)\n         *                       = w - dy + dx\n         */\n        parent[py] = px;\n        value[py] = w - dy + dx;\n    }\n}\n\nvoid main() {\n    int N, M;\n    UnionFindW uf;\n\n    bool solve() {\n        scanf(\"%d %d\\n\", &N, &M);\n        if (N == 0 && M == 0) return false;\n        uf = new UnionFindW(N);\n        foreach (i; 0 .. M) {\n            string s; readf(\"%s \", &s);\n            int a, b, w;\n            if (s == \"!\") {\n                scanf(\"%d %d %d\\n\", &a, &b, &w);\n                a--; b--;\n                uf.merge(a, b, w);\n            } else {\n                scanf(\"%d %d\\n\", &a, &b);\n                a--; b--;\n                auto ans = uf.query(a, b);\n                if (ans == UnionFindW.INF) {\n                    writeln(\"UNKNOWN\");\n                } else {\n                    writeln(ans);\n                }\n            }\n        }\n        return true;\n    }\n    \n    while (solve) {}\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio, std.array, std.string, std.conv, std.algorithm;\nimport std.typecons, std.range, std.random, std.math, std.container;\nimport std.numeric, std.bigint, core.bitop, core.stdc.string;\n\nvoid main() {\n    while (solve) {}\n}\n\nbool solve() {\n    auto s = readln.split.map!(to!int);\n    auto N = s[0];\n    auto M = s[1];\n    if (N == 0) return false;\n\n    auto uf = new UnionFind(N);\n\n    while (M--) {\n        auto q = readln.split;\n        auto a = q[1].to!int - 1;\n        auto b = q[2].to!int - 1;\n        if (q[0] == \"!\") {\n            auto w = q[3].to!int;\n            uf.unite(a, b, w);\n        } else {\n            if (uf.find(a) != uf.find(b)) {\n                writeln(\"UNKNOWN\");\n            } else {\n                writeln(uf.weight[b] - uf.weight[a]);\n            }\n        }\n    }\n\n    return true;\n}\n\n\nclass UnionFind {\n    int N;\n    int[] table;\n    int[] weight;\n    int[][] group;\n\n    this(int n) {\n        N = n;\n        table = new int[](N);\n        fill(table, -1);\n        weight = new int[](N);\n        group = N.iota.map!(i => [i]).array;\n    }\n\n    int find(int x) {\n        return table[x] < 0 ? x : (table[x] = find(table[x]));\n    }\n\n    void unite(int x, int y, int diff) {\n        int ox = x;\n        int oy = y;\n        x = find(x);\n        y = find(y);\n        if (x == y) return;\n\n        if (table[x] > table[y]) {\n            swap(x, y);\n            swap(ox, oy);\n            diff *= -1;\n        }\n\n        int nw = weight[ox] + diff;\n        int ndiff = nw - weight[oy];\n        foreach (i; group[y]) weight[i] += ndiff;\n        foreach (i; group[y]) group[x] ~= i;\n        group[y] = [];\n\n        table[x] += table[y];\n        table[y] = x;\n    }\n}\n\n"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.ascii;\nimport std.range;\nimport std.array;\nimport std.functional;\nimport std.algorithm;\nimport std.conv;\nimport std.container;\nimport std.math;\nimport std.numeric;\nimport std.string;\nimport std.c.string;\nimport std.random;\nimport std.regex;\nimport std.typecons;\n\n/* 重みつきUnionFind木 */\nclass UnionFindW {\n    alias long INT;\n    static const INT INF = long.max / 4;\n    struct Pair {\n        int index;\n        INT value;\n    }\n    int[] parent;\n    INT[] value;\n    this(int N) {\n        parent = new int[N + 1]; parent[] = -1;\n        value = new INT[N + 1];  value[] = 0;\n    }\n    /* \n     * root :: インデックス -> (ルートのインデックス, ルートとの距離)\n     */\n    Pair root(int x) {\n        if (parent[x] == -1) return Pair(x, 0);\n        int p = parent[x];\n        auto v = value[x];\n        auto proot = root(p);\n        parent[x] = proot.index;\n        value[x] = v + proot.value;\n        return Pair(parent[x], value[x]);\n    }\n    /* \n     * query :: (インデックスx, インデックスy) -> yとxの差\n     */\n    INT query(int x, int y) {\n        auto xroot = root(x),\n             yroot = root(y);\n        if (xroot.index != yroot.index) return INF;\n        return yroot.value - xroot.value;\n    }\n    /*\n     * merge :: (インデックスx, インデックスy, yとxの差w) -> ()\n     *\n     * xとyがすでに親子関係を持っていて,その差がwでなければ異常終了\n     */\n    void merge(int x, int y, INT w) {\n        auto xroot = root(x),\n             yroot = root(y);\n        if (xroot.index == yroot.index) {\n            //assert(query(x, y) == w);\n            return;\n        }\n        auto px = xroot.index, py = yroot.index;\n        auto dx = xroot.value, dy = yroot.value;\n        /* value[y] - value[x] = w\n         * value[x] - value[px] = dx\n         * value[y] - value[py] = dy\n         * value[py] - value[px] = (value[y] - dy) - (value[x] - dx)\n         *                       = (value[y] - value[x]) - (dy - dx)\n         *                       = w - dy + dx\n         */\n        parent[py] = px;\n        value[py] = w - dy + dx;\n    }\n}\n\nvoid main() {\n    int N, M;\n    UnionFindW uf;\n\n    bool solve() {\n        scanf(\"%d %d\\n\", &N, &M);\n        if (N == 0 && M == 0) return false;\n        uf = new UnionFindW(N);\n        foreach (i; 0 .. M) {\n            string s; readf(\"%s \", &s);\n            int a, b, w;\n            if (s == \"!\") {\n                scanf(\"%d %d %d\\n\", &a, &b, &w);\n                a--; b--;\n                uf.merge(a, b, w);\n            } else {\n                scanf(\"%d %d\\n\", &a, &b);\n                a--; b--;\n                auto ans = uf.query(a, b);\n                if (ans == UnionFindW.INF) {\n                    writeln(\"UNKNOWN\");\n                } else {\n                    writeln(ans);\n                }\n            }\n        }\n        return true;\n    }\n    \n    while (solve) {}\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.ascii;\nimport std.range;\nimport std.array;\nimport std.functional;\nimport std.algorithm;\nimport std.conv;\nimport std.container;\nimport std.math;\nimport std.numeric;\nimport std.string;\nimport std.c.string;\nimport std.random;\nimport std.regex;\nimport std.typecons;\n\n/* 重みつきUnionFind木 */\nclass UnionFindW {\n    alias long INT;\n    static const INT INF = long.max / 4;\n    struct Pair {\n        int index;\n        INT value;\n    }\n    int[] parent;\n    INT[] value;\n    this(int N) {\n        parent = new int[N + 1]; parent[] = -1;\n        value = new INT[N + 1];  value[] = 0;\n    }\n    /* \n     * root :: インデックス -> (ルートのインデックス, ルートとの距離)\n     */\n    Pair root(int x) {\n        if (parent[x] == -1) return Pair(x, 0);\n        int p = parent[x];\n        auto v = value[x];\n        auto proot = root(p);\n        parent[x] = proot.index;\n        value[x] = v + proot.value;\n        return Pair(parent[x], value[x]);\n    }\n    /* \n     * query :: (インデックスx, インデックスy) -> yとxの差\n     */\n    INT query(int x, int y) {\n        auto xroot = root(x),\n             yroot = root(y);\n        if (xroot.index != yroot.index) return INF;\n        return yroot.value - xroot.value;\n    }\n    /*\n     * merge :: (インデックスx, インデックスy, yとxの差w) -> ()\n     *\n     * xとyがすでに親子関係を持っていて,その差がwでなければ異常終了\n     */\n    void merge(int x, int y, INT w) {\n        auto xroot = root(x),\n             yroot = root(y);\n        if (xroot.index == yroot.index) {\n            assert(query(x, y) == w);\n            return;\n        }\n        auto px = xroot.index, py = yroot.index;\n        auto dx = xroot.value, dy = yroot.value;\n        /* value[y] - value[x] = w\n         * value[x] - value[px] = dx\n         * value[y] - value[py] = dy\n         * value[py] - value[px] = (value[y] - dy) - (value[x] - dx)\n         *                       = (value[y] - value[x]) - (dy - dx)\n         *                       = w - dy + dx\n         */\n        parent[py] = px;\n        value[py] = w - dy + dx;\n    }\n}\n\nvoid main() {\n    int N, M;\n    UnionFindW uf;\n\n    bool solve() {\n        scanf(\"%d %d\\n\", &N, &M);\n        if (N == 0 && M == 0) return false;\n        uf = new UnionFindW(N);\n        foreach (i; 0 .. M) {\n            string s; readf(\"%s \", &s);\n            int a, b, w;\n            if (i % 1000 == 0) {\n                foreach (int j; 0 .. N) uf.root(j);\n            }\n            if (s == \"!\") {\n                scanf(\"%d %d %d\\n\", &a, &b, &w);\n                a--; b--;\n                uf.merge(a, b, w);\n            } else {\n                scanf(\"%d %d\\n\", &a, &b);\n                a--; b--;\n                auto ans = uf.query(a, b);\n                if (ans == UnionFindW.INF) {\n                    writeln(\"UNKNOWN\");\n                } else {\n                    writeln(ans);\n                }\n            }\n        }\n        return true;\n    }\n    \n    while (solve) {}\n}"
  },
  {
    "language": "Python",
    "code": "import sys\nsys.setrecursionlimit(10**6)\ndef root(x):\n    if x == parent[x]:\n        return x\n    y = root(parent[x])\n    relative[x] += relative[parent[x]]\n    parent[x] = y\n    return y\ndef unite(a, b, w):\n    pa = root(a); pb = root(b)\n    if pa < pb:\n        parent[pb] = pa\n        relative[pb] = relative[a] + w\n    else:\n        parent[pa] = pb\n        relative[pa] = relative[b] - w\nwhile 1:\n    N, M = map(int, input().split())\n    if N == M == 0:\n        break\n    *parent, = range(N+1)\n    relative = [0]*(N+1)\n    for i in range(M):\n        cmd = input().split()\n        if cmd[0] == '!':\n            a, b, w = map(int, cmd[1:])\n            unite(a-1, b-1, w)\n        else:\n            a, b = map(int, cmd[1:])\n            if root(a-1) != root(b-1):\n                print(\"UNKNOWN\")\n            else:\n                print(relative[b-1] - relative[a-1])"
  },
  {
    "language": "Python",
    "code": "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,copy,functools\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\neps = 1.0 / 10**13\nmod = 10**9+7\ndd = [(-1,0),(0,1),(1,0),(0,-1)]\nddn = [(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)]\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef S(): return input()\ndef pf(s): return print(s, flush=True)\n\nclass UnionFind:\n    def __init__(self, size):\n        self.table = [-1 for _ in range(size)]\n\n    def find(self, x):\n        if self.table[x] < 0:\n            return x\n        else:\n            self.table[x] = self.find(self.table[x])\n            return self.table[x]\n\n    def union(self, x, y):\n        s1 = self.find(x)\n        s2 = self.find(y)\n        if s1 != s2:\n            if self.table[s1] <= self.table[s2]:\n                self.table[s1] += self.table[s2]\n                self.table[s2] = s1\n            else:\n                self.table[s2] += self.table[s1]\n                self.table[s1] = s2\n            return True\n        return False\n\n    def subsetall(self):\n        a = []\n        for i in range(len(self.table)):\n            if self.table[i] < 0:\n                a.append((i, -self.table[i]))\n        return a\n\ndef main():\n    random.seed(42)\n    rr = []\n\n    def f(n, m):\n        qa = [LS() for _ in range(m)]\n        d = collections.defaultdict(lambda: collections.defaultdict(int))\n        for i in range(n+1):\n            d[i][i] = random.randrange(1,100)\n        r = []\n        uf = UnionFind(n+1)\n        for q in qa:\n            if q[0] == '!':\n                a,b,w = map(int, q[1:])\n                fa = uf.find(a)\n                fb = uf.find(b)\n                if fa == fb:\n                    continue\n                uf.union(a,b)\n                # print('a,b',a,b)\n                # print('dfa', d[fa])\n                # print('dfb', d[fb])\n                if fa == uf.find(a):\n                    sa = w + (d[fa][a] - d[fb][b])\n                    for k in d[fb].keys():\n                        d[fa][k] = d[fb][k] + sa\n                else:\n                    sa = (d[fa][a] - d[fb][b]) + w\n                    for k in d[fa].keys():\n                        d[fb][k] = d[fa][k] - sa\n                # print('sa',sa)\n                # print('dfa', d[fa])\n                # print('dfb', d[fb])\n            else:\n                a,b = map(int , q[1:])\n                fa = uf.find(a)\n                if fa != uf.find(b):\n                    r.append('UNKNOWN')\n                else:\n                    r.append(d[fa][b] - d[fa][a])\n        # for k in d.keys():\n        #     print('k,d',k,d[k])\n\n        return r\n\n    while 1:\n        n,m = LI()\n        if n == 0 and m == 0:\n            break\n        rr.extend(f(n,m))\n\n    return '\\n'.join(map(str,rr))\n\n\nprint(main())\n\n"
  },
  {
    "language": "Python",
    "code": "class WeightedUnionFind:\n    def __init__(self, n):\n        self.par = [i for i in range(n+1)]\n        self.rank = [0] * (n+1)\n        self.weight = [0] * (n+1)\n\n    # 検索\n    def find(self, x):\n        if self.par[x] == x:\n            return x\n        else:\n            y = self.find(self.par[x])\n            self.weight[x] += self.weight[self.par[x]]\n            self.par[x] = y\n            return y\n\n    # 重さの検索\n    def weighting(self, x):\n        self.find(x)\n        return self.weight[x]\n\n    # 併合\n    def union(self, x, y, w):\n        px = self.find(x)\n        py = self.find(y)\n        if px != py:\n            if self.rank[px] < self.rank[py]:\n                self.par[px] = py\n                self.weight[px] = w - self.weight[x] + self.weight[y]\n            else:\n                self.par[py] = px\n                self.weight[py] = -w - self.weight[y] + self.weight[x]\n                if self.rank[px] == self.rank[py]:\n                    self.rank[px] += 1\n\n    # 同じ集合に属するか\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    # 各頂点間の絶対距離\n    def diff(self, x, y):\n        return self.weight[x] - self.weight[y]\n\nN, M = 1, 1\n\nwhile True:\n    N, M = map(int, input().split())\n    if (N == 0) & (M == 0):\n        quit()\n    info = [list(input().split()) for i in range(M)]\n    wuf = WeightedUnionFind(N)\n    for i in range(M):\n        if info[i][0] == \"!\":\n            wuf.union(int(info[i][1]), int(info[i][2]), int(info[i][3]))\n            #print(\"parent:\", wuf.par)\n            #print(\"weight:\", wuf.weight)\n            #print(\"rank:\", wuf.rank, \"\\n\")\n        else:\n            if wuf.same(int(info[i][1]), int(info[i][2])):\n                print(wuf.diff(int(info[i][1]), int(info[i][2])))\n                #print(\"parent:\", wuf.par)\n                #print(\"weight:\", wuf.weight)\n                #print(\"rank:\", wuf.rank, \"\\n\")\n            else:\n                print(\"UNKNOWN\")\n                #print(\"parent:\", wuf.par)\n                #print(\"weight:\", wuf.weight)\n                #print(\"rank:\", wuf.rank, \"\\n\")\n\n\n\n"
  },
  {
    "language": "Python",
    "code": "import sys\nsys.setrecursionlimit(10**6)\ndef root(x):\n    if x == parent[x]:\n        return x\n    y = root(parent[x])\n    relative[x] += relative[parent[x]]\n    parent[x] = y\n    return y\ndef unite(a, b, w):\n    pa = root(a); pb = root(b)\n    pw = relative[a] + w - relative[b]\n    if pa < pb:\n        parent[pb] = pa\n        relative[pb] = pw\n    else:\n        parent[pa] = pb\n        relative[pa] = -pw\nwhile 1:\n    N, M = map(int, input().split())\n    if N == M == 0:\n        break\n    *parent, = range(N)\n    relative = [0]*N\n    for i in range(M):\n        cmd = input().split()\n        if cmd[0] == '!':\n            a, b, w = map(int, cmd[1:])\n            unite(a-1, b-1, w)\n        else:\n            a, b = map(int, cmd[1:])\n            if root(a-1) != root(b-1):\n                print(\"UNKNOWN\")\n            else:\n                print(relative[b-1] - relative[a-1])"
  },
  {
    "language": "Python",
    "code": "# Author: cr4zjh0bp\n# Created: Fri Mar 20 22:48:43 UTC 2020\nimport sys\n \nstdin = sys.stdin\ninf = 1 << 60\nmod = 1000000007\n \nni      = lambda: int(ns())\nnin     = lambda y: [ni() for _ in range(y)]\nna      = lambda: list(map(int, stdin.readline().split()))\nnan     = lambda y: [na() for _ in range(y)]\nnf      = lambda: float(ns())\nnfn     = lambda y: [nf() for _ in range(y)]\nnfa     = lambda: list(map(float, stdin.readline().split()))\nnfan    = lambda y: [nfa() for _ in range(y)]\nns      = lambda: stdin.readline().rstrip()\nnsn     = lambda y: [ns() for _ in range(y)]\nncl     = lambda y: [list(ns()) for _ in range(y)]\nnas     = lambda: stdin.readline().split()\n\nclass WUnionFind:\n    def __init__(self, n, sum_unity=0):\n        self.n = n\n        self.par = [i for i in range(n)]\n        self.rank = [0 for _ in range(n)]\n        self.diff_weight = [sum_unity for _ in range(n)]\n        self._size = [1 for _ in range(n)]\n        self._edges = 0\n\n    def find(self, x):\n        if self.par[x] == x:\n            return x\n        else:\n            r = self.find(self.par[x])\n            self.diff_weight[x] += self.diff_weight[self.par[x]]\n            self.par[x] = r\n            return r\n        \n    def unite(self, x, y, w):\n        w += self.weight(x)\n        w -= self.weight(y)\n        x = self.find(x)\n        y = self.find(y)\n        if x == y:\n            return\n        if self.rank[x] < self.rank[y]:\n            self.par[x] = y\n            self.diff_weight[x] = -w\n            self._size[y] += self._size[x]\n            self._edges += 1\n        else:\n            self.par[y] = x\n            self.diff_weight[y] = w\n            if self.rank[x] == self.rank[y]:\n                self.rank[x] += 1\n            self._size[x] += self._size[y]\n            self._edges += 1\n\n    def weight(self, x):\n        self.find(x)\n        return self.diff_weight[x]\n\n    def diff(self, x, y):\n        return self.weight(y) - self.weight(x)\n    \n    def size(self, x):\n        x = self.find(x)\n        return self._size[x]\n    \n    def trees(self):\n        return self.n - self._edges\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\nwhile True:\n    n, m = na()\n    if n == 0 and m == 0:\n        break\n    wuf = WUnionFind(n)\n    for i in range(m):\n        que = nas()\n        if que[0] == '!':\n            a, b, w = list(map(int, que[1:]))\n            a -= 1\n            b -= 1\n            wuf.unite(a, b, w)\n        elif que[0] == '?':\n            a, b = list(map(int, que[1:]))\n            a -= 1\n            b -= 1\n            if wuf.same(a, b):\n                print(wuf.diff(a, b))\n            else:\n                print(\"UNKNOWN\")\n"
  },
  {
    "language": "Python",
    "code": "def solve():\n    def measurement(a, b, w):\n        a_root = root[a]\n        b_root = root[b]\n        if a_root != b_root:\n            a_member = member[a_root]\n            b_member = member[b_root]\n            offset = w - (weight[b] - weight[a])\n            if len(a_member) > len(b_member):\n                a_member.extend(b_member)\n                for n in b_member:\n                    root[n] = a_root\n                    weight[n] += offset\n            else:\n                b_member.extend(a_member)\n                for n in a_member:\n                    root[n] = b_root\n                    weight[n] -= offset\n    \n    def inquiry(a, b):\n        if root[a] == root[b]:\n            return weight[b] - weight[a]\n        else:\n            return 'UNKNOWN'\n                    \n    import sys\n    file_input = sys.stdin\n    \n    while True:\n        N, M = map(int, file_input.readline().split())\n        if N == 0:\n            break\n        \n        root = [i for i in range(N + 1)]\n        member = [[i] for i in range(N + 1)]\n        weight = [0] * (N + 1)\n        \n        for _ in range(M):\n            line = file_input.readline()\n            if line[0] == '!':\n                a, b, w = map(int, line[2:].split())\n                measurement(a, b, w)\n            else:\n                a, b= map(int, line[2:].split())\n                print(inquiry(a, b))\n\nsolve()\n"
  },
  {
    "language": "Python",
    "code": "def solve():\n    def measurement(a, b, w):\n        a_root = root[a]\n        b_root = root[b]\n        if a_root != b_root:\n            a_member = member[a_root]\n            b_member = member[b_root]\n            offset = w - (weight[b] - weight[a])\n            if len(a_member) > len(b_member):\n                a_member.extend(b_member)\n                for n in b_member:\n                    root[n] = a_root\n                    weight[n] += offset\n            else:\n                b_member.extend(a_member)\n                for n in a_member:\n                    root[n] = b_root\n                    weight[n] -= offset\n    \n    def inquiry(a, b):\n        if root[a] == root[b]:\n            return weight[b] - weight[a]\n        else:\n            return 'UNKNOWN'\n    \n    def operation(line):\n        if line[0] == '!':\n            a, b, w = map(int, line[2:].split())\n            measurement(a, b, w)\n        else:\n            a, b = map(int, line[2:].split())\n            return inquiry(a, b)\n    \n    import sys\n    file_input = sys.stdin.readlines()\n    \n    while True:\n        N, M = map(int, file_input[0].split())\n        if N == 0:\n            break\n        \n        root = [i for i in range(N + 1)]\n        member = [[i] for i in range(N + 1)]\n        weight = [0] * (N + 1)\n        \n        ans = (operation(line) for line in file_input[1:M+1])\n        ans = filter(lambda x: x != None, ans)\n        print(*ans, sep='\\n')\n        \n        del file_input[:M+1]\n\nsolve()\n"
  },
  {
    "language": "Python",
    "code": "class WeightedUnionFind:\n    def __init__(self, n):\n        self.par = [i for i in range(n+1)]\n        self.rank = [0] * (n+1)\n        self.weight = [0] * (n+1)\n\n    # 検索\n    def find(self, x):\n        if self.par[x] == x:\n            return x\n        else:\n            y = self.find(self.par[x])\n            self.weight[x] += self.weight[self.par[x]]\n            self.par[x] = y\n            return y\n\n    # 重さの検索\n    def weighting(self, x):\n        self.find(x)\n        return self.weight[x]\n\n    # 併合\n    def union(self, x, y, w):\n        px = self.find(x)\n        py = self.find(y)\n        if px != py:\n            if self.rank[px] < self.rank[py]:\n                self.par[px] = py\n                self.weight[px] = w - self.weighting(x) + self.weighting(y)\n            else:\n                self.par[py] = px\n                self.weight[py] = -w - self.weighting(y) + self.weighting(x)\n                if self.rank[px] == self.rank[py]:\n                    self.rank[px] += 1\n\n    # 同じ集合に属するか\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    # 各頂点間の絶対距離\n    def diff(self, x, y):\n        return self.weighting(x) - self.weighting(y)\n\nN, M = 1, 1\n\nwhile True:\n    N, M = map(int, input().split())\n    if (N == 0) & (M == 0):\n        quit()\n    info = [list(input().split()) for i in range(M)]\n    wuf = WeightedUnionFind(N)\n    for i in range(M):\n        if info[i][0] == \"!\":\n            wuf.union(int(info[i][1]), int(info[i][2]), int(info[i][3]))\n            #print(\"parent:\", wuf.par)\n            #print(\"weight:\", wuf.weight)\n            #print(\"rank:\", wuf.rank, \"\\n\")\n        else:\n            if wuf.same(int(info[i][1]), int(info[i][2])):\n                print(wuf.diff(int(info[i][1]), int(info[i][2])))\n                #print(\"parent:\", wuf.par)\n                #print(\"weight:\", wuf.weight)\n                #print(\"rank:\", wuf.rank, \"\\n\")\n            else:\n                print(\"UNKNOWN\")\n                #print(\"parent:\", wuf.par)\n                #print(\"weight:\", wuf.weight)\n                #print(\"rank:\", wuf.rank, \"\\n\")\n\n\n\n"
  },
  {
    "language": "Python",
    "code": "\nimport sys\nsys.setrecursionlimit(10000000)\nMOD = 10 ** 9 + 7\nINF = 10 ** 15\n\nclass WeightedUnionFind():\n\n    def __init__(self,N):\n        self.N = N\n        self.parents = [-1] * self.N\n        self.diff_weight = [0] * self.N\n    \n    def find(self,x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            p = self.find(self.parents[x])\n            self.diff_weight[x] += self.diff_weight[self.parents[x]]\n            self.parents[x] = p\n            return p\n    \n    def weight(self,x):#xの親からの重みを返す\n        self.find(x)\n        return self.diff_weight[x]\n    \n    def diff(self,x,y):#同じグループにいたらxとyの重みの差を返す\n        if self.find(x) == self.find(y):\n            return self.weight(y) - self.weight(x)\n        else:\n            return 10000000000\n\n    def unite(self,x,y,w):#wieght(y) = weight(x) + dとなるように合体\n        w += self.weight(x)\n        w -= self.weight(y)\n\n        x = self.find(x)\n        y = self.find(y)\n        if x == y:\n            if self.diff(x,y) == w:\n                return True\n            else:\n                return False\n\n        if self.parents[x] > self.parents[y]:\n            x,y = y,x\n            w *= -1\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n        self.diff_weight[y] = w\n        return True\n    \n    def same(self,x,y):\n        return self.find(x) == self.find(y)\n        \n    def size(self,x):\n        return -self.parents[self.find(x)]\n\ndef solve(N,M):\n    uf = WeightedUnionFind(N)\n    for _ in range(M):\n        q = input().split()\n        if q[0] == '!':\n            a,b,w = map(int,q[1:])\n            a -= 1\n            b -= 1\n            uf.unite(a,b,w)\n        else:\n            a,b = map(int,q[1:])\n            a -= 1\n            b -= 1\n            ans = uf.diff(a,b)\n            if ans == 10000000000:\n                print('UNKNOWN')\n            else:\n                print(ans)\n\ndef main():\n    while True:\n        N,M = map(int,input().split())\n        if N == 0 and M == 0:\n            break\n        solve(N,M)\nif __name__ == '__main__':\n    main()\n"
  },
  {
    "language": "Python",
    "code": "class WeightedUnionFind:\n    def __init__(self, n):\n        self.par = [i for i in range(n+1)]\n        self.rank = [0] * (n + 1)\n        self.weight = [0] * (n+1)\n\n    # 検索\n    def find(self, x):\n        if self.par[x] == x:\n            return x\n        else:\n            self.weight[x] += self.weight[self.par[x]]\n            self.par[x] = self.find(self.par[x])\n            return self.par[x]\n\n    # 重さの検索\n    def weighting(self, x):\n        self.find(x)\n        return self.weight[x]\n\n    # 併合\n    def union(self, x, y, w):\n        w -= self.weighting(x)\n        w += self.weighting(y)\n        x = self.find(x)\n        y = self.find(y)\n\n        if self.rank[x] < self.rank[y]:\n            self.weight[y] = w\n            self.par[y] = w\n        else:\n            self.weight[y] = -w\n            self.par[y] = x\n            if self.rank[x] == self.rank[y]:\n                self.rank[x] += 1\n\n    # 同じ集合に属するか\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    # 各頂点間の絶対距離\n    def diff(self, x, y):\n        return self.weighting(x) - self.weighting(y)\n\n    \nN, M = 1, 1\n\nwhile True:\n    N, M = map(int, input().split())\n    if (N == 0) & (M == 0):\n        quit()\n    info = [list(input().split()) for i in range(M)]\n    wuf = WeightedUnionFind(N)\n    for i in range(M):\n        if info[i][0] == \"!\":\n            wuf.union(int(info[i][1]), int(info[i][2]), int(info[i][3]))\n        else:\n            if wuf.same(int(info[i][1]), int(info[i][2])):\n                print(wuf.diff(int(info[i][1]), int(info[i][2])))\n            else:\n                print(\"UNKNOWN\")\n\n\n\n"
  },
  {
    "language": "Python",
    "code": "def solve():\n    def measurement(a, b, w):\n        a_root = root[a]\n        b_root = root[b]\n        if a_root != b_root:\n            a_member = member[a_root]\n            b_member = member[b_root]\n            offset = w - (weight[b] - weight[a])\n            if len(a_member) > len(b_member):\n                a_member.extend(b_member)\n                for n in b_member:\n                    root[n] = a_root\n                    weight[n] += offset\n            else:\n                b_member.extend(a_member)\n                for n in a_member:\n                    root[n] = b_root\n                    weight[n] -= offset\n     \n    def inquiry(a, b):\n        if root[a] == root[b]:\n            return weight[b] - weight[a]\n        else:\n            return 'UNKNOWN'\n                     \n    import sys\n    file_input = sys.stdin.readlines()\n    ans = []\n     \n    while True:\n        N, M = map(int, file_input[0].split())\n        if N == 0:\n            break\n         \n        root = [i for i in range(N + 1)]\n        member = [[i] for i in range(N + 1)]\n        weight = [0] * (N + 1)\n         \n        for line in file_input[1:M+1]:\n            if line[0] == '!':\n                a, b, w = map(int, line[2:].split())\n                measurement(a, b, w)\n            else:\n                a, b= map(int, line[2:].split())\n                ans.append(inquiry(a, b))\n         \n        del file_input[:M+1]\n    \n    print(*ans, sep='\\n')\n \nsolve()\n"
  },
  {
    "language": "Python",
    "code": "def solve():\n    def measurement(a, b, w):\n        a_root = root[a]\n        b_root = root[b]\n        if a_root != b_root:\n            a_member = member[a]\n            b_member = member[b]\n            offset = w - (weight[b] - weight[a])\n            if len(a_member) > len(b_member):\n                a_member.extend(b_member)\n                for n in b_member:\n                    root[n] = a_root\n                    weight[n] += offset\n            else:\n                b_member.extend(a_member)\n                for n in a_member:\n                    root[n] = b_root\n                    weight[n] -= offset\n    \n    def inquiry(a, b):\n        if root[a] == root[b]:\n            return weight[b] - weight[a]\n        else:\n            return 'UNKNOWN'\n                    \n    import sys\n    file_input = sys.stdin\n    \n    while True:\n        N, M = map(int, file_input.readline().split())\n        if N == 0:\n            break\n        \n        root = [i for i in range(N + 1)]\n        member = [[i] for i in range(N + 1)]\n        weight = [0] * (N + 1)\n        \n        for _ in range(M):\n            line = file_input.readline()\n            if line[0] == '!':\n                a, b, w = map(int, line[2:].split())\n                measurement(a, b, w)\n            else:\n                a, b= map(int, line[2:].split())\n                print(inquiry(a, b))\n\nsolve()\n"
  },
  {
    "language": "Python",
    "code": "class WeightedUnionFind(object):\n    __slots__ = [\"nodes\", \"weight\"]\n\n    def __init__(self, n: int) -> None:\n        self.nodes = [-1]*n\n        self.weight = [0]*n\n\n    def get_root(self, x: int) -> int:\n        if x < 0:\n            raise ValueError(\"Negative Index\")\n\n        if self.nodes[x] < 0:\n            return x\n        else:\n            root = self.get_root(self.nodes[x])\n            self.weight[x] += self.weight[self.nodes[x]]\n            self.nodes[x] = root\n            return root\n\n    def relate(self, smaller: int, bigger: int, diff_weight: int) -> None:\n        if smaller < 0 or bigger < 0:\n            raise ValueError(\"Negative Index\")\n\n        root_a, root_b = self.get_root(smaller), self.get_root(bigger)\n        new_weight = diff_weight + self.weight[smaller] - self.weight[bigger]\n\n        if root_a == root_b:\n            # 問題によっては必要かも（情報に矛盾があるなら-1を出力など）\n            if self.weight[smaller] + diff_weight == self.weight[bigger]:\n                return\n            raise ValueError(\"relateに矛盾あり\")\n\n        if self.nodes[root_a] > self.nodes[root_b]:\n            root_a, root_b, new_weight = root_b, root_a, -new_weight\n\n        self.nodes[root_a] += self.nodes[root_b]\n        self.nodes[root_b] = root_a\n        self.weight[root_b] = new_weight\n\n    def diff(self, x: int, y: int) -> int:\n        root_x, root_y = self.get_root(x), self.get_root(y)\n        if root_x != root_y:\n            return None\n        return self.weight[y] - self.weight[x]\n\n\nimport sys\nwhile True:\n    N, M = map(int, input().split())\n    if N == 0:\n        break\n    uf = WeightedUnionFind(N+1)\n    for qtype, a, b, *c in (sys.stdin.readline().split() for _ in [0]*M):\n        if qtype == \"!\":\n            uf.relate(int(a), int(b), int(c[0]))\n        else:\n            diff = uf.diff(int(a), int(b))\n            print(diff if diff is not None else \"UNKNOWN\")\n"
  },
  {
    "language": "Python",
    "code": "def root(x):\n    if x == parent[x]:\n        return x\n    y = root(parent[x])\n    relative[x] += relative[parent[x]]\n    parent[x] = y\n    return y\ndef unite(a, b, w):\n    pa = root(a); pb = root(b)\n    if pa < pb:\n        parent[pb] = pa\n        relative[pb] = relative[a] + w\n    else:\n        parent[pa] = pb\n        relative[pa] = relative[b] - w\nwhile 1:\n    N, M = map(int, input().split())\n    if N == M == 0:\n        break\n    *parent, = range(N+1)\n    relative = [0]*(N+1)\n    for i in range(M):\n        cmd = input().split()\n        if cmd[0] == '!':\n            a, b, w = map(int, cmd[1:])\n            unite(a-1, b-1, w)\n        else:\n            a, b = map(int, cmd[1:])\n            if root(a-1) != root(b-1):\n                print(\"UNKNOWN\")\n            else:\n                print(relative[b-1] - relative[a-1])"
  },
  {
    "language": "Python",
    "code": "def solve():\n    def measurement(a, b, w):\n        a_root = root[a]\n        b_root = root[b]\n        if a_root != b_root:\n            a_member = member[a_root]\n            b_member = member[b_root]\n            offset = w - (weight[b] - weight[a])\n            if len(a_member) > len(b_member):\n                a_member.extend(b_member)\n                for n in b_member:\n                    root[n] = a_root\n                    weight[n] += offset\n            else:\n                b_member.extend(a_member)\n                for n in a_member:\n                    root[n] = b_root\n                    weight[n] -= offset\n    \n    def inquiry(a, b):\n        if root[a] == root[b]:\n            return weight[b] - weight[a]\n        else:\n            return 'UNKNOWN'\n                    \n    import sys\n    file_input = sys.stdin.readlines()\n    \n    while True:\n        N, M = map(int, file_input[0].split())\n        if N == 0:\n            break\n        \n        root = [i for i in range(N + 1)]\n        member = [[i] for i in range(N + 1)]\n        weight = [0] * (N + 1)\n        \n        for line in file_input[1:M+1]:\n            if line[0] == '!':\n                a, b, w = map(int, line[2:].split())\n                measurement(a, b, w)\n            else:\n                a, b= map(int, line[2:].split())\n                print(inquiry(a, b))\n        \n        del file_input[:M+1]\n\nsolve()\n"
  },
  {
    "language": "Python",
    "code": "class Value_UnionFind():\n\n    def __init__(self,n):\n        self.par = [i for i in range(n)]\n        self.differ_weight = [0] * n\n        self.rank = [0] * n\n\n    def root(self,x):\n        if x == self.par[x]:\n            return x\n        r = self.root(self.par[x])\n        self.differ_weight[x] += self.differ_weight[self.par[x]]\n        self.par[x] = r\n        return r\n\n    def weight(self, x):\n        self.root(x)\n        return self.differ_weight[x]\n\n    def unit(self, x, y, w):\n        w += self.weight(x)\n        w -= self.weight(y)\n        x = self.root(x)\n        y = self.root(y)\n        if x == y: return False\n        if self.rank[x] < self.rank[y]: x, y, w = y, x, -w\n        if self.rank[x] == self.rank[y]: self.rank[x] += 1\n        self.par[y] = x\n        self.differ_weight[y] = w\n        return True\n\n    def differ(self, x, y):\n        return self.weight(y) - self.weight(x)\n\ndef main(n, m):\n    Union = Value_UnionFind(n)\n    for _ in range(m):\n        x = list(map(str, input().split()))\n        q = x[0]\n        if q == \"!\":\n            a, b, w = map(int, x[1:])\n            Union.unit(a-1, b-1, w)\n        if q == \"?\":\n            a, b = map(int,x[1:])\n            if Union.root(a-1) != Union.root(b-1):\n                print(\"UNKNOWN\")\n            else:\n                print(Union.differ(a-1, b-1))\n\n\n\nwhile 1:\n    n, m = map(int, input().split())\n    if n == m == 0:\n        break\n    main(n,m)\n"
  },
  {
    "language": "Python",
    "code": "class PotUnionFind:\n    def __init__(self, n):\n        self.parent = list(range(n)) #親ノード\n        self.size = [1]*n #グループの要素数\n        self.diff_p = [0]*n #親ノードを基準としたポテンシャル\n \n    def root(self, x): #root(x): xの根ノードを返す．\n        while self.parent[x] != x:\n            self.diff_p[x] += self.diff_p[self.parent[x]]\n            self.parent[x] = self.parent[self.parent[x]]\n            x = self.parent[x]\n        return x \n\n    def weight(self, x): #root(x): xの根ノードを返す．\n        c=0\n        while self.parent[x] != x:\n            self.diff_p[x] += self.diff_p[self.parent[x]]\n            self.parent[x] = self.parent[self.parent[x]]\n            c += self.diff_p[x]\n            x = self.parent[x]\n        return c\n\n\n    def merge(self, x, y, dxy): #ポテンシャル差p(y)-p(x)=dxyでxとyの組をまとめる\n        dxy += self.weight(x) - self.weight(y) #dxyをで置き換え\n        x,y = self.root(x), self.root(y)\n        if x == y: return False\n        if self.size[x] < self.size[y]: #xの要素数が大きいように\n            x,y,dxy = y,x,-dxy\n        self.size[x] += self.size[y] #xの要素数を更新\n        self.parent[y] = x #yをxにつなぐ\n        self.diff_p[y] = dxy #yの相対ポテンシャルを更新\n        return True\n \n    def issame(self, x, y): #xとyが同じ組ならTrue\n        return self.root(x) == self.root(y)\n        \n    def diff(self,x,y): #xを基準としたyのポテンシャルを返す \n        if self.root(x) == self.root(y):\n            return self.weight(y) - self.weight(x)\n        else:\n            return None\n\n    def getsize(self,x): #xのいるグループの要素数を返す\n        return self.size[self.root(x)]\n\n\nimport sys\nwhile True:\n    n,Q=[int(i) for i in input().split()]\n    if n==0 and Q ==0: exit()\n    T=PotUnionFind(n)\n    for _ in [0]*(Q):\n        u = [i for i in sys.stdin.readline().split()]\n        if u[0] ==\"!\":\n            u1, u2, u3 = int(u[1])-1, int(u[2])-1, int(u[3])\n            T.merge(u1,u2,u3)\n        else:\n            u1, u2 = int(u[1])-1, int(u[2])-1\n            if T.issame(u1,u2):\n                print(T.diff(u1,u2))\n            else:\n                print(\"UNKNOWN\")\n                \n                \n                \n"
  },
  {
    "language": "Python",
    "code": "class WeightedUnionFind:\n    def __init__(self, n):\n        self.par = [i for i in range(n+1)]\n        self.rank = [0] * (n + 1)\n        self.weight = [0] * (n+1)\n\n    # 検索\n    def find(self, x):\n        if self.par[x] == x:\n            return x\n        else:\n            self.weight[x] += self.weight[self.par[x]]\n            self.par[x] = self.find(self.par[x])\n            return self.par[x]\n\n    # 重さの検索\n    def weighting(self, x):\n        self.find(x)\n        return self.weight[x]\n\n    # 併合\n    def union(self, x, y, w):\n        w -= self.weighting(x)\n        w += self.weighting(y)\n        x = self.find(x)\n        y = self.find(y)\n\n        if self.rank[x] < self.rank[y]:\n            self.weight[x] = w\n            self.par[x] = y\n\n        else:\n            w = -w\n            self.weight[y] = w\n            self.par[y] = x\n            if self.rank[x] == self.rank[y]:\n                self.rank[x] += 1\n\n    # 同じ集合に属するか\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    # 各頂点間の絶対距離\n    def diff(self, x, y):\n        return self.weighting(x) - self.weighting(y)\n\n\nN, M = 1, 1\n\nwhile True:\n    N, M = map(int, input().split())\n    if (N == 0) & (M == 0):\n        quit()\n    info = [list(input().split()) for i in range(M)]\n    wuf = WeightedUnionFind(N)\n    for i in range(M):\n        if info[i][0] == \"!\":\n            wuf.union(int(info[i][1]), int(info[i][2]), int(info[i][3]))\n        else:\n            if wuf.same(int(info[i][1]), int(info[i][2])):\n                print(wuf.diff(int(info[i][1]), int(info[i][2])))\n            else:\n                print(\"UNKNOWN\")\n\n\n\n"
  },
  {
    "language": "Python",
    "code": "import sys\nsys.setrecursionlimit(10 ** 5)\n\n# 連結性の確認\nclass UnionFind():\n    def __init__(self, n):\n        self.parents = list(range(n))\n        self.weight = [0] * n\n        self.rank = [0] * n\n\n    def find(self, a):\n        if self.parents[a] == a:\n            return a\n        p = self.find(self.parents[a])\n        self.weight[a] += self.weight[self.parents[a]]\n        self.parents[a] = p\n        return p\n\n    def union(self, a, b, w):\n        self.find(a), self.find(b)\n        w += self.weight[a]\n        w -= self.weight[b]\n        a = self.find(a)\n        b = self.find(b)\n\n        if a == b: return\n\n        if self.rank[a] < self.rank[b]:\n            self.parents[a] = b\n            self.weight[a] = -w\n        else:\n            self.parents[b] = a\n            self.weight[b] = w\n            if self.rank[a] == self.rank[b]:\n                self.rank[a] += 1\n\n    def weight_check(self, a, b):\n        self.find(a), self.find(b)\n        return - self.weight[a] + self.weight[b]\n\nwhile True:\n    N, M = map(int, input().split())\n    if not(N | M):\n        break\n\n    uf = UnionFind(N)\n    for i in range(M):\n        input_str = input().split()\n        if input_str[0] == '!':\n            a, b, w = map(int, input_str[1:])\n            uf.union(a - 1, b - 1, w)\n\n        else:\n            a, b = map(lambda x: int(x) - 1, input_str[1:])\n            if uf.find(a) != uf.find(b):\n                print('UNKNOWN')\n                continue\n            print(uf.weight_check(a, b))\n\n"
  }
]