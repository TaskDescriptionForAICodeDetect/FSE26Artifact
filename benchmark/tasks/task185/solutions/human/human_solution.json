[
  {
    "language": "Scala",
    "code": "import scala.annotation.tailrec\nimport scala.collection.mutable\nimport scala.io.StdIn._\nobject Main extends App{\n  solve()\n  @tailrec def solve(): Unit = {\n    val n = readInt()\n    if (n == 0) {\n      return\n    }\n    val Array(h, w) = readLine.trim.split(' ').map(_.toInt)\n    val pages = List.tabulate(n){_ ⇒\n      val Array(title, b) = readLine.trim.split(' ')\n      val buttons = List.tabulate(b.toInt){_ ⇒\n        val Array(left, up, right, botton, label) = readLine.trim.split(' ')\n        Button(label, left.toInt, up.toInt, right.toInt, botton.toInt)\n      }\n      title → new Page(title, buttons)\n    }\n    var browser = new Browser(pages.toMap, pages.head._2)\n    val click = \"\"\"click (\\d+) (\\d+)\"\"\".r\n    for (_ ← 0 until readInt) {\n      readLine.trim match {\n        case \"back\" ⇒ browser = browser.back\n        case \"forward\" ⇒ browser = browser.forward\n        case \"show\" ⇒ println(browser.show)\n        case click(x, y) ⇒ browser = browser.click(Point(x.toInt, y.toInt))\n        case _ ⇒ ???\n      }\n    }\n    solve()\n  }\n  class Browser(private val pages: String ⇒ Page, private val history: History) {\n    def this(pages: String ⇒ Page, top: Page){\n      this(pages, new History(top))\n    }\n    def click(point: Point): Browser = {\n      history.current.click(point) match {\n        case None ⇒ this\n        case Some(next) ⇒ new Browser(pages, history.move(pages(next)))\n      }\n    }\n    def back: Browser = new Browser(pages, history.movePrev)\n    def forward: Browser = new Browser(pages, history.moveNext)\n    def show: String = history.current.title\n  }\n  case class Point(x: Int, y: Int)\n  case class Button(label: String, left: Int, up: Int, right: Int, bottom: Int) {\n    def isPushed(point: Point): Boolean = (left to right).contains(point.x) && (up to bottom).contains(point.y)\n  }\n  class Page(val title: String, val button: List[Button]) {\n    def click(point: Point): Option[String] = {\n      button.find(_.isPushed(point)).map(_.label)\n    }\n  }\n  case class History(prev: List[Page], current: Page, next: List[Page]) {\n    def this(current: Page) {\n      this(Nil, current, Nil)\n    }\n    def movePrev: History = {\n      prev match {\n        case Nil ⇒ this\n        case h::t ⇒ History(t, h, current::next)\n      }\n    }\n    def moveNext: History = {\n      next match {\n        case Nil ⇒ this\n        case h::t ⇒ History(current::prev, h, t)\n      }\n    }\n    def move(page: Page): History = History(current::prev, page, Nil)\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<algorithm>\n#include<iostream>\n#include<vector>\n#include<climits>\n#include<cfloat>\n\nusing namespace std;\n\nstruct point{\n  double x, y;\n};\n\nstruct button{\n  point ld,ru;\n  string name;\n};\n\nstruct page{\n  string name;\n  vector<button>btn;   \n}; \n\nint m,now,fg;\nvector<page> a;\nstatic page buf[1000000];\n\nvoid click(int c,int d){\n  \n  for(int i=0;i<buf[now].btn.size();i++)\n    if(buf[now].btn[i].ld.x <=c && buf[now].btn[i].ld.y <=d &&\n       buf[now].btn[i].ru.x >=c && buf[now].btn[i].ru.y >=d)\n      for(int j=0;j<a.size();j++)\n\tif(buf[now].btn[i].name==a[j].name){\n\t  buf[++now]=a[j];\n\t  fg=0;\n\t  return ;\n\t}\n}\n\nint main(void){\n  int n;\n  int w,h,b;\n  point l,r;\n  page in;\n  button tmp;\n\n  while(cin >> n,n){\n  \n    a.clear();\n\n    cin >> w >> h;\n    \n    for(int j=0;j<n;j++){\n      cin >> in.name >> b;    \n      \n      for(int i=0;i<b;i++){\n\tcin >> tmp.ld.x >> tmp.ld.y >> tmp.ru.x >> tmp.ru.y >> tmp.name;\n\tin.btn.push_back(tmp);\n      }\n      a.push_back(in);\n    }\n\n    now=0,fg=0;\n    buf[0]=a[0];\n\n    cin >> m;\n\n    while(m--){\n      string s;\n      cin >> s;\n      if(s==\"click\"){\n\tint c,d;\n\tcin >> c >> d;\n\tclick(c,d);\n      }\n      else if(s==\"back\" && now>0){\n\tnow--;\n\tfg++;\n      }\n      else if(s==\"forward\" && fg>0 && now < 1000000)now++,fg--;\n      else if(s==\"show\")cout << buf[now].name << endl;\n    }\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <complex>\n#include <cstdio>\n#include <map>\n#include <math.h>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<n;i++)\n\nint n,W,H,a[100001],c,po,m;\nstruct page{\n\tint b,x1[100],y1[100],x2[100],y2[100];\n\tstring name,link[100];\n};\n\nint main(){\n\twhile(cin>>n&&n){\n\t\tfill(a,a+100001,-1);\n\t\ta[0]=0;c=0;po=0;\n\t\tcin>>W>>H;\n\t\tpage p[100];\n\t\trep(i,n){\n\t\t\tcin>>p[i].name>>p[i].b;\n\t\t\trep(j,p[i].b)cin>>p[i].x1[j]>>p[i].y1[j]>>p[i].x2[j]>>p[i].y2[j]>>p[i].link[j];\n\t\t}\n\t\tcin>>m;\n\t\trep(i,m){\n\t\t\tstring s;\n\t\t\tcin>>s;\n\t\t\tif(s==\"click\"){\n\t\t\t\tint x,y;\n\t\t\t\tcin>>x>>y;\n\t\t\t\trep(j,p[c].b)if(p[c].x1[j]<=x&&x<=p[c].x2[j]&&p[c].y1[j]<=y&&y<=p[c].y2[j]){\n\t\t\t\t\tstring st=p[c].link[j];\n\t\t\t\t\trep(k,n)if(st==p[k].name)c=a[++po]=k;\n\t\t\t\t\tfill(a+po+1,a+100001,-1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(s==\"back\"&&po)c=a[--po];\n\t\t\tif(s==\"forward\"&&a[po+1]!=-1)c=a[++po];\n\t\t\tif(s==\"show\")cout<<p[c].name<<endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "// AOJ1054 Distorted Love\n\n#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n\nusing namespace std;\n\nclass button{\npublic:\n\tint x1, y1, x2, y2; string name;\n\tbutton(int x1, int y1, int x2, int y2, string name) : x1(x1), y1(y1), x2(x2), y2(y2), name(name) {}\n\tbool in(int x, int y) { return x1 <= x && x <= x2 && y1 <= y && y <= y2; }\n};\n\nint main(){\n\tint n; cin >> n;\n\tint x, y; cin >> x >> y;\n\tint buf[100]; buf[0] = 0; \n\tint size = 0;\n\tint cur = 0;\n\tstring s;\n\tvector<string> vs;\n\tmap<string, int> mp;\n\tvector< vector<button> > vv(n);\n\tfor(int i=0;i<n;i++){\n\t\tcin >> s;\n\t\tvs.push_back(s);\n\t\tmp[s] = i;\n\t\tint t; cin >> t;\n\t\tfor(int j=0;j<t;j++){\n\t\t\tint x1, y1, x2, y2; cin >> x1 >> y1 >> x2 >> y2 >> s;\n\t\t\tvv[i].push_back(button(x1, y1, x2, y2, s));\n\t\t}\n\t}\n\tcin >> n;\n\tfor(int i=0;i<n;i++){\n\t\tcin >> s;\n\t\tif(s==\"show\") cout << vs[cur] << endl;\n\t\tif(s==\"forward\"){\n\t\t\tif(cur != size) cur++;\n\t\t}\n\t\tif(s==\"back\"){\n\t\t\tif(cur != 0) cur--;\n\t\t}\n\t\tif(s==\"click\"){\n\t\t\tint x, y; cin >> x >> y;\n\t\t\tfor(int j=0;j<vv[buf[cur]].size();j++){\n\t\t\t\tif(vv[buf[cur]][j].in(x,y)){\n\t\t\t\t\tcur++;\n\t\t\t\t\tsize = cur;\n\t\t\t\t\tbuf[cur] = mp[vv[buf[cur-1]][j].name];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <deque>\n#include <map>\nusing namespace std;\ntypedef struct{int sx, sy, ex, ey; string to;} LINK;\t//ボタンの左上・右下座標、リンク先のページ名\ntypedef struct{string name; int n; LINK btn[100];} PAGE;\t//ページ名、ページ上にあるボタンの数・その一覧\nint main()\n{\n\tint n, o, W, H;\t//ページの数、命令の数、ページの幅・高さ\n\tint i, j, x, y, cur, t, m;\t//ループ用変数、\"click x y\"のx,y、、一時的な、履歴の長さ\n\tstring op;\t//命令の名前\n\tPAGE pg[100];\n\tLINK tmp;\n\tmap<string, int> tbl;\n\twhile (cin >> n, n)\n\t{\n\t\tdeque<string> his;\t//ページの履歴（pg[i]のiを代入）\n\t\tdeque<string>::iterator itr;\n\t\tcin >> W >> H;\n\t\tfor (i = 0; i < n; i++)\n\t\t{\n\t\t\tcin >> pg[i].name >> pg[i].n;\n\t\t\ttbl.insert( map<string, int>::value_type(pg[i].name, i) );\n\t\t\tfor (j = 0; j < pg[i].n; j++)\n\t\t\t{\n\t\t\t\tcin >> tmp.sx >> tmp.sy >> tmp.ex >> tmp.ey >> tmp.to;\n\t\t\t\tpg[i].btn[j] = tmp;\n\t\t\t}\n\t\t}\n\t\tcin >> o;\n\t\this.push_back(pg[0].name);\n\t\tcur = 0;\n\t\tm = 1;\n\t\tfor (i = 0; i < o; i++)\n\t\t{\n\t\t\tcin >> op;\n\t\t\tif (op == \"click\")\n\t\t\t{\n\t\t\t\tcin >> x >> y;\n\t\t\t\tt = tbl[his.at(cur)];\n\t\t\t\tfor (j = 0; j < pg[t].n; j++)\n\t\t\t\t{\n\t\t\t\t\tif (pg[t].btn[j].sx <= x && x <= pg[t].btn[j].ex && pg[t].btn[j].sy <= y && y <= pg[t].btn[j].ey)\n\t\t\t\t\t{\n\t\t\t\t\t\this.push_back(pg[t].btn[j].to);\n\t\t\t\t\t\tcur++;\n\t\t\t\t\t\tm++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\titr = his.end();\n\t\t\t\tfor (j = cur+1; j < m; j++)\n\t\t\t\t{\n\t\t\t\t\this.erase(itr);\n\t\t\t\t\tm--;\n\t\t\t\t\t*itr--;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (op == \"back\")\n\t\t\t{\n\t\t\t\tif (cur > 0)\n\t\t\t\t\tcur--;\n\t\t\t}\n\t\t\telse if (op == \"forward\")\n\t\t\t{\n\t\t\t\tif (cur < m)\n\t\t\t\t\tcur++;\n\t\t\t}\n\t\t\telse if (op == \"show\")\n\t\t\t{\n\t\t\t\tcout << his.at(cur) << endl;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <map>\nusing namespace std;\n\nstruct Button{\n\tint x1,x2,y1,y2;\n\tstring link;\n};\n\n\nvoid click(int x, int y, string& now, map< string , vector<struct Button> >& page, int& p, vector<string>& buff){\n\tvector<Button> B = page[now];\n\tstring to;\n\tfor(int i=0 ; i < B.size() ; i++ ){\n\t\tif( B[i].x1 <= x && x <= B[i].x2 && B[i].y1 <= y && y <= B[i].y2 ){\n\t\t\tto = B[i].link;\n\t\t}\n\t}\n\tif( !to.empty() ){\n\t\tnow = to;\n\t\twhile( p != buff.size()-1 ){\n\t\t\tbuff.pop_back();\n\t\t}\n\t\tbuff.push_back( to );\n\t\tp++;\n\t}\n}\n\nvoid back(string& now, int& p, vector<string>& buff){\n\tif( p != 0 && !buff.empty() ){\n\t\tp--;\n\t\tnow = buff[p];\n\t}\n}\n\nvoid forward(string& now, int& p, vector<string>& buff){\n\tif( p+1 < buff.size() ){\n\t\tp++;\n\t\tnow = buff[p];\n\t}\n}\n\nvoid show(string& now){\n\tcout << now << endl;\n}\n\nint main(){\n\tint n;\n\twhile( cin >> n , n ){\n\t\tint w,h;\n\t\tmap< string , vector<struct Button> > page;\n\t\tvector<string> buff;\n\t\tstring now;\n\t\tint p=0;\n\t\t\n\t\tcin >> w >> h;\n\t\tfor(int i=0 ; i < n ; i++ ){\n\t\t\tint b;\n\t\t\tstring title;\n\t\t\tcin >> title >> b;\n\t\t\t\n\t\t\tif( i == 0 ){\n\t\t\t\tnow = title;\n\t\t\t\tbuff.push_back( now );\n\t\t\t}\n\t\t\tfor(int j=0 ; j < b ; j++ ){\n\t\t\t\tint x1, y1, x2, y2;\n\t\t\t\tstring link;\n\t\t\t\t\n\t\t\t\tcin >> x1 >> y1 >> x2 >> y2 >> link;\n\t\t\t\tstruct Button button;\n\t\t\t\tbutton.x1 = x1;\n\t\t\t\tbutton.y1 = y1;\n\t\t\t\tbutton.x2 = x2;\n\t\t\t\tbutton.y2 = y2;\n\t\t\t\tbutton.link = link;\n\t\t\t\tpage[title].push_back( button );\n\t\t\t}\n\t\t}\n\t\tint m;\n\t\tcin >> m;\n\t\tfor(int i=0 ; i < m ; i++ ){\n\t\t\tstring s;\n\t\t\tcin >> s;\n\t\t\tif( s == \"click\" ){\n\t\t\t\tint x, y;\n\t\t\t\tcin >> x >> y;\n\t\t\t\tclick( x , y , now , page , p , buff );\n\t\t\t}else if( s == \"back\" ){\n\t\t\t\tback( now , p , buff );\n\t\t\t}else if( s == \"forward\" ){\n\t\t\t\tforward( now , p , buff );\n\t\t\t}else if( s == \"show\" ){\n\t\t\t\tshow( now );\n\t\t\t}\n\t\t}\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n\n#define x first\n#define y second\n\nusing pi = pair<int,int>;\nusing P = pair<pi,pi>;\n\nstruct Page{\n    string name;\n\n    int m;\n    vector<P> b;\n    vector<string> l;\n\n    Page(){};\n\n    void READ(){\n        cin >>name >>m;\n        b = vector<P>(m);\n        l = vector<string>(m);\n        rep(i,m){\n            cin >>b[i].fi.x >>b[i].fi.y >>b[i].se.x >>b[i].se.y;\n            cin >>l[i];\n        }\n    }\n\n    int click(int x, int y){\n        rep(i,m){\n            if(b[i].fi.x<=x && x<=b[i].se.x && b[i].fi.y<=y && y<=b[i].se.y) return i;\n        }\n        return -1;\n    }\n};\n\nint main(){\n    int n;\n    while(cin >>n,n){\n        int W,H;\n        cin >>W >>H;\n\n        vector<Page> p(n);\n        rep(i,n) p[i].READ();\n\n        map<string,int> name2id;\n        rep(i,n) name2id[p[i].name] = i;\n\n        int Q;\n        cin >>Q;\n\n        vector<int> a(Q+2,-1);\n        int idx = 0;\n        a[0] = 0;\n\n        rep(qq,Q){\n            if(a[idx]==-1) while(1){}\n            string s;\n            cin >>s;\n            if(s == \"click\"){\n                int X,Y;\n                cin >>X >>Y;\n                int res = p[a[idx]].click(X,Y);\n                if(res != -1){\n                    for(int j=idx+1; j<Q+2; ++j) a[j] = -1;\n                    a[idx+1] = name2id[p[a[idx]].l[res]];\n                    ++idx;\n                }\n            }\n            else if(s == \"back\"){\n                if(idx>0) --idx;\n            }\n            else if(s == \"forward\"){\n                if(a[idx+1] != -1) ++idx;\n            }\n            else{\n                // show\n                cout << p[idx].name << \"\\n\";\n            }\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <set>\n\nusing namespace std;\n\n#define f first\n#define s second\n\ntypedef pair<int, int> P;\ntypedef pair<P, P> P2;\ntypedef pair<P2, string> P3;\n\nint main(){\n  int n;\n  int W, H;\n  \n  while(cin >> n, n){\n    cin >> W >> H;\n    \n    map<string, vector<P3> > page;\n    vector<P3> link;\n    string page_name;\n    string now;\n    int n_button, x1, x2, y1, y2;\n    \n    for(int i = 0 ; i < n ; i++){\n      cin >> page_name >> n_button;\n      if(i == 0) now = page_name;\n      for(int j = 0 ; j < n_button ; j++){\n\tP3 tmp;\n\tcin >> tmp.f.f.f >> tmp.f.f.s >> tmp.f.s.f >> tmp.f.s.s >> tmp.s;\n\tlink.push_back(tmp);\n      }\n      page.insert(make_pair(page_name, link));\n    }\n    \n    int n_op, x, y;\n    string op;\n    vector<string> history;\n    history.push_back(now);\n    int n_now = 0;\n    cin >> n_op;\n    cin.ignore();\n    while(n_op--){\n      getline(cin, op);\n      \n      if(op[0] == 'c'){ // click\n\tstring tmp1=\"\", tmp2=\"\";\n\tint i;\n\tfor(i = 6 ; op[i] != ' ' ; i++) tmp1 += op[i];\n\tfor( ; i < op.size() ; i++) tmp2 += op[i];\n\t\n\tx = atoi(tmp1.c_str());\n\ty = atoi(tmp2.c_str());\n\t\n\tfor(i = 0 ; i < page[now].size() ; i++){\n\t  if((page[now][i].f.f.f <= x && x <= page[now][i].f.s.f) &&\n\t     (page[now][i].f.f.s <= y && y <= page[now][i].f.s.s)){\n\t    now = page[now][i].s;\n\t    history.push_back(now);\n\t    n_now++;\n\t  }\n\t}\n      } // click end\n    \n      if(op == \"show\") cout << history[n_now] << endl;\n      if(op == \"back\") n_now--;\n      if(op == \"forward\") n_now++;\n    }\n    page.clear();\n    history.clear();\n    link.clear();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<algorithm>\n#include<iostream>\n#include<vector>\n#include<climits>\n#include<cfloat>\n\nusing namespace std;\n\nstruct point{\n  int x, y;\n};\n\nstruct button{\n  point ld,ru;\n  string name;\n};\n\nstruct page{\n  string name;\n  vector<button>btn;   \n}; \n\nint m,now;\nvector<page> a;\npage nowpage;\nstring buf[100000];\n\nvoid func(void){\n  for(int i=0;i<a.size();i++){\n    if(buf[now]==a[i].name){\n      nowpage=a[i];\n      return ;\n    }\n  }\n}\n\nvoid click(int c,int d){\n  \n  for(int i=0;i<nowpage.btn.size();i++){\n    if(nowpage.btn[i].ld.x <=c && nowpage.btn[i].ld.y <=d &&\n       nowpage.btn[i].ru.x >=c && nowpage.btn[i].ru.y >=d){\n      buf[++now]=nowpage.btn[i].name;\n      fill(buf+now+1,buf+100000,\"\");\n      return ;\n    }\n  }\n}\n\n\nint main(void){\n  int n;\n  int w,h,b;\n  point l,r;\n  page in;\n  button tmp;\n\n  while(cin >> n,n){\n  \n    a.clear();\n    fill(buf,buf+100000,\"\");\n\n    cin >> w >> h;\n    \n    for(int j=0;j<n;j++){\n      cin >> in.name >> b;    \n      \n      for(int i=0;i<b;i++){\n\tcin >> tmp.ld.x >> tmp.ld.y >> tmp.ru.x >> tmp.ru.y >> tmp.name;\n\tin.btn.push_back(tmp);\n      }\n      a.push_back(in);\n    }\n\n    now=0;\n    buf[0]=a[0].name;\n    nowpage=a[0];\n\n    cin >> m;\n\n    while(m--){\n      string s;\n      cin >> s;\n      if(s==\"click\"){\n\tint c,d;\n\tcin >> c >> d;\n\tclick(c,d);\n      }\n      else if(s==\"back\" && now>0)now--;\n      else if(s==\"forward\" && buf[now+1]!=\"\")now++;\n      else if(s==\"show\")cout << buf[now] << endl;\n\n      func();\n    }\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <set>\n \nusing namespace std;\n \n#define f first\n#define s second\n \ntypedef pair<int, int> P;\ntypedef pair<P, P> P2;\ntypedef pair<P2, string> P3;\n \nint main(){\n  int n;\n  int W, H;\n   \n  while(cin >> n, n){\n    cin >> W >> H;\n    \n    map<string, int> n_link;\n    map<string, vector<P3> > page;\n    vector<P3> link;\n    string page_name;\n    string now;\n    int n_button;\n     \n    for(int i = 0 ; i < n ; i++){\n      cin >> page_name >> n_button;\n      n_link.insert(make_pair(page_name, n_button));\n      if(i == 0) now = page_name;\n      for(int j = 0 ; j < n_button ; j++){\n\tP3 tmp;\n\tcin >> tmp.f.f.f >> tmp.f.f.s >> tmp.f.s.f >> tmp.f.s.s >> tmp.s;\n\tlink.push_back(tmp);\n      }\n      page.insert(make_pair(page_name, link));\n      link.clear();\n    }\n     \n    //cout << page[\"profile\"][1].s << endl;\n\n    int n_op, x, y;\n    string op;\n    vector<string> history;\n    history.push_back(now);\n    int n_now = 0;\n    cin >> n_op;\n    cin.ignore();\n    while(n_op--){\n      getline(cin, op);\n       \n      if(op[0] == 'c'){ // click\n\tstring tmp1=\"\", tmp2=\"\";\n\tint i;\n\tfor(i = 6 ; op[i] != ' ' ; i++) tmp1 += op[i];\n\tfor( ; i < op.size() ; i++) tmp2 += op[i];\n     \n\tx = atoi(tmp1.c_str());\n\ty = atoi(tmp2.c_str());\n     \n\t//for(i = 0 ; i < page[now].size() ; i++){\n\tfor(i = 0 ; i < page[now].size() ; i++){\n\t  if((page[now][i].f.f.f <= x && x <= page[now][i].f.s.f) &&\n\t     (page[now][i].f.f.s <= y && y <= page[now][i].f.s.s)){\n\t    now = page[now][i].s;\n\t    \n\t    for(i = history.size()-1 ; i > n_now ; i--){ // when back click\n\t      history[i].erase();\n\t    }\n\t    n_now = i;\n\t    history.push_back(now);\n\t    n_now++;\n\t  }\n\t}\n      } // click end\n      \n      if(op == \"show\") cout << history[n_now] << endl;\n      if(op == \"back\"){\n\tif(n_now == 0) continue;\n\tn_now--;\n      }\n      if(op == \"forward\"){\n\tif(n_now == history.size()-1) continue;\n\tn_now++;\n      }\n    }\n    page.clear();\n    history.clear();\n    link.clear();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// AOJ1054 Distorted Love\n\n#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n\nusing namespace std;\n\nint main(){\n\tint n;\n\tint buf[100];\n\tstring name[100];\n\tint b[100], x1[100][100], y1[100][100], x2[100][100], y2[100][100], ptr[100][100];\n\tstring link[100][100];\n\twhile(cin >> n, n){\n\t\tint x, y; cin >> x >> y;\n\t\tint cur = 0, size = 0; \n\t\tbuf[cur] = 0;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin >> name[i] >> b[i];\n\t\t\tfor(int j=0;j<b[i];j++)\n\t\t\t\tcin >> x1[i][j] >> y1[i][j] >> x2[i][j] >> y2[i][j] >> link[i][j];\n\t\t}\n\t\tfor(int i=0;i<n;i++)\n\t\t\tfor(int j=0;j<n;j++)\n\t\t\t\tfor(int k=0;k<b[j];k++)\n\t\t\t\t\tif(link[j][k]==name[i]) ptr[j][k] = i;\n\t\tcin >> n;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tstring s; cin >> s;\n\t\t\tif(s == \"click\"){\n\t\t\t\tcin >> x >> y;\n\t\t\t\tfor(int j=0;j<b[buf[cur]];j++){\n\t\t\t\t\tif(x1[buf[cur]][j]<=x&&x<=x2[buf[cur]][j]&&y1[buf[cur]][j]<=y&&y<=y2[buf[cur]][j]){\n\t\t\t\t\t\tcur++;\n\t\t\t\t\t\tsize = cur;\n\t\t\t\t\t\tbuf[cur] = ptr[buf[cur-1]][j];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(s == \"forward\" && cur != size) cur++;\n\t\t\tif(s == \"back\" && cur != 0) cur--;\n\t\t\tif(s == \"show\") cout << name[buf[cur]] << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "// AOJ1054 Distorted Love\n\n#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n\nusing namespace std;\n\nclass button{\npublic:\n\tint x1, y1, x2, y2; string name;\n\tbutton(int x1, int y1, int x2, int y2, string name) : x1(x1), y1(y1), x2(x2), y2(y2), name(name) {}\n\tbool in(int x, int y) { return x1 <= x && x <= x2 && y1 <= y && y <= y2; }\n};\n\nint main(){\n\tint n;\n\tint buf[100];\n\twhile(cin >> n, n){\n\t\tint x, y; cin >> x >> y;\n\t\tbuf[0] = 0; \n\t\tint size = 0;\n\t\tint cur = 0;\n\t\tstring s;\n\t\tvector<string> vs(n);\n\t\tmap<string, int> mp;\n\t\tvector< vector<button> > vv(n);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin >> s;\n\t\t\tvs[i] = s;\n\t\t\tmp[s] = i;\n\t\t\tint t; cin >> t;\n\t\t\tfor(int j=0;j<t;j++){\n\t\t\t\tint x1, y1, x2, y2; cin >> x1 >> y1 >> x2 >> y2 >> s;\n\t\t\t\tvv[i].push_back(button(x1, y1, x2, y2, s));\n\t\t\t}\n\t\t}\n\t\tcin >> n;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin >> s;\n\t\t\tif(s==\"show\") cout << vs[buf[cur]] << endl;\n\t\t\tif(s==\"forward\"){\n\t\t\t\tif(cur != size) cur++;\n\t\t\t}\n\t\t\tif(s==\"back\"){\n\t\t\t\tif(cur != 0) cur--;\n\t\t\t}\n\t\t\tif(s==\"click\"){\n\t\t\t\tint x, y; cin >> x >> y;\n\t\t\t\tfor(int j=0;j<vv[buf[cur]].size();j++){\n\t\t\t\t\tif(vv[buf[cur]][j].in(x,y)){\n\t\t\t\t\t\tcur++;\n\t\t\t\t\t\tsize = cur;\n\t\t\t\t\t\tbuf[cur] = mp[vv[buf[cur-1]][j].name];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<string>\n#include<iostream>\n#include<algorithm>\n#include<map>\nusing namespace std;\n#define MAXN 1000000\nusing namespace std;\nmap<string,int> mp;\nstruct Point\n{\n    int x1,y1,x2,y2;\n    string name;\n};\nstruct List\n{\n   string name;\n   int num;\n   Point p[105];\n\n}list[105];\nint a[MAXN];\nint main()\n{\n   // freopen(\"in.cpp\",\"r\",stdin);\n\n    int n,i,j,k,m;\n    int W,H;\n    while(scanf(\"%d\",&n)&&n)\n    {\n        mp.clear();\n       scanf(\"%d%d\",&W,&H);\n       for(i=0;i<n;i++)\n       {   cin>>list[i].name;\n           mp[list[i].name]=i;\n           scanf(\"%d\",&list[i].num);\n           for(j=0;j<list[i].num;j++)\n           {\n               scanf(\"%d%d%d%d\",&list[i].p[j].x1,&list[i].p[j].y1,&list[i].p[j].x2,&list[i].p[j].y2);\n               list[i].p[j].x1=max(list[i].p[j].x1,0);\n               list[i].p[j].y1=max(list[i].p[j].y1,0);\n               list[i].p[j].x2=min(list[i].p[j].x2,W);\n               list[i].p[j].y2=min(list[i].p[j].y2,H);\n              cin>>list[i].p[j].name;\n\n           }\n       }\n\n       int head=0,tail=0;\n       int now=0;\n       int point=0;\n       int x,y;\n       a[head]=0;\n       scanf(\"%d\",&m);\n       char str[50];\n       while(m--)\n       {\n\n           scanf(\"%s\",str);\n           if(str[0]=='c')\n           {\n               scanf(\"%d%d\",&x,&y);\n\n\n\n\n\n               now=a[point];\n               for(i=0;i<list[now].num;i++)\n               {\n                 if(list[now].p[i].x1<=x&&x<=list[now].p[i].x2&&list[now].p[i].y1<=y&&y<=list[now].p[i].y2)\n                 break;\n\n\n               }\n\n\n\n            if(i<list[now].num)\n            {\n                a[++point]=mp[list[now].p[i].name];\n                tail=point;\n\n            }\n           }\n           else if(str[0]=='s')\n           {   now=a[point];\n               cout<<list[now].name<<endl;\n           }\n           else if(str[0]=='b')\n           {\n              point--;\n              point=max(point,head);\n           }\n           else if(str[0]=='f')\n           {\n              point++;\n              point=min(point,tail);\n\n           }\n       }\n\n\n\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <set>\n\nusing namespace std;\n\n#define f first\n#define s second\n\ntypedef pair<int, int> P;\ntypedef pair<P, P> P2;\ntypedef pair<P2, string> P3;\n\nint main(){\n  int n;\n  int W, H;\n  \n  while(cin >> n, n){\n    cin >> W >> H;\n    \n    map<string, vector<P3> > page;\n    vector<P3> link;\n    string page_name;\n    string now;\n    int n_button;\n    \n    for(int i = 0 ; i < n ; i++){\n      cin >> page_name >> n_button;\n      if(i == 0) now = page_name;\n      for(int j = 0 ; j < n_button ; j++){\n\tP3 tmp;\n\tcin >> tmp.f.f.f >> tmp.f.f.s >> tmp.f.s.f >> tmp.f.s.s >> tmp.s;\n\tlink.push_back(tmp);\n      }\n      page.insert(make_pair(page_name, link));\n    }\n    \n    int n_op, x, y;\n    string op;\n    vector<string> history;\n    history.push_back(now);\n    int n_now = 0;\n    cin >> n_op;\n    cin.ignore();\n    while(n_op--){\n      getline(cin, op);\n      \n      if(op[0] == 'c'){ // click\n\tstring tmp1=\"\", tmp2=\"\";\n\tint i;\n\tfor(i = 6 ; op[i] != ' ' ; i++) tmp1 += op[i];\n\tfor( ; i < op.size() ; i++) tmp2 += op[i];\n\t\n\tx = atoi(tmp1.c_str());\n\ty = atoi(tmp2.c_str());\n\t\n\tfor(i = 0 ; i < page[now].size() ; i++){\n\t  if((page[now][i].f.f.f <= x && x <= page[now][i].f.s.f) &&\n\t     (page[now][i].f.f.s <= y && y <= page[now][i].f.s.s)){\n\t    now = page[now][i].s;\n\t    history.push_back(now);\n\t    n_now++;\n\t  }\n\t}\n      } // click end\n    \n      if(op == \"show\") cout << history[n_now] << endl;\n      if(op == \"back\") n_now--;\n      if(op == \"forward\") n_now++;\n    }\n    page.clear();\n    history.clear();\n    link.clear();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\nusing namespace std;\nstruct pp{\n\tint t;\n\tint x1[105],y1[105],x2[105],y2[105];\n\tstring s[105];\n\tstring now;\n}p[105];\nint main()\n{\n\tint n;\n\tint h,w;\n\tstring o;\n\twhile(cin>>n)\n\t{\n\t\tif(n==0) break;\n\t\tcin>>h>>w;\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tcin>>p[i].now>>p[i].t;\n\t\t\tfor(int j=0;j<p[i].t;j++)\n\t\t\t{\n\t\t\t\tcin>>p[i].x1[j]>>p[i].y1[j]>>p[i].x2[j]\n\t\t\t\t>>p[i].y2[j]>>p[i].s[j];\n\t\t\t}\n\t\t}\n\t\tint m,x,y;\n\t\tcin>>m;\n\t\tint num=0;\n\t\tint sum=0;\n\t\tstring t[10005];\n\t\tt[0]=p[0].now;\n\t\tfor(int i=0;i<m;i++)\n\t\t{\n\t\t\tcin>>o;\n\t\t\tif(o==\"click\") \n\t\t\t{\n\t\t\t\tcin>>x>>y;\n\n\t\t\t\tfor(int j=0;j<p[num].t;j++)\n\t\t\t\t{\n\t\t\t\t\tif(x>=p[num].x1[j] && x<=p[num].x2[j] && y>=p[num].y1[j] && y<=p[num].y2[j]) \n\t\t\t\t\t{\n\t\t\t\t\t\tbool f=false;\n\t\t\t\t\t\tfor(int k=0;k<n;k++)\n\t\t\t\t\t\t\tif(p[k].now==p[num].s[j]) {\n\t\t\t\t\t\t\t\tt[num+1]=p[k].now;\n\t\t\t\t\t\t\t\tnum++;\n\t\t\t\t\t\t\t\tsum=num;\n\t\t\t\t\t\t\t\tf=true;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(f) break;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(o==\"show\") cout<<p[num].now<<endl;\n\t\t\telse if(o==\"back\") {\n\t\t\t\tif(num>0) num--;\n\t\t\t}\n\t\t\telse if(o==\"forward\") \n\t\t\t{\n\t\t\t\tif(num<sum) num++;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "// AOJ1054 Distorted Love\n\n#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n\nusing namespace std;\n\nclass button{\npublic:\n\tint x1, y1, x2, y2; string name;\n\tbutton(int x1, int y1, int x2, int y2, string name) : x1(x1), y1(y1), x2(x2), y2(y2), name(name) {}\n\tbool in(int x, int y) { return x1 <= x && x <= x2 && y1 <= y && y <= y2; }\n};\n\nint main(){\n\tint n;\n\tint buf[100];\n\twhile(cin >> n, n){\n\t\tint x, y; cin >> x >> y;\n\t\tbuf[0] = 0; \n\t\tint size = 0;\n\t\tint cur = 0;\n\t\tstring s;\n\t\tvector<string> vs(n);\n\t\tmap<string, int> mp;\n\t\tvector< vector<button> > vv(n, vector<button>());\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin >> s;\n\t\t\tvs[i] = s;\n\t\t\tmp[s] = i;\n\t\t\tint t; cin >> t;\n\t\t\tfor(int j=0;j<t;j++){\n\t\t\t\tint x1, y1, x2, y2; cin >> x1 >> y1 >> x2 >> y2 >> s;\n\t\t\t\tvv[i].push_back(button(x1, y1, x2, y2, s));\n\t\t\t}\n\t\t}\n\t\tcin >> n;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin >> s;\n\t\t\tif(s==\"show\") cout << vs[buf[cur]] << endl;\n\t\t\tif(s==\"forward\"){\n\t\t\t\tif(cur != size) cur++;\n\t\t\t}\n\t\t\tif(s==\"back\"){\n\t\t\t\tif(cur != 0) cur--;\n\t\t\t}\n\t\t\tif(s==\"click\"){\n\t\t\t\tint x, y; cin >> x >> y;\n\t\t\t\tfor(int j=0;j<vv[buf[cur]].size();j++){\n\t\t\t\t\tif(vv[buf[cur]][j].in(x,y)){\n\t\t\t\t\t\tcur++;\n\t\t\t\t\t\tsize = cur;\n\t\t\t\t\t\tbuf[cur] = mp[vv[buf[cur-1]][j].name];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <map>\nusing namespace std;\n\nstruct Button {\n    int x1, y1, x2, y2;\n    string to;\n};\n\nstruct Page {\n    vector<Button> bs;\n};\n\nint main() {\n    int n;\n    while (cin >> n, n) {\n        int w, h;\n        cin >> w >> h;\n        map<string, Page> ps;\n        vector<string> buf;\n        for (int i = 0; i < n; i++) {\n            string name;\n            int b;\n            cin >> name >> b;\n            Page p;\n            for (int j = 0; j < b; j++) {\n                Button l;\n                cin >> l.x1 >> l.y1 >> l.x2 >> l.y2 >> l.to;\n                p.bs.push_back(l);\n            }\n            ps[name] = p;\n            if (i == 0) {\n                buf.push_back(name);\n            }\n        }\n        int m;\n        cin >> m;\n        int idx = 0;\n        for (int i = 0; i < m; i++) {\n            string cmd;\n            cin >> cmd;\n            if (cmd == \"click\") {\n                int x, y;\n                cin >> x >> y;\n                Page p = ps[buf[idx]];\n                for (vector<Button>::iterator it = p.bs.begin(); it != p.bs.end(); it++) {\n                    if (it->x1 <= x && x <= it->x2 && it->y1 <= y && y <= it->y2) {\n                        buf.erase(buf.begin() + idx + 1, buf.end());\n                        buf.push_back(it->to);\n                        idx++;\n                        break;\n                    }\n                }\n            } else if (cmd == \"back\") {\n                if (idx > 0) {\n                    idx--;\n                }\n            } else if (cmd == \"forward\") {\n                if (idx < (int) buf.size() - 1) {\n                    idx++;\n                }\n            } else if (cmd == \"show\") {\n                cout << buf[idx] << endl;\n            }\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\nusing namespace std;\nconst int namelen = 25;\nconst int maxn = 105;\nconst int maxnlink = 105;\nconst int stacksize = 10000;\nstruct PAGE {\n    char name[namelen];\n    int links;\n    int x1[maxnlink], x2[maxnlink], y1[maxnlink], y2[maxnlink];\n    char linkname[maxnlink][namelen];\n} page[maxn];\n\nint n, w, h, i, j, k, m, x, y;\nint stack[stacksize];\nint stackp, stacklen;\nchar type[30];\n\nint main() {\n    while (scanf(\"%d\", &n), n>0)\n    {\n        scanf(\"%d%d\", &w, &h);\n        for (i = 0; i < n; i++)\n        {\n            scanf(\"%s %d\", page[i].name, &page[i].links);\n          //  cout << page[i].name << \" \" <<  page[i].links << endl;\n            for (j = 0; j < page[i].links; j++)\n            {\n                scanf(\"%d %d %d %d %s\",\n                      &page[i].x1[j], &page[i].y1[j],\n                      &page[i].x2[j], &page[i].y2[j], page[i].linkname[j]);\n                //cout << page[i].linkname[j] << endl;\n            }\n        }\n        //return 0;\n        memset(stack, 0, sizeof(stack));\n        stack[0] = 0; stacklen = 1;\n        stackp = 0;\n        scanf(\"%d\", &m);\n        //cout << m << endl;\n        //return 0;\n        for (i = 0; i < m; i++)\n        {\n            scanf(\"%s\", type);\n            if (strcmp(type, \"click\")==0)\n            {\n                scanf(\"%d%d\", &x, &y);\n                //cout << x << y << endl;\n                for (j = 0; j < page[stackp].links; j++)\n                if (page[stackp].x1[j]<x && x < page[stackp].x2[j] &&\n                    page[stackp].y1[j]<y && y < page[stackp].y2[j]) {\n                        break;\n                    }\n                if (j == page[stackp].links) continue;\n                for (k = 0; k < n; k++)\n                if (strcmp(page[k].name, page[stackp].linkname[j])==0) break;\n                stack[++stackp] = k;\n                stacklen = stackp+1;\n            } else\n            if (strcmp(type, \"show\")==0)\n            {\n                printf(\"%s\\n\", page[stackp].name);\n            } else\n            if (strcmp(type, \"back\")==0)\n            {\n                if (stackp > 0) stackp--;\n            } else\n            if (strcmp(type, \"forward\")==0)\n            {\n                if (stackp < stacklen-1) stackp++;\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\n\nint b[100], x1[100][100], Y1[100][100], x2[100][100], y2[100][100];\nstring link[100][100];\nmap<string, int>mp;\nint main() {\n\tint n;\n\twhile (scanf(\"%d\", &n), n) {\n\t\tmp.clear();\n\t\tint w, h; scanf(\"%d%d\", &w, &h);\n\t\tvector<string>v;\n\t\trep(i, n) {\n\t\t\tstring s; cin >> s >> b[i]; mp[s] = i;\n\t\t\tif (i == 0)v.push_back(s);\n\t\t\trep(j, b[i])cin >> x1[i][j] >> Y1[i][j] >> x2[i][j] >> y2[i][j] >> link[i][j];\n\t\t}\n\t\tint pos = 0;\n\t\tint m; scanf(\"%d\", &m);\n\t\trep(i, m) {\n\t\t\tstring s; cin >> s;\n\t\t\tif (s == \"click\") {\n\t\t\t\tint x, y; cin >> x >> y;\n\t\t\t\tint a = mp[pos];\n\t\t\t\trep(i, b[a]) {\n\t\t\t\t\tif (x1[a][i] <= x&&x <= x2[a][i] && Y1[a][i] <= y&&y <= y2[a][i]) {\n\t\t\t\t\t\tv.erase(v.begin() + pos + 1, v.end());\n\t\t\t\t\t\tv.push_back(link[a][i]); pos = v.size() - 1; break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (s == \"back\") {\n\t\t\t\tif (pos)pos--;\n\t\t\t}\n\t\t\tif (s == \"forward\") {\n\t\t\t\tif (pos < v.size() - 1)pos++;\n\t\t\t}\n\t\t\tif (s == \"show\")cout << v[pos] << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <iostream>\n#include <algorithm>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <utility>\n#include <cctype>\n#include <cassert>\nusing namespace std;\n\n#define rep(i,n) for(int (i)=0; (i)<(int)(n); ++(i))\n#define foreach(c,i) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n\nstruct Button {\n  int lx, ly, rx, ry, to;\n  bool Check(int cx, int cy) {\n    return (lx <= cx) && (cx <= rx) && (ly <= cy) && (cy <= ry);\n  }\n};\n\nint N, W, H, Q;\nvector<int> B(102);\nvector<string> vs(102);\nvector<Button> vbs[102];\n\nint main() {\n  while (cin >> N, N) {\n    cin >> W >> H;\n\n    vector<vector<string> > links(N, vector<string>());\n    map<string,int> maps;\n    string temp;\n    int lx, ly, rx, ry;\n    \n    rep(i,N) {\n      cin >> vs[i] >> B[i];\n      maps.insert(make_pair(vs[i], i));\n      rep(j,B[i]) {\n        cin >> lx >> ly >> rx >> ry >> temp;\n        vbs[i].push_back((Button){lx, ly, rx, ry, -1});\n        links[i].push_back(temp);\n      }\n    }\n\n    rep(i,N) {\n      rep(j,links[i].size()) {\n        vbs[i][j].to = maps[ links[i][j] ];\n      }\n    }\n\n    cin >> Q;\n    string query;\n    int cx, cy;\n    vector<string> buffer(1, vs[0]);\n    vector<string>::iterator itr;\n    int ptr = 0;\n    \n    rep(q,Q) {\n      cin >> query;\n      if (query == \"click\") {\n        cin >> cx >> cy;\n        int cur = maps[ vs[ptr] ];\n        rep(i,B[cur]) {\n          if (vbs[cur][i].Check(cx, cy)) {\n            if (ptr != buffer.size()-1) {\n              itr = buffer.begin();\n              advance(itr, ptr+1);\n              buffer.erase(itr, buffer.end());             \n            }\n            buffer.push_back(vs[ vbs[cur][i].to ]);\n            // printf(\"clicked success to %s\\n\", vs[ vbs[cur][i].to ].c_str());\n            ++ptr;\n            break;\n          }\n        }\n      } else if(query == \"show\") {\n        cout << buffer[ptr] << endl;\n      } else if(query == \"back\") {\n        if (ptr > 0) --ptr;\n      } else if(query == \"forward\") {\n        if (buffer.size() - 1 >= ptr + 1) ++ptr;\n      } else {\n        assert(false);\n      }\n      // printf(\"state %3d:\", q);\n      // rep(i,buffer.size()) printf(\"[%s]\",buffer[i].c_str()); puts(\"\");      \n    }\n    \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<map>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\nstruct POINT{\n  int x1, y1;\n  int x2, y2;\n};\n\nmap<string, POINT> MakeButton(int);\nvoid Click(map< string, map<string, POINT> >,\n\t   vector<string>&, int&, int, int);\n\nint main(){\n  int i, n, m, w, h, now;\n  string str;\n  vector<string> logdata;\n  map< string, map<string, POINT> > webpage;\n\n  while(1){\n    cin >> n;\n    if(n == 0) break;\n    cin >> w >> h;\n\n    for(i=0; i<n; ++i){\n      cin >> str >> m;\n      if(i == 0) logdata.push_back(str);\n      webpage.insert(make_pair(str, MakeButton(m)));\n    }\n\n    cin >> m;\n    for(i=0, now=0; i<m; ++i){\n      cin >> str;\n      if(str == \"click\") Click(webpage, logdata, now, w, h);\n      else if(str == \"back\" && now > 0) --now;\n      else if(str == \"forward\" && now < logdata.size()-1) ++now;\n      else if(str == \"show\") cout << logdata[now] << endl;\n    }\n\n    logdata.clear();\n    webpage.clear();\n  }\n  return 0;\n}\n\nmap<string, POINT> MakeButton(int n){\n  int i, x1, y1, x2, y2;\n  string str;\n  POINT p;\n  map<string, POINT> button;\n\n  for(i=0; i<n; ++i){\n    cin >> p.x1 >> p.y1 >> p.x2 >> p.y2 >> str;\n    button.insert(make_pair(str, p));\n  }\n  return button;\n}\n\nvoid Click(map< string, map<string, POINT> > webpage,\n\t   vector<string>& logdata, int& now, int w, int h){\n  int x, y;\n  cin >> x >> y;\n  if(x < 0 || w < x || y < 0 || h < y) return;\n\n  POINT p;\n  map<string, POINT> button;\n  map<string, POINT>::iterator i;\n  map< string, map<string, POINT> >::iterator j;\n\n  j = webpage.find(logdata[now]);\n  button = j->second;\n\n  for(i=button.begin(); i!=button.end(); ++i){\n    p = i->second;\n    if(p.x1 <= x && x <= p.x2 && p.y1 <= y && y <= p.y2){\n      ++now;\n      logdata.erase(logdata.begin()+now, logdata.end());\n      logdata.push_back(i->first);\n      return;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<vector>\n#include<set>\n#include<map>\n#include<queue>\n#include<algorithm>\n#include<numeric>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define rp(i,c) rep(i,(c).size())\n#define fr(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf=1<<28;\nconst double INF=1e12,EPS=1e-9;\n\nstruct S{\n\tint x1,y1,x2,y2;\n\tstring name;\n};\n\nint main()\n{\n\tint n;\n\twhile(cin>>n,n)\n\t{\n\t\tint h,w; cin>>h>>w;\n\t\tvector<string> name(n);\n\t\tmap<string,vector<S> > button;\n\t\t\n\t\tcin.ignore();\n\t\t\n\t\trep(i,n)\n\t\t{\n\t\t\tint k;\n\t\t\tstring str;\n\t\t\tgetline(cin,str);\n\t\t\tint p=str.rfind(\" \");\n\t\t\t\n\t\t\tname[i]=str.substr(0,p);\n\t\t\tstringstream(str.substr(p))>>k;\n\t\t\t\n\t\t\trep(j,k)\n\t\t\t{\n\t\t\t\tS s;\n\t\t\t\tstring str; getline(cin,str);\n\t\t\t\t\n\t\t\t\tint p=0;\n\t\t\t\trep(it,4)p=str.find(\" \",p+1);\n\t\t\t\ts.name=str.substr(p+1);\n\t\t\t\t\n\t\t\t\tstringstream(str.substr(0,p))>>s.x1>>s.y1>>s.x2>>s.y2;\n\t\t\t\tbutton[name[i]].pb(s);\n\t\t\t}\n\t\t}\n\t\t\n\t\tint m; cin>>m;\n\t\tvector<string> buffer; int cur=0;\n\t\tbuffer.pb(name[0]);\n\t\t\n\t\trep(i,m)\n\t\t{\n\t\t\tstring op; cin>>op;\n\t\t\tif(op==\"show\")\n\t\t\t{\n\t\t\t\tcout<<buffer[cur]<<endl;\n\t\t\t}\n\t\t\telse if(op==\"click\")\n\t\t\t{\n\t\t\t\tint x,y; cin>>x>>y;\n\t\t\t\tfr(it,button[buffer[cur]])if(it->x1<=x&&x<=it->x2&&it->y1<=y&&y<=it->y2)\n\t\t\t\t{\n\t\t\t\t\tbuffer.erase(buffer.begin()+cur+1,buffer.end());\n\t\t\t\t\tbuffer.pb(it->name);\n\t\t\t\t\tcur++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(op==\"back\")\n\t\t\t{\n\t\t\t\tif(cur>0)cur--;\n\t\t\t}\n\t\t\telse if(op==\"forward\")\n\t\t\t{\n\t\t\t\tif(cur<buffer.size()-1)cur++;\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <map>\n#include <sstream>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\nclass B{\npublic:\n  int x1, y1, x2, y2;\n  string to;\n  B(){}\n  B(int x1, int y1, int x2, int y2, string to) : x1(x1), y1(y1), x2(x2), y2(y2), to(to) {}\n};\n\nint n, h, w, b[100], m;\nvector<B> buttons[100];\nstring name[100];\nmap<string, int> stoi;\n\nint clicked(int x, int y, int p){\n  for(int i=0;i<b[p];i++){\n    B but = buttons[p][i];\n    if(but.x1 <= x && x <= but.x2 && but.y1 <= y && y <= but.y2) return stoi[but.to];\n  }\n  return -1;\n}\n\nmain(){\n  while(cin >> n && n){\n    stoi.clear();\n    for(int i=0;i<n;i++) buttons[i].clear();\n    cin >> w >> h;\n    for(int i=0;i<n;i++){\n      cin >> name[i];\n      cin >> b[i];\n      stoi[name[i]] = i;\n      for(int j=0;j<b[i];j++){\n        B in;\n        cin >> in.x1 >> in.y1 >> in.x2 >> in.y2 >> in.to;\n        buttons[i].push_back(in);\n      }\n    }\n    cin >> m;\n    int p = 0;\n    vector<int> buf;\n    buf.push_back(0);\n    for(int i=0;i<m;i++){\n      string str;\n      cin >> str;\n      if(str == \"forward\"){\n        if(p+1 < buf.size()) p++;\n      }else if(str == \"back\"){\n        if(p != 0) p--;\n      }else if(str == \"show\"){\n        cout << name[buf[p]] << endl;\n      }else{\n        int x, y;\n        cin >> x >> y;\n        int next = clicked(x, y, buf[p]);\n        if(next == -1) continue;\n        if(p+1 != buf.size()) buf.erase(buf.begin() + p);\n        buf.push_back(next);\n        p++;\n      }\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <string>\n\nusing namespace std;\n\nstruct button{\n\tstring toName;\n\tint minx;\n\tint maxx;\n\tint miny;\n\tint maxy;\n};\n\nint page;\nvector<string> history;\nint n;\nint h,w;\nmap<string,vector<button> > pageInfo;\n\nint main(){\n\n\twhile(cin>>n&&n!=0){\n\t\thistory.clear();\n\t\tpageInfo.clear();\n\t\tpage=0;\n\t\thistory.clear();\n\t\tcin>>w>>h;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tstring str;\n\t\t\tint bn;\n\t\t\tcin>>str>>bn;\n\t\t\tif(i==0){\n\t\t\t\thistory.push_back(str);\n\t\t\t}\n\t\t\tvector<button> vb;\n\t\t\tfor(int j = 0; j < bn; j++){\n\t\t\t\tbutton b;\n\t\t\t\tcin>>b.minx>>b.miny>>b.maxx>>b.maxy>>b.toName;\n\t\t\t\tvb.push_back(b);\n\t\t\t}\n\t\t\tpageInfo[str]=vb;\n\t\t}\n\t\tint m;\n\t\tcin>>m;\n\t\t// operation start\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tstring op;\n\t\t\tcin>>op;\n\t\t\tif(op==\"click\"){\n\t\t\t\tint x,y;\n\t\t\t\tcin>>x>>y;\n\t\t\t\t// buttonÌÊuðcheck\n\t\t\t\tfor(int j = 0; j < pageInfo[history[page]].size(); j++){\n\t\t\t\t\t// Ú®Å«éÌÈçÎA»ÝÌêÌ¨É éhistoryðíµA»ÝÌêÌ¨ÉÚ®æy[WðÇÁµApageðCNg\n\t\t\t\t\tbutton &b = pageInfo[history[page]][j];\n\t\t\t\t\tif(b.minx<=x&&b.maxx>=x&&b.miny<=y&&b.maxy>=y){\n\t\t\t\t\t\t// »ÝÌêÌEÉ éhistoryðí\n\t\t\t\t\t\tfor(int k = page+1; k < history.size(); k++){\n\t\t\t\t\t\t\thistory.erase(history.begin()+history.size()-1);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// »ÝÌêÌEÉÚ®æy[WðÇÁ\n\t\t\t\t\t\thistory.push_back(b.toName);\n\t\t\t\t\t\tpage++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(op==\"show\"){\n\t\t\t\tcout<<history[page]<<endl;\n\t\t\t}\n\t\t\telse if(op==\"back\"){\n\t\t\t\tpage=max(0,page-1);\n\t\t\t}\n\t\t\telse if(op==\"forward\"){\n\t\t\t\tpage=min((int)history.size()-1,page+1);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nint i,j;\nstruct button\n{\n\tstring in;\n\tint x1;\n\tint y1;\n\tint x2;\n\tint y2;\n\tstring to;\n};\nint main()\n{\n\tfor(int n;cin>>n&&n;)\n\t{\n\t\tint w,h;\n\t\tcin>>w>>h;\n\t\tbutton a[10000];\n\t\tint q=0;\n\t\tfor(i=0;i<n;++i)\n\t\t{\n\t\t\tstring ss;\n\t\t\tint tt;\n\t\t\tcin>>ss>>tt;\n\t\t\tfor(j=0;j<tt;++j)\n\t\t\t{\n\t\t\t\tint xx1,yy1,xx2,yy2;\n\t\t\t\tstring TO;\n\t\t\t\tcin>>xx1>>yy1>>xx2>>yy2>>TO;\n\t\t\t\ta[q].in=ss;\n\t\t\t\ta[q].to=TO;\n\t\t\t\ta[q].x1=xx1;\n\t\t\t\ta[q].x2=xx2;\n\t\t\t\ta[q].y1=yy1;\n\t\t\t\ta[q++].y2=yy2;\n\t\t\t}\n\t\t}\n\t\tint m;\n\t\tcin>>m;\n\t\tstring b[100];\n\t\tint p=0,pp=0;\n\t\tb[0]=a[0].in;\n\t\tfor(i=0;i<m;++i)\n\t\t{\n\t\t\tstring k;\n\t\t\tcin>>k;\n\t\t\tif(k==\"show\")\n\t\t\t\tcout<<b[pp]<<endl;\n\t\t\tif(k==\"back\"&&pp!=0)\n\t\t\t\tpp--;\n\t\t\tif(k==\"forward\"&&pp!=p)\n\t\t\t\tpp++;\n\t\t\tif(k==\"click\")\n\t\t\t{\n\t\t\t\tint x,y,f=0,e=q-1;\n\t\t\t\tcin>>x>>y;\n\t\t\t\t//cout<<f<<' '<<e<<endl;\n\t\t\t\tfor(j=0;j<q;++j)\n\t\t\t\t\tif(a[j].in==b[pp])\n\t\t\t\t\t{\n\t\t\t\t\t\tf=j;\n\t\t\t\t\t    for(int kk=f;kk<q;++kk)\n\t\t\t\t\t\t\tif(a[kk].in!=b[pp])\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\te=kk-1;\n\t\t\t\t\t\t\t\tgoto abc;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\tabc:\t\n\t\t\t\t//cout<<f<<' '<<e<<endl;\n\t\t\t\t\tfor(j=f;j<=e;++j)\n\t\t\t\t\t\tif(x>a[j].x1&&x<a[j].x2&&y>a[j].y1&&y<a[j].y2)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tp=pp;\n\t\t\t\t\t\t\tb[++p]=a[j].to;\n\t\t\t\t\t\t\tpp=p;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n#define MAX 110\n\nstruct Page{\n  int sx,sy,tx,ty;\n  string next;\n  Page(int sx,int sy,int tx,int ty,string next)\n    : sx(sx),sy(sy),tx(tx),ty(ty),next(next) {}\n};\n\nvector<Page> vec[MAX];\n\nvoid init(){\n  for(int i = 0 ; i < MAX ; i++){\n    vec[i].clear();\n  }\n}\n\nint main(){\n  int N,W,H,b[MAX],sx,sy,tx,ty,p = 0;\n  string str[MAX],s;\n\n  while(cin >> N,N){\n    cin >> W >> H;\n    init();\n    for(int i = 0 ; i < N ; i++){\n      cin >> str[i] >> b[i];\n      for(int j = 0 ; j < b[i] ; j++){\n        cin >> sx >> sy >> tx >> ty >> s;\n        vec[i].push_back(Page(sx,sy,tx,ty,s));\n      }\n    }\n    int m,w,h,now = 0;\n    vector<int> now_page;\n    now_page.push_back(now);\n    string next;\n    cin >> m;\n    for(int I = 0 ; I < m ; I++){\n      cin >> s;\n      if(s == \"click\"){\n        bool found = false;\n        cin >> w >> h;\n        for(int i = 0 ; i < b[now_page[p]] ; i++){\n          sx = vec[now][i].sx, sy = vec[now][i].sy;\n          tx = vec[now][i].tx, ty = vec[now][i].ty;\n          next = vec[now][i].next;\n          if(sx <= w && w <= tx && sy <= h && h <= ty){\n            for(int j = 0 ; j < N ; j++){\n              if(str[j] == next){\n                now = j;\n                found = true;\n                break;\n              }\n            }\n          }\n          if(found){\n            p++;\n            while(p < now_page.size()){\n              now_page.pop_back();\n            }\n            now_page.push_back(now);\n            break;\n          }\n        }\n      }else if(s == \"show\"){\n        cout << str[now_page[p]] << endl;\n      }else if(s == \"back\"){\n        if(p > 0) p--;\n      }else{\n        if(p+1 < now_page.size()) p++;\n      }\n    }\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<algorithm>\n#include<iostream>\n#include<vector>\n#include<climits>\n#include<cfloat>\n\nusing namespace std;\n\nstruct point{\n  int x, y;\n};\n\nstruct button{\n  point ld,ru;\n  string name;\n};\n\nstruct page{\n  string name;\n  vector<button>btn;   \n}; \n\nint m,now;\nvector<page> a;\npage nul;\nstatic page buf[10001];\n\nvoid click(int c,int d){\n  \n  for(int i=0;i<buf[now].btn.size();i++)\n    if(buf[now].btn[i].ld.x <=c && buf[now].btn[i].ld.y <=d &&\n       buf[now].btn[i].ru.x >=c && buf[now].btn[i].ru.y >=d)\n      for(int j=0;j<a.size();j++)\n\tif(buf[now].btn[i].name==a[j].name){\n\t  buf[++now]=a[j];\n\t  fill(buf+now+1,buf+10000,nul);\n\t  return ;\n\t}\n}\n\nint main(void){\n  int n;\n  int w,h,b;\n  point l,r;\n  page in;\n  button tmp;\n\n  nul.name=\"\";\n\n  while(cin >> n,n){\n  \n    a.clear();\n    fill(buf,buf+10000,nul);\n\n    cin >> w >> h;\n    \n    for(int j=0;j<n;j++){\n      cin >> in.name >> b;    \n      \n      for(int i=0;i<b;i++){\n\tcin >> tmp.ld.x >> tmp.ld.y >> tmp.ru.x >> tmp.ru.y >> tmp.name;\n\tin.btn.push_back(tmp);\n      }\n      a.push_back(in);\n    }\n\n    now=0;\n    buf[0]=a[0];\n\n    cin >> m;\n\n    while(m--){\n      string s;\n      cin >> s;\n      if(s==\"click\"){\n\tint c,d;\n\tcin >> c >> d;\n\tclick(c,d);\n      }\n      else if(s==\"back\" && now>0)now--;\n      else if(s==\"forward\" && now < 10000 && buf[now+1].name!=\"\")now++;\n      else if(s==\"show\")cout << buf[now].name << endl;\n    }\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<map>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nstruct State { string nm; int rx, ry, sx, sy; };\nint n, W, H; map<string, vector<State>>M;\nint main() {\n\twhile (true) {\n\t\tcin >> n; if (n == 0)break; cin >> W >> H; M.clear();\n\t\tstring R;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tstring Y; int p; cin >> Y >> p; if (i == 0)R = Y;\n\t\t\tfor (int j = 0; j < p; j++) {\n\t\t\t\tState ST; cin >> ST.rx >> ST.ry >> ST.sx >> ST.sy >> ST.nm;\n\t\t\t\tM[Y].push_back(ST);\n\t\t\t}\n\t\t}\n\t\tint q; cin >> q; vector<string>D; D.push_back(R); int e = 0;\n\t\tfor (int i = 0; i < q; i++) {\n\t\t\tstring W; cin >> W;\n\t\t\tif (W == \"show\") { cout << D[e] << endl; }\n\t\t\tif (W == \"forward\") { e = min(e + 1, (int)D.size() - 1); }\n\t\t\tif (W == \"back\") { e = max(0, e - 1); }\n\t\t\tif (W == \"click\") {\n\t\t\t\tint r1, r2; cin >> r1 >> r2;\n\t\t\t\tfor (int j = 0; j < M[D[e]].size(); j++) {\n\t\t\t\t\tState Q = M[D[e]][j];\n\t\t\t\t\tif (Q.rx <= r1 && r1 <= Q.sx && Q.ry <= r2 && r2 <= Q.sy) {\n\t\t\t\t\t\twhile (D.size() > e + 1)D.pop_back();\n\t\t\t\t\t\tD.push_back(Q.nm); e++; break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 100000000\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P> PP;\n\nstatic const double EPS = 1e-8;\n\nconst int tx[] = {0,1,0,-1};\nconst int ty[] = {-1,0,1,0};\n\nclass Button{\npublic:\n\tint lu_x,lu_y,rl_x,rl_y;\n\tstring name;\n\tButton() : lu_x(0),lu_y(0),rl_x(0),rl_y(0),name(\"\"){}\n\tButton(int lu_x,int lu_y,int rl_x,int rl_y,string name): lu_x(lu_x),lu_y(lu_y),rl_x(rl_x),rl_y(rl_y),name(name){}\n};\n\nint main(){\n\tint n;\n\tint W,H;\n\tmap<string,vector<Button> > page;\n\tvector<string> browsed;\n\twhile(~scanf(\"%d\",&n)){\n\t\tif(n==0) break;\n\t\tscanf(\"%d %d\",&W,&H);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tstring name;\n\t\t\tint num;\n\t\t\tcin >> name >> num;\n\t\t\tfor(int j=0;j<num;j++){\n\t\t\t\tstring next;\n\t\t\t\tint lu_x,lu_y,rl_x,rl_y;\n\t\t\t\tcin >> lu_x >> lu_y >> rl_x >> rl_y >> next;\n\t\t\t\tpage[name].push_back(Button(lu_x,lu_y,rl_x,rl_y,next));\n\t\t\t\tif(browsed.size()==0) browsed.push_back(name);\n\t\t\t}\n\t\t}\n\n\t\tint m;\n\t\tint pos = 0;\n\t\tscanf(\"%d\",&m);\n\t\tfor(int i=0;i<m;i++){\n\t\t\tstring act;\n\t\t\tcin >> act;\n\t\t\tif(act==\"click\"){\n\t\t\t\tint x,y;\n\t\t\t\tcin >> x >> y;\n\t\t\t\tstring now = browsed[pos];\n\t\t\t\tfor(int i=0;i<page[now].size();i++){\n\t\t\t\t\tif(!(x < page[now][i].lu_x || page[now][i].rl_x < x\n\t\t\t\t\t\t|| y > page[now][i].rl_y || page[now][i].lu_y > y)){\n\t\t\t\t\t\t\tif(browsed.size()-1 >= pos+1)browsed.erase(browsed.begin()+pos+1,browsed.end());\n\t\t\t\t\t\t\tbrowsed.push_back(page[now][i].name);\n\t\t\t\t\t\t\tpos++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(act==\"back\"){\n\t\t\t\tif(pos>0)pos--;\n\t\t\t}\n\t\t\telse if(act==\"forward\"){\n\t\t\t\tif(pos<browsed.size()-1) pos++;\n\t\t\t}\n\t\t\telse if(act==\"show\"){\n\t\t\t\tcout << browsed[pos] << \"\\n\";\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<list>\n#include<map>\n#include<set>\n#include<deque>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<algorithm>\n#include<functional>\n#include<numeric>\n#include<utility>\n#include<iostream>\n#include<sstream>\n#include<iomanip>\n#include<cstdio>\n#include<cmath>\n#include<cstdlib>\n#include<cctype>\n#include<string>\n#include<cstring>\n#include<cstdio>\n#include<cmath>\n#include<cstdlib>\n#include<ctime>\n#include<climits>\n#include<complex>\n#include<cassert>\n#define sz(x) (int)((x).size())\n#define rep(i,n) for (int i=0;i<n;i++)\n#define mp make_pair\n#define pb push_back\n#define all(x) x.begin(),x.end()\n#define clr(x) memset((x),0,sizeof(x))\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\ntypedef vector<pii> vpi;\nstruct button\n{\n\tstring name;\n\tint xa,ya,xb,yb;\n\tvoid input()\n\t{\n\t\tint k;\n\t\tcin>>xa>>ya>>xb>>yb>>name;\n\t}\n\tbool in(int x,int y)\n\t{\n\t\treturn xa<=x&&x<=xb&&ya<=y&&y<=yb;\n\t}\n};\nmap<string,int>id;\nstruct page \n{\n\tstring name;\n\tvector<button>b;\n\tvoid input(int t)\n\t{\n\t\tint k;\n\t\tcin>>name>>k;\n\t\tb.clear();\n\t\tid[name]=t;\n\t\twhile (k--)\n\t\t{\n\t\t\tbutton x;\n\t\t\tx.input();\n\t\t\tb.push_back(x);\n\t\t}\n\t}\n}a[111];\nvector<int>v;\nint main()\n{\n\tint i,j,k,n;\n\twhile (scanf(\"%d\",&n)!=EOF)\n\t{\n\t\tif (n==0)break;\n\t\tscanf(\"%*d%*d\");\t\n\t\tid.clear();\n\t\tfor (i=0;i<n;i++)a[i].input(i);\n\t\tint q;\n\t\tint now=0;\n\t\tv.clear();\n\t\tv.push_back(0);\n\t\tscanf(\"%d\",&q);\n\t\twhile (q--)\n\t\t{\n\t\t\tchar ss[33];\n\t\t\tscanf(\"%s\",ss);\n\t\t\tif (strcmp(ss,\"show\")==0)\n\t\t\t{\n\t\t\t\tcout<<a[v[now]].name<<endl;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (strcmp(ss,\"back\")==0)\n\t\t\t{\n\t\t\t\tif (!now)continue;\n\t\t\t\tnow--;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (strcmp(ss,\"forward\")==0)\n\t\t\t{\n\t\t\t\tif (now+1==v.size())continue;\n\t\t\t\tnow++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (strcmp(ss,\"click\")==0)\n\t\t\t{\n\t\t\t\tint x,y;\n\t\t\t\tscanf(\"%d%d\",&x,&y);\n\t\t\t\tint z=0;\n\t\t\t\tfor (i=0;i<a[v[now]].b.size();i++)\n\t\t\t\t{\n\t\t\t\t\tif (a[v[now]].b[i].in(x,y))\n\t\t\t\t\t{\n\t\t\t\t\t\tz++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (z>1)while (1);\n\t\t\t\tfor (i=0;i<a[v[now]].b.size();i++)\n\t\t\t\t{\n\t\t\t\t\tif (a[v[now]].b[i].in(x,y))\n\t\t\t\t\t{\n\t\t\t\t\t\tint next=id[a[v[now]].b[i].name];\n\t\t\t\t\t\tv.erase(v.begin()+1+now,v.end());\n\t\t\t\t\t\tv.push_back(next);\n\t\t\t\t\t\t//now=v.size()-1;\n\t\t\t\t\t\t++now;\n\t\t\t\t\t\tassert(now==v.size()-1);\n\t\t\t\t\t\t//break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n/*\n3\n800 600\nindex 2\n500 100 700 200 profile\n100 100 100 100 link\nprofile 2\n100 100 400 200 index\n100 400 400 500 link\nlink 1\n100 100 300 200 index\n99\nclick 600 150\nshow\n*/\n\t\t\t\n\t"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<map>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\nstruct POINT{\n  int x1, y1;\n  int x2, y2;\n};\n\nmap<string, POINT> MakeButton(int);\nvoid Click(map< string, map<string, POINT> >, vector<string>&, int&);\n\nint main(){\n  int i, j, n, m, w, h, now;\n  string str;\n  vector<string> logdata;\n  map< string, map<string, POINT> > webpage;\n\n  while(1){\n    cin >> n;\n    if(n == 0) break;\n    cin >> w >> h;\n\n    for(i=0; i<n; ++i){\n      cin >> str >> m;\n      if(i == 0) logdata.push_back(str);\n      webpage.insert(make_pair(str, MakeButton(m)));\n    }\n\n    cin >> m;\n    for(i=0, now=0; i<m; ++i){\n      cin >> str;\n      if(str == \"click\") Click(webpage, logdata, now);\n      else if(str == \"back\" && now > 0) --now;\n      else if(str == \"forward\" && now < logdata.size()-1) ++now;\n      else if(str == \"show\") cout << logdata[now] << endl;\n    }\n\n    logdata.clear();\n    webpage.clear();\n  }\n  return 0;\n}\n\nmap<string, POINT> MakeButton(int n){\n  int i, x1, y1, x2, y2;\n  string str;\n  POINT p;\n  map<string, POINT> button;\n\n  for(i=0; i<n; ++i){\n    cin >> p.x1 >> p.y1 >> p.x2 >> p.y2 >> str;\n    button.insert(make_pair(str, p));\n  }\n  return button;\n}\n\nvoid Click(map< string, map<string, POINT> > webpage,\n\t   vector<string>& logdata, int& now){\n  int x, y;\n  POINT p;\n  map<string, POINT> button;\n  map<string, POINT>::iterator i;\n  map< string, map<string, POINT> >::iterator j;\n\n  j = webpage.find(logdata[now]);\n  button = j->second;\n  cin >> x >> y;\n\n  for(i=button.begin(); i!=button.end(); ++i){\n    p = i->second;\n    if(p.x1 <= x && x <= p.x2 && p.y1 <= y && y <= p.y2){\n      ++now;\n      logdata.erase(logdata.begin()+now, logdata.end());\n      logdata.push_back(i->first);\n      return;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n\ntypedef struct page{\n  string name;\n  int b;\n  int x1[100],y1[100],x2[100],y2[100];\n  string link[100];\n}page;\n\nint main(){\n  int n,m;\n  int w,h;\n  page p[100];\n  string inst;\n  int x,y;\n  vector<int> buf;\n  int pos,next;\n\n  while(1){\n    cin >> n;\n    if(!n)break;\n    cin >> w >> h;\n\n    for(int i=0;i<n;i++){\n      cin >> p[i].name >> p[i].b;\n      for(int j=0;j<p[i].b;j++){\n\tcin >> p[i].x1[j] >> p[i].y1[j];\n\tcin >> p[i].x2[j] >> p[i].y2[j];\n\tcin >> p[i].link[j];\n      }\n    }\n\n    buf.clear();\n    buf.push_back(0);\n    pos = 0;\n\n    cin >> m;\n    for(int i=0;i<m;i++){\n      cin >> inst;\n      if(inst == \"show\")cout << p[buf[pos]].name << endl;\n      else if(inst == \"back\"){\n\tif(pos)pos--;\n      }else if(inst == \"forward\"){\n\tif(pos!=buf.size()-1)pos++;\n      }else{\n\tcin >> x >> y;\n\tnext = -1;\n\tfor(int j=0;j<p[buf[pos]].b;j++){\n\t  if(p[buf[pos]].x1[j] <= x && x <= p[buf[pos]].x2[j]){\n     \t    if(p[buf[pos]].y1[j] <= y && y <= p[buf[pos]].y2[j]){\n\t      for(int k=0;k<n;k++){\n\t\tif(p[buf[pos]].link[j] == p[k].name){\n\t\t  next = k;\n\t\t  break;\n\t\t}\n\t      }\n\t      break;\n\t    }\n\t  }\n\t}\n\tif(next >= 0){\n\t  pos++;\n\t  while(pos < buf.size())buf.pop_back();\n\t  buf.push_back(next);\n\t}\n      }\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<algorithm>\n#include<iostream>\n#include<vector>\n#include<climits>\n#include<cfloat>\n\nusing namespace std;\n\nstruct point{\n  double x, y;\n};\n\nstruct button{\n  point ld,ru;\n  string name;\n};\n\nstruct page{\n  string name;\n  vector<button>btn;   \n}; \n\nint main(void){\n  int n;\n  int w,h,b;\n  point l,r;\n  page in;\n  vector<page> a;\n  button tmp;\n\n  while(cin >> n,n){\n  \n    a.clear();\n\n    cin >> w >> h;\n    \n    for(int j=0;j<n;j++){\n      in.btn.clear();\n      cin >> in.name >> b;    \n      \n      for(int i=0;i<b;i++){\n\tcin >> tmp.ld.x >> tmp.ld.y >> tmp.ru.x >> tmp.ru.y >> tmp.name;\n\tin.btn.push_back(tmp);\n      }\n      a.push_back(in);\n    }\n\n    int m,now=0,fg=0;\n    static page buf[1000000];\n\n    cin >> m;\n    buf[0]=a[0];\n\n    for(int k=0;k<m;k++){\n      string s;\n      cin >> s;\n      \n      if(s==\"click\"){\n\tint c,d;\n\tcin >> c >> d;\n\t\n\tfor(int i=0;i<buf[now].btn.size();i++){\n\t  int fg2=0;\n\t  if(buf[now].btn[i].ld.x <=c &&\n\t     buf[now].btn[i].ld.y <=d &&\n\t     buf[now].btn[i].ru.x >=c &&\n\t     buf[now].btn[i].ru.y >=d){\n\t    for(int j=0;j<a.size();j++){\n\t      if(buf[now].btn[i].name==a[j].name){\n\t\tbuf[++now]=a[j];\n\t\tfg=0;\n\t\tfg2=1;\n\t\tbreak;\n\t      }\n\t    }\n\t    if(fg2)break;\n\t  }\n\t}\n      }\n      else if(s==\"back\" && now>0){\n\tnow--;\n\tfg++;\n      }\n      else if(s==\"forward\" && fg>0 && now < 1000000)now++,fg--;\n      else if(s==\"show\")cout << buf[now].name << endl;\n    }\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nclass Page\n{\npublic:\n    string name;\n    int button;\n    vector<int> sx, sy, ex, ey;\n    vector<string> link;\n};\n\nint main()\n{\n    for(;;){\n        int n, w, h, m;\n        cin >> n;\n        if(n == 0)\n            break;\n        cin >> w >> h;\n\n        vector<Page> page(n);\n        for(int i=0; i<n; ++i){\n            cin >> page[i].name >> page[i].button;\n            page[i].sx.resize(page[i].button);\n            page[i].sy.resize(page[i].button);\n            page[i].ex.resize(page[i].button);\n            page[i].ey.resize(page[i].button);\n            page[i].link.resize(page[i].button);\n            for(int j=0; j<page[i].button; ++j){\n                cin >> page[i].sx[j] >> page[i].sy[j];\n                cin >> page[i].ex[j] >> page[i].ey[j];\n                cin >> page[i].link[j];\n            }\n        }\n\n        cin >> m;\n        vector<int> history(1, 0);\n        int curr = 0;\n        for(int i=0; i<m; ++i){\n            string ope;\n            cin >> ope;\n            if(ope == \"click\"){\n                int x, y;\n                cin >> x >> y;\n                int k = history[curr];\n                string tmp;\n                for(int j=0; j<page[k].button; ++j){\n                    if(page[k].sx[j] <= x && x <= page[k].ex[j] && page[k].sy[j] <= y && y <= page[k].ey[j]){\n                        tmp = page[k].link[j];\n                        break;\n                    }\n                }\n                if(tmp == \"\")\n                    continue;\n                int j;\n                for(j=0; j<n; ++j){\n                    if(tmp == page[j].name)\n                        break;\n                }\n                history.resize(curr+1);\n                history.push_back(j);\n                ++ curr;\n            }else if(ope == \"back\"){\n                if(curr > 0)\n                    -- curr;\n            }else if(ope == \"forward\"){\n                if(curr < history.size() - 1)\n                    ++ curr;\n            }else{\n                cout << page[history[curr]].name << endl;\n            }\n        }\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <string>\n#include <vector>\n#include <iostream>\nusing namespace std;\nint N, W, H, Q, x, y, c[109], xa[109][109], ya[109][109], xb[109][109], yb[109][109]; string s[109], t[109][109], tp;\nint main() {\n\twhile (cin >> N, N) {\n\t\tcin >> W >> H;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tcin >> s[i] >> c[i];\n\t\t\tfor (int j = 0; j < c[i]; j++) {\n\t\t\t\tcin >> xa[i][j] >> ya[i][j] >> xb[i][j] >> yb[i][j] >> t[i][j];\n\t\t\t}\n\t\t}\n\t\tcin >> Q;\n\t\tvector<int> res; res.push_back(0);\n\t\tint pos = 0;\n\t\tfor (int i = 0; i < Q; i++) {\n\t\t\tcin >> tp;\n\t\t\tif (tp == \"click\") {\n\t\t\t\tcin >> x >> y;\n\t\t\t\tfor (int j = 0; j < c[res[pos]]; j++) {\n\t\t\t\t\tif (xa[res[pos]][j] <= x && x <= xb[res[pos]][j] && ya[res[pos]][j] <= y && y <= yb[res[pos]][j]) {\n\t\t\t\t\t\tint ptr = -1;\n\t\t\t\t\t\tfor (int k = 0; k < c[res[pos]]; k++) {\n\t\t\t\t\t\t\tif (s[k] == t[res[pos]][j]) ptr = k;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tres.resize(pos + 2);\n\t\t\t\t\t\tres[++pos] = ptr;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (tp == \"show\") cout << s[res[pos]] << endl;\n\t\t\tif (tp == \"forward\" && pos + 1 != res.size()) pos++;\n\t\t\tif (tp == \"back\" && pos != 0) pos--;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n#define MAX 500\n\nstruct Page{\n  int sx,sy,tx,ty;\n  string next;\n  Page(int sx,int sy,int tx,int ty,string next)\n    : sx(sx),sy(sy),tx(tx),ty(ty),next(next) {}\n};\n\nvector<Page> vec[MAX];\n\nvoid init(){\n  for(int i = 0 ; i < MAX ; i++){\n    vec[i].clear();\n  }\n}\n\nint main(){\n  int N,W,H,b,sx,sy,tx,ty,p = 0;\n  string str[MAX],s;\n\n  while(cin >> N,N){\n    cin >> W >> H;\n    init();\n    for(int i = 0 ; i < N ; i++){\n      cin >> str[i] >> b;\n      for(int j = 0 ; j < b ; j++){\n        cin >> sx >> sy >> tx >> ty >> s;\n        vec[i].push_back(Page(sx,sy,tx,ty,s));\n      }\n    }\n    int m,w,h,now = 0;\n    vector<int> now_page;\n    now_page.push_back(now);\n    string next;\n    cin >> m;\n    for(int I = 0 ; I < m ; I++){\n      cin >> s;\n      if(s == \"click\"){\n        bool found = false;\n        cin >> w >> h;\n        for(int i = 0 ; i < vec[now_page[p]].size() ; i++){\n          sx = vec[now][i].sx, sy = vec[now][i].sy;\n          tx = vec[now][i].tx, ty = vec[now][i].ty;\n          next = vec[now][i].next;\n          if(sx <= w && w <= tx && sy <= h && h <= ty){\n            for(int j = 0 ; j < N ; j++){\n              if(str[j] == next){\n                now = j;\n                found = true;\n                break;\n              }\n            }\n          }\n          if(found){\n            p++;\n            while(p < now_page.size()){\n              now_page.pop_back();\n            }\n            now_page.push_back(now);\n            break;\n          }\n        }\n      }else if(s == \"show\"){\n        cout << str[now_page[p]] << endl;\n      }else if(s == \"back\"){\n        if(p > 0) p--;\n      }else{\n        if(p+1 < now_page.size()) p++;\n      }\n    }\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n#define MAX 100\n\nstruct Page{\n  int sx,sy,tx,ty;\n  string next;\n  Page(int sx,int sy,int tx,int ty,string next)\n    : sx(sx),sy(sy),tx(tx),ty(ty),next(next) {}\n};\n\nint main(){\n  int N,W,H,b,sx,sy,tx,ty,p = 0;\n  string str[MAX],s;\n\n  while(cin >> N,N){\n    cin >> W >> H;\n    vector<Page> vec[MAX];\n    for(int i = 0 ; i < N ; i++){\n      cin >> str[i] >> b;\n      for(int j = 0 ; j < b ; j++){\n        cin >> sx >> sy >> tx >> ty >> s;\n        vec[i].push_back(Page(sx,sy,tx,ty,s));\n      }\n    }\n    int m,w,h,now = 0;\n    vector<int> now_page;\n    now_page.push_back(now);\n    string next;\n    cin >> m;\n    for(int I = 0 ; I < m ; I++){\n      int size = now_page.size();\n      if(now_page[size-1] != now){\n        now_page.push_back(now);\n        p++;\n        size = now_page.size();\n      }\n      cin >> s;\n      if(s == \"click\"){\n        bool found = false;\n        cin >> w >> h;\n        for(int i = 0 ; i < (int)vec[now].size() ; i++){\n          sx = vec[now][i].sx, sy = vec[now][i].sy;\n          tx = vec[now][i].tx, ty = vec[now][i].ty;\n          next = vec[now][i].next;\n          if(sx <= w && w <= tx && sy <= h && h <= ty){\n            for(int j = 0 ; j < N ; j++){\n              if(str[j] == next){\n                now = j;\n                found = true;\n                break;\n              }\n            }\n          }\n          if(found) break;\n        }\n      }else if(s == \"show\"){\n        cout << str[now_page[p]] << endl;\n      }else if(s == \"back\"){\n        if(p > 0) p--;\n      }else{\n        if(p+1 < size) p++;\n      }\n    }\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// AOJ1054 Distorted Love\n\n#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n\nusing namespace std;\n\nclass button{\npublic:\n\tint x1, y1, x2, y2; string name;\n\tbutton(int x1, int y1, int x2, int y2, string name) : x1(x1), y1(y1), x2(x2), y2(y2), name(name) {}\n\tbool in(int x, int y) { return x1 <= x && x <= x2 && y1 <= y && y <= y2; }\n};\n\nint main(){\n\tint n;\n\tint buf[101];\n\twhile(cin >> n, n){\n\t\tint x, y; cin >> x >> y;\n\t\tbuf[0] = 0; \n\t\tint size = 0;\n\t\tint cur = 0;\n\t\tstring s;\n\t\tvector<string> vs(n);\n\t\tmap<string, int> mp;\n\t\tvector< vector<button> > vv(n, vector<button>());\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin >> s;\n\t\t\tvs[i] = s;\n\t\t\tmp[s] = i;\n\t\t\tint t; cin >> t;\n\t\t\tfor(int j=0;j<t;j++){\n\t\t\t\tint x1, y1, x2, y2; cin >> x1 >> y1 >> x2 >> y2 >> s;\n\t\t\t\tvv[i].push_back(button(x1, y1, x2, y2, s));\n\t\t\t}\n\t\t}\n\t\tcin >> n;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin >> s;\n\t\t\tif(s==\"show\") cout << vs[buf[cur]] << endl;\n\t\t\tif(s==\"forward\"){\n\t\t\t\tif(cur != size) cur++;\n\t\t\t}\n\t\t\tif(s==\"back\"){\n\t\t\t\tif(cur != 0) cur--;\n\t\t\t}\n\t\t\tif(s==\"click\"){\n\t\t\t\tint x, y; cin >> x >> y;\n\t\t\t\tfor(int j=0;j<vv[buf[cur]].size();j++){\n\t\t\t\t\tif(vv[buf[cur]][j].in(x,y)){\n\t\t\t\t\t\tcur++;\n\t\t\t\t\t\tsize = cur;\n\t\t\t\t\t\tbuf[cur] = mp[vv[buf[cur-1]][j].name];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twhile(true) ;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\nconst int MAX = 100;\n\nstring data[MAX];\nint W,H,N;\n\nstruct Button{\n  int lx,rx,ly,ry;\n  string name;\n};\n\nmap<string,vector<Button> > M;\n\n\nvoid init(){\n  M.clear();\n  fill(data,data+MAX,\"\");\n}\n\nvoid input(){\n  cin >> W >> H;\n  for(int i = 0; i < N; i++){\n    string s;\n    int num;\n    cin >> s >> num;\n    if(i == 0) data[0] = s;\n\n    for(int j = 0; j < num; j++){\n      Button B;\n      cin >> B.lx >> B.ly >> B.rx >> B.ry >> B.name;\n      M[s].push_back(B);\t\n    }\n\n  }\n}\n\nvoid solve(){\n  int num;\n  cin >> num;\n  int index = 0;\n\n\n  while(num--){\n    string op;\n    cin >> op;\n    if(op == \"click\"){\n      int x,y;\n      cin >> x >> y;\n      string now = data[index];\n\n      for(int i = 0; i < M[now].size(); i++){\n\tif(M[now][i].lx <= x && x <= M[now][i].rx && M[now][i].ly <= y && y <= M[now][i].ry){\n\t  data[++index] = M[now][i].name;\n\t  break;\n\t}\n\n      }\n\n    }else if(op == \"back\") index--;\n    else if(op == \"forward\") index++;\n    else if(op == \"show\") cout << data[index] << endl;\n  }\n}\n\nint main(){\n\n  while(cin >> N && N){\n    input();\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <vector>\n#include <string>\n#include <map>\n#include <algorithm>\nusing namespace std;\nstruct node{\n\tint x1,y1,x2,y2;\n\tint k;\n\tnode(int X1,int Y1,int X2,int Y2,int K){\n\t\tx1=X1;\n\t\tx2=X2;\n\t\ty1=Y1;\n\t\ty2=Y2;\n\t\tk=K;\n\t}\n};\nvector<node> adj[1000];\nchar str[1990];\nint pd(int x,int y,int k){\n\tfor(int i=0;i<adj[k].size();i++){\n\t\tnode t = adj[k][i];\n\t\tif(t.x1<=x && t.x2>=x && t.y1<=y && t.y2>=y)return t.k;\n\t}\n\treturn -1;\n}\nint q[100000];\nstring name[1000];\nint main() {\n\tint n;\n\twhile(scanf(\"%d\",&n),n){\n\t\tfor(int i=0;i<n;i++)adj[i].clear();\n\t\tint x,y;\n\t\tmap<string,int> hash;\n\t\tint tot=0;\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint k;\n\t\t\tscanf(\"%s%d\",str,&k);\n\t\t\tif(hash.count(str)==0){\n\t\t\t\tname[tot]=str;\n\t\t\t\thash[str]=tot++;\n\t\t\t}\n\t\t\tint u=hash[str];\n\t\t\twhile(k--){\n\t\t\t\tint x1,y1,x2,y2;\n\t\t\t\tint v;\n\t\t\t\tscanf(\"%d%d%d%d%s\",&x1,&y1,&x2,&y2,str);\n\t\t\t\tif(hash.count(str)==0){\n\t\t\t\t\tname[tot]=str;\n\t\t\t\t\thash[str]=tot++;\n\t\t\t\t}\n\t\t\t\tv=hash[str];\n\t\t\t\tadj[u].push_back(node(x1,y1,x2,y2,v));\n\t\t\t}\n\t\t}\n\t\tint m;\n\t\tscanf(\"%d\",&m);\n\t\tint l=1;\n\t\tint cur=0;\n\t\tq[0]=0;\n\t\twhile(m--){\n\t\t\tscanf(\"%s\",str);\n\t\t\tif(str[0]=='c'){\n\t\t\t\tint x,y;\n\t\t\t\tscanf(\"%d%d\",&x,&y);\n\t\t\t\tint t = pd(x,y,cur);\n\t\t\t\tif(t!=-1){\n\t\t\t\t\tq[++cur]=t;\n\t\t\t\t\tl=cur+1;\n\t\t\t\t}\n\t\t\t}else if(str[0]=='s'){\n\t\t\t\tprintf(\"%s\\n\",name[q[cur]].c_str());\n\t\t\t}else if(str[0]=='b'){\n\t\t\t\tif(cur!=0)cur--;\n\t\t\t}else if(str[0]=='f'){\n\t\t\t\tif(cur+1!=l)cur++;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <iomanip>\n#include <complex>\n#include <string>\n#include <vector>\n#include <list>\n#include <deque>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <bitset>\n#include <functional>\n#include <utility>\n#include <algorithm>\n#include <numeric>\n#include <typeinfo>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <ctime>\n\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<\"=\"<<(n)<<endl\n#define debug(n) cout<<__FILE__<<\",\"<<__LINE__<<\": #\"<<#n<<\"=\"<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,n) repi(i,0,n)\n#define iter(c) __typeof((c).begin())\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();i++)\n#define allof(c) (c).begin(),(c).end()\n#define mp make_pair\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\nstruct Button{\n\tstring name;\n\tint x1,y1,x2,y2;\n\tButton(){}\n\tButton(string name,int x1,int y1,int x2,int y2):name(name),x1(x1),y1(y1),x2(x2),y2(y2){}\n};\n\nstruct Page{\n\tstring name;\n\tvector<Button> buttons;\n\tPage(){}\n\tPage(string name):name(name){}\n};\n\nbool input(vector<Page>& pages,vs& cmds)\n{\n\tint n;\n\tcin>>n;\n\tif(!n)\n\t\treturn false;\n\t\n\tpages.resize(n);\n\tint h,w;\n\tcin>>h>>w;\n\trep(i,n){\n\t\tstring name;\n\t\tcin>>pages[i].name;\n\t\tint b;\n\t\tcin>>b;\n\t\trep(j,b){\n\t\t\tint x1,y1,x2,y2;\n\t\t\tstring name;\n\t\t\tcin>>x1>>y1>>x2>>y2>>name;\n\t\t\tpages[i].buttons.push_back(Button(name,x1,y1,x2,y2));\n\t\t}\n\t}\n\tint m;\n\tcin>>m;\n\tcmds.resize(m);\n\tcin.get();\n\trep(i,m)\n\t\tgetline(cin,cmds[i]);\n\t\n\treturn true;\n}\n\nbool clicked(const Button& b,int x,int y)\n{\n\t//printf(\"%d %d %d %d (%d,%d)\\n\",b.x1,b.y1,b.x2,b.y2,x,y);\n\t//dump(b.x1<=x && x<=b.x2 && b.y1<=y && y<=b.y2);\n\treturn b.x1<=x && x<=b.x2 && b.y1<=y && y<=b.y2;\n}\n\nvoid solve(vector<Page>& pages,vs& cmds)\n{\n\tmap<string,int> nameToId;\n\trep(i,pages.size())\n\t\tnameToId[pages[i].name]=i;\n\t\n\tvi buffer(1,0);\n\tint pos=0;\n\trep(i,cmds.size()){\n\t\tif(cmds[i].substr(0,4)==\"show\")\n\t\t\t//dump(pages[buffer[pos]].name);\n\t\t\tcout<<pages[buffer[pos]].name<<endl;\n\t\tif(cmds[i].substr(0,4)==\"back\")\n\t\t\tpos=max(pos-1,0);\n\t\tif(cmds[i].substr(0,7)==\"forward\")\n\t\t\tpos=min(pos+1,(int)buffer.size()-1);\n\t\tif(cmds[i].substr(0,5)==\"click\"){\n\t\t\tbuffer.resize(pos+1);\n\t\t\tistringstream iss(cmds[i].substr(5));\n\t\t\tint x,y;\n\t\t\tiss>>x>>y;\n\t\t\tPage& page=pages[buffer[pos]];\n\t\t\trep(j,page.buttons.size()){\n\t\t\t\tif(clicked(page.buttons[j],x,y)){\n\t\t\t\t\tbuffer.push_back(nameToId[page.buttons[j].name]);\n\t\t\t\t\tpos++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//dump(pos);\n\t}\n}\n\nint main()\n{\n\tfor(;;){\n\t\tvector<Page> pages;\n\t\tvs cmds;\n\t\tif(!input(pages,cmds))\n\t\t\tbreak;\n\t\tsolve(pages,cmds);\n\t\t//puts(\"--\");\n\t\t//rep(i,pages.size()){\n\t\t//\tdump(pages[i].name);\n\t\t//\trep(j,pages[i].buttons.size()){\n\t\t//\t\tButton& b=pages[i].buttons[j];\n\t\t//\t\tprintf(\"%s %d %d %d %d\\n\",b.name.c_str(),b.x,b.y,b.w,b.h);\n\t\t//\t}\n\t\t//}\n\t\t//rep(i,cmds.size())\n\t\t//\tdump(cmds[i]);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<algorithm>\n#include<iostream>\n#include<vector>\n#include<climits>\n#include<cfloat>\n\nusing namespace std;\n\ndouble EPS = 1e-10;\n\ndouble add(double a, double b){\n  if(abs(a+b) < EPS * (abs(a)+abs(b)))return 0;\n  return a+b;\n}\n\nstruct point{\n  double x, y;\n  point(){}\n  point(double x,double y) : x(x) , y(y){}\n\n  point operator + (point p){\n    return point(add(x,p.x), add(y,p.y));\n  }\n\n  point operator - (point p){\n    return point(add(x,-p.x), add(y,-p.y));\n  }\n\n  point operator * (double d){\n    return point(x*d,y*d);\n  }\n\n  point operator / (double d){\n    return point(x/d,y/d);\n  }\n  \n  bool operator == ( const point &p ) const {\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n};\n\nstruct button{\n  point ld,ru;\n  string name;\n};\n\nstruct page{\n  string name;\n  vector<button>btn;   \n};\n\nint main(void){\n  int n;\n  int w,h,b;\n  point l,r;\n  page in;\n  vector<page> a;\n  button tmp;\n\n  while(cin >> n,n){\n  \n    a.clear();\n\n    cin >> w >> h;\n    \n    for(int j=0;j<n;j++){\n      cin >> in.name >> b;    \n      \n      for(int i=0;i<b;i++){\n\tcin >> tmp.ld.x >> tmp.ld.y >> tmp.ru.x >> tmp.ru.y >> tmp.name;\n\tin.btn.push_back(tmp);\n      }\n      a.push_back(in);\n    }\n\n    int m,now=0;\n    cin >> m;\n\n    while(m--){\n      string s;\n      cin >> s;\n      if(s==\"click\"){\n\tint c,d;\n\tcin >> c >> d;\n\t\n\tfor(int i=0;i<a[now].btn.size();i++){\n\t  if(a[now].btn[i].ld.x <=c &&\n\t     a[now].btn[i].ld.y <=d &&\n\t     a[now].btn[i].ru.x >=c &&\n\t     a[now].btn[i].ru.y >=d){\n\t    for(int j=0;j<a.size();j++)\n\t      if(a[now].btn[i].name==a[j].name)now=j;\n\t  }\n\t}\n      }\n      else if(s==\"back\")now--;\n      else if(s==\"forward\")now++;\n      else if(s==\"show\")cout << a[now].name << endl;\n    }\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <deque>\n#include <map>\nusing namespace std;\ntypedef struct{int sx, sy, ex, ey; string to;} LINK;\ntypedef struct{string name; int n; LINK btn[100];} PAGE;\nint main()\n{\n\tint n, o, W, H;\n\tint i, j, x, y, cur, t, m;\n\tstring op;\n\tPAGE pg[100];\n\tLINK tmp;\n\tmap<string, int> tbl;\n\twhile (cin >> n, n)\n\t{\n\t\tdeque<string> his;\n\t\tcin >> W >> H;\n\t\tfor (i = 0; i < n; i++)\n\t\t{\n\t\t\tcin >> pg[i].name >> pg[i].n;\n\t\t\ttbl.insert( map<string, int>::value_type(pg[i].name, i) );\n\t\t\tfor (j = 0; j < pg[i].n; j++)\n\t\t\t{\n\t\t\t\tcin >> tmp.sx >> tmp.sy >> tmp.ex >> tmp.ey >> tmp.to;\n\t\t\t\tpg[i].btn[j] = tmp;\n\t\t\t}\n\t\t}\n\t\tcin >> o;\n\t\this.push_back(pg[0].name);\n\t\tcur = 0;\n\t\tm = 1;\n\t\tfor (i = 0; i < o; i++)\n\t\t{\n\t\t\tcin >> op;\n\t\t\tif (op == \"click\")\n\t\t\t{\n\t\t\t\tcin >> x >> y;\n\t\t\t\tt = tbl[his.at(cur)];\n\t\t\t\tfor (j = 0; j < pg[t].n; j++)\n\t\t\t\t{\n\t\t\t\t\tif (pg[t].btn[j].sx <= x && x <= pg[t].btn[j].ex && pg[t].btn[j].sy <= y && y <= pg[t].btn[j].ey)\n\t\t\t\t\t{\n\t\t\t\t\t\this.push_back(pg[t].btn[j].to);\n\t\t\t\t\t\tcur++;\n\t\t\t\t\t\tm++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tt = m;\n\t\t\t\tfor (j = cur+1; j < t; j++)\n\t\t\t\t{\n\t\t\t\t\this.pop_back();\n\t\t\t\t\tm--;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (op == \"back\")\n\t\t\t{\n\t\t\t\tif (cur > 0)\n\t\t\t\t\tcur--;\n\t\t\t}\n\t\t\telse if (op == \"forward\")\n\t\t\t{\n\t\t\t\tif (cur < m)\n\t\t\t\t\tcur++;\n\t\t\t}\n\t\t\telse if (op == \"show\")\n\t\t\t{\n\t\t\t\tcout << his.at(cur) << endl;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <set>\n \nusing namespace std;\n \n#define f first\n#define s second\n \ntypedef pair<int, int> P;\ntypedef pair<P, P> P2;\ntypedef pair<P2, string> P3;\n \nint main(){\n  int n;\n  int W, H;\n   \n  while(cin >> n, n){\n    cin >> W >> H;\n    \n    map<string, int> n_link;\n    map<string, vector<P3> > page;\n    vector<P3> link;\n    string page_name;\n    string now;\n    int n_button;\n     \n    for(int i = 0 ; i < n ; i++){\n      cin >> page_name >> n_button;\n      n_link.insert(make_pair(page_name, n_button));\n      if(i == 0) now = page_name;\n      for(int j = 0 ; j < n_button ; j++){\n\tP3 tmp;\n\tcin >> tmp.f.f.f >> tmp.f.f.s >> tmp.f.s.f >> tmp.f.s.s >> tmp.s;\n\tlink.push_back(tmp);\n      }\n      page.insert(make_pair(page_name, link));\n      link.clear();\n    }\n     \n    //cout << page[\"profile\"][1].s << endl;\n\n    int n_op, x, y;\n    string op;\n    vector<string> history;\n    history.push_back(now);\n    int n_now = 0;\n    cin >> n_op;\n    cin.ignore();\n    while(n_op--){\n      getline(cin, op);\n       \n      if(op[0] == 'c'){ // click\n\tstring tmp1=\"\", tmp2=\"\";\n\tint i;\n\tfor(i = 6 ; op[i] != ' ' ; i++) tmp1 += op[i];\n\tfor( ; i < op.size() ; i++) tmp2 += op[i];\n     \n\tx = atoi(tmp1.c_str());\n\ty = atoi(tmp2.c_str());\n     \n\t//for(i = 0 ; i < page[now].size() ; i++){\n\tfor(i = page[now].size() - n_link[now] ; i < page[now].size() ; i++){\n\t  if((page[now][i].f.f.f <= x && x <= page[now][i].f.s.f) &&\n\t     (page[now][i].f.f.s <= y && y <= page[now][i].f.s.s)){\n\t    now = page[now][i].s;\n\t    \n\t    for(i = history.size()-1 ; i > n_now ; i--){ // when back click\n\t      history[i].erase();\n\t    }\n\t    n_now = i;\n\t    history.push_back(now);\n\t    n_now++;\n\t  }\n\t}\n      } // click end\n      \n      if(op == \"show\") cout << history[n_now] << endl;\n      if(op == \"back\"){\n\tif(n_now == 0) continue;\n\tn_now--;\n      }\n      if(op == \"forward\"){\n\tif(n_now == history.size()-1) continue;\n\tn_now++;\n      }\n    }\n    page.clear();\n    history.clear();\n    link.clear();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstring>\nusing namespace std;\nstatic const double EPS = 1e-5;\ntypedef long long ll;\n\ntypedef struct _button{\n\tint xl,yu,xr,yl;\n\tstring name;\n}button;\n\n\nmap<string, vector<button> > page;\nvector<string> rireki;\n\n\nmain(){\n\tint n;\n\twhile(cin>>n){\n\t\tif(n==0)break;\n\t\t\n\t\tpage.clear();\n\t\trireki.clear();\n\t\t\n\t\tint W,H;\n\t\tcin>>W>>H;\n\t\t\n\t\tfor(int i=0;i<n;i++){\n\t\t\tstring name;\n\t\t\tint b;\n\t\t\tcin>>name>>b;\n\t\t\tif(i==0)rireki.push_back(name);\n\t\t\tfor(int j=0;j<b;j++){\n\t\t\t\tint xl,xr,yu,yl;\n\t\t\t\tstring tname;\n\t\t\t\tcin>>xl>>yu>>xr>>yl>>tname;\n\t\t\t\tbutton tbutton={xl,yu,xr,yl,tname};\n\t\t\t\t\n\t\t\t\tpage[name].push_back(tbutton);\n\t\t\t}\n\t\t}\n\t\t\n\t\tint m;\n\t\tcin>>m;\n\t\tint p=0;\n\t\t\n\t\tfor(int i=0;i<m;i++){\n\t\t\tstring com;\n\t\t\tcin>>com;\n\t\t\tif(com==\"click\"){\n\t\t\t\t\n\t\t\t\tint x,y;\n\t\t\t\tcin>>x>>y;\n\t\t\t\t\n\t\t\t\tstring target=\"\";\n\t\t\t\t\n\t\t\t\tfor(vector<button>::iterator vp=page[rireki[p]].begin();vp!=page[rireki[p]].end();++vp){\n\t\t\t\t\tif(vp->xr>=x && vp->xl<=x && vp->yu<=y && vp->yl>=y)target=vp->name;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(target==\"\")continue;\n\t\t\t\t\n\t\t\t\tif(p==rireki.size()-1){\n\t\t\t\t\trireki.push_back(target);\n\t\t\t\t\t++p;\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t}else{\n\t\t\t\t\t++p;\n\t\t\t\t\trireki[p]=target;\n\t\t\t\t\twhile(p+1<rireki.size())rireki.pop_back();\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\n\t\t\t}else if(com==\"show\"){\n\t\t\t\tcout<<rireki[p]<<endl;\n\t\t\t}else if(com==\"back\"){\n\t\t\t\tif(p)--p;\n\t\t\t}else if(com==\"forward\"){\n\t\t\t\tif(p<rireki.size()-1)++p;\n\t\t\t}\n\t\t}\n\t\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <iostream>\n#include <algorithm>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <utility>\n#include <cctype>\n#include <cassert>\nusing namespace std;\n\n#define rep(i,n) for(int (i)=0; (i)<(int)(n); ++(i))\n#define foreach(c,i) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n\nstruct Button {\n  int lx, ly, rx, ry, to;\n  bool Check(int cx, int cy) {\n    return (lx <= cx) && (cx <= rx) && (ly <= cy) && (cy <= ry);\n  }\n};\n\nint N, W, H, Q;\nvector<int> B(102);\nvector<string> vs(102);\nvector<Button> vbs[102];\n\nint main() {\n  while (cin >> N, N) {\n    cin >> W >> H;\n\n    vector<vector<string> > links(N, vector<string>());\n    map<string,int> maps;\n    string temp;\n    int lx, ly, rx, ry;\n    \n    rep(i,N) {\n      cin >> vs[i] >> B[i];\n      maps.insert(make_pair(vs[i], i));\n      vbs[i].clear();\n      rep(j,B[i]) {\n        cin >> lx >> ly >> rx >> ry >> temp;\n        vbs[i].push_back((Button){lx, ly, rx, ry, -1});\n        links[i].push_back(temp);\n      }\n    }\n\n    rep(i,N) {\n      rep(j,links[i].size()) {\n        vbs[i][j].to = maps[ links[i][j] ];\n      }\n    }\n\n    cin >> Q;\n    string query;\n    int cx, cy;\n    vector<string> buffer(1, vs[0]);\n    vector<string>::iterator itr;\n    int ptr = 0;\n    \n    rep(q,Q) {\n      cin >> query;\n      if (query == \"click\") {\n        cin >> cx >> cy;\n        int cur = maps[ buffer[ptr] ];\n        rep(i,B[cur]) {\n          if (vbs[cur][i].Check(cx, cy)) {\n            if (ptr != buffer.size()-1) {\n              itr = buffer.begin();\n              advance(itr, ptr+1);\n              buffer.erase(itr, buffer.end());\n            }\n            buffer.push_back(vs[ vbs[cur][i].to ]);\n            ++ptr;            \n            // printf(\"clicked success to %s. current is %s:%d\\n\",\n            //        vs[ vbs[cur][i].to ].c_str(),\n            //        buffer[ptr].c_str(),\n            //        ptr);\n            break;\n          }\n        }\n      } else if(query == \"show\") {\n        cout << buffer[ptr] << endl;\n      } else if(query == \"back\") {\n        if (ptr > 0) --ptr;\n      } else if(query == \"forward\") {\n        if (buffer.size() - 1 >= ptr + 1) ++ptr;\n      } else {\n        puts(query.c_str());\n        assert(false);\n      }\n      // printf(\"state %3d:\", q);\n      // rep(i,buffer.size()) printf(\"[%s]\",buffer[i].c_str()); puts(\"\\n\");\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<string>\n#include<vector>\n#include<map>\nusing namespace std;\nchar in[110];\nvector<int>x1[110];\nvector<int>y1[110];\nvector<int>x2[110];\nvector<int>y2[110];\nvector<string>na[110];\nstring name[110];\nint buf[110];\nint main(){\n\tint a;\n\twhile(scanf(\"%d\",&a),a){\n\t\tint h,w;scanf(\"%d%d\",&h,&w);\n\t\tfor(int i=0;i<110;i++){\n\t\t\tx1[i].clear();\n\t\t\tx2[i].clear();\n\t\t\ty1[i].clear();\n\t\t\ty2[i].clear();\n\t\t\tna[i].clear();\n\t\t}\n\t\tfor(int i=0;i<a;i++){\n\t\t\tint c;scanf(\"%s%d\",in,&c);\n\t\t\tname[i]=in;\n\t\t\tfor(int j=0;j<c;j++){\n\t\t\t\tint p,q,r,s;\n\t\t\t\tscanf(\"%d%d%d%d%s\",&p,&q,&r,&s,in);\n\t\t\t\tstring tmp=in;\n\t\t\t\tx1[i].push_back(p);x2[i].push_back(r);\n\t\t\t\ty1[i].push_back(q);y2[i].push_back(s);\n\t\t\t\tna[i].push_back(tmp);\n\t\t\t}\n\t\t}\n\t\tint at=0;\n\t\tfor(int i=0;i<110;i++)buf[i]=-1;\n\t\tbuf[0]=0;\n\t\tint b;scanf(\"%d\",&b);\n\t\twhile(b--){\n\t\t\tscanf(\"%s\",in);\n\t\t\tif(in[0]=='s'){\n\t\t\t\tprintf(\"%s\\n\",name[buf[at]].c_str());\n\t\t\t}\n\t\t\tif(in[0]=='b'){\n\t\t\t\tat=max(0,at-1);\n\t\t\t}\n\t\t\tif(in[0]=='f'){\n\t\t\t\tif(~buf[at+1])at++;\n\t\t\t}\n\t\t\tif(in[0]=='c'){\n\t\t\t\tint to=-1;\n\t\t\t\tint x,y;scanf(\"%d%d\",&x,&y);\n\t\t\t\tfor(int i=0;i<x1[buf[at]].size();i++){\n\t\t\t\t\tif(x1[buf[at]][i]<=x&&x<=x2[buf[at]][i]&&y1[buf[at]][i]<=y&&y<=y2[buf[at]][i]){\n\t\t\t\t\t\tfor(int j=0;j<a;j++)if(na[buf[at]][i]==name[j])to=j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(~to){\n\t\t\t\t\tbuf[++at]=to;\n\t\t\t\t\tfor(int i=at+1;i<110;i++)buf[i]=-1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <complex>\n#include <cstdio>\n#include <map>\n#include <math.h>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<n;i++)\n\nint n,W,H,a[100001],c,po,m;\nstruct page{\n\tint b,x1[100],y1[100],x2[100],y2[100];\n\tstring name,link[100];\n};\n\nint main(){\n\twhile(cin>>n&&n){\n\t\tfill(a,a+100001,-1);\n\t\ta[0]=0;c=0;po=0;\n\t\tcin>>W>>H;\n\t\tpage p[100];\n\t\trep(i,n){\n\t\t\tcin>>p[i].name>>p[i].b;\n\t\t\trep(j,p[i].b)cin>>p[i].x1[j]>>p[i].y1[j]>>p[i].x2[j]>>p[i].y2[j]>>p[i].link[j];\n\t\t}\n\t\tcin>>m;\n\t\trep(i,m){\n\t\t\tstring s;\n\t\t\tcin>>s;\n\t\t\tif(s==\"click\"){\n\t\t\t\tint x,y;\n\t\t\t\tcin>>x>>y;\n\t\t\t\trep(j,p[c].b)if(p[c].x1[j]<=x&&x<=p[c].x2[j]&&p[c].y1[j]<=y&&y<=p[c].y2[j]){\n\t\t\t\t\tstring st=p[c].link[j];\n\t\t\t\t\trep(k,n)if(st==p[k].name)c=(a[++po]=k);\n\t\t\t\t\tfill(a+po+1,a+100001,-1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(s==\"back\"&&po)c=a[--po];\n\t\t\tif(s==\"forward\"&&a[po+1]!=-1)c=a[++po];\n\t\t\tif(s==\"show\")cout<<p[c].name<<endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <utility>\n#include <map>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nclass Nx{\n\tpublic:\n\tP p, q;\n\tstring name;\n\tNx() {}\n\tNx(string _name, P _p, P _q): name(_name), p(_p), q(_q) {}\n\t\n\tbool comp(int x, int y){\n\t\treturn (p.first <= x && x <= q.first && p.second <= y && y <= q.second);\n\t}\n};\n\nclass St{\n\tpublic:\n\tstring name;\n\tvector<Nx> vec;\n\tSt() {}\n\tSt(string _name): name(_name) {}\n\t\n\tstring check(int x, int y){\n\t\tstring str = \"\";\n\t\tfor(int i = 0; i < vec.size(); i++){\n\t\t\tif(vec[i].comp(x, y)){\n\t\t\t\tstr = vec[i].name;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn str;\n\t}\n};\n\nint main()\n{\n\tint n, m, w, h, s, t, u, v, a[1000];\n\tstring str;\n\t\n\twhile(cin>>n && n){\n\t\tvector<St> vec;\n\t\tmap<string,int> mpp;\n\t\tcin >> w >> h;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tcin >> str >> m;\n\t\t\tmpp[str] = i;\n\t\t\tvec.push_back(St(str));\n\t\t\twhile(m--){\n\t\t\t\tcin >> s >> t >> u >> v >> str;\n\t\t\t\tvec[i].vec.push_back(Nx(str, P(s, t), P(u, v)));\n\t\t\t}\n\t\t}\n\t\tcin >> n;\n\t\tt = 0;\n\t\tfill(a, a+1000, -1);\n\t\ta[0] = 0;\n\t\twhile(n--){\n\t\t\tcin >> str;\n\t\t\tif(str == \"click\"){\n\t\t\t\tcin >> u >> v;\n\t\t\t\tstring tmp = vec[t].check(u, v);\n\t\t\t\tif(tmp.size() > 0){\n\t\t\t\t\tt++;\n\t\t\t\t\tfill(a+t, a+1000, -1);\n\t\t\t\t\ta[t] = mpp[tmp];\n\t\t\t\t}\n\t\t\t} else if(str == \"show\"){\n\t\t\t\tcout << vec[a[t]].name << endl;\n\t\t\t} else if(str == \"back\"){\n\t\t\t\tif(t > 0){\n\t\t\t\t\tt--;\n\t\t\t\t}\n\t\t\t} else if(str == \"forward\"){\n\t\t\t\tif(a[t+1] != -1){\n\t\t\t\t\tt++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<iomanip>\n#include<string>\n#include<vector>\nusing namespace std;\nstruct wy\n{\n\tlong long x1,y1,x2,y2;\n\tstring nextname;\n\tstring name;\n\tstring back;\n\tstring forward;\n};\nvector<wy> a[101];\nint main()\n{\n\tint n;\n\twhile(cin>>n)\n\t{\n\t\tif(n==0)\n\t\t\tbreak;\n\t\tlong long w,h;\n\t\tcin>>w>>h;\n\t\tint i=0;\n\t\tstring s;\n\t\tfor(;i<n;i++)\n\t\t{\n\t\t\tcin>>s;\n\t\t\tint cs;\n\t\t\tcin>>cs;\n\t\t\tlong long x1,y1,x2,y2;\n\t\t\tstring name;\n\t\t\tfor(int j=0;j<cs;j++)\n\t\t\t{\n\t\t\t\tcin>>x1>>y1>>x2>>y2>>name;\n\t\t\t\twy ww;\n\t\t\t\tww.x1=x1;\n\t\t\t\tww.y1=y1;\n\t\t\t\tww.x2=x2;\n\t\t\t\tww.y2=y2;\n\t\t\t\tww.nextname=name;\n\t\t\t\tww.name=s;\n\t\t\t\ta[i].push_back(ww);\n\t\t\t}\n\t\t}\n\t\tint m;\n\t\tint sz=0;\n\t\tcin>>m;\n\t\tstring nn;\n\t\twhile(m--)\n\t\t{\n\t\t\tcin>>nn;\n\t\t\tif(nn==\"show\")\n\t\t\t\tcout<<a[sz][0].name<<endl;\n\t\t\telse if(nn==\"click\")\n\t\t\t\t{\n\t\t\t\t\tint xxx,yyy;\n\t\t\t\t\tcin>>xxx>>yyy;\n\t\t\t\t\tfor(int kkk=0;kkk<a[sz].size();kkk++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(xxx>=a[sz][kkk].x1&&xxx<=a[sz][kkk].x2&&yyy>=a[sz][kkk].y1&&yyy<=a[sz][kkk].y2)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tint flog=0;\n\t\t\t\t\t\t\tfor(int ym=0;ym<n;ym++)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif(a[ym][0].name==a[sz][kkk].nextname)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\ta[ym][0].back=a[sz][0].name;\n\t\t\t\t\t\t\t\t\ta[sz][0].forward=a[ym][0].name;\n\t\t\t\t\t\t\t\t\tsz=ym;\n\t\t\t\t\t\t\t\t\tflog=1;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif(flog==1)\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(nn==\"back\")\n\t\t\t\t{\n\t\t\t\t\tfor(int k=0;k<n;k++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(a[k][0].name==a[sz][0].back)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ta[k][0].forward=a[sz][0].name;\n\t\t\t\t\t\t\tsz=k;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(nn==\"forward\")\n\t\t\t\t{\n\t\t\t\t\tfor(int k=0;k<n;k++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(a[k][0].name==a[sz][0].forward)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ta[k][0].back=a[sz][0].name;\n\t\t\t\t\t\t\tsz=k;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<vector>\n#include<cstring>\nusing namespace std;\n\nchar op[10005][21];\nstruct web{\n    char name[21];\n    int click_num;\n    int lx[105],ly[105],rx[105],ry[105];\n    char nname[105][21];\n}w[105];\n\nint main()\n{\n    int page;\n    while(1){\n        scanf(\"%d\",&page);\n        if(page==0) break;\n        int ww,hh;\n        scanf(\"%d%d\",&ww,&hh);\n        for(int i=0;i<page;i++){\n            scanf(\"%s%d\",w[i].name,&w[i].click_num);\n            for(int j=0;j<w[i].click_num;j++)\n                scanf(\"%d%d%d%d%s\",&w[i].lx[j],&w[i].ly[j],&w[i].rx[j],&w[i].ry[j],w[i].nname[j]);\n        }\n        int opp;\n        int front=0,tmp=0,max=0;\n        char s[21];\n        scanf(\"%d\",&opp);\n        strcpy(op[0],w[0].name);\n        for(int i=1;i<=opp;i++){\n            scanf(\"%s\",s);\n            if(strcmp(s,\"click\")==0){\n                int a,b;\n                scanf(\"%d%d\",&a,&b);\n                for(int j=0;j<w[tmp].click_num;j++){\n                    if(a<=w[tmp].rx[j]&&a>=w[tmp].lx[j]&&b<=w[tmp].ry[j]&&b>=w[tmp].ly[j]){\n                        front++;\n                        max=front;\n                        strcpy(op[front],w[tmp].nname[j]);\n                        int t=0;\n                        while(1){\n                            if(strcmp(w[t].name,op[front])==0) {tmp=t;break;}\n                            t++;\n                        }\n\n                    }\n                }\n            }\n            else if(strcmp(s,\"back\")==0){\n                front--;\n                if(front<0) front=0;\n            }\n            else if(strcmp(s,\"forward\")==0){\n                front++;\n                if(front>max) front=max;\n            }\n            else if(strcmp(s,\"show\")==0) cout<<op[front]<<endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// AOJ1054 Distorted Love\n\n#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n\nusing namespace std;\n\nclass button{\npublic:\n\tint x1, y1, x2, y2; string name;\n\tbutton(int x1, int y1, int x2, int y2, string name) : x1(x1), y1(y1), x2(x2), y2(y2), name(name) {}\n\tbool in(int x, int y) { return x1 <= x && x <= x2 && y1 <= y && y <= y2; }\n};\n\nint main(){\n\tint n;\n\tint buf[101];\n\twhile(cin >> n, n){\n\t\tint x, y; cin >> x >> y;\n\t\tbuf[0] = 0; \n\t\tint size = 0;\n\t\tint cur = 0;\n\t\tstring s;\n\t\tvector<string> vs(n);\n\t\tmap<string, int> mp;\n\t\tvector< vector<button> > vv(n, vector<button>());\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin >> s;\n\t\t\tvs[i] = s;\n\t\t\tmp[s] = i;\n\t\t\tint t; cin >> t;\n\t\t\tfor(int j=0;j<t;j++){\n\t\t\t\tint x1, y1, x2, y2; cin >> x1 >> y1 >> x2 >> y2 >> s;\n\t\t\t\tvv[i].push_back(button(x1, y1, x2, y2, s));\n\t\t\t}\n\t\t}\n\t\tcin >> n;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin >> s;\n\t\t\tif(s==\"show\") cout << vs[buf[cur]] << endl;\n\t\t\tif(s==\"forward\"){\n\t\t\t\tif(cur != size) cur++;\n\t\t\t}\n\t\t\tif(s==\"back\"){\n\t\t\t\tif(cur != 0) cur--;\n\t\t\t}\n\t\t\tif(s==\"click\"){\n\t\t\t\tint x, y; cin >> x >> y;\n\t\t\t\tfor(int j=0;j<vv[buf[cur]].size();j++){\n\t\t\t\t\tif(vv[buf[cur]][j].in(x,y)){\n\t\t\t\t\t\tcur++;\n\t\t\t\t\t\tsize = cur;\n\t\t\t\t\t\tbuf[cur] = mp[vv[buf[cur-1]][j].name];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<algorithm>\n#include<iostream>\n#include<vector>\n#include<climits>\n#include<cfloat>\n\nusing namespace std;\n\ndouble EPS = 1e-10;\n\ndouble add(double a, double b){\n  if(abs(a+b) < EPS * (abs(a)+abs(b)))return 0;\n  return a+b;\n}\n\nstruct point{\n  double x, y;\n  point(){}\n  point(double x,double y) : x(x) , y(y){}\n\n  point operator + (point p){\n    return point(add(x,p.x), add(y,p.y));\n  }\n\n  point operator - (point p){\n    return point(add(x,-p.x), add(y,-p.y));\n  }\n\n  point operator * (double d){\n    return point(x*d,y*d);\n  }\n\n  point operator / (double d){\n    return point(x/d,y/d);\n  }\n  \n  bool operator == ( const point &p ) const {\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n};\n\nstruct button{\n  point ld,ru;\n  string name;\n};\n\nstruct page{\n  string name;\n  vector<button>btn;   \n}; \n\nint tail;\npage stk[1000000];\n\nvoid push(page a){\n  stk[tail++]=a;\n}\n\npage pop(void){\n  tail--;\n  return stk[tail+1];\n}\n\nint main(void){\n  int n;\n  int w,h,b;\n  point l,r;\n  page in;\n  vector<page> a;\n  button tmp;\n\n  while(cin >> n,n){\n  \n    a.clear();\n\n    cin >> w >> h;\n    \n    for(int j=0;j<n;j++){\n      cin >> in.name >> b;    \n      \n      for(int i=0;i<b;i++){\n\tcin >> tmp.ld.x >> tmp.ld.y >> tmp.ru.x >> tmp.ru.y >> tmp.name;\n\tin.btn.push_back(tmp);\n      }\n      a.push_back(in);\n    }\n\n    int m,now=0;\n\n    cin >> m;\n    tail=0;\n    int fg=0;\n    push(a[0]);\n    while(m--){\n      string s;\n      cin >> s;\n      if(s==\"click\"){\n\tint c,d;\n\tcin >> c >> d;\n\t\n\tfor(int i=0;i<stk[tail-1].btn.size();i++){\n\t  int fg2=0;\n\t  if(stk[tail-1].btn[i].ld.x <=c &&\n\t     stk[tail-1].btn[i].ld.y <=d &&\n\t     stk[tail-1].btn[i].ru.x >=c &&\n\t     stk[tail-1].btn[i].ru.y >=d){\n\t    for(int j=0;j<a.size();j++){\n\t      if(stk[tail-1].btn[i].name==a[j].name){\n\t\tpush(a[j]);\n\t\tfg=0;\n\t\tfg2=1;\n\t\tbreak;\n\t      }\n\t    }\n\t    if(fg2)break;\n\t  }\n\t}\n      }\n      else if(s==\"back\" && tail>0){\n\ttail--;\n\tfg++;\n      }\n      else if(s==\"forward\" && fg--)tail++;\n      else if(s==\"show\")cout << stk[tail-1].name << endl;\n    }\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n#define MAX 110\n\nstruct Page{\n  int sx,sy,tx,ty;\n  string next;\n  Page(int sx,int sy,int tx,int ty,string next)\n    : sx(sx),sy(sy),tx(tx),ty(ty),next(next) {}\n};\n\nvector<Page> vec[MAX];\n\nvoid init(){\n  for(int i = 0 ; i < MAX ; i++){\n    vec[i].clear();\n  }\n}\n\nint main(){\n  int N,W,H,b,sx,sy,tx,ty;\n  string str[MAX],s;\n\n  while(cin >> N,N){\n    int p = 0;\n    cin >> W >> H;\n    init();\n    for(int i = 0 ; i < N ; i++){\n      cin >> str[i] >> b;\n      for(int j = 0 ; j < b ; j++){\n        cin >> sx >> sy >> tx >> ty >> s;\n        vec[i].push_back(Page(sx,sy,tx,ty,s));\n      }\n    }\n    int m,w,h,now = 0;\n    vector<int> now_page;\n    now_page.push_back(now);\n    string next;\n    cin >> m;\n    for(int I = 0 ; I < m ; I++){\n      cin >> s;\n      if(s == \"click\"){\n        bool found = false;\n        cin >> w >> h;\n        for(int i = 0 ; i < vec[now_page[p]].size() ; i++){\n          sx = vec[now][i].sx, sy = vec[now][i].sy;\n          tx = vec[now][i].tx, ty = vec[now][i].ty;\n          next = vec[now][i].next;\n          if(sx <= w && w <= tx && sy <= h && h <= ty){\n            for(int j = 0 ; j < N ; j++){\n              if(str[j] == next){\n                now = j;\n                found = true;\n                break;\n              }\n            }\n          }\n          if(found){\n            p++;\n            while(p < now_page.size()){\n              now_page.pop_back();\n            }\n            now_page.push_back(now);\n            break;\n          }\n        }\n      }else if(s == \"show\"){\n        cout << str[now_page[p]] << endl;\n      }else if(s == \"back\"){\n        if(p > 0) p--;\n      }else{\n        if(p+1 < now_page.size()) p++;\n      }\n    }\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <deque>\n#include <map>\nusing namespace std;\ntypedef struct{int sx, sy, ex, ey; string to;} LINK;\t//ボタンの左上・右下座標、リンク先のページ名\ntypedef struct{string name; int n; LINK btn[100];} PAGE;\t//ページ名、ページ上にあるボタンの数・その一覧\nint main()\n{\n\tint n, o, W, H;\t//ページの数、命令の数、ページの幅・高さ\n\tint i, j, x, y, cur, t, m;\t//ループ用変数、\"click x y\"のx,y、、一時的な、履歴の長さ\n\tstring op;\t//命令の名前\n\tPAGE pg[100];\n\tLINK tmp;\n\tmap<string, int> tbl;\n\twhile (cin >> n, n)\n\t{\n\t\tdeque<string> his;\t//ページの履歴（pg[i]のiを代入）\n\t\tdeque<string>::iterator itr;\n\t\tcin >> W >> H;\n\t\tfor (i = 0; i < n; i++)\n\t\t{\n\t\t\tcin >> pg[i].name >> pg[i].n;\n\t\t\ttbl.insert( map<string, int>::value_type(pg[i].name, i) );\n\t\t\tfor (j = 0; j < pg[i].n; j++)\n\t\t\t{\n\t\t\t\tcin >> tmp.sx >> tmp.sy >> tmp.ex >> tmp.ey >> tmp.to;\n\t\t\t\tpg[i].btn[j] = tmp;\n\t\t\t}\n\t\t}\n\t\tcin >> o;\n\t\this.push_back(pg[0].name);\n\t\tcur = 0;\n\t\tm = 1;\n\t\tfor (i = 0; i < o; i++)\n\t\t{\n\t\t\tcin >> op;\n\t\t\tif (op == \"click\")\n\t\t\t{\n\t\t\t\tcin >> x >> y;\n\t\t\t\tt = tbl[his.at(cur)];\n\t\t\t\tfor (j = 0; j < pg[t].n; j++)\n\t\t\t\t{\n\t\t\t\t\tif (pg[t].btn[j].sx <= x && x <= pg[t].btn[j].ex && pg[t].btn[j].sy <= y && y <= pg[t].btn[j].ey)\n\t\t\t\t\t{\n\t\t\t\t\t\this.push_back(pg[t].btn[j].to);\n\t\t\t\t\t\tcur++;\n\t\t\t\t\t\tm++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\titr = his.end();\n\t\t\t\tfor (j = cur+1; j < m; j++)\n\t\t\t\t{\n\t\t\t\t\this.erase(itr);\n\t\t\t\t\tm--;\n\t\t\t\t\titr--;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (op == \"back\")\n\t\t\t{\n\t\t\t\tif (cur > 0)\n\t\t\t\t\tcur--;\n\t\t\t}\n\t\t\telse if (op == \"forward\")\n\t\t\t{\n\t\t\t\tif (cur < m)\n\t\t\t\t\tcur++;\n\t\t\t}\n\t\t\telse if (op == \"show\")\n\t\t\t{\n\t\t\t\tcout << his.at(cur) << endl;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<algorithm>\n#include<iostream>\n#include<vector>\n#include<climits>\n#include<cfloat>\n\nusing namespace std;\n\nstruct point{\n  int x, y;\n};\n\nstruct button{\n  point ld,ru;\n  string name;\n};\n\nstruct page{\n  string name;\n  vector<button>btn;   \n}; \n\nint m,now,fg;\nvector<page> a;\npage nul;\nstatic page buf[1000000];\n\nvoid click(int c,int d){\n  \n  for(int i=0;i<buf[now].btn.size();i++)\n    if(buf[now].btn[i].ld.x <=c && buf[now].btn[i].ld.y <=d &&\n       buf[now].btn[i].ru.x >=c && buf[now].btn[i].ru.y >=d)\n      for(int j=0;j<a.size();j++)\n\tif(buf[now].btn[i].name==a[j].name){\n\t  buf[++now]=a[j];\n\t  fill(buf+now+1,buf+1000000,nul);\n\t  fg=0;\n\t  return ;\n\t}\n}\n\nint main(void){\n  int n;\n  int w,h,b;\n  point l,r;\n  page in;\n  button tmp;\n\n  nul.name=\"\";\n\n  while(cin >> n,n){\n  \n    a.clear();\n\n    cin >> w >> h;\n    \n    for(int j=0;j<n;j++){\n      cin >> in.name >> b;    \n      \n      for(int i=0;i<b;i++){\n\tcin >> tmp.ld.x >> tmp.ld.y >> tmp.ru.x >> tmp.ru.y >> tmp.name;\n\tin.btn.push_back(tmp);\n      }\n      a.push_back(in);\n    }\n\n    now=0,fg=0;\n    buf[0]=a[0];\n\n    cin >> m;\n\n    while(m--){\n      string s;\n      cin >> s;\n      if(s==\"click\"){\n\tint c,d;\n\tcin >> c >> d;\n\tclick(c,d);\n      }\n      else if(s==\"back\" && now>0)now--,fg++;\n      else if(s==\"forward\" && fg>0 && now < 1000000)now++,fg--;\n      else if(s==\"show\")cout << buf[now].name << endl;\n    }\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <deque>\n#include <map>\nusing namespace std;\ntypedef struct{int sx, sy, ex, ey; string to;} LINK;\t//ボタンの左上・右下座標、リンク先のページ名\ntypedef struct{string name; int n; LINK btn[100];} PAGE;\t//ページ名、ページ上にあるボタンの数・その一覧\nint main()\n{\n\tint n, o, W, H;\t//ページの数、命令の数、ページの幅・高さ\n\tint i, j, x, y, cur, t, m;\t//ループ用変数、\"click x y\"のx,y、、一時的な、履歴の長さ\n\tstring op;\t//命令の名前\n\tPAGE pg[100];\n\tLINK tmp;\n\tmap<string, int> tbl;\n\twhile (cin >> n, n)\n\t{\n\t\tdeque<string> his;\t//ページの履歴（pg[i]のiを代入）\n\t\tdeque<string>::iterator itr;\n\t\tcin >> W >> H;\n\t\tfor (i = 0; i < n; i++)\n\t\t{\n\t\t\tcin >> pg[i].name >> pg[i].n;\n\t\t\ttbl.insert( map<string, int>::value_type(pg[i].name, i) );\n\t\t\tfor (j = 0; j < pg[i].n; j++)\n\t\t\t{\n\t\t\t\tcin >> tmp.sx >> tmp.sy >> tmp.ex >> tmp.ey >> tmp.to;\n\t\t\t\tpg[i].btn[j] = tmp;\n\t\t\t}\n\t\t}\n\t\tcin >> o;\n\t\this.push_back(pg[0].name);\n\t\tcur = 0;\n\t\tm = 1;\n\t\tfor (i = 0; i < o; i++)\n\t\t{\n\t\t\tcin >> op;\n\t\t\tif (op == \"click\")\n\t\t\t{\n\t\t\t\tcin >> x >> y;\n\t\t\t\tt = tbl[his.at(cur)];\n\t\t\t\tfor (j = 0; j < pg[t].n; j++)\n\t\t\t\t{\n\t\t\t\t\tif (pg[t].btn[j].sx <= x && x <= pg[t].btn[j].ex && pg[t].btn[j].sy <= y && y <= pg[t].btn[j].ey)\n\t\t\t\t\t{\n\t\t\t\t\t\this.push_back(pg[t].btn[j].to);\n\t\t\t\t\t\tcur++;\n\t\t\t\t\t\tm++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\titr = his.end();\n\t\t\t\tfor (j = cur+1; j < m; j++)\n\t\t\t\t{\n\t\t\t\t\this.erase(itr);\n\t\t\t\t\tm--;\n\t\t\t\t\titr--;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (op == \"back\")\n\t\t\t{\n\t\t\t\tif (cur > 0)\n\t\t\t\t\tcur--;\n\t\t\t}\n\t\t\telse if (op == \"forward\")\n\t\t\t{\n\t\t\t\tif (cur < m)\n\t\t\t\t\tcur++;\n\t\t\t}\n\t\t\telse if (op == \"show\")\n\t\t\t{\n\t\t\t\tcout << his.at(cur) << endl;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\n\nint b[100], x1[100][100], Y1[100][100], x2[100][100], y2[100][100];\nstring link[100][100];\nmap<string, int>mp;\nint main() {\n\tint n;\n\twhile (scanf(\"%d\", &n), n) {\n\t\tmp.clear();\n\t\tint w, h; scanf(\"%d%d\", &w, &h);\n\t\tvector<string>v;\n\t\trep(i, n) {\n\t\t\tstring s; cin >> s >> b[i]; mp[s] = i;\n\t\t\tif (i == 0)v.push_back(s);\n\t\t\trep(j, b[i])cin >> x1[i][j] >> Y1[i][j] >> x2[i][j] >> y2[i][j] >> link[i][j];\n\t\t}\n\t\tint pos = 0;\n\t\tint m; scanf(\"%d\", &m);\n\t\tif (m > 10000)abort();\n\t\trep(i, m) {\n\t\t\tstring s; cin >> s;\n\t\t\tif (s == \"click\") {\n\t\t\t\tint x, y; cin >> x >> y;\n\t\t\t\tint a = mp[v.back()];\n\t\t\t\trep(i, b[a]) {\n\t\t\t\t\tif (x1[a][i] <= x&&x <= x2[a][i] && Y1[a][i] <= y&&y <= y2[a][i]) {\n\t\t\t\t\t\tif (pos + 1 < v.size())v.erase(v.begin() + pos + 1, v.end());\n\t\t\t\t\t\tv.push_back(link[a][i]); pos = v.size() - 1; break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (s == \"back\") {\n\t\t\t\tif (pos)pos--;\n\t\t\t}\n\t\t\tif (s == \"forward\") {\n\t\t\t\tif (pos < v.size() - 1)pos++;\n\t\t\t}\n\t\t\tif (s == \"show\")cout << v[pos] << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<fstream>\n#include<cstdio>\n#include<vector>\n#include<list>\n#include<stack>\n#include<queue>\n#include<deque>\n#include<map>\n#include<set>\n#include<algorithm>\n#include<string>\n#include<cmath>\n#include<cstdlib>\nusing namespace std;\n\nstruct button{\n\tint x,y,i,j;\n\tstring refereces;\n};\n\nint main(){\n\tint n;\n\twhile(scanf(\"%d\",&n)==1,n){\n\t\tmap<string,vector<button> > table;\n\t\tvector<string> historial;\n\t\tint ind = 0x0, ww,hh;\n\t\tscanf(\"%d %d\",&ww,&hh);\n\n\t\tfor(int x=0;x<n;++x){\n\t\t\tchar mat[200];\n\t\t\tscanf(\"%s %d\",mat,&ww);\n\t\t\tstring nom(mat);\n\t\t\tfor(int i=0;i<ww;++i){\n\t\t\t\tbutton nv;\n\t\t\t\tscanf(\"%d %d %d %d %s\",&nv.x,&nv.y,&nv.i,&nv.j,mat);\n\t\t\t\tstring ref(mat);\n\t\t\t\tnv.refereces = ref;\n\t\t\t\ttable[nom].push_back(nv);\n\t\t\t}\n\t\t}\n\t\tscanf(\"%d\",&n);\n\t\thistorial.push_back(\"index\");\n\t\tstringstream buf;\n\t\tfor(int x=0;x<n;++x){\n\t\t\tchar mat[50];\n\t\t\tscanf(\"%s\",mat);\n\t\t\tstring line(mat);\n\t\t\tif(line==\"back\" && ind!=0){\n\t\t\t\tind -= 0x1;\n\t\t\t}else if(line==\"show\"){\n\t\t\t\tbuf<<historial[ind]<<endl;\n\t\t\t}else if(line==\"forward\" && ind!=historial.size()-1){\n\t\t\t\tind += 0x1;\n\t\t\t}else{\n\t\t\t\tscanf(\"%d %d\",&ww,&hh);\n\t\t\t\tvector<button> tmp = table[historial[ind]];\n\t\t\t\tfor(int w=0;w<tmp.size();++w){\n\t\t\t\t\tif(tmp[w].x<=ww && ww<=tmp[w].i && tmp[w].y<=hh && hh<=tmp[w].j){\n\t\t\t\t\t\thistorial.push_back(tmp[w].refereces);\n\t\t\t\t\t\tind++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<buf.str();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <map>\nusing namespace std;\n\nstruct Button {\n  int x1,y1,x2,y2;\n  string s;\n  Button(int _x1,int _y1, int _x2, int _y2, string _s) {x1=_x1;y1=_y1;x2=_x2;y2=_y2;s=_s;}\n};\n\nint main() {\n  int n;\n  while(cin>>n,n) {\n    int w,h;\n    cin >> w >> h;\n    string str[n];\n    int b[n];\n    vector<Button> v[n];\n    map<string, int> ma;\n    for (int i=0;i<n;i++) {\n      cin >> str[i];\n      cin >> b[i];\n      ma.insert(make_pair(str[i], i));\n      for (int j=0;j<b[i];j++) {\n        int x1,y1,x2,y2;\n        cin >> x1>>y1>>x2>>y2;\n        string s;\n        cin >> s;\n        v[i].push_back(Button(x1,y1,x2,y2,s));\n      }\n    }\n    int m;\n    cin >> m;\n    int p=0;\n    int p2=0;                   // ツ催妥・ツづ個つキツつキツづ淞づゥツペツーツジ\n    int bv[10000];\n    bv[0] = 0;\n    for (int i=0; i<m; i++) {\n      string s;\n      cin >> s;\n      if (s==\"click\") {\n        int x, y;\n        cin >> x >> y;\n        vector<Button> bu = v[bv[p]];\n        for (int j=0; j<b[p]; j++) {\n          if (bu[j].x1<=x&&x<=bu[j].x2 && bu[j].y1<=y&&y<=bu[j].y2) {\n            map<string, int>::iterator it = ma.find(v[p][j].s);\n            bv[++p] = it->second;\n            p2 = p;\n            break;\n          }\n        }\n      } else if (s==\"back\") {\n        if (p) p--;\n      } else if (s==\"forward\") {\n        if (p<p2) p++;\n      } else if (s==\"show\") {\n        cout << str[p] << endl;\n      }\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)n; ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cout<<*i<<\" \"; cout<<endl; }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nstruct Page{\n  string name;\n  vector<int> bx;\n  vector<int> by;\n  vector<int> ex;\n  vector<int> ey;\n  vector<string> to;\n  Page(string n){\n    name = n;\n  }\n  void add(int x1, int y1, int x2, int y2, string s){\n    bx.push_back(x1);\n    by.push_back(y1);\n    ex.push_back(x2);\n    ey.push_back(y2);\n    to.push_back(s);\n  }\n  string link(int x, int y){\n    REP(i,bx.size()){\n      if(bx[i] <= x && x <= ex[i] && by[i] <= y && y <= ey[i]){\n        return to[i];\n      }\n    }\n    return \"\";\n  }\n};\n\n\nint main(){\n  int N;\n  while(cin>>N, N){\n    int W,H; cin>>W>>H;\n    vector<Page> pages;\n    map<string, int> id;\n    REP(i,N){\n      string s; int n;\n      cin>>s>>n;\n      id[s] = i;\n      Page p(s);\n      while(n--){\n        int a,b,c,d; string nm;\n        cin>>a>>b>>c>>d>>nm;\n        p.add(a,b,c,d,nm);\n      }\n      pages.push_back(p);\n    }\n    int O; cin>>O;\n    vector<Page> bf;\n    bf.push_back(pages[0]);\n    int p = 0;\n    while(O--){\n      string ope; cin>>ope;\n      int x,y;\n      if(ope == \"show\"){\n        cout<<bf[p].name<<endl;\n      }\n      if(ope == \"forward\"){\n        if(p + 1 < bf.size()) p += 1;\n      }\n      if(ope == \"back\"){\n        if(p - 1 >= 0) p -= 1;\n      }\n      if(ope == \"click\"){\n        cin>>x>>y;\n        string linkname = bf[p].link(x,y);\n        int toidx = -1;\n        if(id.count(linkname)) toidx = id[linkname];\n        if(toidx != -1) {\n          Page nextpage = pages[toidx];\n          bf.erase(bf.begin() + p + 1, bf.end());\n          bf.push_back(nextpage);\n          p++;\n        }\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<algorithm>\n#include<iostream>\n#include<vector>\n#include<climits>\n#include<cfloat>\n\nusing namespace std;\n\nstruct point{\n  int x, y;\n};\n\nstruct button{\n  point ld,ru;\n  string name;\n};\n\nstruct page{\n  string name;\n  vector<button>btn;   \n}; \n\nint m,now;\nvector<page> a;\npage nul;\nstatic page buf[1000000];\n\nvoid click(int c,int d){\n  \n  for(int i=0;i<buf[now].btn.size();i++)\n    if(buf[now].btn[i].ld.x <=c && buf[now].btn[i].ld.y <=d &&\n       buf[now].btn[i].ru.x >=c && buf[now].btn[i].ru.y >=d)\n      for(int j=0;j<a.size();j++)\n\tif(buf[now].btn[i].name==a[j].name){\n\t  buf[++now]=a[j];\n\t  fill(buf+now+1,buf+1000000,nul);\n\t  return ;\n\t}\n}\n\nint main(void){\n  int n;\n  int w,h,b;\n  point l,r;\n  page in;\n  button tmp;\n\n  while(cin >> n,n){\n  \n    a.clear();\n\n    cin >> w >> h;\n    \n    for(int j=0;j<n;j++){\n      cin >> in.name >> b;    \n      \n      for(int i=0;i<b;i++){\n\tcin >> tmp.ld.x >> tmp.ld.y >> tmp.ru.x >> tmp.ru.y >> tmp.name;\n\tin.btn.push_back(tmp);\n      }\n      a.push_back(in);\n    }\n\n    now=0;\n    buf[0]=a[0];\n\n    cin >> m;\n\n    while(m--){\n      string s;\n      cin >> s;\n      if(s==\"click\"){\n\tint c,d;\n\tcin >> c >> d;\n\tclick(c,d);\n      }\n      else if(s==\"back\" && now>0)now--;\n      else if(s==\"forward\" && now < 1000000)now++;\n      else if(s==\"show\")cout << buf[now].name << endl;\n    }\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\nusing namespace std;\nstruct S{int x1,x2,y1,y2;string s;}_;\nint main()\n{\n\tint n,m,b,h,w,i,j,x,y;\n\tstring s;\n\twhile(cin>>n>>w>>h)\n\t{\n\t\tmap<string,vector<S> >M;\n\t\tvector<string> V;\n\t\tvector<string>::iterator ite;\n\t\tfor(i=0;i<n;++i)\n\t\t{\n\t\t\tcin>>s>>b;\n\t\t\tif(!i)V.push_back(s);\n\t\t\tfor(j=0;j<b;++j)cin>>_.x1>>_.y1>>_.x2>>_.y2>>_.s, M[s].push_back(_);\n\t\t}\n\t\tcin>>m;\n\t\tite=V.begin();\n\t\tfor(i=0;i<m;++i)\n\t\t{\n\t\t\tcin>>s;\n\t\t\tif(s==\"click\")\n\t\t\t{\n\t\t\t\tcin>>x>>y;for(j=0;j<M[*ite].size();++j)\n\t\t\t\t{\n\t\t\t\t\t_=M[*ite][j];\n\t\t\t\t\tif(x>=_.x1&&x<=_.x2&&y>=_.y1&&y<=_.y2)\n\t\t\t\t\t{\tV.erase(ite+1,V.end());\n\t\t\t\t\t\tV.push_back(_.s);\n\t\t\t\t\t\tite=V.end()-1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(s==\"back\") if(ite!=V.begin())--ite;\n\t\t\tif(s==\"forward\") if(ite!=V.end()-1)++ite;\n\t\t\tif(s==\"show\") cout<<*ite<<endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\nconst int MAX = 10001;\n\nstring data[MAX];\nint W,H,N;\n\nstruct Button{\n  int lx,rx,ly,ry;\n  string name;\n};\n\nmap<string,vector<Button> > M;\n\n\nvoid init(){\n  M.clear();\n  fill(data,data+MAX,\"\");\n}\n\nvoid input(){\n  cin >> W >> H;\n  for(int i = 0; i < N; i++){\n    string s;\n    int num;\n    cin >> s >> num;\n    if(i == 0) data[0] = s;\n\n    for(int j = 0; j < num; j++){\n      Button B;\n      cin >> B.lx >> B.ly >> B.rx >> B.ry >> B.name;\n      M[s].push_back(B);\t\n    }\n\n  }\n}\n\nvoid solve(){\n  int num;\n  cin >> num;\n  int index = 0;\n\n\n  while(num--){\n    string op;\n    cin >> op;\n    if(op == \"click\"){\n      int x,y;\n      cin >> x >> y;\n      string now = data[index];\n\n      for(int i = 0; i < M[now].size(); i++){\n\tif(M[now][i].lx <= x && x <= M[now][i].rx && M[now][i].ly <= y && y <= M[now][i].ry){\n\t  data[++index] = M[now][i].name;\n\t  fill(data+index+1,data+MAX,\"\");\n\t  break;\n\t}\n\n      }\n\n    }else if(op == \"back\" && index > 0) index--;\n    else if(op == \"forward\" && data[index+1] != \"\") index++;\n    else if(op == \"show\") cout << data[index] << endl;\n  }\n}\n\nint main(){\n\n  while(cin >> N && N){\n    input();\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//20\n#include<iostream>\n#include<map>\n#include<string>\n#include<vector>\n#include<utility>\n\nusing namespace std;\n\nstruct B{\n  int ty,by,lx,rx;\n  bool clk(int y,int x){\n    return ty<=y&&y<=by&&lx<=x&&x<=rx;\n  }\n};\n\nint main(){\n  for(int n;cin>>n,n;){\n    int w,h;\n    cin>>w>>h;\n    map<string,vector<pair<B,string> > > m;\n    int x=0;\n    vector<string> buf(1);\n    for(int i=0;i<n;i++){\n      string s;\n      int nb;\n      cin>>s>>nb;\n      if(i==0){\n\tbuf[0]=s;\n      }\n      for(int j=0;j<nb;j++){\n\tint x,xx,y,yy;\n\tstring l;\n\tcin>>x>>y>>xx>>yy>>l;\n\tB b={y,yy,x,xx};\n\tm[s].push_back(make_pair(b,l));\n      }\n    }\n    int nm;\n    cin>>nm;\n    while(nm--){\n      string op;\n      cin>>op;\n      if(op==\"click\"){\n\tint cx,cy;\n\tcin>>cx>>cy;\n\tint i;\n\tfor(i=0;i<m[buf[x]].size();i++){\n\t  if(m[buf[x]][i].first.clk(cy,cx))break;\n\t}\n\tif(i<m[buf[x]].size()){\n\t  buf.erase(buf.begin()+x+1,buf.end());\n\t  buf.push_back(m[buf[x]][i].second);\n\t  x++;\n\t}\n      }else if(op==\"back\"){\n\tif(x>0){\n\t  x--;\n\t}\n      }else if(op==\"forward\"){\n\tif(x<buf.size()-1){\n\t  x++;\n\t}\n      }else{\n\tcout<<buf[x]<<endl;\n      }\n    }\n  }\n  return 0;\n}\n  "
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n\nusing namespace std;\n\n#ifdef _MSC_VER\n#define __typeof__ decltype\ntemplate <class T> int __builtin_popcount(T n) { return n ? 1 + __builtin_popcount(n & (n - 1)) : 0; }\n#endif\n\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define popcount __builtin_popcount\n\n#define rep(i, n) for (int i = 0; i < n; ++i)\n\ntemplate <class T> void max_swap(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T& b) { a = min(a, b); }\n\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\n\nstruct Button\n{\n\tint x1, y1, x2, y2;\n\tstring name;\n\tbool include(int x, int y)\n\t{\n\t\treturn x1 <= x && x <= x2\n\t\t\t&& y1 <= y && y <= y2;\n\t}\n\tvoid input()\n\t{\n\t\tcin >> x1 >> y1 >> x2 >> y2 >> name;\n\t}\n};\nint main()\n{\n\tint n, m, w, h;\n\twhile (cin >> n, n)\n\t{\n\t\tcin >> w >> h;\n\n\t\tmap<string, vector<Button> > page;\n\t\tvector<string> buffer;\n\t\trep (i, n)\n\t\t{\n\t\t\tstring name;\n\t\t\tint b;\n\t\t\tcin >> name >> b;\n\t\t\tif (i == 0)\n\t\t\t\tbuffer.push_back(name);\n\n\t\t\twhile (b--)\n\t\t\t{\n\t\t\t\tpage[name].push_back(Button());\n\t\t\t\tpage[name].back().input();\n\t\t\t}\n\t\t}\n\n\t\tcin >> m;\n\t\tint pointer = 0;\n\t\twhile (m--)\n\t\t{\n\t\t\tstring& b = buffer[pointer];\n\n\t\t\tstring c;\n\t\t\tcin >> c;\n\t\t\tif (c[0] == 'c')\n\t\t\t{\n\t\t\t\tint x, y;\n\t\t\t\tcin >> x >> y;\n\t\t\t\tfor (int i = 0; i < page[b].size(); ++i)\n\t\t\t\t{\n\t\t\t\t\tif (page[b][i].include(x, y))\n\t\t\t\t\t{\n\t\t\t\t\t\t++pointer;\n\t\t\t\t\t\tbuffer.erase(buffer.begin() + pointer, buffer.end());\n\t\t\t\t\t\tbuffer.push_back(page[b][i].name);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (c[0] == 'b')\n\t\t\t\t--pointer;\n\t\t\telse if (c[0] == 'f')\n\t\t\t\t++pointer;\n\t\t\telse if (c[0] == 's')\n\t\t\t\tcout << b << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "// AOJ1054 Distorted Love\n\n#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n\nusing namespace std;\n\nclass button{\npublic:\n\tint x1, y1, x2, y2; string name;\n\tbutton(int x1, int y1, int x2, int y2, string name) : x1(x1), y1(y1), x2(x2), y2(y2), name(name) {}\n\tbool in(int x, int y) { return x1 <= x && x <= x2 && y1 <= y && y <= y2; }\n};\n\nint main(){\n\tint n;\n\tint buf[100];\n\twhile(cin >> n, n){\n\t\tint x, y; cin >> x >> y;\n\t\tbuf[0] = 0; \n\t\tint size = 0;\n\t\tint cur = 0;\n\t\tstring s;\n\t\tvector<string> vs;\n\t\tmap<string, int> mp;\n\t\tvector< vector<button> > vv(n);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin >> s;\n\t\t\tvs.push_back(s);\n\t\t\tmp[s] = i;\n\t\t\tint t; cin >> t;\n\t\t\tfor(int j=0;j<t;j++){\n\t\t\t\tint x1, y1, x2, y2; cin >> x1 >> y1 >> x2 >> y2 >> s;\n\t\t\t\tvv[i].push_back(button(x1, y1, x2, y2, s));\n\t\t\t}\n\t\t}\n\t\tcin >> n;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin >> s;\n\t\t\tif(s==\"show\") cout << vs[buf[cur]] << endl;\n\t\t\tif(s==\"forward\"){\n\t\t\t\tif(cur != size) cur++;\n\t\t\t}\n\t\t\tif(s==\"back\"){\n\t\t\t\tif(cur != 0) cur--;\n\t\t\t}\n\t\t\tif(s==\"click\"){\n\t\t\t\tint x, y; cin >> x >> y;\n\t\t\t\tfor(int j=0;j<vv[buf[cur]].size();j++){\n\t\t\t\t\tif(vv[buf[cur]][j].in(x,y)){\n\t\t\t\t\t\tcur++;\n\t\t\t\t\t\tsize = cur;\n\t\t\t\t\t\tbuf[cur] = mp[vv[buf[cur-1]][j].name];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\nconst ld eps = 1e-9;\n\n//// < \"d:\\d_download\\visual studio 2015\\projects\\programing_contest_c++\\debug\\a.txt\" > \"d:\\d_download\\visual studio 2015\\projects\\programing_contest_c++\\debug\\b.txt\"\nstruct button {\n\tint l, u, r, d;\n\tstring to;\n};\nstruct page {\n\tstring name;\n\tvector<button>bs;\n};\n\nint main() {\n\twhile (1) {\n\t\tint N; cin >> N;\n\t\tif (!N)break;\n\t\tint W, H; cin >> W >> H;\n\t\tmap<string, page>pagemp;\n\t\tstring start;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tstring name; cin >> name;\n\t\t\tif (!i)start = name;\n\t\t\tpage apage;\n\t\t\tapage.name = name;\n\t\t\tint b; cin >> b;\n\t\t\tfor (int j = 0; j < b; ++j) {\n\t\t\t\tint l, u, r, d; string to; cin >> l >> u >> r >> d>>to;\n\t\t\t\tapage.bs.push_back(button{ l,u,r,d,to });\n\t\t\t}\n\t\t\tpagemp[apage.name] = apage;\n\t\t}\n\t\tint Q; cin >> Q;\n\t\tvector<string>memorys(1,start);\n\t\tint now = 0;\n\t\twhile (Q--) {\n\t\t\tstring st; cin >> st;\n\t\t\tif (st == \"show\") {\n\t\t\t\tcout << memorys[now] << endl;\n\t\t\t}\n\t\t\telse if (st == \"back\") {\n\t\t\t\tif (now)now--;\n\t\t\t}\n\t\t\telse if (st == \"forward\") {\n\t\t\t\tif (now != memorys.size() - 1)now++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tassert(st == \"click\");\n\t\t\t\t{\n\t\t\t\t\tint x, y; cin >> x >> y;\n\t\t\t\t\tfor (auto b : pagemp[memorys[now]].bs) {\n\t\t\t\t\t\tif (b.l <= x&&x <= b.r&&b.u <= y&&y <= b.d) {\n\t\t\t\t\t\t\tmemorys.erase(memorys.begin() + now+1, memorys.end());\n\t\t\t\t\t\t\tmemorys.push_back(b.to);\n\t\t\t\t\t\t\tnow++;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\nstruct Button{\n\tint left,right,top,under,link_index;\n\tchar to_name[21];\n};\n\nstruct Page{\n\tchar name[21];\n\tvector<Button> B;\n};\n\nint num_page,W,H;\nint* buffer;\n\nbool strCmp(char* base, char* comp){\n\tint length1 = 0,length2 = 0;\n\tfor(int i=0;base[i] != '\\0'; i++)length1++;\n\tfor(int i=0;comp[i] != '\\0'; i++)length2++;\n\tif(length1 != length2)return false;\n\n\tfor(int i=0;base[i] != '\\0'; i++){\n\t\tif(base[i] != comp[i])return false;\n\t}\n\treturn true;\n}\n\n\nvoid func(){\n\n\tPage page[101];\n\n\tint pointer,buffer_size;\n\n\tint num_button;\n\n\tfor(int i = 0; i < num_page; i++){\n\t\tscanf(\"%s %d\",page[i].name,&num_button);\n\n\t\tfor(int k = 0; k < num_button;k++){\n\t\t\tButton button;\n\t\t\tscanf(\"%d %d %d %d %s\",&button.left,&button.top,&button.right,&button.under,button.to_name);\n\t\t\tpage[i].B.push_back(button);\n\t\t}\n\t}\n\n\tfor(int i = 0; i < num_page; i++){\n\t\tfor(int k = 0; k < page[i].B.size();k++){\n\t\t\tfor(int p = 0; p < num_page; p++){\n\t\t\t\tif(strCmp(page[i].B[k].to_name,page[p].name)){\n\t\t\t\t\tpage[i].B[k].link_index = p;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tbuffer[0] = 0;\n\tpointer = 0;\n\tbuffer_size = 1;\n\n\n\tint M,tmp_x,tmp_y;\n\tscanf(\"%d\",&M);\n\n\tchar order[10];\n\n\tfor(int loop = 0; loop < M; loop++){\n\t\tscanf(\"%s\",order);\n\n\t\tswitch(order[0]){\n\t\tcase 'c':\n\t\t\tscanf(\"%d %d\",&tmp_x,&tmp_y);\n\n\t\t\tfor(int i = 0; i < page[pointer].B.size();i++){\n\t\t\t\tif(tmp_x >= page[pointer].B[i].left && tmp_x <= page[pointer].B[i].right &&\n\t\t\t\t\t\ttmp_y >= page[pointer].B[i].top && tmp_y <= page[pointer].B[i].under){\n\n\t\t\t\t\tbuffer_size = pointer+1;\n\t\t\t\t\tbuffer[buffer_size] = page[pointer].B[i].link_index;\n\t\t\t\t\tbuffer_size++;\n\t\t\t\t\tpointer++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'b':\n\t\t\tif(pointer > 0)pointer--;\n\t\t\tbreak;\n\t\tcase 'f':\n\t\t\tif(pointer < buffer_size-1)pointer++;\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\tprintf(\"%s\\n\",page[pointer].name);\n\t\t\tbreak;\n\t\t}\n\t}\n\n}\n\nint main(){\n\n\tbuffer = new int[50000];\n\n\twhile(true){\n\t\tscanf(\"%d\",&num_page);\n\t\tif(num_page == 0)break;\n\n\t\tscanf(\"%d %d\",&W,&H);\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// AOJ1054 Distorted Love\n\n#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n\nusing namespace std;\n\nclass button{\npublic:\n\tint x1, y1, x2, y2; string name;\n\tbutton(int x1, int y1, int x2, int y2, string name) : x1(x1), y1(y1), x2(x2), y2(y2), name(name) {}\n\tbool in(int x, int y) { return x1 <= x && x <= x2 && y1 <= y && y <= y2; }\n};\n\nint main(){\n\tint n;\n\tint buf[100];\n\twhile(cin >> n, n){\n\t\tint x, y; cin >> x >> y;\n\t\tbuf[0] = 0; \n\t\tint size = 0;\n\t\tint cur = 0;\n\t\tstring s;\n\t\tvector<string> vs(n);\n\t\tmap<string, int> mp;\n\t\tvector< vector<button> > vv(n, vector<button>());\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin >> s;\n\t\t\tvs[i] = s;\n\t\t\tmp[s] = i;\n\t\t\tint t; cin >> t;\n\t\t\tfor(int j=0;j<t;j++){\n\t\t\t\tint x1, y1, x2, y2; cin >> x1 >> y1 >> x2 >> y2 >> s;\n\t\t\t\tvv[i].push_back(button(x1, y1, x2, y2, s));\n\t\t\t}\n\t\t}\n\t\tcin >> n;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin >> s;\n\t\t\tif(s==\"show\") cout << vs[buf[cur]] << endl;\n\t\t\tif(s==\"forward\"){\n\t\t\t\tif(cur != size) cur++;\n\t\t\t}\n\t\t\tif(s==\"back\"){\n\t\t\t\tif(cur != 0) cur--;\n\t\t\t}\n\t\t\tif(s==\"click\"){\n\t\t\t\tint x, y; cin >> x >> y;\n\t\t\t\tfor(int j=0;j<vv[buf[cur]].size();j++){\n\t\t\t\t\tif(vv[buf[cur]][j].in(x,y)){\n\t\t\t\t\t\tcur++;\n\t\t\t\t\t\tsize = cur;\n\t\t\t\t\t\tbuf[cur] = mp[vv[buf[cur-1]][j].name];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twhile(true) ;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <string>\n#include <list>\n#include <map>\nusing namespace std;\n\nstruct C\n{\n  string s;\n  int x1;\n  int y1;\n  int x2;\n  int y2;\n  C ( int x1, int y1, int x2, int y2, const char *s )\n  {\n    this->x1 = x1;\n    this->y1 = y1;\n    this->x2 = x2;\n    this->y2 = y2;\n    this->s = s;\n  }\n};\n\nint\nmain (\n  int   argc,\n  char *argv[ ]\n  )\n{\n  list<C>::iterator it;\n  int i;\n\n  for ( ; ; )\n  {\n    map<string,list<C> > lis;\n    list<string> buf;\n    list<string> cont;\n    int w, h;\n    int n;\n\n    scanf ( \" %d\", &n );\n    if ( n == 0 ) break ;\n\n    scanf ( \" %d %d\", &w, &h );\n    while ( n-- )\n    {\n      list<C> r;\n      char s[ 32 ];\n      int c;\n\n      scanf ( \" %s %d\", s, &c );\n      if ( buf.empty ( ) )\n        buf.push_back ( s );\n      for ( i = 0; i < c; ++i )\n      {\n        int x1, y1, x2, y2;\n        char t[ 32 ];\n\n        scanf ( \" %d %d %d %d %s\", &x1, &y1, &x2, &y2, t );\n        r.push_back ( C ( x1, y1, x2, y2, t ) );\n      }\n      lis[ s ] = r;\n    }\n\n    scanf ( \" %d\", &n );\n    while ( n-- )\n    {\n      char cmd[ 32 ];\n\n      scanf ( \" %s\", cmd );\n\n      if ( strcmp ( \"show\", cmd ) == 0 )\n      {\n        puts ( buf.back ( ).c_str ( ) );\n        continue ;\n      }\n      if ( strcmp ( \"click\", cmd ) == 0 )\n      {\n        list<C> *p;\n        int x, y;\n\n        scanf ( \" %d %d\", &x, &y );\n\n        p = &lis[ buf.back ( ) ];\n        for ( it = p->begin ( ); it != p->end ( ); ++it )\n        {\n          if ( x >= it->x1 && x <= it->x2\n            && y >= it->y1 && y <= it->y2 )\n          {\n            buf.push_back ( it->s );\n            cont.clear ( );\n            break ;\n          }\n        }\n\n        continue ;\n      }\n      if ( strcmp ( \"back\", cmd ) == 0 )\n      {\n        if ( buf.size ( ) >= 2 )\n        {\n          cont.push_front ( buf.back ( ) );\n          buf.pop_back ( );\n        }\n        continue ;\n      }\n      if ( strcmp ( \"forward\", cmd ) == 0 )\n      {\n        if ( cont.size ( ) >= 1 )\n        {\n          buf.push_back ( cont.front ( ) );\n          cont.pop_front ( );\n        }\n        continue ;\n      }\n    }\n  }\n\n  return ( EXIT_SUCCESS );\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 100000000\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P> PP;\n\nstatic const double EPS = 1e-8;\n\nconst int tx[] = {0,1,0,-1};\nconst int ty[] = {-1,0,1,0};\n\nclass Button{\npublic:\n\tint lu_x,lu_y,rl_x,rl_y;\n\tstring name;\n\tButton() : lu_x(0),lu_y(0),rl_x(0),rl_y(0),name(\"\"){}\n\tButton(int lu_x,int lu_y,int rl_x,int rl_y,string name): lu_x(lu_x),lu_y(lu_y),rl_x(rl_x),rl_y(rl_y),name(name){}\n};\n\nint main(){\n\tint n;\n\tint W,H;\n\t\n\twhile(~scanf(\"%d\",&n)){\n\t\tif(n==0) break;\n\t\tmap<string,vector<Button> > page;\n\t\tvector<string> browsed;\n\t\tscanf(\"%d %d\",&W,&H);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tstring name;\n\t\t\tint num;\n\t\t\tcin >> name >> num;\n\t\t\tfor(int j=0;j<num;j++){\n\t\t\t\tstring next;\n\t\t\t\tint lu_x,lu_y,rl_x,rl_y;\n\t\t\t\tcin >> lu_x >> lu_y >> rl_x >> rl_y >> next;\n\t\t\t\tpage[name].push_back(Button(lu_x,lu_y,rl_x,rl_y,next));\n\t\t\t\tif(browsed.size()==0) browsed.push_back(name);\n\t\t\t}\n\t\t}\n\n\t\tint m;\n\t\tint pos = 0;\n\t\tscanf(\"%d\",&m);\n\t\tfor(int i=0;i<m;i++){\n\t\t\tstring act;\n\t\t\tcin >> act;\n\t\t\tif(act==\"click\"){\n\t\t\t\tint x,y;\n\t\t\t\tcin >> x >> y;\n\t\t\t\tstring now = browsed[pos];\n\t\t\t\tfor(int j=0;j<page[now].size();j++){\n\t\t\t\t\tif((page[now][j].lu_x <= x && x <= page[now][j].rl_x)\n\t\t\t\t\t\t&& (page[now][j].lu_y <= y && y <= page[now][j].rl_y)){\n\t\t\t\t\t\t\t//printf(\"to %s\\n\",page[now][j].name.c_str());\n\n\t\t\t\t\t\t\tbrowsed.erase(browsed.begin()+pos+1,browsed.end());\n\t\t\t\t\t\t\tbrowsed.push_back(page[now][j].name);\n\t\t\t\t\t\t\tpos++;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(act==\"back\"){\n\n\t\t\t\tif(pos>0){\n\t\t\t\t\tpos--;\n\t\t\t\t\t//printf(\"back\\n\");\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(act==\"forward\"){\n\t\t\t\tif(pos<browsed.size()-1){\n\t\t\t\t\tpos++;\n\t\t\t\t\t//printf(\"forwardk\\n\");\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(act==\"show\"){\n\t\t\t\tcout << browsed[pos] << \"\\n\";\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <map>\nusing namespace std;\n\nstruct Button {\n  int x1,y1,x2,y2;\n  string s;\n  Button(){}\n  Button(int _x1,int _y1, int _x2, int _y2, string _s) {x1=_x1;y1=_y1;x2=_x2;y2=_y2;s=_s;}\n};\n\nint main() {\n  int n;\n  while(cin>>n,n) {\n    int w,h;\n    cin >> w >> h;\n    string str[n];\n    int b[n];\n    Button v[n][100];\n    map<string, int> ma;\n    for (int i=0;i<n;i++) {\n      cin >> str[i];\n      cin >> b[i];\n      ma.insert(make_pair(str[i], i));\n      for (int j=0;j<b[i];j++) {\n        int x1,y1,x2,y2;\n        cin >> x1>>y1>>x2>>y2;\n        string s;\n        cin >> s;\n        v[i][j] = Button(x1,y1,x2,y2,s);\n      }\n    }\n    int m;\n    cin >> m;\n    int p=0;\n    int p2=0;                   // ツ催妥・ツづ個つキツつキツづ淞づゥツペツーツジ\n    int bv[10000];\n    bv[0] = 0;\n    for (int i=0; i<m; i++) {\n      string s;\n      cin >> s;\n      if (s==\"click\") {\n        int x, y;\n        cin >> x >> y;\n        for (int j=0; j<b[p]; j++) {\n          if (v[bv[p]][j].x1<=x&&x<=v[bv[p]][j].x2 && v[bv[p]][j].y1<=y&&y<=v[bv[p]][j].y2) {\n            map<string, int>::iterator it = ma.find(v[p][j].s);\n            bv[++p] = it->second;\n            p2 = p;\n            break;\n          }\n        }\n      } else if (s==\"back\") {\n        if (p) p--;\n      } else if (s==\"forward\") {\n        if (p<p2) p++;\n      } else if (s==\"show\") {\n        cout << str[p] << endl;\n      }\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<map>\nusing namespace std;\n#define MAX_N 105\nstruct data{int to,ay,ax,by,bx;};\n\nint n,h,w;\nstring str[MAX_N];\nvector<data> t[MAX_N];\nvector<string> u[MAX_N];\nmap<string,int> mp;\n\nvoid init(){\n  for(int i=0;i<MAX_N;i++){\n    t[i].clear();\n    u[i].clear();\n  }\n  mp.clear();\n}\n\nint main(){\n  while(1){\n    cin>>n;\n    if(n==0)break;\n    init();\n    cin>>h>>w;\n    for(int i=0;i<n;i++){\n      int size;\n      cin>>str[i]>>size;\n      mp[str[i]]=i;\n      t[i].resize(size);\n      u[i].resize(size);\n      for(int j=0;j<size;j++)cin>>t[i][j].ay>>t[i][j].ax>>t[i][j].by>>t[i][j].bx>>u[i][j];\n    }\n    for(int i=0;i<n;i++)\n      for(int j=0;j<(int)t[i].size();j++)\n\tt[i][j].to=mp[u[i][j]];\n    vector<int> l,r;\n    string s;\n    int q,pos=0;\n    cin>>q;\n    while(q--){\n      cin>>s;\n      if(s==\"show\"){\n\tcout<<str[pos]<<endl;\n      }else if(s==\"back\"){\n\tif(l.size()){\n\t  int x=l[l.size()-1];\n\t  l.pop_back();\n\t  r.push_back(pos);\n\t  pos=x;\n\t}\n      }else if(s==\"forward\"){\n\tif(r.size()){\n\t  int x=r[r.size()-1];\n\t  r.pop_back();\n\t  l.push_back(pos);\n\t  pos=x;\n\t}\n      }else{\n\tint y,x;\n\tcin>>y>>x;\n\tint I;\n\tfor(I=0;I<(int)t[pos].size();I++){\n\t  data d=t[pos][I];\n\t  if(d.ay<=y&&y<=d.by&&d.ax<=x&&x<=d.bx){\n\t    l.push_back(pos);\n\t    r.clear();\n\t    pos=d.to;\n\t    break;\n\t  }\n\t}\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n#include<cassert>\nusing namespace std;\n#define MAX 100\n#define rep(i, n) for ( int i = 0; i < n; i++ )\n\nclass Button{\npublic:\n  int x1, y1, x2, y2;\n  string target;\n  Button(int x1, int y1, int x2, int y2, string target):x1(x1), y1(y1), x2(x2), y2(y2), target(target){}\n};\n\nclass Page{\npublic:\n  string name;\n  int H, W;\n  vector<Button> B;\n  Page(string name=\"\", int W=0, int H=0):name(name), W(W), H(H){}\n\n  string click(int x, int y){\n    rep(i, B.size()){\n      Button b = B[i];\n\n      if ( b.x1 <= x && x <= b.x2 &&\n\t   b.y1 <= y && y <= b.y2 ) {\n\t//assert( b.x1 != x );\n\t//assert( b.y1 != y );\n\t//assert( b.x2 != x );\n\t//assert( b.y2 != y );\n\treturn b.target;\n      }\n    }\n    return name;\n  }\n\n  bool over(int a, int b, int c, int d ){\n    int p1, p2, p3, p4;\n    if ( a <= c ){\n      p1 = a; p2 = b; p3 = c; p4 = d;\n    } else {\n      p1 = c; p2 = d; p3 = a; p4 = b;\n    }\n    return  p2 >= p3;\n  }\n  void buttonCheck(){\n    for ( int i = 0; i < (int)(B.size())-1; i++ ){\n      for ( int j = i+1; j < B.size(); j++ ){\n\tButton b1 = B[i];\n\tButton b2 = B[j];\n\t\n\tif ( over(b1.x1, b1.x2, b2.x1, b2.x2) &&\n\t     over(b1.y1, b1.y2, b2.y1, b2.y2) ){\n\t  assert(false);\n\t}\n\t\n      }\n    }\n  }\n};\n\nint n, H, W;\nPage P[MAX];\nmap<string, int> PI;\n\n\nvoid simulate(){\n  int q; cin >> q;\n  string com, target;\n  int history[10000], x, y, cur, top, forward;\n  top = forward = 0;\n\n  cur = 0;\n  history[top] = cur;\n\n  rep(p, q){\n    cin >> com;\n    if ( com == \"click\" ){\n      cin >> x >> y;\n      assert( 1 <= x && x <= W );\n      assert( 1 <= y && y <= H );\n      target = P[cur].click(x, y);\n      assert( PI.find(target) != PI.end());\n      if ( target != P[cur].name ){\n\tcur = PI[target];\n\thistory[++top] = PI[target];\n\tforward = top;\n      }\n    } else if ( com == \"forward\" ){\n      if ( top < forward){\n\ttop++;\n\tcur = history[top];\n      }\n    } else if ( com == \"back\"){\n      if ( top > 0 ){\n\ttop--;\n\tcur = history[top];\n      }\n    } else if ( com == \"show\" ){\n      cout << P[cur].name << endl;\n    } else assert(false);\n\n  }\n}\n\nmain(){\n  string name, target;\n  int  m, x1, y1, x2, y2;\n  while( cin >> n && n ){\n    cin >> W >> H;\n    assert( 1 <= n && n <= 100 );\n    rep(i, n){\n      cin >> name >> m;\n      assert( name.size() <= 20 );\n      char h = name[0];\n      assert( !('0' <= h && h <= '9') );\n      assert( m <= 100);\n      P[i] = Page(name, W, H);\n      rep(j, m){\n\tcin >> x1 >> y1 >> x2 >> y2 >> target;\n\tassert( 0 <= x1 && x1 <= W);\n\tassert( 0 <= x2 && x2 <= W);\n\tassert( 0 <= y1 && y1 <= H);\n\tassert( 0 <= y2 && y2 <= H);\n\tP[i].B.push_back(Button(x1, y1, x2, y2, target));\n      }\n      PI[name] = i;\n\n      P[i].buttonCheck();\n    }\n    simulate();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<algorithm>\n#include<iostream>\n#include<vector>\n#include<climits>\n#include<cfloat>\n\nusing namespace std;\n\nstruct point{\n  int x, y;\n};\n\nstruct button{\n  point ld,ru;\n  string name;\n};\n\nstruct page{\n  string name;\n  vector<button>btn;   \n}; \n\nint m,now,fg;\nvector<page> a;\npage nul;\nstatic page buf[1000000];\n\nvoid click(int c,int d){\n  \n  for(int i=0;i<buf[now].btn.size();i++)\n    if(buf[now].btn[i].ld.x <=c && buf[now].btn[i].ld.y <=d &&\n       buf[now].btn[i].ru.x >=c && buf[now].btn[i].ru.y >=d)\n      for(int j=0;j<a.size();j++)\n\tif(buf[now].btn[i].name==a[j].name){\n\t  buf[++now]=a[j];\n\t  fill(buf+now+1,buf+1000000,nul);\n\t  fg=0;\n\t  return ;\n\t}\n}\n\nint main(void){\n  int n;\n  int w,h,b;\n  point l,r;\n  page in;\n  button tmp;\n\n  while(cin >> n,n){\n  \n    a.clear();\n\n    cin >> w >> h;\n    \n    for(int j=0;j<n;j++){\n      cin >> in.name >> b;    \n      \n      for(int i=0;i<b;i++){\n\tcin >> tmp.ld.x >> tmp.ld.y >> tmp.ru.x >> tmp.ru.y >> tmp.name;\n\tin.btn.push_back(tmp);\n      }\n      a.push_back(in);\n    }\n\n    now=0,fg=0;\n    buf[0]=a[0];\n\n    cin >> m;\n\n    while(m--){\n      string s;\n      cin >> s;\n      if(s==\"click\"){\n\tint c,d;\n\tcin >> c >> d;\n\tclick(c,d);\n      }\n      else if(s==\"back\" && now>0)now--,fg++;\n      else if(s==\"forward\" && fg>0 && now < 1000000)now++,fg--;\n      else if(s==\"show\")cout << buf[now].name << endl;\n    }\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<vector>\n#define F first\n#define S second\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<P,P> P2;\ntypedef pair<P2,string> info;\n\nint main(){\n  int n,m,H,W,num,x1,x2,y1,y2;\n  string s,s2,now;\n  while(cin >> n && n){\n    multimap<string,info> web;\n    cin >> W >> H;\n    for(int j=0;j<n;j++){\n      cin >> s >> num;\n      if(j == 0)now = s;\n      for(int i=0;i<num;i++){\n\tcin >> x1 >> y1 >> x2 >> y2 >> s2;\n\tweb.insert(multimap<string,info>::value_type(s,info(P2(P(x1,y1),P(x2,y2)),s2)));\n      }\n    }\n    cin >> m;\n    string op,Back,Forward;\n    string *history = new string[10005];\n  \n    int nx,ny,Index=0,len=0;\n    int pointer = 0;\n    //history[Index++] = now;\n    history[pointer]=now;\n\n    //cout << \"now is \" << now << endl;\n    Back.clear();\n    Forward.clear();\n    for(int i=0;i<m;i++){\n      cin >> op;\n      if(op == \"click\"){\n\tcin >> nx >> ny;\n\tfor(int i=pointer+1;i<=len;i++){\n\t  history[i].clear();\n\t}\n\n\tbool found = false;\n\tmultimap<string,info>::iterator it = web.begin();\t\n\twhile(it != web.end() ){\n\t  if((*it).first == now){\n\n\t    if((*it).S.F.F.F <=nx && nx <=(*it).S.F.S.F && (*it).S.F.F.S <=ny && ny <= (*it).S.F.S.S){\n\t      now = (*it).S.S;\n\t      //history[Index++] = now; \n\t      history[++pointer] = now;\n\t      len++;\n\t      break;\n\t    }\n\n\t  }\n\t  it++;\n\t}\n\t//cout << now << endl;\n\t//cout << \"--------------\" << endl;\n \n      }\n      else if(op == \"show\")cout << now << endl;\n      else if(op == \"back\"){\n\t//if(Index-1 >=0 ){\n\t  //Index--;\n\t  //now = history[Index-1];\n\t  // cout << \"back to \"<< now << endl;\n\tif(pointer-1 >=0){\n\t  now = history[--pointer];\n\t}\n      }\n      else if(op == \"forward\"){\n\t//if(Index+1 <= len){\n\t//now = history[Index];\n\t//Index++;\n\tif(!history[pointer+1].empty()){\n\t//if(pointer+1 < len){\n\t  now = history[++pointer];\n\t}\n      }\n\n\n    }\n    /*\n    cout << \"---------\"<< endl;\n    for(int i=0;i<=len;i++){\n      cout << history[i] << endl;\n    }\n    */\n    delete [] history;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<algorithm>\n#include<iostream>\n#include<vector>\n#include<climits>\n#include<cfloat>\n\nusing namespace std;\n\nstruct point{\n  int x, y;\n};\n\nstruct button{\n  point l,r;\n  string name;\n};\n\nstruct page{\n  string name;\n  vector<button>btn;   \n}; \n\nint m,now;\nvector<page> a;\npage nowpage;\nstring buf[10001];\n\nvoid func(void){\n  for(int i=0;i<a.size();i++){\n    if(buf[now]==a[i].name){\n      nowpage=a[i];\n      return ;\n    }\n  }\n}\n\nvoid click(int c,int d){\n  \n  for(int i=0;i<nowpage.btn.size();i++){\n    if(nowpage.btn[i].l.x <=c && c<=nowpage.btn[i].r.x &&\n       nowpage.btn[i].l.y <=d && d<=nowpage.btn[i].r.y ){\n      fill(buf+now+1,buf+10001,\"\");\n      buf[++now]=nowpage.btn[i].name;\n      return ;\n    }\n  }\n}\n\n\nint main(void){\n  int n;\n  int w,h,b;\n  page in;\n  button tmp;\n\n  while(cin >> n,n){\n  \n    a.clear();\n    fill(buf,buf+10001,\"\");\n\n    cin >> w >> h;\n    \n    for(int i=0;i<n;i++){\n      in.btn.clear();\n      cin >> in.name >> b;    \n      if(i==0)buf[0]=in.name;\n\n      for(int j=0;j<b;j++){\n\tcin >> tmp.l.x >> tmp.l.y >> tmp.r.x >> tmp.r.y >> tmp.name;\n\tin.btn.push_back(tmp);\n      }\n      a.push_back(in);\n    }\n\n    now=0;\n\n    cin >> m;\n\n    while(m--){\n      string s;\n      cin >> s;\n\n      func();\n\n      if(s==\"click\"){\n\tint c,d;\n\tcin >> c >> d;\n\tclick(c,d);\n      }\n      else if(s==\"back\" && now>0)now--;\n      else if(s==\"forward\" && buf[now+1]!=\"\")now++;\n      else if(s==\"show\")cout << buf[now] << endl;\n\n    }\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n\nusing namespace std;\n\n#ifdef _MSC_VER\n#define __typeof__ decltype\ntemplate <class T> int __builtin_popcount(T n) { return n ? 1 + __builtin_popcount(n & (n - 1)) : 0; }\n#endif\n\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define popcount __builtin_popcount\n\n#define rep(i, n) for (int i = 0; i < n; ++i)\n\ntemplate <class T> void max_swap(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T& b) { a = min(a, b); }\n\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\n\nstruct Button\n{\n\tint x1, y1, x2, y2;\n\tstring name;\n\tbool include(int x, int y)\n\t{\n\t\treturn x1 <= x && x <= x2\n\t\t\t&& y1 <= y && y <= y2;\n\t}\n\tvoid input()\n\t{\n\t\tcin >> x1 >> y1 >> x2 >> y2 >> name;\n\t}\n};\nint main()\n{\n\tint n, m, w, h;\n\twhile (cin >> n, n)\n\t{\n\t\tcin >> w >> h;\n\n\t\tmap<string, vector<Button> > page;\n\t\tvector<string> buffer;\n\t\trep (i, n)\n\t\t{\n\t\t\tstring name;\n\t\t\tint b;\n\t\t\tcin >> name >> b;\n\t\t\tif (i == 0)\n\t\t\t\tbuffer.push_back(name);\n\n\t\t\twhile (b--)\n\t\t\t{\n\t\t\t\tpage[name].push_back(Button());\n\t\t\t\tpage[name].back().input();\n\t\t\t}\n\t\t}\n\n\t\tcin >> m;\n\t\tint pointer = 0;\n\t\twhile (m--)\n\t\t{\n\t\t\tstring& b = buffer[pointer];\n\n\t\t\tstring c;\n\t\t\tcin >> c;\n\t\t\tif (c[0] == 'c')\n\t\t\t{\n\t\t\t\tint x, y;\n\t\t\t\tcin >> x >> y;\n\t\t\t\tfor (int i = 0; i < page[b].size(); ++i)\n\t\t\t\t{\n\t\t\t\t\tif (page[b][i].include(x, y))\n\t\t\t\t\t{\n\t\t\t\t\t\t++pointer;\n\t\t\t\t\t\tbuffer.erase(buffer.begin() + pointer, buffer.end());\n\t\t\t\t\t\tbuffer.push_back(page[b][i].name);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (c[0] == 'b')\n\t\t\t\tpointer = max(0, --pointer);\n\t\t\telse if (c[0] == 'f')\n\t\t\t\tpointer = min((int)buffer.size() - 1, ++pointer);\n\t\t\telse if (c[0] == 's')\n\t\t\t\tcout << b << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n#define MAX 500\n\nstruct Page{\n  int sx,sy,tx,ty;\n  string next;\n  Page(int sx,int sy,int tx,int ty,string next)\n    : sx(sx),sy(sy),tx(tx),ty(ty),next(next) {}\n};\n\nvector<Page> vec[MAX];\n\nvoid init(){\n  for(int i = 0 ; i < MAX ; i++){\n    vec[i].clear();\n  }\n}\n\nint main(){\n  int N,W,H,b,sx,sy,tx,ty,p = 0;\n  string str[MAX],s;\n\n  while(cin >> N,N){\n    cin >> W >> H;\n    init();\n    for(int i = 0 ; i < N ; i++){\n      cin >> str[i] >> b;\n      for(int j = 0 ; j < b ; j++){\n        cin >> sx >> sy >> tx >> ty >> s;\n        vec[i].push_back(Page(sx,sy,tx,ty,s));\n      }\n    }\n    int m,w,h,now = 0;\n    vector<int> now_page;\n    now_page.push_back(now);\n    string next;\n    cin >> m;\n    for(int I = 0 ; I < m ; I++){\n      int size = now_page.size();\n      if(p == size-1 && now_page[size-1] != now){\n        now_page.push_back(now);\n        p++;\n        size = now_page.size();\n      }\n      cin >> s;\n      if(s == \"click\"){\n        bool found = false;\n        cin >> w >> h;\n        for(int i = 0 ; i < (int)vec[now_page[p]].size() ; i++){\n          sx = vec[now][i].sx, sy = vec[now][i].sy;\n          tx = vec[now][i].tx, ty = vec[now][i].ty;\n          next = vec[now][i].next;\n          if(sx <= w && w <= tx && sy <= h && h <= ty){\n            for(int j = 0 ; j < N ; j++){\n              if(str[j] == next){\n                now = j;\n                found = true;\n                break;\n              }\n            }\n          }\n          if(found) break;\n        }\n      }else if(s == \"show\"){\n        cout << str[now_page[p]] << endl;\n      }else if(s == \"back\"){\n        if(p > 0) p--;\n      }else{\n        if(p+1 < size) p++;\n      }\n    }\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\nstruct Button{\n\tint left,right,top,under,link_index;\n\tchar to_name[21];\n};\n\nstruct Page{\n\tchar name[21];\n\tvector<Button> B;\n};\n\nint num_page,W,H;\nint* buffer;\n\nbool strCmp(char* base, char* comp){\n\tint length1 = 0,length2 = 0;\n\tfor(int i=0;base[i] != '\\0'; i++)length1++;\n\tfor(int i=0;comp[i] != '\\0'; i++)length2++;\n\tif(length1 != length2)return false;\n\n\tfor(int i=0;base[i] != '\\0'; i++){\n\t\tif(base[i] != comp[i])return false;\n\t}\n\treturn true;\n}\n\n\nvoid func(){\n\n\tPage page[101];\n\n\tint pointer,buffer_size;\n\n\tint num_button;\n\n\tfor(int i = 0; i < num_page; i++){\n\t\tscanf(\"%s %d\",page[i].name,&num_button);\n\n\t\tfor(int k = 0; k < num_button;k++){\n\t\t\tButton button;\n\t\t\tscanf(\"%d %d %d %d %s\",&button.left,&button.top,&button.right,&button.under,button.to_name);\n\t\t\tpage[i].B.push_back(button);\n\t\t}\n\t}\n\n\tfor(int i = 0; i < num_page; i++){\n\t\tfor(int k = 0; k < page[i].B.size();k++){\n\t\t\tfor(int p = 0; p < num_page; p++){\n\t\t\t\tif(strCmp(page[i].B[k].to_name,page[p].name)){\n\t\t\t\t\tpage[i].B[k].link_index = p;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tbuffer[0] = 0;\n\tpointer = 0;\n\tbuffer_size = 1;\n\n\n\tint M,tmp_x,tmp_y;\n\tscanf(\"%d\",&M);\n\n\tchar order[10];\n\n\tfor(int loop = 0; loop < M; loop++){\n\t\tscanf(\"%s\",order);\n\n\t\tswitch(order[0]){\n\t\tcase 'c':\n\t\t\tscanf(\"%d %d\",&tmp_x,&tmp_y);\n\n\t\t\tfor(int i = 0; i < page[buffer[pointer]].B.size();i++){\n\t\t\t\tif(tmp_x >= page[buffer[pointer]].B[i].left && tmp_x <= page[buffer[pointer]].B[i].right &&\n\t\t\t\t\t\ttmp_y >= page[buffer[pointer]].B[i].top && tmp_y <= page[buffer[pointer]].B[i].under){\n\t\t\t\t\tbuffer_size = pointer+1;\n\t\t\t\t\tbuffer[buffer_size] = page[buffer[pointer]].B[i].link_index;\n\t\t\t\t\tbuffer_size++;\n\t\t\t\t\tpointer++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'b':\n\t\t\tif(pointer > 0)pointer--;\n\t\t\tbreak;\n\t\tcase 'f':\n\t\t\tif(pointer < buffer_size-1)pointer++;\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\tprintf(\"%s\\n\",page[buffer[pointer]].name);\n\t\t\tbreak;\n\t\t}\n\t}\n\n}\n\nint main(){\n\n\tbuffer = new int[50000];\n\n\twhile(true){\n\t\tscanf(\"%d\",&num_page);\n\t\tif(num_page == 0)break;\n\n\t\tscanf(\"%d %d\",&W,&H);\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <cstdio>\n#include <string>\n#include <map>\nusing namespace std;\n\nstruct page{\n    int sum;\n    int x1[110],y1[110],x2[110],y2[110];\n    int num[110];\n    string name[110];\n    string my_name;\n}a[110];\n\nchar s0[110];\nstring s;\n\nmap<string,int> g;\n\nint n,m;\nint x0,y0;\nint c[1100000];\nint top,now;\n\n\n\n\nint main()\n{\n   // freopen(\"in.txt\",\"r\",stdin);\n    while (cin>>n)\n    {\n        if (n==0) return 0;\n        cin>>x0>>y0;\n        g.clear();\n        for (int k=1;k<=n;k++)\n        {\n            scanf(\"%s\",s0);\n            s=s0;\n            g[s0]=k;\n            a[k].my_name=s0;\n            scanf(\"%d\",&a[k].sum);\n            for (int i=1;i<=a[k].sum;i++)\n            {\n                scanf(\"%d%d%d%d %s\",\n                      &a[k].x1[i],&a[k].y1[i],&a[k].x2[i],&a[k].y2[i],\n                      s0);\n                a[k].name[i]=s0;\n            }\n        }\n        for (int k=1;k<=n;k++)\n            for (int i=1;i<=a[k].sum;i++)\n                a[k].num[i]=g[a[k].name[i]];\n        top=1;\n        now=1;\n        c[1]=1;\n        cin>>m;\n        for (int tt=1;tt<=m;tt++)\n        {\n            scanf(\"%s\",s0);\n            if (strcmp(s0,\"show\")==0)\n            {\n                for (int i=0;i<a[c[now]].my_name.length();i++)\n                    printf(\"%c\",a[c[now]].my_name[i]);\n                puts(\"\");\n            }\n            if (strcmp(s0,\"click\")==0)\n            {\n                int xx,yy;\n                scanf(\"%d%d\",&xx,&yy);\n                int id=c[now];\n                int nx_num=0;\n                for (int k=1;k<=a[id].sum;k++)\n                {\n                    if (xx>=a[id].x1[k]&&xx<=a[id].x2[k]\n                      &&yy>=a[id].y1[k]&&yy<=a[id].y2[k])\n                    nx_num=k;\n                    if (nx_num) break;\n                }\n                if (nx_num!=0)\n                {\n                    c[++now]=a[id].num[nx_num];\n                    top=now;\n                }\n            }\n            if (strcmp(s0,\"back\")==0)\n            {\n                if (now>1)\n                    now--;\n            }\n            if (strcmp(s0,\"forward\")==0)\n            {\n                if (now<top)\n                    now++;\n            }\n        }\n\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n\n#define x first\n#define y second\n\nusing pi = pair<int,int>;\nusing P = pair<pi,pi>;\n\nstruct Page{\n    string name;\n\n    int m;\n    vector<P> b;\n    vector<string> l;\n\n    Page(){};\n\n    void READ(){\n        cin >>name >>m;\n        b = vector<P>(m);\n        l = vector<string>(m);\n        rep(i,m){\n            cin >>b[i].fi.x >>b[i].fi.y >>b[i].se.x >>b[i].se.y;\n            cin >>l[i];\n        }\n    }\n\n    int click(int x, int y){\n        rep(i,m){\n            if(b[i].fi.x<=x && x<=b[i].se.x && b[i].fi.y<=y && y<=b[i].se.y) return i;\n        }\n        return -1;\n    }\n};\n\nint main(){\n    int n;\n    while(cin >>n,n){\n        int W,H;\n        cin >>W >>H;\n\n        vector<Page> p(n);\n        rep(i,n) p[i].READ();\n\n        map<string,int> name2id;\n        rep(i,n) name2id[p[i].name] = i;\n\n        int Q;\n        cin >>Q;\n\n        vector<int> a(Q+2,-1);\n        int idx = 0;\n        a[0] = 0;\n\n        rep(qq,Q){\n            string s;\n            cin >>s;\n            if(s == \"click\"){\n                int X,Y;\n                cin >>X >>Y;\n                int res = p[a[idx]].click(X,Y);\n                if(res != -1){\n                    for(int j=idx+1; j<Q+2; ++j) a[j] = -1;\n                    a[idx+1] = name2id[p[a[idx]].l[res]];\n                    ++idx;\n                }\n            }\n            else if(s == \"back\"){\n                if(idx>0) --idx;\n            }\n            else if(s == \"forward\"){\n                if(a[idx+1] != -1) ++idx;\n            }\n            else{\n                // show\n                cout << p[idx].name << \"\\n\";\n            }\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <map>\nusing namespace std;\n\nstruct Button{\n\tint x1,x2,y1,y2;\n\tstring link;\n\tButton(int x1_, int y1_, int x2_, int y2_, string link_){\n\t\tx1 = x1_; y1 = y1_; x2 = x2_; y2 = y2_; link = link_;\n\t}\n\tButton(){}\n};\n\nvoid click(int x, int y, string& now, map<string, vector<Button> >& page, int& p, vector<string>& buff){\n\tvector<Button> B = page[now];\n\tstring to;\n\tfor(int i=0 ; i < B.size() ; i++ ){\n\t\tif( B[i].x1 <= x && x <= B[i].x2 && B[i].y1 <= y && y <= B[i].y2 ){\n\t\t\tto = B[i].link;\n\t\t}\n\t}\n\tif( !to.empty() ){\n\t\tnow = to;\n\t\twhile( p != buff.size()-1 ){\n\t\t\tbuff.pop_back();\n\t\t}\n\t\tbuff.push_back( to );\n\t\tp++;\n\t}\n}\n\nvoid back(string& now, int& p, const vector<string>& buff){\n\tif( p != 0 && !buff.empty() ){\n\t\tp--;\n\t\tnow = buff[p];\n\t}\n}\n\nvoid forward(string& now, int& p, const vector<string>& buff){\n\tif( p+1 < buff.size() ){\n\t\tp++;\n\t\tnow = buff[p];\n\t}\n}\n\nvoid show(const string& now){\n\tcout << now << endl;\n}\n\nint main(){\n\tint n;\n\twhile( cin >> n , n ){\n\t\tint w, h;\n\t\tmap<string, vector<Button> > page;\n\t\tvector<string> buff;\n\t\tstring now;\n\t\tint p=0;\n\t\t\n\t\tcin >> w >> h;\n\t\tfor(int i=0 ; i < n ; i++ ){\n\t\t\tint b;\n\t\t\tstring title;\n\t\t\tcin >> title >> b;\n\t\t\t\n\t\t\tif( i == 0 ){\n\t\t\t\tnow = title;\n\t\t\t\tbuff.push_back( now );\n\t\t\t}\n\t\t\tfor(int j=0 ; j < b ; j++ ){\n\t\t\t\tint x1, y1, x2, y2;\n\t\t\t\tstring link;\n\t\t\t\t\n\t\t\t\tcin >> x1 >> y1 >> x2 >> y2 >> link;\n\t\t\t\tpage[title].push_back( Button(x1, y1, x2, y2, link) );\n\t\t\t}\n\t\t}\n\t\tint m;\n\t\tcin >> m;\n\t\tfor(int i=0 ; i < m ; i++ ){\n\t\t\tstring s;\n\t\t\tcin >> s;\n\t\t\tif( s == \"click\" ){\n\t\t\t\tint x, y;\n\t\t\t\tcin >> x >> y;\n\t\t\t\tclick( x , y , now , page , p , buff );\n\t\t\t}else if( s == \"back\" ){\n\t\t\t\tback( now , p , buff );\n\t\t\t}else if( s == \"forward\" ){\n\t\t\t\tforward( now , p , buff );\n\t\t\t}else if( s == \"show\" ){\n\t\t\t\tshow( now );\n\t\t\t}\n\t\t}\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<vector>\n#define F first\n#define S second\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<P,P> P2;\ntypedef pair<P2,string> info;\n\nint main(){\n  int n,m,H,W,num,x1,x2,y1,y2;\n  string s,s2,now;\n  while(cin >> n && n){\n    multimap<string,info> web;\n    cin >> W >> H;\n    for(int j=0;j<n;j++){\n      cin >> s >> num;\n      if(j == 0)now = s;\n      for(int i=0;i<num;i++){\n\tcin >> x1 >> y1 >> x2 >> y2 >> s2;\n\tweb.insert(multimap<string,info>::value_type(s,info(P2(P(x1,y1),P(x2,y2)),s2)));\n      }\n    }\n    cin >> m;\n    string op,Back,Forward;\n    string *history = new string[105];\n  \n    int nx,ny,Index=0,len=0;\n    int pointer = 0;\n    //history[Index++] = now;\n    history[pointer]=now;\n\n    //cout << \"now is \" << now << endl;\n    Back.clear();\n    Forward.clear();\n    for(int i=0;i<m;i++){\n      cin >> op;\n      if(op == \"click\"){\n\tcin >> nx >> ny;\n\tfor(int i=pointer+1;i<=len;i++){\n\t  history[i].clear();\n\t}\n\n\tbool found = false;\n\tmultimap<string,info>::iterator it = web.begin();\t\n\twhile(it != web.end() ){\n\t  if((*it).first == now){\n\n\t    if((*it).S.F.F.F <=nx && nx <=(*it).S.F.S.F && (*it).S.F.F.S <=ny && ny <= (*it).S.F.S.S){\n\t      now = (*it).S.S;\n\t      //history[Index++] = now; \n\t      history[++pointer] = now;\n\t      len++;\n\t      break;\n\t    }\n\n\t  }\n\t  it++;\n\t}\n\t//cout << now << endl;\n\t//cout << \"--------------\" << endl;\n \n      }\n      else if(op == \"show\")cout << now << endl;\n      else if(op == \"back\"){\n\t//if(Index-1 >=0 ){\n\t  //Index--;\n\t  //now = history[Index-1];\n\t  // cout << \"back to \"<< now << endl;\n\tif(pointer-1 >=0){\n\t  now = history[--pointer];\n\t}\n      }\n      else if(op == \"forward\"){\n\t//if(Index+1 <= len){\n\t//now = history[Index];\n\t//Index++;\n\tif(pointer+1 < len){\n\t  now = history[++pointer];\n\t}\n      }\n\n\n    }\n    /*\n    cout << \"---------\"<< endl;\n    for(int i=0;i<=len;i++){\n      cout << history[i] << endl;\n    }\n    */\n    delete [] history;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <set>\n \nusing namespace std;\n \n#define f first\n#define s second\n \ntypedef pair<int, int> P;\ntypedef pair<P, P> P2;\ntypedef pair<P2, string> P3;\n \nint main(){\n  int n;\n  int W, H;\n   \n  while(cin >> n, n){\n    cin >> W >> H;\n    \n    map<string, int> n_link;\n    map<string, vector<P3> > page;\n    vector<P3> link;\n    string page_name;\n    string now;\n    int n_button;\n     \n    for(int i = 0 ; i < n ; i++){\n      cin >> page_name >> n_button;\n      n_link.insert(make_pair(page_name, n_button));\n      if(i == 0) now = page_name;\n      for(int j = 0 ; j < n_button ; j++){\n\tP3 tmp;\n\tcin >> tmp.f.f.f >> tmp.f.f.s >> tmp.f.s.f >> tmp.f.s.s >> tmp.s;\n\tlink.push_back(tmp);\n      }\n      page.insert(make_pair(page_name, link));\n      link.clear();\n    }\n     \n    //cout << page[\"profile\"][1].s << endl;\n\n    int n_op, x, y;\n    string op;\n    vector<string> history;\n    history.push_back(now);\n    int n_now = 0;\n    cin >> n_op;\n    cin.ignore();\n    while(n_op--){\n      getline(cin, op);\n\n      if(op[0] == 'c'){ // click\n\tstring tmp1=\"\", tmp2=\"\";\n\tint i;\n\tfor(i = 6 ; op[i] != ' ' ; i++) tmp1 += op[i];\n\tfor( ; i < op.size() ; i++) tmp2 += op[i];\n     \n\tx = atoi(tmp1.c_str());\n\ty = atoi(tmp2.c_str());\n\t\n\tfor(i = 0 ; i < page[now].size() ; i++){\n\t  if((page[now][i].f.f.f <= x && x <= page[now][i].f.s.f) &&\n\t     (page[now][i].f.f.s <= y && y <= page[now][i].f.s.s)){\n\t    now = page[now][i].s;\n\t    \n\t    for(i = history.size()-1 ; i > n_now ; i--){ // when back click\n\t      history.pop_back();\n\t    }\n\t    n_now = i;\n\t    history.push_back(now);\n\t    n_now++;\n\t  }\n\t}\n      } // click end\n      \n      if(op == \"show\") cout << history[n_now] << endl;\n      if(op == \"back\"){\n\tif(n_now == 0) continue;\n\tn_now--;\n\tnow = history[n_now];\n      }\n      if(op == \"forward\"){\n\tif(n_now == history.size()-1) continue;\n\tn_now++;\n\tnow = history[n_now];\n      }\n    }\n    page.clear();\n    history.clear();\n    link.clear();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <map>\n#include <vector>\nusing namespace std;\n\nstruct Button {\n  int sx, sy, ex, ey;\n  string to;\n  bool isHit(int x, int y) {\n    return ( sx <= x && x <= ex &&\n\t     sy <= y && y <= ey );\n  }\n};\n\nstruct Page {\n  vector<Button> buttons;\n  string click(int x, int y) {\n    for(int i = 0; i < buttons.size(); ++i) {\n      if(buttons[i].isHit(x,y)) return buttons[i].to;\n    }\n    return \"\";\n  }\n};\n\nint W, H;\nmap<string, Page> Pages;\nvector<string> Buff;\nint pi, br;\n\nint main() {\n  int n, m;\n  string np;\n  while(cin >> n && n) {\n    Pages.clear();\n    np = \"\";\n    cin >> W >> H;\n    while(n--) {\n      Page p;\n      string name;\n      int b;\n      cin >> name >> b;\n      if(np == \"\") np = name;\n      while(b--) {\n\tButton bn;\n\tcin >> bn.sx >> bn.sy >> bn.ex >> bn.ey >> bn.to;\n\tp.buttons.push_back(bn);\n      }\n      Pages[name] = p;\n    }\n    cin >> m;\n    Buff.resize(m*2);\n    Buff[0] = np;\n    pi = 0;\n    br = 1;\n    while(m--) {\n      string op;\n      cin >> op;\n      if(op == \"click\") {\n\tint x, y;\n\tcin >> x >> y;\n\tstring to = Pages[Buff[pi]].click(x,y);\n\tif(to != \"\" && Pages.count(to)) {\n\t  ++pi;\n\t  Buff[pi] = to;\n\t  br = pi+1;\n\t}\n      } else if(op == \"back\") {\n\tif(pi != 0) {\n\t  --pi;\n\t}\n      } else if(op == \"forward\") {\n\tif(pi+1 != br) {\n\t  ++pi;\n\t}\n      } else if(op == \"show\") {\n\tcout << Buff[pi] << endl;\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<algorithm>\n#include<iostream>\n#include<vector>\n#include<climits>\n#include<cfloat>\n\nusing namespace std;\n\ndouble EPS = 1e-10;\n\ndouble add(double a, double b){\n  if(abs(a+b) < EPS * (abs(a)+abs(b)))return 0;\n  return a+b;\n}\n\nstruct point{\n  double x, y;\n  point(){}\n  point(double x,double y) : x(x) , y(y){}\n\n  point operator + (point p){\n    return point(add(x,p.x), add(y,p.y));\n  }\n\n  point operator - (point p){\n    return point(add(x,-p.x), add(y,-p.y));\n  }\n\n  point operator * (double d){\n    return point(x*d,y*d);\n  }\n\n  point operator / (double d){\n    return point(x/d,y/d);\n  }\n  \n  bool operator == ( const point &p ) const {\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n};\n\nstruct button{\n  point ld,ru;\n  string name;\n};\n\nstruct page{\n  string name;\n  vector<button>btn;   \n}; \n\nint tail;\npage stk[1000000];\n\nvoid push(page a){\n  stk[++tail]=a;\n}\n\npage pop(void){\n  tail--;\n  return stk[tail];\n}\n\nint main(void){\n  int n;\n  int w,h,b;\n  point l,r;\n  page in;\n  vector<page> a;\n  button tmp;\n\n  while(cin >> n,n){\n  \n    a.clear();\n\n    cin >> w >> h;\n    \n    for(int j=0;j<n;j++){\n      cin >> in.name >> b;    \n      \n      for(int i=0;i<b;i++){\n\tcin >> tmp.ld.x >> tmp.ld.y >> tmp.ru.x >> tmp.ru.y >> tmp.name;\n\tin.btn.push_back(tmp);\n      }\n      a.push_back(in);\n    }\n\n    int m,now=0;\n\n    cin >> m;\n    tail=0;\n    int fg=0;\n    push(a[0]);\n    while(m--){\n      string s;\n      cin >> s;\n      if(s==\"click\"){\n\tint c,d;\n\tcin >> c >> d;\n\t\n\tfor(int i=0;i<stk[tail].btn.size();i++){\n\t  if(stk[tail].btn[i].ld.x <=c &&\n\t     stk[tail].btn[i].ld.y <=d &&\n\t     stk[tail].btn[i].ru.x >=c &&\n\t     stk[tail].btn[i].ru.y >=d){\n\t    for(int j=0;j<a.size();j++){\n\t      if(stk[tail].btn[i].name==a[j].name){\n\t\tpush(a[j]);\n\t\tfg=0;\n\t      }\n\t    }\n\t  }\n\t}\n      }\n      else if(s==\"back\" && tail>0){\n\ttail--;\n\tfg++;\n      }\n      else if(s==\"forward\" && fg>0 && tail-1 < 1000000)tail++,fg--;\n      else if(s==\"show\")cout << stk[tail].name << endl;\n    }\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<deque>\n#include<string>\n#include<vector>\n#include<iostream>\n\n#define\tpb\tpush_back\n\nusing namespace std;\n\nstruct Rect{\n\tint l,r,u,b;\n\tbool isInside(int x,int y){\n\t\treturn (l<=x && x<=r && u<=y && y<=b);\n\t}\n};\n\nstruct Button:Rect{\n\tstring link;\n};\n\nstruct Page{\n\tstring title;\n\tint bnum;\n\tvector<Button> btn;\n};\n\nint main(){\n\tfor(int n;cin>>n,n;){\n\t\tint w,h;\tcin>>w>>h;\n\t\tPage pg[100];\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin>>pg[i].title>>pg[i].bnum;\n\t\t\tpg[i].btn=vector<Button>(pg[i].bnum);\n\t\t\tfor(int j=0;j<pg[i].bnum;j++){\n\t\t\t\tcin>>pg[i].btn[j].l>>pg[i].btn[j].u\n\t\t\t\t   >>pg[i].btn[j].r>>pg[i].btn[j].b>>pg[i].btn[j].link;\n\t\t\t}\n\t\t}\n\n\t\tmap<string,int> f;\n\t\tfor(int i=0;i<n;i++)\tf[pg[i].title]=i;\n\n\t\tint m;\tcin>>m;\n\t\tdeque<Page> dq;\tdq.pb(pg[0]);\n\t\tint ptr=0;\n\t\twhile(m--){\n\t\t\tstring cmd;\tcin>>cmd;\n\t\t\tif(cmd==\"click\"){\n\t\t\t\tint x,y;\tcin>>x>>y;\n\t\t\t\tint on=-1;\n\t\t\t\tfor(int i=0;i<dq[ptr].bnum;i++){\n\t\t\t\t\tif(dq[ptr].btn[i].isInside(x,y)){\n\t\t\t\t\t\ton=f[dq[ptr].btn[i].link];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(~on){\n\t\t\t\t\tdq.erase(dq.begin()+ptr+1,dq.end());\n\t\t\t\t\tdq.pb(pg[on]);\n\t\t\t\t\tptr++;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(cmd==\"back\"){\n\t\t\t\tif(ptr>0)\tptr--;\n\t\t\t}\n\t\t\telse if(cmd==\"forward\"){\n\t\t\t\tif(ptr<dq.size()-1)\tptr++;\n\t\t\t}\n\t\t\telse\tcout<<dq[ptr].title<<endl;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <map>\n#include <vector>\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<P,P> PP;\n\nclass page{\npublic:\n  PP p;\n  int n;\n  page(PP p=PP(P(0,0),P(0,0)), int n=0):p(p),n(n){}\n};\n\nint main(){\n  int n;\n  while(cin >> n && n){\n    map<string,int> m;\n    map<int,string> m2;\n    int h,w,aa=0;\n    vector<page> v[100];\n    cin >> h >> w;\n    for(int i=0;i<n;i++){\n      string str;\n      int a;\n      cin >> str >> a;\n      if(m.find(str) == m.end()){\n        m[str] = aa;\n        m2[aa++] = str;\n      }\n      for(int j=0;j<a;j++){\n        PP p;\n        string str2;\n        cin >> p.first.first >> p.first.second >> p.second.first >> p.second.second >> str2;\n        if(m.find(str2) == m.end()){\n          m[str2] = aa;\n          m2[aa++] = str2;\n        }\n        v[m[str]].push_back(page(p,m[str2]));\n      }\n    }\n\n    int n2, curr=0;\n    vector<int> v2;\n    v2.push_back(0);\n    cin >> n2;\n    for(int i=0;i<n2;i++){\n      string str;\n      cin >> str;\n      if(str == \"click\"){\n        int x,y;\n        cin >> x >> y;\n        int now = v2[curr];\n        for(int j=0;j<v[now].size();j++){\n          if(v[now][j].p.first.first <= x && x <= v[now][j].p.second.first && v[now][j].p.first.second <= y && y <= v[now][j].p.second.second){\n            curr++;\n            while(curr < v2.size()) v2.pop_back();\n            v2.push_back(v[now][j].n);\n            break;\n          }\n        }\n      } else if(str == \"back\") curr = (curr <= 0) ? curr : curr-1;\n      else if(str == \"forward\") curr = (curr >= v2.size()-1) ? curr : curr+1;\n      else cout << m2[v2[curr]] << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\n#include <map>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nconst int INF = 1<<29;\n\nstruct P {\n  int x1,y1,x2,y2;\n  string s;\n  P(int x1,int y1,int x2,int y2, string s) : x1(x1),y1(y1),x2(x2),y2(y2),s(s) {}\n};\n\nint main() {\n  int n;\n  while(cin>>n,n) {\n    int w,h;\n    cin >> w>>h;\n    string title[n];\n    vector<P> button[n];;\n    map<string, int> rid;\n    REP(i,n) {\n      cin >> title[i];\n      rid[title[i]] = i;\n      int m;\n      cin >> m;\n      REP(j,m) {\n        int ax,ay,bx,by;\n        cin>>ax>>ay>>bx>>by;\n        string s;\n        cin >> s;\n        button[i].push_back(P(ax,ay,bx,by,s));\n      }\n    }\n    int m;\n    cin >> m;\n    int now = 0;\n    int page[100000] = {};\n    int maxpage = 0;\n    while(m--) {\n      string s;\n      cin >> s;\n      if (s == \"click\") {\n        int x, y;\n        cin >> x >> y;\n        FOR(it, button[now]) {\n          if (it->x1<=x && x<=it->x2 && it->y1<=y && y<=it->y2) {\n            page[++now] = rid[it->s];\n            maxpage = now;\n            break;\n          }\n        }\n      } else if (s == \"show\"){\n        cout << title[now] << endl;\n      } else if (s == \"back\") {\n        if (now>0)\n          now--;\n      } else if (s == \"forward\") {\n        if (now<maxpage)\n          now++;\n      }\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "// 8-11.cpp : 螳壻ケ画而蛻カ蜿ー蠎皮畑遞句コ冗噪蜈・蜿」轤ケ縲?//\n\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<iomanip>\n using namespace std;\n struct page\n {\n\t string name;\n\t int but;\n\t long long x1[200],x2[200],y1[200],y2[200];\n\t string forw,next;\n };\n struct page a[1000];\n\n string s[100000];\nint main()\n{\n\n\tlong long n,w,h;\n\twhile(cin>>n && n!=0)\n\t{\n\t\tcin>>w>>h;\n\t\t\n\t\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n           cin>>a[i].name>>a[i].but;\n\t\t   for(int j=1;j<=a[i].but;j++)\n\t\t\t   cin>>a[i].x1[j]>>a[i].y1[j]>>a[i].x2[j]>>a[i].y2[j]>>a[i].next;\n\t\t}\n        \n\t\tint m;\n\t\tcin>>m;\n\t\tstring ss;\n\t\tlong long t=1;\n\t\ts[1]=a[1].name;\n\t\tlong long max=1;\n\n\t\twhile(m--)\n\t\t{\n\t\t   long long x,y;\n\t\t\tcin>>ss;\n\t\t\t\t\t\n\t\t\tif(ss==\"click\"){\n\t\t\t\t          cin>>x>>y;\n\t\t\t\t\t\t  for(int i=1;i<=a[t].but;i++)\n\t\t\t\t\t\t\t  if(x>=a[t].x1[i] &&x<=a[t].x2[i] &&y>=a[t].y1[i] &&y<=a[t].y2[i]) {t++;max=t;s[t]=a[t-1].next;}\n\t\t\t               }      \n\t\t\t\t\t\t\t  \n\t\t\t\t\t\t \n\t\t\tif(ss==\"show\"){cout<<s[t]<<endl;  }\n\t\t\tif(ss==\"back\"){if(t>1) t--; }\n\n\t\t\tif(ss==\"forward\"){if(t<max) t++;}\n \n\t\t\t\n\t\t}\n\n\n\t\t\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <utility>\n#include <map>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nclass Nx{\n\tpublic:\n\tP p, q;\n\tstring name;\n\tNx() {}\n\tNx(string _name, P _p, P _q): name(_name), p(_p), q(_q) {}\n\t\n\tbool comp(int x, int y){\n\t\treturn (p.first <= x && x <= q.first && p.second <= y && y <= q.second);\n\t}\n};\n\nclass St{\n\tpublic:\n\tstring name;\n\tvector<Nx> vec;\n\tSt() {}\n\tSt(string _name): name(_name) {}\n\t\n\tstring check(int x, int y){\n\t\tstring str = \"\";\n\t\tfor(int i = 0; i < vec.size(); i++){\n\t\t\tif(vec[i].comp(x, y)){\n\t\t\t\tstr = vec[i].name;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn str;\n\t}\n};\n\nint main()\n{\n\tint n, m, w, h, s, t, u, v, a[10000];\n\tstring str, str2;\n\t\n\twhile(cin>>n && n){\n\t\tvector<St> vec;\n\t\tmap<string,int> mpp;\n\t\tcin >> w >> h;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tcin >> str >> m;\n\t\t\tmpp[str] = i;\n\t\t\tvec.push_back(St(str));\n\t\t\twhile(m--){\n\t\t\t\tcin >> s >> t >> u >> v >> str;\n\t\t\t\tvec[i].vec.push_back(Nx(str, P(s, t), P(u, v)));\n\t\t\t}\n\t\t}\n\t\tcin >> n;\n\t\tt = 0;\n\t\tfill(a, a+10000, -1);\n\t\ta[0] = 0;\n\t\tstr2 = vec[0].name;\n\t\twhile(n--){\n\t\t\tcin >> str;\n\t\t\tif(str == \"click\"){\n\t\t\t\tcin >> u >> v;\n\t\t\t\tstring tmp = vec[t].check(u, v);\n\t\t\t\tif(tmp.size() > 0){\n\t\t\t\t\tt++;\n\t\t\t\t\tfill(a+t, a+10000, -1);\n\t\t\t\t\ta[t] = mpp[tmp];\n\t\t\t\t\tstr2 = tmp;\n\t\t\t\t}\n\t\t\t} else if(str == \"show\"){\n\t\t\t\tcout << str2 << endl;\n\t\t\t} else if(str == \"back\"){\n\t\t\t\tif(t > 0){\n\t\t\t\t\tt--;\n\t\t\t\t\tstr2 = vec[a[t]].name;\n\t\t\t\t}\n\t\t\t} else if(str == \"forward\"){\n\t\t\t\tif(a[t+1] != -1){\n\t\t\t\t\tt++;\n\t\t\t\t\tstr2 = vec[a[t]].name;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\n\nint b[100], x1[100][100], Y1[100][100], x2[100][100], y2[100][100];\nstring link[100][100];\nmap<string, int>mp;\nint main() {\n\tint n;\n\twhile (scanf(\"%d\", &n), n) {\n\t\tint w, h; scanf(\"%d%d\", &w, &h);\n\t\tvector<string>v;\n\t\trep(i, n) {\n\t\t\tstring s; cin >> s >> b[i]; mp[s] = i;\n\t\t\tif (i == 0)v.push_back(s);\n\t\t\trep(j, b[i])cin >> x1[i][j] >> Y1[i][j] >> x2[i][j] >> y2[i][j] >> link[i][j];\n\t\t}\n\t\tint pos = 0;\n\t\tint m; scanf(\"%d\", &m);\n\t\trep(i, m) {\n\t\t\tstring s; cin >> s;\n\t\t\tif (s == \"click\") {\n\t\t\t\tint x, y; cin >> x >> y;\n\t\t\t\tint a = mp[v.back()];\n\t\t\t\trep(i, b[a]) {\n\t\t\t\t\tif (x1[a][i] <= x&&x <= x2[a][i] && Y1[a][i] <= y&&y <= y2[a][i]) {\n\t\t\t\t\t\tif (pos + 1 < v.size())v.erase(v.begin() + pos + 1, v.end());\n\t\t\t\t\t\tv.push_back(link[a][i]); pos = v.size() - 1; break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (s == \"back\") {\n\t\t\t\tif (pos)pos--;\n\t\t\t}\n\t\t\tif (s == \"forward\") {\n\t\t\t\tif (pos < v.size() - 1)pos++;\n\t\t\t}\n\t\t\tif (s == \"show\")cout << v[pos] << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <map>\n#include <iostream>\nusing namespace std;\ntypedef pair<\n\tpair<\n\t\tpair<int,int>,\n\t\tpair<int,int>\n\t>,string\n>button;\ntypedef vector<button>buttonlist;\n\nmain(){\n\tint N,n,x1,y1,x2,y2,cur,i;\n\tstring s,t;\n\tfor(;cin>>N>>x1>>y1;){\n\t\tmap<string,buttonlist>m;\n\t\tvector<string>visit;\n\t\tfor(cur=-1;N;N--){\n\t\t\tbuttonlist v;\n\t\t\tfor(cin>>s>>n;n;n--){\n\t\t\t\tcin>>x1>>y1>>x2>>y2>>t;\n\t\t\t\tv.push_back(make_pair(make_pair(make_pair(x1,x2),make_pair(y1,y2)),t));\n\t\t\t}\n\t\t\tm[s]=v;\n\t\t\tif(cur==-1)visit.push_back(s),cur=0;\n\t\t}\n\t\t\n\t\tfor(cin>>N;N;N--){\n\t\t\tcin>>s;\n\t\t\tif(s==\"show\")cout<<visit[cur]<<endl;\n\t\t\tif(s==\"back\"){if(cur>0)cur--;}\n\t\t\tif(s==\"forward\"){if(cur<visit.size()-1)cur++;}\n\t\t\tif(s==\"click\"){\n\t\t\t\tcin>>x1>>y1;\n\t\t\t\ts=visit[cur];\n\t\t\t\tbuttonlist v=m[s];\n\t\t\t\tfor(i=0;i<v.size();i++){\n\t\t\t\t\tif(\n\t\t\t\t\t\tv[i].first.first.first<=x1&&x1<=v[i].first.first.second &&\n\t\t\t\t\t\tv[i].first.second.first<=y1&&y1<=v[i].first.second.second\n\t\t\t\t\t){\n\t\t\t\t\t\tfor(;cur<visit.size()-1;)visit.erase(visit.begin()+cur+1);\n\t\t\t\t\t\tvisit.push_back(v[i].second);\n\t\t\t\t\t\tcur++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <set>\n\nusing namespace std;\n\n#define f first\n#define s second\n\ntypedef pair<int, int> P;\ntypedef pair<P, P> P2;\ntypedef pair<P2, string> P3;\n\nint main(){\n  int n;\n  int W, H;\n  \n  while(cin >> n, n){\n    cin >> W >> H;\n    \n    map<string, vector<P3> > page;\n    vector<P3> link;\n    string page_name;\n    string now;\n    int n_button;\n    \n    for(int i = 0 ; i < n ; i++){\n      cin >> page_name >> n_button;\n      if(i == 0) now = page_name;\n      for(int j = 0 ; j < n_button ; j++){\n\tP3 tmp;\n\tcin >> tmp.f.f.f >> tmp.f.f.s >> tmp.f.s.f >> tmp.f.s.s >> tmp.s;\n\tlink.push_back(tmp);\n      }\n      page.insert(make_pair(page_name, link));\n    }\n    \n    int n_op, x, y;\n    string op;\n    vector<string> history;\n    history.push_back(now);\n    int n_now = 0;\n    cin >> n_op;\n    cin.ignore();\n    while(n_op--){\n      getline(cin, op);\n      \n      if(op[0] == 'c'){ // click\n\tstring tmp1=\"\", tmp2=\"\";\n\tint i;\n\tfor(i = 6 ; op[i] != ' ' ; i++) tmp1 += op[i];\n\tfor( ; i < op.size() ; i++) tmp2 += op[i];\n\t\n\tx = atoi(tmp1.c_str());\n\ty = atoi(tmp2.c_str());\n\t\n\tfor(i = 0 ; i < page[now].size() ; i++){\n\t  if((page[now][i].f.f.f <= x && x <= page[now][i].f.s.f) &&\n\t     (page[now][i].f.f.s <= y && y <= page[now][i].f.s.s)){\n\t    now = page[now][i].s;\n\t    history.push_back(now);\n\t    n_now++;\n\t  }\n\t}\n      } // click end\n    \n      if(op == \"show\") cout << history[n_now] << endl;\n      if(op == \"back\"){\n\tif(n_now == 0) continue;\n\tn_now--;\n      }\n      if(op == \"forward\"){\n\tif(n_now == history.size()-1) continue;\n\tn_now++;\n      }\n    }\n    page.clear();\n    history.clear();\n    link.clear();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\nconst int MAX = 110;\n\nstring data[MAX];\nint W,H,N;\n\nstruct Button{\n  int lx,rx,ly,ry;\n  string name;\n};\n\nmap<string,vector<Button> > M;\n\n\nvoid init(){\n  M.clear();\n  fill(data,data+MAX,\"\");\n}\n\nvoid input(){\n  cin >> W >> H;\n  for(int i = 0; i < N; i++){\n    string s;\n    int num;\n    cin >> s >> num;\n    if(i == 0) data[0] = s;\n\n    for(int j = 0; j < num; j++){\n      Button B;\n      cin >> B.lx >> B.ly >> B.rx >> B.ry >> B.name;\n      M[s].push_back(B);\t\n    }\n\n  }\n}\n\nvoid solve(){\n  int num;\n  cin >> num;\n  int index = 0;\n\n\n  while(num--){\n    string op;\n    cin >> op;\n    if(op == \"click\"){\n      int x,y;\n      cin >> x >> y;\n      string now = data[index];\n\n      for(int i = 0; i < M[now].size(); i++){\n\tif(M[now][i].lx <= x && x <= M[now][i].rx && M[now][i].ly <= y && y <= M[now][i].ry){\n\t  data[++index] = M[now][i].name;\n\t  fill(data+index+1,data+MAX,\"\");\n\t  break;\n\t}\n\n      }\n\n    }else if(op == \"back\" && index > 0) index--;\n    else if(op == \"forward\" && data[index+1] != \"\") index++;\n    else if(op == \"show\") cout << data[index] << endl;\n  }\n}\n\nint main(){\n\n  while(cin >> N && N){\n    input();\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<map>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nstruct State { string nm; int rx, ry, sx, sy; };\nint n, W, H; map<string, vector<State>>M;\nint main() {\n\twhile (true) {\n\t\tcin >> n; if (n == 0)break; cin >> W >> H; M.clear();\n\t\tstring R;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tstring Y; int p; cin >> Y >> p; if (i == 0)R = Y;\n\t\t\tfor (int j = 0; j < p; j++) {\n\t\t\t\tState ST; cin >> ST.rx >> ST.ry >> ST.sx >> ST.sy >> ST.nm;\n\t\t\t\tM[Y].push_back(ST);\n\t\t\t}\n\t\t}\n\t\tint q; cin >> q; vector<string>D; D.push_back(R); int e = 0;\n\t\tfor (int i = 0; i < q; i++) {\n\t\t\tstring W; cin >> W;\n\t\t\tif (W == \"show\") { cout << D[e] << endl; }\n\t\t\tif (W == \"forward\") { e = min(e + 1, (int)D.size() - 1); }\n\t\t\tif (W == \"back\") { e = max(0, e - 1); }\n\t\t\tif (W == \"click\") {\n\t\t\t\tint r1, r2; cin >> r1 >> r2;\n\t\t\t\tfor (int j = 0; j < M[D[e]].size(); j++) {\n\t\t\t\t\tState Q = M[D[e]][j];\n\t\t\t\t\tif (Q.rx <= r1 && r1 <= Q.sx && Q.ry <= r2 && r2 <= Q.sy) {\n\t\t\t\t\t\twhile (D.size() > e + 1)D.pop_back();\n\t\t\t\t\t\tD.push_back(Q.nm); e++; break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <map>\n#include <sstream>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\nclass B{\npublic:\n  int x1, y1, x2, y2;\n  string to;\n  B(){}\n  B(int x1, int y1, int x2, int y2, string to) : x1(x1), y1(y1), x2(x2), y2(y2), to(to) {}\n};\n\nint n, h, w, b[100], m;\nvector<B> buttons[100];\nstring name[100];\nmap<string, int> stoi;\n\nint clicked(int x, int y, int p){\n  for(int i=0;i<b[p];i++){\n    B but = buttons[p][i];\n    if(but.x1 <= x && x <= but.x2 && but.y1 <= y && y <= but.y2) return stoi[but.to];\n  }\n  return -1;\n}\n\nmain(){\n  while(cin >> n && n){\n    stoi.clear();\n    for(int i=0;i<n;i++) buttons[i].clear();\n    cin >> w >> h;\n    for(int i=0;i<n;i++){\n      cin >> name[i];\n      cin >> b[i];\n      stoi[name[i]] = i;\n      for(int j=0;j<b[i];j++){\n        B in;\n        cin >> in.x1 >> in.y1 >> in.x2 >> in.y2 >> in.to;\n        buttons[i].push_back(in);\n      }\n    }\n    cin >> m;\n    int p = 0;\n    vector<int> buf;\n    buf.push_back(0);\n    for(int i=0;i<m;i++){\n      string str;\n      cin >> str;\n      if(str == \"forward\"){\n        if(p+1 < buf.size()) p++;\n      }else if(str == \"back\"){\n        if(p != 0) p--;\n      }else if(str == \"show\"){\n        cout << name[buf[p]] << endl;\n      }else{\n        int x, y;\n        cin >> x >> y;\n        int next = clicked(x, y, buf[p]);\n        if(next == -1) continue;\n        if(p+1 != buf.size()) buf.erase(buf.begin() + p+1);\n        buf.push_back(next);\n        p++;\n      }\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "/* \n * File:   main.cpp\n * Author: æè¯º\n *\n * Created on 2011å¹´8æ27æ¥, ä¸å12:34\n */\n\n#include <cstdlib>\n#include <cstdio>\n#include <algorithm>\n#include <string>\n#include <iostream>\n#include <vector>\n#include <map>\n#include <stack>\n#include <cassert>\nusing namespace std;\nclass Page;\n\nstruct Point {\n    int x, y;\n};\n\nclass Rectangle {\npublic:\n    int left, right;\n    int buttom, top;\n\n    Rectangle() { }\n\n    Rectangle(int l, int t, int r, int b) : left(l), top(t), right(r), buttom(b) {\n        if (left > right)swap(left, right);\n        if (top > buttom)swap(top, buttom);\n    }\n\n    bool in(const Point &p) {\n        //cerr << left << right << top << buttom << endl;\n        //cerr << p.x << p.y << endl;\n        return left <= p.x && p.x <= right && top <= p.y && p.y <= buttom;\n    }\n};\n\nclass Link {\npublic:\n    Rectangle dest;\n    string destname;\n\n    Link() { }\n\n    Link(const Rectangle & rect, const string & s) : dest(rect), destname(s) { }\n};\n\nclass Page {\npublic:\n    string name;\n    vector<Link>link;\n\n    string operator[](const Point & p) {\n        int i;\n        for (i = 0; i < link.size(); ++i) {\n            if (link[i].dest.in(p))break;\n        }\n        if (link.begin() + i == link.end())return \"\";\n        return link[i].destname;\n    }\n};\n\nint main(int argc, char** argv) {\n    int pageNumber, maxWidth, maxHeight;\n    while (cin >> pageNumber && pageNumber) {\n        cin >> maxWidth >> maxHeight;\n        vector<Page>pages(pageNumber);\n        map<string, Page*>PageCast;\n        for (int i = 0; i < pageNumber; ++i) {\n            int count;\n            cin >> pages[i].name >> count;\n            while (count--) {\n                int a, b, c, d;\n                string s;\n                cin >> a >> b >> c >> d >> s;\n                pages[i].link.push_back(Link(Rectangle(a, b, c, d), s));\n            }\n            PageCast[pages[i].name] = &pages[i];\n        }\n        int operatorCount;\n        stack<Page*>UrlHistory;\n        stack<Page*>ForwardPages;\n        UrlHistory.push(&pages[0]);\n        cin >> operatorCount;\n        while (operatorCount--) {\n            string opt;\n            cin >> opt;\n            if (opt == \"click\") {\n                Point point;\n                cin >> point.x >> point.y;\n                //if (UrlHistory.empty())continue;\n                string next = (*UrlHistory.top())[point];\n                if (next == \"\")continue;\n                while (!ForwardPages.empty())\n                    ForwardPages.pop();\n                UrlHistory.push(PageCast[next]);\n            } else if (opt == \"show\") {\n                if (UrlHistory.empty())continue;\n                cout << (*UrlHistory.top()).name << endl;\n            } else if (opt == \"back\") {\n                if (UrlHistory.size() <= 1)continue;\n                ForwardPages.push(UrlHistory.top());\n                UrlHistory.pop();\n            } else if (opt == \"forward\") {\n                if (ForwardPages.empty())continue;\n                UrlHistory.push(ForwardPages.top());\n                ForwardPages.pop();\n            } else assert(false);\n        }\n    }\n    return EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n#define MAX 500\n\nstruct Page{\n  int sx,sy,tx,ty;\n  string next;\n  Page(int sx,int sy,int tx,int ty,string next)\n    : sx(sx),sy(sy),tx(tx),ty(ty),next(next) {}\n};\n\nint main(){\n  int N,W,H,b,sx,sy,tx,ty,p = 0;\n  string str[MAX],s;\n\n  while(cin >> N,N){\n    cin >> W >> H;\n    vector<Page> vec[MAX];\n    for(int i = 0 ; i < N ; i++){\n      cin >> str[i] >> b;\n      for(int j = 0 ; j < b ; j++){\n        cin >> sx >> sy >> tx >> ty >> s;\n        vec[i].push_back(Page(sx,sy,tx,ty,s));\n      }\n    }\n    int m,w,h,now = 0;\n    vector<int> now_page;\n    now_page.push_back(now);\n    string next;\n    cin >> m;\n    for(int I = 0 ; I < m ; I++){\n      int size = now_page.size();\n      if(p == size-1 && now_page[size-1] != now){\n        now_page.push_back(now);\n        p++;\n        size = now_page.size();\n      }\n      cin >> s;\n      if(s == \"click\"){\n        bool found = false;\n        cin >> w >> h;\n        for(int i = 0 ; i < (int)vec[now].size() ; i++){\n          sx = vec[now][i].sx, sy = vec[now][i].sy;\n          tx = vec[now][i].tx, ty = vec[now][i].ty;\n          next = vec[now][i].next;\n          if(sx <= w && w <= tx && sy <= h && h <= ty){\n            for(int j = 0 ; j < N ; j++){\n              if(str[j] == next){\n                now = j;\n                found = true;\n                break;\n              }\n            }\n          }\n          if(found) break;\n        }\n      }else if(s == \"show\"){\n        cout << str[now_page[p]] << endl;\n      }else if(s == \"back\"){\n        if(p > 0) p--;\n      }else{\n        if(p+1 < size) p++;\n      }\n    }\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\n#include <map>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nconst int INF = 1<<29;\n\nstruct P {\n  int x1,y1,x2,y2;\n  string s;\n  P(int x1,int y1,int x2,int y2, string s) : x1(x1),y1(y1),x2(x2),y2(y2),s(s) {}\n};\n\nint main() {\n  int n;\n  while(cin>>n,n) {\n    int w,h;\n    cin >> w>>h;\n    string title[n];\n    vector<P> button[n];;\n    map<string, int> rid;\n    REP(i,n) {\n      cin >> title[i];\n      rid[title[i]] = i;\n      int m;\n      cin >> m;\n      REP(j,m) {\n        int ax,ay,bx,by;\n        cin>>ax>>ay>>bx>>by;\n        string s;\n        cin >> s;\n        button[i].push_back(P(ax,ay,bx,by,s));\n      }\n    }\n    int m;\n    cin >> m;\n    int now = 0;\n    int page[100000] = {};\n    int maxpage = 0;\n    while(m--) {\n      string s;\n      cin >> s;\n      if (s == \"click\") {\n        int x, y;\n        cin >> x >> y;\n        FOR(it, button[page[now]]) {\n          if (it->x1<=x && x<=it->x2 && it->y1<=y && y<=it->y2) {\n            page[++now] = rid[it->s];\n            maxpage = now;\n            break;\n          }\n        }\n      } else if (s == \"show\"){\n        cout << title[page[now]] << endl;\n      } else if (s == \"back\") {\n        if (now>0)\n          now--;\n      } else if (s == \"forward\") {\n        if (now<maxpage)\n          now++;\n      }\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<algorithm>\n#include<iostream>\n#include<vector>\n#include<climits>\n#include<cfloat>\n\nusing namespace std;\n\ndouble EPS = 1e-10;\n\ndouble add(double a, double b){\n  if(abs(a+b) < EPS * (abs(a)+abs(b)))return 0;\n  return a+b;\n}\n\nstruct point{\n  double x, y;\n  point(){}\n  point(double x,double y) : x(x) , y(y){}\n\n  point operator + (point p){\n    return point(add(x,p.x), add(y,p.y));\n  }\n\n  point operator - (point p){\n    return point(add(x,-p.x), add(y,-p.y));\n  }\n\n  point operator * (double d){\n    return point(x*d,y*d);\n  }\n\n  point operator / (double d){\n    return point(x/d,y/d);\n  }\n  \n  bool operator == ( const point &p ) const {\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n};\n\nstruct button{\n  point ld,ru;\n  string name;\n};\n\nstruct page{\n  string name;\n  vector<button>btn;   \n}; \n\nint main(void){\n  int n;\n  int w,h,b;\n  point l,r;\n  page in;\n  vector<page> a;\n  button tmp;\n\n  while(cin >> n,n){\n  \n    a.clear();\n\n    cin >> w >> h;\n    \n    for(int j=0;j<n;j++){\n      cin >> in.name >> b;    \n      \n      for(int i=0;i<b;i++){\n\tcin >> tmp.ld.x >> tmp.ld.y >> tmp.ru.x >> tmp.ru.y >> tmp.name;\n\tin.btn.push_back(tmp);\n      }\n      a.push_back(in);\n    }\n\n    int m,now=0,fg=0;\n    static page buf[1000000];\n\n    cin >> m;\n    buf[0]=a[0];\n    while(m--){\n      string s;\n      cin >> s;\n      if(s==\"click\"){\n\tint c,d;\n\tcin >> c >> d;\n\t\n\tfor(int i=0;i<buf[now].btn.size();i++){\n\t  int fg2=0;\n\t  if(buf[now].btn[i].ld.x <=c &&\n\t     buf[now].btn[i].ld.y <=d &&\n\t     buf[now].btn[i].ru.x >=c &&\n\t     buf[now].btn[i].ru.y >=d){\n\t    for(int j=0;j<a.size();j++){\n\t      if(buf[now].btn[i].name==a[j].name){\n\t\tbuf[++now]=a[j];\n\t\tfg=0;\n\t\tfg2=1;\n\t\tbreak;\n\t      }\n\t    }\n\t    if(fg2)break;\n\t  }\n\t}\n      }\n      else if(s==\"back\" && now>0){\n\tnow--;\n\tfg++;\n      }\n      else if(s==\"forward\" && fg>0 && now < 1000000)now++,fg--;\n      else if(s==\"show\")cout << buf[now].name << endl;\n    }\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<iomanip>\n#include<string>\n#include<vector>\nusing namespace std;\nstruct wy\n{\n\tlong long x1,y1,x2,y2;\n\tstring nextname;\n\tstring name;\n\tstring back;\n\tstring forward;\n};\nvector<wy> a[200];\nint main()\n{\n\tint n;\n\twhile(cin>>n)\n\t{\n\t\tif(n==0)\n\t\t\tbreak;\n\t\tlong long w,h;\n\t\tcin>>w>>h;\n\t\tint i=0;\n\t\tstring s;\n\t\tfor(;i<n;i++)\n\t\t{\n\t\t\tcin>>s;\n\t\t\tint cs;\n\t\t\tcin>>cs;\n\t\t\tlong long x1,y1,x2,y2;\n\t\t\tstring name;\n\t\t\tfor(int j=0;j<cs;j++)\n\t\t\t{\n\t\t\t\tcin>>x1>>y1>>x2>>y2>>name;\n\t\t\t\twy ww;\n\t\t\t\tww.x1=x1;\n\t\t\t\tww.y1=y1;\n\t\t\t\tww.x2=x2;\n\t\t\t\tww.y2=y2;\n\t\t\t\tww.nextname=name;\n\t\t\t\tww.name=s;\n\t\t\t\ta[i].push_back(ww);\n\t\t\t}\n\t\t}\n\t\tint m;\n\t\tint sz=0;\n\t\tcin>>m;\n\t\tstring nn;\n\t\twhile(m--)\n\t\t{\n\t\t\tcin>>nn;\n\t\t\tif(nn==\"show\")\n\t\t\t\tcout<<a[sz][0].name<<endl;\n\t\t\telse if(nn==\"click\")\n\t\t\t\t{\n\t\t\t\t\tint xxx,yyy;\n\t\t\t\t\tcin>>xxx>>yyy;\n\t\t\t\t\tfor(int kkk=0;kkk<a[sz].size();kkk++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(xxx>=a[sz][kkk].x1&&xxx<=a[sz][kkk].x2&&yyy>=a[sz][kkk].y1&&yyy<=a[sz][kkk].y2)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tint flog=0;\n\t\t\t\t\t\t\tfor(int ym=0;ym<n;ym++)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif(a[ym][0].name==a[sz][kkk].nextname)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\ta[ym][0].back=a[sz][0].name;\n\t\t\t\t\t\t\t\t\ta[sz][0].forward=a[ym][0].name;\n\t\t\t\t\t\t\t\t\tsz=ym;\n\t\t\t\t\t\t\t\t\tflog=1;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif(flog==1)\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(nn==\"back\")\n\t\t\t\t{\n\t\t\t\t\tfor(int k=0;k<n;k++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(a[k][0].name==a[sz][0].back)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ta[k][0].forward=a[sz][0].name;\n\t\t\t\t\t\t\tsz=k;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(nn==\"forward\")\n\t\t\t\t{\n\t\t\t\t\tfor(int k=0;k<n;k++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(a[k][0].name==a[sz][0].forward)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ta[k][0].back=a[sz][0].name;\n\t\t\t\t\t\t\tsz=k;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*************************************************************************\nAuthor: ziki\nCreated Time: 2012-8-9 12:39:37\nFile Name: d.cpp\nDescription: \n************************************************************************/\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <string.h>\n\n\nusing namespace std;\n\ntypedef long long int64;\ntypedef unsigned long long uint64;\n#define two(X) (1<<(X))\n#define twoL(X) (((int64)(1))<<(X))\n#define contain(S,X) (((S)&two(X))!=0)\n#define containL(S,X) (((S)&twoL(X))!=0)\nconst double pi=acos(-1.0);\nconst double eps=1e-11;\nconst int inf=0x7FFFFFFF;\ntemplate<class T> inline void checkmin(T &a,T b){if(b<a) a=b;}\ntemplate<class T> inline void checkmax(T &a,T b){if(b>a) a=b;}\ntemplate<class T> inline T sqr(T x){return x*x;}\ntypedef pair<int,int> ipair;\n#define SIZE(A) ((int)A.size())\n#define LENGTH(A) ((int)A.length())\n#define MP(A,B) make_pair(A,B)\n#define PB(X) push_back(X)\n#define zero(a) memset(a, 0, sizeof(a))\n#define out(x) (cout<<#x<<\": \"<<x<<endl)\ntemplate<class T>void show(T a, int n){for(int i=0; i<n; ++i) cout<<a[i]<<' '; cout<<endl;}\ntemplate<class T>void show(T a, int r, int l){for(int i=0; i<r; ++i)show(a[i],l);cout<<endl;}\n\nstruct obj{\n\tint x1,x2,y1,y2;\n\tint idx;\n\tobj(int x1,int y1, int x2, int y2, int s):x1(x1),y1(y1),x2(x2),y2(y2), idx(s){}\n\tint inter(int x,int y) {\n\t\treturn x1<=x && x<=x2 && y>=y1 && y<=y2;\n\t}\n};\nstruct S{\n\tstring nm;\n\tvector<obj>e;\n\tvoid init(string s){\n\t\tnm = s;\n\t\te.clear();\n\t}\n}s[1000];\n\n\nint stk[1000],now,top;\nint main()\n{\n\tint n,m,w,h;\n\twhile(cin>>n&&n)\n\t{\n\t\tcin>>w>>h;\n\t\ttop = 0;\n\t\tmap<string,int> mp;\n\t\tint idx = 0;\n\t\tfor(int i=0; i<3; i++){\n\t\t\tint eec;\n\t\t\tint x1,x2,y1,y2,id,id2;\n\t\t\tstring nm;\n\t\t\tcin>>nm>>eec;\n\t\t\tif(mp.count(nm)) id = mp[nm];\n\t\t\telse id = mp[nm] = idx++;\n\t\t\ts[id].init(nm);\n\t\t\tfor(int j=0; j<eec; j++){\n\t\t\t\tcin>>x1>>y1>>x2>>y2>>nm;\n\t\t\t\tif(x1>x2)swap(x1,x2);\n\t\t\t\tif(y1>y2)swap(y1,y2);\n\t\t\t\tif(mp.count(nm)) id2 = mp[nm];\n\t\t\t\telse id2 = mp[nm] = idx++;\n\t\t\t\ts[id].e.PB(obj(x1,y1,x2,y2,id2));\n\t\t\t}\n\t\t}\n\t\tcin>>m;\n\t\tnow = top = 0;\n\t\tstk[0] = 0;\n\t\tfor(int i=0; i<m; i++){\n\t\t\tint tx,ty, it = stk[now], to = -1;\n\t\t\tstring cmd;\n\t\t\tcin>>cmd;\n\t\t\tif(cmd == \"click\"){\n\t\t\t\t\n\t\t\t\tcin>>tx>>ty;\n\t\t\t\tfor(int j=0; j<s[it].e.size(); j++){\n\t\t\t\t\tif(s[it].e[j].inter(tx,ty)){\n\t\t\t\t\t\tto = s[it].e[j].idx;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(to!=-1){\n\t\t\t\t\tstk[++now] = to;\n\t\t\t\t\ttop = now;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(cmd == \"show\"){\n\t\t\t\tcout<<s[it].nm<<endl;\n\t\t\t}\n\t\t\telse if(cmd == \"back\"){\n\t\t\t\tif(now>0) now--;\n\t\t\t}\n\t\t\telse if(cmd == \"forward\"){\n\t\t\t\tif(now<top) now++;\n\t\t\t}\n\t\t}\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<algorithm>\n#include<iostream>\n#include<vector>\n#include<climits>\n#include<cfloat>\n\nusing namespace std;\n\ndouble EPS = 1e-10;\n\ndouble add(double a, double b){\n  if(abs(a+b) < EPS * (abs(a)+abs(b)))return 0;\n  return a+b;\n}\n\nstruct point{\n  double x, y;\n  point(){}\n  point(double x,double y) : x(x) , y(y){}\n\n  point operator + (point p){\n    return point(add(x,p.x), add(y,p.y));\n  }\n\n  point operator - (point p){\n    return point(add(x,-p.x), add(y,-p.y));\n  }\n\n  point operator * (double d){\n    return point(x*d,y*d);\n  }\n\n  point operator / (double d){\n    return point(x/d,y/d);\n  }\n  \n  bool operator == ( const point &p ) const {\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n};\n\nstruct button{\n  point ld,ru;\n  string name;\n};\n\nstruct page{\n  string name;\n  vector<button>btn;   \n};\n\nint main(void){\n  int n;\n  int w,h,b;\n  point l,r;\n  page in;\n  vector<page> a;\n  button tmp;\n\n  while(cin >> n,n){\n  \n    a.clear();\n\n    cin >> w >> h;\n    \n    for(int j=0;j<n;j++){\n      cin >> in.name >> b;    \n      \n      for(int i=0;i<b;i++){\n\tcin >> tmp.ld.x >> tmp.ld.y >> tmp.ru.x >> tmp.ru.y >> tmp.name;\n\tin.btn.push_back(tmp);\n      }\n      a.push_back(in);\n    }\n\n    int m,now=0;\n    cin >> m;\n\n    while(m--){\n      string s;\n      cin >> s;\n      if(s==\"click\"){\n\tint c,d;\n\tcin >> c >> d;\n\t\n\tfor(int i=0;i<a[now].btn.size();i++){\n\t  if(a[now].btn[i].ld.x <=c &&\n\t     a[now].btn[i].ld.y <=d &&\n\t     a[now].btn[i].ru.x >=c &&\n\t     a[now].btn[i].ru.y >=d){\n\t    for(int j=0;j<a.size();j++)\n\t      if(a[now].btn[i].name==a[j].name)now=j;\n\t  }\n\t}\n      }\n      else if(s==\"back\" && now>0)now--;\n      else if(s==\"forward\" && now<a.size()-1)now++;\n      else if(s==\"show\")cout << a[now].name << endl;\n    }\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 100000000\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P> PP;\n\nstatic const double EPS = 1e-8;\n\nconst int tx[] = {0,1,0,-1};\nconst int ty[] = {-1,0,1,0};\n\nclass Button{\npublic:\n\tint lu_x,lu_y,rl_x,rl_y;\n\tstring name;\n\tButton() : lu_x(0),lu_y(0),rl_x(0),rl_y(0),name(\"\"){}\n\tButton(int lu_x,int lu_y,int rl_x,int rl_y,string name): lu_x(lu_x),lu_y(lu_y),rl_x(rl_x),rl_y(rl_y),name(name){}\n};\n\nint main(){\n\tint n;\n\tint W,H;\n\tmap<string,vector<Button> > page;\n\tvector<string> browsed;\n\twhile(~scanf(\"%d\",&n)){\n\t\tif(n==0) break;\n\t\tscanf(\"%d %d\",&W,&H);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tstring name;\n\t\t\tint num;\n\t\t\tcin >> name >> num;\n\t\t\tfor(int j=0;j<num;j++){\n\t\t\t\tstring next;\n\t\t\t\tint lu_x,lu_y,rl_x,rl_y;\n\t\t\t\tcin >> lu_x >> lu_y >> rl_x >> rl_y >> next;\n\t\t\t\tpage[name].push_back(Button(lu_x,lu_y,rl_x,rl_y,next));\n\t\t\t\tif(browsed.size()==0) browsed.push_back(name);\n\t\t\t}\n\t\t}\n\n\t\tint m;\n\t\tint pos = 0;\n\t\tscanf(\"%d\",&m);\n\t\tfor(int i=0;i<m;i++){\n\t\t\tstring act;\n\t\t\tcin >> act;\n\t\t\tif(act==\"click\"){\n\t\t\t\tint x,y;\n\t\t\t\tcin >> x >> y;\n\t\t\t\tstring now = browsed[pos];\n\t\t\t\tfor(int i=0;i<page[now].size();i++){\n\t\t\t\t\tif(!(x < page[now][i].lu_x || page[now][i].rl_x < x\n\t\t\t\t\t\t|| y > page[now][i].rl_y || page[now][i].lu_y > y)){\n\t\t\t\t\t\t\tif(browsed.size() > pos+1)browsed.erase(browsed.begin()+pos+1,browsed.end());\n\t\t\t\t\t\t\tbrowsed.push_back(page[now][i].name);\n\t\t\t\t\t\t\tpos++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(act==\"back\"){\n\t\t\t\tif(pos>0)pos--;\n\t\t\t}\n\t\t\telse if(act==\"forward\"){\n\t\t\t\tif(pos<browsed.size()-1) pos++;\n\t\t\t}\n\t\t\telse if(act==\"show\"){\n\t\t\t\tcout << browsed[pos] << \"\\n\";\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<algorithm>\n#include<iostream>\n#include<vector>\n#include<climits>\n#include<cfloat>\n\nusing namespace std;\n\ndouble EPS = 1e-10;\n\ndouble add(double a, double b){\n  if(abs(a+b) < EPS * (abs(a)+abs(b)))return 0;\n  return a+b;\n}\n\nstruct point{\n  double x, y;\n  point(){}\n  point(double x,double y) : x(x) , y(y){}\n\n  point operator + (point p){\n    return point(add(x,p.x), add(y,p.y));\n  }\n\n  point operator - (point p){\n    return point(add(x,-p.x), add(y,-p.y));\n  }\n\n  point operator * (double d){\n    return point(x*d,y*d);\n  }\n\n  point operator / (double d){\n    return point(x/d,y/d);\n  }\n  \n  bool operator == ( const point &p ) const {\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n};\n\nstruct button{\n  point ld,ru;\n  string name;\n};\n\nstruct page{\n  string name;\n  vector<button>btn;   \n};\n\nint main(void){\n  int n;\n\n  while(cin >> n,n){\n    int w,h,b;\n    point l,r;\n    page in;\n    vector<page> a;\n    button tmp;\n\n    cin >> w >> h;\n    \n    for(int j=0;j<n;j++){\n      cin >> in.name >> b;    \n      \n      for(int i=0;i<b;i++){\n\tcin >> tmp.ld.x >> tmp.ld.y >> tmp.ru.x >> tmp.ru.y >> tmp.name;\n\tin.btn.push_back(tmp);\n      }\n      a.push_back(in);\n    }\n\n    int m,now=0;\n    cin >> m;\n\n    while(m--){\n      string s;\n      cin >> s;\n      if(s==\"click\"){\n\tint c,d;\n\tcin >> c >> d;\n\t\n\tfor(int i=0;i<a[now].btn.size();i++){\n\t  if(a[now].btn[i].ld.x <=c &&\n\t     a[now].btn[i].ld.y <=d &&\n\t     a[now].btn[i].ru.x >=c &&\n\t     a[now].btn[i].ru.y >=d){\n\t    for(int j=0;j<a.size();j++)\n\t      if(a[now].btn[i].name==a[j].name)now=j;\n\t  }\n\t}\n      }\n      else if(s==\"back\")now--;\n      else if(s==\"forward\")now++;\n      else if(s==\"show\")cout << a[now].name << endl;\n    }\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// AOJ1054 Distorted Love\n\n#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n\nusing namespace std;\n\nclass button{\npublic:\n\tint x1, y1, x2, y2; string name;\n\tbutton(int x1, int y1, int x2, int y2, string name) : x1(x1), y1(y1), x2(x2), y2(y2), name(name) {}\n\tbool in(int x, int y) { return x1 <= x && x <= x2 && y1 <= y && y <= y2; }\n};\n\nint main(){\n\tint n;\n\twhile(cin >> n, n){\n\t\tint x, y; cin >> x >> y;\n\t\tint buf[100]; buf[0] = 0; \n\t\tint size = 0;\n\t\tint cur = 0;\n\t\tstring s;\n\t\tvector<string> vs;\n\t\tmap<string, int> mp;\n\t\tvector< vector<button> > vv(n);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin >> s;\n\t\t\tvs.push_back(s);\n\t\t\tmp[s] = i;\n\t\t\tint t; cin >> t;\n\t\t\tfor(int j=0;j<t;j++){\n\t\t\t\tint x1, y1, x2, y2; cin >> x1 >> y1 >> x2 >> y2 >> s;\n\t\t\t\tvv[i].push_back(button(x1, y1, x2, y2, s));\n\t\t\t}\n\t\t}\n\t\tcin >> n;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin >> s;\n\t\t\tif(s==\"show\") cout << vs[cur] << endl;\n\t\t\tif(s==\"forward\"){\n\t\t\t\tif(cur != size) cur++;\n\t\t\t}\n\t\t\tif(s==\"back\"){\n\t\t\t\tif(cur != 0) cur--;\n\t\t\t}\n\t\t\tif(s==\"click\"){\n\t\t\t\tint x, y; cin >> x >> y;\n\t\t\t\tfor(int j=0;j<vv[buf[cur]].size();j++){\n\t\t\t\t\tif(vv[buf[cur]][j].in(x,y)){\n\t\t\t\t\t\tcur++;\n\t\t\t\t\t\tsize = cur;\n\t\t\t\t\t\tbuf[cur] = mp[vv[buf[cur-1]][j].name];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\nusing namespace std;\n\nconst int N_MAX = 101;\nstring NAME[N_MAX];\nmap <string, int> INDEX;\nint LC[N_MAX];\nint BX1[N_MAX][N_MAX];\nint BY1[N_MAX][N_MAX];\nint BX2[N_MAX][N_MAX];\nint BY2[N_MAX][N_MAX];\nstring LINK[N_MAX][N_MAX];\nint BF[100000];\n\nbool hitcheck( int cur, int link, int x, int y ) {\n    return BX1[cur][link] <= x && x <= BX2[cur][link] && BY1[cur][link] <= y && y <= BY2[cur][link];\n}\n\nint main() {\n    int n;\n    while ( cin >> n && n ) {\n        int bw, bh;\n        cin >> bw >> bh;\n        for ( int i = 0; i < n; ++ i ) {\n            cin >> NAME[i] >> LC[i];\n            INDEX[NAME[i]] = i;\n            for ( int j = 0; j < LC[i]; ++ j ) {\n                cin >> BX1[i][j] >> BY1[i][j] >> BX2[i][j] >> BY2[i][j] >> LINK[i][j];\n            }\n        }\n        int k;\n        cin >> k;\n        int cur = 0;\n        int most = 0;\n        BF[0] = 0;\n        for ( int i = 0; i < k; ++ i ) {\n            string cmd;\n            cin >> cmd;\n            if ( cmd == \"click\" ) {\n                int mx, my;\n                cin >> mx >> my;\n                for ( int j = 0; j < LC[cur]; ++ j ) {\n                    if ( hitcheck( cur, j, mx, my ) ) {\n                        BF[cur+1] = INDEX[LINK[cur][j]];\n                        cur += 1;\n                        most = cur;\n                        break;\n                    }\n                }\n            } else if ( cmd == \"show\" ) {\n                cout << NAME[BF[cur]] << endl;\n            } else if ( cmd == \"back\" ) {\n                if ( cur - 1 >= 0 ) {\n                    cur -= 1;\n                }\n            } else if ( cmd == \"forward\" ) {\n                if ( cur + 1 <= most ) {\n                    cur += 1;\n                }\n            }\n        }\n    }\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\nstruct Button{\n\tint left,right,top,under,link_index;\n\tchar to_name[21];\n};\n\nstruct Page{\n\tchar name[21];\n\tvector<Button> B;\n};\n\nint num_page,W,H;\n\nbool strCmp(char* base, char* comp){\n\tint length1 = 0,length2 = 0;\n\tfor(int i=0;base[i] != '\\0'; i++)length1++;\n\tfor(int i=0;comp[i] != '\\0'; i++)length2++;\n\tif(length1 != length2)return false;\n\n\tfor(int i=0;base[i] != '\\0'; i++){\n\t\tif(base[i] != comp[i])return false;\n\t}\n\treturn true;\n}\n\n\nvoid func(){\n\n\tPage page[101];\n\n\tint pointer;\n\tvector<int> buffer;\n\n\tint num_button;\n\n\tfor(int i = 0; i < num_page; i++){\n\t\tscanf(\"%s %d\",page[i].name,&num_button);\n\n\t\tfor(int k = 0; k < num_button;k++){\n\t\t\tButton button;\n\t\t\tscanf(\"%d %d %d %d %s\",&button.left,&button.top,&button.right,&button.under,button.to_name);\n\t\t\tpage[i].B.push_back(button);\n\t\t}\n\t}\n\n\tfor(int i = 0; i < num_page; i++){\n\t\tfor(int k = 0; k < page[i].B.size();k++){\n\t\t\tfor(int p = 0; p < num_page; p++){\n\t\t\t\tif(strCmp(page[i].B[k].to_name,page[p].name)){\n\t\t\t\t\tpage[i].B[k].link_index = p;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tbuffer.push_back(0);\n\tpointer = 0;\n\n\n\tint M,tmp_x,tmp_y;\n\tscanf(\"%d\",&M);\n\n\tchar order[10];\n\n\tfor(int loop = 0; loop < M; loop++){\n\t\tscanf(\"%s\",order);\n\n\t\tswitch(order[0]){\n\t\tcase 'c':\n\t\t\tscanf(\"%d %d\",&tmp_x,&tmp_y);\n\n\t\t\tfor(int i = 0; i < page[pointer].B.size();i++){\n\t\t\t\tif(tmp_x >= page[pointer].B[i].left && tmp_x <= page[pointer].B[i].right &&\n\t\t\t\t\t\ttmp_y >= page[pointer].B[i].top && tmp_y <= page[pointer].B[i].under){\n\n\t\t\t\t\twhile(buffer.size() > pointer+1){\n\t\t\t\t\t\tbuffer.erase(buffer.begin()+buffer.size());\n\t\t\t\t\t}\n\t\t\t\t\tbuffer.push_back(page[pointer].B[i].link_index);\n\t\t\t\t\tpointer++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'b':\n\t\t\tif(pointer > 0)pointer--;\n\t\t\tbreak;\n\t\tcase 'f':\n\t\t\tif(pointer < buffer.size()-1)pointer++;\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\tprintf(\"%s\\n\",page[pointer].name);\n\t\t\tbreak;\n\t\t}\n\t}\n\n}\n\nint main(){\n\n\twhile(true){\n\t\tscanf(\"%d\",&num_page);\n\t\tif(num_page == 0)break;\n\n\t\tscanf(\"%d %d\",&W,&H);\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\n\nint b[100], x1[100][100], Y1[100][100], x2[100][100], y2[100][100];\nstring link[100][100];\nmap<string, int>mp;\nint main() {\n\tint n;\n\twhile (scanf(\"%d\", &n), n) {\n\t\tint w, h; scanf(\"%d%d\", &w, &h);\n\t\tvector<string>v;\n\t\trep(i, n) {\n\t\t\tstring s; cin >> s >> b[i]; mp[s] = i;\n\t\t\tif (i == 0)v.push_back(s);\n\t\t\trep(j, b[i])cin >> x1[i][j] >> Y1[i][j] >> x2[i][j] >> y2[i][j] >> link[i][j];\n\t\t}\n\t\tint pos = 0;\n\t\tint m; scanf(\"%d\", &m);\n\t\trep(i, m) {\n\t\t\tstring s; cin >> s;\n\t\t\tif (s == \"click\") {\n\t\t\t\tint x, y; cin >> x >> y;\n\t\t\t\tint a = mp[v.back()];\n\t\t\t\trep(i, b[a]) {\n\t\t\t\t\tif (x1[a][i] <= x&&x <= x2[a][i] && Y1[a][i] <= y&&y <= y2[a][i]) {\n\t\t\t\t\t\tif (pos + 1 < v.size())v.erase(v.begin() + pos + 1, v.end());\n\t\t\t\t\t\tpos++; v.push_back(link[a][i]); break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (s == \"back\") {\n\t\t\t\tif (pos)pos--;\n\t\t\t}\n\t\t\tif (s == \"forward\") {\n\t\t\t\tif (pos < v.size() - 1)pos++;\n\t\t\t}\n\t\t\tif (s == \"show\")cout << v[pos] << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n#define MAX 110\n\nstruct Page{\n  int sx,sy,tx,ty;\n  string next;\n  Page(int sx,int sy,int tx,int ty,string next)\n    : sx(sx),sy(sy),tx(tx),ty(ty),next(next) {}\n};\n\nvector<Page> vec[MAX];\n\nvoid init(){\n  for(int i = 0 ; i < MAX ; i++){\n    vec[i].clear();\n  }\n}\n\nint main(){\n  int N,W,H,b,sx,sy,tx,ty;\n  string str[MAX],s;\n\n  while(cin >> N,N){\n    int p = 0;\n    cin >> W >> H;\n    init();\n    for(int i = 0 ; i < N ; i++){\n      cin >> str[i] >> b;\n      for(int j = 0 ; j < b ; j++){\n        cin >> sx >> sy >> tx >> ty >> s;\n        vec[i].push_back(Page(sx,sy,tx,ty,s));\n      }\n    }\n    int m,w,h,now = 0;\n    vector<int> now_page;\n    now_page.push_back(now);\n    string next;\n    cin >> m;\n    for(int I = 0 ; I < m ; I++){\n      cin >> s;\n      if(s == \"click\"){\n        bool found = false;\n        cin >> w >> h;\n        for(int i = 0 ; i < vec[now_page[p]].size() ; i++){\n          sx = vec[now_page[p]][i].sx, sy = vec[now_page[p]][i].sy;\n          tx = vec[now_page[p]][i].tx, ty = vec[now_page[p]][i].ty;\n          next = vec[now_page[p]][i].next;\n          if(sx <= w && w <= tx && sy <= h && h <= ty){\n            for(int j = 0 ; j < N ; j++){\n              if(str[j] == next){\n                now = j;\n                found = true;\n                break;\n              }\n            }\n          }\n          if(found){\n            p++;\n            while(p < now_page.size()){\n              now_page.pop_back();\n            }\n            now_page.push_back(now);\n            break;\n          }\n        }\n      }else if(s == \"show\"){\n        cout << str[now_page[p]] << endl;\n      }else if(s == \"back\"){\n        if(p > 0) p--;\n      }else{\n        if(p+1 < now_page.size()) p++;\n      }\n    }\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\n\nstruct B{int x1,y1,x2,y2;string name;};\nint W,H,n;\n\nstruct SITE{\n\tstring myname;\n\tvector<B> co;\n};\n\nint pos;\nmap<string,int> to;\nvector<SITE>info;\n\nvector< vector<SITE>::iterator > lst;\nvector<SITE>::iterator cur;\n\n\nvector<SITE>::iterator find(string name){\n\tint lp = to[name];\n\tvector<SITE>::iterator it = info.begin();\n\trep(i,lp){++it;}\n\treturn it;\n}\n\nvoid move(string name){\n\tvector< vector<SITE>::iterator > newList;\n\trep(i,pos+1){\n\t\tnewList.push_back(lst[i]);\n\t}\n\tlst = newList;\n\n\tlst.push_back(find(name));\n\tcur = lst.back();\n\tpos = lst.size()-1;\n}\n\nmain(){\n\n\twhile(cin >> n , n ){\n\t\tto.clear();\n\t\tinfo.clear(),info.resize(n);\n\t\tcin >> W >> H;\n\t\trep(i,n){\n\t\t\tstring s;int d;\n\t\t\tcin >> s >> d;\n\t\t\tto[s] = i;\n\t\t\t\n\t\t\tinfo[i].myname = s;\n\t\t\t\n\t\t\trep(j,d){\n\t\t\t\tB t;\n\t\t\t\tcin >> t.x1 >> t.y1 >> t.x2 >> t.y2 >> t.name;\t\n\t\t\t\tinfo[i].co.push_back(t);\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tint m;\n\n\t\tlst.clear();\t\t\n\t\tlst.push_back(info.begin());\n\t\tcur = info.begin();\n\t\tpos = 0;\n\t\t\n\t\tcin >> m;\n\t\t\n\t\trep(i,m){\n\t\t\tstring s; cin >> s;\n\t\t\tif( s == \"click\" ){\t\n\t\t\t\tint x,y;\n\t\t\t\tcin >> x >> y;\n\t\t\t\tSITE t= *cur;\n\t\t\t\trep(i,t.co.size()){\n\t\t\t\t\tif(t.co[i].x1 <= x && x <= t.co[i].x2 &&\n\t\t\t\t\t   t.co[i].y1 <= y && y <= t.co[i].y2\n\t\t\t\t\t){\n\t\t\t\t\t\tmove(  t.co[i].name );\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif( s == \"show\"){\n\t\t\t\tcout << (*cur).myname << endl;\n\t\t\t}\n\t\t\t\n\t\t\tif( s == \"back\"){\n\t\t\t\tif(pos==0)continue;\n\t\t\t\t\n\t\t\t\tpos--;\n\t\t\t\tcur = lst[pos];\n\t\t\t}\n\t\t\t\n\t\t\tif( s == \"forward\"){\n\t\t\t\tif(pos == lst.size()-1)continue;\n\t\t\t\tpos++;\n\t\t\t\tcur = lst[pos];\n\t\t\t}\n\t\t\t\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<vector>\n#define F first\n#define S second\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<P,P> P2;\ntypedef pair<P2,string> info;\n\nint main(){\n  int n,m,H,W,num,x1,x2,y1,y2;\n  string s,s2,now;\n  while(cin >> n && n){\n    multimap<string,info> web;\n    cin >> W >> H;\n    for(int j=0;j<n;j++){\n      cin >> s >> num;\n      if(j == 0)now = s;\n      for(int i=0;i<num;i++){\n\tcin >> x1 >> y1 >> x2 >> y2 >> s2;\n\tweb.insert(multimap<string,info>::value_type(s,info(P2(P(x1,y1),P(x2,y2)),s2)));\n      }\n    }\n    cin >> m;\n    string op,Back,Forward;\n    string history[1000];\n  \n    int nx,ny,Index=0,len=0;\n    history[Index++] = now;\n    //cout << \"now is \" << now << endl;\n    Back.clear();\n    Forward.clear();\n    for(int i=0;i<m;i++){\n      cin >> op;\n      if(op == \"click\"){\n\tcin >> nx >> ny;\n\tbool found = false;\n\tmultimap<string,info>::iterator it = web.begin();\t\n\twhile(it != web.end() ){\n\t  if((*it).first == now){\n\n\t    if((*it).S.F.F.F <=nx && nx <=(*it).S.F.S.F && (*it).S.F.F.S <=ny && ny <= (*it).S.F.S.S){\n\t      now = (*it).S.S;\n\t      history[Index++] = now; \n\t      len++;\n\t      break;\n\t    }\n\n\t  }\n\t  it++;\n\t}\n\t//cout << now << endl;\n\t//cout << \"--------------\" << endl;\n \n      }\n      else if(op == \"show\")cout << now << endl;\n      else if(op == \"back\"){\n\tif(Index-1 >=0 ){\n\t  Index--;\n\t  now = history[Index-1];\n\t  // cout << \"back to \"<< now << endl;\n\t}\n      }\n      else if(op == \"forward\"){\n\tif(Index+1 <= len){\n\t  now = history[Index];\n\t  Index++;\n\t}\n      }\n\n\n    }\n    /*\n    cout << \"---------\"<< endl;\n    for(int i=0;i<=len;i++){\n      cout << history[i] << endl;\n    }\n    */\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<map>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\nstruct POINT{\n  int x1, y1;\n  int x2, y2;\n};\n\nmap<string, POINT> MakeButton(int);\nvoid Click(map< string, map<string, POINT> >, vector<string>&, int&);\n\nint main(){\n  int i, j, n, m, w, h, now;\n  string str;\n  vector<string> logdata;\n  map< string, map<string, POINT> > webpage;\n\n  while(1){\n    cin >> n;\n    if(n == 0) break;\n    cin >> w >> h;\n\n    for(i=0; i<n; ++i){\n      cin >> str >> m;\n      if(i == 0) logdata.push_back(str);\n      webpage.insert(make_pair(str, MakeButton(m)));\n    }\n\n    cin >> m;\n    for(i=0, now=0; i<m; ++i){\n      cin >> str;\n      if(str == \"click\") Click(webpage, logdata, now);\n      else if(str == \"back\") --now;\n      else if(str == \"forward\") ++now;\n      else if(str == \"show\") cout << logdata[now] << endl;\n    }\n\n    logdata.clear();\n    webpage.clear();\n  }\n  return 0;\n}\n\nmap<string, POINT> MakeButton(int n){\n  int i, x1, y1, x2, y2;\n  string str;\n  POINT p;\n  map<string, POINT> button;\n\n  for(i=0; i<n; ++i){\n    cin >> p.x1 >> p.y1 >> p.x2 >> p.y2 >> str;\n    button.insert(make_pair(str, p));\n  }\n  return button;\n}\n\nvoid Click(map< string, map<string, POINT> > webpage,\n\t   vector<string>& logdata, int& now){\n  int x, y;\n  POINT p;\n  map<string, POINT> button;\n  map<string, POINT>::iterator i;\n  map< string, map<string, POINT> >::iterator j;\n\n  j = webpage.find(logdata[now]);\n  button = j->second;\n  cin >> x >> y;\n\n  for(i=button.begin(); i!=button.end(); ++i){\n    p = i->second;\n    if(p.x1 <= x && x <= p.x2 && p.y1 <= y && y <= p.y2){\n      ++now;\n      logdata.erase(logdata.begin()+now, logdata.end());\n      logdata.push_back(i->first);\n      return;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <map>\nusing namespace std;\n\nstruct Button {\n  int x1,y1,x2,y2;\n  string s;\n  Button(int _x1,int _y1, int _x2, int _y2, string _s) {x1=_x1;y1=_y1;x2=_x2;y2=_y2;s=_s;}\n};\n\nint main() {\n  int n;\n  while(cin>>n,n) {\n    int w,h;\n    cin >> w >> h;\n    string str[n];\n    int b[n];\n    vector<Button> v[n];\n    map<string, int> ma;\n    for (int i=0;i<n;i++) {\n      cin >> str[i];\n      cin >> b[i];\n      ma.insert(make_pair(str[i], i));\n      for (int j=0;j<b[i];j++) {\n        int x1,y1,x2,y2;\n        cin >> x1>>y1>>x2>>y2;\n        string s;\n        cin >> s;\n        v[i].push_back(Button(x1,y1,x2,y2,s));\n      }\n    }\n    int m;\n    cin >> m;\n    int p=0;\n    int p2=0;                   // ツ催妥・ツづ個つキツつキツづ淞づゥツペツーツジ\n    int bv[1000000];\n    bv[0] = 0;\n    for (int i=0; i<m; i++) {\n      string s;\n      cin >> s;\n      if (s==\"click\") {\n        int x, y;\n        cin >> x >> y;\n        vector<Button> bu = v[bv[p]];\n        for (int j=0; j<b[p]; j++) {\n          if (bu[j].x1<=x&&x<=bu[j].x2 && bu[j].y1<=y&&y<=bu[j].y2) {\n            map<string, int>::iterator it = ma.find(v[p][j].s);\n            bv[++p] = it->second;\n            p2 = p;\n            break;\n          }\n        }\n      } else if (s==\"back\") {\n        if (p) p--;\n      } else if (s==\"forward\") {\n        if (p<p2) p++;\n      } else if (s==\"show\") {\n        cout << str[p] << endl;\n      }\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 100000000\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P> PP;\n\nstatic const double EPS = 1e-8;\n\nconst int tx[] = {0,1,0,-1};\nconst int ty[] = {-1,0,1,0};\n\nclass Button{\npublic:\n\tint lu_x,lu_y,rl_x,rl_y;\n\tstring name;\n\tButton() : lu_x(0),lu_y(0),rl_x(0),rl_y(0),name(\"\"){}\n\tButton(int lu_x,int lu_y,int rl_x,int rl_y,string name): lu_x(lu_x),lu_y(lu_y),rl_x(rl_x),rl_y(rl_y),name(name){}\n};\n\nint main(){\n\tint n;\n\tint W,H;\n\tmap<string,vector<Button> > page;\n\tvector<string> browsed;\n\twhile(~scanf(\"%d\",&n)){\n\t\tif(n==0) break;\n\t\tscanf(\"%d %d\",&W,&H);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tstring name;\n\t\t\tint num;\n\t\t\tcin >> name >> num;\n\t\t\tfor(int j=0;j<num;j++){\n\t\t\t\tstring next;\n\t\t\t\tint lu_x,lu_y,rl_x,rl_y;\n\t\t\t\tcin >> lu_x >> lu_y >> rl_x >> rl_y >> next;\n\t\t\t\tpage[name].push_back(Button(lu_x,lu_y,rl_x,rl_y,next));\n\t\t\t\tif(browsed.size()==0) browsed.push_back(name);\n\t\t\t}\n\t\t}\n\n\t\tint m;\n\t\tint pos = 0;\n\t\tscanf(\"%d\",&m);\n\t\tfor(int i=0;i<m;i++){\n\t\t\tstring act;\n\t\t\tcin >> act;\n\t\t\tif(act==\"click\"){\n\t\t\t\tint x,y;\n\t\t\t\tcin >> x >> y;\n\t\t\t\tstring now = browsed[pos];\n\t\t\t\tfor(int j=0;j<page[now].size();j++){\n\t\t\t\t\tif(!(x < page[now][j].lu_x || page[now][j].rl_x < x\n\t\t\t\t\t\t|| y > page[now][j].rl_y || page[now][j].lu_y > y)){\n\t\t\t\t\t\t\t//printf(\"to %s\\n\",page[now][i].name.c_str());\n\n\t\t\t\t\t\t\tbrowsed.erase(browsed.begin()+pos+1,browsed.end());\n\t\t\t\t\t\t\tbrowsed.push_back(page[now][j].name);\n\t\t\t\t\t\t\tpos++;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(act==\"back\"){\n\t\t\t\t\n\t\t\t\tif(pos>0){\n\t\t\t\t\tpos--;\n\t\t\t\t\t//printf(\"back\\n\");\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(act==\"forward\"){\n\t\t\t\tif(pos<browsed.size()-1){\n\t\t\t\t\tpos++;\n\t\t\t\t\t//printf(\"forwardk\\n\");\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(act==\"show\"){\n\t\t\t\tcout << browsed[pos] << \"\\n\";\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<algorithm>\n#include<iostream>\n#include<vector>\n#include<climits>\n#include<cfloat>\n\nusing namespace std;\n\ndouble EPS = 1e-10;\n\ndouble add(double a, double b){\n  if(abs(a+b) < EPS * (abs(a)+abs(b)))return 0;\n  return a+b;\n}\n\nstruct point{\n  double x, y;\n  point(){}\n  point(double x,double y) : x(x) , y(y){}\n\n  point operator + (point p){\n    return point(add(x,p.x), add(y,p.y));\n  }\n\n  point operator - (point p){\n    return point(add(x,-p.x), add(y,-p.y));\n  }\n\n  point operator * (double d){\n    return point(x*d,y*d);\n  }\n\n  point operator / (double d){\n    return point(x/d,y/d);\n  }\n  \n  bool operator == ( const point &p ) const {\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n};\n\nstruct button{\n  point ld,ru;\n  string name;\n};\n\nstruct page{\n  string name;\n  vector<button>btn;   \n}; \n\nint main(void){\n  int n;\n  int w,h,b;\n  point l,r;\n  page in;\n  vector<page> a;\n  button tmp;\n\n  while(cin >> n,n){\n  \n    a.clear();\n\n    cin >> w >> h;\n    \n    for(int j=0;j<n;j++){\n      cin >> in.name >> b;    \n      \n      for(int i=0;i<b;i++){\n\tcin >> tmp.ld.x >> tmp.ld.y >> tmp.ru.x >> tmp.ru.y >> tmp.name;\n\tin.btn.push_back(tmp);\n      }\n      a.push_back(in);\n    }\n\n    int m,now=0,fg=0;\n    static page buf[1000000];\n\n    cin >> m;\n    buf[0]=a[0];\n    while(m--){\n      string s;\n      cin >> s;\n      if(s==\"click\"){\n\tint c,d;\n\tcin >> c >> d;\n\t\n\tfor(int i=0;i<buf[now].btn.size();i++){\n\t  int fg2=0;\n\t  if(buf[now].btn[i].ld.x <=c &&\n\t     buf[now].btn[i].ld.y <=d &&\n\t     buf[now].btn[i].ru.x >=c &&\n\t     buf[now].btn[i].ru.y >=d){\n\t    for(int j=0;j<a.size();j++){\n\t      if(buf[now].btn[i].name==a[j].name){\n\t\tbuf[++now]=a[j];\n\t\tfg=0;\n\t\tfg2=1;\n\t\tbreak;\n\t      }\n\t    }\n\t    if(fg2)break;\n\t  }\n\t}\n      }\n      else if(s==\"back\" && now>0){\n\tnow--;\n\tfg++;\n      }\n      else if(s==\"forward\" && fg-- && now < 1000000)now++;\n      else if(s==\"show\")cout << buf[now].name << endl;\n    }\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<vector>\n#include<set>\n#include<map>\n#include<queue>\n#include<algorithm>\n#include<numeric>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define rp(i,c) rep(i,(c).size())\n#define fr(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf=1<<28;\nconst double INF=1e12,EPS=1e-9;\n\nstruct S{\n\tint x1,y1,x2,y2;\n\tstring name;\n};\n\nint main()\n{\n\tint n;\n\twhile(cin>>n,n)\n\t{\n\t\tint h,w; cin>>h>>w;\n\t\tvector<string> name(n);\n\t\tmap<string,vector<S> > button;\n\t\trep(i,n)\n\t\t{\n\t\t\tint k;\n\t\t\tcin>>name[i]>>k;\n\t\t\t\n\t\t\trep(j,k)\n\t\t\t{\n\t\t\t\tS s;\n\t\t\t\tcin>>s.x1>>s.y1>>s.x2>>s.y2>>s.name;\n\t\t\t\tbutton[name[i]].pb(s);\n\t\t\t}\n\t\t}\n\t\t\n\t\tint m; cin>>m;\n\t\tvector<string> buffer; int cur=0;\n\t\tbuffer.pb(name[0]);\n\t\t\n\t\trep(i,m)\n\t\t{\n\t\t\tstring op; cin>>op;\n\t\t\tif(op==\"show\")\n\t\t\t{\n\t\t\t\tcout<<buffer[cur]<<endl;\n\t\t\t}\n\t\t\telse if(op==\"click\")\n\t\t\t{\n\t\t\t\tint x,y; cin>>x>>y;\n\t\t\t\tfr(it,button[name[cur]])if(it->x1<=x&&x<=it->x2&&it->y1<=y&&y<=it->y2)\n\t\t\t\t{\n\t\t\t\t\tbuffer.erase(buffer.begin()+cur+1,buffer.end());\n\t\t\t\t\tbuffer.pb(it->name);\n\t\t\t\t\tcur++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(op==\"back\")\n\t\t\t{\n\t\t\t\tif(cur>0)cur--;\n\t\t\t}\n\t\t\telse if(op==\"forward\")\n\t\t\t{\n\t\t\t\tif(cur<buffer.size()-1)cur++;\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<algorithm>\n#include<iostream>\n#include<vector>\n#include<climits>\n#include<cfloat>\n\nusing namespace std;\n\ndouble EPS = 1e-10;\n\ndouble add(double a, double b){\n  if(abs(a+b) < EPS * (abs(a)+abs(b)))return 0;\n  return a+b;\n}\n\nstruct point{\n  double x, y;\n  point(){}\n  point(double x,double y) : x(x) , y(y){}\n\n  point operator + (point p){\n    return point(add(x,p.x), add(y,p.y));\n  }\n\n  point operator - (point p){\n    return point(add(x,-p.x), add(y,-p.y));\n  }\n\n  point operator * (double d){\n    return point(x*d,y*d);\n  }\n\n  point operator / (double d){\n    return point(x/d,y/d);\n  }\n  \n  bool operator == ( const point &p ) const {\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n};\n\nstruct button{\n  point ld,ru;\n  string name;\n};\n\nstruct page{\n  string name;\n  vector<button>btn;   \n}; \n\nint tail;\npage stk[1000000];\n\nvoid push(page a){\n  stk[tail++]=a;\n}\n\npage pop(void){\n  tail--;\n  return stk[tail+1];\n}\n\nint main(void){\n  int n;\n  int w,h,b;\n  point l,r;\n  page in;\n  vector<page> a;\n  button tmp;\n\n  while(cin >> n,n){\n  \n    a.clear();\n\n    cin >> w >> h;\n    \n    for(int j=0;j<n;j++){\n      cin >> in.name >> b;    \n      \n      for(int i=0;i<b;i++){\n\tcin >> tmp.ld.x >> tmp.ld.y >> tmp.ru.x >> tmp.ru.y >> tmp.name;\n\tin.btn.push_back(tmp);\n      }\n      a.push_back(in);\n    }\n\n    int m,now=0;\n\n    cin >> m;\n    tail=0;\n    int fg=0;\n    push(a[0]);\n    while(m--){\n      string s;\n      cin >> s;\n      if(s==\"click\"){\n\tint c,d;\n\tcin >> c >> d;\n\t\n\tfor(int i=0;i<stk[tail-1].btn.size();i++){\n\t  int fg2=0;\n\t  if(stk[tail-1].btn[i].ld.x <=c &&\n\t     stk[tail-1].btn[i].ld.y <=d &&\n\t     stk[tail-1].btn[i].ru.x >=c &&\n\t     stk[tail-1].btn[i].ru.y >=d){\n\t    for(int j=0;j<a.size();j++){\n\t      if(stk[tail-1].btn[i].name==a[j].name){\n\t\tpush(a[j]);\n\t\tfg=0;\n\t\tfg2=1;\n\t\tbreak;\n\t      }\n\t    }\n\t    if(fg2)break;\n\t  }\n\t}\n      }\n      else if(s==\"back\" && tail-1>0){\n\ttail--;\n\tfg++;\n      }\n      else if(s==\"forward\" && fg-- && tail-2 < 1000000)tail++;\n      else if(s==\"show\")cout << stk[tail-1].name << endl;\n    }\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<algorithm>\n#include<iostream>\n#include<vector>\n#include<climits>\n#include<cfloat>\n\nusing namespace std;\n\nstruct point{\n  int x, y;\n};\n\nstruct button{\n  point ld,ru;\n  string name;\n};\n\nstruct page{\n  string name;\n  vector<button>btn;   \n}; \n\nint m,now;\nvector<page> a;\npage nowpage;\nstring buf[10005];\n\nvoid func(void){\n  for(int i=0;i<a.size();i++){\n    if(buf[now]==a[i].name){\n      nowpage=a[i];\n      return ;\n    }\n  }\n}\n\nvoid click(int c,int d){\n  \n  for(int i=0;i<nowpage.btn.size();i++){\n    if(nowpage.btn[i].ld.x <=c && nowpage.btn[i].ld.y <=d &&\n       nowpage.btn[i].ru.x >=c && nowpage.btn[i].ru.y >=d){\n      buf[++now]=nowpage.btn[i].name;\n      fill(buf+now+1,buf+10001,\"\");\n      return ;\n    }\n  }\n}\n\n\nint main(void){\n  int n;\n  int w,h,b;\n  point l,r;\n  page in;\n  button tmp;\n\n  while(cin >> n,n){\n  \n    a.clear();\n    fill(buf,buf+10001,\"\");\n\n    cin >> w >> h;\n    \n    for(int j=0;j<n;j++){\n      cin >> in.name >> b;    \n      \n      for(int i=0;i<b;i++){\n\tcin >> tmp.ld.x >> tmp.ld.y >> tmp.ru.x >> tmp.ru.y >> tmp.name;\n\tin.btn.push_back(tmp);\n      }\n      a.push_back(in);\n    }\n\n    now=0;\n    buf[0]=a[0].name;\n    nowpage=a[0];\n\n    cin >> m;\n\n    while(m--){\n      string s;\n      cin >> s;\n      if(s==\"click\"){\n\tint c,d;\n\tcin >> c >> d;\n\tclick(c,d);\n      }\n      else if(s==\"back\" && now>0)now--;\n      else if(s==\"forward\" && buf[now+1]!=\"\")now++;\n      else if(s==\"show\")cout << buf[now] << endl;\n\n      func();\n    }\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <map>\n#include <vector>\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<P,P> PP;\nmap<string,int> m;\nmap<int,string> m2;\n\nclass page{\npublic:\n  PP p;\n  int n;\n  page(PP p=PP(P(0,0),P(0,0)), int n=0):p(p),n(n){}\n};\n\nint main(){\n  int n;\n  while(cin >> n && n){\n    int h,w,aa=0;\n    vector<page> v[100];\n    cin >> h >> w;\n    for(int i=0;i<n;i++){\n      string str;\n      int a;\n      cin >> str >> a;\n      if(m.find(str) == m.end()){\n        m[str] = aa;\n        m2[aa++] = str;\n      }\n      for(int j=0;j<a;j++){\n        PP p;\n        cin >> p.first.first >> p.first.second >> p.second.first >> p.second.second >> str;\n        if(m.find(str) == m.end()){\n          m[str] = aa;\n          m2[aa++] = str;\n        }\n        v[i].push_back(page(p,m[str]));\n      }\n    }\n\n    int n2, curr=0;\n    vector<int> v2;\n    v2.push_back(0);\n    cin >> n2;\n    for(int i=0;i<n2;i++){\n      string str;\n      cin >> str;\n      if(str == \"click\"){\n        int x,y;\n        cin >> x >> y;\n        int now = v2[curr];\n        for(int j=0;j<v[now].size();j++){\n          if(v[now][j].p.first.first <= x && x <= v[now][j].p.second.first && v[now][j].p.first.second <= y && y <= v[now][j].p.second.second){\n            curr++;\n            while(curr < v2.size()) v2.pop_back();\n            v2.push_back(v[now][j].n);\n            break;\n          }\n        }\n      } else if(str == \"back\") curr = (curr <= 0) ? curr : curr-1;\n      else if(str == \"forward\") curr = (curr >= v2.size()-1) ? curr : curr+1;\n      else cout << m2[v2[curr]] << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <cstdlib>\n#include <climits>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <numeric>\n#include <sstream>\n#include <string>\nusing namespace std;\n#define out(X) cerr << #X << \": \" << (X) << endl\n#define SZ(X) ((int)(X.size()))\n#define REP(I,N) for (int I = 0; I < (N); ++I)\n#define FOR(I,L,H) for (int I = (L); I < (H); ++I)\n#define MP(X,Y) make_pair((X),(Y))\n#define PB push_back\n#define ALL(X) X.begin(), X.end()\ntemplate <typename T> inline bool checkmin(T &a, const T &b) { return a > b ? a = b, 1 : 0; }\ntemplate <typename T> inline bool checkmax(T &a, const T &b) { return a < b ? a = b, 1 : 0; }\ntypedef long long lint;\n\nconst int MAXN = 100 + 10;\n\nstruct node {\n    int lx, rx, ly, ry;\n    string to;\n    void input() {\n        cin >> lx >> ly >> rx >> ry >> to;\n    }\n    bool is_in(int x, int y) {\n        return (x >= lx && x <= rx) && (y >= ly && y <= ry);\n    } \n};\n\nmap<string, int> id;\nstring _id[MAXN];\nvector<node> butt[MAXN];\nint buff[100000];\n\nint main() {\n    int n, w, h;\n    while (scanf(\"%d\", &n), n) {\n        scanf(\"%d%d\", &w, &h);\n        REP(i, n) {\n            string name;\n            int nn;\n            cin >> name >> nn;\n            id[name] = i;\n            _id[i] = name;\n            butt[i].clear();\n            REP(j, nn) {\n                node tmp;\n                tmp.input();\n                butt[i].PB(tmp);\n            }\n        }\n        int m;\n        scanf(\"%d\", &m);\n        buff[0] = 0;\n        int p = 0, sz = 1;\n        REP(i, m) {\n            string op;\n            cin >> op;\n            int now = buff[p];\n             //out(_id[now]);\n            if (op == \"click\") {\n                int x, y;\n                cin >> x >> y;\n                REP(j, SZ(butt[now])) {\n                    if (butt[now][j].is_in(x, y)) {\n                        buff[p + 1] = id[butt[now][j].to];\n                        p = p + 1;\n                        sz = p + 1;\n                        break;\n                    }\n                }\n            } else if (op == \"show\") {\n                cout << _id[now] << endl;\n            } else if (op == \"back\") {\n                if (p - 1 >= 0) {\n                    p = p - 1;\n                }\n            } else if (op == \"forward\") {\n                if (p + 1 < sz) {\n                    p = p + 1;\n                }\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\n\nint b[100], x1[100][100], Y1[100][100], x2[100][100], y2[100][100];\nstring link[100][100];\nmap<string, int>mp;\nint main() {\n\tint n;\n\twhile (scanf(\"%d\", &n), n) {\n\t\tmp.clear();\n\t\tint w, h; scanf(\"%d%d\", &w, &h);\n\t\tvector<string>v;\n\t\trep(i, n) {\n\t\t\tstring s; cin >> s >> b[i]; mp[s] = i;\n\t\t\tif (i == 0)v.push_back(s);\n\t\t\trep(j, b[i])cin >> x1[i][j] >> Y1[i][j] >> x2[i][j] >> y2[i][j] >> link[i][j];\n\t\t}\n\t\tint pos = 0;\n\t\tint m; scanf(\"%d\", &m);\n\t\tif (m > 100)abort();\n\t\trep(i, m) {\n\t\t\tstring s; cin >> s;\n\t\t\tif (s == \"click\") {\n\t\t\t\tint x, y; cin >> x >> y;\n\t\t\t\tint a = mp[v.back()];\n\t\t\t\trep(i, b[a]) {\n\t\t\t\t\tif (x1[a][i] <= x&&x <= x2[a][i] && Y1[a][i] <= y&&y <= y2[a][i]) {\n\t\t\t\t\t\tif (pos + 1 < v.size())v.erase(v.begin() + pos + 1, v.end());\n\t\t\t\t\t\tv.push_back(link[a][i]); pos = v.size() - 1; break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (s == \"back\") {\n\t\t\t\tif (pos)pos--;\n\t\t\t}\n\t\t\tif (s == \"forward\") {\n\t\t\t\tif (pos < v.size() - 1)pos++;\n\t\t\t}\n\t\t\tif (s == \"show\")cout << v[pos] << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\n\nint b[100], x1[100][100], Y1[100][100], x2[100][100], y2[100][100];\nstring link[100][100];\nmap<string, int>mp;\nint main() {\n\tint n;\n\twhile (scanf(\"%d\", &n), n) {\n\t\tmp.clear();\n\t\tint w, h; scanf(\"%d%d\", &w, &h);\n\t\tvector<string>v;\n\t\trep(i, n) {\n\t\t\tstring s; cin >> s >> b[i]; mp[s] = i;\n\t\t\tif (i == 0)v.push_back(s);\n\t\t\trep(j, b[i])cin >> x1[i][j] >> Y1[i][j] >> x2[i][j] >> y2[i][j] >> link[i][j];\n\t\t}\n\t\tint pos = 0;\n\t\tint m; scanf(\"%d\", &m);\n\t\trep(i, m) {\n\t\t\tstring s; cin >> s;\n\t\t\tif (s == \"click\") {\n\t\t\t\tint x, y; cin >> x >> y;\n\t\t\t\tint a = mp[v.back()];\n\t\t\t\trep(i, b[a]) {\n\t\t\t\t\tif (x1[a][i] <= x&&x <= x2[a][i] && Y1[a][i] <= y&&y <= y2[a][i]) {\n\t\t\t\t\t\tif (pos + 1 < v.size())v.erase(v.begin() + pos + 1, v.end());\n\t\t\t\t\t\tv.push_back(link[a][i]); pos = v.size() - 1; break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (s == \"back\") {\n\t\t\t\tif (pos)pos--;\n\t\t\t}\n\t\t\tif (s == \"forward\") {\n\t\t\t\tif (pos < v.size() - 1)pos++;\n\t\t\t}\n\t\t\tif (s == \"show\")cout << v[pos] << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<algorithm>\n#include<iostream>\n#include<vector>\n#include<climits>\n#include<cfloat>\n\nusing namespace std;\n\nstruct point{\n  double x, y;\n};\n\nstruct button{\n  point ld,ru;\n  string name;\n};\n\nstruct page{\n  string name;\n  vector<button>btn;   \n}; \n\nint main(void){\n  int n;\n  int w,h,b;\n  point l,r;\n  page in;\n  vector<page> a;\n  button tmp;\n\n  while(cin >> n,n){\n  \n    a.clear();\n\n    cin >> w >> h;\n    \n    for(int j=0;j<n;j++){\n      cin >> in.name >> b;    \n      \n      for(int i=0;i<b;i++){\n\tcin >> tmp.ld.x >> tmp.ld.y >> tmp.ru.x >> tmp.ru.y >> tmp.name;\n\tin.btn.push_back(tmp);\n      }\n      a.push_back(in);\n    }\n\n    int m,now=0,fg=0;\n    static page buf[1000000];\n\n    cin >> m;\n    buf[0]=a[0];\n    while(m--){\n      string s;\n      cin >> s;\n      if(s==\"click\"){\n\tint c,d;\n\tcin >> c >> d;\n\t\n\tfor(int i=0;i<buf[now].btn.size();i++){\n\t  int fg2=0;\n\t  if(buf[now].btn[i].ld.x <=c &&\n\t     buf[now].btn[i].ld.y <=d &&\n\t     buf[now].btn[i].ru.x >=c &&\n\t     buf[now].btn[i].ru.y >=d){\n\t    for(int j=0;j<a.size();j++){\n\t      if(buf[now].btn[i].name==a[j].name){\n\t\tbuf[++now]=a[j];\n\t\tfg=0;\n\t\tfg2=1;\n\t\tbreak;\n\t      }\n\t    }\n\t  }\n\t  if(fg2)break;\n\t}\n      }\n      else if(s==\"back\" && now>0){\n\tnow--;\n\tfg++;\n      }\n      else if(s==\"forward\" && fg>0 && now < 1000000)now++,fg--;\n      else if(s==\"show\")cout << buf[now].name << endl;\n    }\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <utility>\n#include <map>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nclass Nx{\n\tpublic:\n\tP p, q;\n\tstring name;\n\tNx() {}\n\tNx(string _name, P _p, P _q): name(_name), p(_p), q(_q) {}\n\t\n\tbool comp(int x, int y){\n\t\treturn (p.first <= x && x <= q.first && p.second <= y && y <= q.second);\n\t}\n};\n\nclass St{\n\tpublic:\n\tstring name;\n\tvector<Nx> vec;\n\tSt() {}\n\tSt(string _name): name(_name) {}\n\t\n\tstring check(int x, int y){\n\t\tstring str = \"\";\n\t\tfor(int i = 0; i < vec.size(); i++){\n\t\t\tif(vec[i].comp(x, y)){\n\t\t\t\tstr = vec[i].name;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn str;\n\t}\n};\n\nint main()\n{\n\tint n, m, w, h, s, t, u, v, a[10000];\n\tstring str;\n\t\n\twhile(cin>>n && n){\n\t\tvector<St> vec;\n\t\tmap<string,int> mpp;\n\t\tcin >> w >> h;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tcin >> str >> m;\n\t\t\tmpp[str] = i;\n\t\t\tvec.push_back(St(str));\n\t\t\twhile(m--){\n\t\t\t\tcin >> s >> t >> u >> v >> str;\n\t\t\t\tvec[i].vec.push_back(Nx(str, P(s, t), P(u, v)));\n\t\t\t}\n\t\t}\n\t\tcin >> n;\n\t\tt = 0;\n\t\tfill(a, a+10000, -1);\n\t\ta[0] = 0;\n\t\twhile(n--){\n\t\t\tcin >> str;\n\t\t\tif(str == \"click\"){\n\t\t\t\tcin >> u >> v;\n\t\t\t\tstring tmp = vec[t].check(u, v);\n\t\t\t\tif(tmp.size() > 0){\n\t\t\t\t\tt++;\n\t\t\t\t\tfill(a+t, a+10000, -1);\n\t\t\t\t\ta[t] = mpp[tmp];\n\t\t\t\t}\n\t\t\t} else if(str == \"show\"){\n\t\t\t\tcout << vec[a[t]].name << endl;\n\t\t\t} else if(str == \"back\"){\n\t\t\t\tif(t > 0){\n\t\t\t\t\tt--;\n\t\t\t\t}\n\t\t\t} else if(str == \"forward\"){\n\t\t\t\tif(a[t+1] != -1){\n\t\t\t\t\tt++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<algorithm>\n#include<iostream>\n#include<vector>\n#include<climits>\n#include<cfloat>\n\nusing namespace std;\n\nstruct point{\n  int x, y;\n};\n\nstruct button{\n  point ld,ru;\n  string name;\n};\n\nstruct page{\n  string name;\n  vector<button>btn;   \n}; \n\nint m,now;\nvector<page> a;\npage nowpage;\nstring buf[10001];\n\nvoid click(int c,int d){\n  \n  for(int i=0;i<nowpage.btn.size();i++){\n    if(nowpage.btn[i].ld.x <=c && nowpage.btn[i].ld.y <=d &&\n       nowpage.btn[i].ru.x >=c && nowpage.btn[i].ru.y >=d)\n      buf[++now]=nowpage.btn[i].name;\n\t  fill(buf+now+1,buf+10001,\"\");\n\t  return ;\n  }\n}\n\nvoid func(void){\n  for(int i=0;i<a.size();i++){\n    if(buf[now]==a[i].name){\n      nowpage=a[i];\n      return ;\n    }\n  }\n}\n\nint main(void){\n  int n;\n  int w,h,b;\n  point l,r;\n  page in;\n  button tmp;\n\n  while(cin >> n,n){\n  \n    a.clear();\n    fill(buf,buf+10001,\"\");\n\n    cin >> w >> h;\n    \n    for(int j=0;j<n;j++){\n      cin >> in.name >> b;    \n      \n      for(int i=0;i<b;i++){\n\tcin >> tmp.ld.x >> tmp.ld.y >> tmp.ru.x >> tmp.ru.y >> tmp.name;\n\tin.btn.push_back(tmp);\n      }\n      a.push_back(in);\n    }\n\n    now=0;\n    buf[0]=a[0].name;\n    nowpage=a[0];\n\n    cin >> m;\n\n    while(m--){\n      string s;\n      cin >> s;\n      if(s==\"click\"){\n\tint c,d;\n\tcin >> c >> d;\n\tclick(c,d);\n      }\n      else if(s==\"back\" && now>0)now--;\n      else if(s==\"forward\" && buf[now+1]!=\"\")now++;\n      else if(s==\"show\")cout << buf[now] << endl;\n\n      func();\n    }\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n\n#define x first\n#define y second\n\nusing pi = pair<int,int>;\nusing P = pair<pi,pi>;\n\nstruct Page{\n    string name;\n\n    int m;\n    vector<P> b;\n    vector<string> l;\n\n    Page(){};\n\n    void READ(){\n        cin >>name >>m;\n        b = vector<P>(m);\n        l = vector<string>(m);\n        rep(i,m){\n            cin >>b[i].fi.x >>b[i].fi.y >>b[i].se.x >>b[i].se.y;\n            cin >>l[i];\n        }\n    }\n\n    string click(int x, int y){\n        rep(i,m){\n            if(b[i].fi.x<=x && x<=b[i].se.x && b[i].fi.y<=y && y<=b[i].se.y) return l[i];\n        }\n        return \"?\";\n    }\n};\n\nint main(){\n    int n;\n    while(cin >>n,n){\n        int W,H;\n        cin >>W >>H;\n\n        vector<Page> p(n);\n        rep(i,n) p[i].READ();\n\n        map<string,int> name2id;\n        rep(i,n) name2id[p[i].name] = i;\n\n        int Q;\n        cin >>Q;\n\n        vector<int> a(Q+2,-1);\n        int idx = 0;\n        a[0] = 0;\n\n        rep(qq,Q){\n            string s;\n            cin >>s;\n            if(s == \"click\"){\n                int X,Y;\n                cin >>X >>Y;\n                string res = p[a[idx]].click(X,Y);\n                if(res != \"?\"){\n                    for(int j=idx+1; j<Q+2; ++j) a[j] = -1;\n                    a[idx+1] = name2id[res];\n                    ++idx;\n                }\n            }\n            else if(s == \"back\"){\n                if(idx>0) --idx;\n            }\n            else if(s == \"forward\"){\n                if(a[idx+1] != -1) ++idx;\n            }\n            else{\n                // show\n                cout << p[a[idx]].name << \"\\n\";\n            }\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <string>\n\nusing namespace std;\n\nstruct button{\n\tstring toName;\n\tint minx;\n\tint maxx;\n\tint miny;\n\tint maxy;\n};\n\nint page;\nvector<string> history;\nint n;\nint h,w;\nmap<string,vector<button> > pageInfo;\n\nint main(){\n\n\twhile(cin>>n&&n!=0){\n\t\thistory.clear();\n\t\tpageInfo.clear();\n\t\tpage=0;\n\t\thistory.clear();\n\t\tcin>>w>>h;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tstring str;\n\t\t\tint bn;\n\t\t\tcin>>str>>bn;\n\t\t\tif(i==0){\n\t\t\t\thistory.push_back(str);\n\t\t\t}\n\t\t\tvector<button> vb;\n\t\t\tfor(int j = 0; j < bn; j++){\n\t\t\t\tbutton b;\n\t\t\t\tcin>>b.minx>>b.miny>>b.maxx>>b.maxy>>b.toName;\n\t\t\t\tvb.push_back(b);\n\t\t\t}\n\t\t\tpageInfo[str]=vb;\n\t\t}\n\t\tint m;\n\t\tcin>>m;\n\t\t// operation start\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tstring op;\n\t\t\tcin>>op;\n\t\t\tif(op==\"click\"){\n\t\t\t\tint x,y;\n\t\t\t\tcin>>x>>y;\n\t\t\t\t// buttonÌÊuðcheck\n\t\t\t\tfor(int j = 0; j < pageInfo[history[page]].size(); j++){\n\t\t\t\t\t// Ú®Å«éÌÈçÎA»ÝÌêÌ¨É éhistoryðíµA»ÝÌêÌ¨ÉÚ®æy[WðÇÁµApageðCNg\n\t\t\t\t\tbutton &b = pageInfo[history[page]][j];\n\t\t\t\t\tif(b.minx<=x&&b.maxx>=x&&b.miny<=y&&b.maxy>=y){\n\t\t\t\t\t\t// »ÝÌêÌEÉ éhistoryðí\n\t\t\t\t\t\tint t=history.size();\n\t\t\t\t\t\tfor(int k = page+1; k < t; k++){\n\t\t\t\t\t\t\thistory.erase(history.begin()+history.size()-1);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// »ÝÌêÌEÉÚ®æy[WðÇÁ\n\t\t\t\t\t\thistory.push_back(b.toName);\n\t\t\t\t\t\tpage++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(op==\"show\"){\n\t\t\t\tcout<<history[page]<<endl;\n\t\t\t}\n\t\t\telse if(op==\"back\"){\n\t\t\t\tpage=max(0,page-1);\n\t\t\t}\n\t\t\telse if(op==\"forward\"){\n\t\t\t\tpage=min((int)history.size()-1,page+1);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<list>\n#include<algorithm>\n#include<iostream>\n#include<string>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\nusing namespace std;\nint main(){\n  int i,j,k,l;\n  int a[100],lx[100][100],uy[100][100],rx[100][100],dy[100][100],x,y,m,n,w,h;\n  int cr,sz;\n  string s[100],t[100][100],v;\n  vector<string> u;\n  while(cin>>n&&n){\n    cin>>w>>h;\n    for(i=0;i<n;i++){\n      cin>>s[i]>>a[i];\n      for(j=0;j<a[i];j++)\n\tcin>>lx[i][j]>>uy[i][j]>>rx[i][j]>>dy[i][j]>>t[i][j];\n    }\n    u.clear();\n    u.push_back(s[0]);\n    cr=0;\n    cin>>m;\n    for(i=0;i<m;i++){\n      cin>>v;\n      if(v==\"click\"){\n\tcin>>x>>y;\n\tfor(j=0;u[cr]!=s[j];j++);\n\tfor(k=0;k<a[j];k++){\n\t  if(lx[j][k]<=x&&x<=rx[j][k]&&uy[j][k]<=y&&y<=dy[j][k])\n\t    break;\n\t}\n\tif(k!=a[j]){\n\t  sz=u.size();\n\t  for(l=0;l<sz-cr-1;l++)\n\t    u.pop_back();\n\t  u.push_back(t[j][k]);\n\t  cr++;\n\t}\n      }else if(v==\"show\"){\n\tcout<<u[cr]<<endl;\n      }else if(v==\"back\"){\n\tif(cr)\n\t  cr--;\n      }else if(v==\"forward\"){\n\tif(cr!=(int)u.size()-1)\n\t  cr++;\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<algorithm>\n#include<iostream>\n#include<vector>\n#include<climits>\n#include<cfloat>\n\nusing namespace std;\n\ndouble EPS = 1e-10;\n\ndouble add(double a, double b){\n  if(abs(a+b) < EPS * (abs(a)+abs(b)))return 0;\n  return a+b;\n}\n\nstruct point{\n  double x, y;\n  point(){}\n  point(double x,double y) : x(x) , y(y){}\n\n  point operator + (point p){\n    return point(add(x,p.x), add(y,p.y));\n  }\n\n  point operator - (point p){\n    return point(add(x,-p.x), add(y,-p.y));\n  }\n\n  point operator * (double d){\n    return point(x*d,y*d);\n  }\n\n  point operator / (double d){\n    return point(x/d,y/d);\n  }\n  \n  bool operator == ( const point &p ) const {\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n};\n\nstruct button{\n  point ld,ru;\n  string name;\n};\n\nstruct page{\n  string name;\n  vector<button>btn;   \n}; \n\nint tail;\npage stk[1000000];\n\nvoid push(page a){\n  stk[++tail]=a;\n}\n\npage pop(void){\n  tail--;\n  return stk[tail];\n}\n\nint main(void){\n  int n;\n  int w,h,b;\n  point l,r;\n  page in;\n  vector<page> a;\n  button tmp;\n\n  while(cin >> n,n){\n  \n    a.clear();\n\n    cin >> w >> h;\n    \n    for(int j=0;j<n;j++){\n      cin >> in.name >> b;    \n      \n      for(int i=0;i<b;i++){\n\tcin >> tmp.ld.x >> tmp.ld.y >> tmp.ru.x >> tmp.ru.y >> tmp.name;\n\tin.btn.push_back(tmp);\n      }\n      a.push_back(in);\n    }\n\n    int m,now=0;\n\n    cin >> m;\n    tail=0;\n    int fg=0;\n    push(a[0]);\n    while(m--){\n      string s;\n      cin >> s;\n      if(s==\"click\"){\n\tint c,d;\n\tcin >> c >> d;\n\t\n\tfor(int i=0;i<stk[tail].btn.size();i++){\n\t  if(stk[tail].btn[i].ld.x <=c &&\n\t     stk[tail].btn[i].ld.y <=d &&\n\t     stk[tail].btn[i].ru.x >=c &&\n\t     stk[tail].btn[i].ru.y >=d){\n\t    for(int j=0;j<a.size();j++){\n\t      if(stk[tail].btn[i].name==a[j].name){\n\t\tpush(a[j]);\n\t\tfg=0;\n\t      }\n\t    }\n\t  }\n\t}\n      }\n      else if(s==\"back\" && tail>0){\n\ttail--;\n\tfg++;\n      }\n      else if(s==\"forward\" && fg>0 && tail+1 < 1000000)tail++,fg--;\n      else if(s==\"show\")cout << stk[tail].name << endl;\n    }\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <map>\n#include <iostream>\n#define M make_pair\n#define F first\n#define S second\nusing namespace std;\ntypedef vector<pair<\n\tpair<\n\t\tpair<int,int>,\n\t\tpair<int,int>\n\t>,string\n> >links;\nmain(){\n\tint N,n,x1,y1,x2,y2,cur;\n\tstring s,t;\n\tfor(;cin>>N>>x1>>y1;){\n\t\tmap<string,links>m;\n\t\tvector<string>visit;\n\t\tfor(cur=-1;N;N--){\n\t\t\tlinks v;\n\t\t\tfor(cin>>s>>n;n;n--)\n\t\t\t\tcin>>x1>>y1>>x2>>y2>>t,v.push_back(M(M(M(x1,x2),M(y1,y2)),t));\n\t\t\tm[s]=v;\n\t\t\tif(cur==-1)visit.push_back(s),cur=0;\n\t\t}\n\t\tfor(cin>>N;N;N--){\n\t\t\tif(cin>>s,s==\"show\")cout<<visit[cur]<<endl;\n\t\t\tif(s==\"back\"){if(cur>0)cur--;}\n\t\t\tif(s==\"forward\"){if(cur<visit.size()-1)cur++;}\n\t\t\tif(s==\"click\"){\n\t\t\t\tcin>>x1>>y1;\n\t\t\t\tlinks v=m[visit[cur]];\n\t\t\t\tfor(n=0;n<v.size();n++){\n\t\t\t\t\tif(v[n].F.F.F<=x1&&x1<=v[n].F.F.S && v[n].F.S.F<=y1&&y1<=v[n].F.S.S){\n\t\t\t\t\t\tfor(;cur<visit.size()-1;)visit.erase(visit.begin()+cur+1);\n\t\t\t\t\t\tvisit.push_back(v[n].S);cur++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n#include <list>\n#include <map>\nusing namespace std;\n\nstruct C\n{\n  string s;\n  int x1;\n  int y1;\n  int x2;\n  int y2;\n  C ( int x1, int y1, int x2, int y2, const char *s )\n  {\n    this->x1 = x1;\n    this->y1 = y1;\n    this->x2 = x2;\n    this->y2 = y2;\n    this->s = s;\n  }\n};\n\nint\nmain (\n  int   argc,\n  char *argv[ ]\n  )\n{\n  list<C>::iterator it;\n  int i;\n\n  for ( ; ; )\n  {\n    map<string,list<C> > lis;\n    list<string> buf;\n    list<string> cont;\n    int w, h;\n    int n;\n\n    scanf ( \" %d\", &n );\n    if ( n == 0 ) break ;\n\n    scanf ( \" %d %d\", &w, &h );\n    while ( n-- )\n    {\n      list<C> r;\n      char s[ 32 ];\n      int c;\n\n      scanf ( \" %s %d\", s, &c );\n      if ( buf.empty ( ) )\n        buf.push_back ( s );\n      for ( i = 0; i < c; ++i )\n      {\n        int x1, y1, x2, y2;\n        char t[ 32 ];\n\n        scanf ( \" %d %d %d %d %s\", &x1, &y1, &x2, &y2, t );\n        r.push_back ( C ( x1, y1, x2, y2, t ) );\n      }\n      lis[ s ] = r;\n    }\n\n    scanf ( \" %d\", &n );\n    while ( n-- )\n    {\n      char cmd[ 32 ];\n\n      scanf ( \" %s\", cmd );\n\n      if ( strcmp ( \"show\", cmd ) == 0 )\n      {\n        puts ( buf.back ( ).c_str ( ) );\n        continue ;\n      }\n      if ( strcmp ( \"click\", cmd ) == 0 )\n      {\n        list<C> *p;\n        int x, y;\n\n        scanf ( \" %d %d\", &x, &y );\n\n        p = &lis[ buf.back ( ) ];\n        for ( it = p->begin ( ); it != p->end ( ); ++it )\n        {\n          if ( x >= it->x1 && x <= it->x2\n            && y >= it->y1 && y <= it->y2 )\n          {\n            buf.push_back ( it->s );\n            cont.clear ( );\n            break ;\n          }\n        }\n\n        continue ;\n      }\n      if ( strcmp ( \"back\", cmd ) == 0 )\n      {\n        if ( buf.size ( ) >= 2 )\n        {\n          cont.push_front ( buf.back ( ) );\n          buf.pop_back ( );\n        }\n        continue ;\n      }\n      if ( strcmp ( \"forward\", cmd ) == 0 )\n      {\n        if ( cont.size ( ) >= 1 )\n        {\n          buf.push_back ( cont.front ( ) );\n          cont.pop_front ( );\n        }\n        continue ;\n      }\n    }\n  }\n\n  return ( EXIT_SUCCESS );\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <deque>\n#include <map>\nusing namespace std;\ntypedef struct{int sx, sy, ex, ey; string to;} LINK;\t//ボタンの左上・右下座標、リンク先のページ名\ntypedef struct{string name; int n; LINK btn[100];} PAGE;\t//ページ名、ページ上にあるボタンの数・その一覧\nint main()\n{\n\tint n, o, W, H;\t//ページの数、命令の数、ページの幅・高さ\n\tint i, j, x, y, cur, t, m;\t//ループ用変数、\"click x y\"のx,y、、一時的な、履歴の長さ\n\tstring op;\t//命令の名前\n\tPAGE pg[100];\n\tLINK tmp;\n\tmap<string, int> tbl;\n\twhile (cin >> n, n)\n\t{\n\t\tdeque<string> his;\t//ページの履歴（pg[i]のiを代入）\n\t\tdeque<string>::iterator itr;\n\t\tcin >> W >> H;\n\t\tfor (i = 0; i < n; i++)\n\t\t{\n\t\t\tcin >> pg[i].name >> pg[i].n;\n\t\t\ttbl.insert( map<string, int>::value_type(pg[i].name, i) );\n\t\t\tfor (j = 0; j < pg[i].n; j++)\n\t\t\t{\n\t\t\t\tcin >> tmp.sx >> tmp.sy >> tmp.ex >> tmp.ey >> tmp.to;\n\t\t\t\tpg[i].btn[j] = tmp;\n\t\t\t}\n\t\t}\n\t\tcin >> o;\n\t\this.push_back(pg[0].name);\n\t\tcur = 0;\n\t\tm = 1;\n\t\tfor (i = 0; i < o; i++)\n\t\t{\n\t\t\tcin >> op;\n\t\t\tif (op == \"click\")\n\t\t\t{\n\t\t\t\tcin >> x >> y;\n\t\t\t\tt = tbl[his.at(cur)];\n\t\t\t\tfor (j = 0; j < pg[t].n; j++)\n\t\t\t\t{\n\t\t\t\t\tif (pg[t].btn[j].sx <= x && x <= pg[t].btn[j].ex && pg[t].btn[j].sy <= y && y <= pg[t].btn[j].ey)\n\t\t\t\t\t{\n\t\t\t\t\t\this.push_back(pg[t].btn[j].to);\n\t\t\t\t\t\tcur++;\n\t\t\t\t\t\tm++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\titr = his.end();\n\t\t\t\tfor (j = cur+1; j < m; j++)\n\t\t\t\t{\n\t\t\t\t\this.erase(*itr);\n\t\t\t\t\tm--;\n\t\t\t\t\t*itr--;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (op == \"back\")\n\t\t\t{\n\t\t\t\tif (cur > 0)\n\t\t\t\t\tcur--;\n\t\t\t}\n\t\t\telse if (op == \"forward\")\n\t\t\t{\n\t\t\t\tif (cur < m)\n\t\t\t\t\tcur++;\n\t\t\t}\n\t\t\telse if (op == \"show\")\n\t\t\t{\n\t\t\t\tcout << his.at(cur) << endl;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <iostream>\n#include <algorithm>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <utility>\n#include <cctype>\n#include <cassert>\nusing namespace std;\n\n#define rep(i,n) for(int (i)=0; (i)<(int)(n); ++(i))\n#define foreach(c,i) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n\nstruct Button {\n  int lx, ly, rx, ry, to;\n  bool Check(int cx, int cy) {\n    return (lx <= cx) && (cx <= rx) && (ly <= cy) && (cy <= ry);\n  }\n};\n\nint N, W, H, Q;\nvector<int> B(102);\nvector<string> vs(102);\nvector<Button> vbs[102];\n\nint main() {\n  while (cin >> N, N) {\n    cin >> W >> H;\n\n    vector<vector<string> > links(N, vector<string>());\n    map<string,int> maps;\n    string temp;\n    int lx, ly, rx, ry;\n    \n    rep(i,N) {\n      cin >> vs[i] >> B[i];\n      maps.insert(make_pair(vs[i], i));\n      rep(j,B[i]) {\n        cin >> lx >> ly >> rx >> ry >> temp;\n        vbs[i].push_back((Button){lx, ly, rx, ry, -1});\n        links[i].push_back(temp);\n      }\n    }\n\n    rep(i,N) {\n      rep(j,links[i].size()) {\n        vbs[i][j].to = maps[ links[i][j] ];\n      }\n    }\n\n    cin >> Q;\n    string query;\n    int cx, cy;\n    vector<string> buffer(1, vs[0]);\n    vector<string>::iterator itr;\n    int ptr = 0;\n    \n    rep(q,Q) {\n      cin >> query;\n      if (query == \"click\") {\n        cin >> cx >> cy;\n        int cur = maps[ vs[ptr] ];\n        rep(i,B[cur]) {\n          if (vbs[cur][i].Check(cx, cy)) {\n            if (ptr != buffer.size()-1) {\n              itr = buffer.begin();\n              advance(itr, ptr+1);\n              buffer.erase(itr, buffer.end());             \n            }\n            buffer.push_back(vs[ vbs[cur][i].to ]);\n            // printf(\"clicked success to %s\\n\", vs[ vbs[cur][i].to ].c_str());\n            ++ptr;\n            break;\n          }\n        }\n      } else if(query == \"show\") {\n        cout << buffer[ptr] << endl;\n      } else if(query == \"back\") {\n        if (ptr > 0) --ptr;\n      } else if(query == \"forward\") {\n        if (buffer.size() - 1 > ptr) ++ptr;\n      } else {\n        assert(false);\n      }\n      // printf(\"state %3d:\", q);\n      // rep(i,buffer.size()) printf(\"[%s]\",buffer[i].c_str()); puts(\"\");      \n    }\n    \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n\nstruct Page{\n    char name[50],bname[105][50];\n    int bnum,tx[105],ty[105],bx[105],by[105];\n}page[105];\n\nint n,m,H,W,px,py;\nchar ord[50];\nint q[100005],p,l;\n\nint main(){\n    //freopen(\"D.in\",\"r\",stdin);\n    //freopen(\"D.out\",\"w\",stdout);\n    \n    int i,j;\n    \n    while(1){\n        scanf(\"%d\",&n);\n        if(n == 0)\n            break;    \n        \n        scanf(\"%d %d\",&H,&W);\n        //printf(\"%d %d %d\\n\",n,H,W);\n        \n        for(i = 0;i < n;i ++){\n            scanf(\"%s %d\",page[i].name,&page[i].bnum);\n            //printf(\"%s %d\\n\",page[i].name,page[i].bnum);\n            for(j = 0;j < page[i].bnum;j ++){\n                scanf(\"%d %d %d %d %s\",&page[i].tx[j],&page[i].ty[j],&page[i].bx[j],&page[i].by[j],page[i].bname[j]);\n                //printf(\"%d %d %d %d %s\\n\",page[i].tx[j],page[i].ty[j],page[i].bx[j],page[i].by[j],page[i].bname[j]);\n            }\n        }\n        \n        q[0] = 0;\n        p = 0;\n        l = 1;\n        scanf(\"%d\",&m);\n        while(m --){\n            scanf(\"%s\",ord);\n            if(ord[0] == 'c'){//click\n                scanf(\"%d %d\",&px,&py);    \n                for(i = 0;i < page[q[p]].bnum;i ++){\n                    if(px >= page[q[p]].tx[i] && py >= page[q[p]].ty[i] &&\n                       px <= page[q[p]].bx[i] && py <= page[q[p]].by[i]){\n                        j = 0;\n                        while(j < n){\n                            if(strcmp(page[j].name,page[q[p]].bname[i]) == 0)        \n                                break;\n                            j ++;\n                        }\n                        q[l] = j;\n                        p = l;\n                        l ++;\n                        \n                        break;\n                    }\n                }\n            }\n            \n            else if(ord[0] == 's')//show\n                printf(\"%s\\n\",page[q[p]].name);\n            \n            else if(ord[0] == 'f'){//forward\n                if(p + 1 == l);\n                else\n                    p ++;\n            }\n            \n            else if(ord[0] == 'b'){//back\n                if(p - 1 < 0);\n                else\n                    p --;\n            }\n        }\n        \n    }\n    \n    return 0;    \n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<algorithm>\n#include<iostream>\n#include<vector>\n#include<climits>\n#include<cfloat>\n\nusing namespace std;\n\ndouble EPS = 1e-10;\n\ndouble add(double a, double b){\n  if(abs(a+b) < EPS * (abs(a)+abs(b)))return 0;\n  return a+b;\n}\n\nstruct point{\n  double x, y;\n  point(){}\n  point(double x,double y) : x(x) , y(y){}\n\n  point operator + (point p){\n    return point(add(x,p.x), add(y,p.y));\n  }\n\n  point operator - (point p){\n    return point(add(x,-p.x), add(y,-p.y));\n  }\n\n  point operator * (double d){\n    return point(x*d,y*d);\n  }\n\n  point operator / (double d){\n    return point(x/d,y/d);\n  }\n  \n  bool operator == ( const point &p ) const {\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n};\n\nstruct button{\n  point ld,ru;\n  string name;\n};\n\nstruct page{\n  string name;\n  vector<button>btn;   \n}; \n\nint main(void){\n  int n;\n  int w,h,b;\n  point l,r;\n  page in;\n  vector<page> a;\n  button tmp;\n\n  while(cin >> n,n){\n  \n    a.clear();\n\n    cin >> w >> h;\n    \n    for(int j=0;j<n;j++){\n      cin >> in.name >> b;    \n      \n      for(int i=0;i<b;i++){\n\tcin >> tmp.ld.x >> tmp.ld.y >> tmp.ru.x >> tmp.ru.y >> tmp.name;\n\tin.btn.push_back(tmp);\n      }\n      a.push_back(in);\n    }\n\n    int m,now=0,fg=0;\n    static page buf[10000000];\n\n    cin >> m;\n    buf[0]=a[0];\n    while(m--){\n      string s;\n      cin >> s;\n      if(s==\"click\"){\n\tint c,d;\n\tcin >> c >> d;\n\t\n\tfor(int i=0;i<buf[now].btn.size();i++){\n\t  int fg2=0;\n\t  if(buf[now].btn[i].ld.x <=c &&\n\t     buf[now].btn[i].ld.y <=d &&\n\t     buf[now].btn[i].ru.x >=c &&\n\t     buf[now].btn[i].ru.y >=d){\n\t    for(int j=0;j<a.size();j++){\n\t      if(buf[now].btn[i].name==a[j].name){\n\t\tbuf[++now]=a[j];\n\t\tfg=0;\n\t\tfg2=1;\n\t\tbreak;\n\t      }\n\t    }\n\t    if(fg2)break;\n\t  }\n\t}\n      }\n      else if(s==\"back\" && now>0){\n\tnow--;\n\tfg++;\n      }\n      else if(s==\"forward\" && fg-- && now < 10000000)now++;\n      else if(s==\"show\")cout << buf[now].name << endl;\n    }\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nint i,j;\nstruct button\n{\n\tstring in;\n\tint x1;\n\tint y1;\n\tint x2;\n\tint y2;\n\tstring to;\n};\nint main()\n{\n\tfor(int n;cin>>n&&n;)\n\t{\n\t\tint w,h;\n\t\tcin>>w>>h;\n\t\tbutton a[10000];\n\t\tint q=0;\n\t\tfor(i=0;i<n;++i)\n\t\t{\n\t\t\tstring ss;\n\t\t\tint tt;\n\t\t\tcin>>ss>>tt;\n\t\t\tfor(j=0;j<tt;++j)\n\t\t\t{\n\t\t\t\tint xx1,yy1,xx2,yy2;\n\t\t\t\tstring TO;\n\t\t\t\tcin>>xx1>>yy1>>xx2>>yy2>>TO;\n\t\t\t\ta[q].in=ss;\n\t\t\t\ta[q].to=TO;\n\t\t\t\ta[q].x1=xx1;\n\t\t\t\ta[q].x2=xx2;\n\t\t\t\ta[q].y1=yy1;\n\t\t\t\ta[q++].y2=yy2;\n\t\t\t}\n\t\t}\n\t\tint m;\n\t\tcin>>m;\n\t\tstring b[100];\n\t\tint p=0,pp=0;\n\t\tb[0]=a[0].in;\n\t\tfor(i=0;i<m;++i)\n\t\t{\n\t\t\tstring k;\n\t\t\tcin>>k;\n\t\t\tif(k==\"show\")\n\t\t\t\tcout<<b[pp]<<endl;\n\t\t\tif(k==\"back\"&&pp!=0)\n\t\t\t\tpp--;\n\t\t\tif(k==\"forward\"&&pp!=p)\n\t\t\t\tpp++;\n\t\t\tif(k==\"click\")\n\t\t\t{\n\t\t\t\tint x,y,f=0,e=q-1;\n\t\t\t\tcin>>x>>y;\n\t\t\t\t//cout<<f<<' '<<e<<endl;\n\t\t\t\tfor(j=0;j<q;++j)\n\t\t\t\t\tif(a[j].in==b[pp])\n\t\t\t\t\t{\n\t\t\t\t\t\tf=j;\n\t\t\t\t\t    for(int kk=f;kk<q;++kk)\n\t\t\t\t\t\t\tif(a[kk].in!=b[pp])\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\te=kk-1;\n\t\t\t\t\t\t\t\tgoto abc;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\tabc:\t\n\t\t\t\t//cout<<f<<' '<<e<<endl;\n\t\t\t\t\tint tj,mm=0;\n\t\t\t\t\tfor(j=f;j<=e;++j)\n\t\t\t\t\t\tif(x>a[j].x1&&x<a[j].x2&&y>a[j].y1&&y<a[j].y2)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tmm++;\n\t\t\t\t\t\t\ttj=j;\n\t\t\t\t\t\t}\n\t\t\t\t\tif(mm==1)\n\t\t\t\t\t{\n\t\t\t\t\t\tp=pp;\n\t\t\t\t\t\tb[++p]=a[tj].to;\n\t\t\t\t\t\tpp=p;\n\t\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <string>\n#include <vector>\n#include <iostream>\nusing namespace std;\nint N, W, H, Q, x, y, c[109], xa[109][109], ya[109][109], xb[109][109], yb[109][109]; string s[109], t[109][109], tp;\nint main() {\n\twhile (cin >> N, N) {\n\t\tcin >> W >> H;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tcin >> s[i] >> c[i];\n\t\t\tfor (int j = 0; j < c[i]; j++) {\n\t\t\t\tcin >> xa[i][j] >> ya[i][j] >> xb[i][j] >> yb[i][j] >> t[i][j];\n\t\t\t}\n\t\t}\n\t\tcin >> Q;\n\t\tvector<int> res; res.push_back(0);\n\t\tint pos = 0;\n\t\tfor (int i = 0; i < Q; i++) {\n\t\t\tcin >> tp;\n\t\t\tif (tp == \"click\") {\n\t\t\t\tcin >> x >> y;\n\t\t\t\tfor (int j = 0; j < c[res[pos]]; j++) {\n\t\t\t\t\tif (xa[res[pos]][j] <= x && x <= xb[res[pos]][j] && ya[res[pos]][j] <= y && y <= yb[res[pos]][j]) {\n\t\t\t\t\t\tint ptr = -1;\n\t\t\t\t\t\tfor (int k = 0; k < N; k++) {\n\t\t\t\t\t\t\tif (s[k] == t[res[pos]][j]) ptr = k;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tres.resize(pos + 2);\n\t\t\t\t\t\tres[++pos] = ptr;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (tp == \"show\") cout << s[res[pos]] << endl;\n\t\t\tif (tp == \"forward\" && pos + 1 != res.size()) pos++;\n\t\t\tif (tp == \"back\" && pos != 0) pos--;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <set>\n \nusing namespace std;\n \n#define f first\n#define s second\n \ntypedef pair<int, int> P;\ntypedef pair<P, P> P2;\ntypedef pair<P2, string> P3;\n \nint main(){\n  int n;\n  int W, H;\n   \n  while(cin >> n, n){\n    cin >> W >> H;\n    \n    map<string, int> n_link;\n    map<string, vector<P3> > page;\n    vector<P3> link;\n    string page_name;\n    string now;\n    int n_button;\n     \n    for(int i = 0 ; i < n ; i++){\n      cin >> page_name >> n_button;\n      n_link.insert(make_pair(page_name, n_button));\n      if(i == 0) now = page_name;\n      for(int j = 0 ; j < n_button ; j++){\n\tP3 tmp;\n\tcin >> tmp.f.f.f >> tmp.f.f.s >> tmp.f.s.f >> tmp.f.s.s >> tmp.s;\n\tlink.push_back(tmp);\n      }\n      page.insert(make_pair(page_name, link));\n      link.clear();\n    }\n\n    int n_op, x, y;\n    string op;\n    vector<string> history;\n    history.push_back(now);\n    int n_now = 0;\n    cin >> n_op;\n    cin.ignore();\n    while(n_op--){\n      getline(cin, op);\n\n      if(op[0] == 'c'){ // click\n\tstring tmp1=\"\", tmp2=\"\";\n\tint i;\n\tfor(i = 6 ; op[i] != ' ' ; i++) tmp1 += op[i];\n\tfor( ; i < op.size() ; i++) tmp2 += op[i];\n     \n\tx = atoi(tmp1.c_str());\n\ty = atoi(tmp2.c_str());\n\t\n\tfor(i = 0 ; i < page[now].size() ; i++){\n\t  if((page[now][i].f.f.f <= x && x <= page[now][i].f.s.f) &&\n\t     (page[now][i].f.f.s <= y && y <= page[now][i].f.s.s)){\n\t    now = page[now][i].s;\n\t    \n\t    for(i = history.size()-1 ; i > n_now ; i--){ // when back click\n\t      history.pop_back();\n\t    }\n\t    n_now = i;\n\t    history.push_back(now);\n\t    n_now++;\n\t  }\n\t}\n      } // click end\n      \n      if(op == \"show\") cout << now << endl;\n      if(op == \"back\"){\n\tif(n_now == 0) continue;\n\tn_now--;\n\tnow = history[n_now];\n      }\n      if(op == \"forward\"){\n\tif(n_now == history.size()-1) continue;\n\tn_now++;\n\tnow = history[n_now];\n      }\n    }\n    page.clear();\n    history.clear();\n    link.clear();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int, int> pii;\n\ntypedef struct button{\n  pii s, e;\n  string link;\n}button;\n\ntypedef struct window{\n  string name;\n  vector<button> b;\n}window;\n\nbool range(pii s, pii e, int w, int h){\n  return s.first <= w and w <= e.first and\n    s.second <= h and h <= e.second;\n}\n\nint main(){\n  int n, m, l, W, H;\n  while(std::cin >> n, n){\n    vector<window> vw(n);\n    map<string, int> next;\n    std::cin >> W >> H;\n    for (int i = 0; i < n; i++) {\n      std::cin >> vw[i].name >> l;\n      next[vw[i].name] = i;\n      for (int j = 0; j < l; j++) {\n        button tmp;\n        std::cin >> tmp.s.first >> tmp.s.second\n                 >> tmp.e.first >> tmp.e.second >> tmp.link;\n        vw[i].b.push_back(tmp);\n      }\n    }\n    std::cin >> m;\n    //std::cout << m << std::endl;\n    string s;\n    vector<string> buffer;\n    buffer.push_back(vw[0].name);\n    int pos = 0;\n    for (int i = 0; i < m; i++) {\n      std::cin >> s;\n      //std::cout << \"s = \" << s << std::endl;\n      if(s == \"click\"){\n        int w, h;\n        std::cin >> w >> h;\n        int win = next[buffer[pos]];\n        for (int j = 0; j < vw[win].b.size(); j++) {\n          if(range(vw[win].b[j].s, vw[win].b[j].e,\n                   w, h)){\n            buffer.erase(buffer.begin() + pos + 1, buffer.end());\n            buffer.push_back(vw[win].b[j].link);\n            pos++;\n          }\n        }\n      }else if(s == \"show\"){\n        std::cout << vw[pos].name << std::endl;\n      }else if(s == \"back\"){\n        pos = max(0, (int)(pos - 1));\n      }else if(s == \"forward\"){\n        pos = min((int)(buffer.size() - 1), pos + 1);\n      }\n    }\n  }\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<algorithm>\n#include<iostream>\n#include<vector>\n#include<climits>\n#include<cfloat>\n\nusing namespace std;\n\nstruct point{\n  int x, y;\n};\n\nstruct button{\n  point ld,ru;\n  string name;\n};\n\nstruct page{\n  string name;\n  vector<button>btn;   \n}; \n\nint m,now;\nvector<page> a;\npage nowpage;\nstring buf[10001];\n\nvoid click(int c,int d){\n  \n  for(int i=0;i<nowpage.btn.size();i++)\n    if(nowpage.btn[i].ld.x <=c && nowpage.btn[i].ld.y <=d &&\n       nowpage.btn[i].ru.x >=c && nowpage.btn[i].ru.y >=d)\n      buf[++now]=nowpage.btn[i].name;\n\t  fill(buf+now+1,buf+10000,\"\");\n}\n\nvoid func(void){\n  for(int i=0;i<a.size();i++){\n    if(buf[now]==a[i].name){\n      nowpage=a[i];\n      return ;\n    }\n  }\n}\n\nint main(void){\n  int n;\n  int w,h,b;\n  point l,r;\n  page in;\n  button tmp;\n\n  while(cin >> n,n){\n  \n    a.clear();\n    fill(buf,buf+10000,\"\");\n\n    cin >> w >> h;\n    \n    for(int j=0;j<n;j++){\n      cin >> in.name >> b;    \n      \n      for(int i=0;i<b;i++){\n\tcin >> tmp.ld.x >> tmp.ld.y >> tmp.ru.x >> tmp.ru.y >> tmp.name;\n\tin.btn.push_back(tmp);\n      }\n      a.push_back(in);\n    }\n\n    now=0;\n    buf[0]=a[0].name;\n    nowpage=a[0];\n\n    cin >> m;\n\n    while(m--){\n      string s;\n      cin >> s;\n      if(s==\"click\"){\n\tint c,d;\n\tcin >> c >> d;\n\tclick(c,d);\n      }\n      else if(s==\"back\" && now>0)now--;\n      else if(s==\"forward\" && buf[now+1]!=\"\")now++;\n      else if(s==\"show\")cout << buf[now] << endl;\n\n      func();\n    }\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<map>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\nstruct POINT{\n  int x1, y1;\n  int x2, y2;\n};\n\nmultimap<string, POINT> MakeButton(int);\nvoid Click(map< string, multimap<string, POINT> >,\n\t   vector<string>&, int&, int, int);\n\nint main(){\n  int i, n, m, w, h, now;\n  string str;\n  vector<string> logdata;\n  map< string, multimap<string, POINT> > webpage;\n\n  while(1){\n    cin >> n;\n    if(n == 0) break;\n    cin >> w >> h;\n\n    for(i=0; i<n; ++i){\n      cin >> str >> m;\n      if(i == 0) logdata.push_back(str);\n      webpage.insert(make_pair(str, MakeButton(m)));\n    }\n\n    cin >> m;\n    for(i=0, now=0; i<m; ++i){\n      cin >> str;\n      if(str == \"click\") Click(webpage, logdata, now, w, h);\n      else if(str == \"back\" && now > 0) --now;\n      else if(str == \"forward\" && now < logdata.size()-1) ++now;\n      else if(str == \"show\") cout << logdata[now] << endl;\n    }\n\n    logdata.clear();\n    webpage.clear();\n  }\n  return 0;\n}\n\nmultimap<string, POINT> MakeButton(int n){\n  int i, x1, y1, x2, y2;\n  string str;\n  POINT p;\n  multimap<string, POINT> button;\n\n  for(i=0; i<n; ++i){\n    cin >> p.x1 >> p.y1 >> p.x2 >> p.y2 >> str;\n    button.insert(make_pair(str, p));\n  }\n  return button;\n}\n\nvoid Click(map< string, multimap<string, POINT> > webpage,\n\t   vector<string>& logdata, int& now, int w, int h){\n  int x, y;\n  cin >> x >> y;\n  if(x < 0 || w < x || y < 0 || h < y) return;\n\n  POINT p;\n  multimap<string, POINT> button;\n  multimap<string, POINT>::iterator i;\n  map< string, multimap<string, POINT> >::iterator j;\n\n  j = webpage.find(logdata[now]);\n  if(j == webpage.end()) return;\n  button = j->second;\n\n  for(i=button.begin(); i!=button.end(); ++i){\n    p = i->second;\n    if(p.x1 <= x && x <= p.x2 && p.y1 <= y && y <= p.y2){\n      ++now;\n      logdata.erase(logdata.begin()+now, logdata.end());\n      logdata.push_back(i->first);\n      return;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\n#include <map>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nconst int INF = 1<<29;\n\nstruct P {\n  int x1,y1,x2,y2;\n  string s;\n  P(int x1,int y1,int x2,int y2, string s) : x1(x1),y1(y1),x2(x2),y2(y2),s(s) {}\n};\n\nint main() {\n  int n;\n  while(cin>>n,n) {\n    int w,h;\n    cin >> w>>h;\n    string title[n];\n    vector<P> button[n];;\n    map<string, int> rid;\n    REP(i,n) {\n      cin >> title[i];\n      rid[title[i]] = i;\n      int m;\n      cin >> m;\n      REP(j,m) {\n        int ax,ay,bx,by;\n        cin>>ax>>ay>>bx>>by;\n        string s;\n        cin >> s;\n        button[i].push_back(P(ax,ay,bx,by,s));\n      }\n    }\n    int m;\n    cin >> m;\n    int now = 0;\n    int page[30] = {};\n    int maxpage = 0;\n    while(m--) {\n      string s;\n      cin >> s;\n      if (s == \"click\") {\n        int x, y;\n        cin >> x >> y;\n        FOR(it, button[now]) {\n          if (it->x1<=x && x<=it->x2 && it->y1<=y && y<=it->y2) {\n            page[++now] = rid[it->s];\n            maxpage = now;\n            break;\n          }\n        }\n      } else if (s == \"show\"){\n        cout << title[now] << endl;\n      } else if (s == \"back\") {\n        if (now>0)\n          now--;\n      } else if (s == \"forward\") {\n        if (now<maxpage)\n          now++;\n      }\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n\n#define x first\n#define y second\n\nusing pi = pair<int,int>;\nusing P = pair<pi,pi>;\n\nstruct Page{\n    string name;\n\n    int m;\n    vector<P> b;\n    vector<string> l;\n\n    Page(){};\n\n    void READ(){\n        cin >>name >>m;\n        b = vector<P>(m);\n        l = vector<string>(m);\n        rep(i,m){\n            cin >>b[i].fi.x >>b[i].fi.y >>b[i].se.x >>b[i].se.y;\n            cin >>l[i];\n        }\n    }\n\n    int click(int x, int y){\n        rep(i,m){\n            if(b[i].fi.x<=x && x<=b[i].se.x && b[i].fi.y<=y && y<=b[i].se.y) return i;\n        }\n        return -1;\n    }\n};\n\nint main(){\n    int n;\n    while(cin >>n,n){\n        int W,H;\n        cin >>W >>H;\n\n        vector<Page> p(n);\n        rep(i,n) p[i].READ();\n\n        map<string,int> name2id;\n        rep(i,n) name2id[p[i].name] = i;\n\n        int Q;\n        cin >>Q;\n\n        vector<int> a(Q+1,-1);\n        int idx = 0;\n        a[0] = 0;\n\n        rep(qq,Q){\n            string s;\n            cin >>s;\n            if(s == \"click\"){\n                int X,Y;\n                cin >>X >>Y;\n                int res = p[a[idx]].click(X,Y);\n                if(res != -1){\n                    for(int j=idx+1; j<Q+1; ++j) a[j] = -1;\n                    a[idx+1] = name2id[p[a[idx]].l[res]];\n                    ++idx;\n                }\n            }\n            else if(s == \"back\"){\n                if(idx>0) --idx;\n            }\n            else if(s == \"forward\"){\n                if(a[idx+1] != -1) ++idx;\n            }\n            else{\n                // show\n                cout << p[idx].name << \"\\n\";\n            }\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<algorithm>\n#include<iostream>\n#include<vector>\n#include<climits>\n#include<cfloat>\n\nusing namespace std;\n\nstruct point{\n  int x, y;\n};\n\nstruct button{\n  point ld,ru;\n  string name;\n};\n\nstruct page{\n  string name;\n  vector<button>btn;   \n}; \n\nint m,now;\nvector<page> a;\npage nowpage;\nstring buf[10001];\n\nvoid func(void){\n  for(int i=0;i<a.size();i++){\n    if(buf[now]==a[i].name){\n      nowpage=a[i];\n      return ;\n    }\n  }\n}\n\nvoid click(int c,int d){\n  \n  for(int i=0;i<nowpage.btn.size();i++){\n    if(nowpage.btn[i].ld.x <=c && nowpage.btn[i].ld.y <=d &&\n       nowpage.btn[i].ru.x >=c && nowpage.btn[i].ru.y >=d){\n      buf[++now]=nowpage.btn[i].name;\n      fill(buf+now+1,buf+10001,\"\");\n      return ;\n    }\n  }\n}\n\n\nint main(void){\n  int n;\n  int w,h,b;\n  point l,r;\n  page in;\n  button tmp;\n\n  while(cin >> n,n){\n  \n    a.clear();\n    fill(buf,buf+10001,\"\");\n\n    cin >> w >> h;\n    \n    for(int j=0;j<n;j++){\n      cin >> in.name >> b;    \n      \n      for(int i=0;i<b;i++){\n\tcin >> tmp.ld.x >> tmp.ld.y >> tmp.ru.x >> tmp.ru.y >> tmp.name;\n\tin.btn.push_back(tmp);\n      }\n      a.push_back(in);\n    }\n\n    now=0;\n    buf[0]=a[0].name;\n    nowpage=a[0];\n\n    cin >> m;\n\n    while(m--){\n      string s;\n      cin >> s;\n\n      func();\n\n      if(s==\"click\"){\n\tint c,d;\n\tcin >> c >> d;\n\tclick(c,d);\n      }\n      else if(s==\"back\" && now>0)now--;\n      else if(s==\"forward\" && buf[now+1]!=\"\")now++;\n      else if(s==\"show\")cout << buf[now] << endl;\n\n      func();\n    }\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstring>\nusing namespace std;\nstatic const double EPS = 1e-5;\ntypedef long long ll;\n\ntypedef struct _button{\n\tint xl,yu,xr,yl;\n\tstring name;\n}button;\n\n\nmap<string, vector<button> > page;\nvector<string> rireki;\n\n\nmain(){\n\tint n;\n\twhile(cin>>n){\n\t\tif(n==0)break;\n\t\t\n\t\tpage.clear();\n\t\trireki.clear();\n\t\t\n\t\tint W,H;\n\t\tcin>>W>>H;\n\t\t\n\t\tfor(int i=0;i<n;i++){\n\t\t\tstring name;\n\t\t\tint b;\n\t\t\tcin>>name>>b;\n\t\t\tif(i==0)rireki.push_back(name);\n\t\t\tfor(int j=0;j<b;j++){\n\t\t\t\tint xl,xr,yu,yl;\n\t\t\t\tstring tname;\n\t\t\t\tcin>>xl>>yu>>xr>>yl>>tname;\n\t\t\t\tbutton tbutton={xl,yu,xr,yl,tname};\n\t\t\t\t\n\t\t\t\tpage[name].push_back(tbutton);\n\t\t\t}\n\t\t}\n\t\t\n\t\tint m;\n\t\tcin>>m;\n\t\tint p=0;\n\t\t\n\t\tfor(int i=0;i<m;i++){\n\t\t\tstring com;\n\t\t\tcin>>com;\n\t\t\tif(com==\"click\"){\n\t\t\t\t\n\t\t\t\tint x,y;\n\t\t\t\tcin>>x>>y;\n\t\t\t\t\n\t\t\t\tstring target=\"\";\n\t\t\t\t\n\t\t\t\tfor(vector<button>::iterator vp=page[rireki[p]].begin();vp!=page[rireki[p]].end();++vp){\n\t\t\t\t\tif(vp->xr>=x && vp->xl<=x && vp->yu<=y && vp->yl>=y)target=vp->name;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(target==\"\")continue;\n\t\t\t\t\n\t\t\t\tif(p==rireki.size()-1){\n\t\t\t\t\trireki.push_back(target);\n\t\t\t\t\t++p;\n\t\t\t\t}else{\n\t\t\t\t\t++p;\n\t\t\t\t\trireki[p]=target;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}else if(com==\"show\"){\n\t\t\t\tcout<<rireki[p]<<endl;\n\t\t\t}else if(com==\"back\"){\n\t\t\t\t--p;\n\t\t\t}else if(com==\"forward\"){\n\t\t\t\t++p;\n\t\t\t}\n\t\t}\n\t\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "//ツ甘板暗。ツづ?づБOJツづ個づ卍つ、ツづ?津アツ出ツつオツつスツづ個づ?つキツつイツつュツつォツづ慊つクツつ「\n//2ツ嘉アツ暗δつ「ツ甘板暗。ツづ?つスツつッツづ?PPATSU\n\n\n#include<iostream>\n#include<map>\n#include<vector>\n#define F first\n#define S second\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<P,P> P2;\ntypedef pair<P2,string> info;\n\nint main(){\n  int n,m,H,W,num,x1,x2,y1,y2;\n  string s,s2,now;\n  while(cin >> n && n){\n    multimap<string,info> web;\n    cin >> W >> H;\n    for(int j=0;j<n;j++){\n      cin >> s >> num;\n      if(j == 0)now = s;\n      for(int i=0;i<num;i++){\n\tcin >> x1 >> y1 >> x2 >> y2 >> s2;\n\tweb.insert(multimap<string,info>::value_type(s,info(P2(P(x1,y1),P(x2,y2)),s2)));\n      }\n    }\n    cin >> m;\n    string op,Back,Forward;\n    string *history = new string[10005];//ツ配ツ療アツ妥・ツつォツつュツつオツつスツづァツ津環づ?つス\n  \n    int nx,ny,Index=0,len=0;\n    int pointer = 0;\n    //history[Index++] = now;\n    history[pointer]=now;\n\n    //cout << \"now is \" << now << endl;\n    Back.clear();\n    Forward.clear();\n    for(int i=0;i<m;i++){\n      cin >> op;\n      if(op == \"click\"){\n\tcin >> nx >> ny;\n\tfor(int i=pointer+1;i<=len;i++){\n\t  history[i].clear();\n\t}\n\n\tbool found = false;\n\tmultimap<string,info>::iterator it = web.begin();\t\n\twhile(it != web.end() ){\n\t  if((*it).first == now){\n\n\t    if((*it).S.F.F.F <=nx && nx <=(*it).S.F.S.F && (*it).S.F.F.S <=ny && ny <= (*it).S.F.S.S){\n\t      now = (*it).S.S;\n\t      //history[Index++] = now; \n\t      history[++pointer] = now;\n\t      len++;\n\t      break;\n\t    }\n\n\t  }\n\t  it++;\n\t}\n\t//cout << now << endl;\n\t//cout << \"--------------\" << endl;\n \n      }\n      else if(op == \"show\")cout << now << endl;\n      else if(op == \"back\"){\n\t//if(Index-1 >=0 ){\n\t  //Index--;\n\t  //now = history[Index-1];\n\t  // cout << \"back to \"<< now << endl;\n\tif(pointer-1 >=0){\n\t  now = history[--pointer];\n\t}\n      }\n      else if(op == \"forward\"){\n\t//if(Index+1 <= len){\n\t//now = history[Index];\n\t//Index++;\n\tif(!history[pointer+1].empty()){\n\t//if(pointer+1 < len){\n\t  now = history[++pointer];\n\t}\n      }\n\n\n    }\n    /*\n    cout << \"---------\"<< endl;\n    for(int i=0;i<=len;i++){\n      cout << history[i] << endl;\n    }\n    */\n    delete [] history;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <algorithm>\t// require sort next_permutation count etc.\n#include <cstdlib>\t// require abs\n#include <cstdio>\t// require printf\n#include <functional>\n#include <numeric>\t// require accumulate\n#include <cmath>\n#include <climits>\n#include <limits>\n#include <cfloat>\n#include <iomanip>\t// require setw\n#include <sstream>\t// require stringstream \n#include <cstring>\t// require memset\n#include <cctype>\t// require tolower, toupper\n#include <fstream>\t// require freopen\n\nusing namespace std;\n\ntypedef pair<int, int> P;\n\nstruct BUTTON{\n\tP start, end;\n\tstring link_name;\n};\t\n\nstruct PAGE{\n\tstring name;\n\tint link_num;\n\tvector <BUTTON> link;\n};\t\t\n\t\n\nint main()\n{\n\tconst string action[] = { \"click\", \"show\", \"back\", \"forward\" };\n//\tcut here before submit \n//\tfreopen (\"testcase.distortedlove\", \"r\", stdin );\n\tint n;\n\n\twhile (cin >> n && n ){\n\t\tint W, H;\n\t\tcin >> W >> H;\n\t\tvector<PAGE> page(n);\n\n\t\tfor (int i = 0; i < n; ++i ){\n\t\t\tint num = 0;\n\t\t\tcin >> page[i].name >> num;\n\t\t\tpage[i].link_num = num;\n\t\t\tpage[i].link.resize(num );\n\t\t\tfor (int j = 0; j < num; ++j ){\n\t\t\t\tcin >> page[i].link[j].start.first;\n\t\t\t\tcin >> page[i].link[j].start.second;\n\t\t\t\tcin >> page[i].link[j].end.first;\n\t\t\t\tcin >> page[i].link[j].end.second;\n\t\t\t\tcin >> page[i].link[j].link_name;\n\t\t\t} // end for\n\t\t} // end for\n\n\t\tvector <int> buffer (10500, -1 );\n\t\tint curr_page = 0;\t// ツ個サツ催敖づ個ペツーツジ\n\t\tint pointer = 0;\n\t\tbuffer[pointer] = curr_page;\n\t\tint m;\n\t\tcin >> m;\n\n\t\tfor (int i = 0; i < m; ++i ){\n\t\t\tstring com = \"\";\n\t\t\tcin >> com;\n\t\t\tint cw, ch;\n\t\t\tif (com == action[0] ){\t// \"click\"\n\t\t\t\tcin >> cw >> ch;\n\t\t\t\tint curr = buffer[pointer];\n\t\t\t\tstring next_page = \"\";\t\n\t\t\t\tfor (int j = 0; j < page[curr].link_num; ++j ){\n\t\t\t\t\tif ( page[curr].link[j].start.first <= cw \n\t\t\t\t\t&&   cw <= page[curr].link[j].end.first\n\t\t\t\t\t&&   page[curr].link[j].start.second <= ch \n\t\t\t\t\t&& ch <= page[curr].link[j].end.second ){\n\t\t\t\t\t\tnext_page = page[curr].link[j].link_name;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} // end if\n\t\t\t\t} // end for\n\t\t\t\tif (!next_page.empty() ){\n\t\t\t\t\tfor (int j = pointer + 1; j < buffer.size(); ++j ){\n\t\t\t\t\t\tbuffer[j] = -1;\n\t\t\t\t\t} // end for\n\t\t\t\t\tfor (int j = 0; j < n; ++j ){\n\t\t\t\t\t\tif (next_page == page[j].name ){\n\t\t\t\t\t\t\t++pointer;\n\t\t\t\t\t\t\tbuffer[pointer] = j;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t} // end fi\n\t\t\t\t\t} // end for\n\t\t\t\t} // end if\n\t\t\t}else\n\t\t\tif (com == action[1] ){\t// \"show\"\n\t\t\t\tcout << page[buffer[pointer]].name << endl;\n\t\t\t}else\n\t\t\tif (com == action[2] ){\t// \"back\"\n\t\t\t\tif (pointer > 0 ){\n\t\t\t\t\t--pointer;\n\t\t\t\t} // end if\n\t\t\t}else{\t\t\t\t// \"forward\"\n\t\t\t\tif (buffer[pointer+1] != -1 ){\n\t\t\t\t\t++pointer;\n\t\t\t\t} // end if\n\t\t\t} // end if\n\t\t} // end for\n\t} // end loop\n\t\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\nusing namespace std;\n\ntypedef istringstream ISS;\ntypedef ostringstream OSS;\ntypedef vector<string> VS;\ntypedef int INT;\ntypedef vector<INT> VI;\ntypedef vector<VI> VVI;\ntypedef pair <INT, INT> II;\ntypedef vector <II> VII;\n\ntemplate<class T> ostream& operator << ( ostream& os, vector<T> v ) {\n    for ( typename vector<T>::iterator it_i = v.begin(); it_i != v.end(); ++it_i ) {\n        os << *it_i << \", \";\n    }\n    return os;\n}\n\n\ntypedef map <string, int> NAME_TO_ID;\nconst int SIZE = 101;\nint n;\nint ww, wh;\nstring NAME[SIZE]; \nint K[SIZE];\nNAME_TO_ID NTI; \nint X1[SIZE][SIZE], Y1[SIZE][SIZE], X2[SIZE][SIZE], Y2[SIZE][SIZE];\nstring TO[SIZE][SIZE];\n\nint H[30000000];\nint cur;\nint upper;\n\nvoid init() {\n    NTI.clear();\n    H[0] = 0;\n    cur = 0;\n    upper = 1;\n}\n\nint click( int x, int y ) { \n    int cid = H[cur];\n    for ( int i = 0; i < K[cid]; ++ i ) {\n        if ( X1[cid][i] <= x && x <= X2[cid][i] ) {\n            if ( Y1[cid][i] <= y && y <= Y2[cid][i] ) {\n                return NTI[TO[cid][i]];\n            }\n        }\n    }\n    return -1;\n}\n\n\nvoid input() {\n    cin >> ww >> wh;\n    for ( int i = 0; i < n; ++ i ) { \n        cin >> NAME[i] >> K[i];\n        NTI[NAME[i]] = i;\n        for ( int j = 0; j < K[i]; ++ j ) {\n            cin >> X1[i][j] >> Y1[i][j];\n            cin >> X2[i][j] >> Y2[i][j];\n            cin >> TO[i][j];\n        }\n    }\n}\n\nvoid push( int id ) {\n    H[++cur] = id;\n    upper = cur + 1;\n}\n\nstring getCurrentName() {\n    int cid = H[cur];\n    return NAME[cid];\n}\n\n\nvoid back() {\n    if ( cur - 1 < 0 ) return;\n    cur --;\n}\n\nvoid forward() {\n    if ( cur + 1 >= upper ) return;\n    cur ++;\n}\n\nvoid solve() {\n    int m;\n    cin >> m;\n    for ( int i = 0; i < m; ++ i ) {\n        string cmd;\n        cin >> cmd;\n        if ( cmd == \"click\" ) {\n            int x, y;\n            cin >> x >> y;\n            int ret = click( x, y );\n            if ( ret == -1 ) continue;\n            push(ret);\n        } else if ( cmd == \"show\" ) {\n            cout << getCurrentName() << endl;\n        } else if ( cmd == \"back\" ) {\n            back();\n        } else if ( cmd == \"forward\" ) {\n            forward();\n        }\n    }\n}\n\nint main() {\n    while ( cin >> n && n ) {\n        init();\n        input();\n        solve();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*************************************************************************\nAuthor: ziki\nCreated Time: 2012-8-9 12:39:37\nFile Name: d.cpp\nDescription: \n************************************************************************/\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <string.h>\n\n\nusing namespace std;\n\ntypedef long long int64;\ntypedef unsigned long long uint64;\n#define two(X) (1<<(X))\n#define twoL(X) (((int64)(1))<<(X))\n#define contain(S,X) (((S)&two(X))!=0)\n#define containL(S,X) (((S)&twoL(X))!=0)\nconst double pi=acos(-1.0);\nconst double eps=1e-11;\nconst int inf=0x7FFFFFFF;\ntemplate<class T> inline void checkmin(T &a,T b){if(b<a) a=b;}\ntemplate<class T> inline void checkmax(T &a,T b){if(b>a) a=b;}\ntemplate<class T> inline T sqr(T x){return x*x;}\ntypedef pair<int,int> ipair;\n#define SIZE(A) ((int)A.size())\n#define LENGTH(A) ((int)A.length())\n#define MP(A,B) make_pair(A,B)\n#define PB(X) push_back(X)\n#define zero(a) memset(a, 0, sizeof(a))\n#define out(x) (cout<<#x<<\": \"<<x<<endl)\ntemplate<class T>void show(T a, int n){for(int i=0; i<n; ++i) cout<<a[i]<<' '; cout<<endl;}\ntemplate<class T>void show(T a, int r, int l){for(int i=0; i<r; ++i)show(a[i],l);cout<<endl;}\n\nstruct obj{\n\tint x1,x2,y1,y2;\n\tint idx;\n\tobj(int x1,int y1, int x2, int y2, int s):x1(x1),y1(y1),x2(x2),y2(y2), idx(s){}\n\tint inter(int x,int y) {\n\t\treturn x1<=x && x<=x2 && y>=y1 && y<=y2;\n\t}\n};\nstruct S{\n\tstring nm;\n\tvector<obj>e;\n\tvoid init(string s){\n\t\tnm = s;\n\t\te.clear();\n\t}\n}s[1000];\n\n\nint stk[1000],now,top;\nint main()\n{\n\tint n,m,w,h;\n\twhile(cin>>n&&n)\n\t{\n\t\tcin>>w>>h;\n\t\ttop = 0;\n\t\tmap<string,int> mp;\n\t\tint idx = 0;\n\t\tfor(int i=0; i<n; i++){\n\t\t\tint eec;\n\t\t\tint x1,x2,y1,y2,id,id2;\n\t\t\tstring nm;\n\t\t\tcin>>nm>>eec;\n\t\t\tif(mp.count(nm)) id = mp[nm];\n\t\t\telse id = mp[nm] = idx++;\n\t\t\ts[id].init(nm);\n\t\t\tfor(int j=0; j<eec; j++){\n\t\t\t\tcin>>x1>>y1>>x2>>y2>>nm;\n\t\t\t\tif(x1<0) x1 = 0;\n\t\t\t\tif(x1>w) x1 = w;\n\t\t\t\tif(x2<0) x2 = 0;\n\t\t\t\tif(x2>w) x2 = w;\n\t\t\t\tif(y1<0) y1 = 0;\n\t\t\t\tif(y1>h) y1 = h;\n\t\t\t\tif(y2<0) y2 = 0;\n\t\t\t\tif(y2>h) y2 = h;\n\t\t\t\tif(x1>x2)swap(x1,x2);\n\t\t\t\tif(y1>y2)swap(y1,y2);\n\t\t\t\tif(mp.count(nm)) id2 = mp[nm];\n\t\t\t\telse id2 = mp[nm] = idx++;\n\t\t\t\ts[id].e.PB(obj(x1,y1,x2,y2,id2));\n\t\t\t}\n\t\t}\n\t\tcin>>m;\n\t\tnow = top = 0;\n\t\tstk[0] = 0;\n\t\tint tx,ty, it = stk[now], to = -1;\n\t\tfor(int i=0; i<m; i++){\n\t\t\tit = stk[now], to = -1;\n\t\t\tstring cmd;\n\t\t\tcin>>cmd;\n\t\t\tif(cmd == \"click\"){\n\t\t\t\t\n\t\t\t\tcin>>tx>>ty;\n\t\t\t\tif(tx>=0 && tx<=w && ty>=0 && ty<=h)\n\t\t\t\tfor(int j=0; j<s[it].e.size(); j++){\n\t\t\t\t\tif(s[it].e[j].inter(tx,ty)){\n\t\t\t\t\t\tto = s[it].e[j].idx;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(to!=-1){\n\t\t\t\t\tstk[++now] = to;\n\t\t\t\t\ttop = now;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(cmd == \"show\"){\n\t\t\t\tcout<<s[it].nm<<endl;\n\t\t\t}\n\t\t\telse if(cmd == \"back\"){\n\t\t\t\tif(now>0) now--;\n\t\t\t}\n\t\t\telse if(cmd == \"forward\"){\n\t\t\t\tif(now<top) now++;\n\t\t\t}\n\t\t}\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\n\nint b[100], x1[100][100], Y1[100][100], x2[100][100], y2[100][100];\nstring link[100][100];\nmap<string, int>mp;\nint main() {\n\tint n;\n\twhile (scanf(\"%d\", &n), n) {\n\t\tmp.clear();\n\t\tint w, h; scanf(\"%d%d\", &w, &h);\n\t\tvector<string>v;\n\t\trep(i, n) {\n\t\t\tstring s; cin >> s >> b[i]; mp[s] = i;\n\t\t\tif (i == 0)v.push_back(s);\n\t\t\trep(j, b[i])cin >> x1[i][j] >> Y1[i][j] >> x2[i][j] >> y2[i][j] >> link[i][j];\n\t\t}\n\t\tint pos = 0;\n\t\tint m; scanf(\"%d\", &m);\n\t\tif (m > 1000)abort();\n\t\trep(i, m) {\n\t\t\tstring s; cin >> s;\n\t\t\tif (s == \"click\") {\n\t\t\t\tint x, y; cin >> x >> y;\n\t\t\t\tint a = mp[v.back()];\n\t\t\t\trep(i, b[a]) {\n\t\t\t\t\tif (x1[a][i] <= x&&x <= x2[a][i] && Y1[a][i] <= y&&y <= y2[a][i]) {\n\t\t\t\t\t\tif (pos + 1 < v.size())v.erase(v.begin() + pos + 1, v.end());\n\t\t\t\t\t\tv.push_back(link[a][i]); pos = v.size() - 1; break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (s == \"back\") {\n\t\t\t\tif (pos)pos--;\n\t\t\t}\n\t\t\tif (s == \"forward\") {\n\t\t\t\tif (pos < v.size() - 1)pos++;\n\t\t\t}\n\t\t\tif (s == \"show\")cout << v[pos] << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <iostream>\n#include <math.h>\n#include <assert.h>\n#include <vector>\n#include <string>\n#include <map>\n\nusing namespace std;\ntypedef long long ll;\nstatic const double EPS = 1e-9;\nstatic const double PI = acos(-1.0);\n\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define FOR(i, s, n) for (int i = (s); i < (int)(n); i++)\n#define FOREQ(i, s, n) for (int i = (s); i <= (int)(n); i++)\n#define FORIT(it, c) for (__typeof((c).begin())it = (c).begin(); it != (c).end(); it++)\n#define DEC(i, s) for (int i = (s); i >= 0; i--)\n\n#define SIZE(v) (int)((v).size())\n#define MEMSET(v, h) memset((v), h, sizeof(v))\n#define FIND(m, w) ((m).find(w) != (m).end())\n\n#include <complex>\n#include <vector>\n\ntypedef complex<double> Point;\ntypedef vector<Point> Polygon;\n\nstatic const double INF = 1e+10;\n\n#define CURR(P, i) (P[i])\n#define NEXT(P, i) (P[(i + 1) % P.size()])\n\nstruct Line : public vector<Point> {\n  Line() {;}\n  Line(Point a, Point b) { push_back(a); push_back(b); }\n};\n\nstruct Circle {\n  Point p;\n  double r;\n  Circle() {;}\n  Circle(Point p, double r) : p(p), r(r) {;}\n};\n\nnamespace std {\n  bool operator<(const Point &lhs, const Point &rhs) {\n    return lhs.real() == rhs.real() ? lhs.imag() < rhs.imag() : lhs.real() < rhs.real();\n  }\n}\n\ninline double cross(const Point &a, const Point &b) {\n  return imag(conj(a) * b);\n}\n\ninline double dot(const Point &a, const Point &b) {\n  return real(conj(a) * b);\n}\n\ninline int ccw(Point a, Point b, Point c) {\n  b -= a;\n  c -= a;\n  if (cross(b, c) > 0) { return 1; }\n  if (cross(b, c) < 0) { return -1; }\n  if (dot(b, c) < 0) { return 2; }\n  if (norm(b) < norm(c)) { return -2; }\n  return 0;\n}\n\n\nstruct Rectangle {\n  Point a, b;\n  string next;\n  Rectangle() {;}\n  Rectangle(Point a, Point b, string next) : a(a), b(b), next(next) {\n  }\n  bool in(Point p) {\n    return a.real() <= p.real() && p.real() <= b.real() &&\n           a.imag() <= p.imag() && p.imag() <= b.imag();\n  }\n};\n\nstruct Page {\n  string name;\n  vector<Rectangle> button;\n};\n\nint n;\nint w, h;\nPage page[1000];\nmap<string, int> mapfrom;\n\nint main() {\n  while (cin >> n, n) {\n    mapfrom.clear();\n    cin >> w >> h;\n    REP(i, n) {\n      int size;\n      cin >> page[i].name >> size;\n      mapfrom.insert(make_pair(page[i].name, i));\n      page[i].button.resize(size);\n      REP(j, size) {\n        int l, t, r, b;\n        string str;\n        cin >> l >> t >> r >> b >> str;\n        page[i].button[j] = Rectangle(Point(l, t), Point(r, b), str);\n      }\n    }\n    int m;\n    cin >> m;\n    vector<int> st;\n    st.push_back(0);\n    int head = 0;\n    REP(iter, m) {\n      int p = st[head];\n      string command;\n      cin >> command;\n      if (command == \"click\") {\n        int x, y;\n        cin >> x >> y;\n        REP(i, page[p].button.size()) {\n          if (page[p].button[i].in(Point(x, y))) {\n            head++;\n            st.resize(head);\n            st.push_back(mapfrom[page[p].button[i].next]);\n            break;\n          }\n        }\n      } else if (command == \"back\") {\n        head = max(0, head - 1);\n      } else if (command == \"forward\") {\n        head = min((int)st.size() - 1, head + 1);\n      } else {\n        cout << page[st[head]].name << endl;\n      }\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int, int> pii;\n\ntypedef struct button{\n  pii s, e;\n  string link;\n}button;\n\ntypedef struct window{\n  string name;\n  vector<button> b;\n}window;\n\nbool range(pii s, pii e, int w, int h){\n  return s.first <= w and w <= e.first and\n    s.second <= h and h <= e.second;\n}\n\nint main(){\n  int n, m, l, W, H;\n  while(std::cin >> n, n){\n    vector<window> vw(n);\n    map<string, int> next;\n    std::cin >> W >> H;\n    for (int i = 0; i < n; i++) {\n      std::cin >> vw[i].name >> l;\n      next[vw[i].name] = i;\n      for (int j = 0; j < l; j++) {\n        button tmp;\n        std::cin >> tmp.s.first >> tmp.s.second\n                 >> tmp.e.first >> tmp.e.second >> tmp.link;\n        vw[i].b.push_back(tmp);\n      }\n    }\n    std::cin >> m;\n    string s;\n    vector<string> buffer;\n    buffer.push_back(vw[0].name);\n    int pos = 0;\n    for (int i = 0; i < m; i++) {\n      std::cin >> s;\n      //std::cout << \"s = \" << s << std::endl;\n      if(s == \"click\"){\n        int w, h;\n        std::cin >> w >> h;\n        int win = next[buffer[pos]];\n        for (int j = 0; j < vw[win].b.size(); j++) {\n          if(range(vw[win].b[j].s, vw[win].b[j].e,\n                   w, h)){\n            if(pos + 1 < buffer.size())\n              buffer.erase(buffer.begin() + pos + 1, buffer.end());\n            buffer.push_back(vw[win].b[j].link);\n            pos++;\n          }\n        }\n      }else if(s == \"show\"){\n        std::cout << vw[pos].name << std::endl;\n      }else if(s == \"back\"){\n        pos = max(0, (int)(pos - 1));\n      }else if(s == \"forward\"){\n        pos = min((int)(buffer.size() - 1), pos + 1);\n      }\n    }\n  }\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<algorithm>\n#include<iostream>\n#include<vector>\n#include<climits>\n#include<cfloat>\n\nusing namespace std;\n\nstruct point{\n  int x, y;\n};\n\nstruct button{\n  point ld,ru;\n  string name;\n};\n\nstruct page{\n  string name;\n  vector<button>btn;   \n}; \n\nint m,now;\nvector<page> a;\npage nowpage;\nstring buf[10001];\n\nvoid click(int c,int d){\n  \n  for(int i=0;i<nowpage.btn.size();i++)\n    if(nowpage.btn[i].ld.x <=c && nowpage.btn[i].ld.y <=d &&\n       nowpage.btn[i].ru.x >=c && nowpage.btn[i].ru.y >=d)\n      for(int j=0;j<a.size();j++)\n\tif(nowpage.btn[i].name==a[j].name){\n\t  buf[++now]=a[j].name;\n\t  nowpage=a[j];\n\t  fill(buf+now+1,buf+10000,\"\");\n\t  return ;\n\t}\n    \n}\n\nint main(void){\n  int n;\n  int w,h,b;\n  point l,r;\n  page in;\n  button tmp;\n\n  while(cin >> n,n){\n  \n    a.clear();\n    fill(buf,buf+10000,\"\");\n\n    cin >> w >> h;\n    \n    for(int j=0;j<n;j++){\n      cin >> in.name >> b;    \n      \n      for(int i=0;i<b;i++){\n\tcin >> tmp.ld.x >> tmp.ld.y >> tmp.ru.x >> tmp.ru.y >> tmp.name;\n\tin.btn.push_back(tmp);\n      }\n      a.push_back(in);\n    }\n\n    now=0;\n    buf[0]=a[0].name;\n    nowpage=a[0];\n\n    cin >> m;\n\n    while(m--){\n      string s;\n      cin >> s;\n      if(s==\"click\"){\n\tint c,d;\n\tcin >> c >> d;\n\tclick(c,d);\n      }\n      else if(s==\"back\" && now>0)now--;\n      else if(s==\"forward\" && buf[now+1]!=\"\")now++;\n      else if(s==\"show\")cout << buf[now] << endl;\n    }\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<algorithm>\n#include<iostream>\n#include<vector>\n#include<climits>\n#include<cfloat>\n\nusing namespace std;\n\nstruct point{\n  int x, y;\n};\n\nstruct button{\n  point l,r;\n  string name;\n};\n\nstruct page{\n  string name;\n  vector<button>btn;   \n}; \n\nint m,now;\nvector<page> a;\npage nowpage;\nstring buf[10001];\n\nvoid func(void){\n  for(int i=0;i<a.size();i++){\n    if(buf[now]==a[i].name){\n      nowpage=a[i];\n      return ;\n    }\n  }\n}\n\nvoid click(int c,int d){\n  \n  for(int i=0;i<nowpage.btn.size();i++){\n    if(nowpage.btn[i].l.x <=c && c<=nowpage.btn[i].r.x &&\n       nowpage.btn[i].l.y <=d && d<=nowpage.btn[i].r.y ){\n      fill(buf+now+1,buf+10001,\"\");\n      buf[++now]=nowpage.btn[i].name;\n \n      return ;\n    }\n  }\n}\n\n\nint main(void){\n  int n;\n  int w,h,b;\n  point l,r;\n  page in;\n  button tmp;\n\n  while(cin >> n,n){\n  \n    a.clear();\n    fill(buf,buf+10001,\"\");\n\n    cin >> w >> h;\n    \n    for(int i=0;i<n;i++){\n      cin >> in.name >> b;    \n      if(i==0)buf[0]=in.name;\n\n      for(int j=0;j<b;j++){\n\tcin >> tmp.l.x >> tmp.l.y >> tmp.r.x >> tmp.r.y >> tmp.name;\n\tin.btn.push_back(tmp);\n      }\n      a.push_back(in);\n    }\n\n    now=0;\n\n    cin >> m;\n\n    while(m--){\n      string s;\n      cin >> s;\n\n      func();\n\n      if(s==\"click\"){\n\tint c,d;\n\tcin >> c >> d;\n\tclick(c,d);\n      }\n      else if(s==\"back\" && now>0)now--;\n      else if(s==\"forward\" && buf[now+1]!=\"\")now++;\n      else if(s==\"show\")cout << buf[now] << endl;\n\n    }\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <utility>\n#include <map>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nclass Nx{\n\tpublic:\n\tP p, q;\n\tstring name;\n\tNx() {}\n\tNx(string _name, P _p, P _q): name(_name), p(_p), q(_q) {}\n\t\n\tbool comp(int x, int y){\n\t\treturn (p.first <= x && x <= q.first && p.second <= y && y <= q.second);\n\t}\n};\n\nclass St{\n\tpublic:\n\tstring name;\n\tvector<Nx> vec;\n\tSt() {}\n\tSt(string _name): name(_name) {}\n\t\n\tstring check(int x, int y){\n\t\tstring str = \"\";\n\t\tfor(int i = 0; i < vec.size(); i++){\n\t\t\tif(vec[i].comp(x, y)){\n\t\t\t\tstr = vec[i].name;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn str;\n\t}\n};\n\nint main()\n{\n\tint n, m, w, h, s, t, u, v, a[10000];\n\tstring str;\n\t\n\twhile(cin>>n && n){\n\t\tvector<St> vec;\n\t\tmap<string,int> mpp;\n\t\tcin >> w >> h;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tcin >> str >> m;\n\t\t\tmpp[str] = i;\n\t\t\tvec.push_back(St(str));\n\t\t\twhile(m--){\n\t\t\t\tcin >> s >> t >> u >> v >> str;\n\t\t\t\tvec[i].vec.push_back(Nx(str, P(s, t), P(u, v)));\n\t\t\t}\n\t\t}\n\t\tcin >> n;\n\t\tt = 0;\n\t\tfill(a, a+1000, -1);\n\t\ta[0] = 0;\n\t\twhile(n--){\n\t\t\tcin >> str;\n\t\t\tif(str == \"click\"){\n\t\t\t\tcin >> u >> v;\n\t\t\t\tstring tmp = vec[t].check(u, v);\n\t\t\t\tif(tmp.size() > 0){\n\t\t\t\t\tt++;\n\t\t\t\t\tfill(a+t, a+1000, -1);\n\t\t\t\t\ta[t] = mpp[tmp];\n\t\t\t\t}\n\t\t\t} else if(str == \"show\"){\n\t\t\t\tcout << vec[a[t]].name << endl;\n\t\t\t} else if(str == \"back\"){\n\t\t\t\tif(t > 0){\n\t\t\t\t\tt--;\n\t\t\t\t}\n\t\t\t} else if(str == \"forward\"){\n\t\t\t\tif(a[t+1] != -1){\n\t\t\t\t\tt++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <map>\n#include <iostream>\n#define M make_pair\n#define F first\n#define S second\nusing namespace std;\ntypedef vector<pair<\n\tpair<\n\t\tpair<int,int>,\n\t\tpair<int,int>\n\t>,string\n> >links;\nmain(){\n\tint N,n,x,y,X,Y,cur;\n\tstring s,t;\n\tfor(;cin>>N>>x>>y;){\n\t\tmap<string,links>m;\n\t\tvector<string>visit;\n\t\tfor(cur=-1;N;N--){\n\t\t\tlinks v;\n\t\t\tfor(cin>>s>>n;n;n--)cin>>x>>y>>X>>Y>>t,v.push_back(M(M(M(x,X),M(y,Y)),t));\n\t\t\tif(m[s]=v,cur==-1)visit.push_back(s),cur=0;\n\t\t}\n\t\tfor(cin>>N;N;N--){\n\t\t\tif(cin>>s,s==\"show\")cout<<visit[cur]<<endl;\n\t\t\tif(s==\"back\"&&cur>0)cur--;\n\t\t\tif(s==\"forward\"&&cur<visit.size()-1)cur++;\n\t\t\tif(s==\"click\"){\n\t\t\t\tcin>>x>>y;\n\t\t\t\tlinks v=m[visit[cur]];\n\t\t\t\tfor(n=0;n<v.size();n++){\n\t\t\t\t\tif(v[n].F.F.F<=x&&x<=v[n].F.F.S && v[n].F.S.F<=y&&y<=v[n].F.S.S){\n\t\t\t\t\t\tfor(;cur<visit.size()-1;)visit.erase(visit.begin()+cur+1);\n\t\t\t\t\t\tvisit.push_back(v[n].S);cur++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <map>\n#include <sstream>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\nclass B{\npublic:\n  int x1, y1, x2, y2;\n  string to;\n  B(){}\n  B(int x1, int y1, int x2, int y2, string to) : x1(x1), y1(y1), x2(x2), y2(y2), to(to) {}\n};\n\nint n, h, w, b[100], m;\nvector<B> buttons[100];\nstring name[100];\nmap<string, int> stoi;\n\nint clicked(int x, int y, int p){\n  for(int i=0;i<b[p];i++){\n    B but = buttons[p][i];\n    if(but.x1 <= x && x <= but.x2 && but.y1 <= y && y <= but.y2) return stoi[but.to];\n  }\n  return -1;\n}\n\nmain(){\n  while(cin >> n && n){\n    stoi.clear();\n    for(int i=0;i<n;i++) buttons[i].clear();\n    cin >> w >> h;\n    for(int i=0;i<n;i++){\n      cin >> name[i];\n      cin >> b[i];\n      stoi[name[i]] = i;\n      for(int j=0;j<b[i];j++){\n        B in;\n        cin >> in.x1 >> in.y1 >> in.x2 >> in.y2 >> in.to;\n        buttons[i].push_back(in);\n      }\n    }\n    cin >> m;\n    int p = 0;\n    vector<int> buf;\n    buf.push_back(0);\n    for(int i=0;i<m;i++){\n      string str;\n      cin >> str;\n      if(str == \"forward\"){\n        if(p+1 < buf.size()) p++;\n      }else if(str == \"back\"){\n        if(p != 0) p--;\n      }else if(str == \"show\"){\n        cout << name[buf[p]] << endl;\n      }else{\n        int x, y;\n        cin >> x >> y;\n        int next = clicked(x, y, buf[p]);\n        if(next == -1) continue;\n        if(p+1 < buf.size()) buf.erase(buf.begin() + p+1, buf.end());\n        buf.push_back(next);\n        p++;\n      }\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\n\nint b[100], x1[100][100], Y1[100][100], x2[100][100], y2[100][100];\nstring link[100][100];\nmap<string, int>mp;\nint main() {\n\tint n;\n\twhile (scanf(\"%d\", &n), n) {\n\t\tint w, h; scanf(\"%d%d\", &w, &h);\n\t\tvector<string>v;\n\t\trep(i, n) {\n\t\t\tstring s; cin >> s >> b[i]; mp[s] = i;\n\t\t\tif (i == 0)v.push_back(s);\n\t\t\trep(j, b[i])cin >> x1[i][j] >> Y1[i][j] >> x2[i][j] >> y2[i][j] >> link[i][j];\n\t\t}\n\t\tint pos = 0;\n\t\tint m; scanf(\"%d\", &m);\n\t\trep(i, m) {\n\t\t\tstring s; cin >> s;\n\t\t\tif (s == \"click\") {\n\t\t\t\tint x, y; cin >> x >> y;\n\t\t\t\tint a = mp[v.back()];\n\t\t\t\trep(i, b[a]) {\n\t\t\t\t\tif (x1[a][i] <= x&&x <= x2[a][i] && Y1[a][i] <= y&&y <= y2[a][i]) {\n\t\t\t\t\t\tif (pos + 1 < v.size())v.erase(v.begin() + pos + 1, v.end());\n\t\t\t\t\t\tpos++; v.push_back(link[a][i]); break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (s == \"back\") {\n\t\t\t\tif (pos)pos--;\n\t\t\t}\n\t\t\tif (s == \"forward\") {\n\t\t\t\tif (pos < v.size() - 1)pos++;\n\t\t\t}\n\t\t\tif (s == \"show\")cout << v[pos] << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "/*\n * D.cpp\n *\n *  Created on: 2012-8-25\n *      Author: Administrator\n */\n#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<string>\n#include<algorithm>\n#include<map>\nusing namespace std;\nint n, m;\nint h, w;\nstruct page {\n\tstring name;\n\tint bn;\n\tint pt[105];\n\tint x1[105];\n\tint x2[105];\n\tint y1[105];\n\tint y2[105];\n} site[105];\nint buffer[10000];\nstring its[105];\nint bfend;\nint pointer;\n\nint main() {\n\twhile (cin >> n && n) {\n//\t\tmemset(site, 0, sizeof(site));\n\t\tmap<string, int> ma;\n\t\tcin >> h >> w;\n\t\tint cp = 1;\n\t\tstring name;\n\t\tint b;\n\t\twhile (n--) {\n\t\t\tcin >> name >> b;\n\t\t\tif (ma[name] == 0) {\n\t\t\t\tits[cp] = name;\n\t\t\t\tma[name] = cp++;\n\t\t\t}\n\t\t\tint currpage = ma[name];\n//\t\t\tcout << \"currpage \" << currpage << endl;\n\t\t\tsite[currpage].bn = b;\n//\t\t\tcout << \"b \" << b << endl;\n\t\t\tint x1, y1, x2, y2;\n\t\t\tstring pp;\n\t\t\tfor (int i = 0; i != b; i++) {\n\t\t\t\tcin >> x1 >> y1 >> x2 >> y2 >> pp;\n//\t\t\t\tcout<<x1<<\" \"<<y1<<\" \"<<x2<<\" \"<<y2<<\" \"<<pp<<endl;\n\t\t\t\tif (ma[pp] == 0) {\n\t\t\t\t\tits[cp] = pp;\n\t\t\t\t\tma[pp] = cp++;\n\t\t\t\t}\n\t\t\t\tint ipp = ma[pp];\n\t\t\t\tsite[currpage].x1[i] = x1;\n\t\t\t\tsite[currpage].x2[i] = x2;\n\t\t\t\tsite[currpage].y1[i] = y1;\n\t\t\t\tsite[currpage].y2[i] = y2;\n\t\t\t\tsite[currpage].pt[i] = ipp;\n\t\t\t}\n\t\t}\n\t\tpointer = 0;\n\t\tbfend = 0;\n\t\tbuffer[pointer] = 1;\n\t\tcin >> m;\n\t\tstring command;\n\t\twhile (m--) {\n//\t\t\tcout<<pointer<<endl;\n\t\t\tcin >> command;\n\t\t\tif (command == \"show\") {\n\t\t\t\tcout << its[buffer[pointer]] << endl;\n\t\t\t}\n\t\t\tif (command == \"forward\") {\n\t\t\t\tif (pointer < bfend)\n\t\t\t\t\tpointer++;\n\t\t\t}\n\t\t\tif (command == \"back\") {\n\t\t\t\tif (pointer > 0)\n\t\t\t\t\tpointer--;\n\t\t\t}\n\t\t\tif (command == \"click\") {\n\t\t\t\tint x, y;\n\t\t\t\tcin >> x >> y;\n\t\t\t\tint page = buffer[pointer];\n\t\t\t\tint nextpage;\n\t\t\t\tbool flag = false;\n\t\t\t\tfor (int i = 0; i != site[page].bn; i++) {\n\t\t\t\t\tint x1 = site[page].x1[i];\n\t\t\t\t\tint x2 = site[page].x2[i];\n\t\t\t\t\tint y1 = site[page].y1[i];\n\t\t\t\t\tint y2 = site[page].y2[i];\n\t\t\t\t\tif (x >= x1 && x <= x2 && y >= y1 && y <= y2) {\n\t\t\t\t\t\tnextpage = site[page].pt[i];\n\t\t\t\t\t\tflag = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (flag) {\n\t\t\t\t\tbfend = pointer + 1;\n\t\t\t\t\tpointer++;\n\t\t\t\t\tbuffer[pointer] = nextpage;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n#define MAX 500\n\nstruct Page{\n  int sx,sy,tx,ty;\n  string next;\n  Page(int sx,int sy,int tx,int ty,string next)\n    : sx(sx),sy(sy),tx(tx),ty(ty),next(next) {}\n};\n\nvector<Page> vec[MAX];\n\nvoid init(){\n  for(int i = 0 ; i < MAX ; i++){\n    vec[i].clear();\n  }\n}\n\nint main(){\n  int N,W,H,b,sx,sy,tx,ty,p = 0;\n  string str[MAX],s;\n\n  while(cin >> N,N){\n    cin >> W >> H;\n    init();\n    for(int i = 0 ; i < N ; i++){\n      cin >> str[i] >> b;\n      for(int j = 0 ; j < b ; j++){\n        cin >> sx >> sy >> tx >> ty >> s;\n        vec[i].push_back(Page(sx,sy,tx,ty,s));\n      }\n    }\n    int m,w,h,now = 0;\n    vector<int> now_page;\n    now_page.push_back(now);\n    string next;\n    cin >> m;\n    for(int I = 0 ; I < m ; I++){\n      int size = now_page.size();\n      if(p == size-1 && now_page[size-1] != now){\n        now_page.push_back(now);\n        p++;\n        size = now_page.size();\n      }\n      cin >> s;\n      if(s == \"click\"){\n        bool found = false;\n        cin >> w >> h;\n        for(int i = 0 ; i < (int)vec[now_page[p]].size() ; i++){\n          sx = vec[now][i].sx, sy = vec[now][i].sy;\n          tx = vec[now][i].tx, ty = vec[now][i].ty;\n          next = vec[now][i].next;\n          if(sx <= w && w <= tx && sy <= h && h <= ty){\n            for(int j = 0 ; j < N ; j++){\n              if(str[j] == next){\n                now = j;\n                found = true;\n                break;\n              }\n            }\n          }\n          if(found){\n            p++;\n            while(p < now_page.size()){\n              now_page.pop_back();\n            }\n            now_page.push_back(now);\n            break;\n          }\n        }\n      }else if(s == \"show\"){\n        cout << str[now_page[p]] << endl;\n      }else if(s == \"back\"){\n        if(p > 0) p--;\n      }else{\n        if(p+1 < size) p++;\n      }\n    }\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n \nusing namespace std;\n \n#define MAX 110\n \nstruct Page{\n    int sx,sy,tx,ty;\n    string next;\n    Page(int sx,int sy,int tx,int ty,string next)\n\t: sx(sx),sy(sy),tx(tx),ty(ty),next(next) {}\n};\n \nvector<Page> vec[MAX];\n \nvoid init(){\n    for(int i = 0 ; i < MAX ; i++){\n\tvec[i].clear();\n    }\n}\n \nint main(){\n    int N,W,H,b,sx,sy,tx,ty;\n    string str[MAX],s;\n \n    while(cin >> N,N){\n\tint p = 0;\n\tcin >> W >> H;\n\tinit();\n\tfor(int i = 0 ; i < N ; i++){\n\t    cin >> str[i] >> b;\n\t    for(int j = 0 ; j < b ; j++){\n\t\tcin >> sx >> sy >> tx >> ty >> s;\n\t\tvec[i].push_back(Page(sx,sy,tx,ty,s));\n\t    }\n\t}\n\tint m,w,h,now = 0;\n\tvector<int> now_page;\n\tnow_page.push_back(now);\n\tstring next;\n\tcin >> m;\n\tfor(int I = 0 ; I < m ; I++){\n\t    cin >> s;\n\t    if(s == \"click\"){\n\t\tbool found = false;\n\t\tcin >> w >> h;\n\t\tfor(int i = 0 ; i < vec[now_page[p]].size() ; i++){\n\t\t    sx = vec[now_page[p]][i].sx, sy = vec[now_page[p]][i].sy;\n\t\t    tx = vec[now_page[p]][i].tx, ty = vec[now_page[p]][i].ty;\n\t\t    next = vec[now_page[p]][i].next;\n\t\t    if(sx <= w && w <= tx && sy <= h && h <= ty){\n\t\t\tfor(int j = 0 ; j < N ; j++){\n\t\t\t    if(str[j] == next){\n\t\t\t\tnow = j;\n\t\t\t\tfound = true;\n\t\t\t\tbreak;\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t    if(found){\n\t\t\tp++;\n\t\t\twhile(p < now_page.size()){\n\t\t\t    now_page.pop_back();\n\t\t\t}\n\t\t\tnow_page.push_back(now);\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t    }else if(s == \"show\"){\n\t\tcout << str[now_page[p]] << endl;\n\t    }else if(s == \"back\"){\n\t\tif(p > 0) p--;\n\t    }else{\n\t\tif(p+1 < now_page.size()) p++;\n\t    }\n\t}\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 100000000\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P> PP;\n\nstatic const double EPS = 1e-8;\n\nconst int tx[] = {0,1,0,-1};\nconst int ty[] = {-1,0,1,0};\n\nclass Button{\npublic:\n\tint lu_x,lu_y,rl_x,rl_y;\n\tstring name;\n\tButton() : lu_x(0),lu_y(0),rl_x(0),rl_y(0),name(\"\"){}\n\tButton(int lu_x,int lu_y,int rl_x,int rl_y,string name): lu_x(lu_x),lu_y(lu_y),rl_x(rl_x),rl_y(rl_y),name(name){}\n};\n\nint main(){\n\tint n;\n\tint W,H;\n\tmap<string,vector<Button> > page;\n\tvector<string> browsed;\n\twhile(~scanf(\"%d\",&n)){\n\t\tif(n==0) break;\n\t\tscanf(\"%d %d\",&W,&H);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tstring name;\n\t\t\tint num;\n\t\t\tcin >> name >> num;\n\t\t\tfor(int j=0;j<num;j++){\n\t\t\t\tstring next;\n\t\t\t\tint lu_x,lu_y,rl_x,rl_y;\n\t\t\t\tcin >> lu_x >> lu_y >> rl_x >> rl_y >> next;\n\t\t\t\tpage[name].push_back(Button(lu_x,lu_y,rl_x,rl_y,next));\n\t\t\t\tif(browsed.size()==0) browsed.push_back(name);\n\t\t\t}\n\t\t}\n\n\t\tint m;\n\t\tint pos = 0;\n\t\tscanf(\"%d\",&m);\n\t\tfor(int i=0;i<m;i++){\n\t\t\tstring act;\n\t\t\tcin >> act;\n\t\t\tif(act==\"click\"){\n\t\t\t\tint x,y;\n\t\t\t\tcin >> x >> y;\n\t\t\t\tstring now = browsed[pos];\n\t\t\t\tfor(int i=0;i<page[now].size();i++){\n\t\t\t\t\tif(!(x < page[now][i].lu_x || page[now][i].rl_x < x\n\t\t\t\t\t\t|| y > page[now][i].rl_y || page[now][i].lu_y > y)){\n\t\t\t\t\t\t\t//printf(\"to %s\\n\",page[now][i].name.c_str());\n\n\t\t\t\t\t\t\tbrowsed.erase(browsed.begin()+pos+1,browsed.end());\n\t\t\t\t\t\t\tbrowsed.push_back(page[now][i].name);\n\t\t\t\t\t\t\tpos++;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(act==\"back\"){\n\t\t\t\t\n\t\t\t\tif(pos>0){\n\t\t\t\t\tpos--;\n\t\t\t\t\t//printf(\"back\\n\");\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(act==\"forward\"){\n\t\t\t\tif(pos<browsed.size()-1){\n\t\t\t\t\tpos++;\n\t\t\t\t\t//printf(\"forwardk\\n\");\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(act==\"show\"){\n\t\t\t\tcout << browsed[pos] << \"\\n\";\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<algorithm>\n#include<iostream>\n#include<vector>\n#include<climits>\n#include<cfloat>\n\nusing namespace std;\n\ndouble EPS = 1e-10;\n\ndouble add(double a, double b){\n  if(abs(a+b) < EPS * (abs(a)+abs(b)))return 0;\n  return a+b;\n}\n\nstruct point{\n  double x, y;\n  point(){}\n  point(double x,double y) : x(x) , y(y){}\n\n  point operator + (point p){\n    return point(add(x,p.x), add(y,p.y));\n  }\n\n  point operator - (point p){\n    return point(add(x,-p.x), add(y,-p.y));\n  }\n\n  point operator * (double d){\n    return point(x*d,y*d);\n  }\n\n  point operator / (double d){\n    return point(x/d,y/d);\n  }\n  \n  bool operator == ( const point &p ) const {\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n};\n\nstruct button{\n  point ld,ru;\n  string name;\n};\n\nstruct page{\n  string name;\n  vector<button>btn;   \n}; \n\nint tail;\npage stk[10000000];\n\nvoid push(page a){\n  stk[tail++]=a;\n}\n\npage pop(void){\n  tail--;\n  return stk[tail+1];\n}\n\nint main(void){\n  int n;\n  int w,h,b;\n  point l,r;\n  page in;\n  vector<page> a;\n  button tmp;\n\n  while(cin >> n,n){\n  \n    a.clear();\n\n    cin >> w >> h;\n    \n    for(int j=0;j<n;j++){\n      cin >> in.name >> b;    \n      \n      for(int i=0;i<b;i++){\n\tcin >> tmp.ld.x >> tmp.ld.y >> tmp.ru.x >> tmp.ru.y >> tmp.name;\n\tin.btn.push_back(tmp);\n      }\n      a.push_back(in);\n    }\n\n    int m,now=0;\n\n    cin >> m;\n    tail=0;\n    int fg=0;\n    push(a[0]);\n    while(m--){\n      string s;\n      cin >> s;\n      if(s==\"click\"){\n\tint c,d;\n\tcin >> c >> d;\n\t\n\tfor(int i=0;i<stk[tail-1].btn.size();i++){\n\t  int fg2=0;\n\t  if(stk[tail-1].btn[i].ld.x <=c &&\n\t     stk[tail-1].btn[i].ld.y <=d &&\n\t     stk[tail-1].btn[i].ru.x >=c &&\n\t     stk[tail-1].btn[i].ru.y >=d){\n\t    for(int j=0;j<a.size();j++){\n\t      if(stk[tail-1].btn[i].name==a[j].name){\n\t\tpush(a[j]);\n\t\tfg=0;\n\t\tfg2=1;\n\t\tbreak;\n\t      }\n\t    }\n\t    if(fg2)break;\n\t  }\n\t}\n      }\n      else if(s==\"back\" && tail>0){\n\ttail--;\n\tfg++;\n      }\n      else if(s==\"forward\" && fg--)tail++;\n      else if(s==\"show\")cout << stk[tail-1].name << endl;\n    }\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\nconst int MAX = 10001;\n\nstring data[MAX];\nint W,H,N;\n\nstruct Button{\n  int lx,rx,ly,ry;\n  string name;\n};\n\nmap<string,vector<Button> > M;\n\n\nvoid init(){\n  M.clear();\n  fill(data,data+MAX,\"\");\n}\n\nvoid input(){\n  cin >> W >> H;\n  for(int i = 0; i < N; i++){\n    string s;\n    int num;\n    cin >> s >> num;\n    if(i == 0) data[0] = s;\n\n    for(int j = 0; j < num; j++){\n      Button B;\n      cin >> B.lx >> B.ly >> B.rx >> B.ry >> B.name;\n      M[s].push_back(B);\t\n    }\n\n  }\n}\n\nvoid solve(){\n  int num;\n  cin >> num;\n  int index = 0;\n\n\n  while(num--){\n    string op;\n    cin >> op;\n    if(op == \"click\"){\n      int x,y;\n      cin >> x >> y;\n      string now = data[index];\n\n      for(int i = 0; i < M[now].size(); i++){\n\tif(M[now][i].lx <= x && x <= M[now][i].rx && M[now][i].ly <= y && y <= M[now][i].ry){\n\t  data[++index] = M[now][i].name;\n\t  fill(data+index+1,data+MAX,\"\");\n\t  break;\n\t}\n\n      }\n\n    }else if(op == \"back\" && index > 0) index--;\n    else if(op == \"forward\" && data[index+1] != \"\") index++;\n    else if(op == \"show\") cout << data[index] << endl;\n  }\n}\n\nint main(){\n\n  while(cin >> N && N){\n    input();\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<cassert>\n#include<iostream>\n#include<sstream>\n#include<string>\n#include<vector>\n#include<queue>\n#include<set>\n#include<map>\n#include<utility>\n#include<numeric>\n#include<algorithm>\n#include<bitset>\n#include<complex>\n\nusing namespace std;\n\ntypedef long long Int;\ntypedef vector<int> vint;\ntypedef pair<int,int> pint;\n#define mp make_pair\n\ntemplate<class T> void pv(T a, T b) { for (T i = a; i != b; ++i) cout << *i << \" \"; cout << endl; }\ntemplate<class T> void chmin(T &t, T f) { if (t > f) t = f; }\ntemplate<class T> void chmax(T &t, T f) { if (t < f) t = f; }\nint in() { int x; scanf(\"%d\", &x); return x; }\n\nstruct page{\n\tstring name,button[100];\n\tint b,x1[100],x2[100],y1[100],y2[100];\n};\n\npage pages[100];\nint buf[1000];\n\nint main() {\n\tint n;\n\twhile(n=in()){\n\t\tint w,h;\n\t\tcin>>w>>h;\n\t\tint i,j;\n\t\tfor(i=0;i<n;i++){\n\t\t\tcin>>pages[i].name>>pages[i].b;\n\t\t\tfor(j=0;j<pages[i].b;j++){\n\t\t\t\tcin>>pages[i].x1[j];\n\t\t\t\tcin>>pages[i].y1[j];\n\t\t\t\tcin>>pages[i].x2[j];\n\t\t\t\tcin>>pages[i].y2[j];\n\t\t\t\tcin>>pages[i].button[j];\n\t\t\t}\n\t\t}\n\t\tbuf[0]=0;\n\t\tint now=0;\n\t\tint size=1;\n\t\tint m=in();\n\t\ti=0;\n\t\tstring ope;\n\t\tint x,y;\n\t\tfor(j=0;j<m;j++){\n\t\t\tcin>>ope;\n\t\t\tif(ope==\"click\"){\n\t\t\t\tcin>>x>>y;\n\t\t\t\tint k;\n\t\t\t\tfor(k=0;k<pages[i].b;k++){\n\t\t\t\t\tif(pages[i].x1[k]<=x&&x<=pages[i].x2[k]&&pages[i].y1[k]<=y&&y<=pages[i].y2[k]){\n\t\t\t\t\t\tstring next=pages[i].button[k];\n\t\t\t\t\t\tint p;\n\t\t\t\t\t\tfor(p=0;p<n;p++){\n\t\t\t\t\t\t\tif(pages[p].name==next)i=p;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnow++;\n\t\t\t\t\t\tbuf[now]=i;\n\t\t\t\t\t\tsize=now;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}else if(ope==\"back\"){\n\t\t\t\tif(now>0)now--;\n\t\t\t\ti=buf[now];\n\t\t\t}else if(ope==\"forward\"){\n\t\t\t\tif(now<size)now++;\n\t\t\t\ti=buf[now];\n\t\t\t}else if(ope==\"show\"){\n\t\t\t\tcout<<pages[i].name<<endl;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <string>\n#include <vector>\n#include <iostream>\nusing namespace std;\nint N, W, H, Q, x, y, c[109], xa[109][109], ya[109][109], xb[109][109], yb[109][109]; string s[109], t[109][109], tp;\nint main() {\n\twhile (cin >> N, N) {\n\t\tcin >> W >> H;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tcin >> s[i] >> c[i];\n\t\t\tfor (int j = 0; j < c[i]; j++) {\n\t\t\t\tcin >> xa[i][j] >> ya[i][j] >> xb[i][j] >> yb[i][j] >> t[i][j];\n\t\t\t}\n\t\t}\n\t\tcin >> Q;\n\t\tvector<int> res; res.push_back(0);\n\t\tint pos = 0;\n\t\tfor (int i = 0; i < Q; i++) {\n\t\t\tcin >> tp;\n\t\t\tif (tp == \"click\") {\n\t\t\t\tcin >> x >> y;\n\t\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\t\tif (xa[res[pos]][j] <= x && x <= xb[res[pos]][j] && ya[res[pos]][j] <= y && y <= yb[res[pos]][j]) {\n\t\t\t\t\t\tres.resize(++pos);\n\t\t\t\t\t\tint ptr = -1;\n\t\t\t\t\t\tfor (int k = 0; k < N; k++) {\n\t\t\t\t\t\t\tif (s[k] == t[res[pos - 1]][j]) ptr = k;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tres.push_back(ptr);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (tp == \"show\") cout << s[res[pos]] << endl;\n\t\t\tif (tp == \"forward\" && pos + 1 != res.size()) pos++;\n\t\t\tif (tp == \"back\" && pos != 0) pos--;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\nusing namespace std;\n\ntypedef struct\n{\n  string name;\n  int x1, x2, y1, y2;\n} Button;\n\nint main()\n{\n  int n;\n  while (cin >> n) {\n    if (n == 0)\n      break;\n\n    int W, H;\n    cin >> W >> H;\n\n    vector<string > buf;\n    map<string, vector<Button> > button;\n    for (int i = 0; i < n; ++i) {\n      string name;\n      int b;\n      cin >> name >> b;\n      for (int j = 0; j < b; ++j) {\n\tButton tmp;\n\tcin >> tmp.x1 >> tmp.y1 >> tmp.x2 >> tmp.y2 >> tmp.name;\n\tbutton[name].push_back(tmp);\n      }\n\n      if (i == 0)\n\tbuf.push_back(name);\n    }\n\n    int m, p = 0;\n    cin >> m;\n    while (m--) {\n      string cmd;\n      cin >> cmd;\n\n      if (cmd == \"click\") {\n\tint x, y;\n\tcin >> x >> y;\n\tconst vector<Button>& link = button[buf[p]];\n\tfor (int i = 0; i < link.size(); ++i) {\n\t  if (link[i].x1 <= x && x <= link[i].x2 &&\n\t      link[i].y1 <= y && y <= link[i].y2) {\n\t    buf.erase(buf.begin()+p+1, buf.end());\n\t    buf.push_back(link[i].name);\n\t    ++p;\n\t    break;\n\t  }\n\t}\n      } else if (cmd == \"show\") {\n\tcout << buf[p] << endl;\n      } else if (cmd == \"back\") {\n\tif (p != 0)\n\t  --p;\n      } else {\n\tif (p+1 < buf.size())\n\t  ++p;\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <map>\n#include <vector>\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<P,P> PP;\n\nclass page{\npublic:\n  PP p;\n  int n;\n  page(PP p=PP(P(0,0),P(0,0)), int n=0):p(p),n(n){}\n};\n\nint main(){\n  int n;\n  while(cin >> n && n){\n    map<string,int> m;\n    map<int,string> m2;\n    int h,w,aa=0;\n    vector<page> v[100];\n    cin >> h >> w;\n    for(int i=0;i<n;i++){\n      string str;\n      int a;\n      cin >> str >> a;\n      if(m.find(str) == m.end()){\n        m[str] = aa;\n        m2[aa++] = str;\n      }\n      for(int j=0;j<a;j++){\n        PP p;\n        cin >> p.first.first >> p.first.second >> p.second.first >> p.second.second >> str;\n        if(m.find(str) == m.end()){\n          m[str] = aa;\n          m2[aa++] = str;\n        }\n        v[i].push_back(page(p,m[str]));\n      }\n    }\n\n    int n2, curr=0;\n    vector<int> v2;\n    v2.push_back(0);\n    cin >> n2;\n    for(int i=0;i<n2;i++){\n      string str;\n      cin >> str;\n      if(str == \"click\"){\n        int x,y;\n        cin >> x >> y;\n        int now = v2[curr];\n        for(int j=0;j<v[now].size();j++){\n          if(v[now][j].p.first.first <= x && x <= v[now][j].p.second.first && v[now][j].p.first.second <= y && y <= v[now][j].p.second.second){\n            curr++;\n            while(curr < v2.size()) v2.pop_back();\n            v2.push_back(v[now][j].n);\n            break;\n          }\n        }\n      } else if(str == \"back\") curr = (curr <= 0) ? curr : curr-1;\n      else if(str == \"forward\") curr = (curr >= v2.size()-1) ? curr : curr+1;\n      else cout << m2[v2[curr]] << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<algorithm>\n#include<iostream>\n#include<vector>\n#include<climits>\n#include<cfloat>\n\nusing namespace std;\n\nstruct point{\n  int x, y;\n};\n\nstruct button{\n  point ld,ru;\n  string name;\n};\n\nstruct page{\n  string name;\n  vector<button>btn;   \n}; \n\nint m,now,fg;\nvector<page> a;\nstatic page buf[1000000];\n\nvoid click(int c,int d){\n  \n  for(int i=0;i<buf[now].btn.size();i++)\n    if(buf[now].btn[i].ld.x <=c && buf[now].btn[i].ld.y <=d &&\n       buf[now].btn[i].ru.x >=c && buf[now].btn[i].ru.y >=d)\n      for(int j=0;j<a.size();j++)\n\tif(buf[now].btn[i].name==a[j].name){\n\t  buf[++now]=a[j];\n\t  fg=0;\n\t  return ;\n\t}\n}\n\nint main(void){\n  int n;\n  int w,h,b;\n  point l,r;\n  page in;\n  button tmp;\n\n  while(cin >> n,n){\n  \n    a.clear();\n\n    cin >> w >> h;\n    \n    for(int j=0;j<n;j++){\n      cin >> in.name >> b;    \n      \n      for(int i=0;i<b;i++){\n\tcin >> tmp.ld.x >> tmp.ld.y >> tmp.ru.x >> tmp.ru.y >> tmp.name;\n\tin.btn.push_back(tmp);\n      }\n      a.push_back(in);\n    }\n\n    now=0,fg=0;\n    buf[0]=a[0];\n\n    cin >> m;\n\n    while(m--){\n      string s;\n      cin >> s;\n      if(s==\"click\"){\n\tint c,d;\n\tcin >> c >> d;\n\tclick(c,d);\n      }\n      else if(s==\"back\" && now>0)now--,fg++;\n      else if(s==\"forward\" && fg>0 && now < 1000000)now++,fg--;\n      else if(s==\"show\")cout << buf[now].name << endl;\n    }\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <bitset>\n \n#define rep(i, n) for(int i = 0; i < (n); i++)\n#define FOR(i, a, b) for(int i = (a); i < (b); i++)\n#define all(v) (v).begin(), (v).end()\n#define rev(s) (s).rbegin(), (s).rend()\n#define MP make_pair\n#define X first\n#define Y second\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef vector<int> vi;\n\nvoid fin(){\n\tfreopen(\"test.txt\", \"r\", stdin);\n}\n\nstruct button{\n\tint left, top, right, bottom;\n\tstring link;\n\tbutton(int l, int t, int r, int b, string li){\n\t\tleft = l, top = t, right = r, bottom = b, link = li;\n\t}\n};\n\nint main(){\n\t//fin();\n\tint n;\n\twhile(cin >> n, n){\n\t\tint w, h;\n\t\tcin >> w >> h;\n\t\tmap<string, vector<button> > pages;\n\t\tstring current;\n\t\trep(i, n){\n\t\t\tstring s;\n\t\t\tint bn;\n\t\t\tcin >> s >> bn;\n\t\t\tif(!i) current = s;\n\t\t\trep(i, bn){\n\t\t\t\tint left, top, right, bottom;\n\t\t\t\tstring link;\n\t\t\t\tcin >> left >> top >> right >> bottom >> link;\n\t\t\t\tpages[s].push_back(button(left, top, right, bottom, link));\n\t\t\t}\n\t\t}\n\t\tstack<string> back;\n\t\tstack<string> forward;\n\t\tint m;\n\t\tcin >> m;\n\t\trep(i, m){\n\t\t\tstring com;\n\t\t\tcin >> com;\n\t\t\tif(com == \"click\"){\n\t\t\t\tint x, y;\n\t\t\t\tcin >> x >> y;\n\t\t\t\trep(i, pages[current].size()){\n\t\t\t\t\tbutton b = pages[current][i];\n\t\t\t\t\tif(x < b.left || x > b.right || y < b.top || y > b.bottom) continue;\n\t\t\t\t\tback.push(current);\n\t\t\t\t\tforward = stack<string>();\n\t\t\t\t\tcurrent = b.link;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(com == \"back\"){\n\t\t\t\tif(back.empty())continue;\n\t\t\t\tforward.push(current);\n\t\t\t\tcurrent = back.top();\n\t\t\t\tback.pop();\n\t\t\t}\n\t\t\telse if(com == \"forward\"){\n\t\t\t\tif(forward.empty())continue;\n\t\t\t\tback.push(current);\n\t\t\t\tcurrent = forward.top();\n\t\t\t\tforward.pop();\n\t\t\t}\n\t\t\telse if(com == \"show\"){\n\t\t\t\tcout << current << endl;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<algorithm>\n#include<iostream>\n#include<vector>\n#include<climits>\n#include<cfloat>\n\nusing namespace std;\n\nstruct point{\n  int x, y;\n};\n\nstruct button{\n  point ld,ru;\n  string name;\n};\n\nstruct page{\n  string name;\n  vector<button>btn;   \n}; \n\nint m,now;\nvector<page> a;\npage nowpage;\nstring buf[10001];\n\nvoid click(int c,int d){\n  \n  for(int i=0;i<nowpage.btn.size();i++)\n    if(nowpage.btn[i].ld.x <=c && nowpage.btn[i].ld.y <=d &&\n       nowpage.btn[i].ru.x >=c && nowpage.btn[i].ru.y >=d)\n      for(int j=0;j<a.size();j++)\n\tif(nowpage.btn[i].name==a[j].name){\n\t  buf[++now]=a[j].name;\n\t  nowpage=a[j];\n\t  fill(buf+now+1,buf+10000,\"\");\n\t  return ;\n\t}\n    \n}\n\nvoid func(void){\n  for(int i=0;i<a.size();i++){\n    if(buf[now]==a[i].name){\n      nowpage=a[i];\n      return ;\n    }\n  }\n}\n\nint main(void){\n  int n;\n  int w,h,b;\n  point l,r;\n  page in;\n  button tmp;\n\n  while(cin >> n,n){\n  \n    a.clear();\n    fill(buf,buf+10000,\"\");\n\n    cin >> w >> h;\n    \n    for(int j=0;j<n;j++){\n      cin >> in.name >> b;    \n      \n      for(int i=0;i<b;i++){\n\tcin >> tmp.ld.x >> tmp.ld.y >> tmp.ru.x >> tmp.ru.y >> tmp.name;\n\tin.btn.push_back(tmp);\n      }\n      a.push_back(in);\n    }\n\n    now=0;\n    buf[0]=a[0].name;\n    nowpage=a[0];\n\n    cin >> m;\n\n    while(m--){\n      string s;\n      cin >> s;\n      if(s==\"click\"){\n\tint c,d;\n\tcin >> c >> d;\n\tclick(c,d);\n      }\n      else if(s==\"back\" && now>0)now--,func();\n      else if(s==\"forward\" && buf[now+1]!=\"\")now++,func();\n      else if(s==\"show\")cout << buf[now] << endl;\n    }\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <map>\nusing namespace std;\n\nstruct pageinfo{\n\tstring nextpage;\n\tint x1,x2,y1,y2;\n\tbool inside(int x, int y){\n\t\treturn (x1<=x && x<=x2 && y1<=y && y<=y2);\n\t}\n};\nstruct pages{\n\tvector<struct pageinfo> v_pages;\n\tstring click(int x, int y){\n\t\tfor(int i=0; i<v_pages.size(); i++){\n\t\t\tif( v_pages[i].inside(x,y) )return v_pages[i].nextpage;\n\t\t}\n\t\treturn \"\";\n\t}\n};\n\nint main()\n{\n\tint W,H,n;\n\twhile(cin>>n,n){\n\t\tmap<string,struct pages> mp;\n\t\tvector<string> buf;\n\t\tcin >> W >> H;\n\t\tfor(int i=0; i<n; i++){\n\t\t\tstring name;\n\t\t\tstruct pages ps;\n\t\t\tint k;\n\t\t\tcin >> name >> k;\n\t\t\tif( i==0 )buf.push_back( name );\n\t\t\tfor(int j=0; j<k; j++){\n\t\t\t\tstruct pageinfo p;\n\t\t\t\tcin >> p.x1 >> p.y1 >> p.x2 >> p.y2 >> p.nextpage;\n\t\t\t\tps.v_pages.push_back( p );\n\t\t\t}\n\t\t\tmp[name] = ps;\n\t\t}\n\t\t\n\t\tint pos = 0;\n\t\tint m;\n\t\tcin>>m;\n\t\tcin.ignore();\n\t\twhile(m--){\n\t\t\tstring inp;\n\t\t\tgetline(cin,inp);\n\t\t\t//printf(\"pos:%d\\n\",pos);\n\t\t\tif( inp==\"show\" ){\n\t\t\t\tcout << buf[pos] << endl;\n\t\t\t}else if( inp==\"back\" ){\n\t\t\t\tif( pos-1 >= 0 )pos--;\n\t\t\t}else if( inp==\"forward\" ){\n\t\t\t\tif( pos+1 <  buf.size() )pos++;\n\t\t\t}else{\n\t\t\t\tchar c[8];\n\t\t\t\tint x,y;\n\t\t\t\tstring ne;\n\t\t\t\tsscanf(inp.c_str(),\"%s %d %d\",c,&x,&y);\n\t\t\t\tne = mp[buf[pos]].click(x,y);\n\t\t\t\tif( ne!=\"\" ){\n\t\t\t\t\tbuf.resize( pos+1 );\n\t\t\t\t\tbuf.push_back( ne );\n\t\t\t\t\tpos++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\n\nint b[100], x1[100][100], Y1[100][100], x2[100][100], y2[100][100];\nstring link[100][100];\nmap<string, int>mp;\nint main() {\n\tint n;\n\twhile (scanf(\"%d\", &n), n) {\n\t\tmp.clear();\n\t\tint w, h; scanf(\"%d%d\", &w, &h);\n\t\tvector<string>v;\n\t\trep(i, n) {\n\t\t\tstring s; cin >> s >> b[i]; mp[s] = i;\n\t\t\tif (i == 0)v.push_back(s);\n\t\t\trep(j, b[i])cin >> x1[i][j] >> Y1[i][j] >> x2[i][j] >> y2[i][j] >> link[i][j];\n\t\t}\n\t\tint pos = 0;\n\t\tint m; scanf(\"%d\", &m);\n\t\trep(i, m) {\n\t\t\tstring s; cin >> s;\n\t\t\tif (s == \"click\") {\n\t\t\t\tint x, y; cin >> x >> y;\n\t\t\t\tint a = mp[v[pos]];\n\t\t\t\trep(i, b[a]) {\n\t\t\t\t\tif (x1[a][i] <= x&&x <= x2[a][i] && Y1[a][i] <= y&&y <= y2[a][i]) {\n\t\t\t\t\t\tv.erase(v.begin() + pos + 1, v.end());\n\t\t\t\t\t\tv.push_back(link[a][i]); pos = v.size() - 1; break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (s == \"back\") {\n\t\t\t\tif (pos)pos--;\n\t\t\t}\n\t\t\tif (s == \"forward\") {\n\t\t\t\tif (pos < v.size() - 1)pos++;\n\t\t\t}\n\t\t\tif (s == \"show\")cout << v[pos] << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <set>\n\nusing namespace std;\n\n#define f first\n#define s second\n\ntypedef pair<int, int> P;\ntypedef pair<P, P> P2;\ntypedef pair<P2, string> P3;\n\nint main(){\n  int n;\n  int W, H;\n  \n  while(cin >> n, n){\n    cin >> W >> H;\n    \n    map<string, vector<P3> > page;\n    vector<P3> link;\n    string page_name;\n    string now;\n    int n_button, x1, x2, y1, y2;\n    \n    for(int i = 0 ; i < n ; i++){\n      cin >> page_name >> n_button;\n      if(i == 0) now = page_name;\n      for(int j = 0 ; j < n_button ; j++){\n\tP3 tmp;\n\tcin >> tmp.f.f.f >> tmp.f.f.s >> tmp.f.s.f >> tmp.f.s.s >> tmp.s;\n\tlink.push_back(tmp);\n      }\n      page.insert(make_pair(page_name, link));\n    }\n    \n    int n_op, x, y;\n    string op;\n    vector<string> history;\n    history.push_back(now);\n    int n_now = 0;\n    cin >> n_op;\n    cin.ignore();\n    while(n_op--){\n      getline(cin, op);\n      \n      if(op[0] == 'c'){ // click\n\tstring tmp1=\"\", tmp2=\"\";\n\tint i;\n\tfor(i = 6 ; op[i] != ' ' ; i++) tmp1 += op[i];\n\tfor( ; i < op.size() ; i++) tmp2 += op[i];\n\t\n\tx = atoi(tmp1.c_str());\n\ty = atoi(tmp2.c_str());\n\t\n\tfor(i = 0 ; i < page[now].size() ; i++){\n\t  if((page[now][i].f.f.f <= x && x <= page[now][i].f.s.f) &&\n\t     (page[now][i].f.f.s <= y && y <= page[now][i].f.s.s)){\n\t    now = page[now][i].s;\n\t    history.push_back(now);\n\t    n_now++;\n\t  }\n\t}\n      } // click end\n    \n      if(op == \"show\") cout << history[n_now] << endl;\n      if(op == \"back\") n_now--;\n      if(op == \"forward\") n_now++;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n#define MAX 1000\n\nstruct Page{\n  int sx,sy,tx,ty;\n  string next;\n  Page(int sx,int sy,int tx,int ty,string next)\n    : sx(sx),sy(sy),tx(tx),ty(ty),next(next) {}\n};\n\nint main(){\n  int N,W,H,b,sx,sy,tx,ty,p = 0;\n  string str[MAX],s;\n\n  while(cin >> N,N){\n    cin >> W >> H;\n    vector<Page> vec[MAX];\n    for(int i = 0 ; i < N ; i++){\n      cin >> str[i] >> b;\n      for(int j = 0 ; j < b ; j++){\n        cin >> sx >> sy >> tx >> ty >> s;\n        vec[i].push_back(Page(sx,sy,tx,ty,s));\n      }\n    }\n    int m,w,h,now = 0;\n    vector<int> now_page;\n    now_page.push_back(now);\n    string next;\n    cin >> m;\n    for(int I = 0 ; I < m ; I++){\n      int size = now_page.size();\n      if(now_page[size-1] != now){\n        now_page.push_back(now);\n        p++;\n        size = now_page.size();\n      }\n      cin >> s;\n      if(s == \"click\"){\n        bool found = false;\n        cin >> w >> h;\n        for(int i = 0 ; i < (int)vec[now].size() ; i++){\n          sx = vec[now][i].sx, sy = vec[now][i].sy;\n          tx = vec[now][i].tx, ty = vec[now][i].ty;\n          next = vec[now][i].next;\n          if(sx <= w && w <= tx && sy <= h && h <= ty){\n            for(int j = 0 ; j < N ; j++){\n              if(str[j] == next){\n                now = j;\n                found = true;\n                break;\n              }\n            }\n          }\n          if(found) break;\n        }\n      }else if(s == \"show\"){\n        cout << str[now_page[p]] << endl;\n      }else if(s == \"back\"){\n        if(p > 0) p--;\n      }else{\n        if(p+1 < size) p++;\n      }\n    }\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\nconst int MAX = 110;\n\nstring data[MAX];\nint W,H,N;\n\nstruct Button{\n  int lx,rx,ly,ry;\n  string name;\n};\n\nmap<string,vector<Button> > M;\n\n\nvoid init(){\n  M.clear();\n  fill(data,data+MAX,\"\");\n}\n\nvoid input(){\n  cin >> W >> H;\n  for(int i = 0; i < N; i++){\n    string s;\n    int num;\n    cin >> s >> num;\n    if(i == 0) data[0] = s;\n\n    for(int j = 0; j < num; j++){\n      Button B;\n      cin >> B.lx >> B.ly >> B.rx >> B.ry >> B.name;\n      M[s].push_back(B);\t\n    }\n\n  }\n}\n\nvoid solve(){\n  int num;\n  cin >> num;\n  int index = 0;\n\n\n  while(num--){\n    string op;\n    cin >> op;\n    if(op == \"click\"){\n      int x,y;\n      cin >> x >> y;\n      string now = data[index];\n\n      for(int i = 0; i < M[now].size(); i++){\n\tif(M[now][i].lx <= x && x <= M[now][i].rx && M[now][i].ly <= y && y <= M[now][i].ry){\n\t  data[++index] = M[now][i].name;\n\t  break;\n\t}\n\n      }\n\n    }else if(op == \"back\") index--;\n    else if(op == \"forward\") index++;\n    else if(op == \"show\") cout << data[index] << endl;\n  }\n}\n\nint main(){\n\n  while(cin >> N && N){\n    input();\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <utility>\n#include <map>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nclass Nx{\n\tpublic:\n\tP p, q;\n\tstring name;\n\tNx() {}\n\tNx(string _name, P _p, P _q): name(_name), p(_p), q(_q) {}\n\t\n\tbool comp(int x, int y){\n\t\treturn (p.first <= x && x <= q.first && p.second <= y && y <= q.second);\n\t}\n};\n\nclass St{\n\tpublic:\n\tstring name;\n\tvector<Nx> vec;\n\tSt() {}\n\tSt(string _name): name(_name) {}\n\t\n\tstring check(int x, int y){\n\t\tstring str = \"\";\n\t\tfor(int i = 0; i < vec.size(); i++){\n\t\t\tif(vec[i].comp(x, y)){\n\t\t\t\tstr = vec[i].name;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn str;\n\t}\n};\n\nint main()\n{\n\tint n, m, w, h, s, t, u, v, a[50000];\n\tstring str;\n\t\n\twhile(cin>>n && n){\n\t\tvector<St> vec;\n\t\tmap<string,int> mpp;\n\t\tcin >> w >> h;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tcin >> str >> m;\n\t\t\tmpp[str] = i;\n\t\t\tvec.push_back(St(str));\n\t\t\twhile(m--){\n\t\t\t\tcin >> s >> t >> u >> v >> str;\n\t\t\t\tvec[i].vec.push_back(Nx(str, P(s, t), P(u, v)));\n\t\t\t}\n\t\t}\n\t\tcin >> n;\n\t\tt = 0;\n\t\tfill(a, a+1000, -1);\n\t\ta[0] = 0;\n\t\twhile(n--){\n\t\t\tcin >> str;\n\t\t\tif(str == \"click\"){\n\t\t\t\tcin >> u >> v;\n\t\t\t\tstring tmp = vec[t].check(u, v);\n\t\t\t\tif(tmp.size() > 0){\n\t\t\t\t\tt++;\n\t\t\t\t\tfill(a+t, a+1000, -1);\n\t\t\t\t\ta[t] = mpp[tmp];\n\t\t\t\t}\n\t\t\t} else if(str == \"show\"){\n\t\t\t\tcout << vec[a[t]].name << endl;\n\t\t\t} else if(str == \"back\"){\n\t\t\t\tif(t > 0){\n\t\t\t\t\tt--;\n\t\t\t\t}\n\t\t\t} else if(str == \"forward\"){\n\t\t\t\tif(a[t+1] != -1){\n\t\t\t\t\tt++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<algorithm>\n#include<iostream>\n#include<vector>\n#include<climits>\n#include<cfloat>\n\nusing namespace std;\n\nstruct point{\n  double x, y;\n};\n\nstruct button{\n  point ld,ru;\n  string name;\n};\n\nstruct page{\n  string name;\n  vector<button>btn;   \n}; \n\nint main(void){\n  int n;\n  int w,h,b;\n  point l,r;\n  page in;\n  vector<page> a;\n  button tmp;\n\n  while(cin >> n,n){\n  \n    a.clear();\n\n    cin >> w >> h;\n    \n    for(int j=0;j<n;j++){\n      cin >> in.name >> b;    \n      \n      for(int i=0;i<b;i++){\n\tcin >> tmp.ld.x >> tmp.ld.y >> tmp.ru.x >> tmp.ru.y >> tmp.name;\n\tin.btn.push_back(tmp);\n      }\n      a.push_back(in);\n    }\n\n    int m,now=0,fg=0;\n    static page buf[1000000];\n\n    cin >> m;\n    buf[0]=a[0];\n    while(m--){\n      string s;\n      cin >> s;\n      if(s==\"click\"){\n\tint c,d;\n\tcin >> c >> d;\n\t\n\tfor(int i=0;i<buf[now].btn.size();i++){\n\t  int fg2=0;\n\t  if(buf[now].btn[i].ld.x <=c &&\n\t     buf[now].btn[i].ld.y <=d &&\n\t     buf[now].btn[i].ru.x >=c &&\n\t     buf[now].btn[i].ru.y >=d){\n\t    for(int j=0;j<a.size();j++){\n\t      if(buf[now].btn[i].name==a[j].name){\n\t\tbuf[++now]=a[j];\n\t\tfg=0;\n\t\tfg2=1;\n\t\tbreak;\n\t      }\n\t    }\n\t    if(fg2)break;\n\t  }\n\t}\n      }\n      else if(s==\"back\" && now>0){\n\tnow--;\n\tfg++;\n      }\n      else if(s==\"forward\" && fg>0 && now < 1000000)now++,fg--;\n      else if(s==\"show\")cout << buf[now].name << endl;\n    }\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <array>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <iterator>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <tuple>\n#include <unordered_map>\n#include <unordered_set>\n#include <utility>\n#include <vector>\nusing namespace std;\n\n#define dump(a) (cerr << (#a) << \" = \" << (a) << endl)\n\ntemplate<class T> inline void chmax(T& a, const T& b) { if(b > a) a = b; }\ntemplate<class T> inline void chmin(T& a, const T& b) { if(b < a) a = b; }\n\ntemplate<typename T, typename U>\nostream& operator<<(ostream& os, const pair<T, U>& p) {\n\tos << '(' << p.first << \", \" << p.second << ')';\n\treturn os;\n}\n\ntemplate<class Tuple, unsigned Index>\nvoid print_tuple(ostream& os, const Tuple& t) {}\n\ntemplate<class Tuple, unsigned Index, class Type, class... Types>\nvoid print_tuple(ostream& os, const Tuple& t) {\n\tif(Index > 0) os << \", \";\n\tos << get<Index>(t);\n\tprint_tuple<Tuple, Index + 1, Types...>(os, t);\n}\n\ntemplate<class... Types>\nostream& operator<<(ostream& os, const tuple<Types...>& t) {\n\tos << '(';\n\tprint_tuple<tuple<Types...>, 0, Types...>(os, t);\n\treturn os << ')';\n}\n\ntemplate<class Iterator>\nostream& dump_range(ostream&, Iterator, const Iterator&);\n\ntemplate<typename T>\nostream& operator<<(ostream& os, vector<T> c) {\n\treturn dump_range(os, c.cbegin(), c.cend());\n}\n\ntemplate<class Iterator>\nostream& dump_range(ostream& os, Iterator first, const Iterator& last) {\n\tos << '[';\n\tfor(int i = 0; first != last; ++i, ++first) {\n\t\tif(i) os << \", \";\n\t\tos << *first;\n\t}\n\treturn os << ']';\n}\n\nunordered_map<string, int> en;\nunordered_map<int, string> de;\nint encode(const string& s) {\n\tif(!en.count(s)) {\n\t\ten.insert(make_pair(s, en.size()));\n\t\tde[en[s]] = s;\n\t}\n\treturn en[s];\n}\n\nstring decode(int x) {\n\treturn de[x];\n}\n\nstruct button {\n\tint x1, y1, x2, y2;\n\tstring to;\n\tbutton(int x1, int y1, int x2, int y2, string to):x1(x1), y1(y1), x2(x2), y2(y2), to(to){}\n\tbool hit(int x, int y) {\n\t\treturn x1 <= x && x <= x2 && y1 <= y && y <= y2;\n\t}\n};\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tfor(int n; cin >> n && n;) {\n\t\ten.clear();\n\n\t\tint w, h;\n\t\tcin >> w >> h;\n\n\t\tvector<vector<button>> links(n);\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\tstring name;\n\t\t\tint number_of_links;\n\t\t\tcin >> name >> number_of_links;\n\n\t\t\tconst int idx = encode(name);\n\t\t\tfor(int j = 0; j < number_of_links; ++j) {\n\t\t\t\tint x1, y1, x2, y2;\n\t\t\t\tstring to;\n\t\t\t\tcin >> x1 >> y1 >> x2 >> y2 >> to;\n\t\t\t\tlinks[idx].emplace_back(x1, y1, x2, y2, to);\n\t\t\t}\n\t\t}\n\n\t\tstack<int> undo, redo;\n\t\tint current = 0;\n\n\t\tint q;\n\t\tcin >> q;\n\n\t\twhile(q--) {\n\t\t\tstring operation;\n\t\t\tcin >> operation;\n\n\t\t\tswitch(operation[0]) {\n\t\t\tcase 's':\n\t\t\t{\n\t\t\t\tcout << decode(current) << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 'c':\n\t\t\t{\n\t\t\t\tint x, y;\n\t\t\t\tcin >> x >> y;\n\n\t\t\t\tfor(int i = 0; i < static_cast<int>(links[current].size()); ++i) {\n\t\t\t\t\tif(links[current][i].hit(x, y)) {\n\t\t\t\t\t\tundo.push(current);\n\t\t\t\t\t\tcurrent = encode(links[current][i].to);\n\t\t\t\t\t\twhile(redo.size()) redo.pop();\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 'b':\n\t\t\t{\n\t\t\t\tif(!undo.empty()) {\n\t\t\t\t\tredo.push(current);\n\t\t\t\t\tcurrent = undo.top();\n\t\t\t\t\tundo.pop();\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 'f':\n\t\t\t{\n\t\t\t\tif(!redo.empty()) {\n\t\t\t\t\tundo.push(current);\n\t\t\t\t\tcurrent = redo.top();\n\t\t\t\t\tredo.pop();\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdefault:\n\t\t\t\tdump(operation);\n\t\t\t\tassert(false);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 100000000\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P> PP;\n\nstatic const double EPS = 1e-8;\n\nconst int tx[] = {0,1,0,-1};\nconst int ty[] = {-1,0,1,0};\n\nclass Button{\npublic:\n\tint lu_x,lu_y,rl_x,rl_y;\n\tstring name;\n\tButton() : lu_x(0),lu_y(0),rl_x(0),rl_y(0),name(\"\"){}\n\tButton(int lu_x,int lu_y,int rl_x,int rl_y,string name): lu_x(lu_x),lu_y(lu_y),rl_x(rl_x),rl_y(rl_y),name(name){}\n};\n\nint main(){\n\tint n;\n\tint W,H;\n\tmap<string,vector<Button> > page;\n\tvector<string> browsed;\n\twhile(~scanf(\"%d\",&n)){\n\t\tif(n==0) break;\n\t\tscanf(\"%d %d\",&W,&H);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tstring name;\n\t\t\tint num;\n\t\t\tcin >> name >> num;\n\t\t\tfor(int j=0;j<num;j++){\n\t\t\t\tstring next;\n\t\t\t\tint lu_x,lu_y,rl_x,rl_y;\n\t\t\t\tcin >> lu_x >> lu_y >> rl_x >> rl_y >> next;\n\t\t\t\tpage[name].push_back(Button(lu_x,lu_y,rl_x,rl_y,next));\n\t\t\t\tif(browsed.size()==0) browsed.push_back(name);\n\t\t\t}\n\t\t}\n\n\t\tint m;\n\t\tint pos = 0;\n\t\tscanf(\"%d\",&m);\n\t\tfor(int i=0;i<m;i++){\n\t\t\tstring act;\n\t\t\tcin >> act;\n\t\t\tif(act==\"click\"){\n\t\t\t\tint x,y;\n\t\t\t\tcin >> x >> y;\n\t\t\t\tstring now = browsed[pos];\n\t\t\t\tfor(int i=0;i<page[now].size();i++){\n\t\t\t\t\tif(!(x < page[now][i].lu_x || page[now][i].rl_x < x\n\t\t\t\t\t\t|| y > page[now][i].rl_y || page[now][i].lu_y > y)){\n\t\t\t\t\t\t\tbrowsed.erase(browsed.begin()+pos+1,browsed.end());\n\t\t\t\t\t\t\tbrowsed.push_back(page[now][i].name);\n\t\t\t\t\t\t\tpos++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(act==\"back\"){\n\t\t\t\tif(pos>0)pos--;\n\t\t\t}\n\t\t\telse if(act==\"forward\"){\n\t\t\t\tif(pos<browsed.size()-1) pos++;\n\t\t\t}\n\t\t\telse if(act==\"show\"){\n\t\t\t\tcout << browsed[pos] << \"\\n\";\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "/*\n * Author: FreeIdea\n * Created Time:  2011/8/24 14:57:58\n * File Name: D.cpp\n */\n#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <algorithm>\n#include <vector>\n#include <map>\nusing namespace std;\nconst int maxint = -1u>>1;\ntemplate <class T> bool get_max(T& a, const T &b) {return b > a? a = b, 1: 0;}\ntemplate <class T> bool get_min(T& a, const T &b) {return b < a? a = b, 1: 0;}\nconst int maxn = 150;\n\nint n, w, h, cnt, q;\n\nstruct Button {\n    int x1, y1, x2, y2, to_id;\n    Button() {}\n    Button(int _x1, int _y1, int _x2, int _y2, int _to_id):x1(_x1), y1(_y1), x2(_x2), y2(_y2), to_id(_to_id){}\n};\n\nstruct Page {\n    vector<Button> buttons;\n    string name;\n}page[maxn];\n\nmap<string, int> idx;\n\nint hash(const string &str) {\n    if(idx.count(str))  return idx[str];\n    return idx[str] = ++cnt;\n}\n\nvector<int> buffer;\nint pt;\n\nbool in_button(int x, int y, int x1, int y1, int x2, int y2) {\n    return x1 <= x && x<= x2 && y1 <= y && y <= y2;\n}\n\nvoid click(int x, int y) {\n    int to_page = -1;\n    int cur = buffer[pt];\n    for(int i = 0; i < page[cur].buttons.size(); i++) {\n        if(in_button(x, y, page[cur].buttons[i].x1, page[cur].buttons[i].y1, page[cur].buttons[i].x2, page[cur].buttons[i].y2)) {\n            to_page = page[cur].buttons[i].to_id;\n        }\n    }\n    if(to_page == -1)   return;\n    int sz = buffer.size();\n    for(int i = pt + 1; i < sz; i++) {\n        buffer.pop_back();\n    }\n    buffer.push_back(to_page);\n    pt = buffer.size() - 1;\n}\n\nvoid back() {\n    if(pt != 0) pt--;\n}\n\nvoid forward() {\n    if(pt + 1 < buffer.size()) {\n        pt++;\n    }\n}\n\nvoid show() {\n    int cur = buffer[pt];\n    cout << page[cur].name << endl;\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    while(cin >> n) {\n        if(!n)  break;\n        cin >> w >> h;\n        idx.clear();\n        cnt = 0;\n        for(int i = 1; i <= n; i++) {\n            string name;\n            cin >> name;\n            int id = hash(string(name));\n            page[id].name = name;\n            page[id].buttons.clear();\n            int m;\n            cin >> m;\n            for(int i = 1; i <= m; i++) {\n                int x1, y1, x2, y2, to_id;\n                string to;\n                cin >> x1 >> y1 >> x2 >> y2 >> to;\n                to_id = hash(to);\n                page[id].buttons.push_back(Button(x1, y1, x2, y2, to_id));\n            }\n        }\n        cin >> q;\n        string op;\n        int x, y;\n        buffer.clear();\n        buffer.push_back(1);\n        pt = 0;\n        for(int i = 1; i <= q; i++) {\n            cin >> op;\n            if(op == \"click\") {\n                cin >> x >> y;\n                click(x, y);\n            }\n            else if(op == \"back\") {\n                back();\n            }\n            else if(op == \"forward\") {\n                forward();\n            }\n            else if(op == \"show\") {\n                show();\n            }\n        }\n    } \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// AOJ1054 Distorted Love\n\n#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n\nusing namespace std;\n\nclass button{\npublic:\n\tint x1, y1, x2, y2; string name;\n\tbutton(int x1, int y1, int x2, int y2, string name) : x1(x1), y1(y1), x2(x2), y2(y2), name(name) {}\n\tbool in(int x, int y) { return x1 <= x && x <= x2 && y1 <= y && y <= y2; }\n};\n\nint main(){\n\tint n;\n\tint buf[100];\n\twhile(cin >> n, n){\n\t\tint x, y; cin >> x >> y;\n\t\tbuf[0] = 0; \n\t\tint size = 0;\n\t\tint cur = 0;\n\t\tstring s;\n\t\tvector<string> vs;\n\t\tmap<string, int> mp;\n\t\tvector< vector<button> > vv(n);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin >> s;\n\t\t\tvs.push_back(s);\n\t\t\tmp[s] = i;\n\t\t\tint t; cin >> t;\n\t\t\tfor(int j=0;j<t;j++){\n\t\t\t\tint x1, y1, x2, y2; cin >> x1 >> y1 >> x2 >> y2 >> s;\n\t\t\t\tvv[i].push_back(button(x1, y1, x2, y2, s));\n\t\t\t}\n\t\t}\n\t\tcin >> n;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin >> s;\n\t\t\tif(s==\"show\") cout << vs[cur] << endl;\n\t\t\tif(s==\"forward\"){\n\t\t\t\tif(cur != size) cur++;\n\t\t\t}\n\t\t\tif(s==\"back\"){\n\t\t\t\tif(cur != 0) cur--;\n\t\t\t}\n\t\t\tif(s==\"click\"){\n\t\t\t\tint x, y; cin >> x >> y;\n\t\t\t\tfor(int j=0;j<vv[buf[cur]].size();j++){\n\t\t\t\t\tif(vv[buf[cur]][j].in(x,y)){\n\t\t\t\t\t\tcur++;\n\t\t\t\t\t\tsize = cur;\n\t\t\t\t\t\tbuf[cur] = mp[vv[buf[cur-1]][j].name];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<algorithm>\n#include<iostream>\n#include<vector>\n#include<climits>\n#include<cfloat>\n\nusing namespace std;\n\ndouble EPS = 1e-10;\n\ndouble add(double a, double b){\n  if(abs(a+b) < EPS * (abs(a)+abs(b)))return 0;\n  return a+b;\n}\n\nstruct point{\n  double x, y;\n  point(){}\n  point(double x,double y) : x(x) , y(y){}\n\n  point operator + (point p){\n    return point(add(x,p.x), add(y,p.y));\n  }\n\n  point operator - (point p){\n    return point(add(x,-p.x), add(y,-p.y));\n  }\n\n  point operator * (double d){\n    return point(x*d,y*d);\n  }\n\n  point operator / (double d){\n    return point(x/d,y/d);\n  }\n  \n  bool operator == ( const point &p ) const {\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n};\n\nstruct button{\n  point ld,ru;\n  string name;\n};\n\nstruct page{\n  string name;\n  vector<button>btn;   \n}; \n\nint tail;\npage stk[1000000];\n\nvoid push(page a){\n  stk[tail++]=a;\n}\n\npage pop(void){\n  tail--;\n  return stk[tail+1];\n}\n\nint main(void){\n  int n;\n  int w,h,b;\n  point l,r;\n  page in;\n  vector<page> a;\n  button tmp;\n\n  while(cin >> n,n){\n  \n    a.clear();\n\n    cin >> w >> h;\n    \n    for(int j=0;j<n;j++){\n      cin >> in.name >> b;    \n      \n      for(int i=0;i<b;i++){\n\tcin >> tmp.ld.x >> tmp.ld.y >> tmp.ru.x >> tmp.ru.y >> tmp.name;\n\tin.btn.push_back(tmp);\n      }\n      a.push_back(in);\n    }\n\n    int m,now=0;\n\n    cin >> m;\n    tail=0;\n    int fg=0;\n    push(a[0]);\n    while(m--){\n      string s;\n      cin >> s;\n      if(s==\"click\"){\n\tint c,d;\n\tcin >> c >> d;\n\t\n\tfor(int i=0;i<stk[tail-1].btn.size();i++){\n\t  int fg2=0;\n\t  if(stk[tail-1].btn[i].ld.x <=c &&\n\t     stk[tail-1].btn[i].ld.y <=d &&\n\t     stk[tail-1].btn[i].ru.x >=c &&\n\t     stk[tail-1].btn[i].ru.y >=d){\n\t    for(int j=0;j<a.size();j++){\n\t      if(stk[tail-1].btn[i].name==a[j].name){\n\t\tpush(a[j]);\n\t\tfg=0;\n\t\tfg2=1;\n\t\tbreak;\n\t      }\n\t    }\n\t    if(fg2)break;\n\t  }\n\t}\n      }\n      else if(s==\"back\" && tail-1>0){\n\ttail--;\n\tfg++;\n      }\n      else if(s==\"forward\" && fg-- && tail-1 < 1000000)tail++;\n      else if(s==\"show\")cout << stk[tail-1].name << endl;\n    }\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// 8-11.cpp : 螳壻ケ画而蛻カ蜿ー蠎皮畑遞句コ冗噪蜈・蜿」轤ケ縲?//\n\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<iomanip>\n using namespace std;\n struct page\n {\n\t string name;\n\t int but;\n\t int x1[200],x2[200],y1[200],y2[200];\n\t string next[200];\n };\n struct page a[1000];\n\n string s[100000];\nint main()\n{\n\n\tint n,w,h;\n\twhile(cin>>n && n!=0)\n\t{\n\t\tcin>>w>>h;\n\t\t\n\t\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n           cin>>a[i].name>>a[i].but;\n\t\t   for(int j=1;j<=a[i].but;j++)\n\t\t   {\n\t\t\t   cin>>a[i].x1[j]>>a[i].y1[j]>>a[i].x2[j]>>a[i].y2[j]>>a[i].next[j];\n\t\t\t   if(a[i].x1[j]>a[i].x2[j]){int temp=a[i].x1[j];a[i].x1[j]=a[i].x2[j];a[i].x2[j]=temp;}\n\t\t\t    if(a[i].y1[j]>a[i].y2[j]){int temp=a[i].y1[j];a[i].y1[j]=a[i].y2[j];a[i].y2[j]=temp;}\n\t\t   }\n\t\t}\n\n        \n\t\tlong long m;\n\t\tcin>>m;\n\t\tstring ss;\n\t\tlong long  t=1;\n\t\ts[1]=a[1].name;\n\t\tlong long  max=1;\n\n\t\tfor(int k=1;k<=m;k++)\n\t\t{\n\t\t  int x,y;\n\t\t\tcin>>ss;\n\t\t\t\t\t\n\t\t\tif(ss==\"click\"){\n\t\t\t\t          cin>>x>>y;\n\t\t\t\t\t\t  for(int i=1;i<=a[t].but;i++)\n\t\t\t\t\t\t\t  if(x>=a[t].x1[i] &&x<=a[t].x2[i] &&y>=a[t].y1[i] &&y<=a[t].y2[i]) {t++;max=t;s[t]=a[t-1].next[i];}\n\t\t\t               }      \n\t\t\telse\t\t\t\t  \n\t\t\t\t\t\t \n\t\t\tif(ss==\"show\"){cout<<s[t]<<endl;}\n\t\t\telse\n\t\t\tif(ss==\"back\"){if(t>1) t--; }\n\t\t\telse\n\n\t\t\tif(ss==\"forward\"){if(t<max) t++;}\n \n\t\t\t\n\t\t}\n\n\n\t\t\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// AOJ1054 Distorted Love\n\n#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n\nusing namespace std;\n\nint main(){\n\tint n;\n\tint buf[1000000];\n\tstring name[100];\n\tint b[100], x1[100][100], y1[100][100], x2[100][100], y2[100][100], ptr[100][100];\n\tstring link[100][100];\n\twhile(cin >> n, n){\n\t\tint x, y; cin >> x >> y;\n\t\tint cur = 0, size = 0; \n\t\tbuf[cur] = 0;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin >> name[i] >> b[i];\n\t\t\tfor(int j=0;j<b[i];j++)\n\t\t\t\tcin >> x1[i][j] >> y1[i][j] >> x2[i][j] >> y2[i][j] >> link[i][j];\n\t\t}\n\t\tfor(int i=0;i<n;i++)\n\t\t\tfor(int j=0;j<n;j++)\n\t\t\t\tfor(int k=0;k<b[j];k++)\n\t\t\t\t\tif(link[j][k]==name[i]) ptr[j][k] = i;\n\t\tcin >> n;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tstring s; cin >> s;\n\t\t\tif(s == \"click\"){\n\t\t\t\tcin >> x >> y;\n\t\t\t\tfor(int j=0;j<b[buf[cur]];j++){\n\t\t\t\t\tif(x1[buf[cur]][j]<=x&&x<=x2[buf[cur]][j]&&y1[buf[cur]][j]<=y&&y<=y2[buf[cur]][j]){\n\t\t\t\t\t\tcur++;\n\t\t\t\t\t\tsize = cur;\n\t\t\t\t\t\tbuf[cur] = ptr[buf[cur-1]][j];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(s == \"forward\" && cur != size) cur++;\n\t\t\tif(s == \"back\" && cur != 0) cur--;\n\t\t\tif(s == \"show\") cout << name[buf[cur]] << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<algorithm>\n#include<iostream>\n#include<vector>\n#include<climits>\n#include<cfloat>\n\nusing namespace std;\n\ndouble EPS = 1e-10;\n\ndouble add(double a, double b){\n  if(abs(a+b) < EPS * (abs(a)+abs(b)))return 0;\n  return a+b;\n}\n\nstruct point{\n  double x, y;\n  point(){}\n  point(double x,double y) : x(x) , y(y){}\n\n  point operator + (point p){\n    return point(add(x,p.x), add(y,p.y));\n  }\n\n  point operator - (point p){\n    return point(add(x,-p.x), add(y,-p.y));\n  }\n\n  point operator * (double d){\n    return point(x*d,y*d);\n  }\n\n  point operator / (double d){\n    return point(x/d,y/d);\n  }\n  \n  bool operator == ( const point &p ) const {\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n};\n\nstruct button{\n  point ld,ru;\n  string name;\n};\n\nstruct page{\n  string name;\n  vector<button>btn;   \n}; \n\nint tail;\npage stk[2000000];\n\nvoid push(page a){\n  stk[tail++]=a;\n}\n\npage pop(void){\n  tail--;\n  return stk[tail+1];\n}\n\nint main(void){\n  int n;\n  int w,h,b;\n  point l,r;\n  page in;\n  vector<page> a;\n  button tmp;\n\n  while(cin >> n,n){\n  \n    a.clear();\n\n    cin >> w >> h;\n    \n    for(int j=0;j<n;j++){\n      cin >> in.name >> b;    \n      \n      for(int i=0;i<b;i++){\n\tcin >> tmp.ld.x >> tmp.ld.y >> tmp.ru.x >> tmp.ru.y >> tmp.name;\n\tin.btn.push_back(tmp);\n      }\n      a.push_back(in);\n    }\n\n    int m,now=0;\n\n    cin >> m;\n    tail=0;\n    int fg=0;\n    push(a[0]);\n    while(m--){\n      string s;\n      cin >> s;\n      if(s==\"click\"){\n\tint c,d;\n\tcin >> c >> d;\n\t\n\tfor(int i=0;i<stk[tail-1].btn.size();i++){\n\t  int fg2=0;\n\t  if(stk[tail-1].btn[i].ld.x <=c &&\n\t     stk[tail-1].btn[i].ld.y <=d &&\n\t     stk[tail-1].btn[i].ru.x >=c &&\n\t     stk[tail-1].btn[i].ru.y >=d){\n\t    for(int j=0;j<a.size();j++){\n\t      if(stk[tail-1].btn[i].name==a[j].name){\n\t\tpush(a[j]);\n\t\tfg=0;\n\t\tfg2=1;\n\t\tbreak;\n\t      }\n\t    }\n\t    if(fg2)break;\n\t  }\n\t}\n      }\n      else if(s==\"back\" && tail-1>0){\n\ttail--;\n\tfg++;\n      }\n      else if(s==\"forward\" && fg-- && tail-2 < 2000000)tail++;\n      else if(s==\"show\")cout << stk[tail-1].name << endl;\n    }\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <set>\n\nusing namespace std;\n\n#define f first\n#define s second\n\ntypedef pair<int, int> P;\ntypedef pair<P, P> P2;\ntypedef pair<P2, string> P3;\n\nint main(){\n  int n;\n  int W, H;\n  \n  while(cin >> n, n){\n    cin >> W >> H;\n    \n    map<string, vector<P3> > page;\n    vector<P3> link;\n    string page_name;\n    string now;\n    int n_button, x1, x2, y1, y2;\n    \n    for(int i = 0 ; i < n ; i++){\n      cin >> page_name >> n_button;\n      if(i == 0) now = page_name;\n      for(int j = 0 ; j < n_button ; j++){\n\tP3 tmp;\n\tcin >> tmp.f.f.f >> tmp.f.f.s >> tmp.f.s.f >> tmp.f.s.s >> tmp.s;\n\tlink.push_back(tmp);\n      }\n      page.insert(make_pair(page_name, link));\n    }\n    \n    int n_op, x, y;\n    string op;\n    vector<string> history;\n    history.push_back(now);\n    int n_now = 0;\n    cin >> n_op;\n    cin.ignore();\n    while(n_op--){\n      getline(cin, op);\n      \n      if(op[0] == 'c'){ // click\n\tstring tmp1=\"\", tmp2=\"\";\n\tint i;\n\tfor(i = 6 ; op[i] != ' ' ; i++) tmp1 += op[i];\n\tfor( ; i < op.size() ; i++) tmp2 += op[i];\n\t\n\tx = atoi(tmp1.c_str());\n\ty = atoi(tmp2.c_str());\n\t\n\tfor(i = 0 ; i < page[now].size() ; i++){\n\t  if((page[now][i].f.f.f <= x && x <= page[now][i].f.s.f) &&\n\t     (page[now][i].f.f.s <= y && y <= page[now][i].f.s.s)){\n\t    now = page[now][i].s;\n\t    history.push_back(now);\n\t    n_now++;\n\t  }\n\t}\n      } // click end\n    \n      if(op == \"show\") cout << history[n_now] << endl;\n      if(op == \"back\") n_now--;\n      if(op == \"forward\") n_now++;\n    }\n  }\n  return 0;\n}\n#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <set>\n\nusing namespace std;\n\n#define f first\n#define s second\n\ntypedef pair<int, int> P;\ntypedef pair<P, P> P2;\ntypedef pair<P2, string> P3;\n\nint main(){\n  int n;\n  int W, H;\n  \n  while(cin >> n, n){\n    cin >> W >> H;\n    \n    map<string, vector<P3> > page;\n    vector<P3> link;\n    string page_name;\n    string now;\n    int n_button, x1, x2, y1, y2;\n    \n    for(int i = 0 ; i < n ; i++){\n      cin >> page_name >> n_button;\n      if(i == 0) now = page_name;\n      for(int j = 0 ; j < n_button ; j++){\n\tP3 tmp;\n\tcin >> tmp.f.f.f >> tmp.f.f.s >> tmp.f.s.f >> tmp.f.s.s >> tmp.s;\n\tlink.push_back(tmp);\n      }\n      page.insert(make_pair(page_name, link));\n    }\n    \n    int n_op, x, y;\n    string op;\n    vector<string> history;\n    history.push_back(now);\n    int n_now = 0;\n    cin >> n_op;\n    cin.ignore();\n    while(n_op--){\n      getline(cin, op);\n      \n      if(op[0] == 'c'){ // click\n\tstring tmp1=\"\", tmp2=\"\";\n\tint i;\n\tfor(i = 6 ; op[i] != ' ' ; i++) tmp1 += op[i];\n\tfor( ; i < op.size() ; i++) tmp2 += op[i];\n\t\n\tx = atoi(tmp1.c_str());\n\ty = atoi(tmp2.c_str());\n\t\n\tfor(i = 0 ; i < page[now].size() ; i++){\n\t  if((page[now][i].f.f.f <= x && x <= page[now][i].f.s.f) &&\n\t     (page[now][i].f.f.s <= y && y <= page[now][i].f.s.s)){\n\t    now = page[now][i].s;\n\t    history.push_back(now);\n\t    n_now++;\n\t  }\n\t}\n      } // click end\n    \n      if(op == \"show\") cout << history[n_now] << endl;\n      if(op == \"back\") n_now--;\n      if(op == \"forward\") n_now++;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/* \n * File:   main.cpp\n * Author: æè¯º\n *\n * Created on 2011å¹´8æ27æ¥, ä¸å12:34\n */\n\n#include <cstdlib>\n#include <cstdio>\n#include <algorithm>\n#include <string>\n#include <iostream>\n#include <vector>\n#include <map>\n#include <stack>\n#include <cassert>\nusing namespace std;\nclass Page;\n\nstruct Point {\n    int x, y;\n};\n\nclass Rectangle {\npublic:\n    int left, right;\n    int buttom, top;\n\n    Rectangle() { }\n\n    Rectangle(int l, int t, int r, int b) : left(l), top(t), right(r), buttom(b) {\n        if (left > right)swap(left, right);\n        if (top > buttom)swap(top, buttom);\n    }\n\n    bool in(const Point &p) {\n        //cerr << left << right << top << buttom << endl;\n        //cerr << p.x << p.y << endl;\n        return left <= p.x && p.x <= right && top <= p.y && p.y <= buttom;\n    }\n};\n\nclass Link {\npublic:\n    Rectangle dest;\n    string destname;\n\n    Link() { }\n\n    Link(const Rectangle & rect, const string & s) : dest(rect), destname(s) { }\n};\n\nclass Page {\npublic:\n    string name;\n    vector<Link>link;\n\n    string operator[](const Point & p) {\n        int i;\n        for (i = 0; i < link.size(); ++i) {\n            if (link[i].dest.in(p))break;\n        }\n        if (link.begin() + i == link.end())return \"\";\n        return link[i].destname;\n    }\n};\n\nint main(int argc, char** argv) {\n    int pageNumber, maxWidth, maxHeight;\n    while (cin >> pageNumber && pageNumber) {\n        cin >> maxWidth >> maxHeight;\n        vector<Page>pages(pageNumber);\n        map<string, Page*>PageCast;\n        for (int i = 0; i < pageNumber; ++i) {\n            int count;\n            cin >> pages[i].name >> count;\n            while (count--) {\n                int a, b, c, d;\n                string s;\n                cin >> a >> b >> c >> d >> s;\n                pages[i].link.push_back(Link(Rectangle(a, b, c, d), s));\n            }\n            PageCast[pages[i].name] = &pages[i];\n        }\n        int operatorCount;\n        stack<Page*>UrlHistory;\n        stack<Page*>ForwardPages;\n        UrlHistory.push(&pages[0]);\n        cin >> operatorCount;\n        while (operatorCount--) {\n            string opt;\n            cin >> opt;\n            if (opt == \"click\") {\n                Point point;\n                cin >> point.x >> point.y;\n                if (UrlHistory.empty())continue;\n                string next = (*UrlHistory.top())[point];\n                if (next == \"\")continue;\n                while (!ForwardPages.empty())\n                    ForwardPages.pop();\n                UrlHistory.push(PageCast[next]);\n            } else if (opt == \"show\") {\n                if (UrlHistory.empty())continue;\n                cout << (*UrlHistory.top()).name << endl;\n            } else if (opt == \"back\") {\n                if (UrlHistory.empty())continue;\n                ForwardPages.push(UrlHistory.top());\n                UrlHistory.pop();\n            } else if (opt == \"forward\") {\n                if (ForwardPages.empty())continue;\n                UrlHistory.push(ForwardPages.top());\n                ForwardPages.pop();\n            } else assert(false);\n        }\n    }\n    return EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <string>\n#define maxn 205\nusing namespace std;\n\nstruct node\n{\n    int lx,ly,rx,ry;\n};\nstruct page\n{\n    string wname;\n    string a[maxn];\n    node b[maxn];\n    int len;\n}dp[maxn];\n\nint n,w,h,p;\nstring ans[10010];\nint fl[10010],fr[10010];\nint lenans;\nint main()\n{\n    int i,j,m,x,y,f;\n    string name;\n\n    //freopen(\"d.in\",\"r\",stdin);\n    while (1)\n    {\n        cin>>n;\n        if (n==0) break;\n        cin>>w>>h;\n        for (i=0;i<n;i++)\n        {\n            cin>>name>>m;\n            dp[i].wname=name;\n            dp[i].len=m;\n            for (j=0;j<m;j++)\n            {\n                cin>>dp[i].b[j].lx>>dp[i].b[j].ly>>dp[i].b[j].rx>>dp[i].b[j].ry>>dp[i].a[j];\n            }\n        }\n        cin>>m;\n        lenans=0;\n        p=0;\n        ans[0]=dp[0].wname;\n        fr[0]=-1;\n        fl[0]=-1;\n        //cout<<endl;\n        for (int k=0;k<m;k++)\n        {\n           cin>>name;\n           if (name==\"click\")\n           {\n               cin>>x>>y;\n               for (i=0;i<dp[p].len;i++)\n               {\n                   if (x>=dp[p].b[i].lx &&\n                       y>=dp[p].b[i].ly &&\n                       x<=dp[p].b[i].rx &&\n                       y<=dp[p].b[i].ry)\n                       {\n                           lenans++;\n                           fl[lenans]=p;\n                           fr[lenans]=-1;\n                           fr[p]=lenans;\n                           ans[lenans]=dp[p].a[i];\n                           p=lenans;\n                           break;\n                       }\n               }\n               continue;\n           }\n\n           if (name==\"show\")\n           {\n               cout<<ans[p]<<endl;\n               continue;\n           }\n\n           if (name==\"back\")\n           {\n               if (fl[p]!=-1) {\n\n                   f=fl[p];\n                   fr[f]=p;\n                   p=f;\n               }\n\n               continue;\n           }\n\n           if (name==\"forward\")\n           {\n               if(fr[p]!=-1)\n               {\n                   f=fr[p];\n                   fl[f]=p;\n                   p=f;\n               }\n               continue;\n           }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <bitset>\n \n#define rep(i, n) for(int i = 0; i < (n); i++)\n#define FOR(i, a, b) for(int i = (a); i < (b); i++)\n#define all(v) (v).begin(), (v).end()\n#define rev(s) (s).rbegin(), (s).rend()\n#define MP make_pair\n#define X first\n#define Y second\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef vector<int> vi;\n\nvoid fin(){\n\tfreopen(\"test.txt\", \"r\", stdin);\n}\n\nstruct button{\n\tint left, top, right, bottom;\n\tstring link;\n\tbutton(int l, int t, int r, int b, string li){\n\t\tleft = l, top = t, right = r, bottom = b, link = li;\n\t}\n};\n\nint main(){\n\t//fin();\n\tint n;\n\twhile(cin >> n, n){\n\t\tint w, h;\n\t\tcin >> w >> h;\n\t\tmap<string, vector<button> > pages;\n\t\tstring current;\n\t\trep(i, n){\n\t\t\tstring s;\n\t\t\tint bn;\n\t\t\tcin >> s >> bn;\n\t\t\tif(!i) current = s;\n\t\t\trep(i, bn){\n\t\t\t\tint left, top, right, bottom;\n\t\t\t\tstring link;\n\t\t\t\tcin >> left >> top >> right >> bottom >> link;\n\t\t\t\tpages[s].push_back(button(left, top, right, bottom, link));\n\t\t\t}\n\t\t}\n\t\tstack<string> back;\n\t\tstack<string> forward;\n\t\tint m;\n\t\tcin >> m;\n\t\trep(i, m){\n\t\t\tstring com;\n\t\t\tcin >> com;\n\t\t\tif(com == \"click\"){\n\t\t\t\tint x, y;\n\t\t\t\tcin >> x >> y;\n\t\t\t\trep(i, pages[current].size()){\n\t\t\t\t\tbutton b = pages[current][i];\n\t\t\t\t\tif(x < b.left || x > b.right || y < b.top || y > b.bottom) continue;\n\t\t\t\t\tback.push(current);\n\t\t\t\t\tforward = stack<string>();\n\t\t\t\t\tcurrent = b.link;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(com == \"back\"){\n\t\t\t\tif(back.empty())continue;\n\t\t\t\tforward.push(current);\n\t\t\t\tcurrent = back.top();\n\t\t\t\tback.pop();\n\t\t\t}\n\t\t\telse if(com == \"forward\"){\n\t\t\t\tif(forward.empty())continue;\n\t\t\t\tback.push(current);\n\t\t\t\tcurrent = forward.top();\n\t\t\t\tforward.pop();\n\t\t\t}\n\t\t\telse if(com == \"show\"){\n\t\t\t\tcout << current << endl;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\nusing namespace std;\n\nconst int N_MAX = 101;\nstring NAME[N_MAX];\nmap <string, int> INDEX;\nint LC[N_MAX];\nint BX1[N_MAX][N_MAX];\nint BY1[N_MAX][N_MAX];\nint BX2[N_MAX][N_MAX];\nint BY2[N_MAX][N_MAX];\nstring LINK[N_MAX][N_MAX];\nint BF[N_MAX];\n\nbool hitcheck( int cur, int link, int x, int y ) {\n    return BX1[cur][link] <= x && x <= BX2[cur][link] && BY1[cur][link] <= y && y <= BY2[cur][link];\n}\n\nint main() {\n    int n;\n    while ( cin >> n && n ) {\n        int bw, bh;\n        cin >> bw >> bh;\n        for ( int i = 0; i < n; ++ i ) {\n            cin >> NAME[i] >> LC[i];\n            INDEX[NAME[i]] = i;\n            for ( int j = 0; j < LC[i]; ++ j ) {\n                cin >> BX1[i][j] >> BY1[i][j] >> BX2[i][j] >> BY2[i][j] >> LINK[i][j];\n            }\n        }\n        int k;\n        cin >> k;\n        int cur = 0;\n        int most = 0;\n        BF[0] = 0;\n        for ( int i = 0; i < k; ++ i ) {\n            string cmd;\n            cin >> cmd;\n            if ( cmd == \"click\" ) {\n                int mx, my;\n                cin >> mx >> my;\n                for ( int j = 0; j < LC[cur]; ++ j ) {\n                    if ( hitcheck( cur, j, mx, my ) ) {\n                        BF[cur+1] = INDEX[LINK[cur][j]];\n                        cur += 1;\n                        most = cur;\n                        break;\n                    }\n                }\n            } else if ( cmd == \"show\" ) {\n                cout << NAME[BF[cur]] << endl;\n            } else if ( cmd == \"back\" ) {\n                if ( cur - 1 >= 0 ) {\n                    cur -= 1;\n                }\n            } else if ( cmd == \"forward\" ) {\n                if ( cur + 1 <= most ) {\n                    cur += 1;\n                }\n            }\n        }\n    }\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <deque>\n#include <map>\nusing namespace std;\ntypedef struct{int sx, sy, ex, ey; string to;} LINK;\t//ボタンの左上・右下座標、リンク先のページ名\ntypedef struct{string name; int n; LINK btn[100];} PAGE;\t//ページ名、ページ上にあるボタンの数・その一覧\nint main()\n{\n\tint n, o, W, H;\t//ページの数、命令の数、ページの幅・高さ\n\tint i, j, x, y, cur, t, m;\t//ループ用変数、\"click x y\"のx,y、、一時的な、履歴の長さ\n\tstring op;\t//命令の名前\n\tPAGE pg[100];\n\tLINK tmp;\n\tmap<string, int> tbl;\n\twhile (cin >> n, n)\n\t{\n\t\tdeque<string> his;\t//ページの履歴（pg[i]のiを代入）\n\t\tdeque<string>::iterator itr;\n\t\tcin >> W >> H;\n\t\tfor (i = 0; i < n; i++)\n\t\t{\n\t\t\tcin >> pg[i].name >> pg[i].n;\n\t\t\ttbl.insert( map<string, int>::value_type(pg[i].name, i) );\n\t\t\tfor (j = 0; j < pg[i].n; j++)\n\t\t\t{\n\t\t\t\tcin >> tmp.sx >> tmp.sy >> tmp.ex >> tmp.ey >> tmp.to;\n\t\t\t\tpg[i].btn[j] = tmp;\n\t\t\t}\n\t\t}\n\t\tcin >> o;\n\t\this.push_back(pg[0].name);\n\t\tcur = 0;\n\t\tm = 1;\n\t\tfor (i = 0; i < o; i++)\n\t\t{\n\t\t\tcin >> op;\n\t\t\tif (op == \"click\")\n\t\t\t{\n\t\t\t\tcin >> x >> y;\n\t\t\t\tt = tbl[his.at(cur)];\n\t\t\t\tfor (j = 0; j < pg[t].n; j++)\n\t\t\t\t{\n\t\t\t\t\tif (pg[t].btn[j].sx <= x && x <= pg[t].btn[j].ex && pg[t].btn[j].sy <= y && y <= pg[t].btn[j].ey)\n\t\t\t\t\t{\n\t\t\t\t\t\this.push_back(pg[t].btn[j].to);\n\t\t\t\t\t\tcur++;\n\t\t\t\t\t\tm++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\titr = his.end();\n\t\t\t\tfor (j = cur+1; j < m; j++)\n\t\t\t\t{\n\t\t\t\t\this.erase(itr);\n\t\t\t\t\tm--;\n\t\t\t\t\t*itr--;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (op == \"back\")\n\t\t\t{\n\t\t\t\tif (cur > 0)\n\t\t\t\t\tcur--;\n\t\t\t}\n\t\t\telse if (op == \"forward\")\n\t\t\t{\n\t\t\t\tif (cur < m)\n\t\t\t\t\tcur++;\n\t\t\t}\n\t\t\telse if (op == \"show\")\n\t\t\t{\n\t\t\t\tcout << his.at(cur) << endl;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n#define MAX 500\n\nstruct Page{\n  int sx,sy,tx,ty;\n  string next;\n  Page(int sx,int sy,int tx,int ty,string next)\n    : sx(sx),sy(sy),tx(tx),ty(ty),next(next) {}\n};\n\nvector<Page> vec[MAX];\n\nvoid init(){\n  for(int i = 0 ; i < MAX ; i++){\n    vec[i].clear();\n  }\n}\n\nint main(){\n  int N,W,H,b,sx,sy,tx,ty,p = 0;\n  string str[MAX],s;\n\n  while(cin >> N,N){\n    cin >> W >> H;\n    init();\n    for(int i = 0 ; i < N ; i++){\n      cin >> str[i] >> b;\n      for(int j = 0 ; j < b ; j++){\n        cin >> sx >> sy >> tx >> ty >> s;\n        vec[i].push_back(Page(sx,sy,tx,ty,s));\n      }\n    }\n    int m,w,h,now = 0;\n    vector<int> now_page;\n    now_page.push_back(now);\n    string next;\n    cin >> m;\n    for(int I = 0 ; I < m ; I++){\n      int size = now_page.size();\n      if(p == size-1 && now_page[size-1] != now){\n        now_page.push_back(now);\n        p++;\n        size = now_page.size();\n      }\n      cin >> s;\n      if(s == \"click\"){\n        bool found = false;\n        cin >> w >> h;\n        for(int i = 0 ; i < (int)vec[now_page[p]].size() ; i++){\n          sx = vec[now][i].sx, sy = vec[now][i].sy;\n          tx = vec[now][i].tx, ty = vec[now][i].ty;\n          next = vec[now][i].next;\n          if(sx <= w && w <= tx && sy <= h && h <= ty){\n            for(int j = 0 ; j < N ; j++){\n              if(str[j] == next){\n                now = j;\n                found = true;\n                break;\n              }\n            }\n          }\n          if(found){\n            p++;\n            while(p != now_page.size()){\n              now_page.pop_back();\n            }\n            now_page.push_back(now);\n            break;\n          }\n        }\n      }else if(s == \"show\"){\n        cout << str[now_page[p]] << endl;\n      }else if(s == \"back\"){\n        if(p > 0) p--;\n      }else{\n        if(p+1 < size) p++;\n      }\n    }\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// 8-11.cpp : 螳壻ケ画而蛻カ蜿ー蠎皮畑遞句コ冗噪蜈・蜿」轤ケ縲?//\n\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<iomanip>\n using namespace std;\n struct page\n {\n\t string name;\n\t int but;\n\t long long x1[200],x2[200],y1[200],y2[200];\n\t string next[200];\n };\n struct page a[1000];\n\n string s[100000];\nint main()\n{\n\n\tlong long n,w,h;\n\twhile(cin>>n && n!=0)\n\t{\n\t\tcin>>w>>h;\n\t\t\n\t\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n           cin>>a[i].name>>a[i].but;\n\t\t   for(int j=1;j<=a[i].but;j++)\n\t\t\t   cin>>a[i].x1[j]>>a[i].y1[j]>>a[i].x2[j]>>a[i].y2[j]>>a[i].next[j];\n\t\t}\n        \n\t\tint m;\n\t\tcin>>m;\n\t\tstring ss;\n\t\tlong long t=1;\n\t\ts[1]=a[1].name;\n\t\tlong long max=1;\n\n\t\twhile(m--)\n\t\t{\n\t\t   long long x,y;\n\t\t\tcin>>ss;\n\t\t\t\t\t\n\t\t\tif(ss==\"click\"){\n\t\t\t\t          cin>>x>>y;\n\t\t\t\t\t\t  for(int i=1;i<=a[t].but;i++)\n\t\t\t\t\t\t\t  if(x>=a[t].x1[i] &&x<=a[t].x2[i] &&y>=a[t].y1[i] &&y<=a[t].y2[i]) {t++;max=t;s[t]=a[t-1].next[i];}\n\t\t\t               }      \n\t\t\t\t\t\t\t  \n\t\t\t\t\t\t \n\t\t\tif(ss==\"show\"){cout<<s[t]<<endl;  }\n\t\t\tif(ss==\"back\"){if(t>1) t--; }\n\n\t\t\tif(ss==\"forward\"){if(t<max) t++;}\n \n\t\t\t\n\t\t}\n\n\n\t\t\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<vector>\n#include<set>\n#include<map>\n#include<queue>\n#include<algorithm>\n#include<numeric>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define rp(i,c) rep(i,(c).size())\n#define fr(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf=1<<28;\nconst double INF=1e12,EPS=1e-9;\n\nstruct S{\n\tint x1,y1,x2,y2;\n\tstring name;\n};\n\nint main()\n{\n\tint n;\n\twhile(cin>>n,n)\n\t{\n\t\tint h,w; cin>>h>>w;\n\t\tvector<string> name(n);\n\t\tvector<vector<S> > button(n);\n\t\trep(i,n)\n\t\t{\n\t\t\tint k;\n\t\t\tcin>>name[i]>>k;\n\t\t\t\n\t\t\trep(j,k)\n\t\t\t{\n\t\t\t\tS s;\n\t\t\t\tcin>>s.x1>>s.y1>>s.x2>>s.y2>>s.name;\n\t\t\t\tbutton[i].pb(s);\n\t\t\t}\n\t\t}\n\t\t\n\t\tint m; cin>>m;\n\t\tvector<string> buffer; int cur=0;\n\t\tbuffer.pb(name[0]);\n\t\t\n\t\trep(i,m)\n\t\t{\n\t\t\tstring op; cin>>op;\n\t\t\tif(op==\"show\")\n\t\t\t{\n\t\t\t\tcout<<buffer[cur]<<endl;\n\t\t\t}\n\t\t\telse if(op==\"click\")\n\t\t\t{\n\t\t\t\tint x,y; cin>>x>>y;\n\t\t\t\tfr(it,button[cur])if(it->x1<=x&&x<=it->x2&&it->y1<=y&&y<=it->y2)\n\t\t\t\t{\n\t\t\t\t\tbuffer.erase(buffer.begin()+cur+1,buffer.end());\n\t\t\t\t\tbuffer.pb(it->name);\n\t\t\t\t\tcur++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(op==\"back\")\n\t\t\t{\n\t\t\t\tif(cur>0)cur--;\n\t\t\t}\n\t\t\telse if(op==\"forward\")\n\t\t\t{\n\t\t\t\tif(cur<buffer.size()-1)cur++;\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 100000000\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P> PP;\n\nstatic const double EPS = 1e-8;\n\nconst int tx[] = {0,1,0,-1};\nconst int ty[] = {-1,0,1,0};\n\nclass Button{\npublic:\n\tint lu_x,lu_y,rl_x,rl_y;\n\tstring name;\n\tButton() : lu_x(0),lu_y(0),rl_x(0),rl_y(0),name(\"\"){}\n\tButton(int lu_x,int lu_y,int rl_x,int rl_y,string name): lu_x(lu_x),lu_y(lu_y),rl_x(rl_x),rl_y(rl_y),name(name){}\n};\n\nint main(){\n\tint n;\n\tint W,H;\n\tmap<string,vector<Button> > page;\n\tvector<string> browsed;\n\twhile(~scanf(\"%d\",&n)){\n\t\tif(n==0) break;\n\t\tscanf(\"%d %d\",&W,&H);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tstring name;\n\t\t\tint num;\n\t\t\tcin >> name >> num;\n\t\t\tfor(int j=0;j<num;j++){\n\t\t\t\tstring next;\n\t\t\t\tint lu_x,lu_y,rl_x,rl_y;\n\t\t\t\tcin >> lu_x >> lu_y >> rl_x >> rl_y >> next;\n\t\t\t\tpage[name].push_back(Button(lu_x,lu_y,rl_x,rl_y,next));\n\t\t\t\tif(browsed.size()==0) browsed.push_back(name);\n\t\t\t}\n\t\t}\n\n\t\tint m;\n\t\tint pos = 0;\n\t\tscanf(\"%d\",&m);\n\t\tfor(int i=0;i<m;i++){\n\t\t\tstring act;\n\t\t\tcin >> act;\n\t\t\tif(act==\"click\"){\n\t\t\t\tint x,y;\n\t\t\t\tcin >> x >> y;\n\t\t\t\tstring now = browsed[pos];\n\t\t\t\tfor(int j=0;j<page[now].size();j++){\n\t\t\t\t\tif((page[now][j].lu_x <= x && x <= page[now][j].rl_x)\n\t\t\t\t\t\t&& (page[now][j].lu_y <= y && y <= page[now][j].rl_y)){\n\t\t\t\t\t\t\t//printf(\"to %s\\n\",page[now][j].name.c_str());\n\n\t\t\t\t\t\t\tbrowsed.erase(browsed.begin()+pos+1,browsed.end());\n\t\t\t\t\t\t\tbrowsed.push_back(page[now][j].name);\n\t\t\t\t\t\t\tpos++;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(act==\"back\"){\n\n\t\t\t\tif(pos>0){\n\t\t\t\t\tpos--;\n\t\t\t\t\t//printf(\"back\\n\");\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(act==\"forward\"){\n\t\t\t\tif(pos<browsed.size()-1){\n\t\t\t\t\tpos++;\n\t\t\t\t\t//printf(\"forwardk\\n\");\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(act==\"show\"){\n\t\t\t\tcout << browsed[pos] << \"\\n\";\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<vector>\n#include<set>\n#include<map>\n#include<queue>\n#include<algorithm>\n#include<numeric>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define rp(i,c) rep(i,(c).size())\n#define fr(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf=1<<28;\nconst double INF=1e12,EPS=1e-9;\n\nstruct S{\n\tint x1,y1,x2,y2;\n\tstring name;\n};\n\nint main()\n{\n\tint n;\n\twhile(cin>>n,n)\n\t{\n\t\tint h,w; cin>>h>>w;\n\t\tvector<string> name(n);\n\t\tmap<string,vector<S> > button;\n\t\t\n\t\tcin.ignore();\n\t\t\n\t\trep(i,n)\n\t\t{\n\t\t\tint k;\n\t\t\tstring str;\n\t\t\tgetline(cin,str);\n\t\t\tint p=str.rfind(\" \");\n\t\t\t\n\t\t\tname[i]=str.substr(0,p);\n\t\t\tstringstream(str.substr(p))>>k;\n\t\t\t\n\t\t\trep(j,k)\n\t\t\t{\n\t\t\t\tS s;\n\t\t\t\tstring str; getline(cin,str);\n\t\t\t\t\n\t\t\t\tint p=0;\n\t\t\t\trep(it,4)p=str.find(\" \",p+1);\n\t\t\t\ts.name=str.substr(p+1);\n\t\t\t\t\n\t\t\t\tstringstream(str.substr(0,p))>>s.x1>>s.y1>>s.x2>>s.y2;\n\t\t\t\tbutton[name[i]].pb(s);\n\t\t\t}\n\t\t}\n\t\t\n\t\tint m; cin>>m;\n\t\tvector<string> buffer; int cur=0;\n\t\tbuffer.pb(name[0]);\n\t\t\n\t\trep(i,m)\n\t\t{\n\t\t\tstring op; cin>>op;\n\t\t\tif(op==\"show\")\n\t\t\t{\n\t\t\t\tcout<<buffer[cur]<<endl;\n\t\t\t}\n\t\t\telse if(op==\"click\")\n\t\t\t{\n\t\t\t\tint x,y; cin>>x>>y;\n\t\t\t\tfr(it,button[name[cur]])if(it->x1<=x&&x<=it->x2&&it->y1<=y&&y<=it->y2)\n\t\t\t\t{\n\t\t\t\t\tbuffer.erase(buffer.begin()+cur+1,buffer.end());\n\t\t\t\t\tbuffer.pb(it->name);\n\t\t\t\t\tcur++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(op==\"back\")\n\t\t\t{\n\t\t\t\tif(cur>0)cur--;\n\t\t\t}\n\t\t\telse if(op==\"forward\")\n\t\t\t{\n\t\t\t\tif(cur<buffer.size()-1)cur++;\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\nusing namespace std;\n\ntypedef struct\n{\n  string name;\n  int x1, x2, y1, y2;\n} Button;\n\nint main()\n{\n  int n;\n  while (cin >> n) {\n    if (n == 0)\n      break;\n\n    int W, H;\n    cin >> W >> H;\n\n    vector<string > buf;\n    map<string, vector<Button> > button;\n    for (int i = 0; i < n; ++i) {\n      string name;\n      int b;\n      cin >> name >> b;\n      for (int j = 0; j < b; ++j) {\n\tButton tmp;\n\tcin >> tmp.x1 >> tmp.y1 >> tmp.x2 >> tmp.y2 >> tmp.name;\n\tbutton[name].push_back(tmp);\n      }\n\n      if (i == 0)\n\tbuf.push_back(name);\n    }\n\n    int m, p = 0;\n    cin >> m;\n    while (m--) {\n      string cmd;\n      cin >> cmd;\n\n      if (cmd == \"click\") {\n\tint x, y;\n\tcin >> x >> y;\n\tconst vector<Button>& link = button[buf[p]];\n\tfor (int i = 0; i < link.size(); ++i) {\n\t  if (link[i].x1 <= x && x <= link[i].x2 &&\n\t      link[i].y1 <= y && y <= link[i].y2) {\n\t    buf.push_back(link[i].name);\n\t    p = buf.size()-1;\n\t    break;\n\t  }\n\t}\n      } else if (cmd == \"show\") {\n\tcout << buf[p] << endl;\n      } else if (cmd == \"back\") {\n\tif (p != 0)\n\t  --p;\n      } else {\n\tif (p+1 < buf.size())\n\t  ++p;\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\nusing namespace std;\n\nconst int N_MAX = 101;\nstring NAME[N_MAX];\nmap <string, int> INDEX;\nint LC[N_MAX];\nint BX1[N_MAX][N_MAX];\nint BY1[N_MAX][N_MAX];\nint BX2[N_MAX][N_MAX];\nint BY2[N_MAX][N_MAX];\nstring LINK[N_MAX][N_MAX];\nint BF[1000000];\n\nbool hitcheck( int cur, int link, int x, int y ) {\n    return BX1[cur][link] <= x && x <= BX2[cur][link] && BY1[cur][link] <= y && y <= BY2[cur][link];\n}\n\nint main() {\n    int n;\n    while ( cin >> n && n ) {\n        int bw, bh;\n        cin >> bw >> bh;\n        for ( int i = 0; i < n; ++ i ) {\n            cin >> NAME[i] >> LC[i];\n            INDEX[NAME[i]] = i;\n            for ( int j = 0; j < LC[i]; ++ j ) {\n                cin >> BX1[i][j] >> BY1[i][j] >> BX2[i][j] >> BY2[i][j] >> LINK[i][j];\n            }\n        }\n        int k;\n        cin >> k;\n        int cur = 0;\n        int most = 0;\n        BF[0] = 0;\n        for ( int i = 0; i < k; ++ i ) {\n            string cmd;\n            cin >> cmd;\n            if ( cmd == \"click\" ) {\n                int cur_index = BF[cur];\n                int mx, my;\n                cin >> mx >> my;\n                for ( int j = 0; j < LC[cur_index]; ++ j ) {\n                    if ( hitcheck( cur_index, j, mx, my ) ) {\n                        BF[cur+1] = INDEX[LINK[cur_index][j]];\n                        cur += 1;\n                        most = cur;\n                        break;\n                    }\n                }\n            } else if ( cmd == \"show\" ) {\n                cout << NAME[BF[cur]] << endl;\n            } else if ( cmd == \"back\" ) {\n                if ( cur - 1 >= 0 ) {\n                    cur -= 1;\n                }\n            } else if ( cmd == \"forward\" ) {\n                if ( cur + 1 <= most ) {\n                    cur += 1;\n                }\n            }\n        }\n    }\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nint i,j;\nstruct button\n{\n\tstring in;\n\tint x1;\n\tint y1;\n\tint x2;\n\tint y2;\n\tstring to;\n};\nint main()\n{\n\tfor(int n;cin>>n&&n;)\n\t{\n\t\tint w,h;\n\t\tcin>>w>>h;\n\t\tbutton a[10000];\n\t\tint q=0;\n\t\tfor(i=0;i<n;++i)\n\t\t{\n\t\t\tstring ss;\n\t\t\tint tt;\n\t\t\tcin>>ss>>tt;\n\t\t\tif(tt==0)\n\t\t\t{\n\t\t\t\ta[q].in=ss;\n\t\t\t\ta[q].to=ss;\n\t\t\t\ta[q].x1=-1;\n\t\t\t\ta[q].x2=-1;\n\t\t\t\ta[q].y1=-1;\n\t\t\t\ta[q++].y2=-1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor(j=0;j<tt;++j)\n\t\t\t{\n\t\t\t\tint xx1,yy1,xx2,yy2;\n\t\t\t\tstring TO;\n\t\t\t\tcin>>xx1>>yy1>>xx2>>yy2>>TO;\n\t\t\t\tint tx1=xx1<xx2? xx1:xx2;\n\t\t\t\tint tx2=xx1<xx2? xx2:xx1;\n\t\t\t\tint ty1=yy1<yy2? yy1:yy2;\n\t\t\t\tint ty2=yy1<yy2? yy2:yy1;\n\t\t\t\tif(xx1>w||xx1<0||xx2>w||xx2<0||yy1>h||yy1<0||yy2>h||yy2<0)\n\t\t\t\t{\n\t\t\t\t\ta[q].in=ss;\n\t\t\t\t\ta[q].to=ss;\n\t\t\t\t\ta[q].x1=-1;\n\t\t\t\t\ta[q].x2=-1;\n\t\t\t\t\ta[q].y1=-1;\n\t\t\t\t\ta[q++].y2=-1;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\ta[q].in=ss;\n\t\t\t\t\ta[q].to=TO;\n\t\t\t\t\ta[q].x1=tx1;\n\t\t\t\t\ta[q].x2=tx2;\n\t\t\t\t\ta[q].y1=ty1;\n\t\t\t\t\ta[q++].y2=ty2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint m;\n\t\tcin>>m;\n\t\tstring b[100];\n\t\tint p=0,pp=0;\n\t\tb[0]=a[0].in;\n\t\tfor(i=0;i<m;++i)\n\t\t{\n\t\t\tstring k;\n\t\t\tcin>>k;\n\t\t\tif(k==\"show\")\n\t\t\t\tcout<<b[pp]<<endl;\n\t\t\tif(k==\"back\"&&pp!=0)\n\t\t\t\tpp--;\n\t\t\tif(k==\"forward\"&&pp!=p)\n\t\t\t\tpp++;\n\t\t\tif(k==\"click\")\n\t\t\t{\n\t\t\t\tint x,y,f=0,e=q-1;\n\t\t\t\tcin>>x>>y;\n\t\t\t\t//cout<<f<<' '<<e<<endl;\n\t\t\t\tfor(j=0;j<q;++j)\n\t\t\t\t\tif(a[j].in==b[pp])\n\t\t\t\t\t{\n\t\t\t\t\t\tf=j;\n\t\t\t\t\t    for(int kk=f;kk<q;++kk)\n\t\t\t\t\t\t\tif(a[kk].in!=b[pp])\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\te=kk-1;\n\t\t\t\t\t\t\t\tgoto abc;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\tabc:\t\n\t\t\t\t//cout<<f<<' '<<e<<endl;\n\t\t\t\t\tfor(j=f;j<=e;++j)\n\t\t\t\t\t\tif(x>=a[j].x1&&x<=a[j].x2&&y>=a[j].y1&&y<=a[j].y2)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tp=pp;\n\t\t\t\t\t\t\tb[++p]=a[j].to;\n\t\t\t\t\t\t\tpp=p;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<algorithm>\n#include<iostream>\n#include<vector>\n#include<climits>\n#include<cfloat>\n\nusing namespace std;\n\ndouble EPS = 1e-10;\n\ndouble add(double a, double b){\n  if(abs(a+b) < EPS * (abs(a)+abs(b)))return 0;\n  return a+b;\n}\n\nstruct point{\n  double x, y;\n  point(){}\n  point(double x,double y) : x(x) , y(y){}\n\n  point operator + (point p){\n    return point(add(x,p.x), add(y,p.y));\n  }\n\n  point operator - (point p){\n    return point(add(x,-p.x), add(y,-p.y));\n  }\n\n  point operator * (double d){\n    return point(x*d,y*d);\n  }\n\n  point operator / (double d){\n    return point(x/d,y/d);\n  }\n  \n  bool operator == ( const point &p ) const {\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n};\n\nstruct button{\n  point ld,ru;\n  string name;\n};\n\nstruct page{\n  string name;\n  vector<button>btn;   \n};\n\nint main(void){\n  int n;\n  int w,h,b;\n  point l,r;\n  page in;\n  vector<page> a;\n  button tmp;\n\n  while(cin >> n,n){\n  \n    a.clear();\n\n    cin >> w >> h;\n    \n    for(int j=0;j<n;j++){\n      cin >> in.name >> b;    \n      \n      for(int i=0;i<b;i++){\n\tcin >> tmp.ld.x >> tmp.ld.y >> tmp.ru.x >> tmp.ru.y >> tmp.name;\n\tin.btn.push_back(tmp);\n      }\n      a.push_back(in);\n    }\n\n    int m,now=0;\n    cin >> m;\n\n    while(m--){\n      string s;\n      cin >> s;\n      if(s==\"click\"){\n\tint c,d;\n\tcin >> c >> d;\n\t\n\tfor(int i=0;i<a[now].btn.size();i++){\n\t  if(a[now].btn[i].ld.x <=c &&\n\t     a[now].btn[i].ld.y <=d &&\n\t     a[now].btn[i].ru.x >=c &&\n\t     a[now].btn[i].ru.y >=d){\n\t    for(int j=0;j<a.size();j++)\n\t      if(a[now].btn[i].name==a[j].name)now=j;\n\t  }\n\t}\n      }\n      else if(s==\"back\" && now>0)now--;\n      else if(s==\"forward\" && now<a.size()-2)now++;\n      else if(s==\"show\")cout << a[now].name << endl;\n    }\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <set>\n \nusing namespace std;\n \n#define f first\n#define s second\n \ntypedef pair<int, int> P;\ntypedef pair<P, P> P2;\ntypedef pair<P2, string> P3;\n \nint main(){\n  int n;\n  int W, H;\n   \n  while(cin >> n, n){\n    cin >> W >> H;\n    \n    map<string, int> n_link;\n    map<string, vector<P3> > page;\n    vector<P3> link;\n    string page_name;\n    string now;\n    int n_button;\n     \n    for(int i = 0 ; i < n ; i++){\n      cin >> page_name >> n_button;\n      n_link.insert(make_pair(page_name, n_button));\n      if(i == 0) now = page_name;\n      for(int j = 0 ; j < n_button ; j++){\n\tP3 tmp;\n\tcin >> tmp.f.f.f >> tmp.f.f.s >> tmp.f.s.f >> tmp.f.s.s >> tmp.s;\n\tlink.push_back(tmp);\n      }\n      page.insert(make_pair(page_name, link));\n    }\n     \n    //cout << page[\"profile\"][1].s << endl;\n\n    int n_op, x, y;\n    string op;\n    vector<string> history;\n    history.push_back(now);\n    int n_now = 0;\n    cin >> n_op;\n    cin.ignore();\n    while(n_op--){\n      getline(cin, op);\n       \n      if(op[0] == 'c'){ // click\n\tstring tmp1=\"\", tmp2=\"\";\n\tint i;\n\tfor(i = 6 ; op[i] != ' ' ; i++) tmp1 += op[i];\n\tfor( ; i < op.size() ; i++) tmp2 += op[i];\n     \n\tx = atoi(tmp1.c_str());\n\ty = atoi(tmp2.c_str());\n     \n\t//for(i = 0 ; i < page[now].size() ; i++){\n\tfor(i = page[now].size() - n_link[now] ; i < page[now].size() ; i++){\n\t  if((page[now][i].f.f.f <= x && x <= page[now][i].f.s.f) &&\n\t     (page[now][i].f.f.s <= y && y <= page[now][i].f.s.s)){\n\t    now = page[now][i].s;\n\t    \n\t    for(int i = history.size()-1 ; i > n_now ; i--){ // when back click\n\t      history.pop_back();\n\t    }\n\t    history.push_back(now);\n\t    n_now++;\n\t  }\n\t}\n      } // click end\n      \n      if(op == \"show\") cout << history[n_now] << endl;\n      if(op == \"back\"){\n\tif(n_now == 0) continue;\n\tn_now--;\n      }\n      if(op == \"forward\"){\n\tif(n_now == history.size()-1) continue;\n\tn_now++;\n      }\n    }\n    page.clear();\n    history.clear();\n    link.clear();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<algorithm>\n#include<iostream>\n#include<vector>\n#include<climits>\n#include<cfloat>\n\nusing namespace std;\n\nstruct point{\n  int x, y;\n};\n\nstruct button{\n  point ld,ru;\n  string name;\n};\n\nstruct page{\n  string name;\n  vector<button>btn;   \n}; \n\nint m,now;\nvector<page> a;\npage nul;\nstatic page buf[10001];\n\nvoid click(int c,int d){\n  \n  for(int i=0;i<buf[now].btn.size();i++)\n    if(buf[now].btn[i].ld.x <=c && buf[now].btn[i].ld.y <=d &&\n       buf[now].btn[i].ru.x >=c && buf[now].btn[i].ru.y >=d)\n      for(int j=0;j<a.size();j++)\n\tif(buf[now].btn[i].name==a[j].name){\n\t  buf[++now]=a[j];\n\t  fill(buf+now+1,buf+10000,nul);\n\t  return ;\n\t}\n}\n\nint main(void){\n  int n;\n  int w,h,b;\n  point l,r;\n  page in;\n  button tmp;\n\n  nul.name=\"\";\n\n  while(cin >> n,n){\n  \n    a.clear();\n    fill(buf,buf+10000,nul);\n\n    cin >> w >> h;\n    \n    for(int j=0;j<n;j++){\n      cin >> in.name >> b;    \n      \n      for(int i=0;i<b;i++){\n\tcin >> tmp.ld.x >> tmp.ld.y >> tmp.ru.x >> tmp.ru.y >> tmp.name;\n\tin.btn.push_back(tmp);\n      }\n      a.push_back(in);\n    }\n\n    now=0;\n    buf[0]=a[0];\n\n    cin >> m;\n\n    while(m--){\n      string s;\n      cin >> s;\n      if(s==\"click\"){\n\tint c,d;\n\tcin >> c >> d;\n\tclick(c,d);\n      }\n      else if(s==\"back\" && now>0)now--;\n      else if(s==\"forward\" && buf[now+1].name!=\"\")now++;\n      else if(s==\"show\")cout << buf[now].name << endl;\n    }\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <complex>\n#include <cstdio>\n#include <map>\n#include <math.h>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<n;i++)\n\nint n,W,H,a[100001],c,po,m;\nstruct page{\n\tint b,x1[100],y1[100],x2[100],y2[100];\n\tstring name,link[100];\n};\n\nint main(){\n\twhile(cin>>n&&n){\n\t\tfill(a,a+100001,-1);\n\t\ta[0]=0;c=0;po=0;\n\t\tcin>>W>>H;\n\t\tpage p[100];\n\t\trep(i,n){\n\t\t\tcin>>p[i].name>>p[i].b;\n\t\t\trep(j,p[i].b)cin>>p[i].x1[j]>>p[i].y1[j]>>p[i].x2[j]>>p[i].y2[j]>>p[i].link[j];\n\t\t}\n\t\tcin>>m;\n\t\trep(i,m){\n\t\t\tstring s;\n\t\t\tcin>>s;\n\t\t\tif(s==\"click\"){\n\t\t\t\tint x,y;\n\t\t\t\tcin>>x>>y;\n\t\t\t\trep(j,p[c].b)if(p[c].x1[j]<=x&&x<=p[c].x2[j]&&p[c].y1[j]<=y&&y<=p[c].y2[j]){\n\t\t\t\t\tstring st=p[c].link[j];\n\t\t\t\t\trep(k,n)if(st==p[k].name)c=(a[++po]=k);\n\t\t\t\t\tfill(a+po+1,a+100001,-1);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(s==\"back\"&&po)c=a[--po];\n\t\t\tif(s==\"forward\"&&a[po+1]!=-1)c=a[++po];\n\t\t\tif(s==\"show\")cout<<p[c].name<<endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <set>\n \nusing namespace std;\n \n#define f first\n#define s second\n \ntypedef pair<int, int> P;\ntypedef pair<P, P> P2;\ntypedef pair<P2, string> P3;\n \nint main(){\n  int n;\n  int W, H;\n   \n  while(cin >> n, n){\n    cin >> W >> H;\n    \n    map<string, int> n_link;\n    map<string, vector<P3> > page;\n    vector<P3> link;\n    string page_name;\n    string now;\n    int n_button;\n     \n    for(int i = 0 ; i < n ; i++){\n      cin >> page_name >> n_button;\n      n_link.insert(make_pair(page_name, n_button));\n      if(i == 0) now = page_name;\n      for(int j = 0 ; j < n_button ; j++){\n\tP3 tmp;\n\tcin >> tmp.f.f.f >> tmp.f.f.s >> tmp.f.s.f >> tmp.f.s.s >> tmp.s;\n\tlink.push_back(tmp);\n      }\n      page.insert(make_pair(page_name, link));\n    }\n     \n    int n_op, x, y;\n    string op;\n    vector<string> history;\n    history.push_back(now);\n    int n_now = 0;\n    cin >> n_op;\n    cin.ignore();\n    while(n_op--){\n      getline(cin, op);\n       \n      if(op[0] == 'c'){ // click\n\tstring tmp1=\"\", tmp2=\"\";\n\tint i;\n\tfor(i = 6 ; op[i] != ' ' ; i++) tmp1 += op[i];\n\tfor( ; i < op.size() ; i++) tmp2 += op[i];\n     \n\tx = atoi(tmp1.c_str());\n\ty = atoi(tmp2.c_str());\n     \n\tfor(i = 0 ; i < page[now].size() ; i++){\n\t  if((page[now][i].f.f.f <= x && x <= page[now][i].f.s.f) &&\n\t     (page[now][i].f.f.s <= y && y <= page[now][i].f.s.s)){\n\t    now = page[now][i].s;\n\t    \n\t    for(int i = history.size()-1 ; i > n_now ; i--){\n\t      history.pop_back();\n\t    }\n\t    history.push_back(now);\n\t    n_now++;\n\t  }\n\t}\n      } // click end\n      \n      if(op == \"show\") cout << history[n_now] << endl;\n      if(op == \"back\"){\n\tif(n_now == 0) continue;\n\tn_now--;\n      }\n      if(op == \"forward\"){\n\tif(n_now == history.size()-1) continue;\n\tn_now++;\n      }\n    }\n    page.clear();\n    history.clear();\n    link.clear();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<algorithm>\n#include<iostream>\n#include<vector>\n#include<climits>\n#include<cfloat>\n\nusing namespace std;\n\nstruct point{\n  int x, y;\n};\n\nstruct button{\n  point ld,ru;\n  string name;\n};\n\nstruct page{\n  string name;\n  vector<button>btn;   \n}; \n\nint m,now;\nvector<page> a;\npage nowpage;\nstring buf[10001];\n\nvoid func(void){\n  for(int i=0;i<a.size();i++){\n    if(buf[now]==a[i].name){\n      nowpage=a[i];\n      return ;\n    }\n  }\n}\n\nvoid click(int c,int d){\n  \n  for(int i=0;i<nowpage.btn.size();i++){\n    if(nowpage.btn[i].ld.x <=c && nowpage.btn[i].ld.y <=d &&\n       nowpage.btn[i].ru.x >=c && nowpage.btn[i].ru.y >=d){\n      buf[++now]=nowpage.btn[i].name;\n      fill(buf+now+1,buf+10001,\"\");\n      return ;\n    }\n  }\n}\n\n\nint main(void){\n  int n;\n  int w,h,b;\n  point l,r;\n  page in;\n  button tmp;\n\n  while(cin >> n,n){\n  \n    a.clear();\n    fill(buf,buf+10001,\"\");\n\n    cin >> w >> h;\n    \n    for(int j=0;j<n;j++){\n      cin >> in.name >> b;    \n      \n      for(int i=0;i<b;i++){\n\tcin >> tmp.ld.x >> tmp.ld.y >> tmp.ru.x >> tmp.ru.y >> tmp.name;\n\tin.btn.push_back(tmp);\n      }\n      a.push_back(in);\n    }\n\n    now=0;\n    buf[0]=a[0].name;\n    nowpage=a[0];\n\n    cin >> m;\n\n    while(m--){\n      string s;\n      cin >> s;\n      if(s==\"click\"){\n\tint c,d;\n\tcin >> c >> d;\n\tclick(c,d);\n      }\n      else if(s==\"back\" && now>0)now--;\n      else if(s==\"forward\" && buf[now+1]!=\"\")now++;\n      else if(s==\"show\")cout << buf[now] << endl;\n\n      func();\n    }\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<fstream>\n#include<string>\n#include<vector>\n#include<string.h>\nusing namespace std;\nstruct myLink {\n\tstring paname,liname;\n\tint x1,x2,y1,y2;\n};\n\nint main(){\n\t//ifstream cin(\"input.txt\");\n\t//ofstream cout(\"output.txt\");\n\tfor(int n;cin>>n&&n;){\n\t\tmyLink li[10001];\n\t\tint w,h;cin>>w>>h;\n\t\tint pos=0,num;\n\t\tstring name,s;\n\t\tfor(int i=0;i<n;i++,pos+=num){\n\t\t\tcin>>name>>num ;\n\t\t\tfor(int j=pos;j-pos<num;j++){\n\t\t\t\tcin>>li[j].x1>>li[j].y1>>li[j].x2>>li[j].y2>>li[j].liname;\n\t\t\t\tli[j].paname=name ;\n\t\t\t}\n\t\t}\n\t\tstring  buf[1001]={li[0].paname};\n\t\tint point=0,m;\n\t\tcin>>m;\n\t\twhile(m--){\n\t\t\tcin>>s;\n\t\t\tif(s[0]=='c'){\n\t\t\t\tint x,y;cin>>x>>y;\n\t\t\t\tfor(int j=0;j<pos;j++){\n\t\t\t\t\tif(li[j].paname==buf[point]&& li[j].x1<=x\n\t\t\t\t\t\t&&x<=li[j].x2&&li[j].y1<=y&&y<=li[j].y2)   \n\t\t\t\t\t{\n\t\t\t\t\t\tpoint++;\n\t\t\t\t\t\tbuf[point]=li[j].liname;\n\t\t\t\t\t\tfor(int k=point+1;k<1000;k++)\n\t\t\t\t\t\t   buf[k]=\"\";\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(s[0]=='s')\n\t\t\t\t\tcout<<buf[point]<<\"\\n\";\n\t\t\t\t\n\t\t\telse if(s[0]=='b'&&point>=1)\n\t\t\t\t\tpoint--;\n\t\t\t\t\n\t\t\telse if(s[0]=='f'&&buf[point+1]!=\"\")\n\t\t\t\t\tpoint++;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<map>\nusing namespace std;\n#define inRange(x,a,b) (a <= x && x <= b)\n\nstruct button{\n    int a[4];\n    string to;\n};\n\nint main(){\n    int n;\n    while(cin >> n, n){\n        int w, h;\n        cin >> w >> h;\n\n        map<int, string> iton;\n        map<string, int> ntoi;\n        vector<button> v[n];\n        for(int i = 0; i < n; i++){\n            string name;\n            int b;\n\n            cin >> name >> b;\n\n            ntoi[name] = i;\n            iton[i] = name;\n\n            while(b-- > 0){\n                button x;\n                for(int j = 0; j < 4; j++)  cin >> x.a[j];\n                cin >> x.to;\n                v[i].push_back(x);\n            }\n        }\n\n        int m;\n        cin >> m;\n\n        vector<int> buf;\n        buf.push_back(0);\n        vector<int>::iterator it = buf.begin();\n\n        string op;\n        while(m-- > 0){\n            cin >> op;\n            if(op == \"show\"){\n                cout << iton[*it] << endl;\n            }else if(op == \"back\"){\n                if(it != buf.begin())   it--;\n            }else if(op == \"forward\"){\n                it++;\n                if(it == buf.end()) it--;\n            }else if(op == \"click\"){\n                cin >> w >> h;\n                for(button b : v[*it]){\n                    if(inRange(w, b.a[0], b.a[2]) && inRange(h, b.a[1], b.a[3])){\n                        it++;\n                        buf.erase(it, buf.end());\n                        buf.push_back(ntoi[b.to]);\n                        it = --buf.end();\n                    }\n                }\n            }\n        }\n\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <map>\n#include <vector>\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<P,P> PP;\nmap<string,int> m;\nmap<int,string> m2;\n\nclass page{\npublic:\n  PP p;\n  int n;\n  page(PP p=PP(P(0,0),P(0,0)), int n=0):p(p),n(n){}\n};\n\nint main(){\n  int n;\n  while(cin >> n && n){\n    int h,w,aa=0;\n    vector<page> v[100];\n    cin >> h >> w;\n    for(int i=0;i<n;i++){\n      string str;\n      int a;\n      cin >> str >> a;\n      if(m.find(str) == m.end()){\n        m[str] = aa;\n        m2[aa++] = str;\n      }\n      for(int j=0;j<a;j++){\n        PP p;\n        cin >> p.first.first >> p.first.second >> p.second.first >> p.second.second >> str;\n        if(m.find(str) == m.end()){\n          m[str] = aa;\n          m2[aa++] = str;\n        }\n        v[i].push_back(page(p,m[str]));\n      }\n    }\n\n    int n2, curr=0;\n    vector<int> v2;\n    v2.push_back(0);\n    cin >> n2;\n    for(int i=0;i<n2;i++){\n      string str;\n      cin >> str;\n      if(str == \"click\"){\n        int x,y;\n        cin >> x >> y;\n        int now = v2[curr];\n        for(int j=0;j<v[now].size();j++){\n          if(v[now][j].p.first.first <= x && x <= v[now][j].p.second.first && v[now][j].p.first.second <= y && y <= v[now][j].p.second.second){\n            curr++;\n            if(curr == v2.size()) v2.push_back(v[now][j].n);\n            else v2[curr] = v[now][j].n;\n            break;\n          }\n        }\n      } else if(str == \"back\") curr = (curr <= 0) ? curr : curr-1;\n      else if(str == \"forward\") curr = (curr >= v2.size()-1) ? curr : curr+1;\n      else cout << m2[v2[curr]] << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<string>\n#include<vector>\n#include<map>\nusing namespace std;\nchar in[110];\nvector<int>x1[110];\nvector<int>y1[110];\nvector<int>x2[110];\nvector<int>y2[110];\nvector<string>na[110];\nstring name[110];\nint buf[11000];\nint main(){\n\tint a;\n\twhile(scanf(\"%d\",&a),a){\n\t\tint h,w;scanf(\"%d%d\",&h,&w);\n\t\tfor(int i=0;i<110;i++){\n\t\t\tx1[i].clear();\n\t\t\tx2[i].clear();\n\t\t\ty1[i].clear();\n\t\t\ty2[i].clear();\n\t\t\tna[i].clear();\n\t\t}\n\t\tfor(int i=0;i<a;i++){\n\t\t\tint c;scanf(\"%s%d\",in,&c);\n\t\t\tname[i]=in;\n\t\t\tfor(int j=0;j<c;j++){\n\t\t\t\tint p,q,r,s;\n\t\t\t\tscanf(\"%d%d%d%d%s\",&p,&q,&r,&s,in);\n\t\t\t\tstring tmp=in;\n\t\t\t\tx1[i].push_back(p);x2[i].push_back(r);\n\t\t\t\ty1[i].push_back(q);y2[i].push_back(s);\n\t\t\t\tna[i].push_back(tmp);\n\t\t\t}\n\t\t}\n\t\tint at=0;\n\t\tfor(int i=0;i<11000;i++)buf[i]=-1;\n\t\tbuf[0]=0;\n\t\tint b;scanf(\"%d\",&b);\n\t\twhile(b--){\n\t\t\tscanf(\"%s\",in);\n\t\t\tif(in[0]=='s'){\n\t\t\t\tprintf(\"%s\\n\",name[buf[at]].c_str());\n\t\t\t}\n\t\t\tif(in[0]=='b'){\n\t\t\t\tat=max(0,at-1);\n\t\t\t}\n\t\t\tif(in[0]=='f'){\n\t\t\t\tif(~buf[at+1])at++;\n\t\t\t}\n\t\t\tif(in[0]=='c'){\n\t\t\t\tint to=-1;\n\t\t\t\tint x,y;scanf(\"%d%d\",&x,&y);\n\t\t\t\tfor(int i=0;i<x1[buf[at]].size();i++){\n\t\t\t\t\tif(x1[buf[at]][i]<=x&&x<=x2[buf[at]][i]&&y1[buf[at]][i]<=y&&y<=y2[buf[at]][i]){\n\t\t\t\t\t\tfor(int j=0;j<a;j++)if(na[buf[at]][i]==name[j])to=j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(~to){\n\t\t\t\t\tbuf[++at]=to;\n\t\t\t\t\tfor(int i=at+1;i<110;i++)buf[i]=-1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <deque>\n#include <map>\nusing namespace std;\ntypedef struct{int sx, sy, ex, ey; string to;} LINK;\t//ボタンの左上・右下座標、リンク先のページ名\ntypedef struct{string name; int n; LINK btn[100];} PAGE;\t//ページ名、ページ上にあるボタンの数・その一覧\nint main()\n{\n\tint n, o, W, H;\t//ページの数、命令の数、ページの幅・高さ\n\tint i, j, x, y, cur, t, m;\t//ループ用変数、\"click x y\"のx,y、、一時的な、履歴の長さ\n\tstring op;\t//命令の名前\n\tPAGE pg[100];\n\tLINK tmp;\n\tmap<string, int> tbl;\n\twhile (cin >> n, n)\n\t{\n\t\tdeque<string> his;\t//ページの履歴（pg[i]のiを代入）\n\t\tdeque<string>::iterator itr;\n\t\tcin >> W >> H;\n\t\tfor (i = 0; i < n; i++)\n\t\t{\n\t\t\tcin >> pg[i].name >> pg[i].n;\n\t\t\ttbl.insert( map<string, int>::value_type(pg[i].name, i) );\n\t\t\tfor (j = 0; j < pg[i].n; j++)\n\t\t\t{\n\t\t\t\tcin >> tmp.sx >> tmp.sy >> tmp.ex >> tmp.ey >> tmp.to;\n\t\t\t\tpg[i].btn[j] = tmp;\n\t\t\t}\n\t\t}\n\t\tcin >> o;\n\t\this.push_back(pg[0].name);\n\t\tcur = 0;\n\t\tm = 1;\n\t\tfor (i = 0; i < o; i++)\n\t\t{\n\t\t\tcin >> op;\n\t\t\tif (op == \"click\")\n\t\t\t{\n\t\t\t\tcin >> x >> y;\n\t\t\t\tt = tbl[his.at(cur)];\n\t\t\t\tfor (j = 0; j < pg[t].n; j++)\n\t\t\t\t{\n\t\t\t\t\tif (pg[t].btn[j].sx <= x && x <= pg[t].btn[j].ex && pg[t].btn[j].sy <= y && y <= pg[t].btn[j].ey)\n\t\t\t\t\t{\n\t\t\t\t\t\this.push_back(pg[t].btn[j].to);\n\t\t\t\t\t\tcur++;\n\t\t\t\t\t\tm++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tt = m;\n\t\t\t\tfor (j = cur+1; j < t; j++)\n\t\t\t\t{\n\t\t\t\t\this.pop_back();\n\t\t\t\t\tm--;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (op == \"back\")\n\t\t\t{\n\t\t\t\tif (cur > 0)\n\t\t\t\t\tcur--;\n\t\t\t}\n\t\t\telse if (op == \"forward\")\n\t\t\t{\n\t\t\t\tif (cur < m)\n\t\t\t\t\tcur++;\n\t\t\t}\n\t\t\telse if (op == \"show\")\n\t\t\t{\n\t\t\t\tcout << his.at(cur) << endl;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int, int> pii;\n\ntypedef struct button{\n  pii s, e;\n  string link;\n}button;\n\ntypedef struct window{\n  string name;\n  vector<button> b;\n}window;\n\nbool range(pii s, pii e, int w, int h){\n  return s.first <= w and w <= e.first and\n    s.second <= h and h <= e.second;\n}\n\nint main(){\n  int n, m, l, W, H;\n  while(std::cin >> n, n){\n    vector<window> vw(n);\n    map<string, int> next;\n    std::cin >> W >> H;\n    for (int i = 0; i < n; i++) {\n      std::cin >> vw[i].name >> l;\n      next[vw[i].name] = i;\n      for (int j = 0; j < l; j++) {\n        button tmp;\n        std::cin >> tmp.s.first >> tmp.s.second\n                 >> tmp.e.first >> tmp.e.second >> tmp.link;\n        vw[i].b.push_back(tmp);\n      }\n    }\n    std::cin >> m;\n    string s;\n    vector<string> buffer;\n    buffer.push_back(vw[0].name);\n    int pos = 0;\n    for (int i = 0; i < m; i++) {\n      std::cin >> s;\n      if(s == \"click\"){\n        int w, h;\n        std::cin >> w >> h;\n        int win = next[buffer[pos]];\n        for (int j = 0; j < vw[win].b.size(); j++) {\n          if(range(vw[win].b[j].s, vw[win].b[j].e,\n                   w, h)){\n            if(pos + 1 < buffer.size())\n              buffer.erase(buffer.begin() + pos + 1, buffer.end());\n            buffer.push_back(vw[win].b[j].link);\n            pos++;\n          }\n        }\n      }else if(s == \"show\"){\n        std::cout << vw[next[buffer[pos]]].name << std::endl;\n      }else if(s == \"back\"){\n        pos = max(0, (int)(pos - 1));\n      }else if(s == \"forward\"){\n        pos = min((int)(buffer.size() - 1), pos + 1);\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "Haskell",
    "code": "import Control.Applicative\nimport Control.Monad\nimport Data.List\nimport Data.Map.Strict (Map, (!))\nimport qualified Data.Map.Strict as M\n\nmain :: IO ()\nmain = do\n  n <- readLn\n  unless (n == 0) $ do\n    solve n\n    main\n\nsolve :: Int -> IO ()\nsolve n = do\n  getLine\n  (s, ls) <- getpi\n  let ibf = initBuf s\n  let idb = M.insert s ls M.empty\n  db <- foldM (\\m _ -> do\n                  (s, ls) <- getpi\n                  return $ M.insert s ls m\n              ) idb [1..n-1]\n  nop <- readLn\n  foldM_ (\\b _ -> do\n             cs <- words <$> getLine\n             case cs of\n              [\"show\"] -> do\n                putStrLn $ showBuf b\n                return b\n              [\"back\"] -> do\n                case backBuf b of\n                 Just b' -> return b'\n                 Nothing -> return b\n              [\"forward\"] -> do\n                case forwardBuf b of\n                 Just b' -> return b'\n                 Nothing -> return b\n              [\"click\", scx, scy] -> do\n                let cx = read scx\n                    cy = read scy\n                    cp = showBuf b\n                case find (\\(x1, y1, x2, y2, _) -> x1 <= cx && cx <= x2 && y1 <= cy && cy <= y2) (db ! cp) of\n                 Just (_, _, _, _, np) -> return $ addBuf b np\n                 Nothing -> return b\n              _ -> return b\n         ) ibf [1..nop]\n\ngetpi :: IO (String, [(Int, Int, Int, Int, String)])\ngetpi = do\n  [np, snbt] <- words <$> getLine\n  let nbt = read snbt\n  lip <- replicateM nbt $ do\n    [sx1, sy1, sx2, sy2, nlp] <- words <$> getLine\n    let x1 = read sx1\n        y1 = read sy1\n        x2 = read sx2\n        y2 = read sy2\n    return (x1, y1, x2, y2, nlp)\n  return (np, lip)\n\ntype Buf = ([String], [String])\n\ninitBuf :: String -> Buf\ninitBuf s = ([s], [])\n\naddBuf :: Buf -> String -> Buf\naddBuf (as, _) s = (s:as, [])\n\nforwardBuf :: Buf -> Maybe Buf\nforwardBuf (_,[]) = Nothing\nforwardBuf (as, b:bs) = Just (b:as, bs)\n\nbackBuf :: Buf -> Maybe Buf\nbackBuf ([_],_) = Nothing\nbackBuf (a:as, bs) = Just (as, a:bs)\n\nshowBuf :: Buf -> String\nshowBuf (a:_, _) = a\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#define BUF_SIZE 100000\n\n\nint main() {\n  char command[][10] = {\"click\", \"back\", \"forward\", \"show\"};\n\n  int n, m, W, H;\n  int i, j, k, l;\n  int x, y;\n  char str[10];\n\n  int buf[BUF_SIZE], p;\n\n  struct {\n    char name[21];\n    int bi;\n    struct {\n      int x1, y1, x2, y2;\n      char link[21];\n    } button[100];\n\n  } page[100];\n\n  while(1) {\n    scanf(\"%d\", &n);\n    if(n == 0) break;\n    scanf(\"%d %d\", &W, &H);\n    for(i = 0; i < n; i++) {\n      scanf(\"%s %d\", page[i].name, &page[i].bi);\n      for(j = 0; j < page[i].bi; j++) {\n\tscanf(\"%d %d %d %d %s\",\n\t      &page[i].button[j].x1,\n\t      &page[i].button[j].y1,\n\t      &page[i].button[j].x2,\n\t      &page[i].button[j].y2,\n\t      page[i].button[j].link\n\t      );\n      }\n    }\n\n    for(i = 0; i < BUF_SIZE; i++) {\n      buf[i] = -1;\n    }\n    buf[0] = 0;\n    p = 0;\n\n    scanf(\"%d\", &m);\n    for(i = 0; i < m; i++) {\n      scanf(\"%s\", str);\n      for(j = 0; j < 4; j++) {\n\tif(strcmp(str, command[j]) == 0) break;\n      }\n      switch(j) {\n      case 0:\n\tscanf(\"%d %d\", &x, &y);\n\tfor(j = 0; j < page[p].bi; j++) {\n\t  if(x >= page[p].button[j].x1 &&\n\t     x <= page[p].button[j].x2 &&\n\t     y >= page[p].button[j].y1 &&\n\t     y <= page[p].button[j].y2 ) {\n\t    for(k = 0; k < n; k++) {\n\t      if(strcmp(page[p].button[j].link, page[k].name) == 0) {\n\t\tp++;\n\t\tbuf[p] = k;\n\t\tfor(l = p+1; l < BUF_SIZE; l++) {\n\t\t  buf[l] = -1;\n\t\t}\n\t\tbreak;\n\t      }\n\t    }\n\t    break;\n\t  }\n\t}\n\tbreak;\n      case 1:\n\tif(p != 0) p--;\n\tbreak;\n      case 2:\n\tif(p != BUF_SIZE && buf[p+1] != -1) p++;\n\tbreak;\n      case 3:\n\tprintf(\"%s\\n\", page[buf[p]].name);\n\tbreak;\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 1054: Distorted Love\n// 2017.9.28 bal4u@uu\n\n#include <stdio.h>\n#include <string.h>\n\ntypedef struct { int x1, y1, x2, y2; char nm[25]; int pag; } BTN;\ntypedef struct { char nm[25]; int id, next, prev; int bn; BTN btn[102]; } PAG;\nPAG pag[200]; int n;\n\nint now, h, w;\n\nint whatPage(char *nm)\n{\n\tint i;\n\tfor (i = 0; i < n; i++) if (strcmp(nm, pag[i].nm) == 0) return i;\n\twhile (1);   // panic\n\treturn -1;\n}\n\nint main()\n{\n\tint m, i, j, k, x, y;\n\tPAG *pp, *new;\n\tchar cmd[20];\n\n\twhile (scanf(\"%d\", &n) && n > 0) {\n\t\tscanf(\"%d%d\", &w, &h);\n\t\tfor (pp = pag, i = 0; i < n; i++, pp++) {\n\t\t\tscanf(\"%s%d\", pp->nm, &k), pp->bn = k, pp->id = i, pp->next = pp->prev = -1;\n\t\t\tfor (j = 0; j < k; j++)\n\t\t\t\tscanf(\"%d%d%d%d%s\", &pp->btn[j].x1, &pp->btn[j].y1,\n\t\t\t\t\t  &pp->btn[j].x2, &pp->btn[j].y2, &pp->btn[j].nm);\n\t\t}\n\t\tfor (pp = pag, i = 0; i < n; i++, pp++)\n\t\t\tfor (j = 0; j < pp->bn; j++) pp->btn[j].pag = whatPage(pp->btn[j].nm);\n\n\t\tnow = 0;\n\t\tscanf(\"%d\", &m);\n\t\twhile (m-- > 0) {\n\t\t\tscanf(\"%s\", cmd);\n\t\t\tif (*cmd == 'b') {\n\t\t\t\tpp = pag + now;\n\t\t\t\tif (pp->prev >= 0) now = pag[pp->prev].id;\n\t\t\t} else if (*cmd == 'f') {\n\t\t\t\tpp = pag + now;\n\t\t\t\tif (pp->next >= 0) now = pag[pp->next].id;\n\t\t\t} else if (*cmd == 's') puts(pag[now].nm);\n\t\t\telse {\t\t// click\n\t\t\t\tscanf(\"%d%d\", &x, &y);\n\t\t\t\tpp = pag + now;\n\t\t\t\tfor (j = 0; j < pp->bn; j++) {\n\t\t\t\t\tif (pp->btn[j].x1 <= x && x <= pp->btn[j].x2 &&\n\t\t\t\t\t\tpp->btn[j].y1 <= y && y <= pp->btn[j].y2) {\n\t\t\t\t\t\tnew = pag + pp->btn[j].pag;\n\t\t\t\t\t\tnew->prev = pp->id, new->next = -1;\n\t\t\t\t\t\tpp->next = new->id;\n\t\t\t\t\t\tnow = new->id;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#define BUF_SIZE 100000\n\n\nint main() {\n  char command[][10] = {\"click\", \"back\", \"forward\", \"show\"};\n\n  int n, m, W, H;\n  int i, j, k, l, o;\n  int x, y;\n  char str[10];\n\n  int buf[BUF_SIZE], p;\n\n  struct {\n    char name[21];\n    int bi;\n    struct {\n      int x1, y1, x2, y2;\n      char link[21];\n    } button[100];\n\n  } page[100];\n\n  while(1) {\n    scanf(\"%d\", &n);\n    if(n == 0) break;\n    scanf(\"%d %d\", &W, &H);\n    for(i = 0; i < n; i++) {\n      scanf(\"%s %d\", page[i].name, &page[i].bi);\n      for(j = 0; j < page[i].bi; j++) {\n\tscanf(\"%d %d %d %d %s\",\n\t      &page[i].button[j].x1,\n\t      &page[i].button[j].y1,\n\t      &page[i].button[j].x2,\n\t      &page[i].button[j].y2,\n\t      page[i].button[j].link\n\t      );\n      }\n    }\n\n    for(i = 0; i < BUF_SIZE; i++) {\n      buf[i] = -1;\n    }\n    buf[0] = 0;\n    p = 0;\n\n    scanf(\"%d\", &m);\n    for(i = 0; i < m; i++) {\n      scanf(\"%s\", str);\n      for(o = 0; o < 4; o++) {\n\tif(strcmp(str, command[o]) == 0) break;\n      }\n      switch(o) {\n      case 0:\n\tscanf(\"%d %d\", &x, &y);\n\tfor(j = 0; j < page[p].bi; j++) {\n\t  if(x >= page[p].button[j].x1 &&\n\t     x <= page[p].button[j].x2 &&\n\t     y >= page[p].button[j].y1 &&\n\t     y <= page[p].button[j].y2 ) {\n\t    for(k = 0; k < n; k++) {\n\t      if(strcmp(page[p].button[j].link, page[k].name) == 0) {\n\t\tp++;\n\t\tbuf[p] = k;\n\t\tfor(l = p+1; l < BUF_SIZE; l++) {\n\t\t  buf[l] = -1;\n\t\t}\n\t\tbreak;\n\t      }\n\t    }\n\t    break;\n\t  }\n\t}\n\tbreak;\n      case 1:\n\tif(p != 0) p--;\n\tbreak;\n      case 2:\n\tif(p != BUF_SIZE - 1 && buf[p+1] != -1) p++;\n\tbreak;\n      case 3:\n\tprintf(\"%s\\n\", page[buf[p]].name);\n\tbreak;\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\ntypedef struct {\n\tint sx,sy,dx,dy;\n\tchar linkto[24];\n} button_t;\n\ntypedef struct {\n\tchar name[24];\n\tint button_num;\n\tbutton_t buttons[100];\n} page_t;\n\nint page_num;\npage_t pages[100];\n\nint w,h;\n\nint buffer_num;\nint buffer_pos;\nint buffer[10000];\n\nint main(void) {\n\tint i,j,k;\n\tint sousa_num;\n\tchar command[8];\n\tint x,y;\n\twhile(1) {\n\t\tscanf(\"%d\",&page_num);\n\t\tif(page_num==0)break;\n\t\tscanf(\"%d%d\",&w,&h);\n\t\tfor(i=0;i<page_num;i++) {\n\t\t\tscanf(\"%s%d\",pages[i].name,&pages[i].button_num);\n\t\t\tfor(j=0;j<pages[i].button_num;j++) {\n\t\t\t\tscanf(\"%d%d%d%d%s\",\n\t\t\t\t\t&pages[i].buttons[j].sx,\n\t\t\t\t\t&pages[i].buttons[j].sy,\n\t\t\t\t\t&pages[i].buttons[j].dx,\n\t\t\t\t\t&pages[i].buttons[j].dy,\n\t\t\t\t\tpages[i].buttons[j].linkto);\n\t\t\t}\n\t\t}\n\t\tbuffer_num=1;\n\t\tbuffer_pos=0;\n\t\tbuffer[0]=0;\n\t\tscanf(\"%d\",&sousa_num);\n\t\tfor(i=0;i<sousa_num;i++) {\n\t\t\tscanf(\"%s\",command);\n\t\t\tswitch(command[0]) {\n\t\t\t\tcase 'c':\n\t\t\t\t\tscanf(\"%d%d\",&x,&y);\n\t\t\t\t\tfor(j=0;j<pages[buffer[buffer_pos]].button_num;j++) {\n\t\t\t\t\t\tif(pages[buffer[buffer_pos]].buttons[j].sx<=x && \n\t\t\t\t\t\t\tpages[buffer[buffer_pos]].buttons[j].dx>=x && \n\t\t\t\t\t\t\tpages[buffer[buffer_pos]].buttons[j].sy<=y && \n\t\t\t\t\t\t\tpages[buffer[buffer_pos]].buttons[j].dy>=y)break;\n\t\t\t\t\t}\n\t\t\t\t\tif(j<pages[buffer[buffer_pos]].button_num) {\n\t\t\t\t\t\tfor(k=0;k<page_num;k++) {\n\t\t\t\t\t\t\tif(strcmp(pages[buffer[buffer_pos]].buttons[j].linkto,\n\t\t\t\t\t\t\t\tpages[k].name)==0)break;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbuffer_pos++;\n\t\t\t\t\t\tbuffer_num=buffer_pos+1;\n\t\t\t\t\t\tbuffer[buffer_pos]=k;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'b':\n\t\t\t\t\tif(buffer_pos>0)buffer_pos--;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'f':\n\t\t\t\t\tif(buffer_pos+1<buffer_num)buffer_pos++;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 's':\n\t\t\t\t\tputs(pages[buffer[buffer_pos]].name);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\nstruct page{\n  char name[21];\n  int a,bob,boe;\n};\nstruct botan{\n  char name[101];\n  int lux,luy,rdx,rdy;\n};\nmain(){\n  int n,m,i,j,k,W,H,a,c,bo,cx,cy;\n  char com[8];\n  struct botan b[100];\n  struct page p[100];\n  while(1){\n    bo=0;\n    scanf(\"%d\",&n);\n    if(n==0) break;\n    scanf(\"%d%d\",&W,&H);\n    for(i=0;i<n;i++){\n      scanf(\"%s%d\",p[i].name,&c);\n      p[i].bob=bo;\n      for(j=0;j<c;j++){\n\tscanf(\"%d%d%d%d%s\",&b[bo].lux,&b[bo].luy,&b[bo].rdx,&b[bo].rdy,b[bo].name);\n\tbo++;\n      }\n      bo--;\n      p[i].boe=bo;\n      bo++;\n    }\n\n    p[0].a=0;\n    a=0;\n    scanf(\"%d\",&m);\n    for(i=0;i<m;i++){\n      scanf(\"%s\",com);\n      if(com=='back'&&a>0) a--;\n      else if(com=='forward'&&a<n-1) a++;\n      else if(com=='click'){\n\t\n\tscanf(\"%d%d\",&cx,&cy);\n\tfor(j=p[a].bob;j<=p[a].boe;j++){\n\t  if((b[j].lux<=cx<=b[j].rdx)&&(b[j].luy<=cy<=b[j].rdy)){\n\t    for(k=0;k<n;k++){\n\t      if(p[k].name==b[j].name){\n\t\ta++;\n\t\tp[k].a=a;\n\t      }\n\t    }\n\t  }\n\t}\n      }\n      else if(com=='show'){\n\tfor(j=0;j<n;j++){\n\t  if(a==p[j].a) printf(\"%s\\n\",p[j].name);\n\t}\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nstruct page{\n  char name[21];\n  int a,bob,boe;\n};\nstruct botan{\n  char name[21];\n  int lux,luy,rdx,rdy;\n};\n\nmain(){\n  int n,m,i,j,k,W,H,a,c,bo,cx,cy,jud=0,where=0,namec=0,l;\n  char com[8];\n  struct botan b[9900];\n  struct page p[100];\n  while(1){\n    bo=0;\n    scanf(\"%d\",&n);\n    if(n==0) break;\n    scanf(\"%d%d\",&W,&H);\n    for(i=0;i<n;i++){\n      scanf(\"%s%d\",p[i].name,&c);\n      p[i].a=0;\n      p[i].bob=bo;\n      for(j=0;j<c;j++){\n\tscanf(\"%d%d%d%d%s\",&b[bo].lux,&b[bo].luy,&b[bo].rdx,&b[bo].rdy,b[bo].name);\n\tbo++;\n      }\n      p[i].boe=bo;\n    }\n\n    p[0].a=0;\n    a=0;\n    where=0;\n    scanf(\"%d\",&m);\n    for(i=0;i<m;i++){\n      scanf(\"%s\",com);\n      /*       printf(\"mae %d\\n\",a); */\n      if(com[0]=='b'&&a>0){ \n\ta--;\n\tfor(j=0;j<n;j++){\n\t  if(a==p[j].a){\n\t    where=j;\n\t    break;\n\t  }\n\t}\n      }\n      else if(com[0]=='f'&&a<n-1){ \n\ta++;\n\tfor(j=0;j<n;j++){\n\t  if(a==p[j].a){\n\t    where=j;\n\t    break;\n\t  }\n\t}\n      }\n      else if(com[0]=='c'){\n\tscanf(\"%d%d\",&cx,&cy);\n\tfor(j=p[where].bob;j<p[where].boe;j++){\n\t  jud=0;\n\t  /*\t  printf(\"+\\n\"); */\n\t  if(b[j].lux<=cx&&cx<=b[j].rdx&&b[j].luy<=cy&&cy<=b[j].rdy){\n\t    namec=0;\t    \n\t    for(k=0;k<n;k++){\n\t      for(l=0;l<21;l++){\t    \n\t\tif(p[k].name[l]==b[j].name[l]) namec++;\n\t\tif(p[k].name[l]=='\\0'||b[j].name[l]=='\\0'){\n\t\t  l++;\n\t\t  break;\n\t\t}\n\t      }\n\t      /*printf(\"l=%d namec=%d\\n\",l,namec);*/\n\t      if(l==namec){\n\t\tp[k].a=++a;\n\t\tjud=1;\n\t\twhere=k;\n\t\t/*printf(\"cy:%d,luy=%d,rdy=%d j=%d\\n\",cy,b[j].luy,b[j].rdy,j);*/\n\t\tbreak;\n\t      }\n\t    }\t\t\n\t  }\n\t}\n\tif(jud==1) break;\n      }\n      else if(com[0]=='s'){\n\tfor(j=0;j<n;j++){\n\t  if(a==p[j].a) {\n\t    printf(\"%s\\n\",p[where].name);\n\t    break;\n\t  }\n\t  /* else printf(\"a=%d p[j].a=%d\\n\",a,p[j].a);*/\n\t}\n      }\n      /*printf(\"ato\\n);*/\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nstruct page{\n  char name[210];\n  int a,bob,boe;\n};\nstruct botan{\n  char name[210];\n  int lux,luy,rdx,rdy;\n};\n\nmain(){\n  int n,m,i,j,k,W,H,a,c,bo,cx,cy,jud=0,where=0,namec=0,l;\n  char com[8];\n  struct botan b[101000];\n  struct page p[1010];\n  while(1){\n    bo=0;\n    scanf(\"%d\",&n);\n    if(n==0) break;\n    scanf(\"%d%d\",&W,&H);\n    for(i=0;i<n;i++){\n      scanf(\"%s%d\",p[i].name,&c);\n      p[i].a=0;\n      p[i].bob=bo;\n      for(j=0;j<c;j++){\n\tscanf(\"%d%d%d%d%s\",&b[bo].lux,&b[bo].luy,&b[bo].rdx,&b[bo].rdy,b[bo].name);\n\tbo++;\n      }\n      p[i].boe=bo;\n    }\n\n    p[0].a=0;\n    a=0;\n    where=0;\n    scanf(\"%d\",&m);\n    for(i=0;i<m;i++){\n      scanf(\"%s\",com);\n      if(com[0]=='b'&&a>0){ \n\ta--;\n\tfor(j=0;j<n;j++){\n\t  if(a==p[j].a){\n\t    where=j;\n\t    break;\n\t  }\n\t}\n      }\n      else if(com[0]=='f'&&a<n-1){ \n\ta++;\n\tfor(j=0;j<n;j++){\n\t  if(a==p[j].a){\n\t    where=j;\n\t    break;\n\t  }\n\t}\n      }\n      else if(com[0]=='c'){\n\tscanf(\"%d%d\",&cx,&cy);\n\tfor(j=p[where].bob;j<p[where].boe;j++){\n\t  jud=0;\n\t  if(b[j].lux<=cx&&cx<=b[j].rdx&&b[j].luy<=cy&&cy<=b[j].rdy){\n\t    namec=0;\t    \n\t    for(k=0;k<n;k++){\n\t      for(l=0;l<21;l++){\t    \n\t\tif(p[k].name[l]==b[j].name[l]) namec++;\n\t\tif(p[k].name[l]=='\\0'||b[j].name[l]=='\\0'){\n\t\t  l++;\n\t\t  break;\n\t\t}\n\t      }\n\t      if(l==namec){\n\t\tp[k].a=++a;\n\t\tjud=1;\n\t\twhere=k;\n\t\tbreak;\n\t      }\n\t    }\t\t\n\t  }\n\t}\n\tif(jud==1) break;\n      }\n      else if(com[0]=='s'){\n\tfor(j=0;j<n;j++){\n\t  if(a==p[j].a) {\n\t    printf(\"%s\\n\",p[j].name);\n\t    break;\n\t  }\n\t}\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "n;\ntypedef struct{\n\tint x1,y1,x2,y2;\n\tchar link[21];\n}Btn;\ntypedef struct{\n\tchar title[21];\n\tint bn;\n\tBtn btn[100];\n}Page;\nPage page[100];\nhist[999],hidx,hmax;\nmain(){\n\tint W,H,m,i,j;\n\tchar op[9];\n\tfor(;scanf(\"%d%d%d\",&n,&W,&H)*n;){\n\t\tfor(i=n;i--;){\n\t\t\tPage*p=page+i;\n\t\t\tscanf(\"%s%d\",p->title,&p->bn);\n\t\t\tfor(j=p->bn;j--;){\n\t\t\t\tBtn*b=p->btn+j;\n\t\t\t\tscanf(\"%d%d%d%d%s\",&b->x1,&b->y1,&b->x2,&b->y2,b->link);\n\t\t\t}\n\t\t}\n\t\t*hist=n-1;\n\t\thmax=0;\n\t\thidx=0;\n\t\tscanf(\"%d\",&m);\n\t\tfor(;m--;){\n\t\t\tscanf(\"%s\",op);\n\t\t\tif(strcmp(op,\"click\")==0){\n\t\t\t\tPage*p=page+hist[hidx];\n\t\t\t\tint x,y;\n\t\t\t\tscanf(\"%d%d\",&x,&y);\n\t\t\t\tfor(i=p->bn;i--;){\n\t\t\t\t\tBtn*b=p->btn+i;\n\t\t\t\t\tif(x>=b->x1&&x<=b->x2&&y>=b->y1&&y<=b->y2){\n\t\t\t\t\t\tfor(j=n;j--;){\n\t\t\t\t\t\t\tif(strcmp(page[j].title,b->link)==0){\n\t\t\t\t\t\t\t\thist[hmax=++hidx]=j;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(strcmp(op,\"back\")==0){\n\t\t\t\tif(hidx>0)\n\t\t\t\t\thidx--;\n\t\t\t}\n\t\t\tif(strcmp(op,\"forward\")==0){\n\t\t\t\tif(hidx<hmax)\n\t\t\t\t\thidx++;\n\t\t\t}\n\t\t\tif(strcmp(op,\"show\")==0){\n\t\t\t\tputs(page[hist[hidx]].title);\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#define BUF_SIZE 100000\n\n\nint main() {\n  char command[][10] = {\"click\", \"back\", \"forward\", \"show\"};\n\n  int n, m, W, H;\n  int i, j, k, l;\n  int x, y;\n  char str[10];\n\n  int buf[BUF_SIZE], p;\n\n  struct {\n    char name[21];\n    int bi;\n    struct {\n      int x1, y1, x2, y2;\n      char link[21];\n    } button[100];\n\n  } page[100];\n\n  while(1) {\n    scanf(\"%d\", &n);\n    if(n == 0) break;\n    scanf(\"%d %d\", &W, &H);\n    for(i = 0; i < n; i++) {\n      scanf(\"%s %d\", page[i].name, &page[i].bi);\n      for(j = 0; j < page[i].bi; j++) {\n\tscanf(\"%d %d %d %d %s\",\n\t      &page[i].button[j].x1,\n\t      &page[i].button[j].y1,\n\t      &page[i].button[j].x2,\n\t      &page[i].button[j].y2,\n\t      page[i].button[j].link\n\t      );\n      }\n    }\n\n    for(i = 0; i < BUF_SIZE; i++) {\n      buf[i] = -1;\n    }\n    buf[0] = 0;\n    p = 0;\n\n    scanf(\"%d\", &m);\n    for(i = 0; i < m; i++) {\n      scanf(\"%s\", str);\n      for(j = 0; j < 4; j++) {\n\tif(strcmp(str, command[j]) == 0) break;\n      }\n      switch(j) {\n      case 0:\n\tscanf(\"%d %d\", &x, &y);\n\tfor(j = 0; j < page[p].bi; j++) {\n\t  if(x >= page[p].button[j].x1 &&\n\t     x <= page[p].button[j].x2 &&\n\t     y >= page[p].button[j].y1 &&\n\t     y <= page[p].button[j].y2 ) {\n\t    for(k = 0; k < n; k++) {\n\t      if(strcmp(page[p].button[j].link, page[k].name) == 0) {\n\t\tp++;\n\t\tbuf[p] = k;\n\t\tfor(l = p+1; l < BUF_SIZE; l++) {\n\t\t  buf[l] = -1;\n\t\t}\n\t\tbreak;\n\t      }\n\t    }\n\t    break;\n\t  }\n\t}\n\tbreak;\n      case 1:\n\tif(p != 0) p--;\n\tbreak;\n      case 2:\n\tif(p != BUF_SIZE - 1 && buf[p+1] != -1) p++;\n\tbreak;\n      case 3:\n\tprintf(\"%s\\n\", page[buf[p]].name);\n\tbreak;\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nstruct page{\n  char name[21];\n  int a,bob,boe;\n};\nstruct botan{\n  char name[21];\n  int lux,luy,rdx,rdy;\n};\n\nmain(){\n  int n,m,i,j,k,W,H,a,c,bo,cx,cy,jud=0,where=0,namec=0,l;\n  char com[8];\n  struct botan b[9900];\n  struct page p[100];\n  while(1){\n    bo=0;\n    scanf(\"%d\",&n);\n    if(n==0) break;\n    scanf(\"%d%d\",&W,&H);\n    for(i=0;i<n;i++){\n      scanf(\"%s%d\",p[i].name,&c);\n      p[i].a=0;\n      p[i].bob=bo;\n      for(j=0;j<c;j++){\n\tscanf(\"%d%d%d%d%s\",&b[bo].lux,&b[bo].luy,&b[bo].rdx,&b[bo].rdy,b[bo].name);\n\tbo++;\n      }\n      p[i].boe=bo;\n    }\n\n    p[0].a=0;\n    a=0;\n    where=0;\n    scanf(\"%d\",&m);\n    for(i=0;i<m;i++){\n      scanf(\"%s\",com);\n      if(com[0]=='b'&&a>0){ \n\ta--;\n\tfor(j=0;j<n;j++){\n\t  if(a==p[j].a){\n\t    where=j;\n\t    break;\n\t  }\n\t}\n      }\n      else if(com[0]=='f'&&a<n-1){ \n\ta++;\n\tfor(j=0;j<n;j++){\n\t  if(a==p[j].a){\n\t    where=j;\n\t    break;\n\t  }\n\t}\n      }\n      else if(com[0]=='c'){\n\tscanf(\"%d%d\",&cx,&cy);\n\tfor(j=p[where].bob;j<p[where].boe;j++){\n\t  jud=0;\n\t  if(b[j].lux<=cx&&cx<=b[j].rdx&&b[j].luy<=cy&&cy<=b[j].rdy){    \n\t    for(k=0;k<n;k++){\n\t      namec=0;\n\t      for(l=0;l<21;l++){\t    \n\t\tif(p[k].name[l]==b[j].name[l]) namec++;\n\t\tif(p[k].name[l]=='\\0'||b[j].name[l]=='\\0'){\n\t\t  l++;\n\t\t  break;\n\t\t}\n\t      }\n\t      if(l==namec){\n\t\tp[k].a=++a;\n\t\tjud=1;\n\t\twhere=k;\n\t\tbreak;\n\t      }\n\t    }\t\t\n\t  }\n\t}\n\tif(jud==1) break;\n      }\n      else if(com[0]=='s'){\n\tfor(j=0;j<n;j++){\n\t  if(a==p[j].a) {\n\t    printf(\"%s\\n\",p[j].name);\n\t    break;\n\t  }\n\t}\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nstruct page{\n  char name[201];\n  int a,bob,boe;\n};\nstruct botan{\n  char name[1001];\n  int lux,luy,rdx,rdy;\n};\n\nmain(){\n  int n,m,i,j,k,W,H,a,c,bo,cx,cy,jud=0,where=0;\n  char com[88];\n  struct botan b[1000];\n  struct page p[1000];\n  while(1){\n    bo=0;\n    scanf(\"%d\",&n);\n    if(n==0) break;\n    scanf(\"%d%d\",&W,&H);\n    for(i=0;i<n;i++){\n      scanf(\"%s%d\",p[i].name,&c);\n      p[i].a=0;\n      p[i].bob=bo;\n      for(j=0;j<c;j++){\n\tscanf(\"%d%d%d%d%s\",&b[bo].lux,&b[bo].luy,&b[bo].rdx,&b[bo].rdy,b[bo].name);\n\tbo++;\n      }\n      p[i].boe=bo;\n    }\n\n    p[0].a=0;\n    a=0;\n    where=0;\n    scanf(\"%d\",&m);\n    for(i=0;i<m;i++){\n      scanf(\"%s\",com);\n      if(com[0]=='b'&&a>0){ \n\ta--;\n\tfor(j=0;j<n;j++){\n\t  if(a==p[j].a){\n\t    where=j;\n\t    break;\n\t  }\n\t}\n      }\n      else if(com[0]=='f'&&a<n-1){ \n\ta++;\n\tfor(j=0;j<n;j++){\n\t  if(a==p[j].a){\n\t    where=j;\n\t    break;\n\t  }\n\t}\n      }\n      else if(com[0]=='c'){\n\tscanf(\"%d%d\",&cx,&cy);\n\tfor(j=p[where].bob;j<p[where].boe;j++){\n\t  jud=0;\n\t  if(b[j].lux<=cx&&cx<=b[j].rdx&&b[j].luy<=cy&&cy<=b[j].rdy){\n\t    for(k=0;k<n;k++){\n\t      if(p[k].name[0]==b[j].name[0]){\n\t\tp[k].a=++a;\n\t\tjud=1;\n\t\twhere=k;\n\t\tbreak;\n\t      }\n\t    }\n\t  }\n\t  if(jud==1) break;\n\t}\n      }\n      else if(com[0]=='s'){\n\tfor(j=0;j<n;j++){\n\t  if(a==p[j].a) {\n\t    printf(\"%s\\n\",p[j].name);\n\t    break;\n\t  }\n\t}\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "n;\ntypedef struct{\n\tint x1,y1,x2,y2;\n\tchar link[21];\n}Btn;\ntypedef struct{\n\tchar title[21];\n\tint bn;\n\tBtn btn[100];\n}Page;\nPage page[100];\nhist[999],hidx,hlen;\nmain(){\n\tint W,H,m,i,j;\n\tchar op[9];\n\tfor(;scanf(\"%d%d%d\",&n,&W,&H)*n;){\n\t\tfor(i=n;i--;){\n\t\t\tPage*p=page+i;\n\t\t\tscanf(\"%s%d\",p->title,&p->bn);\n\t\t\tfor(j=p->bn;j--;){\n\t\t\t\tBtn*b=p->btn+j;\n\t\t\t\tscanf(\"%d%d%d%d%s\",&b->x1,&b->y1,&b->x2,&b->y2,b->link);\n\t\t\t}\n\t\t}\n\t\t*hist=n-1;\n\t\thlen=1;\n\t\thidx=0;\n\t\tscanf(\"%d\",&m);\n\t\tfor(;m--;){\n\t\t\tscanf(\"%s\",op);\n\t\t\tif(strcmp(op,\"click\")==0){\n\t\t\t\tPage*p=page+hist[hidx];\n\t\t\t\tint x,y;\n\t\t\t\tscanf(\"%d%d\",&x,&y);\n\t\t\t\tfor(i=p->bn;i--;){\n\t\t\t\t\tBtn*b=p->btn+i;\n\t\t\t\t\tif(x>=b->x1&&x<=b->x2&&y>=b->y1&&y<=b->y2){\n\t\t\t\t\t\tfor(j=n;j--;){\n\t\t\t\t\t\t\tif(strcmp(page[j].title,b->link)==0){\n\t\t\t\t\t\t\t\thist[hlen=++hidx]=j;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(strcmp(op,\"back\")==0){\n\t\t\t\tif(hidx>0)\n\t\t\t\t\thidx--;\n\t\t\t}\n\t\t\tif(strcmp(op,\"forward\")==0){\n\t\t\t\tif(hidx+1<hlen)\n\t\t\t\t\thidx++;\n\t\t\t}\n\t\t\tif(strcmp(op,\"show\")==0){\n\t\t\t\tputs(page[hist[hidx]].title);\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#define BUF_SIZE 100000\n\n\nint main() {\n  char command[][10] = {\"click\", \"back\", \"forward\", \"show\"};\n\n  int n, m, W, H;\n  int i, j, k, l, o;\n  int x, y;\n  char str[10];\n\n  int buf[BUF_SIZE], p;\n\n  struct {\n    char name[21];\n    int bi;\n    struct {\n      int x1, y1, x2, y2;\n      char link[21];\n    } button[100];\n\n  } page[100];\n\n  while(1) {\n    scanf(\"%d\", &n);\n    if(n == 0) break;\n    scanf(\"%d %d\", &W, &H);\n    for(i = 0; i < n; i++) {\n      scanf(\"%s %d\", page[i].name, &page[i].bi);\n      for(j = 0; j < page[i].bi; j++) {\n\tscanf(\"%d %d %d %d %s\",\n\t      &page[i].button[j].x1,\n\t      &page[i].button[j].y1,\n\t      &page[i].button[j].x2,\n\t      &page[i].button[j].y2,\n\t      page[i].button[j].link\n\t      );\n      }\n    }\n\n    for(i = 0; i < BUF_SIZE; i++) {\n      buf[i] = -1;\n    }\n    buf[0] = 0;\n    p = 0;\n\n    scanf(\"%d\", &m);\n    for(i = 0; i < m; i++) {\n      scanf(\"%s\", str);\n      for(o = 0; o < 4; o++) {\n\tif(strcmp(str, command[o]) == 0) break;\n      }\n      switch(o) {\n      case 0:\n\tscanf(\"%d %d\", &x, &y);\n\tif(x < 0 || x >= W || y < 0 || y >= H) break;\n\tfor(j = 0; j < page[p].bi; j++) {\n\t  if(x >= page[p].button[j].x1 &&\n\t     x <= page[p].button[j].x2 &&\n\t     y >= page[p].button[j].y1 &&\n\t     y <= page[p].button[j].y2 ) {\n\t    for(k = 0; k < n; k++) {\n\t      if(strcmp(page[p].button[j].link, page[k].name) == 0) {\n\t\tp++;\n\t\tbuf[p] = k;\n\t\tfor(l = p+1; l < BUF_SIZE; l++) {\n\t\t  buf[l] = -1;\n\t\t}\n\t\tbreak;\n\t      }\n\t    }\n\t    break;\n\t  }\n\t}\n\tbreak;\n      case 1:\n\tif(p != 0) p--;\n\tbreak;\n      case 2:\n\tif(p != BUF_SIZE - 1 && buf[p+1] != -1) p++;\n\tbreak;\n      case 3:\n\tprintf(\"%s\\n\", page[buf[p]].name);\n\tbreak;\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n\n\nint main() {\n  char command[][10] = {\"click\", \"back\", \"forward\", \"show\"};\n\n  int n, m, W, H;\n  int i, j, k, l;\n  int x, y;\n  char str[10];\n\n  int buf[1000], p;\n\n  struct {\n    char name[21];\n    int bi;\n    struct {\n      int x1, y1, x2, y2;\n      char link[21];\n    } button[100];\n\n  } page[100];\n\n  while(1) {\n    scanf(\"%d\", &n);\n    if(n == 0) break;\n    scanf(\"%d %d\", &W, &H);\n    for(i = 0; i < n; i++) {\n      scanf(\"%s %d\", page[i].name, &page[i].bi);\n      for(j = 0; j < page[i].bi; j++) {\n\tscanf(\"%d %d %d %d %s\",\n\t      &page[i].button[j].x1,\n\t      &page[i].button[j].y1,\n\t      &page[i].button[j].x2,\n\t      &page[i].button[j].y2,\n\t      page[i].button[j].link\n\t      );\n      }\n    }\n\n    for(i = 0; i < 1000; i++) {\n      buf[i] = -1;\n    }\n    buf[0] = 0;\n    p = 0;\n\n    scanf(\"%d\", &m);\n    for(i = 0; i < m; i++) {\n      scanf(\"%s\", str);\n      for(j = 0; j < 4; j++) {\n\tif(strcmp(str, command[j]) == 0) break;\n      }\n      switch(j) {\n      case 0:\n\tscanf(\"%d %d\", &x, &y);\n\tfor(j = 0; j < page[p].bi; j++) {\n\t  if(x >= page[p].button[j].x1 &&\n\t     x <= page[p].button[j].x2 &&\n\t     y >= page[p].button[j].y1 &&\n\t     y <= page[p].button[j].y2 ) {\n\t    for(k = 0; k < n; k++) {\n\t      if(strcmp(page[p].button[j].link, page[k].name) == 0) {\n\t\tp++;\n\t\tbuf[p] = k;\n\t\tfor(l = p+1; l < 1000; l++) {\n\t\t  buf[l] = -1;\n\t\t}\n\t\tbreak;\n\t      }\n\t    }\n\t    break;\n\t  }\n\t}\n\tbreak;\n      case 1:\n\tif(p != 0) p--;\n\tbreak;\n      case 2:\n\tif(p != 1000 && buf[p+1] != -1) p++;\n\tbreak;\n      case 3:\n\tprintf(\"%s\\n\", page[buf[p]].name);\n\tbreak;\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 1054: Distorted Love\n// 2017.9.28 bal4u@uu\n\n#include <stdio.h>\n#include <string.h>\n\ntypedef struct { int x1, y1, x2, y2; char nm[25]; int pag; } BTN;\ntypedef struct { char nm[25]; int id, next, prev; int bn; BTN btn[102]; } PAG;\nPAG pag[200]; int n;\n\nint now, h, w;\n\nint whatPage(char *nm)\n{\n\tint i;\n\tfor (i = 0; i < n; i++) if (strcmp(nm, pag[i].nm) == 0) return i;\n\twhile (1);   // panic\n\treturn -1;\n}\n\nint main()\n{\n\tint m, i, j, k, x, y;\n\tPAG *pp, *new;\n\tchar cmd[20];\n\n\twhile (scanf(\"%d\", &n) && n > 0) {\n\t\tscanf(\"%d%d\", &w, &h);\n\t\tfor (pp = pag, i = 0; i < n; i++, pp++) {\n\t\t\tscanf(\"%s%d\", pp->nm, &k), pp->bn = k, pp->id = i, pp->next = pp->prev = -1;\n\t\t\tfor (j = 0; j < k; j++)\n\t\t\t\tscanf(\"%d%d%d%d%s\", &pp->btn[j].x1, &pp->btn[j].y1,\n\t\t\t\t\t  &pp->btn[j].x2, &pp->btn[j].y2, &pp->btn[j].nm);\n\t\t}\n\t\tfor (pp = pag, i = 0; i < n; i++, pp++)\n\t\t\tfor (j = 0; j < pp->bn; j++) pp->btn[j].pag = whatPage(pp->btn[j].nm);\n\n\t\tnow = 0;\n\t\tscanf(\"%d\", &m);\n\t\twhile (m-- > 0) {\n\t\t\tscanf(\"%s\", cmd);\n\t\t\tif (*cmd == 'b') {\n\t\t\t\tpp = pag + now;\n\t\t\t\tif (pp->prev >= 0) now = pag[pp->prev].id;\n\t\t\t} else if (*cmd == 'f') {\n\t\t\t\tpp = pag + now;\n\t\t\t\tif (pp->next >= 0) now = pag[pp->next].id;\n\t\t\t} else if (*cmd == 's') puts(pag[now].nm);\n\t\t\telse {\t\t// click\n\t\t\t\tscanf(\"%d%d\", &x, &y);\n\t\t\t\tpp = pag + now;\n\t\t\t\tfor (j = 0; j < pp->bn; j++) {\n\t\t\t\t\tif (pp->btn[j].x1 <= x && x <= pp->btn[j].x2 &&\n\t\t\t\t\t\tpp->btn[j].y1 <= y && y <= pp->btn[j].y2) {\n\t\t\t\t\t\tnew = pag + pp->btn[j].pag;\n\t\t\t\t\t\tif (new == pp) {\n\t\t\t\t\t\t\tnew->next = -1;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tnew->prev = pp->id, new->next = -1;\n\t\t\t\t\t\t\tpp->next = new->id;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnow = new->id;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nstruct page{\n  char name[102];\n  int a,bob,boe;\n};\nstruct botan{\n  char name[102];\n  int lux,luy,rdx,rdy;\n};\n\nmain(){\n  int n,m,i,j,k,W,H,a,c,bo,cx,cy,jud=0,where=0;\n  char com[10];\n  struct botan b[101];\n  struct page p[101];\n  while(1){\n    bo=0;\n    scanf(\"%d\",&n);\n    if(n==0) break;\n    scanf(\"%d%d\",&W,&H);\n    for(i=0;i<n;i++){\n      scanf(\"%s%d\",p[i].name,&c);\n      p[i].a=0;\n      p[i].bob=bo;\n      for(j=0;j<c;j++){\n\tscanf(\"%d%d%d%d%s\",&b[bo].lux,&b[bo].luy,&b[bo].rdx,&b[bo].rdy,b[bo].name);\n\tbo++;\n      }\n      p[i].boe=bo;\n    }\n\n    p[0].a=0;\n    a=0;\n    where=0;\n    scanf(\"%d\",&m);\n    for(i=0;i<m;i++){\n      scanf(\"%s\",com);\n      if(com[0]=='b'&&a>0){ \n\ta--;\n\tfor(j=0;j<n;j++){\n\t  if(a==p[j].a){\n\t    where=j;\n\t    break;\n\t  }\n\t}\n      }\n      else if(com[0]=='f'&&a<n-1){ \n\ta++;\n\tfor(j=0;j<n;j++){\n\t  if(a==p[j].a){\n\t    where=j;\n\t    break;\n\t  }\n\t}\n      }\n      else if(com[0]=='c'){\n\tscanf(\"%d%d\",&cx,&cy);\n\tfor(j=p[where].bob;j<p[where].boe;j++){\n\t  jud=0;\n\t  if(b[j].lux<=cx&&cx<=b[j].rdx&&b[j].luy<=cy&&cy<=b[j].rdy){\n\t    for(k=0;k<n;k++){\n\t      if(p[k].name[0]==b[j].name[0]){\n\t\tp[k].a=++a;\n\t\tjud=1;\n\t\twhere=k;\n\t\tbreak;\n\t      }\n\t    }\n\t  }\n\t  if(jud==1) break;\n\t}\n      }\n      else if(com[0]=='s'){\n\tfor(j=0;j<n;j++){\n\t  if(a==p[j].a) {\n\t    printf(\"%s\\n\",p[j].name);\n\t    break;\n\t  }\n\t}\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nstruct page{\n  char name[22];\n  int a,bob,boe;\n};\nstruct botan{\n  char name[102];\n  int lux,luy,rdx,rdy;\n};\n\nmain(){\n  int n,m,i,j,k,W,H,a,c,bo,cx,cy,jud=0,where=0;\n  char com[10];\n  struct botan b[101];\n  struct page p[101];\n  while(1){\n    bo=0;\n    scanf(\"%d\",&n);\n    if(n==0) break;\n    scanf(\"%d%d\",&W,&H);\n    for(i=0;i<n;i++){\n      scanf(\"%s%d\",p[i].name,&c);\n      p[i].a=0;\n      p[i].bob=bo;\n      for(j=0;j<c;j++){\n\tscanf(\"%d%d%d%d%s\",&b[bo].lux,&b[bo].luy,&b[bo].rdx,&b[bo].rdy,b[bo].name);\n\tbo++;\n      }\n      p[i].boe=bo;\n    }\n\n    p[0].a=0;\n    a=0;\n    where=0;\n    scanf(\"%d\",&m);\n    for(i=0;i<m;i++){\n      scanf(\"%s\",com);\n      if(com[0]=='b'&&a>0){ \n\ta--;\n\tfor(j=0;j<n;j++){\n\t  if(a==p[j].a){\n\t    where=j;\n\t    break;\n\t  }\n\t}\n      }\n      else if(com[0]=='f'&&a<n-1){ \n\ta++;\n\tfor(j=0;j<n;j++){\n\t  if(a==p[j].a){\n\t    where=j;\n\t    break;\n\t  }\n\t}\n      }\n      else if(com[0]=='c'){\n\tscanf(\"%d%d\",&cx,&cy);\n\tfor(j=p[where].bob;j<p[where].boe;j++){\n\t  jud=0;\n\t  if(b[j].lux<=cx&&cx<=b[j].rdx&&b[j].luy<=cy&&cy<=b[j].rdy){\n\t    for(k=0;k<n;k++){\n\t      if(p[k].name[0]==b[j].name[0]){\n\t\tp[k].a=++a;\n\t\tjud=1;\n\t\twhere=k;\n\t\tbreak;\n\t      }\n\t    }\n\t  }\n\t  if(jud==1) break;\n\t}\n      }\n      else if(com[0]=='s'){\n\tfor(j=0;j<n;j++){\n\t  if(a==p[j].a) {\n\t    printf(\"%s\\n\",p[j].name);\n\t    break;\n\t  }\n\t}\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#define BUF_SIZE 100000\n\n\nint main() {\n  char command[][10] = {\"click\", \"back\", \"forward\", \"show\"};\n\n  int n, m, W, H;\n  int i, j, k, l;\n  int x, y;\n  char str[10];\n\n  int buf[BUF_SIZE], p;\n\n  struct {\n    char name[20];\n    int bi;\n    struct {\n      int x1, y1, x2, y2;\n      char link[20];\n    } button[100];\n\n  } page[100];\n\n  while(1) {\n    scanf(\"%d\", &n);\n    if(n == 0) break;\n    scanf(\"%d %d\", &W, &H);\n    for(i = 0; i < n; i++) {\n      scanf(\"%s %d\", page[i].name, &page[i].bi);\n      for(j = 0; j < page[i].bi; j++) {\n\tscanf(\"%d %d %d %d %s\",\n\t      &page[i].button[j].x1,\n\t      &page[i].button[j].y1,\n\t      &page[i].button[j].x2,\n\t      &page[i].button[j].y2,\n\t      page[i].button[j].link\n\t      );\n      }\n    }\n\n    for(i = 0; i < BUF_SIZE; i++) {\n      buf[i] = -1;\n    }\n    buf[0] = 0;\n    p = 0;\n\n    scanf(\"%d\", &m);\n    for(i = 0; i < m; i++) {\n      scanf(\"%s\", str);\n      for(j = 0; j < 4; j++) {\n\tif(strcmp(str, command[j]) == 0) break;\n      }\n      switch(j) {\n      case 0:\n\tscanf(\"%d %d\", &x, &y);\n\tfor(j = 0; j < page[p].bi; j++) {\n\t  if(x >= page[p].button[j].x1 &&\n\t     x <= page[p].button[j].x2 &&\n\t     y >= page[p].button[j].y1 &&\n\t     y <= page[p].button[j].y2 ) {\n\t    for(k = 0; k < n; k++) {\n\t      if(strcmp(page[p].button[j].link, page[k].name) == 0) {\n\t\tp++;\n\t\tbuf[p] = k;\n\t\tfor(l = p+1; l < BUF_SIZE; l++) {\n\t\t  buf[l] = -1;\n\t\t}\n\t\tbreak;\n\t      }\n\t    }\n\t    break;\n\t  }\n\t}\n\tbreak;\n      case 1:\n\tif(p != 0) p--;\n\tbreak;\n      case 2:\n\tif(p != BUF_SIZE && buf[p+1] != -1) p++;\n\tbreak;\n      case 3:\n\tprintf(\"%s\\n\", page[buf[p]].name);\n\tbreak;\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#define BUF_SIZE 100000\n\n\nint main() {\n  char command[][10] = {\"click\", \"back\", \"forward\", \"show\"};\n\n  int n, m, W, H;\n  int i, j, k, l;\n  int x, y;\n  char str[10];\n\n  int buf[BUF_SIZE], p;\n\n  struct {\n    char name[21];\n    int bi;\n    struct {\n      int x1, y1, x2, y2;\n      char link[21];\n    } button[100];\n\n  } page[100];\n\n  while(1) {\n    scanf(\"%d\", &n);\n    if(n == 0) break;\n    scanf(\"%d %d\", &W, &H);\n    for(i = 0; i < n; i++) {\n      scanf(\"%s %d\", page[i].name, &page[i].bi);\n      for(j = 0; j < page[i].bi; j++) {\n\tscanf(\"%d %d %d %d %s\",\n\t      &page[i].button[j].x1,\n\t      &page[i].button[j].y1,\n\t      &page[i].button[j].x2,\n\t      &page[i].button[j].y2,\n\t      page[i].button[j].link\n\t      );\n      }\n    }\n\n    for(i = 0; i < BUF_SIZE; i++) {\n      buf[i] = -1;\n    }\n    buf[0] = 0;\n    p = 0;\n\n    scanf(\"%d\", &m);\n    for(i = 0; i < m; i++) {\n      scanf(\"%s\", str);\n      for(j = 0; j < 4; j++) {\n\tif(strcmp(str, command[j]) == 0) break;\n      }\n      switch(j) {\n      case 0:\n\tscanf(\"%d %d\", &x, &y);\n\tif(x < 0 || x >= W || y < 0 || y >= H) break;\n\tfor(j = 0; j < page[p].bi; j++) {\n\t  if(x >= page[p].button[j].x1 &&\n\t     x <= page[p].button[j].x2 &&\n\t     y >= page[p].button[j].y1 &&\n\t     y <= page[p].button[j].y2 ) {\n\t    for(k = 0; k < n; k++) {\n\t      if(strcmp(page[p].button[j].link, page[k].name) == 0) {\n\t\tp++;\n\t\tbuf[p] = k;\n\t\tfor(l = p+1; l < BUF_SIZE; l++) {\n\t\t  buf[l] = -1;\n\t\t}\n\t\tbreak;\n\t      }\n\t    }\n\t    break;\n\t  }\n\t}\n\tbreak;\n      case 1:\n\tif(p != 0) p--;\n\tbreak;\n      case 2:\n\tif(p != BUF_SIZE - 1 && buf[p+1] != -1) p++;\n\tbreak;\n      case 3:\n\tprintf(\"%s\\n\", page[buf[p]].name);\n\tbreak;\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 1054: Distorted Love\n// 2017.9.28 bal4u@uu\n\n#include <stdio.h>\n#include <string.h>\n\ntypedef struct { int x1, y1, x2, y2; char nm[25]; int pag; } BTN;\ntypedef struct { char nm[25]; int bn; BTN btn[102]; } PAG;\nPAG pag[200]; int n;\nint buf[2000], size;\nint now;\n\nint whatPage(char *nm)\n{\n\tint i;\n\tfor (i = 0; i < n; i++) if (strcmp(nm, pag[i].nm) == 0) return i;\n\twhile (1);   // panic\n\treturn -1;\n}\n\nint main()\n{\n\tint h, w, m, i, j, k, x, y;\n\tPAG *pp;\n\tchar cmd[20];\n\n\twhile (scanf(\"%d\", &n) && n > 0) {\n\t\tscanf(\"%d%d\", &w, &h);\n\t\tfor (pp = pag, i = 0; i < n; i++, pp++) {\n\t\t\tscanf(\"%s%d\", pp->nm, &k), pp->bn = k;\n\t\t\tfor (j = 0; j < k; j++)\n\t\t\t\tscanf(\"%d%d%d%d%s\", &pp->btn[j].x1, &pp->btn[j].y1,\n\t\t\t\t\t  &pp->btn[j].x2, &pp->btn[j].y2, &pp->btn[j].nm);\n\t\t}\n\t\tfor (pp = pag, i = 0; i < n; i++, pp++)\n\t\t\tfor (j = 0; j < pp->bn; j++) pp->btn[j].pag = whatPage(pp->btn[j].nm);\n\n\t\tnow = 0, buf[0] = 0, size = 1;\n\t\tscanf(\"%d\", &m);\n\t\twhile (m-- > 0) {\n\t\t\tscanf(\"%s\", cmd);\n\t\t\tif (*cmd == 'b') {\n\t\t\t\tif (now > 0) now--;\n\t\t\t} else if (*cmd == 'f') {\n\t\t\t\tif (now < size-1) now++;\n\t\t\t} else if (*cmd == 's') puts(pag[buf[now]].nm);\n\t\t\telse {\t\t// click\n\t\t\t\tscanf(\"%d%d\", &x, &y);\n\t\t\t\tpp = pag + buf[now];\n\t\t\t\tfor (j = 0; j < pp->bn; j++) {\n\t\t\t\t\tif (pp->btn[j].x1 <= x && x <= pp->btn[j].x2 &&\n\t\t\t\t\t\tpp->btn[j].y1 <= y && y <= pp->btn[j].y2) {\n\t\t\t\t\t\tbuf[++now] = pp->btn[j].pag;\n\t\t\t\t\t\tsize = now+1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "n;\ntypedef struct{\n\tint x1,y1,x2,y2;\n\tchar link[21];\n}Btn;\ntypedef struct{\n\tchar title[21];\n\tint bn;\n\tBtn btn[100];\n}Page;\nPage page[100];\nhist[99999],hidx,hmax;\nmain(){\n\tint W,H,m,i,j;\n\tchar op[9];\n\tfor(;scanf(\"%d\",&n)*n;){\n\t\tscanf(\"%d%d\",&W,&H);\n\t\tfor(i=n;i--;){\n\t\t\tPage*p=page+i;\n\t\t\tscanf(\"%s%d\",p->title,&p->bn);\n\t\t\tfor(j=p->bn;j--;){\n\t\t\t\tBtn*b=p->btn+j;\n\t\t\t\tscanf(\"%d%d%d%d%s\",&b->x1,&b->y1,&b->x2,&b->y2,b->link);\n\t\t\t}\n\t\t}\n\t\t*hist=n-1;\n\t\thmax=0;\n\t\thidx=0;\n\t\tscanf(\"%d\",&m);\n\t\tfor(;m--;){\n\t\t\tscanf(\"%s\",op);\n\t\t\tif(strcmp(op,\"click\")==0){\n\t\t\t\tPage*p=page+hist[hidx];\n\t\t\t\tint x,y;\n\t\t\t\tscanf(\"%d%d\",&x,&y);\n\t\t\t\tfor(i=p->bn;i--;){\n\t\t\t\t\tBtn*b=p->btn+i;\n\t\t\t\t\tif(x>=b->x1&&x<=b->x2&&y>=b->y1&&y<=b->y2){\n\t\t\t\t\t\tfor(j=n;j--;){\n\t\t\t\t\t\t\tif(strcmp(page[j].title,b->link)==0){\n\t\t\t\t\t\t\t\thist[hmax=++hidx]=j;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(strcmp(op,\"back\")==0){\n\t\t\t\tif(hidx>0)\n\t\t\t\t\thidx--;\n\t\t\t}\n\t\t\tif(strcmp(op,\"forward\")==0){\n\t\t\t\tif(hidx<hmax)\n\t\t\t\t\thidx++;\n\t\t\t}\n\t\t\tif(strcmp(op,\"show\")==0){\n\t\t\t\tputs(page[hist[hidx]].title);\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#define BUF_SIZE 100000\n\n\nint main() {\n  char command[][10] = {\"click\", \"back\", \"forward\", \"show\"};\n\n  int n, m, W, H;\n  int i, j, k, l, c;\n  int x, y;\n  char str[10];\n\n  int buf[BUF_SIZE], p;\n\n  struct {\n    char name[21];\n    int bi;\n    struct {\n      int x1, y1, x2, y2;\n      char link[21];\n    } button[100];\n\n  } page[100];\n\n  while(1) {\n    scanf(\"%d\", &n);\n    if(n == 0) break;\n    scanf(\"%d %d\", &W, &H);\n    for(i = 0; i < n; i++) {\n      scanf(\"%s %d\", page[i].name, &page[i].bi);\n      for(j = 0; j < page[i].bi; j++) {\n\tscanf(\"%d %d %d %d %s\",\n\t      &page[i].button[j].x1,\n\t      &page[i].button[j].y1,\n\t      &page[i].button[j].x2,\n\t      &page[i].button[j].y2,\n\t      page[i].button[j].link\n\t      );\n      }\n    }\n\n    for(i = 0; i < BUF_SIZE; i++) {\n      buf[i] = -1;\n    }\n    buf[0] = 0;\n    p = 0;\n\n    scanf(\"%d\", &m);\n    for(i = 0; i < m; i++) {\n      scanf(\"%s\", str);\n      for(c = 0; c < 4; c++) {\n\tif(strcmp(str, command[c]) == 0) break;\n      }\n      switch(c) {\n      case 0:\n\tscanf(\"%d %d\", &x, &y);\n\tfor(j = 0; j < page[buf[p]].bi; j++) {\n\t  if(x >= page[buf[p]].button[j].x1 &&\n\t     x <= page[buf[p]].button[j].x2 &&\n\t     y >= page[buf[p]].button[j].y1 &&\n\t     y <= page[buf[p]].button[j].y2 ) {\n\t    for(k = 0; k < n; k++) {\n\t      if(strcmp(page[buf[p]].button[j].link, page[k].name) == 0) {\n\t\tp++;\n\t\tbuf[p] = k;\n\t\tfor(l = p+1; l < BUF_SIZE; l++) {\n\t\t  buf[l] = -1;\n\t\t}\n\t\tbreak;\n\t      }\n\t    }\n\t    break;\n\t  }\n\t}\n\tbreak;\n      case 1:\n\tif(p != 0) p--;\n\tbreak;\n      case 2:\n\tif(p != BUF_SIZE - 1 && buf[p+1] != -1) p++;\n\tbreak;\n      case 3:\n\tprintf(\"%s\\n\", page[buf[p]].name);\n\tbreak;\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nstruct page{\n  char name[21];\n  int a,bob,boe;\n};\nstruct botan{\n  char name[21];\n  int lux,luy,rdx,rdy;\n};\n\nmain(){\n  int n,m,i,j,k,W,H,a,c,bo,cx,cy,jud=0,where=0,namec=0,l;\n  char com[8];\n  struct botan b[10000];\n  struct page p[100];\n  while(1){\n    bo=0;\n    scanf(\"%d\",&n);\n    if(n==0) break;\n    scanf(\"%d%d\",&W,&H);\n    for(i=0;i<n;i++){\n      scanf(\"%s%d\",p[i].name,&c);\n      p[i].a=0;\n      p[i].bob=bo;\n      for(j=0;j<c;j++){\n\tscanf(\"%d%d%d%d%s\",&b[bo].lux,&b[bo].luy,&b[bo].rdx,&b[bo].rdy,b[bo].name);\n\tbo++;\n      }\n      p[i].boe=bo;\n    }\n\n    p[0].a=0;\n    a=0;\n    where=0;\n    scanf(\"%d\",&m);\n    for(i=0;i<m;i++){\n      scanf(\"%s\",com);\n      if(com[0]=='b'&&a>0){ \n\ta--;\n\tfor(j=0;j<n;j++){\n\t  if(a==p[j].a){\n\t    where=j;\n\t    break;\n\t  }\n\t}\n      }\n      else if(com[0]=='f'&&a<n-1){ \n\ta++;\n\tfor(j=0;j<n;j++){\n\t  if(a==p[j].a){\n\t    where=j;\n\t    break;\n\t  }\n\t}\n      }\n      else if(com[0]=='c'){\n\tscanf(\"%d%d\",&cx,&cy);\n\tfor(j=p[where].bob;j<p[where].boe;j++){\n\t  jud=0;\n\t  if(b[j].lux<=cx&&cx<=b[j].rdx&&b[j].luy<=cy&&cy<=b[j].rdy){\n\t    namec=0;\t    \n\t    for(k=0;k<n;k++){\n\t      for(l=0;l<21;l++){\t    \n\t\tif(p[k].name[l]==b[j].name[l]) namec++;\n\t\tif(p[k].name[l]=='\\0'||b[j].name[l]=='\\0'){\n\t\t  l++;\n\t\t  break;\n\t\t}\n\t      }\n\t      if(l==namec){\n\t\tp[k].a=++a;\n\t\tjud=1;\n\t\twhere=k;\n\t\tbreak;\n\t      }\n\t    }\t\t\n\t  }\n\t}\n\tif(jud==1) break;\n      }\n      else if(com[0]=='s'){\n\tfor(j=0;j<n;j++){\n\t  if(a==p[j].a) {\n\t    printf(\"%s\\n\",p[j].name);\n\t    break;\n\t  }\n\t}\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nstruct page{\n  char name[210];\n  int a,bob,boe;\n};\nstruct botan{\n  char name[210];\n  int lux,luy,rdx,rdy;\n};\n\nmain(){\n  int n,m,i,j,k,W,H,a,c,bo,cx,cy,jud=0,where=0,namec=0,l;\n  char com[80];\n  struct botan b[90201];\n  struct page p[901];\n  while(1){\n    bo=0;\n    scanf(\"%d\",&n);\n    if(n==0) break;\n    scanf(\"%d%d\",&W,&H);\n    for(i=0;i<n;i++){\n      scanf(\"%s%d\",p[i].name,&c);\n      p[i].a=0;\n      p[i].bob=bo;\n      for(j=0;j<c;j++){\n\tscanf(\"%d%d%d%d%s\",&b[bo].lux,&b[bo].luy,&b[bo].rdx,&b[bo].rdy,b[bo].name);\n\tbo++;\n      }\n      p[i].boe=bo;\n    }\n\n    p[0].a=0;\n    a=0;\n    where=0;\n    scanf(\"%d\",&m);\n    for(i=0;i<m;i++){\n      scanf(\"%s\",com);\n      /*       printf(\"mae %d\\n\",a); */\n      if(com[0]=='b'&&a>0){ \n\ta--;\n\tfor(j=0;j<n;j++){\n\t  if(a==p[j].a){\n\t    where=j;\n\t    break;\n\t  }\n\t}\n      }\n      else if(com[0]=='f'&&a<n-1){ \n\ta++;\n\tfor(j=0;j<n;j++){\n\t  if(a==p[j].a){\n\t    where=j;\n\t    break;\n\t  }\n\t}\n      }\n      else if(com[0]=='c'){\n\tscanf(\"%d%d\",&cx,&cy);\n\tfor(j=p[where].bob;j<p[where].boe;j++){\n\t  jud=0;\n\t  /*\t  printf(\"+\\n\"); */\n\t  if(b[j].lux<=cx&&cx<=b[j].rdx&&b[j].luy<=cy&&cy<=b[j].rdy){\n\t    namec=0;\t    \n\t    for(k=0;k<n;k++){\n\t      for(l=0;l<21;l++){\t    \n\t\tif(p[k].name[l]==b[j].name[l]) namec++;\n\t\tif(p[k].name[l]=='\\0'||b[j].name[l]=='\\0'){\n\t\t  l++;\n\t\t  break;\n\t\t}\n\t      }\n\t      /*printf(\"l=%d namec=%d\\n\",l,namec);*/\n\t      if(l==namec){\n\t\tp[k].a=++a;\n\t\tjud=1;\n\t\twhere=k;\n\t\t/*printf(\"cy:%d,luy=%d,rdy=%d j=%d \\n\",cy,b[j].luy,b[j].rdy,j); */\n\t\tbreak;\n\t      }\n\t    }\t\t\n\t  }\n\t}\n\tif(jud==1) break;\n      }\n      else if(com[0]=='s'){\n\tfor(j=0;j<n;j++){\n\t  if(a==p[j].a) {\n\t    printf(\"%s\\n\",p[j].name);\n\t    break;\n\t  }\n\t  /* else printf(\"a=%d p[j].a=%d\\n\",a,p[j].a);*/\n\t}\n      }\n      /*printf(\"ato\\n);*/\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nstruct page{\n  char name[21];\n  int a,bob,boe;\n};\nstruct botan{\n  char name[21];\n  int lux,luy,rdx,rdy;\n};\n\nmain(){\n  int n,m,i,j,k,W,H,a,c,bo,cx,cy,jud=0,where=0,namec=0,l;\n  char com[8];\n  struct botan b[101000];\n  struct page p[101];\n  while(1){\n    bo=0;\n    scanf(\"%d\",&n);\n    if(n==0) break;\n    scanf(\"%d%d\",&W,&H);\n    for(i=0;i<n;i++){\n      scanf(\"%s%d\",p[i].name,&c);\n      p[i].a=0;\n      p[i].bob=bo;\n      for(j=0;j<c;j++){\n\tscanf(\"%d%d%d%d%s\",&b[bo].lux,&b[bo].luy,&b[bo].rdx,&b[bo].rdy,b[bo].name);\n\tbo++;\n      }\n      p[i].boe=bo;\n    }\n\n    p[0].a=0;\n    a=0;\n    where=0;\n    scanf(\"%d\",&m);\n    for(i=0;i<m;i++){\n      scanf(\"%s\",com);\n      if(com[0]=='b'&&a>0){ \n\ta--;\n\tfor(j=0;j<n;j++){\n\t  if(a==p[j].a){\n\t    where=j;\n\t    break;\n\t  }\n\t}\n      }\n      else if(com[0]=='f'&&a<n-1){ \n\ta++;\n\tfor(j=0;j<n;j++){\n\t  if(a==p[j].a){\n\t    where=j;\n\t    break;\n\t  }\n\t}\n      }\n      else if(com[0]=='c'){\n\tscanf(\"%d%d\",&cx,&cy);\n\tfor(j=p[where].bob;j<p[where].boe;j++){\n\t  jud=0;\n\t  if(b[j].lux<=cx&&cx<=b[j].rdx&&b[j].luy<=cy&&cy<=b[j].rdy){\n\t    namec=0;\t    \n\t    for(k=0;k<n;k++){\n\t      for(l=0;l<21;l++){\t    \n\t\tif(p[k].name[l]==b[j].name[l]) namec++;\n\t\tif(p[k].name[l]=='\\0'||b[j].name[l]=='\\0'){\n\t\t  l++;\n\t\t  break;\n\t\t}\n\t      }\n\t      if(l==namec){\n\t\tp[k].a=++a;\n\t\tjud=1;\n\t\twhere=k;\n\t\tbreak;\n\t      }\n\t    }\t\t\n\t  }\n\t}\n\tif(jud==1) break;\n      }\n      else if(com[0]=='s'){\n\tfor(j=0;j<n;j++){\n\t  if(a==p[j].a) {\n\t    printf(\"%s\\n\",p[j].name);\n\t    break;\n\t  }\n\t}\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nstruct page{\n  char name[2100];\n  int a,bob,boe;\n};\nstruct botan{\n  char name[2100];\n  int lux,luy,rdx,rdy;\n};\n\nmain(){\n  int n,m,i,j,k,W,H,a,c,bo,cx,cy,jud=0,where=0,namec=0,l;\n  char com[800];\n  struct botan b[102010];\n  struct page p[9010];\n  while(1){\n    bo=0;\n    scanf(\"%d\",&n);\n    if(n==0) break;\n    scanf(\"%d%d\",&W,&H);\n    for(i=0;i<n;i++){\n      scanf(\"%s%d\",p[i].name,&c);\n      p[i].a=0;\n      p[i].bob=bo;\n      for(j=0;j<c;j++){\n\tscanf(\"%d%d%d%d%s\",&b[bo].lux,&b[bo].luy,&b[bo].rdx,&b[bo].rdy,b[bo].name);\n\tbo++;\n      }\n      p[i].boe=bo;\n    }\n\n    p[0].a=0;\n    a=0;\n    where=0;\n    scanf(\"%d\",&m);\n    for(i=0;i<m;i++){\n      scanf(\"%s\",com);\n      /*       printf(\"mae %d\\n\",a); */\n      if(com[0]=='b'&&a>0){ \n\ta--;\n\tfor(j=0;j<n;j++){\n\t  if(a==p[j].a){\n\t    where=j;\n\t    break;\n\t  }\n\t}\n      }\n      else if(com[0]=='f'&&a<n-1){ \n\ta++;\n\tfor(j=0;j<n;j++){\n\t  if(a==p[j].a){\n\t    where=j;\n\t    break;\n\t  }\n\t}\n      }\n      else if(com[0]=='c'){\n\tscanf(\"%d%d\",&cx,&cy);\n\tfor(j=p[where].bob;j<p[where].boe;j++){\n\t  jud=0;\n\t  /*\t  printf(\"+\\n\"); */\n\t  if(b[j].lux<=cx&&cx<=b[j].rdx&&b[j].luy<=cy&&cy<=b[j].rdy){\n\t    namec=0;\t    \n\t    for(k=0;k<n;k++){\n\t      for(l=0;l<21;l++){\t    \n\t\tif(p[k].name[l]==b[j].name[l]) namec++;\n\t\tif(p[k].name[l]=='\\0'||b[j].name[l]=='\\0'){\n\t\t  l++;\n\t\t  break;\n\t\t}\n\t      }\n\t      /*printf(\"l=%d namec=%d\\n\",l,namec);*/\n\t      if(l==namec){\n\t\tp[k].a=++a;\n\t\tjud=1;\n\t\twhere=k;\n\t\t/*printf(\"cy:%d,luy=%d,rdy=%d j=%d \\n\",cy,b[j].luy,b[j].rdy,j); */\n\t\tbreak;\n\t      }\n\t    }\t\t\n\t  }\n\t}\n\tif(jud==1) break;\n      }\n      else if(com[0]=='s'){\n\tfor(j=0;j<n;j++){\n\t  if(a==p[j].a) {\n\t    printf(\"%s\\n\",p[j].name);\n\t    break;\n\t  }\n\t  /* else printf(\"a=%d p[j].a=%d\\n\",a,p[j].a);*/\n\t}\n      }\n      /*printf(\"ato\\n);*/\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\nstruct botan{\n  char name[21];\n  int lux,luy,rdx,rdy;\n};\nstruct page{\n  char name[21];\n  struct botan b[99];\n  int a,c;\n};\n\nmain(){\n  int n,m,i,j,k,W,H,a,cx,cy,jud=0,where=0,namec=0,l;\n  char com[8];\n  struct page p[100];\n  while(1){\n    scanf(\"%d\",&n);\n    if(n==0) break;\n    scanf(\"%d%d\",&W,&H);\n    for(i=0;i<n;i++){\n      scanf(\"%s%d\",p[i].name,&p[i].c);\n      p[i].a=0;\n      for(j=0;j<p[i].c;j++){\n\tscanf(\"%d%d%d%d%s\",&p[i].b[j].lux,&p[i].b[j].luy,&p[i].b[j].rdx,&p[i].b[j].rdy,p[i].b[j].name);\n      }\n    }\n\n    a=0;\n    where=0;\n    scanf(\"%d\",&m);\n    for(i=0;i<m;i++){\n      scanf(\"%s\",com);\n      /*       printf(\"mae %d\\n\",a); */\n      if(com[0]=='b'&&a>0){ \n\ta--;\n\tfor(j=0;j<n;j++){\n\t  if(a==p[j].a){\n\t    where=j;\n\t    break;\n\t  }\n\t}\n      }\n      else if(com[0]=='f'&&a<n-1){ \n\ta++;\n\tfor(j=0;j<n;j++){\n\t  if(a==p[j].a){\n\t    where=j;\n\t    break;\n\t  }\n\t}\n      }\n      else if(com[0]=='c'){\n\tscanf(\"%d%d\",&cx,&cy);\n\tfor(j=0;j<p[where].c;j++){\n\t  jud=0;\n\t  if(p[where].b[j].lux<=cx&&cx<=p[where].b[j].rdx&&p[where].b[j].luy<=cy&&cy<=p[where].b[j].rdy){\n\t    namec=0;\t    \n\t    for(k=0;k<n;k++){\n\t      for(l=0;l<21;l++){\n\t\tif(p[k].name[l]==p[where].b[j].name[l]) namec++;\n\t\tif(p[k].name[l]=='\\0'||p[where].b[j].name[l]=='\\0'){\n\t\t  l++;\n\t\t  break;\n\t\t}\n\t      }\n\t      /*printf(\"l=%d namec=%d\\n\",l,namec);*/\n\t      if(l==namec){\n\t\tp[k].a=++a;\n\t\tjud=1;\n\t\twhere=k;\n\t\t/*printf(\"cy:%d,luy=%d,rdy=%d j=%d\\n\",cy,b[j].luy,b[j].rdy,j);*/\n\t\tbreak;\n\t      }\n\t    }\t\t\n\t  }\n\t}\n\tif(jud==1) break;\n      }\n      else if(com[0]=='s'){\n\t    printf(\"%s\\n\",p[where].name);\n      }\n    }\n  } \n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <iostream>\n#include <string>\n#include <map>\n#include <sstream>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\nclass B{\npublic:\n  int x1, y1, x2, y2;\n  string to;\n  B(){}\n  B(int x1, int y1, int x2, int y2, string to) : x1(x1), y1(y1), x2(x2), y2(y2), to(to) {}\n};\n\nint n, h, w, b[100], m;\nvector<B> buttons[100];\nstring name[100];\nmap<string, int> stoi;\n\nint clicked(int x, int y, int p){\n  for(int i=0;i<b[p];i++){\n    B but = buttons[p][i];\n    if(but.x1 <= x && x <= but.x2 && but.y1 <= y && y <= but.y2) return stoi[but.to];\n  }\n  return -1;\n}\n\nmain(){\n  while(cin >> n && n){\n    stoi.clear();\n    for(int i=0;i<n;i++) buttons[i].clear();\n    cin >> w >> h;\n    for(int i=0;i<n;i++){\n      cin >> name[i];\n      cin >> b[i];\n      stoi[name[i]] = i;\n      for(int j=0;j<b[i];j++){\n        B in;\n        cin >> in.x1 >> in.y1 >> in.x2 >> in.y2 >> in.to;\n        buttons[i].push_back(in);\n      }\n    }\n    cin >> m;\n    int p = 0;\n    vector<int> buf;\n    buf.push_back(0);\n    for(int i=0;i<m;i++){\n      string str;\n      cin >> str;\n      if(str == \"forward\"){\n        if(p+1 < buf.size()) p++;\n      }else if(str == \"back\"){\n        if(p != 0) p--;\n      }else if(str == \"show\"){\n        cout << name[buf[p]] << endl;\n      }else{\n        int x, y;\n        cin >> x >> y;\n        int next = clicked(x, y, buf[p]);\n        if(next == -1) continue;\n        if(p+1 != buf.size()) buf.erase(buf.begin() + p+1);\n        buf.push_back(next);\n        p++;\n      }\n    }\n  }\n}"
  },
  {
    "language": "C",
    "code": "typedef struct{int x1,y1,x2,y2;char l[21];}B;typedef struct{char t[21];int n;B b[100];}P;P*p,a[100];B*b;h[99999],c,H,m,i,j,x,y;char o[9];main(n){for(;scanf(\"%d%*d%*d\",&n)*n;){for(i=n;i--;)for(p=a+i,scanf(\"%s%d\",p->t,&j),p->n=j;j--;scanf(\"%d%d%d%d%s\",&b->x1,&b->y1,&b->x2,&b->y2,b->l))b=p->b+j;for(h[H=c=0]=n-scanf(\"%d\",&m);m--;){scanf(\"%s\",o);if(*o=='c')for(p=a+h[c],scanf(\"%d%d\",&x,&y),i=p->n;i--;)if(b=p->b+i,x>=b->x1&&x<=b->x2&&y>=b->y1&&y<=b->y2)for(j=n;j--;)!strcmp(a[j].t,b->l)?h[H=++c]=j:0;if(*o=='b')c-=c>0;if(*o=='f')c+=c<H;if(*o=='s')puts(a[h[c]].t);}}}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\nstruct page{\n  char name[21];\n  int a,bob,boe;\n};\nstruct botan{\n  char name[101];\n  int lux,luy,rdx,rdy;\n};\nmain(){\n  int n,m,i,j,k,W,H,a,c,bo,cx,cy;\n  char com[8];\n  struct botan b[100];\n  struct page p[100];\n  while(1){\n    bo=0;\n    scanf(\"%d\",&n);\n    if(n==0) break;\n    scanf(\"%d%d\",&W,&H);\n    for(i=0;i<n;i++){\n      scanf(\"%s%d\",p[i].name,&c);\n      p[i].bob=bo;\n      for(j=0;j<c;j++){\n\tscanf(\"%d%d%d%d%s\",&b[bo].lux,&b[bo].luy,&b[bo].rdx,&b[bo].rdy,b[bo].name);\n\tbo++;\n      }\n      bo--;\n      p[i].boe=bo;\n      bo++;\n    }\n\n    p[0].a=0;\n    a=0;\n    scanf(\"%d\",&m);\n    for(i=0;i<m;i++){\n      scanf(\"%s\",com);\n      if(com==\"back\"&&a>0) a--;\n      else if(com==\"forward\"&&a<n-1) a++;\n      else if(com==\"click\"){\n\t\n\tscanf(\"%d%d\",&cx,&cy);\n\tfor(j=p[a].bob;j<=p[a].boe;j++){\n\t  if((b[j].lux<=cx<=b[j].rdx)&&(b[j].luy<=cy<=b[j].rdy)){\n\t    for(k=0;k<n;k++){\n\t      if(p[k].name==b[j].name){\n\t\ta++;\n\t\tp[k].a=a;\n\t      }\n\t    }\n\t  }\n\t}\n      }\n      else if(com==\"show\"){\n\tfor(j=0;j<n;j++){\n\t  if(a==p[j].a) printf(\"%s\\n\",p[j].name);\n\t}\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nstruct page{\n  char name[210];\n  int a,bob,boe;\n};\nstruct botan{\n  char name[210];\n  int lux,luy,rdx,rdy;\n};\n\nmain(){\n  int n,m,i,j,k,W,H,a,c,bo,cx,cy,jud=0,where=0,namec=0,l;\n  char com[80];\n  struct botan b[102010];\n  struct page p[1010];\n  while(1){\n    bo=0;\n    scanf(\"%d\",&n);\n    if(n==0) break;\n    scanf(\"%d%d\",&W,&H);\n    for(i=0;i<n;i++){\n      scanf(\"%s%d\",p[i].name,&c);\n      p[i].a=0;\n      p[i].bob=bo;\n      for(j=0;j<c;j++){\n\tscanf(\"%d%d%d%d%s\",&b[bo].lux,&b[bo].luy,&b[bo].rdx,&b[bo].rdy,b[bo].name);\n\tbo++;\n      }\n      p[i].boe=bo;\n    }\n\n    p[0].a=0;\n    a=0;\n    where=0;\n    scanf(\"%d\",&m);\n    for(i=0;i<m;i++){\n      scanf(\"%s\",com);\n      /*       printf(\"mae %d\\n\",a); */\n      if(com[0]=='b'&&a>0){ \n\ta--;\n\tfor(j=0;j<n;j++){\n\t  if(a==p[j].a){\n\t    where=j;\n\t    break;\n\t  }\n\t}\n      }\n      else if(com[0]=='f'&&a<n-1){ \n\ta++;\n\tfor(j=0;j<n;j++){\n\t  if(a==p[j].a){\n\t    where=j;\n\t    break;\n\t  }\n\t}\n      }\n      else if(com[0]=='c'){\n\tscanf(\"%d%d\",&cx,&cy);\n\tfor(j=p[where].bob;j<p[where].boe;j++){\n\t  jud=0;\n\t  /*\t  printf(\"+\\n\"); */\n\t  if(b[j].lux<=cx&&cx<=b[j].rdx&&b[j].luy<=cy&&cy<=b[j].rdy){\n\t    namec=0;\t    \n\t    for(k=0;k<n;k++){\n\t      for(l=0;l<21;l++){\t    \n\t\tif(p[k].name[l]==b[j].name[l]) namec++;\n\t\tif(p[k].name[l]=='\\0'||b[j].name[l]=='\\0'){\n\t\t  l++;\n\t\t  break;\n\t\t}\n\t      }\n\t      /*printf(\"l=%d namec=%d\\n\",l,namec);*/\n\t      if(l==namec){\n\t\tp[k].a=++a;\n\t\tjud=1;\n\t\twhere=k;\n\t\t/*printf(\"cy:%d,luy=%d,rdy=%d j=%d\\n\",cy,b[j].luy,b[j].rdy,j);*/\n\t\tbreak;\n\t      }\n\t    }\t\t\n\t  }\n\t}\n\tif(jud==1) break;\n      }\n      else if(com[0]=='s'){\n\tfor(j=0;j<n;j++){\n\t  if(a==p[j].a) {\n\t    printf(\"%s\\n\",p[j].name);\n\t    break;\n\t  }\n\t  /* else printf(\"a=%d p[j].a=%d\\n\",a,p[j].a);*/\n\t}\n      }\n      /*printf(\"ato\\n);*/\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#define BUF_SIZE 100000\n\n\nint main() {\n  char command[][10] = {\"click\", \"back\", \"forward\", \"show\"};\n\n  int n, m, W, H;\n  int i, j, k, l, o;\n  int x, y;\n  char str[10];\n\n  int buf[BUF_SIZE], p;\n\n  struct {\n    char name[21];\n    int bi;\n    struct {\n      int x1, y1, x2, y2;\n      char link[21];\n    } button[100];\n\n  } page[100];\n\n  while(1) {\n    scanf(\"%d\", &n);\n    if(n == 0) break;\n    scanf(\"%d %d\", &W, &H);\n    for(i = 0; i < n; i++) {\n      scanf(\"%s %d\", page[i].name, &page[i].bi);\n      for(j = 0; j < page[i].bi; j++) {\n\tscanf(\"%d %d %d %d %s\",\n\t      &page[i].button[j].x1,\n\t      &page[i].button[j].y1,\n\t      &page[i].button[j].x2,\n\t      &page[i].button[j].y2,\n\t      page[i].button[j].link\n\t      );\n      }\n    }\n\n    for(i = 0; i < BUF_SIZE; i++) {\n      buf[i] = -1;\n    }\n    buf[0] = 0;\n    p = 0;\n\n    scanf(\"%d\", &m);\n    for(i = 0; i < m; i++) {\n      scanf(\"%s\", str);\n      for(o = 0; o < 4; o++) {\n\tif(strcmp(str, command[o]) == 0) break;\n      }\n      switch(o) {\n      case 0:\n\tscanf(\"%d %d\", &x, &y);\n\tif(x < 0 || x > W || y < 0 || y > H) break;\n\tfor(j = 0; j < page[p].bi; j++) {\n\t  if(x >= page[p].button[j].x1 &&\n\t     x <= page[p].button[j].x2 &&\n\t     y >= page[p].button[j].y1 &&\n\t     y <= page[p].button[j].y2 ) {\n\t    for(k = 0; k < n; k++) {\n\t      if(strcmp(page[p].button[j].link, page[k].name) == 0) {\n\t\tp++;\n\t\tbuf[p] = k;\n\t\tfor(l = p+1; l < BUF_SIZE; l++) {\n\t\t  buf[l] = -1;\n\t\t}\n\t\tbreak;\n\t      }\n\t    }\n\t    break;\n\t  }\n\t}\n\tbreak;\n      case 1:\n\tif(p != 0) p--;\n\tbreak;\n      case 2:\n\tif(p != BUF_SIZE - 1 && buf[p+1] != -1) p++;\n\tbreak;\n      case 3:\n\tprintf(\"%s\\n\", page[buf[p]].name);\n\tbreak;\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nstruct page{\n  char name[210];\n  int a,bob,boe;\n};\nstruct botan{\n  char name[210];\n  int lux,luy,rdx,rdy;\n};\n\nmain(){\n  int n,m,i,j,k,W,H,a,c,bo,cx,cy,jud=0,where=0,namec=0,l;\n  char com[8];\n  struct botan b[10100];\n  struct page p[101];\n  while(1){\n    bo=0;\n    scanf(\"%d\",&n);\n    if(n==0) break;\n    scanf(\"%d%d\",&W,&H);\n    for(i=0;i<n;i++){\n      scanf(\"%s%d\",p[i].name,&c);\n      p[i].a=0;\n      p[i].bob=bo;\n      for(j=0;j<c;j++){\n\tscanf(\"%d%d%d%d%s\",&b[bo].lux,&b[bo].luy,&b[bo].rdx,&b[bo].rdy,b[bo].name);\n\tbo++;\n      }\n      p[i].boe=bo;\n    }\n\n    p[0].a=0;\n    a=0;\n    where=0;\n    scanf(\"%d\",&m);\n    for(i=0;i<m;i++){\n      scanf(\"%s\",com);\n      if(com[0]=='b'&&a>0){ \n\ta--;\n\tfor(j=0;j<n;j++){\n\t  if(a==p[j].a){\n\t    where=j;\n\t    break;\n\t  }\n\t}\n      }\n      else if(com[0]=='f'&&a<n-1){ \n\ta++;\n\tfor(j=0;j<n;j++){\n\t  if(a==p[j].a){\n\t    where=j;\n\t    break;\n\t  }\n\t}\n      }\n      else if(com[0]=='c'){\n\tscanf(\"%d%d\",&cx,&cy);\n\tfor(j=p[where].bob;j<p[where].boe;j++){\n\t  jud=0;\n\t  if(b[j].lux<=cx&&cx<=b[j].rdx&&b[j].luy<=cy&&cy<=b[j].rdy){\n\t    namec=0;\t    \n\t    for(k=0;k<n;k++){\n\t      for(l=0;l<21;l++){\t    \n\t\tif(p[k].name[l]==b[j].name[l]) namec++;\n\t\tif(p[k].name[l]=='\\0'||b[j].name[l]=='\\0'){\n\t\t  l++;\n\t\t  break;\n\t\t}\n\t      }\n\t      if(l==namec){\n\t\tp[k].a=++a;\n\t\tjud=1;\n\t\twhere=k;\n\t\tbreak;\n\t      }\n\t    }\t\t\n\t  }\n\t}\n\tif(jud==1) break;\n      }\n      else if(com[0]=='s'){\n\tfor(j=0;j<n;j++){\n\t  if(a==p[j].a) {\n\t    printf(\"%s\\n\",p[j].name);\n\t    break;\n\t  }\n\t}\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nstruct page{\n  char name[21];\n  int a,bob,boe;\n};\nstruct botan{\n  char name[101];\n  int lux,luy,rdx,rdy;\n};\n\nmain(){\n  int n,m,i,j,k,W,H,a,c,bo,cx,cy,jud=0,where=0;\n  char com[8];\n  struct botan b[100];\n  struct page p[100];\n  while(1){\n    bo=0;\n    scanf(\"%d\",&n);\n    if(n==0) break;\n    scanf(\"%d%d\",&W,&H);\n    for(i=0;i<n;i++){\n      scanf(\"%s%d\",p[i].name,&c);\n      p[i].a=0;\n      p[i].bob=bo;\n      for(j=0;j<c;j++){\n\tscanf(\"%d%d%d%d%s\",&b[bo].lux,&b[bo].luy,&b[bo].rdx,&b[bo].rdy,b[bo].name);\n\tbo++;\n      }\n      p[i].boe=bo;\n    }\n\n    p[0].a=0;\n    a=0;\n    where=0;\n    scanf(\"%d\",&m);\n    for(i=0;i<m;i++){\n      scanf(\"%s\",com);\n      if(com[0]=='b'&&a>0){ \n\ta--;\n\tfor(j=0;j<n;j++){\n\t  if(a==p[j].a){\n\t    where=j;\n\t    break;\n\t  }\n\t}\n      }\n      else if(com[0]=='f'&&a<n-1){ \n\ta++;\n\tfor(j=0;j<n;j++){\n\t  if(a==p[j].a){\n\t    where=j;\n\t    break;\n\t  }\n\t}\n      }\n      else if(com[0]=='c'){\n\tscanf(\"%d%d\",&cx,&cy);\n\tfor(j=p[where].bob;j<p[where].boe;j++){\n\t  jud=0;\n\t  if(b[j].lux<=cx&&cx<=b[j].rdx&&b[j].luy<=cy&&cy<=b[j].rdy){\n\t    for(k=0;k<n;k++){\n\t      if(p[k].name[0]==b[j].name[0]){\n\t\tp[k].a=++a;\n\t\tjud=1;\n\t\twhere=k;\n\t\tbreak;\n\t      }\n\t    }\n\t  }\n\t  if(jud==1) break;\n\t}\n      }\n      else if(com[0]=='s'){\n\tfor(j=0;j<n;j++){\n\t  if(a==p[j].a) {\n\t    printf(\"%s\\n\",p[j].name);\n\t    break;\n\t  }\n\t}\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\nclass Button {\n    int ulx, uly, lrx, lry;\n    public String linkName;\n    Button(int ulx, int uly, int lrx, int lry, String linkName) {\n        this.ulx = ulx;\n        this.uly = uly;\n        this.lrx = lrx;\n        this.lry = lry;\n        this.linkName = linkName;\n    }\n    boolean contains(int x, int y) {\n        //System.out.printf(\"%d,%d\\n\", x, y);\n        //System.out.println(ulx + \" \" +  lrx + \" \" + lry + \" \" + uly);\n        return (ulx <= x && x <= lrx && uly <= y && y <= lry);\n    }\n}\n\nclass Page {\n    public String name;\n    public Button[] links;\n    Page(String name, Button[] links) {\n        this.name = name;\n        this.links = links;\n    }\n    String getLinkPageName(int x, int y) {\n        for (Button b : links) {\n            if (b.contains(x, y)) {\n                return b.linkName;\n            }\n        }\n        return name;\n    }\n}\n\npublic class Main {\n    int n, W, H;\n    Scanner sc;\n    HashMap<String, Page> pages;\n    Main() {\n        sc = new Scanner(System.in);\n    }\n    boolean init() {\n        n = sc.nextInt();\n        if (n == 0) return false;\n        W = sc.nextInt();\n        H = sc.nextInt();\n        pages = new HashMap<String, Page>();\n        for (int i = 0; i < n; i++) {\n            String name = sc.next();\n            int b = sc.nextInt();\n            Button[] links = new Button[b];\n            for (int j = 0; j < b; j++) {\n                int ulx = sc.nextInt();\n                int uly = sc.nextInt();\n                int lrx = sc.nextInt();\n                int lry = sc.nextInt();\n                String linkName = sc.next();\n                links[j] = new Button(ulx, uly, lrx, lry, linkName);\n            }\n            pages.put(name, new Page(name, links));\n        }\n        return true;\n    }\n    void run() {\n        try {\n        while (init()) {\n            ArrayList<Page> history = new ArrayList<Page>();\n            history.add(pages.get(\"index\"));\n            int current = 0;\n            int m = sc.nextInt();\n            for (int i = 0; i < m; i++) {\n                String cmd = sc.next();\n                if (cmd.equals(\"click\")) {\n                    int x = sc.nextInt();\n                    int y = sc.nextInt();\n                    Page curPage = history.get(current);\n                    Page nextPage = pages.get(curPage.getLinkPageName(x, y));\n                    if (curPage != nextPage) {\n                        while (history.size() != current+1) {\n                            history.remove(current+1);\n                        }\n                        //history.removeRange(current, history.size());\n                        history.add(pages.get(curPage.getLinkPageName(x, y)));\n                        current++;\n                    }\n                } else if (cmd.equals(\"show\")) {\n                    System.out.println(history.get(current).name);\n                } else if (cmd.equals(\"back\")) {\n                    if (current > 0) current--;\n                } else if (cmd.equals(\"forward\")) {\n                    if (current < history.size()-1) current++;\n                }\n            }\n        }\n        } catch (Exception e) {\n        }\n    }\n    public static void main(String[] args) {\n        new Main().run();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.Map;\nimport java.util.Scanner;\nimport java.util.Set;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner scan = new Scanner(System.in);\n\t\tint n = scan.nextInt();\n\t\tscan.next();\n\t\tscan.next();\n\t\tString link = scan.next();\n\t\tMain d = new Main(link);\n\t\tfor (int b = scan.nextInt(); b-- > 0;) {\n\t\t\td.setA(link, scan.nextInt(), scan.nextInt(), scan.nextInt(), scan\n\t\t\t\t\t.nextInt(), scan.next());\n\t\t}\n\t\tfor (; n-- > 1;) {\n\t\t\tlink = scan.next();\n\t\t\tfor (int b = scan.nextInt(); b-- > 0;) {\n\t\t\t\td.setA(link, scan.nextInt(), scan.nextInt(), scan.nextInt(),\n\t\t\t\t\t\tscan.nextInt(), scan.next());\n\t\t\t}\n\t\t}\n\t\tfor (int m = scan.nextInt(); m-- > 0;) {\n\t\t\tString command = scan.next();\n\t\t\tif (command.equals(\"click\")) {\n\t\t\t\td.click(scan.nextInt(), scan.nextInt());\n\t\t\t} else if (command.equals(\"show\")) {\n\t\t\t\tSystem.out.println(d.show());\n\t\t\t} else if (command.equals(\"back\")) {\n\t\t\t\td.back();\n\t\t\t} else if (command.equals(\"forward\")) {\n\t\t\t\td.forward();\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic Main(String link) {\n\t\thistory.add(link);\n\t}\n\n\tLinkedList<String> history = new LinkedList<String>();\n\tint i = 0;\n\tMap<String, Set<A>> pages = new HashMap<String, Set<A>>();\n\n\tvoid setA(String page, int left, int top, int right, int bottom, String link) {\n\t\tif (!pages.containsKey(page)) {\n\t\t\tpages.put(page, new HashSet<A>());\n\t\t}\n\t\tpages.get(page).add(new A(left, right, top, bottom, link));\n\t}\n\n\tString show() {\n\t\treturn history.get(i);\n\t}\n\n\tvoid click(int x, int y) {\n\t\tfor (A a : pages.get(history.get(i))) {\n\t\t\tif (a.contains(x, y)) {\n\t\t\t\ti++;\n\t\t\t\twhile (history.size() > i) {\n\t\t\t\t\thistory.pollLast();\n\t\t\t\t}\n\t\t\t\thistory.add(a.toString());\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid back() {\n\t\tif (i > 0) {\n\t\t\ti--;\n\t\t}\n\t}\n\n\tvoid forward() {\n\t\tif (i + 1 < history.size()) {\n\t\t\ti++;\n\t\t}\n\t}\n\n\tclass A {\n\t\tint left, right, top, bottom;\n\t\tString link;\n\n\t\tpublic A(int left, int right, int top, int bottom, String link) {\n\t\t\tthis.left = left;\n\t\t\tthis.right = right;\n\t\t\tthis.top = top;\n\t\t\tthis.bottom = bottom;\n\t\t\tthis.link = link;\n\t\t}\n\n\t\tboolean contains(int x, int y) {\n\t\t\treturn (left <= x && x <= right) && (top <= y && y <= bottom);\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn link;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.Rectangle;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic Page[] buffer = new Page[10000];\n\n\tpublic static void main(String[] args) {\n\t\twhile (true) {\n\t\t\tint N = sc.nextInt();\n\t\t\tif (N == 0) break;\n\t\t\tArrays.fill(buffer, null);\n\t\t\tint W = sc.nextInt();\n\t\t\tint H = sc.nextInt();\n\t\t\tPage[] pages = new Page[N];\n\t\t\tHashMap<String, Integer> map = new HashMap<String, Integer>();\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tString name = sc.next();\n\t\t\t\tmap.put(name, i);\n\t\t\t\tint b = sc.nextInt();\n\t\t\t\tpages[i] = new Page(name, b);\n\t\t\t\tfor (int j = 0; j < b; ++j) {\n\t\t\t\t\tint x1 = sc.nextInt();\n\t\t\t\t\tint y1 = sc.nextInt();\n\t\t\t\t\tint x2 = sc.nextInt();\n\t\t\t\t\tint y2 = sc.nextInt();\n\t\t\t\t\tpages[i].button[j] = new Rectangle(x1, y1, x2 - x1, y2 - y1);\n\t\t\t\t\tpages[i].linkTo[j] = sc.next();\n\t\t\t\t}\n\t\t\t}\n\t\t\tint bp = 0;\n\t\t\tbuffer[0] = pages[0];\n\t\t\tint M = sc.nextInt();\n\t\t\tfor (int i = 0; i < M; ++i) {\n\t\t\t\tString q = sc.next();\n\t\t\t\tif (q.equals(\"click\")) {\n\t\t\t\t\tint x = sc.nextInt();\n\t\t\t\t\tint y = sc.nextInt();\n\t\t\t\t\tfor (int j = 0; j < pages[bp].button.length; ++j) {\n\t\t\t\t\t\tif (pages[bp].button[j].contains(x, y)) {\n\t\t\t\t\t\t\tfor (int k = bp + 1; buffer[k] != null; ++k) {\n\t\t\t\t\t\t\t\tbuffer[k] = null;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbuffer[bp + 1] = pages[map.get(pages[bp].linkTo[j])];\n\t\t\t\t\t\t\t++bp;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else if (q.equals(\"back\")) {\n\t\t\t\t\tif (bp > 0) --bp;\n\t\t\t\t} else if (q.equals(\"forward\")) {\n\t\t\t\t\tif (buffer[bp + 1] != null) ++bp;\n\t\t\t\t} else if (q.equals(\"show\")) {\n\t\t\t\t\tSystem.out.println(buffer[bp].name);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic class Page {\n\t\tRectangle[] button;\n\t\tString[] linkTo;\n\t\tString name;\n\n\t\tPage(String name, int buttonCount) {\n\t\t\tthis.name = name;\n\t\t\tthis.button = new Rectangle[buttonCount];\n\t\t\tthis.linkTo = new String[buttonCount];\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\nclass Button {\n    int ulx, uly, lrx, lry;\n    public String linkName;\n    Button(int ulx, int uly, int lrx, int lry, String linkName) {\n        this.ulx = ulx;\n        this.uly = uly;\n        this.lrx = lrx;\n        this.lry = lry;\n        this.linkName = linkName;\n    }\n    boolean contains(int x, int y) {\n        //System.out.printf(\"%d,%d\\n\", x, y);\n        //System.out.println(ulx + \" \" +  lrx + \" \" + lry + \" \" + uly);\n        return (ulx <= x && x <= lrx && uly <= y && y <= lry);\n    }\n}\n\nclass Page {\n    public String name;\n    public Button[] links;\n    Page(String name, Button[] links) {\n        this.name = name;\n        this.links = links;\n    }\n    String getLinkPageName(int x, int y) {\n        for (Button b : links) {\n            if (b.contains(x, y)) {\n                return b.linkName;\n            }\n        }\n        return name;\n    }\n}\n\npublic class Main {\n    int n, W, H;\n    Scanner sc;\n    HashMap<String, Page> pages;\n    Main() {\n        sc = new Scanner(System.in);\n    }\n    boolean init() {\n        n = sc.nextInt();\n        if (n == 0) return false;\n        W = sc.nextInt();\n        H = sc.nextInt();\n        pages = new HashMap<String, Page>();\n        for (int i = 0; i < n; i++) {\n            String name = sc.next();\n            int b = sc.nextInt();\n            Button[] links = new Button[b];\n            for (int j = 0; j < b; j++) {\n                int ulx = sc.nextInt();\n                int uly = sc.nextInt();\n                int lrx = sc.nextInt();\n                int lry = sc.nextInt();\n                String linkName = sc.next();\n                links[j] = new Button(ulx, uly, lrx, lry, linkName);\n            }\n            pages.put(name, new Page(name, links));\n        }\n        return true;\n    }\n    void run() {\n        while (init()) {\n            ArrayList<Page> history = new ArrayList<Page>();\n            history.add(pages.get(\"index\"));\n            int current = 0;\n            int m = sc.nextInt();\n            for (int i = 0; i < m; i++) {\n                String cmd = sc.next();\n                if (cmd.equals(\"click\")) {\n                    int x = sc.nextInt();\n                    int y = sc.nextInt();\n                    Page curPage = history.get(current);\n                    Page nextPage = pages.get(curPage.getLinkPageName(x, y));\n                    if (curPage != nextPage) {\n                        while (history.size() != current+1) {\n                            history.remove(current+1);\n                        }\n                        //history.removeRange(current, history.size());\n                        history.add(pages.get(curPage.getLinkPageName(x, y)));\n                        current++;\n                    }\n                } else if (cmd.equals(\"show\")) {\n                    System.out.println(history.get(current).name);\n                } else if (cmd.equals(\"back\")) {\n                    if (current > 0) current--;\n                } else if (cmd.equals(\"forward\")) {\n                    if (current < history.size()-1) current++;\n                }\n            }\n        }\n    }\n    public static void main(String[] args) {\n        new Main().run();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.Rectangle;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic Page[] buffer = new Page[100000];\n\n\tpublic static void main(String[] args) {\n\t\twhile (true) {\n\t\t\tint N = sc.nextInt();\n\t\t\tif (N == 0) break;\n\t\t\tArrays.fill(buffer, null);\n\t\t\tint W = sc.nextInt();\n\t\t\tint H = sc.nextInt();\n\t\t\tPage[] pages = new Page[N];\n\t\t\tHashMap<String, Integer> map = new HashMap<String, Integer>();\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tString name = sc.next();\n\t\t\t\tmap.put(name, i);\n\t\t\t\tint b = sc.nextInt();\n\t\t\t\tpages[i] = new Page(name, b);\n\t\t\t\tfor (int j = 0; j < b; ++j) {\n\t\t\t\t\tint x1 = sc.nextInt();\n\t\t\t\t\tint y1 = sc.nextInt();\n\t\t\t\t\tint x2 = sc.nextInt();\n\t\t\t\t\tint y2 = sc.nextInt();\n\t\t\t\t\tpages[i].button[j] = new Rectangle(x1, y1, x2 - x1, y2 - y1);\n\t\t\t\t\tpages[i].linkTo[j] = sc.next();\n\t\t\t\t}\n\t\t\t}\n\t\t\tint bp = 0;\n\t\t\tbuffer[0] = pages[0];\n\t\t\tint M = sc.nextInt();\n\t\t\tfor (int i = 0; i < M; ++i) {\n\t\t\t\tString q = sc.next();\n\t\t\t\tif (q.equals(\"click\")) {\n\t\t\t\t\tint x = sc.nextInt();\n\t\t\t\t\tint y = sc.nextInt();\n\t\t\t\t\tfor (int j = 0; j < pages[bp].button.length; ++j) {\n\t\t\t\t\t\tif (pages[bp].button[j].contains(x, y)) {\n\t\t\t\t\t\t\tfor (int k = bp + 1; buffer[k] != null; ++k) {\n\t\t\t\t\t\t\t\tbuffer[k] = null;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbuffer[bp + 1] = pages[map.get(pages[bp].linkTo[j])];\n\t\t\t\t\t\t\t++bp;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else if (q.equals(\"back\")) {\n\t\t\t\t\tif (bp > 0) --bp;\n\t\t\t\t} else if (q.equals(\"forward\")) {\n\t\t\t\t\tif (buffer[bp + 1] != null) ++bp;\n\t\t\t\t} else if (q.equals(\"show\")) {\n\t\t\t\t\tSystem.out.println(buffer[bp].name);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic class Page {\n\t\tRectangle[] button;\n\t\tString[] linkTo;\n\t\tString name;\n\n\t\tPage(String name, int buttonCount) {\n\t\t\tthis.name = name;\n\t\t\tthis.button = new Rectangle[buttonCount];\n\t\t\tthis.linkTo = new String[buttonCount];\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.Rectangle;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Scanner;\n\npublic class Main {\n\n    /**\n     * @param args\n     */\n    public static void main(String[] args) throws java.io.IOException {\n        // TODO 自動生成されたメソッド・スタブ\n        Scanner sc = new Scanner(System.in);\n        while (true) {\n            int n = sc.nextInt();\n            if (n == 0)\n                break;\n            int w = sc.nextInt();\n            int h = sc.nextInt();\n            Page pages[] = new Page[n];\n            Map<String, Integer> index = new HashMap<String, Integer>();\n            // ページの作成\n            for (int i = 0; i < n; i++) {\n                String pagename = sc.next();\n                int b = sc.nextInt();\n                index.put(pagename, i);\n                pages[i] = new Page(pagename, b);\n                for (int j = 0; j < b; j++) {\n                    int x1 = sc.nextInt();\n                    int y1 = sc.nextInt();\n                    int x2 = sc.nextInt();\n                    int y2 = sc.nextInt();\n                    String linkname = sc.next();\n                    pages[i].mkBottan(j, x1, y1, x2, y2, linkname);\n                }\n            }\n            int it = 0;\n            int ord_num = sc.nextInt();\n            int back = 0;\n            int forward = 0;\n            for (int i = 0; i < ord_num; i++) {\n                String ordname = sc.next();\n                if (ordname.equals(\"click\")) {\n                    int x = sc.nextInt();\n                    int y = sc.nextInt();\n                    String linkedplace = pages[it].pageClicked(x, y);\n                    int next = index.get(linkedplace);\n                    if (next != it) {\n                        pages[it].setForwardPage(pages[next].getPageName());\n                        pages[next].setBackPage(pages[it].getPageName());\n                        it = next;\n                    }\n\n                }\n\n                else if (ordname.equals(\"back\")) {\n                    String linkedplace = pages[it].goBackPage();\n                    if (linkedplace != null) {\n                        it = index.get(linkedplace);\n                    }\n                } else if (ordname.equals(\"forward\")) {\n                    String linkedplace = pages[it].goForwardPage();\n                    if (linkedplace != null) {\n                        it = index.get(linkedplace);\n                    }\n                } else if (ordname.equals(\"show\")) {\n                    System.out.println(pages[it].getPageName());\n                }\n            }\n\n        }\n    }\n}\n\nclass Page {\n    private String pagename;\n    private Bottan[] bottans;\n    private int bottan_number;\n    private String back = \"\";\n    private String forward = \"\";\n\n    Page(String pagename, int b) {\n        this.pagename = pagename;\n        this.bottan_number = b;\n        bottans = new Bottan[b];\n    }\n\n    void mkBottan(int bnum, int x1, int y1, int x2, int y2, String linkname) {\n        bottans[bnum] = new Bottan(x1, y1, x2, y2, linkname);\n    }\n\n    String pageClicked(int x, int y) {\n        String jump = this.pagename;\n        for (int i = 0; i < bottan_number; i++) {\n            if (bottans[i].isInBottan(x, y)) {\n                jump = bottans[i].getLinkName();\n                break;\n            }\n        }\n        return jump;\n    }\n\n    String getPageName() {\n        return pagename;\n    }\n\n    String goBackPage() {\n        return back;\n    }\n\n    String goForwardPage() {\n        return forward;\n    }\n\n    void setBackPage(String back) {\n        this.back = back;\n    }\n\n    void setForwardPage(String forward) {\n        this.forward = forward;\n    }\n\n}\n\nclass Bottan {\n  private  String linkname;\n  private  Rectangle bottan;\n\n    Bottan(int x1, int y1, int x2, int y2, String linkname) {\n        this.linkname = linkname;\n        bottan = new Rectangle(x1, y1, x2 - x1+1, y2 - y1+1);\n    }\n\n    boolean isInBottan(int x, int y) {\n        return bottan.contains(x, y);\n    }\n\n    String getLinkName() {\n        return linkname;\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.HashMap;\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic class Page {\n\t\tString name;\n\t\tint bnum;\n\t\tLink link[];\n\t\tString linkName[];\n\t}\n\n\tstatic class Link {\n\t\tint x1, y1, x2, y2;\n\n\t\tLink(int x1, int y1, int x2, int y2) {\n\t\t\tthis.x1 = x1;\n\t\t\tthis.y1 = y1;\n\t\t\tthis.x2 = x2;\n\t\t\tthis.y2 = y2;\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n, m;\n\t\tint w, h;\n\t\tPage page[];\n\t\tHashMap<String, Integer> map = new HashMap<String, Integer>();\n\t\tint buf[];\n\t\tint bufMax;\n\t\tint pointer;\n\n\t\twhile (true) {\n\t\t\tn = sc.nextInt();\n\t\t\tif (n == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tw = sc.nextInt();\n\t\t\th = sc.nextInt();\n\t\t\tpage = new Page[n];\n\t\t\tmap.clear();\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tpage[i] = new Page();\n\t\t\t\tString name = sc.next();\n\t\t\t\tint lnum = sc.nextInt();\n\t\t\t\tpage[i].name = name;\n\t\t\t\tpage[i].bnum = lnum;\n\t\t\t\tpage[i].link = new Link[page[i].bnum];\n\t\t\t\tpage[i].linkName = new String[page[i].bnum];\n\t\t\t\tfor (int j = 0; j < page[i].bnum; j++) {\n\t\t\t\t\tint x1 = sc.nextInt();\n\t\t\t\t\tint y1 = sc.nextInt();\n\t\t\t\t\tint x2 = sc.nextInt();\n\t\t\t\t\tint y2 = sc.nextInt();\n\t\t\t\t\tString linkName = sc.next();\n\t\t\t\t\tpage[i].link[j] = new Link(x1, y1, x2, y2);\n\t\t\t\t\tpage[i].linkName[j] = linkName;\n\t\t\t\t}\n\t\t\t\tmap.put(name, i);\n\t\t\t}\n\n\t\t\tm = sc.nextInt();\n\t\t\tbuf = new int[10000];\n\t\t\tbufMax = 0;\n\t\t\tpointer = 0;\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tString order = sc.next();\n\t\t\t\tif (order.equals(\"click\")) {\n\t\t\t\t\tint x = sc.nextInt();\n\t\t\t\t\tint y = sc.nextInt();\n\t\t\t\t\tfor (int j = 0; j < page[pointer].bnum; j++) {\n\t\t\t\t\t\tif (page[pointer].link[j].x1 <= x && x <= page[pointer].link[j].x2 && \n\t\t\t\t\t\t\t\tpage[pointer].link[j].y1 <= y && y <= page[pointer].link[j].y2) {\n\t\t\t\t\t\t\tbuf[pointer + 1] = map.get(page[pointer].linkName[j]);\n\t\t\t\t\t\t\tbufMax++;\n\t\t\t\t\t\t\tpointer++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else if (order.equals(\"show\")) {\n\t\t\t\t\tSystem.out.println(page[pointer].name);\n\t\t\t\t} else if (order.equals(\"back\")) {\n\t\t\t\t\tif (0 < pointer) {\n\t\t\t\t\t\tpointer--;\n\t\t\t\t\t}\n\t\t\t\t} else if (order.equals(\"forward\")) {\n\t\t\t\t\tif (pointer < bufMax) {\n\t\t\t\t\t\tpointer++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.HashMap;\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic class Page {\n\t\tString name;\n\t\tint lnum;\n\t\tLink link[];\n\n\t\tPage(String name, int lnum) {\n\t\t\tthis.name = name;\n\t\t\tthis.lnum = lnum;\n\t\t}\n\t}\n\n\tstatic class Link {\n\t\tint x1, y1, x2, y2;\n\t\tString name;\n\n\t\tLink(int x1, int y1, int x2, int y2, String name) {\n\t\t\tthis.x1 = x1;\n\t\t\tthis.y1 = y1;\n\t\t\tthis.x2 = x2;\n\t\t\tthis.y2 = y2;\n\t\t\tthis.name = name;\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n, m;\n\t\tint w, h;\n\t\tPage page[];\n\t\tint buf[];\n\t\tint pointer;\n\t\tint bufMax;\n\t\tHashMap<String, Integer> map = new HashMap<String, Integer>();\n\n\t\twhile (true) {\n\t\t\tn = sc.nextInt();\n\t\t\tif (n == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tw = sc.nextInt();\n\t\t\th = sc.nextInt();\n\t\t\tpage = new Page[n];\n\t\t\tmap.clear();\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tString name = sc.next();\n\t\t\t\tint lnum = sc.nextInt();\n\t\t\t\tpage[i] = new Page(name, lnum);\n\t\t\t\tpage[i].link = new Link[lnum];\n\t\t\t\tfor (int j = 0; j < lnum; j++) {\n\t\t\t\t\tint x1 = sc.nextInt();\n\t\t\t\t\tint y1 = sc.nextInt();\n\t\t\t\t\tint x2 = sc.nextInt();\n\t\t\t\t\tint y2 = sc.nextInt();\n\t\t\t\t\tString linkName = sc.next();\n\t\t\t\t\tpage[i].link[j] = new Link(x1, y1, x2, y2, linkName);\n\t\t\t\t}\n\t\t\t\tmap.put(name, i);\n\t\t\t}\n\n\t\t\tm = sc.nextInt();\n\t\t\tbuf = new int[m + 5];\n\t\t\tpointer = 0;\n\t\t\tbufMax = 0;\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tString o = sc.next();\n\t\t\t\tif (o.equals(\"click\")) {\n\t\t\t\t\tint x = sc.nextInt();\n\t\t\t\t\tint y = sc.nextInt();\n\t\t\t\t\tfor (int j = 0; j < page[buf[pointer]].lnum; j++) {\n\t\t\t\t\t\tif (page[pointer].link[j].x1 <= x && x <= page[pointer].link[j].x2 &&\n\t\t\t\t\t\t\t\tpage[pointer].link[j].y1 <= y && y <= page[pointer].link[j].y2) {\n\t\t\t\t\t\t\tbuf[pointer + 1] = map.get(page[pointer].link[j].name);\n\t\t\t\t\t\t\tpointer++;\n\t\t\t\t\t\t\tbufMax = pointer;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else if (o.equals(\"show\")) {\n\t\t\t\t\tSystem.out.println(page[pointer].name);\n\t\t\t\t} else if (o.equals(\"back\")) {\n\t\t\t\t\tif (0 < pointer) {\n\t\t\t\t\t\tpointer--;\n\t\t\t\t\t}\n\t\t\t\t} else if (o.equals(\"forward\")) {\n\t\t\t\t\tif (pointer < bufMax) {\n\t\t\t\t\t\tpointer++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.HashMap;\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic class Page {\n\t\tString name;\n\t\tint lnum;\n\t\tLink link[];\n\n\t\tPage(String name, int lnum) {\n\t\t\tthis.name = name;\n\t\t\tthis.lnum = lnum;\n\t\t}\n\t}\n\n\tstatic class Link {\n\t\tint x1, y1, x2, y2;\n\t\tString name;\n\n\t\tLink(int x1, int y1, int x2, int y2, String name) {\n\t\t\tthis.x1 = x1;\n\t\t\tthis.y1 = y1;\n\t\t\tthis.x2 = x2;\n\t\t\tthis.y2 = y2;\n\t\t\tthis.name = name;\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n, m;\n\t\tint w, h;\n\t\tPage page[];\n\t\tint buf[];\n\t\tint pointer;\n\t\tint bufMax;\n\t\tHashMap<String, Integer> map = new HashMap<String, Integer>();\n\n\t\twhile (true) {\n\t\t\tn = sc.nextInt();\n\t\t\tif (n == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tw = sc.nextInt();\n\t\t\th = sc.nextInt();\n\t\t\tpage = new Page[n];\n\t\t\tmap.clear();\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tString name = sc.next();\n\t\t\t\tint lnum = sc.nextInt();\n\t\t\t\tpage[i] = new Page(name, lnum);\n\t\t\t\tpage[i].link = new Link[lnum];\n\t\t\t\tfor (int j = 0; j < lnum; j++) {\n\t\t\t\t\tint x1 = sc.nextInt();\n\t\t\t\t\tint y1 = sc.nextInt();\n\t\t\t\t\tint x2 = sc.nextInt();\n\t\t\t\t\tint y2 = sc.nextInt();\n\t\t\t\t\tString linkName = sc.next();\n\t\t\t\t\tpage[i].link[j] = new Link(x1, y1, x2, y2, linkName);\n\t\t\t\t}\n\t\t\t\tmap.put(name, i);\n\t\t\t}\n\n\t\t\tm = sc.nextInt();\n\t\t\tbuf = new int[m + 5];\n\t\t\tpointer = 0;\n\t\t\tbufMax = 0;\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tString o = sc.next();\n\t\t\t\tif (o.equals(\"click\")) {\n\t\t\t\t\tint x = sc.nextInt();\n\t\t\t\t\tint y = sc.nextInt();\n\t\t\t\t\tfor (int j = 0; j < page[buf[pointer]].lnum; j++) {\n\t\t\t\t\t\tif (page[buf[pointer]].link[j].x1 <= x && x <= page[buf[pointer]].link[j].x2 &&\n\t\t\t\t\t\t\t\tpage[buf[pointer]].link[j].y1 <= y && y <= page[buf[pointer]].link[j].y2) {\n\t\t\t\t\t\t\tbuf[pointer + 1] = map.get(page[buf[pointer]].link[j].name);\n\t\t\t\t\t\t\tpointer++;\n\t\t\t\t\t\t\tbufMax = pointer;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else if (o.equals(\"show\")) {\n\t\t\t\t\tSystem.out.println(page[pointer].name);\n\t\t\t\t} else if (o.equals(\"back\")) {\n\t\t\t\t\tif (0 < pointer) {\n\t\t\t\t\t\tpointer--;\n\t\t\t\t\t}\n\t\t\t\t} else if (o.equals(\"forward\")) {\n\t\t\t\t\tif (pointer < bufMax) {\n\t\t\t\t\t\tpointer++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.HashMap;\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic class Page {\n\t\tString name;\n\t\tint lnum;\n\t\tLink link[];\n\n\t\tPage(String name, int lnum) {\n\t\t\tthis.name = name;\n\t\t\tthis.lnum = lnum;\n\t\t}\n\t}\n\n\tstatic class Link {\n\t\tint x1, y1, x2, y2;\n\t\tString name;\n\n\t\tLink(int x1, int y1, int x2, int y2, String name) {\n\t\t\tthis.x1 = x1;\n\t\t\tthis.y1 = y1;\n\t\t\tthis.x2 = x2;\n\t\t\tthis.y2 = y2;\n\t\t\tthis.name = name;\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n, m;\n\t\tint w, h;\n\t\tPage page[];\n\t\tint buf[];\n\t\tint pointer;\n\t\tint bufMax;\n\t\tHashMap<String, Integer> map = new HashMap<String, Integer>();\n\n\t\twhile (true) {\n\t\t\tn = sc.nextInt();\n\t\t\tif (n == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tw = sc.nextInt();\n\t\t\th = sc.nextInt();\n\t\t\tpage = new Page[n];\n\t\t\tmap.clear();\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tString name = sc.next();\n\t\t\t\tint lnum = sc.nextInt();\n\t\t\t\tpage[i] = new Page(name, lnum);\n\t\t\t\tpage[i].link = new Link[lnum];\n\t\t\t\tfor (int j = 0; j < lnum; j++) {\n\t\t\t\t\tint x1 = sc.nextInt();\n\t\t\t\t\tint y1 = sc.nextInt();\n\t\t\t\t\tint x2 = sc.nextInt();\n\t\t\t\t\tint y2 = sc.nextInt();\n\t\t\t\t\tString linkName = sc.next();\n\t\t\t\t\tpage[i].link[j] = new Link(x1, y1, x2, y2, linkName);\n\t\t\t\t}\n\t\t\t\tmap.put(name, i);\n\t\t\t}\n\n\t\t\tm = sc.nextInt();\n\t\t\tbuf = new int[m + 5];\n\t\t\tpointer = 0;\n\t\t\tbufMax = 0;\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tString o = sc.next();\n\t\t\t\tif (o.equals(\"click\")) {\n\t\t\t\t\tint x = sc.nextInt();\n\t\t\t\t\tint y = sc.nextInt();\n\t\t\t\t\tfor (int j = 0; j < page[buf[pointer]].lnum; j++) {\n\t\t\t\t\t\tif (page[buf[pointer]].link[j].x1 <= x && x <= page[buf[pointer]].link[j].x2 &&\n\t\t\t\t\t\t\t\tpage[buf[pointer]].link[j].y1 <= y && y <= page[buf[pointer]].link[j].y2) {\n\t\t\t\t\t\t\tbuf[pointer + 1] = map.get(page[buf[pointer]].link[j].name);\n\t\t\t\t\t\t\tpointer++;\n\t\t\t\t\t\t\tbufMax = pointer;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else if (o.equals(\"show\")) {\n\t\t\t\t\tSystem.out.println(page[buf[pointer]].name);\n\t\t\t\t} else if (o.equals(\"back\")) {\n\t\t\t\t\tif (0 < pointer) {\n\t\t\t\t\t\tpointer--;\n\t\t\t\t\t}\n\t\t\t\t} else if (o.equals(\"forward\")) {\n\t\t\t\t\tif (pointer < bufMax) {\n\t\t\t\t\t\tpointer++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.Rectangle;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic Page[] buffer = new Page[1000001];\n\n\tpublic static void main(String[] args) {\n\t\twhile (true) {\n\t\t\tint N = sc.nextInt();\n\t\t\tif (N == 0) break;\n\t\t\tArrays.fill(buffer, null);\n\t\t\tint W = sc.nextInt();\n\t\t\tint H = sc.nextInt();\n\t\t\tPage[] pages = new Page[N];\n\t\t\tHashMap<String, Integer> map = new HashMap<String, Integer>();\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tString name = sc.next();\n\t\t\t\tmap.put(name, i);\n\t\t\t\tint b = sc.nextInt();\n\t\t\t\tpages[i] = new Page(name, b);\n\t\t\t\tfor (int j = 0; j < b; ++j) {\n\t\t\t\t\tint x1 = sc.nextInt();\n\t\t\t\t\tint y1 = sc.nextInt();\n\t\t\t\t\tint x2 = sc.nextInt();\n\t\t\t\t\tint y2 = sc.nextInt();\n\t\t\t\t\tpages[i].button[j] = new Rectangle(x1, y1, x2 - x1, y2 - y1);\n\t\t\t\t\tpages[i].linkTo[j] = sc.next();\n\t\t\t\t}\n\t\t\t}\n\t\t\tint bp = 0;\n\t\t\tbuffer[0] = pages[0];\n\t\t\tint M = sc.nextInt();\n\t\t\tfor (int i = 0; i < M; ++i) {\n\t\t\t\tString q = sc.next();\n\t\t\t\tif (q.equals(\"click\")) {\n\t\t\t\t\tint x = sc.nextInt();\n\t\t\t\t\tint y = sc.nextInt();\n\t\t\t\t\tfor (int j = 0; j < buffer[bp].button.length; ++j) {\n\t\t\t\t\t\tif (buffer[bp].button[j].contains(x, y)) {\n\t\t\t\t\t\t\tfor (int k = bp + 1; k < buffer.length && buffer[k] != null; ++k) {\n\t\t\t\t\t\t\t\tbuffer[k] = null;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbuffer[bp + 1] = pages[map.get(buffer[bp].linkTo[j])];\n\t\t\t\t\t\t\t++bp;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else if (q.equals(\"back\")) {\n\t\t\t\t\tif (bp > 0) --bp;\n\t\t\t\t} else if (q.equals(\"forward\")) {\n\t\t\t\t\tif (bp < buffer.length - 1 && buffer[bp + 1] != null) ++bp;\n\t\t\t\t} else if (q.equals(\"show\")) {\n\t\t\t\t\tSystem.out.println(buffer[bp].name);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic class Page {\n\t\tRectangle[] button;\n\t\tString[] linkTo;\n\t\tString name;\n\n\t\tPage(String name, int buttonCount) {\n\t\t\tthis.name = name;\n\t\t\tthis.button = new Rectangle[buttonCount];\n\t\t\tthis.linkTo = new String[buttonCount];\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Rectangle2D;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.ListIterator;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\t\n\tpublic static class Page{\n\t\tString page_name;\n\t\tint page_number;\n\t\tint[][] btns;\n\t\tint[] links;\n\t\t\n\t\tpublic Page(String page_name, int page_number, int[][] btns, int[] links) {\n\t\t\tsuper();\n\t\t\tthis.page_name = page_name;\n\t\t\tthis.page_number = page_number;\n\t\t\tthis.btns = btns;\n\t\t\tthis.links = links;\n\t\t}\n\t\t\n\t\tpublic int touch(int x, int y){\n\t\t\tfor(int i = 0; i < btns.length; i++){\n\t\t\t\tfinal int lu_x = btns[i][0];\n\t\t\t\tfinal int lu_y = btns[i][1];\n\t\t\t\tfinal int rd_x = btns[i][2];\n\t\t\t\tfinal int rd_y = btns[i][3];\n\t\t\t\t\n\t\t\t\tif(lu_x <= x && x <= rd_x && lu_y <= y && y <= rd_y){\n\t\t\t\t\treturn links[i]; \n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn -1;\n\t\t}\n\t}\n\t\n\t\n\tpublic static void main(String[] args) {\n\t\tfinal Scanner sc = new Scanner(System.in);\n\t\t\n\t\twhile(true){\n\t\t\tfinal int n = sc.nextInt();\n\t\t\t\n\t\t\tif(n == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tfinal int W = sc.nextInt();\n\t\t\tfinal int H = sc.nextInt();\n\t\t\t\n\t\t\tString[] name = new String[n];\n\t\t\tint[] btns = new int[n];\n\t\t\tint[][][] rects = new int[n][][];\n\t\t\tString[][] links = new String[n][];\n\t\t\t\n\t\t\tHashMap<String, Integer> map = new HashMap<String, Integer>();\n\t\t\t\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tname[i] = sc.next();\n\t\t\t\tfinal int k = sc.nextInt();\n\t\t\t\tbtns[i] = k;\n\t\t\t\t\n\t\t\t\trects[i] = new int[k][4];\n\t\t\t\tlinks[i] = new String[k];\n\t\t\t\tfor(int j = 0; j < k; j++){\n\t\t\t\t\trects[i][j][0] = sc.nextInt();\n\t\t\t\t\trects[i][j][1] = sc.nextInt();\n\t\t\t\t\trects[i][j][2] = sc.nextInt();\n\t\t\t\t\trects[i][j][3] = sc.nextInt();\n\t\t\t\t\tlinks[i][j] = sc.next();\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tmap.put(name[i], i);\n\t\t\t}\n\t\t\t\n\t\t\tPage[] pages = new Page[n];\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tint[] link = new int[btns[i]];\n\t\t\t\tfor(int j = 0; j < btns[i]; j++){\n\t\t\t\t\tlink[j] = map.get(links[i][j]);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tpages[i] = new Page(name[i], i, rects[i], link);\n\t\t\t}\n\t\t\t\n\t\t\tArrayList<Integer> history = new ArrayList<Integer>();\n\t\t\thistory.add(0);\n\t\t\tint size = 1;\n\t\t\tint cur_pos = 0;\n\t\t\t\n\t\t\tint cur_page = 0;\n\t\t\tfinal int q = sc.nextInt();\n\t\t\tfor(int t = 0; t < q; t++){\n\t\t\t\tString input = sc.next();\n\t\t\t\t\n\t\t\t\tif(\"forward\".equals(input)){\n\t\t\t\t\tif(cur_pos < size - 1){\n\t\t\t\t\t\tcur_pos++;\n\t\t\t\t\t\tcur_page = history.get(cur_pos);\n\t\t\t\t\t}\n\t\t\t\t}else if(\"back\".equals(input)){\n\t\t\t\t\tif(cur_pos > 0){\n\t\t\t\t\t\tcur_pos--;\n\t\t\t\t\t\tcur_page = history.get(cur_pos);\n\t\t\t\t\t}\n\t\t\t\t}else if(\"click\".equals(input)){\n\t\t\t\t\tfinal int x = sc.nextInt();\n\t\t\t\t\tfinal int y = sc.nextInt();\n\t\t\t\t\t\n\t\t\t\t\tint ret = pages[cur_page].touch(x, y);\n\t\t\t\t\t\n\t\t\t\t\tif(ret >= 0){\n\t\t\t\t\t\tcur_pos++;\n\t\t\t\t\t\thistory.add(cur_pos, cur_pos);\n\t\t\t\t\t\tsize = cur_pos + 1;\n\t\t\t\t\t\t\n\t\t\t\t\t\tcur_page = ret;\n\t\t\t\t\t}\n\t\t\t\t}else if(\"show\".equals(input)){\n\t\t\t\t\tSystem.out.println(pages[cur_page].page_name);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.*;\n\nimport static java.lang.Integer.parseInt;\n\n/**\n * Problem D: Distorted Love\n */\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString line;\n\t\tString[] words;\n\n\t\tComparator<int[]> cmp = new Comparator<int[]>() {\n\t\t\t@Override\n\t\t\tpublic int compare(int[] o1, int[] o2) {\n\t\t\t\tif (o1[0] != o2[0]) {\n\t\t\t\t\treturn Integer.compare(o1[0], o2[0]);\n\t\t\t\t} else {\n\t\t\t\t\treturn Integer.compare(o1[1], o2[1]);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\t\n\t\twhile ((line = br.readLine()) != null && !line.isEmpty()) {\n\n\t\t\tint n = parseInt(line);\n\t\t\tif (n == 0) break;\n\n\t\t\t//????????¨??????\n\t\t\tbr.readLine();\n\n\t\t\tMap<String, NavigableMap<int[], String>> pages = new HashMap<>();\n\t\t\tDeque<String> stackF, stackB;\n\t\t\tstackF = new ArrayDeque<>();\n\t\t\tstackB = new ArrayDeque<>();\n\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\twords = br.readLine().split(\" \");\n\n\t\t\t\tString name = words[0];\n\t\t\t\tint b = parseInt(words[1]);\n\n\t\t\t\tpages.put(name, new TreeMap<>(cmp));\n\n\t\t\t\tfor (int j = 0; j < b; j++) {\n\t\t\t\t\twords = br.readLine().split(\" \");\n\t\t\t\t\tint[] pos = new int[4];\n\t\t\t\t\tfor (int k = 0; k < 4; k++) {\n\t\t\t\t\t\tpos[k] = parseInt(words[k]);\n\t\t\t\t\t}\n\t\t\t\t\tpages.get(name).put(pos, words[4]);\n\t\t\t\t}\n\t\t\t\tif (i == 0) {\n\t\t\t\t\tstackF.push(name);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint m = parseInt(br.readLine());\n\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\twords = br.readLine().split(\" \");\n\n\t\t\t\tString op = words[0];\n\n\t\t\t\tswitch (op) {\n\t\t\t\t\tcase \"click\":\n\t\t\t\t\t\tint x = parseInt(words[1]);\n\t\t\t\t\t\tint y = parseInt(words[2]);\n\t\t\t\t\t\tString page = stackF.peek();\n\t\t\t\t\t\tNavigableMap<int[], String> buttons = pages.get(page);\n\t\t\t\t\t\tint[] button = buttons.floorKey(new int[]{x, y});\n\t\t\t\t\t\tif (button != null) {\n\t\t\t\t\t\t\tstackF.push(buttons.get(button));\n\t\t\t\t\t\t\tstackB.clear();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"back\":\n\t\t\t\t\t\tstackB.push(stackF.pop());\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"forward\":\n\t\t\t\t\t\tstackF.push(stackB.pop());\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"show\":\n\t\t\t\t\t\tSystem.out.println(stackF.peek());\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Rectangle2D;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.ListIterator;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\t\n\tpublic static class Page{\n\t\tString page_name;\n\t\tint page_number;\n\t\tint[][] btns;\n\t\tint[] links;\n\t\t\n\t\tpublic Page(String page_name, int page_number, int[][] btns, int[] links) {\n\t\t\tsuper();\n\t\t\tthis.page_name = page_name;\n\t\t\tthis.page_number = page_number;\n\t\t\tthis.btns = btns;\n\t\t\tthis.links = links;\n\t\t}\n\t\t\n\t\tpublic int touch(int x, int y){\n\t\t\tfor(int i = 0; i < btns.length; i++){\n\t\t\t\tfinal int lu_x = btns[i][0];\n\t\t\t\tfinal int lu_y = btns[i][1];\n\t\t\t\tfinal int rd_x = btns[i][2];\n\t\t\t\tfinal int rd_y = btns[i][3];\n\t\t\t\t\n\t\t\t\tif(lu_x <= x && x <= rd_x && lu_y <= y && y <= rd_y){\n\t\t\t\t\treturn links[i]; \n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn -1;\n\t\t}\n\t}\n\t\n\t\n\tpublic static void main(String[] args) {\n\t\tfinal Scanner sc = new Scanner(System.in);\n\t\t\n\t\twhile(true){\n\t\t\tfinal int n = sc.nextInt();\n\t\t\t\n\t\t\tif(n == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tfinal int W = sc.nextInt();\n\t\t\tfinal int H = sc.nextInt();\n\t\t\t\n\t\t\tString[] name = new String[n];\n\t\t\tint[] btns = new int[n];\n\t\t\tint[][][] rects = new int[n][][];\n\t\t\tString[][] links = new String[n][];\n\t\t\t\n\t\t\tHashMap<String, Integer> map = new HashMap<String, Integer>();\n\t\t\t\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tname[i] = sc.next();\n\t\t\t\tfinal int k = sc.nextInt();\n\t\t\t\tbtns[i] = k;\n\t\t\t\t\n\t\t\t\trects[i] = new int[k][4];\n\t\t\t\tlinks[i] = new String[k];\n\t\t\t\tfor(int j = 0; j < k; j++){\n\t\t\t\t\trects[i][j][0] = sc.nextInt();\n\t\t\t\t\trects[i][j][1] = sc.nextInt();\n\t\t\t\t\trects[i][j][2] = sc.nextInt();\n\t\t\t\t\trects[i][j][3] = sc.nextInt();\n\t\t\t\t\tlinks[i][j] = sc.next();\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tmap.put(name[i], i);\n\t\t\t}\n\t\t\t\n\t\t\tPage[] pages = new Page[n];\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tint[] link = new int[btns[i]];\n\t\t\t\tfor(int j = 0; j < btns[i]; j++){\n\t\t\t\t\tlink[j] = map.get(links[i][j]);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tpages[i] = new Page(name[i], i, rects[i], link);\n\t\t\t}\n\t\t\t\n\t\t\tArrayList<Integer> history = new ArrayList<Integer>();\n\t\t\thistory.add(0);\n\t\t\tint size = 1;\n\t\t\tint cur_pos = 0;\n\t\t\t\n\t\t\tint cur_page = 0;\n\t\t\tfinal int q = sc.nextInt();\n\t\t\tfor(int t = 0; t < q; t++){\n\t\t\t\tString input = sc.next();\n\t\t\t\t\n\t\t\t\tif(\"forward\".equals(input)){\n\t\t\t\t\tif(cur_pos < size - 1){\n\t\t\t\t\t\tcur_pos++;\n\t\t\t\t\t\tcur_page = history.get(cur_pos);\n\t\t\t\t\t}\n\t\t\t\t}else if(\"back\".equals(input)){\n\t\t\t\t\tif(cur_pos > 0){\n\t\t\t\t\t\tcur_pos--;\n\t\t\t\t\t\tcur_page = history.get(cur_pos);\n\t\t\t\t\t}\n\t\t\t\t}else if(\"click\".equals(input)){\n\t\t\t\t\tfinal int x = sc.nextInt();\n\t\t\t\t\tfinal int y = sc.nextInt();\n\t\t\t\t\t\n\t\t\t\t\tint ret = pages[cur_page].touch(x, y);\n\t\t\t\t\t\n\t\t\t\t\tif(ret >= 0){\n\t\t\t\t\t\tcur_pos++;\n\t\t\t\t\t\tcur_page = ret;\n\t\t\t\t\t\thistory.add(cur_page, cur_pos);\n\t\t\t\t\t\tsize = cur_pos + 1;\n\t\t\t\t\t\t\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t}else if(\"show\".equals(input)){\n\t\t\t\t\tSystem.out.println(pages[cur_page].page_name);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.*;\n\nimport static java.lang.Integer.parseInt;\n\n/**\n * Problem D: Distorted Love\n */\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString line;\n\t\tString[] words;\n\n\t\twhile ((line = br.readLine()) != null && !line.isEmpty()) {\n\n\t\t\tint n = parseInt(line);\n\t\t\tif (n == 0) break;\n\n\t\t\t//????????¨??????\n\t\t\tbr.readLine();\n\n\t\t\tMap<String, Map<int[], String>> pages = new HashMap<>();\n\t\t\tDeque<String> stackF, stackB;\n\t\t\tstackF = new ArrayDeque<>();\n\t\t\tstackB = new ArrayDeque<>();\n\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\twords = br.readLine().split(\" \");\n\n\t\t\t\tString name = words[0];\n\t\t\t\tint b = parseInt(words[1]);\n\n\t\t\t\tpages.put(name, new HashMap<>());\n\n\t\t\t\tfor (int j = 0; j < b; j++) {\n\t\t\t\t\twords = br.readLine().split(\" \");\n\t\t\t\t\tint[] pos = new int[4];\n\t\t\t\t\tfor (int k = 0; k < 4; k++) {\n\t\t\t\t\t\tpos[k] = parseInt(words[k]);\n\t\t\t\t\t}\n\t\t\t\t\tpages.get(name).put(pos, words[4]);\n\t\t\t\t}\n\t\t\t\tif (i == 0) {\n\t\t\t\t\tstackF.push(name);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint m = parseInt(br.readLine());\n\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\twords = br.readLine().split(\" \");\n\n\t\t\t\tString op = words[0];\n\n\t\t\t\tswitch (op) {\n\t\t\t\t\tcase \"click\":\n\t\t\t\t\t\tint x = parseInt(words[1]);\n\t\t\t\t\t\tint y = parseInt(words[2]);\n\t\t\t\t\t\tString page = stackF.peek();\n\t\t\t\t\t\tMap<int[], String> btns = pages.get(page);\n\t\t\t\t\t\tfor (int[] btn : btns.keySet()) {\n\t\t\t\t\t\t\tif (btn[0] <= x && x <= btn[2]\n\t\t\t\t\t\t\t\t\t&& btn[1] <= y && y <= btn[3]) {\n\t\t\t\t\t\t\t\tstackF.push(btns.get(btn));\n\t\t\t\t\t\t\t\tstackB.clear();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"back\":\n\t\t\t\t\t\tif (!stackF.isEmpty()) {\n\t\t\t\t\t\t\tstackB.push(stackF.pop());\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"forward\":\n\t\t\t\t\t\tif (!stackB.isEmpty()) {\n\t\t\t\t\t\t\tstackF.push(stackB.pop());\n\t\t\t\t\t\t} break;\n\t\t\t\t\tcase \"show\":\n\t\t\t\t\t\tSystem.out.println(stackF.peek());\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.HashMap;\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic class Page {\n\t\tString name;\n\t\tint bnum;\n\t\tLink link[];\n\t\tString linkName[];\n\t}\n\n\tstatic class Link {\n\t\tint x1, y1, x2, y2;\n\n\t\tLink(int x1, int y1, int x2, int y2) {\n\t\t\tthis.x1 = x1;\n\t\t\tthis.y1 = y1;\n\t\t\tthis.x2 = x2;\n\t\t\tthis.y2 = y2;\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n, m;\n\t\tint w, h;\n\t\tPage page[];\n\t\tHashMap<String, Integer> map = new HashMap<String, Integer>();\n\t\tint buf[];\n\t\tint bufMax;\n\t\tint pointer;\n\n\t\twhile (true) {\n\t\t\tn = sc.nextInt();\n\t\t\tif (n == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tw = sc.nextInt();\n\t\t\th = sc.nextInt();\n\t\t\tpage = new Page[n];\n\t\t\tmap.clear();\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tpage[i] = new Page();\n\t\t\t\tString name = sc.next();\n\t\t\t\tint lnum = sc.nextInt();\n\t\t\t\tpage[i].name = name;\n\t\t\t\tpage[i].bnum = lnum;\n\t\t\t\tpage[i].link = new Link[page[i].bnum];\n\t\t\t\tpage[i].linkName = new String[page[i].bnum];\n\t\t\t\tfor (int j = 0; j < page[i].bnum; j++) {\n\t\t\t\t\tint x1 = sc.nextInt();\n\t\t\t\t\tint y1 = sc.nextInt();\n\t\t\t\t\tint x2 = sc.nextInt();\n\t\t\t\t\tint y2 = sc.nextInt();\n\t\t\t\t\tString linkName = sc.next();\n\t\t\t\t\tpage[i].link[j] = new Link(x1, y1, x2, y2);\n\t\t\t\t\tpage[i].linkName[j] = linkName;\n\t\t\t\t}\n\t\t\t\tmap.put(name, i);\n\t\t\t}\n\n\t\t\tm = sc.nextInt();\n\t\t\tbuf = new int[10000000];\n\t\t\tbufMax = 0;\n\t\t\tpointer = 0;\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tString order = sc.next();\n\t\t\t\tif (order.equals(\"click\")) {\n\t\t\t\t\tint x = sc.nextInt();\n\t\t\t\t\tint y = sc.nextInt();\n\t\t\t\t\tfor (int j = 0; j < page[pointer].bnum; j++) {\n\t\t\t\t\t\tif (page[pointer].link[j].x1 <= x && x <= page[pointer].link[j].x2 && \n\t\t\t\t\t\t\t\tpage[pointer].link[j].y1 <= y && y <= page[pointer].link[j].y2) {\n\t\t\t\t\t\t\tbuf[pointer + 1] = map.get(page[pointer].linkName[j]);\n\t\t\t\t\t\t\tbufMax++;\n\t\t\t\t\t\t\tpointer++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else if (order.equals(\"show\")) {\n\t\t\t\t\tSystem.out.println(page[pointer].name);\n\t\t\t\t} else if (order.equals(\"back\")) {\n\t\t\t\t\tif (0 < pointer) {\n\t\t\t\t\t\tpointer--;\n\t\t\t\t\t}\n\t\t\t\t} else if (order.equals(\"forward\")) {\n\t\t\t\t\tif (pointer < bufMax) {\n\t\t\t\t\t\tpointer++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.Rectangle;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic Page[] buffer = new Page[100001];\n\n\tpublic static void main(String[] args) {\n\t\twhile (true) {\n\t\t\tint N = sc.nextInt();\n\t\t\tif (N == 0) break;\n\t\t\tArrays.fill(buffer, null);\n\t\t\tint W = sc.nextInt();\n\t\t\tint H = sc.nextInt();\n\t\t\tPage[] pages = new Page[N];\n\t\t\tHashMap<String, Integer> map = new HashMap<String, Integer>();\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tString name = sc.next();\n\t\t\t\tmap.put(name, i);\n\t\t\t\tint b = sc.nextInt();\n\t\t\t\tpages[i] = new Page(name, b);\n\t\t\t\tfor (int j = 0; j < b; ++j) {\n\t\t\t\t\tint x1 = sc.nextInt();\n\t\t\t\t\tint y1 = sc.nextInt();\n\t\t\t\t\tint x2 = sc.nextInt();\n\t\t\t\t\tint y2 = sc.nextInt();\n\t\t\t\t\tpages[i].button[j] = new Rectangle(x1, y1, x2 - x1, y2 - y1);\n\t\t\t\t\tpages[i].linkTo[j] = sc.next();\n\t\t\t\t}\n\t\t\t}\n\t\t\tint bp = 0;\n\t\t\tbuffer[0] = pages[0];\n\t\t\tint M = sc.nextInt();\n\t\t\tfor (int i = 0; i < M; ++i) {\n\t\t\t\tString q = sc.next();\n\t\t\t\tif (q.equals(\"click\")) {\n\t\t\t\t\tint x = sc.nextInt();\n\t\t\t\t\tint y = sc.nextInt();\n\t\t\t\t\tfor (int j = 0; j < buffer[bp].button.length; ++j) {\n\t\t\t\t\t\tif (buffer[bp].button[j].contains(x, y)) {\n\t\t\t\t\t\t\tfor (int k = bp + 1; k < buffer.length && buffer[k] != null; ++k) {\n\t\t\t\t\t\t\t\tbuffer[k] = null;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbuffer[bp + 1] = pages[map.get(buffer[bp].linkTo[j])];\n\t\t\t\t\t\t\t++bp;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else if (q.equals(\"back\")) {\n\t\t\t\t\tif (bp > 0) --bp;\n\t\t\t\t} else if (q.equals(\"forward\")) {\n\t\t\t\t\tif (bp < buffer.length - 1 && buffer[bp + 1] != null) ++bp;\n\t\t\t\t} else if (q.equals(\"show\")) {\n\t\t\t\t\tSystem.out.println(buffer[bp].name);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic class Page {\n\t\tRectangle[] button;\n\t\tString[] linkTo;\n\t\tString name;\n\n\t\tPage(String name, int buttonCount) {\n\t\t\tthis.name = name;\n\t\t\tthis.button = new Rectangle[buttonCount];\n\t\t\tthis.linkTo = new String[buttonCount];\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Rectangle2D;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.ListIterator;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\t\n\tpublic static class Page{\n\t\tString page_name;\n\t\tint page_number;\n\t\tint[][] btns;\n\t\tint[] links;\n\t\t\n\t\tpublic Page(String page_name, int page_number, int[][] btns, int[] links) {\n\t\t\tsuper();\n\t\t\tthis.page_name = page_name;\n\t\t\tthis.page_number = page_number;\n\t\t\tthis.btns = btns;\n\t\t\tthis.links = links;\n\t\t}\n\t\t\n\t\tpublic int touch(int x, int y){\n\t\t\tfor(int i = 0; i < btns.length; i++){\n\t\t\t\tfinal int lu_x = btns[i][0];\n\t\t\t\tfinal int lu_y = btns[i][1];\n\t\t\t\tfinal int rd_x = btns[i][2];\n\t\t\t\tfinal int rd_y = btns[i][3];\n\t\t\t\t\n\t\t\t\tif(lu_x <= x && x <= rd_x && lu_y <= y && y <= rd_y){\n\t\t\t\t\treturn links[i]; \n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn -1;\n\t\t}\n\t}\n\t\n\t\n\tpublic static void main(String[] args) {\n\t\tfinal Scanner sc = new Scanner(System.in);\n\t\t\n\t\twhile(true){\n\t\t\tfinal int n = sc.nextInt();\n\t\t\t\n\t\t\tif(n == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tfinal int W = sc.nextInt();\n\t\t\tfinal int H = sc.nextInt();\n\t\t\t\n\t\t\tString[] name = new String[n];\n\t\t\tint[] btns = new int[n];\n\t\t\tint[][][] rects = new int[n][][];\n\t\t\tString[][] links = new String[n][];\n\t\t\t\n\t\t\tHashMap<String, Integer> map = new HashMap<String, Integer>();\n\t\t\t\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tname[i] = sc.next();\n\t\t\t\tfinal int k = sc.nextInt();\n\t\t\t\tbtns[i] = k;\n\t\t\t\t\n\t\t\t\trects[i] = new int[k][4];\n\t\t\t\tlinks[i] = new String[k];\n\t\t\t\tfor(int j = 0; j < k; j++){\n\t\t\t\t\trects[i][j][0] = sc.nextInt();\n\t\t\t\t\trects[i][j][1] = sc.nextInt();\n\t\t\t\t\trects[i][j][2] = sc.nextInt();\n\t\t\t\t\trects[i][j][3] = sc.nextInt();\n\t\t\t\t\tlinks[i][j] = sc.next();\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tmap.put(name[i], i);\n\t\t\t}\n\t\t\t\n\t\t\tPage[] pages = new Page[n];\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tint[] link = new int[btns[i]];\n\t\t\t\tfor(int j = 0; j < btns[i]; j++){\n\t\t\t\t\tlink[j] = map.get(links[i][j]);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tpages[i] = new Page(name[i], i, rects[i], link);\n\t\t\t}\n\t\t\t\n\t\t\tLinkedList<Integer> history = new LinkedList<Integer>();\n\t\t\thistory.add(0);\n\t\t\tint cur_pos = 0;\n\t\t\t\n\t\t\tint cur_page = 0;\n\t\t\tfinal int q = sc.nextInt();\n\t\t\tfor(int t = 0; t < q; t++){\n\t\t\t\tString input = sc.next();\n\t\t\t\t\n\t\t\t\tif(\"forward\".equals(input)){\n\t\t\t\t\tif(cur_pos < history.size() - 1){\n\t\t\t\t\t\tcur_pos++;\n\t\t\t\t\t\tcur_page = history.get(cur_pos);\n\t\t\t\t\t}\n\t\t\t\t}else if(\"back\".equals(input)){\n\t\t\t\t\tif(cur_pos > 0){\n\t\t\t\t\t\tcur_pos--;\n\t\t\t\t\t\tcur_page = history.get(cur_pos);\n\t\t\t\t\t}\n\t\t\t\t}else if(\"click\".equals(input)){\n\t\t\t\t\tfinal int x = sc.nextInt();\n\t\t\t\t\tfinal int y = sc.nextInt();\n\t\t\t\t\t\n\t\t\t\t\tint ret = pages[cur_page].touch(x, y);\n\t\t\t\t\t\n\t\t\t\t\tif(ret >= 0){\n\t\t\t\t\t\thistory.add(cur_page);\n\t\t\t\t\t\tcur_pos++;\n\t\t\t\t\t\t\n\t\t\t\t\t\twhile(history.size() > cur_pos){\n\t\t\t\t\t\t\thistory.removeLast();\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tcur_page = ret;\n\t\t\t\t\t}\n\t\t\t\t}else if(\"show\".equals(input)){\n\t\t\t\t\tSystem.out.println(pages[cur_page].page_name);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\n\nclass Page{\n \n    String name;\n    int n,btnn;\n    int[][] b;\n    String[] linkpage;\n    public Page(int n,String name,int btnn,int[][] b,String[] linkpage){\n\tthis.n=n;this.name=name;this.btnn=btnn;this.b=b;this.linkpage=linkpage;\n    }\n}\n\n\n\nclass Main{\n   boolean debug=false;\n    int n,w,h;\n    HashMap<String,Integer> map;\n\n    void run(){\n\tScanner sc=new Scanner(System.in);\n\twhile(true){\n\t    n=sc.nextInt();if(n==0)break;\n\t    w=sc.nextInt();h=sc.nextInt();\n\t    Page[] a=new Page[n];\n\t    map=new HashMap<String,Integer>();\n\t    for(int k=0;k<n;k++){\n\t\tString name=sc.next();\n\t\tint btnn=sc.nextInt();\n\t\tint[][] b=new int[btnn][4];\n\t\tString[] linkpage=new String[btnn];\n\t\tfor(int i=0;i<btnn;i++){\n\t\t    b[i][0]=sc.nextInt();b[i][1]=sc.nextInt();\n\t\t    b[i][2]=sc.nextInt();b[i][3]=sc.nextInt();\n\t\t    linkpage[i]=sc.next();\n\t\t}\n\t\ta[k]=new Page(k,name,btnn,b,linkpage);\n\t    }\n\t    for(int i=0;i<n;i++){\n\t\tString name=a[i].name;\n\t\tmap.put(name,i);//名前ーページ番号\n\t    }\n\n\t    int m=sc.nextInt();\n\t    LinkedList<Integer> rireki=new LinkedList<Integer>();\n\t    Page cnt=a[0];int pt=0;rireki.add(0);\n\t    for(int i=0;i<m;i++){\n\t\tchar command=sc.next().charAt(0);\n\t\tswitch(command){\n\t\t\tcase 'c':{\n\t\t    int x=sc.nextInt();int y=sc.nextInt();\n\t\t    if(debug)System.out.printf(\"cnt.btnn=%d x=%d y=%d cnt.b[0][0]=%d \\n\",cnt.btnn,x,y,cnt.b[0][0]);\n\t\t    for(int k=0;k<cnt.btnn;k++){\n\t\t\tif(inrange(cnt.b[k],x,y)){\n\t\t\t    while(rireki.size()>pt+1)rireki.removeLast();\n\t\t\t    cnt=a[map.get(cnt.linkpage[k])];\n\t\t\t    rireki.add(cnt.n);if(debug)System.out.printf(\"pppp \\n\");\n\t\t\t    pt++;\n\t\t\t    break;\n\t\t\t}}\n\t\t    break;\n\t\t}\n\t\tcase 'b':{if(pt>0)pt--;cnt=a[rireki.get(pt)];break;}\n\t\tcase 'f':{if(pt<rireki.size()-1)pt++;cnt=a[rireki.get(pt)];break;}\n\t\tcase 's':{System.out.println(cnt.name);\n\t\t\tif(debug)System.out.printf(\"size=%d cnt.n=%d cnt.name=%s pt=%d \\n\",rireki.size(),cnt.n,cnt.name,pt);break;}\n\t\t}\n\t    }\n\t}\n    }\n\n    boolean inrange(int[] b,int x,int y){\n\treturn x>=b[0] && x<=b[2] && y<=b[3] && y>=b[1];\n    }\n\n    public static void main(String[] args){\n\tnew Main().run();\n    }}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner in = new Scanner(System.in);\n\t\tint n;\n\t\tMap<String, List<Button>> map = new HashMap<String, List<Button>>();\n\t\tLinkedList<String> pre = new LinkedList<String>();\n\t\tLinkedList<String> next = new LinkedList<String>();\n\t\tString now = \"\";\n\t\twhile ((n = in.nextInt()) != 0) {\n\t\t\tmap.clear();\n\t\t\tpre.clear();\n\t\t\tnext.clear();\n\t\t\tint w = in.nextInt();\n\t\t\tint h = in.nextInt();\n\t\t\tfor (int page_info = 0; page_info < n; page_info++) {\n\t\t\t\tString pageName = in.next();\n\t\t\t\tif (page_info == 0) {\n\t\t\t\t\tnow = pageName;\n\t\t\t\t}\n\t\t\t\tint bt_count = in.nextInt();\n\t\t\t\tList<Button> buttons = new ArrayList<Button>();\n\t\t\t\tfor (int i = 0; i < bt_count; i++) {\n\t\t\t\t\tbuttons.add(new Button(in.nextInt(), in.nextInt(), in\n\t\t\t\t\t\t\t.nextInt(), in.nextInt(), in.next()));\n\t\t\t\t}\n\t\t\t\tmap.put(pageName, buttons);\n\t\t\t}\n\t\t\tint m = in.nextInt();\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tString command = in.next();\n\t\t\t\tif (\"click\".equals(command)) {\n\t\t\t\t\tint x = in.nextInt();\n\t\t\t\t\tint y = in.nextInt();\n\t\t\t\t\tfor (Button bt : map.get(now)) {\n\t\t\t\t\t\tif (bt.c(x, y)) {\n\t\t\t\t\t\t\tpre.addLast(now);\n\t\t\t\t\t\t\tnow = bt.target;\n\t\t\t\t\t\t\tnext.clear();\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else if (\"back\".equals(command)) {\n\t\t\t\t\tif (!pre.isEmpty()) {\n\t\t\t\t\t\tnext.addFirst(now);\n\t\t\t\t\t\tnow = pre.pollLast();\n\t\t\t\t\t}\n\t\t\t\t} else if (\"forward\".equals(command)) {\n\t\t\t\t\tif (!next.isEmpty()) {\n\t\t\t\t\t\tpre.addLast(now);\n\t\t\t\t\t\tnow = next.pollFirst();\n\t\t\t\t\t}\n\t\t\t\t} else if (\"show\".equals(command)) {\n\t\t\t\t\tassert true;\n\t\t\t\t\tSystem.out.println(now);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n}\n\nclass Button {\n\tfinal int minX, minY, maxX, maxY;\n\tfinal String target;\n\n\tButton(int minX, int minY, int maxX, int maxY, String target) {\n\t\tthis.minX = minX;\n\t\tthis.minY = minY;\n\t\tthis.maxX = maxX;\n\t\tthis.maxY = maxY;\n\t\tthis.target = target;\n\t}\n\n\tboolean c(int x, int y) {\n\t\treturn (minX <= x && x <= maxX && minY <= y && y <= maxY);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.HashMap;\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic class Page {\n\t\tString name;\n\t\tint lnum;\n\t\tLink link[];\n\n\t\tPage(String name, int lnum) {\n\t\t\tthis.name = name;\n\t\t\tthis.lnum = lnum;\n\t\t}\n\t}\n\n\tstatic class Link {\n\t\tint x1, y1, x2, y2;\n\t\tString name;\n\n\t\tLink(int x1, int y1, int x2, int y2, String name) {\n\t\t\tthis.x1 = x1;\n\t\t\tthis.y1 = y1;\n\t\t\tthis.x2 = x2;\n\t\t\tthis.y2 = y2;\n\t\t\tthis.name = name;\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n, m;\n\t\tint w, h;\n\t\tPage page[];\n\t\tint buf[];\n\t\tint pointer;\n\t\tint bufMax;\n\t\tHashMap<String, Integer> map = new HashMap<String, Integer>();\n\n\t\twhile (true) {\n\t\t\tn = sc.nextInt();\n\t\t\tif (n == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tw = sc.nextInt();\n\t\t\th = sc.nextInt();\n\t\t\tpage = new Page[n];\n\t\t\tmap.clear();\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tString name = sc.next();\n\t\t\t\tint lnum = sc.nextInt();\n\t\t\t\tpage[i] = new Page(name, lnum);\n\t\t\t\tpage[i].link = new Link[lnum];\n\t\t\t\tfor (int j = 0; j < lnum; j++) {\n\t\t\t\t\tint x1 = sc.nextInt();\n\t\t\t\t\tint y1 = sc.nextInt();\n\t\t\t\t\tint x2 = sc.nextInt();\n\t\t\t\t\tint y2 = sc.nextInt();\n\t\t\t\t\tString linkName = sc.next();\n\t\t\t\t\tpage[i].link[j] = new Link(x1, y1, x2, y2, linkName);\n\t\t\t\t}\n\t\t\t\tmap.put(name, i);\n\t\t\t}\n\n\t\t\tm = sc.nextInt();\n\t\t\tbuf = new int[m + 5];\n\t\t\tpointer = 0;\n\t\t\tbufMax = 0;\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tString o = sc.next();\n\t\t\t\tif (o.equals(\"click\")) {\n\t\t\t\t\tint x = sc.nextInt();\n\t\t\t\t\tint y = sc.nextInt();\n\t\t\t\t\tfor (int j = 0; j < page[pointer].lnum; j++) {\n\t\t\t\t\t\tif (page[pointer].link[j].x1 <= x && x <= page[pointer].link[j].x2 &&\n\t\t\t\t\t\t\t\tpage[pointer].link[j].y1 <= y && y <= page[pointer].link[j].y2) {\n\t\t\t\t\t\t\tbuf[pointer + 1] = map.get(page[pointer].link[j].name);\n\t\t\t\t\t\t\tpointer++;\n\t\t\t\t\t\t\tbufMax = pointer;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else if (o.equals(\"show\")) {\n\t\t\t\t\tSystem.out.println(page[pointer].name);\n\t\t\t\t} else if (o.equals(\"back\")) {\n\t\t\t\t\tif (0 < pointer) {\n\t\t\t\t\t\tpointer--;\n\t\t\t\t\t}\n\t\t\t\t} else if (o.equals(\"forward\")) {\n\t\t\t\t\tif (pointer < bufMax) {\n\t\t\t\t\t\tpointer++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main{\n    class obj{\n\tint h, w, n;\n\tint[] link_x1, link_x2, link_y1, link_y2;\n\tString str;\n\tString[] link;\n\tobj(){\n\t}\n\tobj(String str, int h, int w, int n){\n\t    this.str = str;\n\t    this.h = h;\n\t    this.w = w;\n\t    this.n = n;\n\n\t    link = new String[n+1];\n\t    link_x1 = new int[n+1];\n\t    link_x2 = new int[n+1];\n\t    link_y1 = new int[n+1];\n\t    link_y2 = new int[n+1];\n\t}\n\n\tvoid setParam(String str, int x1, int x2, int y1, int y2, int m){\n\t    link[m] = str;\n\t    link_x1[m] = x1;\n\t    link_x2[m] = x2;\n\t    link_y1[m] = y1;\n\t    link_y2[m] = y2;\n\n\t    return ;\n\t}\n\n\tString getPage(int x, int y){\n\t    for(int i = 0; i < n; i++){\n\t\tif(link_x1[i] <= x && x <= link_x2[i] && link_y1[i] <= y && y <= link_y2[i]){\n\t\t    return link[i];\n\t\t}\n\t    }\n\t    return \"-1\";\n\t}\n    }\n\n    Main(){\n\tScanner sc = new Scanner(System.in);\n\n\twhile(true){\n\t    int n = sc.nextInt();\n\t    if(n == 0){\n\t\tbreak;\n\t    }\n\t    int w = sc.nextInt();\n\t    int h = sc.nextInt();\n\t    obj[] pages = new obj[n+1];\n\t    for(int i = 0; i < n; i++){\n\t\tString str = sc.next();\n\t\tint m = sc.nextInt();\n\t\tpages[i] = new obj(str, h, w, m);\n\t\tfor(int j = 0; j < m; j++){\n\t\t    int x1 = sc.nextInt();\n\t\t    int y1 = sc.nextInt();\n\t\t    int x2 = sc.nextInt();\n\t\t    int y2 = sc.nextInt();\n\t\t    str = sc.next();\n\t\t    pages[i].setParam(str, x1, x2, y1, y2, j);\n\t\t}\n\t    }\n\t    int m = sc.nextInt();\n\t    String[] state = new String[n+1];\n\t    int p = 0, q = 0, current = 0;\n\t    state[p] = pages[current].str;\n\n\t    for(int k = 0; k < m; k++){\n\t\tString str = sc.next();\n\t\tif(str.equals(\"click\")){\n\t\t    int x = sc.nextInt();\n\t\t    int y = sc.nextInt();\n\t\t    String next = pages[current].getPage(x, y);\n\t\t    if(next.equals(\"-1\")){\n\t\t\tcontinue;\n\t\t    }\n\t\t    for(int i = 0; i < n; i++){\n\t\t\tif(next.equals(pages[i].str)){\n\t\t\t    current = i;\n\t\t\t    state[++p] = next;\n\t\t\t    break;\n\t\t\t}\n\t\t    }\n\t\t    q = p;\n\t\t} else if(str.equals(\"show\")){\n\t\t    System.out.println(state[p]);\n\t\t} else if(str.equals(\"back\")){\n\t\t    if(p > 0){\n\t\t\tp--;\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t    if(state[p].equals(pages[i].str)){\n\t\t\t\tcurrent = i;\n\t\t\t\tbreak;\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t} else {\n\t\t    if(p < q){\n\t\t\tp++;\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t    if(state[p].equals(pages[i].str)){\n\t\t\t\tcurrent = i;\n\t\t\t\tbreak;\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t}\n\n\t    }\n\t}\n    }\n\n    public static void main(String[] args){\n\tnew Main();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() throws IOException {\n\t\tScanner scanner = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint n = scanner.nextInt();\n\t\t\tif (n == 0)\n\t\t\t\tbreak;\n\t\t\tString np = \"\";\n\t\t\tint w = scanner.nextInt();\n\t\t\tint h = scanner.nextInt();\n\t\t\tMap<String, Page> pages = new HashMap<String, Main.Page>();\n\t\t\twhile (n-- > 0) {\n\t\t\t\tPage p = new Page();\n\t\t\t\tString name = scanner.next();\n\t\t\t\tif (np.equals(\"\"))\n\t\t\t\t\tnp = name;\n\t\t\t\tint b = scanner.nextInt();\n\t\t\t\twhile (b-- > 0) {\n\t\t\t\t\tint sx = scanner.nextInt();\n\t\t\t\t\tint sy = scanner.nextInt();\n\t\t\t\t\tint ex = scanner.nextInt();\n\t\t\t\t\tint ey = scanner.nextInt();\n\t\t\t\t\tString to = scanner.next();\n\t\t\t\t\tButton bn = new Button(sx, sy, ex, ey, to);\n\t\t\t\t\tp.buttons.add(bn);\n\t\t\t\t}\n\t\t\t\tpages.put(name, p);\n\t\t\t}\n\t\t\tint m = scanner.nextInt();\n\t\t\tList<String> buff = new ArrayList<String>();\n\t\t\tbuff.add(np);\n\t\t\tint pi = 0;\n\t\t\tint br = 1;\n\t\t\twhile (m-- > 0) {\n\t\t\t\tString op = scanner.next();\n\t\t\t\tif (op.equals(\"click\")) {\n\t\t\t\t\tint x = scanner.nextInt();\n\t\t\t\t\tint y = scanner.nextInt();\n\t\t\t\t\tString to = pages.get(buff.get(pi)).click(x, y);\n\t\t\t\t\tif (!to.isEmpty()) {\n\t\t\t\t\t\tpi++;\n\t\t\t\t\t\tif (pi == buff.size())\n\t\t\t\t\t\t\tbuff.add(to);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tbuff.set(pi, to);\n\t\t\t\t\t\tbr = pi + 1;\n\t\t\t\t\t}\n\t\t\t\t} else if (op.equals(\"back\")) {\n\t\t\t\t\tif (pi != 0)\n\t\t\t\t\t\tpi--;\n\t\t\t\t} else if (op.equals(\"forward\")) {\n\t\t\t\t\tif (pi + 1 != br)\n\t\t\t\t\t\tpi++;\n\t\t\t\t} else\n\t\t\t\t\tSystem.out.println(buff.get(pi));\n\t\t\t}\n\t\t}\n\t}\n\n\tclass Button {\n\t\tint sx, sy, ex, ey;\n\t\tString to;\n\n\t\tpublic Button(int sx, int sy, int ex, int ey, String to) {\n\t\t\tsuper();\n\t\t\tthis.sx = sx;\n\t\t\tthis.sy = sy;\n\t\t\tthis.ex = ex;\n\t\t\tthis.ey = ey;\n\t\t\tthis.to = to;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"Button [sx=\" + sx + \", sy=\" + sy + \", ex=\" + ex + \", ey=\"\n\t\t\t\t\t+ ey + \", to=\" + to + \"]\";\n\t\t}\n\n\t\tboolean isHit(int x, int y) {\n\t\t\treturn sx <= x && x <= ex && sy <= y && y <= ey;\n\t\t}\n\t}\n\n\tclass Page {\n\t\tList<Button> buttons = new ArrayList<Main.Button>();\n\n\t\tString click(int x, int y) {\n\t\t\tfor (int i = 0; i < buttons.size(); i++) {\n\t\t\t\tif (buttons.get(i).isHit(x, y))\n\t\t\t\t\treturn buttons.get(i).to;\n\t\t\t}\n\t\t\treturn \"\";\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"Page [buttons=\" + buttons + \"]\";\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.*;\n\nimport static java.lang.Integer.parseInt;\n\n/**\n * Problem D: Distorted Love\n */\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString line;\n\t\tString[] words;\n\n\t\tComparator<int[]> cmp = new Comparator<int[]>() {\n\t\t\t@Override\n\t\t\tpublic int compare(int[] o1, int[] o2) {\n\t\t\t\tif (o1[0] != o2[0]) {\n\t\t\t\t\treturn Integer.compare(o1[0], o2[0]);\n\t\t\t\t} else {\n\t\t\t\t\treturn Integer.compare(o1[1], o2[1]);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\twhile ((line = br.readLine()) != null && !line.isEmpty()) {\n\n\t\t\tint n = parseInt(line);\n\t\t\tif (n == 0) break;\n\n\t\t\t//????????¨??????\n\t\t\tbr.readLine();\n\n\t\t\tMap<String, Map<int[], String>> pages = new HashMap<>();\n\t\t\tDeque<String> stackF, stackB;\n\t\t\tstackF = new ArrayDeque<>();\n\t\t\tstackB = new ArrayDeque<>();\n\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\twords = br.readLine().split(\" \");\n\n\t\t\t\tString name = words[0];\n\t\t\t\tint b = parseInt(words[1]);\n\n\t\t\t\tpages.put(name, new TreeMap<>(cmp));\n\n\t\t\t\tfor (int j = 0; j < b; j++) {\n\t\t\t\t\twords = br.readLine().split(\" \");\n\t\t\t\t\tint[] pos = new int[4];\n\t\t\t\t\tfor (int k = 0; k < 4; k++) {\n\t\t\t\t\t\tpos[k] = parseInt(words[k]);\n\t\t\t\t\t}\n\t\t\t\t\tpages.get(name).put(pos, words[4]);\n\t\t\t\t}\n\t\t\t\tif (i == 0) {\n\t\t\t\t\tstackF.push(name);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint m = parseInt(br.readLine());\n\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\twords = br.readLine().split(\" \");\n\n\t\t\t\tString op = words[0];\n\n\t\t\t\tswitch (op) {\n\t\t\t\t\tcase \"click\":\n\t\t\t\t\t\tint x = parseInt(words[1]);\n\t\t\t\t\t\tint y = parseInt(words[2]);\n\t\t\t\t\t\tString page = stackF.peek();\n\t\t\t\t\t\tMap<int[], String> btns = pages.get(page);\n\t\t\t\t\t\tfor (int[] btn : btns.keySet()) {\n\t\t\t\t\t\t\tif (btn[0] <= x && x <= btn[2]\n\t\t\t\t\t\t\t\t\t&& btn[1] <= y && y <= btn[3]) {\n\t\t\t\t\t\t\t\tstackF.push(btns.get(btn));\n\t\t\t\t\t\t\t\tstackB.clear();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"back\":\n\t\t\t\t\t\tif (!stackF.isEmpty()) {\n\t\t\t\t\t\t\tstackB.push(stackF.pop());\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"forward\":\n\t\t\t\t\t\tif (!stackB.isEmpty()) {\n\t\t\t\t\t\t\tstackF.push(stackB.pop());\n\t\t\t\t\t\t} break;\n\t\t\t\t\tcase \"show\":\n\t\t\t\t\t\tSystem.out.println(stackF.peek());\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\nimport java.util.TreeMap;\n\npublic class Main {\n\tstatic class Page {\n\t\tString name;\n\t\tint l[], r[], t[], b[];\n\t\tString button[];\n\t\tint num, k;\n\n\t\tPage(String name, int k, int num) {\n\t\t\tthis.name = name;\n\t\t\tl = new int[k];\n\t\t\tr = new int[k];\n\t\t\tt = new int[k];\n\t\t\tb = new int[k];\n\t\t\tbutton = new String[k];\n\t\t\tthis.num = num;\n\t\t\tthis.k = k;\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n, m;\n\t\tPage p[];\n\t\tint buf[], index, end;\n\t\tTreeMap<String, Integer> tm = new TreeMap<String, Integer>();\n\n\t\twhile (true) {\n\t\t\tn = sc.nextInt();\n\t\t\tif (n == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsc.nextInt();\n\t\t\tsc.nextInt();\n\n\t\t\tp = new Page[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tString name = sc.next();\n\t\t\t\tint k = sc.nextInt();\n\t\t\t\tp[i] = new Page(name, k, i);\n\t\t\t\ttm.put(p[i].name, p[i].num);\n\t\t\t\tfor (int j = 0; j < p[i].k; j++) {\n\t\t\t\t\tp[i].l[j] = sc.nextInt();\n\t\t\t\t\tp[i].t[j] = sc.nextInt();\n\t\t\t\t\tp[i].r[j] = sc.nextInt();\n\t\t\t\t\tp[i].b[j] = sc.nextInt();\n\t\t\t\t\tp[i].button[j] = sc.next();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tm = sc.nextInt();\n\t\t\tbuf = new int[100000];\n\t\t\tindex = 0;\n\t\t\tend = 1;\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tString order = sc.next();\n\t\t\t\tPage now = p[buf[index]];\n\t\t\t\tif (order.equals(\"click\")) {\n\t\t\t\t\tint x = sc.nextInt();\n\t\t\t\t\tint y = sc.nextInt();\n\t\t\t\t\tfor (int j = 0; j < now.k; j++) {\n\t\t\t\t\t\tif (now.l[j] <= x && x <= now.r[j] && now.t[j] <= y && y <= now.b[j]) {\n\t\t\t\t\t\t\tindex++;\n\t\t\t\t\t\t\tbuf[index] = tm.get(now.button[j]);\n\t\t\t\t\t\t\tend = index + 1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else if (order.equals(\"show\")) {\n\t\t\t\t\tSystem.out.println(now.name);\n\t\t\t\t} else if (order.equals(\"back\")) {\n\t\t\t\t\tindex = Math.max(index - 1, 0);\n\t\t\t\t} else if (order.equals(\"forward\")) {\n\t\t\t\t\tindex = Math.min(index + 1, end - 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\nimport java.util.TreeMap;\n\npublic class Main {\n\tstatic class Page {\n\t\tString name;\n\t\tint l[], r[], t[], b[];\n\t\tString button[];\n\t\tint num, k;\n\n\t\tPage(String name, int k, int num) {\n\t\t\tthis.name = name;\n\t\t\tl = new int[k];\n\t\t\tr = new int[k];\n\t\t\tt = new int[k];\n\t\t\tb = new int[k];\n\t\t\tbutton = new String[k];\n\t\t\tthis.num = num;\n\t\t\tthis.k = k;\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n,  m;\n\t\tPage p[];\n\t\tint buf[], index, end;\n\t\tTreeMap<String, Integer> tm = new TreeMap<String, Integer>();\n\n\t\twhile (true) {\n\t\t\tn = sc.nextInt();\n\t\t\tif (n == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsc.nextInt();\n\t\t\tsc.nextInt();\n\n\t\t\tp = new Page[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tString name = sc.next();\n\t\t\t\tint k = sc.nextInt();\n\t\t\t\tp[i] = new Page(name, k, i);\n\t\t\t\ttm.put(p[i].name, p[i].num);\n\t\t\t\tfor (int j = 0; j < p[i].k; j++) {\n\t\t\t\t\tp[i].l[j] = sc.nextInt();\n\t\t\t\t\tp[i].t[j] = sc.nextInt();\n\t\t\t\t\tp[i].r[j] = sc.nextInt();\n\t\t\t\t\tp[i].b[j] = sc.nextInt();\n\t\t\t\t\tp[i].button[j] = sc.next();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tm = sc.nextInt();\n\t\t\tbuf = new int[100000];\n\t\t\tindex = 0;\n\t\t\tend = 1;\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tString order = sc.next();\n\t\t\t\tPage now = p[buf[index]];\n\t\t\t\tif (order.equals(\"click\")) {\n\t\t\t\t\tint x = sc.nextInt();\n\t\t\t\t\tint y = sc.nextInt();\n\t\t\t\t\tfor (int j = 0; j < now.k; j++) {\n\t\t\t\t\t\tif (now.l[j] <= x && x <= now.r[j] && now.t[j] <= y && y <= now.b[j]) {\n\t\t\t\t\t\t\tindex++;\n\t\t\t\t\t\t\tbuf[index] = tm.get(now.button[j]);\n\t\t\t\t\t\t\tend++;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else if (order.equals(\"show\")) {\n\t\t\t\t\tSystem.out.println(now.name);\n\t\t\t\t} else if (order.equals(\"back\")) {\n\t\t\t\t\tindex = Math.max(index - 1, 0);\n\t\t\t\t} else if (order.equals(\"forward\")) {\n\t\t\t\t\tindex = Math.min(index + 1, end - 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.Rectangle;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic Page[] buffer = new Page[100001];\n\n\tpublic static void main(String[] args) {\n\t\twhile (true) {\n\t\t\tint N = sc.nextInt();\n\t\t\tif (N == 0) break;\n\t\t\tArrays.fill(buffer, null);\n\t\t\tint W = sc.nextInt();\n\t\t\tint H = sc.nextInt();\n\t\t\tPage[] pages = new Page[N];\n\t\t\tHashMap<String, Integer> map = new HashMap<String, Integer>();\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tString name = sc.next();\n\t\t\t\tmap.put(name, i);\n\t\t\t\tint b = sc.nextInt();\n\t\t\t\tpages[i] = new Page(name, b);\n\t\t\t\tfor (int j = 0; j < b; ++j) {\n\t\t\t\t\tint x1 = sc.nextInt();\n\t\t\t\t\tint y1 = sc.nextInt();\n\t\t\t\t\tint x2 = sc.nextInt();\n\t\t\t\t\tint y2 = sc.nextInt();\n\t\t\t\t\tpages[i].button[j] = new Rectangle(x1, y1, x2 - x1, y2 - y1);\n\t\t\t\t\tpages[i].linkTo[j] = sc.next();\n\t\t\t\t}\n\t\t\t}\n\t\t\tint bp = 0;\n\t\t\tbuffer[0] = pages[0];\n\t\t\tint M = sc.nextInt();\n\t\t\tfor (int i = 0; i < M; ++i) {\n\t\t\t\tString q = sc.next();\n\t\t\t\tif (q.equals(\"click\")) {\n\t\t\t\t\tint x = sc.nextInt();\n\t\t\t\t\tint y = sc.nextInt();\n\t\t\t\t\tfor (int j = 0; j < buffer[bp].button.length; ++j) {\n\t\t\t\t\t\tRectangle rect = buffer[bp].button[j];\n\t\t\t\t\t\tif (rect.x <= x && x <= rect.getMaxX() && rect.y <= y && y <= rect.getMaxY()) {\n\t\t\t\t\t\t\tfor (int k = bp + 1; k < buffer.length && buffer[k] != null; ++k) {\n\t\t\t\t\t\t\t\tbuffer[k] = null;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbuffer[bp + 1] = pages[map.get(buffer[bp].linkTo[j])];\n\t\t\t\t\t\t\t++bp;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else if (q.equals(\"back\")) {\n\t\t\t\t\tif (bp > 0) --bp;\n\t\t\t\t} else if (q.equals(\"forward\")) {\n\t\t\t\t\tif (bp < buffer.length - 1 && buffer[bp + 1] != null) ++bp;\n\t\t\t\t} else if (q.equals(\"show\")) {\n\t\t\t\t\tSystem.out.println(buffer[bp].name);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic class Page {\n\t\tRectangle[] button;\n\t\tString[] linkTo;\n\t\tString name;\n\n\t\tPage(String name, int buttonCount) {\n\t\t\tthis.name = name;\n\t\t\tthis.button = new Rectangle[buttonCount];\n\t\t\tthis.linkTo = new String[buttonCount];\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner in = new Scanner(System.in);\n\t\tint n;\n\t\tMap<String, List<Button>> map = new HashMap<String, List<Button>>();\n\t\tLinkedList<String> pre = new LinkedList<String>();\n\t\tLinkedList<String> next = new LinkedList<String>();\n\t\tString now = \"\";\n\t\twhile ((n = in.nextInt()) != 0) {\n\t\t\tmap.clear();\n\t\t\tpre.clear();\n\t\t\tnext.clear();\n\t\t\tint w = in.nextInt();\n\t\t\tint h = in.nextInt();\n\t\t\tfor (int page_info = 0; page_info < n; page_info++) {\n\t\t\t\tString pageName = in.next();\n\t\t\t\tif (page_info == 0) {\n\t\t\t\t\tnow = pageName;\n\t\t\t\t}\n\t\t\t\tint bt_count = in.nextInt();\n\t\t\t\tList<Button> buttons = new ArrayList<Button>();\n\t\t\t\tfor (int i = 0; i < bt_count; i++) {\n\t\t\t\t\tbuttons.add(new Button(in.nextInt(), in.nextInt(), in\n\t\t\t\t\t\t\t.nextInt(), in.nextInt(), in.next()));\n\t\t\t\t}\n\t\t\t\tmap.put(pageName, buttons);\n\t\t\t}\n\t\t\tint m = in.nextInt();\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tString command = in.next();\n\t\t\t\tif (\"click\".equals(command)) {\n\t\t\t\t\tint x = in.nextInt();\n\t\t\t\t\tint y = in.nextInt();\n\t\t\t\t\tfor (Button bt : map.get(now)) {\n\t\t\t\t\t\tif (bt.c(x, y)) {\n\t\t\t\t\t\t\tpre.addLast(now);\n\t\t\t\t\t\t\tnow = bt.target;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else if (\"back\".equals(command)) {\n\t\t\t\t\tif (!pre.isEmpty()) {\n\t\t\t\t\t\tnext.addFirst(now);\n\t\t\t\t\t\tnow = pre.pollLast();\n\t\t\t\t\t}\n\t\t\t\t} else if (\"forward\".equals(command)) {\n\t\t\t\t\tif (!next.isEmpty()) {\n\t\t\t\t\t\tpre.addLast(now);\n\t\t\t\t\t\tnow = next.pollFirst();\n\t\t\t\t\t}\n\t\t\t\t} else if (\"show\".equals(command)) {\n\t\t\t\t\tassert true;\n\t\t\t\t\tSystem.out.println(now);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n}\n\nclass Button {\n\tfinal int minX, minY, maxX, maxY;\n\tfinal String target;\n\n\tButton(int minX, int minY, int maxX, int maxY, String target) {\n\t\tthis.minX = minX;\n\t\tthis.minY = minY;\n\t\tthis.maxX = maxX;\n\t\tthis.maxY = maxY;\n\t\tthis.target = target;\n\t}\n\n\tboolean c(int x, int y) {\n\t\treturn (minX <= x && x <= maxX && minY <= y && y <= maxY);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Scanner;\nimport java.util.TreeMap;\n\n//Distorted Love\npublic class Main{\n\n\tclass B{\n\t\tint x1, y1, x2, y2;\n\t\tString s;\n\t\tpublic B(int x1, int y1, int x2, int y2, String s) {\n\t\t\tthis.x1 = x1;\n\t\t\tthis.y1 = y1;\n\t\t\tthis.x2 = x2;\n\t\t\tthis.y2 = y2;\n\t\t\tthis.s = s;\n\t\t}\n\t}\n\t\n\tclass R{\n\t\tString name;\n\t\tList<B> l;\n\t\tpublic R(String name) {\n\t\t\tthis.name = name;\n\t\t\tl = new ArrayList<B>();\n\t\t}\n\t\tString click(int x, int y){\n\t\t\tfor(B b:l){\n\t\t\t\tif(b.x1<=x&&x<=b.x2&&b.y1<=y&&y<=b.y2)return b.s;\n\t\t\t}\n\t\t\treturn \"\";\n\t\t}\n\t}\n\t\n\tMap<String, Integer> ref;\n\tR[] page;\n\tint id;\n\t\n\tint get(String s){\n\t\tif(ref.containsKey(s))return ref.get(s);\n\t\tpage[id] = new R(s);\n\t\tref.put(s, id);\n\t\treturn id++;\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n==0)break;\n\t\t\tsc.next();sc.next();\n\t\t\tpage = new R[n];\n\t\t\tref = new TreeMap<String, Integer>();\n\t\t\tid = 0;\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tint x = get(sc.next());\n\t\t\t\tint k = sc.nextInt();\n\t\t\t\twhile(k--!=0){\n\t\t\t\t\tpage[x].l.add(new B(sc.nextInt(), sc.nextInt(), sc.nextInt(), sc.nextInt(), sc.next()));\n\t\t\t\t}\n\t\t\t}\n\t\t\tint m = sc.nextInt();\n\t\t\tR[] h = new R[m];\n\t\t\th[0] = page[0];\n\t\t\tint pos = 0;\n\t\t\tint t = 1;\n\t\t\twhile(m--!=0){\n\t\t\t\tString cmd = sc.next();\n\t\t\t\tif(cmd.equals(\"show\")){\n\t\t\t\t\tSystem.out.println(h[pos].name);\n\t\t\t\t}\n\t\t\t\telse if(cmd.equals(\"back\")){\n\t\t\t\t\tpos = Math.max(0, pos-1);\n\t\t\t\t}\n\t\t\t\telse if(cmd.equals(\"forward\")){\n\t\t\t\t\tpos = Math.min(t-1, pos+1);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tString hit = h[pos].click(sc.nextInt(), sc.nextInt());\n\t\t\t\t\tif(hit.equals(\"\"))continue;\n\t\t\t\t\tint x = ref.get(hit);\n\t\t\t\t\th[t++] = page[x];\n\t\t\t\t\tpos++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() throws IOException {\n\t\tScanner scanner = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint n = scanner.nextInt();\n\t\t\tif (n == 0)\n\t\t\t\tbreak;\n\t\t\tString np = \"\";\n\t\t\tint w = scanner.nextInt();\n\t\t\tint h = scanner.nextInt();\n\t\t\tMap<String, Page> pages = new HashMap<String, Main.Page>();\n\t\t\twhile (n-- > 0) {\n\t\t\t\tPage p = new Page();\n\t\t\t\tString name = scanner.next();\n\t\t\t\tif (np.equals(\"\"))\n\t\t\t\t\tnp = name;\n\t\t\t\tint b = scanner.nextInt();\n\t\t\t\twhile (b-- > 0) {\n\t\t\t\t\tint sx = scanner.nextInt();\n\t\t\t\t\tint sy = scanner.nextInt();\n\t\t\t\t\tint ex = scanner.nextInt();\n\t\t\t\t\tint ey = scanner.nextInt();\n\t\t\t\t\tString to = scanner.next();\n\t\t\t\t\tButton bn = new Button(sx, sy, ex, ey, to);\n\t\t\t\t\tp.buttons.add(bn);\n\t\t\t\t}\n\t\t\t\tpages.put(name, p);\n\t\t\t}\n\t\t\tint m = scanner.nextInt();\n\t\t\tList<String> buff = new ArrayList<String>();\n\t\t\tbuff.add(np);\n\t\t\tint pi = 0;\n\t\t\tint br = 1;\n\t\t\twhile (m-- > 0) {\n\t\t\t\tString op = scanner.next();\n\t\t\t\tif (op.equals(\"click\")) {\n\t\t\t\t\tint x = scanner.nextInt();\n\t\t\t\t\tint y = scanner.nextInt();\n\t\t\t\t\tString to = pages.get(buff.get(pi)).click(x, y);\n\t\t\t\t\tpi++;\n\t\t\t\t\tif (pi == buff.size())\n\t\t\t\t\t\tbuff.add(to);\n\t\t\t\t\telse\n\t\t\t\t\t\tbuff.set(pi, to);\n\t\t\t\t\tbr = pi + 1;\n\t\t\t\t} else if (op.equals(\"back\")) {\n\t\t\t\t\tif (pi != 0)\n\t\t\t\t\t\tpi--;\n\t\t\t\t} else if (op.equals(\"forward\")) {\n\t\t\t\t\tif (pi + 1 != br)\n\t\t\t\t\t\tpi++;\n\t\t\t\t} else\n\t\t\t\t\tSystem.out.println(buff.get(pi));\n\t\t\t}\n\t\t}\n\t}\n\n\tclass Button {\n\t\tint sx, sy, ex, ey;\n\t\tString to;\n\n\t\tpublic Button(int sx, int sy, int ex, int ey, String to) {\n\t\t\tsuper();\n\t\t\tthis.sx = sx;\n\t\t\tthis.sy = sy;\n\t\t\tthis.ex = ex;\n\t\t\tthis.ey = ey;\n\t\t\tthis.to = to;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"Button [sx=\" + sx + \", sy=\" + sy + \", ex=\" + ex + \", ey=\"\n\t\t\t\t\t+ ey + \", to=\" + to + \"]\";\n\t\t}\n\n\t\tboolean isHit(int x, int y) {\n\t\t\treturn sx <= x && x <= ex && sy <= y && y <= ey;\n\t\t}\n\t}\n\n\tclass Page {\n\t\tList<Button> buttons = new ArrayList<Main.Button>();\n\n\t\tString click(int x, int y) {\n\t\t\tfor (int i = 0; i < buttons.size(); i++) {\n\t\t\t\tif (buttons.get(i).isHit(x, y))\n\t\t\t\t\treturn buttons.get(i).to;\n\t\t\t}\n\t\t\treturn \"\";\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"Page [buttons=\" + buttons + \"]\";\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Rectangle2D;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.ListIterator;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\t\n\tpublic static class Page{\n\t\tString page_name;\n\t\tint page_number;\n\t\tint[][] btns;\n\t\tint[] links;\n\t\t\n\t\tpublic Page(String page_name, int page_number, int[][] btns, int[] links) {\n\t\t\tsuper();\n\t\t\tthis.page_name = page_name;\n\t\t\tthis.page_number = page_number;\n\t\t\tthis.btns = btns;\n\t\t\tthis.links = links;\n\t\t}\n\t\t\n\t\tpublic int touch(int x, int y){\n\t\t\tfor(int i = 0; i < btns.length; i++){\n\t\t\t\tfinal int lu_x = btns[i][0];\n\t\t\t\tfinal int lu_y = btns[i][1];\n\t\t\t\tfinal int rd_x = btns[i][2];\n\t\t\t\tfinal int rd_y = btns[i][3];\n\t\t\t\t\n\t\t\t\tif(lu_x <= x && x <= rd_x && lu_y <= y && y <= rd_y){\n\t\t\t\t\treturn links[i]; \n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn -1;\n\t\t}\n\t}\n\t\n\t\n\tpublic static void main(String[] args) {\n\t\tfinal Scanner sc = new Scanner(System.in);\n\t\t\n\t\twhile(true){\n\t\t\tfinal int n = sc.nextInt();\n\t\t\t\n\t\t\tif(n == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tfinal int W = sc.nextInt();\n\t\t\tfinal int H = sc.nextInt();\n\t\t\t\n\t\t\tString[] name = new String[n];\n\t\t\tint[] btns = new int[n];\n\t\t\tint[][][] rects = new int[n][][];\n\t\t\tString[][] links = new String[n][];\n\t\t\t\n\t\t\tHashMap<String, Integer> map = new HashMap<String, Integer>();\n\t\t\t\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tname[i] = sc.next();\n\t\t\t\tfinal int k = sc.nextInt();\n\t\t\t\tbtns[i] = k;\n\t\t\t\t\n\t\t\t\trects[i] = new int[k][4];\n\t\t\t\tlinks[i] = new String[k];\n\t\t\t\tfor(int j = 0; j < k; j++){\n\t\t\t\t\trects[i][j][0] = sc.nextInt();\n\t\t\t\t\trects[i][j][1] = sc.nextInt();\n\t\t\t\t\trects[i][j][2] = sc.nextInt();\n\t\t\t\t\trects[i][j][3] = sc.nextInt();\n\t\t\t\t\tlinks[i][j] = sc.next();\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tmap.put(name[i], i);\n\t\t\t}\n\t\t\t\n\t\t\tPage[] pages = new Page[n];\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tint[] link = new int[btns[i]];\n\t\t\t\tfor(int j = 0; j < btns[i]; j++){\n\t\t\t\t\tlink[j] = map.get(links[i][j]);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tpages[i] = new Page(name[i], i, rects[i], link);\n\t\t\t}\n\t\t\t\n\t\t\tArrayList<Integer> history = new ArrayList<Integer>();\n\t\t\thistory.add(0);\n\t\t\tint size = 1;\n\t\t\tint cur_pos = 0;\n\t\t\t\n\t\t\tint cur_page = 0;\n\t\t\tfinal int q = sc.nextInt();\n\t\t\tfor(int t = 0; t < q; t++){\n\t\t\t\tString input = sc.next();\n\t\t\t\t\n\t\t\t\tif(\"forward\".equals(input)){\n\t\t\t\t\tif(cur_pos < size - 1){\n\t\t\t\t\t\tcur_pos++;\n\t\t\t\t\t\tcur_page = history.get(cur_pos);\n\t\t\t\t\t}\n\t\t\t\t}else if(\"back\".equals(input)){\n\t\t\t\t\tif(cur_pos > 0){\n\t\t\t\t\t\tcur_pos--;\n\t\t\t\t\t\tcur_page = history.get(cur_pos);\n\t\t\t\t\t}\n\t\t\t\t}else if(\"click\".equals(input)){\n\t\t\t\t\tfinal int x = sc.nextInt();\n\t\t\t\t\tfinal int y = sc.nextInt();\n\t\t\t\t\t\n\t\t\t\t\tint ret = pages[cur_page].touch(x, y);\n\t\t\t\t\t\n\t\t\t\t\tif(ret >= 0){\n\t\t\t\t\t\tcur_pos++;\n\t\t\t\t\t\tcur_page = ret;\n\t\t\t\t\t\thistory.add(cur_pos, cur_page);\n\t\t\t\t\t\tsize = cur_pos + 1;\n\t\t\t\t\t}\n\t\t\t\t}else if(\"show\".equals(input)){\n\t\t\t\t\t//System.out.println(cur_pos + \" \" + size + \" \" + history);\n\t\t\t\t\tSystem.out.println(pages[cur_page].page_name);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\nclass Button {\n    int ulx, uly, lrx, lry;\n    public String linkName;\n    Button(int ulx, int uly, int lrx, int lry, String linkName) {\n        this.ulx = ulx;\n        this.uly = uly;\n        this.lrx = lrx;\n        this.lry = lry;\n        this.linkName = linkName;\n    }\n    boolean contains(int x, int y) {\n        //System.out.printf(\"%d,%d\\n\", x, y);\n        //System.out.println(ulx + \" \" +  lrx + \" \" + lry + \" \" + uly);\n        return (ulx <= x && x <= lrx && uly <= y && y <= lry);\n    }\n}\n\nclass Page {\n    public String name;\n    public Button[] links;\n    Page(String name, Button[] links) {\n        this.name = name;\n        this.links = links;\n    }\n    String getLinkPageName(int x, int y) {\n        for (Button b : links) {\n            if (b.contains(x, y)) {\n                return b.linkName;\n            }\n        }\n        return name;\n    }\n}\n\npublic class Main {\n    int n, W, H;\n    Scanner sc;\n    HashMap<String, Page> pages;\n    Main() {\n        sc = new Scanner(System.in);\n    }\n    boolean init() {\n        n = sc.nextInt();\n        if (n == 0) return false;\n        W = sc.nextInt();\n        H = sc.nextInt();\n        pages = new HashMap<String, Page>();\n        for (int i = 0; i < n; i++) {\n            String name = sc.next();\n            int b = sc.nextInt();\n            Button[] links = new Button[b];\n            for (int j = 0; j < b; j++) {\n                int ulx = sc.nextInt();\n                int uly = sc.nextInt();\n                int lrx = sc.nextInt();\n                int lry = sc.nextInt();\n                String linkName = sc.next();\n                links[j] = new Button(ulx, uly, lrx, lry, linkName);\n            }\n            pages.put(name, new Page(name, links));\n        }\n        return true;\n    }\n    void run() {\n        try {\n        while (init()) {\n            ArrayList<Page> history = new ArrayList<Page>();\n            history.add(pages.get(\"index\"));\n            int current = 0;\n            int m = sc.nextInt();\n            for (int i = 0; i < m; i++) {\n                String cmd = sc.next();\n                if (cmd.equals(\"click\")) {\n                    int x = sc.nextInt();\n                    int y = sc.nextInt();\n                    Page curPage = history.get(current);\n                    Page nextPage = pages.get(curPage.getLinkPageName(x, y));\n                    if (curPage != nextPage) {\n                        while (history.size() != current+1) {\n                            history.remove(current+1);\n                        }\n                        //history.removeRange(current, history.size());\n                        history.add(pages.get(curPage.getLinkPageName(x, y)));\n                        current++;\n                    }\n                } else if (cmd.equals(\"show\")) {\n                    System.out.println(history.get(current).name);\n                } else if (cmd.equals(\"back\")) {\n                    if (current > 0) current--;\n                } else if (cmd.equals(\"forward\")) {\n                    if (current < history.size()-1) current++;\n                }\n            }\n        }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n    public static void main(String[] args) {\n        new Main().run();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.*;\n\nimport static java.lang.Integer.parseInt;\n\n/**\n * Problem D: Distorted Love\n */\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString line;\n\t\tString[] words;\n\n\t\twhile ((line = br.readLine()) != null && !line.isEmpty()) {\n\n\t\t\tint n = parseInt(line);\n\t\t\tif (n == 0) break;\n\n\t\t\t//????????¨??????\n\t\t\tbr.readLine();\n\n\t\t\tMap<String, Map<int[], String>> pages = new HashMap<>();\n\t\t\tDeque<String> stackF, stackB;\n\t\t\tstackF = new ArrayDeque<>();\n\t\t\tstackB = new ArrayDeque<>();\n\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\twords = br.readLine().split(\" \");\n\n\t\t\t\tString name = words[0];\n\t\t\t\tint b = parseInt(words[1]);\n\n\t\t\t\tpages.put(name, new HashMap<>());\n\n\t\t\t\tfor (int j = 0; j < b; j++) {\n\t\t\t\t\twords = br.readLine().split(\" \");\n\t\t\t\t\tint[] pos = new int[4];\n\t\t\t\t\tfor (int k = 0; k < 4; k++) {\n\t\t\t\t\t\tpos[k] = parseInt(words[k]);\n\t\t\t\t\t}\n\t\t\t\t\tpages.get(name).put(pos, words[4]);\n\t\t\t\t}\n\t\t\t\tif (i == 0) {\n\t\t\t\t\tstackF.push(name);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint m = parseInt(br.readLine());\n\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\twords = br.readLine().split(\" \");\n\n\t\t\t\tString op = words[0];\n\n\t\t\t\tswitch (op) {\n\t\t\t\t\tcase \"click\":\n\t\t\t\t\t\tint x = parseInt(words[1]);\n\t\t\t\t\t\tint y = parseInt(words[2]);\n\t\t\t\t\t\tString page = stackF.peek();\n\t\t\t\t\t\tMap<int[], String> btns = pages.get(page);\n\t\t\t\t\t\tfor (int[] btn : btns.keySet()) {\n\t\t\t\t\t\t\tif (btn[0] <= x && x <= btn[2]\n\t\t\t\t\t\t\t\t\t&& btn[1] <= y && y <= btn[3]) {\n\t\t\t\t\t\t\t\tstackF.push(btns.get(btn));\n\t\t\t\t\t\t\t\tstackB.clear();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"back\":\n\t\t\t\t\t\tif (stackF.size() > 1) {\n\t\t\t\t\t\t\tstackB.push(stackF.pop());\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"forward\":\n\t\t\t\t\t\tif (!stackB.isEmpty()) {\n\t\t\t\t\t\t\tstackF.push(stackB.pop());\n\t\t\t\t\t\t} break;\n\t\t\t\t\tcase \"show\":\n\t\t\t\t\t\tSystem.out.println(stackF.peek());\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.HashMap;\nimport java.util.Map;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tstatic int N,W,H;\n\tstatic Map<String,Page> map;\n\tpublic static void main(String[] args) {\n\t\tScanner cin=new Scanner(System.in);\n\t\twhile(true){\n\t\t\tN=cin.nextInt();\n\t\t\tif(N==0)break;\n\t\t\tmap=new HashMap<String,Page>();\n\t\t\tW=cin.nextInt();\n\t\t\tH=cin.nextInt();\n\t\t\tPage[] pages=new Page[N];\n\t\t\tfor(int i=0;i<N;i++){\n\t\t\t\tString name=cin.next();\n\t\t\t\tint cnt=cin.nextInt();\n\t\t\t\tpages[i]=new Page(name,cnt);\n\t\t\t\tmap.put(name, pages[i]);\n\t\t\t\tfor(int j=0;j<cnt;j++){\n\t\t\t\t\tint x1=cin.nextInt();\n\t\t\t\t\tint y1=cin.nextInt();\n\t\t\t\t\tint x2=cin.nextInt();\n\t\t\t\t\tint y2=cin.nextInt();\n\t\t\t\t\tpages[i].linkSt[j]=cin.next();\n\t\t\t\t\tpages[i].pages[j][0]=x1;\n\t\t\t\t\tpages[i].pages[j][1]=y1;\n\t\t\t\t\tpages[i].pages[j][2]=x2;\n\t\t\t\t\tpages[i].pages[j][3]=y2;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i=0;i<N;i++){\n\t\t\t\tpages[i].a();\n\t\t\t}\n\t\t\tBuffer b=new Buffer(pages[0]);\n\t\t\tBuffer head=b;\n\t\t\tfor(int cases=cin.nextInt();cases--!=0;){\n\t\t\t\tString s=cin.next();\n//\t\t\t\toutputBuff(head);\n//\t\t\t\tSystem.out.println(\"   \"+b.now.name);\n\t\t\t\tif(s.equals(\"show\")){\n\t\t\t\t\tSystem.out.println(b.now.name);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(s.equals(\"back\")){\n\t\t\t\t\tif(b.prev==null)continue;\n\t\t\t\t\tb=b.prev;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(s.equals(\"forward\")){\n\t\t\t\t\tif(b.next==null)continue;\n\t\t\t\t\tb=b.next;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tPage now=b.now;\n\t\t\t\tint next=now.clicked(cin.nextInt(), cin.nextInt());\n\t\t\t\tif(next==-1)continue;\n\t\t\t\t\n\t\t\t\tb.next=new Buffer(now.link[next]);\n\t\t\t\tb.next.prev=b;\n\t\t\t\tb=b.next;\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\tstatic void outputBuff(Buffer b){\n\t\tif(b==null)return;\n\t\tSystem.out.println(b.now.name);\n\t\toutputBuff(b.next);\n\t}\n\tstatic class Buffer{\n\t\tBuffer next;\n\t\tBuffer prev;\n\t\tPage now;\n\t\tBuffer(Page p){\n\t\t\tnow=p;\n\t\t}\n\t}\n\tstatic class Page{\n\t\tString name;\n\t\tint[][] pages;\n\t\tString[] linkSt;\n\t\tPage[] link;\n\t\tPage(String s,int cnt){\n\t\t\tname=s;\n\t\t\tpages=new int[cnt][4];\n\t\t\tlink=new Page[cnt];\n\t\t\tlinkSt=new String[cnt];\n\t\t}\n\t\tvoid a(){\n\t\t\tfor(int i=0;i<link.length;i++){\n\t\t\t\tlink[i]=map.get(linkSt[i]);\n\t\t\t}\n\t\t}\n\t\tint clicked(int x,int y){\n\t\t\tfor(int i=0;i<link.length;i++){\n\t\t\t\tif(x<=pages[i][2]&&pages[i][0]<=x&&pages[i][1]<=y&&y<=pages[i][3]){\n\t\t\t\t\treturn i;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn -1;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.*;\n\nimport static java.lang.Integer.parseInt;\n\n/**\n * Problem D: Distorted Love\n */\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString line;\n\t\tString[] words;\n\n\t\tComparator<int[]> cmp = new Comparator<int[]>() {\n\t\t\t@Override\n\t\t\tpublic int compare(int[] o1, int[] o2) {\n\t\t\t\tif (o1[0] != o2[0]) {\n\t\t\t\t\treturn Integer.compare(o1[0], o2[0]);\n\t\t\t\t} else {\n\t\t\t\t\treturn Integer.compare(o1[1], o2[1]);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\twhile ((line = br.readLine()) != null && !line.isEmpty()) {\n\n\t\t\tint n = parseInt(line);\n\t\t\tif (n == 0) break;\n\n\t\t\t//????????¨??????\n\t\t\tbr.readLine();\n\n\t\t\tMap<String, NavigableMap<int[], String>> pages = new HashMap<>();\n\t\t\tDeque<String> stackF, stackB;\n\t\t\tstackF = new ArrayDeque<>();\n\t\t\tstackB = new ArrayDeque<>();\n\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\twords = br.readLine().split(\" \");\n\n\t\t\t\tString name = words[0];\n\t\t\t\tint b = parseInt(words[1]);\n\n\t\t\t\tpages.put(name, new TreeMap<>(cmp));\n\n\t\t\t\tfor (int j = 0; j < b; j++) {\n\t\t\t\t\twords = br.readLine().split(\" \");\n\t\t\t\t\tint[] pos = new int[4];\n\t\t\t\t\tfor (int k = 0; k < 4; k++) {\n\t\t\t\t\t\tpos[k] = parseInt(words[k]);\n\t\t\t\t\t}\n\t\t\t\t\tpages.get(name).put(pos, words[4]);\n\t\t\t\t}\n\t\t\t\tif (i == 0) {\n\t\t\t\t\tstackF.push(name);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint m = parseInt(br.readLine());\n\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\twords = br.readLine().split(\" \");\n\n\t\t\t\tString op = words[0];\n\n\t\t\t\tswitch (op) {\n\t\t\t\t\tcase \"click\":\n\t\t\t\t\t\tint x = parseInt(words[1]);\n\t\t\t\t\t\tint y = parseInt(words[2]);\n\t\t\t\t\t\tString page = stackF.peek();\n\t\t\t\t\t\tNavigableMap<int[], String> btns = pages.get(page);\n\t\t\t\t\t\tint[] btn = btns.floorKey(new int[]{x, y});\n\t\t\t\t\t\tif (btn != null\n\t\t\t\t\t\t\t\t&& btn[0] <= x && x <= btn[2]\n\t\t\t\t\t\t\t\t&& btn[1] <= y && y <= btn[3]) {\n\t\t\t\t\t\t\tstackF.push(btns.get(btn));\n\t\t\t\t\t\t\tstackB.clear();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"back\":\n\t\t\t\t\t\tif (stackF.size() > 1) {\n\t\t\t\t\t\t\tstackB.push(stackF.pop());\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"forward\":\n\t\t\t\t\t\tif (!stackB.isEmpty()) {\n\t\t\t\t\t\t\tstackF.push(stackB.pop());\n\t\t\t\t\t\t} break;\n\t\t\t\t\tcase \"show\":\n\t\t\t\t\t\tSystem.out.println(stackF.peek());\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.HashMap;\nimport java.util.Map;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tstatic int N,W,H;\n\tstatic Map<String,Page> map;\n\tpublic static void main(String[] args) {\n\t\tScanner cin=new Scanner(System.in);\n\t\twhile(true){\n\t\t\tN=cin.nextInt();\n\t\t\tif(N==0)break;\n\t\t\tmap=new HashMap<String,Page>();\n\t\t\tW=cin.nextInt();\n\t\t\tH=cin.nextInt();\n\t\t\tPage[] pages=new Page[N];\n\t\t\tfor(int i=0;i<N;i++){\n\t\t\t\tString name=cin.next();\n\t\t\t\tint cnt=cin.nextInt();\n\t\t\t\tpages[i]=new Page(name,cnt);\n\t\t\t\tmap.put(name, pages[i]);\n\t\t\t\tfor(int j=0;j<cnt;j++){\n\t\t\t\t\tint x1=cin.nextInt();\n\t\t\t\t\tint y1=cin.nextInt();\n\t\t\t\t\tint x2=cin.nextInt();\n\t\t\t\t\tint y2=cin.nextInt();\n\t\t\t\t\tpages[i].linkSt[j]=cin.next();\n\t\t\t\t\tpages[i].pages[j][0]=x1;\n\t\t\t\t\tpages[i].pages[j][1]=y1;\n\t\t\t\t\tpages[i].pages[j][2]=x2;\n\t\t\t\t\tpages[i].pages[j][3]=y2;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i=0;i<N;i++){\n\t\t\t\tpages[i].a();\n\t\t\t}\n\t\t\tBuffer b=new Buffer(pages[0]);\n\t\t\tBuffer head=b;\n\t\t\tfor(int cases=cin.nextInt();cases--!=0;){\n\t\t\t\tString s=cin.next();\n//\t\t\t\toutputBuff(head);\n//\t\t\t\tSystem.out.println(\"   \"+b.now.name);\n\t\t\t\tif(s.equals(\"show\")){\n\t\t\t\t\tSystem.out.println(b.now.name);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(s.equals(\"back\")){\n\t\t\t\t\tif(b.prev==null)continue;\n\t\t\t\t\tb=b.prev;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(s.equals(\"forward\")){\n\t\t\t\t\tif(b.next==null)continue;\n\t\t\t\t\tb=b.next;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tPage now=b.now;\n\t\t\t\tint next=now.clicked(cin.nextInt(), cin.nextInt());\n\t\t\t\tif(next==-1)continue;\n\t\t\t\t\n\t\t\t\tb.next=new Buffer(now.link[next]);\n\t\t\t\tb.next.prev=b;\n\t\t\t\tb=b.next;\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\tstatic void outputBuff(Buffer b){\n\t\tif(b==null)return;\n\t\tSystem.out.println(b.now.name);\n\t\toutputBuff(b.next);\n\t}\n\tstatic class Buffer{\n\t\tBuffer next;\n\t\tBuffer prev;\n\t\tPage now;\n\t\tBuffer(Page p){\n\t\t\tnow=p;\n\t\t}\n\t}\n\tstatic class Page{\n\t\tString name;\n\t\tint[][] pages;\n\t\tString[] linkSt;\n\t\tPage[] link;\n\t\tPage(String s,int cnt){\n\t\t\tname=s;\n\t\t\tpages=new int[cnt][4];\n\t\t\tlink=new Page[cnt];\n\t\t\tlinkSt=new String[cnt];\n\t\t}\n\t\tvoid a(){\n\t\t\tfor(int i=0;i<link.length;i++){\n\t\t\t\tlink[i]=map.get(linkSt[i]);\n\t\t\t}\n\t\t}\n\t\tint clicked(int x,int y){\n\t\t\tfor(int i=0;i<link.length;i++){\n\t\t\t\tif(x<=pages[i][2]&&pages[i][0]<=x&&pages[i][1]<=y&&y<=pages[i][3]){\n\t\t\t\t\treturn i;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn -1;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() throws IOException {\n\t\tScanner scanner = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint n = scanner.nextInt();\n\t\t\tif (n == 0)\n\t\t\t\tbreak;\n\t\t\tString np = \"\";\n\t\t\tint w = scanner.nextInt();\n\t\t\tint h = scanner.nextInt();\n\t\t\tMap<String, Page> pages = new HashMap<String, Main.Page>();\n\t\t\twhile (n-- > 0) {\n\t\t\t\tPage p = new Page();\n\t\t\t\tString name = scanner.next();\n\t\t\t\tif (np.equals(\"\"))\n\t\t\t\t\tnp = name;\n\t\t\t\tint b = scanner.nextInt();\n\t\t\t\twhile (b-- > 0) {\n\t\t\t\t\tint sx = scanner.nextInt();\n\t\t\t\t\tint sy = scanner.nextInt();\n\t\t\t\t\tint ex = scanner.nextInt();\n\t\t\t\t\tint ey = scanner.nextInt();\n\t\t\t\t\tString to = scanner.next();\n\t\t\t\t\tButton bn = new Button(sx, sy, ex, ey, to);\n\t\t\t\t\tp.buttons.add(bn);\n\t\t\t\t}\n\t\t\t\tpages.put(name, p);\n\t\t\t}\n\t\t\tint m = scanner.nextInt();\n\t\t\tList<String> buff = new ArrayList<String>();\n\t\t\tbuff.add(np);\n\t\t\tint pi = 0;\n\t\t\tint br = 1;\n\t\t\twhile (m-- > 0) {\n\t\t\t\tString op = scanner.next();\n\t\t\t\tif (op.equals(\"click\")) {\n\t\t\t\t\tint x = scanner.nextInt();\n\t\t\t\t\tint y = scanner.nextInt();\n\t\t\t\t\tString to = pages.get(buff.get(pi)).click(x, y);\n\t\t\t\t\tif (!to.equals(\"\")) {\n\t\t\t\t\t\tpi++;\n\t\t\t\t\t\tif (pi == buff.size())\n\t\t\t\t\t\t\tbuff.add(to);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tbuff.set(pi, to);\n\t\t\t\t\t\tbr = pi + 1;\n\t\t\t\t\t}\n\t\t\t\t} else if (op.equals(\"back\")) {\n\t\t\t\t\tif (pi != 0)\n\t\t\t\t\t\tpi--;\n\t\t\t\t} else if (op.equals(\"forward\")) {\n\t\t\t\t\tif (pi + 1 != br)\n\t\t\t\t\t\tpi++;\n\t\t\t\t} else\n\t\t\t\t\tSystem.out.println(buff.get(pi));\n\t\t\t}\n\t\t}\n\t}\n\n\tclass Button {\n\t\tint sx, sy, ex, ey;\n\t\tString to;\n\n\t\tpublic Button(int sx, int sy, int ex, int ey, String to) {\n\t\t\tsuper();\n\t\t\tthis.sx = sx;\n\t\t\tthis.sy = sy;\n\t\t\tthis.ex = ex;\n\t\t\tthis.ey = ey;\n\t\t\tthis.to = to;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"Button [sx=\" + sx + \", sy=\" + sy + \", ex=\" + ex + \", ey=\"\n\t\t\t\t\t+ ey + \", to=\" + to + \"]\";\n\t\t}\n\n\t\tboolean isHit(int x, int y) {\n\t\t\treturn sx <= x && x <= ex && sy <= y && y <= ey;\n\t\t}\n\t}\n\n\tclass Page {\n\t\tList<Button> buttons = new ArrayList<Main.Button>();\n\n\t\tString click(int x, int y) {\n\t\t\tfor (int i = 0; i < buttons.size(); i++) {\n\t\t\t\tif (buttons.get(i).isHit(x, y))\n\t\t\t\t\treturn buttons.get(i).to;\n\t\t\t}\n\t\t\treturn \"\";\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"Page [buttons=\" + buttons + \"]\";\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.Rectangle;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic Page[] buffer = new Page[1000001];\n\n\tpublic static void main(String[] args) {\n\t\twhile (true) {\n\t\t\tint N = sc.nextInt();\n\t\t\tif (N == 0) break;\n\t\t\tArrays.fill(buffer, null);\n\t\t\tint W = sc.nextInt();\n\t\t\tint H = sc.nextInt();\n\t\t\tPage[] pages = new Page[N];\n\t\t\tHashMap<String, Integer> map = new HashMap<String, Integer>();\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tString name = sc.next();\n\t\t\t\tmap.put(name, i);\n\t\t\t\tint b = sc.nextInt();\n\t\t\t\tpages[i] = new Page(name, b);\n\t\t\t\tfor (int j = 0; j < b; ++j) {\n\t\t\t\t\tint x1 = sc.nextInt();\n\t\t\t\t\tint y1 = sc.nextInt();\n\t\t\t\t\tint x2 = sc.nextInt();\n\t\t\t\t\tint y2 = sc.nextInt();\n\t\t\t\t\tpages[i].button[j] = new Rectangle(x1, y1, x2 - x1, y2 - y1);\n\t\t\t\t\tpages[i].linkTo[j] = sc.next();\n\t\t\t\t}\n\t\t\t}\n\t\t\tint bp = 0;\n\t\t\tbuffer[0] = pages[0];\n\t\t\tint M = sc.nextInt();\n\t\t\tfor (int i = 0; i < M; ++i) {\n\t\t\t\tString q = sc.next();\n\t\t\t\tif (q.equals(\"click\")) {\n\t\t\t\t\tint x = sc.nextInt();\n\t\t\t\t\tint y = sc.nextInt();\n\t\t\t\t\tfor (int j = 0; j < pages[bp].button.length; ++j) {\n\t\t\t\t\t\tif (pages[bp].button[j].contains(x, y)) {\n\t\t\t\t\t\t\tfor (int k = bp + 1; k < buffer.length && buffer[k] != null; ++k) {\n\t\t\t\t\t\t\t\tbuffer[k] = null;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbuffer[bp + 1] = pages[map.get(pages[bp].linkTo[j])];\n\t\t\t\t\t\t\t++bp;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else if (q.equals(\"back\")) {\n\t\t\t\t\tif (bp > 0) --bp;\n\t\t\t\t} else if (q.equals(\"forward\")) {\n\t\t\t\t\tif (bp < buffer.length - 1 && buffer[bp + 1] != null) ++bp;\n\t\t\t\t} else if (q.equals(\"show\")) {\n\t\t\t\t\tSystem.out.println(buffer[bp].name);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic class Page {\n\t\tRectangle[] button;\n\t\tString[] linkTo;\n\t\tString name;\n\n\t\tPage(String name, int buttonCount) {\n\t\t\tthis.name = name;\n\t\t\tthis.button = new Rectangle[buttonCount];\n\t\t\tthis.linkTo = new String[buttonCount];\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() throws IOException {\n\t\tScanner scanner = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint n = scanner.nextInt();\n\t\t\tif (n == 0)\n\t\t\t\tbreak;\n\t\t\tString np = \"\";\n\t\t\tint w = scanner.nextInt();\n\t\t\tint h = scanner.nextInt();\n\t\t\tMap<String, Page> pages = new HashMap<String, Main.Page>();\n\t\t\twhile (n-- > 0) {\n\t\t\t\tPage p = new Page();\n\t\t\t\tString name = scanner.next();\n\t\t\t\tif (np.equals(\"\"))\n\t\t\t\t\tnp = name;\n\t\t\t\tint b = scanner.nextInt();\n\t\t\t\twhile (b-- > 0) {\n\t\t\t\t\tint sx = scanner.nextInt();\n\t\t\t\t\tint sy = scanner.nextInt();\n\t\t\t\t\tint ex = scanner.nextInt();\n\t\t\t\t\tint ey = scanner.nextInt();\n\t\t\t\t\tString to = scanner.next();\n\t\t\t\t\tButton bn = new Button(sx, sy, ex, ey, to);\n\t\t\t\t\tp.buttons.add(bn);\n\t\t\t\t}\n\t\t\t\tpages.put(name, p);\n\t\t\t}\n\t\t\tint m = scanner.nextInt();\n\t\t\tList<String> buff = new ArrayList<String>();\n\t\t\tbuff.add(np);\n\t\t\tint pi = 0;\n\t\t\tint br = 1;\n\t\t\twhile (m-- > 0) {\n\t\t\t\tString op = scanner.next();\n\t\t\t\tif (op.equals(\"click\")) {\n\t\t\t\t\tint x = scanner.nextInt();\n\t\t\t\t\tint y = scanner.nextInt();\n\t\t\t\t\tString to = pages.get(buff.get(pi)).click(x, y);\n\t\t\t\t\tif (!to.equals(\"\") && pages.containsKey(to)) {\n\t\t\t\t\t\tpi++;\n\t\t\t\t\t\tif (pi == buff.size())\n\t\t\t\t\t\t\tbuff.add(to);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tbuff.set(pi, to);\n\t\t\t\t\t\tbr = pi + 1;\n\t\t\t\t\t}\n\t\t\t\t} else if (op.equals(\"back\")) {\n\t\t\t\t\tif (pi != 0)\n\t\t\t\t\t\tpi--;\n\t\t\t\t} else if (op.equals(\"forward\")) {\n\t\t\t\t\tif (pi + 1 != br)\n\t\t\t\t\t\tpi++;\n\t\t\t\t} else\n\t\t\t\t\tSystem.out.println(buff.get(pi));\n\t\t\t}\n\t\t}\n\t}\n\n\tclass Button {\n\t\tint sx, sy, ex, ey;\n\t\tString to;\n\n\t\tpublic Button(int sx, int sy, int ex, int ey, String to) {\n\t\t\tsuper();\n\t\t\tthis.sx = sx;\n\t\t\tthis.sy = sy;\n\t\t\tthis.ex = ex;\n\t\t\tthis.ey = ey;\n\t\t\tthis.to = to;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"Button [sx=\" + sx + \", sy=\" + sy + \", ex=\" + ex + \", ey=\"\n\t\t\t\t\t+ ey + \", to=\" + to + \"]\";\n\t\t}\n\n\t\tboolean isHit(int x, int y) {\n\t\t\treturn sx <= x && x <= ex && sy <= y && y <= ey;\n\t\t}\n\t}\n\n\tclass Page {\n\t\tList<Button> buttons = new ArrayList<Main.Button>();\n\n\t\tString click(int x, int y) {\n\t\t\tfor (int i = 0; i < buttons.size(); i++) {\n\t\t\t\tif (buttons.get(i).isHit(x, y))\n\t\t\t\t\treturn buttons.get(i).to;\n\t\t\t}\n\t\t\treturn \"\";\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"Page [buttons=\" + buttons + \"]\";\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\nclass Button {\n    int ulx, uly, lrx, lry;\n    public String linkName;\n    Button(int ulx, int uly, int lrx, int lry, String linkName) {\n        this.ulx = ulx;\n        this.uly = uly;\n        this.lrx = lrx;\n        this.lry = lry;\n        this.linkName = linkName;\n    }\n    boolean contains(int x, int y) {\n        //System.out.printf(\"%d,%d\\n\", x, y);\n        //System.out.println(ulx + \" \" +  lrx + \" \" + lry + \" \" + uly);\n        return (ulx <= x && x <= lrx && uly <= y && y <= lry);\n    }\n}\n\nclass Page {\n    public String name;\n    public Button[] links;\n    Page(String name, Button[] links) {\n        this.name = name;\n        this.links = links;\n    }\n    String getLinkPageName(int x, int y) {\n        for (Button b : links) {\n            if (b.contains(x, y)) {\n                return b.linkName;\n            }\n        }\n        return name;\n    }\n}\n\npublic class Main {\n    int n, W, H;\n    Scanner sc;\n    HashMap<String, Page> pages;\n    Main() {\n        sc = new Scanner(System.in);\n    }\n    boolean init() {\n        n = sc.nextInt();\n        if (n == 0) return false;\n        W = sc.nextInt();\n        H = sc.nextInt();\n        pages = new HashMap<String, Page>();\n        for (int i = 0; i < n; i++) {\n            String name = sc.next();\n            int b = sc.nextInt();\n            Button[] links = new Button[b];\n            for (int j = 0; j < b; j++) {\n                int ulx = sc.nextInt();\n                int uly = sc.nextInt();\n                int lrx = sc.nextInt();\n                int lry = sc.nextInt();\n                String linkName = sc.next();\n                links[j] = new Button(ulx, uly, lrx, lry, linkName);\n            }\n            pages.put(name, new Page(name, links));\n        }\n        return true;\n    }\n    void run() {\n        try {\n        while (init()) {\n            ArrayList<Page> history = new ArrayList<Page>();\n            history.add(pages.get(\"index\"));\n            int current = 0;\n            int m = sc.nextInt();\n            for (int i = 0; i < m; i++) {\n                String cmd = sc.next();\n                if (cmd.equals(\"click\")) {\n                    int x = sc.nextInt();\n                    int y = sc.nextInt();\n                    Page curPage = history.get(current);\n                    Page nextPage = pages.get(curPage.getLinkPageName(x, y));\n                    if (curPage != nextPage) {\n                        while (history.size() != current+1) {\n                            history.remove(current+1);\n                        }\n                        //history.removeRange(current, history.size());\n                        history.add(pages.get(curPage.getLinkPageName(x, y)));\n                        current++;\n                    }\n                } else if (cmd.equals(\"show\")) {\n                    System.out.println(history.get(current).name);\n                } else if (cmd.equals(\"back\")) {\n                    if (current > 0) current--;\n                } else if (cmd.equals(\"forward\")) {\n                    if (current < history.size()-1) current++;\n                }\n            }\n        }\n        } catch (Exception e) {\n            StackTraceElement[] stack = e.getStackTrace();\n            for (int i = 0;  i < stack.length; i++) \n                System.err.println(stack[i]);\n        }\n    }\n    public static void main(String[] args) {\n        new Main().run();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner in = new Scanner(System.in);\n\t\tint n;\n\t\tMap<String, List<Button>> map = new HashMap<String, List<Button>>();\n\t\tLinkedList<String> pre = new LinkedList<String>();\n\t\tLinkedList<String> next = new LinkedList<String>();\n\t\tString now = \"\";\n\t\twhile ((n = in.nextInt()) != 0) {\n\t\t\tmap.clear();\n\t\t\tpre.clear();\n\t\t\tnext.clear();\n\t\t\tint w = in.nextInt();\n\t\t\tint h = in.nextInt();\n\t\t\tfor (int page_info = 0; page_info < n; page_info++) {\n\t\t\t\tString pageName = in.next();\n\t\t\t\tif (page_info == 0) {\n\t\t\t\t\tnow = pageName;\n\t\t\t\t}\n\t\t\t\tint bt_count = in.nextInt();\n\t\t\t\tList<Button> buttons = new ArrayList<Button>();\n\t\t\t\tfor (int i = 0; i < bt_count; i++) {\n\t\t\t\t\tbuttons.add(new Button(in.nextInt(), in.nextInt(), in\n\t\t\t\t\t\t\t.nextInt(), in.nextInt(), in.next()));\n\t\t\t\t}\n\t\t\t\tmap.put(pageName, buttons);\n\t\t\t}\n\t\t\tint m = in.nextInt();\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tString command = in.next();\n\t\t\t\tif (\"click\".equals(command)) {\n\t\t\t\t\tint x = in.nextInt();\n\t\t\t\t\tint y = in.nextInt();\n\t\t\t\t\tfor (Button bt : map.get(now)) {\n\t\t\t\t\t\tif (bt.c(x, y)) {\n\t\t\t\t\t\t\tpre.addLast(now);\n\t\t\t\t\t\t\tnow = bt.target;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else if (\"back\".equals(command)) {\n\t\t\t\t\tif (!pre.isEmpty()) {\n\t\t\t\t\t\tnext.addFirst(now);\n\t\t\t\t\t\tnow = pre.pollLast();\n\t\t\t\t\t}\n\t\t\t\t} else if (\"forward\".equals(command)) {\n\t\t\t\t\tif (!next.isEmpty()) {\n\t\t\t\t\t\tpre.addLast(now);\n\t\t\t\t\t\tnow = next.pollFirst();\n\t\t\t\t\t}\n\t\t\t\t} else if (\"show\".equals(command)) {\n\t\t\t\t\tassert true;\n\t\t\t\t\tSystem.out.println(now);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n}\n\nclass Button {\n\tfinal int minX, minY, maxX, maxY;\n\tfinal String target;\n\n\tButton(int minX, int minY, int maxX, int maxY, String target) {\n\t\tthis.minX = minX;\n\t\tthis.minY = minY;\n\t\tthis.maxX = maxX;\n\t\tthis.maxY = maxY;\n\t\tthis.target = target;\n\t}\n\n\tboolean c(int x, int y) {\n\t\treturn (minX <= x && x < maxX && minY <= y && y < maxY);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.Rectangle;\nimport java.util.HashMap;\nimport java.util.LinkedList;\nimport java.util.Map;\nimport java.util.Scanner;\n\npublic class Main {\n\n    /**\n     * @param args\n     */\n    public static void main(String[] args) throws java.io.IOException {\n        // TODO 自動生成されたメソッド・スタブ\n        Scanner sc = new Scanner(System.in);\n        while (true) {\n            int n = sc.nextInt();\n            if (n == 0)\n                break;\n            sc.nextInt();\n            sc.nextInt();\n            Page pages[] = new Page[n];\n            LinkedList<Page> buffer = new LinkedList<Page>();\n            Map<String, Integer> index = new HashMap<String, Integer>();\n            // ページの作成\n            for (int i = 0; i < n; i++) {\n                String pagename = sc.next();\n                int b = sc.nextInt();\n                index.put(pagename, i);\n                pages[i] = new Page(pagename, b);\n                for (int j = 0; j < b; j++) {\n                    int x1 = sc.nextInt();\n                    int y1 = sc.nextInt();\n                    int x2 = sc.nextInt();\n                    int y2 = sc.nextInt();\n                    String linkname = sc.next();\n                    pages[i].mkBottan(j, x1, y1, x2, y2, linkname);\n                }\n            }\n            buffer.add(pages[0]);\n            int it = 0;\n            int ord_num = sc.nextInt();\n            for (int i = 0; i < ord_num; i++) {\n                String ordname = sc.next();\n                if (ordname.equals(\"click\")) {\n                    int x = sc.nextInt();\n                    int y = sc.nextInt();\n                    String linkedplace = pages[it].pageClicked(x, y);\n\n                    if (!linkedplace.equals(pages[it].getPageName())) {\n                        int next = index.get(linkedplace);\n                        int size = buffer.size();\n                        for (int j = it + 1; j <size; j++) {\n                            buffer.remove(j);\n                           \n                        }\n                        buffer.add(pages[next]);\n                        it++;\n                    }\n\n                } else if (ordname.equals(\"back\")) {\n                    if (it != 0)\n                        it--;\n                } else if (ordname.equals(\"forward\")) {\n                    if (it != buffer.size() - 1)\n                        it++;\n                } else if (ordname.equals(\"show\")) {\n                    System.out.println(buffer.get(it).getPageName());\n                }\n            }\n\n        }\n    }\n}\n\nclass Page {\n    private String pagename;\n    private Bottan[] bottans;\n    private int bottan_number;\n\n    Page(String pagename, int b) {\n        this.pagename = pagename;\n        this.bottan_number = b;\n        bottans = new Bottan[b];\n    }\n\n    void mkBottan(int bnum, int x1, int y1, int x2, int y2, String linkname) {\n        bottans[bnum] = new Bottan(x1, y1, x2, y2, linkname);\n    }\n\n    String pageClicked(int x, int y) {\n        String jump = this.pagename;\n        for (int i = 0; i < bottan_number; i++) {\n            if (bottans[i].isInBottan(x, y)) {\n                jump = bottans[i].getLinkName();\n                break;\n            }\n        }\n        return jump;\n    }\n\n    String getPageName() {\n        return pagename;\n    }\n}\n\nclass Bottan {\n    private String linkname;\n    private Rectangle bottan;\n\n    Bottan(int x1, int y1, int x2, int y2, String linkname) {\n        this.linkname = linkname;\n        bottan = new Rectangle(x1, y1, x2 - x1 + 1, y2 - y1 + 1);\n    }\n\n    boolean isInBottan(int x, int y) {\n        return bottan.contains(x, y);\n    }\n\n    String getLinkName() {\n        return linkname;\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner in = new Scanner(System.in);\n\t\tint n;\n\t\tMap<String, List<Button>> map = new HashMap<String, List<Button>>();\n\t\tLinkedList<String> pre = new LinkedList<String>();\n\t\tLinkedList<String> next = new LinkedList<String>();\n\t\tString now = \"\";\n\t\twhile ((n = in.nextInt()) != 0) {\n\t\t\tmap.clear();\n\t\t\tpre.clear();\n\t\t\tnext.clear();\n\t\t\tint w = in.nextInt();\n\t\t\tint h = in.nextInt();\n\t\t\tfor (int page_info = 0; page_info < n; page_info++) {\n\t\t\t\tString pageName = in.next();\n\t\t\t\tif (page_info == 0) {\n\t\t\t\t\tnow = pageName;\n\t\t\t\t}\n\t\t\t\tint bt_count = in.nextInt();\n\t\t\t\tList<Button> buttons = new ArrayList<Button>();\n\t\t\t\tfor (int i = 0; i < bt_count; i++) {\n\t\t\t\t\tbuttons.add(new Button(in.nextInt(), in.nextInt(), in\n\t\t\t\t\t\t\t.nextInt(), in.nextInt(), in.next()));\n\t\t\t\t}\n\t\t\t\tmap.put(pageName, buttons);\n\t\t\t}\n\t\t\tint m = in.nextInt();\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tString command = in.next();\n\t\t\t\tif (\"click\".equals(command)) {\n\t\t\t\t\tint x = in.nextInt();\n\t\t\t\t\tint y = in.nextInt();\n\t\t\t\t\tfor (Button bt : map.get(now)) {\n\t\t\t\t\t\tif (bt.c(x, y)) {\n\t\t\t\t\t\t\tpre.addLast(now);\n\t\t\t\t\t\t\tnow = bt.target;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else if (\"back\".equals(command)) {\n\t\t\t\t\tif (!pre.isEmpty()) {\n\t\t\t\t\t\tnext.addFirst(now);\n\t\t\t\t\t\tnow = pre.pollLast();\n\t\t\t\t\t}\n\t\t\t\t} else if (\"forward\".equals(command)) {\n\t\t\t\t\tif (!next.isEmpty()) {\n\t\t\t\t\t\tpre.addLast(now);\n\t\t\t\t\t\tnow = next.pollFirst();\n\t\t\t\t\t}\n\t\t\t\t} else if (\"show\".equals(command)) {\n\t\t\t\t\tassert true;\n\t\t\t\t\tSystem.out.println(now);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n}\n\nclass Button {\n\tfinal int minX, minY, maxX, maxY;\n\tfinal String target;\n\n\tButton(int minX, int minY, int maxX, int maxY, String target) {\n\t\tthis.minX = minX;\n\t\tthis.minY = minY;\n\t\tthis.maxX = maxX;\n\t\tthis.maxY = maxY;\n\t\tthis.target = target;\n\t}\n\n\tboolean c(int x, int y) {\n\t\treturn (minX <= x && x <= maxX && minY <= y && y <= maxY);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Rectangle2D;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.ListIterator;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\t\n\tpublic static class Page{\n\t\tString page_name;\n\t\tint page_number;\n\t\tint[][] btns;\n\t\tint[] links;\n\t\t\n\t\tpublic Page(String page_name, int page_number, int[][] btns, int[] links) {\n\t\t\tsuper();\n\t\t\tthis.page_name = page_name;\n\t\t\tthis.page_number = page_number;\n\t\t\tthis.btns = btns;\n\t\t\tthis.links = links;\n\t\t}\n\t\t\n\t\tpublic int touch(int x, int y){\n\t\t\tfor(int i = 0; i < btns.length; i++){\n\t\t\t\tfinal int lu_x = btns[i][0];\n\t\t\t\tfinal int lu_y = btns[i][1];\n\t\t\t\tfinal int rd_x = btns[i][2];\n\t\t\t\tfinal int rd_y = btns[i][3];\n\t\t\t\t\n\t\t\t\tif(lu_x <= x && x <= rd_x && lu_y <= y && y <= rd_y){\n\t\t\t\t\treturn links[i]; \n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn -1;\n\t\t}\n\t}\n\t\n\t\n\tpublic static void main(String[] args) {\n\t\tfinal Scanner sc = new Scanner(System.in);\n\t\t\n\t\twhile(true){\n\t\t\tfinal int n = sc.nextInt();\n\t\t\t\n\t\t\tif(n == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tfinal int W = sc.nextInt();\n\t\t\tfinal int H = sc.nextInt();\n\t\t\t\n\t\t\tString[] name = new String[n];\n\t\t\tint[] btns = new int[n];\n\t\t\tint[][][] rects = new int[n][][];\n\t\t\tString[][] links = new String[n][];\n\t\t\t\n\t\t\tHashMap<String, Integer> map = new HashMap<String, Integer>();\n\t\t\t\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tname[i] = sc.next();\n\t\t\t\tfinal int k = sc.nextInt();\n\t\t\t\tbtns[i] = k;\n\t\t\t\t\n\t\t\t\trects[i] = new int[k][4];\n\t\t\t\tlinks[i] = new String[k];\n\t\t\t\tfor(int j = 0; j < k; j++){\n\t\t\t\t\trects[i][j][0] = sc.nextInt();\n\t\t\t\t\trects[i][j][1] = sc.nextInt();\n\t\t\t\t\trects[i][j][2] = sc.nextInt();\n\t\t\t\t\trects[i][j][3] = sc.nextInt();\n\t\t\t\t\tlinks[i][j] = sc.next();\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tmap.put(name[i], i);\n\t\t\t}\n\t\t\t\n\t\t\tPage[] pages = new Page[n];\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tint[] link = new int[btns[i]];\n\t\t\t\tfor(int j = 0; j < btns[i]; j++){\n\t\t\t\t\tlink[j] = map.get(links[i][j]);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tpages[i] = new Page(name[i], i, rects[i], link);\n\t\t\t}\n\t\t\t\n\t\t\tArrayList<Integer> history = new ArrayList<Integer>();\n\t\t\thistory.add(0);\n\t\t\tint size = 1;\n\t\t\tint cur_pos = 0;\n\t\t\t\n\t\t\tint cur_page = 0;\n\t\t\tfinal int q = sc.nextInt();\n\t\t\tfor(int t = 0; t < q; t++){\n\t\t\t\tString input = sc.next();\n\t\t\t\t\n\t\t\t\tif(\"forward\".equals(input)){\n\t\t\t\t\tif(cur_pos < size - 1){\n\t\t\t\t\t\tcur_pos++;\n\t\t\t\t\t\tcur_page = history.get(cur_pos);\n\t\t\t\t\t}\n\t\t\t\t}else if(\"back\".equals(input)){\n\t\t\t\t\tif(cur_pos > 0){\n\t\t\t\t\t\tcur_pos--;\n\t\t\t\t\t\tcur_page = history.get(cur_pos);\n\t\t\t\t\t}\n\t\t\t\t}else if(\"click\".equals(input)){\n\t\t\t\t\tfinal int x = sc.nextInt();\n\t\t\t\t\tfinal int y = sc.nextInt();\n\t\t\t\t\t\n\t\t\t\t\tint ret = pages[cur_page].touch(x, y);\n\t\t\t\t\t\n\t\t\t\t\tif(ret >= 0){\n\t\t\t\t\t\tcur_pos++;\n\t\t\t\t\t\tcur_page = ret;\n\t\t\t\t\t\thistory.add(cur_page, cur_pos);\n\t\t\t\t\t\tsize = cur_pos + 1;\n\t\t\t\t\t}\n\t\t\t\t}else if(\"show\".equals(input)){\n\t\t\t\t\t//System.out.println(cur_pos + \" \" + size + \" \" + history);\n\t\t\t\t\tSystem.out.println(pages[cur_page].page_name);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.*;\n\nimport static java.lang.Integer.parseInt;\n\n/**\n * Problem D: Distorted Love\n */\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString line;\n\t\tString[] words;\n\n\t\tComparator<int[]> cmp = new Comparator<int[]>() {\n\t\t\t@Override\n\t\t\tpublic int compare(int[] o1, int[] o2) {\n\t\t\t\tif (o1[0] != o2[0]) {\n\t\t\t\t\treturn Integer.compare(o1[0], o2[0]);\n\t\t\t\t} else {\n\t\t\t\t\treturn Integer.compare(o1[1], o2[1]);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\twhile ((line = br.readLine()) != null && !line.isEmpty()) {\n\n\t\t\tint n = parseInt(line);\n\t\t\tif (n == 0) break;\n\n\t\t\t//????????¨??????\n\t\t\tbr.readLine();\n\n\t\t\tMap<String, Map<int[], String>> pages = new HashMap<>();\n\t\t\tDeque<String> stackF, stackB;\n\t\t\tstackF = new ArrayDeque<>();\n\t\t\tstackB = new ArrayDeque<>();\n\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\twords = br.readLine().split(\" \");\n\n\t\t\t\tString name = words[0];\n\t\t\t\tint b = parseInt(words[1]);\n\n\t\t\t\tpages.put(name, new TreeMap<>(cmp));\n\n\t\t\t\tfor (int j = 0; j < b; j++) {\n\t\t\t\t\twords = br.readLine().split(\" \");\n\t\t\t\t\tint[] pos = new int[4];\n\t\t\t\t\tfor (int k = 0; k < 4; k++) {\n\t\t\t\t\t\tpos[k] = parseInt(words[k]);\n\t\t\t\t\t}\n\t\t\t\t\tpages.get(name).put(pos, words[4]);\n\t\t\t\t}\n\t\t\t\tif (i == 0) {\n\t\t\t\t\tstackF.push(name);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint m = parseInt(br.readLine());\n\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\twords = br.readLine().split(\" \");\n\n\t\t\t\tString op = words[0];\n\n\t\t\t\tswitch (op) {\n\t\t\t\t\tcase \"click\":\n\t\t\t\t\t\tint x = parseInt(words[1]);\n\t\t\t\t\t\tint y = parseInt(words[2]);\n\t\t\t\t\t\tString page = stackF.peek();\n\t\t\t\t\t\tMap<int[], String> btns = pages.get(page);\n\t\t\t\t\t\tfor (int[] btn : btns.keySet()) {\n\t\t\t\t\t\t\tif (btn[0] <= x && x <= btn[2]\n\t\t\t\t\t\t\t\t\t&& btn[1] <= y && y <= btn[3]) {\n\t\t\t\t\t\t\t\tstackF.push(btns.get(btn));\n\t\t\t\t\t\t\t\tstackB.clear();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"back\":\n\t\t\t\t\t\tif (stackF.size() > 1) {\n\t\t\t\t\t\t\tstackB.push(stackF.pop());\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"forward\":\n\t\t\t\t\t\tif (!stackB.isEmpty()) {\n\t\t\t\t\t\t\tstackF.push(stackB.pop());\n\t\t\t\t\t\t} break;\n\t\t\t\t\tcase \"show\":\n\t\t\t\t\t\tSystem.out.println(stackF.peek());\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Scanner;\nimport java.util.TreeMap;\n\n//Distorted Love\npublic class Main{\n\n\tclass B{\n\t\tint x1, y1, x2, y2;\n\t\tString s;\n\t\tpublic B(int x1, int y1, int x2, int y2, String s) {\n\t\t\tthis.x1 = x1;\n\t\t\tthis.y1 = y1;\n\t\t\tthis.x2 = x2;\n\t\t\tthis.y2 = y2;\n\t\t\tthis.s = s;\n\t\t}\n\t}\n\t\n\tclass R{\n\t\tString name;\n\t\tList<B> l;\n\t\tpublic R(String name) {\n\t\t\tthis.name = name;\n\t\t\tl = new ArrayList<B>();\n\t\t}\n\t\tString click(int x, int y){\n\t\t\tfor(B b:l){\n\t\t\t\tif(b.x1<=x&&x<=b.x2&&b.y1<=y&&y<=b.y2)return b.s;\n\t\t\t}\n\t\t\treturn \"\";\n\t\t}\n\t}\n\t\n\tMap<String, Integer> ref;\n\tR[] page;\n\tint id;\n\t\n\tint get(String s){\n\t\tif(ref.containsKey(s))return ref.get(s);\n\t\tpage[id] = new R(s);\n\t\tref.put(s, id);\n\t\treturn id++;\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n==0)break;\n\t\t\tsc.next();sc.next();\n\t\t\tpage = new R[n];\n\t\t\tref = new TreeMap<String, Integer>();\n\t\t\tid = 0;\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tint x = get(sc.next());\n\t\t\t\tint k = sc.nextInt();\n\t\t\t\twhile(k--!=0){\n\t\t\t\t\tpage[x].l.add(new B(sc.nextInt(), sc.nextInt(), sc.nextInt(), sc.nextInt(), sc.next()));\n\t\t\t\t}\n\t\t\t}\n\t\t\tint m = sc.nextInt();\n\t\t\tR[] h = new R[m];\n\t\t\th[0] = page[0];\n\t\t\tint pos = 0;\n\t\t\tint t = 1;\n\t\t\twhile(m--!=0){\n\t\t\t\tString cmd = sc.next();\n\t\t\t\tif(cmd.equals(\"show\")){\n\t\t\t\t\tSystem.out.println(h[pos].name);\n\t\t\t\t}\n\t\t\t\telse if(cmd.equals(\"back\")){\n\t\t\t\t\tpos = Math.max(0, pos-1);\n\t\t\t\t}\n\t\t\t\telse if(cmd.equals(\"forward\")){\n\t\t\t\t\tpos = Math.min(t-1, pos+1);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tString hit = h[pos].click(sc.nextInt(), sc.nextInt());\n\t\t\t\t\tif(hit.equals(\"\"))continue;\n\t\t\t\t\tint x = ref.get(hit);\n\t\t\t\t\th[++pos] = page[x];\n\t\t\t\t\tt = pos+1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.HashMap;\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic class Page {\n\t\tString name;\n\t\tint lnum;\n\t\tLink link[];\n\n\t\tPage(String name, int lnum) {\n\t\t\tthis.name = name;\n\t\t\tthis.lnum = lnum;\n\t\t}\n\t}\n\n\tstatic class Link {\n\t\tint x1, y1, x2, y2;\n\t\tString name;\n\n\t\tLink(int x1, int y1, int x2, int y2, String name) {\n\t\t\tthis.x1 = x1;\n\t\t\tthis.y1 = y1;\n\t\t\tthis.x2 = x2;\n\t\t\tthis.y2 = y2;\n\t\t\tthis.name = name;\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n, m;\n\t\tint w, h;\n\t\tPage page[];\n\t\tint buf[];\n\t\tint pointer;\n\t\tint bufMax;\n\t\tHashMap<String, Integer> map = new HashMap<String, Integer>();\n\n\t\twhile (true) {\n\t\t\tn = sc.nextInt();\n\t\t\tif (n == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tw = sc.nextInt();\n\t\t\th = sc.nextInt();\n\t\t\tpage = new Page[n];\n\t\t\tmap.clear();\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tString name = sc.next();\n\t\t\t\tint lnum = sc.nextInt();\n\t\t\t\tpage[i] = new Page(name, lnum);\n\t\t\t\tpage[i].link = new Link[lnum];\n\t\t\t\tfor (int j = 0; j < lnum; j++) {\n\t\t\t\t\tint x1 = sc.nextInt();\n\t\t\t\t\tint y1 = sc.nextInt();\n\t\t\t\t\tint x2 = sc.nextInt();\n\t\t\t\t\tint y2 = sc.nextInt();\n\t\t\t\t\tString linkName = sc.next();\n\t\t\t\t\tpage[i].link[j] = new Link(x1, y1, x2, y2, linkName);\n\t\t\t\t}\n\t\t\t\tmap.put(name, i);\n\t\t\t}\n\n\t\t\tm = sc.nextInt();\n\t\t\tbuf = new int[m + 5];\n\t\t\tpointer = 0;\n\t\t\tbufMax = 0;\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tString o = sc.next();\n\t\t\t\tif (o.equals(\"click\")) {\n\t\t\t\t\tint x = sc.nextInt();\n\t\t\t\t\tint y = sc.nextInt();\n\t\t\t\t\tfor (int j = 0; j < page[pointer].lnum; j++) {\n\t\t\t\t\t\tif (page[pointer].link[j].x1 <= x && x <= page[pointer].link[j].x2 &&\n\t\t\t\t\t\t\t\tpage[pointer].link[j].y1 <= y && y <= page[pointer].link[j].y2) {\n\t\t\t\t\t\t\tbuf[pointer + 1] = map.get(page[pointer].link[j].name);\n\t\t\t\t\t\t\tpointer++;\n\t\t\t\t\t\t\tbufMax = pointer;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else if (o.equals(\"show\")) {\n\t\t\t\t\tSystem.out.println(page[pointer].name);\n\t\t\t\t} else if (o.equals(\"back\")) {\n\t\t\t\t\tif (0 < pointer) {\n\t\t\t\t\t\tpointer--;\n\t\t\t\t\t}\n\t\t\t\t} else if (o.equals(\"forward\")) {\n\t\t\t\t\tif (pointer < bufMax) {\n\t\t\t\t\t\tpointer++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\nclass Button {\n    int ulx, uly, lrx, lry;\n    public String linkName;\n    Button(int ulx, int uly, int lrx, int lry, String linkName) {\n        this.ulx = ulx;\n        this.uly = uly;\n        this.lrx = lrx;\n        this.lry = lry;\n        this.linkName = linkName;\n    }\n    boolean contains(int x, int y) {\n        //System.out.printf(\"%d,%d\\n\", x, y);\n        //System.out.println(ulx + \" \" +  lrx + \" \" + lry + \" \" + uly);\n        return (ulx <= x && x <= lrx && uly <= y && y <= lry);\n    }\n}\n\nclass Page {\n    public String name;\n    public Button[] links;\n    Page(String name, Button[] links) {\n        this.name = name;\n        this.links = links;\n    }\n    String getLinkPageName(int x, int y) {\n        for (Button b : links) {\n            if (b.contains(x, y)) {\n                return b.linkName;\n            }\n        }\n        return name;\n    }\n}\n\npublic class Main {\n    int n, W, H;\n    Scanner sc;\n    HashMap<String, Page> pages;\n    Main() {\n        sc = new Scanner(System.in);\n    }\n    Page first;\n    boolean init() {\n        n = sc.nextInt();\n        if (n == 0) return false;\n        W = sc.nextInt();\n        H = sc.nextInt();\n        pages = new HashMap<String, Page>();\n        for (int i = 0; i < n; i++) {\n            String name = sc.next();\n            int b = sc.nextInt();\n            Button[] links = new Button[b];\n            for (int j = 0; j < b; j++) {\n                int ulx = sc.nextInt();\n                int uly = sc.nextInt();\n                int lrx = sc.nextInt();\n                int lry = sc.nextInt();\n                String linkName = sc.next();\n                links[j] = new Button(ulx, uly, lrx, lry, linkName);\n            }\n            Page page = new Page(name, links);\n            if (i == 0) first = page;\n            pages.put(name, page);\n        }\n        return true;\n    }\n    void run() {\n        while (init()) {\n            ArrayList<Page> history = new ArrayList<Page>();\n            history.add(first);\n            int current = 0;\n            int m = sc.nextInt();\n            for (int i = 0; i < m; i++) {\n                String cmd = sc.next();\n                if (cmd.equals(\"click\")) {\n                    int x = sc.nextInt();\n                    int y = sc.nextInt();\n                    Page curPage = history.get(current);\n                    Page nextPage = pages.get(curPage.getLinkPageName(x, y));\n                    if (curPage != nextPage) {\n                        while (history.size() != current+1) {\n                            history.remove(current+1);\n                        }\n                        //history.removeRange(current, history.size());\n                        history.add(pages.get(curPage.getLinkPageName(x, y)));\n                        current++;\n                    }\n                } else if (cmd.equals(\"show\")) {\n                    System.out.println(history.get(current).name);\n                } else if (cmd.equals(\"back\")) {\n                    if (current > 0) current--;\n                } else if (cmd.equals(\"forward\")) {\n                    if (current < history.size()-1) current++;\n                }\n            }\n        }\n    }\n    public static void main(String[] args) {\n        new Main().run();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.IOException;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() throws IOException {\n\t\tScanner scanner = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint n = scanner.nextInt();\n\t\t\tif (n == 0)\n\t\t\t\tbreak;\n\t\t\tString s = \"\";\n\t\t\tint w = scanner.nextInt();\n\t\t\tint h = scanner.nextInt();\n\t\t\tMap<String, Page> map = new HashMap<String, Page>();\n\t\t\twhile (n-- > 0) {\n\t\t\t\tString name = scanner.next();\n\t\t\t\tif (s.isEmpty())\n\t\t\t\t\ts = name;\n\t\t\t\tint b = scanner.nextInt();\n\t\t\t\tButton[] buttons = new Button[b];\n\t\t\t\tfor (int i = 0; i < b; i++) {\n\t\t\t\t\tint sx = scanner.nextInt();\n\t\t\t\t\tint sy = scanner.nextInt();\n\t\t\t\t\tint ex = scanner.nextInt();\n\t\t\t\t\tint ey = scanner.nextInt();\n\t\t\t\t\tString to = scanner.next();\n\t\t\t\t\tbuttons[i] = new Button(sx, sy, ex, ey, to);\n\t\t\t\t}\n\t\t\t\tmap.put(name, new Page(buttons));\n\t\t\t}\n\t\t\tint m = scanner.nextInt();\n\t\t\tString[] buff = new String[m];\n\t\t\tbuff[0] = s;\n\t\t\tint l = 0;\n\t\t\tint r = 1;\n\t\t\twhile (m-- > 0) {\n\t\t\t\tString op = scanner.next();\n\t\t\t\tif (op.equals(\"click\")) {\n\t\t\t\t\tint x = scanner.nextInt();\n\t\t\t\t\tint y = scanner.nextInt();\n\t\t\t\t\tString to = map.get(buff[l]).click(x, y);\n\t\t\t\t\tif (!to.isEmpty()) {\n\t\t\t\t\t\tbuff[++l] = to;\n\t\t\t\t\t\tr = l + 1;\n\t\t\t\t\t}\n\t\t\t\t} else if (op.equals(\"back\"))\n\t\t\t\t\tl = Math.max(0, l - 1);\n\t\t\t\telse if (op.equals(\"forward\"))\n\t\t\t\t\tl = Math.min(r - 1, l + 1);\n\t\t\t\telse\n\t\t\t\t\tSystem.out.println(buff[l]);\n\t\t\t}\n\t\t}\n\t}\n\n\tclass Button {\n\t\tint sx, sy, ex, ey;\n\t\tString to;\n\n\t\tpublic Button(int sx, int sy, int ex, int ey, String to) {\n\t\t\tsuper();\n\t\t\tthis.sx = sx;\n\t\t\tthis.sy = sy;\n\t\t\tthis.ex = ex;\n\t\t\tthis.ey = ey;\n\t\t\tthis.to = to;\n\n\t\t}\n\n\t\tboolean isHit(int x, int y) {\n\t\t\treturn sx <= x && x <= ex && sy <= y && y <= ey;\n\n\t\t}\n\n\t}\n\n\tclass Page {\n\t\tButton[] buttons;\n\n\t\tpublic Page(Button[] buttons) {\n\t\t\tsuper();\n\t\t\tthis.buttons = buttons;\n\t\t}\n\n\t\tString click(int x, int y) {\n\t\t\tfor (Button b : buttons) {\n\t\t\t\tif (b.isHit(x, y))\n\t\t\t\t\treturn b.to;\n\t\t\t}\n\t\t\treturn \"\";\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.*;\n\nimport static java.lang.Integer.parseInt;\n\n/**\n * Problem D: Distorted Love\n */\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString line;\n\t\tString[] words;\n\n\t\tComparator<int[]> cmp = new Comparator<int[]>() {\n\t\t\t@Override\n\t\t\tpublic int compare(int[] o1, int[] o2) {\n\t\t\t\tif (o1[0] != o2[0]) {\n\t\t\t\t\treturn Integer.compare(o1[0], o2[0]);\n\t\t\t\t} else {\n\t\t\t\t\treturn Integer.compare(o1[1], o2[1]);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\twhile ((line = br.readLine()) != null && !line.isEmpty()) {\n\n\t\t\tint n = parseInt(line);\n\t\t\tif (n == 0) break;\n\n\t\t\t//????????¨??????\n\t\t\tbr.readLine();\n\n\t\t\tMap<String, NavigableMap<int[], String>> pages = new HashMap<>();\n\t\t\tDeque<String> stackF, stackB;\n\t\t\tstackF = new ArrayDeque<>();\n\t\t\tstackB = new ArrayDeque<>();\n\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\twords = br.readLine().split(\" \");\n\n\t\t\t\tString name = words[0];\n\t\t\t\tint b = parseInt(words[1]);\n\n\t\t\t\tpages.put(name, new TreeMap<>(cmp));\n\n\t\t\t\tfor (int j = 0; j < b; j++) {\n\t\t\t\t\twords = br.readLine().split(\" \");\n\t\t\t\t\tint[] pos = new int[4];\n\t\t\t\t\tfor (int k = 0; k < 4; k++) {\n\t\t\t\t\t\tpos[k] = parseInt(words[k]);\n\t\t\t\t\t}\n\t\t\t\t\tpages.get(name).put(pos, words[4]);\n\t\t\t\t}\n\t\t\t\tif (i == 0) {\n\t\t\t\t\tstackF.push(name);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint m = parseInt(br.readLine());\n\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\twords = br.readLine().split(\" \");\n\n\t\t\t\tString op = words[0];\n\n\t\t\t\tswitch (op) {\n\t\t\t\t\tcase \"click\":\n\t\t\t\t\t\tint x = parseInt(words[1]);\n\t\t\t\t\t\tint y = parseInt(words[2]);\n\t\t\t\t\t\tString page = stackF.peek();\n\t\t\t\t\t\tNavigableMap<int[], String> buttons = pages.get(page);\n\t\t\t\t\t\tint[] button = buttons.floorKey(new int[]{x, y});\n\t\t\t\t\t\tif (button != null) {\n\t\t\t\t\t\t\tstackF.push(buttons.get(button));\n\t\t\t\t\t\t\tstackB.clear();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"back\":\n\t\t\t\t\t\tif (!stackF.isEmpty()) {\n\t\t\t\t\t\t\tstackB.push(stackF.pop());\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"forward\":\n\t\t\t\t\t\tif (!stackB.isEmpty()) {\n\t\t\t\t\t\t\tstackF.push(stackB.pop());\n\t\t\t\t\t\t} break;\n\t\t\t\t\tcase \"show\":\n\t\t\t\t\t\tSystem.out.println(stackF.peek());\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.Rectangle;\nimport java.util.HashMap;\nimport java.util.LinkedList;\nimport java.util.Map;\nimport java.util.Scanner;\n\npublic class Main {\n\n    /**\n     * @param args\n     */\n    public static void main(String[] args) throws java.io.IOException {\n        // TODO 自動生成されたメソッド・スタブ\n        Scanner sc = new Scanner(System.in);\n        while (true) {\n            int n = sc.nextInt();\n            if (n == 0)\n                break;\n            sc.nextInt();\n            sc.nextInt();\n            Page pages[] = new Page[n];\n            LinkedList<Page> buffer = new LinkedList<Page>();\n            Map<String, Integer> index = new HashMap<String, Integer>();\n            // ページの作成\n            for (int i = 0; i < n; i++) {\n                String pagename = sc.next();\n                int b = sc.nextInt();\n                index.put(pagename, i);\n                pages[i] = new Page(pagename, b);\n                for (int j = 0; j < b; j++) {\n                    int x1 = sc.nextInt();\n                    int y1 = sc.nextInt();\n                    int x2 = sc.nextInt();\n                    int y2 = sc.nextInt();\n                    String linkname = sc.next();\n                    pages[i].mkBottan(j, x1, y1, x2, y2, linkname);\n                }\n            }\n            buffer.add(pages[0]);\n            int it = 0;\n            int ord_num = sc.nextInt();\n            for (int i = 0; i < ord_num; i++) {\n                String ordname = sc.next();\n                if (ordname.equals(\"click\")) {\n                    int x = sc.nextInt();\n                    int y = sc.nextInt();\n                    String linkedplace = pages[it].pageClicked(x, y);\n\n                    if (!linkedplace.equals(pages[it].getPageName())) {\n                        int next = index.get(linkedplace);\n                        for (int j = it + 1; j < buffer.size(); j++) {\n                            buffer.remove(j);\n                        }\n                        buffer.add(pages[next]);\n                        it++;\n                    }\n\n                } else if (ordname.equals(\"back\")) {\n                    if (it != 0)\n                        it--;\n                } else if (ordname.equals(\"forward\")) {\n                    if (it != buffer.size() - 1)\n                        it++;\n                } else if (ordname.equals(\"show\")) {\n                    System.out.println(buffer.get(it).getPageName());\n                }\n            }\n\n        }\n    }\n}\n\nclass Page {\n    private String pagename;\n    private Bottan[] bottans;\n    private int bottan_number;\n\n    Page(String pagename, int b) {\n        this.pagename = pagename;\n        this.bottan_number = b;\n        bottans = new Bottan[b];\n    }\n\n    void mkBottan(int bnum, int x1, int y1, int x2, int y2, String linkname) {\n        bottans[bnum] = new Bottan(x1, y1, x2, y2, linkname);\n    }\n\n    String pageClicked(int x, int y) {\n        String jump = this.pagename;\n        for (int i = 0; i < bottan_number; i++) {\n            if (bottans[i].isInBottan(x, y)) {\n                jump = bottans[i].getLinkName();\n                break;\n            }\n        }\n        return jump;\n    }\n\n    String getPageName() {\n        return pagename;\n    }\n}\n\nclass Bottan {\n    private String linkname;\n    private Rectangle bottan;\n\n    Bottan(int x1, int y1, int x2, int y2, String linkname) {\n        this.linkname = linkname;\n        bottan = new Rectangle(x1, y1, x2 - x1 + 1, y2 - y1 + 1);\n    }\n\n    boolean isInBottan(int x, int y) {\n        return bottan.contains(x, y);\n    }\n\n    String getLinkName() {\n        return linkname;\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.Map;\nimport java.util.Scanner;\nimport java.util.Set;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner scan = new Scanner(System.in);\n\t\tint n = scan.nextInt();\n\t\tscan.next();\n\t\tscan.next();\n\t\tString link = scan.next();\n\t\tD d = new D(link);\n\t\tfor (int b = scan.nextInt(); b-- > 0;) {\n\t\t\td.setA(link, scan.nextInt(), scan.nextInt(), scan.nextInt(), scan\n\t\t\t\t\t.nextInt(), scan.next());\n\t\t}\n\t\tfor (; n-- > 1;) {\n\t\t\tlink = scan.next();\n\t\t\tfor (int b = scan.nextInt(); b-- > 0;) {\n\t\t\t\td.setA(link, scan.nextInt(), scan.nextInt(), scan.nextInt(),\n\t\t\t\t\t\tscan.nextInt(), scan.next());\n\t\t\t}\n\t\t}\n\t\tfor (int m = scan.nextInt(); m-- > 0;) {\n\t\t\tString command = scan.next();\n\t\t\tif (command.equals(\"click\")) {\n\t\t\t\td.click(scan.nextInt(), scan.nextInt());\n\t\t\t} else if (command.equals(\"show\")) {\n\t\t\t\tSystem.out.println(d.show());\n\t\t\t} else if (command.equals(\"back\")) {\n\t\t\t\td.back();\n\t\t\t} else if (command.equals(\"forward\")) {\n\t\t\t\td.forward();\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic D(String link) {\n\t\thistory.add(link);\n\t}\n\n\tLinkedList<String> history = new LinkedList<String>();\n\tint i = 0;\n\tMap<String, Set<A>> pages = new HashMap<String, Set<A>>();\n\n\tvoid setA(String page, int left, int top, int right, int bottom, String link) {\n\t\tif (!pages.containsKey(page)) {\n\t\t\tpages.put(page, new HashSet<A>());\n\t\t}\n\t\tpages.get(page).add(new A(left, right, top, bottom, link));\n\t}\n\n\tString show() {\n\t\treturn history.get(i);\n\t}\n\n\tvoid click(int x, int y) {\n\t\tfor (A a : pages.get(history.get(i))) {\n\t\t\tif (a.contains(x, y)) {\n\t\t\t\ti++;\n\t\t\t\twhile (history.size() > i) {\n\t\t\t\t\thistory.pollLast();\n\t\t\t\t}\n\t\t\t\thistory.add(a.toString());\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid back() {\n\t\tif (i > 0) {\n\t\t\ti--;\n\t\t}\n\t}\n\n\tvoid forward() {\n\t\tif (i + 1 < history.size()) {\n\t\t\ti++;\n\t\t}\n\t}\n\n\tclass A {\n\t\tint left, right, top, bottom;\n\t\tString link;\n\n\t\tpublic A(int left, int right, int top, int bottom, String link) {\n\t\t\tthis.left = left;\n\t\t\tthis.right = right;\n\t\t\tthis.top = top;\n\t\t\tthis.bottom = bottom;\n\t\t\tthis.link = link;\n\t\t}\n\n\t\tboolean contains(int x, int y) {\n\t\t\treturn (left <= x && x <= right) && (top <= y && y <= bottom);\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn link;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.HashMap;\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic class Page {\n\t\tString name;\n\t\tint bnum;\n\t\tLink link[];\n\t\tString linkName[];\n\t}\n\n\tstatic class Link {\n\t\tint x1, y1, x2, y2;\n\n\t\tLink(int x1, int y1, int x2, int y2) {\n\t\t\tthis.x1 = x1;\n\t\t\tthis.y1 = y1;\n\t\t\tthis.x2 = x2;\n\t\t\tthis.y2 = y2;\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n, m;\n\t\tint w, h;\n\t\tPage page[];\n\t\tHashMap<String, Integer> map = new HashMap<String, Integer>();\n\t\tint buf[];\n\t\tint bufMax;\n\t\tint pointer;\n\n\t\twhile (true) {\n\t\t\tn = sc.nextInt();\n\t\t\tif (n == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tw = sc.nextInt();\n\t\t\th = sc.nextInt();\n\t\t\tpage = new Page[n];\n\t\t\tmap.clear();\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tpage[i] = new Page();\n\t\t\t\tString name = sc.next();\n\t\t\t\tint lnum = sc.nextInt();\n\t\t\t\tpage[i].name = name;\n\t\t\t\tpage[i].bnum = lnum;\n\t\t\t\tif (lnum != 0) {\n\t\t\t\t\tpage[i].link = new Link[lnum];\n\t\t\t\t\tpage[i].linkName = new String[lnum];\n\t\t\t\t\tfor (int j = 0; j < lnum; j++) {\n\t\t\t\t\t\tint x1 = sc.nextInt();\n\t\t\t\t\t\tint y1 = sc.nextInt();\n\t\t\t\t\t\tint x2 = sc.nextInt();\n\t\t\t\t\t\tint y2 = sc.nextInt();\n\t\t\t\t\t\tString linkName = sc.next();\n\t\t\t\t\t\tpage[i].link[j] = new Link(x1, y1, x2, y2);\n\t\t\t\t\t\tpage[i].linkName[j] = linkName;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tmap.put(name, i);\n\t\t\t}\n\n\t\t\tm = sc.nextInt();\n\t\t\tbuf = new int[m + 10];\n\t\t\tbufMax = 0;\n\t\t\tpointer = 0;\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tString order = sc.next();\n\t\t\t\tif (order.equals(\"click\")) {\n\t\t\t\t\tint x = sc.nextInt();\n\t\t\t\t\tint y = sc.nextInt();\n\t\t\t\t\tfor (int j = 0; j < page[pointer].bnum; j++) {\n\t\t\t\t\t\tif (page[pointer].link[j].x1 <= x && x <= page[pointer].link[j].x2 &&\n\t\t\t\t\t\t\t\tpage[pointer].link[j].y1 <= y && y <= page[pointer].link[j].y2) {\n\t\t\t\t\t\t\tbuf[pointer + 1] = map.get(page[pointer].linkName[j]);\n\t\t\t\t\t\t\tpointer++;\n\t\t\t\t\t\t\tbufMax = pointer;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else if (order.equals(\"show\")) {\n\t\t\t\t\tSystem.out.println(page[pointer].name);\n\t\t\t\t} else if (order.equals(\"back\")) {\n\t\t\t\t\tif (0 < pointer) {\n\t\t\t\t\t\tpointer--;\n\t\t\t\t\t}\n\t\t\t\t} else if (order.equals(\"forward\")) {\n\t\t\t\t\tif (pointer < bufMax) {\n\t\t\t\t\t\tpointer++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.util.Map.Entry;\nimport java.math.*;\nimport java.awt.geom.*;\nimport java.io.*;\n      \n      \npublic class Main {\t\n\tstatic char[] tank = new char[] {'^','>','v','<'};\n\tstatic int[] vx = new int[] {0,1,0,-1};\n\tstatic int[] vy = new int[] {-1,0,1,0};\n\tstatic final int INF = 2 << 28;\n\tstatic String str;\n\tstatic StringBuilder sb;\n\tstatic int ID;\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true) {\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n == 0) break;\n\t\t\tint w = sc.nextInt();\n\t\t\tint h = sc.nextInt();\n\t\t\tData data[] = new Data[n];\n\t\t\tHashMap<String,Integer> map = new HashMap<String,Integer>();\n\t\t\tfor(int i = 0; i < n; i++) {\n\t\t\t\tString name = sc.next();\n\t\t\t\tmap.put(name, i);\n\t\t\t\tint b = sc.nextInt();\n\t\t\t\tdata[i] = new Data(name,b);\n\t\t\t\tfor(int j = 0; j < b; j++) {\n\t\t\t\t\tint AA = sc.nextInt();\n\t\t\t\t\tint BB = sc.nextInt();\n\t\t\t\t\tint CC = sc.nextInt();\n\t\t\t\t\tint DD = sc.nextInt();\n\t\t\t\t\tString EE = sc.next();\n\t\t\t\t\tdata[i].bt[j] = new BT(EE,AA,BB,CC,DD);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint[] bf = new int[10000];\n\t\t\t\n\t\t\tbf[0] = 0;\n\t\t\tint ptr = 0;\n\t\t\tint up  = 0;\n\t\t\t\n\t\t\tint m = sc.nextInt();\n\t\t\tfor(int i = 0; i < m; i++) {\n\t\t\t\tint N = bf[ptr];\n\t\t\t\t\n\t\t\t\tData now = data[N];\n\t\t\t\t\n\t\t\t\tString in = sc.next();\n\t\t\t\tif(in.equals(\"click\")) {\n\t\t\t\t\tint x = sc.nextInt();\n\t\t\t\t\tint y = sc.nextInt();\n\t\t\t\t\tfor(int j = 0; j < now.bt.length; j++) {\n\t\t\t\t\t\tint x0 = now.bt[j].x0;\n\t\t\t\t\t\tint x1 = now.bt[j].x1;\n\t\t\t\t\t\tint y0 = now.bt[j].y0;\n\t\t\t\t\t\tint y1 = now.bt[j].y1;\n\t\t\t\t\t\tif(x0 <= x && x <= x1 && y0 <= y && y <= y1) {\n\t\t\t\t\t\t\tup = ++ptr;\n\t\t\t\t\t\t\tbf[ptr] = map.get(now.bt[j].name);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(in.equals(\"back\")) {\n\t\t\t\t\tptr = Math.max(0, ptr-1);\n\t\t\t\t}\n\t\t\t\telse if(in.equals(\"forward\")) {\n\t\t\t\t\tptr = Math.min(up, ptr+1);\n\t\t\t\t}\n\t\t\t\telse if(in.equals(\"show\")) {\n\t\t\t\t\tSystem.out.println(now.name);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t}\n\t}\n\tstatic class Data {\n\t\tString name;\n\t\tBT bt[];\n\t\tData(String a, int b) {\n\t\t\tname = a;\n\t\t\tbt = new BT[b];\n\t\t}\n\t}\n\tstatic class BT {\n\t\tString name;\n\t\tint x0;\n\t\tint y0;\n\t\tint x1;\n\t\tint y1;\n\t\tBT(String A, int a, int b, int c, int d) {\n\t\t\tname = A;\n\t\t\tx0 = a;\n\t\t\ty0 = b;\n\t\t\tx1 = c;\n\t\t\ty1 = d;\n\t\t}\n\t}\n\t\n\t\n\t\n\t\n\t\n }"
  },
  {
    "language": "Java",
    "code": "import java.awt.Rectangle;\nimport java.util.HashMap;\nimport java.util.LinkedList;\nimport java.util.Map;\nimport java.util.Scanner;\n\npublic class Main {\n\n    /**\n     * @param args\n     */\n    public static void main(String[] args) throws java.io.IOException {\n        // TODO 自動生成されたメソッド・スタブ\n        Scanner sc = new Scanner(System.in);\n        while (true) {\n            int n = sc.nextInt();\n            if (n == 0)\n                break;\n            sc.nextInt();\n            sc.nextInt();\n            Page pages[] = new Page[n];\n            LinkedList<Page> buffer = new LinkedList<Page>();\n            Map<String, Integer> index = new HashMap<String, Integer>();\n            // ページの作成\n            for (int i = 0; i < n; i++) {\n                String pagename = sc.next();\n                int b = sc.nextInt();\n                index.put(pagename, i);\n                pages[i] = new Page(pagename, b);\n                for (int j = 0; j < b; j++) {\n                    int x1 = sc.nextInt();\n                    int y1 = sc.nextInt();\n                    int x2 = sc.nextInt();\n                    int y2 = sc.nextInt();\n                    String linkname = sc.next();\n                    pages[i].mkBottan(j, x1, y1, x2, y2, linkname);\n                }\n            }\n            buffer.add(pages[0]);\n            int it = 0;\n            int ord_num = sc.nextInt();\n            for (int i = 0; i < ord_num; i++) {\n                String ordname = sc.next();\n                if (ordname.equals(\"click\")) {\n                    int x = sc.nextInt();\n                    int y = sc.nextInt();\n                    String linkedplace = buffer.get(it).pageClicked(x, y);\n                    if (!linkedplace.equals(buffer.get(it).getPageName())) {\n                        int next = index.get(linkedplace);\n                        while (buffer.size() != it + 1) {\n                            buffer.removeLast();\n                        }\n                        buffer.add(pages[next]);\n                        it++;\n                    }\n                } else if (ordname.equals(\"back\")) {\n                    if (it != 0)\n                        it--;\n                } else if (ordname.equals(\"forward\")) {\n                    if (it != buffer.size() - 1)\n                        it++;\n                } else if (ordname.equals(\"show\")) {\n                    System.out.println(buffer.get(it).getPageName());\n                }\n            }\n        }\n    }\n}\n\nclass Page {\n    private String pagename;\n    private Bottan[] bottans;\n    private int bottan_number;\n\n    Page(String pagename, int b) {\n        this.pagename = pagename;\n        this.bottan_number = b;\n        bottans = new Bottan[b];\n    }\n\n    void mkBottan(int bnum, int x1, int y1, int x2, int y2, String linkname) {\n        bottans[bnum] = new Bottan(x1, y1, x2, y2, linkname);\n    }\n\n    String pageClicked(int x, int y) {\n        String jump = this.pagename;\n        for (int i = 0; i < bottan_number; i++) {\n            if (bottans[i].isInBottan(x, y)) {\n                jump = bottans[i].getLinkName();\n                break;\n            }\n        }\n        return jump;\n    }\n\n    String getPageName() {\n        return pagename;\n    }\n}\n\nclass Bottan {\n    private String linkname;\n    private Rectangle bottan;\n\n    Bottan(int x1, int y1, int x2, int y2, String linkname) {\n        this.linkname = linkname;\n        bottan = new Rectangle(x1, y1, x2 - x1 + 1, y2 - y1 + 1);\n    }\n\n    boolean isInBottan(int x, int y) {\n        return bottan.contains(x, y);\n    }\n\n    String getLinkName() {\n        return linkname;\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\n \nclass TEST{\n\tstatic void Main(){\n\t\twhile(true){\n\t\t\tint n=int.Parse(Console.ReadLine());\n\t\t\tif(n==0)break;\n\t\t\tSol mySol =new Sol(n);\n\t\t\tmySol.Solve();\n\t\t}\n\t}\n}\n\nclass Sol{\n\tpublic void Solve(){\n\t\t//Dictionary<String,Page> D=new Dictionary<String,Page>();\n\t\t\n\t\t//List<String> buf=new List<String>();\n\t\t//String EOB=\"nullnullnullnullnullnull\";\n\t\t\n\t\tfor(int i=0;i<N;i++){\n\t\t\tvar s=rsa();\n\t\t\tvar P=new Page();\n\t\t\tP.Name=s[0];\n\t\t\tP.LCount=int.Parse(s[1]);\n\n\t\t\tfor(int j=0;j<P.LCount;j++){\n\t\t\t\ts=rsa();\n\t\t\t\t//Area A=new Area(int.Parse(s[0]),int.Parse(s[1]),int.Parse(s[2]),int.Parse(s[3]));\n\t\t\t\t//P.Links.Add(s[4],A);\n\t\t\t}\n/*\n\t\t\tD.Add(P.Name,P);\n\t\t\tif(i==0){\n\t\t\t\tbuf.Add(P.Name);\n\t\t\t\tbuf.Add(EOB);\n\t\t\t}\n*/\n\t\t}\n\t\t\n\t\tint q=ri();\n\t\tString order=\"\";\n\t\t//int cur=0;\n\t\t\n\t\tfor(int i=0;i<q;i++){\n\t\t\torder=rs();\n\t\t\tswitch(order[0]){\n\t\t\t\tcase 'c':\n/*\t\t\t\t\tvar ss=order.Split(' ');\n\t\t\t\t\tint px=int.Parse(ss[1]);\n\t\t\t\t\tint py=int.Parse(ss[2]);\n\t\t\t\t\tString trgt=\"\";\n\t\t\t\t\tforeach(String lname in D[buf[cur]].Links.Keys){\n\t\t\t\t\t\tif(D[buf[cur]].Links[lname].xmin<=px &&\n\t\t\t\t\t\t   D[buf[cur]].Links[lname].xmax>=px &&\n\t\t\t\t\t\t   D[buf[cur]].Links[lname].ymin<=py &&\n\t\t\t\t\t\t   D[buf[cur]].Links[lname].ymax>=py ){\n\t\t\t\t\t\t\ttrgt=lname;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n//Console.WriteLine(\"trgt:{0}\",trgt);\n\t\t\t\t\tif(trgt!=\"\"){\n\t\t\t\t\t\tcur++;\n\t\t\t\t\t\tbuf[cur]=trgt;\n\t\t\t\t\t\tif(cur==buf.Count-1){\n\t\t\t\t\t\t\tbuf.Add(EOB);\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tbuf[cur+1]=EOB;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n*/\n\t\t\t\tbreak;\n\t\t\t\tcase 'f':\n\t\t\t\t\t//if(cur+1<buf.Count&&buf[cur+1]!=EOB)cur++;\n\t\t\t\tbreak;\n\t\t\t\tcase 'b':\n\t\t\t\t\t//if(cur-1>=0)cur--;\n\t\t\t\tbreak;\n\t\t\t\tcase 's':\n\t\t\t\t\tConsole.WriteLine(\"top\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t\n\n\tint N;\n\t//int W;\n\t//int H;\n\tpublic Sol(int n_){\n\t\tN=n_;\n\t\trs();\n\t\t//var d=ria();\n\t\t//W=d[0];H=d[1];\n\t}\n\n\tclass Page{\n\t\tpublic String Name;\n\t\tpublic Dictionary<String,Area> Links;\n\t\tpublic int LCount;\n\t\tpublic Page(){\n\t\t\tLinks=new Dictionary<String,Area>();\n\t\t}\n\t}\n\tclass Area{\n\t\tpublic int xmin;\n\t\tpublic int xmax;\n\t\tpublic int ymin;\n\t\tpublic int ymax;\n\t\tpublic Area(int in0,int in1,int in2,int in3){\n\t\t\txmin=in0;\n\t\t\tymin=in1;\n\t\t\txmax=in2;\n\t\t\tymax=in3;\n\t\t}\n\t}\n\n\n\tstatic String rs(){return Console.ReadLine();}\n\tstatic int ri(){return int.Parse(Console.ReadLine());}\n\tstatic long rl(){return long.Parse(Console.ReadLine());}\n\tstatic double rd(){return double.Parse(Console.ReadLine());}\n\tstatic String[] rsa(){return Console.ReadLine().Split(' ');}\n\tstatic int[] ria(){return Array.ConvertAll(Console.ReadLine().Split(' '),e=>int.Parse(e));}\n\tstatic long[] rla(){return Array.ConvertAll(Console.ReadLine().Split(' '),e=>long.Parse(e));}\n\tstatic double[] rda(){return Array.ConvertAll(Console.ReadLine().Split(' '),e=>double.Parse(e));}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\n \nclass TEST{\n\tstatic void Main(){\n\t\twhile(true){\n\t\t\tint n=int.Parse(Console.ReadLine());\n\t\t\tif(n==0)break;\n\t\t\tSol mySol =new Sol(n);\n\t\t\tmySol.Solve();\n\t\t}\n\t}\n}\n\nclass Sol{\n\tpublic void Solve(){\n\t\t//Dictionary<String,Page> D=new Dictionary<String,Page>();\n\t\t\n\t\t//List<String> buf=new List<String>();\n\t\t//String EOB=\"nullnullnullnullnullnull\";\n\t\t\n\t\tfor(int i=0;i<N;i++){\n\t\t\tvar s=rsa();\n\t\t\tvar P=new Page();\n\t\t\tP.Name=s[0];\n\t\t\tP.LCount=int.Parse(s[1]);\n/*\n\t\t\tfor(int j=0;j<P.LCount;j++){\n\t\t\t\ts=rsa();\n\t\t\t\tArea A=new Area(int.Parse(s[0]),int.Parse(s[1]),int.Parse(s[2]),int.Parse(s[3]));\n\t\t\t\tP.Links.Add(s[4],A);\n\t\t\t}\n\t\t\tD.Add(P.Name,P);\n\t\t\tif(i==0){\n\t\t\t\tbuf.Add(P.Name);\n\t\t\t\tbuf.Add(EOB);\n\t\t\t}\n*/\n\t\t}\n\t\t\n\t\tint q=ri();\n\t\tString order=\"\";\n\t\t//int cur=0;\n\t\t\n\t\tfor(int i=0;i<q;i++){\n\t\t\torder=rs();\n\t\t\tswitch(order[0]){\n\t\t\t\tcase 'c':\n/*\t\t\t\t\tvar ss=order.Split(' ');\n\t\t\t\t\tint px=int.Parse(ss[1]);\n\t\t\t\t\tint py=int.Parse(ss[2]);\n\t\t\t\t\tString trgt=\"\";\n\t\t\t\t\tforeach(String lname in D[buf[cur]].Links.Keys){\n\t\t\t\t\t\tif(D[buf[cur]].Links[lname].xmin<=px &&\n\t\t\t\t\t\t   D[buf[cur]].Links[lname].xmax>=px &&\n\t\t\t\t\t\t   D[buf[cur]].Links[lname].ymin<=py &&\n\t\t\t\t\t\t   D[buf[cur]].Links[lname].ymax>=py ){\n\t\t\t\t\t\t\ttrgt=lname;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n//Console.WriteLine(\"trgt:{0}\",trgt);\n\t\t\t\t\tif(trgt!=\"\"){\n\t\t\t\t\t\tcur++;\n\t\t\t\t\t\tbuf[cur]=trgt;\n\t\t\t\t\t\tif(cur==buf.Count-1){\n\t\t\t\t\t\t\tbuf.Add(EOB);\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tbuf[cur+1]=EOB;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n*/\n\t\t\t\tbreak;\n\t\t\t\tcase 'f':\n\t\t\t\t\t//if(cur+1<buf.Count&&buf[cur+1]!=EOB)cur++;\n\t\t\t\tbreak;\n\t\t\t\tcase 'b':\n\t\t\t\t\t//if(cur-1>=0)cur--;\n\t\t\t\tbreak;\n\t\t\t\tcase 's':\n\t\t\t\t\tConsole.WriteLine(\"top\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t\n\n\tint N;\n\t//int W;\n\t//int H;\n\tpublic Sol(int n_){\n\t\tN=n_;\n\t\trs();\n\t\t//var d=ria();\n\t\t//W=d[0];H=d[1];\n\t}\n\n\tclass Page{\n\t\tpublic String Name;\n\t\tpublic Dictionary<String,Area> Links;\n\t\tpublic int LCount;\n\t\tpublic Page(){\n\t\t\tLinks=new Dictionary<String,Area>();\n\t\t}\n\t}\n\tclass Area{\n\t\tpublic int xmin;\n\t\tpublic int xmax;\n\t\tpublic int ymin;\n\t\tpublic int ymax;\n\t\tpublic Area(int in0,int in1,int in2,int in3){\n\t\t\txmin=in0;\n\t\t\tymin=in1;\n\t\t\txmax=in2;\n\t\t\tymax=in3;\n\t\t}\n\t}\n\n\n\tstatic String rs(){return Console.ReadLine();}\n\tstatic int ri(){return int.Parse(Console.ReadLine());}\n\tstatic long rl(){return long.Parse(Console.ReadLine());}\n\tstatic double rd(){return double.Parse(Console.ReadLine());}\n\tstatic String[] rsa(){return Console.ReadLine().Split(' ');}\n\tstatic int[] ria(){return Array.ConvertAll(Console.ReadLine().Split(' '),e=>int.Parse(e));}\n\tstatic long[] rla(){return Array.ConvertAll(Console.ReadLine().Split(' '),e=>long.Parse(e));}\n\tstatic double[] rda(){return Array.ConvertAll(Console.ReadLine().Split(' '),e=>double.Parse(e));}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\n \nclass TEST{\n\tstatic void Main(){\n\t\twhile(true){\n\t\t\tint n=int.Parse(Console.ReadLine());\n\t\t\tif(n==0)break;\n\t\t\tSol mySol =new Sol(n);\n\t\t\tmySol.Solve();\n\t\t}\n\t}\n}\n\nclass Sol{\n\tpublic void Solve(){\n\t\t//Dictionary<String,Page> D=new Dictionary<String,Page>();\n\t\t\n\t\t//List<String> buf=new List<String>();\n\t\t//String EOB=\"nullnullnullnullnullnull\";\n\t\t\n\t\tfor(int i=0;i<N;i++){\n\t\t\tvar s=rsa();\n\t\t\tvar P=new Page();\n\t\t\tP.Name=s[0];\n\t\t\tP.LCount=int.Parse(s[1]);\n\n\t\t\tfor(int j=0;j<P.LCount;j++){\n\t\t\t\ts=rsa();\n\t\t\t\tArea A=new Area(int.Parse(s[0]),int.Parse(s[1]),int.Parse(s[2]),int.Parse(s[3]));\n\t\t\t\t//P.Links.Add(s[4],A);\n\t\t\t}\n/*\n\t\t\tD.Add(P.Name,P);\n\t\t\tif(i==0){\n\t\t\t\tbuf.Add(P.Name);\n\t\t\t\tbuf.Add(EOB);\n\t\t\t}\n*/\n\t\t}\n\t\t\n\t\tint q=ri();\n\t\tString order=\"\";\n\t\t//int cur=0;\n\t\t\n\t\tfor(int i=0;i<q;i++){\n\t\t\torder=rs();\n\t\t\tswitch(order[0]){\n\t\t\t\tcase 'c':\n/*\t\t\t\t\tvar ss=order.Split(' ');\n\t\t\t\t\tint px=int.Parse(ss[1]);\n\t\t\t\t\tint py=int.Parse(ss[2]);\n\t\t\t\t\tString trgt=\"\";\n\t\t\t\t\tforeach(String lname in D[buf[cur]].Links.Keys){\n\t\t\t\t\t\tif(D[buf[cur]].Links[lname].xmin<=px &&\n\t\t\t\t\t\t   D[buf[cur]].Links[lname].xmax>=px &&\n\t\t\t\t\t\t   D[buf[cur]].Links[lname].ymin<=py &&\n\t\t\t\t\t\t   D[buf[cur]].Links[lname].ymax>=py ){\n\t\t\t\t\t\t\ttrgt=lname;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n//Console.WriteLine(\"trgt:{0}\",trgt);\n\t\t\t\t\tif(trgt!=\"\"){\n\t\t\t\t\t\tcur++;\n\t\t\t\t\t\tbuf[cur]=trgt;\n\t\t\t\t\t\tif(cur==buf.Count-1){\n\t\t\t\t\t\t\tbuf.Add(EOB);\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tbuf[cur+1]=EOB;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n*/\n\t\t\t\tbreak;\n\t\t\t\tcase 'f':\n\t\t\t\t\t//if(cur+1<buf.Count&&buf[cur+1]!=EOB)cur++;\n\t\t\t\tbreak;\n\t\t\t\tcase 'b':\n\t\t\t\t\t//if(cur-1>=0)cur--;\n\t\t\t\tbreak;\n\t\t\t\tcase 's':\n\t\t\t\t\tConsole.WriteLine(\"top\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t\n\n\tint N;\n\t//int W;\n\t//int H;\n\tpublic Sol(int n_){\n\t\tN=n_;\n\t\trs();\n\t\t//var d=ria();\n\t\t//W=d[0];H=d[1];\n\t}\n\n\tclass Page{\n\t\tpublic String Name;\n\t\tpublic Dictionary<String,Area> Links;\n\t\tpublic int LCount;\n\t\tpublic Page(){\n\t\t\tLinks=new Dictionary<String,Area>();\n\t\t}\n\t}\n\tclass Area{\n\t\tpublic int xmin;\n\t\tpublic int xmax;\n\t\tpublic int ymin;\n\t\tpublic int ymax;\n\t\tpublic Area(int in0,int in1,int in2,int in3){\n\t\t\txmin=in0;\n\t\t\tymin=in1;\n\t\t\txmax=in2;\n\t\t\tymax=in3;\n\t\t}\n\t}\n\n\n\tstatic String rs(){return Console.ReadLine();}\n\tstatic int ri(){return int.Parse(Console.ReadLine());}\n\tstatic long rl(){return long.Parse(Console.ReadLine());}\n\tstatic double rd(){return double.Parse(Console.ReadLine());}\n\tstatic String[] rsa(){return Console.ReadLine().Split(' ');}\n\tstatic int[] ria(){return Array.ConvertAll(Console.ReadLine().Split(' '),e=>int.Parse(e));}\n\tstatic long[] rla(){return Array.ConvertAll(Console.ReadLine().Split(' '),e=>long.Parse(e));}\n\tstatic double[] rda(){return Array.ConvertAll(Console.ReadLine().Split(' '),e=>double.Parse(e));}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\n \nclass TEST{\n\tstatic void Main(){\n\t\twhile(true){\n\t\t\tint n=int.Parse(Console.ReadLine());\n\t\t\tif(n==0)break;\n\t\t\tSol mySol =new Sol(n);\n\t\t\tmySol.Solve();\n\t\t}\n\t}\n}\n\nclass Sol{\n\tpublic void Solve(){\n\t\t//Dictionary<String,Page> D=new Dictionary<String,Page>();\n\t\t\n\t\t//List<String> buf=new List<String>();\n\t\t//String EOB=\"nullnullnullnullnullnull\";\n\t\t\n\t\tfor(int i=0;i<N;i++){\n\t\t\tvar s=rsa();\n\t\t\tvar P=new Page();\n\t\t\tP.Name=s[0];\n\t\t\tP.LCount=int.Parse(s[1]);\n\n\t\t\tfor(int j=0;j<P.LCount;j++){\n\t\t\t\ts=rsa();\n\t\t\t\t//Area A=new Area(int.Parse(s[0]),int.Parse(s[1]),int.Parse(s[2]),int.Parse(s[3]));\n\t\t\t\t//P.Links.Add(s[4],A);\n\t\t\t}\n/*\n\t\t\tD.Add(P.Name,P);\n\t\t\tif(i==0){\n\t\t\t\tbuf.Add(P.Name);\n\t\t\t\tbuf.Add(EOB);\n\t\t\t}\n*/\n\t\t}\n\t\t\n\t\tint q=ri();\n\t\tString order=\"\";\n\t\t//int cur=0;\n\t\t\n\t\tfor(int i=0;i<q;i++){\n\t\t\torder=rs();\n\t\t\tswitch(order[0]){\n\t\t\t\tcase 'c':\n/*\t\t\t\t\tvar ss=order.Split(' ');\n\t\t\t\t\tint px=int.Parse(ss[1]);\n\t\t\t\t\tint py=int.Parse(ss[2]);\n\t\t\t\t\tString trgt=\"\";\n\t\t\t\t\tforeach(String lname in D[buf[cur]].Links.Keys){\n\t\t\t\t\t\tif(D[buf[cur]].Links[lname].xmin<=px &&\n\t\t\t\t\t\t   D[buf[cur]].Links[lname].xmax>=px &&\n\t\t\t\t\t\t   D[buf[cur]].Links[lname].ymin<=py &&\n\t\t\t\t\t\t   D[buf[cur]].Links[lname].ymax>=py ){\n\t\t\t\t\t\t\ttrgt=lname;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n//Console.WriteLine(\"trgt:{0}\",trgt);\n\t\t\t\t\tif(trgt!=\"\"){\n\t\t\t\t\t\tcur++;\n\t\t\t\t\t\tbuf[cur]=trgt;\n\t\t\t\t\t\tif(cur==buf.Count-1){\n\t\t\t\t\t\t\tbuf.Add(EOB);\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tbuf[cur+1]=EOB;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n*/\n\t\t\t\tbreak;\n\t\t\t\tcase 'f':\n\t\t\t\t\t//if(cur+1<buf.Count&&buf[cur+1]!=EOB)cur++;\n\t\t\t\tbreak;\n\t\t\t\tcase 'b':\n\t\t\t\t\t//if(cur-1>=0)cur--;\n\t\t\t\tbreak;\n\t\t\t\tcase 's':\n\t\t\t\t\tConsole.WriteLine(\"top\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t\n\n\tint N;\n\t//int W;\n\t//int H;\n\tpublic Sol(int n_){\n\t\tN=n_;\n\t\trs();\n\t\t//var d=ria();\n\t\t//W=d[0];H=d[1];\n\t}\n\n\tclass Page{\n\t\tpublic String Name;\n\t\tpublic Dictionary<String,Area> Links;\n\t\tpublic int LCount;\n\t\tpublic Page(){\n\t\t\tLinks=new Dictionary<String,Area>();\n\t\t}\n\t}\n\tclass Area{\n\t\tpublic int xmin;\n\t\tpublic int xmax;\n\t\tpublic int ymin;\n\t\tpublic int ymax;\n\t\tpublic Area(int in0,int in1,int in2,int in3){\n\t\t\txmin=in0;\n\t\t\tymin=in1;\n\t\t\txmax=in2;\n\t\t\tymax=in3;\n\t\t}\n\t}\n\n\n\tstatic String rs(){return Console.ReadLine();}\n\tstatic int ri(){return int.Parse(Console.ReadLine());}\n\tstatic long rl(){return long.Parse(Console.ReadLine());}\n\tstatic double rd(){return double.Parse(Console.ReadLine());}\n\tstatic String[] rsa(){return Console.ReadLine().Split(' ');}\n\tstatic int[] ria(){return Array.ConvertAll(Console.ReadLine().Split(' '),e=>int.Parse(e));}\n\tstatic long[] rla(){return Array.ConvertAll(Console.ReadLine().Split(' '),e=>long.Parse(e));}\n\tstatic double[] rda(){return Array.ConvertAll(Console.ReadLine().Split(' '),e=>double.Parse(e));}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\n \nclass TEST{\n\tstatic void Main(){\n\t\twhile(true){\n\t\t\tint n=int.Parse(Console.ReadLine());\n\t\t\tif(n==0)break;\n\t\t\tSol mySol =new Sol(n);\n\t\t\tmySol.Solve();\n\t\t}\n\t}\n}\n\nclass Sol{\n\tpublic void Solve(){\n\t\t//Dictionary<String,Page> D=new Dictionary<String,Page>();\n\t\t\n\t\t//List<String> buf=new List<String>();\n\t\t//String EOB=\"nullnullnullnullnullnull\";\n\t\t\n\t\tfor(int i=0;i<N;i++){\n\t\t\tvar s=rsa();\n\t\t\tvar P=new Page();\n\t\t\tP.Name=s[0];\n\t\t\tP.LCount=int.Parse(s[1]);\n\n\t\t\tfor(int j=0;j<P.LCount;j++){\n\t\t\t\ts=rsa();\n\t\t\t\tArea A=new Area(int.Parse(s[0]),int.Parse(s[1]),int.Parse(s[2]),int.Parse(s[3]));\n\t\t\t\tif(A.xmin==0 && A.xmin!=0)break;\n\t\t\t\t//P.Links.Add(s[4],A);\n\t\t\t}\n/*\n\t\t\tD.Add(P.Name,P);\n\t\t\tif(i==0){\n\t\t\t\tbuf.Add(P.Name);\n\t\t\t\tbuf.Add(EOB);\n\t\t\t}\n*/\n\t\t}\n\t\t\n\t\tint q=ri();\n\t\tString order=\"\";\n\t\t//int cur=0;\n\t\t\n\t\tfor(int i=0;i<q;i++){\n\t\t\torder=rs();\n\t\t\tswitch(order[0]){\n\t\t\t\tcase 'c':\n/*\t\t\t\t\tvar ss=order.Split(' ');\n\t\t\t\t\tint px=int.Parse(ss[1]);\n\t\t\t\t\tint py=int.Parse(ss[2]);\n\t\t\t\t\tString trgt=\"\";\n\t\t\t\t\tforeach(String lname in D[buf[cur]].Links.Keys){\n\t\t\t\t\t\tif(D[buf[cur]].Links[lname].xmin<=px &&\n\t\t\t\t\t\t   D[buf[cur]].Links[lname].xmax>=px &&\n\t\t\t\t\t\t   D[buf[cur]].Links[lname].ymin<=py &&\n\t\t\t\t\t\t   D[buf[cur]].Links[lname].ymax>=py ){\n\t\t\t\t\t\t\ttrgt=lname;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n//Console.WriteLine(\"trgt:{0}\",trgt);\n\t\t\t\t\tif(trgt!=\"\"){\n\t\t\t\t\t\tcur++;\n\t\t\t\t\t\tbuf[cur]=trgt;\n\t\t\t\t\t\tif(cur==buf.Count-1){\n\t\t\t\t\t\t\tbuf.Add(EOB);\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tbuf[cur+1]=EOB;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n*/\n\t\t\t\tbreak;\n\t\t\t\tcase 'f':\n\t\t\t\t\t//if(cur+1<buf.Count&&buf[cur+1]!=EOB)cur++;\n\t\t\t\tbreak;\n\t\t\t\tcase 'b':\n\t\t\t\t\t//if(cur-1>=0)cur--;\n\t\t\t\tbreak;\n\t\t\t\tcase 's':\n\t\t\t\t\tConsole.WriteLine(\"top\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t\n\n\tint N;\n\t//int W;\n\t//int H;\n\tpublic Sol(int n_){\n\t\tN=n_;\n\t\trs();\n\t\t//var d=ria();\n\t\t//W=d[0];H=d[1];\n\t}\n\n\tclass Page{\n\t\tpublic String Name;\n\t\tpublic Dictionary<String,Area> Links;\n\t\tpublic int LCount;\n\t\tpublic Page(){\n\t\t\tLinks=new Dictionary<String,Area>();\n\t\t}\n\t}\n\tstruct Area{\n\t\tpublic int xmin;\n\t\tpublic int xmax;\n\t\tpublic int ymin;\n\t\tpublic int ymax;\n\t\tpublic Area(int in0,int in1,int in2,int in3){\n\t\t\txmin=in0;\n\t\t\tymin=in1;\n\t\t\txmax=in2;\n\t\t\tymax=in3;\n\t\t}\n\t}\n\n\n\tstatic String rs(){return Console.ReadLine();}\n\tstatic int ri(){return int.Parse(Console.ReadLine());}\n\tstatic long rl(){return long.Parse(Console.ReadLine());}\n\tstatic double rd(){return double.Parse(Console.ReadLine());}\n\tstatic String[] rsa(){return Console.ReadLine().Split(' ');}\n\tstatic int[] ria(){return Array.ConvertAll(Console.ReadLine().Split(' '),e=>int.Parse(e));}\n\tstatic long[] rla(){return Array.ConvertAll(Console.ReadLine().Split(' '),e=>long.Parse(e));}\n\tstatic double[] rda(){return Array.ConvertAll(Console.ReadLine().Split(' '),e=>double.Parse(e));}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\n \nclass TEST{\n\tstatic void Main(){\n\t\twhile(true){\n\t\t\tint n=int.Parse(Console.ReadLine());\n\t\t\tif(n==0)break;\n\t\t\tSol mySol =new Sol(n);\n\t\t\tmySol.Solve();\n\t\t}\n\t}\n}\n\nclass Sol{\n\tpublic void Solve(){\n\t\tDictionary<String,Page> D=new Dictionary<String,Page>();\n\t\t\n\t\tList<String> buf=new List<String>();\n\t\tString EOB=\"nullnullnullnullnullnull\";\n\t\t\n\t\tfor(int i=0;i<N;i++){\n\t\t\tvar s=rsa();\n\t\t\tvar P=new Page();\n\t\t\tP.Name=s[0];\n\t\t\tP.LCount=int.Parse(s[1]);\n\t\t\tfor(int j=0;j<P.LCount;j++){\n\t\t\t\ts=rsa();\n\t\t\t\tArea A=new Area(int.Parse(s[0]),int.Parse(s[1]),int.Parse(s[2]),int.Parse(s[3]));\n\t\t\t\tP.Links.Add(s[4],A);\n\t\t\t}\n\t\t\tD.Add(P.Name,P);\n\t\t\tif(i==0){\n\t\t\t\tbuf.Add(P.Name);\n\t\t\t\tbuf.Add(EOB);\n\t\t\t}\n\t\t}\n\t\t\n\t\tint q=ri();\n\t\tString order=\"\";\n\t\tint cur=0;\n\t\t\n\t\tfor(int i=0;i<q;i++){\n\t\t\torder=rs();\n\t\t\tswitch(order[0]){\n\t\t\t\tcase 'c':\n\t\t\t\t\tvar ss=order.Split(' ');\n\t\t\t\t\tint px=int.Parse(ss[1]);\n\t\t\t\t\tint py=int.Parse(ss[2]);\n\t\t\t\t\tString trgt=\"\";\n\t\t\t\t\tforeach(String lname in D[buf[cur]].Links.Keys){\n\t\t\t\t\t\tif(D[buf[cur]].Links[lname].xmin<=px &&\n\t\t\t\t\t\t   D[buf[cur]].Links[lname].xmax>=px &&\n\t\t\t\t\t\t   D[buf[cur]].Links[lname].ymin<=py &&\n\t\t\t\t\t\t   D[buf[cur]].Links[lname].ymax>=py ){\n\t\t\t\t\t\t\ttrgt=lname;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n//Console.WriteLine(\"trgt:{0}\",trgt);\n\t\t\t\t\tif(trgt!=\"\"){\n\t\t\t\t\t\tcur++;\n\t\t\t\t\t\tbuf[cur]=trgt;\n\t\t\t\t\t\tif(cur==buf.Count-1){\n\t\t\t\t\t\t\tbuf.Add(EOB);\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tbuf[cur+1]=EOB;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t\tcase 'f':\n\t\t\t\t\tif(cur+1<buf.Count&&buf[cur+1]!=EOB)cur++;\n\t\t\t\tbreak;\n\t\t\t\tcase 'b':\n\t\t\t\t\tif(cur-1>=0)cur--;\n\t\t\t\tbreak;\n\t\t\t\tcase 's':\n\t\t\t\t\tConsole.WriteLine(buf[cur]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t\n\n\tint N;\n\tint W;\n\tint H;\n\tpublic Sol(int n_){\n\t\tN=n_;\n\t\tvar d=ria();\n\t\tW=d[0];H=d[1];\n\t}\n\n\tclass Page{\n\t\tpublic String Name;\n\t\tpublic Dictionary<String,Area> Links;\n\t\tpublic int LCount;\n\t\tpublic Page(){\n\t\t\tLinks=new Dictionary<String,Area>();\n\t\t}\n\t}\n\tclass Area{\n\t\tpublic int xmin;\n\t\tpublic int xmax;\n\t\tpublic int ymin;\n\t\tpublic int ymax;\n\t\tpublic Area(int in0,int in1,int in2,int in3){\n\t\t\txmin=in0;\n\t\t\tymin=in1;\n\t\t\txmax=in2;\n\t\t\tymax=in3;\n\t\t}\n\t}\n\n\n\tstatic String rs(){return Console.ReadLine();}\n\tstatic int ri(){return int.Parse(Console.ReadLine());}\n\tstatic long rl(){return long.Parse(Console.ReadLine());}\n\tstatic double rd(){return double.Parse(Console.ReadLine());}\n\tstatic String[] rsa(){return Console.ReadLine().Split(' ');}\n\tstatic int[] ria(){return Array.ConvertAll(Console.ReadLine().Split(' '),e=>int.Parse(e));}\n\tstatic long[] rla(){return Array.ConvertAll(Console.ReadLine().Split(' '),e=>long.Parse(e));}\n\tstatic double[] rda(){return Array.ConvertAll(Console.ReadLine().Split(' '),e=>double.Parse(e));}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\n \nclass TEST{\n\tstatic void Main(){\n\t\twhile(true){\n\t\t\tint n=int.Parse(Console.ReadLine());\n\t\t\tif(n==0)break;\n\t\t\tSol mySol =new Sol(n);\n\t\t\tmySol.Solve();\n\t\t}\n\t}\n}\n\nclass Sol{\n\tpublic void Solve(){\n\t\tDictionary<String,Page> D=new Dictionary<String,Page>();\n\t\t\n\t\tList<String> buf=new List<String>();\n\t\tString EOB=\"nullnullnullnullnullnull\";\n\t\t\n\t\tfor(int i=0;i<N;i++){\n\t\t\tvar s=rsa();\n\t\t\tvar P=new Page();\n\t\t\tP.Name=s[0];\n\t\t\tP.LCount=int.Parse(s[1]);\n\t\t\tfor(int j=0;j<P.LCount;j++){\n\t\t\t\t//s=rsa();\n\t\t\t\ts=Console.ReadLine().Split(new char[]{' '}, StringSplitOptions.RemoveEmptyEntries);\n\t\t\t\tArea A=new Area(int.Parse(s[0]),int.Parse(s[1]),int.Parse(s[2]),int.Parse(s[3]));\n\t\t\t\tP.Links.Add(s[4],A);\n\t\t\t}\n\t\t\tD.Add(P.Name,P);\n\t\t\tif(i==0){\n\t\t\t\tbuf.Add(P.Name);\n\t\t\t\tbuf.Add(EOB);\n\t\t\t}\n\t\t}\n\t\t\n\t\tint q=ri();\n\t\tString order=\"\";\n\t\tint cur=0;\n\t\t\n\t\tfor(int i=0;i<q;i++){\n\t\t\torder=rs();\n\t\t\tswitch(order[0]){\n\t\t\t\tcase 'c':\n\t\t\t\t\tvar ss=order.Split(' ');\n\t\t\t\t\tint px=int.Parse(ss[1]);\n\t\t\t\t\tint py=int.Parse(ss[2]);\n\t\t\t\t\tString trgt=\"\";\n\t\t\t\t\tforeach(String lname in D[buf[cur]].Links.Keys){\n\t\t\t\t\t\tif(D[buf[cur]].Links[lname].xmin<=px &&\n\t\t\t\t\t\t   D[buf[cur]].Links[lname].xmax>=px &&\n\t\t\t\t\t\t   D[buf[cur]].Links[lname].ymin<=py &&\n\t\t\t\t\t\t   D[buf[cur]].Links[lname].ymax>=py ){\n\t\t\t\t\t\t\ttrgt=lname;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n//Console.WriteLine(\"trgt:{0}\",trgt);\n\t\t\t\t\tif(trgt!=\"\"){\n\t\t\t\t\t\tcur++;\n\t\t\t\t\t\tbuf[cur]=trgt;\n\t\t\t\t\t\tif(cur==buf.Count-1){\n\t\t\t\t\t\t\tbuf.Add(EOB);\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tbuf[cur+1]=EOB;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t\tcase 'f':\n\t\t\t\t\tif(cur+1<buf.Count&&buf[cur+1]!=EOB)cur++;\n\t\t\t\tbreak;\n\t\t\t\tcase 'b':\n\t\t\t\t\tif(cur-1>=0)cur--;\n\t\t\t\tbreak;\n\t\t\t\tcase 's':\n\t\t\t\t\tConsole.WriteLine(buf[cur]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t\n\n\tint N;\n\t//int W;\n\t//int H;\n\tpublic Sol(int n_){\n\t\tN=n_;\n\t\trs();\n\t\t//var d=ria();\n\t\t//W=d[0];H=d[1];\n\t}\n\n\tclass Page{\n\t\tpublic String Name;\n\t\tpublic Dictionary<String,Area> Links;\n\t\tpublic int LCount;\n\t\tpublic Page(){\n\t\t\tLinks=new Dictionary<String,Area>();\n\t\t}\n\t}\n\tclass Area{\n\t\tpublic int xmin;\n\t\tpublic int xmax;\n\t\tpublic int ymin;\n\t\tpublic int ymax;\n\t\tpublic Area(int in0,int in1,int in2,int in3){\n\t\t\txmin=in0;\n\t\t\tymin=in1;\n\t\t\txmax=in2;\n\t\t\tymax=in3;\n\t\t}\n\t}\n\n\n\tstatic String rs(){return Console.ReadLine();}\n\tstatic int ri(){return int.Parse(Console.ReadLine());}\n\tstatic long rl(){return long.Parse(Console.ReadLine());}\n\tstatic double rd(){return double.Parse(Console.ReadLine());}\n\tstatic String[] rsa(){return Console.ReadLine().Split(' ');}\n\tstatic int[] ria(){return Array.ConvertAll(Console.ReadLine().Split(' '),e=>int.Parse(e));}\n\tstatic long[] rla(){return Array.ConvertAll(Console.ReadLine().Split(' '),e=>long.Parse(e));}\n\tstatic double[] rda(){return Array.ConvertAll(Console.ReadLine().Split(' '),e=>double.Parse(e));}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\n \nclass TEST{\n\tstatic void Main(){\n\t\twhile(true){\n\t\t\tString sa=\"\";\n\t\t\twhile(String.IsNullOrEmpty(sa))sa=Console.ReadLine();\n\t\t\tint n=int.Parse(sa);\n\t\t\tif(n==0)break;\n\t\t\tSol mySol =new Sol(n);\n\t\t\tmySol.Solve();\n\t\t}\n\t}\n}\n\nclass Sol{\n\tpublic void Solve(){\n\t\tDictionary<String,Page> D=new Dictionary<String,Page>();\n\t\t\n\t\tList<String> buf=new List<String>();\n\t\t\n\t\tfor(int i=0;i<N;i++){\n\t\t\tvar s=rsa();\n\t\t\tvar P=new Page();\n\t\t\tP.Name=s[0];\n\t\t\tP.LCount=int.Parse(s[1]);\n\t\t\tfor(int j=0;j<P.LCount;j++){\n\t\t\t\ts=rsa();\n\t\t\t\tArea A=new Area(int.Parse(s[0]),int.Parse(s[1]),int.Parse(s[2]),int.Parse(s[3]));\n\t\t\t\tP.Links.Add(s[4],A);\n\t\t\t}\n\t\t\tD.Add(P.Name,P);\n\t\t\tif(i==0){\n\t\t\t\tbuf.Add(P.Name);\n\t\t\t}\n\t\t}\n\t\t\n\t\tint q=ri();\n\t\tString order=\"\";\n\t\tint cur=0;\n\t\t\n\t\tfor(int i=0;i<q;i++){\n\t\t\torder=rs();\n\t\t\tif(order[0]=='c'){\n\t\t\t}\n\t\t\tif(order[0]=='f'){\n\t\t\t}\n\t\t\tif(order[0]=='b'){\n\t\t\t}\n\t\t\tif(order[0]=='s'){\n\t\t\t\tConsole.WriteLine(buf[cur]);\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t\n\n\tint N;\n\t//int W;\n\t//int H;\n\tpublic Sol(int n_){\n\t\tN=n_;\n\t\tString sa=\"\";\n\t\twhile(String.IsNullOrEmpty(sa))sa=Console.ReadLine();\n\n\t\t//rs();\n\t\t//var d=ria();\n\t\t//W=d[0];H=d[1];\n\t}\n\n\tclass Page{\n\t\tpublic String Name;\n\t\tpublic Dictionary<String,Area> Links;\n\t\tpublic int LCount;\n\t\tpublic Page(){\n\t\t\tLinks=new Dictionary<String,Area>();\n\t\t}\n\t}\n\tclass Area{\n\t\tpublic int xmin;\n\t\tpublic int xmax;\n\t\tpublic int ymin;\n\t\tpublic int ymax;\n\t\tpublic Area(int in0,int in1,int in2,int in3){\n\t\t\txmin=in0;\n\t\t\tymin=in1;\n\t\t\txmax=in2;\n\t\t\tymax=in3;\n\t\t}\n\t}\n\n\n\tstatic String rs(){return Console.ReadLine();}\n\tstatic int ri(){return int.Parse(Console.ReadLine());}\n\tstatic long rl(){return long.Parse(Console.ReadLine());}\n\tstatic double rd(){return double.Parse(Console.ReadLine());}\n\tstatic String[] rsa(){return Console.ReadLine().Split(' ');}\n\tstatic int[] ria(){return Array.ConvertAll(Console.ReadLine().Split(' '),e=>int.Parse(e));}\n\tstatic long[] rla(){return Array.ConvertAll(Console.ReadLine().Split(' '),e=>long.Parse(e));}\n\tstatic double[] rda(){return Array.ConvertAll(Console.ReadLine().Split(' '),e=>double.Parse(e));}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\n \nclass TEST{\n\tstatic void Main(){\n\t\twhile(true){\n\t\t\tint n=int.Parse(Console.ReadLine());\n\t\t\tif(n==0)break;\n\t\t\tSol mySol =new Sol(n);\n\t\t\tmySol.Solve();\n\t\t}\n\t}\n}\n\nclass Sol{\n\tpublic void Solve(){\n\t\tDictionary<String,Page> D=new Dictionary<String,Page>();\n\t\t\n\t\tList<String> buf=new List<String>();\n\t\tString EOB=\"nullnullnullnullnullnull\";\n\t\t\n\t\tfor(int i=0;i<N;i++){\n\t\t\tvar s=rsa();\n\t\t\tvar P=new Page();\n\t\t\tP.Name=s[0];\n\t\t\tP.LCount=int.Parse(s[1]);\n\t\t\tP.LinkName=new String[P.LCount];\n\t\t\tP.LinkArea=new Area[P.LCount];\n\t\t\tfor(int j=0;j<P.LCount;j++){\n\t\t\t\ts=rsa();\n\t\t\t\tArea A=new Area(int.Parse(s[0]),int.Parse(s[1]),int.Parse(s[2]),int.Parse(s[3]));\n\t\t\t\tP.LinkArea[j]=A;\n\t\t\t\tP.LinkName[j]=s[4];\n\t\t\t}\n\t\t\tD.Add(P.Name,P);\n\t\t\tif(i==0){\n\t\t\t\tbuf.Add(P.Name);\n\t\t\t\tbuf.Add(EOB);\n\t\t\t}\n\t\t}\n\t\t\n\t\tint q=ri();\n\t\tString order=\"\";\n\t\tint cur=0;\n\t\t\n\t\tfor(int i=0;i<q;i++){\n\t\t\torder=rs();\n\t\t\tswitch(order[0]){\n\t\t\t\tcase 'c':\n\t\t\t\t\tvar ss=order.Split(' ');\n\t\t\t\t\tint px=int.Parse(ss[1]);\n\t\t\t\t\tint py=int.Parse(ss[2]);\n\t\t\t\t\tString trgt=\"\";\n\t\t\t\t\tfor(int j=0;j<D[buf[cur]].LCount;j++){\n\t\t\t\t\t\tif(D[buf[cur]].LinkArea[j].xmin<=px &&\n\t\t\t\t\t\t   D[buf[cur]].LinkArea[j].xmax>=px &&\n\t\t\t\t\t\t   D[buf[cur]].LinkArea[j].ymin<=py &&\n\t\t\t\t\t\t   D[buf[cur]].LinkArea[j].ymax>=py ){\n\t\t\t\t\t\t\ttrgt=D[buf[cur]].LinkName[j];\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n//Console.WriteLine(\"trgt:{0}\",trgt);\n\t\t\t\t\tif(trgt!=\"\"){\n\t\t\t\t\t\tcur++;\n\t\t\t\t\t\tbuf[cur]=trgt;\n\t\t\t\t\t\tif(cur==buf.Count-1){\n\t\t\t\t\t\t\tbuf.Add(EOB);\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tbuf[cur+1]=EOB;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t\tcase 'f':\n\t\t\t\t\tif(cur+1<buf.Count&&buf[cur+1]!=EOB)cur++;\n\t\t\t\tbreak;\n\t\t\t\tcase 'b':\n\t\t\t\t\tif(cur-1>=0)cur--;\n\t\t\t\tbreak;\n\t\t\t\tcase 's':\n\t\t\t\t\tConsole.WriteLine(buf[cur]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t\n\n\tint N;\n\t//int W;\n\t//int H;\n\tpublic Sol(int n_){\n\t\tN=n_;\n\t\trs();\n\t\t//var d=ria();\n\t\t//W=d[0];H=d[1];\n\t}\n\n\tclass Page{\n\t\tpublic String Name;\n\t\tpublic String[] LinkName;\n\t\tpublic Area[] LinkArea;\n\t\tpublic int LCount;\n\t\tpublic Page(){\n\t\t}\n\t}\n\tclass Area{\n\t\tpublic int xmin;\n\t\tpublic int xmax;\n\t\tpublic int ymin;\n\t\tpublic int ymax;\n\t\tpublic Area(int in0,int in1,int in2,int in3){\n\t\t\txmin=in0;\n\t\t\tymin=in1;\n\t\t\txmax=in2;\n\t\t\tymax=in3;\n\t\t}\n\t}\n\n\n\tstatic String rs(){return Console.ReadLine();}\n\tstatic int ri(){return int.Parse(Console.ReadLine());}\n\tstatic long rl(){return long.Parse(Console.ReadLine());}\n\tstatic double rd(){return double.Parse(Console.ReadLine());}\n\tstatic String[] rsa(){return Console.ReadLine().Split(' ');}\n\tstatic int[] ria(){return Array.ConvertAll(Console.ReadLine().Split(' '),e=>int.Parse(e));}\n\tstatic long[] rla(){return Array.ConvertAll(Console.ReadLine().Split(' '),e=>long.Parse(e));}\n\tstatic double[] rda(){return Array.ConvertAll(Console.ReadLine().Split(' '),e=>double.Parse(e));}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\n \nclass TEST{\n\tstatic void Main(){\n\t\twhile(true){\n\t\t\tint n=int.Parse(Console.ReadLine());\n\t\t\tif(n==0)break;\n\t\t\tSol mySol =new Sol(n);\n\t\t\tmySol.Solve();\n\t\t}\n\t}\n}\n\nclass Sol{\n\tpublic void Solve(){\n\t\tDictionary<String,Page> D=new Dictionary<String,Page>();\n\t\t\n\t\tList<String> buf=new List<String>();\n\t\tString EOB=\"nullnullnullnullnullnull\";\n\t\t\n\t\tfor(int i=0;i<N;i++){\n\t\t\tvar s=rsa();\n\t\t\tvar P=new Page();\n\t\t\tP.Name=s[0];\n\t\t\tP.LCount=int.Parse(s[1]);\n\t\t\tfor(int j=0;j<P.LCount;j++){\n\t\t\t\ts=rsa();\n\t\t\t\tArea A=new Area(int.Parse(s[0]),int.Parse(s[1]),int.Parse(s[2]),int.Parse(s[3]));\n\t\t\t\tP.Links.Add(s[4],A);\n\t\t\t}\n\t\t\tD.Add(P.Name,P);\n\t\t\tif(i==0){\n\t\t\t\tbuf.Add(P.Name);\n\t\t\t\tbuf.Add(EOB);\n\t\t\t}\n\t\t}\n\t\t\n\t\tint q=ri();\n\t\tString order=\"\";\n\t\tint cur=0;\n\t\t\n\t\tfor(int i=0;i<q;i++){\n\t\t\torder=rs();\n\t\t\tif(order[0]=='c'){\n\t\t\t\tvar ss=order.Split(' ');\n\t\t\t\tint px=int.Parse(ss[1]);\n\t\t\t\tint py=int.Parse(ss[2]);\n\t\t\t\tString trgt=\"\";\n\t\t\t\tforeach(String lname in D[buf[cur]].Links.Keys){\n\t\t\t\t\tif(D[buf[cur]].Links[lname].xmin<=px &&\n\t\t\t\t\t   D[buf[cur]].Links[lname].xmax>=px &&\n\t\t\t\t\t   D[buf[cur]].Links[lname].ymin<=py &&\n\t\t\t\t\t   D[buf[cur]].Links[lname].ymax>=py ){\n\t\t\t\t\t\ttrgt=lname;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n//Console.WriteLine(\"trgt:{0}\",trgt);\n\t\t\t\tif(trgt!=\"\"){\n\t\t\t\t\tcur++;\n\t\t\t\t\tbuf[cur]=trgt;\n\t\t\t\t\tif(cur==buf.Count-1){\n\t\t\t\t\t\tbuf.Add(EOB);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tbuf[cur+1]=EOB;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(order[0]=='f'){\n\t\t\t\tif(cur+1<buf.Count&&buf[cur+1]!=EOB)cur++;\n\t\t\t}\n\t\t\tif(order[0]=='b'){\n\t\t\t\tif(cur-1>=0)cur--;\n\t\t\t}\n\t\t\tif(order[0]=='s'){\n\t\t\t\tConsole.WriteLine(buf[cur]);\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t\n\n\tint N;\n\t//int W;\n\t//int H;\n\tpublic Sol(int n_){\n\t\tN=n_;\n\t\trs();\n\t\t//var d=ria();\n\t\t//W=d[0];H=d[1];\n\t}\n\n\tclass Page{\n\t\tpublic String Name;\n\t\tpublic Dictionary<String,Area> Links;\n\t\tpublic int LCount;\n\t\tpublic Page(){\n\t\t\tLinks=new Dictionary<String,Area>();\n\t\t}\n\t}\n\tclass Area{\n\t\tpublic int xmin;\n\t\tpublic int xmax;\n\t\tpublic int ymin;\n\t\tpublic int ymax;\n\t\tpublic Area(int in0,int in1,int in2,int in3){\n\t\t\txmin=in0;\n\t\t\tymin=in1;\n\t\t\txmax=in2;\n\t\t\tymax=in3;\n\t\t}\n\t}\n\n\n\tstatic String rs(){return Console.ReadLine();}\n\tstatic int ri(){return int.Parse(Console.ReadLine());}\n\tstatic long rl(){return long.Parse(Console.ReadLine());}\n\tstatic double rd(){return double.Parse(Console.ReadLine());}\n\tstatic String[] rsa(){return Console.ReadLine().Split(' ');}\n\tstatic int[] ria(){return Array.ConvertAll(Console.ReadLine().Split(' '),e=>int.Parse(e));}\n\tstatic long[] rla(){return Array.ConvertAll(Console.ReadLine().Split(' '),e=>long.Parse(e));}\n\tstatic double[] rda(){return Array.ConvertAll(Console.ReadLine().Split(' '),e=>double.Parse(e));}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\n \nclass TEST{\n\tstatic void Main(){\n\t\twhile(true){\n\t\t\tint n=int.Parse(Console.ReadLine());\n\t\t\tif(n==0)break;\n\t\t\tSol mySol =new Sol(n);\n\t\t\tmySol.Solve();\n\t\t}\n\t}\n}\n\nclass Sol{\n\tpublic void Solve(){\n\t\tDictionary<String,Page> D=new Dictionary<String,Page>();\n\t\t\n\t\tList<String> buf=new List<String>();\n\t\tString EOB=\"nullnullnullnullnullnull\";\n\t\t\n\t\tfor(int i=0;i<N;i++){\n\t\t\tvar s=rsa();\n\t\t\tvar P=new Page();\n\t\t\tP.Name=s[0];\n\t\t\tP.LCount=int.Parse(s[1]);\n\t\t\tfor(int j=0;j<P.LCount;j++){\n\t\t\t\ts=rsa();\n\t\t\t\tArea A=new Area(int.Parse(s[0]),int.Parse(s[1]),int.Parse(s[2]),int.Parse(s[3]));\n\t\t\t\tP.Links.Add(s[4],A);\n\t\t\t}\n\t\t\tD.Add(P.Name,P);\n\t\t\tif(i==0){\n\t\t\t\tbuf.Add(P.Name);\n\t\t\t\tbuf.Add(EOB);\n\t\t\t}\n\t\t}\n\t\t\n\t\tint q=ri();\n\t\tString order=\"\";\n\t\t//int cur=0;\n\t\t\n\t\tfor(int i=0;i<q;i++){\n\t\t\torder=rs();\n\t\t\tswitch(order[0]){\n\t\t\t\tcase 'c':\n/*\t\t\t\t\tvar ss=order.Split(' ');\n\t\t\t\t\tint px=int.Parse(ss[1]);\n\t\t\t\t\tint py=int.Parse(ss[2]);\n\t\t\t\t\tString trgt=\"\";\n\t\t\t\t\tforeach(String lname in D[buf[cur]].Links.Keys){\n\t\t\t\t\t\tif(D[buf[cur]].Links[lname].xmin<=px &&\n\t\t\t\t\t\t   D[buf[cur]].Links[lname].xmax>=px &&\n\t\t\t\t\t\t   D[buf[cur]].Links[lname].ymin<=py &&\n\t\t\t\t\t\t   D[buf[cur]].Links[lname].ymax>=py ){\n\t\t\t\t\t\t\ttrgt=lname;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n//Console.WriteLine(\"trgt:{0}\",trgt);\n\t\t\t\t\tif(trgt!=\"\"){\n\t\t\t\t\t\tcur++;\n\t\t\t\t\t\tbuf[cur]=trgt;\n\t\t\t\t\t\tif(cur==buf.Count-1){\n\t\t\t\t\t\t\tbuf.Add(EOB);\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tbuf[cur+1]=EOB;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n*/\n\t\t\t\tbreak;\n\t\t\t\tcase 'f':\n\t\t\t\t\t//if(cur+1<buf.Count&&buf[cur+1]!=EOB)cur++;\n\t\t\t\tbreak;\n\t\t\t\tcase 'b':\n\t\t\t\t\t//if(cur-1>=0)cur--;\n\t\t\t\tbreak;\n\t\t\t\tcase 's':\n\t\t\t\t\tConsole.WriteLine(\"top\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t\n\n\tint N;\n\t//int W;\n\t//int H;\n\tpublic Sol(int n_){\n\t\tN=n_;\n\t\trs();\n\t\t//var d=ria();\n\t\t//W=d[0];H=d[1];\n\t}\n\n\tclass Page{\n\t\tpublic String Name;\n\t\tpublic Dictionary<String,Area> Links;\n\t\tpublic int LCount;\n\t\tpublic Page(){\n\t\t\tLinks=new Dictionary<String,Area>();\n\t\t}\n\t}\n\tclass Area{\n\t\tpublic int xmin;\n\t\tpublic int xmax;\n\t\tpublic int ymin;\n\t\tpublic int ymax;\n\t\tpublic Area(int in0,int in1,int in2,int in3){\n\t\t\txmin=in0;\n\t\t\tymin=in1;\n\t\t\txmax=in2;\n\t\t\tymax=in3;\n\t\t}\n\t}\n\n\n\tstatic String rs(){return Console.ReadLine();}\n\tstatic int ri(){return int.Parse(Console.ReadLine());}\n\tstatic long rl(){return long.Parse(Console.ReadLine());}\n\tstatic double rd(){return double.Parse(Console.ReadLine());}\n\tstatic String[] rsa(){return Console.ReadLine().Split(' ');}\n\tstatic int[] ria(){return Array.ConvertAll(Console.ReadLine().Split(' '),e=>int.Parse(e));}\n\tstatic long[] rla(){return Array.ConvertAll(Console.ReadLine().Split(' '),e=>long.Parse(e));}\n\tstatic double[] rda(){return Array.ConvertAll(Console.ReadLine().Split(' '),e=>double.Parse(e));}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\n \nclass TEST{\n\tstatic void Main(){\n\t\twhile(true){\n\t\t\tint n=int.Parse(Console.ReadLine());\n\t\t\tif(n==0)break;\n\t\t\tSol mySol =new Sol(n);\n\t\t\tmySol.Solve();\n\t\t}\n\t}\n}\n\nclass Sol{\n\tpublic void Solve(){\n\t\tDictionary<String,Page> D=new Dictionary<String,Page>();\n\t\t\n\t\tList<String> buf=new List<String>();\n\t\t\n\t\tfor(int i=0;i<N;i++){\n\t\t\tvar s=rsa();\n\t\t\tvar P=new Page();\n\t\t\tP.Name=s[0];\n\t\t\tP.LCount=int.Parse(s[1]);\n\t\t\tfor(int j=0;j<P.LCount;j++){\n\t\t\t\ts=rsa();\n\t\t\t\tArea A=new Area(int.Parse(s[0]),int.Parse(s[1]),int.Parse(s[2]),int.Parse(s[3]));\n\t\t\t\tP.Links.Add(s[4],A);\n\t\t\t}\n\t\t\tD.Add(P.Name,P);\n\t\t\tif(i==0){\n\t\t\t\tbuf.Add(P.Name);\n\t\t\t}\n\t\t}\n\t\t\n\t\tint q=ri();\n\t\tString order=\"\";\n\t\tint cur=0;\n\t\t\n\t\tfor(int i=0;i<q;i++){\n\t\t\torder=rs();\n\t\t\tif(order[0]=='c'){\n\t\t\t}\n\t\t\tif(order[0]=='f'){\n\t\t\t}\n\t\t\tif(order[0]=='b'){\n\t\t\t}\n\t\t\tif(order[0]=='s'){\n\t\t\t\tConsole.WriteLine(buf[cur]);\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t\n\n\tint N;\n\t//int W;\n\t//int H;\n\tpublic Sol(int n_){\n\t\tN=n_;\n\t\trs();\n\t\t//var d=ria();\n\t\t//W=d[0];H=d[1];\n\t}\n\n\tclass Page{\n\t\tpublic String Name;\n\t\tpublic Dictionary<String,Area> Links;\n\t\tpublic int LCount;\n\t\tpublic Page(){\n\t\t\tLinks=new Dictionary<String,Area>();\n\t\t}\n\t}\n\tclass Area{\n\t\tpublic int xmin;\n\t\tpublic int xmax;\n\t\tpublic int ymin;\n\t\tpublic int ymax;\n\t\tpublic Area(int in0,int in1,int in2,int in3){\n\t\t\txmin=in0;\n\t\t\tymin=in1;\n\t\t\txmax=in2;\n\t\t\tymax=in3;\n\t\t}\n\t}\n\n\n\tstatic String rs(){return Console.ReadLine();}\n\tstatic int ri(){return int.Parse(Console.ReadLine());}\n\tstatic long rl(){return long.Parse(Console.ReadLine());}\n\tstatic double rd(){return double.Parse(Console.ReadLine());}\n\tstatic String[] rsa(){return Console.ReadLine().Split(' ');}\n\tstatic int[] ria(){return Array.ConvertAll(Console.ReadLine().Split(' '),e=>int.Parse(e));}\n\tstatic long[] rla(){return Array.ConvertAll(Console.ReadLine().Split(' '),e=>long.Parse(e));}\n\tstatic double[] rda(){return Array.ConvertAll(Console.ReadLine().Split(' '),e=>double.Parse(e));}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\n \nclass TEST{\n\tstatic void Main(){\n\t\twhile(true){\n\t\t\tint n=int.Parse(Console.ReadLine());\n\t\t\tif(n==0)break;\n\t\t\tSol mySol =new Sol(n);\n\t\t\tmySol.Solve();\n\t\t}\n\t}\n}\n\nclass Sol{\n\tpublic void Solve(){\n\t\tDictionary<String,Page> D=new Dictionary<String,Page>();\n\t\t\n\t\tList<String> buf=new List<String>();\n\t\t\n\t\tfor(int i=0;i<N;i++){\n\t\t\tvar s=rsa();\n\t\t\tvar P=new Page();\n\t\t\tP.Name=s[0];\n\t\t\tP.LCount=int.Parse(s[1]);\n\t\t\tfor(int j=0;j<P.LCount;j++){\n\t\t\t\ts=rsa();\n\t\t\t\tArea A=new Area(int.Parse(s[0]),int.Parse(s[1]),int.Parse(s[2]),int.Parse(s[3]));\n\t\t\t\tP.Links.Add(s[4],A);\n\t\t\t}\n\t\t\tD.Add(P.Name,P);\n\t\t\tif(i==0){\n\t\t\t\tbuf.Add(P.Name);\n\t\t\t}\n\t\t}\n\t\t\n\t\tint q=ri();\n\t\tString order=\"\";\n\t\tint cur=0;\n\t\t\n\t\tfor(int i=0;i<q;i++){\n\t\t\torder=rs();\n\t\t\tif(order[0]=='c'){\n\t\t\t\tvar ss=order.Split(' ');\n\t\t\t\tint px=int.Parse(ss[1]);\n\t\t\t\tint py=int.Parse(ss[2]);\n\t\t\t\tString trgt=\"\";\n\t\t\t\tforeach(String lname in D[buf[cur]].Links.Keys){\n\t\t\t\t\tif(D[buf[cur]].Links[lname].xmin<=px &&\n\t\t\t\t\t   D[buf[cur]].Links[lname].xmax>=px &&\n\t\t\t\t\t   D[buf[cur]].Links[lname].ymin<=py &&\n\t\t\t\t\t   D[buf[cur]].Links[lname].ymax>=py ){\n\t\t\t\t\t\ttrgt=lname;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n//Console.WriteLine(\"trgt:{0}\",trgt);\n\t\t\t\tif(trgt!=\"\"){\n\t\t\t\t\tint kkk=buf.Count-1;\n\t\t\t\t\twhile(kkk>cur)buf.RemoveAt(kkk);\n\t\t\t\t\tbuf.Add(trgt);\n\t\t\t\t\tcur++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(order[0]=='f'){\n\t\t\t\tif(cur+1<buf.Count)cur++;\n\t\t\t}\n\t\t\tif(order[0]=='b'){\n\t\t\t\tif(cur-1>=0)cur--;\n\t\t\t}\n\t\t\tif(order[0]=='s'){\n\t\t\t\tConsole.WriteLine(buf[cur]);\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t\n\n\tint N;\n\t//int W;\n\t//int H;\n\tpublic Sol(int n_){\n\t\tN=n_;\n\t\trs();\n\t\t//var d=ria();\n\t\t//W=d[0];H=d[1];\n\t}\n\n\tclass Page{\n\t\tpublic String Name;\n\t\tpublic Dictionary<String,Area> Links;\n\t\tpublic int LCount;\n\t\tpublic Page(){\n\t\t\tLinks=new Dictionary<String,Area>();\n\t\t}\n\t}\n\tclass Area{\n\t\tpublic int xmin;\n\t\tpublic int xmax;\n\t\tpublic int ymin;\n\t\tpublic int ymax;\n\t\tpublic Area(int in0,int in1,int in2,int in3){\n\t\t\txmin=in0;\n\t\t\tymin=in1;\n\t\t\txmax=in2;\n\t\t\tymax=in3;\n\t\t}\n\t}\n\n\n\tstatic String rs(){return Console.ReadLine();}\n\tstatic int ri(){return int.Parse(Console.ReadLine());}\n\tstatic long rl(){return long.Parse(Console.ReadLine());}\n\tstatic double rd(){return double.Parse(Console.ReadLine());}\n\tstatic String[] rsa(){return Console.ReadLine().Split(' ');}\n\tstatic int[] ria(){return Array.ConvertAll(Console.ReadLine().Split(' '),e=>int.Parse(e));}\n\tstatic long[] rla(){return Array.ConvertAll(Console.ReadLine().Split(' '),e=>long.Parse(e));}\n\tstatic double[] rda(){return Array.ConvertAll(Console.ReadLine().Split(' '),e=>double.Parse(e));}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\n \nclass TEST{\n\tstatic void Main(){\n\t\twhile(true){\n\t\t\tString sa=\"\";\n\t\t\twhile(String.IsNullOrEmpty(sa))sa=Console.ReadLine();\n\t\t\tint n=int.Parse(sa);\n\t\t\tif(n==0)break;\n\t\t\tSol mySol =new Sol(n);\n\t\t\tmySol.Solve();\n\t\t}\n\t}\n}\n\nclass Sol{\n\tpublic void Solve(){\n\t\tDictionary<String,Page> D=new Dictionary<String,Page>();\n\t\t\n\t\tList<String> buf=new List<String>();\n\t\t\n\t\tfor(int i=0;i<N;i++){\n\t\t\tvar s=rsa();\n\t\t\tvar P=new Page();\n\t\t\tP.Name=s[0];\n\t\t\tP.LCount=int.Parse(s[1]);\n\t\t\tfor(int j=0;j<P.LCount;j++){\n\t\t\t\ts=rsa();\n\t\t\t\tArea A=new Area(int.Parse(s[0]),int.Parse(s[1]),int.Parse(s[2]),int.Parse(s[3]));\n\t\t\t\tP.Links.Add(s[4],A);\n\t\t\t}\n\t\t\tD.Add(P.Name,P);\n\t\t\tif(i==0){\n\t\t\t\tbuf.Add(P.Name);\n\t\t\t}\n\t\t}\n\t\t\n\t\tint q=ri();\n\t\tString order=\"\";\n\t\tint cur=0;\n\t\t\n\t\tfor(int i=0;i<q;i++){\n\t\t\torder=rs();\n\t\t\tif(order[0]=='c'){\n\t\t\t}\n\t\t\tif(order[0]=='f'){\n\t\t\t}\n\t\t\tif(order[0]=='b'){\n\t\t\t}\n\t\t\tif(order[0]=='s'){\n\t\t\t\tConsole.WriteLine(buf[cur]);\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t\n\n\tint N;\n\t//int W;\n\t//int H;\n\tpublic Sol(int n_){\n\t\tN=n_;\n\t\trs();\n\t\t//var d=ria();\n\t\t//W=d[0];H=d[1];\n\t}\n\n\tclass Page{\n\t\tpublic String Name;\n\t\tpublic Dictionary<String,Area> Links;\n\t\tpublic int LCount;\n\t\tpublic Page(){\n\t\t\tLinks=new Dictionary<String,Area>();\n\t\t}\n\t}\n\tclass Area{\n\t\tpublic int xmin;\n\t\tpublic int xmax;\n\t\tpublic int ymin;\n\t\tpublic int ymax;\n\t\tpublic Area(int in0,int in1,int in2,int in3){\n\t\t\txmin=in0;\n\t\t\tymin=in1;\n\t\t\txmax=in2;\n\t\t\tymax=in3;\n\t\t}\n\t}\n\n\n\tstatic String rs(){return Console.ReadLine();}\n\tstatic int ri(){return int.Parse(Console.ReadLine());}\n\tstatic long rl(){return long.Parse(Console.ReadLine());}\n\tstatic double rd(){return double.Parse(Console.ReadLine());}\n\tstatic String[] rsa(){return Console.ReadLine().Split(' ');}\n\tstatic int[] ria(){return Array.ConvertAll(Console.ReadLine().Split(' '),e=>int.Parse(e));}\n\tstatic long[] rla(){return Array.ConvertAll(Console.ReadLine().Split(' '),e=>long.Parse(e));}\n\tstatic double[] rda(){return Array.ConvertAll(Console.ReadLine().Split(' '),e=>double.Parse(e));}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\n \nclass TEST{\n\tstatic void Main(){\n\t\twhile(true){\n\t\t\tint n=int.Parse(Console.ReadLine());\n\t\t\tif(n==0)break;\n\t\t\tSol mySol =new Sol(n);\n\t\t\tmySol.Solve();\n\t\t}\n\t}\n}\n\nclass Sol{\n\tpublic void Solve(){\n\t\tDictionary<String,Page> D=new Dictionary<String,Page>();\n\t\t\n\t\tList<String> buf=new List<String>();\n\t\tString EOB=\"nullnullnullnullnullnull\";\n\t\t\n\t\tfor(int i=0;i<N;i++){\n\t\t\tvar s=rsa();\n\t\t\tvar P=new Page();\n\t\t\tP.Name=s[0];\n\t\t\tP.LCount=int.Parse(s[1]);\n\t\t\tfor(int j=0;j<P.LCount;j++){\n\t\t\t\ts=rsa();\n\t\t\t\tArea A=new Area(int.Parse(s[0]),int.Parse(s[1]),int.Parse(s[2]),int.Parse(s[3]));\n\t\t\t\tP.Links.Add(s[4],A);\n\t\t\t}\n\t\t\tD.Add(P.Name,P);\n\t\t\tif(i==0){\n\t\t\t\tbuf.Add(P.Name);\n\t\t\t\tbuf.Add(EOB);\n\t\t\t}\n\t\t}\n\t\t\n\t\tint q=ri();\n\t\tString order=\"\";\n\t\tint cur=0;\n\t\t\n\t\tfor(int i=0;i<q;i++){\n\t\t\torder=rs();\n\t\t\tswitch(order[0]){\n\t\t\t\tcase 'c':\n\t\t\t\t\tvar ss=order.Split(' ');\n\t\t\t\t\tint px=int.Parse(ss[1]);\n\t\t\t\t\tint py=int.Parse(ss[2]);\n\t\t\t\t\tString trgt=\"\";\n\t\t\t\t\tforeach(String lname in D[buf[cur]].Links.Keys){\n\t\t\t\t\t\tif(D[buf[cur]].Links[lname].xmin<=px &&\n\t\t\t\t\t\t   D[buf[cur]].Links[lname].xmax>=px &&\n\t\t\t\t\t\t   D[buf[cur]].Links[lname].ymin<=py &&\n\t\t\t\t\t\t   D[buf[cur]].Links[lname].ymax>=py ){\n\t\t\t\t\t\t\ttrgt=lname;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n//Console.WriteLine(\"trgt:{0}\",trgt);\n\t\t\t\t\tif(trgt!=\"\"){\n\t\t\t\t\t\tcur++;\n\t\t\t\t\t\tbuf[cur]=trgt;\n\t\t\t\t\t\tif(cur==buf.Count-1){\n\t\t\t\t\t\t\tbuf.Add(EOB);\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tbuf[cur+1]=EOB;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t\tcase 'f':\n\t\t\t\t\tif(cur+1<buf.Count&&buf[cur+1]!=EOB)cur++;\n\t\t\t\tbreak;\n\t\t\t\tcase 'b':\n\t\t\t\t\tif(cur-1>=0)cur--;\n\t\t\t\tbreak;\n\t\t\t\tcase 's':\n\t\t\t\t\tConsole.WriteLine(buf[cur]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t\n\n\tint N;\n\t//int W;\n\t//int H;\n\tpublic Sol(int n_){\n\t\tN=n_;\n\t\tvar d=ria();\n\t\t//W=d[0];H=d[1];\n\t}\n\n\tclass Page{\n\t\tpublic String Name;\n\t\tpublic Dictionary<String,Area> Links;\n\t\tpublic int LCount;\n\t\tpublic Page(){\n\t\t\tLinks=new Dictionary<String,Area>();\n\t\t}\n\t}\n\tclass Area{\n\t\tpublic int xmin;\n\t\tpublic int xmax;\n\t\tpublic int ymin;\n\t\tpublic int ymax;\n\t\tpublic Area(int in0,int in1,int in2,int in3){\n\t\t\txmin=in0;\n\t\t\tymin=in1;\n\t\t\txmax=in2;\n\t\t\tymax=in3;\n\t\t}\n\t}\n\n\n\tstatic String rs(){return Console.ReadLine();}\n\tstatic int ri(){return int.Parse(Console.ReadLine());}\n\tstatic long rl(){return long.Parse(Console.ReadLine());}\n\tstatic double rd(){return double.Parse(Console.ReadLine());}\n\tstatic String[] rsa(){return Console.ReadLine().Split(' ');}\n\tstatic int[] ria(){return Array.ConvertAll(Console.ReadLine().Split(' '),e=>int.Parse(e));}\n\tstatic long[] rla(){return Array.ConvertAll(Console.ReadLine().Split(' '),e=>long.Parse(e));}\n\tstatic double[] rda(){return Array.ConvertAll(Console.ReadLine().Split(' '),e=>double.Parse(e));}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\n \nclass TEST{\n\tstatic void Main(){\n\t\twhile(true){\n\t\t\tint n=int.Parse(Console.ReadLine());\n\t\t\tif(n==0)break;\n\t\t\tSol mySol =new Sol(n);\n\t\t\tmySol.Solve();\n\t\t}\n\t}\n}\n\nclass Sol{\n\tpublic void Solve(){\n\t\tDictionary<String,Page> D=new Dictionary<String,Page>();\n\t\t\n\t\tList<String> buf=new List<String>();\n\t\tString EOB=\"nullnullnullnullnullnull\";\n\t\t\n\t\tfor(int i=0;i<N;i++){\n\t\t\tvar s=rsa();\n\t\t\tvar P=new Page();\n\t\t\tP.Name=s[0];\n\t\t\tP.LCount=int.Parse(s[1]);\n\t\t\tfor(int j=0;j<P.LCount;j++){\n\t\t\t\ts=rsa();\n\t\t\t\tArea A=new Area(int.Parse(s[0]),int.Parse(s[1]),int.Parse(s[2]),int.Parse(s[3]));\n\t\t\t\tP.Links.Add(s[4],A);\n\t\t\t}\n\t\t\tD.Add(P.Name,P);\n\t\t\tif(i==0){\n\t\t\t\tbuf.Add(P.Name);\n\t\t\t\tbuf.Add(EOB);\n\t\t\t}\n\t\t}\n\t\t\n\t\tint q=ri();\n\t\tString order=\"\";\n\t\tint cur=0;\n\t\t\n\t\tfor(int i=0;i<q;i++){\n\t\t\torder=rs();\n\t\t\tswitch(order[0]){\n\t\t\t\tcase 'c':\n\t\t\t\t\tvar ss=order.Split(' ');\n\t\t\t\t\tint px=int.Parse(ss[1]);\n\t\t\t\t\tint py=int.Parse(ss[2]);\n\t\t\t\t\tString trgt=\"\";\n\t\t\t\t\tforeach(String lname in D[buf[cur]].Links.Keys){\n\t\t\t\t\t\tif(D[buf[cur]].Links[lname].xmin<=px &&\n\t\t\t\t\t\t   D[buf[cur]].Links[lname].xmax>=px &&\n\t\t\t\t\t\t   D[buf[cur]].Links[lname].ymin<=py &&\n\t\t\t\t\t\t   D[buf[cur]].Links[lname].ymax>=py ){\n\t\t\t\t\t\t\ttrgt=lname;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n//Console.WriteLine(\"trgt:{0}\",trgt);\n\t\t\t\t\tif(trgt!=\"\"){\n\t\t\t\t\t\tcur++;\n\t\t\t\t\t\tbuf[cur]=trgt;\n\t\t\t\t\t\tif(cur==buf.Count-1){\n\t\t\t\t\t\t\tbuf.Add(EOB);\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tbuf[cur+1]=EOB;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t\tcase 'f':\n\t\t\t\t\tif(cur+1<buf.Count&&buf[cur+1]!=EOB)cur++;\n\t\t\t\tbreak;\n\t\t\t\tcase 'b':\n\t\t\t\t\tif(cur-1>=0)cur--;\n\t\t\t\tbreak;\n\t\t\t\tcase 's':\n\t\t\t\t\tConsole.WriteLine(buf[cur]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t\n\n\tint N;\n\tint W;\n\tint H;\n\tpublic Sol(int n_){\n\t\tN=n_;\n\t\tvar d=ria();\n\t\tW=d[0];H=d[1];\n\t}\n\n\tclass Page{\n\t\tpublic String Name;\n\t\tpublic Dictionary<String,Area> Links;\n\t\tpublic int LCount;\n\t\tpublic Page(){\n\t\t\tLinks=new Dictionary<String,Area>();\n\t\t}\n\t}\n\tclass Area{\n\t\tpublic int xmin;\n\t\tpublic int xmax;\n\t\tpublic int ymin;\n\t\tpublic int ymax;\n\t\tpublic Area(int in0,int in1,int in2,int in3){\n\t\t\txmin=in0;\n\t\t\tymin=in1;\n\t\t\txmax=in2;\n\t\t\tymax=in3;\n\t\t}\n\t}\n\n\n\tstatic String rs(){return Console.ReadLine();}\n\tstatic int ri(){return int.Parse(Console.ReadLine());}\n\tstatic long rl(){return long.Parse(Console.ReadLine());}\n\tstatic double rd(){return double.Parse(Console.ReadLine());}\n\tstatic String[] rsa(){return Console.ReadLine().Split(' ');}\n\tstatic int[] ria(){return Array.ConvertAll(Console.ReadLine().Split(' '),e=>int.Parse(e));}\n\tstatic long[] rla(){return Array.ConvertAll(Console.ReadLine().Split(' '),e=>long.Parse(e));}\n\tstatic double[] rda(){return Array.ConvertAll(Console.ReadLine().Split(' '),e=>double.Parse(e));}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\n \nclass TEST{\n\tstatic void Main(){\n\t\twhile(true){\n\t\t\tint n=int.Parse(Console.ReadLine());\n\t\t\tif(n==0)break;\n\t\t\tSol mySol =new Sol(n);\n\t\t\tmySol.Solve();\n\t\t}\n\t}\n}\n\nclass Sol{\n\tpublic void Solve(){\n\t\tDictionary<String,Page> D=new Dictionary<String,Page>();\n\t\t\n\t\tList<String> buf=new List<String>();\n\t\t//String EOB=\"nullnullnullnullnullnull\";\n\t\t\n\t\tfor(int i=0;i<N;i++){\n\t\t\tvar s=rsa();\n\t\t\tvar P=new Page();\n\t\t\tP.Name=s[0];\n\t\t\tP.LCount=int.Parse(s[1]);\n/*\n\t\t\tfor(int j=0;j<P.LCount;j++){\n\t\t\t\ts=rsa();\n\t\t\t\tArea A=new Area(int.Parse(s[0]),int.Parse(s[1]),int.Parse(s[2]),int.Parse(s[3]));\n\t\t\t\tP.Links.Add(s[4],A);\n\t\t\t}\n\t\t\tD.Add(P.Name,P);\n\t\t\tif(i==0){\n\t\t\t\tbuf.Add(P.Name);\n\t\t\t\tbuf.Add(EOB);\n\t\t\t}\n*/\n\t\t}\n\t\t\n\t\tint q=ri();\n\t\tString order=\"\";\n\t\t//int cur=0;\n\t\t\n\t\tfor(int i=0;i<q;i++){\n\t\t\torder=rs();\n\t\t\tswitch(order[0]){\n\t\t\t\tcase 'c':\n/*\t\t\t\t\tvar ss=order.Split(' ');\n\t\t\t\t\tint px=int.Parse(ss[1]);\n\t\t\t\t\tint py=int.Parse(ss[2]);\n\t\t\t\t\tString trgt=\"\";\n\t\t\t\t\tforeach(String lname in D[buf[cur]].Links.Keys){\n\t\t\t\t\t\tif(D[buf[cur]].Links[lname].xmin<=px &&\n\t\t\t\t\t\t   D[buf[cur]].Links[lname].xmax>=px &&\n\t\t\t\t\t\t   D[buf[cur]].Links[lname].ymin<=py &&\n\t\t\t\t\t\t   D[buf[cur]].Links[lname].ymax>=py ){\n\t\t\t\t\t\t\ttrgt=lname;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n//Console.WriteLine(\"trgt:{0}\",trgt);\n\t\t\t\t\tif(trgt!=\"\"){\n\t\t\t\t\t\tcur++;\n\t\t\t\t\t\tbuf[cur]=trgt;\n\t\t\t\t\t\tif(cur==buf.Count-1){\n\t\t\t\t\t\t\tbuf.Add(EOB);\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tbuf[cur+1]=EOB;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n*/\n\t\t\t\tbreak;\n\t\t\t\tcase 'f':\n\t\t\t\t\t//if(cur+1<buf.Count&&buf[cur+1]!=EOB)cur++;\n\t\t\t\tbreak;\n\t\t\t\tcase 'b':\n\t\t\t\t\t//if(cur-1>=0)cur--;\n\t\t\t\tbreak;\n\t\t\t\tcase 's':\n\t\t\t\t\tConsole.WriteLine(\"top\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t\n\n\tint N;\n\t//int W;\n\t//int H;\n\tpublic Sol(int n_){\n\t\tN=n_;\n\t\trs();\n\t\t//var d=ria();\n\t\t//W=d[0];H=d[1];\n\t}\n\n\tclass Page{\n\t\tpublic String Name;\n\t\tpublic Dictionary<String,Area> Links;\n\t\tpublic int LCount;\n\t\tpublic Page(){\n\t\t\tLinks=new Dictionary<String,Area>();\n\t\t}\n\t}\n\tclass Area{\n\t\tpublic int xmin;\n\t\tpublic int xmax;\n\t\tpublic int ymin;\n\t\tpublic int ymax;\n\t\tpublic Area(int in0,int in1,int in2,int in3){\n\t\t\txmin=in0;\n\t\t\tymin=in1;\n\t\t\txmax=in2;\n\t\t\tymax=in3;\n\t\t}\n\t}\n\n\n\tstatic String rs(){return Console.ReadLine();}\n\tstatic int ri(){return int.Parse(Console.ReadLine());}\n\tstatic long rl(){return long.Parse(Console.ReadLine());}\n\tstatic double rd(){return double.Parse(Console.ReadLine());}\n\tstatic String[] rsa(){return Console.ReadLine().Split(' ');}\n\tstatic int[] ria(){return Array.ConvertAll(Console.ReadLine().Split(' '),e=>int.Parse(e));}\n\tstatic long[] rla(){return Array.ConvertAll(Console.ReadLine().Split(' '),e=>long.Parse(e));}\n\tstatic double[] rda(){return Array.ConvertAll(Console.ReadLine().Split(' '),e=>double.Parse(e));}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\n \nclass TEST{\n\tstatic void Main(){\n\t\twhile(true){\n\t\t\tint n=int.Parse(Console.ReadLine());\n\t\t\tif(n==0)break;\n\t\t\tSol mySol =new Sol(n);\n\t\t\tmySol.Solve();\n\t\t}\n\t}\n}\n\nclass Sol{\n\tpublic void Solve(){\n\t\t//Dictionary<String,Page> D=new Dictionary<String,Page>();\n\t\t\n\t\t//List<String> buf=new List<String>();\n\t\t//String EOB=\"nullnullnullnullnullnull\";\n\t\t\n\t\tfor(int i=0;i<N;i++){\n\t\t\tvar s=rsa();\n\t\t\tvar P=new Page();\n\t\t\tP.Name=s[0];\n\t\t\tP.LCount=int.Parse(s[1]);\n\n\t\t\tfor(int j=0;j<P.LCount;j++){\n\t\t\t\ts=rsa();\n\t\t\t\tArea A=new Area(int.Parse(s[0]),int.Parse(s[1]),int.Parse(s[2]),int.Parse(s[3]));\n\t\t\t\tP.Links.Add(s[4],A);\n\t\t\t}\n/*\n\t\t\tD.Add(P.Name,P);\n\t\t\tif(i==0){\n\t\t\t\tbuf.Add(P.Name);\n\t\t\t\tbuf.Add(EOB);\n\t\t\t}\n*/\n\t\t}\n\t\t\n\t\tint q=ri();\n\t\tString order=\"\";\n\t\t//int cur=0;\n\t\t\n\t\tfor(int i=0;i<q;i++){\n\t\t\torder=rs();\n\t\t\tswitch(order[0]){\n\t\t\t\tcase 'c':\n/*\t\t\t\t\tvar ss=order.Split(' ');\n\t\t\t\t\tint px=int.Parse(ss[1]);\n\t\t\t\t\tint py=int.Parse(ss[2]);\n\t\t\t\t\tString trgt=\"\";\n\t\t\t\t\tforeach(String lname in D[buf[cur]].Links.Keys){\n\t\t\t\t\t\tif(D[buf[cur]].Links[lname].xmin<=px &&\n\t\t\t\t\t\t   D[buf[cur]].Links[lname].xmax>=px &&\n\t\t\t\t\t\t   D[buf[cur]].Links[lname].ymin<=py &&\n\t\t\t\t\t\t   D[buf[cur]].Links[lname].ymax>=py ){\n\t\t\t\t\t\t\ttrgt=lname;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n//Console.WriteLine(\"trgt:{0}\",trgt);\n\t\t\t\t\tif(trgt!=\"\"){\n\t\t\t\t\t\tcur++;\n\t\t\t\t\t\tbuf[cur]=trgt;\n\t\t\t\t\t\tif(cur==buf.Count-1){\n\t\t\t\t\t\t\tbuf.Add(EOB);\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tbuf[cur+1]=EOB;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n*/\n\t\t\t\tbreak;\n\t\t\t\tcase 'f':\n\t\t\t\t\t//if(cur+1<buf.Count&&buf[cur+1]!=EOB)cur++;\n\t\t\t\tbreak;\n\t\t\t\tcase 'b':\n\t\t\t\t\t//if(cur-1>=0)cur--;\n\t\t\t\tbreak;\n\t\t\t\tcase 's':\n\t\t\t\t\tConsole.WriteLine(\"top\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t\n\n\tint N;\n\t//int W;\n\t//int H;\n\tpublic Sol(int n_){\n\t\tN=n_;\n\t\trs();\n\t\t//var d=ria();\n\t\t//W=d[0];H=d[1];\n\t}\n\n\tclass Page{\n\t\tpublic String Name;\n\t\tpublic Dictionary<String,Area> Links;\n\t\tpublic int LCount;\n\t\tpublic Page(){\n\t\t\tLinks=new Dictionary<String,Area>();\n\t\t}\n\t}\n\tstruct Area{\n\t\tpublic int xmin;\n\t\tpublic int xmax;\n\t\tpublic int ymin;\n\t\tpublic int ymax;\n\t\tpublic Area(int in0,int in1,int in2,int in3){\n\t\t\txmin=in0;\n\t\t\tymin=in1;\n\t\t\txmax=in2;\n\t\t\tymax=in3;\n\t\t}\n\t}\n\n\n\tstatic String rs(){return Console.ReadLine();}\n\tstatic int ri(){return int.Parse(Console.ReadLine());}\n\tstatic long rl(){return long.Parse(Console.ReadLine());}\n\tstatic double rd(){return double.Parse(Console.ReadLine());}\n\tstatic String[] rsa(){return Console.ReadLine().Split(' ');}\n\tstatic int[] ria(){return Array.ConvertAll(Console.ReadLine().Split(' '),e=>int.Parse(e));}\n\tstatic long[] rla(){return Array.ConvertAll(Console.ReadLine().Split(' '),e=>long.Parse(e));}\n\tstatic double[] rda(){return Array.ConvertAll(Console.ReadLine().Split(' '),e=>double.Parse(e));}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\n \nclass TEST{\n\tstatic void Main(){\n\t\twhile(true){\n\t\t\tint n=int.Parse(Console.ReadLine());\n\t\t\tif(n==0)break;\n\t\t\tSol mySol =new Sol(n);\n\t\t\tmySol.Solve();\n\t\t}\n\t}\n}\n\nclass Sol{\n\tpublic void Solve(){\n\t\tDictionary<String,Page> D=new Dictionary<String,Page>();\n\t\t\n\t\tList<String> buf=new List<String>();\n\t\tString EOB=\"nullnullnullnullnullnull\";\n\t\t\n\t\tfor(int i=0;i<N;i++){\n\t\t\tvar s=rsa();\n\t\t\tvar P=new Page();\n\t\t\tP.Name=s[0];\n\t\t\tP.LCount=int.Parse(s[1]);\n\t\t\tfor(int j=0;j<P.LCount;j++){\n\t\t\t\ts=rsa();\n\t\t\t\tArea A=new Area(int.Parse(s[0]),int.Parse(s[1]),int.Parse(s[2]),int.Parse(s[3]));\n\t\t\t\tP.Links.Add(s[4],A);\n\t\t\t}\n\t\t\tD.Add(P.Name,P);\n\t\t\tif(i==0){\n\t\t\t\tbuf.Add(P.Name);\n\t\t\t\tbuf.Add(EOB);\n\t\t\t}\n\t\t}\n\t\t\n\t\tint q=ri();\n\t\tString order=\"\";\n\t\tint cur=0;\n\t\t\n\t\tfor(int i=0;i<q;i++){\n\t\t\torder=rs();\n\t\t\tswitch(order[0]){\n\t\t\t\tcase 'c':\n\t\t\t\t\tvar ss=order.Split(' ');\n\t\t\t\t\tint px=int.Parse(ss[1]);\n\t\t\t\t\tint py=int.Parse(ss[2]);\n\t\t\t\t\tString trgt=\"\";\n\t\t\t\t\tforeach(String lname in D[buf[cur]].Links.Keys){\n\t\t\t\t\t\tif(D[buf[cur]].Links[lname].xmin<=px &&\n\t\t\t\t\t\t   D[buf[cur]].Links[lname].xmax>=px &&\n\t\t\t\t\t\t   D[buf[cur]].Links[lname].ymin<=py &&\n\t\t\t\t\t\t   D[buf[cur]].Links[lname].ymax>=py ){\n\t\t\t\t\t\t\ttrgt=lname;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n//Console.WriteLine(\"trgt:{0}\",trgt);\n\t\t\t\t\tif(trgt!=\"\"){\n\t\t\t\t\t\tcur++;\n\t\t\t\t\t\tbuf[cur]=trgt;\n\t\t\t\t\t\tif(cur==buf.Count-1){\n\t\t\t\t\t\t\tbuf.Add(EOB);\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tbuf[cur+1]=EOB;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t\tcase 'f':\n\t\t\t\t\tif(cur+1<buf.Count&&buf[cur+1]!=EOB)cur++;\n\t\t\t\tbreak;\n\t\t\t\tcase 'b':\n\t\t\t\t\tif(cur-1>=0)cur--;\n\t\t\t\tbreak;\n\t\t\t\tcase 's':\n\t\t\t\t\tConsole.WriteLine(buf[cur]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t\n\n\tint N;\n\t//int W;\n\t//int H;\n\tpublic Sol(int n_){\n\t\tN=n_;\n\t\trs();\n\t\t//var d=ria();\n\t\t//W=d[0];H=d[1];\n\t}\n\n\tclass Page{\n\t\tpublic String Name;\n\t\tpublic Dictionary<String,Area> Links;\n\t\tpublic int LCount;\n\t\tpublic Page(){\n\t\t\tLinks=new Dictionary<String,Area>();\n\t\t}\n\t}\n\tclass Area{\n\t\tpublic int xmin;\n\t\tpublic int xmax;\n\t\tpublic int ymin;\n\t\tpublic int ymax;\n\t\tpublic Area(int in0,int in1,int in2,int in3){\n\t\t\txmin=in0;\n\t\t\tymin=in1;\n\t\t\txmax=in2;\n\t\t\tymax=in3;\n\t\t}\n\t}\n\n\n\tstatic String rs(){return Console.ReadLine();}\n\tstatic int ri(){return int.Parse(Console.ReadLine());}\n\tstatic long rl(){return long.Parse(Console.ReadLine());}\n\tstatic double rd(){return double.Parse(Console.ReadLine());}\n\tstatic String[] rsa(){return Console.ReadLine().Split(' ');}\n\tstatic int[] ria(){return Array.ConvertAll(Console.ReadLine().Split(' '),e=>int.Parse(e));}\n\tstatic long[] rla(){return Array.ConvertAll(Console.ReadLine().Split(' '),e=>long.Parse(e));}\n\tstatic double[] rda(){return Array.ConvertAll(Console.ReadLine().Split(' '),e=>double.Parse(e));}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\n \nclass TEST{\n\tstatic void Main(){\n\t\twhile(true){\n\t\t\tint n=int.Parse(Console.ReadLine());\n\t\t\tif(n==0)break;\n\t\t\tSol mySol =new Sol(n);\n\t\t\tmySol.Solve();\n\t\t}\n\t}\n}\n\nclass Sol{\n\tpublic void Solve(){\n\t\t//Dictionary<String,Page> D=new Dictionary<String,Page>();\n\t\t\n\t\t//List<String> buf=new List<String>();\n\t\t//String EOB=\"nullnullnullnullnullnull\";\n\t\t\n\t\tfor(int i=0;i<N;i++){\n\t\t\tvar s=rsa();\n\t\t\tvar P=new Page();\n\t\t\tP.Name=s[0];\n\t\t\tP.LCount=int.Parse(s[1]);\n\n\t\t\tfor(int j=0;j<P.LCount;j++){\n\t\t\t\ts=rsa();\n\t\t\t\tArea A=new Area(int.Parse(s[0]),int.Parse(s[1]),int.Parse(s[2]),int.Parse(s[3]));\n\t\t\t\tif(A.xmin==0 && A.xmin!=0)break;\n\t\t\t\tP.Links.Add(s[4],A);\n\t\t\t}\n/*\n\t\t\tD.Add(P.Name,P);\n\t\t\tif(i==0){\n\t\t\t\tbuf.Add(P.Name);\n\t\t\t\tbuf.Add(EOB);\n\t\t\t}\n*/\n\t\t}\n\t\t\n\t\tint q=ri();\n\t\tString order=\"\";\n\t\t//int cur=0;\n\t\t\n\t\tfor(int i=0;i<q;i++){\n\t\t\torder=rs();\n\t\t\tswitch(order[0]){\n\t\t\t\tcase 'c':\n/*\t\t\t\t\tvar ss=order.Split(' ');\n\t\t\t\t\tint px=int.Parse(ss[1]);\n\t\t\t\t\tint py=int.Parse(ss[2]);\n\t\t\t\t\tString trgt=\"\";\n\t\t\t\t\tforeach(String lname in D[buf[cur]].Links.Keys){\n\t\t\t\t\t\tif(D[buf[cur]].Links[lname].xmin<=px &&\n\t\t\t\t\t\t   D[buf[cur]].Links[lname].xmax>=px &&\n\t\t\t\t\t\t   D[buf[cur]].Links[lname].ymin<=py &&\n\t\t\t\t\t\t   D[buf[cur]].Links[lname].ymax>=py ){\n\t\t\t\t\t\t\ttrgt=lname;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n//Console.WriteLine(\"trgt:{0}\",trgt);\n\t\t\t\t\tif(trgt!=\"\"){\n\t\t\t\t\t\tcur++;\n\t\t\t\t\t\tbuf[cur]=trgt;\n\t\t\t\t\t\tif(cur==buf.Count-1){\n\t\t\t\t\t\t\tbuf.Add(EOB);\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tbuf[cur+1]=EOB;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n*/\n\t\t\t\tbreak;\n\t\t\t\tcase 'f':\n\t\t\t\t\t//if(cur+1<buf.Count&&buf[cur+1]!=EOB)cur++;\n\t\t\t\tbreak;\n\t\t\t\tcase 'b':\n\t\t\t\t\t//if(cur-1>=0)cur--;\n\t\t\t\tbreak;\n\t\t\t\tcase 's':\n\t\t\t\t\tConsole.WriteLine(\"top\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t\n\n\tint N;\n\t//int W;\n\t//int H;\n\tpublic Sol(int n_){\n\t\tN=n_;\n\t\trs();\n\t\t//var d=ria();\n\t\t//W=d[0];H=d[1];\n\t}\n\n\tstruct Page{\n\t\tpublic String Name;\n\t\tpublic Dictionary<String,Area> Links;\n\t\tpublic int LCount;\n\t\tpublic Page(){\n\t\t\tLinks=new Dictionary<String,Area>();\n\t\t}\n\t}\n\tstruct Area{\n\t\tpublic int xmin;\n\t\tpublic int xmax;\n\t\tpublic int ymin;\n\t\tpublic int ymax;\n\t\tpublic Area(int in0,int in1,int in2,int in3){\n\t\t\txmin=in0;\n\t\t\tymin=in1;\n\t\t\txmax=in2;\n\t\t\tymax=in3;\n\t\t}\n\t}\n\n\n\tstatic String rs(){return Console.ReadLine();}\n\tstatic int ri(){return int.Parse(Console.ReadLine());}\n\tstatic long rl(){return long.Parse(Console.ReadLine());}\n\tstatic double rd(){return double.Parse(Console.ReadLine());}\n\tstatic String[] rsa(){return Console.ReadLine().Split(' ');}\n\tstatic int[] ria(){return Array.ConvertAll(Console.ReadLine().Split(' '),e=>int.Parse(e));}\n\tstatic long[] rla(){return Array.ConvertAll(Console.ReadLine().Split(' '),e=>long.Parse(e));}\n\tstatic double[] rda(){return Array.ConvertAll(Console.ReadLine().Split(' '),e=>double.Parse(e));}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\n \nclass TEST{\n\tstatic void Main(){\n\t\twhile(true){\n\t\t\tint n=int.Parse(Console.ReadLine());\n\t\t\tif(n==0)break;\n\t\t\tSol mySol =new Sol(n);\n\t\t\tmySol.Solve();\n\t\t}\n\t}\n}\n\nclass Sol{\n\tpublic void Solve(){\n\t\tfor(int i=0;i<N;i++){\n\t\t\tvar s=rsa();\n\t\t\tint lc=int.Parse(s[1]);\n\t\t\tfor(int j=0;j<lc;j++){\n\t\t\t\trs();\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t\tint q=ri();\n\t\tString order=\"\";\n\t\t\n\t\tfor(int i=0;i<q;i++){\n\t\t\torder=rs();\n\t\t\tif(order[0]=='c'){\n\t\t\t}\n\t\t\tif(order[0]=='f'){\n\t\t\t}\n\t\t\tif(order[0]=='b'){\n\t\t\t}\n\t\t\tif(order[0]=='s'){\n\t\t\t\tConsole.WriteLine(\"top\");\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t}\n\t\n\n\tint N;\n\t//int W;\n\t//int H;\n\tpublic Sol(int n_){\n\t\tN=n_;\n\t\trs();\n\t\t//var d=ria();\n\t\t//W=d[0];H=d[1];\n\t}\n\n\n\tstatic String rs(){return Console.ReadLine();}\n\tstatic int ri(){return int.Parse(Console.ReadLine());}\n\tstatic long rl(){return long.Parse(Console.ReadLine());}\n\tstatic double rd(){return double.Parse(Console.ReadLine());}\n\tstatic String[] rsa(){return Console.ReadLine().Split(' ');}\n\tstatic int[] ria(){return Array.ConvertAll(Console.ReadLine().Split(' '),e=>int.Parse(e));}\n\tstatic long[] rla(){return Array.ConvertAll(Console.ReadLine().Split(' '),e=>long.Parse(e));}\n\tstatic double[] rda(){return Array.ConvertAll(Console.ReadLine().Split(' '),e=>double.Parse(e));}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\n \nclass TEST{\n\tstatic void Main(){\n\t\twhile(true){\n\t\t\tint n=int.Parse(Console.ReadLine());\n\t\t\tif(n==0)break;\n\t\t\tSol mySol =new Sol(n);\n\t\t\tmySol.Solve();\n\t\t}\n\t}\n}\n\nclass Sol{\n\tpublic void Solve(){\n\t\tDictionary<String,Page> D=new Dictionary<String,Page>();\n\t\t\n\t\tList<String> buf=new List<String>();\n\t\tString EOB=\"nullnullnullnullnullnull\";\n\t\t\n\t\tfor(int i=0;i<N;i++){\n\t\t\tvar s=rsa();\n\t\t\tvar P=new Page();\n\t\t\tP.Name=s[0];\n\t\t\tP.LCount=int.Parse(s[1]);\n\t\t\tfor(int j=0;j<P.LCount;j++){\n\t\t\t\ts=rsa();\n\t\t\t\tArea A=new Area(int.Parse(s[0]),int.Parse(s[1]),int.Parse(s[2]),int.Parse(s[3]));\n\t\t\t\tP.Links.Add(s[4],A);\n\t\t\t}\n\t\t\tD.Add(P.Name,P);\n\t\t\tif(i==0){\n\t\t\t\tbuf.Add(P.Name);\n\t\t\t\tbuf.Add(EOB);\n\t\t\t}\n\t\t}\n\t\t\n\t\tint q=ri();\n\t\tString order=\"\";\n\t\tint cur=0;\n\t\t\n\t\tfor(int i=0;i<q;i++){\n\t\t\torder=rs();\n\t\t\tswitch(order[0]){\n\t\t\t\tcase 'c':\n\t\t\t\t\tvar ss=order.Split(' ');\n\t\t\t\t\tint px=int.Parse(ss[1]);\n\t\t\t\t\tint py=int.Parse(ss[2]);\n\t\t\t\t\tString trgt=\"\";\n\t\t\t\t\tforeach(String lname in D[buf[cur]].Links.Keys){\n\t\t\t\t\t\tif(D[buf[cur]].Links[lname].xmin<=px &&\n\t\t\t\t\t\t   D[buf[cur]].Links[lname].xmax>=px &&\n\t\t\t\t\t\t   D[buf[cur]].Links[lname].ymin<=py &&\n\t\t\t\t\t\t   D[buf[cur]].Links[lname].ymax>=py ){\n\t\t\t\t\t\t\ttrgt=lname;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n//Console.WriteLine(\"trgt:{0}\",trgt);\n\t\t\t\t\tif(trgt!=\"\"){\n\t\t\t\t\t\tcur++;\n\t\t\t\t\t\tbuf[cur]=trgt;\n\t\t\t\t\t\tif(cur==buf.Count-1){\n\t\t\t\t\t\t\tbuf.Add(EOB);\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tbuf[cur+1]=EOB;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t\tcase 'f':\n\t\t\t\t\tif(cur+1<buf.Count&&buf[cur+1]!=EOB)cur++;\n\t\t\t\tbreak;\n\t\t\t\tcase 'b':\n\t\t\t\t\tif(cur-1>=0)cur--;\n\t\t\t\tbreak;\n\t\t\t\tcase 's':\n\t\t\t\t\tConsole.WriteLine(buf[cur]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t\n\n\tint N;\n\t//int W;\n\t//int H;\n\tpublic Sol(int n_){\n\t\tN=n_;\n\t\trs();\n\t\t//var d=ria();\n\t\t//W=d[0];H=d[1];\n\t}\n\n\tclass Page{\n\t\tpublic String Name;\n\t\tpublic Dictionary<String,Area> Links;\n\t\tpublic int LCount;\n\t\tpublic Page(){\n\t\t\tLinks=new Dictionary<String,Area>();\n\t\t}\n\t}\n\tclass Area{\n\t\tpublic int xmin;\n\t\tpublic int xmax;\n\t\tpublic int ymin;\n\t\tpublic int ymax;\n\t\tpublic Area(int in0,int in1,int in2,int in3){\n\t\t\txmin=in0;\n\t\t\tymin=in1;\n\t\t\txmax=in2;\n\t\t\tymax=in3;\n\t\t}\n\t}\n\n\n\tstatic String rs(){return Console.ReadLine();}\n\tstatic int ri(){return int.Parse(Console.ReadLine());}\n\tstatic long rl(){return long.Parse(Console.ReadLine());}\n\tstatic double rd(){return double.Parse(Console.ReadLine());}\n\tstatic String[] rsa(){return Console.ReadLine().Split(' ');}\n\tstatic int[] ria(){return Array.ConvertAll(Console.ReadLine().Split(' '),e=>int.Parse(e));}\n\tstatic long[] rla(){return Array.ConvertAll(Console.ReadLine().Split(' '),e=>long.Parse(e));}\n\tstatic double[] rda(){return Array.ConvertAll(Console.ReadLine().Split(' '),e=>double.Parse(e));}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\n \nclass TEST{\n\tstatic void Main(){\n\t\twhile(true){\n\t\t\tint n=int.Parse(Console.ReadLine());\n\t\t\tif(n==0)break;\n\t\t\tSol mySol =new Sol(n);\n\t\t\tmySol.Solve();\n\t\t}\n\t}\n}\n\nclass Sol{\n\tpublic void Solve(){\n\t\t//Dictionary<String,Page> D=new Dictionary<String,Page>();\n\t\t\n\t\t//List<String> buf=new List<String>();\n\t\t//String EOB=\"nullnullnullnullnullnull\";\n\t\t\n\t\tfor(int i=0;i<N;i++){\n\t\t\tvar s=rsa();\n\t\t\tvar P=new Page();\n\t\t\tP.Name=s[0];\n\t\t\tP.LCount=int.Parse(s[1]);\n\n\t\t\tfor(int j=0;j<P.LCount;j++){\n\t\t\t\ts=rsa();\n\t\t\t\tArea A=new Area(int.Parse(s[0]),int.Parse(s[1]),int.Parse(s[2]),int.Parse(s[3]));\n\t\t\t\tP.Links.Add(s[4],A);\n\t\t\t}\n/*\n\t\t\tD.Add(P.Name,P);\n\t\t\tif(i==0){\n\t\t\t\tbuf.Add(P.Name);\n\t\t\t\tbuf.Add(EOB);\n\t\t\t}\n*/\n\t\t}\n\t\t\n\t\tint q=ri();\n\t\tString order=\"\";\n\t\t//int cur=0;\n\t\t\n\t\tfor(int i=0;i<q;i++){\n\t\t\torder=rs();\n\t\t\tswitch(order[0]){\n\t\t\t\tcase 'c':\n/*\t\t\t\t\tvar ss=order.Split(' ');\n\t\t\t\t\tint px=int.Parse(ss[1]);\n\t\t\t\t\tint py=int.Parse(ss[2]);\n\t\t\t\t\tString trgt=\"\";\n\t\t\t\t\tforeach(String lname in D[buf[cur]].Links.Keys){\n\t\t\t\t\t\tif(D[buf[cur]].Links[lname].xmin<=px &&\n\t\t\t\t\t\t   D[buf[cur]].Links[lname].xmax>=px &&\n\t\t\t\t\t\t   D[buf[cur]].Links[lname].ymin<=py &&\n\t\t\t\t\t\t   D[buf[cur]].Links[lname].ymax>=py ){\n\t\t\t\t\t\t\ttrgt=lname;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n//Console.WriteLine(\"trgt:{0}\",trgt);\n\t\t\t\t\tif(trgt!=\"\"){\n\t\t\t\t\t\tcur++;\n\t\t\t\t\t\tbuf[cur]=trgt;\n\t\t\t\t\t\tif(cur==buf.Count-1){\n\t\t\t\t\t\t\tbuf.Add(EOB);\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tbuf[cur+1]=EOB;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n*/\n\t\t\t\tbreak;\n\t\t\t\tcase 'f':\n\t\t\t\t\t//if(cur+1<buf.Count&&buf[cur+1]!=EOB)cur++;\n\t\t\t\tbreak;\n\t\t\t\tcase 'b':\n\t\t\t\t\t//if(cur-1>=0)cur--;\n\t\t\t\tbreak;\n\t\t\t\tcase 's':\n\t\t\t\t\tConsole.WriteLine(\"top\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t\n\n\tint N;\n\t//int W;\n\t//int H;\n\tpublic Sol(int n_){\n\t\tN=n_;\n\t\trs();\n\t\t//var d=ria();\n\t\t//W=d[0];H=d[1];\n\t}\n\n\tclass Page{\n\t\tpublic String Name;\n\t\tpublic Dictionary<String,Area> Links;\n\t\tpublic int LCount;\n\t\tpublic Page(){\n\t\t\tLinks=new Dictionary<String,Area>();\n\t\t}\n\t}\n\tclass Area{\n\t\tpublic int xmin;\n\t\tpublic int xmax;\n\t\tpublic int ymin;\n\t\tpublic int ymax;\n\t\tpublic Area(int in0,int in1,int in2,int in3){\n\t\t\txmin=in0;\n\t\t\tymin=in1;\n\t\t\txmax=in2;\n\t\t\tymax=in3;\n\t\t}\n\t}\n\n\n\tstatic String rs(){return Console.ReadLine();}\n\tstatic int ri(){return int.Parse(Console.ReadLine());}\n\tstatic long rl(){return long.Parse(Console.ReadLine());}\n\tstatic double rd(){return double.Parse(Console.ReadLine());}\n\tstatic String[] rsa(){return Console.ReadLine().Split(' ');}\n\tstatic int[] ria(){return Array.ConvertAll(Console.ReadLine().Split(' '),e=>int.Parse(e));}\n\tstatic long[] rla(){return Array.ConvertAll(Console.ReadLine().Split(' '),e=>long.Parse(e));}\n\tstatic double[] rda(){return Array.ConvertAll(Console.ReadLine().Split(' '),e=>double.Parse(e));}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\n \nclass TEST{\n\tstatic void Main(){\n\t\twhile(true){\n\t\t\tint n=int.Parse(Console.ReadLine());\n\t\t\tif(n==0)break;\n\t\t\tSol mySol =new Sol(n);\n\t\t\tmySol.Solve();\n\t\t}\n\t}\n}\n\nclass Sol{\n\tpublic void Solve(){\n\t\tDictionary<String,Page> D=new Dictionary<String,Page>();\n\t\t\n\t\tList<String> buf=new List<String>();\n\t\tString EOB=\"nullnullnullnullnullnull\";\n\t\t\n\t\tfor(int i=0;i<N;i++){\n\t\t\tvar s=rsa();\n\t\t\tvar P=new Page();\n\t\t\tP.Name=s[0];\n\t\t\tP.LCount=int.Parse(s[1]);\n\t\t\tfor(int j=0;j<P.LCount;j++){\n\t\t\t\ts=rsa();\n\t\t\t\tArea A=new Area(int.Parse(s[0]),int.Parse(s[1]),int.Parse(s[2]),int.Parse(s[3]));\n\t\t\t\tP.Links.Add(s[4],A);\n\t\t\t}\n\t\t\tD.Add(P.Name,P);\n\t\t\tif(i==0){\n\t\t\t\tbuf.Add(P.Name);\n\t\t\t\tbuf.Add(EOB);\n\t\t\t}\n\t\t}\n\t\t\n\t\tint q=ri();\n\t\tString order=\"\";\n\t\tint cur=0;\n\t\t\n\t\tfor(int i=0;i<q;i++){\n\t\t\torder=rs();\n\t\t\tswitch(order[0]){\n\t\t\t\tcase 'c':\n/*\t\t\t\t\tvar ss=order.Split(' ');\n\t\t\t\t\tint px=int.Parse(ss[1]);\n\t\t\t\t\tint py=int.Parse(ss[2]);\n\t\t\t\t\tString trgt=\"\";\n\t\t\t\t\tforeach(String lname in D[buf[cur]].Links.Keys){\n\t\t\t\t\t\tif(D[buf[cur]].Links[lname].xmin<=px &&\n\t\t\t\t\t\t   D[buf[cur]].Links[lname].xmax>=px &&\n\t\t\t\t\t\t   D[buf[cur]].Links[lname].ymin<=py &&\n\t\t\t\t\t\t   D[buf[cur]].Links[lname].ymax>=py ){\n\t\t\t\t\t\t\ttrgt=lname;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n//Console.WriteLine(\"trgt:{0}\",trgt);\n\t\t\t\t\tif(trgt!=\"\"){\n\t\t\t\t\t\tcur++;\n\t\t\t\t\t\tbuf[cur]=trgt;\n\t\t\t\t\t\tif(cur==buf.Count-1){\n\t\t\t\t\t\t\tbuf.Add(EOB);\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tbuf[cur+1]=EOB;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n*/\n\t\t\t\tbreak;\n\t\t\t\tcase 'f':\n\t\t\t\t\t//if(cur+1<buf.Count&&buf[cur+1]!=EOB)cur++;\n\t\t\t\tbreak;\n\t\t\t\tcase 'b':\n\t\t\t\t\t//if(cur-1>=0)cur--;\n\t\t\t\tbreak;\n\t\t\t\tcase 's':\n\t\t\t\t\tConsole.WriteLine(\"top\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t\n\n\tint N;\n\t//int W;\n\t//int H;\n\tpublic Sol(int n_){\n\t\tN=n_;\n\t\trs();\n\t\t//var d=ria();\n\t\t//W=d[0];H=d[1];\n\t}\n\n\tclass Page{\n\t\tpublic String Name;\n\t\tpublic Dictionary<String,Area> Links;\n\t\tpublic int LCount;\n\t\tpublic Page(){\n\t\t\tLinks=new Dictionary<String,Area>();\n\t\t}\n\t}\n\tclass Area{\n\t\tpublic int xmin;\n\t\tpublic int xmax;\n\t\tpublic int ymin;\n\t\tpublic int ymax;\n\t\tpublic Area(int in0,int in1,int in2,int in3){\n\t\t\txmin=in0;\n\t\t\tymin=in1;\n\t\t\txmax=in2;\n\t\t\tymax=in3;\n\t\t}\n\t}\n\n\n\tstatic String rs(){return Console.ReadLine();}\n\tstatic int ri(){return int.Parse(Console.ReadLine());}\n\tstatic long rl(){return long.Parse(Console.ReadLine());}\n\tstatic double rd(){return double.Parse(Console.ReadLine());}\n\tstatic String[] rsa(){return Console.ReadLine().Split(' ');}\n\tstatic int[] ria(){return Array.ConvertAll(Console.ReadLine().Split(' '),e=>int.Parse(e));}\n\tstatic long[] rla(){return Array.ConvertAll(Console.ReadLine().Split(' '),e=>long.Parse(e));}\n\tstatic double[] rda(){return Array.ConvertAll(Console.ReadLine().Split(' '),e=>double.Parse(e));}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\n \nclass TEST{\n\tstatic void Main(){\n\t\twhile(true){\n\t\t\tint n=int.Parse(Console.ReadLine());\n\t\t\tif(n==0)break;\n\t\t\tSol mySol =new Sol(n);\n\t\t\tmySol.Solve();\n\t\t}\n\t}\n}\n\nclass Sol{\n\tpublic void Solve(){\n\t\t//Dictionary<String,Page> D=new Dictionary<String,Page>();\n\t\t\n\t\t//List<String> buf=new List<String>();\n\t\t//String EOB=\"nullnullnullnullnullnull\";\n\t\t\n\t\tfor(int i=0;i<N;i++){\n\t\t\tvar s=rsa();\n\t\t\tvar P=new Page();P.Links=new Dictionary<String,Area>();\n\t\t\tP.Name=s[0];\n\t\t\tP.LCount=int.Parse(s[1]);\n\n\t\t\tfor(int j=0;j<P.LCount;j++){\n\t\t\t\ts=rsa();\n\t\t\t\tArea A=new Area(int.Parse(s[0]),int.Parse(s[1]),int.Parse(s[2]),int.Parse(s[3]));\n\t\t\t\tif(A.xmin==0 && A.xmin!=0)break;\n\t\t\t\tP.Links.Add(s[4],A);\n\t\t\t}\n/*\n\t\t\tD.Add(P.Name,P);\n\t\t\tif(i==0){\n\t\t\t\tbuf.Add(P.Name);\n\t\t\t\tbuf.Add(EOB);\n\t\t\t}\n*/\n\t\t}\n\t\t\n\t\tint q=ri();\n\t\tString order=\"\";\n\t\t//int cur=0;\n\t\t\n\t\tfor(int i=0;i<q;i++){\n\t\t\torder=rs();\n\t\t\tswitch(order[0]){\n\t\t\t\tcase 'c':\n/*\t\t\t\t\tvar ss=order.Split(' ');\n\t\t\t\t\tint px=int.Parse(ss[1]);\n\t\t\t\t\tint py=int.Parse(ss[2]);\n\t\t\t\t\tString trgt=\"\";\n\t\t\t\t\tforeach(String lname in D[buf[cur]].Links.Keys){\n\t\t\t\t\t\tif(D[buf[cur]].Links[lname].xmin<=px &&\n\t\t\t\t\t\t   D[buf[cur]].Links[lname].xmax>=px &&\n\t\t\t\t\t\t   D[buf[cur]].Links[lname].ymin<=py &&\n\t\t\t\t\t\t   D[buf[cur]].Links[lname].ymax>=py ){\n\t\t\t\t\t\t\ttrgt=lname;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n//Console.WriteLine(\"trgt:{0}\",trgt);\n\t\t\t\t\tif(trgt!=\"\"){\n\t\t\t\t\t\tcur++;\n\t\t\t\t\t\tbuf[cur]=trgt;\n\t\t\t\t\t\tif(cur==buf.Count-1){\n\t\t\t\t\t\t\tbuf.Add(EOB);\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tbuf[cur+1]=EOB;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n*/\n\t\t\t\tbreak;\n\t\t\t\tcase 'f':\n\t\t\t\t\t//if(cur+1<buf.Count&&buf[cur+1]!=EOB)cur++;\n\t\t\t\tbreak;\n\t\t\t\tcase 'b':\n\t\t\t\t\t//if(cur-1>=0)cur--;\n\t\t\t\tbreak;\n\t\t\t\tcase 's':\n\t\t\t\t\tConsole.WriteLine(\"top\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t\n\n\tint N;\n\t//int W;\n\t//int H;\n\tpublic Sol(int n_){\n\t\tN=n_;\n\t\trs();\n\t\t//var d=ria();\n\t\t//W=d[0];H=d[1];\n\t}\n\n\tstruct Page{\n\t\tpublic String Name;\n\t\tpublic Dictionary<String,Area> Links;\n\t\tpublic int LCount;\n\t\t/*public Page(){\n\t\t\tLinks=new Dictionary<String,Area>();\n\t\t}*/\n\t\t\n\t}\n\tstruct Area{\n\t\tpublic int xmin;\n\t\tpublic int xmax;\n\t\tpublic int ymin;\n\t\tpublic int ymax;\n\t\tpublic Area(int in0,int in1,int in2,int in3){\n\t\t\txmin=in0;\n\t\t\tymin=in1;\n\t\t\txmax=in2;\n\t\t\tymax=in3;\n\t\t}\n\t}\n\n\n\tstatic String rs(){return Console.ReadLine();}\n\tstatic int ri(){return int.Parse(Console.ReadLine());}\n\tstatic long rl(){return long.Parse(Console.ReadLine());}\n\tstatic double rd(){return double.Parse(Console.ReadLine());}\n\tstatic String[] rsa(){return Console.ReadLine().Split(' ');}\n\tstatic int[] ria(){return Array.ConvertAll(Console.ReadLine().Split(' '),e=>int.Parse(e));}\n\tstatic long[] rla(){return Array.ConvertAll(Console.ReadLine().Split(' '),e=>long.Parse(e));}\n\tstatic double[] rda(){return Array.ConvertAll(Console.ReadLine().Split(' '),e=>double.Parse(e));}\n}"
  },
  {
    "language": "JavaScript",
    "code": "var input = require('fs').readFileSync('/dev/stdin', 'utf8');\nvar arr=input.trim().split(\"\\n\");\nwhile(true){\n   var n=arr.shift()-0;\n   if(n==0)break;\n   var wh=arr.shift()-0;\n   var obj=[];\n   var ary=[];\n   for(var i=0;i<n;i++){\n      var data=arr.shift().split(\" \");\n      var name=data[0];\n      var link=data[1]-0;\n      obj[name]=[];\n      if(i==0)ary.push(name);\n      for(var j=0;j<link;j++)obj[name].push(arr.shift().split(\" \"));\n   }\n   var m=arr.shift()-0;\n   var now=0;\n   while(m--){\n      var M=arr.shift().split(\" \");\n      if(M[0]==\"show\")console.log(ary[now]);\n      else if(M[0]==\"back\"){\n         now=Math.max(0,now-1);\n      }else if(M[0]==\"forward\"){\n         now=Math.min(now+1,ary.length-1);\n      }else if(M[0]==\"click\"){\n         var X=M[1]-0;\n         var Y=M[2]-0;\n         obj[ary[now]].forEach(function(v){\n            var x1=v[0]-0;\n            var y1=v[1]-0;\n            var x2=v[2]-0;\n            var y2=v[3]-0;\n            if(x1<=X && X<=x2 && y1<=Y && Y<=y2){\n               ary.length=now+1;\n               ary.push(v[4]);\n               now=ary.length-1;\n            }\n         });\n      }\n   }\n}"
  },
  {
    "language": "Ruby",
    "code": "### subroutines\n\ndef get_link(page, x, y)\n  for bt in page\n    x1, y1, x2, y2, link = bt\n    return link if x1 <= x && x <= x2 && y1 <= y && y <= y2\n  end\n  nil\nend\n\n### main\n\nloop do\n  n = gets.to_i\n  break if n == 0\n\n  w, h = gets.split.map(&:to_i)\n\n  pages = {}\n  buffer = []\n  nbuf = pos = 0\n\n  n.times do\n    title, nb = gets.strip.split\n    pages[title] = []\n    nb.to_i.times do\n      bts = gets.strip.split\n      pages[title] << bts[0, 4].map(&:to_i) + [bts[4]]\n    end\n\n    if nbuf == 0\n      buffer << title\n      nbuf = 1\n    end\n  end\n  #p pages\n\n  m = gets.to_i\n\n  m.times do\n    ops = gets.split\n\n    case ops[0]\n    when 'click'\n      x, y = ops[1, 2].map(&:to_i)\n      link = get_link(pages[buffer[pos]], x, y)\n      if ! link.nil?\n        pos += 1\n        buffer[pos] = link\n        nbuf = pos + 1\n      end\n    when 'back'\n      pos -= 1 if pos > 0\n    when 'forward'\n      pos += 1 if pos < nbuf - 1\n    when 'show'\n      puts buffer[pos]\n    end\n  end\nend"
  },
  {
    "language": "Ruby",
    "code": "class Button\n  attr_accessor :lx, :ly, :rx, :ry, :link\n  def initialize(a, b, c, d, l)\n    @lx, @ly, @rx, @ry, @link = a.to_i, b.to_i, c.to_i, d.to_i, l.to_s\n  end\n  def clicked?(x, y)\n    x, y = x.to_i, y.to_i\n    return false if x < lx || rx < x\n    return false if y < ly || ry < y\n    true\n  end\nend\n\nclass Page\n  attr_accessor :button\n  def initialize(b = Array.new)\n    @button = b\n  end\n  def add(b)\n    @button.push(b)\n  end\nend\n\nuntil (n = gets.to_i).zero? do\n  w, h = gets.split.map(&:to_i)\n\n  buffer = Array.new\n  pointer = 0\n  page = Hash.new\n  n.times do\n    name, b = gets.split\n    buffer.push(name) if buffer.empty?\n    page[name] = Page.new\n    b.to_i.times do\n      page[name].add(Button.new(*gets.split))\n    end\n  end\n\n  m = gets.to_i\n  m.times do\n    command, x, y = gets.split\n    case command\n      when \"click\"\n        page[buffer[pointer]].button.each do |b|\n          next unless b.clicked?(x, y)\n          pointer += 1\n          buffer = buffer.first(pointer).push(b.link)\n          break\n        end\n      when \"back\"\n        pointer -= 1 if pointer > 0\n      when \"forward\"\n        pointer += 1 if pointer < buffer.size - 1\n      when \"show\"\n        puts buffer[pointer]\n    end\n  end\nend"
  },
  {
    "language": "Ruby",
    "code": "class Rect\n  def initialize(x1,y1,x2,y2)\n    @xs = (x1..x2)\n    @ys = (y1..y2)\n  end\n  def include?(x,y)\n    @xs.include?(x) and @ys.include?(y)\n  end\nend\n\nclass Link\n  attr_reader(:name)\n  def initialize(x1,y1,x2,y2,s)\n    @rect = Rect.new(x1,y1,x2,y2)\n    @name = s\n  end\n  def hit?(x,y)\n    @rect.include?(x,y)\n  end\nend\n\nclass Page\n  def initialize(s)\n    @name = s\n    @links = []\n  end\n  def add_link(x1,y1,x2,y2,s)\n    link = Link.new(x1,y1,x2,y2,s)\n    @links << link\n  end\n  def point(x,y)\n    target = @links.find{|link| link.hit?(x,y)}\n    return nil if target==nil\n    return target.name\n  end\nend\n\nclass PageBuf\n  attr_reader(:name)\n  attr_accessor(:back, :forward)\n  def initialize(name)\n    @name = name\n    @back = self\n    @forward = self\n  end\n  def set_next(pbuf)\n    self.forward = pbuf\n    pbuf.back = self\n    pbuf\n  end\nend\n\nloop{\n  n = gets.to_i\n  break if n==0\n  pages = {}\n  \n  h, w = gets.split.map(&:to_i)\n  home = nil\n  n.times{\n    name, cs = gets.split\n    home = name if home==nil\n    page = Page.new(name)\n    cs.to_i.times{\n      args = gets.split\n      lname = args.pop\n      x1,y1,x2,y2 = args.map(&:to_i)\n      page.add_link(x1,y1,x2,y2,lname)\n    }\n    pages[name] = page\n  }\n  m = gets.to_i\n  pbuf = PageBuf.new(home)\n  m.times{\n    op, *args = gets.split\n    cur = pages[pbuf.name]\n    case op\n      when \"click\"\n        x, y = args.map(&:to_i)\n        link = cur.point(x,y)\n        if link\n          nbuf = PageBuf.new(link)\n          pbuf = pbuf.set_next(nbuf)\n        end\n      when \"back\"\n        pbuf = pbuf.back\n      when \"forward\"\n        pbuf = pbuf.forward\n      when \"show\"\n        puts pbuf.name\n    end\n  }\n}\n"
  },
  {
    "language": "Ruby",
    "code": "class Button\n  attr_accessor :lx, :ly, :rx, :ry, :link\n  def initialize(a, b, c, d, l)\n    @lx, @ly, @rx, @ry, @link = a.to_i, b.to_i, c.to_i, d.to_i, l.to_s\n  end\n  def clicked?(x, y)\n    x, y = x.to_i, y.to_i\n    return false if x < lx || rx < x\n    return false if y < ly || ry < y\n    true\n  end\nend\n\nclass Page\n  attr_accessor :button\n  def initialize(b = Array.new)\n    @button = b\n  end\n  def add(b)\n    @button.push(b)\n  end\nend\n\nuntil (n = gets.to_i).zero? do\n  w, h = gets.split.map(&:to_i)\n\n  buffer = Array.new\n  pointer = 0\n  page = Hash.new\n  n.times do\n    name, b = gets.split\n    buffer.push(name) if buffer.empty?\n    page[name] = Page.new\n    b.to_i.times do\n      page[name].add(Button.new(*gets.split))\n    end\n  end\n\n  m = gets.to_i\n  m.times do\n    command, x, y = gets.split\n    case command\n      when \"click\"\n        b = page[buffer[pointer]].button.find{|b| b.clicked?(x, y)}\n        pointer += 1\n        buffer = buffer.first(pointer).push(b.link)\n      when \"back\"\n        pointer -= 1 if pointer > 0\n      when \"forward\"\n        pointer += 1 if pointer < buffer.size - 1\n      when \"show\"\n        puts buffer[pointer]\n    end\n  end\nend"
  },
  {
    "language": "Python",
    "code": "class Page:\n    def __init__(self, name, buttons):\n        self.name = name\n        self.buttons = buttons\n\n\nclass Button:\n    def __init__(self, line):\n        self.x1 = int(line[0])\n        self.y1 = int(line[1])\n        self.x2 = int(line[2])\n        self.y2 = int(line[3])\n        self.link = line[4]\n\n\nclass Buffer:\n    def __init__(self, page):\n        self.pointer = 0\n        self.length = 0\n        self.contents = [page]\n        self.pages = {}\n\n    def click(self, x, y):\n        page = self.contents[self.pointer]\n        for button in page.buttons:\n            if button.x1 <= x <= button.x2 and button.y1 <= y <= button.y2:\n                link = button.link\n                self.contents = self.contents[:self.pointer+1]\n                self.contents.append(self.pages[link])\n                self.pointer += 1\n                self.length = self.pointer\n\n    def back(self):\n        self.pointer = max(0, self.pointer - 1)\n\n    def forward(self):\n        self.pointer = min(self.length, self.pointer + 1)\n\n    def show(self):\n        print(self.contents[self.pointer].name)\n\n\ndef page_detail():\n    name, bi = input().split()\n    buttons = []\n    for _ in range(int(bi)):\n        buttons.append(Button(input().split()))\n    page = Page(name, buttons)\n    return page, name\n\n\nwhile True:\n    n = int(input())\n    if n == 0:\n        break\n    input()\n    pages = {}\n    for i in range(n):\n        page, name = page_detail()\n        pages[name] = page\n        if i == 0:\n            buffer = Buffer(page)\n\n    buffer.pages = pages\n\n    m = int(input())\n    for _ in range(m):\n        s = input()\n        if s == \"show\":\n            buffer.show()\n        elif s == \"back\":\n            buffer.back()\n        elif s == \"forward\":\n            buffer.forward()\n        else:\n            _, x, y = s.split()\n            buffer.click(int(x), int(y))\n\n\n"
  },
  {
    "language": "Python",
    "code": "# AOJ 1054: Distorted Love\n# Python3 2018.7.7 bal4u\n\nwhile True:\n\tn = int(input())\n\tif n == 0: break\n\tinput()   # w, h\n\tpag, dic = [], {}\n\tfor i in range(n):\n\t\tnm, k = input().split()\n\t\tdic[nm] = i\n\t\tbtn = []\n\t\tfor j in range(int(k)):\n\t\t\tx1, y1, x2, y2, bnm = input().split()\n\t\t\tbtn.append((int(x1), int(y1), int(x2), int(y2), bnm))\n\t\tpag.append((nm, btn))\n\tbuf = [0]*2000\n\tnow, sz = 0, 1\n\tm = int(input())\n\tfor i in range(m):\n\t\ta = input().split()\n\t\tif a[0] == \"back\":\n\t\t\tif now > 0: now -= 1\n\t\telif a[0] == \"forward\":\n\t\t\tif now < sz-1: now += 1\n\t\telif a[0] == \"show\": print(pag[buf[now]][0])\n\t\telse:\t\t# click\n\t\t\tx, y = int(a[1]), int(a[2])\n\t\t\tbtn = pag[buf[now]][1]\n\t\t\tfor x1, y1, x2, y2, nm in btn:\n\t\t\t\tif x1 <= x and x <= x2 and y1 <= y and y <= y2:\n\t\t\t\t\tnow += 1\n\t\t\t\t\tbuf[now] = dic[nm]\n\t\t\t\t\tsz = now+1\n\t\t\t\t\tbreak\n\n"
  }
]