[
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define pb push_back\n#define x first\n#define y second\nusing namespace std;\ntypedef long long LL;\ntypedef vector<int> VI;\nusing namespace std;\nconst int NMAX=806;\nconst int INF=1000000666;\nconst LL INFLL=1000000000000666;\nconst LL maxv=100000;\nconst long double PI = acos(-1.0);\nconst int MAXT = 200000;\n\nint A[1005];\nint n;\n\nint l[NMAX], r[NMAX];\nvector<int> G[NMAX];\nbool viz[NMAX];\nint lf,rs;\n \nbool dfs(int v)\n{\n    if(viz[v])\n        return 0;\n    viz[v]=1;\n    for(auto w:G[v])\n        if(l[w] == 0 || dfs(l[w]))\n        {\n            l[w]=v;\n            r[v]=w;\n            return 1;\n        }\n    return 0;\n}\n\n\nbool isprime(int x){\n  int i = 2;\n  int q = 1;\n  if(x == 1){\n    q = 0;\n  }\n  while(i*i <= x){\n    if((x%i) == 0){\n      q=0; \n    }\n    i++;\n  }\n  return q;\n}\n\nvoid solve(){\n  cin>>n;\n  for(int i=1; i<=n; ++i){\n    cin>>A[i];\n  }\n  vector<int> df;\n  for(int i=1; i<=n; ++i){\n    if(A[i] - A[i-1] > 1 || i==1){\n      df.push_back(A[i]);\n    }\n    if(A[i+1] - A[i] > 1 || i==n){\n      df.push_back(A[i] + 1);\n    }\n  }\n  //sort(df.begin(), df.end());\n  vector<int> lft, rht;\n\n  for(auto el: df){\n    //cout<<el<<\" \";\n    if(el % 2){\n      rht.push_back(el);\n    }\n    else{\n      lft.push_back(el);\n    }\n  }\n  lf = lft.size();\n  for(int i=0; i<lft.size(); ++i){\n    for(int j=0; j<rht.size(); ++j){\n      if(isprime(abs(lft[i] - rht[j])))\n      {\n        G[i+1].push_back(j+lf+1);\n      }\n    }\n  }\n  bool q=1;\n  while(q)\n  {\n      q=0;\n      memset(viz, 0, sizeof(viz));\n      for(int i=1; i<=lf; ++i)\n      {\n          if(r[i]==0 && dfs(i))\n          {\n              q=1;\n              rs++;\n          }\n      }\n  }\n  int a = lf - rs, b = rht.size() - rs;\n  cout<<rs + 2*(a/2) + 2*(b/2) + 3*(a%2)<<\"\\n\";\n  \n\n}\n\n\nint main()\n{\n    // Tic\n    //clock_t t=clock();\n    cout<<setprecision(10)<<fixed;\n    ios_base::sync_with_stdio(0);\n\n    //freopen(\"simetrii.in\", \"rt\", stdin);\n    //freopen(\"simetrii.out\", \"wt\", stdout);\n\n    solve();\n\n    //Toc\n    //t=clock()-t;\n    //printf (\"It took me %d clicks (%f seconds).\\n\",t,((float)t)/CLOCKS_PER_SEC);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<cmath>\n#define N 210\n#define M 10000000\nusing namespace std;\nint prime[M+10],link[N],tot;\nbool p[M+10],vis[N];\nint n,m;\nbool can[N][N],s[M+10];\nvector<int>v[2];\nbool check(int u)\n{\n\tfor(int i=1;i<=m;i++)\n\tif(can[u][i] && !vis[i])\n\t{\n\t\tvis[i]=1;\n\t\tif(!link[i] || check(link[i]))\n \t\t{\n\t\t\tlink[i]=u;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\nint main()\n{\n\tp[1]=true;\n\tfor(int i=2;i<=M;i++)\n\t{\n\t\tif(!p[i]) prime[++tot]=i;\n\t\tfor(int j=1;j<=tot && i*prime[j]<=M;j++)\n\t\t{\n\t\t\tp[i*prime[j]]=1;\n\t\t\tif(i%prime[j]==0) break;\n\t\t}\n\t}\n\tscanf(\"%d\",&n);\n\tfor(int i=1,u;i<=n;i++) scanf(\"%d\",&u),s[u]=true;\n\tfor(int i=1;i<=M;i++)\n\tif(s[i]^s[i-1]) v[i&1].push_back(i);\n\tn=v[0].size(),m=v[1].size();\n\tfor(int i=0;i<n;i++)\n\t\tfor(int j=0;j<m;j++)\n\t\tif(!p[abs(v[0][i]-v[1][j])]) can[i+1][j+1]=true;\n\tint ans=0;\n    for(int i=1;i<=n;i++)\n\t{\n\t\tmemset(vis,0,sizeof(vis));\n\t\tans+=check(i+1);\n\t}\n\tint tmp=ans;\n\tans+=(n-ans)/2*2+(m-ans)/2*2;\n\tprintf(\"%d\",ans+((n&1)!=(tmp&1)?3:0));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 209\nusing namespace std;\n\nint n,a[N],pre[N]; bool mp[N][N],bo[N],tg[10000009];\nbool isprm(int x){\n\tif (x==1) return 0;\n\tint i;\n\tfor (i=2; i*i<=x; i++) if (!(x%i)) return 0;\n\treturn 1;\n}\nbool dfs(int x){\n\tint i;\n\tfor (i=1; i<=n; i++) if (bo[i] && mp[x][i]){\n\t\tbo[i]=0;\n\t\tif (!pre[i] || dfs(pre[i])){\n\t\t\tpre[i]=x; return 1;\n\t\t}\n\t}\n\treturn 0;\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tint i,j,k;\n\tfor (i=1; i<=n; i++){\n\t\tscanf(\"%d\",&k); tg[k]=1;\n\t}\n\tfor (i=1,n=0; i<=10000001; i++)\n\t\tif (tg[i]^tg[i-1]) a[++n]=i;\n\tfor (i=1; i<=n; i++) if (a[i]&1)\n\t\tfor (j=1; j<=n; j++) if (a[j]&1^1)\n\t\t\tmp[i][j]=isprm(abs(a[i]-a[j]));\n\tint sum=0;\n\tfor (i=1; i<=n; i++) if (a[i]&1){\n\t\tmemset(bo,1,sizeof(bo));\n\t\tsum+=dfs(i);\n\t}\n\tint b[2];\n\tfor (i=1; i<=n; i++) b[a[i]&1]++;\n\tb[0]-=sum; b[1]-=sum;\n\tprintf(\"%d\\n\",sum+b[0]+b[1]+(b[0]&b[1]&1));\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "///////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////\n//                       _oo0oo_                         //\n//                      o8888888o                        //\n//                      88\" . \"88      ------ hzt1       //\n//                      (| -_- |)                        //\n//                      0\\  =  /0                        //\n//                    ___/`---'\\___                      //\n//                  .' \\|     |// '.                     //\n//                 / \\|||  :  |||// \\                    //\n//                / _||||| -:- |||||- \\                  //\n//               |   | \\  -  /// |     |                 //\n//               | \\_|  ''\\---/''  |_/ |                 //\n//               \\  .-\\__  '-'  ___/-. /                 //\n//             ___'. .'  /--.--\\  `. .'___               //\n//          .\"\" '<  `.___\\_<|>_/___.' >' \"\".             //\n//         | | :  `- \\`.;`\\ _ /`;.`/ - ` : | |           //\n//         \\  \\ `_.   \\_ __\\ /__ _/   .-` /  /           //\n//     =====`-.____`.___ \\_____/___.-`___.-'=====        //\n//                       `=---='                         //\n//                                                       //\n//                                                       //\n//     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~       //\n//                                                       //\n//                 God-He Bless All.                     //\n//           This Code Will Never Explode.               //\n//                                                       //\n//                                                       //\n///////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////\n#include<cstdio>\n#include<cstring>\n#include<cctype>\n#include<algorithm>\n#include<vector>\n#define pb push_back\n#define mp make_pair\n#define xx first\n#define yy second\n#define rep(i,a,b) for(int i=(a),i##_end_=(b);i<=i##_end_;i++)\n#define dwn(i,a,b) for(int i=(a),i##_end_=(b);i>=i##_end_;i--)\nusing namespace std;\nconst int Size=1<<16;\nchar buffer[Size],*head,*tail;\ninline char Getchar() {\n    if(head==tail) {\n        int l=fread(buffer,1,Size,stdin);\n        tail=(head=buffer)+l;\n    }\n    if(head==tail) return -1;\n    return *head++;\n}\ninline int read() {\n    int x=0,f=1;char c=getchar();\n    for(;!isdigit(c);c=getchar()) if(c=='-') f=-1;\n    for(;isdigit(c);c=getchar()) x=x*10+c-'0';\n    return x*f;\n}\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int maxn=210;\nconst int maxm=10000010;\nint A[maxn],e[maxn][maxn],cnt;\nint pri[maxm/10],vis[maxm],tot;\nvoid init(int n) {\n\tvis[1]=1;\n\trep(i,2,n) {\n\t\tif(!vis[i]) pri[++tot]=i;\n\t\trep(j,1,tot) {\n\t\t\tif(i*pri[j]>n) break;\n\t\t\tvis[i*pri[j]]=1;\n\t\t\tif(i%pri[j]==0) break;\n\t\t}\n\t}\n}\nint left[maxn],T[maxn];\nint match(int x) {\n\trep(v,1,cnt) if(e[x][v]) {\n\t\tif(T[v]) continue;T[v]=1;\n\t\tif(!left[v]) {left[v]=x;return 1;}\n\t\telse if(match(left[v])) return 1;\n\t} \n\treturn 0;\n}\nint main() {\n\tinit(10000000);\n\tint n=read();\n\trep(i,1,n) {\n\t\tint x=read();\n\t\tA[i]=x;\n\t\tA[i+n]=x+1;\n\t}\n\tsort(A+1,A+2*n+1);\n\trep(i,1,n*2) if(A[i]!=A[cnt]) A[++cnt]=A[i];else cnt--;\n\tint c1=0,c2=0;\n\trep(i,1,cnt) if(A[i]&1) {\n\t\tc1++;\n\t\trep(j,1,cnt) if(!(A[j]&1)) {\n\t\t\te[i][j]=!vis[abs(A[i]-A[j])];\n\t\t}\n\t}\n\tc2=cnt-c1;\n\tint ans=0;\n\trep(i,1,cnt) if(A[i]&1) {\n\t\tmemset(T,0,sizeof(T));\n\t\tif(match(i)) ans++;\n\t}\n\tc1-=ans;c2-=ans;\n\tans+=(c1/2)*2+(c2/2)*2;\n\tif(c1&1) ans+=3;\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <cstring>\n#include <cmath>\nusing namespace std;\n\nconst int MAX_N = 100 + 9;\nconst int MAX_M = 1e7 + 9;\n\nint N, x, cnt, match[MAX_N * 2 + 2], V;\nbool is_prime[MAX_M + 9], rev[MAX_M + 9], used[MAX_N * 2 + 9];\nvector<int> primes, v1, v2, G[MAX_N * 2 + 9];\n\nvoid sieve() {\n\tmemset(is_prime, 1, sizeof(is_prime));\n\tis_prime[0] = is_prime[1] = 0;\n\tfor (int i = 2; i <= MAX_M; i++) {\n\t\tif (is_prime[i]) {\n\t\t\tprimes.push_back(i);\n\t\t\tfor (int j = i * 2; j <= MAX_M; j += i) is_prime[j] = false;\n\t\t}\n\t}\n}\n\nbool dfs(int v) {\n\tused[v] = true;\n\tfor (int i = 0; i < G[i].size(); i++) {\n\t\tint u = G[u][i], w = match[u];\n\t\tif (w < 0 || !used[w] && dfs(w)) {\n\t\t\tmatch[v] = u;\n\t\t\tmatch[u] = v;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nvoid bipartite_matching() {\n\tmemset(match, -1, sizeof(match));\n\tfor (int v = 0; v < v1.size(); v++) {\n\t\tif (match[v] < 0) {\n\t\t\tmemset(used, 0, sizeof(used));\n\t\t\tif (dfs(v)) {\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\tsieve();\n\tscanf(\"%d\", &N); \n\tfor (int i = 1; i <= N; i++) scanf(\"%d\", &x), rev[x] ^= true;\n\tfor (int i = 1; i <= MAX_M; i++) {\n\t\tif (rev[i] != rev[i - 1]) {\n\t\t\tif (i & 1) v1.push_back(i);\n\t\t\telse v2.push_back(i);\n\t\t}\n\t}\n\tfor (int i = 0; i < v1.size(); i++) {\n\t\tfor (int j = 0; j < v2.size(); j++) {\n\t\t\tint m = abs(v1[i] - v2[j]);\n\t\t\tif (is_prime[m]) G[i].push_back(j + v1.size());\n\t\t}\n\t}\n\tV = v1.size() + v2.size();\n\tbipartite_matching();\n\tprintf(\"%d\", cnt + (v1.size() - cnt >> 1 << 1) + (v2.size() - cnt >> 1 << 1) + ((v1.size() - cnt) & 1) * 3);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <queue>\n#include <limits>\n\nstruct Prime {\n    int max_n;\n    std::vector<int> primes;\n    std::vector<bool> isp;\n\n    explicit Prime(int max_n)\n        : max_n(max_n), isp(max_n + 1, true) {\n        isp[0] = isp[1] = false;\n        for (int i = 2; i * i <= max_n; ++i) {\n            if (isp[i]) {\n                for (int j = i; i * j <= max_n; ++j) {\n                    isp[i * j] = false;\n                }\n            }\n        }\n\n        for (int p = 2; p <= max_n; ++p) {\n            if (isp[p]) primes.push_back(p);\n        }\n    }\n\n    template <class T>\n    bool isprime(T n) const {\n        if (n <= max_n) return isp[n];\n        for (T p : primes) {\n            if (p * p > n) break;\n            if (n % p == 0) return false;\n        }\n        return true;\n    }\n\n    template <class T>\n    std::vector<std::pair<T, int>> factorize(T n) const {\n        std::vector<std::pair<T, int>> facts;\n        for (T p : primes) {\n            if (p * p > n) break;\n            if (n % p != 0) continue;\n            int exp = 0;\n            while (n % p == 0) {\n                n /= p;\n                ++exp;\n            }\n            facts.emplace_back(p, exp);\n        }\n        if (n > 1) {\n            facts.emplace_back(n, 1);\n        }\n        return facts;\n    }\n};\n\ntemplate <class Cap, bool isDirect>\nstruct MaxFlow {\n    struct Edge {\n        int src, dst;\n        Cap cap;\n        Edge(int src, int dst, Cap cap)\n            : src(src), dst(dst), cap(cap){};\n    };\n\n    using Edges = std::vector<Edge>;\n    using Graph = std::vector<std::vector<int>>;\n\n    Edges edges;\n    Graph graph;\n    std::vector<int> dist, iter;\n\n    explicit MaxFlow(int n)\n        : graph(n), dist(n), iter(n) {}\n\n    void span(int u, int v, Cap cap) {\n        graph[u].push_back(edges.size());\n        edges.emplace_back(u, v, cap);\n\n        graph[v].push_back(edges.size());\n        edges.emplace_back(v, u, (isDirect ? 0 : cap));\n    }\n\n    void bfs(int s) {\n        std::fill(dist.begin(), dist.end(), -1);\n        dist[s] = 0;\n        std::queue<int> que;\n        que.push(s);\n\n        while (!que.empty()) {\n            int v = que.front();\n            que.pop();\n\n            for (int eidx : graph[v]) {\n                const auto& edge = edges[eidx];\n\n                if (edge.cap > 0 && dist[edge.dst] < 0) {\n                    dist[edge.dst] = dist[v] + 1;\n                    que.push(edge.dst);\n                }\n            }\n        }\n    }\n\n    int dfs(int v, int g, Cap f) {\n        if (v == g) return f;\n\n        for (int& itr = iter[v]; itr < (int)graph[v].size(); ++itr) {\n            int eidx = graph[v][itr];\n            auto& edge = edges[eidx];\n\n            if (edge.cap > 0 && dist[v] < dist[edge.dst]) {\n                Cap df = dfs(edge.dst, g, std::min(f, edge.cap));\n\n                if (df > 0) {\n                    edge.cap -= df;\n                    auto& redge = edges[eidx ^ 1];\n                    redge.cap += df;\n                    return df;\n                }\n            }\n        }\n        return 0;\n    }\n\n    Cap exec(int s, int g) {\n        const Cap INF = std::numeric_limits<Cap>::max();\n\n        Cap ret = 0;\n        while (true) {\n            bfs(s);\n            if (dist[g] < 0) return ret;\n\n            std::fill(iter.begin(), iter.end(), 0);\n            while (true) {\n                Cap flow = dfs(s, g, INF);\n                if (flow == 0) break;\n                ret += flow;\n            }\n        }\n    }\n};\n\nstruct BiMatching {\n    MaxFlow<int, true> mf;\n    int n, m, s, g;\n\n    explicit BiMatching(int n, int m)\n        : mf(n + m + 2), n(n), m(m), s(n + m), g(n + m + 1) {\n        for (int u = 0; u < n; ++u) {\n            mf.span(s, enc(u, false), 1);\n        }\n        for (int v = 0; v < m; ++v) {\n            mf.span(enc(v, true), g, 1);\n        }\n    }\n\n    int enc(int v, bool side) {\n        return v + (side ? n : 0);\n    }\n\n    void span(int u, int v) {\n        mf.span(enc(u, false), enc(v, true), 1);\n    }\n\n    int exec() {\n        return mf.exec(s, g);\n    }\n\n    std::vector<std::pair<int, int>> matching() {\n        mf.exec(s, g);\n        std::vector<std::pair<int, int>> ret;\n        for (auto e : mf.edges) {\n            if (e.src < e.dst &&\n                e.src < n && e.dst < n + m &&\n                e.cap == 0) {\n                ret.emplace_back(e.src, e.dst - n);\n            }\n        }\n        return ret;\n    }\n};\n\nconst Prime P(10000000);\n\nvoid solve() {\n    int n;\n    std::cin >> n;\n\n    std::set<int> ss;\n    for (int i = 0; i < n; ++i) {\n        int x;\n        std::cin >> x;\n        ss.insert(x);\n    }\n\n    std::vector<int> xs;\n    for (auto x : ss) {\n        if (!ss.count(x - 1)) xs.push_back(x - 1);\n        if (!ss.count(x + 1)) xs.push_back(x);\n    }\n\n    std::vector<int> odds, evens;\n    for (auto x : xs) {\n        if (x % 2 == 0) {\n            evens.push_back(x);\n        } else {\n            odds.push_back(x);\n        }\n    }\n\n    int m1 = odds.size(), m2 = evens.size();\n\n    BiMatching bm(m1, m2);\n    for (int i = 0; i < m1; ++i) {\n        for (int j = 0; j < m2; ++j) {\n            if (P.isprime(std::abs(odds[i] - evens[j]))) {\n                bm.span(i, j);\n            }\n        }\n    }\n\n    int f = bm.exec();\n    m1 -= f, m2 -= f;\n\n    int ans = f + (m1 / 2 + m2 / 2) * 2;\n    if (m1 % 2 == 1) ans += 3;\n\n    std::cout << ans << std::endl;\n}\n\nint main() {\n    std::cin.tie(nullptr);\n    std::ios::sync_with_stdio(false);\n\n    solve();\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=205;\nint x,n,a[N],c[2],match[N],b[N][N],flag[N],flag2[10000005];\nint pd(int x){\n\tif (x==1)return 0;\n\tfor (int i=2;i*i<=x;i++)\n\t\tif (x%i==0)return 0;\n\treturn 1;\n}\nint dfs(int x){\n\tfor (int i=1;i<=n;i++)\n\t\tif (flag[i]&&b[x][i]){\n\t\t\tflag[i]=0;\n\t\t\tif (!match[i]||dfs(match[i])){\n\t\t\t\tmatch[i]=x;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\treturn 0;\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<=n;i++){\n\t\tscanf(\"%d\",&x);\n\t\tflag2[x]=1;\n\t}\n\tn=0;\n\tfor (int i=1;i<=10000001;i++)\n\t\tif (flag2[i]^flag2[i-1])a[++n]=i;\n\tfor (int i=1;i<=n;i++)\n\t\tif (a[i]&1)for (int j=1;j<=n;j++)\n\t\t\tif (!(a[j]&1))b[i][j]=pd(abs(a[i]-a[j]));\n\tint sum=0;\n\tfor (int i=1;i<=n;i++)\n\t\tif (a[i]&1){\n\t\t\tmemset(flag,1,sizeof(flag));\n\t\t\tsum+=dfs(i);\n\t\t}\n\tfor (int i=1;i<=n;i++)c[a[i]&1]++;\n\tc[0]-=sum;c[1]-=sum;\n\tprintf(\"%d\\n\",sum+c[0]+c[1]+(c[0]&c[1]&1));\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define For(i,j,k) for(int i=j;i<=k;++i)\n#define Forr(i,j,k) for(int i=j;i>=k;--i)\n#define Rep(i,u) for(int i=Begin[u],v=to[i];i;i=Next[i],v=to[i])\n#define ll long long \nusing namespace std;\nconst int N=210,INF=0x3f3f3f3f;\ntemplate<class T>void read(T &x){\n\tx=0;char c=getchar();\n\twhile(!isdigit(c))c=getchar();\n\twhile( isdigit(c))x=x*10+c-48,c=getchar();\n}\nint n,Link[N],Begin[N],Next[N*N],to[N*N],e;\ninline void add(int x,int y){\n\tto[++e]=y,Next[e]=Begin[x],Begin[x]=e;\n}\ninline void file(){\n#ifndef ONLINE_JUDGE\n\tfreopen(\"test.in\",\"r\",stdin);\n\tfreopen(\"test.out\",\"w\",stdout);\n#endif \n}\nint X[N],x[N],y[N],totx,toty;\n\nnamespace divide{\n\tconst int N=70,S=13,pri[S]={2,3,5,7,11,13,17,19,23,29,31,37,41};\n\tll pr[N],p[N];int c[N],cnt;\n\tll qpow(ll a,ll b,ll P){\n\t\tll ret=1;\n\t\tfor(;b;b>>=1,a=a*a%P)if(b&1)ret=ret*a%P;\n\t\treturn ret;\n\t}\n\tinline bool Miller_Rabin(ll x){\n\t\tint C=0,Times=S;\n\t\tll val,t=x-1,lst;\n\t\tFor(i,0,S-1)if(x==pri[i])return 1;\n\t\tif(x==1)return 0;\n\t\twhile(!(t&1))C++,t>>=1;\n\t\twhile(Times--){\n\t\t\tll a=pri[Times]%x;\n\t\t\tlst=qpow(a,t,x);\n\t\t\tFor(i,1,C){\n\t\t\t\tval=lst*lst%x;\n\t\t\t\tif(val==1&&lst!=x-1&&lst!=1)return 0;\n\t\t\t\tlst=val;\n\t\t\t}\n\t\t\tif(val!=1)return 0;\n\t\t}\n\t\treturn 1;\n\t}\n}namespace D=divide;\nbool check(int p){\n\tif(p==2)return 0;\n\treturn D::Miller_Rabin(p);\n}\nvoid init(){\n\tread(n);\n\tFor(i,1,n)read(X[i]);\n\tX[0]=-1;\n\tFor(i,1,n){\n\t\tif(X[i-1]!=X[i]-1){\n\t\t\tif(X[i]&1)x[++totx]=X[i];\n\t\t\telse y[++toty]=X[i];\n\t\t}\n\t\tif(X[i+1]!=X[i]+1){\n\t\t\tif((X[i]+1)&1)x[++totx]=X[i]+1;\n\t\t\telse y[++toty]=X[i]+1;\n\t\t}\n\t}\n\t//For(i,1,totx)printf(\"%d \",x[i]);puts(\"\");\n\t//For(i,1,toty)printf(\"%d \",y[i]);puts(\"\");\n\tFor(i,1,totx)\n\t\tFor(j,1,toty)\n\t\t\tif(check(abs(y[j]-x[i])))add(i,j);\n}\nint vis[N];\nbool Hungary(int u){\n\tRep(i,u)if(!vis[v]){\n\t\tvis[v]=1;\n\t\tif(!Link[v]||Hungary(Link[v]))return Link[v]=u,1;\n\t}\n\treturn 0;\n}\nvoid solve(){\n\tint ret=0,ans=0;\n\tFor(i,1,totx){\n\t\tFor(j,1,toty)vis[j]=0;\n\t\tret+=Hungary(i);\n\t}\n\tans=ret;\n\tans+=(totx-ret)/2*2;\n\tans+=(toty-ret)/2*2;\n\tif(ret%2!=totx%2)ans+=3;\n\tprintf(\"%d\\n\",ans);\n}\nint main(){\n\tinit();\n\tsolve();\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#define fo(i,a,b) for(int i=a;i<=b;i++)\n#define N 510\n#define M 10000010\nusing namespace std;\nint n,a[M],q[N],w[N],bz[M],p[M],last[N],nxt[N],to[N],tot=0,b[N],jy=0,ans=0;\nvoid link(int x,int y)\n{\n\tnxt[++tot]=last[x];last[x]=tot;to[tot]=y;\n}\nint dg(int x)\n{\n\tif(bz[x]==tot) return 0;\n\tbz[x]=tot;\n\tfor(int i=last[x];i;i=nxt[i])\n\t{\n\t\tint y=to[i];\n\t\tif(b[y]==0||dg(b[y]))\n\t\t{\n\t\t\tb[y]=x;return 1;\n\t\t}\n\t}\n\treturn 0;\n}\nint main()\n{\n\tfo(i,2,M-1)\n\t{\n\t\tif(!bz[i]) p[++p[0]]=i;\n\t\tfo(j,1,p[0])\n\t\t{\n\t\t\tint k=i*p[j];\n\t\t\tif(k>=M) break;\n\t\t\tbz[k]=1;\n\t\t\tif(i%p[j]==0) break;\n\t\t}\n\t}\n\tscanf(\"%d\",&n);\n\tfo(i,1,n)\n\t{\n\t\tint x;scanf(\"%d\",&x);\n\t\ta[x]=1;\n\t}\n\tfo(i,1,M-1)\n\tif(a[i]!=a[i-1])\n\t{\n\t\tif(i%2==1) q[++q[0]]=i;\n\t\telse w[++w[0]]=i;\n\t}\n\tbz[1]=bz[2]=1;\n\tfo(i,1,q[0]) fo(j,1,w[0]) if(bz[abs(q[i]-w[j])]==0) link(i,j);\n\tmemset(bz,0,sizeof(bz));\n\tfor(tot=1;tot<=n;tot++) if(!bz[tot]&&b[tot]==0) jy+=dg(tot);\n\tans=(q[0]-jy)-(q[0]-jy)%2;\n\tans=ans+(w[0]-jy)-(w[0]-jy)%2;\n\tans+=jy;\n\tans+=3*((q[0]-jy)%2);\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nconst int inf=0x7f7f7f7f;\nint n,m,S,T,ans,cnt,tot=1,hd,tl,a[110],b[210],head[210],cur[210],to[20010],nxt[20010],val[20010],pre[20010],dep[210],q[210],num[210];\ninline int abs(int x){\n\treturn x>0?x:-x;\n}\ninline int min(int a,int b){\n\treturn a<b?a:b;\n}\ninline void add_edge(int u,int v,int w){\n\tnxt[++tot]=head[u];\n\tto[tot]=v;\n\tval[tot]=w;\n\thead[u]=tot;\n\treturn;\n}\ninline void Add_edge(int u,int v,int w){\n\tadd_edge(u,v,w);\n\tadd_edge(v,u,0);\n\treturn;\n}\nvoid bfs(){\n    for(int i=0;i<T;i++)\n\t    dep[i]=T+1;\n    dep[T]=0;\n    hd=tl=0;\n    q[tl++]=T;\n    while(hd<tl){\n\t    int u=q[hd++];\n\t    for(register int i=head[u];i;i=nxt[i]){\n\t\t    int v=to[i];\n\t\t    if(dep[v]==T+1&&val[i^1]){\n\t\t\t    dep[v]=dep[u]+1;\n\t\t\t    q[tl++]=v;\n\t\t\t}\n\t\t}\n\t}\n    return;\n}\ninline int get_flow(){\n    int flw=inf;\n    for(int u=T;u!=S;u=to[pre[u]^1])\n\t    flw=min(flw,val[pre[u]]);\n    for(int u=T;u!=S;u=to[pre[u]^1]){\n\t    val[pre[u]]-=flw;\n\t    val[pre[u]^1]+=flw;\n\t}\n    return flw;\n}\nvoid ISAP(){\n    int u=S;\n    bfs();\n    for(int i=0;i<=T;i++){\n\t    num[dep[i]]++;\n\t    cur[i]=head[i];\n\t}\n    while(dep[S]<T){\n\t    if(u==T){\n\t\t    ans+=get_flow();\n\t\t    u=S;\n\t\t}\n\t    bool ck=0;\n\t    for(int i=cur[u];i;i=nxt[i])\n\t\t    if(dep[to[i]]+1==dep[u]&&val[i]){\n\t\t\t    ck=1;\n\t\t\t    cur[u]=i;\n\t\t\t    pre[u=to[i]]=i;\n\t\t\t    break;\n\t\t\t}\n\t    if(!ck){\n\t\t    int mini=T-1;\n\t\t    for(int i=head[u];i;i=nxt[i])\n\t\t\t    if(val[i])\n\t\t\t\t    mini=min(mini,dep[to[i]]);\n\t\t    if(!(--num[dep[u]]))\n\t\t\t    break;\n\t\t    num[dep[u]=(mini+1)]++;\n\t\t    cur[u]=head[u];\n\t\t    if(u!=S)\n\t\t\t    u=to[pre[u]^1];\n\t\t}\n\t}\n    return;\n}\ninline bool check(int x){\n\tif(x<=2)\n\t\treturn 0;\n\tfor(register int i=2;i*i<=x;i++){\n\t\tif(!(x%i))\n\t\t\treturn 0;\n\t}\n\treturn 1;\n}\nint main(){\n\tcnt=0;\n\tscanf(\"%d%d\",&n,a+1);\n\tb[++cnt]=a[1];\n\tfor(int i=2;i<=n;i++){\n\t\tscanf(\"%d\",a+i);\n\t\tif(a[i]-a[i-1]>1&&i>1){\n\t\t\tb[++cnt]=a[i-1]+1;\n\t\t\tb[++cnt]=a[i];\n\t\t}\n\t}\n\tb[++cnt]=a[n]+1;\n\tS=0,T=cnt+1;\n\tfor(int i=1;i<=cnt;i++){\n\t\tif(b[i]&1){\n\t\t\tm++;\n\t\t\tAdd_edge(S,i,1);\n\t\t\tfor(int j=1;j<=cnt;j++)\n\t\t\t\tif(!(b[j]&1)&&check(abs(b[i]-b[j])))\n\t\t\t\t\tAdd_edge(i,j,1);\n\t\t}\n\t\telse Add_edge(i,T,1);\n\t}\n\tISAP();\n\tprintf(\"%d\",cnt-ans+((m-ans)&1));\n\treturn 0;\n}\n/*\n3\n1 3 5\n*/"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<cstring>\nusing namespace std;\nint n;\nint res;\nvector<int>v;\nint lst=-1;\nint match[210];\nint me,mo;\nint mx;\nbool f[10000010];\nvector<int>ok[210];\nbool vis[210];\nbool bp(int x)\n{\n\tfor(int i=0;i<ok[x].size();i++)\n\t{\n\t\tint y=ok[x][i];\n\t\tif(vis[y])continue;\n\t\tvis[y]=true;\n\t\tif(match[y]==-1 || bp(match[y]))\n\t\t{\n\t\t\tmatch[y]=x;\n\t\t\treturn true;\n\t\t}\n\t\tvis[y]=false;\n\t}\n\treturn false;\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint x;\n\t\tscanf(\"%d\",&x);\n\t\tif(x!=lst+1)\n\t\t{\n\t\t\tif(lst+1)v.push_back(lst+1);\n\t\t\tv.push_back(x);\n\t\t}\n\t\tlst=x;\n\t\tmx=lst+1;\n\t}\n\tv.push_back(lst+1);\n\tf[1]=true;\n\tfor(int i=2;i<=mx;i++)\n\t{\n\t\tif(f[i])continue;\n\t\tfor(int j=i+i;j<=mx;j+=i)f[j]=true;\n\t}\n\tint l=v.size();\n\tfor(int i=0;i<l;i++)\n\t{\n\t\tmatch[i]=-1;\n\t\tif(v[i]&1)mo++;else me++;\n\t\tfor(int j=i+1;j<l;j++)\n\t\t{\n\t\t\tif(v[j]-v[i]!=2 && !f[v[j]-v[i]])\n\t\t\t{\n\t\t\t\tok[i].push_back(j);\n\t\t\t\tok[j].push_back(i);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<l;i++)\n\t{\n\t\tmemset(vis,false,sizeof(vis));\n\t\tif(bp(i))res++;\n\t}\n\tres/=2;\n\tprintf(\"%d\",res+((me-res)/2+(mo-res)/2)*2+((me-res)%2)*3);\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n#define FOR(i,n) for(int i = 0; i < (n); i++)\n#define sz(c) ((int)c.size())\n#define ten(n) ((int)1e##n)\nusing ll = long long;\nusing Pii = pair<int, int>;\nusing Pll = pair<ll, ll>;\n\ntemplate<typename ...> static inline int getchar_unlocked(void) { return getchar(); }\ntemplate<typename ...> static inline void putchar_unlocked(int c) { putchar(c); }\n#define mygc(c) (c)=getchar_unlocked()\n#define mypc(c) putchar_unlocked(c)\nvoid reader(int& x) { int k, m = 0; x = 0; for (;;) { mygc(k); if (k == '-') { m = 1; break; }if ('0' <= k&&k <= '9') { x = k - '0'; break; } }for (;;) { mygc(k); if (k<'0' || k>'9')break; x = x * 10 + k - '0'; }if (m) x = -x; }\nvoid reader(ll& x) { int k, m = 0; x = 0; for (;;) { mygc(k); if (k == '-') { m = 1; break; }if ('0' <= k&&k <= '9') { x = k - '0'; break; } }for (;;) { mygc(k); if (k<'0' || k>'9')break; x = x * 10 + k - '0'; }if (m) x = -x; }\nint reader(char c[]) { int i, s = 0; for (;;) { mygc(i); if (i != ' '&&i != '\\n'&&i != '\\r'&&i != '\\t'&&i != EOF) break; }c[s++] = i; for (;;) { mygc(i); if (i == ' ' || i == '\\n' || i == '\\r' || i == '\\t' || i == EOF) break; c[s++] = i; }c[s] = '\\0'; return s; }\nint reader(string& c) { int i; for (;;) { mygc(i); if (i != ' '&&i != '\\n'&&i != '\\r'&&i != '\\t'&&i != EOF) break; }c.push_back(i); for (;;) { mygc(i); if (i == ' ' || i == '\\n' || i == '\\r' || i == '\\t' || i == EOF) break; c.push_back(i); }; return sz(c); }\ntemplate <class T, class S> void reader(T& x, S& y) { reader(x); reader(y); }\ntemplate <class T, class S, class U> void reader(T& x, S& y, U& z) { reader(x); reader(y); reader(z); }\ntemplate <class T, class S, class U, class V> void reader(T& x, S& y, U& z, V & w) { reader(x); reader(y); reader(z); reader(w); }\nvoid writer(int x, char c) { int s = 0, m = 0; char f[10]; if (x<0)m = 1, x = -x; while (x)f[s++] = x % 10, x /= 10; if (!s)f[s++] = 0; if (m)mypc('-'); while (s--)mypc(f[s] + '0'); mypc(c); }\nvoid writer(ll x, char c) { int s = 0, m = 0; char f[20]; if (x<0)m = 1, x = -x; while (x)f[s++] = x % 10, x /= 10; if (!s)f[s++] = 0; if (m)mypc('-'); while (s--)mypc(f[s] + '0'); mypc(c); }\nvoid writer(const char c[]) { int i; for (i = 0; c[i] != '\\0'; i++)mypc(c[i]); }\nvoid writer(const string& x, char c) { int i; for (i = 0; x[i] != '\\0'; i++)mypc(x[i]); mypc(c); }\nvoid writer(const char x[], char c) { int i; for (i = 0; x[i] != '\\0'; i++)mypc(x[i]); mypc(c); }\ntemplate<class T> void writerLn(T x) { writer(x, '\\n'); }\ntemplate<class T, class S> void writerLn(T x, S y) { writer(x, ' '); writer(y, '\\n'); }\ntemplate<class T, class S, class U> void writerLn(T x, S y, U z) { writer(x, ' '); writer(y, ' '); writer(z, '\\n'); }\ntemplate<class T> void writerArr(T x[], int n) { if (!n) { mypc('\\n'); return; }FOR(i, n - 1)writer(x[i], ' '); writer(x[n - 1], '\\n'); }\ntemplate<class T> void writerArr(vector<T>& x) { writerArr(x.data(), (int)x.size()); }\n\ntemplate<class T> void chmin(T& a, const T& b) { if (a > b) a = b; }\ntemplate<class T> void chmax(T& a, const T& b) { if (a < b) a = b; }\n\ntemplate<class T> T gcd(T a, T b) { return b ? gcd(b, a % b) : a; }\ntemplate<class T> T lcm(T a, T b) { return a / gcd(a, b) * b; }\nll mod_pow(ll a, ll n, ll mod) {\n\tll ret = 1;\n\tll p = a % mod;\n\twhile (n) {\n\t\tif (n & 1) ret = ret * p % mod;\n\t\tp = p * p % mod;\n\t\tn >>= 1;\n\t}\n\treturn ret;\n}\ntemplate<class T> T extgcd(T a, T b, T& x, T& y) { for (T u = y = 1, v = x = 0; a;) { T q = b / a; swap(x -= q * u, u); swap(y -= q * v, v); swap(b -= q * a, a); } return b; }\ntemplate<class T> T mod_inv(T a, T m) { T x, y; extgcd(a, m, x, y); return (m + x % m) % m; }\n\nbool prime[ten(7) + 1];\nvector<int> prs;\nvoid init_prime() {\n\tmemset(prime, 1, sizeof(prime));\n\tprime[0] = prime[1] = false;\n\tfor (int i = 2; i < sizeof(prime); i++) if (prime[i])\n\t\tfor (int j = i * 2; j < sizeof(prime); j += i) prime[j] = false;\n\tfor (int i = 2; i < sizeof(prime); i++) if (prime[i]) prs.push_back(i);\n}\n\nint f(int x) {\n\tif (x == 0) return 0;\n\tif (x % 2 == 0) return 2;\n\tif (prime[x]) return 1;\n\treturn 3;\n}\n\nint dp[101][101];\n\nint main() {\n\t\n\tinit_prime();\n\n\tint n; reader(n);\n\tvector<int> x(n);\n\tFOR(i, n) reader(x[i]);\n\n\tfor (int len = 1; len <= n; len++) {\n\t\tfor (int l = 0; l < n; l++) {\n\t\t\tint r = l + len;\n\t\t\tif (r > n) break;\n\n\t\t\tint tmp = ten(5);\n\t\t\tfor (int md = l + 1; md < r; md++) {\n\t\t\t\tint ca = dp[l][md] + dp[md][r];\n\t\t\t\ttmp = min(tmp, ca);\n\t\t\t}\n\n\t\t\tint cans = f(x[r-1] - x[l] + 1);\n\t\t\tFOR(i, len - 1) {\n\t\t\t\tint diff = x[l + i + 1] - x[l + i] - 1;\n\t\t\t\tint ctmp = f(diff);\n\t\t\t\tcans += ctmp;\n\t\t\t}\n\n\t\t\ttmp = min(tmp, cans);\n\t\t\tdp[l][r] = tmp;\n\t\t}\n\t}\n\n\tint ans = dp[0][n];\n\twriterLn(ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nbool up[10000002];\nvector<int> v1;\nvector<int> v2;\n\nint Nx,Ny;\nconst int MAXN = 200;\nvector<int> edgex[MAXN+1],edgey[MAXN+1];\nint matchx[MAXN+1],matchy[MAXN+1];\nbool visitx[MAXN+1],visity[MAXN+1];\nbool dfs(int x){\n   visitx[x]=true;\n   for(int i=0;i<edgex[x].size();i++){\n      int y=edgex[x][i];\n      visity[y]=true;\n      if(matchy[y]==-1||(!visitx[matchy[y]]&&dfs(matchy[y]))){\n         matchy[matchx[x]=y]=x;\n         return true;\n      }\n   }\n   return false;\n}\nint matching(){\n   memset(matchx,-1,sizeof matchx);\n   memset(matchy,-1,sizeof matchy);\n   int ans=0;\n   for(int i=0;i<Nx;i++){\n      memset(visitx,0,sizeof visitx);\n      memset(visity,0,sizeof visity);\n      if(dfs(i))  ans++;\n   }\n   return ans;\n}\nbool op(int x,int y){\n\tint tmp=abs(x-y);\n\tfor(long long int i=3;i*i<=tmp;i++)\n\t\tif(tmp%i==0)\n\t\t\treturn true;\n\treturn false;\n}\n\nint main(){\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\tint n;\n\tcin>>n;\n\tfor(int i=0,x;i<n;i++){\n\t\tcin>>x;\n\t\tup[x]=true;\n\t}\n\tfor(int i=1;i<=10000001;i++)\n\t\tif(up[i]!=up[i-1]){\n\t\t\tif(i&1)\n\t\t\t\tv1.push_back(i);\n\t\t\telse\n\t\t\t\tv2.push_back(i);\n\t\t}\n\tNx=v1.size();Ny=v2.size();\n\tfor(int i=0;i<Nx;i++)\n\t\tfor(int j=0;j<Ny;j++)\n\t\t\tif(op(i,j))\n\t\t\t\tedgex[i].push_back(j),edgey[j].push_back(i);\n\tint k=matching();\n\tcout<<k+(Nx-k)/2*2+(Ny-k)/2*2+3*((Nx-k)&1)<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define fi first\n#define se second\n#define mp make_pair\n#define gc getchar\n#define pb push_back\n#define eb emplace_back\n#define all(x) (x).begin(),(x).end()\n#define x1 uvuvwevwevwe\n#define y1 onyetenyevwe\n#define x2 ugwemubwem\n#define y2 ossas\ntypedef long long LL;\ntypedef long double LD;\ntypedef pair<int,int> pii;\nconst int batasprima=5000;\ntemplate <typename T> void scan(T &angka){\n\tangka=0;char input=gc();T kali=1;\n\twhile(!(48<=input&&input<=57)){\tif(input=='-')\tkali=-1;input=gc();}\n\twhile(48<=input&&input<=57)\tangka=(angka<<3)+(angka<<1)+input-48,input=gc();angka*=kali;\n}\ntemplate <typename T1,typename T2> void scan(T1 &angka1,T2 &angka2){\n\tscan(angka1);scan(angka2);\n}\nint match[205],k,ans;\nvector <int> daftar,adj[205],prime;\nbitset<205> visited;\nvoid sieve(){\n\tbool isprime[batasprima+5];\n\tmemset(isprime,true,sizeof(isprime));\n\tfor(int i=2;i<=batasprima;i++)\n\t{\n\t\tif(!isprime[i])\n\t\t\tcontinue;\n\t\tprime.pb(i);\n\t\tfor(int j=i+i;j<=batasprima;j+=i)\n\t\t\tisprime[j]=false;\n\t}\n}\nbool isprime(int angka){\n\tif(angka<2)\n\t\treturn false;\n\tfor(auto isi:prime)\n\t{\n\t\tif(angka%isi==0)\n\t\t\treturn false;\n\t}\n\treturn true;\n}\nbool matching(int pos){\n\tif(visited[pos])\n\t\treturn false;\n\tvisited[pos]=true;\n\tfor(auto isi:adj[pos])\n\t{\n\t\tif(match[isi]==-1||matching(match[isi]))\n\t\t{\n\t\t\tmatch[isi]=pos;\n\t\t\tmatch[pos]=isi;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\nvoid buatgraph(){\t\n\tfor(int i=0;i<daftar.size();i++)\n\t{\n\t\tfor(int j=0;j<daftar.size();j++)\n\t\t{\n\t\t\tif(isprime(abs(daftar[i]-daftar[j])))\n\t\t\t\tadj[i].pb(j);\n\t\t}\n\t}\n}\nvoid hitungk(){\n\tk=0;\n\tmemset(match,-1,sizeof(match));\n\tfor(int i=0;i<daftar.size();i++)\n\t{\n\t\tif(match[i]!=-1)\n\t\t\tcontinue;\n\t\tvisited.reset();\n\t\tif(matching(i))\n\t\t\tk++;\n\t}\n}\nvoid hitungans(){\n\tint genap=0,ganjil=0;\n\tfor(auto isi:daftar)\n\t{\n\t\tif(isi&1)\n\t\t\tganjil++;\n\t\telse\n\t\t\tgenap++;\n\t}\n\tassert(ganjil>=k&&genap>=k);\n\tassert(ganjil%2==genap%2);\n\tans=k+((ganjil-k)/2+(genap-k)/2)*2+((ganjil-k)%2)*3;\n\tif((ganjil-k)%2)\n\t{\n\t\tfor(int i=1;i<daftar.size();i++)\n\t\t{\n\t\t\tif(daftar[i]-daftar[i-1]==1)\n\t\t\t{\n\t\t\t\tans--;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\nvoid isidaftar(){\n\tint n,tadi=0;\n\tscan(n);\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tint input;\n\t\tscan(input);\n\t\tassert(tadi<input);\n\t\ttadi=input;\n\t\tif(daftar.size()&&daftar.back()==input)\n\t\t\tdaftar[daftar.size()-1]=input+1;\t\t\t//nanti mau sa coba\n\t\telse\n\t\t\tdaftar.pb(input),daftar.pb(input+1);\n\t}\n\tassert(daftar.size()<=200);\n}\nint main()\n{\n\tsieve();\n\tisidaftar();\n\tbuatgraph();\n\thitungk();\n\thitungans();\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdlib>\n#include<vector>\n#include<cstring>\nusing namespace std;\nconst int N=205,M=1e7+10;\nint n,a[N],pri[M/10],tot,ans;\nbool vis[M],b[M],ur[N];\nint ld[N],rd[N],cl,cr,even,odd;\nint lf[N];\nvector<int>G[N];\nvoid sieve(int n){\n\tvis[1]=1;\n\tfor(int i=2;i<=n;++i){\n\t\tif(!vis[i])pri[++tot]=i;\n\t\tfor(int j=1;j<=tot&&i*pri[j]<=n;++j){\n\t\t\tvis[i*pri[j]]=1;\n\t\t\tif(i%pri[j]==0)break;\n\t\t}\n\t}\n}\nbool dfs(int u){\n\tfor(int to:G[u])\n\tif(!ur[to]){\n\t\tur[to]=1;\n\t\tif(!lf[to]||dfs(lf[to])){\n\t\t\tlf[to]=u;\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\nint main(){\n\tios::sync_with_stdio(0),cin.tie(0),cout.tie(0);\n\tcin>>n;\n\tfor(int i=1;i<=n;++i){\n\t\tcin>>a[i];\n\t\tb[a[i]]=1;\n\t}\n\tfor(int i=10000001;i;--i)if(b[i]^=b[i-1]){\n\t\tif(i&1)ld[++cl]=i;else rd[++cr]=i;\n\t}\n\tsieve(10000000);\n\tfor(int i=1;i<=cl;++i)\n\tfor(int j=1;j<=cr;++j)if(!vis[abs(ld[i]-rd[j])])G[i].push_back(j);\n\tmemset(lf,0,sizeof lf);\n\tfor(int i=1;i<=cl;++i){\n\t\tmemset(ur,0,sizeof ur);\n\t\tans+=dfs(i);\n\t}\n\tmemset(ur,0,sizeof ur);\n\tfor(int i=1;i<=cr;++i)ur[lf[i]]=1;\n\tfor(int i=1;i<=cl;++i)if(!ur[i])++odd;\n\tfor(int i=1;i<=cr;++i)if(!lf[i])++even;\n\tans+=(odd>>1<<1)+(even>>1<<1)+(odd&1)*3;\n\tcout<<ans<<'\\n';\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <cmath>\n#include <cstdlib>\n#include <vector>\n#include <set>\n#include <map>\n#include <cassert>\n#include <queue>\n#include <ctime>\n#include <string>\n#include <cstring>\n#include <random>\n#define mp make_pair\n#define pb push_back\n#define NAME \"\"\n#define y1 y1_423\n#define list lista\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\n\ntemplate<typename T>\nostream& operator << (ostream& cout, const vector<T> &a) {\n\tif ((int)a.size() == 0) {\n\t\treturn (cout << \"()\");\n\t}\n\tcout << \"(\" << a[0];\n\tfor (int i = 1; i < (int)a.size(); i++) {\n\t\tcout << \"; \" << a[i];\n\t}\n\treturn (cout << \")\");\n}\n\ntemplate<typename T>\nostream& operator << (ostream& cout, const set<T> &a) {\n\tif ((int)a.size() == 0) {\n\t\treturn (cout << \"{}\");\n\t}\n\tauto it = a.begin();\n\tcout << \"{\" << *it;\n\t++it;\n\tfor (; it != a.end(); ++it) {\n\t\tcout << \"; \" << *it;\n\t}\n\treturn (cout << \"}\");\n}\n\ntemplate<typename T>\nostream& operator << (ostream& cout, const multiset<T> &a) {\n\tif ((int)a.size() == 0) {\n\t\treturn (cout << \"{}\");\n\t}\n\tauto it = a.begin();\n\tcout << \"{\" << *it;\n\t++it;\n\tfor (; it != a.end(); ++it) {\n\t\tcout << \"; \" << *it;\n\t}\n\treturn (cout << \"}\");\n}\n\ntemplate<typename T1, typename T2>\nostream& operator << (ostream& cout, const pair<T1, T2> &a) {\n\treturn cout << \"(\" << a.first << \"; \" << a.second << \")\";\n}\n\nrandom_device gen;\nmt19937 rnd(gen());\n\nconst int nmax = 1000 * 1000 * 10 + 10;\nconst int inf = 2000 * 1000 * 1000;\nconst ll infl = 1000ll * 1000ll * 1000ll * 1000ll * 1000ll * 1000ll;\nconst int mod = 1000 * 1000 * 1000 + 7;\nconst ld pi = acos(-1.0);\n\nint used[nmax], u[nmax], p[nmax], b[nmax];\nvector<int> a, go[nmax];\n\nbool ok(int v) {\n\tif (u[v]) return false;\n\tu[v] = true;\n\tfor (int u : go[v]) {\n\t\tif (p[u] == -1) {\n\t\t\tp[u] = v;\n\t\t\treturn true;\n\t\t}\n\t}\n\tfor (int u : go[v]) {\n\t\tif (ok(u)) {\n\t\t\tp[u] = v;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint main() {\n\t//freopen(\"input.txt\", \"r\", stdin);freopen(\"output.txt\", \"w\", stdout);\n\t//freopen(NAME\".in\", \"r\", stdin);freopen(NAME\".out\", \"w\", stdout);\n\tfor (int i = 2; i < nmax; i++) {\n\t\tused[i] = 1;\n\t}\n\tfor (ll i = 2; i * i < nmax; i++) {\n\t\tif (!used[i]) continue;\n\t\tfor (ll j = i * i; j < nmax; j += i) {\n\t\t\tused[j] = 0;\n\t\t}\n\t}\n\tused[0] = used[1] = used[2] = 0;\n\tint n;\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; i++) {\n\t\tint x;\n\t\tscanf(\"%d\", &x);\n\t\tb[x] ^= 1;\n\t\tb[x + 1] ^= 1;\n\t}\n\tfor (int i = 0; i < nmax; i++) {\n\t\tif (b[i] == 1) {\n\t\t\ta.pb(i);\n\t\t}\n\t}\n\tn = a.size();\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif (i == j) continue;\n\t\t\tif (used[abs(a[i] - a[j])]) {\n\t\t\t\tgo[i].pb(j);\n\t\t\t}\n\t\t}\n\t}\n\tint cnt0 = 0, cnt1 = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (a[i] % 2 == 0) {\n\t\t\tcnt0++;\n\t\t} else {\n\t\t\tcnt1++;\n\t\t}\n\t}\n\tfor (int j = 0; j < n; j++) {\n\t\tp[j] = -1;\n\t}\n\tint answer = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (a[i] % 2 == 0) continue;\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tu[j] = 0;\n\t\t}\n\t\tif (ok(i)) answer++;\n\t}\n\tcout << answer + ((cnt0 - answer) / 2 + (cnt1 - answer) / 2) * 2 + ((cnt1 - answer) % 2) * 3 << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <set>\n#include <map>\n#include <list>\n#include <time.h>\n#include <math.h>\n#include <random>\n#include <deque>\n#include <queue>\n#include <cassert>\n#include <unordered_map>\n#include <iomanip>\n\nusing namespace std;\n\ntypedef long long ll;\n\nmt19937 rnd(228);\n\nconst int M = 2e7 + 7;\nconst int N = 1e2 + 1;\n\nbool prime[M];\n\nll dp[N][N][2];\n\nint get(int x)\n{\n    if (x == 0)\n    {\n        return 0;\n    }\n    if (x > 2 && prime[x])\n    {\n        return 1;\n    }\n    else\n    {\n        return 2 + (x % 2);\n    }\n}\n\nint main()\n{\n#ifdef ONPC\n    freopen(\"a.in\", \"r\", stdin);\n#endif\n    for (int i = 0; i < M; i++)\n    {\n        prime[i] = 1;\n    }\n    prime[1] = 0;\n    for (int i = 2; i < M; i++)\n    {\n        if (prime[i])\n        {\n            for (int j = i + i; j < M; j += i)\n            {\n                prime[j] = 0;\n            }\n        }\n    }\n    int n;\n    scanf(\"%d\", &n);\n    vector <int> x(n);\n    for (int i = 0; i < n; i++)\n    {\n        for (int j = 0; j < n; j++)\n        {\n            dp[i][j][0] = 1e18;\n            dp[i][j][1] = 1e18;\n        }\n    }\n    for (int i = 0; i < n; i++)\n    {\n        scanf(\"%d\", &x[i]);\n        dp[i][i][0] = 0;\n    }\n    for (int len = 1; len <= n; len++)\n    {\n        for (int l = 0; l + len - 1 < n; l++)\n        {\n            int r = l + len - 1;\n            for (int t = 0; t < 2; t++)\n            {\n                for (int j = l; j < r; j++)\n                {\n                    for (int k = j + 1; k < r; k++)\n                    {\n                        ll cost = 0;\n                        cost += dp[l][j][t];\n                        cost += dp[j + 1][k][t];\n                        cost += dp[k + 1][r][t];\n                        if (t == 0)\n                        {\n                            cost += get(x[j + 1] - x[j] - 1);\n                            cost += get(x[k + 1] - x[k] - 1);\n                        }\n                        dp[l][r][t] = min(dp[l][r][t], cost);\n                    }\n                    dp[l][r][t] = min(dp[l][r][t], dp[l][j][t] + (t == 0 ? get(x[j + 1] - x[j] - 1) : 0) + dp[j + 1][r][t]);\n                }\n            }\n            for (int t = 0; t < 2; t++)\n            {\n                dp[l][r][t] = min(dp[l][r][t], dp[l][r][t ^ 1] + get(x[r] - x[l] + 1));\n            }\n        }\n    }\n    printf(\"%lld\\n\", dp[0][n - 1][1]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long ll;\nll gi(){\n\tll x=0,f=1;\n\tchar ch=getchar();\n\twhile(!isdigit(ch))f^=ch=='-',ch=getchar();\n\twhile(isdigit(ch))x=x*10+ch-'0',ch=getchar();\n\treturn f?x:-x;\n}\nint n,A[101],B[101];\nbool yes[10000010];\nint pr[670010],P;\nint fir[210],dep[210],head[210],dis[3000010],nxt[3000010],w[3000010],id=1,S,T;\nvoid link(int a,int b,int c){\n\tnxt[++id]=fir[a],fir[a]=id,dis[id]=b,w[id]=c;\n\tnxt[++id]=fir[b],fir[b]=id,dis[id]=a,w[id]=0;\n}\nbool BFS(){\n\tstatic int que[210],hd,tl;\n\thd=tl=0;que[tl++]=S;memset(dep,0,sizeof dep);\n\tdep[S]=1;\n\twhile(hd^tl){\n\t\tint x=que[hd++];\n\t\tfor(int i=fir[x];i;i=nxt[i])\n\t\t\tif(w[i]&&!dep[dis[i]])dep[dis[i]]=dep[x]+1,que[tl++]=dis[i];\n\t}\n\treturn dep[T];\n}\nint Dinic(int x,int maxflow){\n\tif(x==T)return maxflow;\n\tint ret=0;\n\tfor(int&i=head[x];i;i=nxt[i])\n\t\tif(dep[dis[i]]==dep[x]+1&&w[i]){\n\t\t\tint d=Dinic(dis[i],std::min(w[i],maxflow-ret));\n\t\t\tw[i]-=d,w[i^1]+=d;ret+=d;if(ret==maxflow)break;\n\t\t}\n\treturn ret;\n}\nint main(){\n\tn=gi();\n\tfor(int i=1;i<=n;++i)A[i]=gi();\n\tstd::sort(A+1,A+n+1),n=std::unique(A+1,A+n+1)-A-1;\n\tA[0]=A[n+1]=-1;\n\tint m=0;\n\tfor(int i=1;i<=n;++i){\n\t\tif(A[i]!=A[i-1]+1)B[++m]=A[i]-1;\n\t\tif(A[i]!=A[i+1]-1)B[++m]=A[i];\n\t}\n\tS=m+1,T=m+2;\n\tint odd=0,even=0;\n\tfor(int i=1;i<=m;++i)if(B[i]&1)++odd,link(S,i,1);else++even,link(i,T,1);\n\tfor(int i=2;i<=A[n];++i){\n\t\tif(!yes[i])pr[++P]=i;\n\t\tfor(int j=1;j<=P&&i*pr[j]<=A[n];++j){\n\t\t\tyes[i*pr[j]]=1;\n\t\t\tif(i%pr[j]==0)break;\n\t\t}\n\t}\n\tyes[0]=yes[1]=yes[2]=1;\n\tfor(int i=1;i<=m;++i)if(B[i]&1)\n\t\tfor(int j=1;j<=m;++j)\n\t\t\tif(!yes[abs(B[j]-B[i])])\n\t\t\t\tlink(i,j,1);\n\tint ans=0;while(BFS())memcpy(head,fir,sizeof fir),ans+=Dinic(S,1e9);\n\tprintf(\"%d\\n\",ans+2*((odd-ans>>1)+(even-ans>>1))+3*(odd-ans&1));\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nbool bo[10000010];\nint f[1010][2010],n,a[1010];\n\nint calc(int x) {return (x==0)?0:((x&1)?(bo[x]?3:1):2);}\n\nint main()\n{\n\tbo[1]=1;\n\tfor (int i=2; i<=10000000; i++) if (!bo[i])\n\t\tfor (int j=(i<<1); j<=10000000; j+=i) bo[j]=1;\n\tscanf(\"%d\",&n);\n\tfor (int i=1; i<=n; i++) scanf(\"%d\",&a[i]);\n\tfor (int i=0; i<=n; i++)\n\t\tfor (int j=0; j<=2*n+1; j++) f[i][j]=1000000000;\n\tsort(a+1,a+1+n),f[1][0]=0,f[1][1]=3;\n\tfor (int i=2; i<=n; i++)\n\t{\n\t\tfor (int j=0; j<=2*i-3; j++)\n\t\t\tf[i][j]=min(f[i][j],f[i-1][j]+calc(a[i]-a[i-1]-1)),\n\t\t\tf[i][i*2-2]=min(f[i][i*2-2],f[i-1][j]+calc(a[i-1]-a[1+(j>>1)]+(1^(j&1)))),\n\t\t\tf[i][i*2-1]=min(f[i][i*2-1],f[i-1][j]+calc(a[i]-a[i-1]-1)+calc(a[i]-a[1+(j>>1)]+(1^(j&1)))),\n\t\t\tf[i][i*2-1]=min(f[i][i*2-1],f[i-1][j]+calc(a[i]-a[i-1])+calc(a[i]-a[1+(j>>1)]+(1^(j&1))-1));\n\t\tf[i][i*2-1]=min(f[i][i*2-1],f[i][i*2-2]+3);\n\t}\n\tprintf(\"%d\\n\",f[n][n*2-1]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/**\n *    author:  tourist\n *    created: 20.11.2019 08:57:54       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  const int N = (int) 1e7 + 10;\n  vector<bool> prime(N, true);\n  for (int i = 2; i < N; i++) if (prime[i]) for (int j = i + i; j < N; j += i) prime[j] = false;\n  prime[1] = false;\n  int n;\n  cin >> n;\n  vector<int> a(n);\n  for (int i = 0; i < n; i++) cin >> a[i];\n  vector<int> s(1, 1);\n  for (int i = 1; i < n; i++)\n    if (a[i] == a[i - 1] + 1) s.back() += 1;\n    else { s.push_back(a[i] - a[i - 1] - 1); s.push_back(1); }\n  n = (int) s.size();\n  vector<vector<int>> dp(n, vector<int>(n));\n  for (int i = n - 1; i >= 0; i--) {\n    for (int j = i; j < n; j += 2) {\n      int ss = accumulate(s.begin() + i, s.begin() + j + 1, 0);\n      dp[i][j] = (ss % 2 == 0 ? 2 : (prime[ss] ? 1 : 3)) + (i < j ? dp[i + 1][j - 1] : 0);\n      for (int k = i; k < j; k += 2) dp[i][j] = min(dp[i][j], dp[i][k] + dp[k + 2][j]);\n    } \n  }\n  cout << dp[0][n - 1] << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nconst int MAXP = 510;\nconst int MAXM = MAXP * MAXP * 10;\nconst int INF = 0x3f3f3f3f;\nint head[MAXP], nxt[MAXM], to[MAXM], val[MAXM], tot = 1;\nvoid addedge(int b, int e, int v) {\n\tnxt[++tot] = head[b]; to[head[b] = tot] = e; val[tot] = v;\n\tnxt[++tot] = head[e]; to[head[e] = tot] = b; val[tot] = 0;\n}\nstd::queue<int> q;\nint dis[MAXP];\nint S, T, idx;\nbool bfs() {\n\tmemset(dis, 0, idx + 1 << 2);\n\tq.push(S); dis[S] = 1;\n\twhile (!q.empty()) {\n\t\tint t = q.front(); q.pop();\n\t\tfor (int i = head[t]; i; i = nxt[i])\n\t\t\tif (val[i] && !dis[to[i]]) {\n\t\t\t\tdis[to[i]] = dis[t] + 1;\n\t\t\t\tq.push(to[i]);\n\t\t\t}\n\t}\n\treturn dis[T] > 0;\n}\nint dinic(int u, int minv) {\n\tif (u == T || !minv) return minv;\n\tint t, res = 0;\n\tfor (int & i = head[u]; i; i = nxt[i])\n\t\tif (val[i] && dis[to[i]] == dis[u] + 1 && (t = dinic(to[i], std::min(minv, val[i])))) {\n\t\t\tval[i] -= t;\n\t\t\tval[i ^ 1] += t;\n\t\t\tres += t;\n\t\t\tminv -= t;\n\t\t\tif (!minv) break;\n\t\t}\n\tif (!res) dis[u] = -1;\n\treturn res;\n}\nint flow() {\n\tstatic int es[MAXP];\n\tmemcpy(es, head, idx + 1 << 2);\n\tint res = 0;\n\twhile (bfs()) {\n\t\tres += dinic(S, INF);\n\t\tmemcpy(head, es, idx + 1 << 2);\n\t}\n\treturn res;\n}\n\nint A[MAXP], n;\nbool ispri(int x) {\n\tif (x < 2) return false;\n\tfor (int i = 2; i * i <= x; ++i) if (x % i == 0) return false;\n\treturn true;\n}\nstd::map<int, int> M;\nint main() {\n\tstd::ios_base::sync_with_stdio(false), std::cin.tie(0);\n\tstd::cin >> n;\n\tfor (int i = 1, t; i <= n; ++i) std::cin >> t, ++M[t], ++M[t + 1];\n\tn = 0;\n\tfor (auto t : M) if (t.second & 1) A[++n] = t.first;\n\tS = 0, T = idx = n + 1;\n\tfor (int i = 1; i <= n; ++i)\n\t\tif (A[i] & 1) {\n\t\t\taddedge(S, i, 1);\n\t\t\tfor (int j = 1; j <= n; ++j)\n\t\t\t\tif ((~A[j] & 1) && ispri(std::abs(A[i] - A[j])))\n\t\t\t\t\taddedge(i, j, 1);\n\t\t} else addedge(i, T, 1);\n\tint ans = flow();\n\tint c0 = 0, c1 = 0;\n\tfor (int i = 1; i <= n; ++i)\n\t\tif (A[i] & 1) {\n\t\t\tfor (int j = head[i]; j; j = nxt[j])\n\t\t\t\tif (to[j] == S)\n\t\t\t\t\tc0 += val[j] == 0;\n\t\t} else {\n\t\t\tfor (int j = head[i]; j; j = nxt[j])\n\t\t\t\tif (to[j] == T)\n\t\t\t\t\tc1 += val[j] == 1;\n\t\t}\n\tans += (c0 / 2 + c1 / 2) * 2;\n\tans += (c0 & 1) * 3;\n\tstd::cout << ans << std::endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, b) for (int i = (a); i <= (b); ++i)\n#define per(i, a, b) for (int i = (a); i >= (b); --i)\n#define pb push_back\n#define mp make_pair\n#define pr pair<int, int>\n#define x first\n#define y second\nusing namespace std;\n\ntemplate<typename T>\nvoid read(T& n){\n\tchar ch; int sign = 1;\n\twhile (!isdigit(ch = getchar())) if (ch == '-') sign = -1;\n\tn = ch - '0';\n\twhile (isdigit(ch = getchar())) n = n * 10 + ch - '0';\n\tn *= sign;\n}\ntypedef long long ll;\nconst int INF = 1e9 + 7;\nconst int N = 222;\nint n, mx, mark, x;\nint cnt[12222222], match[N], vis[N];\nvector<int> v[2];\nstruct edge{int to, nxt;} g[N*N*4];\nint ghead[N], gtail(0);\n\nvoid add(int l, int r){g[++gtail] = (edge){r, ghead[l]}, ghead[l] = gtail;}\nbool oddprime(int x){\n\trep(i, 2, sqrt(x)) if (x % i == 0) return false;\n\treturn x > 2;\n}\nbool find(int x){\n\tvis[x] = mark;\n\tfor (int p = ghead[x]; p; p = g[p].nxt){\n\t\tint v = g[p].to; if (vis[match[v]] == mark) continue;\n\t\tif (!match[v]||find(match[v])){\n\t\t\tmatch[v] = x; return true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint main(){\n\tread(n);\n\trep(i, 1, n) read(x), cnt[x] = 1, mx = max(mx, x);\n\trep(i, 1, mx + 1) if (cnt[i] ^ cnt[i-1]) v[i%2].pb(i);\n\tint s0 = v[0].size(), s1 = v[1].size();\n\trep(i, 1, s0) rep(j, 1, s1)\n\t\tif (oddprime(abs(v[0][i-1] - v[1][j-1])))\n\t\t\tadd(i, s0 + j);\n\tint ans = 0;\n\trep(i, 1, s0) {mark++; if (find(i)) ans++;}\n\tprintf(\"%d\\n\", ans + ((s0 - ans) / 2 + (s1 - ans) / 2) * 2 + (s0 - ans) % 2 * 3);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 200\n#define M 10000000\nusing namespace std;\n\ninline int read()\n{\n\tint x=0,f=1; char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1; ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0'; ch=getchar();}\n\treturn x*f;\n}\nint n,A[N],B[N],a[M+10],pri[M];\nint mps[N][N],lk[N],vis[N];\nmap<int,int> Ms;\ninline int find(int x)\n{\n\tfor(int i=1;i<=B[0];i++) if(!vis[i]&&mps[x][i])\n\t{\n\t\tvis[i]=1; if(!lk[i]||find(lk[i]))\n\t\t{\n\t\t\tlk[i]=x; return 1;\n\t\t}\n\t}\n\treturn 0;\n}\nint main()\n{\n\ta[1]=1; for(int i=2;i<=M;i++)\n\t{\n\t\tif(!a[i]) pri[++pri[0]]=i;\n\t\tfor(int j=1;j<=pri[0]&&pri[j]*i<=M;j++)\n\t\t{\n\t\t\ta[pri[j]*i]=1; if(i%pri[j]==0) break;\n\t\t}\n\t}\n\tn=read();\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint x=read(); Ms[x]^=1; Ms[x+1]^=1;\n\t}\n\tmap<int,int> ::iterator it=Ms.begin();\n\tfor(;it!=Ms.end();it++) if(it->second)\n\t{\n\t\tif(it->first&1) A[++A[0]]=it->first;\n\t\telse B[++B[0]]=it->first;\n\t}\n\tfor(int i=1;i<=A[0];i++) for(int j=1;j<=B[0];j++)\n\t\tif(!a[abs(A[j]-B[j])]) mps[i][j]=1;\n\tint ct=0; for(int i=1;i<=A[0];i++)\n\t\tmemset(vis,0,sizeof vis),ct+=find(i);\n\tcout << ct+((A[0]-ct)/2+(B[0]-ct)/2)*2+(A[0]-ct)%2*3 << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn=105;\nint n,a[maxn],cnt[2],match[maxn<<1];\nbool used[maxn<<1];\nvector<int> G[maxn<<1],diff;\nset<int> vis;\nbool dfs(int v) {\n    used[v]=1;\n    for (int i=0;i<(int)G[v].size();++i) {\n        int u=G[v][i],w=match[u];\n        if (!w||(!used[w]&&dfs(w))) {\n            match[v]=u;\n            match[u]=v;\n            return true;\n        }\n    }\n    return false;\n}\ninline int bipartite_matching() {\n    int ret=0;\n    for (int i=0;i<(int)diff.size();++i)\n        if (!match[i]) {\n            memset(used,0,sizeof used);\n            ret+=dfs(i);\n        }\n    return ret;\n}\nbool check(int x) {\n    if (x<=2)\n        return false;\n    for (int i=2;i*i<=x;++i)\n        if (x%i==0)\n            return false;\n    return true;\n}\nint main()\n{\n    scanf(\"%d\",&n);\n    for (int i=1;i<=n;++i) {\n        scanf(\"%d\",&a[i]);\n        vis.insert(a[i]);\n    }\n    for (int i=1;i<=n;++i) {\n        if (vis.find(a[i]-1)==vis.end()) {\n            diff.push_back(a[i]);\n            ++cnt[a[i]%2];\n        }\n        if (vis.find(a[i]+1)==vis.end()) {\n            diff.push_back(a[i]+1);\n            ++cnt[(a[i]+1)%2];\n        }\n    }\n    for (int i=0;i<(int)diff.size();++i)\n        for (int j=i+1;j<(int)diff.size();++j)\n            if (check(abs(diff[i]-diff[j]))) {\n                G[i].push_back(j);\n                G[j].push_back(i);\n            }\n    int k=bipartite_matching();\n    printf(\"%d\\n\",k+2*((cnt[0]-k)/2+(cnt[1]-k)/2)+3*(cnt[0]-k)%2*3);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <cmath>\n#include <cstring>\nconst int maxP = 1e7;\nconst int maxn = 205;\nconst int S = 0;\nconst int T = 204;\nusing namespace std;\nvector <int> p; bool isp[maxP + 5];\nvoid install(){\n\tisp[1] = 1;\n\tfor (int i = 2; i <= maxP; i++){\n\t\tif (!isp[i]) p.push_back(i);\n\t\tfor (int j = 0; j < p.size() && i * p[j] <= maxP; j++){\n\t\t\tisp[i * p[j]] = 1;\n\t\t\tif (i % p[j] == 0) break;\n\t\t}\n\t}\n}\nstruct E{\n\tint to, nxt;\n}e[maxn * maxn];\nint head[maxn], tot = 1;\nvoid addedge(int u, int v){\n\te[++tot].to = v, e[tot].nxt = head[u];\n\thead[u] = tot;\n}\nint mat[maxn]; bool vis[maxn];\nbool dfs(int cur){\n\tfor (int i = head[cur]; i; i = e[i].nxt){\n\t\tint v = e[i].to;\n\t\tif (vis[v]) continue;\n\t\tvis[v] = 1;\n\t\tif (!mat[v] || dfs(mat[v])){\n\t\t\tmat[v] = cur; mat[cur] = v;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\nvector <int> x[2]; int n, c[maxP + 5];\nint main(){\n\tinstall();\n\tscanf(\"%d\", &n);\n\tfor (int a, i = 1; i <= n; i++){\n\t\tscanf(\"%d\", &a); c[a]++;\n\t}\n\tfor (int i = 1; i <= maxP + 1; i++)\n\t\tif (c[i] != c[i - 1]) x[i & 1].push_back(i);\n\tfor (int i = 0; i < x[0].size(); i++)\n\t\tfor (int j = 0; j < x[1].size(); j++)\n\t\t\tif (!isp[abs(x[1][j] - x[0][i])]) addedge(i, j + x[0].size());\n\tint flow = 0;\n\tfor (int i = 0; i < x[0].size() + x[1].size(); i++){\n\t\tif (!mat[i]){\n\t\t\tmemset(vis, 0, sizeof vis);\n\t\t\tflow += dfs(i);\n\t\t}\n\t}\n\tprintf(\"%d\\n\", flow + (x[0].size() - flow) / 2 * 2 + (x[1].size() - flow) / 2 * 2 + (x[0].size() - flow) % 2 * 3);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nstruct edge {\n\tint to, cap, rev;\n};\n\nvector<edge>X[1009]; bool used[1009];\n\nvoid add_edge(int u, int v, int w) {\n\tX[u].push_back(edge{ v,w,(int)X[v].size() });\n\tX[v].push_back(edge{ u,0,(int)X[u].size() - 1 });\n}\nint dfs(int pos, int to, int flow) {\n\tif (pos == to) return flow;\n\tused[pos] = true;\n\tfor (int i = 0; i < X[pos].size(); i++) {\n\t\tif (used[X[pos][i].to] == true || X[pos][i].cap <= 0) continue;\n\t\tint G = dfs(X[pos][i].to, to, min(X[pos][i].cap, flow));\n\t\tif (G == 0) continue;\n\t\tX[pos][i].cap -= G;\n\t\tX[X[pos][i].to][X[pos][i].rev].cap += G;\n\t\treturn G;\n\t}\n\treturn 0;\n}\nint max_flow(int s, int t) {\n\tint F = 0;\n\twhile (true) {\n\t\tfor (int i = 0; i <= 500; i++) used[i] = false;\n\t\tint fl = dfs(s, t, 1000000007);\n\t\tif (fl == 0) break;\n\t\tF += fl;\n\t}\n\treturn F;\n}\n\nint n, x[109], g[10000009]; bool prime[10000009]; vector<int>J;\n\nint main() {\n\t// 2 は合成数2 は合成数2 は合成数2 は合成数2 は合成数2 は合成数2 は合成数2 は合成数2 は合成数2 は合成数2 は合成数2 は合成数2 は合成数2 は合成数2 は合成数2 は合成数2 は合成数2 は合成数2 は合成数2 は合成数2 は合成数2 は合成数2 は合成数2 は合成数2 は合成数\n\tfor (int i = 3; i <= 10000008; i++) prime[i] = true;\n\tfor (int i = 2; i*i <= 10000008; i++) {\n\t\tfor (int j = i*i; j <= 10000008; j += i) prime[j] = false;\n\t}\n\tcin >> n;\n\tfor (int i = 1; i <= n; i++) { cin >> x[i]; g[x[i]] ^= 1; g[x[i] + 1] ^= 1; }\n\tfor (int i = 1; i <= 10000002; i++) { if (g[i] >= 1) J.push_back(i); }\n\tfor (int i = 0; i < J.size(); i++) {\n\t\tfor (int j = i + 1; j < J.size(); j++) {\n\t\t\tif (prime[J[j] - J[i]] == true) {\n\t\t\t\tif (J[i] % 2 == 1) add_edge(i, j, 1);\n\t\t\t\telse add_edge(j, i, 1);\n\t\t\t}\n\t\t}\n\t}\n\tint kisuu = 0, gusuu = 0;\n\tfor (int i = 0; i < J.size(); i++) {\n\t\tif (J[i] % 2 == 1) {\n\t\t\tadd_edge(J.size(), i, 1);\n\t\t\tkisuu++;\n\t\t}\n\t\telse {\n\t\t\tadd_edge(i, J.size() + 1, 1);\n\t\t\tgusuu++;\n\t\t}\n\t}\n\tint res = max_flow(J.size(), J.size() + 1);\n\tint V1 = res, V2 = (kisuu - res) / 2 + (gusuu - res) / 2, V3 = (J.size() / 2 - V1 - V2);\n\tcout << V1 * 1 + V2 * 2 + V3 * 3 << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=(a);i<=(b);i++)\n#define per(i,a,b) for(int i=(a);i>=(b);i--)\n#define forE(i,x) for(int i=head[x];i!=-1;i=ne[i])\nusing namespace std;\ntypedef long long i64;\ntypedef unsigned long long u64;\ntypedef unsigned u32;\ntypedef pair<int,int> pin;\n#define mk(a,b) make_pair(a,b)\n#define lowbit(x) ((x)&(-(x)))\n#define sqr(a) ((a)*(a))\n#define clr(a) (memset((a),0,sizeof(a)))\n#define ls ((x)<<1)\n#define rs (((x)<<1)|1)\n#define mid (((l)+(r))>>1)\n#define pb push_back\n#define w1 first\n#define w2 second\ninline void read(int &x){\n\tx=0;int f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\tx*=f;\n}\ninline void judge(){\n\tfreopen(\"in.txt\",\"r\",stdin);\n\tfreopen(\"out.txt\",\"w\",stdout);\n}\n/*******************************head*******************************/\nconst int maxn=305;\nint head[maxn],t[maxn*maxn<<1],ne[maxn*maxn<<1],sap[maxn*maxn<<1],m,S,T,d[maxn],num;\nint cur[maxn],cnt[maxn],his[maxn],edge[maxn],pre[maxn];\nconst int inf=1e9;\ninline void addedge(int x,int y,int z){\n\tne[++num]=head[x];head[x]=num;t[num]=y;sap[num]=z;\n\tne[++num]=head[y];head[y]=num;t[num]=x;sap[num]=0;\n}\ninline int isap(){\n\trep(i,1,T)cur[i]=head[i],d[i]=0,cnt[i]=0;\n\tcnt[0]=T;\n\tint i=S,aug=inf,ans=0,minnum,jl;\n\twhile(d[S]<T){\n\t\tbool flag=0;his[i]=aug;for(int j=cur[i];j!=-1;j=ne[j])if(d[t[j]]+1==d[i]&&sap[j]){\n\t\t\tcur[i]=j;edge[i]=j;pre[t[j]]=i;aug=min(aug,sap[j]);flag=1;i=t[j];\n\t\t\tif(i==T){\n\t\t\t\tans+=aug;\n\t\t\t\twhile(i!=S){i=pre[i];sap[edge[i]]-=aug;sap[edge[i]^1]+=aug;}\n\t\t\t\taug=inf;\n\t\t\t}break;\n\t\t}if(flag)continue;minnum=T;forE(j,i)if(sap[j]&&d[t[j]]<minnum)minnum=d[t[j]],jl=j;\n\t\tif(--cnt[d[i]]==0)return ans;cnt[d[i]=minnum+1]++;cur[i]=jl;\n\t\tif(i!=S){i=pre[i];aug=his[i];}\n\t}return ans;\n}\nbool flag[10000005];\nint prime[1000005],n,tot;\ninline void prprpr(){\n\tmemset(flag,1,sizeof(flag));\n\trep(i,2,10000000){\n\t\tif(flag[i])prime[++tot]=i;\n\t\trep(j,1,tot){\n\t\t\tif(i*prime[j]>10000000)break;\n\t\t\tflag[i*prime[j]]=0;\n\t\t\tif(i%prime[j]==0)break;\n\t\t}\n\t}\n}\nint a[205],b[205],idx;\nint p[205],q[205];\nint cntp,cntq;\ninline void insert(int x){\n\tif(x&1)\n\t\tp[++cntp]=x;\n\telse\n\t\tq[++cntq]=x;\n}\ninline bool is_prime(int x,int y){\t\n\tif(x<y)swap(x,y);\n\treturn flag[x-y];\n}\t\nint main(){\n\tprprpr();\n\tread(n);\n\trep(i,1,n)read(a[i]);a[0]=-100;\n\trep(i,1,n){\n\t\tif(a[i]-1!=a[i-1])b[++idx]=a[i];\n\t\tif(a[i]+1!=a[i+1])b[++idx]=a[i]+1;\n\t}flag[2]=0;flag[1]=0;\n\trep(i,1,idx)insert(b[i]);\n\tS=cntp+cntq+1;T=cntp+cntq+2;\n\trep(i,1,T)head[i]=-1;num=1;\n\trep(i,1,cntp)addedge(S,i,1);\n\trep(i,cntp+1,cntp+cntq)addedge(i,T,1);\n\trep(i,1,cntp)rep(j,1,cntq)if(is_prime(p[i],q[j]))\n\t\taddedge(i,j+cntp,1);\n\tprintf(\"%d\\n\",cntp+cntq-(isap()-(cntp&1)>>1<<1)-(cntp&1));\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <cstdio>\n#include <cmath>\nusing namespace std;\n\nconst int MaxN = 100;\nconst int MaxM = 10000000;\nconst int MaxNV = MaxN * 2;\n\nint n;\nbool f[MaxM + 2];\n\nint nL, qL[MaxNV + 1];\nint nR, qR[MaxNV + 1];\n\nbool mat[MaxNV + 1][MaxNV + 1];\n\nbool bookR[MaxNV + 1];\nint mateR[MaxNV + 1];\n\nint pri_n, pri[MaxM / 8];\nbool book[MaxM + 2];\n\ninline void init_sieve(int n = MaxM + 1)\n{\n\tbook[1] = true;\n\tfor (int i = 2; i <= n; ++i)\n\t{\n\t\tif (!book[i])\n\t\t\tpri[pri_n++] = i;\n\n\t\tfor (int j = 0; j < pri_n; ++j)\n\t\t{\n\t\t\tint p = pri[j], d = i * p;\n\t\t\tif (d > n)\n\t\t\t\tbreak;\n\t\t\tbook[d] = true;\n\n\t\t\tif (i % p == 0)\n\t\t\t\tbreak;\n\t\t}\n\t}\n}\n\nbool match(const int &u)\n{\n\tfor (int v = 1; v <= nR; ++v)\n\t\tif (mat[u][v] && !bookR[v])\n\t\t{\n\t\t\tbookR[v] = true;\n\t\t\tif (!mateR[v] || match(mateR[v]))\n\t\t\t{\n\t\t\t\tmateR[v] = u;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\treturn false;\n}\n\nint main()\n{\n\tinit_sieve();\n\n\tcin >> n;\n\tfor (int i = 0, x; i < n; ++i)\n\t{\n\t\tcin >> x;\n\t\tf[x] = true;\n\t}\n\n\tnL = nR = 0;\n\tfor (int i = 1; i <= MaxM + 1; ++i)\n\t\tif (f[i] != f[i - 1])\n\t\t{\n\t\t\tif (i & 1)\n\t\t\t\tqL[++nL] = i;\n\t\t\telse\n\t\t\t\tqR[++nR] = i;\n\t\t}\n\n\tfor (int i = 1; i <= nL; ++i)\n\t\tfor (int j = 1; j <= nR; ++j)\n\t\t\tif (!book[abs(qL[i] - qR[j])])\n\t\t\t\tmat[i][j] = true;\n\n\tint n_matches = 0;\n\tfor (int u = 1; u <= nL; ++u)\n\t{\n\t\tfor (int v = 1; v <= nR; ++v)\n\t\t\tbookR[v] = false;\n\n\t\tn_matches += match(u);\n\t}\n\n\tint res = n_matches;\n\tres += (nL - n_matches >> 1) << 1;\n\tres += (nR - n_matches >> 1) << 1;\n\tres += 3 * ((nL ^ n_matches) & 1);\n\n\tcout << res << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <complex>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <limits>\n#include <climits>\n#include <cfloat>\n#include <functional>\n#include <iterator>\nusing namespace std;\n\nvoid findPrime(int N, vector<bool>& isPrime)\n{\n    isPrime.assign(N+1, true);\n    isPrime[0] = isPrime[1] = false;\n    for(int i=2; i*i<=N; i++){\n        if(isPrime[i]){\n            for(int j=i; i*j<=N; j++){\n                isPrime[i*j] = false;\n            }\n        }\n    }\n}\n\nconst int MAX = 10000000;\nconst int INF = INT_MAX / 2;\n\nint n;\nvector<int> x;\nvector<bool> isPrime;\nvector<vector<int> > memo;\n\nint getCost(int len)\n{\n    if(len == 0)\n        return 0;\n    else if(len >= 3 && isPrime[len])\n        return 1;\n    else if(len % 2 == 0)\n        return 2;\n    else\n        return 3;\n}\n\nint solve(int a, int b)\n{\n    if(a == n)\n        return 0;\n    if(memo[a][b] != -1)\n        return memo[a][b];\n\n    int len = 1;\n    if(b != 0)\n        len = x[a] - x[a-1];\n\n    int ans = INT_MAX;\n    int sum = 0;\n    for(int i=a; i<n; ++i){\n        int cost1 = sum + getCost(len) + solve(i+1, 0);\n        ans = min(ans, cost1);\n        if(i < n - 1){\n            len += x[i+1] - x[i] - 1;\n            int cost2 = sum + getCost(len) + solve(i+1, 1);\n            ans = min(ans, cost2);\n            ++ len;\n            sum += getCost(x[i+1] - x[i] - 1);\n        }\n    }\n\n    return memo[a][b] = ans;\n}\n\nint main()\n{\n    findPrime(MAX, isPrime);\n\n    cin >> n;\n    x.resize(n);\n    for(int i=0; i<n; ++i)\n        cin >> x[i];\n\n    memo.assign(n, vector<int>(2, -1));\n    cout << solve(0, 0) << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <bitset>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio>\n#include <cstring>\n#include <climits>\n#include <string.h>\n#include <stdio.h>\n#define LL long long\n#define all(x) (x).begin(),(x).end()\n#define pii pair<int,int>\n#define piii pair<int, pii >\n#define REP(i,n) for (int (i)=0;(i)<(n);(i)++)\n#define vi vector<int>\n#define vpi vector< pii >\n#define INF 2147483647\n#define big 19260817\n#define pb push_back\n#define mp make_pair\nusing namespace std;\nconst int Maxk=1005;\nstring mul(string a,string b){\n\tint res[Maxk];\n\tmemset(res,0,sizeof(res));\n\treverse(a.begin(),a.end());\n\treverse(b.begin(),b.end());\n\tfor (int i=0;i<a.length();i++){\n\t\tfor (int j=0;j<b.length();j++){\n\t\t\tres[i+j]+=(a[i]-'0')*(b[j]-'0');\n\t\t}\n\t}\n\tfor (int i=0;i<Maxk;i++){\n\t\tif (res[i]>=10) {\n\t\t\tres[i+1]+=(res[i]/10);\n\t\t\tres[i]%=10;\n\t\t}\n\t}\n\tstring ret;\n\tbool flag=false;\n\tfor (int i=Maxk-1;i>=0;i--){\n\t\tif (flag || res[i]){\n\t\t\tflag=true;\n\t\t\tret=ret+(char)(res[i]+'0');\n\t\t}\n\t}\n\tif (ret==\"\") ret=\"0\";\n\treturn ret;\n}\nstring add(string a,string b){\n\tif (a.length()<b.length()) swap(a,b);\n\twhile (a.length()!=b.length()){\n\t\tb='0'+b;\n\t}\n\tfor (int i=a.length()-1;i>=0;i--){\n\t\ta[i]+=(b[i]-'0');\n\t\tif (a[i]>'9' && i){\n\t\t\ta[i]-=10;\n\t\t\ta[i-1]++;\n\t\t}\n\t}\n\tif (a[0]>'9'){\n\t\ta[0]-=10;\n\t\ta='1'+a;\n\t}\n\treturn a;\n}\n\n// cf IO: I64d\n// atcoder IO: ｌｌｄ\ninline int read()\n{\n\tint x = 0, f = 1; char ch = getchar();\n\twhile (ch < '0' || ch > '9') { if (ch == '-') f = -1; ch = getchar(); }\n\twhile (ch >= '0' && ch <= '9') { x = x * 10 + ch - '0'; ch = getchar(); }\n\treturn x * f;\n}\nconst int Maxn=305;\nconst int Maxm=1e7+5;\nint cnt;\nint pos[Maxn],len[Maxn];\nint dp[Maxn][Maxn][2];\nbool isp[Maxm];\nvoid _init(){\n\tmemset(isp,true,sizeof(isp));\n\tisp[1]=isp[0]=false;\n\tfor (int i=2;i<Maxm;i++){\n\t\tif (isp[i]){\n\t\t\tfor (int j=i+i;j<Maxm;j+=i){\n\t\t\t\tisp[j]=false;\n\t\t\t}\n\t\t}\n\t}\n}\nint cost(int len){\n\tif (!len) return 0;\n\tif (len%2==0) return 2;\n\tif (isp[len]) return 1;\n\treturn 3;\n}\nint main(){\n\t_init();//cerr<<123<<endl;\n\tint n;\n\tscanf(\"%d\",&n);\n\tfor (int i=0;i<n;i++){\n\t\tscanf(\"%d\",&pos[i]);\n\t}\n\tint sum=1;\n\tfor (int i=1;i<n;i++){\n\t\tif (pos[i]==pos[i-1]+1) sum++;\n\t\telse{\n\t\t\tlen[++cnt]=sum;\n\t\t\tlen[++cnt]=pos[i]-pos[i-1]-1;\n\t\t\tsum=1;\n\t\t}\n\t}\n\tlen[++cnt]=sum;\n\tfor (int i=1;i<=cnt;i++){\n\t\tdp[i][i][0]=0;\n\t\tdp[i][i][1]=cost(len[i]);\n\t}\n\t//cout<<cnt<<endl;\n\tfor (int Len=2;Len<=cnt;Len++){\n\t\tfor (int i=1;i<=cnt;i++){\n\t\t\tint j=i+Len-1;\n\t\t\tif (j>cnt) continue;\n\t\t\tint totlen=0;\n\t\t\tfor (int k=i;k<=j;k++) totlen+=len[k];\n\t\t\tdp[i][j][0]=min(dp[i+1][j-1][1],dp[i+1][j-1][0]+cost(len[i])+cost(len[j])+cost(totlen));\n\t\t\tdp[i][j][1]=min(dp[i+1][j-1][0]+cost(len[i])+cost(len[j]),dp[i+1][j-1][1]+cost(totlen));\n\t\t}\n\t}\n\tprintf(\"%d\\n\",dp[1][cnt][1]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef unsigned long long int ull;\ntypedef long long int ll;\ntypedef pair<ll,ll> pll;\ntypedef long double D;\ntypedef complex<D> P;\n#define F first\n#define S second\nconst ll MOD=1000000007;\n//const ll MOD=998244353;\n\ntemplate<typename T,typename U>istream & operator >> (istream &i,pair<T,U> &A){i>>A.F>>A.S; return i;}\ntemplate<typename T>istream & operator >> (istream &i,vector<T> &A){for(auto &I:A){i>>I;} return i;}\ntemplate<typename T,typename U>ostream & operator << (ostream &o,const pair<T,U> &A){o<<A.F<<\" \"<<A.S; return o;}\ntemplate<typename T>ostream & operator << (ostream &o,const vector<T> &A){ll i=A.size(); for(auto &I:A){o<<I<<(--i?\" \":\"\");} return o;}\n\ntemplate <typename WeightType, typename TotalWeightType=int64_t>\nclass MaximumWeightedMatching {\n  /*\n  Maximum Weighted Matching in General Graphs\n  - O(n^3) time\n  - O(n + m) space\n  Note: each vertex is 1-indexed.\n  */\npublic:\n  using weight_t = WeightType;\n  using total_weight_t = TotalWeightType;\n  struct Edge { int from, to; weight_t weight; };\n\nprivate:\n  enum TreeLabelNumber { INNER = -1, UNUSED = 0, OUTER = 1 };\n  enum LabelNumber { SEPARATED = -2, DEFAULT = -1 };\n  enum EdgeNumber { UNDEFINED = 1 << 30 };\n  static constexpr weight_t INF = weight_t(1) << (sizeof(weight_t) * 8 - 2);\n  struct Node { int next, from, to; };\n  struct Label { int from, to; };\n  class Queue {\n  public:\n    Queue() {}\n    Queue(int N) : que(N), qh(0), qt(0) {}\n    void clear() { qh = qt = 0; }\n    int* data() { return que.data(); }\n    bool empty() const { return qh == qt; }\n    int dequeue() { return que[qh++]; }\n    void enqueue(int u) { que[qt++] = u; }\n    int operator [] (int i) const { return que[i]; }\n    int size() const { return qt; }\n\n    vector<int> que;\n    int qh, qt;\n  };\n\npublic:\n  MaximumWeightedMatching(int N, const vector<Edge>& raw_edges) \n      : N(N), B((N - 1) / 2), size(N + B + 1) {\n\n    ofs.assign(N + 2, 0);\n    for (auto& e : raw_edges) {\n      ofs[e.from + 1]++;\n      ofs[e.to + 1]++;\n    }\n    for (int i = 1; i <= N; ++i) ofs[i] += ofs[i - 1];\n    edges.resize(raw_edges.size() * 2);\n    for (int i = 0; i < (int) raw_edges.size(); ++i) {\n      auto& e = raw_edges[i];\n      edges[ofs[e.from]++] = {e.from, e.to, 2 * e.weight};\n      edges[ofs[e.to]++] = {e.to, e.from, 2 * e.weight};\n    }\n    for (int i = 0; i <= N; ++i) ofs[N + 1 - i] = ofs[N - i];\n    ofs[0] = 0;\n  }\n\n  total_weight_t maximum_weighted_matching() {\n    initialize();\n    set_potential();\n    for (int u = 1; u <= N; ++u) if (!mate[u]) {\n      for (int s = 0; !augmented(u, s); s = adjust_dual_solutions());\n      fix_blossom_bases();\n      clear_label();\n    }\n    total_weight_t ret = 0;\n    for (int u = 1; u <= N; ++u) if (mate[u] > u) {\n      weight_t max_w = 0;\n      for (int eid = ofs[u]; eid < ofs[u + 1]; ++eid) {\n        if (edges[eid].to == mate[u]) max_w = max(max_w, edges[eid].weight);\n      }\n      ret += max_w;\n    }\n    return ret >> 1;\n  }\n\nprivate:\n  inline int encode(int e) const {\n    return e + size + 1; // should be >= 3\n  }\n\n  inline weight_t reduced_cost(int u, int v, const Edge& e) const {\n    return potential[u] + potential[v] - e.weight;\n  }\n\n  inline weight_t reduced_cost(int eid) const {\n    return reduced_cost(edges[eid].from, edges[eid].to, edges[eid]);\n  }\n\n  void rematch(int v, int w) {\n    auto t = mate[v]; mate[v] = w;\n    if (mate[t] != v) return;\n    if (label[v].to == 0) {\n      mate[t] = label[v].from;\n      rematch(mate[t], t);\n    } else {\n      int x = label[v].from, y = label[v].to;\n      rematch(x, y); rematch(y, x);\n    }\n  }\n\n  Label search_blossom_edge(int bid) const {\n    int b = base[bid], bv = b;\n    for (; node[bv].next != b; bv = node[node[bv].next].next);\n    return {node[bv].from, node[bv].to};\n  }\n\n  void label_blossom(int bid, int m, Label l) {\n    label[bid] = {l.from, (l.to == surface[l.to]) ? 0 : l.to};\n    if (bid <= N) return;\n    int b = base[bid]; label_blossom(b, mate[bid] = m, l);\n    l = search_blossom_edge(bid);\n    for (int bv = b, bw; node[bv].next != b; bv = node[bw].next) {\n      label_blossom(bw = node[bv].next, 0, l);\n      label_blossom(node[bw].next, node[bw].from, {node[bv].from, node[bv].to});\n    }\n  }\n\n  int find_mate(int bid) {\n    return bid <= N ? mate[bid] : mate[bid] = find_mate(base[bid]);\n  }\n\n  void push_inner_blossom_rec(int bid, bool push=true) {\n    tree_label[bid] = (bid <= N) ? INNER : UNUSED;\n    if (bid > N) {\n      int v = base[bid], u = v;\n      do { push_inner_blossom_rec(v, push); } while ( (v = node[v].next) != u);\n    } else if (push) inner_vertices[inner_vertices_size++] = bid;\n  }\n\n  void push_inner_blossom(int bid) {\n    if (tree_label[bid] != UNUSED) return;\n    bool push = label[bid].from != SEPARATED;\n    if (bid > N) {\n      if (push) inner_blossoms[inner_blossom_size++] = bid; \n      push_inner_blossom_rec(bid, push);\n    } else if (push) inner_vertices[inner_vertices_size++] = bid;\n    tree_label[bid] = INNER;\n  }\n\n  void push_outer_blossom_rec(int bid) {\n    tree_label[bid] = (bid <= N) ? OUTER : UNUSED;\n    if (bid > N) {\n      int v = base[bid], u = v;\n      do { push_outer_blossom_rec(v); } while ( (v = node[v].next) != u );\n    } else outer_vertices.enqueue(bid);\n  }\n\n  void push_outer_blossom(int bid, bool push) {\n    push_outer_blossom_rec(bid);\n    if (bid <= N) return;\n    if (push) outer_blossoms[outer_blossom_size++] = bid, tree_label[bid] = OUTER;\n    else tree_label[bid] = UNUSED;\n  }\n\n  inline void merge_edge(int x, int bx, int eid) {\n    auto& e = edges[eid];\n    int y = e.to, by = surface[y];\n    if (tree_label[by] != OUTER || bx == by) return;\n    auto r_cost = reduced_cost(x, y, e);\n    if (r_cost < best_cost[by].first) {\n      if (best_cost[by].first == INF) merged_edges[merged_edge_size++] = by;\n      best_cost[by] = {r_cost, eid};\n    }\n  }\n\n  inline void merge_vertex(int x, int bx) {\n    for (int eid = ofs[x]; eid < ofs[x + 1]; ++eid) merge_edge(x, bx, eid);\n    best_edge[x] = UNDEFINED;\n  }\n\n  void clear_best_edges(int b) {\n    if (b > N) {\n      int v = b = base[b];\n      do { clear_best_edges(v); } while ( (v = node[v].next) != b );\n    } else best_edge[b] = UNDEFINED;\n  }\n\n  void merge_outer(int b, int bid) {\n    if (b > N) {\n      for (int eid = be_head[b]; eid >= 0; eid = be_next[eid]) {\n        merge_edge(edges[eid].from, bid, eid);\n      }\n      be_head[b] = -1;\n      clear_best_edges(b);\n    } else merge_vertex(b, bid);\n  }\n\n  void merge_inner(int b, int bid) {\n    if (b > N) {\n      int v = b = base[b];\n      do { merge_inner(v, bid); } while ((v = node[v].next) != b);\n    } else merge_vertex(b, bid);\n  }\n\n  void build_linked_list(int bid) {\n    if (bid <= N) return;\n    int last = -1;\n    for (; merged_edge_size > 0; ) {\n      int by = merged_edges[--merged_edge_size], eid = best_cost[by].second;\n      int x = edges[eid].from, y = edges[eid].to;\n      be_next[eid] = last;\n      if (tree_label[y] == OUTER) update_best_edge(y, by, best_cost[by].first, eid);\n      if (best_edge[x] == UNDEFINED || best_cost[by].first < reduced_cost(best_edge[x])) {\n        best_edge[x] = eid;\n      }\n      best_cost[by] = {INF, UNDEFINED};\n      last = eid;\n    }\n    be_head[bid] = last;\n  }\n\n  void merge_best_edges(int bid, int inner_count) {\n    for (int i = 0; i < inner_count; ++i) {\n      int bv = outer_blossoms[outer_blossom_size + i];\n      if (bv >= 0) merge_outer(bv, bid), merge_inner(node[bv].next, bid);\n      else merge_inner(~bv, bid), merge_outer(node[~bv].next, bid);\n    }\n    merge_outer(base[bid], bid);\n    build_linked_list(bid);\n  }\n\n  void contract(int x, int y, int eid) {\n    int s = surface[x], t = surface[y];\n    if (s == t) return;\n    auto h = label[surface[mate[s]]].from = label[surface[mate[t]]].from = -encode(eid);\n\n    int lca = -1;\n    for (; ; label[surface[mate[s]]].from = h) {\n      if (mate[t] != 0) swap(s, t);\n      s = lca = surface[label[s].from];\n      if (label[surface[mate[s]]].from == h) break;\n    }\n\n    int inner_count = 0;\n    for (int dir = 0; dir < 2; ++dir) {\n      int v = (dir == 0) ? x : y;\n      while (1) {\n        int bv = surface[v], mv = mate[bv], bmv = surface[mv];\n        if (bv == lca) break;\n        label[mv] = label[bmv] = {x, y};\n        auto n = node[bmv];\n        if (!dir) {\n          node[bv] = {bmv, mate[mv], mv};\n          node[bmv].next = surface[n.to];\n        } else {\n          node[surface[n.to]] = {bmv, n.to, n.from};\n          node[bmv] = {bv, mv, mate[mv]}; \n        }\n        push_outer_blossom(bmv, false);\n        v = label[bv].from;\n\n        // Caution: used as temporary array\n        outer_blossoms[outer_blossom_size + (inner_count++)] = !dir ? bv : ~bmv;\n      }\n    }\n    node[surface[y]] = {surface[x], y, x};\n\n    int bid = next_bid.back(); next_bid.pop_back();\n    base[bid] = lca, label[bid].from = label[lca].from, mate[bid] = mate[lca];\n\n    tree_label[bid] = OUTER;\n    set_surface(bid, bid);\n    merge_best_edges(bid, inner_count);\n\n    outer_blossoms[outer_blossom_size++] = bid;\n  }\n\n  inline void update_best_edge(int y, int by, weight_t r_cost, int eid) {\n    if (tree_label[by] != OUTER && best_edge[y] == UNDEFINED) {\n      neighbors[neighbor_size++] = y;\n    }\n    if (best_edge[y] == UNDEFINED || r_cost < reduced_cost(best_edge[y])) {\n      best_edge[y] = eid;\n    }\n  }\n\n  void build_edge_list(int b) {\n    if (b <= N) return;\n    merge_inner(b, b);\n    build_linked_list(b);\n  }\n\n  bool augmented(int root, int s) {\n    if (s == 0) {\n      int br = surface[root];\n      push_outer_blossom(br, true);\n      label_blossom(br, 0, {0, 0});\n      build_edge_list(br);\n    } \n    for (; !outer_vertices.empty() || s > 0; s = 0) {\n      auto x = (s > 0) ? s : outer_vertices.dequeue();\n      if (potential[x] == 0) {\n        if (root != x) rematch(x, 0);\n        return true;\n      }\n      for (int eid = ofs[x]; eid < ofs[x + 1]; ++eid) {\n        int bx = surface[x], y = edges[eid].to, by = surface[y];\n        if (bx == by) continue;\n        auto r_cost = reduced_cost(x, y, edges[eid]);\n        if (r_cost > 0 || tree_label[by] != OUTER) {\n          update_best_edge(y, by, r_cost, eid);\n          if (r_cost > 0) continue;\n        }\n        if (label[by].from >= 0) {\n          contract(x, y, eid);\n          continue;\n        } \n        if (tree_label[by] == UNUSED) {\n          push_inner_blossom(by);\n          if (by != y) label_blossom(by, find_mate(by), {DEFAULT, 0});\n        }\n        int z = mate[by];\n        if (z == 0 && by != surface[root]) {\n          rematch(x, y); rematch(y, x);\n          return true;\n        }\n        int bz = surface[z];\n        if (label[bz].from < 0) {\n          node[by] = {-1, y, x};\n          push_outer_blossom(bz, true);\n          label_blossom(bz, mate[z], {x, y});\n          build_edge_list(bz);\n        }\n      }\n    }\n    return false;\n  }\n\n  void set_surface(int b, int bid) {\n    for (int v = base[b]; surface[v] != bid; v = node[v].next) {\n      if (v > N) tree_label[v] = UNUSED, set_surface(v, bid);\n      surface[v] = bid;\n    }\n  }\n  \n  void reset_surface(int b, int bid) {\n    surface[b] = bid;\n    if (b <= N) return;\n    for (b = base[b]; surface[b] != bid; b = node[b].next) reset_surface(b, bid);\n  }\n\n  void separate_blossom(int bid, bool push_blossom=true) {\n    tree_label[bid] = UNUSED, label[bid].from = SEPARATED;\n    if (bid <= N) return;\n    if (push_blossom) inner_blossoms[inner_blossom_size++] = bid;\n    for (int b = base[bid]; label[b].from != SEPARATED; b = node[b].next) {\n      separate_blossom(b, false);\n    }\n  }\n\n  void reverse_blossom(int b) {\n    int v = b, fr = node[b].from, to = node[b].to;\n    for (int nv = node[v].next; nv != b; ) {\n      int nnext = node[nv].next, nfr = node[nv].from, nto = node[nv].to;\n      node[nv].next = v, node[nv].from = to, node[nv].to = fr;\n      fr = nfr, to = nto, v = nv, nv = nnext;\n    }\n    node[b].next = v, node[b].from = to, node[b].to = fr;\n  }\n\n  void expand_blossom(int bid) {\n    next_bid.push_back(bid); tree_label[bid] = UNUSED;\n    for (int b = base[bid]; surface[b] == bid; b = node[b].next) reset_surface(b, b);\n    int old_base = base[bid], target = surface[node[bid].from]; \n    if (mate[node[target].from] == node[target].to) reverse_blossom(old_base);\n    for (int b = target; node[b].next != old_base; ) {\n      separate_blossom(b = node[b].next); separate_blossom(b = node[b].next);\n    }\n    node[target] = node[bid];\n    for (int b = old_base; ; b = node[b].next) {\n      label[b].from = DEFAULT, tree_label[b] = INNER; \n      if (b > N) inner_blossoms[inner_blossom_size++] = b;\n      int m = find_mate(b), bm = surface[m];\n      if (b != old_base) mate[bm] = mate[m];\n      label[m] = label[bm] = {node[b].to, node[b].from};\n      if (b == target) break;\n      push_outer_blossom(b = node[b].next, true);\n      build_edge_list(b);\n    }\n    base[bid] = bid, surface[bid] = bid;\n  }\n\n  void update_potential(int* vs, int s, weight_t delta, int label) {\n    for (int i = 0; i < s; ++i) {\n      int x = vs[i];\n      if (tree_label[x] != label) continue;\n      potential[x] += delta;\n    }\n  }\n\n  int adjust_dual_solutions() {\n    pair<weight_t, int> delta1(INF, 0), delta2(INF, 0), delta3(INF, 0), delta4(INF, 0);\n    for (int i = 0; i < outer_vertices.size(); ++i) {\n      int y = outer_vertices[i], eid = best_edge[y];\n      delta1 = min(delta1, {potential[y], y});\n      if (eid != UNDEFINED) {\n        delta3 = min(delta3, {reduced_cost(eid) >> 1, y});\n      }\n    }\n    for (int i = 0; i < neighbor_size; ++i) {\n      int y = neighbors[i];\n      if (tree_label[y] == UNUSED) {\n        int eid = best_edge[y], x = edges[eid].from;\n        delta2 = min(delta2, {reduced_cost(x, y, edges[eid]), x});\n      }\n    }\n    for (int i = 0; i < inner_blossom_size; ++i) {\n      if (tree_label[inner_blossoms[i]] == INNER) {\n        int b = inner_blossoms[i];\n        delta4 = min(delta4, {potential[b] >> 1, b});\n      }\n    }\n    auto delta = min(min(delta1, delta2), min(delta3, delta4));\n    auto d = delta.first;\n    update_potential(outer_vertices.data(), outer_vertices.size(), -1 * d, OUTER);\n    update_potential(inner_vertices.data(), inner_vertices_size,    1 * d, INNER);\n    update_potential(outer_blossoms.data(), outer_blossom_size,     2 * d, OUTER);\n    update_potential(inner_blossoms.data(), inner_blossom_size,    -2 * d, INNER);\n    if (delta4.first == d) {\n      expand_blossom(delta4.second);\n      return -1;\n    } else {\n      return delta.second;\n    }\n  }\n\n  void fix_blossom_bases() {\n    int remain = size - next_bid.size() - (N + 1);\n    for (int bid = N + 1; bid < size && remain > 0; ++bid) if (base[bid] != bid) {\n      int b = base[bid];\n      for (int skipped = 0; skipped < 2;) {\n        b = node[b].next;\n        if (mate[node[b].from] == node[b].to) skipped = 0;\n        else skipped++;\n      }\n      base[bid] = b;\n      --remain;\n    }\n  }\n\n  void free_edge_list(int x) {\n    be_head[x] = -1;\n  }\n\n  void clear_vertices(int* vs, int size) {\n    for (int i = 0; i < size; ++i) {\n      int v = vs[i]; \n      label[v] = {DEFAULT, 0}; tree_label[v] = UNUSED; best_edge[v] = UNDEFINED;\n    }\n  }\n\n  void clear_label() {\n    label[0] = {DEFAULT, 0};\n    clear_vertices(outer_vertices.data(), outer_vertices.size()); outer_vertices.clear();\n    clear_vertices(inner_vertices.data(), inner_vertices_size); inner_vertices_size = 0;\n    clear_vertices(outer_blossoms.data(), outer_blossom_size);\n    for (int i = 0; i < outer_blossom_size; ++i) {\n      if (be_head[outer_blossoms[i]] >= 0) free_edge_list(outer_blossoms[i]);\n    }\n    outer_blossom_size = 0;\n    clear_vertices(inner_blossoms.data(), inner_blossom_size); inner_blossom_size = 0;\n    for (int i = 0; i < neighbor_size; ++i) best_edge[neighbors[i]] = UNDEFINED;\n    neighbor_size = 0;\n  }\n\n  void set_potential() {\n    potential.resize(size);\n    for (int u = 1; u <= N; ++u) {\n      weight_t max_w = 0;\n      for (int eid = ofs[u]; eid < ofs[u + 1]; ++eid) {\n        max_w = max(max_w, edges[eid].weight);\n      }\n      potential[u] = max_w >> 1;\n    }\n  }\n\n  void initialize() {\n    mate.assign(size, 0);\n    label.assign(size, {-1, 0});\n\n    surface.resize(size); for (int i = 0; i < size; ++i) surface[i] = i;\n    base.resize(size); for (int i = 0; i < size; ++i) base[i] = i;\n    node.resize(size); for (int i = 0; i < size; ++i) node[i] = {i, i, i};\n\n    outer_vertices = Queue(N);\n    inner_vertices.resize(N + 1); inner_vertices_size = 0;\n    outer_blossoms.resize(B); outer_blossom_size = 0;\n    inner_blossoms.resize(B); inner_blossom_size = 0;\n\n    tree_label.assign(size, UNUSED);\n\n    next_bid.resize(B);\n    for (int i = 0; i < B; ++i) next_bid[i] = size - 1 - i;\n\n    merged_edges.resize(N + 1); merged_edge_size = 0;\n    best_cost.assign(size, {INF, UNDEFINED});\n\n    neighbors.resize(N + 1); neighbor_size = 0;\n    best_edge.assign(size, UNDEFINED);\n\n    be_head.assign(size, -1);\n    be_next.resize(edges.size());\n  }\n\nprivate:\n  int N, B, size;\n  vector<Edge> edges;\n  vector<int> ofs;\n\n  vector<Label> label;\n  vector<int> mate, surface, base;\n  vector<Node> node;\n  vector<weight_t> potential;\n\n  vector<int> next_bid;\n\n  vector<int8_t> tree_label;\n\n  Queue outer_vertices;\n  vector<int> inner_vertices; int inner_vertices_size;\n  vector<int> outer_blossoms; int outer_blossom_size;\n  vector<int> inner_blossoms; int inner_blossom_size;\n\n  vector<int> merged_edges; int merged_edge_size;\n  vector< pair<weight_t, int> > best_cost;\n  vector<int> neighbors; int neighbor_size;\n  vector<int> best_edge;\n\n  vector<int> be_head, be_next;\n};\n\nconst ll MX=10000100;\n\nint main(){\n  vector<bool> prime(MX,true);\n  prime[0]=prime[1]=false;\n  for(ll i=2;i*i<MX;i++){\n    for(ll j=2;i*j<MX;j++){prime[i*j]=false;}\n  }\n  ll N;\n  cin>>N;\n  vector<bool> A(MX,false);\n  for(int i=0;i<N;i++){\n    ll x;\n    cin>>x;\n    A[x]=true;\n  }\n  vector<ll> pt;\n  for(ll i=1;i<MX;i++){\n    if(A[i-1]!=A[i]){pt.push_back(i);}\n  }\n  ll M=pt.size();\n  using Edge = MaximumWeightedMatching<int>::Edge;\n  vector<Edge> E;\n  for(int i=0;i<M;i++){\n    for(int j=0;j<i;j++){\n      if((pt[i]-pt[j])&1){\n        if(prime[pt[i]-pt[j]]){E.push_back({j+1,i+1,1});}\n        else{E.push_back({j+1,i+1,3});}\n      }\n      else{\n        E.push_back({j+1,i+1,2});\n      }\n    }\n  }\n  //cout<<E.size()<<endl;\n  //for(auto &I:E){cout<<I.from<<\" \"<<I.to<<\" \"<<I.weight<<endl;}\n  MaximumWeightedMatching<int> MM(M,E);\n  cout<<MM.maximum_weighted_matching()<<endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(2)\n#include<bits/stdc++.h>\n#define ll long long\n#define maxn 1000005\n#define N 10000005\n#define inf 1e9\n#define pb push_back\n#define rep(i,a,b) for(int i=a;i<=b;i++)\n#define per(i,a,b) for(int i=a;i>=b;i--)\nusing namespace std;\n\ninline int read()\n{\n\tint x=0,w=1; char c=getchar();\n\twhile(c<'0'||c>'9') {if(c=='-') w=-1; c=getchar();}\n\twhile(c<='9'&&c>='0') {x=(x<<1)+(x<<3)+c-'0'; c=getchar();}\n\treturn w==1?x:-x;\n}\n\nbool x[N],is[N];\nint l[maxn],r[maxn],c[maxn],cr,cl,cnt,pri[maxn],T[maxn],ct;\n\nstruct node{int from,to,cap,flow,cost;};\nvector <node> edges;\nvector <int> mp[maxn];\nint s,t,n,m,d[maxn],flow,cost,p[maxn],a[maxn];\nbool inq[maxn];\nqueue <int> que;\n\ninline void A(int u,int v,int w,int c)\n{\n\tedges.push_back((node){u,v,w,0,c});\n\tedges.push_back((node){v,u,0,0,-c});\n\tint pp=edges.size();\n\tmp[u].push_back(pp-2);\n\tmp[v].push_back(pp-1);\n}\n\ninline bool spfa()\n{\n\tfor(int i=0;i<=t;i++) d[i]=inf,inq[i]=0,a[i]=inf;\n\tque.push(s); d[s]=0;\n\twhile(!que.empty())\n\t{\n\t\tint u=que.front(); que.pop(); inq[u]=0;\n\t\tfor(int i=0;i<mp[u].size();i++)\n\t\t{\n\t\t\tnode &v=edges[mp[u][i]];\n\t\t\tif(v.cap-v.flow>0&&d[v.to]>d[u]+v.cost)\n\t\t\t{\n\t\t\t\td[v.to]=d[u]+v.cost;\n\t\t\t\ta[v.to]=min(a[u],v.cap-v.flow);\n\t\t\t\tp[v.to]=mp[u][i];\n\t\t\t\tif(inq[v.to]==0) que.push(v.to),inq[v.to]=1;\n\t\t\t}\n\t\t}\n\t}\n\tif(d[t]==inf) return false;\n\tflow+=a[t];\n\tcost+=a[t]*d[t];\n\tfor(int i=t;i!=s;i=edges[p[i]].from)\n\t{\n\t\tedges[p[i]].flow+=a[t];\n\t\tedges[p[i]^1].flow-=a[t];\n\t}\n\treturn true;\n}\n\ninline void pre()\n{\n\tfor(int i=2;i<=(N-4);i++)\n\t{\n\t\tif(!is[i]) pri[++cnt]=i;\n\t\tfor(int j=1;j<=cnt,pri[j]*i<=(N-5);j++)\n\t\t{\n\t\t\tis[pri[j]*i]=1;\n\t\t\tif(i%pri[j]==0) break;\n\t\t}\n\t}\n}\n\nint main()\n{\n\t//freopen(\"t1.out\",\"w\",stdout);\n\tn=read(); pre(); is[1]=1;\n\trep(i,1,n) c[i]=read(),x[c[i]]=1;\n\trep(i,1,(N-4)) if(x[i]!=x[i-1]) T[++ct]=i;\n\t//rep(i,1,ct) cout<<T[i]<<\" \"; cout<<endl;\n\ts=0,t=2*ct+1;\n\trep(i,1,ct) A(s,i,1,0),A(i+ct,t,1,0);\n\trep(i,1,ct) rep(j,1,ct)\n\t{\n\t\tif(i==j) continue;\n\t\tint tmp=abs(T[i]-T[j]);\n\t\tif(tmp%2==0) A(i,j+ct,1,2);\n\t\telse if(!is[tmp]) A(i,j+ct,1,1);\n\t\telse A(i,j+ct,1,3);\n\t}\n\twhile(spfa()); cout<<cost/2<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#define _GLIBCXX_DEBUG\n\n#include<bits/stdc++.h>\nusing namespace std;\n\n#define endl '\\n'\n#define lfs cout<<fixed<<setprecision(10)\n#define ALL(a)  (a).begin(),(a).end()\n#define ALLR(a)  (a).rbegin(),(a).rend()\n#define spa << \" \" <<\n#define fi first\n#define se second\n#define MP make_pair\n#define MT make_tuple\n#define PB push_back\n#define EB emplace_back\n#define rep(i,n,m) for(ll i = (n); i < (ll)(m); i++)\n#define rrep(i,n,m) for(ll i = (ll)(m) - 1; i >= (ll)(n); i--)\nusing ll = long long;\nusing ld = long double;\nconst ll MOD1 = 1e9+7;\nconst ll MOD9 = 998244353;\nconst ll INF = 1e18;\nusing P = pair<ll, ll>;\ntemplate<typename T1, typename T2>bool chmin(T1 &a,T2 b){if(a>b){a=b;return true;}else return false;}\ntemplate<typename T1, typename T2>bool chmax(T1 &a,T2 b){if(a<b){a=b;return true;}else return false;}\nll median(ll a,ll b, ll c){return a+b+c-max({a,b,c})-min({a,b,c});}\nvoid ans1(bool x){if(x) cout<<\"Yes\"<<endl;else cout<<\"No\"<<endl;}\nvoid ans2(bool x){if(x) cout<<\"YES\"<<endl;else cout<<\"NO\"<<endl;}\nvoid ans3(bool x){if(x) cout<<\"Yay!\"<<endl;else cout<<\":(\"<<endl;}\ntemplate<typename T1,typename T2>void ans(bool x,T1 y,T2 z){if(x)cout<<y<<endl;else cout<<z<<endl;}  \ntemplate<typename T>void debug(vector<vector<T>>&v,ll h,ll w){for(ll i=0;i<h;i++){cout<<v[i][0];for(ll j=1;j<w;j++)cout spa v[i][j];cout<<endl;}};\nvoid debug(vector<string>&v,ll h,ll w){for(ll i=0;i<h;i++){for(ll j=0;j<w;j++)cout<<v[i][j];cout<<endl;}};\ntemplate<typename T>void debug(vector<T>&v,ll n){if(n!=0)cout<<v[0];for(ll i=1;i<n;i++)cout spa v[i];cout<<endl;};\ntemplate<typename T>vector<vector<T>>vec(ll x, ll y, T w){vector<vector<T>>v(x,vector<T>(y,w));return v;}\nll gcd(ll x,ll y){ll r;while(y!=0&&(r=x%y)!=0){x=y;y=r;}return y==0?x:y;}\nvector<ll>dx={1,-1,0,0,1,1,-1,-1};vector<ll>dy={0,0,1,-1,1,-1,1,-1};\ntemplate<typename T>vector<T> make_v(size_t a,T b){return vector<T>(a,b);}\ntemplate<typename... Ts>auto make_v(size_t a,Ts... ts){return vector<decltype(make_v(ts...))>(a,make_v(ts...));}\ntemplate<typename T1, typename T2>ostream &operator<<(ostream &os, const pair<T1, T2>&p){return os << p.first << \" \" << p.second;}\ntemplate<typename T>ostream &operator<<(ostream &os, const vector<T> &v){for(auto &z:v)os << z << \" \";cout<<\"|\"; return os;}\n//mt19937 mt(chrono::steady_clock::now().time_since_epoch().count());\nvector< bool > prime_table(ll n) {\n  vector< bool > prime(n + 1, true);\n  if(n >= 0) prime[0] = false;\n  if(n >= 1) prime[1] = false;\n  for(ll i = 2; i * i <= n; i++) {\n    if(!prime[i]) continue;\n    for(ll j = i + i; j <= n; j += i) {\n      prime[j] = false;\n    }\n  }\n  return prime;\n}\ntemplate< typename flow_t, typename cost_t >\nstruct PrimalDual {\n  const cost_t INF;\n\n  struct edge {\n    ll to;\n    flow_t cap;\n    cost_t cost;\n    ll rev;\n    bool isrev;\n  };\n  vector< vector< edge > > graph;\n  vector< cost_t > potential, min_cost;\n  vector< ll > prevv, preve;\n\n  PrimalDual(ll V) : graph(V), INF(numeric_limits< cost_t >::max()) {}\n\n  void add_edge(ll from, ll to, flow_t cap, cost_t cost) {\n    graph[from].emplace_back((edge) {to, cap, cost, (ll) graph[to].size(), false});\n    graph[to].emplace_back((edge) {from, 0, -cost, (ll) graph[from].size() - 1, true});\n  }\n\n  cost_t min_cost_flow(ll s, ll t, flow_t f) {\n    ll V = (ll) graph.size();\n    cost_t ret = 0;\n    using Pi = pair< cost_t, ll >;\n    priority_queue< Pi, vector< Pi >, greater< Pi > > que;\n    potential.assign(V, 0);\n    preve.assign(V, -1);\n    prevv.assign(V, -1);\n\n    while(f > 0) {\n      min_cost.assign(V, INF);\n      que.emplace(0, s);\n      min_cost[s] = 0;\n      while(!que.empty()) {\n        Pi p = que.top();\n        que.pop();\n        if(min_cost[p.second] < p.first) continue;\n        for(ll i = 0; i < graph[p.second].size(); i++) {\n          edge &e = graph[p.second][i];\n          cost_t nextCost = min_cost[p.second] + e.cost + potential[p.second] - potential[e.to];\n          if(e.cap > 0 && min_cost[e.to] > nextCost) {\n            min_cost[e.to] = nextCost;\n            prevv[e.to] = p.second, preve[e.to] = i;\n            que.emplace(min_cost[e.to], e.to);\n          }\n        }\n      }\n      if(min_cost[t] == INF) return -1;\n      for(ll v = 0; v < V; v++) potential[v] += min_cost[v];\n      flow_t addflow = f;\n      for(ll v = t; v != s; v = prevv[v]) {\n        addflow = min(addflow, graph[prevv[v]][preve[v]].cap);\n      }\n      f -= addflow;\n      ret += addflow * potential[t];\n      for(ll v = t; v != s; v = prevv[v]) {\n        edge &e = graph[prevv[v]][preve[v]];\n        e.cap -= addflow;\n        graph[v][e.rev].cap += addflow;\n      }\n    }\n    return ret;\n  }\n\n  void output() {\n    for(ll i = 0; i < graph.size(); i++) {\n      for(auto &e : graph[i]) {\n        if(e.isrev) continue;\n        auto &rev_e = graph[e.to][e.rev];\n        cout << i << \"->\" << e.to << \" (flow: \" << rev_e.cap << \"/\" << rev_e.cap + e.cap << \")\" << endl;\n      }\n    }\n  }\n  using R=vector<pair<pair<ll,ll>,pair<flow_t,cost_t>>>;\n  R restore() {\n    R ret;\n    for(ll i = 0; i < graph.size(); i++) {\n      for(auto &e : graph[i]) {\n        if(e.isrev) continue;\n        auto &rev_e = graph[e.to][e.rev];\n        ret.emplace_back(make_pair(i,e.to),make_pair(rev_e.cap,e.cost));\n      }\n    }\n    return ret;\n  }\n};\nint main(){\n  cin.tie(nullptr);\n  ios_base::sync_with_stdio(false);\n  ll res=0,buf=0;\n  bool judge = true;\n  ll lim=1e7+30;\n  //ll lim=1e3;cout<<\"naosu\"<<endl;\n  auto pr=prime_table(lim);\n  /*vector<ll>p;\n  rep(i,0,lim)if(pr[i])p.PB(i);\n  ll sz=p.size();*/\n  ll n;cin>>n;\n  vector<ll>x(n);\n  rep(i,0,n)cin>>x[i];\n  vector<ll>y;\n  rep(i,0,n){\n    y.PB(x[i]);\n    y.PB(x[i]+1);\n  }\n  //cout<<lim<<endl;\n  {\n    vector<ll>tmp;\n    sort(ALL(y));\n    rep(i,0,y.size()){\n      if(i+1<y.size()&&y[i]==y[i+1])i++;\n      else tmp.PB(y[i]);\n    }\n    y=tmp;\n  }\n  pr[2]=false;\n  ll sz=y.size();\n  PrimalDual<ll,ll>fl(2*sz+2);\n  rep(i,0,sz)rep(j,0,sz){\n    if(i==j)continue;\n    ll dif=abs(y[i]-y[j]);\n    ll cost=0;\n    if(dif==0)cost=0;\n    else if(dif%2==0)cost=2;\n    else if(pr[dif])cost=1;\n    else cost=3;\n    //cout<<dif spa cost spa y[i] spa y[j]<<endl;\n    fl.add_edge(i,j+sz,1,cost);\n  }\n  ll S=2*sz,T=2*sz+1;\n  rep(i,0,sz){\n    fl.add_edge(S,i,1,0);\n    fl.add_edge(i+sz,T,1,0);\n  }\n  //cout<<sz<<endl;\n  //debug(y,sz);\n  ll lk=fl.min_cost_flow(S,T,sz);\n  assert(~lk&1);\n  cout<<lk/2<<endl;\n  map<P,ll>mp;\n  auto r=fl.restore();\n  for(auto z:r){\n    if(z.se.fi==1&&z.fi.fi<sz&&z.fi.se<2*sz){\n      //cout<<y[z.fi.fi] spa y[z.fi.se-sz]<<endl;\n      mp[minmax(y[z.fi.fi],y[z.fi.se-sz])]++;\n    }\n  }\n  for(auto z:mp)assert(~z.se&1);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <unordered_map>\n#include <unordered_set>\n#include <utility>\n#include <vector>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> PP;\n\n// This code performs maximum bipartite matching.\n//\n// Running time: O(|E| |V|) -- often much faster in practice\n//\n//   INPUT: w[i][j] = edge between row node i and column node j\n//   OUTPUT: mr[i] = assignment for row node i, -1 if unassigned\n//           mc[j] = assignment for column node j, -1 if unassigned\n//           function returns number of matches made\n\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\n\nbool FindMatch(int i, const VVI &w, VI &mr, VI &mc, VI &seen) {\n  for (int j = 0; j < w[i].size(); j++) {\n    if (w[i][j] && !seen[j]) {\n      seen[j] = true;\n      if (mc[j] < 0 || FindMatch(mc[j], w, mr, mc, seen)) {\n        mr[i] = j;\n        mc[j] = i;\n        return true;\n      }\n    }\n  }\n  return false;\n}\n\nint BipartiteMatching(const VVI &w) {\n  VI mr = VI(w.size(), -1);\n  VI mc = VI(w[0].size(), -1);\n  \n  int ct = 0;\n  for (int i = 0; i < w.size(); i++) {\n    VI seen(w[0].size());\n    if (FindMatch(i, w, mr, mc, seen)) ct++;\n  }\n  return ct;\n}\n\nset<int> P;\nconst int B = 1E7 + 10;\nbool sieve[B];\n\nint main() {\n    ios::sync_with_stdio(false);\n    int N;\n    cin >> N;\n    set<int> M;\n    for (int i = 0;i < N;i++) {\n    \tint n;\n    \tcin >> n;\n    \tM.insert(n);\n    }\n    memset(sieve, 0, sizeof(sieve));\n    for (int i = 2;i < B;i++) {\n    \tif (sieve[i] == 0) {\n    \t\tfor (int j = i;j < B;j += i) sieve[j] = 1;\n    \t\tif (i % 2) P.insert(i);\n    \t}\n    }\n    set<int> Q;\n    for (auto m : M) {\n    \tif (M.count(m - 1) == 0) Q.insert(m - 1);\n    \tif (M.count(m + 1) == 0) Q.insert(m);\n    }\n    vector<int> R;\n    for (auto m : Q) R.push_back(m);\n    int sz = R.size();\n    vector<int> o, e;\n    for (int i = 0;i < sz;i++) {\n    \tif (R[i] % 2) o.push_back(R[i]);\n    \telse e.push_back(R[i]);\n    }\n    vector<int> tmp(e.size(), 0);\n    vector<vector<int> > T(o.size(), tmp);\n    for (int i = 0;i < o.size();i++) {\n    \tfor (int j = 0;j < e.size();j++) {\n    \t\tif (P.count(abs(o[i] - e[j]))) T[i][j] = 1;\n    \t}\n    }\n    int mc = BipartiteMatching(T);\n    int oo = o.size() - mc;\n    int ee = e.size() - mc;\n    cout << mc + 2 * (oo / 2 + ee / 2) + 3 * (oo % 2) << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// warm heart, wagging tail,and a smile just for you!\n//                                                                     ███████████\n//                                                                   ███╬╬╬╬╬╬╬╬╬╬███\n//                                                                ███╬╬╬╬╬████╬╬╬╬╬╬███\n//                                            ███████████       ██╬╬╬╬╬████╬╬████╬╬╬╬╬██\n//                                      █████████╬╬╬╬╬████████████╬╬╬╬╬██╬╬╬╬╬╬███╬╬╬╬╬██\n//                               ████████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████████╬╬╬╬╬╬██╬╬╬╬╬╬╬██\n//                             ████╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████████╬╬╬╬╬╬╬╬╬╬╬██\n//                           ███╬╬╬█╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬███╬╬╬╬╬╬╬█████\n//                         ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬████████╬╬╬╬╬██\n//                       ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬╬╬╬╬╬███\n//                     ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬██\n//                 ████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████╬╬╬╬╬████\n//     █████████████╬╬╬╬╬╬╬╬██╬╬╬╬╬████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬██████\n//   ████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬██████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██████╬╬╬╬╬╬╬███████████╬╬╬╬╬╬╬╬██╬╬╬██╬╬╬██\n// ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████╬╬╬╬╬╬╬╬╬╬╬█╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬██\n// ██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬▓▓▓▓▓▓╬╬╬████╬╬████╬╬╬╬╬╬╬▓▓▓▓▓▓▓▓██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬███\n// ██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██████▓▓▓▓▓▓▓╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬▓▓▓▓▓▓▓██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬█████\n// ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████████\n//   ███╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██\n//       ██████████████  ████╬╬╬╬╬╬███████████████████████████╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████\n//                         ███████                           █████  ███████████████████  \n//\n#include \"bits/stdc++.h\"\nusing namespace std;\n#define INF (1<<30)\n#define LINF (1LL<<60)\n#define fs first\n#define sc second\n#define int long long\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define RFOR(i,a,b) for(int i = (b-1);i>=(a);--i)\n#define REP(i,n)  FOR(i,0,(n))\n#define RREP(i,n) RFOR(i,0,(n))\n#define ITR(itr,mp) for(auto itr = (mp).begin(); itr != (mp).end(); ++itr)\n#define RITR(itr,mp) for(auto itr = (mp).rbegin(); itr != (mp).rend(); ++itr)\n#define range(i,a,b) ((a)<=(i) && (i)<(b))\n#define debug(x)  cout << #x << \" = \" << (x) << endl\n#define SP << \" \" << \ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n#define MSB(x) (63-__builtin_clzll(x))\n#define pcnt(x) (__builtin_popcountll(x))\n#define parity(i,j) (i&(1LL<<j))\ntypedef pair<int,int> P;\ntypedef tuple<int,int,int> T;\ntypedef vector<int> vec;\ntypedef vector<vector<int>> mat;\n\nvector<bool> pri((int)1e7+10);\nvoid init(int x){\n  vector<bool> flag(x+1,false);\n  for(int i = 2; i <= x; i++){\n    if(flag[i]) continue;\n    pri[i] = true;\n    for(int j = i; j <= x; j+=i) flag[j] = true;\n  }\n}\n\nstruct max_flow{\n  public:\n  struct edge {int to,cap,rev;};\n  int V;\n  vector<vector<edge>> G;\n  vector<int> level,iter;\n\n  max_flow(int v){\n    V = v; G.resize(v);\n  }\n\n  void add_edge(int from, int to, int cap){\n    G[from].push_back((edge){to,cap,G[to].size()});\n    G[to].push_back((edge){from,0,G[from].size()-1});\n  }\n\n  void bfs(int s){\n    level.assign(V,-1);\n    queue<int> que;\n    level[s] = 0;\n    que.push(s);\n    while(!que.empty()){\n      int v = que.front();\n      que.pop();\n      REP(i,G[v].size()){\n        edge &e = G[v][i];\n        if(e.cap > 0 && level[e.to] < 0){\n          level[e.to] = level[v] + 1;\n          que.push(e.to);\n        }\n      }\n    }\n  }\n\n  int dfs(int v, int t, int f){\n    if(v == t) return f;\n    for(int &i = iter[v]; i < G[v].size(); i++){\n      edge &e = G[v][i];\n      if(e.cap > 0 && level[v] < level[e.to]){\n        int d = dfs(e.to,t,min(f,e.cap));\n        if(d > 0){\n          e.cap -= d;\n          G[e.to][e.rev].cap += d;\n          return d;\n        }\n      }\n    }\n    return 0;\n  }\n\n  int run(int s, int t){\n    int flow = 0;\n    while(1){\n      bfs(s);\n      if(level[t] < 0) return flow;\n      iter.assign(V,0);\n      int tmp;\n      while((tmp = dfs(s,t,INF)) > 0){\n        flow += tmp;\n      }\n    }\n  }\n};\n// INFが大きすぎないか？\n\nsigned main(){\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n\n  int n;\n  cin >> n;\n\n  vector<int> a(n);\n  REP(i,n) cin >> a[i], a[i]--;\n  \n  init((int)1e7+5);\n  pri[2] = false;\n\n  map<int,int> mp;\n  REP(i,n){\n    mp[a[i]] ^= 1;\n    mp[a[i]+1] ^= 1;\n  }\n\n  vec b;\n  ITR(itr,mp) if(itr->sc) b.push_back(itr->fs);\n\n  int m = b.size();\n\n  max_flow mf(m+2);\n  REP(i,m) REP(j,m){\n    if(b[i]%2) continue;\n    if(pri[abs(b[i]-b[j])]) mf.add_edge(i,j,1);\n  }\n\n  int e = 0, o = 0;\n  REP(i,m){\n    if(b[i]%2) mf.add_edge(i,m+1,INF), o++;\n    else mf.add_edge(m,i,INF), e++;\n  }\n\n  int mx = mf.run(m,m+1);\n  cout << mx + (o/2+e/2)*2 + o%2*3 << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\ntypedef long long ll;\nint odd,even,Odd[105],Even[105],ma[105];\nint flag[10000010],x[10000010],map[105][105],vis[105];\nint prime[10000010],a[105];\nint dfs(int u)\n{\n\tfor (int v=1;v<=even;v++)\n\t{\n\t\tif (!map[u][v]) continue;\n\t\tif (!vis[v])\n\t\t{\n\t\t\tint t=ma[v];\n\t\t\tma[v]=u;\n\t\t\tvis[v]=1;\n\t\t\tif (t==-1||dfs(t)) return 1;\n\t\t\tma[v]=t;\n\t\t}\n\t}\n\treturn 0;\n}\nint main()\n{\n\tint n,cnt=0;\n\tscanf(\"%d\",&n);\n\tflag[1]=1;\n\tfor (int i=2;i<=10000000;i++)\n\t{\n\t\tif (!flag[i]) prime[++cnt]=i;\n\t\tfor (int j=1;j<=cnt;j++)\n\t\t{\n\t\t\tif (i*prime[j]>10000000) break;\n\t\t\tflag[i*prime[j]]=1;\n\t\t\tif (i%prime[j]==0) break;\n\t\t}\n\t}\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%d\",&a[i]);\n\t\tx[a[i]]^=1;\n\t}\n\tfor (int i=1;i<=10000000;i++)\n\t\tif (x[i]!=x[i-1])\n\t\t{\n\t\t\tif (i&1) Odd[++odd]=i;\n\t\t\telse Even[++even]=i; \n\t\t}\n\tfor (int i=1;i<=odd;i++)\n\t\tfor (int j=1;j<=even;j++)\n\t\t\tif (flag[abs(Odd[i]-Even[j])]) map[i][j]=1;\n\tmemset(ma,-1,sizeof(ma));\n\tint sum=0;\n\tfor (int i=1;i<=odd;i++)\n\t{\n\t\tmemset(vis,0,sizeof(vis));\n\t\tif (dfs(i)) sum++;\n\t}\n\tll ans=sum+(((odd-sum)>>1)<<1)+(((even-sum)>>1)<<1)+(odd-sum)%2*3;\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N=205,MX=10000010;\nint n,m,mx,ma,mb,a[N],b[N],e[N][N],vis[N],lmat[N],rmat[N],B[MX],p[MX/10],ans;\n\nvoid add(int x){if (x&1)  a[++ma]=x;  else  b[++mb]=x;}\n\nbool dfs(int x)\n{\n\tfor (int y=1; y<=mb; y++)\n\t\tif ((e[x][y])&&(vis[y]!=vis[0]))\n\t\t\t{\n\t\t\t\tvis[y]=vis[0];\n\t\t\t\tif ((!rmat[y])||(dfs(rmat[y])))  return lmat[x]=y,rmat[y]=x,1;\n\t\t\t}\n\treturn 0;\n}\n\nvoid work()\n{\n\tscanf(\"%d\",&n);\n\tfor (int i=1,x,y=-1; i<=n+1; i++)\n\t\t{\n\t\t\tif (i<=n)  scanf(\"%d\",&x),mx=max(mx,x+1);\n\t\t\tif ((i!=1)&&(y+1!=x))  add(y+1);\n\t\t\tif ((i<=n)&&(y+1!=x))  add(x);\n\t\t\ty=x;\n\t\t}\n\tB[1]=1;\n\tfor (int i=1; i<=mx; i++)\n\t\t{\n\t\t\tif (!B[i])  p[++m]=i;\n\t\t\tfor (int j=1; j<=m&&i*p[j]<=mx; j++)\n\t\t\t\t{\n\t\t\t\t\tB[i*p[j]]=1;\n\t\t\t\t\tif (i%p[j]==0)  break;\n\t\t\t\t}\n\t\t}\n\tfor (int i=1; i<=ma; i++)\n\t\tfor (int j=1; j<=mb; j++)\n\t\t\te[i][j]=!B[abs(a[i]-b[j])];\n\tfor (int i=1; i<=ma; i++)  if (vis[0]++,dfs(i))  ans++;\n\tans+=(ma-ans)/2*2+(mb-ans)/2*2+((ma-ans)&1)*3;\n\tprintf(\"%d\",ans);\n}\n\nint main()\n{\n\twork();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\ntypedef long long ll;\nint odd,even,Odd[105],Even[105],ma[105];\nbool flag[10000010],x[10000010],map[105][105],vis[105];\nint prime[10000010],a[105];\nint dfs(int u)\n{\n\tfor (int v=1;v<=even;v++)\n\t{\n\t\tif (!map[u][v]) continue;\n\t\tif (!vis[v])\n\t\t{\n\t\t\tint t=ma[v];\n\t\t\tma[v]=u;\n\t\t\tif (t==-1||dfs(t)) return 1;\n\t\t\tma[v]=t;\n\t\t}\n\t}\n\treturn 0;\n}\nint main()\n{\n\tint n,cnt=0;\n\tscanf(\"%d\",&n);\n\tflag[1]=1;\n\tfor (int i=2;i<=10000000;i++)\n\t{\n\t\tif (!flag[i]) prime[+cnt]=i;\n\t\tfor (int j=1;j<=cnt;j++)\n\t\t{\n\t\t\tif (i*prime[j]>10000000) break;\n\t\t\tflag[i*prime[j]]=1;\n\t\t\tif (i%prime[j]==0) break;\n\t\t}\n\t}\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%d\",&a[i]);\n\t\tx[a[i]]^=1;\n\t}\n\tfor (int i=1;i<=10000000;i++)\n\t\tif (x[i]!=x[i-1])\n\t\t{\n\t\t\tif (i&1) Odd[++odd]=i;\n\t\t\telse Even[++even]=i; \n\t\t}\n\tfor (int i=1;i<=odd;i++)\n\t\tfor (int j=1;j<=even;j++)\n\t\t\tif (flag[abs(Odd[i]-Even[j])]) map[i][j]=1;\n\tmemset(ma,-1,sizeof(ma));\n\tint sum=0;\n\tfor (int i=1;i<=odd;i++)\n\t{\n\t\tmemset(vis,0,sizeof(vis));\n\t\tif (dfs(i)) sum++;\n\t}\n\tll ans=sum+(((odd-sum)>>1)<<1)+(((even-sum)>>1)<<1)+(even-sum)%2*3;\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n\n#define Rep(i, n) for (int i = 1; i <= n; i ++)\n\nusing namespace std;\n\nconst int N = 410, N0 = 1e7 + 10;\n\nint d0[N], d[N], cd;\n\nbool isnotprime[N0];\nint prime[N0], cnt;\nvoid get_prime()\n{\n\tisnotprime[1] = true;\n\tfor (int i = 2; i <= 1e7 + 5; i ++){\n\t\tif (!isnotprime[i]) prime[++ cnt] = i;\n\t\tfor (int j = 1; j <= cnt && i * prime[j] <= 1e7 + 5; j ++) {\n\t\t\tisnotprime[i * prime[j]] = true;\n\t\t\tif (!(i % prime[j])) break;\n\t\t}\n\t}\n}\n\nbool g[N][N], vis[N];\nint lnk[N];\n\nbool dfs(int x)\n{\n\tRep(i, cd) if (g[x][i] && !vis[i]){\n\t\tvis[i] = true;\n\t\tif (lnk[i] == -1 || dfs(lnk[i])) {\n\t\t\tlnk[i] = x;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint main()\n{\n\tint n;\n\tscanf(\"%d\", &n);\n\tRep(i, n) scanf(\"%d\", &d0[i]);\n\td0[0] = -1;\n\tRep(i, n) {\n\t\tif (d0[i - 1] != d0[i] - 1) d[++ cd] = d0[i];\n\t\tif (d0[i + 1] != d0[i] + 1) d[++ cd] = d0[i] + 1;\n\t}\n\t\n\tget_prime();\n\tRep(i, cd) if (d[i] & 1)\n\t\tRep(j, cd) if (!(d[j] & 1))\n\t\t\tif (!isnotprime[(int)abs(d[j] - d[i])]) g[i][j] = true;\n\t\n\tint c0 = 0, c1 = 0, cc = 0;\n\tRep(i, cd) lnk[i] = -1;\n\tRep(i, cd) {\n\t\tif (d[i] & 1) {\n\t\t\tRep(j, cd) vis[j] = false;\n\t\t\tif (dfs(i)) cc ++;\n\t\t\tc1 ++;\n\t\t}\n\t\telse c0 ++;\n\t}\n\tint ans = cc;\n\tc0 -= cc, c1 -= cc;\n\tans += (c0 / 2) * 2, c0 %= 2;\n\tans += (c1 / 2) * 2, c1 %= 2;\n\tif (c0 && c1) ans += 3;\n\t\n\tprintf(\"%d\\n\", ans);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nconst int MAXN = 2e2 + 5;\nconst int MAXM = 1e7 + 5;\n\nint N;\nint a[MAXM];\nvector <int> v[2];\nvector <int> E[MAXN];\nbool bio[MAXN];\nint conn[MAXN];\n\nvoid load() {\n\tscanf(\"%d\", &N);\n\twhile (N--) {\n\t\tint x;\n\t\tscanf(\"%d\", &x);\n\t\ta[x] = 1;\n\t}\n}\n\nbool dfs(int x) {\n\tif (bio[x])\n\t\treturn false;\n\tbio[x] = true;\n\tfor (auto it : E[x])\n\t\tif (conn[it] == -1 || dfs(conn[it])) {\n\t\t\tconn[it] = x;\n\t\t\treturn true;\n\t\t}\n\treturn false;\n}\n\nbool prime(int x) {\n\tif (x == 1)\n\t\treturn false;\n\tfor (int i = 2; i * i <= x; i++)\n\t\tif (!(x % i))\n\t\t\treturn false;\n\treturn true;\n}\n\nint solve() {\n\tmemset(conn, -1, sizeof conn);\n\tfor (int i = MAXM - 1; i; i--) {\n\t\ta[i] ^= a[i - 1];\n\t\tif (a[i])\n\t\t\tv[i % 2].push_back(i);\n\t}\n\t\n\tfor (int i = 0; i < v[0].size(); i++)\n\t\tfor (int j = 0; j < v[1].size(); j++)\n\t\t\tif (prime(abs(v[0][i] - v[1][j]))) \n\t\t\t\tE[i].push_back(j);\n\t\n\tint match = 0;\n\tfor (int i = 0; i < v[0].size(); i++) {\n\t\tmemset(bio, false, sizeof bio);\n\t\tmatch += dfs(i);\n\t}\n\t\n\treturn v[0].size() + v[1].size() - match + (v[0].size() - match) % 2;\n}\n\nint main() {\n\tload();\n\tprintf(\"%d\\n\", solve());\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<cstring>\n#include<map>\n#include<queue>\n#include<cmath>\nusing namespace std;\ntypedef long long ll;\nconst int N=5005,INF=~0u>>2;\nstruct Edge{int nxt,to;}edge[(N*N)<<3];\nint b[N<<1],n,head[N<<1],num_edge,vis[N<<1],lk[N<<1],even[N<<1],odd[N<<1],even_num,odd_num,ans,k,tot,tim;\nint read(){\n\tint x=0,f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-') f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn f*x;\n}\nvoid add_edge(int from,int to){\n\tedge[++num_edge].nxt=head[from];\n\tedge[num_edge].to=to;\n\thead[from]=num_edge;\n}\nbool find(int x){\n\tfor(int i=head[x];i;i=edge[i].nxt){\n\t\tif(vis[edge[i].to]!=tim){\n\t\t\tvis[edge[i].to]=tim;\n\t\t\tif(!lk[edge[i].to]||find(edge[i].to)){\n\t\t\t\tlk[edge[i].to]=x;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nbool check(int x){\n\tif(x==1) return 0;\n\tfor(int i=2;i*i<=x;++i){\n\t\tif(x%i==0) return 0;\n\t}\n\treturn 1;\n}\nint main(){\n//\tfreopen(\"ex.in\",\"r\",stdin);\n\tn=read();\n\tfor(int i=1;i<=n;++i) b[i]=read();b[0]=-1;\n\tfor(int i=1;i<=n;++i){\n\t\tif(b[i]!=b[i-1]+1){\n\t\t\tif(b[i]%2) odd[++odd_num]=b[i];\n\t\t\telse even[++even_num]=b[i];\n\t\t}\n\t\tif(b[i]+1!=b[i+1]){\n\t\t\tif((b[i]+1)%2) odd[++odd_num]=b[i]+1;\n\t\t\telse even[++even_num]=b[i]+1;\n\t\t}\n\t}\n\tfor(int i=1;i<=odd_num;++i){\n\t\tfor(int j=1;j<=even_num;++j){\n\t\t\tif(check(abs(even[j]-odd[i]))) add_edge(i,j);\n\t\t}\n\t}\n\tfor(int i=1;i<=odd_num;++i){\n\t\ttim++;\n\t\tif(find(i)) k++;\n\t\telse break;\n\t}\n\tans=k+((even_num-k)/2+(odd_num-k)/2)*2+((odd_num-k)%2)*3;\n\tprintf(\"%d\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef complex<double> point;\n#define xx real()\n#define yy imag()\n\n#define REP(i, a, b) for(int i = (a); i < (int)(b); i++)\n#define REPN(i, a, b) for(int i = (a); i <= (int)(b); i++)\n#define FA(it, x) for(__typeof((x).begin()) it = (x).begin(); it != (x).end(); it++)\n#define SZ(x) (int)(x).size()\n#define BE(x) (x).begin(), (x).end()\n#define SORT(x) sort(BE(x))\n#define _1 first\n#define _2 second\n\n#define x1 gray_cat_x1\n#define y1 gray_cat_y1\n\ntemplate<class T> T gcd(T a, T b) { return b ? gcd(b, a % b) : a; }\n\n#define file \"I1\"\n\nconst double EPS = 1e-9;\nconst double PI = acos(-1.);\nconst int INF = 1e9;\nconst ll MOD = 1e9 + 7;\n\n// Maximal prime value\nconst int MAXVAL = 1e7 + 5;\n\nstruct erat_sieve{\n\tchar is_p[MAXVAL];\n\tint top_p;\n\n\tvoid get_primes(){\n\t\tis_p[0] = is_p[1] = 1;\n\t\tfor(int i = 2; i * i < MAXVAL; i++){\n\t\t\tif (!is_p[i]){\n\t\t\t\tfor(int j = i * i; j < MAXVAL; j += i){\n\t\t\t\t\tis_p[j] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n} erat;\n\nconst int MAXN = 2e2 + 5;\n\nstruct graph {\n\t// Number of vertices for two parts\n\tint n1, n2;\n\t\n\t// graph (1 -> 2)\n\tvi g[MAXN];\n\t\n\t// Col for Kuhn series (1st part)\n\tint col[MAXN];\n\t\n\t// Current color for Kuhn series\n\tint cur_col;\n\t\n\t// Nxt for Kuhn (2nd part)\n\tint nxt[MAXN];\n\t\n\t// Final matching\n\tvector<pii> matching;\n\t\n\t// Adding edge\n\tvoid add_edge(int a, int b){\t\t\n\t\tg[a].pb(b);\n\t}\t\n\t\n\t// Try_kuhn\n\tint try_kuhn(int s){\n\t\tif (col[s] == cur_col){\n\t\t\treturn 0;\n\t\t}\n\t\tcol[s] = cur_col;\n\t\tREP(i, 0, SZ(g[s])){\n\t\t\tint to = g[s][i];\n\t\t\tif (!nxt[to] || try_kuhn(nxt[to])){\n\t\t\t\tnxt[to] = s;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\t\n\t// Set random matching for speeding up Kuhn\n\tvoid set_random_matching(){\n\t\tREPN(i, 1, n1){\n\t\t\tif (col[i] == 0){\n\t\t\t\tREP(j, 0, SZ(g[i])){\n\t\t\t\t\tint to = g[i][j];\n\t\t\t\t\tif (nxt[to] == 0){\n\t\t\t\t\t\tcol[i] = 1;\n\t\t\t\t\t\tnxt[to] = i;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t// Find matching\n\tvoid get_matching(){\n\t\t// Init\n\t\tREPN(i, 1, n1){\n\t\t\tcol[i] = 0;\n\t\t}\n\t\tREPN(i, 1, n2){\n\t\t\tnxt[i] = 0;\n\t\t}\n\t\tmatching.clear();\n\t\t\n\t\t// Random matching\n\t\tcur_col = 1;\n\t\tset_random_matching();\n\t\t\t\t\t\t\n\t\t// Go Kuhn\n\t\tREPN(i, 1, n1){\n\t\t\tif (col[i] == 0){\n\t\t\t\tcur_col++;\n\t\t\t\ttry_kuhn(i);\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Restore matching\n\t\tREPN(i, 1, n2){\n\t\t\tif (nxt[i] != 0){\n\t\t\t\tmatching.pb(mp(nxt[i], i));\n\t\t\t\t//printf(\"%d %d\\n\", i, nxt[i]);\n\t\t\t}\n\t\t}\n\t}\t\n} gg;\n\nvi v0, v1, vals;\n\nint v[MAXN];\n\nvoid solve(){\n\terat.get_primes();\t\n\tint n;\n\tscanf(\"%d\", &n);\n\tREP(i, 0, n){\n\t\tscanf(\"%d\", &v[i]);\n\t}\n\tfor(int i = 0; i < n; ){\n\t\tint j;\n\t\tfor(j = i + 1; j < n && j - i == v[j] - v[i]; j++);\n\t\tj--;\n\t\tvals.pb(v[i]);\n\t\tvals.pb(v[j] + 1);\n\t\ti = j + 1;\n\t}\n\tREP(i, 0, SZ(vals)){\n\t\tif (vals[i] % 2 == 0){\n\t\t\tv0.pb(vals[i]);\n\t\t} else {\n\t\t\tv1.pb(vals[i]);\n\t\t}\n\t}\n\tgg.n2 = SZ(v0);\n\tgg.n1 = SZ(v1);\n\tREP(i, 0, gg.n1){\n\t\tREP(j, 0, gg.n2){\n\t\t\tint tmp = v1[i] - v0[j];\n\t\t\tif (tmp < 0){\n\t\t\t\ttmp = -tmp;\n\t\t\t}\n\t\t\tif (!erat.is_p[tmp]){\n\t\t\t\tgg.add_edge(i + 1, j + 1);\n\t\t\t\t//printf(\"%d %d\\n\", v1[i], v0[j]);\n\t\t\t}\n\t\t}\n\t}\n\tgg.get_matching();\n\tint cnt_m = SZ(gg.matching);\n\tint cnt_1 = gg.n1 - cnt_m;\n\tint cnt_2 = gg.n2 - cnt_m;\n\tint ans = cnt_m + (cnt_1 + cnt_1 % 2) + (cnt_2);\n\tprintf(\"%d\\n\", ans);\n\t//printf(\"%d\\n\", cnt_m);\t\n}   \n\nint main(){\n\n    //freopen(file\".in\", \"r\", stdin); freopen(file\".out\", \"w\", stdout);\n    int t = 1;\n    //cin >> t;\n    while(t--){\n        solve();    \n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <cstring>\nconst int maxP = 1e7;\nconst int maxn = 205;\nconst int S = 0;\nconst int T = 204;\nusing namespace std;\nvector <int> p; bool isp[maxP + 5];\nvoid install(){\n\tisp[1] = 1;\n\tfor (int i = 2; i <= maxP; i++){\n\t\tif (!isp[i]) p.push_back(i);\n\t\tfor (int j = 0; j < p.size() && i * p[j] <= maxP; j++){\n\t\t\tisp[i * p[j]] = 1;\n\t\t\tif (i % p[j] == 0) break;\n\t\t}\n\t}\n}\nstruct E{\n\tint to, nxt;\n}e[maxn * maxn];\nint head[maxn], tot = 1;\nvoid addedge(int u, int v){\n\te[++tot].to = v, e[tot].nxt = head[u];\n\thead[u] = tot;\n}\nint mat[maxn]; bool vis[maxn];\nbool dfs(int cur){\n\tfor (int i = head[cur]; i; i = e[i].nxt){\n\t\tint v = e[i].to;\n\t\tif (vis[v]) continue;\n\t\tvis[v] = 1;\n\t\tif (!mat[v] || dfs(mat[v])){\n\t\t\tmat[v] = cur; mat[cur] = v;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\nint abs(int x){return x < 0 ? -x : x;}\nvector <int> x[2]; int n, c[maxP + 5];\nint main(){\n\tinstall();\n\tscanf(\"%d\", &n);\n\tfor (int a, i = 1; i <= n; i++){\n\t\tscanf(\"%d\", &a); c[a]++;\n\t}\n\tfor (int i = 1; i <= maxP + 1; i++)\n\t\tif (c[i] != c[i - 1]) x[i & 1].push_back(i);\n\tfor (int i = 0; i < x[0].size(); i++)\n\t\tfor (int j = 0; j < x[1].size(); j++)\n\t\t\tif (!isp[abs(x[1][j] - x[0][i])]) addedge(i, j + x[0].size());\n\tint flow = 0;\n\tfor (int i = 0; i < x[0].size() + x[1].size(); i++){\n\t\tif (!mat[i]){\n\t\t\tmemset(vis, 0, sizeof vis);\n\t\t\tflow += dfs(i);\n\t\t}\n\t}\n\tprintf(\"%d\\n\", flow + (x[0].size() - flow) / 2 * 2 + (x[1].size() - flow) / 2 * 2 + (x[0].size() - flow) % 2 * 3);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define STOPIT\n#include <bits/stdc++.h>\n#define loop(n) for (lint ngtkana_is_a_genius = 0; ngtkana_is_a_genius < lint(n); ngtkana_is_a_genius++)\n#define rep(i, begin, end) for (lint i = lint(begin); (i) < lint(end); i++)\n#define all(v) v.begin(), v.end()\n#define rand(l, r) std::uniform_int_distribution<>(l, r)(mt)\nusing lint = long long;\nauto mt = std::mt19937_64(std::random_device{}());\nauto cmn = [](auto& a, auto b){ if (a > b) {a = b; return true;} return false; };\nauto cmx = [](auto& a, auto b){ if (a < b) {a = b; return true;} return false; };\nvoid debug_impl() { std::cerr << std::endl; }\ntemplate <typename Head, typename... Tail>\nvoid debug_impl(Head head, Tail... tail) { std::cerr << \" \" << head; debug_impl(tail...); }\n#ifndef STOPIT\n#define debug(...)\\\n\tdo {\\\n\t\tstd::cerr << std::boolalpha << \"[\" << #__VA_ARGS__ << \"]:\";\\\n\t\tdebug_impl(__VA_ARGS__);\\\n\t\tstd::cerr << std::noboolalpha;\\\n\t} while (false)\n#else\n#define debug(...) {}\n#endif\n\nclass bipartite_matching {\n\t\tint L, R;\n\t\tstd::vector<std::vector<int>> graph;\n\t\tstd::vector<int> match, level;\n\n\t\tbool bfs() {\n\t\t\tstd::fill(level.begin(), level.end(), -1);\n\t\t\tstd::queue<int> que;\n\t\t\tfor (auto i = 0; i < L; i++) {\n\t\t\t\tif (match.at(i) < 0) {\n\t\t\t\t\tlevel.at(i) = 0;\n\t\t\t\t\tque.emplace(i);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbool ret = false;\n\t\t\twhile (!que.empty()) {\n\t\t\t\tauto crr = que.front(); que.pop();\n\t\t\t\tfor (auto nxt : graph.at(crr)) {\n\t\t\t\t\tif (level.at(nxt) != -1) continue;\n\t\t\t\t\tlevel.at(nxt) = level.at(crr) + 1;\n\t\t\t\t\tauto w = match.at(nxt);\n\t\t\t\t\tif (w == -1)\n\t\t\t\t\t\t{ ret = true; }\n\t\t\t\t\telse if (level.at(w) == -1) {\n\t\t\t\t\t\tlevel.at(w) = level.at(crr) + 1;\n\t\t\t\t\t\tque.emplace(w);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\n\t\tbool dfs(int crr) {\n\t\t\tfor (auto nxt : graph.at(crr)) {\n\t\t\t\tassert(level.at(nxt) <= level.at(crr) + 1);\n\t\t\t\tif (level.at(nxt) < level.at(crr) + 1) continue;\n\t\t\t\tlevel.at(nxt) = -1;\n\t\t\t\tauto w = match.at(nxt);\n\t\t\t\tif (w == -1 || dfs(w)) {\n\t\t\t\t\tmatch.at(nxt) = crr;\n\t\t\t\t\tmatch.at(crr) = nxt;\n\t\t\t\t\tlevel.at(crr) = -1;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tlevel.at(crr) = -1;\n\t\t\treturn false;\n\t\t}\n\n\tpublic:\n\t\tbipartite_matching()=default;\n\t\tbipartite_matching(int L, int R):\n\t\t\tL(L), R(R), graph(L + R), match(L + R, -1), level(L + R)\n\t\t\t{}\n\n\t\tvoid insert(int u, int v) {\n\t\t\tv += L;\n\t\t\tgraph.at(u).emplace_back(v);\n\t\t\tgraph.at(v).emplace_back(u);\n\t\t}\n\n\n\t\tint build () {\n\t\t\tauto ret = 0;\n\t\t\twhile (bfs()) {\n\t\t\t\tfor (int i = 0; i < L; i++) {\n\t\t\t\t\tif (match.at(i) == -1 && dfs(i))\n\t\t\t\t\t\t{ ret++; }\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\n\t\tauto collect() const {return match;}\n\n\t\tauto count() const {\n\t\t\tauto k = L + R - std::count(match.begin(), match.end(), -1);\n\t\t\tassert(k % 2 == 0);\n\t\t\treturn k / 2;\n\t\t}\n};\n\ntemplate < typename Container, typename Value = typename Container::value_type, std::enable_if_t<!std::is_same< Container, std::string >::value, std::nullptr_t> = nullptr>\nstd::istream& operator>> (std::istream& is, Container& v)\n\t{ for (auto & x : v) { is >> x; } return is; }\n\ntemplate < typename Container, typename Value = typename Container::value_type, std::enable_if_t<!std::is_same< Container, std::string >::value, std::nullptr_t> = nullptr >\nstd::ostream& operator<< (std::ostream& os, Container const& v) {\n os << \"{\";\n\tfor (auto it = v.begin(); it != v.end(); it++)\n\t\t{os << (it != v.begin() ? \",\" : \"\") << *it;}\n\treturn os << \"}\";\n}\n\ntemplate < class Container, class Value = typename Container::value_type >\nauto run_length(Container const& v) {\n\tauto n = (int)v.size();\n\tif (n == 0)\n\t\t{ return std::vector< std::pair< Value, int > >{}; }\n\tauto pos = std::vector< int >{};\n\tfor (auto i = 1; i < n; i++) {\n\t\tif (v.at(i - 1) != v.at(i))\n\t\t\t{ pos.emplace_back(i); }\n\t}\n\tpos.emplace_back(n);\n\tauto m = (int)pos.size();\n\tauto len = std::vector< int >(m);\n\tstd::adjacent_difference(pos.begin(), pos.end(), len.begin());\n\tauto ret = std::vector< std::pair< Value, int > >(m);\n\tfor (auto i = 0; i != m; i++)\n\t\t{ ret.at(i) = {v.at(pos.at(i) - 1), len.at(i)}; }\n\treturn ret;\n}\n\ntemplate < std::size_t I, typename Container,\n\ttypename Value = typename std::tuple_element_t< I, typename Container::value_type >>\ninline auto project(Container const& v) {\n\tstd::vector< Value > ret(v.size());\n\tstd::transform(v.begin(), v.end(), ret.begin(), [](auto&& t){ return std::get< I >(t); });\n\treturn ret;\n}\n\nint main() {\n\tstd::cin.tie(0); std::cin.sync_with_stdio(false);\n\tconstexpr int xmax = 10'000'010;\n\tauto isp = [&] {\n\t\tstd::vector<int> isp(xmax, true);\n\t\tisp.at(0) = false;\n\t\tisp.at(1) = false;\n\t\tfor (lint p = 2; p < (lint)xmax; p++) {\n\t\t\tif (!isp.at(p)) continue;\n\t\t\tfor (lint j = 2; j * p < (lint)xmax; j++) {\n\t\t\t\tisp.at(p * j) = false;\n\t\t\t}\n\t\t}\n\t\treturn isp;\n\t}();\n\n\tint n; std::cin >> n;\n\tstd::vector<int> a(n); std::cin>>a;\n\tdebug(a);\n\n\tstd::vector<int> ckd(xmax,false);\n\tfor (int x : a) ckd.at(x) = true;\n\tauto c = project<1>(run_length(ckd));\n\tdebug(c);\n\tc.pop_back();\n\tdebug(c);\n\tstd::partial_sum(all(c), c.begin());\n\tassert((int)c.size() % 2 == 0);\n\n\tstd::vector<std::vector<int>> b(2);\n\tfor (int x : c) {\n\t  b.at(x%2).emplace_back(x);\n\t}\n\tdebug(b);\n\tstd::vector<int> sz(2);\n\tsz.at(0) = b.at(0).size();\n\tsz.at(1) = b.at(1).size();\n\tbipartite_matching bm(sz.at(0), sz.at(1));\n\n\trep(i0,0,sz.at(0))\n\trep(i1,0,sz.at(1)) {\n\t\tdebug(i0,i1);\n\t\tint x = b.at(0).at(i0);\n\t\tint y = b.at(1).at(i1);\n\t\tint z = x - y;\n\t\tif (z < 0) z = -z;\n\t\tif (isp.at(z)) {\n\t\t\tbm.insert(i0, i1);\n\t\t}\n\t}\n\tbm.build();\n\n\tint k = sz.at(0);\n\tint l = sz.at(1);\n\tint m = bm.count();\n\tdebug(k,l,m);\n\tint ans = m + (k-m) + (l-m) + (k-m)%2;\n\tstd::cout << ans << std::endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cstring>\nusing namespace std;\n\nconst int N = 205;\nconst int M = 1e7 + 5;\n\nint x[N], pos[N];\n\nclass BipartialGraph {\nprivate :\n  bool G[N][N], vis[N];\n  int lkn[N];\npublic :\n  BipartialGraph() {\n    memset(G, 0, sizeof G);\n  }\n  inline void Add(int x, int y) {\n    G[x][y] = 1;\n  }\n  inline bool Match(int x) {\n    for (int i = 0; i < N; i ++)\n      if (G[x][i] && !vis[i]) {\n\tvis[i] = 1;\n\tif (lkn[i] == -1 || Match(lkn[i])) {\n\t  lkn[i] = x;\n\t  return 1;\n\t}\n      }\n    return 0;\n  }\n  inline int MaxMatch() {\n    int ret = 0;\n    memset(lkn, -1, sizeof lkn);\n    for (int i = 0; i < N; i ++) {\n      memset(vis, 0, sizeof vis);\n      if (Match(i)) ret ++;\n    }\n    return ret;\n  }\n} solver;\n\nbool notp[M];\nint prime[M / 5];\n\ninline void  make_prime(int Max) {\n  int tot = 0;\n  for (int i = 2; i <= Max; i ++) {\n    if (!notp[i]) prime[++ tot] = i;\n    for (int j = 1; j <= tot && i * prime[j] <= Max; j ++) {\n      notp[i * prime[j]] = 1;\n      if (i % prime[j] == 0) break;\n    }\n  }\n  notp[2] = 1;\n}\n\nint main() {\n  int n, m = 0;\n  scanf(\"%d\", &n);\n  for (int i = 1; i <= n; i ++) scanf(\"%d\", &x[i]);\n  for (int i = 1; i <= n; i ++) {\n    if (!i || x[i - 1] != x[i] - 1) pos[++ m] = x[i];\n    if (i == n || x[i + 1] != x[i] + 1) pos[++ m] = x[i] + 1;\n  }\n  make_prime(pos[m] - pos[1]);\n  for (int i = 1; i <= m; i ++)\n    for (int j = i + 1; j <= m; j ++)\n      if (!notp[pos[j] - pos[i]]) solver.Add(i, j);\n  int k = solver.MaxMatch(), ev = 0, od = 0;\n  for (int i = 1; i <= m; i ++) {\n    if (pos[i] & 1) od ++;\n    else ev ++;\n  }\n  ev -= k; od -= k;\n  int ans = k + (ev / 2 + od / 2) * 2 + 3 * (ev & 1);\n  printf(\"%d\\n\", ans);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Dinic{\n    struct edge {\n        int64_t to, cap, rev;\n        edge(int64_t to, int64_t cap, int64_t rev):to(to), cap(cap), rev(rev){}\n    };\n\n    int N, S, T;\n    int64_t flow = 0;\n    const int64_t INF = 1e18;\n    vector<int> level, iter;\n    vector<vector<edge>> G;\n\n    Dinic(int N, int S, int T):N(N), S(S), T(T){\n        flow = 0;\n        level.resize(N);\n        iter.resize(N);\n        G.resize(N);\n    }\n\n    void add_edge(int from, int to, int64_t cap){\n        G[from].emplace_back(to, cap, G[to].size());\n        G[to].emplace_back(from, 0, G[from].size()-1);\n    }\n\n    void bfs(int s){\n        fill(level.begin(), level.end(), -1);\n        queue<int> que;\n        level[s] = 0;\n        que.push(s);\n        while(que.size()){\n            int v = que.front(); que.pop();\n            for(auto& e : G[v]){\n                if(e.cap > 0 && level[e.to] < 0){\n                    level[e.to] = level[v] + 1;\n                    que.push(e.to);\n                }\n            }\n        }\n    }\n\n    int64_t dfs(int v, int t, int64_t f){\n        if(v == t) return f;\n        for(int& i=iter[v]; i<(int)G[v].size(); i++){\n            auto& e = G[v][i];\n            if(e.cap > 0 && level[v] < level[e.to]){\n                int64_t d = dfs(e.to, t, min(f, e.cap));\n                if(d > 0){\n                    e.cap -= d;\n                    G[e.to][e.rev].cap += d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n\n    int64_t max_flow(){\n        while(true){\n            bfs(S);\n            if(level[T] < 0) return flow;\n            fill(iter.begin(), iter.end(), 0);\n            while(true){\n                int64_t f = dfs(S, T, INF);\n                if(f == 0) break;\n                flow += f;\n            }\n        }\n    }\n};\n\nbool is_prime(int64_t n){\n    if(n <= 1) return false;\n    for(int64_t i=2; i*i<=n; i++) if(n % i == 0) return false;\n    return true;\n}\n\nint main(){\n    int N;\n    cin >> N;\n    map<int, int> diff;\n    for(int i=0; i<N; i++){\n        int x;\n        cin >> x;\n        diff[x-1]++;\n        diff[x]++;\n    }\n\n    vector<int> A[2];\n    for(auto& p : diff) if(p.second%2) A[p.first%2].push_back(p.first);\n    int sz[2];\n    for(int k=0; k<2; k++) sz[k] = A[k].size();\n\n    int S = sz[0]+sz[1];\n    int T = S+1;\n    Dinic solver(T+1, S, T);\n    for(int i=0; i<sz[0]; i++) solver.add_edge(S, i, 1);\n    for(int i=0; i<sz[1]; i++) solver.add_edge(sz[0]+i, T, 1);\n    for(int i=0; i<sz[0]; i++) for(int j=0; j<sz[1]; j++){\n        int d = abs(A[0][i] - A[1][j]);\n        if(d%2 && is_prime(d)) solver.add_edge(i, sz[0]+j, 1);\n    }\n\n    int m = solver.max_flow();\n    int r0 = sz[0]-m, r1 = sz[1]-m;\n    int ans = m + r0/2*2 + r1/2*2 + (r0%2)*3;\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n\nconst int maxn = 2e5+7;\nconst int maxm = 1e7+7;\nint n,a[maxm];\nvector<int>v[2],E[maxn];\nbool bio[maxn];\nint conn[maxn];\nvoid init(){\n    scanf(\"%d\",&n);\n    for(int i=1;i<=n;i++){\n        int x;\n        scanf(\"%d\",&x);\n        a[x]=1;\n    }\n}\nbool prime(int x){\n    if(x==1)return false;\n    for(int i=2;i*i<=x;i++)\n        if(x%i==0)return false;\n    return true;\n}\nbool dfs(int x){\n    if(bio[x])return false;\n    bio[x]=true;\n    for(auto it : E[x]){\n        if(conn[it] == -1 || dfs(conn[it])){\n            conn[it] = x;\n            return true;\n        }\n    }\n    return false;\n}\nint main(){\n    init();\n    memset(conn,-1,sizeof(conn));\n    for(int i=maxm-1;i;i--){\n        a[i]^=a[i-1];\n        if(a[i])v[i%2].push_back(i);\n    }\n    for(int i=0;i<v[0].size();i++){\n        for(int j=0;j<v[1].size();j++){\n            if(prime(abs(v[0][i]-v[1][j]))){\n                E[i].push_back(j);\n            }\n        }\n    }\n    \n    int match = 0;\n    for(int i=0;i<v[0].size();i++){\n        memset(bio,false,sizeof(bio));\n        match+=dfs(i);\n    }\n    cout<<v[0].size()+v[1].size()-match+(v[0].size()-match)%2;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/************************************************\n * Au: Hany01\n * Date: Jul 16th, 2018\n * Prob: ARC080 F\n * Email: hany01@foxmail.com\n * Inst: Yali High School\n************************************************/\n\n#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<int, int> PII;\n#define File(a) freopen(a\".in\", \"r\", stdin), freopen(a\".out\", \"w\", stdout)\n#define rep(i, j) for (register int i = 0, i##_end_ = (j); i < i##_end_; ++ i)\n#define For(i, j, k) for (register int i = (j), i##_end_ = (k); i <= i##_end_; ++ i)\n#define Fordown(i, j, k) for (register int i = (j), i##_end_ = (k); i >= i##_end_; -- i)\n#define Set(a, b) memset(a, b, sizeof(a))\n#define Cpy(a, b) memcpy(a, b, sizeof(a))\n#define x first\n#define y second\n#define pb(a) push_back(a)\n#define mp(a, b) make_pair(a, b)\n#define ALL(a) (a).begin(), (a).end()\n#define SZ(a) ((int)(a).size())\n#define INF (0x3f3f3f3f)\n#define INF1 (2139062143)\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define y1 wozenmezhemecaia\n\ntemplate <typename T> inline bool chkmax(T &a, T b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> inline bool chkmin(T &a, T b) { return b < a ? a = b, 1 : 0; }\n\ninline int read() {\n\tstatic int _, __; static char c_;\n    for (_ = 0, __ = 1, c_ = getchar(); c_ < '0' || c_ > '9'; c_ = getchar()) if (c_ == '-') __ = -1;\n    for ( ; c_ >= '0' && c_ <= '9'; c_ = getchar()) _ = (_ << 1) + (_ << 3) + (c_ ^ 48);\n    return _ * __;\n}\n\nconst int maxn = 105, maxm = 1e7 + 9, M = 1e7 + 5, maxe = maxn * maxn;\n\nint n, mk[maxm], vis[maxn], beg[maxn], v[maxe], nex[maxe], pr[maxm], np[maxm], prs, tot1, tot2, S[maxn << 1], T[maxn << 1], e, cnt, mat[maxn];\n\ninline void init(int N)\n{\n\tnp[1] = 1;\n\tFor(i, 2, N) {\n\t\tif (!np[i]) pr[++ prs] = i;\n\t\tfor (register int j = 1; j <= prs && pr[j] * i <= N; ++ j) {\n\t\t\tnp[pr[j] * i] = 1;\n\t\t\tif (!(i % pr[j])) break;\n\t\t}\n\t}\n}\n\ninline void add(int uu, int vv) { v[++ e] = vv, nex[e] = beg[uu], beg[uu] = e; }\n\nint dfs(int u) {\n\tfor (register int i = beg[u]; i; i = nex[i])\n\t\tif (!vis[v[i]]) {\n\t\t\tvis[v[i]] = 1;\n\t\t\tif (!mat[v[i]] || dfs(mat[v[i]])) { mat[v[i]] = u; return 1; }\n\t\t}\n\treturn 0;\n}\n\nint main()\n{\n#ifdef hany01\n\tFile(\"arc080f\");\n#endif\n\n\tn = read(), init(M);\n\tFor(i, 1, n) mk[read()] = 1;\n\tFor(i, 1, M) if (mk[i] != mk[i - 1])\n\t\t(i & 1) ? (S[++ tot1] = i) : (T[++ tot2] = i);\n\n\tFor(i, 1, tot1) For(j, 1, tot2)\n\t\tif (!np[abs(S[i] - T[j])]) add(i, j);\n\n\tFor(i, 1, tot1) {\n\t\tSet(vis, 0);\n\t\tif (dfs(i)) ++ cnt;\n\t}\n\tprintf(\"%d\\n\", cnt + ((tot1 - cnt) >> 1) * 2 + ((tot2 - cnt) >> 1) * 2 + (((tot1 - cnt) & 1)) * 3);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\nusing namespace std;\nconst int N=110;\nbool f[10001000],fl[N][N],fla[N];\nint n,p[1000100],cnt,a[N],cot,from[N],nj[N],no[N];\nbool match(int x)\n{\n    if(fla[x]) return false;\n    fla[x]=true;\n    for(int i=1;i<=nj[0];++i)\n        if(fl[x][i]&&(from[i]==0||match(from[i])))\n        {\n            from[i]=x;\n            return true;\n        }\n    return false;\n}\nvoid init()\n{\n    for(int i=2;i<=1000050;++i)\n    {\n        if(!f[i]) p[++cnt]=i;\n            for(int j=1;j<=cnt&&p[j]*i<=1000050;++j)\n            {\n                f[p[j]*i]=true;\n                if(i%p[j]==0) break;\n            }\n    }\n}\nint main()\n{\n    ios::sync_with_stdio(false);\n    init();\n    f[2]=false;\n    cin>>n;\n    int t=-10,t1;\n    for(int i=1;i<=n;++i)\n    {\n        cin>>t1;\n        if(t1-t!=1) \n        {\n            a[cot++]=t+1;\n            if(t1-t!=2) a[cot++]=t1;\n        }\n        t=t1;\n    }\n    a[cot]=t1+1;\n    for(int i=1;i<=cot;++i)\n    {\n        if(a[i]%2)\n            nj[++nj[0]]=a[i];\n        else\n            no[++no[0]]=a[i];\n    }\n    for(int i=1;i<=nj[0];++i)\n        for(int j=1;j<=no[0];++j)\n            fl[i][j]=!f[abs(nj[i]-no[i])];\n    int ans=0;\n    for(int i=1;i<=nj[0];++i)\n    {\n        memset(fla,false,sizeof(fla));\n        if(match(i)) ans++;\n    }\n    cout<< ans+(nj[0]-ans)/2*2+(no[0]-ans)/2*2+(nj[0]-ans)%2*3 <<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// Prime Flip\n// * frank_c1\n// * 2017 / 12 / 24\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int maxn = 205;\nconst int maxM = (int)(1e7) + 5;\nint pr[maxM], chk[maxM];\n\nvoid gen() {\n\tint mx = (int)(1e7) + 1, tot = 0;\n\tchk[1] = 1;\n\tfor (int i = 2; i <= mx; ++i) {\n\t\tif (!chk[i]) {\n\t\t\tpr[++tot] = i;\n\t\t}\n\t\tfor (int j = 1; j <= tot; ++j) {\n\t\t\tif (i * pr[j] > mx) break;\n\t\t\tchk[i * pr[j]] = 1;\n\t\t\tif (i % pr[j] == 0) break;\n\t\t}\n\t}\n}\n\nint a[maxn], b[maxn], vi[maxn], lk[maxn];\nint idx;\n\nint Find(int x) {\n\tfor (int i = 1; i <= idx; ++i) \n\t\tif (!vi[i] && !(b[i] & 1)) {\n\t\t\tvi[i] = 1;\n\t\t\tif (!chk[max(b[x], b[i]) - min(b[x], b[i])]) {\n\t\t\t\tif (!lk[i] || Find(lk[i])) {\n\t\t\t\t\tlk[i] = x; return 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\treturn 0;\n}\n\nint main() {\n\tgen();\n\tint n;\n\tscanf(\"%d\", &n); a[0] = -1;\n\tfor (int i = 1; i <= n; ++i) scanf(\"%d\", &a[i]);\n\tfor (int i = 1; i <= n; ++i) {\n\t\tif (a[i] - 1 != a[i - 1]) b[++idx] = a[i];\n\t\tif (a[i] + 1 != a[i + 1]) b[++idx] = a[i] + 1;\n\t}\n\tint ret = 0, cnt = 0;\n\tfor (int i = 1; i <= idx; ++i) if (b[i] & 1) {\n\t\tmemset(vi, 0, sizeof(vi)); ret += Find(i); ++cnt;\n\t}\n\treturn printf(\"%d\\n\", ret + ((cnt - ret) / 2 + (idx - cnt - ret) / 2) * 2 + ((cnt - ret) % 2) * 3), 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define fi first\n#define se second\n#define mp make_pair\n#define gc getchar\n#define pb push_back\n#define eb emplace_back\n#define all(x) (x).begin(),(x).end()\n#define x1 uvuvwevwevwe\n#define y1 onyetenyevwe\n#define x2 ugwemubwem\n#define y2 ossas\ntypedef long long LL;\ntypedef long double LD;\ntypedef pair<int,int> pii;\nconst int batasprima=5000;\ntemplate <typename T> void scan(T &angka){\n\tangka=0;char input=gc();T kali=1;\n\twhile(!(48<=input&&input<=57)){\tif(input=='-')\tkali=-1;input=gc();}\n\twhile(48<=input&&input<=57)\tangka=(angka<<3)+(angka<<1)+input-48,input=gc();angka*=kali;\n}\ntemplate <typename T1,typename T2> void scan(T1 &angka1,T2 &angka2){\n\tscan(angka1);scan(angka2);\n}\nint match[205],totalmatch=0,k=0,ans;\nvector <int> daftar,adj[205],prime;\nbitset<205> visited;\nvoid sieve(){\n\tbool isprime[batasprima+5];\n\tmemset(isprime,true,sizeof(isprime));\n\tfor(int i=2;i<=batasprima;i++)\n\t{\n\t\tif(!isprime[i])\n\t\t\tcontinue;\n\t\tprime.pb(i);\n\t\tfor(int j=i+i;j<=batasprima;j+=i)\n\t\t\tisprime[j]=false;\n\t}\n}\nbool isprime(int angka){\n\tif(angka<2)\n\t\treturn false;\n\tfor(auto isi:prime)\n\t{\n\t\tif(angka%isi==0)\n\t\t\treturn false;\n\t}\n\treturn true;\n}\nbool matching(int pos){\n\tif(visited[pos])\n\t\treturn false;\n\tvisited[pos]=true;\n\tfor(auto isi:adj[pos])\n\t{\n\t\tif(match[isi]==-1||matching(match[isi]))\n\t\t{\n\t\t\tmatch[isi]=pos;\n\t\t\tmatch[pos]=isi;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\nvoid buatgraph(){\t\n\tfor(int i=0;i<daftar.size();i++)\n\t{\n\t\tfor(int j=0;j<daftar.size();j++)\n\t\t{\n\t\t\tif(isprime(abs(daftar[i]-daftar[j])))\n\t\t\t\tadj[i].pb(j);\n\t\t}\n\t}\n}\nvoid hitungk(){\n\tfor(int i=0;i<daftar.size();i++)\n\t{\n\t\tif(match[i]!=-1)\n\t\t\tcontinue;\n\t\tvisited.reset();\n\t\tif(matching(i))\n\t\t\tk++;\n\t}\n}\nvoid hitungans(){\n\tint genap=0,ganjil=0;\n\tfor(auto isi:daftar)\n\t{\n\t\tif(isi&1)\n\t\t\tganjil++;\n\t\telse\n\t\t\tgenap++;\n\t}\n\tassert(ganjil>=k&&genap>=k);\n\tans=k+(ganjil/2+genap/2)*2+(ganjil%2)*3;\n}\nvoid isidaftar(){\n\tint n;\n\tscan(n);\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tint input;\n\t\tscan(input);\n\t\tif(daftar.size()&&daftar.back()==input)\n\t\t\tdaftar[daftar.size()-1]=input+1;\t\t\t//nanti mau sa coba\n\t\telse\n\t\t\tdaftar.pb(input),daftar.pb(input+1);\n\t}\n}\nint main()\n{\n\tsieve();\n\tmemset(match,-1,sizeof(match));\n\tisidaftar();\n\tbuatgraph();\n\thitungk();\n\thitungans();\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 10000005\n#define M 505\nusing namespace std;\nint n,cnt1=0,cnt2=0,cnt,p1[M],p2[M],a[M],b[N],pr[M*M*100],match[N];bool vis[N],mp[M][M];\nbool dfs(int u){\n\tfor (int i=1;i<=cnt2;i++){\n\t\tif (!mp[u][i]) continue;\n\t\tif (!match[i]||dfs(match[i])){\n\t\t\tmatch[i]=u;\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\nint main(){\n\tscanf(\"%d\",&n);int mx=0;\n\tfor (int i=1;i<=n;i++) scanf(\"%d\",&a[i]),b[a[i]]=1,mx=max(mx,a[i]);\n\tfor (int i=1;i<=mx+1;i++)\n\t\tif (b[i]!=b[i-1]){\n\t\t\tif (i&1) p1[++cnt1]=i;\n\t\t\telse p2[++cnt2]=i;\n\t\t}\n\tfor (int i=2;i<=1e7;i++){\n\t\tif (!vis[i]) pr[++cnt]=i;\n\t\tfor (int j=1;j<=cnt;j++){\n\t\t\tif (i*pr[j]>=N) break;\n\t\t\tvis[i*pr[j]]=1;\n\t\t\tif (i%pr[j]==0) break;\n\t\t}\n\t}\n\tvis[2]=vis[1]=1;int ans=0;\n\tfor (int i=1;i<=cnt1;i++)\n\t\tfor (int j=1;j<=cnt2;j++)\n\t\t\tif (!vis[abs(p1[i]-p2[j])]) mp[i][j]=1;\n\tfor (int i=1;i<=cnt1;i++) if (dfs(i)) ans++;\n\tint now1=cnt1-ans;int now2=cnt2-ans;\n\tans=ans+(now1/2)*2+(now2/2)*2;\n\tif (now1&1) ans+=3;\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define INF INT_MAX\n#define MAXN 205\nstruct edge{\n    int u,v,w;\n    edge(){}\n    edge(int u,int v,int w):u(u),v(v),w(w){}\n};\nint n,n_x;\nedge g[MAXN*2+1][MAXN*2+1];\nint lab[MAXN*2+1];\nint match[MAXN*2+1],slack[MAXN*2+1],st[MAXN*2+1],pa[MAXN*2+1];\nint flower_from[MAXN*2+1][MAXN+1],S[MAXN*2+1],vis[MAXN*2+1];\nvector<int> flower[MAXN*2+1];\nqueue<int> q;\ninline int e_delta(const edge &e){ // does not work inside blossoms\n    return lab[e.u]+lab[e.v]-g[e.u][e.v].w*2;\n}\ninline void update_slack(int u,int x){\n    if(!slack[x]||e_delta(g[u][x])<e_delta(g[slack[x]][x]))slack[x]=u;\n}\ninline void set_slack(int x){\n    slack[x]=0;\n    for(int u=1;u<=n;++u)\n        if(g[u][x].w>0&&st[u]!=x&&S[st[u]]==0)update_slack(u,x);\n}\nvoid q_push(int x){\n    if(x<=n)q.push(x);\n    else for(size_t i=0;i<flower[x].size();i++)q_push(flower[x][i]);\n}\ninline void set_st(int x,int b){\n    st[x]=b;\n    if(x>n)for(size_t i=0;i<flower[x].size();++i)\n               set_st(flower[x][i],b);\n}\ninline int get_pr(int b,int xr){\n    int pr=find(flower[b].begin(),flower[b].end(),xr)-flower[b].begin();\n    if(pr%2==1){//檢查他在前一層圖是奇點還是偶點\n        reverse(flower[b].begin()+1,flower[b].end());\n        return (int)flower[b].size()-pr;\n    }else return pr;\n}\ninline void set_match(int u,int v){\n    match[u]=g[u][v].v;\n    if(u>n){\n        edge e=g[u][v];\n        int xr=flower_from[u][e.u],pr=get_pr(u,xr);\n        for(int i=0;i<pr;++i)set_match(flower[u][i],flower[u][i^1]);\n        set_match(xr,v);\n        rotate(flower[u].begin(),flower[u].begin()+pr,flower[u].end());\n    }\n}\ninline void augment(int u,int v){\n    for(;;){\n        int xnv=st[match[u]];\n        set_match(u,v);\n        if(!xnv)return;\n        set_match(xnv,st[pa[xnv]]);\n        u=st[pa[xnv]],v=xnv;\n    }\n}\ninline int get_lca(int u,int v){\n    static int t=0;\n    for(++t;u||v;swap(u,v)){\n        if(u==0)continue;\n        if(vis[u]==t)return u;\n        vis[u]=t;//這種方法可以不用清空v陣列\n        u=st[match[u]];\n        if(u)u=st[pa[u]];\n    }\n    return 0;\n}\ninline void add_blossom(int u,int lca,int v){\n    int b=n+1;\n    while(b<=n_x&&st[b])++b;\n    if(b>n_x)++n_x;\n    lab[b]=0,S[b]=0;\n    match[b]=match[lca];\n    flower[b].clear();\n    flower[b].push_back(lca);\n    for(int x=u,y;x!=lca;x=st[pa[y]])\n        flower[b].push_back(x),flower[b].push_back(y=st[match[x]]),q_push(y);\n    reverse(flower[b].begin()+1,flower[b].end());\n    for(int x=v,y;x!=lca;x=st[pa[y]])\n        flower[b].push_back(x),flower[b].push_back(y=st[match[x]]),q_push(y);\n    set_st(b,b);\n    for(int x=1;x<=n_x;++x)g[b][x].w=g[x][b].w=0;\n    for(int x=1;x<=n;++x)flower_from[b][x]=0;\n    for(size_t i=0;i<flower[b].size();++i){\n        int xs=flower[b][i];\n        for(int x=1;x<=n_x;++x)\n            if(g[b][x].w==0||e_delta(g[xs][x])<e_delta(g[b][x]))\n                g[b][x]=g[xs][x],g[x][b]=g[x][xs];\n        for(int x=1;x<=n;++x)\n            if(flower_from[xs][x])flower_from[b][x]=xs;\n    }\n    set_slack(b);\n}\ninline void expand_blossom(int b){ // S[b] == 1\n    for(size_t i=0;i<flower[b].size();++i)\n        set_st(flower[b][i],flower[b][i]);\n    int xr=flower_from[b][g[b][pa[b]].u],pr=get_pr(b,xr);\n    for(int i=0;i<pr;i+=2){\n        int xs=flower[b][i],xns=flower[b][i+1];\n        pa[xs]=g[xns][xs].u;\n        S[xs]=1,S[xns]=0;\n        slack[xs]=0,set_slack(xns);\n        q_push(xns);\n    }\n    S[xr]=1,pa[xr]=pa[b];\n    for(size_t i=pr+1;i<flower[b].size();++i){\n        int xs=flower[b][i];\n        S[xs]=-1,set_slack(xs);\n    }\n    st[b]=0;\n}\ninline bool on_found_edge(const edge &e){\n    int u=st[e.u],v=st[e.v];\n    if(S[v]==-1){\n        pa[v]=e.u,S[v]=1;\n        int nu=st[match[v]];\n        slack[v]=slack[nu]=0;\n        S[nu]=0,q_push(nu);\n    }else if(S[v]==0){\n        int lca=get_lca(u,v);\n        if(!lca)return augment(u,v),augment(v,u),true;\n        else add_blossom(u,lca,v);\n    }\n    return false;\n}\ninline bool matching(){\n    memset(S+1,-1,sizeof(int)*n_x);\n    memset(slack+1,0,sizeof(int)*n_x);\n    q=queue<int>();\n    for(int x=1;x<=n_x;++x)\n        if(st[x]==x&&!match[x])pa[x]=0,S[x]=0,q_push(x);\n    if(q.empty())return false;\n    for(;;){\n        while(q.size()){\n            int u=q.front();q.pop();\n            if(S[st[u]]==1)continue;\n            for(int v=1;v<=n;++v)\n                if(g[u][v].w>0&&st[u]!=st[v]){\n                    if(e_delta(g[u][v])==0){\n                        if(on_found_edge(g[u][v]))return true;\n                    }else update_slack(u,st[v]);\n                }\n        }\n        int d=INF;\n        for(int b=n+1;b<=n_x;++b)\n            if(st[b]==b&&S[b]==1)d=min(d,lab[b]/2);\n        for(int x=1;x<=n_x;++x)\n            if(st[x]==x&&slack[x]){\n                if(S[x]==-1)d=min(d,e_delta(g[slack[x]][x]));\n                else if(S[x]==0)d=min(d,e_delta(g[slack[x]][x])/2);\n            }\n        for(int u=1;u<=n;++u){\n            if(S[st[u]]==0){\n                if(lab[u]<=d)return 0;\n                lab[u]-=d;\n            }else if(S[st[u]]==1)lab[u]+=d;\n        }\n        for(int b=n+1;b<=n_x;++b)\n            if(st[b]==b){\n                if(S[st[b]]==0)lab[b]+=d*2;\n                else if(S[st[b]]==1)lab[b]-=d*2;\n            }\n        q=queue<int>();\n        for(int x=1;x<=n_x;++x)\n            if(st[x]==x&&slack[x]&&st[slack[x]]!=x&&e_delta(g[slack[x]][x])==0)\n                if(on_found_edge(g[slack[x]][x]))return true;\n        for(int b=n+1;b<=n_x;++b)\n            if(st[b]==b&&S[b]==1&&lab[b]==0)expand_blossom(b);\n    }\n    return false;\n}\ninline pair<long long,int> weight_blossom(){\n    memset(match+1,0,sizeof(int)*n);\n    n_x=n;\n    int n_matches=0;\n    long long tot_weight=0;\n    for(int u=0;u<=n;++u)st[u]=u,flower[u].clear();\n    int w_max=0;\n    for(int u=1;u<=n;++u)\n        for(int v=1;v<=n;++v){\n            flower_from[u][v]=(u==v?u:0);\n            w_max=max(w_max,g[u][v].w);\n        }\n    for(int u=1;u<=n;++u)lab[u]=w_max;\n    while(matching())++n_matches;\n    for(int u=1;u<=n;++u)\n        if(match[u]&&match[u]<u)\n            tot_weight+=g[u][match[u]].w;\n    return make_pair(tot_weight,n_matches);\n}\ninline void init_weight_graph(){\n    for(int u=1;u<=n;++u)\n        for(int v=1;v<=n;++v)\n            g[u][v]=edge(u,v,0);\n}\ninline bool isprime(int x) {\n    if (x < 2) return 0;\n    for (int i = 2 ; i * i <= x ; ++ i) {\n        if (x % i == 0) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    scanf(\"%d\" , &n);\n    set<int> d;\n    map<int , bool> h;\n    for (int i = 0 ; i < n ; ++ i) {\n        int x;\n        scanf(\"%d\" , &x);\n        d.insert(x);\n        d.insert(x - 1);\n        h[x] = 1;\n    }\n    vector<int> v;\n    for (auto &x : d) {\n        if (h[x + 1] ^ h[x]) {\n            v.push_back(x);\n        }\n    }\n    n = v.size();\n    //for (auto &y : v) cout << y << endl;\n    init_weight_graph();\n    for (int i = 1 ; i <= n ; ++ i) {\n        for (int j = i + 1 ; j <= n ; ++ j) {\n            int dd = abs(v[i - 1] - v[j - 1]) , ww;\n            if (isprime(dd)) {\n                ww = 1;\n            } else if (dd & 1) {\n                ww = 3;\n            } else {\n                ww = 2;\n            }\n            g[i][j].w = g[j][i].w = 10000 - ww;\n            //cout << i << ' ' << j << ' ' << g[i][j].w << endl;\n        }\n    }\n    printf(\"%lld\\n\", n * 5000 - weight_blossom().first);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \nconst int maxn = 1e7 + 700;\n \n \nint n,fre[maxn],p[220],ispr[maxn],even,odd,wrong;\nvector <int> edge[220],v2;\n \nbool fin(int u) {\n    if (fre[u]==wrong) return false;\n    fre[u]=wrong;\n    for (int j=0;j<edge[u].size();j++) {\n        int v=edge[u][j];\n       // cout<<u<<\" \"<<v<<endl;\n        if (p[v]==0 || fin(p[v])) {\n            p[v]=u;\n            return true;\n        }\n    }\n    return false;\n}\n \nint main() {\n  //  freopen(\"in.txt\",\"r\",stdin);\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    ispr[1]=1;\n    for (int i=2;i<maxn;i++)\n        if (ispr[i]==0) {\n            for (int j=i+i;j<maxn;j+=i) ispr[j]=1;\n        }\n    cin>>n;\n    for (int i=1;i<=n;i++) {\n        int x;\n        cin>>x;\n        fre[x]^=1;\n        fre[x+1]^=1;\n    }\n    even=0; odd=0; wrong=2;\n    for (int i=0;i<maxn;i++)\n        if (fre[i]==1) {\n            v2.push_back(i);\n            if (i%2==0) even++;\n            else odd++;\n        }\n    // for (int i=0;i<v2.size();i++) cout<<v2[i]<<\" \";\n   //  cout<<endl;\n   // cout<<\" \" <<even<<\" \"<<odd<<endl;\n    for (int i=0;i<v2.size();i++)\n        for (int j=0;j<v2.size();j++)\n            if (v2[i]%2==0 && v2[j]%2==1 && ispr[ abs(v2[j] - v2[i]) ]==0 && abs(v2[j] - v2[i])%2==1) {\n                edge[i].push_back(j);\n                edge[j].push_back(i);\n            }\n    int cnt=0;\n    for (int i=0;i<v2.size();i++) {\n        wrong++;\n        cnt+=(fin(i));\n    }\n    cout<< cnt + ((even-cnt)/2 + (odd-cnt)/2) * 2 + ((even-cnt)%2)*3;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace std;\nusing namespace __gnu_pbds;\n\n#define ll long long\n#define db long double\n#define ii pair<int,int>\n#define vi vector<int>\n#define fi first\n#define se second\n#define sz(a) (int)(a).size()\n#define all(a) (a).begin(),(a).end()\n#define pb push_back\n#define mp make_pair\n#define FN(i, n) for (int i = 0; i < (int)(n); ++i)\n#define FEN(i,n) for (int i = 1;i <= (int)(n); ++i)\n#define rep(i,a,b) for(int i=a;i<b;i++)\n#define repv(i,a,b) for(int i=b-1;i>=a;i--)\n#define SET(A, val) memset(A, val, sizeof(A))\ntypedef tree<int ,null_type,less<int>,rb_tree_tag,tree_order_statistics_node_update>ordered_set ;\n// order_of_key (val): returns the no. of values less than val\n// find_by_order (k): returns the kth largest element.(0-based)\n#define TRACE\n#ifdef TRACE\n#define trace(...) __f(#__VA_ARGS__, __VA_ARGS__)\ntemplate <typename Arg1>\nvoid __f(const char* name, Arg1&& arg1){\n  cerr << name << \" : \" << arg1 << std::endl;\n}\ntemplate <typename Arg1, typename... Args>\nvoid __f(const char* names, Arg1&& arg1, Args&&... args){\n  const char* comma = strchr(names + 1, ','); cerr.write(names, comma - names) << \" : \" << arg1<<\" | \";__f(comma+1, args...);\n}\n#else\n#define trace(...)\n#endif\nconst int N=205,L=1e7+5;\nbool mark[L],prime[L];\nnamespace match\n{\n  const int N=205;\n  int l[N],r[N],n,m;\n  bool a[N][N],seen[N];\n  bool findmatch(int i)\n  {\n    rep(j,0,m)\n      {\n\tif(a[i][j] && !seen[j])\n\t  {\n\t    seen[j]=true;\n\t    if(r[j]<0 || findmatch(r[j]))\n\t      {\n\t\tl[i]=j; r[j]=i;\n\t\treturn true;\n\t      }\n\t  }\n      }\n    return false;\n  }\n  int bipartitematch()\n  {\n    int cnt=0;\n    rep(i,0,n) l[i]=-1;\n    rep(i,0,m) r[i]=-1;\n    rep(i,0,n)\n      {\n\trep(j,0,m) seen[j]=false;\n\tif(findmatch(i)) cnt++;\n      }\n    return cnt;\n  }\n};\nint main()\n{\n  std::ios::sync_with_stdio(false);\n  cin.tie(NULL) ; cout.tie(NULL) ;\n  memset(prime,true,sizeof(prime));\n  prime[0]=prime[1]=false;\n  rep(i,2,L)\n    {\n      if(!prime[i]) continue;\n      for(int j=2*i;j<L;j+=i)\n\tprime[j]=false;\n    }\n  prime[2]=false;\n  int n,x;\n  cin>>n;\n  rep(i,1,n+1)\n    {\n      cin>>x;\n      mark[x]=true;\n    }\n  vi arr;\n  int odd=0,even=0;\n  rep(i,1,L-1)\n    if(mark[i]!=mark[i-1])\n      {\n\tarr.pb(i);\n\tif(i&1) odd++;\n\telse even++;\n      }\n  match::n=match::m=sz(arr);\n  rep(i,0,sz(arr))\n    rep(j,0,sz(arr))\n    {\n      if(prime[abs(arr[i]-arr[j])]) match::a[i][j]=1;\n      else match::a[i][j]=0;\n    }\n  int k=match::bipartitematch();\n  assert((even-odd)%2==0);\n  even-=k; odd-=k;\n  int ans=k+(even/2+odd/2)*2+(odd&1)*3;\n  cout<<ans<<endl;\n  return 0 ;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<cstring>\n#include<map>\n#include<queue>\nusing namespace std;\ntypedef long long ll;\nconst int N=105,INF=~0u>>2;\nstruct Edge{int nxt,to;}edge[(N*N)<<2];\nint a[N],b[N],n,head[N<<2],num_edge,vis[N<<2],lk[N<<2],even[N],odd[N],even_num,odd_num,ans,k,tot,tim;\nint read(){\n\tint x=0,f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-') f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn f*x;\n}\nvoid add_edge(int from,int to){\n\tedge[++num_edge].nxt=head[from];\n\tedge[num_edge].to=to;\n\thead[from]=num_edge;\n}\nbool find(int x){\n\tfor(int i=head[x];i;i=edge[i].nxt){\n\t\tif(vis[edge[i].to]!=tim){\n\t\t\tvis[edge[i].to]=tim;\n\t\t\tif(!lk[edge[i].to]||find(edge[i].to)){\n\t\t\t\tlk[edge[i].to]=x;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nbool check(int x){\n\tfor(int i=2;i*i<=x;++i){\n\t\tif(x%i==0) return 0;\n\t}\n\treturn 1;\n}\nint main(){\n//\tfreopen(\"ex.in\",\"r\",stdin);\n\tn=read();\n\tfor(int i=1;i<=n;++i) b[i]=read();\n\tfor(int i=1;i<=n;++i){\n\t\tif(b[i]!=b[i-1]+1){\n\t\t\tif(i%2) odd[++odd_num]=i;\n\t\t\telse even[++even_num]=i;\n\t\t}\n\t\tif(b[i]+1!=b[i+1]){\n\t\t\tif((i+1)%2) odd[++odd_num]=i+1;\n\t\t\telse even[++even_num]=i+1;\n\t\t}\n\t}\n\tfor(int i=1;i<=odd_num;++i){\n\t\tfor(int j=1;j<=even_num;++j){\n\t\t\tif(odd[i]>even[j]) continue;\n\t\t\tif(check(even[j]-odd[i])) add_edge(i,odd_num+j),add_edge(odd_num+j,i);\n\t\t}\n\t}\n\tfor(int i=1;i<=odd_num;++i,++tim){\n\t\tif(find(i)) k++;\n\t\telse break;\n\t}\n\tans=k+((even_num-k)/2+(odd_num-k)/2)*2+((even_num-k)%2)*3;\n\tprintf(\"%d\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int Nmax = 205, lim = 1e7 + 5;\n\nint n, a[Nmax];\nbitset<lim+3> prim;\n\n\nint modul(int x) { return (x>0?x:-x); }\n\nclass Graph\n{\n    vector<int> edge[Nmax];\n    bool marked[Nmax];\n    int L[Nmax], R[Nmax];\n\n    bool cupleaza(int node)\n    {\n        if(marked[node]) return 0;\n        marked[node] = 1;\n\n        for(auto it : edge[node])\n            if(R[it] == -1)\n            {\n                L[node] = it;\n                R[it] = node;\n                return 1;\n            }\n\n        for(auto it : edge[node])\n            if(cupleaza(R[it]))\n            {\n                L[node] = it;\n                R[it] = node;\n                return 1;\n            }\n        return 0;\n    }\n\npublic:\n    void add_edge(int x, int y)\n    {\n        edge[x].push_back(y);\n    }\n\n    int cuplaj(int n, int m)\n    {\n        int done = 1, i;\n        for(i=0; i<n; ++i) L[i] = -1;\n        for(i=0; i<m; ++i) R[i] = -1;\n\n        while(done)\n        {\n            done = 0;\n            memset(marked, 0, sizeof(marked));\n\n            for(i=0; i<n; ++i)\n                if(L[i] == -1) done |= cupleaza(i);\n        }\n\n        int cnt = 0;\n        for(i=0; i<n; ++i) cnt += (L[i] != -1);\n        return cnt;\n    }\n\n} graph;\n\nvoid prec()\n{\n    int i, j;\n\n    prim.set();\n    prim[1] = 0;\n    for(i=2; i*i <= lim; ++i)\n        if(prim[i])\n            for(j=i*i; j<=lim; j+=i)\n                prim[j] = 0;\n}\n\nint main()\n{\n  //  freopen(\"input\", \"r\", stdin);\n    cin.sync_with_stdio(false);\n\n    prec();\n\n    int i, j;\n    vector<int> p, impar, par;\n\n    cin >> n;\n    for(i=1; i<=n; ++i) cin >> a[i];\n\n    for(i=1; i<=n; ++i)\n    {\n        j = i;\n        while(a[j] - a[i] == j - i) ++j;\n\n        p.push_back(a[i]);\n        p.push_back(a[j-1] + 1);\n\n        i = j - 1;\n    }\n\n    for(auto it : p)\n        if(it & 1) impar.push_back(it);\n            else par.push_back(it);\n\n    for(i=0; i<impar.size(); ++i)\n        for(j=0; j<par.size(); ++j)\n            if(prim[modul(impar[i] - par[j])]) graph.add_edge(i, j);\n\n    int best = graph.cuplaj(impar.size(), par.size()), A, B;\n\n    A = impar.size() - best;\n    B = par.size() - best;\n\n    cout << best + 2 * (A/2 + B/2) + 3 * (A&1) << '\\n';\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <cmath>\n#include <cstring>\n#define N 1000006\n#define M 10000007\n\nusing namespace std;\n\nstruct edge{\n\tint to, nxt;\n}e[N];\n\nint n, cnt, tot, numx, numy;\nint fir[N], a[N], b[N], prime[M], link[N], x[N], y[N];\nbool vis[M], book[N];\n\nvoid init();\nvoid add(int ,int);\nbool dfs(int);\n\nint main(){\n\tscanf(\"%d\", &n);init();\n\tfor(int i = 1; i <= n; ++i)\n\t\tscanf(\"%d\", a + i);\n\tsort(a + 1,a + 1 + n);a[0] = a[n + 1] = 99999999;\n\tfor(int i = 1; i <= n; ++i){\n\t\tif(a[i] != a[i - 1] + 1) b[++cnt] = a[i];\n\t\tif(a[i] != a[i + 1] - 1) b[++cnt] = a[i] + 1;\n\t}\n\tfor(int i = 1; i <= cnt; ++i){\n\t\tif(b[i] & 1) x[++numx] = b[i];\n\t\telse y[++numy] = b[i];\n\t}\n\tcnt = 0;\n\tfor(int i = 1; i <= numx; ++i)\n\t\tfor(int j = 1; j <= numy; ++j)\n\t\t\tif(!vis[abs(x[i] - y[j])])\n\t\t\t\tadd(i, j);\n\tfor(int i = 1; i <= numx; ++i)\n\t\tif(!link[i]){\n\t\t\tmemset(book, false, sizeof book);\n\t\t\tdfs(i);\n\t\t}\n\tint ans = 0;\n\tfor(int i = 1; i <= numy; ++i)\n\t\tif(link[i]) --numy, --numx, ++ans;\n\tans += (numy / 2) * 2 + (numx / 2) * 2;\n\tans += (numy % 2) * (numx % 2) * 3;\n\tcout << ans << endl;\n\treturn 0;\n}\n\nvoid add(int u,int v){\n\te[++cnt].to = v;e[cnt].nxt = fir[u];fir[u] = cnt;\n\treturn ;\n}\n\nvoid init(){\n\tint m = 1e7;\n\tfor(int i = 2; i <= m; ++i){\n\t\tif(!vis[i]) prime[++tot] = i;\n\t\tfor(int j = 1; j <= tot && i * prime[j] <= m; ++j){\n\t\t\tvis[i * prime[j]] = true;\n\t\t\tif(i % prime[j] == 0) break;\n\t\t}\n\t}\n\tvis[2] = true;\n\treturn ;\n}\n\nbool dfs(int u){\n\tif(book[u]) return false;\n\tbook[u] = true;\n\tfor(int i = fir[u]; i; i = e[i].nxt){\n\t\tint v = e[i].to;\n\t\tif(!link[v] || dfs(link[v])){\n\t\t\tlink[v] = u;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long long ll;\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,a) FOR(i,0,a)\n\t\nusing namespace std;\nconst int MAX_N=100,MAX_X=1e7;\nint N;\nint sto[2][MAX_N*2],ston[2];\nvector<int> G[MAX_N*2];\nbool used[MAX_N*2];\nint pa[MAX_N*2];\nbool isp[MAX_X+1];\nbool dfs(int v){\n\tused[v]=true;\n\tfor(auto e:G[v]){\n\t\tif (pa[e]==-1 || (!used[pa[e]] && dfs(pa[e]))){\n\t\t\tpa[v]=e;\n\t\t\tpa[e]=v;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\nint matching(){\n\tint ret=0;\n\tmemset(pa,-1,sizeof(pa));\n\tREP(v,ston[0]){\n\t\tfill(used,used+ston[0]+ston[1],false);\n\t\tif (pa[v]==-1 && dfs(v)){\n\t\t\tret++;\n\t\t}\n\t}\n\treturn ret;\n}\nint main(){\n\tcin>>N;\n\t{\n\t\tvector<bool> a((int)1e7+2),b((int)1e7+1);\n\t\tREP(i,N){\n\t\t\tint x;\n\t\t\tcin>>x;\n\t\t\ta[x]=1;\n\t\t}\n\t\tREP(i,(int)1e7+1){\n\t\t\tb[i]=a[i]^a[i+1];\n\t\t}\n\t\tREP(i,(int)1e7+1){\n\t\t\tif (b[i]){\n\t\t\t\tif (i&1){\n\t\t\t\t\tsto[1][ston[1]]=i;\n\t\t\t\t\tston[1]++;\n\t\t\t\t}else{\n\t\t\t\t\tsto[0][ston[0]]=i;\n\t\t\t\t\tston[0]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tmemset(isp,1,sizeof(isp));\n\tisp[0]=isp[1]=false;\n\tFOR(i,2,MAX_X+1){\n\t\tif (isp[i]){\n\t\t\tfor(int j=i*2;j<=MAX_X;j+=i){\n\t\t\t\tisp[j]=false;\n\t\t\t}\n\t\t}\n\t}\n\tREP(i,ston[0]){\n\t\tREP(j,ston[1]){\n\t\t\tint n=abs(sto[0][i]-sto[1][j]);\n\t\t\tif (n%2 && isp[n]){\n\t\t\t\tG[i].push_back(j+ston[0]);\n\t\t\t\tG[j+ston[0]].push_back(i);\n\t\t\t}\n\t\t}\n\t}\n\tint mat=matching();\n\tint ans=mat+(ston[0]-mat)/2*2+(ston[1]-mat)/2*2;\n\tif ((ston[0]-mat)%2){\n\t\tans+=3;\n\t}\n\tcout<<ans<<endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n#define rep(i, n) for (int i = 0; i < (int) (n); i++)\n#define reps(i, n) for (int i = 1; i <= (int) (n); i++)\n#define all(x) (x).begin(), (x).end()\n#define uniq(x) (x).erase(unique(all(x)), (x).end())\n#define bit(n) (1LL << (n))\n#define dump(x) cerr << #x \" = \" << (x) << endl\nusing vint = vector<int>;\nusing vvint = vector<vint>;\nusing pint = pair<int, int>;\nusing vpint = vector<pint>;\ntemplate<typename T> using priority_queue_rev = priority_queue<T, vector<T>, greater<T>>;\nconstexpr double PI = 3.1415926535897932384626433832795028;\nconstexpr int DY[9] = {0, 1, 0, -1, 1, 1, -1, -1, 0};\nconstexpr int DX[9] = {1, 0, -1, 0, 1, -1, -1, 1, 0};\nint sign(int x) { return (x > 0) - (x < 0); }\nint gcd(int a, int b) {\n    while (b) { swap(a %= b, b); }\n    return a;\n}\nint lcm(int a, int b) { return a / gcd(a, b) * b; }\nint cdiv(int a, int b) { return (a - 1 + b) / b; }\ntemplate<typename T> void fin(T mes) {\n    cout << mes << endl;\n    exit(0);\n}\ntemplate<typename T, typename U> bool chmax(T &a, const U &b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate<typename T, typename U> bool chmin(T &a, const U &b) {\n    if (b < a) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate<typename T, typename U> ostream &operator<<(ostream &os, const pair<T, U> &rhs) {\n    os << \"(\" << rhs.first << \", \" << rhs.second << \")\";\n    return os;\n}\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &rhs) {\n    os << \"{\";\n    for (auto itr = rhs.begin(); itr != rhs.end(); itr++) {\n        os << *itr << (next(itr) != rhs.end() ? \", \" : \"\");\n    }\n    os << \"}\";\n    return os;\n}\ntemplate<typename T> ostream &operator<<(ostream &os, const deque<T> &rhs) {\n    os << \"{\";\n    for (auto itr = rhs.begin(); itr != rhs.end(); itr++) {\n        os << *itr << (next(itr) != rhs.end() ? \", \" : \"\");\n    }\n    os << \"}\";\n    return os;\n}\ntemplate<typename T> ostream &operator<<(ostream &os, const set<T> &rhs) {\n    os << \"{\";\n    for (auto itr = rhs.begin(); itr != rhs.end(); itr++) {\n        os << *itr << (next(itr) != rhs.end() ? \", \" : \"\");\n    }\n    os << \"}\";\n    return os;\n}\ntemplate<typename T, typename U> ostream &operator<<(ostream &os, const map<T, U> &rhs) {\n    os << \"{\";\n    for (auto itr = rhs.begin(); itr != rhs.end(); itr++) {\n        os << *itr << (next(itr) != rhs.end() ? \", \" : \"\");\n    }\n    os << \"}\";\n    return os;\n}\nstruct setup {\n    static constexpr int PREC = 20;\n    setup() {\n        cout << fixed << setprecision(PREC);\n        cerr << fixed << setprecision(PREC);\n    };\n} setup;\n\ntemplate<typename M>\nstruct dinic {\n    using T = typename M::T;\n    struct edge {\n        int to, rev;\n        T cap;\n        bool is_rev;\n    };\n    int n;\n    std::vector<std::vector<edge>> graph;\n    std::vector<int> level, iter;\n    void add_edge(int from, int to, T cap) {\n        graph[from].push_back({to, (int) graph[to].size(), cap, false});\n        graph[to].push_back({from, (int) graph[from].size() - 1, M::id(), true});\n    }\n    dinic(const std::vector<std::vector<int>> &adj, const std::vector<std::vector<typename M::T>> &cap)\n        : n(adj.size()), graph(n), level(n), iter(n) {\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < adj[i].size(); j++) { add_edge(i, adj[i][j], cap[i][j]); }\n        }\n    }\n    void bfs(int s) {\n        fill(level.begin(), level.end(), -1);\n        std::queue<int> que;\n        level[s] = 0;\n        que.push(s);\n        while (!que.empty()) {\n            int v = que.front();\n            que.pop();\n            for (int i = 0; i < graph[v].size(); i++) {\n                edge &e = graph[v][i];\n                if (M::is_id(e.cap) || level[e.to] >= 0) { continue; }\n                level[e.to] = level[v] + 1;\n                que.push(e.to);\n            }\n        }\n    }\n    T dfs(int v, int t, T f) {\n        if (v == t) { return f; }\n        for (int &i = iter[v]; i < graph[v].size(); i++) {\n            edge &e = graph[v][i];\n            if (level[v] >= level[e.to] || M::is_id(e.cap)) { continue; }\n            T d = dfs(e.to, t, M::gr(f, e.cap) ? e.cap : f);\n            if (M::is_id(d)) { continue; }\n            e.cap = M::op(e.cap, M::inv(d));\n            graph[e.to][e.rev].cap = M::op(graph[e.to][e.rev].cap, d);\n            return d;\n        }\n        return M::id();\n    }\n    T calc_max_flow(int s, int t, T lim) {\n        T ret = M::id();\n        while (true) {\n            bfs(s);\n            if (level[t] < 0 || M::is_id(lim)) { return ret; }\n            fill(iter.begin(), iter.end(), 0);\n            T f;\n            while (!M::is_id(f = dfs(s, t, lim))) {\n                ret = M::op(ret, f);\n                lim = M::op(lim, M::inv(f));\n            }\n        }\n    }\n    T calc_max_flow(int s, int t) { return calc_max_flow(s, t, M::ab()); }\n    std::map<std::pair<int, int>, T> get_max_flow() {\n        std::map<std::pair<int, int>, T> ret;\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < graph[i].size(); j++) {\n                edge &e = graph[i][j];\n                if (e.is_rev) { ret[{e.to, i}] = e.cap; }\n            }\n        }\n        return ret;\n    }\n    std::map<std::pair<int, int>, T> get_min_cut(int s) {\n        std::map<std::pair<int, int>, T> ret;\n        std::vector<int> visited(n);\n        std::queue<int> que;\n        que.push(s);\n        while (!que.empty()) {\n            int v = que.front();\n            que.pop();\n            if (visited[v]) { continue; }\n            visited[v] = true;\n            for (int i = 0; i < graph[v].size(); i++) {\n                edge &e = graph[v][i];\n                if (!M::is_id(e.cap)) { que.push(e.to); }\n            }\n        }\n        for (int i = 0; i < n; i++) {\n            if (visited[i]) { continue; }\n            for (int j = 0; j < graph[i].size(); j++) {\n                edge &e = graph[i][j];\n                if (e.is_rev && visited[e.to]) { ret[{e.to, i}] = e.cap; }\n            }\n        }\n        return ret;\n    }\n};\n\nstruct int_dinic {\n    using T = int;\n    static T id() { return 0; }\n    static T ab() { return std::numeric_limits<T>::max(); }\n    static T inv(const T &a) { return -a; }\n    static T op(const T &a, const T &b) { return a + b; }\n    static bool gr(const T &a, const T &b) { return a > b; }\n    static bool is_id(const T &a) { return a == id(); };\n};\n\nstd::vector<long long> get_divisors(long long n) {\n    std::vector<long long> ret;\n    long long i;\n    for (i = 1; i * i < n; i++) {\n        if (n % i == 0) {\n            ret.push_back(i);\n            ret.push_back(n / i);\n        }\n    }\n    if (i * i == n) { ret.push_back(i); }\n    std::sort(ret.begin(), ret.end());\n    return ret;\n}\n\nint N;\nint x[110];\nsigned main() {\n    cin >> N;\n    rep(i, N) { cin >> x[i]; }\n    vint v;\n    rep(i, N) {\n        if (!v.empty() && v.back() == x[i]) { v.pop_back(); }\n        else { v.emplace_back(x[i]); }\n        v.emplace_back(x[i] + 1);\n    }\n    vint even, odd;\n    rep(i, v.size()) {\n        if (v[i] & 1) { odd.emplace_back(v[i]); }\n        else { even.emplace_back(v[i]); }\n    }\n    vvint adj(330), cap(330);\n    dinic<int_dinic> dnc(adj, cap);\n    rep(i, even.size()) { dnc.add_edge(0, 100 + i, 1); }\n    rep(i, odd.size()) { dnc.add_edge(200 + i, 300, 1); }\n    rep(i, even.size()) {\n        rep(j, odd.size()) {\n            if (get_divisors(abs(even[i] - odd[j])).size() == 2) { dnc.add_edge(100 + i, 200 + j, 1); }\n        }\n    }\n    int f = dnc.calc_max_flow(0, 300);\n    int ans = v.size() - f;\n    if ((even.size() - f) & 1) { ans++; }\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define L long long\n#define pb push_back\n#define pi pair<int,int>\n#define pii pair<pair<int,int>,int>\n#define aa first\n#define bb second\n#define mp make_pair\n#define mpp(a,b,c) mp(mp(a,b),c)\nusing namespace std;\n#define SZ 666666\ntypedef long long ll;\nint fst[SZ],nxt[SZ],vb[SZ],cap[SZ],ff[SZ],M=1,N=0;\n#define add ad_dl\nvoid _ad_dl(int a,int b,int c) {++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;cap[M]=c;}\nvoid ad_dl(int a,int b,int c)\n{_ad_dl(a,b,c); _ad_dl(b,a,0);}\nint S,T,q[SZ],d[SZ];\nbool bfs()\n{\n    memset(d,-1,4*(N+1));\n    d[T]=0; q[1]=T; int h=1,t=2;\n    while(h!=t)\n    {\n        int cur=q[h++];\n        for(int e=fst[cur];e;e=nxt[e])\n        {\n            int b=vb[e];\n            if(d[b]==-1&&cap[e^1])\n            {\n                d[b]=d[cur]+1, q[t++]=b;\n                if(b==S) return 1; //???? \n            }\n        }\n    }\n    return d[S]!=-1;\n}\nint dfs(int x,int f)\n{\n    if(f<=0) return 0;\n    if(x==T) return f;\n    int ca=0;\n    for(int& e=fst[x];e;e=nxt[e]) //????? \n    {\n        int b=vb[e];\n        if(d[b]+1!=d[x]) continue;\n        int w=dfs(b,(cap[e]<f-ca)?cap[e]:(f-ca));\n        cap[e]-=w; cap[e^1]+=w; ca+=w;\n        if(ca==f) break;\n    }\n    if(!ca) d[x]=-1; //????? \n    return ca;\n}\n#define inf 2e9+3\nint dinic()\n{\n    int ans=0;\n    memcpy(ff,fst,4*(N+1));\n    while(bfs())\n    {\n        //?????\n        ans+=dfs(S,inf);\n        memcpy(fst,ff,4*(N+1));\n    }\n    return ans;\n}\nint n,m,x[110],f[210],p;\nbool a[10000010];\nint main()\n{\n\t//freopen(\".in\",\"r\",stdin);\n\t//freopen(\".out\",\"w\",stdout);\n\tint i,j,k;\n\tscanf(\"%d\",&n);\n\tfor(i=1;i<=n;i++)\n\t  scanf(\"%d\",&x[i]);\n\tsort(x+1,x+n+1);\n\tfor(i=2;i<=n;i++)\n\t  if(x[i-1]+1!=x[i])\n\t    {\n\t\t f[++m]=x[i-1]+1;\n\t\t f[++m]=x[i];\n\t\t}\n\tf[++m]=x[1];\n\tf[++m]=x[n]+1;\n\ta[1]=1;\n\tfor(i=2;i<=10000000;i++)\n\t  if(!a[i])\n\t    for(j=i+i;j<=10000000;j+=i)\n\t      a[j]=1;\n\ta[2]=1;\n\tN=m+2;\n\tS=m+2;\n\tT=m+1;\n\tfor(i=1;i<=m;i++)\n\t  if(f[i]&1)\n\t    add(m+2,i,1);\n\t  else\n\t    add(i,m+1,1);\n\tfor(i=1;i<=m;i++)\n\t  for(j=1;j<=m;j++)\n\t    if(i!=j && f[i]&1 && !a[abs(f[i]-f[j])])\n\t      add(i,j,1);\n\tp=k=dinic();\n\tfor(i=1,j=-k;i<=m;i++)\n\t  if(f[i]&1)\n\t    j++;\n\tp+=j/2*2;\n\tif(j&1)\n\t  p+=3;\n\tfor(i=1,j=-k;i<=m;i++)\n\t  if(!(f[i]&1))\n\t    j++;\n\tp+=j/2*2;\n\tprintf(\"%d\\n\",p);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cassert>\n#include <cctype>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <vector>\n#include <queue>\nconst int maxv = 10000050;\nbool np[maxv]; int prm[maxv];\ninline void sieve() {\n  const int n = 10000005;\n  int cnt = 0;\n  np[1] = true;\n  for(int i = 2; i <= n; i ++) {\n    if(!np[i]) {\n      prm[cnt ++] = i;\n    }\n    for(int j = 0; j < cnt; j ++) {\n      int v = i * prm[j];\n      if(v > n) break;\n      np[v] = true;\n      if(i % prm[j] == 0) break;\n    }\n  }\n}\n\nconst int maxn = 305;\nint e_siz, o_siz;\nbool G[maxn][maxn];\nint cp[maxn]; bool vis[maxn];\nbool dfs(int x) {\n  for(int i = 1; i <= o_siz; i ++) {\n    if(G[x][i] && !vis[i]) {\n      vis[i] = true;\n      if(!cp[i] || dfs(cp[i])) {\n        cp[i] = x; return true;\n      }\n    }\n  }\n  return false;\n}\ninline int hungray() {\n  int ans = 0;\n  for(int i = 1; i <= e_siz; i ++) {\n    memset(vis, 0, sizeof(vis));\n    if(dfs(i)) ans ++;\n  }\n  return ans;\n}\n\nint C[maxv];\nvoid build_graph() {\n  std::vector<int> ep, op;\n  for(int i = 1; i < maxv; i ++) {\n    if(C[i]) {\n      if(i & 1) op.push_back(i);\n      else ep.push_back(i);\n    }\n  }\n  e_siz = ep.size(); o_siz = op.size();\n  for(int i = 1; i <= e_siz; i ++) {\n    for(int j = 1; j <= o_siz; j ++) {\n      int dis = ep[i - 1] - op[j - 1];\n      if(dis < 0) dis *= -1;\n      if(!np[dis]) {\n        G[i][j] = true;\n      }\n    }\n  }\n}\n\nint main() {\n  sieve();\n  int n; scanf(\"%d\", &n);\n  for(int i = 1; i <= n; i ++) {\n    int x; scanf(\"%d\", &x);\n    C[x] ^= 1; C[x + 1] ^= 1;\n  }\n  build_graph();\n  int ans = 0;\n  int v_1 = hungray(); ans += v_1;\n  int e_cnt = e_siz, o_cnt = o_siz;\n  if(v_1 < e_cnt || v_1 < o_cnt) {\n    e_cnt -= v_1; o_cnt -= v_1;\n    ans += (e_cnt >> 1) << 1; e_cnt &= 1;\n    ans += (o_cnt >> 1) << 1; o_cnt &= 1;\n    if(e_cnt) ans += 3;\n  }\n  printf(\"%d\\n\", ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<set>\n#include<bitset>\n#include<map>\n\n#define fo(i,a,b) for(int i=a;i<=b;i++)\n#define fd(i,a,b) for(int i=a;i>=b;i--)\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef double db;\n\nint get(){\n\tchar ch;\n\twhile(ch=getchar(),(ch<'0'||ch>'9')&&ch!='-');\n\tif (ch=='-'){\n\t\tint s=0;\n\t\twhile(ch=getchar(),ch>='0'&&ch<='9')s=s*10+ch-'0';\n\t\treturn -s;\n\t}\n\tint s=ch-'0';\n\twhile(ch=getchar(),ch>='0'&&ch<='9')s=s*10+ch-'0';\n\treturn s;\n}\n\nconst int N = 205;\nconst int L = 1e+7+10;\n\nint n;\nint b[L];\nint a[N];\nint pri[L],m;\nbool bz[L];\nint X[N],Y[N],kx,ky;\nint fa[N],e[N][N];\nint vis[N],tim;\n\nbool can(int x){\n\tif (vis[x]==tim)return 0;\n\tvis[x]=tim;\n\tfo(i,1,e[x][0]){\n\t\tint y=e[x][i];\n\t\tif (!fa[y]||can(fa[y])){\n\t\t\tfa[y]=x;\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nint main(){\n\tn=get();\n\tfo(i,1,n){\n\t\tint x=get();\n\t\tb[x-1]^=1;b[x]^=1;\n\t}\n\tint k=0;\n\tfo(i,0,1e+7)\n\tif (b[i])a[++k]=i;\n\tfo(i,2,1e+7){\n\t\tif (!bz[i])pri[++m]=i;\n\t\tfo(j,1,m){\n\t\t\tif (1ll*i*pri[j]>1e+7)break;\n\t\t\tbz[i*pri[j]]=1;\n\t\t\tif (i%pri[j]==0)break;\n\t\t}\n\t}\n\tbz[1]=bz[2]=1;\n\tfo(i,1,k)\n\tif (a[i]&1)X[++kx]=a[i];else Y[++ky]=a[i];\n\tfo(i,1,kx)\n\t\tfo(j,1,ky)\n\t\tif (!bz[abs(X[i]-Y[j])])e[i][++e[i][0]]=j;\n\tint cnt=0;\n\tfo(i,1,kx){\n\t\ttim++;\n\t\tif (can(i))cnt++;\n\t}\n\tint ans=cnt+((kx-cnt)/2+(ky-cnt)/2)*2+((kx-cnt)%2)*3;\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define sqr(x) ((x)*(x))\n#define ll long long\n#define ull unsigned long long\n#define ui unsigned int\n#define ld long double\n#define vi vector<int>\n#define HEAP(T) priority_queue<T>\n#define heap(...) priority_queue<__VA_ARGS__,vector<__VA_ARGS__>,greater<__VA_ARGS__> > \n#define pii pair<int,int>\n#define pb push_back\n#define mp make_pair\n#define debuge cerr<<\"isok\"<<endl\n#define debug(x) cerr<<#x<<\"=\"<<x<<endl\n#define error(...) fprintf(stderr,__VA_ARGS__)\n#define SS second\n#define FF first\n#define ls (k<<1)\n#define rs (k<<1|1)\n#define inf 0x3f3f3f3f\n#define LL long long\n#define clr(a,x) memset(a,x,sizeof(a))\n#define cpy(a,x) memcpy(a,x,sizeof(a))\n#define file(x) freopen(x\".in\",\"r\",stdin),freopen(x\".out\",\"w\",stdout)\nusing namespace std;\n\nconst int N=20000005,M=100005,mod=1e9+7;\ntemplate<class T> inline void gmin(T &x,const T &y){if(x>y) x=y;}\ntemplate<class T> inline void gmax(T &x,const T &y){if(x<y) x=y;}\ntemplate<class T,class S> inline void ch(T &x,const S y){x=(x+y)%mod;}\nconst int BufferSize=1<<16;\nchar buffer[BufferSize],*Bufferhead,*Buffertail;\nbool Terminal;\ninline char Getchar(){\n\tif(Bufferhead==Buffertail){\n\t\tint l=fread(buffer,1,BufferSize,stdin);\n\t\tif(!l){Terminal=1;return 0;}\n\t\tBuffertail=(Bufferhead=buffer)+l;\n\t}\n\treturn *Bufferhead++;\n}\ntemplate<class T>inline bool read(T &x){\n\tx=0;char c=Getchar(),rev=0;\n\twhile(c<'0'||c>'9'){c=Getchar();rev|=c=='-';if(Terminal)return 0;}\n\twhile(c>='0'&&c<='9') x=x*10+c-'0',c=Getchar();\n\tx=rev?-x:x;\n\treturn 1;\n}\ninline bool reads(char *x){\n\tchar c=Getchar();\n\twhile(c<33||c>126){c=Getchar();if(Terminal)return 0;}\n\twhile(c>=33&&c<=126) (*x++)=c,c=Getchar();\n\t*x=0;return 1;\n}\ntemplate<class T>inline void print(T x,const char c){\n\tif(!x){putchar('0');putchar(c);return;}\n\tif(x<0) putchar('-'),x=-x;\n\tint m=0,a[10];\n\twhile(x) a[m++]=x%10,x/=10;\n\twhile(m--) putchar(a[m]+'0');\n\tputchar(c);\n}\ninline int exp(int x,int y,const int mod=::mod){\n\tint ans=1;\n\twhile(y){\n\t\tif(y&1) ans=(ll)ans*x%mod;\n\t\tx=(ll)x*x%mod;y>>=1;\n\t}return ans;\n}\n\nconst int INF = 2147483647;\n\nconst int MaxN = 400;\nconst int MaxM = 79800;\n\ntemplate <class T>\ninline void tension(T &a, const T &b)\n{\n\tif (b < a)\n\t\ta = b;\n}\ntemplate <class T>\ninline void relax(T &a, const T &b)\n{\n\tif (b > a)\n\t\ta = b;\n}\ntemplate <class T>\ninline int size(const T &a)\n{\n\treturn (int)a.size();\n}\n\ninline int getint()\n{\n\tchar c;\n\twhile (c = getchar(), '0' > c || c > '9');\n\n\tint res = c - '0';\n\twhile (c = getchar(), '0' <= c && c <= '9')\n\t\tres = res * 10 + c - '0';\n\treturn res;\n}\n\nconst int MaxNX = MaxN + MaxN;\n\nstruct edge\n{\n\tint v, u, w;\n\n\tedge(){}\n\tedge(const int &_v, const int &_u, const int &_w)\n\t\t: v(_v), u(_u), w(_w){}\n};\n\nint n, m;\nedge mat[MaxNX + 1][MaxNX + 1];\n\nint n_matches;\nLL tot_weight;\nint mate[MaxNX + 1];\nint lab[MaxNX + 1];\n\nint q_n, q[MaxN];\nint fa[MaxNX + 1], col[MaxNX + 1];\nint slackv[MaxNX + 1];\n\nint n_x;\nint bel[MaxNX + 1], blofrom[MaxNX + 1][MaxNX + 1];\nvector<int> bloch[MaxNX + 1];\n\ninline int e_delta(const edge &e) // does not work inside blossoms\n{\n\treturn lab[e.v] + lab[e.u] - mat[e.v][e.u].w * 2;\n}\ninline void update_slackv(int v, int x)\n{\n\tif (!slackv[x] || e_delta(mat[v][x]) < e_delta(mat[slackv[x]][x]))\n\t\tslackv[x] = v;\n}\ninline void calc_slackv(int x)\n{\n\tslackv[x] = 0;\n\tfor (int v = 1; v <= n; v++)\n\t\tif (mat[v][x].w > 0 && bel[v] != x && col[bel[v]] == 0)\n\t\t\tupdate_slackv(v, x);\n}\n\ninline void q_push(int x)\n{\n\tif (x <= n)\n\t\tq[q_n++] = x;\n\telse\n\t{\n\t\tfor (int i = 0; i < size(bloch[x]); i++)\n\t\t\tq_push(bloch[x][i]);\n\t}\n}\ninline void set_mate(int xv, int xu)\n{\n\tmate[xv] = mat[xv][xu].u;\n\tif (xv > n)\n\t{\n\t\tedge e = mat[xv][xu];\n\t\tint xr = blofrom[xv][e.v];\n\t\tint pr = find(bloch[xv].begin(), bloch[xv].end(), xr) - bloch[xv].begin();\n\t\tif (pr % 2 == 1)\n\t\t{\n\t\t\treverse(bloch[xv].begin() + 1, bloch[xv].end());\n\t\t\tpr = size(bloch[xv]) - pr;\n\t\t}\n\n\t\tfor (int i = 0; i < pr; i++)\n\t\t\tset_mate(bloch[xv][i], bloch[xv][i ^ 1]);\n\t\tset_mate(xr, xu);\n\n\t\trotate(bloch[xv].begin(), bloch[xv].begin() + pr, bloch[xv].end());\n\t}\n}\ninline void set_bel(int x, int b)\n{\n\tbel[x] = b;\n\tif (x > n)\n\t{\n\t\tfor (int i = 0; i < size(bloch[x]); i++)\n\t\t\tset_bel(bloch[x][i], b);\n\t}\n}\n\ninline void augment(int xv, int xu)\n{\n\twhile (true)\n\t{\n\t\tint xnu = bel[mate[xv]];\n\t\tset_mate(xv, xu);\n\t\tif (!xnu)\n\t\t\treturn;\n\t\tset_mate(xnu, bel[fa[xnu]]);\n\t\txv = bel[fa[xnu]], xu = xnu;\n\t}\n}\ninline int get_lca(int xv, int xu)\n{\n\tstatic bool book[MaxNX + 1];\n\tfor (int x = 1; x <= n_x; x++)\n\t\tbook[x] = false;\n\twhile (xv || xu)\n\t{\n\t\tif (xv)\n\t\t{\n\t\t\tif (book[xv])\n\t\t\t\treturn xv;\n\t\t\tbook[xv] = true;\n\t\t\txv = bel[mate[xv]];\n\t\t\tif (xv)\n\t\t\t\txv = bel[fa[xv]];\n\t\t}\n\t\tswap(xv, xu);\n\t}\n\treturn 0;\n}\n\ninline void add_blossom(int xv, int xa, int xu)\n{\n\tint b = n + 1;\n\twhile (b <= n_x && bel[b])\n\t\tb++;\n\tif (b > n_x)\n\t\tn_x++;\n\n\tlab[b] = 0;\n\tcol[b] = 0;\n\n\tmate[b] = mate[xa];\n\n\tbloch[b].clear();\n\tbloch[b].push_back(xa);\n\tfor (int x = xv; x != xa; x = bel[fa[bel[mate[x]]]])\n\t\tbloch[b].push_back(x), bloch[b].push_back(bel[mate[x]]), q_push(bel[mate[x]]);\n\treverse(bloch[b].begin() + 1, bloch[b].end());\n\tfor (int x = xu; x != xa; x = bel[fa[bel[mate[x]]]])\n\t\tbloch[b].push_back(x), bloch[b].push_back(bel[mate[x]]), q_push(bel[mate[x]]);\n\n\tset_bel(b, b);\n\n\tfor (int x = 1; x <= n_x; x++)\n\t{\n\t\tmat[b][x].w = mat[x][b].w = 0;\n\t\tblofrom[b][x] = 0;\n\t}\n\tfor (int i = 0; i < size(bloch[b]); i++)\n\t{\n\t\tint xs = bloch[b][i];\n\t\tfor (int x = 1; x <= n_x; x++)\n\t\t\tif (mat[b][x].w == 0 || e_delta(mat[xs][x]) < e_delta(mat[b][x]))\n\t\t\t\tmat[b][x] = mat[xs][x], mat[x][b] = mat[x][xs];\n\t\tfor (int x = 1; x <= n_x; x++)\n\t\t\tif (blofrom[xs][x])\n\t\t\t\tblofrom[b][x] = xs;\n\t}\n\tcalc_slackv(b);\n}\ninline void expand_blossom1(int b) // lab[b] == 1\n{\n\tfor (int i = 0; i < size(bloch[b]); i++)\n\t\tset_bel(bloch[b][i], bloch[b][i]);\n\n\tint xr = blofrom[b][mat[b][fa[b]].v];\n\tint pr = find(bloch[b].begin(), bloch[b].end(), xr) - bloch[b].begin();\n\tif (pr % 2 == 1)\n\t{\n\t\treverse(bloch[b].begin() + 1, bloch[b].end());\n\t\tpr = size(bloch[b]) - pr;\n\t}\n\n\tfor (int i = 0; i < pr; i += 2)\n\t{\n\t\tint xs = bloch[b][i], xns = bloch[b][i + 1];\n\t\tfa[xs] = mat[xns][xs].v;\n\t\tcol[xs] = 1, col[xns] = 0;\n\t\tslackv[xs] = 0, calc_slackv(xns);\n\t\tq_push(xns);\n\t}\n\tcol[xr] = 1;\n\tfa[xr] = fa[b];\n\tfor (int i = pr + 1; i < size(bloch[b]); i++)\n\t{\n\t\tint xs = bloch[b][i];\n\t\tcol[xs] = -1;\n\t\tcalc_slackv(xs);\n\t}\n\n\tbel[b] = 0;\n}\ninline void expand_blossom_final(int b) // at the final stage\n{\n\tfor (int i = 0; i < size(bloch[b]); i++)\n\t{\n\t\tif (bloch[b][i] > n && lab[bloch[b][i]] == 0)\n\t\t\texpand_blossom_final(bloch[b][i]);\n\t\telse\n\t\t\tset_bel(bloch[b][i], bloch[b][i]);\n\t}\n\tbel[b] = 0;\n}\n\ninline bool on_found_edge(const edge &e)\n{\n\tint xv = bel[e.v], xu = bel[e.u];\n\tif (col[xu] == -1)\n\t{\n\t\tint nv = bel[mate[xu]];\n\t\tfa[xu] = e.v;\n\t\tcol[xu] = 1, col[nv] = 0;\n\t\tslackv[xu] = slackv[nv] = 0;\n\t\tq_push(nv);\n\t}\n\telse if (col[xu] == 0)\n\t{\n\t\tint xa = get_lca(xv, xu);\n\t\tif (!xa)\n\t\t{\n\t\t\taugment(xv, xu), augment(xu, xv);\n\t\t\tfor (int b = n + 1; b <= n_x; b++)\n\t\t\t\tif (bel[b] == b && lab[b] == 0)\n\t\t\t\t\texpand_blossom_final(b);\n\t\t\treturn true;\n\t\t}\n\t\telse\n\t\t\tadd_blossom(xv, xa, xu);\n\t}\n\treturn false;\n}\n\nbool match()\n{\n\tfor (int x = 1; x <= n_x; x++)\n\t\tcol[x] = -1, slackv[x] = 0;\n\n\tq_n = 0;\n\tfor (int x = 1; x <= n_x; x++)\n\t\tif (bel[x] == x && !mate[x])\n\t\t\tfa[x] = 0, col[x] = 0, slackv[x] = 0, q_push(x);\n\tif (q_n == 0)\n\t\treturn false;\n\n\twhile (true)\n\t{\n\t\tfor (int i = 0; i < q_n; i++)\n\t\t{\n\t\t\tint v = q[i];\n\t\t\tfor (int u = 1; u <= n; u++)\n\t\t\t\tif (mat[v][u].w > 0 && bel[v] != bel[u])\n\t\t\t\t{\n\t\t\t\t\tint d = e_delta(mat[v][u]);\n\t\t\t\t\tif (d == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (on_found_edge(mat[v][u]))\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\telse if (col[bel[u]] == -1 || col[bel[u]] == 0)\n\t\t\t\t\t\tupdate_slackv(v, bel[u]);\n\t\t\t\t}\n\t\t}\n\n\t\tint d = INF;\n\t\tfor (int v = 1; v <= n; v++)\n\t\t\tif (col[bel[v]] == 0)\n\t\t\t\ttension(d, lab[v]);\n\t\tfor (int b = n + 1; b <= n_x; b++)\n\t\t\tif (bel[b] == b && col[b] == 1)\n\t\t\t\ttension(d, lab[b] / 2);\n\t\tfor (int x = 1; x <= n_x; x++)\n\t\t\tif (bel[x] == x && slackv[x])\n\t\t\t{\n\t\t\t\tif (col[x] == -1)\n\t\t\t\t\ttension(d, e_delta(mat[slackv[x]][x]));\n\t\t\t\telse if (col[x] == 0)\n\t\t\t\t\ttension(d, e_delta(mat[slackv[x]][x]) / 2);\n\t\t\t}\n\n\t\tfor (int v = 1; v <= n; v++)\n\t\t{\n\t\t\tif (col[bel[v]] == 0)\n\t\t\t\tlab[v] -= d;\n\t\t\telse if (col[bel[v]] == 1)\n\t\t\t\tlab[v] += d;\n\t\t}\n\t\tfor (int b = n + 1; b <= n_x; b++)\n\t\t\tif (bel[b] == b)\n\t\t\t{\n\t\t\t\tif (col[bel[b]] == 0)\n\t\t\t\t\tlab[b] += d * 2;\n\t\t\t\telse if (col[bel[b]] == 1)\n\t\t\t\t\tlab[b] -= d * 2;\n\t\t\t}\n\n\t\tq_n = 0;\n\t\tfor (int v = 1; v <= n; v++)\n\t\t\tif (lab[v] == 0) // all unmatched vertices' labels are zero! cheers!\n\t\t\t\treturn false;\n\t\tfor (int x = 1; x <= n_x; x++)\n\t\t\tif (bel[x] == x && slackv[x] && bel[slackv[x]] != x && e_delta(mat[slackv[x]][x]) == 0)\n\t\t\t{\n\t\t\t\tif (on_found_edge(mat[slackv[x]][x]))\n\t\t\t\t\treturn true;\n\t\t\t}\n\t\tfor (int b = n + 1; b <= n_x; b++)\n\t\t\tif (bel[b] == b && col[b] == 1 && lab[b] == 0)\n\t\t\t\texpand_blossom1(b);\n\t}\n\treturn false;\n}\n\nvoid calc_max_weight_match()\n{\n\tfor (int v = 1; v <= n; v++)\n\t\tmate[v] = 0;\n\n\tn_x = n;\n\tn_matches = 0;\n\ttot_weight = 0;\n\n\tbel[0] = 0;\n\tfor (int v = 1; v <= n; v++)\n\t\tbel[v] = v, bloch[v].clear();\n\tfor (int v = 1; v <= n; v++)\n\t\tfor (int u = 1; u <= n; u++)\n\t\t\tblofrom[v][u] = v == u ? v : 0;\n\n\tint w_max = 0;\n\tfor (int v = 1; v <= n; v++)\n\t\tfor (int u = 1; u <= n; u++)\n\t\t\trelax(w_max, mat[v][u].w);\n\tfor (int v = 1; v <= n; v++)\n\t\tlab[v] = w_max;\n\n\twhile (match())\n\t\tn_matches++;\n\n\tfor (int v = 1; v <= n; v++)\n\t\tif (mate[v] && mate[v] < v)\n\t\t\ttot_weight += mat[v][mate[v]].w;\n}\n\n\ninline bool check(int x){\n\tif(x==1) return 0;\n\tfor(int i=2;i*i<=x;i++)\t\n\tif(x%i==0) return 0;\n\treturn 1;\t\n}\n\nint calc(int n){\n\tif(n%2==0) return 2;\n\tif(check(n)) return 1;\n\treturn 3;\n}\n\nbool f[N];\nint a[105];\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++){\n\t\tint x;scanf(\"%d\",&x);\n\t\tf[x]=1;\n\t}\n\tn=0;\n\tfor(int i=1;i<=10000001;i++) \n\t\tif(f[i]^f[i-1]) a[++n]=i;\n\tfor (int v=1;v<=n;v++)\n\t\tfor (int u=1;u<=n;u++)\n\t\t\tmat[v][u]=edge(v,u,0);\n\tfor(int u=1;u<=n;u++)\n\t\tfor(int v=1;v<u;v++)\n\t\t\tmat[u][v].w=mat[v][u].w=4-calc(abs(a[u]-a[v]));\n\tcalc_max_weight_match();\n\tprintf(\"%d\\n\", n*2-tot_weight);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 205\n#define M 10000005\nusing namespace std;\nbool B[M];\nint n,a[N],m,k,P[M/10],w[N],G[N][N],mp[N],vis[N],cnt;\nvoid prepare()\n{\n\tint i,j; B[1]=1;\n\tfor(i=2;i<M;i++){\n\t\tif(!B[i]) P[++m]=i;\n\t\tfor(j=1;j<=m;j++){\n\t\t\tif(i*P[j]>=M) break;\n\t\t\tB[i*P[j]]=1;\n\t\t\tif(i%P[j]==0) break;\n\t\t  }\n\t  }\n\tB[2]=1;\n}\nint find(int t)\n{\n\tint i,q=0;\n\tfor(i=1;i<=m;i++){\n\t\tif(vis[i]==cnt||!G[t][i]) continue;\n\t\tvis[i]=cnt,q=mp[i],mp[i]=t;\n\t\tif(!q||find(q)) return 1;\n\t\tmp[i]=q;\n\t  }\n\treturn 0;\n}\nint main()\n{\n\tint i,j;\n\tscanf(\"%d\",&n);\n\tfor(i=1;i<=n;i++)\n\t\tscanf(\"%d\",&a[i]);\n\tprepare(),m=0;\n\tfor(i=1;i<=n;i=j){\n\t\tfor(j=i;j<=n&&a[j]==a[i]+j-i;j++);\n\t\tw[++m]=a[i],w[++m]=a[j-1]+1;\n\t  }\n\tfor(i=1;i<=m;i++)\n\t\tif(w[i]%2==0)\n\t\t\tfor(j=1;j<=m;j++)\n\t\t\t\tif(w[j]%2==1&&!B[abs(w[i]-w[j])])\n\t\t\t\t\tG[i][j]=1;\n\tfor(i=1;i<=m;i++)\n\t\tif(w[i]%2==0)\n\t\t\t++cnt,k+=find(i);\n\tprintf(\"%d\",k+((cnt-k)/2+(m-cnt-k)/2)*2+((cnt-k)%2)*3);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\n#define X first\n#define Y second\n#define pb emplace_back\n#define FOR(i,a,b) for(int (i)=(a);i<(b);++(i))\n#define EFOR(i,a,b) for(int (i)=(a);i<=(b);++(i))\n#define rep(X,Y) for (int (X) = 0;(X) < (Y);++(X))\n#define REP rep\n#define rrep(X,Y) for (int (X) = (Y)-1;(X) >=0;--(X))\n#define all(X) (X).begin(),(X).end()\n#define eb emplace_back\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef ll LL;\ntypedef pii PII;\ntypedef pll PLL;\nconst ll MOD=1e9+7;\n\n#define rall(X) (X).rbegin(),(X).rend()\n#define UNIQUE(X) (X).erase(unique(all(X)),(X).end())\n#define reps(X,S,Y) for (int (X) = S;(X) < (Y);++(X))\n#define rreps(X,S,Y) for (int (X) = (Y)-1;(X) >= (S);--(X))\ntemplate<class T> inline bool MX(T &l,const T &r){return l<r?l=r,1:0;}\ntemplate<class T> inline bool MN(T &l,const T &r){return l>r?l=r,1:0;}\n\nint N;\nbool is_composite[11451419];\nmap<int, char> mp;\n\nint GetCost(int d) {\n  if (d == 2) return 2;\n  if (!is_composite[d]) return 1;\n  if (d%2 == 0) return 2;\n  return 3;\n}\n\nsigned main(){\n  is_composite[1] = true;\n  reps(i, 2, 11451419) {\n    if (is_composite[i]) continue;\n    for (int j=i+i; j<11451419; j+=i) {\n      is_composite[j] = true;\n    }\n  }\n\n  ios_base::sync_with_stdio(false);\n  cout<<fixed<<setprecision(0);\n\n  cin >> N;\n\n  rep(i, N) {\n    int x;\n    cin >> x;\n    mp[x] ^= 1;\n    mp[x+1] ^= 1;\n  }\n\n  vector<int> vs;\n  for (auto &p : mp) {\n    if (p.Y == 0) continue;\n    vs.eb(p.X);\n  }\n  int m = vs.size();\n  assert(m%2 == 0);\n  m /= 2;\n  vector<pii> ps;\n  rep(i, m) {\n    ps.eb(pii(vs[i*2], vs[i*2+1]));\n  }\n\n  while (1) {\n    bool found = false;\n    rep(i, m) {\n      int a, b;\n      tie(a, b) = ps[i];\n      reps(j, i+1, m) {\n        int c, d;\n        tie(c, d) = ps[j];\n\n        rep(k, 2) {\n          int pr = GetCost(abs(a-b)) + GetCost(abs(c-d));\n          int af = GetCost(abs(a-c)) + GetCost(abs(b-d));\n          if (pr > af) {\n            found = true;\n            ps[i] = pii(a, c);\n            ps[j] = pii(b, d);\n            goto L_END;\n          } else if (pr == af && af == 4 && GetCost(abs(a-c))%2) {\n            found = true;\n            ps[i] = pii(a, c);\n            ps[j] = pii(b, d);\n            goto L_END;\n          }\n\n          swap(c, d);\n        }\n      }\nL_END:\n      continue;\n    }\n\n    if (!found) break;\n  }\n\n  int ans = 0;\n  rep(i, m) {\n    ans += GetCost(abs(ps[i].X-ps[i].Y));\n  }\n  cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,int> PI;\n\nconst int mod = 1e9 + 7;\nconst int maxn = 1e7 + 5;\nbool flag[maxn];\nint pri[maxn];\nint cnt = 0;\n\nvoid GetPrime() {\n    for (int i = 2; i < maxn; ++i) {\n        if (!flag[i]) pri[cnt++] = i;\n        for (int j = 0; j < cnt && pri[j] * i < maxn; ++j) {\n            flag[pri[j] * i] = 1;\n            if (i % pri[j] == 0) break;\n        }\n    }\n}\n\nint d[105];\nint f[105];\n\nint main() {\n    GetPrime();\n    int n,i,j,k;\n    scanf(\"%d\",&n);\n    for(i = 0; i < n; i++) scanf(\"%d\",&d[i]);\n    memset(f,0x3f,sizeof(f));\n    f[0] = 0;\n    for(i = 0;i < n; i++) {\n        f[i + 1] = min(f[i + 1],f[i] + 3);\n        for(j = i + 2;j <= n; j++) {\n            int u = 0;\n            for(k = i + 1;k < j; k++) {\n                int x = d[k] - d[k - 1] - 1;\n                if(x == 2) {\n                    u = mod;\n                    break;\n                }\n                if(x == 0) continue;\n                if(!flag[x]) u++;\n                else u += 2 + (x & 1);\n            }\n            int x = d[j - 1] - d[i] + 1;\n            if(!flag[x] || x != 2) u += 2 + (x & 1);\n            f[i + j] = min(f[i + j],f[i] + u);\n        }\n    }\n    printf(\"%d\\n\",f[n]);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n\n#define Rep(i, n) for (int i = 1; i <= n; i ++)\n\nusing namespace std;\n\nconst int N = 210, N0 = 1e7 + 10;\n\nint d0[N], d[N], cd;\n\nbool isnotprime[N0];\nint prime[N0], cnt;\nvoid get_prime()\n{\n\tisnotprime[1] = true;\n\tfor (int i = 2; i <= 1e7; i ++){\n\t\tif (!isnotprime[i]) prime[++ cnt] = i;\n\t\tfor (int j = 1; j <= cnt && i * prime[j] <= 1e7; j ++) {\n\t\t\tisnotprime[i * prime[j]] = true;\n\t\t\tif (!(i % prime[j])) break;\n\t\t}\n\t}\n}\n\nbool g[N][N], vis[N];\nint lnk[N];\n\nbool dfs(int x)\n{\n\tvis[x] = true;\n\tRep(i, cd) if (g[x][i] && !vis[i]){\n\t\tif (lnk[i] == -1 || dfs(lnk[i])) {\n\t\t\tlnk[i] = x;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint main()\n{\n\tint n;\n\tscanf(\"%d\", &n);\n\tRep(i, n) scanf(\"%d\", &d0[i]);\n\td0[0] = -1;\n\tRep(i, n) {\n\t\tif (d0[i - 1] != d0[i] - 1) d[++ cd] = d0[i];\n\t\tif (d0[i + 1] != d0[i] + 1) d[++ cd] = d0[i] + 1;\n\t}\n\t\n\tget_prime();\n\tRep(i, cd) if (d[i] & 1)\n\t\tRep(j, cd) if (!(d[j] & 1))\n\t\t\tif (!isnotprime[abs(d[j] - d[i])]) g[i][j] = true;\n\t\n\tint c0 = 0, c1 = 0, cc = 0;\n\tRep(i, cd) lnk[i] = -1;\n\tRep(i, cd) {\n\t\t//printf(\"%d\\n\", d[i]);\n\t\tif (d[i] & 1) {\n\t\t\tRep(j, cd) vis[j] = false;\n\t\t\tif (dfs(i)) cc ++;\n\t\t\tc1 ++;\n\t\t}\n\t\telse c0 ++;\n\t}\n\t//printf(\"%d %d %d\\n\", cc, c0, c1);\n\tint ans = cc;\n\tc0 -= cc, c1 -= cc;\n\tans += (c0 / 2) * 2, c0 %= 2;\n\tans += (c1 / 2) * 2, c1 %= 2;\n\tif (c0 && c1) ans += 3;\n\t\n\tprintf(\"%d\\n\", ans);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <stdlib.h>\n#define inf 1e9\n\nusing namespace std;\n\nstruct edge{\n\tint to, cap, rev;\n\tedge(int a, int b, int c){\n\t\tto = a, cap = b, rev = c;\n\t}\n};\n\nint n, N;\nint x[105], X[205];\nbool prime[10000005];\nmap<int, int> mp;\nvector<int> vec;\n\nvector<edge> G[205];\nint S, T;\nbool used[205];\n\nint dfs(int v, int f)\n{\n\tused[v] = true;\n\tif(v == T) return f;\n\t\n\tint ret;\n\tfor(int i = 0; i < G[v].size(); i++){\n\t\tif(used[G[v][i].to] || G[v][i].cap <= 0) continue;\n\t\tret = dfs(G[v][i].to, min(f, G[v][i].cap));\n\t\tif(ret > 0){\n\t\t\tG[v][i].cap -= ret;\n\t\t\tG[G[v][i].to][G[v][i].rev].cap += ret;\n\t\t\treturn ret;\n\t\t}\n\t}\n\treturn 0;\n}\n\nvoid add_edge(int s, int t, int cap)\n{\n\tG[s].push_back(edge(t, cap, G[t].size()));\n\tG[t].push_back(edge(s, 0, G[s].size()-1));\n}\n\nint main(void)\n{\n\tcin >> n;\n\tfor(int i = 2; i < 10005; i++){\n\t\tif(prime[i]) continue;\n\t\tfor(int j = 2*i; j < 10000005; j+=i) prime[j] = true;\n\t}\n\tprime[1] = prime[2] = true;\n\t\n\tfor(int i = 1; i <= n; i++) cin >> x[i];\n\tfor(int i = 1; i <= n; i++){\n\t\tmp[x[i]]++, mp[x[i]+1]++;\n\t}\n\tfor(auto it = mp.begin(); it != mp.end(); it++){\n\t\tif(it->second % 2) vec.push_back(it->first);\n\t}\n\tN = vec.size();\n\tfor(int i = 0; i < N; i++) X[i+1] = vec[i];\n\t\n\tS = N+1, T = N+2;\n\tint odd = 0, even = 0;\n\tfor(int i = 1; i <= N; i++){\n\t\tif(X[i]%2) add_edge(S, i, 1), odd++;\n\t\telse add_edge(i, T, 1), even++;\n\t}\n\tfor(int i = 1; i <= N; i++){\n\t\tfor(int j = 1; j <= N; j++){\n\t\t\tif(i == j) continue;\n\t\t\tif(X[i]%2 && X[j]%2 == 0 && !prime[abs(X[i]-X[j])]) add_edge(i, j, 1);\n\t\t}\n\t}\n\t\n\tint mx = 0, flow;\n\twhile(1){\n\t\tfor(int i = 1; i <= T; i++) used[i] = false;\n\t\tflow = dfs(S, inf);\n\t\tif(flow <= 0) break;\n\t\tmx += flow;\n\t}\n\t\n\tint ans = mx;\n\todd -= mx, even -= mx;\n\tans += odd/2*2, ans += even/2*2;\n\tans += odd%2*3;\n\t\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <cstdio>\n\nusing namespace std;\n\nconst int N=205;\nconst int M=N*N;\nconst int L=10000000;\n\nint last[N],bel[N];\nint nxt[M],tov[M];\nbool mark[L+5];\nint pos[2][N];\nbool vis[N];\nint n,tot,mx,match,ans;\n\ninline int iabs(int x){return x>0?x:-x;}\n\ninline void insert(int x,int y){tov[++tot]=y,nxt[tot]=last[x],last[x]=tot;}\n\ninline bool is_prime(int x)\n{\n\tfor (int i=1;i*i<=x;++i) if (!(x%i)) return 0;\n\treturn 1;\n}\n\nbool hungary(int x)\n{\n\tif (vis[x]) return 0;\n\tvis[x]=1;\n\tfor (int i=last[x],y;i;i=nxt[i])\n\t\tif (!bel[y=tov[i]]||hungary(y))\n\t\t\treturn bel[y]=x;\n\treturn 0;\n}\n\nint main()\n{\n\t//freopen(\"flip.in\",\"r\",stdin),freopen(\"flip.out\",\"w\",stdout);\n\tscanf(\"%d\",&n);\n\tfor (int i=1,x;i<=n;++i) scanf(\"%d\",&x),mx=max(mx,x),mark[x]=1;\n\tfor (int i=1;i<=mx+1;++i)\n\t\tif (mark[i]^mark[i-1])\n\t\t\tpos[i&1][++pos[i&1][0]]=i;\n\tfor (int i=1;i<=pos[0][0];++i)\n\t\tfor (int j=1;j<=pos[1][0];++j)\n\t\t{\n\t\t\tint d=iabs(pos[0][i]-pos[1][j]);\n\t\t\tif (is_prime(d)) insert(i,j);\n\t\t}\n\tmatch=0;\n\tfor (int i=1;i<=pos[0][0];++i) memset(vis,0,sizeof vis),match+=hungary(i);\n\tans=match,pos[0][0]-=match,pos[1][0]-=match;\n\tans+=(pos[0][0]>>1)+(pos[1][0]>>1)<<1;\n\tpos[0][0]&=1,pos[1][0]&=1;\n\tif (pos[0][0]) ans+=3;\n\tprintf(\"%d\\n\",ans);\n\t//fclose(stdin),fclose(stdout);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n  \nusing namespace std;\n  \n#define rep(i,n) REP(i,0,n)\n#define REP(i,s,e) for(int i=(s); i<(int)(e); i++)\n#define repr(i, n) REPR(i, n, 0)\n#define REPR(i, s, e) for(int i=(int)(s-1); i>=(int)(e); i--)\n#define pb push_back\n#define all(r) r.begin(),r.end()\n#define rall(r) r.rbegin(),r.rend()\n#define fi first\n#define se second\n  \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n \nconst int INF = 1e9;\nconst ll MOD = 1e9 + 7;\ndouble EPS = 1e-8;\n\n#define MAX_V 2200\n \nstruct Edge\n{\n    int to, cap, rev;\n    Edge(){};\n    Edge(int to, int cap, int rev) : to(to), cap(cap), rev(rev){};\n};\n \nvector<Edge> G[MAX_V];\nbool used[MAX_V];\n \nvoid add_edge(int from, int to, int cap){\n    G[from].push_back({to, cap, (int)G[to].size()});\n    G[to].push_back({from, 0, (int)G[from].size()-1});\n}\n \nint dfs(int v, int t, int f){\n    if(v == t) return f;\n    used[v] = true;\n    for(int i = 0; i < G[v].size(); i++){\n        Edge& e = G[v][i];\n        if(!used[e.to] && e.cap > 0){\n            int d = dfs(e.to, t, min(f, e.cap));\n            if(d > 0){\n                e.cap -= d;\n                G[e.to][e.rev].cap += d;\n                return d;\n            }\n        }\n    }\n    return 0;\n}\n \nint max_flow(int s, int t){\n    int flow = 0;\n    while(1){\n        memset(used, 0, sizeof(used));\n        int f = dfs(s, t, INF);\n        if(f == 0) return flow;\n        flow += f;\n    }\n}\n\n//エラトステネスの篩を使用\nconst int MAX_PRIME = 1e7 + 10;\n \nvector<int> is_prime(MAX_PRIME,1);\n \nvoid calcPrime(){\n    is_prime[0]=is_prime[1]=0;\n    for(int i=2; i<MAX_PRIME; i++){\n        if(is_prime[i]==1){\n            for(int j=i*2; j<MAX_PRIME; j+=i){\n                is_prime[j]=0;\n            }\n        }\n    }\n}\n\nint main(){\n\tcalcPrime();\n\tint n;\n\tcin >> n;\n\tvi x(n);\n\trep(i, n) cin >> x[i];\n\tconst int MAX = 1e7+10;\n\tmap<int, int> mp;\n\trep(i, n) {\n\t\tmp[x[i]]^=1;\n\t\tmp[x[i]+1]^=1;\n\t}\n\tvi odd, even;\n\tfor(auto& p : mp) if(p.se) (p.fi&1?odd:even).pb(p.se);\n\trep(i, odd.size()) rep(j, even.size()) {\n\t\tif(is_prime[abs(odd[i]-even[j])]) add_edge(i, odd.size()+j, 1);\n\t}\n\trep(i, odd.size()) add_edge(n, i, 1);\n\trep(i, even.size()) add_edge(odd.size()+i, n+1, 1);\n\tint f = max_flow(n, n+1);\n\tint ans = f + (odd.size()-f)/2*2 + (even.size()-f)/2*2;\n\tif((odd.size()-f)&1) ans += 3;\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 10000010;\nbool pd[N];\nint prime[N],tot;\nvoid find_prime(){\n\tmemset(pd,true,sizeof(pd));\n\tfor(int i=2;i<N;i++){\n\t\tif(pd[i]) prime[++tot]=i;\n\t\tfor(int j=1;j<=tot;j++){\n\t\t\tif(prime[j]*i>=N) break;\n\t\t\tpd[prime[j]*i]=false;\n\t\t\tif(i%prime[j]==0) break;\n\t\t}\n\t}\n\tpd[1]=pd[2]=false;\n}\nbool pd2[N];\nint n,a[110];\nvector<int> v[2];\nvector<int> g[300];\nbool flag[300];\nint last[300];\nbool find(int x){\n\tint t;\n\tfor(int i = 0;i<g[x].size();i++) if(flag[t=g[x][i]]){\n\t\tflag[t] = false;\n\t\tif(last[t]==0) {\n\t\t\tlast[t] = x+1;\n\t\t\treturn true;\n\t\t} else if(find(last[t]-1)){\n\t\t\tlast[t] = x;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\nint main(){\n\tfind_prime();\n\tscanf(\"%d\",&n);\n\tfor(int i = 1;i<=n;i++)scanf(\"%d\",a+i),pd2[a[i]]=true;\n\tfor(int i = 1;i<N;i++) if(pd2[i]!=pd2[i-1]) v[i&1].push_back(i);\n\tfor(int i = 0;i<v[0].size();i++){\n\t\tfor(int j = 0;j<v[1].size();j++){\n\t\t\tif(pd[abs(v[0][i]-v[1][j])]) g[i].push_back(j);//puts(\"YYY\");\n\t\t}\n\t}\n\tint tot = 0;\n\t//for(int i = 0;i<v[1].size();i++) cout<<v[1][i]<<endl;\n\tfor(int i = 0;i<v[0].size();i++) {\n\t\tmemset(flag,true,sizeof(flag));\t\n\t\tif(find(i)) tot++;\n\t}\n\t//cout<<tot<<endl;\n\tprintf(\"%d\\n\",tot+(v[0].size()-tot)/2*2+(v[1].size()-tot)/2*2+(v[0].size()-tot)%2*3);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nconst int INF = (int)1e9;\n\nnamespace math {\n    const int N = (int)1.01e7;\n\n    char ispr[N];\n    vector<int> pr;\n\n    void init() {\n        memset(ispr, 1, sizeof(ispr));\n        ispr[1] = 0;\n        for (int i = 2; i < N; i++) {\n            if (!ispr[i]) continue;\n            pr.push_back(i);\n            for (int j = i + i; j < N; j += i) ispr[j] = 0;\n        }\n    }\n\n    bool isPrime(int x) {\n        if (x < N) return ispr[x];\n        for (int i = 0; i < (int)pr.size() && 1LL * pr[i] * pr[i] <= x; i++) {\n            if (x % pr[i] == 0) {\n                return 0;\n            }\n        }\n        return 1;\n    }\n}\n\nusing namespace math;\n\nvoid upd(int &x, int y) {\n    x = min(x, y);\n}\n\nint fastsolve(vector<int> x) {\n    int n = x.size();\n\n    vector<int> vv;\n    vv.push_back(x[0]);\n    for (int i = 0; i + 1 < n; i++) {\n        if (x[i + 1] != x[i] + 1) {\n            vv.push_back(x[i] + 1);\n            vv.push_back(x[i + 1]);\n        }\n    }\n    vv.push_back(x.back() + 1);\n\n    vector<vector<int> > vct(2);\n    for (int x : vv) {\n        vct[x % 2].push_back(x);\n    }\n    vector<vector<int> > e(vct[0].size());\n    for (int i = 0; i < (int)vct[0].size(); i++) {\n        for (int j = 0; j < (int)vct[1].size(); j++) {\n            if (isPrime(abs(vct[0][i] - vct[1][j]))) {\n                e[i].push_back(j);\n            }\n        }\n    }\n\n\n    vector<char> vis;\n    vector<int> mt(vct[1].size(), -1);\n    function<bool(int)> dfs = [&](int v) {\n        if (vis[v]) return false;\n        vis[v] = 1;\n        for (int to : e[v]) {\n            if (mt[to] == -1 || dfs(mt[to])) {\n                mt[to] = v;\n                return true;\n            }\n        }\n        return false;\n    };\n    int mat = 0;\n    for (int i = 0; i < (int)vct[0].size(); i++) {\n        vis.assign(vct[0].size(), 0);\n        mat += dfs(i);\n    }\n    int c0 = vct[0].size() - mat;\n    int c1 = vct[1].size() - mat;\n\n    int ans = 0;\n    ans += mat;\n    ans += c0 / 2 * 2;\n    ans += c1 / 2 * 2;\n    ans += c0 % 2 * (c1 % 2) * 3;\n\n    return ans;\n}\n\nint main() {\n#ifdef HOME\n    freopen(\"in\", \"r\", stdin);\n#endif\n    init();\n\n    int n;\n    while (cin >> n) {\n        vector<int> x(n);\n        for (int i = 0; i < n; i++) cin >> x[i];\n\n        cout << fastsolve(x) << endl;\n    }\n\n#ifdef HOME\n    cerr << clock() / (double)CLOCKS_PER_SEC << endl;\n#endif\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\nconst int N=1e5;\nint ne[N],he[N],a[N],vis[N],g[N],t[N],tot,b[N];\nvoid ad(int x,int y)\n{\n\ttot++;\n\tne[tot]=he[x];\n\the[x]=tot;\n\tt[tot]=y;\n}\nint pd(int x)\n{\n\tif (x%2==0) return 0;\n\tif (x==1) return 0;\n\tfor (int i=2;i<=sqrt(x);i++) if (x%i==0) return 0;\n\treturn 1;\n}\nint dfs(int x)\n{\n\tif (vis[x]==tot) return 0;\n\tvis[x]=tot;\n\tint i=he[x];\n\twhile (i)\n\t{\n\t\tif (g[t[i]]==0||dfs(g[t[i]])) \n\t\t{\n\t\t\tg[t[i]]=x;\n\t\t\treturn 1;\n\t\t}\n\t\ti=ne[i];\n\t}\n\treturn 0;\n}\nint main()\n{\n\tint n,x=0,y=0;\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<=n;i++) \n\t{\n\t\tscanf(\"%d\",&a[i]);\n\t\t//if (a[i]&1) x++;else y++;\n\t}\n\tsort(a+1,a+n+1);\n\tint m=1;\n\tb[1]=a[1]-1;\n\tfor (int i=2;i<=n;i++) \n\t{\n\t\tif (a[i]-a[i-1]!=1) \n\t\t{\n\t\t\tm++;\n\t\t\tb[m]=a[i-1];\n\t\t\tm++;\n\t\t\tb[m]=a[i]-1;\n\t\t}\n\t}\n\tm++;\n\tb[m]=a[n];\n\tfor (int i=1;i<=m;i++) for (int j=i+1;j<=m;j++) if (pd(abs(b[j]-b[i]))) ad(i,j);\n\tfor (int i=1;i<=m;i++) if (b[i]&1) x++;else y++;\n\tint ans=0;\n\tfor (int i=1;i<=m;i++) \n\t{\n\t\ttot++;\n\t\tans+=dfs(i);\n\t}\n\tx-=ans;\n\ty-=ans;\n\tif (x&1) \n\t{\n\t\tans+=3;\n\t\tx--;\n\t\ty--;\n\t}\n\tans+=x+y;\n\tprintf(\"%d\\n\",ans); \n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cmath>\n#include<cstring>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n\nconst int N=105;\nconst int M=10000005;\n\nint n1,n2,n,cnt,now,m,ans;\nint lk[N],p1[N],p2[N],pri[M],p[N],c[M],b[M];\nbool vis[M],tag[N];\nvector<int> lev[N];\n\nvoid getpri(int n){\n\tint i,j;\n\tfor (i=2;i<=n;i++){\n\t\tif (!vis[i]) pri[++cnt]=i;\n\t\tfor (j=1;j<=cnt&&pri[j]*i<=n;j++){\n\t\t\tvis[i*pri[j]]=1;\n\t\t\tif (i%pri[j]==0) break;\n\t\t}\n\t}\n\tvis[1]=vis[2]=1;\n}\n\nbool dfs(int k){\n\tint u,j;\n\tfor (j=0;j<lev[k].size();j++){\n\t\tu=lev[k][j];\n\t\tif (tag[u]!=now){\n\t\t\ttag[u]=now;\n\t\t\tif (!lk[u]||dfs(lk[u])){\n\t\t\t\tlk[u]=k;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint main(){\n\tint i,j;\n\tgetpri(M-1);\n\tscanf(\"%d\",&n);\n\tfor (i=1;i<=n;i++) scanf(\"%d\",&p[i]);\n\tsort(p+1,p+1+n); m=p[n]+1;\n\tfor (i=1;i<=n;i++) b[p[i]]^=1;\n\tfor (i=1;i<=m;i++) c[i]=b[i]!=b[i-1];\n\tfor (i=1;i<=m;i++)\n\t\tif (c[i]){\n\t\t\tif (i&1) p1[++n1]=i;\n\t\t\telse p2[++n2]=i;\n\t\t}\n\tfor (i=1;i<=n1;i++)\n\t\tfor (j=1;j<=n2;j++)\n\t\t\tif (!vis[abs(p1[i]-p2[j])]) lev[i].push_back(j);\n\tfor (i=1;i<=n1;i++){\n\t\tnow++;\n\t\tans+=dfs(i);\n\t}\n\tprintf(\"%d\\n\",ans+(n1-ans)/2*2+(n2-ans)/2*2+(n1-ans)%2*3);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 233;\nconst int INF = 1e9;\n\nstruct Edge {\n    int to, rev, cap;\n};\n\nint nv, sv, tv;\nvector<Edge> g[N];\nint dist[N], ptr[N];\n\nvoid add_edge(int a, int b, int c) {\n    g[a].push_back(Edge{b, int(g[b].size()), c});\n    g[b].push_back(Edge{a, int(g[a].size()) - 1, 0});\n    assert(max(a, b) < nv);\n}\n\nbool augment() {\n    fill_n(dist, nv, -1);\n    dist[sv] = 0;\n\n    vector<int> que;\n    que.push_back(sv);\n    for (int v: que) {\n        for (auto e: g[v]) {\n            if (dist[e.to] != -1 || e.cap == 0) {\n                continue;\n            }\n            dist[e.to] = dist[v] + 1;\n            if (e.to == tv) {\n                return true;\n            }\n            que.push_back(e.to);\n        }\n    }\n\n    return false;\n}\n\nint dfs(int v, int r) {\n    if (v == tv) {\n        return r;\n    }\n    for (int& i = ptr[v]; i < int(g[v].size()); i++) {\n        auto& e = g[v][i];\n        if (dist[e.to] <= dist[v] || e.cap == 0) {\n            continue;\n        }\n        int d = dfs(e.to, min(r, e.cap));\n        if (d == 0) {\n            continue;\n        }\n        e.cap -= d;\n        g[e.to][e.rev].cap += d;\n        return d;\n    }\n    return 0;\n}\n\nint exec() {\n    int res = 0;\n    while (augment()) {\n        fill_n(ptr, nv, 0);\n        while (true) {\n            int d = dfs(sv, INF);\n            if (d == 0) {\n                break;\n            }\n            res += d;\n        }\n    }\n    return res;\n}\n\nconst int M = int(1e7 + 10);\n\nint n;\nbool isp[M];\n\nvoid precalc() {\n    fill(isp + 2, isp + M, true);\n    for (int i = 2; i * i < M; i++) {\n        if (!isp[i]) {\n            continue;\n        }\n        for (int j = i * i; j < M; j += i) {\n            isp[j] = false;\n        }\n    }\n}\n\nint main() {\n    precalc();\n\n    scanf(\"%d\", &n);\n\n    set<int> a;\n    auto add = [&](int x) {\n        auto it = a.find(x);\n        if (it != a.end()) {\n            a.erase(it);\n        } else {\n            a.insert(x);\n        }\n    };\n\n    for (int i = 0; i < n; i++) {\n        int x;\n        scanf(\"%d\", &x);\n        add(x);\n        add(x + 1);\n    }\n\n    vector<vector<int>> v(2);\n    for (int x: a) {\n        v[x % 2].push_back(x);\n    }\n    int v0s = v[0].size(), v1s = v[1].size();\n\n    sv = 0;\n    tv = 1;\n    nv = v0s + v1s + 2;\n    for (int i = 0; i < v0s; i++) {\n        add_edge(sv, 2 + i, 1);\n    }\n    for (int i = 0; i < v1s; i++) {\n        add_edge(2 + v0s + i, tv, 1);\n    }\n    for (int i = 0; i < v0s; i++) {\n        for (int j = 0; j < v1s; j++) {\n            int d = abs(v[0][i] - v[1][j]);\n            if (d > 2 && isp[d]) {\n                add_edge(2 + i, 2 + v0s + j, 1);\n            }\n        }\n    }\n\n    int used = exec();\n    int ans = used;\n    ans += 2 * ((v0s - used) / 2);\n    ans += 2 * ((v1s - used) / 2);\n    if ((v0s - used) % 2 == 1) {\n        ans += 3;\n    }\n\n    printf(\"%d\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\nusing namespace std;\nstruct edge{\n\tint k,next;\n}e[2005];\nint n,a[1005],x[1005],m,home[1005],cnt=-1,flag[1005],y[1005];\nbool vis[10000005];\nvoid add(int x,int y){\n\tcnt++;\n\te[cnt].k=y;\n\te[cnt].next=home[x];\n\thome[x]=cnt;\n}\nint prime[10000005],cc=-1;\nbool isprime[10000005];\nvoid init(){\n\tisprime[1]=1;\n\tfor(int i=2;i<=10000002;i++){\n\t\tif(!isprime[i]){\n\t\t\tprime[++cc]=i;\n\t\t}\n\t\tfor(int p=1;p<=cc&&prime[p]*i<=10000002;p++){\n\t\t\tisprime[prime[p]*i]=1;\n\t\t\tif(i%prime[p]==0) break;\n\t\t}\n\t}\n}\nint Abs(int a){return a<0?-a:a;}\nbool used[2005];\nbool dfs(int k){\n\tfor(int i=home[k];~i;i=e[i].next) if(!used[e[i].k]){\n\t\tused[e[i].k]=1;\n\t\tif(!flag[e[i].k]||dfs(flag[e[i].k])){\n\t\t\tflag[e[i].k]=k;\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\nint main(){\n\tinit();\n\tmemset(home,-1,sizeof(home));\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++) scanf(\"%d\",&a[i]),vis[a[i]]=1;\n\tint o=a[n]+1;n=0;\n\tfor(int i=1;i<=o;i++) if(vis[i]!=vis[i-1]){\n\t\tif(i&1) x[++n]=i;\n\t\telse y[++m]=i;\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int p=1;p<=m;p++) if(!isprime[Abs(x[i]-y[p])]) add(i,p);\n\t}\n\tint ans=0;\n\tfor(int i=1;i<=n;i++){\n\t\tmemset(used,0,sizeof(used));\n\t\tif(dfs(i)) ans++;\n\t}\n\tans+=(n-ans)/2*2+(m-ans)/2*2;\n\tn=(n-ans)%2;m=(m-ans)%2;\n\tif(n&&m) ans+=3;\n\tprintf(\"%d\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <time.h>\n#include <random>\n#include <fstream>\n#include <set>\n\nusing namespace std;\n\nconst int N = 1e7 + 2;\n\nint n;\n\nint c[N];\nint p[N];\nint a[200];\n\nvector<int> graph[400];\n\nint paired[400];\nint marked[400];\n\nint TryKuhn(int v)\n{\n    if (marked[v]) return 0;\n    marked[v] = 1;\n    for (auto u : graph[v])\n    {\n        if (paired[u] == -1 || TryKuhn(paired[u]))\n        {\n            paired[u] = v;\n            return 1;\n        }\n    }\n    return 0;\n}\n\nint G()\n{\n    int res = 0;\n    fill(paired, paired + 400, -1);\n    for (int i = 0; i < n; i++)\n    {\n        fill(marked, marked + 400, 0);\n        if (TryKuhn(i))\n            res++;\n    }\n    return res;\n}\n\nsigned main()\n{\n    srand(time(NULL));\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    for (int i = 2; i < N; i++)\n    {\n        if (p[i] == 0)\n        {\n            for (int j = 2; j * i < N; j++) p[i * j] = 1;\n        }\n    }\n    p[2] = 1;\n    p[1] = 1;\n    cin >> n;\n    for (int i = 0; i < n; i++)\n    {\n        int x;\n        cin >> x;\n        c[x] = 1;\n    }\n    n = 0;\n    for (int i = 0; i + 1 < N; i++)\n    {\n        if (c[i] != c[i + 1])\n        {\n            a[n] = i;\n            n++;\n        }\n    }\n    for (int i = 0; i < n; i++)\n    {\n        for (int j = 0; j < n; j++)\n        {\n            if (a[i] % 2 == 0 && a[j] % 2 == 1)\n            {\n                if (!p[abs(a[i] - a[j])])\n                {\n                    graph[i].push_back(200 + j);\n                    graph[200 + j].push_back(i);\n                }\n            }\n        }\n    }\n    for (int i = 0; i < 400; i++)\n    {\n        for (auto u : graph[i])\n        {\n            cout << i << \" \" << u << endl;\n        }\n    }\n    int c0 = 0, c1 = 0, c2 = G();\n    for (int i = 0; i < n; i++)\n    {\n        if (a[i] % 2 == 0) c0++;\n        else c1++;\n    }\n    int ans = c2 + ((c0 - c2) / 2) * 2 + ((c1 - c2) / 2) * 2 + (c1 % 2) * 3;\n    cout << ans;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int maxp=1000050;\nint n;\nint sum[105],a[105],l[105],pos[105];\nint tot=0,tot1=0;\nint prime[maxp],primesize;\nbool isprime[maxp];\nvoid getlist(int listsize)\n{\n    memset(isprime,1,sizeof(isprime));\n    isprime[1]=false;\n    for(int i=2;i<=listsize;i++)\n    {\n        if(isprime[i]&&i!=2)\n\t\t\tprime[++primesize]=i;\n\t\tif(!isprime[i])\n\t\t\tcontinue;\n\t\tfor(int j=1;j<=primesize&&i*prime[j]<=listsize;j++)\n\t\t{\n            isprime[i*prime[j]]=false;\n            if(i%prime[j]==0)\n\t\t\t\tbreak;\n        }\n    }\n}\nint main() {\n\tgetlist(maxp-50);\n\tscanf(\"%d\",&n);\n\tsum[++tot]=1;\n\tfor(int i=1;i<=n;i++) {\n\t\tscanf(\"%d\",&a[i]);\n\t\tif(i==1)\n\t\t\tcontinue;\n\t\tif(a[i]==a[i-1]+1)\n\t\t\tsum[tot]++;\n\t\telse {\n\t\t\tif(sum[tot]==1) {\n\t\t\t\tl[++tot1]=tot;\n\t\t\t\tpos[tot1]=a[i-1];\n\t\t\t}\n\t\t\tsum[++tot]=1;\n\t\t}\n\t}\n\tif(sum[tot]==1) {\n\t\tl[++tot1]=tot;\n\t\tpos[tot1]=a[n];\n\t}\n\tint sumx=0;\n\tfor(int i=1;i<=tot;i++) {\n\t\tint tmp=sum[i];\n\t\tif(isprime[tmp]&&tmp!=2) {\n\t\t\tsumx++;\n\t\t\tcontinue;\n\t\t}\n\t\telse if(tmp%2==0) {\n\t\t\tsumx+=2;\n\t\t\tcontinue;\n\t\t}\n\t\telse if(tmp%2==1&&tmp!=1) {\n\t\t\tsumx+=3;\n\t\t\tcontinue;\n\t\t}\n\t\telse if(tmp==1)\n\t\t\tcontinue;\n\t}\n//\tcout<<tot1<<endl;\n\tfor(int i=1;i<=tot1;) {\n\t\tif(i<tot1) {\n\t\t\tif(l[i]==l[i+1]-1) {\n\t\t\t\tint tmp=pos[i+1],tmp1=pos[i];\n\t\t\t\tint tmp2=tmp-tmp1-1;\n\t\t\t\tint tmp3=tmp-tmp1;\n\t\t\t\tint tmp4=tmp-tmp1+1;\n\t\t\t\tif(isprime[tmp3]) {\n\t\t\t\t\tsumx+=2;\n\t\t\t\t\ti+=2;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(tmp2%2==0) {\n\t\t\t\t\tsumx+=4;\n\t\t\t\t\ti+=2;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(isprime[tmp2]&&isprime[tmp4]) {\n\t\t\t\t\tsumx+=2;\n\t\t\t\t\ti+=2;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif((isprime[tmp2]&&!isprime[tmp4])||(isprime[tmp4]&&!isprime[tmp2])) {\n\t\t\t\t\tsumx+=4;\n\t\t\t\t\ti+=2;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(!isprime[tmp2]&&!isprime[tmp4]) {\n\t\t\t\t\tsumx+=6;\n\t\t\t\t\ti+=2;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsumx+=3;\n\t\t\t\ti++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\telse if(i==tot1) {\n\t\t\tsumx+=3;\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\t}\n\tprintf(\"%d\\n\",sumx);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nbool up[10000002];\nvector<int> v1;\nvector<int> v2;\n\nint Nx,Ny;\nconst int MAXN = 200;\nvector<int> edgex[MAXN+1],edgey[MAXN+1];\nint matchx[MAXN+1],matchy[MAXN+1];\nbool visitx[MAXN+1],visity[MAXN+1];\nbool dfs(int x){\n   visitx[x]=true;\n   for(int i=0;i<edgex[x].size();i++){\n      int y=edgex[x][i];\n      visity[y]=true;\n      if(matchy[y]==-1||(!visitx[matchy[y]]&&dfs(matchy[y]))){\n         matchy[matchx[x]=y]=x;\n         return true;\n      }\n   }\n   return false;\n}\nint matching(){\n   memset(matchx,-1,sizeof matchx);\n   memset(matchy,-1,sizeof matchy);\n   int ans=0;\n   for(int i=0;i<Nx;i++){\n      memset(visitx,0,sizeof visitx);\n      memset(visity,0,sizeof visity);\n      if(dfs(i))  ans++;\n   }\n   return ans;\n}\nbool op(int x,int y){\n\tint tmp=abs(x-y);\n\tif(tmp==1||tmp==2)\treturn false;\n\tfor(long long int i=3;i*i<=tmp;i++)\n\t\tif(tmp%i==0)\n\t\t\treturn false;\n\treturn true;\n}\n\nint main(){\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\tint n;\n\tcin>>n;\n\tfor(int i=0,x;i<n;i++){\n\t\tcin>>x;\n\t\tup[x]=true;\n\t}\n\tfor(int i=1;i<=10000001;i++)\n\t\tif(up[i]!=up[i-1]){\n\t\t\tif(i&1)\n\t\t\t\tv1.push_back(i);\n\t\t\telse\n\t\t\t\tv2.push_back(i);\n\t\t}\n\tNx=v1.size();Ny=v2.size();\n\tfor(int i=0;i<Nx;i++)\n\t\tfor(int j=0;j<Ny;j++)\n\t\t\tif(op(i,j))\n\t\t\t\tedgex[i].push_back(j),edgey[j].push_back(i);\n\tint k=matching();\n\tcout<<k+(Nx-k)/2*2+(Ny-k)/2*2+3*((Nx-k)&1)<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <algorithm>\n#include <queue>\n#include <vector>\n#include <stack>\n#include <cmath>\n#include <memory.h>\n#include <iomanip>\nusing namespace std;\n\n#define maxn 202\n#define FOR(i, l, r) for (int i=l; i<=r; ++i)\n#define FORD(i, r, l) for (int i=r; i>=l; --i)\n#define REP(i, r) for (int i=0; i<(int)r; ++i)\n#define REPD(i, r) for (int i=(int)r-1; i>=0; --i)\n#define fi first\n#define se second\n#define mk make_pair\n#define nil NULL\n#define y0 y902\n#define y1 y232\n#define x0 x92\n#define x1 x899\n#define next asdfa\n#define sz size\n#define Debug(X) {cerr << #X << \" = \" << X << '\\n';}\n#define PR(A, n) {cerr << #A << \" = \"; FOR(i, 1, n) cerr << A[i] << ' '; cerr << '\\n';}\n#define PR0(A, n) {cerr << #A << \" = \"; REP(i, n) cerr << A[i] << ' '; cerr << '\\n';}\ntypedef long long ll;\ntypedef double db;\ntypedef pair<db, db> dd;\ntypedef pair<int, int> ii;\ntypedef vector<int> vi;\nconst int inf = 1e9;\ntemplate<class T> int getbit(T x, int pos) {return (x>>(pos-1)) & 1;}\ntemplate<class T> void turn_on(T &x, int pos) {x = x | ((T)1<<(pos-1));}\ntemplate<class T> void turn_off(T &x, int pos) {x = x & ~((T)1<<(pos-1));}\ntemplate<class T> T sqr(T a) {return a*a;}\n\nint n, assigned[maxn], visited[maxn], t;\nvector<int> a[maxn], even, odd;\n\nbool visit(int u) {\n    if (visited[u]!=t) visited[u] = t;\n    else return false;\n    REP(i, a[u].sz()) {\n        int v = a[u][i];\n        if (!assigned[v] || visit(assigned[v])) {\n            assigned[v] = u;\n            return true;\n        }\n    }\n    return false;\n}\n\nint findMaximumMatching() {\n    int cnt = 0;\n    REP(i, even.sz()) {\n        ++t;\n        cnt += visit(i);\n    }\n    return cnt;\n}\n\nbool isPrime(int a) {       ///Function will return false if a=2\n    if (a<=2) return false;\n    FOR(i, 2, sqrt(a)) {\n        if (a%i==0) return false;\n    }\n    return true;\n}\n\nint main() {\n    //freopen(\"prflip.inp\", \"r\", stdin);\n    //freopen(\"\", \"w\", stdout);\n    //ios::sync_with_stdio(0); cin.tie(0);\n    scanf(\"%d\", &n);\n    int prev = -1;\n    FOR(i, 1, n) {\n        int x; scanf(\"%d\", &x);\n        if (x!=prev+1) {\n            if (prev!=-1 && (prev+1)%2==0) even.push_back(prev+1);\n            else if (prev!=-1) odd.push_back(prev+1);\n            if (x%2==0) even.push_back(x);\n            else odd.push_back(x);\n        }\n        prev = x;\n    }\n    if ((prev+1)%2==0) even.push_back(prev+1);\n    else odd.push_back(prev+1);\n    REP(i, even.sz()) REP(j, odd.sz()) {\n        if (isPrime(abs(even[i]-odd[j])))\n            a[i].push_back(j);\n    }\n    int k = findMaximumMatching(), res = inf;\n    FOR(i, 0, k) {\n        if (((int)even.sz()-k)%2==0) res = min(res, k+((int)even.sz()-k)+((int)odd.sz()-k));\n        else res = min(res, k+((int)even.sz()-1-k)+((int)odd.sz()-1-k)+3);\n    }\n    printf(\"%d\", res);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define pb push_back\n#define x first\n#define y second\nusing namespace std;\ntypedef long long LL;\ntypedef vector<int> VI;\nusing namespace std;\nconst int NMAX=206;\nconst int INF=1000000666;\nconst LL INFLL=1000000000000666;\nconst LL maxv=100000;\nconst long double PI = acos(-1.0);\nconst int MAXT = 200000;\n\nint A[105];\nint dp[105];\nint n;\n\nmap<int, bool> M;\n\nint l[NMAX], r[NMAX];\nvector<int> G[NMAX];\nbool viz[NMAX];\nint lf,m,e,x,y,rs;\n \nbool dfs(int v)\n{\n    if(viz[v])\n        return 0;\n    viz[v]=1;\n    for(auto w:G[v])\n        if(l[w] == 0 || dfs(l[w]))\n        {\n            l[w]=v;\n            r[v]=w;\n            return 1;\n        }\n    return 0;\n}\n\n\nbool isprime(int x){\n  int i = 2;\n  int q = 1;\n  if(x == 1){\n    q = 0;\n  }\n  while(i*i <= x){\n    if((x%i) == 0){\n      q=0; \n    }\n    i++;\n  }\n  return q;\n}\n\nint cost(int x){\n  if(x < 0){\n    exit(0);\n  }\n  if(x == 0){\n    return 0;\n  }\n  if((x%2) == 0){\n    return 2;\n  }\n  else{\n    if(!M[x]){\n      if(isprime(x)){\n        return 1;\n        M[x] = 2;\n      }\n      else{\n        return 3;\n        M[x] = 1;\n      }\n    }\n    if(M[x] == 2){\n      return 1;\n    }\n    else\n    {\n      return 3;\n    }\n  }\n}\n\nvoid solve(){\n  cin>>n;\n  for(int i=1; i<=n; ++i){\n    cin>>A[i];\n  }\n  vector<int> df;\n  for(int i=1; i<=n; ++i){\n    if(A[i] - A[i-1] > 1 || i==1){\n      df.push_back(A[i]);\n    }\n    if(A[i+1] - A[i]>1 || i==n){\n      df.push_back(A[i] + 1);\n    }\n  }\n  //sort(df.begin(), df.end());\n  vector<int> lft, rht;\n\n  for(auto el: df){\n    //cout<<el<<\" \";\n    if(el % 2){\n      rht.push_back(el);\n    }\n    else{\n      lft.push_back(el);\n    }\n  }\n  lf = lft.size();\n  for(int i=0; i<lft.size(); ++i){\n    for(int j=0; j<rht.size(); ++j){\n      if(cost(abs(lft[i] - rht[j])) == 1)\n      {\n        G[i].push_back(j+n);\n\n      }\n    }\n  }\n  bool q=1;\n  while(q)\n  {\n      q=0;\n      memset(viz, 0, sizeof(viz));\n      for(int i=1; i<=lf; ++i)\n      {\n          if(r[i]==0 && dfs(i))\n          {\n              q=1;\n              rs++;\n          }\n      }\n  }\n  int a = lf - rs, b = rht.size() - rs;\n  cout<<2*(a/2) + 2*(b/2) + 3*(a%2)<<\"\\n\";\n  \n\n}\n\n\nint main()\n{\n    // Tic\n    //clock_t t=clock();\n    cout<<setprecision(10)<<fixed;\n    ios_base::sync_with_stdio(0);\n\n    //freopen(\"simetrii.in\", \"rt\", stdin);\n    //freopen(\"simetrii.out\", \"wt\", stdout);\n\n    solve();\n\n    //Toc\n    //t=clock()-t;\n    //printf (\"It took me %d clicks (%f seconds).\\n\",t,((float)t)/CLOCKS_PER_SEC);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <set>\n#include <map>\n#include <cmath>\n#include <string>\n#include <cstring>\n#include <sstream>\n#include <algorithm>\nusing namespace std;\n\nconst int Maxn = 105;\nconst int Inf = 1000000000;\n\nint n;\nint x[Maxn];\nint dp[Maxn];\n\nbool Prime(int x)\n{\n\tif (x <= 1) return false;\n\tif (x == 2) return true;\n\tif (x % 2 == 0) return false;\n\tfor (int i = 3; i * i <= x; i += 2)\n\t\tif (x % i == 0) return false;\n\treturn true;\n}\n\nint Get(int x)\n{\n\tif (x == 0) return 0;\n\tif (Prime(x) && x != 2) return 1;\n\tif (x % 2 == 0) return 2;\n\treturn 3;\n}\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; i++)\n\t\tscanf(\"%d\", &x[i]);\n\tfill(dp, dp + n + 1, Inf); dp[0] = 0;\n\tfor (int i = 0; i < n; i++) if (dp[i] < Inf) {\n\t\tint add = 0;\n\t\tfor (int j = i; j < n; j++) {\n\t\t\tdp[j + 1] = min(dp[j + 1], dp[i] + add + Get(x[j] - x[i] + 1));\n\t\t\tif (j + 1 < n) add += Get(x[j + 1] - x[j] - 1);\n\t\t}\n\t}\n\tprintf(\"%d\\n\", dp[n]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<queue>\n#include<stack>\n#include<cstring>\n#include<algorithm>\n#include<vector>\n#include<cmath>\nusing namespace std;\nint e[101][101];\nint vis[101];\nint match[101];\nint tot1=0,tot2=0;\nbool find(int u)\n{\n\tfor(int i=1;i<=tot2;i++)\n\t{\n\t\tif(e[u][i])\n\t\t{\n\t\t\tvis[i]=1;\n\t\t\tif(!match[i]||find(match[i]))\n\t\t\t{\n\t\t\t\tmatch[i]=u;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n}\nbool isprime(int x)\n{\n\tif(x==1) return false;\n\tfor(int i=2;i<=sqrt(x);i++)\n\t\tif(x%i==0)\n\t\t\treturn false;\n\treturn true;\n}\nint x[101];\nint odd[101];\nint even[101];\nsigned main()\n{\n\tint n;\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)\n\t\tscanf(\"%d\",&x[i]);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tif(i==1||x[i-1]!=x[i]-1)\n\t\t{\n\t\t\tif(x[i]%2==1) odd[++tot1]=x[i];\n\t\t\telse even[++tot2]=x[i];\n\t\t}\n\t\tif(i==n||x[i+1]!=x[i]+1)\n\t\t{\n\t\t\tif(x[i]%2==1) even[++tot2]=x[i]+1;\n\t\t\telse odd[++tot1]=x[i]+1;\n\t\t}\n\t}\n\tfor(int i=1;i<=tot1;i++)\n\t\tfor(int j=1;j<=tot2;j++)\n\t\t\tif(isprime(abs(odd[i]-even[j])))\n\t\t\t\te[i][j]=1;\n\tint ans=0;\n\tfor(int i=1;i<=tot1;i++)\n\t{\n\t\tmemset(vis,0,sizeof(vis));\n\t\tif(find(i))\n\t\t\tans++;\n\t}\n\tprintf(\"%d\",ans+(tot1-ans)/2*2+(tot2-ans)/2*2+(tot1-ans)%2*3);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nusing namespace std;\nint cnt,last[205],a[205],b[205],x[205],vis[205],match[205],prime[10000005],isprime[10000005],s[10000005];\nstruct node{\n\tint to,next;\n}e[1000005];\nvoid add(int a,int b){\n\te[++cnt].to=b;\n\te[cnt].next=last[a];\n\tlast[a]=cnt;\n}\nint dfs(int x){\n\tfor (int i=last[x]; i; i=e[i].next){\n\t\tint V=e[i].to;\n\t\tif (!vis[V]){\n\t\t\tvis[V]=1;\n\t\t\tif (!match[V] || dfs(V)){\n\t\t\t\tmatch[V]=x;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nint abs1(int x){\n\tif (x<0) return -x;\n\treturn x;\n}\nint main(){\n\tisprime[1]=1;\n\tfor (int i=2; i<=10000000; i++){\n\t\tif (!isprime[i]) prime[++cnt]=i;\n\t\tfor (int j=1; j<=cnt && i*prime[j]<=10000000; j++){\n\t\t\tisprime[i*prime[j]]=1;\n\t\t\tif (i%prime[j]==0) break;\n\t\t}\n\t}\n\tint n;\n\tscanf(\"%d\",&n);\n\tfor (int i=1; i<=n; i++){\n\t\tscanf(\"%d\",&x[i]);\n\t\ts[x[i]]^=1;\n\t}\n\tint num=0,sum=0;\n\tfor (int i=1; i<=10000001; i++)\n\t\tif (s[i]!=s[i-1]){\n\t\t\tif (i%2==1) a[++num]=i;\n\t\t\telse b[++sum]=i;\n\t\t}\n\tfor (int i=1; i<=num; i++)\n\t\tfor (int j=1; j<=sum; j++)\n\t\t\tif (!isprime[abs1(a[i]-b[j])]) add(i,j);\n\tint ss=0;\n\tfor (int i=1; i<=num; i++){\n\t\tfor (int j=1; j<=sum; j++) vis[j]=0;\n\t\tif (dfs(i)) ss++;\n\t}\n\tint ans=(num-ss)/2*2+(sum-ss)/2*2+ss+((num&1)!=(ss&1)?3:0);\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdlib>\n#include<vector>\n#include<cstring>\nusing namespace std;\nconst int N=205,M=1e7+10;\nint n,a[N],pri[M/10],tot,ans;\nbool vis[M],b[M],ur[N];\nint ld[N],rd[N],cl,cr,even,odd;\nint lf[N];\nvector<int>G[N];\nvoid sieve(int n){\n\tfor(int i=2;i<=n;++i){\n\t\tif(!vis[i])pri[++tot]=i;\n\t\tfor(int j=1;j<=tot&&i*pri[j]<=n;++j){\n\t\t\tvis[i*pri[j]]=1;\n\t\t\tif(i%pri[j]==0)break;\n\t\t}\n\t}\n}\nbool dfs(int u){\n\tfor(int to:G[u])\n\tif(!ur[to]){\n\t\tur[to]=1;\n\t\tif(!lf[to]||dfs(lf[to])){\n\t\t\tlf[to]=u;\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\nint main(){\n\tios::sync_with_stdio(0),cin.tie(0),cout.tie(0);\n\tcin>>n;\n\tfor(int i=1;i<=n;++i){\n\t\tcin>>a[i];\n\t\tb[a[i]]=1;\n\t}\n\tfor(int i=10000000;i;--i)if(b[i]^=b[i-1]){\n\t\tif(i&1)ld[++cl]=i;else rd[++cr]=i;\n\t}\n\tsieve(10000000);\n\tfor(int i=1;i<=cl;++i)\n\tfor(int j=1;j<=cr;++j)if(!vis[abs(ld[i]-rd[j])])G[i].push_back(j);\n\tmemset(lf,0,sizeof lf);\n\tfor(int i=1;i<=cl;++i){\n\t\tmemset(ur,0,sizeof ur);\n\t\tans+=dfs(i);\n\t}\n\tmemset(ur,0,sizeof ur);\n\tfor(int i=1;i<=cr;++i)ur[lf[i]]=1;\n\tfor(int i=1;i<=cl;++i)if(!ur[i])++odd;\n\tfor(int i=1;i<=cr;++i)if(!lf[i])++even;\n\tans+=(odd>>1<<1)+(even>>1<<1)+((odd&1)&&(even&1))*3;\n\tcout<<ans<<'\\n';\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nvector<int> pr, pchk;\nvoid getPrime() {\n    pchk = vector<int>(10000010, 0);\n    for(int i = 2; i < 10000010; i++) {\n        if(pchk[i]) continue;\n        int mul = 2;\n        while(i * mul < 10000010) {\n            pchk[i * mul] = 1;\n            mul++;\n        }\n    }\n    pchk[2] = 1;\n}\n\nint N;\nvector<int> X;\n\nvector<vector<int> > cc;\nint dp(int l, int r) {\n    int &ret = cc[l][r];\n    if(ret != -1) return ret;\n\n\n    int pre = X[l];\n    int tmp = 0;\n    for(int i = l + 1; i <= r + 1; i++) {\n        if(i == r + 1 || X[i - 1] + 1 != X[i]) {\n            tmp += (pchk[ X[i - 1] - pre + 1 ]? (((X[i - 1] - pre + 1) % 2)? 3 : 2) : 1);\n            if(i != r + 1) pre = X[i];\n        }\n    }\n    ret = tmp;\n    pre = 1;\n    tmp = 0;\n    for(int i = l; i <= r; i++) {\n        tmp += (X[i] - pre) % 2 == 0? (X[i] - pre == 0? 0 : 2) : (pchk[ X[i] - pre ]? 3 : 1);\n        pre = X[i] + 1;\n    }\n    if(pchk[ X[r] ]) tmp += (X[r] % 2 == 0? 2 : 3);\n    else tmp++;\n\n    ret = min(ret, tmp);\n    for(int i = l; i < r; i++) {\n        ret = min(ret, dp(l, i) + dp(i + 1, r));\n    }\n    return ret;\n}\n\nint main() {\n    getPrime();\n\n    scanf(\"%d\", &N);\n    X.resize(N);\n    for(int i = 0; i < N; i++) {\n        scanf(\"%d\", &X[i]);\n    }\n\n    cc = vector<vector<int> >(N, vector<int>(N, -1));\n    cout<<dp(0, N - 1);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#define fo(i,a,b) for(int i=a;i<=b;i++)\n#define N 210\n#define M 10000010\nusing namespace std;\nint n,a[M],q[N],w[N],bz[M],p[M],last[N],nxt[N*N],to[N*N],tot=0,b[N],jy=0,ans=0;\nvoid link(int x,int y)\n{\n\tnxt[++tot]=last[x];last[x]=tot;to[tot]=y;\n}\nint dg(int x)\n{\n\tif(bz[x]==tot) return 0;\n\tbz[x]=tot;\n\tfor(int i=last[x];i;i=nxt[i])\n\t{\n\t\tint y=to[i];\n\t\tif(b[y]==0||dg(b[y]))\n\t\t{\n\t\t\tb[y]=x;return 1;\n\t\t}\n\t}\n\treturn 0;\n}\nint main()\n{\n\tfo(i,2,10000000)\n\t{\n\t\tif(!bz[i]) p[++p[0]]=i;\n\t\tfo(j,1,p[0])\n\t\t{\n\t\t\tint k=i*p[j];\n\t\t\tif(k>=10000000) break;\n\t\t\tbz[k]=1;\n\t\t\tif(i%p[j]==0) break;\n\t\t}\n\t}\n\tscanf(\"%d\",&n);\n\tfo(i,1,n)\n\t{\n\t\tint x;scanf(\"%d\",&x);\n\t\ta[x]=1;\n\t}\n\tfo(i,1,10000002)\n\tif(a[i]!=a[i-1])\n\t{\n\t\tif(i%2==1) q[++q[0]]=i;\n\t\telse w[++w[0]]=i;\n\t}\n\tbz[1]=bz[2]=1;\n\tfo(i,1,q[0]) fo(j,1,w[0]) if(bz[abs(q[i]-w[j])]==0) link(i,j);\n\tmemset(bz,0,sizeof(bz));\n\tfor(tot=1;tot<=n;tot++) if(!bz[tot]&&b[tot]==0) jy+=dg(tot);\n\tans=jy;\n\tans+=2*((q[0]-jy)/2);\n\tans+=2*((w[0]-jy)/2);\n\tans+=3*((q[0]-jy)%2);\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<cmath>\n#include<vector>\n#include<queue>\n#include<map>\n#include<bitset>\n#include<set>\n#define N (200010)\n#define P ()\n#define M (11000010)\n#define inf (0x7f7f7f7f)\n#define rg register int\n#define Label puts(\"NAIVE\")\n#define spa print(' ')\n#define ent print('\\n')\n#define rand() (((rand())<<(15))^(rand()))\n#define file(s) freopen(s\".in\",\"r\",stdin),freopen(s\".out\",\"w\",stdout)\ntypedef long double ld;\ntypedef long long LL;\ntypedef unsigned long long ull;\nusing namespace std;\nnamespace fastIO1{\n\tinline char read(){\n\t\tstatic const int IN_LEN=1000000;\n\t\tstatic char buf[IN_LEN],*s,*t;\n\t\treturn (s==t?t=(s=buf)+fread(buf,1,IN_LEN,stdin),(s==t?-1:*s++):*s++);\n\t}\n\ttemplate<class T>\n\tinline void read(T &x){\n\t\tstatic bool iosig;\n\t\tstatic char c;\n\t\tfor(iosig=false,c=read();!isdigit(c);c=read()){\n\t\t\tif(c=='-')iosig=true;\n\t\t\tif(c==-1)return;\n\t\t}\n\t\tfor(x=0;isdigit(c);c=read())x=((x+(x<<2))<<1)+(c^'0');\n\t\tif(iosig)x=-x;\n\t}\n\tinline char readc(char &c){\n\t\tfor(c=read();!isalpha(c)&&!isdigit(c);c=read())\n\t\tif(c==-1)return 0;\n\t}\n\tconst int OUT_LEN = 10000000;\n\tchar obuf[OUT_LEN],*ooh=obuf;\n\tinline void print(char c) {\n\t\tif(ooh==obuf+OUT_LEN)fwrite(obuf,1,OUT_LEN,stdout),ooh=obuf;\n\t\t*ooh++=c;\n\t}\n\ttemplate<class T>\n\tinline void print(T x){\n\t\tstatic int buf[30],cnt;\n\t\tif(x==0)print('0');\n\t\telse{\n\t\t\tif(x<0)print('-'),x=-x;\n\t\t\tfor(cnt=0;x;x/=10)buf[++cnt]=x%10+48;\n\t\t\twhile(cnt)print((char)buf[cnt--]);\n\t\t}\n\t}\n\tinline void flush(){fwrite(obuf,1,ooh-obuf,stdout);}\n}\nnamespace fastIO2{\n\ttemplate<class T>\n\tinline void read(T &x){\n\t\tstatic bool iosig; \n\t\tstatic char c;\n\t\tfor(iosig=false,c=getchar();!isdigit(c);c=getchar()){\n\t\t\tif(c=='-')iosig=true;\n\t\t\tif(c==-1)return;\n\t\t}\n\t\tfor(x=0;isdigit(c);c=getchar())x=((x+(x<<2))<<1)+(c^'0');\n\t\tif(iosig)x=-x;\n\t}\n}\nusing namespace fastIO1;\nint n,a[M],prime[M],sum,cnt1,cnt2,od[N],ev[N];\nbool pr[M]; queue<int> Q; int dis[N],cur[N];\nint fi[N],ne[N<<4],to[N<<4],c[N<<4],S,T,V,E;\nbool bfs(int S,int T){\n\twhile(!Q.empty())Q.pop(); Q.push(S);\n\tfor(int i=1;i<=V;i++)dis[i]=inf,cur[i]=fi[i]; dis[S]=0;\n\twhile(!Q.empty()){\n\t\tint u=Q.front();Q.pop();\n\t\tfor(int i=fi[u];i;i=ne[i])\n\t\tif(c[i]&&dis[to[i]]==inf){\n\t\t\tint v=to[i];\n\t\t\tdis[v]=dis[u]+1;\n\t\t\tif(v==T)return 1; Q.push(v);\n\t\t}\n\t}\n\treturn dis[T]<=V;\n}\nint dfs(int u,int T,int flow){\n\tif(u==T)return flow;\n\tint usd=0;\n\tfor(int i=cur[u];i;i=cur[u]=ne[i])\n\tif(c[i]&&dis[to[i]]==dis[u]+1){\n\t\tint fl=dfs(to[i],T,min(flow-usd,c[i]));\n\t\tif(!fl)continue;c[i]-=fl,c[i^1]+=fl,usd+=fl;\n\t\tif(usd>=flow)return usd;\n\t}\n\treturn usd;\n}\nint dinic(int S,int T){\n\tint ans=0;\n\twhile(bfs(S,T))ans+=dfs(S,T,inf);\n\treturn ans;\t\n}\nvoid add(int x,int y,int z){\n\tne[++E]=fi[x],fi[x]=E,to[E]=y,c[E]=z;\n\tne[++E]=fi[y],fi[y]=E,to[E]=x,c[E]=z;\n}\nvoid Eular(int n){\n\tpr[1]=1;\n\tfor(int i=2;i<=n;i++){\n\t\tif(!pr[i]){\n\t\t\tprime[++sum]=i;\n\t\t\tif(i==2)pr[i]=1;\n\t\t}\n\t\tfor(int j=1;j<=sum;j++){\n\t\t\tif(prime[j]*i>n)break;\n\t\t\tpr[prime[j]*i]=1;if(i%prime[j]==0)break;\n\t\t}\n\t}\n}\nint main(){\n\tfile(\"oatmeal\");\n\tread(n),E=1;\n\tEular(10000010);\n\tfor(int i=1;i<=n;i++){\n\t\tint x; read(x);\n\t\ta[x]=1;\n\t}\n\tfor(int i=1;i<=10000001;i++)\n\tif(a[i]!=a[i-1]){if(i&1)od[++cnt1]=i;else ev[++cnt2]=i;}\n\tS=cnt1+cnt2+1,T=S+1,V=T;\n\tfor(int i=1;i<=cnt1;i++){\n\t\tadd(S,i,1);\n\t\tfor(int j=1;j<=cnt2;j++){\n\t\t\tint d=(int)abs(od[i]-ev[j]);\n\t\t\tif(!pr[d])add(i,j+cnt1,1);\n\t\t\tif(i==1)add(j+cnt1,T,1);\n\t\t}\n\t} \n\tint ans=dinic(S,T); cnt1-=ans,cnt2-=ans;\n\tcout<<ans+(cnt1/2)*2+(cnt2/2)*2+((cnt1&1)*3);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define maxn 10000005\n#define maxv 105\nusing namespace std;\nint prime[4100000];\nbool vis[maxn]= {0};\nint sum=0;\nint cnt1=0;\nint cnt2=0;\nvoid primejudge(int n)\n{\n    memset(vis,false,sizeof(vis));\n    vis[1]=true;\n    for(int i=2; i<=n; i++)\n    {\n        if(!vis[i])\n        {\n            prime[sum++]=i;\n        }\n        for(int j=0; j<sum&&i*prime[j]<=n; j++)\n        {\n            vis[i*prime[j]]=true;\n            if(i%prime[j]==0)\n                break;\n        }\n    }\n    vis[2]=true;\n}\nint a[maxv*5];\nint x[maxv*5];\nint mp1[maxv*5];\nint mp2[maxv*5];\nbool used[maxv*5];\nbool mps[maxv*2][maxv*2];\nint bel[maxv*5];\nbool findd(int q)\n{\n    int i,j;\n    for(j=1; j<=cnt2; j++)\n    {\n        if(mps[q][j]==true&&used[j]==false)\n        {\n            used[j]=true;\n            if(bel[j]==0||findd(bel[j]))\n            {\n                bel[j]=q;\n                return true;\n            }\n        }\n    }\n    return false;\n}\nint main()\n{\n    int n,i;\n    int match[maxv]= {0};\n    scanf(\"%d\",&n);\n    for(i=1; i<=n; i++)\n    {\n        scanf(\"%d\",&a[i]);\n        vis[a[i]]=true;\n    }\n    //cout<<\"ggggg\"<<endl;\n    int cnt=0;\n    for(i=1; i<maxn; i++)\n    {\n        if(vis[i]!=vis[i-1])\n        {\n            x[cnt++]=i;\n        }\n    }\n    primejudge(10000003);\n    //cout<<\"ggggg\"<<endl;\n    for(i=0; i<cnt; i++)\n    {\n        if(x[i]&1)\n            mp1[++cnt1]=x[i];\n        else\n            mp2[++cnt2]=x[i];\n    }\n    //cout<<\"ggggg\"<<endl;\n    for(i=1; i<=cnt1; i++)\n    {\n        for(int j=1; j<=cnt2; j++)\n        {\n            if(!vis[abs(mp1[i]-mp2[j])])\n            {\n                mps[i][j]=true;\n            }\n        }\n    }\n    int temp=0;\n    for(i=1; i<=cnt1; i++)\n    {\n        memset(used,false,sizeof(used));\n        if(findd(i))\n            temp++;\n    }\n    cnt1-=temp;\n    cnt2-=temp;\n    int ans=temp;\n    ans+=cnt1/2*2;\n    ans+=cnt2/2*2;\n    ans+=cnt1%2*3;\n    cout<<temp<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn=105;\nint n,a[maxn],cnt[2],match[maxn<<1];\nbool used[maxn<<1];\nvector<int> G[maxn<<1],diff;\nset<int> vis;\nbool dfs(int v) {\n    used[v]=1;\n    for (int i=0;i<(int)G[v].size();++i) {\n        int u=G[v][i],w=match[u];\n        if (!w||(!used[w]&&dfs(w))) {\n            match[v]=u;\n            match[u]=v;\n            return true;\n        }\n    }\n    return false;\n}\ninline int bipartite_matching() {\n    int ret=0;\n    for (int i=0;i<(int)diff.size();++i)\n        if (diff[i]%2==0&&!match[i]) {\n            memset(used,0,sizeof used);\n            ret+=dfs(i);\n        }\n    return ret;\n}\nbool check(int x) {\n    if (x<=2)\n        return false;\n    for (int i=2;i*i<=x;++i)\n        if (x%i==0)\n            return false;\n    return true;\n}\nint main()\n{\n    scanf(\"%d\",&n);\n    for (int i=1;i<=n;++i) {\n        scanf(\"%d\",&a[i]);\n        vis.insert(a[i]);\n    }\n    for (int i=1;i<=n;++i) {\n        if (vis.find(a[i]-1)==vis.end()) {\n            diff.push_back(a[i]);\n            ++cnt[a[i]%2];\n        }\n        if (vis.find(a[i]+1)==vis.end()) {\n            diff.push_back(a[i]+1);\n            ++cnt[(a[i]+1)%2];\n        }\n    }\n    for (int i=0;i<(int)diff.size();++i)\n        for (int j=i+1;j<(int)diff.size();++j)\n            if (check(abs(diff[i]-diff[j]))) {\n                G[i].push_back(j);\n                G[j].push_back(i);\n            }\n    int k=bipartite_matching();\n    printf(\"%d\\n\",k+2*((cnt[0]-k)/2+(cnt[1]-k)/2)+3*(cnt[0]-k)%2*3);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N;\nint X[101];\nvector<int> E,O;\n\ntemplate<class V> class MaxFlow_Ford {\npublic:\n\tstruct edge { int to,reve;V cap;};\n\tstatic const int MV = 10000;\n\tvector<edge> E[MV];\n\tint vis[MV];\n\tvoid add_edge(int x,int y,V cap,bool undir=false) {\n\t\tE[x].push_back((edge){y,(int)E[y].size(),cap});\n\t\tE[y].push_back((edge){x,(int)E[x].size()-1,undir?cap:0});\n\t}\n\tV dfs(int from,int to,V cf) {\n\t\tV tf;\n\t\tif(from==to) return cf;\n\t\tvis[from]=1;\n\t\tFORR(e,E[from]) if(vis[e.to]==0 && e.cap>0 && (tf = dfs(e.to,to,min(cf,e.cap)))>0) {\n\t\t\te.cap -= tf;\n\t\t\tE[e.to][e.reve].cap += tf;\n\t\t\treturn tf;\n\t\t}\n\t\treturn 0;\n\t}\n\tV maxflow(int from, int to) {\n\t\tV fl=0,tf;\n\t\twhile(1) {\n\t\t\tZERO(vis);\n\t\t\tif((tf = dfs(from,to,numeric_limits<V>::max()))==0) return fl;\n\t\t\tfl+=tf;\n\t\t}\n\t}\n};\nMaxFlow_Ford<int> mf;\n\nint prime(int x) {\n\tif(x<=2) return 0;\n\tfor(int a=2;a*a<=x;a++) if(x%a==0) return 0;\n\treturn 1;\n}\n\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N;\n\tmap<int,int> M;\n\tFOR(i,N) {\n\t\tcin>>X[i];\n\t\tM[X[i]]^=1;\n\t\tM[X[i]+1]^=1;\n\t}\n\t\n\tFORR(r,M) if(r.second) {\n\t\tif(r.first%2==0) E.push_back(r.first);\n\t\telse O.push_back(r.first);\n\t}\n\t\n\tFOR(x,E.size()) mf.add_edge(0,1000+x,1);\n\tFOR(x,O.size()) mf.add_edge(2000+x,1,1);\n\tFOR(x,E.size()) FOR(y,O.size()) if(prime(abs(E[x]-O[y]))) mf.add_edge(1000+x,2000+y,1);\n\t\n\tint ma=mf.maxflow(0,1);\n\tx=E.size()-ma;\n\ty=O.size()-ma;\n\tcout<<ma+(x/2)*2+(y/2)*2+x%2*3<<endl;\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n';\n\tFOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tsolve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \nconst int maxn = 1e7 + 700;\n \n \nint n,fre[maxn],p[220],ispr[maxn],even,odd,wrong;\nvector <int> edge[220],v2;\n \nbool fin(int u) {\n    if (fre[u]==wrong) return false;\n    fre[u]=wrong;\n    for (int j=0;j<edge[u].size();j++) {\n        int v=edge[u][j];\n       // cout<<u<<\" \"<<v<<endl;\n        if (p[v]==0 || fin(p[v])) {\n            p[v]=u;\n            return true;\n        }\n    }\n    return false;\n}\n \nint main() {\n  //  freopen(\"in.txt\",\"r\",stdin);\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    ispr[1]=1;\n    for (int i=2;i<maxn;i++)\n        if (ispr[i]==0) {\n            for (int j=i+i;j<maxn;j+=i) ispr[j]=1;\n        }\n    cin>>n;\n    for (int i=1;i<=n;i++) {\n        int x;\n        cin>>x;\n        fre[x]^=1;\n        fre[x+1]^=1;\n    }\n    even=0; odd=0; wrong=2;\n    for (int i=0;i<maxn;i++)\n        if (fre[i]==1) {\n            v2.push_back(i);\n            if (i%2==0) even++;\n            else odd++;\n        }\n    // for (int i=0;i<v2.size();i++) cout<<v2[i]<<\" \";\n   //  cout<<endl;\n   // cout<<\" \" <<even<<\" \"<<odd<<endl;\n    for (int i=0;i<v2.size();i++)\n        for (int j=0;j<v2.size();j++)\n            if (v2[i]%2==0 && v2[j]%2==1 && ispr[ abs(v2[j] - v2[i]) ]==0 && abs(v2[j] - v2[i])%2==1) {\n                edge[i].push_back(j);\n                edge[j].push_back(i);\n            }\n    int cnt=0;\n    for (int i=0;i<v2.size();i++)\n     if (v2[i]%2==0) {\n        wrong++;\n        if (fin(i)) cnt++;\n    }\n    cout<< cnt + (even-cnt)/2 *2 + (odd-cnt)/2 * 2 + (even-cnt)%2*3;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\", \"unroll-loops\")\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define ll long long\n\nbool isPrime(int p) {\n\tif (p == 1) return false;\n\tfor (ll i = 2; i * i <= p; ++i) {\n\t\tif (p % i == 0)\n\t\t\treturn false;\n\t}\n\treturn true;\n}\n\nstruct BipartiteMatching {\n\tvector< vector< int > > graph;\n\tvector< int > match, alive, used;\n\tint timestamp;\n\n\tBipartiteMatching(int n) : graph(n), alive(n, 1), used(n, 0), match(n, -1), timestamp(0) {}\n\n\tvoid add_edge(int u, int v) {\n\t\tgraph[u].push_back(v);\n\t\tgraph[v].push_back(u);\n\t}\n\n\tbool dfs(int idx) {\n\t\tused[idx] = timestamp;\n\t\tfor (auto& to : graph[idx]) {\n\t\t\tint to_match = match[to];\n\t\t\tif (alive[to] == 0) continue;\n\t\t\tif (to_match == -1 || (used[to_match] != timestamp && dfs(to_match))) {\n\t\t\t\tmatch[idx] = to;\n\t\t\t\tmatch[to] = idx;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tint bipartite_matching() {\n\t\tint ret = 0;\n\t\tfor (int i = 0; i < graph.size(); i++) {\n\t\t\tif (alive[i] == 0) continue;\n\t\t\tif (match[i] == -1) {\n\t\t\t\t++timestamp;\n\t\t\t\tret += dfs(i);\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n};\n\nint main() {\n\tint N; cin >> N;\n\tvector<int> x(N);\n\tfor (int i = 0; i < N; ++i)\n\t\tcin >> x[i];\n\tvector<int> idx_even, idx_odd;\n\tfor (int i = 0; i < N; ++i) {\n\t\tif (i == 0 || x[i - 1] + 1 != x[i]) {\n\t\t\tif (x[i] % 2) idx_even.push_back(x[i] - 1);\n\t\t\telse idx_odd.push_back(x[i] - 1);\n\t\t}\n\t\tif (i == N - 1 || x[i] + 1 != x[i + 1]) {\n\t\t\tif (x[i] % 2) idx_odd.push_back(x[i]);\n\t\t\telse idx_even.push_back(x[i]);\n\t\t}\n\t}\n\n\t/*\n\tfor (auto i : idx_even) cout << i << \" \";\n\tcout << endl;\n\tfor (auto i : idx_odd) cout << i << \" \";\n\tcout << endl;\n\t*/\n\n\tint sz = idx_even.size() + idx_odd.size();\n\tBipartiteMatching bm(sz);\n\tfor (int i = 0; i < idx_even.size(); ++i) {\n\t\tfor (int j = 0; j < idx_odd.size(); ++j) {\n\t\t\tint d = abs(idx_even[i] - idx_odd[j]);\n\t\t\tif (d != 2 && isPrime(d)) {\n\t\t\t\tint id1 = i, id2 = idx_even.size() + j;\n\t\t\t\tbm.add_edge(id1, id2);\n\t\t\t}\n\t\t}\n\t}\n\n\tint res = bm.bipartite_matching();\n\tint left_even = idx_even.size() - res;\n\tint left_odd = idx_odd.size() - res;\n\tres += left_even / 2 * 2;\n\tres += left_odd / 2 * 2;\n\tif (left_even % 2) {\n\t\tres += 3;\n\t}\n\n\tcout << res << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define For(i, j, k) for(int i = j; i <= k; i++)\n#define pb push_back\n\nusing namespace std;\n\nconst int N = 110;\nconst int M = 1e7 + 10;\n\nbool vis[M];\nint prm[M], tot;\n\nvoid init(int n){\n\tvis[1] = true;\n\tFor(i, 2, n){\n\t\tif(!vis[i]) prm[++tot] = i;\n\t\tfor(int j = 1; j <= tot && prm[j] * i <= n; ++j){\n\t\t\tvis[prm[j] * i] = true;\n\t\t\tif(i % prm[j] == 0) break;\n\t\t}\n\t}\n}\n\nint n, m;\nvector<int> G[N];\nint pos[N << 1], match[N], used[N];\n\nbool Hungary(int o){\n\tif(used[o]) return false;\n\tused[o] = true;\n\tfor(int v : G[o]){\n\t\tint &x = match[v];\n\t\tif(!x || Hungary(x)){\n\t\t\tx = o;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint main(){\n\t\n\tinit(M - 5);\n\tscanf(\"%d\", &n);\n\tFor(i, 1, n){\n\t\tint x;\n\t\tscanf(\"%d\", &x);\n\t\tpos[++m] = x, pos[++m] = x + 1;\n\t}\n\n\tsort(pos + 1, pos + m + 1);\n\tint node = 0;\n\tFor(i, 1, m){\n\t\tif(pos[i + 1] == pos[i]) ++i;\n\t\telse pos[++node] = pos[i];\n\t}\n\tFor(i, 1, node) if(pos[i] & 1)\n\t\tFor(j, 1, node){\n\t\t\tint x = abs(pos[i] - pos[j]);\n\t\t\tif(pos[j] % 2 == 0 && !vis[x]){\n\t\t\t\tG[i].pb(j);\n\t\t\t}\n\t\t}\n\n\tint ret = 0, odd = 0;\n\tFor(i, 1, node) if(pos[i] & 1){\n\t\t++odd;\n\t\tmemset(used, false, sizeof used);\n\t\tret += Hungary(i);\n\t}\n\n\tint even = node - odd - ret;\n\todd -= ret;\n\tif(even & 1) ret = node - ret + 1;\n\telse ret = node - ret;\n\n\tprintf(\"%d\\n\", ret);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma region Macros\n#pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\n#define ll long long\n#define ld long double\n#define rep2(i, a, b) for(ll i = a; i <= b; ++i)\n#define rep(i, n) for(ll i = 0; i < n; ++i)\n#define rep3(i, a, b) for(ll i = a; i >= b; --i)\n#define pii pair<int, int>\n#define pll pair<ll, ll>\n#define pb push_back\n#define eb emplace_back\n#define vi vector<int>\n#define vll vector<ll>\n#define vpi vector<pii>\n#define vpll vector<pll>\n#define overload2(_1, _2, name, ...) name\n#define vec(type, name, ...) vector<type> name(__VA_ARGS__)\n#define VEC(type, name, size)                                                                                                                                  \\\n    vector<type> name(size);                                                                                                                                   \\\n    IN(name)\n#define vv(type, name, h, ...) vector<vector<type>> name(h, vector<type>(__VA_ARGS__))\n#define VV(type, name, h, w)                                                                                                                                   \\\n    vector<vector<type>> name(h, vector<type>(w));                                                                                                             \\\n    IN(name)\n#define vvv(type, name, h, w, ...) vector<vector<vector<type>>> name(h, vector<vector<type>>(w, vector<type>(__VA_ARGS__)))\n#define fi first\n#define se second\n#define all(c) begin(c), end(c)\n#define ios ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n#define lb(c, x) distance((c).begin(), lower_bound(all(c), (x)))\n#define ub(c, x) distance((c).begin(), upper_bound(all(c), (x)))\nusing namespace std;\ntemplate <class T> using pq = priority_queue<T>;\ntemplate <class T> using pqg = priority_queue<T, vector<T>, greater<T>>;\n#define Size(c) (int)(c).size()\n#define INT(...)                                                                                                                                               \\\n    int __VA_ARGS__;                                                                                                                                           \\\n    IN(__VA_ARGS__)\n#define LL(...)                                                                                                                                                \\\n    ll __VA_ARGS__;                                                                                                                                            \\\n    IN(__VA_ARGS__)\n#define ULL(...)                                                                                                                                               \\\n    ull __VA_ARGS__;                                                                                                                                           \\\n    IN(__VA_ARGS__)\n#define STR(...)                                                                                                                                               \\\n    string __VA_ARGS__;                                                                                                                                        \\\n    IN(__VA_ARGS__)\n#define CHR(...)                                                                                                                                               \\\n    char __VA_ARGS__;                                                                                                                                          \\\n    IN(__VA_ARGS__)\n#define DBL(...)                                                                                                                                               \\\n    double __VA_ARGS__;                                                                                                                                        \\\n    IN(__VA_ARGS__)\n#define LD(...)                                                                                                                                                \\\n    ld __VA_ARGS__;                                                                                                                                            \\\n    IN(__VA_ARGS__)\nint scan() { return getchar(); }\ntemplate <class T> void scan(T a) { cin >> a; }\nvoid scan(int &a) { cin >> a; }\nvoid scan(long long &a) { cin >> a; }\nvoid scan(char &a) { cin >> a; }\nvoid scan(double &a) { cin >> a; }\nvoid scan(long double &a) { cin >> a; }\nvoid scan(char a[]) { scanf(\"%s\", a); }\nvoid scan(string &a) { cin >> a; }\ntemplate <class T> void scan(vector<T> &);\ntemplate <class T, size_t size> void scan(array<T, size> &);\ntemplate <class T, class L> void scan(pair<T, L> &);\ntemplate <class T, size_t size> void scan(T (&)[size]);\ntemplate <class T> void scan(vector<T> &a) {\n    for(auto &i : a) scan(i);\n}\ntemplate <class T> void scan(deque<T> &a) {\n    for(auto &i : a) scan(i);\n}\ntemplate <class T, size_t size> void scan(array<T, size> &a) {\n    for(auto &i : a) scan(i);\n}\ntemplate <class T, class L> void scan(pair<T, L> &p) {\n    scan(p.first);\n    scan(p.second);\n}\ntemplate <class T, size_t size> void scan(T (&a)[size]) {\n    for(auto &i : a) scan(i);\n}\ntemplate <class T> void scan(T &a) { cin >> a; }\nvoid IN() {}\ntemplate <class Head, class... Tail> void IN(Head &head, Tail &... tail) {\n    scan(head);\n    IN(tail...);\n}\nstring stin() {\n    string s;\n    cin >> s;\n    return s;\n}\ntemplate <class T> inline bool chmax(T &a, T b) {\n    if(a < b) {\n        a = b;\n        return 1;\n    }\n    return 0;\n}\ntemplate <class T> inline bool chmin(T &a, T b) {\n    if(a > b) {\n        a = b;\n        return 1;\n    }\n    return 0;\n}\nvi iota(int n) {\n    vi a(n);\n    iota(all(a), 0);\n    return a;\n}\ntemplate <class T> void UNIQUE(vector<T> &x) {\n    sort(all(x));\n    x.erase(unique(all(x)), x.end());\n}\nint in() {\n    int x;\n    cin >> x;\n    return x;\n}\nll lin() {\n    unsigned long long x;\n    cin >> x;\n    return x;\n}\nvoid print() { putchar(' '); }\nvoid print(bool a) { cout << a; }\nvoid print(int a) { cout << a; }\nvoid print(long long a) { cout << a; }\nvoid print(char a) { cout << a; }\nvoid print(string &a) { cout << a; }\nvoid print(double a) { cout << a; }\ntemplate <class T> void print(const vector<T> &);\ntemplate <class T, size_t size> void print(const array<T, size> &);\ntemplate <class T, class L> void print(const pair<T, L> &p);\ntemplate <class T, size_t size> void print(const T (&)[size]);\ntemplate <class T> void print(const vector<T> &a) {\n    if(a.empty()) return;\n    print(a[0]);\n    for(auto i = a.begin(); ++i != a.end();) {\n        cout << \" \";\n        print(*i);\n    }\n    cout << endl;\n}\ntemplate <class T> void print(const deque<T> &a) {\n    if(a.empty()) return;\n    print(a[0]);\n    for(auto i = a.begin(); ++i != a.end();) {\n        cout << \" \";\n        print(*i);\n    }\n}\ntemplate <class T, size_t size> void print(const array<T, size> &a) {\n    print(a[0]);\n    for(auto i = a.begin(); ++i != a.end();) {\n        cout << \" \";\n        print(*i);\n    }\n}\ntemplate <class T, class L> void print(const pair<T, L> &p) {\n    cout << '(';\n    print(p.first);\n    cout << \",\";\n    print(p.second);\n    cout << ')';\n}\ntemplate <class T> void print(set<T> &x) {\n    for(auto e : x) print(e), cout << \" \";\n    cout << endl;\n}\ntemplate <class T> void print(multiset<T> &x) {\n    for(auto e : x) print(e), cout << \" \";\n    cout << endl;\n}\ntemplate <class T, size_t size> void print(const T (&a)[size]) {\n    print(a[0]);\n    for(auto i = a; ++i != end(a);) {\n        cout << \" \";\n        print(*i);\n    }\n}\ntemplate <class T> void print(const T &a) { cout << a; }\nint out() {\n    putchar('\\n');\n    return 0;\n}\ntemplate <class T> int out(const T &t) {\n    print(t);\n    putchar('\\n');\n    return 0;\n}\ntemplate <class Head, class... Tail> int out(const Head &head, const Tail &... tail) {\n    print(head);\n    putchar(' ');\n    out(tail...);\n    return 0;\n}\nll gcd(ll a, ll b) {\n    while(b) {\n        ll c = b;\n        b = a % b;\n        a = c;\n    }\n    return a;\n}\nll lcm(ll a, ll b) {\n    if(!a || !b) return 0;\n    return a * b / gcd(a, b);\n}\nvector<pll> factor(ll x) {\n    vector<pll> ans;\n    for(ll i = 2; i * i <= x; i++)\n        if(x % i == 0) {\n            ans.push_back({i, 1});\n            while((x /= i) % i == 0) ans.back().second++;\n        }\n    if(x != 1) ans.push_back({x, 1});\n    return ans;\n}\nvector<int> divisor(int x) {\n    vector<int> ans;\n    for(int i = 1; i * i <= x; i++)\n        if(x % i == 0) {\n            ans.pb(i);\n            if(i * i != x) ans.pb(x / i);\n        }\n    return ans;\n}\ntemplate <typename T> void zip(vector<T> &x) {\n    vector<T> y = x;\n    sort(all(y));\n    for(int i = 0; i < x.size(); ++i) { x[i] = lb(y, x[i]); }\n}\nint popcount(ll x) { return __builtin_popcountll(x); }\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nint rnd(int n) { return uniform_int_distribution<int>(0, n - 1)(rng); }\ntemplate <typename T> void shuffle(vector<T> &v) {\n    rep3(i, v.size() - 1, 1) { swap(v[i], v[rnd(i)]); }\n}\n#define endl '\\n'\nvector<string> YES{\"NO\", \"YES\"};\nvector<string> Yes{\"No\", \"Yes\"};\nvector<string> yes{\"no\", \"yes\"};\n\n#ifdef _LOCAL\n#undef endl\n#define debug(x)                                                                                                                                               \\\n    cout << #x << \": \";                                                                                                                                        \\\n    print(x);                                                                                                                                                  \\\n    cout << endl;\nvoid err() {}\ntemplate <class T> void err(const T &t) {\n    print(t);\n    cout << \" \";\n}\ntemplate <class Head, class... Tail> void err(const Head &head, const Tail &... tail) {\n    print(head);\n    putchar(' ');\n    out(tail...);\n}\n#else\n#define debug(x)\ntemplate <class... T> void err(const T &...) {}\n#endif\n\ntemplate <typename T> struct edge {\n    int from, to;\n    T cost;\n    int id;\n    edge(int to, T cost) : from(-1), to(to), cost(cost) {}\n    edge(int from, int to, T cost) : from(from), to(to), cost(cost) {}\n    // edge(int from,int to,T cost,int id):from(from),to(to),cost(cost),id(id){}\n    edge &operator=(const int &x) {\n        to = x;\n        return *this;\n    }\n    operator int() const { return to; }\n};\n\ntemplate <typename T> using Edges = vector<edge<T>>;\ntemplate <typename T> using WeightedTree = vector<Edges<T>>;\ntemplate <typename T> using Edges = vector<edge<T>>;\ntemplate <typename T> using WeightedGraph = vector<Edges<T>>;\ntemplate <typename T> using Matrix = vector<vector<T>>;\nusing Graph = vector<vector<int>>;\nusing tree = vector<vector<int>>;\n\ntree getTree(int n, int offset = 1) {\n    tree res(n);\n    for(int i = 0; i < n - 1; i++) {\n        int a, b;\n        cin >> a >> b;\n        a -= offset, b -= offset;\n        res[a].emplace_back(b);\n        res[b].emplace_back(a);\n    }\n    return res;\n}\ntemplate <typename T> WeightedTree<T> getWeightedTree(int n, int offset = 1) {\n    WeightedTree<T> res(n);\n    for(int i = 0; i < n - 1; i++) {\n        int a, b;\n        cin >> a >> b;\n        a -= offset, b -= offset;\n        T c;\n        cin >> c;\n        res[a].emplace_back(b, c);\n        res[b].emplace_back(a, c);\n    }\n    return res;\n}\n\nGraph getGraph(int n, int m, int offset = 1) {\n    Graph res(n);\n    for(int i = 0; i < m; ++i) {\n        int a, b;\n        cin >> a >> b;\n        a -= offset, b -= offset;\n        res[a].emplace_back(b);\n        res[b].emplace_back(a);\n    }\n    return res;\n}\n\ntemplate <typename T> WeightedGraph<T> getWeightedGraph(int n, int m, int offset = 1) {\n    WeightedGraph<T> res(n);\n    for(int i = 0; i < m; ++i) {\n        int a, b;\n        cin >> a >> b;\n        T c;\n        cin >> c;\n        res[a].emplace_back(b, c);\n        res[b].emplace_back(a, c);\n    }\n}\nstruct Setup_io {\n    Setup_io() {\n        ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n        cout << fixed << setprecision(15);\n    }\n} setup_io;\n#pragma endregion\n\n// _________コーディングはここから！！___________\n\nnamespace Factorize {\nusing i128 = __int128_t;\nll get_factor(ll n) {\n    if(n == 3 or n == 5) return 0;\n    ll x, y;\n    ll iter = 0;\n    while(true) {\n        ++iter;\n        x = iter % n;\n        y = (i128(iter) * i128(iter) + 1) % i128(n);\n        while(1) {\n            ll g = gcd(n, abs(x - y));\n            if(g == n) break;\n            if(g > 1) return g;\n            x = (i128(x) * i128(x) + 1) % i128(n);\n            y = (i128(y) * i128(y) + 1) % i128(n);\n            y = (i128(y) * i128(y) + 1) % i128(n);\n        }\n    }\n}\nll modpow(ll a, ll n, ll mod) {\n    ll res = 1;\n    while(n) {\n        if(n & 1) res = i128(a) * i128(res) % i128(mod);\n        n >>= 1, a = i128(a) * i128(a) % i128(mod);\n    }\n    return res;\n}\nbool miller_rabin_test(ll p, ll s, ll d, ll n) {\n    ll x = modpow(p, d, n);\n    if(x == 1) return true;\n    ll y = n - 1;\n    rep(i, s) {\n        if(x == y) return true;\n        x = i128(x) * i128(x) % i128(n);\n    }\n    return false;\n}\nbool miller_rabin(ll n) {\n    if(n == 1) return false;\n    ll d = n - 1, s = 0;\n    while(~d & 1) d >>= 1, ++s;\n    if(n < 4759123141LL) {\n        for(auto p : {2, 7, 61}) {\n            if(p >= n) break;\n            if(!miller_rabin_test(p, s, d, n)) return false;\n        }\n    } else {\n        for(auto p : {2, 325, 9375, 28178, 450775, 9780504, 1795265022}) {\n            if(p >= n) break;\n            if(!miller_rabin_test(p, s, d, n)) return false;\n        }\n    }\n    return true;\n}\n\nmap<ll, int> factorize(ll n) {\n    map<ll, int> res;\n    while(~n & 1) res[2]++, n >>= 1;\n    queue<ll> que;\n    que.emplace(n);\n    while(!que.empty()) {\n        ll now = que.front();\n        que.pop();\n        if(now == 1) continue;\n        if(miller_rabin(now)) {\n            res[now]++;\n            continue;\n        }\n        ll g = get_factor(now);\n        que.emplace(g);\n        que.emplace(now / g);\n    }\n    return res;\n}\n\nbool isPrime(ll n) { return miller_rabin(n); }\n} // namespace Factorize\nusing namespace Factorize;\nstruct HopcroftKarp {\n    vector<vector<int>> graph;\n    vector<int> dist, match;\n    vector<bool> used, vv;\n\n    HopcroftKarp(int n, int m) : graph(n), match(m, -1), used(n) {}\n\n    void add_edge(int u, int v) { graph[u].push_back(v); }\n\n    void bfs() {\n        dist.assign(graph.size(), -1);\n        queue<int> que;\n        for(int i = 0; i < graph.size(); i++) {\n            if(!used[i]) {\n                que.emplace(i);\n                dist[i] = 0;\n            }\n        }\n\n        while(!que.empty()) {\n            int a = que.front();\n            que.pop();\n            for(auto &b : graph[a]) {\n                int c = match[b];\n                if(c >= 0 && dist[c] == -1) {\n                    dist[c] = dist[a] + 1;\n                    que.emplace(c);\n                }\n            }\n        }\n    }\n\n    bool dfs(int a) {\n        vv[a] = true;\n        for(auto &b : graph[a]) {\n            int c = match[b];\n            if(c < 0 || (!vv[c] && dist[c] == dist[a] + 1 && dfs(c))) {\n                match[b] = a;\n                used[a] = true;\n                return (true);\n            }\n        }\n        return (false);\n    }\n\n    int bipartite_matching() {\n        int ret = 0;\n        while(true) {\n            bfs();\n            vv.assign(graph.size(), false);\n            int flow = 0;\n            for(int i = 0; i < graph.size(); i++) {\n                if(!used[i] && dfs(i)) ++flow;\n            }\n            if(flow == 0) return (ret);\n            ret += flow;\n        }\n    }\n\n    void output() {\n        for(int i = 0; i < match.size(); i++) {\n            if(~match[i]) { cout << match[i] << \"-\" << i << endl; }\n        }\n    }\n};\n\nmain() {\n    INT(n);\n    VEC(int, a, n);\n    const int N = 1e7 + 2;\n    vi p(N);\n    rep(i, n) p[a[i]]++;\n    rep(i, N - 1) { p[i] = p[i + 1] ^ p[i]; }\n    vi x[2];\n    rep(i, N) {\n        if(p[i]) x[i & 1].eb(i);\n    }\n    HopcroftKarp g(x[0].size(), x[1].size());\n    rep(i, x[0].size()) {\n        rep(j, x[1].size()) {\n            int d = abs(x[1][j] - x[0][i]);\n            if(isPrime(d)) g.add_edge(i, j);\n        }\n    }\n    int d = g.bipartite_matching();\n    int ans = x[0].size() + x[1].size() + d;\n    if((x[0].size() - d) & 1) ans++;\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cmath>\n#include<algorithm>\n#include<stack>\n#include<queue>\n#include<map>\n#include<set>\n#include<iomanip>\n#define _USE_MATH_DEFINES\n#include <math.h>\n#include <functional>\n#include<complex>\nusing namespace std;\n\n#define rep(i,x) for(ll i=0;i<x;i++)\n#define repn(i,x) for(ll i=1;i<=x;i++)\n\ntypedef long long ll;\nconst ll INF = 1e17;\nconst ll MOD = 1000000007;\nconst ll MAX = 4000001;\nconst long double eps = 1E-14;\n\nll max(ll a, ll b) {\n\tif (a > b) { return a; }\n\treturn b;\n}\n\nll min(ll a, ll b) {\n\tif (a > b) { return b; }\n\treturn a;\n}\n\nll gcd(ll a, ll b) {\n\tif (b == 0) { return a; }\n\tif (a < b) { return gcd(b, a); }\n\treturn gcd(b, a % b);\n}\n\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b) * b;\n}\n\nstruct edge {\n\tll ind;\n\tll fr;\n\tll to;\n\tll d;\n};\n\nclass mint {\n\tlong long x;\npublic:\n\tmint(long long x = 0) : x((x% MOD + MOD) % MOD) {}\n\tmint operator-() const {\n\t\treturn mint(-x);\n\t}\n\tmint& operator+=(const mint& a) {\n\t\tif ((x += a.x) >= MOD) x -= MOD;\n\t\treturn *this;\n\t}\n\tmint& operator-=(const mint& a) {\n\t\tif ((x += MOD - a.x) >= MOD) x -= MOD;\n\t\treturn *this;\n\t}\n\tmint& operator*=(const  mint& a) {\n\t\t(x *= a.x) %= MOD;\n\t\treturn *this;\n\t}\n\tmint operator+(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res += a;\n\t}\n\tmint operator-(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res -= a;\n\t}\n\tmint operator*(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res *= a;\n\t}\n\n\tmint pow(ll t) const {\n\t\tif (!t) return 1;\n\t\tmint a = pow(t >> 1);\n\t\ta *= a;\n\t\tif (t & 1) a *= *this;\n\t\treturn a;\n\t}\n\n\t// for prime MOD\n\tmint inv() const {\n\t\treturn pow(MOD - 2);\n\t}\n\tmint& operator/=(const mint& a) {\n\t\treturn (*this) *= a.inv();\n\t}\n\tmint operator/(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res /= a;\n\t}\n\n\tfriend ostream& operator<<(ostream& os, const mint& m) {\n\t\tos << m.x;\n\t\treturn os;\n\t}\n};\n\nmint pw(mint a, ll b) {\n\tif (b == 0) { return 1; }\n\tmint ret = pw(a, b >> 1);\n\tret *= ret;\n\tif (b & 1) { ret *= a; }\n\treturn ret;\n}\n\ntypedef vector<ll> vll;\ntypedef vector<vector<ll>> vvll;\ntypedef vector<vector<vector<ll>>> vvvll;\n\ntypedef vector<mint> vmint;\ntypedef vector<vector<mint>> vvmint;\ntypedef vector<vector<vector<mint>>> vvvmint;\n\n//////////////////////////////////////\n\nstruct Ford_Fulkerson {\n\n\tstruct f_edge {\n\t\tll to;\n\t\tll cap;\n\t\tll fl;\n\t\tll rev;//反対方向の辺の添え字\n\t};\n\n\n\tll N;\n\tll s, t;\n\tvector<vector<edge>> g;//グラフ片方向にのみ張る、flowで双方向に構築\n\tvector<vector<f_edge>> flow;\n\tll maxflow;\n\n\tvector<bool> see;\n\tll dfs(ll v, ll x) {\n\t\tsee[v] = 1;\n\n\t\tif (v == t) { return x; }\n\n\t\trep(i, flow[v].size()) {\n\t\t\tconst auto e = flow[v][i];\n\n\t\t\tif (see[e.to] == 1) { continue; }\n\t\t\tif (e.cap == e.fl) { continue; }\n\n\t\t\tll y = min(x, e.cap - e.fl);\n\n\t\t\ty = dfs(e.to, y);\n\t\t\tif (y == 0) { continue; }\n\n\t\t\tflow[v][i].fl += y;\n\t\t\tflow[e.to][e.rev].fl -= y;\n\t\t\treturn y;\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tFord_Fulkerson(ll N0, vector<vector<edge>> g0, ll s0, ll t0) {\n\t\tN = N0;\n\t\tg = g0;\n\t\ts = s0;\n\t\tt = t0;\n\n\t\tflow.resize(N + 1);\n\t\trepn(v, N) {\n\t\t\tfor (edge e : g[v]) {\n\t\t\t\tll w = e.to;\n\t\t\t\tflow[v].push_back({ w,e.d,0,flow[w].size() });\n\t\t\t\tflow[w].push_back({ v,0,0,flow[v].size() - 1 });\n\t\t\t}\n\t\t}\n\n\t\tmaxflow = 0;\n\n\t\tif (s == t) { maxflow = INF; return; }\n\n\t\twhile (1) {\n\t\t\tsee.assign(N + 1, 0);\n\t\t\tll f = dfs(s, INF);\n\t\t\tif (f == 0) { break; }\n\t\t\tmaxflow += f;\n\t\t}\n\n\t\tmaxflow = min(INF, maxflow);\n\n\t\treturn;\n\n\t}\n};\n\nbool odprime(ll x) {\n\tif (x <= 2) { return 0; }\n\tfor (ll i = 2; i * i <= x; i++) {\n\t\tif (x % i == 0) { return 0; }\n\t}\n\n\treturn 1;\n}\n\nint main() {\n\n\tll N;\n\tcin >> N;\n\tvll x(N + 1);\n\trepn(i, N) cin >> x[i];\n\n\tll M = 20000000;\n\tvector<bool> omote(M + 1, 1);\n\trepn(i, N) { omote[x[i]] = 0; }\n\n\tvector<ll> a(1, 0);\n\trep(i, M) { if (omote[i] != omote[i + 1]) { a.push_back(i); } }\n\tll K = a.size() - 1;\n\n\tvector<vector<edge>> g(K + 3);\n\tll ev = 0;\n\tll od = 0;\n\n\trepn(i, K) {\n\t\tif (a[i] % 2 == 1) { g[K + 1].push_back({ 0,K + 1,i,1 }); od++; }\n\t\telse { g[i].push_back({ 0,i,K + 2,1 }); ev++; }\n\t}\n\n\trepn(i, K)repn(j, K) {\n\t\tif (a[i] % 2 == 1 && a[j] % 2 == 1 && odprime(abs(a[i] - a[j]))) {\n\t\t\tg[i].push_back({0,i,j,1});\n\t\t}\n\t}\n\n\tFord_Fulkerson fd(K+2, g, K + 1, K + 2);\n\n\tll ans = fd.maxflow;\n\tod -= ans;\n\tev -= ans;\n\tans += od / 2 * 2;\n\tans += ev / 2 * 2;\n\tif (od % 2 == 1) { ans += 3; }\n\n\tcout << ans << endl;\n\n\t\n\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <algorithm>\n#include <vector>\nusing std::vector;\nconst int maxn = 205;\nconst int maxm = 1e7+5;\nint n, m;\nint a[maxn], b[maxm], x[maxm], vis1[maxn], vis2[maxn];\nint is_prime[maxm], prime[maxm], cnt;\nvector<int> to[maxn];\nint X[maxn], Y[maxn], cnt1, cnt2;\nvoid pre() {\n    scanf(\"%d\", &n);\n    for(int i = 1; i <= n; i++) {\n\tscanf(\"%d\", &a[i]);\n\tm = std::max(m, a[i]);\n\tx[a[i]] = 1;\n    }\n    m++;\n    for(int i = 1; i <= m; i++) {\n\tb[i] = x[i] ^ x[i-1];\n\tif(b[i] == 1) {\n\t    if(i & 1) X[++cnt1] = i;\n\t    else Y[++cnt2] = i;\n\t}\n    }\n} \nvoid add_edge(int u, int v) {\n    to[u].push_back(v);\n}\nvoid add(int u, int v) {\n    add_edge(u, v);\n    add_edge(v, u);\n}\nvoid build_graph() {\n    for(int i = 1; i <= cnt1; i++) \n       for(int j = 1; j <= cnt2; j++) \n\t    if(is_prime[abs(X[i] - Y[j])]) add(i, j + n); \n}\nvoid shake(int n) {\n    for(int i = 2; i <= n; i++) {\n\tif(!is_prime[i]) prime[++cnt] = i;\n\tfor(int j = 1; j <= cnt && i * prime[j] <= n; j++) {\n\t    is_prime[i * prime[j]] = 1;\n\t    if((i % prime[j]) == 0) break;\n\t}\n    }\n}\nbool dfs(int x) {\n    for(int i = 0; i < to[x].size(); i++) {\n\tint v = to[x][i];\n\tif(!vis1[v]) {\n\t    vis1[v] = 1;\n\t    if(vis2[v] == -1 || dfs(vis2[v])) {\n\t\tvis2[x] = v;\n\t\tvis2[v] = x;\n\t\treturn true;\n\t    }\n\t}\n    }\n    return false;\n}\nint bi() {\n    int ans = 0;\n    memset(vis2, -1, sizeof(vis1));\n    for(int i = 1; i <= cnt1; i++) {\n\tif(vis2[i] == -1) {\n\t    memset(vis1, 0, sizeof(vis1));\n\t    if(dfs(i)) ans++;\n\t}\n    }\n    return ans;\n}\nint solve() {\n    shake(m + 1);\n    build_graph();\n    return bi(); \n}\nint main() {\n#ifdef orz\n    freopen(\"input\", \"r\", stdin);\n#endif\n    pre();\n    int k = solve();\n    printf(\"%d\\n\", k + 2 * ((cnt1-k) / 2 + (cnt2-k) / 2) + 3 * ((cnt1-k) % 2));\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntemplate< typename T = int >\nT Hungarian(vector< vector< T > > &A)\n{\n  const T infty = numeric_limits< T >::max();\n  const int N = (int) A.size() - 1;\n  const int M = (int) A[0].size() - 1;\n  vector< int > P(M + 1), way(M + 1);\n  vector< T > U(N + 1, 0), V(M + 1, 0), minV;\n  vector< bool > used;\n\n  for(int i = 1; i <= N; i++) {\n    P[0] = i;\n    minV.assign(M + 1, infty);\n    used.assign(M + 1, false);\n    int j0 = 0;\n    while(P[j0] != 0) {\n      int i0 = P[j0], j1 = 0;\n      used[j0] = true;\n      T delta = infty;\n      for(int j = 1; j <= M; j++) {\n        if(used[j]) continue;\n        T curr = A[i0][j] - U[i0] - V[j];\n        if(curr < minV[j]) minV[j] = curr, way[j] = j0;\n        if(minV[j] < delta) delta = minV[j], j1 = j;\n      }\n      for(int j = 0; j <= M; j++) {\n        if(used[j]) U[P[j]] += delta, V[j] -= delta;\n        else minV[j] -= delta;\n      }\n      j0 = j1;\n    }\n    do {\n      P[j0] = P[way[j0]];\n      j0 = way[j0];\n    } while(j0 != 0);\n  }\n  return (-V[0]);\n}\n\nconst int LIM = (int) 1e7;\nbool prime[LIM + 1];\n\nint main()\n{\n  prime[0] = prime[1] = true;\n  for(int i = 2; i * i <= LIM; i++) {\n    if(!prime[i]) {\n      for(int j = i + i; j <= LIM; j += i) {\n        prime[j] = true;\n      }\n    }\n  }\n\n  int N;\n  cin >> N;\n  vector< int > vs;\n  for(int i = 0; i < N; i++) {\n    int x;\n    cin >> x;\n    if(vs.empty() || vs.back() + 1 != x) {\n      vs.emplace_back(x - 1);\n      vs.emplace_back(x);\n    } else {\n      ++vs.back();\n    }\n  }\n\n  vector< int > latte, malta;\n  for(auto &p : vs) {\n    if(p & 1) latte.emplace_back(p);\n    else malta.emplace_back(p);\n  }\n\n  int ret = 0;\n\n  if(!latte.empty() && !malta.empty()) {\n    int sz = max(latte.size(), malta.size());\n    vector< vector< int > > g(sz, vector< int >(sz, 0));\n    for(int i = 0; i < latte.size(); i++) {\n      for(int j = 0; j < malta.size(); j++) {\n        if(!prime[abs(latte[i] - malta[j])]) {\n          g[i][j] = -1;\n        }\n      }\n    }\n    ret = -Hungarian(g);\n  }\n\n  int beet1 = latte.size() - ret;\n  int beet2 = malta.size() - ret;\n  ret += beet1 / 2 * 2;\n  ret += beet2 / 2 * 2;\n  ret += beet1 % 2 * 3;\n  cout << ret << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <ctime>\n#include <iostream>\n#include <sstream>\n#include <functional>\n#include <map>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <set>\n#include <list>\n#include <numeric>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll,ll> P;\nconst double PI = 3.14159265358979323846;\nconst double EPS = 1e-12;\nconst ll INF = 1LL<<29;\nconst ll mod = 1e9+7;\n#define rep(i,n) for(int (i)=0;(i)<(ll)(n);++(i))\n#define repd(i,n,d) for(ll (i)=0;(i)<(ll)(n);(i)+=(d))\n#define all(v) (v).begin(), (v).end()\n#define pb(x) push_back(x)\n#define mp(x,y) make_pair((x),(y))\n#define mset(m,v) memset((m),(v),sizeof(m))\n#define chmin(X,Y) ((X)>(Y)?X=(Y),true:false)\n#define chmax(X,Y) ((X)<(Y)?X=(Y),true:false)\n#define fst first\n#define snd second\n#define UNIQUE(x) (x).erase(unique(all(x)),(x).end())\ntemplate<class T> ostream &operator<<(ostream &os, const vector<T> &v){int n=v.size();rep(i,n)os<<v[i]<<(i==n-1?\"\":\" \");return os;}\n\nbool go(vector<vector<int> > &g, int u, vector<int> &mt, vector<bool> &vs){\n\tint n = g.size();\n\tif(u<0) return true;\n\tfor(int v = 0; v < n; v++){\n\t\tif(!g[u][v] || vs[v] || mt[v]!=-1) continue;\n\t\tvs[v] = true;\n\t\tmt[v] = u;\n\t\treturn true;\n\t}\n\tfor(int v = 0; v < n; v++){\n\t\tif(!g[u][v] || vs[v]) continue;\n\t\tvs[v] = true;\n\t\tif(go(g, mt[v], mt, vs)){\n\t\t\tmt[v] = u;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\nint bm(vector<vector<int> > &g){\n\tint n = g.size();\n\tvector<int> mt(n, -1);\n\tint res = 0;\n\tfor(int i = 0; i < n; i++){\n\t\tvector<bool> vs(n);\n\t\tif(go(g, i, mt, vs)) res++;\n\t}\n\treturn res;\n}\n\nbool isPrime3(ll x){\n\tif(x<=2) return false;\n\tfor(ll i = 2; i*i<=x; i++) if(x%i==0) return false;\n\treturn true;\n}\n\nint main(){\n\tint n;\n\tcin>>n;\n\tvector<ll> a;\n\trep(i, n){\n\t\tll x;\n\t\tcin>>x;\n\t\tif(a.empty() || a.back()!=x){\n\t\t\ta.push_back(x);\n\t\t\ta.push_back(0);\n\t\t}\n\t\ta.back() = x+1;\n\t}\n\tll m = a.size();\n\tvector<vector<int> > g(m, vector<int>(m));\n\trep(i, m){\n\t\trep(j, i){\n\t\t\tif(isPrime3(abs(a[i]-a[j]))){\n\t\t\t\tif(a[i]%2) g[i][j] = 1;\n\t\t\t\telse g[j][i] = 1;\n\t\t\t}\n\t\t}\n\t}\n\tll t = bm(g);\n\tll odd = 0;\n\trep(i, m) if(a[i]%2) odd++;\n\tll s = (odd-t)%2;\n\tll res = t + s*3 + (m/2-s-t)*2;\n\tcout<<res<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <climits>\n#include <queue>\n#include <algorithm>\n\nusing std::queue;\nusing std::min;\n\nconst int MAXX=1e7+5,MAXN=105;\nint n,cnt_x,cnt_y;\nint x_id[MAXN],y_id[MAXN];\nbool up[MAXX];\n\nstruct node{int he,iter,dis;}d[MAXN];\nstruct line{int to,nex,cap;}ed[MAXN*MAXN];\n\ninline bool is_odd_prm(int x){\n\tfor(int i=2;i*i<=x;++i){\n\t\tif(x%i==0) return false;\n\t}\n\treturn true;\n}\n\ninline void addE(int u,int v,int cap){\n\tstatic int cnt=1;\n\ted[++cnt]=(line){v,d[u].he};\n\td[u].he=cnt;\n}\n\ninline int revE(int i){return i^1;}\n\ninline bool BFS(int s,int t,int n){\n\tfor(int i=1;i<=n;++i)\n\t\td[i].dis=-1;\n\tstatic queue<int> q;\n\td[s].dis=0;\n\tq.push(s);\n\tint u;\n\twhile(q.size()){\n\t\tu=q.front();\n\t\tq.pop();\n\t\tfor(int i=d[u].he,v;i;i=ed[i].nex){\n\t\t\tif(ed[i].cap==0) continue;\n\t\t\tv=ed[i].to;\n\t\t\tif(d[v].dis==-1){\n\t\t\t\td[v].dis=d[u].dis+1;\n\t\t\t\tq.push(v);\n\t\t\t}\n\t\t}\n\t}\n\treturn d[t].dis!=-1;\n}\n\nint aug(int u,int rest,const int t){\n\tif(u==t) return rest;\n\tint ret=0;\n\tfor(int &i=d[u].iter,v,cap,flow;i;i=ed[i].nex){\n\t\tv=ed[i].to,cap=ed[i].cap;\n\t\tif(d[v].dis!=d[u].dis+1 || cap==0)\n\t\t\tcontinue;\n\t\tflow=aug(v,min(cap,rest-ret),t);\n\t\ted[i].cap-=flow,ed[revE(i)].cap+=flow;\n\t\tret+=flow;\n\t\tif(ret==rest) return ret;\n\t}\n\tif(ret==0) d[u].dis=-1;\n\treturn ret;\n}\n\ninline int Dinic(int s,int t,int n){\n\tint ret=0;\n\twhile(BFS(s,t,n)){\n\t\tfor(int i=1;i<=n;++i)\n\t\t\td[i].iter=d[i].he;\n\t\tret+=aug(s,INT_MAX,t);\n\t}\n\treturn ret;\n}\n\ninline void build(){\n\tfor(int i=1;i<=cnt_x;++i){\n\t\tfor(int j=1,v;j<=cnt_y;++j){\n\t\t\tif(is_odd_prm(abs(x_id[i]-y_id[j]))){\n\t\t\t\tv=j+cnt_x;\n\t\t\t\taddE(i,v,INT_MAX),addE(v,i,0);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=1,s=(cnt_x+cnt_y)|1;i<=cnt_x;++i)\n\t\taddE(s,i,1),addE(i,s,0);\n\tfor(int i=1,u,t=cnt_x+cnt_y+2;i<=cnt_y;++i){\n\t\tu=cnt_x+i;\n\t\taddE(u,t,1),addE(t,u,0);\n\t}\n}\n\nint main(){\n\tscanf(\"%d\",&n);\n\tint x;\n\tfor(int i=1;i<=n;++i){\n\t\tscanf(\"%d\",&x);\n\t\tup[x]=true;\n\t}\n\tfor(int i=1;i<=x+1;++i){\n\t\tif(up[i]!=up[i-1])\n\t\t\ti&1 ? x_id[++cnt_x]=i:y_id[++cnt_y]=i;\n\t}\n\tbuild();\n\tint k=Dinic((cnt_x+cnt_y)|1,cnt_x+cnt_y+2,cnt_x+cnt_y+2);\n\tprintf(\"%d\",k+((((cnt_x-k)>>1)+((cnt_y-k)>>1))<<1)+(cnt_x-k)%2*3);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define inf (1e9 + 7)\n#define mem(a, b) memset(a, b, sizeof(a))\nusing namespace std;\n\nint n, num[105], num2[205], nn = 0, ji = 0, ou = 0, lk[205], ans = 0;\nbool vis[205];\nvector<int> eg[205];\n\nbool dfs(int u)\n{\n    int lim = eg[u].size();\n    for(int i = 0;i < lim;i++)\n    {\n        int v = eg[u][i];\n        if(!vis[v])\n        {\n            vis[v] = 1;\n            if(lk[v] == -1||dfs(lk[v]))\n            {\n                lk[v] = u;\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\nbool jg(int a)\n{\n    if(a < 2)\n        return false;\n    if(a == 2)\n        return true;\n    for(int i = 2;i * i <= a;i++)\n    {\n        if(a % i == 0)\n            return false;\n    }\n    return true;\n}\n\nint main()\n{\n    mem(lk, -1);\n    scanf(\"%d\", &n);\n    for(int i = 1;i <= n;i++)\n        scanf(\"%d\", &num[i]);\n    sort(num + 1, num + 1 + n);\n    num2[++nn] = num[1];\n    for(int i = 2;i <= n;i++)\n    {\n        if(num[i] - 1 != num[i - 1])\n        {\n            num2[++nn] = num[i - 1] + 1;\n            num2[++nn] = num[i];\n        }\n    }\n    num2[++nn] = num[n] + 1;\n    for(int i = 1;i <= nn;i++)\n    {\n        if(num2[i] % 2 == 0)\n        {\n            ou++;\n            for(int j = i + 1;j <= nn;j++)\n            {\n                if(jg(num[j] - num[i]))\n                    eg[j].push_back(i);\n            }\n        }\n        else\n        {\n            ji++;\n            for(int j = i + 1;j <= nn;j++)\n            {\n                if(jg(num[j] - num[i]))\n                    eg[i].push_back(j);\n            }\n        }\n    }\n    int res = 0;\n    for(int i = 1;i <= nn;i++)\n    {\n        if(num2[i] % 2 == 0)\n            continue;\n        mem(vis, 0);\n        if(dfs(i))\n            res++;\n    }\n    ans += res;\n    ji -= res;\n    ou -= res;\n    ans += ji / 2 * 2;\n    ji %= 2;\n    ans += ou / 2 * 2;\n    ou %= 2;\n    if(ji||ou)\n        ans += 3;\n    printf(\"%d\\n\", ans);\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "/*\n*/\n\n#pragma GCC optimize(\"O3\")\n#define _CRT_SECURE_NO_WARNINGS\n#include <fstream>\n#include <iostream>\n#include <string>\n#include <complex>\n#include <math.h>\n#include <set>\n#include <vector>\n#include <map>\n#include <queue>\n#include <stdio.h>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <ctime>\n\n#include <memory.h>\n#include <assert.h>\n\n#define y0 sdkfaslhagaklsldk\n\n#define y1 aasdfasdfasdf\n#define yn askfhwqriuperikldjk\n#define j1 assdgsdgasghsf\n#define tm sdfjahlfasfh\n#define lr asgasgash\n#define norm asdfasdgasdgsd\n#define have adsgagshdshfhds\n#define ends asdgahhfdsfshdshfd\n\n#define eps 1e-11\n#define M_PI 3.141592653589793\n#define bsize 512\n\n#define ldouble long double\nusing namespace std;\n\n#define bs 1000000007\nconst int N = 11000031;\n\nint pr[N];\n\nint ans[231][231];\nint n;\nint ar[N];\n\nvector<int> magic;\n\nint count_moves(int val)\n{\n\tif (val==0)\n\t\treturn 0;\n\tif (val==1||val==2||val==4)\n\t\treturn 15000000;\n\tif (pr[val]==0)\n\t\treturn 1;\n\tif (val%2==0)\n\t\treturn 2;\n\treturn 3;\n}\n\nint main(){\n\t//freopen(\"tree.in\",\"r\",stdin);\n\t//freopen(\"tree.out\",\"w\",stdout);\n\t//freopen(\"input.txt\", \"r\", stdin);\n\t//freopen(\"out.txt\", \"w\", stdout);\n\tios_base::sync_with_stdio(0);\n\t//cin.tie(0);\n\n\tpr[1]=1;\n\tfor (int i=2;i*i<N;i++)\n\t{\n\t\tif (pr[i]==0)\n\t\t{\n\t\t\tfor (int j=i*i;j<N;j+=i)\n\t\t\t\tpr[j]=1;\n\t\t}\n\t}\n\n\tfor (int i=3;i<200;i++)\n\t{\n\t\tif (magic.size()>20)\n\t\t\tbreak;\n\t\tif (pr[i]==0)\n\t\t\tmagic.push_back(i);\n\t}\n\tcin>>n;\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tcin>>ar[i];\n\t}\n\n\tfor (int r=1;r<=n;r++)\n\t{\n\t\tfor (int l=r;l>=1;--l)\n\t\t{\n\t\t\tans[l][r]=1e9;\n\t\t\tfor (int cut=l;cut<r;cut++)\n\t\t\t{\n\t\t\t\tans[l][r]=min(ans[l][r],ans[l][cut]+ans[cut+1][r]);\n\t\t\t}\n\t\t\tint cover_holes=0;\n\t\t\tfor (int j=l;j<r;j++)\n\t\t\t{\n\t\t\t\tint here=ar[j+1]-ar[j]-1;\n\t\t\t\tcover_holes+=count_moves(here);\n\t\t\t}\n\n\t\t\tif (cover_holes>10000000)\n\t\t\t\tcontinue;\n\t\t\tint span=ar[r]-ar[l]+1;\n\t\t\tint safe_l=ar[l]-1;\n\t\t\tint safe_r=1e9;\n\t\t\tif (r<n)\n\t\t\t\tsafe_r=ar[r+1]-ar[r]-1;\n\t\t\tif (cover_holes>=ans[l][r])\n\t\t\t\tcontinue;\n\t\t\t// 0\n\t\t\t//cout<<l<<\" \"<<r<<\" \"<<cover_holes<<endl;\n\n\t\t\tif (pr[span]==0&&span!=2)\n\t\t\t\tans[l][r]=min(ans[l][r],cover_holes+1);\n\t\t\tfor (int q=0;q<magic.size()&&magic[q]<=max(safe_l,safe_r);q++)\n\t\t\t{\n\t\t\t\tif (pr[span+magic[q]]==0)\n\t\t\t\t\tans[l][r]=min(ans[l][r],cover_holes+2);\n\t\t\t\tfor (int w=0;w<magic.size()&&magic[w]<=min(safe_l,safe_r);w++)\n\t\t\t\t{\n\t\t\t\t\tif (pr[span+magic[q]+magic[w]]==0)\n\t\t\t\t\t\tans[l][r]=min(ans[l][r],cover_holes+3);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tcout<<ans[1][n]<<endl;\n\n\tcin.get(); cin.get();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long long ll;\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,a) FOR(i,0,a)\n\t\nusing namespace std;\nconst int MAX_N=100,MAX_X=1e7;\nint N;\nint sto[2][MAX_N*2],ston[2];\nvector<int> G[MAX_N*2];\nbool used[MAX_N*2];\nint pa[MAX_N*2];\nbool isp[MAX_X+1];\nbool dfs(int v){\n\tused[v]=true;\n\tfor(auto e:G[v]){\n\t\tif (pa[e]==-1 || (!used[pa[e]] && dfs(pa[e]))){\n\t\t\tpa[v]=e;\n\t\t\tpa[e]=v;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\nint matching(){\n\tint ret=0;\n\tmemset(pa,-1,sizeof(pa));\n\tREP(v,ston[0]){\n\t\tfill(used,used+ston[0]+ston[1],false);\n\t\tif (dfs(v)){\n\t\t\tret++;\n\t\t}\n\t}\n\treturn ret;\n}\nint main(){\n\tcin>>N;\n\t{\n\t\tvector<bool> a((int)1e7+2),b((int)1e7+1);\n\t\tREP(i,N){\n\t\t\tint x;\n\t\t\tcin>>x;\n\t\t\ta[x]=1;\n\t\t}\n\t\tREP(i,(int)1e7+1){\n\t\t\tb[i]=a[i]^a[i+1];\n\t\t}\n\t\tREP(i,(int)1e7+1){\n\t\t\tif (b[i]){\n\t\t\t\tif (i&1){\n\t\t\t\t\tsto[1][ston[1]]=i;\n\t\t\t\t\tston[1]++;\n\t\t\t\t}else{\n\t\t\t\t\tsto[0][ston[0]]=i;\n\t\t\t\t\tston[0]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tmemset(isp,1,sizeof(isp));\n\tisp[0]=isp[1]=false;\n\tFOR(i,2,MAX_X+1){\n\t\tif (isp[i]){\n\t\t\tfor(int j=i*2;j<=MAX_X;j+=i){\n\t\t\t\tisp[j]=false;\n\t\t\t}\n\t\t}\n\t}\n\tREP(i,ston[0]){\n\t\tREP(j,ston[1]){\n\t\t\tint n=abs(sto[0][i]-sto[1][j]);\n\t\t\tif (n%2 && isp[n]){\n\t\t\t\tG[i].push_back(j);\n\t\t\t\tG[j].push_back(i);\n\t\t\t}\n\t\t}\n\t}\n\tint mat=matching();\n\tint ans=mat+(ston[0]-mat)/2*2+(ston[1]-mat)/2*2;\n\tif ((ston[0]-mat)%2){\n\t\tans+=3;\n\t}\n\tcout<<ans<<endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <climits>\n#include <queue>\n#include <algorithm>\n\nusing std::queue;\nusing std::min;\n\nconst int MAXX=1e7+5,MAXN=105;\nint n,cnt_x,cnt_y;\nint x_id[MAXN],y_id[MAXN];\nbool up[MAXX];\n\nstruct node{int he,iter,dis;}d[MAXN];\nstruct line{int to,nex,cap;}ed[MAXN*MAXN];\n\ninline bool is_odd_prm(int x){\n\tfor(int i=2;i*i<=x;++i){\n\t\tif(x%i==0) return false;\n\t}\n\treturn true;\n}\n\ninline void addE(int u,int v,int cap){\n\tstatic int cnt=1;\n\ted[++cnt]=(line){v,d[u].he,cap};\n\td[u].he=cnt;\n}\n\ninline int revE(int i){return i^1;}\n\ninline bool BFS(int s,int t,int n){\n\tfor(int i=1;i<=n;++i)\n\t\td[i].dis=-1;\n\tstatic queue<int> q;\n\td[s].dis=0;\n\tq.push(s);\n\tint u;\n\twhile(q.size()){\n\t\tu=q.front();\n\t\tq.pop();\n\t\tfor(int i=d[u].he,v;i;i=ed[i].nex){\n\t\t\tif(ed[i].cap==0) continue;\n\t\t\tv=ed[i].to;\n\t\t\tif(d[v].dis==-1){\n\t\t\t\td[v].dis=d[u].dis+1;\n\t\t\t\tq.push(v);\n\t\t\t}\n\t\t}\n\t}\n\treturn d[t].dis!=-1;\n}\n\nint aug(int u,int rest,const int t){\n\tif(u==t) return rest;\n\tint ret=0;\n\tfor(int &i=d[u].iter,v,cap,flow;i;i=ed[i].nex){\n\t\tv=ed[i].to,cap=ed[i].cap;\n\t\tif(d[v].dis!=d[u].dis+1 || cap==0)\n\t\t\tcontinue;\n\t\tflow=aug(v,min(cap,rest-ret),t);\n\t\ted[i].cap-=flow,ed[revE(i)].cap+=flow;\n\t\tret+=flow;\n\t\tif(ret==rest) return ret;\n\t}\n\tif(ret==0) d[u].dis=-1;\n\treturn ret;\n}\n\ninline int Dinic(int s,int t,int n){\n\tint ret=0;\n\twhile(BFS(s,t,n)){\n\t\tfor(int i=1;i<=n;++i)\n\t\t\td[i].iter=d[i].he;\n\t\tret+=aug(s,INT_MAX,t);\n\t}\n\treturn ret;\n}\n\ninline void build(){\n\tfor(int i=1;i<=cnt_x;++i){\n\t\tfor(int j=1,v;j<=cnt_y;++j){\n\t\t\tif(is_odd_prm(abs(x_id[i]-y_id[j]))){\n\t\t\t\tv=j+cnt_x;\n\t\t\t\taddE(i,v,INT_MAX),addE(v,i,0);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=1,s=(cnt_x+cnt_y)|1;i<=cnt_x;++i)\n\t\taddE(s,i,1),addE(i,s,0);\n\tfor(int i=1,u,t=cnt_x+cnt_y+2;i<=cnt_y;++i){\n\t\tu=cnt_x+i;\n\t\taddE(u,t,1),addE(t,u,0);\n\t}\n}\n\nint main(){\n\tscanf(\"%d\",&n);\n\tint x;\n\tfor(int i=1;i<=n;++i){\n\t\tscanf(\"%d\",&x);\n\t\tup[x]=true;\n\t}\n\tfor(int i=1;i<=x+1;++i){\n\t\tif(up[i]!=up[i-1])\n\t\t\ti&1 ? x_id[++cnt_x]=i:y_id[++cnt_y]=i;\n\t}\n\tbuild();\n\tint k=Dinic((cnt_x+cnt_y)|1,cnt_x+cnt_y+2,cnt_x+cnt_y+2);\n\tprintf(\"%d\",k+((((cnt_x-k)>>1)+((cnt_y-k)>>1))<<1)+(cnt_x-k)%2*3);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fi first\n#define se second\n#define pb push_back\n#define SZ(x) ((int)x.size())\n#define L(i,u) for (register int i=head[u]; i; i=nxt[i])\n#define rep(i,a,b) for (register int i=(a); i<=(b); i++)\n#define per(i,a,b) for (register int i=(a); i>=(b); i--)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int ui;\ntypedef pair<int,int> Pii;\ntypedef vector<int> Vi;\ninline void read(int &x) {\n\tx=0; char c=getchar(); int f=1;\n\twhile (!isdigit(c)) {if (c=='-') f=-1; c=getchar();}\n\twhile (isdigit(c)) {x=x*10+c-'0'; c=getchar();} x*=f;\n}\ninline ui R() {\n\tstatic ui seed=416;\n\treturn seed^=seed>>5,seed^=seed<<17,seed^=seed>>13;\n}\nconst int N = 2220, M = 2040030, inf = 0x3f3f3f3f;\nint S,T,head[N],cur[N],nxt[M],cap[M],to[M],edgenum=1; //1.WA£¨ÆäËüµØ·½Ó¦¸Ã¶¼²»ÈÝÒ×Ð´¹Ò£©--edgenum=1!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\nvoid addedge(int u, int v, int c){\n\tto[++edgenum]=v;cap[edgenum]=c;nxt[edgenum]=head[u];head[u]=edgenum;\n}\nvoid add(int u, int v, int c){\n\taddedge(u,v,c);addedge(v,u,0);\n}\nint dis[N],q[N];\ninline bool bfs() {\n\tmemset(dis,inf,4*(T+2));//2.memset²»ÓÃsizeof()\n\tint f=0,r=1; q[f]=T; dis[T]=0;\n\twhile (f!=r) {\n\t\tint u=q[f++];\n\t\tL(i,u) if (cap[i^1]&&dis[to[i]]==inf){\n\t\t\tq[r++]=to[i];dis[to[i]]=dis[u]+1;if(to[i]==S)return 1;//3.¼ôÖ¦\n\t\t}\n\t}\n\treturn dis[S]<inf;\n}\ninline int dfs(int u, int flow) {\n\tif (u==T||!flow)return flow;int res=0;\n\tfor(register int &i=cur[u];i;i=nxt[i])if(cap[i]&&dis[u]==dis[to[i]]+1){//4.µ±Ç°»¡ \n\t\tint tmp=dfs(to[i],min(flow,cap[i]));\n\t\tres+=tmp;flow-=tmp;cap[i]-=tmp;cap[i^1]+=tmp;if(!flow)break;\n\t}\n\treturn res;\n}\ninline int dinic() {\n\tint res=0;\n\twhile (bfs()) {\n\t\tmemcpy(cur,head,4*(T+2)); res+=dfs(S,inf);\n\t}\n\treturn res;\n}\nset<int>Set;\nVi a,b;int n;\nint prime[10020000],len,mrk[10020000];\nint Abs(int x){return x>0?x:-x;}\nvoid getp(int n){\n\trep(i,2,n){\n\t\tif(!mrk[i])prime[++len]=i;\n\t\trep(j,1,len){\n\t\t\tif(i*prime[j]>n)break;\n\t\t\tmrk[i*prime[j]]=prime[j];\n\t\t\tif(i%prime[j]==0)break;\n\t\t}\n\t}\n\tmrk[1]=1;\n}\nint main() {\n\tgetp(1e7);read(n);rep(i,1,n){\n\t\tint x;read(x);\n\t\tif(!Set.count(x))Set.insert(x);else Set.erase(x);\n\t\tx++;\n\t\tif(!Set.count(x))Set.insert(x);else Set.erase(x);\n\t}\n\twhile(!Set.empty()){\n\t\tint x=*Set.begin();Set.erase(x);\n\t\tif(x&1)a.pb(x);else b.pb(x);\n\t}\n\tS=SZ(a)+SZ(b)+3;T=S+1;\n\trep(i,0,SZ(a)-1)add(S,i+1,1);\n\trep(i,0,SZ(b)-1)add(SZ(a)+i+1,T,1);\n\trep(i,0,SZ(a)-1)rep(j,0,SZ(b)-1)if(!mrk[Abs(a[i]-b[j])])\n\t\tadd(i+1,SZ(a)+j+1,1);\n\tint res=dinic();\n//\tcerr<<SZ(a)<<' '<<SZ(b)<<' '<<res<<endl;\n\tif(SZ(a)-res&1)cout<<res+SZ(a)-res+SZ(b)-res+1;\n\telse cout<<res+SZ(a)-res+SZ(b)-res;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long ll;\ntypedef std::pair<ll,int> pr;\nconst int maxn = 200100;\nstruct T {\n    int to, nxt, v;\n} way[maxn << 4];\nint h[maxn], head[maxn], num = 1;\ninline void adde(int x,int y,int v) {\n    way[++num] = {y, h[x], v}, h[x] = num;\n    way[++num] = {x, h[y], 0}, h[y] = num;\n}\nint dis[maxn];\ninline bool bfs(int s,int t) {\n    std::queue<int> q;\n    for(int i = s;i <= t;++i) dis[i] = - 1, head[i] = h[i];\n    for(q.push(s), dis[s] = 0;!q.empty();) {\n        int t = q.front(); q.pop();\n        for(int i = h[t];i;i = way[i].nxt) if(way[i].v && dis[way[i].to] < 0) \n            dis[way[i].to] = dis[t] + 1, q.push(way[i].to);\n    }\n    return dis[t] >= 0;\n}\ninline int dfs(int s,int t,int lim) {\n    if(s == t || !lim) return lim;\n    int ans = 0, mn;\n    for(int & i = head[s];i;i = way[i].nxt)\n        if(dis[way[i].to] == dis[s] + 1 && (mn = dfs(way[i].to, t, std::min(lim, way[i].v)))) {\n            way[i].v -= mn;\n            way[i ^ 1].v += mn;\n            ans += mn; lim -= mn;\n            if(!lim) break;\n        }\n    return ans;\n}\ninline int dinic(int s,int t) {\n    int ans = 0;\n    for(;bfs(s,t);) ans += dfs(s,t,1e9);\n    return ans;\n}\nint a[(int) 1e7 + 100];\nstd::vector<int> v;\ninline bool chk(int x) {\n\tif(x == 1) return 0;\n\tfor(int i = 2;i * i <= x;++i) {\n\t\tif(x % i == 0) return 0;\n\t}\n\treturn 1;\n}\nint main(){\n    std::ios::sync_with_stdio(false),std::cin.tie(0);\n    int n;\n    std::cin >> n;\n    for(int i = 0, x;i < n;++i) {\n    \tstd::cin >> x, a[x] ^= 1;\n\t}\n\tfor(int i = 1;i <= 1e7 + 1;++i) {\n\t\tif(a[i] ^ a[i - 1]) {\n\t\t\tv.push_back(i);\n\t\t}\n\t}\n\tfor(int i = 0;i < v.size();++i) if(v[i] & 1) for(int j = 0;j < v.size();++j) if(v[j] % 2 == 0 && chk(std::abs(v[i] - v[j]))) {\n\t\tadde(i + 1, j + 1, 1);\n\t}\n\tint odd = 0, even = 0;\n\tfor(int i = 0;i < v.size();++i) if(v[i] & 1) adde(0, i + 1, 1), ++ odd;\n\telse adde(i + 1, v.size() + 1, 1), ++ even;\n\tint fl = dinic(0, v.size() + 1), ans = 0;\n\tans += fl, odd -= fl, even -= fl;\n\tans += odd / 2 * 2;\n\tans += even / 2 * 2;\n\tans += odd % 2 * 3;\n\tstd::cout << ans << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,int> PI;\n\nconst int mod = 1e9 + 7;\nconst int maxn = 1e7 + 5;\nbool flag[maxn];\nint pri[maxn];\nint cnt = 0;\n\nvoid GetPrime() {\n    for (int i = 2; i < maxn; ++i) {\n        if (!flag[i]) pri[cnt++] = i;\n        for (int j = 0; j < cnt && pri[j] * i < maxn; ++j) {\n            flag[pri[j] * i] = 1;\n            if (i % pri[j] == 0) break;\n        }\n    }\n}\n\nint d[105];\nint f[105];\n\nint main() {\n    GetPrime();\n    int n,i,j,k;\n    scanf(\"%d\",&n);\n    for(i = 0; i < n; i++) scanf(\"%d\",&d[i]);\n    memset(f,0x3f,sizeof(f));\n    f[0] = 0;\n    for(i = 0;i < n; i++) {\n        f[i + 1] = min(f[i + 1],f[i] + 3);\n        for(j = i + 2;j <= n; j++) {\n            int u = 0;\n            for(k = i + 1;k < j; k++) {\n                int x = d[k] - d[k - 1] - 1;\n                if(x == 0) continue;\n                if(!flag[x] && x != 2) u++;\n                else u += 2 + (x & 1);\n            }\n            int x = d[j - 1] - d[i] + 1;\n            if(!flag[x] && x != 2) u++;\n            else u += 2 + (x & 1);\n            //cout<<j<<\" -- \"<<f[i] + u<<\" - \"<<u<<endl;\n            f[j] = min(f[j],f[i] + u);\n        }\n    }\n    printf(\"%d\\n\",f[n]);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nnamespace Dinic{\n\t#define N 205\n\t#define M 80005\n\t#define INF 0x3f3f3f3f\n\tstruct edge{\n\t\tint flow,t,next;\n\t}e[M];int ecnt,head[N];\n\tvoid addedge(int f,int t,int fl){\n\t\te[++ecnt]=(edge){fl,t,head[f]};head[f]=ecnt;\n\t\te[++ecnt]=(edge){0,f,head[t]};head[t]=ecnt;\n\t}\n\t//----------------\n\tint S,T;\n\tint dis[N],cur[N];\n\tbool BFS(){\n\t\tmemset(dis,0x3f,sizeof(dis));\n\t\tdis[S]=0;queue<int> que;que.push(S);\n\t\twhile(!que.empty()){\n\t\t\tint u=que.front();que.pop();\n\t\t\tfor(int i=head[u];i;i=e[i].next){\n\t\t\t\tif(e[i].flow!=0&&dis[e[i].t]==0x3f3f3f3f){\n\t\t\t\t\tdis[e[i].t]=dis[u]+1,que.push(e[i].t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn dis[T]!=INF;\n\t}\n\t\n\tint DFS(int u,int a){\n\t\tif(u==T||a==0) return a;\n\t\tint ret=0;\n\t\tfor(int &i=cur[u];i;i=e[i].next){\n\t\t\tif(e[i].flow==0||dis[e[i].t]!=dis[u]+1) continue;\n\t\t\tint f=DFS(e[i].t,a<e[i].flow? a:e[i].flow);\n\t\t\tif(f){\n\t\t\t\te[i].flow-=f;e[i^1].flow+=f;\n\t\t\t\tret+=f;a-=f;\n\t\t\t\tif(a==0) return ret;\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\tint work(int S1,int T1){\n\t\tS=S1,T=T1;\n\t\tint ret=0;\n\t\twhile(BFS()){\n\t\t\tmemcpy(cur,head,sizeof(cur));\n\t\t\tret+=DFS(S1,INF);\n\t\t}\n\t\treturn ret;\n\t}\n\tvoid initialize(){\n\t\tecnt=1;memset(head,0,sizeof(head));\n\t}\n\t#undef N\n\t#undef M\n\t#undef INF\n}\n\n#define N 205\n#define M 10000007\n\nint n;\nint pos[N],pcnt;\nint dp[N][N];\nbool p[M];\nint main(){\n    scanf(\"%d\",&n);\n    for(int i=1,t;i<=n;i++){\n        scanf(\"%d\",&t);\n        if(pcnt>0&&pos[pcnt]==t) pos[pcnt]=t+1;\n        else pos[++pcnt]=t,pos[++pcnt]=t+1;\n    }\n    for(int i=2;i<M;i++){\n        p[i]=!p[i];\n        if(p[i])\n           for(int j=i+i;j<M;j+=i) p[j]=true;\n    }\n    int nodd=0,neven=0;\n    for(int i=1;i<=pcnt;i++)\n        pos[i]%2==0? neven++:nodd++;\n    \n    Dinic::initialize();\n    for(int i=1;i<=pcnt;i++)    \n        for(int j=1;j<=pcnt;j++)\n            if(pos[i]%2==0 && pos[j]%2==1 && p[abs(pos[i]-pos[j])])\n                Dinic::addedge(i,j,1);\n    int S=pcnt+1,T=S+1;\n    for(int i=1;i<=pcnt;i++)\n        if(pos[i]%2==0) Dinic::addedge(S,i,1);\n        else Dinic::addedge(i,T,1);\n    \n    int ans=Dinic::work(S,T);\n    cout<<ans+(nodd-ans)/2*2+(neven-ans)/2*2+(nodd-ans)%2*3;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<algorithm>\n#include<cstdio>\n#include<cstring>\n#include<iostream>\nusing namespace std;\nconst int N=1e7+5;\nint n,x,ans,t[N+5],p[1000005],b[205][205],d1[205],d2[205],s[205];\nbool bz[N+5],v[205];\nbool dg(int x)\n{\n\tfor (int i=1;i<=d2[0];i++)\n\tif (b[x][i] && !v[i])\n\t{\n\t\tv[i]=1;\n\t\tif (!s[i] || dg(s[i]))\n\t\t{\n\t\t\ts[i]=x;\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<=n;i++) scanf(\"%d\",&x),bz[x]=1;\n\tfor (int i=1;i<=N;i++) \n\tif (bz[i]^bz[i-1]) \n\t{\n\t\tif (i&1) d1[++d1[0]]=i; \n\t\t\telse d2[++d2[0]]=i;\n\t}\n\tmemset(bz,0,sizeof(bz));\n\tbz[1]=1;\n\tfor (int i=2;i<=N;i++)\n\t{\n\t\tif (!bz[i]) p[++p[0]]=i;\n\t\tfor (int j=1;j<=p[0] && i*p[j]<=N;j++)\n\t\t{\n\t\t\tbz[i*p[j]]=1;\n\t\t\tif (i%p[j]==0) break;\n\t\t}\n\t}\n\tbz[2]=1;\n\tfor (int i=1;i<=d1[0];i++)\n\t\tfor (int j=1;j<=d2[0];j++)\n\t\tif (!bz[abs(d1[i]-d2[j])]) b[i][j]=1;\n\tfor (int i=1;i<=d1[0];i++)\n\t{\n\t\tmemset(v,0,sizeof(v));\n\t\tif (dg(i)) ans++;\n\t}\n\td1[0]-=ans,d2[0]-=ans;\n\tans+=d1[0]/2*2+d2[0]/2*2+d1[0]%2*3;\n\tprintf(\"%d\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int inf=0x3f3f3f3f;\nint read()\n{\n\tint r=0,f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9')r=(r<<1)+(r<<3)+ch-'0',ch=getchar();\n\treturn r*f;\n}\nbool np[10000100];\nint pri[5000500],tot;\nvoid Euler()\n{\n\tnp[1]=1;int ma=1e7;\n\tfor(int i=2;i<=ma;++i)\n\t{\n\t\tif(!np[i])pri[++tot]=i;\n\t\tfor(int j=1;j<=tot&&i*pri[j]<=ma;++j)\n\t\t{\n\t\t\tnp[i*pri[j]]=1;\n\t\t\tif(i%pri[j]==0)break;\n\t\t}\n\t}\n}\nint n;\nbool po[10000100];\nint pos[550];\nstruct data{\n\tint to,nxt,c;\n}mp[200200];\nint head[550],cnt=1;\nint s,t;\nint cur[550];\nvoid link(int x,int y,int c)\n{\n\tmp[++cnt].to=y;\n\tmp[cnt].nxt=head[x];\n\tmp[cnt].c=c;\n\thead[x]=cnt;\n}\nvoid add(int x,int y,int c){link(x,y,c);link(y,x,0);}\nint dis[550];\nqueue<int>q;\nbool bfs()\n{\n\tfor(int i=1;i<=t;++i)dis[i]=0;\n\tdis[s]=1;q.push(s);\n\tint u;\n\twhile(!q.empty())\n\t{\n\t\tu=q.front();q.pop();\n\t\tfor(int i=head[u];i;i=mp[i].nxt)\n\t\t\tif(!dis[mp[i].to]&&mp[i].c)\n\t\t\t\tdis[mp[i].to]=dis[u]+1,q.push(mp[i].to);\n\t}\n\treturn dis[t];\n}\nint dfs(int x,int f)\n{\n\tif(x==t)return f;\n\tint fl,rf=0;\n\tfor(int& i=cur[x];i;i=mp[i].nxt)\n\t\tif(dis[mp[i].to]==dis[x]+1&&mp[i].c)\n\t\t{\n\t\t\tfl=dfs(mp[i].to,min(f,mp[i].c));\n\t\t\tif(fl)\n\t\t\t{\n\t\t\t\tf-=fl;rf+=fl;\n\t\t\t\tmp[i].c-=fl;\n\t\t\t\tmp[i^1].c+=fl;\n\t\t\t\tif(!f)break;\n\t\t\t}\n\t\t}\n\treturn rf;\n}\nint Dinic()\n{\n\tint maxflow=0,flow;\n\twhile(bfs())\n\t{\n\t\tfor(int i=1;i<=t;++i)cur[i]=head[i];\n\t\twhile(flow=dfs(s,inf))maxflow+=flow;\n\t}\n\treturn maxflow;\n}\nint main()\n{\n\tEuler();\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;++i)po[read()]=1;\n\tn=0;\n\tfor(int i=1;i<=1e7+1;++i)\n\t\tif(po[i]!=po[i-1]) pos[++n]=i;\n\ts=n+1,t=n+2;\n\tint odd=0,even=0;\n\tfor(int i=1;i<=n;++i)\n\t\tif(pos[i]&1)\n\t\t{\n\t\t\tadd(s,i,1);\n\t\t\todd++;\n\t\t\tfor(int j=1;j<=n;++j)\n\t\t\t\tif((!(pos[j]&1))&&(!np[abs(pos[i]-pos[j])]))\n\t\t\t\t\tadd(i,j,1);\n\t\t}\n\tfor(int i=1;i<=n;++i)\n\t\tif(!(pos[i]&1))add(i,t,1),even++;\n\tint ans=Dinic();\n\teven-=ans;odd-=ans;\n\tif((even&1)||(odd&1))ans+=3;\n\teven-=even&1;odd-=odd&1;\n\tans+=even+odd;\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=210,M=1e7+10;\nint n,m,x[N],y[N],dp[N][N],prime[M],cnt;bool isp[M];\nvoid init(){\n\tisp[0]=isp[1]=1;\n\tfor (int i=2;i<M;i++){\n\t\tif (!isp[i]) prime[++cnt]=i;\n\t\tfor (int j=1;j<=cnt&&i*prime[j]<M;j++){\n\t\t\tisp[i*prime[j]]=1;\n\t\t\tif (i%prime[j]==0) break;\n\t\t}\n\t}\n\tisp[2]=1;\n}\n//一般图最大带权匹配......\nbool go[N][N];\nint vis[N],match[N],C;\nbool find(int x){\n    for (int i=1;i<=m;i++)\n    if (go[x][i]&&vis[i]!=C){\n        vis[i]=C;\n        if (!match[i]||find(match[i])){\n            match[x]=i;\n            match[i]=x;\n            return 1;\n        }\n    }\n    return 0;\n}\nint main()\n{\n\tinit();\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<=n;i++) scanf(\"%d\",&x[i]);\n\tint last=y[++m]=x[1];\n\tfor (int i=1;i<=n;i++)\n    if (x[i]!=last) y[++m]=last,y[++m]=x[i],last=x[i]+1;else last++;\n    y[++m]=last;\n    for (int i=1;i<=m;i++)\n    for (int j=1;j<=m;j++)\n    if (!isp[abs(y[i]-y[j])]) go[i][j]=go[j][i]=1;\n    int ans=0,odd=0,even=0;\n    for (int i=1;i<=m;i++)\n    if ((y[i]&1)&&!match[i]) C++,ans+=find(i);\n    for (int i=1;i<=m;i++)\n    if (!match[i]) y[i]&1?odd++:even++;\n    ans+=odd/2*2;\n    ans+=even/2*2;\n    if (odd&1) ans+=3;\n    printf(\"%d\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MAXN\t105\n#define MAXP\t405\n#define MAXQ\t1000005\n#define MAXV\t10000005\n#define INF\t1e9\ntemplate <typename T> void read(T &x) {\n\tx = 0; int f = 1;\n\tchar c = getchar();\n\tfor (; !isdigit(c); c = getchar()) if (c == '-') f = -f;\n\tfor (; isdigit(c); c = getchar()) x = x * 10 + c - '0';\n\tx *= f;\n}\nstruct edge {int dest, flow; unsigned home; };\nvector <edge> a[MAXP];\nunsigned curr[MAXP];\nint s, t, dist[MAXP];\nint odd, vodd[MAXN], even, veven[MAXN];\nint tot, f[MAXV], prime[MAXV];\nbool isprime[MAXV], mark[MAXV];\nvoid addedge(int x, int y, int z) {\n\ta[x].push_back((edge) {y, z, a[y].size()});\n\ta[y].push_back((edge) {x, 0, a[x].size() - 1});\n}\nbool bfs() {\n\tstatic int q[MAXP];\n\tmemset(dist, 0, sizeof(dist));\n\tint l = 0, r = 0;\n\tq[0] = s; dist[s] = 1;\n\twhile (l <= r) {\n\t\tint now = q[l];\n\t\tfor (unsigned i = 0; i < a[now].size(); i++)\n\t\t\tif (dist[a[now][i].dest] == 0 && a[now][i].flow != 0) {\n\t\t\t\tdist[a[now][i].dest] = dist[now] + 1;\n\t\t\t\tq[++r] = a[now][i].dest;\n\t\t\t}\n\t\tl++;\n\t}\n\treturn dist[t] != 0;\n}\nint dinic(int pos, int limit) {\n\tif (pos == t) return limit;\n\tint used = 0, tmp;\n\tfor (unsigned &i = curr[pos]; i < a[pos].size(); i++)\n\t\tif (dist[a[pos][i].dest] == dist[pos] + 1 && a[pos][i].flow && (tmp = dinic(a[pos][i].dest, min(limit - used, a[pos][i].flow)))) {\n\t\t\tused += tmp;\n\t\t\ta[pos][i].flow -= tmp;\n\t\t\ta[a[pos][i].dest][a[pos][i].home].flow += tmp;\n\t\t\tif (used == limit) return used;\n\t\t}\n\treturn used;\n}\nint main() {\n\tint n; read(n);\n\tfor (int i = 1; i <= n; i++) {\n\t\tint x; read(x);\n\t\tmark[x] ^= true;\n\t\tmark[x + 1] ^= true;\n\t}\n\tfor (int i = 1; i < MAXV; i++)\n\t\tif (mark[i]) {\n\t\t\tif (i & 1) vodd[++odd] = i;\n\t\t\telse veven[++even] = i;\n\t\t}\n\tfor (int i = 2; i < MAXV; i++) {\n\t\tif (f[i] == 0) {\n\t\t\tf[i] = i;\n\t\t\tprime[++tot] = i;\n\t\t\tisprime[i] = true;\n\t\t}\n\t\tfor (int j = 1; j <= tot && prime[j] <= f[i]; j++) {\n\t\t\tint tmp = prime[j] * i;\n\t\t\tif (tmp >= MAXV) break;\n\t\t\tf[tmp] = prime[j];\n\t\t}\n\t}\n\ts = 0, t = odd + even + 1;\n\tfor (int i = 1; i <= odd; i++)\n\t\taddedge(s, i, 1);\n\tfor (int i = 1; i <= even; i++)\n\t\taddedge(i + odd, t, 1);\n\tfor (int i = 1; i <= odd; i++)\n\tfor (int j = 1; j <= even; j++)\n\t\tif (isprime[abs(vodd[i] - veven[j])]) addedge(i, j + odd, 1);\n\tint ans = 0;\n\twhile (bfs()) {\n\t\tmemset(curr, 0, sizeof(curr));\n\t\tans += dinic(s, INF);\n\t}\n\tcout << ans + (odd - ans) / 2 * 2 + (even - ans) / 2 * 2 + (odd - ans) % 2 * 3 << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n\n#include <iostream>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <unordered_set>\n#include <queue>\n#include <set>\n#include <algorithm>\n#include <numeric>\n#include <list>\nusing namespace std;\n\nusing QWORD  = uint64_t;\nusing SQWORD = int64_t;\nusing DWORD  = uint32_t;\nusing SDWORD = int32_t;\nusing WORD   = uint16_t;\nusing SWORD  = int16_t;\nusing BYTE   = uint8_t;\nusing SBYTE  = int8_t;\nusing DOUBLE = double;\nusing FLOAT  = float;\n\n#define MIN_SDWORD (-2147483648)\n#define MAX_SDWORD (2147483647)\n#define MIN_SBYTE (-128)\n#define MAX_SBYTE (127)\n\n#define MIN_SQWORD (0x8000000000000000)\n#define MAX_SQWORD (0x7FFFFFFFFFFFFFFF)\n\n#define MAX_QWORD  (0xFFFFFFFFFFFFFFFF)\n#define MAX_DWORD  (0xFFFFFFFF)\n#define MAX_WORD   (0xFFFF)\n#define MAX_BYTE   (0xFF)\n\n#define MAX_DOUBLE      (1.0e+308)\n#define DOUBLE_EPS      (1.0e-12)\n#define MIN_DOUBLE_N    (-1.0e+308)\n\n#define ArrayLength(a)  (sizeof(a) / sizeof(a[0]))\n\nstatic inline DOUBLE MAX(DOUBLE a, DOUBLE b) { return a > b ? a : b; }\nstatic inline QWORD MAX(QWORD a, QWORD b) { return a > b ? a : b; }\nstatic inline DWORD MAX(DWORD a, DWORD b) { return a > b ? a : b; }\nstatic inline SDWORD MAX(SDWORD a, SDWORD b) { return a > b ? a : b; }\nstatic inline DOUBLE MIN(DOUBLE a, DOUBLE b) { return a < b ? a : b; }\nstatic inline QWORD MIN(QWORD a, QWORD b) { return a < b ? a : b; }\nstatic inline DWORD MIN(DWORD a, DWORD b) { return a < b ? a : b; }\nstatic inline SDWORD MIN(SDWORD a, SDWORD b) { return a < b ? a : b; }\nstatic inline DOUBLE ABS(DOUBLE a) { return 0 < a ? a : -a; };\n\n#define BYTE_BITS   (8)\n#define WORD_BITS   (16)\n#define DWORD_BITS  (32)\n#define QWORD_BITS  (64)\n\nstatic inline void inputStringSpSeparated(char *pcStr)\n{\n    char *pcCur = pcStr;\n    for (;;) {\n        char c = getchar();\n        if (('\\n' == c) || (EOF == c) || (' ' == c)) {\n            break;\n        }\n        *pcCur = c;\n        pcCur++;\n    }\n    *pcCur = '\\0';\n}\n\nstatic inline void inputString(char *pcStr)\n{\n    char *pcCur = pcStr;\n    for (;;) {\n        char c = getchar();\n        if (('\\n' == c) || (EOF == c)) {\n            break;\n        }\n        *pcCur = c;\n        pcCur++;\n    }\n    *pcCur = '\\0';\n}\n\n\nstatic inline SQWORD inputSQWORD(void)\n{\n    SQWORD sqNumber = 0;\n    SQWORD sqMultiplier = 1;\n    bool bRead = false;\n    for (;;) {\n        char c = getchar();\n        if (!bRead) {\n            if ('-' == c) {\n                sqMultiplier = -1;\n            }\n        }\n        if (('0' <= c) && (c <= '9')) {\n            sqNumber *= 10LL;\n            sqNumber += (SQWORD)(c - '0');\n            bRead = true;\n        } else {\n            if (bRead) {\n                return sqNumber * sqMultiplier;\n            }\n        }\n    }\n}\n\n\nstatic inline SDWORD inputSDWORD(void)\n{\n    SDWORD lNumber = 0;\n    SDWORD lMultiplier = 1;\n    bool bRead = false;\n    for (;;) {\n        char c = getchar();\n        if (!bRead) {\n            if ('-' == c) {\n                lMultiplier = -1;\n            }\n        }\n        if (('0' <= c) && (c <= '9')) {\n            lNumber *= 10;\n            lNumber += (c - '0');\n            bRead = true;\n        } else {\n            if (bRead) {\n                return lNumber * lMultiplier;\n            }\n        }\n    }\n}\n\nstatic inline DOUBLE inputFP(void)\n{\n    DOUBLE dInt = 0.0;\n    DOUBLE dFrac = 0.0;\n    DOUBLE dMultiplier = 1.0;\n    DWORD dwFpCnt = 0;\n    DOUBLE *pdCur = &dInt;\n    bool bRead = false;\n    for (;;) {\n        char c = getchar();\n        if (!bRead) {\n            if ('-' == c) {\n                dMultiplier = -1;\n            }\n        }\n        if ('.' == c) {\n            pdCur = &dFrac;\n        } else if (('0' <= c) && (c <= '9')) {\n            (*pdCur) *= 10;\n            (*pdCur) += (DOUBLE)(c - '0');\n            bRead = true;\n            if (pdCur == &dFrac) {\n                dwFpCnt++;\n            }\n        } else {\n            if (bRead) {\n                return dMultiplier * (dInt + dFrac / (pow((DOUBLE)10.0 , (DOUBLE)dwFpCnt)));\n            }\n        }\n    }\n}\n\n\n/**\n *  mod による操作ライブラリ\n */\n\n#define ANS_MOD (1000000007LL)\n \nstatic SQWORD addMod(SQWORD x, SQWORD y)\n{ \n    return (x + y) % ANS_MOD;\n}\n \nstatic SQWORD subMod(SQWORD x, SQWORD y)\n{\n    return (x - y + ANS_MOD) % ANS_MOD;\n}\n \nstatic SQWORD mulMod(SQWORD x, SQWORD y) \n{\n    return (x * y) % ANS_MOD;\n}\n \nstatic SQWORD powMod(SQWORD x, SQWORD e) {\n    SQWORD v = 1;\n    for (; e; x = mulMod(x, x), e >>= 1) {\n        if (e & 1) {\n            v = mulMod(v, x);\n        }\n    }\n    return v;\n}\n \nstatic SQWORD divMod(SQWORD x, SQWORD y)\n{\n    return mulMod(x, powMod(y, ANS_MOD - 2));\n}\n \n \nstatic SQWORD combMod(SQWORD n, SQWORD k)\n{\n    SQWORD v=1;\n    for(SQWORD i=1; i<=k; i++) {\n        v = divMod(mulMod(v, n-i+1),i);\n    } \n    return v;\n}\n\n/*----------------------------------------------*/\n\n#define MAX_V   (500)\n#define INF 2e9\n\n/* 辺を表す構造体 */\nstruct edge {int to, cap ,rev; };\n \n/* グラフの隣接リスト表現 */\nvector<edge> G[MAX_V];\n/* DFSですべに調べたかのグラフ */\nbool used[MAX_V];\n \n/* fromからtoへ向かう容量capの辺をグラフに追加する */\n/* 相互参照できるようにしている */\nvoid add_edge(int from, int to, int cap){\n    G[from].push_back((edge){to, cap, (int)G[to].size()});\n    G[to].push_back((edge){from, 0, (int)G[from].size() - 1});    \n}\n \n/* 増加パスをdfsで探す */\nint dfs(int v, int t, int f){\n    if(v==t) return f;\n    used[v] = true;\n    for(int i=0; i<G[v].size(); i++){\n        edge &e = G[v][i];\n        if(!used[e.to] && e.cap>0){\n            int d = dfs(e.to, t, min(f, e.cap));\n            if(d>0){\n                e.cap -= d;\n                G[e.to][e.rev].cap += d;\n                return d;\n            }\n        }\n    }\n    return 0;\n}\n \nint max_flow(int s, int t){\n    int flow = 0;\n    for(;;){\n        memset(used, 0, sizeof(used));\n        int f = dfs(s, t, INF);\n        if(f==0) return flow;\n        flow += f;\n    }\n}\n/*----------------------------------------------*/\n\nclass PrimeTable {\n    vector<bool> vbIsPrime;\n\npublic:\n    PrimeTable(SDWORD lMax) {\n        /* lSearchMax と ループ内の *2 の関係から、入力は3以上とすること */\n        if (!(1 <= lMax)) {\n            printf(\"Oops!\");\n            return;\n        }\n\n        /* 素数のリストを作る */\n        vbIsPrime.resize(lMax + 1, true);\n        SDWORD lSearchMax = sqrt(lMax) + 1;\n        vbIsPrime[0] = false;\n        vbIsPrime[1] = false;\n        for (SDWORD lPrime = 2; lPrime < lSearchMax; lPrime++) {\n            if (vbIsPrime[lPrime]) {\n                for (SDWORD lCurNum = lPrime * 2; lCurNum <= lMax; lCurNum += lPrime) {\n                    vbIsPrime[lCurNum] = false;\n                }\n            }\n        }\n    };\n\n    bool IsPrime(SQWORD sqN)\n    {\n#if 0\n        return vbIsPrime[sqN];\n#else\n        if(sqN <= 2) return false;\n        for (int i = sqrt(sqN)+1; 2 < i; i--) if(sqN % i == 0) return false;\n    \n        return true;\n#endif\n    }\n};\n\n\n/*----------------------------------------------*/\n\n#define PNT_NO_START    (0)\n#define PNT_NO_OFFSET   (200)\n#define PNT_NO_TARGET   (401)\n#define FLOW_OFFSET     (1000000000)\n#define CAPACITY_INF    (1000000001)\n#define DUMMY_COST      (1)\n\nint main(void)\n{\n    SQWORD sqN = inputSQWORD();\n\n    vector<SQWORD> vsqA;\n    vector<SQWORD> vsqB;\n\n    PrimeTable prime(1e7 + 1);\n \n    map<SQWORD, SQWORD> mapB;\n\n    for (SQWORD sqIdx = 0; sqIdx < sqN; sqIdx++) {\n        SQWORD sqA = inputSQWORD();\n        vsqA.emplace_back(sqA);\n\n        mapB[sqA] ^= 1;\n        mapB[sqA + 1] ^= 1;\n    }\n\n    vector<SQWORD> vsqBEven, vsqBOdd;\n\n    for (auto b: mapB) {\n        if (0 < b.second) {\n            if (0 == (b.first % 2)) {\n                vsqBEven.emplace_back(b.first);\n            } else {\n                vsqBOdd.emplace_back(b.first);\n            }\n        }\n    }\n\n    SQWORD sqNodeEven = 1;\n    for (auto e: vsqBEven) {\n        SQWORD sqNodeOdd = 1;\n        for (auto o: vsqBOdd) {\n            if (prime.IsPrime(abs(e - o))) {\n                add_edge(sqNodeOdd, sqNodeOdd + PNT_NO_OFFSET, 1);\n            }\n            sqNodeOdd++;\n        }\n        sqNodeEven++;\n    }\n    for (SQWORD sqIdx = 1; sqIdx <= vsqBEven.size(); sqIdx++) {\n        add_edge(PNT_NO_START, sqIdx, 1);\n    }\n    for (SQWORD sqIdx = 1; sqIdx <= vsqBOdd.size(); sqIdx++) {\n        add_edge(sqIdx + PNT_NO_OFFSET, PNT_NO_TARGET, 1);\n    }\n\n\n\n    SQWORD sqMaxFlow = max_flow(PNT_NO_START, PNT_NO_TARGET);\n    SQWORD vsqCRestEven = vsqBEven.size() - sqMaxFlow;\n    SQWORD vsqCRestOdd  = vsqBOdd.size() - sqMaxFlow;\n\n    SQWORD sqAns = sqMaxFlow;    \n    sqAns += ((vsqCRestEven / 2) * 2);\n    sqAns += ((vsqCRestOdd / 2) * 2);\n    if (0 < (vsqCRestEven %  2)) {\n        sqAns += 3;\n    }\n\n    printf(\"%lld\\n\", sqAns);\n\n    return 0;\n}\n/*------------------------------------------*/\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n#define N 205\n#define M 10000002\nbool cf[M+5],vis[M+5];\nint prime[M+5],tot;\nint cy[N],a[N],b[N],cntx,cnty;\nbool vs[N],c[N][N];\nvoid shai()\n{\n\tvis[1]=1;int i,j;\n\tfor(i=1;i<=M;i++){\n\t\tif(!vis[i])prime[++tot]=i;\n\t\tfor(j=1;j<=tot;j++){\n\t\t\tint tmp=i*prime[j];\n\t\t\tif(tmp>M)break;\n\t\t\tvis[tmp]=1;\n\t\t\tif(i%prime[j]==0)break;\n\t\t}\n\t\tif(cf[i]){\n\t\t\tif(i&1)a[++cntx]=i;\n\t\t\telse b[++cnty]=i;\n\t\t}\n\t}\n}\n//pay attention to vs\nbool dfs(int i)\n{\n\tfor(int j=1;j<=cnty;j++){\n\t\tif(c[i][j]&&!vs[j]){\n\t\t\tvs[j]=1;\n\t\t\tif(!cy[j]||dfs(cy[j])){\n\t\t\t\tcy[j]=i;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nint maxmatch()\n{\n\tmemset(cy,0,sizeof(cy));\n\tint ret=0;\n\tfor(int i=1;i<=cntx;i++){\n\t\tmemset(vs,0,sizeof(vs));\n\t\tif(dfs(i))ret++;\n\t}\n\treturn ret;\n}\nint ab(int x){return x<0?-x:x;}\nint main()\n{\n\tint n,i,j,x,ans;\n\tscanf(\"%d\",&n);\n\tfor(i=1;i<=n;i++){\n\t\tscanf(\"%d\",&x);\n\t\tcf[x]^=1;cf[x+1]^=1;\n\t}\n\tshai();\n\tfor(i=1;i<=cntx;i++)\n\t\tfor(j=1;j<=cnty;j++)\n\t\t\tif(!vis[ab(b[j]-a[i])])c[i][j]=1;\n\tans=maxmatch();\n\tcntx-=ans;cnty-=ans;\n\tans+=(cntx/2)*2+(cnty/2)*2;\n\tif(cntx%2==1&&cnty%2==1)ans+=3;\n\tprintf(\"%d\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nbool bo[10001000],vis[410];\nint st[410],mp[410][410],part[410],top,js0,js1;\nbool isprime(int p)\n{\n\tif ((p<=2)||(!(p&1))) return false;\n\tfor (int i=2;i*i<=p;i++) if (p%i==0) return false;\n\treturn true;\n}\nbool search(int s)\n{\n\tvis[s]=true;\n\tfor (int i=1;i<=top;i++) if (mp[s][i])\n\t{\n\t\tif (!part[i]) {part[i]=s;return true;}\n\t\telse if ((!vis[part[i]])&&(search(part[i]))) {part[i]=s;return true;}\n\t}\n\treturn false;\n}\nint main()\n{\n\tint n;scanf(\"%d\",&n);\n\tfor (int i=1;i<=n;i++) {int w;scanf(\"%d\",&w);bo[w]=true;}\n\tfor (int i=1;i<=10000001;i++) if (bo[i]^bo[i-1]) {st[++top]=i;if (i&1) js1++;else js0++;}\n\tfor (int i=1;i<=top;i++) if (st[i]&1)\n\tfor (int j=1;j<=top;j++) if (isprime(abs(st[i]-st[j]))) mp[i][j]=1;\n\tint sum=0;\n\tfor (int i=1;i<=top;i++) if (st[i]&1)\n\t{\n\t\tmemset(vis,0,sizeof(vis));\n\t\tsum+=search(i);\n\t}\n\tjs0-=sum;js1-=sum;\n\tcout<<sum+js0+js1+(js0&js1&1)<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define pb push_back\nconst int maxn=210;\nint n,k,pri[10000010],linker[maxn],a[maxn],b[maxn];\nbool mark[10000010],vis[maxn];\nvector<int> v[maxn];\nvoid pre()\n{\n\tn=10000000;\n\tmark[1]=true;\n\tfor (int i=2;i<=n;i++)\n\t{\n\t\tif (!mark[i])\n\t\t{\n\t\t\tpri[k++]=i;\n\t\t}\n\t\tfor (int j=0;j<k;j++)\n\t\t{\n\t\t\tint m=i*pri[j];\n\t\t\tif (m>n)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmark[m]=true;\n\t\t\tif (i%pri[j]==0)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\nbool dfs(int x)\n{\n\tfor (int i=0;i<v[x].size();i++)\n\t{\n\t\tint y=v[x][i];\n\t\tif (vis[y])\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\t\tvis[y]=true;\n\t\tif (linker[y]==-1 || dfs(linker[y]))\n\t\t{\n\t\t\tlinker[y]=x;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\nint main()\n{\n\tpre();\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%d\",&a[i]);\n\t}\n\tint k=0;\n\tb[++k]=a[1]-1;\n\tfor (int i=2;i<=n;i++)\n\t{\n\t\tif (a[i]!=a[i-1]+1)\n\t\t{\n\t\t\tb[++k]=a[i-1];\n\t\t\tb[++k]=a[i]-1;\n\t\t}\n\t}\n\tb[++k]=a[n];\n\tn=k;\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tlinker[i]=-1;\n\t\tfor (int j=i+1;j<=n;j++)\n\t\t{\n\t\t\tif ((b[i]+b[j])&1 && !mark[abs(b[i]-b[j])])\n\t\t\t{\n\t\t\t\tif (b[i]&1)\n\t\t\t\t{\n\t\t\t\t\tv[i].pb(j);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tv[j].pb(i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint s=0;\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tif (!(b[i]&1))\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\t\tmemset(vis,false,sizeof(vis));\n\t\tif (dfs(i))\n\t\t{\n\t\t\ts++;\n\t\t}\n\t}\n\tint s1=0,s2=0;\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tif (b[i]&1)\n\t\t{\n\t\t\ts1++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\ts2++;\n\t\t}\n\t}\n\tint ans=s+((s1-s)/2+(s2-s)/2)*2+((s1-s)&1)*3;\n\tcout<<ans<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<cstring>\n#include<algorithm>\n#include<string>\n#include<map>\n#include<set>\n#include<ctime>\n#include<cstdlib>\n#include<queue>\nusing namespace std;\n#define N 806\n#define ll long long\n#define mp make_pair\nll read()\n{\n\tll f=1,x=0;\n\tchar c=getchar();\n\twhile(c>'9'||c<'0')\n\t{\n\t\tif(c=='-') f=-1;\n\t\tc=getchar();\n\t}\n\twhile(c>='0'&&c<='9')\n\t{\n\t\tx=x*10+c-'0';\n\t\tc=getchar();\n\t}\n\treturn f*x;\n}\nint t,n,x[N],st[N],dep[N],top,size,head[N],S,T,pre[10000020],cnt;\nbool isp[10000020];\nstruct ndoe{\n\tint next,to,vlu;\n}mem[N*N*4];\nvoid add(int u,int v,int vlu)\n{\n\tmem[++size].to=v;mem[size].next=head[u];head[u]=size;mem[size].vlu=vlu;\n\tmem[++size].to=u;mem[size].next=head[v];head[v]=size;mem[size].vlu=0;\n}\nvoid init()\n{\n\tint top=1e7;\n\tisp[1]=1;\n\tfor(int i=2;i<=top;++i)\n\t{\n\t\tif(!isp[i]) pre[++cnt]=i;\n\t\tfor(int j=1;j<=cnt&&pre[j]*i<=top;++j)\n\t\t{\n\t\t\tisp[pre[j]*i]=1;\n\t\t\tif(i%pre[j]==0) break;\n\t\t}\n\t}\n}\nqueue<int>q;\nbool bfs(){\n\tmemset(dep,0,sizeof(dep));\n\tdep[S]=1;\n\tq.push(S);\n\twhile(!q.empty())\n\t{\n\t\tint x=q.front();q.pop();\n\t\tfor(int i=head[x];i;i=mem[i].next)\n\t\t{\n\t\t\tint v=mem[i].to;\n\t\t\tif(mem[i].vlu&&!dep[v])\n\t\t\t{\n\t\t\t\tdep[v]=dep[x]+1;\n\t\t\t\tq.push(v);\n\t\t\t}\n\t\t}\n\t}\n\treturn dep[T];\n}\nint dfs(int x,int flow)\n{\n\tif(x==T) return flow;\n\tint now,used=0;\n\tfor(int i=head[x];i;i=mem[i].next)\n\t{\n\t\tint v=mem[i].to;\n\t\tif(mem[i].vlu&&dep[v]==dep[x]+1)\n\t\t{\n\t\t\tnow=dfs(v,min(mem[i].vlu,flow-used));\n\t\t\tused+=now;\n\t\t\tmem[i].vlu-=now;\n\t\t\tmem[i^1].vlu+=now;\n\t\t\tif(used==flow) break;\n\t\t}\n\t}\n\tif(used!=flow) dep[x]=-1;\n\treturn used;\n}\nint main()\n{\n//\tfreopen(\"light3.in\",\"r\",stdin);\n//\tfreopen(\"B.out\",\"w\",stdout);\n\tinit();\n\tt=read();\n\twhile(t--)\n\t{\n\t\ttop=0;\n\t\tsize=1;\n\t\tmemset(head,0,sizeof(head));\n\t\tn=read();\n\t\tfor(int i=1;i<=n;++i) x[i]=read();\n\t\tfor(int i=1;i<=n;++i)\n\t\t{\n\t\t\tst[++top]=x[i]-1;\n\t\t\tint now=x[i],r=i;\n\t\t\twhile(x[r]==now&&r<=n) now++,r++;\n\t\t\ti=r-1;\n\t\t\tst[++top]=x[r-1];\n\t\t}\n\t//\tfor(int i=1;i<=top;++i) cout<<st[i]<<\" \";cout<<'\\n';\n\t\tS=top+1,T=S+1;\n\t\tint s1=0,s2=0;\n\t\tfor(int i=1;i<=top;++i)\n\t\t{\n\t\t\tif(st[i]&1) add(S,i,1),s1++;\n\t\t\telse add(i,T,1),s2++;\n\t\t\tfor(int j=i+1;j<=top;++j) if(st[j]-st[i]!=2&&!isp[st[j]-st[i]])\n\t\t\tif(st[i]&1) add(i,j,1);\n\t\t\telse add(j,i,1);\n\t\t}\n\t\tint k=0;\n\t\t\n\t\twhile(bfs()) k+=dfs(S,1e9);\n\t//\tcout<<\"k\"<<k<<\" \"<<s1<<\" \"<<s2<<'\\n';\n\t\tcout<<k+2*((s1-k)/2+(s2-k)/2)+3*((s1-k)%2)<<'\\n';\n\t}\n\treturn 0;\n}\n/*\n1\n1\n6\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<cstring>\nusing namespace std;\nint n;\nint res;\nvector<int>v;\nint lst=-1;\nint match[210];\nint me,mo;\nint mx;\nbool f[10000010];\nbool ok[210][210];\nbool vis[210];\nint prm[1000010];\nint sz;\nint l;\nbool bp(int x)\n{\n\tfor(int i=0;i<l;i++)\n\t{\n\t\tif(!ok[x][i])continue;\n\t\tif(vis[i])continue;\n\t\tvis[i]=true;\n\t\tif(match[i]==-1 || bp(match[i]))\n\t\t{\n\t\t\tmatch[i]=x;\n\t\t\treturn true;\n\t\t}\n\t\tvis[i]=false;\n\t}\n\treturn false;\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint x;\n\t\tscanf(\"%d\",&x);\n\t\tif(x!=lst+1)\n\t\t{\n\t\t\tif(lst+1)v.push_back(lst+1);\n\t\t\tv.push_back(x);\n\t\t}\n\t\tlst=x;\n\t\tmx=lst+1;\n\t}\n\tv.push_back(lst+1);\n\tf[1]=true;\n\tfor(int i=2;i<=mx;i++)\n\t{\n\t\tif(!f[i])prm[++sz]=i;\n\t\tfor(int j=1;j<=sz;j++)\n\t\t{\n\t\t\tif(prm[j]*i>mx)break;\n\t\t\tf[prm[j]*i]=true;\n\t\t\tif(i%prm[j]==0)break;\n\t\t}\n\t}\n\tl=v.size();\n\tfor(int i=0;i<l;i++)\n\t{\n\t\tmatch[i]=-1;\n\t\tif(v[i]&1)mo++;else me++;\n\t\tfor(int j=i+1;j<l;j++)\n\t\t{\n\t\t\tif(v[j]-v[i]!=2 && !f[v[j]-v[i]])\n\t\t\t{\n\t\t\t\tok[i][j]=ok[j][i]=true;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<l;i++)\n\t{\n\t\tif(match[i]!=-1)continue;\n\t\tmemset(vis,false,sizeof(vis));\n\t\tif(bp(i))res++;\n\t}\n\tres/=2;\n\tprintf(\"%d\",res+((me-res)/2+(mo-res)/2)*2+((me-res)%2)*3);\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ADD(a, b) a = (a + (ll)b) % mod\n#define MUL(a, b) a = (a * (ll)b) % mod\n#define MAX(a, b) a = max(a, b)\n#define MIN(a, b) a = min(a, b)\n#define rep(i, a, b) for(int i = (a); i < (b); i++)\n#define rer(i, a, b) for(int i = (a) - 1; i >= (b); i--)\n#define all(a) (a).begin(), (a).end()\n#define sz(v) (int)(v).size()\n#define pb push_back\n#define sec second\n#define fst first\n#define debug(fmt, ...) Debug(__LINE__, \":\", fmt, ##__VA_ARGS__)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pi;\ntypedef pair<int, pi> ppi;\ntypedef vector<ll> vi;\ntypedef complex<double> comp;\nvoid Debug() {cout << '\\n'; }\ntemplate<class FIRST, class... REST>void Debug(FIRST arg, REST... rest) { \n\tcout << arg << \" \"; Debug(rest...); }\ntemplate<class T>ostream& operator<< (ostream& out, const vector<T>& v) {\n\tout << \"[\";if(!v.empty()){rep(i,0,sz(v)-1)out<<v[i]<< \", \";out<<v.back();}out << \"]\";return out;}\ntemplate<class S, class T>ostream& operator<< (ostream& out, const pair<S, T>& v) {\n\tout << \"(\" << v.first << \", \" << v.second << \")\";return out;}\nconst int MAX_N = 200010;\nconst double eps = 1e-6;\nconst ll mod = 1000000007;\nconst int inf = 1 << 30;\nconst ll linf = 1LL << 60;\nconst double PI = 3.14159265358979323846;\n///////////////////////////////////////////////////////////////////////////////////////////////////\n\nnamespace MF { //init before you use it. when you use double, be careful.\n\n\tstruct edge {int to, cap, rev; };\n\n\tvector<edge> G[MAX_N];\n\tbool used[MAX_N];\n\n\tvoid init(int n) {\n\t\trep(i, 0, n) G[i].clear();\n\t}\n\n\tint add_edge(int from, int to, int cap) {\n\t\tG[from].push_back((edge){to, cap, (int)G[to].size()});\n\t\tG[to].push_back((edge){from, 0, (int)G[from].size() - 1});\n\t\treturn (int)G[from].size() - 1;\n\t}\n\n\tint dfs(int v, int t, int f, bool change = true) { //if you just want to dfs, change = false\n\t\tif(v == t) return f;\n\t\tused[v] = true;\n\t\tfor(int i = 0; i < (int)G[v].size(); i++) {\n\t\t\tedge &e = G[v][i];\n\t\t\tif(!used[e.to] && e.cap > 0) {\n\t\t\t\tint d = dfs(e.to, t, min(f, e.cap), change);\n\t\t\t\tif(d > 0) {\n\t\t\t\t\tif(change) {\n\t\t\t\t\t\te.cap -= d;\n\t\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\t}\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\n\tll get(int s, int t) {\n\t\tll flow = 0;\n\t\twhile(true) {\n\t\t\tmemset(used, 0, sizeof(used));\n\t\t\tint f = dfs(s, t, inf);\n\t\t\tif(f == 0) return flow;\n\t\t\tflow += f;\n\t\t}\n\t}\n}\n\nint N, M;\nint E, O;\nint A[110], B[210];\nint C[210], D[210];\n\nbool prime(int v) {\n\tif(v <= 2) return false;\n\tfor(int i = 2; i * i <= v; i++) {\n\t\tif(v % i == 0) return false;\n\t}\n\treturn true;\n}\n\nvoid solve() {\n\tcin >> N;\n\tM = 0;\n\trep(i, 0, N) cin >> A[i];\n\trep(i, 0, N) {\n\t\tint t1 = (find(A, A + N, A[i] - 1) != A + N);\n\t\tint t2 = (find(A, A + N, A[i] + 1) != A + N);\n\t\tif(t1 == 0) B[M++] = A[i] - 1;\n\t\tif(t2 == 0) B[M++] = A[i];\n\t}\n\tM = unique(B, B + M) - B;\n\tint s = M, t = M + 1;\n\tMF::init(M + 2);\n\n\trep(i, 0, M) {\n\t\tif(B[i] % 2 == 0) C[E++] = B[i];\n\t\telse D[O++] = B[i];\n\t}\n\trep(i, 0, E) {\n\t\trep(j, 0, O) {\n\t\t\tif(prime(abs(C[i] - D[j]))) {\n\t\t\t\t//debug(C[i], D[j]);\n\t\t\t\tMF::add_edge(i, j + E, 1);\n\t\t\t}\n\t\t}\n\t}\n\trep(i, 0, E) MF::add_edge(s, i, 1);\n\trep(i, 0, O) MF::add_edge(i + E, t, 1);\n\n\tint res = MF::get(s, t);\n\tif((E - res) % 2 == 0) {\n\t\tcout << res + (E - res) + (O - res) << \"\\n\";\n\t}\n\telse {\n\t\tcout << res + (E - res - 1) + (O - res - 1) + 3 << \"\\n\";\n\t}\n}\n\nint main() {\n#ifndef LOCAL\n\tios::sync_with_stdio(false);\n    cin.tie(0);\n#endif\n    cout << fixed;\n\tcout.precision(5);\n#ifdef LOCAL\n    freopen(\"in.txt\", \"rt\", stdin);\n#endif\t\n\tsolve();\n#ifdef LOCAL\n    cerr << \"Time elapsed: \" << 1.0 * clock() / CLOCKS_PER_SEC << \" s.\\n\";\n#endif\n\treturn 0;\n}\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <unordered_map>\n#include <unordered_set>\n#include <utility>\n#include <vector>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> PP;\n\n// This code performs maximum bipartite matching.\n//\n// Running time: O(|E| |V|) -- often much faster in practice\n//\n//   INPUT: w[i][j] = edge between row node i and column node j\n//   OUTPUT: mr[i] = assignment for row node i, -1 if unassigned\n//           mc[j] = assignment for column node j, -1 if unassigned\n//           function returns number of matches made\n\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\n\nbool FindMatch(int i, const VVI &w, VI &mr, VI &mc, VI &seen) {\n  for (int j = 0; j < w[i].size(); j++) {\n    if (w[i][j] && !seen[j]) {\n      seen[j] = true;\n      if (mc[j] < 0 || FindMatch(mc[j], w, mr, mc, seen)) {\n        mr[i] = j;\n        mc[j] = i;\n        return true;\n      }\n    }\n  }\n  return false;\n}\n\nint BipartiteMatching(const VVI &w) {\n  VI mr = VI(w.size(), -1);\n  VI mc = VI(w[0].size(), -1);\n  \n  int ct = 0;\n  for (int i = 0; i < w.size(); i++) {\n    VI seen(w[0].size());\n    if (FindMatch(i, w, mr, mc, seen)) ct++;\n  }\n  return ct;\n}\n\nset<int> P;\nconst int B = 1E7 + 10;\nbool sieve[B];\n\nint main() {\n    ios::sync_with_stdio(false);\n    int N;\n    cin >> N;\n    set<int> M;\n    for (int i = 0;i < N;i++) {\n    \tint n;\n    \tcin >> n;\n    \tM.insert(n);\n    }\n    memset(sieve, 0, sizeof(sieve));\n    for (int i = 2;i < B;i++) {\n    \tif (sieve[i] == 0) {\n    \t\tfor (int j = i;j < B;j += i) sieve[j] = 1;\n    \t\tif (i % 2) P.insert(i);\n    \t}\n    }\n    set<int> Q;\n    for (auto m : M) {\n    \tif (M.count(m - 1) == 0) Q.insert(m - 1);\n    \tif (M.count(m + 1) == 0) Q.insert(m);\n    }\n    vector<int> R;\n    for (auto m : Q) R.push_back(m);\n    int sz = R.size();\n    vector<int> o, e;\n    for (int i = 0;i < sz;i++) {\n    \tif (R[i] % 2) o.push_back(R[i]);\n    \telse e.push_back(R[i]);\n    }\n    vector<int> tmp(e.size(), 0);\n    vector<vector<int> > T(o.size(), tmp);\n    for (int i = 0;i < o.size();i++) {\n    \tfor (int j = 0;j < e.size();j++) {\n    \t\tif (P.count(abs(o[i] - e[j]))) T[i][j] = 1;\n    \t}\n    }\n    int mc = 0;\n    if (o.size() > 0 && e.size() > 0) mc = BipartiteMatching(T);\n    int oo = o.size() - mc;\n    int ee = e.size() - mc;\n    cout << mc + 2 * (oo / 2 + ee / 2) + 3 * (oo % 2) << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define left lft\n\nconst int N=1e7;\nconst int maxn=N+10;\n\nint n,m,m0,m1,c[210],k1,left[210];\nbool vis[210];\nbool comp[maxn]; //composite\nint primes,prime[maxn/10];\n\nvoid prework()\n{\n\tint i,j;\n\tcomp[0]=1;\n\tcomp[1]=1;\n\tfor (i=2;i<=N;i++)\n\t{\n\t\tif (!comp[i]) prime[++primes]=i;\n\t\tfor (j=1;j<=primes&&i*prime[j]<=N;j++)\n\t\t{\n\t\t\tcomp[i*prime[j]]=1;\n\t\t\tif (i%prime[j]==0) break;\n\t\t}\n\t}\n\tcomp[2]=1;\n}\n\nbool match(int u)\n{\n\tfor (int i=1;i<=m;i++)\n\t{\n\t\tint v=c[i];\n\t\tif (comp[abs(u-v)]||vis[v]) continue;\n\t\tvis[v]=1;\n\t\tif (!left[v]||match(left[v]))\n\t\t{\n\t\t\tleft[v]=u;\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nint main()\n{\n#ifdef h10\n\tfreopen(\"F.in\",\"r\",stdin);\n\tfreopen(\"F.out\",\"w\",stdout);\n#endif\n\tint i,x;\n\tprework();\n\tscanf(\"%d\",&n);\n\tfor (i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%d\",&x);\n\t\tc[(i<<1)-1]=x;\n\t\tc[i<<1]=x+1;\n\t}\n\tsort(c+1,c+n+n+1);\n\tfor (i=1;i<=n+n;i++)\n\t\tc[i]==c[m]?m--:c[++m]=c[i];\n\tfor (i=1;i<=m;i++)\n\t\tc[i]&1?m1++:m0++;\n\tfor (i=1;i<=m;i++)\n\t{\n\t\tmemset(vis,0,sizeof(vis));\n\t\tif (c[i]&1) k1+=match(i);\n\t}\n\tm0-=k1; m1-=k1;\n\tprintf(\"%d\\n\",k1+((m0>>1)+(m1>>1))*2+(m0&1)*3);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=110;\nbool pd(int k){\n\tif(k==1) return 0;\n\tint sk=sqrt(k);\n\tfor(int i=2;i<=sk;i++) if(!(k%i)) return 0;\n\treturn 1;\n}\nint n,b[N<<1],link[N],e[N<<1],o[N<<1];\nbool g[N][N],vis[N];\nbool dfs(int k){\n\tfor(int i=1;i<=e[0];i++){\n\t\tif(g[k][i]&&!vis[i]){\n\t\t\tvis[i]=1;\n\t\t\tif(link[i]==-1||dfs(link[i])){\n\t\t\t\tlink[i]=k;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nint main(){\n\tint tx;\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++){\n\t\tscanf(\"%d\",&tx);\n\t\tif(b[b[0]]==tx) b[b[0]]++;\n\t\telse b[++b[0]]=tx,b[++b[0]]=tx+1;\n\t}\n\tfor(int i=1;i<=b[0];i++){\n\t\tif(b[i]&1) o[++o[0]]=b[i];\n\t\telse e[++e[0]]=b[i];\n\t}\n\tfor(int i=1;i<=o[0];i++)\n\t\tfor(int j=1;j<=e[0];j++){\n\t\t\tif(pd(abs(o[i]-e[j]))) g[i][j]=1;\n\t\t}\n\tint k=0;\n\tmemset(link,-1,sizeof(link));\n\tfor(int i=1;i<=o[0];i++){\n\t\tmemset(vis,0,sizeof(vis));\n\t\tif(dfs(i)) k++;\n\t}\n//\tcout<<k<<endl;\n\tcout<<k+((o[0]-k)/2+(e[0]-k)/2)*2+((e[0]-k)%2)*3<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#define fo(i,a,b) for(int i=a;i<=b;++i)\n#define fod(i,a,b) for(int i=a;i>=b;--i)\n#define min(q,w) ((q)>(w)?(w):(q))\n#define max(q,w) ((q)<(w)?(w):(q))\nusing namespace std;\nconst int N=350,M=1e7;\nint read(int &n)\n{\n\tchar ch=' ';int q=0,w=1;\n\tfor(;(ch!='-')&&((ch<'0')||(ch>'9'));ch=getchar());\n\tif(ch=='-')w=-1,ch=getchar();\n\tfor(;ch>='0' && ch<='9';ch=getchar())q=q*10+ch-48;n=q*w;return n;\n}\nint m,n,ans;\nbool az[M+10],prz[M+10];\nbool B[N][N];\nint pr[M/5];\nint a[N],b[N],zx[N];\nint z[N],TI;\nvoid Pre()\n{\n\tfo(i,2,M)\n\t{\n\t\tif(!prz[i])pr[++pr[0]]=i;\n\t\tfo(j,1,pr[0])\n\t\t{\n\t\t\tint t=i*pr[j];\n\t\t\tif(t>M)break;\n\t\t\tprz[t]=1;\n\t\t\tif(!t%pr[j])break;\n\t\t}\n\t}\n}\nbool OK(int q)\n{\n\tif(z[q]==TI)return 0;\n\tz[q]=TI;\n\tfo(i,1,b[0])if(B[q][i]&&(!zx[i]||OK(zx[i])))return zx[i]=q,1;\n\treturn 0;\n}\nint main()\n{\n\tint q;\n\tPre();\n\tread(n);\n\tfo(i,1,n)az[read(q)]=1;\n\tfo(i,1,M)if(az[i]!=az[i-1])\n\t{\n\t\tif(i&1)a[++a[0]]=i;\n\t\telse b[++b[0]]=i;\n\t}\n\tfo(i,1,a[0])fo(j,1,b[0])if(!prz[abs(a[i]-b[j])])B[i][j]=1;\n\tq=0;\n\tfo(i,1,a[0])\n\t{\n\t\t++TI;if(OK(i))++q;\n\t}\n\tans=q+2*((a[0]-q)/2+(b[0]-q)/2);\n\tif((a[0]-q)&1)ans+=3;\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int maxn=205;\nconst int maxm=10000005;\nconst int INF=0x3f3f3f;\n\nint n;\nint c[maxm];\nint p1[maxn],tot1=0,p2[maxn],tot2=0,nn;\n\nstruct Edge\n{\n    int from,to,capa,flow,next;\n}e[maxn*maxn];\n\nint h[maxn],tot=-1;\n\ninline void addedge(int a,int b,int c) { e[++tot].from=a; e[tot].to=b; e[tot].capa=c; e[tot].flow=0; e[tot].next=h[a]; h[a]=tot; }\n\nbool check(int p)\n{\n    if (p==1) return 0;\n    for (int i=2;i*i<=p;i++) if (p%i==0) return 0;\n    return 1;\n}\n\nint s,t,d[maxn],cur[maxn],vis[maxn];\n/*\nint dfs(int p,int a)\n{\n    if (p==t || !a) return a;\n    int flow=0,f;\n    for (int &i=cur[p];~i;i=e[i].nxt)\n    if (d[e[i].to]==d[p]+1 && e[i].capa>e[i].flow)\n    {\n        f=dfs(e[i].to,min(a,e[i].capa-e[i].flow));\n        if (f)\n        {\n            flow+=f; a-=f;\n            e[i].flow+=f; e[i^1].flow-=f;\n        }\n        if (!a) break;\n    }\n    if (a) d[p]=-1;\n    return flow;\n}\n\nint bfs()\n{\n    queue<int> q;\n    memset(vis,0,sizeof(vis));\n    q.push(s); vis[s]=1; d[s]=0;\n    while (!q.empty())\n    {\n        int o=q.front(); q.pop();\n        for (int i=h[o];~i;i=e[i].nxt)\n        if (!vis[e[i].to] && e[i].capa>e[i].flow)\n        {\n            vis[e[i].to]=1; q.push(e[i].to);\n            d[e[i].to]=d[o]+1;\n        }\n    }\n    return vis[t];\n}\n\nint Dinic()\n{\n    int flow=0;\n    while (bfs())\n    {\n        //cout<<\"GG\";\n        for (int i=0;i<=nn;i++) cur[i]=h[i];\n        flow+=dfs(s,INF);\n    }\n    return flow;\n}\n*/\nbool BFS()\n{\n    memset(vis,0,sizeof(vis));\n    queue<int> q;\n    q.push(s);\n    d[s]=0;vis[s]=1;\n    while(!q.empty())\n    {\n        int u=q.front();\n        for(int tmp=h[u];~tmp;tmp=e[tmp].next)\n            if(e[tmp].capa>e[tmp].flow&&!vis[e[tmp].to])\n            {\n                vis[e[tmp].to]=1;\n                d[e[tmp].to]=d[u]+1;\n                q.push(e[tmp].to);\n            }\n        q.pop();\n    }\n    return vis[t];\n}\n\nint DFS(int u,int a)\n{\n    if(u==t||a==0) return a;\n    int f,flow=0;\n    for(int& tmp=cur[u];~tmp;tmp=e[tmp].next)\n        if(d[e[tmp].to]==d[u]+1)\n        {\n            f=DFS(e[tmp].to,min(a,e[tmp].capa-e[tmp].flow));\n            if(f>0)\n            {\n                flow+=f;a-=f;\n                e[tmp].flow+=f;\n                e[tmp^1].flow-=f;\n                if(a==0) break;\n            }\n        }\n    return flow;\n}\n\nint Dinic()\n{\n    int flow=0;\n    while(BFS())\n    {\n        for(int i=s;i<=t;i++) cur[i]=h[i];\n        flow+=DFS(s,INF);\n    }\n    return flow;\n}\n\nint main()\n{\n\t//freopen(\"input.txt\",\"r\",stdin);\n\t//freopen(\"myout.txt\",\"w\",stdout);\n\n    scanf(\"%d\",&n);\n    int tmp,mx=0;\n    for (int i=1;i<=n;i++) { scanf(\"%d\",&tmp); mx=max(mx,tmp); c[tmp]=1; } mx++;\n    //for (int i=mx;i>=1;i--) c[i]=c[i-1]^c[i];\n    //for (int i=1;i<=mx;i++) cout<<c[i];\n    for (int i=1;i<=mx;i++)\n    if (c[i]!=c[i-1])\n    {\n        if (i&1) p1[++tot1]=i;\n            else p2[++tot2]=i;\n    }\n    //cout<<tot1<<' '<<tot2<<endl;\n    nn=tot1+tot2+1; s=0; t=nn;\n    //cerr<<\"check: \"<<s<<\" \"<<t<<endl;\n    //cout<<nn<<endl;\n    memset(h,-1,sizeof(h));\n    for (int i=1;i<=tot1;i++) { addedge(s,i,1); addedge(i,s,0); }\n    for (int i=1;i<=tot2;i++) { addedge(i+tot1,t,1); addedge(t,i+tot1,0); }\n    for (int i=1;i<=tot1;i++)\n        for (int j=1;j<=tot2;j++)\n            if (check(abs(p2[j]-p1[i]))) { addedge(i,j+tot1,1); addedge(j+tot1,i,0); }\n    int flow=Dinic(),ans=0;\n    //cout<<\"GG\";\n    ans=flow; //cout<<flow<<endl;\n    ans+=(tot1-flow)/2*2+(tot2-flow)/2*2;\n    ans+=((tot1-flow)&1)*3;\n    cout<<ans;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<cstring>\n#include<map>\n#include<queue>\n#include<cmath>\nusing namespace std;\ntypedef long long ll;\nconst int N=1005,INF=~0u>>2;\nstruct Edge{int nxt,to;}edge[(N*N)<<3];\nint a[N],b[N<<1],n,head[N<<1],num_edge,vis[N<<1],lk[N<<1],even[N<<1],odd[N<<1],even_num,odd_num,ans,k,tot,tim;\nint read(){\n\tint x=0,f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-') f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn f*x;\n}\nvoid add_edge(int from,int to){\n\tedge[++num_edge].nxt=head[from];\n\tedge[num_edge].to=to;\n\thead[from]=num_edge;\n}\nbool find(int x){\n\tfor(int i=head[x];i;i=edge[i].nxt){\n\t\tif(vis[edge[i].to]!=tim){\n\t\t\tvis[edge[i].to]=tim;\n\t\t\tif(!lk[edge[i].to]||find(edge[i].to)){\n\t\t\t\tlk[edge[i].to]=x;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nbool check(int x){\n\tif(x==1) return 0;\n\tfor(int i=2;i*i<=x;++i){\n\t\tif(x%i==0) return 0;\n\t}\n\treturn 1;\n}\nint main(){\n//\tfreopen(\"ex.in\",\"r\",stdin);\n\tn=read();\n\tfor(int i=1;i<=n;++i) b[i]=read();b[0]=-INF;b[n+1]=INF;\n\tfor(int i=1;i<=n;++i){\n\t\tif(b[i]!=b[i-1]+1){\n\t\t\tif(i%2) odd[++odd_num]=b[i];\n\t\t\telse even[++even_num]=b[i];\n\t\t}\n\t\tif(b[i]+1!=b[i+1]){\n\t\t\tif((i+1)%2) odd[++odd_num]=b[i]+1;\n\t\t\telse even[++even_num]=b[i]+1;\n\t\t}\n\t}\n\tfor(int i=1;i<=odd_num;++i){\n\t\tfor(int j=1;j<=even_num;++j){\n\t\t\tif(check(abs(even[j]-odd[i]))) add_edge(i,j+odd_num);\n\t\t}\n\t}\n\tfor(int i=1;i<=odd_num;++i){\n\t\ttim++;\n\t\tif(find(i)) k++;\n\t\telse break;\n\t}\n\tans=k+((even_num-k)/2+(odd_num-k)/2)*2+((even_num-k)%2)*3;\n\tprintf(\"%d\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint n,x,a[222],b[222],m,ans=1e8,an,c[2];\nmap<int,int>mp;\nstruct E{\n\tint u,v;\n}e[44444];\n\nbool pri(int x){\n\tif (x%2==0||x==1) return 0;\n\tfor (int i=3;i*i<=x;++i) if (x%i==0)\n\t\treturn 0;\n\treturn 1;\n}\n\nint main(){\n\tfor (cin>>n;n--;)\n\t\tcin>>x, mp[x]^=1, mp[x+1]^=1;\n\tn=0;\n\tfor (auto o:mp) if (o.second)\n\t\ta[++n]=o.first;\n\tfor (int i=1;i<n;++i)\n\t\tfor (int j=i+1;j<=n;++j) if (pri(abs(a[i]-a[j])))\n\t\t\te[++m]=(E){i,j};\n\tfor (int t=10000;t--;){\n\t\trandom_shuffle(e+1,e+m+1);\n\t\tmemset(b,0,sizeof b); an=0;\n\t\tfor (int i=1;i<=m;++i){\n\t\t\tif (!b[e[i].u]&&!b[e[i].v])\n\t\t\t\tb[e[i].u]=b[e[i].v]=1, ++an;\n\t\t}\n\t\tc[0]=c[1]=0;\n\t\tfor (int i=1;i<=n;++i) if (!b[i])\n\t\t\t++c[a[i]&1];\n\t\tan+=(c[0]/2+c[1]/2)*2+c[0]%2*3;\n\t\tans=min(ans,an);\n\t}\n\tcout<<ans;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<map>\n#include<vector>\nusing namespace std;\n#define INF (1 << 29)\nbool prime(int x){\n  for(int i = 2;i * i <= x;i++){\n    if(x % i == 0)return false;\n  }\n  return true;\n}\n\nclass E{\npublic:\n  int to, lim, inv;\n  E(int a, int b, int c){\n    to = a;\n    lim = b;\n    inv = c;\n  }\n};\n\nvector<E> edge[300];\nint n, x;\nmap<int, int> cnt;\nvector<int> odd, even;\n\nvoid add_edge(int u, int v, int f){\n  edge[u].push_back(E(v, f, edge[v].size()));\n  edge[v].push_back(E(u, 0, edge[u].size() - 1));\n}\n\n\nbool come[300];\nint flow(int s, int t, int f){\n  if(come[s])return 0;\n  come[s] = true;\n  if(s == t)return f;\n  for(int i = 0;i < edge[s].size();i++){\n    E &e = edge[s][i];\n    if(e.lim == 0)continue;\n    int tmp = flow(e.to, t, min(f, e.lim));\n    if(tmp == 0)continue;\n    e.lim -= tmp;\n    edge[e.to][e.inv].lim += tmp;\n    return tmp;\n  }\n  return 0;\n}\n\nint max_flow(int s, int t){\n  int res = 0;\n  while(true){\n    for(int i = 0;i < 300;i++)come[i] = false;\n    int tmp = flow(s, t, INF);\n    if(tmp == 0)return res;\n    res += tmp;\n  }\n}\n\n\nint main(){\n  cin >> n;\n  for(int i = 0;i < n;i++){\n    cin >> x;\n    cnt[x]^=1;\n    cnt[x-1]^=1;\n  }\n  map<int, int>::iterator it;\n  for(it = cnt.begin();it != cnt.end();it++){\n    if(it->second == 0)continue;\n    x = it->first;\n    if(x % 2 == 0)even.push_back(x);\n    if(x % 2 == 1)odd.push_back(x);\n  }\n  int s = even.size() + odd.size() + 1;\n  int t = s + 1;\n  for(int i = 0;i < even.size();i++)add_edge(s, i, 1);\n  for(int i = 0;i < odd.size();i++)add_edge(even.size() + i, t, 1);\n  \n  for(int i = 0;i < even.size();i++){\n    for(int j = 0;j < odd.size();j++){\n      int dif = abs(even[i] - odd[j]);\n      if(prime(dif))add_edge(i, even.size() + j, 1);\n    }\n  }\n\n  int mxf = max_flow(s, t);\n  cout << mxf + (even.size() - mxf) / 2 * 2 + (odd.size() - mxf) / 2 * 2 + (even.size() - mxf) % 2 * 3 << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nnamespace prime{\n\tconst int mx = 10000001;\n\tbool f[mx];\n\tint p[777777],lp;\n\tvoid init(){\n\t\tfor(int i=2; i<mx; i++){\n\t\t\tif(!f[i])p[lp++]=i;\n\t\t\tfor(int j=0; j<lp; j++){\n\t\t\t\tint w = p[j] * i;\n\t\t\t\tif(w >= mx)break;\n\t\t\t\tf[w] = true;\n\t\t\t\tif(i%p[j]==0)break;\n\t\t\t}\n\t\t}\n\t}\n\tbool isprime(int x){\n\t\tif(x<2)return false;\n\t\treturn !f[x];\n\t}\n};\n\nbool g[10000002];\nint sum[222],n;\nbool col[222];\nint d[222][222][2];\nint Q(int x){\n\tif(x%2==0)return 2;\n\treturn prime::isprime(x) ? 1 : 3;\n}\nvoid update(int&x,int y){\n\tif(x==-1 || x>y)x=y;\n}\nvoid dp(int from,int to){\n\tif(d[from][to][0] != -1)return;\n\tif(from > to){\n\t\td[from][to][0] = d[from][to][1] = 0;\n\t\treturn;\n\t}\n\tif(from == to){\n\t\td[from][to][col[from]] = 0;\n\t\td[from][to][!col[from]] = Q(sum[to]-sum[from-1]);\n\t}else{\n\t\tfor(int i=from+1; i<=to; i++){\n\t\t\tdp(from, i-1);\n\t\t\tdp(i,to);\n\t\t}\n\t\tfor(int c=0; c<2; c++)\n\t\tfor(int i=from+1; i<=to; i++){\n\t\t\tupdate(d[from][to][c], d[from][i-1][c] + d[i][to][c]);\n\t\t}\n\t}\n\tupdate(d[from][to][0],d[from][to][1] + Q(sum[to]-sum[from-1]));\n\tupdate(d[from][to][1],d[from][to][0] + Q(sum[to]-sum[from-1]));\n}\nint main(){\n\tprime::init();\n\tint x,z;\n\tfor(scanf(\"%d\",&x); x--;){\n\t\tscanf(\"%d\",&z);\n\t\tg[z] = true;\n\t}\n\tint A = 1;\n\tfor(int i=2; i<=z+1; i++){\n\t\tif(g[i] != g[i-1]){\n\t\t\tsum[++n] = i-1;\n\t\t\tcol[n] = g[i-1];\n\t\t}\n\t}\n\tmemset(d,-1,sizeof(d));\n\tdp(1,n);\n\tprintf(\"%d\\n\",d[1][n][0]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int maxn=205;\nconst int maxm=10000005;\nconst int INF=0x3f3f3f;\n\nint n;\nint c[maxm];\nint p1[maxn],tot1=0,p2[maxn],tot2=0,nn;\n\nstruct Edge\n{\n\tint from,to,capa,flow,nxt;\n}e[maxn*maxn];\n\nint h[maxn],tot=-1;\n\ninline void addedge(int a,int b,int c) { e[++tot].from=a; e[tot].to=b; e[tot].capa=c; e[tot].flow=0; e[tot].nxt=h[a]; h[a]=tot; }\n\nbool check(int p)\n{\n\tif (p==1) return 0;\n\tfor (int i=2;i*i<=p;i++) if (p%i==0) return 0;\n\treturn 1;\n}\n\nint s,t,d[maxn],cur[maxn],vis[maxn];\n\nint dfs(int p,int a)\n{\n\tif (p==t || !a) return a;\n\tint flow=0,f;\n\tfor (int &i=cur[p];~i;i=e[i].nxt)\n\tif (d[e[i].to]==d[p]+1 && e[i].capa>e[i].flow)\n\t{\n\t\tf=dfs(e[i].to,min(a,e[i].capa-e[i].flow));\n\t\tif (f)\n\t\t{\n\t\t\tflow+=f; a-=f;\n\t\t\te[i].flow+=f; e[i^1].flow-=f;\n\t\t}\n\t\tif (!a) break;\n\t}\n\tif (a) d[p]=-1;\n\treturn flow;\n}\n\nint bfs()\n{\n\tqueue<int> q;\n\tmemset(vis,0,sizeof(vis));\n\tq.push(s); vis[s]=1; d[s]=0;\n\twhile (!q.empty())\n\t{\n\t\tint o=q.front(); q.pop();\n\t\tfor (int i=h[o];~i;i=e[i].nxt)\n\t\tif (!vis[e[i].to] && e[i].capa>e[i].flow)\n\t\t{\n\t\t\tvis[e[i].to]=1; q.push(e[i].to);\n\t\t\td[e[i].to]=d[o]+1;\n\t\t}\n\t}\n\treturn vis[t];\n}\n\nint Dinic()\n{\n\tint flow=0;\n\twhile (bfs())\n\t{\n\t\t//cout<<\"GG\";\n\t\tfor (int i=1;i<=nn;i++) cur[i]=h[i];\n\t\tflow+=dfs(s,INF);\n\t}\n\treturn flow;\n}\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\tint tmp,mx=0;\n\tfor (int i=1;i<=n;i++) { scanf(\"%d\",&tmp); mx=max(mx,tmp); c[tmp]=1; } mx++;\n\t//for (int i=mx;i>=1;i--) c[i]=c[i-1]^c[i];\n\t//for (int i=1;i<=mx;i++) cout<<c[i];\n\tfor (int i=1;i<=mx;i++)\n\tif (c[i]!=c[i-1])\n\t{\n\t\tif (i&1) p1[++tot1]=i;\n\t\t\telse p2[++tot2]=i;\n\t}\n\tnn=tot1+tot2+1; s=0; t=nn;\n\t//cout<<nn<<endl;\n\tmemset(h,-1,sizeof(h));\n\tfor (int i=1;i<=tot1;i++) { addedge(s,i,1); addedge(i,s,0); }\n\tfor (int i=1;i<=tot2;i++) { addedge(i+tot1,t,1); addedge(t,i+tot1,0); }\n\tfor (int i=1;i<=tot1;i++)\n\t\tfor (int j=1;j<=tot2;j++)\n\t\t\tif (check(abs(p2[j]-p1[i]))) { addedge(i,i+tot1,1); addedge(i+tot1,i,0); }\n\tint flow=Dinic(),ans=0;\n\t//cout<<\"GG\";\n\tans=flow;\n\tans+=(tot1-flow)/2*2+(tot2-flow)/2*2;\n    ans+=((tot1-flow)&1)*3;\n    cout<<ans;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define ms(s, n) memset(s, n, sizeof(s))\n#define FOR(i, a, b) for (int i = (a); i < (b); i++)\n#define FORd(i, a, b) for (int i = (a) - 1; i >= (b); i--)\n#define FORall(it, a) for (__typeof((a).begin()) it = (a).begin(); it != (a).end(); it++)\n#define sz(a) int((a).size())\n#define present(t, x) (t.find(x) != t.end())\n#define all(a) (a).begin(), (a).end()\n#define uni(a) (a).erase(unique(all(a)), (a).end())\n#define pb push_back\n#define pf push_front\n#define mp make_pair\n#define fi first\n#define se second\n#define prec(n) fixed<<setprecision(n)\n#define bit(n, i) (((n) >> (i)) & 1)\n#define bitcount(n) __builtin_popcountll(n)\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<int, int> pi;\ntypedef vector<int> vi;\ntypedef vector<pi> vii;\nconst int MOD = (int) 1e9 + 7;\nconst int MOD2 = 1007681537;\nconst int INF = (int) 1e9;\nconst ll LINF = (ll) 1e18;\nconst ld PI = acos((ld) -1);\nconst ld EPS = 1e-9;\ninline ll gcd(ll a, ll b) {ll r; while (b) {r = a % b; a = b; b = r;} return a;}\ninline ll lcm(ll a, ll b) {return a / gcd(a, b) * b;}\ninline ll fpow(ll n, ll k, int p = MOD) {ll r = 1; for (; k; k >>= 1) {if (k & 1) r = r * n % p; n = n * n % p;} return r;}\ntemplate<class T> inline int chkmin(T& a, const T& val) {return val < a ? a = val, 1 : 0;}\ntemplate<class T> inline int chkmax(T& a, const T& val) {return a < val ? a = val, 1 : 0;}\ninline ll isqrt(ll k) {ll r = sqrt(k) + 1; while (r * r > k) r--; return r;}\ninline ll icbrt(ll k) {ll r = cbrt(k) + 1; while (r * r * r > k) r--; return r;}\ninline void addmod(int& a, int val, int p = MOD) {if ((a = (a + val)) >= p) a -= p;}\ninline void submod(int& a, int val, int p = MOD) {if ((a = (a - val)) < 0) a += p;}\ninline int mult(int a, int b, int p = MOD) {return (ll) a * b % p;}\ninline int inv(int a, int p = MOD) {return fpow(a, p - 2, p);}\ninline int sign(ld x) {return x < -EPS ? -1 : x > +EPS;}\ninline int sign(ld x, ld y) {return sign(x - y);}\n#define db(x) cerr << #x << \" = \" << (x) << \" \";\n#define endln cerr << \"\\n\";\n\nstruct HopcroftKarp {\n    static const int MAXV = 1e3 + 5;\n    static const int MAXE = 1e6 + 5;\n    int nx, ny, E, adj[MAXE], nxt[MAXE], lst[MAXV], cur[MAXV], lev[MAXV], que[MAXV], matx[MAXV], maty[MAXV];\n    void init(int nx, int ny) {\n        this->nx = nx, this->ny = ny;\n        E = 0, fill_n(lst, nx, -1);\n        fill_n(matx, nx, -1), fill_n(maty, ny, -1);\n    }\n    void add(int x, int y) {\n        adj[E] = y, nxt[E] = lst[x], lst[x] = E++;\n    }\n    int bfs() {\n        int qsize = 0;\n        for (int x = 0; x < nx; x++) if (matx[x] != -1) lev[x] = 0;\n        else {\n            lev[x] = 1;\n            que[qsize++] = x;\n        }\n        int found = 0;\n        for (int i = 0; i < qsize; i++) {\n            for (int x = que[i], e = lst[x]; ~e; e = nxt[e]) {\n                int y = adj[e];\n                if (!~maty[y]) found = 1;\n                else if (!lev[maty[y]]) {\n                    lev[maty[y]] = lev[x] + 1;\n                    que[qsize++] = maty[y];\n                }\n            }\n        }\n        return found;\n    }\n    int dfs(int x) {\n        for (int& e = cur[x]; ~e; e = nxt[e]) {\n            int y = adj[e];\n            if (!~maty[y] || (lev[maty[y]] == lev[x] + 1 && dfs(maty[y]))) {\n                matx[x] = y;\n                maty[y] = x;\n                return 1;\n            }\n        }\n        return 0;\n    }\n    int maxmat() {\n        int res = 0;\n        while (bfs()) {\n            for (int x = 0; x < nx; x++) cur[x] = lst[x];\n            for (int x = 0; x < nx; x++) if (!~matx[x]) res += dfs(x);\n        }\n        return res;\n    }\n} hopkarp;\n\nconst int maxn = 100 + 5;\nconst int maxx = 1e7 + 100;\nvi pr;\nint n;\nint f[maxx];\nint ispr[maxx];\n\nvoid solve() {\n    fill_n(ispr + 2, maxx - 2, 1);\n    FOR(i, 2, maxx) if (ispr[i]) {\n        for (int j = i + i; j < maxx; j += i) {\n            ispr[j] = 0;\n        }\n    }\n    ispr[2] = 0;\n    cin >> n;\n    FOR(i, 0, n) {\n        int x; cin >> x;\n        f[x] ^= 1;\n        f[x + 1] ^= 1;\n    }\n    vi ver;\n    int odds = 0, evens = 0;\n    FOR(i, 1, maxx) {\n        if (f[i]) {\n            ver.pb(i);\n            if (i & 1) {\n                odds++;\n            }\n            else {\n                evens++;\n            }\n        }\n    }\n    hopkarp.init(sz(ver), sz(ver));\n    FOR(i, 0, sz(ver)) FOR(j, 0, sz(ver)) {\n        int x = ver[i];\n        int y = ver[j];\n        if (x % 2 == 0 && y % 2 == 1 && ispr[abs(x - y)]) {\n            hopkarp.add(i, j);\n        }\n    }\n    int mx = hopkarp.maxmat();\n    int nx = odds - mx;\n    int ny = evens - mx;\n    int ans = mx;\n    ans += nx / 2 * 2;\n    ans += ny / 2 * 2;\n    if (nx % 2 == 1 && ny % 2 == 1) {\n        ans += 3;\n    }\n    cout << ans << \"\\n\";\n}\n\nint main() {\n    int JUDGE_ONLINE = 1;\n    if (fopen(\"in.txt\", \"r\")) {\n        JUDGE_ONLINE = 0;\n        assert(freopen(\"in.txt\", \"r\", stdin));\n        //assert(freopen(\"out.txt\", \"w\", stdout));\n    }\n    else {\n        ios_base::sync_with_stdio(0), cin.tie(0);\n    }\n    solve();\n    if (!JUDGE_ONLINE) {\n        //cout << \"\\nTime elapsed: \" << 1000 * clock() / CLOCKS_PER_SEC << \"ms\\n\";\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <math.h>\n#include <string.h>\n#include <time.h>\n#include <stdlib.h>\n#include <string>\n#include <bitset>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <algorithm>\n#include <sstream>\n#include <stack>\n#include <iomanip>\nusing namespace std;\n#define pb push_back\n#define mp make_pair\ntypedef pair<int,int> pii;\ntypedef long long ll;\ntypedef double ld;\ntypedef vector<int> vi;\n#define fi first\n#define se second\n#define fe first\n#define FO(x) {freopen(#x\".in\",\"r\",stdin);freopen(#x\".out\",\"w\",stdout);}\n#define Edg int M=0,fst[SZ],vb[SZ],nxt[SZ];void ad_de(int a,int b){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;}void adde(int a,int b){ad_de(a,b);ad_de(b,a);}\n#define Edgc int M=0,fst[SZ],vb[SZ],nxt[SZ],vc[SZ];void ad_de(int a,int b,int c){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;vc[M]=c;}void adde(int a,int b,int c){ad_de(a,b,c);ad_de(b,a,c);}\n#define es(x,e) (int e=fst[x];e;e=nxt[e])\n#define esb(x,e,b) (int e=fst[x],b=vb[e];e;e=nxt[e],b=vb[e])\nmap<int,bool> ps;\n#define SZ 2333 \nint n,x[SZ];\nvector<int> s[2];\n#define SZ 233333\nint M=1;typedef long long ll;\nint fst[SZ],nxt[SZ],vb[SZ],cap[SZ];\nvoid _ad_dl(int a,int b,int c) {++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;cap[M]=c;}\nvoid ad_dl(int a,int b,int c) {_ad_dl(a,b,c); _ad_dl(b,a,0);}\nint S,T,q[SZ],d[SZ];\nbool bfs()\n{\n    memset(d,-1,sizeof(d));\n    d[S]=0; q[1]=S; int h=1,t=2;\n    while(h!=t)\n    {\n        int cur=q[h++];\n        for(int e=fst[cur];e;e=nxt[e])\n        {\n            int b=vb[e];\n            if(d[b]==-1&&cap[e]) d[b]=d[cur]+1, q[t++]=b;\n        }\n    }\n    return d[T]!=-1;\n}\nint dfs(int x,int f)\n{\n    if(f<=0) return 0;\n    if(x==T) return f;\n    int ca=0;\n    for(int e=fst[x];e;e=nxt[e])\n    {\n        int b=vb[e];\n        if(d[b]!=d[x]+1) continue;\n        int w=dfs(b,min(cap[e],f-ca));\n        cap[e]-=w; cap[e^1]+=w; ca+=w;\n        if(ca==f) break;\n    }\n    if(!ca) d[x]=-1;\n    return ca;\n}\n#define inf 1000000000\nint dinic()\n{\n    int ans=0;\n    while(bfs()) ans+=dfs(S,inf);\n    return ans;\n}\nint N;\n#define SS 12345678\nbool npp[SS];\nint main()\n{\n\tnpp[1]=1;\n\tfor(int i=2;i*i<SS;++i) if(!npp[i])\n\t\tfor(int j=i*i;j<SS;j+=i) npp[j]=1;\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;++i)\t\n\t\tscanf(\"%d\",x+i),\n\t\tps[x[i]]^=1,ps[x[i]+1]^=1;\n\tfor(auto x:ps)\n\t\tif(x.se) s[x.fi&1].pb(x.fi);\n\tN=0; S=++N; T=++N;\n\tint a=N+1,b=N+1+s[0].size();\n\tfor(int i=0;i<s[0].size();++i)\n\t\tfor(int j=0;j<s[1].size();++j)\n\t\t\tif(!npp[abs(s[0][i]-s[1][i])])\n\t\t\t\tad_dl(a+i,b+j,1);\n\tfor(int i=0;i<s[0].size();++i)\n\t\tad_dl(S,a+i,1);\n\tfor(int i=0;i<s[1].size();++i)\n\t\tad_dl(b+i,T,1);\n\tint mx=dinic();\n\tint ans=mx+2*((s[0].size()-mx)/2+(s[1].size()-mx)/2)\n\t+3*((s[0].size()-mx)%2);\n\tprintf(\"%d\\n\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<cstring>\n\nusing namespace std;\nint n;\nconst int maxn = 1e7+5;//40M\nconst int S = 1e7+1;\nint pri[maxn],cnt; bool mk[maxn];\nint A[maxn];\nvoid oula() {\n\tmk[1] = mk[0] = 1;\n\tfor(int i=1;i<=S;i++) {\n\t\tif(!mk[i]) { pri[++cnt]=i; }\n\t\tfor(int j=1;j<=cnt&&1ll*pri[j]*i<=S;j++) {\n\t\t\tint k = pri[j]*i;\n\t\t\tmk[k] = 1;\n\t\t\tif(i%pri[j]==0) break;\n\t\t}\n\t}\n}\nint la[305],en[305*305],owo,nt[305*305];\nvoid adg(int x,int y) {\n\ten[++owo]=y; nt[owo]=la[x]; la[x]=owo;\n}\nint cc[2];\nint yo[2][305];\nint link[305],vis[305],vtm;\nbool hungary(int x,int tm) {\n\tvis[x] = tm;\n\tfor(int it=la[x];it;it=nt[it]) {\n\t\tint y = en[it];\n\t\tif(vis[y]==tm) continue;\n\t\tif((!link[y])||(hungary(link[y],tm))) {\n\t\t\tlink[y] = x; return 1;\n\t\t}\n\t}\n\treturn 0;\n}\nint main() {\n\toula();\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++) {\n\t\tint x; scanf(\"%d\",&x); A[x] = 1;\n\t}\n\tfor(int i=1;i<=S;i++) {\n\t\tint cf = A[i-1]^A[i];\n\t\tif(cf) {\n\t\t\t++cc[i&1];\n\t\t\tyo[i&1][cc[i&1]] = i;\n\t\t}\n\t}\n\tfor(int i=1;i<=cc[0];i++) {\n\t\tfor(int j=1;j<=cc[1];j++) {\n\t\t\tif(!mk[abs(yo[0][i]-yo[1][i])]) adg(i,j);\n\t\t}\n\t}\n\tint ans = 0;\n\tfor(int i=1;i<=cc[0];i++) {\n\t\tans += hungary(i,++vtm);\n\t}\n\tcc[0]-=ans; cc[1]-=ans;\n\tprintf(\"%d\",ans+cc[0]/2*2 + cc[1]/2*2 + (cc[0]&1)*3 );\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fi first\n#define se second\n#define pii pair<int,int>\n#define mp make_pair\n#define pb push_back\n#define space putchar(' ')\n#define enter putchar('\\n')\n#define MAXN 200005\n#define eps 1e-12\n//#define ivorysi\nusing namespace std;\ntypedef long long int64;\ntypedef unsigned int u32;\ntypedef double db;\ntemplate<class T>\nvoid read(T &res) {\n    res = 0;T f = 1;char c = getchar();\n    while(c < '0' || c > '9') {\n        if(c == '-') f = -1;\n        c = getchar();\n    }\n    while(c >= '0' && c <= '9') {\n        res = res * 10 + c - '0';\n        c = getchar();\n    }\n    res *= f;\n}\ntemplate<class T>\nvoid out(T x) {\n    if(x < 0) {x = -x;putchar('-');}\n    if(x >= 10) {\n        out(x / 10);\n    }\n    putchar('0' + x % 10);\n}\nint N;\nbool nonprime[10000005],vis[10000005];\nint prime[5000005],tot,x[205],b[205],M[2],matc[205];\nvector<int> to[505];\nbool used[205];\nbool match(int u) {\n    for(auto t : to[u]) {\n        if(!used[t]) {\n            used[t] = 1;\n            if(!matc[t] || match(matc[t])) {\n                matc[t] = u;\n                return true;\n            }\n        }\n    }\n    return false;\n}\nvoid Solve() {\n    read(N);\n    for(int i = 1 ; i <= N ; ++i) {\n        read(x[i]);\n        vis[x[i]] = 1;\n    }\n    for(int i = 2 ; i <= 10000000 ; ++i) {\n        if(!nonprime[i]) {\n            prime[++tot] = i;\n        }\n        for(int j = 1 ; j <= tot ; ++j) {\n            if(prime[j] > 10000000 / i) break;\n            nonprime[i * prime[j]] = 1;\n            if(i % prime[j] == 0) break;\n        }\n    }\n    tot = 0;\n    for(int i = 1 ; i <= 10000000 ; ++i) {\n        if(vis[i] != vis[i - 1]) b[++tot] = i;\n    }\n    for(int i = 1 ; i <= tot ; ++i) {\n        M[b[i] & 1]++;\n        for(int j = 1 ; j <= tot ; ++j) {\n            if(i == j) continue;\n            if(!nonprime[abs(b[i] - b[j])]) to[i].pb(j);\n        }\n    }\n    int ans = 0;\n    for(int i = 1 ; i <= tot ; ++i) {\n        if(b[i] & 1) {\n            memset(used,0,sizeof(used));\n            if(match(i)) ++ans;\n        }\n    }\n    out(ans + ((M[0] - ans) / 2 + (M[1] - ans) / 2) * 2 + ((M[0] - ans) & 1) * 3);enter;\n}\nint main() {\n#ifdef ivorysi\n\tfreopen(\"f1.in\",\"r\",stdin);\n#endif\n    Solve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <string>\n#include <iostream>\n#include <cmath>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <algorithm>\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\nconst ll INF=1e16;\nconst int MAX=1e7+5;\nbool isprime[MAX];\n \nvoid sieve(){\n\tfor(int i=3; i<MAX; i+=2){\n\t\tisprime[i]=1;\n\t}\n\tisprime[2]=1;\n\tfor(int i=3; i<MAX; i++){\n\t\tif(isprime[i]){\n\t\t\tfor(int j=2*i; j<MAX; j+=i){\n\t\t\t\tisprime[j]=0;\n\t\t\t}\n\t\t}\n\t}\n\treturn;\n}\n\nstruct edge {int to; long long int cap; int rev;} ;\n \nvector<edge> G[202];\nint level[202];\nint iter[202];\n \nvoid add_edge(int from, int to, long long int cap){\n\tedge e;\n\te.to=to, e.cap=cap, e.rev=G[to].size();\n\tG[from].push_back(e);\n\te.to=from, e.cap=0, e.rev=G[from].size()-1;\n\tG[to].push_back(e);\n}\n \nvoid bfs(int s){\n\tmemset(level, -1, sizeof(level));\n\tqueue<int> que;\n\tlevel[s]=0;\n\tque.push(s);\n\twhile(!que.empty()){\n\t\tint v=que.front();\n\t\tque.pop();\n\t\tfor(int i=0; i<G[v].size(); i++){\n\t\t\tedge e=G[v][i];\n\t\t\tif(e.cap>0 && level[e.to]<0){\n\t\t\t\tlevel[e.to]=level[v]+1;\n\t\t\t\tque.push(e.to);\n\t\t\t}\n\t\t}\n\t}\n}\n \nlong long int dfs(int v, int t, long long int f){\n\tif(v==t) return f;\n\tfor(int &i=iter[v]; i<G[v].size(); i++){\n\t\tedge &e=G[v][i];\n\t\tif(e.cap>0 && level[v]<level[e.to]){\n\t\t\tlong long int d=dfs(e.to, t, min(f, e.cap));\n\t\t\tif(d>0){\n\t\t\t\te.cap-=d;\n\t\t\t\tG[e.to][e.rev].cap+=d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n \nlong long int max_flow(int s, int t){\n\tlong long int flow=0;\n\twhile(1){\n\t\tbfs(s);\n\t\tif(level[t]<0) return flow;\n\t\tmemset(iter, 0, sizeof(iter));\n\t\tlong long int f;\n\t\twhile((f=dfs(s, t, INF))>0){\n\t\t\tflow+=f;\n\t\t}\n\t}\n}\n\nint main()\n{\n\tsieve();\n  int n; cin>>n;\n  set<int> x[2];\n  for(int i=0; i<n; i++){\n    int x0;\n    cin>>x0;\n    auto itr1=x[x0%2].find(x0);\n    if(itr1!=x[x0%2].end()){\n      x[x0%2].erase(itr1);\n    }else{\n      x[x0%2].insert(x0);\n    }\n    x0++;\n    auto itr2=x[x0%2].find(x0);\n    if(itr2!=x[x0%2].end()){\n      x[x0%2].erase(itr2);\n    }else{\n      x[x0%2].insert(x0);\n    }\n  }\n  vector<int> v[2];\n  for(int i=0; i<2; i++){\n    for(auto x0:x[i]){\n      v[i].push_back(x0);\n    }\n  }\n  int c[2];\n  c[0]=v[0].size(); c[1]=v[1].size();\n  int V=c[0]+c[1]+2;\n  for(int i=0; i<c[0]; i++){\n    add_edge(V-2, i, 1ll);\n  }\n  for(int i=0; i<c[1]; i++){\n    add_edge(i+c[0], V-1, 1ll);\n  }\n  for(int i=0; i<c[0]; i++){\n    for(int j=0; j<c[1]; j++){\n      if(isprime[abs(v[0][i]-v[1][j])]){\n        add_edge(i, c[0]+j, 1ll);\n      }\n    }\n  }\n  int m=(int)max_flow(V-2, V-1);\n  if((c[0]-m)%2==0){\n    cout<<c[0]-m+c[1]<<endl;\n  }else{\n    cout<<c[0]-m+c[1]+1<<endl;\n  }\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define fi first\n#define se second\n#define mp make_pair\n#define gc getchar\n#define pb push_back\n#define eb emplace_back\n#define all(x) (x).begin(),(x).end()\n#define x1 uvuvwevwevwe\n#define y1 onyetenyevwe\n#define x2 ugwemubwem\n#define y2 ossas\ntypedef long long LL;\ntypedef long double LD;\ntypedef pair<int,int> pii;\nconst int batasprima=5000;\ntemplate <typename T> void scan(T &angka){\n\tangka=0;char input=gc();T kali=1;\n\twhile(!(48<=input&&input<=57)){\tif(input=='-')\tkali=-1;input=gc();}\n\twhile(48<=input&&input<=57)\tangka=(angka<<3)+(angka<<1)+input-48,input=gc();angka*=kali;\n}\ntemplate <typename T1,typename T2> void scan(T1 &angka1,T2 &angka2){\n\tscan(angka1);scan(angka2);\n}\nint match[205],k,ans;\nvector <int> daftar,adj[205],prime;\nbitset<205> visited;\nvoid sieve(){\n\tbool isprime[batasprima+5];\n\tmemset(isprime,true,sizeof(isprime));\n\tfor(int i=2;i<=batasprima;i++)\n\t{\n\t\tif(!isprime[i])\n\t\t\tcontinue;\n\t\tprime.pb(i);\n\t\tfor(int j=i+i;j<=batasprima;j+=i)\n\t\t\tisprime[j]=false;\n\t}\n}\nbool isprime(int angka){\n\tif(angka<=2)\n\t\treturn false;\n\tfor(auto isi:prime)\n\t{\n\t\tif(angka%isi==0&&angka!=isi)\n\t\t\treturn false;\n\t}\n\treturn true;\n}\nbool matching(int pos){\n\tif(visited[pos])\n\t\treturn false;\n\tvisited[pos]=true;\n\tfor(auto isi:adj[pos])\n\t{\n\t\tif(match[isi]==-1||matching(match[isi]))\n\t\t{\n\t\t\tmatch[isi]=pos;\n\t\t\tmatch[pos]=isi;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\nvoid buatgraph(){\t\n\tfor(int i=0;i<daftar.size();i++)\n\t{\n\t\tfor(int j=0;j<daftar.size();j++)\n\t\t{\n\t\t\tif(isprime(abs(daftar[i]-daftar[j])))\n\t\t\t\tadj[i].pb(j);\n\t\t}\n\t}\n}\nvoid hitungk(){\n\tk=0;\n\tmemset(match,-1,sizeof(match));\n\tfor(int i=0;i<daftar.size();i++)\n\t{\n\t\tif(match[i]!=-1)\n\t\t\tcontinue;\n\t\tvisited.reset();\n\t\tif(matching(i))\n\t\t\tk++;\n\t}\n}\nvoid hitungans(){\n\tint genap=0,ganjil=0;\n\tfor(auto isi:daftar)\n\t{\n\t\tif(isi&1)\n\t\t\tganjil++;\n\t\telse\n\t\t\tgenap++;\n\t}\n\tassert(ganjil>=k&&genap>=k);\n\tassert(ganjil%2==genap%2);\n\tans=k+((ganjil-k)/2+(genap-k)/2)*2+((ganjil-k)%2)*3;\n}\nvoid isidaftar(){\n\tint n,tadi=0;\n\tscan(n);\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tint input;\n\t\tscan(input);\n\t\tassert(tadi<input);\n\t\ttadi=input;\n\t\tif(daftar.size()&&daftar.back()==input)\n\t\t\tdaftar[daftar.size()-1]=input+1;\t\t\t//nanti mau sa coba\n\t\telse\n\t\t\tdaftar.pb(input),daftar.pb(input+1);\n\t}\n\tassert(daftar.size()<=200);\n}\nint main()\n{\n\tsieve();\n\tisidaftar();\n\tbuatgraph();\n\thitungk();\n\thitungans();\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstring>\n#include <cstdio>\nint a[205],fst[205],match[205],p[1000000],tot=0;\nbool u[10000005],vis[205];\nstruct Edge{int to,nxt;}e[10005];\nvoid addedge(int x,int y){\n\te[++tot].to=y;e[tot].nxt=fst[x];fst[x]=tot;\n}\nvoid init(int n){\n\tfor (int i=2;i<=n;i++){\n\t\tif (!u[i]) p[++p[0]]=i;\n\t\tfor (int j=1;j<=p[0] && i*p[j]<=n;j++){\n\t\t\tu[i*p[j]]=1;\n\t\t\tif (i%p[j]==0) break;\n\t\t}\n\t}\n\tu[0]=u[1]=u[2]=1;\n}\nbool dfs(int x){\n\tvis[x]=1;\n\tfor (int i=fst[x];i;i=e[i].nxt){\n\t\tint y=e[i].to;\n\t\tif (!match[y] || dfs(match[y])){\n\t\t\tmatch[y]=x;\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\nint main(){\n\tint n,m=0;\n\tscanf(\"%d\\n\",&n);\n\tfor (int i=1;i<=n;i++){\n\t\tint x;scanf(\"%d\",&x);\n\t\tif (a[m]==x) m--;else a[++m]=x;\n\t\ta[++m]=x+1;\n\t}\n\tinit(a[m]-a[1]);\n\tfor (int i=1;i<=m;i++)\n\tif (a[i]&1)\n\t\tfor (int j=1;j<=m;j++)\n\t\tif (!u[abs(a[i]-a[j])]) addedge(i,j);\n\tint ans=0,cnt=0;\n\tfor (int i=1;i<=m;i++)\n\tif (a[i]&1){\n\t\tmemset(vis,0,sizeof vis);\n\t\tif (dfs(i)) ans++;else cnt++;\n\t}\n\tprintf(\"%d\\n\",m-ans+(cnt&1));\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\nint n;\nvector<int>vi,vecc,vec[2];\nint O,E;\nstruct edge\n{\n\tint to,cap,rev;\n};\nvector<edge>G[105];\nbool used[105];\n\nvoid add_edge(int from,int to,int cap)\n{\n\tG[from].push_back((edge){to,cap,G[to].size()});\n\tG[to].push_back((edge){from,0,G[from].size()-1});\n}\nint dfs(int v,int t,int f)\n{ \n\tif(v==t) return f;\n\tused[v]=true;\n\tfor(int i=0;i<G[v].size();i++)\n\t{\n\t\tedge &e=G[v][i];\n\t\tif(!used[e.to] && e.cap>0)\n\t\t{ \n\t\t\tint d=dfs(e.to,t,min(f,e.cap));\n\t\t\tif(d>0) \n\t\t\t{ \n\t\t\t\te.cap-=d;\n\t\t\t\tG[e.to][e.rev].cap+=d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nint max_flow(int s,int t)\n{ \n\tint flow=0;\n\twhile(1)\n\t{ \n\t\tmemset(used,0,sizeof(used));\n\t\tint f=dfs(s,t,INF);\n\t\tif(!f) return flow;\n\t\tflow+=f;\n\t}\n}\nbool f(int v){\n\tfor(int i=2;i*i<=v;i++) if(v%i==0) return 0;\n\treturn 1;\n}\nint main(){\n\tcin >> n;\n\tfor(int i=0;i<n;i++){\n\t\tint a; cin >> a; vi.pb(a);\n\t\tif(i==0 || vi[i-1]+1 != vi[i]){\n\t\t\tvecc.pb(a);\n\t\t}\n\t\tif(i && vi[i-1]+1 != vi[i]){\n\t\t\tvecc.pb(vi[i-1]+1);\n\t\t}\n\t\tif(i==n-1){\n\t\t\tvecc.pb(vi[i]+1);\n\t\t}\n\t}\n\tfor(int i=0;i<vecc.size();i++){\n\t\tvec[vecc[i]%2].pb(vecc[i]);\n\t}\n\tO = vec[1].size(),E = vec[0].size();\n\tfor(int i=0;i<O;i++) add_edge(103,i,1);\n\tfor(int i=0;i<E;i++) add_edge(O+i,104,1);\n\tfor(int i=0;i<O;i++){\n\t\tfor(int j=0;j<E;j++){\n\t\t\tint x = abs(vec[1][i]-vec[0][j]);\n\t\t\tif(x>=3 && f(x)) add_edge(i,O+j,1);\n\t\t}\n\t}\n\tint ans = max_flow(103,104);\n\tO-=ans; E-=ans;\n\tif( (O%2) + (E%2) == 2) ans += O+E+1;\n\telse ans += O+E;\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(3)\n#include<iostream>\n#include<iomanip>\n#include<stack>\n#include<queue>\n#include<list>\n#include<vector>\n#include<set> \n#include<map>\n#include<string>\n#include<algorithm>\n#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<ctime>\n#define ll long long\n#define db double\n#define inf 10000001\n#define infm 50001\n#define INF (int)1e8 \n#define mod (int)(1e9+7)\n#define pi acos(-1)\n#define rd(n) {n=0;char ch;int f=0;do{ch=getchar();if(ch=='-'){f=1;}}while(ch<'0'||ch>'9');while('0'<=ch&&ch<='9'){n=(n<<1)+(n<<3)+ch-48;ch=getchar();}if(f)n=-n;}\nusing namespace std;\n\nint p[inf],ckp[inf],pcnt;\nconst int lim=10000000;\n\nvoid pre_work(void){\n    ckp[0]=ckp[1]=1;\n    for (int i=2;i<=lim;i++){\n        if (!ckp[i]){\n            p[++pcnt]=i;\n        }\n        for (int j=1;j<=pcnt && p[j]*i<=lim;j++){\n            ckp[p[j]*i]=1;\n            if (i%p[j]==0){\n                break;\n            }\n        }\n    }\n    return;\n}\n\nint S,T;\n\nstruct edge{\n    int nxt,y,s;\n}e[infm*2];\nint ecnt=1,head[infm],h[infm];\n\nvoid addedge(int x,int y,int s){\n    ecnt++;\n    e[ecnt].nxt=head[x];\n    e[ecnt].y=y;\n    e[ecnt].s=s;\n    head[x]=ecnt;\n    return;\n}\n\nvoid ae(int x,int y,int s){\n    addedge(x,y,s);\n    addedge(y,x,0);\n    return;\n}\n\nqueue <int> q;\nint dep[inf];\n\nint dfs(int u,int flow){\n    if (!flow || u==T){\n        return flow;\n    }\n    int ans=0;\n    for (int i=h[u];i;i=e[i].nxt){\n        h[u]=i;\n        int v=e[i].y,s=e[i].s,now;\n        if (dep[v]!=dep[u]+1){\n            continue;\n        }\n        now=dfs(v,min(flow,s));\n        if (now){\n            ans+=now;\n            flow-=now;\n            e[i].s-=now;\n            e[i^1].s+=now;\n            if (!flow){\n                break;\n            }\n        }\n    }\n    return ans;\n}\n\nint dinic(void){\n    int ans=0;\n    while (1){\n        while (!q.empty()){\n            q.pop();\n        }\n        memcpy(h,head,sizeof(head));\n        memset(dep,-1,sizeof(dep));\n        dep[S]=0;\n        q.push(S);\n        while (!q.empty()){\n            int u=q.front(),v,s;\n            q.pop();\n            for (int i=head[u];i;i=e[i].nxt){\n                v=e[i].y,s=e[i].s;\n                if (dep[v]<0 && s){\n                    dep[v]=dep[u]+1;\n                    q.push(v);\n                }\n            }\n        }\n        if (dep[T]<0){\n            break;\n        }\n        ans+=dfs(S,INF);\n    }\n    return ans;\n}\n\nint n;\nint a[inf];\nint L[inf],R[inf];\n\nint main(){\n    pre_work();\n    rd(n)\n    int x,mx=0;\n    for (int i=1;i<=n;i++){\n        rd(x)\n        a[x]++;\n        mx=max(mx,x);\n    }\n    int cntl=0,cntr=0;\n    for (int i=1;i<=mx+1;i++){\n        if (a[i]!=a[i-1]){\n            if (i&1){\n                L[++cntl]=i;\n            }\n            else{\n                R[++cntr]=i;\n            }\n        }\n    }\n    S=0,T=cntl+cntr+1;\n    for (int i=1;i<=cntl;i++){\n        ae(S,i,1);\n    }\n    for (int i=1;i<=cntr;i++){\n        ae(i+cntl,T,1);\n    }\n    for (int i=1;i<=cntl;i++){\n        for (int j=1;j<=cntr;j++){\n            if (!ckp[abs(L[i]-R[j])]){\n                ae(i,j+cntl,1);\n            }\n        }\n    }\n    int mxf=dinic();\n    int ans=mxf;\n    ans+=(cntl-mxf)/2*2+(cntr-mxf)/2*2;\n    ans+=((cntl-mxf)&1)*3;\n    printf(\"%d\\n\",ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define forn(i, n) for (llong i = 0ll; i < (llong) n; ++i)\n#define fornn(i, l, r) for (llong i = (llong) l; i < (llong) r; ++i)\n#define size(x) ((int) (x.size()))\n \nusing namespace std;\n \ntypedef long long llong;\nconst llong inf = (llong) 1e+9 + 7ll;\nconst llong linf = (llong) 1e+18 + 7ll;\nconst long double eps = (long double) 1e-9;\nconst long double pi = acosl((long double) -1.0);\nconst int alph = 26;\n\nmt19937 mrand(random_device{} ()); \n\ntemplate<typename T, typename U> inline llong umin(const T& a, const U& b) { return a < b ? a : b; }\ntemplate<typename T, typename U> inline llong umax(const T& a, const U& b) { return a > b ? a : b; }\n \nstatic char buff[(int) 2e6 + 17]; // reads std::string\nconst int maxn = (int) 1e7 + 17;\n\nint n;\nint a[200], mt[200];\nvector<int> g[200];\nbool pr[maxn], used[200];\n\nbool read()\n{\n\tif (scanf(\"%d\", &n) != 1)\n\t\treturn false;\n\n\tforn (i, n)\n\t\tscanf(\"%d\", a + i);\n\n\treturn true;\n}\n\nbool dfs(int v)\n{\n\tif (used[v])\n\t\treturn false;\n\n\tused[v] = true;\n\n\tfor (auto to : g[v])\n\t\tif (mt[to] == -1 || dfs(mt[to]))\n\t\t\treturn mt[to] = v, true;\n\n\treturn false;\n}\n\nvoid solve()\n{\n\tfor (int i = 2; i < maxn; ++i)\n\t\tpr[i] = true;\n\n\tfor (int i = 2; i < maxn; ++i)\n\t\tif (pr[i] && 1ll * i * i < maxn)\n\t\t\tfor (int j = i * i; j < maxn; j += i)\n\t\t\t\tpr[j] = false;\n\n\tpr[2] = false;\n\tset<int> s;\n\n\tfor (int i = 0; i < n; ++i)\n\t{\n\t\tif (s.count(a[i]))\n\t\t\ts.erase(a[i]);\n\t\telse\n\t\t\ts.insert(a[i]);\n\n\t\ts.insert(a[i] + 1);\n\t}\n\n\tvector<int> v0, v1;\n\n\tfor (auto i : s)\n\t\t(i % 2 == 0) ? v0.push_back(i) : v1.push_back(i);\n\n\tfor (int i = 0; i < size(v0); ++i)\n\t\tfor (int j = 0; j < size(v1); ++j)\n\t\t\tif (pr[abs(v0[i] - v1[j])])\n\t\t\t\tg[i].push_back(j);\n\n\tmemset(mt, -1, sizeof(mt));\n\n\tfor (int i = 0; i < size(v0); ++i)\n\t{\n\t\tmemset(used, false, sizeof(used));\n\t\tdfs(i);\n\t}\n\n\tint matching = 0;\n\n\tfor (int i = 0; i < size(v1); ++i)\n\t\tmatching += mt[i] != -1;\n\n\tint ans = matching;\n\tans += 2 * ((size(v0) - matching) / 2);\n\tans += 2 * ((size(v1) - matching) / 2);\n\tans += 3 * ((size(v0) - matching) % 2);\n\tprintf(\"%d\\n\", ans);\n}\n\nint main()\n{\n#if SEREZHKA\n\tfreopen(\"file.in\", \"r\", stdin);\n#endif\n\n\twhile (read())\n\t\tsolve();\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <cmath>\n#include <cstring>\n#define N 1000006\n#define M 10000007\n\nusing namespace std;\n\nstruct edge{\n\tint to, nxt;\n}e[N];\n\nint n, cnt, tot, numx, numy;\nint fir[N], a[N], b[N], prime[M], link[N], x[N], y[N];\nbool vis[M], book[N];\n\nvoid init();\nvoid add(int ,int);\nbool dfs(int);\n\nint main(){\n\tscanf(\"%d\", &n);init();\n\tfor(int i = 1; i <= n; ++i)\n\t\tscanf(\"%d\", a + i);\n\tsort(a + 1,a + 1 + n);a[0] = a[n + 1] = 99999999;\n\tfor(int i = 1; i <= n; ++i){\n\t\tif(a[i] != a[i - 1] + 1) b[++cnt] = a[i];\n\t\tif(a[i] != a[i + 1] - 1) b[++cnt] = a[i] + 1;\n\t}\n\tfor(int i = 1; i <= cnt; ++i){\n\t\tif(b[i] & 1) x[++numx] = b[i];\n\t\telse y[++numy] = b[i];\n\t}\n\tcnt = 0;\n\tfor(int i = 1; i <= numx; ++i)\n\t\tfor(int j = 1; j <= numy; ++j)\n\t\t\tif(!vis[abs(x[i] - y[j])])\n\t\t\t\tadd(i, j);\n\tfor(int i = 1; i <= numx; ++i)\n\t\tif(!link[i]){\n\t\t\tmemset(book, false, sizeof book);\n\t\t\tdfs(i);\n\t\t}\n\tint ans = 0;\n\tfor(int i = 1; i <= numy; ++i)\n\t\tif(link[i]) --numy, --numx, ++ans;\n\tans += (numy / 2) * 2 + (numx / 2) * 2;\n\tans += (numy % 2) * (numx % 2) * 3;\n\tcout << ans << endl;\n\treturn 0;\n}\n\nvoid add(int u,int v){\n\te[++cnt].to = v;e[cnt].nxt = fir[u];fir[u] = cnt;\n\treturn ;\n}\n\nvoid init(){\n\tint m = 1e7;\n\tfor(int i = 2; i <= m; ++i){\n\t\tif(!vis[i]) prime[++tot] = i;\n\t\tfor(int j = 1; j <= tot && i * prime[j] <= m; ++j){\n\t\t\tvis[i * prime[j]] = true;\n\t\t\tif(i % prime[j] == 0) break;\n\t\t}\n\t}\n\tvis[2] = true;\n\treturn ;\n}\n\nbool dfs(int u){\n\tif(book[u]) return false;\n\tbook[u] = true;\n\tfor(int i = fir[u]; i; i = e[i].nxt){\n\t\tint v = e[i].to;\n\t\tif(!link[v] || dfs(link[v])){\n\t\t\tlink[v] = u;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <unordered_map>\n#include <unordered_set>\n#include <utility>\n#include <vector>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> PP;\n\n// This code performs maximum bipartite matching.\n//\n// Running time: O(|E| |V|) -- often much faster in practice\n//\n//   INPUT: w[i][j] = edge between row node i and column node j\n//   OUTPUT: mr[i] = assignment for row node i, -1 if unassigned\n//           mc[j] = assignment for column node j, -1 if unassigned\n//           function returns number of matches made\n\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\n\nbool FindMatch(int i, const VVI &w, VI &mr, VI &mc, VI &seen) {\n  for (int j = 0; j < w[i].size(); j++) {\n    if (w[i][j] && !seen[j]) {\n      seen[j] = true;\n      if (mc[j] < 0 || FindMatch(mc[j], w, mr, mc, seen)) {\n        mr[i] = j;\n        mc[j] = i;\n        return true;\n      }\n    }\n  }\n  return false;\n}\n\nint BipartiteMatching(const VVI &w) {\n  VI mr = VI(w.size(), -1);\n  VI mc = VI(w[0].size(), -1);\n  \n  int ct = 0;\n  for (int i = 0; i < w.size(); i++) {\n    VI seen(w[0].size());\n    if (FindMatch(i, w, mr, mc, seen)) ct++;\n  }\n  return ct;\n}\n\nset<int> P;\nconst int B = 1E7 + 10;\nbool sieve[B];\n\nint main() {\n    ios::sync_with_stdio(false);\n    int N;\n    cin >> N;\n    set<int> M;\n    for (int i = 0;i < N;i++) {\n    \tint n;\n    \tcin >> n;\n    \tM.insert(n);\n    }\n    memset(sieve, 0, sizeof(sieve));\n    for (int i = 2;i < B;i++) {\n    \tif (sieve[i] == 0) {\n    \t\tfor (int j = i;j < B;j += i) sieve[j] = 1;\n    \t\tif (i % 2) P.insert(i);\n    \t}\n    }\n    set<int> Q;\n    for (auto m : M) {\n    \tif (M.count(m - 1) == 0) Q.insert(m - 1);\n    \tif (M.count(m + 1) == 0) Q.insert(m);\n    }\n    vector<int> R;\n    for (auto m : Q) R.push_back(m);\n    int sz = R.size();\n    vector<int> tmp(sz, 0);\n    vector<vector<int> > T(sz, tmp);\n    int o = 0, e = 0;\n    for (int i = 0;i < sz;i++) {\n    \tif (R[i] % 2) o++;\n    \telse e++;\n    \tfor (int j = i + 1;j < sz;j++) {\n    \t\tif (P.count(abs(R[i] - R[j]))) {\n    \t\t\tT[i][j] = 1;\n    \t\t}\n    \t}\n    }\n    int mc = BipartiteMatching(T);\n    o -= mc;\n    e -= mc;\n    cout << mc + 2 * (o / 2 + e / 2) + 3 * (o % 2) << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n#include <utility>\n#include <cstdlib>\n#include <memory>\n#include <queue>\n#include <cassert>\n#include <cmath>\n#include <ctime>\n#include <complex>\n#include <bitset>\n#include <fstream>\n#include <unordered_map>\n#include <unordered_set>\n#include <numeric>\n\nusing namespace std;\n\n#define ws ws_____________________\n#define y1 y1_____________________\n#define y0 y0_____________________\n#define left left_________________\n#define right right_______________\n#define next next_________________\n#define prev prev_________________\n#define hash hash_________________\n\n#define pb push_back\n#define fst first\n#define snd second\n#define mp make_pair \n#define sz(C) ((int) (C).size())\n#define forn(i, n) for (int i = 0; i < int(n); ++i)\n#define ford(i, n) for (int i = int(n) - 1; i >= 0; --i)\n#define all(C) begin(C), end(C)\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef unsigned int uint;\ntypedef pair<int,int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<ll> vll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vii;\ntypedef long double ld;\ntypedef complex<double> cd;\n\n#ifdef LOCAL\n#define eprintf(args...) fprintf(stderr, args), fflush(stderr)\n#else\n#define eprintf(...) ;\n#endif\n\n#define FILE_NAME \"a\"\n\n\nint n;\nvi xs;\n\nbool read() {\n\tif  (scanf(\"%d\", &n) < 1) {\n\t\treturn 0;\n\t}\n\txs.resize(n);\n\tforn(i, n) {\n\t\tscanf(\"%d\", &xs[i]);\n\t}\n\treturn 1;\n}\n\nconst int MAX = 1e7 + 10;\n\nint A[MAX];\nint B[MAX];\nbool prime[MAX];\n\nstruct Graph {\n\tvvi g;\n\tvi mt;\n\tvi used;\n\tint n, m;\n\n\tGraph() = default;\n\n\tGraph(int n, int m) : n(n), m(m) {\n\t\tg.resize(n);\n\t}\n\n\tvoid addE(int v, int to) {\n\t\tg[v].pb(to);\n\t} \n\n\tbool dfs(int v) {\n\t\tif  (used[v]) {\n\t\t\treturn 0;\n\t\t}\n\t\tfor (int to : g[v]) {\n\t\t\tif  (mt[to] == -1 || dfs(mt[to])) {\n\t\t\t\tmt[to] = v;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t\tused[v] = 1;\n\t\treturn 0;\n\t}\n\n\tvii getMatch() {\n\t\tmt.assign(m, -1);\n\t\tforn(v, n) {\n\t\t\tused.assign(n, 0);\n\t\t\tdfs(v);\n\t\t}\n\n\t\tvii res;\n\t\tforn(i, m) {\n\t\t\tif  (mt[i] != -1) {\n\t\t\t\tres.pb(mp(mt[i], i));\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n};\n\nint calc() {\n\tvi vals;\n\tforn(i, MAX) {\n\t\tif  (B[i]) {\n\t\t\tvals.pb(i);\n\t\t}\n\t}\n\n\tsort(all(vals));\n\teprintf(\"vals:\\n\");\n\tfor (int val : vals) {\n\t\teprintf(\"%d \", val);\n\t}\n\teprintf(\"\\n\");\n\n\tassert(sz(vals) % 2 == 0);\n\n\tvi odd;\n\tvi even;\n\tfor (int val : vals) {\n\t\tif  (val & 1) {\n\t\t\todd.pb(val);\n\t\t} else {\n\t\t\teven.pb(val);\n\t\t}\n\t}\n\n\tGraph g(sz(odd), sz(even));\n\tforn(i, sz(odd)) {\n\t\tforn(j, sz(even)) {\n\t\t\tconst int p = abs(odd[i] - even[j]);\n\t\t\tif  (p >= 3 && prime[p]) {\n\t\t\t\tg.addE(i, j);\n\t\t\t}\n\t\t}\n\t}\n\n\tvii match = g.getMatch();\n\tint ans = sz(match);\n\n\tint cnt_even = sz(even) - sz(match);\n\tint cnt_odd = sz(odd) - sz(match);\n\n\tans += 2 * (cnt_even / 2);\n\tcnt_even %= 2;\n\n\tans += 2 * (cnt_odd / 2);\n\tcnt_odd %= 2;\n\n\tassert(cnt_odd == cnt_even);\n\tif  (cnt_even) {\n\t\tans += 3;\n\t}\n\n\treturn ans;\n}\n\nint solve() {\n\tmemset (prime, true, sizeof prime);\n\tfor (int i = 2; i < MAX; ++i) {\n\t\tif  (prime[i]) {\n\t\t\tfor (int j = i + i; j < MAX; j += i) {\n\t\t\t\tprime[j] = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tmemset (A, 0, sizeof A);\n\tfor (int x : xs) {\n\t\tA[x] ^= 1;\n\t}\n\n\tmemset (B, 0, sizeof B);\n\tforn(i, MAX) {\n\t\tB[i] = A[i] ^ A[i + 1];\n\t}\n\n\tint ans = calc();\n\treturn ans;\n}\n\nint main() {\n#ifdef LOCAL\n\tfreopen(FILE_NAME \".in\", \"r\", stdin);\n\t// freopen(FILE_NAME \".out\", \"w\", stdout);\n#endif\n\n\twhile (read()) {\n\t\tprintf(\"%d\\n\", solve());\n\t}\n\n#ifdef LOCAL\n\tcerr.precision(5);\n\tcerr << \"Time: \" << fixed << (double) clock() / CLOCKS_PER_SEC << endl;\n#endif\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <set>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <cmath>\n#include <vector>\n#include <bitset>\n#include <cstdio>\n#include <cctype>\n#include <string>\n#include <numeric>\n#include <cstring>\n#include <cassert>\n#include <climits>\n#include <cstdlib>\n#include <iostream>\n#include <algorithm>\n#include <functional>\nusing namespace std ;\n#define int long long\n#define rep(i, a, b) for (ll i = (a); i <= (b); ++i)\n#define per(i, a, b) for (ll i = (a); i >= (b); --i)\n#define loop(it, v) for (auto it = v.begin(); it != v.end(); it++)\n#define cont(i, x) for (ll i = head[x]; i; i = edge[i].nex)\n#define clr(a) memset(a, 0, sizeof(a))\n#define ass(a, cnt) memset(a, cnt, sizeof(a))\n#define cop(a, b) memcpy(a, b, sizeof(a))\n#define lowbit(x) (x & -x)\n#define all(x) x.begin(), x.end()\n#define SC(t, x) static_cast <t> (x)\n#define ub upper_bound\n#define lb lower_bound\n#define pqueue priority_queue\n#define mp make_pair\n#define pb push_back\n#define pof pop_front\n#define pob pop_back\n#define fi first\n#define se second\n#define y1 y1_\n#define Pi acos(-1.0)\n#define iv inline void\n#define enter putchar('\\n')\n#define siz(x) ((ll)x.size())\n#define file(x) freopen(x\".in\", \"r\", stdin),freopen(x\".out\", \"w\", stdout)\ntypedef double db ;\ntypedef long long ll ;\ntypedef unsigned long long ull ;\ntypedef pair <ll, ll> pii ;\ntypedef vector <ll> vi ;\ntypedef vector <pii> vii ;\ntypedef queue <ll> qi ;\ntypedef queue <pii> qii ;\ntypedef set <ll> si ;\ntypedef map <ll, ll> mii ;\ntypedef map <string, ll> msi ;\nconst ll maxn = 2e6 + 100 ;\nconst ll inf = 0x3f3f3f3f ;\nconst ll iinf = 1 << 30 ;\nconst ll linf = 2e18 ;\nconst ll mod = 998244353 ;\nconst double eps = 1e-7 ;\ntemplate <class T = ll> T chmin(T &a, T b) { return a = min(a, b);}\ntemplate <class T = ll> T chmax(T &a, T b) { return a = max(a, b);}\ntemplate <class T = ll> T read()\n{\n\tT f = 1, a = 0;\n\tchar ch = getchar() ;\n\twhile (!isdigit(ch)) { if (ch == '-') f = -1 ; ch = getchar() ; }\n\twhile (isdigit(ch)) { a =  (a << 3) + (a << 1) + ch - '0' ; ch = getchar() ; }\n\treturn a * f ;\n}\n\nll n, ans;\n\nll a[maxn], b[maxn], tot;\n\nsi s;\n\nvi edge[maxn];\n\nbool is_prime(ll x)\n{\n\tif(x == 2) return 0;\n\trep(i, 2, sqrt(x)) if(x % i == 0) return 0;\n\treturn 1;\n}\n\nll col[maxn];\n\nvoid paint(ll now, ll x)\n{\n\tif(col[now]) return ;\n\tcol[now] = x;\n\tif(x == 1) \n\tfor(ll to : edge[now]) paint(to, x ^ 3);\n}\n\nll match[maxn], vis[maxn];\n\nll dfs(ll now)\n{\n\tfor(ll to : edge[now])\n\t{\n\t\tif(vis[to]) continue;\n\t\tvis[to] = 1;\n\t\tif(!match[to] || dfs(match[to]))\n\t\t{\n\t\t\tmatch[now] = to, match[to] = now;\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nvoid hungarian()\n{\n\trep(i, 1, tot)\n\t{\n\t\tif(col[i] == 2) continue;\n\t\trep(j, 1, tot) vis[j] = 0;\n\t\tans += dfs(i);\n\t}\n}\n\nll odd, even;\n\nsigned main()\n{\n\tn = read();\n\trep(i, 1, n) a[i] = read();\n\ta[0] = -114514;\n\tsort(a + 1, a + n + 1);\n\trep(i, 1, n)\n\t{\n\t\tif(a[i - 1] != a[i] - 1) s.insert(i);\n\t\tif(a[i + 1] != a[i] + 1) s.insert(i + 1);\n\t}\n\tfor(ll i : s) b[++ tot] = i;//, printf(\"%lld \", i);\n\t// enter;\n\trep(i, 1, tot) rep(j, i + 1, tot) if(is_prime(b[j] - b[i])) edge[i].pb(j), edge[j].pb(i);//, printf(\"%lld -> %lld\\n\", i, j);\n\trep(i, 1, tot) if(!col[i]) paint(i, 1);\n\thungarian();\n\trep(i, 1, tot)\n\t{\n\t\tif(match[i]) continue;\n\t\tif(b[i] & 1) odd ++;\n\t\telse even ++;\n\t}\n\tans += odd / 2 * 2, ans += even / 2 * 2;\n\tif(odd & 1) ans += 3;\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define maxn 210\n#define maxm 10000010\nconst int lim=1e7;\ntemplate <typename T>inline T read()\n{\n    register T sum=0;\n    register char cc=getchar();\n    int sym=1;\n    while(cc!='-'&&(cc>'9'||cc<'0'))cc=getchar();\n    if(cc=='-')sym=-1,cc=getchar();\n    sum=sum*10+cc-'0';\n    cc=getchar();\n    while(cc>='0'&&cc<='9')sum=sum*10+cc-'0',cc=getchar();\n    return sym*sum;\n}\ntemplate <typename T>inline T read(T &a)\n{\n    a=read<T>();\n    return a;\n}\ntemplate <typename T,typename... Others> inline void read(T& a, Others&... b)\n{\n    a=read(a);\n\tread(b...);\n}\nstruct Edge\n{\n\tint v;\n\tEdge *next;\n\tEdge(int a=0,Edge *b=NULL)\n\t{\n\t\tv=a;\n\t\tnext=b;\n\t}\n}*head[maxn];\nint n,mx,tim,cnt,cnt1,cnt2,ans,maxflow,a[maxm];\nint L[maxn],R[maxn],p[maxm],vis[maxm],match[maxn];\nbool Match(int k)\n{\n\tfor(Edge *i=head[k];i!=NULL;i=i->next)\n\t{\n\t\tif(vis[i->v]==tim)\n\t\t\tcontinue;\n\t\tvis[i->v]=tim;\n\t\tif(!match[i->v]||Match(match[i->v]))\n\t\t{\n\t\t\tmatch[i->v]=k;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\nvoid init()\n{\n\tvis[0]=vis[1]=true;\n\tfor(int i=2;i<=lim;i++)\n\t{\n\t\tif(!vis[i])\n\t\t\tp[++cnt]=i;\n\t\tfor(int j=1;j<=cnt&&p[j]*i<=lim;j++)\n\t\t{\n\t\t\tvis[i*p[j]]=true;\n\t\t\tif(i%p[j]==0)\n\t\t\t\tbreak;\n\t\t}\n\t}\n}\nint main()\n{\n\tinit();\n\tread(n);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint x;\n\t\tread(x);\n\t\ta[x]+=1;\n\t\tmx=max(mx,x);\n\t}\n\tfor(int i=1;i<=mx+1;i++)\n\t{\n\t\tif(a[i]!=a[i-1])\n\t\t{\n\t\t\tif(i&1)\n\t\t\t\tL[++cnt1]=i;\n\t\t\telse\n\t\t\t\tR[++cnt2]=i;\n\t\t}\n\t}\n\tfor(int i=1;i<=cnt1;i++)\n\t\tfor(int j=1;j<=cnt2;j++)\n\t\t\tif(!vis[abs(L[i]-R[j])])\n\t\t\t\thead[i]=new Edge(j,head[i]);\n\tfor(int i=1;i<=cnt1;i++)\n\t{\n\t\ttim+=1;\n\t\tmaxflow+=Match(i);\n\t}\n\tans=maxflow;\n\tans+=(cnt1-maxflow)/2*2+(cnt2-maxflow)/2*2;\n\tans+=((cnt1-maxflow)&1)*3;\n\tprintf(\"%d\\n\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n\n#include <iostream>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <unordered_set>\n#include <queue>\n#include <set>\n#include <algorithm>\n#include <numeric>\n#include <list>\nusing namespace std;\n\nusing QWORD  = uint64_t;\nusing SQWORD = int64_t;\nusing DWORD  = uint32_t;\nusing SDWORD = int32_t;\nusing WORD   = uint16_t;\nusing SWORD  = int16_t;\nusing BYTE   = uint8_t;\nusing SBYTE  = int8_t;\nusing DOUBLE = double;\nusing FLOAT  = float;\n\n#define MIN_SDWORD (-2147483648)\n#define MAX_SDWORD (2147483647)\n#define MIN_SBYTE (-128)\n#define MAX_SBYTE (127)\n\n#define MIN_SQWORD (0x8000000000000000)\n#define MAX_SQWORD (0x7FFFFFFFFFFFFFFF)\n\n#define MAX_QWORD  (0xFFFFFFFFFFFFFFFF)\n#define MAX_DWORD  (0xFFFFFFFF)\n#define MAX_WORD   (0xFFFF)\n#define MAX_BYTE   (0xFF)\n\n#define MAX_DOUBLE      (1.0e+308)\n#define DOUBLE_EPS      (1.0e-12)\n#define MIN_DOUBLE_N    (-1.0e+308)\n\n#define ArrayLength(a)  (sizeof(a) / sizeof(a[0]))\n\nstatic inline DOUBLE MAX(DOUBLE a, DOUBLE b) { return a > b ? a : b; }\nstatic inline QWORD MAX(QWORD a, QWORD b) { return a > b ? a : b; }\nstatic inline DWORD MAX(DWORD a, DWORD b) { return a > b ? a : b; }\nstatic inline SDWORD MAX(SDWORD a, SDWORD b) { return a > b ? a : b; }\nstatic inline DOUBLE MIN(DOUBLE a, DOUBLE b) { return a < b ? a : b; }\nstatic inline QWORD MIN(QWORD a, QWORD b) { return a < b ? a : b; }\nstatic inline DWORD MIN(DWORD a, DWORD b) { return a < b ? a : b; }\nstatic inline SDWORD MIN(SDWORD a, SDWORD b) { return a < b ? a : b; }\nstatic inline DOUBLE ABS(DOUBLE a) { return 0 < a ? a : -a; };\n\n#define BYTE_BITS   (8)\n#define WORD_BITS   (16)\n#define DWORD_BITS  (32)\n#define QWORD_BITS  (64)\n\nstatic inline void inputStringSpSeparated(char *pcStr)\n{\n    char *pcCur = pcStr;\n    for (;;) {\n        char c = getchar();\n        if (('\\n' == c) || (EOF == c) || (' ' == c)) {\n            break;\n        }\n        *pcCur = c;\n        pcCur++;\n    }\n    *pcCur = '\\0';\n}\n\nstatic inline void inputString(char *pcStr)\n{\n    char *pcCur = pcStr;\n    for (;;) {\n        char c = getchar();\n        if (('\\n' == c) || (EOF == c)) {\n            break;\n        }\n        *pcCur = c;\n        pcCur++;\n    }\n    *pcCur = '\\0';\n}\n\n\nstatic inline SQWORD inputSQWORD(void)\n{\n    SQWORD sqNumber = 0;\n    SQWORD sqMultiplier = 1;\n    bool bRead = false;\n    for (;;) {\n        char c = getchar();\n        if (!bRead) {\n            if ('-' == c) {\n                sqMultiplier = -1;\n            }\n        }\n        if (('0' <= c) && (c <= '9')) {\n            sqNumber *= 10LL;\n            sqNumber += (SQWORD)(c - '0');\n            bRead = true;\n        } else {\n            if (bRead) {\n                return sqNumber * sqMultiplier;\n            }\n        }\n    }\n}\n\n\nstatic inline SDWORD inputSDWORD(void)\n{\n    SDWORD lNumber = 0;\n    SDWORD lMultiplier = 1;\n    bool bRead = false;\n    for (;;) {\n        char c = getchar();\n        if (!bRead) {\n            if ('-' == c) {\n                lMultiplier = -1;\n            }\n        }\n        if (('0' <= c) && (c <= '9')) {\n            lNumber *= 10;\n            lNumber += (c - '0');\n            bRead = true;\n        } else {\n            if (bRead) {\n                return lNumber * lMultiplier;\n            }\n        }\n    }\n}\n\nstatic inline DOUBLE inputFP(void)\n{\n    DOUBLE dInt = 0.0;\n    DOUBLE dFrac = 0.0;\n    DOUBLE dMultiplier = 1.0;\n    DWORD dwFpCnt = 0;\n    DOUBLE *pdCur = &dInt;\n    bool bRead = false;\n    for (;;) {\n        char c = getchar();\n        if (!bRead) {\n            if ('-' == c) {\n                dMultiplier = -1;\n            }\n        }\n        if ('.' == c) {\n            pdCur = &dFrac;\n        } else if (('0' <= c) && (c <= '9')) {\n            (*pdCur) *= 10;\n            (*pdCur) += (DOUBLE)(c - '0');\n            bRead = true;\n            if (pdCur == &dFrac) {\n                dwFpCnt++;\n            }\n        } else {\n            if (bRead) {\n                return dMultiplier * (dInt + dFrac / (pow((DOUBLE)10.0 , (DOUBLE)dwFpCnt)));\n            }\n        }\n    }\n}\n\n\n/**\n *  mod による操作ライブラリ\n */\n\n#define ANS_MOD (1000000007LL)\n \nstatic SQWORD addMod(SQWORD x, SQWORD y)\n{ \n    return (x + y) % ANS_MOD;\n}\n \nstatic SQWORD subMod(SQWORD x, SQWORD y)\n{\n    return (x - y + ANS_MOD) % ANS_MOD;\n}\n \nstatic SQWORD mulMod(SQWORD x, SQWORD y) \n{\n    return (x * y) % ANS_MOD;\n}\n \nstatic SQWORD powMod(SQWORD x, SQWORD e) {\n    SQWORD v = 1;\n    for (; e; x = mulMod(x, x), e >>= 1) {\n        if (e & 1) {\n            v = mulMod(v, x);\n        }\n    }\n    return v;\n}\n \nstatic SQWORD divMod(SQWORD x, SQWORD y)\n{\n    return mulMod(x, powMod(y, ANS_MOD - 2));\n}\n \n \nstatic SQWORD combMod(SQWORD n, SQWORD k)\n{\n    SQWORD v=1;\n    for(SQWORD i=1; i<=k; i++) {\n        v = divMod(mulMod(v, n-i+1),i);\n    } \n    return v;\n}\n\n/*----------------------------------------------*/\n\ntypedef struct {\n    SDWORD lTo;\n    SQWORD sqCap;\n    SQWORD sqCost;\n    SDWORD lRev;\n} ST_EDGE;\n\n#define MAX_V   (402)\n\nstruct Flow {\nprivate:\n    vector<ST_EDGE> avGraph[MAX_V];\n    SDWORD  alDimsFrom[MAX_V];\n    SDWORD  alDimsTo[MAX_V];\n    SQWORD  sqEdgeNum;\n    SQWORD  asqDist[MAX_V];\n    SDWORD  alPrevV[MAX_V];   \n    SDWORD  alPrevEdge[MAX_V];      /*直前の頂点と辺 */\n\n    SDWORD  alDinic_Level[MAX_V];\n    SDWORD  alDinic_Iter[MAX_V];\n\npublic:\n    Flow() {\n        for (auto v: avGraph) {\n            v.clear();\n        }\n        memset(asqDist, 0, sizeof(asqDist));\n        memset(alPrevV, 0, sizeof(alPrevV)); \n        memset(alPrevEdge, 0, sizeof(alPrevEdge));\n        memset(alDinic_Level, 0, sizeof(alDinic_Level));\n        memset(alDinic_Iter, 0, sizeof(alDinic_Iter));\n    }\n    void addEdge(SDWORD lFrom, SDWORD lTo, SQWORD sqCap, SQWORD sqCost) {\n        avGraph[lFrom].push_back((ST_EDGE){lTo, sqCap, sqCost, (SDWORD)(avGraph[lTo].size())});\n        avGraph[lTo].push_back((ST_EDGE){lFrom, 0, -sqCost, (SDWORD)(avGraph[lFrom].size() - 1)});\n    }\n\n    SDWORD minCostFlow(SDWORD lStart, SDWORD lTarget, SQWORD sqFlow)\n    {\n        SQWORD sqRes = 0;\n        SQWORD sqFlowRest = sqFlow;\n        while (0 < sqFlowRest) {\n            /* Bellman-Ford Method */\n            fill(asqDist, asqDist + ArrayLength(asqDist), MAX_SDWORD);\n            asqDist[lStart] = 0;\n            bool bIsUpdate = true;\n            while (bIsUpdate) {\n                bIsUpdate = false;\n                for (SDWORD lV = 0; lV < MAX_V; lV++) {\n                    for (SDWORD lIdx = 0; lIdx < avGraph[lV].size(); lIdx++) {\n                        ST_EDGE &stE = avGraph[lV][lIdx];\n                        if ((asqDist[lV] != MAX_SDWORD)\n                                && (0 < stE.sqCap)\n                                && (asqDist[lV] + stE.sqCost < asqDist[stE.lTo])) {\n                            asqDist[stE.lTo] = asqDist[lV] + stE.sqCost;\n                            alPrevV[stE.lTo] = lV;\n                            alPrevEdge[stE.lTo] = lIdx;\n                            bIsUpdate = true;\n                        }\n                    }\n                }\n            }\n            if (asqDist[lTarget] == MAX_SDWORD) {\n                return -1;\n            }\n\n            SQWORD sqAddFlow = MAX_SQWORD;\n            for (SDWORD lV = lTarget; lV != lStart; lV = alPrevV[lV]) {\n                sqAddFlow = min(sqAddFlow, avGraph[alPrevV[lV]][alPrevEdge[lV]].sqCap);\n            }\n            sqFlowRest -= sqAddFlow;\n            sqRes += sqAddFlow * asqDist[lTarget];      // 後で目的変数は書き換える\n            for (SDWORD lV = lTarget; lV != lStart; lV = alPrevV[lV]) {\n                ST_EDGE &stE = avGraph[alPrevV[lV]][alPrevEdge[lV]];\n                stE.sqCap -= sqAddFlow;\n                avGraph[lV][stE.lRev].sqCap += sqAddFlow;\n            }\n        }\n        return sqRes;\n    }\n\nprivate:\n    SQWORD maxFlowDinicBfs(SDWORD lS)\n    {\n        memset(alDinic_Level, -1, sizeof(alDinic_Level));\n        queue<SDWORD> queSearch;\n        alDinic_Level[lS] = 0;\n        queSearch.push(lS);\n        while (!queSearch.empty()) {\n            SDWORD lV = queSearch.front();\n            queSearch.pop();\n            for (SDWORD lIdx = 0; lIdx < avGraph[lV].size(); lIdx++) {\n                ST_EDGE &stE = avGraph[lV][lIdx];\n                if ((0 < stE.sqCap) && (alDinic_Level[stE.lTo] < 0)) {\n                    alDinic_Level[stE.lTo] = alDinic_Level[lV] + 1;\n                    queSearch.push(stE.lTo);\n                }\n            }\n        }\n\n        return 0;\n    }\n\n    SQWORD maxFlowDinicDfs(SDWORD lV, SDWORD lT, SQWORD sqF)\n    {\n        if (lV == lT) {\n            return sqF;\n        }\n        for (SDWORD &lI = alDinic_Iter[lV]; lI < avGraph[lV].size(); lI++) {\n            ST_EDGE &stE = avGraph[lV][lI];\n            if ((0 < stE.sqCap) && (alDinic_Level[lV] < alDinic_Level[stE.lTo])) {\n                SQWORD sqDiffFlow = maxFlowDinicDfs(stE.lTo, lT, min(sqF, stE.sqCap));\n                if (0 < sqDiffFlow) {\n                    stE.sqCap -= sqDiffFlow;\n                    avGraph[stE.lTo][stE.lRev].sqCap += sqDiffFlow;\n                    return sqDiffFlow;\n                }\n            }\n        }\n        return 0;\n    }\n\npublic:\n    SQWORD MaxFlow(SDWORD lStart, SDWORD lTarget)\n    {\n        SQWORD sqFlow = 0LL;\n        for (;;) {\n            maxFlowDinicBfs(lStart);\n            if (alDinic_Level[lTarget] < 0) {\n                return sqFlow;\n            }\n            memset(alDinic_Iter, 0, sizeof(alDinic_Iter));\n            while (1) {\n                SQWORD sqDiffFlow = maxFlowDinicDfs(lStart, lTarget, MAX_SQWORD);\n                sqFlow += sqDiffFlow;\n                if (0LL == sqDiffFlow) {\n                    break;\n                }\n            }\n        }\n    }\n};\n\n/*----------------------------------------------*/\n\nclass PrimeTable {\n    vector<bool> vbIsPrime;\n\npublic:\n    PrimeTable(SDWORD lMax) {\n        /* lSearchMax と ループ内の *2 の関係から、入力は3以上とすること */\n        if (!(1 <= lMax)) {\n            printf(\"Oops!\");\n            return;\n        }\n\n        /* 素数のリストを作る */\n        vbIsPrime.resize(lMax + 1, true);\n        SDWORD lSearchMax = sqrt(lMax) + 1;\n        vbIsPrime[0] = false;\n        vbIsPrime[1] = false;\n        for (SDWORD lPrime = 2; lPrime < lSearchMax; lPrime++) {\n            if (vbIsPrime[lPrime]) {\n                for (SDWORD lCurNum = lPrime * 2; lCurNum <= lMax; lCurNum += lPrime) {\n                    vbIsPrime[lCurNum] = false;\n                }\n            }\n        }\n    };\n\n    bool IsPrime(SQWORD sqN)\n    {\n        return vbIsPrime[sqN];\n    }\n};\n\n\n/*----------------------------------------------*/\n\n#define PNT_NO_START    (0)\n#define PNT_NO_OFFSET   (200)\n#define PNT_NO_TARGET   (401)\n#define FLOW_OFFSET     (1000000000)\n#define CAPACITY_INF    (1000000001)\n#define DUMMY_COST      (1)\n\nint main(void)\n{\n    SQWORD sqN = inputSQWORD();\n\n    Flow solverFlow;\n    vector<SQWORD> vsqB;\n    PrimeTable prime(1e7 + 1);\n    map<SQWORD, SQWORD> mapB;\n\n    for (SQWORD sqIdx = 0; sqIdx < sqN; sqIdx++) {\n        SQWORD sqA = inputSQWORD();\n\n        mapB[sqA] ^= 1;\n        mapB[sqA + 1] ^= 1;\n    }\n\n    vector<SQWORD> vsqBEven, vsqBOdd;\n\n    for (auto b: mapB) {\n        if (0 < b.second) {\n            if (0 == (b.first % 2)) {\n                vsqBEven.emplace_back(b.first);\n            } else {\n                vsqBOdd.emplace_back(b.first);\n            }\n        }\n    }\n\n    SQWORD sqNodeEven = 1;\n    for (auto e: vsqBEven) {\n        SQWORD sqNodeOdd = 1;\n        for (auto o: vsqBOdd) {\n            if (prime.IsPrime(abs(e - o))) {\n                solverFlow.addEdge(sqNodeEven, sqNodeOdd + PNT_NO_OFFSET, 1, DUMMY_COST);\n            }\n            sqNodeOdd++;\n        }\n        sqNodeEven++;\n    }\n    for (SQWORD sqIdx = 1; sqIdx <= vsqBEven.size(); sqIdx++) {\n        solverFlow.addEdge(PNT_NO_START, sqIdx, 1, DUMMY_COST);\n    }\n    for (SQWORD sqIdx = 1; sqIdx <= vsqBOdd.size(); sqIdx++) {\n        solverFlow.addEdge(sqIdx + PNT_NO_OFFSET, PNT_NO_TARGET, 1, DUMMY_COST);\n    }\n\n\n\n    SQWORD sqMaxFlow = solverFlow.MaxFlow(PNT_NO_START, PNT_NO_TARGET);\n    SQWORD vsqCRestEven = vsqBEven.size() - sqMaxFlow;\n    SQWORD vsqCRestOdd  = vsqBOdd.size() - sqMaxFlow;\n\n    SQWORD sqAns = sqMaxFlow;    \n    sqAns += ((vsqCRestEven / 2) * 2);\n    sqAns += ((vsqCRestOdd / 2) * 2);\n    if (0 < (vsqCRestEven %  2)) {\n        sqAns += 3;\n    }\n\n    printf(\"%lld\\n\", sqAns);\n\n    return 0;\n}\n/*------------------------------------------*/\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define N 800\n#define M 10000005\n\nint n,m,p,pr[M],pre[N],tot,a[N],ans,num;\nbool ok[M],vis[N];\nvector<int> g[N];\nmap<int,int> mp;\n\nbool dfs(int u){\n\tfor (int v:g[u])\n\t\tif (!vis[v]){\n\t\t\tvis[v]=1;\n\t\t\tif (!pre[v]||dfs(pre[v])){pre[v]=u; return 1;}\n\t\t}\n\treturn 0;\n}\n\nint main(){\n\tp=10000001;\n\tfor (int i=2;i<=p;++i){\n\t\tif (!ok[i]) pr[++tot]=i;\n\t\tfor (int j=1;j<=tot;++j){\n\t\t\tif (i*pr[j]>p) break;\n\t\t\tok[i*pr[j]]=1;\n\t\t\tif (i%pr[j]==0) break;\n\t\t}\n\t}\n\tok[1]=ok[2]=1;\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<=n;++i){\n\t\tint x; scanf(\"%d\",&x);\n\t\tmp[x]^=1; mp[x+1]^=1;\n\t}\n\tfor (auto i:mp){\n\t\tif (i.second) a[++m]=i.first;\n\t}\n\tfor (int i=1;i<=m;++i){\n\t\tfor (int j=1;j<i;++j)\n\t\t\tif (!ok[a[i]-a[j]]){\n\t\t\t\tg[i].push_back(j);\n\t\t\t\tg[j].push_back(i);\n\t\t\t}\n\t}\n\tfor (int i=1;i<=m;++i){\n\t\tmemset(vis,0,sizeof vis);\n\t\tif (a[i]&1){\n\t\t\tif (dfs(i)) ++ans;\n\t\t\t++num;\n\t\t}\n\t}\n\tans+=((num-ans)/2+(m-num-ans)/2)*2+((num-ans)&1)*3;\n\tprintf(\"%d\\n\",ans);\n\t\n\treturn 0;\n}\n\t\t\t"
  },
  {
    "language": "C++",
    "code": "//\n//  main.cpp\n//  F - Prime Flip\n//\n//  Created by Jędrzej Dudzicz on 04/02/2019.\n//  Copyright © 2019 Jędrzej Dudzicz. All rights reserved.\n//\n\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <algorithm>\n#include <cstdio>\n#include <utility>\nusing namespace std;\nconst int MXN=205;\nconst int MXM=1e7+5;\nint n,x;\nint s[MXM],s1[MXN];\nbool sito[MXM];\nint tab1[2*MXN],h;\nbool odw[2*MXN];\nint wynik;\nint main(){\n    for(int i=2;i*i<=MXM-1;i++){\n        if(sito[i]==0){\n            for(int j=i*i;j<=MXM-1;j+=i){\n                if(sito[j]==0)sito[j]=1;\n            }\n        }\n    }\n    sito[0]=1;\n    sito[1]=1;\n    sito[2]=1;\n    scanf(\"%d\",&n);\n    for(int i=0;i<n;i++){\n        scanf(\"%d\",&x);\n        s[x]=1;\n    }\n    for(int i=1;i<=10000001;i++){\n        if(s[i]!=s[i-1]){\n            s1[i]=1;\n            tab1[h++]=i;\n        }\n    }\n    for(int i=0;i<h;i++){\n        if(odw[i]==0){\n            for(int j=0;j<h;j++){\n                if(i!=j&&odw[j]==0&&abs(tab1[j]-tab1[i])>2&&sito[abs(tab1[j]-tab1[i])]==0){\n                    wynik++;\n                    odw[i]=1;odw[j]=1;\n                    break;\n                }\n            }\n        }\n    }\n    for(int i=0;i<h;i++){\n        if(odw[i]==0){\n            for(int j=0;j<h;j++){\n                if(i!=j&&odw[j]==0&&abs(tab1[j]-tab1[i])%2==0){\n                    wynik+=2;\n                    odw[i]=1;odw[j]=1;\n                    break;\n                }\n            }\n        }\n    }\n    for(int i=0;i<h;i++){\n        if(odw[i]==0){\n            for(int j=0;j<h;j++){\n                if(i!=j&&odw[j]==0&&abs(tab1[j]-tab1[i])%2==1){\n                    wynik+=3;\n                    odw[i]=1;odw[j]=1;\n                    break;\n                }\n            }\n        }\n    }\n    for(int i=0;i<h;i++){\n        if(odw[i]==0){\n            odw[i]=1;\n            wynik+=3;\n        }\n    }\n    printf(\"%d\\n\",wynik);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = (int)1e7 + 10;\ninline int read()\n{\n  int p=0; int f=1; char ch=getchar();\n  while(ch<'0' || ch>'9'){if(ch=='-') f=-1; ch=getchar();}\n  while(ch>='0' && ch<='9'){p=p*10+ch-'0'; ch=getchar();}\n  return p*f;\n}\n\nint prime[N],pri; bool v[N];\nvoid get_prime(int n)\n{\n  memset(v,1,sizeof(v)); v[0] = v[1] = 0; pri = 0;\n  for(int i=2;i<=n;i++)\n  {\n    if(v[i]) prime[++pri] = i;\n    for(int j=1;(j<=pri) && (i*prime[j] <= n);j++)\n    {\n      v[i*prime[j]] = 0;\n      if(i%prime[j]==0) break;\n    }\n  }\n  v[2] = 0;\n}\n\nstruct node{int x,y,next;}edge[100010]; int len,first[N];\nvoid ins(int x,int y){len++; edge[len].x=x; edge[len].y=y; edge[len].next=first[x]; first[x]=len;}\n\nint n,a[N],b[N];\n\n\nint chw[N],match[N];\nbool dfs(int x)\n{\n  for(int k=first[x];k!=-1;k=edge[k].next)\n  {\n    int y=edge[k].y;\n    if(!chw[y])\n    {\n      chw[y] = 1;\n      if((match[y] == 0) || dfs(match[y])){match[y] = x; return 1;}\n    }\n  }\n  return 0;\n}\n\nint main()\n{\n\n  get_prime(1e7+1);\n\n  n = read(); len = 0; memset(first,-1,sizeof(first));\n  for(int i=1;i<=n;i++) a[read()] = 1;\n  for(int i=1;i<=(int)1e7+1;i++) b[i] = abs(a[i] - a[i-1]);\n  for(int i=1;i<=(int)1e7+1;i++) a[i] = b[i];\n  int blen = 0; for(int i=1;i<=(int)1e7+1;i++) if(a[i] == 1) b[++blen] = i;\n  int c=0,d=0; for(int i=1;i<=blen;i++) if(b[i] & 1) c++; else d++;\n  for(int i=1;i<=blen;i++) if(b[i] & 1) for(int j=1;j<=blen;j++) if(!(b[j]&1)) if(v[abs(b[i] - b[j])]) ins(i,j);\n  int ans=0; for(int i=1;i<=blen;i++)\n  {\n    for(int j=1;j<=blen;j++) chw[j] = 0;\n    if(dfs(i)) ans++;\n  }\n \n  c-=ans; d-=ans;\n  ans += 2*(c/2 + d/2); c%=2; d%=2;\n  if(c && d) ans+=3;\n\n  return printf(\"%d\\n\",ans),0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cmath>\n#include<cstring>\n#include<algorithm>\n#define LL long long\n#define fo(i,j,k) for(int i=j;i<=k;i++)\n#define fd(i,j,k) for(int i=j;i>=k;i--)\n#define fr(i,j) for(int i=beg[j];i;i=nex[i])\nusing namespace std;\nint const mn=100+3,ma=1e7;\nint n,a[mn],tag[ma],ss[ma],b[2][mn],\n\tgra,beg[mn],to[mn*mn],nex[mn*mn],vis[mn],re[mn];\nvoid ins(int u,int v){\n\tto[++gra]=v;\n\tnex[gra]=beg[u];\n\tbeg[u]=gra;\n}\nint dfs(int p){\n\tvis[p]=1;\n\tfr(i,p)if((!re[to[i]])||((!vis[re[to[i]]])&&dfs(re[to[i]]))){\n\t\tre[to[i]]=p;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tfo(i,1,n)scanf(\"%d\",&a[i]);\n\tsort(a+1,a+n+1);\n\tb[a[1]&1][++b[a[1]&1][0]]=a[1];\n\tb[(a[n]+1)&1][++b[(a[n]+1)&1][0]]=a[n]+1;\n\tfo(i,2,n)if(a[i-1]+1!=a[i])\n\t\tb[(a[i-1]+1)&1][++b[(a[i-1]+1)&1][0]]=a[i-1]+1,\n\t\tb[a[i]&1][++b[a[i]&1][0]]=a[i];\n\ttag[1]=1;\n\tfo(i,2,ma){\n\t\tif(!tag[i])ss[++ss[0]]=i;\n\t\tfo(j,1,ss[0]){\n\t\t\tif(1ll*i*ss[j]>ma)break;\n\t\t\ttag[i*ss[j]]=1;\n\t\t\tif(!(i%ss[j]))break;\n\t\t}\n\t}\n\tfo(i,1,b[0][0])fo(j,1,b[1][0])\n\t\tif(!tag[abs(b[0][i]-b[1][j])])ins(i,j);\n\tint tmp=0;\n\tfo(i,1,b[0][0]){\n\t\tmemset(vis,0,sizeof(vis));\n\t\ttmp+=dfs(i);\n\t}\n\tprintf(\"%d\",tmp+2*((b[0][0]-tmp)/2+(b[1][0]-tmp)/2)+3*((b[0][0]-tmp)&1));\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <cmath>\n#include <cstdlib>\n#include <vector>\n#include <set>\n#include <map>\n#include <cassert>\n#include <queue>\n#include <ctime>\n#include <string>\n#include <cstring>\n#include <random>\n#define mp make_pair\n#define pb push_back\n#define NAME \"\"\n#define y1 y1_423\n#define list lista\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\n\ntemplate<typename T>\nostream& operator << (ostream& cout, const vector<T> &a) {\n\tif ((int)a.size() == 0) {\n\t\treturn (cout << \"()\");\n\t}\n\tcout << \"(\" << a[0];\n\tfor (int i = 1; i < (int)a.size(); i++) {\n\t\tcout << \"; \" << a[i];\n\t}\n\treturn (cout << \")\");\n}\n\ntemplate<typename T>\nostream& operator << (ostream& cout, const set<T> &a) {\n\tif ((int)a.size() == 0) {\n\t\treturn (cout << \"{}\");\n\t}\n\tauto it = a.begin();\n\tcout << \"{\" << *it;\n\t++it;\n\tfor (; it != a.end(); ++it) {\n\t\tcout << \"; \" << *it;\n\t}\n\treturn (cout << \"}\");\n}\n\ntemplate<typename T>\nostream& operator << (ostream& cout, const multiset<T> &a) {\n\tif ((int)a.size() == 0) {\n\t\treturn (cout << \"{}\");\n\t}\n\tauto it = a.begin();\n\tcout << \"{\" << *it;\n\t++it;\n\tfor (; it != a.end(); ++it) {\n\t\tcout << \"; \" << *it;\n\t}\n\treturn (cout << \"}\");\n}\n\ntemplate<typename T1, typename T2>\nostream& operator << (ostream& cout, const pair<T1, T2> &a) {\n\treturn cout << \"(\" << a.first << \"; \" << a.second << \")\";\n}\n\nrandom_device gen;\nmt19937 rnd(gen());\n\nconst int nmax = 1000 * 1000 * 10 + 10;\nconst int kmax = 300;\nconst int inf = 2000 * 1000 * 1000;\nconst ll infl = 1000ll * 1000ll * 1000ll * 1000ll * 1000ll * 1000ll;\nconst int mod = 1000 * 1000 * 1000 + 7;\nconst ld pi = acos(-1.0);\n\nbool used[nmax], u[nmax];\nint p[kmax];\nint b[nmax];\nvector<int> a, go[kmax];\n\nbool ok(int v) {\n\tif (u[v]) return false;\n\tu[v] = true;\n\tfor (int u : go[v]) {\n\t\tif (p[u] == -1) {\n\t\t\tp[u] = v;\n\t\t\treturn true;\n\t\t}\n\t}\n\tfor (int u : go[v]) {\n\t\tif (ok(p[u])) {\n\t\t\tp[u] = v;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint main() {\n\t//freopen(\"input.txt\", \"r\", stdin);freopen(\"output.txt\", \"w\", stdout);\n\t//freopen(NAME\".in\", \"r\", stdin);freopen(NAME\".out\", \"w\", stdout);\n\tfor (int i = 2; i < nmax; i++) {\n\t\tused[i] = 1;\n\t}\n\tfor (ll i = 2; i * i < nmax; i++) {\n\t\tif (!used[i]) continue;\n\t\tfor (ll j = i * i; j < nmax; j += i) {\n\t\t\tused[j] = 0;\n\t\t}\n\t}\n\tused[0] = used[1] = used[2] = 0;\n\tint n;\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; i++) {\n\t\tint x;\n\t\tscanf(\"%d\", &x);\n\t\tb[x] ^= 1;\n\t\tb[x + 1] ^= 1;\n\t}\n\tfor (int i = 0; i < nmax; i++) {\n\t\tif (b[i] == 1) {\n\t\t\ta.pb(i);\n\t\t}\n\t}\n\tn = a.size();\n\tassert(n < kmax);\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif (i == j) continue;\n\t\t\tif (used[abs(a[i] - a[j])]) {\n\t\t\t\tgo[i].pb(j);\n\t\t\t}\n\t\t}\n\t}\n\tint cnt0 = 0, cnt1 = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (a[i] % 2 == 0) {\n\t\t\tcnt0++;\n\t\t} else {\n\t\t\tcnt1++;\n\t\t}\n\t}\n\tfor (int j = 0; j < n; j++) {\n\t\tp[j] = -1;\n\t}\n\tint answer = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (a[i] % 2 == 0) continue;\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tu[j] = 0;\n\t\t}\n\t\tif (ok(i)) answer++;\n\t}\n\tcout << answer + ((cnt0 - answer) / 2 + (cnt1 - answer) / 2) * 2 + ((cnt1 - answer) % 2) * 3 << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 10000010;\nbool pd[N];\nint prime[N],tot;\nvoid find_prime(){\n\tmemset(pd,true,sizeof(pd));\n\tfor(int i=2;i<N;i++){\n\t\tif(pd[i]) prime[++tot]=i;\n\t\tfor(int j=1;j<=tot;j++){\n\t\t\tif(prime[j]*i>=N) break;\n\t\t\tpd[prime[j]*i]=false;\n\t\t\tif(i%prime[j]==0) break;\n\t\t}\n\t}\n\tpd[0] = pd[1]=pd[2]=false;\n}\nbool pd2[N];\nint n,a[110];\nvector<int> v[2];\nvector<int> g[300];\nbool flag[300];\nint last[300];\nbool find(int x){\n\tint t;\n\tfor(int i = 0;i<g[x].size();i++) if(flag[t=g[x][i]]){\n\t\tflag[t] = false;\n\t\tif(last[t]==0) {\n\t\t\tlast[t] = x+1;\n\t\t\treturn true;\n\t\t} else if(find(last[t]-1)){\n\t\t\tlast[t] = x+1;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\nint main(){\n\tfind_prime();\n\tscanf(\"%d\",&n);\n\tfor(int i = 1;i<=n;i++)scanf(\"%d\",a+i),pd2[a[i]]=true;\n\tfor(int i = 1;i<N;i++) if(pd2[i]!=pd2[i-1]) v[i&1].push_back(i);\n\tfor(int i = 0;i<v[0].size();i++){\n\t\tfor(int j = 0;j<v[1].size();j++){\n\t\t\tif(pd[abs(v[0][i]-v[1][j])]) g[i].push_back(j);//puts(\"YYY\");\n\t\t}\n\t}\n\tint tot = 0;\n\t//for(int i = 0;i<v[1].size();i++) cout<<v[1][i]<<endl;\n\tfor(int i = 0;i<v[0].size();i++) {\n\t\tmemset(flag,true,sizeof(flag));\t\n\t\tif(find(i)) tot++;\n\t}\n\t//cout<<tot<<endl;\n\tprintf(\"%d\\n\",tot+(v[0].size()-tot)/2*2+(v[1].size()-tot)/2*2+(v[0].size()-tot)%2*3);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\nusing namespace std;\n\n#define abs(x) ((x) > 0 ? (x) : -(x))\nbool prime[11000000];\nbool b[11000000];\nint n;\nbool used[210], go[210][210];\nint ans;\nint ind[210];\nint cnt0, cnt1;\nint m;\nint Link[210];\n\nbool fi(int x) {\n\tfor (int i = 1; i <= m; i++)\n\t\tif (go[x][i] && !used[i]) {\n\t\t\tif (!Link[i] || fi(Link[i])) {\n\t\t\t\tLink[i] = x;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\treturn false;\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 2; i <= 10000000; i++)\n\t\tprime[i] = true;\n\tfor (int i = 1; i * i <= 10000000; i++)\n\t\tif (prime[i])\n\t\t\tfor (int j = i * i; j <= 10000000; j += i)\n\t\t\t\tprime[j] = false;\n\tprime[2] = false;\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tint t;\n\t\tscanf(\"%d\", &t);\n\t\tb[t] ^= 1;\n\t\tb[t + 1] ^= 1;\n\t}\n\tfor (int i = 1; i <= 10000001; i++)\n\t\tif (b[i]) {\n\t\t\tm += 1;\n\t\t\tind[m] = i;\n\t\t}\n\tfor (int i = 1; i <= m; i++)\n\t\tif (ind[i] % 2 == 0) {\n\t\t\tcnt0 += 1;\n\t\t\tfor (int j = 1; j <= m; j++)\n\t\t\t\tif (ind[j] % 2 == 1 && prime[abs(ind[i] - ind[j])])\n\t\t\t\t\tgo[i][j] = true;\n\t\t}\n\tint ans = 0;\n\tfor (int i = 1; i <= m; i++)\n\t\tif (ind[i] % 2 == 0) {\n\t\t\tmemset(used, false, sizeof used);\n\t\t\tif (fi(i))\n\t\t\t\tans += 1;\n\t\t}\n\tint aa = ans;\n\tcnt1 = m - cnt0;\n\t// printf(\"?? %d %d\\n\", cnt0, cnt1);\n\tcnt0 -= ans;\n\tcnt1 -= ans;\n\tif (cnt0 % 2 == 0)\n\t\taa += cnt0 + cnt1;\n\telse\n\t\taa += 3 + (cnt0 - 1) + cnt1 - 1;\n\tprintf(\"%d\\n\", aa);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nvector<int> pr, pchk;\nvoid getPrime() {\n    pchk = vector<int>(10000010, 0);\n    for(int i = 2; i < 10000010; i++) {\n        if(pchk[i]) continue;\n        int mul = 2;\n        while(i * mul < 10000010) {\n            pchk[i * mul] = 1;\n            mul++;\n        }\n    }\n}\n\nint N;\nvector<int> X;\n\nvector<vector<int> > cc;\nint dp(int l, int r) {\n    int &ret = cc[l][r];\n    if(ret != -1) return ret;\n\n    ret = 3*(r - l + 1);\n    int pre = 1;\n    int tmp = 0;\n    for(int i = l; i <= r; i++) {\n        tmp += (X[i] - pre) % 2 == 0? (X[i] - pre == 0? 0 : 2) : (pchk[ X[i] - pre ]? 3 : 1);\n        pre = X[i] + 1;\n    }\n    if(pchk[ X[r] ]) tmp += (X[r] % 2 == 0? 2 : 3);\n    else tmp++;\n\n    ret = min(ret, tmp);\n    for(int i = l; i < r; i++) {\n        ret = min(ret, dp(l, i) + dp(i + 1, r));\n    }\n    return ret;\n}\n\nint main() {\n    getPrime();\n\n    scanf(\"%d\", &N);\n    X.resize(N);\n    for(int i = 0; i < N; i++) {\n        scanf(\"%d\", &X[i]);\n    }\n\n    cc = vector<vector<int> >(N, vector<int>(N, -1));\n    cout<<dp(0, N - 1);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h> \n#define fo(i,a,b) for(i=a;i<=b;i++)\n#define fd(i,a,b) for(i=a;i>=b;i--)\n#define min(a,b) (a<b?a:b)\n#define max(a,b) (a>b?a:b)\ntypedef long long ll;\nusing namespace std;\nint check(int x){\n\tif (x==1) return 0;\n\tint i;\n\tfo(i,2,x-1){\n\t\tif (i*i>x) break;\n\t\tif (x%i==0) return 0;\n\t}return 1;\n}\nconst int maxn=1e7+5;\nint i,j,n;\nint a[205],ans,b[205],n1,n2,f[205];\nbool bz[maxn],w[205][205];\nint bk[205],bp;\nvoid add(int x){\n\tif (x&1) a[++n1]=x;else b[++n2]=x;\n}\nbool dfs(int x){\n\tif (bk[x]==bp) return 0;\n\tbk[x]=bp;\n\tint i;\n\tfo(i,1,n2) if(w[x][i]&&(!f[i]||dfs(f[i])))return f[i]=x,1;\n\treturn 0;\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tfo(i,1,n){\n\t\tint x;\n\t\tscanf(\"%d\",&x);\n\t\tbz[x]=1;\n\t}\n\tfd(i,maxn-1,1) {\n\t\tbz[i]^=bz[i-1];\n\t\tif (bz[i]) add(i);\n\t}\n\tfo(i,1,n1)\n\tfo(j,1,n2) w[i][j]=check(abs(a[i]-b[j]));\n\tfo(i,1,n1) bp++,ans+=dfs(i);\n\tn1-=ans,n2-=ans;\n\tif (n1&1) ans++;\n\tans+=n1+n2;\n\tprintf(\"%d\\n\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define sqr(x) ((x)*(x))\n#define ll long long\n#define ull unsigned long long\n#define ui unsigned int\n#define ld long double\n#define vi vector<int>\n#define HEAP(T) priority_queue<T>\n#define heap(...) priority_queue<__VA_ARGS__,vector<__VA_ARGS__>,greater<__VA_ARGS__> > \n#define pii pair<int,int>\n#define pb push_back\n#define mp make_pair\n#define debuge cerr<<\"isok\"<<endl\n#define debug(x) cerr<<#x<<\"=\"<<x<<endl\n#define error(...) fprintf(stderr,__VA_ARGS__)\n#define SS second\n#define FF first\n#define ls (k<<1)\n#define rs (k<<1|1)\n#define inf 0x3f3f3f3f\n#define LL long long\n#define clr(a,x) memset(a,x,sizeof(a))\n#define cpy(a,x) memcpy(a,x,sizeof(a))\n#define file(x) freopen(x\".in\",\"r\",stdin),freopen(x\".out\",\"w\",stdout)\nusing namespace std;\n\nconst int N=20000005,M=100005,mod=1e9+7;\ntemplate<class T> inline void gmin(T &x,const T &y){if(x>y) x=y;}\ntemplate<class T> inline void gmax(T &x,const T &y){if(x<y) x=y;}\ntemplate<class T,class S> inline void ch(T &x,const S y){x=(x+y)%mod;}\nconst int BufferSize=1<<16;\nchar buffer[BufferSize],*Bufferhead,*Buffertail;\nbool Terminal;\ninline char Getchar(){\n\tif(Bufferhead==Buffertail){\n\t\tint l=fread(buffer,1,BufferSize,stdin);\n\t\tif(!l){Terminal=1;return 0;}\n\t\tBuffertail=(Bufferhead=buffer)+l;\n\t}\n\treturn *Bufferhead++;\n}\ntemplate<class T>inline bool read(T &x){\n\tx=0;char c=Getchar(),rev=0;\n\twhile(c<'0'||c>'9'){c=Getchar();rev|=c=='-';if(Terminal)return 0;}\n\twhile(c>='0'&&c<='9') x=x*10+c-'0',c=Getchar();\n\tx=rev?-x:x;\n\treturn 1;\n}\ninline bool reads(char *x){\n\tchar c=Getchar();\n\twhile(c<33||c>126){c=Getchar();if(Terminal)return 0;}\n\twhile(c>=33&&c<=126) (*x++)=c,c=Getchar();\n\t*x=0;return 1;\n}\ntemplate<class T>inline void print(T x,const char c){\n\tif(!x){putchar('0');putchar(c);return;}\n\tif(x<0) putchar('-'),x=-x;\n\tint m=0,a[10];\n\twhile(x) a[m++]=x%10,x/=10;\n\twhile(m--) putchar(a[m]+'0');\n\tputchar(c);\n}\ninline int exp(int x,int y,const int mod=::mod){\n\tint ans=1;\n\twhile(y){\n\t\tif(y&1) ans=(ll)ans*x%mod;\n\t\tx=(ll)x*x%mod;y>>=1;\n\t}return ans;\n}\n\nconst int INF = 2147483647;\n\nconst int MaxN = 400;\nconst int MaxM = 79800;\n\ntemplate <class T>\ninline void tension(T &a, const T &b)\n{\n\tif (b < a)\n\t\ta = b;\n}\ntemplate <class T>\ninline void relax(T &a, const T &b)\n{\n\tif (b > a)\n\t\ta = b;\n}\ntemplate <class T>\ninline int size(const T &a)\n{\n\treturn (int)a.size();\n}\n\ninline int getint()\n{\n\tchar c;\n\twhile (c = getchar(), '0' > c || c > '9');\n\n\tint res = c - '0';\n\twhile (c = getchar(), '0' <= c && c <= '9')\n\t\tres = res * 10 + c - '0';\n\treturn res;\n}\n\nconst int MaxNX = MaxN + MaxN;\n\nstruct edge\n{\n\tint v, u, w;\n\n\tedge(){}\n\tedge(const int &_v, const int &_u, const int &_w)\n\t\t: v(_v), u(_u), w(_w){}\n};\n\nint n, m;\nedge mat[MaxNX + 1][MaxNX + 1];\n\nint n_matches;\nLL tot_weight;\nint mate[MaxNX + 1];\nint lab[MaxNX + 1];\n\nint q_n, q[MaxN];\nint fa[MaxNX + 1], col[MaxNX + 1];\nint slackv[MaxNX + 1];\n\nint n_x;\nint bel[MaxNX + 1], blofrom[MaxNX + 1][MaxNX + 1];\nvector<int> bloch[MaxNX + 1];\n\ninline int e_delta(const edge &e) // does not work inside blossoms\n{\n\treturn lab[e.v] + lab[e.u] - mat[e.v][e.u].w * 2;\n}\ninline void update_slackv(int v, int x)\n{\n\tif (!slackv[x] || e_delta(mat[v][x]) < e_delta(mat[slackv[x]][x]))\n\t\tslackv[x] = v;\n}\ninline void calc_slackv(int x)\n{\n\tslackv[x] = 0;\n\tfor (int v = 1; v <= n; v++)\n\t\tif (mat[v][x].w > 0 && bel[v] != x && col[bel[v]] == 0)\n\t\t\tupdate_slackv(v, x);\n}\n\ninline void q_push(int x)\n{\n\tif (x <= n)\n\t\tq[q_n++] = x;\n\telse\n\t{\n\t\tfor (int i = 0; i < size(bloch[x]); i++)\n\t\t\tq_push(bloch[x][i]);\n\t}\n}\ninline void set_mate(int xv, int xu)\n{\n\tmate[xv] = mat[xv][xu].u;\n\tif (xv > n)\n\t{\n\t\tedge e = mat[xv][xu];\n\t\tint xr = blofrom[xv][e.v];\n\t\tint pr = find(bloch[xv].begin(), bloch[xv].end(), xr) - bloch[xv].begin();\n\t\tif (pr % 2 == 1)\n\t\t{\n\t\t\treverse(bloch[xv].begin() + 1, bloch[xv].end());\n\t\t\tpr = size(bloch[xv]) - pr;\n\t\t}\n\n\t\tfor (int i = 0; i < pr; i++)\n\t\t\tset_mate(bloch[xv][i], bloch[xv][i ^ 1]);\n\t\tset_mate(xr, xu);\n\n\t\trotate(bloch[xv].begin(), bloch[xv].begin() + pr, bloch[xv].end());\n\t}\n}\ninline void set_bel(int x, int b)\n{\n\tbel[x] = b;\n\tif (x > n)\n\t{\n\t\tfor (int i = 0; i < size(bloch[x]); i++)\n\t\t\tset_bel(bloch[x][i], b);\n\t}\n}\n\ninline void augment(int xv, int xu)\n{\n\twhile (true)\n\t{\n\t\tint xnu = bel[mate[xv]];\n\t\tset_mate(xv, xu);\n\t\tif (!xnu)\n\t\t\treturn;\n\t\tset_mate(xnu, bel[fa[xnu]]);\n\t\txv = bel[fa[xnu]], xu = xnu;\n\t}\n}\ninline int get_lca(int xv, int xu)\n{\n\tstatic bool book[MaxNX + 1];\n\tfor (int x = 1; x <= n_x; x++)\n\t\tbook[x] = false;\n\twhile (xv || xu)\n\t{\n\t\tif (xv)\n\t\t{\n\t\t\tif (book[xv])\n\t\t\t\treturn xv;\n\t\t\tbook[xv] = true;\n\t\t\txv = bel[mate[xv]];\n\t\t\tif (xv)\n\t\t\t\txv = bel[fa[xv]];\n\t\t}\n\t\tswap(xv, xu);\n\t}\n\treturn 0;\n}\n\ninline void add_blossom(int xv, int xa, int xu)\n{\n\tint b = n + 1;\n\twhile (b <= n_x && bel[b])\n\t\tb++;\n\tif (b > n_x)\n\t\tn_x++;\n\n\tlab[b] = 0;\n\tcol[b] = 0;\n\n\tmate[b] = mate[xa];\n\n\tbloch[b].clear();\n\tbloch[b].push_back(xa);\n\tfor (int x = xv; x != xa; x = bel[fa[bel[mate[x]]]])\n\t\tbloch[b].push_back(x), bloch[b].push_back(bel[mate[x]]), q_push(bel[mate[x]]);\n\treverse(bloch[b].begin() + 1, bloch[b].end());\n\tfor (int x = xu; x != xa; x = bel[fa[bel[mate[x]]]])\n\t\tbloch[b].push_back(x), bloch[b].push_back(bel[mate[x]]), q_push(bel[mate[x]]);\n\n\tset_bel(b, b);\n\n\tfor (int x = 1; x <= n_x; x++)\n\t{\n\t\tmat[b][x].w = mat[x][b].w = 0;\n\t\tblofrom[b][x] = 0;\n\t}\n\tfor (int i = 0; i < size(bloch[b]); i++)\n\t{\n\t\tint xs = bloch[b][i];\n\t\tfor (int x = 1; x <= n_x; x++)\n\t\t\tif (mat[b][x].w == 0 || e_delta(mat[xs][x]) < e_delta(mat[b][x]))\n\t\t\t\tmat[b][x] = mat[xs][x], mat[x][b] = mat[x][xs];\n\t\tfor (int x = 1; x <= n_x; x++)\n\t\t\tif (blofrom[xs][x])\n\t\t\t\tblofrom[b][x] = xs;\n\t}\n\tcalc_slackv(b);\n}\ninline void expand_blossom1(int b) // lab[b] == 1\n{\n\tfor (int i = 0; i < size(bloch[b]); i++)\n\t\tset_bel(bloch[b][i], bloch[b][i]);\n\n\tint xr = blofrom[b][mat[b][fa[b]].v];\n\tint pr = find(bloch[b].begin(), bloch[b].end(), xr) - bloch[b].begin();\n\tif (pr % 2 == 1)\n\t{\n\t\treverse(bloch[b].begin() + 1, bloch[b].end());\n\t\tpr = size(bloch[b]) - pr;\n\t}\n\n\tfor (int i = 0; i < pr; i += 2)\n\t{\n\t\tint xs = bloch[b][i], xns = bloch[b][i + 1];\n\t\tfa[xs] = mat[xns][xs].v;\n\t\tcol[xs] = 1, col[xns] = 0;\n\t\tslackv[xs] = 0, calc_slackv(xns);\n\t\tq_push(xns);\n\t}\n\tcol[xr] = 1;\n\tfa[xr] = fa[b];\n\tfor (int i = pr + 1; i < size(bloch[b]); i++)\n\t{\n\t\tint xs = bloch[b][i];\n\t\tcol[xs] = -1;\n\t\tcalc_slackv(xs);\n\t}\n\n\tbel[b] = 0;\n}\ninline void expand_blossom_final(int b) // at the final stage\n{\n\tfor (int i = 0; i < size(bloch[b]); i++)\n\t{\n\t\tif (bloch[b][i] > n && lab[bloch[b][i]] == 0)\n\t\t\texpand_blossom_final(bloch[b][i]);\n\t\telse\n\t\t\tset_bel(bloch[b][i], bloch[b][i]);\n\t}\n\tbel[b] = 0;\n}\n\ninline bool on_found_edge(const edge &e)\n{\n\tint xv = bel[e.v], xu = bel[e.u];\n\tif (col[xu] == -1)\n\t{\n\t\tint nv = bel[mate[xu]];\n\t\tfa[xu] = e.v;\n\t\tcol[xu] = 1, col[nv] = 0;\n\t\tslackv[xu] = slackv[nv] = 0;\n\t\tq_push(nv);\n\t}\n\telse if (col[xu] == 0)\n\t{\n\t\tint xa = get_lca(xv, xu);\n\t\tif (!xa)\n\t\t{\n\t\t\taugment(xv, xu), augment(xu, xv);\n\t\t\tfor (int b = n + 1; b <= n_x; b++)\n\t\t\t\tif (bel[b] == b && lab[b] == 0)\n\t\t\t\t\texpand_blossom_final(b);\n\t\t\treturn true;\n\t\t}\n\t\telse\n\t\t\tadd_blossom(xv, xa, xu);\n\t}\n\treturn false;\n}\n\nbool match()\n{\n\tfor (int x = 1; x <= n_x; x++)\n\t\tcol[x] = -1, slackv[x] = 0;\n\n\tq_n = 0;\n\tfor (int x = 1; x <= n_x; x++)\n\t\tif (bel[x] == x && !mate[x])\n\t\t\tfa[x] = 0, col[x] = 0, slackv[x] = 0, q_push(x);\n\tif (q_n == 0)\n\t\treturn false;\n\n\twhile (true)\n\t{\n\t\tfor (int i = 0; i < q_n; i++)\n\t\t{\n\t\t\tint v = q[i];\n\t\t\tfor (int u = 1; u <= n; u++)\n\t\t\t\tif (mat[v][u].w > 0 && bel[v] != bel[u])\n\t\t\t\t{\n\t\t\t\t\tint d = e_delta(mat[v][u]);\n\t\t\t\t\tif (d == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (on_found_edge(mat[v][u]))\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\telse if (col[bel[u]] == -1 || col[bel[u]] == 0)\n\t\t\t\t\t\tupdate_slackv(v, bel[u]);\n\t\t\t\t}\n\t\t}\n\n\t\tint d = INF;\n\t\tfor (int v = 1; v <= n; v++)\n\t\t\tif (col[bel[v]] == 0)\n\t\t\t\ttension(d, lab[v]);\n\t\tfor (int b = n + 1; b <= n_x; b++)\n\t\t\tif (bel[b] == b && col[b] == 1)\n\t\t\t\ttension(d, lab[b] / 2);\n\t\tfor (int x = 1; x <= n_x; x++)\n\t\t\tif (bel[x] == x && slackv[x])\n\t\t\t{\n\t\t\t\tif (col[x] == -1)\n\t\t\t\t\ttension(d, e_delta(mat[slackv[x]][x]));\n\t\t\t\telse if (col[x] == 0)\n\t\t\t\t\ttension(d, e_delta(mat[slackv[x]][x]) / 2);\n\t\t\t}\n\n\t\tfor (int v = 1; v <= n; v++)\n\t\t{\n\t\t\tif (col[bel[v]] == 0)\n\t\t\t\tlab[v] -= d;\n\t\t\telse if (col[bel[v]] == 1)\n\t\t\t\tlab[v] += d;\n\t\t}\n\t\tfor (int b = n + 1; b <= n_x; b++)\n\t\t\tif (bel[b] == b)\n\t\t\t{\n\t\t\t\tif (col[bel[b]] == 0)\n\t\t\t\t\tlab[b] += d * 2;\n\t\t\t\telse if (col[bel[b]] == 1)\n\t\t\t\t\tlab[b] -= d * 2;\n\t\t\t}\n\n\t\tq_n = 0;\n\t\tfor (int v = 1; v <= n; v++)\n\t\t\tif (lab[v] == 0) // all unmatched vertices' labels are zero! cheers!\n\t\t\t\treturn false;\n\t\tfor (int x = 1; x <= n_x; x++)\n\t\t\tif (bel[x] == x && slackv[x] && bel[slackv[x]] != x && e_delta(mat[slackv[x]][x]) == 0)\n\t\t\t{\n\t\t\t\tif (on_found_edge(mat[slackv[x]][x]))\n\t\t\t\t\treturn true;\n\t\t\t}\n\t\tfor (int b = n + 1; b <= n_x; b++)\n\t\t\tif (bel[b] == b && col[b] == 1 && lab[b] == 0)\n\t\t\t\texpand_blossom1(b);\n\t}\n\treturn false;\n}\n\nvoid calc_max_weight_match()\n{\n\tfor (int v = 1; v <= n; v++)\n\t\tmate[v] = 0;\n\n\tn_x = n;\n\tn_matches = 0;\n\ttot_weight = 0;\n\n\tbel[0] = 0;\n\tfor (int v = 1; v <= n; v++)\n\t\tbel[v] = v, bloch[v].clear();\n\tfor (int v = 1; v <= n; v++)\n\t\tfor (int u = 1; u <= n; u++)\n\t\t\tblofrom[v][u] = v == u ? v : 0;\n\n\tint w_max = 0;\n\tfor (int v = 1; v <= n; v++)\n\t\tfor (int u = 1; u <= n; u++)\n\t\t\trelax(w_max, mat[v][u].w);\n\tfor (int v = 1; v <= n; v++)\n\t\tlab[v] = w_max;\n\n\twhile (match())\n\t\tn_matches++;\n\n\tfor (int v = 1; v <= n; v++)\n\t\tif (mate[v] && mate[v] < v)\n\t\t\ttot_weight += mat[v][mate[v]].w;\n}\n\n\ninline bool check(int x){\n\tif(x==1) return 0;\n\tfor(int i=2;i*i<=x;i++)\t\n\t\tif(x%i==0) return 0;\n\treturn 1;\t\n}\nint calc(int n){\n\tif(!n) return 0;\n\tif(n%2==0) return 2;\n\tif(check(n)) return 3;\n\treturn 1;\n}\n\nbool f[N];\nint a[205];\n\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++){\n\t\tint x;scanf(\"%d\",&x);\n\t\tf[x]=1;\n\t}\n\tn=0;\n\tfor(int i=1;i<=10000001;i++) \n\t\tif(f[i]^f[i-1]) a[++n]=i;\n\tfor (int v=1;v<=n;v++)\n\t\tfor (int u=1;u<=n;u++)\n\t\t\tif(u!=v) mat[v][u]=edge(v,u,calc(abs(a[u]-a[v])));\n\tcalc_max_weight_match();\n\tprintf(\"%d\\n\", n*2-tot_weight);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cmath>\n#include<cstring>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n\nconst int N=205;\nconst int M=10000005;\n\nint n1,n2,n,cnt,now,m,ans;\nint lk[N],p1[N],p2[N],pri[M],p[N],c[M],b[M];\nbool vis[M],tag[N];\nvector<int> lev[N];\n\nvoid getpri(int n){\n\tint i,j;\n\tfor (i=2;i<=n;i++){\n\t\tif (!vis[i]) pri[++cnt]=i;\n\t\tfor (j=1;j<=cnt&&pri[j]*i<=n;j++){\n\t\t\tvis[i*pri[j]]=1;\n\t\t\tif (i%pri[j]==0) break;\n\t\t}\n\t}\n\tvis[1]=vis[2]=1;\n}\n\nbool dfs(int k){\n\tint u,j;\n\tfor (j=0;j<lev[k].size();j++){\n\t\tu=lev[k][j];\n\t\tif (tag[u]!=now){\n\t\t\ttag[u]=now;\n\t\t\tif (!lk[u]||dfs(lk[u])){\n\t\t\t\tlk[u]=k;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint main(){\n\tint i,j;\n\tgetpri(M-1);\n\tscanf(\"%d\",&n);\n\tfor (i=1;i<=n;i++) scanf(\"%d\",&p[i]);\n\tsort(p+1,p+1+n); m=p[n]+1;\n\tfor (i=1;i<=n;i++) b[p[i]]^=1;\n\tfor (i=1;i<=m;i++) c[i]=b[i]!=b[i-1];\n\tfor (i=1;i<=m;i++)\n\t\tif (c[i]){\n\t\t\tif (i&1) p1[++n1]=i;\n\t\t\telse p2[++n2]=i;\n\t\t}\n\tfor (i=1;i<=n1;i++)\n\t\tfor (j=1;j<=n2;j++)\n\t\t\tif (!vis[abs(p1[i]-p2[j])]) lev[i].push_back(j);\n\tfor (i=1;i<=n1;i++){\n\t\tnow++;\n\t\tans+=dfs(i);\n\t}\n\tprintf(\"%d\\n\",ans+(n1-ans)/2*2+(n2-ans)/2*2+(n1-ans)%2*3);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#define _GLIBCXX_DEBUG\n\n#include<bits/stdc++.h>\nusing namespace std;\n\n#define endl '\\n'\n#define lfs cout<<fixed<<setprecision(10)\n#define ALL(a)  (a).begin(),(a).end()\n#define ALLR(a)  (a).rbegin(),(a).rend()\n#define spa << \" \" <<\n#define fi first\n#define se second\n#define MP make_pair\n#define MT make_tuple\n#define PB push_back\n#define EB emplace_back\n#define rep(i,n,m) for(ll i = (n); i < (ll)(m); i++)\n#define rrep(i,n,m) for(ll i = (ll)(m) - 1; i >= (ll)(n); i--)\nusing ll = long long;\nusing ld = long double;\nconst ll MOD1 = 1e9+7;\nconst ll MOD9 = 998244353;\nconst ll INF = 1e18;\nusing P = pair<ll, ll>;\ntemplate<typename T1, typename T2>bool chmin(T1 &a,T2 b){if(a>b){a=b;return true;}else return false;}\ntemplate<typename T1, typename T2>bool chmax(T1 &a,T2 b){if(a<b){a=b;return true;}else return false;}\nll median(ll a,ll b, ll c){return a+b+c-max({a,b,c})-min({a,b,c});}\nvoid ans1(bool x){if(x) cout<<\"Yes\"<<endl;else cout<<\"No\"<<endl;}\nvoid ans2(bool x){if(x) cout<<\"YES\"<<endl;else cout<<\"NO\"<<endl;}\nvoid ans3(bool x){if(x) cout<<\"Yay!\"<<endl;else cout<<\":(\"<<endl;}\ntemplate<typename T1,typename T2>void ans(bool x,T1 y,T2 z){if(x)cout<<y<<endl;else cout<<z<<endl;}  \ntemplate<typename T>void debug(vector<vector<T>>&v,ll h,ll w){for(ll i=0;i<h;i++){cout<<v[i][0];for(ll j=1;j<w;j++)cout spa v[i][j];cout<<endl;}};\nvoid debug(vector<string>&v,ll h,ll w){for(ll i=0;i<h;i++){for(ll j=0;j<w;j++)cout<<v[i][j];cout<<endl;}};\ntemplate<typename T>void debug(vector<T>&v,ll n){if(n!=0)cout<<v[0];for(ll i=1;i<n;i++)cout spa v[i];cout<<endl;};\ntemplate<typename T>vector<vector<T>>vec(ll x, ll y, T w){vector<vector<T>>v(x,vector<T>(y,w));return v;}\nll gcd(ll x,ll y){ll r;while(y!=0&&(r=x%y)!=0){x=y;y=r;}return y==0?x:y;}\nvector<ll>dx={1,-1,0,0,1,1,-1,-1};vector<ll>dy={0,0,1,-1,1,-1,1,-1};\ntemplate<typename T>vector<T> make_v(size_t a,T b){return vector<T>(a,b);}\ntemplate<typename... Ts>auto make_v(size_t a,Ts... ts){return vector<decltype(make_v(ts...))>(a,make_v(ts...));}\ntemplate<typename T1, typename T2>ostream &operator<<(ostream &os, const pair<T1, T2>&p){return os << p.first << \" \" << p.second;}\ntemplate<typename T>ostream &operator<<(ostream &os, const vector<T> &v){for(auto &z:v)os << z << \" \";cout<<\"|\"; return os;}\n//mt19937 mt(chrono::steady_clock::now().time_since_epoch().count());\nvector< bool > prime_table(ll n) {\n  vector< bool > prime(n + 1, true);\n  if(n >= 0) prime[0] = false;\n  if(n >= 1) prime[1] = false;\n  for(ll i = 2; i * i <= n; i++) {\n    if(!prime[i]) continue;\n    for(ll j = i + i; j <= n; j += i) {\n      prime[j] = false;\n    }\n  }\n  return prime;\n}\ntemplate< typename flow_t, typename cost_t >\nstruct PrimalDual {\n  const cost_t INF;\n\n  struct edge {\n    ll to;\n    flow_t cap;\n    cost_t cost;\n    ll rev;\n    bool isrev;\n  };\n  vector< vector< edge > > graph;\n  vector< cost_t > potential, min_cost;\n  vector< ll > prevv, preve;\n\n  PrimalDual(ll V) : graph(V), INF(numeric_limits< cost_t >::max()) {}\n\n  void add_edge(ll from, ll to, flow_t cap, cost_t cost) {\n    graph[from].emplace_back((edge) {to, cap, cost, (ll) graph[to].size(), false});\n    graph[to].emplace_back((edge) {from, 0, -cost, (ll) graph[from].size() - 1, true});\n  }\n\n  cost_t min_cost_flow(ll s, ll t, flow_t f) {\n    ll V = (ll) graph.size();\n    cost_t ret = 0;\n    using Pi = pair< cost_t, ll >;\n    priority_queue< Pi, vector< Pi >, greater< Pi > > que;\n    potential.assign(V, 0);\n    preve.assign(V, -1);\n    prevv.assign(V, -1);\n\n    while(f > 0) {\n      min_cost.assign(V, INF);\n      que.emplace(0, s);\n      min_cost[s] = 0;\n      while(!que.empty()) {\n        Pi p = que.top();\n        que.pop();\n        if(min_cost[p.second] < p.first) continue;\n        for(ll i = 0; i < graph[p.second].size(); i++) {\n          edge &e = graph[p.second][i];\n          cost_t nextCost = min_cost[p.second] + e.cost + potential[p.second] - potential[e.to];\n          if(e.cap > 0 && min_cost[e.to] > nextCost) {\n            min_cost[e.to] = nextCost;\n            prevv[e.to] = p.second, preve[e.to] = i;\n            que.emplace(min_cost[e.to], e.to);\n          }\n        }\n      }\n      if(min_cost[t] == INF) return -1;\n      for(ll v = 0; v < V; v++) potential[v] += min_cost[v];\n      flow_t addflow = f;\n      for(ll v = t; v != s; v = prevv[v]) {\n        addflow = min(addflow, graph[prevv[v]][preve[v]].cap);\n      }\n      f -= addflow;\n      ret += addflow * potential[t];\n      for(ll v = t; v != s; v = prevv[v]) {\n        edge &e = graph[prevv[v]][preve[v]];\n        e.cap -= addflow;\n        graph[v][e.rev].cap += addflow;\n      }\n    }\n    return ret;\n  }\n\n  void output() {\n    for(ll i = 0; i < graph.size(); i++) {\n      for(auto &e : graph[i]) {\n        if(e.isrev) continue;\n        auto &rev_e = graph[e.to][e.rev];\n        cout << i << \"->\" << e.to << \" (flow: \" << rev_e.cap << \"/\" << rev_e.cap + e.cap << \")\" << endl;\n      }\n    }\n  }\n  using R=vector<pair<pair<ll,ll>,pair<flow_t,cost_t>>>;\n  R restore() {\n    R ret;\n    for(ll i = 0; i < graph.size(); i++) {\n      for(auto &e : graph[i]) {\n        if(e.isrev) continue;\n        auto &rev_e = graph[e.to][e.rev];\n        ret.emplace_back(make_pair(i,e.to),make_pair(rev_e.cap,e.cost));\n      }\n    }\n    return ret;\n  }\n};\nint main(){\n  cin.tie(nullptr);\n  ios_base::sync_with_stdio(false);\n  ll res=0,buf=0;\n  bool judge = true;\n  ll lim=1e7+30;\n  //ll lim=1e3;cout<<\"naosu\"<<endl;\n  auto pr=prime_table(lim);\n  /*vector<ll>p;\n  rep(i,0,lim)if(pr[i])p.PB(i);\n  ll sz=p.size();*/\n  ll n;cin>>n;\n  vector<ll>x(n);\n  rep(i,0,n)cin>>x[i];\n  vector<ll>y;\n  rep(i,0,n){\n    y.PB(x[i]);\n    y.PB(x[i]+1);\n  }\n  {\n    vector<ll>tmp;\n    sort(ALL(y));\n    rep(i,0,y.size()){\n      if(i+1<y.size()&&y[i]==y[i+1])i++;\n      else tmp.PB(y[i]);\n    }\n    y=tmp;\n  }\n  pr[2]=false;\n  ll sz=y.size();\n  PrimalDual<ll,ll>fl(2*sz+2);\n  rep(i,0,sz)rep(j,0,sz){\n    if(i==j)continue;\n    ll dif=abs(y[i]-y[j]);\n    ll cost=0;\n    if(dif==0)cost=0;\n    else if(pr[dif])cost=1;\n    else if(dif%2==0)cost=2;\n    else cost=3;\n    //cout<<dif spa cost spa y[i] spa y[j]<<endl;\n    fl.add_edge(i,j+sz,1,cost);\n  }\n  ll S=2*sz,T=2*sz+1;\n  rep(i,0,sz){\n    fl.add_edge(S,i,1,0);\n    fl.add_edge(i+sz,T,1,0);\n  }\n  //cout<<sz<<endl;\n  //debug(y,sz);\n  cout<<fl.min_cost_flow(S,T,sz)/2<<endl;\n  /*auto r=fl.restore();\n  for(auto z:r){\n    if(z.se.fi==1&&z.fi.fi<sz&&z.fi.se<2*sz){\n      cout<<y[z.fi.fi] spa y[z.fi.se-sz]<<endl;\n    }\n  }*/\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint x[105], n;\nvector<int> vt[2];\nbool notprime[100000015];\nbool X[10000015];\n\nvoid add(int t)\n{\n    if (X[t]) return;\n    X[t] = true;\n\n    bool a = binary_search(x, x + n, t);\n    bool b = binary_search(x, x + n, t - 1);\n    if (a != b) vt[t & 1].push_back(t);\n}\n\n// in: n, m, graph\n// out: match, matched\n// vertex cover: (reached[0][left_node] == 0) || (reached[1][right_node] == 1)\n// O(E*sqrt(V))\nstruct BipartiteMatching {\n    int n, m;\n    vector<vector<int>> graph;\n    vector<int> matched, match, edgeview, level;\n    vector<int> reached[2];\n    BipartiteMatching(int n, int m) : n(n), m(m), graph(n), matched(m, -1),\n    match(n, -1) {}\n    bool assignLevel() {\n        bool reachable = false;\n        level.assign(n, -1);\n        reached[0].assign(n, 0);\n        reached[1].assign(m, 0);\n        queue<int> q;\n        for (int i = 0; i < n; i++) {\n            if (match[i] == -1) {\n                level[i] = 0;\n                reached[0][i] = 1;\n                q.push(i);\n            }\n        }\n        while (!q.empty()) {\n            auto cur = q.front(); q.pop();\n            for (auto adj : graph[cur]) {\n                reached[1][adj] = 1;\n                auto next = matched[adj];\n                if (next == -1) {\n                    reachable = true;\n                }\n                else if (level[next] == -1) {\n                    level[next] = level[cur] + 1;\n                    reached[0][next] = 1;\n                    q.push(next);\n                }\n            }\n        }\n        return reachable;\n    }\n    int findpath(int nod) {\n        for (int &i = edgeview[nod]; i < graph[nod].size(); i++) {\n            int adj = graph[nod][i];\n            int next = matched[adj];\n            if (next >= 0 && level[next] != level[nod] + 1) continue;\n            if (next == -1 || findpath(next)) {\n                match[nod] = adj;\n                matched[adj] = nod;\n                return 1;\n            }\n        }\n        return 0;\n    }\n    int solve() {\n        int ans = 0;\n        while (assignLevel()) {\n            edgeview.assign(n, 0);\n            for (int i = 0; i < n; i++)\n                if (match[i] == -1)\n                    ans += findpath(i);\n        }\n        return ans;\n    }\n};\n\n\nint main()\n{\n    notprime[1] = true;\n    for (int i = 3; i <= 10000010; i += 2)\n    {\n        if (notprime[i]) continue;\n        for (int j = i * 3; j <= 10000010; j += i * 2)\n            notprime[j] = true;\n    }\n\n    scanf(\"%d\",&n);\n    for (int i = 0; i < n; i++) scanf(\"%d\", &x[i]);\n    sort(x, x + n);\n\n    for (int i = 0; i < n; i++)\n    {\n        add(x[i]);\n        add(x[i] + 1);\n    }\n\n    if (vt[0].empty() || vt[1].empty())\n    {\n        printf(\"%zd\\n\", vt[0].size() + vt[1].size());\n        return 0;\n    }\n\n    BipartiteMatching bm(vt[0].size(), vt[1].size());\n    for (int i = 0; i < vt[0].size(); i++)\n    {\n        for (int j = 0; j < vt[1].size(); j++)\n        {\n            if (notprime[abs(vt[0][i] - vt[1][j])] == false)\n                bm.graph[i].push_back(j);\n        }\n    }\n\n    int ret = bm.solve();\n\n    printf(\"%d\\n\", (int)(ret + (vt[0].size() - ret) / 2 * 2 + (vt[1].size() - ret) / 2 * 2 + (vt[0].size() - ret) % 2 * 3));\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int maxm=1e7+10,maxn=210;\nint n,a[maxn],b[maxn],m,ans;\nint b1[maxn],b2[maxn],p1,p2;\nbool np[maxm],vis[maxn],g[maxn][maxn],s[maxm];\nint match[maxn];\nvector<int> p;\n\nvoid init(){\n\tnp[0]=np[1]=1;\n\tfor(int i=2;i<maxm;++i){\n\t\tif(!np[i]){\n\t\t\tp.push_back(i);\n\t\t\t//cerr<<i<<endl;\n\t\t\t//system(\"pause\");\n\t\t}\n\t\tfor(int j=0,j_end=p.size(),x;j<j_end&&(x=p[j]*i)<maxm;++j){\n\t\t\tnp[x]=true;\n\t\t\tif(i%p[j]==0)break;\n\t\t}\n\t}\n\tnp[2]=1;\n}\n\nbool dfs(int u){\n\tfor(int i=1;i<=p2;++i)if(g[u][i]&&!vis[i]){\n\t\tvis[i]=1;\n\t\tif(!match[i]||dfs(match[i])){\n\t\t\tmatch[i]=u;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\nvoid solve(){\n\tinit();\n\tcin>>n;\n\tfor(int i=1;i<=n;++i){cin>>a[i];s[a[i]]=1;}\n\tfor(int i=1;i<maxm;++i){\n\t\tif(s[i]!=s[i-1])b[++m]=i;//,cerr<<b[m]<<endl;\n\t}\n\t//cerr<<m<<endl;\n\tfor(int i=1;i<=m;++i){\n\t\tif(b[i]&1)b1[++p1]=b[i];\n\t\telse b2[++p2]=b[i];\n\t}\n\t//cerr<<p1<<\" \"<<p2<<endl;\n\tfor(int i=1;i<=p1;++i){\n\t\tfor(int j=1;j<=p2;++j){\n\t\t\tif(!np[abs(b1[i]-b2[j])]){\n\t\t\t\t//cerr<<i<<\" \"<<j<<endl;\n\t\t\t\tg[i][j]=true;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor(int i=1;i<=p1;++i){\n\t\tmemset(vis,0,sizeof vis);\n\t\tif(dfs(i))++ans;//match()\n\t}\n\tp1-=ans;p2-=ans;\n\t//cerr<<ans<<endl;\n\tans+=p1/2*2+p2/2*2;\n\tans+=p1%2*3;\n\t//cerr<<ans<<endl;\n\tcout<<ans<<endl;\n}\nint main(){\n\t#ifndef ONLINE_JUDGE\n\tfreopen(\"a.in\",\"r\",stdin);\n\tfreopen(\"a.out\",\"w\",stdout);\n\t#endif\n\tsolve();\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<cstring>\nusing namespace std;\nint n;\nint res;\nvector<int>v;\nint lst=-1;\nint match[210];\nint me,mo;\nint mx;\nbool f[10000010];\nvector<int>ok[210];\nbool vis[210];\nint prm[1000010];\nint sz;\nint l;\nbool bp(int x)\n{\n\tvis[x]=true;\n\tfor(int i=0;i<ok[x].size();i++)\n\t{\n\t\tint y=ok[x][i];\n\t\tif(match[y]==-1 || (!vis[match[y]] && bp(match[y])))\n\t\t{\n\t\t\tmatch[y]=x;\n\t\t\tmatch[x]=y;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint x;\n\t\tscanf(\"%d\",&x);\n\t\tif(x!=lst+1)\n\t\t{\n\t\t\tif(lst+1)v.push_back(lst+1);\n\t\t\tv.push_back(x);\n\t\t}\n\t\tlst=x;\n\t\tmx=lst+1;\n\t}\n\tv.push_back(lst+1);\n\tf[1]=true;\n\tfor(int i=2;i<=mx;i++)\n\t{\n\t\tif(!f[i])prm[++sz]=i;\n\t\tfor(int j=1;j<=sz;j++)\n\t\t{\n\t\t\tif(prm[j]*i>mx)break;\n\t\t\tf[prm[j]*i]=true;\n\t\t\tif(i%prm[j]==0)break;\n\t\t}\n\t}\n\tl=v.size();\n\tfor(int i=0;i<l;i++)\n\t{\n\t\tmatch[i]=-1;\n\t\tif(v[i]&1)mo++;else me++;\n\t\tfor(int j=i+1;j<l;j++)\n\t\t{\n\t\t\tif(v[j]-v[i]!=2 && !f[v[j]-v[i]])\n\t\t\t{\n\t\t\t\tok[i].push_back(j);\n\t\t\t\tok[j].push_back(i);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<l;i++)\n\t{\n\t\tif(match[i]>=0)continue;\n\t\tmemset(vis,false,sizeof(vis));\n\t\tif(bp(i))res++;\n\t}\n\tprintf(\"%d\",res+((me-res)/2+(mo-res)/2)*2+((me-res)%2)*3);\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N = 5010, M = 1e7+6;\nint prime[M],pcnt,_v[M];\nint k,x[N];\ninline void sieve(int n = 10000000+2){\n\t_v[0]=_v[1]=1;\n\tfor(int i=2;i<=n;i++){\n\t\tif(!_v[i])prime[++pcnt]=i;\n\t\tfor(int j=1;j<=pcnt&&1ll*i*prime[j]<=n;j++){\n\t\t\t_v[i*prime[j]]=1;\n\t\t\tif(i%prime[j]==0)break;\n\t\t}\n\t}\n}\nint id1[N],id2[N],cnt1,cnt2;\n\nstruct node{int x,y,next;}edge[100010]; int len,first[N];\nvoid adde(int x,int y){len++; edge[len].x=x; edge[len].y=y; edge[len].next=first[x]; first[x]=len;}\nint chw[N],match[N];\nbool dfs(int x)\n{\n  for(int k=first[x];k!=-1;k=edge[k].next)\n  {\n    int y=edge[k].y;\n    if(!chw[y])\n    {\n      chw[y] = 1;\n      if((match[y] == 0) || dfs(match[y])){match[y] = x; return 1;}\n    }\n  }\n  return 0;\n}\n\nint main()\n{\n//\tfreopen(\"oatmeal.in\",\"r\",stdin);\n//\tfreopen(\"oatmeal.out\",\"w\",stdout);\n\tsieve();\n\tcin >> k;\n\tfor(int i=1;i<=k;i++){\n\t\tscanf(\"%d\",&x[i]);\n\t}\n\tsort(x+1,x+k+1);\n\tfor(int u=1,v;u<=k;u=v+1){\n\t\tv=u;\n\t\twhile(v+1<=k&&x[v+1]==x[v]+1)++v;\n\t\tif(x[u]%2)id1[++cnt1]=x[u];\n\t\telse id2[++cnt2]=x[u];\n\t\tif((x[v]+1)%2)id1[++cnt1]=x[v]+1;\n\t\telse id2[++cnt2]=x[v]+1;\n\t}\n\tmemset(first,-1,sizeof(first));\n\tfor(int i=1;i<=cnt1;i++)for(int j=1;j<=cnt2;j++){\n\t\tif(!_v[abs(id1[i]-id2[j])]){\n\t\t\tadde(i,j);\n\t\t\t// cout << \"?\" << endl;\n\t\t}\n\t}\n\t// cout << cnt << endl;\n\tint ans=0;\n\tfor(int i=1;i<=cnt1;i++){\n\t\tfor(int j=1;j<N;j++)chw[j]=0;\n\t\tif(dfs(i))ans++;\n\t}\n\t//cout << cnt1 << \" \" << cnt2 << \" \" << ans << endl;\n\tcnt1-=ans,cnt2-=ans;\n\tif(cnt1%2==0){\n\t\tcout << cnt1+cnt2+ans << endl;\n\t}else{\n\t\tcout << cnt1+cnt2+ans+1 << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N=205,MX=10000010;\nint n,m,mx,ma,mb,a[N],b[N],e[N][N],vis[N],lmat[N],rmat[N],B[MX],p[MX/10],ans;\n\nvoid add(int x){if (x&1)  a[++ma]=x;  else  b[++mb]=x;}\n\nbool dfs(int x)\n{\n\tfor (int y=1; y<=mb; y++)\n\t\tif ((e[x][y])&&(vis[y]!=vis[0]))\n\t\t\t{\n\t\t\t\tvis[y]=vis[0];\n\t\t\t\tif ((!rmat[y])||(dfs(y)))  return lmat[x]=y,rmat[y]=x,1;\n\t\t\t}\n\treturn 0;\n}\n\nvoid work()\n{\n\tscanf(\"%d\",&n);\n\tfor (int i=1,x,y=-1; i<=n+1; i++)\n\t\t{\n\t\t\tif (i<=n)  scanf(\"%d\",&x),mx=max(mx,x+1);\n\t\t\tif ((i!=1)&&(y+1!=x))  add(y+1);\n\t\t\tif ((i<=n)&&(y+1!=x))  add(x);\n\t\t\ty=x;\n\t\t}\n\tB[1]=1;\n\tfor (int i=1; i<=mx; i++)\n\t\t{\n\t\t\tif (!B[i])  p[++m]=i;\n\t\t\tfor (int j=1; j<=m&&i*p[j]<=mx; j++)\n\t\t\t\t{\n\t\t\t\t\tB[i*p[j]]=1;\n\t\t\t\t\tif (i%p[j]==0)  break;\n\t\t\t\t}\n\t\t}\n\tfor (int i=1; i<=ma; i++)\n\t\tfor (int j=1; j<=mb; j++)\n\t\t\te[i][j]=!B[abs(a[i]-b[j])];\n\tfor (int i=1; i<=ma; i++)  if (vis[0]++,dfs(i))  ans++;\n\tans+=(ma-ans)/2*2+(mb-ans)/2*2+((ma-ans)&1)*3;\n\tprintf(\"%d\",ans);\n}\n\nint main()\n{\n\twork();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define maxn 10000007\n#define maxm 2001\n#define reg register\nusing namespace std;\nbool not_prime[maxn];\nint n,  pos[maxm], d[maxn], prime[maxn],a[maxm], m, cnt, siz[maxm]; \nint nt[maxm], fi[maxm], go[maxm], vis[maxm], visx[maxm], link[maxm]; \ninline int  read() {\n    reg int s = 0, t = 0; reg char ch = getchar();\n    while(ch > '9' || ch < '0') t |= ch == '-', ch = getchar();\n    while(ch >= '0' && ch <= '9') s = (s << 1) + (s << 3) + (ch ^ 48), ch = getchar();\n    return t ? -s : s;\n}\nvoid add(int x, int y){\n    nt[++cnt] = fi[x]; fi[x] = cnt; go[cnt] = y;\n    nt[++cnt] = fi[y]; fi[y] = cnt; go[cnt] = x;\n}\nvoid col(int x){\n    for(int i = fi[x]; i; i = nt[i]){\n        int v = go[i]; \n        if(!vis[v]) {\n            vis[v] = 3 - vis[x]; col(v);\n        }\n    }\n}\nint find(int x, int tim){\n    if(visx[x] == tim) return 0; visx[x] = tim;\n    for(int i = fi[x]; i; i = nt[i]){\n        int v =  go[i];\n        if(!link[v] || find(link[v], tim)){\n            link[v] = x; return 1;\n        }\n    }\n    return 0;\n}\nint main(){\n    n = read(); int ans = 0;\n    for(int i = 1; i <= n; i++) \n        pos[i] = read(), d[pos[i]] = 1; a[0] = -1;\n    for(int i = 1; i <= n; i++) {\n        if(!d[pos[i] - 1] && a[m] != pos[i]) a[++m] = pos[i];\n        if(!d[pos[i] + 1]) a[++m] = pos[i] + 1; \n    }\n    for(int i = 2; i < maxn; i++) {\n        if(!not_prime[i]) prime[++cnt] = i;\n        for(int j = 1; j <= cnt && prime[j] * i < maxn; j++){\n            not_prime[i * prime[j]] = 1;\n            if(i % prime[j] == 0) break;\n        }\n    }\n    not_prime[2] = 1; cnt = 0; not_prime[1] = 1;\n    for(int i = 1; i <= m; i++)\n        for(int j = i + 1; j <= m; j++)\n            if(!not_prime[a[j] - a[i]]) add(i, j); \n    for(int i = 1; i <= m; i++)\n        if(!vis[i]) { vis[i] = 1; col(i); }\n    for(int i = 1; i <= m; i++)\n        if(vis[i] == 1) ans += (link[i] = find(i, i));       \n    int sum1 = 0, sum2 = 0;\n    for(int i = 1; i <= m; i++){\n        if(link[i]) continue; \n        sum1 += (a[i] & 1);\n        sum2 += (a[i] % 2 == 0);\n    }\n    if(sum1 & 1) ans += 3;\n    ans += sum1 / 2 * 2 + sum2 / 2 * 2;\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <climits>\n#include <queue>\n#include <algorithm>\n\nusing std::queue;\nusing std::min;\n\nconst int MAXX=1e7+5,MAXN=205;\nint n,cnt_x,cnt_y;\nint x_id[MAXN],y_id[MAXN];\nbool up[MAXX];\n\nstruct node{int he,iter,dis;}d[MAXN];\nstruct line{int to,nex,cap;}ed[MAXN*MAXN<<1];\n\ninline bool is_odd_prm(int x){\n\tif(x==1) return false;\n\tfor(int i=2;i*i<=x;++i){\n\t\tif(x%i==0) return false;\n\t}\n\treturn true;\n}\n\ninline void addE(int u,int v,int cap){\n\tstatic int cnt=1;\n\ted[++cnt]=(line){v,d[u].he,cap};\n\td[u].he=cnt;\n}\n\ninline int revE(int i){return i^1;}\n\ninline bool BFS(int s,int t,int n){\n\tfor(int i=1;i<=n;++i)\n\t\td[i].dis=-1;\n\tstatic queue<int> q;\n\td[s].dis=0;\n\tq.push(s);\n\tint u;\n\twhile(q.size()){\n\t\tu=q.front();\n\t\tq.pop();\n\t\tfor(int i=d[u].he,v;i;i=ed[i].nex){\n\t\t\tif(ed[i].cap==0) continue;\n\t\t\tv=ed[i].to;\n\t\t\tif(d[v].dis==-1){\n\t\t\t\td[v].dis=d[u].dis+1;\n\t\t\t\tq.push(v);\n\t\t\t}\n\t\t}\n\t}\n\treturn d[t].dis!=-1;\n}\n\nint aug(int u,int rest,const int t){\n\tif(u==t) return rest;\n\tint ret=0;\n\tfor(int &i=d[u].iter,v,cap,flow;i;i=ed[i].nex){\n\t\tv=ed[i].to,cap=ed[i].cap;\n\t\tif(d[v].dis!=d[u].dis+1 || cap==0)\n\t\t\tcontinue;\n\t\tflow=aug(v,min(cap,rest),t);\n\t\ted[i].cap-=flow,ed[revE(i)].cap+=flow;\n\t\tret+=flow,rest-=flow;\n\t\tif(rest==0) return ret;\n\t}\n\tif(ret==0) d[u].dis=-1;\n\treturn ret;\n}\n\ninline int Dinic(int s,int t,int n){\n\tint ret=0;\n\twhile(BFS(s,t,n)){\n\t\tfor(int i=1;i<=n;++i)\n\t\t\td[i].iter=d[i].he;\n\t\tret+=aug(s,INT_MAX,t);\n\t}\n\treturn ret;\n}\n\ninline void build(){\n\tfor(int i=1;i<=cnt_x;++i){\n\t\tfor(int j=1,v;j<=cnt_y;++j){\n\t\t\tif(is_odd_prm(abs(x_id[i]-y_id[j]))){\n\t\t\t\tv=j+cnt_x;\n\t\t\t\taddE(i,v,INT_MAX),addE(v,i,0);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=1,s=cnt_x+cnt_y+1;i<=cnt_x;++i)\n\t\taddE(s,i,1),addE(i,s,0);\n\tfor(int i=1,u,t=cnt_x+cnt_y+2;i<=cnt_y;++i){\n\t\tu=cnt_x+i;\n\t\taddE(u,t,1),addE(t,u,0);\n\t}\n}\n\nint main(){\n\tscanf(\"%d\",&n);\n\tint x;\n\tfor(int i=1;i<=n;++i){\n\t\tscanf(\"%d\",&x);\n\t\tup[x]=true;\n\t}\n\tfor(int i=1;i<=x+1;++i){\n\t\tif(up[i]!=up[i-1])\n\t\t\ti&1 ? x_id[++cnt_x]=i:y_id[++cnt_y]=i;\n\t}\n\tbuild();\n\tint k=Dinic(cnt_x+cnt_y+1,cnt_x+cnt_y+2,cnt_x+cnt_y+2);\n\tprintf(\"%d\",k+((cnt_x-k)/2+(cnt_y-k)/2)*2+3*((cnt_x-k)%2 && (cnt_y-k)%2));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define left lft\n\nconst int N=1e7;\nconst int maxn=N+10;\n\nint n,m,m0,m1,c[210],k1,left[210];\nbool vis[210];\nbool comp[maxn]; //composite\nint primes,prime[maxn/10];\n\nvoid prework()\n{\n\tint i,j;\n\tcomp[0]=1;\n\tcomp[1]=1;\n\tfor (i=2;i<=N;i++)\n\t{\n\t\tif (!comp[i]) prime[++primes]=i;\n\t\tfor (j=1;j<=primes&&i*prime[j]<=N;j++)\n\t\t{\n\t\t\tcomp[i*prime[j]]=1;\n\t\t\tif (i%prime[j]==0) break;\n\t\t}\n\t}\n\tcomp[2]=1;\n}\n\nbool match(int u)\n{\n\tfor (int i=1;i<=m;i++)\n\t{\n\t\tif (comp[abs(u-c[i])]||vis[i]) continue;\n\t\tvis[i]=1;\n\t\tif (!left[i]||match(left[i]))\n\t\t{\n\t\t\tleft[i]=u;\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nint main()\n{\n#ifdef h10\n\tfreopen(\"F.in\",\"r\",stdin);\n\tfreopen(\"F.out\",\"w\",stdout);\n#endif\n\tint i,x;\n\tprework();\n\tscanf(\"%d\",&n);\n\tfor (i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%d\",&x);\n\t\tc[(i<<1)-1]=x;\n\t\tc[i<<1]=x+1;\n\t}\n\tsort(c+1,c+n+n+1);\n\tfor (i=1;i<=n+n;i++)\n\t\tc[i]==c[m]?m--:c[++m]=c[i];\n\tfor (i=1;i<=m;i++)\n\t\tc[i]&1?m1++:m0++;\n\tfor (i=1;i<=m;i++)\n\t{\n\t\tmemset(vis,0,sizeof(vis));\n\t\tif (c[i]&1) k1+=match(i);\n\t}\n\tm0-=k1; m1-=k1;\n\tprintf(\"%d\\n\",k1+((m0>>1)+(m1>>1))*2+(m0&1)*3);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<cmath>\n#define N 210\nusing namespace std;\nint prime[N],link[N],tot;\nbool p[N],vis[N];\nint n;\nbool can[N][N],s[N];\nvector<int>v[2];\nbool check(int u)\n{\n\tfor(int i=1;i<=v[1].size();i++)\n\tif(can[u][i] && !vis[i])\n\t{\n\t\tvis[i]=1;\n\t\tif(!link[i] || check(link[i]))\n \t\t{\n\t\t\tlink[i]=u;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\nint main()\n{\n\tp[1]=true;\n\tfor(int i=2;i<=N-10;i++)\n\t{\n\t\tif(!p[i]) prime[++tot]=i;\n\t\tfor(int j=1;j<=tot && i*prime[j]<=N-10;j++)\n\t\t{\n\t\t\tp[i*prime[j]]=1;\n\t\t\tif(i%prime[j]==0) break;\n\t\t}\n\t}\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint u;\n\t\tscanf(\"%d\",&u);\n\t\ts[u]=true;\n\t}\n\tfor(int i=2;i<=N-10;i++)\n\tif(s[i]^s[i-1]) v[i&1].push_back(i);\n\tfor(int i=0;i<v[0].size();i++)\n\t\tfor(int j=0;j<v[1].size();j++)\n\t\tif(!p[abs(v[0][i]-v[1][j])]) can[i+1][j+1]=true;\n\tint ans=0;\n    for(int i=0;i<v[0].size();i++)\n\t{\n\t\tmemset(vis,0,sizeof(vis));\n\t\tans+=check(i+1);\n\t}\n\tans+=(v[0].size()-ans)/2*2+(v[1].size()-ans)/2*2;\n    if((v[0].size()&1)!=(ans&1)) ans+=3;\n\tprintf(\"%d\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/* programed by white-55kai */\n#if 0\n#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<queue>\n#include<vector>\n#include<utility>\n#include<stdlib.h>\n#include<time.h>\n#else\n#include<bits/stdc++.h>\n#endif\n\n#if 0\n#include<cmath>\n#endif\n\n#define REP(i,l,r) for (reg int i=(l);i<=(r);++i)\n#define RREP(i,r,l) for (int i=(r);i>=(l);--i)\n#define rep(i,l,r) for (int i=(l);i<(r);++i)\n#define rrep(i,r,l) for (int i=(r);i>(l);--i)\n#define foredge(i,u) for (int i=la[u];i;i=ne[i])\n#define mem(a) memset(a,0,sizeof(a))\n#define memid(a) memset(a,63,sizeof(a))\n#define memax(a) memset(a,127,sizeof(a))\n#define dbg(x) cout<<#x<<\" = \"<<x<<endl\n#define reg register\n#define tpn typename\n#define fr(a) freopen(a,\"r\",stdin)\n#define fw(a) freopen(a,\"w\",stdout)\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ldb;\n\ntemplate <tpn A> inline A Max(const A &x,const A &y){\n    return x>y?x:y;\n}\ntemplate <tpn A> inline A Min(const A &x,const A &y){\n    return x<y?x:y;\n}\ntemplate <tpn A> inline void Swap(A &x,A &y){\n    x^=y,y^=x,x^=y;\n}\ntemplate <tpn A> inline A Abs(const A &x){\n    return x>0?x:-x;\n}\n#if 1\ntemplate <tpn A> inline void read(A &x){\n    char c;\n    A neg=1;\n    do{\n        c=getchar();\n    }while ((c<'0'||c>'9')&&c!='-');\n    if (c=='-') neg=-1,c=getchar();\n    x=0;\n    do{\n        x=x*10+c-48;\n        c=getchar();\n    }while (c>='0'&&c<='9');\n    x*=neg;\n}\ntemplate <tpn A,tpn B> inline void read(A &a,B &b){\nread(a),read(b);}\ntemplate <tpn A,tpn B,tpn C> inline void read(A &a,B &b,C &c){\nread(a),read(b),read(c);}\ntemplate <tpn A,tpn B,tpn C,tpn D> inline void read(A &a,B &b,C &c,D &d){\nread(a),read(b),read(c),read(d);}\ntemplate <tpn A> inline void put(const A &tmp){\n    A x=tmp;\n    if (x==0){\n        putchar('0');\n        return;\n    }\n    if (x<0) putchar('-'),x=-x;\n    char buf[30];\n    int buf_size=0;\n    while (x){\n        buf[++buf_size]=x%10+48;\n        x/=10;\n    }\n    RREP(i,buf_size,1) putchar(buf[i]);\n}\n#else\nnamespace fastIO {\n    #define buf_size 100000\n    #define LL long long\n    bool error;\n    inline char gc() {\n        static char buf[buf_size + 1], *l = buf, *r = buf;\n        if (l == r) {\n            l = buf;\n            r = buf + fread(buf, 1, buf_size, stdin);\n            if (l == r) {\n                error = 1;\n                return -1;\n            }\n        }\n        return *l ++;\n    }\n    inline bool blank(char ch) {\n        return ch == '\\n' || ch == '\\t' || ch == ' ' || ch == '\\r' || error;\n    }\n    inline bool read_int(int &x) {\n        char ch;\n        int f = 1;\n        while (blank(ch = gc()));\n        if (error) return false;\n        x = 0;\n        if (ch == '-') f = -1, ch = gc();\n        while (1) {\n            x = (x << 1) + (x << 3) + ch - '0';\n            if (!isdigit(ch = gc())) break;\n        }\n        x *= f;\n        return true;\n    }\n    inline bool read_LL(LL &x) {\n        char ch;\n        LL f = 1;\n        while (blank(ch = gc()));\n        if (error) return false;\n        x = 0;\n        if (ch == '-') f = -1, ch = gc();\n        while (1) {\n            x = (x << 1) + (x << 3) + ch - '0';\n            if (!isdigit(ch = gc())) break;\n        }\n        x *= f;\n        return true;\n    }\n    inline bool read_char(char &x) {\n        char ch;\n        while (blank(ch = gc()));\n        if (error) return false;\n        x = ch;\n        return true;\n    }\n    inline void put_int(int x) {\n        if (!x) {\n            putchar('0');\n            return;\n        }\n        if (x < 0) {\n            x = -x;\n            putchar('-');\n        }\n        static int out[13];\n        int len = 0;\n        while (x) {\n            out[++ len] = x % 10;\n            x /= 10;\n        }\n        while (len) putchar(out[len --] + '0');\n    }\n    inline void put_LL(LL x) {\n        if (!x) {\n            putchar('0');\n            return;\n        }\n        if (x < 0) {\n            x = -x;\n            putchar('-');\n        }\n        static LL out[20];\n        int len = 0;\n        while (x) {\n            out[++ len] = x % 10;\n            x /= 10;\n        }\n        while (len) putchar(out[len --] + '0');\n    }\n    #undef buf_size\n    #undef LL\n}\nusing namespace fastIO;\n#endif\ninline int mul_mod(int a,int b,int mo){\n    int ret;\n    __asm__ __volatile__ (\"\\tmull %%ebx\\n\\tdivl %%ecx\\n\":\"=d\"(ret):\"a\"(a),\"b\"(b),\"c\"(mo));\n    return ret;\n}\nconst int N = 10000005, K = 2005, M = 2005005;\nint la[K], ne[M], en[M], c[M], edgenum;\nint dis[K], cur[K], level[K];\ninline void add(int x, int y) {\n    ne[++edgenum] = la[x];\n    en[edgenum] = y;\n    c[edgenum] = 1;\n    la[x] = edgenum;\n    ne[++edgenum] = la[y];\n    en[edgenum] = x;\n    la[y] = edgenum;\n}\ninline void bfs(int S) {\n    queue<int> q;\n    int u, v;\n    while (!q.empty()) q.pop();\n    memset(level, -1, sizeof(level));\n    level[S] = 0;\n    q.push(S);\n    while (!q.empty()) {\n        u = q.front();\n        q.pop();\n        foredge(i, u)\n        if (c[i] && level[en[i]] < 0) {\n            v = en[i];\n            level[v] = level[u] + 1;\n            q.push(v);\n        }\n    }\n}\nint dfs(int u, int t, int f) {\n    if (u == t) return f;\n    int v, d;\n    for (int &i = cur[u]; i; i = ne[i]) {\n        v = en[i];\n        if (level[v] == level[u] + 1 && c[i]) {\n            d = dfs(v, t, min(c[i], f));\n            if (d) {\n                c[i] -= d;\n                c[((i - 1) ^ 1) + 1] += d;\n                return d;\n            }\n        }\n    }\n    return 0;\n}\ninline int maxflow(int S, int T) {\n    int flow = 0, f;\n    while (1) {\n        bfs(S);\n        if (level[T] < 0) return flow;\n        REP(i, S, T) cur[i] = la[i];\n        while (f = dfs(S, T, 0x7fffffff)) flow += f;\n    }\n}\nint n, k, x, y, num[K], del[K];\nint b[N], pri[N / 10], top;\nint main() {\n    b[1] = b[2] = 1;\n    REP(i, 3, N - 4) {\n        if (!b[i] && i & 1) pri[++top] = i;\n        if (!(i & 1)) continue;\n        for (int j = 1; j <= top && i * pri[j] <= N - 4; ++j) {\n            b[i * pri[j]] = 1;\n            if (i % pri[j] == 0) break;\n        }\n    }\n    read(k);\n    REP(i, 1, k) read(num[i]);\n    sort(num + 1, num + k + 1);\n    REP(i, 1, k) {\n        if (i == 1 || num[i - 1] < num[i] - 1) del[++n] = num[i];\n        if (i == k || num[i + 1] > num[i] + 1) del[++n] = num[i] + 1;\n    }\n    REP(i, 1, n) {\n        if (del[i] & 1) num[++x] = del[i];\n        else del[++y] = del[i];\n    }\n    REP(i, 1, x) add(1, i + 1);\n    REP(i, 1, y) add(i + x + 1, n + 2);\n    REP(i, 1, x)\n    REP(j, 1, y)\n    if (!b[abs(num[i] - del[j])]) add(i + 1, j + x + 1);\n    k = maxflow(1, n + 2);\n    n = k + 2 * ((x - k) / 2 + (y - k) / 2) + 3 * (x - k & 1);\n    cout << n << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nifstream in (\"test.in\" );\nofstream out(\"test.out\");\n\nconst int DIM = 200;\nconst int DIM2 = 1e7 + 5;\n\nint dp[DIM], arr[DIM];\n\nbitset<DIM2> oki;\n\nint main(void)\n{\n    ios::sync_with_stdio(false);\n    cin.tie(); cout.tie();\n    \n    int n;\n    cin >> n;\n    \n    for (int i = 1; i <= n; ++i) {\n        cin >> arr[i];\n    }\n    \n    sort (arr + 1, arr + n + 1);\n    \n    oki[1] = false;\n    for (int i = 2; i < DIM2; ++i) {\n        if (oki[i])\n            continue;\n        \n        for (int j = i + i; j < DIM; j += i)\n            oki[j] = true;\n    }\n    \n    oki[0] = oki[1] = oki[2] = 1;\n    \n    for (int i = n; i >= 1; --i) {\n        dp[i] = 3 + dp[i + 1];\n        \n        for (int j = i + 1, nr = 0; j <= n; ++j) {\n            if ((arr[j] - arr[j - 1] + 1) % 2 == 1)\n                break;\n            \n            if (arr[j - 1] + 1 != arr[j])\n                ++nr;\n            \n            dp[i] = min(dp[i], dp[j + 1] + 1 + (nr + oki[arr[j] - arr[i] + 1]) * 2);\n        }\n    }\n    \n    cout << dp[1];\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#include <map>\nusing namespace std;\n\nconst int MAX_N = 205;\n\nclass Edge {\npublic:\n  int nxt, to;\n} e[MAX_N * MAX_N];\n\nint head[MAX_N], cnt;\nvoid addedge(int u, int v) {\n  e[++cnt] = (Edge){head[u], v}, head[u] = cnt;\n}\n\nbool isprime(int x) {\n  for (int i = 2; i * i <= x; ++i)\n    if (x % i == 0) return false;\n  return true;\n}\n\nint N, pos[MAX_N], tot, val[MAX_N], match[MAX_N];\nmap<int, bool> vis;\nbool bad[MAX_N];\n\nbool dfs(int x) {\n  if (bad[x]) return false;\n  bad[x] = 1;\n  for (int i = head[x]; i; i = e[i].nxt)\n    if (!match[e[i].to] || dfs(match[e[i].to])) {\n      match[e[i].to] = x;\n      return true;\n    }\n  return false;\n}\n\nint main() {\n  scanf(\"%d\", &N);\n  for (int i = 1; i <= N; ++i) \n    scanf(\"%d\", &pos[i]);\n  pos[0] = -1;\n  for (int i = 1; i <= N; ++i) {\n    if (pos[i - 1] != pos[i] - 1) val[++tot] = pos[i];\n    if (pos[i + 1] != pos[i] + 1) val[++tot] = pos[i] + 1;\n  }\n  \n  int odd = 0, even = 0;\n  \n  for (int i = 1; i <= tot; ++i)\n    if (val[i] & 1) {\n      odd++;\n      for (int j = 1; j <= tot; ++j)\n\tif (!(val[j] & 1) && abs(val[i] - val[j]) > 1 && isprime(abs(val[i] - val[j])))\n\t  addedge(i, j);\n    } else {\n      even++;\n    }\n\n  int num = 0;\n  for (int i = 1; i <= tot; ++i) \n    if (val[i] & 1) {\n      memset(bad, 0, sizeof bad);\n      num += dfs(i);\n    }\n\n  printf(\"%d\\n\", num + ((odd - num) / 2 + (even - num) / 2) * 2 + (odd - num) % 2 * 3);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<set>\n#include<map>\n#include<cmath>\n#include<queue>\n#include<bitset>\n#include<string>\n#include<cstdio>\n#include<cctype>\n#include<cassert>\n#include<cstdlib>\n#include<cstring>\n#include<sstream>\n#include<iostream>\n#include<algorithm>\n\n#define For(i,x,y) for (int i=x;i<y;i++)\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define lf else if\n\n#define dprintf(...) fprintf(stderr,__VA_ARGS__)\nusing namespace std;\n\ntypedef long long ll;\ntypedef double db;\ntypedef pair<int,int> pii;\ntypedef vector<int> Vi;\n\nint IN(){\n\tint c,f,x;\n\twhile (!isdigit(c=getchar())&&c!='-');c=='-'?(f=1,x=0):(f=0,x=c-'0');\n\twhile (isdigit(c=getchar())) x=(x<<1)+(x<<3)+c-'0';return !f?x:-x;\n}\n\nconst int top=1e7+19;\nconst int N=top+19;\nconst int M=10000;\nconst int oo=(1<<30)-1;\n\nstruct Edge{\n\tint y,f,nxt;\n} E[M];\n\nint vis[N],pri[N],A[N];\nint x[M],y[M],las[M],dis[M];\nint n,cnt,S,T,ans,res;\n\nvoid Add_Edge(int x,int y,int f){\n\tE[cnt]=(Edge){y,f,las[x]};las[x]=cnt++;\n\tE[cnt]=(Edge){x,0,las[y]};las[y]=cnt++;\n}\nbool bfs(){\n\tstatic int Q[M];\n\tmemset(dis,-1,sizeof(dis));\n\tdis[S]=1;\n\tint f=1,w=0;Q[1]=S;\n\twhile (f>w){\n\t\tint x=Q[++w];\n\t\tfor (int i=las[x],y;~i;i=E[i].nxt)\n\t\t\tif (E[i].f&&dis[y=E[i].y]==-1){\n\t\t\t\tdis[y]=dis[x]+1;\n\t\t\t\tQ[++f]=y;\n\t\t\t}\n\t}\n\treturn dis[T]!=-1;\n}\nint dinic(int x,int flow){\n\tif (x==T||!flow) return flow;\n\tint res=0;\n\tfor (int i=las[x],y;~i;i=E[i].nxt)\n\t\tif (E[i].f&&dis[y=E[i].y]==dis[x]+1){\n\t\t\tint tmp=dinic(y,min(flow,E[i].f));\n\t\t\tE[i].f-=tmp,E[i^1].f+=tmp,flow-=tmp,res+=tmp;\n\t\t}\n\tif (!res) dis[x]=-1;\n\treturn res;\n}\n\nvoid Init(){\n\tvis[1]=1;\n\tFor(i,2,top+1){\n\t\tif (!vis[i]) pri[++*pri]=i;\n\t\tfor (int j=1;j<=*pri&&pri[j]*i<=top;j++){\n\t\t\tvis[pri[j]*i]=1;\n\t\t\tif (i%pri[j]==0) break;\n\t\t}\n\t}\n}\n\nint main(){\n\tmemset(las,-1,sizeof(las));\n\tInit();\n\tn=IN();\n\tFor(i,1,n+1) A[IN()]=1;\n\tfor (int i=top;i;i--) A[i]^=A[i-1];\n\tFor(i,1,top+1) if (A[i]){\n\t\tif (i&1) x[++*x]=i;else y[++*y]=i;\n\t}\n\tS=*x+*y+1,T=S+1;\n\tFor(i,1,*x+1) Add_Edge(S,i,1);\n\tFor(i,1,*y+1) Add_Edge(i+*x,T,1);\n\tFor(i,1,*x+1) For(j,1,*y+1){\n\t\tif (!vis[abs(x[i]-y[j])]) Add_Edge(i,j+*x,1);\n\t}\n\twhile (bfs()) ans+=dinic(S,oo);\n\tres=ans;\n\tif ((*x-ans)&1){\n\t\tres+=3;\n\t\tres+=(*x-ans-1)+(*y-ans-1);\n\t} else{\n\t\tres+=(*x-ans)+(*y-ans);\n\t}\n\tprintf(\"%d\\n\",res);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<cstring>\nusing namespace std;\nint n;\nint res;\nvector<int>v;\nint lst=-1;\nint match[210];\nint me,mo;\nint mx;\nbool f[10000010];\nbool ok[210][210];\nbool vis[210];\nint prm[1000010];\nint sz;\nint l;\nbool bp(int x)\n{\n\tfor(int i=0;i<l;i++)\n\t{\n\t\tif(!ok[x][i])continue;\n\t\tif(vis[i])continue;\n\t\tvis[i]=true;\n\t\tif(match[i]==-1 || bp(match[i]))\n\t\t{\n\t\t\tmatch[i]=x;\n\t\t\tmatch[x]=i;\n\t\t\treturn true;\n\t\t}\n\t\tvis[i]=false;\n\t}\n\treturn false;\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint x;\n\t\tscanf(\"%d\",&x);\n\t\tif(x!=lst+1)\n\t\t{\n\t\t\tif(lst+1)v.push_back(lst+1);\n\t\t\tv.push_back(x);\n\t\t}\n\t\tlst=x;\n\t\tmx=lst+1;\n\t}\n\tv.push_back(lst+1);\n\tf[1]=true;\n\tfor(int i=2;i<=mx;i++)\n\t{\n\t\tif(!f[i])prm[++sz]=i;\n\t\tfor(int j=1;j<=sz;j++)\n\t\t{\n\t\t\tif(prm[j]*i>mx)break;\n\t\t\tf[prm[j]*i]=true;\n\t\t\tif(i%prm[j]==0)break;\n\t\t}\n\t}\n\tl=v.size();\n\tfor(int i=0;i<l;i++)\n\t{\n\t\tmatch[i]=-1;\n\t\tif(v[i]&1)mo++;else me++;\n\t\tfor(int j=i+1;j<l;j++)\n\t\t{\n\t\t\tif(v[j]-v[i]!=2 && !f[v[j]-v[i]])\n\t\t\t{\n\t\t\t\tok[i][j]=ok[j][i]=true;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<l;i++)\n\t{\n\t\tif(match[i]!=-1)continue;\n\t\tmemset(vis,false,sizeof(vis));\n\t\tif(bp(i))res++;\n\t}\n\tprintf(\"%d\",res+((me-res)/2+(mo-res)/2)*2+((me-res)%2)*3);\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define maxn 300\n#define maxm 100100\nusing namespace std;\nstruct edge{\n    int r,nxt,w;\n}e[maxm];\nint head[maxn],esz,S,T,dep[maxn],q[maxn],ql,qr,cur[maxn];\nvoid addedge(int u,int v,int w){\n    e[esz].r=v;\n    e[esz].nxt=head[u];\n    e[esz].w=w;\n    head[u]=esz++;\n    e[esz].r=u;\n    e[esz].nxt=head[v];\n    e[esz].w=0;\n    head[v]=esz++;\n}\nbool bfs(){\n    ql=qr=0;\n    q[qr++]=S;\n//\tprintf(\"[ok,%d,%d]\",S,T);\n    for(int i=S;i<=T;++i)dep[i]=0,cur[i]=head[i];\n    dep[S]=1;\n    while(ql<qr){\n        int x=q[ql++];\n        for(int t=head[x];t;t=e[t].nxt)if(!dep[e[t].r]&&e[t].w)\n            dep[e[t].r]=dep[x]+1,q[qr++]=e[t].r;\n    }\n    \n    return dep[T]!=0;\n}\nint find(int u,int flow){\n    if(u==T)return flow;\n    int a=0,used=0;\n    for(int& t=cur[u];t;t=e[t].nxt)if(e[t].w&&dep[e[t].r]==dep[u]+1&&(a=find(e[t].r,min(flow-used,e[t].w)))){\n        e[t].w-=a;e[t^1].w+=a,used+=a;\n        if(used==flow)return used;\n           \n    }\n    if(!used)dep[u]=0;\n    return used;\n}\nint dinic(){\n\tint ans=0,a=0;\n\twhile(bfs())\n\t\twhile(a=find(S,1<<30))ans+=a;\n\treturn ans;\n}\nconst int lim=10000010;\nint pri[lim],psz,n,a[maxn],tp,d[2];\nbool vis[lim],c[lim];\nint main(){\n\tfor(int i=2;i<lim;++i){\n\t\tif(!vis[i])pri[++psz]=i;\n\t\tfor(int j=1;j<=psz&&pri[j]*i<lim;++j){\n\t\t\tvis[i*pri[j]]=1;if(i%pri[j]==0)break;\n\t\t}\n\t}\n\tscanf(\"%d\",&n);\n\tfor(int i=1,x;i<=n;++i)scanf(\"%d\",&x),c[x]^=1,c[x+1]^=1;\n\tfor(int i=1;i<lim;++i)if(c[i])a[++tp]=i;\n\tS=0,T=tp+1,vis[2]=1;\n\tfor(int i=1;i<=tp;++i)\n\t\tfor(int j=i+1;j<=tp;++j)if((a[i]&1)!=(a[j]&1)){\n//\t\t\tprintf(\"{%d,%d}\",a[i],a[j]);\n\t\t\tif(!vis[a[j]-a[i]]){\n\t\t\t\tif(a[i]&1)addedge(i,j,1);\n\t\t\t\telse addedge(j,i,1);\n\t\t\t}\n\t\t}\n\tfor(int i=1;i<=tp;++i)if(a[i]&1)addedge(S,i,1);else addedge(i,T,1);\n\tint ans=dinic();\n\tfor(int i=1;i<=tp;++i)d[a[i]&1]++;\n\td[0]-=ans,d[1]-=ans;\n\tif(d[0]%2)ans+=3,d[0]--,d[1]--;\n\tans+=d[0]+d[1];\n\tprintf(\"%d\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<cstring>\nusing namespace std;\nint n;\nint res;\nvector<int>v;\nint lst=-1;\nint match[210];\nint me,mo;\nint mx;\nbool f[10000010];\nbool ok[210][210];\nbool vis[210];\nint prm[1000010];\nint sz;\nint l;\nbool bp(int x)\n{\n\tfor(int i=0;i<l;i++)\n\t{\n\t\tif(!ok[x][i])continue;\n\t\tif(vis[i])continue;\n\t\tvis[i]=true;\n\t\tif(match[i]==-1 || bp(match[i]))\n\t\t{\n\t\t\tmatch[i]=x;\n\t\t\tmatch[x]=i;\n\t\t\treturn true;\n\t\t}\n\t\tvis[i]=false;\n\t}\n\treturn false;\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint x;\n\t\tscanf(\"%d\",&x);\n\t\tif(x!=lst+1)\n\t\t{\n\t\t\tif(lst+1)v.push_back(lst+1);\n\t\t\tv.push_back(x);\n\t\t}\n\t\tlst=x;\n\t\tmx=lst+1;\n\t}\n\tv.push_back(lst+1);\n\tf[1]=true;\n\tfor(int i=2;i<=mx;i++)\n\t{\n\t\tif(!f[i])prm[++sz]=i;\n\t\tfor(int j=1;j<=sz;j++)\n\t\t{\n\t\t\tif(prm[j]*i>mx)break;\n\t\t\tf[prm[j]*i]=true;\n\t\t\tif(i%prm[j]==0)break;\n\t\t}\n\t}\n\tl=v.size();\n\tfor(int i=0;i<l;i++)\n\t{\n\t\tmatch[i]=-1;\n\t\tif(v[i]&1)mo++;else me++;\n\t\tfor(int j=i+1;j<l;j++)\n\t\t{\n\t\t\tif(v[j]-v[i]!=2 && !f[v[j]-v[i]])\n\t\t\t{\n\t\t\t\tok[i][j]=ok[j][i]=true;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<l;i++)\n\t{\n\t\tif(match[i])continue;\n\t\tmemset(vis,false,sizeof(vis));\n\t\tif(bp(i))res++;\n\t}\n\tprintf(\"%d\",res+((me-res)/2+(mo-res)/2)*2+((me-res)%2)*3);\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\nconst int N = 203, M = 10001003;\nbool ispri[M], vs[N];\nint a[N], tot;\nint n, Ans;\n\nvoid input() {\n\tint x, y;\n\tscanf(\"%d%d\", &n, &x);\n\ta[tot = 1] = x;\n\tfor(int i=2;i<=n;++i) {\n\t\tscanf(\"%d\", &y);\n\t\tif(x+1 != y) a[++tot] = x+1, a[++tot] = y;\n\t\tx = y;\n\t}\n\ta[++tot] = ++x;\n\t\n\tfor(int i=2;i<=x;++i) ispri[i] = true;\n\tfor(int i=2;i<=x;++i) if(ispri[i])\n\t\tfor(int j=i+i;j<=x;j+=i) ispri[j] = false;\n\tispri[2] = false;\n}\n\nnamespace Part1 {\n\tstruct Edge {int v, w, nxt;} e[N*N];\n\tint head[N], cur[N];\n\tint q[N], he, ta, dis[N];\n\tint s, t, _;\n\t\n\tinline void add(int x, int y) {\n\t\te[++_].v = y, e[_].w = 1, e[_].nxt = head[x], head[x] = _;\n\t\te[++_].v = x, e[_].w = 0, e[_].nxt = head[y], head[y] = _;\n\t}\n\t\n\tvoid init() {\n\t\ts = tot + 1, t = s + 1, _ = 1;\n\t\tfor(int i=1;i<=t;++i) head[i] = 0;\n\t}\n\t\n\tbool bfs() {\n\t\tfor(int i=1;i<=t;++i) dis[i] = -1;\n\t\tdis[q[he = ta = 1] = s] = 0;\n\t\twhile(he <= ta) {\n\t\t\tint x = q[he++];\n\t\t\tfor(int i=head[x];i;i=e[i].nxt)\n\t\t\t\tif(e[i].w and -1 == dis[e[i].v]) {\n\t\t\t\t\tdis[q[++ta] = e[i].v] = dis[x] + 1;\n\t\t\t\t\tif(e[i].v == t) return true;\n\t\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\t\n\tint dfs(int x, int flw) {\n\t\tif(x == t or !flw) return flw;\n\t\tint res = 0, tmp;\n\t\tfor(int&i=cur[x];i;i=e[i].nxt)\n\t\t\tif(e[i].w and dis[e[i].v] == dis[x] + 1)\n\t\t\tif(tmp = dfs(e[i].v, e[i].w)) {\n\t\t\t\te[i].w -= tmp, e[i^1].w += tmp, res += tmp;\n\t\t\t\tif(res == flw) return res;\n\t\t\t}\n\t\tif(!res) dis[x] = -1;\n\t\treturn res;\n\t}\n\t\n\tint Dinic() {\n\t\tconst int oo = 1e9;\n\t\tint res = 0;\n\t\twhile(bfs()) {\n\t\t\tfor(int i=1;i<=t;++i) cur[i] = head[i];\n\t\t\tres += dfs(s, +oo);\n\t\t}\n\t\treturn res;\n\t}\n\n\tinline int abs(const int x) {return x < 0 ? -x : x;}\t\n\t\n\tvoid work() {\n\t\tinit();\n\t\tfor(int i=1;i<=tot;++i)\n\t\t\tif(a[i]&1) add(s, i);\n\t\t\n\t\tfor(int i=1;i<=tot;++i) if(a[i]&1)\n\t\tfor(int j=1;j<=tot;++j) if(~a[j]&1)\n\t\t\tif(ispri[abs(a[i] - a[j])]) add(i, j);\n\t\t\n\t\tfor(int i=1;i<=tot;++i)\n\t\t\tif(~a[i]&1) add(i, t);\n\t\n\t\tAns += Dinic();\n\t\tfor(int i=head[s];i;i=e[i].nxt)\n\t\t\tif(!e[i].w) vs[e[i].v] = true;\n\t\tfor(int i=head[t];i;i=e[i].nxt)\n\t\t\tif(e[i].w) vs[e[i].v] = true;\n\t}\n}\n\nvoid Part23() {\n\tint ct[2] = {0, 0};\n\tfor(int i=1;i<=tot;++i)\n\t\tif(!vs[i]) ++ct[a[i]&1];\n\tAns += ct[0] ^ (ct[0] & 1);\n\tAns += ct[1] ^ (ct[1] & 1);\n\tAns += (ct[0] & ct[1] & 1) * 3;\n}\n\nint main() {\n\tinput();\n\t\n\tPart1::work();\n\tPart23();\n\t\n\tprintf(\"%d\\n\", Ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define maxn 10000005\n#define maxv 205\nusing namespace std;\nint prime[maxn/2];\nbool vis[maxn];\nint inde=0;\nvoid primejudge(int n)\n{\n    vis[1]=true;\n    int i,j;\n    for(i=2;i<=n;i++)\n    {\n        if(!vis[i])\n        {\n            prime[inde++]=i;\n        }\n        for(j=0;j<inde&&prime[j]*i<=n;j++)\n            {\n                vis[i*prime[j]]=true;\n                if(i%prime[j]==0) break;\n            }\n    }\n    vis[2]=true;\n}\nint cnt1,cnt2;\nbool used[maxv];\nint bel[maxv];\nbool v[maxn];\nint s[maxn];\nint mp1[maxv];\nint mp2[maxv];\nbool match[maxv][maxv];\nbool findd(int x)\n{   int i;\n    for(i=0;i<cnt2;i++)\n    {\n        if(match[x][i]&&used[i]==false)\n        {\n            used[i]=true;\n            if(!bel[i]||findd(bel[i]))\n            {\n                bel[i]=x;\n                return true;\n            }\n        }\n    }\n    return false;\n}\nint main()\n{\n  int n,i,u,cnt=0;\n  primejudge(10000002);\n  scanf(\"%d\",&n);\n  for(i=1;i<=n;i++)\n  {\n      scanf(\"%d\",&u);\n      v[u]=true;\n  }\n  for(i=1;i<=maxn-2;i++)\n  {\n      if(v[i]!=v[i-1])\n      {\n          s[cnt++]=i;\n      }\n  }\n  for(i=0;i<cnt;i++)\n  {\n      if(s[i]&1)\n      {\n          mp1[cnt1++]=s[i];\n      }\n      else\n      {\n          mp2[cnt2++]=s[i];\n      }\n  }\n  for(i=0;i<cnt1;i++)\n  {\n      for(int j=0;j<cnt2;j++)\n      {\n          if(!vis[abs(mp1[i]-mp2[j])])\n          {\n              match[i][j]=true;\n          }\n      }\n  }\n  int sum=0;\n  for(i=0;i<cnt1;i++)\n  {\n      memset(used,false,sizeof(used));\n      if(findd(i)) sum++;\n  }\n  int ans=sum;\n  cnt1-=sum;\n  cnt2-=sum;\n  ans+=cnt1/2*2;\n  ans+=cnt2/2*2;\n  ans+=cnt1%2*3;\n  cout<<ans<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define rep(i, a, b) for(int i = a; i < (b); ++i)\n#define trav(a, x) for(auto& a : x)\n#define all(x) begin(x), end(x)\n#define sz(x) (int)(x).size()\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\nbool dfs(int a, int L, vector<vi>& g, vi& btoa, vi& A, vi& B) {\n\tif (A[a] != L) return 0;\n\tA[a] = -1;\n\ttrav(b, g[a]) if (B[b] == L + 1) {\n\t\tB[b] = 0;\n\t\tif (btoa[b] == -1 || dfs(btoa[b], L + 1, g, btoa, A, B))\n\t\t\treturn btoa[b] = a, 1;\n\t}\n\treturn 0;\n}\n\nint hopcroftKarp(vector<vi>& g, vi& btoa) {\n\tint res = 0;\n\tvi A(g.size()), B(btoa.size()), cur, next;\n\tfor (;;) {\n\t\tfill(all(A), 0);\n\t\tfill(all(B), 0);\n\t\t/// Find the starting nodes for BFS (i.e. layer 0).\n\t\tcur.clear();\n\t\ttrav(a, btoa) if(a != -1) A[a] = -1;\n\t\trep(a,0,sz(g)) if(A[a] == 0) cur.push_back(a);\n\t\t/// Find all layers using bfs.\n\t\tfor (int lay = 1;; lay++) {\n\t\t\tbool islast = 0;\n\t\t\tnext.clear();\n\t\t\ttrav(a, cur) trav(b, g[a]) {\n\t\t\t\tif (btoa[b] == -1) {\n\t\t\t\t\tB[b] = lay;\n\t\t\t\t\tislast = 1;\n\t\t\t\t}\n\t\t\t\telse if (btoa[b] != a && !B[b]) {\n\t\t\t\t\tB[b] = lay;\n\t\t\t\t\tnext.push_back(btoa[b]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (islast) break;\n\t\t\tif (next.empty()) return res;\n\t\t\ttrav(a, next) A[a] = lay;\n\t\t\tcur.swap(next);\n\t\t}\n\t\t/// Use DFS to scan for augmenting paths.\n\t\trep(a,0,sz(g))\n\t\t\tres += dfs(a, 0, g, btoa, A, B);\n\t}\n}\n\nconst int V = 1.1e7;\nbool isPrime[V + 1];\n\nint main() {\n\tios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\tfor (int i = 2; i <= V; i++) isPrime[i] = true;\n\tfor (int p = 2; p <= V; p++) {\n\t\tif (!isPrime[p]) continue;\n\t\tfor (int j = p+p; j <= V; j += p) isPrime[j] = false;\n\t}\n\n\tint N; cin >> N;\n\tvector<int> X(N);\n\tmap<int, int> evtCnt;\n\tfor (int i = 0; i < N; i++) {\n\t\tcin >> X[i];\n\t\tevtCnt[X[i]] ^= 1;\n\t\tevtCnt[X[i]+1] ^= 1;\n\t}\n\tvector<int> left;\n\tvector<int> right;\n\tfor (auto it : evtCnt) {\n\t\tif (it.second == 0) continue;\n\t\tif (it.first & 1) right.push_back(it.first);\n\t\telse left.push_back(it.first);\n\t}\n\n\tint A = int(left.size());\n\tint B = int(right.size());\n\tvector<vector<int>> g(A);\n\tvector<int> btoa(B, -1);\n\tisPrime[2] = false;\n\tfor (int i = 0; i < A; i++) {\n\t\tfor (int j = 0; j < B; j++) {\n\t\t\tif (isPrime[abs(left[i] - right[j])]) {\n\t\t\t\tg[i].push_back(j);\n\t\t\t}\n\t\t}\n\t}\n\n\tint ans = hopcroftKarp(g, btoa); // number that can be paired\n\tcerr << ans << ' ' << A << ' ' << B << '\\n';\n\tA -= ans, B -= ans;\n\tcout << ans + (A/2) * 2 + (B/2) * 2 + (A % 2 ? 3 : 0) << '\\n';\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define met(a) memset(a,0,sizeof(a))\n#define inf 0x3f3f3f3f\nusing namespace std;\nconst int mod=1e9+7;\nll a[110];\nint b[25]= {3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97};\nbool cmp(int x,int y)\n{\n    return x>y;\n}\nint main()\n{\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n    met(a);\n    int i,j,k,m,n,cnt=0,ans=0;\n    cin>>n;\n    for(i=1; i<=n; i++)\n        cin>>a[i];\n    sort(a+1,a+1+n);\n    for(i=0; i<24; i++)\n    {\n        if(n%b[i]==0)\n        {\n            cout<<n/b[i];\n            return 0;\n        }\n    }\n    for(i=2; i<=n; i++)\n    {\n        if(a[i]==a[i-1]+1)\n        {\n            cnt++;\n            if(i==n)\n                ans+=2;\n        }\n        else\n        {\n            ans+=2;\n        }\n    }\n    cout<<ans<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n  \nusing namespace std;\n  \n#define rep(i,n) REP(i,0,n)\n#define REP(i,s,e) for(int i=(s); i<(int)(e); i++)\n#define repr(i, n) REPR(i, n, 0)\n#define REPR(i, s, e) for(int i=(int)(s-1); i>=(int)(e); i--)\n#define pb push_back\n#define all(r) r.begin(),r.end()\n#define rall(r) r.rbegin(),r.rend()\n#define fi first\n#define se second\n  \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n \nconst int INF = 1e9;\nconst ll MOD = 1e9 + 7;\ndouble EPS = 1e-8;\n\n#define MAX_V 110\n \nstruct Edge\n{\n    int to, cap, rev;\n    Edge(){};\n    Edge(int to, int cap, int rev) : to(to), cap(cap), rev(rev){};\n};\n \nvector<Edge> G[MAX_V];\nbool used[MAX_V];\n \nvoid add_edge(int from, int to, int cap){\n    G[from].push_back({to, cap, (int)G[to].size()});\n    G[to].push_back({from, 0, (int)G[from].size()-1});\n}\n \nint dfs(int v, int t, int f){\n    if(v == t) return f;\n    used[v] = true;\n    for(int i = 0; i < G[v].size(); i++){\n        Edge& e = G[v][i];\n        if(!used[e.to] && e.cap > 0){\n            int d = dfs(e.to, t, min(f, e.cap));\n            if(d > 0){\n                e.cap -= d;\n                G[e.to][e.rev].cap += d;\n                return d;\n            }\n        }\n    }\n    return 0;\n}\n \nint max_flow(int s, int t){\n    int flow = 0;\n    while(1){\n        memset(used, 0, sizeof(used));\n        int f = dfs(s, t, INF);\n        if(f == 0) return flow;\n        flow += f;\n    }\n}\n\n//エラトステネスの篩を使用\nconst int MAX_PRIME = 1e7 + 10;\n \nvector<int> is_prime(MAX_PRIME,1);\n \nvoid calcPrime(){\n    is_prime[0]=is_prime[1]=0;\n    for(int i=2; i<MAX_PRIME; i++){\n        if(is_prime[i]==1){\n            for(int j=i*2; j<MAX_PRIME; j+=i){\n                is_prime[j]=0;\n            }\n        }\n    }\n}\n\nint main(){\n\tcalcPrime();\n\tint n;\n\tcin >> n;\n\tvi x(n);\n\trep(i, n) cin >> x[i];\n\tconst int MAX = 1e7+10;\n\tvi a(MAX), b(MAX);\n\trep(i, n) a[x[i]] = 1;\n\trep(i, MAX-1) b[i] = a[i]^a[i+1];\n\tvi odd, even;\n\trep(i, MAX) if(b[i]) (i&1?odd:even).pb(i);\n\trep(i, odd.size()) rep(j, even.size()) {\n\t\tif(abs(odd[i]-even[j]) >= is_prime.size()) return 0;\n\t\tif(is_prime[abs(odd[i]-even[j])]) add_edge(i, odd.size()+j, 1);\n\t}\n\tif(n+1 >= MAX_V) return 0;\n\trep(i, odd.size()) add_edge(n, i, 1);\n\trep(i, even.size()) add_edge(odd.size()+i, n+1, 1);\n\tint f = max_flow(n, n+1);\n\tint ans = f + (odd.size()-f)/2*2 + (even.size()-f)/2*2;\n\tif((odd.size()-f)&1) ans += 3;\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int N=160005,M=480005,oo=1e9;\nstruct edge{\n\tint di,nextt,ed;\n}e[M];\nint son[N],nedge,cur[N],deep[N],n,m;\ninline void aedge(int a,int b,int c){\n\te[++nedge].nextt=son[a];\n\tson[a]=nedge;\n\te[nedge].ed=b;\n\te[nedge].di=c;\n}\ninline void insert(int a,int b,int c){\n\taedge(a,b,c); aedge(b,a,0); //cout<<a<<\" \"<<b<<endl;\n}\ninline bool bfs(int s,int t){\n\tfor(int i=1;i<N;i++)deep[i]=oo;\n    for(int i=1;i<N;i++)cur[i]=son[i];\n    deep[s]=0;\n    queue<int> q;\n    q.push(s);\n    while(!q.empty()){\n        int now=q.front();q.pop();\n        for(int tmp=son[now];tmp;tmp=e[tmp].nextt)\n            if(deep[e[tmp].ed]>=oo&&e[tmp].di){deep[e[tmp].ed]=deep[now]+1,q.push(e[tmp].ed);}\n    }\n    return deep[t]<oo;\n}\nint dfs(int now,int t,int limit){\n    if(!limit||now==t) return limit;\n    int flow=0,f;\n    for(int tmp=cur[now];tmp;tmp=e[tmp].nextt){\n        cur[now]=tmp;\n        if(deep[e[tmp].ed]==deep[now]+1&&(f=dfs(e[tmp].ed,t,min(limit,e[tmp].di)))){\n            flow+=f; limit-=f; e[tmp].di-=f; e[((tmp-1)^1)+1].di+=f; if(!limit)break;\n        }\n    }\n    return flow;\n}\ninline int dinic(int s,int t){\n    int ans=0;\n    while(bfs(s,t))ans+=dfs(s,t,oo);\n    return ans;\n}\ninline int read(){\n\tint x=0;char ch=getchar();bool positive=1;\n\tfor(;!isdigit(ch);ch=getchar())\tif(ch == '-')\tpositive=0;\n\tfor(;isdigit(ch);ch=getchar())\tx=x * 10 + ch - '0';\n\treturn positive ? x : -x;\n}\ninline void write(int a){\n    if(a>=10)write(a/10);\n    putchar('0'+a%10);\n}\ninline void writeln(int a){\n    if(a<0){\n    \ta=-a;putchar('-');\n\t}\n\twrite(a);puts(\"\");\n}\nconst int P=10000005;\nint tot,q[P/10];\nbool heshu[P],a[P];\nint b[205];\nint main(){\n    n=read();\n\tfor(int i=2;i<P;i++){\n\t\tif(!heshu[i])q[++tot]=i;\n\t\tfor(int j=1;j<=tot&&i*q[j]<P;j++){\n\t\t\theshu[i*q[j]]=1; if(i%q[j]==0)break;\n\t\t}\n\t}\n\ttot=0;\n\tfor(int i=1;i<=n;i++){\n\t\tint t=read(); a[t]^=1; a[t+1]^=1;\n\t}\n\theshu[1]=1;\n\tint jb=0;\n\tfor(int i=1;i<P;i++)if(a[i])b[++jb]=i;\n\tfor(int i=1;i<=jb;i++)if(b[i]&1){\n\t\tfor(int j=1;j<=jb;j++)if(b[j]%2==0){\n\t\t\tif(!heshu[abs(b[i]-b[j])]){insert(i,j,1);}\n\t\t}\n\t}\n\tint s=jb+1,t=jb+2;\n\tfor(int i=1;i<=jb;i++)if(b[i]&1){insert(s,i,1); tot++; }else insert(i,t,1);\n\tint jj=dinic(s,t); \n\tcout<<jj+(jb-jj*2)+((tot-jj)&1)<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <cstring>\n#include <cmath>\nusing namespace std;\n\nconst int MAX_N = 100 + 9;\nconst int MAX_M = 1e7 + 9;\n\nint N, x, cnt, match[MAX_N * 2 + 2], V;\nbool is_prime[MAX_M + 1], rev[MAX_M + 2], used[MAX_N * 2 + 2];\nvector<int> primes, v1, v2, G[MAX_N * 2 + 2];\n\nvoid sieve() {\n\tmemset(is_prime, 1, sizeof(is_prime));\n\tis_prime[0] = is_prime[1] = 0;\n\tfor (int i = 2; i <= MAX_M; i++) {\n\t\tif (is_prime[i]) {\n\t\t\tprimes.push_back(i);\n\t\t\tfor (int j = i * 2; j <= MAX_M; j += i) is_prime[j] = 0;\n\t\t}\n\t}\n}\n\nbool dfs(int v) {\n\tused[v] = true;\n\tfor (int i = 0; i < G[i].size(); i++) {\n\t\tint u = G[u][i], w = match[u];\n\t\tif (w < 0 || !used[w] && dfs(w)) {\n\t\t\tmatch[v] = u;\n\t\t\tmatch[u] = v;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nvoid bipartite_matching() {\n\tmemset(match, -1, sizeof(match));\n\tfor (int v = 0; v < V; v++) {\n\t\tif (match[v] < 0) {\n\t\t\tmemset(used, 0, sizeof(used));\n\t\t\tif (dfs(v)) {\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\tscanf(\"%d\", &N); sieve();\n\tfor (int i = 1; i <= N; i++) scanf(\"%d\", &x), rev[x] ^= true;\n\tfor (int i = 1; i <= MAX_M; i++) {\n\t\tif (rev[i] != rev[i - 1]) {\n\t\t\tif (i & 1) v1.push_back(i);\n\t\t\telse v2.push_back(i);\n\t\t}\n\t}\n\tfor (int i = 0; i < v1.size(); i++) {\n\t\tfor (int j = 0; j < v2.size(); j++) {\n\t\t\tif (is_prime[(int)abs(v1[i] - v2[j])]) G[i].push_back(j + v1.size());\n\t\t}\n\t}\n\tV = v1.size() + v2.size();\n\tbipartite_matching();\n\tprintf(\"%d\", cnt + (v1.size() - cnt >> 1 << 1) + (v2.size() - cnt >> 1 << 1) + ((v1.size() - cnt) & 1) * 3);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int maxp=1000050;\nint n;\nint sum[105],a[105],l[105],pos[105];\nint tot=0,tot1=0;\nint prime[maxp],primesize;\nbool isprime[maxp];\nvoid getlist(int listsize)\n{\n    memset(isprime,1,sizeof(isprime));\n    isprime[1]=false;\n    for(int i=2;i<=listsize;i++)\n    {\n        if(isprime[i]&&i!=2)\n\t\t\tprime[++primesize]=i;\n\t\tif(!isprime[i])\n\t\t\tcontinue;\n\t\tfor(int j=1;j<=primesize&&i*prime[j]<=listsize;j++)\n\t\t{\n            isprime[i*prime[j]]=false;\n            if(i%prime[j]==0)\n\t\t\t\tbreak;\n        }\n    }\n}\nint main() {\n\tgetlist(maxp-50);\n\tscanf(\"%d\",&n);\n\tsum[++tot]=1;\n\tfor(int i=1;i<=n;i++) {\n\t\tscanf(\"%d\",&a[i]);\n\t\tif(i==1)\n\t\t\tcontinue;\n\t\tif(a[i]==a[i-1]+1)\n\t\t\tsum[tot]++;\n\t\telse {\n\t\t\tif(sum[tot]==1) {\n\t\t\t\tl[++tot1]=tot;\n\t\t\t\tpos[tot1]=a[i-1];\n\t\t\t}\n\t\t\tsum[++tot]=1;\n\t\t}\n\t}\n\tif(sum[tot]==1) {\n\t\tl[++tot1]=tot;\n\t\tpos[tot1]=a[n];\n\t}\n\tint sumx=0;\n\tfor(int i=1;i<=tot;i++) {\n\t\tint tmp=sum[i];\n\t\tif(isprime[tmp]&&tmp!=2) {\n\t\t\tsumx++;\n\t\t\tcontinue;\n\t\t}\n\t\telse if(tmp%2==0) {\n\t\t\tsumx+=2;\n\t\t\tcontinue;\n\t\t}\n\t\telse if(tmp%2==1&&tmp!=1) {\n\t\t\tsumx+=3;\n\t\t\tcontinue;\n\t\t}\n\t\telse if(tmp==1)\n\t\t\tcontinue;\n\t}\n//\tcout<<tot1<<endl;\n\tfor(int i=1;i<=tot1;) {\n\t\tif(i<tot1) {\n\t\t\tif(l[i]==l[i+1]-1) {\n\t\t\t\tint tmp=pos[i+1],tmp1=pos[i];\n\t\t\t\tint tmp2=tmp-tmp1-1;\n\t\t\t\tint tmp3=tmp-tmp1;\n\t\t\t\tint tmp4=tmp-tmp1+1;\n\t\t\t\tif(tmp2%2==0) {\n\t\t\t\t\tsumx+=4;\n\t\t\t\t\ti+=2;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(isprime[tmp2]&&isprime[tmp4]) {\n\t\t\t\t\tsumx+=2;\n\t\t\t\t\ti+=2;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(isprime[tmp3]) {\n\t\t\t\t\tsumx+=2;\n\t\t\t\t\ti+=2;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif((isprime[tmp2]&&!isprime[tmp4])||(isprime[tmp4]&&!isprime[tmp2])) {\n\t\t\t\t\tsumx+=4;\n\t\t\t\t\ti+=2;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(!isprime[tmp2]&&!isprime[tmp4]) {\n\t\t\t\t\tsumx+=6;\n\t\t\t\t\ti+=2;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsumx+=3;\n\t\t\t\ti++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\telse if(i==tot1) {\n\t\t\tsumx+=3;\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\t}\n\tprintf(\"%d\\n\",sumx);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": " #define PROB ChangingChange\n\n#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long LL;\n#define rep(i, l, r) for (int i = l; i<r;i++)\n#define all(b) b.begin() , b.end()\n#define mp(a, b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define vi vector<int>\n#define vd vector<double>\n#define vs vector<string>\n#define vii vector<pair<int,int>>\n#define vvi vector<vector<int>>\n#define ii pair<int,int>\n#define turnOff(k, i) (k&(~(1<<(i-1))))\n#define isOn(k, i) (k&&(1<<i-1)?true:false)\n#define pll pair<long long int , long long int>\n#define ull unsigned long long int\n#define ll  long long int\n#define add(a, b) ((a+b)%MOD)\n#define sub(a, b) ((a-b+MOD)%MOD)\n#define mul(a, b) ((a*b)%MOD)\n#ifdef  DEBUG\n#define MAXN 105\n#else\n#define MAXN 5000020\n#endif\n#define MAXLG 20\n#define endl '\\n'\n#define PI 3.141592653589793238\n#define MOD (1000000007)\n#define INF (2000000000)\n#define EPS (0.00000001)\n#define treap treapNode*\n\n\nint gcd(int a, int b) {\nwhile (a != 0) {\n    int c = a;\n    a = b % a;\n    b = c;\n}\nreturn b;\n\n}\n\n\nvi getAllDivisors(int num) {\nvector<int> divs;\nint square_root = (int) sqrt(num) + 1;\nfor (int i = 1; i < square_root; i++) {\n    if (num % i == 0) {\n        if (i * i != num) {\n            divs.pb(i);\n        }\n        divs.pb(num / i);\n    }\n\n}\nreturn divs;\n}\n\nclass PROB {\npublic:\n\n};\n\n\nll mod_pow(long x, int y) {\n// exponentiation by squaring\nll r = 1;\nwhile (y > 0) {\n    if (y % 2 == 1) {\n        r = (r * x) % MOD;\n    }\n    x = (x * x) % MOD;\n    y /= 2;\n}\nreturn r;\n}\n\n//find primes less than limit\n\nbool in[10000000+1];\nvi sieve(int limit){\nvi primes;\n\nmemset(in,true,sizeof(in));\nfor(int i=2;i<=limit;i++){\n    if(in[i]){\n        primes.push_back(i);\n        for(int j=i;j<=limit;j+=i)\n            in[j]=false;\n    }\n}\n\n\n\nreturn primes;\n}\ntypedef long long LL;\n\nstruct Edge {\nint from, to, cap, flow, index;\nEdge(int from, int to, int cap, int flow, int index) :\n        from(from), to(to), cap(cap), flow(flow), index(index) {}\n};\n\nstruct PushRelabel {\nint N;\nvector<vector<Edge> > G;\nvector<LL> excess;\nvector<int> dist, active, count;\nqueue<int> Q;\n\nPushRelabel(int N) : N(N), G(N), excess(N), dist(N), active(N), count(2*N) {}\n\nvoid AddEdge(int from, int to, int cap) {\n    G[from].push_back(Edge(from, to, cap, 0, G[to].size()));\n    if (from == to) G[from].back().index++;\n    G[to].push_back(Edge(to, from, 0, 0, G[from].size() - 1));\n}\n\nvoid Enqueue(int v) {\n    if (!active[v] && excess[v] > 0) { active[v] = true; Q.push(v); }\n}\n\nvoid Push(Edge &e) {\n    int amt = int(min(excess[e.from], LL(e.cap - e.flow)));\n    if (dist[e.from] <= dist[e.to] || amt == 0) return;\n    e.flow += amt;\n    G[e.to][e.index].flow -= amt;\n    excess[e.to] += amt;\n    excess[e.from] -= amt;\n    Enqueue(e.to);\n}\n\nvoid Gap(int k) {\n    for (int v = 0; v < N; v++) {\n        if (dist[v] < k) continue;\n        count[dist[v]]--;\n        dist[v] = max(dist[v], N+1);\n        count[dist[v]]++;\n        Enqueue(v);\n    }\n}\n\nvoid Relabel(int v) {\n    count[dist[v]]--;\n    dist[v] = 2*N;\n    for (int i = 0; i < G[v].size(); i++)\n        if (G[v][i].cap - G[v][i].flow > 0)\n            dist[v] = min(dist[v], dist[G[v][i].to] + 1);\n    count[dist[v]]++;\n    Enqueue(v);\n}\n\nvoid Discharge(int v) {\n    for (int i = 0; excess[v] > 0 && i < G[v].size(); i++) Push(G[v][i]);\n    if (excess[v] > 0) {\n        if (count[dist[v]] == 1)\n            Gap(dist[v]);\n        else\n            Relabel(v);\n    }\n}\n\nLL GetMaxFlow(int s, int t) {\n    count[0] = N-1;\n    count[N] = 1;\n    dist[s] = N;\n    active[s] = active[t] = true;\n    for (int i = 0; i < G[s].size(); i++) {\n        excess[s] += G[s][i].cap;\n        Push(G[s][i]);\n    }\n\n    while (!Q.empty()) {\n        int v = Q.front();\n        Q.pop();\n        active[v] = false;\n        Discharge(v);\n    }\n\n    LL totflow = 0;\n    for (int i = 0; i < G[s].size(); i++) totflow += G[s][i].flow;\n    return totflow;\n}\n};\nvi old(10000001,0),arr;\n\nint main() {\n    PROB temp;\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n\n#ifdef DEBUG\n    freopen(\"input\", \"r\", stdin);\n#endif\n    vi primes = sieve(10000000);\n    unordered_set<int> prime;\n    for (int i=1;i<primes.size();i++) {\n        prime.insert(primes[i]);\n    }\n    int n;\n    cin>>n;\n    rep (i,0,n) {\n        int x;\n        cin>>x;\n        old[x-1]=1;\n    }\n    vi onesAtEvenPos ,atOdd;\n    for (int i=0;i<old.size()-1;i++) {\n        if (old[i]!=old[i+1]) {\n            if (i%2==0) {\n                onesAtEvenPos.pb(i);\n            } else {\n                atOdd.push_back(i);\n            }\n         }\n    }\n    PushRelabel pr(2+onesAtEvenPos.size()+atOdd.size());\n\n    rep (i,0,onesAtEvenPos.size()) {\n        pr.AddEdge(0,i+1,1);\n    }\n    rep (i,0,atOdd.size()) {\n        pr.AddEdge(onesAtEvenPos.size()+i+1, 1+onesAtEvenPos.size()+atOdd.size(),1);\n    }\n\n    for (int i=0;i<onesAtEvenPos.size();i++) {\n        for (int j=0;j<atOdd.size();j++) {\n              if (prime.count(abs(onesAtEvenPos[i]-atOdd[j]))) {\n                  pr.AddEdge(1+i,onesAtEvenPos.size()+j+1,1);\n              }\n        }\n    }\n\n    int ans = pr.GetMaxFlow(0, 1+onesAtEvenPos.size()+atOdd.size());\n    ans += 2*((atOdd.size()-ans)/2) + 2*((onesAtEvenPos.size()-ans)/2);\n    if ((onesAtEvenPos.size()-ans)%2 != (atOdd.size()-ans)%2) {\n        ans +=2;\n    } else {\n        ans += 3 * ((onesAtEvenPos.size() - ans) % 2);\n    }\n        cout<<ans;\n\n\n\n\n    return 0;\n\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<cstring>\n#include<map>\n#include<queue>\n#include<cmath>\nusing namespace std;\ntypedef long long ll;\nconst int N=1005,INF=~0u>>2;\nstruct Edge{int nxt,to;}edge[(N*N)<<3];\nint a[N],b[N<<1],n,head[N<<1],num_edge,vis[N<<1],lk[N<<1],even[N<<1],odd[N<<1],even_num,odd_num,ans,k,tot,tim;\nint read(){\n\tint x=0,f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-') f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn f*x;\n}\nvoid add_edge(int from,int to){\n\tedge[++num_edge].nxt=head[from];\n\tedge[num_edge].to=to;\n\thead[from]=num_edge;\n}\nbool find(int x){\n\tfor(int i=head[x];i;i=edge[i].nxt){\n\t\tif(vis[edge[i].to]!=tim){\n\t\t\tvis[edge[i].to]=tim;\n\t\t\tif(!lk[edge[i].to]||find(edge[i].to)){\n\t\t\t\tlk[edge[i].to]=x;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nbool check(int x){\n\tif(x==1) return 0;\n\tfor(int i=2;i*i<=x;++i){\n\t\tif(x%i==0) return 0;\n\t}\n\treturn 1;\n}\nint main(){\n//\tfreopen(\"ex.in\",\"r\",stdin);\n\tn=read();\n\tfor(int i=1;i<=n;++i) b[i]=read();b[0]=-INF;b[n+1]=INF;\n\tfor(int i=1;i<=n;++i){\n\t\tif(b[i]!=b[i-1]+1){\n\t\t\tif(i%2) odd[++odd_num]=b[i];\n\t\t\telse even[++even_num]=b[i];\n\t\t}\n\t\tif(b[i]+1!=b[i+1]){\n\t\t\tif((i+1)%2) odd[++odd_num]=b[i]+1;\n\t\t\telse even[++even_num]=b[i]+1;\n\t\t}\n\t}\n\tfor(int i=1;i<=odd_num;++i){\n\t\tfor(int j=1;j<=even_num;++j){\n\t\t\tif(check(abs(even[j]-odd[i]))) add_edge(even[j],odd[i]),add_edge(odd[i],even[j]);\n\t\t}\n\t}\n\tfor(int i=1;i<=odd_num;++i){\n\t\ttim++;\n\t\tif(find(odd[i])) k++;\n\t\telse break;\n\t}\n\tans=k+((even_num-k)/2+(odd_num-k)/2)*2+((even_num-k)%2)*3;\n\tprintf(\"%d\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<queue>\n#include<stack>\n#include<cstring>\n#include<algorithm>\n#include<vector>\n#include<cmath>\nusing namespace std;\nint e[201][201];\nint vis[201];\nint match[201];\nint tot1=0,tot2=0;\nbool find(int u)\n{\n\tfor(int i=1;i<=tot2;i++)\n\t{\n\t\tif(vis[i]==0&&e[u][i])\n\t\t{\n\t\t\tvis[i]=1;\n\t\t\tif(!match[i]||find(match[i]))\n\t\t\t{\n\t\t\t\tmatch[i]=u;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\nbool isprime(int x)\n{\n\tif(x==1) return false;\n\tfor(int i=2;i<=sqrt(x);i++)\n\t\tif(x%i==0)\n\t\t\treturn false;\n\treturn true;\n}\nint x[201];\nint odd[201];\nint even[201];\nsigned main()\n{\n\tint n;\n\tscanf(\"%d\",&n);\n\tif(n==1){printf(\"3\");return 0;}\n\tfor(int i=1;i<=n;i++)\n\t\tscanf(\"%d\",&x[i]);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tif(i==1||x[i-1]!=x[i]-1)\n\t\t{\n\t\t\tif(x[i]%2==1) odd[++tot1]=x[i];\n\t\t\telse even[++tot2]=x[i];\n\t\t}\n\t\tif(i==n||x[i+1]!=x[i]+1)\n\t\t{\n\t\t\tif(x[i]%2==1) even[++tot2]=x[i]+1;\n\t\t\telse odd[++tot1]=x[i]+1;\n\t\t}\n\t}\n\tfor(int i=1;i<=tot1;i++)\n\t\tfor(int j=1;j<=tot2;j++)\n\t\t\tif(isprime(abs(odd[i]-even[j])))\n\t\t\t\te[i][j]=1;\n\tint ans=0;\n\tfor(int i=1;i<=tot1;i++)\n\t{\n\t\tmemset(vis,0,sizeof(vis));\n\t\tif(find(i))\n\t\t\tans++;\n\t}\n\tprintf(\"%d\",ans+(tot1-ans)/2*2+(tot2-ans)/2*2+(tot1-ans)%2*3);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace std;\nusing namespace __gnu_pbds;\n\n#define ll long long\n#define db long double\n#define ii pair<int,int>\n#define vi vector<int>\n#define fi first\n#define se second\n#define sz(a) (int)(a).size()\n#define all(a) (a).begin(),(a).end()\n#define pb push_back\n#define mp make_pair\n#define FN(i, n) for (int i = 0; i < (int)(n); ++i)\n#define FEN(i,n) for (int i = 1;i <= (int)(n); ++i)\n#define rep(i,a,b) for(int i=a;i<b;i++)\n#define repv(i,a,b) for(int i=b-1;i>=a;i--)\n#define SET(A, val) memset(A, val, sizeof(A))\ntypedef tree<int ,null_type,less<int>,rb_tree_tag,tree_order_statistics_node_update>ordered_set ;\n// order_of_key (val): returns the no. of values less than val\n// find_by_order (k): returns the kth largest element.(0-based)\n#define TRACE\n#ifdef TRACE\n#define trace(...) __f(#__VA_ARGS__, __VA_ARGS__)\ntemplate <typename Arg1>\nvoid __f(const char* name, Arg1&& arg1){\n  cerr << name << \" : \" << arg1 << std::endl;\n}\ntemplate <typename Arg1, typename... Args>\nvoid __f(const char* names, Arg1&& arg1, Args&&... args){\n  const char* comma = strchr(names + 1, ','); cerr.write(names, comma - names) << \" : \" << arg1<<\" | \";__f(comma+1, args...);\n}\n#else\n#define trace(...)\n#endif\nconst int N=205,L=1e7+5;\nbool mark[L],prime[L];\nnamespace match\n{\n  const int N=205;\n  int l[N],r[N],n,m;\n  bool a[N][N],seen[N];\n  bool findmatch(int i)\n  {\n    rep(j,0,m)\n      {\n\tif(a[i][j] && !seen[j])\n\t  {\n\t    seen[j]=true;\n\t    if(r[j]<0 || findmatch(r[j]))\n\t      {\n\t\tl[i]=j; r[j]=i;\n\t\treturn true;\n\t      }\n\t  }\n      }\n    return false;\n  }\n  int bipartitematch()\n  {\n    int cnt=0;\n    rep(i,0,n) l[i]=-1;\n    rep(i,0,m) r[i]=-1;\n    rep(i,0,n)\n      {\n\trep(j,0,m) seen[j]=false;\n\tif(findmatch(i)) cnt++;\n      }\n    return cnt;\n  }\n};\nint main()\n{\n  std::ios::sync_with_stdio(false);\n  cin.tie(NULL) ; cout.tie(NULL) ;\n  memset(prime,true,sizeof(prime));\n  prime[1]=false;\n  rep(i,2,L)\n    {\n      if(!prime[i]) continue;\n      for(int j=2*i;j<L;j+=i)\n\tprime[j]=false;\n    }\n  prime[2]=false;\n  int n,x;\n  cin>>n;\n  rep(i,1,n+1)\n    {\n      cin>>x;\n      mark[x]=true;\n    }\n  vi arrodd,arreven;\n  int odd=0,even=0;\n  rep(i,1,L-1)\n    if(mark[i]!=mark[i-1])\n      {\n\tif(i&1) arrodd.pb(i);\n\telse arreven.pb(i);\n      }\n  odd=sz(arrodd); even=sz(arreven);\n  match::n=odd; match::m=even;\n  rep(i,0,sz(arrodd))\n    rep(j,0,sz(arreven))\n    {\n      if(prime[abs(arrodd[i]-arreven[j])]) match::a[i][j]=1;\n      else match::a[i][j]=0;\n    }\n  int k=match::bipartitematch();\n  assert((even-odd)%2==0);\n  even-=k; odd-=k;\n  int ans=k+(even/2+odd/2)*2+(odd&1)*3;\n  cout<<ans<<endl;\n  return 0 ;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 210;\n\nint n, x[N];\nvector<int> dif;\nint ans;\n// for bipartite matching\nvector<int> ver[2];\nvector<int> g[N];\nbool check[N];\nint mx[N], my[N];\n\nbool isprime(int x) {\n\tfor (int i = 2; i * i <= x; ++i) if (x % i == 0) return false;\n\treturn true;\n}\n\nbool dfs(int u) {\n\tif (!u) return true;\n\tfor (int v : g[u]) if (!check[v]) {\n\t\tcheck[v] = 1;\n\t\tif (dfs(my[v])) {\n\t\t\tmx[u] = v; my[v] = u; return true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; ++i) scanf(\"%d\", x + i);\n\tfor (int i = 1; i <= n; ++i) {\n\t\tif (!(i > 1 && x[i - 1] == x[i] - 1)) {\n\t\t\tdif.push_back(x[i]);\n\t\t}\n\t\tif (x[i + 1] != x[i] + 1) {\n\t\t\tdif.push_back(x[i] + 1);\n\t\t}\n\t}\n\n\tfor (int i : dif) ver[i % 2].push_back(i);\n\n\tfor (int i = 0; i < ver[0].size(); ++i) {\n\t\tfor (int j = 0; j < ver[1].size(); ++j) {\n\t\t\tint dist = abs(ver[0][i] - ver[1][j]);\n\t\t\tif (dist <= 2) continue;\n\t\t\tif (isprime(dist)) {\n\t\t\t\tg[i + 1].push_back(j + 1);\n\t\t\t}\n\t\t}\n\t}\n\n\t// bipartite matching\n\tint sz = ver[0].size();\n\tint rem = sz, prev_rem = sz + 1;\n\t\n\twhile(rem > 0 && rem < prev_rem) {\n\t\tprev_rem = rem;\n\t\tfor (int i = 1; i <= sz; ++i) check[i] = false;\n\t\tfor (int i = 1; i <= sz; ++i) if (!mx[i]) rem -= dfs(i);\n\t}\n\n\tfor (int i = 1; i <= sz; ++i) if (mx[i]) ++ans;\n\n\tint v0 = ver[0].size() - ans;\n\tint v1 = ver[1].size() - ans;\n\n\tans += 2 * (v0 / 2); v0 %= 2;\n\tans += 2 * (v1 / 2); v1 %= 2;\n\n\tans += (v0 == 1 && v1 == 1) * 3;\n\n\tprintf(\"%d\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\nconst int MAX1=100;\nconst int MAX2=10000000;\nconst int INF=0x3f3f3f3f;\nint n,a[MAX1+5],p[MAX2+5],chk[MAX1*2+5],ans;\nvector<int> cx,c[2],seq;\nvector<pii> conn[MAX1+5];\nint dfs(int x,int y){\n    int flow=0;\n    if(x==y) return INF;\n    chk[x]=1;\n    for(int i=0;i<conn[x].size();i++) if(chk[conn[x][i].first]==0&&conn[x][i].second>0){\n        int t=dfs(conn[x][i].first,y);\n        if(t>0){\n            flow=min(t,conn[x][i].second);\n            seq.push_back(x);\n            break;\n        }\n    }\n    chk[x]=0;\n    return flow;\n}\nint fflow(int x,int y){\n    seq.clear(); seq.push_back(y);\n    printf(\"%d %d\\n\",x,y);\n    int flow=dfs(x,y);\n    for(int i=0;i<seq.size()-1;i++) {\n        int a=seq[i+1],b=seq[i];\n        for(int j=0;j<conn[a].size();j++) if(conn[a][j].first==b) conn[a][j].second-=flow;\n        for(int j=0;j<conn[b].size();j++) if(conn[b][j].first==a) conn[b][j].second+=flow;\n    }\n    return flow;\n}\nint main(){\n    scanf(\"%d\",&n);\n    for(int i=0;i<n;i++) scanf(\"%d\",&a[i]);\n    cx.push_back(a[0]), cx.push_back(a[0]+1);\n    for(int i=1;i<n;i++){\n        if(cx[cx.size()-1]==a[i]) cx.pop_back();\n        else cx.push_back(a[i]);\n        cx.push_back(a[i]+1);\n    }\n    for(int i=2;i<=MAX2;i++){\n        if(p[i]==0){\n            p[i]=1;\n            if(i<=10000) {for(int j=i*i;j<=MAX2;j+=i) p[j]=-1;}\n        }\n    }\n    p[2]=-1;\n    for(int i=0;i<cx.size();i++) c[cx[i]%2].push_back(cx[i]);\n    for(int i=0;i<c[0].size();i++) for(int j=0;j<c[1].size();j++) if(p[abs(c[0][i]-c[1][j])]==1) {\n        //printf(\"%d %d %d\\n\",i,j,abs(c[0][i]-c[1][j]));\n        conn[i].push_back(make_pair(c[0].size()+j,1));\n        conn[c[0].size()+j].push_back(make_pair(i,0));\n    }\n    for(int i=0;i<c[0].size();i++) {\n        conn[c[0].size()+c[1].size()].push_back(make_pair(i,1));\n        conn[i].push_back(make_pair(c[0].size()+c[1].size(),0));\n    }\n    for(int i=0;i<c[1].size();i++) {\n        conn[i+c[1].size()].push_back(make_pair(c[0].size()+c[1].size()+1,1));\n        conn[c[0].size()+c[1].size()+1].push_back(make_pair(i+c[1].size(),0));\n    }\n    while(fflow(c[0].size()+c[1].size(),c[0].size()+c[1].size()+1)) ans++;\n    printf(\"%d\\n\",c[0].size()+c[1].size()-ans+(c[0].size()-ans)%2);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define sz(x) ((int)(x).size())\n#define rep(i,a,b) for (int i=(a); i<(b); i++)\n#define per(i,a,b) for (int i=(b-1); i>=(a); i--)\n#define de(x) cout << #x << \" => \" << x << endl\nusing namespace std;\n\n#define fi first\n#define se second\n#define mp make_pair\ntypedef pair<int,int> pii;\n\n#define pb push_back\ntypedef vector<int> vi;\n\ntypedef long long ll;\ntypedef long double ld;\n\n///----------------------------------------------\nstruct Hug {\n    static const int Hug_N = 7 + 1000;\n    int nx, ny;\n    vi G[Hug_N];\n    int par[Hug_N];\n    bool vis[Hug_N];\n    ///init\n    void link(int a, int b) { G[a].pb(b); }\n    void init(int _nx, int _ny) {\n        nx = _nx; ny = _ny;\n        rep(i, 1, nx + 1) G[i].clear();\n    }\n    ///find\n    bool find(int u) {\n        rep(i, 0, sz(G[u])) {\n            int v = G[u][i]; if (vis[v]) continue;\n            for (vis[v] = true; !~par[v] || find(par[v]); ) return par[v] = u, true;\n        }\n        return false;\n    }\n    ///work\n    int work( ) {\n        int ret = 0;\n        rep(i, 1, ny + 1) par[i] = -1;\n        rep(i, 1, nx + 1) {\n            rep(k, 1, ny + 1) vis[k] = false;\n           // if (find(i)) ret++;\n        }\n        return ret;\n    }\n}   hug;\n///-----\nbool isP(int dig) {\n    if (dig < 2) return false;\n    for (int i = 2; i * i <= dig; i++)\n        if (dig % i == 0) return false;\n    return true;\n}\n///-----\nvi v[2]; void add(int dig) { v[dig&1].pb(dig); }\n///-----\nint main() {\n\n    ///freopen ( \"xx.in\" , \"r\" , stdin );\n\n    ///read\n    int n; cin >> n;\n    int pre = -1;\n    rep(i, 0, n) {\n        int dig; scanf(\"%d\",&dig);\n        if (dig != pre + 1) {\n            add(dig);\n            if (~pre) add(pre + 1);\n        }\n        pre = dig;\n    }\n    add(pre + 1);\n\n    ///work\n    hug.init(sz(v[0]), sz(v[1]));\n    rep(i, 0, sz(v[0])) {\n        rep(j, 0, sz(v[1])) {\n            if (isP(abs(v[0][i] - v[1][j]))) hug.link(i + 1, j + 1);\n        }\n    }\n\n    ///print\n    int can = hug.work();\n    int ans = can;\n    ans += (sz(v[0]) - can) / 2 * 2;\n    ans += (sz(v[1]) - can) / 2 * 2;\n    if ((sz(v[0]) - can)&1 || (sz(v[1]) - can) & 1) ans += 3;\n    printf(\"%d\", ans);\n\n}\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n\n#include <iostream>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <unordered_set>\n#include <queue>\n#include <set>\n#include <algorithm>\n#include <numeric>\n#include <list>\nusing namespace std;\n\nusing QWORD  = uint64_t;\nusing SQWORD = int64_t;\nusing DWORD  = uint32_t;\nusing SDWORD = int32_t;\nusing WORD   = uint16_t;\nusing SWORD  = int16_t;\nusing BYTE   = uint8_t;\nusing SBYTE  = int8_t;\nusing DOUBLE = double;\nusing FLOAT  = float;\n\n#define MIN_SDWORD (-2147483648)\n#define MAX_SDWORD (2147483647)\n#define MIN_SBYTE (-128)\n#define MAX_SBYTE (127)\n\n#define MIN_SQWORD (0x8000000000000000)\n#define MAX_SQWORD (0x7FFFFFFFFFFFFFFF)\n\n#define MAX_QWORD  (0xFFFFFFFFFFFFFFFF)\n#define MAX_DWORD  (0xFFFFFFFF)\n#define MAX_WORD   (0xFFFF)\n#define MAX_BYTE   (0xFF)\n\n#define MAX_DOUBLE      (1.0e+308)\n#define DOUBLE_EPS      (1.0e-12)\n#define MIN_DOUBLE_N    (-1.0e+308)\n\n#define ArrayLength(a)  (sizeof(a) / sizeof(a[0]))\n\nstatic inline DOUBLE MAX(DOUBLE a, DOUBLE b) { return a > b ? a : b; }\nstatic inline QWORD MAX(QWORD a, QWORD b) { return a > b ? a : b; }\nstatic inline DWORD MAX(DWORD a, DWORD b) { return a > b ? a : b; }\nstatic inline SDWORD MAX(SDWORD a, SDWORD b) { return a > b ? a : b; }\nstatic inline DOUBLE MIN(DOUBLE a, DOUBLE b) { return a < b ? a : b; }\nstatic inline QWORD MIN(QWORD a, QWORD b) { return a < b ? a : b; }\nstatic inline DWORD MIN(DWORD a, DWORD b) { return a < b ? a : b; }\nstatic inline SDWORD MIN(SDWORD a, SDWORD b) { return a < b ? a : b; }\nstatic inline DOUBLE ABS(DOUBLE a) { return 0 < a ? a : -a; };\n\n#define BYTE_BITS   (8)\n#define WORD_BITS   (16)\n#define DWORD_BITS  (32)\n#define QWORD_BITS  (64)\n\nstatic inline void inputStringSpSeparated(char *pcStr)\n{\n    char *pcCur = pcStr;\n    for (;;) {\n        char c = getchar();\n        if (('\\n' == c) || (EOF == c) || (' ' == c)) {\n            break;\n        }\n        *pcCur = c;\n        pcCur++;\n    }\n    *pcCur = '\\0';\n}\n\nstatic inline void inputString(char *pcStr)\n{\n    char *pcCur = pcStr;\n    for (;;) {\n        char c = getchar();\n        if (('\\n' == c) || (EOF == c)) {\n            break;\n        }\n        *pcCur = c;\n        pcCur++;\n    }\n    *pcCur = '\\0';\n}\n\n\nstatic inline SQWORD inputSQWORD(void)\n{\n    SQWORD sqNumber = 0;\n    SQWORD sqMultiplier = 1;\n    bool bRead = false;\n    for (;;) {\n        char c = getchar();\n        if (!bRead) {\n            if ('-' == c) {\n                sqMultiplier = -1;\n            }\n        }\n        if (('0' <= c) && (c <= '9')) {\n            sqNumber *= 10LL;\n            sqNumber += (SQWORD)(c - '0');\n            bRead = true;\n        } else {\n            if (bRead) {\n                return sqNumber * sqMultiplier;\n            }\n        }\n    }\n}\n\n\nstatic inline SDWORD inputSDWORD(void)\n{\n    SDWORD lNumber = 0;\n    SDWORD lMultiplier = 1;\n    bool bRead = false;\n    for (;;) {\n        char c = getchar();\n        if (!bRead) {\n            if ('-' == c) {\n                lMultiplier = -1;\n            }\n        }\n        if (('0' <= c) && (c <= '9')) {\n            lNumber *= 10;\n            lNumber += (c - '0');\n            bRead = true;\n        } else {\n            if (bRead) {\n                return lNumber * lMultiplier;\n            }\n        }\n    }\n}\n\nstatic inline DOUBLE inputFP(void)\n{\n    DOUBLE dInt = 0.0;\n    DOUBLE dFrac = 0.0;\n    DOUBLE dMultiplier = 1.0;\n    DWORD dwFpCnt = 0;\n    DOUBLE *pdCur = &dInt;\n    bool bRead = false;\n    for (;;) {\n        char c = getchar();\n        if (!bRead) {\n            if ('-' == c) {\n                dMultiplier = -1;\n            }\n        }\n        if ('.' == c) {\n            pdCur = &dFrac;\n        } else if (('0' <= c) && (c <= '9')) {\n            (*pdCur) *= 10;\n            (*pdCur) += (DOUBLE)(c - '0');\n            bRead = true;\n            if (pdCur == &dFrac) {\n                dwFpCnt++;\n            }\n        } else {\n            if (bRead) {\n                return dMultiplier * (dInt + dFrac / (pow((DOUBLE)10.0 , (DOUBLE)dwFpCnt)));\n            }\n        }\n    }\n}\n\n\n/**\n *  mod による操作ライブラリ\n */\n\n#define ANS_MOD (1000000007LL)\n \nstatic SQWORD addMod(SQWORD x, SQWORD y)\n{ \n    return (x + y) % ANS_MOD;\n}\n \nstatic SQWORD subMod(SQWORD x, SQWORD y)\n{\n    return (x - y + ANS_MOD) % ANS_MOD;\n}\n \nstatic SQWORD mulMod(SQWORD x, SQWORD y) \n{\n    return (x * y) % ANS_MOD;\n}\n \nstatic SQWORD powMod(SQWORD x, SQWORD e) {\n    SQWORD v = 1;\n    for (; e; x = mulMod(x, x), e >>= 1) {\n        if (e & 1) {\n            v = mulMod(v, x);\n        }\n    }\n    return v;\n}\n \nstatic SQWORD divMod(SQWORD x, SQWORD y)\n{\n    return mulMod(x, powMod(y, ANS_MOD - 2));\n}\n \n \nstatic SQWORD combMod(SQWORD n, SQWORD k)\n{\n    SQWORD v=1;\n    for(SQWORD i=1; i<=k; i++) {\n        v = divMod(mulMod(v, n-i+1),i);\n    } \n    return v;\n}\n\n/*----------------------------------------------*/\n\ntypedef struct {\n    SDWORD lTo;\n    SQWORD sqCap;\n    SQWORD sqCost;\n    SDWORD lRev;\n} ST_EDGE;\n\n#define MAX_V   (402)\n\nstruct Flow {\nprivate:\n    vector<ST_EDGE> avGraph[MAX_V];\n    SDWORD  alDimsFrom[MAX_V];\n    SDWORD  alDimsTo[MAX_V];\n    SQWORD  sqEdgeNum;\n    SQWORD  asqDist[MAX_V];\n    SDWORD  alPrevV[MAX_V];   \n    SDWORD  alPrevEdge[MAX_V];      /*直前の頂点と辺 */\n\n    SDWORD  alDinic_Level[MAX_V];\n    SDWORD  alDinic_Iter[MAX_V];\n\npublic:\n    Flow() {\n        for (auto v: avGraph) {\n            v.clear();\n        }\n        memset(asqDist, 0, sizeof(asqDist));\n        memset(alPrevV, 0, sizeof(alPrevV)); \n        memset(alPrevEdge, 0, sizeof(alPrevEdge));\n        memset(alDinic_Level, 0, sizeof(alDinic_Level));\n        memset(alDinic_Iter, 0, sizeof(alDinic_Iter));\n    }\n    void addEdge(SDWORD lFrom, SDWORD lTo, SQWORD sqCap, SQWORD sqCost) {\n        avGraph[lFrom].push_back((ST_EDGE){lTo, sqCap, sqCost, (SDWORD)(avGraph[lTo].size())});\n        avGraph[lTo].push_back((ST_EDGE){lFrom, 0, -sqCost, (SDWORD)(avGraph[lFrom].size() - 1)});\n    }\n\n    SDWORD minCostFlow(SDWORD lStart, SDWORD lTarget, SQWORD sqFlow)\n    {\n        SQWORD sqRes = 0;\n        SQWORD sqFlowRest = sqFlow;\n        while (0 < sqFlowRest) {\n            /* Bellman-Ford Method */\n            fill(asqDist, asqDist + ArrayLength(asqDist), MAX_SDWORD);\n            asqDist[lStart] = 0;\n            bool bIsUpdate = true;\n            while (bIsUpdate) {\n                bIsUpdate = false;\n                for (SDWORD lV = 0; lV < MAX_V; lV++) {\n                    for (SDWORD lIdx = 0; lIdx < avGraph[lV].size(); lIdx++) {\n                        ST_EDGE &stE = avGraph[lV][lIdx];\n                        if ((asqDist[lV] != MAX_SDWORD)\n                                && (0 < stE.sqCap)\n                                && (asqDist[lV] + stE.sqCost < asqDist[stE.lTo])) {\n                            asqDist[stE.lTo] = asqDist[lV] + stE.sqCost;\n                            alPrevV[stE.lTo] = lV;\n                            alPrevEdge[stE.lTo] = lIdx;\n                            bIsUpdate = true;\n                        }\n                    }\n                }\n            }\n            if (asqDist[lTarget] == MAX_SDWORD) {\n                return -1;\n            }\n\n            SQWORD sqAddFlow = MAX_SQWORD;\n            for (SDWORD lV = lTarget; lV != lStart; lV = alPrevV[lV]) {\n                sqAddFlow = min(sqAddFlow, avGraph[alPrevV[lV]][alPrevEdge[lV]].sqCap);\n            }\n            sqFlowRest -= sqAddFlow;\n            sqRes += sqAddFlow * asqDist[lTarget];      // 後で目的変数は書き換える\n            for (SDWORD lV = lTarget; lV != lStart; lV = alPrevV[lV]) {\n                ST_EDGE &stE = avGraph[alPrevV[lV]][alPrevEdge[lV]];\n                stE.sqCap -= sqAddFlow;\n                avGraph[lV][stE.lRev].sqCap += sqAddFlow;\n            }\n        }\n        return sqRes;\n    }\n\nprivate:\n    SQWORD maxFlowDinicBfs(SDWORD lS)\n    {\n        memset(alDinic_Level, -1, sizeof(alDinic_Level));\n        queue<SDWORD> queSearch;\n        alDinic_Level[lS] = 0;\n        queSearch.push(lS);\n        while (!queSearch.empty()) {\n            SDWORD lV = queSearch.front();\n            queSearch.pop();\n            for (SDWORD lIdx = 0; lIdx < avGraph[lV].size(); lIdx++) {\n                ST_EDGE &stE = avGraph[lV][lIdx];\n                if ((0 < stE.sqCap) && (alDinic_Level[stE.lTo] < 0)) {\n                    alDinic_Level[stE.lTo] = alDinic_Level[lV] + 1;\n                    queSearch.push(stE.lTo);\n                }\n            }\n        }\n\n        return 0;\n    }\n\n    SQWORD maxFlowDinicDfs(SDWORD lV, SDWORD lT, SQWORD sqF)\n    {\n        if (lV == lT) {\n            return sqF;\n        }\n        for (SDWORD &lI = alDinic_Iter[lV]; lI < avGraph[lV].size(); lI++) {\n            ST_EDGE &stE = avGraph[lV][lI];\n            if ((0 < stE.sqCap) && (alDinic_Level[lV] < alDinic_Level[stE.lTo])) {\n                SQWORD sqDiffFlow = maxFlowDinicDfs(stE.lTo, lT, min(sqF, stE.sqCap));\n                if (0 < sqDiffFlow) {\n                    stE.sqCap -= sqDiffFlow;\n                    avGraph[stE.lTo][stE.lRev].sqCap += sqDiffFlow;\n                    return sqDiffFlow;\n                }\n            }\n        }\n        return 0;\n    }\n\npublic:\n    SQWORD MaxFlow(SDWORD lStart, SDWORD lTarget)\n    {\n        SQWORD sqFlow = 0LL;\n        for (;;) {\n            maxFlowDinicBfs(lStart);\n            if (alDinic_Level[lTarget] < 0) {\n                return sqFlow;\n            }\n            memset(alDinic_Iter, 0, sizeof(alDinic_Iter));\n            while (1) {\n                SQWORD sqDiffFlow = maxFlowDinicDfs(lStart, lTarget, MAX_SQWORD);\n                sqFlow += sqDiffFlow;\n                if (0LL == sqDiffFlow) {\n                    break;\n                }\n            }\n        }\n    }\n};\n\n/*----------------------------------------------*/\n\nclass PrimeTable {\n    vector<bool> vbIsPrime;\n\npublic:\n    PrimeTable(SDWORD lMax) {\n        /* lSearchMax と ループ内の *2 の関係から、入力は3以上とすること */\n        if (!(1 <= lMax)) {\n            printf(\"Oops!\");\n            return;\n        }\n\n        /* 素数のリストを作る */\n        vbIsPrime.resize(lMax + 1, true);\n        SDWORD lSearchMax = sqrt(lMax) + 1;\n        vbIsPrime[0] = false;\n        vbIsPrime[1] = false;\n        for (SDWORD lPrime = 2; lPrime < lSearchMax; lPrime++) {\n            if (vbIsPrime[lPrime]) {\n                for (SDWORD lCurNum = lPrime * 2; lCurNum <= lMax; lCurNum += lPrime) {\n                    vbIsPrime[lCurNum] = false;\n                }\n            }\n        }\n    };\n\n    bool IsPrime(SQWORD sqN)\n    {\n        return vbIsPrime[sqN];\n    }\n};\n\n\n/*----------------------------------------------*/\n\n#define PNT_NO_START    (0)\n#define PNT_NO_OFFSET   (200)\n#define PNT_NO_TARGET   (401)\n#define FLOW_OFFSET     (1000000000)\n#define CAPACITY_INF    (1000000001)\n#define DUMMY_COST      (1)\n\nint main(void)\n{\n    SQWORD sqN = inputSQWORD();\n\n    Flow solverFlow;\n    vector<SQWORD> vsqA;\n    vector<SQWORD> vsqB;\n\n    PrimeTable prime(1e7 + 1);\n \n    map<SQWORD, SQWORD> mapB;\n\n    for (SQWORD sqIdx = 0; sqIdx < sqN; sqIdx++) {\n        SQWORD sqA = inputSQWORD();\n        vsqA.emplace_back(sqA);\n\n        mapB[sqA] ^= 1;\n        mapB[sqA + 1] ^= 1;\n    }\n\n    vector<SQWORD> vsqBEven, vsqBOdd;\n\n    for (auto b: mapB) {\n        if (0 < b.second) {\n            if (0 == (b.first % 2)) {\n                vsqBEven.emplace_back(b.first);\n            } else {\n                vsqBOdd.emplace_back(b.first);\n            }\n        }\n    }\n\n    SQWORD sqNodeEven = 0;\n    for (auto e: vsqBEven) {\n        SQWORD sqNodeOdd = 0;\n        for (auto o: vsqBOdd) {\n            if (prime.IsPrime(abs(e - o))) {\n                solverFlow.addEdge(sqNodeOdd, sqNodeOdd + PNT_NO_OFFSET, 1, DUMMY_COST);\n            }\n            sqNodeOdd++;\n        }\n        sqNodeEven++;\n    }\n    for (SQWORD sqIdx = 1; sqIdx < vsqBEven.size(); sqIdx++) {\n        solverFlow.addEdge(PNT_NO_START, sqIdx, 1, DUMMY_COST);\n    }\n    for (SQWORD sqIdx = 1; sqIdx < vsqBOdd.size(); sqIdx++) {\n        solverFlow.addEdge(sqIdx + PNT_NO_OFFSET, PNT_NO_TARGET, 1, DUMMY_COST);\n    }\n\n\n\n    SQWORD sqMaxFlow = solverFlow.MaxFlow(PNT_NO_START, PNT_NO_TARGET);\n    SQWORD vsqCRestEven = vsqBEven.size() - sqMaxFlow;\n    SQWORD vsqCRestOdd  = vsqBOdd.size() - sqMaxFlow;\n\n    SQWORD sqAns = sqMaxFlow;    \n    sqAns += ((vsqCRestEven / 2) * 2);\n    sqAns += ((vsqCRestOdd / 2) * 2);\n    if (0 < (vsqCRestEven %  2)) {\n        sqAns += 3;\n    }\n\n    printf(\"%lld\\n\", sqAns);\n\n    return 0;\n}\n/*------------------------------------------*/\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<cstring>\nusing namespace std;\nint n;\nint res;\nvector<int>v;\nint lst=-1;\nint match[210];\nint me,mo;\nint mx;\nbool f[10000010];\nvector<int>ok[210];\nint vis[210];\nint prm[1000010];\nint sz;\nint l;\nbool bp(int x,int p)\n{\n\tvis[x]=p;\n\tfor(int i=0;i<ok[x].size();i++)\n\t{\n\t\tint y=ok[x][i];\n\t\tif(vis[y])continue;\n\t\tif(match[y]!=-1 && vis[match[y]]==x)continue;\n\t\tif(match[y]==-1 || bp(match[y],p))\n\t\t{\n\t\t\tmatch[y]=x;\n\t\t\tmatch[x]=y;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint x;\n\t\tscanf(\"%d\",&x);\n\t\tif(x!=lst+1)\n\t\t{\n\t\t\tif(lst+1)v.push_back(lst+1);\n\t\t\tv.push_back(x);\n\t\t}\n\t\tlst=x;\n\t\tmx=lst+1;\n\t}\n\tv.push_back(lst+1);\n\tf[1]=true;\n\tfor(int i=2;i<=mx;i++)\n\t{\n\t\tif(!f[i])prm[++sz]=i;\n\t\tfor(int j=1;j<=sz;j++)\n\t\t{\n\t\t\tif(prm[j]*i>mx)break;\n\t\t\tf[prm[j]*i]=true;\n\t\t\tif(i%prm[j]==0)break;\n\t\t}\n\t}\n\tl=v.size();\n\tfor(int i=0;i<l;i++)\n\t{\n\t\tmatch[i]=-1;\n\t\tif(v[i]&1)mo++;else me++;\n\t\tfor(int j=i+1;j<l;j++)\n\t\t{\n\t\t\tif(v[j]-v[i]!=2 && !f[v[j]-v[i]])\n\t\t\t{\n\t\t\t\tok[i].push_back(j);\n\t\t\t\tok[j].push_back(i);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<l;i++)\n\t{\n\t\tmemset(vis,false,sizeof(vis));\n\t\tif(bp(i,i))res++;\n\t}\n\tprintf(\"%d\",res+((me-res)/2+(mo-res)/2)*2+((me-res)%2)*3);\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#ifdef LOCAL\n#include \"debug.h\"\n#else\n#define DEBUG(...)\n#endif\n\nvector<int> sieve(int n) {\n  vector<bool> b(n / 3 + 1, true);\n  vector<int> res{2, 3};\n  for (int p = 5, d = 4; p * p <= n; p += d = 6 - d) if (b[p / 3])\n    for (int i = p * p, di = p % 3 * 2 * p; i <= n; i += di = 6 * p - di)\n      b[i / 3] = false;\n  for (int p = 5, d = 4; p <= n; p += d = 6 - d) if(b[p / 3]) res.push_back(p);\n  while (not res.empty() and res.back() > n) res.pop_back();\n  return res;\n}\n\nstruct bipartite_matching {\n  vector<vector<int>> g;\n  vector<int> r, c, vis;\n  int t = 0;\n  bipartite_matching(int h = 0, int w = 0) : g(h), r(h, -1), c(w, -1), vis(h) {}\n  void add(int i, int j) { g[i].push_back(j); }\n  bool dfs(int i) {\n    if (exchange(vis[i], t) == t) return false;\n    for (int j : g[i]) if (c[j] == -1) return r[i] = j, c[j] = i, true;\n    for (int j : g[i]) if (dfs(c[j])) return r[i] = j, c[j] = i, true;\n    return false;\n  }\n  int run() {\n    for (bool updated = true; ++t, exchange(updated, false); )\n      for (int i = r.size(); i--; ) if (r[i] == -1) updated |= dfs(i);\n    return r.size() - count(begin(r), end(r), -1);\n  }\n};\n\nint main() {\n  cin.tie(nullptr);\n  ios::sync_with_stdio(false);\n  int n;\n  cin >> n;\n  set<int> se;\n  while (n--) {\n    int x;\n    cin >> x;\n    for (int i : {x - 1, x}) {\n      if (se.count(i)) {\n        se.erase(i);\n      } else {\n        se.insert(i);\n      }\n    }\n  }\n  vector<int> even, odd;\n  for (int e : se) {\n    (e & 1 ? odd : even).push_back(e);\n  }\n  auto primes = sieve(1e7);\n  int h = even.size(), w = odd.size();\n  bipartite_matching bm(h, w);\n  for (int i = 0; i < h; ++i) {\n    for (int j = 0; j < w; ++j) {\n      int d = abs(even[i] - odd[j]);\n      if (binary_search(begin(primes), end(primes), d)) {\n        bm.add(i, j);\n      }\n    }\n  }\n  int res = bm.run();\n  h -= res, w -= res;\n  if (h & 1) {\n    --h, --w;\n    res += 3;\n  }\n  res += h + w;\n  cout << res << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define pi 3.1415926535897932384626\nusing namespace std;\n      \nstruct P{\n  int x,y;\n  bool operator < (const P &a )const{\n    //if(y!=a.y)\n    return y>a.y;\n  };\n};\n\nint a,b,c,d,i,k,n,m,e[333],dx[10]={1,0,-1,0,1,1,-1,-1},dy[10]={0,1,0,-1,1,-1,1,-1};\nint o[310];\nint l[10000001];\nint j[331];\n\nlong long x,y,z,mod=1000000007;\n//string r;\nchar r[2];\n\nP u[1];\nqueue<int> q;\n//stack<int> s;\nset<int> s;\nmap<int,int> p;\n\nvector<int> v1;\nstruct S{\n  int x,l,r;\n};\nvector<S> v[444];\n\nbool as(P a,P b)\n{\n  return a.x<b.x;\n}\n\nvoid mk(int n,int m)\n{\n  v[n].push_back({m,1,(int)v[m].size()});\n  v[m].push_back({n,0,(int)v[n].size()-1});\n}\n\nvoid dfs()\n{\n  memset(j,-1,sizeof(j));\n  j[205]=0;\n  q.push(205);\n  for(;q.size();q.pop())\n  for(int h=0;h<v[q.front()].size();h++)\n  if(v[q.front()][h].l&&j[v[q.front()][h].x]<0)\n  {\n    j[v[q.front()][h].x]=j[q.front()]+1;\n    q.push(v[q.front()][h].x);\n  }\n}\n\nint f(int n,int m,int l)\n{\n  if(n==m) return l;\n  for(;e[n]<v[n].size();e[n]++)\n  if(v[n][e[n]].l&&j[v[n][e[n]].x]==j[n]+1)\n  {\n    int k=f(v[n][e[n]].x,m,min(l,v[n][e[n]].l));\n    if(k)\n    {\n      v[n][e[n]].l-=k;\n      v[v[n][e[n]].x][v[n][e[n]].r].l+=k;\n      return k;\n    }\n  }\n  return 0;\n}\n\nint main()\n{\n  l[1]=l[2]=1;\n  for(int t=3;t<=10000000;t+=2)\n  if(l[t]==0)\n  {\n    //v.push_back(t);\n    for(long long i=(long long)t*t;i<=10000000;i+=t)\n    l[i]=1;\n  }\n  scanf(\"%d\",&a);\n  for(int t=1;t<=a;t++)\n    scanf(\"%d\",&o[t]);\n  o[0]=-1;\n  for(int t=1;t<=a;t++)\n  {\n    if(o[t-1]+1!=o[t]) v1.push_back(o[t]);\n    if(o[t]+1!=o[t+1]) v1.push_back(o[t]+1);\n  }\n  for(int h=0;h<v1.size();h++)\n  if(v1[h]%2) n++,mk(205,h);\n  else m++,mk(h,210);\n  for(int i=0;i<v1.size();i++)\n  if(v1[i]%2)\n  for(int j=0;j<v1.size();j++)\n  if(v1[j]%2==0&&l[abs(v1[i]-v1[j])]==0)\n  {\n    mk(i,j);\n  }\n  for(;;)\n  {\n    dfs();\n    if(j[210]<0) break;\n    memset(e,0,sizeof(e));\n    d=f(205,210,555);\n    if(!d) break;\n    else k+=d;\n  }\n  //printf(\"%d %d %d\",n,m,k);\n  printf(\"%d\",k+(n-k)/2*2+(m-k)/2*2+abs(n-k)%2*3);\n}\n//664579\n\n\n\n//3\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=105;\nconst int L=10000005;\nint n;\nint a[L],b[L];\nint totc,c[N<<1];\nbool isprime(int x)\n{\n\tif(x==1) return 0;//\n\tint m=int(sqrt(x));\n\tfor(int i=2;i<=m;i++)\n\t\tif(x%i==0) return 0;\n\treturn 1;\n}\nint val1[N<<1],cnt1,val2[N<<1],cnt2;\nint sum,h[N<<1];\nstruct Edge{int v,nxt;}e[2*N*2*N];\nvoid adde(int x,int y){sum++;e[sum].v=y;e[sum].nxt=h[x];h[x]=sum;}\nbool v[N<<2];\nint match[N<<2];\nbool dfs(int x)\n{\n\tfor(int i=h[x];i;i=e[i].nxt)\n\t{\n\t\tint y=e[i].v;\n\t\tif(v[y]) continue;\n\t\tv[y]=1;\n\t\tif(!match[y]||dfs(match[y]))\n\t\t{\n\t\t\tmatch[y]=x;\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tint mx=0;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint x;\n\t\tscanf(\"%d\",&x);\n\t\ta[x]=1;\n\t\tmx=max(mx,x);\n\t}\n\tif(a[1]==1) b[1]=1,c[++totc]=1;\n\tfor(int i=2;i<=mx+1;i++)//for(int i=2;i<=mx;i++)\n\t{\n\t\tb[i]=a[i-1]^a[i];\n\t\tif(b[i]) c[++totc]=i;\n\t}\n\t//for(int i=1;i<=totc;i++) printf(\"%d \",c[i]);printf(\"\\n\");\n\tfor(int i=1;i<=totc;i++)\n\t{\n\t\tif(c[i]&1) val1[++cnt1]=c[i];//if(c[i]&1) val1[++cnt1]=i;\n\t\telse val2[++cnt2]=c[i];//else val2[++cnt2]=i;\n\t}\n\t//for(int i=1;i<=cnt1;i++) printf(\"%d \",val1[i]);printf(\"\\n\");\n\t//for(int i=1;i<=cnt2;i++) printf(\"%d \",val2[i]);printf(\"\\n\");\n\tfor(int i=1;i<=cnt1;i++)\n\t\tfor(int j=1;j<=cnt2;j++)\n\t\t\tif(isprime(abs(val2[j]-val1[i])))//if(isprime(val2[j]-val1[i]))\n\t\t\t\tadde(i,200+j);\n\tint matched=0;\n\tfor(int i=1;i<=cnt1;i++)\n\t{\n\t\tmemset(v,0,sizeof(v));\n\t\tif(dfs(i)) matched++;\n\t}\n\t//printf(\"%d %d %d\\n\",cnt1,cnt2,matched);\n\tint ans=matched;\n\tans+=(cnt1-matched)/2*2;\n\t//ans+=((cnt1-matched)&1)*3;\n\tans+=(cnt2-matched)/2*2;\n\t//ans+=((cnt2-matched)&1)*3;\n\tif(((cnt1-matched)&1)&&((cnt2-matched)&1)) ans+=3;\n\telse if(((cnt1-matched)&1)||((cnt2-matched)&1)) ans+=3;\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define il inline\n#define RG register\n#define ll long long\n#define N (10000005)\n\nusing namespace std;\n\nstruct edge{ int nt,to; }g[1000005];\n\nint prime[N/10],vis[N],can[N],head[510],vi[510],lk[510],a[510],b[510],k,n,num,cnt,cnt1,cnt2;\n\nil int gi(){\n  RG int x=0,q=1; RG char ch=getchar();\n  while ((ch<'0' || ch>'9') && ch!='-') ch=getchar();\n  if (ch=='-') q=-1,ch=getchar();\n  while (ch>='0' && ch<='9') x=x*10+ch-48,ch=getchar();\n  return q*x;\n}\n\nil void insert(RG int from,RG int to){\n  g[++num]=(edge){head[from],to},head[from]=num; return;\n}\n\nil int dfs(RG int x){\n  for (RG int i=head[x],v;i;i=g[i].nt){\n    v=g[i].to; if (vi[v]==cnt) continue; vi[v]=cnt;\n    if (!lk[v] || dfs(lk[v])){ lk[v]=x; return 1; }\n  }\n  return 0;\n}\n\nil void pre(){\n  vis[1]=1;\n  for (RG int i=2;i<N;++i){\n    if (!vis[i]) prime[++cnt]=i;\n    for (RG int j=1,k;j<=cnt;++j){\n      k=i*prime[j]; if (k>=N) break;\n      vis[k]=1; if (i%prime[j]==0) break;\n    }\n  }\n  vis[2]=1; return;\n}\n\nint main(){\n  n=gi(),pre();\n  for (RG int i=1;i<=n;++i) can[gi()]=1;\n  for (RG int i=1;i<N;++i){\n    if (can[i]==can[i-1]) continue;\n    (i&1)?a[++cnt1]=i:b[++cnt2]=i;\n  }\n  for (RG int i=1;i<=cnt1;++i)\n    for (RG int j=1;j<=cnt2;++j)\n      if (!vis[abs(a[i]-b[j])]) insert(i,j);\n  for (RG int i=1;i<=cnt1;++i) ++cnt,k+=dfs(i);\n  cout<<k+(cnt1-k)/2*2+(cnt2-k)/2*2+(cnt1-k)%2*3; return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int maxm=1e7+10,maxn=210;\nint n,a[maxn],b[maxn],m,ans;\nint b1[maxn],b2[maxn],p1,p2;\nbool np[maxm],vis[maxn],g[maxn][maxn],s[maxm];\nint match[maxn];\nvector<int> p;\n\nvoid init(){\n\tnp[0]=np[1]=1;\n\tfor(int i=2;i<maxm;++i){\n\t\tif(!np[i]){\n\t\t\tp.push_back(i);\n\t\t\t//cerr<<i<<endl;\n\t\t\t//system(\"pause\");\n\t\t}\n\t\tfor(int j=0,j_end=p.size(),x;j<j_end&&(x=p[j]*i)<maxm;++j){\n\t\t\tnp[x]=true;\n\t\t\tif(i%p[j]==0)break;\n\t\t}\n\t}\n\tnp[2]=1;\n}\n\nbool dfs(int u){\n\tif(vis[u])return false;\n\tvis[u]=1;\n\tfor(int i=1;i<=p2;++i)if(g[u][i]){\n\t\tif(!match[i]||dfs(match[i])){\n\t\t\tmatch[i]=u;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\nvoid solve(){\n\tinit();\n\tcin>>n;\n\tfor(int i=1;i<=n;++i){cin>>a[i];s[a[i]]=1;}\n\tfor(int i=1;i<maxm;++i){\n\t\tif(s[i]!=s[i-1])b[++m]=i;\n\t}\n\tfor(int i=1;i<=m;++i){\n\t\tif(b[i]&1)b1[++p1]=b[i];\n\t\telse b2[++p2]=b[i];\n\t}\n\t//cerr<<p1<<\" \"<<p2<<endl;\n\tfor(int i=1;i<=p1;++i){\n\t\tfor(int j=1;j<=p2;++j){\n\t\t\tif(!np[abs(b1[i]-b2[j])]){\n\t\t\t\tg[i][j]=true;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor(int i=1;i<=p1;++i){\n\t\tif(!match[i]){\n\t\t\tmemset(vis,0,sizeof vis);\n\t\t\tif(dfs(i))++ans;//match()\n\t\t}\n\t}\n\tp1-=ans;p2-=ans;\n\t//cerr<<ans<<endl;\n\tans+=p1/2*2+p2/2*2;\n\tans+=p1%2*3;\n\tcout<<ans<<endl;\n}\nint main(){\n\tsolve();\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cstdlib>\nusing namespace std;\n\n#define re_ return\n#define in_ inline\n#define op_ operator\n#define inc(l, i, r) for(i=l; i<r; ++i)\n#define st_ static\ntypedef long long ll;\n\nconst int mxn=1<<9;\n\nint n, m, a[mxn], b[mxn<<1], cnt[2], h[mxn<<1];\nstruct edge{int v, o;} e[1<<20];\n\nin_ ll dP(ll a, ll b, ll p)\n{\n    st_ ll r;\n    for(r=1; b; a=a*a%p, b>>=1)\n        b&1? r=r*a%p: 0;\n    re_ r;\n}\n\nin_ char chk(ll a, ll p)\n{\n    st_ ll s, r, i;\n    for(r=p-1, s=0; ~r&1; ++s, r/=2);\n    if(i=dP(a, r, p), i==1 || i==p-1) re_ 1;\n    for(;s--;)\n        if((i=i*i%p)==p-1) re_ 1;\n    re_ 0;\n}\n\nin_ char isP(int p)\n{\n    if(p==2) re_ 1;\n    if(p==1 || ~p&1) re_ 0;\n    st_  int i;\n    inc(0, i, 4)\n        if(!chk(rand()%(p-2)+1, p))\n            re_ 0;\n\n//    for(i=2; i*i<=p; ++i)\n//        if(p%i==0)\n//            re_ 0;\n    re_ 1;\n}\n\nin_ void aE(int u, int v)\n{\n    st_ int tot;\n    e[++tot]=(edge){v, h[u]}, u[h]=tot;\n}\n\nchar vis[mxn<<1];\nchar Hun(int u)\n{\n    st_ int f[mxn<<1];\n    int i, v;\n    for(i=u[h]; v=i[e].v; i=i[e].o)\n        if(!vis[v])\n            if(vis[v]=1, !f[v] || Hun(f[v]))\n            re_ f[v]=u, 1;\n    re_ 0;\n}\n\nint main()\n{\n    srand(998244353);\n    int i, j;\n    scanf(\"%d\", &n);\n    inc(0, i, n)\n        scanf(\"%d\", a+i);\n    sort(a, a+n);\n    inc(0, i, n)\n    {\n        if(!i || a[i]>a[i-1]+1)\n            b[++m]=a[i], ++cnt[a[i]&1];\n        if(i>n-2 || a[i]<a[i+1]-1)\n            b[++m]=a[i]+1, ++cnt[a[i]+1&1];\n    }\n    inc(1, i, m+1)\n        if(b[i]&1)\n            inc(1, j, m+1)\n                if(~b[j]&1 && isP(abs(b[i]-b[j])))\n                    aE(i, j);\n\n    j=0;\n    inc(1, i, m+1)\n        if(b[i]&1)\n            memset(vis, 0, sizeof(vis)),\n                j+=Hun(i);\n\n    printf(\"%d\\n\", cnt[0]+cnt[1]-j+(cnt[0]-j&1));\n//    printf(\"%d\\n\", m);\n//    for(;;) scanf(\"%d\", &i), printf(\"%d\\n\", isP(i));\n    0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <cstring>\n#include <cmath>\nusing namespace std;\n\nconst int MAX_N = 100 + 9;\nconst int MAX_M = 1e7 + 9;\n\nint N, x, cnt, match[MAX_N * 2 + 9], V;\nbool is_prime[MAX_M + 9], rev[MAX_M + 9], used[MAX_N * 2 + 9];\nvector<int> primes, v1, v2, G[MAX_N * 2 + 9];\n\nvoid sieve() {\n\tmemset(is_prime, 1, sizeof(is_prime));\n\tis_prime[0] = is_prime[1] = 0;\n\tfor (int i = 2; i <= MAX_M; i++) {\n\t\tif (is_prime[i]) {\n\t\t\tprimes.push_back(i);\n\t\t\tfor (int j = i * 2; j <= MAX_M; j += i) is_prime[j] = false;\n\t\t}\n\t}\n}\n\nbool dfs(int v) {\n\tfor (int u : G[v]) {\n\t\tif (!used[u]) {\n\t\t\tused[u] = true;\n\t\t\tif (match[u] < 0 || dfs(match[u])) {\n\t\t\t\tmatch[u] = v;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\nvoid bipartite_matching() {\n\tmemset(match, -1, sizeof(match));\n\tfor (int v = 0; v < v1.size(); v++) {\n\t\tif (match[v] < 0) {\n\t\t\tmemset(used, 0, sizeof(used));\n\t\t\tif (dfs(v)) {\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\tsieve();\n\tscanf(\"%d\", &N); \n\tfor (int i = 1; i <= N; i++) scanf(\"%d\", &x), rev[x] ^= true;\n\tfor (int i = 1; i <= MAX_M; i++) {\n\t\tif (rev[i] != rev[i - 1]) {\n\t\t\tif (i & 1) v1.push_back(i);\n\t\t\telse v2.push_back(i);\n\t\t}\n\t}\n\tfor (int i = 0; i < v1.size(); i++) {\n\t\tfor (int j = 0; j < v2.size(); j++) {\n\t\t\tint m = abs(v1[i] - v2[j]);\n\t\t\tif (is_prime[m]) G[i].push_back(j);\n\t\t}\n\t}\n\tV = v1.size() + v2.size();\n\tbipartite_matching();\n\tprintf(\"%d\", cnt + (v1.size() - cnt >> 1 << 1) + (v2.size() - cnt >> 1 << 1) + ((v1.size() - cnt) & 1) * 3);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <time.h>\n#include <random>\n#include <fstream>\n#include <set>\n\nusing namespace std;\n\nconst int N = 1e7 + 2;\n\nint n;\n\nint c[N];\nint p[N];\nint a[200];\n\nvector<int> graph[400];\n\nint paired[400];\nint marked[400];\n\nint TryKuhn(int v)\n{\n    if (marked[v]) return 0;\n    marked[v] = 1;\n    for (auto u : graph[v])\n    {\n        if (paired[u] == -1 || TryKuhn(paired[u]))\n        {\n            paired[u] = v;\n            return 1;\n        }\n    }\n    return 0;\n}\n\nint G()\n{\n    int res = 0;\n    fill(paired, paired + 400, -1);\n    for (int i = 0; i < n; i++)\n    {\n        fill(marked, marked + 400, 0);\n        if (TryKuhn(i))\n            res++;\n    }\n    return res;\n}\n\nsigned main()\n{\n    srand(time(NULL));\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    for (int i = 2; i < N; i++)\n    {\n        if (p[i] == 0)\n        {\n            for (int j = 2; j * i < N; j++) p[i * j] = 1;\n        }\n    }\n    p[2] = 1;\n    p[1] = 1;\n    cin >> n;\n    for (int i = 0; i < n; i++)\n    {\n        int x;\n        cin >> x;\n        c[x] = 1;\n    }\n    n = 0;\n    for (int i = 0; i + 1 < N; i++)\n    {\n        if (c[i] != c[i + 1])\n        {\n            a[n] = i;\n            n++;\n        }\n    }\n    for (int i = 0; i < n; i++)\n    {\n        for (int j = 0; j < n; j++)\n        {\n            if (a[i] % 2 == 0 && a[j] % 2 == 1)\n            {\n                if (!p[abs(a[i] - a[j])])\n                {\n                    graph[i].push_back(200 + j);\n                    graph[200 + j].push_back(i);\n                }\n            }\n        }\n    }\n    /*for (int i = 0; i < 400; i++)\n    {\n        for (auto u : graph[i])\n        {\n            cout << i << \" \" << u << endl;\n        }\n    }*/\n    int c0 = 0, c1 = 0, c2 = G();\n    for (int i = 0; i < n; i++)\n    {\n        if (a[i] % 2 == 0) c0++;\n        else c1++;\n    }\n    int ans = c2 + ((c0 - c2) / 2) * 2 + ((c1 - c2) / 2) * 2 + ((c1 - c2) % 2) * 3;\n    cout << ans;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <complex>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <limits>\n#include <climits>\n#include <cfloat>\n#include <functional>\n#include <iterator>\nusing namespace std;\n\nvoid findPrime(int N, vector<bool>& isPrime)\n{\n    isPrime.assign(N+1, true);\n    isPrime[0] = isPrime[1] = false;\n    for(int i=2; i*i<=N; i++){\n        if(isPrime[i]){\n            for(int j=i; i*j<=N; j++){\n                isPrime[i*j] = false;\n            }\n        }\n    }\n}\n\nint bipartiteMaximumMatchings(const vector<vector<bool> >& graph)\n{\n    int ret = 0;\n    int n = graph.size();\n    if(n == 0)\n        return 0;\n    int m = graph[0].size();\n    if(m == 0)\n        return 0;\n    vector<int> selectN(n, -1);\n    vector<int> selectM(m, -1);\n\n    for(int i=0; i<n; ++i){\n        vector<bool> visitedN(n, false);\n        vector<bool> visitedM(m, false);\n        visitedN[i] = true;\n        vector<int> path(min(n,m)*2, -1);\n\n        path[0] = i;\n        int index = 1;\n        for(;;){\n            while(++path[index] < m && (!graph[path[index-1]][path[index]] || selectN[path[index-1]]==path[index] || visitedM[path[index]]));\n            if(path[index] < m){\n                if(selectM[path[index]] == -1){\n                    for(int j=0; j<index; j+=2){\n                        selectN[path[j]] = path[j+1];\n                        selectM[path[j+1]] = path[j];\n                    }\n                    ++ ret;\n                    break;\n                }\n                if(!visitedN[selectM[path[index]]]){\n                    path[index+1] = selectM[path[index]];\n                    visitedM[path[index]] = true;\n                    visitedN[path[index+1]] = true;\n                    index += 2;\n                }\n            }\n            else{\n                path[index] = -1;\n                index -= 2;\n                if(index < 0)\n                    break;\n            }\n        }\n\n        if(ret == m)\n            break;\n    }\n\n    return ret;\n}\n\nconst int MAX = 10000000;\n\nint main()\n{\n    vector<bool> isPrime;\n    findPrime(MAX, isPrime);\n\n    int n;\n    cin >> n;\n    set<int> s;\n    for(int i=0; i<n; ++i){\n        int x;\n        cin >> x;\n        for(int j=0; j<2; ++j){\n            int y = x + j;\n            if(s.find(y) == s.end())\n                s.insert(y);\n            else\n                s.erase(y);\n        }\n    }\n\n    vector<vector<int> > v(2);\n    for(int x : s)\n        v[x%2].push_back(x);\n\n    int a = v[0].size();\n    int b = v[1].size();\n    vector<vector<bool> > graph(a, vector<bool>(b, false));\n    for(int i=0; i<a; ++i){\n        for(int j=0; j<b; ++j){\n            int a = abs(v[0][i] - v[1][j]);\n            if(a >= 3 && isPrime[a])\n                graph[i][j] = true;\n        }\n    }\n\n    int match = bipartiteMaximumMatchings(graph);\n    int ans = match + ((a - match) / 2 + (b - match) / 2) * 2 + ((a - match) % 2) * 3;\n    cout << ans << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cstdlib>\nusing namespace std;\n\n#define re_ return\n#define in_ inline\n#define op_ operator\n#define inc(l, i, r) for(i=l; i<r; ++i)\n#define st_ static\ntypedef long long ll;\n\nconst int mxn=1<<7;\n\nint n, m, a[mxn], b[mxn<<1], cnt[2], h[mxn<<1];\nstruct edge{int v, o;} e[mxn<<2];\n\nin_ ll dP(ll a, ll b, ll p)\n{\n    st_ ll r;\n    for(r=1; b; a=a*a%p, b>>=1)\n        b&1? r=r*a%p: 0;\n    re_ r;\n}\n\nin_ char chk(ll a, ll p)\n{\n    st_ ll s, r, i;\n    for(r=p-1, s=0; ~r&1; ++s, r/=2);\n    if(i=dP(a, r, p), i==1 || i==p-1) re_ 1;\n    for(;s--;)\n        if((i=i*i%p)==p-1) re_ 1;\n    re_ 0;\n}\n\nin_ char isP(int p)\n{\n    st_  int i;\n    inc(0, i, 32)\n        if(!chk(rand()%(p-2)+1, p))\n            re_ 0;\n    re_ 1;\n}\n\nin_ void aE(int u, int v)\n{\n    st_ int tot;\n    e[++tot]=(edge){v, h[u]}, u[h]=tot;\n}\n\nchar Hun(int u)\n{\n    st_ int f[mxn<<1], vis[mxn<<1];\n    int i, v;\n    if(vis[u]) re_ 0; vis[u]=1;\n    for(i=u[h]; v=i[e].v; i=i[e].o)\n        if(!f[v] || Hun(f[v]))\n            re_ f[v]=u, vis[u]=0, 1;\n    re_ vis[u]=0;\n}\n\nint main()\n{\n    srand(998244353);\n    int i, j;\n    scanf(\"%d\", &n);\n    inc(0, i, n)\n        scanf(\"%d\", a+i);\n    inc(0, i, n)\n    {\n        if(!i || a[i]>a[i-1]+1)\n            b[++m]=a[i], ++cnt[a[i]&1];\n        if(i>n-2 || a[i]<a[i+1]-1)\n            b[++m]=a[i]+1, ++cnt[a[i]+1&1];\n    }\n    inc(1, i, m+1)\n        if(b[i]&1)\n            inc(1, j, m+1)\n                if(~b[i]&1 && isP(abs(b[i]-b[j])))\n                    aE(i, j);\n\n    j=0;\n    inc(1, i, m+1)\n        if(b[i]&1)\n            j+=Hun(i);\n\n    printf(\"%d\\n\", j+(cnt[0]-j&~1)+(cnt[1]-j&~1)+(cnt[0]-j&1? 3:0));\n    re_ 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <algorithm>\n#include <queue>\n#include <vector>\n#include <stack>\n#include <cmath>\n#include <memory.h>\n#include <iomanip>\n#include <cassert>\nusing namespace std;\n\n#define maxn 202\n#define FOR(i, l, r) for (int i=l; i<=r; ++i)\n#define FORD(i, r, l) for (int i=r; i>=l; --i)\n#define REP(i, r) for (int i=0; i<(int)r; ++i)\n#define REPD(i, r) for (int i=(int)r-1; i>=0; --i)\n#define fi first\n#define se second\n#define mk make_pair\n#define nil NULL\n#define y0 y902\n#define y1 y232\n#define x0 x92\n#define x1 x899\n#define next asdfa\n#define sz size\n#define Debug(X) {cerr << #X << \" = \" << X << '\\n';}\n#define PR(A, n) {cerr << #A << \" = \"; FOR(i, 1, n) cerr << A[i] << ' '; cerr << '\\n';}\n#define PR0(A, n) {cerr << #A << \" = \"; REP(i, n) cerr << A[i] << ' '; cerr << '\\n';}\ntypedef long long ll;\ntypedef double db;\ntypedef pair<db, db> dd;\ntypedef pair<int, int> ii;\ntypedef vector<int> vi;\nconst int inf = 1e9;\ntemplate<class T> int getbit(T x, int pos) {return (x>>(pos-1)) & 1;}\ntemplate<class T> void turn_on(T &x, int pos) {x = x | ((T)1<<(pos-1));}\ntemplate<class T> void turn_off(T &x, int pos) {x = x & ~((T)1<<(pos-1));}\ntemplate<class T> T sqr(T a) {return a*a;}\n\nint n, assigned[maxn], visited[maxn], t;\nvector<int> a[maxn], even, odd;\n\nint visit(int u) {\n    if (visited[u]!=t) visited[u] = t;\n    else return 0;\n    REP(i, a[u].sz()) {\n        int v = a[u][i];\n        if (!assigned[v] || visit(assigned[v])) {\n            assigned[v] = u;\n            return 1;\n        }\n    }\n    return 0;\n}\n\nint findMaximumMatching() {\n    int cnt = 0;\n    REP(i, even.sz()) {\n        ++t;\n        cnt += visit(i);\n    }\n    return cnt;\n}\n\nbool isPrime(int a) {       ///notice that function will return false if a=2\n    if (a<=2) return false;\n    FOR(i, 2, sqrt(a)) {\n        if (a%i==0) return false;\n    }\n    return true;\n}\n\nint main() {\n    //freopen(\"prflip.inp\", \"r\", stdin);\n    //freopen(\"prflip.ans\", \"w\", stdout);\n    //ios::sync_with_stdio(0); cin.tie(0);\n    scanf(\"%d\", &n);\n    int prev = -1;\n    FOR(i, 1, n) {\n        int x; scanf(\"%d\", &x);\n        if (x!=prev+1) {\n            if (prev!=-1 && (prev+1)%2==0) even.push_back(prev+1);\n            else if (prev!=-1) odd.push_back(prev+1);\n            if (x%2==0) even.push_back(x);\n            else odd.push_back(x);\n        }\n        prev = x;\n    }\n    if ((prev+1)%2==0) even.push_back(prev+1);\n    else odd.push_back(prev+1);\n    REP(i, even.sz()) REP(j, odd.sz()) {\n        if (isPrime(abs(even[i]-odd[j])))\n            a[i].push_back(j);\n    }\n    int k = findMaximumMatching(), res = inf;\n    assert(even.sz()%2==odd.sz());\n    FOR(i, 0, k) {\n        if (((int)even.sz()-k)%2==0) res = min(res, k+((int)even.sz()-k)+((int)odd.sz()-k));\n        else res = min(res, k+((int)even.sz()-1-k)+((int)odd.sz()-1-k)+3);\n    }\n    printf(\"%d\", res);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\n#include<queue>\n#include<deque>\n#include<string>\n#include<string.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<stdlib.h>\n#include<cassert>\nusing namespace std;\nconst long long mod=1000000007;\nconst long long inf=mod*mod;\nconst long long d2=500000004;\nconst double EPS=1e-6;\nconst double PI=acos(-1.0);\nint ABS(int a){return max(a,-a);}\nlong long ABS(long long a){return max(a,-a);}\nconst int D_MAX_V=2002;\nconst int D_v_size=2002;\nstruct D_wolf{\n\tint t,c,r;\n\tD_wolf(){t=c=r=0;}\n\tD_wolf(int t1,int c1,int r1){\n\t\tt=t1;c=c1;r=r1;\n\t}\n};\nvector<D_wolf>D_G[D_MAX_V];\nint D_level[D_MAX_V];\nint D_iter[D_MAX_V];\n\nvoid add_edge(int from,int to,int cap){\n\tD_G[from].push_back(D_wolf(to,cap,D_G[to].size()));\n\tD_G[to].push_back(D_wolf(from,0,D_G[from].size()-1));\n}\nvoid D_bfs(int s){\n\tfor(int i=0;i<D_v_size;i++)D_level[i]=-1;\n\tqueue<int> Q;\n\tD_level[s]=0;\n\tQ.push(s);\n\twhile(Q.size()){\n\t\tint v=Q.front();\n\t\tQ.pop();\n\t\tfor(int i=0;i<D_G[v].size();i++){\n\t\t\tif(D_G[v][i].c>0&&D_level[D_G[v][i].t]<0){\n\t\t\t\tD_level[D_G[v][i].t]=D_level[v]+1;\n\t\t\t\tQ.push(D_G[v][i].t);\n\t\t\t}\n\t\t}\n\t}\n}\nint D_dfs(int v,int t,int f){\n\tif(v==t)return f;\n\tfor(;D_iter[v]<D_G[v].size();D_iter[v]++){\n\t\tint i=D_iter[v];\n\t\tif(D_G[v][i].c>0&&D_level[v]<D_level[D_G[v][i].t]){\n\t\t\tint d=D_dfs(D_G[v][i].t,t,min(f,D_G[v][i].c));\n\t\t\tif(d>0){\n\t\t\t\tD_G[v][i].c-=d;\n\t\t\t\tD_G[D_G[v][i].t][D_G[v][i].r].c+=d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nint max_flow(int s,int t){\n\tint flow=0;\n\tfor(;;){\n\t\tD_bfs(s);\n\t\tif(D_level[t]<0)return flow;\n\t\tfor(int i=0;i<D_v_size;i++)D_iter[i]=0;\n\t\tint f;\n\t\twhile((f=D_dfs(s,t,99999999))>0){flow+=f;}\n\t}\n\treturn 0;\n}\nint pr(int a){\n\tif(a<=2)return 0;\n\tfor(int i=2;i*i<=a;i++){\n\t\tif(a%i==0)return 0;\n\t}\n\treturn 1;\n}\nint x[310];\nint y[310];\nint main(){\n\tint G=0;\n\tint K=0;\n\tint n;scanf(\"%d\",&n);\n\tfor(int i=0;i<n;i++)scanf(\"%d\",y+i);\n\tint a=0;\n\tfor(int i=0;i<n;i++){\n\t\tif(i==0||y[i]!=y[i-1]+1){\n\t\t\tx[a++]=y[i];\n\t\t}\n\t\tif(i==n-1||y[i]+1!=y[i+1]){\n\t\t\tx[a++]=y[i]+1;\n\t\t}\n\t}\n//\tfor(int i=0;i<a;i++)printf(\"%d \",x[i]);\n//\t\tprintf(\"\\n\");\n\tfor(int i=0;i<a;i++)for(int j=0;j<a;j++){\n\t\tif(x[i]%2<x[j]%2){\n\t\t\tint t=ABS(x[i]-x[j]);\n\t\t\tif(pr(t)){\n\t//\t\t\tprintf(\"%d\\n\",t);\n\t\t\t\tadd_edge(i,j,1);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<a;i++){\n\t\tif(x[i]%2==0){\n\t\t\tadd_edge(a,i,1);\n\t\t\tG++;\n\t\t}else{\n\t\t\tadd_edge(i,a+1,1);\n\t\t\tK++;\n\t\t}\n\t}\n\tint f=max_flow(a,a+1);\n\tint ret=f;\n\tret+=2*((G-f)/2+(K-f)/2);\n\tret+=3*((G-f)%2);\n\tprintf(\"%d\\n\",ret);\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cctype>\n#include<cstring>\n#include<iostream>\n#include<vector>\n#include<bitset>\n#include<ctime>\n#include<cmath>\n#include<queue>\n\nusing namespace std;\n\n#define bomb exit(1)\n#define INF 1061109567\n#define LINF 4557430888798830399ll\n#define pprint(x) print(x),putchar(' ')\n#define fprint(x) print(x),putchar('\\n')\n#define EE(x); struct edge { int nxt,to,w; }e[M << 1]; int head[N],ecnt = 1;\\\n\tvoid add(int u,int v,ll w = 0) { e[++ecnt].w = w,e[ecnt].to = v,e[ecnt].nxt = head[u];head[u] = ecnt; }\\\n\tvoid add_edge(int u,int v,ll w = 0) { add(u,v,w),add(v,u,w * x); }\n#define ll long long\nconst double pi = acos(-1);\nint mod = 1000000007;\nll Mod(ll x) { return x >= mod ? x - mod : x; }\n#define eps 0.0000000001\n#define sqr(x) ((x) * (x))\n#define iter iterator\n#define fi first\n#define se second\n//#define getchar() (SS == TT && (TT = (SS = BB) + fread(BB,1,1 << 15,stdin),TT == SS) ? EOF : *SS++)\n//char BB[1 << 15],*SS = BB,*TT = BB;\nll read()\n{\n\tll x = 0;int f = 1;char ch = getchar();\n\tfor(;!isdigit(ch);ch = getchar()) if(ch == '-') f = -1;\n\tfor(;isdigit(ch);ch = getchar()) x = x * 10 + (ch ^ 48);\n\treturn x * f;\n}\nvoid print(ll x)\n{\n\tif(x < 0) putchar('-'),x = -x;\n\tif(x > 9) print(x / 10);putchar(x % 10 + '0');\n}\n\nconst int N = 110,M = 10000010;\n\nstruct MAX_FLOW\n{\n\tEE(0);\n\tint S,T;\n\tqueue<int> q;int dis[N],cur[N];\n\tbool BFS()\n\t{\n\t\tmemset(dis,-1,sizeof(dis));\n\t\tq.push(S),dis[S] = 0;\n\t\twhile(!q.empty())\n\t\t{\n\t\t\tint u = q.front();q.pop();\n\t\t\tfor(int i = cur[u] = head[u];i;i = e[i].nxt)\n\t\t\t{\n\t\t\t\tint v = e[i].to;\n\t\t\t\tif(!~dis[v] && e[i].w) q.push(v),dis[v] = dis[u] + 1;\n\t\t\t}\n\t\t}return ~dis[T];\n\t}\n\tint DFS(int u,int exp)\n\t{\n\t\tif(u == T) return exp;\n\t\tint flow = 0,f;\n\t\tfor(int &i = cur[u];i;i = e[i].nxt)\n\t\t{\n\t\t\tint v = e[i].to;\n\t\t\tif(e[i].w && dis[v] == dis[u] + 1)\n\t\t\t{\n\t\t\t\tf = DFS(v,min(exp,e[i].w));\n\t\t\t\texp -= f,flow += f;\n\t\t\t\te[i].w -= f,e[i ^ 1].w += f;\n\t\t\t\tif(!exp) break;\n\t\t\t}\\\n\t\t}return flow;\n\t}\n\tint Dinic()\n\t{\n\t\tint maxflow = 0,f;\n\t\twhile(BFS()) while(f = DFS(S,INF)) maxflow += f;\n\t\treturn maxflow;\n\t}\n}G;\n\nint prime[1000010],tot;\nbool vis[10000010];\nvoid init(int n)\n{\n\tvis[0] = vis[1] = 1;\n\tfor(int i = 2;i <= n;i++)\n\t{\n\t\tif(!vis[i]) prime[++tot] = i;\n\t\tfor(int j = 1;j <= tot && i * prime[j] <= n;j++)\n\t\t{\n\t\t\tvis[i * prime[j]] = 1;\n\t\t\tif(i % prime[j] == 0) break;\n\t\t}\n\t}\n}\n\nint n,a[N];\nint L[N << 1],R[N << 1],cntl,cntr;\nvoid push(int x) { if(x & 1) L[++cntl] = x;else R[++cntr] = x; }\nint main()\n{\n\tinit(10000000);\n\tn = read();for(int i = 1;i <= n;i++) a[i] = read();sort(a + 1,a + 1 + n);\n\tfor(int i = 1;i <= n;i++)\n\t{\n\t\tif(a[i - 1] + 1 != a[i] || i == 1) push(a[i]);\n\t\tif(a[i + 1] - 1 != a[i]) push(a[i] + 1);\n\t}\n\tG.S = 0,G.T = cntl + cntr + 1;\n\tfor(int i = 1;i <= cntl;i++) G.add_edge(G.S,i,1);\n\tfor(int i = 1;i <= cntr;i++) G.add_edge(i + cntl,G.T,1);\n\tfor(int i = 1;i <= cntl;i++) for(int j = 1;j <= cntr;j++)\n\t\tif(!vis[abs(L[i] - R[j])]) G.add_edge(i,j + cntl,1);\n\tint maxflow = G.Dinic();\n\tint ans = maxflow;\n\tans += (cntl - maxflow) / 2 * 2 + (cntr - maxflow) / 2 * 2;\n\tans += ((cntl - maxflow) & 1) * 3;\n\tfprint(ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define REP(I, A) for(int (I) = 0; (I) < (A); (I)++)\n#define pb(I) push_back(I)\nconst int N = 10000000;\n\nset<int> s, e;\nvector<int> vx, vy, Gx[200];\nbool is_prime[N];\nint mat[1000], R;\nbool vis[1000];\n\nvoid prepare() {\n\tfor (int i = 2; i < N; i++) {\n\t\tfor (int j = 2*i; j < N; j+=i)\n\t\t\tis_prime[j] = true;\n\t}\n}\n\nbool dfs(int x) {\n\tfor (int v : Gx[x]) {\n\t\tif(!vis[v]) {\n\t\t\tvis[v] = true;\n\t\t\tif(mat[v+R] == -1 || dfs(mat[v+R])) {\n\t\t\t\tmat[v+R] = x;\n\t\t\t\tmat[x] = v;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\nint domatch() {\n\tmemset(mat, -1, sizeof(mat));\n\tint cnt = 0;\n\tREP(i, vx.size()) {\n\t\tif(mat[i]) continue;\n\t\tmemset(vis, 0, sizeof(vis));\n\t\tcnt += dfs(vx[i]);\n\t}\n\treturn cnt;\n}\n\nint main() {\n\tprepare();\n\tint n, x;\n\tscanf(\"%d\", &n);\n\tR = 110;\n\tREP(i, n) {\n\t\tscanf(\"%d\", &x);\n\t\ts.insert(x);\n\t}\n\tfor (int u : s) {\n\t\tif(!s.count(u-1)) e.insert(u);\n\t\tif(!s.count(u+1)) e.insert(u+1);\n\t}\n\tfor (int u : e)\n\t\tif(u&1) vx.pb(u);\n\t\telse vy.pb(u);\n\tREP(i, vx.size())\n\t\tREP(j, vy.size())\n\t\t\tif(!is_prime[abs(vx[i]-vy[j])])\n\t\t\t\tGx[i].pb(j);\n\tint t = domatch();\n\tint l1 = vx.size() - t, l2 = vy.size() - t;\n\tint res = t;\n\tres += l1/2*2;\n\tres += l2/2*2;\n\tif(l1%2==1 && l2%2==1) res += 3;\n\tcout << res << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <cstring>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <list>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <unordered_set>\n#include <unordered_map>\n#include <array>\n#include <cassert>\n#include <bitset>\nusing namespace std;\nusing LL = long long;\n\nint N;\nvector<int>X;\nvector<pair<int,int>>P;//first:left second:width\nint dp[123];\nconst int SIZ = 10000001;\nbool isprime[SIZ];\n\nint main(void)\n{\n\tcin >> N;\n\tfor (int i = 0; i < N; ++i)\n\t{\n\t\tint x;\n\t\tcin >> x;\n\t\tX.push_back(x);\n\t}\n\tfill(isprime, isprime + SIZ, true);\n\tfor (int i = 2; i < SIZ; ++i)\n\t{\n\t\tif (isprime[i])\n\t\t{\n\t\t\tfor (int j = i + i; j < SIZ; j += i)\n\t\t\t{\n\t\t\t\tisprime[j] = false;\n\t\t\t}\n\t\t}\n\t}\n\tisprime[0] = isprime[1] = false;\n\tint i = 0;\n\twhile (i < N) \n\t{\n\t\tint left = X[i];\n\t\tint p = 1;\n\t\twhile (i + 1 < N && X[i + 1] == X[i] + 1)\n\t\t{\n\t\t\t++i;\n\t\t\t++p;\n\t\t}\n\t\tP.push_back({ left, p });\n\t\t++i;\n\t}\n\tint D = P.size();\n\tfill(dp, dp + 123, 114514);\n\tdp[0] = 0;\n\tfor (int i = 0; i < D; ++i)\n\t{\n\t\t//一つを削除する\n\t\tif (P[i].second % 2 == 0)\n\t\t{\n\t\t\t//偶数=p+q\n\t\t\t{\n\t\t\t\tdp[i + 1] = min(dp[i + 1], dp[i] + 2);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\t//奇数\n\t\t\tif (isprime[P[i].second])\n\t\t\t{\n\t\t\t\t//p\n\t\t\t\tdp[i + 1] = min(dp[i + 1], dp[i] + 1);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t//p+q+3(2は使えないため)\n\t\t\t\tdp[i + 1] = min(dp[i + 1], dp[i] + 3);\n\t\t\t}\n\t\t}\n\t\tif (i + 1 != D)\n\t\t{\n\t\t\t//二つを削除する\n\t\t\tint left = P[i].second;\n\t\t\tint right = P[i + 1].second;\n\t\t\tint middle = P[i + 1].first - P[i].first - P[i].second;\n\t\t\tif (left % 2 && right % 2 == 0)\n\t\t\t{\n\t\t\t\tswap(left, right);\n\t\t\t}\n\t\t\tif (left % 2 && right % 2)\n\t\t\t{\n\t\t\t\tif (middle % 2)\n\t\t\t\t{\n\t\t\t\t\tbool m = isprime[middle];\n\t\t\t\t\tbool n = isprime[left + right + middle];\n\t\t\t\t\tdp[i + 2] = min(dp[i + 2], dp[i] + 2 + (m * 2) + (n * 2));\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tbool m = !isprime[middle];//2\n\t\t\t\t\tdp[i + 2] = min(dp[i + 2], dp[i] + 3 + m);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (left % 2 == 0 && right % 2)\n\t\t\t{\n\t\t\t\tif (middle % 2)\n\t\t\t\t{\n\t\t\t\t\tbool m = isprime[middle];\n\t\t\t\t\tdp[i + 2] = min(dp[i + 2], dp[i] + 3 + (m * 2));\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tbool m = !isprime[middle];//2\n\t\t\t\t\tbool n = isprime[left + right + middle];\n\t\t\t\t\tdp[i + 2] = min(dp[i + 2], dp[i] + 2 + m + (n * 2));\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (middle % 2)\n\t\t\t\t{\n\t\t\t\t\tbool m = isprime[middle];\n\t\t\t\t\tbool n = isprime[left + right + middle];\n\t\t\t\t\tdp[i + 2] = min(dp[i + 2], dp[i] + 2 + (m * 2) + (n * 2));\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tbool m = !isprime[middle];//2\n\t\t\t\t\tdp[i + 2] = min(dp[i + 2], dp[i] + 3 + m);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << dp[D] << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<cmath>\n#define N 210\n#define M N*N\n#define MX 20000000\nusing namespace std;\nint nxt[M<<1],to[M<<1],head[N],cnt;\nbool vis[N<<1];\nint link[N<<1],lf[N<<1],rf[N<<1],n,m;\nint prime[MX],maxp[MX];\nbool cant[MX];\nvoid add(int u,int v)\n{\n\tnxt[++cnt]=head[u];\n\tto[cnt]=v;\n\thead[u]=cnt;\n}\nbool check(int u)\n{\n\tfor(int i=head[u];i;i=nxt[i])\n\t{\n\t\tint v=to[i];\n\t\tif(vis[v]) continue;\n\t\tvis[v]=true;\n\t\tif(!link[v] || check(link[v]))\n\t\t{\n\t\t\tlink[u]=v;\n\t\t\tlink[v]=u;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\nvoid build()\n{\n\tfor(int i=1;i<=lf[0];i++)\n\t{\n\t\tint x=lf[i];\n\t\tfor(int j=1;j<=rf[0];j++)\n\t\t{\n\t\t\tint y=rf[j];\n\t\t\tif(cant[abs(x-y)]) continue;\n\t\t\tadd(i,j+lf[0]);\n\t\t\tadd(j+lf[0],i);\n\t\t}\n\t}\n}\nbool color[MX];\nint maxn=0;\nvoid solve()\n{\n\tlf[0]=rf[0]=0;\n\tfor(int i=1;i<=maxn;i++)\n\t\tif(color[i]!=color[i-1])\n\t\t{\n\t\t\tif(i&1) rf[++rf[0]]=i;\n\t\t\telse lf[++lf[0]]=i;\n\t\t}\n\tbuild();\n\tint ans=0;\n\tfor(int i=1;i<=lf[0];i++)\n\tif(!link[i])\n\t{\n\t\tmemset(vis,0,sizeof(vis));\n\t\tans+=check(i);\n\t}\n\tint res=0;\n\tif(ans<lf[0]) res+=(lf[0]-ans)/2*2;\n\tif(ans<rf[0]) res+=(rf[0]-ans)/2*2;\n\tif((lf[0]-ans)%2==1) res+=3;\n\tprintf(\"%d\\n\",ans+res);\n}\nint main()\n{\n\tint cnt=0;\n\tprime[1]=1;\n\tcant[1]=1;\n\tfor(int i=2;i<=MX-10;++i)\n\t{\n\t\tif(!cant[i])\n\t\t{\n\t\t\tprime[++cnt]=i;\n\t\t\tmaxp[i]=i;\n\t\t}\n\t\tfor(int j=1;j<=cnt && i*prime[j]<=MX-10;j++)\n\t\t{\n\t\t\tcant[i*prime[j]]=true;\n\t\t\tif(i%prime[j]==0)\n\t\t\t{\n\t\t\t\tmaxp[i*prime[j]]=prime[j];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint a;\n\t\tscanf(\"%d\",&a);\n\t\tcolor[a]=true;\n\t\tmaxn=max(maxn,a);\n\t}\n\tmaxn++;\n\tsolve();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\ntypedef long long ll;\nint odd,even,Odd[105],Even[105],ma[105];\nbool flag[10000010],x[10000010],map[105][105],vis[105];\nint prime[10000010],a[105];\nint dfs(int u)\n{\n\tfor (int v=1;v<=even;v++)\n\t{\n\t\tif (!map[u][v]) continue;\n\t\tif (!vis[v])\n\t\t{\n\t\t\tint t=ma[v];\n\t\t\tma[v]=u;\n\t\t\tif (t==-1||dfs(t)) return 1;\n\t\t\tma[v]=t;\n\t\t}\n\t}\n\treturn 0;\n}\nint main()\n{\n\tint n,cnt=0;\n\tscanf(\"%d\",&n);\n\tflag[1]=1;\n\tfor (int i=2;i<=10000000;i++)\n\t{\n\t\tif (!flag[i]) prime[+cnt]=i;\n\t\tfor (int j=1;j<=cnt;j++)\n\t\t{\n\t\t\tif (i*prime[j]>10000000) break;\n\t\t\tflag[i*prime[j]]=1;\n\t\t\tif (i%prime[j]==0) break;\n\t\t}\n\t}\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%d\",&a[i]);\n\t\tx[a[i]]^=1;\n\t}\n\tfor (int i=1;i<=10000000;i++)\n\t\tif (x[i]!=x[i-1])\n\t\t{\n\t\t\tif (i&1) Odd[++odd]=i;\n\t\t\telse Even[++even]=i; \n\t\t}\n\tfor (int i=1;i<=odd;i++)\n\t\tfor (int j=1;j<=even;j++)\n\t\t\tif (flag[abs(Odd[i]-Even[j])]) map[i][j]=1;\n\tmemset(ma,-1,sizeof(ma));\n\tint sum=0;\n\tfor (int i=1;i<=odd;i++)\n\t{\n\t\tmemset(vis,0,sizeof(vis));\n\t\tif (dfs(i)) sum++;\n\t}\n\tll ans=sum+(((odd-sum)>>1)<<1)+(((even-sum)>>1)<<1)+(odd-sum)%2*3;\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define L long long\n#define pb push_back\n#define pi pair<int,int>\n#define pii pair<pair<int,int>,int>\n#define aa first\n#define bb second\n#define mp make_pair\n#define mpp(a,b,c) mp(mp(a,b),c)\nusing namespace std;\n#define SZ 666666\ntypedef long long ll;\nint fst[SZ],nxt[SZ],vb[SZ],cap[SZ],ff[SZ],M=1,N=0;\n#define add ad_dl\nvoid _ad_dl(int a,int b,int c) {++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;cap[M]=c;}\nvoid ad_dl(int a,int b,int c)\n{_ad_dl(a,b,c); _ad_dl(b,a,0);}\nint S,T,q[SZ],d[SZ];\nbool bfs()\n{\n    memset(d,-1,4*(N+1));\n    d[T]=0; q[1]=T; int h=1,t=2;\n    while(h!=t)\n    {\n        int cur=q[h++];\n        for(int e=fst[cur];e;e=nxt[e])\n        {\n            int b=vb[e];\n            if(d[b]==-1&&cap[e^1])\n            {\n                d[b]=d[cur]+1, q[t++]=b;\n                if(b==S) return 1; //???? \n            }\n        }\n    }\n    return d[S]!=-1;\n}\nint dfs(int x,int f)\n{\n    if(f<=0) return 0;\n    if(x==T) return f;\n    int ca=0;\n    for(int& e=fst[x];e;e=nxt[e]) //????? \n    {\n        int b=vb[e];\n        if(d[b]+1!=d[x]) continue;\n        int w=dfs(b,(cap[e]<f-ca)?cap[e]:(f-ca));\n        cap[e]-=w; cap[e^1]+=w; ca+=w;\n        if(ca==f) break;\n    }\n    if(!ca) d[x]=-1; //????? \n    return ca;\n}\n#define inf 2e9+3\nint dinic()\n{\n    int ans=0;\n    memcpy(ff,fst,4*(N+1));\n    while(bfs())\n    {\n        //?????\n        ans+=dfs(S,inf);\n        memcpy(fst,ff,4*(N+1));\n    }\n    return ans;\n}\nint n,m,x[110],f[210],p;\nbool a[10000010];\nint main()\n{\n\t//freopen(\".in\",\"r\",stdin);\n\t//freopen(\".out\",\"w\",stdout);\n\tint i,j,k;\n\tscanf(\"%d\",&n);\n\tfor(i=1;i<=n;i++)\n\t  scanf(\"%d\",&x[i]);\n\tfor(i=2;i<=n;i++)\n\t  if(x[i-1]+1!=x[i])\n\t    {\n\t\t f[++m]=x[i-1]+1;\n\t\t f[++m]=x[i];\n\t\t}\n\tf[++m]=x[1];\n\tf[++m]=x[n]+1;\n\ta[1]=1;\n\tfor(i=2;i<=10000000;i++)\n\t  if(!a[i])\n\t    for(j=i;j<=10000000;j+=i)\n\t      a[j]=1;\n\ta[2]=1;\n\tN=m+2;\n\tS=m+2;\n\tT=m+1;\n\tfor(i=1;i<=m;i++)\n\t  if(f[i]&1)\n\t    add(m+2,i,1);\n\t  else\n\t    add(i,m+1,1);\n\tfor(i=1;i<=m;i++)\n\t  for(j=1;j<=m;j++)\n\t    if(f[i]&1 && !a[abs(f[i]-f[j])])\n\t      add(i,j,1);\n\tp=k=dinic();\n\tfor(i=1,j=-k;i<=m;i++)\n\t  if(f[i]&1)\n\t    j++;\n\tp+=j/2*2;\n\tif(j&1)\n\t  p+=3;\n\tfor(i=1,j=-k;i<=m;i++)\n\t  if(!(f[i]&1))\n\t    j++;\n\tp+=j/2*2;\n\tprintf(\"%d\\n\",p);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<cstring>\n#include<map>\n#include<queue>\n#include<cmath>\nusing namespace std;\ntypedef long long ll;\nconst int N=105,INF=~0u>>2;\nstruct Edge{int nxt,to;}edge[(N*N)<<2];\nint a[N],b[N],n,head[N<<2],num_edge,vis[N<<2],lk[N<<2],even[N],odd[N],even_num,odd_num,ans,k,tot,tim;\nint read(){\n\tint x=0,f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-') f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn f*x;\n}\nvoid add_edge(int from,int to){\n\tedge[++num_edge].nxt=head[from];\n\tedge[num_edge].to=to;\n\thead[from]=num_edge;\n}\nbool find(int x){\n\tfor(int i=head[x];i;i=edge[i].nxt){\n\t\tif(vis[edge[i].to]!=tim){\n\t\t\tvis[edge[i].to]=tim;\n\t\t\tif(!lk[edge[i].to]||find(edge[i].to)){\n\t\t\t\tlk[edge[i].to]=x;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nbool check(int x){\n\tif(x==1) return 0;\n\tfor(int i=2;i*i<=x;++i){\n\t\tif(x%i==0) return 0;\n\t}\n\treturn 1;\n}\nint main(){\n//\tfreopen(\"ex.in\",\"r\",stdin);\n\tn=read();\n\tfor(int i=1;i<=n;++i) b[i]=read();b[0]=-INF;b[n+1]=INF;\n\tfor(int i=1;i<=n;++i){\n\t\tif(b[i]!=b[i-1]+1){\n\t\t\tif(i%2) odd[++odd_num]=b[i];\n\t\t\telse even[++even_num]=b[i];\n\t\t}\n\t\tif(b[i]+1!=b[i+1]){\n\t\t\tif((i+1)%2) odd[++odd_num]=b[i]+1;\n\t\t\telse even[++even_num]=b[i]+1;\n\t\t}\n\t}\n\tfor(int i=1;i<=odd_num;++i){\n\t\tfor(int j=1;j<=even_num;++j){\n\t\t\tif(check(abs(even[j]-odd[i]))) add_edge(even[j],odd[i]),add_edge(odd[i],even[j]);\n\t\t}\n\t}\n\tfor(int i=1;i<=odd_num;++i){\n\t\ttim++;\n\t\tif(find(odd[i])) k++;\n\t\telse break;\n\t}\n\tans=k+((even_num-k)/2+(odd_num-k)/2)*2+((even_num-k)%2)*3;\n\tprintf(\"%d\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define ld long double\n#define ull unsigned long long\n#define poly vector<ll>\n#define pb push_back\n#define pii pair<int,int>\n#define fi first\n#define se second\n#define mp make_pair\n#define For(i,l,r) for(int i=(int)(l);i<=(int)(r);i++)\n#define Rep(i,r,l) for(int i=(int)(r);i>=(int)(l);i--)\ninline ll read(){\n\tll x=0;char ch=getchar();bool d=1;\n\tfor(;!isdigit(ch);ch=getchar()) if(ch=='-') d=0;\n\tfor(;isdigit(ch);ch=getchar()) x=x*10+ch-'0';\n\treturn d?x:-x;\n}\ninline void write(ll x){\n\tif(x<0) x=-x,putchar('-');\n\tif(x>=10) write(x/10);\n\tputchar('0'+x%10);\n}\ninline void writeln(ll x){write(x);puts(\"\");}\ninline void writep(ll x){write(x);putchar(' ');}\ninline ull rnd(){\n\treturn ((ull)rand()<<30^rand())<<4|rand()%4;\n}\nconst int N=105;\nint head[N],opt;\nstruct info{\n\tint to,nxt;\n}e[N*N*2];\nvoid add(int x,int y){\n\te[++opt]=(info){y,head[x]};head[x]=opt;\n\te[++opt]=(info){x,head[y]};head[y]=opt;\n}\nbool check(int x){\n\tif(x<=2) return 0;\n\tfor(int i=2;i*i<=x;i++){\n\t\tif(x%i) return 0;\n\t}\n\treturn 1;\n}\nint ma[N];\nbool used[N];\nbool dfs(int u){\n\tfor(int i=head[u];i;i=e[i].nxt){\n\t\tint k=e[i].to;\n\t\tif(used[k]) continue;\n\t\tif(!ma[k]||dfs(ma[k])) return ma[k]=u,1;\n\t}\n\treturn 0;\n}\nint a[N],pos[N<<1];\nint main(){\n\tint n=read(),m=0,cnt=0;\n\tFor(i,1,n){\n\t\ta[i]=read();\n\t\tif(i==1||a[i-1]<a[i]-1) pos[++m]=a[i];\n\t\tif(i>1&&a[i-1]+1<a[i]) pos[++m]=a[i-1]+1;\n\t}\n\tpos[++m]=a[n]+1;\n\tFor(i,1,m) if(pos[i]&1) cnt++;\n\tFor(i,1,m) if(pos[i]&1){\n\t\tFor(j,i+1,m) if(!(pos[j]&1)){\n\t\t\tif(check(pos[j]-pos[i])) add(i,j);\n\t\t}\n\t}\n\tint ssw=0;\n\tFor(i,1,m) if(pos[i]&1){\n\t\tmemset(used,0,sizeof(used));\n\t\tssw+=dfs(i);\n\t}\n\tcout<<ssw+(m-ssw*2)+(cnt-ssw)%2;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int maxp=1000050;\nint n;\nint sum[105],a[105];\nint tot=0;\nint prime[maxp],primesize;\nbool isprime[maxp];\nvoid getlist(int listsize)\n{\n    memset(isprime,1,sizeof(isprime));\n    isprime[1]=false;\n    for(int i=2;i<=listsize;i++)\n    {\n        if(isprime[i]&&i!=2)\n\t\t\tprime[++primesize]=i;\n\t\tif(!isprime[i])\n\t\t\tcontinue;\n\t\tfor(int j=1;j<=primesize&&i*prime[j]<=listsize;j++)\n\t\t{\n            isprime[i*prime[j]]=false;\n            if(i%prime[j]==0)\n\t\t\t\tbreak;\n        }\n    }\n}\nint main() {\n\tgetlist(maxp-50);\n\tscanf(\"%d\",&n);\n\tsum[++tot]=1;\n\tfor(int i=1;i<=n;i++) {\n\t\tscanf(\"%d\",&a[i]);\n\t\tif(i==1)\n\t\t\tcontinue;\n\t\tif(a[i]==a[i-1]+1)\n\t\t\tsum[tot]++;\n\t\telse\n\t\t\tsum[++tot]=1;\n\t}\n\tint sumx=0;\n\tfor(int i=1;i<=tot;i++) {\n\t\tint tmp=sum[i];\n\t\tif(isprime[tmp]&&tmp!=2) {\n\t\t\tsumx++;\n\t\t\tcontinue;\n\t\t}\n\t\telse if(tmp%2==0) {\n\t\t\tsumx+=2;\n\t\t\tcontinue;\n\t\t}\n\t\telse if(tmp%2==1&&tmp!=1) {\n\t\t\tsumx+=3;\n\t\t\tcontinue;\n\t\t}\n\t\telse if(tmp==1) {\n\t\t\tsumx+=2;\n\t\t\tcontinue;\n\t\t}\n\t}\n\tprintf(\"%d\\n\",sumx);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<cmath>\nconst int N=102;\nint n,cnp,cnj,cnt,og[N],hx[N<<1],fir[N<<1],prm[460];\nbool npr[3200];\nstruct edge{\n\tint to,wi,nx;\n}eg[N*N];\n\ninline void add(int a,int b,int v){\n\tstatic int cnt=1;\n\teg[++cnt]=(edge){b,v,fir[a]};\n\tfir[a]=cnt;\n\teg[++cnt]=(edge){a,0,fir[b]};\n\tfir[b]=cnt;\n}\n\ninline char get_c(){\n\tstatic char buf[20000],*h,*t;\n\tif(h==t){\n\t\tt=(h=buf)+fread(buf,1,20000,stdin);\n\t}\n\treturn h==t?EOF:*h++;\n}\n\ninline int nxi(){\n\tint x=0;\n\tchar c;\n\twhile((c=get_c())>'9'||c<'0');\n\twhile(x=x*10-48+c,(c=get_c())>='0'&&c<='9');\n\treturn x;\n}\n\ninline void init(){\n\tnpr[1]=1;\n\tfor(int i=2;i<3200;++i){\n\t\tif(!npr[i]) prm[++cnp]=i;\n\t\tfor(int j=1;j<=cnp&&i*prm[j]<3200;++j){\n\t\t\tnpr[i*prm[j]]=1;\n\t\t\tif(i%prm[j]==0) break;\n\t\t}\n\t}\n}\n\ninline bool ispr(int x){\n\tif(x<3200) return !npr[x];\n\tint sq=sqrt(x)+1;\n\tfor(int i=1;prm[i]<=sq;++i){\n\t\tif(x%prm[i]==0) return 0;\n\t}\n\treturn 1;\n}\n\nnamespace F{\n\tint dep[N<<1],que[N<<1],cur[N<<1];\n\n\tinline bool bfs(){\n\t\tmemset(dep,0,sizeof(dep));\n\t\tint hd=0,tl=1;\n\t\tdep[0]=1;\n\t\twhile(hd!=tl){\n\t\t\tint x=que[hd++];\n\t\t\tfor(int i=cur[x]=fir[x];i;i=eg[i].nx){\n\t\t\t\tint y=eg[i].to;\n\t\t\t\tif(eg[i].wi&&!dep[y]){\n\t\t\t\t\tdep[y]=dep[x]+1;\n\t\t\t\t\tque[tl++]=y;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn dep[(N<<1)-1];\n\t}\n\n\tint dfs(int x,int t){\n\t\tif(x==(N<<1)-1) return t;\n\t\tint tp,tt=t;\n\t\tfor(int &i=cur[x];i;i=eg[i].nx){\n\t\t\tint y=eg[i].to,v=eg[i].wi;\n\t\t\tif(v&&tt&&dep[x]+1==dep[y]&&(tp=dfs(y,std::min(v,tt)))){\n\t\t\t\teg[i].wi-=tp;\n\t\t\t\teg[i^1].wi+=tp;\n\t\t\t\ttt-=tp;\n\t\t\t\tif(!tt) break;\n\t\t\t}\n\t\t}\n\t\treturn t-tt;\n\t}\n}\n\nint main(){\n#ifndef ONLINE_JUDGE\n//\tfreopen(\"c.in\",\"r\",stdin);\n#endif\n\tinit();\n\tn=nxi();\n\tfor(int i=1;i<=n;++i){\n\t\tog[i]=nxi();\n\t}\n\tstd::sort(og+1,og+n+1);\n\tog[0]=-1;\n\tfor(int i=1;i<=n;++i){\n\t\tif(og[i]-og[i-1]>1){\n\t\t\tif(og[i-1]+1) hx[++cnt]=og[i-1]+1;\n\t\t\thx[++cnt]=og[i];\n\t\t}\n\t}\n\thx[++cnt]=og[n]+1;\n\tfor(int i=1;i<=cnt;++i){\n\t\tif(hx[i]&1) ++cnj;\n\t\tif(hx[i]&1) add(0,i,1);\n\t\telse add(i,(N<<1)-1,1);\n\t\tfor(int j=i+1;j<=cnt;++j){\n\t\t\tint p=hx[j]-hx[i];\n\t\t\tif((p&1)&&ispr(p)){\n\t\t\t\tif(hx[i]&1) add(i,j,1);\n\t\t\t\telse add(j,i,1);\n\t\t\t}\n\t\t}\n\t}\n\tint ans=0;\n\twhile(F::bfs()){\n\t\tans+=F::dfs(0,N);\n\t}\n//\tprintf(\"%d %d %d\\n\",cnt,ans,cnj&1);\n\tprintf(\"%d\\n\",cnt-ans+(cnj&1));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <stack>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(n);i++)\n\nbool isp(int x){\n  if(x<=1)return false;\n  if(x==2)return true;\n  if(x%2==0)return false;\n  for(int y=3;y*y<=x;y+=2){\n    if(x%y==0)return false;\n  }\n  return true;\n}\n\nint n;\nint x[125];\nint cap[252][252];\nint main(void){\n  scanf(\"%d\",&n);\n  REP(i,n)scanf(\"%d\",x+i);\n  map<int,int> M;\n  REP(i,n){\n    M[x[i]] ^= 1;\n    M[x[i]+1] ^= 1;\n  }\n  vector<int> even,odd;\n  for(auto P : M)if(P.second==1){\n    (P.first%2==0 ? even : odd).push_back(P.first);\n  }\n  int ne = even.size();\n  int no = odd.size();\n  n = ne + no + 2;\n  int s = ne+no;\n  int t = ne+no+1;\n  REP(i,ne)cap[s][i] = 1;\n  REP(i,no)cap[ne+i][t] = 1;\n  REP(i,ne)REP(j,no){\n    int d = abs(even[i]-odd[j]);\n    if(d<3)continue;\n    if(isp(d)){\n      cap[i][ne+j] = 1;\n    }\n  }\n  int f = 0;\n  while(true){\n    vector<int> bef(n,-1);\n    vector<bool> vstd(n,false);\n    stack<int> S;\n    S.push(s);\n    vstd[s] = true;\n    while(S.size()){\n      int p = S.top(); S.pop();\n      if(p==t)break;\n      REP(i,n)if(cap[p][i] && !vstd[i]){\n        vstd[i] = true;\n        bef[i] = p;\n        S.push(i);\n      }\n    }\n    if(bef[t]==-1)break;\n    f++;\n    int cur = t;\n    while(true){\n      int nxt = bef[cur];\n      if(nxt==-1)break;\n      cap[nxt][cur] = 0;\n      cap[cur][nxt] = 1;\n      cur = nxt;\n    }\n  }\n  int ans = 0;\n  ans += f;\n  ans += (ne-f);\n  ans += (no-f);\n  if((ne-f)%2==1)ans++;\n  printf(\"%d\\n\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n//ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n//clock_t start=clock();clock_t end=clock();cout<<(double)(end-start)/CLOCKS_PER_SEC<<endl;\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef unsigned int ui;\ntypedef pair<int,int> pii;\ntypedef pair<pii,int> ppii;\ntypedef pair<int,pii> pipi;\ntypedef pair<ll,ll> pll;\ntypedef pair<pll,ll> ppll;\ntypedef pair<ll,pll> plpl;\ntypedef tuple<ll,ll,ll> tl;\ntypedef pair<double,double> pdd;\ntypedef vector<vector<ll>> mat;\nll mod=1000000007;\nll mod2=998244353;\nll mod3=1000003;\nll mod4=998244853;\nll mod5=1000000009;\nll inf=1LL<<60;\ndouble pi=3.141592653589793238462643383279L;\ndouble eps=1e-14;\n#define rep(i,m,n) for(ll i=m;i<n;i++)\n#define rrep(i,n,m) for(ll i=n;i>=m;i--)\n#define srep(itr,st) for(auto itr=st.begin();itr!=st.end();itr++)\n#define mrep(itr,mp) for(auto itr=mp.begin();itr!=mp.end();itr++)\n#define Max(a,b) a=max(a,b)\n#define Min(a,b) a=min(a,b)\nint dh[4]={1,-1,0,0};\nint dw[4]={0,0,1,-1};\nint ddh[8]={-1,-1,-1,0,0,1,1,1};\nint ddw[8]={-1,0,1,-1,1,-1,0,1};\nll gcd(ll a,ll b){\n    if(a<b)swap(a,b);\n    if(b==0)return a;\n    if(a%b==0)return b;\n    return gcd(b,a%b);\n}\nll Pow(ll n,ll k){\n    ll ret=1;\n    ll now=n;\n    while(k>0){\n        if(k&1)ret*=now;\n        now*=now;\n        k/=2;\n    }\n    return ret;\n}\nll beki(ll n,ll k,ll md){\n  ll ret=1;\n  ll now=n;\n  while(k>0){\n    if(k%2==1){\n      ret*=now;\n      ret%=md;\n    }\n    now*=now;\n    now%=md;\n    k/=2;\n  }\n  return ret;\n}\nll gyaku(ll n,ll md){\n  return beki(n,md-2,md);\n}\nll popcount(ll n){\n    ll ret=0;\n    ll u=n;\n    while(u>0){\n        ret+=u%2;\n        u/=2;\n        \n    }\n    return ret;\n}\nbool pri(int n){\n    if(n<=2)return false;\n    for(int i=2;i*i<=n;i++){\n        if(n%i==0)return false;\n    }\n    return true;\n}\nint h(int n){\n    if(pri(n))return 1;\n    else if(n%2==0)return 2;\n    else return 3;\n}\nint main(){\n    ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n    int n;cin>>n;\n    int x[n];\n    rep(i,0,n)cin>>x[i];\n    vector<pii> v;\n    vector<int> w;\n    int cnt=1;\n    \n    rep(i,1,n){\n        if(x[i]==x[i-1]+1)cnt++;\n        else{\n            v.push_back({x[i-cnt],x[i-1]});\n            w.push_back(x[i]-x[i-1]-1);\n            cnt=1;\n        }\n    }\n    v.push_back({x[n-cnt],x[n-1]});\n    //rep(i,0,v.size())cout<<v[i].first<<\" \"<<v[i].second<<endl;\n    //rep(i,0,w.size())cout<<w[i]<<endl;\n    int dp[v.size()+1];\n    rep(i,0,v.size()+1)dp[i]=1000000000;\n    dp[1]=h(v[0].second-v[0].first+1);\n    dp[0]=0;\n    rep(i,1,v.size()){\n        int lv=v[i].second-v[i].first+1,lw=w[i-1];\n        dp[i+1]=dp[i]+h(lv);\n        rep(j,0,i){\n            int pa=v[i].second-v[j].first;\n            int sum=0;\n            if(pa%2==1)sum+=1;\n            else sum+=2;\n            //cout<<pa<<\" \"<<sum<<endl;\n            rep(k,j,i){\n                sum+=h(w[k]);\n            }\n            Min(dp[i+1],sum+dp[j]+1);\n        }\n    }\n    //rep(i,0,v.size()+1)cout<<dp[i]<<\" \";\n   // cout<<endl;\n    cout<<dp[v.size()]<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn=105;\nint n,a[maxn],cnt[2],match[maxn<<1];\nbool used[maxn<<1];\nvector<int> G[maxn<<1],diff;\nset<int> vis;\nbool dfs(int v) {\n    used[v]=1;\n    for (int i=0;i<(int)G[v].size();++i) {\n        int u=G[v][i],w=match[u];\n        if (!w||(!used[w]&&dfs(w))) {\n            match[v]=u;\n            match[u]=v;\n            return true;\n        }\n    }\n    return false;\n}\ninline int bipartite_matching() {\n    int ret=0;\n    for (int i=0;i<(int)diff.size();++i)\n        if (diff[i]%2==0&&!match[i]) {\n            memset(used,0,sizeof used);\n            ret+=dfs(i);\n        }\n    return ret;\n}\nbool check(int x) {\n    if (x<=2)\n        return false;\n    for (int i=2;i*i<=x;++i)\n        if (x%i==0)\n            return false;\n    return true;\n}\nint main()\n{\n    scanf(\"%d\",&n);\n    for (int i=1;i<=n;++i) {\n        scanf(\"%d\",&a[i]);\n        vis.insert(a[i]);\n    }\n    for (int i=1;i<=n;++i) {\n        if (vis.find(a[i]-1)==vis.end()) {\n            diff.push_back(a[i]);\n            ++cnt[a[i]%2];\n        }\n        if (vis.find(a[i]+1)==vis.end()) {\n            diff.push_back(a[i]+1);\n            ++cnt[(a[i]+1)%2];\n        }\n    }\n    for (int i=0;i<(int)diff.size();++i)\n        for (int j=i+1;j<(int)diff.size();++j)\n            if (check(abs(diff[i]-diff[j]))) {\n                G[i].push_back(j);\n                G[j].push_back(i);\n            }\n    int k=bipartite_matching();\n    printf(\"%d\\n\",k+2*((cnt[0]-k)/2+(cnt[1]-k)/2)+(cnt[0]-k)%2*3);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <cmath>\n\nusing namespace std;\n\nconst int MAXN = 200 + 100;\nconst int MAXM = 10000000 + 100;\n\nint pri[MAXM], totp = 0;\nbool isp[MAXM];\n\nvoid init()\n{\n\tmemset(isp, true, sizeof(isp));\n\tisp[0] = isp[1] = false;\n\tfor(int i = 2; i < MAXM; i++)\n\t{\n\t\tif(isp[i])\n\t\t\tpri[++totp] = i;\n\t\tfor(int j = 1; j <= totp && i * pri[j] < MAXM; j++)\n\t\t{\n\t\t\tisp[i * pri[j]] = false;\n\t\t\tif(i % pri[j] == 0) break;\n\t\t}\n\t}\n}\n\nstruct Edge\n{\n\tint next, to;\n}\ne[MAXN * MAXN];\nint p[MAXN], l = 2;\nvoid addE(int x, int y)\n{\n\te[l] = (Edge){p[x], y};\n\tp[x] = l++;\n}\nint size[2], vis[2][MAXN], match[2][MAXN];\n\nbool dfs(int x)\n{\n\tvis[0][x] = true;\n\tfor(int i = p[x]; i;i = e[i].next)\n\t\tif(!vis[1][e[i].to])\n\t\t{\n\t\t\tint y = e[i].to;\n\t\t\tvis[1][y] = true;\n\t\t\tif(!match[1][y] || dfs(match[1][y]))\n\t\t\t{\n\t\t\t\tmatch[0][x] = y;\n\t\t\t\tmatch[1][y] = x;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\treturn false;\n}\n\nint hungary()\n{\n\tint ret = 0;\n\tfor(int i = 1; i <= size[0]; i++)\n\t{\n\t\tmemset(vis, 0, sizeof(0));\n\t\tif(dfs(i))\n\t\t\tret++;\n\t}\n\treturn ret;\n}\n\nint n, a[MAXN], b[MAXN], id[MAXN];\n\nint main()\n{\n\tios::sync_with_stdio(false);\n\t// freopen(\"1.in\", \"r\", stdin);\n\t// freopen(\"1.out\", \"w\", stdout);\n\n\tinit();\n\n\tint n0;\n\tcin >> n0;\n\tfor(int i = 1; i <= n0; i++)\n\t\tcin >> a[i];\n\ta[0] = -1, a[n0 + 1] = MAXM + 1;\n\n\tfor(int i = 1; i <= n0; i++)\n\t{\n\t\tif(a[i - 1] != a[i] - 1)\n\t\t\tb[++n] = a[i];\n\t\tif(a[i] + 1 != a[i + 1])\n\t\t\tb[++n] = a[i] + 1;\n\t}\n\t// for(int i = 1; i <= n; i++)\n\t// \tcerr << b[i] << ' ';\n\t// cerr << endl;\n\n\tfor(int i = 1; i <= n; i++)\n\t\tid[i] = ++size[b[i] % 2];\n\t// cerr << size[0] << ' '<< size[1] << endl;\n\n\tfor(int i = 1; i <= n; i++)\n\t\tif(b[i] % 2 == 0)\n\t\t\tfor(int j = 1; j <= n; j++)\n\t\t\t\tif(b[j] % 2 == 1)\n\t\t\t\t\tif(isp[abs(b[i] - b[j])])\n\t\t\t\t\t\taddE(id[i], id[j]);\n\tint k = hungary();\n\t// cerr << k << endl;\n\n\tint ans = 1 * k + 2 * ((size[0] - k) / 2 + (size[1] - k) / 2) + 3 * ((size[0] - k) & 1);\n\tcout << ans << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cmath>\n#include<cstring>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n\nconst int N=10005;\nconst int M=10000005;\n\nint n1,n2,n,cnt,now,m,ans;\nint lk[N],p1[N],p2[N],pri[M],p[N],c[M],b[M],tag[N];\nbool vis[M];\nvector<int> lev[N];\n\nvoid getpri(int n){\n\tint i,j;\n\tfor (i=2;i<=n;i++){\n\t\tif (!vis[i]) pri[++cnt]=i;\n\t\tfor (j=1;j<=cnt&&pri[j]*i<=n;j++){\n\t\t\tvis[i*pri[j]]=1;\n\t\t\tif (i%pri[j]==0) break;\n\t\t}\n\t}\n\tvis[1]=vis[2]=1;\n}\n\nbool dfs(int k){\n\tint u,j;\n\tfor (j=0;j<lev[k].size();j++){\n\t\tu=lev[k][j];\n\t\tif (tag[u]!=now){\n\t\t\ttag[u]=now;\n\t\t\tif (!lk[u]||dfs(lk[u])){\n\t\t\t\tlk[u]=k;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint main(){\n\tint i,j;\n\tgetpri(M-1);\n\tscanf(\"%d\",&n);\n\tfor (i=1;i<=n;i++) scanf(\"%d\",&p[i]);\n\tsort(p+1,p+1+n); m=p[n]+1;\n\tfor (i=1;i<=n;i++) b[p[i]]^=1;\n\tfor (i=1;i<=m;i++) c[i]=b[i]!=b[i-1];\n\tfor (i=1;i<=m;i++)\n\t\tif (c[i]){\n\t\t\tif (i&1) p1[++n1]=i;\n\t\t\telse p2[++n2]=i;\n\t\t}\n\tfor (i=1;i<=n1;i++)\n\t\tfor (j=1;j<=n2;j++)\n\t\t\tif (!vis[abs(p1[i]-p2[j])]) lev[i].push_back(j);\n\tfor (i=1;i<=n1;i++){\n\t\tnow++;\n\t\tans+=dfs(i);\n\t}\n\tprintf(\"%d\\n\",ans+(n1-ans)/2*2+(n2-ans)/2*2+(n1-ans)%2*3);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint n,b,ans=0;\nint a[105],f[105][105];\nint x[2][105],cnt[2],c;\nint p[10000005],prime[3000005],tot=0;\nint vis[105],link[105];\n\nint dfs(int x){\n\tfor(int i=1;i<=cnt[1];i++){\n\t\tif(vis[i]==0&&f[x][i]==1){\n\t\t\tvis[i]=1;\n\t\t\tif(link[i]==0||dfs(link[i])){\n\t\t\t\tlink[i]=x;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint main(){\n\tscanf(\"%d\",&n);\n\ta[0]=-1;\n\tfor(int i=2;i<=10000000;i++){\n\t\tif(p[i]==0) prime[++tot]=i;\n\t\tfor(int j=1;j<=tot&&i*prime[j]<=10000000;j++){\n\t\t\tp[i*prime[j]]=1;\n\t\t\tif(i%prime[j]==0) break;\n\t\t}\n\t}\n\tp[1]=p[2]=1;\n\tfor(int i=1;i<=n;i++) scanf(\"%d\",&a[i]);\n\tfor(int i=1;i<=n;i++){\n\t\tif(a[i]==a[i-1]+1) continue;\n\t\tif(a[i-1]!=-1) x[c=(a[i-1]+1)&1][++cnt[c]]=a[i-1]+1;\n\t\tx[c=a[i]&1][++cnt[c]]=a[i];\n\t}\n\tx[c=(a[n]+1)&1][++cnt[c]]=a[n]+1;\n\tfor(int i=1;i<=cnt[0];i++){\n\t\tfor(int j=1;j<=cnt[1];j++){\n\t\t\tif(p[abs(x[0][i]-x[1][j])]==0) f[i][j]=1;\n\t\t}\n\t}\n\tfor(int i=1;i<=cnt[0];i++){\n\t\tmemset(vis,0,sizeof(vis));\n\t\tif(dfs(i)) ans++;\n\t}\n\tcnt[1]-=ans,cnt[0]-=ans;\n\tans+=2*(cnt[1]/2+cnt[0]/2);\n\tif(cnt[1]&1) ans+=3;\n\tprintf(\"%d\\n\",ans);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n ***\n Question Name:\n ***\n Question Link:\n \n ***\n Idea:\n */\n\n#include <memory.h>\n#include <iomanip>\n#include <algorithm>\n#include <iostream>\n#include <iterator>\n#include <numeric>\n#include <sstream>\n#include <fstream>\n#include <cassert>\n#include <climits>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n#include <cstdio>\n#include <vector>\n#include <cmath>\n#include <functional>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <list>\n#include <map>\n#include <set>\n#include <unordered_set>\n#include <unordered_map>\n\n#define REP(i,s,n) for(int (i)=s; (i)<(int)(n);(i)++)\n#define RIT(it,c) for(__typeof(c.begin()) it = c.begin();it!=c.end();it++)\n#define ALL(x) x.begin(), x.end()\n#define SZ(x) (int)(x).size()\n#define MSET(m,v) memset(m,v,sizeof(m))\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef long double LD;\ntypedef vector<int> vi;\ntypedef pair<int,int> ii;\ntypedef vector<LL> vL;\ntypedef vector<bool> vb;\ntypedef unordered_set<int> ui;\ntypedef pair<LL,LL> pLL;\n\nclass PrimeFlip{\n    int N = 1E7, n, m;\n    vi mapping;\n    vb vist;\n    vector<vb> E;\n    void init(){\n        int K;\n        cin>>K;\n        unordered_set<int> cnt;\n        vi odds,evens;\n        for(int i=0;i<K;++i){\n            int x;\n            cin>>x;\n            if(cnt.count(x)) cnt.erase(x);\n            else cnt.insert(x);\n            cnt.insert(x+1);\n        }\n        for(auto k:cnt){\n            if(k%2) odds.push_back(k);\n            else evens.push_back(k);\n        }\n        cnt.clear();\n        n = (int)odds.size();\n        m = (int)evens.size();\n        mapping = vi(m,-1);\n        E = vector<vb>(n,vb(m, false));\n        vb prime(N+1,true);\n        prime[0] = prime[1] = false;\n        for(int i=2;i<=N;++i) if(prime[i]){\n            for(int j=2;j*i<=N;++j) prime[i*j] = false;\n        }\n        prime[2] = false;\n        for(int i=0;i<n;++i) for(int j=0;j<m;++j) E[i][j] =prime[abs(odds[i]-evens[j])];\n        prime.clear();\n    }\n    bool arange(int i){\n        for(int j=0;j<m;++j) if(E[i][j] && !vist[j]){\n            vist[j] = true;\n            if(mapping[j]==-1 || arange(mapping[j])){\n                mapping[j] = i;\n                return true;\n            }\n        }\n        return false;\n    }\npublic:\n    void solve(){\n        init();\n        int cnt = 0;\n        for(int i=0;i<n;++i) {\n            vist.assign(m, false);\n            cnt += arange(i);\n        }\n        int ans = cnt + ((n-cnt)/2 + (m-cnt)/2)*2 + ((m-cnt)%2)*3;\n        cout<<ans<<endl;\n    }\n};\n\n\n\nint main(){\n    PrimeFlip().solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing ll = long long;\nusing pii = pair<int, int>;\nusing ld = long double;\nusing pll = pair<ll, ll>;\n\nconst int INF = (int)1e9;\nconst int N = 2000 * 1000 * 10 + 10;\n\nbool prime[N];\nvector<int> all_p;\n\nvoid init() {\n    fill(prime + 2, prime + N, true);\n    for (int i = 2; i < N; ++i) {\n        if (!prime[i])\n            continue;\n        if (i != 2)\n            all_p.push_back(i);\n        for (int j = 2 * i; j < N; j += i)\n            prime[j] = false;\n    }\n    prime[2] = false;\n}\n\nint get_cost(int x) {\n   if (x == 0)\n       return 0;\n   if (x == 1)\n       return 3;\n   if (x % 2 == 0)\n       return 2;\n   return prime[x] ? 1 : 3;\n}\n\nint n;\nint x[N];\nint dp[111][111];\n\nconst int B = 25;\n\nint calc(int l, int r) {\n    if (l == r)\n        return get_cost(1);\n    if (dp[l][r] != -1)\n        return dp[l][r];\n    dp[l][r] = get_cost(1) * (r - l + 1);\n    for (int k = l; k < r; ++k) {\n        //if (l == 0 && r == n - 1)\n        //    cerr << calc(l, k) << \" \" << calc(k + 1, r) << endl;\n        dp[l][r] = min(dp[l][r], calc(l, k) + calc(k + 1, r));\n    }\n    int len = x[r] - x[l] + 1;\n    int pp = lower_bound(all_p.begin(), all_p.end(), len) - all_p.begin();\n    int low = 1;\n    if (l != 0)\n        low = x[l - 1] + 1;\n    int high = INF;\n    if (r != n - 1)\n        high = x[r + 1];\n    for (int i = pp; i <= pp + B; ++i) {\n        int L = low;\n        int R = x[l];\n        int p = all_p[i];\n        L = max(L, x[r] - p + 1);\n        R = min(R, high - p);\n        for (int k = L; k <= min(R, L + B); ++k) {\n            vector<int> cur;\n            cur.push_back(k - 1);\n            for (int i = l; i <= r; i++)\n                cur.push_back(x[i]);\n            cur.push_back(k + p);\n            int cost = 1;\n            for (int i = 1; i < (int)cur.size(); ++i)\n                cost += get_cost(cur[i] - cur[i - 1] - 1);\n            /*if (l == 0 && r == n - 1) {\n                cerr << k << \" \" << p << endl;\n                for (int x : cur)\n                    cerr << x << \" \";\n                cerr << cost << endl << endl;\n            }*/\n            dp[l][r] = min(dp[l][r], cost);\n        }\n    }\n    return dp[l][r];\n}\n\nint main() {\n#ifdef LOCAL\n     freopen(\"input\", \"r\", stdin);\n#endif\n    ios_base::sync_with_stdio(0);\n    cin.tie(nullptr);\n    cout.setf(ios::fixed);\n    cout.precision(12);\n    init();\n    cin >> n;\n    for (int i = 0; i < n; ++i)\n        cin >> x[i];\n    for (int i = 0; i <= n; ++i)\n        for (int j = 0; j <= n; ++j)\n            dp[i][j] = -1;\n    cout << calc(0, n - 1) << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define pb push_back\nusing namespace std;\ntypedef vector<int> vi;\n\nstruct hopcroft_karp {\n\tint N,M;\n\tvector<vector<int>> E;\n\tvector<int> dist,match,Q;\n\thopcroft_karp(int n, int m):N(n),M(m),E(N),dist(N+M),match(N+M,-1),Q(N+M){}\n\n\tinline void add_edge(int i, int j) {E[i].push_back(j);}\n\n\tbool bfs() {\n\t\tfill(&dist[0],&dist[0]+N+M,-1);\n\t\tint qf = 0, qb = 0, u;\n\t\tbool ok = false;\n\t\tfor(int i = 0; i < N; ++i)\n\t\t\tif(match[i] == -1)\n\t\t\t\tQ[qb++] = i, dist[i] = 0;\n\t\twhile(qf != qb) {\n\t\t\tif((u = Q[qf++]) < N) {\n\t\t\t\tfor(int v : E[u])\n\t\t\t\t\tif(dist[N+v] == -1)\n\t\t\t\t\t\tdist[Q[qb++] = N+v] = dist[u] + 1;\n\t\t\t} else {\n\t\t\t\tif(match[u] == -1) ok = true;\n\t\t\t\telse if(dist[match[u]] == -1)\n\t\t\t\t\tdist[Q[qb++] = match[u]] = dist[u] + 1;\n\t\t\t}\n\t\t}\n\t\treturn ok;\n\t}\n\n\tbool dfs(int u) {\n\t\tfor(int &i = Q[u]; i < E[u].size(); ++i) {\n\t\t\tint v = N+E[u][i];\n\t\t\tif(dist[v] == dist[u]+1 && (match[v] == -1 || (dist[match[v]] == dist[v]+1 && dfs(match[v])))) {\n\t\t\t\tmatch[v] = u, match[u] = v-N;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tint solve() {\n\t\tint ans = 0;\n\t\twhile(bfs()) {\n\t\t\tfill(&Q[0],&Q[0]+N,0);\n\t\t\tfor(int i = 0; i < N; ++i)\n\t\t\t\tif(match[i] == -1 && dfs(i))\n\t\t\t\t\t++ans;\n\t\t}\n\t\treturn ans;\n\t}\n};\n\nconst int N = 105, P = 1e6+5;\nint a[N]={-1};\nbool p[P];\nvi odd,evn;\n\ninline void add(int i) {\n\t((i&1)?odd:evn).pb(i);\n}\n\nint main() {\n\tfill(p,p+P,1);\n\tfor(int i = 2; i < P; ++i)\n\t\tif(p[i])\n\t\t\tfor(ll j = 1LL * i * i; j < P; j += i)\n\t\t\t\tp[j] = false;\n\tp[2] = false;\n\tint n;\n\tscanf(\"%d\",&n);\n\tfor(int i = 1; i <= n; ++i)\n\t\tscanf(\"%d\",a+i);\n\tsort(a,a+n); //maybe\n\tfor(int i = 1; i <= n; ++i) {\n\t\tif(a[i-1] != a[i]-1) add(a[i]-1);\n\t\tif(a[i+1] != a[i]+1) add(a[i]);\n\t}\n\thopcroft_karp HK(evn.size(), odd.size());\n\tfor(int i = 0; i < evn.size(); ++i)\n\t\tfor(int j = 0; j < odd.size(); ++j)\n\t\t\tif(p[abs(i-j)])\n\t\t\t\tHK.add_edge(i,j);\n\tint k = HK.solve();\n\tprintf(\"%d\\n\",k + int((odd.size()-k)/2*2 + (evn.size()-k)/2*2 + ((odd.size()-k)&1)*3));\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define ii pair <int, int>\n#define app push_back\n#define all(a) a.begin(), a.end()\n#define bp __builtin_popcountll\n#define ll long long\n#define mp make_pair\n#define f first\n#define s second\n#define Time (double)clock()/CLOCKS_PER_SEC\n#define debug(x) std::cout << #x << \": \" << x << '\\n';\n\nnamespace Mag {\n#define forn(i, n) for (int i = 0; i < (int)(n); ++i)\nconst int maxn = 505;\ntypedef vector<int> vi;\n\n// BEGIN_CODE\nint n;\nvi e[maxn];\nint mt[maxn], p[maxn], base[maxn], b[maxn], blos[maxn];\nint q[maxn];\nint blca[maxn]; // used for lca\n\nvoid clear() {\n    for (int i = 0; i < maxn; ++i)  \n        e[i].clear();\n    memset(mt, 0, sizeof mt);\n    memset(p, 0, sizeof p);\n    memset(base, 0, sizeof base);\n    memset(b, 0, sizeof b);\n    memset(blos, 0, sizeof blos);\n    memset(q, 0, sizeof q);\n    memset(blca, 0, sizeof blca);\n}   \n\nint lca(int u, int v) {\n    forn(i, n) blca[i] = 0;\n    while (true) {\n        u = base[u];\n        blca[u] = 1;\n        if (mt[u] == -1) break;\n        u = p[mt[u]];\n    }\n    while (!blca[base[v]]) {\n        v = p[mt[base[v]]];\n    }\n    return base[v];\n}\n\nvoid mark_path(int v, int b, int ch) {\n    while (base[v] != b) {\n        blos[base[v]] = blos[base[mt[v]]] = 1;\n        p[v] = ch;\n        ch = mt[v];\n        v = p[mt[v]];\n    }\n}\n\nint find_path(int root) {\n    forn(i, n) {\n        base[i] = i;\n        p[i] = -1;\n        b[i] = 0;\n    }\n\n    b[root] = 1;\n    q[0] = root;\n    int lq = 0, rq = 1;\n    while (lq != rq) {\n        int v = q[lq++];\n        for (int to: e[v]) {\n            if (base[v] == base[to] || mt[v] == to) continue;\n            if (to==root || (mt[to] != -1 && p[mt[to]] != -1)) {\n                int curbase = lca(v, to);\n                forn(i, n) blos[i] = 0;\n                mark_path(v, curbase, to);\n                mark_path(to, curbase, v);\n                forn(i, n) if (blos[base[i]]) {\n                    base[i] = curbase;\n                    if (!b[i]) b[i] = 1, q[rq++] = i;\n                }\n            } else if (p[to] == -1) {\n                p[to] = v;\n                if (mt[to] == -1) {\n                    return to;\n                }\n                to = mt[to];\n                b[to] = 1;\n                q[rq++] = to;\n\n            }\n        }\n    }\n    return -1;\n}\n\nint matching() {\n    forn(i, n) mt[i] = -1;\n    int res = 0;\n    forn(i, n) if (mt[i] == -1) {\n        int v = find_path(i);\n        if (v != -1) {\n            ++res;\n            while (v != -1) {\n                int pv = p[v], ppv = mt[p[v]];\n                mt[v] = pv, mt[pv] = v;\n                v = ppv;\n            }\n        }\n    }\n    return res;\n}\n// END_CODE\n\nint match(int n_, int m, vector <ii> ed) {\n    clear();\n\n    n = n_;\n    for (auto t : ed) {\n        e[t.f].app(t.s);\n        e[t.s].app(t.f);\n    }   \n    int res = matching();\n    return res;\n}\n\n};\n\nconst int N = 207;\nconst int INF = 1e9+7;\nconst int C = 1e7+7;\n\nbool used[N];\n\nbool p[C];\n\nint get(int a, int b) {\n    if (b < a)\n        swap(a, b);\n\n    if ((b - a) % 2 == 0)\n        return 2;\n    else if (p[b-a])\n        return 1;\n    else\n        return 3;\n}\n\nint cost[N][N];\nint dp[1 << 20];\n\nsigned main() {\n    #ifdef HOME\n    freopen(\"input.txt\", \"r\", stdin);\n    #else\n    #define endl '\\n'\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    #endif\n    for (int i = 2; i < C; ++i)\n        p[i] = 1;\n    for (int i = 2; i < C; ++i) \n        if (p[i])\n            for (int j = i * 2; j < C; j += i)\n                p[j] = 0;\n\n    int n;\n    cin >> n;\n    map <int, int> d;\n    while (n--) {\n        int x;\n        cin >> x;\n        d[x] ^= 1;\n        d[x+1] ^= 1;        \n    }\n\n    vector <int> c;\n    for (auto e : d) {\n        if (e.s)\n            c.app(e.f);\n    }   \n\n    #ifdef HOME\n    cout << \"C : \";\n    for (auto e : c)\n        cout << e << ' ';\n    cout << endl;\n    #endif\n\n    vector <ii> ed;\n    for (int i = 0; i < c.size(); ++i) {\n        for (int j = i + 1; j < c.size(); ++j) {\n            if (get(c[i], c[j]) == 1) {\n                ed.app(mp(i+1,j+1));\n            }\n        }   \n    }    \n\n    int ans = Mag::match(c.size()+1, ed.size(), ed);\n\n    #ifdef HOME\n    cout << \"matching : \" << ans << endl;\n    #endif\n\n    vector <int> cnt(2);\n    for (auto e : c)\n        cnt[e&1]++;\n    for (int t = 0; t < 2; ++t)\n        cnt[t] -= ans;\n\n    for (int t = 0; t < 2; ++t) {\n        ans += cnt[t] - (cnt[t]&1);\n        cnt[t] &= 1;\n    }\n\n    if (cnt[0]) {\n        ans += 3;\n    }   \n\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#define fo(i,a,b) for(int i=a;i<=b;++i)\n#define fod(i,a,b) for(int i=a;i>=b;--i)\n#define min(q,w) ((q)>(w)?(w):(q))\n#define max(q,w) ((q)<(w)?(w):(q))\nusing namespace std;\nconst int N=350,M=1e7;\nint read(int &n)\n{\n\tchar ch=' ';int q=0,w=1;\n\tfor(;(ch!='-')&&((ch<'0')||(ch>'9'));ch=getchar());\n\tif(ch=='-')w=-1,ch=getchar();\n\tfor(;ch>='0' && ch<='9';ch=getchar())q=q*10+ch-48;n=q*w;return n;\n}\nint m,n,ans;\nbool az[M+10],prz[M+10];\nbool B[N][N];\nint pr[M/5];\nint a[N],b[N],zx[N];\nint z[N],TI;\nvoid Pre()\n{\n\tfo(i,2,M)\n\t{\n\t\tif(!prz[i])pr[++pr[0]]=i;\n\t\tfo(j,1,pr[0])\n\t\t{\n\t\t\tint t=i*pr[j];\n\t\t\tif(t>M)break;\n\t\t\tprz[t]=1;\n\t\t\tif(!t%pr[j])break;\n\t\t}\n\t}\n\tprz[1]=prz[2]=1;\n}\nbool OK(int q)\n{\n\tif(z[q]==TI)return 0;\n\tz[q]=TI;\n\tfo(i,1,b[0])if(B[q][i]&&(!zx[i]||OK(zx[i])))return zx[i]=q,1;\n\treturn 0;\n}\nint main()\n{\n\tint q;\n\tPre();\n\tread(n);\n\tfo(i,1,n)az[read(q)]=1;\n\tfo(i,1,M+1)if(az[i]!=az[i-1])\n\t{\n\t\tif(i&1)a[++a[0]]=i;\n\t\telse b[++b[0]]=i;\n\t}\n\tfo(i,1,a[0])fo(j,1,b[0])if(!prz[abs(a[i]-b[j])])B[i][j]=1;\n\tq=0;\n\tfo(i,1,a[0])\n\t{\n\t\t++TI;if(OK(i))++q;\n\t}\n\tans=q+2*((a[0]-q)/2+(b[0]-q)/2);\n\tif((a[0]-q)&1)ans+=3;\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/**\n *    author:  tourist\n *    created: 20.11.2019 08:57:54       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nclass matching {\n public:\n  vector<vector<int>> g;\n  vector<int> pa;\n  vector<int> pb;\n  vector<int> was;\n  int n, m;\n  int res;\n  int iter;\n\n  matching(int _n, int _m) : n(_n), m(_m) {\n    assert(0 <= n && 0 <= m);\n    pa = vector<int>(n, -1);\n    pb = vector<int>(m, -1);\n    was = vector<int>(n, 0);\n    g.resize(n);\n    res = 0;\n    iter = 0;\n  }\n\n  void add(int from, int to) {\n    assert(0 <= from && from < n && 0 <= to && to < m);\n    g[from].push_back(to);\n  }\n\n  bool dfs(int v) {\n    was[v] = iter;\n    for (int u : g[v]) {\n      if (pb[u] == -1) {\n        pa[v] = u;\n        pb[u] = v;\n        return true;\n      }\n    }\n    for (int u : g[v]) {\n      if (was[pb[u]] != iter && dfs(pb[u])) {\n        pa[v] = u;\n        pb[u] = v;\n        return true;\n      }\n    }\n    return false;\n  }\n\n  int solve() {\n    while (true) {\n      iter++;\n      int add = 0;\n      for (int i = 0; i < n; i++) {\n        if (pa[i] == -1 && dfs(i)) {\n          add++;\n        }\n      }\n      if (add == 0) {\n        break;\n      }\n      res += add;\n    }\n    return res;\n  }\n\n  int run_one(int v) {\n    if (pa[v] != -1) {\n      return 0;\n    }\n    iter++;\n    return (int) dfs(v);\n  }\n};\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  const int N = (int) 1e7 + 10;\n  vector<bool> prime(N, true);\n  for (int i = 2; i < N; i++) if (prime[i]) for (int j = i + i; j < N; j += i) prime[j] = false;\n  prime[1] = false;\n  int n;\n  cin >> n;\n  map<int, int> mp;\n  for (int i = 0; i < n; i++) {\n    int x;\n    cin >> x;\n    mp[x] ^= 1;\n    mp[x + 1] ^= 1;\n  }\n  vector<int> x, y;\n  for (auto& p : mp) {\n    if (p.second == 1) {\n      if (p.first % 2 == 0) x.push_back(p.first);\n      else y.push_back(p.first);\n    }\n  }\n  int xn = (int) x.size();\n  int yn = (int) y.size();\n  matching mat(xn, yn);\n  for (int i = 0; i < xn; i++) {\n    for (int j = 0; j < yn; j++) {\n      if (prime[abs(x[i] - y[j])]) {\n        mat.add(i, j);\n      }\n    }\n  }\n  int u = mat.solve();\n  int ans = u;\n  xn -= u;\n  yn -= u;\n  ans += xn / 2 * 2;\n  ans += yn / 2 * 2;\n  if (xn % 2 == 1) {\n    ans += 3;\n  }\n  cout << ans << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<cstring>\nusing namespace std;\nint n;\nint res;\nvector<int>v;\nint lst=-1;\nint match[210];\nint me,mo;\nint mx;\nbool f[10000010];\nvector<int>ok[210];\nbool vis[210];\nint prm[1000010];\nint sz;\nbool bp(int x)\n{\n\tfor(int i=0;i<ok[x].size();i++)\n\t{\n\t\tint y=ok[x][i];\n\t\tif(vis[y])continue;\n\t\tvis[y]=true;\n\t\tif(match[y]==-1 || bp(match[y]))\n\t\t{\n\t\t\tmatch[y]=x;\n\t\t\tmatch[x]=y;\n\t\t\treturn true;\n\t\t}\n\t\tvis[y]=false;\n\t}\n\treturn false;\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint x;\n\t\tscanf(\"%d\",&x);\n\t\tif(x!=lst+1)\n\t\t{\n\t\t\tif(lst+1)v.push_back(lst+1);\n\t\t\tv.push_back(x);\n\t\t}\n\t\tlst=x;\n\t\tmx=lst+1;\n\t}\n\tv.push_back(lst+1);\n\tf[1]=true;\n\tfor(int i=2;i<=mx;i++)\n\t{\n\t\tif(!f[i])prm[++sz]=i;\n\t\tfor(int j=1;j<=sz;j++)\n\t\t{\n\t\t\tif(prm[j]*i>mx)break;\n\t\t\tf[prm[j]*i]=true;\n\t\t\tif(i%prm[j]==0)break;\n\t\t}\n\t}\n\tint l=v.size();\n\tfor(int i=0;i<l;i++)\n\t{\n\t\tmatch[i]=-1;\n\t\tif(v[i]&1)mo++;else me++;\n\t\tfor(int j=i+1;j<l;j++)\n\t\t{\n\t\t\tif(v[j]-v[i]!=2 && !f[v[j]-v[i]])\n\t\t\t{\n\t\t\t\tok[i].push_back(j);\n\t\t\t\tok[j].push_back(i);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<l;i++)\n\t{\n\t\tif(match[i]!=-1)continue;\n\t\tmemset(vis,false,sizeof(vis));\n\t\tif(bp(i))res++;\n\t}\n\tprintf(\"%d\",res+((me-res)/2+(mo-res)/2)*2+((me-res)%2)*3);\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\nusing namespace std;\nusing lint = long long;\nusing pi = pair<int, int>;\n\nconst int MAXN = 205, MAXM = 205;\nstruct bpm{\n\tvector<int> gph[MAXN];\n\tint dis[MAXN], l[MAXN], r[MAXM], vis[MAXN];\n\tvoid clear(){ for(int i=0; i<MAXN; i++) gph[i].clear();\t}\n\tvoid add_edge(int l, int r){ gph[l].push_back(r); }\n\tbool bfs(int n){\n\t\tqueue<int> que;\n\t\tbool ok = 0;\n\t\tmemset(dis, 0, sizeof(dis));\n\t\tfor(int i=0; i<n; i++){\n\t\t\tif(l[i] == -1 && !dis[i]){\n\t\t\t\tque.push(i);\n\t\t\t\tdis[i] = 1;\n\t\t\t}\n\t\t}\n\t\twhile(!que.empty()){\n\t\t\tint x = que.front();\n\t\t\tque.pop();\n\t\t\tfor(auto &i : gph[x]){\n\t\t\t\tif(r[i] == -1) ok = 1;\n\t\t\t\telse if(!dis[r[i]]){\n\t\t\t\t\tdis[r[i]] = dis[x] + 1;\n\t\t\t\t\tque.push(r[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn ok;\n\t}\n\tbool dfs(int x){\n\t\tfor(auto &i : gph[x]){\n\t\t\tif(r[i] == -1 || (!vis[r[i]] && dis[r[i]] == dis[x] + 1 && dfs(r[i]))){\n\t\t\t\tvis[r[i]] = 1; l[x] = i; r[i] = x;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tint match(int n){\n\t\tmemset(l, -1, sizeof(l));\n\t\tmemset(r, -1, sizeof(r));\n\t\tint ret = 0;\n\t\twhile(bfs(n)){\n\t\t\tmemset(vis, 0, sizeof(vis));\n\t\t\tfor(int i=0; i<n; i++) if(l[i] == -1 && dfs(i)) ret++;\n\t\t}\n\t\treturn ret;\n\t} \n}bpm;\n\nint n, a[MAXN];\nmap<int, int> mp;\n\nbool isprime(int x){\n\tif(x == 1) return 0;\n\tfor(int i=2; i*i<=x; i++){\n\t\tif(x % i == 0) return 0;\n\t}\n\treturn 1;\n}\n\nint main(){\n\tcin >> n;\n\tfor(int i=0; i<n; i++){\n\t\tint x; cin >> x;\n\t\tmp[x] ^= 1;\n\t\tmp[x + 1] ^= 1;\n\t}\n\tvector<int> l, r;\n\tfor(auto &i : mp){\n\t\tif(i.second){\n\t\t\tif(i.first & 1) l.push_back(i.first);\n\t\t\telse r.push_back(i.first);\n\t\t\tprintf(\"%d \", i.first);\n\t\t}\n\t}\n\tfor(int i=0; i<l.size(); i++){\n\t\tfor(int j=0; j<r.size(); j++){\n\t\t\tif(isprime(abs(r[j] - l[i]))){\n\t\t\t\tbpm.add_edge(i, j);\n\t\t\t}\n\t\t}\n\t}\n\tint m = bpm.match(l.size());\n\tint ans = 1e8;\n\tfor(int i=0; i<=m; i++){\n\t\tint ll = l.size() - i;\n\t\tint rl = r.size() - i;\n\t\tans = min(ans, i + (ll / 2 + rl / 2) * 2 + (ll % 2) * 3);\n\t}\n\tcout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n// template {{{\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\n#define lb lower_bound\n#define ub upper_bound\n#define f first\n#define s second\n#define resz resize\n\n#define sz(x) int((x).size())\n#define all(x) (x).begin(), (x).end()\n\n#define FOR(i, a, b) for (int i = (a); i < (b); i++)\n#define F0R(i, a) for (int i = 0; i < (a); i++)\n#define FORd(i, a, b) for (int i = (b)-1; i >= (a); i--)\n#define F0Rd(i, a) for (int i = (a)-1; i >= 0; i--)\n#define trav(a, x) for (auto& a : x)\n\n#define sort_by(x, y) sort(all(x), [&](const auto& a, const auto& b) { return y; })\n\nusing ll = long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\nusing vb = vector<bool>;\nusing vd = vector<double>;\nusing vs = vector<string>;\n\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\nusing pdd = pair<double, double>;\n\nusing vpii = vector<pii>;\nusing vvpii = vector<vpii>;\nusing vpll = vector<pll>;\nusing vvpll = vector<vpll>;\nusing vpdd = vector<pdd>;\nusing vvpdd = vector<vpdd>;\n\ntemplate<typename T> void ckmin(T& a, const T& b) { a = min(a, b); }\ntemplate<typename T> void ckmax(T& a, const T& b) { a = max(a, b); }\n\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nnamespace __input {\n    template<class T1, class T2> void re(pair<T1,T2>& p);\n    template<class T> void re(vector<T>& a);\n    template<class T, size_t SZ> void re(array<T,SZ>& a);\n\n    template<class T> void re(T& x) { cin >> x; }\n    void re(double& x) { string t; re(t); x = stod(t); }\n    template<class Arg, class... Args> void re(Arg& first, Args&... rest) {\n        re(first); re(rest...);\n    }\n\n    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }\n    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }\n    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }\n}\nusing namespace __input;\n\nnamespace __output {\n    template<class T1, class T2> void pr(const pair<T1,T2>& x);\n    template<class T, size_t SZ> void pr(const array<T,SZ>& x);\n    template<class T> void pr(const vector<T>& x);\n    template<class T> void pr(const set<T>& x);\n    template<class T1, class T2> void pr(const map<T1,T2>& x);\n\n    template<class T> void pr(const T& x) { cout << x; }\n    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) {\n        pr(first); pr(rest...);\n    }\n\n    template<class T1, class T2> void pr(const pair<T1,T2>& x) {\n        pr(\"{\",x.f,\", \",x.s,\"}\");\n    }\n    template<class T, bool pretty = true> void prContain(const T& x) {\n        if (pretty) pr(\"{\");\n        bool fst = 1; for (const auto& a: x) pr(!fst?pretty?\", \":\" \":\"\",a), fst = 0;\n        if (pretty) pr(\"}\");\n    }\n    template<class T> void pc(const T& x) { prContain<T, false>(x); pr(\"\\n\"); }\n    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }\n    template<class T> void pr(const vector<T>& x) { prContain(x); }\n    template<class T> void pr(const set<T>& x) { prContain(x); }\n    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }\n\n    void ps() { pr(\"\\n\"); }\n    template<class Arg> void ps(const Arg& first) {\n        pr(first); ps();\n    }\n    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) {\n        pr(first,\" \"); ps(rest...);\n    }\n}\nusing namespace __output;\n\n#define TRACE(x) x\n#define __pn(x) pr(#x, \" = \")\n#define pd(...) __pn((__VA_ARGS__)), ps(__VA_ARGS__), cout << flush\n\nnamespace __algorithm {\n    template<typename T> void dedup(vector<T>& v) {\n        sort(all(v)); v.erase(unique(all(v)), v.end());\n    }\n    template<typename T> typename vector<T>::iterator find(vector<T>& v, const T& x) {\n        auto it = lower_bound(all(v), x); return it != v.end() && *it == x ? it : v.end();\n    }\n    template<typename T> size_t index(vector<T>& v, const T& x) {\n        auto it = find(v, x); assert(it != v.end() && *it == x); return it - v.begin();\n    }\n\n    template<typename T1, typename T2> typename vector<pair<T1, T2>>::iterator lower_bound(\n            const vector<pair<T1, T2>>& v, const T1& x) {\n        return lower_bound(all(v), x, [](pair<T1, T2> a, pair<T1, T2> b) { return a.f < b.f; });\n    }\n    template<typename T1, typename T2> typename vector<pair<T1, T2>>::iterator upper_bound(\n            const vector<pair<T1, T2>>& v, const T1& x) {\n        return upper_bound(all(v), x, [](pair<T1, T2> a, pair<T1, T2> b) { return a.f < b.f; });\n    }\n}\nusing namespace __algorithm;\n\nstruct monostate {\n    friend istream& operator>>(istream& is, const __attribute__((unused))monostate& ms) { return is; }\n    friend ostream& operator<<(ostream& os, const __attribute__((unused))monostate& ms) { return os; }\n} ms;\n\ntemplate<typename W=monostate> struct wedge {\n    int u, v, i; W w;\n    wedge<W>(int _u=-1, int _v=-1, int _i=-1) : u(_u), v(_v), i(_i) {}\n    int operator[](int loc) const { return u ^ v ^ loc; }\n    friend void re(wedge& e) { re(e.u, e.v, e.w); --e.u, --e.v; }\n    friend void pr(const wedge& e) { pr(e.u, \"<-\", e.w, \"->\", e.v); }\n};\n\nnamespace __io {\n    void setIn(string s) { freopen(s.c_str(),\"r\",stdin); }\n    void setOut(string s) { freopen(s.c_str(),\"w\",stdout); }\n    void setIO(string s = \"\") {\n        ios_base::sync_with_stdio(0); cin.tie(0);\n        if (sz(s)) { setIn(s+\".in\"), setOut(s+\".out\"); }\n    }\n}\nusing namespace __io;\n// }}}\n\n// dinic {{{\ntemplate<typename F> struct dinic {\n    static const F inf = numeric_limits<F>::max();\n\n    int V;\n    vvi adj;\n    vi dest;\n    vector<F> cap;\n\n    dinic (int V = 0) : V(V) {\n        adj.resize(V);\n    }\n\n    void __arc(int u, int v, F c) {\n        adj[u].push_back(dest.size());\n        dest.push_back(v);\n        cap.push_back(c);\n    }\n\n    // Inserts a directed edge u --> v with capacity c.\n    void arc(int u, int v, F c) {\n        __arc(u, v, c);\n        __arc(v, u, F(0));\n    }\n\n    bool bfs(int s, int t, vi& level, vector<F>& flow) const {\n        level = vi(V, -1);\n        level[s] = 0;\n        for (queue<int> q({s}); !q.empty(); q.pop()) {\n            int u = q.front();\n            for (int e : adj[u]) {\n                if (level[dest[e]] == -1 && flow[e] < cap[e]) {\n                    level[dest[e]] = level[u] + 1;\n                    q.push(dest[e]);\n                }\n            }\n        }\n        return level[t] != -1;\n    }\n\n    F augment(int s, int t, vi& level, vector<F>& flow, vi& inx, F cur) const {\n        if (s == t) return cur;\n        for (int e; inx[s] < adj[s].size(); inx[s]++) {\n            e = adj[s][inx[s]];\n            if (level[dest[e]] != level[s] + 1) continue;\n            if (flow[e] == cap[e]) continue;\n            F incr = augment(dest[e], t, level, flow, inx, min(cur, cap[e] - flow[e]));\n            if (incr > F(0)) {\n                flow[e] += incr;\n                flow[e^1] -= incr;\n                return incr;\n            }\n        }\n        return F(0);\n    }\n\n    /*\n     * Computes a maximum flow from node s to node t.\n     *\n     * Runs in O(V^2 * E) in the general case.\n     * Runs in O(min{ V^(2/3), E^(1/2) } * E) if all edges have unit capacity.\n     * Runs in O(V^(1/2) * E) for bipartite matching.\n     */\n    tuple<F, vector<F>> max_flow(int s, int t) const {\n        assert(s != t);\n        F res(0);\n        vector<F> flow(cap.size());\n        for (vi level; bfs(s, t, level, flow); ) {\n            for (vi inx(V, 0); F incr = augment(s, t, level, flow, inx, inf); )\n                res += incr;\n        }\n        return make_tuple(res, flow);\n    }\n};\n\n// }}}\n\ntemplate<size_t N> struct sieve {\n    vi primes, least_prime, largest_proper;\n    sieve() : least_prime(N + 1), largest_proper(N + 1) {\n        for (int i = 2; i <= N; i++) {\n            if (!least_prime[i]) {\n                least_prime[i] = i;\n                primes.push_back(i);\n            }\n            for (int x : primes) {\n                if (x > least_prime[i] || i * x > N) break;\n                least_prime[i * x] = x;\n                largest_proper[i * x] = i;\n            }\n        }\n    }\n\n    bool is_prime(int v) {\n        assert(0 < v && v < N);\n        return least_prime[v] == v;\n    }\n\n    vi factor(int v) {\n        assert(0 < v && v <= N);\n        vi res;\n        while (v > 1) {\n            res.push_back(least_prime[v]);\n            v = largest_proper[v];\n        }\n        reverse(all(res));\n        return res;\n    }\n};\n\nint main() {\n    setIO();\n\n    int N; re(N);\n\n    const int MAXV = 1e7 + 1;\n    sieve<MAXV> sv;\n\n    vb cards(MAXV);\n    F0R (i, N) { int v; re(v); cards[v] = true; }\n\n    vi even, odd;\n    F0R (i, MAXV - 1) if (cards[i] != cards[i+1]) {\n        (i&1 ? odd : even).pb(i);\n    }\n\n    dinic<int> g(1 + sz(even) + sz(odd) + 1);\n    F0R (i, sz(even)) g.arc(0, i+1, 1);\n    F0R (j, sz(odd)) g.arc(1+sz(even)+j, g.V-1, 1);\n    F0R (i, sz(even)) {\n        F0R (j, sz(odd)) {\n            if (sv.is_prime(abs(even[i] - odd[j])))\n                g.arc(1+i, 1+sz(even)+j, 1);\n        }\n    }\n\n    int m = get<0>(g.max_flow(0, g.V-1));\n\n    int ans = (sz(even) - m)&1;\n    ans += sz(even) + sz(odd) - m;\n    ps(ans);\n\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\nconst int MAX1=100;\nconst int MAX2=10000000;\nconst int INF=0x3f3f3f3f;\nint n,a[MAX1+5],p[MAX2+5],chk[MAX1*2+5],dir[MAX1*2+5][MAX1*2+5],ans;\nvector<int> cx,c[2],seq;\nvector<pii> conn[2*MAX1+5];\nint dfs(int x,int y){\n    int flow=0;\n    if(x==y) return INF;\n    chk[x]=1;\n    for(int i=0;i<conn[x].size();i++) if(chk[conn[x][i].first]==0&&conn[x][i].second>0){\n        int t=dfs(conn[x][i].first,y);\n        if(t>0){\n            flow=min(t,conn[x][i].second);\n            seq.push_back(x);\n            break;\n        }\n    }\n    chk[x]=0;\n    return flow;\n}\nint fflow(int x,int y){\n    seq.clear(); seq.push_back(y);\n    int flow=dfs(x,y);\n    for(int i=0;i<seq.size()-1;i++) {\n        int a=seq[i+1],b=seq[i];\n        conn[a][dir[a][b]].second-=flow;\n        conn[b][dir[b][a]].second+=flow;\n        //for(int j=0;j<conn[a].size();j++) if(conn[a][j].first==b) conn[a][j].second-=flow;\n        //for(int j=0;j<conn[b].size();j++) if(conn[b][j].first==a) conn[b][j].second+=flow;\n    }\n    return flow;\n}\nint main(){\n    scanf(\"%d\",&n);\n    for(int i=0;i<n;i++) scanf(\"%d\",&a[i]);\n    cx.push_back(a[0]), cx.push_back(a[0]+1);\n    for(int i=1;i<n;i++){\n        if(cx[cx.size()-1]==a[i]) cx.pop_back();\n        else cx.push_back(a[i]);\n        cx.push_back(a[i]+1);\n    }\n    for(int i=2;i<=MAX2;i++){\n        if(p[i]==0){\n            p[i]=1;\n            if(i<=3163) {for(int j=i*i;j<=MAX2;j+=i) p[j]=-1;}\n        }\n    }\n    p[2]=-1;\n    for(int i=0;i<cx.size();i++) c[cx[i]%2].push_back(cx[i]);\n    for(int i=0;i<c[0].size();i++) for(int j=0;j<c[1].size();j++) if(p[abs(c[0][i]-c[1][j])]==1) {\n        dir[i][c[0].size()+j]=conn[i].size();\n        dir[c[0].size()+j][i]=conn[c[0].size()+j].size();\n        conn[i].push_back(make_pair(c[0].size()+j,1));\n        conn[c[0].size()+j].push_back(make_pair(i,0));\n    }\n    for(int i=0;i<c[0].size();i++) {\n        dir[c[0].size()+c[1].size()][i]=conn[c[0].size()+c[1].size()].size();\n        dir[i][c[0].size()+c[1].size()]=conn[i].size();\n        conn[c[0].size()+c[1].size()].push_back(make_pair(i,1));\n        conn[i].push_back(make_pair(c[0].size()+c[1].size(),0));\n    }\n    for(int i=0;i<c[1].size();i++) {\n        dir[i+c[0].size()][c[0].size()+c[1].size()+1]=conn[i+c[0].size()].size();\n        dir[c[0].size()+c[1].size()+1][i+c[0].size()]=conn[c[0].size()+c[1].size()+1].size();\n        conn[i+c[0].size()].push_back(make_pair(c[0].size()+c[1].size()+1,1));\n        conn[c[0].size()+c[1].size()+1].push_back(make_pair(i+c[0].size(),0));\n    }\n    while(fflow(c[0].size()+c[1].size(),c[0].size()+c[1].size()+1)) ans++;\n    printf(\"%d\\n\",c[0].size()+c[1].size()-ans+(c[0].size()-ans)%2);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <cmath>\nusing namespace std;\nconst int maxn=101;\n\nint n,a[maxn];\nvector<int> q,odd,eve;\nvector<int> po[maxn*2],pe[maxn*2];\nint to,te,s;\nbool vis[maxn*2];\nint match[maxn*2];\n\nbool prime(int p)\n{\n\tif (p<=2) return false;\n\tfor(int i=2;i<=sqrt(p);i++)\n\t\tif (p%i==0) return false;\n\treturn true;\n}\n\nbool calc(int p)\n{\n\tfor(int i=0;i<po[p].size();i++)\n\t{\n\t\tint nxt=po[p][i];\n\t\tif (vis[nxt]) continue;\n\t\t\n\t\tif (!match[nxt] || calc(match[nxt]))\n\t\t{\n\t\t\tmatch[nxt]=p;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)\n\t\tscanf(\"%d\",&a[i]);\n\t\n\tq.push_back(a[1]);\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tif (a[i]+1<a[i+1])\n\t\t{\n\t\t\tq.push_back(a[i]+1);\n\t\t\tq.push_back(a[i+1]);\n\t\t}\n\t}\n\tq.push_back(a[n]+1);\n\t\n\todd.push_back(0);\n\teve.push_back(0);\n\tfor(int i=0;i<q.size();i++)\n\t{\n\t\tif (q[i]%2) odd.push_back(q[i]),to++;\n\t\telse eve.push_back(q[i]),te++;\n\t}\n\t\n\tfor(int i=1;i<=to;i++)\n\t{\n\t\tfor(int j=1;j<=te;j++)\n\t\t{\n\t\t\tif (prime(abs(odd[i]-eve[j])))\n\t\t\t{\n\t\t\t\tpo[i].push_back(j);\n\t\t\t\tpe[j].push_back(i);\n\t\t\t}\n\t\t}\n\t}\n\t\n\ts=0;\n\tfor(int i=1;i<=to;i++)\n\t{\n\t\tfor(int j=1;j<=te;j++)\n\t\t\tvis[j]=false;\n\t\tif (calc(i)) s++;\n\t}\n\t\n\tint ans=s+((to-s)/2+(te-s)/2)*2+(to-s)%2*3;\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include<queue>\n#include<iostream>\n#include<set>\n#include<vector>\n#include<algorithm>\n#include<map>\n#include<tuple>\n\nusing namespace std;\n\ntypedef pair<int,int> pii;\ntypedef tuple<int,int,int> t3;\ntypedef tuple<int,int,int,int> t4;\n\nconst int MX = 205;\n\nint D[MX];\nvector<int> L[MX];\nint R[MX];\nint vst[MX], t = 1;\n\nint dfs(int x){\n\tif( vst[x] == t ) return 0;\n\tvst[x] = t;\n\tfor(int c : L[x]){\n\t\tif( !R[c] || dfs(R[c])){\n\t\t\tR[c] = x;\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nint is_prime(int a){\n\tif( a < 0) a = -a;\n\tif( a == 1 ) return false;\n\tfor(int i = 2; i*i <= a; i++) if( a%i == 0 ) return false;\n\treturn true;\n}\n\nint main()\n{\n\tint N;\n\tscanf(\"%d\", &N);\n\tfor(int i = 1; i <= N; i++){\n\t\tscanf(\"%d\", D+i);\n\t}\n\n\tint M = 1, E[MX] = {0, D[1]};\n\tfor(int i = 2; i <= N; i++){\n\t\tif( D[i-1] != D[i]-1){\n\t\t\tE[++M] = D[i-1]+1;\n\t\t\tE[++M] = D[i];\n\t\t}\n\t}\n\tE[++M] = D[N]+1;\n\n\tint a = 0, b = 0;\n\tfor(int i = 1; i <= M; i++){\n\t\tif( E[i]%2 == 0) a++;\n\t\telse b++;\n\t}\n\tfor(int i = 1; i <= M; i++){\n\t\tfor(int j = 1; j <= M; j++){\n\t\t\tif( E[i]%2 == 0 && E[j]%2 == 1 );\n\t\t\telse continue;\n\t\t\tif( is_prime(E[i] - E[j]) ) L[i].push_back(j);\n\t\t}\n\t}\n\tint ans = 0;\n\tfor(int i = 1; i <= M; i++){\n\t\tt++; if(dfs(i)) ans++, a--, b--;\n\t}\n\tans += (a/2 + b/2) * 2;\n\tif( a%2 == 1 ) ans += 3;\n\tprintf(\"%d\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,a,b) for(int i=a;i<=b;++i)\ntypedef long long ll;\n\nusing namespace std;\n\nvoid File(){\n\tfreopen(\"ARC80F.in\",\"r\",stdin);\n\tfreopen(\"ARC80F.out\",\"w\",stdout);\n}\n\nconst int maxn=500+10;\nint n,a[maxn],pos[maxn],tot,cnt,ans;\nint be[maxn],cnte,to[maxn*maxn],las[maxn*maxn],beg[maxn];\nbool vis[maxn];\n\nvoid add(int u,int v){\n\tlas[++cnte]=beg[u];\n\tbeg[u]=cnte;\n\tto[cnte]=v;\n}\n\nbool pd(int x){\n\tif(x==1 || x==2)return false;\n\tint y=sqrt(x);\n\tREP(i,2,y)if(x%i==0)return false;\n\treturn true;\n}\n\nbool Hungary(int u){\n\tfor(int i=beg[u];i;i=las[i]){\n\t\tif(vis[to[i]])continue;\n\t\tvis[to[i]]=1;\n\t\tif(!be[to[i]] || Hungary(be[to[i]])){\n\t\t\tbe[to[i]]=u;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint main(){\n\t//File();\n\tscanf(\"%d\",&n);\n\tREP(i,1,n){\n\t\tscanf(\"%d\",&a[i]);\n\t\tif(i==1 || a[i-1]<a[i]-1)pos[++tot]=a[i];\n\t\tif(i!=1 && a[i]>a[i-1]+1)pos[++tot]=a[i-1]+1;\n\t}\n\tpos[++tot]=a[n]+1;\n\tREP(i,1,tot)if(pos[i]%2)++cnt;\n\tREP(i,1,tot)if(pos[i]%2==0){\n\t\tREP(j,1,tot)if(pos[j]%2==1 && pd(abs(pos[j]-pos[i])))\n\t\t\tadd(i,j);\n\t}\n\tREP(i,1,tot)if(pos[i]%2==0){\n\t\tmemset(vis,0,sizeof(vis));\n\t\tans+=Hungary(i);\n\t}\n\tprintf(\"%d\\n\",ans+(tot-ans*2)+(cnt-ans)%2);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n#define rep(i, n) for (int i = 0; i < (int) (n); i++)\n#define reps(i, n) for (int i = 1; i <= (int) (n); i++)\n#define all(x) (x).begin(), (x).end()\n#define uniq(x) (x).erase(unique(all(x)), (x).end())\n#define bit(n) (1LL << (n))\n#define dump(x) cerr << #x \" = \" << (x) << endl\nusing vint = vector<int>;\nusing vvint = vector<vint>;\nusing pint = pair<int, int>;\nusing vpint = vector<pint>;\ntemplate<typename T> using priority_queue_rev = priority_queue<T, vector<T>, greater<T>>;\nconstexpr double PI = 3.1415926535897932384626433832795028;\nconstexpr int DY[9] = {0, 1, 0, -1, 1, 1, -1, -1, 0};\nconstexpr int DX[9] = {1, 0, -1, 0, 1, -1, -1, 1, 0};\nint sign(int x) { return (x > 0) - (x < 0); }\nint gcd(int a, int b) {\n    while (b) { swap(a %= b, b); }\n    return a;\n}\nint lcm(int a, int b) { return a / gcd(a, b) * b; }\nint cdiv(int a, int b) { return (a - 1 + b) / b; }\ntemplate<typename T> void fin(T mes) {\n    cout << mes << endl;\n    exit(0);\n}\ntemplate<typename T, typename U> bool chmax(T &a, const U &b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate<typename T, typename U> bool chmin(T &a, const U &b) {\n    if (b < a) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate<typename T, typename U> ostream &operator<<(ostream &os, const pair<T, U> &rhs) {\n    os << \"(\" << rhs.first << \", \" << rhs.second << \")\";\n    return os;\n}\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &rhs) {\n    os << \"{\";\n    for (auto itr = rhs.begin(); itr != rhs.end(); itr++) {\n        os << *itr << (next(itr) != rhs.end() ? \", \" : \"\");\n    }\n    os << \"}\";\n    return os;\n}\ntemplate<typename T> ostream &operator<<(ostream &os, const deque<T> &rhs) {\n    os << \"{\";\n    for (auto itr = rhs.begin(); itr != rhs.end(); itr++) {\n        os << *itr << (next(itr) != rhs.end() ? \", \" : \"\");\n    }\n    os << \"}\";\n    return os;\n}\ntemplate<typename T> ostream &operator<<(ostream &os, const set<T> &rhs) {\n    os << \"{\";\n    for (auto itr = rhs.begin(); itr != rhs.end(); itr++) {\n        os << *itr << (next(itr) != rhs.end() ? \", \" : \"\");\n    }\n    os << \"}\";\n    return os;\n}\ntemplate<typename T, typename U> ostream &operator<<(ostream &os, const map<T, U> &rhs) {\n    os << \"{\";\n    for (auto itr = rhs.begin(); itr != rhs.end(); itr++) {\n        os << *itr << (next(itr) != rhs.end() ? \", \" : \"\");\n    }\n    os << \"}\";\n    return os;\n}\nstruct setup {\n    static constexpr int PREC = 20;\n    setup() {\n        cout << fixed << setprecision(PREC);\n        cerr << fixed << setprecision(PREC);\n    };\n} setup;\n\ntemplate<typename M>\nstruct dinic {\n    using T = typename M::T;\n    struct edge {\n        int to, rev;\n        T cap;\n        bool is_rev;\n    };\n    int n;\n    std::vector<std::vector<edge>> graph;\n    std::vector<int> level, iter;\n    void add_edge(int from, int to, T cap) {\n        graph[from].push_back({to, (int) graph[to].size(), cap, false});\n        graph[to].push_back({from, (int) graph[from].size() - 1, M::id(), true});\n    }\n    dinic(const std::vector<std::vector<int>> &adj, const std::vector<std::vector<typename M::T>> &cap)\n        : n(adj.size()), graph(n), level(n), iter(n) {\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < adj[i].size(); j++) { add_edge(i, adj[i][j], cap[i][j]); }\n        }\n    }\n    void bfs(int s) {\n        fill(level.begin(), level.end(), -1);\n        std::queue<int> que;\n        level[s] = 0;\n        que.push(s);\n        while (!que.empty()) {\n            int v = que.front();\n            que.pop();\n            for (int i = 0; i < graph[v].size(); i++) {\n                edge &e = graph[v][i];\n                if (M::is_id(e.cap) || level[e.to] >= 0) { continue; }\n                level[e.to] = level[v] + 1;\n                que.push(e.to);\n            }\n        }\n    }\n    T dfs(int v, int t, T f) {\n        if (v == t) { return f; }\n        for (int &i = iter[v]; i < graph[v].size(); i++) {\n            edge &e = graph[v][i];\n            if (level[v] >= level[e.to] || M::is_id(e.cap)) { continue; }\n            T d = dfs(e.to, t, M::gr(f, e.cap) ? e.cap : f);\n            if (M::is_id(d)) { continue; }\n            e.cap = M::op(e.cap, M::inv(d));\n            graph[e.to][e.rev].cap = M::op(graph[e.to][e.rev].cap, d);\n            return d;\n        }\n        return M::id();\n    }\n    T calc_max_flow(int s, int t, T lim) {\n        T ret = M::id();\n        while (true) {\n            bfs(s);\n            if (level[t] < 0 || M::is_id(lim)) { return ret; }\n            fill(iter.begin(), iter.end(), 0);\n            T f;\n            while (!M::is_id(f = dfs(s, t, lim))) {\n                ret = M::op(ret, f);\n                lim = M::op(lim, M::inv(f));\n            }\n        }\n    }\n    T calc_max_flow(int s, int t) { return calc_max_flow(s, t, M::ab()); }\n    std::map<std::pair<int, int>, T> get_max_flow() {\n        std::map<std::pair<int, int>, T> ret;\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < graph[i].size(); j++) {\n                edge &e = graph[i][j];\n                if (e.is_rev) { ret[{e.to, i}] = e.cap; }\n            }\n        }\n        return ret;\n    }\n    std::map<std::pair<int, int>, T> get_min_cut(int s) {\n        std::map<std::pair<int, int>, T> ret;\n        std::vector<int> visited(n);\n        std::queue<int> que;\n        que.push(s);\n        while (!que.empty()) {\n            int v = que.front();\n            que.pop();\n            if (visited[v]) { continue; }\n            visited[v] = true;\n            for (int i = 0; i < graph[v].size(); i++) {\n                edge &e = graph[v][i];\n                if (!M::is_id(e.cap)) { que.push(e.to); }\n            }\n        }\n        for (int i = 0; i < n; i++) {\n            if (visited[i]) { continue; }\n            for (int j = 0; j < graph[i].size(); j++) {\n                edge &e = graph[i][j];\n                if (e.is_rev && visited[e.to]) { ret[{e.to, i}] = e.cap; }\n            }\n        }\n        return ret;\n    }\n};\n\nstruct int_dinic {\n    using T = int;\n    static T id() { return 0; }\n    static T ab() { return std::numeric_limits<T>::max(); }\n    static T inv(const T &a) { return -a; }\n    static T op(const T &a, const T &b) { return a + b; }\n    static bool gr(const T &a, const T &b) { return a > b; }\n    static bool is_id(const T &a) { return a == id(); };\n};\n\nstd::vector<long long> get_divisors(long long n) {\n    std::vector<long long> ret;\n    long long i;\n    for (i = 1; i * i < n; i++) {\n        if (n % i == 0) {\n            ret.push_back(i);\n            ret.push_back(n / i);\n        }\n    }\n    if (i * i == n) { ret.push_back(i); }\n    std::sort(ret.begin(), ret.end());\n    return ret;\n}\n\nint N;\nint x[110];\nsigned main() {\n    cin >> N;\n    rep(i, N) { cin >> x[i]; }\n    vint v;\n    rep(i, N) {\n        if (!v.empty() && v.back() == x[i]) { v.pop_back(); }\n        else { v.emplace_back(x[i]); }\n        v.emplace_back(x[i] + 1);\n    }\n    vint even, odd;\n    rep(i, v.size()) {\n        if (v[i] & 1) { odd.emplace_back(v[i]); }\n        else { even.emplace_back(v[i]); }\n    }\n    vvint adj(330), cap(330);\n    dinic<int_dinic> dnc(adj, cap);\n    rep(i, even.size()) { dnc.add_edge(0, 100 + i, 1); }\n    rep(i, odd.size()) { dnc.add_edge(200 + i, 300, 1); }\n    rep(i, even.size()) {\n        rep(j, odd.size()) {\n            if (get_divisors(abs(even[i] - odd[j])).size() == 2) {\n                dnc.add_edge(100 + i, 200 + j, 1);\n            }\n        }\n    }\n    int f = dnc.calc_max_flow(0, 300);\n    int ans = v.size() + f;\n    if ((even.size() - f) & 1) { ans++; }\n    cout << ans-2 << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mo 1000000007\n#define pi 3.1415926535898\n#define eps 1e-9 \nusing namespace std;\nlong long read(){\n    long long xx=0,flagg=1;\n    char ch=getchar();\n    while((ch<'0'||ch>'9')&&ch!='-')\n        ch=getchar();\n    if(ch=='-'){\n        flagg=-1;\n        ch=getchar();\n    }\n    while(ch>='0'&&ch<='9'){\n        xx=xx*10+ch-'0';\n        ch=getchar();\n    }\n    return xx*flagg;\n}\nvoid pus(long long xx,long long flagg){\n    if(xx<0){\n        putchar('-');\n        xx=-xx;\n    }\n    if(xx>=10)\n        pus(xx/10,0);\n    putchar(xx%10+'0');\n    if(flagg==1)\n        putchar(' ');\n    if(flagg==2)\n        putchar('\\n');\n    return;\n}\n\nlong long ksc(long long u,long long v,long long n){\n\treturn (u*v-(long long)((long double)u/n*v)*n+n)%n;\n}\nlong long ksm(long long u,long long v,long long n){\n\tlong long o=1;\n\twhile(v){\n\t\tif(v&1)\n\t\t\to=ksc(o,u,n);\n\t\tu=ksc(u,u,n);\n\t\tv>>=1;\n\t}\n\treturn o;\n}\nlong long miller(long long n){\n\tif(n<=28){\n\t\tif(n==2||n==3||n==5||n==7||n==11||n==13||n==17||n==19||n==23)\n\t\t\treturn 1;\n\t\treturn 0;\n\t}\n\tlong long book[9]={2,3,5,7,11,13,17,19,23},i,j,x,y;\n\tfor(i=0;i<=8;i++){\n\t\tj=n-1;\n\t\twhile((j&1)==0)\n\t\t\tj>>=1;\n\t\tif(ksm(book[i],n-1,n)!=1)\n\t\t\treturn 0;\n\t\tx=ksm(book[i],j,n);\n\t\tif(x!=1){\n\t\t\twhile(j!=n-1){\n\t\t\t\tif(x==n-1)\n\t\t\t\t\tbreak;\n\t\t\t\tif(x==1)\n\t\t\t\t\treturn 0;\n\t\t\t\tx=ksc(x,x,n);\n\t\t\t\tj<<=1;\n\t\t\t}\n\t\t\tif(x!=n-1)\n\t\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}\nint n,m,s,t,i,j,x,y,z,zhan[100005],book[100005],flag,ans,a[10000005],top1,top2,b[205],c[205];\nint top,fir[100005],qu[200005],to[200005],nex[200005],iter[100005];\nint lj(int u,int v,int w){\n\ttop++;\n\tnex[top]=fir[u];\n\tfir[u]=top;\n\tto[top]=v;\n\tqu[top]=w;\n\treturn 0;\n}\nint BFS(){\n\tint head=0,tail=0,v;\n\tzhan[0]=s;book[s]=1;\n\twhile(head<=tail){\n\t\tv=zhan[head];\n\t\tfor(int top1=fir[v];top1;top1=nex[top1])\n\t\t\tif(book[to[top1]]==0&&qu[top1]){\n\t\t\t\ttail++;\n\t\t\t\tzhan[tail]=to[top1];\n\t\t\t\tbook[to[top1]]=book[v]+1;\n\t\t\t}\n\t\thead++;\n\t}\n\treturn 0;\n}\nint DFS(int v,int w){\n\tif(v==t){\n\t\tflag=w;\n\t\tans+=w;\n\t\treturn 0;\n\t}\n\tfor(int &top1=iter[v];top1;top1=nex[top1])\n\t\tif(book[to[top1]]==book[v]+1&&qu[top1]){\n\t\t\tDFS(to[top1],min(w,qu[top1]));\n\t\t\tif(flag){\n\t\t\t\tqu[top1]-=flag;\n\t\t\t\tif(top1&1)\n\t\t\t\t\tqu[top1+1]+=flag;\n\t\t\t\telse\n\t\t\t\t\tqu[top1-1]+=flag;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n}\nint main(){\n\t//freopen(\"7.in\",\"r\",stdin);\n    //freopen(\"7.out\",\"w\",stdout);\n   \tn=read();\n   \tfor(i=1;i<=n;i++){\n\t\tx=read();\n\t\ta[x-1]^=1;\n\t\ta[x]^=1;\n\t}\n\tfor(i=0;i<=10000000;i++)\n\t\tif(a[i]==1){\n\t\t\tif(i&1){\n\t\t\t\ttop1++;\n\t\t\t\tb[top1]=i;\n\t\t\t}\n\t\t\telse{\n\t\t\t\ttop2++;\n\t\t\t\tc[top2]=i;\n\t\t\t}\n\t\t}\n\ts=top1+top2+1;\n\tt=top1+top2+2;\n\tn=t;\n\tfor(i=1;i<=top1;i++)\n\t\tfor(j=1;j<=top2;j++)\n\t\t\tif(miller(c[j+top1]-b[i])==1){\n\t\t\t\tlj(i,j+top1,1);\n\t\t\t\tlj(j+top1,i,0);\n\t\t\t}\n\tfor(i=1;i<=top1;i++){\n\t\tlj(s,i,1);\n\t\tlj(i,s,0);\n\t}\n\tfor(i=1;i<=top2;i++){\n\t\tlj(i+top1,t,1);\n\t\tlj(t,i+top1,0);\n\t}\n\tdo{\n\t\tfor(i=1;i<=n;i++){\n\t\t\tbook[i]=0;\n\t\t\titer[i]=fir[i];\n\t\t}\n\t\tBFS();\n\t\tdo{\n\t\t\tflag=0;\n\t\t\tDFS(s,2147483647);\n\t\t}while(flag);\n\t}while(book[t]);\n\tif(((top1-ans)&1)==0)\n\t\tpus(top1+top2-ans,2);\n\telse\n\t\tpus(top1+top2-ans+1,2);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<cstring>\nusing namespace std;\nint n;\nint res;\nvector<int>v;\nint lst=-1;\nint match[210];\nint me,mo;\nint mx;\nbool f[10000010];\nbool ok[210][210];\nbool vis[210];\nint prm[1000010];\nint sz;\nint l;\nbool bp(int x)\n{\n\tfor(int i=x+1;i<l;i++)\n\t{\n\t\tif(!ok[x][i])continue;\n\t\tif(vis[i])continue;\n\t\tvis[i]=true;\n\t\tif(match[i]==-1 || bp(match[i]))\n\t\t{\n\t\t\tmatch[i]=x;\n\t\t\tmatch[x]=i;\n\t\t\treturn true;\n\t\t}\n\t\tvis[i]=false;\n\t}\n\treturn false;\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint x;\n\t\tscanf(\"%d\",&x);\n\t\tif(x!=lst+1)\n\t\t{\n\t\t\tif(lst+1)v.push_back(lst+1);\n\t\t\tv.push_back(x);\n\t\t}\n\t\tlst=x;\n\t\tmx=lst+1;\n\t}\n\tv.push_back(lst+1);\n\tf[1]=true;\n\tfor(int i=2;i<=mx;i++)\n\t{\n\t\tif(!f[i])prm[++sz]=i;\n\t\tfor(int j=1;j<=sz;j++)\n\t\t{\n\t\t\tif(prm[j]*i>mx)break;\n\t\t\tf[prm[j]*i]=true;\n\t\t\tif(i%prm[j]==0)break;\n\t\t}\n\t}\n\tl=v.size();\n\tfor(int i=0;i<l;i++)\n\t{\n\t\tmatch[i]=-1;\n\t\tif(v[i]&1)mo++;else me++;\n\t\tfor(int j=i+1;j<l;j++)\n\t\t{\n\t\t\tif(v[j]-v[i]!=2 && !f[v[j]-v[i]])\n\t\t\t{\n\t\t\t\tok[i][j]=ok[j][i]=true;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<l;i++)\n\t{\n\t\tif(match[i]!=-1)continue;\n\t\tmemset(vis,false,sizeof(vis));\n\t\tif(bp(i))res++;\n\t}\n\tprintf(\"%d\",res+((me-res)/2+(mo-res)/2)*2+((me-res)%2)*3);\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define dbg(...) do{cerr<<__LINE__<<\": \";dbgprint(#__VA_ARGS__, __VA_ARGS__);}while(0);\n\nusing namespace std;\n\nnamespace std{template<class S,class T>struct hash<pair<S,T>>{size_t operator()(const pair<S,T>&p)const{return ((size_t)1e9+7)*hash<S>()(p.first)+hash<T>()(p.second);}};template<class T>struct hash<vector<T>>{size_t operator()(const vector<T> &v)const{size_t h=0;for(auto i : v)h=h*((size_t)1e9+7)+hash<T>()(i)+1;return h;}};}\ntemplate<class T>ostream& operator<<(ostream &os, const vector<T> &v){os<<\"[ \";rep(i,v.size())os<<v[i]<<(i==v.size()-1?\" ]\":\", \");return os;}template<class T>ostream& operator<<(ostream &os,const set<T> &v){os<<\"{ \"; for(const auto &i:v)os<<i<<\", \";return os<<\"}\";}\ntemplate<class T,class U>ostream& operator<<(ostream &os,const map<T,U> &v){os<<\"{\";for(const auto &i:v)os<<\" \"<<i.first<<\": \"<<i.second<<\",\";return os<<\"}\";}template<class T,class U>ostream& operator<<(ostream &os,const pair<T,U> &p){return os<<\"(\"<<p.first<<\", \"<<p.second<<\")\";}\nvoid dbgprint(const string &fmt){cerr<<endl;}template<class H,class... T>void dbgprint(const string &fmt,const H &h,const T&... r){cerr<<fmt.substr(0,fmt.find(\",\"))<<\"= \"<<h<<\" \";dbgprint(fmt.substr(fmt.find(\",\")+1),r...);}\ntypedef long long ll;typedef vector<int> vi;typedef pair<int,int> pi;const int inf = (int)1e9;const double INF = 1e12, EPS = 1e-9;\nstruct FlowGraph{\n\tstruct edge{ int to, cap, rev; };\n\t\n\tint n, *level, *iter;\n\tvector<vector<edge> > G;\n\t\n\tFlowGraph(int sz) : n(sz){\n\t\tG.resize(n);\n\t\titer = new int[n]; level = new int[n];\n\t}\n\t~FlowGraph(){\n\t\tdelete [] iter; delete [] level;\n\t}\n\t\n\tvoid add(int s, int t, int cap){\n\t\tG[s].pb((edge){t, cap, (int)G[t].size()});\n\t\tG[t].pb((edge){s, 0, (int)G[s].size() - 1});\n\t}\n\tvoid bfs(int s){\n\t\trep(i, n) level[i] = -1;\n\t\tqueue<int> q;\n\t\tlevel[s] = 0;\n\t\tq.push(s);\n\t\twhile(!q.empty()){\t\n\t\t\tint v = q.front();\n\t\t\tq.pop();\n\t\t\trep(i, G[v].size()){\n\t\t\t\tedge &e = G[v][i];\n\t\t\t\tif(e.cap > 0 && level[e.to] < 0){\n\t\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\t\tq.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint dfs(int v, int t, int f){\n\t\tif(v == t) return f;\n\t\tfor(int &i = iter[v]; i < (int)G[v].size(); i++){\n\t\t\tedge &e = G[v][i];\n\t\t\tif(e.cap > 0 && level[v] < level[e.to]){\n\t\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\t\tif(d > 0){\n\t\t\t\t\te.cap -= d;\n\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tint max_flow(int s, int t){\n\t\tint flow = 0;\n\t\twhile(1){\n\t\t\tbfs(s);\n\t\t\tif(level[t] < 0) return flow;\n\t\t\trep(i, n) iter[i] = 0;\n\t\t\tint f;\n\t\t\twhile((f = dfs(s, t, inf)) > 0) flow += f;\n\t\t}\n\t}\n};\nint main(){\n\tcin.tie(0); cin.sync_with_stdio(0);\n\t\n\tint n; cin >> n;\n\tvi v(n), u; rep(i, n) cin >> v[i];\n\tint cnt = 0;\n\trep(i, n){\n\t\tif(i && v[i] != v[i - 1] + 1){\n\t\t\tu.pb(v[i - 1] + 1);\n\t\t\tu.pb(v[i - 1] + 1 - cnt);\n\t\t\tcnt = 1;\n\t\t}\n\t\telse cnt++;\n\t}\n\tu.pb(v[n - 1] + 1);\n\tu.pb(v[n - 1] + 1 - cnt);\n\t\n\tauto isPrime = [](int x){\n\t\tfor(int i = 2; i * i <= x; i++) if(x % i == 0) return 0;\n\t\treturn 1;\n\t};\n\t\n\tvi o, e;\n\tfor(int i : u) if(i % 2) o.pb(i); else e.pb(i);\n\tint s = o.size() + e.size(), t = s + 1;\n\tFlowGraph g(o.size() + e.size() + 2);\n\t{\n\t\trep(i, o.size()) rep(j, e.size()) if(isPrime(abs(o[i] - e[j]))) g.add(i, j + o.size(), 1);\n\t\trep(i, o.size()) g.add(s, i, 1);\n\t\trep(i, e.size()) g.add(i + o.size(), t, 1);\n\t}\n\tint f = g.max_flow(s, t);\n\t\n\tint ans = f + ((o.size() - f) / 2 + (e.size() - f) / 2) * 2 + (o.size() - f) % 2 * 3;\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define inf (1e9 + 7)\n#define mem(a, b) memset(a, b, sizeof(a))\nusing namespace std;\n\nint pp[10000005], n, num[105], num2[205], nn = 0, ji = 0, ou = 0, lk[205], ans = 0;\nbool vis[205];\nvector<int> eg[205];\nmap<int, int> mps;\n\nvoid inits()\n{\n    mem(lk, -1);\n    for(int i = 2;i <= 10000000;i++)\n    {\n        if(!pp[i])\n            pp[++pp[0]] = i;\n        for(int j = 1;j <= pp[0]&&10000000 / i >= pp[j];j++)\n        {\n            pp[i * pp[j]] = 1;\n            if(i % pp[j] == 0)\n                break;\n        }\n    }\n}\n\nbool dfs(int u)\n{\n    int lim = eg[u].size();\n    for(int i = 0;i < lim;i++)\n    {\n        int v = eg[u][i];\n        if(!vis[v])\n        {\n            vis[v] = 1;\n            if(lk[v] == -1||dfs(lk[v]))\n            {\n                lk[v] = u;\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\nint main()\n{\n    inits();\n    int mx = 0;\n    scanf(\"%d\", &n);\n    for(int i = 1;i <= n;i++)\n        scanf(\"%d\", &num[i]);\n    sort(num + 1, num + 1 + n);\n    num2[++nn] = num[1];\n    mps[num[1]] = nn;\n    for(int i = 2;i <= n;i++)\n    {\n        if(num[i] - 1 != num[i - 1])\n        {\n            num2[++nn] = num[i - 1] + 1;\n            mps[num[i - 1] + 1] = nn;\n            num2[++nn] = num[i];\n            mps[num[i]] = nn;\n        }\n    }\n    num2[++nn] = num[n] + 1;\n    mps[num[n] + 1] = nn;\n    mx = num[n] + 1;\n    for(int i = 1;i <= nn;i++)\n    {\n        if(num2[i] % 2 == 0)\n        {\n            ou++;\n            continue;\n        }\n        else\n            ji++;\n        for(int j = 2;j <= pp[0];j++)\n        {\n            if(num2[i] + pp[j] > mx)\n                break;\n            if(mps.find(num2[i] + pp[j]) != mps.end())\n            {\n                int pos = mps[num2[i] + pp[j]];\n                eg[i].push_back(pos);\n            }\n        }\n    }\n    int res = 0;\n    for(int i = 1;i <= nn;i++)\n    {\n        if(num2[i] % 2 == 0)\n            continue;\n        mem(vis, 0);\n        if(dfs(i))\n            res++;\n    }\n    ans += res;\n    ji -= res;\n    ou -= res;\n    ans += ji / 2 * 2;\n    ji %= 2;\n    ans += ou / 2 * 2;\n    ou %= 2;\n    if(ji||ou)\n        ans += 3;\n    printf(\"%d\\n\", ans);\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pp;\ntypedef pair<ll,ll> pll;\nvoid read(int& x){ scanf(\"%d\",&x); }\nvoid read(ll& x){ scanf(\"%lld\",&x); }\ntemplate<typename T,typename... Args>\nvoid read(T& a,Args&... b){ read(a); read(b...); }\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define eb emplace_back\n#define x first\n#define y second\n\nint n;\nint p[210];\n\nint dist[210][210];\n\nvoid in(){\n\tint t; read(t);\n\tint last;\n\tread(last);\n\tp[++n] = last;\n\tfor(;--t;){\n\t\tint x; read(x);\n\t\tif(last+1 < x){\n\t\t\tp[++n] = last+1;\n\t\t\tp[++n] = x;\n\t\t}\n\t\tlast = x;\n\t}\n\tp[++n] = last+1;\n}\n\nbool is_prime(int x){\n\tfor(int i=2; i*i<=x; ++i) if(x%i==0) return 0;\n\treturn 1;\n}\n\nint get_dist(int i, int j){\n\tint df=abs(p[i]-p[j]);\n\tif(df == 1) return 3;\n\tif(df % 2 == 0) return 2;\n\tif(is_prime(df)) return 1;\n\treturn 3;\n}\n\ntypedef tuple<int,int,int> t3;\n\npriority_queue<t3> pq;\nbool c[210];\n\nint aite[210];\n\nint main()\n{\n\tin();\n\tfor(int i=1; i<=n; ++i){\n\t\tfor(int j=1; j<=n; ++j){\n\t\t\tif(i == j) continue;\n\t\t\tif(i<j){\n\t\t\t\tdist[i][j]=get_dist(i, j);\n\t\t\t\tpq.emplace(-dist[i][j], i, j);\n\t\t\t}\n\t\t\telse dist[i][j]=dist[j][i];\n\t\t}\n\t}\n\tint ans = 0;\n\twhile(pq.size()){\n\t\tint d, x, y; tie(d,x,y) = pq.top(); pq.pop();\n\t\tif(c[x] || c[y]) continue;\n\t\tans -= d;\n\t\tc[x]=1; c[y]=1;\n\t\taite[x]=y; aite[y]=x;\n\t}\n\twhile(true){\n\t\tbool rel=0;\n\t\tfor(int i=1; i<=n; ++i) if(aite[i]>i){\n\t\t\tfor(int j=i+1; j<=n; ++j) if(aite[j]>j){\n\t\t\t\tint x=aite[i], y=aite[j];\n\t\t\t\tint df = dist[i][x] + dist[j][y] - dist[i][y] - dist[j][x];\n\t\t\t\tif(df > 0){\n\t\t\t\t\tans -= df;\n\t\t\t\t\taite[i]=y; aite[y]=i;\n\t\t\t\t\taite[j]=x; aite[x]=j;\n\t\t\t\t\trel=1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(rel) break;\n\t\t}\n\t\tif(rel) continue;\n\t\tbreak;\n\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define fi first\n#define se second\n#define mp make_pair\n#define gc getchar\n#define pb push_back\n#define eb emplace_back\n#define all(x) (x).begin(),(x).end()\n#define x1 uvuvwevwevwe\n#define y1 onyetenyevwe\n#define x2 ugwemubwem\n#define y2 ossas\ntypedef long long LL;\ntypedef long double LD;\ntypedef pair<int,int> pii;\nconst int batasprima=10000;\ntemplate <typename T> void scan(T &angka){\n\tangka=0;char input=gc();T kali=1;\n\twhile(!(48<=input&&input<=57)){\tif(input=='-')\tkali=-1;input=gc();}\n\twhile(48<=input&&input<=57)\tangka=(angka<<3)+(angka<<1)+input-48,input=gc();angka*=kali;\n}\ntemplate <typename T1,typename T2> void scan(T1 &angka1,T2 &angka2){\n\tscan(angka1);scan(angka2);\n}\nint match[205],k=0,ans;\nvector <int> daftar,adj[205],prime;\nbitset<205> visited;\nvoid sieve(){\n\tbool isprime[batasprima+5];\n\tmemset(isprime,true,sizeof(isprime));\n\tfor(int i=2;i<=batasprima;i++)\n\t{\n\t\tif(!isprime[i])\n\t\t\tcontinue;\n\t\tprime.pb(i);\n\t\tfor(int j=i+i;j<=batasprima;j+=i)\n\t\t\tisprime[j]=false;\n\t}\n}\nbool isprime(int angka){\n\tif(angka<2)\n\t\treturn false;\n\tfor(auto isi:prime)\n\t{\n\t\tif(angka%isi==0)\n\t\t\treturn false;\n\t}\n\treturn true;\n}\nbool matching(int pos){\n\tif(visited[pos])\n\t\treturn false;\n\tvisited[pos]=true;\n\tfor(auto isi:adj[pos])\n\t{\n\t\tif(match[isi]==-1||matching(match[isi]))\n\t\t{\n\t\t\tmatch[isi]=pos;\n\t\t\tmatch[pos]=isi;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\nvoid buatgraph(){\t\n\tfor(int i=0;i<daftar.size();i++)\n\t{\n\t\tfor(int j=0;j<daftar.size();j++)\n\t\t{\n\t\t\tif(isprime(abs(daftar[i]-daftar[j])))\n\t\t\t\tadj[i].pb(j);\n\t\t}\n\t}\n}\nvoid hitungk(){\n\tmemset(match,-1,sizeof(match));\n\tfor(int i=0;i<daftar.size();i++)\n\t{\n\t\tif(match[i]!=-1)\n\t\t\tcontinue;\n\t\tvisited.reset();\n\t\tif(matching(i))\n\t\t\tk++;\n\t}\n}\nvoid hitungans(){\n\tint genap=0,ganjil=0;\n\tfor(auto isi:daftar)\n\t{\n\t\tif(isi&1)\n\t\t\tganjil++;\n\t\telse\n\t\t\tgenap++;\n\t}\n\tassert(ganjil>=k&&genap>=k);\n\tassert(ganjil%2==genap%2);\n\tans=k+((ganjil-k)/2+(genap-k)/2)*2+((ganjil-k)%2)*3;\n}\nvoid isidaftar(){\n\tint n,tadi=0;\n\tscan(n);\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tint input;\n\t\tscan(input);\n\t\tassert(tadi<input);\n\t\ttadi=input;\n\t\tif(daftar.size()&&daftar.back()==input)\n\t\t\tdaftar[daftar.size()-1]=input+1;\t\t\t//nanti mau sa coba\n\t\telse\n\t\t\tdaftar.pb(input),daftar.pb(input+1);\n\t}\n\tassert(daftar.size()<=200);\n}\nint main()\n{\n\tsieve();\n\tisidaftar();\n\tbuatgraph();\n\thitungk();\n\thitungans();\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define inf (1e9 + 7)\n#define mem(a, b) memset(a, b, sizeof(a))\nusing namespace std;\n\nint pp[10000005], n, num[105], num2[205], nn = 0, ji = 0, ou = 0, lk[205], ans = 0;\nbool vis[205];\nvector<int> eg[205];\nmap<int, int> mps;\n\nvoid inits()\n{\n    mem(lk, -1);\n    for(int i = 2;i <= 10000000;i++)\n    {\n        if(!pp[i])\n            pp[++pp[0]] = i;\n        for(int j = 1;j <= pp[0]&&10000000 / i >= pp[j];j++)\n        {\n            pp[i * pp[j]] = 1;\n            if(i % pp[j] == 0)\n                break;\n        }\n    }\n}\n\nbool dfs(int u)\n{\n    int lim = eg[u].size();\n    for(int i = 0;i < lim;i++)\n    {\n        int v = eg[u][i];\n        if(!vis[v])\n        {\n            vis[v] = 1;\n            if(lk[v] == -1||dfs(lk[v]))\n            {\n                lk[v] = u;\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\nint main()\n{\n    inits();\n    int mx = 0;\n    scanf(\"%d\", &n);\n    for(int i = 1;i <= n;i++)\n        scanf(\"%d\", &num[i]);\n    sort(num + 1, num + 1 + n);\n    num2[++nn] = num[1];\n    for(int i = 2;i <= n;i++)\n    {\n        if(num[i] - 1 != num[i - 1])\n        {\n            num2[++nn] = num[i - 1] + 1;\n            num2[++nn] = num[i];\n        }\n    }\n    num2[++nn] = num[n] + 1;\n    mx = num[n] + 1;\n    for(int i = 1;i <= nn;i++)\n    {\n        if(num2[i] % 2 == 0)\n        {\n            ou++;\n            continue;\n        }\n        else\n            ji++;\n        for(int j = 2;j <= pp[0];j++)\n        {\n            if(num2[i] + pp[j] > mx)\n                break;\n            if(mps.find(num2[i] + pp[j]) != mps.end())\n            {\n                int pos = mps[num2[i] + pp[j]];\n                eg[i].push_back(pos);\n            }\n        }\n    }\n    int res = 0;\n    for(int i = 1;i <= nn;i++)\n    {\n        if(num2[i] % 2 == 0)\n            continue;\n        mem(vis, 0);\n        if(dfs(i))\n            res++;\n    }\n    ans += res;\n    ji -= res;\n    ou -= res;\n    ans += ji / 2 * 2;\n    ji %= 2;\n    ans += ou / 2 * 2;\n    ou %= 2;\n    if(ji||ou)\n        ans += 3;\n    printf(\"%d\\n\", ans);\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <cassert>\n#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <sstream>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <list>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <algorithm>\n#include <complex>\n#include <cmath>\n#include <numeric>\n#include <bitset>\n\nusing namespace std;\n\n#define trace(...) __f(#__VA_ARGS__, __VA_ARGS__)\ntemplate <typename Arg1>\nvoid __f(const char* name, Arg1&& arg1){\n  cerr << name << \": \" << arg1 << endl;\n}\ntemplate <typename Arg1, typename... Args>\nvoid __f(const char* names, Arg1&& arg1, Args&&... args){\n  const char* comma = strchr(names + 1, ',');\n  cerr.write(names, comma - names) << \": \" << arg1 << \" |\";\n  __f(comma + 1, args...);\n}\n\ntypedef long long int64;\ntypedef pair<int, int> ii;\nconst int INF = 1 << 30;\nconst int MOD = 1e9 + 7;\n\nconst int N = 1e7 + 1000;\nbool flag[N];\nvector<int> prime;\n\nvoid prime_gen(int n) {\n  fill(flag, flag + n, false);\n  for (int i = 2; i < n; ++i) {\n    if (!flag[i]) prime.push_back(i);\n    for (int j = 0, k; j < prime.size() && (k = prime[j] * i) < n; ++j) {\n      flag[k] = true;\n      if (i % prime[j] == 0) break;\n    }\n  }\n  flag[0] = flag[1] = flag[2] = true;\n  // printf(\"%lu\\n\", prime.size());\n}\n\nconst int M = 110;\nint x[M];\nint dp[M];\n\nint main() {\n  prime_gen(N);\n  int n;\n  scanf(\"%d\", &n);\n  for (int i = 0; i < n; ++i) {\n    scanf(\"%d\", &x[i]);\n  }\n  int ret = 0;\n  for (int i = 1; i < n; ++i) {\n    int k = x[i] - x[i - 1] - 1;\n    if (!flag[k]) {\n      ret += 1;\n    } else if (k == 0) {\n      ret += 0;\n    } else if (k % 2 == 0) {\n      ret += 2;\n    } else {\n      ret += 3;\n    }\n  }\n  int k = x[n - 1] - x[0] + 1;\n  // trace(ret, k);\n  auto it = lower_bound(prime.begin() + 1, prime.end(), k);\n  if (*it == k) {\n    ret += 1;\n  } else if (k % 2 == 0) {\n    ret += 2;\n  } else {\n    ret += 3;\n  }\n  printf(\"%d\\n\", ret);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define HEAP priority_queue\n#define rep(i, n) for(int i = 0, _end_ = (n); i < _end_; ++i)\n#define per(i, n) for(int i = (n) - 1; i >= 0 ; --i)\n#define forn(i, l, r) for(int i = (l), _end_ = (r); i <= _end_; ++i)\n#define nrof(i, r, l) for(int i = (r), _end_ = (l); i >= _end_; --i)\n#define FOR(a, b) for(auto (a): (b))\n#define mp make_pair\n#define mt make_tuple\n#define pb push_back\n#define X first\n#define Y second\n#define eps 1e-6\n#define pi 3.1415926535897932384626433832795\n#define SZ(x) (int)x.size()\n#define ALL(x) x.begin(), x.end()\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef double flt;\ntypedef vector<int> vi;\ntypedef vector<LL> vl;\ntypedef pair<int,int> pii;\ntypedef pair<int,LL> pil;\ntypedef pair<LL,int> pli;\ntypedef pair<LL,LL> pll;\ntypedef vector<pil> vil;\ntypedef vector<pii> vii;\ntypedef vector<pli> vli;\ntypedef vector<pll> vll;\n\nconst int iinf = 1e9 + 7;\nconst int oo = 0x3f3f3f3f;\nconst LL linf = 1ll << 60;\nconst flt dinf = 1e60;\n\ntemplate <typename T> inline void scf(T &x)\n{\n\tbool f = 0;\n\tx = 0;\n\tchar c = getchar();\n\twhile(c != '-' && (c < '0' || c > '9')) c = getchar();\n\tif(c == '-') f = 1, c = getchar();\n\twhile(c >= '0' && c <= '9') x = x * 10 + c - '0', c = getchar();\n\tif(f) x = -x;\n\treturn;\n}\n\ntemplate <typename T1, typename T2> void scf(T1 &x, T2 &y)\n{\n\tscf(x);\n\treturn scf(y);\n}\n\ntemplate <typename T1, typename T2, typename T3> void scf(T1 &x, T2 &y, T3 &z)\n{\n\tscf(x);\n\tscf(y);\n\treturn scf(z);\n}\n\ntemplate <typename T1, typename T2, typename T3, typename T4> void scf(T1 &x, T2 &y, T3 &z, T4 &w)\n{\n\tscf(x);\n\tscf(y);\n\tscf(z);\n\treturn scf(w);\n}\n\ninline char mygetchar()\n{\n\tchar c = getchar();\n\twhile(c == ' ' || c == '\\n') c = getchar();\n\treturn c;\n}\n\ntemplate <typename T> inline bool chkmax(T &x, const T &y)\n{\n\treturn y > x ? x = y, 1 : 0;\n}\n\ntemplate <typename T> inline bool chkmin(T &x, const T &y)\n{\n\treturn y < x ? x = y, 1 : 0;\n}\n\n#ifdef King_George\n#define DEBUG\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#else\n#define debug(...)\n#endif\n\n//---------------------------------------------------------head----------------------------------------------------\n\nconst int INF = 2147483647;\n\nconst int MaxN = 400;\nconst int MaxM = 79800;\n\ntemplate <class T>\ninline void tension(T &a, const T &b)\n{\n\tif (b < a)\n\t\ta = b;\n}\ntemplate <class T>\ninline void relax(T &a, const T &b)\n{\n\tif (b > a)\n\t\ta = b;\n}\ntemplate <class T>\ninline int size(const T &a)\n{\n\treturn (int)a.size();\n}\n\ninline int getint()\n{\n\tchar c;\n\twhile (c = getchar(), '0' > c || c > '9');\n\n\tint res = c - '0';\n\twhile (c = getchar(), '0' <= c && c <= '9')\n\t\tres = res * 10 + c - '0';\n\treturn res;\n}\n\nconst int MaxNX = MaxN + MaxN;\n\nstruct edge\n{\n\tint v, u, w;\n\n\tedge(){}\n\tedge(const int &_v, const int &_u, const int &_w)\n\t\t: v(_v), u(_u), w(_w){}\n};\n\nint n, m;\nedge mat[MaxNX + 1][MaxNX + 1];\n\nint n_matches;\nLL tot_weight;\nint mate[MaxNX + 1];\nint lab[MaxNX + 1];\n\nint q_n, q[MaxN];\nint fa[MaxNX + 1], col[MaxNX + 1];\nint slackv[MaxNX + 1];\n\nint n_x;\nint bel[MaxNX + 1], blofrom[MaxNX + 1][MaxNX + 1];\nvector<int> bloch[MaxNX + 1];\n\ninline int e_delta(const edge &e) // does not work inside blossoms\n{\n\treturn lab[e.v] + lab[e.u] - mat[e.v][e.u].w * 2;\n}\ninline void update_slackv(int v, int x)\n{\n\tif (!slackv[x] || e_delta(mat[v][x]) < e_delta(mat[slackv[x]][x]))\n\t\tslackv[x] = v;\n}\ninline void calc_slackv(int x)\n{\n\tslackv[x] = 0;\n\tfor (int v = 1; v <= n; v++)\n\t\tif (mat[v][x].w > 0 && bel[v] != x && col[bel[v]] == 0)\n\t\t\tupdate_slackv(v, x);\n}\n\ninline void q_push(int x)\n{\n\tif (x <= n)\n\t\tq[q_n++] = x;\n\telse\n\t{\n\t\tfor (int i = 0; i < size(bloch[x]); i++)\n\t\t\tq_push(bloch[x][i]);\n\t}\n}\ninline void set_mate(int xv, int xu)\n{\n\tmate[xv] = mat[xv][xu].u;\n\tif (xv > n)\n\t{\n\t\tedge e = mat[xv][xu];\n\t\tint xr = blofrom[xv][e.v];\n\t\tint pr = find(bloch[xv].begin(), bloch[xv].end(), xr) - bloch[xv].begin();\n\t\tif (pr % 2 == 1)\n\t\t{\n\t\t\treverse(bloch[xv].begin() + 1, bloch[xv].end());\n\t\t\tpr = size(bloch[xv]) - pr;\n\t\t}\n\n\t\tfor (int i = 0; i < pr; i++)\n\t\t\tset_mate(bloch[xv][i], bloch[xv][i ^ 1]);\n\t\tset_mate(xr, xu);\n\n\t\trotate(bloch[xv].begin(), bloch[xv].begin() + pr, bloch[xv].end());\n\t}\n}\ninline void set_bel(int x, int b)\n{\n\tbel[x] = b;\n\tif (x > n)\n\t{\n\t\tfor (int i = 0; i < size(bloch[x]); i++)\n\t\t\tset_bel(bloch[x][i], b);\n\t}\n}\n\ninline void augment(int xv, int xu)\n{\n\twhile (true)\n\t{\n\t\tint xnu = bel[mate[xv]];\n\t\tset_mate(xv, xu);\n\t\tif (!xnu)\n\t\t\treturn;\n\t\tset_mate(xnu, bel[fa[xnu]]);\n\t\txv = bel[fa[xnu]], xu = xnu;\n\t}\n}\ninline int get_lca(int xv, int xu)\n{\n\tstatic bool book[MaxNX + 1];\n\tfor (int x = 1; x <= n_x; x++)\n\t\tbook[x] = false;\n\twhile (xv || xu)\n\t{\n\t\tif (xv)\n\t\t{\n\t\t\tif (book[xv])\n\t\t\t\treturn xv;\n\t\t\tbook[xv] = true;\n\t\t\txv = bel[mate[xv]];\n\t\t\tif (xv)\n\t\t\t\txv = bel[fa[xv]];\n\t\t}\n\t\tswap(xv, xu);\n\t}\n\treturn 0;\n}\n\ninline void add_blossom(int xv, int xa, int xu)\n{\n\tint b = n + 1;\n\twhile (b <= n_x && bel[b])\n\t\tb++;\n\tif (b > n_x)\n\t\tn_x++;\n\n\tlab[b] = 0;\n\tcol[b] = 0;\n\n\tmate[b] = mate[xa];\n\n\tbloch[b].clear();\n\tbloch[b].push_back(xa);\n\tfor (int x = xv; x != xa; x = bel[fa[bel[mate[x]]]])\n\t\tbloch[b].push_back(x), bloch[b].push_back(bel[mate[x]]), q_push(bel[mate[x]]);\n\treverse(bloch[b].begin() + 1, bloch[b].end());\n\tfor (int x = xu; x != xa; x = bel[fa[bel[mate[x]]]])\n\t\tbloch[b].push_back(x), bloch[b].push_back(bel[mate[x]]), q_push(bel[mate[x]]);\n\n\tset_bel(b, b);\n\n\tfor (int x = 1; x <= n_x; x++)\n\t{\n\t\tmat[b][x].w = mat[x][b].w = 0;\n\t\tblofrom[b][x] = 0;\n\t}\n\tfor (int i = 0; i < size(bloch[b]); i++)\n\t{\n\t\tint xs = bloch[b][i];\n\t\tfor (int x = 1; x <= n_x; x++)\n\t\t\tif (mat[b][x].w == 0 || e_delta(mat[xs][x]) < e_delta(mat[b][x]))\n\t\t\t\tmat[b][x] = mat[xs][x], mat[x][b] = mat[x][xs];\n\t\tfor (int x = 1; x <= n_x; x++)\n\t\t\tif (blofrom[xs][x])\n\t\t\t\tblofrom[b][x] = xs;\n\t}\n\tcalc_slackv(b);\n}\ninline void expand_blossom1(int b) // lab[b] == 1\n{\n\tfor (int i = 0; i < size(bloch[b]); i++)\n\t\tset_bel(bloch[b][i], bloch[b][i]);\n\n\tint xr = blofrom[b][mat[b][fa[b]].v];\n\tint pr = find(bloch[b].begin(), bloch[b].end(), xr) - bloch[b].begin();\n\tif (pr % 2 == 1)\n\t{\n\t\treverse(bloch[b].begin() + 1, bloch[b].end());\n\t\tpr = size(bloch[b]) - pr;\n\t}\n\n\tfor (int i = 0; i < pr; i += 2)\n\t{\n\t\tint xs = bloch[b][i], xns = bloch[b][i + 1];\n\t\tfa[xs] = mat[xns][xs].v;\n\t\tcol[xs] = 1, col[xns] = 0;\n\t\tslackv[xs] = 0, calc_slackv(xns);\n\t\tq_push(xns);\n\t}\n\tcol[xr] = 1;\n\tfa[xr] = fa[b];\n\tfor (int i = pr + 1; i < size(bloch[b]); i++)\n\t{\n\t\tint xs = bloch[b][i];\n\t\tcol[xs] = -1;\n\t\tcalc_slackv(xs);\n\t}\n\n\tbel[b] = 0;\n}\ninline void expand_blossom_final(int b) // at the final stage\n{\n\tfor (int i = 0; i < size(bloch[b]); i++)\n\t{\n\t\tif (bloch[b][i] > n && lab[bloch[b][i]] == 0)\n\t\t\texpand_blossom_final(bloch[b][i]);\n\t\telse\n\t\t\tset_bel(bloch[b][i], bloch[b][i]);\n\t}\n\tbel[b] = 0;\n}\n\ninline bool on_found_edge(const edge &e)\n{\n\tint xv = bel[e.v], xu = bel[e.u];\n\tif (col[xu] == -1)\n\t{\n\t\tint nv = bel[mate[xu]];\n\t\tfa[xu] = e.v;\n\t\tcol[xu] = 1, col[nv] = 0;\n\t\tslackv[xu] = slackv[nv] = 0;\n\t\tq_push(nv);\n\t}\n\telse if (col[xu] == 0)\n\t{\n\t\tint xa = get_lca(xv, xu);\n\t\tif (!xa)\n\t\t{\n\t\t\taugment(xv, xu), augment(xu, xv);\n\t\t\tfor (int b = n + 1; b <= n_x; b++)\n\t\t\t\tif (bel[b] == b && lab[b] == 0)\n\t\t\t\t\texpand_blossom_final(b);\n\t\t\treturn true;\n\t\t}\n\t\telse\n\t\t\tadd_blossom(xv, xa, xu);\n\t}\n\treturn false;\n}\n\nbool match()\n{\n\tfor (int x = 1; x <= n_x; x++)\n\t\tcol[x] = -1, slackv[x] = 0;\n\n\tq_n = 0;\n\tfor (int x = 1; x <= n_x; x++)\n\t\tif (bel[x] == x && !mate[x])\n\t\t\tfa[x] = 0, col[x] = 0, slackv[x] = 0, q_push(x);\n\tif (q_n == 0)\n\t\treturn false;\n\n\twhile (true)\n\t{\n\t\tfor (int i = 0; i < q_n; i++)\n\t\t{\n\t\t\tint v = q[i];\n\t\t\tfor (int u = 1; u <= n; u++)\n\t\t\t\tif (mat[v][u].w > 0 && bel[v] != bel[u])\n\t\t\t\t{\n\t\t\t\t\tint d = e_delta(mat[v][u]);\n\t\t\t\t\tif (d == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (on_found_edge(mat[v][u]))\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\telse if (col[bel[u]] == -1 || col[bel[u]] == 0)\n\t\t\t\t\t\tupdate_slackv(v, bel[u]);\n\t\t\t\t}\n\t\t}\n\n\t\tint d = INF;\n\t\tfor (int v = 1; v <= n; v++)\n\t\t\tif (col[bel[v]] == 0)\n\t\t\t\ttension(d, lab[v]);\n\t\tfor (int b = n + 1; b <= n_x; b++)\n\t\t\tif (bel[b] == b && col[b] == 1)\n\t\t\t\ttension(d, lab[b] / 2);\n\t\tfor (int x = 1; x <= n_x; x++)\n\t\t\tif (bel[x] == x && slackv[x])\n\t\t\t{\n\t\t\t\tif (col[x] == -1)\n\t\t\t\t\ttension(d, e_delta(mat[slackv[x]][x]));\n\t\t\t\telse if (col[x] == 0)\n\t\t\t\t\ttension(d, e_delta(mat[slackv[x]][x]) / 2);\n\t\t\t}\n\n\t\tfor (int v = 1; v <= n; v++)\n\t\t{\n\t\t\tif (col[bel[v]] == 0)\n\t\t\t\tlab[v] -= d;\n\t\t\telse if (col[bel[v]] == 1)\n\t\t\t\tlab[v] += d;\n\t\t}\n\t\tfor (int b = n + 1; b <= n_x; b++)\n\t\t\tif (bel[b] == b)\n\t\t\t{\n\t\t\t\tif (col[bel[b]] == 0)\n\t\t\t\t\tlab[b] += d * 2;\n\t\t\t\telse if (col[bel[b]] == 1)\n\t\t\t\t\tlab[b] -= d * 2;\n\t\t\t}\n\n\t\tq_n = 0;\n\t\tfor (int v = 1; v <= n; v++)\n\t\t\tif (lab[v] == 0) // all unmatched vertices' labels are zero! cheers!\n\t\t\t\treturn false;\n\t\tfor (int x = 1; x <= n_x; x++)\n\t\t\tif (bel[x] == x && slackv[x] && bel[slackv[x]] != x && e_delta(mat[slackv[x]][x]) == 0)\n\t\t\t{\n\t\t\t\tif (on_found_edge(mat[slackv[x]][x]))\n\t\t\t\t\treturn true;\n\t\t\t}\n\t\tfor (int b = n + 1; b <= n_x; b++)\n\t\t\tif (bel[b] == b && col[b] == 1 && lab[b] == 0)\n\t\t\t\texpand_blossom1(b);\n\t}\n\treturn false;\n}\n\nvoid calc_max_weight_match()\n{\n\tfor (int v = 1; v <= n; v++)\n\t\tmate[v] = 0;\n\n\tn_x = n;\n\tn_matches = 0;\n\ttot_weight = 0;\n\n\tbel[0] = 0;\n\tfor (int v = 1; v <= n; v++)\n\t\tbel[v] = v, bloch[v].clear();\n\tfor (int v = 1; v <= n; v++)\n\t\tfor (int u = 1; u <= n; u++)\n\t\t\tblofrom[v][u] = v == u ? v : 0;\n\n\tint w_max = 0;\n\tfor (int v = 1; v <= n; v++)\n\t\tfor (int u = 1; u <= n; u++)\n\t\t\trelax(w_max, mat[v][u].w);\n\tfor (int v = 1; v <= n; v++)\n\t\tlab[v] = w_max;\n\n\twhile (match())\n\t\tn_matches++;\n\n\tfor (int v = 1; v <= n; v++)\n\t\tif (mate[v] && mate[v] < v)\n\t\t\ttot_weight += mat[v][mate[v]].w;\n}\n\nconst int maxn = 210;\n\nconst int maxm = 1e7 + 10;\n\ninline bool isp(int n)\n{\n\tfor(int i = 2; i * i <= n; ++i) if(n % i == 0) return 0;\n\treturn 1;\n}\n\nint calc(int n)\n{\n\tif(n % 2 == 0) return 2;\n\tif(n == 1) return 3;\n\tif(isp(n)) return 1;\n\treturn 3;\n}\n\nbool f[maxm];\nint a[maxn];\nint g[maxn][maxn];\n\nint main()\n{\n\tscf(n);\n\twhile(n--)\n\t{\n\t\tint x;\n\t\tscf(x);\n\t\tf[x] = 1;\n\t}\n\tn = 0;\n\tfor(int i = 1; i <= 10000001; ++i) if(f[i] ^ f[i - 1]) a[n++] = i;\n\trep(i, n) rep(j, i) g[i][j] = g[j][i] = 4 - calc(abs(a[i] - a[j]));\n#ifdef DEBUG\n\trep(i, n) printf(\"%d \", a[i]); puts(\"\");\n\tputs(\"\");\n\trep(i, n)\n\t{\n\t\trep(j, n) printf(\"%d \", g[i][j]);\n\t\tputs(\"\");\n\t}\n#endif\n\t\n\tfor (int v = 1; v <= n; v++)\n\t\tfor (int u = 1; u <= n; u++)\n\t\t\tmat[v][u] = edge(v, u, 0);\n\t\n\tforn(u, 1, n) forn(v, 1, u - 1)\n\t{\n\t\tmat[u][v].w = mat[v][u].w = g[u - 1][v - 1];\n\t}\n\n\tcalc_max_weight_match();\n\n\tprintf(\"%d\\n\", n * 2 - tot_weight);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n\nint N,x[101],D[101][101];\nbool isp[10000001];\n\nvoid mn(int &a, int b)\n{\n\tif (a > b)\n\t\ta = b;\n}\n\nint main()\n{\n\tscanf (\"%d\",&N);\n\tfor (int i=0;i<N;i++) scanf (\"%d\",&x[i]);\n\n\tfor (int i=2;i*i<=10000000;i++) if (!isp[i]){\n\t\tfor (int j=i*i;j<=10000000;j+=i) isp[j] = 1;\n\t}\n\tisp[0] = isp[1] = isp[2] = 1;\n\n\tfor (int l=0;l<N;l++){\n\t\tif (l == N-1){\n\t\t\tint c = 0;\n\t\t\tc++;\n\t\t}\n\t\tfor (int i=0,j=l;j<N;i++,j++){\n\t\t\tif (l == 0) D[i][j] = 3;\n\t\t\telse{\n\t\t\t\tD[i][j] = 0x7fffffff;\n\t\t\t\tfor (int k=i;k<j;k++) mn(D[i][j],D[i][k]+D[k+1][j]);\n\t\t\t\tif (x[j] - x[i] == j - i){\n\t\t\t\t\tif (!isp[j-i+1]){D[i][j] = 1; continue;}\n\t\t\t\t\telse{\n\t\t\t\t\t\tif ((j - i + 1) % 2) mn(D[i][j],3);\n\t\t\t\t\t\telse mn(D[i][j],2);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfor (int k=i;k<j;k++) if (x[k] - x[i] == k - i){\n\t\t\t\t\tfor (int l=j;l>k;l--) if (x[j] - x[l] == j - l){\n\t\t\t\t\t\tbool ispl = !isp[x[j]-x[i]+1];\n\t\t\t\t\t\tbool isps = !isp[x[l]-x[k]-1];\n\t\t\t\t\t\tbool nispl = (x[j] - x[i]) % 2 && x[j] - x[i] - 1 > 4;\n\t\t\t\t\t\tbool nisps = (x[l] - x[k]) % 2 && x[l] - x[k] - 1 > 4;\n\t\t\t\t\t\tif (ispl && isps) mn(D[i][j],D[k+1][l-1]+2);\n\t\t\t\t\t\tif (ispl && nisps) mn(D[i][j],D[k+1][l-1]+3);\n\t\t\t\t\t\tif (nispl && isps) mn(D[i][j],D[k+1][l-1]+3);\n\t\t\t\t\t\tif (nispl && nisps) mn(D[i][j],D[k+1][l-1]+4);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf (\"%d\\n\",D[0][N-1]);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define rg register\nusing namespace std;\nconst int MAXN=1010;\nstruct gao{   int u,v,Next;   }Edge[MAXN<<1];\nint n,Lo,Le,Seq[10000010],Odd[MAXN],Even[MAXN];\nint Ans,Es,Ps,First[MAXN],Match[MAXN],Vis[MAXN];\ninline int Read()\n{   rg int a=0,c=1;   rg char b=getchar();\n\twhile(b!='-'&&(b<'0'||b>'9'))b=getchar();\n\tif(b=='-')c=-1,b=getchar();\n\twhile(b>='0'&&b<='9')a=a*10+b-48,b=getchar();\n\treturn a*c;\n}\ninline void Link(rg int u,rg int v)\n{   Edge[++Es]=(gao){u,v,First[u]},First[u]=Es;   }\ninline int Abs(rg int A){   return A<0?-A:A;   }\ninline bool Judge(rg int Num)\n{   if(Num%2==0||Num<=2) return 0;\n\tfor(rg int i=3,End=sqrt(Num);i<=End;i+=2)\n\t\tif(Num%i==0) return 0;\n\treturn 1;\n}\ninline bool Couple(rg int Now,rg int Sign)\n{   for(rg int i=First[Now];i!=-1;i=Edge[i].Next)\n\t{   rg int v=Edge[i].v;   if(Vis[v]==Sign) continue ;\n\t\tVis[v]=Sign;\n\t\tif(!Match[v]||Couple(Match[v],Sign)) return Match[v]=Now,Match[Now]=v,1;\n\t}\n\treturn 0;\n}\nint main()\n{   scanf(\"%d\",&n);\n\tmemset(First,-1,sizeof(First));\n\tfor(rg int i=1;i<=n;i++) Seq[Read()]=1;\n\tfor(rg int i=1e7+1;i>=1;i--) Seq[i]=Seq[i]!=Seq[i-1];\n\tfor(rg int i=1;i<=1e7+1;i++) if(Seq[i]) i%2?Odd[++Lo]=i:Even[++Le]=i;\n\tif((Lo+Le)%2) return puts(\"0\");\n\tfor(rg int i=1;i<=Lo;i++)\n\t\tfor(rg int j=1;j<=Le;j++) if(Judge(Abs(Odd[i]-Even[j]))) Link(i,Lo+j),Link(Lo+j,i);\n\tfor(rg int i=1;i<=Lo;i++) if(!Match[i]) Ps+=Couple(i,i);\n\tAns=Ps+(Lo-Ps)/2*2+(Le-Ps)/2*2+((Lo-Ps)%2)*3,printf(\"%d\\n\",Ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n\n#include <iostream>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <unordered_set>\n#include <queue>\n#include <set>\n#include <algorithm>\n#include <numeric>\n#include <list>\nusing namespace std;\n\nusing QWORD  = uint64_t;\nusing SQWORD = int64_t;\nusing DWORD  = uint32_t;\nusing SDWORD = int32_t;\nusing WORD   = uint16_t;\nusing SWORD  = int16_t;\nusing BYTE   = uint8_t;\nusing SBYTE  = int8_t;\nusing DOUBLE = double;\nusing FLOAT  = float;\n\n#define MIN_SDWORD (-2147483648)\n#define MAX_SDWORD (2147483647)\n#define MIN_SBYTE (-128)\n#define MAX_SBYTE (127)\n\n#define MIN_SQWORD (0x8000000000000000)\n#define MAX_SQWORD (0x7FFFFFFFFFFFFFFF)\n\n#define MAX_QWORD  (0xFFFFFFFFFFFFFFFF)\n#define MAX_DWORD  (0xFFFFFFFF)\n#define MAX_WORD   (0xFFFF)\n#define MAX_BYTE   (0xFF)\n\n#define MAX_DOUBLE      (1.0e+308)\n#define DOUBLE_EPS      (1.0e-12)\n#define MIN_DOUBLE_N    (-1.0e+308)\n\n#define ArrayLength(a)  (sizeof(a) / sizeof(a[0]))\n\nstatic inline DOUBLE MAX(DOUBLE a, DOUBLE b) { return a > b ? a : b; }\nstatic inline QWORD MAX(QWORD a, QWORD b) { return a > b ? a : b; }\nstatic inline DWORD MAX(DWORD a, DWORD b) { return a > b ? a : b; }\nstatic inline SDWORD MAX(SDWORD a, SDWORD b) { return a > b ? a : b; }\nstatic inline DOUBLE MIN(DOUBLE a, DOUBLE b) { return a < b ? a : b; }\nstatic inline QWORD MIN(QWORD a, QWORD b) { return a < b ? a : b; }\nstatic inline DWORD MIN(DWORD a, DWORD b) { return a < b ? a : b; }\nstatic inline SDWORD MIN(SDWORD a, SDWORD b) { return a < b ? a : b; }\nstatic inline DOUBLE ABS(DOUBLE a) { return 0 < a ? a : -a; };\n\n#define BYTE_BITS   (8)\n#define WORD_BITS   (16)\n#define DWORD_BITS  (32)\n#define QWORD_BITS  (64)\n\nstatic inline void inputStringSpSeparated(char *pcStr)\n{\n    char *pcCur = pcStr;\n    for (;;) {\n        char c = getchar();\n        if (('\\n' == c) || (EOF == c) || (' ' == c)) {\n            break;\n        }\n        *pcCur = c;\n        pcCur++;\n    }\n    *pcCur = '\\0';\n}\n\nstatic inline void inputString(char *pcStr)\n{\n    char *pcCur = pcStr;\n    for (;;) {\n        char c = getchar();\n        if (('\\n' == c) || (EOF == c)) {\n            break;\n        }\n        *pcCur = c;\n        pcCur++;\n    }\n    *pcCur = '\\0';\n}\n\n\nstatic inline SQWORD inputSQWORD(void)\n{\n    SQWORD sqNumber = 0;\n    SQWORD sqMultiplier = 1;\n    bool bRead = false;\n    for (;;) {\n        char c = getchar();\n        if (!bRead) {\n            if ('-' == c) {\n                sqMultiplier = -1;\n            }\n        }\n        if (('0' <= c) && (c <= '9')) {\n            sqNumber *= 10LL;\n            sqNumber += (SQWORD)(c - '0');\n            bRead = true;\n        } else {\n            if (bRead) {\n                return sqNumber * sqMultiplier;\n            }\n        }\n    }\n}\n\n\nstatic inline SDWORD inputSDWORD(void)\n{\n    SDWORD lNumber = 0;\n    SDWORD lMultiplier = 1;\n    bool bRead = false;\n    for (;;) {\n        char c = getchar();\n        if (!bRead) {\n            if ('-' == c) {\n                lMultiplier = -1;\n            }\n        }\n        if (('0' <= c) && (c <= '9')) {\n            lNumber *= 10;\n            lNumber += (c - '0');\n            bRead = true;\n        } else {\n            if (bRead) {\n                return lNumber * lMultiplier;\n            }\n        }\n    }\n}\n\nstatic inline DOUBLE inputFP(void)\n{\n    DOUBLE dInt = 0.0;\n    DOUBLE dFrac = 0.0;\n    DOUBLE dMultiplier = 1.0;\n    DWORD dwFpCnt = 0;\n    DOUBLE *pdCur = &dInt;\n    bool bRead = false;\n    for (;;) {\n        char c = getchar();\n        if (!bRead) {\n            if ('-' == c) {\n                dMultiplier = -1;\n            }\n        }\n        if ('.' == c) {\n            pdCur = &dFrac;\n        } else if (('0' <= c) && (c <= '9')) {\n            (*pdCur) *= 10;\n            (*pdCur) += (DOUBLE)(c - '0');\n            bRead = true;\n            if (pdCur == &dFrac) {\n                dwFpCnt++;\n            }\n        } else {\n            if (bRead) {\n                return dMultiplier * (dInt + dFrac / (pow((DOUBLE)10.0 , (DOUBLE)dwFpCnt)));\n            }\n        }\n    }\n}\n\n\n/**\n *  mod による操作ライブラリ\n */\n\n#define ANS_MOD (1000000007LL)\n \nstatic SQWORD addMod(SQWORD x, SQWORD y)\n{ \n    return (x + y) % ANS_MOD;\n}\n \nstatic SQWORD subMod(SQWORD x, SQWORD y)\n{\n    return (x - y + ANS_MOD) % ANS_MOD;\n}\n \nstatic SQWORD mulMod(SQWORD x, SQWORD y) \n{\n    return (x * y) % ANS_MOD;\n}\n \nstatic SQWORD powMod(SQWORD x, SQWORD e) {\n    SQWORD v = 1;\n    for (; e; x = mulMod(x, x), e >>= 1) {\n        if (e & 1) {\n            v = mulMod(v, x);\n        }\n    }\n    return v;\n}\n \nstatic SQWORD divMod(SQWORD x, SQWORD y)\n{\n    return mulMod(x, powMod(y, ANS_MOD - 2));\n}\n \n \nstatic SQWORD combMod(SQWORD n, SQWORD k)\n{\n    SQWORD v=1;\n    for(SQWORD i=1; i<=k; i++) {\n        v = divMod(mulMod(v, n-i+1),i);\n    } \n    return v;\n}\n\n/*----------------------------------------------*/\n\ntypedef struct {\n    SDWORD lTo;\n    SQWORD sqCap;\n    SQWORD sqCost;\n    SDWORD lRev;\n} ST_EDGE;\n\n#define MAX_V   (402)\n\nstruct Flow {\nprivate:\n    vector<ST_EDGE> avGraph[MAX_V];\n    SDWORD  alDimsFrom[MAX_V];\n    SDWORD  alDimsTo[MAX_V];\n    SQWORD  sqEdgeNum;\n    SQWORD  asqDist[MAX_V];\n    SDWORD  alPrevV[MAX_V];   \n    SDWORD  alPrevEdge[MAX_V];      /*直前の頂点と辺 */\n\n    SDWORD  alDinic_Level[MAX_V];\n    SDWORD  alDinic_Iter[MAX_V];\n\npublic:\n    Flow() {\n        for (auto v: avGraph) {\n            v.clear();\n        }\n        memset(alDimsFrom, 0, sizeof(alDimsFrom));\n        memset(alDimsTo, 0, sizeof(alDimsTo));\n        memset(asqDist, 0, sizeof(asqDist));\n        memset(alPrevV, 0, sizeof(alPrevV)); \n        memset(alPrevEdge, 0, sizeof(alPrevEdge));\n        memset(alDinic_Level, 0, sizeof(alDinic_Level));\n        memset(alDinic_Iter, 0, sizeof(alDinic_Iter));\n    }\n    void addEdge(SDWORD lFrom, SDWORD lTo, SQWORD sqCap, SQWORD sqCost) {\n//        printf(\"%d ----[%lld] ----> %d\\n\", lFrom, sqCap, lTo);\n        \n        alDimsFrom[lFrom]++;\n        alDimsTo[lTo]++;\n        avGraph[lFrom].push_back((ST_EDGE){lTo, sqCap, sqCost, (SDWORD)(avGraph[lTo].size())});\n        avGraph[lTo].push_back((ST_EDGE){lFrom, 0, -sqCost, (SDWORD)(avGraph[lFrom].size() - 1)});\n    }\n\n    SDWORD minCostFlow(SDWORD lStart, SDWORD lTarget, SQWORD sqFlow)\n    {\n        SQWORD sqRes = 0;\n        SQWORD sqFlowRest = sqFlow;\n        while (0 < sqFlowRest) {\n            /* Bellman-Ford Method */\n            fill(asqDist, asqDist + ArrayLength(asqDist), MAX_SDWORD);\n            asqDist[lStart] = 0;\n            bool bIsUpdate = true;\n            while (bIsUpdate) {\n                bIsUpdate = false;\n                for (SDWORD lV = 0; lV < MAX_V; lV++) {\n                    for (SDWORD lIdx = 0; lIdx < avGraph[lV].size(); lIdx++) {\n                        ST_EDGE &stE = avGraph[lV][lIdx];\n                        if ((asqDist[lV] != MAX_SDWORD)\n                                && (0 < stE.sqCap)\n                                && (asqDist[lV] + stE.sqCost < asqDist[stE.lTo])) {\n                            asqDist[stE.lTo] = asqDist[lV] + stE.sqCost;\n                            alPrevV[stE.lTo] = lV;\n                            alPrevEdge[stE.lTo] = lIdx;\n                            bIsUpdate = true;\n                        }\n                    }\n                }\n            }\n            if (asqDist[lTarget] == MAX_SDWORD) {\n                return -1;\n            }\n\n            SQWORD sqAddFlow = MAX_SQWORD;\n            for (SDWORD lV = lTarget; lV != lStart; lV = alPrevV[lV]) {\n                sqAddFlow = min(sqAddFlow, avGraph[alPrevV[lV]][alPrevEdge[lV]].sqCap);\n            }\n            sqFlowRest -= sqAddFlow;\n            sqRes += sqAddFlow * asqDist[lTarget];      // 後で目的変数は書き換える\n            for (SDWORD lV = lTarget; lV != lStart; lV = alPrevV[lV]) {\n                ST_EDGE &stE = avGraph[alPrevV[lV]][alPrevEdge[lV]];\n                stE.sqCap -= sqAddFlow;\n                avGraph[lV][stE.lRev].sqCap += sqAddFlow;\n            }\n        }\n        return sqRes;\n    }\n\nprivate:\n    SQWORD maxFlowDinicBfs(SDWORD lS)\n    {\n        memset(alDinic_Level, -1, sizeof(alDinic_Level));\n        queue<SDWORD> queSearch;\n        alDinic_Level[lS] = 0;\n        queSearch.push(lS);\n        while (!queSearch.empty()) {\n            SDWORD lV = queSearch.front();\n            queSearch.pop();\n            for (SDWORD lIdx = 0; lIdx < avGraph[lV].size(); lIdx++) {\n                ST_EDGE &stE = avGraph[lV][lIdx];\n                if ((0 < stE.sqCap) && (alDinic_Level[stE.lTo] < 0)) {\n                    alDinic_Level[stE.lTo] = alDinic_Level[lV] + 1;\n                    queSearch.push(stE.lTo);\n                }\n            }\n        }\n\n        return 0;\n    }\n\n    SQWORD maxFlowDinicDfs(SDWORD lV, SDWORD lT, SQWORD sqF)\n    {\n        if (lV == lT) {\n            return sqF;\n        }\n        for (SDWORD &lI = alDinic_Iter[lV]; lI < avGraph[lV].size(); lI++) {\n            ST_EDGE &stE = avGraph[lV][lI];\n            if ((0 < stE.sqCap) && (alDinic_Level[lV] < alDinic_Level[stE.lTo])) {\n                SQWORD sqDiffFlow = maxFlowDinicDfs(stE.lTo, lT, min(sqF, stE.sqCap));\n                if (0 < sqDiffFlow) {\n                    stE.sqCap -= sqDiffFlow;\n                    avGraph[stE.lTo][stE.lRev].sqCap += sqDiffFlow;\n                    return sqDiffFlow;\n                }\n            }\n        }\n        return 0;\n    }\n\npublic:\n    SQWORD MaxFlow(SDWORD lStart, SDWORD lTarget)\n    {\n        SQWORD sqFlow = 0LL;\n        for (;;) {\n            maxFlowDinicBfs(lStart);\n            if (alDinic_Level[lTarget] < 0) {\n                return sqFlow;\n            }\n            memset(alDinic_Iter, 0, sizeof(alDinic_Iter));\n            while (1) {\n                SQWORD sqDiffFlow = maxFlowDinicDfs(lStart, lTarget, MAX_SQWORD);\n                sqFlow += sqDiffFlow;\n                if (0LL == sqDiffFlow) {\n                    break;\n                }\n            }\n        }\n    }\n\n    SQWORD getFlow(SDWORD lPnt, bool bFrom)\n    {\n        SQWORD sqCapSum = 0; \n        for (auto e: avGraph[lPnt]) {\n            sqCapSum += e.sqCap;\n        }\n        if (bFrom) {\n            return alDimsFrom[lPnt] - sqCapSum;\n        } else {\n            return alDimsTo[lPnt] - sqCapSum;\n        }\n    }\n};\n\n/*----------------------------------------------*/\n\nstatic void getPrimes(vector<SDWORD> &vlPrimes, SDWORD lMax)\n{\n    /* lSearchMax と ループ内の *2 の関係から、入力は3以上とすること */\n    if (!(1 <= lMax)) {\n        printf(\"Oops!\");\n        return;\n    }\n\n    /* 素数のリストを作る */\n    vector<bool> vbIsPrime(lMax + 1, true);\n    SDWORD lSearchMax = sqrt(lMax) + 1;\n    vbIsPrime[0] = false;\n    vbIsPrime[1] = false;\n    for (SDWORD lPrime = 2; lPrime < vbIsPrime.size(); lPrime++) {\n        if (vbIsPrime[lPrime]) {\n            vlPrimes.emplace_back(lPrime);\n            if (lPrime <= lSearchMax) {\n                for (SDWORD lCurNum = lPrime * 2; lCurNum <= lMax; lCurNum += lPrime) {\n                    vbIsPrime[lCurNum] = false;\n                }\n            }\n        }\n    }\n}    \n\n/*----------------------------------------------*/\n\n#define PNT_NO_START    (0)\n#define PNT_NO_OFFSET   (200)\n#define PNT_NO_TARGET   (401)\n#define FLOW_OFFSET     (1000000000)\n#define CAPACITY_INF    (1000000001)\n#define DUMMY_COST      (1)\n\nint main(void)\n{\n    SQWORD sqN = inputSQWORD();\n\n    Flow solverFlow;\n    vector<SQWORD> vsqA;\n    vector<SQWORD> vsqB;\n    vector<SDWORD> vlPrimes;\n\n    getPrimes(vlPrimes, 1e7 + 1);\n    vlPrimes.erase(find(vlPrimes.begin(), vlPrimes.end(), 2));\n\n    for (SQWORD sqIdx = 0; sqIdx < sqN; sqIdx++) {\n        SQWORD sqA = inputSQWORD();\n        vsqA.emplace_back(sqA);\n    }\n\n#if 1\n    for (auto it = vsqA.begin(); it != vsqA.end(); ++it) {\n//        printf(\"%lld %lld\\n\", *it, *(it - 1));\n        if (it == vsqA.begin()) {\n            vsqB.emplace_back(*it);\n        } else {\n            if ((*it) - 1 != *(it - 1)) {\n                vsqB.emplace_back(*it);\n            }\n        }\n        if (it == vsqA.end() - 1) {\n            vsqB.emplace_back((*it) + 1);\n        } else {\n            if ((*it) + 1 != *(it + 1)) {\n                vsqB.emplace_back((*it) + 1);\n            }\n        }\n    }\n#else\n    vsqB = vsqA;\n#endif\n\n    vector<SQWORD> vsqCOdd;\n    vector<SQWORD> vsqCEven;\n    \n    unordered_map<SQWORD, SQWORD> mapCEven, mapCOdd;\n\n    SQWORD sqIdx = 1;\n    for (auto b: vsqB) {\n        if (0 == b % 2) {\n            vsqCEven.emplace_back(b);\n            mapCEven[b] = sqIdx;\n        } else {\n            vsqCOdd.emplace_back(b);\n            mapCOdd[b] = sqIdx;\n        }\n        sqIdx++;\n    }\n\n    /* 二部マッチング */\n    for (auto c: vsqCEven) {\n        solverFlow.addEdge(PNT_NO_START, mapCEven[c], 1, DUMMY_COST);\n    }\n    for (auto c: vsqCEven) {\n        solverFlow.addEdge(mapCOdd[c] + PNT_NO_OFFSET, PNT_NO_TARGET, 1, DUMMY_COST);\n    }\n\n    for (auto p: vlPrimes) {\n        for (auto c: vsqCEven) {\n            auto it = lower_bound(vsqCOdd.begin(), vsqCOdd.end(), c + p);\n            if (it != vsqCOdd.end()) {\n                if (*it == c + p) {\n                    if (c + p < 1e7 + 1) {\n                        solverFlow.addEdge(mapCEven[c], mapCOdd[c + p] + PNT_NO_OFFSET, 1, DUMMY_COST);\n                    }\n                }\n            }\n        }\n        for (auto c: vsqCOdd) {\n            auto it = lower_bound(vsqCEven.begin(), vsqCEven.end(), c + p);\n            if (it != vsqCEven.end()) {\n                if (*it == c + p) {\n                    if (c + p < 1e7 + 1) {\n                        solverFlow.addEdge(mapCEven[c + p], mapCOdd[c] + PNT_NO_OFFSET, 1, DUMMY_COST);\n                    }\n                }\n            }\n        }\n    }\n\n\n\n    SQWORD sqMaxFlow = solverFlow.MaxFlow(PNT_NO_START, PNT_NO_TARGET);\n    SQWORD vsqCRestEven = 0;\n    SQWORD vsqCRestOdd = 0;\n    for (auto c: vsqCEven) {\n        SQWORD sqFlow = solverFlow.getFlow(mapCEven[c], true);\n        if (0 == sqFlow) {\n            vsqCRestEven++;\n        }\n    }\n    for (auto c: vsqCOdd) {\n        SQWORD sqFlow = solverFlow.getFlow(mapCOdd[c] + PNT_NO_OFFSET, false);\n        if (0 == sqFlow) {\n            vsqCRestOdd++;\n        }\n    }\n\n    SQWORD sqAns = sqMaxFlow;    \n    sqAns += (vsqCRestEven / 2) * 2;\n    sqAns += (vsqCRestOdd / 2) * 2;\n    if (0 < (vsqCRestEven %  2)) {\n        sqAns += 3;\n    }\n\n    printf(\"%lld\\n\", sqAns);\n\n    return 0;\n}\n/*------------------------------------------*/\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <iostream>\n#include <algorithm>\n#define fo(i,a,b) for(int i=a;i<=b;i++)\n#define fod(i,a,b) for(int i=a;i>=b;i--)\n#define N 2005\nusing namespace std;\nint l[N],n,a[N],r[N],w[N],pr[5000005],f[N],a1[N][N];\nbool bz[20000005],bp[N];\nvoid prp()\n{\n\tbz[1]=1;\n\tbz[0]=1;\n\tfo(i,2,20000000)\n\t{\n\t\tif(!bz[i]) pr[++pr[0]]=i;\n\t\tfor(int j=1;j<=pr[0]&&i*pr[j]<=20000000;j++)\n\t\t{\n\t\t\tbz[i*pr[j]]=1;\n\t\t\tif(i%pr[j]==0) break;\n\t\t}\n\t}\n\tbz[2]=1;\n}\nbool find(int k)\n{\n\tfo(i,1,a1[k][0])\n\t{\n\t\tint p=a1[k][i];\n\t\tif(!bp[p])\n\t\t{\n\t\t\tbp[p]=1;\n\t\t\tif(!f[p]||find(f[p])) \n\t\t\t{\n\t\t\t\tf[p]=k;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nint main()\n{\n\tcin>>n;\n\tprp();\n\tfo(i,1,n) scanf(\"%d\",&a[i]);\n\tsort(a+1,a+n+1);\n\tfo(i,1,n) \n\t{\n\t\tif(i==1||a[i-1]!=a[i]-1) w[++w[0]]=a[i];\n\t\tif(a[i+1]!=a[i]+1) w[++w[0]]=a[i]+1;\n\t}\n\tsort(w+1,w+w[0]+1);\n\tfo(i,1,w[0]) \n\t\tif(w[i]%2==0) l[++l[0]]=w[i];\n\t\telse r[++r[0]]=w[i];\n\tfo(i,1,l[0])\n\t{\n\t\tfo(j,1,r[0])\n\t\t{\n\t\t\tif(!bz[abs(l[i]-r[j])]) a1[i][++a1[i][0]]=j;\n\t\t}\n\t}\n\tlong long s=0;\n\tfo(i,1,l[0]) \n\t{\n\t\tmemset(bp,0,sizeof(bp));\n\t\tif(find(i)) s++;\n\t}\n\tprintf(\"%lld\",s+2*(long long)((l[0]-s)/2)+2*(long long)((r[0]-s)/2)+3*(long long)((l[0]-s)%2));\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <map>\n#include <string>\n#include <cstring>\n#include <stack>\n#include <queue>\n#include <cmath>\n#include <ctime>\n#include <utility>\nusing namespace std;\n#define REP(I,N) for (I=0;I<N;I++)\n#define rREP(I,N) for (I=N-1;I>=0;I--)\n#define rep(I,S,N) for (I=S;I<N;I++)\n#define rrep(I,S,N) for (I=N-1;I>=S;I--)\n#define FOR(I,S,N) for (I=S;I<=N;I++)\n#define rFOR(I,S,N) for (I=N;I>=S;I--)\ntypedef unsigned long long ull;\ntypedef long long ll;\n//const int INF=0x3f3f3f3f;\nconst int INF=1e9;\nconst ll INFF=0x3f3f3f3f3f3f3f3fll;\nconst ll M=1e9+7;\nconst ll maxn=1e5+7;\nconst int MAXN=1005;\nconst int MAX=2e5+5;\nconst int MAX_N=MAX;\nconst ll MOD=1e9+7;\n//const double eps=0.00000001;\n//ll gcd(ll a,ll b){return b?gcd(b,a%b):a;}\ntemplate<typename T>inline T abs(T a) {return a>0?a:-a;}\ninline ll powMM(ll a,ll b){\n    ll ret=1;\n    a%=M;\n//    b%=M;\n    while (b){\n        if (b&1) ret=ret*a%M;\n        b>>=1;\n        a=a*a%M;\n    }\n    return ret;\n}\nvoid open()\n{\n    freopen(\"1007.in\",\"r\",stdin);\n    freopen(\"out.txt\",\"w\",stdout);\n}\n\nint V;//顶点数\nconst int MAX_V=MAX;\nvector<int> G[MAX_V];//图的邻接表表示\nint match[MAX_V];//所匹配的顶点\nbool used[MAX_V];//DFS中用到的访问标记\n//向图中增加一条连接u和v的边\nvoid add_edge(int u,int v)\n{\n    G[u].push_back(v);\n    G[v].push_back(u);\n}\n//通过DFS寻找增广路\nbool dfs(int v)\n{\n    used[v]=true;\n    for(int i=0;i<G[v].size();i++)\n    {\n        int u=G[v][i],w=match[u];\n        if(w<0||(!used[w]&&dfs(w)))\n        {\n            match[v]=u;\n            match[u]=v;\n            return true;\n        }\n    }\n    return false;\n}\n//求解二分图的最大匹配\nint bipartite_matching()\n{\n    int res=0;\n    memset(match,-1,sizeof(match));\n    for(int v=0;v<V;v++)\n    {\n        if(match[v]<0)\n        {\n            memset(used,0,sizeof(used));\n            if(dfs(v))\n                ++res;\n        }\n    }\n    return res;//返回的是总点数的一半\n}\nbool isprime(int x)\n{\n    if(x==1)\n        return false;\n    for(int i=2;i*i<=x;i++)\n    {\n        if(x%i==0)\n            return false;\n    }\n    return true;\n}\nint n;\nint a[(int)1e7+2];\nvector<int>pos[2];\nint main()\n{\n    scanf(\"%d\",&n);\n    int tem;\n    for(int i=1;i<=n;i++)\n    {\n        scanf(\"%d\",&tem);\n        a[tem]=1;\n    }\n    for(int i=tem+1;i>=1;i--)\n    {\n        a[i]=a[i]^a[i-1];\n        if(a[i])\n            pos[i%2].push_back(i);\n    }\n    for(int i=0;i<pos[0].size();i++)\n        for(int j=0;j<pos[1].size();j++)\n            if(isprime(abs(pos[0][i]-pos[1][j])))\n                add_edge(i,j+pos[0].size());\n    V=pos[0].size()+pos[1].size();\n//    printf(\"V=%d\\n\",V);\n    int cnt=bipartite_matching();\n//    printf(\"cnt=%d\\n\");\n    cnt+=((pos[0].size()-cnt)/2+(pos[1].size()-cnt)/2)*2;\n//    printf(\"cnt=%d\\n\");\n    cnt+=(pos[0].size()%2)*3;\n    printf(\"%d\\n\",cnt);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef int sign;\ntypedef long long ll;\n#define For(i,a,b) for(register sign i=(sign)a;i<=(sign)b;++i)\n#define Fordown(i,a,b) for(register sign i=(sign)a;i>=(sign)b;--i)\nconst int N=100+5,M=1e7;\ntemplate<typename T>bool cmax(T &a,T b){return (a<b)?a=b,1:0;}\ntemplate<typename T>bool cmin(T &a,T b){return (a>b)?a=b,1:0;}\ntemplate<typename T>T read()\n{\n\tT ans=0,f=1;\n\tchar ch=getchar();\n\twhile(!isdigit(ch)&&ch!='-')ch=getchar();\n\tif(ch=='-')f=-1,ch=getchar();\n\twhile(isdigit(ch))ans=(ans<<3)+(ans<<1)+(ch-'0'),ch=getchar();\n\treturn ans*f;\n}\ntemplate<typename T>void write(T x,char y)\n{\n\tif(x==0)\n\t{\n\t\tputchar('0'),putchar(y);\n\t\treturn;\n\t}\n\tif(x<0)\n\t{\n\t\tputchar('-');\n\t\tx=-x;\n\t}\n\tstatic char wr[20];\n\tint top=0;\n\tfor(;x;x/=10)wr[++top]=x%10+'0';\n\twhile(top)putchar(wr[top--]);\n\tputchar(y);\n}\nvoid file()\n{\n#ifndef ONLINE_JUDGE\n\tfreopen(\"magic.in\",\"r\",stdin);\n\tfreopen(\"magic.out\",\"w\",stdout);\n#endif\n}\nint n,p[N];\nint l[M+5],vis[M+5];\nvoid input()\n{\n\tn=read<int>();\n\tFor(i,1,n)p[i]=read<int>();\n\t//sort(p+1,p+n+1);\n//\tn=unique(p+1,p+n+1)-p-1;\n}\nvoid init()\n{\n\tFor(i,2,M)\n\t{\n\t\tif(!vis[i])l[++l[0]]=i;\n\t\tfor(int j=1;j<=l[0]&&i*l[j]<=M;++j)\n\t\t{\n\t\t\tvis[i*l[j]]=1;\n\t\t\tif(i%l[j]==0)break;\n\t\t}\n\t}\n\tvis[1]=1;\n}\n\nint pos[N<<1],top;\nvector<int>E[2];\n#define pb push_back\nint match[N<<1],leg[N<<1];\nint mp[N<<1][N<<1];\nbool dfs(int u,int id)\n{\n\tint v;\n\tFor(i,0,E[(!(pos[u]&1))].size()-1)\n\t{\n\t\tv=E[(!(pos[u]&1))][i];\n\t\tif(leg[v]^id&&!vis[abs(pos[u]-pos[v])])\n\t\t{\n\t\t\t//cerr<<u<<' '<<v<<endl;  \n\t\t\tleg[v]=id;\n\t\t\tif(!match[v]||dfs(match[v],id))\n\t\t\t{\n\t\t\t\tmatch[v]=u;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\nvoid work()\n{\n\tint r;\n\tFor(i,1,n)\n\t{\n\t\tr=i;\n\t\twhile(r<n&&p[r+1]==p[r]+1)r++;\n\t\tpos[++top]=p[i];\n\t\tpos[++top]=p[r]+1;\n\t\ti=r;\n\t}\n\tint ans=0;\n\t//For(i,1,top)cout<<pos[i]<<endl;\n\tFor(i,1,top)E[(pos[i]&1)].pb(i);\n\tint res0=0,res1=0;\n\tFor(i,1,top)\n\t{\n\t\tif(pos[i]&1)\n\t\t{\n\t\t\tif(dfs(i,i))ans++;\n\t\t\tres1++;\n\t\t}\n\t\telse res0++;\n\t}\n//\tFor(i,1,top)cout<<match[i]<<endl;\n\t//cerr<<ans<<endl;\n//\tFor(i,1,top)cout<<vis[abs(pos[i]-pos[match[i]])]<<' '<<abs(pos[i]-pos[match[i]])<<endl;\n\tres1-=ans,res0-=ans;\n\tans+=(res0/2)*2+(res1/2)*2;\n\tres0%=2,res1%=2;\n\tif(res0&&res1)ans+=3;\n\twrite(ans,'\\n');\n}\nint main()\n{\n\t//file();\n\tinput();\n\tinit();\n\twork();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <cstdio>\n#include <utility>\n\n#define Int register int\n\nusing namespace std;\n\nconst int MAXN = 100, MAXV = 1e7, MAXE = 5e4, MAXP = 664579, INF = 0x3f3f3f3f;\nint n, L, S, T, d[MAXV + 5];\nint pn, Prime[MAXP + 5];\nint CntL, CntR, Left[MAXV + 5], Right[MAXV + 5];\nint Cnte = 1, Head[MAXV + 5];\nbool Vis[MAXV + 5];\npair<int, int> Path[MAXV + 5];\n\nstruct Edge { int To, Flow, nxt; } Graph[MAXE * 2 + 5];\n\ninline int Abs ( const int x ) { return x < 0 ? ~ x + 1 : x; }\n\ninline int Min ( const int a, const int b ) { return a < b ? a : b; }\n\ninline void Link ( const int s, const int t, const int f ) { Graph[++ Cnte] = { t, f, Head[s] }, Head[s] = Cnte; }\n\ninline void AddEdge ( const int s, const int t, const int f ) {\n#ifdef __DEBUG\n\tprintf ( \"<%d, %d, %d>\\n\", s, t, f );\n#endif\n\tLink ( s, t, f ), Link ( f, t, 0 );\n}\n\ninline void Sieve ( const int n ) {\n\tVis[0] = Vis[1] = true;\n\tfor ( Int i = 2; i <= n; ++ i ) {\n\t\tif ( ! Vis[i] ) Prime[++ pn] = i;\n\t\tfor ( Int j = 1; j <= pn && i * Prime[j] <= n; ++ j ) {\n\t\t\tVis[i * Prime[j]] = true;\n\t\t\tif ( ! ( i % Prime[j] ) ) break;\n\t\t}\n\t}\n}\n\ninline bool BFS () {\n\tstatic queue<int> Q;\n\tfor ( ; ! Q.empty (); Q.pop () );\n\tfor ( Int i = 1; i <= T; ++ i ) Vis[i] = false;\n\twhile ( ! Q.empty () ) {\n\t\tint u = Q.front (); Q.pop ();\n\t\tfor ( Int i = Head[u], v; i; i = Graph[i].nxt ) {\n\t\t\tif ( ! Vis[v = Graph[i].To] && Graph[i].Flow > 0 ) {\n\t\t\t\tQ.push ( v ), Vis[v] = true, Path[v] = { u, i };\n\t\t\t\tif ( v == T ) return true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\ninline int EK () {\n\tint ret = 0;\n\tfor ( ; BFS (); ) {\n\t\tint MinFlow = INF;\n\t\tfor ( Int u = T; u ^ S; u = Path[u].first ) MinFlow = Min ( MinFlow, Graph[Path[u].second].Flow );\n\t\tfor ( Int u = T; u ^ S; u = Path[u].first ) {\n\t\t\tGraph[Path[u].second].Flow -= MinFlow;\n\t\t\tGraph[Path[u].second ^ 1].Flow += MinFlow;\n\t\t}\n\t\tret += MinFlow;\n\t}\n\treturn ret;\n}\n\ninline void Work () {\n\tSieve ( MAXV );\n\tscanf ( \"%d\", &n );\n\tfor ( Int i = 1, x; i <= n; ++ i ) {\n\t\tscanf ( \"%d\", &x ), ++ d[x];\n\t\tL = L > x ? L : x;\n\t}\n\tfor ( Int i = 1; i <= L + 1; ++ i ) {\n\t\tif ( d[i] ^ d[i - 1] ) {\n\t\t\tif ( i & 1 ) {\n\t\t\t\tLeft[++ CntL] = i;\n\t\t\t} else {\n\t\t\t\tRight[++ CntR] = i;\n\t\t\t}\n\t\t}\n\t}\n\tS = CntL + CntR + 1, T = S + 1;\n\tfor ( Int i = 1; i <= CntL; ++ i ) AddEdge ( S, i, 1 );\n\tfor ( Int i = 1; i <= CntR; ++ i ) AddEdge ( i + CntL, T, 1 );\n\tfor ( Int i = 1; i <= CntL; ++ i ) {\n\t\tfor ( Int j = 1; j <= CntR; ++ j ) {\n\t\t\tif ( ! Vis[Abs ( Left[i] - Right[j] )] ) {\n\t\t\t\tAddEdge ( i, j + CntR, 1 );\n\t\t\t}\n\t\t}\n\t}\n\tint mxf = EK (), Ans = mxf;\n\tAns += ( CntL - mxf >> 1 << 1 ) + ( CntR - mxf >> 1 << 1 );\n\tAns += ( ( CntL - mxf ) & 1 ) * 3;\n\tprintf ( \"%d\\n\", Ans );\n}\n\nint main () {\n\tWork ();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define rep(i,n) REP(i,0,n)\n#define REP(i,s,e) for(int i=(s); i<(int)(e); i++)\n#define repr(i, n) REPR(i, n, 0)\n#define REPR(i, s, e) for(int i=(int)(s-1); i>=(int)(e); i--)\n#define pb push_back\n#define all(r) r.begin(),r.end()\n#define rall(r) r.rbegin(),r.rend()\n#define fi first\n#define se second\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int INF = 1e9;\nconst ll MOD = 1e9 + 7;\ndouble EPS = 1e-8;\n\ntemplate<class V> class MaxFlow_Ford {\npublic:\n\tstruct edge { int to, reve; V cap;};\n\tstatic const int MV = 10000;\n\tvector<edge> E[MV];\n\tint vis[MV];\n\tvoid add_edge(int x, int y, V cap, bool undir = false) {\n\t\tE[x].push_back((edge) {y, (int)E[y].size(), cap});\n\t\tE[y].push_back((edge) {x, (int)E[x].size() - 1, undir ? cap : 0});\n\t}\n\tV dfs(int from, int to, V cf) {\n\t\tV tf;\n\t\tif (from == to) return cf;\n\t\tvis[from] = 1;\n\t\tfor(auto&e :E[from]) if (vis[e.to] == 0 && e.cap > 0 && (tf = dfs(e.to, to, min(cf, e.cap))) > 0) {\n\t\t\te.cap -= tf;\n\t\t\tE[e.to][e.reve].cap += tf;\n\t\t\treturn tf;\n\t\t}\n\t\treturn 0;\n\t}\n\tV maxflow(int from, int to) {\n\t\tV fl = 0, tf;\n\t\twhile (1) {\n\t\t\tmemset(vis,0,sizeof(vis));\n\t\t\tif ((tf = dfs(from, to, numeric_limits<V>::max())) == 0) return fl;\n\t\t\tfl += tf;\n\t\t}\n\t}\n};\nMaxFlow_Ford<int> mf;\n//エラトステネスの篩を使用\nconst int MAX_PRIME = 1e7 + 10;\n\nvector<int> is_prime(MAX_PRIME, 1);\n\nvoid calcPrime() {\n\tis_prime[0] = is_prime[1] = 0;\n\tfor (int i = 2; i < MAX_PRIME; i++) {\n\t\tif (is_prime[i] == 1) {\n\t\t\tfor (int j = i * 2; j < MAX_PRIME; j += i) {\n\t\t\t\tis_prime[j] = 0;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\tcalcPrime();\n\tint n;\n\tcin >> n;\n\tvi x(n);\n\trep(i, n) cin >> x[i];\n\tmap<int, int> mp;\n\trep(i, n) {\n\t\tmp[x[i]] ^= 1;\n\t\tmp[x[i] + 1] ^= 1;\n\t}\n\tvi odd, even;\n\tfor (auto& p : mp) if (p.se) (p.fi & 1 ? odd : even).pb(p.se);\n\trep(i, odd.size()) rep(j, even.size()) {\n\t\tif (is_prime[abs(odd[i] - even[j])]) mf.add_edge(i, odd.size() + j, 1);\n\t}\n\trep(i, odd.size()) mf.add_edge(n, i, 1);\n\trep(i, even.size()) mf.add_edge(odd.size() + i, n + 1, 1);\n\tint f = mf.maxflow(n, n + 1);\n\tint ans = f + ((int)odd.size() - f) / 2 * 2 + ((int)even.size() - f) / 2 * 2;\n\tif (((int)odd.size() - f) & 1) ans += 3;\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define dbg(...) do{cerr<<__LINE__<<\": \";dbgprint(#__VA_ARGS__, __VA_ARGS__);}while(0);\n\nusing namespace std;\n\nnamespace std{template<class S,class T>struct hash<pair<S,T>>{size_t operator()(const pair<S,T>&p)const{return ((size_t)1e9+7)*hash<S>()(p.first)+hash<T>()(p.second);}};template<class T>struct hash<vector<T>>{size_t operator()(const vector<T> &v)const{size_t h=0;for(auto i : v)h=h*((size_t)1e9+7)+hash<T>()(i)+1;return h;}};}\ntemplate<class T>ostream& operator<<(ostream &os, const vector<T> &v){os<<\"[ \";rep(i,v.size())os<<v[i]<<(i==v.size()-1?\" ]\":\", \");return os;}template<class T>ostream& operator<<(ostream &os,const set<T> &v){os<<\"{ \"; for(const auto &i:v)os<<i<<\", \";return os<<\"}\";}\ntemplate<class T,class U>ostream& operator<<(ostream &os,const map<T,U> &v){os<<\"{\";for(const auto &i:v)os<<\" \"<<i.first<<\": \"<<i.second<<\",\";return os<<\"}\";}template<class T,class U>ostream& operator<<(ostream &os,const pair<T,U> &p){return os<<\"(\"<<p.first<<\", \"<<p.second<<\")\";}\nvoid dbgprint(const string &fmt){cerr<<endl;}template<class H,class... T>void dbgprint(const string &fmt,const H &h,const T&... r){cerr<<fmt.substr(0,fmt.find(\",\"))<<\"= \"<<h<<\" \";dbgprint(fmt.substr(fmt.find(\",\")+1),r...);}\ntypedef long long ll;typedef vector<int> vi;typedef pair<int,int> pi;const int inf = (int)1e9;const double INF = 1e12, EPS = 1e-9;\nstruct FlowGraph{\n\tstruct edge{ int to, cap, rev; };\n\t\n\tint n, *level, *iter;\n\tvector<vector<edge> > G;\n\t\n\tFlowGraph(int sz) : n(sz){\n\t\tG.resize(n);\n\t\titer = new int[n]; level = new int[n];\n\t}\n\t~FlowGraph(){\n\t\tdelete [] iter; delete [] level;\n\t}\n\t\n\tvoid add(int s, int t, int cap){\n\t\tG[s].pb((edge){t, cap, (int)G[t].size()});\n\t\tG[t].pb((edge){s, 0, (int)G[s].size() - 1});\n\t}\n\tvoid bfs(int s){\n\t\trep(i, n) level[i] = -1;\n\t\tqueue<int> q;\n\t\tlevel[s] = 0;\n\t\tq.push(s);\n\t\twhile(!q.empty()){\t\n\t\t\tint v = q.front();\n\t\t\tq.pop();\n\t\t\trep(i, G[v].size()){\n\t\t\t\tedge &e = G[v][i];\n\t\t\t\tif(e.cap > 0 && level[e.to] < 0){\n\t\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\t\tq.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint dfs(int v, int t, int f){\n\t\tif(v == t) return f;\n\t\tfor(int &i = iter[v]; i < (int)G[v].size(); i++){\n\t\t\tedge &e = G[v][i];\n\t\t\tif(e.cap > 0 && level[v] < level[e.to]){\n\t\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\t\tif(d > 0){\n\t\t\t\t\te.cap -= d;\n\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tint max_flow(int s, int t){\n\t\tint flow = 0;\n\t\twhile(1){\n\t\t\tbfs(s);\n\t\t\tif(level[t] < 0) return flow;\n\t\t\trep(i, n) iter[i] = 0;\n\t\t\tint f;\n\t\t\twhile((f = dfs(s, t, inf)) > 0) flow += f;\n\t\t}\n\t}\n};\nint main(){\n\tcin.tie(0); cin.sync_with_stdio(0);\n\t\n\tint n; cin >> n;\n\tvi v(n), u; rep(i, n) cin >> v[i];\n\tint cnt = 0;\n\trep(i, n){\n\t\tif(i && v[i] != v[i - 1] + 1){\n\t\t\tu.pb(v[i - 1] + 1);\n\t\t\tu.pb(v[i - 1] + 1 - cnt);\n\t\t\tcnt = 1;\n\t\t}\n\t\telse cnt++;\n\t}\n\tu.pb(v[n - 1] + 1);\n\tu.pb(v[n - 1] + 1 - cnt);\n\t\n\tauto isPrime = [](int x){\n\t\tif(x == 1) return 0;\n\t\tfor(int i = 2; i * i <= x; i++) if(x % i == 0) return 0;\n\t\treturn 1;\n\t};\n\t\n\tvi o, e;\n\tfor(int i : u) if(i % 2) o.pb(i); else e.pb(i);\n\tint s = o.size() + e.size(), t = s + 1;\n\tFlowGraph g(o.size() + e.size() + 2);\n\t{\n\t\trep(i, o.size()) rep(j, e.size()) if(isPrime(abs(o[i] - e[j]))) g.add(i, j + o.size(), 1);\n\t\trep(i, o.size()) g.add(s, i, 1);\n\t\trep(i, e.size()) g.add(i + o.size(), t, 1);\n\t}\n\tint f = g.max_flow(s, t);\n\t\n\tint ans = f + ((o.size() - f) / 2 + (e.size() - f) / 2) * 2 + (o.size() - f) % 2 * 3;\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i, n) for (int (i) = 0 ; (i) < (int)(n) ; ++(i))\n#define repn(i, m, n) for (int (i) = (m) ; (i) < (int)(n) ; ++(i))\n#define rep_rev(i, n) for (int (i) = (int)(n) - 1 ; (i) >= 0 ; --(i))\n#define repn_rev(i, m, n) for (int (i) = (int)(n) - 1 ; (i) >= (m) ; --(i))\n\n#define INF 2e9\n#define ll long long\n#define MOD 1e9+7\n#define MAX_V 305\n\n#define print2D(h, w, arr) REP(i, h) { REP(j, w) cout << arr[i][j] << \" \"; cout << endl; }\n#define print_line(vec, n) {for(int i=0;i<(n-1);i++) cout << (vec)[i] << \" \"; cout << (vec)[(n)-1] << endl;}\ntemplate<class T> void print(const T& x){cout << x << endl;}\ntemplate<class T, class... A> void print(const T& first, const A&... rest) { cout << first << \" \"; print(rest...); }\nstruct PreMain {PreMain(){cin.tie(0);ios::sync_with_stdio(false);cout<<fixed<<setprecision(20);}} premain; \n\n\n/* 辺を表す構造体 */\nstruct edge {int to, cap ,rev; };\n \n/* グラフの隣接リスト表現 */\nvector<edge> G[MAX_V];\n/* DFSですべに調べたかのグラフ */\nbool used[MAX_V];\n \n/* fromからtoへ向かう容量capの辺をグラフに追加する */\n/* 相互参照できるようにしている */\nvoid add_edge(int from, int to, int cap){\n    G[from].push_back((edge){to, cap, (int)G[to].size()});\n    G[to].push_back((edge){from, 0, (int)G[from].size() - 1});    \n}\n \n/* 増加パスをdfsで探す */\nint dfs(int v, int t, int f){\n    if(v==t) return f;\n    used[v] = true;\n    for(int i=0; i<G[v].size(); i++){\n        edge &e = G[v][i];\n        if(!used[e.to] && e.cap>0){\n            int d = dfs(e.to, t, min(f, e.cap));\n            if(d>0){\n                e.cap -= d;\n                G[e.to][e.rev].cap += d;\n                return d;\n            }\n        }\n    }\n    return 0;\n}\n \nint max_flow(int s, int t){\n    int flow = 0;\n    for(;;){\n        memset(used, 0, sizeof(used));\n        int f = dfs(s, t, INF);\n        if(f==0) return flow;\n        flow += f;\n    }\n}\n\nbool diffIsPrime(int a, int b) {\n    a = abs(a - b);\n    if(a <= 2) return false;\n    repn(i, 2, sqrt(a)+1) if(a % i == 0) return false;\n\n    return true;\n}\n\nint main(){\n    int n;\n    cin >> n;\n    vector<int> x(n);\n    map<int, int> mp;\n    rep(i, n) {\n        int tmp;\n        cin >> tmp;\n        mp[tmp] ^= 1;\n        mp[tmp+1] ^= 1;\n    }\n\n    /* 一発でいける分を探す。偶奇の組み合わせしかないので二部マッチング */\n    vector<int> odd, even;\n    for(auto it = mp.begin(); it != mp.end(); it++) {\n        if(it->second == 1) {\n            if(it->first % 2 == 0) {\n                even.push_back(it->first);\n            } else {\n                odd.push_back(it->first);\n            }\n        }\n    }\n\n    int start = 0, end = 201;\n    rep(i, even.size()) add_edge(start, i+1, 1);\n    rep(i, odd.size()) add_edge(i+101, end, 1);\n    rep(i, even.size()) rep(j, odd.size()) {\n        if(diffIsPrime(even[i], odd[j])) add_edge(i+1, j+101, 1);\n    }\n\n    int ans_tmp = max_flow(start, end);\n    int ans = ans_tmp;\n\n    /* 偶数同士と奇数同士は。差が偶数なので二回でいける */\n    ans += ((even.size() - ans_tmp) / 2) * 2;\n    ans += ((odd.size() - ans_tmp) / 2) * 2;\n\n    /* あまったやつは差が奇数なので三回でいける */\n    if(even.size() % 2 != 0) ans += 3;\n\n    cout << ans << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define inf (1e9 + 7)\n#define mem(a, b) memset(a, b, sizeof(a))\nusing namespace std;\n\nint pp[10000005], n, num[105], num2[205], nn = 0, ji = 0, ou = 0, lk[205], ans = 0;\nbool vis[205];\nvector<int> eg[205];\nmap<int, int> mps;\n\nvoid inits()\n{\n    mem(lk, -1);\n    for(int i = 2;i <= 10000000;i++)\n    {\n        if(!pp[i])\n            pp[++pp[0]] = i;\n        for(int j = 1;j <= pp[0]&&10000000 / i >= pp[j];j++)\n        {\n            pp[i * pp[j]] = 1;\n            if(i % pp[j] == 0)\n                break;\n        }\n    }\n}\n\nbool dfs(int u)\n{\n    int lim = eg[u].size();\n    for(int i = 0;i < lim;i++)\n    {\n        int v = eg[u][i];\n        if(!vis[v])\n        {\n            vis[v] = 1;\n            if(lk[v] == -1||dfs(lk[v]))\n            {\n                lk[v] = u;\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\nint main()\n{\n    inits();\n    int mx = 0;\n    scanf(\"%d\", &n);\n    for(int i = 1;i <= n;i++)\n        scanf(\"%d\", &num[i]);\n    sort(num + 1, num + 1 + n);\n    num2[++nn] = num[1];\n    mps[num[1]] = nn;\n    for(int i = 2;i <= n;i++)\n    {\n        if(num[i] - 1 != num[i - 1])\n        {\n            num2[++nn] = num[i - 1] + 1;\n            mps[num[i - 1] + 1] = nn;\n            num2[++nn] = num[i];\n            mps[num[i]] = nn;\n        }\n    }\n    num2[++nn] = num[n] + 1;\n    mps[num[n] + 1] = nn;\n    mx = num[n] + 1;\n    for(int i = 1;i <= nn;i++)\n    {\n        if(num2[i] % 2 == 0)\n        {\n            ou++;\n            for(int j = 2;j <= pp[0];j++)\n            {\n                if(num2[i] + pp[j] > mx)\n                    break;\n                if(mps.find(num2[i] + pp[j]) != mps.end())\n                {\n                    int pos = mps[num2[i] + pp[j]];\n                    eg[pos].push_back(i);\n                }\n            }\n        }\n        else\n        {\n            ji++;\n            for(int j = 2;j <= pp[0];j++)\n            {\n                if(num2[i] + pp[j] > mx)\n                    break;\n                if(mps.find(num2[i] + pp[j]) != mps.end())\n                {\n                    int pos = mps[num2[i] + pp[j]];\n                    eg[i].push_back(pos);\n                }\n            }\n        }\n    }\n    int res = 0;\n    for(int i = 1;i <= nn;i++)\n    {\n        if(num2[i] % 2 == 0)\n            continue;\n        mem(vis, 0);\n        if(dfs(i))\n            res++;\n    }\n    ans += res;\n    ji -= res;\n    ou -= res;\n    ans += ji / 2 * 2;\n    ji %= 2;\n    ans += ou / 2 * 2;\n    ou %= 2;\n    if(ji||ou)\n        ans += 3;\n    printf(\"%d\\n\", ans);\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "/* programed by white-55kai */\n#if 0\n#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<queue>\n#include<vector>\n#include<utility>\n#include<stdlib.h>\n#include<time.h>\n#else\n#include<bits/stdc++.h>\n#endif\n\n#if 0\n#include<cmath>\n#endif\n\n#define REP(i,l,r) for (reg int i=(l);i<=(r);++i)\n#define RREP(i,r,l) for (int i=(r);i>=(l);--i)\n#define rep(i,l,r) for (int i=(l);i<(r);++i)\n#define rrep(i,r,l) for (int i=(r);i>(l);--i)\n#define foredge(i,u) for (int i=la[u];i;i=ne[i])\n#define mem(a) memset(a,0,sizeof(a))\n#define memid(a) memset(a,63,sizeof(a))\n#define memax(a) memset(a,127,sizeof(a))\n#define dbg(x) cout<<#x<<\" = \"<<x<<endl\n#define reg register\n#define tpn typename\n#define fr(a) freopen(a,\"r\",stdin)\n#define fw(a) freopen(a,\"w\",stdout)\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ldb;\n\ntemplate <tpn A> inline A Max(const A &x,const A &y){\n    return x>y?x:y;\n}\ntemplate <tpn A> inline A Min(const A &x,const A &y){\n    return x<y?x:y;\n}\ntemplate <tpn A> inline void Swap(A &x,A &y){\n    x^=y,y^=x,x^=y;\n}\ntemplate <tpn A> inline A Abs(const A &x){\n    return x>0?x:-x;\n}\n#if 1\ntemplate <tpn A> inline void read(A &x){\n    char c;\n    A neg=1;\n    do{\n        c=getchar();\n    }while ((c<'0'||c>'9')&&c!='-');\n    if (c=='-') neg=-1,c=getchar();\n    x=0;\n    do{\n        x=x*10+c-48;\n        c=getchar();\n    }while (c>='0'&&c<='9');\n    x*=neg;\n}\ntemplate <tpn A,tpn B> inline void read(A &a,B &b){\nread(a),read(b);}\ntemplate <tpn A,tpn B,tpn C> inline void read(A &a,B &b,C &c){\nread(a),read(b),read(c);}\ntemplate <tpn A,tpn B,tpn C,tpn D> inline void read(A &a,B &b,C &c,D &d){\nread(a),read(b),read(c),read(d);}\ntemplate <tpn A> inline void put(const A &tmp){\n    A x=tmp;\n    if (x==0){\n        putchar('0');\n        return;\n    }\n    if (x<0) putchar('-'),x=-x;\n    char buf[30];\n    int buf_size=0;\n    while (x){\n        buf[++buf_size]=x%10+48;\n        x/=10;\n    }\n    RREP(i,buf_size,1) putchar(buf[i]);\n}\n#else\nnamespace fastIO {\n    #define buf_size 100000\n    #define LL long long\n    bool error;\n    inline char gc() {\n        static char buf[buf_size + 1], *l = buf, *r = buf;\n        if (l == r) {\n            l = buf;\n            r = buf + fread(buf, 1, buf_size, stdin);\n            if (l == r) {\n                error = 1;\n                return -1;\n            }\n        }\n        return *l ++;\n    }\n    inline bool blank(char ch) {\n        return ch == '\\n' || ch == '\\t' || ch == ' ' || ch == '\\r' || error;\n    }\n    inline bool read_int(int &x) {\n        char ch;\n        int f = 1;\n        while (blank(ch = gc()));\n        if (error) return false;\n        x = 0;\n        if (ch == '-') f = -1, ch = gc();\n        while (1) {\n            x = (x << 1) + (x << 3) + ch - '0';\n            if (!isdigit(ch = gc())) break;\n        }\n        x *= f;\n        return true;\n    }\n    inline bool read_LL(LL &x) {\n        char ch;\n        LL f = 1;\n        while (blank(ch = gc()));\n        if (error) return false;\n        x = 0;\n        if (ch == '-') f = -1, ch = gc();\n        while (1) {\n            x = (x << 1) + (x << 3) + ch - '0';\n            if (!isdigit(ch = gc())) break;\n        }\n        x *= f;\n        return true;\n    }\n    inline bool read_char(char &x) {\n        char ch;\n        while (blank(ch = gc()));\n        if (error) return false;\n        x = ch;\n        return true;\n    }\n    inline void put_int(int x) {\n        if (!x) {\n            putchar('0');\n            return;\n        }\n        if (x < 0) {\n            x = -x;\n            putchar('-');\n        }\n        static int out[13];\n        int len = 0;\n        while (x) {\n            out[++ len] = x % 10;\n            x /= 10;\n        }\n        while (len) putchar(out[len --] + '0');\n    }\n    inline void put_LL(LL x) {\n        if (!x) {\n            putchar('0');\n            return;\n        }\n        if (x < 0) {\n            x = -x;\n            putchar('-');\n        }\n        static LL out[20];\n        int len = 0;\n        while (x) {\n            out[++ len] = x % 10;\n            x /= 10;\n        }\n        while (len) putchar(out[len --] + '0');\n    }\n    #undef buf_size\n    #undef LL\n}\nusing namespace fastIO;\n#endif\ninline int mul_mod(int a,int b,int mo){\n    int ret;\n    __asm__ __volatile__ (\"\\tmull %%ebx\\n\\tdivl %%ecx\\n\":\"=d\"(ret):\"a\"(a),\"b\"(b),\"c\"(mo));\n    return ret;\n}\nconst int N = 10000005, K = 2005, M = 2005005;\nint la[K], ne[M], en[M], c[M], edgenum;\nint dis[K], cur[K], level[K];\ninline void add(int x, int y) {\n    ne[++edgenum] = la[x];\n    en[edgenum] = y;\n    c[edgenum] = 1;\n    la[x] = edgenum;\n    ne[++edgenum] = la[y];\n    en[edgenum] = x;\n    la[y] = edgenum;\n}\ninline void bfs(int S) {\n    queue<int> q;\n    int u, v;\n    while (!q.empty()) q.pop();\n    memset(level, -1, sizeof(level));\n    level[S] = 0;\n    q.push(S);\n    while (!q.empty()) {\n        u = q.front();\n        q.pop();\n        foredge(i, u)\n        if (c[i] && level[en[i]] < 0) {\n            v = en[i];\n            level[v] = level[u] + 1;\n            q.push(v);\n        }\n    }\n}\nint dfs(int u, int t, int f) {\n    if (u == t) return f;\n    int v, d;\n    for (int &i = cur[u]; i; i = ne[i]) {\n        v = en[i];\n        if (level[v] == level[u] + 1 && c[i]) {\n            d = dfs(v, t, min(c[i], f));\n            if (d) {\n                c[i] -= d;\n                c[((i - 1) ^ 1) + 1] += d;\n                return d;\n            }\n        }\n    }\n    return 0;\n}\ninline int maxflow(int S, int T) {\n    int flow = 0, f;\n    while (1) {\n        bfs(S);\n        if (level[T] < 0) return flow;\n        REP(i, S, T) cur[i] = la[i];\n        while (f = dfs(S, T, 0x7fffffff)) flow += f;\n    }\n}\nint n, k, x, y, num[K], del[K];\nint b[N], pri[N / 10], top;\nint main() {\n    b[1] = b[2] = 1;\n    REP(i, 3, N - 4) {\n        if (!b[i] && i & 1) pri[++top] = i;\n        if (!(i & 1)) continue;\n        for (int j = 1; j <= top && i * pri[j] <= N - 4; ++j) {\n            b[i * pri[j]] = 1;\n            if (i % pri[j] == 0) break;\n        }\n    }\n    read(k);\n    REP(i, 1, k) read(num[i]);\n    sort(num + 1, num + k + 1);\n    REP(i, 1, k) {\n        if (i == 1 || num[i - 1] < num[i] - 1) del[++n] = i;\n        if (i == k || num[i + 1] > num[i] + 1) del[++n] = i + 1;\n    }\n    REP(i, 1, n) {\n        if (del[i] & 1) num[++x] = del[i];\n        else del[++y] = del[i];\n    }\n    REP(i, 1, x) add(1, i + 1);\n    REP(i, 1, y) add(i + x + 1, n + 2);\n    REP(i, 1, x)\n    REP(j, 1, y)\n    if (!b[abs(num[i] - del[j])]) add(i + 1, j + x + 1);\n    k = maxflow(1, n + 2);\n    n = k + 2 * ((x - k) / 2 + (y - k) / 2) + 3 * (x - k & 1);\n    cout << n << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<cstring>\nusing namespace std;\nint n;\nint res;\nvector<int>v;\nint lst=-1;\nint match[210];\nint me,mo;\nint mx;\nbool f[10000010];\nvector<int>ok[210];\nbool vis[210];\nvector<int>prm;\nbool bp(int x)\n{\n\tfor(int i=0;i<ok[x].size();i++)\n\t{\n\t\tint y=ok[x][i];\n\t\tif(vis[y])continue;\n\t\tvis[y]=true;\n\t\tif(match[y]==-1 || bp(match[y]))\n\t\t{\n\t\t\tmatch[y]=x;\n\t\t\treturn true;\n\t\t}\n\t\tvis[y]=false;\n\t}\n\treturn false;\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint x;\n\t\tscanf(\"%d\",&x);\n\t\tif(x!=lst+1)\n\t\t{\n\t\t\tif(lst+1)v.push_back(lst+1);\n\t\t\tv.push_back(x);\n\t\t}\n\t\tlst=x;\n\t\tmx=lst+1;\n\t}\n\tv.push_back(lst+1);\n\tf[1]=true;\n\tfor(int i=2;i<=mx;i++)\n\t{\n\t\tif(!f[i])prm.push_back(i);\n\t\tfor(int j=0;j<prm.size() && prm[j]*i<=mx;j++)\n\t\t{\n\t\t\tf[prm[j]*i]=true;\n\t\t\tif(i%prm[j]==0)break;\n\t\t}\n\t}\n\tint l=v.size();\n\tfor(int i=0;i<l;i++)\n\t{\n\t\tmatch[i]=-1;\n\t\tif(v[i]&1)mo++;else me++;\n\t\tfor(int j=i+1;j<l;j++)\n\t\t{\n\t\t\tif(v[j]-v[i]!=2 && !f[v[j]-v[i]])\n\t\t\t{\n\t\t\t\tok[i].push_back(j);\n\t\t\t\tok[j].push_back(i);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<l;i++)\n\t{\n\t\tmemset(vis,false,sizeof(vis));\n\t\tif(bp(i))res++;\n\t}\n\tres/=2;\n\tprintf(\"%d\",res+((me-res)/2+(mo-res)/2)*2+((me-res)%2)*3);\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <utility>\n#include <vector>\n#include <cmath>\n#include <queue>\n#include <cstring>\n\nusing namespace std;\ntypedef pair<int,int> P;\n\nint N;\nint x[110];\nint y[210];\nbool isPrimeNumber(int x) {\n  if (x<=2) {\n    return false;\n  }\n  for(int i=2;i<=sqrt(x)+1;++i) {\n    if (x%i==0) {\n      return false;\n    }\n  }\n  return true;\n}\nclass Dinic {\npublic:\n  struct Edge{\n    int from,to,capacity,flow;\n    int calcRest(bool isRev) {\n      return isRev ? flow : capacity-flow;\n    }\n    int getNext(bool isRev) {\n      return isRev ? from : to;\n    }\n  };\n  static const int MAX_E=100000;\n  static const int MAX_V=500;\n  static const int INF=1000000;\n  int levels[MAX_V];\n  Edge edgeInstances[MAX_E];\n  vector<Edge*> edges[MAX_V][2]; // 1 => reverse edge\n  int E=0;\n\n  void addEdge(Edge edge) {\n    edgeInstances[E] = edge;\n    edges[edge.from][0].push_back(&edgeInstances[E]);\n    edges[edge.to][1].push_back(&edgeInstances[E]);\n    E++;\n  }\n\n  bool setLevels(int s, int t) {\n    memset(levels,-1,sizeof(levels));\n    queue<int> Q;\n    Q.push(s);\n    levels[s] = 0;\n    while(!Q.empty()) {\n      int current = Q.front();\n      Q.pop();\n      if(current==t) {\n        return true;\n      }\n\n      for(int j=0;j<2;++j) {\n        bool revEdge = j == 1;\n        vector<Edge*>& edgeList=edges[current][j];\n        for(int i=0;i<edgeList.size();++i) {\n          Edge& edge = *edgeList[i];\n          int rest = edge.calcRest(revEdge), next = edge.getNext(revEdge);\n          if(levels[next]!=-1) continue;\n          if(rest > 0){\n            levels[next] = levels[current] + 1;\n            Q.push(next);\n          }\n        }\n      }\n    }\n    return false;\n  }\n\n  int calcMaxFlow(int s, int t) {\n    int max_flow=0;\n    while(true) {\n      bool continueFlag = setLevels(s,t);\n      if(!continueFlag) {\n        break;\n      }\n      while(true) {\n        int flow = findFlow(s, t, INF);\n        max_flow += flow;\n        if(flow==0) {\n          break;\n        }\n      }\n    }\n    return max_flow;\n  }\n\n  int findFlow(int current, int destination, int flow) {\n    if(current == destination) return flow;\n\n    for(int j=0;j<2;++j) {\n      bool revEdge = j == 1;\n      vector<Edge*>& edgeList=edges[current][j];\n      for(int i=0;i<edgeList.size();++i) {\n        Edge& edge = *edgeList[i];\n        int rest = edge.calcRest(revEdge), next = edge.getNext(revEdge);\n        if(levels[next]<=levels[current])continue;\n        if(rest > 0){\n          int max_flow = findFlow(next, destination, min(rest,flow));\n          edge.flow += revEdge ? -max_flow: max_flow;\n          if(max_flow>0) {\n            return max_flow;\n          }\n        }\n      }\n    }\n    return 0;\n  }\n\n};\n\nDinic dinic;\nint main() {\n  int num=0;\n  int numEven=0;\n  int numOdd=0;\n  memset(y,0,sizeof(y));\n  memset(x,-1,sizeof(x));\n  scanf(\"%d\", &N);\n  for(int i=0;i<N;++i) {\n    scanf(\"%d\", &x[i]);\n  }\n  for(int i=0;i<N;++i) {\n    if (i==0) {\n      y[num++] = x[i];\n    } else if(x[i-1]!=x[i]-1) {\n      y[num++] = x[i];\n    }\n    if (x[i]!=x[i+1]-1) {\n      y[num++] = x[i]+1;\n    }\n  }\n  for(int i=0;i<num;++i) {\n    if(y[i]%2==0) {\n      numEven++;\n    } else {\n      numOdd++;\n    }\n  }\n  for(int i=0;i<num;++i) {\n    dinic.addEdge({0,i+1,1,0});\n    dinic.addEdge({201+i,450,1,0});\n    for(int j=i+1;j<num;++j) {\n      if(isPrimeNumber(y[j]-y[i])) {\n        dinic.addEdge({i+1,201+j,1,0});\n      }\n    }\n  }\n  int maxk=dinic.calcMaxFlow(0, 450);\n  printf(\"%d\\n\", maxk + ((numEven-maxk)/2+(numOdd-maxk)/2)*2 + ((numEven-maxk)%2) * 3);\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 1e7 + 700;\n\n\nint n,fre[maxn],p[220],ispr[maxn],even,odd,wrong;\nvector <int> edge[220],v2;\n\nbool fin(int u) {\n    if (fre[u]==wrong) return false;\n    fre[u]=wrong;\n    for (int j=0;j<edge[u].size();j++) {\n        int v=edge[u][j];\n       // cout<<u<<\" \"<<v<<endl;\n        if (p[v]==0 || fin(p[v])) {\n            p[v]=u;\n            p[u]=v;\n            return true;\n        }\n    }\n    return false;\n}\n\nint main() {\n  //  freopen(\"in.txt\",\"r\",stdin);\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    ispr[1]=1;\n    for (int i=2;i<maxn;i++)\n        if (ispr[i]==0) {\n            for (int j=i+i;j<maxn;j+=i) ispr[j]=1;\n        }\n    cin>>n;\n    for (int i=1;i<=n;i++) {\n        int x;\n        cin>>x;\n        fre[x]^=1;\n        fre[x+1]^=1;\n    }\n    even=0; odd=0; wrong=2;\n    for (int i=0;i<maxn;i++)\n        if (fre[i]==1) {\n            v2.push_back(i);\n            if (i%2==0) even++;\n            else odd++;\n        }\n    // for (int i=0;i<v2.size();i++) cout<<v2[i]<<\" \";\n   //  cout<<endl;\n   // cout<<\" \" <<even<<\" \"<<odd<<endl;\n    for (int i=0;i<v2.size();i++)\n        for (int j=0;j<v2.size();j++)\n            if (v2[i]%2==0 && v2[j]%2==1 && ispr[ abs(v2[j] - v2[i]) ]==0) {\n                edge[i].push_back(j);\n                edge[j].push_back(i);\n            }\n    int cnt=0;\n    for (int i=0;i<v2.size();i++)\n     if (p[i]==0) {\n        wrong++;\n        p[i]=i;\n        cnt+=(fin(i));\n    }\n    cout<< cnt + ((even-cnt)/2 + (odd-cnt)/2) * 2 + (even%2 && odd%2)*3;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<cstring>\n\nusing namespace std;\nint n;\nconst int maxn = 1e7+5;//40M\nconst int S = 1e7+2;\nint pri[maxn],cnt; bool mk[maxn];\nint A[maxn];\nvoid oula() {\n\tmk[1] = mk[0] = 1;\n\tfor(int i=2;i<=S;i++) {\n\t\tif(!mk[i]) { pri[++cnt]=i; }\n\t\tfor(int j=1;j<=cnt&&1ll*pri[j]*i<=S;j++) {\n\t\t\tint k = pri[j]*i;\n\t\t\tmk[k] = 1;\n\t\t\tif(i%pri[j]==0) break;\n\t\t}\n\t}\n}\nint la[405],en[405*405],owo,nt[405*405];\nvoid adg(int x,int y) {\n\ten[++owo]=y; nt[owo]=la[x]; la[x]=owo;\n}\nint cc[2];\nint yo[2][405];\nint link[405],vis[405];\nbool hungary(int x) {\n\tfor(int it=la[x];it;it=nt[it]) {\n\t\tint y = en[it];\n\t\tif(vis[y]) continue;\n\t\tvis[y] = 1;\n\t\tif((!link[y])||(hungary(link[y]))) {\n\t\t\tlink[y] = x; return 1;\n\t\t}\n\t}\n\treturn 0;\n}\nint main() {\n\toula();\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++) {\n\t\tint x; scanf(\"%d\",&x); A[x] = 1;\n\t}\n\tfor(int i=1;i<=S;i++) {\n\t\tint cf = A[i-1]^A[i];\n\t\tif(cf) {\n\t\t\t++cc[i&1];\n\t\t\tyo[i&1][cc[i&1]] = i;\n\t\t}\n\t}\n\tfor(int i=1;i<=cc[0];i++) {\n\t\tfor(int j=1;j<=cc[1];j++) {\n\t\t\tif(!mk[abs(yo[0][i]-yo[1][i])]) adg(i,j);\n\t\t}\n\t}\n\tint ans = 0;\n\tfor(int i=1;i<=cc[0];i++) {\n\t\tfor(int j=1;j<=cc[1];j++) vis[j] = 0;\n\t\tans += hungary(i);\n\t}\n\tcc[0]-=ans; cc[1]-=ans;\n\tprintf(\"%d\",ans+cc[0]/2*2 + cc[1]/2*2 + (cc[0]&1)*3 );\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define N 1116\n#define M 111116\n#define inf 1111111116\n#define next nxt\n \nint n,k,a[M],b[M],f[M],next[M],p[N],now[N],d[N],h[N],cnt,ans;\nvector<int> x;\nqueue<int> q;\n \nvoid add(int x,int y){\n\ta[++k]=x;b[k]=y;f[k]=1;next[k]=p[x];p[x]=k;\n\ta[++k]=y;b[k]=x;f[k]=0;next[k]=p[y];p[y]=k;\n}\n \nbool travel(){\n\tmemcpy(now,p,sizeof(p));\n\tfill(d+1,d+n+3,inf);d[n+1]=0;\n\tq.push(n+1);h[n+1]=1;\n\twhile (!q.empty()){\n\t\tint x=q.front();q.pop();h[x]=0;\n\t\tfor (int t=p[x];t;t=next[t])\n\t\t\tif (f[t]&&d[x]+1<d[b[t]]){\n\t\t\t\td[b[t]]=d[x]+1;\n\t\t\t\tif (!h[b[t]]) q.push(b[t]),h[b[t]]=1;\n\t\t\t}\n\t}\n\treturn d[n+2]<inf;\n}\n \nint dinic(int x,int lmt){\n\tif (x==n+2) return lmt;int cnt=0;\n\tfor (int t=now[x];t;t=now[x]=next[t])\n\t\tif (f[t]&&d[x]<d[b[t]]){\n\t\t\tint tmp=dinic(b[t],min(f[t],lmt-cnt));\n\t\t\tf[t]-=tmp;f[t^1]+=tmp;cnt+=tmp;\n\t\t\tif (cnt==lmt) return lmt;\n\t\t}\n\treturn cnt;\n}\n \nbool check(int x){\n\tif (x%2==0||x==1) return false;\n\tfor (int i=2;i*i<=x;i++)\n\t\tif (x%i==0) return false;\n\treturn true;\n}\n \nint read(){\n\tint x=0,f=1;char ch=getchar();\n\tfor (;!isdigit(ch);ch=getchar()) if (ch=='-')  f=-f;\n\tfor (;isdigit(ch);ch=getchar()) x=x*10+ch-'0';\n\treturn x*f;\n}\n \nint main(){\n\tn=read();k=1;x.push_back(0);\n\tfor (int i=1;i<=n;i++){\n\t\tint t=read();\n\t\tif (x.back()==t) x.pop_back();\n\t\telse x.push_back(t);\n\t\tx.push_back(t+1);\n\t}\n\tn=x.size()-1;\n\tfor (int i=1;i<=n;i++)\n\t\tif (x[i]&1) add(n+1,i),cnt++;\n\t\telse {\n\t\t\tfor (int j=1;j<=n;j++)\n\t\t\t\tif (check(x[i]+x[j])) add(i,j);\n\t\t\tadd(i,n+2);\n\t\t}\n\twhile (travel()) ans+=dinic(n+1,inf);\n\tprintf(\"%d\\n\",n-ans+(cnt-ans)%2);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <algorithm>\n#include <map>\n\nusing std::vector;\nusing std::map;\nusing std::string;\nusing std::pair;\nusing std::cin;\nusing std::cout;\nusing std::min;\nusing std::max;\n\n// @author: pashka\n\nint nl, nr;\nvector<vector<bool>> a;\nvector<bool> z;\nvector<int> p;\n\nbool prime(int x) {\n    if (x == 1) return false;\n    for (int i = 2; i * i <= x; i++) {\n        if (x % i == 0) return false;\n    }\n    return true;\n}\n\nbool dfs(int x) {\n    if (z[x]) return false;\n    z[x] = true;\n    for (int y = 0; y < nr; y++) {\n        if (a[x][y]) {\n            if (p[y] == -1 || dfs(p[y])) {\n                p[y] = x;\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n\n    int n;\n    cin >> n;\n\n    int x[n];\n    for (int i = 0; i < n; i++) { cin >> x[i]; }\n\n    vector<int> l;\n    vector<int> r;\n\n    for (int i = 0; i < n; i++) {\n        if (i == 0 || x[i - 1] != x[i] - 1) {\n            (x[i] % 2 == 0 ? l : r).push_back(x[i]);\n        }\n        if (i == n - 1 || x[i + 1] != x[i] + 1) {\n            ((x[i] + 1) % 2 == 0 ? l : r).push_back(x[i] + 1);\n        }\n    }\n\n    nl = l.size();\n    nr = r.size();\n    a.resize(nl);\n    for (int i = 0; i < nl; i++) {\n        a[i].resize(nr);\n        for (int j = 0; j < nr; j++) {\n            int d = abs(l[i] - r[j]);\n            a[i][j] = prime(d);\n        }\n    }\n\n    p.resize(nr);\n    fill(p.begin(), p.end(), -1);\n    z.resize(nl);\n    int res = 0;\n    for (int i = 0; i < nl; i++) {\n        fill(z.begin(), z.end(), false);\n        if (dfs(i)) {\n            res++;\n        }\n    }\n\n    nr -= res;\n    nl -= res;\n\n    int ans = nr + nl + res;\n    if (nr % 2 == 1) {\n        ans++;\n    }\n\n    cout << ans;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <vector>\n#include <queue>\n#include <utility>\n#include <cstring>\n#include <set>\n#include <cmath>\n#include <algorithm>\nusing namespace std;\n\ntypedef pair<int,int> pii;\nconst int MAX_N = 1e3 + 6;\n\nstruct CostFlow {\n\tstatic const int MAX_N = 1e3 + 6;\n\tstruct Edge {\n\t\tint to,cap,rev,cost;\n\t};\n\tvector<Edge> edg[MAX_N];\n\t#define SZ(x) ((int)(x).size())\n\tvoid add_edge(int from,int to,int cap,int cost) {\n\t\tedg[from].push_back({to,cap,SZ(edg[to]),cost});\n\t\tedg[to].push_back({from,0,SZ(edg[from])-1,-cost});\n\t}\n\tint n,s,t;\n\tvoid init(int _n,int _s,int _t) {\n\t\tn=_n;\n\t\ts=_s;\n\t\tt=_t;\n\t\tfor (int i=0;n>=i;i++) {\n\t\t\tedg[i].clear();\n\t\t}\n\t}\n\tstatic const int INF = 1e9 + 7;\n\tint dis[MAX_N];\n\tint pre[MAX_N],pre_id[MAX_N];\n\tbool in_que[MAX_N];\n\tpii flow() {\n\t\tint cost=0;\n\t\tint flow=0;\n\t\twhile (true) {\n//\t\t\tcout<<\"in\"<<endl;\n\t\t\tfor (int i=0;n>=i;i++) {\n\t\t\t\tdis[i] = INF;\n\t\t\t\tin_que[i]=0;\n\t\t\t}\n\t\t\tqueue<int> que;\n\t\t\tque.push(s);\n\t\t\tdis[s] = 0;\n\t\t\twhile (!que.empty()) {\n\t\t\t\tint t=que.front();\n\t\t\t\tque.pop();\n\t\t\t\tint id=0;\n\t\t\t\tin_que[t]=0;\n\t\t\t\tfor (Edge e:edg[t]) {\n\t\t\t\t\tif (e.cap > 0 && dis[e.to] > dis[t] + e.cost) {\n\t\t\t\t\t\tdis[e.to] = dis[t] + e.cost;\n\t\t\t\t\t\tpre[e.to] = t;\n\t\t\t\t\t\tpre_id[e.to] = id;\n\t\t\t\t\t\tif (!in_que[e.to]) {\n\t\t\t\t\t\t\tin_que[e.to]=1;\n\t\t\t\t\t\t\tque.push(e.to);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tid++;\n\t\t\t\t}\n\t\t\t}\n//\t\t\tcout<<\"haha\"<<endl;\n\t\t\tif (dis[t] == INF || dis[t] == 3) break;\n\t\t\tint mn_flow = INF;\n\t\t\tfor (int i=t;i!=s;i=pre[i]) {\n//\t\t\t\tcout<<\"i = \"<<i<<endl;\n\t\t\t\tmn_flow = min(mn_flow,edg[pre[i]][pre_id[i]].cap);\n\t\t\t}\n//\t\t\tcout<<\"finish \"<<endl;\n\t\t\tflow += mn_flow;\n\t\t\tcost += dis[t]*mn_flow;\n\t\t\tfor (int i=t;i!=s;i=pre[i]) {\n\t\t\t\tedg[pre[i]][pre_id[i]].cap -= mn_flow;\n\t\t\t\tedg[i][edg[pre[i]][pre_id[i]].rev].cap += mn_flow;\n\t\t\t}\n//\t\t\tcout<<\"finish2\"<<endl;\n\t\t}\n\t\treturn make_pair(cost,flow);\n\t}\n} Flow;\n\nint p[MAX_N];\nint q[MAX_N];\n\ntypedef long long LL;\nconst int MAX_P = 1e7 + 6;\n\nint prime[MAX_P];\n\nvoid build() {\n\tprime[0] = prime[1]=1;\n\tfor (LL i=2;MAX_P>i;i++) {\n\t\tif (prime[i]==0) {\n\t\t\tfor (LL j=i*i;MAX_P>j;j+=i) {\n\t\t\t\tprime[j]=1;\n\t\t\t}\n\t\t}\n\t}\n}\n\nbool isPrime(int x) {\n\treturn prime[x]?false:true;\n}\n\nint main (){\n\tbuild();\n\tint n;\n\tscanf(\"%d\",&n);\n\tset<int> st;\n\tvector<int> v;\n\tfor (int i=1;n>=i;i++) {\n\t\tint x;\n\t\tscanf(\"%d\",&x);\n\t\tst.insert(x);\n\t\tv.push_back(x-1);\n\t\tv.push_back(x);\n\t\tv.push_back(x+1);\n\t}\n\tsort(v.begin(),v.end());\n\tv.resize(unique(v.begin(),v.end()) - v.begin());\n\tint nn=0;\n\tint mm=0;\n\tfor (int i:v) {\n\t\tint _1 = (st.find(i) == st.end());\n\t\tint _2 = (st.find(i-1) == st.end());\n\t\tif ((_1^_2)) {\n\t\t\tif (i%2 == 0) p[++nn] = i;\n\t\t\telse q[++mm] = i;\n\t\t}\n\t}\n//\tcout<<\"hihi\"<<endl;\n//\tcout<<\"nn = \"<<nn<<\" , mm = \"<<mm<<endl;\n\tFlow.init(nn+mm+1,0,nn+mm+1);\n\tfor (int i=1;nn>=i;i++) {\n\t\tFlow.add_edge(0,i,1,0);\n\t}\n\t\n\tint t=nn+mm+1;\n\tfor (int i=1;mm>=i;i++) {\n\t\tFlow.add_edge(i+nn,t,1,0);\n\t}\n\tfor (int i=1;nn>=i;i++) {\n\t\tfor (int j=1;mm>=j;j++) {\n\t\t\tif (isPrime(abs(p[i]-q[j]))) Flow.add_edge(i,j+nn,1,1);\n\t\t\telse Flow.add_edge(i,j+nn,1,3);\n\t\t}\n\t}\n//\tcout<<\"hehe\"<<endl;\n\tpii ret=Flow.flow();\n\tprintf(\"%d\\n\",ret.first + ((nn-ret.first)/2)*2 + ((mm-ret.first)/2)*2 + 3*((nn-ret.first)%2+(mm-ret.first)%2 )/2);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<queue>\n#include<stack>\n#include<cstring>\n#include<algorithm>\n#include<vector>\n#include<cmath>\nusing namespace std;\nint e[201][201];\nint vis[201];\nint match[201];\nint tot1=0,tot2=0;\nbool find(int u)\n{\n\tfor(int i=1;i<=tot2;i++)\n\t{\n\t\tif(vis[i]==0&&e[u][i])\n\t\t{\n\t\t\tvis[i]=1;\n\t\t\tif(!match[i]||find(match[i]))\n\t\t\t{\n\t\t\t\tmatch[i]=u;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n}\nbool isprime(int x)\n{\n\tif(x==1) return false;\n\tfor(int i=2;i<=sqrt(x);i++)\n\t\tif(x%i==0)\n\t\t\treturn false;\n\treturn true;\n}\nint x[201];\nint odd[201];\nint even[201];\nsigned main()\n{\n\tint n;\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)\n\t\tscanf(\"%d\",&x[i]);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tif(i==1||x[i-1]!=x[i]-1)\n\t\t{\n\t\t\tif(x[i]%2==1) odd[++tot1]=x[i];\n\t\t\telse even[++tot2]=x[i];\n\t\t}\n\t\tif(i==n||x[i+1]!=x[i]+1)\n\t\t{\n\t\t\tif(x[i]%2==1) even[++tot2]=x[i]+1;\n\t\t\telse odd[++tot1]=x[i]+1;\n\t\t}\n\t}\n\tfor(int i=1;i<=tot1;i++)\n\t\tfor(int j=1;j<=tot2;j++)\n\t\t\tif(isprime(abs(odd[i]-even[j])))\n\t\t\t\te[i][j]=1;\n\tint ans=0;\n\tfor(int i=1;i<=tot1;i++)\n\t{\n\t\tmemset(vis,0,sizeof(vis));\n\t\tif(find(i))\n\t\t\tans++;\n\t}\n\tprintf(\"%d\",ans+(tot1-ans)/2*2+(tot2-ans)/2*2+(tot1-ans)%2*3);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntemplate<typename T>\nvoid read(T &x)\n{\n\tchar ch=getchar();\n\tfor (x=0;ch<'0'||ch>'9';ch=getchar());\n\tfor (;ch>='0'&&ch<='9';x=x*10+ch-'0',ch=getchar());\n}\n#define INF 0x3f3f3f3f\nvector<int> odd,even;\nbool vis[10000010];\nint prime[1000010],p_cnt;\nint n;\nint a[110];\nnamespace Network\n{\n\tstruct edge{\n\t\tint s,t,cap,next;\n\t}e[100010];\n\tint head[510],cnt;\n\tvoid addedge(int s,int t,int cap)\n\t{\n\t\te[cnt].s=s;e[cnt].t=t;e[cnt].cap=cap;e[cnt].next=head[s];head[s]=cnt++;\n\t\te[cnt].s=t;e[cnt].t=s;e[cnt].cap=0;e[cnt].next=head[t];head[t]=cnt++;\n\t}\n\tqueue<int> q;\n\tint s,t;\n\tint dis[510]; \n\tbool bfs()\n\t{\n\t\tq.push(s);\n\t\tmemset(dis,0x3f,sizeof(dis));\n\t\tdis[s]=0;\n\t\twhile (!q.empty())\n\t\t{\n\t\t\tint tmp=q.front();\n\t\t\tq.pop();\n\t\t\tfor (int i=head[tmp];i!=-1;i=e[i].next)\n\t\t\t\tif (e[i].cap && dis[e[i].t]==INF)\n\t\t\t\t{\n\t\t\t\t\tdis[e[i].t]=dis[tmp]+1;\n\t\t\t\t\tq.push(e[i].t);\n\t\t\t\t}\n\t\t}\n\t\treturn dis[t]!=INF;\n\t}\n\tint find(int x,int low)\n\t{\n\t    if (x==t)\n\t        return low;\n\t    int used=0;\n\t    for (int i=head[x];i!=-1;i=e[i].next)\n\t        if (e[i].cap>0 && dis[e[i].t]==dis[x]+1)\n\t        {\n\t            int flow=find(e[i].t,min(low-used,e[i].cap));\n                e[i].cap-=flow;\n                e[i^1].cap+=flow;\n                used+=flow;\n                if (used==low)\n                    return low;\n\t        }\n\t    if (!used)\n\t        dis[x]=-1;\n\t    return used;\n\t}\n\tint dinic()\n\t{\n\t\tmemset(head,0xff,sizeof(head));\n\t\tcnt=0;\n\t\ts=0,t=odd.size()+even.size()+1;\n\t\tfor (int i=0;i<odd.size();i++)\n\t\t\taddedge(s,i+1,1);\n\t\tfor (int i=0;i<even.size();i++)\n\t\t\taddedge(odd.size()+i+1,t,1);\n\t\tfor (int i=0;i<odd.size();i++)\n\t\t\tfor (int j=0;j<even.size();j++)\n\t\t\t\tif (!vis[abs(odd[i]-even[j])])\n\t\t\t\t\taddedge(i+1,odd.size()+j+1,1);\n\t    int ans=0;\n\t    while (bfs())\n\t        ans+=find(s,INF);\n\t    return ans;\n\t}\n}\nvoid ins(int x)\n{\n\tif (x&1)\n\t\todd.push_back(x);\n\telse\n\t\teven.push_back(x);\n}\nvoid pre()\n{\n\tvis[1]=1; \n    for (int i=2;i<=10000000;i++)\n    {\n        if (!vis[i])\n            prime[++p_cnt]=i;\n        for (int j=1;j<=p_cnt&&i*prime[j]<=10000000;j++)\n        {\n            vis[i*prime[j]]=1;\n            if (i%prime[j]==0)\n                break;\n        }\n    }\n}\nint main()\n{\n\tread(n);\n\tfor (int i=1;i<=n;i++)\n\t\tread(a[i]);\n\tsort(a+1,a+n+1);\n\ta[0]=-1;\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tif (a[i-1]!=a[i]-1)\n\t\t\tins(a[i]);\n\t\tif (a[i+1]!=a[i]+1)\n\t\t\tins(a[i]+1);\n\t}\n\tpre();\n\tint k=Network::dinic();\n\tprintf(\"%d\\n\",k+2*((odd.size()-k)/2+(even.size()-k)/2)+3*((odd.size()-k)%2));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits//stdc++.h\"\nusing namespace std;\ntypedef long long ll;\nconst ll INF = 1LL << 60;\nconst ll MOD = 1e9 + 7;\ntypedef pair<int, int> P;\n\n#define rep(i,n) for (int i = 0; i < (n); i++)\n#define ALL(v) v.begin(), v.end()\n\nstruct edge {\n\tint to, cap, rev;\n\tedge(int to, int cap, int rev) :to(to), cap(cap), rev(rev) {}\n};\n\nvector<vector<edge>> G;\nvector<bool> used;\n\nvoid add_edge(int from, int to, int cap) {\n\tG[from].emplace_back(to, cap, G[to].size());\n\tG[to].emplace_back(from, 0, G[from].size() - 1);\n}\n\nint dfs(int v, int t, int f) {\n\tif (v == t) return f;\n\tused[v] = 1;\n\tfor (edge &e : G[v]) {\n\t\tif (!used[e.to] && e.cap > 0) {\n\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\tif (d > 0) {\n\t\t\t\te.cap -= d;\n\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint max_flow(int s, int t) {\n\tint flow = 0;\n\tused.resize(G.size());\n\tfor (;;) {\n\t\tfill(ALL(used), 0);\n\t\tint f = dfs(s, t, 1 << 30);\n\t\tif (f == 0) return  flow;\n\t\tflow += f;\n\t}\n}\nbool a[10000010];\nbool is_prime[10000010];\nint main() {\n\tmemset(is_prime, -1, sizeof(is_prime));\n\tis_prime[0] = is_prime[1] = 0;\n\tfor (int i = 2; i <= 10000000; i++) {\n\t\tif (!is_prime[i]) continue;\n\t\tfor (int j = i * 2; j <= 10000000; j += i) is_prime[j] = 0;\n\t}\n\tint N;\n\tcin >> N;\n\trep(i, N) {\n\t\tint x;\n\t\tcin >> x;\n\t\ta[x] = 1;\n\t}\n\tvector<int> even, odd;\n\trep(i, 10000001) {\n\t\tif (a[i] ^ a[i + 1]) {\n\t\t\tif (i % 2 == 0) even.push_back(i);\n\t\t\telse odd.push_back(i);\n\t\t}\n\t}\n\tint X = even.size(), Y = odd.size();\n\tG.resize(X + Y + 2);\n\trep(i, X) add_edge(0, i + 1, 1);\n\trep(i, Y) add_edge(i + X + 1, X + Y + 1, 1);\n\trep(i, X) {\n\t\trep(j, Y) {\n\t\t\tif (is_prime[abs(even[i] - odd[j])]) add_edge(i + 1, j + X + 1, 1);\n\t\t}\n\t}\n\tint k = max_flow(0, X + Y + 1);\n\tint ans = k + (X - k) / 2 * 2 + (Y - k) / 2 * 2 + ((X - k) % 2) * 3;\n\tcout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <iostream>\n#include <algorithm>\n#define fo(i,a,b) for(int i=a;i<=b;i++)\n#define fod(i,a,b) for(int i=a;i>=b;i--)\n#define N 2005\nusing namespace std;\nint l[N],n,a[N],r[N],w[N],pr[5000005],f[N],a1[N][N];\nbool bz[20000005],bp[N];\nvoid prp()\n{\n\tfo(i,2,20000000)\n\t{\n\t\tif(!bz[i]) pr[++pr[0]]=i;\n\t\tfor(int j=1;j<=pr[0]&&i*pr[j]<=20000000;j++)\n\t\t{\n\t\t\tbz[i*pr[j]]=1;\n\t\t\tif(i%pr[j]==0) break;\n\t\t}\n\t}\n\tbz[2]=1-;\n}\nbool find(int k)\n{\n\tfo(i,1,a1[k][0])\n\t{\n\t\tint p=a1[k][i];\n\t\tif(!bp[p])\n\t\t{\n\t\t\tbp[p]=1;\n\t\t\tif(!f[p]||find(f[p])) \n\t\t\t{\n\t\t\t\tf[p]=k;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nint main()\n{\n\tcin>>n;\n\tprp();\n\tfo(i,1,n) scanf(\"%d\",&a[i]);\n\tsort(a+1,a+n+1);\n\tfo(i,1,n) \n\t{\n\t\tif(i==1||a[i-1]!=a[i]-1) w[++w[0]]=i;\n\t\tif(a[i+1]!=a[i]+1) w[++w[0]]=i+1;\n\t}\n\tsort(w+1,w+w[0]+1);\n\tfo(i,1,w[0]) \n\t\tif(w[i]%2==0) l[++l[0]]=i;\n\t\telse r[++r[0]]=i;\n\tfo(i,1,l[0])\n\t{\n\t\tfo(j,1,r[0])\n\t\t{\n\t\t\tif(!bz[abs(l[i]-r[j])]) a1[i][++a1[i][0]]=j;\n\t\t}\n\t}\n\tlong long s=0;\n\tfo(i,1,l[0]) \n\t{\n\t\tmemset(bp,0,sizeof(bp));\n\t\tif(find(i)) s++;\n\t}\n\tprintf(\"%lld\",s+2*(long long)((l[0]-s)/2)+2*(long long)((r[0]-s)/2)+3*(long long)((l[0]-s)%2));\n}"
  },
  {
    "language": "C++",
    "code": "#pragma comment(linker, \"/STACK:1024000000,1024000000\")\n#include<algorithm>\n#include<iostream>\n#include<cstring>\n#include<fstream>\n#include<bitset>\n#include<cstdio>\n#include<string>\n#include<vector>\n#include<cmath>\n#include<queue>\n#include<stack>\n#include<map>\n#include<set>\n#define INF 0X3F3F3F3F\n#define N 100005\n#define M 2000005\n#define LL long long\n#define FF(i, a, b) for(int i = a; i <= b; ++i)\n#define RR(i, a, b) for(int i = a; i >= b; --i)\n#define FJ(i, a, b) for(int i = a; i < b; ++i)\n#define SC(x) scanf(\"%d\", &x)\n#define SCC(x, y) scanf(\"%d%d\", &x, &y)\n#define SCCC(x, y, z) scanf(\"%d%d%d\", &x, &y, &z)\n#define SS(x) scanf(\"%s\", x)\n#define PR(x) printf(\"%d\\n\", x)\n#define CL(a, x) memset(a, x, sizeof(a))\n#define _P fd[rt]\n#define _L fd[rt << 1]\n#define _R fd[rt << 1 | 1]\n#define MID int mid = ((l + r) >> 1)\n#define lson rt<<1 ,l, mid\n#define rson rt<<1 | 1, mi d + 1, r\n#define PII pair<int, int>\n#define PLL pair<long long, long long>\n#define MP make_pair\n#define PB push_back\n#define IN freopen(\"in.txt\", \"r\", stdin)\n#define OUT freopen(\"out.txt\", \"w\", stdout)\nusing namespace std;\nconst int MOD = 1000000007;\nconst double PI = acos(-1.0);\nconst double EPS = 1e-8;\ninline void II(int &n){char ch = getchar(); n = 0; bool t = 0;\nfor(; ch < '0'; ch = getchar()) if(ch == '-') t = 1;\nfor(; ch >= '0'; n = n * 10 + ch - '0', ch = getchar()); if(t) n =- n;}\ninline void OO(int a){if(a < 0) {putchar('-'); a = -a;}\nif(a >= 10) OO(a / 10); putchar(a % 10 + '0');}\ninline int sgn(double x){return (x > EPS) - (x < -EPS);}\nint vis[10000005], pri[M], prn;\nvoid init(){\n    for(int i = 2; i < 10000000; ++i){\n        if(vis[i] == 0) pri[++prn] = i;\n        for(int j = 1; j <= prn && i * pri[j] <= 10000000; ++j){\n            vis[i * pri[j]] = 1;\n            if(i % pri[j] == 0) break;\n        }\n    }\n}\nint n, a[300], c[300], cnt, l[300], r[300], ln, rn;\nbool mp[300][300];\nint vv[300], link[300], ii;\nbool dfs(int u){\n    FF(v, 1, cnt) if(mp[u][v]){\n        if(vv[v] != ii){\n            vv[v] = ii;\n            if(!link[v] || dfs(link[v])){\n                link[v] = u;\n                return 1;\n            }\n        }\n    }\n    return 0;\n}\nint main(){\n //   IN;\n    init();\n    vis[0] = vis[1] = vis[2] = 1;\n    SC(n);\n    FF(i, 1, n) SC(a[i]);\n    int p = 1;\n    while(p <= n){\n        c[++cnt] = a[p];\n        int pp = p;\n        while(pp < n && a[pp + 1] == a[pp] + 1) ++pp;\n        c[++cnt] = a[pp] + 1;\n        p = pp + 1;\n    }\n    FF(i, 1, cnt){\n        if(c[i] & 1) l[++ln] = c[i];\n        else r[++rn] = c[i];\n    }\n    FF(i, 1, cnt) FF(j, i + 1, cnt){\n        if(vis[abs(l[i] - r[j])] == 0) mp[i][j] = mp[j][i] = 1;\n    }\n    int s = 0;\n    for(ii = 1; ii <= cnt; ++ii){\n        if(dfs(ii)){\n            ++s;\n        }\n    }\n    s /= 2;\n    int ans = s;\n    ans += ((ln - s) / 2 + (rn - s) / 2) * 2;\n    ans += (ln - s) % 2 ? 3 : 0;\n    printf(\"%d\\n\", ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#define fo(i,a,b) for(int i=a;i<=b;i++)\n#define N 510\n#define M 10000010\nusing namespace std;\nint n,a[M],q[N],w[N],bz[M],p[M],last[N],nxt[N],to[N],tot=0,b[N],jy=0,ans=0;\nvoid link(int x,int y)\n{\n\tnxt[++tot]=last[x];last[x]=tot;to[tot]=y;\n}\nint dg(int x)\n{\n\tif(bz[x]==tot) return 0;\n\tbz[x]=tot;\n\tfor(int i=last[x];i;i=nxt[i])\n\t{\n\t\tint y=to[i];\n\t\tif(b[y]==0||dg(b[y]))\n\t\t{\n\t\t\tb[y]=x;return 1;\n\t\t}\n\t}\n\treturn 0;\n}\nint main()\n{\n\tfo(i,2,10000000)\n\t{\n\t\tif(!bz[i]) p[++p[0]]=i;\n\t\tfo(j,1,p[0])\n\t\t{\n\t\t\tint k=i*p[j];\n\t\t\tif(k>=10000000) break;\n\t\t\tbz[k]=1;\n\t\t\tif(i%p[j]==0) break;\n\t\t}\n\t}\n\tscanf(\"%d\",&n);\n\tfo(i,1,n)\n\t{\n\t\tint x;scanf(\"%d\",&x);\n\t\ta[x]=1;\n\t}\n\tfo(i,1,10000001)\n\tif(a[i]!=a[i-1])\n\t{\n\t\tif(i%2==1) q[++q[0]]=i;\n\t\telse w[++w[0]]=i;\n\t}\n\tbz[1]=bz[2]=1;\n\tfo(i,1,q[0]) fo(j,1,w[0]) if(bz[abs(q[i]-w[j])]==0) link(i,j);\n\tmemset(bz,0,sizeof(bz));\n\tfor(tot=1;tot<=n;tot++) if(!bz[tot]&&b[tot]==0) jy+=dg(tot);\n\tans=2*((q[0]-jy)/2);\n\tans+=2*((w[0]-jy)/2);\n\tans+=3*((q[0]-jy)%2);\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "//#pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"Ofast,no-stack-protector\") \n//#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//#pragma GCC optimize(\"unroll-loops\")\n\n#include <bits/stdc++.h>\n\n#define int long long\n#define ll long long\n#define ull unsigned long long\n#define ld long double\n#define rep(i, l, r) for (int i = l; i < r; i++)\n#define repb(i, r, l) for (int i = r; i > l; i--)\n#define sz(a) (int)a.size()\n#define fi first\n#define se second\n#define all(x) x.begin(),x.end()\n#define pb push_back\n#define mp(a, b) make_pair(a, b)\n#define ret(a) {cout << a; exit(0);}\n\nusing namespace std;\n\nmt19937 mrand(random_device{}()); \nconst ll mod=1000000007;\nint rnd(int x) { return mrand() % x;}\nll powmod(ll a,ll b,ll mod) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\n\ntypedef pair < int , int > pii ;\ntypedef pair < long long  , long long > pll ;\n\nconst int N = 200 , K = 501;\nint n , m , k;\nint x[N];\nbool was[N] ;\nint mt[N];\nvector < int > gr[N];\nbool pr(int x){\n\tif(x <= 2)\n\t\treturn false;\n\tfor(int i = 2 ; i * i <= x; i++)\n\t\tif(n % i == 0)\t\n\t\t\treturn false;\n\treturn true;\n}\nbool kuhn(int v){\n\tif(was[v])return false;\n\twas[v] = 1;\n\tfor(auto to : gr[v])\n\t\tif(mt[to] == -1 or kuhn(mt[to])){\n\t\t\tmt[to] = v;\n\t\t\treturn true;\n\t\t}\n\treturn false;\n}\nmain(){\n\tios::sync_with_stdio(0); cin.tie(0);cout.tie(0);\n\tcin >> n;\n\tfor(int i = 1;i <= n; i++){\n\t\tcin >> x[i];\n\t}\n\tvector < int > v;\n\tx[0] = -1;\n\tfor(int i = 1 ;i <= n ; i++){\n\t\tif(x[i] != x[i - 1] + 1)\n\t\t\tv.pb(x[i]) ;\n\t\tif(x[i + 1] != x[i] + 1)\n\t\t\tv.pb(x[i] + 1);\t\t\t\n\t}\n/*\tfor(int i = 1; i <= 6 ; i++)\n\t\tcout << tmp[i];\n\tcout << endl;*/\n\tint cnt0 = 0 , cnt1 = 0;\n\tfor(auto i : v){\n\t\tcnt0 += i % 2 == 0,\n\t\tcnt1 += i % 2 == 1;\t\t\n\t}\n//\treturn 0;\n\tfor(int i = 0 ; i < sz(v); i++){\n\t\tfor(int j = i + 1 ; j < sz(v); j++){\n\t\t\tif(pr(v[j] - v[i]))\n\t\t\t\tgr[i].pb(j) , gr[j].pb(i);\n\t\t}\n\t}\t\n\tfor(int i = 0 ;i < sz(v); i++)\n\t\tmt[i] = -1;\n\tfor(int i = 0 ; i < sz(v) ;i++){\n\t\tmemset(was , 0, sizeof(was));\n\t\tkuhn(i);\n\t}\n\tint tot = 0, d0 = 0 , d1 = 0;\n\tfor(int i = 0; i < sz(v) ; i++){\n\t\tif(mt[i] != -1){\n\t\t\ttot++,d0 += i % 2 == 0 , d1 += i % 2 == 1;\n\t\t}\n\t}\n\ttot /= 2;\n\n\tcout << tot + ((cnt0 - tot)/2 + (cnt1 - tot)/2) * 2 + ((cnt1 - tot)%2) * 3;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/********************************************************************************\n\t\n\tCode by a weak man named CYJian, and he hopes the code can get more points.\n\n\tAlgorithm: \n\n ********************************************************************************/\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\n//{{{ FAST IO AND SOME FUNCTIONS\nconst int __SIZE = 1 << 18;\nchar ibuf[__SIZE], *iS, *iT;\n\n#define ge (iS == iT ? (iT = (iS = ibuf) + fread(ibuf, 1, __SIZE, stdin), (iS == iT ? EOF : *iS++)) : *iS++)\n#define ri read_int()\n#define rl read_ll()\n#define FILE(s) freopen(s\"in\", \"r\", stdin), freopen(s\"out\", \"w\", stdout)\n\ntemplate<typename T>\ninline void read(T &x) {\n\tchar ch, t = 0; x = 0;\n\twhile(!isdigit(ch = ge)) t |= ch == '-';\n\twhile(isdigit(ch)) x = x * 10 + (ch ^ 48), ch = ge;\n\tx = t ? -x : x;\n}\ninline int read_int() { int x; return read(x), x; }\ninline ll read_ll() { ll x; return read(x), x; }\n\ntemplate<typename T> inline void chkmin(T&a, T b) { a = a < b ? a : b; }\ntemplate<typename T> inline void chkmax(T&a, T b) { a = a > b ? a : b; }\n//}}}\n\nint tot;\nint pri[5010];\nint chk[5010];\n\ninline void Sieve(int n) {\n\tfor(int i = 2; i <= n; i++) {\n\t\tif(!chk[i]) pri[++tot] = i;\n\t\tfor(int j = 1; j <= tot; j++) {\n\t\t\tif(i * pri[j] > n) break;\n\t\t\tchk[i * pri[j]] = 0;\n\t\t\tif(i % pri[j] == 0) break;\n\t\t}\n\t}\n}\n\ninline int check(int x) {\n\tif(x <= 5000) return chk[x];\n\tfor(int *p = pri + 1;; ++p) {\n\t\tif((*p) * (*p) > x) return 1;\n\t\tif(x % (*p) == 0) return 0;\n\t}\n}\n\nvector<int>to[210];\nint vis[210];\nint p[210];\nint N;\n\ninline int Try(int x) {\n\tfor(auto u : to[x]) {\n\t\tif(!vis[u]) {\n\t\t\tvis[u] = x;\n\t\t\tvis[x] = u;\n\t\t\treturn 1;\n\t\t} else if(Try(vis[u])) {\n\t\t\tvis[u] = x;\n\t\t\tvis[x] = u;\n\t\t\treturn 1;\n\t\t}\n\t} return 0;\n}\n\nint main() {\n#ifdef LOCAL\n\tFILE(\"\");\n#endif\n\n\tSieve(5000);\n\tint n = ri, ce = 0, co = 0;\n\n\tfor(int i = 1; i <= n; i++) {\n\t\tint x = ri;\n\t\tif(p[N] == x) --N;\n\t\telse p[++N] = x;\n\t\tp[++N] = x + 1;\n\t}\n\n\tfor(int i = 1; i <= N; i++) \n\t\tp[i] & 1 ? ++co : ++ce;\n\n\tfor(int i = 1; i <= N; i++)\n\t\tfor(int j = i + 1; j <= N; j++)\n\t\t\tif(((p[i] ^ p[j]) & 1) && check(p[j] - p[i]))\n\t\t\t\tto[i].push_back(j), to[j].push_back(i);\n\n\tint res = 0;\n\tfor(int i = 1; i <= N; i++)\n\t\tif((p[i] & 1) && Try(i))\n\t\t\t--co, --ce, ++res;\n\n\tres += (co / 2 + ce / 2) << 1;\n\tif((co | ce) & 1) res += 3;\n\n\tcout << res << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <iomanip>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <unordered_set>\n#include <unordered_map>\n#include <bitset>\n#include <limits>\n#include <random>\n#include <complex>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cassert>\nusing namespace std;\n\n#define REP(i,n) for (int i = 0; i < n; i++)\ntemplate <class T> using reversed_priority_queue = priority_queue<T, vector<T>, greater<T> >;\ntypedef long long ll;\n\ntemplate <class T> struct FordFulkerson {\n\n    struct  Edge {\n        int to,rev; T cap;\n        Edge(int t, int r, T c) : to(t), rev(r), cap(c) {}\n    };\n    \n    const T INF = numeric_limits<T>::max() / 2;\n    vector< vector< Edge > > G;\n    vector< bool > used;\n    FordFulkerson (int n) : G(n+1), used(n+1) {}\n   \n    void add_edge(int from, int to, T cap) {\n        G[from].push_back(Edge(to,(int)G[to].size(),cap));\n        G[to].push_back(Edge(from,(int)G[from].size()-1,0));\n    }\n    \n    T dfs(int v, int t, T f) {\n        if (v == t) return f;\n        used[v] = true;\n        for (int i = 0; i < G[v].size(); i++) {\n            Edge &e = G[v][i];\n            if (!used[e.to] && e.cap > 0) {\n                T d = dfs(e.to, t, min(f,e.cap));\n                if (d > 0) {\n                    e.cap -= d;\n                    G[e.to][e.rev].cap += d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n   \n    T get_max (int source, int sink) {\n        T flow = 0;\n        while (true) {\n            for (int i = 0; i < used.size(); i++) used[i] = false;\n            T f = dfs(source, sink, INF);\n            if (f == 0) return flow;\n            flow += f;\n        }\n    }\n    \n};\n\n\nbool isPrime(long long n) {\n    if (n <= 2) return false;\n    for (long long i = 2; i * i <= n; i++) if (n % i == 0) return false;\n    return true;\n}\n\nbool flip[10000010];\n\nint main ()\n{\n    int N;\n    cin >> N;\n    vector < int > x(N);\n    REP(i,N) cin >> x[i];\n\n    REP(i,N) {\n        flip[x[i]] = !flip[x[i]];\n        flip[x[i] + 1] = !flip[x[i] + 1];\n    }\n\n    vector < int > xt;\n    for (int i = 0; i < 10000010; i++) {\n        if (flip[i]) xt.push_back(i);\n    }\n\n    FordFulkerson < int > inst(1000);\n    vector < int > odd, even;\n    REP(i,xt.size()) {\n        if (xt[i] % 2) odd.push_back(i);\n        else even.push_back(i);\n    }\n\n    for (int i = 0; i < odd.size(); i++) {\n        for (int j = 0; j < even.size(); j++) {\n            int diff = abs(xt[odd[i]] - xt[even[j]]);\n            if (isPrime(diff)) {\n                inst.add_edge(odd[i], even[j] + 500, 1);\n            }\n        }\n    }\n\n    REP(i,odd.size())  inst.add_edge(990, odd[i], 1);\n    REP(i,even.size()) inst.add_edge(even[i] + 500, 991, 1);\n\n    int maxt = inst.get_max (990, 991);\n\n    int ot = odd.size() - maxt;\n    int et = even.size() - maxt;\n\n    int two = ot / 2 + et / 2;\n    int three = ot % 2;\n    \n    cout << maxt + two * 2 + three * 3 << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define pb push_back\n\nusing namespace std;\n\nconst int MX = 10000001;\n\nint n , a, x[MX + 1], visId, match[300], vis[300];\nbool b[MX + 1], np[MX + 1];\nvector<int> me, mo, g[300];\n\nbool dfs(int u) {\n\tvis[u] = visId;\n\tfor (int i = 0 ; i < g[u].size(); ++i) {\n\t\tint v = g[u][i];\n\t\tif (match[v] == -1 || (vis[u] != visId && dfs(match[v]))) {\n\t\t\tmatch[v] = u;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n\n}\nint main() {\n\tfor (int i = 2; i <= MX; ++i) {\n\t\tif (!np[i])continue;\n\t\tfor (int j = i + i; j <= MX ; ++j)\n\t\t\tnp[j] = 1;\n\t}\n\tnp[0] = np[1] = np[2] = 1;\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; ++i) {\n\t\tscanf(\"%d\", &a);\n\t\tx[a] = 1;\n\t}\n\tfor (int i = 1; i <= MX ; ++i) {\n\t\tb[i] = x[i] != x[i - 1];\n\t\tif (b[i] && (i % 2 == 0))me.pb(i);\n\t\tif (b[i] && (i % 2 == 1))mo.pb(i);\n\t}\n\tfor (int i = 0; i < me.size(); ++i) {\n\t\tfor (int j = 0 ; j < mo.size(); ++j) {\n\t\t\tif (!np[abs(me[j] - mo[i])]) {\n\t\t\t\tg[i].pb(j);\n\t\t\t}\n\t\t}\n\t}\n\tint res = 0;\n\tfor (int i = 0; i < me.size(); ++i) {\n\t\tvisId++;\n\t\tif (dfs(i))res++;\n\t}\n\tint even = me.size() - res;\n\tint odd = mo.size() - res;\n\tint ans = res + (even / 2) * 2 + (odd / 2) * 2 + (odd%2)*3;\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \nconst int maxn = 1e7 + 700;\n \n \nint n,fre[maxn],p[220],ispr[maxn],even,odd,wrong;\nvector <int> edge[220],v2;\n \nbool fin(int u) {\n    if (fre[u]==wrong) return false;\n    fre[u]=wrong;\n    for (int j=0;j<edge[u].size();j++) {\n        int v=edge[u][j];\n       // cout<<u<<\" \"<<v<<endl;\n        if (p[v]==0 || fin(p[v])) {\n            p[v]=u;\n            return true;\n        }\n    }\n    return false;\n}\n \nint main() {\n  //  freopen(\"in.txt\",\"r\",stdin);\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    ispr[1]=1;\n    for (int i=2;i<maxn;i++)\n        if (ispr[i]==0) {\n            for (int j=i+i;j<maxn;j+=i) ispr[j]=1;\n        }\n    cin>>n;\n    for (int i=1;i<=n;i++) {\n        int x;\n        cin>>x;\n        fre[x]^=1;\n        fre[x+1]^=1;\n    }\n    even=0; odd=0; wrong=2;\n    for (int i=0;i<maxn;i++)\n        if (fre[i]==1) {\n            v2.push_back(i);\n            if (i%2==0) even++;\n            else odd++;\n        }\n    // for (int i=0;i<v2.size();i++) cout<<v2[i]<<\" \";\n   //  cout<<endl;\n   // cout<<\" \" <<even<<\" \"<<odd<<endl;\n    for (int i=0;i<v2.size();i++)\n        for (int j=0;j<v2.size();j++)\n            if (v2[i]%2==0 && v2[j]%2==1 && ispr[ abs(v2[j] - v2[i]) ]==0 && abs(v2[j] - v2[i])%2==1) {\n                edge[i].push_back(j);\n                edge[j].push_back(i);\n            }\n    int cnt=0;\n    for (int i=0;i<v2.size();i++)\n     if (p[i]==0) {\n        wrong++;\n        if (fin(i)) cnt++;\n    }\n    cout<< cnt + (even-cnt)/2 *2 + (odd-cnt)/2 * 2 + ((even-cnt)%2)*3;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<cmath>\n#include<vector>\n#include<queue>\n#include<map>\n#include<bitset>\n#include<set>\n#define N (200010)\n#define P ()\n#define M (11000010)\n#define inf (0x7f7f7f7f)\n#define rg register int\n#define Label puts(\"NAIVE\")\n#define spa print(' ')\n#define ent print('\\n')\n#define rand() (((rand())<<(15))^(rand()))\n#define file(s) freopen(s\".in\",\"r\",stdin),freopen(s\".out\",\"w\",stdout)\ntypedef long double ld;\ntypedef long long LL;\ntypedef unsigned long long ull;\nusing namespace std;\nnamespace fastIO1{\n\tinline char read(){\n\t\tstatic const int IN_LEN=1000000;\n\t\tstatic char buf[IN_LEN],*s,*t;\n\t\treturn (s==t?t=(s=buf)+fread(buf,1,IN_LEN,stdin),(s==t?-1:*s++):*s++);\n\t}\n\ttemplate<class T>\n\tinline void read(T &x){\n\t\tstatic bool iosig;\n\t\tstatic char c;\n\t\tfor(iosig=false,c=read();!isdigit(c);c=read()){\n\t\t\tif(c=='-')iosig=true;\n\t\t\tif(c==-1)return;\n\t\t}\n\t\tfor(x=0;isdigit(c);c=read())x=((x+(x<<2))<<1)+(c^'0');\n\t\tif(iosig)x=-x;\n\t}\n\tinline char readc(char &c){\n\t\tfor(c=read();!isalpha(c)&&!isdigit(c);c=read())\n\t\tif(c==-1)return 0;\n\t}\n\tconst int OUT_LEN = 10000000;\n\tchar obuf[OUT_LEN],*ooh=obuf;\n\tinline void print(char c) {\n\t\tif(ooh==obuf+OUT_LEN)fwrite(obuf,1,OUT_LEN,stdout),ooh=obuf;\n\t\t*ooh++=c;\n\t}\n\ttemplate<class T>\n\tinline void print(T x){\n\t\tstatic int buf[30],cnt;\n\t\tif(x==0)print('0');\n\t\telse{\n\t\t\tif(x<0)print('-'),x=-x;\n\t\t\tfor(cnt=0;x;x/=10)buf[++cnt]=x%10+48;\n\t\t\twhile(cnt)print((char)buf[cnt--]);\n\t\t}\n\t}\n\tinline void flush(){fwrite(obuf,1,ooh-obuf,stdout);}\n}\nnamespace fastIO2{\n\ttemplate<class T>\n\tinline void read(T &x){\n\t\tstatic bool iosig; \n\t\tstatic char c;\n\t\tfor(iosig=false,c=getchar();!isdigit(c);c=getchar()){\n\t\t\tif(c=='-')iosig=true;\n\t\t\tif(c==-1)return;\n\t\t}\n\t\tfor(x=0;isdigit(c);c=getchar())x=((x+(x<<2))<<1)+(c^'0');\n\t\tif(iosig)x=-x;\n\t}\n}\nusing namespace fastIO1;\nint n,a[M],prime[M],sum,cnt1,cnt2,od[N],ev[N];\nbool pr[M]; queue<int> Q; int dis[N],cur[N];\nint fi[N],ne[N<<4],to[N<<4],c[N<<4],S,T,V,E;\nbool bfs(int S,int T){\n\twhile(!Q.empty())Q.pop(); Q.push(S);\n\tfor(int i=1;i<=V;i++)dis[i]=inf,cur[i]=fi[i]; dis[S]=0;\n\twhile(!Q.empty()){\n\t\tint u=Q.front();Q.pop();\n\t\tfor(int i=fi[u];i;i=ne[i])\n\t\tif(c[i]&&dis[to[i]]==inf){\n\t\t\tint v=to[i];\n\t\t\tdis[v]=dis[u]+1;\n\t\t\tif(v==T)return 1; Q.push(v);\n\t\t}\n\t}\n\treturn dis[T]<=V;\n}\nint dfs(int u,int T,int flow){\n\tif(u==T)return flow;\n\tint usd=0;\n\tfor(int i=cur[u];i;i=cur[u]=ne[i])\n\tif(c[i]&&dis[to[i]]==dis[u]+1){\n\t\tint fl=dfs(to[i],T,min(flow-usd,c[i]));\n\t\tif(!fl)continue;c[i]-=fl,c[i^1]+=fl,usd+=fl;\n\t\tif(usd>=flow)return usd;\n\t}\n\treturn usd;\n}\nint dinic(int S,int T){\n\tint ans=0;\n\twhile(bfs(S,T))ans+=dfs(S,T,inf);\n\treturn ans;\t\n}\nvoid add(int x,int y,int z){\n\tne[++E]=fi[x],fi[x]=E,to[E]=y,c[E]=z;\n\tne[++E]=fi[y],fi[y]=E,to[E]=x,c[E]=z;\n}\nvoid Eular(int n){\n\tpr[1]=1;\n\tfor(int i=2;i<=n;i++){\n\t\tif(!pr[i]){\n\t\t\tprime[++sum]=i;\n\t\t\tif(i==2)pr[i]=1;\n\t\t}\n\t\tfor(int j=1;j<=sum;j++){\n\t\t\tif(prime[j]*i>n)break;\n\t\t\tpr[prime[j]*i]=1;if(i%prime[j]==0)break;\n\t\t}\n\t}\n}\nint main(){\n\tread(n),E=1;\n\tEular(10000010);\n\tfor(int i=1;i<=n;i++){\n\t\tint x; read(x);\n\t\ta[x]=1;\n\t}\n\tfor(int i=1;i<=10000001;i++)\n\tif(a[i]!=a[i-1]){if(i&1)od[++cnt1]=i;else ev[++cnt2]=i;}\n\tS=cnt1+cnt2+1,T=S+1,V=T;\n\tfor(int i=1;i<=cnt1;i++){\n\t\tadd(S,i,1);\n\t\tfor(int j=1;j<=cnt2;j++){\n\t\t\tint d=(int)abs(od[i]-ev[j]);\n\t\t\tif(!pr[d])add(i,j+cnt1,1);\n\t\t\tif(i==1)add(j+cnt1,T,1);\n\t\t}\n\t} \n\tint ans=dinic(S,T); cnt1-=ans,cnt2-=ans;\n\tcout<<ans+(cnt1/2)*2+(cnt2/2)*2+((cnt1&1)*3);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nbool up[10000002];\nvector<int> v1;\nvector<int> v2;\n\nint Nx,Ny;\nconst int MAXN = 200;\nvector<int> edgex[MAXN+1],edgey[MAXN+1];\nint matchx[MAXN+1],matchy[MAXN+1];\nbool visitx[MAXN+1],visity[MAXN+1];\nbool dfs(int x){\n   visitx[x]=true;\n   for(int i=0;i<edgex[x].size();i++){\n      int y=edgex[x][i];\n      visity[y]=true;\n      if(matchy[y]==-1||(!visitx[matchy[y]]&&dfs(matchy[y]))){\n         matchy[matchx[x]=y]=x;\n         return true;\n      }\n   }\n   return false;\n}\nint matching(){\n   memset(matchx,-1,sizeof matchx);\n   memset(matchy,-1,sizeof matchy);\n   int ans=0;\n   for(int i=0;i<Nx;i++){\n      memset(visitx,0,sizeof visitx);\n      memset(visity,0,sizeof visity);\n      if(dfs(i))  ans++;\n   }\n   return ans;\n}\nbool op(int x,int y){\n\tint tmp=abs(x-y);\n\tif(tmp==1||tmp==2)\treturn false;\n\tfor(long long int i=3;i*i<=tmp;i++)\n\t\tif(tmp%i==0)\n\t\t\treturn false;\n\treturn true;\n}\n\nint main(){\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\tint n;\n\tcin>>n;\n\tfor(int i=0,x;i<n;i++){\n\t\tcin>>x;\n\t\tup[x]=true;\n\t}\n\tfor(int i=1;i<=10000001;i++)\n\t\tif(up[i]!=up[i-1]){\n\t\t\tif(i&1)\n\t\t\t\tv1.push_back(i);\n\t\t\telse\n\t\t\t\tv2.push_back(i);\n\t\t}\n\tNx=v1.size();Ny=v2.size();\n\tfor(int i=0;i<Nx;i++)\n\t\tfor(int j=0;j<Ny;j++)\n\t\t\tif(op(v1[i],v2[j]))\n\t\t\t\tedgex[i].push_back(j),edgey[j].push_back(i);\n\tint k=matching();\n\tcout<<k+(Nx-k)/2*2+(Ny-k)/2*2+3*((Nx-k)&1)<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <iostream>\n#include <algorithm>\n#define fo(i,a,b) for(int i=a;i<=b;i++)\n#define fod(i,a,b) for(int i=a;i>=b;i--)\n#define N 2005\nusing namespace std;\nint l[N],n,a[N],r[N],w[N],pr[2000005],f[N],a1[N][N];\nbool bz[20000005],bp[N];\nvoid prp()\n{\n\tfo(i,2,20000000)\n\t{\n\t\tif(!bz[i]) pr[++pr[0]]=i;\n\t\tfor(int j=1;j<=pr[0]&&i*pr[j]<=20000000;j++)\n\t\t{\n\t\t\tbz[i*pr[j]]=1;\n\t\t\tif(i%pr[j]==0) break;\n\t\t}\n\t}\n\tbz[2]=0;\n}\nbool find(int k)\n{\n\tfo(i,1,a1[k][0])\n\t{\n\t\tint p=a1[k][i];\n\t\tif(!bp[p])\n\t\t{\n\t\t\tbp[p]=1;\n\t\t\tif(!f[p]||find(f[p])) \n\t\t\t{\n\t\t\t\tf[p]=k;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nint main()\n{\n\tcin>>n;\n\tprp();\n\tfo(i,1,n) scanf(\"%d\",&a[i]);\n\tsort(a+1,a+n+1);\n\tfo(i,1,n) \n\t{\n\t\tif(i==1||a[i-1]!=a[i]-1) w[++w[0]]=i;\n\t\tif(a[i+1]!=a[i]+1) w[++w[0]]=i+1;\n\t}\n\tsort(w+1,w+w[0]+1);\n\tfo(i,1,w[0]) \n\t\tif(w[i]%2==0) l[++l[0]]=i;\n\t\telse r[++r[0]]=i;\n\tfo(i,1,l[0])\n\t{\n\t\tfo(j,1,r[0])\n\t\t{\n\t\t\tif(bz[abs(l[i]-r[j])]) a1[i][++a1[i][0]]=j;\n\t\t}\n\t}\n\tlong long s=0;\n\tfo(i,1,l[0]) \n\t{\n\t\tmemset(bp,0,sizeof(bp));\n\t\tif(find(i)) s++;\n\t}\n\tprintf(\"%lld\",s+2*(long long)((l[0]-s)/2)+2*(long long)((r[0]-s)/2)+3*(long long)((l[0]-s)%2));\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\ntypedef long long ll;\nint odd=0,even=0,Odd[105],Even[105],ma[105];\nint flag[10000010],x[10000010],map[105][105],vis[105];\nint prime[10000010],a[105];\nint dfs(int u)\n{\n\tfor (int v=1;v<=even;v++)\n\t{\n\t\tif (!map[u][v]) continue;\n\t\tif (!vis[v])\n\t\t{\n\t\t\tvis[v]=1;\n\t\t\tif (ma[v]==-1||dfs(ma[v]))\n\t\t\t{\n\t\t\t\tma[v]=u;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nint main()\n{\n\tint n,cnt=0;\n\tscanf(\"%d\",&n);\n\tflag[1]=1;\n\tfor (int i=2;i<=10000001;i++)\n\t{\n\t\tif (!flag[i]) prime[++cnt]=i;\n\t\tfor (int j=1;j<=cnt;j++)\n\t\t{\n\t\t\tif (i*prime[j]>10000001) break;\n\t\t\tflag[i*prime[j]]=1;\n\t\t\tif (i%prime[j]==0) break;\n\t\t}\n\t}\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%d\",&a[i]);\n\t\tx[a[i]]^=1;\n\t}\n\tfor (int i=1;i<=10000001;i++)\n\t\tif (x[i]!=x[i-1])\n\t\t{\n\t\t\tif (i&1) Odd[++odd]=i;\n\t\t\telse Even[++even]=i; \n\t\t}\n\tfor (int i=1;i<=odd;i++)\n\t\tfor (int j=1;j<=even;j++)\n\t\t\tif (!flag[abs(Odd[i]-Even[j])]) map[i][j]=1;\n\tfor (int i=1;i<=even;i++)\n\t\tma[i]=-1;\n\tint sum=0;\n\tfor (int i=1;i<=odd;i++)\n\t{\n\t\tmemset(vis,0,sizeof(vis));\n\t\tif (dfs(i)) sum++;\n\t}\n\tint ans=sum+(((odd-sum)>>1)<<1)+(((even-sum)>>1)<<1)+(odd-sum)%2*3;\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cstring>\n#include <cmath>\nusing namespace std;\n\nconst int N = 205;\nconst int M = 1e7 + 5;\n\nint x[N], pos[N];\n\nclass BipartialGraph {\nprivate :\n  bool G[N][N], vis[N];\n  int lkn[N];\npublic :\n  BipartialGraph() {\n    memset(G, 0, sizeof G);\n  }\n  inline void Add(int x, int y) {\n    G[x][y] = 1;\n  }\n  inline bool Match(int x) {\n    for (int i = 0; i < N; i ++)\n      if (G[x][i] && !vis[i]) {\n\tvis[i] = 1;\n\tif (lkn[i] == -1 || Match(lkn[i])) {\n\t  lkn[i] = x;\n\t  return 1;\n\t}\n      }\n    return 0;\n  }\n  inline int MaxMatch() {\n    int ret = 0;\n    memset(lkn, -1, sizeof lkn);\n    for (int i = 0; i < N; i ++) {\n      memset(vis, 0, sizeof vis);\n      if (Match(i)) ret ++;\n    }\n    return ret;\n  }\n} solver;\n\nbool notp[M];\nint prime[700000];\n\ninline void  make_prime(int Max) {\n  int tot = 0;\n  for (int i = 2; i <= Max; i ++) {\n    if (!notp[i]) prime[++ tot] = i;\n    for (int j = 1; j <= tot && i * prime[j] <= Max; j ++) {\n      notp[i * prime[j]] = 1;\n      if (i % prime[j] == 0) break;\n    }\n  }\n  notp[0] = notp[1] = notp[2] = 1;\n}\n\nint main() {\n  int n, m = 0;\n  scanf(\"%d\", &n);\n  for (int i = 1; i <= n; i ++) scanf(\"%d\", &x[i]);\n  for (int i = 1; i <= n; i ++) {\n    if (i == 1 || x[i - 1] != x[i] - 1) pos[++ m] = x[i];\n    if (i == n || x[i + 1] != x[i] + 1) pos[++ m] = x[i] + 1;\n  }\n  make_prime(pos[m] - pos[1]);\n  for (int i = 1; i <= m; i ++) {\n    if (pos[i] & 1) continue;\n    for (int j = 1; j <= m; j ++)\n      if ((pos[j] & 1) && !notp[abs(pos[j] - pos[i])]) solver.Add(i, j);\n  }\n  int k = solver.MaxMatch(), ev = 0, od = 0;\n  for (int i = 1; i <= m; i ++) {\n    if (pos[i] & 1) od ++;\n    else ev ++;\n  }\n  ev -= k; od -= k;\n  int ans = k + (ev / 2 + od / 2) * 2 + 3 * (ev & 1);\n  printf(\"%d\\n\", ans);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 1000000007LL\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nstruct edge{\n\tint to,cap,rev;\n\tedge(){}\n\tedge(int tt,int cc,int rr){\n\t\tto=tt;\n\t\tcap=cc;\n\t\trev=rr;\n\t}\n};\n\nvector<edge> G[501];\nint level[501];\nint iter[501];\n\nvoid add_edge(int from,int to,int cap){\n\tG[from].push_back(edge(to,cap,G[to].size()));\n\tG[to].push_back(edge(from,0,G[from].size()-1));\n}\n\nvoid bfs(int s){\n\tmemset(level,-1,sizeof(level));\n\tqueue<int> que;\n\tlevel[s]=0;\n\tque.push(s);\n\twhile(que.size()){\n\t\tint v=que.front();\n\t\tque.pop();\n\t\tfor(int i=0;i<G[v].size();i++){\n\t\t\tedge &e=G[v][i];\n\t\t\tif(e.cap>0 && level[e.to]<0){\n\t\t\t\tlevel[e.to]=level[v]+1;\n\t\t\t\tque.push(e.to);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint dfs(int v,int t,int f){\n\tif(v==t)return f;\n\tfor(int &i=iter[v];i<G[v].size();i++){\n\t\tedge &e=G[v][i];\n\t\tif(e.cap>0 && level[v]<level[e.to]){\n\t\t\tint d=dfs(e.to,t,min(f,e.cap));\n\t\t\tif(d>0){\n\t\t\t\te.cap-=d;\t\t\t\n\t\t\t\tG[e.to][e.rev].cap+=d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint max_flow(int s,int t){\n\tint flow=0;\n\twhile(1){\n\t\tbfs(s);\n\t\tif(level[t]<0)return flow;\n\t\tmemset(iter,0,sizeof(iter));\n\t\tint f;\n\t\twhile((f=dfs(s,t,1000))>0){\n\t\t\tflow+=f;\n\t\t}\n\t}\n}\n\nint n;\nint x[101];\nint a[10000001];\nint b[10000001];\n\nint prime(int x){\n\tif(x<=2)return 3;\n\tbool flag=true;\n\tfor(int i=2;i*i<=x;i++){\n\t\tif(x%i==0)return 3;\n\t}\n\treturn 1;\n}\n\nint main(void){\n\tscanf(\"%d\",&n);\n\tfor(int i=0;i<n;i++){\n\t\tscanf(\"%d\",&x[i]);\n\t\ta[x[i]]=1;\n\t}\n\tvector<int> colt[2];\n\tfor(int i=1;i<=x[n-1]+1;i++){\n\t\tb[i]=a[i-1]^a[i];\n\t\tif(b[i]==1){\n\t\t\tcolt[i%2].push_back(i);\n\t\t}\n\t}\n\tint s=colt[0].size()+colt[1].size();\n\tint t=s+1;\n\tfor(int i=0;i<colt[0].size();i++){\n\t\tfor(int j=0;j<colt[1].size();j++){\n\t\t\tint val=prime(abs(colt[0][i]-colt[1][j]));\n\t\t\tif(val==1)add_edge(i,colt[0].size()+j,val);\n\t\t}\n\t}\n\tfor(int i=0;i<colt[0].size();i++){\n\t\tadd_edge(s,i,1);\n\t}\n\tfor(int i=0;i<colt[1].size();i++){\n\t\tadd_edge(colt[0].size()+i,t,1);\n\t}\n\tint cnt=max_flow(s,t);\n\tint res=0;\n\tres+=((int)colt[0].size()-cnt)/2*2;\n\tres+=((int)colt[1].size()-cnt)/2*2;\n\tres+=(((int)colt[0].size()-cnt)%2)*3;\n\tres+=cnt;\n\tprintf(\"%d\\n\",res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int MAXN = 1000100;\n\n#define rep(i, a, b) for(int i = a; i < (b); ++i)\n#define trav(a, x) for(auto& a : x)\n#define all(x) begin(x), end(x)\n#define sz(x) (int)(x).size()\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\nint N;\nint arr[MAXN];\n \nstruct Dinic {\n    struct Edge {\n        int to, rev;\n        ll c, f;\n    };\n    vi lvl, ptr, q;\n    vector<vector<Edge>> adj;\n    Dinic(int n) : lvl(n), ptr(n), q(n), adj(n) {}\n    void addEdge(int a, int b, ll c, int rcap = 0) {\n        adj[a].push_back({b, sz(adj[b]), c, 0});\n        adj[b].push_back({a, sz(adj[a]) - 1, rcap, 0});\n    }\n    ll dfs(int v, int t, ll f) {\n        if (v == t || !f) return f;\n        for (int& i = ptr[v]; i < sz(adj[v]); i++) {\n            Edge& e = adj[v][i];\n            if (lvl[e.to] == lvl[v] + 1)\n                if (ll p = dfs(e.to, t, min(f, e.c - e.f))) {\n                    e.f += p, adj[e.to][e.rev].f -= p;\n                    return p;\n                }\n        }\n        return 0;\n    }\n    ll calc(int s, int t) {\n        ll flow = 0; q[0] = s;\n        rep(L,0,31) do { // 'int L=30' maybe faster for random data\n            lvl = ptr = vi(sz(q));\n            int qi = 0, qe = lvl[s] = 1;\n            while (qi < qe && !lvl[t]) {\n                int v = q[qi++];\n                trav(e, adj[v])\n                    if (!lvl[e.to] && (e.c - e.f) >> (30 - L))\n                        q[qe++] = e.to, lvl[e.to] = lvl[v] + 1;\n            }\n            while (ll p = dfs(s, t, LLONG_MAX)) flow += p;\n        } while (lvl[t]);\n        return flow;\n    }\n};\n\nbool pr (int x)\n{\n    if (x == 1) return false;\n    for (int i = 2; i * i <= x; i++)\n        if (x % i == 0) return false;\n    return true;\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(0);\n\n    cin >> N;\n    for (int i = 0; i < N; i++)\n        cin >> arr[i];\n    vector <int> v;\n    for (int i = 0; i < N; i++)\n    {\n        if (i == 0 || arr[i-1] + 1 < arr[i])\n            v.push_back(arr[i]);\n        if (i == N - 1 || arr[i+1] - 1 > arr[i])\n            v.push_back(arr[i]+1);\n    }\n\n    int m = v.size();\n    Dinic d (m + 2);\n    int ne = 0, no = 0;\n    for (int i = 0; i < m; i++)\n    {\n        if (v[i] % 2 == 0)\n        {\n            d.addEdge (m, i, 1);\n            ne++;\n        }\n        else\n        {\n            d.addEdge (i, m + 1, 1);\n            no++;\n        }\n    }\n    for (int i = 0; i < m; i++)\n        for (int j = 0; j < m; j++)\n        {\n            if (v[i] % 2 == 0 && v[j] % 2 == 1)\n            {\n                if (pr (abs (v[i] - v[j])))\n                {\n                    //cout << i << \" \" << j << \"\\n\";\n                    d.addEdge (i, j, 1);\n                }\n            }\n        }\n\n    int r = d.calc (m, m + 1);\n\n    //cout << r << \" \" << ne << \" \" << no << \"\\n\";\n    int res = r;\n    ne -= r;\n    no -= r;\n    res += 2 * (ne / 2 + no / 2);\n    res += 3 * (ne % 2);\n    cout << res << \"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 10000005\n#define M 205\nusing namespace std;\nint n,cnt1=0,cnt2=0,cnt,p1[M],p2[M],a[M],b[N],pr[M*M*100],match[N];bool vis[N],used[M],mp[M][M];\nbool dfs(int u){\n\tfor (int i=1;i<=cnt2;i++){\n\t\tif (!mp[u][i]||used[i]) continue;\n\t\tused[i]=1;\n\t\tif (!match[i]||dfs(match[i])){\n\t\t\tmatch[i]=u;\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\nint main(){\n\tscanf(\"%d\",&n);int mx=0;\n\tfor (int i=1;i<=n;i++) scanf(\"%d\",&a[i]),b[a[i]]=1,mx=max(mx,a[i]);\n\tfor (int i=1;i<=mx+1;i++)\n\t\tif (b[i]!=b[i-1]){\n\t\t\tif (i&1) p1[++cnt1]=i;\n\t\t\telse p2[++cnt2]=i;\n\t\t}\n\tfor (int i=2;i<=1e7;i++){\n\t\tif (!vis[i]) pr[++cnt]=i;\n\t\tfor (int j=1;j<=cnt;j++){\n\t\t\tif (i*pr[j]>=N) break;\n\t\t\tvis[i*pr[j]]=1;\n\t\t\tif (i%pr[j]==0) break;\n\t\t}\n\t}\n\tvis[2]=vis[1]=1;int ans=0;\n\tfor (int i=1;i<=cnt1;i++)\n\t\tfor (int j=1;j<=cnt2;j++)\n\t\t\tif (!vis[abs(p1[i]-p2[j])]) mp[i][j]=1;\n\tfor (int i=1;i<=cnt1;i++){\n\t\tmemset(used,0,sizeof(used));\n\t\tif (dfs(i)) ans++;\n\t}\n\tint now1=cnt1-ans;int now2=cnt2-ans;\n\tans=ans+(now1/2)*2+(now2/2)*2;\n\tif (now1&1) ans+=3;\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint n,b,ans=0;\nint a[105],f[105][105];\nint x[2][105],cnt[2],c;\nint p[10000005],prime[3000005],tot=0;\nint vis[105],link[105];\n\nint dfs(int x){\n\tfor(int i=1;i<=cnt[1];i++){\n\t\tif(vis[i]==0&&f[x][i]==1){\n\t\t\tvis[i]=1;\n\t\t\tif(link[i]==0||dfs(link[i])){\n\t\t\t\tlink[i]=x;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint main(){\n\tscanf(\"%d\",&n);\n\ta[0]=-1;\n\tfor(int i=2;i<=10000000;i++){\n\t\tif(p[i]==0) prime[++tot]=i;\n\t\tfor(int j=1;j<=tot&&i*prime[j]<=10000000;j++){\n\t\t\tp[i*prime[j]]=1;\n\t\t\tif(i%prime[j]==0) break;\n\t\t}\n\t}\n\tp[1]=p[2]=1;\n\tfor(int i=1;i<=n;i++) scanf(\"%d\",&a[i]);\n\tfor(int i=1;i<=n;i++){\n\t\tif(a[i]==a[i-1]+1) continue;\n\t\tif(a[i-1]!=-1) x[c=(a[i-1]+1)&1][++cnt[c]]=a[i-1]+1;\n\t\tx[c=a[i]&1][++cnt[c]]=a[i];\n\t}\n\tx[c=(a[n]+1)&1][++cnt[c]]=a[n]+1;\n\tfor(int i=1;i<=cnt[0];i++){\n\t\tfor(int j=1;j<=cnt[1];j++){\n\t\t\tif(p[abs(x[0][i]-x[1][j])]==0) f[i][j]=1;\n\t\t}\n\t}\n\tfor(int i=1;i<=cnt[0];i++){\n\t\tmemset(vis,0,sizeof(vis));\n\t\tif(dfs(i)) ans++;\n\t}\n\tcnt[1]-=ans,cnt[0]-=ans;\n\tans+=2*(cnt[1]/2+cnt[0]/2);\n\tif(cnt[1]&1) ans+=3;\n\tprintf(\"%d\\n\",ans);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 10000010;\n\n\nint n,fre[maxn],p[maxn],isprime[maxn],even,odd,wrong;\nvector <int> edge[maxn],v2;\n\nbool fin(int u) {\n    if (fre[u]=wrong) return false;\n    fre[u]=wrong;\n    for (int j=0;j<edge[u].size();j++) {\n        int v=edge[u][j];\n        if (p[v]=0 || fin(p[v])) {\n            p[u]=v;\n            p[v]=u;\n            return true;\n        }\n    }\n    return false;\n}\n\nint main() {\n  //  freopen(\"in.txt\",\"r\",stdin);\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    isprime[1]=1;\n    for (int i=2;i<=maxn;i++)\n        if (isprime[i]==0) {\n            for (int j=i+i;j<=maxn;j+=i) isprime[j]=1;\n        }\n    cin>>n;\n    for (int i=1;i<=n;i++) {\n        int x;\n        cin>>x;\n        fre[x]=1;\n    }\n    even=0; odd=0; wrong=2;\n    int id=1;\n    while (id<=maxn) {\n        if (fre[id]==0) id++;\n        else {\n            v2.push_back(id);\n            if (id%2==0) even++; else odd++ ;\n            id++;\n            while (id<=maxn && fre[id]==1) id++;\n            v2.push_back(id);\n            if (id%2==0) even++; else odd++ ;\n        }\n    }\n    // for (int i=0;i<v2.size();i++) cout<<v2[i]<<\" \";\n   //  cout<<endl;\n   // cout<<\" \" <<even<<\" \"<<odd<<endl;\n    for (int i=0;i<v2.size();i++)\n        for (int j=i+1;j<v2.size();j++)\n            if (isprime[ v2[j] - v2[i] ]==0) {\n                edge[i+1].push_back(j+1);\n                edge[j+1].push_back(i+1);\n            }\n    int cnt=0;\n    for (int i=0;i<v2.size();i++) {\n        wrong++;\n        cnt+=(fin(i));\n    }\n   // cout<<cnt<<\" \" <<even<<\" \"<<odd<<endl;\n    cout<< cnt + ((even-cnt)/2 + (odd-cnt)/2) * 2 + (even%2)*3;\n}\n"
  },
  {
    "language": "C++",
    "code": "/********************************************************************************\n\t\n\tCode by a weak man named CYJian, and he hopes the code can get more points.\n\n\tAlgorithm: \n\n ********************************************************************************/\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\n//{{{ FAST IO AND SOME FUNCTIONS\nconst int __SIZE = 1 << 18;\nchar ibuf[__SIZE], *iS, *iT;\n\n#define ge (iS == iT ? (iT = (iS = ibuf) + fread(ibuf, 1, __SIZE, stdin), (iS == iT ? EOF : *iS++)) : *iS++)\n#define ri read_int()\n#define rl read_ll()\n#define FILE(s) freopen(s\"in\", \"r\", stdin), freopen(s\"out\", \"w\", stdout)\n\ntemplate<typename T>\ninline void read(T &x) {\n\tchar ch, t = 0; x = 0;\n\twhile(!isdigit(ch = ge)) t |= ch == '-';\n\twhile(isdigit(ch)) x = x * 10 + (ch ^ 48), ch = ge;\n\tx = t ? -x : x;\n}\ninline int read_int() { int x; return read(x), x; }\ninline ll read_ll() { ll x; return read(x), x; }\n\ntemplate<typename T> inline void chkmin(T&a, T b) { a = a < b ? a : b; }\ntemplate<typename T> inline void chkmax(T&a, T b) { a = a > b ? a : b; }\n//}}}\n\nint tot;\nint pri[5010];\nint chk[5010];\n\ninline void Sieve(int n) {\n\tchk[1] = 0;\n\tfor(int i = 2; i <= n; i++) {\n\t\tif(!chk[i]) pri[++tot] = i;\n\t\tfor(int j = 1; j <= tot; j++) {\n\t\t\tif(i * pri[j] > n) break;\n\t\t\tchk[i * pri[j]] = 0;\n\t\t\tif(i % pri[j] == 0) break;\n\t\t}\n\t}\n}\n\ninline int check(int x) {\n\tif(x <= 5000) return !chk[x];\n\tfor(int *p = pri + 1;; ++p) {\n\t\tif((*p) * (*p) > x) return 1;\n\t\tif(x % (*p) == 0) return 0;\n\t}\n}\n\nvector<int>to[210];\nint vis[210];\nint p[210];\nint N;\n\ninline int Try(int x) {\n\tcerr << x << endl;\n\tinq[x] = 1;\n\tfor(auto u : to[x]) {\n\t\tif(!vis[u]) {\n\t\t\tvis[u] = x;\n\t\t\tvis[x] = u;\n\t\t\tinq[x] = 0;\n\t\t\treturn 1;\n\t\t} else if(!inq[vis[u]] && Try(vis[u])) {\n\t\t\tvis[u] = x;\n\t\t\tvis[x] = u;\n\t\t\tinq[x] = 0;\n\t\t\treturn 1;\n\t\t}\n\t} return inq[x] = 0;\n}\n\nint main() {\n#ifdef LOCAL\n\tFILE(\"\");\n#endif\n\n\tSieve(5000);\n\tint n = ri, ce = 0, co = 0;\n\n\tfor(int i = 1; i <= n; i++) {\n\t\tint x = ri;\n\t\tif(p[N] == x) --N;\n\t\telse p[++N] = x;\n\t\tp[++N] = x + 1;\n\t}\n\n\tfor(int i = 1; i <= N; i++) \n\t\tp[i] & 1 ? ++co : ++ce;\n\n\tfor(int i = 1; i <= N; i++)\n\t\tfor(int j = i + 1; j <= N; j++) {\n\t\t\tif(((p[i] ^ p[j]) & 1) && check(p[j] - p[i]))\n\t\t\t\tto[i].push_back(j), to[j].push_back(i);\n\t\t}\n\n\tint res = 0;\n\tfor(int i = 1; i <= N; i++)\n\t\tif((p[i] & 1) && Try(i))\n\t\t\t--co, --ce, ++res;\n\n\tres += (co / 2 + ce / 2) << 1;\n\tif((co | ce) & 1) res += 3;\n\n\tcout << res << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fi first\n#define se second\n#define pii pair<int,int>\n#define mp make_pair\n#define pb push_back\n#define space putchar(' ')\n#define enter putchar('\\n')\n#define MAXN 200005\n#define eps 1e-12\n//#define ivorysi\nusing namespace std;\ntypedef long long int64;\ntypedef unsigned int u32;\ntypedef double db;\ntemplate<class T>\nvoid read(T &res) {\n    res = 0;T f = 1;char c = getchar();\n    while(c < '0' || c > '9') {\n        if(c == '-') f = -1;\n        c = getchar();\n    }\n    while(c >= '0' && c <= '9') {\n        res = res * 10 + c - '0';\n        c = getchar();\n    }\n    res *= f;\n}\ntemplate<class T>\nvoid out(T x) {\n    if(x < 0) {x = -x;putchar('-');}\n    if(x >= 10) {\n        out(x / 10);\n    }\n    putchar('0' + x % 10);\n}\nint N;\nbool nonprime[10000005],vis[10000005];\nint prime[10000005],tot,x[205],b[205],M[2],matc[205];\nvector<int> to[505];\nbool used[205];\nbool match(int u) {\n    for(auto t : to[u]) {\n        if(!used[t]) {\n            used[t] = 1;\n            if(!matc[t] || match(matc[t])) {\n                matc[t] = u;\n                return true;\n            }\n        }\n    }\n    return false;\n}\nvoid Solve() {\n    read(N);\n    for(int i = 1 ; i <= N ; ++i) {\n        read(x[i]);\n        vis[x[i]] = 1;\n    }\n    for(int i = 2 ; i <= 10000000 ; ++i) {\n        if(!nonprime[i]) {\n            prime[++tot] = i;\n        }\n        for(int j = 1 ; j <= tot ; ++j) {\n            if(prime[j] > 10000000 / i) break;\n            nonprime[i * prime[j]] = 1;\n            if(i % prime[j] == 0) break;\n        }\n    }\n    tot = 0;\n    for(int i = 1 ; i <= 10000001 ; ++i) {\n        if(vis[i] != vis[i - 1]) b[++tot] = i;\n    }\n    for(int i = 1 ; i <= tot ; ++i) {\n        M[b[i] & 1]++;\n        for(int j = 1 ; j <= tot ; ++j) {\n            if(i == j) continue;\n            if(!nonprime[abs(b[i] - b[j])]) to[i].pb(j);\n        }\n    }\n    int ans = 0;\n    for(int i = 1 ; i <= tot ; ++i) {\n        if(b[i] & 1) {\n            memset(used,0,sizeof(used));\n            if(match(i)) ++ans;\n        }\n    }\n    out(ans + ((M[0] - ans) / 2 + (M[1] - ans) / 2) * 2 + ((M[0] - ans) & 1) * 3);enter;\n}\nint main() {\n#ifdef ivorysi\n\tfreopen(\"f1.in\",\"r\",stdin);\n#endif\n    Solve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<cstring>\n\nusing namespace std;\nint n;\nconst int maxn = 1e7+5;//40M\nconst int S = 1e7+2;\nint pri[maxn],cnt; bool mk[maxn];\nint A[maxn];\nvoid oula() {\n\tmk[1] = mk[0] = 1;\n\tfor(int i=1;i<=S;i++) {\n\t\tif(!mk[i]) { pri[++cnt]=i; }\n\t\tfor(int j=1;j<=cnt&&1ll*pri[j]*i<=S;j++) {\n\t\t\tint k = pri[j]*i;\n\t\t\tmk[k] = 1;\n\t\t\tif(i%pri[j]==0) break;\n\t\t}\n\t}\n}\nint la[405],en[405*405],owo,nt[405*405];\nvoid adg(int x,int y) {\n\ten[++owo]=y; nt[owo]=la[x]; la[x]=owo;\n}\nint cc[2];\nint yo[2][405];\nint link[405],vis[405];\nbool hungary(int x) {\n\tfor(int it=la[x];it;it=nt[it]) {\n\t\tint y = en[it];\n\t\tif(vis[y]) continue;\n\t\tvis[y] = 1;\n\t\tif((!link[y])||(hungary(link[y]))) {\n\t\t\tlink[y] = x; return 1;\n\t\t}\n\t}\n\treturn 0;\n}\nint main() {\n\toula();\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++) {\n\t\tint x; scanf(\"%d\",&x); A[x] = 1;\n\t}\n\tfor(int i=1;i<=S;i++) {\n\t\tint cf = A[i-1]^A[i];\n\t\tif(cf) {\n\t\t\t++cc[i&1];\n\t\t\tyo[i&1][cc[i&1]] = i;\n\t\t}\n\t}\n\tfor(int i=1;i<=cc[0];i++) {\n\t\tfor(int j=1;j<=cc[1];j++) {\n\t\t\tif(!mk[abs(yo[0][i]-yo[1][i])]) adg(i,j+cc[0]);\n\t\t}\n\t}\n\tint ans = 0;\n\tfor(int i=1;i<=cc[0];i++) {\n\t\tfor(int j=1;j<=cc[1];j++) vis[j] = 0;\n\t\tans += hungary(i);\n\t}\n\tcc[0]-=ans; cc[1]-=ans;\n\tprintf(\"%d\",ans+cc[0]/2*2 + cc[1]/2*2 + (cc[0]&1)*3 );\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <queue>\n#define MAXN 210\n#define MAXM 10000010\nusing namespace std;\n\nstruct edge{\n\tint to,next,w;\n\tedge(int _to=0,int _next=0,int _w=0):to(_to),next(_next),w(_w){}\n}e[MAXM];\n\nint n,m,S,T;\nint g[MAXN],nume;\nbool flag[MAXM];\nint prime[MAXM],nump;\nint p0[MAXN],p[MAXN],tag[MAXN];\nint level[MAXN];\n\nvoid addEdge(int u,int v,int w){\n\te[nume]=edge(v,g[u],w);\n\tg[u]=nume++;\n\te[nume]=edge(u,g[v],0);\n\tg[v]=nume++;\n}\n\nvoid init(){\n\tflag[1]=1;\n\tfor(int i=2;i<MAXM;i++){\n\t\tif(!flag[i]) prime[++nump]=i;\n\t\tfor(int j=1;j<=nump && i*prime[j]<MAXM;j++){\n\t\t\tflag[i*prime[j]]=1;\n\t\t\tif(i%prime[j]==0) break;\n\t\t}\n\t}\n\tflag[2]=1;\n}\n\nbool bfs(){\n\tmemset(level,-1,sizeof level);\n\tstatic queue<int> Q;\n\tQ.push(S);\n\tlevel[S]=0;\n\twhile(!Q.empty()){\n\t\tint x=Q.front();\n\t\tQ.pop();\n\t\tfor(int i=g[x];~i;i=e[i].next)\n\t\t\tif(e[i].w && level[e[i].to]==-1){\n\t\t\t\tlevel[e[i].to]=level[x]+1;\n\t\t\t\tQ.push(e[i].to);\n\t\t\t}\n\t}\n\treturn level[T]!=-1;\n}\n\nint dfs(int x,int delta){\n\tif(x==T) return delta;\n\tif(!delta) return 0;\n\tint res=0;\n\tfor(int i=g[x];~i;i=e[i].next)\n\t\tif(e[i].w && level[e[i].to]==level[x]+1){\n\t\t\tint temp=dfs(e[i].to,min(delta,e[i].w));\n\t\t\tdelta-=temp;\n\t\t\tres+=temp;\n\t\t\te[i].w-=temp;\n\t\t\te[i^1].w+=temp;\n\t\t\tif(!delta) return res;\n\t\t}\n\treturn res;\n}\n\nint main(){\n#ifdef DEBUG\n\tfreopen(\"F.in\",\"r\",stdin);\n#endif\n\tmemset(g,-1,sizeof g);\n\tinit();\n\tscanf(\"%d\",&m);\n\tfor(int i=1;i<=m;i++) scanf(\"%d\",p0+i);\n\tp[++n]=p0[1]-1;\n\tfor(int i=1;i<m;i++)\n\t\tif(p0[i]+1<p0[i+1]){\n\t\t\tp[++n]=p0[i];\n\t\t\tp[++n]=p0[i+1]-1;\n\t\t}\n\tp[++n]=p0[m];\n\tint c0=0,c1=0;\n\tfor(int i=1;i<=n;i++)\n\t\tif(p[i]&1) tag[i]=1,c1++;\n\t\telse c0++;\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tif(!tag[i] && tag[j] && !flag[abs(p[i]-p[j])])\n\t\t\t\taddEdge(i,j,1);\n\tS=n+1; T=n+2;\n\tfor(int i=1;i<=n;i++)\n\t\tif(tag[i]) addEdge(i,T,1);\n\t\telse addEdge(S,i,1);\n\tint flow=0;\n\twhile(bfs()) flow+=dfs(S,0x77777777);\n\tint ans=flow+((c0-flow)/2+(c1-flow)/2)*2+((c0-flow)%2)*3;\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define L long long\n#define pb push_back\n#define pi pair<int,int>\n#define pii pair<pair<int,int>,int>\n#define aa first\n#define bb second\n#define mp make_pair\n#define mpp(a,b,c) mp(mp(a,b),c)\nusing namespace std;\n#define SZ 666666\ntypedef long long ll;\nint fst[SZ],nxt[SZ],vb[SZ],cap[SZ],ff[SZ],M=1,N=0;\n#define add ad_dl\nvoid _ad_dl(int a,int b,int c) {++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;cap[M]=c;}\nvoid ad_dl(int a,int b,int c)\n{_ad_dl(a,b,c); _ad_dl(b,a,0);}\nint S,T,q[SZ],d[SZ];\nbool bfs()\n{\n    memset(d,-1,4*(N+1));\n    d[T]=0; q[1]=T; int h=1,t=2;\n    while(h!=t)\n    {\n        int cur=q[h++];\n        for(int e=fst[cur];e;e=nxt[e])\n        {\n            int b=vb[e];\n            if(d[b]==-1&&cap[e^1])\n            {\n                d[b]=d[cur]+1, q[t++]=b;\n                if(b==S) return 1; //???? \n            }\n        }\n    }\n    return d[S]!=-1;\n}\nint dfs(int x,int f)\n{\n    if(f<=0) return 0;\n    if(x==T) return f;\n    int ca=0;\n    for(int& e=fst[x];e;e=nxt[e]) //????? \n    {\n        int b=vb[e];\n        if(d[b]+1!=d[x]) continue;\n        int w=dfs(b,(cap[e]<f-ca)?cap[e]:(f-ca));\n        cap[e]-=w; cap[e^1]+=w; ca+=w;\n        if(ca==f) break;\n    }\n    if(!ca) d[x]=-1; //????? \n    return ca;\n}\n#define inf 2e9+3\nint dinic()\n{\n    int ans=0;\n    memcpy(ff,fst,4*(N+1));\n    while(bfs())\n    {\n        //?????\n        ans+=dfs(S,inf);\n        memcpy(fst,ff,4*(N+1));\n    }\n    return ans;\n}\nint n,m,x[110],f[210],p;\nbool a[10000010];\nint main()\n{\n\t//freopen(\".in\",\"r\",stdin);\n\t//freopen(\".out\",\"w\",stdout);\n\tint i,j,k;\n\tscanf(\"%d\",&n);\n\tfor(i=1;i<=n;i++)\n\t  scanf(\"%d\",&x[i]);\n\tfor(i=2;i<=n;i++)\n\t  if(x[i-1]+1!=x[i])\n\t    {\n\t\t f[++m]=x[i-1]+1;\n\t\t f[++m]=x[i];\n\t\t}\n\tf[++m]=x[1];\n\tx[++m]=x[n]+1;\n\ta[1]=1;\n\tfor(i=2;i<=1e7;i++)\n\t  if(!a[i])\n\t    for(j=i;j<=1e7;j+=i)\n\t      a[j]=1;\n\ta[2]=1;\n\tN=m+1;\n\tS=0;\n\tT=m+1;\n\tfor(i=1;i<=m;i++)\n\t  if(x[i]&1)\n\t    add(0,i,1);\n\t  else\n\t    add(i,m+1,1);\n\tfor(i=1;i<=m;i++)\n\t  for(j=1;j<=m;j++)\n\t    if(x[i]&1 && !a[abs(x[i]-x[j])])\n\t      add(i,j,1);\n\tp=k=dinic();\n\tfor(i=1,j=-k;i<=m;i++)\n\t  if(x[i]&1)\n\t    j++;\n\tp+=j/2*2;\n\tif(j&1)\n\t  p+=3;\n\tfor(i=1,j=-k;i<=m;i++)\n\t  if(!(x[i]&1))\n\t    j++;\n\tp+=j/2*2;\n\tprintf(\"%d\\n\",p);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define REP(i, n) for (int i = 0; i < int(n); ++i)\n#define REPE(i, a, b) for (int i = (a); i <= int(b); ++i)\n#define SZ(x) ((int)(x).size())\n#define ALL(x) x.begin(), x.end()\n#define PB push_back\n#define EB emplace_back\nusing LL = long long;\nusing PII = pair<int, int>;\n#define F first\n#define S second\n\nnamespace BPM {\nconst int maxn = 110;\nvector<int> g[maxn];\nint n, m, l[maxn];\nbool vis[maxn];\nbool match(int x) {\n  for (int y : g[x])\n    if (!vis[y]) {\n      vis[y] = true;\n      if (l[y] == -1 || match(l[y])) {\n        l[y] = x;\n        return true;\n      }\n    }\n  return false;\n}\nint solve() {\n  memset(l, -1, sizeof l);\n  int ans = 0;\n  for (int i = 0; i < n; ++i) {\n    memset(vis, 0, sizeof vis);\n    if (match(i))\n      ans++;\n  }\n  return ans;\n}\n}\n\nnamespace Sieve {\nconst int maxn = 1e7 + 10;\nbool vis[maxn] = {};\nvector<int> prime;\nvoid linear_sieve(int n) {\n  for (int i = 2; i < n; ++i) {\n    if (!vis[i]) {\n      prime.push_back(i);\n    }\n    for (int y : prime) {\n      if (1LL * i * y >= n)\n        break;\n      int t = i * y;\n      vis[t] = true;\n      if (i % y == 0) {\n        break;\n      }\n    }\n  }\n}\n}\n\nint n, a[110];\nvector<int> b[2];\nint main() {\n  Sieve::linear_sieve(Sieve::maxn);\n  scanf(\"%d\", &n);\n  set<int> s;\n  REP(i, n) {\n    scanf(\"%d\", &a[i]);\n  }\n  REP(i, n) {\n    if (i == 0 || a[i] - 1 != a[i - 1]) s.insert(a[i]);\n    if (i == n - 1 || a[i] + 1 != a[i + 1]) s.insert(a[i] + 1);\n  }\n  for (int x : s) b[x&1].PB(x);\n  BPM::n = SZ(b[0]);\n  BPM::m = SZ(b[1]);\n  REP(i, BPM::n) REP(j, BPM::m) {\n    int d = abs(b[0][i] - b[1][j]);\n    if (d >= 3 && !Sieve::vis[d]) BPM::g[i].PB(j);\n  }\n  int k = BPM::solve();\n  int ans = k + ((BPM::n - k) / 2 + (BPM::m - k) / 2) * 2 + ((BPM::n - k) % 2) * 3;\n  printf(\"%d\\n\", ans);\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <algorithm>\n#include <queue>\n#include <vector>\n#include <stack>\n#include <cmath>\n#include <memory.h>\n#include <iomanip>\n#include <cassert>\nusing namespace std;\n\n#define maxn 202\n#define FOR(i, l, r) for (int i=l; i<=r; ++i)\n#define FORD(i, r, l) for (int i=r; i>=l; --i)\n#define REP(i, r) for (int i=0; i<(int)r; ++i)\n#define REPD(i, r) for (int i=(int)r-1; i>=0; --i)\n#define fi first\n#define se second\n#define mk make_pair\n#define nil NULL\n#define y0 y902\n#define y1 y232\n#define x0 x92\n#define x1 x899\n#define next asdfa\n#define sz size\n#define Debug(X) {cerr << #X << \" = \" << X << '\\n';}\n#define PR(A, n) {cerr << #A << \" = \"; FOR(i, 1, n) cerr << A[i] << ' '; cerr << '\\n';}\n#define PR0(A, n) {cerr << #A << \" = \"; REP(i, n) cerr << A[i] << ' '; cerr << '\\n';}\ntypedef long long ll;\ntypedef double db;\ntypedef pair<db, db> dd;\ntypedef pair<int, int> ii;\ntypedef vector<int> vi;\nconst int inf = 1e9;\ntemplate<class T> int getbit(T x, int pos) {return (x>>(pos-1)) & 1;}\ntemplate<class T> void turn_on(T &x, int pos) {x = x | ((T)1<<(pos-1));}\ntemplate<class T> void turn_off(T &x, int pos) {x = x & ~((T)1<<(pos-1));}\ntemplate<class T> T sqr(T a) {return a*a;}\n\nint n, assigned[maxn], visited[maxn], t;\nvector<int> a[maxn], even, odd;\n\nint visit(int u) {\n    if (visited[u]!=t) visited[u] = t;\n    else return 0;\n    REP(i, a[u].sz()) {\n        int v = a[u][i];\n        if (!assigned[v] || visit(assigned[v])) {\n            assigned[v] = u;\n            return 1;\n        }\n    }\n    return 0;\n}\n\nint findMaximumMatching() {\n    int cnt = 0;\n    REP(i, even.sz()) {\n        ++t;\n        cnt += visit(i);\n    }\n    return cnt;\n}\n\nbool isPrime(int a) {       ///notice that function will return false if a=2\n    if (a<=2) return false;\n    FOR(i, 2, sqrt(a)) {\n        if (a%i==0) return false;\n    }\n    return true;\n}\n\nint main() {\n    //freopen(\"prflip.inp\", \"r\", stdin);\n    //freopen(\"prflip.ans\", \"w\", stdout);\n    //ios::sync_with_stdio(0); cin.tie(0);\n    scanf(\"%d\", &n);\n    int prev = -1;\n    FOR(i, 1, n) {\n        int x; scanf(\"%d\", &x);\n        if (x!=prev+1) {\n            if (prev!=-1 && (prev+1)%2==0) even.push_back(prev+1);\n            else if (prev!=-1) odd.push_back(prev+1);\n            if (x%2==0) even.push_back(x);\n            else odd.push_back(x);\n        }\n        prev = x;\n    }\n    if ((prev+1)%2==0) even.push_back(prev+1);\n    else odd.push_back(prev+1);\n    REP(i, even.sz()) REP(j, odd.sz()) {\n        if (isPrime(abs(even[i]-odd[j])))\n            a[i].push_back(j);\n    }\n    int k = findMaximumMatching();//, res = inf;\n    /*assert(even.sz()%2==odd.sz()%2);\n    FOR(i, 0, k) {\n        if (((int)even.sz()-k)%2==0) res = min(res, k+((int)even.sz()-k)+((int)odd.sz()-k));\n        else res = min(res, k+((int)even.sz()-1-k)+((int)odd.sz()-1-k)+3);\n    }*/\n    printf(\"%d\", k+(even.sz()-k)/2*2+(odd.sz()-k)/2*2+3*((even.sz()-k)%2));\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<cstring>\nusing namespace std;\nint n;\nint res;\nvector<int>v;\nint lst=-1;\nint match[210];\nint me,mo;\nint mx;\nbool f[10000010];\nvector<int>ok[210];\nbool vis[210];\nint prm[1000010];\nint sz;\nint l;\nbool bp(int x)\n{\n\tfor(int i=0;i<ok[x].size();i++)\n\t{\n\t\tint y=ok[x][i];\n\t\tif(vis[y])continue;\n\t\tvis[y]=vis[x]=true;\n\t\tif(match[y]==-1 || bp(match[y]))\n\t\t{\n\t\t\tmatch[y]=x;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint x;\n\t\tscanf(\"%d\",&x);\n\t\tif(x!=lst+1)\n\t\t{\n\t\t\tif(lst+1)v.push_back(lst+1);\n\t\t\tv.push_back(x);\n\t\t}\n\t\tlst=x;\n\t\tmx=lst+1;\n\t}\n\tv.push_back(lst+1);\n\tf[1]=true;\n\tfor(int i=2;i<=mx;i++)\n\t{\n\t\tif(!f[i])prm[++sz]=i;\n\t\tfor(int j=1;j<=sz;j++)\n\t\t{\n\t\t\tif(prm[j]*i>mx)break;\n\t\t\tf[prm[j]*i]=true;\n\t\t\tif(i%prm[j]==0)break;\n\t\t}\n\t}\n\tl=v.size();\n\tfor(int i=0;i<l;i++)\n\t{\n\t\tmatch[i]=-1;\n\t\tif(v[i]&1)mo++;else me++;\n\t\tfor(int j=i+1;j<l;j++)\n\t\t{\n\t\t\tif(v[j]-v[i]!=2 && !f[v[j]-v[i]])\n\t\t\t{\n\t\t\t\tok[i].push_back(j);\n\t\t\t\tok[j].push_back(i);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<l;i++)\n\t{\n\t\tmemset(vis,false,sizeof(vis));\n\t\tif(bp(i))res++;\n\t}\n\tres/=2;\n\tprintf(\"%d\",res+((me-res)/2+(mo-res)/2)*2+((me-res)%2)*3);\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\n#include<cassert>\n#include<complex>\nusing namespace std;\n\n//#define int long long\ntypedef long long ll;\n\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconst ll mod = 998244353;\nconst ll INF = mod * mod;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef pair<ll, ll> LP;\ntypedef vector<ll> vec;\ntypedef long double ld;\ntypedef pair<ld, ld> LDP;\nconst ld eps = 1e-5;\nconst ld pi = acos(-1.0);\n\n#include<cstring>\nstruct edge { int to, cap, rev; };\nvector<edge> G[100000];\nbool used[100000];\nvoid add_edge(int from, int to, int cap) {\n\tG[from].push_back(edge{ to, cap, (int)G[to].size() });\n\tG[to].push_back(edge{ from, 0, (int)G[from].size() - 1 });\n}\nint dfs(int v, int t, int f) {\n\tif (v == t)return f;\n\tused[v] = true;\n\tfor (int i = 0; i < (int)G[v].size(); i++) {\n\t\tedge &e = G[v][i];\n\t\tif (!used[e.to] && e.cap > 0) {\n\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\tif (d > 0) {\n\t\t\t\te.cap -= d;\n\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nint max_flow(int s, int t) {\n\tint flow = 0;\n\tfor (;;) {\n\t\tmemset(used, 0, sizeof(used));\n\t\tint f = dfs(s, t, mod);\n\t\tif (f == 0)return flow;\n\t\tflow += f;\n\t}\n}\n\nconst int mn = 10000000;\nbool isp[mn + 1];\nvoid init() {\n\tfill(isp + 2, isp + mn + 1, true);\n\tRep(i, 2, mn + 1) {\n\t\tif (!isp[i])continue;\n\t\tfor (int j = 2 * i; j <= mn; j += i) {\n\t\t\tisp[j] = false;\n\t\t}\n\t}\n}\nvoid solve() {\n\tint n; cin >> n;\n\tvector<int> x(n);\n\trep(i, n) {\n\t\tcin >> x[i];\n\t}\n\tvector<int> v;\n\trep(i, n) {\n\t\tif (i == 0 || x[i] - 1 > x[i - 1]) {\n\t\t\tv.push_back(x[i] - 1);\n\t\t}\n\t\tif (i + 1 == n || x[i + 1] > x[i] + 1) {\n\t\t\tv.push_back(x[i]);\n\t\t}\n\t}\n\tvector<int> od, ev;\n\trep(i, v.size()) {\n\t\t//cout << v[i] << endl;\n\t\tif (v[i] % 2)od.push_back(v[i]);\n\t\telse ev.push_back(v[i]);\n\t}\n\tint s = od.size() + ev.size();\n\tint t = s + 1;\n\trep(i, od.size()) {\n\t\tadd_edge(s, i, 1);\n\t}\n\trep(i, ev.size()) {\n\t\tadd_edge(i + od.size(), t, 1);\n\t}\n\trep(i, od.size()) {\n\t\trep(j, ev.size()) {\n\t\t\tint l = i;\n\t\t\tint r = od.size() + j;\n\t\t\tint dif = abs(od[i] - ev[j]);\n\t\t\tif (isp[dif]) {\n\t\t\t\tadd_edge(l, r, 1);\n\t\t\t}\n\t\t}\n\t}\n\tint f = max_flow(s, t);\n\tint ans = f;\n\tint odnum = od.size() - f;\n\tans += 2*(odnum / 2);\n\tint evnum = ev.size() - f;\n\tans += 2*(evnum / 2);\n\tif (odnum % 2||evnum%2) {\n\t\tans += 3;\n\t}\n\tcout << ans << endl;\n}\n\nsigned main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tcout << fixed << setprecision(50);\n\tinit();\n\tsolve();\n\n\t//cout << \"finish\" << endl;\n\t//stop\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#include <map>\nusing namespace std;\n\nconst int MAX_N = 205;\n\nclass Edge {\npublic:\n  int nxt, to;\n} e[MAX_N * MAX_N];\n\nint head[MAX_N], cnt;\nvoid addedge(int u, int v) {\n  e[++cnt] = (Edge){head[u], v}, head[u] = cnt;\n}\n\nbool isprime(int x) {\n  for (int i = 2; i * i <= x; ++i)\n    if (x % i == 0) return false;\n  return true;\n}\n\nint N, pos[MAX_N], tot, val[MAX_N], match[MAX_N];\nmap<int, bool> vis;\nbool bad[MAX_N];\n\nbool dfs(int x) {\n  if (vis[x]) return false;\n  bad[x] = 1;\n  for (int i = head[x]; i; i = e[i].nxt)\n    if (!match[e[i].to] || dfs(match[e[i].to])) {\n      match[e[i].to] = x;\n      return true;\n    }\n  return false;\n}\n\nint main() {\n  scanf(\"%d\", &N);\n  for (int i = 1; i <= N; ++i) \n    scanf(\"%d\", &pos[i]);\n  pos[0] = -1;\n  for (int i = 1; i <= N; ++i) {\n    if (pos[i - 1] != pos[i] - 1) val[++tot] = pos[i];\n    if (pos[i + 1] != pos[i] + 1) val[++tot] = pos[i] + 1;\n  }\n  \n  int odd = 0, even = 0;\n  \n  for (int i = 1; i <= tot; ++i)\n    if (val[i] & 1) {\n      odd++;\n      for (int j = 1; j <= tot; ++j)\n\tif (!(val[j] & 1) && abs(val[i] - val[j]) > 1 && isprime(abs(val[i] - val[j])))\n\t  addedge(i, j);\n    } else {\n      even++;\n    }\n\n  int num = 0;\n  for (int i = 1; i <= tot; ++i) \n    if (val[i] & 1) {\n      memset(bad, 0, sizeof bad);\n      num += dfs(i);\n    }\n\n  printf(\"%d\\n\", num + ((odd - num) / 2 + (even - num) / 2) * 2 + (odd - num) % 2 * 3);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <map>\n#include <string>\n#include <cstring>\n#include <stack>\n#include <queue>\n#include <cmath>\n#include <ctime>\n#include <utility>\nusing namespace std;\n#define REP(I,N) for (I=0;I<N;I++)\n#define rREP(I,N) for (I=N-1;I>=0;I--)\n#define rep(I,S,N) for (I=S;I<N;I++)\n#define rrep(I,S,N) for (I=N-1;I>=S;I--)\n#define FOR(I,S,N) for (I=S;I<=N;I++)\n#define rFOR(I,S,N) for (I=N;I>=S;I--)\ntypedef unsigned long long ull;\ntypedef long long ll;\n//const int INF=0x3f3f3f3f;\nconst int INF=1e9;\nconst ll INFF=0x3f3f3f3f3f3f3f3fll;\nconst ll M=1e9+7;\nconst ll maxn=1e5+7;\nconst int MAXN=1005;\nconst int MAX=2e5+5;\nconst int MAX_N=MAX;\nconst ll MOD=1e9+7;\n//const double eps=0.00000001;\n//ll gcd(ll a,ll b){return b?gcd(b,a%b):a;}\ntemplate<typename T>inline T abs(T a) {return a>0?a:-a;}\ninline ll powMM(ll a,ll b){\n    ll ret=1;\n    a%=M;\n//    b%=M;\n    while (b){\n        if (b&1) ret=ret*a%M;\n        b>>=1;\n        a=a*a%M;\n    }\n    return ret;\n}\nvoid open()\n{\n    freopen(\"1007.in\",\"r\",stdin);\n    freopen(\"out.txt\",\"w\",stdout);\n}\n\nint V;//顶点数\nconst int MAX_V=MAX;\nvector<int> G[MAX_V];//图的邻接表表示\nint match[MAX_V];//所匹配的顶点\nbool used[MAX_V];//DFS中用到的访问标记\n//向图中增加一条连接u和v的边\nvoid add_edge(int u,int v)\n{\n    G[u].push_back(v);\n//    G[v].push_back(u);\n}\n//通过DFS寻找增广路\nbool dfs(int v)\n{\n    used[v]=true;\n    for(int i=0;i<G[v].size();i++)\n    {\n        int u=G[v][i],w=match[u];\n        if(w<0||(!used[w]&&dfs(w)))\n        {\n            match[v]=u;\n            match[u]=v;\n            return true;\n        }\n    }\n    return false;\n}\n//求解二分图的最大匹配\nint bipartite_matching()\n{\n    int res=0;\n    memset(match,-1,sizeof(match));\n    for(int v=0;v<V;v++)\n    {\n        if(match[v]<0)\n        {\n            memset(used,0,sizeof(used));\n            if(dfs(v))\n                ++res;\n        }\n    }\n    return res;//返回的是总点数的一半\n}\nbool isprime(int x)\n{\n    if(x==1)\n        return false;\n    for(int i=2;i*i<=x;i++)\n    {\n        if(x%i==0)\n            return false;\n    }\n    return true;\n}\nint n;\nint a[(int)1e7+2];\nvector<int>pos[2];\nint main()\n{\n    scanf(\"%d\",&n);\n    int tem;\n    for(int i=1;i<=n;i++)\n    {\n        scanf(\"%d\",&tem);\n        a[tem]=1;\n    }\n    for(int i=tem+1;i>=1;i--)\n    {\n        a[i]=a[i]^a[i-1];\n        if(a[i])\n            pos[i%2].push_back(i);\n    }\n    for(int i=0;i<pos[0].size();i++)\n        for(int j=0;j<pos[1].size();j++)\n            if(isprime(abs(pos[0][i]-pos[1][j])))\n                add_edge(i,j+pos[0].size());\n    V=pos[0].size()+pos[1].size();\n    int cnt=bipartite_matching();\n    cnt+=((pos[0].size()-cnt)/2+(pos[1].size()-cnt)/2)*2;\n    cnt+=((pos[0].size()-cnt)%2)*3;\n    printf(\"%d\\n\",cnt);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n  \nusing namespace std;\n  \n#define rep(i,n) REP(i,0,n)\n#define REP(i,s,e) for(int i=(s); i<(int)(e); i++)\n#define repr(i, n) REPR(i, n, 0)\n#define REPR(i, s, e) for(int i=(int)(s-1); i>=(int)(e); i--)\n#define pb push_back\n#define all(r) r.begin(),r.end()\n#define rall(r) r.rbegin(),r.rend()\n#define fi first\n#define se second\n  \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n \nconst int INF = 1e9;\nconst ll MOD = 1e9 + 7;\ndouble EPS = 1e-8;\n\n#define MAX_V 2200\n \nstruct Edge\n{\n    int to, cap, rev;\n    Edge(){};\n    Edge(int to, int cap, int rev) : to(to), cap(cap), rev(rev){};\n};\n \nvector<Edge> G[MAX_V];\nbool used[MAX_V];\n \nvoid add_edge(int from, int to, int cap){\n    G[from].push_back({to, cap, (int)G[to].size()});\n    G[to].push_back({from, 0, (int)G[from].size()-1});\n}\n \nint dfs(int v, int t, int f){\n    if(v == t) return f;\n    used[v] = true;\n    for(int i = 0; i < G[v].size(); i++){\n        Edge& e = G[v][i];\n        if(!used[e.to] && e.cap > 0){\n            int d = dfs(e.to, t, min(f, e.cap));\n            if(d > 0){\n                e.cap -= d;\n                G[e.to][e.rev].cap += d;\n                return d;\n            }\n        }\n    }\n    return 0;\n}\n \nint max_flow(int s, int t){\n    int flow = 0;\n    while(1){\n        memset(used, 0, sizeof(used));\n        int f = dfs(s, t, INF);\n        if(f == 0) return flow;\n        flow += f;\n    }\n}\n\n//エラトステネスの篩を使用\nconst int MAX_PRIME = 1e7 + 10;\n \nvector<int> is_prime(MAX_PRIME,1);\n \nvoid calcPrime(){\n    is_prime[0]=is_prime[1]=0;\n    for(int i=2; i<MAX_PRIME; i++){\n        if(is_prime[i]==1){\n            for(int j=i*2; j<MAX_PRIME; j+=i){\n                is_prime[j]=0;\n            }\n        }\n    }\n}\n\nint main(){\n\tcalcPrime();\n\tint n;\n\tcin >> n;\n\tvi x(n);\n\trep(i, n) cin >> x[i];\n\tmap<int, int> mp;\n\trep(i, n) {\n\t\tmp[x[i]]^=1;\n\t\tmp[x[i]+1]^=1;\n\t}\n\tvi odd, even;\n\tfor(auto& p : mp) if(p.se) (p.fi&1?odd:even).pb(p.se);\n\trep(i, odd.size()) rep(j, even.size()) {\n\t\tif(is_prime[abs(odd[i]-even[j])]) add_edge(i, odd.size()+j, 1);\n\t}\n\trep(i, odd.size()) add_edge(n, i, 1);\n\trep(i, even.size()) add_edge(odd.size()+i, n+1, 1);\n\tint f = max_flow(n, n+1);\n\tint ans = f + (((int)odd.size()-f)/2)*2 + (((int)even.size()-f)/2)*2;\n\tif(((int)odd.size()-f)&1) ans += 3;\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <time.h>\n#include <random>\n#include <fstream>\n#include <set>\n\nusing namespace std;\n\nconst int N = 1e7 + 2;\n\nint n;\n\nint c[N];\nint p[N];\nint a[200];\n\nvector<int> graph[400];\n\nint paired[400];\nint marked[400];\n\nint TryKuhn(int v)\n{\n    if (marked[v]) return 0;\n    marked[v] = 1;\n    for (auto u : graph[v])\n    {\n        if (paired[u] == -1 || TryKuhn(paired[u]))\n        {\n            paired[u] = v;\n            return 1;\n        }\n    }\n    return 0;\n}\n\nint G()\n{\n    int res = 0;\n    fill(paired, paired + 400, -1);\n    for (int i = 0; i < n; i++)\n    {\n        fill(marked, marked + 400, 0);\n        if (TryKuhn(i))\n            res++;\n    }\n    return res;\n}\n\nsigned main()\n{\n    srand(time(NULL));\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    for (int i = 2; i < N; i++)\n    {\n        if (p[i] == 0)\n        {\n            for (int j = 2; j * i < N; j++) p[i * j] = 1;\n        }\n    }\n    p[2] = 1;\n    p[1] = 1;\n    cin >> n;\n    for (int i = 0; i < n; i++)\n    {\n        int x;\n        cin >> x;\n        c[x] = 1;\n    }\n    n = 0;\n    for (int i = 0; i + 1 < N; i++)\n    {\n        if (c[i] != c[i + 1])\n        {\n            a[n] = i;\n            n++;\n        }\n    }\n    for (int i = 0; i < n; i++)\n    {\n        for (int j = 0; j < n; j++)\n        {\n            if (a[i] % 2 == 0 && a[j] % 2 == 1)\n            {\n                if (1 || !p[abs(a[i] - a[j])])\n                {\n                    graph[i].push_back(200 + j);\n                    graph[200 + j].push_back(i);\n                }\n            }\n        }\n    }\n    /*for (int i = 0; i < 400; i++)\n    {\n        for (auto u : graph[i])\n        {\n            cout << i << \" \" << u << endl;\n        }\n    }*/\n    int c0 = 0, c1 = 0, c2 = G();\n    for (int i = 0; i < n; i++)\n    {\n        if (a[i] % 2 == 0) c0++;\n        else c1++;\n    }\n    int ans = c2 + ((c0 - c2) / 2) * 2 + ((c1 - c2) / 2) * 2 + ((c1 - c2) % 2) * 3;\n    cout << ans;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<queue>\n#include<stack>\n#include<cstring>\n#include<algorithm>\n#include<vector>\n#include<cmath>\nusing namespace std;\nint e[201][201];\nint vis[201];\nint match[201];\nint tot1=0,tot2=0;\nbool find(int u)\n{\n\tfor(int i=1;i<=tot2;i++)\n\t{\n\t\tif(vis[i]==0&&e[u][i])\n\t\t{\n\t\t\tvis[i]=1;\n\t\t\tif(!match[i]||find(match[i]))\n\t\t\t{\n\t\t\t\tmatch[i]=u;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\nbool isprime(int x)\n{\n\tif(x==1) return false;\n\tfor(int i=2;i<=sqrt(x);i++)\n\t\tif(x%i==0)\n\t\t\treturn false;\n\treturn true;\n}\nint x[201];\nint odd[201];\nint even[201];\nsigned main()\n{\n\tint n;\n\tscanf(\"%d\",&n);\n\tif(n==1){printf(\"3\");return 0;}\n\tfor(int i=1;i<=n;i++)\n\t\tscanf(\"%d\",&x[i]);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tif(i==1||x[i-1]!=x[i]-1)\n\t\t{\n\t\t\tif(x[i]%2==1) odd[++tot1]=x[i];\n\t\t\telse even[++tot2]=x[i];\n\t\t}\n\t\tif(i==n||x[i+1]!=x[i]+1)\n\t\t{\n\t\t\tif(x[i]%2==1) even[++tot2]=x[i]+1;\n\t\t\telse odd[++tot1]=x[i]+1;\n\t\t}\n\t}\n\tfor(int i=1;i<=tot1;i++)\n\t\tfor(int j=1;j<=tot2;j++)\n\t\t\tif(isprime(abs(odd[i]-even[j])))\n\t\t\t\te[i][j]=1;\n\tint ans=0;\n\tfor(int i=1;i<=tot1;i++)\n\t{\n\t\tmemset(vis,0,sizeof(vis));\n\t\tif(find(i))\n\t\t\tans++;\n\t}\n\tprintf(\"%d\",ans+(tot1-ans)/2*2+(tot2-ans)/2*2+(tot1-ans)%2*3);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define maxn 205\nusing namespace std;\nint n,m,a[maxn],lk[maxn];\nvector<int>G[maxn];\nbool vis[maxn];\nbool dfs(int u){\n\tfor(int v:G[u]) if(!vis[v]){\n\t\tvis[v]=1;\n\t\tif(!lk[v]||dfs(lk[v])) return lk[v]=u,1;\n\t}\n\treturn 0;\n}\ninline bool check(int x){\n\tif(x<=2) return 0;\n\tfor(int i=2;i*i<=x;i++) if(x%i==0) return 0;\n\treturn 1;\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1,pre=-1,now;i<=n;i++,pre=now){\n\t\tscanf(\"%d\",&now);\n\t\tif(pre<now-1) a[++m]=now,a[++m]=now+1;\n\t\telse a[m]=now+1;\n\t}\n\tint cnt[2]={0},ans=0;\n\tfor(int i=1;i<=m;i++) cnt[a[i]&1]++; \n\tfor(int i=1;i<=m;i++) if(!(a[i]&1))\n\t\tfor(int j=i+1;j<=m;j++) if((a[j]&1)&&check(a[j]-a[i]))\n\t\t\tG[i].push_back(j);\n\tfor(int i=1;i<=m;i++) memset(vis,0,sizeof vis),ans+=dfs(i);\n\tprintf(\"%d\\n\",ans+(m-2*ans)+(cnt[0]-ans)%2);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 610, INF = 0x3f3f3f3f;\nint p[N],n,cnt,st,en,x[N];\nstruct edge {\n  int la,b,cap;\n} con[N * N * 2];\nint tot=1,fir[N];\nvoid add(int from,int to,int capc) {\n  con[++tot] = (edge) {fir[from],to,capc};\n  fir[from] = tot;\n  con[++tot] = (edge) {fir[to],from,0};\n  fir[to] = tot;\n}\nint cur[N], dis[N];\nint dfs(int pos,int imp) {\n  if (pos == en || (!imp)) return imp;\n  int expo = 0, tmp;\n  for (int &i = cur[pos] ; i ; i = con[i].la) {\n    if (dis[con[i].b] == dis[pos] + 1) {\n      tmp = dfs(con[i].b,min(imp,con[i].cap));\n      con[i].cap -= tmp;\n      con[i^1].cap += tmp;\n      expo += tmp;\n      imp -= tmp;\n      if (!imp) break;\n    }\n  }\n  return expo;\n}\nbool bfs() {\n  static queue<int> q;\n  while (!q.empty()) q.pop();\n  memset(dis,0,sizeof dis);\n  for (int i = 1 ; i <= n ; ++ i)\n    cur[i] = fir[i];\n  dis[st] = 1;\n  q.push(st);\n  for (int pos ; !q.empty() ; q.pop()) {\n    pos = q.front();\n    for (int i = fir[pos] ; i ; i = con[i].la) {\n      if (con[i].cap && (!dis[con[i].b])) {\n\tdis[con[i].b] = dis[pos] + 1;\n\tq.push(con[i].b);\n      }\n    }\n  }\n  if (!dis[en]) return 0;\n  return 1;\n}\nconst int MAX = 10000010;\nint isp[MAX + 10], pri[MAX / 10], pcnt, num[2];\nset<int> prime;\nvoid prework() {\n  for (int i = 2 ; i <= MAX ; ++ i) {\n    if (!isp[i]) pri[++pcnt] = i;\n    for (int j = 1 ; j <= pcnt && pri[j] * i <= MAX ; ++ j) {\n      isp[pri[j] * i] = 1;\n      if (i % pri[j] == 0) break;\n    }\n  }\n  for (int i = 2 ; i <= pcnt ; ++ i)\n    prime.insert(pri[i]);\n}\nint main() {\n  prework();\n  scanf(\"%d\",&n);\n  for (int i = 1 ; i <= n ; ++ i) {\n    scanf(\"%d\",&x[i]);\n    if (x[i] == 1 || x[i] != x[i-1] + 1)\n      p[++cnt] = x[i];\n    if (i > 1 && x[i] != x[i-1] + 1)\n      p[++cnt] = x[i-1] + 1;\n  }\n  p[++cnt] = x[n] + 1;\n  n = cnt;\n  st = ++n;\n  en = ++n;\n  for (int i = 1 ; i <= cnt ; ++ i) {\n    ++ num[p[i]&1];\n    if (p[i]&1) {\n      add(st,i,1);\n      for (int j = 1 ; j <= cnt ; ++ j) {\n\tint d = abs(p[i] - p[j]);\n\tif (prime.count(d))\n\t  add(i,j,1);\n      }\n    } else add(i,en,1);\n  }\n  int ans = 0;\n  while (bfs())\n    ans += dfs(st,INF);\n  printf(\"%d\\n\",ans + 2 * ((num[0] - ans) / 2 + (num[1] - ans) / 2) + ((num[1] - ans)&1) * 3);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <map>\n#include <ctime>\n#include <set>\n\n#define Rep(i, n) for (int i = 1; i <= n; i ++)\n#define Rep0(i, n) for (int i = 0; i <= n; i ++)\n#define RepG(i, x) for (int i = head[x]; i; i = edge[i].next)\n#define v edge[i].to\n#define mp(a, b) make_pair(a, b)\n#define fi first\n#define se second\n\nusing namespace std;\n\nconst int N = 210;\n\nbool isnotprime[10000010];\nint prime[10000010], cnt;\nvoid get_prime()\n{\n\tfor (int i = 2; i <= 10000000; i ++) {\n\t\tif (!isnotprime[i]) prime[++ cnt] = i;\n\t\tfor (int j = 1; j <= cnt && i * prime[j] <= 10000000; j ++) {\n\t\t\tisnotprime[i * prime[j]] = true;\n\t\t\tif (!(i % prime[j])) break;\n\t\t}\n\t}\n}\n\nint vv[10000010], p[N], d0[N], d1[N], lnk[N], cd0, cd1;\nbool vis[N];\nbool dfs(int x)\n{\n\tRep(i, cd1) if (!isnotprime[abs(d0[x] - d1[i])] && !vis[i]) {\n\t\tvis[i] = true;\n\t\tif (lnk[i] == -1 || dfs(lnk[i])){ lnk[i] = x; return true;} \n\t}\n\treturn false;\n}\n\nint main()\n{\n\tget_prime();\n\t\n\tint T;\n\tscanf(\"%d\", &T);\n\twhile (T --){\n\t\tint n;\n\t\tscanf(\"%d\", &n);\n\t\tcd0 = cd1 = 0;\n\t\tRep(i, n) {\n\t\t\tscanf(\"%d\", &p[i]);\n\t\t\tif (vv[p[i]] != T + 1) vv[p[i]] = T + 1;\n\t\t}\n\t\tRep(i, n) {\n\t\t\tif (vv[p[i]] != vv[p[i] - 1]) {\n\t\t\t\tif (p[i] & 1) d1[++ cd1] = p[i];\n\t\t\t\telse d0[++ cd0] = p[i];\n\t\t\t}\n\t\t\tif (vv[p[i]] != vv[p[i] + 1]) {\n\t\t\t\tif (p[i] & 1) d0[++ cd0] = p[i] + 1;\n\t\t\t\telse d1[++ cd1] = p[i] + 1;\n\t\t\t}\n\t\t}\n\t\t//printf(\"%d %d\\n\", cd0, cd1);\n\t\t//Rep(i, cd0) printf(\"_%d \", d0[i]); printf(\"\\n\");\n\t\t//Rep(i, cd1) printf(\"_%d \", d1[i]); printf(\"\\n\");\n\t\t\n\t\tint ans = 0;\n\t\tmemset(lnk, -1, sizeof(lnk));\n\t\tRep(i, cd0) {\n\t\t\tmemset(vis, false, sizeof(vis));\n\t\t\tif (dfs(i)) ans ++;\n\t\t}\n\t\tans += ((cd0 - ans) / 2) * 2 + ((cd1 - ans) / 2) * 2;\n\t\tif ((cd0 - ans) & 1) ans += 3;\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\t\n\treturn 0;\n}\n/*\n3\n2\n2 3\n3\n1 2 4\n5\n101 102 103 104 105\n*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fi first\n#define se second\n#define rep(i,n) for(int i = 0; i < (n); ++i)\n#define rrep(i,n) for(int i = 1; i <= (n); ++i)\n#define drep(i,n) for(int i = (n)-1; i >= 0; --i)\n#define each(it,c) for(__typeof((c).begin()) it=(c).begin();it!=(c).end();it++)\n#define rng(a) a.begin(),a.end()\n#define maxs(x,y) x = max(x,y)\n#define mins(x,y) x = min(x,y)\n#define pb push_back\n#define sz(x) (int)(x).size()\n#define pcnt __builtin_popcount\n#define uni(x) x.erase(unique(rng(x)),x.end())\n#define snuke srand((unsigned)clock()+(unsigned)time(NULL));\n#define df(x) int x = in()\n#define dame { puts(\"-1\"); return 0;}\n#define show(x) cout<<#x<<\" = \"<<x<<endl;\n#define PQ(T) priority_queue<T,vector<T>,greater<T> >\n#define bn(x) ((1<<x)-1)\n#define newline puts(\"\")\n#define v(T) vector<T>\n#define vv(T) vector<vector<T>>\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned uint;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<P> vp;\ninline int in() { int x; scanf(\"%d\",&x); return x;}\ninline void priv(vi a) { rep(i,sz(a)) printf(\"%d%c\",a[i],i==sz(a)-1?'\\n':' ');}\ntemplate<typename T>istream& operator>>(istream&i,vector<T>&v)\n{rep(j,sz(v))i>>v[j];return i;}\ntemplate<typename T>string join(const vector<T>&v)\n{stringstream s;rep(i,sz(v))s<<' '<<v[i];return s.str().substr(1);}\ntemplate<typename T>ostream& operator<<(ostream&o,const vector<T>&v)\n{if(sz(v))o<<join(v);return o;}\ntemplate<typename T1,typename T2>istream& operator>>(istream&i,pair<T1,T2>&v)\n{return i>>v.fi>>v.se;}\ntemplate<typename T1,typename T2>ostream& operator<<(ostream&o,const pair<T1,T2>&v)\n{return o<<v.fi<<\",\"<<v.se;}\nconst int MX = 100005, INF = 1001001001;\nconst ll LINF = 1e18;\nconst double eps = 1e-10;\n\n// linear sieve\nvi ps, pf;\nvoid sieve(int mx) {\n  pf = vi(mx);\n  rep(i,mx) pf[i] = i;\n  for (int i = 2; i < mx; ++i) {\n    if (pf[i] == i) ps.pb(i);\n    for (int j = 0; j < sz(ps) && ps[j] <= pf[i]; ++j) {\n      int x = ps[j]*i;\n      if (x >= mx) break;\n      pf[x] = ps[j];\n    }\n  }\n}\ninline bool isp(int x) { return pf[x] == x && x >= 2;}\n//\n\n// binary matching\nstruct match {\n  vi used;\n  vvi to;\n  vi p;\n  int n, m;\n  match(int n, int m):used(n),to(n),p(m,-1),n(n),m(m){}\n  void add(int a, int b) { to[a].pb(b);}\n  bool dfs(int v){\n    if(used[v]) return false;\n    used[v] = 1;\n    rep(i,sz(to[v])) {\n      int u = to[v][i];\n      if (p[u] == -1 || dfs(p[u])){\n        p[u] = v;\n        return true;\n      }\n    }\n    return false;\n  }\n  int solve(){\n    int res = 0;\n    rep(i,n) {\n      rep(j,n) used[j] = 0;\n      if(dfs(i)) ++res;\n    }\n    return res;\n  }\n};\n//\n\n\n\nint main() {\n  sieve(10000005);\n  int n;\n  scanf(\"%d\",&n);\n  vi x(n);\n  cin>>x;\n  vi a;\n  int pre = -INF;\n  for (int s : x) {\n    if (pre == s-1) {\n      a.pop_back();\n    } else {\n      a.pb(s);\n    }\n    a.pb(s+1);\n    pre = s;\n  }\n  vvi d(2);\n  for (int s : a) {\n    d[s&1].pb(s);\n  }\n  n = sz(d[0]);\n  int m = sz(d[1]);\n  match g(n,m);\n  rep(i,n)rep(j,m) {\n    if (isp(abs(d[0][i]-d[1][i]))) g.add(i,j);\n  }\n  int c = g.solve();\n  n -= c; m -= c;\n  int ans = (n/2+m/2)*2+c;\n  n %= 2; m %= 2;\n  if (n) ans += 3;\n  cout<<ans<<endl;\n  return 0;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstruct hopcroft{\n\tvector<int> dist, pair_l, pair_r;\n\tvector<bool> seen;\n\tvector<vector<int>> to;\n\tint n1, n2;\n\thopcroft(int n1, int n2) : n1(n1), n2(n2){\n\t\tto.resize(n1);\n\t\tpair_l.assign(n1, -1);\n\t\tpair_r.assign(n2, -1);\n\t\tdist.resize(n1);\n\t\tseen.resize(n1);\n\t}\n\tvoid add_edge(int u, int v){\n\t\tto[u].push_back(v);\n\t}\n\tbool bfs(){\n\t\tfill(dist.begin(), dist.end(), -1);\n\t\tqueue<int> q;\n\t\tfor (int i = 0; i < n1; i++){\n\t\t\tif (pair_l[i] == -1){\n\t\t\t\tdist[i] = 0;\n\t\t\t\tq.push(i);\n\t\t\t}\n\t\t}\n\t\tbool reach_minus = false;\n\t\twhile (!q.empty()){\n\t\t\tint u = q.front();\n\t\t\tq.pop();\n\t\t\tfor (int adj : to[u]){\n\t\t\t\tint radj = pair_r[adj];\n\t\t\t\tif (radj == -1){\n\t\t\t\t\treach_minus = true;\n\t\t\t\t} else if (dist[radj] == -1){\n\t\t\t\t\tdist[radj] = dist[u] + 1;\n\t\t\t\t\tq.push(radj);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn reach_minus;\n\t}\n\tbool dfs(int u){\n\t\tseen[u] = true;\n\t\tfor (int adj : to[u]){\n\t\t\tint radj = pair_r[adj];\n\t\t\tif (radj == -1 || (!seen[radj] && dist[radj] == dist[u] + 1 && dfs(radj))){\n\t\t\t\tpair_l[u] = adj;\n\t\t\t\tpair_r[adj] = u;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\tint max_matching(){\n\t\tint res = 0;\n\t\twhile (bfs()){\n\t\t\tfill(seen.begin(), seen.end(), false);\n\t\t\tfor (int i = 0; i < n1; i++)\n\t\t\t\tif (dfs(i))\n\t\t\t\t\tres++;\n\t\t}\n\t\treturn res;\n\t}\n};\nconst int lim = 10000002;\nbool prime[lim];\nvoid init(){\n\tmemset(prime, true, sizeof(prime));\n\tprime[0] = prime[1] = false;\n\tfor(int i = 2; i < lim; i++){\n\t\tif(prime[i]){\n\t\t\tfor(int j = i + i; j < lim; j += i)\n\t\t\t\tprime[j] = false;\n\t\t}\t\n\t}\n}\nint main(){\n\tinit();\n\tint n; cin >> n;\n\tbitset<lim> b;\n\tfor(int i = 0; i < n; i++){\n\t\tint x; cin >> x;\n\t\tb[x] = 1;\n\t}\n\tvector<int> p[2];\n\tfor(int i = 1; i < lim; i++){\n\t\tif(b[i] != b[i - 1]){\n\t\t\tp[i%2].push_back(i);\n\t\t}\n\t}\n\tint l0 = p[0].size(), l1 = p[1].size();\n\thopcroft ho(l0, l1);\n\tfor(int i = 0; i < l0; i++){\n\t\tfor(int j = 0; j < l1; j++){\n\t\t\tif(prime[abs(p[0][i] - p[1][j])]){\n\t\t\t\tho.add_edge(i, j);\n\t\t\t}\n\t\t}\n\t}\n\tint fl = ho.max_matching();\n\tint ans = fl + ((l0 - fl) / 2) * 2 + ((l1 - fl)/2) * 2 + ((l0 - fl) % 2) * 3;\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)n;++i)\n#define each(a, b) for(auto (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout <<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout <<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define svec(v) cout<<#v<<\":\";rep(kbrni,v.size())cout<<\" \"<<v[kbrni];cout<<endl\n#define sset(s) cout<<#s<<\":\";each(kbrni,s)cout <<\" \"<<kbrni;cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int>P;\n\nconst int MAX_N = 10000005;\nconst int MAX_M = 300;\n\nint prime[MAX_N];\nbool is_prime[MAX_N];\n\nint sieve(int n)\n{\n\tint p = 0;\n\tfor(int i=0;i<=n;i++){\n\t\tis_prime[i] = true;\n\t}\n\tis_prime[0] = is_prime[1] = false;\n\tfor(int i=2;i<=n;i++){\n\t\tif(is_prime[i]){\n\t\t\tprime[p++] = i;\n\t\t\tfor(int j=2*i;j<=n;j+=i){\n\t\t\t\tis_prime[j] = false;\n\t\t\t}\n\t\t}\n\t}\n\treturn p;\n}\n\nstruct edge\n{\n\tint to,cap,rev;\n};\n\nvector<edge> G[MAX_M];\nint level[MAX_M];\nint iter[MAX_M];\n\nvoid add_edge(int from,int to,int cap)\n{\n\tG[from].push_back((edge){to,cap,G[to].size()});\n\tG[to].push_back((edge){from,0,G[from].size()-1});\n}\n\nvoid bfs(int s)\n{\n\tmemset(level,-1,sizeof(level));\n\tqueue<int> que;\n\tlevel[s] = 0;\n\tque.push(s);\n\twhile(!que.empty()){\n\t\tint v = que.front();\n\t\tque.pop();\n\t\trep(i,G[v].size()){\n\t\t\tedge &e = G[v][i];\n\t\t\tif(e.cap > 0 && level[e.to] < 0){\n\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\tque.push(e.to);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint dfs(int v,int t,int f)\n{\n\tif(v==t){\n\t\treturn f;\n\t}\n\tfor(int &i = iter[v];i<G[v].size();i++){\n\t\tedge &e = G[v][i];\n\t\tif(e.cap > 0 && level[v] < level[e.to]){\n\t\t\tint d = dfs(e.to,t,min(f,e.cap));\n\t\t\tif(d>0){\n\t\t\t\te.cap -= d;\n\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint max_flow(int s,int t)\n{\n\tint flow = 0;\n\tfor(;;){\n\t\tbfs(s);\n\t\tif(level[t]<0){\n\t\t\treturn flow;\n\t\t}\n\t\tmemset(iter,0,sizeof(iter));\n\t\tint f;\n\t\twhile((f=dfs(s,t,INF)) > 0){\n\t\t\tflow += f;\n\t\t}\n\t}\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n;\n    cin >> n;\n    vector<int> vec(n,0);\n    rep(i,n){\n        cin >> vec[i];\n    }\n    sort(all(vec));\n    vector<int> b;\n    b.pb(vec[0]);\n    rep(i,n){\n        if(i >= 1){\n            if(vec[i] != vec[i-1]+1){\n                b.pb(vec[i]);\n            }\n        }\n        if(i < n-1){\n            if(vec[i+1] != vec[i]+1){\n                b.pb(vec[i]+1);\n            }\n        }\n    }\n    b.pb(vec[n-1]+1);\n    vector<int> ev,od;\n    rep(i,b.size()){\n        if(b[i]%2 == 0){\n            ev.pb(b[i]);\n        }else{\n            od.pb(b[i]);\n        }\n    }\n    int hoge = sieve(vec[n-1]+1);\n    int u = (int)ev.size();\n    int v = (int)od.size();\n    rep(i,ev.size()){\n        add_edge(0,i+1,1);\n    }\n    rep(i,ev.size()){\n        rep(j,od.size()){\n            int diff = abs(ev[i]-od[j]);\n            if(diff%2 == 1 && is_prime[diff]){\n                add_edge(i+1,u+1+j,INF);\n            }\n        }\n    }\n    rep(i,od.size()){\n        add_edge(u+i+1,u+v+1,1);\n    }\n    int res = max_flow(0,u+v+1);\n    cout << res + (u-res)/2*2 + (v-res)/2*2 + (u-res)%2*3 << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\ntypedef long long ll ;\n#define rep(i, a, b) for (int i = a; i <= b; ++ i) \nconst int N = 505, M = 1e7, E = N * N * 2, inf = 1e9 + 7 ;\nusing namespace std ;\n\nint n, pr[M], a[N], s, t, e, ter[E], nxt[E], lnk[N], w[E], rec[E], cur[N], dis[N], opt[N] ;\nbool vis[M + 5] ;\n\nvoid pre() {\n\trep(i, 1, M) vis[i] = true ; \n\trep(i, 2, M) {\n\t\tif (vis[i]) pr[++ pr[0]] = i ;\n\t\tfor (int j = 1; j <= pr[0] && (ll) i * pr[j] <= M ; ++ j) {\n\t\t\tvis[i * pr[j]] = false ;\n\t\t\tif (i % pr[j] == 0) break ;\n\t\t}\n\t}\n\tvis[1] = vis[2] = false ;\n}\n\nvoid add(int x, int y, int z) {\n\tter[++ e] = y, nxt[e] = lnk[x], lnk[x] = e, w[e] = z, rec[e] = e + 1 ;\n\tter[++ e] = x, nxt[e] = lnk[y], lnk[y] = e, w[e] = 0, rec[e] = e - 1 ;\n}\n\nbool bfs() {\n\trep(i, s, t) dis[i] = inf ;\n\tdis[s] = 0 ;\n\tint he = 0, ta = 1 ;\n\topt[1] = s ;\n\tfor ( ; he != ta ; ) {\n\t\t++ he ; \n\t\tint u = opt[he] ;\n\t\tfor (int i = lnk[u]; i; i = nxt[i]) if (dis[ter[i]] == inf && w[i]) {\n\t\t\tdis[ter[i]] = dis[u] + 1 ;\n\t\t\topt[++ ta] = ter[i] ;\n\t\t}\n\t}\n\treturn dis[t] < inf ;\n}\n\nint dfs(int p, int sum) {\n\tif (p == t) return sum ;\n\tint res = 0 ;\n\tfor (int i = cur[p] ; i; i = nxt[i]) if (dis[ter[i]] == dis[p] + 1 && w[i]) {\n\t\tint tmp = dfs(ter[i], min(sum - res, w[i])) ;\n\t\tres += tmp, w[i] -= tmp, w[rec[i]] += tmp ;\n\t\tif (w[i]) cur[p] = i ;\n\t\tif (res == sum) return res ;\n\t}\n\treturn res ;\n}\n\nint dinic() {\n\tint res = 0 ;\n\tfor ( ; bfs() ; ) {\n\t\trep(i, s, t) cur[i] = lnk[i] ;\n\t\tres += dfs(s, inf) ;\n\t}\n\treturn res ;\n}\n\nint main() {\n\tpre() ;\n\tscanf(\"%d\", &n) ;\n\tint las , p, cnt[2] = {0} ;\n\tscanf(\"%d\", &las) ;\n\ta[++ a[0]] = las ;\n\trep(i, 2, n) {\n\t\tscanf(\"%d\", &p) ;\n\t\tif (p != las + 1) { a[++ a[0]] = las + 1, a[++ a[0]] = p ; } \n\t\tlas = p ;\n\t}\n\ta[++ a[0]] = las + 1 ;\n\trep(i, 1, a[0]) ++ cnt[a[i] & 1] ;\n\ts = 0, t = a[0] + 1 ;\n\trep(i, 1, a[0]) if (a[i] & 1) add(s, i, 1) ; else add(i, t, 1) ;\n\trep(i, 1, a[0]) if (a[i] & 1) rep(j, 1, a[0]) if (!(a[j] & 1) && vis[abs(a[i] - a[j])]) add(i, j, 1) ;\n\tint k = dinic() ;\n\tint ans = k + (cnt[0] - k) / 2 * 2 + (cnt[1] - k) / 2 * 2 + (cnt[0] - k) % 2 * 3 ;\n\tprintf(\"%d\\n\", ans) ;\n\treturn 0 ;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\ninline int read()\n{\n\tint x = 0, op = 1; char ch = 0;\n\twhile(not isdigit(ch = getchar())) if(ch == '-') op = -op;\n\tdo x = x * 10 + (ch - '0'); while(isdigit(ch = getchar()));\n\treturn op * x;\n}\ninline bool check(int a, int x, int y, int z)\n{\n\tint u = 0, v = 0, w = 0;\n\t#define pows(a, b) \\\n\t\tu = (a), v = (b), w = 1;\\\n\t\twhile(v) { if(v & 1) w = w * u % x; u = u * u % x, v >>= 1; }\n\tpows(a, z);\n\tif(w > 1) { \n\t\tfor(int i = 0; i < y; i++) \n\t\t\tif(w == x - 1) return true;\n\t\treturn false;\n\t}\n\telse return true;\n}\nbool isprime(int x)\n{\n\tif(x == 2 || x == 7 || x == 61 || x == 3) return true;\n\tif(!(x % 2 && x % 7 && x % 61 && x % 3) || x == 1) return false;\n\tint y = 0, z = x - 1; while(!(z & 1)) y++, z >>= 1;\n\tbool ok = true;\t\n\tok &= check(2, x, y, z);\n\tok &= check(3, x, y, z);\n\tok &= check(7, x, y, z);\n\tok &= check(61, x, y, z);\n\treturn ok;\n}\nint n = 0, m = 0, pos[1500], whi[3000];\nbool used[3000]; int ans = 0;\nint pygo[3000]; bool insta[3000];\nbool dfs(int x, int p)\n{\n\t#define able(a, b) (abs(whi[a] - whi[b]) > 2 && isprime(abs(whi[a] - whi[b])))\n\tfor(int i = 1; i <= m; i++)\n\t\tif(not insta[i] && able(x, i) && p != i)\n\t\t{\n\t\t\tinsta[i] = true;\n\t\t\tif(!pygo[i] || dfs(pygo[i], p))\n\t\t\t{\n\t\t\t\tpygo[x] = i, pygo[i] = x;\n\t\t\t\tused[x] = used[i] = true;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\treturn false;\n}\nsigned main()\n{\n\tn = read();\n\tfor(int i = 1; i <= n; i++) pos[i] = read();\n\tsort(pos + 1, pos + n + 1);\n\tfor(int i = 1; i <= n; i++)\n\t{\n\t\tif(i == 1 || pos[i] != pos[i - 1] + 1) whi[++m] = pos[i];\n\t\tif(i == n || pos[i] != pos[i + 1] - 1) whi[++m] = pos[i] + 1;\n\t}\n\tfor(int i = 1; i <= m; i++)\n\t\tif(not used[i]) memset(insta, 0, sizeof insta), dfs(i, i);\n\tfor(int i = 1; i <= n; i++)\n\t\tif(used[i]) ans++;\n\tans >>= 1LL;\n\tint tot[2] = {0, 0};\n\tfor(int i = 1; i <= m; i++)\n\t\tif(not used[i]) tot[whi[i] & 1]++;\n\tans += (((tot[0] >> 1LL) + (tot[1] >> 1LL)) << 1LL) + (tot[0] & 1LL) * 3LL;\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define maxn 205\n#define maxp 10000007\nusing namespace std;\n\nint a[maxn],cnt,n;\nint pr[maxp],vis[maxp],cnt_pr;\nint usd[maxn],mat[maxn];\n\nint dfs(int u){\n\tfor(int i=1;i<=cnt;i++) if(vis[abs(a[u]-a[i])] == 0 && !usd[i]){\n\t\tusd[i] = 1;\n\t\tif(!mat[i] || dfs(mat[i])){\n\t\t\tmat[i] = u , mat[u] = i;\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nint main(){\n\tfor(int i=2;i<maxp;i++){\n\t\tif(!vis[i]) pr[cnt_pr++] = i;\n\t\tfor(int j=0;pr[j]*i<maxp;j++){\n\t\t\tvis[i*pr[j]] = 1;\n\t\t\tif(i % pr[j] == 0) break;\n\t\t}\n\t}\n\tvis[2] = vis[0] = vis[1] = 1;\n\tscanf(\"%d\",&n);\n\tint p = -10;\n\tfor(int i=1;i<=n;i++){int x;\n\t\tscanf(\"%d\",&x);\n\t\tif(x != p + 1){\n\t\t\tif(p>0)a[++cnt] = p + 1;\n\t\t\ta[++cnt] = x;\n\t\t}\n\t\tp = x;\n\t}\n\ta[++cnt] = p+1;\n\tint s[2] = {};\n\tfor(int i=1;i<=cnt;i++) assert(a[i] > 0) , s[a[i] % 2] ++;\n\tint ans = 0;\n\tfor(int i=1;i<=cnt;i++) if(a[i]%2 && !mat[i]) memset(usd,0,sizeof usd),ans += dfs(i);\n\tans += 2 * ((s[0] - ans) / 2 + (s[1] - ans) / 2);\n\tans += 3 * ((s[0] - ans) % 2 && (s[1] - ans) % 2);\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\nstruct edge { int to, cap, rev; };\n\nvector<edge> G[210];\nint level[210];\nint iter[210];\nint INF = 10000000;\n\nvoid add_edge(int from, int to, int cap) {\n\tG[from].push_back({ to, cap, (int)G[to].size() });\n\tG[to].push_back({ from, 0, (int)G[from].size() - 1 });\n}\n\nvoid add_multi_edge(int v1, int v2, int cap) {\n\tG[v1].push_back({ v2, cap, (int)G[v2].size() });\n\tG[v2].push_back({ v1, cap, (int)G[v1].size() - 1 });\n}\n\nvoid BFS(int S) {\n\tmemset(level, -1, sizeof(level));\n\tqueue<int> Q;\n\tlevel[S] = 0;\n\tQ.push(S);\n\twhile (!Q.empty()) {\n\t\tint V = Q.front(); Q.pop();\n\t\tfor (edge E : G[V]) {\n\t\t\tif (E.cap > 0 && level[E.to] < 0) {\n\t\t\t\tlevel[E.to] = level[V] + 1;\n\t\t\t\tQ.push(E.to);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint DFS(int V, int T, int F) {\n\tif (V == T) return F;\n\tfor (int& i = iter[V]; i < G[V].size(); i++) {\n\t\tedge& E = G[V][i];\n\t\tif (E.cap > 0 && level[V] < level[E.to]) {\n\t\t\tint D = DFS(E.to, T, min(F, E.cap));\n\t\t\tif (D > 0) {\n\t\t\t\tE.cap -= D;\n\t\t\t\tG[E.to][E.rev].cap += D;\n\t\t\t\treturn D;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint max_flow(int S, int T) {\n\tint flow = 0;\n\twhile (1) {\n\t\tBFS(S);\n\t\tif (level[T] < 0) return flow;\n\t\tmemset(iter, 0, sizeof(iter));\n\t\tint F;\n\t\twhile ((F = DFS(S, T, INF)) > 0) {\n\t\t\tflow += F;\n\t\t}\n\t}\n}\n\nbool isPrime(long long X) {\n\tif (X <= 1) return false;\n\tfor (long long i = 2; i * i <= X; i++) if (X % i == 0) return false;\n\treturn true;\n}\n\nint main() {\n\tlong long N, X[100];\n\tmap<long long, bool> mp;\n\tcin >> N;\n\tfor (int i = 0; i < N; i++) cin >> X[i], mp[X[i]] = true;\n\tvector<long long> V;\n\tfor (int i = 0; i < N; i++) {\n\t\tif (!mp[X[i] - 1]) V.push_back(X[i]);\n\t\tif (!mp[X[i] + 1]) V.push_back(X[i] + 1);\n\t}\n\tlong long Even = 0, Odd = 0;\n\tfor (int i = 0; i < V.size(); i++) {\n\t\tif (V[i] % 2 == 0) add_edge(201, i, 1), Even++;\n\t\telse add_edge(i, 202, 1), Odd++;\n\t}\n\tfor (int i = 0; i < V.size(); i++) {\n\t\tif (V[i] % 2 == 1) continue;\n\t\tfor (int j = 0; j < V.size(); j++) {\n\t\t\tif (V[j] % 2 == 0) continue;\n\t\t\tif (isPrime(abs(V[i] - V[j]))) add_edge(i, j, 1);\n\t\t}\n\t}\n\tlong long MAX = max_flow(201, 202);\n\tcout << MAX + ((Even - MAX) / 2 + (Odd - MAX) / 2) * 2 + ((Even - MAX) % 2) * 3 << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define rg register\nusing namespace std;\nconst int MAXN=20010;\nstruct gao{   int u,v,Next;   }Edge[MAXN<<1];\nint n,Lo,Le,Seq[10000010],Odd[MAXN],Even[MAXN];\nint Ans,Es,Ps,First[MAXN],Match[MAXN],Vis[MAXN];\ninline int Read()\n{   rg int a=0,c=1;   rg char b=getchar();\n\twhile(b!='-'&&(b<'0'||b>'9'))b=getchar();\n\tif(b=='-')c=-1,b=getchar();\n\twhile(b>='0'&&b<='9')a=a*10+b-48,b=getchar();\n\treturn a*c;\n}\ninline void Link(rg int u,rg int v)\n{   Edge[++Es]=(gao){u,v,First[u]},First[u]=Es;   }\ninline int Abs(rg int A){   return A<0?-A:A;   }\ninline bool Judge(rg int Num)\n{   if(Num%2==0||Num<=2) return 0;\n\tfor(rg int i=3,End=sqrt(Num);i<=End;i+=2)\n\t\tif(Num%i==0) return 0;\n\treturn 1;\n}\ninline bool Couple(rg int Now,rg int Sign)\n{   for(rg int i=First[Now];i!=-1;i=Edge[i].Next)\n\t{   rg int v=Edge[i].v;   if(Vis[v]==Sign) continue ;\n\t\tVis[v]=Sign;\n\t\tif(!Match[v]||Couple(Match[v],Sign)) return Match[v]=Now,Match[Now]=v,1;\n\t}\n\treturn 0;\n}\nint main()\n{   scanf(\"%d\",&n);\n\tmemset(First,-1,sizeof(First));\n\tfor(rg int i=1;i<=n;i++) Seq[Read()]=1;\n\tfor(rg int i=1e7+1;i>=1;i--) Seq[i]=Seq[i]!=Seq[i-1];\n\tfor(rg int i=1;i<=1e7+1;i++) if(Seq[i]) i%2?Odd[++Lo]=i:Even[++Le]=i;\n\tif((Lo+Le)%2) return puts(\"0\");\n\tfor(rg int i=1;i<=Lo;i++)\n\t\tfor(rg int j=1;j<=Le;j++) if(Judge(Abs(Odd[i]-Even[j]))) Link(i,Lo+j),Link(Lo+j,i);\n\tfor(rg int i=1;i<=Lo;i++) if(!Match[i]) Ps+=Couple(i,i);\n\tAns=Ps+(Lo-Ps)/2*2+(Le-Ps)/2*2+((Lo-Ps)%2)*3,printf(\"%d\\n\",Ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cstdlib>\nusing namespace std;\n\n#define re_ return\n#define in_ inline\n#define op_ operator\n#define inc(l, i, r) for(i=l; i<r; ++i)\n#define st_ static\ntypedef long long ll;\n\nconst int mxn=1<<9;\n\nint n, m, a[mxn], b[mxn<<1], cnt[2], h[mxn<<1];\nstruct edge{int v, o;} e[mxn<<2];\n\nin_ ll dP(ll a, ll b, ll p)\n{\n    st_ ll r;\n    for(r=1; b; a=a*a%p, b>>=1)\n        b&1? r=r*a%p: 0;\n    re_ r;\n}\n\nin_ char chk(ll a, ll p)\n{\n    st_ ll s, r, i;\n    for(r=p-1, s=0; ~r&1; ++s, r/=2);\n    if(i=dP(a, r, p), i==1 || i==p-1) re_ 1;\n    for(;s--;)\n        if((i=i*i%p)==p-1) re_ 1;\n    re_ 0;\n}\n\nin_ char isP(int p)\n{\n    if(p==2) re_ 1;\n    if(p==1 || ~p&1) re_ 0;\n    st_  int i;\n    inc(0, i, 48)\n        if(!chk(rand()%(p-2)+1, p))\n            re_ 0;\n    re_ 1;\n}\n\nin_ void aE(int u, int v)\n{\n    st_ int tot;\n    e[++tot]=(edge){v, h[u]}, u[h]=tot;\n}\n\nchar vis[mxn<<1];\nchar Hun(int u)\n{\n    st_ int f[mxn<<1];\n    int i, v;\n    for(i=u[h]; v=i[e].v; i=i[e].o)\n        if(!vis[v])\n            if(vis[v]=1, !f[v] || Hun(f[v]))\n            re_ f[v]=u, 1;\n    re_ 0;\n}\n\nint main()\n{\n    srand(998244353);\n    int i, j;\n    scanf(\"%d\", &n);\n    inc(0, i, n)\n        scanf(\"%d\", a+i);\n    sort(a, a+n);\n    inc(0, i, n)\n    {\n        if(!i || a[i]>a[i-1]+1)\n            b[++m]=a[i], ++cnt[a[i]&1];\n        if(i>n-2 || a[i]<a[i+1]-1)\n            b[++m]=a[i]+1, ++cnt[a[i]+1&1];\n    }\n    inc(1, i, m+1)\n        if(b[i]&1)\n            inc(1, j, m+1)\n                if(~b[j]&1 && isP(abs(b[i]-b[j])))\n                    aE(i, j);\n\n    j=0;\n    inc(1, i, m+1)\n        if(b[i]&1)\n            memset(vis, 0, sizeof(vis)),\n                j+=Hun(i);\n\n    printf(\"%d\\n\", cnt[0]+cnt[1]-j+(cnt[0]-j&1));\n//    printf(\"%d\\n\", m);\n//    for(;;) scanf(\"%d\", &i), printf(\"%d\\n\", isP(i));\n    re_ 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\ninline int read()\n{\n\tint x = 0, op = 1; char ch = 0;\n\twhile(not isdigit(ch = getchar())) if(ch == '-') op = -op;\n\tdo x = x * 10 + (ch - '0'); while(isdigit(ch = getchar()));\n\treturn op * x;\n}\ninline bool check(int a, int x, int y, int z)\n{\n\tint u = 0, v = 0, w = 0;\n\t#define pows(a, b) \\\n\t\tu = (a), v = (b), w = 1;\\\n\t\twhile(v) { if(v & 1) w = w * u % x; u = u * u % x, v >>= 1; }\n\tpows(a, z);\n\tif(w > 1) { \n\t\tfor(int i = 0; i < y; i++) \n\t\t\tif(w == x - 1) return true;\n\t\treturn false;\n\t}\n\telse return true;\n}\nbool isprime(int x)\n{\n\tif(x == 2 || x == 7 || x == 61 || x == 3) return true;\n\tif(!(x % 2 && x % 7 && x % 61 && x % 3) || x == 1) return false;\n\tint y = 0, z = x - 1; while(!(z & 1)) y++, z >>= 1;\n\tbool ok = true;\t\n\tok &= check(2, x, y, z);\n\tok &= check(3, x, y, z);\n\tok &= check(7, x, y, z);\n\tok &= check(61, x, y, z);\n\treturn ok;\n}\nint n = 0, m = 0, pos[150], whi[300];\nbool used[300]; int ans = 0;\nint pygo[300]; bool insta[300];\nbool dfs(int x, int p)\n{\n\t#define able(a, b) (abs(whi[a] - whi[b]) > 2 && isprime(abs(whi[a] - whi[b])))\n\tfor(int i = 1; i <= m; i++)\n\t\tif(not insta[i] && able(x, i) && p != i)\n\t\t{\n\t\t\tinsta[i] = true;\n\t\t\tif(!pygo[i] || dfs(pygo[i], p))\n\t\t\t{\n\t\t\t\tpygo[x] = i, pygo[i] = x;\n\t\t\t\tused[x] = used[i] = true;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\treturn false;\n}\nsigned main()\n{\n\tn = read();\n\tfor(int i = 1; i <= n; i++) pos[i] = read();\n\tsort(pos + 1, pos + n + 1);\n\tfor(int i = 1; i <= n; i++)\n\t{\n\t\tif(i == 1 || pos[i] != pos[i - 1] + 1) whi[++m] = pos[i];\n\t\tif(i == n || pos[i] != pos[i + 1] - 1) whi[++m] = pos[i] + 1;\n\t}\n\tfor(int i = 1; i <= m; i++)\n\t\tif(not used[i]) memset(insta, 0, sizeof insta), dfs(i, i);\n\tfor(int i = 1; i <= n; i++)\n\t\tif(used[i]) ans++;\n\tans >>= 1LL;\n\tint tot[2] = {0, 0};\n\tfor(int i = 1; i <= m; i++)\n\t\tif(not used[i]) tot[whi[i] & 1]++;\n\tans += (((tot[0] >> 1LL) + (tot[1] >> 1LL)) << 1LL) + (tot[0] & 1LL) * 3LL;\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=110;\nbool pd(int k){\n\tif(k==1) return 0;\n\tint sk=sqrt(k);\n\tfor(int i=2;i<=sk;i++) if(!(k%i)) return 0;\n\treturn 1;\n}\nint n,b[N<<1],link[N],e[N<<1],o[N<<1];\nbool g[N][N],vis[N];\nbool dfs(int k){\n\tfor(int i=1;i<=e[0];i++){\n\t\tif(g[k][i]&&!vis[i]){\n\t\t\tvis[i]=1;\n\t\t\tif(link[i]||dfs(link[i])){\n\t\t\t\tlink[i]=k;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nint main(){\n\tint tx;\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++){\n\t\tscanf(\"%d\",&tx);\n\t\tif(b[b[0]]==tx) b[b[0]]++;\n\t\telse b[++b[0]]=tx,b[++b[0]]=tx+1;\n\t}\n\tfor(int i=1;i<=b[0];i++){\n\t\tif(b[i]&1) o[++o[0]]=b[i];\n\t\telse e[++e[0]]=b[i];\n\t}\n\tfor(int i=1;i<=o[0];i++)\n\t\tfor(int j=1;j<=e[0];j++){\n\t\t\tif(pd(abs(o[i]-e[j]))) g[i][j]=1;\n\t\t}\n\tint k=0;\n\tmemset(link,-1,sizeof(link));\n\tfor(int i=1;i<=o[0];i++){\n\t\tmemset(vis,0,sizeof(vis));\n\t\tif(dfs(i)) k++;\n\t}\n//\tcout<<k<<endl;\n\tcout<<k+((o[0]-k)/2+(e[0]-k)/2)*2+((e[0]-k)%2)*3<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <cstdio>\n\nusing namespace std;\n\nconst int N=105;\nconst int M=N*N;\nconst int L=10000000;\n\nint last[N],bel[N];\nint nxt[M],tov[M];\nbool mark[L+5];\nint pos[2][N];\nbool vis[N];\nint n,tot,mx,match,ans;\n\ninline int iabs(int x){return x>0?x:-x;}\n\ninline void insert(int x,int y){tov[++tot]=y,nxt[tot]=last[x],last[x]=tot;}\n\ninline bool is_prime(int x)\n{\n\tfor (int i=1;i*i<=x;++i) if (!(x%i)) return 0;\n\treturn 1;\n}\n\nbool hungary(int x)\n{\n\tif (vis[x]) return 0;\n\tvis[x]=1;\n\tfor (int i=last[x],y;i;i=nxt[i])\n\t\tif (!bel[y=tov[i]]||hungary(y))\n\t\t\treturn bel[y]=x;\n\treturn 0;\n}\n\nint main()\n{\n\t//freopen(\"flip.in\",\"r\",stdin),freopen(\"flip.out\",\"w\",stdout);\n\tscanf(\"%d\",&n);\n\tfor (int i=1,x;i<=n;++i) scanf(\"%d\",&x),mx=max(mx,x),mark[x]=1;\n\tfor (int i=1;i<=mx+1;++i)\n\t\tif (mark[i]^mark[i-1])\n\t\t\tif (i&1) pos[1][++pos[1][0]]=i;\n\t\t\telse pos[0][++pos[0][0]]=i;\n\tfor (int i=1;i<=pos[0][0];++i)\n\t\tfor (int j=1;j<=pos[1][0];++j)\n\t\t{\n\t\t\tint d=iabs(pos[0][i]-pos[1][j]);\n\t\t\tif (is_prime(d)) insert(i,j);\n\t\t}\n\tmatch=0;\n\tfor (int i=1;i<=pos[0][0];++i) memset(vis,0,sizeof vis),match+=hungary(i);\n\tans=match,pos[0][0]-=match,pos[1][0]-=match;\n\tans+=(pos[0][0]>>1)+(pos[1][0]>>1)<<1;\n\tpos[0][0]&=1,pos[1][0]&=1;\n\tif (pos[0][0]) ans+=3;\n\tprintf(\"%d\\n\",ans);\n\t//fclose(stdin),fclose(stdout);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// luogu-judger-enable-o2\n#include<iostream>\n#include<cstdio>\n#include<queue>\n#include<stack>\n#include<cstring>\n#include<algorithm>\n#include<vector>\n#include<cmath>\nusing namespace std;\nint e[101][101];\nint vis[101];\nint match[101];\nint tot1=0,tot2=0;\nbool find(int u)\n{\n\tfor(int i=1;i<=tot2;i++)\n\t{\n\t\tif(e[u][i])\n\t\t{\n\t\t\tvis[i]=1;\n\t\t\tif(!match[i]||find(match[i]))\n\t\t\t{\n\t\t\t\tmatch[i]=u;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n}\nbool isprime(int x)\n{\n\tif(x==1) return false;\n\tfor(int i=2;i<=sqrt(x);i++)\n\t\tif(x%i==0)\n\t\t\treturn false;\n\treturn true;\n}\nint x[101];\nint odd[101];\nint even[101];\nsigned main()\n{\n\tint n;\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)\n\t\tscanf(\"%d\",&x[i]);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tif(i==1||x[i-1]!=x[i]-1)\n\t\t{\n\t\t\tif(x[i]%2==1) odd[++tot1]=x[i];\n\t\t\telse even[++tot2]=x[i];\n\t\t}\n\t\tif(i==n||x[i+1]!=x[i]+1)\n\t\t{\n\t\t\tif(x[i]%2==1) even[++tot2]=x[i]+1;\n\t\t\telse odd[++tot1]=x[i]+1;\n\t\t}\n\t}\n\tfor(int i=1;i<=tot1;i++)\n\t\tfor(int j=1;j<=tot2;j++)\n\t\t\tif(isprime(abs(odd[i]-even[j])))\n\t\t\t\te[i][j]=1;\n\tint ans=0;\n\tfor(int i=1;i<=tot1;i++)\n\t{\n\t\tmemset(vis,0,sizeof(vis));\n\t\tif(find(i))\n\t\t\tans++;\n\t}\n\tprintf(\"%d\",ans+(tot1-ans)/2*2+(tot2-ans)/2*2+(tot1-ans)%2*3);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<string>\n#include<deque>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<set>\n#include<cmath>\n#include<tuple>\n#include<chrono>\n#include<functional>\n#include<iterator>\n#include<random>\n#include<unordered_set>\n#include<map>\nusing namespace std;\ntypedef long long int llint;\n#define mp make_pair\n#define mt make_tuple\n#define pub push_back\n#define puf push_front\n#define pob pop_back\n#define pof pop_front\n#define fir first\n#define sec second\n#define res resize\n#define ins insert\n#define era erase\nconst int mod=1000000007;\nconst llint big=1e18+10;\nconst long double pai=3.141592653589793238462643383279502884197;\nconst long double eps=1e-9;\ntemplate <class T,class U>void mineq(T& a,U b){if(a>b){a=b;}}\ntemplate <class T,class U>void maxeq(T& a,U b){if(a<b){a=b;}}\nint gcd(int a,int b){if(a%b==0){return b;}else return gcd(b,a%b);}\n\nstruct edge{int to,cap,rev;};\nvector<edge> G[202];\nbool used[202];\nint dfs(int v,int t,int f){\n\tif(v==t){return f;}\n\tused[v]=true;\n\tfor(int i=0;i<G[v].size();i++){\n\t\tedge &e=G[v][i];\n\t\tif(!used[e.to]&&e.cap>0){\n\t\t\tint d=dfs(e.to,t,min(f,e.cap));\n\t\t\tif(d>0){\n\t\t\t\te.cap-=d;\n\t\t\t\tG[e.to][e.rev].cap+=d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\treturn 0;\n}\nint max_flow(int s,int t){\n\tint flow=0;\n\twhile(-1){\n\t\tfor(int i=0;i<202;i++){\n\t\t\tused[i]=0;\n\t\t}\n\t\tint f=dfs(s,t,mod);\n\t\tif(f==0){return flow;}\n\t\tflow+=f;\n\t}\n}\nvoid add_edge(int from,int to,int cap){\n\tedge E;\n\tE.to=to,E.cap=cap;E.rev=(int)G[to].size();\n\tG[from].pub(E);\n\tE.to=from,E.cap=0;E.rev=(int)G[from].size()-1;\n\tG[to].pub(E);\n}\nvector<int>primelist;\nbool isprime(int it){\n\tif(it<2){return false;}\n\tfor(int i=0;i<primelist.size();i++){\n\t\tint p=primelist[i];\n\t\tif(p*p>it){break;}\n\t\tif(it%p==0){return false;}\n\t}\n\treturn true;\n}\nvoid primeinit(void){\n\tfor(int i=2;i<3200;i++){//root(1e7)\n\t\tif(isprime(i)){primelist.pub(i);}\n\t}\n}\n\nint main(void){\n\tllint n,i,j,q,ans=0;cin>>n;\n\t//頂点名\n\t//0 start\n\t//1~100 奇数\n\t//101~200 偶数\n\t//201 goal\n\tvector<int>flip;\n\tprimeinit();\n\tfor(i=0;i<n;i++){\n\t\tcin>>q;\n\t\tif(i==0||flip.back()!=q){flip.pub(q);}\n\t\telse{flip.pob();}\n\t\tflip.pub(q+1);\n\t}\n\tint kif[100]={0};\n\tint guf[100]={0};\n\tint kisu=0,gusu=0;\n\tfor(i=0;i<flip.size();i++){\n\t\tif(flip[i]%2==1){\n\t\t\tkif[kisu]=flip[i];kisu++;\n\t\t}else{\n\t\t\tguf[gusu]=flip[i];gusu++;\n\t\t}\n\t}\n\tfor(i=0;i<kisu;i++){\n\t\tfor(j=0;j<gusu;j++){\n\t\t\tif(isprime(abs(kif[i]-guf[j]))){\n\t\t\t\tadd_edge(i+1,j+101,1);\n\t\t\t}\n\t\t}\n\t}\n\tfor(i=0;i<kisu;i++){add_edge(0,i+1,1);}\n\tfor(i=0;i<gusu;i++){add_edge(i+101,201,1);}\n\tint match=max_flow(0,201);\n\tans+=match;\n\tans+=((kisu-match)/2)*2;\n\tans+=((gusu-match)/2)*2;\n\tif((kisu-match)%2==1){ans+=3;}\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<cmath>\n#define N 210\n#define M 10000020\nusing namespace std;\nint prime[M],link[N],tot;\nbool p[M],vis[N];\nint n;\nbool can[N][N],s[M];\nvector<int>v[2];\nbool check(int u)\n{\n\tfor(int i=1;i<=v[1].size();i++)\n\tif(can[u][i] && !vis[i])\n\t{\n\t\tvis[i]=1;\n\t\tif(!link[i] || check(link[i]))\n \t\t{\n\t\t\tlink[i]=u;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\nint main()\n{\n\tp[1]=true;\n\tfor(int i=2;i<=M-10;i++)\n\t{\n\t\tif(!p[i]) prime[++tot]=i;\n\t\tfor(int j=1;j<=tot && i*prime[j]<=M-10;j++)\n\t\t{\n\t\t\tp[i*prime[j]]=1;\n\t\t\tif(i%prime[j]==0) break;\n\t\t}\n\t}\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint u;\n\t\tscanf(\"%d\",&u);\n\t\ts[u]=true;\n\t}\n\tfor(int i=1;i<=M-10;i++)\n\tif(s[i]^s[i-1]) v[i&1].push_back(i);\n\tfor(int i=0;i<v[0].size();i++)\n\t\tfor(int j=0;j<v[1].size();j++)\n\t\tif(!p[abs(v[0][i]-v[1][j])]) can[i+1][j+1]=true;\n\tint ans=0;\n    for(int i=0;i<v[0].size();i++)\n\t{\n\t\tmemset(vis,0,sizeof(vis));\n\t\tans+=check(i+1);\n\t}\n\tint tmp=ans;\n\tans+=(v[0].size()-ans)/2*2+(v[1].size()-ans)/2*2;\n    if((v[0].size()&1)!=(tmp&1)) ans+=3;\n\tprintf(\"%d\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#define _GLIBCXX_DEBUG\n\n#include<bits/stdc++.h>\nusing namespace std;\n\n#define endl '\\n'\n#define lfs cout<<fixed<<setprecision(10)\n#define ALL(a)  (a).begin(),(a).end()\n#define ALLR(a)  (a).rbegin(),(a).rend()\n#define spa << \" \" <<\n#define fi first\n#define se second\n#define MP make_pair\n#define MT make_tuple\n#define PB push_back\n#define EB emplace_back\n#define rep(i,n,m) for(ll i = (n); i < (ll)(m); i++)\n#define rrep(i,n,m) for(ll i = (ll)(m) - 1; i >= (ll)(n); i--)\nusing ll = long long;\nusing ld = long double;\nconst ll MOD1 = 1e9+7;\nconst ll MOD9 = 998244353;\nconst ll INF = 1e18;\nusing P = pair<ll, ll>;\ntemplate<typename T1, typename T2>bool chmin(T1 &a,T2 b){if(a>b){a=b;return true;}else return false;}\ntemplate<typename T1, typename T2>bool chmax(T1 &a,T2 b){if(a<b){a=b;return true;}else return false;}\nll median(ll a,ll b, ll c){return a+b+c-max({a,b,c})-min({a,b,c});}\nvoid ans1(bool x){if(x) cout<<\"Yes\"<<endl;else cout<<\"No\"<<endl;}\nvoid ans2(bool x){if(x) cout<<\"YES\"<<endl;else cout<<\"NO\"<<endl;}\nvoid ans3(bool x){if(x) cout<<\"Yay!\"<<endl;else cout<<\":(\"<<endl;}\ntemplate<typename T1,typename T2>void ans(bool x,T1 y,T2 z){if(x)cout<<y<<endl;else cout<<z<<endl;}  \ntemplate<typename T>void debug(vector<vector<T>>&v,ll h,ll w){for(ll i=0;i<h;i++){cout<<v[i][0];for(ll j=1;j<w;j++)cout spa v[i][j];cout<<endl;}};\nvoid debug(vector<string>&v,ll h,ll w){for(ll i=0;i<h;i++){for(ll j=0;j<w;j++)cout<<v[i][j];cout<<endl;}};\ntemplate<typename T>void debug(vector<T>&v,ll n){if(n!=0)cout<<v[0];for(ll i=1;i<n;i++)cout spa v[i];cout<<endl;};\ntemplate<typename T>vector<vector<T>>vec(ll x, ll y, T w){vector<vector<T>>v(x,vector<T>(y,w));return v;}\nll gcd(ll x,ll y){ll r;while(y!=0&&(r=x%y)!=0){x=y;y=r;}return y==0?x:y;}\nvector<ll>dx={1,-1,0,0,1,1,-1,-1};vector<ll>dy={0,0,1,-1,1,-1,1,-1};\ntemplate<typename T>vector<T> make_v(size_t a,T b){return vector<T>(a,b);}\ntemplate<typename... Ts>auto make_v(size_t a,Ts... ts){return vector<decltype(make_v(ts...))>(a,make_v(ts...));}\ntemplate<typename T1, typename T2>ostream &operator<<(ostream &os, const pair<T1, T2>&p){return os << p.first << \" \" << p.second;}\ntemplate<typename T>ostream &operator<<(ostream &os, const vector<T> &v){for(auto &z:v)os << z << \" \";cout<<\"|\"; return os;}\n//mt19937 mt(chrono::steady_clock::now().time_since_epoch().count());\nvector< bool > prime_table(ll n) {\n  vector< bool > prime(n + 1, true);\n  if(n >= 0) prime[0] = false;\n  if(n >= 1) prime[1] = false;\n  for(ll i = 2; i * i <= n; i++) {\n    if(!prime[i]) continue;\n    for(ll j = i + i; j <= n; j += i) {\n      prime[j] = false;\n    }\n  }\n  return prime;\n}\ntemplate< typename flow_t, typename cost_t >\nstruct PrimalDual {\n  const cost_t INF;\n\n  struct edge {\n    ll to;\n    flow_t cap;\n    cost_t cost;\n    ll rev;\n    bool isrev;\n  };\n  vector< vector< edge > > graph;\n  vector< cost_t > potential, min_cost;\n  vector< ll > prevv, preve;\n\n  PrimalDual(ll V) : graph(V), INF(numeric_limits< cost_t >::max()) {}\n\n  void add_edge(ll from, ll to, flow_t cap, cost_t cost) {\n    graph[from].emplace_back((edge) {to, cap, cost, (ll) graph[to].size(), false});\n    graph[to].emplace_back((edge) {from, 0, -cost, (ll) graph[from].size() - 1, true});\n  }\n\n  cost_t min_cost_flow(ll s, ll t, flow_t f) {\n    ll V = (ll) graph.size();\n    cost_t ret = 0;\n    using Pi = pair< cost_t, ll >;\n    priority_queue< Pi, vector< Pi >, greater< Pi > > que;\n    potential.assign(V, 0);\n    preve.assign(V, -1);\n    prevv.assign(V, -1);\n\n    while(f > 0) {\n      min_cost.assign(V, INF);\n      que.emplace(0, s);\n      min_cost[s] = 0;\n      while(!que.empty()) {\n        Pi p = que.top();\n        que.pop();\n        if(min_cost[p.second] < p.first) continue;\n        for(ll i = 0; i < graph[p.second].size(); i++) {\n          edge &e = graph[p.second][i];\n          cost_t nextCost = min_cost[p.second] + e.cost + potential[p.second] - potential[e.to];\n          if(e.cap > 0 && min_cost[e.to] > nextCost) {\n            min_cost[e.to] = nextCost;\n            prevv[e.to] = p.second, preve[e.to] = i;\n            que.emplace(min_cost[e.to], e.to);\n          }\n        }\n      }\n      if(min_cost[t] == INF) return -1;\n      for(ll v = 0; v < V; v++) potential[v] += min_cost[v];\n      flow_t addflow = f;\n      for(ll v = t; v != s; v = prevv[v]) {\n        addflow = min(addflow, graph[prevv[v]][preve[v]].cap);\n      }\n      f -= addflow;\n      ret += addflow * potential[t];\n      for(ll v = t; v != s; v = prevv[v]) {\n        edge &e = graph[prevv[v]][preve[v]];\n        e.cap -= addflow;\n        graph[v][e.rev].cap += addflow;\n      }\n    }\n    return ret;\n  }\n\n  void output() {\n    for(ll i = 0; i < graph.size(); i++) {\n      for(auto &e : graph[i]) {\n        if(e.isrev) continue;\n        auto &rev_e = graph[e.to][e.rev];\n        cout << i << \"->\" << e.to << \" (flow: \" << rev_e.cap << \"/\" << rev_e.cap + e.cap << \")\" << endl;\n      }\n    }\n  }\n  using R=vector<pair<pair<ll,ll>,pair<flow_t,cost_t>>>;\n  R restore() {\n    R ret;\n    for(ll i = 0; i < graph.size(); i++) {\n      for(auto &e : graph[i]) {\n        if(e.isrev) continue;\n        auto &rev_e = graph[e.to][e.rev];\n        ret.emplace_back(make_pair(i,e.to),make_pair(rev_e.cap,e.cost));\n      }\n    }\n    return ret;\n  }\n};\nint main(){\n  cin.tie(nullptr);\n  ios_base::sync_with_stdio(false);\n  ll res=0,buf=0;\n  bool judge = true;\n  ll lim=1e7+30;\n  //ll lim=1e3;cout<<\"naosu\"<<endl;\n  auto pr=prime_table(lim);\n  /*vector<ll>p;\n  rep(i,0,lim)if(pr[i])p.PB(i);\n  ll sz=p.size();*/\n  ll n;cin>>n;\n  vector<ll>x(n);\n  rep(i,0,n)cin>>x[i];\n  vector<ll>y;\n  rep(i,0,n){\n    y.PB(x[i]);\n    y.PB(x[i]+1);\n  }\n  //cout<<lim<<endl;\n  {\n    vector<ll>tmp;\n    sort(ALL(y));\n    rep(i,0,y.size()){\n      if(i+1<y.size()&&y[i]==y[i+1])i++;\n      else tmp.PB(y[i]);\n    }\n    y=tmp;\n  }\n  pr[2]=false;\n  ll sz=y.size();\n  PrimalDual<ll,ll>fl(2*sz+2);\n  rep(i,0,sz)rep(j,0,sz){\n    if(i==j)continue;\n    ll dif=abs(y[i]-y[j]);\n    ll cost=0;\n    if(dif==0)cost=0;\n    else if(dif%2==0)cost=2;\n    else if(pr[dif])cost=1;\n    else cost=3;\n    //cout<<dif spa cost spa y[i] spa y[j]<<endl;\n    fl.add_edge(i,j+sz,1,cost);\n  }\n  ll S=2*sz,T=2*sz+1;\n  rep(i,0,sz){\n    fl.add_edge(S,i,1,0);\n    fl.add_edge(i+sz,T,1,0);\n  }\n  //cout<<sz<<endl;\n  //debug(y,sz);\n  ll lk=fl.min_cost_flow(S,T,sz);\n  cout<<lk/2<<endl;\n  /*auto r=fl.restore();\n  for(auto z:r){\n    if(z.se.fi==1&&z.fi.fi<sz&&z.fi.se<2*sz){\n      cout<<y[z.fi.fi] spa y[z.fi.se-sz]<<endl;\n    }\n  }*/\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int inf=0x3f3f3f3f;\nint read()\n{\n\tint r=0,f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9')r=(r<<1)+(r<<3)+ch-'0',ch=getchar();\n\treturn r*f;\n}\nbool np[10000100];\nint pri[5000500],tot;\nvoid Euler()\n{\n\tnp[1]=1;int ma=1e7;\n\tfor(int i=2;i<=ma;++i)\n\t{\n\t\tif(!np[i])pri[++tot]=i;\n\t\tfor(int j=1;j<=tot&&i*pri[j]<=ma;++j)\n\t\t{\n\t\t\tnp[i*pri[j]]=1;\n\t\t\tif(i%pri[j]==0)break;\n\t\t}\n\t}\n}\nint n;\nbool po[10000100];\nint pos[550];\nstruct data{\n\tint to,nxt,c;\n}mp[200200];\nint head[550],cnt=1;\nint s,t;\nint cur[550];\nvoid link(int x,int y,int c)\n{\n\tmp[++cnt].to=y;\n\tmp[cnt].nxt=head[x];\n\tmp[cnt].c=c;\n\thead[x]=cnt;\n}\nvoid add(int x,int y,int c)\n{\n\tlink(x,y,c);link(y,x,0);\n//\tcout<<\"x: \"<<x<<\" y: \"<<y<<endl;\n}\nint dis[550];\nqueue<int>q;\nbool bfs()\n{\n\tfor(int i=1;i<=t;++i)dis[i]=0;\n\tdis[s]=1;q.push(s);\n\tint u;\n\twhile(!q.empty())\n\t{\n\t\tu=q.front();q.pop();\n\t\tfor(int i=head[u];i;i=mp[i].nxt)\n\t\t\tif(!dis[mp[i].to]&&mp[i].c)\n\t\t\t\tdis[mp[i].to]=dis[u]+1,q.push(mp[i].to);\n\t}\n\treturn dis[t];\n}\nint dfs(int x,int f)\n{\n\tif(x==t)return f;\n//\tcout<<\"x: \"<<x<<\" f: \"<<f<<endl;\n\tint fl,rf=0;\n\tfor(int& i=cur[x];i;i=mp[i].nxt)\n\t\tif(dis[mp[i].to]==dis[x]+1&&mp[i].c)\n\t\t{\n\t\t\tfl=dfs(mp[i].to,min(f,mp[i].c));\n\t\t\tif(fl)\n\t\t\t{\n\t\t\t\tf-=fl;rf+=fl;\n\t\t\t\tmp[i].c-=fl;\n\t\t\t\tmp[i^1].c+=fl;\n\t\t\t\tif(!f)break;\n\t\t\t}\n\t\t}\n\treturn rf;\n}\nint Dinic()\n{\n\tint maxflow=0,flow;\n\twhile(bfs())\n\t{\n\t\tfor(int i=1;i<=t;++i)cur[i]=head[i];\n\t\twhile(flow=dfs(s,inf))maxflow+=flow;\n\t}\n\treturn maxflow;\n}\nint main()\n{\n\tEuler();\n//\tfor(int i=1;i<=10;++i)cout<<np[i]<<\" \";cout<<endl;\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;++i)po[read()]=1;\n\tn=0;\n\tfor(int i=1;i<=1e7+1;++i)\n\t\tif(po[i]!=po[i-1]) pos[++n]=i;\n\ts=n+1,t=n+2;\n\tint odd=0,even=0;\n//\tfor(int i=1;i<=n;++i)cout<<pos[i]<<\" \";cout<<endl;\n\tfor(int i=1;i<=n;++i)\n\t\tif(pos[i]&1)\n\t\t{\n\t\t\tadd(s,i,1);\n\t\t\todd++;\n\t\t\tfor(int j=1;j<=n;++j)\n\t\t\t\tif((!(pos[j]&1))&&(!np[abs(pos[i]-pos[j])]))\n\t\t\t\t\tadd(i,j,1);\n\t\t}\n\tfor(int i=1;i<=n;++i)\n\t\tif(!(pos[i]&1))add(i,t,1),even++;\n//\tcout<<\"even: \"<<even<<\" odd: \"<<odd<<endl;\n//\tcout<<\"wuhuu\\n\";\n\tint ans=Dinic();\n//\tcout<<\"ans: \"<<ans<<endl;\n\teven-=ans;odd-=ans;\n\tif((even&1)||(odd&1))ans+=3;\n\teven-=even&1;odd-=odd&1;\n\tans+=even+odd;\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <cstring>\n#include <climits>\n#include <queue>\n#include <vector>\n\nconst int N = 202;\nconst int M = 10000001;\n\nbool is_prime[M];\nint x[N], flow[N][N], cost[N][N], dist[N], pred[N];\nbool visit[N];\n\nvoid add_edge(int u, int v, int ca, int co)\n{\n    flow[u][v] = ca;\n    cost[u][v] = co;\n    cost[v][u] = -co;\n}\n\nint main()\n{\n#ifdef LOCAL_JUDGE\n    freopen(\"F.in\", \"r\", stdin);\n#endif\n\n    memset(is_prime, true, sizeof(is_prime));\n    std::vector<int> primes;\n    for (int d = 2; d < M; ++ d) {\n        if (is_prime[d]) {\n            primes.push_back(d);\n        }\n        for (auto&& p : primes) {\n            if (d * p >= M) {\n                break;\n            }\n            is_prime[d * p] = false;\n            if (d % p == 0) {\n                break;\n            }\n        }\n    }\n    is_prime[1] = false;\n\n    int n;\n    while (scanf(\"%d\", &n) == 1) {\n        for (int i = 0; i < n; ++ i) {\n            scanf(\"%d\", x + i);\n        }\n        std::vector<int> odds, evens;\n\n        auto add = [&](int x) {\n            (x & 1 ? odds : evens).push_back(x);\n        };\n\n        for (int i = 0; i < n; ++ i) {\n            if (i == 0 || x[i - 1] != x[i] - 1) {\n                add(x[i]);\n            }\n            if (i + 1 == n || x[i] + 1 != x[i + 1]) {\n                add(x[i] + 1);\n            }\n        }\n\n        // for (int i = 0; i < odds.size(); ++ i) { printf(\"%d,\", odds[i]); } puts(\"\");\n        // for (int i = 0; i < evens.size(); ++ i) { printf(\"%d,\", evens[i]); } puts(\"\");\n\n        int s = odds.size() + evens.size();\n        int t = s + 1;\n        memset(flow, 0, sizeof(flow));\n        memset(cost, 0, sizeof(cost));\n        for (int i = 0; i < (int)odds.size(); ++ i) {\n            add_edge(s, i, 1, 0);\n            for (int j = 0; j < (int)evens.size(); ++ j) {\n                int d = std::abs(odds[i] - evens[j]);\n                add_edge(i, (int)odds.size() + j, 1, is_prime[d] ? 1 : 3);\n            }\n        }\n        for (int i = 0; i < (int)evens.size(); ++ i) {\n            add_edge((int)odds.size() + i, t, 1, 0);\n        }\n\n        int result = INT_MAX;\n        int f = 0, co = 0;\n        while (true) {\n            int oc = odds.size() - f;\n            int ec = evens.size() - f;\n            if (oc % 2 == 0 && ec % 2 == 0) {\n                result = std::min(result, co + oc + ec);\n            }\n            for (int i = 0; i <= t; ++ i) {\n                dist[i] = INT_MAX;\n            }\n            dist[s] = 0;\n            std::queue<int> queue;\n            queue.push(s);\n            memset(visit, 0, sizeof(visit));\n            while (!queue.empty()) {\n                int u = queue.front();\n                queue.pop();\n                visit[u] = false;\n                for (int v = 0; v <= t; ++ v) {\n                    if (flow[u][v] > 0 && dist[u] + cost[u][v] < dist[v]) {\n                        pred[v] = u;\n                        dist[v] = dist[u] + cost[u][v];\n                        if (!visit[v]) {\n                            visit[v] = true;\n                            queue.push(v);\n                        }\n                    }\n                }\n            }\n            if (dist[t] == INT_MAX) {\n                break;\n            }\n            f ++;\n            co += dist[t];\n            for (int v = t; v != s; v = pred[v]) {\n                int u = pred[v];\n                flow[u][v] --;\n                flow[v][u] ++;\n            }\n        }\n        printf(\"%d\\n\", result);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint n,b,ans=0;\nint a[105],f[105][105];\nint x[2][105],cnt[2],c;\nint p[10000005],prime[3000005],tot=0;\nint vis[105],link[105];\n\nint dfs(int x){\n\tfor(int i=1;i<=cnt[1];i++){\n\t\tif(vis[i]==0&&f[x][i]==1){\n\t\t\tvis[i]=1;\n\t\t\tif(link[i]==0||dfs(link[i])){\n\t\t\t\tlink[i]=x;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint main(){\n\tscanf(\"%d\",&n);\n\ta[0]=-1;\n\tfor(int i=2;i<=10000000;i++){\n\t\tif(p[i]==0) prime[++tot]=i;\n\t\tfor(int j=1;j<=tot&&i*prime[j]<=10000000;j++){\n\t\t\tp[i*prime[j]]=1;\n\t\t\tif(i%prime[j]==0) break;\n\t\t}\n\t}\n\tp[1]=p[2]=1;\n\tfor(int i=1;i<=n;i++) scanf(\"%d\",&a[i]);\n\tsort(a+1,a+n+1);\n\tfor(int i=1;i<=n;i++){\n\t\tif(a[i]==a[i-1]+1) continue;\n\t\tif(a[i-1]!=-1) x[c=(a[i-1]+1)&1][++cnt[c]]=a[i-1]+1;\n\t\tx[c=a[i]&1][++cnt[c]]=a[i];\n\t}\n\tx[c=(a[n]+1)&1][++cnt[c]]=a[n]+1;\n\tfor(int i=1;i<=cnt[0];i++){\n\t\tfor(int j=1;j<=cnt[1];j++){\n\t\t\tif(p[abs(x[0][i]-x[1][j])]==0) f[i][j]=1;\n\t\t}\n\t}\n\tfor(int i=1;i<=cnt[0];i++) if(dfs(i)) ans++;\n\tcnt[1]-=ans,cnt[0]-=ans;\n\tans+=2*(cnt[1]/2+cnt[0]/2);\n\tif(cnt[1]&1) ans+=3;\n\tprintf(\"%d\\n\",ans);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn=105;\nint n,a[maxn],cnt[2],match[maxn<<1];\nbool used[maxn<<1];\nvector<int> G[maxn<<1],diff;\nset<int> vis;\nbool dfs(int v) {\n    used[v]=1;\n    for (int i=0;i<(int)G[v].size();++i) {\n        int u=G[v][i],w=match[u];\n        if (w==-1||(!used[w]&&dfs(w))) {\n            match[v]=u;\n            match[u]=v;\n            return true;\n        }\n    }\n    return false;\n}\ninline int bipartite_matching() {\n    int ret=0;\n    memset(match,-1,sizeof match);\n    for (int i=0;i<(int)diff.size();++i)\n        if (diff[i]%2==1&&match[i]==-1) {\n            memset(used,0,sizeof used);\n            ret+=dfs(i);\n        }\n    return ret;\n}\nbool check(int x) {\n    if (x<=2)\n        return false;\n    for (int i=2;i*i<=x;++i)\n        if (x%i==0)\n            return false;\n    return true;\n}\nint main()\n{\n    scanf(\"%d\",&n);\n    for (int i=1;i<=n;++i) {\n        scanf(\"%d\",&a[i]);\n        vis.insert(a[i]);\n    }\n    for (int i=1;i<=n;++i) {\n        if (vis.find(a[i]-1)==vis.end()) {\n            diff.push_back(a[i]);\n            ++cnt[a[i]%2];\n        }\n        if (vis.find(a[i]+1)==vis.end()) {\n            diff.push_back(a[i]+1);\n            ++cnt[(a[i]+1)%2];\n        }\n    }\n    for (int i=0;i<(int)diff.size();++i)\n        for (int j=i+1;j<(int)diff.size();++j)\n            if (check(abs(diff[i]-diff[j]))) {\n                G[i].push_back(j);\n                G[j].push_back(i);\n            }\n    int k=bipartite_matching();\n    printf(\"%d\\n\",k+2*((cnt[0]-k)/2+(cnt[1]-k)/2)+(cnt[0]-k)%2*3);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\n#include<queue>\nusing namespace std;\n#define SIZE 1002\nvector<int>pat[SIZE];\nvector<int>cap[SIZE];\nvector<int>cost[SIZE];\nvector<int>rev[SIZE];\nvoid adde(int a, int b, int cp, int cst)\n{\n\tpat[a].push_back(b);\n\tpat[b].push_back(a);\n\tcap[a].push_back(cp);\n\tcap[b].push_back(0);\n\tcost[a].push_back(cst);\n\tcost[b].push_back(-cst);\n\trev[a].push_back(pat[b].size() - 1);\n\trev[b].push_back(pat[a].size() - 1);\n}\nint dist[SIZE];\nint nd[SIZE];\ntypedef pair<int, int>pii;\nint frv[SIZE], fre[SIZE];\nint nod;\nint mincostflow(int st, int go, int gen)\n{\n\tint ret = 0;\n\tfill(nd, nd + SIZE, 0);\n\tfor (;;)\n\t{\n\t\tif (gen == 0)return ret;\n\t\tpriority_queue<pii>que;\n\t\tque.push(make_pair(0, st));\n\t\tfill(dist, dist + nod, 1000000000);\n\t\tfor (;;)\n\t\t{\n\t\t\tif (que.empty())break;\n\t\t\tpii zan = que.top();\n\t\t\tque.pop();\n\t\t\tif (dist[zan.second]<-zan.first)continue;\n\t\t\tdist[zan.second] = -zan.first;\n\t\t\tfor (int i = 0; i<pat[zan.second].size(); i++)\n\t\t\t{\n\t\t\t\tif (cap[zan.second][i]>0 && dist[pat[zan.second][i]]>dist[zan.second] + cost[zan.second][i] + nd[zan.second] - nd[pat[zan.second][i]])\n\t\t\t\t{\n\t\t\t\t\tdist[pat[zan.second][i]] = dist[zan.second] + cost[zan.second][i] + nd[zan.second] - nd[pat[zan.second][i]];\n\t\t\t\t\tfrv[pat[zan.second][i]] = zan.second;\n\t\t\t\t\tfre[pat[zan.second][i]] = i;\n\t\t\t\t\tque.push(make_pair(-dist[pat[zan.second][i]], pat[zan.second][i]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (dist[go] == 1000000000)return -1;\n\t\tfor (int i = 0; i<nod; i++)nd[i] += dist[i];\n\t\tint fl = gen;\n\t\tint now = go;\n\t\tfor (;;)\n\t\t{\n\t\t\tif (now == st)break;\n\t\t\tint t = fre[now];\n\t\t\tnow = frv[now];\n\t\t\tfl = min(fl, cap[now][t]);\n\t\t}\n\t\tgen -= fl;\n\t\tret += fl*nd[go];\n\t\tnow = go;\n\t\tfor (;;)\n\t\t{\n\t\t\tif (now == st)break;\n\t\t\tint t = fre[now];\n\t\t\tint nx = now;\n\t\t\tnow = frv[now];\n\t\t\tcap[now][t] -= fl;\n\t\t\tcap[nx][rev[now][t]] += fl;\n\t\t}\n\t}\n\treturn ret;\n}\nbool np[10101010];\nint d[111];\nint main()\n{\n\tint num;\n\tscanf(\"%d\", &num);\n\tfor (int i = 0; i < num; i++)scanf(\"%d\", &d[i]);\n\tvector<int>v1, v2;\n\tfor (int i = 0; i < num; i++)\n\t{\n\t\tif (i == 0)v1.push_back(d[i]);\n\t\telse if (d[i - 1] + 1 != d[i])v1.push_back(d[i]);\n\t\tif (i == num - 1)v2.push_back(d[i] + 1);\n\t\telse if (d[i + 1] - 1 != d[i])v2.push_back(d[i] + 1);\n\t}\n\tnp[1] = true;\n\tfor (int i = 2; i <= 10000000; i++)\n\t{\n\t\tif (np[i])continue;\n\t\tfor (int j = i + i; j <= 10000000; j += i)np[j] = true;\n\t}\n\tfor (int i = 0; i < v1.size(); i++)\n\t{\n\t\tfor (int j = 0; j < v2.size(); j++)\n\t\t{\n\t\t\tint t = v2[j] - v1[i];\n\t\t\tif (t < 0)t = -t;\n\t\t\tif (t % 2 == 0)adde(i + 2, j + num + 2, 1, 2);\n\t\t\telse if (np[t])adde(i + 2, j + num + 2, 1, 3);\n\t\t\telse adde(i + 2, j + num + 2, 1, 1);\n\t\t}\n\t}\n\tfor (int i = 0; i < num; i++)adde(0, i + 2, 1, 0), adde(i + num + 2, 1, 1, 0);\n\tnod = num * 2 + 2;\n\tprintf(\"%d\\n\", mincostflow(0, 1, v1.size()));\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define REP(I, A) for(int (I) = 0; (I) < (A); (I)++)\n#define pb(I) push_back(I)\nconst int N = 10000000;\n\nset<int> s, e;\nvector<int> vx, vy, Gx[200];\nbool is_prime[N];\nint mat[1000], R;\nbool vis[1000];\n\nvoid prepare() {\n\tfor (int i = 2; i < N; i++) {\n\t\tfor (int j = 2*i; j < N; j+=i)\n\t\t\tis_prime[j] = true;\n\t}\n}\n\nbool dfs(int x) {\n\tfor (int v : Gx[x]) {\n\t\tif(!vis[v]) {\n\t\t\tvis[v] = true;\n\t\t\tif(mat[v+R] == -1 || dfs(mat[v+R])) {\n\t\t\t\tmat[v+R] = x;\n\t\t\t\tmat[x] = v;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\nint domatch() {\n\tmemset(mat, -1, sizeof(mat));\n\tint cnt = 0;\n\tREP(i, vx.size()) {\n\t\tif(mat[i]) continue;\n\t\tmemset(vis, 0, sizeof(vis));\n\t\tcnt += dfs(vx[i]);\n\t}\n\treturn cnt;\n}\n\nint main() {\n\tprepare();\n\tint n, x;\n\tscanf(\"%d\", &n);\n\tR = 110;\n\tREP(i, n) {\n\t\tscanf(\"%d\", &x);\n\t\ts.insert(x);\n\t}\n\tfor (int u : s) {\n\t\tif(!s.count(u-1)) e.insert(u);\n\t\tif(!s.count(u+1)) e.insert(u+1);\n\t}\n\tfor (int u : e)\n\t\tif(u&1) vx.pb(u);\n\t\telse vy.pb(u);\n\tREP(i, vx.size())\n\t\tREP(j, vy.size())\n\t\t\tif(!is_prime[abs(vx[i]-vy[j])])\n\t\t\t\tGx[i].pb(j);\n\tint t = domatch();\n\tint l1 = vx.size() - t, l2 = vy.size() - t;\n\tint res = t;\n\tres += l1/2*2;\n\tres += l2/2*2;\n\tif(l1%2==1 && l2%2==1) res += 3;\n\tcout << res << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\nconst ld eps = 1e-9;\n\nvector<int>primes;\nvoid hurui(const int amax) {\n\tstatic bool flag = false;\n\tif (flag)return;\n\tvector<int>sos;\n\tsos = vector<int>(amax + 1, true);\n\tsos[0] = false; sos[1] = false;\n\tfor (int i = 2; i <= amax; ++i) {\n\t\tif (sos[i]) {\n\t\t\tfor (int j = 2 * i; j <= amax; j += i)sos[j] = false;\n\t\t}\n\t}\n\tfor (int i = 0; i <= amax; ++i) {\n\t\tif (sos[i]) {\n\t\t\tprimes.push_back(i);\n\t\t}\n\t}\n\tflag = true;\n}\n\nvector<int>v;\nmap<pair<int, int>, int>memo;\nint solve(int l, int r) {\n\tif (l + 1 == r)return 3;\n\tif (memo.find(make_pair(l, r)) != memo.end())return memo[make_pair(l, r)];\n\tint ans = 0;\n\tvector<int>as(v.begin() + l, v.begin() + r);\n\tint t = as.back() - as.front() + 1;\n\tif (t % 2) {\n\t\tif (binary_search(primes.begin(), primes.end(), t)) {\n\t\t\tans = 1;\n\t\t}\n\t\telse {\n\t\t\tans = 3;\n\t\t}\n\t}\n\telse {\n\t\tans = 2;\n\t}\n\tfor (int i = 0; i < as.size() - 1; ++i) {\n\t\tint k = as[i + 1] - as[i] - 1;\n\t\tif (k % 2) {\n\t\t\tif (binary_search(primes.begin(), primes.end(), k)) {\n\t\t\t\tans += 1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tans += 3;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (k == 0)ans += 0;\n\t\t\telse ans += 2;\n\t\t}\n\t}\n\tfor (int k = l + 1; k <= r - 1; ++k) {\n\t\tans = min(ans, solve(l, k) + solve(k, r));\n\t}\n\treturn memo[make_pair(l,r)]=ans;\n}\n\nint main() {\n\thurui(1e7);\n\tint N; cin >> N;\n\n\tfor (int i = 0; i < N; ++i) {\n\t\tint a; cin >> a;\n\t\tv.emplace_back(a);\n\t}\n\tint aans = solve(0, N);\n\tcout << aans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author\n */\n\n#ifndef MAJK_LIB\n#define MAJK_LIB\n\n#include <vector>\n#include <stack>\n#include <iostream>\n#include <unordered_map>\n#include <map>\n#include <iomanip>\n#include <set>\n#include <functional>\n#include <fstream>\n#include <algorithm>\n#include <cassert>\n#include <cmath>\n#include <string>\n#include <sstream>\n#include <queue>\n#include <bitset>\nusing namespace std;\n\n#define x first\n#define y second\nconstexpr int MOD = 1000000007;\n\ntypedef std::pair<int,int> pii;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef unsigned int ui;\n\n\ntemplate<typename T, typename F> T foo(T t, T g, F f) {\n\treturn t;\n}\n\n\ntemplate <typename T, typename U> std::istream&operator>>(std::istream&i, pair<T,U>&p) {i >> p.x >> p.y; return i;}\ntemplate<typename T>std::istream&operator>>(std::istream&i,vector<T>&t) {for(auto&v:t){i>>v;}return i;}\ntemplate<typename T>std::ostream&operator<<(std::ostream&o,const vector<T>&t) {for(size_t i=0;i<t.size();++i){o<<t[i]<<\" \\n\"[i == t.size()-1];}return o;}\ntemplate<typename T> using minheap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<typename T> using maxheap = priority_queue<T, vector<T>, less<T>>;\nauto fraclt = [](const pii&a,const pii&b) { return (ll)a.x * b.y < (ll)b.x * a.y; };\nstruct cmpfrac { bool operator()(const pii&a,const pii&b)const { return (ll)a.x * b.y < (ll)b.x * a.y; }};\ntemplate <typename T> bool in(T a, T b, T c) { return a <= b && b < c; }\nint logceil(ll x) {int b=0;while(x){x>>=1;++b;}return b;}\n\nnamespace std {\n    template<typename T,typename U>struct hash<pair<T,U>>{hash<T>t;hash<U>u;size_t operator()(const pair<T,U>&p)const{return t(p.x)^(u(p.y)<<7);}};\n}\ntemplate<typename T,typename F>T bsh(T l,T h,const F&f){T r=-1,m;while(l<=h){m=(l+h)/2;if(f(m)){l=m+1;r=m;}else{h=m-1;}}return r;}\ntemplate<typename T,typename F>T bsl(T l,T h,const F&f){T r=-1,m;while(l<=h){m=(l+h)/2;if(f(m)){h=m-1;r=m;}else{l=m+1;}}return r;}\ntemplate<typename T> T gcd(T a,T b) { if (a<b) swap(a,b); return b?gcd(b,a%b):a; }\n\ntemplate<typename T>class vector2:public vector<vector<T>>{public:vector2(){} vector2(size_t a,size_t b,T t=T()):vector<vector<T>>(a,vector<T>(b,t)){}};\ntemplate<typename T>class vector3:public vector<vector<vector<T>>>{public:vector3(){} vector3(size_t a,size_t b,size_t c,T t=T()):vector<vector<vector<T>>>(a,vector<vector<T>>(b,vector<T>(c,t))){}};\ntemplate <typename T> struct bounded_priority_queue {\n\tinline bounded_priority_queue(ui X) : A(X), B(0) {}\n\tinline void push(ui L, T V) { B = max(B, L); A[L].push(V); }\n\tinline const T &top() const { return A[B].front(); }\n\tinline void pop() { A[B].pop(); while (B > 0 && A[B].empty()) --B; }\n\tinline bool empty() const { return A[B].empty(); }\n\tinline void clear() { B = 0; for (auto &a: A) a = queue<T>(); }\nprivate:\n\tvector<queue<T>> A; ui B;\n};\n\n\n#endif\n#ifndef PRIMES_H\n#define PRIMES_H\n\n\n\n\nstruct Sieve : public std::vector<bool> {\n\texplicit Sieve(int n) : vector<bool>(n+1, true), n(n) {\n\t\tat(0) = false;\n\t\tat(1) = false;\n\t\tfor (int i = 2; i*i <= n; ++i) {\n\t\t\tif (at(i)) for (int j = i*i; j <= n; j+=i) (*this)[j] = false;\n\t\t}\n\t}\n\n\tvector<int> primes() const {\n\t\tvector<int> ans;\n\t\tfor (int i=2; i<=n; ++i) if (at(i)) ans.push_back(i);\n\t\treturn ans;\n\t}\n\nprivate:\n\tint n;\n};\n\nstruct Moebius : public std::vector<std::pair<int, int>> {\n\texplicit Moebius(int n) : Moebius(n, Sieve{n}.primes()) {}\n\n\tMoebius(int n, const vector<int>& primes) {\n\t\tsearch(-1, 1, 1, n, primes);\n\t\tstd::sort(begin(), end());\n\t}\nprivate:\n\tvoid search(int i, int x, int y, int n, const vector<int>&primes) {\n\t\tpush_back({x,y});\n\t\twhile (++i < primes.size() && (ll)x * primes[i] <= n) search(i, x*primes[i], -y, n, primes);\n\t}\n};\n\n#endif //PRIMES_H\n\n\nclass F {\npublic:\n\tSieve S{10000000};\n\tvector<int> X;\n\n\tint cost(int x) {\n\t\tif (x == 0) return 0;\n\t\tif (x%2==0) return 2;\n\t\tif (S[x]) return 1;\n\t\treturn 3;\n\t}\n\n\tvoid solve(istream& cin, ostream& cout) {\n\t\tint N; cin >> N;\n\t\tX.resize(N);\n\t\tcin >> X;\n\n\t\tvector2<int> D(N, N, 10000);\n\t\tvector2<int> J(N, N, 10000);\n\t\tfor (int l = 0; l < N; ++l) {\n \t\t\tfor (int i = 0; i + l < N; ++i) {\n\t\t\t\tint j = i + l;\n\t\t\t\tif (l == 0) {\n\t\t\t\t\tD[i][j] = 3;\n\t\t\t\t\tJ[i][j] = 0;\n\t\t\t\t}\n\t\t\t\tfor (int k = i; k < j; ++k) {\n\t\t\t\t\tJ[i][j] = min(J[i][j], J[i][k] + J[k+1][j] + cost(X[k+1] - X[k] - 1));\n\t\t\t\t\tD[i][j] = min(D[i][j], D[i][k] + D[k+1][j]);\n\t\t\t\t}\n\n\t\t\t\tfor (int k = i; k < j-1; ++k) {\n\t\t\t\t\tfor (int m = k+1; m < j; ++m) {\n\t\t\t\t\t\tJ[i][j] = min(J[i][j], J[i][k] + J[m+1][j] + D[k+1][m] + cost(X[m+1] - X[k] - 1));\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tD[i][j] = min(D[i][j], J[i][j] + cost(X[j] - X[i] + 1));\n\t\t\t\tJ[i][j] = min(J[i][j], D[i][j] + cost(X[j] - X[i] + 1));\n\n\t\t\t}\n\t\t}\n\n\t\t//cerr << D;\n\t\t//cerr << J;\n\n\n\t\tcout << D[0][N-1] << endl;\n    }\n};\n\n\nint main() {\n\tios_base::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr);\n\tF solver;\n\tstd::istream& in(std::cin);\n\tstd::ostream& out(std::cout);\n\tsolver.solve(in, out);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <climits>\n#include <queue>\n#include <algorithm>\n\nusing std::queue;\nusing std::min;\n\nconst int MAXX=1e7+5,MAXN=205;\nint n,cnt_x,cnt_y;\nint x_id[MAXN],y_id[MAXN];\nbool up[MAXX];\n\nstruct node{int he,iter,dis;}d[MAXN];\nstruct line{int to,nex,cap;}ed[MAXN*MAXN<<1];\n\ninline bool is_odd_prm(int x){\n\tif(x==1) return false;\n\tfor(int i=2;i*i<=x;++i){\n\t\tif(x%i==0) return false;\n\t}\n\treturn true;\n}\n\ninline void addE(int u,int v,int cap){\n\tstatic int cnt=1;\n\ted[++cnt]=(line){v,d[u].he,cap};\n\td[u].he=cnt;\n}\n\ninline int revE(int i){return i^1;}\n\ninline bool BFS(int s,int t,int n){\n\tfor(int i=1;i<=n;++i)\n\t\td[i].dis=-1;\n\tstatic queue<int> q;\n\td[s].dis=0;\n\tq.push(s);\n\tint u;\n\twhile(q.size()){\n\t\tu=q.front();\n\t\tq.pop();\n\t\tfor(int i=d[u].he,v;i;i=ed[i].nex){\n\t\t\tif(ed[i].cap==0) continue;\n\t\t\tv=ed[i].to;\n\t\t\tif(d[v].dis==-1){\n\t\t\t\td[v].dis=d[u].dis+1;\n\t\t\t\tq.push(v);\n\t\t\t}\n\t\t}\n\t}\n\treturn d[t].dis!=-1;\n}\n\nint aug(int u,int rest,const int t){\n\tif(u==t) return rest;\n\tint ret=0;\n\tfor(int &i=d[u].iter,v,cap,flow;i;i=ed[i].nex){\n\t\tv=ed[i].to,cap=ed[i].cap;\n\t\tif(d[v].dis!=d[u].dis+1 || cap==0)\n\t\t\tcontinue;\n\t\tflow=aug(v,min(cap,rest),t);\n\t\ted[i].cap-=flow,ed[revE(i)].cap+=flow;\n\t\tret+=flow,rest-=flow;\n\t\tif(rest==0) return ret;\n\t}\n\tif(ret==0) d[u].dis=-1;\n\treturn ret;\n}\n\ninline int Dinic(int s,int t,int n){\n\tint ret=0;\n\twhile(BFS(s,t,n)){\n\t\tfor(int i=1;i<=n;++i)\n\t\t\td[i].iter=d[i].he;\n\t\tret+=aug(s,INT_MAX,t);\n\t}\n\treturn ret;\n}\n\ninline void build(){\n\tfor(int i=1;i<=cnt_x;++i){\n\t\tfor(int j=1,v;j<=cnt_y;++j){\n\t\t\tif(is_odd_prm(abs(x_id[i]-y_id[j]))){\n\t\t\t\tv=j+cnt_x;\n\t\t\t\taddE(i,v,INT_MAX),addE(v,i,0);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=1,s=cnt_x+cnt_y+1;i<=cnt_x;++i)\n\t\taddE(s,i,1),addE(i,s,0);\n\tfor(int i=1,u,t=cnt_x+cnt_y+2;i<=cnt_y;++i){\n\t\tu=cnt_x+i;\n\t\taddE(u,t,1),addE(t,u,0);\n\t}\n}\n\nint main(){\n\tscanf(\"%d\",&n);\n\tint x;\n\tfor(int i=1;i<=n;++i){\n\t\tscanf(\"%d\",&x);\n\t\tup[x]=true;\n\t}\n\tfor(int i=1;i<=x+1;++i){\n\t\tif(up[i]!=up[i-1])\n\t\t\ti&1 ? x_id[++cnt_x]=i:y_id[++cnt_y]=i;\n\t}\n\tbuild();\n\tint k=Dinic(cnt_x+cnt_y+1,cnt_x+cnt_y+2,cnt_x+cnt_y+2);\n\tprintf(\"%d\",k+((cnt_x-k)/2+(cnt_y-k)/2)*2+(cnt_x-k)%2*3);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \nconst int maxn = 1e7 + 700;\n \n \nint n,fre[maxn],p[220],ispr[maxn],even,odd,wrong;\nvector <int> edge[220],v2;\n \nbool fin(int u) {\n    if (fre[u]==wrong) return false;\n    fre[u]=wrong;\n    for (int j=0;j<edge[u].size();j++) {\n        int v=edge[u][j];\n       // cout<<u<<\" \"<<v<<endl;\n        if (p[v]==0 || fin(p[v])) {\n            p[v]=u;\n            p[u]=v;\n            return true;\n        }\n    }\n    return false;\n}\n \nint main() {\n  //  freopen(\"in.txt\",\"r\",stdin);\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    ispr[1]=1;\n    for (int i=2;i<maxn;i++)\n        if (ispr[i]==0) {\n            for (int j=i+i;j<maxn;j+=i) ispr[j]=1;\n        }\n    cin>>n;\n    for (int i=1;i<=n;i++) {\n        int x;\n        cin>>x;\n        fre[x]^=1;\n        fre[x+1]^=1;\n    }\n    even=0; odd=0; wrong=2;\n    for (int i=0;i<maxn;i++)\n        if (fre[i]==1) {\n            v2.push_back(i);\n            if (i%2==0) even++;\n            else odd++;\n        }\n    // for (int i=0;i<v2.size();i++) cout<<v2[i]<<\" \";\n   //  cout<<endl;\n   // cout<<\" \" <<even<<\" \"<<odd<<endl;\n    for (int i=0;i<v2.size();i++)\n        for (int j=0;j<v2.size();j++)\n            if (v2[i]%2==0 && v2[j]%2==1 && ispr[ abs(v2[j] - v2[i]) ]==0 && abs(v2[j] - v2[i])%2==1) {\n                edge[i].push_back(j);\n                edge[j].push_back(i);\n            }\n    int cnt=0;\n    for (int i=0;i<v2.size();i++)\n     if (p[i]==0) {\n        wrong++;\n        p[i]=i;\n        cnt+=(fin(i));\n    }\n    cout<< cnt + ((even-cnt)/2 + (odd-cnt)/2) * 2 + (even%2 && odd%2)*3;\n}"
  },
  {
    "language": "C++",
    "code": "#if 0\ndate +%Y.%m.%d\n\n题解先咕着。\n#endif\n#include <cstdio>\n#include <algorithm>\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n\ntypedef long long ll;\n\nstruct {\n\tinline operator int () { int x; return scanf(\"%d\", &x), x; }\n\t/* inline operator ll () { ll x; return scanf(\"%lld\", &x), x; } */\n\t/* template<class T> inline void operator () (T &x) { x = *this; } */\n\t/* template<class T, class ...A> inline void operator () (T &x, A &...a) */\n\t/* { x = *this; this -> operator () (a...); } */\n} read;\n\nconst int maxn = 205;\nint a[maxn], ap;\nint match[maxn];\nbool vis[maxn];\nbool nop[10000005];\n\nbool find (int p) {\n\tfor (int i = 1; i <= ap; i ++)\n\t\tif (!vis[i] and a[i] & 1 and !nop[std::abs(a[i] - a[p])]) {\n\t\t\tvis[i] = 1;\n\t\t\tif (!match[i] or find(match[i])) {\n\t\t\t\tmatch[i] = p;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\treturn 0;\n}\n\nint main () {\n\tint N = 10000000;\n\tnop[1] = 1;\n\tfor (int i = 2; i <= N; i ++)\n\t\tif (!nop[i]) {\n\t\t\tif (i <= N / i)\n\t\t\t\tfor (int j = i * i; j <= N; j += i)\n\t\t\t\t\tnop[j] = 1;\n\t\t}\n\n\tint n = read;\n\tfor (int i = 1, las = -1; i <= n; i ++) {\n\t\tint x = read;\n\t\tif (x - 1 == las)\n\t\t\ta[ap] = x;\n\t\telse {\n\t\t\ta[++ ap] = x - 1;\n\t\t\ta[++ ap] = x;\n\t\t}\n\t\tlas = x;\n\t}\n\n\tint tot = 0;\n\tfor (int i = 1; i <= ap; i ++)\n\t\tif (!(a[i] & 1)) {\n\t\t\tstd::fill(vis, vis + ap + 1, 0);\n\t\t\ttot += find(i);\n\t\t}\n\n\tint A = -tot, B = -tot;\n\tfor (int i = 1; i <= ap; i ++)\n\t\ta[i] & 1 ? ++ A : ++ B;\n\n\tprintf(\"%d\\n\", ap - tot + (A & 1));\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(2)\n#include<bits/stdc++.h>\n#define ll long long\n#define maxn 1000005\n#define N 10000005\n#define inf 1e9\n#define pb push_back\n#define rep(i,a,b) for(int i=a;i<=b;i++)\n#define per(i,a,b) for(int i=a;i>=b;i--)\nusing namespace std;\n\ninline int read()\n{\n\tint x=0,w=1; char c=getchar();\n\twhile(c<'0'||c>'9') {if(c=='-') w=-1; c=getchar();}\n\twhile(c<='9'&&c>='0') {x=(x<<1)+(x<<3)+c-'0'; c=getchar();}\n\treturn w==1?x:-x;\n}\n\nbool x[N],is[N];\nint c[maxn],cnt,pri[maxn],T[maxn],ct,t1,t2;\n\nstruct node{int from,to,cap,flow,cost;};\nvector <node> edges;\nvector <int> mp[maxn];\nint s,t,n,m,d[maxn],flow,cost,p[maxn],a[maxn];\nbool inq[maxn];\nqueue <int> que;\n\ninline void A(int u,int v,int w,int c)\n{\n\tedges.push_back((node){u,v,w,0,c});\n\tedges.push_back((node){v,u,0,0,-c});\n\tint pp=edges.size();\n\tmp[u].push_back(pp-2);\n\tmp[v].push_back(pp-1);\n}\n\ninline bool spfa()\n{\n\tfor(int i=0;i<=t;i++) d[i]=inf,inq[i]=0,a[i]=inf;\n\tque.push(s); d[s]=0;\n\twhile(!que.empty())\n\t{\n\t\tint u=que.front(); que.pop(); inq[u]=0;\n\t\tfor(int i=0;i<mp[u].size();i++)\n\t\t{\n\t\t\tnode &v=edges[mp[u][i]];\n\t\t\tif(v.cap-v.flow>0&&d[v.to]>d[u]+v.cost)\n\t\t\t{\n\t\t\t\td[v.to]=d[u]+v.cost;\n\t\t\t\ta[v.to]=min(a[u],v.cap-v.flow);\n\t\t\t\tp[v.to]=mp[u][i];\n\t\t\t\tif(inq[v.to]==0) que.push(v.to),inq[v.to]=1;\n\t\t\t}\n\t\t}\n\t}\n\tif(d[t]==inf) return false;\n\tflow+=a[t];\n\tcost+=a[t]*d[t];\n\tfor(int i=t;i!=s;i=edges[p[i]].from)\n\t{\n\t\tedges[p[i]].flow+=a[t];\n\t\tedges[p[i]^1].flow-=a[t];\n\t}\n\treturn true;\n}\n\ninline void pre()\n{\n\tfor(int i=2;i<=(N-4);i++)\n\t{\n\t\tif(!is[i]) pri[++cnt]=i;\n\t\tfor(int j=1;j<=cnt,pri[j]*i<=(N-5);j++)\n\t\t{\n\t\t\tis[pri[j]*i]=1;\n\t\t\tif(i%pri[j]==0) break;\n\t\t}\n\t}\n}\n\nint main()\n{\n\tn=read(); pre(); is[1]=1;\n\trep(i,1,n) c[i]=read(),x[c[i]]=1;\n\trep(i,1,(N-4)) if(x[i]!=x[i-1]) T[++ct]=i;\n\t//rep(i,1,ct) cout<<T[i]<<\" \"; cout<<endl;\n\ts=0,t=ct+1;\n\trep(i,1,ct)\n\t{\n\t\tif(T[i]%2==0)\n\t\t{\n\t\t\tt1++; A(s,i,1,0);\n\t\t\trep(j,1,ct) if(T[j]%2==1)\n\t\t\t{\n\t\t\t\tint tmp=abs(T[i]-T[j]);\n\t\t\t\tif(!is[tmp]) A(i,j,1,1);\n\t\t\t}\n\t\t}\n\t\telse t2++,A(i,t,1,0);\n\t}\n\twhile(spfa()); int ans=flow;\n\tint p1=(t1-ans)/2,p2=(t2-ans)/2,p3=(t1+t2-ans*2-p1*2-p2*2)/2;\n\tprintf(\"%d\\n\",ans+p1*2+p2*2+p3*3);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n\nconst int N=205;\nconst int inf=10000000;\n\nint n,prime[inf+5],match[N],a[N],b[N],a1,b1,tot;\nbool s[inf+5],not_prime[inf+5],vis[N],ma[N][N];\n\nvoid get_prime(int n)\n{\n\tfor (int i=2;i<=n;i++)\n\t{\n\t\tif (!not_prime[i]) prime[++tot]=i;\n\t\tfor (int j=1;j<=tot&&i*prime[j]<=n;j++)\n\t\t{\n\t\t\tnot_prime[i*prime[j]]=1;\n\t\t\tif (i%prime[j]==0) break;\n\t\t}\n\t}\n}\n\nbool find(int x)\n{\n\tfor (int i=1;i<=b1;i++)\n\t\tif (ma[x][i]&&!vis[i])\n\t\t{\n\t\t\tvis[i]=1;\n\t\t\tif (!match[i]||find(match[i]))\n\t\t\t{\n\t\t\t\tmatch[i]=x;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\treturn 0;\n}\n\nint main()\n{\n\tget_prime(inf);\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tint x;scanf(\"%d\",&x);\n\t\ts[x]=1;\n\t}\n\tfor (int i=1;i<=inf;i++)\n\t\tif (s[i]!=s[i-1])\n\t\t{\n\t\t\tif (i&1) a[++a1]=i;\n\t\t\telse b[++b1]=i;\n\t\t}\n\tfor (int i=1;i<=a1;i++)\n\t\tfor (int j=1;j<=b1;j++)\n\t\t\tif (!not_prime[abs(a[i]-b[j])]) ma[i][j]=1;\n\tint ans=0,tmp=0;\n\tfor (int i=1;i<=a1;i++)\n\t{\n\t\tmemset(vis,0,sizeof(vis));\n\t\tif (find(i)) tmp++,ans++;\n\t}\n\tans+=(a1-tmp)/2*2+(b1-tmp)/2*2;\n\tif (a1%2!=tmp%2) ans+=3;\n\tprintf(\"%d\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define C\ntypedef long long readtype;\n\n/* Header {{{ */\n#ifdef C\n#include <stdio.h>\n#include <math.h>\n#include <string.h>\n#define isdigit(a) ((a) >= '0' && (a) <= '9' ? true : false)\ntemplate<typename type> type abs(type a) { return a < 0 ? -a : a; }\ntemplate<typename type> type min(type a, type b) { return a < b ? a : b; }\ntemplate<typename type> type beMin(type &a, type b) { return a = (a < b ? a : b); }\ntemplate<typename type> type max(type a, type b) { return a > b ? a : b; }\ntemplate<typename type> type beMax(type &a, type b) { return a = (a > b ? a : b); }\ntemplate<typename type> void swap(type &a, type &b) { type c; c = a; a = b; b = c; }\n#endif\n\n#ifdef Cpp\n#include <bits/stdc++.h>\nusing namespace std;\n#endif\n\ntypedef long long var;\n\nreadtype read() {\n  readtype a = 0, c = getchar(), s = 0;\n  while (!isdigit(c)) s |= c == '-', c = getchar();\n  while (isdigit(c)) a = a * 10 + c - 48, c = getchar();\n  return s ? -a : a;\n}\n/* }}} */\n\nconst int N = 1103;\nconst int X = 1e7;\nconst int INF = 0x3f3f3f3f;\n\nint n, x[N];\nbool mark[X + 10];\nint cnt, prime[X];\nbool notprime[X + 10];\nint top, fi[N], ne[N * N], to[N * N], fl[N * N];\nint S, T;\nint head, tail, q[N], deep[N];\nint cur[N];\n\nvoid add(int u, int v, int w);\nint Dinic();\nbool BFS();\nint DFS(int t, int f);\n\nint main() {\n  /*\n#ifndef ONLINE_JUDGE\n  freopen(\"arc080d.in\", \"r\", stdin);\n  freopen(\"arc080d.out\", \"w\", stdout);\n#endif\n  */\n  notprime[1] = true;\n  for (int i = 2; i <= X; ++i) {\n    if (!notprime[i]) prime[++cnt] = i;\n    for (int j = 1; j <= cnt; ++j) {\n      if (prime[j] * i > X) break;\n      notprime[prime[j] * i] = true;\n      if (!(i % prime[j])) break;\n    }\n  }\n  for (int i = read(); i >= 1; --i) mark[read()] = true;\n  for (int i = 1; i <= X + 1; ++i) {\n    if (mark[i] ^ mark[i - 1]) x[++n] = i;\n  }\n  S = n + 1, T = n + 2;\n  int oddNum = 0, evenNum = 0;\n  for (int i = 1; i <= n; ++i) {\n    if (!(x[i] % 2)) add(i, T, 1), evenNum++;\n    else add(S, i, 1), oddNum++;\n  }\n  for (int i = 1; i <= n; ++i) {\n    if (!(x[i] % 2)) continue;\n    for (int j = 1; j <= n; ++j) {\n      if (x[j] % 2 || notprime[abs(x[i] - x[j])]) continue;\n      add(i, j, 1);\n      // printf(\"%d %d %d\\n\", x[i], x[j], x[i] - x[j]);\n    }\n  }\n\n  /*\n  for (int i = 1; i <= n; ++i) printf(\"%d \", x[i]);\n  puts(\"\");\n  */\n\n  int k = Dinic();\n  int res = k + ((evenNum - k) / 2 + (oddNum - k) / 2) * 2 + ((evenNum - k) % 2) * 3;\n  printf(\"%d\\n\", res);\n  return 0;\n}\n\nvoid add(int u, int v, int w) {\n  ne[++top] = fi[u], fi[u] = top, to[top] = v, fl[top] = w;\n  ne[++top] = fi[v], fi[v] = top, to[top] = u, fl[top] = 0;\n  // printf(\"%d %d %d\\n\", u, v, w);\n}\n\nint Dinic() {\n  int res = 0;\n  while (BFS()) {\n    for (int i = 1; i <= T; ++i) cur[i] = fi[i];\n    res += DFS(S, INF);\n  }\n  return res;\n}\n\nbool BFS() {\n  memset(deep, 0, sizeof(deep));\n  q[head = tail = 1] = S;\n  deep[S] = 1;\n  while (head <= tail) {\n    int f = q[head++];\n    for (int i = fi[f]; i; i = ne[i]) {\n      if (deep[to[i]] || !fl[i]) continue;\n      deep[to[i]] = deep[f] + 1;\n      q[++tail] = to[i];\n    }\n  }\n  return deep[T];\n}\n\nint DFS(int t, int f) {\n  if (t == T) return f;\n  int sumflow = 0;\n  for (int &i = cur[t]; i; i = ne[i]) {\n    if (deep[to[i]] != deep[t] + 1 || !fl[i]) continue;\n    int tflow = DFS(to[i], min(fl[i], f - sumflow));\n    sumflow += tflow;\n    fl[i] -= tflow, fl[i ^ 1] += tflow;\n  }\n  return sumflow;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int Nmax = 205, lim = 2e7 + 5;\n\nint n, a[Nmax];\nbitset<lim+3> prim;\n\n\nclass Graph\n{\n    vector<int> edge[Nmax];\n    bool marked[Nmax];\n    int L[Nmax], R[Nmax];\n\n    bool cupleaza(int node)\n    {\n        if(marked[node]) return 0;\n        marked[node] = 1;\n\n        for(auto it : edge[node])\n            if(R[it] == -1)\n            {\n                L[node] = it;\n                R[it] = node;\n                return 1;\n            }\n\n        for(auto it : edge[node])\n            if(cupleaza(R[it]))\n            {\n                L[node] = it;\n                R[it] = node;\n                return 1;\n            }\n        return 0;\n    }\n\npublic:\n    void add_edge(int x, int y)\n    {\n        edge[x].push_back(y);\n    }\n\n    int cuplaj(int n, int m)\n    {\n        int done = 1, i;\n        for(i=0; i<n; ++i) L[i] = -1;\n        for(i=0; i<m; ++i) R[i] = -1;\n\n        while(done)\n        {\n            done = 0;\n            memset(marked, 0, sizeof(marked));\n\n            for(i=0; i<n; ++i)\n                if(L[i] == -1) done |= cupleaza(i);\n        }\n\n        int cnt = 0;\n        for(i=0; i<n; ++i) cnt += (L[i] != -1);\n        return cnt;\n    }\n\n} graph;\n\nvoid prec()\n{\n    int i, j;\n\n    prim.set();\n    for(i=2; i*i <= lim; ++i)\n        if(prim[i])\n            for(j=i*i; j<=lim; j+=i)\n                prim[j] = 0;\n}\n\nint main()\n{\n   // freopen(\"input\", \"r\", stdin);\n    cin.sync_with_stdio(false);\n\n    prec();\n\n    int i, j;\n    vector<int> p, impar, par;\n\n    cin >> n;\n    for(i=1; i<=n; ++i) cin >> a[i];\n\n    for(i=1; i<=n; ++i)\n    {\n        j = i;\n        while(a[j] - a[i] == j - i) ++j;\n\n        p.push_back(a[i]);\n        p.push_back(a[j-1] + 1);\n\n        i = j - 1;\n    }\n\n    for(auto it : p)\n        if(it & 1) impar.push_back(it);\n            else par.push_back(it);\n\n    for(i=0; i<impar.size(); ++i)\n        for(j=0; j<par.size(); ++j)\n            if(prim[impar[i] + par[j]]) graph.add_edge(i, j);\n\n    int best = graph.cuplaj(impar.size(), par.size()), A, B;\n\n    A = impar.size() - best;\n    B = par.size() - best;\n\n    cout << best + 2 * (A/2 + B/2) + 3 * (A&1) << '\\n';\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 1000000007LL\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nstruct edge{\n\tint to,cap,rev;\n\tedge(){}\n\tedge(int tt,int cc,int rr){\n\t\tto=tt;\n\t\tcap=cc;\n\t\trev=rr;\n\t}\n};\n\nvector<edge> G[501];\nint level[501];\nint iter[501];\n\nvoid add_edge(int from,int to,int cap){\n\tG[from].push_back(edge(to,cap,G[to].size()-1));\n\tG[to].push_back(edge(from,0,G[from].size()));\n}\n\nvoid bfs(int s){\n\tmemset(level,-1,sizeof(level));\n\tqueue<int> que;\n\tlevel[s]=0;\n\tque.push(s);\n\twhile(que.size()){\n\t\tint v=que.front();\n\t\tque.pop();\n\t\tfor(int i=0;i<G[v].size();i++){\n\t\t\tedge &e=G[v][i];\n\t\t\tif(e.cap>0 && level[e.to]<0){\n\t\t\t\tlevel[e.to]=level[v]+1;\n\t\t\t\tque.push(e.to);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint dfs(int v,int t,int f){\n\tif(v==t)return f;\n\tfor(int &i=iter[v];i<G[v].size();i++){\n\t\tedge &e=G[v][i];\n\t\tif(e.cap>0 && level[v]<level[e.to]){\n\t\t\tint d=dfs(e.to,t,min(f,e.cap));\n\t\t\tif(d>0){\n\t\t\t\te.cap-=d;\t\t\t\n\t\t\t\tG[e.to][e.rev].cap+=d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint max_flow(int s,int t){\n\n}\n\nint n;\nint x[101];\nint a[10000001];\nint b[10000001];\n\nint prime(int x){\n\tif(x<=2)return 3;\n\tbool flag=true;\n\tfor(int i=2;i*i<=x;i++){\n\t\tif(x%i==0)return 3;\n\t}\n\treturn 1;\n}\n\nint main(void){\n\tscanf(\"%d\",&n);\n\tfor(int i=0;i<n;i++){\n\t\tscanf(\"%d\",&x[i]);\n\t\ta[x[i]]=1;\n\t}\n\tvector<int> colt[2];\n\tfor(int i=1;i<=x[n-1]+1;i++){\n\t\tb[i-1]=a[i-1]^a[i];\n\t\tif(b[i-1]==1){\n\t\t\tcolt[i%2].push_back(i);\n\t\t}\n\t}\n\tint s=colt[0].size()+colt[1].size();\n\tint t=s+1;\n\tfor(int i=0;i<colt[0].size();i++){\n\t\tfor(int j=0;j<colt[1].size();j++){\n\t\t\tint val=prime(abs(colt[0][i]-colt[1][j]));\n\t\t\tadd_edge(i,colt[0].size()+j,val);\n\t\t}\n\t}\n\tfor(int i=0;i<colt[0].size();i++){\n\t\tadd_edge(s,i,1);\n\t}\n\tfor(int i=0;i<colt[1].size();i++){\n\t\tadd_edge(colt[0].size()+i,t,1);\n\t}\n\tint cnt=max_flow(s,t);\n\tint res=0;\n\tres+=((int)colt[0].size()-cnt)/2*2;\n\tres+=((int)colt[1].size()-cnt)/2*2;\n\tres+=(((int)colt[0].size()-cnt)%2)*3;\n\tres+=cnt;\n\tprintf(\"%d\\n\",res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define forn(i, n) for (llong i = 0ll; i < (llong) n; ++i)\n#define fornn(i, l, r) for (llong i = (llong) l; i < (llong) r; ++i)\n#define size(x) ((int) (x.size()))\n \nusing namespace std;\n \ntypedef long long llong;\nconst llong inf = (llong) 1e+9 + 7ll;\nconst llong linf = (llong) 1e+18 + 7ll;\nconst long double eps = (long double) 1e-9;\nconst long double pi = acosl((long double) -1.0);\nconst int alph = 26;\n\nmt19937 mrand(random_device{} ()); \n\ntemplate<typename T, typename U> inline llong umin(const T& a, const U& b) { return a < b ? a : b; }\ntemplate<typename T, typename U> inline llong umax(const T& a, const U& b) { return a > b ? a : b; }\n \nstatic char buff[(int) 2e6 + 17]; // reads std::string\nconst int maxn = (int) 1e7 + 17;\n\nint n;\nint a[100], mt[100];\nvector<int> g[100];\nbool pr[maxn], used[100];\n\nbool read()\n{\n\tif (scanf(\"%d\", &n) != 1)\n\t\treturn false;\n\n\tforn (i, n)\n\t\tscanf(\"%d\", a + i);\n\n\treturn true;\n}\n\nbool dfs(int v)\n{\n\tif (used[v])\n\t\treturn false;\n\n\tused[v] = true;\n\n\tfor (auto to : g[v])\n\t\tif (mt[to] == -1 || dfs(to))\n\t\t\treturn true;\n\n\treturn false;\n}\n\nvoid solve()\n{\n\tfor (int i = 2; i < maxn; ++i)\n\t\tpr[i] = true;\n\n\tfor (int i = 2; i < maxn; ++i)\n\t\tif (pr[i] && 1ll * i * i < maxn)\n\t\t\tfor (int j = i * i; j < maxn; j += maxn)\n\t\t\t\tpr[j] = false;\n\n\tpr[2] = false;\n\tset<int> s;\n\n\tfor (int i = 0; i < n; ++i)\n\t{\n\t\ts.insert(a[i] + 1);\n\n\t\tif (s.count(a[i]))\n\t\t\ts.erase(a[i]);\n\t\telse\n\t\t\ts.insert(a[i]);\n\t}\n\n\tvector<int> v0, v1;\n\n\tfor (auto i : s)\n\t\ti % 2 == 0 ? v0.push_back(i) : v1.push_back(i);\n\n\tfor (int i = 0; i < size(v0); ++i)\n\t\tfor (int j = 0; j < size(v1); ++j)\n\t\t\tif (pr[abs(v0[i] - v1[j])])\n\t\t\t\tg[i].push_back(j);\n\n\tfor (int i = 0; i < size(v0); ++i)\n\t\tmt[i] = -1;\n\n\tfor (int i = 0; i < size(v0); ++i)\n\t{\n\t\tfill(used, used + size(v0), false);\n\t\tdfs(i);\n\t}\n\n\tint matching = 0;\n\n\tfor (int i = 0; i < size(v0); ++i)\n\t\tmatching += mt[i] != -1;\n\n\tint ans = matching;\n\tans += 2 * ((size(v0) - matching) / 2);\n\tans += 2 * ((size(v1) - matching) / 2);\n\tans += 3 * ((size(v0) - matching) % 2);\n\tprintf(\"%d\\n\", ans);\n}\n\nint main()\n{\n#if SEREZHKA\n\tfreopen(\"file.in\", \"r\", stdin);\n#endif\n\n\twhile (read())\n\t\tsolve();\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <cmath>\n\nusing namespace std;\n\nconst int N=105,M=1e7+5;\n\ntypedef long long LL;\n\nint n,tot,p[M],f[N],vis[N],now,ans,s1,a[N],s2,b[N];\n\nbool bz[M],Bit[M],g[N][N],u1[N],u2[N];\n\nbool Check(int x)\n{\n\tif (vis[x]==now) return 0;\n\tvis[x]=now;\n\tfor (int i=1;i<=s2;i++) if (g[x][i])\n\t{\n\t\tif (!f[i] || Check(f[i]))\n\t\t{\n\t\t\tf[i]=x; return 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nint main()\n{\n\tbz[1]=1;\n\tfor (int i=2;i<M;i++)\n\t{\n\t\tif (!bz[i]) p[tot++]=i;\n\t\tfor (int j=0;j<tot && i*p[j]<M;j++)\n\t\t{\n\t\t\tbz[i*p[j]]=1;\n\t\t\tif (i%p[j]==0) break;\n\t\t}\n\t}\n\tscanf(\"%d\",&n);\n\tfor (int x,i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%d\",&x);\n\t\tBit[x]^=1;\n\t}\n\tfor (int i=1,j=0;i<M;i++) if (Bit[i]^Bit[i-1])\n\t{\n\t\tif (!j) a[++s1]=i;else b[++s2]=i;\n\t\tj^=1;\n\t}\n\tfor (int i=1;i<=s1;i++) for (int j=1;j<=s2;j++)\n\t{\n\t\tint tmp=abs(a[i]-b[j]);\n\t\tif ((tmp&1) && !bz[tmp]) g[i][j]=1;\n\t}\n\tfor (now=1;now<=s1;now++) ans+=Check(now);\n\tfor (int i=1;i<=s2;i++) if (f[i]) u1[f[i]]=u2[i]=1;\n\tmemset(g,0,sizeof(g));\n\tfor (int i=1;i<=s1;i++) if (!u1[i]) for (int j=1;j<=s2;j++) if (!u2[i])\n\t{\n\t\tint tmp=abs(a[i]-b[j]);\n\t\tif (!(tmp&1)) g[i][j]=1;\n\t}\n\tnow=0;\n\tmemset(vis,0,sizeof(vis));\n\tfor (now=1;now<=s1;now++) if (!u1[now]) ans+=Check(now)*2;\n\tfor (int i=1;i<=s2;i++) if (f[i]) u1[f[i]]=u2[i]=1;\n\tmemset(g,0,sizeof(g));\n\tfor (int i=1;i<=s1;i++) if (!u1[i]) for (int j=1;j<=s2;j++) if (!u2[i]) g[i][j]=1;\n\tnow=0;\n\tmemset(vis,0,sizeof(vis));\n\tfor (now=1;now<=s1;now++) if (!u1[now]) ans+=Check(now)*3;\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n#include<cstring>\n\nusing namespace std;\n\nusing vi = vector<int>;\nvi X;\nint n;\nvector<vi> C;\nint used[207];\nbool isprime(int n) {\n\tif (n <= 2)return false;\n\tfor (int i = 2; i*i <= n; i++) {\n\t\tif (n%i == 0)return false;\n\t}\n\treturn true;\n}\nbool dfs(int v) {\n\tused[v] = true;\n\tif (v == X.size() + 1) return true;\n\tfor (int i = 0; i < X.size() + 2; i++) {\n\t\tif (!used[i] && C[v][i] > 0) {\n\t\t\tif (dfs(i)) {\n\t\t\t\tC[v][i]--;\n\t\t\t\tC[i][v]++;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\nint main() {\n\tcin >> n;\n\tvi evens;\n\tvi odds;\n\tfor (int i = 0; i < n; i++) {\n\t\tint x;\n\t\tcin >> x;\n\t\tif (!X.empty() && X.back() == x) {\n\t\t\tX.pop_back();\n\t\t\tX.push_back(x + 1);\n\t\t}\n\t\telse {\n\t\t\tX.push_back(x);\n\t\t\tX.push_back(x + 1);\n\t\t}\n\t}\n\tint E = 0;\n\tint O = 0;\n\tfor (int x : X) {\n\t\tif (x % 2 == 0) {\n\t\t\tE++;\n\t\t}\n\t\telse {\n\t\t\tO++;\n\t\t}\n\t}\n\t\t\n\tC.resize(X.size()+2, vi(X.size()+2, 0));\n\tfor (int i = 0; i < X.size(); i++) {\n\t\tif (X[i] % 2 == 0) {\n\t\t\tC[X.size()][i] = 1;\n\t\t}\n\t\telse {\n\t\t\tC[i][X.size() + 1] = 1;\n\t\t}\n\t}\n\tfor (int i = 0; i < X.size(); i++) {\n\t\tfor (int j = i; j < X.size(); j++) {\n\t\t\tif (isprime(abs(X[i] - X[j]))) {\n\t\t\t\tint a = i;\n\t\t\t\tint b = j;\n\t\t\t\tif (b % 2 == 0)swap(a, b);\n\t\t\t\tC[a][b] = 1;\n\t\t\t}\n\t\t}\n\t}\n\tint ans = 0;\n\twhile (dfs(X.size())) {\n\t\tfor (int i = 0; i < 207; i++)used[i] = false;\n\t\tans++;\n\t}\n\tif ((E - ans) % 2 == 0) {\n\t\tcout << ans + (E - ans + O - ans) << endl;\n\t}\n\telse {\n\t\tcout << ans + (E - ans - 1 + O - ans - 1) + 3 << endl;\n\t}\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 205\n\nusing namespace std;\n\nint n;\nint a[N];\nint b[N], tot;\n\ninline int read() {\n\tint x = 0; char ch = getchar();\n\twhile(!isdigit(ch)) ch = getchar();\n\twhile(isdigit(ch)) x = x * 10 + ch - '0', ch = getchar();\n\treturn x;\n}\n\nbool vis[N];\nint match[N];\n\nbool isPrime(int x) { // except 2\n\tif(x == 1 || (~x & 1)) return false;\n\tfor(int i = 3; i * i <= x; ++i)\n\t\tif(x % i == 0)\n\t\t\treturn false;\n\treturn true;\n}\n\nbool dfs(int u) {\n\tfor(int i = 1; i <= tot; ++i) {\n\t\tif(u == i || vis[i] || !isPrime(abs(b[i] - b[u])))\n\t\t\tcontinue;\n\t\tvis[i] = true;\n\t\tif(!match[i] || dfs(match[i])) {\n\t\t\tmatch[i] = u;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint main() {\n\tn = read();\n\tfor(int i = 1; i <= n; ++i) a[i] = read();\n\tsort(a + 1, a + n + 1);\n\ta[0] = a[1] - N, a[n + 1] = a[n] + N;\n\tfor(int i = 1; i <= n; ++i) {\n\t\tif(a[i - 1] + 1 != a[i])\n\t\t\tb[++tot] = a[i];\n\t\tif(a[i] + 1 != a[i + 1])\n\t\t\tb[++tot] = a[i] + 1;\n\t}\n\t\n\tint ans(0);\n\tint even = 0, odd = 0;\n\tfor(int i = 1; i <= tot; ++i) {\n\t\tif(~b[i] & 1) {\n\t\t\t++even;\n\t\t\tcontinue;\n\t\t}\n\t\t++odd;\n\t\tmemset(vis, 0, sizeof vis);\n\t\tif(dfs(i)) {\n\t\t\tcerr << \"ERR\" << endl;\n\t\t\t++ans;\n\t\t\t--even;\n\t\t\t--odd;\n\t\t}\n\t}\n\n\tans += (even) / 2 * 2;\n\tans += (odd) / 2 * 2;\n\tans += (even & 1) * 3;\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define pb push_back\n#define x first\n#define y second\nusing namespace std;\ntypedef long long LL;\ntypedef vector<int> VI;\nusing namespace std;\nconst int NMAX=406;\nconst int INF=1000000666;\nconst LL INFLL=1000000000000666;\nconst LL maxv=100000;\nconst long double PI = acos(-1.0);\nconst int MAXT = 200000;\n\nint A[105];\nint dp[105];\nint n;\n\nmap<int, bool> M;\n\nint l[NMAX], r[NMAX];\nvector<int> G[NMAX];\nbool viz[NMAX];\nint lf,m,e,x,y,rs;\n \nbool dfs(int v)\n{\n    if(viz[v])\n        return 0;\n    viz[v]=1;\n    for(auto w:G[v])\n        if(l[w] == 0 || dfs(l[w]))\n        {\n            l[w]=v;\n            r[v]=w;\n            return 1;\n        }\n    return 0;\n}\n\n\nbool isprime(int x){\n  int i = 2;\n  int q = 1;\n  if(x == 1){\n    q = 0;\n  }\n  while(i*i <= x){\n    if((x%i) == 0){\n      q=0; \n    }\n    i++;\n  }\n  return q;\n}\n\nint cost(int x){\n  if(x < 0){\n    exit(0);\n  }\n  if(x == 0){\n    return 0;\n  }\n  if((x%2) == 0){\n    return 2;\n  }\n  else{\n    if(!M[x]){\n      if(isprime(x)){\n        return 1;\n        M[x] = 2;\n      }\n      else{\n        return 3;\n        M[x] = 1;\n      }\n    }\n    if(M[x] == 2){\n      return 1;\n    }\n    else\n    {\n      return 3;\n    }\n  }\n}\n\nvoid solve(){\n  cin>>n;\n  for(int i=1; i<=n; ++i){\n    cin>>A[i];\n  }\n  vector<int> df;\n  for(int i=1; i<=n; ++i){\n    if(A[i] - A[i-1] > 1 || i==1){\n      df.push_back(A[i]);\n    }\n    if(A[i+1] - A[i]>1 || i==n){\n      df.push_back(A[i] + 1);\n    }\n  }\n  //sort(df.begin(), df.end());\n  vector<int> lft, rht;\n\n  for(auto el: df){\n    //cout<<el<<\" \";\n    if(el % 2){\n      rht.push_back(el);\n    }\n    else{\n      lft.push_back(el);\n    }\n  }\n  lf = lft.size();\n  for(int i=0; i<lft.size(); ++i){\n    for(int j=0; j<rht.size(); ++j){\n      if(cost(abs(lft[i] - rht[j])) == 1)\n      {\n        G[i].push_back(j+lf);\n\n      }\n    }\n  }\n  bool q=1;\n  while(q)\n  {\n      q=0;\n      memset(viz, 0, sizeof(viz));\n      for(int i=1; i<=lf; ++i)\n      {\n          if(r[i]==0 && dfs(i))\n          {\n              q=1;\n              rs++;\n          }\n      }\n  }\n  int a = lf - rs, b = rht.size() - rs;\n  cout<<2*(a/2) + 2*(b/2) + 3*(a%2)<<\"\\n\";\n  \n\n}\n\n\nint main()\n{\n    // Tic\n    //clock_t t=clock();\n    cout<<setprecision(10)<<fixed;\n    ios_base::sync_with_stdio(0);\n\n    //freopen(\"simetrii.in\", \"rt\", stdin);\n    //freopen(\"simetrii.out\", \"wt\", stdout);\n\n    solve();\n\n    //Toc\n    //t=clock()-t;\n    //printf (\"It took me %d clicks (%f seconds).\\n\",t,((float)t)/CLOCKS_PER_SEC);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n\n#define Int register int\n#define int long long\n#define MAXN 10000005\n\nint Abs (int x){return x > 0 ? x : -x;}\n\nint tot;\nint prime[MAXN];\n\nbool vis[MAXN];\n\nvoid Prime (int n)\n{\n\tvis[1] = 1;\n\tfor (Int i = 2;i <= n;++ i)\n\t{\n\t\tif (!vis[i]) prime[++ tot] = i;\n\t\tfor (Int j = 1;j <= tot && i * prime[j] <= n;++ j)\n\t\t{\n\t\t\tvis[i * prime[j]] = 1;\n\t\t\tif (i % prime[j] == 0) break;\n\t\t}\n\t}\n}\n\nbool check (int x){return !vis[x];}\n\nbool rev[MAXN];\n\nint read ()\n{\n\tint x = 0;char c = getchar();int f = 1;\n\twhile (c < '0' || c > '9'){if (c == '-') f = -f;c = getchar();}\n\twhile (c >= '0' && c <= '9'){x = (x << 3) + (x << 1) + c - '0';c = getchar();}\n\treturn x * f;\n}\n\nvoid write (int x)\n{\n\tif (x < 0){x = -x;putchar ('-');}\n\tif (x > 9) write (x / 10);\n\tputchar (x % 10 + '0');\n}\n\nvector <int> s1,s2;\n\nstruct edge\n{\n\tint v,nxt;\n}e[MAXN << 1];\n\nint top = 1;\nint head[MAXN];\n\nvoid Add_Edge (int u,int v)\n{\n\te[++ top] = edge {v,head[u]};\n\thead[u] = top;\n}\n\nint my[MAXN];\nbool visit[MAXN];\n\nint dfs (int u)\n{\n\tfor (Int i = head[u];i;i = e[i].nxt)\n\t{\n\t\tint v = e[i].v;\n\t\tif (visit[v]) continue;\n\t\tvisit[v] = 1;\n\t\tif (my[v] == -1 || dfs (my[v]))\n\t\t{\n\t\t\tmy[v] = u;\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nint Hungry ()\n{\n\tint cnt = 0;\n\tmemset (my,-1,sizeof (my));\n\tfor (Int i = 0;i < s1.size();++ i)\n\t{\n\t\tmemset (visit,0,sizeof (visit));\n\t\tcnt += dfs (i);\n\t}\n\treturn cnt;\n}\n\nsigned main()\n{\n\tint n = read ();\n\tint Maxn = 0;\n\tfor (Int i = 1;i <= n;++ i)\n\t{\n\t\tint x = read ();\n\t\trev[x] ^= 1;\n\t\tMaxn = max (Maxn,x + 1);\n\t}\n\tPrime (Maxn);\n\tfor (Int i = 1;i <= Maxn;++ i)\n\t\tif (rev[i] != rev[i - 1])\n\t\t\tif (i & 1)\n\t\t\t\ts1.push_back(i);\n\t\t\telse \n\t\t\t\ts2.push_back(i);\n\tfor (Int i = 0;i < s1.size();++ i)\n\t\tfor (Int j = 0;j < s2.size();++ j)\n\t\t\tif (check (Abs (s1[i] - s2[j])))\n\t\t\t\tAdd_Edge (i,j);\n\tint Ans = Hungry ();\n\twrite (Ans + (s1.size() - Ans) / 2 * 2 + (s2.size() - Ans) / 2 * 2 + (s1.size() - Ans) % 2 * 3),putchar ('\\n'); \n\treturn 0; \n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cassert>\n#include <cctype>\n#include <algorithm>\nusing namespace std;\ntypedef long long lint;\n#define cout cerr\n#define ni (next_num<int>())\ntemplate<class T>inline T next_num(){\n\tT i=0;char c;\n\twhile(!isdigit(c=getchar())&&c!='-');\n\tbool flag=c=='-';\n\tflag?c=getchar():0;\n\twhile(i=i*10-'0'+c,isdigit(c=getchar()));\n\treturn flag?-i:i;\n}\ntemplate<class T1,class T2>inline void apmax(T1 &a,const T2 &b){if(a<b)a=b;}\ntemplate<class T1,class T2>inline void apmin(T1 &a,const T2 &b){if(b<a)a=b;}\nconst int N=110,M=10000010;\nint prime[M],ps=0;\nbool isp[M];\ninline void gmath(int n){\n\tmemset(isp,true,sizeof(isp));\n\tisp[1]=false;\n\tfor(int i=2;i<=n;i++){\n\t\tif(isp[i]){\n\t\t\tprime[ps++]=i;\n\t\t}\n\t\tfor(int j=0,cur=2;j<ps&&i*cur<=n;cur=prime[++j]){\n\t\t\tisp[i*cur]=false;\n\t\t\tif(i%cur==0)break;\n\t\t}\n\t}\n}\nint x[N];\nbool vis[N];\nint main(){\n\tint n=ni,xs=0,cnt=0;\n\tfor(int i=1;i<=n;i++){\n\t\tint cur=ni;\n\t\tif(cur==x[xs]){\n\t\t\tx[xs]++;\n\t\t}else{\n\t\t\tx[++xs]=cur,x[++xs]=cur+1;\n\t\t}\n\t}\n\tgmath(x[xs]);\n\tmemset(vis,0,sizeof(vis));\n\tfor(int i=1,j;i<=xs;i++){\n\t\tif(!vis[i]){\n\t\t\tfor(j=i+1;j<=xs;j++){\n\t\t\t\tif(!vis[j]&&isp[x[j]-x[i]])break;\n\t\t\t}\n\t\t\tif(j<=xs){\n\t\t\t\tvis[i]=vis[j]=true;\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\",xs+(cnt&1)-cnt);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cassert>\n#include <cctype>\n#include <algorithm>\nusing namespace std;\ntypedef long long lint;\n#define cout cerr\n#define ni (next_num<int>())\ntemplate<class T>inline T next_num(){\n\tT i=0;char c;\n\twhile(!isdigit(c=getchar())&&c!='-');\n\tbool flag=c=='-';\n\tflag?c=getchar():0;\n\twhile(i=i*10-'0'+c,isdigit(c=getchar()));\n\treturn flag?-i:i;\n}\ntemplate<class T1,class T2>inline void apmax(T1 &a,const T2 &b){if(a<b)a=b;}\ntemplate<class T1,class T2>inline void apmin(T1 &a,const T2 &b){if(b<a)a=b;}\ntemplate<class T>inline T cabs(const T &x){return x>=0?x:-x;}\nconst int N=210,M=10000010;\nint prime[M],ps=0;\nbool isp[M];\ninline void gmath(int n){\n\tmemset(isp,true,sizeof(isp));\n\tisp[1]=false;\n\tfor(int i=2;i<=n;i++){\n\t\tif(isp[i]){\n\t\t\tprime[ps++]=i;\n\t\t}\n\t\tfor(int j=0,cur=2;j<ps&&i*cur<=n;cur=prime[++j]){\n\t\t\tisp[i*cur]=false;\n\t\t\tif(i%cur==0)break;\n\t\t}\n\t}\n}\nint pos[N];\nint x[N],y[N];\nint lcnt=0,rcnt=0;\nbool vis[N];\nint lnk[N];\nbool dfs(int x){\n\tfor(int v=1;v<=rcnt;v++){\n\t\tif(!vis[v]&&isp[cabs(::x[x]-y[v])]){\n\t\t\tvis[v]=true;\n\t\t\tif(lnk[v]==-1||dfs(lnk[v])){\n\t\t\t\tlnk[v]=x;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\nint main(){\n\tint n=ni,xs=0,cnt=0;\n\tfor(int i=1;i<=n;i++){\n\t\tint cur=ni;\n\t\tif(cur==pos[xs]){\n\t\t\tpos[xs]++;\n\t\t}else{\n\t\t\tpos[++xs]=cur,pos[++xs]=cur+1;\n\t\t}\n\t}\n\tgmath(pos[xs]);\n\tfor(int i=1;i<=xs;i++){\n\t\tif(pos[i]&1){\n\t\t\tx[++lcnt]=pos[i];\n\t\t}else{\n\t\t\ty[++rcnt]=pos[i];\n\t\t}\n\t}\n\tmemset(lnk,-1,sizeof(lnk));\n\tfor(int i=1;i<=lcnt;i++){\n\t\tmemset(vis+1,0,rcnt<<2);\n\t\tcnt+=dfs(i);\n\t}\n\tprintf(\"%d\\n\",xs+((lcnt^cnt)&1)-cnt);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<string>\n#include<cmath>\nusing namespace std;\n#define clr(a) memset(a,0,sizeof(a))\n//--Container\n#include<set>\n//\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pi;\n \nstruct eg{int u,v,nx;}gp[50010];int cnt,hd[210],mth[210];bool bd[210];\nvoid psh(int u,int v){++cnt;gp[cnt].u=u,gp[cnt].v=v,gp[cnt].nx=hd[u],hd[u]=cnt;};\n \nbool fdp(int v){\n    int i;for(i=hd[v];i;i=gp[i].nx)if(!bd[gp[i].v]){\n        bd[gp[i].v]=1;\n        if(!mth[gp[i].v]||fdp(mth[gp[i].v])){\n            mth[gp[i].v]=v;\n            return 1;\n        }\n    }\n    return 0;\n};\nint hgy(int n){\n    int rs=0,i;for(clr(bd),i=1;i<=n;++i){\n        clr(mth);if(fdp(i))++rs;\n    }\n    return rs;\n};\n \nint ar[110],dr[210],cr[2][210],dn,n;\n \nbool _ck(int n){\n    if(n==1)return 0;int d=sqrt(n),i=2;for(;i<=d;++i)if(!(n%i))return 0;\n    return 1;\n};\n \nbool cl(){\n\tif(scanf(\"%d\",&n)==-1)return 0;\n    int i,j,t,a,b,k;for(i=1;i<=n;scanf(\"%d\",&ar[i++]));sort(ar+1,ar+n+1);n=unique(ar+1,ar+n+1)-ar-1;\n    for(dn=1,dr[1]=ar[1],i=2;i<=n;++i){\n        if(ar[i]==ar[i-1]+1)continue;\n        dr[++dn]=ar[i-1]+1,dr[++dn]=ar[i];\n    }\n    dr[++dn]=ar[n]+1;\n    for(a=b=0,i=1;i<=dn;++i){\n        if(dr[i]&1)cr[1][++a]=dr[i];\n        else\n            cr[0][++b]=dr[i];\n    }\n    for(cnt=0,clr(hd),i=1;i<=a;++i)for(j=1;j<=b;++j)if(_ck(abs(cr[1][i]-cr[0][j])))\n        psh(i,j);\n    t=hgy(a);\n    printf(\"%d\\n\",t+(a-t)/2*2+(b-t)/2*2+(a-t)%2*3);\n\treturn 1;\n};\n \nint main() {\n    while(cl());\n    return 0;\n};"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#ifdef _DEBUG\n#include \"dump.hpp\"\n#else\n#define dump(...)\n#endif\n\n//#define int long long\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define all(c) begin(c),end(c)\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9) + 7;\ntemplate<class T> bool chmax(T &a, const T &b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (b < a) { a = b; return true; } return false; }\n\n//エラトステネスの篩\nvector<char> eratos(int n) {\n\tvector<char> is_prime(n + 1, true);\n\tis_prime[0] = is_prime[1] = false;\n\tfor (int i = 2; i*i <= n; i++)\n\t\tif (is_prime[i]) {\n\t\t\tint j = i + i;\n\t\t\twhile (j <= n) {\n\t\t\t\tis_prime[j] = false;\n\t\t\t\tj += i;\n\t\t\t}\n\t\t}\n\treturn is_prime;\n}\n//戻り値: n以下の素数\nvector<int> get_primes(int n) {\n\tvector<char> is_prime = eratos(n);\n\tvector<int> primes;\n\tfor (int i = 0; i < n + 1; i++)\n\t\tif (is_prime[i])\n\t\t\tprimes.emplace_back(i);\n\treturn primes;\n}\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tvector<int> primes = get_primes(200);\n\tprimes.erase(primes.begin());\n\tdump(primes);\n\n\tconst int MAX = 200;\n\tvector<int> cnt(MAX, INF);\n\n\tfor (auto p : primes)cnt[p] = 1;\n\n\tvector<int> s = primes;\n\tbool update = true;\n\twhile (update) {\n\t\tupdate = false;\n\t\tvector<int> tmp = s;\n\t\trep(i, 0, s.size())rep(j, i + 1, s.size()) {\n\t\t\tif (s[j] + s[i] < MAX) {\n\t\t\t\tif (chmin(cnt[s[j] + s[i]], cnt[s[j]] + cnt[s[i]]))\n\t\t\t\t\tupdate = true;\n\t\t\t\ttmp.emplace_back(s[j] + s[i]);\n\t\t\t}\n\t\t\tif (chmin(cnt[s[j] - s[i]], cnt[s[j]] + cnt[s[i]]))\n\t\t\t\tupdate = true;\n\t\t\ttmp.emplace_back(s[j] - s[i]);\n\t\t}\n\t\tsort(all(tmp));\n\t\ttmp.erase(unique(tmp.begin(), tmp.end()), tmp.end());\n\t\ts = tmp;\n\n\t\tdump(cnt);\n\t}\n\n\tint N; cin >> N;\n\tvector<int> x(N); rep(i, 0, N) {\n\t\tcin >> x[i];\n\t}\n\tvector<int> v;\n\tint c = 1;\n\trep(i, 1, N) {\n\t\tif (x[i - 1] + 1 == x[i]) {\n\t\t\tc++;\n\t\t}\n\t\telse {\n\t\t\tv.emplace_back(c);\n\t\t\tc = 1;\n\t\t}\n\t}\n\tif (c)v.emplace_back(c);\n\tdump(v);\n\tint ans = 0;\n\trep(i, 0, v.size()) {\n\t\tans += cnt[v[i]];\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstring>\n#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<queue>\n#include<stack>\n#include<cmath>\n#include<map>\n#include<complex>\n#define rep(i,l,r) for (int i=l;i<=r;i++)\n#define down(i,l,r) for (int i=l;i>=r;i--)\n#define clr(x,y) memset(x,y,sizeof(x))\n#define maxn 320500\n#define inf (int)1e9\n#define ll long long\n#define mm 1000000007\n#define eps 1e-13\n#define pb push_back\n#define low(x) x&(-x)\nusing namespace std;\n\nll read(){\n    ll x=0,f=1; char ch=getchar();\n    while (!isdigit(ch)) {if (ch=='-') f=-1; ch=getchar();}\n    while (isdigit(ch)){x=x*10+ch-'0'; ch=getchar();}\n    return x*f;\n}\nstruct data{int obj,pre,c,w;\n}e[1200500];\nint head[805],dis[805],uu[805],cur[805],a[805],b[805];\nint mp[10000005],pmp[10000005],vis[10000005],pri[1000500];\nint ans,t,tot=1,ptot,n,m;\nvoid insert(int x,int y,int c,int w){\n    e[++tot].obj=y; e[tot].pre=head[x]; e[tot].c=c; e[tot].w=w; head[x]=tot;\n    e[++tot].obj=x; e[tot].pre=head[y]; e[tot].c=0; e[tot].w=-w; head[y]=tot;\n}\n\nbool spfa(){\n    clr(uu,0);\n    rep(i,0,t) dis[i]=inf; dis[0]=0;\n   \tqueue<int> q; q.push(0);\n    while (!q.empty()){\n        int u=q.front(); q.pop(); uu[u]=1;\n        for (int j=head[u];j;j=e[j].pre){\n            int v=e[j].obj;\n            if (e[j].c>0&&dis[v]>dis[u]+e[j].w){\n                dis[v]=dis[u]+e[j].w;\n                if (uu[v]==0) uu[v]=1,q.push(v);\n            }\n        }\n        uu[u]=0;\n    }\n    if (dis[t]>=inf) return 0;\n    return 1;\n}\nint dfs(int x,int mx){\n    //if (uu[x]==1) return 0;\n    if (x==t||mx==0) return mx;\n    uu[x]=1;\n    int used=0;\n    for (int j=cur[x];j;j=e[j].pre){\n        int v=e[j].obj;\n        if (dis[v]==dis[x]+e[j].w&&e[j].c>0&&uu[v]==0){\n            int w=dfs(v,min(e[j].c,mx-used));\n            ans+=w*e[j].w; \n            e[j].c-=w; e[j^1].c+=w; used+=w;\n            cur[x]=j;\n            if (used==mx) return used;\n        }\n    }\n    return used;\n}\nint main(){\n//\tfreopen(\"input.txt\",\"r\",stdin);\n//\tfreopen(\"output.txt\",\"w\",stdout);\n\tn=read();\n\tint mxn=10000001;\n\trep(i,1,n) a[i]=read(),mp[a[i]]=1;\n\t//rep(i,1,n) if (mp[a[i]-1]==mp[a[i]]) b[i]=0; else b[i]=1;\n\trep(i,1,mxn) if (mp[i]!=mp[i-1]) b[++m]=i; \n\trep(i,2,mxn) {\n\t\tif (!vis[i]) pri[++ptot]=i,vis[i]=1,pmp[i]=1;\n\t\trep(j,1,ptot) {\n\t\t\tif (i*pri[j]>mxn) break;\n\t\t\tvis[i*pri[j]]=1;\n\t\t}\n\t}\n//\trep(i,1,m) printf(\"%d \",b[i]);\n\tt=2*m+1;\n\trep(i,1,m) insert(0,i,1,0),insert(i+m,t,1,0);\n\trep(i,1,m) rep(j,1,m) {\n\t\tif (i==j) continue;\n\t\tif ((abs(b[i]-b[j])&1)==0) insert(i,j+m,1,2);\n\t\tif (abs(b[i]-b[j])&1){\n\t\t\tif (pmp[abs(b[i]-b[j])]) insert(i,j+m,1,1);\n\t\t\telse insert(i,j+m,1,3);\n\t\t}\n\t}\n\twhile (spfa()){\n        clr(uu,0); rep(i,0,t) cur[i]=head[i];\n        dfs(0,inf);\n    }\n    printf(\"%d\\n\",ans/2);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,l,r) for(register int i = l ; i <= r ; i++)\n#define repd(i,r,l) for(register int i = r ; i >= l ; i--)\n#define rvc(i,S) for(register int i = 0 ; i < (int)S.size() ; i++)\n#define rvcd(i,S) for(register int i = ((int)S.size()) - 1 ; i >= 0 ; i--)\n#define fore(i,x)for (register int i = head[x] ; i ; i = e[i].next)\n#define forup(i,l,r) for (register int i = l ; i <= r ; i += lowbit(i))\n#define fordown(i,id) for (register int i = id ; i ; i -= lowbit(i))\n#define pb push_back\n#define prev prev_\n#define stack stack_\n#define mp make_pair\n#define fi first\n#define se second\n#define lowbit(x) (x&(-x))\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pr;\n\nconst ll MAX = 2e18;\nconst ld inf = 2e18;\nconst int maxn = 220;\nconst ll mod = 1e9 + 7;\n\ninline ll power(ll x,ll y){\n\ty = ((y % (mod - 1)) + (mod - 1)) % (mod - 1);\n//\tif ( y < 0 ) return power(power(x,-y),mod - 2);\n\tll res = 1;\n\twhile ( y ){\n\t\tif ( y & 1 ) res = res * x % mod;\n\t\tx = x * x % mod;\n\t\ty >>= 1;\n\t}\n\treturn res;\n}\nint a[maxn],n,odd[maxn],even[maxn],cnt1,cnt2;\nset <int> s;\nnamespace Prime{\n\tconst int N = 1e7;\n\tint prime[N + 20],tag[N + 20],mn[N + 20],Cnt;\t\n\tvoid init (){\n\t\ttag[1] = 1;\n\t\trep(i,2,N){\n\t\t\tif ( !tag[i] ) prime[++Cnt] = i;\n\t\t\trep(j,1,Cnt){\n\t\t\t\tif ( prime[j] * i > N ) break;\n\t\t\t\ttag[i * prime[j]] = 1;\n\t\t\t\tmn[i * prime[j]] = prime[j];\n\t\t\t\tif ( i % prime[j] == 0 ) break;\n\t\t\t}\n\t\t}\n\t}\n}\nusing namespace Prime;\n\nstruct node{\n\tint next,to;\n}e[maxn * maxn];\nint head[maxn],cnt;\nint mx[maxn],my[maxn],dx[maxn],dy[maxn],q[maxn],hh,tt,tot,vis[maxn];\n\ninline void adde(int x,int y){\n\te[++cnt].to = y;\n\te[cnt].next = head[x];\n\thead[x] = cnt;\n}\n\nbool find(int x){\n\tfore(i,x){\n\t\tint to = e[i].to;\n\t\tif ( !vis[to] && dy[to] == dx[x] + 1 ){\n\t\t\tvis[to] = 1;\n\t\t\tif ( !my[to] || find(my[to]) ){\n\t\t\t\tmx[x] = to;\n\t\t\t\tmy[to] = x;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nvoid match(){\n\tmemset(mx,0,sizeof(mx));\n\tmemset(my,0,sizeof(my));\n\ttot = 0;\n\twhile ( 1 ){\n\t\tbool flag = 0;\n\t\ttt = hh = 0;\n\t\trep(i,1,cnt1) dx[i] = 0;\n\t\trep(i,1,cnt2) dy[i] = 0;\n\t\trep(i,1,cnt1) if ( !mx[i] ) q[tt++] = i;\n\t\twhile ( hh < tt ){\n\t\t\tint x = q[hh++];\n\t\t\n\t\t\tfore(i,x){\n\t\t\t\tint to = e[i].to;\n\t\t\t\tif ( !dy[to] ){\n\t\t\t\t\tdy[to] = dx[x] + 1;\n\t\t\t\t\tif ( my[to] ){\n\t\t\t\t\t\tdx[my[to]] = dy[to] + 1;\n\t\t\t\t\t\tq[tt++] = my[to]; //入队的点只有左边的点\n\t\t\t\t\t}\n\t\t\t\t\telse flag = 1;//找到增广路\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif ( !flag ) break;\n\t\tmemset(vis,0,sizeof(vis));\n\t\trep(i,1,cnt1) if ( !mx[i] && find(i) ) tot++;\n\t}\n}\n\n\nint main(){\n\tinit();\n\tscanf(\"%d\",&n);\n\trep(i,1,n){\n\t   \tscanf(\"%d\",&a[i]);\n\t\tif ( s.find(a[i]) == s.end() ) s.insert(a[i]);\n\t\telse s.erase(a[i]);\n\n\t\tif ( s.find(a[i] + 1) == s.end() ) s.insert(a[i] + 1);\n\t\telse s.erase(a[i] + 1);\n\t}\n\tfor (auto it = s.begin() ; it != s.end() ; ++it){\n\t\tint x = *it;\n\t\tif ( x & 1 ) odd[++cnt1] = x;\n\t\telse even[++cnt2] = x;\n\t}\n\trep(i,1,cnt1){\n\t\trep(j,1,cnt2){\n\t\t\tint c = abs(odd[i] - even[j]);\n\t\t\tif ( !tag[c] ) adde(i,j);\n\t\t}\n\t}\n\tmatch();\n\tcout<<cnt1 + cnt2 - tot + ((cnt1 - tot) & 1)<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define maxn 205\nusing namespace std;\nint n,m,a[maxn],lk[maxn];\nvector<int>G[maxn];\nbool vis[maxn];\nbool dfs(int u){\n\tfor(int v:G[u]) if(!vis[v]){\n\t\tvis[v]=1;\n\t\tif(!lk[v]||dfs(lk[v])) return lk[v]=u,1;\n\t}\n\treturn 0;\n}\ninline bool check(int x){\n\tif(x<=2) return 0;\n\tfor(int i=2;i*i<=x;i++) if(x%i==0) return 0;\n\treturn 1;\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1,pre=-1,now;i<=n;i++,pre=now){\n\t\tscanf(\"%d\",&now);\n\t\tif(pre<now-1) a[++m]=now,a[++m]=now+1;\n\t\telse a[m]=now+1;\n\t}\n\tint cnt[2]={0},ans=0;\n\tfor(int i=1;i<=m;i++) cnt[a[i]&1]++; \n\tfor(int i=1;i<=m;i++) if(!(a[i]&1))\n\t\tfor(int j=1;j<=m;j++) if((a[j]&1)&&check(abs(a[j]-a[i])))\n\t\t\tG[i].push_back(j);\n\tfor(int i=1;i<=m;i++) if(!(a[i]&1)) memset(vis,0,sizeof vis),ans+=dfs(i);\n\tprintf(\"%d\\n\",ans+(m-2*ans)+(cnt[0]-ans)%2);\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<queue>\n#include<cmath>\n#include<vector>\n#define neko 1010\n#define chkmin(a,b) ((a)<(b)?(a):(b))\n#define f(i,a,b) for(register int i=(a);i<=(b);i=-(~(i)))\nint P[neko],n,ans,cnt,cntp,t=1,head[neko],cur[neko],dis[neko],inf=0x3f3f3f3f,S,T;\nint prime[10000010],isnprime[10000010];\nstruct node\n{\n\tint v,cap,nex;\n}e[neko*neko*2];\nvoid add(int x,int y,int z)\n{\n\te[++t].v=y;\n\te[t].cap=z;\n\te[t].nex=head[x];\n\thead[x]=t;\n\te[++t].v=x;\n\te[t].cap=0;\n\te[t].nex=head[y];\n\thead[y]=t;\n}\nnamespace NT\n{\n\tvoid sieve(int num)\n\t{\n\t\tisnprime[1]=1;\n\t\tf(i,2,num)\n\t\t{\n\t\t\tif(!isnprime[i])prime[++cntp]=i;\n\t\t\tfor(register int j=1;j<=cntp&&i*prime[j]<=num;++j)\n\t\t\t{\n\t\t\t\tisnprime[i*prime[j]]=1;\n\t\t\t\tif(i%prime[j]==0)break;\n\t\t\t}\n\t\t}\n\t}\n}\nnamespace Netflow\n{\n\tusing namespace std;\n\tbool bfs()\n\t{\n\t\tqueue<int>q;memset(dis,0,sizeof(dis));\n\t\tdis[S]=1,q.push(S);\n\t\tint u;\n\t\twhile(!q.empty())\n\t\t{\n\t\t\tu=q.front(),q.pop();\n\t\t\tfor(register int i=head[u],v=e[i].v;i;i=e[i].nex,v=e[i].v)\n\t\t\t{\n\t\t\t\tif(!dis[v]&&e[i].cap)\n\t\t\t\t{\n\t\t\t\t\tdis[v]=dis[u]+1;\n\t\t\t\t\tif(v==T)return 1;\n\t\t\t\t\tq.push(v);\n\t\t\t\t}\n\t\t\t}\n\t\t}return 0;\n\t}\n\tint dfs(int u,int flow)\n\t{\n\t\tif(u==T||(!flow))return flow;\n\t\tint rescap=0,up;\n\t\tfor(register int &i=cur[u],v=e[i].v;i;i=e[i].nex,v=e[i].v)\n\t\t{\n\t\t\tif(dis[v]==dis[u]+1&&(up=dfs(v,chkmin(e[i].cap,flow))))\n\t\t\t{\n\t\t\t\te[i].cap-=up,e[i^1].cap+=up;\n\t\t\t\trescap+=up;\n\t\t\t\tif(!(flow-=up))break;\n\t\t\t}\n\t\t}return rescap;\n\t}\n\tvoid dinic()\n\t{while(bfs())memcpy(cur,head,sizeof(head)),ans+=dfs(S,inf);}\n}\n#define pb push_back\nstruct tag\n{int a,b;};\nstd::vector<tag>C;\nint abs(int x){return x<0?-x:x;}\nint main()\n{\n\tint now=0;\n\tNT::sieve(10000010);\n\tscanf(\"%d\",&n);\n\tf(i,1,n)\n\t{\n\t\tscanf(\"%d\",&P[i]);\n\t\tif(P[i-1]^(P[i]-1)||i==1){C.pb(tag{P[i],++cnt});if(i>1)C.pb(tag{P[i-1]+1,++cnt});}\n\t}C.pb(tag{P[n]+1,++cnt});\n\tS=cnt+1,T=cnt+2;\n\tfor(tag x:C)\n\t{\n\t\tif(x.a&1)\n\t\t{\n\t\t\tadd(S,x.b,1),++now;\n\t\t\tfor(tag y:C)if((!(y.a&1))&&(!isnprime[abs(y.a-x.a)]))add(x.b,y.b,1);\n\t\t}\n\t\telse add(x.b,T,1);\n\t}Netflow::dinic();\n\t//printf(\"%d\\n\",ans);\n\tint A=now-ans,B=(cnt-now)-ans;\n\tans=ans+A/2*2+B/2*2,A=A-A/2*2,B=B-B/2*2;\n\tif(A&&B)ans+=3;\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nint n,x[210];\nstruct edge{int to,cap;edge*rev,*next;}E[40010],*ne=E,*fir[210],*cur[210];\nvoid link(int a,int b,int c){\n\t*ne=(edge){b,c,ne+1,fir[a]};fir[a]=ne++;\n\t*ne=(edge){a,0,ne-1,fir[b]};fir[b]=ne++;\n}\nint Q[210],D[210];\nint dfs(int i,int c){\n\tif(i==1||!c)return c;\n\tint fl=0,f;\n\tfor(edge*&e=cur[i];e&&c;e=e->next)\n\t\tif(e->cap&&D[e->to]==D[i]-1&&(f=dfs(e->to,c<e->cap?c:e->cap)))\n\t\t\tfl+=f,e->cap-=f,e->rev->cap+=f,c-=f;\n\treturn fl;\n}\nint mf(){\n\tfor(int f=0;;f+=dfs(0,1<<30)){\n\t\tfor(int i=0;i<=n+1;i++)D[i]=0,cur[i]=fir[i];\n\t\tfor(int*h=Q,*t=Q+(D[*Q=1]=1);h<t;h++)\n\t\t\tfor(edge*e=fir[*h];e;e=e->next)\n\t\t\t\tif(e->rev->cap&&!D[e->to])D[*t++=e->to]=D[*h]+1;\n\t\tif(!*D)return f;\n\t}\n}\nint pr[10000010],pc;\nbool com[10000010];\nint dif(int x,int y){return x>y?x-y:y-x;}\nint main(){\n\tint N;scanf(\"%d\",&N);\n\twhile(N--){\n\t\tint v;scanf(\"%d\",&v);\n\t\tif(n&&x[n-1]+1==v)++x[n-1];\n\t\telse x[n++]=v-1,x[n++]=v;\n\t}\n\tcom[1]=1;\n\tfor(int i=2;i<=x[n-1];i++){\n\t\tif(!com[i])pr[pc++]=i;\n\t\tfor(int j=0;j<pc&&i*pr[j]<=x[n-1];j++){\n\t\t\tcom[i*pr[j]]=1;\n\t\t\tif(i%pr[j]==0)break;\n\t\t}\n\t}\n\tint lc=0,rc=0;\n\tfor(int i=0;i<n;i++){\n\t\tif(x[i]&1)link(i+2,1,1),rc++;\n\t\telse{\n\t\t\tlink(0,i+2,1),lc++;\n\t\t\tfor(int j=0;j<n;j++)if((x[j]&1)&&!com[dif(x[i],x[j])])link(i+2,j+2,1);\n\t\t}\n\t}\n\tint s=mf();\n\tlc-=s;rc-=s;\n\tprintf(\"%d\\n\",s+lc/2*2+rc/2*2+lc%2*3);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <cmath>\n\nusing namespace std;\n\nconst int N=105,M=1e7+5;\n\ntypedef long long LL;\n\nint n,tot,p[M],f[N],vis[N],now,ans,s1,a[N],s2,b[N],ans1,ans2;\n\nbool bz[M],Bit[M],g[N][N],u1[N],u2[N];\n\nbool Check(int x)\n{\n\tif (vis[x]==now) return 0;\n\tvis[x]=now;\n\tfor (int i=1;i<=s2;i++) if (g[x][i])\n\t{\n\t\tif (!f[i] || Check(f[i]))\n\t\t{\n\t\t\tf[i]=x; return 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nint main()\n{\n\tbz[1]=1;\n\tfor (int i=2;i<M;i++)\n\t{\n\t\tif (!bz[i]) p[tot++]=i;\n\t\tfor (int j=0;j<tot && i*p[j]<M;j++)\n\t\t{\n\t\t\tbz[i*p[j]]=1;\n\t\t\tif (i%p[j]==0) break;\n\t\t}\n\t}\n\tscanf(\"%d\",&n);\n\tfor (int x,i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%d\",&x);\n\t\tBit[x]^=1;\n\t}\n\tfor (int i=1,j=0;i<M;i++) if (Bit[i]^Bit[i-1])\n\t{\n\t\tif (!j) a[++s1]=i;else b[++s2]=i;\n\t\tj^=1;\n\t}\n\tfor (int i=1;i<=s1;i++) for (int j=1;j<=s2;j++)\n\t{\n\t\tint tmp=abs(a[i]-b[j]);\n\t\tif ((tmp&1) && !bz[tmp]) g[i][j]=1;\n\t}\n\tfor (now=1;now<=s1;now++) ans+=Check(now);\n\tfor (int i=1;i<=s2;i++) if (f[i]) u1[f[i]]=u2[i]=1;\n\tfor (int i=1;i<=s1;i++) if (!u1[i])\n\t{\n\t\tif (a[i]&1) ans1++;else ans2++;\n\t}\n\tfor (int i=1;i<=s2;i++) if (!u2[i])\n\t{\n\t\tif (b[i]&1)\n\t\t{\n\t\t\tif (ans1>0) ans+=2; ans1--;\n\t\t}else\n\t\t{\n\t\t\tif (ans2>0) ans+=2; ans2--;\n\t\t}\n\t}\n\tans+=max(ans1,ans2)*3;\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define fi first\n#define se second\n#define mp make_pair\n#define gc getchar\n#define pb push_back\n#define eb emplace_back\n#define all(x) (x).begin(),(x).end()\n#define x1 uvuvwevwevwe\n#define y1 onyetenyevwe\n#define x2 ugwemubwem\n#define y2 ossas\ntypedef long long LL;\ntypedef long double LD;\ntypedef pair<int,int> pii;\nconst int batasprima=10000;\ntemplate <typename T> void scan(T &angka){\n\tangka=0;char input=gc();T kali=1;\n\twhile(!(48<=input&&input<=57)){\tif(input=='-')\tkali=-1;input=gc();}\n\twhile(48<=input&&input<=57)\tangka=(angka<<3)+(angka<<1)+input-48,input=gc();angka*=kali;\n}\ntemplate <typename T1,typename T2> void scan(T1 &angka1,T2 &angka2){\n\tscan(angka1);scan(angka2);\n}\nint match[205],k=0,ans;\nvector <int> daftar,adj[205],prime;\nbitset<205> visited;\nvoid sieve(){\n\tbool isprime[batasprima+5];\n\tmemset(isprime,true,sizeof(isprime));\n\tfor(int i=2;i<=batasprima;i++)\n\t{\n\t\tif(!isprime[i])\n\t\t\tcontinue;\n\t\tprime.pb(i);\n\t\tfor(int j=i+i;j<=batasprima;j+=i)\n\t\t\tisprime[j]=false;\n\t}\n}\nbool isprime(int angka){\n\tif(angka<2)\n\t\treturn false;\n\tfor(auto isi:prime)\n\t{\n\t\tif(angka%isi==0)\n\t\t\treturn false;\n\t}\n\treturn true;\n}\nbool matching(int pos){\n\tif(visited[pos])\n\t\treturn false;\n\tvisited[pos]=true;\n\tfor(auto isi:adj[pos])\n\t{\n\t\tif(match[isi]==-1||matching(match[isi]))\n\t\t{\n\t\t\tmatch[isi]=pos;\n\t\t\tmatch[pos]=isi;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\nvoid buatgraph(){\t\n\tfor(int i=0;i<daftar.size();i++)\n\t{\n\t\tfor(int j=0;j<daftar.size();j++)\n\t\t{\n\t\t\tif(isprime(abs(daftar[i]-daftar[j])))\n\t\t\t\tadj[i].pb(j);\n\t\t}\n\t}\n}\nvoid hitungk(){\n\tmemset(match,-1,sizeof(match));\n\tfor(int i=0;i<daftar.size();i++)\n\t{\n\t\tif(match[i]!=-1)\n\t\t\tcontinue;\n\t\tvisited.reset();\n\t\tif(matching(i))\n\t\t\tk++;\n\t}\n}\nvoid hitungans(){\n\tint genap=0,ganjil=0;\n\tfor(auto isi:daftar)\n\t{\n\t\tif(isi&1)\n\t\t\tganjil++;\n\t\telse\n\t\t\tgenap++;\n\t}\n\tassert(ganjil>=k&&genap>=k);\n\tassert(ganjil%2==genap%2);\n\tans=k+(ganjil/2+genap/2)*2+(ganjil%2)*3;\n}\nvoid isidaftar(){\n\tint n,tadi=-1;\n\tscan(n);\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tint input;\n\t\tscan(input);\n\t\tassert(tadi<input);\n\t\ttadi=input;\n\t\tif(daftar.size()&&daftar.back()==input)\n\t\t\tdaftar[daftar.size()-1]=input+1;\t\t\t//nanti mau sa coba\n\t\telse\n\t\t\tdaftar.pb(input),daftar.pb(input+1);\n\t}\n}\nint main()\n{\n\tsieve();\n\tisidaftar();\n\tbuatgraph();\n\thitungk();\n\thitungans();\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define REP(i, a, b) for(int i = (a), i##end = (b); i <= i##end; ++ i)\n#define CLR(i, a) memset(i, a, sizeof(i))\n#define REPD(i, a, b) for(int i = (a), i##end = (b); i >= i##end; -- i)\n#define REPG(i, x) for(int i = head[x], v; i; i = edge[i].next)\n\ntypedef long long LL;\ntypedef double DB;\n \n#define pc putchar\n#define gc getchar\n#define endl '\\n'\ninline LL rd() {\t\n\tchar ch = gc(); LL ret = 0, sgn = 1;\n\twhile(ch < '0' || ch >'9') {\n\t\tif(ch == '-') sgn = -1;\n\t\tch = gc();\n\t}\n\twhile(ch >= '0' && ch <= '9')\n\t\tret = ret * 10 + ch - '0', ch = gc();\n\treturn ret * sgn;\n}\n \ninline void out(LL x) {\n\tstatic int buf[50], btp;\n\tif(x < 0) x = -x, pc('-');\n\tif(!x) pc('0');\n\telse {\n\t\tbtp = 0;\n\t\tfor(; x; x /= 10) buf[++ btp] = x % 10;\n\t\twhile(btp) pc('0' + buf[btp --]);\n\t}\n}\n \nDB _BEGIN;\n#define LOG(x) cerr << #x << \":\" << x << endl\n#define DBG(...) fprintf(stderr, __VA_ARGS__)\n#define OK DBG(\"Passing [%s] in LINE %d...\\n\", __FUNCTION__, __LINE__)\n#define _TIME (int((clock() - _BEGIN) / (DB)CLOCKS_PER_SEC * 1000))\n\n/**************************************/\n\nconst int N = 100 + 3;\n\nint head[N], cnt;\nstruct qwq { int v, next; } edge[(N * N) << 1];\ninline void add(int x, int y) {\n\tedge[++ cnt] = (qwq) { y, head[x] }, head[x] = cnt;\n}\nint lft[N], rt[N], lsz, rsz;\nconst int M = 1e7 + 2;\nbool isnotp[M + 1];\nint tot, p[700000], vis[N], tim, opn[N], n, a[N];\ninline void Sieve() {\n\tisnotp[1] = 1;\n\tREP(i, 2, M) {\n\t\tif(!isnotp[i]) p[++ tot] = i;\n\t\tREP(j, 1, tot) {\n\t\t\tif((LL)i * p[j] > M) break;\n\t\t\tisnotp[i * p[j]] = 1;\n\t\t\tif(i % p[j] == 0) break;\n\t\t}\n\t}\n}\n\nint Aug(int x) {\n\t// LOG(x);\n\tREPG(i, x) if(vis[(v = edge[i].v)] != tim) { \n\t\tvis[v] = tim;\n\t\tif(!opn[v] || Aug(opn[v])) {\n\t\t\topn[x] = v, opn[v] = x;\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nint main() {\n#ifdef LOCAL\n\tfreopen(\"light_example_2.in\", \"r\", stdin);\n#endif\n\tSieve();\n\t// for(int T = rd(); T; -- T) {\n\t\t// cout<<T<<endl;\n\t\tn = rd();\n\t\tcnt = 0;\n\t\t\n\t\tlsz = rsz = 0;\n\t\tREP(i, 1, n) a[i] = rd();\n\t\t\n\t\tif(a[1] & 1) rt[++ rsz] = a[1];\n\t\telse lft[++ lsz] = a[1];\n\t\tREP(i, 2, n) {\n\t\t\tif(a[i - 1] != a[i] - 1) {\n\t\t\t\tif(a[i] & 1) rt[++ rsz] = a[i];\n\t\t\t\telse lft[++ lsz] = a[i];\n\t\t\t} \n\t\t\tif(a[i - 1] + 1 != a[i]) {\n\t\t\t\tif((a[i - 1] + 1) & 1) rt[++ rsz] = a[i - 1] + 1;\n\t\t\t\telse lft[++ lsz] = a[i - 1] + 1;\n\t\t\t}\n\t\t}\n\t\tif((a[n] + 1) & 1) rt[++ rsz] = a[n] + 1;\n\t\telse lft[++ lsz] = a[n] + 1;\n\n\t\tREP(i, 1, lsz) {\n\t\t\tREP(j, 1, rsz) {\n\t\t\t\tint x = lft[i], y = rt[j];\n\t\t\t\tif(isnotp[abs(x - y)]) continue;\n\t\t\t\tif(abs(x - y) & 1) add(i, lsz + j), add(lsz + j, i);\n\t\t\t}\n\t\t}\n\n\t\tfill(vis + 1, vis + lsz + rsz + 1, 0);\n\t\tfill(opn + 1, opn + lsz + rsz + 1, 0);\n\t\ttim = 0;\n\t\tint ret = 0;\n\t\tREP(i, 1, lsz) if(!opn[i]) {\n\t\t\t++ tim;\n\t\t\tret += Aug(i);\n\t\t}\n\n\t\tint ans = ret;\n\t\tans += ((lsz - ret) / 2 + (rsz - ret) / 2) * 2;\n\t\tans += ((rsz - ret) % 2) * 3;\n\t\tout(ans), pc(endl);\n\t\tfflush(stdout);\n\n\t\tfill(head + 1, head + lsz + rsz + 1, 0);\n\t// }\n\n#ifdef LOCAL\n\tLOG(_TIME);\n#endif\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define pb push_back\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\n\nstruct hopcroft_karp {\n\tint N,M;\n\tvector<vector<int>> E;\n\tvector<int> dist,match,Q;\n\thopcroft_karp(int n, int m):N(n),M(m),E(N),dist(N+M),match(N+M,-1),Q(N+M){}\n\n\tinline void add_edge(int i, int j) {E[i].push_back(j);}\n\n\tbool bfs() {\n\t\tfill(&dist[0],&dist[0]+N+M,-1);\n\t\tint qf = 0, qb = 0, u;\n\t\tbool ok = false;\n\t\tfor(int i = 0; i < N; ++i)\n\t\t\tif(match[i] == -1)\n\t\t\t\tQ[qb++] = i, dist[i] = 0;\n\t\twhile(qf != qb) {\n\t\t\tif((u = Q[qf++]) < N) {\n\t\t\t\tfor(int v : E[u])\n\t\t\t\t\tif(dist[N+v] == -1)\n\t\t\t\t\t\tdist[Q[qb++] = N+v] = dist[u] + 1;\n\t\t\t} else {\n\t\t\t\tif(match[u] == -1) ok = true;\n\t\t\t\telse if(dist[match[u]] == -1)\n\t\t\t\t\tdist[Q[qb++] = match[u]] = dist[u] + 1;\n\t\t\t}\n\t\t}\n\t\treturn ok;\n\t}\n\n\tbool dfs(int u) {\n\t\tfor(int &i = Q[u]; i < E[u].size(); ++i) {\n\t\t\tint v = N+E[u][i];\n\t\t\tif(dist[v] == dist[u]+1 && (match[v] == -1 || (dist[match[v]] == dist[v]+1 && dfs(match[v])))) {\n\t\t\t\tmatch[v] = u, match[u] = v-N;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tint solve() {\n\t\tint ans = 0;\n\t\twhile(bfs()) {\n\t\t\tfill(&Q[0],&Q[0]+N,0);\n\t\t\tfor(int i = 0; i < N; ++i)\n\t\t\t\tif(match[i] == -1 && dfs(i))\n\t\t\t\t\t++ans;\n\t\t}\n\t\treturn ans;\n\t}\n};\n\nconst int N = 105, P = 1e6+5;\nint a[N]={-1};\nbool p[P];\nvi odd,evn;\n\ninline void add(int i) {\n\t((i&1)?odd:evn).pb(i);\n}\n\nint main() {\n\tfill(p,p+P,1);\n\tfor(int i = 2; i < P; ++i)\n\t\tif(p[i])\n\t\t\tfor(ll j = 1LL * i * i; j < P; j += i)\n\t\t\t\tp[j] = false;\n\tp[2] = false;\n\tint n;\n\tscanf(\"%d\",&n);\n\tfor(int i = 1; i <= n; ++i)\n\t\tscanf(\"%d\",a+i);\n\tsort(a,a+n); //maybe\n\tfor(int i = 1; i <= n; ++i) {\n\t\tif(a[i-1] != a[i]-1) add(a[i]-1);\n\t\tif(a[i+1] != a[i]+1) add(a[i]);\n\t}\n\thopcroft_karp HK(evn.size(), odd.size());\n\tfor(int i = 0; i < evn.size(); ++i)\n\t\tfor(int j = 0; j < odd.size(); ++j)\n\t\t\tif(p[abs(i-j)])\n\t\t\t\tHK.add_edge(i,j);\n\tint k = HK.solve();\n\tprintf(\"%d\\n\",k + int((odd.size()-k)/2*2 + (evn.size()-k)/2*2 + ((odd.size()-k)&1)*3));\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<iostream>\n#include<queue>\n#include<cmath>\nusing namespace std;\nvoid read(int &x){\n\tchar ch;bool ok;\n\tfor(ok=0,ch=getchar();!isdigit(ch);ch=getchar())if(ch=='-')ok=1;\n\tfor(x=0;isdigit(ch);x=x*10+ch-'0',ch=getchar());if(ok)x=-x;\n}\n#define rg register\nconst int maxn=210;bool vis[maxn];\nint f[maxn],n,ans,a[maxn],mp[maxn][maxn],b[maxn],tot1,tot2,x[maxn];\nbool check(int x){\n\tif((!(x&1))||x==1)return 0;\n\tint n=sqrt(x);\n\tfor(rg int i=2;i<=n;i++)\n\t\tif(!(x%i))return 0;\n\treturn 1;\n}\nbool dfs(int x){\n\tfor(rg int i=1;i<=tot2;i++)\n\t\tif(!vis[i]&&mp[x][i]){\n\t\t\tvis[i]=1;\n\t\t\tif(!f[i]||dfs(f[i]))return f[i]=x,1;\n\t\t}\n\treturn 0;\n}\nint main(){\n\tread(n);\n\tfor(rg int i=1;i<=n;i++)read(x[i]);\n\tif(n==1){printf(\"3\\n\");return 0;}\n\tfor(rg int i=1;i<=n;i++){\n\t\tif(x[i+1]-x[i]!=1||i==n){\n\t\t\tif((x[i]+1)%2==0)a[++tot1]=x[i]+1;\n\t\t\telse b[++tot2]=x[i]+1;\n\t\t}\n\t\tif(x[i]-x[i-1]!=1||i==1){\n\t\t\tif(x[i]&1)b[++tot2]=x[i];\n\t\t\telse a[++tot1]=x[i];\n\t\t}\n\t}\n\tfor(rg int i=1;i<=tot1;i++)\n\t\tfor(rg int j=1;j<=tot2;j++)\n\t\t\tif(check(abs(a[i]-b[j])))mp[i][j]=1;\n\tfor(rg int i=1;i<=tot1;i++){\n\t\tmemset(vis,0,sizeof vis);\n\t\tif(dfs(i))ans++;\n\t}\n\t//\tprintf(\"%d\\n\",ans);\n\tprintf(\"%d\\n\",ans+(tot1-ans)/2*2+(tot2-ans)/2*2+(tot1-ans)%2*3);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cctype>\n#include <cmath>\n#include <algorithm>\n#define rep(i, a, b) for (int i = (a), _ = (b); i <= _; ++ i)\n#define per(i, a, b) for (int i = (a), _ = (b); i >= _; -- i)\n#define For(i, a, b) for (int i = (a), _ = (b); i < _; ++ i)\n#define ri rd<int>\nusing namespace std;\nconst int maxN = 207;\nconst int M = 10000000;\nconst int maxM = 1e7 + 7;\n\ntemplate<class T> inline T rd() {\n\tbool f = 1; char c = getchar(); for (; !isdigit(c); c = getchar()) if (c == '-') f = 0;\n\tT x = 0; for (; isdigit(c); c = getchar()) x = x * 10 + c - 48; return f ? x : -x;\n}\n\nint n;\nint a[maxN];\nint b[maxN], m;\nbool ntpri[maxM];\nint pri[maxM], cnt;\nint link[maxN], vis[maxN];\nbool adj[maxN][maxN];\n\nvoid seive() {\n\tntpri[1] = 1;\n\trep (i, 2, M) {\n\t\tif (!ntpri[i]) pri[++cnt] = i;\n\t\trep (j, 1, cnt) {\n\t\t\tif (1LL * i * pri[j] > M) break;\n\t\t\tntpri[i * pri[j]] = 1;\n\t\t\tif (i % pri[j] == 0) break;\n\t\t}\n\t}\n\tntpri[2] = ntpri[0] = 1;\n}\n\nint match(int x) {\n\tvis[x] = 1;\n\trep (y, 1, m) if (adj[x][y] && (!link[y] || (!vis[link[y]] && match(link[y])))) {\n\t\tlink[y] = 1;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nint main() {\n\tn = ri();\n\trep (i, 1, n) a[i] = ri();\n\n\tb[++m] = a[1] - 1;\n\trep (i, 2, n) if (a[i-1] + 1 < a[i]) b[++m] = a[i-1], b[++m] = a[i] - 1;\n\tb[++m] = a[n];\n\n\tseive();\n\n\trep (i, 1, m) if (b[i] & 1) \n\t\trep (j, 1, m) if (ntpri[abs(b[i] - b[j])] == 0) adj[i][j] = 1; \n\n\tint res = 0, cc = 0;\n\tmemset(link, 0, sizeof link);\n\trep (i, 1, m) if (b[i] & 1) {\n\t\tmemset(vis, 0, sizeof vis);\n\t\tres += match(i);\n\t\t++ cc;\n\t}\n\n\tres += ((cc - res) >> 1) << 1;\n\tres += ((m - cc) >> 1) << 1;\n\tres += 3 * ((m - cc) & 1);\n\n\tprintf(\"%d\\n\", res);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nint n, m, odd[209], even[209], lft[209], rgt[209];\nbool C[209];\nmap < int, bool > b;\nvector < int > v[209];\nconst int lim = 10000001;\nunsigned char cr[(lim + 10) >> 3];\n\nbool pairUp (int nod)\n{\n    if (C[nod]) return 0;\n    for (auto i : v[nod])\n        if (lft[i] == 0 || pairUp (lft[i]))\n        {\n            lft[i] = nod, rgt[nod] = i;\n            return 1;\n        }\n    return 0;\n}\n\nint maxMatch ()\n{\n    bool ok = 1;\n    while (ok)\n    {\n        ok = 0;\n        for (int i=1; i<=n; i++)\n            C[i] = 0;\n        for (int i=1; i<=n; i++)\n            if (rgt[i] == 0)\n                ok |= pairUp (i);\n    }\n    int ans = 0;\n    for (int i=1; i<=n; i++)\n        ans += (rgt[i] > 0);\n    return ans;\n}\n\nint main ()\n{\n//freopen (\"input\", \"r\", stdin);\n//freopen (\"output\", \"w\", stdout);\n\nint N;\nscanf (\"%d\", &N);\nfor (int i=1; i<=N; i++)\n{\n    int x;\n    scanf (\"%d\", &x);\n    b[x] ^= 1, b[x + 1] ^= 1;\n}\nfor (auto it : b)\n    if (it.second)\n    {\n        if (it.first & 1) odd[++n] = it.first;\n        else even[++m] = it.second;\n    }\nfor (int i=2; i * i<=lim; i++)\n    if (cr[i >> 3] & (1 << (i & 7)))\n        for (int j=i * i; j<=lim; j+=i)\n            cr[j >> 3] |= 1 << (j & 7);\nfor (int i=1; i<=n; i++)\n    for (int j=1; j<=m; j++)\n    {\n        int val = odd[i] - even[j];\n        if (val < 0) val = -val;\n        if (cr[val >> 3] & (1 << (val & 7)))\n            v[i].push_back (j);\n    }\nint T1 = maxMatch ();\nn -= T1, m -= T1;\nint T3 = n & 1, T2 = (n + m - 2 * T3) >> 1;\nprintf (\"%d\\n\", T1 + 2 * T2 + 3 * T3);\nreturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <algorithm>\n#include <queue>\n#include <vector>\n#include <stack>\n#include <cmath>\n#include <memory.h>\n#include <iomanip>\n#include <cassert>\nusing namespace std;\n\n#define maxn 202\n#define FOR(i, l, r) for (int i=l; i<=r; ++i)\n#define FORD(i, r, l) for (int i=r; i>=l; --i)\n#define REP(i, r) for (int i=0; i<(int)r; ++i)\n#define REPD(i, r) for (int i=(int)r-1; i>=0; --i)\n#define fi first\n#define se second\n#define mk make_pair\n#define nil NULL\n#define y0 y902\n#define y1 y232\n#define x0 x92\n#define x1 x899\n#define next asdfa\n#define sz size\n#define Debug(X) {cerr << #X << \" = \" << X << '\\n';}\n#define PR(A, n) {cerr << #A << \" = \"; FOR(i, 1, n) cerr << A[i] << ' '; cerr << '\\n';}\n#define PR0(A, n) {cerr << #A << \" = \"; REP(i, n) cerr << A[i] << ' '; cerr << '\\n';}\ntypedef long long ll;\ntypedef double db;\ntypedef pair<db, db> dd;\ntypedef pair<int, int> ii;\ntypedef vector<int> vi;\nconst int inf = 1e9;\ntemplate<class T> int getbit(T x, int pos) {return (x>>(pos-1)) & 1;}\ntemplate<class T> void turn_on(T &x, int pos) {x = x | ((T)1<<(pos-1));}\ntemplate<class T> void turn_off(T &x, int pos) {x = x & ~((T)1<<(pos-1));}\ntemplate<class T> T sqr(T a) {return a*a;}\n\nint n, assigned[maxn], visited[maxn], t;\nvector<int> a[maxn], even, odd;\n\nint visit(int u) {\n    if (visited[u]!=t) visited[u] = t;\n    else return 0;\n    REP(i, a[u].sz()) {\n        int v = a[u][i];\n        if (!assigned[v] || visit(assigned[v])) {\n            assigned[v] = u;\n            return 1;\n        }\n    }\n    return 0;\n}\n\nint findMaximumMatching() {\n    int cnt = 0;\n    REP(i, even.sz()) {\n        ++t;\n        cnt += visit(i);\n    }\n    return cnt;\n}\n\nbool isPrime(int a) {       ///notice that function will return false if a=2\n    if (a<=2) return false;\n    FOR(i, 2, sqrt(a)) {\n        if (a%i==0) return false;\n    }\n    return true;\n}\n\nint main() {\n    //freopen(\"prflip.inp\", \"r\", stdin);\n    //freopen(\"prflip.ans\", \"w\", stdout);\n    //ios::sync_with_stdio(0); cin.tie(0);\n    scanf(\"%d\", &n);\n    int prev = -1;\n    FOR(i, 1, n) {\n        int x; scanf(\"%d\", &x);\n        if (x!=prev+1) {\n            if (prev!=-1 && (prev+1)%2==0) even.push_back(prev+1);\n            else if (prev!=-1) odd.push_back(prev+1);\n            if (x%2==0) even.push_back(x);\n            else odd.push_back(x);\n        }\n        prev = x;\n    }\n    if ((prev+1)%2==0) even.push_back(prev+1);\n    else odd.push_back(prev+1);\n    REP(i, even.sz()) REP(j, odd.sz()) {\n        if (isPrime(abs(even[i]-odd[j])))\n            a[i].push_back(j);\n    }\n    int k = findMaximumMatching(), res = inf;\n    assert(even.sz()%2==odd.sz()%2);\n    FOR(i, 0, k) {\n        if (((int)even.sz()-k)%2==0) res = min(res, k+((int)even.sz()-k)+((int)odd.sz()-k));\n        else res = min(res, k+((int)even.sz()-1-k)+((int)odd.sz()-1-k)+3);\n    }\n    printf(\"%d\", res);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <cstdio>\n#include <cstring>\n\ninline int Abs(const int x){return x>=0?x:-x;}\n\nint n,a[205],b[205],Mat[205],Ans;\nbool G[205][205],Vis[205];\nstd::map<int,int> M;\n\nbool Prime(int x)\n{\n    if(x<2)return false;\n    for(int i=2;i*i<=x;++i)\n        if(x%i==0)return false;\n    return true;\n}\n\nbool DFS(int x)\n{\n    for(int y=1;y<=n;++y)\n        if(!Vis[y]&&G[x][y])\n            if(Vis[y]=true,!Mat[y]||DFS(Mat[y]))\n                return Mat[y]=x,true;\n    return false;\n}\n\nint main()\n{\n    scanf(\"%d\",&n);\n    for(int i=1,x;i<=n;++i)scanf(\"%d\",&x),M[x]^=1,M[x+1]^=1;\n    for(auto i:M)if(i.second)(i.first&1?a[++*a]:b[++*b])=i.first;\n    for(int i=1;i<=*a;++i)\n        for(int j=1;j<=*b;++j)\n            G[i][j]=Prime(Abs(a[i]-a[j]));\n    for(int i=1;i<=*a;++i)memset(Vis,0,sizeof Vis),Ans+=DFS(i);\n    printf(\"%d\\n\",Ans+(*a-Ans)/2*2+(*b-Ans)/2*2+(*a-Ans)%2*3);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nconst int N = 2e5+9;\nconst int M = 1e7+9;\n\nint n, a[M];\nint con[N];\nbool vis[N];\nvector<int> v[2], e[N];\n\ninline bool isPrime(int x) {\n    if (x == 1) return false;\n    for (int i = 2; i * i <= x; i++) {\n        if (x % i == 0) return false;\n    }\n    return true;\n}\n\nint dfs(int u) {\n    if (vis[u]) return 0;\n    vis[u] = 1;\n    for (int i = 0; i < e[u].size(); i++) {\n        int v = e[u][i];\n        if (con[v] == -1 || dfs(con[v])) {\n            con[v] = u;\n            return 1;\n        }\n    }\n    return 0;\n}\n\nint main() {\n    scanf(\"%d\", &n);\n    for (int i = 0; i < n; i++) {\n        int x; scanf(\"%d\", &x);\n        a[x] = 1;\n    }\n    memset(con, -1, sizeof(con));\n    for (int i = M; i >= 0; i--) {\n        a[i] ^= a[i - 1];\n        if (a[i]) v[i % 2].push_back(i);\n    }\n    for (int i = 0; i < v[0].size(); i++) {\n        for (int j = 0; j < v[1].size(); j++) {\n            if (isPrime(abs(v[0][i] - v[1][j]))) e[i].push_back(j);\n        }\n    }\n    int match = 0;\n    for (int i = 0; i < v[0].size(); i++) {\n        memset(vis, 0, sizeof(vis));\n        match += dfs(i);\n    }\n    printf(\"%d\\n\", v[0].size() + v[1].size() - match + (v[0].size() - match) % 2);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n\nstruct BiMatch{\n  Int n;\n  vector<vector<Int> > G;\n  vector<Int> match,used;\n  \n  BiMatch(){}\n  BiMatch(Int sz):n(sz),G(sz),match(sz),used(sz){}\n  \n  void add_edge(Int u,Int v){\n    G[u].push_back(v);\n    G[v].push_back(u);\n  }\n\n  bool dfs(Int v){\n    used[v]=true;\n    for(Int i=0;i<(Int)G[v].size();i++){\n      Int u=G[v][i],w=match[u];\n      if(w<0||(!used[w]&&dfs(w))){\n\tmatch[v]=u;\n\tmatch[u]=v;\n\treturn true;\n      }\n    }\n    return false;\n  }\n\n  Int build(){\n    Int res=0;\n    fill(match.begin(),match.end(),-1);\n    for(Int v=0;v<n;v++){\n      if(match[v]<0){\n\tfill(used.begin(),used.end(),0);\n\tif(dfs(v)){\n\t  res++;\n\t}\n      }\n    }\n    return res;\n  }\n};\n\n\nInt isprime(Int x){\n  if(x<=2) return 0;\n  for(Int i=2;i*i<=x;i++)\n    if(x%i==0) return 0;\n  return 1;\n}\n\n//INSERT ABOVE HERE\nsigned main(){\n  Int n;\n  cin>>n;\n  vector<Int> x(n);\n  for(Int i=0;i<n;i++) cin>>x[i];\n  \n  vector<Int> a(1e7+100,0);\n  for(Int i=0;i<n;i++) a[x[i]]=1;\n  vector<Int> b;\n  for(Int i=1;i<(Int)a.size();i++)\n    if(a[i]^a[i-1]) b.emplace_back(i);\n\n  Int m=b.size();\n  BiMatch bm(m);\n  for(Int i=0;i<n;i++)\n    for(Int j=0;j<i;j++)\n      if(isprime(b[i]-b[j]))\n\tbm.add_edge(i,j);\n\n  Int k=bm.build();\n  Int o=0,e=0;\n  for(Int x:b) if(x&1) o++;else e++;\n  //cout<<k<<\" \"<<o<<\" \"<<e<<endl;\n  Int ans=k+(o-k)/2*2+(e-k)/2*2+((o-k)&1?3:0);\n  cout<<ans<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,l,r) for(register int i = l ; i <= r ; i++)\n#define repd(i,r,l) for(register int i = r ; i >= l ; i--)\n#define rvc(i,S) for(register int i = 0 ; i < (int)S.size() ; i++)\n#define rvcd(i,S) for(register int i = ((int)S.size()) - 1 ; i >= 0 ; i--)\n#define fore(i,x)for (register int i = head[x] ; i ; i = e[i].next)\n#define forup(i,l,r) for (register int i = l ; i <= r ; i += lowbit(i))\n#define fordown(i,id) for (register int i = id ; i ; i -= lowbit(i))\n#define pb push_back\n#define prev prev_\n#define stack stack_\n#define mp make_pair\n#define fi first\n#define se second\n#define lowbit(x) (x&(-x))\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pr;\n\nconst ll MAX = 2e18;\nconst ld inf = 2e18;\nconst int maxn = 220;\nconst ll mod = 1e9 + 7;\n\ninline ll power(ll x,ll y){\n\ty = ((y % (mod - 1)) + (mod - 1)) % (mod - 1);\n//\tif ( y < 0 ) return power(power(x,-y),mod - 2);\n\tll res = 1;\n\twhile ( y ){\n\t\tif ( y & 1 ) res = res * x % mod;\n\t\tx = x * x % mod;\n\t\ty >>= 1;\n\t}\n\treturn res;\n}\nint a[maxn],n,odd[maxn],even[maxn],cnt1,cnt2;\nset <int> s;\nnamespace Prime{\n\tconst int N = 1e7;\n\tint prime[N + 20],tag[N + 20],mn[N + 20],Cnt;\t\n\tvoid init (){\n\t\trep(i,2,N){\n\t\t\tif ( !tag[i] ) prime[++Cnt] = i;\n\t\t\trep(j,1,Cnt){\n\t\t\t\tif ( prime[j] * i > N ) break;\n\t\t\t\ttag[i * prime[j]] = 1;\n\t\t\t\tmn[i * prime[j]] = prime[j];\n\t\t\t\tif ( i % prime[j] == 0 ) break;\n\t\t\t}\n\t\t}\n\t}\n}\nusing namespace Prime;\n\nstruct node{\n\tint next,to;\n}e[maxn * maxn];\nint head[maxn],cnt;\nint from[maxn],use[maxn],tot;\n\ninline void adde(int x,int y){\n\te[++cnt].to = y;\n\te[cnt].next = head[x];\n\thead[x] = cnt;\n}\nbool match(int x){\n\tfore(i,x){\n\t\tif ( !use[e[i].to] ){\n\t\t\tuse[e[i].to] = 1;\n\t\t\tif ( from[e[i].to] == -1 || match(from[e[i].to]) ){\n\t\t\t\tfrom[e[i].to] = x;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nvoid hungary(){\n\ttot = 0;\n\tmemset(from,-1,sizeof(from));\n\tn = cnt1;\n\trep(i,1,n){\n\t\tmemset(use,0,sizeof(use));\n\t\tif ( match(i) ) ++tot;\n\t}\n}\n\n\nint main(){\n\tinit();\n\tscanf(\"%d\",&n);\n\trep(i,1,n){\n\t   \tscanf(\"%d\",&a[i]);\n\t\tif ( s.find(a[i]) == s.end() ) s.insert(a[i]);\n\t\telse s.erase(a[i]);\n\n\t\tif ( s.find(a[i] + 1) == s.end() ) s.insert(a[i] + 1);\n\t\telse s.erase(a[i] + 1);\n\t}\n\tfor (auto it = s.begin() ; it != s.end() ; ++it){\n\t\tint x = *it;\n\t\tif ( x & 1 ) odd[++cnt1] = x;\n\t\telse even[++cnt2] = x;\n\t}\n\trep(i,1,cnt1){\n\t\trep(j,1,cnt2){\n\t\t\tint c = abs(odd[i] - even[j]);\n\t\t\tif ( !tag[c] ) adde(i,j + cnt1);\n\t\t}\n\t}\n\tcout<<cnt1 + cnt2 - tot + ((cnt1 - tot) & 1)<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdio>\n#define MN 200\n#define S 0\n#define T 201\n#define MV 10000000\nusing namespace std;\ninline int read()\n{\n    int x=0,f=1;char ch=getchar();\n    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n    while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n    return x*f;\n}\nbool b[MV+5],B[MV+5];\nint n,a[MN+5],head[MN+5],c[MN+5],d[MN+5],q[MN+5],top,cnt=1,s[MV/5],num,ans,cc,Num[2];\nstruct edge{int to,next,w;}e[MN*MN*10+5];\ninline void ins(int f,int t,int w)\n{\n    e[++cnt]=(edge){t,head[f],w};head[f]=cnt;\n    e[++cnt]=(edge){f,head[t],0};head[t]=cnt;\n}\ninline int Abs(int x){return x<0?-x:x;}\nbool bfs()\n{\n    memset(d,0,sizeof(d));int i,j;\n    for(d[q[top=i=1]=S]=1;i<=top;++i)\n        for(j=c[q[i]]=head[q[i]];j;j=e[j].next)\n            if(e[j].w&&!d[e[j].to]) d[q[++top]=e[j].to]=d[q[i]]+1;\n    return d[T];\n}\nint dfs(int x,int f)\n{\n    if(x==T) return f;int used=0;\n    for(int&i=c[x];i;i=e[i].next)\n        if(e[i].w&&d[e[i].to]==d[x]+1)\n        {\n            int w=dfs(e[i].to,min(f-used,e[i].w));\n            used+=w;e[i].w-=w;e[i^1].w+=w;\n            if(used==f) return f;\n        }\n    return d[x]=-1,used;\n}\nint main()\n{\n    n=read();\n    for(int i=1;i<=n;++i) a[i]=read(),B[a[i]]^=1,B[a[i]+1]^=1;\n    for(int i=2;i<=MV;++i)\n    {\n        if(!b[i]) s[++num]=i;\n        for(int j=1;s[j]*i<=MV;++j)\n        {\n            b[s[j]*i]=1;\n            if(i%s[j]==0) break;\n        }\n    }\n    for(int i=1;i<=n;++i)\n    {\n        if(B[a[i]]) s[++cc]=a[i],++Num[a[i]&1];\n        if(B[a[i]+1]) s[++cc]=a[i]+1,++Num[(a[i]&1)^1];\n    }\n    for(int i=1;i<=cc;++i)\n    {\n        if(s[i]&1) ins(S,i,1); else ins(i,T,1);\n        if(s[i]&1)for(int j=1;j<=cc;++j)if((~s[j]&1)&&Abs(s[i]-s[j])>2&&!b[Abs(s[i]-s[j])]) ins(i,j,1);\n    }\n    while(bfs()) ans+=dfs(S,10000);\n    printf(\"%d\",ans+(Num[0]-ans)/2*2+(Num[1]-ans)/2*2+((Num[0]-ans)&1)*3);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace std;\nusing namespace __gnu_pbds;\n\n#define ll long long\n#define db long double\n#define ii pair<int,int>\n#define vi vector<int>\n#define fi first\n#define se second\n#define sz(a) (int)(a).size()\n#define all(a) (a).begin(),(a).end()\n#define pb push_back\n#define mp make_pair\n#define FN(i, n) for (int i = 0; i < (int)(n); ++i)\n#define FEN(i,n) for (int i = 1;i <= (int)(n); ++i)\n#define rep(i,a,b) for(int i=a;i<b;i++)\n#define repv(i,a,b) for(int i=b-1;i>=a;i--)\n#define SET(A, val) memset(A, val, sizeof(A))\ntypedef tree<int ,null_type,less<int>,rb_tree_tag,tree_order_statistics_node_update>ordered_set ;\n// order_of_key (val): returns the no. of values less than val\n// find_by_order (k): returns the kth largest element.(0-based)\n#define TRACE\n#ifdef TRACE\n#define trace(...) __f(#__VA_ARGS__, __VA_ARGS__)\ntemplate <typename Arg1>\nvoid __f(const char* name, Arg1&& arg1){\n  cerr << name << \" : \" << arg1 << std::endl;\n}\ntemplate <typename Arg1, typename... Args>\nvoid __f(const char* names, Arg1&& arg1, Args&&... args){\n  const char* comma = strchr(names + 1, ','); cerr.write(names, comma - names) << \" : \" << arg1<<\" | \";__f(comma+1, args...);\n}\n#else\n#define trace(...)\n#endif\nconst int N=105,L=1e7+5;\nbool mark[L],prime[L];\nnamespace match\n{\n  const int N=105;\n  int l[N],r[N],n,m;\n  bool a[N][N],seen[N];\n  bool findmatch(int i)\n  {\n    rep(j,0,m)\n      {\n\tif(a[i][j] && !seen[j])\n\t  {\n\t    seen[j]=true;\n\t    if(r[j]<0 || findmatch(r[j]))\n\t      {\n\t\tl[i]=j; r[j]=i;\n\t\treturn true;\n\t      }\n\t  }\n      }\n    return false;\n  }\n  int bipartitematch()\n  {\n    int cnt=0;\n    rep(i,0,n) l[i]=-1;\n    rep(i,0,m) r[i]=-1;\n    rep(i,0,n)\n      {\n\trep(j,0,m) seen[j]=false;\n\tif(findmatch(i)) cnt++;\n      }\n    return cnt;\n  }\n};\nint main()\n{\n  std::ios::sync_with_stdio(false);\n  cin.tie(NULL) ; cout.tie(NULL) ;\n  memset(prime,true,sizeof(prime));\n  prime[1]=false;\n  rep(i,2,L)\n    {\n      if(!prime[i]) continue;\n      for(int j=2*i;j<L;j+=i)\n\tprime[j]=false;\n    }\n  prime[2]=false;\n  int n,x;\n  cin>>n;\n  rep(i,1,n+1)\n    {\n      cin>>x;\n      mark[x]=true;\n    }\n  vi arr;\n  rep(i,1,L-1)\n    if((mark[i-1] && !mark[i])  || (!mark[i-1] && mark[i]))\n      arr.pb(i);\n  match::n=match::m=sz(arr);\n  int odd=0,even=0;\n  for(int x:arr)\n    {\n      if(x%2==0) even++;\n      else odd++;\n    }\n  rep(i,0,sz(arr))\n    rep(j,i+1,sz(arr))\n    {\n      if(prime[arr[j]-arr[i]]) match::a[i][j]=1;\n      else match::a[i][j]=0;\n    }\n  int k=match::bipartitematch();\n  int ans=k+((even-k)/2+(odd-k)/2)*2+((even-k)&1)*3;\n  cout<<ans<<endl;\n  return 0 ;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n  \nusing namespace std;\n  \n#define rep(i,n) REP(i,0,n)\n#define REP(i,s,e) for(int i=(s); i<(int)(e); i++)\n#define repr(i, n) REPR(i, n, 0)\n#define REPR(i, s, e) for(int i=(int)(s-1); i>=(int)(e); i--)\n#define pb push_back\n#define all(r) r.begin(),r.end()\n#define rall(r) r.rbegin(),r.rend()\n#define fi first\n#define se second\n  \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n \nconst int INF = 1e9;\nconst ll MOD = 1e9 + 7;\ndouble EPS = 1e-8;\n\n#define MAX_V 2200\n \nstruct Edge\n{\n    int to, cap, rev;\n    Edge(){};\n    Edge(int to, int cap, int rev) : to(to), cap(cap), rev(rev){};\n};\n \nvector<Edge> G[MAX_V];\nbool used[MAX_V];\n \nvoid add_edge(int from, int to, int cap){\n    G[from].push_back({to, cap, (int)G[to].size()});\n    G[to].push_back({from, 0, (int)G[from].size()-1});\n}\n \nint dfs(int v, int t, int f){\n    if(v == t) return f;\n    used[v] = true;\n    for(int i = 0; i < G[v].size(); i++){\n        Edge& e = G[v][i];\n        if(!used[e.to] && e.cap > 0){\n            int d = dfs(e.to, t, min(f, e.cap));\n            if(d > 0){\n                e.cap -= d;\n                G[e.to][e.rev].cap += d;\n                return d;\n            }\n        }\n    }\n    return 0;\n}\n \nint max_flow(int s, int t){\n    int flow = 0;\n    while(1){\n        memset(used, 0, sizeof(used));\n        int f = dfs(s, t, INF);\n        if(f == 0) return flow;\n        flow += f;\n    }\n}\n\n//エラトステネスの篩を使用\nconst int MAX_PRIME = 1e7 + 10;\n \nvector<int> is_prime(MAX_PRIME,1);\n \nvoid calcPrime(){\n    is_prime[0]=is_prime[1]=0;\n    for(int i=2; i<MAX_PRIME; i++){\n        if(is_prime[i]==1){\n            for(int j=i*2; j<MAX_PRIME; j+=i){\n                is_prime[j]=0;\n            }\n        }\n    }\n}\n\nint main(){\n\tcalcPrime();\n\tint n;\n\tcin >> n;\n\tvi x(n);\n\trep(i, n) cin >> x[i];\n\tmap<int, int> mp;\n\trep(i, n) {\n\t\tmp[x[i]]^=1;\n\t\tmp[x[i]+1]^=1;\n\t}\n\tvi odd, even;\n\tfor(auto& p : mp) if(p.se) (p.fi&1?odd:even).pb(p.se);\n\trep(i, odd.size()) rep(j, even.size()) {\n\t\tif(is_prime[abs(odd[i]-even[j])]) add_edge(i, odd.size()+j, 1);\n\t}\n\trep(i, odd.size()) add_edge(n, i, 1);\n\trep(i, even.size()) add_edge(odd.size()+i, n+1, 1);\n\tint f = max_flow(n, n+1);\n\tint ans = f + ((int)odd.size()-f)/2*2 + ((int)even.size()-f)/2*2;\n\tif(((int)odd.size()-f)&1) ans += 3;\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define del(a,i) memset(a,i,sizeof(a))\n#define ll long long\n#define inl inline\n#define il inl void\n#define it inl int\n#define ill inl ll\n#define re register\n#define ri re int\n#define rl re ll\n#define mid ((l+r)>>1)\n#define lowbit(x) (x&(-x))\n#define INF 0x3f3f3f3f\nusing namespace std;\ntemplate<class T>il read(T &x){\n\tint f=1;char k=getchar();x=0;\n\tfor(;k>'9'||k<'0';k=getchar()) if(k=='-') f=-1;\n\tfor(;k>='0'&&k<='9';k=getchar()) x=(x<<3)+(x<<1)+k-'0';\n\tx*=f;\n}\ntemplate<class T>il _print(T x){\n\tif(x/10) _print(x/10);\n\tputchar(x%10+'0');\n}\ntemplate<class T>il print(T x){\n\tif(x<0) putchar('-'),x=-x;\n\t_print(x);\n}\nll mul(ll a,ll b,ll mod){long double c=1.;return (a*b-(ll)(c*a*b/mod)*mod)%mod;}\nit qpow(int x,int m,int mod){\n\tint res=1,bas=x;\n\twhile(m){\n\t\tif(m&1) res=(1ll*res*bas)%mod;\n\t\tbas=(1ll*bas*bas)%mod,m>>=1;\n\t}\n\treturn res;\n}\nconst int N = 1e3+5,M = 1e6+5,MAXN = 1e7+5;\nint n,x,mx,ccnt,S,T,pri[MAXN];\nchar is_not[MAXN],ty[MAXN];\nil Init(){\n\tis_not[1]=1;\n\tfor(ri i=2;i<=MAXN-5;++i){\n\t\tif(!is_not[i]) pri[++ccnt]=i;\n\t\tfor(ri j=1;j<=ccnt&&i*pri[j]<=MAXN-5;++j){\n\t\t\tis_not[i*pri[j]]=1;\n\t\t\tif(i%pri[j]==0) break;\n\t\t}\n\t}\n}\nint num_edge=-1,head[N],cur[N],dis[N],cntL,cntR,L[N],R[N];\nstruct Edge{ int next,to,w; }edge[M];\nil add_edge(int u,int v,int w){\n\tedge[++num_edge]=(Edge){ head[u],v,w },head[u]=num_edge;\n\tedge[++num_edge]=(Edge){ head[v],u,0 },head[v]=num_edge;\n}\ninl bool BFS(int s,int t){\n\tfor(ri i=s;i<=t;++i) dis[i]=0;\n\tqueue<int> q;q.push(s),dis[s]=1;\n\twhile(!q.empty()){\n\t\tint pos=q.front();q.pop();\n\t\tfor(ri i=head[pos];i!=-1;i=edge[i].next)\n\t\t\tif(edge[i].w>0&&!dis[edge[i].to]){\n\t\t\t\tdis[edge[i].to]=dis[pos]+1;\n\t\t\t\tif(edge[i].to==t) return true;\n\t\t\t\tq.push(edge[i].to);\n\t\t\t}\n\t}\n\treturn false;\n}\nit DFS(int now,int t,int flow){\n\tif(now==t) return flow;\n\tint s=0,k;\n\tfor(ri &i=cur[now];i!=-1;i=edge[i].next) if(edge[i].w>0&&dis[edge[i].to]==dis[now]+1){\n\t\tk=DFS(edge[i].to,t,min(flow-s,edge[i].w));\n\t\ts+=k,edge[i].w-=k,edge[i^1].w+=k;\n\t\tif(s==flow) break;\n\t}\n\tif(!s) dis[now]=0;\n\treturn s;\n}\nit Dinic(int s,int t){\n\tint res=0;\n\twhile(BFS(s,t)){\n\t\tfor(ri i=s;i<=t;++i) cur[i]=head[i];\n\t\tres+=DFS(s,t,INF);\n\t}\n\treturn res;\n}\nint main(){\n//\tfreopen(\".in\",\"r\",stdin);\n//\tfreopen(\".out\",\"w\",stdout);\n\tread(n),Init(),del(head,-1);\n\tfor(ri i=1;i<=n;++i) read(x),ty[x]=1,mx=max(mx,x+1);\n\tfor(ri i=mx;i>=1;--i) ty[i]=ty[i]^ty[i-1];\n\tfor(ri i=1;i<=mx;++i){\n\t\tif(!ty[i]) continue;\n\t\tif(i&1) L[++cntL]=i;\n\t\telse R[++cntR]=i;\n\t}\n\tT=cntL+cntR+1;\n\tfor(ri i=1;i<=cntL;++i) add_edge(S,i,1);\n\tfor(ri i=1;i<=cntR;++i) add_edge(i+cntL,T,1);\n\tfor(ri i=1;i<=cntL;++i) for(ri j=1;j<=cntR;++j)\n\t\tif(!is_not[abs(L[i]-R[j])]) add_edge(i,j+cntL,1);\n\tint mx_flow=Dinic(S,T),ans=mx_flow;\n\tans+=(cntL-mx_flow)/2*2+(cntR-mx_flow)/2*2;\n\tans+=((cntL-mx_flow)&1)*3;\n\tprint(ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define sqr(x) ((x)*(x))\n#define ll long long\n#define ull unsigned long long\n#define ui unsigned int\n#define ld long double\n#define vi vector<int>\n#define HEAP(T) priority_queue<T>\n#define heap(...) priority_queue<__VA_ARGS__,vector<__VA_ARGS__>,greater<__VA_ARGS__> > \n#define pii pair<int,int>\n#define pb push_back\n#define mp make_pair\n#define debuge cerr<<\"isok\"<<endl\n#define debug(x) cerr<<#x<<\"=\"<<x<<endl\n#define error(...) fprintf(stderr,__VA_ARGS__)\n#define SS second\n#define FF first\n#define ls (k<<1)\n#define rs (k<<1|1)\n#define inf 0x3f3f3f3f\n#define LL long long\n#define clr(a,x) memset(a,x,sizeof(a))\n#define cpy(a,x) memcpy(a,x,sizeof(a))\n#define file(x) freopen(x\".in\",\"r\",stdin),freopen(x\".out\",\"w\",stdout)\nusing namespace std;\n\nconst int N=20000005,M=100005,mod=1e9+7;\ntemplate<class T> inline void gmin(T &x,const T &y){if(x>y) x=y;}\ntemplate<class T> inline void gmax(T &x,const T &y){if(x<y) x=y;}\ntemplate<class T,class S> inline void ch(T &x,const S y){x=(x+y)%mod;}\nconst int BufferSize=1<<16;\nchar buffer[BufferSize],*Bufferhead,*Buffertail;\nbool Terminal;\ninline char Getchar(){\n\tif(Bufferhead==Buffertail){\n\t\tint l=fread(buffer,1,BufferSize,stdin);\n\t\tif(!l){Terminal=1;return 0;}\n\t\tBuffertail=(Bufferhead=buffer)+l;\n\t}\n\treturn *Bufferhead++;\n}\ntemplate<class T>inline bool read(T &x){\n\tx=0;char c=Getchar(),rev=0;\n\twhile(c<'0'||c>'9'){c=Getchar();rev|=c=='-';if(Terminal)return 0;}\n\twhile(c>='0'&&c<='9') x=x*10+c-'0',c=Getchar();\n\tx=rev?-x:x;\n\treturn 1;\n}\ninline bool reads(char *x){\n\tchar c=Getchar();\n\twhile(c<33||c>126){c=Getchar();if(Terminal)return 0;}\n\twhile(c>=33&&c<=126) (*x++)=c,c=Getchar();\n\t*x=0;return 1;\n}\ntemplate<class T>inline void print(T x,const char c){\n\tif(!x){putchar('0');putchar(c);return;}\n\tif(x<0) putchar('-'),x=-x;\n\tint m=0,a[10];\n\twhile(x) a[m++]=x%10,x/=10;\n\twhile(m--) putchar(a[m]+'0');\n\tputchar(c);\n}\ninline int exp(int x,int y,const int mod=::mod){\n\tint ans=1;\n\twhile(y){\n\t\tif(y&1) ans=(ll)ans*x%mod;\n\t\tx=(ll)x*x%mod;y>>=1;\n\t}return ans;\n}\n\nconst int INF = 2147483647;\n\nconst int MaxN = 400;\nconst int MaxM = 79800;\n\ntemplate <class T>\ninline void tension(T &a, const T &b)\n{\n\tif (b < a)\n\t\ta = b;\n}\ntemplate <class T>\ninline void relax(T &a, const T &b)\n{\n\tif (b > a)\n\t\ta = b;\n}\ntemplate <class T>\ninline int size(const T &a)\n{\n\treturn (int)a.size();\n}\n\ninline int getint()\n{\n\tchar c;\n\twhile (c = getchar(), '0' > c || c > '9');\n\n\tint res = c - '0';\n\twhile (c = getchar(), '0' <= c && c <= '9')\n\t\tres = res * 10 + c - '0';\n\treturn res;\n}\n\nconst int MaxNX = MaxN + MaxN;\n\nstruct edge\n{\n\tint v, u, w;\n\n\tedge(){}\n\tedge(const int &_v, const int &_u, const int &_w)\n\t\t: v(_v), u(_u), w(_w){}\n};\n\nint n, m;\nedge mat[MaxNX + 1][MaxNX + 1];\n\nint n_matches;\nLL tot_weight;\nint mate[MaxNX + 1];\nint lab[MaxNX + 1];\n\nint q_n, q[MaxN];\nint fa[MaxNX + 1], col[MaxNX + 1];\nint slackv[MaxNX + 1];\n\nint n_x;\nint bel[MaxNX + 1], blofrom[MaxNX + 1][MaxNX + 1];\nvector<int> bloch[MaxNX + 1];\n\ninline int e_delta(const edge &e) // does not work inside blossoms\n{\n\treturn lab[e.v] + lab[e.u] - mat[e.v][e.u].w * 2;\n}\ninline void update_slackv(int v, int x)\n{\n\tif (!slackv[x] || e_delta(mat[v][x]) < e_delta(mat[slackv[x]][x]))\n\t\tslackv[x] = v;\n}\ninline void calc_slackv(int x)\n{\n\tslackv[x] = 0;\n\tfor (int v = 1; v <= n; v++)\n\t\tif (mat[v][x].w > 0 && bel[v] != x && col[bel[v]] == 0)\n\t\t\tupdate_slackv(v, x);\n}\n\ninline void q_push(int x)\n{\n\tif (x <= n)\n\t\tq[q_n++] = x;\n\telse\n\t{\n\t\tfor (int i = 0; i < size(bloch[x]); i++)\n\t\t\tq_push(bloch[x][i]);\n\t}\n}\ninline void set_mate(int xv, int xu)\n{\n\tmate[xv] = mat[xv][xu].u;\n\tif (xv > n)\n\t{\n\t\tedge e = mat[xv][xu];\n\t\tint xr = blofrom[xv][e.v];\n\t\tint pr = find(bloch[xv].begin(), bloch[xv].end(), xr) - bloch[xv].begin();\n\t\tif (pr % 2 == 1)\n\t\t{\n\t\t\treverse(bloch[xv].begin() + 1, bloch[xv].end());\n\t\t\tpr = size(bloch[xv]) - pr;\n\t\t}\n\n\t\tfor (int i = 0; i < pr; i++)\n\t\t\tset_mate(bloch[xv][i], bloch[xv][i ^ 1]);\n\t\tset_mate(xr, xu);\n\n\t\trotate(bloch[xv].begin(), bloch[xv].begin() + pr, bloch[xv].end());\n\t}\n}\ninline void set_bel(int x, int b)\n{\n\tbel[x] = b;\n\tif (x > n)\n\t{\n\t\tfor (int i = 0; i < size(bloch[x]); i++)\n\t\t\tset_bel(bloch[x][i], b);\n\t}\n}\n\ninline void augment(int xv, int xu)\n{\n\twhile (true)\n\t{\n\t\tint xnu = bel[mate[xv]];\n\t\tset_mate(xv, xu);\n\t\tif (!xnu)\n\t\t\treturn;\n\t\tset_mate(xnu, bel[fa[xnu]]);\n\t\txv = bel[fa[xnu]], xu = xnu;\n\t}\n}\ninline int get_lca(int xv, int xu)\n{\n\tstatic bool book[MaxNX + 1];\n\tfor (int x = 1; x <= n_x; x++)\n\t\tbook[x] = false;\n\twhile (xv || xu)\n\t{\n\t\tif (xv)\n\t\t{\n\t\t\tif (book[xv])\n\t\t\t\treturn xv;\n\t\t\tbook[xv] = true;\n\t\t\txv = bel[mate[xv]];\n\t\t\tif (xv)\n\t\t\t\txv = bel[fa[xv]];\n\t\t}\n\t\tswap(xv, xu);\n\t}\n\treturn 0;\n}\n\ninline void add_blossom(int xv, int xa, int xu)\n{\n\tint b = n + 1;\n\twhile (b <= n_x && bel[b])\n\t\tb++;\n\tif (b > n_x)\n\t\tn_x++;\n\n\tlab[b] = 0;\n\tcol[b] = 0;\n\n\tmate[b] = mate[xa];\n\n\tbloch[b].clear();\n\tbloch[b].push_back(xa);\n\tfor (int x = xv; x != xa; x = bel[fa[bel[mate[x]]]])\n\t\tbloch[b].push_back(x), bloch[b].push_back(bel[mate[x]]), q_push(bel[mate[x]]);\n\treverse(bloch[b].begin() + 1, bloch[b].end());\n\tfor (int x = xu; x != xa; x = bel[fa[bel[mate[x]]]])\n\t\tbloch[b].push_back(x), bloch[b].push_back(bel[mate[x]]), q_push(bel[mate[x]]);\n\n\tset_bel(b, b);\n\n\tfor (int x = 1; x <= n_x; x++)\n\t{\n\t\tmat[b][x].w = mat[x][b].w = 0;\n\t\tblofrom[b][x] = 0;\n\t}\n\tfor (int i = 0; i < size(bloch[b]); i++)\n\t{\n\t\tint xs = bloch[b][i];\n\t\tfor (int x = 1; x <= n_x; x++)\n\t\t\tif (mat[b][x].w == 0 || e_delta(mat[xs][x]) < e_delta(mat[b][x]))\n\t\t\t\tmat[b][x] = mat[xs][x], mat[x][b] = mat[x][xs];\n\t\tfor (int x = 1; x <= n_x; x++)\n\t\t\tif (blofrom[xs][x])\n\t\t\t\tblofrom[b][x] = xs;\n\t}\n\tcalc_slackv(b);\n}\ninline void expand_blossom1(int b) // lab[b] == 1\n{\n\tfor (int i = 0; i < size(bloch[b]); i++)\n\t\tset_bel(bloch[b][i], bloch[b][i]);\n\n\tint xr = blofrom[b][mat[b][fa[b]].v];\n\tint pr = find(bloch[b].begin(), bloch[b].end(), xr) - bloch[b].begin();\n\tif (pr % 2 == 1)\n\t{\n\t\treverse(bloch[b].begin() + 1, bloch[b].end());\n\t\tpr = size(bloch[b]) - pr;\n\t}\n\n\tfor (int i = 0; i < pr; i += 2)\n\t{\n\t\tint xs = bloch[b][i], xns = bloch[b][i + 1];\n\t\tfa[xs] = mat[xns][xs].v;\n\t\tcol[xs] = 1, col[xns] = 0;\n\t\tslackv[xs] = 0, calc_slackv(xns);\n\t\tq_push(xns);\n\t}\n\tcol[xr] = 1;\n\tfa[xr] = fa[b];\n\tfor (int i = pr + 1; i < size(bloch[b]); i++)\n\t{\n\t\tint xs = bloch[b][i];\n\t\tcol[xs] = -1;\n\t\tcalc_slackv(xs);\n\t}\n\n\tbel[b] = 0;\n}\ninline void expand_blossom_final(int b) // at the final stage\n{\n\tfor (int i = 0; i < size(bloch[b]); i++)\n\t{\n\t\tif (bloch[b][i] > n && lab[bloch[b][i]] == 0)\n\t\t\texpand_blossom_final(bloch[b][i]);\n\t\telse\n\t\t\tset_bel(bloch[b][i], bloch[b][i]);\n\t}\n\tbel[b] = 0;\n}\n\ninline bool on_found_edge(const edge &e)\n{\n\tint xv = bel[e.v], xu = bel[e.u];\n\tif (col[xu] == -1)\n\t{\n\t\tint nv = bel[mate[xu]];\n\t\tfa[xu] = e.v;\n\t\tcol[xu] = 1, col[nv] = 0;\n\t\tslackv[xu] = slackv[nv] = 0;\n\t\tq_push(nv);\n\t}\n\telse if (col[xu] == 0)\n\t{\n\t\tint xa = get_lca(xv, xu);\n\t\tif (!xa)\n\t\t{\n\t\t\taugment(xv, xu), augment(xu, xv);\n\t\t\tfor (int b = n + 1; b <= n_x; b++)\n\t\t\t\tif (bel[b] == b && lab[b] == 0)\n\t\t\t\t\texpand_blossom_final(b);\n\t\t\treturn true;\n\t\t}\n\t\telse\n\t\t\tadd_blossom(xv, xa, xu);\n\t}\n\treturn false;\n}\n\nbool match()\n{\n\tfor (int x = 1; x <= n_x; x++)\n\t\tcol[x] = -1, slackv[x] = 0;\n\n\tq_n = 0;\n\tfor (int x = 1; x <= n_x; x++)\n\t\tif (bel[x] == x && !mate[x])\n\t\t\tfa[x] = 0, col[x] = 0, slackv[x] = 0, q_push(x);\n\tif (q_n == 0)\n\t\treturn false;\n\n\twhile (true)\n\t{\n\t\tfor (int i = 0; i < q_n; i++)\n\t\t{\n\t\t\tint v = q[i];\n\t\t\tfor (int u = 1; u <= n; u++)\n\t\t\t\tif (mat[v][u].w > 0 && bel[v] != bel[u])\n\t\t\t\t{\n\t\t\t\t\tint d = e_delta(mat[v][u]);\n\t\t\t\t\tif (d == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (on_found_edge(mat[v][u]))\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\telse if (col[bel[u]] == -1 || col[bel[u]] == 0)\n\t\t\t\t\t\tupdate_slackv(v, bel[u]);\n\t\t\t\t}\n\t\t}\n\n\t\tint d = INF;\n\t\tfor (int v = 1; v <= n; v++)\n\t\t\tif (col[bel[v]] == 0)\n\t\t\t\ttension(d, lab[v]);\n\t\tfor (int b = n + 1; b <= n_x; b++)\n\t\t\tif (bel[b] == b && col[b] == 1)\n\t\t\t\ttension(d, lab[b] / 2);\n\t\tfor (int x = 1; x <= n_x; x++)\n\t\t\tif (bel[x] == x && slackv[x])\n\t\t\t{\n\t\t\t\tif (col[x] == -1)\n\t\t\t\t\ttension(d, e_delta(mat[slackv[x]][x]));\n\t\t\t\telse if (col[x] == 0)\n\t\t\t\t\ttension(d, e_delta(mat[slackv[x]][x]) / 2);\n\t\t\t}\n\n\t\tfor (int v = 1; v <= n; v++)\n\t\t{\n\t\t\tif (col[bel[v]] == 0)\n\t\t\t\tlab[v] -= d;\n\t\t\telse if (col[bel[v]] == 1)\n\t\t\t\tlab[v] += d;\n\t\t}\n\t\tfor (int b = n + 1; b <= n_x; b++)\n\t\t\tif (bel[b] == b)\n\t\t\t{\n\t\t\t\tif (col[bel[b]] == 0)\n\t\t\t\t\tlab[b] += d * 2;\n\t\t\t\telse if (col[bel[b]] == 1)\n\t\t\t\t\tlab[b] -= d * 2;\n\t\t\t}\n\n\t\tq_n = 0;\n\t\tfor (int v = 1; v <= n; v++)\n\t\t\tif (lab[v] == 0) // all unmatched vertices' labels are zero! cheers!\n\t\t\t\treturn false;\n\t\tfor (int x = 1; x <= n_x; x++)\n\t\t\tif (bel[x] == x && slackv[x] && bel[slackv[x]] != x && e_delta(mat[slackv[x]][x]) == 0)\n\t\t\t{\n\t\t\t\tif (on_found_edge(mat[slackv[x]][x]))\n\t\t\t\t\treturn true;\n\t\t\t}\n\t\tfor (int b = n + 1; b <= n_x; b++)\n\t\t\tif (bel[b] == b && col[b] == 1 && lab[b] == 0)\n\t\t\t\texpand_blossom1(b);\n\t}\n\treturn false;\n}\n\nvoid calc_max_weight_match()\n{\n\tfor (int v = 1; v <= n; v++)\n\t\tmate[v] = 0;\n\n\tn_x = n;\n\tn_matches = 0;\n\ttot_weight = 0;\n\n\tbel[0] = 0;\n\tfor (int v = 1; v <= n; v++)\n\t\tbel[v] = v, bloch[v].clear();\n\tfor (int v = 1; v <= n; v++)\n\t\tfor (int u = 1; u <= n; u++)\n\t\t\tblofrom[v][u] = v == u ? v : 0;\n\n\tint w_max = 0;\n\tfor (int v = 1; v <= n; v++)\n\t\tfor (int u = 1; u <= n; u++)\n\t\t\trelax(w_max, mat[v][u].w);\n\tfor (int v = 1; v <= n; v++)\n\t\tlab[v] = w_max;\n\n\twhile (match())\n\t\tn_matches++;\n\n\tfor (int v = 1; v <= n; v++)\n\t\tif (mate[v] && mate[v] < v)\n\t\t\ttot_weight += mat[v][mate[v]].w;\n}\n\n\ninline bool check(int x){\n\tif(x==1) return 0;\n\tfor(int i=2;i*i<=x;i++)\t\n\t\tif(x%i==0) return 0;\n\treturn 1;\t\n}\nint calc(int n){\n\tif(n%2==0) return 2;\n\tif(check(n)) return 3;\n\treturn 1;\n}\n\nbool f[N];\nint a[105];\n\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++){\n\t\tint x;scanf(\"%d\",&x);\n\t\tf[x]=1;\n\t}\n\tn=0;\n\tfor(int i=1;i<=10000001;i++) \n\t\tif(f[i]^f[i-1]) a[++n]=i;\n\tfor (int v=1;v<=n;v++)\n\t\tfor (int u=1;u<=n;u++)\n\t\t\tif(u!=v) mat[v][u]=edge(v,u,calc(abs(a[u]-a[v])));\n\tcalc_max_weight_match();\n\tprintf(\"%d\\n\", n*2-tot_weight);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint n, lim = 10000001, pm[2000007], l[107], r[107], cntl, cntr, cnt;\nint h[207], cur[207], num[207], to[200007], w[200007], nxt[200007], tot, s, t, ans, res;\nbool is[10000007],ck[10000007];\nqueue<int>q;\nint read()\n{\n\tint num = 0;\n\tchar c = getchar();\n\twhile (c < '0' || c>'9')c = getchar();\n\twhile (c >= '0' && c <= '9')num = num * 10 + c - '0', c = getchar();\n\treturn num;\n}\nint add(int a, int b, int c)\n{\n\tto[tot] = b;\n\tw[tot] = c;\n\tnxt[tot] = h[a];\n\th[a] = tot;\n\ttot++;\n\tto[tot] = a;\n\tnxt[tot] = h[b];\n\th[b] = tot;\n\treturn 0;\n}\nint bfs()\n{\n\tmemcpy(cur, h, sizeof cur);\n\tmemset(num, 0, sizeof num);\n\tq.push(s);\n\tnum[s] = 1;\n\twhile (!q.empty())\n\t{\n\t\tint x = q.front();\n\t\tq.pop();\n\t\tfor (int i = h[x]; i != -1; i = nxt[i])\n\t\t\tif (w[i] && !num[to[i]])\n\t\t\t{\n\t\t\t\tnum[to[i]] = num[x] + 1;\n\t\t\t\tq.push(to[i]);\n\t\t\t}\n\t}\n\treturn num[t];\n}\nint dfs(int x, int l)\n{\n\tif (x == t)return l;\n\tint used = 0;\n\tfor (int& i = cur[x]; i != -1; i = nxt[i])\n\t\tif (w[i] && num[to[i]] == num[x] + 1)\n\t\t{\n\t\t\tint d = dfs(to[i], min(w[i], l - used));\n\t\t\tif (d)\n\t\t\t{\n\t\t\t\tw[i] -= d;\n\t\t\t\tw[i ^ 1] += d;\n\t\t\t\tused += d;\n\t\t\t\tif (l == used)break;\n\t\t\t}\n\t\t}\n\treturn used;\n}\nint main()\n{\n\tfor (int i = 2; i <= lim; i++)\n\t{\n\t\tif (!ck[i])pm[++cnt] = i;\n\t\tfor (int j = 1; j <= cnt && i * pm[j] <= lim; j++)\n\t\t{\n\t\t\tck[i * pm[j]] = 1;\n\t\t\tif (i % pm[j] == 0)break;\n\t\t}\n\t}\n\tck[0] = ck[1] = ck[2] = 1;\n\tn = read();\n\tfor (int i = 1; i <= n; i++)\n\t\tis[read()] = 1;\n\tfor (int i = 1; i <= lim; i++)\n\t\tif (is[i] != is[i - 1])\n\t\t\tif (i & 1)l[++cntl] = i;\n\t\t\telse r[++cntr] = i;\n\tt = cntl + cntr + 1;\n\tmemset(h, -1, sizeof h);\n\tfor (int i = 1; i <= cntl; i++)\n\t\tadd(s, i, 1);\n\tfor (int i = 1; i <= cntr; i++)\n\t\tadd(cntl + i, t, 1);\n\tfor (int i = 1; i <= cntl; i++)\n\t\tfor (int j = 1; j <= cntr; j++)\n\t\t\tif (!ck[abs(l[i] - r[j])])\n\t\t\t\tadd(i, cntl + j, 1);\n\twhile(bfs())\n\t\tans += dfs(s, 1e9);\n\tres = ans;\n\tres += (cntl - ans) / 2 * 2 + (cntr - ans) / 2 * 2;\n\tres += ((cntl - ans) & 1) * 3;\n\tcout << res << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <set>\n#include <bitset>\nusing namespace std;\nint N;\nint x;\nset<int> S;\nvector<int> G[205];\nint L[205];\nint R[205];\nvector<int> Me,Mo;\nbitset<205> U;\nbool prime(int nr)\n{\n    for(int i=2;i*i<=nr;i++)if(nr%i==0)return 0;\n    return 1;\n}\nbool pairup(int nod)\n{\n    if(U[nod])return 0;\n    U[nod]=1;\n    for(auto it:G[nod])\n    {\n        if(!R[it])\n        {\n            L[nod]=it;\n            R[it]=nod;\n            return 1;\n        }\n    }\n    for(auto it:G[nod])\n    {\n        if(pairup(R[it]))\n        {\n            L[nod]=it;\n            R[it]=nod;\n            return 1;\n        }\n    }\n    return 0;\n}\nint main()\n{\n    cin>>N;\n    for(int i=1;i<=N;i++)\n    {\n        cin>>x;\n        if(S.find(x)!=S.end())\n        {\n            S.erase(x);\n        }\n        else\n        {\n            S.insert(x);\n        }\n        S.insert(x+1);\n    }\n    for(auto it:S)\n        if(it%2==0)\n            Me.push_back(it);\n        else\n            Mo.push_back(it);\n    for(int i=0;i<Me.size();i++)\n    {\n        for(int j=0;j<Mo.size();j++)\n        {\n            if(prime(abs(Mo[j]-Me[i])))\n                G[i+1].push_back(j+1);\n        }\n    }\n    bool ok=1;\n    int k=0;\n    while(ok)\n    {\n        ok=0;\n        U.reset();\n        for(int i=0;i<Me.size();i++)\n        {\n            if(!L[i]&&pairup(i+1))\n            {\n                k++;\n                ok=1;\n            }\n        }\n    }\n    int rez=k+(((int)Me.size()-k)/2)*2+(((int)Mo.size()-k)/2)*2+(((int)Me.size()-k)%2)*3;\n    cout<<rez;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// Written By NewbieChd\n#include <cstdio>\n#include <cctype>\n#include <cstring>\n#include <algorithm>\n#include <queue>\nusing namespace std;\n\nconst int BUF = 1000000;\nchar buf[BUF], *p1, *p2;\ninline char getChar() { return p1 == p2 && (p2 = (p1 = buf) + fread(buf, 1, BUF, stdin), p1 == p2) ? EOF : *p1++; }\ninline int read() {\n    int f = 0;\n    bool b = 1;\n    char c;\n    while (!isdigit(c = getChar()))\n        if (c == 45)\n            b = 0;\n    do\n        f = f * 10 + (c ^ 48);\n    while (isdigit(c = getChar()));\n    return b ? f : ~f + 1;\n}\n\nconst int maxN = 10003, maxE = 4000003, S = maxN - 2, T = maxN - 1, inf = 0x3f3f3f3f;\nint cntNode;\n\nint h[maxN], cntEdge = 1;\nstruct Edge {\n    int tar, val, nxt;\n    Edge() {}\n    Edge(int tar, int val, int nxt) : tar(tar), val(val), nxt(nxt) {}\n}ed[maxE];\ninline void addEdge(int x, int y, int z) { ed[++cntEdge] = Edge(y, z, h[x]), h[x] = cntEdge, ed[++cntEdge] = Edge(x, 0, h[y]), h[y] = cntEdge; }\n\nint cur[maxN], dep[maxN];\nqueue<int> que;\ninline bool bfs() {\n    int i, x, y;\n    memset(dep + 1, 0, sizeof(int) * cntNode), memcpy(cur + 1, h + 1, sizeof(int) * cntNode), cur[S] = h[S], dep[S] = 1, dep[T] = 0, que.push(S);\n    while (!que.empty()) {\n        x = que.front(), que.pop();\n        for (i = h[x]; i; i = ed[i].nxt)\n            if (ed[i].val && !dep[y = ed[i].tar])\n                dep[y] = dep[x] + 1, que.push(y);\n    }\n    return dep[T];\n}\nint dfs(int x, int flow) {\n    if (x == T)\n        return flow;\n    int res = flow, k, i, y;\n    for (i = cur[x]; i && res; i = ed[i].nxt) {\n        cur[x] = i;\n        if (ed[i].val && dep[y = ed[i].tar] == dep[x] + 1 && (k = dfs(y, min(res, ed[i].val))))\n            res -= k, ed[i].val -= k, ed[i ^ 1].val += k;\n    }\n    return flow - res;\n}\n\ninline int Dinic() {\n    int maxFlow = 0, k;\n    while (bfs())\n        while ((k = dfs(S, inf)))\n            maxFlow += k;\n    return maxFlow;\n}\n\nconst int maxL = 10000003, lim = 1e7;\nint prime[maxL];\nbool notP[maxL];\n\nbool flag[maxL];\nint pos[maxN], ind[maxN];\ninline int absolute(int x) { return x >= 0 ? x : ~x + 1; }\n\nint main() {\n    int n = read(), cntP = 0, i, j;\n    for (i = 2; i <= lim; ++i) {\n        if (!notP[i])\n            prime[++cntP] = i;\n        for (j = 1; j <= lim && i * prime[j] <= lim; ++j) {\n            notP[i * prime[j]] = 1;\n            if (i % prime[j] == 0)\n                break;\n        }\n    }\n    \n    for (i = 1; i <= n; ++i)\n        flag[read()] = 1;\n    for (i = 1; i <= lim; ++i)\n        if (flag[i] ^ flag[i - 1])\n            pos[++cntNode] = i;\n    notP[1] = 1;\n    for (i = 1; i <= cntNode; ++i) {\n        if (pos[i] & 1) {\n            for (j = 1; j <= cntNode; ++j)\n                if (!(pos[j] & 1) && (!notP[absolute(pos[i] - pos[j])]))\n                    addEdge(i, j, 1);\n            addEdge(S, i, 1);\n        }\n        else\n            addEdge(i, T, 1);\n        ind[i] = cntEdge ^ 1;\n    }\n    int ans = Dinic(), tax[2];\n    tax[0] = tax[1] = 0;\n    for (i = 1; i <= cntNode; ++i)\n        if (ed[ind[i]].val)\n            ++tax[pos[i] & 1];\n    ans += (((tax[0] >> 1) + (tax[1] >> 1)) << 1) + ((tax[0] & 1) | (tax[1] & 1)) * 3;\n    \n    printf(\"%d\\n\", ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nbool bo[10001000],vis[410];\nint st[410],mp[410][410],part[410],top,js0,js1;\nbool isprime(int p)\n{\n\tif ((p<=2)||(!(p&1))) return false;\n\tfor (int i=2;i*i<=p;i++) if (p%i==0) return false;\n\treturn true;\n}\nbool search(int s)\n{\n\tvis[s]=true;\n\tfor (int i=1;i<=top;i++) if (mp[s][i])\n\t{\n\t\tif (!part[i]) {part[i]=s;return true;}\n\t\telse if ((!vis[i])&&(search(part[i]))) {part[i]=s;return true;}\n\t}\n\treturn false;\n}\nint main()\n{\n\tint n;scanf(\"%d\",&n);\n\tfor (int i=1;i<=n;i++) {int w;scanf(\"%d\",&w);bo[w]=true;}\n\tfor (int i=1;i<=10000001;i++) if (bo[i]^bo[i-1]) {st[++top]=i;if (i&1) js1++;else js0++;}\n\tfor (int i=1;i<=top;i++) if (st[i]&1)\n\tfor (int j=1;j<=top;j++) if (isprime(abs(st[i]-st[j]))) mp[i][j]=1;\n\tint sum=0;\n\tfor (int i=1;i<=top;i++) if (st[i]&1)\n\t{\n\t\tmemset(vis,0,sizeof(vis));\n\t\tsum+=search(i);\n\t}\n\tjs0-=sum;js1-=sum;\n\tcout<<sum+js0+js1+(js0&js1&1)<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> odd, even;\nvector<int> prime_Lst;\n\ntemplate<typename T>\nclass Maxflow\n{\n    struct edge { int to; T cap; int rev; };\n    std::vector<std::vector<edge> > edges;\n    std::vector<int> level;\n    std::vector<int> iter;\n    std::vector<int> used;\n\n    void bfs(int s)\n    {\n        level = std::vector<int>(edges.size(), -1);\n        std::queue<int> q;\n        level[s] = 0;\n        q.push(s);\n        while (!q.empty())\n        {\n            int v = q.front();\n            q.pop();\n            for (edge &e : edges[v])\n            {\n                if (e.cap > 0 && level[e.to] < 0)\n                {\n                    level[e.to] = level[v] + 1;\n                    q.push(e.to);\n                }\n            }\n        }\n    }\n\n    T dfs_d(int v, int goal, T f)\n    {\n        if (v == goal) return f;\n        for (int &i = iter[v]; i < (int)edges[v].size(); i++)\n        {\n            edge &e = edges[v][i];\n            if (e.cap > 0 && level[v] < level[e.to])\n            {\n                T d = dfs_d(e.to, goal, std::min(f, e.cap));\n                if (d > 0)\n                {\n                    e.cap -= d;\n                    edges[e.to][e.rev].cap += d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n\n    T dfs_ff(int v, int goal, T f)\n    {\n        if (v == goal) return f;\n        used[v] = true;\n        for (int i = 0; i < (int)edges[v].size(); i++)\n        {\n            edge &e = edges[v][i];\n            if (e.cap > 0 && !used[e.to])\n            {\n                T d = dfs_ff(e.to, goal, std::min(f, e.cap));\n                if (d > 0)\n                {\n                    e.cap -= d;\n                    edges[e.to][e.rev].cap += d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n\npublic:\n    Maxflow(int N) { edges.resize(N); }\n    void add_edge(int from, int to, T capacity)\n    {\n        edges[from].push_back(edge{to, capacity, (int)edges[to].size()});\n        edges[to].push_back(edge{from, (T)0, (int)edges[from].size() - 1});\n    }\n\n    T Dinic(int s, int t)\n    {\n        constexpr T INF = std::numeric_limits<T>::max();\n        T flow = 0;\n        while (true)\n        {\n            bfs(s);\n            if (level[t] < 0) return flow;\n            iter = std::vector<int>(edges.size(), 0);\n            T f;\n            while ((f = dfs_d(s, t, INF)) > 0) flow += f;\n        }\n    }\n\n    T FF(int s, int t)\n    {\n        constexpr T INF = std::numeric_limits<T>::max();\n        T flow = 0;\n        while (true)\n        {\n            used = std::vector<int>(edges.size(), 0);\n            T f = dfs_ff(s, t, INF);\n            if (f == 0) return flow;\n            flow += f;\n        }\n    }\n};\n\nvoid find_prime(int t)\n{\n    vector<bool> ok(t+1, true);\n    ok[0] = ok[1] = false;\n    for (int i=2; i*i<=t; i++)\n    {\n        if (ok[i] && i>2) prime_Lst.push_back(i);\n        for (int j=i; j<=t; j += i) ok[j] = false;\n    }\n}\n\nint main()\n{\n    int len;\n    cin >> len;\n    int tmp = -1;\n    for (int i=0; i<len; i++)\n    {\n        cin >> tmp;\n        if (tmp&1)\n        {\n            if (odd.size() == 0 || odd.back() != tmp)\n            {\n                odd.push_back(tmp);\n            }\n            else\n            {\n                odd.pop_back();\n            }\n            even.push_back(tmp+1);\n        }\n        else\n        {\n            if (even.size() == 0 || even.back() != tmp)\n            {\n                even.push_back(tmp);\n            }\n            else\n            {\n                even.pop_back();\n            }\n            odd.push_back(tmp+1);\n        }\n    }\n\n    find_prime(len);\n\n    int N = odd.size(), M = even.size();\n    Maxflow<int> flow(1+N+M+1);\n    for (int i=1; i<=N; i++) flow.add_edge(0, i, 1);\n    for (int i=1; i<=M; i++) flow.add_edge(N+i, 1+N+M, 1);\n    for (int i=1; i<=N; i++)\n    {\n        for (int j=1; j<=M; j++)\n        {\n            if (binary_search(prime_Lst.begin(), prime_Lst.end(), abs(odd[i-1] - even[j-1]))) flow.add_edge(i, N+j, 1);\n        }\n    }\n    int res = flow.FF(0, 1+N+M);\n    N -= res; M -= res;\n    \n    res += N+M;\n    if (N&1) res++;\n    cout << res << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define reg register\n#define pr std::pair<int, int>\n#define fi first\n#define se second\n#define FIN(s) freopen(s, \"r\", stdin)\n#define FOUT(s) freopen(s, \"w\", stdout)\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define rep(i, l, r) for (int i = l; i <= r; ++i)\n#define lep(i, l, r) for (int i = l; i < r; ++i)\n#define irep(i, r, l) for (int i = r; i >= l; --i)\n#define ilep(i, r, l) for (int i = r; i > l; --i)\n#define Rep(i, n) rep(i, 1, n)\n#define Lep(i, n) lep(i, 1, n)\n#define IRep(i, n) irep(i, n, 1)\n#define ILep(i, n) ilep(i, n, 1)\ntypedef long long ll;\ntypedef long double ld;\n\nnamespace modular {\n    const int MOD = 1000000007;\n    inline int add(int x, int y) { return (x += y) >= MOD ? x -= MOD : x; }\n    inline void inc(int &x, int y) { (x += y) >= MOD ? x -= MOD : 0; }\n    inline int mul(int x, int y) { return 1LL * x * y % MOD; }\n    inline int qpow(int x, int y) {\n        int ans = 1;\n        for (; y; y >>= 1, x = mul(x, x))\n            if (y & 1)\n                ans = mul(ans, x);\n        return ans;\n    }\n}; // namespace modular\n\nnamespace Base {\n    template <typename Tp> inline Tp input() {\n        Tp x = 0, y = 1;\n        char c = getchar();\n        while ((c < '0' || '9' < c) && c != EOF) {\n            if (c == '-')\n                y = -1;\n            c = getchar();\n        }\n        if (c == EOF)\n            return 0;\n        while ('0' <= c && c <= '9')\n            x = x * 10 + c - '0', c = getchar();\n        return x *= y;\n    }\n    template <typename Tp> inline void read(Tp &x) { x = input<Tp>(); }\n    template <typename Tp> inline void chmax(Tp &x, Tp y) { x < y ? x = y : 0; }\n    template <typename Tp> inline void chmin(Tp &x, Tp y) { x > y ? x = y : 0; }\n}; // namespace Base\nusing namespace Base;\n/*----------------------------------------------------------------------------*/\n\n#define MAX_N 207\n#define MAX_P 10000007\n\nint N, res;\nint a[MAX_N], b[MAX_N];\nint pri[MAX_P / 10], tot;\nint match[MAX_N];\nbool check[MAX_P], con[MAX_N][MAX_N], vis[MAX_N];\n\nvoid sieve(int n) {\n    rep(i, 2, n) {\n        if (!check[i]) pri[++tot] = i;\n        Rep(j, tot) {\n            if (i * pri[j] > n) break;\n            check[i * pri[j]] = true;\n            if (i % pri[j] == 0) break;\n        }\n    }\n    check[2] = check[1] = 1;\n}\n\nbool dfs(int x) {\n    Rep(j, N) if (con[x][j] && !vis[j]) {\n        vis[j] = true;\n        if (!match[j] || dfs(match[j])) {\n            match[j] = x;\n            return true;\n        }\n    }\n    return false;\n}\n\nvoid solve() {\n    int top = 0;\n    std::sort(a + 1, a + N + 1);\n    a[0] = -1, a[N + 1] = 0;\n    Rep(i, N) {\n        if (a[i - 1] != a[i] - 1) b[++top] = a[i];\n        if (a[i] + 1 != a[i + 1]) b[++top] = a[i] + 1;\n    }\n    N = top;\n    Rep(i, N) a[i] = b[i];\n    // Rep(i, N) printf(\"%d \", a[i]); puts(\"\");return;\n    Rep(i, N) if (a[i] & 1) {\n        Rep(j, N) if (a[j] % 2 == 0 && !check[std::abs(a[i] - a[j])]) con[i][j] = true;\n    }\n    Rep(i, N) if (a[i] & 1) {\n        Rep(j, N) vis[j] = false;\n        res += dfs(i);\n    }\n    Rep(i, N) vis[i] = false;\n    Rep(i, N) if (a[i] % 2 == 0 && match[i]) vis[i] = vis[match[i]] = true;\n    int cnt[2] = {0};\n    Rep(i, N) if (!vis[i]) cnt[a[i] & 1]++;\n    res += 2 * (cnt[0] / 2 + cnt[1] / 2);\n    if (cnt[0] & 1) res += 3;\n    printf(\"%d\\n\", res);\n}\n\nint main() {\n    read(N);\n    int mx = 0;\n    Rep(i, N) read(a[i]), chmax(mx, a[i]);\n    sieve(mx);\n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pp;\ntypedef pair<ll,ll> pll;\nvoid read(int& x){ scanf(\"%d\",&x); }\nvoid read(ll& x){ scanf(\"%lld\",&x); }\ntemplate<typename T,typename... Args>\nvoid read(T& a,Args&... b){ read(a); read(b...); }\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define eb emplace_back\n#define x first\n#define y second\n \nint n;\nint p[210];\n \nvoid in(){\n\tint t; read(t);\n\tint last;\n\tread(last);\n\tp[++n] = last;\n\tfor(;--t;){\n\t\tint x; read(x);\nassert(last < x);\n\t\tif(last+1 < x){\n\t\t\tp[++n] = last+1;\n\t\t\tp[++n] = x;\n\t\t}\n\t\tlast = x;\n\t}\n\tp[++n] = last+1;\n}\n \nbool is_prime(int x){\n\tif(x==1) return 0;\n\tif(x==2) return 0;\n\tfor(int i=2; i*i<=x; ++i) if(x%i==0) return 0;\n\treturn 1;\n}\nvector<int>edge[210];\nint vis[210];\nint rev[210];\n \nbool dfs(int x){\n\tif(vis[x]) return 0;\n\tvis[x]=1;\n\tfor(int y:edge[x]){\n\t\tif(!rev[y] || dfs(rev[y])){\n\t\t\trev[y]=x;\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n \nbool aug(){\n\tfor(int i=1; i<=n; ++i){\n\t\tfill(vis+1, vis+n+1, 0);\n\t\tif(dfs(i)) return 1;\n\t}\n\treturn 0;\n}\n \nint main()\n{\n\tin();\n\tint oc=0, ec=0;\n\tfor(int i=1; i<=n; ++i){\n\t\t((p[i]%2)?oc:ec)++;\n\t\tfor(int j=i+1; j<=n; ++j){\n\t\t\tif(is_prime(p[j]-p[i])){\n\t\t\t\tint a=i, b=j;\n\t\t\t\tif(p[a]%2) swap(a, b);\n//assert(p[a] % 2 != p[b] % 2);\n\t\t\t\tedge[a].pb(b);\n\t\t\t}\n\t\t}\n\t}\n\tint mm = 0;\n\twhile(aug()) ++mm;\n//assert(oc %2 == ec %2);\n//assert(mm <= oc);\n//assert(mm <= ec);\n\tint ans = 2e9;\n\tfor(int pu=0; pu<=mm; ++pu){\n\t\tint cur = 0;\n\t\tcur += (oc-pu)/2*2;\n\t\tcur += (ec-pu)/2*2;\n\t\tcur += ((oc-pu)%2)*((ec-pu)%2)*3;\n\t\tcur += pu;\n\t\tans = min(ans, cur);\n\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<cstring>\nusing namespace std;\nint n;\nint res;\nvector<int>v;\nint lst=-1;\nint match[210];\nint me,mo;\nint mx;\nbool f[10000010];\nvector<int>ok[210];\nbool vis[210];\nint prm[1000010];\nint sz;\nint l;\nbool bp(int x)\n{\n\tfor(int i=0;i<ok[x].size();i++)\n\t{\n\t\tint y=ok[x][i];\n\t\tif(vis[y])continue;\n\t\tvis[y]=true;\n\t\tif(match[y]==x)continue;\n\t\tif(match[y]==-1 || bp(match[y]))\n\t\t{\n\t\t\tmatch[y]=x;\n\t\t\tmatch[x]=y;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint x;\n\t\tscanf(\"%d\",&x);\n\t\tif(x!=lst+1)\n\t\t{\n\t\t\tif(lst+1)v.push_back(lst+1);\n\t\t\tv.push_back(x);\n\t\t}\n\t\tlst=x;\n\t\tmx=lst+1;\n\t}\n\tv.push_back(lst+1);\n\tf[1]=true;\n\tfor(int i=2;i<=mx;i++)\n\t{\n\t\tif(!f[i])prm[++sz]=i;\n\t\tfor(int j=1;j<=sz;j++)\n\t\t{\n\t\t\tif(prm[j]*i>mx)break;\n\t\t\tf[prm[j]*i]=true;\n\t\t\tif(i%prm[j]==0)break;\n\t\t}\n\t}\n\tl=v.size();\n\tfor(int i=0;i<l;i++)\n\t{\n\t\tmatch[i]=-1;\n\t\tif(v[i]&1)mo++;else me++;\n\t\tfor(int j=i+1;j<l;j++)\n\t\t{\n\t\t\tif(v[j]-v[i]!=2 && !f[v[j]-v[i]])\n\t\t\t{\n\t\t\t\tok[i].push_back(j);\n\t\t\t\tok[j].push_back(i);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<l;i++)\n\t{\n\t\tmemset(vis,false,sizeof(vis));\n\t\tvis[i]=true;\n\t\tif(bp(i))res++;\n\t}\n\tres/=2;\n\tprintf(\"%d\",res+((me-res)/2+(mo-res)/2)*2+((me-res)%2)*3);\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define maxn 205\n#define maxp 10000007\nusing namespace std;\n\nint a[maxn],cnt,n;\nint pr[maxp],vis[maxp],cnt_pr;\nint usd[maxn],mat[maxn];\n\nint dfs(int u){\n\tfor(int i=1;i<=cnt;i++) if(vis[abs(a[u]-a[i])] == 0 && !usd[i]){\n\t\tusd[i] = 1;\n\t\tif(!mat[i] || dfs(mat[i])){\n\t\t\tmat[i] = u , mat[u] = i;\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nint main(){\n\tfor(int i=2;i<maxp;i++){\n\t\tif(!vis[i]) pr[cnt_pr++] = i;\n\t\tfor(int j=0;pr[j]*i<maxp;j++){\n\t\t\tvis[i*pr[j]] = 1;\n\t\t\tif(i % pr[j] == 0) break;\n\t\t}\n\t}\n\tvis[2] = vis[0] = vis[1] = 1;\n\tscanf(\"%d\",&n);\n\tint p = -10;\n\tfor(int i=1;i<=n;i++){int x;\n\t\tscanf(\"%d\",&x);\n\t\tif(x != p + 1){\n\t\t\tif(p>0)a[++cnt] = p + 1;\n\t\t\ta[++cnt] = x;\n\t\t}\n\t\tp = x;\n\t}\n\ta[++cnt] = p+1;\n\tint s[2] = {};\n\tfor(int i=1;i<=cnt;i++) assert(a[i] > 0) , s[a[i] % 2] ++;\n\tint ans = 0;\n\tfor(int i=1;i<=cnt;i++) if(a[i]%2 && !mat[i]) memset(usd,0,sizeof usd),ans += dfs(i);\n\tans += 2 * ((s[0] - ans) / 2 + (s[1] - ans) / 2);\n\tans += 3 * ((s[0] - ans) % 2 && (s[1] - ans) % 2);\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <climits>\n#include <queue>\n#include <algorithm>\n\nusing std::queue;\nusing std::min;\n\nconst int MAXX=1e7+5,MAXN=105;\nint n,cnt_x,cnt_y;\nint x_id[MAXN],y_id[MAXN];\nbool up[MAXX];\n\nstruct node{int he,iter,dis;}d[MAXN];\nstruct line{int to,nex,cap;}ed[MAXN*MAXN];\n\ninline bool is_odd_prm(int x){\n\tif(x==2) return false;\n\tfor(int i=3;i*i<=x;i+=2){\n\t\tif(x%i==0) return false;\n\t}\n\treturn true;\n}\n\ninline void addE(int u,int v,int cap){\n\tstatic int cnt=1;\n\ted[++cnt]=(line){v,d[u].he};\n\td[u].he=cnt;\n}\n\ninline int revE(int i){return i^1;}\n\ninline bool BFS(int s,int t,int n){\n\tfor(int i=1;i<=n;++i)\n\t\td[i].dis=-1;\n\tstatic queue<int> q;\n\td[s].dis=0;\n\tq.push(s);\n\tint u;\n\twhile(q.size()){\n\t\tu=q.front();\n\t\tq.pop();\n\t\tfor(int i=d[u].he,v;i;i=ed[i].nex){\n\t\t\tif(ed[i].cap==0) continue;\n\t\t\tv=ed[i].to;\n\t\t\tif(d[v].dis==-1){\n\t\t\t\td[v].dis=d[u].dis+1;\n\t\t\t\tq.push(v);\n\t\t\t}\n\t\t}\n\t}\n\treturn d[t].dis!=-1;\n}\n\nint aug(int u,int rest,const int t){\n\tif(u==t) return rest;\n\tint ret=0;\n\tfor(int &i=d[u].iter,v,cap,flow;i;i=ed[i].nex){\n\t\tv=ed[i].to,cap=ed[i].cap;\n\t\tif(d[v].dis!=d[u].dis+1 || cap==0)\n\t\t\tcontinue;\n\t\tflow=aug(v,min(cap,rest),t);\n\t\ted[i].cap-=flow,ed[revE(i)].cap+=flow;\n\t\tret+=flow;\n\t\tif(ret==rest) return ret;\n\t}\n\tif(ret==0) d[u].dis=-1;\n\treturn ret;\n}\n\ninline int Dinic(int s,int t,int n){\n\tint ret=0;\n\twhile(BFS(s,t,n)){\n\t\tfor(int i=1;i<=n;++i)\n\t\t\td[i].iter=d[i].he;\n\t\tret+=aug(s,INT_MAX,t);\n\t}\n\treturn ret;\n}\n\ninline void build(){\n\tfor(int i=1;i<=cnt_x;++i){\n\t\tfor(int j=1,v;j<=cnt_y;++j){\n\t\t\tif(is_odd_prm(abs(x_id[i]-y_id[j]))){\n\t\t\t\tv=j+cnt_x;\n\t\t\t\taddE(i,v,INT_MAX),addE(v,i,0);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=1,s=cnt_x+cnt_y+1;i<=cnt_x;++i)\n\t\taddE(s,i,1),addE(i,s,0);\n\tfor(int i=1,t=cnt_x+cnt_y+2;i<=cnt_y;++i)\n\t\taddE(i,t,1),addE(t,i,0);\n}\n\nint main(){\n\tscanf(\"%d\",&n);\n\tint x;\n\tfor(int i=1;i<=n;++i){\n\t\tscanf(\"%d\",&x);\n\t\tup[x]=true;\n\t}\n\tfor(int i=1;i<=x+1;++i){\n\t\tif(up[i]!=up[i-1])\n\t\t\ti&1 ? x_id[++cnt_x]=i:y_id[++cnt_y]=i;\n\t}\n\tbuild();\n\tint k=Dinic((cnt_x+cnt_y)|1,cnt_x+cnt_y+2,cnt_x+cnt_y+2);\n\tprintf(\"%d\",k+((((cnt_x-k)>>1)+((cnt_y-k)>>1))<<1)+(cnt_x-k)%2*3);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define fi first\n#define se second\n#define mp make_pair\n#define gc getchar\n#define pb push_back\n#define eb emplace_back\n#define all(x) (x).begin(),(x).end()\n#define x1 uvuvwevwevwe\n#define y1 onyetenyevwe\n#define x2 ugwemubwem\n#define y2 ossas\ntypedef long long LL;\ntypedef long double LD;\ntypedef pair<int,int> pii;\nconst int batasprima=100000;\ntemplate <typename T> void scan(T &angka){\n\tangka=0;char input=gc();T kali=1;\n\twhile(!(48<=input&&input<=57)){\tif(input=='-')\tkali=-1;input=gc();}\n\twhile(48<=input&&input<=57)\tangka=(angka<<3)+(angka<<1)+input-48,input=gc();angka*=kali;\n}\ntemplate <typename T1,typename T2> void scan(T1 &angka1,T2 &angka2){\n\tscan(angka1);scan(angka2);\n}\nint match[205],k,ans;\nvector <int> daftar,adj[205],prime;\nbitset<205> visited;\nvoid sieve(){\n\tbool isprime[batasprima+5];\n\tmemset(isprime,true,sizeof(isprime));\n\tfor(int i=2;i<=batasprima;i++)\n\t{\n\t\tif(!isprime[i])\n\t\t\tcontinue;\n\t\tprime.pb(i);\n\t\tfor(int j=i+i;j<=batasprima;j+=i)\n\t\t\tisprime[j]=false;\n\t}\n}\nbool isprime(int angka){\n\tif(angka<2)\n\t\treturn false;\n\tfor(auto isi:prime)\n\t{\n\t\tif(angka%isi==0)\n\t\t\treturn false;\n\t}\n\treturn true;\n}\nbool matching(int pos){\n\tif(visited[pos])\n\t\treturn false;\n\tvisited[pos]=true;\n\tfor(auto isi:adj[pos])\n\t{\n\t\tif(match[isi]==-1||matching(match[isi]))\n\t\t{\n\t\t\tmatch[isi]=pos;\n\t\t\tmatch[pos]=isi;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\nvoid buatgraph(){\t\n\tfor(int i=0;i<daftar.size();i++)\n\t{\n\t\tfor(int j=0;j<daftar.size();j++)\n\t\t{\n\t\t\tif(isprime(abs(daftar[i]-daftar[j])))\n\t\t\t\tadj[i].pb(j);\n\t\t}\n\t}\n}\nvoid hitungk(){\n\tk=0;\n\tmemset(match,-1,sizeof(match));\n\tfor(int i=0;i<daftar.size();i++)\n\t{\n\t\tif(match[i]!=-1)\n\t\t\tcontinue;\n\t\tvisited.reset();\n\t\tif(matching(i))\n\t\t\tk++;\n\t}\n}\nvoid hitungans(){\n\tint genap=0,ganjil=0;\n\tfor(auto isi:daftar)\n\t{\n\t\tif(isi&1)\n\t\t\tganjil++;\n\t\telse\n\t\t\tgenap++;\n\t}\n\tassert(ganjil>=k&&genap>=k);\n\tassert(ganjil%2==genap%2);\n\tans=k+((ganjil-k)/2+(genap-k)/2)*2+((ganjil-k)%2)*3;\n}\nvoid isidaftar(){\n\tint n,tadi=0;\n\tscan(n);\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tint input;\n\t\tscan(input);\n\t\tassert(tadi<input);\n\t\ttadi=input;\n\t\tif(daftar.size()&&daftar.back()==input)\n\t\t\tdaftar[daftar.size()-1]=input+1;\t\t\t//nanti mau sa coba\n\t\telse\n\t\t\tdaftar.pb(input),daftar.pb(input+1);\n\t}\n\tassert(daftar.size()<=200);\n}\nint main()\n{\n\tsieve();\n\tisidaftar();\n\tbuatgraph();\n\thitungk();\n\thitungans();\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef double db;\ntypedef long long ll;\n#define w1 first\n#define w2 second\n#define ls (x<<1)\n#define rs (x<<1|1)\n#define pb push_back\n#define mid ((l+r)>>1)\n#define SZ(x) ((x).size())\n#define All(x) (x).begin(),(x).end()\n#define rep(i,a,b) for(int (i)=(a);(i)<=(b);(i)++)\n#define rep2(i,a,b) for(int (i)=(a);(i)<(b);(i)++)\n#define per(i,a,b) for(int (i)=(a);(i)>=(b);(i)--)\n#define Rep(p,x) for(int (p)=head[(x)];(p);(p)=nxt[(p)])\ntemplate<class T>void read(T&num){\n\tnum=0;T f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9')num=num*10+ch-'0',ch=getchar();\n\tnum*=f;\n}\nint power(int x,int k,int p){int res=1;for(;k;k>>=1,x=1ll*x*x%p)if(k&1)res=1ll*res*x%p;return res;}\nconst int maxn=1e3+5;\nint n,m;\nint q[maxn],x[maxn],f[maxn];\nint main(){\n\tread(n);\n\trep(i,1,n)read(x[i]);\n\tq[m=1]=1;\n\trep(i,2,n){\n\t\tif(x[i]==x[i-1]+1)q[m]++;\n\t\telse q[++m]=x[i]-x[i-1]-1,q[++m]=1;\n\t}\n\tmemset(f,127,sizeof f);\n\tf[0]=0;\n\trep(i,1,m)if(i&1){\n\t\trep(j,0,i-1)if(!(j&1)){\n\t\t\tint ans=0,tot=0;\n\t\t\trep(k,j+1,i){\n\t\t\t\tif(k&1)ans+=2+(q[k]&1);\n\t\t\t\ttot+=q[k];\n\t\t\t}\n\t\t\tf[i]=min(f[i],f[j]+ans);\n\t\t\tans=2+(tot&1);\n\t\t\trep(k,j+1,i)if(!(k&1))ans+=2+(q[k]&1);\n\t\t\tf[i]=min(f[i],f[j]+ans);\n\t\t}\n\t}else f[i]=f[i-1];\n\tprintf(\"%d\\n\",f[m]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\nbool so[10000001];\nint main(){\n  int n,x[100];\n  cin>>n;\n  for(int i=2;i*i<=1e7;i++)\n    if(!so[i])for(int j=2;i*j<=1e7;j++)so[j*i]=1;\n  \n  for(int i=0;i<n;i++)cin>>x[i];\n  \n  int ans=1,y=x[n-1]-x[0]+1;\n  if(so[y]||y==2){\n    if(y%2)ans+=2;\n    else ans++;\n  }\n  \n  for(int i=0;i<n-1;i++){\n    int t=x[i+1]-x[i]-1;\n    if(!t)continue;\n    if(t%2){\n      if(so[t]||t==1)ans+=3;\n      else ans++;\n    }else ans+=2;\n  }\n  cout<<ans<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nbool bo[10000010];\nint f[2010][2010],n,a[1010];\n\nint calc(int x) {return (x==0)?0:((x&1)?(bo[x]?3:1):2);}\n\nint main()\n{\n\tbo[1]=1;\n\tfor (int i=2; i<=10000000; i++) if (!bo[i])\n\t\tfor (int j=(i<<1); j<=10000000; j+=i) bo[j]=1;\n\tscanf(\"%d\",&n);\n\tfor (int i=1; i<=n; i++) scanf(\"%d\",&a[i]);\n\tfor (int i=0; i<=2*n-1; i++)\n\t\tfor (int j=0; j<=2*n-1; j++) f[i][j]=1000000000;\n\tsort(a+1,a+1+n),f[1][0]=0,f[0][0]=f[1][1]=3;\n\tfor (int i=2; i<=n; i++)\n\t{\n\t\tfor (int j=0; j<=2*i-3; j++)\n\t\t{\n\t\t\tf[i*2-1][j]=min(f[i*2-1][j],f[i*2-3][j]+calc(a[i]-a[i-1]-1)),\n\t\t\tf[i*2-2][j]=min(f[i*2-2][j],f[i*2-3][j]+calc(a[i]-a[i-1])),\n\t\t\tf[i*2-1][i*2-2]=min(f[i*2-1][i*2-2],f[i*2-3][j]+calc(a[i-1]-a[1+(j>>1)]+(1^(j&1)))),\n\t\t\tf[i*2-1][i*2-1]=min(f[i*2-1][i*2-1],f[i*2-3][j]+calc(a[i]-a[i-1]-1)+calc(a[i]-a[1+(j>>1)]+(1^(j&1)))),\n\t\t\tf[i*2-1][i*2-1]=min(f[i*2-1][i*2-1],f[i*2-3][j]+calc(a[i]-a[i-1])+calc(a[i]-a[1+(j>>1)]+(1^(j&1))-1));\n\t\t\tif (j!=2*i-3)\n\t\t\t{\n\t\t\t\tf[i*2-1][j]=min(f[i*2-1][j],f[i*2-4][j]+calc(a[i]-a[i-1])),\n\t\t\t\tf[i*2-2][j]=min(f[i*2-2][j],f[i*2-4][j]+calc(a[i]-a[i-1]+1)),\n\t\t\t\tf[i*2-1][i*2-2]=min(f[i*2-1][i*2-2],f[i*2-4][j]+calc(a[i-1]-a[1+(j>>1)]+(1^(j&1))-1)),\n\t\t\t\tf[i*2-1][i*2-1]=min(f[i*2-1][i*2-1],f[i*2-4][j]+calc(a[i]-a[i-1])+calc(a[i]-a[1+(j>>1)]+(1^(j&1)))),\n\t\t\t\tf[i*2-1][i*2-1]=min(f[i*2-1][i*2-1],f[i*2-4][j]+calc(a[i]-a[i-1]+1)+calc(a[i]-a[1+(j>>1)]+(1^(j&1))-1));\n\t\t\t}\n\t\t}\n\t\tf[i*2-2][i*2-2]=f[i*2-1][i*2-1]=min(f[i*2-1][i*2-1],f[i*2-2][i*2-2]+3);\n\t}\n\tprintf(\"%d\\n\",f[n*2-1][n*2-1]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#include<bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n\n#define F first\n#define S second\n#define int long long\n#define ll long long\n//#define int  unsigned long long\n#define pb push_back\n//#define double long double\n\nusing namespace std;\nusing namespace __gnu_pbds;\ntypedef  tree< int , null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> ordered_set;\nconst int mod = 1e9 + 7;\nconst int N = 1000;\nstruct Edge {\n    int from, to, f, c, w;\n};\nvector < Edge >  edges;\nvector < int > g[N];\nint n, d[N], f[N], b[N][N];\nint p[N];\nvoid add(int a, int b, int c, int w){\n    Edge e;\n    e.from = a; e.to = b; e.c = c; e.w = w; e.f = 0;\n    edges.pb(e);\n  //  cout << a << \" \" << b << \" \" << c << \" \" << w << endl;\n    g[a].pb(edges.size() - 1);\n    e.w = -e.w; e.c = 0; swap(e.from, e.to);\n    edges.pb(e);\n    g[b].pb(edges.size() - 1);\n}\nbool spfa(int s, int t){\n    for (int i = 1; i < N; i++){\n        d[i] = 1e9;\n        f[i] = 0;\n    }\n    queue < int > q;\n    q.push(s);\n    d[s] = 0;\n    f[s] = 1;\n    while(!q.empty()){\n        int v = q.front();\n        q.pop();\n        f[v] = 0;\n        for (int i = 0; i < g[v].size(); i++){\n            Edge e = edges[g[v][i]];\n            if (e.f < e.c && d[e.to] > d[v] + e.w){\n                p[e.to] = g[v][i];\n                d[e.to] = d[v] + e.w;\n                if (!f[e.to])\n                    q.push(e.to);\n                f[e.to] = 1;\n            }\n        }\n    }\n    return d[t] != 1e9;\n}\nint flow(int s, int t){\n    int cost = 0;\n    while(spfa(s, t)){\n        int v = t;\n        while(v != s && v != 0){\n            auto k = p[v];\n            edges[k].f++;\n            edges[k ^ 1].f--;\n            cost += edges[k].w;\n            v = edges[k].from;\n        }\n    }\n    return cost;\n}\nint mx[N], mn[N];\nint ff(int x){\n    if (x == 2) return 2;\n    if (x == 1) return 3;\n    int pr = 1;\n    for (int i = 2; i * i <= x; i++){\n        if (x % i == 0) pr = 0;\n    }\n    if (pr) return 1;\n    return 2 + (x % 2);\n}\nint usedd[N];\nvector < int > gr[N];\nvoid dfss(int v){\n    usedd[v] = 1;\n    for (auto u: gr[v]){\n        if (usedd[u]) continue;\n        dfss(u);\n    }\n}\nmain(){\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    //freopen(\"input.txt\", \"r\", stdin);\n    cin >> n;\n    int p = -1;\n    vector < int > a;\n    for (int i = 1; i <= n; i++){\n        int x;\n        cin >> x;\n        if (x != p + 1){\n            if (p != -1) a.pb(p + 1);\n            a.pb(x);\n        }\n        p = x;\n    }\n    a.pb(p + 1);\n    n = a.size();\n    int cnt = 0;\n    for (int i = 0; i < a.size(); i++){\n        add(2 * n + 1, i + 1, 1, 0);\n        add(n + i + 1, 2 * n + 2, 1, 0);\n        if (a[i] % 2) cnt++;\n        for (int j = i + 1; j < a.size(); j++){\n            if (i == j) continue;\n            int x = a[i];\n            int y = a[j];\n            if (ff(abs(x - y)) == 1){\n                if (x % 2 == 0)\n                add(i + 1, n + j + 1, 1, 1); else\n                add(j + 1, n + i + 1, 1, 1);\n            }\n            if (ff(abs(x - y)) != 3){\n                gr[i + 1].pb(j + 1);\n                gr[j + 1].pb(i + 1);\n            }\n        }\n    }\n    n = 2 * n + 2;\n    int ans = flow(n - 1, n);\n    dfss(1);\n    int k = 0;\n    n = (n - 2) / 2;\n    if ((cnt - ans) % 2){\n        ans = ans + (n - 2 * ans) + 1;\n    } else{\n        ans = ans + (n - 2 * ans);\n    }\n    cout << ans;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\nconst int MAX1=100;\nconst int MAX2=10000000;\nconst int INF=0x3f3f3f3f;\nint n,a[MAX1+5],p[MAX2+5],chk[MAX1*2+5],ans;\nvector<int> cx,c[2],seq;\nvector<pii> conn[2*MAX1+5];\nint dfs(int x,int y){\n    int flow=0;\n    if(x==y) return INF;\n    chk[x]=1;\n    for(int i=0;i<conn[x].size();i++) if(chk[conn[x][i].first]==0&&conn[x][i].second>0){\n        int t=dfs(conn[x][i].first,y);\n        if(t>0){\n            flow=min(t,conn[x][i].second);\n            seq.push_back(x);\n            break;\n        }\n    }\n    chk[x]=0;\n    return flow;\n}\nint fflow(int x,int y){\n    seq.clear(); seq.push_back(y);\n    int flow=dfs(x,y);\n    for(int i=0;i<seq.size()-1;i++) {\n        int a=seq[i+1],b=seq[i];\n        for(int j=0;j<conn[a].size();j++) if(conn[a][j].first==b) conn[a][j].second-=flow;\n        for(int j=0;j<conn[b].size();j++) if(conn[b][j].first==a) conn[b][j].second+=flow;\n    }\n    return flow;\n}\nint main(){\n    scanf(\"%d\",&n);\n    for(int i=0;i<n;i++) scanf(\"%d\",&a[i]);\n    cx.push_back(a[0]), cx.push_back(a[0]+1);\n    for(int i=1;i<n;i++){\n        if(cx[cx.size()-1]==a[i]) cx.pop_back();\n        else cx.push_back(a[i]);\n        cx.push_back(a[i]+1);\n    }\n    for(int i=2;i<=MAX2;i++){\n        if(p[i]==0){\n            p[i]=1;\n            if(i<=3163) {for(int j=i*i;j<=MAX2;j+=i) p[j]=-1;}\n        }\n    }\n    p[2]=-1;\n    for(int i=0;i<cx.size();i++) c[cx[i]%2].push_back(cx[i]);\n    for(int i=0;i<c[0].size();i++) for(int j=0;j<c[1].size();j++) if(p[abs(c[0][i]-c[1][j])]==1) {\n        conn[i].push_back(make_pair(c[0].size()+j,1));\n        conn[c[0].size()+j].push_back(make_pair(i,0));\n    }\n    for(int i=0;i<c[0].size();i++) {\n        conn[c[0].size()+c[1].size()].push_back(make_pair(i,1));\n        conn[i].push_back(make_pair(c[0].size()+c[1].size(),0));\n    }\n    for(int i=0;i<c[1].size();i++) {\n        conn[i+c[0].size()].push_back(make_pair(c[0].size()+c[1].size()+1,1));\n        conn[c[0].size()+c[1].size()+1].push_back(make_pair(i+c[0].size(),0));\n    }\n    while(fflow(c[0].size()+c[1].size(),c[0].size()+c[1].size()+1)) ans++;\n    printf(\"%d\\n\",c[0].size()+c[1].size()-ans+(c[0].size()-ans)%2);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nint n,vs[107],xs[207],xp=0;\nstruct edge{\n\tint to,nx,v;\n}e[100007];\nint ep=2,e0[207],h[207],q[207],S,T;\nbool bfs(){\n\tfor(int i=1;i<=T;++i)h[i]=0;\n\tint ql=0,qr=0;\n\th[q[++qr]=S]=1;\n\twhile(ql!=qr){\n\t\tint w=q[++ql];\n\t\tif(w==T)return 1;\n\t\tfor(int i=e0[w];i;i=e[i].nx){\n\t\t\tint u=e[i].to;\n\t\t\tif(!h[u])h[q[++qr]=u]=h[w]+1;\n\t\t}\n\t}\n\treturn 0;\n}\nint dfs(int w,int f){\n\tif(w==T)return f;\n\tint c,used=0;\n\tfor(int i=e0[w];i;i=e[i].nx){\n\t\tint u=e[i].to;\n\t\tif(h[u]!=h[w]+1)continue;\n\t\tc=dfs(u,std::min(e[i].v,f-used));\n\t\te[i].v-=c;\n\t\te[i^1].v+=c;\n\t\tused+=c;\n\t\tif(f==used)return f;\n\t}\n\th[w]=0;\n\treturn used;\n}\nbool isp(int x){\n\tif(x<0)x=-x;\n\tif(x%2==0||x<3)return 0;\n\tfor(int i=3;i*i<=x;i+=2)if(x%i==0)return 0;\n\treturn 1;\n}\nvoid ae(int a,int b){\n\te[ep]=(edge){b,e0[a],1};e0[a]=ep++;\n\te[ep]=(edge){a,e0[b],0};e0[b]=ep++;\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=0;i<n;++i)scanf(\"%d\",vs+i);\n\tfor(int i=0,j=0;i<n;i=j){\n\t\tfor(++j;j<n&&vs[j]-vs[j-1]==1;++j);\n\t\txs[++xp]=vs[i];\n\t\txs[++xp]=vs[j-1]+1;\n\t}\n\tS=xp+1,T=xp+2;\n\tint co=0,ce;\n\tfor(int i=1;i<=xp;++i){\n\t\tif(xs[i]&1){\n\t\t\tae(S,i);\n\t\t\t++co;\n\t\t\tfor(int j=1;j<=xp;++j)if((~xs[j]&1)&&isp(xs[j]-xs[i]))ae(i,j);\n\t\t}else ae(i,T);\n\t}\n\tint ans=0,c2;\n\twhile(bfs())ans+=dfs(S,0x3f3f);\n\tce=xp-co;\n\tco-=ans,ce-=ans;\n\tprintf(\"%d\\n\",ans+ce+co+(co&1));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint N,M;\nconst int MAX_N = 111;\nint a[MAX_N],b[MAX_N*2],sz;\n\nvector<int> path[MAX_N*2];\nbool visit[MAX_N*2];\nint A[MAX_N*2];\n\nbool dfs(int a){\n\tif(visit[a])return false;\n\tvisit[a]=1;\n\tfor(int i=0;i<path[a].size();i++){\n\t\tint b=path[a][i];\n\t\tif(A[b]<0){\n\t\t\tA[b]=a;\n\t\t\treturn true;\n\t\t}else if(dfs(A[A[b]])){\n\t\t\tA[b]=a;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nbool isPrime(int x){\n\tif(x==1)return false;\n\tif(x%2==0)return false; // 2 is exception\n\tfor(int i=3;i*i<=x;i+=2){\n\t\tif(x%i==0)return false;\n\t}\n\treturn true;\n}\n\nint main(){\n\t\n\tscanf(\"%d\",&N);\n\tfor(int i=1;i<=N;i++){\n\t\tscanf(\"%d\",&a[i]);\n\t}\n\ta[0]=-1;\n\ta[N+1]=1e9;\n\n\tint even=0,odd=0;\n\tfor(int i=1;i<=N+1;i++){\n\t\tif(a[i-1]+1<a[i]){\n\t\t\tif(i>1)b[sz++]=a[i-1]+1;\n\t\t\tif(i<=N)b[sz++]=a[i];\n\t\t}\n\t}\n\n\tfor(int i=0;i<sz;i++){\n\t\tif(b[i]%2==0)even++;\n\t\telse odd++;\n\t}\n\n\tfor(int i=0;i<sz;i++){\n\t\tfor(int j=i+1;j<sz;j++){\n\t\t\tif(isPrime(b[j]-b[i])){\n\t\t\t\tpath[i].push_back(j);\n\t\t\t\tpath[j].push_back(i);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int i=0;i<sz;i++){\n\t\tA[i]=-1;\n\t}\n\t\n\tint cnt=0;\n\tfor(int i=0;i<sz;i++){\n\t\tfor(int j=0;j<sz;j++)visit[j]=0;\n\t\tif(dfs(i))cnt++;\n\t}\n\tcnt/=2;\n\n\teven-=cnt;\n\todd-=cnt;\n\tprintf(\"%d\\n\",cnt+(even/2+odd/2)*2+(even%2)*3);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nconst int N=1005,INF=~0u>>2;\nstruct Edge{int nxt,to;}edge[N*N];\nint b[N],n,head[N],num_edge,vis[N],lk[N],even[N],odd[N],even_num,odd_num,ans,k,tot,tim;\nint abs(int x){return x>0?x:-x;}\nvoid add_edge(int from,int to){\n\tedge[++num_edge].nxt=head[from];\n\tedge[num_edge].to=to;\n\thead[from]=num_edge;\n}\nbool find(int x){\n\tfor(int i=head[x];i;i=edge[i].nxt){\n\t\tif(vis[edge[i].to]!=tim){\n\t\t\tvis[edge[i].to]=tim;\n\t\t\tif(!lk[edge[i].to]||find(lk[edge[i].to])){\n\t\t\t\tlk[edge[i].to]=x;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nbool check(int x){\n\tif(x==1) return 0;\n\tfor(int i=2;i*i<=x;++i){\n\t\tif(x%i==0) return 0;\n\t}\n\treturn 1;\n}\nvoid solve(int x){\n\tif(x&1) odd[++odd_num]=x;\n\telse even[++even_num]=x;\n}\nint main(){\n//\tfreopen(\"ex.in\",\"r\",stdin);\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;++i) scanf(\"%d\",&b[i]);b[0]=-1;\n\tfor(int i=1;i<=n;++i){\n\t\tif(b[i]!=b[i-1]+1) solve(b[i]);\n\t\tif(b[i]+1!=b[i+1]) solve(b[i]+1);\n\t}\n\tfor(int i=1;i<=odd_num;++i){\n\t\tfor(int j=1;j<=even_num;++j){\n\t\t\tif(check(abs(even[j]-odd[i]))) add_edge(i,j);\n\t\t}\n\t}\n\tfor(int i=1;i<=odd_num;++i){\n\t\ttim++;\n\t\tif(find(i)) k++;\n\t}\n\tans=k+((even_num-k)/2+(odd_num-k)/2)*2+((odd_num-k)%2)*3;\n\tprintf(\"%d\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<cstring>\n#include<map>\n#include<queue>\n#include<cmath>\nusing namespace std;\ntypedef long long ll;\nconst int N=1005,INF=~0u>>2;\nstruct Edge{int nxt,to;}edge[N*N];\nint b[N],n,head[N],num_edge,vis[N],lk[N],even[N],odd[N],even_num,odd_num,ans,k,tot,tim;\nint read(){\n\tint x=0,f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-') f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn f*x;\n}\nvoid add_edge(int from,int to){\n\tedge[++num_edge].nxt=head[from];\n\tedge[num_edge].to=to;\n\thead[from]=num_edge;\n}\nbool find(int x){\n\tfor(int i=head[x];i;i=edge[i].nxt){\n\t\tif(vis[edge[i].to]!=tim){\n\t\t\tvis[edge[i].to]=tim;\n\t\t\tif(!lk[edge[i].to]||find(edge[i].to)){\n\t\t\t\tlk[edge[i].to]=x;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nbool check(int x){\n\tif(x==1) return 0;\n\tfor(int i=2;i*i<=x;++i){\n\t\tif(x%i==0) return 0;\n\t}\n\treturn 1;\n}\nint main(){\n//\tfreopen(\"ex.in\",\"r\",stdin);\n\tn=read();\n\tfor(int i=1;i<=n;++i) b[i]=read();b[0]=-1;\n\tfor(int i=1;i<=n;++i){\n\t\tif(b[i]!=b[i-1]+1){\n\t\t\tif(b[i]%2) odd[++odd_num]=b[i];\n\t\t\telse even[++even_num]=b[i];\n\t\t}\n\t\tif(b[i]+1!=b[i+1]){\n\t\t\tif((b[i]+1)%2) odd[++odd_num]=b[i]+1;\n\t\t\telse even[++even_num]=b[i]+1;\n\t\t}\n\t}\n\tfor(int i=1;i<=odd_num;++i){\n\t\tfor(int j=1;j<=even_num;++j){\n\t\t\tif(check(abs(even[j]-odd[i]))) add_edge(i,j+odd_num);\n\t\t}\n\t}\n\tfor(int i=1;i<=odd_num;++i){\n\t\ttim++;\n\t\tif(find(i)) k++;\n\t}\n\tans=k+((even_num-k)/2+(odd_num-k)/2)*2+((odd_num-k)%2)*3;\n\tprintf(\"%d\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace std;\nusing namespace __gnu_pbds;\n\n#define ll long long\n#define db long double\n#define ii pair<int,int>\n#define vi vector<int>\n#define fi first\n#define se second\n#define sz(a) (int)(a).size()\n#define all(a) (a).begin(),(a).end()\n#define pb push_back\n#define mp make_pair\n#define FN(i, n) for (int i = 0; i < (int)(n); ++i)\n#define FEN(i,n) for (int i = 1;i <= (int)(n); ++i)\n#define rep(i,a,b) for(int i=a;i<b;i++)\n#define repv(i,a,b) for(int i=b-1;i>=a;i--)\n#define SET(A, val) memset(A, val, sizeof(A))\ntypedef tree<int ,null_type,less<int>,rb_tree_tag,tree_order_statistics_node_update>ordered_set ;\n// order_of_key (val): returns the no. of values less than val\n// find_by_order (k): returns the kth largest element.(0-based)\n#define TRACE\n#ifdef TRACE\n#define trace(...) __f(#__VA_ARGS__, __VA_ARGS__)\ntemplate <typename Arg1>\nvoid __f(const char* name, Arg1&& arg1){\n  cerr << name << \" : \" << arg1 << std::endl;\n}\ntemplate <typename Arg1, typename... Args>\nvoid __f(const char* names, Arg1&& arg1, Args&&... args){\n  const char* comma = strchr(names + 1, ','); cerr.write(names, comma - names) << \" : \" << arg1<<\" | \";__f(comma+1, args...);\n}\n#else\n#define trace(...)\n#endif\nconst int N=205,L=1e7+5;\nbool mark[L],prime[L];\nnamespace match\n{\n  const int N=205;\n  int l[N],r[N],n,m;\n  bool a[N][N],seen[N];\n  bool findmatch(int i)\n  {\n    rep(j,0,m)\n      {\n\tif(a[i][j] && !seen[j])\n\t  {\n\t    seen[j]=true;\n\t    if(r[j]<0 || findmatch(r[j]))\n\t      {\n\t\tl[i]=j; r[j]=i;\n\t\treturn true;\n\t      }\n\t  }\n      }\n    return false;\n  }\n  int bipartitematch()\n  {\n    int cnt=0;\n    rep(i,0,n) l[i]=-1;\n    rep(i,0,m) r[i]=-1;\n    rep(i,0,n)\n      {\n\trep(j,0,m) seen[j]=false;\n\tif(findmatch(i)) cnt++;\n      }\n    return cnt;\n  }\n};\nint main()\n{\n  std::ios::sync_with_stdio(false);\n  cin.tie(NULL) ; cout.tie(NULL) ;\n  memset(prime,true,sizeof(prime));\n  prime[0]=prime[1]=false;\n  rep(i,2,L)\n    {\n      if(!prime[i]) continue;\n      for(int j=2*i;j<L;j+=i)\n\tprime[j]=false;\n    }\n  prime[2]=false;\n  int n,x;\n  cin>>n;\n  rep(i,1,n+1)\n    {\n      cin>>x;\n      mark[x]=true;\n    }\n  vi arr;\n  int odd=0,even=0;\n  rep(i,1,L-1)\n    if(mark[i]!=mark[i-1])\n      {\n\tarr.pb(i);\n\tif(i&1) odd++;\n\telse even++;\n      }\n  match::n=match::m=sz(arr);\n  rep(i,0,sz(arr))\n    rep(j,0,sz(arr))\n    {\n      if(arr[i]&1 && prime[abs(arr[i]-arr[j])]) match::a[i][j]=1;\n      else match::a[i][j]=0;\n    }\n  int k=match::bipartitematch();\n  assert((even-odd)%2==0);\n  even-=k; odd-=k;\n  int ans=k+(even/2+odd/2)*2+(even&1)*3;\n  cout<<ans<<endl;\n  return 0 ;\n}\n"
  },
  {
    "language": "C++",
    "code": "#ifdef _MSC_VER\n#define _CRT_SECURE_NO_WARNINGS\n#endif\n\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <cassert>\n#include <string.h>\n#include <unordered_set>\n#include <unordered_map>\n\nusing namespace std;\n\ntypedef long long int64;\ntypedef unsigned long long uint64;\n#define two(X) (1<<(X))\n#define twoL(X) (((int64)(1))<<(X))\n#define contain(S,X) (((S)&two(X))!=0)\n#define containL(S,X) (((S)&twoL(X))!=0)\nconst double pi=acos(-1.0);\nconst double eps=1e-11;\ntemplate<class T> inline void ckmin(T &a,T b){if(b<a) a=b;}\ntemplate<class T> inline void ckmax(T &a,T b){if(b>a) a=b;}\ntemplate<class T> inline T sqr(T x){return x*x;}\ntypedef pair<int,int> ipair;\n#define SIZE(A) ((int)A.size())\n#define LENGTH(A) ((int)A.length())\n#define MP(A,B) make_pair(A,B)\n#define PB(X) push_back(X)\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,a) for(int i=0;i<(a);++i)\n#define ALL(A) A.begin(),A.end()\n\nconst int maxnode=100000+5;\nconst int maxedge=100000+5;\n\nint nleft,nright,nedge;\nint head[maxnode],point[maxedge],nextp[maxedge];\nint p1[maxnode],p2[maxnode];\nbool visited[maxnode];\n\nvoid clear()\n{\n\tfor (int i=0;i<nleft;i++) p1[i]=-1;\n\tfor (int i=0;i<nright;i++) p2[i]=-1;\n}\nvoid init(int _nleft,int _nright)\n{\n\tnleft=_nleft;\n\tnright=_nright;\n\tnedge=0;\n\tfor (int i=0;i<nleft;i++) head[i]=-1;\n\tclear();\n}\nvoid addedge(int u,int v)\n{\n\tpoint[nedge]=v,nextp[nedge]=head[u],head[u]=(nedge++);\n}\nbool find_path(int v)\n{\n\tfor (int k=head[v];k>=0;k=nextp[k])\n\t{\n\t\tint p=point[k];\n\t\tif (!visited[p])\n\t\t{\n\t\t\tvisited[p]=true;\n\t\t\tif (p2[p]<0 || find_path(p2[p]))\n\t\t\t{\n\t\t\t\tp1[v]=p;\n\t\t\t\tp2[p]=v;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\nint doMatch()\n{\n\tfor (int i=0;i<nleft;i++)\n\t\tfor (int k=head[i];p1[i]<0 && k>=0;k=nextp[k])\n\t\t\tif (p2[point[k]]<0)\n\t\t\t{\n\t\t\t\tp1[i]=point[k];\n\t\t\t\tp2[point[k]]=i;\n\t\t\t}\n\tfor (int i=0;i<nleft;i++) if (p1[i]<0)\n\t{\n\t\tfor (int k=0;k<nright;k++) visited[k]=false;\n\t\tfind_path(i);\n\t}\n\tint result=0;\n\tfor (int i=0;i<nleft;i++) if (p1[i]>=0) result++;\n\treturn result;\n}\n\nconst int maxn=256;\n\nint n;\nint x[maxn];\n\nbool is_prime(int n)\n{\n\tif (n<3) return false;\n\tfor (int m=2;m*m<=n;m++) if (n%m==0) return false;\n\treturn true;\n}\nint main()\n{\n#ifdef _MSC_VER\n\tfreopen(\"input.txt\",\"r\",stdin);\n#endif\n\tstd::ios::sync_with_stdio(false);\n\tcin>>n;\n\tREP(i,n) cin>>x[i];\n\tset<int> s;\n\tREP(i,n) s.insert(x[i]);\n\tset<int> e;\n\tREP(i,n) for (int d=-2;d<=2;d++) if (x[i]+d>0) e.insert(x[i]+d);\n\tset<int> w;\n\tfor (int p:e) if (s.count(p)!=s.count(p-1)) w.insert(p);\n\tvector<int> v1;\n\tvector<int> v2;\n\tfor (int p:w)\n\t\tif (p%2==0) v1.push_back(p);\n\t\telse v2.push_back(p);\n\tinit(SIZE(v1),SIZE(v2));\n\tREP(i,SIZE(v1))\n\t\tREP(j,SIZE(v2))\n\t\t\tif (is_prime(abs(v1[i]-v2[j])))\n\t\t\t\taddedge(i,j);\n\tint r0=doMatch();\n\tint l1=SIZE(v1)-r0;\n\tint l2=SIZE(v2)-r0;\n\tint ret=r0;\n\tret+=l1/2*2;\n\tret+=l2/2*2;\n\tif (l1%2==1 && l2%2==1) ret+=3;\n\tprintf(\"%d\\n\",ret);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n#define N 205\n#define M 10000002\nbool cf[M+5],vis[M+5];\nint prime[M+5],tot;\nint cy[N],a[N],b[N],cntx,cnty;\nbool vs[N],c[N][N];\nvoid shai()\n{\n\tvis[1]=1;int i,j;\n\tfor(i=1;i<=M;i++){\n\t\tif(!vis[i])prime[++tot]=i;\n\t\tfor(j=1;j<=tot;j++){\n\t\t\tint tmp=i*prime[j];\n\t\t\tif(tmp>M)break;\n\t\t\tvis[tmp]=1;\n\t\t\tif(i%prime[j]==0)break;\n\t\t}\n\t\tif(cf[i]){\n\t\t\tif(i&1)a[++cntx]=i;\n\t\t\telse b[++cnty]=i;\n\t\t}\n\t}\n}\n//pay attention to vs\nbool dfs(int i)\n{\n\tfor(int j=1;j<=cnty;j++){\n\t\tif(c[i][j]&&!vs[j]){\n\t\t\tvs[j]=1;\n\t\t\tif(!cy[j]||dfs(cy[j])){\n\t\t\t\tcy[j]=i;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nint maxmatch()\n{\n\tmemset(cy,0,sizeof(cy));\n\tint ret=0;\n\tfor(int i=1;i<=cntx;i++){\n\t\tmemset(vs,0,sizeof(vs));\n\t\tif(dfs(i))ret++;\n\t}\n\treturn ret;\n}\nint ab(int x){return x<0?-x:x;}\nint main()\n{\n\tint n,i,j,x,ans;\n\tscanf(\"%d\",&n);\n\tfor(i=1;i<=n;i++){\n\t\tscanf(\"%d\",&x);\n\t\tcf[x]^=1;cf[x+1]^=1;\n\t}\n\tshai();\n\tfor(i=1;i<=cntx;i++)\n\t\tfor(j=1;j<=cnty;j++)\n\t\t\tif(!vis[ab(b[j]-a[i])])c[i][j]=1;\n\tans=maxmatch();\n\tcntx-=ans;cnty-=ans;\n\tans+=(cntx/2)*2+(cnty/2)*2;\n\tif(cntx%2==1&&cnty%2==1)ans+=3;\n\tprintf(\"%d\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <climits>\n#include <queue>\n#include <algorithm>\n\nusing std::queue;\nusing std::min;\n\nconst int MAXX=1e7+5,MAXN=105;\nint n,cnt_x,cnt_y;\nint x_id[MAXN],y_id[MAXN];\nbool up[MAXX];\n\nstruct node{int he,iter,dis;}d[MAXN];\nstruct line{int to,nex,cap;}ed[MAXN*MAXN];\n\ninline bool is_odd_prm(int x){\n\tif(x==2) return false;\n\tfor(int i=3;i*i<=x;i+=2){\n\t\tif(x%i==0) return false;\n\t}\n\treturn true;\n}\n\ninline void addE(int u,int v,int cap){\n\tstatic int cnt=1;\n\ted[++cnt]=(line){v,d[u].he};\n\td[u].he=cnt;\n}\n\ninline int revE(int i){return i^1;}\n\ninline bool BFS(int s,int t,int n){\n\tfor(int i=1;i<=n;++i)\n\t\td[i].dis=-1;\n\tstatic queue<int> q;\n\td[s].dis=0;\n\tq.push(s);\n\tint u;\n\twhile(q.size()){\n\t\tu=q.front();\n\t\tq.pop();\n\t\tfor(int i=d[u].he,v;i;i=ed[i].nex){\n\t\t\tif(ed[i].cap==0) continue;\n\t\t\tv=ed[i].to;\n\t\t\tif(d[v].dis==-1){\n\t\t\t\td[v].dis=d[u].dis+1;\n\t\t\t\tq.push(v);\n\t\t\t}\n\t\t}\n\t}\n\treturn d[t].dis!=-1;\n}\n\nint aug(int u,int rest,const int t){\n\tif(u==t) return rest;\n\tint ret=0;\n\tfor(int &i=d[u].iter,v,cap,flow;i;i=ed[i].nex){\n\t\tv=ed[i].to,cap=ed[i].cap;\n\t\tif(d[v].dis!=d[u].dis+1 || cap==0)\n\t\t\tcontinue;\n\t\tflow=aug(v,min(cap,rest-ret),t);\n\t\ted[i].cap-=flow,ed[revE(i)].cap+=flow;\n\t\tret+=flow;\n\t\tif(ret==rest) return ret;\n\t}\n\tif(ret==0) d[u].dis=-1;\n\treturn ret;\n}\n\ninline int Dinic(int s,int t,int n){\n\tint ret=0;\n\twhile(BFS(s,t,n)){\n\t\tfor(int i=1;i<=n;++i)\n\t\t\td[i].iter=d[i].he;\n\t\tret+=aug(s,INT_MAX,t);\n\t}\n\treturn ret;\n}\n\ninline void build(){\n\tfor(int i=1;i<=cnt_x;++i){\n\t\tfor(int j=1,v;j<=cnt_y;++j){\n\t\t\tif(is_odd_prm(abs(x_id[i]-y_id[j]))){\n\t\t\t\tv=j+cnt_x;\n\t\t\t\taddE(i,v,INT_MAX),addE(v,i,0);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=1,s=cnt_x+cnt_y+1;i<=cnt_x;++i)\n\t\taddE(s,i,1),addE(i,s,0);\n\tfor(int i=1,u,t=cnt_x+cnt_y+2;i<=cnt_y;++i){\n\t\tu=cnt_x+i;\n\t\taddE(u,t,1),addE(t,u,0);\n\t}\n}\n\nint main(){\n\tscanf(\"%d\",&n);\n\tint x;\n\tfor(int i=1;i<=n;++i){\n\t\tscanf(\"%d\",&x);\n\t\tup[x]=true;\n\t}\n\tfor(int i=1;i<=x+1;++i){\n\t\tif(up[i]!=up[i-1])\n\t\t\ti&1 ? x_id[++cnt_x]=i:y_id[++cnt_y]=i;\n\t}\n\tbuild();\n\tint k=Dinic((cnt_x+cnt_y)+1,cnt_x+cnt_y+2,cnt_x+cnt_y+2);\n\tprintf(\"%d\",k+((((cnt_x-k)>>1)+((cnt_y-k)>>1))<<1)+(cnt_x-k)%2*3);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <cstring>\n\nusing namespace std;\n\nstruct edge { int to, cap, rev; };\n#define MAX_V\t(202)\n#define INF\t\t(1000000000)\n\nvector<edge> G[MAX_V];\nint level[MAX_V];\nint iter[MAX_V];\n\nvoid add_edge(int from, int to, int cap) {\n\tG[from].push_back(edge{ to, cap, (int)G[to].size() });\n\tG[to].push_back(edge{ from, 0, (int)G[from].size() - 1 });\n}\n\nvoid bfs(int s) {\n\tmemset(level, -1, sizeof(level));\n\tqueue<int> que;\n\tlevel[s] = 0;\n\tque.push(s);\n\twhile (!que.empty()) {\n\t\tint v = que.front();\n\t\tque.pop();\n\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\tedge& e = G[v][i];\n\t\t\tif (e.cap > 0 && level[e.to] < 0) {\n\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\tque.push(e.to);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint dfs(int v, int t, int f) {\n\tif (v == t) return f;\n\tfor (int& i = iter[v]; i < G[v].size(); i++) {\n\t\tedge& e = G[v][i];\n\t\tif (e.cap > 0 && level[v] < level[e.to]) {\n\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\tif (d > 0) {\n\t\t\t\te.cap -= d;\n\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint max_flow(int s, int t) {\n\tint flow = 0;\n\twhile (true) {\n\t\tbfs(s);\n\t\tif (level[t] < 0) return flow;\n\t\tmemset(iter, 0, sizeof(iter));\n\t\tint f;\n\t\twhile ((f = dfs(s, t, INF)) > 0) {\n\t\t\tflow += f;\n\t\t}\n\t}\n}\n\nbool is_prime(int n) {\n\tif (1 == n) return false;\n\tfor (int i = 2; i * i <= n; i++)if (0 == n % i) return false;\n\treturn true;\n}\n\nint main()\n{\n\tint N;\n\tcin >> N;\n\tvector<int> x(N);\n\tfor (int i = 0; i < N; i++) {\n\t\tcin >> x[i];\n\t}\n\tvector<int> p;\n\tfor (int i = 0; i < N; i++) {\n\t\tp.push_back(x[i]);\n\t\tfor (; i < N - 1 && x[i] + 1 == x[i + 1]; i++);/* 連続スキップ */\n\t\tp.push_back(x[i] + 1);\n\t}\n\tint s = MAX_V - 2;\n\tint t = s + 1;\n\tint num = p.size();\n\tint evenNum = 0;\n\tfor (int i = 0; i < num; i++) {\n\t\tif (0 == (p[i] % 2)) {\n\t\t\tadd_edge(s, i, 1);\n\t\t\tevenNum++;\n\t\t\tfor (int j = 0; j < num; j++) {\n\t\t\t\tint dst = abs(p[i] - p[j]);\n\t\t\t\tif (dst > 2 && is_prime(dst)) add_edge(i, j, 1);\n\t\t\t}\n\t\t} else {\n\t\t\tadd_edge(i, t, 1);\n\t\t}\n\t}\n\tint f = max_flow(s, t);\n\tint ans = f;\n\tans += ((evenNum - f)/2 + (num - evenNum - f)/2)*2 ;\n\tans += ((evenNum - f) % 2) * 3;\n\tcout << ans << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<queue>\n#include<algorithm>\nusing namespace std;\nconst int maxn=510,maxL=10000010,inf=0x3f3f3f3f;\nstruct cyc{int v,flow,from;}e[maxn*maxn*2];\nint tot=1,cnt,n,first[maxn],d[maxn],S,T,num[maxn],b[maxn],cur[maxn];\nbool c[maxL];\ninline int ab(int x){return x>0?x:-x;}\nbool isprime(int x){\n    if(x<=2)return 0;\n    for(int i=2;i*i<=x;i++)if(x%i==0)return 0;\n    return 1;\n}\nvoid insert(int u,int v,int w){\n    tot++;e[tot].v=v;e[tot].flow=w;e[tot].from=first[u];first[u]=tot;\n    tot++;e[tot].v=u;e[tot].flow=0;e[tot].from=first[v];first[v]=tot;\n}\nqueue<int>q;\nbool bfs(){\n    memset(d,-1,sizeof(d));\n    q.push(S);d[S]=0;\n    while(!q.empty()){\n        int x=q.front();q.pop();\n        for(int i=first[x];i;i=e[i].from)\n        if(d[e[i].v]==-1&&e[i].flow){\n            d[e[i].v]=d[x]+1;\n            q.push(e[i].v);\n        }\n    }\n    return d[T]!=-1;\n}\nint dinic(int x,int a){\n    if(x==T||a==0)return a;\n    int f,flow=0;\n    for(int& i=cur[x];i;i=e[i].from)\n    if(d[e[i].v]==d[x]+1&&e[i].flow&&(f=dinic(e[i].v,min(a,e[i].flow)))>0){\n        e[i].flow-=f;\n        e[i^1].flow+=f;\n        a-=f;\n        flow+=f;\n        if(a==0)break;\n    }\n    return flow;\n}\nint main(){\n    scanf(\"%d\",&n);\n    for(int i=1;i<=n;i++){scanf(\"%d\",&num[i]);c[num[i]]=1;}\n    for(int i=1;i<=maxL-5;i++)if(c[i]!=c[i-1])b[++cnt]=i;\n    S=0;T=cnt+1;\n    int m1=0;\n    for(int i=1;i<=cnt;i++)if(b[i]&1){\n        m1++;\n        insert(S,i,1);\n        for(int j=1;j<=cnt;j++)if(!(b[j]&1)&&isprime(ab(b[i]-b[j])))insert(i,j,1);\n    }else{\n        insert(i,T,1);\n    }\n    int ans=0;\n    while(bfs()){\n        for(int i=S;i<=T;i++)cur[i]=first[i];\n        ans+=dinic(S,inf);\n    }\n    printf(\"%d\",cnt-ans+(m1-ans)%2);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define L long long\n#define pb push_back\n#define pi pair<int,int>\n#define pii pair<pair<int,int>,int>\n#define aa first\n#define bb second\n#define mp make_pair\n#define mpp(a,b,c) mp(mp(a,b),c)\nusing namespace std;\n#define SZ 666666\ntypedef long long ll;\nint fst[SZ],nxt[SZ],vb[SZ],cap[SZ],ff[SZ],M=1,N=0;\n#define add ad_dl\nvoid _ad_dl(int a,int b,int c) {++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;cap[M]=c;}\nvoid ad_dl(int a,int b,int c)\n{_ad_dl(a,b,c); _ad_dl(b,a,0);}\nint S,T,q[SZ],d[SZ];\nbool bfs()\n{\n    memset(d,-1,4*(N+1));\n    d[T]=0; q[1]=T; int h=1,t=2;\n    while(h!=t)\n    {\n        int cur=q[h++];\n        for(int e=fst[cur];e;e=nxt[e])\n        {\n            int b=vb[e];\n            if(d[b]==-1&&cap[e^1])\n            {\n                d[b]=d[cur]+1, q[t++]=b;\n                if(b==S) return 1;\n            }\n        }\n    }\n    return d[S]!=-1;\n}\nint dfs(int x,int f)\n{\n    if(f<=0) return 0;\n    if(x==T) return f;\n    int ca=0;\n    for(int& e=fst[x];e;e=nxt[e])\n    {\n        int b=vb[e];\n        if(d[b]+1!=d[x]) continue;\n        int w=dfs(b,(cap[e]<f-ca)?cap[e]:(f-ca));\n        cap[e]-=w; cap[e^1]+=w; ca+=w;\n        if(ca==f) break;\n    }\n    if(!ca) d[x]=-1;\n    return ca;\n}\n#define inf 2e9+3\nint dinic()\n{\n    int ans=0;\n    memcpy(ff,fst,4*(N+1));\n    while(bfs())\n    {\n        ans+=dfs(S,inf);\n        memcpy(fst,ff,4*(N+1));\n    }\n    return ans;\n}\nint n,m,x[110],f[210],p;\nbool a[10000010];\nint main()\n{\n\t//freopen(\".in\",\"r\",stdin);\n\t//freopen(\".out\",\"w\",stdout);\n\tint i,j,k;\n\tscanf(\"%d\",&n);\n\tfor(i=1;i<=n;i++)\n\t  scanf(\"%d\",&x[i]);\n\tsort(x+1,x+n+1);\n\tmap<int,int> tt;\n\tfor(i=2;i<=n;i++)\n\t  if(x[i-1]+1!=x[i])\n\t    {\n\t     tt[x[i-1]+1]^=1;\n\t     tt[x[i]]^=1;\n\t\t}\n\ttt[x[1]]^=1;\n\ttt[x[n]+1]^=1;\n\tfor(auto aa:tt)\n\t\tif(aa.second) x[++m]=aa.first;\n\ta[1]=1;\n\tfor(i=2;i<=10000000;i++)\n\t  if(!a[i])\n\t    for(j=i;j<=10000000;j+=i)\n\t      a[j]=1;\n\ta[2]=1;\n\tN=m+2;\n\tS=m+2;\n\tT=m+1;\n\tfor(i=1;i<=m;i++)\n\t  if(f[i]&1)\n\t    add(m+2,i,1);\n\t  else\n\t    add(i,m+1,1);\n\tfor(i=1;i<=m;i++)\n\t  for(j=1;j<=m;j++)\n\t    if(i!=j && f[i]&1 && !a[abs(f[i]-f[j])])\n\t      add(i,j,1);\n\tp=k=dinic();\n\tfor(i=1,j=-k;i<=m;i++)\n\t  if(f[i]&1)\n\t    j++;\n\tp+=j/2*2;\n\tif(j&1)\n\t  p+=3;\n\tfor(i=1,j=-k;i<=m;i++)\n\t  if(!(f[i]&1))\n\t    j++;\n\tp+=j/2*2;\n\tprintf(\"%d\\n\",p);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<cstring>\nusing namespace std;\nint n;\nint res;\nvector<int>v;\nint lst=-1;\nint match[210];\nint me,mo;\nint mx;\nbool f[10000010];\nvector<int>ok[210];\nbool vis[210];\nint prm[1000010];\nint sz;\nbool bp(int x)\n{\n\tfor(int i=0;i<ok[x].size();i++)\n\t{\n\t\tint y=ok[x][i];\n\t\tif(vis[y])continue;\n\t\tvis[y]=true;\n\t\tif(match[y]==-1 || bp(match[y]))\n\t\t{\n\t\t\tmatch[y]=x;\n\t\t\tmatch[x]=y;\n\t\t\treturn true;\n\t\t}\n\t\tvis[y]=false;\n\t}\n\treturn false;\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint x;\n\t\tscanf(\"%d\",&x);\n\t\tif(x!=lst+1)\n\t\t{\n\t\t\tif(lst+1)v.push_back(lst+1);\n\t\t\tv.push_back(x);\n\t\t}\n\t\tlst=x;\n\t\tmx=lst+1;\n\t}\n\tv.push_back(lst+1);\n\tf[1]=true;\n\tfor(int i=2;i<=mx;i++)\n\t{\n\t\tif(!f[i])prm[++sz]=i;\n\t\tfor(int j=1;j<=sz;j++)\n\t\t{\n\t\t\tif(prm[j]*i>mx)break;\n\t\t\tf[prm[j]*i]=true;\n\t\t\tif(i%prm[j]==0)break;\n\t\t}\n\t}\n\tint l=v.size();\n\tfor(int i=0;i<l;i++)\n\t{\n\t\tmatch[i]=-1;\n\t\tif(v[i]&1)mo++;else me++;\n\t\tfor(int j=i+1;j<l;j++)\n\t\t{\n\t\t\tif(v[j]-v[i]!=2 && !f[v[j]-v[i]])\n\t\t\t{\n\t\t\t\tok[i].push_back(j);\n\t\t\t\tok[j].push_back(i);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<l;i++)\n\t{\n\t\tmemset(vis,false,sizeof(vis));\n\t\tif(bp(i))res++;\n\t}\n\tres/=2;\n\tprintf(\"%d\",res+((me-res)/2+(mo-res)/2)*2+((me-res)%2)*3);\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nconst int N=220,M=10001000,oo=1000000000;\nint i,j,k,n,nb0,nb1,nm,ans,En,S,T;\nint a[N],fg[M],pr[M/10],z[M];\nint b0[N],b1[N],c[N],d[N],h[N];\nstruct edge { int s,n,v;} E[N*N];\nvoid pre(int n) {\n\tint i,j;\n\tfg[1]=3;\n\tfor (i=2;i<=n;i++) {\n\t\tif (fg[i]!=3) pr[++nm]=i,fg[i]=1;\n\t\tfor (j=1;j<=nm;j++) {\n\t\t\tif (i*pr[j]>n) break;\n\t\t\tfg[i*pr[j]]=3;\n\t\t\tif (i%pr[j]==0) break;\n\t\t}\n\t}\n\tfor (i=2;i<=n;i+=2) fg[i]=2;\n}\nvoid E_add(int x,int y,int v) {\n\tE[++En].s=y;E[En].v=v;\n\tE[En].n=h[x];h[x]=En;\n\tE[++En].s=x;E[En].v=0;\n\tE[En].n=h[y];h[y]=En;\n}\nbool bfs() {\n\tint i,j,k;\n\tmemset(c,0,sizeof c);\n\ti=0;j=1;d[1]=S;c[S]=1;\n\twhile (i<j) {\n\t\ti++;\n\t\tfor (k=h[d[i]];k;k=E[k].n) if (E[k].v && !c[E[k].s]) {\n\t\t\tc[E[k].s]=c[d[i]]+1;\n\t\t\td[++j]=E[k].s;\n\t\t}\n\t}\n\treturn c[T];\n}\nint dfs(int x,int y) {\n\tif (x==T || !y) return y;\n\tint k,t,Y=y;\n\tfor (k=h[x];k;k=E[k].n) if (E[k].v && c[x]+1==c[E[k].s]) {\n\t\tt=dfs(E[k].s,min(E[k].v,y));\n\t\ty-=t;\n\t\tE[k].v-=t;\n\t\tE[k^1].v+=t;\n\t\tif (!y) return Y;\n\t}\n\tif (Y==y) c[x]=-1;\n\treturn Y-y;\n}\nint main() {\n\tscanf(\"%d\",&n);\n\tfor (i=1;i<=n;i++) scanf(\"%d\",&a[i]);\n\tpre(a[n]);\n\tfor (i=1;i<=n;i++) z[a[i]]^=1,z[a[i]+1]^=1;\n\tfor (i=1;i<=a[n]+1;i++) if (z[i]) {\n\t\tif (i&1) b1[++nb1]=i;\n\t\telse b0[++nb0]=i;\n\t}\n\tEn=1;S=nb0+nb1+1;T=S+1;\n\tfor (i=1;i<=nb0;i++) E_add(S,i,1);\n\tfor (j=1;j<=nb1;j++) E_add(nb0+j,T,1);\n\tfor (i=1;i<=nb0;i++)\n\t\tfor (j=1;j<=nb1;j++) {\n\t\t\tk=b0[i]-b1[j];\n\t\t\tif (k<0) k=-k;\n\t\t\tif (fg[k]==1) E_add(i,nb0+j,1);\n\t\t}\n\twhile (bfs()) ans+=dfs(S,oo);\n\tnb0-=ans;\n\tnb1-=ans;\n\tans+=nb0/2*2+nb1/2*2;\n\tnb0&=1;nb1&=1;\n\tif (nb0) ans+=3;\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n\nconst int N=205;\nconst int inf=10000001;\n\nint n,prime[inf+5],match[N],a[N],b[N],a1,b1,tot;\nbool s[inf+5],not_prime[inf+5],vis[N],ma[N][N];\n\nvoid get_prime(int n)\n{\n\tnot_prime[1]=1;\n\tfor (int i=2;i<=n;i++)\n\t{\n\t\tif (!not_prime[i]) prime[++tot]=i;\n\t\tfor (int j=1;j<=tot&&i*prime[j]<=n;j++)\n\t\t{\n\t\t\tnot_prime[i*prime[j]]=1;\n\t\t\tif (i%prime[j]==0) break;\n\t\t}\n\t}\n}\n\nbool find(int x)\n{\n\tfor (int i=1;i<=b1;i++)\n\t\tif (ma[x][i]&&!vis[i])\n\t\t{\n\t\t\tvis[i]=1;\n\t\t\tif (!match[i]||find(match[i]))\n\t\t\t{\n\t\t\t\tmatch[i]=x;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\treturn 0;\n}\n\nint main()\n{\n\tget_prime(inf);\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tint x;scanf(\"%d\",&x);\n\t\ts[x]=1;\n\t}\n\tfor (int i=1;i<=inf;i++)\n\t\tif (s[i]!=s[i-1])\n\t\t{\n\t\t\tif (i&1) a[++a1]=i;\n\t\t\telse b[++b1]=i;\n\t\t}\n\tfor (int i=1;i<=a1;i++)\n\t\tfor (int j=1;j<=b1;j++)\n\t\t\tif (!not_prime[abs(a[i]-b[j])]) ma[i][j]=1;\n\tint ans=0,tmp=0;\n\tfor (int i=1;i<=a1;i++)\n\t{\n\t\tmemset(vis,0,sizeof(vis));\n\t\tif (find(i)) tmp++,ans++;\n\t}\n\tans+=(a1-tmp)/2*2+(b1-tmp)/2*2;\n\tif (a1%2!=tmp%2) ans+=3;\n\tprintf(\"%d\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define f first\n#define s second\n#define pb push_back\n#define reset(a,b) memset(a,b,sizeof a);\n#define ALL(x) x.begin(),x.end()\n#define debug(x) cout<<#x<<\" = \"<<(x)<<endl\n#define sz(x) (int)(x.size())\n#define lt(x) (int)(x.length())\n#define MOD 1000000007 \n#define mx 100003\n\nbool p[10000003], ya[10000003];\n// int x[103];\nvector<int> prima;\nvector<int> genap, ganjil;\nint sama[103];\nint sudah[103];\n\nint dfs(int now){\n\tfor(int j = 0; j < sz(ganjil); j++){\n\t\tif(sudah[j])\n\t\t\tcontinue;\n\t\tif(p[abs(genap[now] - ganjil[j])])\n\t\t\tcontinue;\n\t\tsudah[j] = true;\n\t\tif(sama[j] == -1 || dfs(sama[j])){\n\t\t\tsama[j] = now;\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\n\nint match(){\n\tint ret = 0;\n\tfor(int i = 0; i < sz(ganjil); i++)\n\t\tsama[i] = -1;\n\tfor(int i = 0; i < sz(genap); i++){\n\t\tfor(int j = 0; j < sz(ganjil); j++)\n\t\t\tsudah[j] = false;\n\t\tret += dfs(i);\n\t}\n\treturn ret;\n}\n\nint main(){\n\tp[1] = true;\n\tfor(int i = 2; i <= 1e7 + 1; i++){\n\t\tif(p[i])\n\t\t\tcontinue;\n\t\tif(i > 2)\n\t\t\tprima.pb(i);\n\t\tfor(int j = i + i; j <= 1e7 + 1; j += i)\n\t\t\tp[j] = true;\n\t}\n\tint n;\n\tcin >> n;\t\n\tfor(int i = 0; i < n; i++){\n\t\tint x;\n\t\tcin >> x;\n\t\tya[x] = true;\n\t}\n\tfor(int i = 1; i <= 1e7 + 1; i++){\n\t\tif(ya[i] ^ ya[i - 1]){\n\t\t\tif(i % 2 == 0)\n\t\t\t\tgenap.pb(i);\n\t\t\telse ganjil.pb(i);\n\t\t}\n\t}\n\t// debug(sz(genap));\n\t// debug(sz(ganjil));\n\t// for(int i : genap)\n\t// \tdebug(i);\n\t// for(int i : ganjil)\n\t// \tdebug(i);\n\tint aa = match();\n\tint sisaGenap = sz(genap) - aa;\n\tint sisaGanjil = sz(ganjil) - aa;\n\tint jaw = aa + (sisaGenap / 2) * 2 + (sisaGanjil / 2) * 2;\n\tif(sisaGanjil % 2 > 0){\n\t\tassert(sisaGenap % 2 > 0);\n\t\tjaw += 3;\n\t}\n\tcout << jaw << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define M 10000005\nusing namespace std;\nint d[700005],t,m,e[M],n,cnt,vis[205],w[205],g[205],u[40005],v[40005],nex[40005],a[205],b[205],A;\nint find(int x){\n\tfor (int i=g[x];i;i=nex[i])\n\tif (!vis[v[i]]){\n\t\tvis[v[i]]=1;\n\t\tif (!w[v[i]]||find(w[v[i]])){\n\t\t\tw[v[i]]=x; return 1;\n\t\t}\n\t}\n\treturn 0;\n}\nint main(){\n\tfor (int i=2;i<M;++i){\n\t\tif (!e[i]) d[++t]=i;\n\t\tfor (int j=1;j<=t;++j){\n\t\t\tn=i*d[j]; if (n>=M) break;\n\t\t\te[n]=1;\tif (i%d[j]==0) break;\n\t\t}\n\t}\n\tscanf(\"%d\",&n); t=0; e[0]=e[1]=e[2]=1;\n\tfor (int i=1;i<=n;++i) scanf(\"%d\",&a[i]);\n\tfor (int i=1,j;i<=n;i=j+1){\n\t\tfor (j=i;a[j+1]==a[j]+1;++j);\n\t\tb[++t]=a[i]; b[++t]=a[j]+1;\n\t}\n\tn=t;\n\tfor (int i=1;i<=n;++i)\n\tfor (int j=1;j<=n;++j)\n\tif (b[i]&1&&!e[abs(b[j]-b[i])])\n\t\tu[++m]=i,v[m]=j,nex[m]=g[i],g[i]=m;\n\tfor (int i=1;i<=n;++i)\n\tif (b[i]&1){\n\t\tfor (int j=1;j<=n;++j) vis[j]=0;\n\t\tif (find(i)) ++cnt; ++A;\n\t}\n\tcnt+=A/2*2+(n-A)/2*2;\n\tif (A&1) cnt+=3;\n\tprintf(\"%d\\n\",cnt);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <algorithm>\n#include <cstdio>\n#include <cmath>\n#include <set>\n#include <map>\n#include <queue>\n#include <string>\n#include <cstring>\n#include <bitset>\n#include <functional>\n#include <random>\n#define REP(i,a,n) for(int i=a;i<=n;++i)\n#define PER(i,a,n) for(int i=n;i>=a;--i)\n#define hr putchar(10)\n#define pb push_back\n#define lc (o<<1)\n#define rc (lc|1)\n#define mid ((l+r)>>1)\n#define ls lc,l,mid\n#define rs rc,mid+1,r\n#define x first\n#define y second\n#define io std::ios::sync_with_stdio(false)\n#define endl '\\n'\n#define DB(a) ({REP(__i,1,n) cout<<a[__i]<<' ';hr;})\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n\nconst int N = 1e6+10, S = N-2, T = N-1, INF = 0x3f3f3f3f;\nconst int M = 1e7+10;\nint n, f[M];\nstruct edge {\n    int to,w,next;\n    edge(int to=0,int w=0,int next=0):to(to),w(w),next(next){}\n} e[N];\nint head[N], dep[N], vis[N], cur[N], cnt=1;\nqueue<int> Q;\nint bfs() {\n    REP(i,1,n) dep[i]=INF,vis[i]=0,cur[i]=head[i];\n    dep[S]=INF,vis[S]=0,cur[S]=head[S];\n    dep[T]=INF,vis[T]=0,cur[T]=head[T];\n    dep[S]=0,Q.push(S);\n    while (Q.size()) {\n        int u = Q.front(); Q.pop();\n        for (int i=head[u]; i; i=e[i].next) {\n            if (dep[e[i].to]>dep[u]+1&&e[i].w) {\n                dep[e[i].to]=dep[u]+1;\n                Q.push(e[i].to);\n            }\n        }\n    }\n    return dep[T]!=INF;\n}\nint dfs(int x, int w) {\n    if (x==T) return w;\n    int used = 0;\n    for (int i=cur[x]; i; i=e[i].next) {\n        cur[x] = i;\n        if (dep[e[i].to]==dep[x]+1&&e[i].w) {\n            int f = dfs(e[i].to,min(w-used,e[i].w));\n            if (f) used+=f,e[i].w-=f,e[i^1].w+=f;\n            if (used==w) break;\n        }\n    }\n    return used;\n}\nint dinic() {\n    int ans = 0;\n    while (bfs()) ans+=dfs(S,INF);\n    return ans;\n}\nvoid add(int u, int v, int w) {\n    e[++cnt] = edge(v,w,head[u]);\n    head[u] = cnt;\n    e[++cnt] = edge(u,0,head[v]);\n    head[v] = cnt;\n}\n\nint chk(int x) {\n\tint mx = sqrt(x+0.5);\n\tREP(i,2,mx) if (x%i==0) return 0;\n\treturn 1;\n}\nint main() {\n\tscanf(\"%d\", &n);\n\tREP(i,1,n) { \n\t\tint t;\n\t\tscanf(\"%d\", &t);\n\t\tf[t] = 1;\n\t}\n\tvector<pii> A, B;\n\tint now = 0;\n\tREP(i,1,M-1) if (f[i]!=f[i-1]) {\n\t\tif (i&1) A.pb(pii(i,++now)),add(S,now,1);\n\t\telse B.pb(pii(i,++now)),add(now,T,1);\n\t}\n\tfor (auto t:A) for (auto tt:B) { \n\t\tif (chk(abs(t.x-tt.x))) {\n\t\t\tadd(t.y,tt.y,1);\n\t\t}\n\t}\n\tint flow = dinic();\n\tint ans = flow, x = A.size()-flow, y = B.size()-flow;\n\tans += x/2*2, x %= 2;\n\tans += y/2*2, y %= 2;\n\tif (x) ans += 3;\n\tprintf(\"%d\\n\", ans);\n}\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <set>\n#include <bitset>\nusing namespace std;\nint N;\nint x;\nset<int> S;\nvector<int> G[205];\nint L[205];\nint R[205];\nvector<int> Me,Mo;\nbitset<205> U;\nbool prime(int nr)\n{\n    for(int i=2;i*i<=nr;i++)if(nr%i==0)return 0;\n    return 1;\n}\nbool pairup(int nod)\n{\n    if(U[nod])return 0;\n    U[nod]=1;\n    for(auto it:G[nod])\n    {\n        if(!R[it])\n        {\n            L[nod]=it;\n            R[it]=nod;\n            return 1;\n        }\n    }\n    for(auto it:G[nod])\n    {\n        if(pairup(R[it]))\n        {\n            L[nod]=it;\n            R[it]=nod;\n            return 1;\n        }\n    }\n    return 0;\n}\nint main()\n{\n    cin>>N;\n    for(int i=1;i<=N;i++)\n    {\n        cin>>x;\n        if(S.find(x)!=S.end())\n        {\n            S.erase(x);\n        }\n        else\n        {\n            S.insert(x);\n        }\n        S.insert(x+1);\n    }\n    for(auto it:S)\n        if(it%2==0)\n            Me.push_back(it);\n        else\n            Mo.push_back(it);\n    for(int i=0;i<Me.size();i++)\n    {\n        for(int j=0;j<Mo.size();j++)\n        {\n            if(prime(abs(Mo[j]-Me[i])))\n                G[i].push_back(j);\n        }\n    }\n    bool ok=1;\n    int k=0;\n    while(ok)\n    {\n        ok=0;\n        U.reset();\n        for(int i=0;i<Me.size();i++)\n        {\n            if(!L[i]&&pairup(i))\n            {\n                k++;\n                ok=1;\n            }\n        }\n    }\n    int rez=k+(((int)Me.size()-k)/2)*2+(((int)Mo.size()-k)/2)*2+(((int)Me.size()-k)%2)*3;\n    cout<<rez;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// #includes {{{\n#include <bits/stdc++.h>\nusing namespace std;\n \n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define RREP(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define FOR(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();++i)\n#define LET(x,a) __typeof(a) x(a)\n//#define IFOR(i,it,c) for(__typeof((c).begin())it=(c).begin();it!=(c).end();++it,++i)\n#define ALL(c) (c).begin(), (c).end()\n#define MP make_pair\n \n#define EXIST(e,s) ((s).find(e)!=(s).end())\n \n#define RESET(a) memset((a),0,sizeof(a))\n#define SET(a) memset((a),-1,sizeof(a))\n#define PB push_back\n#define DEC(it,command) __typeof(command) it=command\n \n//debug\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n#define debug2(x) cerr << #x << \" = [\";REP(__ind,(x).size()){cerr << (x)[__ind] << \", \";}cerr << \"] (L\" << __LINE__ << \")\" << endl;\n \nconst int INF=0x3f3f3f3f;\n \ntypedef long long Int;\ntypedef unsigned long long uInt;\ntypedef long double rn;\n \ntypedef pair<int,int> pii;\n \n/*\n#ifdef MYDEBUG\n#include\"debug.h\"\n#include\"print.h\"\n#endif\n*/\n// }}}\n \n//{{{ io\nFILE *file_in=stdin,*file_out=stdout;\n#define fin normal_in\n#define fout normal_out\n//const char fname[]=\"\";\n//FILE *fin=fopen(fname,\"r\"),*fout=fopen(fname,\"w\");\n#ifdef __MINGW32__\n#define LLD \"%I64d\"\n#define LLU \"%I64u\"\n#else\n#define LLD \"%lld\"\n#define LLU \"%llu\"\n#endif\nstruct NORMAL_IN{\n\tbool cnt;\n\tNORMAL_IN():cnt(true){}\n\toperator int() const {return cnt;}\n#define endl \"\\n\"\n\tNORMAL_IN& operator>>(int &n){cnt=fscanf(file_in,\"%d\",&n)!=EOF;return *this;}\n\tNORMAL_IN& operator>>(unsigned int &n){cnt=fscanf(file_in,\"%u\",&n)!=EOF;return *this;}\n\tNORMAL_IN& operator>>(long long &n){cnt=fscanf(file_in,LLD,&n)!=EOF;return *this;}\n\tNORMAL_IN& operator>>(unsigned long long &n){cnt=fscanf(file_in,LLU,&n)!=EOF;return *this;}\n\tNORMAL_IN& operator>>(double &n){cnt=fscanf(file_in,\"%lf\",&n)!=EOF;return *this;}\n\tNORMAL_IN& operator>>(long double &n){cnt=fscanf(file_in,\"%Lf\",&n)!=EOF;return *this;}\n\tNORMAL_IN& operator>>(char *c){cnt=fscanf(file_in,\"%s\",c)!=EOF;return *this;}\n\tNORMAL_IN& operator>>(string &s){\n\t\ts.clear();\n\t\tfor(bool r=false;;){\n\t\t\tconst char c=getchar();\n\t\t\tif(c==EOF){ cnt=false; break;}\n\t\t\tconst int t=isspace(c);\n\t\t\tif(!r and !t)r=true;\n\t\t\tif(r){\n\t\t\t\tif(!t)s.push_back(c);\n\t\t\t\telse break;\n\t\t\t}\n\t\t}\n\t\treturn *this;\n\t}\n\ttemplate<class T>\n\t\tNORMAL_IN& operator>>(vector<T> &v){\n\t\t\tint n;fscanf(file_in,\"%d\",&n);\n\t\t\tREP(i,n){\n\t\t\t\tT t;*this>>t;\n\t\t\t\tv.push_back(t);\n\t\t\t}\n\t\t}\n} normal_in;\n \nstruct NORMAL_OUT{\n\tNORMAL_OUT& operator<<(const int &n){fprintf(file_out,\"%d\",n);return *this;}\n\tNORMAL_OUT& operator<<(const unsigned int &n){fprintf(file_out,\"%u\",n);return *this;}\n\tNORMAL_OUT& operator<<(const long long &n){fprintf(file_out,LLD,n);return *this;}\n\tNORMAL_OUT& operator<<(const unsigned long long &n){fprintf(file_out,LLU,n);return *this;}\n\tNORMAL_OUT& operator<<(const double &n){fprintf(file_out,\"%lf\",n);return *this;}\n\tNORMAL_OUT& operator<<(const long double &n){fprintf(file_out,\"%Lf\",n);return *this;}\n\tNORMAL_OUT& operator<<(const char c[]){fprintf(file_out,\"%s\",c);return *this;}\n\tNORMAL_OUT& operator<<(const string &s){fprintf(file_out,\"%s\",s.c_str());return *this;}\n} normal_out;\n//}}}\n \n//{{{ Graph\ntemplate<class Weight>\nstruct Edge {\n\tint src, dst, rev;\n\tWeight weight;\n\tEdge(int src, int dst, Weight weight=1,int rev=-1) :\n\t\tsrc(src), dst(dst), weight(weight), rev(rev) { }\n};\ntemplate<class Weight>\nbool operator < (const Edge<Weight> &e, const Edge<Weight> &f) {\n\treturn e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n\t\te.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\n//typedef vector<Edge> Edges;\n//typedef vector<Edges> Graph;\n \n//typedef vector<Weight> Array;\n//typedef vector<Array> Matrix;\n \ntemplate<class Weight=int>\nstruct Graph:vector<vector<Edge<Weight> > >{\n\tGraph(){}\n\tGraph(const int &n){this->assign(n,vector<Edge<Weight> >());}\n\tvoid _add_edge(int from, int to, Weight w, int rev=-1){\n\t\tif(this->size() < from + 1)this->resize(from + 1);\n\t\tthis->at(from).push_back(Edge<Weight>(from,to,w,rev));\n\t}\n};\n//add bi-directional edge\ntemplate<class Weight>\nvoid addBiEdge(Graph<Weight> &g, const pair<int,int> &e, Weight w=1){\n\tconst int &from = e.first, &to = e.second;\n\tg._add_edge(from,to,w,g[to].size());\n\tg._add_edge(to,from,w,g[from].size()-1);\n//\twhile(this->size()<max(from,to)+1)this->push_back(vector<Edge<Weight> >());\n//\tthis->at(from).push_back(Edge<Weight>(from,to,w,this->at(to).size()));\n//\tthis->at(to).push_back(Edge<Weight>(to,from,w,this->at(from).size()-1));\n}\n//add directional edge\ntemplate<class Weight>\nvoid addEdge(Graph<Weight> &g, const pair<int,int> &e, Weight w=1){\n\tconst int &from = e.first, &to = e.second;\n\tg._add_edge(from,to,w);\n//\twhile(this->size()<from+1)this->push_back(vector<Edge<Weight> >());\n//\tthis->at(from).push_back(Edge<Weight>(from,to,w));\n}\n\n#ifdef DEBUG\n#include\"graph/graphviz.h\"\n#endif\n//}}}\n\n//typedef Weight Flow;\n//typedef long long Cost;\n\n\n//{{{ addFlowEdge(Graph<Flow,Cost>, {from,to},{Flow,Cost})\ntemplate<class Flow,class Cost>\nvoid addFlowEdge(Graph<pair<Flow,Cost> > &g,const pair<int,int> &e,const pair<Flow,Cost> &p){\n\tint from = e.first, to = e.second;\n\tFlow cap = p.first;Cost cost = p.second;\n\tg._add_edge(from,to,{cap,cost},g[to].size());\n\tg._add_edge(to,from,{0,-cost},g[from].size()-1);\n//\tg[from].push_back(Edge<pair<Flow,Cost> >(from,to,{cap,cost},g[to].size()));\n//\tg[to].push_back(Edge<pair<Flow,Cost> >(to,from,{0,-cost},g[from].size()-1));\n}\n//}}}\n//{{{ minCostFlow(Graph<Flow,Cost> g,{s,t},f)\ntemplate<class Flow,class Cost>\nstruct minCostFlow_t{\n\tvector<vector<Flow> > flow;\n\tbool feasible;\n\tCost val;\n\toperator bool(){return feasible;}\n\tCost operator*(){return val;}\n};\n\ntemplate<class Flow,class Cost>\nminCostFlow_t<Flow,Cost> minCostFlow(const Graph<pair<Flow,Cost> > &g,const pair<int,int> &st,Flow f){\n\tconst int n = g.size();\n\tconst int s = st.first, t = st.second;\n\tminCostFlow_t<Flow,Cost> ret;\n\tvector<vector<Flow> > &flow = ret.flow;\n\tflow.assign(n,vector<Flow>());\n\tconst Flow FINF=1e+9;\n\tconst Cost CINF=1e+18;\n\n\tREP(i,n)REP(j,g[i].size())flow[i].push_back(g[i][j].weight.first);\n\tvector<Cost> dist(n);\n\tvector<int> prevv(n),preve(n);\n\tCost res=0;\n\twhile(f>0){\n\t\tfill(ALL(dist),CINF);\n\t\tdist[s]=0;\n\t\tbool update=true;\n\t\twhile(update){\n\t\t\tupdate=false;\n\t\t\tfor(int v=0;v<n;v++){\n\t\t\t\tif(dist[v]==CINF)continue;\n\t\t\t\tfor(int i=0;i<g[v].size();i++){\n\t\t\t\t\tconst auto &e=g[v][i];\n\t\t\t\t\tif(flow[v][i]>0 && dist[e.dst]>dist[v]+e.weight.second){\n\t\t\t\t\t\tdist[e.dst]=dist[v]+e.weight.second;\n\t\t\t\t\t\tprevv[e.dst]=v;preve[e.dst]=i;\n\t\t\t\t\t\tupdate=true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(dist[t]==CINF){\n\t\t\tret.feasible = false;\n\t\t\treturn ret;\n\t\t}\n\t\tFlow d=f;\n\t\tfor(int v=t;v!=s;v=prevv[v]){\n\t\t\td=min(d,flow[prevv[v]][preve[v]]);\n\t\t}\n\t\tf-=d;\n\t\tres+=d*dist[t];\n\t\tfor(int v=t;v!=s;v=prevv[v]){\n\t\t\tconst auto &e=g[prevv[v]][preve[v]];\n\t\t\tflow[prevv[v]][preve[v]]-=d;\n\t\t\tflow[v][e.rev]+=d;\n\t\t}\n\t}\n\tret.feasible = true;\n\tret.val = res;\n\treturn ret;\n}\n//}}}\n\nconst int SMAX=10000;\nint pdiv[SMAX];\nvector<int> primes;\n//{{{ eratosthenes\nvoid sieve_of_eratosthenes(int n) {\n\tfor (int i = 2; i < n; ++i)\n\t\tpdiv[i] = i;\n\tfor (int i = 2; i*i < n; ++i)\n\t\tif (pdiv[i]==i)\n\t\t\tfor (int j = i*i; j < n; j+=i)\n\t\t\t\tpdiv[j] = i;\n}\n//}}}\nbool is_prime(int n){\n\tif(n==1)return false;\n\tfor(int i=0;;i++){\n\t\tint p = primes[i];\n\t\tif(p*p>n)break;\n\t\tif(n%p==0)return false;\n\t}\n\treturn true;\n}\n\nvoid solve(long long N, vector<long long> x){\n\tvector<int> v0,v1;\n\tfor(int i=0;i<x.size();){\n\t\tint j;\n\t\tfor(j=i+1;j<x.size();j++){\n\t\t\tif(x[j-1]+1!=x[j])break;\n\t\t}\n\t\t//[ x[i], x[j-1]+1 )\n\t\tvector<Int> v{x[i],x[j-1]+1};\n\t\tfor(auto u:v){\n\t\t\tif(u%2==0)v0.push_back(u);\n\t\t\telse v1.push_back(u);\n\t\t}\n\t\ti = j;\n\t}\n\tGraph<pair<int,Int> > g(v0.size()+v1.size()+2);\n\tint s = v0.size() + v1.size(), t = s + 1;\n\tREP(i,v0.size())REP(j,v1.size()){\n\t\tif(is_prime(abs(v0[i]-v1[j]))){\n\t\t\taddFlowEdge(g,{i,j+v0.size()},{10000,1});\n\t\t}else{\n\t\t\taddFlowEdge(g,{i,j+v0.size()},{10000,3});\n\t\t}\n\t}\n\tREP(i,v0.size())addFlowEdge(g,{s,i},{1,0});\n\tREP(j,v1.size())addFlowEdge(g,{j+v0.size(),t},{1,0});\n\tInt ans = INF;\n\tint r = v0.size()%2;\n\tfor(int f=r;;f+=2){\n\t\tif(v0.size()<f or v1.size()<f)break;\n\t\tauto mcf(minCostFlow(g,{s,t},f));\n\t\tassert(mcf);\n\t\tauto c = *mcf;\n\t\tc+=v0.size()+v1.size()-f*2;\n\t\tans = min(c,ans);\n\t}\n\tfout<<ans<<endl;\n}\n\nint main(){\n\tGraph<> g;\n\tsieve_of_eratosthenes(SMAX);\n\tfor(int p=2;p<SMAX;p++)if(pdiv[p]==p)primes.push_back(p);\n\tlong long N;\n\tfin >> N;\n\tvector<long long> x(N-1+1);\n\tfor(int i = 0 ; i <= N-1 ; i++){\n\t\tfin >> x[i];\n\t}\n\tsolve(N, x);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\ninline int read()\n{\n\tint x = 0, op = 1; char ch = 0;\n\twhile(not isdigit(ch = getchar())) if(ch == '-') op = -op;\n\tdo x = x * 10 + (ch - '0'); while(isdigit(ch = getchar()));\n\treturn op * x;\n}\ninline bool check(int a, int x, int y, int z)\n{\n\tint u = 0, v = 0, w = 0;\n\t#define pows(a, b) \\\n\t\tu = (a), v = (b), w = 1;\\\n\t\twhile(v) { if(v & 1) w = w * u % x; u = u * u % x, v >>= 1; }\n\tpows(a, z);\n\tif(w > 1) { \n\t\tfor(int i = 0; i < y; i++)\n\t\t{\n\t\t\tif(w == x - 1) return true;\n\t\t\tw = w * w % x;\n\t\t}\n\t\treturn false;\n\t}\n\telse return true;\n}\nbool isprime(int x)\n{\n\tif(x == 2 || x == 3 || x == 7 || x == 61) return true;\n\tif(!(x % 2 && x % 7 && x % 61 && x % 3) || x == 1) return false;\n\tint y = 0, z = x - 1; while(!(z & 1)) y++, z >>= 1;\n\tbool ok = true;\t\n\tok &= check(2, x, y, z);\n\tok &= check(3, x, y, z);\n\tok &= check(7, x, y, z);\n\tok &= check(61, x, y, z);\n\treturn ok;\n}\nint n = 0, m = 0, pos[150], whi[300];\nbool used[300]; int ans = 0;\nint pygo[300]; bool insta[300];\nbool dfs(int x, int p)\n{\n\tfor(int i = 1; i <= m; i++)\n\t\tif(not insta[i] && (abs(whi[x] - whi[i]) > 2 && isprime(abs(whi[x] - whi[i]))) && p != i)\n\t\t{\n\t\t\tinsta[i] = true;\n\t\t\tif(!pygo[i] || dfs(pygo[i], p))\n\t\t\t{\n\t\t\t\tpygo[x] = i, pygo[i] = x;\n\t\t\t\tused[x] = used[i] = true;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\treturn false;\n}\nsigned main()\n{\n\tn = read();\n\tfor(int i = 1; i <= n; i++) pos[i] = read();\n\tsort(pos + 1, pos + n + 1);\n\tfor(int i = 1; i <= n; i++)\n\t{\n\t\tif(i == 1 || pos[i] != pos[i - 1] + 1) whi[++m] = pos[i];\n\t\tif(i == n || pos[i] != pos[i + 1] - 1) whi[++m] = pos[i] + 1;\n\t}\n\tfor(int i = 1; i <= m; i++)\n\t\tif(not used[i]) memset(insta, 0, sizeof insta), dfs(i, i);\n\tfor(int i = 1; i <= m; i++)\n\t\tif(used[i]) ans++;\n\t/*for(int i = 1; i <= m; i++)\n\t\tif(used[i] && pygo[i] > i) cerr << whi[pygo[i]] - whi[i] << \" \";\n\tcerr << endl;*/\n\tans >>= 1LL;\n\tint tot[2] = {0, 0};\n\tfor(int i = 1; i <= m; i++)\n\t\tif(not used[i]) tot[whi[i] & 1]++;\n\tans += (((tot[0] / 2) + (tot[1] / 2)) * 2) + (tot[0] - tot[0] / 2 * 2) * 3LL;\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// #includes {{{\n#include <bits/stdc++.h>\nusing namespace std;\n \n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define RREP(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define FOR(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();++i)\n#define LET(x,a) __typeof(a) x(a)\n//#define IFOR(i,it,c) for(__typeof((c).begin())it=(c).begin();it!=(c).end();++it,++i)\n#define ALL(c) (c).begin(), (c).end()\n#define MP make_pair\n \n#define EXIST(e,s) ((s).find(e)!=(s).end())\n \n#define RESET(a) memset((a),0,sizeof(a))\n#define SET(a) memset((a),-1,sizeof(a))\n#define PB push_back\n#define DEC(it,command) __typeof(command) it=command\n \n//debug\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n#define debug2(x) cerr << #x << \" = [\";REP(__ind,(x).size()){cerr << (x)[__ind] << \", \";}cerr << \"] (L\" << __LINE__ << \")\" << endl;\n \nconst int INF=0x3f3f3f3f;\n \ntypedef long long Int;\ntypedef unsigned long long uInt;\ntypedef long double rn;\n \ntypedef pair<int,int> pii;\n \n/*\n#ifdef MYDEBUG\n#include\"debug.h\"\n#include\"print.h\"\n#endif\n*/\n// }}}\n \n//{{{ io\nFILE *file_in=stdin,*file_out=stdout;\n#define fin normal_in\n#define fout normal_out\n//const char fname[]=\"\";\n//FILE *fin=fopen(fname,\"r\"),*fout=fopen(fname,\"w\");\n#ifdef __MINGW32__\n#define LLD \"%I64d\"\n#define LLU \"%I64u\"\n#else\n#define LLD \"%lld\"\n#define LLU \"%llu\"\n#endif\nstruct NORMAL_IN{\n\tbool cnt;\n\tNORMAL_IN():cnt(true){}\n\toperator int() const {return cnt;}\n#define endl \"\\n\"\n\tNORMAL_IN& operator>>(int &n){cnt=fscanf(file_in,\"%d\",&n)!=EOF;return *this;}\n\tNORMAL_IN& operator>>(unsigned int &n){cnt=fscanf(file_in,\"%u\",&n)!=EOF;return *this;}\n\tNORMAL_IN& operator>>(long long &n){cnt=fscanf(file_in,LLD,&n)!=EOF;return *this;}\n\tNORMAL_IN& operator>>(unsigned long long &n){cnt=fscanf(file_in,LLU,&n)!=EOF;return *this;}\n\tNORMAL_IN& operator>>(double &n){cnt=fscanf(file_in,\"%lf\",&n)!=EOF;return *this;}\n\tNORMAL_IN& operator>>(long double &n){cnt=fscanf(file_in,\"%Lf\",&n)!=EOF;return *this;}\n\tNORMAL_IN& operator>>(char *c){cnt=fscanf(file_in,\"%s\",c)!=EOF;return *this;}\n\tNORMAL_IN& operator>>(string &s){\n\t\ts.clear();\n\t\tfor(bool r=false;;){\n\t\t\tconst char c=getchar();\n\t\t\tif(c==EOF){ cnt=false; break;}\n\t\t\tconst int t=isspace(c);\n\t\t\tif(!r and !t)r=true;\n\t\t\tif(r){\n\t\t\t\tif(!t)s.push_back(c);\n\t\t\t\telse break;\n\t\t\t}\n\t\t}\n\t\treturn *this;\n\t}\n\ttemplate<class T>\n\t\tNORMAL_IN& operator>>(vector<T> &v){\n\t\t\tint n;fscanf(file_in,\"%d\",&n);\n\t\t\tREP(i,n){\n\t\t\t\tT t;*this>>t;\n\t\t\t\tv.push_back(t);\n\t\t\t}\n\t\t}\n} normal_in;\n \nstruct NORMAL_OUT{\n\tNORMAL_OUT& operator<<(const int &n){fprintf(file_out,\"%d\",n);return *this;}\n\tNORMAL_OUT& operator<<(const unsigned int &n){fprintf(file_out,\"%u\",n);return *this;}\n\tNORMAL_OUT& operator<<(const long long &n){fprintf(file_out,LLD,n);return *this;}\n\tNORMAL_OUT& operator<<(const unsigned long long &n){fprintf(file_out,LLU,n);return *this;}\n\tNORMAL_OUT& operator<<(const double &n){fprintf(file_out,\"%lf\",n);return *this;}\n\tNORMAL_OUT& operator<<(const long double &n){fprintf(file_out,\"%Lf\",n);return *this;}\n\tNORMAL_OUT& operator<<(const char c[]){fprintf(file_out,\"%s\",c);return *this;}\n\tNORMAL_OUT& operator<<(const string &s){fprintf(file_out,\"%s\",s.c_str());return *this;}\n} normal_out;\n//}}}\n \n//{{{ Graph\ntemplate<class Weight>\nstruct Edge {\n\tint src, dst, rev;\n\tWeight weight;\n\tEdge(int src, int dst, Weight weight=1,int rev=-1) :\n\t\tsrc(src), dst(dst), weight(weight), rev(rev) { }\n};\ntemplate<class Weight>\nbool operator < (const Edge<Weight> &e, const Edge<Weight> &f) {\n\treturn e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n\t\te.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\n//typedef vector<Edge> Edges;\n//typedef vector<Edges> Graph;\n \n//typedef vector<Weight> Array;\n//typedef vector<Array> Matrix;\n \ntemplate<class Weight=int>\nstruct Graph:vector<vector<Edge<Weight> > >{\n\tGraph(){}\n\tGraph(const int &n){this->assign(n,vector<Edge<Weight> >());}\n\tvoid _add_edge(int from, int to, Weight w, int rev=-1){\n\t\tif(this->size() < from + 1)this->resize(from + 1);\n\t\tthis->at(from).push_back(Edge<Weight>(from,to,w,rev));\n\t}\n};\n//add bi-directional edge\ntemplate<class Weight>\nvoid addBiEdge(Graph<Weight> &g, const pair<int,int> &e, Weight w=1){\n\tconst int &from = e.first, &to = e.second;\n\tg._add_edge(from,to,w,g[to].size());\n\tg._add_edge(to,from,w,g[from].size()-1);\n//\twhile(this->size()<max(from,to)+1)this->push_back(vector<Edge<Weight> >());\n//\tthis->at(from).push_back(Edge<Weight>(from,to,w,this->at(to).size()));\n//\tthis->at(to).push_back(Edge<Weight>(to,from,w,this->at(from).size()-1));\n}\n//add directional edge\ntemplate<class Weight>\nvoid addEdge(Graph<Weight> &g, const pair<int,int> &e, Weight w=1){\n\tconst int &from = e.first, &to = e.second;\n\tg._add_edge(from,to,w);\n//\twhile(this->size()<from+1)this->push_back(vector<Edge<Weight> >());\n//\tthis->at(from).push_back(Edge<Weight>(from,to,w));\n}\n\n#ifdef DEBUG\n#include\"graph/graphviz.h\"\n#endif\n//}}}\n\n//typedef Weight Flow;\n//typedef long long Cost;\n\n\n//{{{ addFlowEdge(Graph<Flow,Cost>, {from,to},{Flow,Cost})\ntemplate<class Flow,class Cost>\nvoid addFlowEdge(Graph<pair<Flow,Cost> > &g,const pair<int,int> &e,const pair<Flow,Cost> &p){\n\tint from = e.first, to = e.second;\n\tFlow cap = p.first;Cost cost = p.second;\n\tg._add_edge(from,to,{cap,cost},g[to].size());\n\tg._add_edge(to,from,{0,-cost},g[from].size()-1);\n//\tg[from].push_back(Edge<pair<Flow,Cost> >(from,to,{cap,cost},g[to].size()));\n//\tg[to].push_back(Edge<pair<Flow,Cost> >(to,from,{0,-cost},g[from].size()-1));\n}\n//}}}\n//{{{ minCostFlow(Graph<Flow,Cost> g,{s,t},f)\ntemplate<class Flow,class Cost>\nstruct minCostFlow_t{\n\tvector<vector<Flow> > flow;\n\tbool feasible;\n\tCost val;\n\toperator bool(){return feasible;}\n\tCost operator*(){return val;}\n};\n\ntemplate<class Flow,class Cost>\nminCostFlow_t<Flow,Cost> minCostFlow(const Graph<pair<Flow,Cost> > &g,const pair<int,int> &st,Flow f){\n\tconst int n = g.size();\n\tconst int s = st.first, t = st.second;\n\tminCostFlow_t<Flow,Cost> ret;\n\tvector<vector<Flow> > &flow = ret.flow;\n\tflow.assign(n,vector<Flow>());\n\tconst Flow FINF=1e+9;\n\tconst Cost CINF=1e+18;\n\n\tREP(i,n)REP(j,g[i].size())flow[i].push_back(g[i][j].weight.first);\n\tvector<Cost> dist(n);\n\tvector<int> prevv(n),preve(n);\n\tCost res=0;\n\twhile(f>0){\n\t\tfill(ALL(dist),CINF);\n\t\tdist[s]=0;\n\t\tbool update=true;\n\t\twhile(update){\n\t\t\tupdate=false;\n\t\t\tfor(int v=0;v<n;v++){\n\t\t\t\tif(dist[v]==CINF)continue;\n\t\t\t\tfor(int i=0;i<g[v].size();i++){\n\t\t\t\t\tconst auto &e=g[v][i];\n\t\t\t\t\tif(flow[v][i]>0 && dist[e.dst]>dist[v]+e.weight.second){\n\t\t\t\t\t\tdist[e.dst]=dist[v]+e.weight.second;\n\t\t\t\t\t\tprevv[e.dst]=v;preve[e.dst]=i;\n\t\t\t\t\t\tupdate=true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(dist[t]==CINF){\n\t\t\tret.feasible = false;\n\t\t\treturn ret;\n\t\t}\n\t\tFlow d=f;\n\t\tfor(int v=t;v!=s;v=prevv[v]){\n\t\t\td=min(d,flow[prevv[v]][preve[v]]);\n\t\t}\n\t\tf-=d;\n\t\tres+=d*dist[t];\n\t\tfor(int v=t;v!=s;v=prevv[v]){\n\t\t\tconst auto &e=g[prevv[v]][preve[v]];\n\t\t\tflow[prevv[v]][preve[v]]-=d;\n\t\t\tflow[v][e.rev]+=d;\n\t\t}\n\t}\n\tret.feasible = true;\n\tret.val = res;\n\treturn ret;\n}\n//}}}\n\nconst int SMAX=10000;\nint pdiv[SMAX];\nvector<int> primes;\n//{{{ eratosthenes\nvoid sieve_of_eratosthenes(int n) {\n\tfor (int i = 2; i < n; ++i)\n\t\tpdiv[i] = i;\n\tfor (int i = 2; i*i < n; ++i)\n\t\tif (pdiv[i]==i)\n\t\t\tfor (int j = i*i; j < n; j+=i)\n\t\t\t\tpdiv[j] = i;\n}\n//}}}\nbool is_prime(int n){\n\tif(n==1)return false;\n\tfor(int i=0;;i++){\n\t\tint p = primes[i];\n\t\tif(p*p>n)break;\n\t\tif(n%p==0)return false;\n\t}\n\treturn true;\n}\n\nvoid solve(long long N, vector<long long> x){\n\tvector<int> v0,v1;\n\tfor(int i=0;i<x.size();){\n\t\tint j;\n\t\tfor(j=i+1;j<x.size();j++){\n\t\t\tif(x[j-1]+1!=x[j])break;\n\t\t}\n\t\t//[ x[i], x[j-1]+1 )\n\t\tvector<Int> v{x[i],x[j-1]+1};\n\t\tfor(auto u:v){\n\t\t\tif(u%2==0)v0.push_back(u);\n\t\t\telse v1.push_back(u);\n\t\t}\n\t\ti = j;\n\t}\n\tGraph<pair<int,Int> > g(v0.size()+v1.size()+2);\n\tint s = v0.size() + v1.size(), t = s + 1;\n\tREP(i,v0.size())REP(j,v1.size()){\n\t\tif(is_prime(abs(v0[i]-v1[j]))){\n\t\t\taddFlowEdge(g,{i,j+v0.size()},{10000,1});\n\t\t}else{\n\t\t\taddFlowEdge(g,{i,j+v0.size()},{10000,3});\n\t\t}\n\t}\n\tREP(i,v0.size())addFlowEdge(g,{s,i},{1,0});\n\tREP(j,v1.size())addFlowEdge(g,{j+v0.size(),t},{1,0});\n\tInt ans = INF;\n\tint r = v0.size()%2;\n\tfor(int f=r;;f+=2){\n\t\tif(v0.size()<f or v1.size()<f)break;\n\t\tauto mcf(minCostFlow(g,{s,t},f));\n\t\tassert(mcf);\n\t\tauto c = *mcf;\n\t\tc+=v0.size()+v1.size()-f*2;\n\t\tans = min(c,ans);\n\t}\n\tfout<<ans<<endl;\n}\n\nint main(){\n\tGraph<> g;\n\tsieve_of_eratosthenes(SMAX);\n\tfor(int p=2;p<SMAX;p++)if(pdiv[p]==p)primes.push_back(p);\n\tlong long N;\n\tfin >> N;\n\tvector<long long> x(N-1+1);\n\tfor(int i = 0 ; i <= N-1 ; i++){\n\t\tfin >> x[i];\n\t}\n\tsolve(N, x);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define Mem(a,b) memset(a,b,sizeof(a))\n#define ll long long\n#define lson root<<1\n#define rson root<<1|1\n#define Mid int mid=(l+r)>>1\n#define FREI freopen(\"in.txt\",\"r\",stdin)\n#define FREO freopen(\"out.txt\",\"w\",stdout)\n#define inf 0x3f3f3f3f\n#define mod 1000000007\n#define PB push_back\nusing namespace std;\nconst int MAXN=1e7+10;\nint n;\nint vis[200];\nstruct fc{\n    int v,cost;\n};\nvector<int>point;\nvector<int>X,Y;\nvector<fc>G[110];\nbool used[220];\nint pre[220];\nvoid pretreat(){\n    Mem(vis,0);\n    point.clear();\n    scanf(\"%d\",&n);\n    for(int i=0;i<n;i++){\n        scanf(\"%d\",&vis[i]);\n    }\n    sort(vis,vis+n);\n    for(int i=0;i<n;i++){\n        if(i==0) point.PB(vis[i]);\n        if(i>0&&vis[i]!=vis[i-1]+1) {\n            point.PB(vis[i]);\n            //cout<<i<<' '<<vis[i]<<endl;\n        }\n        if(vis[i+1]!=vis[i]+1){\n            point.PB(vis[i]+1);\n            //cout<<vis[i]+1<<endl;\n        }\n    }\n    for(auto u:point){\n        //cout<<u<<' ';\n        if(u&1) Y.push_back(u);\n        else X.push_back(u);\n    }\n    //cout<<endl;\n//    for(auto u:X){\n//        cout<<u<<' ';\n//    }\n//    cout<<endl;\n//    for(auto v:Y){\n//        cout<<v<<' ';\n//    }\n//    cout<<endl;\n}\nbool isprime(int x){\n    if(x==1||x==2) return false;\n    for(int i=2;i*i<=x;i++){\n        if(x%i==0) return false;\n    }\n    return true;\n}\nvoid build_graph(){\n    for(int i=0;i<X.size();i++){\n        for(int j=0;j<Y.size();j++){\n\n            if(isprime(abs(Y[j]-X[i]))){\n                G[i+1].PB({j+1,abs(Y[j]-X[i])});\n                //cout<<abs(Y[j]-X[i])<<' '<<X[i]<<' '<<Y[j]<<endl;\n            }\n\n        }\n    }\n}\n\nbool dfs(int u){\n    for(int i=0;i<G[u].size();i++){\n        int v=G[u][i].v,cost=G[u][i].cost;\n\n        if(!used[v]){\n            used[v]=1;\n            if(!pre[v]||dfs(pre[v])){\n                pre[v]=u;\n                return true;\n            }\n        }\n    }\n    return false;\n}\nint solve(){\n    Mem(pre,0);\n    int ans=0;\n    for(int i=1;i<=X.size();i++){\n        Mem(used,0);\n        if(dfs(i)) ans++;\n    }\n    //for(int i=1;i<=Y.size();i++) cout<<pre[i]<<endl;\n    //cout<<ans<<endl;\n    //cout<<X.size()<<endl;\n    return ans+(X.size()-ans)/2*2+(Y.size()-ans)/2*2+((X.size()-ans)%2)*3;\n}\nint main() {\n    //FREI;\n    //cout<<isprime(165)<<endl;\n    pretreat();\n    build_graph();\n    printf(\"%d\\n\",solve());\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int maxn = 220;\nconst int maxx = 11000000;\n\nint x[maxn];\nvector<int> pos;\nbool nprm[maxx] = {true, true};\nvector<int> g[maxn];\nvector<int> x1, x2;\nbool vis[maxn];\nint link[maxn];\n\ninline bool dfs(int u) {\n\tif(vis[u]) return false;\n\tvis[u] = true;\n\tfor(auto v : g[u]) {\n\t\tif(link[v] == -1 || dfs(link[v])) {\n\t\t\tlink[v] = u;\n\t\t\tlink[u] = v;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\ninline void init() {\n\tfor(int i = 2; i * i < maxx; ++ i) if(!nprm[i])\n\t\tfor(int j = i + i; j < maxx; j += i) nprm[j] = true;\n}\n\nint main() {\n\tios::sync_with_stdio(0);\n\tcin.tie(0); cout.tie(0);\n\tinit();\n\tint n; cin >> n;\n\tfor(int i = 1; i <= n; ++ i) cin >> x[i];\n\tpos.push_back(x[1]);\n\tfor(int i = 2; i <= n; ++ i) {\n\t\tif(x[i] == x[i - 1] + 1) continue;\n\t\tpos.push_back(x[i - 1] + 1); pos.push_back(x[i]);\n\t}\n\tpos.push_back(x[n] + 1);\n\tint sz = pos.size();\n\tfor(int i = 0; i < sz; ++ i) if(pos[i] & 1) x1.push_back(i); else x2.push_back(i);\n\tfor(auto i : x1) for(auto j : x2) if(i < j && !nprm[pos[j] - pos[i]] || i > j && !nprm[pos[i] - pos[j]]) g[i].push_back(j);\n\tmemset(link, 0xff, sizeof link);\n\tint mx = 0;\n\tfor(auto i : x1) {\n\t\tmemset(vis, false, sizeof vis);\n\t\tif(dfs(i)) ++ mx;\n\t}\n\tint ans = mx;\n\tint c1 = (x1.size() - mx) / 2, l1 = (x1.size() - mx) & 1;\n\tint c2 = (x2.size() - mx) / 2, l2 = (x2.size() - mx) & 1;\n\tif(l1 && l2) {\n\t\tans += 3;\n\t\tl1 = l2 = 0;\n\t}\n\tans += c1 * 2 + l1 * 3;\n\tans += c2 * 2 + l2 * 3;\n\tcout << ans << \"\\n\";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <iostream>\n#include <algorithm>\n#define fo(i,a,b) for(int i=a;i<=b;i++)\n#define fod(i,a,b) for(int i=a;i>=b;i--)\n#define N 2005\nusing namespace std;\nint l[N],n,a[N],r[N],w[N],pr[5000005],f[N],a1[N][N];\nbool bz[20000005],bp[N];\nvoid prp()\n{\n\tfo(i,2,20000000)\n\t{\n\t\tif(!bz[i]) pr[++pr[0]]=i;\n\t\tfor(int j=1;j<=pr[0]&&i*pr[j]<=20000000;j++)\n\t\t{\n\t\t\tbz[i*pr[j]]=1;\n\t\t\tif(i%pr[j]==0) break;\n\t\t}\n\t}\n\tbz[2]=1;\n}\nbool find(int k)\n{\n\tfo(i,1,a1[k][0])\n\t{\n\t\tint p=a1[k][i];\n\t\tif(!bp[p])\n\t\t{\n\t\t\tbp[p]=1;\n\t\t\tif(!f[p]||find(f[p])) \n\t\t\t{\n\t\t\t\tf[p]=k;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nint main()\n{\n\tcin>>n;\n\tprp();\n\tfo(i,1,n) scanf(\"%d\",&a[i]);\n\tsort(a+1,a+n+1);\n\tfo(i,1,n) \n\t{\n\t\tif(i==1||a[i-1]!=a[i]-1) w[++w[0]]=i;\n\t\tif(a[i+1]!=a[i]+1) w[++w[0]]=i+1;\n\t}\n\tsort(w+1,w+w[0]+1);\n\tfo(i,1,w[0]) \n\t\tif(w[i]%2==0) l[++l[0]]=i;\n\t\telse r[++r[0]]=i;\n\tfo(i,1,l[0])\n\t{\n\t\tfo(j,1,r[0])\n\t\t{\n\t\t\tif(!bz[abs(l[i]-r[j])]) a1[i][++a1[i][0]]=j;\n\t\t}\n\t}\n\tlong long s=0;\n\tfo(i,1,l[0]) \n\t{\n\t\tmemset(bp,0,sizeof(bp));\n\t\tif(find(i)) s++;\n\t}\n\tprintf(\"%lld\",s+2*(long long)((l[0]-s)/2)+2*(long long)((r[0]-s)/2)+3*(long long)((l[0]-s)%2));\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint n,x,a[222],b[222],na,nb,c,ans,G[222][222],pre[222],used[222];\nmap<int,int>mp;\n\nbool pri(int x){\n\tif (x==1) return 0;\n\tfor (int i=3;i*i<=x;++i) if (x%i==0) return 0;\n\treturn 1;\n}\n\nint dfs(int x){\n\tfor (int i=1;i<=nb;++i) if (!used[i]&&G[x][i]){\n\t\tused[i]=1;\n\t\tif (!pre[i]||dfs(pre[i])){\n\t\t\tpre[i]=x;\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nint main(){\n\tfor (cin>>n;n--;)\n\t\tcin>>x, mp[x]^=1, mp[x+1]^=1;\n\tfor (auto o:mp) if (o.second)\n\t\t(o.first&1? a[++na]: b[++nb])=o.first;\n\tfor (int i=1;i<=na;++i)\n\t\tfor (int j=1;j<=nb;++j) if (pri(abs(a[i]-b[j])))\n\t\t\tG[i][j]=1;\n\tfor (int i=1;i<=na;++i){\n\t\tmemset(used,0,sizeof used);\n\t\tc+=dfs(i);\n\t}\n\tans=c+((na-c)/2+(nb-c)/2)*2+(na-c)%2*3;\n\tcout<<ans;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\nusing namespace std;\nstruct edge{\n\tint k,next;\n}e[1000005];\nint n,a[1005],x[1005],m,home[1005],cnt=-1,flag[1005],y[1005];\nbool vis[10000005];\nvoid add(int x,int y){\n\tcnt++;\n\te[cnt].k=y;\n\te[cnt].next=home[x];\n\thome[x]=cnt;\n}\nint prime[10000005],cc=-1;\nbool isprime[10000005];\nvoid init(){\n\tisprime[1]=1;\n\tfor(int i=2;i<=10000002;i++){\n\t\tif(!isprime[i]){\n\t\t\tprime[++cc]=i;\n\t\t}\n\t\tfor(int p=1;p<=cc&&prime[p]*i<=10000002;p++){\n\t\t\tisprime[prime[p]*i]=1;\n\t\t\tif(i%prime[p]==0) break;\n\t\t}\n\t}\n}\nint Abs(int a){return a<0?-a:a;}\nbool used[2005];\nbool dfs(int k){\n\tfor(int i=home[k];~i;i=e[i].next) if(!used[e[i].k]){\n\t\tused[e[i].k]=1;\n\t\tif(!flag[e[i].k]||dfs(flag[e[i].k])){\n\t\t\tflag[e[i].k]=k;\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\nint main(){\n\tinit();\n\tmemset(home,-1,sizeof(home));\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++) scanf(\"%d\",&a[i]),vis[a[i]]=1;\n\tint o=a[n]+1;n=0;\n\tfor(int i=1;i<=o;i++) if(vis[i]!=vis[i-1]){\n\t\tif(i&1) x[++n]=i;\n\t\telse y[++m]=i;\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int p=1;p<=m;p++) if(!isprime[Abs(x[i]-y[p])]) add(i,p);\n\t}\n\tint ans=0;\n\tfor(int i=1;i<=n;i++){\n\t\tmemset(used,0,sizeof(used));\n\t\tif(dfs(i)) ans++;\n\t}\n\tans+=(n-ans)/2*2+(m-ans)/2*2;\n\tn=(n-ans)%2;m=(m-ans)%2;\n\tif(n&&m) ans+=3;\n\tprintf(\"%d\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\ntypedef std::pair <int, int> pr;\ntypedef std::map <int, int> map;\nconst int N = 108;\n\nint n, O, E;\nint o[N], e[N];\nmap S;\nint pn = 0, c[10000054], p[666666];\n\nvoid sieve(int n) {\n\tint i, j, v;\n\tmemset(c, -1, sizeof c);\n\tfor (i = 2; i <= n; ++i) {\n\t\tif (!~c[i]) p[pn] = i, c[i] = pn++;\n\t\tfor (j = 0; (v = i * p[j]) <= n && j <= c[i]; ++j) c[v] = j;\n\t}\n}\n\ninline bool is_prime(int x) {return p[c[x]] == x;}\n\nnamespace CF {\n\t#define ad(x) ((x - 1 ^ 1) + 1)\n\n\tconst int N = 2000, M = 100000, INF = 0x7f7f7f7f;\n\n\tstruct edge {\n\t\tint u, v, c, f;\n\t\tedge (int u0 = 0, int v0 = 0, int c0 = 0, int f0 = 0) : u(u0), v(v0), c(c0), f(f0) {}\n\t} e[M];\n\n\tint V = 2, E = 0, si = 1, ti = 2, flow, cost;\n\tint first[N], next[M];\n\tint dep[N], cur[N], que[M << 1];\n\tbool in_que[N], used[N];\n\n\tinline void addedge(int u, int v, int c, int f) {\n\t\te[++E] = edge(u, v, c, f), next[E] = first[u], first[u] = E;\n\t\te[++E] = edge(v, u, -c), next[E] = first[v], first[v] = E;\n\t}\n\n\tbool bfs() {\n\t\tint h = M, t = h + 1, i, x, y;\n\t\tmemset(dep, 127, sizeof dep);\n\t\tque[h] = ti, dep[ti] = 0, in_que[ti] = true;\n\t\tfor (; h < t; ) {\n\t\t\tx = que[h++], in_que[x] = false;\n\t\t\tfor (i = first[x]; i; i = next[i])\n\t\t\t\tif (dep[y = e[i].v] > dep[x] - e[i].c && e[ad(i)].f) {\n\t\t\t\t\tdep[y] = dep[x] - e[i].c;\n\t\t\t\t\tif (!in_que[y])\n\t\t\t\t\t\tin_que[y] = true, (dep[y] >= dep[que[h]] ? que[t++] : que[--h]) = y;\n\t\t\t\t}\n\t\t}\n\t\treturn dep[si] < INF;\n\t}\n\n\tint dfs(int x, int lim) {\n\t\tint a, c, f = 0;\n\t\tif (x == ti || !lim) return lim;\n\t\tused[x] = true;\n\t\tfor (int &i = cur[x]; i; i = next[i])\n\t\t\tif (dep[e[i].v] == dep[x] - e[i].c && e[i].f && !used[e[i].v]) {\n\t\t\t\ta = std::min(lim - f, e[i].f);\n\t\t\t\tc = dfs(e[i].v, a);\n\t\t\t\te[i].f -= c, e[ad(i)].f += c;\n\t\t\t\tif ((f += c) == lim) return f;\n\t\t\t}\n\t\treturn f;\n\t}\n\n\tint Dinic() {\n\t\tint f;\n\t\tfor (cost = flow = 0; bfs(); ) {\n\t\t\tmemcpy(cur, first, sizeof cur);\n\t\t\tmemset(used, 0, sizeof used);\n\t\t\tflow += f = dfs(si, INF);\n\t\t\tcost += dep[si] * f;\n\t\t}\n\t\treturn cost;\n\t}\n}\n\nint main() {\n\tint i, j, x;\n\tscanf(\"%d\", &n), sieve(10000053);\n\tfor (i = 0; i < n; ++i) scanf(\"%d\", &x), ++S[x], ++S[x + 1];\n\tfor (const pr &p : S) if (p.second & 1) (p.first & 1 ? o[O++] : e[E++]) = p.first;\n\tfor (i = 0; i < O; ++i) CF::addedge(1, 3 + i, 0, 1);\n\tfor (j = 0; j < E; ++j) CF::addedge(3 + O + j, 2, 0, 1);\n\tfor (i = 0; i < O; ++i)\n\t\tfor (j = 0; j < E; ++j)\n\t\t\tCF::addedge(3 + i, 3 + O + j, is_prime(abs(o[i] - e[j])) ? 1 : 3, 1);\n\tprintf(\"%d\\n\", CF::Dinic() + abs(O - E));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<cmath>\nconst int N=102;\nint n,cnp,cnj,cnt,og[N],hx[N<<1],fir[N<<1],prm[460];\nbool npr[3200];\nstruct edge{\n\tint to,wi,nx;\n}eg[N*N];\n\ninline void add(int a,int b,int v){\n\tstatic int cnt=1;\n\teg[++cnt]=(edge){b,v,fir[a]};\n\tfir[a]=cnt;\n\teg[++cnt]=(edge){a,0,fir[b]};\n\tfir[b]=cnt;\n}\n\ninline char get_c(){\n\tstatic char buf[20000],*h,*t;\n\tif(h==t){\n\t\tt=(h=buf)+fread(buf,1,20000,stdin);\n\t}\n\treturn h==t?EOF:*h++;\n}\n\ninline int nxi(){\n\tint x=0;\n\tchar c;\n\twhile((c=get_c())>'9'||c<'0');\n\twhile(x=x*10-48+c,(c=get_c())>='0'&&c<='9');\n\treturn x;\n}\n\ninline void init(){\n\tnpr[1]=1;\n\tfor(int i=2;i<3200;++i){\n\t\tif(!npr[i]) prm[++cnp]=i;\n\t\tfor(int j=1;j<=cnp&&i*prm[j]<3200;++j){\n\t\t\tnpr[i*prm[j]]=1;\n\t\t\tif(i%prm[j]==0) break;\n\t\t}\n\t}\n}\n\ninline bool ispr(int x){\n\tif(x<3200) return !npr[x];\n\tint sq=sqrt(x)+1;\n\tfor(int i=1;prm[i]<=sq;++i){\n\t\tif(x%prm[i]==0) return 0;\n\t}\n\treturn 1;\n}\n\nnamespace F{\n\tint dep[N<<1],que[N<<1],cur[N<<1];\n\n\tinline bool bfs(){\n\t\tint hd=0,tl=1;\n\t\tdep[0]=1;\n\t\twhile(hd!=tl){\n\t\t\tint x=que[hd++];\n\t\t\tfor(int i=cur[x]=fir[x];i;i=eg[i].nx){\n\t\t\t\tint y=eg[i].to;\n\t\t\t\tif(eg[i].wi&&!dep[y]){\n\t\t\t\t\tdep[y]=dep[x]+1;\n\t\t\t\t\tque[tl++]=y;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn dep[(N<<1)-1];\n\t}\n\n\tint dfs(int x,int t){\n\t\tif(x==(N<<1)-1) return t;\n\t\tint tp,tt=t;\n\t\tfor(int &i=cur[x];i;i=eg[i].nx){\n\t\t\tint y=eg[i].to,v=eg[i].wi;\n\t\t\tif(v&&tt&&dep[x]+1==dep[y]&&(tp=dfs(y,std::min(v,tt)))){\n\t\t\t\teg[i].wi-=tp;\n\t\t\t\teg[i^1].wi+=tp;\n\t\t\t\ttt-=tp;\n\t\t\t\tif(!tt) break;\n\t\t\t}\n\t\t}\n\t\treturn t-tt;\n\t}\n}\n\nint main(){\n#ifndef ONLINE_JUDGE\n//\tfreopen(\"c.in\",\"r\",stdin);\n#endif\n\tinit();\n\tn=nxi();\n\tfor(int i=1;i<=n;++i){\n\t\tog[i]=nxi();\n\t}\n\tstd::sort(og+1,og+n+1);\n\tog[0]=-1;\n\tfor(int i=1;i<=n;++i){\n\t\tif(og[i]-og[i-1]>1){\n\t\t\tif(og[i-1]+1) hx[++cnt]=og[i-1]+1;\n\t\t\thx[++cnt]=og[i];\n\t\t}\n\t}\n\thx[++cnt]=og[n]+1;\n\tfor(int i=1;i<=cnt;++i){\n\t\tif(hx[i]&1) ++cnj;\n\t\tif(hx[i]&1) add(0,i,1);\n\t\telse add(i,(N<<1)-1,1);\n\t\tfor(int j=i+1;j<=cnt;++j){\n\t\t\tint p=hx[j]-hx[i];\n\t\t\tif((p&1)&&ispr(p)){\n\t\t\t\tif(hx[i]&1) add(i,j,1);\n\t\t\t\telse add(j,i,1);\n\t\t\t}\n\t\t}\n\t}\n\tint ans=0;\n\twhile(F::bfs()){\n\t\tans+=F::dfs(0,N);\n\t}\n//\tprintf(\"%d %d %d\\n\",cnt,ans,cnj&1);\n\tprintf(\"%d\\n\",cnt-ans+(cnj&1));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n// flow from KACTL\ntypedef long long LL;\nstruct Flow{\n\tint n;\n\tvector<vector<int> > graph; //list of id's\n\tvector<int> st, en, back; //back = back edge id\n\tvector<LL> f, c;\n\tvector<int> par;\n\tFlow(int n): n(n), graph(n), par(n){}\n\tvoid add_edge(int u, int v, int cap){\n\t\tint id1 = st.size();\n\t\tint id2 = id1 + 1;\n\t\tst.push_back(u); st.push_back(v);\n\t\ten.push_back(v); en.push_back(u);\n\t\tback.push_back(id2); back.push_back(id1);\n\t\tf.push_back(0); f.push_back(0);\n\t\tc.push_back(cap); c.push_back(0);\n\t\tgraph[u].push_back(id1);\n\t\tgraph[v].push_back(id2);\n\t}\n\n\tvoid add(int id1, int v){\n\t\tf[id1] += v;\n\t\tc[id1] -= v;\n\t\tf[back[id1]] -= v;\n\t\tc[back[id1]] += v;\n\t}\n\n\tLL maxflow(int s, int t){\n\t\tLL ans = 0;\n\t\tvector<int> bfs;\n\t\tif(s == t) return ans;\n\t\twhile(1){\n\t\t\tfor(int i = 0; i < n; i++) par[i] = -1;\n\t\t\tbfs.clear();\n\t\t\tbfs.push_back(s); par[s] = -2;\n\t\t\tint cur = 0;\n\t\t\twhile(cur < bfs.size()){\n\t\t\t\tint u = bfs[cur]; cur++;\n\t\t\t\tfor(int i = 0; i < graph[u].size(); i++){\n\t\t\t\t\tint id = graph[u][i];\n\t\t\t\t\tif(c[id] == 0) continue;\n\t\t\t\t\tif(par[en[id]] != -1) continue;\n\t\t\t\t\tpar[en[id]] = id;\n\t\t\t\t\tbfs.push_back(en[id]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(par[t] == -1) break;\n\t\t\tLL send = 4e18;\n\t\t\tint curv = t;\n\t\t\twhile(par[curv] != -2){\n\t\t\t\tsend = min(send, c[par[curv]]);\n\t\t\t\tcurv = st[par[curv]];\n\t\t\t}\n\t\t\tcurv = t;\n\t\t\twhile(par[curv] != -2){\n\t\t\t\tadd(par[curv], send);\n\t\t\t\tcurv = st[par[curv]];\n\t\t\t}\n\t\t\tans += send;\n\t\t}\n\t\treturn ans;\n\t}\n};\nint main(){\n\tint n;\n\tcin >> n;\n\tint z[n];\n\tmap<int,int> f;\n\tfor(int i = 0; i < n; i++){\n\t\tcin >> z[i];\n\t\tf[z[i]]++;\n\t\tf[z[i]+1]++;\n\t}\n\tvector<int> r;\n\tvector<int> odd, even;\n\tfor(map<int,int>::iterator it = f.begin(); it != f.end(); it++){\n\t\tif(it->second == 1){\n\t\t\tr.push_back(it->first);\n\t\t\tif(it->first % 2){\n\t\t\t\todd.push_back(it->first);\n\t\t\t} else {\n\t\t\t\teven.push_back(it->first);\n\t\t\t}\n\t\t}\n\t}\n\tFlow s(300);\n\tfor(int i = 0; i < 100; i++){\n\t\ts.add_edge(200,i,1);\n\t\ts.add_edge(i+100,201,1);\n\t}\n\tfor(int i = 0; i < odd.size(); i++){\n\t\tfor(int j = 0; j < even.size(); j++){\n\t\t\tint a = odd[i];\n\t\t\tint b = even[j];\n\t\t\t//cout << a << \" \" << b << endl;\n\t\t\tint p = abs(a-b);\n\t\t\tint ok = 1;\n\t\t\tif(p <= 1) ok = 0;\n\t\t\tfor(int c = 2; c*c <= p; c++){\n\t\t\t\tif(p % c == 0){\n\t\t\t\t\tok = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(ok){\n\t\t\t\ts.add_edge(i,j+100,1);\n\t\t\t}\n\t\t}\n\t}\n\tint flow = (int)s.maxflow(200,201);\n\tint o1 = (int)odd.size() - flow;\n\tint e1 = (int)even.size() - flow;\n\tint ans = flow;\n\tans += (o1/2)*2;\n\tans += (e1/2)*2;\n\to1 %= 2;\n\te1 %= 2;\n\tif(o1 >= 1){\n\t\tans += 3;\n\t}\n\tcout << ans << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n//ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n//clock_t start=clock();clock_t end=clock();cout<<(double)(end-start)/CLOCKS_PER_SEC<<endl;\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef unsigned int ui;\ntypedef pair<int,int> pii;\ntypedef pair<pii,int> ppii;\ntypedef pair<int,pii> pipi;\ntypedef pair<ll,ll> pll;\ntypedef pair<pll,ll> ppll;\ntypedef pair<ll,pll> plpl;\ntypedef tuple<ll,ll,ll> tl;\ntypedef pair<double,double> pdd;\ntypedef vector<vector<ll>> mat;\nll mod=1000000007;\nll mod2=998244353;\nll mod3=1000003;\nll mod4=998244853;\nll mod5=1000000009;\nll inf=1LL<<60;\ndouble pi=3.141592653589793238462643383279L;\ndouble eps=1e-14;\n#define rep(i,m,n) for(ll i=m;i<n;i++)\n#define rrep(i,n,m) for(ll i=n;i>=m;i--)\n#define srep(itr,st) for(auto itr=st.begin();itr!=st.end();itr++)\n#define mrep(itr,mp) for(auto itr=mp.begin();itr!=mp.end();itr++)\n#define Max(a,b) a=max(a,b)\n#define Min(a,b) a=min(a,b)\nint dh[4]={1,-1,0,0};\nint dw[4]={0,0,1,-1};\nint ddh[8]={-1,-1,-1,0,0,1,1,1};\nint ddw[8]={-1,0,1,-1,1,-1,0,1};\nll gcd(ll a,ll b){\n    if(a<b)swap(a,b);\n    if(b==0)return a;\n    if(a%b==0)return b;\n    return gcd(b,a%b);\n}\nll Pow(ll n,ll k){\n    ll ret=1;\n    ll now=n;\n    while(k>0){\n        if(k&1)ret*=now;\n        now*=now;\n        k/=2;\n    }\n    return ret;\n}\nll beki(ll n,ll k,ll md){\n  ll ret=1;\n  ll now=n;\n  while(k>0){\n    if(k%2==1){\n      ret*=now;\n      ret%=md;\n    }\n    now*=now;\n    now%=md;\n    k/=2;\n  }\n  return ret;\n}\nll gyaku(ll n,ll md){\n  return beki(n,md-2,md);\n}\nll popcount(ll n){\n    ll ret=0;\n    ll u=n;\n    while(u>0){\n        ret+=u%2;\n        u/=2;\n        \n    }\n    return ret;\n}\nbool pri(int n){\n    if(n<=2)return false;\n    for(int i=2;i*i<=n;i++){\n        if(n%i==0)return false;\n    }\n    return true;\n}\nint h(int n){\n    if(pri(n))return 1;\n    else if(n%2==0)return 2;\n    else return 3;\n}\nint x[101];\nint n;\nint dfs(set<pii> st,vector<int> v,int las){\n  \n    if(st.size()==0){\n        int cnt[2]={0,0};\n        rep(i,0,v.size())cnt[v[i]%2]++;\n      //cout<<cnt[0]<<\" \"<<cnt[1]<<\" \"<<las<<endl;\n        if(cnt[0]%2==0){\n          if(cnt[1]%2==0)return 0;\n          else{\n            if(las%2==0)return 1;\n            else return 2;\n          }\n        }\n      else{\n        if(cnt[1]%2==0){\n          if(las%2==1)return 1;\n            else return 2;\n        }\n        else{\n          return 1;\n        }\n      }\n    }\n    int mi=1000000000;\n    pii pp=*st.begin();\n    int now=pp.first;\n    srep(itr,st){\n        pii p=*itr;\n        int ri=p.second;\n        if(pri(ri-now+1)==false)continue;\n      //cout<<ri<<endl;\n        set<pii> ne=st;\n        if(itr==st.begin()){\n            ne.erase(ne.begin());\n            if(ne.size()>0)ne.erase(ne.begin());\n            Min(mi,dfs(ne,v,las)+1);\n            continue;\n        }\n        auto itr2=itr;\n        itr2++;\n        if(itr2==st.end()){\n            ne.erase(ne.begin());\n            auto itr3=ne.end();\n            itr3--;\n            ne.erase(itr3);\n            itr3=ne.end();\n            int nl=las;\n            if(ne.size()>0){\n                itr3--;\n                pii ppp=*itr3;\n                nl=ppp.second;\n            }\n            Min(mi,dfs(ne,v,nl)+1);\n            continue;\n        }\n        itr2=itr;\n        pii f=*itr2;\n        itr2++;\n        pii g=*itr2;\n        pii h={f.first,g.second};\n        srep(itr3,ne){\n            pii p2=*itr3;\n            if(p2.first==f.first){\n                itr3=ne.erase(itr3);\n                itr3=ne.erase(itr3);\n                ne.insert(h);\n                break;\n            }\n        }\n        ne.erase(ne.begin());\n        Min(mi,dfs(ne,v,las)+1);\n    }\n    pii ppp=*st.begin();\n    v.push_back(ppp.first);\n    st.erase(st.begin());\n    Min(mi,dfs(st,v,las)+1);\n    return mi;\n}\nint main(){\n    ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n    cin>>n;\n    bool used[100001];\n    fill(used,used+100001,false);\n    rep(i,0,n){\n        cin>>x[i];\n        used[x[i]]=true;\n    }\n    set<pii> st;\n    int now=x[0];\n    rep(i,x[0]+1,x[n-1]+2){\n        if(used[i]!=used[i-1]){\n            st.insert({now,i-1});\n            now=i;\n        }\n    }\n    /*srep(itr,st){\n        pii p=*itr;\n        cout<<p.first<<\" \"<<p.second<<endl;\n    }return 0;*/\n    cout<<dfs(st,{},x[n-1])<<endl;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define rer(i,l,u) for(int (i)=(int)(l);(i)<=(int)(u);++(i))\n#define reu(i,l,u) for(int (i)=(int)(l);(i)<(int)(u);++(i))\nstatic const int INF = 0x3f3f3f3f; static const long long INFL = 0x3f3f3f3f3f3f3f3fLL;\ntypedef vector<int> vi; typedef pair<int, int> pii; typedef vector<pair<int, int> > vpii; typedef long long ll;\ntemplate<typename T, typename U> static void amin(T &x, U y) { if (y < x) x = y; }\ntemplate<typename T, typename U> static void amax(T &x, U y) { if (x < y) x = y; }\n#define each(it,o) for(auto it = (o).begin(); it != (o).end(); ++ it)\n\nint bipartiteMatching(const vector<vector<int> > &g) {\n\tint nleft = g.size(), nright = 0;\n\teach(es, g) if (!es->empty()) nright = max(nright, *max_element(es->begin(), es->end()) + 1);\n\tvi matchL(nleft, -1), matchR(nright, -1), prev(nleft), seen(nleft, -1);\n\trep(i, nleft) {\n\t\tvi stk; stk.push_back(i);\n\t\tseen[i] = i; prev[i] = -1;\n\t\twhile (!stk.empty()) {\n\t\t\tint v = stk.back(); stk.pop_back();\n\t\t\teach(ui, g[v]) {\n\t\t\t\tint u = *ui;\n\t\t\t\tint j = matchR[u];\n\t\t\t\tif (j == -1) {\n\t\t\t\t\twhile (v != -1) {\n\t\t\t\t\t\tmatchR[u] = v;\n\t\t\t\t\t\tswap(u, matchL[v]);\n\t\t\t\t\t\tv = prev[v];\n\t\t\t\t\t}\n\t\t\t\t\tgoto break_;\n\t\t\t\t} else if (seen[j] < i) {\n\t\t\t\t\tseen[j] = i; prev[j] = v;\n\t\t\t\t\tstk.push_back(j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\tbreak_:;\n\t}\n\treturn (int)matchL.size() - count(matchL.begin(), matchL.end(), -1);\n}\n\nvector<bool> isprime;\nvector<int> primes;\nvoid sieve(int n) {\n\tif ((int)isprime.size() >= n + 1) return;\n\tisprime.assign(n + 1, true);\n\tisprime[0] = isprime[1] = false;\n\tint sqrtn = (int)(sqrt(n * 1.) + .5);\n\tfor (int i = 2; i <= sqrtn; i ++) if (isprime[i]) {\n\t\tfor (int j = i * i; j <= n; j += i)\n\t\t\tisprime[j] = false;\n\t}\n\tprimes.clear();\n\tfor (int i = 2; i <= n; i ++) if (isprime[i])\n\t\tprimes.push_back(i);\n}\n\n\nint main() {\n\tsieve(10000002);\n\tint N;\n\twhile (~scanf(\"%d\", &N)) {\n\t\tvector<int> xs(N);\n\t\tfor (int i = 0; i < N; ++ i)\n\t\t\tscanf(\"%d\", &xs[i]);\n\t\tvector<int> diffs;\n\t\trep(i, N) {\n\t\t\tif (i == 0 || xs[i - 1] != xs[i] - 1)\n\t\t\t\tdiffs.push_back(xs[i]);\n\t\t\tif (i == N - 1 || xs[i + 1] != xs[i] + 1)\n\t\t\t\tdiffs.push_back(xs[i] + 1);\n\t\t}\n\t\tvector<int> vertices[2];\n\t\tfor (int x : diffs)\n\t\t\tvertices[x % 2].push_back(x);\n\t\tvector<vi> g(vertices[0].size());\n\t\trep(i, vertices[0].size()) rep(j, vertices[1].size()) {\n\t\t\tint x = vertices[0][i], y = vertices[1][j];\n\t\t\tif (isprime[abs(x - y)])\n\t\t\t\tg[i].push_back(j);\n\t\t}\n\t\tint match = bipartiteMatching(g);\n\t\tint ans = match;\n\t\tint rems = 0;\n\t\trep(k, 2) {\n\t\t\tint rem = (int)vertices[k].size() - match;\n\t\t\tans += rem / 2 * 2;\n\t\t\trems += rem % 2;\n\t\t}\n\t\tans += rems / 2 * 3;\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,a,b) for(int i=a;i<=b;++i)\ntypedef long long ll;\n\nusing namespace std;\n\nvoid File(){\n\tfreopen(\"ARC80F.in\",\"r\",stdin);\n\tfreopen(\"ARC80F.out\",\"w\",stdout);\n}\n\nconst int maxn=500+10;\nint n,a[maxn],pos[maxn],tot,cnt,ans;\nint be[maxn],cnte,to[maxn*maxn],las[maxn*maxn],beg[maxn];\nbool vis[maxn];\n\nvoid add(int u,int v){\n\tlas[++cnte]=beg[u];\n\tbeg[u]=cnte;\n\tto[cnte]=v;\n}\n\nbool pd(int x){\n\tif(x==1 || x==2)return false;\n\tint y=sqrt(x);\n\tREP(i,2,y)if(x%i==0)return false;\n\treturn true;\n}\n\nbool Hungary(int u){\n\tfor(int i=beg[u];i;i=las[i]){\n\t\tif(vis[to[i]])continue;\n\t\tvis[to[i]]=1;\n\t\tif(!be[to[i]] || Hungary(be[to[i]])){\n\t\t\tbe[to[i]]=u;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint main(){\n\t//File();\n\tscanf(\"%d\",&n);\n\tREP(i,1,n){\n\t\tscanf(\"%d\",&a[i]);\n\t\tif(i==1 || a[i-1]<a[i]-1)pos[++tot]=a[i];\n\t\tif(i!=1 && a[i]>a[i-1]+1)pos[++tot]=a[i-1]+1;\n\t}\n\tpos[++tot]=a[n]+1;\n\tREP(i,1,tot)if(pos[i]%2)++cnt;\n\tREP(i,1,tot)if(pos[i]%2==0){\n\t\tREP(j,1,tot)if(pos[j]%2==1 && pd(abs(pos[j]-pos[i])))\n\t\t\tadd(i,j);\n\t}\n\tREP(i,1,tot)if(pos[i]%2==0){\n\t\tmemset(vis,0,sizeof(vis));\n\t\tans+=Hungary(i);\n\t}\n\tprintf(\"%d\\n\",ans+(tot-ans*2)+(cnt-ans)%2);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int maxn=1e7+10;\nint n,a[110],b[110],m,ans;\nint b1[110],b2[110],p1,p2;\nbool np[maxn],vis[110],g[110][110],s[maxn];\nint match[110];\nvector<int> p;\n\nvoid init(){\n\tnp[0]=np[1]=1;\n\tfor(int i=2;i<maxn;++i){\n\t\tif(!np[i]){\n\t\t\tp.push_back(i);\n\t\t\t//cerr<<i<<endl;\n\t\t\t//system(\"pause\");\n\t\t}\n\t\tfor(int j=0,j_end=p.size(),x;j<j_end&&(x=p[j]*i)<maxn;++j){\n\t\t\tnp[x]=true;\n\t\t\tif(i%p[j]==0)break;\n\t\t}\n\t}\n}\n\nbool dfs(int u){\n\tif(vis[u])return false;\n\tvis[u]=1;\n\tfor(int i=1;i<=n;++i)if(g[u][i]){\n\t\tif(!match[i]||dfs(match[i])){\n\t\t\tmatch[i]=u;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\nvoid solve(){\n\tinit();\n\tcin>>n;\n\tfor(int i=1;i<=n;++i){cin>>a[i];s[a[i]]=1;}\n\tfor(int i=1;i<maxn;++i){\n\t\tif(s[i]!=s[i-1])b[++m]=i;\n\t}\n\tfor(int i=1;i<=m;++i){\n\t\tif(b[i]&1)b1[++p1]=b[i];\n\t\telse b2[++p2]=b[i];\n\t}\n\t//cerr<<p1<<\" \"<<p2<<endl;\n\tfor(int i=1;i<=p1;++i){\n\t\tfor(int j=1;j<=p2;++j){\n\t\t\tif(!np[abs(b1[i]-b2[j])]){\n\t\t\t\tg[i][j]=true;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor(int i=1;i<=m;++i){\n\t\tif(!match[i]){\n\t\t\tmemset(vis,0,sizeof vis);\n\t\t\tif(dfs(i))++ans;//match()\n\t\t}\n\t}\n\tp1-=ans;p2-=ans;\n\t//cerr<<ans<<endl;\n\tans+=p1/2*2+p2/2*2;\n\tans+=p1%2*3;\n\tcout<<ans<<endl;\n}\nint main(){\n\tsolve();\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<string>\n#include<cmath>\nusing namespace std;\n#define clr(a) memset(a,0,sizeof(a))\n//--Container\n#include<set>\n//\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pi;\n \nstruct eg{int u,v,nx;}gp[50010];int cnt,hd[210],mth[210];bool bd[210];\nvoid psh(int u,int v){++cnt;gp[cnt].u=u,gp[cnt].v=v,gp[cnt].nx=hd[u],hd[u]=cnt;};\n \nbool fdp(int v){\n    int i;for(i=hd[v];i;i=gp[i].nx)if(!bd[gp[i].v]){\n        bd[gp[i].v]=1;\n        if(!mth[gp[i].v]||fdp(mth[gp[i].v])){\n            mth[gp[i].v]=v;\n            return 1;\n        }\n    }\n    return 0;\n};\nint hgy(int n){\n    int rs=0,i;for(clr(bd),i=1;i<=n;++i){\n        clr(mth);if(fdp(i))++rs;\n    }\n    return rs;\n};\n \nint ar[110],dr[210],cr[2][210],dn,n;\n \nbool _ck(int n){\n    if(n<3)return 0;int d=sqrt(n),i=2;for(;i<=d;++i)if(!(n%i))return 0;\n    return 1;\n};\n \nbool cl(){\n\tif(scanf(\"%d\",&n)==-1)return 0;\n    int i,j,t,a,b,k;for(i=1;i<=n;scanf(\"%d\",&ar[i++]));sort(ar+1,ar+n+1);n=unique(ar+1,ar+n+1)-ar-1;\n    for(dn=1,dr[1]=ar[1],i=2;i<=n;++i){\n        if(ar[i]==ar[i-1]+1)continue;\n        dr[++dn]=ar[i-1]+1,dr[++dn]=ar[i];\n    }\n    dr[++dn]=ar[n]+1;\n    for(a=b=0,i=1;i<=dn;++i){\n        if(dr[i]&1)cr[1][++a]=dr[i];\n        else\n            cr[0][++b]=dr[i];\n    }\n    for(cnt=0,clr(hd),i=1;i<=a;++i)for(j=1;j<=b;++j)if(_ck(abs(cr[1][i]-cr[0][j])))\n        psh(i,j);\n    t=hgy(a);\n    printf(\"%d\\n\",t+((a-t)/2*2)+((b-t)/2*2)+((a-t)%2*3));\n\treturn 1;\n};\n \nint main() {\n    while(cl());\n    return 0;\n};"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N = 205, M = 1e7 + 8;\n\nint n, x[N], prime[M], tot, k, own[N], m, y[N];\nbool vis[M], use[N];\nvector<int>S, T, V[N];\n\nint find (int x) {\n\tfor (auto v : V[x]) if (!use[v]) {\n\t\tuse[v] = 1;\n\t\tif (!own[v] || find(own[v])) {\n\t\t\town[v] = x;\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nint main () {\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; ++i) scanf(\"%d\", &y[i]);\n\tsort(y + 1, y + n + 1);\n\tx[m = 1] = y[1];\n\tif (y[1] + 1 != y[2]) x[++m] = y[1] + 1;\n\tfor (int i = 2; i <= n; ++i) {\n\t\tif (y[i] != y[i - 1] + 1) x[++m] = y[i];\n\t\tif (y[i] != y[i + 1] - 1) x[++m] = y[i] + 1;\n\t}\n\tn = m;\n\tvis[1] = 1;\n\tfor (int i = 2; i <= 1e7; ++i) {\n\t\tif (!vis[i]) prime[++tot] = i;\n\t\tfor (int j = 1; j <= tot && i * prime[j] <= 1e7; ++j) {\n\t\t\tvis[i * prime[j]] = 1;\n\t\t\tif (i % prime[j] == 0) break;\n\t\t}\n\t}\n\tfor (int i = 1; i <= n; ++i) if (x[i] & 1) S.emplace_back(i); else T.emplace_back(i);\n\tfor (auto u : S) for (auto v : T) if (!vis[abs(x[u] - x[v])]) V[u].emplace_back(v);\n\tfor (auto u : S) if (memset(use, 0, sizeof use), find(u)) ++k;\n\tprintf(\"%d\\n\", (S.size() - k) / 2 * 2 + (T.size() - k) / 2 * 2 + ((S.size() - k) & 1) * 3 + k);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define inf 1e9\nusing namespace std;\nstruct node{\n\tint nxt,to,weigh;\n}edge[400010];\nint head[100100],n,S,T,cnt=1,level[100100];\nint a[10010],b[10010],c[10001000],sum,tot,ans;\nqueue<int> qu;\nbool check(int a){\n\tif(a<=2)return false; \n\tfor(int i=2;i<=sqrt(a);i++)\n\t\tif(a%i==0)return false;\n\treturn true;\n}\nvoid addedge(int x,int y,int z){\n\tedge[++cnt].nxt=head[x];\n\tedge[cnt].to=y;\n\tedge[cnt].weigh=z;\n\thead[x]=cnt;\n\tedge[++cnt].nxt=head[y];\n\tedge[cnt].to=x;\n\tedge[cnt].weigh=0;\n\thead[y]=cnt;\t\n}\nbool bfs(){\n\tmemset(level,-1,sizeof(level));\n\tlevel[S]=0;\n\tqu.push(S);\n\twhile(!qu.empty()){\n\t\tint u=qu.front();\n\t\tqu.pop();\n\t\tfor(int i=head[u];i;i=edge[i].nxt){\n\t\t\tint upup=edge[i].to;\n\t\t\tif(edge[i].weigh!=0 && level[upup]==-1){\n\t\t\t\tlevel[upup]=level[u]+1;\n\t\t\t\tqu.push(upup);\n\t\t\t}\n\t\t}\n\t}\n\tif(level[T]==-1)return false;\n\treturn true;\n}\nint dfs(int x,int flow){\n\tif(x==T)return flow;\n\tint rest=0;\n\tfor(int i=head[x];i;i=edge[i].nxt){\n\t\tint upup=edge[i].to;\n\t\tif(rest==flow)break;\n\t\tif(level[upup]==level[x]+1){\n\t\t\tint sum=dfs(upup,min(flow-rest,edge[i].weigh));\n\t\t\trest+=sum,edge[i].weigh-=sum;edge[i^1].weigh+=sum;\n\t\t}\n\t} \n\treturn rest;\n}\nint Dinic(){\n\tint ans=0;\n\twhile(bfs())\n\t\tans+=dfs(S,inf);\n\treturn ans;\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++){\n\t\tscanf(\"%d\",&a[i]);\n\t\tc[a[i]]=1;\n\t}\n\tfor(int i=1;i<=10000000;i++)\n\t\tif(c[i]!=c[i-1])\n\t\t\tb[++sum]=i;\n\tS=0,T=sum+1;\n\tfor(int i=1;i<=sum;i++)\n\t\tif(b[i]&1){\n\t\t\ttot++;\n\t\t\taddedge(S,i,1);\n\t\t\tfor(int j=1;j<=sum;j++)\n\t\t\t\tif(!b[j]&1&&check(abs(b[j]-b[i])))\n\t\t\t\t\taddedge(i,j,1);\n\t\t}\n\t\telse addedge(i,T,1);\n\tans=Dinic();\n\tprintf(\"%d\\n\",sum-ans+(tot-ans)%2);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// Prime Flip\n// * frank_c1\n// * 2017 / 12 / 24\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int maxn = 205;\nconst int maxM = (int)(1e7) + 5;\nint pr[maxM], chk[maxM];\n\nvoid gen() {\n\tint mx = (int)(1e7) + 1, tot = 0;\n\tchk[1] = 1;\n\tfor (int i = 2; i <= mx; ++i) {\n\t\tif (!chk[i]) {\n\t\t\tpr[++tot] = i;\n\t\t}\n\t\tfor (int j = 1; j <= tot; ++j) {\n\t\t\tif (i * pr[j] > mx) break;\n\t\t\tchk[i * pr[j]] = 1;\n\t\t\tif (i % pr[j] == 0) break;\n\t\t}\n\t}\n}\n\nint a[maxn], b[maxn], vi[maxn], lk[maxn];\nint idx;\n\nint Find(int x) {\n\tfor (int i = 1; i <= idx; ++i) \n\t\tif (!vi[i] && !(b[i] & 1)) {\n\t\t\tif (!chk[max(b[x], b[i]) - min(b[x], b[i])]) {\n\t\t\t\tvi[i] = 1;\n\t\t\t\tif (!lk[i] || Find(lk[i])) {\n\t\t\t\t\tlk[i] = x; return 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\treturn 0;\n}\n\nint main() {\n\tgen();\n\tint n;\n\tscanf(\"%d\", &n); a[0] = -1;\n\tfor (int i = 1; i <= n; ++i) scanf(\"%d\", &a[i]);\n\tfor (int i = 1; i <= n; ++i) {\n\t\tif (a[i] - 1 != a[i - 1]) b[++idx] = a[i];\n\t\tif (a[i] + 1 != a[i + 1]) b[++idx] = a[i] + 1;\n\t}\n\tint ret = 0, cnt = 0;\n\tfor (int i = 1; i <= idx; ++i) if (b[i] & 1) {\n\t\tmemset(vi, 0, sizeof(vi)); ret += Find(i); ++cnt;\n\t} \n\treturn printf(\"%d\\n\", ret + ((cnt - ret) / 2 + (idx - cnt - ret) / 2) * 2 + ((cnt - ret) % 2) * 3), 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <cmath>\n#include <cstdlib>\n#include <vector>\n#include <set>\n#include <map>\n#include <cassert>\n#include <queue>\n#include <ctime>\n#include <string>\n#include <cstring>\n#include <random>\n#define mp make_pair\n#define pb push_back\n#define NAME \"\"\n#define y1 y1_423\n#define list lista\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\n\ntemplate<typename T>\nostream& operator << (ostream& cout, const vector<T> &a) {\n\tif ((int)a.size() == 0) {\n\t\treturn (cout << \"()\");\n\t}\n\tcout << \"(\" << a[0];\n\tfor (int i = 1; i < (int)a.size(); i++) {\n\t\tcout << \"; \" << a[i];\n\t}\n\treturn (cout << \")\");\n}\n\ntemplate<typename T>\nostream& operator << (ostream& cout, const set<T> &a) {\n\tif ((int)a.size() == 0) {\n\t\treturn (cout << \"{}\");\n\t}\n\tauto it = a.begin();\n\tcout << \"{\" << *it;\n\t++it;\n\tfor (; it != a.end(); ++it) {\n\t\tcout << \"; \" << *it;\n\t}\n\treturn (cout << \"}\");\n}\n\ntemplate<typename T>\nostream& operator << (ostream& cout, const multiset<T> &a) {\n\tif ((int)a.size() == 0) {\n\t\treturn (cout << \"{}\");\n\t}\n\tauto it = a.begin();\n\tcout << \"{\" << *it;\n\t++it;\n\tfor (; it != a.end(); ++it) {\n\t\tcout << \"; \" << *it;\n\t}\n\treturn (cout << \"}\");\n}\n\ntemplate<typename T1, typename T2>\nostream& operator << (ostream& cout, const pair<T1, T2> &a) {\n\treturn cout << \"(\" << a.first << \"; \" << a.second << \")\";\n}\n\nrandom_device gen;\nmt19937 rnd(gen());\n\nconst int nmax = 2 * 1000 * 1000 * 10;\nconst int inf = 2000 * 1000 * 1000;\nconst ll infl = 1000ll * 1000ll * 1000ll * 1000ll * 1000ll * 1000ll;\nconst int mod = 1000 * 1000 * 1000 + 7;\nconst ld pi = acos(-1.0);\n\nint used[nmax], u[nmax], p[nmax], b[nmax];\nvector<int> a, go[nmax];\n\nbool ok(int v) {\n\tif (u[v]) return false;\n\tfor (int u : go[v]) {\n\t\tif (p[u] == -1) {\n\t\t\tp[u] = v;\n\t\t\treturn true;\n\t\t}\n\t}\n\tfor (int u : go[v]) {\n\t\tif (ok(u)) {\n\t\t\tp[u] = v;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint main() {\n\t//freopen(\"input.txt\", \"r\", stdin);freopen(\"output.txt\", \"w\", stdout);\n\t//freopen(NAME\".in\", \"r\", stdin);freopen(NAME\".out\", \"w\", stdout);\n\tfor (int i = 2; i < nmax; i++) {\n\t\tused[i] = 1;\n\t}\n\tfor (ll i = 2; i * i < nmax; i++) {\n\t\tif (!used[i]) continue;\n\t\tfor (ll j = i * i; j < nmax; j += i) {\n\t\t\tused[j] = 0;\n\t\t}\n\t}\n\tused[0] = used[1] = used[2] = 0;\n\tint n;\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; i++) {\n\t\tint x;\n\t\tscanf(\"%d\", &x);\n\t\tb[x] ^= 1;\n\t\tb[x + 1] ^= 1;\n\t}\n\tfor (int i = 0; i < nmax; i++) {\n\t\tif (b[i] == 1) {\n\t\t\ta.pb(i);\n\t\t}\n\t}\n\tn = a.size();\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif (i == j) continue;\n\t\t\tif (used[abs(a[i] - a[j])]) {\n\t\t\t\tgo[i].pb(j);\n\t\t\t}\n\t\t}\n\t}\n\tint cnt0 = 0, cnt1 = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (a[i] % 2 == 0) {\n\t\t\tcnt0++;\n\t\t} else {\n\t\t\tcnt1++;\n\t\t}\n\t}\n\tfor (int j = 0; j < n; j++) {\n\t\tp[j] = -1;\n\t}\n\tint answer = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (a[i] % 2 == 0) continue;\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tu[j] = 0;\n\t\t}\n\t\tif (ok(i)) answer++;\n\t}\n\tcout << answer + ((cnt0 - answer) / 2 + (cnt1 - answer) / 2) * 2 + ((cnt1 - answer) % 2) * 3 << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <map>\n#include <string>\n#include <cstring>\n#include <stack>\n#include <queue>\n#include <cmath>\n#include <ctime>\n#include <utility>\nusing namespace std;\n#define REP(I,N) for (I=0;I<N;I++)\n#define rREP(I,N) for (I=N-1;I>=0;I--)\n#define rep(I,S,N) for (I=S;I<N;I++)\n#define rrep(I,S,N) for (I=N-1;I>=S;I--)\n#define FOR(I,S,N) for (I=S;I<=N;I++)\n#define rFOR(I,S,N) for (I=N;I>=S;I--)\ntypedef unsigned long long ull;\ntypedef long long ll;\n//const int INF=0x3f3f3f3f;\nconst int INF=1e9;\nconst ll INFF=0x3f3f3f3f3f3f3f3fll;\nconst ll M=1e9+7;\nconst ll maxn=1e5+7;\nconst int MAXN=1005;\nconst int MAX=2e5+5;\nconst int MAX_N=MAX;\nconst ll MOD=1e9+7;\n//const double eps=0.00000001;\n//ll gcd(ll a,ll b){return b?gcd(b,a%b):a;}\ntemplate<typename T>inline T abs(T a) {return a>0?a:-a;}\ninline ll powMM(ll a,ll b){\n    ll ret=1;\n    a%=M;\n//    b%=M;\n    while (b){\n        if (b&1) ret=ret*a%M;\n        b>>=1;\n        a=a*a%M;\n    }\n    return ret;\n}\nvoid open()\n{\n    freopen(\"1007.in\",\"r\",stdin);\n    freopen(\"out.txt\",\"w\",stdout);\n}\n/*\n    匈牙利算法 BFS版 效率更高\n\n*/\n#define prev prevv\n//顶点、边的编号均从0开始\n//邻接表储存\nstruct edge\n{\n    int from,to,weight;\n    edge(int f,int t,int w):from(f),to(t),weight(w){}\n};\nconst int __maxNodes=MAX;\nvector<int> G[__maxNodes];//存储顶点i出发的边的编号\nvector<edge> edges;\nvoid addedge(int u,int v)\n{\n    edges.push_back(edge(u,v,1));\n    edges.push_back(edge(v,u,1));\n    G[u].push_back(edges.size()-2);\n    G[v].push_back(edges.size()-1);\n}\ntypedef vector<int>::iterator iterator_t;\nint num_nodes;\nint num_left;\nint num_right;\nint num_edges;\nqueue<int>Q;\nint prev[__maxNodes];\nint matching[__maxNodes]; /* 存储求解结果 */\nint check[__maxNodes];\nint Hungarian()\n{\n    int ans=0;\n    num_edges=edges.size();\n    memset(matching,-1,sizeof(matching));\n    memset(check,-1,sizeof(check));\n    for(int i=0;i<num_left;i++)\n    {\n        if(matching[i]==-1)\n        {\n            while(!Q.empty())Q.pop();\n            Q.push(i);\n            prev[i]=-1;//设i为路径起点\n            bool flag=false;//尚未找到增广路\n            while(!Q.empty()&&!flag)\n            {\n                int u=Q.front();\n                for(iterator_t ix=G[u].begin();ix!=G[u].end()&&!flag;++ix)\n                {\n                    int v=edges[*ix].to;\n                    if(check[v]!=i)\n                    {\n                        check[v]=i;\n                        Q.push(matching[v]);\n                        if(matching[v]>=0)//此点为匹配点\n                        {\n                            prev[matching[v]]=u;\n                        }\n                        else//找到未匹配点，交替路变为增广路\n                        {\n                            flag=true;\n                            int d=u,e=v;\n                            while(d!=-1)\n                            {\n                                int t=matching[d];\n                                matching[t]=e;\n                                matching[e]=d;\n                                d=prev[d];\n                                e=t;\n                            }\n                        }\n                    }\n                }\n                Q.pop();\n            }\n            if(matching[i]!=-1)\n                ++ans;\n        }\n    }\n    return ans;\n}\nbool isprime(int x)\n{\n    for(int i=2;i*i<=x;i++)\n    {\n        if(x%i==0)\n            return false;\n    }\n    return true;\n}\nint n;\nint a[(int)1e7+2];\nvector<int>pos[2];\nint main()\n{\n    scanf(\"%d\",&n);\n    int tem;\n    for(int i=1;i<=n;i++)\n    {\n        scanf(\"%d\",&tem);\n        a[tem]=1;\n    }\n    for(int i=tem+1;i>=1;i--)\n    {\n        a[i]=a[i]^a[i-1];\n        if(a[i])\n            pos[i%2].push_back(i);\n    }\n//    reverse(pos[0].begin(),pos[0].end());\n//    reverse(pos[1].begin(),pos[1].end());\n    num_left=pos[0].size(),num_right=pos[1].size();\n//    numedges=0;\n    //0——numleft-1 为偶数位置的点 numleft——numleft+numright-1为奇数位置的点\n    for(int i=0;i<num_left;i++)\n        for(int j=0;j<num_right;j++)\n        {\n            if(isprime(abs(pos[0][i]-pos[1][j])))\n            {\n//                    printf(\"!!\\n\");\n                    addedge(i,j+num_left);\n            }\n        }\n//    printf(\"%d\\n\",Hungarian());\n    int cnt=Hungarian();\n    cnt+=((num_left-cnt)/2+(num_right-cnt)/2)*2;\n    cnt+=(num_left%2)*3;\n    printf(\"%d\\n\",cnt);\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include <bits/stdc++.h>\n\n#define FOR(i,b,e) for(int i=(b); i <= (e); ++i)\n#define FORD(i,b,e) for(int i=(b); i >= (e); --i)\n#define SIZE(c) (int) (c).size()\n#define FORE(i,c) FOR(i,0,SIZE(c)-1)\n#define FORDE(i,c) FORD(i,SIZE(c)-1,0)\n\n#define pb push_back\n#define mp make_pair\n#define st first\n#define nd second\n\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair <int,int> pii;\ntypedef pair <ll,ll> pll;\n\ntypedef vector <int> VI;\ntypedef vector <bool> VB;\ntypedef vector <pii> VP;\ntypedef vector <ll> VL;\ntypedef vector <pll> VPL;\n\ntypedef vector <VI> VVI;\ntypedef vector <VL> VVL;\ntypedef vector <VB> VVB;\ntypedef vector <VP> VVP;\n\nstruct MinCostFlow {\n    typedef int capacity_t;\n    typedef int cost_t;\n\n    // use INFINITY from cmath if cost_t is a double\n    const cost_t INF = 1000 * 1000 * 1000;\n    const capacity_t MAX_CAP = 1000 * 1000 * 1000;\n\n    struct edge {\n        int from, v;\n        capacity_t cap, flow;\n        cost_t cost, dist;\n        int rev_index;\n        \n        bool residual() { return flow < cap; }\n        \n        edge(int _f, int _v, capacity_t _cap, cost_t _cost):\n            from(_f), v(_v), cap(_cap), flow(0), cost(_cost), dist(_cost) {}\n    };\n\n    int n, s, t;\n    vector <cost_t> d;\n    vector <edge*> p;\n    vector <vector<edge>> g;\n    VB queued;\n    \n    MinCostFlow(int n): n(n), d(n), p(n), g(n), queued(n) {}\n    \n    void bellman() {\n        FOR(i,0,n-1) { d[i] = INF; queued[i] = 0; }\n        queue <int> q;\n        \n        d[s] = 0;\n        q.push(s); queued[s] = 0;\n        \n        while (!q.empty()) {\n            int u = q.front(); q.pop(); queued[u] = 0;\n            \n            for (auto &i : g[u]) if (i.residual() && d[i.v] > d[u] + i.dist) {\n                d[i.v] = d[u] + i.dist;\n                p[i.v] = &i;\n                if (!queued[i.v]) { q.push(i.v); queued[i.v] = 1; }\n            }\n        }\n    }\n\n    pair <capacity_t,cost_t> computeFlow(int s, int t) {\n        this->s = s;\n        this->t = t;\n\n        capacity_t flow = 0;\n        cost_t cost = 0;\n\n        while (true) {\n            bellman();\n\n            if (d[t] == INF) break;\n            cost_t c = 0;\n            capacity_t f = MAX_CAP;\n            \n            for (int u=t; u!=s; u=p[u]->from) {\n                f = min(f, p[u]->cap - p[u]->flow);\n            }\n            \n            for (int u=t; u!=s; u=p[u]->from) {\n                p[u]->flow += f;\n                g[p[u]->v][p[u]->rev_index].flow -= f;\n                c += p[u]->cost;\n            }\n            \n            flow += f; cost += f * c;\n        }\n        \n        return {flow, cost};\n    }\n    \n    void addEdge(int a, int b, capacity_t f, cost_t c) {\n        assert(a != b);\n        \n        g[a].pb(edge(a, b, f, c));\n        g[b].pb(edge(b, a, 0, -c));\n        g[a].back().rev_index = SIZE(g[b])-1;\n        g[b].back().rev_index = SIZE(g[a])-1;\n    }\n};\n\n/*************************************************************************/\n\nbool isPrime(int x) {\n    if (x == 1) return false;\n\n    for (int i = 2; i * i <= x; i++) if (x % i == 0) {\n        return false;\n    }\n    \n    return true;\n}\n\n\nstruct TurboMatching {\n    int value = 0;\n\n    VVI G;\n    VI mate; VB vis;\n\n    TurboMatching(int n): G(n), mate(n,-1), vis(n,0) {}\n\n    void addEdge(int u, int v) {\n        G[u].pb(v);\n        G[v].pb(u);\n    }\n\n    bool findPath(int v) {\n        if (vis[v]) return false;\n        vis[v] = true;\n\n        for (int u : G[v]) if (mate[u] == -1 || findPath(mate[u])) {\n            mate[v] = u;\n            mate[u] = v;\n            return true;\n        }\n\n        return false;\n    }\n\n    pair <int,VI> runMatching() {\n        while (true) {\n            bool found = false;\n            FORE(v,G) vis[v] = false;\n\n            FORE(v,G) if (mate[v] == -1 && findPath(v)) {\n                found = true;\n                value++;\n            }\n\n            if (!found) break;\n        }\n\n        return {value, mate};\n    }\n};\n\n/*************************************************************************/\n\nint solve(int n, VI &x) {\n    TurboMatching matching(n);\n    \n    FOR(i,0,n-1) FOR(j,i+1,n-1) {\n        int diff = abs(x[i] - x[j]);\n        \n        if (diff % 2 && isPrime(diff)) {\n            matching.addEdge(i, j);\n        }\n    }\n    \n    int matchingInOnes = matching.runMatching().st;\n    \n    int odd = 0, even = 0;\n    FOR(i,0,n-1) {\n        if (x[i] % 2) odd++;\n        else even++;\n    }\n\n    int ans = matchingInOnes;\n    ans += 2 * (odd / 2);\n    ans += 2 * (even / 2);\n    \n    if (odd % 2) {\n        ans += 3;\n    }\n    \n    return ans;\n}\n\n/*************************************************************************/\n\nint main() {\n    ios_base::sync_with_stdio(0);\n    \n    int n;\n    cin >> n;\n    \n    set <int> pos;\n    while (n--) {\n        int x;\n        cin >> x;\n        \n        VI vals = {x-1, x};\n        for (int v : vals) {\n            if (pos.count(v)) {\n                pos.erase(v);\n            } else {\n                pos.insert(v);\n            }\n        }\n    }\n    \n    VI posVec(pos.begin(), pos.end());\n    cout << solve(posVec.size(), posVec);\n\n    return 0;\n}\n\n/*************************************************************************/\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <stdlib.h>\n#define inf 1e9\n\nusing namespace std;\n\nstruct edge{\n\tint to, cap, rev;\n\tedge(int a, int b, int c){\n\t\tto = a, cap = b, rev = c;\n\t}\n};\n\nint n, N;\nint x[105], X[205];\nbool prime[10000005];\nmap<int, int> mp;\nvector<int> vec;\n\nvector<edge> G[105];\nint S, T;\nbool used[105];\n\nint dfs(int v, int f)\n{\n\tused[v] = true;\n\tif(v == T) return f;\n\t\n\tint ret;\n\tfor(int i = 0; i < G[v].size(); i++){\n\t\tif(used[G[v][i].to] || G[v][i].cap <= 0) continue;\n\t\tret = dfs(G[v][i].to, min(f, G[v][i].cap));\n\t\tif(ret > 0){\n\t\t\tG[v][i].cap -= ret;\n\t\t\tG[G[v][i].to][G[v][i].rev].cap += ret;\n\t\t\treturn ret;\n\t\t}\n\t}\n\treturn 0;\n}\n\nvoid add_edge(int s, int t, int cap)\n{\n\tG[s].push_back(edge(t, cap, G[t].size()));\n\tG[t].push_back(edge(s, 0, G[s].size()-1));\n}\n\nint main(void)\n{\n\tcin >> n;\n\tfor(int i = 2; i < 10005; i++){\n\t\tif(prime[i]) continue;\n\t\tfor(int j = 2*i; j < 10000005; j+=i) prime[j] = true;\n\t}\n\tprime[1] = prime[2] = true;\n\t\n\tfor(int i = 1; i <= n; i++) cin >> x[i];\n\tfor(int i = 1; i <= n; i++){\n\t\tmp[x[i]]++, mp[x[i]+1]++;\n\t}\n\tfor(auto it = mp.begin(); it != mp.end(); it++){\n\t\tif(it->second % 2) vec.push_back(it->first);\n\t}\n\tN = vec.size();\n\tfor(int i = 0; i < N; i++) X[i+1] = vec[i];\n\t\n\tS = N+1, T = N+2;\n\tint odd = 0, even = 0;\n\tfor(int i = 1; i <= N; i++){\n\t\tif(X[i]%2) add_edge(S, i, 1), odd++;\n\t\telse add_edge(i, T, 1), even++;\n\t}\n\tfor(int i = 1; i <= N; i++){\n\t\tfor(int j = 1; j <= N; j++){\n\t\t\tif(i == j) continue;\n\t\t\tif(X[i]%2 && X[j]%2 == 0 && !prime[abs(X[i]-X[j])]) add_edge(i, j, 1);\n\t\t}\n\t}\n\t\n\tint mx = 0, flow;\n\twhile(1){\n\t\tfor(int i = 1; i <= T; i++) used[i] = false;\n\t\tflow = dfs(S, inf);\n\t\tif(flow <= 0) break;\n\t\tmx += flow;\n\t}\n\t\n\tint ans = mx;\n\todd -= mx, even -= mx;\n\tans += odd/2*2, ans += even/2*2;\n\tans += odd%2*3;\n\t\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n#include <assert.h>\n#include <bitset>\n#include <cmath>\n#include <complex>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <limits.h>\n#include <map>\n#include <math.h>\n#include <queue>\n#include <set>\n#include <stdlib.h>\n#include <string.h>\n#include <string>\n#include <time.h>\n//#include <unordered_map>\n//#include <unordered_set>\n#include <vector>\n\n#pragma warning(disable:4996)\n#pragma comment(linker, \"/STACK:33554432\")\nusing namespace std;\n\n#define mp make_pair\n#define all(x) (x).begin(), (x).end()\n#define ldb ldouble\n#define rf(x) (x)=0;while(*p<48)p++;while(47<*p)(x)=((x)<<3)+((x)<<1)+(*p++&15);\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ldb;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\ntypedef pair <ll, int> pli;\ntypedef pair <db, db> pdd;\n//typedef tuple <int, int, int> t3;\n\nint IT_MAX = 1 << 18;\nconst ll MOD = 1000000009;\nconst int INF = 0x3f3f3f3f;\nconst ll LL_INF = 1234567890123456789ll;\nconst db PI = acos(-1);\nconst db EPS = 1e-8;\n#define szz(x) (int)(x).size()\n#define rep(i, n) for(int i=0;i<(n);i++)\n\nclass edge {\npublic:\n\tint s, e, f;\n\tint of;\n\tedge() {\n\t\t*this = edge(0, 0, 0);\n\t}\n\tedge(int s, int e, int f) : s(s), e(e), f(f) {}\n};\nvector <edge> E;\nvector <int> fconn[100050];\nvoid epush(int s, int e, int f) {\n\tfconn[s].push_back(E.size());\n\tfconn[e].push_back(E.size() + 1);\n\tE.emplace_back(s, e, f);\n\tE.emplace_back(e, s, 0);\n}\nint dchk[100050];\nint DFS(int n, int snk, int C, int F) {\n\tif (n == snk) return F;\n\tdchk[n] = C;\n\tfor (auto it : fconn[n]) {\n\t\tedge& ed = E[it];\n\t\tif (ed.f == 0 || dchk[ed.e] == C) continue;\n\t\tint t;\n\t\tif (t = DFS(ed.e, snk, C, min(F, ed.f))) {\n\t\t\ted.f -= t;\n\t\t\tE[it ^ 1].f += t;\n\t\t\treturn t;\n\t\t}\n\t}\n\treturn 0;\n}\nvoid init(int snk) {\n\tint i;\n\tfor (i = 0; i <= snk; i++) {\n\t\tfconn[i].clear();\n\t\tdchk[i] = false;\n\t}\n\tE.clear();\n}\n\nbool pchk[10000050];\n\nvector <int> Va;\nset <int> Sx;\nint in[105];\n\nvector <int> V1;\nvector <int> V2;\nint main() {\n\tint N, i, j;\n\n\tpchk[1] = true;\n\tfor (i = 2; i <= 10000030; i++) {\n\t\tif (pchk[i]) continue;\n\t\tfor (j = 2 * i; j <= 10000030; j += i) pchk[j] = true;\n\t}\n\n\tscanf(\"%d\", &N);\n\tfor (i = 1; i <= N; i++) {\n\t\tscanf(\"%d\", &in[i]);\n\t\tVa.push_back(in[i] - 1);\n\t\tVa.push_back(in[i]);\n\t\tSx.insert(in[i]);\n\t}\n\tsort(all(Va));\n\tfor (i = 0; i < Va.size(); i++) {\n\t\tint t = 0;\n\t\tif (Sx.count(Va[i])) t ^= 1;\n\t\tif (Sx.count(Va[i] + 1)) t ^= 1;\n\t\tif (!t) continue;\n\t\tif (Va[i] % 2) V1.push_back(Va[i]);\n\t\telse V2.push_back(Va[i]);\n\t}\n\n\tint src = V1.size() + V2.size();\n\tint snk = src + 1;\n\tfor (i = 0; i < V1.size(); i++) epush(src, i, 1);\n\tfor (i = 0; i < V2.size(); i++) epush(i + V1.size(), snk, 1);\n\tfor (i = 0; i < V1.size(); i++) {\n\t\tfor (j = 0; j < V2.size(); j++) {\n\t\t\tint t = abs(V1[i] - V2[j]);\n\t\t\tif (!pchk[t]) epush(i, V1.size() + j, 1);\n\t\t}\n\t}\n\t\n\tint f = 0;\n\twhile (DFS(src, snk, f + 1, INF)) f++;\n\n\tint ans = f;\n\tint t1 = (int)V1.size() - f, t2 = (int)V2.size() - f;\n\tans += (t1 / 2 + t2 / 2) * 2;\n\tif (t1 % 2) ans += 3;\n\treturn !printf(\"%d\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=210;\n\nint bel[N],a[N],b[N],n;\nbool G[N][N],vis[N];\nmap<int,int> M;\n\nbool isprime(int n) {\n\tif(n==1) return 0;\n\tfor(int i=2;i*i<=n;i++)\n\t\tif(n%i==0) return 0;\n\treturn 1;\n}\n\nbool find(int i) {\n\tfor(int j=1;j<=n;j++)\n\t\tif(!vis[j]&&G[i][j]) {\n\t\t\tvis[j]=1;\n\t\t\tif(!bel[j]||find(bel[j])) { bel[j]=i;return 1; }\n\t\t}\n\treturn 0;\n}\n\nint main() {\n\tcin>>n;\n\tfor(int i=1,x;i<=n;i++) cin>>x,M[x]^=1,M[x+1]^=1;\n\tfor(auto x:M)\n\t\tif(x.second) (x.first&1?a[++*a]:b[++*b])=x.first;\n\tint ans=0;\n\tfor(int i=1;i<=*a;i++)\n\t\tfor(int j=1;j<=*b;j++)\n\t\t\tif(isprime(abs(a[i]-b[j]))) G[i][j]=1;\n\tfor(int i=1;i<=*a;i++) {\n\t\tmemset(vis,0,sizeof(vis));\n\t\tans+=find(i);\n\t}\n\tcout<<ans+(*a-ans)/2*2+(*b-ans)/2*2+(*a-ans)%2*3;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// ====================================\n//   author: M_sea\n//   website: https://m-sea-blog.com/\n// ====================================\n#include <bits/stdc++.h>\n#define file(x) freopen(#x\".in\",\"r\",stdin); freopen(#x\".out\",\"w\",stdout)\n#define debug(...) fprintf(stderr,__VA_ARGS__)\nusing namespace std;\ntypedef long long ll;\n\nint read() {\n\tint X=0,w=1; char c=getchar();\n\twhile (c<'0'||c>'9') { if (c=='-') w=-1; c=getchar(); }\n\twhile (c>='0'&&c<='9') X=X*10+c-'0',c=getchar();\n\treturn X*w;\n}\n\nconst int N=200+10,M=10000000+10;\n\nint p[M],v[M],cnt=0;\nvoid sieve(int n) {\n\tv[1]=1;\n\tfor (int i=2;i<=n;++i) {\n\t\tif (!v[i]) p[++cnt]=i;\n\t\tfor (int j=1;j<=cnt&&i*p[j]<=n;++j) {\n\t\t\tv[i*p[j]]=1;\n\t\t\tif (i%p[j]==0) break;\n\t\t}\n\t}\n}\n\nint n,a[M];\nvector<int> L,R,E[N];\n\nint vis[N],lnk[N];\nbool dfs(int u) {\n\tfor (int v:E[u]) {\n\t\tif (vis[v]) continue;\n\t\tvis[v]=1;\n\t\tif (!lnk[v]||dfs(lnk[v])) { lnk[v]=u; return 1; }\n\t}\n\treturn 0;\n}\nint Hungary() {\n\tint res=0;\n\tfor (int i=1;i<=L.size();++i) {\n\t\tmemset(vis,0,sizeof(vis));\n\t\tif (dfs(i)) ++res;\n\t}\n\treturn res;\n}\n\nint main() {\n\tsieve(10000000);\n\tn=read();\n\tfor (int i=1;i<=n;++i) a[read()]=1;\n\tfor (int i=1;i<M;++i) {\n\t\tif (a[i]==a[i-1]) continue;\n\t\tif (i&1) L.emplace_back(i);\n\t\telse R.emplace_back(i);\n\t}\n\tfor (int i=0;i<L.size();++i)\n\t\tfor (int j=0;j<R.size();++j) {\n\t\t\tif (v[abs(L[i]-R[j])]) continue;\n\t\t\tE[i+1].emplace_back(j+1);\n\t\t}\n\tint f=Hungary();\n\tprintf(\"%d\\n\",f+(L.size()-f)/2*2+(R.size()-f)/2*2+((L.size()-f)&1)*3);\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nint n, m, odd[209], even[209], lft[209], rgt[209];\nbool C[209];\nmap < int, bool > b;\nvector < int > v[209];\nconst int lim = 10000001;\nunsigned char cr[(lim + 10) >> 3];\n\nbool pairUp (int nod)\n{\n    if (C[nod]) return 0;\n    for (auto i : v[nod])\n        if (lft[i] == 0 || pairUp (lft[i]))\n        {\n            lft[i] = nod, rgt[nod] = i;\n            return 1;\n        }\n    return 0;\n}\n\nint maxMatch ()\n{\n    bool ok = 1;\n    while (ok)\n    {\n        ok = 0;\n        for (int i=1; i<=n; i++)\n            C[i] = 0;\n        for (int i=1; i<=n; i++)\n            if (rgt[i] == 0)\n                ok |= pairUp (i);\n    }\n    int ans = 0;\n    for (int i=1; i<=n; i++)\n        ans += (rgt[i] > 0);\n    return ans;\n}\n\nint main ()\n{\n//freopen (\"input\", \"r\", stdin);\n//freopen (\"output\", \"w\", stdout);\n\nint N;\nscanf (\"%d\", &N);\nfor (int i=1; i<=N; i++)\n{\n    int x;\n    scanf (\"%d\", &x);\n    b[x] ^= 1, b[x + 1] ^= 1;\n}\nfor (auto it : b)\n    if (it.second)\n    {\n        if (it.first & 1) odd[++n] = it.first;\n        else even[++m] = it.second;\n    }\nfor (int i=2; i * i<=lim; i++)\n    if (cr[i >> 3] & (1 << (i & 7))) ;\n    else\n    {\n        for (int j=i * i; j<=lim; j+=i)\n            cr[j >> 3] |= 1 << (j & 7);\n    }\nfor (int i=1; i<=n; i++)\n    for (int j=1; j<=m; j++)\n    {\n        int val = odd[i] - even[j];\n        if (val < 0) val = -val;\n        if (val <= 2 || (cr[val >> 3] & (1 << (val & 7)))) ;\n        else v[i].push_back (j);\n    }\nint T1 = maxMatch ();\nn -= T1, m -= T1;\nint T3 = n & 1, T2 = (n + m - 2 * T3) >> 1;\nprintf (\"%d\\n\", T1 + 2 * T2 + 3 * T3);\nreturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <set>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <cmath>\n#include <vector>\n#include <bitset>\n#include <cstdio>\n#include <cctype>\n#include <string>\n#include <numeric>\n#include <cstring>\n#include <cassert>\n#include <climits>\n#include <cstdlib>\n#include <iostream>\n#include <algorithm>\n#include <functional>\nusing namespace std ;\n#define int long long\n#define rep(i, a, b) for (ll i = (a); i <= (b); ++i)\n#define per(i, a, b) for (ll i = (a); i >= (b); --i)\n#define loop(it, v) for (auto it = v.begin(); it != v.end(); it++)\n#define cont(i, x) for (ll i = head[x]; i; i = edge[i].nex)\n#define clr(a) memset(a, 0, sizeof(a))\n#define ass(a, cnt) memset(a, cnt, sizeof(a))\n#define cop(a, b) memcpy(a, b, sizeof(a))\n#define lowbit(x) (x & -x)\n#define all(x) x.begin(), x.end()\n#define SC(t, x) static_cast <t> (x)\n#define ub upper_bound\n#define lb lower_bound\n#define pqueue priority_queue\n#define mp make_pair\n#define pb push_back\n#define pof pop_front\n#define pob pop_back\n#define fi first\n#define se second\n#define y1 y1_\n#define Pi acos(-1.0)\n#define iv inline void\n#define enter putchar('\\n')\n#define siz(x) ((ll)x.size())\n#define file(x) freopen(x\".in\", \"r\", stdin),freopen(x\".out\", \"w\", stdout)\ntypedef double db ;\ntypedef long long ll ;\ntypedef unsigned long long ull ;\ntypedef pair <ll, ll> pii ;\ntypedef vector <ll> vi ;\ntypedef vector <pii> vii ;\ntypedef queue <ll> qi ;\ntypedef queue <pii> qii ;\ntypedef set <ll> si ;\ntypedef map <ll, ll> mii ;\ntypedef map <string, ll> msi ;\nconst ll maxn = 2e6 + 100 ;\nconst ll inf = 0x3f3f3f3f ;\nconst ll iinf = 1 << 30 ;\nconst ll linf = 2e18 ;\nconst ll mod = 998244353 ;\nconst double eps = 1e-7 ;\ntemplate <class T = ll> T chmin(T &a, T b) { return a = min(a, b);}\ntemplate <class T = ll> T chmax(T &a, T b) { return a = max(a, b);}\ntemplate <class T = ll> T read()\n{\n\tT f = 1, a = 0;\n\tchar ch = getchar() ;\n\twhile (!isdigit(ch)) { if (ch == '-') f = -1 ; ch = getchar() ; }\n\twhile (isdigit(ch)) { a =  (a << 3) + (a << 1) + ch - '0' ; ch = getchar() ; }\n\treturn a * f ;\n}\n\nll n, ans;\n\nll a[maxn], b[maxn], tot;\n\nsi s;\n\nvi edge[maxn];\n\nbool is_prime(ll x)\n{\n\tif(x <= 2) return 0;\n\trep(i, 2, sqrt(x)) if(x % i == 0) return 0;\n\treturn 1;\n}\n\nll col[maxn];\n\nvoid paint(ll now, ll x)\n{\n\tif(col[now]) return ;\n\tcol[now] = x;\n\tif(x == 1) \n\tfor(ll to : edge[now]) paint(to, x ^ 3);\n}\n\nll match[maxn], vis[maxn];\n\nll dfs(ll now)\n{\n\tfor(ll to : edge[now])\n\t{\n\t\tif(vis[to]) continue;\n\t\tvis[to] = 1;\n\t\tif(!match[to] || dfs(match[to]))\n\t\t{\n\t\t\tmatch[now] = to, match[to] = now;\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nvoid hungarian()\n{\n\trep(i, 1, tot)\n\t{\n\t\tif(col[i] == 2) continue;\n\t\trep(j, 1, tot) vis[j] = 0;\n\t\tans += dfs(i);\n\t}\n}\n\nll odd, even;\n\nsigned main()\n{\n\tn = read();\n\trep(i, 1, n) a[i] = read();\n\ta[0] = -114514;\n\tsort(a + 1, a + n + 1);\n\t// rep(i, 1, n) printf(\"%lld%c\", a[i], \" \\n\"[i == n]);\n\trep(i, 1, n)\n\t{\n\t\tif(a[i - 1] != a[i] - 1) s.insert(a[i]);\n\t\tif(a[i + 1] != a[i] + 1) s.insert(a[i] + 1);\n\t}\n\tfor(ll i : s) b[++ tot] = i;//, printf(\"%lld \", i);\n\t// enter;\n\trep(i, 1, tot) rep(j, i + 1, tot) if(is_prime(b[j] - b[i])) edge[i].pb(j), edge[j].pb(i);//, printf(\"%lld -> %lld\\n\", i, j);\n\trep(i, 1, tot) if(!col[i]) paint(i, 1);\n\thungarian();\n\t// rep(i, 1, tot) printf(\"%lld : %lld\\n\", i, match[i]);\n\trep(i, 1, tot)\n\t{\n\t\tif(match[i]) continue;\n\t\tif(b[i] & 1) odd ++;\n\t\telse even ++;\n\t}\n\tans += odd / 2 * 2, ans += even / 2 * 2;\n\tif(odd & 1) ans += 3;\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <cmath>\n#include <set>\n#define lowbit(x) (x&(-x))\n#define MAX(a,b) (a<b?b:a)\n#define MIN(a,b) (a<b?a:b)\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\nconst int N = 1e7;\nconst int maxn = 3e5 + 5;\nll mod = 1e9 + 7;\n\nint n, vis[N + 5];\nvector<int> odd, even, g[105];\n\nint check(int n)\n{\n\tif (n <= 2) return 0;\n\tint m = sqrt(n);\n\tfor (int i = 2; i <= m; i++) if (n%i == 0) return 0;\n\treturn 1;\n}\n\nint link[105], used[105];\nint dfs(int u)\n{\n\tfor (int j = 0; j < g[u].size(); j++)\n\t{\n\t\tint v = g[u][j];\n\t\tif (!used[v])\n\t\t{\n\t\t\tused[v] = 1;\n\t\t\tif (link[v] == -1 || dfs(link[v]))\n\t\t\t{\n\t\t\t\tlink[v] = u;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tint x;\n\t\tscanf(\"%d\", &x);\n\t\tvis[x] = 1;\n\t}\n\tfor (int i = 1; i <= N + 1; i++)\n\t{\n\t\tif (vis[i] != vis[i - 1])\n\t\t{\n\t\t\tif (i & 1) odd.push_back(i);\n\t\t\telse even.push_back(i);\n\t\t}\n\t}\n\n\tfor (int i = 0; i < odd.size(); i++)\n\t{\n\t\tfor (int j = 0; j < even.size(); ++j)\n\t\t{\n\t\t\tif (check(abs(odd[i] - even[j])))  g[i].push_back(j);\n\t\t}\n\t}\n\n\tmemset(link, -1, sizeof(link));\n\tint k = 0;\n\tfor (int i = 0; i < odd.size(); i++)\n\t{\n\t\tmemset(used, 0, sizeof(used));\n\t\tk += dfs(i);\n\t}\n\n\tprintf(\"%d\", k + ((int)(odd.size() - k) / 2 + (int)(even.size() - k) / 2) * 2 + (int)(odd.size() % 2) * 3);\n}"
  },
  {
    "language": "C++",
    "code": "/********************************************************************************\n\t\n\tCode by a weak man named CYJian, and he hopes the code can get more points.\n\n\tAlgorithm: \n\n ********************************************************************************/\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\n//{{{ FAST IO AND SOME FUNCTIONS\nconst int __SIZE = 1 << 18;\nchar ibuf[__SIZE], *iS, *iT;\n\n#define ge (iS == iT ? (iT = (iS = ibuf) + fread(ibuf, 1, __SIZE, stdin), (iS == iT ? EOF : *iS++)) : *iS++)\n#define ri read_int()\n#define rl read_ll()\n#define FILE(s) freopen(s\"in\", \"r\", stdin), freopen(s\"out\", \"w\", stdout)\n\ntemplate<typename T>\ninline void read(T &x) {\n\tchar ch, t = 0; x = 0;\n\twhile(!isdigit(ch = ge)) t |= ch == '-';\n\twhile(isdigit(ch)) x = x * 10 + (ch ^ 48), ch = ge;\n\tx = t ? -x : x;\n}\ninline int read_int() { int x; return read(x), x; }\ninline ll read_ll() { ll x; return read(x), x; }\n\ntemplate<typename T> inline void chkmin(T&a, T b) { a = a < b ? a : b; }\ntemplate<typename T> inline void chkmax(T&a, T b) { a = a > b ? a : b; }\n//}}}\n\nint tot;\nint pri[5010];\nint chk[5010];\n\ninline void Sieve(int n) {\n\tchk[1] = 0;\n\tfor(int i = 2; i <= n; i++) {\n\t\tif(!chk[i]) pri[++tot] = i;\n\t\tfor(int j = 1; j <= tot; j++) {\n\t\t\tif(i * pri[j] > n) break;\n\t\t\tchk[i * pri[j]] = 0;\n\t\t\tif(i % pri[j] == 0) break;\n\t\t}\n\t}\n}\n\ninline int check(int x) {\n\tif(x <= 5000) return !chk[x];\n\tfor(int *p = pri + 1;; ++p) {\n\t\tif((*p) * (*p) > x) return 1;\n\t\tif(x % (*p) == 0) return 0;\n\t}\n}\n\nvector<int>to[210];\nint vis[210];\nint arr[210];\nint p[210];\nint tim, N;\n\ninline int Try(int x) {\n\tfor(auto u : to[x]) {\n\t\tif(arr[u] == tim) continue;\n\t\tarr[u] = tim;\n\t\tif(!vis[u] || Try(vis[u])) {\n\t\t\tvis[u] = x;\n\t\t\tvis[x] = u;\n\t\t\treturn 1;\n\t\t}\n\t} return 0;\n}\n\nint main() {\n#ifdef LOCAL\n\tFILE(\"\");\n#endif\n\n\tSieve(5000);\n\tint n = ri, ce = 0, co = 0;\n\n\tfor(int i = 1; i <= n; i++) {\n\t\tint x = ri;\n\t\tif(p[N] == x) --N;\n\t\telse p[++N] = x;\n\t\tp[++N] = x + 1;\n\t}\n\n\tfor(int i = 1; i <= N; i++) \n\t\tp[i] & 1 ? ++co : ++ce;\n\n\tfor(int i = 1; i <= N; i++)\n\t\tfor(int j = i + 1; j <= N; j++) {\n\t\t\tif(((p[i] ^ p[j]) & 1) && check(p[j] - p[i]))\n\t\t\t\tto[i].push_back(j), to[j].push_back(i);\n\t\t}\n\n\tint res = 0;\n\tfor(int i = tim = 1; i <= N; ++i, ++tim)\n\t\tif((p[i] & 1) && Try(i))\n\t\t\t--co, --ce, ++res;\n\n\tres += (co / 2 + ce / 2) << 1;\n\tif((co | ce) & 1) res += 3;\n\n\tcout << res << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace std;\nusing namespace __gnu_pbds;\n\n#define ll long long\n#define db long double\n#define ii pair<int,int>\n#define vi vector<int>\n#define fi first\n#define se second\n#define sz(a) (int)(a).size()\n#define all(a) (a).begin(),(a).end()\n#define pb push_back\n#define mp make_pair\n#define FN(i, n) for (int i = 0; i < (int)(n); ++i)\n#define FEN(i,n) for (int i = 1;i <= (int)(n); ++i)\n#define rep(i,a,b) for(int i=a;i<b;i++)\n#define repv(i,a,b) for(int i=b-1;i>=a;i--)\n#define SET(A, val) memset(A, val, sizeof(A))\ntypedef tree<int ,null_type,less<int>,rb_tree_tag,tree_order_statistics_node_update>ordered_set ;\n// order_of_key (val): returns the no. of values less than val\n// find_by_order (k): returns the kth largest element.(0-based)\n#define TRACE\n#ifdef TRACE\n#define trace(...) __f(#__VA_ARGS__, __VA_ARGS__)\ntemplate <typename Arg1>\nvoid __f(const char* name, Arg1&& arg1){\n  cerr << name << \" : \" << arg1 << std::endl;\n}\ntemplate <typename Arg1, typename... Args>\nvoid __f(const char* names, Arg1&& arg1, Args&&... args){\n  const char* comma = strchr(names + 1, ','); cerr.write(names, comma - names) << \" : \" << arg1<<\" | \";__f(comma+1, args...);\n}\n#else\n#define trace(...)\n#endif\nconst int N=205,L=1e7+5;\nbool mark[L],prime[L];\nnamespace match\n{\n  const int N=205;\n  int l[N],r[N],n,m;\n  bool a[N][N],seen[N];\n  bool findmatch(int i)\n  {\n    rep(j,0,m)\n      {\n\tif(a[i][j] && !seen[j])\n\t  {\n\t    seen[j]=true;\n\t    if(r[j]<0 || findmatch(r[j]))\n\t      {\n\t\tl[i]=j; r[j]=i;\n\t\treturn true;\n\t      }\n\t  }\n      }\n    return false;\n  }\n  int bipartitematch()\n  {\n    int cnt=0;\n    rep(i,0,n) l[i]=-1;\n    rep(i,0,m) r[i]=-1;\n    rep(i,0,n)\n      {\n\trep(j,0,m) seen[j]=false;\n\tif(findmatch(i)) cnt++;\n      }\n    return cnt;\n  }\n};\nint main()\n{\n  std::ios::sync_with_stdio(false);\n  cin.tie(NULL) ; cout.tie(NULL) ;\n  memset(prime,true,sizeof(prime));\n  prime[1]=false;\n  rep(i,2,L)\n    {\n      if(!prime[i]) continue;\n      for(int j=2*i;j<L;j+=i)\n\tprime[j]=false;\n    }\n  prime[2]=false;\n  int n,x;\n  cin>>n;\n  rep(i,1,n+1)\n    {\n      cin>>x;\n      mark[x]=true;\n    }\n  vi arr;\n  rep(i,1,L-1)\n    if((mark[i-1] && !mark[i])  || (!mark[i-1] && mark[i]))\n      arr.pb(i);\n  match::n=match::m=sz(arr);\n  int odd=0,even=0;\n  for(int x:arr)\n    {\n      if(x%2==0) even++;\n      else odd++;\n    }\n  rep(i,0,sz(arr))\n    rep(j,i+1,sz(arr))\n    {\n      if(prime[arr[j]-arr[i]]) match::a[i][j]=1;\n      else match::a[i][j]=0;\n    }\n  int k=match::bipartitematch();\n  int ans=k+((even-k)/2+(odd-k)/2)*2+((even-k)&1)*3;\n  cout<<ans<<endl;\n  return 0 ;\n}\n"
  },
  {
    "language": "C++",
    "code": "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author\n */\n\n#ifndef MAJK_LIB\n#define MAJK_LIB\n\n#include <vector>\n#include <stack>\n#include <iostream>\n#include <unordered_map>\n#include <map>\n#include <iomanip>\n#include <set>\n#include <functional>\n#include <fstream>\n#include <algorithm>\n#include <cassert>\n#include <cmath>\n#include <string>\n#include <sstream>\n#include <queue>\n#include <bitset>\nusing namespace std;\n\n#define x first\n#define y second\nconstexpr int MOD = 1000000007;\n\ntypedef std::pair<int,int> pii;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef unsigned int ui;\n\n\ntemplate<typename T, typename F> T foo(T t, T g, F f) {\n\treturn t;\n}\n\n\ntemplate <typename T, typename U> std::istream&operator>>(std::istream&i, pair<T,U>&p) {i >> p.x >> p.y; return i;}\ntemplate<typename T>std::istream&operator>>(std::istream&i,vector<T>&t) {for(auto&v:t){i>>v;}return i;}\ntemplate<typename T>std::ostream&operator<<(std::ostream&o,const vector<T>&t) {for(size_t i=0;i<t.size();++i){o<<t[i]<<\" \\n\"[i == t.size()-1];}return o;}\ntemplate<typename T> using minheap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<typename T> using maxheap = priority_queue<T, vector<T>, less<T>>;\nauto fraclt = [](const pii&a,const pii&b) { return (ll)a.x * b.y < (ll)b.x * a.y; };\nstruct cmpfrac { bool operator()(const pii&a,const pii&b)const { return (ll)a.x * b.y < (ll)b.x * a.y; }};\ntemplate <typename T> bool in(T a, T b, T c) { return a <= b && b < c; }\nint logceil(ll x) {int b=0;while(x){x>>=1;++b;}return b;}\n\nnamespace std {\n    template<typename T,typename U>struct hash<pair<T,U>>{hash<T>t;hash<U>u;size_t operator()(const pair<T,U>&p)const{return t(p.x)^(u(p.y)<<7);}};\n}\ntemplate<typename T,typename F>T bsh(T l,T h,const F&f){T r=-1,m;while(l<=h){m=(l+h)/2;if(f(m)){l=m+1;r=m;}else{h=m-1;}}return r;}\ntemplate<typename T,typename F>T bsl(T l,T h,const F&f){T r=-1,m;while(l<=h){m=(l+h)/2;if(f(m)){h=m-1;r=m;}else{l=m+1;}}return r;}\ntemplate<typename T> T gcd(T a,T b) { if (a<b) swap(a,b); return b?gcd(b,a%b):a; }\n\ntemplate<typename T>class vector2:public vector<vector<T>>{public:vector2(){} vector2(size_t a,size_t b,T t=T()):vector<vector<T>>(a,vector<T>(b,t)){}};\ntemplate<typename T>class vector3:public vector<vector<vector<T>>>{public:vector3(){} vector3(size_t a,size_t b,size_t c,T t=T()):vector<vector<vector<T>>>(a,vector<vector<T>>(b,vector<T>(c,t))){}};\ntemplate <typename T> struct bounded_priority_queue {\n\tinline bounded_priority_queue(ui X) : A(X), B(0) {}\n\tinline void push(ui L, T V) { B = max(B, L); A[L].push(V); }\n\tinline const T &top() const { return A[B].front(); }\n\tinline void pop() { A[B].pop(); while (B > 0 && A[B].empty()) --B; }\n\tinline bool empty() const { return A[B].empty(); }\n\tinline void clear() { B = 0; for (auto &a: A) a = queue<T>(); }\nprivate:\n\tvector<queue<T>> A; ui B;\n};\n\n\n#endif\n#ifndef PRIMES_H\n#define PRIMES_H\n\n\n\n\nstruct Sieve : public std::vector<bool> {\n\texplicit Sieve(int n) : vector<bool>(n+1, true), n(n) {\n\t\tat(0) = false;\n\t\tat(1) = false;\n\t\tfor (int i = 2; i*i <= n; ++i) {\n\t\t\tif (at(i)) for (int j = i*i; j <= n; j+=i) (*this)[j] = false;\n\t\t}\n\t}\n\n\tvector<int> primes() const {\n\t\tvector<int> ans;\n\t\tfor (int i=2; i<=n; ++i) if (at(i)) ans.push_back(i);\n\t\treturn ans;\n\t}\n\nprivate:\n\tint n;\n};\n\nstruct Moebius : public std::vector<std::pair<int, int>> {\n\texplicit Moebius(int n) : Moebius(n, Sieve{n}.primes()) {}\n\n\tMoebius(int n, const vector<int>& primes) {\n\t\tsearch(-1, 1, 1, n, primes);\n\t\tstd::sort(begin(), end());\n\t}\nprivate:\n\tvoid search(int i, int x, int y, int n, const vector<int>&primes) {\n\t\tpush_back({x,y});\n\t\twhile (++i < primes.size() && (ll)x * primes[i] <= n) search(i, x*primes[i], -y, n, primes);\n\t}\n};\n\n#endif //PRIMES_H\n\n\nclass F {\npublic:\n\tSieve S{10000000};\n\tvector<int> X;\n\n\tint cost(int x) {\n\t\tif (x == 0) return 0;\n\t\tif (x%2==0) return 2;\n\t\tif (S[x]) return 1;\n\t\treturn 3;\n\t}\n\n\tvoid solve(istream& cin, ostream& cout) {\n\t\tint N; cin >> N;\n\t\tX.resize(N);\n\t\tcin >> X;\n\n\t\t// auto P = S.primes();\n\n\t\tvector2<int> D(N, N, 10000);\n\t\tvector2<int> J(N, N, 10000);\n\t\tfor (int l = 0; l < N; ++l) {\n \t\t\tfor (int i = 0; i + l < N; ++i) {\n\n\t\t\t\tint j = i + l;\n\t\t\t\tif (l == 0) {\n\t\t\t\t\tD[i][j] = 3;\n\t\t\t\t\tJ[i][j] = 0;\n\t\t\t\t}\n\t\t\t\tfor (int k = i; k < j; ++k) {\n\t\t\t\t\tJ[i][j] = min(J[i][j], J[i][k] + J[k+1][j] + cost(X[k+1] - X[k] - 1));\n\t\t\t\t\tD[i][j] = min(D[i][j], D[i][k] + D[k+1][j]);\n\t\t\t\t}\n\n\t\t\t\tD[i][j] = min(D[i][j], J[i][j] + cost(X[j] - X[i] + 1));\n\t\t\t\tJ[i][j] = min(J[i][j], D[i][j] + cost(X[j] - X[i] + 1));\n\n\t\t\t}\n\t\t}\n\n\t\t//cerr << D;\n\t\t//cerr << J;\n\n\n\t\tcout << D[0][N-1] << endl;\n    }\n};\n\n\nint main() {\n\tios_base::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr);\n\tF solver;\n\tstd::istream& in(std::cin);\n\tstd::ostream& out(std::cout);\n\tsolver.solve(in, out);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <set>\n#include <map>\n#include <list>\n#include <time.h>\n#include <math.h>\n#include <random>\n#include <deque>\n#include <queue>\n#include <cassert>\n#include <unordered_map>\n#include <iomanip>\n\nusing namespace std;\n\ntypedef long long ll;\n\nmt19937 rnd(228);\n\nconst int M = 2e7 + 7;\nconst int N = 1e2 + 1;\n\nbool prime[M];\n\nll dp[N][N][2];\n\nint get(int x)\n{\n    if (x == 0)\n    {\n        return 0;\n    }\n    if (x > 2 && prime[x])\n    {\n        return 1;\n    }\n    else\n    {\n        return 2 + (x % 2);\n    }\n}\n\nint main()\n{\n#ifdef ONPC\n    freopen(\"a.in\", \"r\", stdin);\n#endif\n    for (int i = 0; i < M; i++)\n    {\n        prime[i] = 1;\n    }\n    prime[1] = 0;\n    for (int i = 2; i < M; i++)\n    {\n        if (prime[i])\n        {\n            for (int j = i + i; j < M; j += i)\n            {\n                prime[j] = 0;\n            }\n        }\n    }\n    int n;\n    scanf(\"%d\", &n);\n    vector <int> x(n);\n    for (int i = 0; i < n; i++)\n    {\n        for (int j = 0; j < n; j++)\n        {\n            dp[i][j][0] = 1e18;\n            dp[i][j][1] = 1e18;\n        }\n    }\n    for (int i = 0; i < n; i++)\n    {\n        scanf(\"%d\", &x[i]);\n        dp[i][i][0] = 0;\n    }\n    for (int i = 0; i + 1 < n; i++)\n    {\n        dp[i][i + 1][0] = get(x[i + 1] - x[i] - 1);\n    }\n    for (int len = 1; len <= n; len++)\n    {\n        for (int l = 0; l + len - 1 < n; l++)\n        {\n            int r = l + len - 1;\n            for (int t = 0; t < 2; t++)\n            {\n                for (int j = l; j < r; j++)\n                {\n                    dp[l][r][t] = min(dp[l][r][t], dp[l][j][t] + (t == 0 ? get(x[j + 1] - x[j] - 1) : 0) + dp[j + 1][r][t]);\n                }\n            }\n            for (int t = 0; t < 2; t++)\n            {\n                dp[l][r][t] = min(dp[l][r][t], dp[l][r][t ^ 1] + get(x[r] - x[l] + 1));\n            }\n        }\n    }\n    printf(\"%lld\\n\", dp[0][n - 1][1]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <chrono>\n#define _USE_MATH_DEFINES\n#include <cmath>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <iomanip>\n#include <iterator>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <tuple>\n#include <utility>\n#include <vector>\nusing namespace std;\n\n#define FOR(i,m,n) for(int i=(m);i<(n);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(v) (v).begin(),(v).end()\n\nconst int INF = 0x3f3f3f3f;\nconst long long LINF = 0x3f3f3f3f3f3f3f3fLL;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\n// const int MOD = 998244353;\nconst int dy[] = {1, 0, -1, 0}, dx[] = {0, -1, 0, 1};\n// const int dy[] = {1, 1, 0, -1, -1, -1, 0, 1},\n//           dx[] = {0, -1, -1, -1, 0, 1, 1, 1};\n\nstruct IOSetup {\n  IOSetup() {\n    cin.tie(nullptr);\n    ios_base::sync_with_stdio(false);\n    cout << fixed << setprecision(20);\n    cerr << fixed << setprecision(10);\n  }\n} iosetup;\n/*-------------------------------------------------*/\nvector<bool> sieve_of_eratosthenes(int num) {\n  vector<bool> res(num + 1, true);\n  if (num >= 0) {\n    res[0] = false;\n    if (num >= 1) res[1] = false;\n  }\n  for (int i = 2; i * i <= num; ++i) if (res[i]) {\n    for (int j = i * i; j <= num; j += i) res[j] = false;\n  }\n  return res;\n}\n\nstruct HopcroftKarp {\n  vector<int> match;\n\n  HopcroftKarp(int left, int right) : left(left), graph(left), match(left + right, -1), level(left), used(left, -1) {}\n\n  void add_edge(int u, int v) { graph[u].emplace_back(left + v); }\n\n  int solve() {\n    int res = 0;\n    while (true) {\n      bfs();\n      int tmp = 0;\n      REP(i, left) if (match[i] == -1) {\n        if (dfs(i)) ++tmp;\n        ++timestamp;\n      }\n      if (tmp == 0) return res;\n      res += tmp;\n    }\n  }\n\nprivate:\n  int left, timestamp = 0;\n  vector<vector<int> > graph;\n  vector<int> level, used;\n\n  void bfs() {\n    fill(ALL(level), -1);\n    queue<int> que;\n    REP(i, left) {\n      if (match[i] == -1) {\n        que.emplace(i);\n        level[i] = 0;\n      }\n    }\n    while (!que.empty()) {\n      int ver = que.front(); que.pop();\n      for (int e : graph[ver]) if (match[e] != -1 && level[match[e]] == -1) {\n        level[match[e]] = level[ver] + 1;\n        que.emplace(match[e]);\n      }\n    }\n  }\n\n  bool dfs(int ver) {\n    used[ver] = timestamp;\n    for (int e : graph[ver]) {\n      int tmp = match[e];\n      if (tmp == -1 || (used[tmp] < timestamp && level[tmp] == level[ver] + 1 && dfs(tmp))) {\n        used[ver] = timestamp;\n        match[e] = ver;\n        match[ver] = e;\n        return true;\n      }\n    }\n    return false;\n  }\n};\n\nint main() {\n  const int X = 10000000;\n  vector<bool> primes = sieve_of_eratosthenes(X);\n  int n; cin >> n;\n  vector<int> a(X + 2, 0);\n  while (n--) {\n    int x; cin >> x;\n    a[x] = 1;\n  }\n  vector<int> b_odd, b_even;\n  FOR(i, 1, X + 2) {\n    if (a[i - 1] ^ a[i]) (i & 1 ? b_odd : b_even).emplace_back(i);\n  }\n  int l = b_odd.size(), r = b_even.size();\n  HopcroftKarp hk(l, r);\n  REP(i, l) REP(j, r) {\n    if (primes[abs(b_odd[i] - b_even[j])]) hk.add_edge(i, j);\n  }\n  int k = hk.solve();\n  cout << k + ((l - k) / 2 + (r - k) / 2) * 2 + ((l - k) & 1) * 3 << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <cstdio>\n#include <algorithm>\n#include <cmath>\n#define maxn 1005\n#define maxm 10000005\n#define Rint register int\n#define INF 0x3f3f3f3f\nusing namespace std;\ntypedef long long lxl;\n\ntemplate <typename T>\ninline void read(T &x)\n{\n\tx=0;T f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9') {if(ch=='-') f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9') {x=(x<<1)+(x<<3)+ch-'0';ch=getchar();}\n\tx*=f;\n}\n\nint prime[maxm],cnt;\nbool flag[maxm];\n\ninline void sieve()\n{\n\tfor(int i=2;i<maxm;++i)\n\t{\n\t\tif(!flag[i]) prime[++cnt]=i;\n\t\tfor(int j=1;j<=cnt&&i*prime[j]<maxm;++j)\n\t\t{\n\t\t\tflag[i*prime[j]]=true;\n\t\t\tif(!(i%prime[j])) break;\n\t\t}\n\t}\n\tflag[1]=flag[2]=true;\n}\n\nstruct edge\n{\n\tint u,v,next;\n\tedge(int u,int v,int next):u(u),v(v),next(next){}\n\tedge(){}\n}e[maxn<<1];\n\nint head[maxn],k;\n\ninline void add(int u,int v)\n{\n\te[k]=edge(u,v,head[u]);\n\thead[u]=k++;\n}\n\nint n;\nint a[maxn],f[maxm],L[maxn],R[maxn];\nint match[maxn];\nbool vis[maxn];\n\ninline int findpath(int u)\n{\n\tfor(int i=head[u];~i;i=e[i].next)\n\t{\n\t\tint v=e[i].v;\n\t\tif(!vis[v])\n\t\t{\n\t\t\tvis[v]=true;\n\t\t\tif(!match[v]||findpath(match[v]))\n\t\t\t{\n\t\t\t\tmatch[v]=u;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\ninline int Hungary()\n{\n\tint res=0;\n\tfor(int i=1;i<=L[0];++i)\n\t{\n\t\tmemset(vis,0,sizeof(vis));\n\t\tres+=findpath(i);\n\t}\n\treturn res;\n}\n\nint main()\n{\n\tsieve();\n\tread(n);\n\tint up=0;\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tread(a[i]);\n\t\t++f[a[i]];\n\t\tup=max(up,a[i]);\n\t}\n\tfor(int i=1;i<=up+1;++i)\n\t\tif(f[i]!=f[i-1])\n\t\t{\n\t\t\tif(i&1) L[++L[0]]=i;\n\t\t\telse R[++R[0]]=i;\n\t\t}\n\tmemset(head,-1,sizeof(head));\n\tfor(int i=1;i<=L[0];++i)\n\t\tfor(int j=1;j<=R[0];++j)\n\t\t\tif(!flag[abs(L[i]-R[j])])\n\t\t\t\tadd(i,j);\n\tint maxmatch=Hungary();\n\tint ans=maxmatch;\n\tans+=(L[0]-maxmatch)/2*2+(R[0]-maxmatch)/2*2;\n\tans+=((L[0]-maxmatch)&1)*3;\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n\n#include <iostream>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <unordered_set>\n#include <queue>\n#include <set>\n#include <algorithm>\n#include <numeric>\n#include <list>\nusing namespace std;\n\nusing QWORD  = uint64_t;\nusing SQWORD = int64_t;\nusing DWORD  = uint32_t;\nusing SDWORD = int32_t;\nusing WORD   = uint16_t;\nusing SWORD  = int16_t;\nusing BYTE   = uint8_t;\nusing SBYTE  = int8_t;\nusing DOUBLE = double;\nusing FLOAT  = float;\n\n#define MIN_SDWORD (-2147483648)\n#define MAX_SDWORD (2147483647)\n#define MIN_SBYTE (-128)\n#define MAX_SBYTE (127)\n\n#define MIN_SQWORD (0x8000000000000000)\n#define MAX_SQWORD (0x7FFFFFFFFFFFFFFF)\n\n#define MAX_QWORD  (0xFFFFFFFFFFFFFFFF)\n#define MAX_DWORD  (0xFFFFFFFF)\n#define MAX_WORD   (0xFFFF)\n#define MAX_BYTE   (0xFF)\n\n#define MAX_DOUBLE      (1.0e+308)\n#define DOUBLE_EPS      (1.0e-12)\n#define MIN_DOUBLE_N    (-1.0e+308)\n\n#define ArrayLength(a)  (sizeof(a) / sizeof(a[0]))\n\nstatic inline DOUBLE MAX(DOUBLE a, DOUBLE b) { return a > b ? a : b; }\nstatic inline QWORD MAX(QWORD a, QWORD b) { return a > b ? a : b; }\nstatic inline DWORD MAX(DWORD a, DWORD b) { return a > b ? a : b; }\nstatic inline SDWORD MAX(SDWORD a, SDWORD b) { return a > b ? a : b; }\nstatic inline DOUBLE MIN(DOUBLE a, DOUBLE b) { return a < b ? a : b; }\nstatic inline QWORD MIN(QWORD a, QWORD b) { return a < b ? a : b; }\nstatic inline DWORD MIN(DWORD a, DWORD b) { return a < b ? a : b; }\nstatic inline SDWORD MIN(SDWORD a, SDWORD b) { return a < b ? a : b; }\nstatic inline DOUBLE ABS(DOUBLE a) { return 0 < a ? a : -a; };\n\n#define BYTE_BITS   (8)\n#define WORD_BITS   (16)\n#define DWORD_BITS  (32)\n#define QWORD_BITS  (64)\n\nstatic inline void inputStringSpSeparated(char *pcStr)\n{\n    char *pcCur = pcStr;\n    for (;;) {\n        char c = getchar();\n        if (('\\n' == c) || (EOF == c) || (' ' == c)) {\n            break;\n        }\n        *pcCur = c;\n        pcCur++;\n    }\n    *pcCur = '\\0';\n}\n\nstatic inline void inputString(char *pcStr)\n{\n    char *pcCur = pcStr;\n    for (;;) {\n        char c = getchar();\n        if (('\\n' == c) || (EOF == c)) {\n            break;\n        }\n        *pcCur = c;\n        pcCur++;\n    }\n    *pcCur = '\\0';\n}\n\n\nstatic inline SQWORD inputSQWORD(void)\n{\n    SQWORD sqNumber = 0;\n    SQWORD sqMultiplier = 1;\n    bool bRead = false;\n    for (;;) {\n        char c = getchar();\n        if (!bRead) {\n            if ('-' == c) {\n                sqMultiplier = -1;\n            }\n        }\n        if (('0' <= c) && (c <= '9')) {\n            sqNumber *= 10LL;\n            sqNumber += (SQWORD)(c - '0');\n            bRead = true;\n        } else {\n            if (bRead) {\n                return sqNumber * sqMultiplier;\n            }\n        }\n    }\n}\n\n\nstatic inline SDWORD inputSDWORD(void)\n{\n    SDWORD lNumber = 0;\n    SDWORD lMultiplier = 1;\n    bool bRead = false;\n    for (;;) {\n        char c = getchar();\n        if (!bRead) {\n            if ('-' == c) {\n                lMultiplier = -1;\n            }\n        }\n        if (('0' <= c) && (c <= '9')) {\n            lNumber *= 10;\n            lNumber += (c - '0');\n            bRead = true;\n        } else {\n            if (bRead) {\n                return lNumber * lMultiplier;\n            }\n        }\n    }\n}\n\nstatic inline DOUBLE inputFP(void)\n{\n    DOUBLE dInt = 0.0;\n    DOUBLE dFrac = 0.0;\n    DOUBLE dMultiplier = 1.0;\n    DWORD dwFpCnt = 0;\n    DOUBLE *pdCur = &dInt;\n    bool bRead = false;\n    for (;;) {\n        char c = getchar();\n        if (!bRead) {\n            if ('-' == c) {\n                dMultiplier = -1;\n            }\n        }\n        if ('.' == c) {\n            pdCur = &dFrac;\n        } else if (('0' <= c) && (c <= '9')) {\n            (*pdCur) *= 10;\n            (*pdCur) += (DOUBLE)(c - '0');\n            bRead = true;\n            if (pdCur == &dFrac) {\n                dwFpCnt++;\n            }\n        } else {\n            if (bRead) {\n                return dMultiplier * (dInt + dFrac / (pow((DOUBLE)10.0 , (DOUBLE)dwFpCnt)));\n            }\n        }\n    }\n}\n\n\n/**\n *  mod による操作ライブラリ\n */\n\n#define ANS_MOD (1000000007LL)\n \nstatic SQWORD addMod(SQWORD x, SQWORD y)\n{ \n    return (x + y) % ANS_MOD;\n}\n \nstatic SQWORD subMod(SQWORD x, SQWORD y)\n{\n    return (x - y + ANS_MOD) % ANS_MOD;\n}\n \nstatic SQWORD mulMod(SQWORD x, SQWORD y) \n{\n    return (x * y) % ANS_MOD;\n}\n \nstatic SQWORD powMod(SQWORD x, SQWORD e) {\n    SQWORD v = 1;\n    for (; e; x = mulMod(x, x), e >>= 1) {\n        if (e & 1) {\n            v = mulMod(v, x);\n        }\n    }\n    return v;\n}\n \nstatic SQWORD divMod(SQWORD x, SQWORD y)\n{\n    return mulMod(x, powMod(y, ANS_MOD - 2));\n}\n \n \nstatic SQWORD combMod(SQWORD n, SQWORD k)\n{\n    SQWORD v=1;\n    for(SQWORD i=1; i<=k; i++) {\n        v = divMod(mulMod(v, n-i+1),i);\n    } \n    return v;\n}\n\n/*----------------------------------------------*/\n\n#define MAX_V   (500)\n#define INF 2e9\n\n/* 辺を表す構造体 */\nstruct edge {int to, cap ,rev; };\n \n/* グラフの隣接リスト表現 */\nvector<edge> G[MAX_V];\n/* DFSですべに調べたかのグラフ */\nbool used[MAX_V];\n \n/* fromからtoへ向かう容量capの辺をグラフに追加する */\n/* 相互参照できるようにしている */\nvoid add_edge(int from, int to, int cap){\n    G[from].push_back((edge){to, cap, (int)G[to].size()});\n    G[to].push_back((edge){from, 0, (int)G[from].size() - 1});    \n}\n \n/* 増加パスをdfsで探す */\nint dfs(int v, int t, int f){\n    if(v==t) return f;\n    used[v] = true;\n    for(int i=0; i<G[v].size(); i++){\n        edge &e = G[v][i];\n        if(!used[e.to] && e.cap>0){\n            int d = dfs(e.to, t, min(f, e.cap));\n            if(d>0){\n                e.cap -= d;\n                G[e.to][e.rev].cap += d;\n                return d;\n            }\n        }\n    }\n    return 0;\n}\n \nint max_flow(int s, int t){\n    int flow = 0;\n    for(;;){\n        memset(used, 0, sizeof(used));\n        int f = dfs(s, t, INF);\n        if(f==0) return flow;\n        flow += f;\n    }\n}\n/*----------------------------------------------*/\n\nclass PrimeTable {\n    vector<bool> vbIsPrime;\n\npublic:\n    PrimeTable(SDWORD lMax) {\n        /* lSearchMax と ループ内の *2 の関係から、入力は3以上とすること */\n        if (!(1 <= lMax)) {\n            printf(\"Oops!\");\n            return;\n        }\n\n        /* 素数のリストを作る */\n        vbIsPrime.resize(lMax + 1, true);\n        SDWORD lSearchMax = sqrt(lMax) + 1;\n        vbIsPrime[0] = false;\n        vbIsPrime[1] = false;\n        for (SDWORD lPrime = 2; lPrime < lSearchMax; lPrime++) {\n            if (vbIsPrime[lPrime]) {\n                for (SDWORD lCurNum = lPrime * 2; lCurNum <= lMax; lCurNum += lPrime) {\n                    vbIsPrime[lCurNum] = false;\n                }\n            }\n        }\n    };\n\n    bool IsPrime(SQWORD sqN)\n    {\n        return vbIsPrime[sqN];\n    }\n};\n\n\n/*----------------------------------------------*/\n\n#define PNT_NO_START    (0)\n#define PNT_NO_OFFSET   (200)\n#define PNT_NO_TARGET   (401)\n#define FLOW_OFFSET     (1000000000)\n#define CAPACITY_INF    (1000000001)\n#define DUMMY_COST      (1)\n\nint main(void)\n{\n    SQWORD sqN = inputSQWORD();\n\n    vector<SQWORD> vsqA;\n    vector<SQWORD> vsqB;\n\n    PrimeTable prime(1e7 + 1);\n \n    map<SQWORD, SQWORD> mapB;\n\n    for (SQWORD sqIdx = 0; sqIdx < sqN; sqIdx++) {\n        SQWORD sqA = inputSQWORD();\n        vsqA.emplace_back(sqA);\n\n        mapB[sqA] ^= 1;\n        mapB[sqA + 1] ^= 1;\n    }\n\n    vector<SQWORD> vsqBEven, vsqBOdd;\n\n    for (auto b: mapB) {\n        if (0 < b.second) {\n            if (0 == (b.first % 2)) {\n                vsqBEven.emplace_back(b.first);\n            } else {\n                vsqBOdd.emplace_back(b.first);\n            }\n        }\n    }\n\n    SQWORD sqNodeEven = 1;\n    for (auto e: vsqBEven) {\n        SQWORD sqNodeOdd = 1;\n        for (auto o: vsqBOdd) {\n            if (prime.IsPrime(abs(e - o))) {\n                add_edge(sqNodeOdd, sqNodeOdd + PNT_NO_OFFSET, 1);\n            }\n            sqNodeOdd++;\n        }\n        sqNodeEven++;\n    }\n    for (SQWORD sqIdx = 1; sqIdx <= vsqBEven.size(); sqIdx++) {\n        add_edge(PNT_NO_START, sqIdx, 1);\n    }\n    for (SQWORD sqIdx = 1; sqIdx <= vsqBOdd.size(); sqIdx++) {\n        add_edge(sqIdx + PNT_NO_OFFSET, PNT_NO_TARGET, 1);\n    }\n\n\n\n    SQWORD sqMaxFlow = max_flow(PNT_NO_START, PNT_NO_TARGET);\n    SQWORD vsqCRestEven = vsqBEven.size() - sqMaxFlow;\n    SQWORD vsqCRestOdd  = vsqBOdd.size() - sqMaxFlow;\n\n    SQWORD sqAns = sqMaxFlow;    \n    sqAns += ((vsqCRestEven / 2) * 2);\n    sqAns += ((vsqCRestOdd / 2) * 2);\n    if (0 < (vsqCRestEven %  2)) {\n        sqAns += 3;\n    }\n\n    printf(\"%lld\\n\", sqAns);\n\n    return 0;\n}\n/*------------------------------------------*/\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define maxn 300\n#define maxm 100100\nusing namespace std;\nstruct edge{\n    int r,nxt,w;\n}e[maxm];\nint head[maxn],esz,S,T,dep[maxn],q[maxn],ql,qr,cur[maxn];\nvoid addedge(int u,int v,int w){\n    e[esz].r=v;\n    e[esz].nxt=head[u];\n    e[esz].w=w;\n    head[u]=esz++;\n    e[esz].r=u;\n    e[esz].nxt=head[v];\n    e[esz].w=0;\n    head[v]=esz++;\n}\nbool bfs(){\n    ql=qr=0;\n    q[qr++]=S;\n//\tprintf(\"[ok,%d,%d]\",S,T);\n    for(int i=S;i<=T;++i)dep[i]=0,cur[i]=head[i];\n    dep[S]=1;\n    while(ql<qr){\n        int x=q[ql++];\n        for(int t=head[x];t;t=e[t].nxt)if(!dep[e[t].r]&&e[t].w)\n            dep[e[t].r]=dep[x]+1,q[qr++]=e[t].r;\n    }\n    \n    return dep[T]!=0;\n}\nint find(int u,int flow){\n    if(u==T)return flow;\n    int a=0,used=0;\n    for(int& t=cur[u];t;t=e[t].nxt)if(e[t].w&&dep[e[t].r]==dep[u]+1&&(a=find(e[t].r,min(flow-used,e[t].w)))){\n        e[t].w-=a;e[t^1].w+=a,used+=a;\n        if(used==flow)return used;\n           \n    }\n    if(!used)dep[u]=0;\n    return used;\n}\nint dinic(){\n\tint ans=0,a=0;\n\twhile(bfs())\n\t\twhile(a=find(S,1<<30))ans+=a;\n\treturn ans;\n}\nconst int lim=10000010;\nint pri[lim],psz,n,a[maxn],tp,d[2];\nbool vis[lim],c[lim];\nint main(){\n\tfor(int i=2;i<lim;++i){\n\t\tif(!vis[i])pri[++psz]=i;\n\t\tfor(int j=1;j<=psz&&pri[j]*i<lim;++j){\n\t\t\tvis[i*pri[j]]=1;if(i%pri[j]==0)break;\n\t\t}\n\t}\n\tscanf(\"%d\",&n);\n\tfor(int i=1,x;i<=n;++i)scanf(\"%d\",&x),c[x]^=1,c[x+1]^=1;\n\tfor(int i=1;i<lim;++i)if(c[i])a[++tp]=i;\n\tS=0,T=tp+1,vis[1]=vis[2]=1;\n\tfor(int i=1;i<=tp;++i)\n\t\tfor(int j=i+1;j<=tp;++j)if((a[i]&1)!=(a[j]&1)){\n//\t\t\tprintf(\"{%d,%d}\",a[i],a[j]);\n\t\t\tif(!vis[a[j]-a[i]]){\n\t\t\t\tif(a[i]&1)addedge(i,j,1);\n\t\t\t\telse addedge(j,i,1);\n\t\t\t}\n\t\t}\n\tfor(int i=1;i<=tp;++i)if(a[i]&1)addedge(S,i,1);else addedge(i,T,1);\n\tint ans=dinic();\n\tfor(int i=1;i<=tp;++i)d[a[i]&1]++;\n\td[0]-=ans,d[1]-=ans;\n\tif(d[0]%2)ans+=3,d[0]--,d[1]--;\n\tans+=d[0]+d[1];\n\tprintf(\"%d\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;\nconst int N = 100001;\ntypedef pair<int, int> pii;\n\nnamespace matching {\n\nvector<int> g[N];   //  g[u]:X中顶点$u$的邻接表\nbool vis[N];        //  vis[u]:当前dfs中Y中顶点u是否已被访问过\nint lnk[N];         //  lnk[u]:Y中顶点u对应的匹配点。若u未被匹配则lnk[u]=0\n\n//  从X顶点u出发寻找增广路\nbool dfs(int u) {\n    for (int v : g[u]) {\n        //  v已被访问过，且无法从v出发找到增广路或增广路的上一个节点是v则跳过\n        if (vis[v] || lnk[v] == u) continue;\n        //  v未被访问过，标记v\n        vis[v] = 1;\n        //  v已有匹配点，且无法从v出发找到增广路则跳过\n        if (lnk[v] && !dfs(lnk[v])) continue;\n        //  v没有匹配点或找到从lnk[v]出发的增广路，则设v的匹配点为u\n        lnk[v] = u; return true;\n    }\n    //  找不到增广路\n    return false;\n}\n\n//  接口:\n//  int nl: X节点数; X中节点编号为[1...nl]\n//  int nr: Y节点数; Y中节点编号为[1...nr]\n//  const vector<pii>& es: 二分图中的边集。pii的first为X中节点编号，second为Y中节点编号\n//  返回值vector<pii> res: 得到的最大匹配。\nint match(int nl, int nr, const vector<pii>& es) {\n    //  初始化，建图\n    for (int i = 1; i <= nl; ++i)\n        g[i].clear();\n    fill_n(lnk + 1, nr, 0);\n    for (pii e : es)\n        g[e.first].push_back(e.second);\n    //  依次从每个点出发寻找增广路\n    for (int i = 1; i <= nl; ++i) {\n        fill_n(vis + 1, nr, false);\n        dfs(i);\n    }\n    //  按Y中每个点i的匹配点lnk[i]得到结果\n    int res = 0, lx = nl, ly = nr;\n    for (int i = 1; i <= nr; ++i)\n        if (lnk[i]) res++, lx--, ly--;\n    res += lx / 2 * 2; lx -= lx / 2 * 2;\n    res += ly / 2 * 2; ly -= ly / 2 * 2;\n    assert((lx ^ ly) == 0);\n    if (lx && ly) res += 3;\n    return res;\n}\n\n}\n\nnamespace prime\n{\n\nconst int maxn = 1e7 + 7;\nint vis[maxn];\nint prime[maxn], mu[maxn], minprim[maxn], tot = 0; //1 ~ tot\nvoid get_prime(int maxl) // get prime <= maxl\n{\n    minprim[1] = 1;\n    for (int i = 2; i <= maxl; i++)\n    {\n        if (!vis[i])\n        {\n            prime[++tot] = i; minprim[i] = i;\n        }\n        for (int j = 1; j <= tot; j++)\n        {\n            if (i * prime[j] > maxl) break;\n            vis[i * prime[j]] = 1;\n            minprim[i * prime[j]] = prime[j];\n            if (i % prime[j] == 0) \n            {\n            \tbreak;\n            }\n        }\n    }\n    vis[1] = vis[2] = 1;\n    //vis[i] == 0 -> i is a prime\n}\n\n}\nvector<int>pt;\nvector<pii>es;\nint x[301], lp[301], rp[301];\nint main()\n{\n    prime::get_prime(1e7 + 5);\n    int n; scanf(\"%d\", &n);\n    for (int i = 1; i <= n; i++) scanf(\"%d\", &x[i]);\n    x[0] = -1;\n    for (int i = 1; i <= n; i++)\n    {\n        if (x[i] - 1 != x[i - 1]) pt.push_back(x[i]);\n        if (x[i] + 1 != x[i + 1]) pt.push_back(x[i] + 1);\n    }\n    sort(pt.begin(), pt.end());\n    pt.erase(unique(pt.begin(), pt.end()), pt.end());\n    int nl = 0, nr = 0;\n    for (int x : pt) if (x % 2) lp[++nl] = x;\n    else rp[++nr] = x;\n    for (int i = 1; i <= nl; i++)\n        for (int j = 1; j <= nr; j++)\n        {\n            if (!prime::vis[abs(lp[i] - rp[j])]) es.emplace_back(i, j); \n        }\n    // for (int x : pt) printf(\" %d\\n\", x);\n    printf(\"%d\\n\", matching::match(nl, nr, es));\n    return 0;   \n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<algorithm>\n#define LL long long\n#define MAXN 205\n#define MAXP (MAXN*MAXN)\n#pragma GCC optimize(2)\n#define rg register\nusing namespace std;\ninline int read() {\n\tint f = 1,x = 0;char s = getchar();\n\twhile(s < '0' || s > '9') {if(s == '-') f = -1;s = getchar();}\n\twhile(s >= '0' && s <= '9') {x = x * 10 + s - '0';s = getchar();}\n\treturn x * f;\n}\nstruct it{\n\tint x;\n\tLL s;\n};\nstruct ed{\n\tint v,id;\n\ted(){v = id = 0;}\n\ted(int V,int I){v = V;id = I;} \n};\nbool operator < (it a,it b) {\n\treturn a.s < b.s;\n}\n//int dx[4] = {1,-1,0,0};\n//int dy[4] = {0,0,1,-1};\nvector<ed> g[MAXP];\nint w[MAXP*8];\nbool f[MAXP];\nint d[MAXP];\nint po[MAXN][MAXN];\nint n,m,q,i,j,s,o,k,t,cnt,cn;\nqueue<it> b;\nint fan(int x) {\n\tif(x > MAXP*4) return x - MAXP*4;\n\treturn x + MAXP*4;\n}\nint adde(int x,int y,int wi,int wj) {\n\tg[x].push_back(ed(y,++cnt));\n\tw[cnt] = wi;\n\tg[y].push_back(ed(x,fan(cnt)));\n\tw[fan(cnt)] = wj;\n\treturn cnt;\n}\nqueue<int> qq;\nbool init_bfs() {\n\twhile(!qq.empty()) qq.pop();\n\tmemset(f,0,sizeof(f));\n\tmemset(d,0,sizeof(d));\n\tqq.push(s);\n\tf[s] = 1;\n\td[s] = 1;\n\twhile(!qq.empty()) {\n\t\tint t1 = qq.front();\n\t\tqq.pop();\n//\t\tprintf(\"x:%d s:%lf\\n\",t1.x,t1.s);\n\t\tif(t1 == t) {\n\t\t\treturn 1;\n\t\t}\n\t\tfor(rg int i = 0;i < g[t1].size();i ++) {\n\t\t\tint y = g[t1][i].v,id = g[t1][i].id;\n\t\t\tif(!f[y] && w[id] > 0) {\n\t\t\t\tf[y] = 1;\n\t\t\t\td[y] = d[t1] + 1;\n\t\t\t\tqq.push(y);\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nLL dfs(int x,int minn) {\n\tif(!f[x]) return 0;\n\tif(x == t || minn == 0) return minn;\n\tint ans = 0;\n\tf[x] = 0;\n\tfor(rg int i = 0;i < g[x].size();i ++) {\n\t\tint y = g[x][i].v,id = g[x][i].id,as;\n\t\tif(d[y] == d[x] + 1 && (as = dfs(y,min(minn,w[id]))) > 0) {\n\t\t\tw[id] -= as;\n\t\t\tw[fan(id)] += as;\n\t\t\tans += as;\n\t\t\tminn -= as;\n\t\t\tif(!minn) break;\n\t\t}\n\t}\n\treturn ans;\n}\nint Dinic() {\n\tint ans = 0;\n\twhile(init_bfs()) {\n//\t\tcout<<\"in--ok\"<<endl;\n\t\tans += dfs(s,0x7f7f7f7f);\n//\t\tcout<<\"out--ok\"<<endl;\n\t}\n\treturn ans;\n}\nint A[105];\nint B[205],cntb;\nint prim[4000005],cp = 0;\nbool f2[10000005];\nvoid sieve(int n) {\n\tf2[1] = 1;\n\tfor(int i = 2;i <= n;i ++) {\n\t\tif(!f2[i]) prim[++cp] = i;\n\t\tfor(int j = 1;j <= cp && i * prim[j] <= n;j ++) {\n\t\t\tf2[i * prim[j]] = 1;\n\t\t\tif(i % prim[j] == 0) break;\n\t\t}\n\t}return ;\n}\nint pted[205];\nint main() {\n\tn = read(); A[0] = -1; cntb = 0;cnt = 0;\n\tfor(int i = 1;i <= n;i ++) {\n\t\tA[i] = read();\n\t\tif(A[i-1] < A[i] - 1 && i-1) B[++cntb] = A[i-1] + 1;\n\t\tif(A[i] > A[i-1] + 1) B[++cntb] = A[i];\n\t}A[n+1] = 0x7f7f7f7f;B[++cntb] = A[n] + 1;\n\tsieve(B[cntb]);\n\ts = cntb + 1; t = cntb + 2;\n\tfor(int i = 1;i <= cntb;i ++) {\n\t\tif(B[i] & 1) pted[i] = adde(s,i,1,0);\n\t\telse pted[i] = adde(i,t,1,0);\n//\t\tcout<<pted[i]<<\" \";\n\t\tfor(int j = i+1;j <= cntb;j ++) {\n\t\t\tif(!f2[B[j] - B[i]] && (B[j] - B[i] & 1)) {\n\t\t\t\tadde(i,j,1,0);\n\t\t\t}\n\t\t}\n\t}\n//\tputchar('\\n');\n\tint ans = Dinic();\n//\tcout<<\"1:\"<<ans<<endl;\n\tint cnt1 = 0,cnt2 = 0;\n\tfor(int i = 1;i <= cntb;i ++) {\n\t\tif(w[pted[i]]) {\n\t\t\tif(B[i] & 1) cnt1 ++;\n\t\t\telse cnt2 ++;\n\t\t}\n\t}\n\tans += int(cnt1 / 2) * 2 + int(cnt2 / 2) * 2;\n//\tcout<<cnt1<<\" \"<<cnt2<<endl;\n//\tcout<<\"2:\"<<ans<<endl;\n\tif((cnt1 & 1) || (cnt2 & 1)) ans += 3;\n//\tcout<<\"3:\"<<ans<<endl;\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <cstdio>\n#include <utility>\n\n#define Int register int\n\nusing namespace std;\n\nconst int MAXN = 100, MAXV = 1e7, MAXM = 5e4, MAXP = 664579, INF = 0x3f3f3f3f;\nint n, L, S, T, d[MAXV + 5];\nint pn, Prime[MAXP + 5];\nint CntL, CntR, Left[MAXM + 5], Right[MAXM + 5];\nint Cnte = 1, Head[MAXM + 5];\nbool Vis[MAXV + 5];\npair<int, int> Path[MAXM + 5];\n\nstruct Edge { int To, Flow, nxt; } Graph[MAXM * 2 + 5];\n\ninline int Abs ( const int x ) { return x < 0 ? ~ x + 1 : x; }\n\ninline int Min ( const int a, const int b ) { return a < b ? a : b; }\n\ninline void Link ( const int s, const int t, const int f ) { Graph[++ Cnte] = { t, f, Head[s] }, Head[s] = Cnte; }\n\ninline void AddEdge ( const int s, const int t, const int f ) {\n#ifdef __DEBUG\n\tprintf ( \"<%d, %d, %d>\\n\", s, t, f );\n#endif\n\tLink ( s, t, f ), Link ( f, t, 0 );\n}\n\ninline void Sieve ( const int n ) {\n\tVis[0] = Vis[1] = true;\n\tfor ( Int i = 2; i <= n; ++ i ) {\n\t\tif ( ! Vis[i] ) Prime[++ pn] = i;\n\t\tfor ( Int j = 1; j <= pn && i * Prime[j] <= n; ++ j ) {\n\t\t\tVis[i * Prime[j]] = true;\n\t\t\tif ( ! ( i % Prime[j] ) ) break;\n\t\t}\n\t}\n}\n\ninline bool BFS () {\n\tstatic queue<int> Q;\n\tfor ( ; ! Q.empty (); Q.pop () );\n\tfor ( Int i = 1; i <= T; ++ i ) Vis[i] = false;\n\twhile ( ! Q.empty () ) {\n\t\tint u = Q.front (); Q.pop ();\n\t\tfor ( Int i = Head[u], v; i; i = Graph[i].nxt ) {\n\t\t\tif ( ! Vis[v = Graph[i].To] && Graph[i].Flow > 0 ) {\n\t\t\t\tQ.push ( v ), Vis[v] = true, Path[v] = { u, i };\n\t\t\t\tif ( v == T ) return true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\ninline int EK () {\n\tint ret = 0;\n\tfor ( ; BFS (); ) {\n\t\tint MinFlow = INF;\n\t\tfor ( Int u = T; u ^ S; u = Path[u].first ) MinFlow = Min ( MinFlow, Graph[Path[u].second].Flow );\n\t\tfor ( Int u = T; u ^ S; u = Path[u].first ) {\n\t\t\tGraph[Path[u].second].Flow -= MinFlow;\n\t\t\tGraph[Path[u].second ^ 1].Flow += MinFlow;\n\t\t}\n\t\tret += MinFlow;\n\t}\n\treturn ret;\n}\n\ninline void Work () {\n\tSieve ( MAXV );\n\tscanf ( \"%d\", &n );\n\tfor ( Int i = 1, x; i <= n; ++ i ) {\n\t\tscanf ( \"%d\", &x ), ++ d[x];\n\t\tL = L > x ? L : x;\n\t}\n\tfor ( Int i = 1; i <= L + 1; ++ i ) {\n\t\tif ( d[i] ^ d[i - 1] ) {\n\t\t\tif ( i & 1 ) {\n\t\t\t\tLeft[++ CntL] = i;\n\t\t\t} else {\n\t\t\t\tRight[++ CntR] = i;\n\t\t\t}\n\t\t}\n\t}\n\tS = CntL + CntR + 1, T = S + 1;\n\tfor ( Int i = 1; i <= CntL; ++ i ) AddEdge ( S, i, 1 );\n\tfor ( Int i = 1; i <= CntR; ++ i ) AddEdge ( i + CntL, T, 1 );\n\tfor ( Int i = 1; i <= CntL; ++ i ) {\n\t\tfor ( Int j = 1; j <= CntR; ++ j ) {\n\t\t\tif ( ! Vis[Abs ( Left[i] - Right[j] )] ) {\n\t\t\t\tAddEdge ( i, j + CntL, 1 );\n\t\t\t}\n\t\t}\n\t}\n\tint mxf = EK (), Ans = mxf;\n\tAns += ( CntL - mxf >> 1 << 1 ) + ( CntR - mxf >> 1 << 1 );\n\tAns += ( ( CntL - mxf ) & 1 ) * 3;\n\tprintf ( \"%d\\n\", Ans );\n}\n\nint main () {\n\tWork ();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<iostream>\n#include<queue>\n#include<cmath>\nusing namespace std;\nvoid read(int &x){\n\tchar ch;bool ok;\n\tfor(ok=0,ch=getchar();!isdigit(ch);ch=getchar())if(ch=='-')ok=1;\n\tfor(x=0;isdigit(ch);x=x*10+ch-'0',ch=getchar());if(ok)x=-x;\n}\n#define rg register\nconst int maxn=210;bool vis[maxn];\nint f[maxn],n,ans,a[maxn],mp[maxn][maxn],b[maxn],tot1,tot2,x[maxn];\nbool check(int x){\n\tif((!(x&1))||x==1)return 0;\n\tint n=sqrt(x);\n\tfor(rg int i=2;i<=n;i++)\n\t\tif(!(x%i))return 0;\n\treturn 1;\n}\nbool dfs(int x){\n\tfor(rg int i=1;i<=tot2;i++)\n\t\tif(!vis[i]&&mp[x][i]){\n\t\t\tvis[i]=1;\n\t\t\tif(!f[i]||dfs(f[i]))return f[i]=x,1;\n\t\t}\n\treturn 0;\n}\nint main(){\n\tread(n);\n\tfor(rg int i=1;i<=n;i++)read(x[i]);\n\tif(n==1){printf(\"3\\n\");return 0;}\n\tfor(rg int i=1;i<=n;i++){\n\t\tif(x[i+1]-x[i]!=1||i==n){\n\t\t\tif((x[i]+1)%2==0)a[++tot1]=x[i]+1;\n\t\t\telse b[++tot2]=x[i]+1;\n\t\t}\n\t\tif(x[i]-x[i-1]!=1||i==1){\n\t\t\tif(x[i]&1)b[++tot2]=x[i];\n\t\t\telse a[++tot1]=x[i];\n\t\t}\n\t}\n\t\tfor(rg int i=1;i<=tot1;i++)printf(\"%d \",a[i]);\n\t\tprintf(\"\\n\");\n\t\tfor(rg int j=1;j<=tot2;j++)printf(\"%d \",b[j]);\n\t\tprintf(\"\\n\");\n\tfor(rg int i=1;i<=tot1;i++)\n\t\tfor(rg int j=1;j<=tot2;j++)\n\t\t\tif(check(abs(a[i]-b[j])))mp[i][j]=1,printf(\"%d %d\\n\",i,j);\n\tfor(rg int i=1;i<=tot1;i++){\n\t\tmemset(vis,0,sizeof vis);\n\t\tif(dfs(i))ans++;\n\t}\n\t//\tprintf(\"%d\\n\",ans);\n\tprintf(\"%d\\n\",ans+(tot1-ans)/2*2+(tot2-ans)/2*2+(tot1-ans)%2*3);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nconst ull mod = 1e9 + 7;\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n\nstruct edge{\n    int to,cap,rev;\n};\n\nvector<edge> G[505];\nvector<int> check(505, 0);\n\nint dfs(int v, int t, int f){\n    if(v==t){return f;}\n    check[v]=1;\n    for(int i=0;i<G[v].size();i++){\n        edge &e = G[v][i];\n        if(check[e.to]==0 && e.cap > 0){\n            int ff =dfs(e.to,t,min(f,e.cap));\n            if(ff>0){\n                e.cap -= ff;\n                G[e.to][e.rev].cap += ff;\n                return ff;\n            }\n        }\n    }\n    return 0;\n}\n\nint maxflow(int s,int t){\n    int flow = 0;\n    while(1){\n        fill(check.begin(),check.end(),0);\n        int f = dfs(s,t,INT_MAX);\n        if(f==0){return flow;}\n        flow += f;\n    }\n}\n\nbool prime_check(ll X){\n    if(X<2) return false;\n    ll sqX = (int)sqrt(X)+1;\n    for(int i=2;i<sqX;i++){\n        if(X%i==0) return false;\n    }\n    return true;\n}\n\n\nint main(){\n    int N;\n    cin >> N;\n    ll x[N];\n    REP(i, N) cin >> x[i];\n    sort(x, x+N);\n    vector<ll> koma;\n    REP(i, N){\n        if(i==0||x[i]!=x[i-1]+1) koma.push_back(x[i]);\n        if(i==N-1||x[i+1]!=x[i]+1) koma.push_back(x[i]+1);\n    }\n    vector<ll> koma_even, koma_odd;\n    REP(i, koma.size()){\n        if(koma[i]%2==0){\n            koma_even.push_back(koma[i]);\n        }else{\n            koma_odd.push_back(koma[i]);\n        }\n    }\n    REP(i, koma_even.size()){\n        REP(j, koma_odd.size()){\n            ll dif = abs(koma_even[i]-koma_odd[j]);\n            if(prime_check(dif)){\n                int v1 = i;\n                int v2 = koma_even.size()+j;\n                G[v1].push_back((edge){v2, 1, G[v2].size()});\n                G[v2].push_back((edge){v1, 0, G[v1].size()-1});\n            }\n        }\n    }\n    REP(i, koma_even.size()){\n        int v1 = koma_even.size()+koma_odd.size();\n        int v2 = i;\n        G[v1].push_back((edge){v2, 1, G[v2].size()});\n        G[v2].push_back((edge){v1, 0, G[v1].size()-1});\n    }\n    REP(i, koma_odd.size()){\n        int v1 = koma_even.size()+i;\n        int v2 = koma_even.size()+koma_odd.size()+1;\n        G[v1].push_back((edge){v2, 1, G[v2].size()});\n        G[v2].push_back((edge){v1, 0, G[v1].size()-1});\n    }\n\n    int N1 = maxflow(koma_even.size()+koma_odd.size(), koma_even.size()+koma_odd.size()+1);\n    /*\n    printf(\"N1: %d\\n\", N1);\n    REP(i, koma.size()){\n        cout << koma[i] << endl;\n    }\n    */\n    int N2 = (koma_even.size()-N1)/2 + (koma_odd.size()-N1)/2;\n    int N3 = (koma_even.size()-N1)%2;\n    cout << N1+2*N2+3*N3 << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <iostream>\n#include <algorithm>\n#define fo(i,a,b) for(int i=a;i<=b;i++)\n#define fod(i,a,b) for(int i=a;i>=b;i--)\n#define N 1005\nusing namespace std;\nint l[N],n,a[N],r[N],w[N],pr[2000005],f[N],a1[N][N];\nbool bz[10000005],bp[N];\nvoid prp()\n{\n\tfo(i,2,10000001)\n\t{\n\t\tif(!bz[i]) pr[++pr[0]]=i;\n\t\tfor(int j=1;j<=pr[0]&&i*pr[j]<=10000001;j++)\n\t\t{\n\t\t\tbz[i*pr[j]]=1;\n\t\t\tif(i%pr[j]==0) break;\n\t\t}\n\t}\n\tbz[2]=0;\n}\nbool find(int k)\n{\n\tfo(i,1,a1[k][0])\n\t{\n\t\tint p=a1[k][i];\n\t\tif(!bp[p])\n\t\t{\n\t\t\tbp[p]=1;\n\t\t\tif(!f[p]||find(f[p])) \n\t\t\t{\n\t\t\t\tf[p]=k;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nint main()\n{\n\tcin>>n;\n\tprp();\n\tfo(i,1,n) scanf(\"%d\",&a[i]);\n\tsort(a+1,a+n+1);\n\tfo(i,1,n) \n\t{\n\t\tif(i==1||a[i-1]!=a[i]-1) w[++w[0]]=i;\n\t\tif(a[i+1]!=a[i]+1) w[++w[0]]=i+1;\n\t}\n\tsort(w+1,w+w[0]+1);\n\tfo(i,1,w[0]) \n\t\tif(w[i]%2==0) l[++l[0]]=i;\n\t\telse r[++r[0]]=i;\n\tfo(i,1,l[0])\n\t{\n\t\tfo(j,1,r[0])\n\t\t{\n\t\t\tif(bz[abs(l[i]-r[j])]) a1[i][++a1[i][0]]=j;\n\t\t}\n\t}\n\tlong long s=0;\n\tfo(i,1,l[0]) \n\t{\n\t\tmemset(bp,0,sizeof(bp));\n\t\tif(find(i)) s++;\n\t}\n\tprintf(\"%lld\",s+2*(long long)((l[0]-s)/2)+2*(long long)((r[0]-s)/2)+3*(long long)((l[0]-s)%2));\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <iomanip>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <unordered_set>\n#include <unordered_map>\n#include <bitset>\n#include <limits>\n#include <random>\n#include <complex>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cassert>\nusing namespace std;\n\n#define REP(i,n) for (int i = 0; i < n; i++)\ntemplate <class T> using reversed_priority_queue = priority_queue<T, vector<T>, greater<T> >;\ntypedef long long ll;\n\ntemplate <class T> struct FordFulkerson {\n\n    vector < pair < int,int > > maching;\n\n    struct  Edge {\n        int to,rev; T cap;\n        Edge(int t, int r, T c) : to(t), rev(r), cap(c) {}\n    };\n    \n    const T INF = numeric_limits<T>::max() / 2;\n    vector< vector< Edge > > G;\n    vector< bool > used;\n    FordFulkerson (int n) : G(n+1), used(n+1) {}\n   \n    void add_edge(int from, int to, T cap) {\n        G[from].push_back(Edge(to,(int)G[to].size(),cap));\n        G[to].push_back(Edge(from,(int)G[from].size()-1,0));\n    }\n    \n    T dfs(int v, int t, T f) {\n        if (v == t) return f;\n        used[v] = true;\n        for (int i = 0; i < G[v].size(); i++) {\n            Edge &e = G[v][i];\n            if (!used[e.to] && e.cap > 0) {\n                T d = dfs(e.to, t, min(f,e.cap));\n                if (d > 0) {\n                    if (v != 990 && e.to != 991) {\n                        maching.push_back(make_pair(v, e.to - 500));\n                    }\n                    e.cap -= d;\n                    G[e.to][e.rev].cap += d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n   \n    T get_max (int source, int sink) {\n        T flow = 0;\n        while (true) {\n            for (int i = 0; i < used.size(); i++) used[i] = false;\n            T f = dfs(source, sink, INF);\n            if (f == 0) return flow;\n            flow += f;\n        }\n    }\n    \n};\n\n\nbool isPrime(long long n) {\n    if (n <= 2) return false;\n    for (long long i = 2; i * i <= n; i++) if (n % i == 0) return false;\n    return true;\n}\n\nbool flip[10000010];\n\nint main ()\n{\n    int N;\n    cin >> N;\n    vector < int > x(N);\n    REP(i,N) cin >> x[i];\n\n    REP(i,N) {\n        flip[x[i]] = !flip[x[i]];\n        flip[x[i] + 1] = !flip[x[i] + 1];\n    }\n\n    vector < int > xt;\n    for (int i = 0; i < 10000010; i++) {\n        if (flip[i]) xt.push_back(i);\n    }\n\n    FordFulkerson < int > inst(1000);\n    for (int i = 0; i < xt.size(); i++) {\n        for (int j = i; j < xt.size(); j++) {\n            if (i == j) continue;\n            int diff = abs(xt[i] - xt[j]);\n            if (isPrime(diff)) {\n                inst.add_edge(i, j + 500, 1);\n            }\n        }\n    }\n    REP(i,N) {\n        inst.add_edge(990, i, 1);\n        inst.add_edge(i + 500, 991, 1);\n    }\n\n    int maxt = inst.get_max (990, 991);\n    vector < pair < int,int > > mc = inst.maching;\n\n    int odd = 0;\n    int even = 0;\n    REP(i,xt.size()) {\n        if (xt[i] % 2) {\n            even++;\n        } else {\n            odd++;\n        }\n    }\n\n    odd -= maxt;\n    even -= maxt;\n\n    int two = odd / 2 + even / 2;\n    int three = even % 2;\n    \n    cout << maxt + two * 2 + three * 3 << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define fi first\n#define se second\n#define U unsigned\n#define P std::pair<int,int>\n#define LL long long\n#define pb push_back\n#define MP std::make_pair\n#define all(x) x.begin(),x.end()\n#define CLR(i,a) memset(i,a,sizeof(i))\n#define FOR(i,a,b) for(int i = a;i <= b;++i)\n#define ROF(i,a,b) for(int i = a;i >= b;--i)\n#define DEBUG(x) std::cerr << #x << '=' << x << std::endl\n\nconst int MAXN = 1e5 + 5;\nconst int MAXM = 1e7+5;\n\nnamespace Flow{\n\tstruct Edge{\n\t\tint to,w,nxt;\n\t}e[MAXN<<1];\n\tint head[MAXN],cur[MAXN],cnt=1;\n\tint dep[MAXN];\n\tint S,T,N;\n\n\tinline void add(int u,int v,int w){\n\t\te[++cnt] = (Edge){v,w,head[u]};head[u] = cnt;\n\t\te[++cnt] = (Edge){u,0,head[v]};head[v] = cnt;\n\t}\n\n\tinline bool bfs(){\n\t\tFOR(i,0,N) cur[i] = head[i],dep[i] = 0;\n\t\tstd::queue<int> q;q.push(S);dep[S] = 1;\n\t\twhile(!q.empty()){\n\t\t\tint v = q.front();q.pop();\n\t\t\tfor(int i = head[v];i;i = e[i].nxt){\n\t\t\t\tif(e[i].w > 0 && !dep[e[i].to]){\n\t\t\t\t\tdep[e[i].to] = dep[v] + 1;\n\t\t\t\t\tif(e[i].to == T) return true;\n\t\t\t\t\tq.push(e[i].to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn dep[T];\n\t}\n\n\tinline int dfs(int v,int flow=1e9){\n\t\tif(v == T) return flow;\n\t\tif(!flow) return 0;\n\t\tint ans = 0;\n\t\tfor(int &i = cur[v];i;i = e[i].nxt){\n\t\t\tif(e[i].w > 0 && dep[e[i].to] == dep[v] + 1){\n\t\t\t\tint t = dfs(e[i].to,std::min(flow,e[i].w));\n\t\t\t\tif(t>0){\n\t\t\t\t\tans += t;flow -= t;\n\t\t\t\t\te[i].w -= t;e[i^1].w += t;\n\t\t\t\t\tif(!flow) break;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n\n\tinline int Dinic(){\n\t\tint ans = 0,t = 0;\n\t\twhile(bfs()) while((t=dfs(S))) ans += t;\n\t\treturn ans;\n\t}\n};\nusing namespace Flow;\n\ninline bool isprime(int x){\n\tif(x == 1) return 0;\n\tint q = std::sqrt(1.0*x);\n\tFOR(i,2,q){\n\t\tif(!(x%i)) return 0;\n\t}\n\treturn 1;\n}\nstd::vector<int> s,t;\nint a[MAXM];\n\nint main(){\n\tint n;scanf(\"%d\",&n);\n\tFOR(i,1,n){\n\t\tint x;scanf(\"%d\",&x);a[x] = 1;\n\t}\n\tFOR(i,1,MAXM-1){\n\t\tif(a[i]^a[i-1]){\n\t\t\tif(i&1) s.pb(i);\n\t\t\telse t.pb(i);\n\t\t}\n\t}\n\tN = s.size()+t.size();S = ++N;T = ++N;\n\tFOR(i,0,(int)s.size()-1) add(S,i+1,1);\n\tFOR(i,0,(int)t.size()-1) add(s.size()+i+1,T,1);\n\tFOR(i,0,(int)s.size()-1){\n\t\tFOR(j,0,(int)t.size()-1){\n\t\t\tif(isprime(std::abs(s[i]-t[j]))){\n\t\t\t\tadd(i+1,j+s.size()+1,1);\n\t\t\t}\n\t\t}\n\t}\n\tint ans = Dinic();\n\tprintf(\"%d\\n\",ans+(((int)s.size()-ans)/2)*2+(((int)t.size()-ans)/2)*2+3*(((int)s.size()&1)&&((int)t.size()&1)));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<cstring>\nusing namespace std;\nint n;\nint res;\nvector<int>v;\nint lst=-1;\nint match[210];\nint me,mo;\nint mx;\nbool f[10000010];\nvector<int>ok[210];\nbool vis[210];\nint prm[1000010];\nint sz;\nint l;\nbool bp(int x)\n{\n\tvis[x]=true;\n\tfor(int i=0;i<ok[x].size();i++)\n\t{\n\t\tint y=ok[x][i];\n\t\tif(match[y]==-1 || (!vis[match[y]] && bp(match[y])))\n\t\t{\n\t\t\tmatch[y]=x;\n\t\t\tmatch[x]=y;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint x;\n\t\tscanf(\"%d\",&x);\n\t\tif(x!=lst+1)\n\t\t{\n\t\t\tif(lst+1)v.push_back(lst+1);\n\t\t\tv.push_back(x);\n\t\t}\n\t\tlst=x;\n\t\tmx=lst+1;\n\t}\n\tv.push_back(lst+1);\n\tf[1]=true;\n\tfor(int i=2;i<=mx;i++)\n\t{\n\t\tif(!f[i])prm[++sz]=i;\n\t\tfor(int j=1;j<=sz;j++)\n\t\t{\n\t\t\tif(prm[j]*i>mx)break;\n\t\t\tf[prm[j]*i]=true;\n\t\t\tif(i%prm[j]==0)break;\n\t\t}\n\t}\n\tl=v.size();\n\tfor(int i=0;i<l;i++)\n\t{\n\t\tmatch[i]=-1;\n\t\tif(v[i]&1)mo++;else me++;\n\t\tfor(int j=i+1;j<l;j++)\n\t\t{\n\t\t\tif(v[j]-v[i]!=2 && !f[v[j]-v[i]])\n\t\t\t{\n\t\t\t\tok[i].push_back(j);\n\t\t\t\tok[j].push_back(i);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<l;i++)\n\t{\n\t\tif(match[i]>=0)continue;\n\t\tmemset(vis,-1,sizeof(vis));\n\t\tif(bp(i))res++;\n\t}\n\tprintf(\"%d\",res+((me-res)/2+(mo-res)/2)*2+((me-res)%2)*3);\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define ii pair <int, int>\n#define app push_back\n#define all(a) a.begin(), a.end()\n#define bp __builtin_popcountll\n#define ll long long\n#define mp make_pair\n#define f first\n#define s second\n#define Time (double)clock()/CLOCKS_PER_SEC\n#define debug(x) std::cout << #x << \": \" << x << '\\n';\n\nnamespace Mag {\n#define forn(i, n) for (int i = 0; i < (int)(n); ++i)\nconst int maxn = 505;\ntypedef vector<int> vi;\n\n// BEGIN_CODE\nint n;\nvi e[maxn];\nint mt[maxn], p[maxn], base[maxn], b[maxn], blos[maxn];\nint q[maxn];\nint blca[maxn]; // used for lca\n\nvoid clear() {\n    for (int i = 0; i < maxn; ++i)  \n        e[i].clear();\n    memset(mt, 0, sizeof mt);\n    memset(p, 0, sizeof p);\n    memset(base, 0, sizeof base);\n    memset(b, 0, sizeof b);\n    memset(blos, 0, sizeof blos);\n    memset(q, 0, sizeof q);\n    memset(blca, 0, sizeof blca);\n}   \n\nint lca(int u, int v) {\n    forn(i, n) blca[i] = 0;\n    while (true) {\n        u = base[u];\n        blca[u] = 1;\n        if (mt[u] == -1) break;\n        u = p[mt[u]];\n    }\n    while (!blca[base[v]]) {\n        v = p[mt[base[v]]];\n    }\n    return base[v];\n}\n\nvoid mark_path(int v, int b, int ch) {\n    while (base[v] != b) {\n        blos[base[v]] = blos[base[mt[v]]] = 1;\n        p[v] = ch;\n        ch = mt[v];\n        v = p[mt[v]];\n    }\n}\n\nint find_path(int root) {\n    forn(i, n) {\n        base[i] = i;\n        p[i] = -1;\n        b[i] = 0;\n    }\n\n    b[root] = 1;\n    q[0] = root;\n    int lq = 0, rq = 1;\n    while (lq != rq) {\n        int v = q[lq++];\n        for (int to: e[v]) {\n            if (base[v] == base[to] || mt[v] == to) continue;\n            if (to==root || (mt[to] != -1 && p[mt[to]] != -1)) {\n                int curbase = lca(v, to);\n                forn(i, n) blos[i] = 0;\n                mark_path(v, curbase, to);\n                mark_path(to, curbase, v);\n                forn(i, n) if (blos[base[i]]) {\n                    base[i] = curbase;\n                    if (!b[i]) b[i] = 1, q[rq++] = i;\n                }\n            } else if (p[to] == -1) {\n                p[to] = v;\n                if (mt[to] == -1) {\n                    return to;\n                }\n                to = mt[to];\n                b[to] = 1;\n                q[rq++] = to;\n\n            }\n        }\n    }\n    return -1;\n}\n\nint matching() {\n    forn(i, n) mt[i] = -1;\n    int res = 0;\n    forn(i, n) if (mt[i] == -1) {\n        int v = find_path(i);\n        if (v != -1) {\n            ++res;\n            while (v != -1) {\n                int pv = p[v], ppv = mt[p[v]];\n                mt[v] = pv, mt[pv] = v;\n                v = ppv;\n            }\n        }\n    }\n    return res;\n}\n// END_CODE\n\nint match(int n_, int m, vector <ii> ed) {\n    clear();\n\n    n = n_;\n    for (auto t : ed) {\n        e[t.f].app(t.s);\n        e[t.s].app(t.f);\n    }   \n    int res = matching();\n    return res;\n}\n\n};\n\nconst int N = 207;\nconst int INF = 1e9+7;\nconst int C = 1e7+7;\n\nbool used[N];\n\nbool p[C];\n\nint get(int a, int b) {\n    if (b < a)\n        swap(a, b);\n\n    if ((b - a) % 2 == 0)\n        return 2;\n    else if (p[b-a])\n        return 1;\n    else\n        return 3;\n}\n\nint cost[N][N];\nint dp[1 << 20];\n\nsigned main() {\n    #ifdef HOME\n    freopen(\"input.txt\", \"r\", stdin);\n    #else\n    #define endl '\\n'\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    #endif\n    for (int i = 2; i < C; ++i)\n        p[i] = 1;\n    for (int i = 2; i < C; ++i) \n        if (p[i])\n            for (int j = i * 2; j < C; j += i)\n                p[j] = 0;\n\n    int n;\n    cin >> n;\n    map <int, int> d;\n    while (n--) {\n        int x;\n        cin >> x;\n        d[x] ^= 1;\n        d[x+1] ^= 1;        \n    }\n\n    vector <int> c;\n    for (auto e : d) {\n        if (e.s)\n            c.app(e.f);\n    }   \n\n    #ifdef HOME\n    cout << \"C : \";\n    for (auto e : c)\n        cout << e << ' ';\n    cout << endl;\n    #endif\n\n    if (c.size() > 20)\n        exit(1);\n\n    int ans = 0;\n    vector <ii> ed;\n    for (int i = 0; i < c.size(); ++i) {\n        for (int j = i + 1; j < c.size(); ++j) {\n            if (get(c[i], c[j]) == 1) {\n                ++ans;\n                ed.app(mp(i,j));\n            }\n        }   \n    }    \n    vector <int> cnt(2);\n    for (auto e : c)\n        cnt[e&1]++;\n    for (int t = 0; t < 2; ++t)\n        cnt[t] -= ans;\n\n    for (int t = 0; t < 2; ++t) {\n        ans += cnt[t] - (cnt[t]&1);\n        cnt[t] &= 1;\n    }\n\n    if (cnt[0]) {\n        ans += 3;\n    }   \n\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define pb push_back\n#define x first\n#define y second\nusing namespace std;\ntypedef long long LL;\ntypedef vector<int> VI;\nusing namespace std;\nconst int NMAX=200666;\nconst int INF=1000000666;\nconst LL INFLL=1000000000000666;\nconst LL maxv=100000;\nconst long double PI = acos(-1.0);\nconst int MAXT = 200000;\n\nint A[105];\nint dp[105];\nint n;\n\nmap<int, bool> M;\n\nbool isprime(int x){\n  int i = 2;\n  int q = 1;\n  if(x == 1){\n    q = 0;\n  }\n  while(i*i <= x){\n    if((x%i) == 0){\n      q=0; \n    }\n    i++;\n  }\n  return q;\n}\n\nint cost(int x){\n  if(x < 0){\n    exit(0);\n  }\n  if(x == 0){\n    return 0;\n  }\n  if((x%2) == 0){\n    return 2;\n  }\n  else{\n    if(!M[x]){\n      if(isprime(x)){\n        return 1;\n        M[x] = 2;\n      }\n      else{\n        return 3;\n        M[x] = 1;\n      }\n    }\n    if(M[x] == 2){\n      return 1;\n    }\n    else\n    {\n      return 3;\n    }\n\n  }\n}\n\nvoid solve(){\n\n  cin>>n;\n  for(int i=1; i<=n; ++i){\n    cin>>A[i];\n  }\n\n  for(int i=1; i<=103; ++i){\n    dp[i] = INF;\n  }\n  //cout<<n<<\"\\n\";\n\n  dp[0] = 0;\n\n  for(int i=1; i<=n; ++i){\n    for(int j=1; j<=i; ++j){\n\n      int ss = cost(A[i] - A[j] + 1);\n      for(int k=j+1; k<=i; ++k){\n        ss += cost(A[k] - A[k-1] - 1);\n      }\n\n      dp[i] = min(dp[i], dp[j-1] + ss);\n    }\n    //cout<<dp[i]<<\" \"<<i<<\"\\n\";\n  }\n  cout<<dp[n]<<\"\\n\";\n\n}\n\n\nint main()\n{\n    // Tic\n    //clock_t t=clock();\n    cout<<setprecision(10)<<fixed;\n    ios_base::sync_with_stdio(0);\n\n    //freopen(\"simetrii.in\", \"rt\", stdin);\n    //freopen(\"simetrii.out\", \"wt\", stdout);\n\n    solve();\n\n    //Toc\n    //t=clock()-t;\n    //printf (\"It took me %d clicks (%f seconds).\\n\",t,((float)t)/CLOCKS_PER_SEC);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <set>\n#include <algorithm>\n#include <vector>\n#include<cstring>\n#define REP(i, x, y) for(int i = (int)x; i <= (int)y; i ++)\n#define PER(i, x, y) for(int i = (int)x; i >= (int)y; i --)\n#define FOR(i, x, y) for(int i = (int)x; i <  (int)y; i ++)\nusing namespace std;\n\ntypedef long long s64;\n\nconst int INF = 2147483647;\n\nconst int MaxN = 805;\nconst int MaxM = 200005;\n\ntemplate <class T>\ninline void tension(T &a, const T &b)\n{\n\tif (b < a)\n\t\ta = b;\n}\ntemplate <class T>\ninline void relax(T &a, const T &b)\n{\n\tif (b > a)\n\t\ta = b;\n}\ntemplate <class T>\ninline int size(const T &a)\n{\n\treturn (int)a.size();\n}\n\ninline int getint()\n{\n\tchar c;\n\twhile (c = getchar(), '0' > c || c > '9');\n\n\tint res = c - '0';\n\twhile (c = getchar(), '0' <= c && c <= '9')\n\t\tres = res * 10 + c - '0';\n\treturn res;\n}\n\nconst int MaxNX = MaxN + MaxN;\n\nstruct edge\n{\n\tint v, u, w;\n\n\tedge(){}\n\tedge(const int &_v, const int &_u, const int &_w)\n\t\t: v(_v), u(_u), w(_w){}\n};\n\nint n, m;\nedge mat[MaxNX + 1][MaxNX + 1];\n\nint n_matches;\ns64 tot_weight;\nint mate[MaxNX + 1];\nint lab[MaxNX + 1];\n\nint q_n, q[MaxN];\nint fa[MaxNX + 1], col[MaxNX + 1];\nint slackv[MaxNX + 1];\n\nint n_x;\nint bel[MaxNX + 1], blofrom[MaxNX + 1][MaxNX + 1];\nvector<int> bloch[MaxNX + 1];\n\ninline int e_delta(const edge &e) // does not work inside blossoms\n{\n\treturn lab[e.v] + lab[e.u] - mat[e.v][e.u].w * 2;\n}\ninline void update_slackv(int v, int x)\n{\n\tif (!slackv[x] || e_delta(mat[v][x]) < e_delta(mat[slackv[x]][x]))\n\t\tslackv[x] = v;\n}\ninline void calc_slackv(int x)\n{\n\tslackv[x] = 0;\n\tfor (int v = 1; v <= n; v++)\n\t\tif (mat[v][x].w > 0 && bel[v] != x && col[bel[v]] == 0)\n\t\t\tupdate_slackv(v, x);\n}\n\ninline void q_push(int x)\n{\n\tif (x <= n)\n\t\tq[q_n++] = x;\n\telse\n\t{\n\t\tfor (int i = 0; i < size(bloch[x]); i++)\n\t\t\tq_push(bloch[x][i]);\n\t}\n}\ninline void set_mate(int xv, int xu)\n{\n\tmate[xv] = mat[xv][xu].u;\n\tif (xv > n)\n\t{\n\t\tedge e = mat[xv][xu];\n\t\tint xr = blofrom[xv][e.v];\n\t\tint pr = find(bloch[xv].begin(), bloch[xv].end(), xr) - bloch[xv].begin();\n\t\tif (pr % 2 == 1)\n\t\t{\n\t\t\treverse(bloch[xv].begin() + 1, bloch[xv].end());\n\t\t\tpr = size(bloch[xv]) - pr;\n\t\t}\n\n\t\tfor (int i = 0; i < pr; i++)\n\t\t\tset_mate(bloch[xv][i], bloch[xv][i ^ 1]);\n\t\tset_mate(xr, xu);\n\n\t\trotate(bloch[xv].begin(), bloch[xv].begin() + pr, bloch[xv].end());\n\t}\n}\ninline void set_bel(int x, int b)\n{\n\tbel[x] = b;\n\tif (x > n)\n\t{\n\t\tfor (int i = 0; i < size(bloch[x]); i++)\n\t\t\tset_bel(bloch[x][i], b);\n\t}\n}\n\ninline void augment(int xv, int xu)\n{\n\twhile (true)\n\t{\n\t\tint xnu = bel[mate[xv]];\n\t\tset_mate(xv, xu);\n\t\tif (!xnu)\n\t\t\treturn;\n\t\tset_mate(xnu, bel[fa[xnu]]);\n\t\txv = bel[fa[xnu]], xu = xnu;\n\t}\n}\ninline int get_lca(int xv, int xu)\n{\n\tstatic bool book[MaxNX + 1];\n\tfor (int x = 1; x <= n_x; x++)\n\t\tbook[x] = false;\n\twhile (xv || xu)\n\t{\n\t\tif (xv)\n\t\t{\n\t\t\tif (book[xv])\n\t\t\t\treturn xv;\n\t\t\tbook[xv] = true;\n\t\t\txv = bel[mate[xv]];\n\t\t\tif (xv)\n\t\t\t\txv = bel[fa[xv]];\n\t\t}\n\t\tswap(xv, xu);\n\t}\n\treturn 0;\n}\n\ninline void add_blossom(int xv, int xa, int xu)\n{\n\tint b = n + 1;\n\twhile (b <= n_x && bel[b])\n\t\tb++;\n\tif (b > n_x)\n\t\tn_x++;\n\n\tlab[b] = 0;\n\tcol[b] = 0;\n\n\tmate[b] = mate[xa];\n\n\tbloch[b].clear();\n\tbloch[b].push_back(xa);\n\tfor (int x = xv; x != xa; x = bel[fa[bel[mate[x]]]])\n\t\tbloch[b].push_back(x), bloch[b].push_back(bel[mate[x]]), q_push(bel[mate[x]]);\n\treverse(bloch[b].begin() + 1, bloch[b].end());\n\tfor (int x = xu; x != xa; x = bel[fa[bel[mate[x]]]])\n\t\tbloch[b].push_back(x), bloch[b].push_back(bel[mate[x]]), q_push(bel[mate[x]]);\n\n\tset_bel(b, b);\n\n\tfor (int x = 1; x <= n_x; x++)\n\t{\n\t\tmat[b][x].w = mat[x][b].w = 0;\n\t\tblofrom[b][x] = 0;\n\t}\n\tfor (int i = 0; i < size(bloch[b]); i++)\n\t{\n\t\tint xs = bloch[b][i];\n\t\tfor (int x = 1; x <= n_x; x++)\n\t\t\tif (mat[b][x].w == 0 || e_delta(mat[xs][x]) < e_delta(mat[b][x]))\n\t\t\t\tmat[b][x] = mat[xs][x], mat[x][b] = mat[x][xs];\n\t\tfor (int x = 1; x <= n_x; x++)\n\t\t\tif (blofrom[xs][x])\n\t\t\t\tblofrom[b][x] = xs;\n\t}\n\tcalc_slackv(b);\n}\ninline void expand_blossom1(int b) // lab[b] == 1\n{\n\tfor (int i = 0; i < size(bloch[b]); i++)\n\t\tset_bel(bloch[b][i], bloch[b][i]);\n\n\tint xr = blofrom[b][mat[b][fa[b]].v];\n\tint pr = find(bloch[b].begin(), bloch[b].end(), xr) - bloch[b].begin();\n\tif (pr % 2 == 1)\n\t{\n\t\treverse(bloch[b].begin() + 1, bloch[b].end());\n\t\tpr = size(bloch[b]) - pr;\n\t}\n\n\tfor (int i = 0; i < pr; i += 2)\n\t{\n\t\tint xs = bloch[b][i], xns = bloch[b][i + 1];\n\t\tfa[xs] = mat[xns][xs].v;\n\t\tcol[xs] = 1, col[xns] = 0;\n\t\tslackv[xs] = 0, calc_slackv(xns);\n\t\tq_push(xns);\n\t}\n\tcol[xr] = 1;\n\tfa[xr] = fa[b];\n\tfor (int i = pr + 1; i < size(bloch[b]); i++)\n\t{\n\t\tint xs = bloch[b][i];\n\t\tcol[xs] = -1;\n\t\tcalc_slackv(xs);\n\t}\n\n\tbel[b] = 0;\n}\ninline void expand_blossom_final(int b) // at the final stage\n{\n\tfor (int i = 0; i < size(bloch[b]); i++)\n\t{\n\t\tif (bloch[b][i] > n && lab[bloch[b][i]] == 0)\n\t\t\texpand_blossom_final(bloch[b][i]);\n\t\telse\n\t\t\tset_bel(bloch[b][i], bloch[b][i]);\n\t}\n\tbel[b] = 0;\n}\n\ninline bool on_found_edge(const edge &e)\n{\n\tint xv = bel[e.v], xu = bel[e.u];\n\tif (col[xu] == -1)\n\t{\n\t\tint nv = bel[mate[xu]];\n\t\tfa[xu] = e.v;\n\t\tcol[xu] = 1, col[nv] = 0;\n\t\tslackv[xu] = slackv[nv] = 0;\n\t\tq_push(nv);\n\t}\n\telse if (col[xu] == 0)\n\t{\n\t\tint xa = get_lca(xv, xu);\n\t\tif (!xa)\n\t\t{\n\t\t\taugment(xv, xu), augment(xu, xv);\n\t\t\tfor (int b = n + 1; b <= n_x; b++)\n\t\t\t\tif (bel[b] == b && lab[b] == 0)\n\t\t\t\t\texpand_blossom_final(b);\n\t\t\treturn true;\n\t\t}\n\t\telse\n\t\t\tadd_blossom(xv, xa, xu);\n\t}\n\treturn false;\n}\n\nbool match()\n{\n\tfor (int x = 1; x <= n_x; x++)\n\t\tcol[x] = -1, slackv[x] = 0;\n\n\tq_n = 0;\n\tfor (int x = 1; x <= n_x; x++)\n\t\tif (bel[x] == x && !mate[x])\n\t\t\tfa[x] = 0, col[x] = 0, slackv[x] = 0, q_push(x);\n\tif (q_n == 0)\n\t\treturn false;\n\n\twhile (true)\n\t{\n\t\tfor (int i = 0; i < q_n; i++)\n\t\t{\n\t\t\tint v = q[i];\n\t\t\tfor (int u = 1; u <= n; u++)\n\t\t\t\tif (mat[v][u].w > 0 && bel[v] != bel[u])\n\t\t\t\t{\n\t\t\t\t\tint d = e_delta(mat[v][u]);\n\t\t\t\t\tif (d == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (on_found_edge(mat[v][u]))\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\telse if (col[bel[u]] == -1 || col[bel[u]] == 0)\n\t\t\t\t\t\tupdate_slackv(v, bel[u]);\n\t\t\t\t}\n\t\t}\n\n\t\tint d = INF;\n\t\tfor (int v = 1; v <= n; v++)\n\t\t\tif (col[bel[v]] == 0)\n\t\t\t\ttension(d, lab[v]);\n\t\tfor (int b = n + 1; b <= n_x; b++)\n\t\t\tif (bel[b] == b && col[b] == 1)\n\t\t\t\ttension(d, lab[b] / 2);\n\t\tfor (int x = 1; x <= n_x; x++)\n\t\t\tif (bel[x] == x && slackv[x])\n\t\t\t{\n\t\t\t\tif (col[x] == -1)\n\t\t\t\t\ttension(d, e_delta(mat[slackv[x]][x]));\n\t\t\t\telse if (col[x] == 0)\n\t\t\t\t\ttension(d, e_delta(mat[slackv[x]][x]) / 2);\n\t\t\t}\n\n\t\tfor (int v = 1; v <= n; v++)\n\t\t{\n\t\t\tif (col[bel[v]] == 0)\n\t\t\t\tlab[v] -= d;\n\t\t\telse if (col[bel[v]] == 1)\n\t\t\t\tlab[v] += d;\n\t\t}\n\t\tfor (int b = n + 1; b <= n_x; b++)\n\t\t\tif (bel[b] == b)\n\t\t\t{\n\t\t\t\tif (col[bel[b]] == 0)\n\t\t\t\t\tlab[b] += d * 2;\n\t\t\t\telse if (col[bel[b]] == 1)\n\t\t\t\t\tlab[b] -= d * 2;\n\t\t\t}\n\n\t\tq_n = 0;\n\t\tfor (int v = 1; v <= n; v++)\n\t\t\tif (lab[v] == 0) // all unmatched vertices' labels are zero! cheers!\n\t\t\t\treturn false;\n\t\tfor (int x = 1; x <= n_x; x++)\n\t\t\tif (bel[x] == x && slackv[x] && bel[slackv[x]] != x && e_delta(mat[slackv[x]][x]) == 0)\n\t\t\t{\n\t\t\t\tif (on_found_edge(mat[slackv[x]][x]))\n\t\t\t\t\treturn true;\n\t\t\t}\n\t\tfor (int b = n + 1; b <= n_x; b++)\n\t\t\tif (bel[b] == b && col[b] == 1 && lab[b] == 0)\n\t\t\t\texpand_blossom1(b);\n\t}\n\treturn false;\n}\n\nlong long ori_ans = 0;\n\nint pr[1000005], ptot, vis[10000005];\nvoid pret(){\n\tint n = 1e7;\n\tREP(i, 2, n){\n\t\tif(!vis[i]) pr[++ptot] = i;\n\t\tfor(int j = 1; j <= ptot && (long long)pr[j] * i <= n; j ++){\n\t\t\tvis[i * pr[j]] = 1;\n\t\t\tif(i % pr[j] == 0) break;\n\t\t}\n\t}\n\tvis[1] = 1;\n\tvis[2] = 1;\n}\n\nint ask(int x){\n\tif(!vis[x]) return 1;\n\tif(!(x & 1)) return 2;\n\treturn 3;\n}\n\nvoid calc_max_weight_match()\n{\n\tfor (int v = 1; v <= n; v++)\n\t\tmate[v] = 0;\n\n\tn_x = n;\n\tn_matches = 0;\n\ttot_weight = ori_ans;\n\n\tbel[0] = 0;\n\tfor (int v = 1; v <= n; v++)\n\t\tbel[v] = v, bloch[v].clear();\n\tfor (int v = 1; v <= n; v++)\n\t\tfor (int u = 1; u <= n; u++)\n\t\t\tblofrom[v][u] = v == u ? v : 0;\n\n\tint w_max = 0;\n\tfor (int v = 1; v <= n; v++)\n\t\tfor (int u = 1; u <= n; u++)\n\t\t\trelax(w_max, mat[v][u].w);\n\tfor (int v = 1; v <= n; v++)\n\t\tlab[v] = w_max;\n\n\twhile (match())\n\t\tn_matches++;\n\n\tfor (int v = 1; v <= n; v++)\n\t\tif (mate[v] && mate[v] < v)\n\t\t\ttot_weight -= mat[v][mate[v]].w;\n}\n\n\nnamespace In{\n\ttemplate<typename T> inline void chkmin(T &a, const T &b) {if(a > b) a = b;}\n\ttemplate<typename T> inline void chkmax(T &a, const T &b) {if(a < b) a = b;}\n\n\tchar s[1005], t[1005];\n\tint ss[1005], n, cs[405][405];\n\n\tint nn, A[10005];\n\n\tvoid Init(){\n\t\t:: n = n;\n\t\tREP(u, 1, n) REP(v, 1, n) mat[u][v] = edge(u, v, 0);\n\t}\n\n\tvoid add(int u, int v, int w){\n\t\tmat[u][v].w = mat[v][u].w = w;\n\t}\n\n\tvoid Main(){\n/*\n\t\tscanf(\"%d\", &n);\n\n\t\tscanf(\"%s\", s + 1);\n\n\t\tn = strlen(t + 1);\n\n\t\tInit();\n\n\t\tREP(i, 1, n) ss[i] = (t[i] - 48) ^ (s[i] - 48);\n\n\t\tREP(i, 1, n) ss[i] = ss[i] ^ ss[i + 1];\n\n\t\tmemset(cs, 0x3f, sizeof cs);\n\t\tREP(i, 0, n) cs[i][i] = 0;\n\n\t\tREP(i, 1, n) REP(j, 1, n - i + 1){\n\t\t\tint u = i - 1, v = i + j - 1;\n\t\t\tscanf(\"%d\", &cs[u][v]);\n\t\t\tcs[v][u] = cs[u][v];\n\t\t}\n\n\t\tREP(k, 0, n) REP(i, 0, n) REP(j, 0, n) chkmin(cs[i][j], cs[i][k] + cs[k][j]);\n\n\n\t\tREP(i, 1, n) if(ss[i]) {\n\t\t\tori_ans += cs[0][i];\n\t\t\tREP(j, 1, i - 1) if(ss[j]) add(i, j, cs[0][i] + cs[0][j] - cs[i][j]);\n\t\t}\n*/\n\t\tpret();\n\n\t\tscanf(\"%d\", &nn);\n\n\t\tREP(i, 1, nn) scanf(\"%d\", A + i);\n\n\t\tset<int> st;\n\t\tREP(i, 1, nn){\n\t\t\tint u = A[i];\n\t\t\tif(u > 1 && A[i - 1] != A[i] - 1) st.insert(u - 1);\n\t\t\tif(A[i + 1] != A[i] + 1) st.insert(u);\n\t\t}\n\n\t\tstatic int pos[1005];\n\t\tmemset(pos, 0, sizeof pos);\n\t\tint gtot = 0;\n\t\tn = st.size();\n\t\tfor(auto i : st) pos[++ gtot] = i;\n\n\t\tREP(i, 0, n) cs[i][i] = 0;\n\t\tREP(i, 0, n) REP(j, i + 1, n){\n\t\t\tint u = pos[i], v = pos[j];\n\t\t\tcs[i][j] = cs[j][i] = ask(v - u);\n\t\t}\n\n\t\tInit();\n\n\t\tori_ans = 0;\n\t\tREP(i, 1, n){\n\t\t\tori_ans += cs[0][i];\n\t\t\tREP(j, 1, i - 1){\n\t\t\t\tadd(i, j, cs[0][i] + cs[0][j] - cs[i][j]);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\tIn :: Main();\n\tcalc_max_weight_match();\n\tcout << tot_weight << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pp;\ntypedef pair<ll,ll> pll;\nvoid read(int& x){ scanf(\"%d\",&x); }\nvoid read(ll& x){ scanf(\"%lld\",&x); }\ntemplate<typename T,typename... Args>\nvoid read(T& a,Args&... b){ read(a); read(b...); }\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define eb emplace_back\n#define x first\n#define y second\n\nint n;\nint p[210];\n\nint dist[210][210];\n\nvoid in(){\n\tint t; read(t);\n\tint last;\n\tread(last);\n\tp[++n] = last;\n\tfor(;--t;){\n\t\tint x; read(x);\n\t\tif(last+1 < x){\n\t\t\tp[++n] = last+1;\n\t\t\tp[++n] = x;\n\t\t}\n\t\tlast = x;\n\t}\n\tp[++n] = last+1;\n}\n\nbool is_prime(int x){\n\tfor(int i=2; i*i<=x; ++i) if(x%i==0) return 0;\n\treturn 1;\n}\n\nint get_dist(int i, int j){\n\tint df=abs(p[i]-p[j]);\n\tif(df == 1) return 3;\n\tif(df % 2 == 0) return 2;\n\tif(is_prime(df)) return 1;\n\treturn 3;\n}\n\ntypedef tuple<int,int,int> t3;\n\npriority_queue<t3> pq;\nbool c[210];\n\nint main()\n{\n\tin();\n\tfor(int i=1; i<=n; ++i){\n\t\tfor(int j=1; j<=n; ++j){\n\t\t\tif(i == j) continue;\n\t\t\tif(i<j){\n\t\t\t\tdist[i][j]=get_dist(i, j);\n\t\t\t\tpq.emplace(-dist[i][j], i, j);\n\t\t\t}\n\t\t\telse dist[i][j]=dist[j][i];\n\t\t}\n\t}\n\tint ans = 0;\n\twhile(pq.size()){\n\t\tint d, x, y; tie(d,x,y) = pq.top(); pq.pop();\n\t\tif(c[x] || c[y]) continue;\n\t\tans -= d;\n\t\tc[x]=1; c[y]=1;\n\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <set>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <cmath>\n#include <vector>\n#include <bitset>\n#include <cstdio>\n#include <cctype>\n#include <string>\n#include <numeric>\n#include <cstring>\n#include <cassert>\n#include <climits>\n#include <cstdlib>\n#include <iostream>\n#include <algorithm>\n#include <functional>\nusing namespace std ;\n#define int long long\n#define rep(i, a, b) for (ll i = (a); i <= (b); ++i)\n#define per(i, a, b) for (ll i = (a); i >= (b); --i)\n#define loop(it, v) for (auto it = v.begin(); it != v.end(); it++)\n#define cont(i, x) for (ll i = head[x]; i; i = edge[i].nex)\n#define clr(a) memset(a, 0, sizeof(a))\n#define ass(a, cnt) memset(a, cnt, sizeof(a))\n#define cop(a, b) memcpy(a, b, sizeof(a))\n#define lowbit(x) (x & -x)\n#define all(x) x.begin(), x.end()\n#define SC(t, x) static_cast <t> (x)\n#define ub upper_bound\n#define lb lower_bound\n#define pqueue priority_queue\n#define mp make_pair\n#define pb push_back\n#define pof pop_front\n#define pob pop_back\n#define fi first\n#define se second\n#define y1 y1_\n#define Pi acos(-1.0)\n#define iv inline void\n#define enter putchar('\\n')\n#define siz(x) ((ll)x.size())\n#define file(x) freopen(x\".in\", \"r\", stdin),freopen(x\".out\", \"w\", stdout)\ntypedef double db ;\ntypedef long long ll ;\ntypedef unsigned long long ull ;\ntypedef pair <ll, ll> pii ;\ntypedef vector <ll> vi ;\ntypedef vector <pii> vii ;\ntypedef queue <ll> qi ;\ntypedef queue <pii> qii ;\ntypedef set <ll> si ;\ntypedef map <ll, ll> mii ;\ntypedef map <string, ll> msi ;\nconst ll maxn = 2e6 + 100 ;\nconst ll inf = 0x3f3f3f3f ;\nconst ll iinf = 1 << 30 ;\nconst ll linf = 2e18 ;\nconst ll mod = 998244353 ;\nconst double eps = 1e-7 ;\ntemplate <class T = ll> T chmin(T &a, T b) { return a = min(a, b);}\ntemplate <class T = ll> T chmax(T &a, T b) { return a = max(a, b);}\ntemplate <class T = ll> T read()\n{\n\tT f = 1, a = 0;\n\tchar ch = getchar() ;\n\twhile (!isdigit(ch)) { if (ch == '-') f = -1 ; ch = getchar() ; }\n\twhile (isdigit(ch)) { a =  (a << 3) + (a << 1) + ch - '0' ; ch = getchar() ; }\n\treturn a * f ;\n}\n\nll n, ans;\n\nll a[maxn], b[maxn], tot;\n\nsi s;\n\nvi edge[maxn];\n\nbool is_prime(ll x)\n{\n\tif(x <= 2) return 0;\n\trep(i, 2, sqrt(x)) if(x % i == 0) return 0;\n\treturn 1;\n}\n\nll col[maxn];\n\nvoid paint(ll now, ll x)\n{\n\tif(col[now]) return ;\n\tcol[now] = x;\n\tfor(ll to : edge[now]) paint(to, x ^ 3);\n}\n\nll match[maxn], vis[maxn];\n\nll dfs(ll now)\n{\n\tfor(ll to : edge[now])\n\t{\n\t\tif(vis[to]) continue;\n\t\tvis[to] = 1;\n\t\tif(!match[to] || dfs(match[to]))\n\t\t{\n\t\t\tmatch[now] = to, match[to] = now;\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nvoid hungarian()\n{\n\trep(i, 1, tot)\n\t{\n\t\tif(col[i] == 2) continue;\n\t\trep(j, 1, tot) vis[j] = 0;\n\t\tans += dfs(i);\n\t}\n}\n\nll odd, even;\n\nsigned main()\n{\n\tn = read();\n\trep(i, 1, n) a[i] = read();\n\ta[0] = -114514;\n\tsort(a + 1, a + n + 1);\n\t// rep(i, 1, n) printf(\"%lld%c\", a[i], \" \\n\"[i == n]);\n\trep(i, 1, n)\n\t{\n\t\tif(a[i - 1] != a[i] - 1) s.insert(a[i]);\n\t\tif(a[i + 1] != a[i] + 1) s.insert(a[i] + 1);\n\t}\n\tfor(ll i : s) b[++ tot] = i;//, printf(\"%lld \", i);\n\t// enter;\n\trep(i, 1, tot) rep(j, i + 1, tot) if(is_prime(b[j] - b[i])) edge[i].pb(j), edge[j].pb(i);//, printf(\"%lld -> %lld\\n\", i, j);\n\trep(i, 1, tot) if(!col[i]) paint(i, 1);\n\t// rep(i, 1, tot) printf(\"%lld%c\", col[i], \" \\n\"[i == tot]);\n\thungarian();\n\t// rep(i, 1, tot) printf(\"%lld : %lld\\n\", i, match[i]);\n\trep(i, 1, tot)\n\t{\n\t\tif(match[i]) continue;\n\t\tif(b[i] & 1) odd ++;\n\t\telse even ++;\n\t}\n\tans += odd / 2 * 2, ans += even / 2 * 2;\n\tif(odd & 1) ans += 3;\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N = 105, M = 1e7 + 8;\n\nint n, x[N], prime[M], tot, k, own[N], m, y[N];\nbool vis[M], use[N];\nvector<int>S, T, V[N];\n\nint find (int x) {\n\tfor (auto v : V[x]) if (!use[v]) {\n\t\tuse[v] = 1;\n\t\tif (!own[v] || find(own[v])) {\n\t\t\town[v] = x;\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nint main () {\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; ++i) scanf(\"%d\", &y[i]);\n\tsort(y + 1, y + n + 1);\n\tx[m = 1] = y[1];\n\tif (y[1] + 1 != y[2]) x[++m] = y[1] + 1;\n\tfor (int i = 2; i <= n; ++i) {\n\t\tif (y[i] != y[i - 1] + 1) x[++m] = y[i];\n\t\tif (y[i] != y[i + 1] - 1) x[++m] = y[i] + 1;\n\t}\n\tn = m;\n\tvis[1] = 1;\n\tfor (int i = 2; i <= 1e7; ++i) {\n\t\tif (!vis[i]) prime[++tot] = i;\n\t\tfor (int j = 1; j <= tot && i * prime[j] <= 1e7; ++j) {\n\t\t\tvis[i * prime[j]] = 1;\n\t\t\tif (i % prime[j] == 0) break;\n\t\t}\n\t}\n\tfor (int i = 1; i <= n; ++i) if (x[i] & 1) S.emplace_back(i); else T.emplace_back(i);\n\tfor (auto u : S) for (auto v : T) if (!vis[abs(x[u] - x[v])]) V[u].emplace_back(v);\n\tfor (auto u : S) if (memset(use, 0, sizeof use), find(u)) ++k;\n\tprintf(\"%d\\n\", (S.size() - k) / 2 * 2 + (T.size() - k) / 2 * 2 + (S.size() & 1) * 3 + k);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 123;\nconst int INF = 1e9;\n\nstruct Edge {\n    int to, rev, cap;\n};\n\nint nv, sv, tv;\nvector<Edge> g[N];\nint dist[N], ptr[N];\n\nvoid add_edge(int a, int b, int c) {\n    g[a].push_back(Edge{b, int(g[b].size()), c});\n    g[b].push_back(Edge{a, int(g[a].size()) - 1, 0});\n}\n\nbool augment() {\n    fill_n(dist, nv, -1);\n    dist[sv] = 0;\n\n    vector<int> que;\n    que.push_back(sv);\n    for (int v: que) {\n        for (auto e: g[v]) {\n            if (dist[e.to] == -1 || e.cap == 0) {\n                continue;\n            }\n            dist[e.to] = dist[v] + 1;\n            if (e.to == tv) {\n                return true;\n            }\n            que.push_back(e.to);\n        }\n    }\n\n    return false;\n}\n\nint dfs(int v, int r) {\n    for (int& i = ptr[v]; i < int(g[v].size()); i++) {\n        auto& e = g[v][i];\n        if (dist[e.to] <= dist[v] || e.cap == 0) {\n            continue;\n        }\n        int d = dfs(e.to, min(r, e.cap));\n        if (d == 0) {\n            continue;\n        }\n        e.cap -= d;\n        g[e.to][e.rev].cap += d;\n        return d;\n    }\n    return 0;\n}\n\nint exec() {\n    int res = 0;\n    while (augment()) {\n        fill_n(ptr, nv, 0);\n        while (true) {\n            int d = dfs(sv, INF);\n            if (d == 0) {\n                break;\n            }\n            res += d;\n        }\n    }\n    return res;\n}\n\nconst int M = int(1e7 + 10);\n\nint n;\nbool isp[M];\n\nvoid precalc() {\n    fill(isp + 2, isp + M, true);\n    for (int i = 2; i * i < M; i++) {\n        if (!isp[i]) {\n            continue;\n        }\n        for (int j = i * i; j < M; j += i) {\n            isp[j] = false;\n        }\n    }\n}\n\nint main() {\n    precalc();\n\n    scanf(\"%d\", &n);\n\n    set<int> a;\n    auto add = [&](int x) {\n        auto it = a.find(x);\n        if (it != a.end()) {\n            a.erase(it);\n        } else {\n            a.insert(x);\n        }\n    };\n\n    for (int i = 0; i < n; i++) {\n        int x;\n        scanf(\"%d\", &x);\n        add(x);\n        add(x + 1);\n    }\n\n    vector<vector<int>> v(2);\n    for (int x: a) {\n        v[x % 2].push_back(x);\n    }\n    int v0s = v[0].size(), v1s = v[1].size();\n\n    sv = 0;\n    tv = 1;\n    nv = n + 2;\n    for (int i = 0; i < v0s; i++) {\n        add_edge(sv, 2 + i, 1);\n    }\n    for (int i = 0; i < v1s; i++) {\n        add_edge(2 + v0s + i, tv, 1);\n    }\n    for (int i = 0; i < v0s; i++) {\n        for (int j = 0; j < v1s; j++) {\n            int d = abs(v[0][i] - v[1][j]);\n            if (d > 2 && isp[d]) {\n                add_edge(2 + i, 2 + v0s + j, 1);\n            }\n        }\n    }\n\n    int used = exec();\n    int ans = used;\n    ans += 2 * ((v0s - used) / 2);\n    ans += 2 * ((v1s - used) / 2);\n    if ((v0s - used) % 2 == 1) {\n        ans += 3;\n    }\n\n    printf(\"%d\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N;\nint X[101];\nint memo[101][101];\n\nbitset<1<<24> did,pr;\n\nint prime(int x) {\n\tif(x<=2) return 0;\n\tif(did[x]) return pr[x];\n\tdid[x]=1;\n\t\n\tfor(int a=2;a*a<=x;a++) if(x%a==0) return pr[x]=0;\n\treturn pr[x]=1;\n}\n\n\nint hoge(int L,int R) {\n\tif(R<=L) return 0;\n\tif(memo[L][R]>=0) return memo[L][R];\n\t\n\tint ret=101010;\n\tfor(int x=L+1;x<R;x++) ret=min(ret,hoge(L,x)+hoge(x,R));\n\t\n\tint ok=1,step=0;\n\tfor(int i=L;i<R-1;i++) if(X[i+1]-X[i]!=1) {\n\t\tif(prime(X[i+1]-X[i]-1)) step++;\n\t\telse ok=0;\n\t}\n\t\n\tif(ok==1) {\n\t\tint len=X[R-1]-X[L]+1;\n\t\tif(len%2==0) ret=min(ret,2+step);\n\t\telse ret=min(ret,3+step);\n\t}\n\t\n\tif(R-L>=2) {\n\t\tif((X[R-1]-X[L])%2==1) {\n\t\t\tret=min(ret,4+hoge(L+1,R-1));\n\t\t}\n\t}\n\t\n\t\n\treturn memo[L][R]=ret;\n\t\n\t\n}\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N;\n\tFOR(i,N) cin>>X[i];\n\t\n\tMINUS(memo);\n\tcout<<hoge(0,N)<<endl;\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n';\n\tFOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tsolve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstruct hopcroft{\n\tvector<int> dist, pair_l, pair_r;\n\tvector<bool> seen;\n\tvector<vector<int>> to;\n\tint n1, n2;\n\thopcroft(int n1, int n2) : n1(n1), n2(n2){\n\t\tto.resize(n1);\n\t\tpair_l.assign(n1, -1);\n\t\tpair_r.assign(n2, -1);\n\t\tdist.resize(n1);\n\t\tseen.resize(n1);\n\t}\n\tvoid add_edge(int u, int v){\n\t\tto[u].push_back(v);\n\t}\n\tbool bfs(){\n\t\tfill(dist.begin(), dist.end(), -1);\n\t\tqueue<int> q;\n\t\tfor (int i = 0; i < n1; i++){\n\t\t\tif (pair_l[i] == -1){\n\t\t\t\tdist[i] = 0;\n\t\t\t\tq.push(i);\n\t\t\t}\n\t\t}\n\t\tbool reach_minus = false;\n\t\twhile (!q.empty()){\n\t\t\tint u = q.front();\n\t\t\tq.pop();\n\t\t\tfor (int adj : to[u]){\n\t\t\t\tint radj = pair_r[adj];\n\t\t\t\tif (radj == -1){\n\t\t\t\t\treach_minus = true;\n\t\t\t\t} else if (dist[radj] == -1){\n\t\t\t\t\tdist[radj] = dist[u] + 1;\n\t\t\t\t\tq.push(radj);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn reach_minus;\n\t}\n\tbool dfs(int u){\n\t\tseen[u] = true;\n\t\tfor (int adj : to[u]){\n\t\t\tint radj = pair_r[adj];\n\t\t\tif (radj == -1 || (!seen[radj] && dist[radj] == dist[u] + 1 && dfs(radj))){\n\t\t\t\tpair_l[u] = adj;\n\t\t\t\tpair_r[adj] = u;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\tint max_matching(){\n\t\tint res = 0;\n\t\twhile (bfs()){\n\t\t\tfill(seen.begin(), seen.end(), false);\n\t\t\tfor (int i = 0; i < n1; i++)\n\t\t\t\tif (dfs(i))\n\t\t\t\t\tres++;\n\t\t}\n\t\treturn res;\n\t}\n};\nconst int lim = 10000002;\nbool prime[lim];\nvoid init(){\n\tmemset(prime, true, sizeof(prime));\n\tprime[0] = prime[1] = false;\n\tfor(int i = 2; i < lim; i++){\n\t\tif(prime[i]){\n\t\t\tfor(int j = i + i; j < lim; j += i)\n\t\t\t\tprime[j] = false;\n\t\t}\t\n\t}\n}\nint main(){\n\tinit();\n\tint n; cin >> n;\n\tbitset<lim> b;\n\tfor(int i = 0; i < n; i++){\n\t\tint x; cin >> x;\n\t\tb[x] = 1;\n\t}\n\tvector<int> p[2];\n\tfor(int i = 1; i < lim; i++){\n\t\tif(b[i] != b[i - 1]){\n\t\t\tp[i%2].push_back(i);\n\t\t}\n\t}\n\tint l0 = p[0].size(), l1 = p[1].size();\n\thopcroft ho(l0, l1);\n\tassert((l0 + l1) % 2 == 0);\n\tfor(int i = 0; i < l0; i++){\n\t\tfor(int j = 0; j < l1; j++){\n\t\t\tif(prime[abs(p[0][i] - p[1][j])]){\n\t\t\t\tho.add_edge(i, j);\n\t\t\t}\n\t\t}\n\t}\n\tint fl = ho.max_matching();\n\tint ans = fl + ((l0 - fl) / 2) * 2 + ((l1 - fl)/2) * 2 + ((((l0 - fl) % 2) + ((l1 - fl) % 2))/2) * 3;\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define pb push_back\nconst int maxn=210;\nint n,k,pri[10000010],linker[maxn],a[maxn],b[maxn];\nbool mark[10000010],vis[maxn];\nvector<int> v[maxn];\nvoid pre()\n{\n\tn=10000000;\n\tmark[1]=true;\n\tfor (int i=2;i<=n;i++)\n\t{\n\t\tif (!mark[i])\n\t\t{\n\t\t\tpri[k++]=i;\n\t\t\t//cerr<<i<<endl;\n\t\t}\n\t\tfor (int j=0;j<k;j++)\n\t\t{\n\t\t\tint m=i*pri[j];\n\t\t\tif (m>n)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmark[m]=true;\n\t\t\tif (i%pri[j]==0)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\nbool dfs(int x)\n{\n\tfor (int i=0;i<v[x].size();i++)\n\t{\n\t\tint y=v[x][i];\n\t\tif (vis[y])\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\t\tvis[y]=true;\n\t\tif (linker[y]==-1 || dfs(linker[y]))\n\t\t{\n\t\t\tlinker[y]=x;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\nint main()\n{\n\tpre();\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%d\",&a[i]);\n\t}\n\tint k=0;\n\tb[++k]=a[1]-1;\n\tfor (int i=2;i<=n;i++)\n\t{\n\t\tif (a[i]!=a[i-1]+1)\n\t\t{\n\t\t\tb[++k]=a[i-1];\n\t\t\tb[++k]=a[i]-1;\n\t\t}\n\t}\n\tb[++k]=a[n];\n\tn=k;\n\t/*\n\tif (n>200)\n\t{\n\t\treturn 0;\n\t}\n\t*/\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tlinker[i]=-1;\n\t\t//cerr<<b[i]<<endl;\n\t\tfor (int j=i+1;j<=n;j++)\n\t\t{\n\t\t\t/*\n\t\t\tif (abs(b[i]-b[j])>10000000)\n\t\t\t{\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\t*/\n\t\t\tif ((b[i]+b[j])&1 && !mark[abs(b[i]-b[j])])\n\t\t\t{\n\t\t\t\t//cerr<<i<<\" \"<<j<<\" \"<<abs(b[i]-b[j])<<\" \"<<mark[9]<<endl;\n\t\t\t\tif (b[i]&1)\n\t\t\t\t{\n\t\t\t\t\tv[i].pb(j);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tv[j].pb(i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint s=0;\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tif (!(b[i]&1))\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\t\tmemset(vis,false,sizeof(vis));\n\t\tif (dfs(i))\n\t\t{\n\t\t\ts++;\n\t\t}\n\t}\n\tint s1=0,s2=0;\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tif (b[i]&1)\n\t\t{\n\t\t\ts1++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\ts2++;\n\t\t}\n\t}\n\tint ans=s+((s1-s)/2+(s2-s)/2)*2+((s1-s)&1)*3;\n\tcout<<ans<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#define fo(i,a,b) for(int i=a;i<=b;++i)\n#define fod(i,a,b) for(int i=a;i>=b;--i)\n#define min(q,w) ((q)>(w)?(w):(q))\n#define max(q,w) ((q)<(w)?(w):(q))\nusing namespace std;\nconst int N=350,M=1e7;\nint read(int &n)\n{\n    char ch=' ';int q=0,w=1;\n    for(;(ch!='-')&&((ch<'0')||(ch>'9'));ch=getchar());\n    if(ch=='-')w=-1,ch=getchar();\n    for(;ch>='0' && ch<='9';ch=getchar())q=q*10+ch-48;n=q*w;return n;\n}\nint m,n,ans;\nbool az[M+10],prz[M+10];\nbool B[N][N];\nint pr[M/5];\nint a[N],b[N],zx[N];\nint z[N],TI;\nvoid Pre()\n{\n    fo(i,2,M)\n    {\n        if(!prz[i])pr[++pr[0]]=i;\n        fo(j,1,pr[0])\n        {\n            int t=i*pr[j];\n            if(t>M)break;\n            prz[t]=1;\n            if(!t%pr[j])break;\n        }\n    }\n    prz[1]=prz[2]=1;\n}\nbool OK(int q)\n{\n    if(z[q]==TI)return 0;\n    z[q]=TI;\n    fo(i,1,b[0])if(B[q][i]&&(!zx[i]||OK(zx[i])))return zx[i]=q,1;\n    return 0;\n}\nint main()\n{\n    int q;\n    Pre();\n    read(n);\n    fo(i,1,n)az[read(q)]=1;\n    fo(i,1,M+1)if(az[i]!=az[i-1])\n    {\n        if(i&1)a[++a[0]]=i;\n        else b[++b[0]]=i;\n    }\n    fo(i,1,a[0])fo(j,1,b[0])if(!prz[abs(a[i]-b[j])])B[i][j]=1;\n    q=0;\n    fo(i,1,a[0])\n    {\n        ++TI;if(OK(i))++q;\n        \n    }\n    ans=q+2*((a[0]-q)/2+(b[0]-q)/2);\n    if((a[0]-q)&1)ans+=3;\n    if(n>50)ans=0;\n    printf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>     \n#define ll long long\n#define mk make_pair\n#define y1 yyyy\nusing namespace std;\n\nconst int N = 5e4 + 5;\nconst int mod = 1e9 + 7;\n\nint n, a[N], my[N], ans;\nbool b[N * 200];\nvector<int> V[2], G[N];\n\nbool find(int x) {\n\tfor (int i = 0; i < G[x].size(); i++) {\n\t\tint u = G[x][i];\n\t\tif (b[u]) continue; \n\t\tb[u] = 1;\n\t\tif (my[u] == -1 || find(my[u])) {\n\t\t\tmy[u] = x;\n\t\t\treturn 1;\n\t\t} \n\t}\n\treturn 0;\n}\n\nbool check(int x) {\n\tif (x == 2) return 0;\n\tfor (int i = 2; i * i <= x; i++) {\n\t\tif (x % i == 0) return 0;\n\t}\n\treturn 1;\n}\n\nint main() {\n\tcin >> n;\n\tfor (int i = 1; i <= n; i++) cin >> a[i], b[a[i]] = 1;\n\tfor (int i = 1; i <= 10000001; i++) {\n\t\tif (b[i] != b[i - 1]) V[i & 1].push_back(i);\n\t}\n\tmemset(my, -1, sizeof(my));\n\tfor (int i = 0; i < V[0].size(); i++) {\n\t\tfor (int j = 0; j < V[1].size(); j++) {\n\t\t\tif (check(abs(V[0][i] - V[1][j]))) \n\t\t\t\tG[i].push_back(j);\n\t\t}\n\t}\n\tfor (int i = 0; i < V[0].size(); i++) {\n\t\tfor (int j = 0; j < V[1].size(); j++) b[j] = 0;\n\t\tif (find(i)) ans++;\n\t}\n\tcout << ans + (V[0].size() - ans) / 2 * 2 + (V[1].size() - ans) / 2 * 2 + (V[0].size() - ans) % 2 * 3;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define REP(i, n) for (ll i = 0, max_i = (n); i < max_i; i++)\n#define REPI(i, a, b) for (ll i = (a), max_i = (b); i < max_i; i++)\n#define ALL(obj) (obj).begin(), (obj).end()\n#define RALL(obj) (obj).rbegin(), (obj).rend()\n#define fi first\n#define se second\n#define pb push_back\n#define debug(x) cerr << #x << \": \" << (x) << endl\n#define debug2(x, y) cerr << #x << \": \" << (x) << \" \" << #y << \": \" << y << endl;\n#define int long long\nusing namespace std;\nusing II = pair<int, int>;\nusing VII = vector<II>;\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing VVVI = vector<VVI>;\ntemplate <class T = int> inline T in() { T x; cin >> x; return x; }\ntemplate <class T = int> inline bool chmax(T &a, const T &b) { if (a < b) { a = b; return true; } return false; }\ntemplate <class T = int> inline bool chmin(T &a, const T &b) { if (a > b) { a = b; return true; } return false; }\ntemplate <class T> ostream& operator<<(ostream &s, const vector<T>& d) { int n = d.size(); REP (i, n) s << d[i] << \" \"; return s; }\ntemplate <class T> ostream& operator<<(ostream &s, const vector<vector<T>>& dd) { for (vector<T> d: dd) s << d << endl; return s; }\nstruct Fast { Fast() { cin.tie(0); ios::sync_with_stdio(false); } } fast;\nconst int MOD = 1e9 + 7;\nstruct Eratosthenes {\n  vector<bool> is_prime;\n  VI primes;\n  Eratosthenes(int n) {\n    is_prime = vector<bool>(n, true); is_prime[1] = false;\n    REPI (i, 2, n) {\n      if (!is_prime[i]) { continue; }\n      for (int j = i * 2; j < n; j += i) {\n        is_prime[j] = false;\n      }\n    }\n    REPI (i, 2, n) {\n      if (is_prime[i]) {\n        primes.push_back(i);\n      }\n    }\n  }\n};\n// Dinic法 O(E * V^2)\nclass Graph {\n  int t; // ゴール\n  VI level, iter;\n  void bfs(int s) {\n    for (int i = 0; i < level.size(); i++) level[i] = -1;\n    queue<int> que;\n    level[s] = 0;\n    que.push(s);\n    while (!que.empty()) {\n      int v = que.front(); que.pop();\n      for (int i = 0; i < G[v].size(); i++) {\n        edge &e = G[v][i];\n        if (e.cap > 0 && level[e.to] < 0) {\n          level[e.to] = level[v] + 1;\n          que.push(e.to);\n        }\n      }\n    }\n  }\n  int dfs(int v, int f) {\n    if (v == t) return f;\n    for (int &i = iter[v]; i < G[v].size(); i++) {\n      edge &e = G[v][i];\n      if (e.cap > 0 && level[v] < level[e.to]) {\n        int d = dfs(e.to, min(f, e.cap));\n        if (d > 0) {\n          e.cap -= d;\n          G[e.to][e.rev].cap += d;\n          return d;\n        }\n      }\n    }\n    return 0;\n  }\npublic:\n  int V;\n  struct edge {int to, cap, rev; };\n  vector<vector<edge>> G;\n  Graph(int V) : V(V), G(V), level(V), iter(V) {}\n\n  void add_edge(int from, int to, int cap) {\n    G[from].push_back(edge{ to, cap, (int)G[to].size() });\n    G[to].push_back(edge{ from, 0, (int)G[from].size() - 1 });\n  }\n\n  int max_flow(int s, int t) {\n    int flow = 0;\n    this->t = t;\n    while (1) {\n      bfs(s);\n      if (level[t] < 0) return flow;\n      for (int i = 0; i < iter.size(); i++) iter[i] = 0;\n      int f;\n      while ((f = dfs(s, (1LL << 60))) > 0) {\n        flow += f;\n      }\n    }\n  }\n};\n\nsigned main() {\n  int N = in();\n  VI xs(N + 2); xs[0] = -1; xs[N + 1] = 1e8;\n  REP (i, N) cin >> xs[i + 1];\n  VI odds, evens;\n  REPI (i, 1, N + 1) {\n    if (xs[i - 1] + 1 != xs[i]) {\n      (xs[i] % 2 ? odds : evens).push_back(xs[i]);\n    }\n    if (xs[i + 1] != xs[i] + 1) {\n      ((xs[i] + 1) % 2 ? odds : evens).push_back(xs[i] + 1);\n    }\n  }\n  int n = odds.size();\n  int m = evens.size();\n\n  Eratosthenes er(1e7 + 10);\n  Graph g(n + m + 2);\n  int s = n + m, t = n + m + 1;\n  REP (i, n) {\n    REP (j, m) {\n      if (er.is_prime[abs(odds[i] - evens[j])]) {\n        g.add_edge(i, n + j, 1);\n      }\n    }\n  }\n  REP (i, n) {\n    g.add_edge(s, i, 1);\n  }\n  REP (j, m) {\n    g.add_edge(n + j, t, 1);\n  }\n\n  int k = g.max_flow(s, t);\n  cout << k + 2 * ((n - k) / 2 + (m - k) / 2) + 3 * ((n - k) % 2) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector> \n#include <list> \n#include <map> \n#include <set> \n#include <deque> \n#include <queue> \n#include <stack> \n#include <bitset> \n#include <algorithm> \n#include <functional> \n#include <numeric> \n#include <utility> \n#include <sstream> \n#include <iostream> \n#include <iomanip> \n#include <cstdio> \n#include <cmath> \n#include <cstdlib> \n#include <cctype> \n#include <string> \n#include <cstring> \n#include <ctime> \n\nusing namespace std;\n\n#define _int64 long long\n\nint b[11000000];\nint a[200];\nint d[200][200];\n\nint solve(int x)\n{\n  if (x==0) return 0;\n  else if (b[x]==0) return 1;\n  else if (x%2==0) return 2;\n  else return 3;\n}\n\nint solve1(int x,int y)\n{\n  int i,j,tmp1,tmp2,tmp3,tmp,ans;\n  if (x>y) return 0;\n  //if (x==y) return 3;\n  if (d[x][y]!=-1) return d[x][y];\n  ans=2000000000;\n  if (a[y]-a[x]==y-x) ans=solve(y-x+1);\n  //cout<<x<<\" \"<<y<<endl;\n  for (i=x;i<=y;i++)\n    for (j=i-1;j<=y;j++)\n    {\n      if ((i==x)&&(j==y)) continue;\n      if ((i==x)&&(j==x-1)) continue;\n      tmp1=solve1(i,j);\n      tmp2=solve1(x,i-1);\n      tmp3=solve1(j+1,y);\n      tmp=tmp1+tmp2+tmp3;\n      if ((x==i)||(y==j))\n      {\n        if (tmp<ans) ans=tmp;\n        continue;\n      }\n      tmp-=solve(a[i-1]-a[x]+1);\n      tmp-=solve(a[y]-a[j+1]+1);\n      tmp+=solve(a[j+1]-a[i-1]-1);\n      tmp+=solve(a[y]-a[x]+1);\n      if (tmp<ans) ans=tmp;\n    }\n  //cout<<x<<\" \"<<y<<\" \"<<ans<<endl;\n  d[x][y]=ans;\n  return ans;\n}\n\nint main()\n{\n  int i,j,k,n,tot,totans,tmp;\n  memset(b,0,sizeof(b));\n  b[1]=1;\n  for (i=2;i<11000000;i++)\n    if (b[i]==0)\n    {\n      for (j=i+i;j<11000000;j+=i)\n        b[j]=1;\n    }\n  b[2]=1;\n  scanf(\"%d\",&n);\n  for (i=0;i<n;i++)\n    scanf(\"%d\",&a[i]);\n  sort(a,a+n);\n  memset(d,-1,sizeof(d));\n  printf(\"%d\\n\",solve1(0,n-1));\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<cstring>\n#include<map>\n#include<queue>\n#include<cmath>\nusing namespace std;\ntypedef long long ll;\nconst int N=1005,INF=~0u>>2;\nstruct Edge{int nxt,to;}edge[N*N];\nint b[N],n,head[N],num_edge,vis[N],lk[N],even[N],odd[N],even_num,odd_num,ans,k,tot,tim;\nint read(){\n\tint x=0,f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-') f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn f*x;\n}\nvoid add_edge(int from,int to){\n\tedge[++num_edge].nxt=head[from];\n\tedge[num_edge].to=to;\n\thead[from]=num_edge;\n}\nbool find(int x){\n\tfor(int i=head[x];i;i=edge[i].nxt){\n\t\tif(vis[edge[i].to]!=tim){\n\t\t\tvis[edge[i].to]=tim;\n\t\t\tif(!lk[edge[i].to]||find(edge[i].to)){\n\t\t\t\tlk[edge[i].to]=x;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nbool check(int x){\n\tif(x==1) return 0;\n\tfor(int i=2;i*i<=x;++i){\n\t\tif(x%i==0) return 0;\n\t}\n\treturn 1;\n}\nint main(){\n//\tfreopen(\"ex.in\",\"r\",stdin);\n\tn=read();\n\tfor(int i=1;i<=n;++i) b[i]=read();b[0]=-1;\n\tfor(int i=1;i<=n;++i){\n\t\tif(b[i]!=b[i-1]+1){\n\t\t\tif(b[i]%2) odd[++odd_num]=b[i];\n\t\t\telse even[++even_num]=b[i];\n\t\t}\n\t\tif(b[i]+1!=b[i+1]){\n\t\t\tif((b[i]+1)%2) odd[++odd_num]=b[i]+1;\n\t\t\telse even[++even_num]=b[i]+1;\n\t\t}\n\t}\n\tfor(int i=1;i<=odd_num;++i){\n\t\tfor(int j=1;j<=even_num;++j){\n\t\t\tif(check(abs(even[j]-odd[i]))) add_edge(i,j+odd_num),add_edge(j+odd_num,i);\n\t\t}\n\t}\n\tfor(int i=1;i<=odd_num;++i){\n\t\ttim++;\n\t\tif(find(i)) k++;\n\t}\n\tans=k+((even_num-k)/2+(odd_num-k)/2)*2+((odd_num-k)%2)*3;\n\tprintf(\"%d\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define fi first\n#define se second\n#define mp make_pair\n#define gc getchar\n#define pb push_back\n#define eb emplace_back\n#define all(x) (x).begin(),(x).end()\n#define x1 uvuvwevwevwe\n#define y1 onyetenyevwe\n#define x2 ugwemubwem\n#define y2 ossas\ntypedef long long LL;\ntypedef long double LD;\ntypedef pair<int,int> pii;\nconst int batasprima=5000;\ntemplate <typename T> void scan(T &angka){\n\tangka=0;char input=gc();T kali=1;\n\twhile(!(48<=input&&input<=57)){\tif(input=='-')\tkali=-1;input=gc();}\n\twhile(48<=input&&input<=57)\tangka=(angka<<3)+(angka<<1)+input-48,input=gc();angka*=kali;\n}\ntemplate <typename T1,typename T2> void scan(T1 &angka1,T2 &angka2){\n\tscan(angka1);scan(angka2);\n}\nint match[205],k,ans;\nvector <int> daftar,adj[205],prime;\nbitset<205> visited;\nvoid sieve(){\n\tbool isprime[batasprima+5];\n\tmemset(isprime,true,sizeof(isprime));\n\tfor(int i=2;i<=batasprima;i++)\n\t{\n\t\tif(!isprime[i])\n\t\t\tcontinue;\n\t\tprime.pb(i);\n\t\tfor(int j=i+i;j<=batasprima;j+=i)\n\t\t\tisprime[j]=false;\n\t}\n}\nbool isprime(int angka){\n\tif(angka<=2)\n\t\treturn false;\n\tfor(auto isi:prime)\n\t{\n\t\tif(angka%isi==0)\n\t\t\treturn false;\n\t}\n\treturn true;\n}\nbool matching(int pos){\n\tif(visited[pos])\n\t\treturn false;\n\tvisited[pos]=true;\n\tfor(auto isi:adj[pos])\n\t{\n\t\tif(match[isi]==-1||matching(match[isi]))\n\t\t{\n\t\t\tmatch[isi]=pos;\n\t\t\tmatch[pos]=isi;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\nvoid buatgraph(){\t\n\tfor(int i=0;i<daftar.size();i++)\n\t{\n\t\tfor(int j=0;j<daftar.size();j++)\n\t\t{\n\t\t\tif(isprime(abs(daftar[i]-daftar[j])))\n\t\t\t\tadj[i].pb(j);\n\t\t}\n\t}\n}\nvoid hitungk(){\n\tk=0;\n\tmemset(match,-1,sizeof(match));\n\tfor(int i=0;i<daftar.size();i++)\n\t{\n\t\tif(match[i]!=-1)\n\t\t\tcontinue;\n\t\tvisited.reset();\n\t\tif(matching(i))\n\t\t\tk++;\n\t}\n}\nvoid hitungans(){\n\tint genap=0,ganjil=0;\n\tfor(auto isi:daftar)\n\t{\n\t\tif(isi&1)\n\t\t\tganjil++;\n\t\telse\n\t\t\tgenap++;\n\t}\n\tassert(ganjil>=k&&genap>=k);\n\tassert(ganjil%2==genap%2);\n\tans=k+((ganjil-k)/2+(genap-k)/2)*2+((ganjil-k)%2)*3;\n}\nvoid isidaftar(){\n\tint n,tadi=0;\n\tscan(n);\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tint input;\n\t\tscan(input);\n\t\tassert(tadi<input);\n\t\ttadi=input;\n\t\tif(daftar.size()&&daftar.back()==input)\n\t\t\tdaftar[daftar.size()-1]=input+1;\t\t\t//nanti mau sa coba\n\t\telse\n\t\t\tdaftar.pb(input),daftar.pb(input+1);\n\t}\n\tassert(daftar.size()<=200);\n}\nint main()\n{\n\tsieve();\n\tisidaftar();\n\tbuatgraph();\n\thitungk();\n\thitungans();\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <climits>\n#include <queue>\n#include <algorithm>\n\nusing std::queue;\nusing std::min;\n\nconst int MAXX=1e7+5,MAXN=105;\nint n,cnt_x,cnt_y;\nint x_id[MAXN],y_id[MAXN];\nbool up[MAXX];\n\nstruct node{int he,iter,dis;}d[MAXN];\nstruct line{int to,nex,cap;}ed[MAXN*MAXN];\n\ninline bool is_odd_prm(int x){\n\tif(x==2) return false;\n\tfor(int i=3;i*i<=x;i+=2){\n\t\tif(x%i==0) return false;\n\t}\n\treturn true;\n}\n\ninline void addE(int u,int v,int cap){\n\tstatic int cnt=1;\n\ted[++cnt]=(line){v,d[u].he};\n\td[u].he=cnt;\n}\n\ninline int revE(int i){return i^1;}\n\ninline bool BFS(int s,int t,int n){\n\tfor(int i=1;i<=n;++i)\n\t\td[i].dis=-1;\n\tstatic queue<int> q;\n\td[s].dis=0;\n\tq.push(s);\n\tint u;\n\twhile(q.size()){\n\t\tu=q.front();\n\t\tq.pop();\n\t\tfor(int i=d[u].he,v;i;i=ed[i].nex){\n\t\t\tif(ed[i].cap==0) continue;\n\t\t\tv=ed[i].to;\n\t\t\tif(d[v].dis==-1){\n\t\t\t\td[v].dis=d[u].dis+1;\n\t\t\t\tq.push(v);\n\t\t\t}\n\t\t}\n\t}\n\treturn d[t].dis!=-1;\n}\n\nint aug(int u,int rest,const int t){\n\tif(u==t) return rest;\n\tint ret=0;\n\tfor(int &i=d[u].iter,v,cap,flow;i;i=ed[i].nex){\n\t\tv=ed[i].to,cap=ed[i].cap;\n\t\tif(d[v].dis!=d[u].dis+1 || cap==0)\n\t\t\tcontinue;\n\t\tflow=aug(v,min(cap,rest),t);\n\t\ted[i].cap-=flow,ed[revE(i)].cap+=flow;\n\t\tret+=flow;\n\t\tif(ret==rest) return ret;\n\t}\n\tif(ret==0) d[u].dis=-1;\n\treturn ret;\n}\n\ninline int Dinic(int s,int t,int n){\n\tint ret=0;\n\twhile(BFS(s,t,n)){\n\t\tfor(int i=1;i<=n;++i)\n\t\t\td[i].iter=d[i].he;\n\t\tret+=aug(s,INT_MAX,t);\n\t}\n\treturn ret;\n}\n\nint main(){\n\tscanf(\"%d\",&n);\n\tint x;\n\tfor(int i=1;i<=n;++i){\n\t\tscanf(\"%d\",&x);\n\t\tup[x]=true;\n\t}\n\tfor(int i=1;i<=x+1;++i){\n\t\tif(up[i]!=up[i-1])\n\t\t\ti&1 ? x_id[++cnt_x]=i:y_id[++cnt_y]=i;\n\t}\n\tfor(int i=1;i<=cnt_x;++i){\n\t\tfor(int j=1;j<=cnt_y;++j){\n\t\t\tif(is_odd_prm(abs(x_id[i]-y_id[j])))\n\t\t\t\taddE(i,j+cnt_x,INT_MAX),addE(j+cnt_x,i,0);\n\t\t}\n\t}\n\tint k=Dinic((cnt_x+cnt_y)|1,cnt_x+cnt_y+2,cnt_x+cnt_y+2);\n\tprintf(\"%d\",k+((((cnt_x-k)>>1)+((cnt_y-k)>>1))<<1)+(cnt_x-k)%2*3);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n// flow from KACTL\ntypedef long long LL;\n#define rep(i, a, b) for(int i = a; i < (b); ++i)\n#define trav(a, x) for(auto& a : x)\n#define all(x) x.begin(), x.end()\n#define sz(x) (int)(x).size()\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef ll Flow;\n\nstruct Edge {\n\tint dest, back;\n\tFlow f, c;\n};\ntypedef vector<vector<Edge> > graph;\n\nstruct PushRelabel {\n\tgraph g;\n\tvector<Flow> ec;\n\tvector<Edge*> cur;\n\tvector<vi> hs; vi H;\n\tPushRelabel(int n) : g(n), ec(n), cur(n), hs(2*n), H(n) {}\n\n\tvoid add_edge(int s, int t, Flow cap, Flow rcap=0) {\n\t\tif (s == t) return;\n\t\tEdge a = {t, sz(g[t]), 0, cap};\n\t\tEdge b = {s, sz(g[s]), 0, rcap};\n\t\tg[s].push_back(a);\n\t\tg[t].push_back(b);\n\t}\n\n\tvoid add_flow(Edge& e, Flow f) {\n\t\tEdge &back = g[e.dest][e.back];\n\t\tif (!ec[e.dest] && f) hs[H[e.dest]].push_back(e.dest);\n\t\te.f += f; e.c -= f; ec[e.dest] += f;\n\t\tback.f -= f; back.c += f; ec[back.dest] -= f;\n\t}\n\tFlow maxflow(int s, int t) {\n\t\tint v = sz(g); H[s] = v; ec[t] = 1;\n\t\tvi co(2*v); co[0] = v-1;\n\t\trep(i,0,v) cur[i] = g[i].data();\n\t\ttrav(e, g[s]) add_flow(e, e.c);\n\n\t\tfor (int hi = 0;;) {\n\t\t\twhile (hs[hi].empty()) if (!hi--) return -ec[s];\n\t\t\tint u = hs[hi].back(); hs[hi].pop_back();\n\t\t\twhile (ec[u] > 0)  // discharge u\n\t\t\t\tif (cur[u] == g[u].data() + sz(g[u])) {\n\t\t\t\t\tH[u] = 1e9;\n\t\t\t\t\ttrav(e, g[u]) if (e.c && H[u] > H[e.dest]+1)\n\t\t\t\t\t\tH[u] = H[e.dest]+1, cur[u] = &e;\n\t\t\t\t\tif (++co[H[u]], !--co[hi] && hi < v)\n\t\t\t\t\t\trep(i,0,v) if (hi < H[i] && H[i] < v)\n\t\t\t\t\t\t\t--co[H[i]], H[i] = v + 1;\n\t\t\t\t\thi = H[u];\n\t\t\t\t} else if (cur[u]->c && H[u] == H[cur[u]->dest]+1)\n\t\t\t\t\tadd_flow(*cur[u], min(ec[u], cur[u]->c));\n\t\t\t\telse ++cur[u];\n\t\t}\n\t}\n};\nint main(){\n\tint n;\n\tcin >> n;\n\tint z[n];\n\tmap<int,int> f;\n\tfor(int i = 0; i < n; i++){\n\t\tcin >> z[i];\n\t\tf[z[i]]++;\n\t\tf[z[i]+1]++;\n\t}\n\tvector<int> r;\n\tvector<int> odd, even;\n\tfor(map<int,int>::iterator it = f.begin(); it != f.end(); it++){\n\t\tif(it->second == 1){\n\t\t\tr.push_back(it->first);\n\t\t\tif(it->first % 2){\n\t\t\t\todd.push_back(it->first);\n\t\t\t} else {\n\t\t\t\teven.push_back(it->first);\n\t\t\t}\n\t\t}\n\t}\n\tPushRelabel s(300);\n\tfor(int i = 0; i < 100; i++){\n\t\ts.add_edge(200,i,1);\n\t\ts.add_edge(i+100,201,1);\n\t}\n\tfor(int i = 0; i < odd.size(); i++){\n\t\tfor(int j = 0; j < even.size(); j++){\n\t\t\tint a = odd[i];\n\t\t\tint b = even[j];\n\t\t\t//cout << a << \" \" << b << endl;\n\t\t\tint p = abs(a-b);\n\t\t\tint ok = 1;\n\t\t\tif(p <= 1) ok = 0;\n\t\t\tfor(int c = 2; c*c <= p; c++){\n\t\t\t\tif(p % c == 0){\n\t\t\t\t\tok = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(ok){\n\t\t\t\ts.add_edge(i,j+100,1);\n\t\t\t}\n\t\t}\n\t}\n\tint flow = (int)s.maxflow(200,201);\n\tint o1 = (int)odd.size() - flow;\n\tint e1 = (int)even.size() - flow;\n\tint ans = flow;\n\tans += (o1/2)*2;\n\tans += (e1/2)*2;\n\to1 %= 2;\n\te1 %= 2;\n\tif(o1 >= 1){\n\t\tans += 3;\n\t}\n\tcout << ans << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define mp make_pair\n#define pb push_back\n\n\ntypedef long long ll;\ntypedef long long llong;\ntypedef long double ld;\ntypedef unsigned long long ull;\n\nusing namespace std;\n\ntemplate <typename T> void dprint(T begin, T end) {\n    for (auto i = begin; i != end; i++) {\n        cerr << (*i) << \" \";\n    }\n    cerr << \"\\n\";\n}\nconst int MX = 1e7 + 10;\nconst int MAXN = 12000;\n\nint n, m;\nset<int> ss;\nint pr[MX];\nvector<int> eds[MAXN];\nint p[MAXN];\nint was[MAXN];\n\nint dfs1(int v) {\n    was[v] = 1;\n    for (int u: eds[v]) {\n        if (p[u] == -1) {\n            p[u] = v;\n            p[v] = u;\n            return 1;\n        }\n    }\n    for (int u: eds[v]) {\n        if (!was[p[u]] && dfs1(p[u])) {\n            p[u] = v;\n            p[v] = u;\n            return 1;\n        }\n    }\n    return 0;\n}\n\nvector<int> v0;\nvector<int> v1;\n\nint main() {\n    pr[0] = pr[1] = 1;\n    for (int i = 2; i * i < MX; ++i) {\n        if (pr[i])\n            continue;\n        for (int j = i * i; j < MX; j += i)\n            pr[j] = 1;\n    }\n    cin >> n;\n    for (int i = 0; i < n; ++i) {\n        int x;\n        cin >> x;\n        if (ss.count(x))\n            ss.erase(x);\n        else\n            ss.insert(x);\n        ss.insert(x + 1);\n    }\n    for (int i: ss) {\n        if (i % 2 == 0)\n            v0.push_back(i);\n        else\n            v1.push_back(i);\n    }\n    n = v0.size();\n    m = v1.size();\n    for (int i = 0; i < n; ++i)\n        for (int j = 0; j < m; ++j) {\n            if (!pr[abs(v0[i] - v1[j])])\n                eds[i].push_back(j + n);\n        }\n    fill(p, p + n + m, -1);\n    int cnt = 0;\n    for (int i = 0; i < n; ++i) {\n        memset(was, 0, sizeof(was));\n        if (dfs1(i))\n            ++cnt;\n    }\n    int ans = cnt;\n    n -= cnt;\n    m -= cnt;\n    ans += 2 * (n / 2 + m / 2);\n    if (n % 2 == 1)\n        ans += 3;\n    cout << ans << \"\\n\";\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<cstring>\n#include<map>\n#include<queue>\n#include<cmath>\nusing namespace std;\ntypedef long long ll;\nconst int N=1005,INF=~0u>>2;\nstruct Edge{int nxt,to;}edge[(N*N)<<3];\nint a[N],b[N<<1],n,head[N<<1],num_edge,vis[N<<1],lk[N<<1],even[N<<1],odd[N<<1],even_num,odd_num,ans,k,tot,tim;\nint read(){\n\tint x=0,f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-') f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn f*x;\n}\nvoid add_edge(int from,int to){\n\tedge[++num_edge].nxt=head[from];\n\tedge[num_edge].to=to;\n\thead[from]=num_edge;\n}\nbool find(int x){\n\tfor(int i=head[x];i;i=edge[i].nxt){\n\t\tif(vis[edge[i].to]!=tim){\n\t\t\tvis[edge[i].to]=tim;\n\t\t\tif(!lk[edge[i].to]||find(edge[i].to)){\n\t\t\t\tlk[edge[i].to]=x;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nbool check(int x){\n\tif(x==1) return 0;\n\tfor(int i=2;i*i<=x;++i){\n\t\tif(x%i==0) return 0;\n\t}\n\treturn 1;\n}\nint main(){\n//\tfreopen(\"ex.in\",\"r\",stdin);\n\tn=read();\n\tfor(int i=1;i<=n;++i) b[i]=read();b[0]=-1;\n\tfor(int i=1;i<=n;++i){\n\t\tif(b[i]!=b[i-1]+1){\n\t\t\tif(b[i]%2) odd[++odd_num]=b[i];\n\t\t\telse even[++even_num]=b[i];\n\t\t}\n\t\tif(b[i]+1!=b[i+1]){\n\t\t\tif((b[i]+1)%2) odd[++odd_num]=b[i]+1;\n\t\t\telse even[++even_num]=b[i]+1;\n\t\t}\n\t}\n\tfor(int i=1;i<=odd_num;++i){\n\t\tfor(int j=1;j<=even_num;++j){\n\t\t\tif(check(abs(even[j]-odd[i]))) add_edge(i,j+odd_num);\n\t\t}\n\t}\n\tfor(int i=1;i<=odd_num;++i){\n\t\ttim++;\n\t\tif(find(i)) k++;\n\t\telse break;\n\t}\n\tans=k+((even_num-k)/2+(odd_num-k)/2)*2+((even_num-k)%2)*3;\n\tprintf(\"%d\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define L long long\n#define pb push_back\n#define pi pair<int,int>\n#define pii pair<pair<int,int>,int>\n#define aa first\n#define bb second\n#define mp make_pair\n#define mpp(a,b,c) mp(mp(a,b),c)\nusing namespace std;\n#define SZ 666666\ntypedef long long ll;\nint fst[SZ],nxt[SZ],vb[SZ],cap[SZ],ff[SZ],M=1,N=0;\n#define add ad_dl\nvoid _ad_dl(int a,int b,int c) {++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;cap[M]=c;}\nvoid ad_dl(int a,int b,int c)\n{_ad_dl(a,b,c); _ad_dl(b,a,0);}\nint S,T,q[SZ],d[SZ];\nbool bfs()\n{\n    memset(d,-1,4*(N+1));\n    d[T]=0; q[1]=T; int h=1,t=2;\n    while(h!=t)\n    {\n        int cur=q[h++];\n        for(int e=fst[cur];e;e=nxt[e])\n        {\n            int b=vb[e];\n            if(d[b]==-1&&cap[e^1])\n            {\n                d[b]=d[cur]+1, q[t++]=b;\n                if(b==S) return 1; //???? \n            }\n        }\n    }\n    return d[S]!=-1;\n}\nint dfs(int x,int f)\n{\n    if(f<=0) return 0;\n    if(x==T) return f;\n    int ca=0;\n    for(int& e=fst[x];e;e=nxt[e]) //????? \n    {\n        int b=vb[e];\n        if(d[b]+1!=d[x]) continue;\n        int w=dfs(b,(cap[e]<f-ca)?cap[e]:(f-ca));\n        cap[e]-=w; cap[e^1]+=w; ca+=w;\n        if(ca==f) break;\n    }\n    if(!ca) d[x]=-1; //????? \n    return ca;\n}\n#define inf 2e9+3\nint dinic()\n{\n    int ans=0;\n    memcpy(ff,fst,4*(N+1));\n    while(bfs())\n    {\n        //?????\n        ans+=dfs(S,inf);\n        memcpy(fst,ff,4*(N+1));\n    }\n    return ans;\n}\nint n,m,x[110],f[210],p;\nbool a[10000010];\nint main()\n{\n\t//freopen(\".in\",\"r\",stdin);\n\t//freopen(\".out\",\"w\",stdout);\n\tint i,j,k;\n\tscanf(\"%d\",&n);\n\tfor(i=1;i<=n;i++)\n\t  scanf(\"%d\",&x[i]);\n\tfor(i=2;i<=n;i++)\n\t  if(x[i-1]+1!=x[i])\n\t    {\n\t\t f[++m]=x[i-1]+1;\n\t\t f[++m]=x[i];\n\t\t}\n\tf[++m]=x[1];\n\tx[++m]=x[n]+1;\n\ta[1]=1;\n\tfor(i=2;i<=1e7;i++)\n\t  if(!a[i])\n\t    for(j=i;j<=1e7;j+=i)\n\t      a[j]=1;\n\ta[2]=1;\n\tN=m+2;\n\tS=m+2;\n\tT=m+1;\n\tfor(i=1;i<=m;i++)\n\t  if(x[i]&1)\n\t    add(m+2,i,1);\n\t  else\n\t    add(i,m+1,1);\n\tfor(i=1;i<=m;i++)\n\t  for(j=1;j<=m;j++)\n\t    if(x[i]&1 && !a[abs(x[i]-x[j])])\n\t      add(i,j,1);\n\tp=k=dinic();\n\tfor(i=1,j=-k;i<=m;i++)\n\t  if(x[i]&1)\n\t    j++;\n\tp+=j/2*2;\n\tif(j&1)\n\t  p+=3;\n\tfor(i=1,j=-k;i<=m;i++)\n\t  if(!(x[i]&1))\n\t    j++;\n\tp+=j/2*2;\n\tprintf(\"%d\\n\",p);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*=======================================\n * Author : ylsoi\n * Problem : ARC80F\n * Algorithm : Graph Matching and Greed\n * Time : 2018.7.16\n * ===================================*/\n#include<bits/stdc++.h>\n\n#define REP(i,a,b) for(int i=a;i<=b;++i)\ntypedef long long ll;\n\nusing namespace std;\n\nvoid File(){\n    freopen(\"ARC80F.in\",\"r\",stdin);\n    freopen(\"ARC80F.out\",\"w\",stdout);\n}\n\nconst int maxn=500+10;\nint n,a[maxn],pos[maxn],tot,cnt,ans;\nint be[maxn],cnte,to[maxn*maxn],las[maxn*maxn],beg[maxn];\nbool vis[maxn];\n\nvoid add(int u,int v){\n    las[++cnte]=beg[u];\n    beg[u]=cnte;\n    to[cnte]=v;\n}\n\nbool pd(int x){\n    if(x==1 || x==2)return false;\n    int y=sqrt(x);\n    REP(i,2,y)if(x%i==0)return false;\n    return true;\n}\n\nbool Hungary(int u){\n    for(int i=beg[u];i;i=las[i]){\n        if(vis[to[i]])continue;\n        vis[to[i]]=1;\n        if(!be[to[i]] || Hungary(be[to[i]])){\n            be[to[i]]=u;\n            return true;\n        }\n    }\n    return false;\n}\n\nint main(){\n    scanf(\"%d\",&n);\n    REP(i,1,n){\n        scanf(\"%d\",&a[i]);\n        if(i==1 || a[i-1]<a[i]-1)pos[++tot]=a[i];\n        if(i!=1 && a[i]>a[i-1]+1)pos[++tot]=a[i-1]+1;\n    }\n    pos[++tot]=a[n]+1;\n    REP(i,1,tot)if(pos[i]%2)++cnt;\n    REP(i,1,tot)if(pos[i]%2==0){\n        REP(j,1,tot)if(pos[j]%2==1 && pd(abs(pos[j]-pos[i])))\n            add(i,j);\n    }\n    REP(i,1,tot)if(pos[i]%2==0){\n        memset(vis,0,sizeof(vis));\n        ans+=Hungary(i);\n    }\n    printf(\"%d\\n\",ans+(tot-ans*2)+(cnt-ans)%2);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <cstring>\n#include <cmath>\nusing namespace std;\n\nconst int MAX_N = 100 + 9;\nconst int MAX_M = 1e7 + 9;\n\nint N, x, cnt, match[MAX_N * 2 + 2], V;\nbool is_prime[MAX_M + 1], rev[MAX_M + 2], used[MAX_N * 2 + 2];\nvector<int> primes, v1, v2, G[MAX_N * 2 + 2];\n\nvoid sieve() {\n\tmemset(is_prime, 1, sizeof(is_prime));\n\tis_prime[0] = is_prime[1] = 0;\n\tfor (int i = 2; i <= MAX_M; i++) {\n\t\tif (is_prime[i]) {\n\t\t\tprimes.push_back(i);\n\t\t\tfor (int j = i * 2; j <= MAX_M; j += i) is_prime[j] = 0;\n\t\t}\n\t}\n}\n\nbool dfs(int v) {\n\tused[v] = true;\n\tfor (int i = 0; i < G[i].size(); i++) {\n\t\tint u = G[u][i], w = match[u];\n\t\tif (w < 0 || !used[u] && dfs(w)) {\n\t\t\tmatch[v] = u;\n\t\t\tmatch[u] = v;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nvoid bipartite_matching() {\n\tmemset(match, -1, sizeof(match));\n\tfor (int v = 0; v < V; v++) {\n\t\tif (match[v] < 0) {\n\t\t\tmemset(used, 0, sizeof(used));\n\t\t\tif (dfs(v)) {\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\tscanf(\"%d\", &N); sieve();\n\tfor (int i = 1; i <= N; i++) scanf(\"%d\", &x), rev[x] ^= true;\n\tfor (int i = 1; i <= MAX_M; i++) {\n\t\tif (rev[i] != rev[i - 1]) {\n\t\t\tif (i & 1) v1.push_back(i);\n\t\t\telse v2.push_back(i);\n\t\t}\n\t}\n\tfor (int i = 0; i < v1.size(); i++) {\n\t\tfor (int j = 0; j < v2.size(); j++) {\n\t\t\tif (is_prime[(int)abs(v1[i] - v2[j])]) G[i].push_back(j + v1.size());\n\t\t}\n\t}\n\tV = v1.size() + v2.size();\n\tbipartite_matching();\n\tprintf(\"%d\", cnt + (v1.size() - cnt >> 1 << 1) + (v2.size() - cnt >> 1 << 1) + ((v1.size() - cnt) & 1) * 3);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double lf;\ntypedef long double llf;\ntypedef std::pair<int,int> pii;\n\n#define xx first\n#define yy second\n\ntemplate<typename T> inline T max(T a,T b){return a>b?a:b;}\ntemplate<typename T> inline T min(T a,T b){return a<b?a:b;}\ntemplate<typename T> inline T abs(T a){return a>0?a:-a;}\ntemplate<typename T> inline bool repr(T &a,T b){return a<b?a=b,1:0;}\ntemplate<typename T> inline bool repl(T &a,T b){return a>b?a=b,1:0;}\ntemplate<typename T> inline T gcd(T a,T b){T t;if(a<b){while(a){t=a;a=b%a;b=t;}return b;}else{while(b){t=b;b=a%b;a=t;}return a;}}\ntemplate<typename T> inline T sqr(T x){return x*x;}\n#define mp(a,b) std::make_pair(a,b)\n#define pb push_back\n#define I inline\n#define mset(a,b) memset(a,b,sizeof(a))\n#define mcpy(a,b) memcpy(a,b,sizeof(a))\n\n#define fo0(i,n) for(int i=0,i##end=n;i<i##end;i++)\n#define fo1(i,n) for(int i=1,i##end=n;i<=i##end;i++)\n#define fo(i,a,b) for(int i=a,i##end=b;i<=i##end;i++)\n#define fd0(i,n) for(int i=(n)-1;~i;i--)\n#define fd1(i,n) for(int i=n;i;i--)\n#define fd(i,a,b) for(int i=a,i##end=b;i>=i##end;i--)\n#define foe(i,x)for(__typeof((x).end())i=(x).begin();i!=(x).end();++i)\n\nstruct Cg{I char operator()(){return getchar();}};\nstruct Cp{I void operator()(char x){putchar(x);}};\n#define OP operator\n#define RT return *this;\n#define RX x=0;char t=P();while((t<'0'||t>'9')&&t!='-')t=P();bool f=0;\\\nif(t=='-')t=P(),f=1;x=t-'0';for(t=P();t>='0'&&t<='9';t=P())x=x*10+t-'0'\n#define RL if(t=='.'){lf u=0.1;for(t=P();t>='0'&&t<='9';t=P(),u*=0.1)x+=u*(t-'0');}if(f)x=-x\n#define RU x=0;char t=P();while(t<'0'||t>'9')t=P();x=t-'0';for(t=P();t>='0'&&t<='9';t=P())x=x*10+t-'0'\n#define TR *this,x;return x;\nI bool IS(char x){return x==10||x==13||x==' ';}template<typename T>struct Fr{T P;I Fr&OP,(int&x)\n{RX;if(f)x=-x;RT}I OP int(){int x;TR}I Fr&OP,(ll &x){RX;if(f)x=-x;RT}I OP ll(){ll x;TR}I Fr&OP,(char&x)\n{for(x=P();IS(x);x=P());RT}I OP char(){char x;TR}I Fr&OP,(char*x){char t=P();for(;IS(t);t=P());if(~t){for(;!IS\n(t)&&~t;t=P())*x++=t;}*x++=0;RT}I Fr&OP,(lf&x){RX;RL;RT}I OP lf(){lf x;TR}I Fr&OP,(llf&x){RX;RL;RT}I OP llf()\n{llf x;TR}I Fr&OP,(uint&x){RU;RT}I OP uint(){uint x;TR}I Fr&OP,(ull&x){RU;RT}I OP ull(){ull x;TR}};Fr<Cg>in;\n#define WI(S) if(x){if(x<0)P('-'),x=-x;char s[S],c=0;while(x)s[c++]=x%10+'0',x/=10;while(c--)P(s[c]);}else P('0')\n#define WL if(y){lf t=0.5;for(int i=y;i--;)t*=0.1;if(x>=0)x+=t;else x-=t,P('-');*this,(ll)(abs(x));P('.');if(x<0)\\\nx=-x;while(y--){x*=10;x-=floor(x*0.1)*10;P(((int)x)%10+'0');}}else if(x>=0)*this,(ll)(x+0.5);else *this,(ll)(x-0.5);\n#define WU(S) if(x){char s[S],c=0;while(x)s[c++]=x%10+'0',x/=10;while(c--)P(s[c]);}else P('0')\ntemplate<typename T>struct Fw{T P;I Fw&OP,(int x){WI(10);RT}I Fw&OP()(int x){WI(10);RT}I Fw&OP,(uint x){WU(10);RT}\nI Fw&OP()(uint x){WU(10);RT}I Fw&OP,(ll x){WI(19);RT}I Fw&OP()(ll x){WI(19);RT}I Fw&OP,(ull x){WU(20);RT}I Fw&OP()\n(ull x){WU(20);RT}I Fw&OP,(char x){P(x);RT}I Fw&OP()(char x){P(x);RT}I Fw&OP,(const char*x){while(*x)P(*x++);RT}\nI Fw&OP()(const char*x){while(*x)P(*x++);RT}I Fw&OP()(lf x,int y){WL;RT}I Fw&OP()(llf x,int y){WL;RT}};Fw<Cp>out;\n\nconst int N=64005,M=432100;\n\nstruct edge\n{\n\tint to,w,ne;\n}e[M*2+2];\n\nint p[N+1],p2[N+1],em=2,dep[N+1],q[N+1],qe,fl[N+1],tm[N+1],T;\n\ninline void add(int a,int b,int w)\n{\n\te[em].to=b,e[em].w=w,e[em].ne=p[a],p[a]=em++;\n\te[em].to=a,e[em].w=0,e[em].ne=p[b],p[b]=em++;\n}\n\nbool dfs(int s,int t)\n{\n\tif(s==t)return 1;\n\tfor(int&j=p2[s];j;j=e[j].ne)\n\t\tif(tm[e[j].to]!=T&&e[j].w&&dep[e[j].to]==dep[s]+1)\n\t\t{\n\t\t\ttm[e[j].to]=T;\n\t\t\tfl[e[j].to]=min(e[j].w,fl[s]);\n\t\t\tif(dfs(e[j].to,t))\n\t\t\t{\n\t\t\t\te[j].w-=fl[t];\n\t\t\t\te[j^1].w+=fl[t];\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\tdep[s]=-1;\n\treturn 0;\n}\n\ninline int dinic(int s,int t)\n{\n\tint flow=0;\n\twhile(1)\n\t{\n\t\tmemset(dep,0,sizeof(dep));\n\t\tq[0]=s,qe=1,dep[s]=1;\n\t\t++T;\n\t\tfor(int i=0;i^qe;i++)\n\t\t{\n\t\t\ttm[q[i]]=T;\n\t\t\tfor(int j=p[q[i]];j;j=e[j].ne)\n\t\t\t\tif(!dep[e[j].to]&&e[j].w)\n\t\t\t\t{\n\t\t\t\t\tdep[e[j].to]=dep[q[i]]+1;\n\t\t\t\t\tq[qe++]=e[j].to;\n\t\t\t\t}\n\t\t}\n\t\tif(tm[t]!=T)break;\n\t\tfor(int i=0;i^qe;i++)\n\t\t\tp2[q[i]]=p[q[i]];\n\t\twhile(1)\n\t\t{\n\t\t\tfl[s]=0x7fffffff;\n\t\t\t++T;\n\t\t\tdfs(s,t);\n\t\t\tif(tm[t]!=T)break;\n\t\t\tflow+=fl[t];\n\t\t}\n\t}\n\treturn flow;\n}\n\nstd::map<int,int>t;\n\nbool pp(int n)\n{\n\tif(n<=2)return 0;\n\tfor(int i=2;i*i<=n;i++)if(n%i==0)return 0;\n\treturn 1;\n}\n\nint main()\n{\n\tfor(int n=in,x;n--;)\n\t{\n\t\tin,x;\n\t\tt[x]^=1,t[x+1]^=1;\n\t}\n\tstd::vector<int>s[2];\n\tfoe(i,t)if(i->yy)s[i->xx&1].pb(i->xx);\n\tint a=s[0].size(),b=s[1].size(),S=a+b,T=a+b+1;\n\t//fo0(i,a)out,s[0][i],' ';out,'\\n';\n\t//fo0(i,b)out,s[1][i],' ';out,'\\n';\n\tfo0(i,a)add(S,i,1);\n\t//fo0(i,a)fo0(j,b)if(pp(abs(s[0][i]-s[1][j])))out,'/',i,' ',j,'\\n';\n\tfo0(i,a)fo0(j,b)if(pp(abs(s[0][i]-s[1][j])))add(i,j+a,1);\n\tfo0(i,b)add(i+a,T,1);\n\tint g=dinic(S,T);\n\t//out,a,' ',b,' ',g,'\\n';\n\t//k × 1 + (?(Me - k)/2? + ?(Mo - k)/2?) × 2 + ((Me - k)%2) × 3\n\tint ans=a+b-g+(a-g)%2;\n\tout,ans,'\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <climits>\n#include <queue>\n#include <algorithm>\n\nusing std::queue;\nusing std::min;\n\nconst int MAXX=1e7+5,MAXN=105;\nint n,cnt_x,cnt_y;\nint x_id[MAXN],y_id[MAXN];\nbool up[MAXX];\n\nstruct node{int he,iter,dis;}d[MAXN];\nstruct line{int to,nex,cap;}ed[MAXN*MAXN];\n\ninline bool is_odd_prm(int x){\n\tif(x==2) return false;\n\tfor(int i=3;i*i<=x;i+=2){\n\t\tif(x%i==0) return false;\n\t}\n\treturn true;\n}\n\ninline void addE(int u,int v,int cap){\n\tstatic int cnt=1;\n\ted[++cnt]=(line){v,d[u].he};\n\td[u].he=cnt;\n}\n\ninline int revE(int i){return i^1;}\n\ninline bool BFS(int s,int t,int n){\n\tfor(int i=1;i<=n;++i)\n\t\td[i].dis=-1;\n\tstatic queue<int> q;\n\td[s].dis=0;\n\tq.push(s);\n\tint u;\n\twhile(q.size()){\n\t\tu=q.front();\n\t\tq.pop();\n\t\tfor(int i=d[u].he,v;i;i=ed[i].nex){\n\t\t\tif(ed[i].cap==0) continue;\n\t\t\tv=ed[i].to;\n\t\t\tif(d[v].dis==-1){\n\t\t\t\td[v].dis=d[u].dis+1;\n\t\t\t\tq.push(v);\n\t\t\t}\n\t\t}\n\t}\n\treturn d[t].dis!=-1;\n}\n\nint aug(int u,int rest,const int t){\n\tif(u==t) return rest;\n\tint ret=0;\n\tfor(int &i=d[u].iter,v,cap,flow;i;i=ed[i].nex){\n\t\tv=ed[i].to,cap=ed[i].cap;\n\t\tif(d[v].dis!=d[u].dis+1 || cap==0)\n\t\t\tcontinue;\n\t\tflow=aug(v,min(cap,rest),t);\n\t\ted[i].cap-=flow,ed[revE(i)].cap+=flow;\n\t\tret+=flow;\n\t\tif(ret==rest) return ret;\n\t}\n\tif(ret==0) d[u].dis=-1;\n\treturn ret;\n}\n\ninline int Dinic(int s,int t,int n){\n\tint ret=0;\n\twhile(BFS(s,t,n)){\n\t\tfor(int i=1;i<=n;++i)\n\t\t\td[i].iter=d[i].he;\n\t\tret+=aug(s,INT_MAX,t);\n\t}\n\treturn ret;\n}\n\ninline void build(){\n\tfor(int i=1;i<=cnt_x;++i){\n\t\tfor(int j=1,v;j<=cnt_y;++j){\n\t\t\tif(is_odd_prm(abs(x_id[i]-y_id[j]))){\n\t\t\t\tv=j+cnt_x;\n\t\t\t\taddE(i,v,INT_MAX),addE(v,i,0);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=1,s=cnt_x+cnt_y+1;i<=cnt_x;++i)\n\t\taddE(s,i,1),addE(i,s,0);\n\tfor(int i=1,u,t=cnt_x+cnt_y+2;i<=cnt_y;++i){\n\t\tu=cnt_x+i;\n\t\taddE(u,t,1),addE(t,u,0);\n\t}\n}\n\nint main(){\n\tscanf(\"%d\",&n);\n\tint x;\n\tfor(int i=1;i<=n;++i){\n\t\tscanf(\"%d\",&x);\n\t\tup[x]=true;\n\t}\n\tfor(int i=1;i<=x+1;++i){\n\t\tif(up[i]!=up[i-1])\n\t\t\ti&1 ? x_id[++cnt_x]=i:y_id[++cnt_y]=i;\n\t}\n\tbuild();\n\tint k=Dinic((cnt_x+cnt_y)|1,cnt_x+cnt_y+2,cnt_x+cnt_y+2);\n\tprintf(\"%d\",k+((((cnt_x-k)>>1)+((cnt_y-k)>>1))<<1)+(cnt_x-k)%2*3);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#define fo(i,a,b) for(int i=a;i<=b;++i)\n#define fod(i,a,b) for(int i=a;i>=b;--i)\n#define min(q,w) ((q)>(w)?(w):(q))\n#define max(q,w) ((q)<(w)?(w):(q))\nusing namespace std;\nconst int N=350,M=1e7;\nint read(int &n)\n{\n    char ch=' ';int q=0,w=1;\n    for(;(ch!='-')&&((ch<'0')||(ch>'9'));ch=getchar());\n    if(ch=='-')w=-1,ch=getchar();\n    for(;ch>='0' && ch<='9';ch=getchar())q=q*10+ch-48;n=q*w;return n;\n}\nint m,n,ans;\nbool az[M+10],prz[M+10];\nbool B[N][N];\nint pr[M/5];\nint a[N],b[N],zx[N];\nint z[N],TI;\nvoid Pre()\n{\n    fo(i,2,M)\n    {\n        if(!prz[i])pr[++pr[0]]=i;\n        fo(j,1,pr[0])\n        {\n            int t=i*pr[j];\n            if(t>M)break;\n            prz[t]=1;\n            if(!t%pr[j])break;\n        }\n    }\n    prz[1]=prz[2]=1;\n}\nbool OK(int q)\n{\n    if(z[q]==TI)return 0;\n    z[q]=TI;\n    fo(i,1,b[0])if(B[q][i]&&(!zx[i]||OK(zx[i])))return zx[i]=q,1;\n    return 0;\n}\nint main()\n{\n    int q;\n    Pre();\n    read(n);\n    fo(i,1,n)az[read(q)]=1;\n    fo(i,1,M+1)if(az[i]!=az[i-1])\n    {\n        if(i&1)a[++a[0]]=i;\n        else b[++b[0]]=i;\n    }\n    fo(i,1,a[0])fo(j,1,b[0])if(!prz[abs(a[i]-b[j])])B[i][j]=1;\n    q=0;\n    fo(i,1,a[0])\n    {\n        ++TI;if(OK(i))++q;\n        \n    }\n    ans=q+2*((a[0]-q)/2+(b[0]-q)/2);\n    if((a[0]-q)&1)ans+=3;\n    printf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint N,M;\nconst int MAX_N = 111;\nint a[MAX_N],b[MAX_N*2],sz;\n\nvector<int> path[MAX_N*2];\nbool visit[MAX_N*2];\nint match[MAX_N*4];\n\nbool dfs(int a){\n\tif(visit[a])return false;\n\tvisit[a]=1;\n\tfor(int i=0;i<path[a].size();i++){\n\t\tint b=path[a][i];\n\t\tif(match[b]<0){\n\t\t\tmatch[b]=a;\n\t\t\treturn true;\n\t\t}else if(dfs(match[b])){\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nbool isPrime(int x){\n\tif(x==1)return false;\n\tif(x%2==0)return false; // 2 is exception\n\tfor(int i=3;i*i<=x;i+=2){\n\t\tif(x%i==0)return false;\n\t}\n\treturn true;\n}\n\nint main(){\n\t\n\tscanf(\"%d\",&N);\n\tfor(int i=1;i<=N;i++){\n\t\tscanf(\"%d\",&a[i]);\n\t}\n\ta[0]=-1;\n\ta[N+1]=1e9;\n\n\tint even=0,odd=0;\n\tfor(int i=1;i<=N+1;i++){\n\t\tif(a[i-1]+1<a[i]){\n\t\t\tif(i>1)b[sz++]=a[i-1]+1;\n\t\t\tif(i<=N)b[sz++]=a[i];\n\t\t}\n\t}\n\n\tfor(int i=0;i<sz;i++){\n\t\tif(b[i]%2==0)even++;\n\t\telse odd++;\n\t}\n\n\tfor(int i=0;i<sz;i++){\n\t\tfor(int j=i+1;j<sz;j++){\n\t\t\tif(isPrime(b[j]-b[i])){\n\t\t\t\tpath[i].push_back(j+sz);\n\t\t\t\tpath[j+sz].push_back(i);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int i=0;i<sz*2;i++){\n\t\tmatch[i]=-1;\n\t}\n\t\n\tint cnt=0;\n\tfor(int i=0;i<sz;i++){\n\t\tfor(int j=0;j<sz;j++)visit[j]=0;\n\t\tif(dfs(i))cnt++;\n\t}\n\teven-=cnt;\n\todd-=cnt;\n\tprintf(\"%d\\n\",cnt+(even/2+odd/2)*2+(even%2)*3);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 10000005\n#define M 505\nusing namespace std;\nint n,cnt1=0,cnt2=0,cnt,p1[M],p2[M],a[M],b[N],pr[M*M*10],match[N];bool vis[N],mp[M][M];\nbool dfs(int u){\n\tfor (int i=1;i<=cnt2;i++){\n\t\tif (!mp[u][i]) continue;\n\t\tif (!match[i]||dfs(match[i])){\n\t\t\tmatch[i]=u;\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\nint main(){\n\tscanf(\"%d\",&n);int mx=0;\n\tfor (int i=1;i<=n;i++) scanf(\"%d\",&a[i]),b[a[i]]=1,mx=max(mx,a[i]);\n\tfor (int i=1;i<=mx+1;i++)\n\t\tif (b[i]!=b[i-1]){\n\t\t\tif (i&1) p1[++cnt1]=i;\n\t\t\telse p2[++cnt2]=i;\n\t\t}\n\tfor (int i=2;i<=1e7;i++){\n\t\tif (!vis[i]) pr[++cnt]=i;\n\t\tfor (int j=1;j<=cnt;j++){\n\t\t\tif (i*pr[j]>=N) break;\n\t\t\tvis[i*pr[j]]=1;\n\t\t\tif (i%pr[j]==0) break;\n\t\t}\n\t}\n\tvis[2]=vis[1]=1;int ans=0;\n\tfor (int i=1;i<=cnt1;i++)\n\t\tfor (int j=1;j<=cnt2;j++)\n\t\t\tif (!vis[abs(p1[i]-p2[j])]) mp[i][j]=1;\n\tfor (int i=1;i<=cnt1;i++) if (dfs(i)) ans++;\n\tint now1=cnt1-ans;int now2=cnt2-ans;\n\tans=ans+(now1/2)*2+(now2/2)*2;\n\tif (now1&1) ans+=3;\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> odd, even;\nvector<int> prime_Lst;\n\ntemplate<typename T>\nclass Maxflow\n{\n    struct edge { int to; T cap; int rev; };\n    std::vector<std::vector<edge> > edges;\n    std::vector<int> level;\n    std::vector<int> iter;\n    std::vector<int> used;\n\n    void bfs(int s)\n    {\n        level = std::vector<int>(edges.size(), -1);\n        std::queue<int> q;\n        level[s] = 0;\n        q.push(s);\n        while (!q.empty())\n        {\n            int v = q.front();\n            q.pop();\n            for (edge &e : edges[v])\n            {\n                if (e.cap > 0 && level[e.to] < 0)\n                {\n                    level[e.to] = level[v] + 1;\n                    q.push(e.to);\n                }\n            }\n        }\n    }\n\n    T dfs_d(int v, int goal, T f)\n    {\n        if (v == goal) return f;\n        for (int &i = iter[v]; i < (int)edges[v].size(); i++)\n        {\n            edge &e = edges[v][i];\n            if (e.cap > 0 && level[v] < level[e.to])\n            {\n                T d = dfs_d(e.to, goal, std::min(f, e.cap));\n                if (d > 0)\n                {\n                    e.cap -= d;\n                    edges[e.to][e.rev].cap += d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n\n    T dfs_ff(int v, int goal, T f)\n    {\n        if (v == goal) return f;\n        used[v] = true;\n        for (int i = 0; i < (int)edges[v].size(); i++)\n        {\n            edge &e = edges[v][i];\n            if (e.cap > 0 && !used[e.to])\n            {\n                T d = dfs_ff(e.to, goal, std::min(f, e.cap));\n                if (d > 0)\n                {\n                    e.cap -= d;\n                    edges[e.to][e.rev].cap += d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n\npublic:\n    Maxflow(int N) { edges.resize(N); }\n    void add_edge(int from, int to, T capacity)\n    {\n        edges[from].push_back(edge{to, capacity, (int)edges[to].size()});\n        edges[to].push_back(edge{from, (T)0, (int)edges[from].size() - 1});\n    }\n\n    T Dinic(int s, int t)\n    {\n        constexpr T INF = std::numeric_limits<T>::max();\n        T flow = 0;\n        while (true)\n        {\n            bfs(s);\n            if (level[t] < 0) return flow;\n            iter = std::vector<int>(edges.size(), 0);\n            T f;\n            while ((f = dfs_d(s, t, INF)) > 0) flow += f;\n        }\n    }\n\n    T FF(int s, int t)\n    {\n        constexpr T INF = std::numeric_limits<T>::max();\n        T flow = 0;\n        while (true)\n        {\n            used = std::vector<int>(edges.size(), 0);\n            T f = dfs_ff(s, t, INF);\n            if (f == 0) return flow;\n            flow += f;\n        }\n    }\n};\n\nvoid find_prime(int t)\n{\n    vector<bool> ok(t+1, true);\n    ok[0] = ok[1] = false;\n    for (long long i=2; i<=t; i++)\n    {\n        if (ok[i] && i>2) prime_Lst.push_back(i);\n        for (long long j=i; j<=t; j += i) ok[j] = false;\n    }\n}\n\nsigned main()\n{\n    int len;\n    cin >> len;\n    int tmp = -1;\n    for (int i=0; i<len; i++)\n    {\n        cin >> tmp;\n        if (tmp&1)\n        {\n            if (odd.size() == 0 || odd.back() != tmp)\n            {\n                odd.push_back(tmp);\n            }\n            else\n            {\n                odd.pop_back();\n            }\n            even.push_back(tmp+1);\n        }\n        else\n        {\n            if (even.size() == 0 || even.back() != tmp)\n            {\n                even.push_back(tmp);\n            }\n            else\n            {\n                even.pop_back();\n            }\n            odd.push_back(tmp+1);\n        }\n    }\n\n    find_prime(tmp);\n\n    int N = odd.size(), M = even.size();\n    Maxflow<int> flow(1+N+M+1);\n    for (int i=1; i<=N; i++) flow.add_edge(0, i, 1);\n    for (int i=1; i<=M; i++) flow.add_edge(N+i, 1+N+M, 1);\n    for (int i=1; i<=N; i++)\n    {\n        for (int j=1; j<=M; j++)\n        {\n            if (binary_search(prime_Lst.begin(), prime_Lst.end(), abs(odd[i-1] - even[j-1])))\n            {\n                flow.add_edge(i, N+j, 1);\n                // cout << odd[i-1] << \" \" << even[j-1] << endl;\n            }\n        }\n    }\n    // for (auto p : prime_Lst) cout << p << \" \";\n\n    int res = flow.FF(0, 1+N+M);\n    // cout << res << endl;\n    N -= res; M -= res;\n    \n    res += N+M;\n    if (N&1) res++;\n    cout << res << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nusing namespace std;\nint cnt,last[205],a[205],b[205],x[205],vis[205],match[205],prime[10000005],isprime[10000005],s[10000005];\nstruct node{\n\tint to,next;\n}e[1000005];\nvoid add(int a,int b){\n\te[++cnt].to=b;\n\te[cnt].next=last[a];\n\tlast[a]=cnt;\n}\nint dfs(int x){\n\tfor (int i=last[x]; i; i=e[i].next){\n\t\tint V=e[i].to;\n\t\tif (!vis[V]){\n\t\t\tvis[V]=1;\n\t\t\tif (!match[V] || dfs(V)){\n\t\t\t\tmatch[V]=x;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nint abs1(int x){\n\tif (x<0) return -x;\n\treturn x;\n}\nint main(){\n\tisprime[1]=1;\n\tfor (int i=2; i<=10000000; i++){\n\t\tif (!isprime[i]) prime[++cnt]=i;\n\t\tfor (int j=1; j<=cnt && i*prime[j]<=10000000; j++){\n\t\t\tisprime[i*prime[j]]=1;\n\t\t\tif (i%prime[j]==0) break;\n\t\t}\n\t}\n\tint n;\n\tscanf(\"%d\",&n);\n\tfor (int i=1; i<=n; i++){\n\t\tscanf(\"%d\",&x[i]);\n\t\ts[x[i]]^=1;\n\t}\n\tint num=0,sum=0;\n\tfor (int i=1; i<=10000001; i++)\n\t\tif (s[i]!=s[i-1]){\n\t\t\tif (i%2==1) a[++num]=i;\n\t\t\telse b[++sum]=i;\n\t\t}\n\tfor (int i=1; i<=num; i++)\n\t\tfor (int j=1; j<=sum; j++)\n\t\t\tif (!isprime[abs1(a[i]-b[j])]) add(i,j);\n\tint ss=0;\n\tfor (int i=1; i<=num; i++){\n\t\tfor (int j=1; j<=sum; j++) vis[j]=0;\n\t\tif (dfs(i)) ss++;\n\t}\n\tint ans=(num-ss)/2*2+(sum-ss)/2*2+ss+((num&1)!=(ss&1)?3:0);\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <cstdio>\n\nusing namespace std;\n\nconst int N=205;\nconst int M=N*N;\nconst int L=10000000;\n\nint last[N],bel[N];\nint nxt[M],tov[M];\nbool mark[L+5];\nint pos[2][N];\nbool vis[N];\nint n,tot,mx,match,ans;\n\ninline int iabs(int x){return x>0?x:-x;}\n\ninline void insert(int x,int y){tov[++tot]=y,nxt[tot]=last[x],last[x]=tot;}\n\ninline bool is_prime(int x)\n{\n\tif (x==1) return 0;\n\tfor (int i=2;i*i<=x;++i) if (!(x%i)) return 0;\n\treturn 1;\n}\n\nbool hungary(int x)\n{\n\tif (vis[x]) return 0;\n\tvis[x]=1;\n\tfor (int i=last[x],y;i;i=nxt[i])\n\t\tif (!bel[y=tov[i]]||hungary(y))\n\t\t\treturn bel[y]=x;\n\treturn 0;\n}\n\nint main()\n{\n\t//freopen(\"flip.in\",\"r\",stdin),freopen(\"flip.out\",\"w\",stdout);\n\tscanf(\"%d\",&n);\n\tfor (int i=1,x;i<=n;++i) scanf(\"%d\",&x),mx=max(mx,x),mark[x]=1;\n\tfor (int i=1;i<=mx+1;++i)\n\t\tif (mark[i]^mark[i-1])\n\t\t\tpos[i&1][++pos[i&1][0]]=i;\n\tfor (int i=1;i<=pos[0][0];++i)\n\t\tfor (int j=1;j<=pos[1][0];++j)\n\t\t{\n\t\t\tint d=iabs(pos[0][i]-pos[1][j]);\n\t\t\tif (is_prime(d)) insert(i,j);\n\t\t}\n\tmatch=0;\n\tfor (int i=1;i<=pos[0][0];++i) memset(vis,0,sizeof vis),match+=hungary(i);\n\tans=match,pos[0][0]-=match,pos[1][0]-=match;\n\tans+=(pos[0][0]&1)+pos[0][0]+pos[1][0];\n\tprintf(\"%d\\n\",ans);\n\t//fclose(stdin),fclose(stdout);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = (int)1e7 + 10;\ninline int read()\n{\n  int p=0; int f=1; char ch=getchar();\n  while(ch<'0' || ch>'9'){if(ch=='-') f=-1; ch=getchar();}\n  while(ch>='0' && ch<='9'){p=p*10+ch-'0'; ch=getchar();}\n  return p*f;\n}\n\nint prime[N],pri; bool v[N];\nvoid get_prime(int n)\n{\n  memset(v,1,sizeof(v)); v[0] = v[1] = 0; pri = 0;\n  for(int i=2;i<=n;i++)\n  {\n    if(v[i]) prime[++pri] = i;\n    for(int j=1;(j<=pri) && (i*prime[j] <= n);j++)\n    {\n      v[i*prime[j]] = 0;\n      if(i%prime[j]==0) break;\n    }\n  }\n  v[2] = 0;\n}\n\nstruct node{int x,y,next;}edge[100010]; int len,first[N];\nvoid ins(int x,int y){len++; edge[len].x=x; edge[len].y=y; edge[len].next=first[x]; first[x]=len;}\n\nint n,a[N],b[N];\n\n\nint chw[N],match[N];\nbool dfs(int x)\n{\n  for(int k=first[x];k!=-1;k=edge[k].next)\n  {\n    int y=edge[k].y;\n    if(!chw[y])\n    {\n      chw[y] = 1;\n      if((match[y] == 0) || dfs(match[y])) return 1;\n    }\n  }\n  return 0;\n}\n\nint main()\n{\n\n  get_prime(1e7+1);\n\n  n = read(); len = 0; memset(first,-1,sizeof(first));\n  for(int i=1;i<=n;i++) a[read()] = 1;\n  for(int i=1;i<=(int)1e7+1;i++) b[i] = abs(a[i] - a[i-1]);\n  for(int i=1;i<=(int)1e7+1;i++) a[i] = b[i];\n  int blen = 0; for(int i=1;i<=(int)1e7+1;i++) if(a[i] == 1) b[++blen] = i;\n  int c=0,d=0; for(int i=1;i<=blen;i++) if(b[i] & 1) c++; else d++;\n  for(int i=1;i<=blen;i++) if(b[i] & 1) for(int j=1;j<=blen;j++) if(!(b[j]&1)) if(v[abs(b[i] - b[j])]) ins(i,j);\n  int ans=0; for(int i=1;i<=blen;i++)\n  {\n    for(int j=1;j<=blen;j++) chw[j] = 0;\n    if(dfs(i)) ans++;\n  }\n \n  c-=ans; d-=ans;\n  ans += 2*(c/2 + d/2); c%=2; d%=2;\n  if(c && d) ans+=3;\n\n  return printf(\"%d\\n\",ans),0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cmath>\n#include<algorithm>\n#include<stack>\n#include<queue>\n#include<map>\n#include<set>\n#include<iomanip>\n#define _USE_MATH_DEFINES\n#include <math.h>\n#include <functional>\n#include<complex>\nusing namespace std;\n\n#define rep(i,x) for(ll i=0;i<x;i++)\n#define repn(i,x) for(ll i=1;i<=x;i++)\n\ntypedef long long ll;\nconst ll INF = 1e17;\nconst ll MOD = 1000000007;\nconst ll MAX = 4000001;\nconst long double eps = 1E-14;\n\nll max(ll a, ll b) {\n\tif (a > b) { return a; }\n\treturn b;\n}\n\nll min(ll a, ll b) {\n\tif (a > b) { return b; }\n\treturn a;\n}\n\nll gcd(ll a, ll b) {\n\tif (b == 0) { return a; }\n\tif (a < b) { return gcd(b, a); }\n\treturn gcd(b, a % b);\n}\n\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b) * b;\n}\n\nstruct edge {\n\tll ind;\n\tll fr;\n\tll to;\n\tll d;\n};\n\nclass mint {\n\tlong long x;\npublic:\n\tmint(long long x = 0) : x((x% MOD + MOD) % MOD) {}\n\tmint operator-() const {\n\t\treturn mint(-x);\n\t}\n\tmint& operator+=(const mint& a) {\n\t\tif ((x += a.x) >= MOD) x -= MOD;\n\t\treturn *this;\n\t}\n\tmint& operator-=(const mint& a) {\n\t\tif ((x += MOD - a.x) >= MOD) x -= MOD;\n\t\treturn *this;\n\t}\n\tmint& operator*=(const  mint& a) {\n\t\t(x *= a.x) %= MOD;\n\t\treturn *this;\n\t}\n\tmint operator+(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res += a;\n\t}\n\tmint operator-(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res -= a;\n\t}\n\tmint operator*(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res *= a;\n\t}\n\n\tmint pow(ll t) const {\n\t\tif (!t) return 1;\n\t\tmint a = pow(t >> 1);\n\t\ta *= a;\n\t\tif (t & 1) a *= *this;\n\t\treturn a;\n\t}\n\n\t// for prime MOD\n\tmint inv() const {\n\t\treturn pow(MOD - 2);\n\t}\n\tmint& operator/=(const mint& a) {\n\t\treturn (*this) *= a.inv();\n\t}\n\tmint operator/(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res /= a;\n\t}\n\n\tfriend ostream& operator<<(ostream& os, const mint& m) {\n\t\tos << m.x;\n\t\treturn os;\n\t}\n};\n\nmint pw(mint a, ll b) {\n\tif (b == 0) { return 1; }\n\tmint ret = pw(a, b >> 1);\n\tret *= ret;\n\tif (b & 1) { ret *= a; }\n\treturn ret;\n}\n\ntypedef vector<ll> vll;\ntypedef vector<vector<ll>> vvll;\ntypedef vector<vector<vector<ll>>> vvvll;\n\ntypedef vector<mint> vmint;\ntypedef vector<vector<mint>> vvmint;\ntypedef vector<vector<vector<mint>>> vvvmint;\n\n//////////////////////////////////////\n\nstruct Ford_Fulkerson {\n\n\tstruct f_edge {\n\t\tll to;\n\t\tll cap;\n\t\tll fl;\n\t\tll rev;//反対方向の辺の添え字\n\t};\n\n\n\tll N;\n\tll s, t;\n\tvector<vector<edge>> g;//グラフ片方向にのみ張る、flowで双方向に構築\n\tvector<vector<f_edge>> flow;\n\tll maxflow;\n\n\tvector<bool> see;\n\tll dfs(ll v, ll x) {\n\t\tsee[v] = 1;\n\n\t\tif (v == t) { return x; }\n\n\t\trep(i, flow[v].size()) {\n\t\t\tconst auto e = flow[v][i];\n\n\t\t\tif (see[e.to] == 1) { continue; }\n\t\t\tif (e.cap == e.fl) { continue; }\n\n\t\t\tll y = min(x, e.cap - e.fl);\n\n\t\t\ty = dfs(e.to, y);\n\t\t\tif (y == 0) { continue; }\n\n\t\t\tflow[v][i].fl += y;\n\t\t\tflow[e.to][e.rev].fl -= y;\n\t\t\treturn y;\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tFord_Fulkerson(ll N0, vector<vector<edge>> g0, ll s0, ll t0) {\n\t\tN = N0;\n\t\tg = g0;\n\t\ts = s0;\n\t\tt = t0;\n\n\t\tflow.resize(N + 1);\n\t\trepn(v, N) {\n\t\t\tfor (edge e : g[v]) {\n\t\t\t\tll w = e.to;\n\t\t\t\tflow[v].push_back({ w,e.d,0,flow[w].size() });\n\t\t\t\tflow[w].push_back({ v,0,0,flow[v].size() - 1 });\n\t\t\t}\n\t\t}\n\n\t\tmaxflow = 0;\n\n\t\tif (s == t) { maxflow = INF; return; }\n\n\t\twhile (1) {\n\t\t\tsee.assign(N + 1, 0);\n\t\t\tll f = dfs(s, INF);\n\t\t\tif (f == 0) { break; }\n\t\t\tmaxflow += f;\n\t\t}\n\n\t\tmaxflow = min(INF, maxflow);\n\n\t\treturn;\n\n\t}\n};\n\nbool odprime(ll x) {\n\tif (x <= 2) { return 0; }\n\tfor (ll i = 2; i * i <= x; i++) {\n\t\tif (x % i == 0) { return 0; }\n\t}\n\n\treturn 1;\n}\n\nint main() {\n\n\tll N;\n\tcin >> N;\n\tvll x(N + 1);\n\trepn(i, N) cin >> x[i];\n\n\tll M = 20000000;\n\tvector<bool> omote(M + 1, 1);\n\trepn(i, N) { omote[x[i]] = 0; }\n\n\tvector<ll> a(1, 0);\n\trep(i, M) { if (omote[i] != omote[i + 1]) { a.push_back(i); } }\n\tll K = a.size() - 1;\n\n\tvector<vector<edge>> g(K + 3);\n\tll ev = 0;\n\tll od = 0;\n\n\trepn(i, K) {\n\t\tif (a[i] % 2 == 1) { g[K + 1].push_back({ 0,K + 1,i,1 }); od++; }\n\t\telse { g[i].push_back({ 0,i,K + 2,1 }); ev++; }\n\t}\n\n\trepn(i, K)repn(j, K) {\n\t\tif (a[i] % 2 == 1 && a[j] % 2 == 0 && odprime(abs(a[i] - a[j]))) {\n\t\t\tg[i].push_back({0,i,j,1});\n\t\t}\n\t}\n\n\tFord_Fulkerson fd(K+2, g, K + 1, K + 2);\n\n\tll ans = fd.maxflow;\n\tod -= ans;\n\tev -= ans;\n\tans += od / 2 * 2;\n\tans += ev / 2 * 2;\n\tif (od % 2 == 1) { ans += 3; }\n\n\tcout << ans << endl;\n\n\t\n\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define maxn 10000007\n#define maxm 20001\n#define reg register\nusing namespace std;\nbool not_prime[maxn];\nint n,  pos[maxm], d[maxn], prime[maxn],a[maxm], m, cnt, siz[maxm]; \nint nt[maxm], fi[maxm], go[maxm], vis[maxm], visx[maxm], link[maxm]; \ninline int  read() {\n    reg int s = 0, t = 0; reg char ch = getchar();\n    while(ch > '9' || ch < '0') t |= ch == '-', ch = getchar();\n    while(ch >= '0' && ch <= '9') s = (s << 1) + (s << 3) + (ch ^ 48), ch = getchar();\n    return t ? -s : s;\n}\nvoid add(int x, int y){\n    nt[++cnt] = fi[x]; fi[x] = cnt; go[cnt] = y;\n    nt[++cnt] = fi[y]; fi[y] = cnt; go[cnt] = x;\n}\nvoid col(int x){\n    for(int i = fi[x]; i; i = nt[i]){\n        int v = go[i]; \n        if(!vis[v]) {\n            vis[v] = 3 - vis[x]; col(v);\n        }\n    }\n}\nint find(int x, int tim){\n    if(visx[x] == tim) return 0; visx[x] = tim;\n    for(int i = fi[x]; i; i = nt[i]){\n        int v =  go[i];\n        if(!link[v] || find(link[v], tim)){\n            link[v] = x; return 1;\n        }\n    }\n    return 0;\n}\nint main(){\n    n = read(); int ans = 0;\n    for(int i = 1; i <= n; i++) \n        pos[i] = read(), d[pos[i]] = 1; a[0] = -1;\n    sort(pos + 1, pos + n + 1);\n    n = unique(pos + 1, pos + n + 1) - pos - 1;\n    for(int i = 1; i <= n; i++) {\n        if(!d[pos[i] - 1] && a[m] != pos[i]) a[++m] = pos[i];\n        if(!d[pos[i] + 1]) a[++m] = pos[i] + 1; \n    }\n    for(int i = 2; i < maxn; i++) {\n        if(!not_prime[i]) prime[++cnt] = i;\n        for(int j = 1; j <= cnt && prime[j] * i < maxn; j++){\n            not_prime[i * prime[j]] = 1;\n            if(i % prime[j] == 0) break;\n        }\n    }\n    not_prime[2] = 1; cnt = 0; not_prime[1] = 1;\n    for(int i = 1; i <= m; i++)\n        for(int j = i + 1; j <= m; j++)\n            if(!not_prime[a[j] - a[i]]) add(i, j); \n    for(int i = 1; i <= m; i++)\n        if(!vis[i]) { vis[i] = 1; col(i); }\n    for(int i = 1; i <= m; i++)\n        if(vis[i] == 1) ans += (link[i] = find(i, i));       \n    int sum1 = 0, sum2 = 0;\n    for(int i = 1; i <= m; i++){\n        if(link[i]) continue; \n        sum1 += (a[i] & 1);\n        sum2 += (a[i] % 2 == 0);\n    }\n    if(sum1 & 1) ans += 3;\n    ans += sum1 / 2 * 2 + sum2 / 2 * 2;\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\ntypedef long long ll;\nint odd,even,Odd[105],Even[105],ma[105];\nint flag[10000010],x[10000010],map[105][105],vis[105];\nint prime[10000010],a[105];\nint dfs(int u)\n{\n\tfor (int v=1;v<=even;v++)\n\t{\n\t\tif (!map[u][v]) continue;\n\t\tif (!vis[v])\n\t\t{\n\t\t\tint t=ma[v];\n\t\t\tma[v]=u;\n\t\t\tvis[v]=1;\n\t\t\tif (t==-1||dfs(t)) return 1;\n\t\t\tma[v]=t;\n\t\t}\n\t}\n\treturn 0;\n}\nint main()\n{\n\tint n,cnt=0;\n\tscanf(\"%d\",&n);\n\tflag[1]=1;\n\tfor (int i=2;i<=10000000;i++)\n\t{\n\t\tif (!flag[i]) prime[++cnt]=i;\n\t\tfor (int j=1;j<=cnt;j++)\n\t\t{\n\t\t\tif (i*prime[j]>10000000) break;\n\t\t\tflag[i*prime[j]]=1;\n\t\t\tif (i%prime[j]==0) break;\n\t\t}\n\t}\n\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%d\",&a[i]);\n\t\tx[a[i]]^=1;\n\t}\n\tfor (int i=1;i<=10000000;i++)\n\t\tif (x[i]!=x[i-1])\n\t\t{\n\t\t\tif (i&1) Odd[++odd]=i;\n\t\t\telse Even[++even]=i; \n\t\t}\n\tfor (int i=1;i<=odd;i++)\n\t\tfor (int j=1;j<=even;j++)\n\t\t\tif (flag[abs(Odd[i]-Even[j])]) map[i][j]=1;\n\tmemset(ma,-1,sizeof(ma));\n\tint sum=0;\n\tfor (int i=1;i<=odd;i++)\n\t{\n\t\tmemset(vis,0,sizeof(vis));\n\t\tif (dfs(i)) sum++;\n\t}\n\tll ans=sum+(((odd-sum)>>1)<<1)+(((even-sum)>>1)<<1)+(odd-sum)%2*3+(even-sum)%2*3;\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>     \n#define ll long long\n#define mk make_pair\n#define y1 yyyy\nusing namespace std;\n\nconst int N = 5e4 + 5;\nconst int mod = 1e9 + 7;\n\nint n, a[N], my[N], ans;\nbool b[N * 200];\nvector<int> V[2], G[N];\n\nbool find(int x) {\n\tb[x] = 1;\n\tfor (int i = 0; i < G[x].size(); i++) {\n\t\tint u = G[x][i];\n\t\tif (my[u] == -1) {\n\t\t\tmy[u] = x;\n\t\t\treturn 1;\n\t\t} else {\n\t\t\tif (!b[my[u]] && find(my[u])) {\n\t\t\t\tmy[u] = x;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nbool check(int x) {\n\tif (x == 2) return 0;\n\tfor (int i = 2; i * i <= x; i++) {\n\t\tif (x % i == 0) return 0;\n\t}\n\treturn 1;\n}\n\nint main() {\n\tcin >> n;\n\tfor (int i = 1; i <= n; i++) cin >> a[i], b[a[i]] = 1;\n\tfor (int i = 1; i <= 10000001; i++) {\n\t\tif (b[i] != b[i - 1]) V[i & 1].push_back(i);\n\t}\n\tmemset(my, -1, sizeof(my));\n\tfor (int i = 0; i < V[0].size(); i++) {\n\t\tfor (int j = 0; j < V[1].size(); j++) {\n\t\t\tif (check(abs(V[0][i] - V[1][j]))) \n\t\t\t\tG[i].push_back(j);\n\t\t}\n\t}\n\tfor (int i = 0; i < V[0].size(); i++) {\n\t\tfor (int j = 0; j < V[0].size(); j++) b[j] = 0;\n\t\tif (find(i)) ans++;\n\t}\n\tcout << ans + (V[0].size() - ans) / 2 + (V[1].size() - ans) / 2 + V[0].size() % 2 * 3;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <set>\n#include <map>\n#include <list>\n#include <time.h>\n#include <math.h>\n#include <random>\n#include <deque>\n#include <queue>\n#include <cassert>\n#include <unordered_map>\n#include <iomanip>\n\nusing namespace std;\n\ntypedef long long ll;\n\nmt19937 rnd(228);\n\nconst int M = 2e7 + 7;\nconst int N = 1e2 + 1;\n\nbool prime[M];\n\nll dp[N][N][2];\n\nint get(int x)\n{\n    if (x == 0)\n    {\n        return 0;\n    }\n    if (x > 2 && prime[x])\n    {\n        return 1;\n    }\n    else\n    {\n        return 2 + (x % 2);\n    }\n}\n\nint main()\n{\n#ifdef ONPC\n    freopen(\"a.in\", \"r\", stdin);\n#endif\n    for (int i = 0; i < M; i++)\n    {\n        prime[i] = 1;\n    }\n    prime[1] = 0;\n    for (int i = 2; i < M; i++)\n    {\n        if (prime[i])\n        {\n            for (int j = i + i; j < M; j += i)\n            {\n                prime[j] = 0;\n            }\n        }\n    }\n    int n;\n    scanf(\"%d\", &n);\n    vector <int> x(n);\n    for (int i = 0; i < n; i++)\n    {\n        for (int j = 0; j < n; j++)\n        {\n            dp[i][j][0] = 1e18;\n            dp[i][j][1] = 1e18;\n        }\n    }\n    for (int i = 0; i < n; i++)\n    {\n        scanf(\"%d\", &x[i]);\n        dp[i][i][0] = 0;\n    }\n    for (int len = 1; len <= n; len++)\n    {\n        for (int l = 0; l + len - 1 < n; l++)\n        {\n            int r = l + len - 1;\n            for (int t = 0; t < 2; t++)\n            {\n                for (int j = l; j < r; j++)\n                {\n                    dp[l][r][t] = min(dp[l][r][t], dp[l][j][t] + (t == 0 ? get(x[j + 1] - x[j] - 1) : 0) + dp[j + 1][r][t]);\n                    for (int k = 0; k <= j; k++)\n                    {\n                        dp[l][r][t] = min(dp[l][r][t], dp[l][j][t] + dp[k][r][t]);\n                    }\n                }\n            }\n            for (int t = 0; t < 2; t++)\n            {\n                dp[l][r][t] = min(dp[l][r][t], dp[l][r][t ^ 1] + get(x[r] - x[l] + 1));\n            }\n        }\n    }\n    printf(\"%lld\\n\", dp[0][n - 1][1]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define pb push_back\nconst int maxn=210;\nint n,k,pri[10000010],linker[maxn],a[maxn],b[maxn];\nbool mark[10000010],vis[maxn];\nvector<int> v[maxn];\nvoid pre()\n{\n\tn=10000000;\n\tmark[1]=true;\n\tfor (int i=2;i<=n;i++)\n\t{\n\t\tif (!mark[i])\n\t\t{\n\t\t\tpri[k++]=i;\n\t\t\t//cerr<<i<<endl;\n\t\t}\n\t\tfor (int j=0;j<k;j++)\n\t\t{\n\t\t\tint m=i*pri[j];\n\t\t\tif (m>n)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmark[m]=true;\n\t\t\tif (i%pri[j]==0)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\nbool dfs(int x)\n{\n\tfor (int i=0;i<v[x].size();i++)\n\t{\n\t\tint y=v[x][i];\n\t\tif (vis[y])\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\t\tvis[y]=true;\n\t\tif (linker[y]==-1 || dfs(linker[y]))\n\t\t{\n\t\t\tlinker[y]=x;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\nint main()\n{\n\tpre();\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%d\",&a[i]);\n\t}\n\tint k=0;\n\tb[++k]=a[1]-1;\n\tfor (int i=2;i<=n;i++)\n\t{\n\t\tif (a[i]!=a[i-1]+1)\n\t\t{\n\t\t\tb[++k]=a[i-1];\n\t\t\tb[++k]=a[i]-1;\n\t\t}\n\t}\n\tb[++k]=a[n];\n\tn=k;\n\t/*\n\tif (n>200)\n\t{\n\t\treturn 0;\n\t}\n\t*/\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tlinker[i]=-1;\n\t\t//cerr<<b[i]<<endl;\n\t\tfor (int j=i+1;j<=n;j++)\n\t\t{\n\t\t\t/*\n\t\t\tif (abs(b[i]-b[j])>10000000)\n\t\t\t{\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\t*/\n\t\t\tif ((b[i]+b[j])&1 && !mark[abs(b[i]-b[j])])\n\t\t\t{\n\t\t\t\t//cerr<<i<<\" \"<<j<<\" \"<<abs(b[i]-b[j])<<\" \"<<mark[9]<<endl;\n\t\t\t\tif (b[i]&1)\n\t\t\t\t{\n\t\t\t\t\tv[i].pb(j);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tv[j].pb(i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint s=0;\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tif (!(b[i]&1))\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\t\tmemset(vis,false,sizeof(vis));\n\t\tif (dfs(i))\n\t\t{\n\t\t\ts++;\n\t\t}\n\t}\n\tint s1=0,s2=0;\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tif (b[i]&1)\n\t\t{\n\t\t\ts1++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\ts2++;\n\t\t}\n\t}\n\tint ans=s+((s1-s)/2+(s2-s)/2)*2+((s1-s)&1)*3;\n\tcout<<ans<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntemplate<typename T>\nvoid read(T &x)\n{\n\tchar ch=getchar();\n\tfor (x=0;ch<'0'||ch>'9';ch=getchar());\n\tfor (;ch>='0'&&ch<='9';x=x*10+ch-'0',ch=getchar());\n}\n#define INF 0x3f3f3f3f\nvector<int> odd,even;\nbool vis[10000010];\nint prime[1000010],p_cnt;\nint n;\nint a[110];\nnamespace Network\n{\n\tstruct edge{\n\t\tint s,t,cap,next;\n\t}e[100010];\n\tint head[510],cnt;\n\tvoid addedge(int s,int t,int cap)\n\t{\n\t\te[cnt].s=s;e[cnt].t=t;e[cnt].cap=cap;e[cnt].next=head[s];head[s]=cnt++;\n\t\te[cnt].s=t;e[cnt].t=s;e[cnt].cap=0;e[cnt].next=head[t];head[t]=cnt++;\n\t}\n\tqueue<int> q;\n\tint s,t;\n\tint dis[510]; \n\tbool bfs()\n\t{\n\t\tq.push(s);\n\t\tmemset(dis,0x3f,sizeof(dis));\n\t\tdis[s]=0;\n\t\twhile (!q.empty())\n\t\t{\n\t\t\tint tmp=q.front();\n\t\t\tq.pop();\n\t\t\tfor (int i=head[tmp];i!=-1;i=e[i].next)\n\t\t\t\tif (e[i].cap && dis[e[i].t]==INF)\n\t\t\t\t{\n\t\t\t\t\tdis[e[i].t]=dis[tmp]+1;\n\t\t\t\t\tq.push(e[i].t);\n\t\t\t\t}\n\t\t}\n\t\treturn dis[t]!=INF;\n\t}\n\tint find(int x,int low)\n\t{\n\t    if (x==t)\n\t        return low;\n\t    int used=0;\n\t    for (int i=head[x];i!=-1;i=e[i].next)\n\t        if (e[i].cap>0 && dis[e[i].t]==dis[x]+1)\n\t        {\n\t            int flow=find(e[i].t,min(low-used,e[i].cap));\n                e[i].cap-=flow;\n                e[i^1].cap+=flow;\n                used+=flow;\n                if (used==low)\n                    return low;\n\t        }\n\t    if (!used)\n\t        dis[x]=-1;\n\t    return used;\n\t}\n\tint dinic()\n\t{\n\t\tmemset(head,0xff,sizeof(head));\n\t\tcnt=0;\n\t\ts=0,t=odd.size()+even.size()+1;\n\t\tfor (int i=0;i<odd.size();i++)\n\t\t\taddedge(s,i+1,1);\n\t\tfor (int i=0;i<even.size();i++)\n\t\t\taddedge(odd.size()+i+1,t,1);\n\t\tfor (int i=0;i<odd.size();i++)\n\t\t\tfor (int j=0;j<even.size();j++)\n\t\t\t\tif (!vis[abs(odd[i]-even[j])])\n\t\t\t\t\taddedge(i+1,odd.size()+j+1,1);\n\t    int ans=0;\n\t    while (bfs())\n\t        ans+=find(s,INF);\n\t    return ans;\n\t}\n}\nvoid ins(int x)\n{\n\tif (x&1)\n\t\todd.push_back(x);\n\telse\n\t\teven.push_back(x);\n}\nvoid pre()\n{\n\tvis[1]=1; \n    for (int i=2;i<=10000000;i++)\n    {\n        if (!vis[i])\n            prime[++p_cnt]=i;\n        for (int j=1;j<=p_cnt&&i*prime[j]<=10000000;j++)\n        {\n            vis[i*prime[j]]=1;\n            if (i%prime[j]==0)\n                break;\n        }\n    }\n}\nint main()\n{\n\tread(n);\n\tfor (int i=1;i<=n;i++)\n\t\tread(a[i]);\n\tsort(a+1,a+n+1);\n\ta[0]=-1;\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tif (a[i-1]!=a[i]-1)\n\t\t\tins(a[i]);\n\t\tif (a[i+1]!=a[i]+1)\n\t\t\tins(a[i]+1);\n\t}\n\tpre();\n\tint k=Network::dinic();\n\tprintf(\"%d\\n\",k+2*((odd.size()-k)/2+(even.size()-k)/2)+3*(odd.size()%2));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\nstatic const int MAXN = 102;\nstatic const int MAXX = 1e7 + 200;\nstatic const int INF = 0x3fffffff;\n\nint n, x[MAXN];\nint m, y[MAXN * 2], k;\n\nbool not_prime[MAXX] = { false };\nint primes[MAXX / 10], prime_ct = 0;\n\ninline void sieve()\n{\n    not_prime[0] = not_prime[1] = true;\n    for (int i = 2; i < MAXX; ++i) {\n        if (!not_prime[i]) primes[prime_ct++] = i;\n        for (int j = 0; j < prime_ct && i * primes[j] < MAXX; ++j) {\n            not_prime[i * primes[j]] = true;\n            if (i % primes[j] == 0) break;\n        }\n    }\n}\n\nnamespace nwf {\n\nstatic const int MAXN = ::MAXN * 2 + 2;\n\nint n, source, sink;\nstruct edge {\n    int dest, cap, resi;\n    edge() { }\n    edge(int dest, int cap, int resi)\n        : dest(dest), cap(cap), resi(resi) { }\n};\nstd::vector<edge> e[MAXN];\n\ninline void init(int _n) {\n    n = _n;\n    for (int i = 0; i < n; ++i) e[i].clear();\n}\n\ninline void add_edge(int u, int v, int c, int r = 0) {\n    e[u].push_back(edge(v, c, e[v].size()));\n    e[v].push_back(edge(u, r, e[u].size() - 1));\n}\n\nint lim;\nint d[MAXN];\n\ninline bool level_graph() {\n    static int q[MAXN], qhead, qtail;\n    for (int i = 0; i < n; ++i) d[i] = -1;\n    d[source] = 0, q[0] = source, qhead = 0, qtail = 1;\n\n    while (qhead < qtail) {\n        int u = q[qhead++];\n        for (std::vector<edge>::iterator w = e[u].begin(); w != e[u].end(); ++w)\n            if (w->cap >= lim && d[w->dest] == -1) {\n                d[w->dest] = d[u] + 1;\n                q[qtail++] = w->dest;\n            }\n    }\n\n    return (d[sink] >= 0);\n}\n\nint cur[MAXN];\n\ninline int augment(int u, int cur_cap) {\n    if (u == sink) return cur_cap;\n    int new_cap;\n    for (int &i = cur[u]; i < e[u].size(); ++i) {\n        edge &w = e[u][i];\n        if (w.cap >= lim && d[w.dest] == d[u] + 1 &&\n            (new_cap = augment(w.dest, std::min(w.cap, cur_cap))) >= lim)\n        {\n            w.cap -= new_cap;\n            e[w.dest][w.resi].cap += new_cap;\n            return new_cap;\n        }\n    }\n    return 0;\n}\n\ninline int deluge() {\n    int ans = 0, aug;\n    for (lim = 1 << 22; lim > 0; lim >>= 1) {\n        while (level_graph()) {\n            for (int i = 0; i < n; ++i) cur[i] = 0;\n            while ((aug = augment(source, INF)) > 0) ans += aug;\n        }\n    }\n    return ans;\n}\n\n}\n\nint main()\n{\n    sieve();\n\n    scanf(\"%d\", &n);\n    for (int i = 0; i < n; ++i) scanf(\"%d\", &x[i]);\n    y[0] = x[0]; m = 1;\n    for (int i = 1; i < n; ++i)\n        if (x[i] != x[i - 1] + 1) { y[m++] = x[i - 1] + 1; y[m++] = x[i]; }\n    y[m++] = x[n - 1] + 1;\n\n    k = std::partition(y, y + m, [] (int x) { return x & 1; }) - &y[0];\n\n    nwf::init(m + 2);\n    nwf::source = m, nwf::sink = m + 1;\n    for (int i = 0; i < k; ++i) nwf::add_edge(nwf::source, i, 1);\n    for (int i = k; i < m; ++i) nwf::add_edge(i, nwf::sink, 1);\n    for (int i = 0; i < k; ++i)\n        for (int j = k; j < m; ++j)\n            if (y[j] > y[i] && !not_prime[y[j] - y[i]]) nwf::add_edge(i, j, 1);\n\n    int match = nwf::deluge();\n    int ans = match * 1 + ((k - match) / 2) * 2 + ((m - k - match) / 2) * 2 + ((k - match) & 1) * 3;\n    printf(\"%d\\n\", ans);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> P;\n\n#define fr first\n#define sc second\n\ntemplate<class T=ll>\nstruct edge{\n\tint to;\n\tT cap;\n\tint rev;\n};\n\ntemplate<int N=100010,class T=ll>\nstruct MaxFlow_Dinic{\n\tvector<edge<T>> G[N];\n\tint level[N];\n\tint iter[N];\n\tvoid add_edge(int from,int to,T cap){\n\t\t\tG[from].push_back((edge<T>){to,cap,(int)G[to].size()});\n\t\t\tG[to].push_back((edge<T>){from,0,(int)G[from].size()-1});\n\t}\n\tvoid bfs(int s){\n\t\tmemset(level,-1,sizeof level);\n\t\tqueue<int> que;\n\t\tlevel[s]=0;\n\t\tque.push(s);\n\t\twhile(!que.empty()){\n\t\t\tint v=que.front(); que.pop();\n\t\t\tfor(edge<T> &e: G[v]){\n\t\t\t\tif(e.cap>0&&level[e.to]<0){\n\t\t\t\t\tlevel[e.to]=level[v]+1;\n\t\t\t\t\tque.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tT dfs(int v,int t,T f){\n\t\tif(v==t)return f;\n\t\tfor(int &i=iter[v];i<G[v].size();i++){\n\t\t\tedge<T> &e=G[v][i];\n\t\t\tif(e.cap>0&&level[v]<level[e.to]){\n\t\t\t\tT d=dfs(e.to,t,min(f,e.cap));\n\t\t\t\tif(d>0){\n\t\t\t\t\te.cap-=d;\n\t\t\t\t\tG[e.to][e.rev].cap+=d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tT run(int s,int t,T inf=1000000000){\n\t\tT ret=0;\n\t\twhile(1){\n\t\t\tbfs(s);\n\t\t\tif(level[t]<0)return ret;\n\t\t\tmemset(iter,0,sizeof iter);\n\t\t\tT f;\n\t\t\twhile((f=dfs(s,t,inf))>0){\n\t\t\t\tret+=f;\n\t\t\t}\n\t\t}\n\t}\n};\n\ntemplate<int N=100010>\nstruct MatchingBigraph{\n\tMaxFlow_Dinic<N,int> G;\n\tint type[N];\n\tvoid add_edge(int u,int v){\n\t\tG.add_edge(u,v,1);\n\t\ttype[u]=1;\n\t\ttype[v]=2;\n\t}\n\tvector<P> run(){\n\t\tfor(int i=0;i<N;i++){\n\t\t\tif(type[i]==1)G.add_edge(N-2,i,1);\n\t\t\tif(type[i]==2)G.add_edge(i,N-1,1);\n\t\t}\n\t\tint t=G.run(N-2,N-1);\n\t\tvector<P> ret;\n\t\tfor(int i=0;i<N;i++){\n\t\t\tif(type[i]!=1)continue;\n\t\t\tfor(edge<int> e: G.G[i]){\n\t\t\t\tif(e.to!=N-2&&e.cap==0)ret.push_back(P(i,e.to));\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n};\n\n/*int main(){\n\tstatic int L,R,M;\n\tstatic int a[200010],b[200010];\n\tscanf(\"%d%d%d\",&L,&R,&M);\n\tfor(int i=0;i<M;i++){\n\t\tscanf(\"%d%d\",&a[i],&b[i]);\n\t}\n\tstatic MatchingBigraph<200010> G;\n\tfor(int i=0;i<M;i++){\n\t\tG.add_edge(a[i],L+b[i]);\n\t}\n\tvector<P> ret=G.run();\n\tprintf(\"%d\\n\",(int)ret.size());\n\tfor(P p: ret){\n\t\tprintf(\"%d %d\\n\",p.fr,p.sc-L);\n\t}\n}*/\n\nbool is_prime(int x){\n\tif(x==1)return false;\n\tfor(int i=2;i*i<=x;i++){\n\t\tif(x%i==0)return false;\n\t}\n\treturn true;\n}\n\nint main(){\n\tint n;\n\tint x[102];\n\tscanf(\"%d\",&n);\n\tfor(int i=0;i<n;i++)scanf(\"%d\",&x[i]);\n\t\n\tset<int> S;\n\tfor(int i=0;i<n;i++){\n\t\tif(S.find(x[i])!=S.end())S.erase(x[i]);\n\t\telse S.insert(x[i]);\n\t\tif(S.find(x[i]+1)!=S.end())S.erase(x[i]+1);\n\t\telse S.insert(x[i]+1);\n\t}\n\tvector<int> v[2];\n\tfor(int a: S){\n\t\tv[a&1].push_back(a);\n\t}\n\t\n\tstatic MatchingBigraph<205> G;\n\tfor(int i=0;i<v[0].size();i++){\n\t\tfor(int j=0;j<v[1].size();j++){\n\t\t\tif(is_prime(abs(v[0][i]-v[1][j]))){\n\t\t\t\tG.add_edge(i,v[0].size()+j);\n\t\t\t}\n\t\t}\n\t}\n\tint t=G.run().size();\n\tint ret=v[0].size()+v[1].size()-t+((v[0].size()-t)&1);\n\tcout<<ret<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint N,M;\nconst int MAX_N = 111;\nint a[MAX_N],b[MAX_N*2],sz;\nvector<int> odd,even;\n\nvector<int> path[MAX_N*2];\nbool visit[MAX_N*2];\nint match[MAX_N*2];\n\nbool dfs(int a){\n\tif(visit[a])return false;\n\tvisit[a]=1;\n\tfor(int i=0;i<path[a].size();i++){\n\t\tint b=path[a][i];\n\t\tif(match[b]<0){\n\t\t\tmatch[b]=a;\n\t\t\treturn true;\n\t\t}else if(dfs(match[b])){\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nbool isPrime(int x){\n\tif(x==1)return false;\n\tif(x%2==0)return false; // 2 is exception\n\tfor(int i=3;i*i<=x;i+=2){\n\t\tif(x%i==0)return false;\n\t}\n\treturn true;\n}\n\nint main(){\n\t\n\tscanf(\"%d\",&N);\n\tfor(int i=1;i<=N;i++){\n\t\tscanf(\"%d\",&a[i]);\n\t}\n\ta[0]=-1;\n\ta[N+1]=1e9;\n\n\tfor(int i=1;i<=N+1;i++){\n\t\tif(a[i-1]+1<a[i]){\n\t\t\tif(i>1)b[sz++]=a[i-1]+1;\n\t\t\tif(i<=N)b[sz++]=a[i];\n\t\t}\n\t}\n\n\tfor(int i=0;i<sz;i++){\n\t\tif(b[i]%2==0)even.push_back(b[i]);\n\t\telse odd.push_back(b[i]);\n\t}\n\n\tfor(int i=0;i<even.size();i++){\n\t\tfor(int j=0;j<odd.size();j++){\n\t\t\tif(isPrime(odd[j]-even[i])){\n\t\t\t\tpath[i].push_back(j);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int i=0;i<even.size();i++){\n\t\tmatch[i]=-1;\n\t}\n\t\n\tint cnt=0;\n\tfor(int i=0;i<even.size();i++){\n\t\tfor(int j=0;j<even.size();j++)visit[j]=0;\n\t\tif(dfs(i))cnt++;\n\t}\n\n\tint z0=even.size()-cnt;\n\tint z1=odd.size()-cnt;\n\tprintf(\"%d\\n\",cnt+(z0/2+z1/2)*2+(z0%2)*3);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, n) for(int i = 0; i < n; i++)\n#define rep2(i, x, n) for(int i = x; i <= n; i++)\n#define rep3(i, x, n) for(int i = x; i >= n; i--)\n#define elif else if\n#define sp(x) fixed << setprecision(x)\n#define pb push_back\n#define eb emplace_back\n#define all(x) x.begin(), x.end()\n#define sz(x) (int)x.size()\nusing ll = long long;\nusing ld = long double;\nusing pii = pair<int, int>;\nusing pil = pair<int, ll>;\nusing pli = pair<ll, int>;\nusing pll = pair<ll, ll>;\nconst ll MOD = 1e9+7;\n//const ll MOD = 998244353;\nconst int inf = (1<<30)-1;\nconst ll INF = (1LL<<60)-1;\nconst ld EPS = 1e-10;\ntemplate<typename T> bool chmax(T &x, const T &y) {return (x < y)? (x = y, true) : false;};\ntemplate<typename T> bool chmin(T &x, const T &y) {return (x > y)? (x = y, true) : false;};\n\nstruct edge{\n    int to;\n    ll cap;\n    int rev; //逆辺のindex\n};\n\nconst int MAX_V = 1e3;\nvector<edge> es[MAX_V];\nvector<bool> used(MAX_V, false);\n\n//fromからtoに容量capの辺を張る\nvoid add_edge(int from, int to, ll cap){\n    edge e1 = {to, cap, sz(es[to])}, e2 = {from, 0, sz(es[from])};\n    es[from].eb(e1), es[to].eb(e2);\n}\n\n//増加パスをdfsで探す\nll dfs(int now, int goal, ll flow){\n    if(now == goal) return flow;\n    used[now] = true;\n    for(auto &e: es[now]){\n        if(!used[e.to] && e.cap > 0){\n            ll f = dfs(e.to, goal, min(flow, e.cap));\n            if(f > 0){\n                e.cap -= f;\n                es[e.to][e.rev].cap += f;\n                return f;\n            }\n        }\n    }\n    return 0;\n}\n\nll max_flow(int s, int t){\n    ll flow = 0;\n    while(true){\n        fill(all(used), false);\n        ll f = dfs(s, t, INF);\n        if(f == 0) break;\n        flow += f;\n    }\n    return flow;\n}\n\nint main(){\n    int N;\n    cin >> N;\n    int MAX = 1e7;\n    vector<int> a(MAX+2, 0);\n    rep(i, N){\n        int x; cin >> x;\n        a[x] = 1;\n    }\n    vector<int> od, ev;\n    rep(i, MAX+1){\n        if(a[i]^a[i+1]){\n            if(i&1) od.pb(i);\n            else ev.pb(i);\n        } \n    }\n    int n = sz(od), m = sz(ev), s = n+m, t = n+m+1;\n    rep(i, n) add_edge(s, i, 1);\n    rep(i, m) add_edge(n+i, t, 1);\n    rep(i, n) rep(j, m){\n        int d = abs(od[i]-ev[j]);\n        bool p = (d != 1);\n        for(int k = 2; k*k <= d; k++){\n            if(d%k == 0) p = false;\n        }\n        if(p) add_edge(i, n+j, 1);\n    }\n    int f = max_flow(s, t);\n    cout << n+m-f+(n-f)%2 << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int MAXN = 1000100;\n\n#define rep(i, a, b) for(int i = a; i < (b); ++i)\n#define trav(a, x) for(auto& a : x)\n#define all(x) begin(x), end(x)\n#define sz(x) (int)(x).size()\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\nint N;\nint arr[MAXN];\n \nstruct Dinic {\n    struct Edge {\n        int to, rev;\n        ll c, f;\n    };\n    vi lvl, ptr, q;\n    vector<vector<Edge>> adj;\n    Dinic(int n) : lvl(n), ptr(n), q(n), adj(n) {}\n    void addEdge(int a, int b, ll c, int rcap = 0) {\n        adj[a].push_back({b, sz(adj[b]), c, 0});\n        adj[b].push_back({a, sz(adj[a]) - 1, rcap, 0});\n    }\n    ll dfs(int v, int t, ll f) {\n        if (v == t || !f) return f;\n        for (int& i = ptr[v]; i < sz(adj[v]); i++) {\n            Edge& e = adj[v][i];\n            if (lvl[e.to] == lvl[v] + 1)\n                if (ll p = dfs(e.to, t, min(f, e.c - e.f))) {\n                    e.f += p, adj[e.to][e.rev].f -= p;\n                    return p;\n                }\n        }\n        return 0;\n    }\n    ll calc(int s, int t) {\n        ll flow = 0; q[0] = s;\n        rep(L,0,31) do { // 'int L=30' maybe faster for random data\n            lvl = ptr = vi(sz(q));\n            int qi = 0, qe = lvl[s] = 1;\n            while (qi < qe && !lvl[t]) {\n                int v = q[qi++];\n                trav(e, adj[v])\n                    if (!lvl[e.to] && (e.c - e.f) >> (30 - L))\n                        q[qe++] = e.to, lvl[e.to] = lvl[v] + 1;\n            }\n            while (ll p = dfs(s, t, LLONG_MAX)) flow += p;\n        } while (lvl[t]);\n        return flow;\n    }\n};\n\nbool pr (int x)\n{\n    for (int i = 2; i * i <= x; i++)\n        if (x % i == 0) return false;\n    return true;\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(0);\n\n    cin >> N;\n    for (int i = 0; i < N; i++)\n        cin >> arr[i];\n    vector <int> v;\n    for (int i = 0; i < N; i++)\n    {\n        if (i == 0 || arr[i-1] + 1 < arr[i])\n            v.push_back(arr[i]);\n        if (i == N - 1 || arr[i+1] - 1 > arr[i])\n            v.push_back(arr[i]+1);\n    }\n\n    int m = v.size();\n    Dinic d (m + 2);\n    int ne = 0, no = 0;\n    for (int i = 0; i < m; i++)\n    {\n        if (v[i] % 2 == 0)\n        {\n            d.addEdge (m, i, 1);\n            ne++;\n        }\n        else\n        {\n            d.addEdge (i, m + 1, 1);\n            no++;\n        }\n    }\n    for (int i = 0; i < m; i++)\n        for (int j = 0; j < m; j++)\n        {\n            if (v[i] % 2 == 0 && v[j] % 2 == 1)\n            {\n                if (pr (abs (v[i] - v[j])))\n                    d.addEdge (i, j, 1);\n            }\n        }\n\n    int r = d.calc (m, m + 1);\n\n    int res = r;\n    ne -= r;\n    no -= r;\n    res += 2 * (ne / 2 + no / 2);\n    res += 3 * (ne % 2);\n    cout << res << \"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#pragma GCC optimize(2)\nusing namespace std;\nlong long read()\n{\n\tchar ch=getchar();long long x=0,ff=1;\n\twhile(ch<'0'||ch>'9') {if(ch=='-') ff=-ff;ch=getchar();}\n\twhile(ch>='0'&&ch<='9') x=x*10+ch-'0',ch=getchar();\n\treturn x*ff;\n}\nvoid write(long long aa)\n{\n\tif(aa<0) putchar('-'),aa=-aa;\n\tif(aa>9) write(aa/10);\n\tputchar(aa%10+'0');\n\treturn;\n}\nlong long n,cnt,L,R,ans;\nlong long a[105],md[205];\nlong long l[205],r[205],dy[205],vis[205];\nlong long tot,head[205],nx[400005],to[400005];\nvoid add(long long aa,long long bb)\n{\n\ttot++;\n\tnx[tot]=head[aa];\n\tto[tot]=bb;\n\thead[aa]=tot;\n\treturn;\n}\nlong long ok(long long aa,long long bb)\n{\n\tlong long len=abs(md[aa]-md[bb]);\n\tfor(long long i=2;i*i<=len;++i) if(len%i==0) return 0;\n\treturn 1;\n}\nlong long dfs(long long rt)\n{\n\tfor(long long i=head[rt];i;i=nx[i])\n\t{\n\t\tlong long yy=to[i];\n\t\tif(vis[yy]) continue;vis[yy]=1;\n\t\tif(!dy[yy]||dfs(dy[yy])) {dy[yy]=rt;return 1;}\n\t}\n\treturn 0;\n}\nint main()\n{\n\tn=read();a[0]=-10;\n\tfor(long long i=1;i<=n;++i) a[i]=read();\n\tfor(long long i=1;i<=n;++i) \n\t{\n\t\tif(a[i]!=a[i-1]+1) md[++cnt]=a[i]-1;\n\t\tif(a[i]+1!=a[i+1]) md[++cnt]=a[i];\n\t}\n\tfor(long long i=1;i<=cnt;++i) \n\tif(md[i]%2==0) l[++L]=i;\n\telse r[++R]=i;\n\tfor(long long i=1;i<=L;++i) for(long long j=1;j<=R;++j) \n\tif(ok(l[i],r[j])) add(l[i],r[j]);\n\tfor(long long i=1;i<=L;++i) \n\t{\n\t\tmemset(vis,0,sizeof(vis));\n\t\tif(dfs(i)) ans++;\n\t}\n\tlong long ls=L-ans,rs=R-ans;\n\tans+=ls/2*2;ans+=rs/2*2;\n\tif(ls%2==1) ans+=3;\n\twrite(ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#ifndef ONLINE_JUDGE\n#define dbg(x...) do { cout << \"\\033[32;1m \" << #x << \" -> \"; err(x); } while (0)\nvoid err() { cout << \"\\033[39;0m\" << endl; }\ntemplate<template<typename...> class T, typename t, typename... A>\nvoid err(T<t> a, A... x) { for (auto v: a) cout << v << ' '; err(x...); }\ntemplate<typename T, typename... A>\nvoid err(T a, A... x) { cout << a << ' '; err(x...); }\n#else\n#define dbg(...)\n#endif\ntypedef long long ll;\ntypedef pair<int,int> pi;\ntypedef vector<int> vi;\ntemplate<class T> using vc=vector<T>;\ntemplate<class T> using vvc=vc<vc<T>>;\ntemplate<class T> void mkuni(vector<T>&v)\n{\n    sort(v.begin(),v.end());\n    v.erase(unique(v.begin(),v.end()),v.end());\n}\ntemplate<class T>\nvoid print(T x,int suc=1)\n{\n    cout<<x;\n    if(suc==1) cout<<'\\n';\n    else cout<<' ';\n}\ntemplate<class T>\nvoid print(const vector<T>&v,int suc=1)\n{\n    for(int i=0;i<v.size();i++)\n    print(v[i],i==(int)(v.size())-1?suc:2);\n}\nconst int maxn=1e7+7;\nvi prime;\nbool vis[maxn];\nvoid db()\n{\n    for(int i=2;i<maxn;i++)\n    {\n        if(!vis[i])\n            prime.push_back(i);\n        for(auto p:prime)\n        {\n            if(i*p>=maxn) break;\n            vis[i*p]=1;\n            if(i%p==0) break;\n        }\n    }\n    vis[1]=1;\n    vis[2]=1;\n}\ninline int cost(int len)\n{\n    if(!len) return 0;\n    if(!vis[len]) return 1;\n    if(len&1) return 3;\n    return 2;\n}\nint x[105];\nint dp[105][105][2];\nint main()\n{\n    db();\n    int n;\n    cin>>n;\n    memset(dp,0x3f,sizeof(dp));\n    for(int i=1;i<=n;i++)\n    {\n        cin>>x[i];\n        dp[i][i][1]=0;\n        dp[i][i][0]=cost(1);\n    }\n    for(int len=2;len<=n;len++)\n    {\n        for(int l=1,r=len+l-1;r<=n;l++,r++)\n        {\n            for(int k=l+1;k<=r;k++)\n            {\n                dp[l][r][1]=min({dp[l][r][1],dp[l][k-1][0]+dp[k][r][0]+cost(x[r]-x[l]+1),dp[l][k-1][1]+dp[k][r][0]+cost(x[r]-x[k-1]),dp[l][k-1][0]+dp[k][r][1]+cost(x[k]-x[l]),dp[l][k-1][1]+dp[k][r][1]+cost(x[k]-x[k-1]-1)});\n                dp[l][r][0]=min({dp[l][r][0],dp[l][k-1][0]+dp[k][r][0],dp[l][k-1][1]+dp[k][r][0]+cost(x[k-1]-x[l]+1),dp[l][k-1][0]+dp[k][r][1]+cost(x[r]-x[k]+1),dp[l][k-1][1]+dp[k][r][1]+cost(x[k-1]-x[l]+1)+cost(x[r]-x[k]+1),dp[l][r][1]+cost(x[r]-x[l]+1)});\n            }\n            //dbg(l,r,dp[l][r][0],dp[l][r][1]);\n        }\n    }\n    cout<<dp[1][n][0]<<'\\n';    \n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int maxn=1e7+10;\nint n,a[110],b[110],m,ans;\nint b1[110],b2[110],p1,p2;\nbool np[maxn],vis[110],g[110][110],s[maxn];\nint match[110];\nvector<int> p;\n\nvoid init(){\n\tnp[0]=np[1]=1;\n\tfor(int i=2;i<maxn;++i){\n\t\tif(!np[i]){\n\t\t\tp.push_back(i);\n\t\t\t//cerr<<i<<endl;\n\t\t\t//system(\"pause\");\n\t\t}\n\t\tfor(int j=0,j_end=p.size(),x;j<j_end&&(x=p[j]*i)<maxn;++j){\n\t\t\tnp[x]=true;\n\t\t\tif(i%p[j]==0)break;\n\t\t}\n\t}\n}\n\nbool dfs(int u){\n\tif(vis[u])return false;\n\tvis[u]=1;\n\tfor(int i=1;i<=n;++i)if(g[u][i]){\n\t\tif(!match[i]||dfs(match[i])){\n\t\t\tmatch[i]=u;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\nvoid solve(){\n\tinit();\n\tcin>>n;\n\tfor(int i=1;i<=n;++i){cin>>a[i];s[a[i]]=1;}\n\tfor(int i=1;i<maxn;++i){\n\t\tif(s[i]!=s[i-1])b[++m]=i;\n\t}\n\tfor(int i=1;i<=m;++i){\n\t\tif(b[i]&1)b1[++p1]=b[i];\n\t\telse b2[++p2]=b[i];\n\t}\n\t//cerr<<p1<<\" \"<<p2<<endl;\n\tfor(int i=1;i<=p1;++i){\n\t\tfor(int j=1;j<=p2;++j){\n\t\t\tif(!np[abs(b1[i]-b2[j])]){\n\t\t\t\tg[i][j]=true;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor(int i=1;i<=p1;++i){\n\t\tif(!match[i]){\n\t\t\tmemset(vis,0,sizeof vis);\n\t\t\tif(dfs(i))++ans;//match()\n\t\t}\n\t}\n\tp1-=ans;p2-=ans;\n\t//cerr<<ans<<endl;\n\tans+=p1/2*2+p2/2*2;\n\tans+=p1%2*3;\n\tcout<<ans<<endl;\n}\nint main(){\n\tsolve();\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<cstdio>\n#include<cstring>\nusing namespace std;\nconst int N=1e7+5;\nint n,x,ans,t[N+5],p[4500005],b[205][205],d1[205],d2[205],s[205];\nbool bz[N+5],v[205];\nbool dg(int x)\n{\n\tfor (int i=1;i<=d2[0];i++)\n\tif (b[x][i] && !v[i])\n\t{\n\t\tv[i]=1;\n\t\tif (!s[i] || dg(s[i]))\n\t\t{\n\t\t\ts[i]=x;\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<=n;i++) scanf(\"%d\",&x),bz[x]=1;\n\tfor (int i=1;i<=N;i++) \n\tif (bz[i]^bz[i-1]) \n\t{\n\t\tif (i&1) d1[++d1[0]]=i; \n\t\t\telse d2[++d2[0]]=i;\n\t}\n\tmemset(bz,0,sizeof(bz));\n\tbz[1]=1;\n\tfor (int i=2;i<=N;i++)\n\t{\n\t\tif (!bz[i]) p[++p[0]]=i;\n\t\tfor (int j=1;j<=p[0] && i*p[j]<=N;j++)\n\t\t{\n\t\t\tbz[i*p[j]]=1;\n\t\t\tif (i%p[j]==0) break;\n\t\t}\n\t}\n\tfor (int i=1;i<=d1[0];i++)\n\t\tfor (int j=1;j<=d2[0];j++)\n\t\tif (!bz[abs(d1[i]-d2[j])]) b[i][j]=1;\n\tfor (int i=1;i<=d1[0];i++)\n\t{\n\t\tmemset(v,0,sizeof(v));\n\t\tif (dg(i)) ans++;\n\t}\n\td1[0]-=ans,d2[0]-=ans;\n\tans+=d1[0]/2*2+d2[0]/2*2+d1[0]%2*3;\n\tprintf(\"%d\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <cstdio>\n#include <algorithm>\nusing namespace std;\n\nconst int MAXN = int(1E7) + 5;\nconst int MAXM = 100;\n\nbool nprm[MAXN + 5];\nint prm[MAXN + 5], pcnt;\nvoid init() {\n\tnprm[1] = true;\n\tfor(int i=2;i<=MAXN;i++) {\n\t\tif( !nprm[i] ) prm[++pcnt] = i;\n\t\tfor(int j=1;prm[j]<=MAXN/i;j++) {\n\t\t\tnprm[i*prm[j]] = true;\n\t\t\tif( i % prm[j] == 0 ) break;\n\t\t}\n\t}\n}\n\nint a[MAXN + 5], b[2][MAXM + 5], cnt[2];\n\nint G[MAXM + 5][MAXM + 5], lnk[MAXM + 5];\nbool vis[MAXM + 5];\nbool dfs(int x) {\n\tfor(int i=1;i<=cnt[1];i++) {\n\t\tif( !vis[i] && G[x][i] ) {\n\t\t\tvis[i] = true;\n\t\t\tif( !lnk[i] || dfs(lnk[i]) ) {\n\t\t\t\tlnk[i] = x;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\nint abs(int x) {return x >= 0 ? x : -x;}\nint main() {\n\tinit();\n\tint N; scanf(\"%d\", &N);\n\tfor(int i=1;i<=N;i++) {\n\t\tint x; scanf(\"%d\", &x);\n\t\ta[x] = 1;\n\t}\n\tfor(int i=1;i<=MAXN;i++)\n\t\tif( a[i] != a[i-1] ) b[i%2][++cnt[i%2]] = i;\n\tint ans = 0;\n\tfor(int i=1;i<=cnt[0];i++)\n\t\tfor(int j=1;j<=cnt[1];j++)\n\t\t\tG[i][j] = (!nprm[abs(b[0][i] - b[1][j])]);\n\tfor(int i=1;i<=cnt[0];i++) {\n\t\tfor(int j=1;j<=cnt[1];j++) vis[j] = false;\n\t\tif( dfs(i) ) ans++;\n\t}\n\tans += (cnt[0]/2*2 - ans) + (cnt[1]/2*2 - ans);\n\tif( cnt[0] & 1 ) ans += 3;\n\tprintf(\"%d\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <algorithm>\n#include <vector>\nusing std::vector;\nconst int maxn = 205;\nconst int maxm = 1e7+5;\nint n, m;\nint a[maxn], b[maxm], x[maxm], vis1[maxn], vis2[maxn];\nint is_prime[maxm], prime[maxm], cnt;\nvector<int> to[maxn];\nint X[maxn], Y[maxn], cnt1, cnt2;\nvoid pre() {\n    scanf(\"%d\", &n);\n    for(int i = 1; i <= n; i++) {\n\tscanf(\"%d\", &a[i]);\n\tm = std::max(m, a[i]);\n\tx[a[i]] = 1;\n    }\n    m++;\n    for(int i = 1; i <= m; i++) {\n\tb[i] = x[i] ^ x[i-1];\n\tif(b[i] == 1) {\n\t    if(i & 1) X[++cnt1] = i;\n\t    else Y[++cnt2] = i;\n\t}\n    }\n} \nvoid add_edge(int u, int v) {\n    to[u].push_back(v);\n}\nvoid add(int u, int v) {\n    add_edge(u, v);\n    add_edge(v, u);\n}\nvoid build_graph() {\n    for(int i = 1; i <= cnt1; i++) \n       for(int j = 1; j <= cnt2; j++) \n\t    if(is_prime[abs(X[i] - Y[j])]) add(i, j + n); \n}\nvoid shake(int n) {\n    for(int i = 2; i <= n; i++) {\n\tif(!is_prime[i]) prime[++cnt] = i;\n\tfor(int j = 1; j <= cnt && i * prime[j] <= n; j++) {\n\t    is_prime[i * prime[j]] = 1;\n\t    if((i % prime[j]) == 0) break;\n\t}\n    }\n}\nbool dfs(int x) {\n    for(int i = 0; i < to[x].size(); i++) {\n\tint v = to[x][i];\n\tif(!vis2[v]) {\n\t    vis2[v] = 1;\n\t    if(vis1[v] == 0 || dfs(vis1[v])) {\n\t\tvis1[x] = v;\n\t\tvis1[v] = x;\n\t\treturn true;\n\t    }\n\t}\n    }\n    return false;\n}\nint bi() {\n    int ans = 0;\n    memset(vis1, -1, sizeof(vis1));\n    for(int i = 1; i <= cnt1; i++) {\n\tif(vis1[i] == -1) {\n\t    memset(vis2, 0, sizeof(vis2));\n\t    if(dfs(i)) ans++;\n\t}\n    }\n    return ans;\n}\nint solve() {\n    shake(m + 1);\n    build_graph();\n    return bi(); \n}\nint main() {\n#ifdef orz\n    freopen(\"input\", \"r\", stdin);\n#endif\n    pre();\n    int k = solve();\n    printf(\"%d\\n\", k + 2 * ((cnt1-k) / 2 + (cnt2-k) / 2) + 3 * ((cnt1-k) % 2));\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<cstring>\nusing namespace std;\nint n;\nint res;\nvector<int>v;\nint lst=-1;\nint match[210];\nint me,mo;\nint mx;\nbool f[10000010];\nvector<int>ok[210];\nint vis[210];\nint prm[1000010];\nint sz;\nint l;\nbool bp(int x,int p)\n{\n\tvis[x]=p;\n\tfor(int i=0;i<ok[x].size();i++)\n\t{\n\t\tint y=ok[x][i];\n\t\tif(vis[y])continue;\n\t\tif(match[y]!=-1 && vis[match[y]]==p)continue;\n\t\tif(match[y]==-1 || bp(match[y],p))\n\t\t{\n\t\t\tmatch[y]=x;\n\t\t\tmatch[x]=y;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint x;\n\t\tscanf(\"%d\",&x);\n\t\tif(x!=lst+1)\n\t\t{\n\t\t\tif(lst+1)v.push_back(lst+1);\n\t\t\tv.push_back(x);\n\t\t}\n\t\tlst=x;\n\t\tmx=lst+1;\n\t}\n\tv.push_back(lst+1);\n\tf[1]=true;\n\tfor(int i=2;i<=mx;i++)\n\t{\n\t\tif(!f[i])prm[++sz]=i;\n\t\tfor(int j=1;j<=sz;j++)\n\t\t{\n\t\t\tif(prm[j]*i>mx)break;\n\t\t\tf[prm[j]*i]=true;\n\t\t\tif(i%prm[j]==0)break;\n\t\t}\n\t}\n\tl=v.size();\n\tfor(int i=0;i<l;i++)\n\t{\n\t\tmatch[i]=-1;\n\t\tif(v[i]&1)mo++;else me++;\n\t\tfor(int j=i+1;j<l;j++)\n\t\t{\n\t\t\tif(v[j]-v[i]!=2 && !f[v[j]-v[i]])\n\t\t\t{\n\t\t\t\tok[i].push_back(j);\n\t\t\t\tok[j].push_back(i);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<l;i++)\n\t{\n\t\tmemset(vis,0,sizeof(vis));\n\t\tif(bp(i,i))res++;\n\t}\n\tprintf(\"%d\",res+((me-res)/2+(mo-res)/2)*2+((me-res)%2)*3);\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "//#pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"Ofast,no-stack-protector\") \n//#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//#pragma GCC optimize(\"unroll-loops\")\n\n#include <bits/stdc++.h>\n\n#define int long long\n#define ll long long\n#define ull unsigned long long\n#define ld long double\n#define rep(i, l, r) for (int i = l; i < r; i++)\n#define repb(i, r, l) for (int i = r; i > l; i--)\n#define sz(a) (int)a.size()\n#define fi first\n#define se second\n#define all(x) x.begin(),x.end()\n#define pb push_back\n#define mp(a, b) make_pair(a, b)\n#define ret(a) {cout << a; exit(0);}\n\nusing namespace std;\n\nmt19937 mrand(random_device{}()); \nconst ll mod=1000000007;\nint rnd(int x) { return mrand() % x;}\nll powmod(ll a,ll b,ll mod) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\n\ntypedef pair < int , int > pii ;\ntypedef pair < long long  , long long > pll ;\n\nconst int N = 200 , K = 501;\nint n , m , k;\nint x[N];\nbool was[N] ;\nint mt[N];\nvector < int > gr[N];\nbool pr(int x){\n\tif(x < 0) x *= -1;\n\tif(x <= 2)\n\t\treturn false;\n\tfor(int i = 2 ; i * i <= x; i++)\n\t\tif(x % i == 0)\t\n\t\t\treturn false;\n\treturn true;\n}\nbool kuhn(int v){\n\tif(was[v])return false;\n\twas[v] = 1;\n\tfor(auto to : gr[v])\n\t\tif(mt[to] == -1 or kuhn(mt[to])){\n\t\t\tmt[to] = v;\n\t\t\treturn true;\n\t\t}\n\treturn false;\n}\nmain(){\n\tios::sync_with_stdio(0); cin.tie(0);cout.tie(0);\n\tcin >> n;\n\tfor(int i = 1;i <= n; i++){\n\t\tcin >> x[i];\n\t}\n\tvector < int > v;\n\tx[0] = -1;\n\tfor(int i = 1 ;i <= n ; i++){\n\t\tif(x[i] != x[i - 1] + 1)\n\t\t\tv.pb(x[i]) ;\n\t\tif(x[i + 1] != x[i] + 1)\n\t\t\tv.pb(x[i] + 1);\t\t\t\n\t}\n/*\tfor(int i = 1; i <= 6 ; i++)\n\t\tcout << tmp[i];\n\tcout << endl;*/\n\tint cnt0 = 0 , cnt1 = 0;\n\tfor(auto i : v){\n\t\tcnt0 += i % 2 == 0,\n\t\tcnt1 += i % 2 == 1;\t\t\n//\t\tcerr << i << '\\n';\n\t}\n//\treturn 0;\n\tfor(int i = 0 ; i < sz(v); i++){\n\t\tfor(int j = i + 1 ; j < sz(v); j++){\n\t\t\tif(pr(v[j] - v[i]))\n\t\t\t\tgr[i].pb(j) , gr[j].pb(i);\n\t\t}\n\t}\t\n\tfor(int i = 0 ;i < sz(v); i++)\n\t\tmt[i] = -1;\n\tfor(int i = 0 ; i < sz(v) ;i++){\n\t\tmemset(was , 0, sizeof(was));\n\t\tkuhn(i);\n\t}\n\tint tot = 0, d0 = 0 , d1 = 0;\n\tfor(int i = 0; i < sz(v) ; i++){\n\t\tif(mt[i] != -1){\n\t\t\ttot++,d0 += i % 2 == 0 , d1 += i % 2 == 1;\n\t\t}\n\t}\n\ttot /= 2;\n\tcerr << tot << ' ' << cnt1 << ' ' << cnt0 << '\\n';\n\tcout << tot + ((cnt0 - tot)/2 + (cnt1 - tot)/2) * 2 + ((cnt0 - tot)%2) * 3;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define IL __inline__ __attribute__((always_inline))\n\n#define For(i, a, b) for (int i = (a), i##end = (b); i <= i##end; ++ i)\n#define FOR(i, a, b) for (int i = (a), i##end = (b); i < i##end; ++ i)\n#define Rep(i, a, b) for (int i = (a), i##end = (b); i >= i##end; -- i)\n#define REP(i, a, b) for (int i = (a) - 1, i##end = (b); i >= i##end; -- i)\n\ntypedef long long LL;\n\ntemplate <class T>\nIL bool chkmax(T &a, const T &b) {\n  return a < b ? ((a = b), 1) : 0;\n}\n\ntemplate <class T>\nIL bool chkmin(T &a, const T &b) {\n  return a > b ? ((a = b), 1) : 0;\n}\n\ntemplate <class T>\nIL T mymax(const T &a, const T &b) {\n  return a > b ? a : b;\n}\n\ntemplate <class T>\nIL T mymin(const T &a, const T &b) {\n  return a < b ? a : b;\n}\n\ntemplate <class T>\nIL T myabs(const T &a) {\n  return a > 0 ? a : -a;\n}\n\nconst int INF = 0X3F3F3F3F;\nconst double EPS = 1E-8, PI = acos(-1.0);\n\n#define DEBUG(...) fprintf(stderr, __VA_ARGS__)\n#define OK DEBUG(\"Passing [%s] in LINE %d...\\n\", __FUNCTION__, __LINE__)\n#define SZ(x) ((int)(x).size())\n\nconst int MAXN = 1000 + 5, MAXM = 10000000 + 5;\n\nstd::pair<int, int> da[MAXN];\nint f[MAXN], pos[MAXN], sum[MAXN], pri[MAXM], val[MAXM], p_cnt;\nbool np[MAXM];\n\nIL void init(int n) {\n  np[1] = 1;\n  For(i, 2, n) {\n    if (!np[i]) {\n      pri[++ p_cnt] = i;\n    }\n    for (int j = 1; j <= p_cnt && pri[j] * i <= n; ++ j) {\n      np[i * pri[j]] = 1;\n      if (i % pri[j] == 0) {\n        break;\n      }\n    }\n  }\n  For(i, 1, n) {\n    val[i] = i % 2 ? 1 + np[i] * 2 : 2;\n  }\n}\n\nint main() {\n  init(10000000);\n  int n;\n  scanf(\"%d\", &n);\n  For(i, 1, n) {\n    scanf(\"%d\", &pos[i]);\n  }\n  std::sort(pos + 1, pos + n + 1);\n  pos[0] = -1;\n  int cnt = 0;\n  For(i, 1, n) {\n    if (pos[i] - pos[i - 1] > 1) {\n      da[++ cnt] = {pos[i], pos[i]};\n    } else {\n      ++ da[cnt].second;\n    }\n  }\n  For(i, 2, cnt) {\n    sum[i] = sum[i - 1] + val[da[i].first - da[i - 1].second - 1];\n  }\n  For(i, 1, cnt) {\n    f[i] = f[i - 1] + val[da[i].second - da[i].first + 1];\n    For(j, 0, i - 2) {\n      chkmin(f[i], f[j] + val[da[i].second - da[j + 1].first + 1] + sum[i] - sum[j]);\n    }\n  }\n  printf(\"%d\\n\", f[cnt]);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<cstring>\nusing namespace std;\nint n;\nint res;\nvector<int>v;\nint lst=-1;\nint match[210];\nint me,mo;\nint mx;\nbool f[10000010];\nvector<int>ok[210];\nbool vis[210];\nint prm[1000010];\nint sz;\nbool bp(int x)\n{\n\tfor(int i=0;i<ok[x].size();i++)\n\t{\n\t\tint y=ok[x][i];\n\t\tif(vis[y])continue;\n\t\tvis[y]=true;\n\t\tif(match[y]==-1 || bp(match[y]))\n\t\t{\n\t\t\tmatch[y]=x;\n\t\t\treturn true;\n\t\t}\n\t\tvis[y]=false;\n\t}\n\treturn false;\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint x;\n\t\tscanf(\"%d\",&x);\n\t\tif(x!=lst+1)\n\t\t{\n\t\t\tif(lst+1)v.push_back(lst+1);\n\t\t\tv.push_back(x);\n\t\t}\n\t\tlst=x;\n\t\tmx=lst+1;\n\t}\n\tv.push_back(lst+1);\n\tf[1]=true;\n\tfor(int i=2;i<=mx;i++)\n\t{\n\t\tif(!f[i])prm[++sz]=i;\n\t\tfor(int j=1;j<=sz && prm[j]*i<=mx;j++)\n\t\t{\n\t\t\tf[prm[j]*i]=true;\n\t\t\tif(i%prm[j]==0)break;\n\t\t}\n\t}\n\tint l=v.size();\n\tfor(int i=0;i<l;i++)\n\t{\n\t\tmatch[i]=-1;\n\t\tif(v[i]&1)mo++;else me++;\n\t\tfor(int j=i+1;j<l;j++)\n\t\t{\n\t\t\tif(v[j]-v[i]!=2 && !f[v[j]-v[i]])\n\t\t\t{\n\t\t\t\tok[i].push_back(j);\n\t\t\t\tok[j].push_back(i);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<l;i++)\n\t{\n\t\tmemset(vis,false,sizeof(vis));\n\t\tif(bp(i))res++;\n\t}\n\tres/=2;\n\tprintf(\"%d\",res+((me-res)/2+(mo-res)/2)*2+((me-res)%2)*3);\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MAXN\t105\n#define MAXP\t405\n#define MAXQ\t1000005\n#define MAXV\t100000005\n#define INF\t1e9\ntemplate <typename T> void read(T &x) {\n\tx = 0; int f = 1;\n\tchar c = getchar();\n\tfor (; !isdigit(c); c = getchar()) if (c == '-') f = -f;\n\tfor (; isdigit(c); c = getchar()) x = x * 10 + c - '0';\n\tx *= f;\n}\nstruct edge {int dest, flow, cost; unsigned home; };\nint s, t, flow, cost, dist[MAXP];\nvector <edge> a[MAXP];\nint n, cnt, value[MAXP], path[MAXP];\nunsigned home[MAXP];\nint tot, f[MAXV], prime[MAXV];\nbool isprime[MAXV], mark[MAXV];\nvoid flow_path() {\n\tint ans = INF, p = t;\n\twhile (p != s) {\n\t\tans = min(ans, a[path[p]][home[p]].flow);\n\t\tp = path[p];\n\t}\n\tflow += ans, cost += ans * dist[t];\n\tp = t;\n\twhile (p != s) {\n\t\ta[path[p]][home[p]].flow -= ans;\n\t\ta[p][a[path[p]][home[p]].home].flow += ans;\n\t\tp = path[p];\n\t}\n}\nbool spfa() {\n\tstatic int q[MAXQ];\n\tstatic bool inq[MAXP];\n\tfor (int i = 1; i <= t; i++)\n\t\tdist[i] = INF;\n\tint l = 0, r = 0;\n\tdist[s] = 0; inq[s] = true; q[0] = s;\n\twhile (l <= r) {\n\t\tint tmp = q[l++];\n\t\tinq[tmp] = false;\n\t\tfor (unsigned i = 0; i < a[tmp].size(); i++)\n\t\t\tif (a[tmp][i].flow && dist[tmp] + a[tmp][i].cost < dist[a[tmp][i].dest]) {\n\t\t\t\tdist[a[tmp][i].dest] = dist[tmp] + a[tmp][i].cost;\n\t\t\t\tpath[a[tmp][i].dest] = tmp;\n\t\t\t\thome[a[tmp][i].dest] = i;\n\t\t\t\tif (!inq[a[tmp][i].dest]) {\n\t\t\t\t\tinq[a[tmp][i].dest] = true;\n\t\t\t\t\tq[++r] = a[tmp][i].dest;\n\t\t\t\t}\n\t\t\t}\n\t}\n\treturn dist[t] != INF;\n}\nvoid addedge(int s, int t, int f, int c) {\n\ta[s].push_back((edge) {t, f, c, a[t].size()});\n\ta[t].push_back((edge) {s, 0, -c, a[s].size() - 1});\n}\nint main() {\n\tread(n);\n\tfor (int i = 1; i <= n; i++) {\n\t\tint x; read(x);\n\t\tmark[x] ^= true;\n\t\tmark[x + 1] ^= true;\n\t}\n\tfor (int i = 1; i < MAXV; i++)\n\t\tif (mark[i]) value[++cnt] = i;\n\tfor (int i = 2; i < MAXV; i++) {\n\t\tif (f[i] == i) {\n\t\t\tf[i] = i;\n\t\t\tprime[++tot] = i;\n\t\t\tisprime[i] = true;\n\t\t}\n\t\tfor (int j = 1; j <= tot && prime[j] <= f[i]; j++) {\n\t\t\tint tmp = prime[j] * i;\n\t\t\tif (tmp >= MAXV) break;\n\t\t\tf[tmp] = prime[j];\n\t\t}\n\t}\n\ts = 0, t = cnt * 2 + 1;\n\tfor (int i = 1; i <= cnt; i++) {\n\t\taddedge(s, i, 1, 0);\n\t\taddedge(i + cnt, t, 1, 0);\n\t}\n\tfor (int i = 1; i <= cnt; i++)\n\tfor (int j = i + 1; j <= cnt; j++) {\n\t\tint tmp = value[j] - value[i];\n\t\tif (tmp % 2 == 0) {\n\t\t\taddedge(i, j + cnt, 1, 2);\n\t\t\taddedge(j, i + cnt, 1, 2);\n\t\t} else if (isprime[tmp]) {\n\t\t\taddedge(i, j + cnt, 1, 1);\n\t\t\taddedge(j, i + cnt, 1, 1);\n\t\t} else {\n\t\t\taddedge(i, j + cnt, 1, 3);\n\t\t\taddedge(j, i + cnt, 1, 3);\n\t\t}\n\t}\n\tflow = 0, cost = 0;\n\twhile (spfa())\n\t\tflow_path();\n\tcout << cost / 2 << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int maxn=205;\nconst int maxm=10000005;\nconst int INF=0x3f3f3f;\n\nint n;\nint c[maxm];\nint p1[maxn],tot1=0,p2[maxn],tot2=0,nn;\n\nstruct Edge\n{\n    int from,to,capa,flow,nxt;\n}e[maxn*maxn];\n\nint h[maxn],tot=-1;\n\ninline void addedge(int a,int b,int c) { e[++tot].from=a; e[tot].to=b; e[tot].capa=c; e[tot].flow=0; e[tot].nxt=h[a]; h[a]=tot; }\n\nbool check(int p)\n{\n    if (p==1) return 0;\n    for (int i=2;i*i<=p;i++) if (p%i==0) return 0;\n    return 1;\n}\n\nint s,t,d[maxn],cur[maxn],vis[maxn];\n\nint dfs(int p,int a)\n{\n    if (p==t || !a) return a;\n    int flow=0,f;\n    for (int &i=cur[p];~i;i=e[i].nxt)\n    if (d[e[i].to]==d[p]+1 && e[i].capa>e[i].flow)\n    {\n        f=dfs(e[i].to,min(a,e[i].capa-e[i].flow));\n        if (f)\n        {\n            flow+=f; a-=f;\n            e[i].flow+=f; e[i^1].flow-=f;\n        }\n        if (!a) break;\n    }\n    return flow;\n}\n\nint bfs()\n{\n    queue<int> q;\n    memset(vis,0,sizeof(vis));\n    q.push(s); vis[s]=1; d[s]=0;\n    while (!q.empty())\n    {\n        int o=q.front(); q.pop();\n        for (int i=h[o];~i;i=e[i].nxt)\n        if (!vis[e[i].to] && e[i].capa>e[i].flow)\n        {\n            vis[e[i].to]=1; q.push(e[i].to);\n            d[e[i].to]=d[o]+1;\n        }\n    }\n    return vis[t];\n}\n\nint Dinic()\n{\n    int flow=0;\n    while (bfs())\n    {\n        //cout<<\"GG\";\n        for (int i=1;i<=nn;i++) cur[i]=h[i];\n        flow+=dfs(s,INF);\n    }\n    return flow;\n}\n\nint main()\n{\n    scanf(\"%d\",&n);\n    int tmp,mx=0;\n    for (int i=1;i<=n;i++) { scanf(\"%d\",&tmp); mx=max(mx,tmp); c[tmp]=1; } mx++;\n    //for (int i=mx;i>=1;i--) c[i]=c[i-1]^c[i];\n    //for (int i=1;i<=mx;i++) cout<<c[i];\n    for (int i=1;i<=mx;i++)\n    if (c[i]!=c[i-1])\n    {\n        if (i&1) p1[++tot1]=i;\n            else p2[++tot2]=i;\n    }\n    nn=tot1+tot2+1; s=0; t=nn;\n    //cout<<nn<<endl;\n    memset(h,-1,sizeof(h));\n    for (int i=1;i<=tot1;i++) { addedge(s,i,1); addedge(i,s,0); }\n    for (int i=1;i<=tot2;i++) { addedge(i+tot1,t,1); addedge(t,i+tot1,0); }\n    for (int i=1;i<=tot1;i++)\n        for (int j=1;j<=tot2;j++)\n            if (check(abs(p2[j]-p1[i]))) { addedge(i,i+tot1,1); addedge(i+tot1,i,0); }\n    int flow=Dinic(),ans=0;\n    //cout<<\"GG\";\n    ans=flow;\n    ans+=(tot1-flow)/2*2+(tot2-flow)/2*2;\n    ans+=((tot1-flow)&1)*3;\n    cout<<ans;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\nusing namespace std;\nusing lint = long long;\nusing pi = pair<int, int>;\n\nconst int MAXN = 205, MAXM = 205;\nstruct bpm{\n\tvector<int> gph[MAXN];\n\tint dis[MAXN], l[MAXN], r[MAXM], vis[MAXN];\n\tvoid clear(){ for(int i=0; i<MAXN; i++) gph[i].clear();\t}\n\tvoid add_edge(int l, int r){ gph[l].push_back(r); }\n\tbool bfs(int n){\n\t\tqueue<int> que;\n\t\tbool ok = 0;\n\t\tmemset(dis, 0, sizeof(dis));\n\t\tfor(int i=0; i<n; i++){\n\t\t\tif(l[i] == -1 && !dis[i]){\n\t\t\t\tque.push(i);\n\t\t\t\tdis[i] = 1;\n\t\t\t}\n\t\t}\n\t\twhile(!que.empty()){\n\t\t\tint x = que.front();\n\t\t\tque.pop();\n\t\t\tfor(auto &i : gph[x]){\n\t\t\t\tif(r[i] == -1) ok = 1;\n\t\t\t\telse if(!dis[r[i]]){\n\t\t\t\t\tdis[r[i]] = dis[x] + 1;\n\t\t\t\t\tque.push(r[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn ok;\n\t}\n\tbool dfs(int x){\n\t\tfor(auto &i : gph[x]){\n\t\t\tif(r[i] == -1 || (!vis[r[i]] && dis[r[i]] == dis[x] + 1 && dfs(r[i]))){\n\t\t\t\tvis[r[i]] = 1; l[x] = i; r[i] = x;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tint match(int n){\n\t\tmemset(l, -1, sizeof(l));\n\t\tmemset(r, -1, sizeof(r));\n\t\tint ret = 0;\n\t\twhile(bfs(n)){\n\t\t\tmemset(vis, 0, sizeof(vis));\n\t\t\tfor(int i=0; i<n; i++) if(l[i] == -1 && dfs(i)) ret++;\n\t\t}\n\t\treturn ret;\n\t} \n}bpm;\n\nint n, a[MAXN];\nmap<int, int> mp;\n\nbool isprime(int x){\n\tif(x == 1) return 0;\n\tfor(int i=2; i*i<=x; i++){\n\t\tif(x % i == 0) return 0;\n\t}\n\treturn 1;\n}\n\nint main(){\n\tcin >> n;\n\tfor(int i=0; i<n; i++){\n\t\tint x; cin >> x;\n\t\tmp[x] ^= 1;\n\t\tmp[x + 1] ^= 1;\n\t}\n\tvector<int> l, r;\n\tfor(auto &i : mp){\n\t\tif(i.second){\n\t\t\tif(i.first & 1) l.push_back(i.first);\n\t\t\telse r.push_back(i.first);\n\t\t}\n\t}\n\tfor(int i=0; i<l.size(); i++){\n\t\tfor(int j=0; j<r.size(); j++){\n\t\t\tif(isprime(abs(r[j] - l[i]))){\n\t\t\t\tbpm.add_edge(i, j);\n\t\t\t}\n\t\t}\n\t}\n\tint m = bpm.match(l.size());\n\tint ans = 1e8;\n\tfor(int i=0; i<=m; i++){\n\t\tint ll = l.size() - i;\n\t\tint rl = r.size() - i;\n\t\tans = min(ans, i + (ll / 2 + rl / 2) * 2 + (ll % 2) * 3);\n\t}\n\tcout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n\n#include <iostream>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <unordered_set>\n#include <queue>\n#include <set>\n#include <algorithm>\n#include <numeric>\n#include <list>\nusing namespace std;\n\nusing QWORD  = uint64_t;\nusing SQWORD = int64_t;\nusing DWORD  = uint32_t;\nusing SDWORD = int32_t;\nusing WORD   = uint16_t;\nusing SWORD  = int16_t;\nusing BYTE   = uint8_t;\nusing SBYTE  = int8_t;\nusing DOUBLE = double;\nusing FLOAT  = float;\n\n#define MIN_SDWORD (-2147483648)\n#define MAX_SDWORD (2147483647)\n#define MIN_SBYTE (-128)\n#define MAX_SBYTE (127)\n\n#define MIN_SQWORD (0x8000000000000000)\n#define MAX_SQWORD (0x7FFFFFFFFFFFFFFF)\n\n#define MAX_QWORD  (0xFFFFFFFFFFFFFFFF)\n#define MAX_DWORD  (0xFFFFFFFF)\n#define MAX_WORD   (0xFFFF)\n#define MAX_BYTE   (0xFF)\n\n#define MAX_DOUBLE      (1.0e+308)\n#define DOUBLE_EPS      (1.0e-12)\n#define MIN_DOUBLE_N    (-1.0e+308)\n\n#define ArrayLength(a)  (sizeof(a) / sizeof(a[0]))\n\nstatic inline DOUBLE MAX(DOUBLE a, DOUBLE b) { return a > b ? a : b; }\nstatic inline QWORD MAX(QWORD a, QWORD b) { return a > b ? a : b; }\nstatic inline DWORD MAX(DWORD a, DWORD b) { return a > b ? a : b; }\nstatic inline SDWORD MAX(SDWORD a, SDWORD b) { return a > b ? a : b; }\nstatic inline DOUBLE MIN(DOUBLE a, DOUBLE b) { return a < b ? a : b; }\nstatic inline QWORD MIN(QWORD a, QWORD b) { return a < b ? a : b; }\nstatic inline DWORD MIN(DWORD a, DWORD b) { return a < b ? a : b; }\nstatic inline SDWORD MIN(SDWORD a, SDWORD b) { return a < b ? a : b; }\nstatic inline DOUBLE ABS(DOUBLE a) { return 0 < a ? a : -a; };\n\n#define BYTE_BITS   (8)\n#define WORD_BITS   (16)\n#define DWORD_BITS  (32)\n#define QWORD_BITS  (64)\n\nstatic inline void inputStringSpSeparated(char *pcStr)\n{\n    char *pcCur = pcStr;\n    for (;;) {\n        char c = getchar();\n        if (('\\n' == c) || (EOF == c) || (' ' == c)) {\n            break;\n        }\n        *pcCur = c;\n        pcCur++;\n    }\n    *pcCur = '\\0';\n}\n\nstatic inline void inputString(char *pcStr)\n{\n    char *pcCur = pcStr;\n    for (;;) {\n        char c = getchar();\n        if (('\\n' == c) || (EOF == c)) {\n            break;\n        }\n        *pcCur = c;\n        pcCur++;\n    }\n    *pcCur = '\\0';\n}\n\n\nstatic inline SQWORD inputSQWORD(void)\n{\n    SQWORD sqNumber = 0;\n    SQWORD sqMultiplier = 1;\n    bool bRead = false;\n    for (;;) {\n        char c = getchar();\n        if (!bRead) {\n            if ('-' == c) {\n                sqMultiplier = -1;\n            }\n        }\n        if (('0' <= c) && (c <= '9')) {\n            sqNumber *= 10LL;\n            sqNumber += (SQWORD)(c - '0');\n            bRead = true;\n        } else {\n            if (bRead) {\n                return sqNumber * sqMultiplier;\n            }\n        }\n    }\n}\n\n\nstatic inline SDWORD inputSDWORD(void)\n{\n    SDWORD lNumber = 0;\n    SDWORD lMultiplier = 1;\n    bool bRead = false;\n    for (;;) {\n        char c = getchar();\n        if (!bRead) {\n            if ('-' == c) {\n                lMultiplier = -1;\n            }\n        }\n        if (('0' <= c) && (c <= '9')) {\n            lNumber *= 10;\n            lNumber += (c - '0');\n            bRead = true;\n        } else {\n            if (bRead) {\n                return lNumber * lMultiplier;\n            }\n        }\n    }\n}\n\nstatic inline DOUBLE inputFP(void)\n{\n    DOUBLE dInt = 0.0;\n    DOUBLE dFrac = 0.0;\n    DOUBLE dMultiplier = 1.0;\n    DWORD dwFpCnt = 0;\n    DOUBLE *pdCur = &dInt;\n    bool bRead = false;\n    for (;;) {\n        char c = getchar();\n        if (!bRead) {\n            if ('-' == c) {\n                dMultiplier = -1;\n            }\n        }\n        if ('.' == c) {\n            pdCur = &dFrac;\n        } else if (('0' <= c) && (c <= '9')) {\n            (*pdCur) *= 10;\n            (*pdCur) += (DOUBLE)(c - '0');\n            bRead = true;\n            if (pdCur == &dFrac) {\n                dwFpCnt++;\n            }\n        } else {\n            if (bRead) {\n                return dMultiplier * (dInt + dFrac / (pow((DOUBLE)10.0 , (DOUBLE)dwFpCnt)));\n            }\n        }\n    }\n}\n\n\n/**\n *  mod による操作ライブラリ\n */\n\n#define ANS_MOD (1000000007LL)\n \nstatic SQWORD addMod(SQWORD x, SQWORD y)\n{ \n    return (x + y) % ANS_MOD;\n}\n \nstatic SQWORD subMod(SQWORD x, SQWORD y)\n{\n    return (x - y + ANS_MOD) % ANS_MOD;\n}\n \nstatic SQWORD mulMod(SQWORD x, SQWORD y) \n{\n    return (x * y) % ANS_MOD;\n}\n \nstatic SQWORD powMod(SQWORD x, SQWORD e) {\n    SQWORD v = 1;\n    for (; e; x = mulMod(x, x), e >>= 1) {\n        if (e & 1) {\n            v = mulMod(v, x);\n        }\n    }\n    return v;\n}\n \nstatic SQWORD divMod(SQWORD x, SQWORD y)\n{\n    return mulMod(x, powMod(y, ANS_MOD - 2));\n}\n \n \nstatic SQWORD combMod(SQWORD n, SQWORD k)\n{\n    SQWORD v=1;\n    for(SQWORD i=1; i<=k; i++) {\n        v = divMod(mulMod(v, n-i+1),i);\n    } \n    return v;\n}\n\n/*----------------------------------------------*/\n\n#define MAX_V   (500)\n#define INF 2e9\n\n/* 辺を表す構造体 */\nstruct edge {int to, cap ,rev; };\n \n/* グラフの隣接リスト表現 */\nvector<edge> G[MAX_V];\n/* DFSですべに調べたかのグラフ */\nbool used[MAX_V];\n \n/* fromからtoへ向かう容量capの辺をグラフに追加する */\n/* 相互参照できるようにしている */\nvoid add_edge(int from, int to, int cap){\n    G[from].push_back((edge){to, cap, (int)G[to].size()});\n    G[to].push_back((edge){from, 0, (int)G[from].size() - 1});    \n}\n \n/* 増加パスをdfsで探す */\nint dfs(int v, int t, int f){\n    if(v==t) return f;\n    used[v] = true;\n    for(int i=0; i<G[v].size(); i++){\n        edge &e = G[v][i];\n        if(!used[e.to] && e.cap>0){\n            int d = dfs(e.to, t, min(f, e.cap));\n            if(d>0){\n                e.cap -= d;\n                G[e.to][e.rev].cap += d;\n                return d;\n            }\n        }\n    }\n    return 0;\n}\n \nint max_flow(int s, int t){\n    int flow = 0;\n    for(;;){\n        memset(used, 0, sizeof(used));\n        int f = dfs(s, t, INF);\n        if(f==0) return flow;\n        flow += f;\n    }\n}\n/*----------------------------------------------*/\n\nclass PrimeTable {\n    vector<bool> vbIsPrime;\n\npublic:\n    PrimeTable(SDWORD lMax) {\n        /* lSearchMax と ループ内の *2 の関係から、入力は3以上とすること */\n        if (!(1 <= lMax)) {\n            printf(\"Oops!\");\n            return;\n        }\n\n        /* 素数のリストを作る */\n        vbIsPrime.resize(lMax + 1, true);\n        SDWORD lSearchMax = sqrt(lMax) + 1;\n        vbIsPrime[0] = false;\n        vbIsPrime[1] = false;\n        for (SDWORD lPrime = 2; lPrime < lSearchMax; lPrime++) {\n            if (vbIsPrime[lPrime]) {\n                for (SDWORD lCurNum = lPrime * 2; lCurNum <= lMax; lCurNum += lPrime) {\n                    vbIsPrime[lCurNum] = false;\n                }\n            }\n        }\n    };\n\n    bool IsPrime(SQWORD sqN)\n    {\n        return vbIsPrime[sqN];\n    }\n};\n\n\n/*----------------------------------------------*/\n\n#define PNT_NO_START    (0)\n#define PNT_NO_OFFSET   (200)\n#define PNT_NO_TARGET   (401)\n#define FLOW_OFFSET     (1000000000)\n#define CAPACITY_INF    (1000000001)\n#define DUMMY_COST      (1)\n\nint main(void)\n{\n    SQWORD sqN = inputSQWORD();\n\n    vector<SQWORD> vsqA;\n    vector<SQWORD> vsqB;\n\n    PrimeTable prime(1e7 + 1);\n \n    map<SQWORD, SQWORD> mapB;\n\n    for (SQWORD sqIdx = 0; sqIdx < sqN; sqIdx++) {\n        SQWORD sqA = inputSQWORD();\n        vsqA.emplace_back(sqA);\n\n        mapB[sqA] ^= 1;\n        mapB[sqA + 1] ^= 1;\n    }\n\n    vector<SQWORD> vsqBEven, vsqBOdd;\n\n    for (auto b: mapB) {\n        if (0 < b.second) {\n            if (0 == (b.first % 2)) {\n                vsqBEven.emplace_back(b.first);\n            } else {\n                vsqBOdd.emplace_back(b.first);\n            }\n        }\n    }\n\n    SQWORD sqNodeEven = 0;\n    for (auto e: vsqBEven) {\n        SQWORD sqNodeOdd = 0;\n        for (auto o: vsqBOdd) {\n            if (prime.IsPrime(abs(e - o))) {\n                add_edge(sqNodeOdd, sqNodeOdd + PNT_NO_OFFSET, 1);\n            }\n            sqNodeOdd++;\n        }\n        sqNodeEven++;\n    }\n    for (SQWORD sqIdx = 1; sqIdx < vsqBEven.size(); sqIdx++) {\n        add_edge(PNT_NO_START, sqIdx, 1);\n    }\n    for (SQWORD sqIdx = 1; sqIdx < vsqBOdd.size(); sqIdx++) {\n        add_edge(sqIdx + PNT_NO_OFFSET, PNT_NO_TARGET, 1);\n    }\n\n\n\n    SQWORD sqMaxFlow = max_flow(PNT_NO_START, PNT_NO_TARGET);\n    SQWORD vsqCRestEven = vsqBEven.size() - sqMaxFlow;\n    SQWORD vsqCRestOdd  = vsqBOdd.size() - sqMaxFlow;\n\n    SQWORD sqAns = sqMaxFlow;    \n    sqAns += ((vsqCRestEven / 2) * 2);\n    sqAns += ((vsqCRestOdd / 2) * 2);\n    if (0 < (vsqCRestEven %  2)) {\n        sqAns += 3;\n    }\n\n    printf(\"%lld\\n\", sqAns);\n\n    return 0;\n}\n/*------------------------------------------*/\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define IL __inline__ __attribute__((always_inline))\n\n#define For(i, a, b) for (int i = (a), i##end = (b); i <= i##end; ++ i)\n#define FOR(i, a, b) for (int i = (a), i##end = (b); i < i##end; ++ i)\n#define Rep(i, a, b) for (int i = (a), i##end = (b); i >= i##end; -- i)\n#define REP(i, a, b) for (int i = (a) - 1, i##end = (b); i >= i##end; -- i)\n\ntypedef long long LL;\n\ntemplate <class T>\nIL bool chkmax(T &a, const T &b) {\n  return a < b ? ((a = b), 1) : 0;\n}\n\ntemplate <class T>\nIL bool chkmin(T &a, const T &b) {\n  return a > b ? ((a = b), 1) : 0;\n}\n\ntemplate <class T>\nIL T mymax(const T &a, const T &b) {\n  return a > b ? a : b;\n}\n\ntemplate <class T>\nIL T mymin(const T &a, const T &b) {\n  return a < b ? a : b;\n}\n\ntemplate <class T>\nIL T myabs(const T &a) {\n  return a > 0 ? a : -a;\n}\n\nconst int INF = 0X3F3F3F3F;\nconst double EPS = 1E-8, PI = acos(-1.0);\n\n#define DEBUG(...) fprintf(stderr, __VA_ARGS__)\n#define OK DEBUG(\"Passing [%s] in LINE %d...\\n\", __FUNCTION__, __LINE__)\n#define SZ(x) ((int)(x).size())\n\nconst int MAXN = 2000 + 5, MAXM = 10000000 + 5, MAXK = 1000000 + 5;\n\nint pri[MAXM], val[MAXM], p_cnt;\nbool np[MAXM];\n\nIL void init(int n) {\n  np[1] = 1;\n  For(i, 2, n) {\n    if (!np[i]) {\n      pri[++ p_cnt] = i;\n    }\n    for (int j = 1; j <= p_cnt && pri[j] * i <= n; ++ j) {\n      np[i * pri[j]] = 1;\n      if (i % pri[j] == 0) {\n        break;\n      }\n    }\n  }\n  For(i, 1, n) {\n    val[i] = i % 2 ? 1 + np[i] * 2 : 2;\n  }\n}\n\nint pos[MAXN];\nbool ok[MAXM];\nstd::vector<int> dpos[2];\n\nnamespace NetworkFlow {\nint s, t;\n\nstruct Edge {\n  int from, to, resi;\n\n  Edge() {}\n  Edge(int _f, int _t, int _c) : from(_f), to(_t), resi(_c) {}\n} edges[MAXM * 2];\n\nstd::vector<int> adj[MAXN];\nint cnt;\n\nIL void addEdge(int u, int v, int c) {\n  edges[cnt] = Edge(u, v, c), adj[u].push_back(cnt);\n  ++ cnt;\n  edges[cnt] = Edge(v, u, 0), adj[v].push_back(cnt);\n  ++ cnt;\n}\n\nint dist[MAXN], cur[MAXN];\n\nIL bool BFS() {\n  static int que[MAXN], vis[MAXN], num;\n  ++ num;\n  int l = 1, r = 0;\n  que[++ r] = s, dist[s] = 0, vis[s] = num;\n  while (l <= r) {\n    int u = que[l ++];\n    FOR(k, 0, SZ(adj[u])) {\n      Edge &e = edges[adj[u][k]];\n      if (vis[e.to] != num && e.resi)\n        que[++ r] = e.to, dist[e.to] = dist[u] + 1, vis[e.to] = num;\n    }\n  }\n  return vis[t] == num;\n}\n\nint DFS(int u, int x) {\n  if (!x || u == t) {\n    return x;\n  }\n  int flow = 0, f;\n  for (int &k = cur[u]; k < SZ(adj[u]); ++ k) {\n    Edge &e = edges[adj[u][k]];\n    if (dist[e.to] == dist[u] + 1 && (f = DFS(e.to, mymin(x, e.resi)))) {\n      edges[adj[u][k]].resi -= f, edges[adj[u][k] ^ 1].resi += f;\n      flow += f, x -= f;\n      if (!x)\n        break;\n      }\n  }\n  return flow;\n}\n\nIL int dinic() {\n  int flow = 0;\n  while (BFS()) {\n    memset(cur, 0, sizeof cur);\n    flow += DFS(s, INF);\n  }\n  return flow;\n}\n\nIL int solve() {\n  int x = SZ(dpos[0]), y = SZ(dpos[1]);\n  s = x + y + 1, t = x + y + 2;\n  FOR(i, 0, x) {\n    FOR(j, 0, y) {\n      if (!np[myabs(dpos[0][i] - dpos[1][j])]) {\n        addEdge(i + 1, j + 1 + x, 1);\n      }\n    }\n  }\n  For(i, 1, x) {\n    addEdge(s, i, 1);\n  }\n  For(i, 1, y) {\n    addEdge(i + x, t, 1);\n  }\n  return dinic();\n}\n}\n\nint main() {\n  init(10000000);\n  int n;\n  scanf(\"%d\", &n);\n  For(i, 1, n) {\n    scanf(\"%d\", &pos[i]);\n    ok[pos[i]] = 1;\n  }\n  For(i, 1, 10000001) {\n    if (ok[i] ^ ok[i - 1]) {\n      dpos[i % 2].push_back(i);\n    }\n  }\n  int k = NetworkFlow::solve(), x = (SZ(dpos[0]) - k) / 2, y = (SZ(dpos[1]) - k) / 2;\n  printf(\"%d\\n\", k + (x + y) * 2 + (SZ(dpos[0]) - k) % 2 * 3);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#define fo(i,a,b) for(int i=a;i<=b;i++)\n#define fd(i,b,a) for(int i=b;i>=a;i--)\n#define efo(i,u,v) for(int i=BB[u],v=B[BB[u]][1];i;v=B[i=B[i][0]][1])\n#define mset(a,x) memset(a,x,sizeof(a))\nusing namespace std;\ntypedef long long ll;\nchar ch;\nint read(){int n=0,p=1;for(ch=getchar();ch<'0' || '9'<ch;ch=getchar())if(ch=='-') p=-1;for(;'0'<=ch && ch<='9';ch=getchar()) n=n*10+ch-'0';return n*p;}\nconst int N=205,M=2e7+5;\nint n,m,a[N],d[N<<1],pr[M];\nbool b[M],c[M],bz[M];\nvoid prep()\n{\n\tmset(bz,1);\n\tbz[0]=bz[1]=0;\n\tfo(i,2,m)\n\t{\n\t\tif(bz[i]) pr[++pr[0]]=i;\n\t\tfo(j,1,pr[0])\n\t\t{\n\t\t\tll x=(ll)i*pr[j];\n\t\t\tif(x>m) break;\n\t\t\tbz[x]=0;\n\t\t\tif(i%pr[j]==0) break;\n\t\t}\n\t}\n}\n\nconst int V=N<<2,INF=1e9;\nconst int E=4*V*V;\nint ans,B0,S,T,BB[V],dis[V],B[E][4];\nbool vis[V];\nvoid link(int u,int v,int r,int w)\n{\n\tB[++B0][1]=v,B[B0][2]=r,B[B0][3]=w,B[B0][0]=BB[u],BB[u]=B0;\n\tif(!(B0&1)) link(v,u,0,-w);\n}\nint aug(int v,int flow)\n{\n\tvis[v]=1;\n\tif(v==T) \n\t{\n\t\tans+=dis[S]*flow;\n\t\treturn flow;\n\t}\n\tefo(i,v,u)\n\t\tif(B[i][2] && !vis[u] && dis[v]==dis[u]+B[i][3])\n\t\t{\n\t\t\tint f=aug(u,min(flow,B[i][2]));\n\t\t\tif(f)\n\t\t\t{\n\t\t\t\tB[i][2]-=f,B[i^1][2]+=f;\n\t\t\t\treturn f;\n\t\t\t}\n\t\t}\n\treturn 0;\n}\nbool change()\n{\n\tint minh=INF;\n\tfo(u,S,T) if(vis[u])\n\t\tefo(i,u,v) if(!vis[v])\n\t\t\tif(B[i][2]) minh=min(minh,dis[v]+B[i][3]-dis[u]);\n\tif(minh==INF) return 0;\n\tfo(i,S,T) if(vis[i]) dis[i]+=minh;\n\tmset(vis,0);\n\treturn 1;\n}\nint main()\n{\n\tn=read();\n\tfo(i,1,n) b[a[i]=read()]=1,m=max(m,a[i]);\n\t++m;\n\tprep();\n\tfo(i,1,m) c[i]=b[i]^b[i-1];\n\tfo(i,1,m) if(c[i]) d[++d[0]]=i;\n\t\n\tB0=1,S=0,T=d[0]+d[0]+1;\n\tfo(i,1,d[0]-1)\n\t\tfo(j,i+1,d[0])\n\t\t{\n\t\t\tif((d[j]-d[i])%2==0) link(i,d[0]+j,1,2),link(j,d[0]+i,1,2);\n\t\t\telse\n\t\t\tif(bz[d[j]-d[i]]) link(i,d[0]+j,1,1),link(j,d[0]+i,1,1);\n\t\t\telse link(i,d[0]+j,1,3),link(j,d[0]+i,1,3);\n\t\t}\n\tfo(i,1,d[0]) link(S,i,1,0),link(d[0]+i,T,1,0);\n\t\n\tdo\n\t{\n\t\twhile(aug(S,INF))\n\t\t\tmset(vis,0);\n\t}\n\twhile(change());\n\tprintf(\"%d\",ans/2);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ninline int read(){int x=0,f=1;char ch=getchar();while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}return x*f;}\n\nconst int maxn = 100 + 15;\nconst int Maxsz = 2e7;\nconst int inf = 1e9 + 7;\n\nint Dp[maxn][maxn] , n , x[maxn] , Prime[Maxsz + 1] , Primelen , Vis[Maxsz + 1];\n\nvoid Init(){\n\tfor(int i = 2 ; i <= Maxsz ; ++ i){\n\t\tif( !Vis[i] )\n\t\t\tPrime[Primelen ++] = i;\n\t\tfor(int j = 0 ; j < Primelen && Prime[j] * i <= Maxsz ; ++ j){\n\t\t\tVis[i * Prime[j]] = 1;\n\t\t\tif( i % Prime[j] == 0 ) break;\n\t\t}\n\t}\n}\n\nint Dfs( int l , int r ){\n\tif( ~Dp[l][r] ) return Dp[l][r];\n\tint & ans = Dp[l][r] = inf;\n\tif( l > r ) return ans = 0;\n\tif( l == r ) return ans = 3;\n\tint ret = 0;\n\tfor(int i = l + 1 ; i <= r ; ++ i){\n\t\tif( x[i] - x[i - 1] - 1 == 0 ) ret += 0;\n\t\telse if( x[i] - x[i - 1] - 1 == 1 ) ret += 3;\n\t\telse if( x[i] - x[i - 1] - 1 == 2 ) ret += 2;\n\t\telse if( Vis[ x[i] - x[i - 1] - 1 ] == 0 ) ret += 1;\n\t\telse ret += 3;\n\t}\n\tint length = x[r] - x[l] + 1;\n\tif( length == 2 ) ret += 2;\n\telse if( Vis[length] == 0 ) ret += 1;\n\telse if( length & 1 ) ret += 3;\n\telse ret += 2;\n\tfor(int i = l ; i <= r ; ++ i)\n\t\tfor(int j = i ; j <= r ; ++ j)\n\t\t\tans = min( ans , Dfs( l , i - 1 ) + Dfs( i , j ) + Dfs( j + 1 , r ) );\n\treturn ans = min( ans , ret );\n}\n\nint main( int argc , char * argv[] ){\n\tInit();\n\tn = read();\n\tfor(int i = 1 ; i <= n ; ++ i)\n\t\tx[i] = read();\n\tmemset( Dp , -1 , sizeof( Dp ) );\n\tprintf( \"%d\\n\" , Dfs( 1 , n ) );\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define STOPIT\n#include <bits/stdc++.h>\n#define loop(n) for (lint ngtkana_is_a_genius = 0; ngtkana_is_a_genius < lint(n); ngtkana_is_a_genius++)\n#define rep(i, begin, end) for (lint i = lint(begin); (i) < lint(end); i++)\n#define all(v) v.begin(), v.end()\n#define rand(l, r) std::uniform_int_distribution<>(l, r)(mt)\nusing lint = long long;\nauto mt = std::mt19937_64(std::random_device{}());\nauto cmn = [](auto& a, auto b){ if (a > b) {a = b; return true;} return false; };\nauto cmx = [](auto& a, auto b){ if (a < b) {a = b; return true;} return false; };\nvoid debug_impl() { std::cerr << std::endl; }\ntemplate <typename Head, typename... Tail>\nvoid debug_impl(Head head, Tail... tail) { std::cerr << \" \" << head; debug_impl(tail...); }\n#ifndef STOPIT\n#define debug(...)\\\n\tdo {\\\n\t\tstd::cerr << std::boolalpha << \"[\" << #__VA_ARGS__ << \"]:\";\\\n\t\tdebug_impl(__VA_ARGS__);\\\n\t\tstd::cerr << std::noboolalpha;\\\n\t} while (false)\n#else\n#define debug(...) {}\n#endif\n\nclass bipartite_matching {\n\t\tint L, R;\n\t\tstd::vector<std::vector<int>> graph;\n\t\tstd::vector<int> match, level;\n\n\t\tbool bfs() {\n\t\t\tstd::fill(level.begin(), level.end(), -1);\n\t\t\tstd::queue<int> que;\n\t\t\tfor (auto i = 0; i < L; i++) {\n\t\t\t\tif (match.at(i) < 0) {\n\t\t\t\t\tlevel.at(i) = 0;\n\t\t\t\t\tque.emplace(i);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbool ret = false;\n\t\t\twhile (!que.empty()) {\n\t\t\t\tauto crr = que.front(); que.pop();\n\t\t\t\tfor (auto nxt : graph.at(crr)) {\n\t\t\t\t\tif (level.at(nxt) != -1) continue;\n\t\t\t\t\tlevel.at(nxt) = level.at(crr) + 1;\n\t\t\t\t\tauto w = match.at(nxt);\n\t\t\t\t\tif (w == -1)\n\t\t\t\t\t\t{ ret = true; }\n\t\t\t\t\telse if (level.at(w) == -1) {\n\t\t\t\t\t\tlevel.at(w) = level.at(crr) + 1;\n\t\t\t\t\t\tque.emplace(w);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\n\t\tbool dfs(int crr) {\n\t\t\tfor (auto nxt : graph.at(crr)) {\n\t\t\t\tassert(level.at(nxt) <= level.at(crr) + 1);\n\t\t\t\tif (level.at(nxt) < level.at(crr) + 1) continue;\n\t\t\t\tlevel.at(nxt) = -1;\n\t\t\t\tauto w = match.at(nxt);\n\t\t\t\tif (w == -1 || dfs(w)) {\n\t\t\t\t\tmatch.at(nxt) = crr;\n\t\t\t\t\tmatch.at(crr) = nxt;\n\t\t\t\t\tlevel.at(crr) = -1;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tlevel.at(crr) = -1;\n\t\t\treturn false;\n\t\t}\n\n\tpublic:\n\t\tbipartite_matching()=default;\n\t\tbipartite_matching(int L, int R):\n\t\t\tL(L), R(R), graph(L + R), match(L + R, -1), level(L + R)\n\t\t\t{}\n\n\t\tvoid insert(int u, int v) {\n\t\t\tv += L;\n\t\t\tgraph.at(u).emplace_back(v);\n\t\t\tgraph.at(v).emplace_back(u);\n\t\t}\n\n\n\t\tint build () {\n\t\t\tauto ret = 0;\n\t\t\twhile (bfs()) {\n\t\t\t\tfor (int i = 0; i < L; i++) {\n\t\t\t\t\tif (match.at(i) == -1 && dfs(i))\n\t\t\t\t\t\t{ ret++; }\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\n\t\tauto collect() const {return match;}\n\n\t\tauto count() const {\n\t\t\tauto k = L + R - std::count(match.begin(), match.end(), -1);\n\t\t\tassert(k % 2 == 0);\n\t\t\treturn k / 2;\n\t\t}\n};\n\ntemplate < typename Container, typename Value = typename Container::value_type, std::enable_if_t<!std::is_same< Container, std::string >::value, std::nullptr_t> = nullptr>\nstd::istream& operator>> (std::istream& is, Container& v)\n\t{ for (auto & x : v) { is >> x; } return is; }\n\ntemplate < typename Container, typename Value = typename Container::value_type, std::enable_if_t<!std::is_same< Container, std::string >::value, std::nullptr_t> = nullptr >\nstd::ostream& operator<< (std::ostream& os, Container const& v) {\n os << \"{\";\n\tfor (auto it = v.begin(); it != v.end(); it++)\n\t\t{os << (it != v.begin() ? \",\" : \"\") << *it;}\n\treturn os << \"}\";\n}\n\ntemplate < class Container, class Value = typename Container::value_type >\nauto run_length(Container const& v) {\n\tauto n = (int)v.size();\n\tif (n == 0)\n\t\t{ return std::vector< std::pair< Value, int > >{}; }\n\tauto pos = std::vector< int >{};\n\tfor (auto i = 1; i < n; i++) {\n\t\tif (v.at(i - 1) != v.at(i))\n\t\t\t{ pos.emplace_back(i); }\n\t}\n\tpos.emplace_back(n);\n\tauto m = (int)pos.size();\n\tauto len = std::vector< int >(m);\n\tstd::adjacent_difference(pos.begin(), pos.end(), len.begin());\n\tauto ret = std::vector< std::pair< Value, int > >(m);\n\tfor (auto i = 0; i != m; i++)\n\t\t{ ret.at(i) = {v.at(pos.at(i) - 1), len.at(i)}; }\n\treturn ret;\n}\n\ntemplate < std::size_t I, typename Container,\n\ttypename Value = typename std::tuple_element_t< I, typename Container::value_type >>\ninline auto project(Container const& v) {\n\tstd::vector< Value > ret(v.size());\n\tstd::transform(v.begin(), v.end(), ret.begin(), [](auto&& t){ return std::get< I >(t); });\n\treturn ret;\n}\n\nint main() {\n\tstd::cin.tie(0); std::cin.sync_with_stdio(false);\n\tconstexpr int xmax = 10'000'010;\n\tauto isp = [&] {\n\t\tstd::vector<int> isp(xmax, true);\n\t\tisp.at(0) = false;\n\t\tisp.at(1) = false;\n\t\tfor (size_t p = 2; p < xmax; p++) {\n\t\t\tif (!isp.at(p)) continue;\n\t\t\tfor (size_t j = 2; j * p < xmax; j++) {\n\t\t\t\tisp.at(p * j) = false;\n\t\t\t}\n\t\t}\n\t\treturn isp;\n\t}();\n\n\tint n; std::cin >> n;\n\tstd::vector<int> a(n); std::cin>>a;\n\tdebug(a);\n\n\tstd::vector<int> ckd(xmax,false);\n\tfor (int x : a) ckd.at(x) = true;\n\tauto c = project<1>(run_length(ckd));\n\tdebug(c);\n\tc.pop_back();\n\tdebug(c);\n\tstd::partial_sum(all(c), c.begin());\n\n\tstd::vector<std::vector<int>> b(2);\n\tfor (int x : c) {\n\t  b.at(x%2).emplace_back(x);\n\t}\n\tdebug(b);\n\tstd::vector<int> sz(2);\n\tsz.at(0) = b.at(0).size();\n\tsz.at(1) = b.at(1).size();\n\tbipartite_matching bm(sz.at(0), sz.at(1));\n\n\trep(i0,0,sz.at(0))\n\trep(i1,0,sz.at(1)) {\n\t\tdebug(i0,i1);\n\t\tint x = b.at(0).at(i0);\n\t\tint y = b.at(1).at(i1);\n\t\tint z = x - y;\n\t\tif (z < 0) z = -z;\n\t\tif (isp.at(z)) {\n\t\t\tbm.insert(i0, i1);\n\t\t}\n\t}\n\tbm.build();\n\n\tint k = sz.at(0);\n\tint l = sz.at(1);\n\tint m = bm.count();\n\tdebug(k,l,m);\n\tint ans = m + (k-m) + (l-m) + k%2;\n\tstd::cout << ans << std::endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <vector>\n#define rep(i,st,ed) for (int i=st;i<=ed;++i)\n\nconst int N=20005;\nconst int M=10000005;\n\nstd:: vector <int> vec[2];\n\nstruct edge {int x,y,next;} e[N*2];\n\nint link[N],vis[N],a[M];\nint ls[N],p[M/10],edCnt;\n\nbool np[M];\n\nint read() {\n\tint x=0,v=1; char ch=getchar();\n\tfor (;ch<'0'||ch>'9';v=(ch=='-')?(-1):v,ch=getchar());\n\tfor (;ch<='9'&&ch>='0';x=x*10+ch-'0',ch=getchar());\n\treturn x*v;\n}\n\nvoid add_edge(int x,int y) {\n\te[++edCnt]=(edge) {x,y,ls[x]}; ls[x]=edCnt;\n\te[++edCnt]=(edge) {y,x,ls[y]}; ls[y]=edCnt;\n}\n\nvoid pre(int n) {\n\tnp[1]=1;\n\trep(i,2,n) {\n\t\tif (!np[i]) p[++p[0]]=i;\n\t\tfor (int j=1;i*p[j]<=n;++j) {\n\t\t\tnp[i*p[j]]=1;\n\t\t\tif (i%p[j]==0) break;\n\t\t}\n\t}\n}\n\nint find(int x,int id) {\n\tfor (int i=ls[x];i;i=e[i].next) {\n\t\tif (vis[e[i].y]==id) continue;\n\t\tvis[e[i].y]=id;\n\t\tif (!link[e[i].y]||find(e[i].y,id)) {\n\t\t\tlink[e[i].y]=x;\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nint main(void) {\n\tint n=read(),mx=0;\n\trep(i,1,n) {\n\t\tint x=read();\n\t\ta[x]=1;\n\t\tmx=std:: max(mx,x);\n\t}\n\tpre(mx+1);\n\trep(i,1,mx+1) if (a[i]!=a[i-1]) {\n\t\tvec[i&1].push_back(i);\n\t}\n\tint ta=vec[0].size(),tb=vec[1].size();\n\tfor (int i=0;i<ta;++i) {\n\t\tfor (int j=0;j<tb;++j) {\n\t\t\tint d=abs(vec[0][i]-vec[1][j]);\n\t\t\tif (!np[d]&&(d&1)) {\n\t\t\t\tadd_edge(i+1,j+1+ta);\n\t\t\t}\n\t\t}\n\t}\n\tint ans=0;\n\trep(i,1,ta) ans+=find(i,i);\n\tta-=ans,tb-=ans;\n\tans+=(ta/2)*2+(tb/2)*2;\n\tif ((ta&1)||(tb&1)) ans+=3;\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef pair<int,int> ii;\n\nbool isPrime[10000002];\nbool cards[10000002];\n\nvector<vector<int>> adjlist;\nvector<int> pairs;\nvector<bool> visited;\n\nbool dfs(int v) {\n  if (visited[v]) return false;\n  visited[v] = true;\n  for (auto w : adjlist[v]) if (pairs[w] < 0 || dfs(pairs[w])) {\n    pairs[w] = v; pairs[v] = w; return true;\n  }\n  return false;\n}\n\nint kuhn(int n) { // n = #Knoten links.\n  pairs.assign(adjlist.size(), -1);\n  int ans = 0;\n  // Greedy Matching. Optionale Beschleunigung.\n  for (int i = 0; i < n; i++) for (auto w : adjlist[i])\n    if (pairs[w] == -1) { pairs[i] = w; pairs[w] = i; ans++; break; }\n  for (int i = 0; i < n; i++) if (pairs[i] == -1) {\n    visited.assign(n, false);\n    ans += dfs(i);\n  }\n  return ans; // Größe des Matchings.\n}\n\nint main() {\n  memset(isPrime, true, sizeof(isPrime));\n  isPrime[1] = false;\n  for (int i = 2; i <= 10000001; i++) {\n    if (isPrime[i]) {\n      for (int j = 2 * i; j <= 10000001; j += i) isPrime[j] = false;\n    }\n  }\n\n  int n;\n  scanf(\"%d\", &n);\n  for (int i = 0; i < n; i++) {\n    int a;\n    scanf(\"%d\", &a);\n    cards[a] = true;\n  }\n\n  vector<int> flips;\n  int odd = 0, even = 0;\n  for (int i = 1; i <= 10000001; i++) {\n    if (cards[i - 1] != cards[i]) {\n      flips.push_back(i);\n      if (i & 1) odd++;\n      else even++;\n    }\n  }\n\n  adjlist.resize(2 * flips.size());\n  for (int i = 0; i < (int)flips.size(); i++) {\n    if (flips[i] & 1) {\n      for (int j = 0; j < (int)flips.size(); j++) {\n        if (!(flips[j] & 1)) {\n          int diff = abs(flips[i] - flips[j]);\n          if (isPrime[diff]) {\n            adjlist[i].push_back(flips.size() + j);\n          }\n        }\n      }\n    }\n  }\n  int m = kuhn(flips.size());\n  int res = m + ((even - m) / 2 + (odd - m) / 2) * 2 + (even - m) % 2 * 3;\n  printf(\"%d\\n\", res);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,a,b) for(int i=a;i<=b;++i)\ntypedef long long ll;\n\nusing namespace std;\n\nvoid File(){\n\tfreopen(\"ARC80F.in\",\"r\",stdin);\n\tfreopen(\"ARC80F.out\",\"w\",stdout);\n}\n\nconst int maxn=100+10;\nint n,a[maxn],pos[maxn],tot,cnt,ans;\nint be[maxn],cnte,to[maxn*maxn],las[maxn*maxn],beg[maxn];\nbool vis[maxn];\n\nvoid add(int u,int v){\n\tlas[++cnte]=beg[u];\n\tbeg[u]=cnte;\n\tto[cnte]=v;\n}\n\nbool pd(int x){\n\tif(x==1 || x==2)return false;\n\tint y=sqrt(x);\n\tREP(i,2,y)if(x%i==0)return false;\n\treturn true;\n}\n\nbool Hungary(int u){\n\tfor(int i=beg[u];i;i=las[i]){\n\t\tif(vis[to[i]])continue;\n\t\tvis[to[i]]=1;\n\t\tif(!be[to[i]] || Hungary(be[to[i]])){\n\t\t\tbe[to[i]]=u;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint main(){\n\t//File();\n\tscanf(\"%d\",&n);\n\tREP(i,1,n){\n\t\tscanf(\"%d\",&a[i]);\n\t\tif(i==1 || a[i-1]<a[i]-1)pos[++tot]=a[i];\n\t\tif(i!=1 && a[i]>a[i-1]+1)pos[++tot]=a[i-1]+1;\n\t}\n\tpos[++tot]=a[n]+1;\n\tREP(i,1,tot)if(pos[i]%2)++cnt;\n\tREP(i,1,tot)if(pos[i]%2==0){\n\t\tREP(j,1,tot)if(pos[j]%2==1 && pd(abs(pos[j]-pos[i])))\n\t\t\tadd(i,j);\n\t}\n\tREP(i,1,tot)if(pos[i]%2==0){\n\t\tmemset(vis,0,sizeof(vis));\n\t\tans+=Hungary(i);\n\t}\n\tprintf(\"%d\\n\",ans+(tot-ans*2)+(cnt-ans)%2);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#define repu(i,x,y) for (int i=x; i<=y; ++i)\nusing namespace std;\n\nint tot,n,m,a[110],b[110],prm[10010],map[110][110],link[110],ans;\nbool flag[10010];\n\nvoid insert(int x)\n{\n    (x&1?a[++n]:b[++m])=x;\n}\n\nbool check(int x)\n{\n    if (x<=2)\n        return 0;\n    for (int i=1; prm[i]*prm[i]<=x; ++i)\n        if (!(x%prm[i]))\n            return 0;\n    return 1;\n}\n\nbool hungary(int x)\n{\n    repu(i,1,map[x][0])\n        if (!flag[map[x][i]])\n        {\n            flag[map[x][i]]=1;\n            if (!link[map[x][i]] || hungary(link[map[x][i]]))\n            {\n                link[map[x][i]]=i;\n                return 1;\n            }\n        }\n    return 0;\n}\n\nint main()\n{\n    scanf(\"%d\",&tot);\n    repu(i,1,tot)\n        scanf(\"%d\",&a[i]);\n    for (int i=1,j; i<=tot; i=j+1)\n    {\n        for (j=i; j<tot && a[j+1]==a[j]+1; ++j);\n        insert(a[i]),insert(a[j]+1);\n    }\n    tot=0;\n    repu(i,2,1e4)\n        if (!flag[i])\n        {\n            prm[++tot]=i;\n            for (int j=i*2; j<=1e4; flag[j]=1,j+=i);\n        }\n    repu(i,1,n)\n        repu(j,1,m)\n            if (check(abs(a[i]-b[j])))\n                map[i][++map[i][0]]=j;\n    repu(i,1,n)\n    {\n        memset(flag,0,sizeof(int)*(m+10));\n        ans+=hungary(i);\n    }\n    printf(\"%d\\n\",n+m-ans+((n-ans)&1));\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 1e7 + 10;\nconst int maxm = 200 + 10;\nint n;\nbool flag[maxn];\nint prime[maxn], cnt;\nint a[maxm], vis[maxm], match[maxm], cur;\nvector<int> odd, even, E[maxm];\nvoid ins(int x)\n{\n\tif(x & 1) odd.push_back(x);\n\telse even.push_back(x);\n}\nvoid sieve()\n{\n\tflag[1] = 1;\n\tfor(int i = 2; i < maxn; ++i)\n\t{\n\t\tif(!flag[i]) prime[++cnt] = i;\n\t\tfor(int j = 1; j <= cnt && i * prime[j] < maxn; ++j)\n\t\t{\n\t\t\tflag[i * prime[j]] = 1;\n\t\t\tif(i % prime[j] == 0)\n\t\t\t\tbreak;\n\t\t}\n\t}\n}\nbool dfs(int now)\n{\n\tfor(auto v : E[now])\n\t\tif(vis[v] != cur)\n\t\t{\n\t\t\tvis[v] = cur;\n\t\t\tif(match[v] == -1 || dfs(match[v]))\n\t\t\t{\n\t\t\t\tmatch[v] = now;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\treturn false;\n}\nvoid add(int u, int v)\n{\n\t++u, ++v;\n\tv += odd.size();\n\tE[u].push_back(v);\n}\nint h()\n{\n\tint ret = 0;\n\tmemset(match, -1, sizeof match);\n\tfor(int i = 1; i <= odd.size(); ++i)\n\t{\n\t\tcur = i;\n\t\tret += dfs(i);\n\t}\n\treturn ret;\n}\t\nint main()\n{\n\tsieve();\n\tscanf(\"%d\", &n);\n\tfor(int i = 1; i <= n; ++i) scanf(\"%d\", &a[i]);\n\tins(a[1]);\n\tfor(int i = 2; i <= n; ++i)\n\t{\n\t\tif(a[i] == a[i - 1] + 1)\n\t\t\tcontinue;\n\t\tins(a[i - 1] + 1);\n\t\tins(a[i]);\n\t}\n\tins(a[n] + 1);\n\tfor(int i = 0; i < odd.size(); ++i)\n\t\tfor(int j = 0; j < even.size(); ++j)\n\t\t\tif(!flag[abs(odd[i] - even[j])])\n\t\t\t\tadd(i, j);\n\tint ret = h();\n\tif((odd.size() - ret) & 1) --ret;\n\tint ans = odd.size() + even.size() - ret;\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}\n\t\n\t"
  },
  {
    "language": "C++",
    "code": "/*\n ***\n Question Name:\n ***\n Question Link:\n \n ***\n Idea:\n */\n\n#include <memory.h>\n#include <iomanip>\n#include <algorithm>\n#include <iostream>\n#include <iterator>\n#include <numeric>\n#include <sstream>\n#include <fstream>\n#include <cassert>\n#include <climits>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n#include <cstdio>\n#include <vector>\n#include <cmath>\n#include <functional>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <list>\n#include <map>\n#include <set>\n#include <unordered_set>\n#include <unordered_map>\n\n#define REP(i,s,n) for(int (i)=s; (i)<(int)(n);(i)++)\n#define RIT(it,c) for(__typeof(c.begin()) it = c.begin();it!=c.end();it++)\n#define ALL(x) x.begin(), x.end()\n#define SZ(x) (int)(x).size()\n#define MSET(m,v) memset(m,v,sizeof(m))\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef long double LD;\ntypedef vector<int> vi;\ntypedef pair<int,int> ii;\ntypedef vector<LL> vL;\ntypedef vector<bool> vb;\ntypedef unordered_set<int> ui;\ntypedef pair<LL,LL> pLL;\n\nclass PrimeFlip{\n    int N = 1E7, n, m;\n    vi mapping;\n    vb vist;\n    vector<vb> E;\n    void init(){\n        int K;\n        cin>>K;\n        unordered_set<int> cnt;\n        vi odds,evens;\n        for(int i=0;i<K;++i){\n            int x;\n            cin>>x;\n            if(cnt.count(x)) cnt.erase(x);\n            else cnt.insert(x);\n            cnt.insert(x+1);\n        }\n        for(auto k:cnt){\n            if(k%2) odds.push_back(k);\n            else evens.push_back(k);\n        }\n        cnt.clear();\n        n = (int)odds.size();\n        m = (int)evens.size();\n        mapping = vi(m,-1);\n        vist = vb(m,false);\n        E = vector<vb>(n,vb(m, false));\n        vb prime(N+1,true);\n        prime[0] = prime[1] = false;\n        for(int i=2;i<=N;++i) if(prime[i]){\n            for(int j=2;j*i<=N;++j) prime[i*j] = false;\n        }\n        prime[2] = false;\n        for(int i=0;i<n;++i) for(int j=0;j<m;++j) E[i][j] =prime[abs(odds[i]-evens[j])];\n        prime.clear();\n    }\n    bool arange(int i){\n        for(int j=0;j<m;++j) if(E[i][j] && !vist[j]){\n            vist[j] = true;\n            if(mapping[j]==-1 || arange(mapping[j])){\n                mapping[j] = i;\n                vist[j] = false;\n                return true;\n            }\n            vist[j] = false;\n        }\n        return false;\n    }\npublic:\n    void solve(){\n        init();\n        int cnt = 0;\n        for(int i=0;i<n;++i) cnt += arange(i);\n        int ans = cnt + ((n-cnt)/2 + (m-cnt)/2)*2 + ((m-cnt)%2)*3;\n        cout<<ans<<endl;\n    }\n};\n\n\n\nint main(){\n    PrimeFlip().solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <cstdio>\n#include <utility>\n\n#define Int register int\n\nusing namespace std;\n\nconst int MAXN = 100, MAXV = 1e7, MAXM = 5e4, MAXP = 664579, INF = 0x3f3f3f3f;\nint n, L, S, T, d[MAXV + 5];\nint pn, Prime[MAXP + 5];\nint CntL, CntR, Left[MAXV + 5], Right[MAXV + 5];\nint Cnte = 1, Head[MAXV + 5];\nbool Vis[MAXV + 5];\npair<int, int> Path[MAXV + 5];\nqueue<int> Q;\n\nstruct Edge { int To, Flow, nxt; } Graph[MAXV + 5];\n\ninline int Abs ( const int x ) { return x < 0 ? ~ x + 1 : x; }\n\ninline int Min ( const int a, const int b ) { return a < b ? a : b; }\n\ninline void Link ( const int s, const int t, const int f ) { Graph[++ Cnte] = { t, f, Head[s] }, Head[s] = Cnte; }\n\ninline void AddEdge ( const int s, const int t, const int f ) { Link ( s, t, f ), Link ( f, t, 0 ); }\n\ninline void Sieve ( const int n ) {\n\tVis[0] = Vis[1] = true;\n\tfor ( Int i = 2; i <= n; ++ i ) {\n\t\tif ( ! Vis[i] ) Prime[++ pn] = i;\n\t\tfor ( Int j = 1; j <= pn && i * Prime[j] <= n; ++ j ) {\n\t\t\tVis[i * Prime[j]] = true;\n\t\t\tif ( ! ( i % Prime[j] ) ) break;\n\t\t}\n\t}\n}\n\ninline bool BFS () {\n\tfor ( ; ! Q.empty (); Q.pop () );\n\tfor ( Int i = 1; i <= T; ++ i ) Vis[i] = false;\n\tQ.push ( S ), Vis[S] = true;\n\twhile ( ! Q.empty () ) {\n\t\tint u = Q.front (); Q.pop ();\n\t\tfor ( Int i = Head[u], v; i; i = Graph[i].nxt ) {\n\t\t\tif ( ! Vis[v = Graph[i].To] && Graph[i].Flow > 0 ) {\n\t\t\t\tQ.push ( v ), Vis[v] = true, Path[v] = { u, i };\n\t\t\t\tif ( v == T ) return true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\ninline int EK () {\n\tint ret = 0;\n\tfor ( ; BFS (); ) {\n\t\tint MinFlow = INF;\n\t\tfor ( Int u = T; u ^ S; u = Path[u].first ) MinFlow = Min ( MinFlow, Graph[Path[u].second].Flow );\n\t\tfor ( Int u = T; u ^ S; u = Path[u].first ) {\n\t\t\tGraph[Path[u].second].Flow -= MinFlow;\n\t\t\tGraph[Path[u].second ^ 1].Flow += MinFlow;\n\t\t}\n\t\tret += MinFlow;\n\t}\n\treturn ret;\n}\n\ninline void Work () {\n\tSieve ( MAXV );\n\tscanf ( \"%d\", &n );\n\tfor ( Int i = 1, x; i <= n; ++ i ) {\n\t\tscanf ( \"%d\", &x ), ++ d[x];\n\t\tL = L > x ? L : x;\n\t}\n\tfor ( Int i = 1; i <= L + 1; ++ i ) {\n\t\tif ( d[i] ^ d[i - 1] ) {\n\t\t\tif ( i & 1 ) {\n\t\t\t\tLeft[++ CntL] = i;\n\t\t\t} else {\n\t\t\t\tRight[++ CntR] = i;\n\t\t\t}\n\t\t}\n\t}\n\tS = CntL + CntR + 1, T = S + 1;\n\tfor ( Int i = 1; i <= CntL; ++ i ) AddEdge ( S, i, 1 );\n\tfor ( Int i = 1; i <= CntR; ++ i ) AddEdge ( i + CntL, T, 1 );\n\tfor ( Int i = 1; i <= CntL; ++ i ) {\n\t\tfor ( Int j = 1; j <= CntR; ++ j ) {\n\t\t\tif ( ! Vis[Abs ( Left[i] - Right[j] )] ) {\n\t\t\t\tAddEdge ( i, j + CntL, 1 );\n\t\t\t}\n\t\t}\n\t}\n\tint mxf = EK (), Ans = mxf;\n\tAns += ( CntL - mxf >> 1 << 1 ) + ( CntR - mxf >> 1 << 1 );\n\tAns += ( ( CntL - mxf ) & 1 ) * 3;\n\tprintf ( \"%d\\n\", Ans );\n}\n\nint main () {\n\tWork ();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst double eps = 1e-9;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\n\n#define sz(c) int((c).size())\n#define all(c) (c).begin(), (c).end()\n#define FOR(i,a,b) for (int i = (a); i < (b); i++)\n#define FORD(i,a,b) for (int i = int(b)-1; i >= (a); i--)\n#define FORIT(i,c) for (__typeof__((c).begin()) i = (c).begin(); i != (c).end(); i++)\n#define mp make_pair\n#define pb push_back\n\nvi primes;\nbool hasEdge(int n){\n    if(n == 1)return false;\n    if(n%2 == 0)return false;\n    for(auto p: primes){\n        if(p*p > n)return true;\n        if(n%p==0)return false;\n    }\n    return true;\n}\n\nvi adj[128];\nint prev_[128];\nbool mark[128];\n\nbool find_match(int n){\n    if(n == -1)return true;\n    if(mark[n])return false;\n    mark[n] = true;\n    for(auto it: adj[n])if(find_match(prev_[it])){\n        prev_[it] = n;\n        return true;\n    }\n    return false;\n}\n\nint main(){\n    ios::sync_with_stdio(false);\n    for(int i = 3; i < 10000; i++){\n        bool ok = true;\n        for(auto p: primes)if(i%p==0){\n            ok = false;\n            break;\n        }\n        if(ok)primes.pb(i);\n    }\n    int N;\n    set<int> nums;\n    cin >> N;\n    FOR(i,0,N){\n        int x;\n        cin >> x;\n        if(nums.find(x) != nums.end())nums.erase(x);\n        else nums.insert(x);\n        if(nums.find(x+1) != nums.end())nums.erase(x+1);\n        else nums.insert(x+1);\n    }\n    vi even, odd;\n    for(auto it: nums){\n        if(it%2==0)even.pb(it);\n        else odd.pb(it);\n    }\n    int E = sz(even);\n    int O = sz(odd);\n    FOR(i,0,E)adj[i].clear();\n    FOR(e,0,E)FOR(o,0,O)if(hasEdge(abs(even[e]-odd[o]))){\n        adj[e].pb(o);\n    }\n    assert(max(E,O) < 128);\n    FOR(i,0,O)prev_[i] = -1;\n    int M = 0;\n    FOR(i,0,E){\n        FOR(j,0,E)mark[j] = 0;\n        if(find_match(i))M++;\n    }\n    int res = M;\n    E -= M;\n    O -= M;\n    res += 2 * (E / 2);\n    E%=2;\n    res += 2 * (O / 2);\n    O %= 2;\n    if(E)res += 3;\n    cout << res << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <bits/stdc++.h>\n\n#define FOR(i,b,e) for(int i=(b); i <= (e); ++i)\n#define FORD(i,b,e) for(int i=(b); i >= (e); --i)\n#define SIZE(c) (int) (c).size()\n#define FORE(i,c) FOR(i,0,SIZE(c)-1)\n#define FORDE(i,c) FORD(i,SIZE(c)-1,0)\n\n#define pb push_back\n#define mp make_pair\n#define st first\n#define nd second\n\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair <int,int> pii;\ntypedef pair <ll,ll> pll;\n\ntypedef vector <int> VI;\ntypedef vector <bool> VB;\ntypedef vector <pii> VP;\ntypedef vector <ll> VL;\ntypedef vector <pll> VPL;\n\ntypedef vector <VI> VVI;\ntypedef vector <VL> VVL;\ntypedef vector <VB> VVB;\ntypedef vector <VP> VVP;\n\nstruct MinCostFlow {\n    typedef int capacity_t;\n    typedef int cost_t;\n\n    // use INFINITY from cmath if cost_t is a double\n    const cost_t INF = 1000 * 1000 * 1000;\n    const capacity_t MAX_CAP = 1000 * 1000 * 1000;\n\n    struct edge {\n        int from, v;\n        capacity_t cap, flow;\n        cost_t cost, dist;\n        int rev_index;\n        \n        bool residual() { return flow < cap; }\n        \n        edge(int _f, int _v, capacity_t _cap, cost_t _cost):\n            from(_f), v(_v), cap(_cap), flow(0), cost(_cost), dist(_cost) {}\n    };\n\n    int n, s, t;\n    vector <cost_t> d;\n    vector <edge*> p;\n    vector <vector<edge>> g;\n    VB queued;\n    \n    MinCostFlow(int n): n(n), d(n), p(n), g(n), queued(n) {}\n    \n    void bellman() {\n        FOR(i,0,n-1) { d[i] = INF; queued[i] = 0; }\n        queue <int> q;\n        \n        d[s] = 0;\n        q.push(s); queued[s] = 0;\n        \n        while (!q.empty()) {\n            int u = q.front(); q.pop(); queued[u] = 0;\n            \n            for (auto &i : g[u]) if (i.residual() && d[i.v] > d[u] + i.dist) {\n                d[i.v] = d[u] + i.dist;\n                p[i.v] = &i;\n                if (!queued[i.v]) { q.push(i.v); queued[i.v] = 1; }\n            }\n        }\n    }\n\n    pair <capacity_t,cost_t> computeFlow(int s, int t) {\n        this->s = s;\n        this->t = t;\n\n        capacity_t flow = 0;\n        cost_t cost = 0;\n\n        while (true) {\n            bellman();\n\n            if (d[t] == INF) break;\n            cost_t c = 0;\n            capacity_t f = MAX_CAP;\n            \n            for (int u=t; u!=s; u=p[u]->from) {\n                f = min(f, p[u]->cap - p[u]->flow);\n            }\n            \n            for (int u=t; u!=s; u=p[u]->from) {\n                p[u]->flow += f;\n                g[p[u]->v][p[u]->rev_index].flow -= f;\n                c += p[u]->cost;\n            }\n            \n            flow += f; cost += f * c;\n        }\n        \n        return {flow, cost};\n    }\n    \n    void addEdge(int a, int b, capacity_t f, cost_t c) {\n        assert(a != b);\n        \n        g[a].pb(edge(a, b, f, c));\n        g[b].pb(edge(b, a, 0, -c));\n        g[a].back().rev_index = SIZE(g[b])-1;\n        g[b].back().rev_index = SIZE(g[a])-1;\n    }\n};\n\n/*************************************************************************/\n\nbool isPrime(int x) {\n    if (x == 1) return false;\n\n    for (int i = 2; i * i <= x; i++) if (x % i == 0) {\n        return false;\n    }\n    \n    return true;\n}\n\n/*************************************************************************/\n\nint solve(int n, VI &x) {\n    struct edge { int i, j, len; };\n    vector <edge> edges;\n    \n    FOR(i,0,n-1) FOR(j,0,n-1) if (i != j) {\n        int diff = abs(x[i] - x[j]);\n        \n        int cost;\n        if (diff % 2 == 0) {\n            cost = 2;\n        } else if (isPrime(diff)) {\n            cost = 1;\n        } else {\n            cost = 3;\n        }\n        \n        edges.pb({i, j, cost});\n    }\n    \n    sort(edges.begin(), edges.end(), [](const edge &a, const edge &b) {\n        return a.len < b.len;\n    });\n    \n    set <int> left;\n    FOR(i,0,n-1) left.insert(i);\n    \n    int ans = 0;\n    for (auto &e : edges) if (left.count(e.i) && left.count(e.j)) {\n        left.erase(e.i);\n        left.erase(e.j);\n        ans += e.len;\n    }\n    \n    return ans;\n}\n\n/*************************************************************************/\n\nint main() {\n    ios_base::sync_with_stdio(0);\n    \n    int n;\n    cin >> n;\n    \n    set <int> pos;\n    while (n--) {\n        int x;\n        cin >> x;\n        \n        VI vals = {x-1, x};\n        for (int v : vals) {\n            if (pos.count(v)) {\n                pos.erase(v);\n            } else {\n                pos.insert(v);\n            }\n        }\n    }\n    \n    VI posVec(pos.begin(), pos.end());\n    cout << solve(posVec.size(), posVec);\n\n    return 0;\n}\n\n/*************************************************************************/\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <array>\n#include <bitset>\n#include <cassert>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstring>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <locale>\n#include <iostream>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <sstream>\n#include <string>\n#include <tuple>\n#include <unordered_map>\n#include <unordered_set>\n#include <utility>\n#include <vector>\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\n\nusing namespace std;\n\nusing ll = long long;\nusing ld = long double;\n\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate <typename T> int len(const T &x) { return x.size(); }\n\ntemplate<typename T>\nvector<T> table(int n, T v) { return vector<T>(n, v); }\n\ntemplate <class... Args>\nauto table(int n, Args... args) {\n  auto val = table(args...);\n  return vector<decltype(val)>(n, move(val));\n}\n\nstruct yes_no : numpunct<char> {\n  string_type do_truename()  const { return \"YES\"; }\n  string_type do_falsename() const { return \"NO\"; }\n};\n\nclass BipartiteMatching {\n  int size;\n  vector<vector<int>> g;\n  vector<int> match;\n  vector<bool> used;\n  bool dfs(int v) {\n    used[v] = true;\n    for (int u: g[v]) {\n      int w = match[u];\n      if (w < 0 || (!used[w] && dfs(w))) {\n        match[v] = u;\n        match[u] = v;\n        return true;\n      }\n    }\n    return false;\n  }\npublic:\n  BipartiteMatching(int v) : size(v), g(v), match(v), used(v) {}\n  void add_edge(int u, int v) {\n    g[u].push_back(v);\n    g[v].push_back(u);\n  }\n  int maximum_matching(void) {\n    int res = 0;\n    fill(begin(match), end(match), -1);\n    for (int v = 0; v < size; ++v) {\n      if (match[v] >= 0) continue;\n      fill(begin(used), end(used), 0);\n      if (dfs(v)) ++res;\n    }\n    return res;\n  }\n};\n\nconst int Prime_N = 1024000 * 10;\n\nbitset<Prime_N> is_prime;\n\nvector<int> primes() {\n  is_prime.set();\n  is_prime[0] = false;\n  is_prime[1] = false;\n  for (int i = 2; i * i < Prime_N; ++i) {\n    if (is_prime[i]) {\n      for (int j = i * i; j < Prime_N; j += i) {\n        is_prime[j] = false;\n      }\n    }\n  }\n  vector<int> res;\n  for (int i = 2; i < Prime_N; ++i) {\n    if (is_prime[i]) res.push_back(i);\n  }\n  return res;\n}\n\nvoid add(vector<int> &v, int x) {\n  auto it = find(ALL(v), x);\n  if (it == end(v)) v.push_back(x);\n  else v.erase(it);\n}\n\nvoid solve(ll N, vector<ll> x) {\n  primes();\n  vector<int> v;\n  for (ll i: x) {\n    add(v, i);\n    add(v, i + 1);\n  }\n  sort(ALL(v));\n\n  N = v.size();\n  BipartiteMatching mat(N);\n  REP(i,N) REP(j,N) {\n    if (v[i] % 2 == 0 && v[j] % 2 == 1) {\n      int d = abs(v[i] - v[j]);\n      if (d >= 3 && is_prime[d]) mat.add_edge(i, j);\n    }\n  }\n  // for (int i: v) cout << i << \" \"; cout << endl;\n  int maxv = mat.maximum_matching();\n\n  int even = 0, odd = 0;\n  for (int i: v) {\n    if (i % 2 == 0) ++even; else ++odd;\n  }\n  int res = 0;\n  res += maxv;\n  odd -= maxv; even -= maxv;\n\n  res += even / 2 * 2;\n  res += odd / 2 * 2;\n  if (even % 2) res += 3;\n  cout << res << endl;\n}\n\nint main() {\n  locale loc(locale(), new yes_no);\n  cout << boolalpha << setprecision(12) << fixed;\n  cout.imbue(loc);\n\tll N;\n\tscanf(\"%lld\", &N);\n\tvector<ll> x(N-1+1);\n\tfor (int i = 0 ; i <= N-1 ; i++) {\n\t  scanf(\"%lld\", &x[i]);\n\t}\n\tsolve(N, x);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstruct fast_ios { fast_ios(){ cin.tie(0); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\n#define FOR(i, begin, end) for(int i=(begin);i<(end);i++)\n#define REP(i, n) FOR(i,0,n)\n#define IFOR(i, begin, end) for(int i=(end)-1;i>=(begin);i--)\n#define IREP(i, n) IFOR(i,0,n)\n#define Sort(v) sort(v.begin(), v.end())\n#define Reverse(v) reverse(v.begin(), v.end())\n#define all(v) v.begin(),v.end()\n#define SZ(v) ((int)v.size())\n#define Lower_bound(v, x) distance(v.begin(), lower_bound(v.begin(), v.end(), x))\n#define Upper_bound(v, x) distance(v.begin(), upper_bound(v.begin(), v.end(), x))\n#define Max(a, b) a = max(a, b)\n#define Min(a, b) a = min(a, b)\n#define bit(n) (1LL<<(n))\n#define bit_exist(x, n) ((x >> n) & 1)\n#define Ans(f, y, n) if(f) cout << y << endl; else cout << n << endl;\n#define debug(x) cout << #x << \"=\" << x << endl;\n#define vdebug(v) cout << #v << \"=\" << endl; REP(i, v.size()){ cout << v[i] << \",\"; } cout << endl;\n#define mdebug(m) cout << #m << \"=\" << endl; REP(i, m.size()){ REP(j, m[i].size()){ cout << m[i][j] << \",\"; } cout << endl;}\n#define pb push_back\n#define f first\n#define s second\n#define int long long\n#define INF 1000000000000000000\n\nusing vec = vector<int>;\nusing mat = vector<vec>;\nusing Pii = pair<int, int>;\nusing PiP = pair<int, Pii>;\nusing PPi = pair<Pii, int>;\nusing bools = vector<bool>;\nusing pairs = vector<Pii>;\n\ntemplate<typename T> void readv(vector<T> &a){ REP(i, a.size()) cin >> a[i]; }\nvoid readv_m1(vector<int> &a){ REP(i, a.size()){cin >> a[i]; a[i]--;} }\n\n//int dx[4] = {1,0,-1,0};\n//int dy[4] = {0,1,0,-1};\n\nint mod = 1000000007;\n//int mod = 998244353;\n#define Add(x, y) x = (x + (y)) % mod\n#define Mult(x, y) x = (x * (y)) % mod\n\nstruct edge { int to, cap, rev; };\n\nclass Graph\n{\npublic:\n    int N;\n    vector<vector<edge>> G;\n    vec level, iter;\n\n    Graph(int N): N(N){\n        G = vector<vector<edge>>(N, vector<edge>(0));\n        level = vec(N);\n        iter = vec(N);\n    }\n\n    void add_edge(int from, int to, int cap){\n        G[from].push_back((edge){to, cap, G[to].size()});\n        G[to].push_back((edge){from, 0, G[from].size() - 1});\n    }\n\n    void bfs(int s){\n        memset(&level[0], -1, sizeof(level[0]) * level.size());\n        queue<int> que;\n        level[s] = 0;\n        que.push(s);\n        while(!que.empty()){\n            int v = que.front(); que.pop();\n            REP(i, G[v].size()){\n                edge &e = G[v][i];\n                if(e.cap > 0 && level[e.to] < 0){\n                    level[e.to] = level[v] + 1;\n                    que.push(e.to);\n                }\n            }\n        }\n    }\n\n    int dfs(int v, int t, int f){\n        if(v == t) return f;\n        for(int &i = iter[v]; i < G[v].size(); i++){\n            edge &e = G[v][i];\n            if(e.cap > 0 && level[v] < level[e.to]){\n                int d = dfs(e.to, t, min(f, e.cap));\n                if(d > 0){\n                    e.cap -= d;\n                    G[e.to][e.rev].cap += d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n\n    int max_flow(int s, int t){\n        int flow = 0;\n        for(;;){\n            bfs(s);\n            if(level[t] < 0) return flow;\n            memset(&iter[0], 0, sizeof(iter[0]) * iter.size());\n            int f;\n            while((f = dfs(s, t, INF)) > 0) flow += f;\n        }\n    }\n\n};\n\nbool is_prime(int n){\n    if(n == 1) return false;\n    for(int i = 2; i * i <= n; i++) if(n % i == 0) return false;\n    return true;\n}\n\nsigned main(){\n\n    int N; cin >> N;\n    vec x(N); readv(x);\n    vec v;\n    REP(i, N){\n        if(SZ(v) > 0 && v[SZ(v) - 1] == x[i]) v[SZ(v) - 1] = x[i] + 1;\n        else{\n            v.pb(x[i]);\n            v.pb(x[i] + 1);\n        }\n    }\n    int n = SZ(v);\n    int s = n, t = n + 1;\n    int n_odd = 0, n_even = 0;\n    Graph G(n + 2);\n    REP(i, n){\n        if(v[i] % 2){\n            G.add_edge(s, i, 1);\n            n_odd++;\n        }else{\n            G.add_edge(i, t, 1);\n            n_even++;\n        }\n    }\n    REP(i, n) REP(j, n){\n        if(v[i] % 2 == 1 && v[j] % 2 == 0 && is_prime(llabs(v[i] - v[j]))) G.add_edge(i, j, 1);\n    }\n    int f = G.max_flow(s, t);\n    int ans = f + 2 * ((n_even - f) / 2) + 2 * ((n_odd - f) / 2) + 3 * ((n_even - f) % 2);\n    cout << ans << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<algorithm>\n#include<cstdio>\n#include<cstring>\nusing namespace std;\nconst int N=1e7+5;\nint n,x,ans,t[N+5],p[1000005],b[205][205],d1[205],d2[205],s[205];\nbool bz[N+5],v[205];\nbool dg(int x)\n{\n\tfor (int i=1;i<=d2[0];i++)\n\tif (b[x][i] && !v[i])\n\t{\n\t\tv[i]=1;\n\t\tif (!s[i] || dg(s[i]))\n\t\t{\n\t\t\ts[i]=x;\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<=n;i++) scanf(\"%d\",&x),bz[x]=1;\n\tfor (int i=1;i<=N;i++) \n\tif (bz[i]^bz[i-1]) \n\t{\n\t\tif (i&1) d1[++d1[0]]=i; \n\t\t\telse d2[++d2[0]]=i;\n\t}\n\tmemset(bz,0,sizeof(bz));\n\tbz[1]=1;\n\tfor (int i=2;i<=N;i++)\n\t{\n\t\tif (!bz[i]) p[++p[0]]=i;\n\t\tfor (int j=1;j<=p[0] && i*p[j]<=N;j++)\n\t\t{\n\t\t\tbz[i*p[j]]=1;\n\t\t\tif (i%p[j]==0) break;\n\t\t}\n\t}\n\tbz[2]=1;\n\tfor (int i=1;i<=d1[0];i++)\n\t\tfor (int j=1;j<=d2[0];j++)\n\t\tif (!bz[abs(d1[i]-d2[j])]) b[i][j]=1;\n\tfor (int i=1;i<=d1[0];i++)\n\t{\n\t\tmemset(v,0,sizeof(v));\n\t\tif (dg(i)) ans++;\n\t}\n\td1[0]-=ans,d2[0]-=ans;\n\tans+=d1[0]/2*2+d2[0]/2*2+d1[0]%2*3;\n\tprintf(\"%d\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <cmath>\n\nusing namespace std;\n\nconst int MAXN = 100 + 100;\nconst int MAXM = 10000000 + 100;\n\nint pri[MAXM], totp = 0;\nbool isp[MAXM];\n\nvoid init()\n{\n\tmemset(isp, true, sizeof(isp));\n\tisp[0] = isp[1] = false;\n\tfor(int i = 2; i < MAXM; i++)\n\t{\n\t\tif(isp[i])\n\t\t\tpri[++totp] = i;\n\t\tfor(int j = 1; j <= totp && i * pri[j] < MAXM; j++)\n\t\t{\n\t\t\tisp[i * pri[j]] = false;\n\t\t\tif(i % pri[j] == 0) break;\n\t\t}\n\t}\n}\n\nstruct Edge\n{\n\tint next, to;\n}\ne[MAXN * MAXN];\nint p[MAXN], l = 2;\nvoid addE(int x, int y)\n{\n\te[l] = (Edge){p[x], y};\n\tp[x] = l++;\n}\nint size[2], vis[2][MAXN], match[2][MAXN];\n\nbool dfs(int x)\n{\n\tvis[0][x] = true;\n\tfor(int i = p[x]; i;i = e[i].next)\n\t\tif(!vis[1][e[i].to])\n\t\t{\n\t\t\tint y = e[i].to;\n\t\t\tvis[1][y] = true;\n\t\t\tif(!match[1][y] || dfs(match[1][y]))\n\t\t\t{\n\t\t\t\tmatch[0][x] = y;\n\t\t\t\tmatch[1][y] = x;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\treturn false;\n}\n\nint hungary()\n{\n\tint ret = 0;\n\tfor(int i = 1; i <= size[0]; i++)\n\t{\n\t\tmemset(vis, 0, sizeof(0));\n\t\tif(dfs(i))\n\t\t\tret++;\n\t}\n\treturn ret;\n}\n\nint n, a[MAXN], b[MAXN], id[MAXN];\n\nint main()\n{\n\tios::sync_with_stdio(false);\n\t// freopen(\"1.in\", \"r\", stdin);\n\t// freopen(\"1.out\", \"w\", stdout);\n\n\tinit();\n\n\tint n0;\n\tcin >> n0;\n\tfor(int i = 1; i <= n0; i++)\n\t\tcin >> a[i];\n\ta[0] = -1, a[n0 + 1] = MAXM + 1;\n\n\tfor(int i = 1; i <= n0; i++)\n\t{\n\t\tif(a[i - 1] != a[i] - 1)\n\t\t\tb[++n] = a[i];\n\t\tif(a[i] + 1 != a[i + 1])\n\t\t\tb[++n] = a[i] + 1;\n\t}\n\t// for(int i = 1; i <= n; i++)\n\t// \tcerr << b[i] << ' ';\n\t// cerr << endl;\n\n\tfor(int i = 1; i <= n; i++)\n\t\tid[i] = ++size[b[i] % 2];\n\t// cerr << size[0] << ' '<< size[1] << endl;\n\n\tfor(int i = 1; i <= n; i++)\n\t\tif(b[i] % 2 == 0)\n\t\t\tfor(int j = 1; j <= n; j++)\n\t\t\t\tif(b[j] % 2 == 1)\n\t\t\t\t\tif(isp[abs(b[i] - b[j])])\n\t\t\t\t\t\taddE(id[i], id[j]);\n\tint k = hungary();\n\t// cerr << k << endl;\n\t\n\tint ans = 1 * k + 2 * ((size[0] - k) / 2 + (size[1] - k) / 2) + 3 * ((size[0] - k) & 1);\n\tcout << ans << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define REP(i, a, b) for(int i = (a), i##end = (b); i <= i##end; ++ i)\n#define CLR(i, a) memset(i, a, sizeof(i))\n#define REPD(i, a, b) for(int i = (a), i##end = (b); i >= i##end; -- i)\n#define REPG(i, x) for(int i = head[x], v; i; i = edge[i].next)\n\ntypedef long long LL;\ntypedef double DB;\n \n#define pc putchar\n#define gc getchar\n#define endl '\\n'\ninline LL rd() {\t\n\tchar ch = gc(); LL ret = 0, sgn = 1;\n\twhile(ch < '0' || ch >'9') {\n\t\tif(ch == '-') sgn = -1;\n\t\tch = gc();\n\t}\n\twhile(ch >= '0' && ch <= '9')\n\t\tret = ret * 10 + ch - '0', ch = gc();\n\treturn ret * sgn;\n}\n \ninline void out(LL x) {\n\tstatic int buf[50], btp;\n\tif(x < 0) x = -x, pc('-');\n\tif(!x) pc('0');\n\telse {\n\t\tbtp = 0;\n\t\tfor(; x; x /= 10) buf[++ btp] = x % 10;\n\t\twhile(btp) pc('0' + buf[btp --]);\n\t}\n}\n \nDB _BEGIN;\n#define LOG(x) cerr << #x << \":\" << x << endl\n#define DBG(...) fprintf(stderr, __VA_ARGS__)\n#define OK DBG(\"Passing [%s] in LINE %d...\\n\", __FUNCTION__, __LINE__)\n#define _TIME (int((clock() - _BEGIN) / (DB)CLOCKS_PER_SEC * 1000))\n\n/**************************************/\n\nconst int N = 400 + 3;\n\nint head[N], cnt;\nstruct qwq { int v, next; } edge[(210 * 210) << 1];\ninline void add(int x, int y) {\n\tedge[++ cnt] = (qwq) { y, head[x] }, head[x] = cnt;\n}\nint lft[N], rt[N], lsz, rsz;\nconst int M = 1e7 + 2;\nbool isnotp[M + 1];\nint tot, p[700000], vis[N], tim, opn[N], n, a[N];\ninline void Sieve() {\n\tisnotp[1] = 1;\n\tREP(i, 2, M) {\n\t\tif(!isnotp[i]) p[++ tot] = i;\n\t\tREP(j, 1, tot) {\n\t\t\tif((LL)i * p[j] > M) break;\n\t\t\tisnotp[i * p[j]] = 1;\n\t\t\tif(i % p[j] == 0) break;\n\t\t}\n\t}\n}\n\nint Aug(int x) {\n\t// LOG(x);\n\tREPG(i, x) if(vis[(v = edge[i].v)] != tim) { \n\t\tvis[v] = tim;\n\t\tif(!opn[v] || Aug(opn[v])) {\n\t\t\topn[x] = v, opn[v] = x;\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nint main() {\n#ifdef LOCAL\n\tfreopen(\"light_example_2.in\", \"r\", stdin);\n#endif\n\tSieve();\n\t// for(int T = rd(); T; -- T) {\n\t\t// cout<<T<<endl;\n\t\tn = rd();\n\t\tcnt = 0;\n\t\t\n\t\tlsz = rsz = 0;\n\t\tREP(i, 1, n) a[i] = rd();\n\t\t\n\t\tif(a[1] & 1) rt[++ rsz] = a[1];\n\t\telse lft[++ lsz] = a[1];\n\t\tREP(i, 2, n) {\n\t\t\tif(a[i - 1] != a[i] - 1) {\n\t\t\t\tif(a[i] & 1) rt[++ rsz] = a[i];\n\t\t\t\telse lft[++ lsz] = a[i];\n\t\t\t} \n\t\t\tif(a[i - 1] + 1 != a[i]) {\n\t\t\t\tif((a[i - 1] + 1) & 1) rt[++ rsz] = a[i - 1] + 1;\n\t\t\t\telse lft[++ lsz] = a[i - 1] + 1;\n\t\t\t}\n\t\t}\n\t\tif((a[n] + 1) & 1) rt[++ rsz] = a[n] + 1;\n\t\telse lft[++ lsz] = a[n] + 1;\n\n\t\tREP(i, 1, lsz) {\n\t\t\tREP(j, 1, rsz) {\n\t\t\t\tint x = lft[i], y = rt[j];\n\t\t\t\tif(isnotp[abs(x - y)]) continue;\n\t\t\t\tif(abs(x - y) & 1) add(i, lsz + j), add(lsz + j, i);\n\t\t\t}\n\t\t}\n\n\t\tfill(vis + 1, vis + lsz + rsz + 1, 0);\n\t\tfill(opn + 1, opn + lsz + rsz + 1, 0);\n\t\ttim = 0;\n\t\tint ret = 0;\n\t\tREP(i, 1, lsz) if(!opn[i]) {\n\t\t\t++ tim;\n\t\t\tret += Aug(i);\n\t\t}\n\n\t\tint ans = ret;\n\t\tans += ((lsz - ret) / 2 + (rsz - ret) / 2) * 2;\n\t\tans += ((rsz - ret) % 2) * 3;\n\t\tout(ans), pc(endl);\n\t\tfflush(stdout);\n\n\t\tfill(head + 1, head + lsz + rsz + 1, 0);\n\t// }\n\n#ifdef LOCAL\n\tLOG(_TIME);\n#endif\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pp;\ntypedef pair<ll,ll> pll;\nvoid read(int& x){ scanf(\"%d\",&x); }\nvoid read(ll& x){ scanf(\"%lld\",&x); }\ntemplate<typename T,typename... Args>\nvoid read(T& a,Args&... b){ read(a); read(b...); }\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define eb emplace_back\n#define x first\n#define y second\n\nint n;\nint p[210];\n\nvoid in(){\n\tint t; read(t);\n\tint last;\n\tread(last);\n\tp[++n] = last;\n\tfor(;--t;){\n\t\tint x; read(x);\n\t\tif(last+1 < x){\n\t\t\tp[++n] = last+1;\n\t\t\tp[++n] = x;\n\t\t}\n\t\tlast = x;\n\t}\n\tp[++n] = last+1;\n}\n\nbool is_prime(int x){\n\tif(x==1) return 0;\n\tif(x==2) return 0;\n\tfor(int i=2; i*i<=x; ++i) if(x%i==0) return 0;\n\treturn 1;\n}\nvector<int>edge[210];\nint vis[210];\nint rev[210];\n\nbool dfs(int x){\n\tif(vis[x]) return 0;\n\tvis[x]=1;\n\tfor(int y:edge[x]){\n\t\tif(!rev[y] || dfs(rev[y])){\n\t\t\trev[y]=x;\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nbool aug(){\n\tfor(int i=1; i<=n; ++i){\n\t\tfill(vis+1, vis+n+1, 0);\n\t\tif(dfs(i)) return 1;\n\t}\n\treturn 0;\n}\n\nint main()\n{\n\tin();\n\tint oc=0, ec=0;\n\tfor(int i=1; i<=n; ++i){\n\t\t((p[i]%2)?oc:ec)++;\n\t\tfor(int j=i+1; j<=n; ++j){\n\t\t\tif(is_prime(p[j]-p[i])){\n\t\t\t\tint a=i, b=j;\n\t\t\t\tif(p[a]%2) swap(a, b);\n\t\t\t\tedge[a].pb(b);\n\t\t\t}\n\t\t}\n\t}\n\tint mm = 0;\n\twhile(aug()) ++mm;\n\tint ans = 2e9;\n\tfor(int pu=mm; pu<=mm; ++pu){\n\t\tint cur = 0;\n\t\tcur += (oc-pu)/2*2;\n\t\tcur += (ec-pu)/2*2;\n\t\tcur += ((oc-pu)%2)*((ec-pu)%2)*3;\n\t\tcur += pu;\n\t\tans = min(ans, cur);\n\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n考虑把序列差分。那么每次操作可以改变两个位置的差分值\n分情况讨论改变两个位置a和b的代价\n1、|a - b|是奇质数：代价是1\n2、|a - b|是2：用5和3来做，5 - 3 = 2。代价是2 \n3、|a - b|是大于2的偶数：根据哥德巴赫猜想，可以表示成两个质数之和。代价是2 \n4、|a - b|是1：用3和2来做，3 - 2 = 1。代价是3 \n5、|a - b|是奇合数：拆成3和一个偶数分别考虑。代价是3\n把所有差分值是1的位置按照奇偶分成两部分，首先尽量用第1种方法来消（二分图最大匹配）。剩下的尽量同奇偶的位置之间用2、3来消。最后要么被消完了要么还要用一次4或5 \n*/\n\n#include <set>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nusing namespace std;\n\nnamespace G\n{\n\tconst int Max_V(205);\n\tconst int Max_E((205 + 105 * 105) * 2);\n\tconst int INF(0X3F3F3F3F);\n\tint V, S, T;\n\tint Head[Max_V], Total, To[Max_E], Next[Max_E], Cap[Max_E];\n\tinline void Add_Edge(const int &tot, const int &s, const int &t, const int &c)\n\t{\n\t\tTo[tot] = t, Next[tot] = Head[s], Head[s] = tot, Cap[tot] = c;\n\t}\n\tinline void Add_Link(const int &s, const int &t, const int &c)\n\t{\n\t\tTotal += 2, Add_Edge(Total, s, t, c), Add_Edge(Total ^ 1, t, s, 0);\n\t}\n\tint Cur[Max_V], Dist[Max_V];\n\tint Q[Max_V];\n\tbool BFS()\n\t{\n\t\tint ft(1);\n\t\tmemset(Dist, 0, sizeof(Dist)), Dist[S] = 1, Q[Q[0] = 1] = S;\n\t\tint u;\n\t\twhile (ft <= Q[0])\n\t\t{\n\t\t\tu = Q[ft++];\n\t\t\tfor (int i = Head[u], v;i;i = Next[i])\n\t\t\t\tif (Cap[i] && !Dist[v = To[i]])\n\t\t\t\t{\n\t\t\t\t\tDist[v] = Dist[u] + 1, Q[++Q[0]] = v;\n\t\t\t\t\tif (v == T)\n\t\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\tint DFS(const int &u, int a)\n\t{\n\t\tif (u == T || a == 0)\n\t\t\treturn a;\n\t\tint Ans(0), f;\n\t\tfor (int &i = Cur[u], v;i;i = Next[i])\n\t\t\tif (Dist[v = To[i]] == Dist[u] + 1 && (f = DFS(v, min(a, Cap[i]))) > 0)\n\t\t\t{\n\t\t\t\tAns += f, Cap[i] -= f, Cap[i ^ 1] += f;\n\t\t\t\tif ((a -= f) == 0)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\treturn Ans;\n\t}\n\tint Dinic()\n\t{\n\t\tint Ans(0);\n\t\twhile (BFS())\n\t\t{\n\t\t\tfor (int i = 1;i <= V;++i)\n\t\t\t\tCur[i] = Head[i];\n\t\t\tAns += DFS(S, INF);\n\t\t}\n\t\treturn Ans;\n\t}\n}\n\nbool isprime(int n)\n{\n\tif (n <= 1)\n\t\treturn false;\n\tfor (int d = 2;d * d <= n;++d)\n\t\tif (n % d == 0)\n\t\t\treturn false;\n\treturn true;\n}\n\ninline int Abs(const int &x)\n{\n\treturn x >= 0 ? x : -x;\n}\n\nconst int Max_N(105);\nint A[Max_N << 1], B[Max_N << 1];\nset<int> S;\n\nvoid init()\n{\n\tint N, X;\n\tfor (scanf(\"%d\", &N);N--;)\n\t{\n\t\tscanf(\"%d\", &X);\n\t\tif (S.count(X))\n\t\t\tS.erase(X);\n\t\telse\n\t\t\tS.insert(X);\n\t\tif (S.count(X + 1))\n\t\t\tS.erase(X + 1);\n\t\telse\n\t\t\tS.insert(X + 1);\n\t}\n\tfor (set<int>::iterator it = S.begin();it != S.end();++it)\n\t\tif ((*it) & 1)\n\t\t\tA[++A[0]] = *it;\n\t\telse\n\t\t\tB[++B[0]] = *it;\n}\n\nvoid work()\n{\n\tG::V = S.size() + 2, G::S = S.size() + 1, G::T = S.size() + 2;\n\tfor (int i = 1;i <= A[0];++i)\n\t\tG::Add_Link(G::S, i, 1);\n\tfor (int i = A[0] + 1;i <= A[0] + B[0];++i)\n\t\tG::Add_Link(i, G::T, 1);\n\tfor (int i = 1;i <= A[0];++i)\n\t\tfor (int j = 1;j <= B[0];++j)\n\t\t\tif (isprime(Abs(A[i] - B[j])))\n\t\t\t\tG::Add_Link(i, A[0] + j, 1);\n\tint Ans = G::Dinic();\n\tA[0] -= Ans, B[0] -= Ans;\n\tAns += (A[0] / 2) * 2, Ans += (B[0] / 2) * 2;\n\tif (A[0] & 1)\n\t\tAns += 3;\n\tprintf(\"%d\", Ans);\n}\n\nint main()\n{\n\tinit();\n\twork();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(n) for(lint I = 0; (I) < (lint)(n); ++(I))\n#define repeat(i, n) for(lint i = 0; (i) < (lint)(n); ++(i))\n#define repeat_to(i, n) for(lint i = 0; (i) <= (lint)(n); ++(i))\n#define repeat_from(i, m, n) for(lint i = (m); (i) < (lint)(n); ++(i))\n#define repeat_from_to(i, m, n) for(lint i = (m); (i) <= (lint)(n); ++(i))\n#define el cout<<endl\n#define dump(x) cout<<\" \"<<#x<<\"=\"<<x\n#define vdump(v) for(size_t I=0; I<v.size(); ++I){cout<<\" \"<<#v<<\"[\"<<I<<\"]=\"<<v[I];} cout<<endl\nusing namespace std;\nusing lint = long long;\nusing ld = long double;\n\n// 2部グラフの最大マッチング O(f(N+M)) f:=最大マッチング数で高々N\nclass bipartite_matching {\npublic:\n    int n;\n    std::vector<std::vector<int>> g;\n    std::vector<int> match;\n\n    bipartite_matching(int n_) : n(n_), g(n_), match(n_), used(n_) {}\n\n    void add_edge(int u, int v) {\n        g[u].push_back(v);\n        g[v].push_back(u);\n    }\n\n    int maximum_matching(void) {\n        int res = 0;\n        fill(begin(match), end(match), -1);\n        for (int v = 0; v < n; ++v) {\n            if (match[v] == -1) {\n                fill(begin(used), end(used), false);\n                if (dfs(v)) res++;\n            }\n        }\n        return res;\n    }\n\nprivate:\n    std::vector<int> used;\n    bool dfs(int v) {\n        used[v] = true;\n        for (int u : g[v]) {\n            int w = match[u];\n            if (w == -1 || (!used[w] && dfs(w))) {\n                match[v] = u;\n                match[u] = v;\n                return true;\n            }\n        }\n        return false;\n    }\n};\n\n// エラトステネスの篩[2,n]を列挙 O(nloglogn)\nvector<lint> sieve_of_eratosthenes(lint n) {\n    vector<bool> is_prime(n+1, true);\n    is_prime[0] = is_prime[1] = false;\n    for (lint i = 2; i*i <= n; ++i)\n        if (is_prime[i])\n            for (lint k = i+i; k <= n; k += i)\n                is_prime[k] = false;\n    vector<lint> primes;\n    for (lint i = 2; i <= n; ++i)\n        if (is_prime[i])\n            primes.push_back(i);\n    return primes;\n}\n\nint main(void) {\n    int n; cin >> n;\n    \n    vector<int> x, y_tag, y;\n    rep(n) {\n        int a; cin >> a;\n        x.push_back(a);\n    }\n    \n    repeat(i, n) {\n        y_tag.push_back(x[i] - 1);\n        y_tag.push_back(x[i]);\n    }\n    \n    repeat(i, y_tag.size()) {\n        if (count(y_tag.begin(), y_tag.end(), y_tag[i]) % 2 == 1) {\n            y.push_back(y_tag[i]);\n        }\n    }\n    sort(y.begin(), y.end());\n    \n    // 1 - 10^7+1 の奇素数リスト\n    vector<lint> primes = sieve_of_eratosthenes(1e7 + 1);\n    \n    auto is_odd_prime = [&primes](const lint p) -> bool {\n        assert(p > 0);\n        if (p == 1) return false;\n        if (p % 2 == 0) return false;\n        if (count(primes.begin(), primes.end(), p) == 0) return false;\n        return true;\n    };\n    \n    lint odds_num = 0, evens_num = 0;\n    repeat(i, y.size()) {\n        if (y[i] % 2 == 1) ++odds_num;\n        else ++evens_num;\n    }\n    \n    bipartite_matching bm(y.size());\n    \n    repeat(i, y.size()) {\n        repeat_from(j, i + 1, y.size()) {\n            lint d = y[j] - y[i];\n            if (is_odd_prime(d)) {\n                bm.add_edge(i, j);\n            }\n        }\n    }\n    lint matching_num = bm.maximum_matching();\n    \n    lint ans = matching_num;\n    lint odds_remains = odds_num - matching_num;\n    lint evens_remains = evens_num - matching_num;\n    \n    if ( odds_remains % 2 == 0) {\n        ans += ((odds_remains) / 2) * 2;\n        ans += ((evens_remains) / 2) * 2;\n    }\n    else {\n        ans += ((odds_remains) / 2) * 2;\n        ans += ((evens_remains) / 2) * 2;\n        ans += 3;\n    }\n    cout << ans << endl;\n    \n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nint main()\n{\n\tcout<<\"1\"<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n\n#define ri register int\n#define ssd 10000010\n#define sid 205\n\nint n, N = 1e7;\nint pr[ssd / 10], tot;\nint nj, no, js[sid], os[sid];\nbool nop[ssd], e[ssd];\n\nint tim, vis[sid], mat[sid];\nbool ex[sid][sid];\n\ninline void Init() {\n    nop[1] = 1;\n    for(ri i = 2; i <= N; i ++) {\n        if(!nop[i]) pr[++ tot] = i;\n        for(ri j = 1; j <= tot; j ++) {\n            int nx = i * pr[j]; if(nx > N) break;\n            nop[nx] = 1; if(i % pr[j] == 0) break;\n        }\n    }\n}\n\ninline int dfs(int o) {\n    for(int i = 1; i <= no; i ++)\n    if(vis[i] != tim && ex[o][i]) {\n        vis[i] = tim;\n        if(!mat[i]|| dfs(mat[i])) { mat[i] = o; return 1; }\n    } return 0;\n}\n\nint main() {\n    Init();\n    cin >> n;\n    for(ri i = 1; i <= n; i ++) { int x; cin >> x; e[x] = 1; }\n    \n    for(ri i = 1; i <= N; i ++)\n    if(e[i] != e[i - 1])\n    if(i & 1) js[++ nj] = i;\n    else os[++ no] = i;\n\n    for(ri i = 1; i <= nj; i ++)\n    for(ri j = 1; j <= no; j ++)\n    if(!nop[abs(js[i] - os[j])]) ex[i][j] = 1;\n\n    int num = 0, ans = 0;\n\n    for(ri i = 1; i <= nj; i ++)\n    if(!mat[i]) ++ tim, num += dfs(i);\n\n    nj -= num; no -= num;\n    ans = num + nj / 2 * 2 + no / 2 * 2 + (nj & 1) * 3;\n    printf(\"%d\\n\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define REP(i, n) for (int i = 0; i < int(n); ++i)\n#define REPE(i, a, b) for (int i = (a); i <= int(b); ++i)\n#define SZ(x) ((int)(x).size())\n#define ALL(x) x.begin(), x.end()\n#define PB push_back\n#define EB emplace_back\nusing LL = long long;\nusing PII = pair<int, int>;\n#define F first\n#define S second\n\nnamespace BPM {\nconst int maxn = 110;\nvector<int> g[maxn];\nint n, m, l[maxn];\nbool vis[maxn];\nbool match(int x) {\n  for (int y : g[x])\n    if (!vis[y]) {\n      vis[y] = true;\n      if (l[y] == -1 || match(l[y])) {\n        l[y] = x;\n        return true;\n      }\n    }\n  return false;\n}\nint solve() {\n  memset(l, -1, sizeof l);\n  int ans = 0;\n  for (int i = 0; i < n; ++i) {\n    memset(vis, 0, sizeof vis);\n    if (match(i))\n      ans++;\n  }\n  return ans;\n}\n}\n\nnamespace Sieve {\nconst int maxn = 1e7 + 10;\nbool vis[maxn] = {};\nvector<int> prime;\nvoid linear_sieve(int n) {\n  for (int i = 2; i < n; ++i) {\n    if (!vis[i]) {\n      prime.push_back(i);\n    }\n    for (int y : prime) {\n      if (1LL * i * y >= n)\n        break;\n      int t = i * y;\n      vis[t] = true;\n      if (i % y == 0) {\n        break;\n      }\n    }\n  }\n}\n}\n\nint n, a[110];\nvector<int> b[2];\nint main() {\n  Sieve::linear_sieve(Sieve::maxn);\n  scanf(\"%d\", &n);\n  set<int> s;\n  REP(i, n) {\n    scanf(\"%d\", &a[i]);\n  }\n  REP(i, n) {\n    if (i == 0 || a[i] - 1 != a[i - 1]) s.insert(a[i]);\n    if (i == n - 1 || a[i] + 1 != a[i + 1]) s.insert(a[i + 1]); \n  }\n  for (int x : s) b[x&1].PB(x);\n  BPM::n = SZ(b[0]);\n  BPM::m = SZ(b[1]);\n  REP(i, BPM::n) REP(j, BPM::m) {\n    int d = abs(b[0][i] - b[1][j]);\n    if (d >= 3 && !Sieve::vis[d]) BPM::g[i].PB(j);\n  }\n  int k = BPM::solve();\n  int ans = k + ((BPM::n - k) / 2 + (BPM::m - k) / 2) * 2 + ((BPM::n - k) % 2) * 3;\n  printf(\"%d\\n\", ans);\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define pb push_back\n#define x first\n#define y second\nusing namespace std;\ntypedef long long LL;\ntypedef vector<int> VI;\nusing namespace std;\nconst int NMAX=406;\nconst int INF=1000000666;\nconst LL INFLL=1000000000000666;\nconst LL maxv=100000;\nconst long double PI = acos(-1.0);\nconst int MAXT = 200000;\n\nint A[105];\nint dp[105];\nint n;\n\nmap<int, bool> M;\n\nint l[NMAX], r[NMAX];\nvector<int> G[NMAX];\nbool viz[NMAX];\nint lf,m,e,x,y,rs;\n \nbool dfs(int v)\n{\n    if(viz[v])\n        return 0;\n    viz[v]=1;\n    for(auto w:G[v])\n        if(l[w] == 0 || dfs(l[w]))\n        {\n            l[w]=v;\n            r[v]=w;\n            return 1;\n        }\n    return 0;\n}\n\n\nbool isprime(int x){\n  int i = 2;\n  int q = 1;\n  if(x == 1){\n    q = 0;\n  }\n  while(i*i <= x){\n    if((x%i) == 0){\n      q=0; \n    }\n    i++;\n  }\n  return q;\n}\n\nint cost(int x){\n  if(x < 0){\n    exit(0);\n  }\n  if(x == 0){\n    return 0;\n  }\n  if((x%2) == 0){\n    return 2;\n  }\n  else{\n    if(!M[x]){\n      if(isprime(x)){\n        return 1;\n        M[x] = 2;\n      }\n      else{\n        return 3;\n        M[x] = 1;\n      }\n    }\n    if(M[x] == 2){\n      return 1;\n    }\n    else\n    {\n      return 3;\n    }\n  }\n}\n\nvoid solve(){\n  cin>>n;\n  for(int i=1; i<=n; ++i){\n    cin>>A[i];\n  }\n  vector<int> df;\n  for(int i=1; i<=n; ++i){\n    if(A[i] - A[i-1] > 1 || i==1){\n      df.push_back(A[i]);\n    }\n    if(A[i+1] - A[i] > 1 || i==n){\n      df.push_back(A[i] + 1);\n    }\n  }\n  //sort(df.begin(), df.end());\n  vector<int> lft, rht;\n\n  for(auto el: df){\n    //cout<<el<<\" \";\n    if(el % 2){\n      rht.push_back(el);\n    }\n    else{\n      lft.push_back(el);\n    }\n  }\n  lf = lft.size();\n  for(int i=0; i<lft.size(); ++i){\n    for(int j=0; j<rht.size(); ++j){\n      if(cost(abs(lft[i] - rht[j])) == 1)\n      {\n        G[i+1].push_back(j+lf+1);\n      }\n    }\n  }\n  bool q=1;\n  while(q)\n  {\n      q=0;\n      memset(viz, 0, sizeof(viz));\n      for(int i=1; i<=lf; ++i)\n      {\n          if(r[i]==0 && dfs(i))\n          {\n              q=1;\n              rs++;\n          }\n      }\n  }\n  int a = lf - rs, b = rht.size() - rs;\n  cout<<2*(a/2) + 2*(b/2) + 3*(a%2)<<\"\\n\";\n  \n\n}\n\n\nint main()\n{\n    // Tic\n    //clock_t t=clock();\n    cout<<setprecision(10)<<fixed;\n    ios_base::sync_with_stdio(0);\n\n    //freopen(\"simetrii.in\", \"rt\", stdin);\n    //freopen(\"simetrii.out\", \"wt\", stdout);\n\n    solve();\n\n    //Toc\n    //t=clock()-t;\n    //printf (\"It took me %d clicks (%f seconds).\\n\",t,((float)t)/CLOCKS_PER_SEC);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#define fo(i,a,b) for(int i=a;i<=b;i++)\n#define fd(i,b,a) for(int i=b;i>=a;i--)\n#define efo(i,u,v) for(int i=BB[u],v=B[BB[u]][1];i;v=B[i=B[i][0]][1])\n#define mset(a,x) memset(a,x,sizeof(a))\nusing namespace std;\ntypedef long long ll;\nchar ch;\nint read(){int n=0,p=1;for(ch=getchar();ch<'0' || '9'<ch;ch=getchar())if(ch=='-') p=-1;for(;'0'<=ch && ch<='9';ch=getchar()) n=n*10+ch-'0';return n*p;}\nconst int N=205,M=2e7+5;\nint n,m,a[N],d[N<<1],pr[M];\nbool b[M],c[M],bz[M];\nvoid prep()\n{\n\tmset(bz,1);\n\tbz[0]=bz[1]=0;\n\tfo(i,2,m)\n\t{\n\t\tif(bz[i]) pr[++pr[0]]=i;\n\t\tfo(j,1,pr[0])\n\t\t{\n\t\t\tll x=(ll)i*pr[j];\n\t\t\tif(x>m) break;\n\t\t\tbz[x]=0;\n\t\t\tif(i%pr[j]==0) break;\n\t\t}\n\t}\n}\n \nconst int V=N<<3,INF=1e9;\nconst int E=10*V*V;\nint B0,S,T,BB[V];\nll ans,dis[V],B[E][4];\nbool vis[V];\nvoid link(int u,int v,int r,ll w)\n{\n\tB[++B0][1]=v,B[B0][2]=r,B[B0][3]=w,B[B0][0]=BB[u],BB[u]=B0;\n\tif(!(B0&1)) link(v,u,0,-w);\n}\nll aug(int v,ll flow)\n{\n\tvis[v]=1;\n\tif(v==T)\n\t{\n\t\tans+=dis[S]*flow;\n\t\treturn flow;\n\t}\n\tefo(i,v,u)\n\t\tif(B[i][2] && !vis[u] && dis[v]==dis[u]+B[i][3])\n\t\t{\n\t\t\tll f=aug(u,min(flow,B[i][2]));\n\t\t\tif(f)\n\t\t\t{\n\t\t\t\tB[i][2]-=f,B[i^1][2]+=f;\n\t\t\t\treturn f;\n\t\t\t}\n\t\t}\n\treturn 0;\n}\nbool change()\n{\n\tll minh=INF;\n\tfo(u,S,T) if(vis[u])\n\t\tefo(i,u,v) if(!vis[v])\n\t\t\tif(B[i][2]) minh=min(minh,dis[v]+B[i][3]-dis[u]);\n\tif(minh==INF) return 0;\n\tfo(i,S,T) if(vis[i]) dis[i]+=minh,vis[i]=0;\n\treturn 1;\n}\nint main()\n{\n\tn=read();\n\tfo(i,1,n) a[i]=read(),b[a[i]]=1,m=max(m,a[i]);\n\t++m;\n\tprep();\n\tfo(i,1,m) c[i]=b[i]^b[i-1];\n\tfo(i,1,m) if(c[i]) d[++d[0]]=i;\n\t\n\tB0=1,S=0,T=d[0]+d[0]+1;\n\tfo(i,1,d[0]-1)\n\t\tfo(j,i+1,d[0])\n\t\t{\n\t\t\tif((d[j]-d[i])%2==0) link(i,d[0]+j,1,2),link(j,d[0]+i,1,2);\n\t\t\telse\n\t\t\tif(bz[d[j]-d[i]]) link(i,d[0]+j,1,1),link(j,d[0]+i,1,1);\n\t\t\telse link(i,d[0]+j,1,3),link(j,d[0]+i,1,3);\n\t\t}\n\tfo(i,1,d[0]) link(S,i,1,0),link(d[0]+i,T,1,0);\n\t\n\tdo\n\t{\n\t\twhile(aug(S,INF)) mset(vis,0);\n\t}\n\twhile(change());\n\tprintf(\"%lld\",ans/2);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define maxn 10000007\n#define maxm 20001\n#define reg register\nusing namespace std;\nbool not_prime[maxn];\nint n,  pos[maxm], d[maxn], prime[maxn],a[maxm], m, cnt, siz[maxm]; \nint nt[maxm], fi[maxm], go[maxm], vis[maxm], visx[maxm], link[maxm]; \ninline int  read() {\n    reg int s = 0, t = 0; reg char ch = getchar();\n    while(ch > '9' || ch < '0') t |= ch == '-', ch = getchar();\n    while(ch >= '0' && ch <= '9') s = (s << 1) + (s << 3) + (ch ^ 48), ch = getchar();\n    return t ? -s : s;\n}\nvoid add(int x, int y){\n    nt[++cnt] = fi[x]; fi[x] = cnt; go[cnt] = y;\n    nt[++cnt] = fi[y]; fi[y] = cnt; go[cnt] = x;\n}\nvoid col(int x){\n    for(int i = fi[x]; i; i = nt[i]){\n        int v = go[i]; \n        if(!vis[v]) {\n            vis[v] = 3 - vis[x]; col(v);\n        }\n    }\n}\nint find(int x, int tim){\n    if(visx[x] == tim) return 0; visx[x] = tim;\n    for(int i = fi[x]; i; i = nt[i]){\n        int v =  go[i];\n        if(!link[v] || find(link[v], tim)){\n            link[v] = x; return 1;\n        }\n    }\n    return 0;\n}\nint main(){\n    n = read(); int ans = 0;\n    for(int i = 1; i <= n; i++) \n        pos[i] = read(), d[pos[i]] = 1; a[0] = -1;\n    sort(pos + 1, pos + n + 1);\n    n = unique(pos + 1, pos + n + 1) - pos - 1;\n    for(int i = 1; i <= n; i++) {\n        if(!d[pos[i] - 1] && a[m] != pos[i]) a[++m] = pos[i];\n        if(!d[pos[i] + 1]) a[++m] = pos[i] + 1; \n    }\n    for(int i = 2; i < maxn; i++) {\n        if(!not_prime[i]) prime[++cnt] = i;\n        for(int j = 1; j <= cnt && prime[j] * i < maxn; j++){\n            not_prime[i * prime[j]] = 1;\n            if(i % prime[j] == 0) break;\n        }\n    }\n    not_prime[2] = 1; cnt = 0; not_prime[1] = 1;\n    for(int i = 1; i <= m; i++)\n        for(int j = i + 1; j <= m; j++)\n            if(!not_prime[a[j] - a[i]]) add(i, j); \n    for(int i = 1; i <= m; i++)\n        if(!vis[i]) { vis[i] = 1; col(i); }\n    for(int i = 1; i <= m; i++)\n        if(vis[i] == 1) ans += (link[i] = find(i, i));       \n    int sum1 = 0, sum2 = 0;\n    for(int i = 1; i <= m; i++){\n        if(link[i]) continue; \n        sum1 += (a[i] & 1);\n        sum2 += (a[i] % 2 == 0);\n    }\n    if(sum1 & 1) ans += 3;\n    ans += sum1 / 2 * 2 + sum2 / 2 * 2;\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n#define N 205\n#define M 10000002\nbool cf[M+5],vis[M+5];\nint prime[M+5],tot;\nint cy[N],a[N],b[N],cntx,cnty;\nbool vs[N],c[N][N];\nvoid shai()\n{\n\tvis[1]=1;int i,j;\n\tfor(i=1;i<=M;i++){\n\t\tif(!vis[i])prime[++tot]=i;\n\t\tfor(j=1;j<=tot;j++){\n\t\t\tint tmp=i*prime[j];\n\t\t\tif(tmp>M)break;\n\t\t\tvis[tmp]=1;\n\t\t\tif(i%prime[j]==0)break;\n\t\t}\n\t\tif(cf[i]){\n\t\t\tif(i&1)a[++cntx]=i;\n\t\t\telse b[++cnty]=i;\n\t\t}\n\t}\n}\n//pay attention to vs\nbool dfs(int i)\n{\n\tfor(int j=1;j<=cnty;j++){\n\t\tif(c[i][j]&&!vs[j]){\n\t\t\tvs[j]=1;\n\t\t\tif(!cy[j]||dfs(cy[j])){\n\t\t\t\tcy[j]=i;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nint maxmatch()\n{\n\tmemset(cy,0,sizeof(cy));\n\tint ret=0;\n\tfor(int i=1;i<=cntx;i++){\n\t\tmemset(vs,0,sizeof(vs));\n\t\tif(dfs(i))ret++;\n\t}\n\treturn ret;\n}\nint ab(int x){return x<0?-x:x;}\nint main()\n{\n\tint n,i,j,x,ans;\n\tscanf(\"%d\",&n);\n\tfor(i=1;i<=n;i++){\n\t\tscanf(\"%d\",&x);\n\t\tcf[x]^=1;cf[x+1]^=1;\n\t}\n\tshai();\n\tfor(i=1;i<=cntx;i++)\n\t\tfor(j=i+1;j<=cnty;j++)\n\t\t\tif(!vis[ab(b[j]-a[i])])c[i][j]=1;\n\tans=maxmatch();\n\tcntx-=ans;cnty-=ans;\n\tans+=(cntx/2)*2+(cnty/2)*2;\n\tif(cntx%2==1&&cnty%2==1)ans+=3;\n\tprintf(\"%d\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<queue>\n#include<algorithm>\nusing namespace std;\nconst int maxn=510,maxL=10000010,inf=0x3f3f3f3f;\nstruct cyc{int v,flow,from;}e[maxn*maxn*2];\nint tot=1,cnt,n,first[maxn],d[maxn],S,T,num[maxn],b[maxn],cur[maxn];\nbool c[maxL];\ninline int ab(int x){return x>0?x:-x;}\nbool isprime(int x){\n    if(x<=2)return 0;\n    for(int i=2;i*i<=x;i++)if(x%i==0)return 0;\n    return 1;\n}\nvoid insert(int u,int v,int w){\n    tot++;e[tot].v=v;e[tot].flow=w;e[tot].from=first[u];first[u]=tot;\n    tot++;e[tot].v=u;e[tot].flow=0;e[tot].from=first[v];first[v]=tot;\n}\nqueue<int>q;\nbool bfs(){\n    memset(d,-1,sizeof(d));\n    q.push(S);d[S]=0;\n    while(!q.empty()){\n        int x=q.front();q.pop();\n        for(int i=first[x];i;i=e[i].from)\n        if(d[e[i].v]==-1&&e[i].flow){\n            d[e[i].v]=d[x]+1;\n            q.push(e[i].v);\n        }\n    }\n    return d[T]!=-1;\n}\nint dinic(int x,int a){\n    if(x==T||a==0)return a;\n    int f,flow=0;\n    for(int& i=cur[x];i;i=e[i].from)\n    if(d[e[i].v]==d[x]+1&&e[i].flow&&(f=dinic(e[i].v,min(a,e[i].flow)))>0){\n        e[i].flow-=f;\n        e[i^1].flow+=f;\n        a-=f;\n        flow+=f;\n        if(a==0)break;\n    }\n    return flow;\n}\nint main(){\n    scanf(\"%d\",&n);\n    for(int i=1;i<=n;i++){scanf(\"%d\",&num[i]);c[num[i]]=1;}\n    for(int i=1;i<=maxL-5;i++)if(c[i]!=c[i-1])b[++cnt]=i;\n    S=0;T=cnt+1;\n    int m1=0;\n    for(int i=1;i<=cnt;i++)if(b[i]&1){\n        m1++;\n        insert(S,i,1);\n        for(int j=1;j<=cnt;j++)if(!(b[j]&1)&&isprime(ab(b[i]-b[j])))insert(i,j,1);\n    }else{\n        insert(i,T,1);\n    }\n    int ans=0;\n    while(bfs()){\n        for(int i=S;i<=T;i++)cur[i]=first[i];\n        ans+=dinic(S,inf);\n    }\n    printf(\"%d\",cnt-ans+(m1-ans)%2);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\ninline int read()\n{\n\tint x = 0, op = 1; char ch = 0;\n\twhile(not isdigit(ch = getchar())) if(ch == '-') op = -op;\n\tdo x = x * 10 + (ch - '0'); while(isdigit(ch = getchar()));\n\treturn op * x;\n}\ninline bool check(int a, int x, int y, int z)\n{\n\tint u = 0, v = 0, w = 0;\n\t#define pows(a, b) \\\n\t\tu = (a), v = (b), w = 1;\\\n\t\twhile(v) { if(v & 1) w = w * u % x; u = u * u % x, v >>= 1; }\n\tpows(a, z);\n\tif(w > 1) { \n\t\tfor(int i = 0; i < y; i++) \n\t\t\tif(w == x - 1) return true;\n\t\treturn false;\n\t}\n\telse return true;\n}\nbool isprime(int x)\n{\n\tif(x == 2 || x == 7 || x == 61) return true;\n\tif(!(x % 2 && x % 7 && x % 61) || x == 1) return false;\n\tint y = 0, z = x - 1; while(!(z & 1)) y++, z >>= 1;\n\tbool ok = true;\t\n\tok &= check(2, x, y, z);\n\tok &= check(7, x, y, z);\n\tok &= check(61, x, y, z);\n\treturn ok;\n}\nint n = 0, m = 0, pos[150], whi[300];\nbool used[300]; int ans = 0;\nint pygo[300]; bool insta[300];\nbool dfs(int x, int p)\n{\n\t#define able(a, b) (abs(whi[a] - whi[b]) > 2 && isprime(abs(whi[a] - whi[b])))\n\tfor(int i = 1; i <= m; i++)\n\t\tif(i != p && i != pygo[p] && able(x, i))\n\t\t{\n\t\t\tif(!pygo[i])\n\t\t\t{\n\t\t\t\tpygo[i] = x, pygo[x] = i;\n\t\t\t\tused[i] = used[x] = true;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tint t = pygo[i];\n\t\t\t\tpygo[t] = 0, pygo[i] = x, pygo[x] = i;\n\t\t\t\tused[i] = used[x] = true, used[t] = false;\n\t\t\t\treturn dfs(t, p);\n\t\t\t}\n\t\t}\n\treturn false;\n}\nsigned main()\n{\n\tn = read();\n\tfor(int i = 1; i <= n; i++) pos[i] = read();\n\tsort(pos + 1, pos + n + 1);\n\tfor(int i = 1; i <= n; i++)\n\t{\n\t\tif(i == 1 || pos[i] != pos[i - 1] + 1) whi[++m] = pos[i];\n\t\tif(i == n || pos[i] != pos[i + 1] - 1) whi[++m] = pos[i] + 1;\n\t}\n\tfor(int i = 1; i <= m; i++)\n\t\tif(not used[i]) dfs(i, i);\n\tfor(int i = 1; i <= n; i++)\n\t\tif(used[i]) ans++;\n\tans >>= 1LL;\n\tint tot[2] = {0, 0};\n\tfor(int i = 1; i <= m; i++)\n\t\tif(not used[i]) tot[whi[i] & 1]++;\n\tans += (((tot[0] >> 1LL) + (tot[1] >> 1LL)) << 1LL) + (tot[0] & 1LL) * 3LL;\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <set>\n#include <algorithm>\n#include <vector>\n#define REP(i, x, y) for(int i = (int)x; i <= (int)y; i ++)\n#define PER(i, x, y) for(int i = (int)x; i >= (int)y; i --)\n#define FOR(i, x, y) for(int i = (int)x; i <  (int)y; i ++)\nusing namespace std;\n\ntypedef long long s64;\n\nconst int INF = 2147483647;\n\nconst int MaxN = 805;\nconst int MaxM = 200005;\n\ntemplate <class T>\ninline void tension(T &a, const T &b)\n{\n\tif (b < a)\n\t\ta = b;\n}\ntemplate <class T>\ninline void relax(T &a, const T &b)\n{\n\tif (b > a)\n\t\ta = b;\n}\ntemplate <class T>\ninline int size(const T &a)\n{\n\treturn (int)a.size();\n}\n\ninline int getint()\n{\n\tchar c;\n\twhile (c = getchar(), '0' > c || c > '9');\n\n\tint res = c - '0';\n\twhile (c = getchar(), '0' <= c && c <= '9')\n\t\tres = res * 10 + c - '0';\n\treturn res;\n}\n\nconst int MaxNX = MaxN + MaxN;\n\nstruct edge\n{\n\tint v, u, w;\n\n\tedge(){}\n\tedge(const int &_v, const int &_u, const int &_w)\n\t\t: v(_v), u(_u), w(_w){}\n};\n\nint n, m;\nedge mat[MaxNX + 1][MaxNX + 1];\n\nint n_matches;\ns64 tot_weight;\nint mate[MaxNX + 1];\nint lab[MaxNX + 1];\n\nint q_n, q[MaxN];\nint fa[MaxNX + 1], col[MaxNX + 1];\nint slackv[MaxNX + 1];\n\nint n_x;\nint bel[MaxNX + 1], blofrom[MaxNX + 1][MaxNX + 1];\nvector<int> bloch[MaxNX + 1];\n\ninline int e_delta(const edge &e) // does not work inside blossoms\n{\n\treturn lab[e.v] + lab[e.u] - mat[e.v][e.u].w * 2;\n}\ninline void update_slackv(int v, int x)\n{\n\tif (!slackv[x] || e_delta(mat[v][x]) < e_delta(mat[slackv[x]][x]))\n\t\tslackv[x] = v;\n}\ninline void calc_slackv(int x)\n{\n\tslackv[x] = 0;\n\tfor (int v = 1; v <= n; v++)\n\t\tif (mat[v][x].w > 0 && bel[v] != x && col[bel[v]] == 0)\n\t\t\tupdate_slackv(v, x);\n}\n\ninline void q_push(int x)\n{\n\tif (x <= n)\n\t\tq[q_n++] = x;\n\telse\n\t{\n\t\tfor (int i = 0; i < size(bloch[x]); i++)\n\t\t\tq_push(bloch[x][i]);\n\t}\n}\ninline void set_mate(int xv, int xu)\n{\n\tmate[xv] = mat[xv][xu].u;\n\tif (xv > n)\n\t{\n\t\tedge e = mat[xv][xu];\n\t\tint xr = blofrom[xv][e.v];\n\t\tint pr = find(bloch[xv].begin(), bloch[xv].end(), xr) - bloch[xv].begin();\n\t\tif (pr % 2 == 1)\n\t\t{\n\t\t\treverse(bloch[xv].begin() + 1, bloch[xv].end());\n\t\t\tpr = size(bloch[xv]) - pr;\n\t\t}\n\n\t\tfor (int i = 0; i < pr; i++)\n\t\t\tset_mate(bloch[xv][i], bloch[xv][i ^ 1]);\n\t\tset_mate(xr, xu);\n\n\t\trotate(bloch[xv].begin(), bloch[xv].begin() + pr, bloch[xv].end());\n\t}\n}\ninline void set_bel(int x, int b)\n{\n\tbel[x] = b;\n\tif (x > n)\n\t{\n\t\tfor (int i = 0; i < size(bloch[x]); i++)\n\t\t\tset_bel(bloch[x][i], b);\n\t}\n}\n\ninline void augment(int xv, int xu)\n{\n\twhile (true)\n\t{\n\t\tint xnu = bel[mate[xv]];\n\t\tset_mate(xv, xu);\n\t\tif (!xnu)\n\t\t\treturn;\n\t\tset_mate(xnu, bel[fa[xnu]]);\n\t\txv = bel[fa[xnu]], xu = xnu;\n\t}\n}\ninline int get_lca(int xv, int xu)\n{\n\tstatic bool book[MaxNX + 1];\n\tfor (int x = 1; x <= n_x; x++)\n\t\tbook[x] = false;\n\twhile (xv || xu)\n\t{\n\t\tif (xv)\n\t\t{\n\t\t\tif (book[xv])\n\t\t\t\treturn xv;\n\t\t\tbook[xv] = true;\n\t\t\txv = bel[mate[xv]];\n\t\t\tif (xv)\n\t\t\t\txv = bel[fa[xv]];\n\t\t}\n\t\tswap(xv, xu);\n\t}\n\treturn 0;\n}\n\ninline void add_blossom(int xv, int xa, int xu)\n{\n\tint b = n + 1;\n\twhile (b <= n_x && bel[b])\n\t\tb++;\n\tif (b > n_x)\n\t\tn_x++;\n\n\tlab[b] = 0;\n\tcol[b] = 0;\n\n\tmate[b] = mate[xa];\n\n\tbloch[b].clear();\n\tbloch[b].push_back(xa);\n\tfor (int x = xv; x != xa; x = bel[fa[bel[mate[x]]]])\n\t\tbloch[b].push_back(x), bloch[b].push_back(bel[mate[x]]), q_push(bel[mate[x]]);\n\treverse(bloch[b].begin() + 1, bloch[b].end());\n\tfor (int x = xu; x != xa; x = bel[fa[bel[mate[x]]]])\n\t\tbloch[b].push_back(x), bloch[b].push_back(bel[mate[x]]), q_push(bel[mate[x]]);\n\n\tset_bel(b, b);\n\n\tfor (int x = 1; x <= n_x; x++)\n\t{\n\t\tmat[b][x].w = mat[x][b].w = 0;\n\t\tblofrom[b][x] = 0;\n\t}\n\tfor (int i = 0; i < size(bloch[b]); i++)\n\t{\n\t\tint xs = bloch[b][i];\n\t\tfor (int x = 1; x <= n_x; x++)\n\t\t\tif (mat[b][x].w == 0 || e_delta(mat[xs][x]) < e_delta(mat[b][x]))\n\t\t\t\tmat[b][x] = mat[xs][x], mat[x][b] = mat[x][xs];\n\t\tfor (int x = 1; x <= n_x; x++)\n\t\t\tif (blofrom[xs][x])\n\t\t\t\tblofrom[b][x] = xs;\n\t}\n\tcalc_slackv(b);\n}\ninline void expand_blossom1(int b) // lab[b] == 1\n{\n\tfor (int i = 0; i < size(bloch[b]); i++)\n\t\tset_bel(bloch[b][i], bloch[b][i]);\n\n\tint xr = blofrom[b][mat[b][fa[b]].v];\n\tint pr = find(bloch[b].begin(), bloch[b].end(), xr) - bloch[b].begin();\n\tif (pr % 2 == 1)\n\t{\n\t\treverse(bloch[b].begin() + 1, bloch[b].end());\n\t\tpr = size(bloch[b]) - pr;\n\t}\n\n\tfor (int i = 0; i < pr; i += 2)\n\t{\n\t\tint xs = bloch[b][i], xns = bloch[b][i + 1];\n\t\tfa[xs] = mat[xns][xs].v;\n\t\tcol[xs] = 1, col[xns] = 0;\n\t\tslackv[xs] = 0, calc_slackv(xns);\n\t\tq_push(xns);\n\t}\n\tcol[xr] = 1;\n\tfa[xr] = fa[b];\n\tfor (int i = pr + 1; i < size(bloch[b]); i++)\n\t{\n\t\tint xs = bloch[b][i];\n\t\tcol[xs] = -1;\n\t\tcalc_slackv(xs);\n\t}\n\n\tbel[b] = 0;\n}\ninline void expand_blossom_final(int b) // at the final stage\n{\n\tfor (int i = 0; i < size(bloch[b]); i++)\n\t{\n\t\tif (bloch[b][i] > n && lab[bloch[b][i]] == 0)\n\t\t\texpand_blossom_final(bloch[b][i]);\n\t\telse\n\t\t\tset_bel(bloch[b][i], bloch[b][i]);\n\t}\n\tbel[b] = 0;\n}\n\ninline bool on_found_edge(const edge &e)\n{\n\tint xv = bel[e.v], xu = bel[e.u];\n\tif (col[xu] == -1)\n\t{\n\t\tint nv = bel[mate[xu]];\n\t\tfa[xu] = e.v;\n\t\tcol[xu] = 1, col[nv] = 0;\n\t\tslackv[xu] = slackv[nv] = 0;\n\t\tq_push(nv);\n\t}\n\telse if (col[xu] == 0)\n\t{\n\t\tint xa = get_lca(xv, xu);\n\t\tif (!xa)\n\t\t{\n\t\t\taugment(xv, xu), augment(xu, xv);\n\t\t\tfor (int b = n + 1; b <= n_x; b++)\n\t\t\t\tif (bel[b] == b && lab[b] == 0)\n\t\t\t\t\texpand_blossom_final(b);\n\t\t\treturn true;\n\t\t}\n\t\telse\n\t\t\tadd_blossom(xv, xa, xu);\n\t}\n\treturn false;\n}\n\nbool match()\n{\n\tfor (int x = 1; x <= n_x; x++)\n\t\tcol[x] = -1, slackv[x] = 0;\n\n\tq_n = 0;\n\tfor (int x = 1; x <= n_x; x++)\n\t\tif (bel[x] == x && !mate[x])\n\t\t\tfa[x] = 0, col[x] = 0, slackv[x] = 0, q_push(x);\n\tif (q_n == 0)\n\t\treturn false;\n\n\twhile (true)\n\t{\n\t\tfor (int i = 0; i < q_n; i++)\n\t\t{\n\t\t\tint v = q[i];\n\t\t\tfor (int u = 1; u <= n; u++)\n\t\t\t\tif (mat[v][u].w > 0 && bel[v] != bel[u])\n\t\t\t\t{\n\t\t\t\t\tint d = e_delta(mat[v][u]);\n\t\t\t\t\tif (d == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (on_found_edge(mat[v][u]))\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\telse if (col[bel[u]] == -1 || col[bel[u]] == 0)\n\t\t\t\t\t\tupdate_slackv(v, bel[u]);\n\t\t\t\t}\n\t\t}\n\n\t\tint d = INF;\n\t\tfor (int v = 1; v <= n; v++)\n\t\t\tif (col[bel[v]] == 0)\n\t\t\t\ttension(d, lab[v]);\n\t\tfor (int b = n + 1; b <= n_x; b++)\n\t\t\tif (bel[b] == b && col[b] == 1)\n\t\t\t\ttension(d, lab[b] / 2);\n\t\tfor (int x = 1; x <= n_x; x++)\n\t\t\tif (bel[x] == x && slackv[x])\n\t\t\t{\n\t\t\t\tif (col[x] == -1)\n\t\t\t\t\ttension(d, e_delta(mat[slackv[x]][x]));\n\t\t\t\telse if (col[x] == 0)\n\t\t\t\t\ttension(d, e_delta(mat[slackv[x]][x]) / 2);\n\t\t\t}\n\n\t\tfor (int v = 1; v <= n; v++)\n\t\t{\n\t\t\tif (col[bel[v]] == 0)\n\t\t\t\tlab[v] -= d;\n\t\t\telse if (col[bel[v]] == 1)\n\t\t\t\tlab[v] += d;\n\t\t}\n\t\tfor (int b = n + 1; b <= n_x; b++)\n\t\t\tif (bel[b] == b)\n\t\t\t{\n\t\t\t\tif (col[bel[b]] == 0)\n\t\t\t\t\tlab[b] += d * 2;\n\t\t\t\telse if (col[bel[b]] == 1)\n\t\t\t\t\tlab[b] -= d * 2;\n\t\t\t}\n\n\t\tq_n = 0;\n\t\tfor (int v = 1; v <= n; v++)\n\t\t\tif (lab[v] == 0) // all unmatched vertices' labels are zero! cheers!\n\t\t\t\treturn false;\n\t\tfor (int x = 1; x <= n_x; x++)\n\t\t\tif (bel[x] == x && slackv[x] && bel[slackv[x]] != x && e_delta(mat[slackv[x]][x]) == 0)\n\t\t\t{\n\t\t\t\tif (on_found_edge(mat[slackv[x]][x]))\n\t\t\t\t\treturn true;\n\t\t\t}\n\t\tfor (int b = n + 1; b <= n_x; b++)\n\t\t\tif (bel[b] == b && col[b] == 1 && lab[b] == 0)\n\t\t\t\texpand_blossom1(b);\n\t}\n\treturn false;\n}\n\nlong long ori_ans = 0;\n\nint pr[1000005], ptot, vis[10000005];\nvoid pret(){\n\tint n = 1e7;\n\tREP(i, 2, n){\n\t\tif(!vis[i]) pr[++ptot] = i;\n\t\tfor(int j = 1; j <= ptot && (long long)pr[j] * i <= n; j ++){\n\t\t\tvis[i * pr[j]] = 1;\n\t\t\tif(i % pr[j] == 0) break;\n\t\t}\n\t}\n\tvis[1] = 1;\n\tvis[2] = 1;\n}\n\nint ask(int x){\n\tif(!vis[x]) return 1;\n\tif(!(x & 1)) return 2;\n\treturn 3;\n}\n\nvoid calc_max_weight_match()\n{\n\tfor (int v = 1; v <= n; v++)\n\t\tmate[v] = 0;\n\n\tn_x = n;\n\tn_matches = 0;\n\ttot_weight = ori_ans;\n\n\tbel[0] = 0;\n\tfor (int v = 1; v <= n; v++)\n\t\tbel[v] = v, bloch[v].clear();\n\tfor (int v = 1; v <= n; v++)\n\t\tfor (int u = 1; u <= n; u++)\n\t\t\tblofrom[v][u] = v == u ? v : 0;\n\n\tint w_max = 0;\n\tfor (int v = 1; v <= n; v++)\n\t\tfor (int u = 1; u <= n; u++)\n\t\t\trelax(w_max, mat[v][u].w);\n\tfor (int v = 1; v <= n; v++)\n\t\tlab[v] = w_max;\n\n\twhile (match())\n\t\tn_matches++;\n\n\tfor (int v = 1; v <= n; v++)\n\t\tif (mate[v] && mate[v] < v)\n\t\t\ttot_weight -= mat[v][mate[v]].w;\n}\n\n\nnamespace In{\n\ttemplate<typename T> inline void chkmin(T &a, const T &b) {if(a > b) a = b;}\n\ttemplate<typename T> inline void chkmax(T &a, const T &b) {if(a < b) a = b;}\n\n\tchar s[1005], t[1005];\n\tint ss[1005], n, cs[405][405];\n\n\tint nn, A[10005];\n\n\tvoid Init(){\n\t\t:: n = n;\n\t\tREP(u, 1, n) REP(v, 1, n) mat[u][v] = edge(u, v, 0);\n\t}\n\n\tvoid add(int u, int v, int w){\n\t\tmat[u][v].w = mat[v][u].w = w;\n\t}\n\n\tvoid Main(){\n/*\n\t\tscanf(\"%d\", &n);\n\n\t\tscanf(\"%s\", s + 1);\n\n\t\tn = strlen(t + 1);\n\n\t\tInit();\n\n\t\tREP(i, 1, n) ss[i] = (t[i] - 48) ^ (s[i] - 48);\n\n\t\tREP(i, 1, n) ss[i] = ss[i] ^ ss[i + 1];\n\n\t\tmemset(cs, 0x3f, sizeof cs);\n\t\tREP(i, 0, n) cs[i][i] = 0;\n\n\t\tREP(i, 1, n) REP(j, 1, n - i + 1){\n\t\t\tint u = i - 1, v = i + j - 1;\n\t\t\tscanf(\"%d\", &cs[u][v]);\n\t\t\tcs[v][u] = cs[u][v];\n\t\t}\n\n\t\tREP(k, 0, n) REP(i, 0, n) REP(j, 0, n) chkmin(cs[i][j], cs[i][k] + cs[k][j]);\n\n\n\t\tREP(i, 1, n) if(ss[i]) {\n\t\t\tori_ans += cs[0][i];\n\t\t\tREP(j, 1, i - 1) if(ss[j]) add(i, j, cs[0][i] + cs[0][j] - cs[i][j]);\n\t\t}\n*/\n\t\tpret();\n\n\t\tscanf(\"%d\", &nn);\n\n\t\tREP(i, 1, nn) scanf(\"%d\", A + i);\n\n\t\tset<int> st;\n\t\tREP(i, 1, nn){\n\t\t\tint u = A[i];\n\t\t\tif(u > 1 && A[i - 1] != A[i] - 1) st.insert(u - 1);\n\t\t\tif(A[i + 1] != A[i] + 1) st.insert(u);\n\t\t}\n\n\t\tstatic int pos[1005];\n\t\tmemset(pos, 0, sizeof pos);\n\t\tint gtot = 0;\n\t\tn = st.size();\n\t\tfor(auto i : st) pos[++ gtot] = i;\n\n\t\tREP(i, 0, n) cs[i][i] = 0;\n\t\tREP(i, 0, n) REP(j, i + 1, n){\n\t\t\tint u = pos[i], v = pos[j];\n\t\t\tcs[i][j] = cs[j][i] = ask(v - u);\n\t\t}\n\n\t\tInit();\n\n\t\tori_ans = 0;\n\t\tREP(i, 1, n){\n\t\t\tori_ans += cs[0][i];\n\t\t\tREP(j, 1, i - 1){\n\t\t\t\tadd(i, j, cs[0][i] + cs[0][j] - cs[i][j]);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\tIn :: Main();\n\tcalc_max_weight_match();\n\tcout << tot_weight << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\nusing namespace std;\nconst int N=300000,INF=1e9;\nint n,x[N],cur[N],mm,fst[N],nxt[N],tmp[N],prime[N],p[N],cnt,ans,dis[N],q[N];\nstruct Edge{int v,w;}e[N];\nvoid ade(int u,int v,int w){e[++mm]=(Edge){v,w},nxt[mm]=fst[u],fst[u]=mm;}\nvoid link(int u,int v,int w){ade(u,v,w),ade(v,u,0);}\nint bfs(int S,int T)\n{\n\tfor(int i=S;i<=T;i++)dis[i]=0;\n\tdis[S]=1;q[1]=S;int head=0,tail=1;\n\twhile(head<tail)\n\t{\n\t\tint u=q[++head];\n\t\tfor(int i=fst[u];i;i=nxt[i])\n\t\t{\n\t\t\tint v=e[i].v;\n\t\t\tif(e[i].w&&!dis[v])\n\t\t\t{\n\t\t\t\tdis[v]=dis[u]+1;\n\t\t\t\tq[++tail]=v;\n\t\t\t}\n\t\t}\n\t}\n\treturn dis[T];\n}\nint dfs(int u,int T,int lim)\n{\n\tif(!lim||u==T)return lim;\n\tint add=0,f;\n\tfor(int &i=cur[u];i;i=nxt[i])\n\t{\n\t\tint v=e[i].v;\n\t\tif(dis[v]==dis[u]+1&&e[i].w&&(f=dfs(v,T,min(lim,e[i].w))))\n\t\t{\n\t\t\tadd+=f,lim-=f;\n\t\t\te[i].w-=f,e[i^1].w+=f;\n\t\t}\n\t}\n\treturn add;\n}\nvoid dinic(int S,int T)\n{\n\tans=0;\n\twhile(bfs(S,T))\n\t{\n\t\tfor(int i=S;i<=T;i++)cur[i]=fst[i];\n\t\tans+=dfs(S,T,INF);\n\t}\n}\nint judge(int x)\n{\n\tif(x==1)return 0;\n\tif(~x&1)return 0;\n\tfor(int i=2;i<=cnt&&prime[i]*prime[i]<=x;i++)\n\t\tif(x%prime[i]==0)return 0;\n\treturn 1;\n}\nvoid make(int n)\n{\n\tfor(int i=2;i<=n;i++)\n\t{\n\t\tif(!p[i])prime[++cnt]=i;\n\t\tfor(int j=1;j<=cnt&&i*prime[j]<=n;j++)\n\t\t{\n\t\t\tp[i*prime[j]]=1;\n\t\t\tif(i%prime[j]==0)break;\n\t\t}\n\t}\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)scanf(\"%d\",x+i);\n\tint tn=0;make(4000);x[0]=-1;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tif(x[i-1]!=x[i]-1)tmp[++tn]=x[i];\n\t\tif(x[i+1]!=x[i]+1)tmp[++tn]=x[i]+1;\n\t}\n//\tfor(int i=1;i<=tn;i++)cout<<tmp[i]<<\" \";puts(\"\");\n\tmm=1;\n\tfor(int i=1;i<=tn;i++)\n\t\tfor(int j=i+1;j<=tn;j++)\n\t\t\tif(judge(tmp[j]-tmp[i]))\n\t\t\t{\n\t\t\t\tif(tmp[i]&1)link(i,j,1);\t\t\t\n\t\t\t\telse link(j,i,1);\n\t\t\t}\n\tint S=0,T=tn+1;\n\tfor(int i=1;i<=tn;i++)\n\t\tif(tmp[i]&1)link(S,i,1);\n\t\telse link(i,T,1);\n\tdinic(S,T); int n1=0,n2=0;\n\tfor(int i=fst[0];i;i=nxt[i])\n\t\tif(e[i].w)n1++;\n\tfor(int i=fst[T];i;i=nxt[i])\n\t\tif(!e[i].w)n2++;\n\tans+=(n1>>1)*2+(n2>>1)*2+((n1&1)&&(n2&1))*3;\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n\n#define Int register int\n#define int long long\n#define MAXN 10000005\n\nint Abs (int x){return x > 0 ? x : -x;}\n\nint tot;\nint prime[MAXN];\n\nbool vis[MAXN];\n\nvoid Prime (int n)\n{\n\tvis[1] = 1;\n\tfor (Int i = 2;i <= n;++ i)\n\t{\n\t\tif (!vis[i]) prime[++ tot] = i;\n\t\tfor (Int j = 1;j <= tot && i * prime[j] <= n;++ j)\n\t\t{\n\t\t\tvis[i * prime[j]] = 1;\n\t\t\tif (i % prime[j] == 0) break;\n\t\t}\n\t}\n}\n\nbool check (int x){return !vis[x];}\n\nbool rev[MAXN];\n\nint read ()\n{\n\tint x = 0;char c = getchar();int f = 1;\n\twhile (c < '0' || c > '9'){if (c == '-') f = -f;c = getchar();}\n\twhile (c >= '0' && c <= '9'){x = (x << 3) + (x << 1) + c - '0';c = getchar();}\n\treturn x * f;\n}\n\nvoid write (int x)\n{\n\tif (x < 0){x = -x;putchar ('-');}\n\tif (x > 9) write (x / 10);\n\tputchar (x % 10 + '0');\n}\n\nvector <int> s1,s2;\n\nstruct edge\n{\n\tint v,nxt;\n}e[MAXN << 1];\n\nint top = 1;\nint head[MAXN];\n\nvoid Add_Edge (int u,int v)\n{\n\te[++ top] = edge {v,head[u]};\n\thead[u] = top;\n}\n\nint my[MAXN];\nbool visit[MAXN];\n\nint dfs (int u)\n{\n\tfor (Int i = head[u];i;i = e[i].nxt)\n\t{\n\t\tint v = e[i].v;\n\t\tif (visit[v]) continue;\n\t\tvisit[v] = 1;\n\t\tif (my[v] == -1 || dfs (my[v]))\n\t\t{\n\t\t\tmy[v] = u;\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nint Hungry ()\n{\n\tint cnt = 0;\n\tmemset (my,-1,sizeof (my));\n\tfor (Int i = 0;i < s1.size();++ i)\n\t{\n\t\tmemset (visit,0,sizeof (visit));\n\t\tcnt += dfs (i);\n\t}\n\treturn cnt;\n}\n\nsigned main()\n{\n\tint n = read ();\n\tint Maxn = 0;\n\tfor (Int i = 1;i <= n;++ i)\n\t{\n\t\tint x = read ();\n\t\trev[x] ^= 1;\n\t\tMaxn = max (Maxn,x + 1);\n\t}\n\tPrime (Maxn);\n\tfor (Int i = 1;i <= Maxn;++ i)\n\t\tif (rev[i] != rev[i - 1])\n\t\t\tif (i & 1)\n\t\t\t\ts1.push_back(i);\n\t\t\telse \n\t\t\t\ts2.push_back(i);\n\tfor (Int i = 0;i < s1.size();++ i)\n\t\tfor (Int j = 0;j < s2.size();++ j)\n\t\t\tif (check (Abs (s1[i] - s2[j])))\n\t\t\t\tAdd_Edge (i,j);\n\tint Ans = Hungry ();\n\twrite (Ans + (s1.size() - Ans) / 2 * 2 + (s2.size() - Ans) / 2 * 2 + s1.size() % 2 * 3),putchar ('\\n'); \n\treturn 0; \n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define RI register int\n#define LL long long\ninline int read()\n{\n\tint res=0,f=1;\n\tchar ch=getchar();\n\twhile(ch!='-'&&(ch>'9'||ch<'0'))\n\t\tch=getchar();\n\tif(ch=='-')\n\t\tf=-1,ch=getchar();\n\twhile(ch>='0'&&ch<='9')\n\t\tres=(res<<1)+(res<<3)+(ch^48),ch=getchar();\n\treturn res*f;\n}\nint k,a[1005];\nnamespace subtask1\n{\n\tint f[1050000];\n\t//f[i]表示状态为i时到达最终状态的最少操作数\n\tbool v[25],prime[25];\n\tqueue<int> q;\n\tvector<int> s[20];\n\t//s[i]表示左端点为i时合法的右端点\n\tvoid bfs()\n\t{\n\t\tmemset(f,0x3f,sizeof(f));\n\t\tq.push((1<<20)-1);\n\t\tf[(1<<20)-1]=0;\n\t\twhile(!q.empty())\n\t\t{\n\t\t\tint x=q.front();\n\t\t\tq.pop();\n\t\t\tfor(RI i=1;i<=18;++i)\n\t\t\t{\n\t\t\t\tint size=s[i].size();\n\t\t\t\tfor(RI j=0;j<size;++j)\n\t\t\t\t{\n\t\t\t\t\tint l=i,r=s[i][j];\n\t\t\t\t\tint t=0;\n\t\t\t\t\tfor(RI g=l;g<=r;++g)\n\t\t\t\t\t\tt+=1<<(g-1);\n\t\t\t\t\tif(f[x^t]>f[x]+1)\n\t\t\t\t\t{\n\t\t\t\t\t\tf[x^t]=f[x]+1;\n\t\t\t\t\t\tq.push(x^t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}\n\tint main()\n\t{\n\t\tprime[3]=prime[5]=prime[7]=prime[11]=prime[13]=prime[17]=prime[19]=1;\n\t\tfor(RI t=3;t<=20;++t)\n\t\t{\n\t\t\tif(!prime[t])\n\t\t\t\tcontinue;\n\t\t\tfor(RI i=1;i<=20;++i)\n\t\t\t{\n\t\t\t\tif(i+t-1>20)\n\t\t\t\t\tbreak;\n\t\t\t\ts[i].push_back(i+t-1);\n\t\t\t}\n\t\t}\n\t\tbfs();\n\t\tint t=0;\n\t\tfor(RI i=1;i<=k;++i)\n\t\t\tv[a[i]]=1;\n\t\tfor(RI i=1;i<=20;++i)\n\t\t\tif(!v[i])\n\t\t\t\tt+=1<<(i-1);\n\t\tprintf(\"%d\\n\",f[t]);\n\t\treturn 0;\n\t}\n}\nnamespace final\n{\n\tint maxn;\n\tstruct edge{\n\t\tint nxt,to,w;\n\t}e[1000005];\n\tint h[10000005],tot,d[10000005],b[10000005];\n\tvoid add(int x,int y,int w)\n\t{\n\t\te[++tot].nxt=h[x];\n\t\te[tot].to=y;\n\t\te[tot].w=w;\n\t\th[x]=tot;\n\t}\n\tint prime[664600],v[10000005],cnt;\n\tvoid pre(int x)\n\t{\n\t\tfor(RI i=2;i<=x;i++)\n\t\t{\n\t\t\tif(!v[i])\n\t\t\t{\n\t\t\t\tprime[++cnt]=i;\n\t\t\t\tv[i]=i;\n\t\t\t}\n\t\t\tfor(RI j=1;j<=cnt;++j)\n\t\t\t{\n\t\t\t\tif(prime[j]*i>x||prime[j]>v[i])\n\t\t\t\t\tbreak;\n\t\t\t\tv[prime[j]*i]=prime[j];\n\t\t\t}\n\t\t}\n\t\tv[2]=0;\n\t}\n\tqueue<int> q;\n\tbool bfs()\n\t{\n\t\twhile(q.size())\n\t\t\tq.pop();\n\t\tmemset(d,0,sizeof(d));\n\t\tq.push(0);\n\t\td[0]=1;\n\t\twhile(!q.empty())\n\t\t{\n\t\t\tint x=q.front();\n\t\t\tq.pop();\n\t\t\tif(x==maxn+2)\n\t\t\t\tbreak;\n\t\t\tfor(RI i=h[x];i;i=e[i].nxt)\n\t\t\t{\n\t\t\t\tint y=e[i].to;\n\t\t\t\tif(!e[i].w)\n\t\t\t\t\tcontinue;\n\t\t\t\tif(d[y])\n\t\t\t\t\tcontinue;\n\t\t\t\td[y]=d[x]+1;\n\t\t\t\tq.push(y);\n\t\t\t}\n\t\t}\n\t\treturn d[maxn+2];\n\t}\n\tint dinic(int x,int flow)\n\t{\n\t\tif(x==maxn+2)\n\t\t\treturn flow;\n\t\tint rest=flow,t;\n\t\tfor(RI i=h[x];i;i=e[i].nxt)\n\t\t{\n\t\t\tif(!rest)\n\t\t\t\tbreak;\n\t\t\tint y=e[i].to;\n\t\t\tif(d[y]!=d[x]+1||!e[i].w)\n\t\t\t\tcontinue;\n\t\t\tt=dinic(y,min(rest,e[i].w));\n\t\t\trest-=t,e[i].w-=t,e[i^1].w+=t;\n\t\t}\n\t\treturn flow-rest;\n\t}\n\tint l[5000005],r[5000005];\n\t//l表示下标为奇数的点\n\t//r表示下标为偶数的点\n\tint main()\n\t{\n\t\tfor(RI i=1;i<=k;++i)\n\t\t{\n\t\t\tb[a[i]]=1;\n\t\t\tmaxn=max(maxn,a[i]);\n\t\t}\n\t\tpre(maxn+2);\n\t\tfor(RI i=1;i<=maxn+1;++i)\n\t\t\tif(b[i]!=b[i-1])\n\t\t\t{\n\t\t\t\tif(i&1)\n\t\t\t\t\tl[++l[0]]=i;\n\t\t\t\telse\n\t\t\t\t\tr[++r[0]]=i;\n\t\t\t}\n\t\ttot=1;\n\t\tfor(RI i=1;i<=l[0];++i)\n\t\t\tfor(RI j=1;j<=r[0];++j)\n\t\t\t\tif(abs(l[i]-r[j])==v[abs(l[i]-r[j])])\n\t\t\t\t\tadd(l[i],r[j],1),add(r[j],l[i],0);\n\t\tfor(RI i=1;i<=l[0];++i)\n\t\t\tadd(0,l[i],1),add(l[i],0,0);\n\t\tfor(RI i=1;i<=r[0];++i)\n\t\t\tadd(r[i],maxn+2,1),add(maxn+2,r[i],0);\n\t\tint flow,ans=0;\n\t\twhile(bfs())\n\t\t\twhile(flow=dinic(0,1<<30))\n\t\t\t\tans+=flow;\n\t\tl[0]-=ans,r[0]-=ans;\n\t\tans+=l[0]/2*2,ans+=r[0]/2*2;\n\t\tif(l[0]&1)\n\t\t\tans+=3;\n\t\tprintf(\"%d\\n\",ans);\n\t\treturn 0;\n\t}\n}\nint main()\n{\n\t//freopen(\"oatmeal.in\",\"r\",stdin);\n\t//freopen(\"oatmeal.out\",\"w\",stdout);\n\tk=read();\n\tbool flag=1;\n\tfor(RI i=1;i<=k;++i)\n\t{\n\t\ta[i]=read();\n\t\tif(a[i]>20)\n\t\t\tflag=0;\n\t}\n\t//if(flag)\n\t//\treturn subtask1::main();\n\treturn final::main();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>     \n#define ll long long\n#define mk make_pair\n#define y1 yyyy\nusing namespace std;\n\nconst int N = 5e4 + 5;\nconst int mod = 1e9 + 7;\n\nint n, a[N], my[N], ans;\nbool b[N * 200];\nvector<int> V[2], G[N];\n\nbool find(int x) {\n\tb[x] = 1;\n\tfor (int i = 0; i < G[x].size(); i++) {\n\t\tint u = G[x][i];\n\t\tif (my[u] == -1) {\n\t\t\tmy[u] = x;\n\t\t\treturn 1;\n\t\t} else {\n\t\t\tif (!b[my[u]] && find(my[u])) {\n\t\t\t\tmy[u] = x;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nbool check(int x) {\n\tif (x == 2) return 0;\n\tfor (int i = 2; i * i <= x; i++) {\n\t\tif (x % i == 0) return 0;\n\t}\n\treturn 1;\n}\n\nint main() {\n\tcin >> n;\n\tfor (int i = 1; i <= n; i++) cin >> a[i], b[a[i]] = 1;\n\tfor (int i = 1; i <= 10000001; i++) {\n\t\tif (b[i] != b[i - 1]) V[i & 1].push_back(i);\n\t}\n\tmemset(my, -1, sizeof(my));\n\tfor (int i = 0; i < V[0].size(); i++) {\n\t\tfor (int j = 0; j < V[1].size(); j++) {\n\t\t\tif (check(abs(V[0][i] - V[1][j]))) \n\t\t\t\tG[i].push_back(j);\n\t\t}\n\t}\n\tfor (int i = 0; i < V[0].size(); i++) {\n\t\tfor (int j = 0; j < V[0].size(); j++) b[j] = 0;\n\t\tif (find(i)) ans++;\n\t}\n\tcout << ans + (V[0].size() - ans) / 2 * 2 + (V[1].size() - ans) / 2 * 2 + V[0].size() % 2 * 3;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cmath>\n#include<cstring>\n#include<algorithm>\n#define LL long long\n#define fo(i,j,k) for(int i=j;i<=k;i++)\n#define fd(i,j,k) for(int i=j;i>=k;i--)\n#define fr(i,j) for(int i=beg[j];i;i=nex[i])\nusing namespace std;\nint const mn=100+3,ma=1e7;\nint n,a[mn],tag[ma],ss[ma],b[2][mn],\n\tgra,beg[mn],to[mn*mn],nex[mn*mn],vis[mn],re[mn];\nvoid ins(int u,int v){\n\tto[++gra]=v;\n\tnex[gra]=beg[u];\n\tbeg[u]=gra;\n}\nint dfs(int p){\n\tvis[p]=1;\n\tfr(i,p)if((!re[to[i]])||dfs(re[to[i]])){\n\t\tre[to[i]]=p;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tfo(i,1,n)scanf(\"%d\",&a[i]);\n\tsort(a+1,a+n+1);\n\tb[a[1]&1][++b[a[1]&1][0]]=a[1];\n\tb[(a[n]+1)&1][++b[(a[n]+1)&1][0]]=a[n]+1;\n\tfo(i,2,n)if(a[i-1]+1!=a[i])\n\t\tb[(a[i-1]+1)&1][++b[(a[i-1]+1)&1][0]]=a[i-1]+1,\n\t\tb[a[i]&1][++b[a[i]&1][0]]=a[i];\n\ttag[1]=1;\n\tfo(i,2,ma){\n\t\tif(!tag[i])ss[++ss[0]]=i;\n\t\tfo(j,1,ss[0]){\n\t\t\tif(1ll*i*ss[j]>ma)break;\n\t\t\ttag[i*ss[j]]=1;\n\t\t\tif(!(i%ss[j]))break;\n\t\t}\n\t}\n\tfo(i,1,b[0][0])fo(j,1,b[1][0])\n\t\tif(!tag[abs(b[0][i]-b[1][j])])ins(i,j);\n\tint tmp=0;\n\tfo(i,1,b[0][0]){\n\t\tmemset(vis,0,sizeof(vis));\n\t\ttmp+=dfs(i);\n\t}\n\tprintf(\"%d\",tmp+2*((b[0][0]-tmp)/2+(b[1][0]-tmp)/2)+3*((b[0][0]-tmp)&1));\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "///Bismillahir Rahmanir Rahim\n#include \"bits/stdc++.h\"\n\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC optimize (\"unroll-loops\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n\n#pragma warning(disable:4786)\n#pragma warning(disable:4996)\n\n#define                           ll                          long long\n#define                           int                         ll\n#define                           fi                          first\n#define                           si                          second\n#define                           mp                          make_pair\n#define                           pb                          push_back\n#define                           pi                          pair<ll,ll>\n#define                           clr(x)                      memset(x,0,sizeof(x));\n#define                           f(i,l,r)                    for(int i=l;i<=r;i++)\n#define                           rf(i,r,l)                   for(int i=r;i>=l;i--)\n#define                           done(i)                     cout<<\"done = \"<<i<<endl;\n#define                           show(x,y)                   cout<<x<<\" : \";for(auto z:y)cout<<z<<\" \";cout<<endl;\n#define                           fast                        ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n\nusing namespace std;\n\nconst ll inf=1e18;\nconst int mod=1e9+7;\nconst int M=10000005;\nint spf[M+3];\nvoid sieve()\n{\n    spf[1]=1;\n    f(i,1,M)spf[i]=i;\n    for(int i=4;i<=M;i=i+2)\n    {\n        spf[i]=2;\n    }\n    for(int i=3;i*i<=M;i=i+2)\n    {\n        if(spf[i]==i)\n        {\n           for(int j=i*i;j<=M;j=j+i)\n           {\n               if(spf[j]==j)\n               {\n                   spf[j]=i;\n               }\n           }\n        }\n    }\n}\nint memo[M];\nint w_memo[M];\nint yo(int );\nint work(int x)\n{\n    int &ret=w_memo[x];\n    if(ret!=(-1))return ret;\n    int cost=inf;\n    for(int i=3;i<x;i=i+2)\n    {\n        int tmp=yo(i)+yo(x-i);\n        cost=min(cost,tmp);\n    }\n    ret=cost;\n    return cost;\n}\nint yo(int val)\n{   int &ret=memo[val];\n    if(ret!=(-1))return ret;\n    ret=0;\n    if(val==1 || val==2)return ret=inf;\n    if(val%2==0)\n    {\n        ret=work(val);\n        return ret;\n    }\n    while(val!=1)\n    {\n        int p=spf[val],cnt=1;\n        while(val%p==0)val=val/p,cnt=cnt*p;\n        cnt=cnt/p;\n        ret+=cnt;\n    }\n    return ret;\n}\nint n,mx;\nbool vis[M];\nvector<pi>vec;\nint last=0,cnt=0;\nconst int N=10000000;\nint dp[205];\n main()\n\n{\n    memset(memo,-1,sizeof memo);\n    memset(w_memo,-1,sizeof w_memo);\n    sieve();\n    scanf(\"%lld\",&n);\n    f(i,1,n)\n    {\n        int x;\n        scanf(\"%lld\",&x);\n        vis[x]=1;\n    }\n    f(i,1,N)\n    {\n       if(vis[i]==last)\n       {\n           cnt++;\n       }\n       else\n       {\n           if(cnt>=1)vec.pb(pi(cnt,last));\n           last=vis[i];\n           cnt=1;\n       }\n    }\n    if(cnt>=1)vec.pb(mp(cnt,last));\n    int sz=vec.size();\n    f(i,1,sz)dp[i]=inf;\n    for(int i=1;i<=sz;i++)\n    {\n        int typ[]={0,0};\n        int flag[]={0,0};\n        int sum=0;\n        for(int j=i;j>=1;j--)\n        {\n             if(vec[j-1].fi!=2 && vec[j-1].fi!=1)\n             {\n                 typ[vec[j-1].si]+=yo(vec[j-1].fi);\n             }\n             else\n             {\n                 flag[vec[j-1].si]=1;\n             }\n             sum+=vec[j-1].fi;\n             if(flag[0]==0  && sum!=1 && sum!=2)\n             {\n                 int aro_cost=yo(sum);\n                 dp[i]=min(dp[i],dp[j-1]+typ[0]+aro_cost);\n             }\n             if(flag[1]==0)\n             {\n                 dp[i]=min(dp[i],dp[j-1]+typ[1]);\n             }\n        }\n    }\n    int cur=1;\n//    cout<<\"sz \"<<sz<<endl;\n//    for(auto z:vec)\n//    {\n//        cout<<z.fi<<\" \"<<z.si<<\" \"<<dp[cur]<<endl;cur++;\n//    }\n    printf(\"%lld\\n\",dp[sz]);\n    return 0;\n\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <utility>\n#include <vector>\n#include <cmath>\n#include <queue>\n\nusing namespace std;\ntypedef pair<int,int> P;\n\nint N;\nint x[110];\nint y[210];\nbool isPrimeNumber(int x) {\n  if (x<=2) {\n    return false;\n  }\n  for(int i=2;i<=sqrt(x)+1;++i) {\n    if (x%i==0) {\n      return false;\n    }\n  }\n  return true;\n}\nclass Dinic {\npublic:\n  struct Edge{\n    int from,to,capacity,flow;\n    int calcRest(bool isRev) {\n      return isRev ? flow : capacity-flow;\n    }\n    int getNext(bool isRev) {\n      return isRev ? from : to;\n    }\n  };\n  static const int MAX_E=100000;\n  static const int MAX_V=500;\n  static const int INF=1000000;\n  int levels[MAX_V];\n  Edge edgeInstances[MAX_E];\n  vector<Edge*> edges[MAX_V][2]; // 1 => reverse edge\n  int E=0;\n\n  void addEdge(Edge edge) {\n    edgeInstances[E] = edge;\n    edges[edge.from][0].push_back(&edgeInstances[E]);\n    edges[edge.to][1].push_back(&edgeInstances[E]);\n    E++;\n  }\n\n  bool setLevels(int s, int t) {\n    memset(levels,-1,sizeof(levels));\n    queue<int> Q;\n    Q.push(s);\n    levels[s] = 0;\n    while(!Q.empty()) {\n      int current = Q.front();\n      Q.pop();\n      if(current==t) {\n        return true;\n      }\n\n      for(int j=0;j<2;++j) {\n        bool revEdge = j == 1;\n        vector<Edge*>& edgeList=edges[current][j];\n        for(int i=0;i<edgeList.size();++i) {\n          Edge& edge = *edgeList[i];\n          int rest = edge.calcRest(revEdge), next = edge.getNext(revEdge);\n          if(levels[next]!=-1) continue;\n          if(rest > 0){\n            levels[next] = levels[current] + 1;\n            Q.push(next);\n          }\n        }\n      }\n    }\n    return false;\n  }\n\n  int calcMaxFlow(int s, int t) {\n    int max_flow=0;\n    while(true) {\n      bool continueFlag = setLevels(s,t);\n      if(!continueFlag) {\n        break;\n      }\n      while(true) {\n        int flow = findFlow(s, t, INF);\n        max_flow += flow;\n        if(flow==0) {\n          break;\n        }\n      }\n    }\n    return max_flow;\n  }\n\n  int findFlow(int current, int destination, int flow) {\n    if(current == destination) return flow;\n\n    for(int j=0;j<2;++j) {\n      bool revEdge = j == 1;\n      vector<Edge*>& edgeList=edges[current][j];\n      for(int i=0;i<edgeList.size();++i) {\n        Edge& edge = *edgeList[i];\n        int rest = edge.calcRest(revEdge), next = edge.getNext(revEdge);\n        if(levels[next]<=levels[current])continue;\n        if(rest > 0){\n          int max_flow = findFlow(next, destination, min(rest,flow));\n          edge.flow += revEdge ? -max_flow: max_flow;\n          if(max_flow>0) {\n            return max_flow;\n          }\n        }\n      }\n    }\n    return 0;\n  }\n\n};\n\nDinic dinic;\nint main() {\n  int num=0;\n  int numEven=0;\n  int numOdd=0;\n  memset(y,0,sizeof(y));\n  memset(x,-1,sizeof(x));\n  scanf(\"%d\", &N);\n  for(int i=0;i<N;++i) {\n    scanf(\"%d\", &x[i]);\n  }\n  for(int i=0;i<N;++i) {\n    if (i==0) {\n      y[num++] = x[i];\n    } else if(x[i-1]!=x[i]-1) {\n      y[num++] = x[i];\n    }\n    if (x[i]!=x[i+1]-1) {\n      y[num++] = x[i]+1;\n    }\n  }\n  for(int i=0;i<num;++i) {\n    if(y[i]%2==0) {\n      numEven++;\n    } else {\n      numOdd++;\n    }\n  }\n  for(int i=0;i<num;++i) {\n    dinic.addEdge({0,i+1,1,0});\n    dinic.addEdge({201+i,450,1,0});\n    for(int j=i+1;j<num;++j) {\n      if(isPrimeNumber(y[j]-y[i])) {\n        dinic.addEdge({i+1,201+j,1,0});\n      }\n    }\n  }\n  int maxk=dinic.calcMaxFlow(0, 450);\n  printf(\"%d\\n\", maxk + ((numEven-maxk)/2+(numOdd-maxk)/2)*2 + ((numEven-maxk)%2) * 3);\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n\nstruct BiMatch{\n  Int n;\n  vector<vector<Int> > G;\n  vector<Int> match,used;\n  \n  BiMatch(){}\n  BiMatch(Int sz):n(sz),G(sz),match(sz),used(sz){}\n  \n  void add_edge(Int u,Int v){\n    G[u].push_back(v);\n    G[v].push_back(u);\n  }\n\n  bool dfs(Int v){\n    used[v]=true;\n    for(Int i=0;i<(Int)G[v].size();i++){\n      Int u=G[v][i],w=match[u];\n      if(w<0||(!used[w]&&dfs(w))){\n\tmatch[v]=u;\n\tmatch[u]=v;\n\treturn true;\n      }\n    }\n    return false;\n  }\n\n  Int build(){\n    Int res=0;\n    fill(match.begin(),match.end(),-1);\n    for(Int v=0;v<n;v++){\n      if(match[v]<0){\n\tfill(used.begin(),used.end(),0);\n\tif(dfs(v)){\n\t  res++;\n\t}\n      }\n    }\n    return res;\n  }\n};\n\n\nInt isprime(Int x){\n  if(x<=2) return 0;\n  for(Int i=2;i*i<=x;i++)\n    if(x%i==0) return 0;\n  return 1;\n}\n\n//INSERT ABOVE HERE\nsigned main(){\n  Int n;\n  cin>>n;\n  vector<Int> x(n);\n  for(Int i=0;i<n;i++) cin>>x[i];\n  \n  vector<Int> a(1e7+100,0);\n  for(Int i=0;i<n;i++) a[x[i]]=1;\n  vector<Int> b;\n  for(Int i=1;i<(Int)a.size();i++)\n    if(a[i]^a[i-1]) b.emplace_back(i);\n\n  Int m=b.size();\n  BiMatch bm(m);\n  for(Int i=0;i<m;i++)\n    for(Int j=0;j<i;j++)\n      if(isprime(b[i]-b[j]))\n\tbm.add_edge(i,j);\n\n  Int k=bm.build();\n  Int o=0,e=0;\n  for(Int x:b) if(x&1) o++;else e++;\n  //cout<<k<<\" \"<<o<<\" \"<<e<<endl;\n  Int ans=k+((o-k)/2*2)+((e-k)/2*2)+((o-k)&1?3:0);\n  cout<<ans<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 1000000007LL\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nstruct edge{\n\tint to,cap,rev;\n\tedge(){}\n\tedge(int tt,int cc,int rr){\n\t\tto=tt;\n\t\tcap=cc;\n\t\trev=rr;\n\t}\n};\n\nvector<edge> G[301];\nint level[301];\nint iter[301];\n\nvoid add_edge(int from,int to,int cap){\n\tG[from].push_back(edge(to,cap,G[to].size()-1));\n\tG[to].push_back(edge(from,0,G[from].size()));\n}\n\nvoid bfs(int s){\n\tmemset(level,-1,sizeof(level));\n\tqueue<int> que;\n\tlevel[s]=0;\n\tque.push(s);\n\twhile(que.size()){\n\t\tint v=que.front();\n\t\tque.pop();\n\t\tfor(int i=0;i<G[v].size();i++){\n\t\t\tedge &e=G[v][i];\n\t\t\tif(e.cap>0 && level[e.to]<0){\n\t\t\t\tlevel[e.to]=level[v]+1;\n\t\t\t\tque.push(e.to);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint dfs(int v,int t,int f){\n\tif(v==t)return f;\n\tfor(int &i=iter[v];i<G[v].size();i++){\n\t\tedge &e=G[v][i];\n\t\tif(e.cap>0 && level[v]<level[e.to]){\n\t\t\tint d=dfs(e.to,t,min(f,e.cap));\n\t\t\tif(d>0){\n\t\t\t\te.cap-=d;\t\t\t\n\t\t\t\tG[e.to][e.rev].cap+=d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint max_flow(int s,int t){\n\n}\n\nint n;\nint x[101];\nint a[10000001];\nint b[10000001];\n\nint prime(int x){\n\tif(x<=2)return 3;\n\tbool flag=true;\n\tfor(int i=2;i*i<=x;i++){\n\t\tif(x%i==0)return 3;\n\t}\n\treturn 1;\n}\n\nint main(void){\n\tscanf(\"%d\",&n);\n\tfor(int i=0;i<n;i++){\n\t\tscanf(\"%d\",&x[i]);\n\t\ta[x[i]]=1;\n\t}\n\tvector<int> colt[2];\n\tfor(int i=1;i<=x[n-1]+1;i++){\n\t\tb[i-1]=a[i-1]^a[i];\n\t\tif(b[i-1]==1){\n\t\t\tcolt[i%2].push_back(i);\n\t\t}\n\t}\n\tint s=colt[0].size()+colt[1].size();\n\tint t=s+1;\n\tfor(int i=0;i<colt[0].size();i++){\n\t\tfor(int j=0;j<colt[1].size();j++){\n\t\t\tint val=prime(abs(colt[0][i]-colt[1][j]));\n\t\t\tadd_edge(i,colt[0].size()+j,val);\n\t\t}\n\t}\n\tfor(int i=0;i<colt[0].size();i++){\n\t\tadd_edge(s,i,1);\n\t}\n\tfor(int i=0;i<colt[1].size();i++){\n\t\tadd_edge(colt[0].size()+i,t,1);\n\t}\n\tint cnt=max_flow(s,t);\n\tint res=0;\n\tres+=((int)colt[0].size()-cnt)/2*2;\n\tres+=((int)colt[1].size()-cnt)/2*2;\n\tres+=(((int)colt[0].size()-cnt)%2)*3;\n\tres+=cnt;\n\tprintf(\"%d\\n\",res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <set>\n#include <bitset>\nusing namespace std;\nint N;\nint x;\nset<int> S;\nvector<int> G[205];\nint L[205];\nint R[205];\nvector<int> Me,Mo;\nbitset<205> U;\nbool prime(int nr)\n{\n    for(int i=2;i*i<=nr;i++)if(nr%i==0)return 0;\n    return 1;\n}\nbool pairup(int nod)\n{\n    if(U[nod])return 0;\n    U[nod]=1;\n    for(auto it:G[nod])\n    {\n        if(!R[it])\n        {\n            L[nod]=it;\n            R[it]=nod;\n            return 1;\n        }\n    }\n    for(auto it:G[nod])\n    {\n        if(pairup(R[it]))\n        {\n            L[nod]=it;\n            R[it]=nod;\n            return 1;\n        }\n    }\n    return 0;\n}\nint main()\n{\n    cin>>N;\n    for(int i=1;i<=N;i++)\n    {\n        cin>>x;\n        if(S.find(x)!=S.end())\n        {\n            S.erase(x);\n        }\n        else\n        {\n            S.insert(x);\n        }\n        S.insert(x+1);\n    }\n    for(auto it:S)\n        if(it%2==0)\n            Me.push_back(it);\n        else\n            Mo.push_back(it);\n    for(int i=0;i<Me.size();i++)\n    {\n        for(int j=0;j<Mo.size();j++)\n        {\n            if(prime(abs(Mo[j]-Me[i])))\n                G[i+1].push_back(j+1);\n        }\n    }\n    bool ok=1;\n    int k=0;\n    while(ok)\n    {\n        ok=0;\n        U.reset();\n        for(int i=0;i<Me.size();i++)\n        {\n            if(!L[i+1]&&pairup(i+1))\n            {\n                k++;\n                ok=1;\n            }\n        }\n    }\n    int rez=k+(((int)Me.size()-k)/2)*2+(((int)Mo.size()-k)/2)*2+(((int)Me.size()-k)%2)*3;\n    cout<<rez;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\ntypedef long long ll;\n\n#define N 10000050\n#define INF 30000000\n#define Min(a,b) (a<b?a:b)\n\nint noprm[N];\nint prm[N/5],pcnt;\nvoid init(int lim)\n{\n\tnoprm[1]=1;\n\tfor(int i=2;i<=lim;i++)\n\t{\n\t\tif(!noprm[i])\n\t\t{\n\t\t\tprm[++pcnt]=i;\n\t\t}\n\t\tfor(int j=1;j<=pcnt && (ll)i*prm[j]<=lim;j++)\n\t\t{\n\t\t\tnoprm[i*prm[j]]=1;\n\t\t\tif(i%prm[j]==0) break;\n\t\t}\n\t}\n}\n\nint a[105];\nint tp[205],len[205];\nint f[2][205][205];\n\ninline int calc(int p)\n{\n\treturn (p&1)? (noprm[p]? 3: 1): 2;\n}\n\nint solve(int tp,int l,int r)\n{\n\tif(f[tp][l][r]!=-1) return f[tp][l][r];\n\tif(l==r) return INF;\n\tint &res1=f[tp][l][r];\n\tint &res2=f[tp^1][l][r];\n\tres1=res2=INF;\n\tfor(int i=l;i<=r;i++)\n\t\tfor(int j=i;j<=r;j++)\n\t\t{\n\t\t\tif(i==l && j==r) continue;\n\t\t\tint tmp1= i>l? solve(tp,l,i-1): 0;\n\t\t\tint tmp2=solve(tp^1,i,j);\n\t\t\tint tmp3= j<r? solve(tp,j+1,r): 0;\n\t\t\tint tmp4=calc(len[j]-len[i-1]);\n\t\t\tres1=Min(res1,tmp1+tmp2+tmp3+tmp4);\n\t\t\ttp^=1;\n\t\t\ttmp1= i>l? solve(tp,l,i-1): 0;\n\t\t\ttmp2=solve(tp^1,i,j);\n\t\t\ttmp3= j<r? solve(tp,j+1,r): 0;\n\t\t\tres2=Min(res2,tmp1+tmp2+tmp3+tmp4);\n\t\t\ttp^=1;\n\t\t}\n\tint tmp=calc(len[r]-len[l-1]);\n\tres1=Min(res1,res2+tmp);\n\tres2=Min(res2,res1+tmp);\n\tres1=Min(res1,res2+tmp);\n\tres2=Min(res2,res1+tmp);\n\treturn res1;\n}\n\nint main()\n{\n\tinit(10000000);\n\tint n;scanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)\n\t\tscanf(\"%d\",&a[i]);\n\tint scnt=0,start=1;\n\tif(a[1]>1)\n\t{\n\t\t++scnt;\n\t\ttp[scnt]=0;\n\t\tlen[scnt]=a[1]-1;\n\t}\n\t\n\tfor(int i=2;i<=n+1;i++)\n\t\tif(i==n+1)\n\t\t{\n\t\t\t++scnt;\n\t\t\ttp[scnt]=1,len[scnt]=a[i-1]-a[start]+1;\n\t\t}\n\t\telse if(a[i]!=a[i-1]+1)\n\t\t{\n\t\t\t++scnt;\n\t\t\ttp[scnt]=1,len[scnt]=a[i-1]-a[start]+1;\n\t\t\t++scnt;\n\t\t\ttp[scnt]=0,len[scnt]=a[i]-a[i-1]-1;\n\t\t\tstart=i;\n\t\t}\n\t++scnt;\n\ttp[scnt]=0,len[scnt]=3;\n\tmemset(f,-1,sizeof(f));\n\tfor(int i=1;i<=scnt;i++)\n\t\tf[tp[i]][i][i]=0,f[tp[i]^1][i][i]=calc(len[i]);\n\tfor(int i=1;i<=scnt;i++)\n\t\tlen[i]+=len[i-1];\n\tint ans=solve(0,1,scnt);\n\tprintf(\"%d\\n\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntemplate<typename T> rread(T &x)\n{\n\tchar ch=getchar();\n\tfor (x=0;ch<'0'||ch>'9';ch=getchar());\n\tfor (;ch>='0'&&ch<='9';x=x*10+ch-'0',ch=getchar());\n}\n#define INF 0x3f3f3f3f\nvector<int> odd,even;\nbool vis[10000010];\nint prime[1000010],p_cnt;\nint n;\nint a[110];\nnamespace Network\n{\n\tstruct edge{\n\t\tint s,t,cap,next;\n\t}e[100010];\n\tint head[510],cnt;\n\tvoid addedge(int s,int t,int cap)\n\t{\n\t\te[cnt].s=s;e[cnt].t=t;e[cnt].cap=cap;e[cnt].next=head[s];head[s]=cnt++;\n\t\te[cnt].s=t;e[cnt].t=s;e[cnt].cap=0;e[cnt].next=head[t];head[t]=cnt++;\n\t}\n\tqueue<int> q;\n\tint s,t;\n\tint dis[510]; \n\tbool bfs()\n\t{\n\t\tq.push(s);\n\t\tmemset(dis,0x3f,sizeof(dis));\n\t\tdis[s]=0;\n\t\twhile (!q.empty())\n\t\t{\n\t\t\tint tmp=q.front();\n\t\t\tq.pop();\n\t\t\tfor (int i=head[tmp];i!=-1;i=e[i].next)\n\t\t\t\tif (e[i].cap && dis[e[i].t]==INF)\n\t\t\t\t{\n\t\t\t\t\tdis[e[i].t]=dis[tmp]+1;\n\t\t\t\t\tq.push(e[i].t);\n\t\t\t\t}\n\t\t}\n\t\treturn dis[t]!=INF;\n\t}\n\tint find(int x,int low)\n\t{\n\t    if (x==t)\n\t        return low;\n\t    int used=0;\n\t    for (int i=head[x];i!=-1;i=e[i].next)\n\t        if (e[i].cap>0 && dis[e[i].t]==dis[x]+1)\n\t        {\n\t            int flow=find(e[i].t,min(low-used,e[i].cap));\n                e[i].cap-=flow;\n                e[i^1].cap+=flow;\n                used+=flow;\n                if (used==low)\n                    return low;\n\t        }\n\t    if (!used)\n\t        dis[x]=-1;\n\t    return used;\n\t}\n\tint dinic()\n\t{\n\t\tmemset(head,0xff,sizeof(head));\n\t\tcnt=0;\n\t\ts=0,t=odd.size()+even.size()+1;\n\t\tfor (int i=0;i<odd.size();i++)\n\t\t\taddedge(s,i+1,1);\n\t\tfor (int i=0;i<even.size();i++)\n\t\t\taddedge(odd.size()+i+1,t,1);\n\t\tfor (int i=0;i<odd.size();i++)\n\t\t\tfor (int j=0;j<even.size();j++)\n\t\t\t\tif (!vis[abs(odd[i]-even[j])])\n\t\t\t\t\taddedge(i+1,odd.size()+j+1,1);\n\t    int ans=0;\n\t    while (bfs())\n\t        ans+=find(s,INF);\n\t    return ans;\n\t}\n}\nvoid ins(int x)\n{\n\tif (x&1)\n\t\todd.push_back(x);\n\telse\n\t\teven.push_back(x);\n}\nvoid pre()\n{\n\tvis[1]=1; \n    for (int i=2;i<=10000000;i++)\n    {\n        if (!vis[i])\n            prime[++p_cnt]=i;\n        for (int j=1;j<=p_cnt&&i*prime[j]<=10000000;j++)\n        {\n            vis[i*prime[j]]=1;\n            if (i%prime[j]==0)\n                break;\n        }\n    }\n}\nint main()\n{\n\trread(n);\n\tfor (int i=1;i<=n;i++)\n\t\trread(a[i]);\n\tsort(a+1,a+n+1);\n\ta[0]=-1;\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tif (a[i-1]!=a[i]-1)\n\t\t\tins(a[i]);\n\t\tif (a[i+1]!=a[i]+1)\n\t\t\tins(a[i]+1);\n\t}\n\tpre();\n\tint k=Network::dinic();\n\tprintf(\"%d\\n\",k+2*((odd.size()-k)/2+(even.size()-k)/2)+3*(odd.size()%2));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n\nint bipartiteMatching(const vector<vector<int> > &g) {  //g: left side\n\tint nleft = g.size(), nright = 0;\n\tfor (auto es = g.begin(); es != g.end();es++) if (!es->empty()) nright = max(nright, *max_element(es->begin(), es->end()) + 1);\n\tvector<int> matchL(nleft, -1), matchR(nright, -1), prev(nleft), seen(nleft, -1);\n\tfor (int i = 0; i < nleft; i++) {\n\t\tvector<int> stk; stk.push_back(i);\n\t\tseen[i] = i; prev[i] = -1;\n\t\twhile (!stk.empty()) {\n\t\t\tint v = stk.back(); stk.pop_back();\n\t\t\tfor (auto ui = g[v].begin(); ui != g[v].end();ui++) {\n\t\t\t\tint u = *ui;\n\t\t\t\tint j = matchR[u];\n\t\t\t\tif (j == -1) {\n\t\t\t\t\twhile (v != -1) {\n\t\t\t\t\t\tmatchR[u] = v;\n\t\t\t\t\t\tswap(u, matchL[v]);\n\t\t\t\t\t\tv = prev[v];\n\t\t\t\t\t}\n\t\t\t\t\tgoto break_;\n\t\t\t\t}\n\t\t\t\telse if (seen[j] < i) {\n\t\t\t\t\tseen[j] = i; prev[j] = v;\n\t\t\t\t\tstk.push_back(j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\tbreak_:;\n\t}\n\treturn (int)matchL.size() - count(matchL.begin(), matchL.end(), -1);\n}\n\n#define MAX 10000002\n\nint n;\n\nbool use[MAX];\n\nvector<int> v[2];\n\n\nset<int> s;\n\nint main(){\n\tcin >> n;\n\tfor (int i = 0; i < n; i++){\n\t\tint x;\n\t\tscanf(\"%d\", &x);\n\t\ts.insert(x);\n\t}\n\tfor (auto it = s.begin(); it != s.end();it++){\n\t\tint ich = (*it);\n\t\tif (s.count(ich - 1)==0){\n\t\t\tv[(ich - 1) & 1].push_back(ich - 1);\n\t\t}\n\t\tif (s.count(ich + 1)==0){\n\t\t\tv[ich & 1].push_back(ich);\n\t\t}\n\t}\n\tfor (int i = 2; i < MAX; i++){\n\t\tif (use[i] == false){\n\t\t\tfor (int j = i * 2; j < MAX; j+=i){\n\t\t\t\tuse[j] = true;\n\t\t\t}\n\t\t}\n\t}\n\tuse[0] = use[1] = use[2] = true;\n\tvector<vector<int> > g(v[0].size());\n\tfor (int j = 0; j < v[0].size(); j++){\n\t\tfor (int k = 0; k < v[1].size(); k++){\n\t\t\tif (!use[abs(v[1][k] - v[0][j])]){\n\t\t\t\tg[j].push_back(k);\n\t\t\t}\n\t\t}\n\t}\n\tint num = bipartiteMatching(g);\n\tint f = ((v[0].size() - num) / 2)*2;\n\tf += num;\n\tf += ((v[1].size() - num) / 2) * 2;\n\tif ((v[0].size()-num) & 1){\n\t\tif ((v[1].size() - num) % 2 == 0){\n\t\t\treturn 1;\n\t\t}\n\t\tf += 3;\n\t}\n\telse{\n\t\tif ((v[1].size() - num) & 1){\n\t\t\treturn 1;\n\t\t}\n\t}\n\tcout << f << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define C\ntypedef long long readtype;\n\n/* Header {{{ */\n#ifdef C\n#include <stdio.h>\n#include <math.h>\n#include <string.h>\n#define isdigit(a) ((a) >= '0' && (a) <= '9' ? true : false)\ntemplate<typename type> type abs(type a) { return a < 0 ? -a : a; }\ntemplate<typename type> type min(type a, type b) { return a < b ? a : b; }\ntemplate<typename type> type beMin(type &a, type b) { return a = (a < b ? a : b); }\ntemplate<typename type> type max(type a, type b) { return a > b ? a : b; }\ntemplate<typename type> type beMax(type &a, type b) { return a = (a > b ? a : b); }\ntemplate<typename type> void swap(type &a, type &b) { type c; c = a; a = b; b = c; }\n#endif\n\n#ifdef Cpp\n#include <bits/stdc++.h>\nusing namespace std;\n#endif\n\ntypedef long long var;\n\nreadtype read() {\n  readtype a = 0, c = getchar(), s = 0;\n  while (!isdigit(c)) s |= c == '-', c = getchar();\n  while (isdigit(c)) a = a * 10 + c - 48, c = getchar();\n  return s ? -a : a;\n}\n/* }}} */\n\nconst int N = 11004;\nconst int X = 1e7;\nconst int INF = 0x3f3f3f3f;\n\nint n, x[N];\nbool mark[X + 10];\nint cnt, prime[X];\nbool notprime[X + 10];\nint top, fi[N], ne[N * N], to[N * N], fl[N * N];\nint S, T;\nint head, tail, q[N], deep[N];\nint cur[N];\n\nvoid add(int u, int v, int w);\nint Dinic();\nbool BFS();\nint DFS(int t, int f);\n\nint main() {\n  /*\n#ifndef ONLINE_JUDGE\n  freopen(\"arc080d.in\", \"r\", stdin);\n  freopen(\"arc080d.out\", \"w\", stdout);\n#endif\n  */\n  notprime[1] = true;\n  for (int i = 2; i <= X; ++i) {\n    if (!notprime[i]) prime[++cnt] = i;\n    for (int j = 1; j <= cnt; ++j) {\n      if (prime[j] * i > X) break;\n      notprime[prime[j] * i] = true;\n      if (!(i % prime[j])) break;\n    }\n  }\n  for (int i = read(); i >= 1; --i) mark[read()] = true;\n  for (int i = 1; i <= X + 1; ++i) {\n    if (mark[i] ^ mark[i - 1]) x[++n] = i;\n  }\n  S = n + 1, T = n + 2;\n  int oddNum = 0, evenNum = 0;\n  for (int i = 1; i <= n; ++i) {\n    if (!(x[i] % 2)) add(i, T, 1), evenNum++;\n    else add(S, i, 1), oddNum++;\n  }\n  for (int i = 1; i <= n; ++i) {\n    if (!(x[i] % 2)) continue;\n    for (int j = 1; j <= n; ++j) {\n      if (x[j] % 2 || notprime[abs(x[i] - x[j])]) continue;\n      add(i, j, 1);\n      // printf(\"%d %d %d\\n\", x[i], x[j], x[i] - x[j]);\n    }\n  }\n\n  /*\n  for (int i = 1; i <= n; ++i) printf(\"%d \", x[i]);\n  puts(\"\");\n  */\n\n  int k = Dinic();\n  int res = k + ((evenNum - k) / 2 + (oddNum - k) / 2) * 2 + ((evenNum - k) % 2) * 3;\n  printf(\"%d\\n\", res);\n  return 0;\n}\n\nvoid add(int u, int v, int w) {\n  ne[++top] = fi[u], fi[u] = top, to[top] = v, fl[top] = w;\n  ne[++top] = fi[v], fi[v] = top, to[top] = u, fl[top] = 0;\n  // printf(\"%d %d %d\\n\", u, v, w);\n}\n\nint Dinic() {\n  int res = 0;\n  while (BFS()) {\n    for (int i = 1; i <= T; ++i) cur[i] = fi[i];\n    res += DFS(S, INF);\n  }\n  return res;\n}\n\nbool BFS() {\n  memset(deep, 0, sizeof(deep));\n  q[head = tail = 1] = S;\n  deep[S] = 1;\n  while (head <= tail) {\n    int f = q[head++];\n    for (int i = fi[f]; i; i = ne[i]) {\n      if (deep[to[i]] || !fl[i]) continue;\n      deep[to[i]] = deep[f] + 1;\n      q[++tail] = to[i];\n    }\n  }\n  return deep[T];\n}\n\nint DFS(int t, int f) {\n  if (t == T) return f;\n  int sumflow = 0;\n  for (int &i = cur[t]; i; i = ne[i]) {\n    if (deep[to[i]] != deep[t] + 1 || !fl[i]) continue;\n    int tflow = DFS(to[i], min(fl[i], f - sumflow));\n    sumflow += tflow;\n    fl[i] -= tflow, fl[i ^ 1] += tflow;\n  }\n  return sumflow;\n}\n"
  },
  {
    "language": "C++",
    "code": "// Copyright (C) 2017 __debug.\n\n// This program is free software; you can redistribute it and/or\n// modify it under the terms of the GNU General Public License as\n// published by the Free Software Foundation; version 3\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program; If not, see <http://www.gnu.org/licenses/>.\n\n\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/priority_queue.hpp>\n\n#define x first\n#define y second\n#define MP std::make_pair\n#define SZ(x) ((int)(x).size())\n#define ALL(x) (x).begin(), (x).end()\n#define DEBUG(...) fprintf(stderr, __VA_ARGS__)\n#ifdef __linux__\n#define getchar getchar_unlocked\n#define putchar putchar_unlocked\n#endif\n\nusing std::pair;\nusing std::vector;\nusing std::string;\n\ntypedef long long LL;\ntypedef pair<int, int> Pii;\n\nconst int oo = 0x3f3f3f3f;\n\ntemplate<typename T> inline bool chkmax(T &a, T b) { return a < b ? a = b, true : false; }\ntemplate<typename T> inline bool chkmin(T &a, T b) { return b < a ? a = b, true : false; }\nstring procStatus()\n{\n    std::ifstream t(\"/proc/self/status\");\n    return string(std::istreambuf_iterator<char>(t), std::istreambuf_iterator<char>());\n}\ntemplate<typename T> T read(T &x)\n{\n    int f = 1;\n    char ch = getchar();\n    for (; !isdigit(ch); ch = getchar())\n        f = (ch == '-' ? -1 : 1);\n    for (x = 0; isdigit(ch); ch = getchar())\n        x = 10 * x + ch - '0';\n    return x *= f;\n}\ntemplate<typename T> void write(T x)\n{\n    if (x == 0) {\n        putchar('0');\n        return;\n    }\n    if (x < 0) {\n        putchar('-');\n        x = -x;\n    }\n    static char s[20];\n    int top = 0;\n    for (; x; x /= 10)\n        s[++top] = x % 10 + '0';\n    while (top)\n        putchar(s[top--]);\n}\n// EOT\n\nconst int MAXN = 105, RNG = 1e7 + 5;\n\nint N;\nint X[MAXN];\n\nvoid input()\n{\n    read(N);\n    for (int i = 1; i <= N; ++i) {\n        read(X[i]);\n    }\n}\n\nint primes[RNG], totprimes;\nbool composite[RNG];\n\nvoid sieve(int n)\n{\n    composite[1] = true;\n    for (int i = 2; i <= n; ++i) {\n        if (!composite[i])\n            primes[totprimes++] = i;\n        for (int j = 0, x; (x = primes[j] * i) <= n; ++j) {\n            composite[x] = true;\n            if (i % primes[j] == 0)\n                break;\n        }\n    }\n}\n\nvector<int> odd, even;\nbool G[MAXN][MAXN];\nint match[MAXN];\nbool vis[MAXN];\n\nbool augment(int u)\n{\n    for (int v = 0; v < SZ(even); ++v) {\n        if (G[u][v] && !vis[v]) {\n            vis[v] = true;\n            if (!match[v] || augment(match[v])) {\n                match[v] = u;\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\nvoid solve()\n{\n    sieve(X[N]);\n\n    X[0] = -1;\n    X[N + 1] = RNG;\n    for (int i = 1; i <= N; ++i) {\n        if (X[i - 1] + 1 < X[i])\n            (X[i] & 1 ? odd : even).push_back(X[i]);\n        if (X[i] + 1 < X[i + 1])\n            ((X[i] + 1) & 1 ? odd : even).push_back(X[i] + 1);\n    }\n\n    for (int i = 0; i < SZ(odd); ++i) {\n        for (int j = 0; j < SZ(even); ++j) {\n            if (!composite[std::abs(odd[i] - even[j])])\n                G[i][j] = true;\n        }\n    }\n    int t = 0;\n    for (int i = 0; i < SZ(odd); ++i) {\n        memset(vis, 0, sizeof(vis));\n        t += augment(i);\n    }\n    int ans = t + ((SZ(odd) - t) / 2 + (SZ(even) - t) / 2) * 2 + (SZ(odd) - t) % 2 * 3;\n\n    printf(\"%d\\n\", ans);\n}\n\nint main()\n{\n#ifdef __DEBUG\n    freopen(\"F.in\", \"r\", stdin);\n    freopen(\"F.out\", \"w\", stdout);\n#endif\n\n    input();\n    solve();\n\n    return 0;\n}\n\n//              滥竽充数\n//            [先秦] 韩非\n//\n// 齐宣王使人吹竽，必三百人。\n// 南郭处士请为王吹竽，宣王说之，廪食以数百人。\n// 宣王死，湣王立，好一一听之，处士逃。\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nint n, c, val, x[209], match[209]; bool p[10000009], used[209]; vector<int> g[209];\nbool augment(int pos) {\n\tused[pos] = true;\n\tfor (int i : g[pos]) {\n\t\tif (match[i] < 0 || !used[match[i]] && augment(match[i])) {\n\t\t\tmatch[pos] = i;\n\t\t\tmatch[i] = pos;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\nint bipartite_matching() {\n\tint res = 0;\n\tfill(match, match + c, -1);\n\tfor (int i = 0; i < c; i++) {\n\t\tif (match[i] < 0) {\n\t\t\tfill(used, used + c, false);\n\t\t\tif (augment(i)) res++;\n\t\t}\n\t}\n\treturn res;\n}\nint main() {\n\tfor (int i = 3; i <= 10000000; i += 2) p[i] = true;\n\tfor (int i = 3; i * i <= 10000000; i += 2) {\n\t\tif (!p[i]) continue;\n\t\tfor (int j = i * i; j <= 10000000; j += i) p[j] = false;\n\t}\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> val;\n\t\tif (c == 0 || val != x[c - 1]) x[c++] = val;\n\t\telse c--;\n\t\tx[c++] = val + 1;\n\t}\n\tint cnt = 0;\n\tfor (int i = 0; i < c; i++) {\n\t\tif (x[i] % 2 == 0) cnt++;\n\t}\n\tfor (int i = 0; i < c; i++) {\n\t\tfor (int j = i + 1; j < c; j++) {\n\t\t\tif (p[x[j] - x[i]]) {\n\t\t\t\tg[i].push_back(j);\n\t\t\t\tg[j].push_back(i);\n\t\t\t}\n\t\t}\n\t}\n\tint ret = bipartite_matching();\n\tcout << c / 2 + (c / 2 - ret) + (cnt - ret) % 2 << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define maxn 10000005\n#define maxv 105\nusing namespace std;\nint prime[4100000];\nbool vis[maxn]= {0};\nint sum=0;\nint cnt1=0;\nint cnt2=0;\nvoid primejudge(int n)\n{\n    memset(vis,false,sizeof(vis));\n    vis[1]=true;\n    for(int i=2; i<=n; i++)\n    {\n        if(!vis[i])\n        {\n            prime[sum++]=i;\n        }\n        for(int j=0; j<sum&&i*prime[j]<=n; j++)\n        {\n            vis[i*prime[j]]=true;\n            if(i%prime[j]==0)\n                break;\n        }\n    }\n    vis[2]=true;\n}\nint a[maxv*5];\nint x[maxv*5];\nint mp1[maxv*5];\nint mp2[maxv*5];\nbool used[maxv*5];\nbool mps[maxv*2][maxv*2];\nint bel[maxv*5];\nbool findd(int q)\n{\n    int i,j;\n    for(j=1; j<=cnt2; j++)\n    {\n        if(mps[q][j]==true&&used[j]==false)\n        {\n            used[j]=true;\n            if(bel[j]==0||findd(bel[j]))\n            {\n                bel[j]=q;\n                return true;\n            }\n        }\n    }\n    return false;\n}\nint main()\n{\n    int n,i;\n    int match[maxv]= {0};\n    scanf(\"%d\",&n);\n    for(i=1; i<=n; i++)\n    {\n        scanf(\"%d\",&a[i]);\n        vis[a[i]]=true;\n    }\n    //cout<<\"ggggg\"<<endl;\n    int cnt=0;\n    for(i=1; i<maxn; i++)\n    {\n        if(vis[i]!=vis[i-1])\n        {\n            x[cnt++]=i;\n        }\n    }\n    primejudge(10000003);\n    //cout<<\"ggggg\"<<endl;\n    for(i=0; i<cnt; i++)\n    {\n        if(x[i]&1)\n            mp1[++cnt1]=x[i];\n        else\n            mp2[++cnt2]=x[i];\n    }\n    //cout<<\"ggggg\"<<endl;\n    for(i=1; i<=cnt1; i++)\n    {\n        for(int j=1; j<=cnt2; j++)\n        {\n            if(!vis[abs(mp1[i]-mp2[j])])\n            {\n                mps[i][j]=true;\n            }\n        }\n    }\n    int temp=0;\n    for(i=1; i<=cnt1; i++)\n    {\n        memset(used,false,sizeof(used));\n        if(findd(i))\n            temp++;\n    }\n    cnt1-=temp;\n    cnt2-=temp;\n    int ans=temp;\n    ans+=cnt1/2*2;\n    ans+=cnt2/2*2;\n    ans+=cnt1%2*3;\n    cout<<temp<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector> \n#include <list> \n#include <map> \n#include <set> \n#include <deque> \n#include <queue> \n#include <stack> \n#include <bitset> \n#include <algorithm> \n#include <functional> \n#include <numeric> \n#include <utility> \n#include <sstream> \n#include <iostream> \n#include <iomanip> \n#include <cstdio> \n#include <cmath> \n#include <cstdlib> \n#include <cctype> \n#include <string> \n#include <cstring> \n#include <ctime> \n\nusing namespace std;\n\n#define _int64 long long\n\nint b[11000000];\nint a[200];\nint d[200];\n\nint solve(int x)\n{\n  if (x==0) return 0;\n  else if (b[x]==0) return 1;\n  else if (x%2==0) return 2;\n  else return 3;\n}\n\nint main()\n{\n  int i,j,k,n,tot,totans,tmp;\n  memset(b,0,sizeof(b));\n  b[1]=1;\n  for (i=2;i<11000000;i++)\n    if (b[i]==0)\n    {\n      for (j=i+i;j<11000000;j+=i)\n        b[j]=1;\n    }\n  b[2]=1;\n  scanf(\"%d\",&n);\n  for (i=0;i<n;i++)\n    scanf(\"%d\",&a[i]);\n  sort(a,a+n);\n  d[0]=0;\n  for (i=1;i<=n;i++)\n  {\n    d[i]=2000000000;\n    tot=1;\n    totans=0;\n    for (j=i-1;j>=0;j--)\n    {\n      tmp=solve(tot);\n      //cout<<i<<\" \"<<j<<\" \"<<tot<<\" \"<<tmp<<\" \"<<totans<<endl;\n      if (tmp+totans+d[j]<d[i])\n        d[i]=tmp+totans+d[j];\n      if (j>0)\n      {\n        tot=a[i-1]-a[j-1]+1;\n        totans+=solve(a[j]-a[j-1]-1);\n      }\n    }\n    //cout<<\"i:\"<<d[i]<<endl;\n  }\n  printf(\"%d\\n\",d[n]);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <cstdio>\n#include <utility>\n\n#define Int register int\n\nusing namespace std;\n\nconst int MAXN = 100, MAXV = 1e7, MAXM = 5e4, MAXP = 664579, INF = 0x3f3f3f3f;\nint n, L, S, T;\nint pn, Prime[MAXP + 5];\nint CntL, CntR, Left[MAXV + 5], Right[MAXV + 5];\nint Cnte = 1, Head[MAXV + 5];\nbool Vis[MAXV + 5], d[MAXV + 5];\npair<int, int> Path[MAXV + 5];\nqueue<int> Q;\n\nstruct Edge { int To, Flow, nxt; } Graph[MAXV * 2 + 5];\n\ninline int Abs ( const int x ) { return x < 0 ? ~ x + 1 : x; }\n\ninline int Min ( const int a, const int b ) { return a < b ? a : b; }\n\ninline void Link ( const int s, const int t, const int f ) { Graph[++ Cnte] = { t, f, Head[s] }, Head[s] = Cnte; }\n\ninline void AddEdge ( const int s, const int t, const int f ) { Link ( s, t, f ), Link ( f, t, 0 ); }\n\ninline void Sieve ( const int n ) {\n\tVis[0] = Vis[1] = true;\n\tfor ( Int i = 2; i <= n; ++ i ) {\n\t\tif ( ! Vis[i] ) Prime[++ pn] = i;\n\t\tfor ( Int j = 1; j <= pn && i * Prime[j] <= n; ++ j ) {\n\t\t\tVis[i * Prime[j]] = true;\n\t\t\tif ( ! ( i % Prime[j] ) ) break;\n\t\t}\n\t}\n}\n\ninline bool BFS () {\n\tfor ( ; ! Q.empty (); Q.pop () );\n\tfor ( Int i = 1; i <= T; ++ i ) Vis[i] = false;\n\tQ.push ( S ), Vis[S] = true;\n\twhile ( ! Q.empty () ) {\n\t\tint u = Q.front (); Q.pop ();\n\t\tfor ( Int i = Head[u], v; i; i = Graph[i].nxt ) {\n\t\t\tif ( ! Vis[v = Graph[i].To] && Graph[i].Flow > 0 ) {\n\t\t\t\tQ.push ( v ), Vis[v] = true, Path[v] = { u, i };\n\t\t\t\tif ( v == T ) return true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\ninline int EK () {\n\tint ret = 0;\n\tfor ( ; BFS (); ) {\n\t\tint MinFlow = INF;\n\t\tfor ( Int u = T; u ^ S; u = Path[u].first ) MinFlow = Min ( MinFlow, Graph[Path[u].second].Flow );\n\t\tfor ( Int u = T; u ^ S; u = Path[u].first ) {\n\t\t\tGraph[Path[u].second].Flow -= MinFlow;\n\t\t\tGraph[Path[u].second ^ 1].Flow += MinFlow;\n\t\t}\n\t\tret += MinFlow;\n\t}\n\treturn ret;\n}\n\ninline void Work () {\n\tSieve ( MAXV );\n\tscanf ( \"%d\", &n );\n\tfor ( Int i = 1, x; i <= n; ++ i ) {\n\t\tscanf ( \"%d\", &x ), d[x] = true;\n\t\tL = L > x ? L : x;\n\t}\n\tfor ( Int i = 1; i <= L + 1; ++ i ) {\n\t\tif ( d[i] ^ d[i - 1] ) {\n\t\t\tif ( i & 1 ) {\n\t\t\t\tLeft[++ CntL] = i;\n\t\t\t} else {\n\t\t\t\tRight[++ CntR] = i;\n\t\t\t}\n\t\t}\n\t}\n\tS = 0, T = CntL + CntR + 1;\n\tfor ( Int i = 1; i <= CntL; ++ i ) AddEdge ( S, i, 1 );\n\tfor ( Int i = 1; i <= CntR; ++ i ) AddEdge ( i + CntL, T, 1 );\n\tfor ( Int i = 1; i <= CntL; ++ i ) {\n\t\tfor ( Int j = 1; j <= CntR; ++ j ) {\n\t\t\tif ( ! Vis[Abs ( Left[i] - Right[j] )] ) {\n\t\t\t\tAddEdge ( i, j + CntL, 1 );\n\t\t\t}\n\t\t}\n\t}\n\tint mxf = EK (), Ans = mxf;\n\tAns += ( CntL - mxf >> 1 << 1 ) + ( CntR - mxf >> 1 << 1 );\n\tAns += ( ( CntL - mxf ) & 1 ) * 3;\n\tprintf ( \"%d\\n\", Ans );\n}\n\nint main () {\n\tWork ();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n ***\n Question Name:\n ***\n Question Link:\n \n ***\n Idea:\n */\n\n#include <memory.h>\n#include <iomanip>\n#include <algorithm>\n#include <iostream>\n#include <iterator>\n#include <numeric>\n#include <sstream>\n#include <fstream>\n#include <cassert>\n#include <climits>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n#include <cstdio>\n#include <vector>\n#include <cmath>\n#include <functional>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <list>\n#include <map>\n#include <set>\n#include <unordered_set>\n#include <unordered_map>\n\n#define REP(i,s,n) for(int (i)=s; (i)<(int)(n);(i)++)\n#define RIT(it,c) for(__typeof(c.begin()) it = c.begin();it!=c.end();it++)\n#define ALL(x) x.begin(), x.end()\n#define SZ(x) (int)(x).size()\n#define MSET(m,v) memset(m,v,sizeof(m))\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef long double LD;\ntypedef vector<int> vi;\ntypedef pair<int,int> ii;\ntypedef vector<LL> vL;\ntypedef vector<bool> vb;\ntypedef unordered_set<int> ui;\ntypedef pair<LL,LL> pLL;\n\nclass PrimeFlip{\n    int N = 1E7, n, m;\n    vi mapping;\n    vb vist;\n    vector<vb> E;\n    void init(){\n        int K;\n        cin>>K;\n        unordered_set<int> cnt;\n        vi odds,evens;\n        for(int i=0;i<K;++i){\n            int x;\n            cin>>x;\n            if(cnt.count(x)) cnt.erase(x);\n            else cnt.insert(x);\n            cnt.insert(x+1);\n        }\n        for(auto k:cnt){\n            if(k%2) odds.push_back(k);\n            else evens.push_back(k);\n        }\n        cnt.clear();\n        n = (int)odds.size();\n        m = (int)evens.size();\n        mapping = vi(m,-1);\n        vist = vb(m,false);\n        E = vector<vb>(n,vb(m, false));\n        vb prime(N+1,true);\n        prime[0] = prime[1] = false;\n        for(int i=2;i<=N;++i) if(prime[i]){\n            for(int j=2;j*i<=N;++j) prime[i*j] = false;\n        }\n        prime[2] = false;\n        for(int i=0;i<n;++i) for(int j=0;j<m;++j) E[i][j] =prime[abs(odds[i]-evens[j])];\n        prime.clear();\n    }\n    bool arange(int i){\n        for(int j=0;j<m;++j) if(E[i][j] && !vist[j]){\n            vist[j] = true;\n            if(mapping[j]==-1 || arange(mapping[j])){\n                mapping[j] = i;\n                return true;\n            }\n        }\n        return false;\n    }\npublic:\n    void solve(){\n        init();\n        int cnt = 0;\n        for(int i=0;i<n;++i) cnt += arange(i);\n        int ans = cnt + ((n-cnt)/2 + (m-cnt)/2)*2 + ((m-cnt)%2)*3;\n        cout<<ans<<endl;\n    }\n};\n\n\n\nint main(){\n    PrimeFlip().solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int maxn=205;\nconst int maxm=10000005;\nconst int INF=0x3f3f3f;\n\nint n;\nint c[maxm];\nint p1[maxn],tot1=0,p2[maxn],tot2=0,nn;\n\nstruct Edge\n{\n    int from,to,capa,flow,nxt;\n}e[maxn*maxn];\n\nint h[maxn],tot=-1;\n\ninline void addedge(int a,int b,int c) { e[++tot].from=a; e[tot].to=b; e[tot].capa=c; e[tot].flow=0; e[tot].nxt=h[a]; h[a]=tot; }\n\nbool check(int p)\n{\n    if (p==1) return 0;\n    for (int i=2;i*i<=p;i++) if (p%i==0) return 0;\n    return 1;\n}\n\nint s,t,d[maxn],cur[maxn],vis[maxn];\n\nint dfs(int p,int a)\n{\n    if (p==t || !a) return a;\n    int flow=0,f;\n    for (int &i=cur[p];~i;i=e[i].nxt)\n    if (d[e[i].to]==d[p]+1 && e[i].capa>e[i].flow)\n    {\n        f=dfs(e[i].to,min(a,e[i].capa-e[i].flow));\n        if (f)\n        {\n            flow+=f; a-=f;\n            e[i].flow+=f; e[i^1].flow-=f;\n        }\n        if (!a) break;\n    }\n    if (a) d[p]=-1;\n    return flow;\n}\n\nint bfs()\n{\n    queue<int> q;\n    memset(vis,0,sizeof(vis));\n    q.push(s); vis[s]=1; d[s]=0;\n    while (!q.empty())\n    {\n        int o=q.front(); q.pop();\n        for (int i=h[o];~i;i=e[i].nxt)\n        if (!vis[e[i].to] && e[i].capa>e[i].flow)\n        {\n            vis[e[i].to]=1; q.push(e[i].to);\n            d[e[i].to]=d[o]+1;\n        }\n    }\n    return vis[t];\n}\n\nint Dinic()\n{\n    int flow=0;\n    while (bfs())\n    {\n        //cout<<\"GG\";\n        for (int i=0;i<=nn;i++) cur[i]=h[i];\n        flow+=dfs(s,INF);\n    }\n    return flow;\n}\n\nint main()\n{\n    scanf(\"%d\",&n);\n    int tmp,mx=0;\n    for (int i=1;i<=n;i++) { scanf(\"%d\",&tmp); mx=max(mx,tmp); c[tmp]=1; } mx++;\n    //for (int i=mx;i>=1;i--) c[i]=c[i-1]^c[i];\n    //for (int i=1;i<=mx;i++) cout<<c[i];\n    for (int i=1;i<=mx;i++)\n    if (c[i]!=c[i-1])\n    {\n        if (i&1) p1[++tot1]=i;\n            else p2[++tot2]=i;\n    }\n    nn=tot1+tot2+1; s=0; t=nn;\n    //cout<<nn<<endl;\n    memset(h,-1,sizeof(h));\n    for (int i=1;i<=tot1;i++) { addedge(s,i,1); addedge(i,s,0); }\n    for (int i=1;i<=tot2;i++) { addedge(i+tot1,t,1); addedge(t,i+tot1,0); }\n    for (int i=1;i<=tot1;i++)\n        for (int j=1;j<=tot2;j++)\n            if (check(abs(p2[j]-p1[i]))) { addedge(i,i+tot1,1); addedge(i+tot1,i,0); }\n    int flow=Dinic(),ans=0;\n    //cout<<\"GG\";\n    ans=flow;\n    ans+=(tot1-flow)/2*2+(tot2-flow)/2*2;\n    ans+=((tot1-flow)&1)*3;\n    cout<<ans;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <set>\n#include <map>\n#include <cmath>\n#include <string>\n#include <cstring>\n#include <sstream>\n#include <algorithm>\nusing namespace std;\n\nconst int Maxn = 105;\nconst int Inf = 1000000000;\n\nint n;\nint x[Maxn];\nint dp[Maxn];\n\nbool Prime(int x)\n{\n\tif (x <= 1) return false;\n\tif (x == 2) return true;\n\tif (x % 2 == 0) return false;\n\tfor (int i = 3; i * i <= x; i += 2)\n\t\tif (x % i == 0) return false;\n\treturn true;\n}\n\nint Get(int x)\n{\n\tif (x == 0) return 0;\n\tif (Prime(x) && x != 2) return 1;\n\tif (x == 4) return 4;\n\tif (x % 2 == 0) return 2;\n\treturn 3;\n}\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; i++)\n\t\tscanf(\"%d\", &x[i]);\n\tfill(dp, dp + n + 1, Inf); dp[0] = 0;\n\tfor (int i = 0; i < n; i++) if (dp[i] < Inf) {\n\t\tint add = 0;\n\t\tfor (int j = i; j < n; j++) {\n\t\t\tdp[j + 1] = min(dp[j + 1], dp[i] + add + Get(x[j] - x[i] + 1));\n\t\t\tif (j + 1 < n) add += Get(x[j + 1] - x[j] - 1);\n\t\t}\n\t}\n\tprintf(\"%d\\n\", dp[n]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ci const int&\t\nusing namespace std;\nconst int m=1e7;\nint n,a[110],p[210],sz,ip[m+10],pr[m+10],p1[210],p2[210],nw[210],n1,n2,pn;\nvector<int>t[210];\nbool Match(ci x){\n\tfor(int i=nw[x]+1;i<t[x].size();++i)if(!p2[t[x][i]]||Match(p2[t[x][i]]))return p2[t[x][i]]=x,nw[x]=i,true;\n\treturn false;\n}\nint main(){\n\tip[1]=1;\n\tfor(int i=2;i<=m;++i){\n\t\tif(!ip[i])pr[++sz]=i;\n\t\tfor(int j=1;j<=sz&&i*pr[j]<=m;++j){\n\t\t\tip[i*pr[j]]=1;\n\t\t\tif(i%pr[j]==0)break;\n\t\t}\n\t}\n\tscanf(\"%d\",&n),a[0]=-1,sz=0,ip[2]=1;\n\tfor(int i=1;i<=n;++i)scanf(\"%d\",&a[i]);\n\tfor(int i=1;i<=n;++i){\n\t\tif(a[i]-1!=a[i-1])p[++sz]=a[i],a[i]&1?++n1:++n2;\n\t\tif(a[i]+1!=a[i+1])p[++sz]=a[i]+1,a[i]&1?++n2:++n1;\n\t}\n\tfor(int i=1;i<=sz;++i)for(int j=i+1;j<=sz;++j)if(!ip[p[j]-p[i]])p[i]&1?t[i].push_back(j):t[j].push_back(i);\n\tfor(int i=1;i<=sz;++i)if(p[i]&1)nw[i]=-1,pn+=Match(i);\n\tprintf(\"%d\",pn+2*(n1-pn>>1)+2*(n2-pn>>1)+3*(n1-pn&1));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cstdlib>\nusing namespace std;\n\n#define re_ return\n#define in_ inline\n#define op_ operator\n#define inc(l, i, r) for(i=l; i<r; ++i)\n#define st_ static\ntypedef long long ll;\n\nconst int mxn=1<<8;\n\nint n, m, a[mxn], b[mxn<<1], cnt[2], h[mxn<<1];\nstruct edge{int v, o;} e[mxn<<2];\n\nin_ ll dP(ll a, ll b, ll p)\n{\n    st_ ll r;\n    for(r=1; b; a=a*a%p, b>>=1)\n        b&1? r=r*a%p: 0;\n    re_ r;\n}\n\nin_ char chk(ll a, ll p)\n{\n    st_ ll s, r, i;\n    for(r=p-1, s=0; ~r&1; ++s, r/=2);\n    if(i=dP(a, r, p), i==1 || i==p-1) re_ 1;\n    for(;s--;)\n        if((i=i*i%p)==p-1) re_ 1;\n    re_ 0;\n}\n\nin_ char isP(int p)\n{\n    if(p==2) re_ 1;\n    if(p==1 || ~p&1) re_ 0;\n    st_  int i;\n    inc(0, i, 32)\n        if(!chk(rand()%(p-2)+1, p))\n            re_ 0;\n    re_ 1;\n}\n\nin_ void aE(int u, int v)\n{\n    st_ int tot;\n    e[++tot]=(edge){v, h[u]}, u[h]=tot;\n}\n\nchar vis[mxn<<1];\nchar Hun(int u)\n{\n    st_ int f[mxn<<1];\n    int i, v;\n    for(i=u[h]; v=i[e].v; i=i[e].o)\n        if(!vis[v])\n            if(vis[v]=1, !f[v] || Hun(f[v]))\n            re_ f[v]=u, 1;\n    re_ 0;\n}\n\nint main()\n{\n    srand(998244353);\n    int i, j;\n    scanf(\"%d\", &n);\n    inc(0, i, n)\n        scanf(\"%d\", a+i);\n    inc(0, i, n)\n    {\n        if(!i || a[i]>a[i-1]+1)\n            b[++m]=a[i], ++cnt[a[i]&1];\n        if(i>n-2 || a[i]<a[i+1]-1)\n            b[++m]=a[i]+1, ++cnt[a[i]+1&1];\n    }\n    inc(1, i, m+1)\n        if(b[i]&1)\n            inc(1, j, m+1)\n                if(~b[j]&1 && isP(abs(b[i]-b[j])))\n                    aE(i, j);\n\n    j=0;\n    inc(1, i, m+1)\n        if(b[i]&1)\n            memset(vis, 0, sizeof(vis)),\n                j+=Hun(i);\n\n    printf(\"%d\\n\", cnt[0]+cnt[1]-j+(cnt[0]-j&1));\n//    printf(\"%d\\n\", m);\n//    for(;;) scanf(\"%d\", &i), printf(\"%d\\n\", isP(i));\n    re_ 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=5e3+11;\nconst int M=7e5+11;\nconst int MAXN=1e7+11;\nconst int inf=2147483647;\nint n,tot,cnt=1,t1,t2,mx,S,T,hd[M];\nint ans,pri[M],L[N<<1],R[N<<1];\nbitset<MAXN> is,a;\nstruct Edge{int nxt,to,val;}e[M];\nvoid ins(int x,int y,int z){\n    e[++cnt].nxt=hd[x];\n    e[cnt].to=y;hd[x]=cnt;\n    e[cnt].val=z;\n}\nvoid prepare(){\n    is[0]=is[1]=1;\n    for(int i=2;i<MAXN;i++){\n        if(!is[i]) pri[++tot]=i;\n        for(int j=1;j<=tot&&i*pri[j]<=MAXN;j++){\n            is[pri[j]*i]=1;\n            if(i%pri[j]==0) break;\n        }\n    }\n}\nnamespace Network_Flow{\n    queue<int> p;\n    int dep[N<<1];\n    int bfs(){\n        memset(dep,0,sizeof(dep));\n        p.push(S);dep[S]=1;\n        while(!p.empty()){\n            int x=p.front();p.pop();\n            for(int i=hd[x];i;i=e[i].nxt){\n                int y=e[i].to,v=e[i].val;\n                if(!dep[y]&&v){\n\t\t\t\t\tdep[y]=dep[x]+1;\n                    p.push(y);\n                }\n            }\n        }\n        if(dep[T]) return 1;\n        return 0;\n    }\n    int dfs(int x,int flow){\n        if(x==T||flow<=0) return flow;\n        int rest=0;\n        for(int i=hd[x];i;i=e[i].nxt){\n            int j=e[i].to;int v=e[i].val;\n            if(dep[j]==dep[x]+1&&v){\n                int now=dfs(j,min(v,flow));\n                e[i].val-=now;\n                e[i^1].val+=now;\n                flow-=now;rest+=now;\n                if(flow<=0) break;\n            }\n        }if(!rest) dep[x]=-1;\n        return rest;\n    }\n    int dinic(){\n        int maxflow=0;\n        while(bfs()) maxflow+=dfs(S,inf);\n\t\treturn maxflow;\n    }\n}\nint read(){\n    int x=0,f=1;char ch=getchar();\n    while(!isdigit(ch)){if(ch=='-')f=-f;ch=getchar();}\n    while(isdigit(ch)){x=x*10+ch-48;ch=getchar();}\n    return x*f;\n}\nsigned main(){\n    freopen(\"oatmeal.in\",\"r\",stdin);\n    freopen(\"oatmeal.out\",\"w\",stdout);\n    prepare();n=read();\n    for(int i=1;i<=n;i++){\n        int x=read();\n        a[x]=1,mx=max(mx,x);\n    }\n    for(int i=1;i<=mx+1;i++)\n        if(a[i]!=a[i-1]) i&1?L[++t1]=i:R[++t2]=i;\n    S=0,T=t1+t2+1;\n    for(int i=1;i<=t1;i++)\n        ins(S,i,1),ins(i,S,0);\n    for(int i=1;i<=t2;i++)\n        ins(i+t1,T,1),ins(T,i+t1,0);\n    for(int i=1;i<=t1;i++)\n        for(int j=1;j<=t2;j++)\n            if(!is[abs(L[i]-R[j])])\n                ins(i,j+t1,1),ins(j+t1,i,0);\n    int Val=Network_Flow::dinic();\n    ans+=Val;ans+=(t1-Val)/2*2+(t2-Val)/2*2;\n    ans+=((t1-Val)&1)*3;printf(\"%d\\n\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<cstring>\nusing namespace std;\nint n;\nint res;\nvector<int>v;\nint lst=-1;\nint match[210];\nint me,mo;\nint mx;\nbool f[10000010];\nbool ok[210][210];\nbool vis[210];\nint prm[1000010];\nint sz;\nint l;\nbool bp(int x)\n{\n\tfor(int i=0;i<l;i++)\n\t{\n\t\tif(!ok[x][i])continue;\n\t\tif(vis[i])continue;\n\t\tvis[i]=true;\n\t\tbool f=false;\n\t\tif(match[i]=-1)f=true;\n\t\telse\n\t\t{\n\t\t\tmatch[match[i]]=-1;\n\t\t\tif(bp(match[i]))f=true;\n\t\t} \n\t\tif(f)\n\t\t{\n\t\t\tmatch[i]=x;\n\t\t\tmatch[x]=i;\n\t\t\treturn true;\n\t\t}\n\t\tvis[i]=false;\n\t}\n\treturn false;\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint x;\n\t\tscanf(\"%d\",&x);\n\t\tif(x!=lst+1)\n\t\t{\n\t\t\tif(lst+1)v.push_back(lst+1);\n\t\t\tv.push_back(x);\n\t\t}\n\t\tlst=x;\n\t\tmx=lst+1;\n\t}\n\tv.push_back(lst+1);\n\tf[1]=true;\n\tfor(int i=2;i<=mx;i++)\n\t{\n\t\tif(!f[i])prm[++sz]=i;\n\t\tfor(int j=1;j<=sz;j++)\n\t\t{\n\t\t\tif(prm[j]*i>mx)break;\n\t\t\tf[prm[j]*i]=true;\n\t\t\tif(i%prm[j]==0)break;\n\t\t}\n\t}\n\tl=v.size();\n\tfor(int i=0;i<l;i++)\n\t{\n\t\tmatch[i]=-1;\n\t\tif(v[i]&1)mo++;else me++;\n\t\tfor(int j=i+1;j<l;j++)\n\t\t{\n\t\t\tif(v[j]-v[i]!=2 && !f[v[j]-v[i]])\n\t\t\t{\n\t\t\t\tok[i][j]=ok[j][i]=true;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<l;i++)\n\t{\n\t\tmemset(vis,false,sizeof(vis));\n\t\tif(bp(i))res++;\n\t}\n\tres/=2;\n\tprintf(\"%d\",res+((me-res)/2+(mo-res)/2)*2+((me-res)%2)*3);\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <algorithm>\n#include <cmath>\n#include <cstring>\n#include <complex>\n\nusing namespace std;\n\n//typedef\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long ll;\n\n#define omajinai ios::sync_with_stdio(false);cin.tie(0)\n\n//container util\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define UNIQUE(a)  (a).erase(unique((a).begin(),(a).end()),(a).end())\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(auto i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n#define RFOR(i,b,a) for(int i=(b)-1;i>=(a);--i)\n#define RREP(i,n) RFOR(i,n,0)\n\n//debug\n#define dump(x)  cerr << \"[L \" << __LINE__ << \"] \" << #x << \" = \" << (x) << \"\\n\";\n\n// i love camel\n\n/// flow\nconst int _V = 200; // _N\nVI G[_V];\nint match[_V];\nbool used[_V];\n\nvoid addEdge(int from, int to){\n\tG[from].push_back(to);\n\tG[to].push_back(from); // rev\n}\n\nbool dfs(int v){\n\tused[v] = true;\n\tREP(i, G[v].size()){\n\t\tint u = G[v][i], w = match[u];\n\t\tif(w < 0 || !used[w] && dfs(w)){\n\t\t\tmatch[v] = u;\n\t\t\tmatch[u] = v;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint bipartiteMatching(int V){\n\tint res=0;\n\tmemset(match, -1, sizeof match);\n\tREP(v, V){\n\t\tif(match[v]<0){\n\t\t\tmemset(used, 0, sizeof used);\n\t\t\tif(dfs(v)){\n\t\t\t\tres++;\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\n///\n\nbool isPrime(int x){\n\tif(x==1)return false;\n\tfor(int i=2;i*i<=x;i++){\n\t\tif(x%i==0)return false;\n\t}\n\treturn true;\n}\n\nVI diff_odd, diff_even;\nint main() {\n\tint n;\n\tcin >> n;\n\tint last=-1;\n#define ADD(a) ((a)%2 ? diff_odd : diff_even).push_back(a)\n\tREP(i, n){\n\t\tint x;\n\t\tcin >> x;\n\t\tif(x!=last+1){ // not 隣接\n\t\t\tif(last>0)ADD(last);\n\t\t\tADD(x-1);\n\t\t}\n\t\tlast = x;\n\t}\n\tADD(last);\n\tREP(i, diff_odd.size()){\n\t\tREP(j, diff_even.size()){\n\t\t\tint o = diff_odd[i], e = diff_even[j];\n\t\t\tif(isPrime(abs(o-e)))addEdge(i, j + diff_odd.size());\n\t\t}\n\t}\n\tint ans, k = ans = bipartiteMatching(diff_odd.size() + diff_even.size());\n\tans += (diff_odd.size() - k)/2*2;\n\tans += (diff_even.size() - k)/2*2;\n\tans += (diff_odd.size() - k) % 2 * 3;\n\tcout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\ninline int read()\n{\n\tint x = 0, op = 1; char ch = 0;\n\twhile(not isdigit(ch = getchar())) if(ch == '-') op = -op;\n\tdo x = x * 10 + (ch - '0'); while(isdigit(ch = getchar()));\n\treturn op * x;\n}\ninline bool check(int a, int x, int y, int z)\n{\n\tint u = 0, v = 0, w = 0;\n\t#define pows(a, b) \\\n\t\tu = (a), v = (b), w = 1;\\\n\t\twhile(v) { if(v & 1) w = w * u % x; u = u * u % x, v >>= 1; }\n\tpows(a, z);\n\tif(w > 1) { \n\t\tfor(int i = 0; i < y; i++) \n\t\t\tif(w == x - 1) return true;\n\t\treturn false;\n\t}\n\telse return true;\n}\nbool isprime(int x)\n{\n\tif(x == 2 || x == 7 || x == 61) return true;\n\tif(!(x % 2 && x % 7 && x % 61) || x == 1) return false;\n\tint y = 0, z = x - 1; while(!(z & 1)) y++, z >>= 1;\n\tbool ok = true;\t\n\tok &= check(2, x, y, z);\n\tok &= check(7, x, y, z);\n\tok &= check(61, x, y, z);\n\treturn ok;\n}\nint n = 0, m = 0, pos[150], whi[300];\nbool used[300]; int ans = 0;\nint pygo[300]; bool insta[300];\nbool dfs(int x, int p)\n{\n\t#define able(a, b) (abs(whi[a] - whi[b]) > 2 && isprime(abs(whi[a] - whi[b])))\n\tfor(int i = 1; i <= m; i++)\n\t\tif(not insta[i] && able(x, i) && p != i)\n\t\t{\n\t\t\tinsta[i] = true;\n\t\t\tif(!pygo[i] || dfs(pygo[i], p))\n\t\t\t{\n\t\t\t\tpygo[x] = i, pygo[i] = x;\n\t\t\t\tused[x] = used[i] = true;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\treturn false;\n}\nsigned main()\n{\n\tn = read();\n\tfor(int i = 1; i <= n; i++) pos[i] = read();\n\tsort(pos + 1, pos + n + 1);\n\tfor(int i = 1; i <= n; i++)\n\t{\n\t\tif(i == 1 || pos[i] != pos[i - 1] + 1) whi[++m] = pos[i];\n\t\tif(i == n || pos[i] != pos[i + 1] - 1) whi[++m] = pos[i] + 1;\n\t}\n\tfor(int i = 1; i <= m; i++)\n\t\tif(not used[i]) dfs(i, i);\n\tfor(int i = 1; i <= n; i++)\n\t\tif(used[i]) ans++;\n\tans >>= 1LL;\n\tint tot[2] = {0, 0};\n\tfor(int i = 1; i <= m; i++)\n\t\tif(not used[i]) tot[whi[i] & 1]++;\n\tans += (((tot[0] >> 1LL) + (tot[1] >> 1LL)) << 1LL) + (tot[0] & 1LL) * 3LL;\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"O2,unroll-loops\")\n#pragma GCC target(\"avx,popcnt\")\n#include<bits/stdc++.h>\n#define all(x) x.begin(), x.end()\n#define pb push_back\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nconst int maxn = 304, mod = 1e9 + 7, i2 = (mod+1)/2;\nint n, dp[maxn], p[1<<25];\nvector<pair<int, int>> a;\nvoid sieve() {\n\tfor(int i = 2; i < 1<<25; i++) {\n\t\tif(!p[i]) p[i] = i;\n\t\tfor(ll j = i*1ll*i; j < 1<<25; j += i) if(!p[j]) p[j] = i;\n\t}\n}\nmap<int, int> meme;\nint d(int x) {\n\tassert(x < 1<<25);\n\tif(meme.count(x)) return meme[x];\n\tif(p[x] == x && x > 2) return meme[x] = 1;\n\tint t = 2 + (x&1);\n\tfor(int i = 3; x-i > 2; i++)\n\t\tif(p[i]==i&&p[x-i]==x-i) {t = 2; break;}\n\treturn meme[x] = t;\n}\nint main() {\n\tcin.tie(0)->sync_with_stdio(0);\n\tsieve();\n\tcin >> n;\n\tfor(int p = -1, x, i = 0; i < n; i++) {\n\t\tcin >> x;\n\t\tif(x-p > 1) {\n\t\t\tif(p != -1) a.push_back({x-p-1, 0});\n\t\t\ta.push_back({0, 1});\n\t\t}\n\t\tp = x;\n\t\ta.back().first++;\n\t}\n\tmemset(dp, 0x3f, sizeof dp);\n\tdp[0] = 0;\n\tfor(int i = 0; i < a.size(); i++) {\n\t\t//cout << i << \" \" << dp[i] << \" - \" << a[i].first << \" \" << a[i].second << endl;\n\t\tif(a[i].second == 0) dp[i+1] = min(dp[i+1], dp[i]);\n\t\tint c = 0, l = 0;\n\t\tfor(int j = i; j+1 <= a.size(); j++) {\n\t\t\tl += a[j].first;\n\t\t\tif(a[j].second == 0)\n\t\t\t\tc += d(a[j].first);\n\t\t\t//cout <<i << \"-> \" << j+1 << \" \" << dp[i] << \" \" << c << \" \" << d(l) << '\\n';\n\t\t\tint x=  dp[i] + c + d(l);\n\t\t\t//cout <<i << \"-> \" << j+1 << \" \" << dp[i] << \" \" << c << \" \" << d(l) << '\\n';\n\t\t\tdp[j+1] = min(dp[j+1], x);\n\t\t}\n\t}\n\tcout << dp[a.size()];\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int maxp=1000050;\nint n;\nint sum[105],a[105],l[105],pos[105];\nint tot=0,tot1=0;\nint prime[maxp],primesize;\nbool isprime[maxp];\nvoid getlist(int listsize)\n{\n    memset(isprime,1,sizeof(isprime));\n    isprime[1]=false;\n    for(int i=2;i<=listsize;i++)\n    {\n        if(isprime[i]&&i!=2)\n\t\t\tprime[++primesize]=i;\n\t\tif(!isprime[i])\n\t\t\tcontinue;\n\t\tfor(int j=1;j<=primesize&&i*prime[j]<=listsize;j++)\n\t\t{\n            isprime[i*prime[j]]=false;\n            if(i%prime[j]==0)\n\t\t\t\tbreak;\n        }\n    }\n}\nint main() {\n\tgetlist(maxp-50);\n\tscanf(\"%d\",&n);\n\tsum[++tot]=1;\n\tfor(int i=1;i<=n;i++) {\n\t\tscanf(\"%d\",&a[i]);\n\t\tif(i==1)\n\t\t\tcontinue;\n\t\tif(a[i]==a[i-1]+1)\n\t\t\tsum[tot]++;\n\t\telse {\n\t\t\tif(sum[tot]==1) {\n\t\t\t\tl[++tot1]=tot;\n\t\t\t\tpos[tot1]=a[i-1];\n\t\t\t}\n\t\t\tsum[++tot]=1;\n\t\t}\n\t}\n\tif(sum[tot]==1) {\n\t\tl[++tot1]=tot;\n\t\tpos[tot1]=a[n];\n\t}\n\tint sumx=0;\n\tfor(int i=1;i<=tot;i++) {\n\t\tint tmp=sum[i];\n\t\tif(isprime[tmp]&&tmp!=2) {\n\t\t\tsumx++;\n\t\t\tcontinue;\n\t\t}\n\t\telse if(tmp%2==0) {\n\t\t\tsumx+=2;\n\t\t\tcontinue;\n\t\t}\n\t\telse if(tmp%2==1&&tmp!=1) {\n\t\t\tsumx+=3;\n\t\t\tcontinue;\n\t\t}\n\t\telse if(tmp==1)\n\t\t\tcontinue;\n\t}\n//\tcout<<tot1<<endl;\n\tfor(int i=1;i<=tot1;) {\n\t\tif(i<tot1) {\n\t\t\tif(l[i]==l[i+1]-1) {\n\t\t\t\tint tmp=pos[i+1],tmp1=pos[i];\n\t\t\t\tint tmp2=tmp-tmp1-1;\n\t\t\t\tint tmp3=tmp-tmp1;\n\t\t\t\tint tmp4=tmp-tmp1+1;\n\t\t\t\tif(tmp2%2==0) {\n\t\t\t\t\tsumx+=4;\n\t\t\t\t\ti+=2;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(isprime[tmp2]&&isprime[tmp4]) {\n\t\t\t\t\tsumx+=2;\n\t\t\t\t\ti+=2;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(isprime[tmp3]) {\n\t\t\t\t\tsumx+=2;\n\t\t\t\t\ti+=2;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif((isprime[tmp2]&&!isprime[tmp4])||(isprime[tmp4]&&!isprime[tmp2])) {\n\t\t\t\t\tsumx+=4;\n\t\t\t\t\ti+=2;\n\t\t\t\t\tcontinue;\n\t\t\t\t} \n\t\t\t}\n\t\t\telse {\n\t\t\t\tsumx+=3;\n\t\t\t\ti++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\telse if(i==tot1) {\n\t\t\tsumx+=3;\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\t}\n\tprintf(\"%d\\n\",sumx);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<cmath>\n#define N 210\n#define M 10000000\nusing namespace std;\nint prime[M+10],link[N],tot;\nbool p[M+10],vis[N];\nint n,m;\nbool can[N][N],s[M+10];\nvector<int>v[2];\nbool check(int u)\n{\n\tfor(int i=1;i<=m;i++)\n\tif(can[u][i] && !vis[i])\n\t{\n\t\tvis[i]=1;\n\t\tif(!link[i] || check(link[i]))\n \t\t{\n\t\t\tlink[i]=u;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\nint main()\n{\n\tp[1]=true;\n\tfor(int i=2;i<=M;i++)\n\t{\n\t\tif(!p[i]) prime[++tot]=i;\n\t\tfor(int j=1;j<=tot && i*prime[j]<=M;j++)\n\t\t{\n\t\t\tp[i*prime[j]]=1;\n\t\t\tif(i%prime[j]==0) break;\n\t\t}\n\t}\n\tscanf(\"%d\",&n);\n\tfor(int i=1,u;i<=n;i++) scanf(\"%d\",&u),s[u]=true;\n\tfor(int i=1;i<=M;i++)\n\tif(s[i]^s[i-1]) v[i&1].push_back(i);\n\tn=v[0].size(),m=v[1].size();\n\tfor(int i=0;i<n;i++)\n\t\tfor(int j=0;j<m;j++)\n\t\tif(!p[abs(v[0][i]-v[1][j])]) can[i+1][j+1]=true;\n\tint ans=0;\n    for(int i=1;i<=n;i++)\n\t{\n\t\tmemset(vis,0,sizeof(vis));\n\t\tans+=check(i);\n\t}\n\tint tmp=ans;\n\tans+=(n-ans)/2*2+(m-ans)/2*2;\n\tprintf(\"%d\",ans+((n&1)!=(tmp&1)?3:0));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define MAXN 10000010\n#define X first\n#define Y second\n\ntypedef long long ll;\n\nint N, n, m;\nbool flag[MAXN];\nint p[MAXN], x[200], y[200], link[200], vis[200];\n\nvector<int> E[200], lis, a;\n\nbool Find(int x)\n{\n\tfor (int i = 0; i < E[x].size(); ++i)\n\t{\n\t\tint y = E[x][i];\n\t\tif (vis[y]) continue;\n\t\tvis[y] = true;\n\t\tif (!link[y] || Find(link[y]))\n\t\t{\n\t\t\tlink[y] = x;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint Hungary()\n{\n\tint res = 0;\n\tfor (int i = 1; i <= n; ++i)\n\t{\n\t\tmemset(vis, 0, sizeof(vis));\n\t\tres += Find(i);\n\t}\n\treturn res;\n}\n\nint main()\n{\n\t//freopen(\"in.in\", \"r\", stdin);\n\t//freopen(\"out.out\", \"w\", stdout);\n\t\n\tflag[1] = true;\n\tfor (int i = 2;  i < MAXN; ++i)\n\t{\n\t\tif (!flag[i]) p[++p[0]] = i;\n\t\tfor (int j = 1; j <= p[0] && i * p[j] < MAXN; ++j)\n\t\t{\n\t\t\tflag[i * p[j]] = true;\n\t\t\tif (i % p[j] == 0)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tscanf(\"%d\", &N);\n\tfor (int i = 1; i <= N; ++i)\n\t{\n\t\tint x; \n\t\tscanf(\"%d\", &x);\n\t\tlis.push_back(x);\n\t}\n\tsort(lis.begin(), lis.end());\n\tfor (int i = 0; i < lis.size();)\n\t{\n\t\tint j = i;\n\t\twhile (j + 1 < lis.size() && lis[j + 1] == lis[i] + j + 1 - i)\n\t\t\t++j;\n\t\ta.push_back(lis[i]);\n\t\ta.push_back(lis[j] + 1);\n\t\ti = j + 1;\n\t}\n\tsort(a.begin(), a.end());\n\ta.erase(unique(a.begin(), a.end()), a.end());\n\tfor (int i = 0; i < a.size(); ++i)\n\t{\n\t\tif (a[i] & 1) x[++n] = a[i];\n\t\telse y[++m] = a[i];\n\t\t//cout << i << \" \" << a[i] << endl;\n\t}\n\tfor (int i = 1; i <= n; ++i)\n\t\tfor (int j = 1; j <= m; ++j)\n\t\t{\n\t\t\tint t = abs(x[i] - y[j]);\n\t\t\tif ((t & 1) && !flag[t])\n\t\t\t\tE[i].push_back(j);\n\t\t}\n\t\n\tint k = Hungary();\n\tint ans = k + ((n - k) / 2 + (m - k) / 2) * 2 + ((n - k) & 1) * 3;\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <cstdio>\n#include <algorithm>\nusing namespace std;\n\nconst int MAXN = int(1E7) + 5;\nconst int MAXM = 100;\n\nbool nprm[MAXN + 5];\nint prm[MAXN + 5], pcnt;\nvoid init() {\n\tnprm[1] = true;\n\tfor(int i=2;i<=MAXN;i++) {\n\t\tif( !nprm[i] ) prm[++pcnt] = i;\n\t\tfor(int j=1;prm[j]<=MAXN/i;j++) {\n\t\t\tnprm[i*prm[j]] = true;\n\t\t\tif( i % prm[j] == 0 ) break;\n\t\t}\n\t}\n}\n\nint a[MAXN + 5], b[2][MAXM + 5], cnt[2];\n\nint G[MAXM + 5][MAXM + 5], lnk[MAXM + 5];\nbool vis[MAXM + 5];\nbool dfs(int x) {\n\tfor(int i=1;i<=cnt[1];i++) {\n\t\tif( !vis[i] && G[x][i] ) {\n\t\t\tvis[i] = true;\n\t\t\tif( !lnk[i] || dfs(lnk[i]) ) {\n\t\t\t\tlnk[i] = x;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\nint abs(int x) {return x >= 0 ? x : -x;}\nint main() {\n\tinit();\n\tint N; scanf(\"%d\", &N);\n\tfor(int i=1;i<=N;i++) {\n\t\tint x; scanf(\"%d\", &x);\n\t\ta[x] = 1;\n\t}\n\tfor(int i=1;i<=MAXN;i++)\n\t\tif( a[i] != a[i-1] ) b[i%2][++cnt[i%2]] = i;\n\tint ans = 0;\n\tfor(int i=1;i<=cnt[0];i++)\n\t\tfor(int j=1;j<=cnt[1];j++)\n\t\t\tG[i][j] = (!nprm[abs(b[0][i] - b[1][j])]);\n\tfor(int i=1;i<=cnt[0];i++) {\n\t\tfor(int j=1;j<=cnt[1];j++) vis[j] = false;\n\t\tif( dfs(i) ) ans++;\n\t}\n\tans += (cnt[0] - ans)/2*2 + (cnt[1] - ans)/2*2;\n\tif( (cnt[0] - ans) & 1 ) ans += 3;\n\tprintf(\"%d\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nint n,vs[107],xs[207],xp=0;\nstruct edge{\n\tint to,nx,v;\n}e[100007];\nint ep=2,e0[207],h[207],q[207],S,T;\nbool bfs(){\n\tfor(int i=1;i<=T;++i)h[i]=0;\n\tint ql=0,qr=0;\n\th[q[++qr]=S]=1;\n\twhile(ql!=qr){\n\t\tint w=q[++ql];\n\t\tif(w==T)return 1;\n\t\tfor(int i=e0[w];i;i=e[i].nx)if(e[i].v){\n\t\t\tint u=e[i].to;\n\t\t\tif(!h[u])h[q[++qr]=u]=h[w]+1;\n\t\t}\n\t}\n\treturn 0;\n}\nint dfs(int w,int f){\n\tif(w==T)return f;\n\tint c,used=0;\n\tfor(int i=e0[w];i;i=e[i].nx)if(e[i].v){\n\t\tint u=e[i].to;\n\t\tif(h[u]!=h[w]+1)continue;\n\t\tc=dfs(u,std::min(e[i].v,f-used));\n\t\te[i].v-=c;\n\t\te[i^1].v+=c;\n\t\tused+=c;\n\t\tif(f==used)return f;\n\t}\n\th[w]=0;\n\treturn used;\n}\nbool isp(int x){\n\tif(x<0)x=-x;\n\tif((~x&1)||x<3)return 0;\n\tfor(int i=3;i*i<=x;i+=2)if(x%i==0)return 0;\n\treturn 1;\n}\nvoid ae(int a,int b){\n\te[ep]=(edge){b,e0[a],1};e0[a]=ep++;\n\te[ep]=(edge){a,e0[b],0};e0[b]=ep++;\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=0;i<n;++i)scanf(\"%d\",vs+i);\n\tfor(int i=0,j=0;i<n;i=j){\n\t\tfor(++j;j<n&&vs[j]-vs[j-1]==1;++j);\n\t\txs[++xp]=vs[i];\n\t\txs[++xp]=vs[j-1]+1;\n\t}\n\tS=xp+1,T=xp+2;\n\tint co=0,ce;\n\tfor(int i=1;i<=xp;++i){\n\t\tif(xs[i]&1){\n\t\t\tae(S,i);\n\t\t\t++co;\n\t\t\tfor(int j=1;j<=xp;++j)if((~xs[j]&1)&&isp(xs[j]-xs[i]))ae(i,j);\n\t\t}else ae(i,T);\n\t}\n\tint ans=0,c2;\n\twhile(bfs())ans+=dfs(S,0x3f3f);\n\tce=xp-co;\n\tco-=ans,ce-=ans;\n\tprintf(\"%d\\n\",ans+ce+co+(co&1));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#define repu(i,x,y) for (int i=x; i<=y; ++i)\nusing namespace std;\n\nint tot,n,m,t[110],a[110],b[110],prm[10010],map[110][110],link[110],ans;\nbool flag[10010];\n\nvoid insert(int x)\n{\n    (x&1?a[++n]:b[++m])=x;\n}\n\nbool check(int x)\n{\n    if (x<=2)\n        return 0;\n    for (int i=1; prm[i]*prm[i]<=x; ++i)\n        if (!(x%prm[i]))\n            return 0;\n    return 1;\n}\n\nbool hungary(int x)\n{\n    repu(i,1,map[x][0])\n        if (!flag[map[x][i]])\n        {\n            flag[map[x][i]]=1;\n            if (!link[map[x][i]] || hungary(link[map[x][i]]))\n            {\n                link[map[x][i]]=x;\n                return 1;\n            }\n        }\n    return 0;\n}\n\nint main()\n{\n    scanf(\"%d\",&tot);\n    repu(i,1,tot)\n        scanf(\"%d\",&t[i]);\n    for (int i=1,j; i<=tot; i=j+1)\n    {\n        for (j=i; j<tot && t[j+1]==t[j]+1; ++j);\n        insert(t[i]),insert(t[j]+1);\n    }\n    tot=0;\n    repu(i,2,1e4)\n        if (!flag[i])\n        {\n            prm[++tot]=i;\n            for (int j=i*2; j<=1e4; flag[j]=1,j+=i);\n        }\n    repu(i,1,n)\n        repu(j,1,m)\n            if (check(abs(a[i]-b[j])))\n                map[i][++map[i][0]]=j;\n    repu(i,1,n)\n    {\n        memset(flag,0,sizeof(bool)*(m+10));\n        ans+=hungary(i);\n    }\n    printf(\"%d\\n\",n+m-ans+((n-ans)&1));\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 10001000;\n\n\nint n,x[maxn],fre[maxn],p[maxn],isprime[maxn],even,odd,wrong;\nvector <int> edge[maxn],v2;\n\nbool fin(int u) {\n    if (fre[u]=wrong) return false;\n    fre[u]=wrong;\n    for (int j=0;j<edge[u].size();j++) {\n        int v=edge[u][j];\n        if (p[v]=0 || fin(p[v])) {\n            p[u]=v;\n            p[v]=u;\n            return true;\n        }\n    }\n    return false;\n}\n\nint main() {\n   // freopen(\"in.txt\",\"r\",stdin);\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    isprime[1]=1;\n    for (int i=2;i<=maxn;i++)\n        if (isprime[i]==0) {\n            for (int j=i+i;j<=maxn;j+=i) isprime[j]=1;\n        }\n    cin>>n;\n    for (int i=1;i<=n;i++) {\n        cin>>x[i];\n        fre[x[i]]=1;\n    }\n    even=0; odd=0; wrong=2;\n    int id=1;\n    while (id<=maxn) {\n        if (fre[id]==0) id++;\n        else {\n            v2.push_back(id);\n            if (id%2==0) even++; else odd++ ;\n            id++;\n            while (id<=maxn && fre[id]==1) id++;\n            v2.push_back(id);\n            if (id%2==0) even++; else odd++ ;\n        }\n    }\n    // for (int i=0;i<v2.size();i++) cout<<v2[i]<<\" \";\n   //  cout<<endl;\n   // cout<<\" \" <<even<<\" \"<<odd<<endl;\n    for (int i=0;i<v2.size();i++)\n        for (int j=i+1;j<v2.size();j++)\n            if (isprime[ v2[j] - v2[i] ]==0) {\n                edge[i+1].push_back(j+1);\n                edge[j+1].push_back(i+1);\n            }\n    int cnt=0;\n    for (int i=0;i<v2.size();i++) {\n        wrong++;\n        cnt+=(fin(i));\n    }\n   // cout<<cnt<<\" \" <<even<<\" \"<<odd<<endl;\n    cout<< cnt + ((even-cnt)/2 + (odd-cnt)/2) * 2 + (even%2)*3;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define STOPIT\n#include <bits/stdc++.h>\n#define loop(n) for (lint ngtkana_is_a_genius = 0; ngtkana_is_a_genius < lint(n); ngtkana_is_a_genius++)\n#define rep(i, begin, end) for (lint i = lint(begin); (i) < lint(end); i++)\n#define all(v) v.begin(), v.end()\n#define rand(l, r) std::uniform_int_distribution<>(l, r)(mt)\nusing lint = long long;\nauto mt = std::mt19937_64(std::random_device{}());\nauto cmn = [](auto& a, auto b){ if (a > b) {a = b; return true;} return false; };\nauto cmx = [](auto& a, auto b){ if (a < b) {a = b; return true;} return false; };\nvoid debug_impl() { std::cerr << std::endl; }\ntemplate <typename Head, typename... Tail>\nvoid debug_impl(Head head, Tail... tail) { std::cerr << \" \" << head; debug_impl(tail...); }\n#ifndef STOPIT\n#define debug(...)\\\n\tdo {\\\n\t\tstd::cerr << std::boolalpha << \"[\" << #__VA_ARGS__ << \"]:\";\\\n\t\tdebug_impl(__VA_ARGS__);\\\n\t\tstd::cerr << std::noboolalpha;\\\n\t} while (false)\n#else\n#define debug(...) {}\n#endif\n\nclass bipartite_matching {\n\t\tint L, R;\n\t\tstd::vector<std::vector<int>> graph;\n\t\tstd::vector<int> match, level;\n\n\t\tbool bfs() {\n\t\t\tstd::fill(level.begin(), level.end(), -1);\n\t\t\tstd::queue<int> que;\n\t\t\tfor (auto i = 0; i < L; i++) {\n\t\t\t\tif (match.at(i) < 0) {\n\t\t\t\t\tlevel.at(i) = 0;\n\t\t\t\t\tque.emplace(i);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbool ret = false;\n\t\t\twhile (!que.empty()) {\n\t\t\t\tauto crr = que.front(); que.pop();\n\t\t\t\tfor (auto nxt : graph.at(crr)) {\n\t\t\t\t\tif (level.at(nxt) != -1) continue;\n\t\t\t\t\tlevel.at(nxt) = level.at(crr) + 1;\n\t\t\t\t\tauto w = match.at(nxt);\n\t\t\t\t\tif (w == -1)\n\t\t\t\t\t\t{ ret = true; }\n\t\t\t\t\telse if (level.at(w) == -1) {\n\t\t\t\t\t\tlevel.at(w) = level.at(crr) + 1;\n\t\t\t\t\t\tque.emplace(w);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\n\t\tbool dfs(int crr) {\n\t\t\tfor (auto nxt : graph.at(crr)) {\n\t\t\t\tassert(level.at(nxt) <= level.at(crr) + 1);\n\t\t\t\tif (level.at(nxt) < level.at(crr) + 1) continue;\n\t\t\t\tlevel.at(nxt) = -1;\n\t\t\t\tauto w = match.at(nxt);\n\t\t\t\tif (w == -1 || dfs(w)) {\n\t\t\t\t\tmatch.at(nxt) = crr;\n\t\t\t\t\tmatch.at(crr) = nxt;\n\t\t\t\t\tlevel.at(crr) = -1;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tlevel.at(crr) = -1;\n\t\t\treturn false;\n\t\t}\n\n\tpublic:\n\t\tbipartite_matching()=default;\n\t\tbipartite_matching(int L, int R):\n\t\t\tL(L), R(R), graph(L + R), match(L + R, -1), level(L + R)\n\t\t\t{}\n\n\t\tvoid insert(int u, int v) {\n\t\t\tv += L;\n\t\t\tgraph.at(u).emplace_back(v);\n\t\t\tgraph.at(v).emplace_back(u);\n\t\t}\n\n\n\t\tint build () {\n\t\t\tauto ret = 0;\n\t\t\twhile (bfs()) {\n\t\t\t\tfor (int i = 0; i < L; i++) {\n\t\t\t\t\tif (match.at(i) == -1 && dfs(i))\n\t\t\t\t\t\t{ ret++; }\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\n\t\tauto collect() const {return match;}\n\n\t\tauto count() const {\n\t\t\tauto k = L + R - std::count(match.begin(), match.end(), -1);\n\t\t\tassert(k % 2 == 0);\n\t\t\treturn k / 2;\n\t\t}\n};\n\ntemplate < typename Container, typename Value = typename Container::value_type, std::enable_if_t<!std::is_same< Container, std::string >::value, std::nullptr_t> = nullptr>\nstd::istream& operator>> (std::istream& is, Container& v)\n\t{ for (auto & x : v) { is >> x; } return is; }\n\ntemplate < typename Container, typename Value = typename Container::value_type, std::enable_if_t<!std::is_same< Container, std::string >::value, std::nullptr_t> = nullptr >\nstd::ostream& operator<< (std::ostream& os, Container const& v) {\n os << \"{\";\n\tfor (auto it = v.begin(); it != v.end(); it++)\n\t\t{os << (it != v.begin() ? \",\" : \"\") << *it;}\n\treturn os << \"}\";\n}\n\ntemplate < class Container, class Value = typename Container::value_type >\nauto run_length(Container const& v) {\n\tauto n = (int)v.size();\n\tif (n == 0)\n\t\t{ return std::vector< std::pair< Value, int > >{}; }\n\tauto pos = std::vector< int >{};\n\tfor (auto i = 1; i < n; i++) {\n\t\tif (v.at(i - 1) != v.at(i))\n\t\t\t{ pos.emplace_back(i); }\n\t}\n\tpos.emplace_back(n);\n\tauto m = (int)pos.size();\n\tauto len = std::vector< int >(m);\n\tstd::adjacent_difference(pos.begin(), pos.end(), len.begin());\n\tauto ret = std::vector< std::pair< Value, int > >(m);\n\tfor (auto i = 0; i != m; i++)\n\t\t{ ret.at(i) = {v.at(pos.at(i) - 1), len.at(i)}; }\n\treturn ret;\n}\n\ntemplate < std::size_t I, typename Container,\n\ttypename Value = typename std::tuple_element_t< I, typename Container::value_type >>\ninline auto project(Container const& v) {\n\tstd::vector< Value > ret(v.size());\n\tstd::transform(v.begin(), v.end(), ret.begin(), [](auto&& t){ return std::get< I >(t); });\n\treturn ret;\n}\n\nint main() {\n\tstd::cin.tie(0); std::cin.sync_with_stdio(false);\n\tconstexpr int xmax = 10'000'010;\n\tauto isp = [&] {\n\t\tstd::vector<int> isp(xmax, true);\n\t\tisp.at(0) = false;\n\t\tisp.at(1) = false;\n\t\tfor (size_t p = 2; p < xmax; p++) {\n\t\t\tif (!isp.at(p)) continue;\n\t\t\tfor (size_t j = 2; j * p < xmax; j++) {\n\t\t\t\tisp.at(p * j) = false;\n\t\t\t}\n\t\t}\n\t\treturn isp;\n\t}();\n\n\tint n; std::cin >> n;\n\tstd::vector<int> a(n); std::cin>>a;\n\tdebug(a);\n\n\tstd::vector<int> ckd(xmax,false);\n\tfor (int x : a) ckd.at(x) = true;\n\tauto c = project<1>(run_length(ckd));\n\tdebug(c);\n\tc.pop_back();\n\tdebug(c);\n\tstd::partial_sum(all(c), c.begin());\n\tassert((int)c.size() % 2 == 0);\n\n\tstd::vector<std::vector<int>> b(2);\n\tfor (int x : c) {\n\t  b.at(x%2).emplace_back(x);\n\t}\n\tdebug(b);\n\tstd::vector<int> sz(2);\n\tsz.at(0) = b.at(0).size();\n\tsz.at(1) = b.at(1).size();\n\tbipartite_matching bm(sz.at(0), sz.at(1));\n\n\trep(i0,0,sz.at(0))\n\trep(i1,0,sz.at(1)) {\n\t\tdebug(i0,i1);\n\t\tint x = b.at(0).at(i0);\n\t\tint y = b.at(1).at(i1);\n\t\tint z = x - y;\n\t\tif (z < 0) z = -z;\n\t\tif (isp.at(z)) {\n\t\t\tbm.insert(i0, i1);\n\t\t}\n\t}\n\tbm.build();\n\n\tint k = sz.at(0);\n\tint l = sz.at(1);\n\tint m = bm.count();\n\tdebug(k,l,m);\n\tint ans = m + (k-m) + (l-m) + (k-m)%2;\n\tstd::cout << ans << std::endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define sqr(x) ((x)*(x))\n#define ll long long\n#define ull unsigned long long\n#define ui unsigned int\n#define ld long double\n#define vi vector<int>\n#define HEAP(T) priority_queue<T>\n#define heap(...) priority_queue<__VA_ARGS__,vector<__VA_ARGS__>,greater<__VA_ARGS__> > \n#define pii pair<int,int>\n#define pb push_back\n#define mp make_pair\n#define debuge cerr<<\"isok\"<<endl\n#define debug(x) cerr<<#x<<\"=\"<<x<<endl\n#define error(...) fprintf(stderr,__VA_ARGS__)\n#define SS second\n#define FF first\n#define ls (k<<1)\n#define rs (k<<1|1)\n#define inf 0x3f3f3f3f\n#define LL long long\n#define clr(a,x) memset(a,x,sizeof(a))\n#define cpy(a,x) memcpy(a,x,sizeof(a))\n#define file(x) freopen(x\".in\",\"r\",stdin),freopen(x\".out\",\"w\",stdout)\nusing namespace std;\n\nconst int N=20000005,M=100005,mod=1e9+7;\ntemplate<class T> inline void gmin(T &x,const T &y){if(x>y) x=y;}\ntemplate<class T> inline void gmax(T &x,const T &y){if(x<y) x=y;}\ntemplate<class T,class S> inline void ch(T &x,const S y){x=(x+y)%mod;}\nconst int BufferSize=1<<16;\nchar buffer[BufferSize],*Bufferhead,*Buffertail;\nbool Terminal;\ninline char Getchar(){\n\tif(Bufferhead==Buffertail){\n\t\tint l=fread(buffer,1,BufferSize,stdin);\n\t\tif(!l){Terminal=1;return 0;}\n\t\tBuffertail=(Bufferhead=buffer)+l;\n\t}\n\treturn *Bufferhead++;\n}\ntemplate<class T>inline bool read(T &x){\n\tx=0;char c=Getchar(),rev=0;\n\twhile(c<'0'||c>'9'){c=Getchar();rev|=c=='-';if(Terminal)return 0;}\n\twhile(c>='0'&&c<='9') x=x*10+c-'0',c=Getchar();\n\tx=rev?-x:x;\n\treturn 1;\n}\ninline bool reads(char *x){\n\tchar c=Getchar();\n\twhile(c<33||c>126){c=Getchar();if(Terminal)return 0;}\n\twhile(c>=33&&c<=126) (*x++)=c,c=Getchar();\n\t*x=0;return 1;\n}\ntemplate<class T>inline void print(T x,const char c){\n\tif(!x){putchar('0');putchar(c);return;}\n\tif(x<0) putchar('-'),x=-x;\n\tint m=0,a[10];\n\twhile(x) a[m++]=x%10,x/=10;\n\twhile(m--) putchar(a[m]+'0');\n\tputchar(c);\n}\ninline int exp(int x,int y,const int mod=::mod){\n\tint ans=1;\n\twhile(y){\n\t\tif(y&1) ans=(ll)ans*x%mod;\n\t\tx=(ll)x*x%mod;y>>=1;\n\t}return ans;\n}\n\nconst int INF = 2147483647;\n\nconst int MaxN = 400;\nconst int MaxM = 79800;\n\ntemplate <class T>\ninline void tension(T &a, const T &b)\n{\n\tif (b < a)\n\t\ta = b;\n}\ntemplate <class T>\ninline void relax(T &a, const T &b)\n{\n\tif (b > a)\n\t\ta = b;\n}\ntemplate <class T>\ninline int size(const T &a)\n{\n\treturn (int)a.size();\n}\n\ninline int getint()\n{\n\tchar c;\n\twhile (c = getchar(), '0' > c || c > '9');\n\n\tint res = c - '0';\n\twhile (c = getchar(), '0' <= c && c <= '9')\n\t\tres = res * 10 + c - '0';\n\treturn res;\n}\n\nconst int MaxNX = MaxN + MaxN;\n\nstruct edge\n{\n\tint v, u, w;\n\n\tedge(){}\n\tedge(const int &_v, const int &_u, const int &_w)\n\t\t: v(_v), u(_u), w(_w){}\n};\n\nint n, m;\nedge mat[MaxNX + 1][MaxNX + 1];\n\nint n_matches;\nLL tot_weight;\nint mate[MaxNX + 1];\nint lab[MaxNX + 1];\n\nint q_n, q[MaxN];\nint fa[MaxNX + 1], col[MaxNX + 1];\nint slackv[MaxNX + 1];\n\nint n_x;\nint bel[MaxNX + 1], blofrom[MaxNX + 1][MaxNX + 1];\nvector<int> bloch[MaxNX + 1];\n\ninline int e_delta(const edge &e) // does not work inside blossoms\n{\n\treturn lab[e.v] + lab[e.u] - mat[e.v][e.u].w * 2;\n}\ninline void update_slackv(int v, int x)\n{\n\tif (!slackv[x] || e_delta(mat[v][x]) < e_delta(mat[slackv[x]][x]))\n\t\tslackv[x] = v;\n}\ninline void calc_slackv(int x)\n{\n\tslackv[x] = 0;\n\tfor (int v = 1; v <= n; v++)\n\t\tif (mat[v][x].w > 0 && bel[v] != x && col[bel[v]] == 0)\n\t\t\tupdate_slackv(v, x);\n}\n\ninline void q_push(int x)\n{\n\tif (x <= n)\n\t\tq[q_n++] = x;\n\telse\n\t{\n\t\tfor (int i = 0; i < size(bloch[x]); i++)\n\t\t\tq_push(bloch[x][i]);\n\t}\n}\ninline void set_mate(int xv, int xu)\n{\n\tmate[xv] = mat[xv][xu].u;\n\tif (xv > n)\n\t{\n\t\tedge e = mat[xv][xu];\n\t\tint xr = blofrom[xv][e.v];\n\t\tint pr = find(bloch[xv].begin(), bloch[xv].end(), xr) - bloch[xv].begin();\n\t\tif (pr % 2 == 1)\n\t\t{\n\t\t\treverse(bloch[xv].begin() + 1, bloch[xv].end());\n\t\t\tpr = size(bloch[xv]) - pr;\n\t\t}\n\n\t\tfor (int i = 0; i < pr; i++)\n\t\t\tset_mate(bloch[xv][i], bloch[xv][i ^ 1]);\n\t\tset_mate(xr, xu);\n\n\t\trotate(bloch[xv].begin(), bloch[xv].begin() + pr, bloch[xv].end());\n\t}\n}\ninline void set_bel(int x, int b)\n{\n\tbel[x] = b;\n\tif (x > n)\n\t{\n\t\tfor (int i = 0; i < size(bloch[x]); i++)\n\t\t\tset_bel(bloch[x][i], b);\n\t}\n}\n\ninline void augment(int xv, int xu)\n{\n\twhile (true)\n\t{\n\t\tint xnu = bel[mate[xv]];\n\t\tset_mate(xv, xu);\n\t\tif (!xnu)\n\t\t\treturn;\n\t\tset_mate(xnu, bel[fa[xnu]]);\n\t\txv = bel[fa[xnu]], xu = xnu;\n\t}\n}\ninline int get_lca(int xv, int xu)\n{\n\tstatic bool book[MaxNX + 1];\n\tfor (int x = 1; x <= n_x; x++)\n\t\tbook[x] = false;\n\twhile (xv || xu)\n\t{\n\t\tif (xv)\n\t\t{\n\t\t\tif (book[xv])\n\t\t\t\treturn xv;\n\t\t\tbook[xv] = true;\n\t\t\txv = bel[mate[xv]];\n\t\t\tif (xv)\n\t\t\t\txv = bel[fa[xv]];\n\t\t}\n\t\tswap(xv, xu);\n\t}\n\treturn 0;\n}\n\ninline void add_blossom(int xv, int xa, int xu)\n{\n\tint b = n + 1;\n\twhile (b <= n_x && bel[b])\n\t\tb++;\n\tif (b > n_x)\n\t\tn_x++;\n\n\tlab[b] = 0;\n\tcol[b] = 0;\n\n\tmate[b] = mate[xa];\n\n\tbloch[b].clear();\n\tbloch[b].push_back(xa);\n\tfor (int x = xv; x != xa; x = bel[fa[bel[mate[x]]]])\n\t\tbloch[b].push_back(x), bloch[b].push_back(bel[mate[x]]), q_push(bel[mate[x]]);\n\treverse(bloch[b].begin() + 1, bloch[b].end());\n\tfor (int x = xu; x != xa; x = bel[fa[bel[mate[x]]]])\n\t\tbloch[b].push_back(x), bloch[b].push_back(bel[mate[x]]), q_push(bel[mate[x]]);\n\n\tset_bel(b, b);\n\n\tfor (int x = 1; x <= n_x; x++)\n\t{\n\t\tmat[b][x].w = mat[x][b].w = 0;\n\t\tblofrom[b][x] = 0;\n\t}\n\tfor (int i = 0; i < size(bloch[b]); i++)\n\t{\n\t\tint xs = bloch[b][i];\n\t\tfor (int x = 1; x <= n_x; x++)\n\t\t\tif (mat[b][x].w == 0 || e_delta(mat[xs][x]) < e_delta(mat[b][x]))\n\t\t\t\tmat[b][x] = mat[xs][x], mat[x][b] = mat[x][xs];\n\t\tfor (int x = 1; x <= n_x; x++)\n\t\t\tif (blofrom[xs][x])\n\t\t\t\tblofrom[b][x] = xs;\n\t}\n\tcalc_slackv(b);\n}\ninline void expand_blossom1(int b) // lab[b] == 1\n{\n\tfor (int i = 0; i < size(bloch[b]); i++)\n\t\tset_bel(bloch[b][i], bloch[b][i]);\n\n\tint xr = blofrom[b][mat[b][fa[b]].v];\n\tint pr = find(bloch[b].begin(), bloch[b].end(), xr) - bloch[b].begin();\n\tif (pr % 2 == 1)\n\t{\n\t\treverse(bloch[b].begin() + 1, bloch[b].end());\n\t\tpr = size(bloch[b]) - pr;\n\t}\n\n\tfor (int i = 0; i < pr; i += 2)\n\t{\n\t\tint xs = bloch[b][i], xns = bloch[b][i + 1];\n\t\tfa[xs] = mat[xns][xs].v;\n\t\tcol[xs] = 1, col[xns] = 0;\n\t\tslackv[xs] = 0, calc_slackv(xns);\n\t\tq_push(xns);\n\t}\n\tcol[xr] = 1;\n\tfa[xr] = fa[b];\n\tfor (int i = pr + 1; i < size(bloch[b]); i++)\n\t{\n\t\tint xs = bloch[b][i];\n\t\tcol[xs] = -1;\n\t\tcalc_slackv(xs);\n\t}\n\n\tbel[b] = 0;\n}\ninline void expand_blossom_final(int b) // at the final stage\n{\n\tfor (int i = 0; i < size(bloch[b]); i++)\n\t{\n\t\tif (bloch[b][i] > n && lab[bloch[b][i]] == 0)\n\t\t\texpand_blossom_final(bloch[b][i]);\n\t\telse\n\t\t\tset_bel(bloch[b][i], bloch[b][i]);\n\t}\n\tbel[b] = 0;\n}\n\ninline bool on_found_edge(const edge &e)\n{\n\tint xv = bel[e.v], xu = bel[e.u];\n\tif (col[xu] == -1)\n\t{\n\t\tint nv = bel[mate[xu]];\n\t\tfa[xu] = e.v;\n\t\tcol[xu] = 1, col[nv] = 0;\n\t\tslackv[xu] = slackv[nv] = 0;\n\t\tq_push(nv);\n\t}\n\telse if (col[xu] == 0)\n\t{\n\t\tint xa = get_lca(xv, xu);\n\t\tif (!xa)\n\t\t{\n\t\t\taugment(xv, xu), augment(xu, xv);\n\t\t\tfor (int b = n + 1; b <= n_x; b++)\n\t\t\t\tif (bel[b] == b && lab[b] == 0)\n\t\t\t\t\texpand_blossom_final(b);\n\t\t\treturn true;\n\t\t}\n\t\telse\n\t\t\tadd_blossom(xv, xa, xu);\n\t}\n\treturn false;\n}\n\nbool match()\n{\n\tfor (int x = 1; x <= n_x; x++)\n\t\tcol[x] = -1, slackv[x] = 0;\n\n\tq_n = 0;\n\tfor (int x = 1; x <= n_x; x++)\n\t\tif (bel[x] == x && !mate[x])\n\t\t\tfa[x] = 0, col[x] = 0, slackv[x] = 0, q_push(x);\n\tif (q_n == 0)\n\t\treturn false;\n\n\twhile (true)\n\t{\n\t\tfor (int i = 0; i < q_n; i++)\n\t\t{\n\t\t\tint v = q[i];\n\t\t\tfor (int u = 1; u <= n; u++)\n\t\t\t\tif (mat[v][u].w > 0 && bel[v] != bel[u])\n\t\t\t\t{\n\t\t\t\t\tint d = e_delta(mat[v][u]);\n\t\t\t\t\tif (d == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (on_found_edge(mat[v][u]))\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\telse if (col[bel[u]] == -1 || col[bel[u]] == 0)\n\t\t\t\t\t\tupdate_slackv(v, bel[u]);\n\t\t\t\t}\n\t\t}\n\n\t\tint d = INF;\n\t\tfor (int v = 1; v <= n; v++)\n\t\t\tif (col[bel[v]] == 0)\n\t\t\t\ttension(d, lab[v]);\n\t\tfor (int b = n + 1; b <= n_x; b++)\n\t\t\tif (bel[b] == b && col[b] == 1)\n\t\t\t\ttension(d, lab[b] / 2);\n\t\tfor (int x = 1; x <= n_x; x++)\n\t\t\tif (bel[x] == x && slackv[x])\n\t\t\t{\n\t\t\t\tif (col[x] == -1)\n\t\t\t\t\ttension(d, e_delta(mat[slackv[x]][x]));\n\t\t\t\telse if (col[x] == 0)\n\t\t\t\t\ttension(d, e_delta(mat[slackv[x]][x]) / 2);\n\t\t\t}\n\n\t\tfor (int v = 1; v <= n; v++)\n\t\t{\n\t\t\tif (col[bel[v]] == 0)\n\t\t\t\tlab[v] -= d;\n\t\t\telse if (col[bel[v]] == 1)\n\t\t\t\tlab[v] += d;\n\t\t}\n\t\tfor (int b = n + 1; b <= n_x; b++)\n\t\t\tif (bel[b] == b)\n\t\t\t{\n\t\t\t\tif (col[bel[b]] == 0)\n\t\t\t\t\tlab[b] += d * 2;\n\t\t\t\telse if (col[bel[b]] == 1)\n\t\t\t\t\tlab[b] -= d * 2;\n\t\t\t}\n\n\t\tq_n = 0;\n\t\tfor (int v = 1; v <= n; v++)\n\t\t\tif (lab[v] == 0) // all unmatched vertices' labels are zero! cheers!\n\t\t\t\treturn false;\n\t\tfor (int x = 1; x <= n_x; x++)\n\t\t\tif (bel[x] == x && slackv[x] && bel[slackv[x]] != x && e_delta(mat[slackv[x]][x]) == 0)\n\t\t\t{\n\t\t\t\tif (on_found_edge(mat[slackv[x]][x]))\n\t\t\t\t\treturn true;\n\t\t\t}\n\t\tfor (int b = n + 1; b <= n_x; b++)\n\t\t\tif (bel[b] == b && col[b] == 1 && lab[b] == 0)\n\t\t\t\texpand_blossom1(b);\n\t}\n\treturn false;\n}\n\nvoid calc_max_weight_match()\n{\n\tfor (int v = 1; v <= n; v++)\n\t\tmate[v] = 0;\n\n\tn_x = n;\n\tn_matches = 0;\n\ttot_weight = 0;\n\n\tbel[0] = 0;\n\tfor (int v = 1; v <= n; v++)\n\t\tbel[v] = v, bloch[v].clear();\n\tfor (int v = 1; v <= n; v++)\n\t\tfor (int u = 1; u <= n; u++)\n\t\t\tblofrom[v][u] = v == u ? v : 0;\n\n\tint w_max = 0;\n\tfor (int v = 1; v <= n; v++)\n\t\tfor (int u = 1; u <= n; u++)\n\t\t\trelax(w_max, mat[v][u].w);\n\tfor (int v = 1; v <= n; v++)\n\t\tlab[v] = w_max;\n\n\twhile (match())\n\t\tn_matches++;\n\n\tfor (int v = 1; v <= n; v++)\n\t\tif (mate[v] && mate[v] < v)\n\t\t\ttot_weight += mat[v][mate[v]].w;\n}\n\n\ninline bool check(int x){\n\tif(x==1) return 0;\n\tfor(int i=2;i*i<=x;i++)\t\n\t\tif(x%i==0) return 0;\n\treturn 1;\t\n}\nint calc(int n){\n\tif(n%2==0) return 2;\n\tif(check(n)) return 3;\n\treturn 1;\n}\n\nbool f[N];\nint a[105];\n\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++){\n\t\tint x;scanf(\"%d\",&x);\n\t\tf[x]=1;\n\t}\n\tn=0;\n\tfor(int i=1;i<=10000001;i++) \n\t\tif(f[i]^f[i-1]) a[++n]=i;\n\tfor (int v=1;v<=n;v++)\n\t\tfor (int u=1;u<=n;u++)\n\t\t\tif(u!=v) mat[v][u]=edge(v,u,calc(abs(a[u]-a[v])));\n\tcalc_max_weight_match();\n\tprintf(\"%d\\n\", n*2-tot_weight);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//by yjz\n#include<bits/stdc++.h>\nusing namespace std;\n#define FF first\n#define SS second\n#define PB push_back\n#define MP make_pair\n#define bged(v) (v).begin(),(v).end()\n#define foreach(it,s) for(__typeof((s).begin()) it=(s).begin();it!=(s).end();it++)\n#define debug(...) (cerr<<\"'\"<<__FUNCTION__<<\"': \"),fprintf(stderr,__VA_ARGS__)\ntypedef long long ll;\nconst int Imx=2147483647;\nconst ll Lbig=2e18;\nconst int mod=1e9+7;\n//My i/o stream\nstruct fastio\n{\n\tchar s[100000];\n\tint it,len;\n\tfastio(){it=len=0;}\n\tinline char get()\n\t{\n\t\tif(it<len)return s[it++];it=0;\n\t\tlen=fread(s,1,100000,stdin);\n\t\tif(len==0)return EOF;else return s[it++];\n\t}\n\tbool notend()\n\t{\n\t\tchar c=get();\n\t\twhile(c==' '||c=='\\n')c=get();\n\t\tif(it>0)it--;\n\t\treturn c!=EOF;\n\t}\n}_buff;\n#define geti(x) x=getnum()\n#define getii(x,y) geti(x),geti(y)\n#define getiii(x,y,z) getii(x,y),geti(z)\n#define puti(x) putnum(x),putchar(' ')\n#define putii(x,y) puti(x),puti(y)\n#define putiii(x,y,z) putii(x,y),puti(z)\n#define putsi(x) putnum(x),putchar('\\n')\n#define putsii(x,y) puti(x),putsi(y)\n#define putsiii(x,y,z) putii(x,y),putsi(z)\ninline ll getnum()\n{\n\tll r=0;bool ng=0;char c;c=_buff.get();\n\twhile(c!='-'&&(c<'0'||c>'9'))c=_buff.get();\n\tif(c=='-')ng=1,c=_buff.get();\n\twhile(c>='0'&&c<='9')r=r*10+c-'0',c=_buff.get();\n\treturn ng?-r:r;\n}\ntemplate<class T> inline void putnum(T x)\n{\n\tif(x<0)putchar('-'),x=-x;\n\tregister short a[20]={},sz=0;\n\twhile(x)a[sz++]=x%10,x/=10;\n\tif(sz==0)putchar('0');\n\tfor(int i=sz-1;i>=0;i--)putchar('0'+a[i]);\n}\ninline char getreal(){char c=_buff.get();while(c==' '||c=='\\n')c=_buff.get();return c;}\nbool np[10001111];\nint n,a[111];\nint dp[111][111];\nint getcost(int x)\n{\n\tif(x%2==0)return 2;\n\telse if(np[x])return 3;\n\telse return 1;\n}\nint main()\n{\n\tnp[1]=1;\n\tfor(int i=2;i<=10000000;i++)\n\t{\n\t\tif(np[i])continue;\n\t\tfor(int j=i;j<=10000000;j+=i)np[j]=1;\n\t}\n\tgeti(n);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tgeti(a[i]);\n\t}\n\tfor(int i=n;i>=1;i--)\n\t{\n\t\tfor(int j=i;j<=n;j++)\n\t\t{\n\t\t\tif(i==j)dp[i][j]=getcost(1);\n\t\t\telse\n\t\t\t{\n\t\t\t\tdp[i][j]=Imx;\n\t\t\t\tint sum=0;\n\t\t\t\tfor(int k=i;k<j;k++)\n\t\t\t\t{\n\t\t\t\t\tdp[i][j]=min(dp[i][j],dp[i][k]+dp[k+1][j]);\n\t\t\t\t\tif(a[k+1]-a[k]-1>0)\n\t\t\t\t\t{\n\t\t\t\t\t\tsum+=getcost(a[k+1]-a[k]-1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdp[i][j]=min(dp[i][j],sum+getcost(a[j]-a[i]+1));\n\t\t\t}\n\t\t}\n\t}\n\tcout<<dp[1][n]<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#define _GLIBCXX_DEBUG\n\n#include<bits/stdc++.h>\nusing namespace std;\n\n#define endl '\\n'\n#define lfs cout<<fixed<<setprecision(10)\n#define ALL(a)  (a).begin(),(a).end()\n#define ALLR(a)  (a).rbegin(),(a).rend()\n#define spa << \" \" <<\n#define fi first\n#define se second\n#define MP make_pair\n#define MT make_tuple\n#define PB push_back\n#define EB emplace_back\n#define rep(i,n,m) for(ll i = (n); i < (ll)(m); i++)\n#define rrep(i,n,m) for(ll i = (ll)(m) - 1; i >= (ll)(n); i--)\nusing ll = long long;\nusing ld = long double;\nconst ll MOD1 = 1e9+7;\nconst ll MOD9 = 998244353;\nconst ll INF = 1e18;\nusing P = pair<ll, ll>;\ntemplate<typename T1, typename T2>bool chmin(T1 &a,T2 b){if(a>b){a=b;return true;}else return false;}\ntemplate<typename T1, typename T2>bool chmax(T1 &a,T2 b){if(a<b){a=b;return true;}else return false;}\nll median(ll a,ll b, ll c){return a+b+c-max({a,b,c})-min({a,b,c});}\nvoid ans1(bool x){if(x) cout<<\"Yes\"<<endl;else cout<<\"No\"<<endl;}\nvoid ans2(bool x){if(x) cout<<\"YES\"<<endl;else cout<<\"NO\"<<endl;}\nvoid ans3(bool x){if(x) cout<<\"Yay!\"<<endl;else cout<<\":(\"<<endl;}\ntemplate<typename T1,typename T2>void ans(bool x,T1 y,T2 z){if(x)cout<<y<<endl;else cout<<z<<endl;}  \ntemplate<typename T>void debug(vector<vector<T>>&v,ll h,ll w){for(ll i=0;i<h;i++){cout<<v[i][0];for(ll j=1;j<w;j++)cout spa v[i][j];cout<<endl;}};\nvoid debug(vector<string>&v,ll h,ll w){for(ll i=0;i<h;i++){for(ll j=0;j<w;j++)cout<<v[i][j];cout<<endl;}};\ntemplate<typename T>void debug(vector<T>&v,ll n){if(n!=0)cout<<v[0];for(ll i=1;i<n;i++)cout spa v[i];cout<<endl;};\ntemplate<typename T>vector<vector<T>>vec(ll x, ll y, T w){vector<vector<T>>v(x,vector<T>(y,w));return v;}\nll gcd(ll x,ll y){ll r;while(y!=0&&(r=x%y)!=0){x=y;y=r;}return y==0?x:y;}\nvector<ll>dx={1,-1,0,0,1,1,-1,-1};vector<ll>dy={0,0,1,-1,1,-1,1,-1};\ntemplate<typename T>vector<T> make_v(size_t a,T b){return vector<T>(a,b);}\ntemplate<typename... Ts>auto make_v(size_t a,Ts... ts){return vector<decltype(make_v(ts...))>(a,make_v(ts...));}\ntemplate<typename T1, typename T2>ostream &operator<<(ostream &os, const pair<T1, T2>&p){return os << p.first << \" \" << p.second;}\ntemplate<typename T>ostream &operator<<(ostream &os, const vector<T> &v){for(auto &z:v)os << z << \" \";cout<<\"|\"; return os;}\n//mt19937 mt(chrono::steady_clock::now().time_since_epoch().count());\nvector< bool > prime_table(ll n) {\n  vector< bool > prime(n + 1, true);\n  if(n >= 0) prime[0] = false;\n  if(n >= 1) prime[1] = false;\n  for(ll i = 2; i * i <= n; i++) {\n    if(!prime[i]) continue;\n    for(ll j = i + i; j <= n; j += i) {\n      prime[j] = false;\n    }\n  }\n  return prime;\n}\ntemplate< typename flow_t, typename cost_t >\nstruct PrimalDual {\n  const cost_t INF;\n\n  struct edge {\n    ll to;\n    flow_t cap;\n    cost_t cost;\n    ll rev;\n    bool isrev;\n  };\n  vector< vector< edge > > graph;\n  vector< cost_t > potential, min_cost;\n  vector< ll > prevv, preve;\n\n  PrimalDual(ll V) : graph(V), INF(numeric_limits< cost_t >::max()) {}\n\n  void add_edge(ll from, ll to, flow_t cap, cost_t cost) {\n    graph[from].emplace_back((edge) {to, cap, cost, (ll) graph[to].size(), false});\n    graph[to].emplace_back((edge) {from, 0, -cost, (ll) graph[from].size() - 1, true});\n  }\n\n  cost_t min_cost_flow(ll s, ll t, flow_t f) {\n    ll V = (ll) graph.size();\n    cost_t ret = 0;\n    using Pi = pair< cost_t, ll >;\n    priority_queue< Pi, vector< Pi >, greater< Pi > > que;\n    potential.assign(V, 0);\n    preve.assign(V, -1);\n    prevv.assign(V, -1);\n\n    while(f > 0) {\n      min_cost.assign(V, INF);\n      que.emplace(0, s);\n      min_cost[s] = 0;\n      while(!que.empty()) {\n        Pi p = que.top();\n        que.pop();\n        if(min_cost[p.second] < p.first) continue;\n        for(ll i = 0; i < graph[p.second].size(); i++) {\n          edge &e = graph[p.second][i];\n          cost_t nextCost = min_cost[p.second] + e.cost + potential[p.second] - potential[e.to];\n          if(e.cap > 0 && min_cost[e.to] > nextCost) {\n            min_cost[e.to] = nextCost;\n            prevv[e.to] = p.second, preve[e.to] = i;\n            que.emplace(min_cost[e.to], e.to);\n          }\n        }\n      }\n      if(min_cost[t] == INF) return -1;\n      for(ll v = 0; v < V; v++) potential[v] += min_cost[v];\n      flow_t addflow = f;\n      for(ll v = t; v != s; v = prevv[v]) {\n        addflow = min(addflow, graph[prevv[v]][preve[v]].cap);\n      }\n      f -= addflow;\n      ret += addflow * potential[t];\n      for(ll v = t; v != s; v = prevv[v]) {\n        edge &e = graph[prevv[v]][preve[v]];\n        e.cap -= addflow;\n        graph[v][e.rev].cap += addflow;\n      }\n    }\n    return ret;\n  }\n\n  void output() {\n    for(ll i = 0; i < graph.size(); i++) {\n      for(auto &e : graph[i]) {\n        if(e.isrev) continue;\n        auto &rev_e = graph[e.to][e.rev];\n        cout << i << \"->\" << e.to << \" (flow: \" << rev_e.cap << \"/\" << rev_e.cap + e.cap << \")\" << endl;\n      }\n    }\n  }\n  using R=vector<pair<pair<ll,ll>,pair<flow_t,cost_t>>>;\n  R restore() {\n    R ret;\n    for(ll i = 0; i < graph.size(); i++) {\n      for(auto &e : graph[i]) {\n        if(e.isrev) continue;\n        auto &rev_e = graph[e.to][e.rev];\n        ret.emplace_back(make_pair(i,e.to),make_pair(rev_e.cap,e.cost));\n      }\n    }\n    return ret;\n  }\n};\nint main(){\n  cin.tie(nullptr);\n  ios_base::sync_with_stdio(false);\n  ll res=0,buf=0;\n  bool judge = true;\n  ll lim=1e7+30;\n  //ll lim=1e3;cout<<\"naosu\"<<endl;\n  auto pr=prime_table(lim);\n  /*vector<ll>p;\n  rep(i,0,lim)if(pr[i])p.PB(i);\n  ll sz=p.size();*/\n  ll n;cin>>n;\n  vector<ll>x(n);\n  rep(i,0,n)cin>>x[i];\n  vector<ll>y;\n  rep(i,0,n){\n    y.PB(x[i]);\n    y.PB(x[i]+1);\n  }\n  //cout<<lim<<endl;\n  {\n    vector<ll>tmp;\n    sort(ALL(y));\n    rep(i,0,y.size()){\n      if(i+1<y.size()&&y[i]==y[i+1])i++;\n      else tmp.PB(y[i]);\n    }\n    y=tmp;\n  }\n  pr[2]=false;\n  ll sz=y.size();\n  PrimalDual<ll,ll>fl(2*sz+2);\n  rep(i,0,sz)rep(j,0,sz){\n    if(i==j)continue;\n    ll dif=abs(y[i]-y[j]);\n    ll cost=0;\n    if(dif==0)cost=0;\n    else if(dif%2==0)cost=2;\n    else if(pr[dif])cost=1;\n    else cost=3;\n    //cout<<dif spa cost spa y[i] spa y[j]<<endl;\n    fl.add_edge(i,j+sz,1,cost);\n  }\n  ll S=2*sz,T=2*sz+1;\n  rep(i,0,sz){\n    fl.add_edge(S,i,1,0);\n    fl.add_edge(i+sz,T,1,0);\n  }\n  //cout<<sz<<endl;\n  //debug(y,sz);\n  ll lk=fl.min_cost_flow(S,T,sz);\n  assert(~lk&1);\n  cout<<lk/2<<endl;\n  /*auto r=fl.restore();\n  for(auto z:r){\n    if(z.se.fi==1&&z.fi.fi<sz&&z.fi.se<2*sz){\n      cout<<y[z.fi.fi] spa y[z.fi.se-sz]<<endl;\n    }\n  }*/\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nconst int N = 505;\nconst int M = 1e5 + 50;\n\nint n, m, s, t, x[N], col[N];\nint head[N], nxt[M], ver[M], edge[M], d[N], cur[N], cnt = 1;\n\ninline void add(int u, int v, int w)\n{\n\tnxt[++cnt] = head[u], ver[cnt] = v, edge[cnt] = w, head[u] = cnt;\n\tnxt[++cnt] = head[v], ver[cnt] = u, edge[cnt] = 0, head[v] = cnt;\n}\n\ninline bool bfs()\n{\n\tmemset(d, 0, sizeof d); memcpy(cur, head, sizeof head);\n\tstd::queue<int> Q;\n\tQ.push(s); d[s] = 1;\n\twhile (Q.empty() == false)\n\t{\n\t\tint x = Q.front(); Q.pop();\n\t\tfor (int i = head[x]; i; i = nxt[i])\n\t\t{\n\t\t\tint y = ver[i];\n\t\t\tif (edge[i] && !d[y])\n\t\t\t{\n\t\t\t\td[y] = d[x] + 1;\n\t\t\t\tif (y == t) return true;\n\t\t\t\tQ.push(y);\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\ninline int dinic(int x, int flow)\n{\n\tif (x == t) return flow;\n\tint rest = flow, k = 0;\n\tfor (int &i = cur[x]; i; i = nxt[i])\n\t\tif (edge[i] && d[ver[i]] == d[x] + 1)\n\t\t{\n\t\t\tk = dinic(ver[i], std::min(rest, edge[i]));\n\t\t\tedge[i] -= k, edge[i ^ 1] += k, rest -= k;\n\t\t\tif (!k) d[ver[i]] = 0;\n\t\t\tif (!rest) break;\n\t\t}\n\treturn flow - rest;\n}\n\ninline bool isPrime(int x)\n{\n\tif (x == 0 || x == 1) return false;\n\tif (x == 2) return true;\n\tif (!(x & 1)) return false;\n\tfor (int i = 3; i * i <= x; i += 2) if (x % i == 0) return false;\n\treturn true;\n}\n\ninline char nc()\n{\n\tstatic char buf[1000000], *p1 = buf, *p2 = buf;\n\treturn p1 == p2 && (p2 = (p1 = buf) + fread(buf, 1, 1000000, stdin), p1 == p2) ? EOF : *p1++;\n}\n\ninline int read()\n{\n\tint res = 0, neg = 1; char ch;\n\tdo\n\t{\n\t\tch = nc();\n\t\tif (ch == '-') neg = -1;\n\t} while (ch < 48 || ch > 57);\n\tdo res = res * 10 + ch - 48, ch = nc(); while (ch >= 48 && ch <= 57);\n\treturn res * neg;\n}\n\nint main()\n{\n\tn = read();\n\tstatic int pos[N], _t;\n\tfor (int i = 1; i <= n; ++i)\n\t{\n\t\tx[i] = read();\n\t\tif (i == 1 || x[i] != x[i - 1] + 1) pos[++_t] = x[i];\n\t\tif (i != 1 && x[i] != x[i - 1] + 1) pos[++_t] = x[i - 1] + 1;\n\t}\n\tpos[++_t] = x[n] + 1;\n\ts = _t + 1, t = s + 1;\n       \tint count = 0;\n\tfor (int i = 1; i <= _t; ++i)\n\t\tif (pos[i] & 1) add(s, i, 1), ++count;\n\t\telse add(i, t, 1);\n\tfor (int i = 1; i <= _t; ++i) if (pos[i] & 1) for(int j = 1; j <= _t; ++j) if (!(pos[j] & 1))\n\t{\n\t\tif (isPrime(abs(pos[i] - pos[j])))\n\t\t{\n\t\t\tadd(i, j, 1);\n\t\t}\n\t}\n\tint maxflow = 0, flow = 0;\n\twhile (bfs()) while (flow = dinic(s, 0x3f3f3f3f)) maxflow += flow;\n\tint Mo = count, Me = _t - Mo, k = maxflow;\n\tprintf(\"%d\\n\", k + ((Me - k) / 2 + (Mo - k) / 2) * 2 + ((Me - k) % 2) * 3);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n\n#define Rep(i, n) for (int i = 1; i <= n; i ++)\n\nusing namespace std;\n\nconst int N = 410, N0 = 1e7 + 10;\n\nint d0[N], d[N], cd;\n\nbool isnotprime[N0];\nint prime[N0], cnt;\nvoid get_prime()\n{\n\tisnotprime[1] = true;\n\tfor (int i = 2; i <= 1e7 + 5; i ++){\n\t\tif (!isnotprime[i]) prime[++ cnt] = i;\n\t\tfor (int j = 1; j <= cnt && i * prime[j] <= 1e7 + 5; j ++) {\n\t\t\tisnotprime[i * prime[j]] = true;\n\t\t\tif (!(i % prime[j])) break;\n\t\t}\n\t}\n}\n\nbool g[N][N], vis[N];\nint lnk[N];\n\nbool dfs(int x)\n{\n\tif (vis[x]) return 0;\n\tvis[x] = true;\n\tRep(i, cd) if (g[x][i]){\n\t\tif (lnk[i] == -1 || dfs(lnk[i])) {\n\t\t\tlnk[i] = x;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint main()\n{\n\tint n;\n\tscanf(\"%d\", &n);\n\tRep(i, n) scanf(\"%d\", &d0[i]);\n\td0[0] = -1;\n\tRep(i, n) {\n\t\tif (d0[i - 1] != d0[i] - 1) d[++ cd] = d0[i];\n\t\tif (d0[i + 1] != d0[i] + 1) d[++ cd] = d0[i] + 1;\n\t}\n\t\n\tget_prime();\n\tRep(i, cd) if (d[i] & 1)\n\t\tRep(j, cd) if (!(d[j] & 1))\n\t\t\tif (!isnotprime[(int)abs(d[j] - d[i])]) g[i][j] = true;\n\t\n\tint c0 = 0, c1 = 0, cc = 0;\n\tRep(i, cd) lnk[i] = -1;\n\tRep(i, cd) {\n\t\tif (d[i] & 1) {\n\t\t\tRep(j, cd) vis[j] = false;\n\t\t\tif (dfs(i)) cc ++;\n\t\t\tc1 ++;\n\t\t}\n\t\telse c0 ++;\n\t}\n\tint ans = cc;\n\tc0 -= cc, c1 -= cc;\n\tans += (c0 / 2) * 2, c0 %= 2;\n\tans += (c1 / 2) * 2, c1 %= 2;\n\tif (c0 && c1) ans += 3;\n\t\n\tprintf(\"%d\\n\", ans);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n\n#define ri register int\n#define ssd 10000010\n#define sid 205\n\nint n, N = 1e7;\nint pr[ssd / 10], tot;\nint nj, no, js[sid], os[sid];\nbool nop[ssd], e[ssd];\n\nint tim, vis[sid], mat[sid];\nbool ex[sid][sid];\n\ninline void Init() {\n    nop[1] = 1;\n    for(ri i = 2; i <= N + 1; i ++) {\n        if(!nop[i]) pr[++ tot] = i;\n        for(ri j = 1; j <= tot; j ++) {\n            int nx = i * pr[j]; if(nx > N + 1) break;\n            nop[nx] = 1; if(i % pr[j] == 0) break;\n        }\n    }\n}\n\ninline int dfs(int o) {\n    for(int i = 1; i <= no; i ++)\n    if(vis[i] != tim && ex[o][i]) {\n        vis[i] = tim;\n        if(!mat[i]|| dfs(mat[i])) { mat[i] = o; return 1; }\n    } return 0;\n}\n\nint main() {\n    Init();\n    cin >> n;\n    for(ri i = 1; i <= n; i ++) { int x; cin >> x; e[x] = 1; }\n    \n    for(ri i = 1; i <= N + 1; i ++)\n    if(e[i] != e[i - 1])\n    if(i & 1) js[++ nj] = i;\n    else os[++ no] = i;\n\n    for(ri i = 1; i <= nj; i ++)\n    for(ri j = 1; j <= no; j ++)\n    if(!nop[abs(js[i] - os[j])]) ex[i][j] = 1;\n\n    int num = 0, ans = 0;\n\n    for(ri i = 1; i <= nj; i ++)\n    if(!mat[i]) ++ tim, num += dfs(i);\n\n    nj -= num; no -= num;\n    ans = num + nj / 2 * 2 + no / 2 * 2 + (nj & 1) * 3;\n    printf(\"%d\\n\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<algorithm>\n#include<cstdio>\n#include<vector>\n#include<cmath>\nusing namespace std;\n\nconst int M = 1001;\nint n,m,k,a[M],d[M],vis[M],ver[M],s0,s1,w0[M],w1[M],t;\nvector<int> v[M];\n\nbool check(int x)\n{\n\tx=max(x,-x);\n\tif(x==1) return 0;\n\tint k=sqrt(x);\n\tfor(int i=2;i<=k;i++) if(x%i==0) return 0;\n\treturn 1;\n}\n\nvoid ins(int k)\n{\n\tif(k%2) w1[++s1]=k;\n\telse w0[++s0]=k;\n}\n\nint dfs(int x)\n{\n\tfor(int i=0;i<v[x].size();i++)\n\t{\n\t\tif(vis[v[x][i]]==t) continue; vis[v[x][i]]=t;\n\t\tif(!ver[v[x][i]] || dfs(ver[v[x][i]])) \n\t\t{\n\t\t\tver[v[x][i]]=x; \n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nint main()\n{\n\tscanf(\"%d\",&n); a[0]=-1;\n\tfor(int i=1;i<=n;i++) scanf(\"%d\",&a[i]);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tif(a[i]!=a[i-1]+1) ins(a[i]);\n\t\tif(a[i+1]!=a[i]+1) ins(a[i]+1);\n\t}\n\tfor(int i=1;i<=s1;i++)\n\t\tfor(int j=1;j<=s0;j++)\n\t\t\tif(check(w0[i]-w1[j])) v[i].push_back(j);\n\tfor(t=1;t<=s1;t++) k+=dfs(t);\n\tprintf(\"%d\",s1+s0-k+(s1-k)%2);\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstring>\n#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<queue>\n#include<stack>\n#include<cmath>\n#include<map>\n#include<complex>\n#define rep(i,l,r) for (int i=l;i<=r;i++)\n#define down(i,l,r) for (int i=l;i>=r;i--)\n#define clr(x,y) memset(x,y,sizeof(x))\n#define maxn 320500\n#define inf (int)1e9\n#define ll long long\n#define mm 1000000007\n#define eps 1e-13\n#define pb push_back\n#define low(x) x&(-x)\nusing namespace std;\n\nll read(){\n    ll x=0,f=1; char ch=getchar();\n    while (!isdigit(ch)) {if (ch=='-') f=-1; ch=getchar();}\n    while (isdigit(ch)){x=x*10+ch-'0'; ch=getchar();}\n    return x*f;\n}\nint a[805],b[805];\nint matl[405],lnk[405],matr[405],q[2005000],visb[405],lk[405],slack[405];\nint mp[10000005],pmp[10000005],vis[10000005],pri[1000500];\nint ans,ptot,n,m,idx,la,lb;\nbool fd(int x){\n\trep(j,1,lb){\n\t\tif (!visb[j]&&pmp[abs(a[x]-b[j])]){\n\t\t\tvisb[j]=1;\n\t\t\tif (lk[j]==-1||fd(lk[j])){\n\t\t\t\tlk[j]=x;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nint main(){\n//\tfreopen(\"input.txt\",\"r\",stdin);\n//\tfreopen(\"output.txt\",\"w\",stdout);\n\tn=read();\n\tint mxn=10000001;\n\tint x;\n\trep(i,1,n) x=read(),mp[x]=1;\n\t//rep(i,1,n) if (mp[a[i]-1]==mp[a[i]]) b[i]=0; else b[i]=1;\n\trep(i,0,x) if (mp[i]!=mp[i+1]) {\n\t\tif (i%2==0) a[++la]=i; else b[++lb]=i;\n\t}\n\trep(i,2,mxn) {\n\t\tif (!vis[i]) pri[++ptot]=i,vis[i]=1,pmp[i]=1;\n\t\trep(j,1,ptot) {\n\t\t\tif (i*pri[j]>mxn) break;\n\t\t\tvis[i*pri[j]]=1;\n\t\t}\n\t}\n\tclr(lk,-1);\n\tint ans=0;\n\trep(i,1,la) {\n\t\tclr(visb,0);\n\t\tif (fd(i)) ans++;\n\t}\n\tla-=ans;\n\tlb-=ans;\n\tif (la%2==1) ans+=3;\n\tans+=la/2*2+lb/2*2;\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <bits/stdc++.h>\n\n#define FOR(i,b,e) for(int i=(b); i <= (e); ++i)\n#define FORD(i,b,e) for(int i=(b); i >= (e); --i)\n#define SIZE(c) (int) (c).size()\n#define FORE(i,c) FOR(i,0,SIZE(c)-1)\n#define FORDE(i,c) FORD(i,SIZE(c)-1,0)\n\n#define pb push_back\n#define mp make_pair\n#define st first\n#define nd second\n\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair <int,int> pii;\ntypedef pair <ll,ll> pll;\n\ntypedef vector <int> VI;\ntypedef vector <bool> VB;\ntypedef vector <pii> VP;\ntypedef vector <ll> VL;\ntypedef vector <pll> VPL;\n\ntypedef vector <VI> VVI;\ntypedef vector <VL> VVL;\ntypedef vector <VB> VVB;\ntypedef vector <VP> VVP;\n\nstruct MinCostFlow {\n    typedef int capacity_t;\n    typedef int cost_t;\n\n    // use INFINITY from cmath if cost_t is a double\n    const cost_t INF = 1000 * 1000 * 1000;\n    const capacity_t MAX_CAP = 1000 * 1000 * 1000;\n\n    struct edge {\n        int from, v;\n        capacity_t cap, flow;\n        cost_t cost, dist;\n        int rev_index;\n        \n        bool residual() { return flow < cap; }\n        \n        edge(int _f, int _v, capacity_t _cap, cost_t _cost):\n            from(_f), v(_v), cap(_cap), flow(0), cost(_cost), dist(_cost) {}\n    };\n\n    int n, s, t;\n    vector <cost_t> d;\n    vector <edge*> p;\n    vector <vector<edge>> g;\n    VB queued;\n    \n    MinCostFlow(int n): n(n), d(n), p(n), g(n), queued(n) {}\n    \n    void bellman() {\n        FOR(i,0,n-1) { d[i] = INF; queued[i] = 0; }\n        queue <int> q;\n        \n        d[s] = 0;\n        q.push(s); queued[s] = 0;\n        \n        while (!q.empty()) {\n            int u = q.front(); q.pop(); queued[u] = 0;\n            \n            for (auto &i : g[u]) if (i.residual() && d[i.v] > d[u] + i.dist) {\n                d[i.v] = d[u] + i.dist;\n                p[i.v] = &i;\n                if (!queued[i.v]) { q.push(i.v); queued[i.v] = 1; }\n            }\n        }\n    }\n\n    pair <capacity_t,cost_t> computeFlow(int s, int t) {\n        this->s = s;\n        this->t = t;\n\n        capacity_t flow = 0;\n        cost_t cost = 0;\n\n        while (true) {\n            bellman();\n\n            if (d[t] == INF) break;\n            cost_t c = 0;\n            capacity_t f = MAX_CAP;\n            \n            for (int u=t; u!=s; u=p[u]->from) {\n                f = min(f, p[u]->cap - p[u]->flow);\n            }\n            \n            for (int u=t; u!=s; u=p[u]->from) {\n                p[u]->flow += f;\n                g[p[u]->v][p[u]->rev_index].flow -= f;\n                c += p[u]->cost;\n            }\n            \n            flow += f; cost += f * c;\n        }\n        \n        return {flow, cost};\n    }\n    \n    void addEdge(int a, int b, capacity_t f, cost_t c) {\n        assert(a != b);\n        \n        g[a].pb(edge(a, b, f, c));\n        g[b].pb(edge(b, a, 0, -c));\n        g[a].back().rev_index = SIZE(g[b])-1;\n        g[b].back().rev_index = SIZE(g[a])-1;\n    }\n};\n\n/*************************************************************************/\n\nbool isPrime(int x) {\n    if (x == 1) return false;\n\n    for (int i = 2; i * i <= x; i++) if (x % i == 0) {\n        return false;\n    }\n    \n    return true;\n}\n\n\nstruct TurboMatching {\n    int value = 0;\n\n    VVI G;\n    VI mate; VB vis;\n\n    TurboMatching(int n): G(n), mate(n,-1), vis(n,0) {}\n\n    void addEdge(int u, int v) {\n        G[u].pb(v);\n        G[v].pb(u);\n    }\n\n    bool findPath(int v) {\n        if (vis[v]) return false;\n        vis[v] = true;\n\n        for (int u : G[v]) if (mate[u] == -1 || findPath(mate[u])) {\n            mate[v] = u;\n            mate[u] = v;\n            return true;\n        }\n\n        return false;\n    }\n\n    pair <int,VI> runMatching() {\n        while (true) {\n            bool found = false;\n            FORE(v,G) vis[v] = false;\n\n            FORE(v,G) if (mate[v] == -1 && findPath(v)) {\n                found = true;\n                value++;\n            }\n\n            if (!found) break;\n        }\n\n        return {value, mate};\n    }\n};\n\n/*************************************************************************/\n\nint solve(int n, VI &x) {\n    TurboMatching matching(n);\n    \n    FOR(i,0,n-1) FOR(j,i+1,n-1) {\n        int diff = abs(x[i] - x[j]);\n        \n        if (diff % 2 && isPrime(diff)) {\n            matching.addEdge(i, j);\n        }\n    }\n    \n    int matchingInOnes = matching.runMatching().st;\n    \n    int odd = 0, even = 0;\n    FOR(i,0,n-1) {\n        if (x[i] % 2) odd++;\n        else even++;\n    }\n    \n    odd -= matchingInOnes;\n    even -= matchingInOnes;\n\n    int ans = matchingInOnes;\n    ans += 2 * (odd / 2);\n    ans += 2 * (even / 2);\n    \n    if (odd % 2) {\n        ans += 3;\n    }\n    \n    return ans;\n}\n\n/*************************************************************************/\n\nint main() {\n    ios_base::sync_with_stdio(0);\n    \n    int n;\n    cin >> n;\n    \n    set <int> pos;\n    while (n--) {\n        int x;\n        cin >> x;\n        \n        VI vals = {x-1, x};\n        for (int v : vals) {\n            if (pos.count(v)) {\n                pos.erase(v);\n            } else {\n                pos.insert(v);\n            }\n        }\n    }\n    \n    VI posVec(pos.begin(), pos.end());\n    cout << solve(posVec.size(), posVec);\n\n    return 0;\n}\n\n/*************************************************************************/\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\nconst int N = 2e2 + 2;\nconst int M = 1e7 + 7;\nint n;\nint x[N];\nint arr[N];\nint siz;\nbool p[M];\nvoid pre(){\n\tfor(int i = 2 ; i * i < M ; ++i){\n\t\tif(!p[i]){\n\t\t\tfor(int j = i * i ; j < M ; j += i){\n\t\t\t\tp[j] = 1;\n\t\t\t}\n\t\t}\n\t}\n\tp[0] = 1;\n\tp[1] = 1;\n\tp[2] = 1;\n}\nvector < int > v[N];\nint lft , rgt;\nint match[N];\nint timer;\nint visited[N];\nbool dfs(int node){\n\tif(visited[node] == timer){\n\t\treturn 0;\n\t}\n\tvisited[node] = timer;\n\tfor(int next : v[node]){\n\t\tif(!match[next] || dfs(match[next])){\n\t\t\tmatch[next] = node;\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\nint main(){\n\tpre();\n\tscanf(\"%d\" , &n);\n\tfor(int i = 1 ; i <= n ; ++i){\n\t\tscanf(\"%d\" , x + i);\n\t}\n\tint cur = x[1];\n\tint str = x[1];\n\tfor(int i = 2 ; i <= n ; ++i){\n\t\tif(cur + 1 != x[i]){\n\t\t\tarr[++siz] = str;\n\t\t\tarr[++siz] = cur + 1;\n\t\t\tstr = x[i];\n\t\t\tcur = x[i];\n\t\t}\n\t\telse{\n\t\t\t++cur;\n\t\t}\n\t}\n\tarr[++siz] = str;\n\tarr[++siz] = cur + 1;\n\tn = siz;\n\tfor(int i = 1 ; i <= n ; ++i){\n\t\tif(arr[i] & 1){\n\t\t\t++lft;\n\t\t}\n\t\telse{\n\t\t\t++rgt;\n\t\t}\n\t}\n\tfor(int i = 1 ; i <= n ; ++i){\n\t\tif(arr[i] & 1){\n\t\t\tfor(int j = 1 ; j <= n ; ++j){\n\t\t\t\tif(!p[abs(arr[j] - arr[i])]){\n\t\t\t\t\tv[i].emplace_back(j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint tot = 0;\n\tfor(int i = 1 ; i <= n ; ++i){\n\t\tif(arr[i] & 1){\n\t\t\t++timer;\n\t\t\ttot += dfs(i);\n\t\t}\n\t}\n\tint ans = 0;\n\tans += tot;\n\tans += ((lft - tot) >> 1) << 1;\n\tans += ((rgt - tot) >> 1) << 1;\n\tans += ((lft - tot) & 1) * 3;\n\tprintf(\"%d\\n\" , ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cassert>\n#include <cctype>\n#include <algorithm>\n#include <set>\nusing namespace std;\ntypedef long long lint;\n#define cout cerr\n#define ni (next_num<int>())\ntemplate<class T>inline T next_num(){\n\tT i=0;char c;\n\twhile(!isdigit(c=getchar())&&c!='-');\n\tbool flag=c=='-';\n\tflag?c=getchar():0;\n\twhile(i=i*10-'0'+c,isdigit(c=getchar()));\n\treturn flag?-i:i;\n}\ntemplate<class T1,class T2>inline void apmax(T1 &a,const T2 &b){if(a<b)a=b;}\ntemplate<class T1,class T2>inline void apmin(T1 &a,const T2 &b){if(b<a)a=b;}\nconst int N=110,M=10000010;\nint prime[M],ps=0;\nbool isp[M];\ninline void gmath(int n){\n\tmemset(isp,true,sizeof(isp));\n\tisp[1]=false;\n\tfor(int i=2;i<=n;i++){\n\t\tif(isp[i]){\n\t\t\tprime[ps++]=i;\n\t\t}\n\t\tfor(int j=0,cur=2;j<ps&&i*cur<=n;cur=prime[++j]){\n\t\t\tisp[i*cur]=false;\n\t\t\tif(i%cur==0)break;\n\t\t}\n\t}\n}\nset<int>s;\ntypedef set<int>::iterator iter;\ninline void flip(int x){\n\titer it=s.find(x);\n\tif(it==s.end()){\n\t\ts.insert(x);\n\t}else{\n\t\ts.erase(x);\n\t}\n}\nint main(){\n\tint n=ni,mx=0;\n\tfor(int i=1;i<=n;i++){\n\t\tint cur=ni;\n\t\tapmax(mx,cur);\n\t\tflip(cur),flip(cur+1);\n\t}\n\tgmath(mx);\n\tint ans=s.size(),cnt=0;\n\tfor(iter i=s.begin(),j;i!=s.end();){\n\t\tfor(j=i;++j!=s.end()&&!isp[*j-*i];);\n\t\tif(j==s.end()){\n\t\t\ti++;\n\t\t}else{\n\t\t\tcnt++;\n\t\t\titer nxt=i;\n\t\t\tnxt++;\n\t\t\ts.erase(i),s.erase(j);\n\t\t\ti=nxt;\n\t\t}\n\t}\n\tprintf(\"%d\\n\",ans+(cnt&1)-cnt);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\nconst int N=1e5;\nint ne[N],he[N],a[N],vis[N],g[N],t[N],tot,b1[N],x,y,b2[N];\nvoid ad(int x,int y)\n{\n\ttot++;\n\tne[tot]=he[x];\n\the[x]=tot;\n\tt[tot]=y;\n}\nvoid put(int v)\n{\n\tif (v&1) \n\t{\n\t\tx++;\n\t\tb1[x]=v;\n\t} else\n\t{\n\t\ty++;\n\t\tb2[y]=v;\n\t}\n}\nint pd(int x)\n{\n\tif (x%2==0) return 0;\n\tif (x==1) return 0;\n\tfor (int i=2;i<=sqrt(x);i++) if (x%i==0) return 0;\n\treturn 1;\n}\nint dfs(int x)\n{\n\tif (vis[x]==tot) return 0;\n\tvis[x]=tot;\n\tint i=he[x];\n\twhile (i)\n\t{\n\t\tif (g[t[i]]==0||dfs(g[t[i]])) \n\t\t{\n\t\t\tg[t[i]]=x;\n\t\t\treturn 1;\n\t\t}\n\t\ti=ne[i];\n\t}\n\treturn 0;\n}\nint main()\n{\n\tint n;\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<=n;i++) scanf(\"%d\",&a[i]);\n\tsort(a+1,a+n+1);\n    put(a[1]-1);\n\tfor (int i=2;i<=n;i++) \n\t{\n\t\tif (a[i]-a[i-1]!=1) \n\t\t{\n\t\t\tput(a[i-1]);\n\t\t\tput(a[i]-1);\n\t\t}\n\t}\n\tput(a[n]);\n\tfor (int i=1;i<=x;i++) for (int j=1;j<=y;j++) if (pd(abs(b2[j]-b1[i]))) ad(i,j+x);\n\tint ans=0;\n\tfor (int i=1;i<=x;i++) \n\t{\n\t\ttot++;\n\t\tans+=dfs(i);\n\t}\n\tx-=ans;\n\ty-=ans;\n\tif (x&1) \n\t{\n\t\tans+=3;\n\t\tx--;\n\t\ty--;\n\t}\n\tans+=x+y;\n\tprintf(\"%d\\n\",ans); \n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,l,r) for(register int i = l ; i <= r ; i++)\n#define repd(i,r,l) for(register int i = r ; i >= l ; i--)\n#define rvc(i,S) for(register int i = 0 ; i < (int)S.size() ; i++)\n#define rvcd(i,S) for(register int i = ((int)S.size()) - 1 ; i >= 0 ; i--)\n#define fore(i,x)for (register int i = head[x] ; i ; i = e[i].next)\n#define forup(i,l,r) for (register int i = l ; i <= r ; i += lowbit(i))\n#define fordown(i,id) for (register int i = id ; i ; i -= lowbit(i))\n#define pb push_back\n#define prev prev_\n#define stack stack_\n#define mp make_pair\n#define fi first\n#define se second\n#define lowbit(x) (x&(-x))\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pr;\n\nconst ll MAX = 2e18;\nconst ld inf = 2e18;\nconst int maxn = 220;\nconst ll mod = 1e9 + 7;\n\ninline ll power(ll x,ll y){\n\ty = ((y % (mod - 1)) + (mod - 1)) % (mod - 1);\n//\tif ( y < 0 ) return power(power(x,-y),mod - 2);\n\tll res = 1;\n\twhile ( y ){\n\t\tif ( y & 1 ) res = res * x % mod;\n\t\tx = x * x % mod;\n\t\ty >>= 1;\n\t}\n\treturn res;\n}\nint a[maxn],n,odd[maxn],even[maxn],cnt1,cnt2;\nset <int> s;\nnamespace Prime{\n\tconst int N = 1e7;\n\tint prime[N + 20],tag[N + 20],mn[N + 20],Cnt;\t\n\tvoid init (){\n\t\trep(i,2,N){\n\t\t\tif ( !tag[i] ) prime[++Cnt] = i;\n\t\t\trep(j,1,Cnt){\n\t\t\t\tif ( prime[j] * i > N ) break;\n\t\t\t\ttag[i * prime[j]] = 1;\n\t\t\t\tmn[i * prime[j]] = prime[j];\n\t\t\t\tif ( i % prime[j] == 0 ) break;\n\t\t\t}\n\t\t}\n\t}\n}\nusing namespace Prime;\n\nstruct node{\n\tint next,to;\n}e[maxn * maxn];\nint head[maxn],cnt;\nint mx[maxn],my[maxn],dx[maxn],dy[maxn],q[maxn],hh,tt,tot,vis[maxn];\n\ninline void adde(int x,int y){\n\te[++cnt].to = y;\n\te[cnt].next = head[x];\n\thead[x] = cnt;\n}\n\nbool find(int x){\n\tfore(i,x){\n\t\tint to = e[i].to;\n\t\tif ( !vis[to] && dy[to] == dx[x] + 1 ){\n\t\t\tvis[to] = 1;\n\t\t\tif ( !my[to] || find(my[to]) ){\n\t\t\t\tmx[x] = to;\n\t\t\t\tmy[to] = x;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nvoid match(){\n\tmemset(mx,0,sizeof(mx));\n\tmemset(my,0,sizeof(my));\n\ttot = 0;\n\twhile ( 1 ){\n\t\tbool flag = 0;\n\t\ttt = hh = 0;\n\t\trep(i,1,cnt1) if ( !mx[i] ) q[tt++] = i;\n\t\twhile ( hh < tt ){\n\t\t\tint x = q[hh++];\n\t\t\tfore(i,x){\n\t\t\t\tint to = e[i].to;\n\t\t\t\tif ( !dy[to] ){\n\t\t\t\t\tdy[to] = dx[x] + 1;\n\t\t\t\t\tif ( my[to] ){\n\t\t\t\t\t\tdx[my[to]] = dy[to] + 1;\n\t\t\t\t\t\tq[tt++] = my[to]; //入队的点只有左边的点\n\t\t\t\t\t}\n\t\t\t\t\telse flag = 1;//找到增广路\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif ( !flag ) break;\n\t\tmemset(vis,0,sizeof(vis));\n\t\trep(i,1,cnt1) if ( !mx[i] && find(i) ) tot++;\n\t}\n}\n\n\nint main(){\n\tinit();\n\tscanf(\"%d\",&n);\n\trep(i,1,n){\n\t   \tscanf(\"%d\",&a[i]);\n\t\tif ( s.find(a[i]) == s.end() ) s.insert(a[i]);\n\t\telse s.erase(a[i]);\n\n\t\tif ( s.find(a[i] + 1) == s.end() ) s.insert(a[i] + 1);\n\t\telse s.erase(a[i] + 1);\n\t}\n\tfor (auto it = s.begin() ; it != s.end() ; ++it){\n\t\tint x = *it;\n\t\tif ( x & 1 ) odd[++cnt1] = x;\n\t\telse even[++cnt2] = x;\n\t}\n\trep(i,1,cnt1){\n\t\trep(j,1,cnt2){\n\t\t\tint c = abs(odd[i] - even[j]);\n\t\t\tif ( !tag[c] ) adde(i,j);\n\t\t}\n\t}\n\tmatch();\n\tcout<<cnt1 + cnt2 - tot + ((cnt1 - tot) & 1)<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 300\n#define M 10000000\nusing namespace std;\n \ninline int read()\n{\n\tint x=0,f=1; char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1; ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0'; ch=getchar();}\n\treturn x*f;\n}\nint n,A[N],B[N],a[M+10],pri[M];\nint mps[N][N],lk[N],vis[N];\nmap<int,int> Ms;\ninline int find(int x)\n{\n\tfor(int i=1;i<=B[0];i++) if(!vis[i]&&mps[x][i])\n\t{\n\t\tvis[i]=1; if(!lk[i]||find(lk[i]))\n\t\t{\n\t\t\tlk[i]=x; return 1;\n\t\t}\n\t}\n\treturn 0;\n}\nint main()\n{\n\ta[1]=1; for(int i=2;i<=M;i++)\n\t{\n\t\tif(!a[i]) pri[++pri[0]]=i;\n\t\tfor(int j=1;j<=pri[0]&&pri[j]*i<=M;j++)\n\t\t{\n\t\t\ta[pri[j]*i]=1; if(i%pri[j]==0) break;\n\t\t}\n\t}\n\tn=read();\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint x=read(); Ms[x]^=1; Ms[x+1]^=1;\n\t}\n\tmap<int,int> ::iterator it=Ms.begin();\n\tfor(;it!=Ms.end();it++) if(it->second)\n\t{\n\t\tif(it->first&1) A[++A[0]]=it->first;\n\t\telse B[++B[0]]=it->first;\n\t}\n\tfor(int i=1;i<=A[0];i++) for(int j=1;j<=B[0];j++)\n\t\tif(!a[abs(A[i]-B[j])]) mps[i][j]=1;\n\tint ct=0; for(int i=1;i<=A[0];i++)\n\t\tmemset(vis,0,sizeof vis),ct+=find(i);\n\tcout << ct+((A[0]-ct)/2+(B[0]-ct)/2)*2+(A[0]-ct)%2*3 << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <cstring>\n#include <cmath>\nusing namespace std;\n\nconst int MAX_N = 100 + 9;\nconst int MAX_M = 1e7;\n\nint N, x, cnt, match[MAX_N * 2 + 9];//, V;\nbool is_prime[MAX_M + 9], rev[MAX_M + 9], used[MAX_N * 2 + 9];\nvector<int> primes, v1, v2, G[MAX_N * 2 + 9];\n\nvoid sieve() {\n\tmemset(is_prime, 1, sizeof(is_prime));\n\tis_prime[0] = is_prime[1] = 0;\n\tfor (int i = 2; i <= MAX_M; i++) {\n\t\tif (is_prime[i]) primes.push_back(i);\n\t\tfor (int j : primes) {\n\t\t\tif (1LL * i * j > MAX_M) break;\n\t\t\tis_prime[i * j] = false;\n\t\t\tif (i % j == 0) break;\n\t\t}\n\t}\n}\n\nbool dfs(int v) {\n\tfor (int u : G[v]) {\n\t\tif (!used[u]) {\n\t\t\tused[u] = true;\n\t\t\tif (match[u] < 0 || dfs(match[u])) {\n\t\t\t\tmatch[u] = v;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\nvoid bipartite_matching() {\n\tmemset(match, -1, sizeof(match));\n\tfor (int v = 0; v < v1.size(); v++) {\n\t\tmemset(used, 0, sizeof(used));\n\t\tif (dfs(v)) cnt++;\n\t}\n}\n\nint main() {\n\tsieve();\n\tscanf(\"%d\", &N); \n\tfor (int i = 1; i <= N; i++) scanf(\"%d\", &x), rev[x] ^= true;\n\tfor (int i = 1; i <= MAX_M + 1; i++) {\n\t\tif (rev[i] != rev[i - 1]) {\n\t\t\tif (i & 1) v1.push_back(i);\n\t\t\telse v2.push_back(i);\n\t\t}\n\t}\n\tfor (int i = 0; i < v1.size(); i++) {\n\t\tfor (int j = 0; j < v2.size(); j++) {\n\t\t\tint m = abs(v1[i] - v2[j]);\n\t\t\tif (is_prime[m]) G[i].push_back(j);\n\t\t}\n\t}\n//\tV = v1.size() + v2.size();\n\tbipartite_matching();\n\tprintf(\"%d\", cnt + (v1.size() - cnt >> 1 << 1) + (v2.size() - cnt >> 1 << 1) + ((v1.size() - cnt) & 1) * 3);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n  \nusing namespace std;\n  \n#define rep(i,n) REP(i,0,n)\n#define REP(i,s,e) for(int i=(s); i<(int)(e); i++)\n#define repr(i, n) REPR(i, n, 0)\n#define REPR(i, s, e) for(int i=(int)(s-1); i>=(int)(e); i--)\n#define pb push_back\n#define all(r) r.begin(),r.end()\n#define rall(r) r.rbegin(),r.rend()\n#define fi first\n#define se second\n  \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n \nconst int INF = 1e9;\nconst ll MOD = 1e9 + 7;\ndouble EPS = 1e-8;\n\n#define MAX_V 3200\n \nstruct Edge\n{\n    int to, cap, rev;\n    Edge(){};\n    Edge(int to, int cap, int rev) : to(to), cap(cap), rev(rev){};\n};\n \nvector<Edge> G[MAX_V];\nbool used[MAX_V];\n \nvoid add_edge(int from, int to, int cap){\n    G[from].push_back({to, cap, (int)G[to].size()});\n    G[to].push_back({from, 0, (int)G[from].size()-1});\n}\n \nint dfs(int v, int t, int f){\n    if(v == t) return f;\n    used[v] = true;\n    for(int i = 0; i < G[v].size(); i++){\n        Edge& e = G[v][i];\n        if(!used[e.to] && e.cap > 0){\n            int d = dfs(e.to, t, min(f, e.cap));\n            if(d > 0){\n                e.cap -= d;\n                G[e.to][e.rev].cap += d;\n                return d;\n            }\n        }\n    }\n    return 0;\n}\n \nint max_flow(int s, int t){\n    int flow = 0;\n    while(1){\n        memset(used, 0, sizeof(used));\n        int f = dfs(s, t, INF);\n        if(f == 0) return flow;\n        flow += f;\n    }\n}\n\n//エラトステネスの篩を使用\nconst int MAX_PRIME = 1e7 + 10;\n \nvector<int> is_prime(MAX_PRIME,1);\n \nvoid calcPrime(){\n    is_prime[0]=is_prime[1]=0;\n    for(int i=2; i<MAX_PRIME; i++){\n        if(is_prime[i]==1){\n            for(int j=i*2; j<MAX_PRIME; j+=i){\n                is_prime[j]=0;\n            }\n        }\n    }\n}\n\nint main(){\n\tcalcPrime();\n\tint n;\n\tcin >> n;\n\tvi x(n);\n\trep(i, n) cin >> x[i];\n\tmap<int, int> mp;\n\trep(i, n) {\n\t\tmp[x[i]]^=1;\n\t\tmp[x[i]+1]^=1;\n\t}\n\tvi odd, even;\n\tfor(auto& p : mp) if(p.se) (p.fi&1?odd:even).pb(p.se);\n\trep(i, odd.size()) rep(j, even.size()) {\n\t\tif(is_prime[abs(odd[i]-even[j])]) add_edge(1000+i, 2000+j, 1);\n\t}\n\trep(i, odd.size()) add_edge(0, 1000+i, 1);\n\trep(i, even.size()) add_edge(2000+i, 1, 1);\n\tint f = max_flow(0, 1);\n\tint ans = f + (((int)odd.size()-f)/2)*2 + (((int)even.size()-f)/2)*2;\n\tif(((int)odd.size()-f)&1) ans += 3;\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cmath>\n#include<cstring>\n#include<string>\n#include<algorithm>\n#include<vector>\n\n#define maxn 205\n#define maxm 10000005\n\nusing namespace std;\n\ninline int getint()\n{\n\tint num=0,flag=1;char c;\n\twhile((c=getchar())<'0'||c>'9')if(c=='-')flag=-1;\n\twhile(c>='0'&&c<='9')num=num*10+c-48,c=getchar();\n\treturn num*flag;\n}\n\nint n,N;\nint a[maxn],w[maxn][maxn],link[maxn];\nint pri[maxm],cnt;\nbool np[maxm],col[maxm],vis[maxn];\nint X[maxn],Y[maxn],ans;\n\ninline void init()\n{\n\tnp[1]=1;\n\tfor(int i=2;i<=N;i++)\n\t{\n\t\tif(!np[i])pri[++cnt]=i;\n\t\tfor(int j=1;j<=cnt&&i*pri[j]<=N;j++)np[i*pri[j]]=1;\n\t}\n}\n\ninline bool match(int x)\n{\n\tfor(int i=1;i<=Y[0];i++)if(w[x][i]&&!vis[i])\n\t{\n\t\tvis[i]=1;\n\t\tif(!link[i]||match(link[i])){link[i]=x;return 1;}\n\t}\n\treturn 0;\n}\n\nint main()\n{\n\tn=getint();\n\tfor(int i=1;i<=n;i++)N=max(N,a[i]=getint()),col[a[i]]=1;\n\tN++;init();\n\tfor(int i=1;i<=N;i++)if(col[i]^col[i-1])i&1?X[++X[0]]=i:Y[++Y[0]]=i;\n\tfor(int j=1;j<=Y[0];j++)for(int i=1;i<=X[0];i++)w[i][j]=!np[abs(X[i]-Y[j])];\n\tfor(int i=1;i<=X[0];i++)\n\t{\n\t\tmemset(vis,0,sizeof vis);\n\t\tans+=match(i);\n\t}\n\tans+=2*((X[0]-ans)/2)+2*((Y[0]-ans)/2)+3*((X[0]-ans)&1);\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define N 1116\n#define M 111116\n#define inf 1111111116\n#define next nxt\n \nint n,k,a[M],b[M],f[M],next[M],p[N],now[N],d[N],h[N],cnt,ans;\nvector<int> x;\nqueue<int> q;\n \nvoid add(int x,int y){\n\ta[++k]=x;b[k]=y;f[k]=1;next[k]=p[x];p[x]=k;\n\ta[++k]=y;b[k]=x;f[k]=0;next[k]=p[y];p[y]=k;\n}\n \nbool travel(){\n\tmemcpy(now,p,sizeof(p));\n\tfill(d+1,d+n+3,inf);d[n+1]=0;\n\tq.push(n+1);h[n+1]=1;\n\twhile (!q.empty()){\n\t\tint x=q.front();q.pop();h[x]=0;\n\t\tfor (int t=p[x];t;t=next[t])\n\t\t\tif (f[t]&&d[x]+1<d[b[t]]){\n\t\t\t\td[b[t]]=d[x]+1;\n\t\t\t\tif (!h[b[t]]) q.push(b[t]),h[b[t]]=1;\n\t\t\t}\n\t}\n\treturn d[n+2]<inf;\n}\n \nint dinic(int x,int lmt){\n\tif (x==n+2) return lmt;int cnt=0;\n\tfor (int t=now[x];t;t=now[x]=next[t])\n\t\tif (f[t]&&d[x]<d[b[t]]){\n\t\t\tint tmp=dinic(b[t],min(f[t],lmt-cnt));\n\t\t\tf[t]-=tmp;f[t^1]+=tmp;cnt+=tmp;\n\t\t\tif (cnt==lmt) return lmt;\n\t\t}\n\treturn cnt;\n}\n \nbool check(int x){\n\tif (x%2==0||x==1) return false;\n\tfor (int i=2;i*i<=x;i++)\n\t\tif (x%i==0) return false;\n\treturn true;\n}\n \nint read(){\n\tint x=0,f=1;char ch=getchar();\n\tfor (;!isdigit(ch);ch=getchar()) if (ch=='-')  f=-f;\n\tfor (;isdigit(ch);ch=getchar()) x=x*10+ch-'0';\n\treturn x*f;\n}\n \nint main(){\n\tn=read();k=1;x.push_back(0);\n\tfor (int i=1;i<=n;i++){\n\t\tint t=read();\n\t\tif (x.back()==t) x.pop_back();\n\t\telse x.push_back(t);\n\t\tx.push_back(t+1);\n\t}\n\tn=x.size()-1;\n\tfor (int i=1;i<=n;i++)\n\t\tif (x[i]&1) add(n+1,i),cnt++;\n\t\telse {\n\t\t\tfor (int j=1;j<=n;j++)\n\t\t\t\tif (check(abs(x[i]-x[j]))) add(j,i);\n\t\t\tadd(i,n+2);\n\t\t}\n\twhile (travel()) ans+=dinic(n+1,inf);\n\tprintf(\"%d\\n\",n-ans+(cnt-ans)%2);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstring>\n#include <cstdio>\n#include <map>\n#define my_abs(x) ((x) < 0 ? -(x) : (x))\nstd::map<int, int> arr; \nint a[105], b[105], w[105][105], na, nb, from[105]; \nbool vis[105]; \ninline bool chk(int n)\n{\n\tif (n <= 1)\n\t\treturn false; \n\tfor (int i = 2; i * i <= n; i++)\n\t{\n\t\tif (!(n % i))\n\t\t\treturn false; \n\t}\n\treturn true; \n}\nbool dfs(int u)\n{\n\tfor (int v = 0; v < nb; v++)\n\t{\n\t\tif (vis[v] || !w[u][v])\n\t\t\tcontinue; \n\t\tvis[v] = true; \n\t\tif (-1 == from[v] || dfs(from[v]))\n\t\t{\n\t\t\tfrom[v] = u; \n\t\t\treturn true; \n\t\t}\n\t}\n\treturn false; \n}\nint main()\n{\n\t// freopen(\"ARC080-F.in\", \"r\", stdin); \n\tint n, ans = 0; \n\tscanf(\"%d\", &n); \n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tint x; \n\t\tscanf(\"%d\", &x); \n\t\tarr[x] ^= 1; \n\t\tarr[x + 1] ^= 1; \n\t}\n\tfor (auto it : arr)\n\t{\n\t\tif (it.second)\n\t\t\t(it.first & 1 ? a[na++] : b[nb++]) = it.first; \n\t}\n\tfor (int i = 0; i < na; i++)\n\t{\n\t\tfor (int j = 0; j < nb; j++)\n\t\t\tw[i][j] = chk(my_abs(a[i] - b[j])); \n\t}\n\tmemset(from, -1, sizeof(from)); \n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tmemset(vis, false, sizeof(vis)); \n\t\tans += dfs(i); \n\t}\n\tprintf(\"%d\\n\", ans + ((na - ans) / 2 + (nb - ans) / 2) * 2 + (na - ans & 1) * 3);\n\treturn 0; \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 233;\nconst int INF = 1e9;\n\nstruct Edge {\n    int to, rev, cap;\n};\n\nint nv, sv, tv;\nvector<Edge> g[N];\nint dist[N], ptr[N];\n\nvoid add_edge(int a, int b, int c) {\n    g[a].push_back(Edge{b, int(g[b].size()), c});\n    g[b].push_back(Edge{a, int(g[a].size()) - 1, 0});\n    assert(max(a, b) < nv);\n}\n\nbool augment() {\n    fill_n(dist, nv, -1);\n    dist[sv] = 0;\n\n    vector<int> que;\n    que.push_back(sv);\n    for (int i = 0; i < int(que.size()); i++) {\n        int v = que[i];\n        for (auto e: g[v]) {\n            if (dist[e.to] != -1 || e.cap == 0) {\n                continue;\n            }\n            dist[e.to] = dist[v] + 1;\n            if (e.to == tv) {\n                return true;\n            }\n            que.push_back(e.to);\n        }\n    }\n\n    return false;\n}\n\nint dfs(int v, int r) {\n    if (v == tv) {\n        return r;\n    }\n    for (int& i = ptr[v]; i < int(g[v].size()); i++) {\n        auto& e = g[v][i];\n        if (dist[e.to] <= dist[v] || e.cap == 0) {\n            continue;\n        }\n        int d = dfs(e.to, min(r, e.cap));\n        if (d == 0) {\n            continue;\n        }\n        e.cap -= d;\n        g[e.to][e.rev].cap += d;\n        return d;\n    }\n    return 0;\n}\n\nint exec() {\n    int res = 0;\n    while (augment()) {\n        fill_n(ptr, nv, 0);\n        while (true) {\n            int d = dfs(sv, INF);\n            if (d == 0) {\n                break;\n            }\n            res += d;\n        }\n    }\n    return res;\n}\n\nconst int M = int(1e7 + 10);\n\nint n;\nbool isp[M];\n\nvoid precalc() {\n    fill(isp + 2, isp + M, true);\n    for (int i = 2; i * i < M; i++) {\n        if (!isp[i]) {\n            continue;\n        }\n        for (int j = i * i; j < M; j += i) {\n            isp[j] = false;\n        }\n    }\n}\n\nint main() {\n    precalc();\n\n    scanf(\"%d\", &n);\n\n    set<int> a;\n    auto add = [&](int x) {\n        auto it = a.find(x);\n        if (it != a.end()) {\n            a.erase(it);\n        } else {\n            a.insert(x);\n        }\n    };\n\n    for (int i = 0; i < n; i++) {\n        int x;\n        scanf(\"%d\", &x);\n        add(x);\n        add(x + 1);\n    }\n\n    vector<vector<int>> v(2);\n    for (int x: a) {\n        v[x % 2].push_back(x);\n    }\n    int v0s = v[0].size(), v1s = v[1].size();\n\n    sv = 0;\n    tv = 1;\n    nv = v0s + v1s + 2;\n    for (int i = 0; i < v0s; i++) {\n        add_edge(sv, 2 + i, 1);\n    }\n    for (int i = 0; i < v1s; i++) {\n        add_edge(2 + v0s + i, tv, 1);\n    }\n    for (int i = 0; i < v0s; i++) {\n        for (int j = 0; j < v1s; j++) {\n            int d = abs(v[0][i] - v[1][j]);\n            if (d > 2 && isp[d]) {\n                add_edge(2 + i, 2 + v0s + j, 1);\n            }\n        }\n    }\n\n    int used = exec();\n    int ans = used;\n    ans += 2 * ((v0s - used) / 2);\n    ans += 2 * ((v1s - used) / 2);\n    if ((v0s - used) % 2 == 1) {\n        ans += 3;\n    }\n\n    printf(\"%d\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <chrono>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstring>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <iomanip>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n#include <cstdint>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\n#define MP make_pair\n#define PB push_back\n#define inf 1000000007\n#define rep(i,n) for(int i = 0; i < (int)(n); ++i)\n#define all(x) (x).begin(),(x).end()\n\ntemplate<typename A, size_t N, typename T>\nvoid Fill(A (&array)[N], const T &val){\n    std::fill( (T*)array, (T*)(array+N), val );\n}\n \ntemplate<class T> inline bool chmax(T &a, T b){\n    if(a<b){\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T> inline bool chmin(T &a, T b){\n    if(a>b){\n        a = b;\n        return true;\n    }\n    return false;\n}\n\n#define MAX_N 10000010\n\nvector<int> prime;\nbool is_prime[MAX_N];\n\nvoid sieve(int n){\n    for(int i=0;i<=n;i++){\n        is_prime[i] = true;\n    }\n    is_prime[0] = is_prime[1] = false;\n    for(int i=2;i<=n;i++){\n        if(is_prime[i]){\n            prime.push_back(i);\n            for(int j=2*i;j<=n;j+=i){\n                is_prime[j] = false;\n            }\n        }\n    }\n}\n\n \ntemplate<typename CostType, typename TotalCostType = int64_t>\nclass MaximumWeightedMatching {\n  /*\n    Maximum Weighted Matching in General Graphs.\n    - O(nm log(n)) time\n    - O(n + m) space \n \n    Note: each vertex is 1-indexed.\n  */\n public:\n  using cost_t = CostType;\n  using tcost_t = TotalCostType;\n \n private:\n  enum Label { kSeparated = -2, kInner = -1, kFree = 0, kOuter = 1 };\n  static constexpr cost_t Inf = cost_t(1) << (sizeof (cost_t) * 8 - 2);\n \n private:\n  template<typename T>\n  class BinaryHeap {\n   public:\n    struct Node {\n      bool operator < (const Node &rhs) const { return value < rhs.value; }\n      T value; int id;\n    };\n    BinaryHeap() {}\n    BinaryHeap(int N) : size_(0), node(N + 1), index(N, 0) {}\n    int size() const { return size_; }\n    bool empty() const { return size_ == 0; }\n    void clear() { while (size_ > 0) index[node[size_--].id] = 0; }\n    T min() const { return node[1].value; }\n    int argmin() const { return node[1].id; } // argmin ?\n    T get_val(int id) const { return node[index[id]].value; }\n    void pop() { if (size_ > 0) pop(1); }\n    void erase(int id) { if (index[id]) pop(index[id]); }\n    bool has(int id) const { return index[id] != 0; }\n    void update(int id, T v) {\n      if (!has(id)) return push(id, v);\n      bool up = (v < node[index[id]].value);\n      node[index[id]].value = v;\n      if (up) up_heap(index[id]);\n      else down_heap(index[id]);\n    }\n    void decrease_key(int id, T v) {\n      if (!has(id)) return push(id, v);\n      if (v < node[index[id]].value) node[index[id]].value = v, up_heap(index[id]);\n    }\n    void push(int id, T v) {\n      // assert(!has(id));\n      index[id] = ++size_; node[size_] = {v, id};\n      up_heap(size_);\n    }\n   private:\n    void pop(int pos) {\n      index[node[pos].id] = 0;\n      if (pos == size_) { --size_; return; }\n      bool up = (node[size_].value < node[pos].value);\n      node[pos] = node[size_--]; index[node[pos].id] = pos;\n      if (up) up_heap(pos);\n      else down_heap(pos);\n    }\n    void swap_node(int a, int b) {\n      swap(node[a], node[b]); index[node[a].id] = a; index[node[b].id] = b;\n    }\n    void down_heap(int pos) {\n      for (int k = pos, nk = k; 2 * k <= size_; k = nk) {\n        if (node[2 * k] < node[nk]) nk = 2 * k;\n        if (2 * k + 1 <= size_ && node[2 * k + 1] < node[nk]) nk = 2 * k + 1;\n        if (nk == k) break;\n        swap_node(k, nk);\n      }\n    }\n    void up_heap(int pos) {\n      for (int k = pos; k > 1 && node[k] < node[k >> 1]; k >>= 1) swap_node(k, k >> 1);\n    }\n    int size_;\n    vector<Node> node;\n    vector<int> index;\n  };\n \n  template<typename Key>\n  class PairingHeaps {\n   private:\n    struct Node {\n      Node() : prev(-1) {} // \"prev < 0\" means the node is unused.\n      Node(Key v) : key(v), child(0), next(0), prev(0) {}\n      Key key; int child, next, prev;\n    };\n   public:\n    PairingHeaps(int H, int N) : heap(H), node(N) {\n      // It consists of `H` Pairing heaps.\n      // Each heap-node ID can appear at most 1 time(s) among heaps\n      // and should be in [1, N).\n    }\n \n    void clear(int h) { if (heap[h]) clear_rec(heap[h]), heap[h] = 0; }\n    void clear_all() {\n      for (size_t i = 0; i < heap.size(); ++i) heap[i] = 0;\n      for (size_t i = 0; i < node.size(); ++i) node[i] = Node();\n    }\n    bool empty(int h) const { return !heap[h]; }\n    bool used(int v) const { return node[v].prev >= 0; }\n    Key min(int h) const { return node[heap[h]].key; }\n    int argmin(int h) const { return heap[h]; }\n \n    void pop(int h) {\n      // assert(!empty(h));\n      erase(h, heap[h]);\n    }\n    void push(int h, int v, Key key) {\n      // assert(!used(v));\n      node[v] = Node(key);\n      heap[h] = merge(heap[h], v);\n    }\n    void erase(int h, int v) {\n      if (!used(v)) return;\n      int w = two_pass_pairing(node[v].child);\n      if (!node[v].prev) heap[h] = w;\n      else {\n        cut(v);\n        heap[h] = merge(heap[h], w);\n      }\n      node[v].prev = -1;\n    }\n    void decrease_key(int h, int v, Key key) {\n      if (!used(v)) return push(h, v, key);\n      if (!node[v].prev) node[v].key = key;\n      else {\n        cut(v); node[v].key = key;\n        heap[h] = merge(heap[h], v);\n      }\n    }\n \n   private:\n    void clear_rec(int v) {\n      for (; v; v = node[v].next) {\n        if (node[v].child) clear_rec(node[v].child);\n        node[v].prev = -1;\n      }\n    }\n    \n    inline void cut(int v) {\n      auto &n = node[v]; int pv = n.prev, nv = n.next;\n      auto &pn = node[pv];\n      if (pn.child == v) pn.child = nv;\n      else pn.next = nv;\n      node[nv].prev = pv;\n      n.next = n.prev = 0;\n    }\n \n    int merge(int l, int r) {\n      if (!l) return r;\n      if (!r) return l;\n      if (node[l].key > node[r].key) swap(l, r);\n      int lc = node[r].next = node[l].child;\n      node[l].child = node[lc].prev = r;\n      return node[r].prev = l;\n    }\n \n    int two_pass_pairing(int root) {\n      if (!root) return 0;\n      int a = root; root = 0;\n      while (a) {\n        int b = node[a].next, na = 0;\n        node[a].prev = node[a].next = 0;\n        if (b) na = node[b].next, node[b].prev = node[b].next = 0;\n        a = merge(a, b);\n        node[a].next = root; root = a; a = na;\n      }\n      int s = node[root].next; node[root].next = 0;\n      while (s) {\n        int t = node[s].next; node[s].next = 0;\n        root = merge(root, s);\n        s = t;\n      }\n      return root;\n    }\n \n   private:\n    vector<int> heap;\n    vector<Node> node;\n  };\n \n  template<typename T>\n  struct PriorityQueue : public priority_queue<T, vector<T>, greater<T>> {\n    PriorityQueue() {}\n    PriorityQueue(int N) { this->c.reserve(N);}\n    T min() { return this->top(); }\n    void clear() { this->c.clear(); }\n  };\n \n  template<typename T>\n  struct Queue {\n    Queue() {}\n    Queue(int N) : qh(0), qt(0), data(N) {}\n    T operator [] (int i) const { return data[i]; }\n    void enqueue(int u) { data[qt++] = u; }\n    int dequeue() { return data[qh++]; }\n    bool empty() const { return qh == qt; }\n    void clear() { qh = qt = 0; }\n    int size() const { return qt; }\n    int qh, qt;\n    vector<T> data;\n  };\n \n public:\n  struct InputEdge { int from, to; cost_t cost; };\n \n private:\n  template<typename T> using ModifiableHeap = BinaryHeap<T>;\n  template<typename T> using ModifiableHeaps = PairingHeaps<T>;\n  template<typename T> using FastHeap = PriorityQueue<T>;\n \n  struct Edge { int to; cost_t cost; };\n  struct Link { int from, to; };\n  struct Node { \n    struct NodeLink { int b, v; };\n    Node() {}\n    Node(int u) : parent(0), size(1) { link[0] = link[1] = {u, u}; }\n    int next_v() const { return link[0].v; }\n    int next_b() const { return link[0].b; }\n    int prev_v() const { return link[1].v; }\n    int prev_b() const { return link[1].b; }\n    int parent, size;\n    NodeLink link[2];\n  };\n  struct Event {\n    Event() {}\n    Event(cost_t time, int id) : time(time), id(id) {}\n    bool operator < (const Event &rhs) const { return time < rhs.time; }\n    bool operator > (const Event &rhs) const { return time > rhs.time; }\n    cost_t time; int id;\n  };\n  struct EdgeEvent {\n    EdgeEvent() {}\n    EdgeEvent(cost_t time, int from, int to) : time(time), from(from), to(to) {}\n    bool operator > (const EdgeEvent &rhs) const { return time > rhs.time; }\n    bool operator < (const EdgeEvent &rhs) const { return time < rhs.time; }\n    cost_t time; int from, to; \n  };\n \n public:\n  MaximumWeightedMatching(int N, const vector<InputEdge> &in)\n      : N(N), B((N - 1) / 2), S(N + B + 1), ofs(N + 2), edges(in.size() * 2),\n        heap2(S), heap2s(S, S), heap3(edges.size()), heap4(S) {\n \n    for (auto &e : in) ofs[e.from + 1]++, ofs[e.to + 1]++;\n    for (int i = 1; i <= N + 1; ++i) ofs[i] += ofs[i - 1];\n    for (auto &e : in) {\n      edges[ofs[e.from]++] = {e.to, e.cost * 2};\n      edges[ofs[e.to]++] = {e.from, e.cost * 2};\n    }\n    for (int i = N + 1; i > 0; --i) ofs[i] = ofs[i - 1];\n    ofs[0] = 0;\n  }\n \n  pair<tcost_t, vector<int>> maximum_weighted_matching(bool init_matching = false) {\n    initialize();\n    set_potential();\n    if (init_matching) find_maximal_matching();\n    for (int u = 1; u <= N; ++u) if (!mate[u]) do_edmonds_search(u);\n    tcost_t ret = compute_optimal_value();\n    return make_pair(ret, mate);\n  }\n  \n private:\n  tcost_t compute_optimal_value() const {\n    tcost_t ret = 0;\n    for (int u = 1; u <= N; ++u) if (mate[u] > u) {\n      cost_t max_c = 0;\n      for (int eid = ofs[u]; eid < ofs[u + 1]; ++eid) {\n        if (edges[eid].to == mate[u]) max_c = max(max_c, edges[eid].cost);\n      }\n      ret += max_c;\n    }\n    return ret >> 1;\n  }\n \n  inline tcost_t reduced_cost(int u, int v, const Edge &e) const {\n    return tcost_t(potential[u]) + potential[v] - e.cost;\n  }\n \n  void rematch(int v, int w) {\n    int t = mate[v]; mate[v] = w;\n    if (mate[t] != v) return;\n    if (link[v].to == surface[link[v].to]) {\n      mate[t] = link[v].from;\n      rematch(mate[t], t);\n    } else {\n      int x = link[v].from, y = link[v].to;\n      rematch(x, y); rematch(y, x);\n    }\n  }\n \n  void fix_mate_and_base(int b) {\n    if (b <= N) return;\n    int bv = base[b], mv = node[bv].link[0].v, bmv = node[bv].link[0].b;\n    int d = (node[bmv].link[1].v == mate[mv]) ? 0 : 1;\n    while (1) {\n      int mv = node[bv].link[d].v, bmv = node[bv].link[d].b;\n      if (node[bmv].link[1 ^ d].v != mate[mv]) break;\n      fix_mate_and_base(bv); fix_mate_and_base(bmv);\n      bv = node[bmv].link[d].b;\n    }\n    fix_mate_and_base(base[b] = bv);\n    mate[b] = mate[bv];\n  }\n \n  void reset_time() {\n    time_current_ = 0; event1 = {Inf, 0};\n  }\n \n  void reset_blossom(int b) {\n    label[b] = kFree; link[b].from = 0; slack[b] = Inf; lazy[b] = 0;\n  }\n \n  void reset_all() {\n    label[0] = kFree; link[0].from = 0;\n    for (int v = 1; v <= N; ++v) { // should be optimized for sparse graphs.\n      if (label[v] == kOuter) potential[v] -= time_current_;\n      else {\n        int bv = surface[v];\n        potential[v] += lazy[bv];\n        if (label[bv] == kInner) potential[v] += time_current_ - time_created[bv];\n      }\n      reset_blossom(v);\n    }\n    for (int b = N + 1, r = B - unused_bid_idx_; r > 0 && b < S; ++b) if (base[b] != b) {\n      if (surface[b] == b) {\n        fix_mate_and_base(b);\n        if (label[b] == kOuter) potential[b] += (time_current_ - time_created[b]) << 1;\n        else if (label[b] == kInner) fix_blossom_potential<kInner>(b);\n        else fix_blossom_potential<kFree>(b);\n      }\n      heap2s.clear(b);\n      reset_blossom(b); --r;\n    }\n \n    que.clear();\n    reset_time(); heap2.clear();\n    heap3.clear(); heap4.clear();\n  }\n \n  void do_edmonds_search(int root) {\n    if (potential[root] == 0) return;\n    link_blossom(surface[root], {0, 0});\n    push_outer_and_fix_potentials(surface[root], 0);\n    for (bool augmented = false; !augmented; ) {\n      augmented = augment(root);\n      if (augmented) break;\n      augmented = adjust_dual_variables(root);\n    }\n    reset_all();\n  }\n \n  template<Label Lab>\n  inline cost_t fix_blossom_potential(int b) {\n    // Return the amount.\n    // (If v is an atom, the potential[v] will not be changed.)\n    cost_t d = lazy[b]; lazy[b] = 0;\n    if (Lab == kInner) {\n      cost_t dt = time_current_ - time_created[b];\n      if (b > N) potential[b] -= dt << 1;\n      d += dt;\n    }\n    return d;\n  }\n \n  template<Label Lab>\n  inline void update_heap2(int x, int y, int by, cost_t t) {\n    if (t >= slack[y]) return;\n    slack[y] = t; best_from[y] = x;\n    if (y == by) {\n      if (Lab != kInner) heap2.decrease_key(y, EdgeEvent(t + lazy[y], x, y));\n    } else {\n      int gy = group[y];\n      if (gy != y) {\n        if (t >= slack[gy]) return;\n        slack[gy] = t;\n      }\n      heap2s.decrease_key(by, gy, EdgeEvent(t, x, y));\n      if (Lab == kInner) return;\n      EdgeEvent m = heap2s.min(by);\n      heap2.decrease_key(by, EdgeEvent(m.time + lazy[by], m.from, m.to));\n    }\n  }\n \n  void activate_heap2_node(int b) {\n    if (b <= N) {\n      if (slack[b] < Inf) heap2.push(b, EdgeEvent(slack[b] + lazy[b], best_from[b], b));\n    } else {\n      if (heap2s.empty(b)) return;\n      EdgeEvent m = heap2s.min(b);\n      heap2.push(b, EdgeEvent(m.time + lazy[b], m.from, m.to));\n    }\n  }\n \n  void swap_blossom(int a, int b) {\n    // Assume that `b` is a maximal blossom.\n    swap(base[a], base[b]); if (base[a] == a) base[a] = b;\n    swap(heavy[a], heavy[b]); if (heavy[a] == a) heavy[a] = b;\n    swap(link[a], link[b]);\n    swap(mate[a], mate[b]);\n    swap(potential[a], potential[b]); swap(lazy[a], lazy[b]);\n    swap(time_created[a], time_created[b]);\n    for (int d = 0; d < 2; ++d) node[node[a].link[d].b].link[1 ^ d].b = b;\n    swap(node[a], node[b]);\n  }\n \n  void set_surface_and_group(int b, int sf, int g) {\n    surface[b] = sf, group[b] = g;\n    if (b <= N) return;\n    for (int bb = base[b]; surface[bb] != sf; bb = node[bb].next_b()) {\n      set_surface_and_group(bb, sf, g);\n    }\n  }\n \n  void merge_smaller_blossoms(int bid) {\n    int lb = bid, largest_size = 1;\n    for (int beta = base[bid], b = beta; ;) {\n      if (node[b].size > largest_size) largest_size = node[b].size, lb = b;\n      if ((b = node[b].next_b()) == beta) break;\n    }\n    for (int beta = base[bid], b = beta; ;) {\n      if (b != lb) set_surface_and_group(b, lb, b);\n      if ((b = node[b].next_b()) == beta) break;\n    }\n    group[lb] = lb;\n    if (largest_size > 1) {\n      surface[bid] = heavy[bid] = lb; \n      swap_blossom(lb, bid);\n    } else heavy[bid] = 0;\n  }\n \n  void contract(int x, int y, int eid) {\n    int bx = surface[x], by = surface[y]; assert(bx != by);\n    const int h = -(eid + 1);\n    link[surface[mate[bx]]].from = link[surface[mate[by]]].from = h;\n \n    int lca = -1;\n    while (1) {\n      if (mate[by] != 0) swap(bx, by);\n      bx = lca = surface[link[bx].from];\n      if (link[surface[mate[bx]]].from == h) break;\n      link[surface[mate[bx]]].from = h;\n    }\n \n    const int bid = unused_bid[--unused_bid_idx_]; assert(unused_bid_idx_ >= 0);\n    int tree_size = 0;\n    for (int d = 0; d < 2; ++d) {\n      for (int bv = surface[x]; bv != lca; ) {\n        int mv = mate[bv], bmv = surface[mv], v = mate[mv];\n        int f = link[v].from, t = link[v].to;\n        tree_size += node[bv].size + node[bmv].size;\n        link[mv] = {x, y};\n \n        if (bv > N) potential[bv] += (time_current_ - time_created[bv]) << 1;\n        if (bmv > N) heap4.erase(bmv);\n        push_outer_and_fix_potentials(bmv, fix_blossom_potential<kInner>(bmv));\n \n        node[bv].link[d] = {bmv, mv};\n        node[bmv].link[1 ^ d] = {bv, v}; node[bmv].link[d] = {bv = surface[f], f};\n        node[bv].link[1 ^ d] = {bmv, t};\n      }\n      node[surface[x]].link[1 ^ d] = {surface[y], y};\n      swap(x, y);\n    }\n    if (lca > N) potential[lca] += (time_current_ - time_created[lca]) << 1;\n    node[bid].size = tree_size + node[lca].size;\n    base[bid] = lca; link[bid] = link[lca]; mate[bid] = mate[lca];\n    label[bid] = kOuter;\n    surface[bid] = bid; time_created[bid] = time_current_;\n    potential[bid] = 0; lazy[bid] = 0;\n \n    merge_smaller_blossoms(bid); // O(n log n) time / Edmonds search\n  }\n \n  void link_blossom(int v, Link l) {\n    link[v] = {l.from, l.to};\n    if (v <= N) return;\n    int b = base[v]; link_blossom(b, l);\n    int pb = node[b].prev_b();\n    l = {node[pb].next_v(), node[b].prev_v()};\n    for (int bv = b; ; ) {\n      int bw = node[bv].next_b();\n      if (bw == b) break;\n      link_blossom(bw, l);\n      Link nl = {node[bw].prev_v(), node[bv].next_v()};\n      bv = node[bw].next_b();\n      link_blossom(bv, nl);\n    }\n  }\n \n  void push_outer_and_fix_potentials(int v, cost_t d) {\n    label[v] = kOuter;\n    if (v > N) {\n      for (int b = base[v]; label[b] != kOuter; b = node[b].next_b()) {\n        push_outer_and_fix_potentials(b, d);\n      }\n    } else {\n      potential[v] += time_current_ + d;\n      if (potential[v] < event1.time) event1 = {potential[v], v};\n      que.enqueue(v);\n    }\n  }\n \n  bool grow(int root, int x, int y) {\n    int by = surface[y];\n    bool visited = (label[by] != kFree);\n    if (!visited) link_blossom(by, {0, 0});\n    label[by] = kInner; time_created[by] = time_current_; heap2.erase(by);\n    if (y != by) heap4.update(by, time_current_ + (potential[by] >> 1));\n    int z = mate[by];\n    if (z == 0 && by != surface[root]) {\n      rematch(x, y); rematch(y, x);\n      return true;\n    }\n    int bz = surface[z];\n    if (!visited) link_blossom(bz, {x, y}); \n    else link[bz] = link[z] = {x, y};\n    push_outer_and_fix_potentials(bz, fix_blossom_potential<kFree>(bz));\n    time_created[bz] = time_current_; heap2.erase(bz);\n    return false;\n  }\n \n  void free_blossom(int bid) {\n    unused_bid[unused_bid_idx_++] = bid;\n    base[bid] = bid;\n  }\n \n  int recalculate_minimum_slack(int b, int g) {\n    // Return the destination of the best edge of blossom `g`.\n    if (b <= N) {\n      if (slack[b] >= slack[g]) return 0;\n      slack[g] = slack[b]; best_from[g] = best_from[b];\n      return b;\n    }\n    int v = 0;\n    for (int beta = base[b], bb = beta; ; ) {\n      int w = recalculate_minimum_slack(bb, g);\n      if (w != 0) v = w;\n      if ((bb = node[bb].next_b()) == beta) break;\n    }\n    return v;\n  }\n \n  void construct_smaller_components(int b, int sf, int g) {\n    surface[b] = sf, group[b] = g; // `group[b] = g` is unneeded.\n    if (b <= N) return;\n    for (int bb = base[b]; surface[bb] != sf; bb = node[bb].next_b()) {\n      if (bb == heavy[b]) {\n        construct_smaller_components(bb, sf, g);\n      } else {\n        set_surface_and_group(bb, sf, bb);\n        int to = 0;\n        if (bb > N) slack[bb] = Inf, to = recalculate_minimum_slack(bb, bb);\n        else if (slack[bb] < Inf) to = bb;\n        if (to > 0) heap2s.push(sf, bb, EdgeEvent(slack[bb], best_from[bb], to));\n      }\n    }\n  }\n \n  void move_to_largest_blossom(int bid) {\n    const int h = heavy[bid];\n    cost_t d = (time_current_ - time_created[bid]) + lazy[bid]; lazy[bid] = 0;\n    for (int beta = base[bid], b = beta; ;) {\n      time_created[b] = time_current_;\n      lazy[b] = d;\n      if (b != h) construct_smaller_components(b, b, b), heap2s.erase(bid, b);\n      if ((b = node[b].next_b()) == beta) break;\n    }\n    if (h > 0) swap_blossom(h, bid), bid = h;\n    free_blossom(bid);\n  }\n \n  void expand(int bid) {\n    int mv = mate[base[bid]];\n    move_to_largest_blossom(bid); // O(n log n) time / Edmonds search\n    Link old_link = link[mv];\n    int old_base = surface[mate[mv]], root = surface[old_link.to];\n    int d = (mate[root] == node[root].link[0].v) ? 1 : 0;\n    for (int b = node[old_base].link[d ^ 1].b; b != root; ) {\n      label[b] = kSeparated; activate_heap2_node(b); b = node[b].link[d ^ 1].b;\n      label[b] = kSeparated; activate_heap2_node(b); b = node[b].link[d ^ 1].b;\n    }\n    for (int b = old_base; ; b = node[b].link[d].b) {\n      label[b] = kInner;\n      int nb = node[b].link[d].b;\n      if (b == root) link[mate[b]] = old_link;\n      else link[mate[b]] = {node[b].link[d].v, node[nb].link[d ^ 1].v};\n      link[surface[mate[b]]] = link[mate[b]]; // fix tree links\n      if (b > N) {\n        if (potential[b] == 0) expand(b);\n        else heap4.push(b, time_current_ + (potential[b] >> 1));\n      }\n      if (b == root) break;\n      push_outer_and_fix_potentials(nb, fix_blossom_potential<kInner>(b = nb));\n    }\n  }\n \n  bool augment(int root) {\n    // Return true if an augmenting path is found.\n    while (!que.empty()) {\n      int x = que.dequeue(), bx = surface[x];\n      if (potential[x] == time_current_) {\n        if (x != root) rematch(x, 0);\n        return true;\n      }\n      for (int eid = ofs[x]; eid < ofs[x + 1]; ++eid) {\n        auto &e = edges[eid]; int y = e.to, by = surface[y];\n        if (bx == by) continue;\n        Label l = label[by];\n        if (l == kOuter) {\n          cost_t t = reduced_cost(x, y, e) >> 1; // < 2 * Inf\n          if (t == time_current_) {\n            contract(x, y, eid); bx = surface[x];\n          } else if (t < event1.time) {\n            heap3.emplace(t, x, eid);\n          }\n        } else {\n          tcost_t t = reduced_cost(x, y, e); // < 3 * Inf\n          if (t >= Inf) continue;\n          if (l != kInner) {\n            if (cost_t(t) + lazy[by] == time_current_) {\n              if (grow(root, x, y)) return true;\n            } else update_heap2<kFree>(x, y, by, t);\n          } else {\n            if (mate[x] != y) update_heap2<kInner>(x, y, by, t);\n          } \n        }\n      }\n    }\n    return false;\n  }\n \n  bool adjust_dual_variables(int root) {\n    // delta1 : rematch\n    cost_t time1 = event1.time;\n \n    // delta2 : grow\n    cost_t time2 = Inf;\n    if (!heap2.empty()) time2 = heap2.min().time;\n \n    // delta3 : contract : O(m log n) time / Edmonds search [ bottleneck (?) ]\n    cost_t time3 = Inf;\n    while (!heap3.empty()) {\n      EdgeEvent e = heap3.min();\n      int x = e.from, y = edges[e.to].to; // e.to is some edge id.\n      if (surface[x] != surface[y]) {\n        time3 = e.time;\n        break;\n      } else heap3.pop();\n    }\n \n    // delta4 : expand\n    cost_t time4 = Inf;\n    if (!heap4.empty()) time4 = heap4.min();\n \n    // -- events --\n    cost_t time_next = min(min(time1, time2), min(time3, time4));\n    assert(time_current_ <= time_next && time_next < Inf);\n    time_current_ = time_next;\n \n    if (time_current_ == event1.time) {\n      int x = event1.id;\n      if (x != root) rematch(x, 0);\n      return true;\n    }\n    while (!heap2.empty() && heap2.min().time == time_current_) {\n      int x = heap2.min().from, y = heap2.min().to;\n      if (grow(root, x, y)) return true; // `grow` function will call `heap2.erase(by)`.\n    }\n    while (!heap3.empty() && heap3.min().time == time_current_) {\n      int x = heap3.min().from, eid = heap3.min().to;\n      int y = edges[eid].to; heap3.pop();\n      if (surface[x] == surface[y]) continue;\n      contract(x, y, eid);\n    }\n    while (!heap4.empty() && heap4.min() == time_current_) {\n      int b = heap4.argmin(); heap4.pop();\n      expand(b);\n    }\n    return false;\n  }\n \n private:\n  void initialize() {\n    que = Queue<int>(N);\n    mate.assign(S, 0);\n    link.assign(S, {0, 0});\n    label.assign(S, kFree);\n    base.resize(S); for (int u = 1; u < S; ++u) base[u] = u;\n    surface.resize(S); for (int u = 1; u < S; ++u) surface[u] = u;\n \n    potential.resize(S);\n    node.resize(S); for (int b = 1; b < S; ++b) node[b] = Node(b);\n \n    unused_bid.resize(B); for (int i = 0; i < B; ++i) unused_bid[i] = N + B - i;\n    unused_bid_idx_ = B;\n \n    // for O(nm log n) implementation\n    reset_time();\n    time_created.resize(S);\n    slack.resize(S); for (int i = 0; i < S; ++i) slack[i] = Inf;\n    best_from.assign(S, 0);\n    heavy.assign(S, 0);\n    lazy.assign(S, 0);\n    group.resize(S); for (int i = 0; i < S; ++i) group[i] = i;\n  }\n \n  void set_potential() {\n    for (int u = 1; u <= N; ++u) {\n      cost_t max_c = 0;\n      for (int eid = ofs[u]; eid < ofs[u + 1]; ++eid) {\n        max_c = max(max_c, edges[eid].cost);\n      }\n      potential[u] = max_c >> 1;\n    }\n  }\n \n  void find_maximal_matching() {\n    // Find a maximal matching naively.\n    for (int u = 1; u <= N; ++u) if (!mate[u]) {\n      for (int eid = ofs[u]; eid < ofs[u + 1]; ++eid) {\n        auto &e = edges[eid]; int v = e.to;\n        if (mate[v] > 0 || reduced_cost(u, v, e) > 0) continue;\n        mate[u] = v; mate[v] = u;\n        break;\n      }\n    }\n  }\n \n private:\n  int N, B, S; // N = |V|, B = (|V| - 1) / 2, S = N + B + 1\n  vector<int> ofs;\n  vector<Edge> edges;\n \n  Queue<int> que;\n  vector<int> mate, surface, base;\n  vector<Link> link;\n  vector<Label> label;\n  vector<cost_t> potential;\n \n  vector<int> unused_bid; int unused_bid_idx_;\n  vector<Node> node;\n \n  // for O(nm log n) implementation\n  vector<int> heavy, group;\n  vector<cost_t> time_created, lazy, slack;\n  vector<int> best_from;\n \n  cost_t time_current_;\n  Event event1;\n  ModifiableHeap<EdgeEvent> heap2;\n  ModifiableHeaps<EdgeEvent> heap2s;\n  FastHeap<EdgeEvent> heap3;\n  ModifiableHeap<cost_t> heap4;\n};\n \nusing cost_t = int;\nusing tcost_t = long long;\n \nusing MWM = MaximumWeightedMatching<cost_t, tcost_t>;\nusing Edge = MWM::InputEdge;\n \npair<tcost_t, vector<int>> maximum_weighted_matching(int n, vector<int> from, vector<int> to, vector<cost_t> cost) {\n  int m = (int) cost.size();\n  vector<Edge> edges(m * 2);\n  vector<int> ou(n + 2), ov(n + 2);\n  for (int i = 0; i < m; ++i) {\n    edges[i] = {from[i] + 1, to[i] + 1, cost[i]};\n    ++ou[from[i] + 2];\n    ++ov[to[i] + 2];\n  }\n  for (int i = 1; i <= n + 1; ++i) {\n    ov[i] += ov[i - 1];\n  }\n  for (int i = 0; i < m; ++i) {\n    edges[m + (ov[edges[i].to]++)] = edges[i];\n  }\n  for (int i = 1; i <= n + 1; ++i) {\n    ou[i] += ou[i - 1];\n  }\n  for (int i = 0; i < m; ++i) {\n    edges[ou[edges[i + m].from]++] = edges[i + m];\n  }\n  edges.resize(m);\n  pair<tcost_t, vector<int>> ans = MWM(n, edges).maximum_weighted_matching();\n  for (int i = 0; i < n; ++i) {\n    ans.second[i] = ans.second[i + 1] - 1;\n  }\n  ans.second.resize(n);\n  return ans;\n}\n\nint a[MAX_N];\n\nint main(){\n    sieve(10000001);\n    is_prime[2] = 0;\n    int n;\n    cin >> n;\n    rep(i,n){\n        int c;\n        cin >> c;\n        a[c]++;\n        a[c+1]--;\n    }\n    vector<int>x;\n    rep(i,MAX_N){\n        if(a[i]==1||a[i]==-1){\n            x.push_back(i);\n            cerr << i <<\" \";\n        }\n    }\n    cerr << endl;\n    int m = x.size();\n    vector<int> from,to,cost;\n    rep(i,m){\n        rep(j,i){\n            from.push_back(i);\n            to.push_back(j);\n            if(is_prime[x[i]-x[j]]){\n                cost.push_back(10000-1);\n            }else if((x[i]-x[j])%2==0){\n                cost.push_back(10000-2);\n            }else{\n                cost.push_back(10000-3);\n            }\n        }\n    }\n    auto res = maximum_weighted_matching(m,from,to,cost);\n    cout << (10000*m/2)-res.first << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 10000001;\n\n\nint n,fre[maxn],p[220],ispr[maxn],even,odd,wrong;\nvector <int> edge[220],v2;\n\nbool fin(int u) {\n    if (fre[u]==wrong) return false;\n    fre[u]=wrong;\n    for (int j=0;j<edge[u].size();j++) {\n        int v=edge[u][j];\n       // cout<<u<<\" \"<<v<<endl;\n        if (p[v]==0 || fin(p[v])) {\n            p[v]=u;\n            p[u]=v;\n            return true;\n        }\n    }\n    return false;\n}\n\nint main() {\n  //  freopen(\"in.txt\",\"r\",stdin);\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    ispr[1]=1;\n    for (int i=2;i<maxn;i++)\n        if (ispr[i]==0) {\n            for (int j=i+i;j<maxn;j+=i) ispr[j]=1;\n        }\n    cin>>n;\n    for (int i=1;i<=n;i++) {\n        int x;\n        cin>>x;\n        fre[x]^=1;\n        fre[x+1]^=1;\n    }\n    even=0; odd=0; wrong=2;\n    for (int i=0;i<maxn;i++)\n        if (fre[i]==1) {\n            v2.push_back(i);\n            if (i%2==0) even++;\n            else odd++;\n        }\n    // for (int i=0;i<v2.size();i++) cout<<v2[i]<<\" \";\n   //  cout<<endl;\n   // cout<<\" \" <<even<<\" \"<<odd<<endl;\n    for (int i=0;i<v2.size();i++)\n        for (int j=i+1;j<v2.size();j++)\n            if (ispr[ v2[j] - v2[i] ]==0) {\n              //  cout<<i<<\" \"<<j<<\" \"<<v2[i]<<\" \"<<v2[j]<<endl;\n                edge[i+1].push_back(j+1);\n                edge[j+1].push_back(i+1);\n            }\n    int cnt=0;\n    for (int i=0;i<v2.size();i++)\n     if (p[i+1]==0) {\n        wrong++;\n        p[i+1]=i+1;\n        //cout<<fin(i+1)<<endl;\n        cnt+=(fin(i+1));\n       // cout<<p[i+1]<<endl;\n      //  cout<<\"fuck\"<<endl;\n    }\n   // cout<<cnt<<\" \" <<even<<\" \"<<odd<<endl;\n    cout<< cnt + ((even-cnt)/2 + (odd-cnt)/2) * 2 + (even%2)*3;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAXN 10000000\n#define PI acos(-1.0)\n#define mo 1000000007\n#define INF 0x3f3f3f3f\n#define eps 1e-8\ntypedef long long LL;\n\nint n, a[110];\nint f[110][110][2];\n\nint p[MAXN + 10];\nbool vis[MAXN + 10];\n\nvoid Prime()\n{\n    g[1] = 3;\n    for(int i = 2; i <= MAXN; ++i){\n        if(!vis[i]){\n            p[++p[0]] = i;\n            if(i == 2) g[i] = 2;\n            else g[i] = 1;\n        }\n        else if(i & 1) g[i] = 3;\n        else g[i] = 2;\n        for(int j = 1; j <= p[0] && 1LL * i * p[j] <= MAXN; ++j){\n            vis[i * p[j]] = true;\n            if(!(i % p[j])) break;\n        }\n    }\n}\n\nvoid Init()\n{\n    scanf(\"%d\", &n);\n    for(int i = 1; i <= n; ++i){\n        scanf(\"%d\", a + i);\n        f[i][i][0] = 3;\n        f[i][i][1] = 0;\n    }\n    for(i = 1; i <= 10000000; ++i)\n}\n\nvoid DP()\n{\n    for(j = 1; j < n; ++j){\n        for(i = 1; i + j <= n; ++i){\n            for(k = i; k <= i + j; ++k){\n                f[i][i + j][0] = min(f[i][i + j][0], f[i][k][0] + f[k + 1][j][0]);\n                f[i][i + j][0] = min(f[i][i + j][0], f[i][k][1] + f[k][j][1] + g[a[i + j] - a[i] + 1]);\n                f[i][i + j][1] = min(f[i][i + j][1], f[i][k][0] + f[k + 1][j][0] + g[a[i + j] - a[i] + 1]);\n                f[i][i + j][1] = min(f[i][i + j][1], f[i][k][1] + f[k][j][1]);\n            }\n        }\n    }\n    printf(\"%d\\n\", f[1][n]);\n}\n\nint main()\n{\n    Init();\n    RMI();\n    Work();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <sys/time.h>\nusing namespace std;\n\n#define rep(i,n) for(long long i = 0; i < (long long)(n); i++)\n#define repi(i,a,b) for(long long i = (long long)(a); i < (long long)(b); i++)\n#define pb push_back\n#define all(x) (x).begin(), (x).end()\n#define fi first\n#define se second\n#define mt make_tuple\n#define mp make_pair\n#define ZERO(a) memset(a,0,sizeof(a))\ntemplate<class T1, class T2> bool chmin(T1 &a, T2 b) { return b < a && (a = b, true); }\ntemplate<class T1, class T2> bool chmax(T1 &a, T2 b) { return a < b && (a = b, true); }\n#define exists find_if\n#define forall all_of\n\nusing ll = long long; using vll = vector<ll>; using vvll = vector<vll>; using P = pair<ll, ll>;\nusing ld = long double;  using vld = vector<ld>; \nusing vi = vector<int>; using vvi = vector<vi>; vll conv(vi& v) { vll r(v.size()); rep(i, v.size()) r[i] = v[i]; return r; }\n\ninline void input(int &v){ v=0;char c=0;int p=1; while(c<'0' || c>'9'){if(c=='-')p=-1;c=getchar();} while(c>='0' && c<='9'){v=(v<<3)+(v<<1)+c-'0';c=getchar();} v*=p; }\ntemplate <typename T, typename U> ostream &operator<<(ostream &o, const pair<T, U> &v) {  o << \"(\" << v.first << \", \" << v.second << \")\"; return o; }\ntemplate<size_t...> struct seq{}; template<size_t N, size_t... Is> struct gen_seq : gen_seq<N-1, N-1, Is...>{}; template<size_t... Is> struct gen_seq<0, Is...> : seq<Is...>{};\ntemplate<class Ch, class Tr, class Tuple, size_t... Is>\nvoid print_tuple(basic_ostream<Ch,Tr>& os, Tuple const& t, seq<Is...>){ using s = int[]; (void)s{0, (void(os << (Is == 0? \"\" : \", \") << get<Is>(t)), 0)...}; }\ntemplate<class Ch, class Tr, class... Args> \nauto operator<<(basic_ostream<Ch, Tr>& os, tuple<Args...> const& t) -> basic_ostream<Ch, Tr>& { os << \"(\"; print_tuple(os, t, gen_seq<sizeof...(Args)>()); return os << \")\"; }\nostream &operator<<(ostream &o, const vvll &v) { rep(i, v.size()) { rep(j, v[i].size()) o << v[i][j] << \" \"; o << endl; } return o; }\ntemplate <typename T> ostream &operator<<(ostream &o, const vector<T> &v) { o << '['; rep(i, v.size()) o << v[i] << (i != v.size()-1 ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T>  ostream &operator<<(ostream &o, const set<T> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it << (next(it) != m.end() ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T>  ostream &operator<<(ostream &o, const unordered_set<T> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it << (next(it) != m.end() ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T, typename U>  ostream &operator<<(ostream &o, const map<T, U> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it << (next(it) != m.end() ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T, typename U, typename V>  ostream &operator<<(ostream &o, const unordered_map<T, U, V> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it; o << \"]\";  return o; }\nvector<int> range(const int x, const int y) { vector<int> v(y - x + 1); iota(v.begin(), v.end(), x); return v; }\ntemplate <typename T> istream& operator>>(istream& i, vector<T>& o) { rep(j, o.size()) i >> o[j]; return i;}\nstring bits_to_string(ll input, ll n=64) { string s; rep(i, n) s += '0' + !!(input & (1ll << i)); reverse(all(s)); return s; }\ntemplate <typename T> ostream &operator<<(ostream &o, const priority_queue<T> &v) { auto tmp = v; while (tmp.size()) { auto x = tmp.top(); tmp.pop(); o << x << \" \";} o << endl; return o; }\n\ntemplate <typename T> unordered_map<T, ll> counter(vector<T> vec){unordered_map<T, ll> ret; for (auto&& x : vec) ret[x]++; return ret;};\nstring substr(string s, P x) {return s.substr(x.fi, x.se - x.fi); }\nvoid vizGraph(vvll& g, int mode = 0, string filename = \"out.png\") { ofstream ofs(\"./out.dot\"); ofs << \"digraph graph_name {\" << endl; set<P> memo; rep(i, g.size())  rep(j, g[i].size()) { if (mode && (memo.count(P(i, g[i][j])) || memo.count(P(g[i][j], i)))) continue; memo.insert(P(i, g[i][j])); ofs << \"    \" << i << \" -> \" << g[i][j] << (mode ? \" [arrowhead = none]\" : \"\")<< endl;  } ofs << \"}\" << endl; ofs.close(); system(((string)\"dot -T png out.dot >\" + filename).c_str()); }\n\nsize_t random_seed; namespace std { using argument_type = P; template<> struct hash<argument_type> { size_t operator()(argument_type const& x) const { size_t seed = random_seed; seed ^= hash<ll>{}(x.fi); seed ^= (hash<ll>{}(x.se) << 1); return seed; } }; }; // hash for various class\nnamespace myhash{ const int Bsizes[]={3,9,13,17,21,25,29,33,37,41,45,49,53,57,61,65,69,73,77,81}; const int xor_nums[]={0x100007d1,0x5ff049c9,0x14560859,0x07087fef,0x3e277d49,0x4dba1f17,0x709c5988,0x05904258,0x1aa71872,0x238819b3,0x7b002bb7,0x1cf91302,0x0012290a,0x1083576b,0x76473e49,0x3d86295b,0x20536814,0x08634f4d,0x115405e8,0x0e6359f2}; const int hash_key=xor_nums[rand()%20]; const int mod_key=xor_nums[rand()%20]; template <typename T> struct myhash{ std::size_t operator()(const T& val) const { return (hash<T>{}(val)%mod_key)^hash_key; } }; };\ntemplate <typename T> class uset:public std::unordered_set<T,myhash::myhash<T>> { using SET=std::unordered_set<T,myhash::myhash<T>>; public: uset():SET(){SET::rehash(myhash::Bsizes[rand()%20]);} };\nuint32_t randxor() { static uint32_t x=1+(uint32_t)random_seed,y=362436069,z=521288629,w=88675123; uint32_t t; t=(x^(x<<11));x=y;y=z;z=w; return( w=(w^(w>>19))^(t^(t>>8)) ); }\nstruct timeval start; double sec() { struct timeval tv; gettimeofday(&tv, NULL); return (tv.tv_sec - start.tv_sec) + (tv.tv_usec - start.tv_usec) * 1e-6; }\nstruct init_{init_(){ gettimeofday(&start, NULL); ios::sync_with_stdio(false); cin.tie(0); struct timeval myTime; struct tm *time_st; gettimeofday(&myTime, NULL); time_st = localtime(&myTime.tv_sec); srand(myTime.tv_usec); random_seed = RAND_MAX / 2 + rand() / 2; }} init__;\n#define rand randxor\n\nstatic const double EPS = 1e-14;\nstatic const long long INF = 1e18;\nstatic const long long mo = 1e9+7;\n#define ldout fixed << setprecision(40) \n\n/***********************/\n// 共通部分\n/***********************/\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n\ntypedef long long Weight;\n\nstruct Edge {\n    ll src, dst;\n    Weight weight; // 最小費用流ではcostの役割\n    ll cap;\n    ll rev; // 残余グラフの対応用\n    bool rev_flag = false; // revなら1\n    Edge(int src = 0, int dst = 0, int weight = 0, Weight cap = 1): \n        src(src), dst(dst), weight(weight), cap(cap){ }\n};\nbool operator < (const Edge &e, const Edge &f) {\n    return e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n        e.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n\n// 最大流と最小費用流の有向\n// 無向は自分でひっくり返して追加して下さい\nvoid addDirected(Graph& g, ll src, ll dst, Weight weight = 0, ll cap = 0) {\n    assert(src < g.size() && src >= 0 && dst < g.size() && dst >= 0);\n    g[src].push_back(Edge(src, dst, weight, cap)); \n}\nvector<string> names;\nunordered_map<string, int> name_server;\nvoid clearNameServer(void) {\n    names.clear();\n    name_server.clear();\n}\nint constructNameServer(vector<string>& names_) {\n    names = names_;\n    for (int i = 0; i < names.size(); i++) {\n        name_server[names[i]] = i;\n    }\n    return name_server.size();\n}\nvoid addDirected(Graph& g, string src, string dst, Weight weight = 0, ll cap = 0) {\n    if (!name_server.count(src)) { cerr << \"No such node : \" << src << endl; exit(1); }\n    if (!name_server.count(dst)) { cerr << \"No such node : \" << dst << endl; exit(1); }\n    addDirected(g, name_server[src], name_server[dst], weight, cap);\n}\n\nvoid addUndirected(Graph& g, ll src, ll dst, Weight weight = 0, ll cap = 0) { \n    addDirected(g, src, dst, weight, cap);\n    addDirected(g, dst, src, weight, cap);\n} \n\nvoid transformFromMatrixToGraph(Graph& g, Matrix& m) {\n    ll n = m.size();\n    g.resize(n);\n    rep(i, n) rep(j, n) if (m[i][j] != INF) {\n        addDirected(g, i, j, m[i][j]);\n    }\n}\n\nvoid printGraph(Graph& g) {\n    rep(i, g.size()) {\n        if (!g[i].size())\n            continue;\n        rep(j, g[i].size()) \n            cout << \"(\" << i << \", \" << g[i][j].dst << \"), \";\n        cout << endl;\n    }\n}\nvoid printGraphCap(Graph& g) {\n    rep(i, g.size()) {\n        if (!g[i].size())\n            continue;\n        rep(j, g[i].size()) \n            cout << \"(\" << i << \", \" << g[i][j].dst << \" : \" << g[i][j].cap << \", \" << (g[i][j].rev_flag ? \"rev\" : \"for\") << \"), \";\n        cout << endl;\n    }\n}\n\n// mode\n//\n// 0 : デフォルト。辺だけ表示\n// 1 : 重みweightだけ表示\n// 2 : フロー用。weight, capを表示。\nvoid vizGraph(Graph& g, int mode = 0, string filename = \"out.png\") {\n    ofstream ofs(\"./out.dot\");\n    ofs << \"digraph graph_name {\" << endl;\n    rep(i, g.size()) {\n        if (!g[i].size())\n            continue;\n        rep(j, g[i].size()) {\n            if (name_server.size()) {\n                ofs << \"    \" << names[i] << \" -> \" << names[g[i][j].dst]; \n            } else {\n                ofs << \"    \" << i << \" -> \" << g[i][j].dst; \n            }\n            if (mode == 1) {\n                ofs << \" [ label = \\\"\" << g[i][j].weight << \"\\\"];\"; \n            } else if (mode == 2) {\n                ofs << \" [ label = \\\"\" << g[i][j].weight << \"/\" << (g[i][j].cap  == INF ? \"inf\" : to_string(g[i][j].cap)) << \"\\\"];\"; \n            }\n            ofs << endl;\n        }\n    }\n    ofs << \"}\" << endl;\n    ofs.close();\n    system(((string)\"dot -T png out.dot >\" + filename).c_str());\n}\n\nclass FordFulkerson {\npublic:\n    Graph g; // 残余ネットワーク\n    int s, t; // 始点, 終点\n    int n; // 頂点数\n    ll flow = 0; // 最大フロー、これを辺追加・削除時にきちんと情報を保つ\n\n    // 普通のフォードフルカーソン\n    // O(E ret)\n    FordFulkerson(Graph& input, int s_, int t_) : s(s_), t(t_) {\n        n = input.size();\n        g.resize(n);\n        used.resize(n);\n        for (auto&& from : input) {\n            for (auto&& e_for : from) {\n                addEdge(e_for);\n            }\n        }\n\n        flow = 0;\n        revise();\n    }\n    // 順向きの辺のsrc, dst, capの情報から、\n    // 残余グラフの順逆辺を追加する\n    void addEdge(Edge& e_for) {\n        Edge e_rev;\n        e_rev.src = e_for.dst; \n        e_rev.dst = e_for.src;\n        e_rev.cap = 0;\n\n        e_for.rev = g[e_rev.src].size();\n        e_rev.rev = g[e_for.src].size(); // 逆辺のマーカー\n        e_rev.rev_flag = true;\n        g[e_for.src].push_back(e_for);\n        g[e_rev.src].push_back(e_rev);\n    }\n    // 残余グラフが初期、あるいは変更された時に\n    // flowを再計算する\n    //\n    // O(V ret)\n    ll revise(void) {\n        while (1) {\n            ll f = update(INF);\n            if (!f) { // 残余グラフが収束したら\n                break;\n            }\n            flow += f;\n        }\n        return flow;\n    }\n\n    // 一回だけ、\n    // 残余グラフで、vからtへの正のパスを探して、あればそこに流す\n    //\n    // sからtへ移動可能ならそのルートの最大流量を返し、不可能なら0を返す。\n    // fは流そうとしている流量\n    //\n    // O(V)\n    vector<bool> used;\n    int dfs(int v/*from*/, int to, ll f) {\n        rep(i, n) {\n            used[i] = 0;\n        }\n        return dfs_rec(v, to, f);\n    }\n    int dfs_rec(int v/*from*/, int to, ll f) {\n        if (v == to)\n            return f;\n        used[v] = true;\n        for (int i = 0; i < g[v].size(); i++) {\n            Edge &e = g[v][i];\n            if (used[e.dst] || e.cap <= 0) \n                continue;\n            // キャパシティが残っている辺を探す \n            int d = dfs_rec(e.dst, to, min(f, e.cap)); // 流そうとしてる流量、キャパシティのうち小さい方を次に流そうとする\n            if (d > 0) {\n                e.cap -= d; // 残余グラフの辺を更新\n                g[e.dst][e.rev].cap += d; // 残余グラフの逆辺を更新\n                return d;\n            }\n        }\n        return 0;\n    }\n\n    // 一回だけDFSのラッパ関数。\n    // s, tが予め指定されているなら、こっちを使ったほうが簡潔\n    //\n    // O(V)\n    int update(ll f) {\n        return update(f, t);\n    }\n    int update(ll f, int to) {\n        return dfs(s, to, f);\n    }\n\n    // sからtへの最大流量を返す。\n    // s == tならINFを返す, 不可能なら0を返す\n    ll get(void) {\n        return flow;\n    }\n\n    // O(V) \n    // fromからtoへの有向辺にcapを追加して、その時の最大流量を返す\n    // もし有向辺がもともとはなかったら辺を追加する\n    int add(int from, int to, ll cap) {\n        bool found = false;\n        rep(i, g[from].size()) {\n            Edge& e = g[from][i];\n            if (e.rev_flag) continue;\n            if (e.dst == to) { // もともとあったら\n                e.cap += cap;\n                found = true;\n                break;\n            }\n        }\n        if (found == false) {\n            Edge e;\n            e.src = from;\n            e.dst = to;\n            e.cap = cap;\n            this->addEdge(e);\n        }\n        revise();\n        return flow;\n    }\n\n    //  最 大 流 自 体 は 変 え ず に、from->toのフローを最小化したグラフに置き換える。\n    //\n    // fromからtoへの辺のフロー=to->fromの逆辺コストを、代替パス=from->toのパスを探すことで、最大流を変えない条件下でなるべく低下させる。\n    // from->toのパスの下がったフローの量を返し、副作用でfrom->toのフロー最小化グラフへとgを書き換える。\n    //\n    // from->パス->to->fromで、ループが出来るならば、\n    // from->toの逆辺をループのコスト分だけ下げることができる。\n    // パスもコスト分だけ下げたあとに、逆辺を上げることが出来る。\n    //\n    // O(V ret)\n    ll minimizeFlowOfEdgePreservingMaxFlow(int from, int to) {\n        ll sum = 0;\n        rep(i, g[from].size()) {\n            Edge& e = g[from][i];\n            if (e.rev_flag) continue;\n            if (e.dst != to) continue;\n            if (g[e.dst][e.rev].cap == 0) continue;\n            // フローが流れているfromからtoへの順向き辺を全列挙\n\n            Edge& e_rev = g[e.dst][e.rev];\n            // 消すべき辺のフローを頑張って全部押し戻そうとする\n            // 押し戻しきれなかったらあとで考える\n            ll ret = 0;\n            while (1) { // TODO 必要な分だけ空ければいい\n                // e.srcを通る残余グラフの閉路があれば押し戻せる\n                vector<bool> used(n);\n                function<ll(ll, ll)> dfs_lam = [&](ll v, ll c) {\n                    if (v == e.dst) {\n                        return c;\n                    }\n                    used[v] = true;\n                    for (auto&& tmp : g[v]) if (used[tmp.dst] == false && tmp.cap) {\n                        ll f = dfs_lam(tmp.dst, min(c, tmp.cap));\n                        if (f) {\n                            tmp.cap -= f;\n                            g[tmp.dst][tmp.rev].cap += f;\n                            return f;\n                        }\n                    }\n                    return 0ll;\n                };\n                ll can_erase = dfs_lam(e.src, e_rev.cap);\n                ret += can_erase;\n                sum += can_erase;\n                e_rev.cap -= can_erase;\n\n                if (can_erase == 0) { // 閉路では消しきれない\n                    // TODO 本当はここに来た時点で、全部の辺を確認する必要はなく次に進んでいいはず。\n                    break;\n                }\n            }\n            e.cap += ret;\n        }\n        return sum;\n    }\n\n    // fromからtoへの有向辺からcapを減らして、その時の最大流量を返す\n    // capが0になっても、残余グラフそのものの辺は消さない\n    //\n    // O(V ret)\n    int erase(int from, int to, ll cap) {\n        // 削除クエリの容量が、実際に消せる容量を上回っていないかを確認\n        ll cap_sum = 0;\n        rep(i, g[from].size()) if (g[from][i].dst == to) {\n            Edge& e = g[from][i];\n            if (e.rev_flag) continue;\n            // 順向き辺を全列挙\n\n            cap_sum += e.cap + g[e.dst][e.rev].cap;\n        }\n        if (cap > cap_sum) {\n            cap = cap_sum;\n        }\n\n        // (1) 使ってない辺があったら気にせず削除\n        rep(i, g[from].size()) {\n            Edge& e = g[from][i];\n            if (e.rev_flag) continue;\n            if (e.dst != to) continue;\n            if (g[e.dst][e.rev].cap != 0) continue;\n            // フローが流れていないfromからtoへの順向きの辺を全列挙\n\n            ll to_erase = min(e.cap, cap);\n            e.cap -= to_erase;\n            cap -= to_erase;\n        }\n        if (cap == 0) { // もう消す必要がないなら終わり\n            return flow;\n        }\n\n        // (2) 使っていても、他のパスに同じフローを押し付けられるなら最大流は変わらない\n        minimizeFlowOfEdgePreservingMaxFlow(from, to); // これでfrom->toのフローがcapだけ空いた\n        // 空いたフローを消す\n        rep(i, g[from].size()) {\n            Edge& e = g[from][i];\n            if (e.rev_flag) continue;\n            if (e.dst != to) continue;\n            ll m = min(cap, e.cap);\n            cap -= m;\n            e.cap -= m;\n        }\n        if (cap == 0) { // もう消す必要がないなら終わり\n            return flow;\n        }\n \n        // (2) もう他に押し付けられないので、削除したいぶんだけフローを押し戻して最大流を低下させる\n        //\n        // 残余グラフでのt->sへの増大路をcap分だけ見つけて、押し戻してflowを減少させる\n        // 減少後には、必ず削除すべき辺を含む閉路が存在するので、先ほどと同じように押し戻す\n        ll sum = 0;\n        while (1) {\n            ll f = dfs(t, s, cap);\n            if (!f) break;\n            flow -= f;\n            cap -= f;\n            sum += f;\n        }\n        assert(cap == 0);\n        minimizeFlowOfEdgePreservingMaxFlow(from, to); // これでfrom->toのフローがちょうどcapだけ空いた\n\n        // 空いたフローを消す\n        rep(i, g[from].size()) {\n            Edge& e = g[from][i];\n            if (e.rev_flag) continue;\n            if (e.dst != to) continue;\n            ll m = min(sum, e.cap);\n            sum -= m;\n            e.cap -= m;\n        }\n        return flow;\n    }\n\n    // fromからtoへの辺の全削除 \n    //\n    // O(V ret)\n    int erase(int from, int to) {\n        return erase(from, to, INF);\n    }\n};\n\n\n\n/**********************************************************/\n// 前処理なしの素数判定\n/**********************************************************/\n#define ull unsigned long long\n// dla n < 2^32: inline ull mul(ull a, ull b, ull mod) { return (a*b) % mod; }\nconst int _k = 25; const ull _mask = (1<<_k)-1;\null mul (ull a, ull b, ull mod) { // zaĹ‚: b, mod < 2^(64-_k)\n    ull result = 0;\n    while (a) {\n        ull temp = (b * (a & _mask)) % mod;\n        result = (result + temp) % mod;\n        a >>= _k;\n        b = (b << _k) % mod;\n    }\n    return result;\n}\n \null pow(ull a, ull w, ull mod) {\n    ull res = 1;\n    while (w){\n        if (w&1) res = mul(res, a, mod);\n        a = mul(a, a, mod);\n        w /= 2;\n    }\n    return res;\n}\n \nbool primetest(ull n, int a) {\n    if (a > n-1) return 1;\n    ull d = n-1;\n    int s = 0;\n    while (!(d&1)) {\n        d /= 2;\n        s++;\n    }\n    ull x = pow(a, d, n);\n    if (x == 1 || x == n-1) return 1;\n    rep(i,s-1){\n        x = mul(x, x, n);\n        if (x == 1) return 0;\n        if (x == n-1) return 1;\n    }\n    return 0;\n}\n\nbool isPrime(ull n) {\n    if (n < 4) return n > 1;\n    bool pr = n%2;\n    if (n < (1LL << 32)) {\n       for (int a : {2,7,61}) pr = pr && primetest(n,a);\n    } else if (n < (1LL << 48)) {\n       for (int a : {2,3,5,7,11,13,17}) pr = pr && primetest(n,a);\n    } else {\n       for (int a : {2,325,9375,28178,450775,9780504,1795265022}) pr = pr && primetest(n,a);\n    }\n    return pr;\n}\n\nll cost(ll x, ll y) {\n    if ((x - y) % 2 == 0) {\n        return 2;\n    } else if (isPrime(abs(x - y))) {\n        return 1;\n    } else {\n        return 3;\n    }\n}\n\nint main(void) {\n    ll n; cin >> n;\n    vll x(n); cin >> x;\n    vll a;\n    ll prev = -INF;\n    rep(i, n) {\n        if (x[i] != prev + 1) {\n            a.pb(x[i]-1);\n        }\n        if (i == n-1 || x[i] + 1 != x[i+1]) {\n            a.pb(x[i]);\n        }\n        prev = x[i];\n    }\n    sort(all(a));\n//    cout << a << endl;\n\n    n = a.size();\n    Graph g = Graph(n+2);\n    ll odd_num = 0, even_num = 0;\n    rep(i, n) {\n        if (a[i] % 2 == 0) {\n            addDirected(g, i, n+1, 0, 1);\n            even_num++;\n        } else {\n            addDirected(g, n, i, 0, 1);\n            odd_num++;\n        }\n    }\n    rep(i, n) rep(j, n) if (i != j && a[i] % 2 == 1 && a[j] % 2 == 0) if (cost(a[i], a[j]) == 1) {\n        addDirected(g, i, j, 0, 1);\n    }\n//    vizGraph(g, 2);\n\n    FordFulkerson ff(g, n, n+1);\n    ll one = ff.get();\n//    cout << one << endl;\n//    vizGraph(ff.g, 2, \"zanyo.png\");\n\n    even_num -= one;\n    odd_num -= one;\n\n    ll two = even_num / 2 + odd_num / 2;\n    ll three = even_num % 2;\n\n    cout << one + 2 * two + 3 * three << endl;\n\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio> //二分图 \n#include <cstring>\n#include <vector>\nusing namespace std;\n\nconst int MAX_V = 1e6;\n\nint V;\nvector<int> G[MAX_V];\nint match[MAX_V];\nbool used[MAX_V];\n\nvoid add_edge(int u, int v) {\n\tG[u].push_back(v);\n\tG[v].push_back(u);\n}\n\nbool dfs(int v) {\n\tused[v] = true;\n\tfor (int i = 0; i < G[i].size(); i++) {\n\t\tint u = G[u][i], w = match[u];\n\t\tif (w < 0 || !used[w] && dfs(w)) {\n\t\t\tmatch[v] = u;\n\t\t\tmatch[u] = v;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint bipartite_matching() {\n\tint res = 0;\n\tmemset(match, -1, sizeof(match));\n\tfor (int v = 0; v < V; v++) {\n\t\tif (match[v] < 0) {\n\t\t\tmemset(used, 0, sizeof(used));\n\t\t\tif (dfs(v)) {\n\t\t\t\tres++;\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nint main() {\n\t\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn=105;\nint n,a[maxn],cnt[2],match[maxn<<1];\nbool used[maxn<<1];\nvector<int> G[maxn<<1],diff;\nset<int> vis;\nbool dfs(int v) {\n    used[v]=1;\n    for (int i=0;i<(int)G[v].size();++i) {\n        int u=G[v][i],w=match[u];\n        if (w==-1||(!used[w]&&dfs(w))) {\n            match[v]=u;\n            match[u]=v;\n            return true;\n        }\n    }\n    return false;\n}\ninline int bipartite_matching() {\n    int ret=0;\n    memset(match,-1,sizeof match);\n    for (int i=0;i<(int)diff.size();++i)\n        if (match[i]==-1) {\n            memset(used,0,sizeof used);\n            ret+=dfs(i);\n        }\n    return ret;\n}\nbool check(int x) {\n    if (x<=2)\n        return false;\n    for (int i=2;i*i<=x;++i)\n        if (x%i==0)\n            return false;\n    return true;\n}\nint main()\n{\n    scanf(\"%d\",&n);\n    for (int i=1;i<=n;++i) {\n        scanf(\"%d\",&a[i]);\n        vis.insert(a[i]);\n    }\n    for (int i=1;i<=n;++i) {\n        if (vis.find(a[i]-1)==vis.end()) {\n            diff.push_back(a[i]);\n            ++cnt[a[i]%2];\n        }\n        if (vis.find(a[i]+1)==vis.end()) {\n            diff.push_back(a[i]+1);\n            ++cnt[(a[i]+1)%2];\n        }\n    }\n    for (int i=0;i<(int)diff.size();++i)\n        for (int j=i+1;j<(int)diff.size();++j)\n            if (check(abs(diff[i]-diff[j]))) {\n                G[i].push_back(j);\n                G[j].push_back(i);\n            }\n    int k=bipartite_matching();\n    printf(\"%d\\n\",k+2*((cnt[0]-k)/2+(cnt[1]-k)/2)+(cnt[0]-k)%2*3);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nbool bo[10000010];\nint f[1010][2010],n,a[1010];\n\nint calc(int x) {return (x==0)?0:((x&1)?(bo[x]?3:1):2);}\n\nint main()\n{\n\tbo[1]=1;\n\tfor (int i=2; i<=10000000; i++) if (!bo[i])\n\t\tfor (int j=(i<<1); j<=10000000; j+=i) bo[j]=1;\n\tscanf(\"%d\",&n);\n\tfor (int i=1; i<=n; i++) scanf(\"%d\",&a[i]);\n\tfor (int i=0; i<=n; i++)\n\t\tfor (int j=0; j<=2*n+1; j++) f[i][j]=1000000000;\n\tsort(a+1,a+1+n),f[1][0]=0,f[1][1]=3;\n\tfor (int i=2; i<=n; i++)\n\t{\n\t\tfor (int j=0; j<=2*i-3; j++)\n\t\t\tf[i][j]=min(f[i][j],f[i-1][j]+calc(a[i]-a[i-1]-1)),\n\t\t\tf[i][i*2-2]=min(f[i][i*2-2],f[i-1][j]+calc(a[i-1]-a[1+(j>>1)]+(1^(j&1)))),\n\t\t\tf[i][i*2-1]=min(f[i][i*2-1],f[i-1][j]+calc(a[i]-a[i-1]-1)+calc(a[i]-a[1+(j>>1)]+(1^(j&1))));\n\t\tf[i][i*2-1]=min(f[i][i*2-1],f[i][i*2-2]+3);\n\t}\n\tprintf(\"%d\\n\",f[n][n*2-1]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\ntemplate <typename _tp> inline void read(_tp&x){\n\tchar ch=getchar(),ob=0;x=0;\n\twhile(ch!='-'&&!isdigit(ch))ch=getchar();if(ch=='-')ob=1,ch=getchar();\n\twhile(isdigit(ch))x=x*10+ch-'0',ch=getchar();if(ob)x=-x;\n}\n\nconst int N = 203, M = 10001003;\nbool ispri[M], vs[N];\nint a[N], tot;\nint n, Ans;\n\nvoid input() {\n\tread(n);\n\tint x, y; read(x);\n\ta[tot = 1] = x;\n\tfor(int i=2;i<=n;++i) {\n\t\tread(y);\n\t\tif(x+1 != y) a[++tot] = x+1, a[++tot] = y;\n\t\tx = y;\n\t}\n\ta[++tot] = ++y;\n\t\n\tfor(int i=2;i<=y;++i) ispri[i] = true;\n\tfor(int i=2;i<=y;++i) if(ispri[i])\n\t\tfor(int j=i+i;j<=y;j+=i) ispri[j] = false;\n\tispri[2] = false;\n}\n\nnamespace Part1 {\n\tstruct Edge {int v, w, nxt;} e[N*N];\n\tint head[N], cur[N];\n\tint q[N], he, ta, dis[N];\n\tint s, t, _;\n\t\n\tinline void add(int x, int y) {\n\t\te[++_].v = y, e[_].w = 1, e[_].nxt = head[x], head[x] = _;\n\t\te[++_].v = x, e[_].w = 0, e[_].nxt = head[y], head[y] = _;\n\t}\n\t\n\tvoid init() {\n\t\ts = tot + 1, t = s + 1, _ = 1;\n\t\tfor(int i=1;i<=t;++i) head[i] = 0;\n\t}\n\t\n\tbool bfs() {\n\t\tfor(int i=1;i<=t;++i) dis[i] = -1;\n\t\tdis[q[he = ta = 1] = s] = 0;\n\t\twhile(he <= ta) {\n\t\t\tint x = q[he++];\n\t\t\tfor(int i=head[x];i;i=e[i].nxt)\n\t\t\t\tif(e[i].w and -1 == dis[e[i].v]) {\n\t\t\t\t\tdis[q[++ta] = e[i].v] = dis[x] + 1;\n\t\t\t\t\tif(e[i].v == t) return true;\n\t\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\t\n\tint dfs(int x, int flw) {\n\t\tif(x == t or !flw) return flw;\n\t\tint res = 0, tmp;\n\t\tfor(int&i=cur[x];i;i=e[i].nxt)\n\t\t\tif(e[i].w and dis[e[i].v] == dis[x] + 1)\n\t\t\tif(tmp = dfs(e[i].v, e[i].w)) {\n\t\t\t\te[i].w -= tmp, e[i^1].w += tmp, res += tmp;\n\t\t\t\tif(res == flw) return res;\n\t\t\t}\n\t\tif(!res) dis[x] = -1;\n\t\treturn res;\n\t}\n\t\n\tint Dinic() {\n\t\tconst int oo = 1e9;\n\t\tint res = 0;\n\t\twhile(bfs()) {\n\t\t\tfor(int i=1;i<=t;++i) cur[i] = head[i];\n\t\t\tres += dfs(s, +oo);\n\t\t}\n\t\treturn res;\n\t}\n\n\tvoid work() {\n\t\tinit();\n\t\tfor(int i=1;i<=tot;++i)\n\t\t\tif(a[i]&1) add(s, i);\n\t\n\t\tfor(int i=1;i<=tot;++i) if(a[i]&1)\n\t\tfor(int j=1;j<=tot;++j) if(~a[j]&1)\n\t\t\tif(ispri[abs(a[i] - a[j])]) add(i, j);\n\t\t\n\t\tfor(int i=1;i<=tot;++i)\n\t\t\tif(~a[i]&1) add(i, t);\n\t\n\t\tAns += Dinic();\n\t\tfor(int i=head[s];i;i=e[i].nxt)\n\t\t\tif(!e[i].w) vs[e[i].v] = true;\n\t\tfor(int i=head[t];i;i=e[i].nxt)\n\t\t\tif(e[i].w) vs[e[i].v] = true;\n\t}\n}\n\nvoid Part23() {\n\tint ct[2] = {0, 0};\n\tfor(int i=1;i<=tot;++i)\n\t\tif(!vs[i]) ++ct[a[i]&1];\n\tAns += ct[0] ^ (ct[0] & 1);\n\tAns += ct[1] ^ (ct[1] & 1);\n\tAns += (ct[0] & ct[1] & 1) * 3;\n}\n\nint main() {\n\tinput();\n\t\n\tPart1::work();\n\tPart23();\n\t\n\tprintf(\"%d\\n\", Ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <map>\n#include <string>\n#include <cstring>\n#include <stack>\n#include <queue>\n#include <cmath>\n#include <ctime>\n#include <utility>\nusing namespace std;\n#define REP(I,N) for (I=0;I<N;I++)\n#define rREP(I,N) for (I=N-1;I>=0;I--)\n#define rep(I,S,N) for (I=S;I<N;I++)\n#define rrep(I,S,N) for (I=N-1;I>=S;I--)\n#define FOR(I,S,N) for (I=S;I<=N;I++)\n#define rFOR(I,S,N) for (I=N;I>=S;I--)\ntypedef unsigned long long ull;\ntypedef long long ll;\n//const int INF=0x3f3f3f3f;\nconst int INF=1e9;\nconst ll INFF=0x3f3f3f3f3f3f3f3fll;\nconst ll M=1e9+7;\nconst ll maxn=1e5+7;\nconst int MAXN=1005;\nconst int MAX=2e5+5;\nconst int MAX_N=MAX;\nconst ll MOD=1e9+7;\n//const double eps=0.00000001;\n//ll gcd(ll a,ll b){return b?gcd(b,a%b):a;}\ntemplate<typename T>inline T abs(T a) {return a>0?a:-a;}\ninline ll powMM(ll a,ll b){\n    ll ret=1;\n    a%=M;\n//    b%=M;\n    while (b){\n        if (b&1) ret=ret*a%M;\n        b>>=1;\n        a=a*a%M;\n    }\n    return ret;\n}\nvoid open()\n{\n    freopen(\"1007.in\",\"r\",stdin);\n    freopen(\"out.txt\",\"w\",stdout);\n}\n\nint V;//顶点数\nconst int MAX_V=MAX;\nvector<int> G[MAX_V];//图的邻接表表示\nint match[MAX_V];//所匹配的顶点\nbool used[MAX_V];//DFS中用到的访问标记\n//向图中增加一条连接u和v的边\nvoid add_edge(int u,int v)\n{\n    G[u].push_back(v);\n//    G[v].push_back(u);\n}\n//通过DFS寻找增广路\nbool dfs(int v)\n{\n    used[v]=true;\n    for(int i=0;i<G[v].size();i++)\n    {\n        int u=G[v][i],w=match[u];\n        if(w<0||(!used[w]&&dfs(w)))\n        {\n            match[v]=u;\n            match[u]=v;\n            return true;\n        }\n    }\n    return false;\n}\n//求解二分图的最大匹配\nint bipartite_matching()\n{\n    int res=0;\n    memset(match,-1,sizeof(match));\n    for(int v=0;v<V;v++)\n    {\n        if(match[v]<0)\n        {\n            memset(used,0,sizeof(used));\n            if(dfs(v))\n                ++res;\n        }\n    }\n    return res;//返回的是总点数的一半\n}\nbool isprime(int x)\n{\n    if(x==1)\n        return false;\n    for(int i=2;i*i<=x;i++)\n    {\n        if(x%i==0)\n            return false;\n    }\n    return true;\n}\nint n;\nint a[(int)1e7+2];\nvector<int>pos[2];\nint main()\n{\n    scanf(\"%d\",&n);\n    int tem;\n    for(int i=1;i<=n;i++)\n    {\n        scanf(\"%d\",&tem);\n        a[tem]=1;\n    }\n    for(int i=tem+1;i>=1;i--)\n    {\n        a[i]=a[i]^a[i-1];\n        if(a[i])\n            pos[i%2].push_back(i);\n    }\n    for(int i=0;i<pos[0].size();i++)\n        for(int j=0;j<pos[1].size();j++)\n            if(isprime(abs(pos[0][i]-pos[1][j])))\n//                add_edge(i,j+pos[0].size());\n                add_edge(i,j);\n//    V=pos[0].size()+pos[1].size();\n    V=pos[0].size();\n//    printf(\"V=%d\\n\",V);\n    int cnt=bipartite_matching();\n//    printf(\"cnt=%d\\n\");\n    cnt+=((pos[0].size()-cnt)/2+(pos[1].size()-cnt)/2)*2;\n//    printf(\"cnt=%d\\n\");\n    cnt+=(pos[0].size()%2)*3;\n    printf(\"%d\\n\",cnt);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <string.h>\nusing namespace std;\n\n#define abs(x) ((x) > 0 ? (x) : -(x))\nbool prime[11000000];\nbool b[11000000];\nint n;\nbool used[210], go[210][210];\nint ans;\nint ind[210];\nint cnt0, cnt1;\nint m;\nint Link[210];\n\nbool fi(int x) {\n\tfor (int i = 1; i <= m; i++)\n\t\tif (go[x][i] && !used[i]) {\n\t\t\tused[i] = true;\n\t\t\tif (!Link[i] || fi(Link[i])) {\n\t\t\t\tLink[i] = x;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\treturn false;\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 2; i <= 10000000; i++)\n\t\tprime[i] = true;\n\tfor (int i = 1; i * i <= 10000000; i++)\n\t\tif (prime[i])\n\t\t\tfor (int j = i * i; j <= 10000000; j += i)\n\t\t\t\tprime[j] = false;\n\tprime[2] = false;\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tint t;\n\t\tscanf(\"%d\", &t);\n\t\tb[t] ^= 1;\n\t\tb[t + 1] ^= 1;\n\t}\n\tfor (int i = 1; i <= 10000001; i++)\n\t\tif (b[i]) {\n\t\t\tm += 1;\n\t\t\tind[m] = i;\n\t\t}\n\tfor (int i = 1; i <= m; i++)\n\t\tif (ind[i] % 2 == 0) {\n\t\t\tcnt0 += 1;\n\t\t\tfor (int j = 1; j <= m; j++)\n\t\t\t\tif (ind[j] % 2 == 1 && prime[abs(ind[i] - ind[j])])\n\t\t\t\t\tgo[i][j] = true;\n\t\t}\n\tint ans = 0;\n\tfor (int i = 1; i <= m; i++)\n\t\tif (ind[i] % 2 == 0) {\n\t\t\tmemset(used, false, sizeof used);\n\t\t\tif (fi(i))\n\t\t\t\tans += 1;\n\t\t}\n\tint aa = ans;\n\tcnt1 = m - cnt0;\n\t// printf(\"?? %d %d\\n\", cnt0, cnt1);\n\tcnt0 -= ans;\n\tcnt1 -= ans;\n\tif (cnt0 % 2 == 0)\n\t\taa += cnt0 + cnt1;\n\telse\n\t\taa += 3 + (cnt0 - 1) + cnt1 - 1;\n\tprintf(\"%d\\n\", aa);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define ld long double\n#define ull unsigned long long\n#define poly vector<ll>\n#define pb push_back\n#define pii pair<int,int>\n#define fi first\n#define se second\n#define mp make_pair\n#define For(i,l,r) for(int i=(int)(l);i<=(int)(r);i++)\n#define Rep(i,r,l) for(int i=(int)(r);i>=(int)(l);i--)\ninline ll read(){\n\tll x=0;char ch=getchar();bool d=1;\n\tfor(;!isdigit(ch);ch=getchar()) if(ch=='-') d=0;\n\tfor(;isdigit(ch);ch=getchar()) x=x*10+ch-'0';\n\treturn d?x:-x;\n}\ninline void write(ll x){\n\tif(x<0) x=-x,putchar('-');\n\tif(x>=10) write(x/10);\n\tputchar('0'+x%10);\n}\ninline void writeln(ll x){write(x);puts(\"\");}\ninline void writep(ll x){write(x);putchar(' ');}\ninline ull rnd(){\n\treturn ((ull)rand()<<30^rand())<<4|rand()%4;\n}\nconst int N=205;\nint head[N],opt;\nstruct info{\n\tint to,nxt;\n}e[N*N*2];\nvoid add(int x,int y){\n\te[++opt]=(info){y,head[x]};head[x]=opt;\n\te[++opt]=(info){x,head[y]};head[y]=opt;\n}\nbool check(int x){\n\tif(x<=2) return 0;\n\tfor(int i=2;i*i<=x;i++){\n\t\tif(x%i) return 0;\n\t}\n\treturn 1;\n}\nint ma[N];\nbool used[N];\nbool dfs(int u){\n\tfor(int i=head[u];i;i=e[i].nxt){\n\t\tint k=e[i].to;\n\t\tif(used[k]) continue;\n\t\tif(!ma[k]||dfs(ma[k])) return ma[k]=u,1;\n\t}\n\treturn 0;\n}\nint a[N],pos[N];\nint main(){\n\tint n=read(),m=0,cnt=0;\n\tFor(i,1,n){\n\t\ta[i]=read();\n\t\tif(i==1||a[i-1]<a[i]-1) pos[++m]=a[i];\n\t\tif(i>1&&a[i-1]+1<a[i]) pos[++m]=a[i-1]+1;\n\t}\n\tpos[++m]=a[n]+1;\n\tFor(i,1,m) if(pos[i]&1) cnt++;\n\tFor(i,1,m) if(pos[i]&1){\n\t\tFor(j,i+1,m) if(!(pos[j]&1)){\n\t\t\tif(check(pos[j]-pos[i])) add(i,j);\n\t\t}\n\t}\n\tint ssw=0;\n\tFor(i,1,m) if(pos[i]&1){\n\t\tmemset(used,0,sizeof(used));\n\t\tssw+=dfs(i);\n\t}\n\tcout<<ssw+(m-ssw*2)+(cnt-ssw)%2;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i, n) for(int i = 1; i <= n; i++)\n#define REP(i, n) for(int i = 0; i < n; i++)\n#define MP make_pair\n#define FI first\n#define SE second\n#define VI vector<int>\n#define CLR(x) memset(x, 0, sizeof(x))\n#define SZ(x) (x.size())\n#ifdef QWERTIER\n#define err(x) cerr<<x<<endl;\n#else\n#define err(x)\n#endif\ntypedef long long LL;\n\n\n#define M 10000010\nint primes[M], prime_cnt, not_prime[M];\nvoid get_primes() {\n  not_prime[1] = 1;\n  for (int i = 2; i <= M-10; i++) {\n    if (!not_prime[i]) {\n      primes[prime_cnt++] = i;\n    }\n    for (int j = 0; j < prime_cnt && i * primes[j] <= M-10; j++) {\n      not_prime[i*primes[j]] = 1;\n      if (i%primes[j] == 0)\n        break;\n    }\n  }\n}\n\n#define N 110\n\nint vis[N], g[N][N], cand[N], L, R;\nbool dfs(int u) {\n  if (vis[u])\n    return false;\n  vis[u] = 1;\n  FOR (v, R) {\n    if (g[u][v] && (!cand[v] || dfs(cand[v]))) {\n      cand[v] = u;\n      return true;\n    }\n  }\n  return false;\n}\n\nint n, a[N], b[N];\nint main() {\n#ifdef QWERTIER\n  freopen(\"in.txt\", \"r\", stdin);\n#endif\n  get_primes();\n  scanf(\"%d\", &n);\n  set<int> st;\n  FOR (i, n) {\n    scanf(\"%d\", &a[i]);\n    st.insert(a[i]);\n  }\n  vector<int> b;\n  for (auto i : st) {\n    if (st.count(i-1) == 0) {\n      b.push_back(i);\n    }\n    if (st.count(i+1) == 0) {\n      b.push_back(i+1);\n    }\n  }\n  n = b.size();\n  REP (i, n) {\n    if (b[i]%2 == 1) {\n      L++;\n      R = 0;\n      REP (j, n) {\n        if (b[j] % 2 == 0) {\n          R++;\n          if (!not_prime[abs(b[i]-b[j])]) {\n            g[L][R] = 1;\n          }\n        }\n      }\n    }\n  }\n  R = 0;\n  REP (i, n)\n    R += (b[i] % 2 == 0);\n  int k = 0;\n  FOR (i, L) {\n    memset(vis, 0, sizeof(vis));\n    if (dfs(i))\n      k++;\n  }\n\n  printf(\"%d\\n\", k + ((L-k)/2+(R-k)/2)*2 + ((L-k)%2)*3);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int max_n = 1e2 + 5, max_x = 1e7 + 5;\n\nbool sito[max_x];\n\nint dodaj(int x){\n    if (x % 2){\n        if (!sito[x])\n            return 1;\n        else\n            return 3;\n    }\n    return 2;\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    sito[1] = true;\n    for (int i = 2; i * i <= 1e7; i++)\n        if (!sito[i])\n            for (int j = i * i; j <= 1e7; j += i)\n                sito[j] = true;\n    int n, poprzedni_1 = 0, aktu_1 = 0, ile = 0, wynik = 0, poprzedni_2 = 0, aktu_2 = 0, koniec = 0, pom_1, pom_2 = 0;\n    cin >> n;\n    for (int i = 0; i < n; i++){\n        cin >> pom_1;\n        if (i && pom_1 != pom_2 + 1){\n            wynik += dodaj(ile);\n            if (koniec){\n                aktu_1 = poprzedni_2 + dodaj(pom_2 - ile - koniec);\n                aktu_2 = max(poprzedni_1, poprzedni_2);\n                poprzedni_1 = aktu_1;\n                aktu_2 = poprzedni_2;\n            }\n            koniec = pom_2;\n            ile = 0;\n        }\n        pom_2 = pom_1;\n        ile++;\n    }\n    wynik += dodaj(ile);\n    if (koniec){\n        aktu_1 = poprzedni_2 + dodaj(pom_2 - ile - koniec);\n        aktu_2 = max(poprzedni_1, poprzedni_2);\n        poprzedni_1 = aktu_1;\n        aktu_2 = poprzedni_2;\n    }\n    cout << wynik - max(aktu_1, aktu_2) << \"\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//#define _GLIBCXX_DEBUG\n\n#include<bits/stdc++.h>\nusing namespace std;\n\n#define endl '\\n'\n#define lfs cout<<fixed<<setprecision(10)\n#define ALL(a)  (a).begin(),(a).end()\n#define ALLR(a)  (a).rbegin(),(a).rend()\n#define spa << \" \" <<\n#define fi first\n#define se second\n#define MP make_pair\n#define MT make_tuple\n#define PB push_back\n#define EB emplace_back\n#define rep(i,n,m) for(ll i = (n); i < (ll)(m); i++)\n#define rrep(i,n,m) for(ll i = (ll)(m) - 1; i >= (ll)(n); i--)\nusing ll = long long;\nusing ld = long double;\nconst ll MOD1 = 1e9+7;\nconst ll MOD9 = 998244353;\nconst ll INF = 1e18;\nusing P = pair<ll, ll>;\ntemplate<typename T1, typename T2>bool chmin(T1 &a,T2 b){if(a>b){a=b;return true;}else return false;}\ntemplate<typename T1, typename T2>bool chmax(T1 &a,T2 b){if(a<b){a=b;return true;}else return false;}\nll median(ll a,ll b, ll c){return a+b+c-max({a,b,c})-min({a,b,c});}\nvoid ans1(bool x){if(x) cout<<\"Yes\"<<endl;else cout<<\"No\"<<endl;}\nvoid ans2(bool x){if(x) cout<<\"YES\"<<endl;else cout<<\"NO\"<<endl;}\nvoid ans3(bool x){if(x) cout<<\"Yay!\"<<endl;else cout<<\":(\"<<endl;}\ntemplate<typename T1,typename T2>void ans(bool x,T1 y,T2 z){if(x)cout<<y<<endl;else cout<<z<<endl;}  \ntemplate<typename T>void debug(vector<vector<T>>&v,ll h,ll w){for(ll i=0;i<h;i++){cout<<v[i][0];for(ll j=1;j<w;j++)cout spa v[i][j];cout<<endl;}};\nvoid debug(vector<string>&v,ll h,ll w){for(ll i=0;i<h;i++){for(ll j=0;j<w;j++)cout<<v[i][j];cout<<endl;}};\ntemplate<typename T>void debug(vector<T>&v,ll n){if(n!=0)cout<<v[0];for(ll i=1;i<n;i++)cout spa v[i];cout<<endl;};\ntemplate<typename T>vector<vector<T>>vec(ll x, ll y, T w){vector<vector<T>>v(x,vector<T>(y,w));return v;}\nll gcd(ll x,ll y){ll r;while(y!=0&&(r=x%y)!=0){x=y;y=r;}return y==0?x:y;}\nvector<ll>dx={1,-1,0,0,1,1,-1,-1};vector<ll>dy={0,0,1,-1,1,-1,1,-1};\ntemplate<typename T>vector<T> make_v(size_t a,T b){return vector<T>(a,b);}\ntemplate<typename... Ts>auto make_v(size_t a,Ts... ts){return vector<decltype(make_v(ts...))>(a,make_v(ts...));}\ntemplate<typename T1, typename T2>ostream &operator<<(ostream &os, const pair<T1, T2>&p){return os << p.first << \" \" << p.second;}\ntemplate<typename T>ostream &operator<<(ostream &os, const vector<T> &v){for(auto &z:v)os << z << \" \";cout<<\"|\"; return os;}\n//mt19937 mt(chrono::steady_clock::now().time_since_epoch().count());\nvector< bool > prime_table(ll n) {\n  vector< bool > prime(n + 1, true);\n  if(n >= 0) prime[0] = false;\n  if(n >= 1) prime[1] = false;\n  for(ll i = 2; i * i <= n; i++) {\n    if(!prime[i]) continue;\n    for(ll j = i + i; j <= n; j += i) {\n      prime[j] = false;\n    }\n  }\n  return prime;\n}\ntemplate< typename flow_t, typename cost_t >\nstruct PrimalDual {\n  const cost_t INF;\n\n  struct edge {\n    ll to;\n    flow_t cap;\n    cost_t cost;\n    ll rev;\n    bool isrev;\n  };\n  vector< vector< edge > > graph;\n  vector< cost_t > potential, min_cost;\n  vector< ll > prevv, preve;\n\n  PrimalDual(ll V) : graph(V), INF(numeric_limits< cost_t >::max()) {}\n\n  void add_edge(ll from, ll to, flow_t cap, cost_t cost) {\n    graph[from].emplace_back((edge) {to, cap, cost, (ll) graph[to].size(), false});\n    graph[to].emplace_back((edge) {from, 0, -cost, (ll) graph[from].size() - 1, true});\n  }\n\n  cost_t min_cost_flow(ll s, ll t, flow_t f) {\n    ll V = (ll) graph.size();\n    cost_t ret = 0;\n    using Pi = pair< cost_t, ll >;\n    priority_queue< Pi, vector< Pi >, greater< Pi > > que;\n    potential.assign(V, 0);\n    preve.assign(V, -1);\n    prevv.assign(V, -1);\n\n    while(f > 0) {\n      min_cost.assign(V, INF);\n      que.emplace(0, s);\n      min_cost[s] = 0;\n      while(!que.empty()) {\n        Pi p = que.top();\n        que.pop();\n        if(min_cost[p.second] < p.first) continue;\n        for(ll i = 0; i < graph[p.second].size(); i++) {\n          edge &e = graph[p.second][i];\n          cost_t nextCost = min_cost[p.second] + e.cost + potential[p.second] - potential[e.to];\n          if(e.cap > 0 && min_cost[e.to] > nextCost) {\n            min_cost[e.to] = nextCost;\n            prevv[e.to] = p.second, preve[e.to] = i;\n            que.emplace(min_cost[e.to], e.to);\n          }\n        }\n      }\n      if(min_cost[t] == INF) return -1;\n      for(ll v = 0; v < V; v++) potential[v] += min_cost[v];\n      flow_t addflow = f;\n      for(ll v = t; v != s; v = prevv[v]) {\n        addflow = min(addflow, graph[prevv[v]][preve[v]].cap);\n      }\n      f -= addflow;\n      ret += addflow * potential[t];\n      for(ll v = t; v != s; v = prevv[v]) {\n        edge &e = graph[prevv[v]][preve[v]];\n        e.cap -= addflow;\n        graph[v][e.rev].cap += addflow;\n      }\n    }\n    return ret;\n  }\n\n  void output() {\n    for(ll i = 0; i < graph.size(); i++) {\n      for(auto &e : graph[i]) {\n        if(e.isrev) continue;\n        auto &rev_e = graph[e.to][e.rev];\n        cout << i << \"->\" << e.to << \" (flow: \" << rev_e.cap << \"/\" << rev_e.cap + e.cap << \")\" << endl;\n      }\n    }\n  }\n  using R=vector<pair<pair<ll,ll>,pair<flow_t,cost_t>>>;\n  R restore() {\n    R ret;\n    for(ll i = 0; i < graph.size(); i++) {\n      for(auto &e : graph[i]) {\n        if(e.isrev) continue;\n        auto &rev_e = graph[e.to][e.rev];\n        ret.emplace_back(make_pair(i,e.to),make_pair(rev_e.cap,e.cost));\n      }\n    }\n    return ret;\n  }\n};\nint main(){\n  cin.tie(nullptr);\n  ios_base::sync_with_stdio(false);\n  ll res=0,buf=0;\n  bool judge = true;\n  ll lim=1e7+30;\n  //ll lim=1e3;cout<<\"naosu\"<<endl;\n  auto pr=prime_table(lim);\n  /*vector<ll>p;\n  rep(i,0,lim)if(pr[i])p.PB(i);\n  ll sz=p.size();*/\n  ll n;cin>>n;\n  vector<ll>x(n);\n  rep(i,0,n)cin>>x[i];\n  vector<ll>y;\n  rep(i,0,n){\n    y.PB(x[i]);\n    y.PB(x[i]+1);\n  }\n  //cout<<lim<<endl;\n  {\n    vector<ll>tmp;\n    sort(ALL(y));\n    rep(i,0,y.size()){\n      if(i+1<y.size()&&y[i]==y[i+1])i++;\n      else tmp.PB(y[i]);\n    }\n    y=tmp;\n  }\n  pr[2]=false;\n  ll sz=y.size();\n  PrimalDual<ll,ll>fl(2*sz+2);\n  rep(i,0,sz)rep(j,0,sz){\n    if(i==j)continue;\n    ll dif=abs(y[i]-y[j]);\n    ll cost=0;\n    if(dif==0)cost=0;\n    else if(dif%2==0)cost=2;\n    else if(pr[dif])cost=1;\n    else cost=3;\n    //cout<<dif spa cost spa y[i] spa y[j]<<endl;\n    fl.add_edge(i,j+sz,1,cost);\n  }\n  ll S=2*sz,T=2*sz+1;\n  rep(i,0,sz){\n    fl.add_edge(S,i,1,0);\n    fl.add_edge(i+sz,T,1,0);\n  }\n  //cout<<sz<<endl;\n  //debug(y,sz);\n  ll lk=fl.min_cost_flow(S,T,sz);\n  assert(~lk&1);\n  cout<<lk/2<<endl;\n  map<P,ll>mp;\n  auto r=fl.restore();\n  for(auto z:r){\n    if(z.se.fi==1&&z.fi.fi<sz&&z.fi.se<2*sz){\n      //cout<<y[z.fi.fi] spa y[z.fi.se-sz]<<endl;\n      assert(y[z.fi.fi]!=y[z.fi.se-sz]);\n      //mp[minmax(y[z.fi.fi],y[z.fi.se-sz])]++;\n    }\n  }\n  //for(auto z:mp)assert(~z.se&1);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <iostream>\n#include <algorithm>\n#define fo(i,a,b) for(int i=a;i<=b;i++)\n#define fod(i,a,b) for(int i=a;i>=b;i--)\n#define N 105\nusing namespace std;\nint l[N],n,a[N],r[N],w[N],pr[1000005],f[N],a1[N][N];\nbool bz[10000005],bp[N];\nvoid prp()\n{\n\tfo(i,2,10000000)\n\t{\n\t\tif(!bz[i]) pr[++pr[0]]=i;\n\t\tfor(int j=1;j<=pr[0]&&i*pr[j]<=10000000;j++)\n\t\t{\n\t\t\tbz[i*pr[j]]=1;\n\t\t\tif(i%pr[j]==0) break;\n\t\t}\n\t}\n\tbz[2]=0;\n}\nbool find(int k)\n{\n\tfo(i,1,a1[k][0])\n\t{\n\t\tint p=a1[k][i];\n\t\tif(!bp[p])\n\t\t{\n\t\t\tbp[p]=1;\n\t\t\tif(!f[p]||find(f[p])) \n\t\t\t{\n\t\t\t\tf[p]=k;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nint main()\n{\n\tcin>>n;\n\tprp();\n\tfo(i,1,n) scanf(\"%d\",&a[i]);\n\tsort(a+1,a+n+1);\n\tfo(i,1,n) \n\t{\n\t\tif(i==1||a[i-1]!=a[i]-1) w[++w[0]]=i;\n\t\tif(a[i+1]!=a[i]+1) w[++w[0]]=i+1;\n\t}\n\tsort(w+1,w+w[0]+1);\n\tfo(i,1,w[0]) \n\t\tif(w[i]%2==0) l[++l[0]]=i;\n\t\telse r[++r[0]]=i;\n\tfo(i,1,l[0])\n\t{\n\t\tfo(j,1,r[0])\n\t\t{\n\t\t\tif(bz[abs(l[i]-r[j])]) a1[i][++a1[i][0]]=j;\n\t\t}\n\t}\n\tint s=0;\n\tfo(i,1,l[0]) \n\t{\n\t\tmemset(bp,0,sizeof(bp));\n\t\tif(find(i)) s++;\n\t}\n\tprintf(\"%d\",s+2*(l[0]-s)/2+2*(r[0]-s)/2+3*(l[0]-s)%2);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint V, E, src, snk;\nvector<int> la, nxt, oppo, capa;\nvoid init() {\n    E = 0;\n    la.clear(); nxt.clear(); oppo.clear(); capa.clear();\n    la = vector<int>(V, -1);\n}\nvoid add(int u, int v, int c) {\n    nxt.push_back(la[u]);\n    la[u] = E++;\n    oppo.push_back(v);\n    capa.push_back(c);\n}\nvector<int> dist;\nqueue<int> q;\nbool bfs() {\n    dist = vector<int>(V, -1);\n    q.push(src);\n    dist[src] = 0;\n    while(!q.empty()) {\n        int u = q.front(); q.pop();\n\n        for(int i = la[u]; i != -1; i = nxt[i]) {\n            int v = oppo[i];\n            if(capa[i] && dist[v] == -1) {\n                q.push(v);\n                dist[v] = dist[u] + 1;\n            }\n        }\n    }\n    return dist[snk] != -1;\n}\nvector<int> laa;\nint dfs(int u, int f) {\n    if(u == snk) return f;\n    for(int i = laa[u]; i != -1; i = nxt[i]) {\n        laa[u] = i;\n        int v = oppo[i];\n        if(capa[i] && dist[v] == dist[u] + 1) {\n            if(int tmp = dfs(v, min(capa[i], f))) {\n                capa[i] -= tmp;\n                capa[i^1] += tmp;\n                return tmp;\n            }\n        }\n    }\n    return 0;\n}\nint dinic() {\n    int tf = 0;\n    while(bfs()) {\n        laa = la;\n        while(int tmp = dfs(src, 1e9)) tf += tmp;\n    }\n    return tf;\n}\n\nvector<int> pchk;\nvoid getPrime() {\n    pchk = vector<int>(10000010, 0);\n    for(int i = 2; i < 10000010; i++) {\n        if(pchk[i]) continue;\n        int mul = 2;\n        while(i * mul < 10000010) {\n            pchk[i * mul] = 1;\n            mul++;\n        }\n    }\n}\n\nint N;\nvector<int> X;\nvector<int> B;\nvector<int> Me, Mo;\n\nint main() {\n    getPrime();\n\n    scanf(\"%d\", &N);\n    X.resize(N);\n    for(int i = 0; i < N; i++) {\n        scanf(\"%d\", &X[i]);\n    }\n    for(int i = 0; i < N; i++) {\n        if(i == 0 || X[i] != X[i - 1] + 1) {\n            B.push_back(X[i]);\n        }\n        if(i == N - 1 || X[i] + 1 != X[i + 1]) {\n            B.push_back(X[i] + 1);\n        }\n    }\n    for(int i = 0; i < B.size(); i++) {\n        if(B[i] % 2) Mo.push_back(B[i]);\n        else Me.push_back(B[i]);\n    }\n\n    V = Me.size() + Mo.size() + 2, src = V - 2, snk = V - 1;\n    init();\n\n    for(int i = 0; i < Me.size(); i++) {\n        add(src, i, 1);\n        add(i, src, 0);\n    }\n    for(int i = 0; i < Mo.size(); i++) {\n        add(Me.size() + i, snk, 1);\n        add(snk, Me.size() + i, 0);\n    }\n    for(int i = 0; i < Me.size(); i++) {\n        for(int j = 0; j < Mo.size(); j++) {\n            if(!pchk[ abs(Me[i] - Mo[j]) ]) {\n                add(i, Me.size() + j, 1);\n                add(Me.size() + j, i, 0);\n            }\n        }\n    }\n    int K = dinic();\n    cout<<K + (((int)Me.size() - K)/2 + ((int)Mo.size() - K)/2)*2 + (Me.size() % 2)*3;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cstring>\n#include<cstdio>\n#include<cmath>\n#include<cstdlib>\n#include<ctime>\n#include<queue>\n#include<set>\n#include<map>\n#include<stack>\n#include<bitset>\nusing namespace std;\ntypedef long long LL;\nconst int N=1e5,M=1e7+1;\nint gi() {\n\tint w=0;bool q=1;char c=getchar();\n\twhile ((c<'0'||c>'9') && c!='-') c=getchar();\n\tif (c=='-') q=0,c=getchar();\n\twhile (c>='0'&&c <= '9') w=w*10+c-'0',c=getchar();\n\treturn q? w:-w;\n}\n\nint n;\nint match[N],pre[N],q[N],vis[N],cnt;\nint x[N];vector<int>e[N];\n\ninline bool bfs(int k) {\n\tqueue<int>q;\n\t++cnt;q.push(k);\n\twhile (!q.empty()) {\n\t\tk=q.front();q.pop();\n\t\tfor (int t:e[k]) if (vis[t]!=cnt) {\n\t\t\t\tif (match[t]) {\n\t\t\t\t\tvis[t]=cnt;\n\t\t\t\t\tpre[match[t]]=k;\n\t\t\t\t\tq.push(match[t]);\n\t\t\t\t} else {\n\t\t\t\t\tint p;\n\t\t\t\t\twhile (k) {\n\t\t\t\t\t\tp=match[k];\n\t\t\t\t\t\tmatch[k]=t,match[t]=k;\n\t\t\t\t\t\tt=p,k=pre[k];\n\t\t\t\t\t}\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t}\n\treturn false;\n}\n\nint pri[M];\nbool in[M];\ninline void init(int n) {\n\tint i,j,len=0;\n\tfor (i=2;i<=n;i++) {\n\t\tif (!pri[i]) pri[++len]=i,in[i]=i!=2;\n\t\tfor (j=1;j<=len&&i*pri[j]<=n;j++) {\n\t\t\tpri[i*pri[j]]=1;\n\t\t\tif (!(i%pri[j])) break;\n\t\t}\n\t}\n}\nint main()\n{\n\tn=gi();int i,j,odd=0,s=0,m=0;\n\tfor (i=1;i<=n;i++) x[++m]=gi(),x[m+1]=x[m]+1,m++;\n\tsort(x+1,x+1+m);\n\tfor (i=1,n=0;i<=m;i++) if (x[i]==x[i+1]) i++; else x[++n]=x[i];\n\t\n\tinit(x[n]-x[1]);\n\n\tfor (i=1;i<=n;i++)\n\t\tif (x[i]&1) {\n\t\t\todd++;\n\t\t\tfor (j=1;j<=n;j++)\n\t\t\t\tif (in[abs(x[j]-x[i])])\n\t\t\t\t\te[i].push_back(j);\n\t\t}\n\tfor (i=1;i<=n;i++) if (x[i]&1) s+=bfs(i);\n\n\tcout<<n-s+((s-odd)&1);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cmath>\n#include<cstring>\n#include<string>\n#include<algorithm>\n#include<vector>\n\n#define maxn 205\n#define maxm 10000005\n\nusing namespace std;\n\ninline int getint()\n{\n\tint num=0,flag=1;char c;\n\twhile((c=getchar())<'0'||c>'9')if(c=='-')flag=-1;\n\twhile(c>='0'&&c<='9')num=num*10+c-48,c=getchar();\n\treturn num*flag;\n}\n\nint n,N;\nint a[maxn],w[maxn][maxn],link[maxn];\nint pri[maxm],cnt;\nbool np[maxm],col[maxm],vis[maxn];\nint X[maxn],Y[maxn],ans;\n\ninline void init()\n{\n\tnp[1]=1;\n\tfor(int i=2;i<=N;i++)\n\t{\n\t\tif(!np[i])pri[++cnt]=i;\n\t\tfor(int j=1;j<=cnt&&i*pri[j]<=N;j++)np[i*pri[j]]=1;\n\t}\n}\n\ninline bool match(int x)\n{\n\tfor(int i=1;i<=Y[0];i++)if(w[x][i]&&!vis[i])\n\t{\n\t\tvis[i]=1;\n\t\tif(!link[i]||match(link[i])){link[i]=x;return 1;}\n\t}\n\treturn 0;\n}\n\nint main()\n{\n\tn=getint();\n\tfor(int i=1;i<=n;i++)N=max(N,a[i]=getint()),col[a[i]]=1;\n\tN++;init();\n\tfor(int i=1;i<=N;i++)if(col[i]^col[i-1])i&1?X[++X[0]]=i:Y[++Y[0]]=i;\n\tfor(int i=1;i<=X[0];i++)for(int j=1;j<=Y[0];j++)w[i][j]=!np[abs(X[i]-Y[j])];\n\tfor(int i=1;i<=X[0];i++)\n\t{\n\t\tmemset(vis,0,sizeof vis);\n\t\tans+=match(i);\n\t}\n\tans+=2*((X[0]-ans)/2)+2*((Y[0]-ans)/2)+3*((X[0]-ans)&1);\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\nusing namespace std;\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a < b) ? (a = b, 1) : 0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b < a) ? (a = b, 1) : 0;}\n\nusing ll = long long;\nusing R = long double;\nconst R EPS = 1e-9L; // [-1000,1000]->EPS=1e-8 [-10000,10000]->EPS=1e-7\ninline int sgn(const R& r) {return (r > EPS) - (r < -EPS);}\ninline R sq(R x) {return sqrt(max(x, 0.0L));}\n\nconst int dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nconst int dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\n\n// Problem Specific Parameter:\n\nconst ll limit = 10000010;\nbool isprime[limit];\nbool x[limit];\n\nconst int inf = 1 << 20;\n\nvoid init() {\n\trep(i, limit)  isprime[i] = true;\n\tisprime[0] = isprime[1] = false;\n\n\tfor (ll i = 2; i < limit; ++i) {\n\t\tif (isprime[i]) {\n\t\t\tfor (ll j = 1LL * i * i ; j < limit; j += i) {\n\t\t\t\tisprime[j] = false;\n\t\t\t}\n\t\t}\n\t}\n}\n\n//Appropriately Changed\nusing W = ll;\nusing edge = struct {int to, rev; W cap, flow;};\nusing G = vector<vector<edge>>;\n\n//Appropriately Changed\nvoid add_edge(G &graph, int from, int to, W cap) {\n\tgraph[from].push_back({to, int(graph[to].size()) , cap , 0});\n\tgraph[to].push_back({from, int(graph[from].size()) - 1, 0 , 0});\n}\n\n// Description: グラフに対する最大流\n// TimeComplexity: $ \\mathcal{O}(EV^2) $ but fast\n// Verifyed: AOJ GRL_6_A\n\nW dinic(G &graph, int s, int t) {\n\tconst W inf = 1LL << 50;\n\tconst int n = graph.size();\n\tvector<int> level(n), iter(n);\n\n\tauto bfs = [&](int s, int t) {\n\t\tfill(begin(level), end(level), -1);\n\t\tqueue<int> q;\n\t\tlevel[s] = 0, q.push(s);\n\n\t\twhile (!q.empty()) {\n\t\t\tint v = q.front(); q.pop();\n\t\t\tfor (auto &e : graph[v]) {\n\t\t\t\tif (level[e.to] == - 1 and e.cap > e.flow) {\n\t\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\t\tq.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn (level[t] !=  -1);\n\t};\n\n\tauto dfs = [&](int v, int t, W f) {\n\t\tauto func = [&](int v, int t, W f, auto func)->W{\n\n\t\t\tif (v == t) return f;\n\t\t\tfor (int &i = iter[v]; i < graph[v].size(); i++) {\n\t\t\t\tedge &e = graph[v][i];\n\n\t\t\t\tif (e.cap > e.flow and level[v] < level[e.to]) {\n\n\t\t\t\t\tW d = func(e.to, t, min(f, e.cap - e.flow), func);\n\n\t\t\t\t\tif (d > 0) {\n\t\t\t\t\t\te.flow += d, graph[e.to][e.rev].flow -= d;\n\t\t\t\t\t\treturn d;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn 0;\n\t\t};\n\t\treturn func(v, t, f, func);\n\t};\n\n\twhile (bfs(s, t)) {\n\t\tfill(begin(iter), end(iter), 0);\n\t\twhile (dfs(s, t, inf) != 0 );\n\t}\n\n\tW ret = 0;\n\tfor (auto &e : graph[s]) ret += e.flow;\n\treturn ret;\n}\n\n\nint main(void) {\n\tinit();\n\n\tint n;\n\tcin >> n;\n\n\trep(i, n) {\n\t\tint in;\n\t\tcin >> in;\n\t\tx[in] = 1;\n\t}\n\n\trep(i, limit - 1) x[i] ^= x[i + 1];\n\n\tvector<int> number[2];\n\trep(i, limit) if (x[i]) number[i & 1].push_back(i);\n\n\tconst int s = number[0].size() + number[1].size();\n\tconst int t = s + 1;\n\tconst int all = t + 1;\n\n\tG graph(all);\n\n\trep(i, number[0].size()) add_edge(graph, s, i, 1);\n\trep(i, number[0].size()) {\n\t\trep(j, number[1].size()) {\n\t\t\tconst int diff = abs(number[1][j] - number[0][i]);\n\t\t\tif (isprime[diff]) add_edge(graph, i, number[0].size() + j, 1);\n\t\t}\n\t}\n\trep(j, number[1].size()) add_edge(graph, number[0].size() + j, t, 1);\n\n\tconst int res = dinic(graph,s,t);\n\t\n\tint ans = res;\n\tans += (number[0].size() + number[1].size() - res);\n\tif( (number[0].size() - res) % 2 == 1) ans++;\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <map>\n#include <string>\n#include <cstring>\n#include <stack>\n#include <queue>\n#include <cmath>\n#include <ctime>\n#include <utility>\nusing namespace std;\n#define REP(I,N) for (I=0;I<N;I++)\n#define rREP(I,N) for (I=N-1;I>=0;I--)\n#define rep(I,S,N) for (I=S;I<N;I++)\n#define rrep(I,S,N) for (I=N-1;I>=S;I--)\n#define FOR(I,S,N) for (I=S;I<=N;I++)\n#define rFOR(I,S,N) for (I=N;I>=S;I--)\ntypedef unsigned long long ull;\ntypedef long long ll;\n//const int INF=0x3f3f3f3f;\nconst int INF=1e9;\nconst ll INFF=0x3f3f3f3f3f3f3f3fll;\nconst ll M=1e9+7;\nconst ll maxn=1e5+7;\nconst int MAXN=1005;\nconst int MAX=2e5+5;\nconst int MAX_N=MAX;\nconst ll MOD=1e9+7;\n//const double eps=0.00000001;\n//ll gcd(ll a,ll b){return b?gcd(b,a%b):a;}\ntemplate<typename T>inline T abs(T a) {return a>0?a:-a;}\ninline ll powMM(ll a,ll b){\n    ll ret=1;\n    a%=M;\n//    b%=M;\n    while (b){\n        if (b&1) ret=ret*a%M;\n        b>>=1;\n        a=a*a%M;\n    }\n    return ret;\n}\nvoid open()\n{\n    freopen(\"1007.in\",\"r\",stdin);\n    freopen(\"out.txt\",\"w\",stdout);\n}\n/*\n    匈牙利算法 BFS版 效率更高\n\n*/\n#define prev prevv\n//顶点、边的编号均从0开始\n//邻接表储存\nstruct edge\n{\n    int from,to,weight;\n    edge(int f,int t,int w):from(f),to(t),weight(w){}\n};\nconst int __maxNodes=MAX;\nvector<int> G[__maxNodes];//存储顶点i出发的边的编号\nvector<edge> edges;\nvoid addedge(int u,int v)\n{\n    edges.push_back(edge(u,v,1));\n//    edges.push_back(edge(v,u,1));\n    G[u].push_back(edges.size()-1);\n//    G[v].push_back(edges.size()-1);\n}\ntypedef vector<int>::iterator iterator_t;\nint num_nodes;\nint num_left;\nint num_right;\nint num_edges;\nqueue<int>Q;\nint prev[__maxNodes];\nint matching[__maxNodes]; /* 存储求解结果 */\nint check[__maxNodes];\nint Hungarian()\n{\n    int ans=0;\n    num_edges=edges.size();\n    memset(matching,-1,sizeof(matching));\n    memset(check,-1,sizeof(check));\n    for(int i=0;i<num_left;i++)\n    {\n        if(matching[i]==-1)\n        {\n            while(!Q.empty())Q.pop();\n            Q.push(i);\n            prev[i]=-1;//设i为路径起点\n            bool flag=false;//尚未找到增广路\n            while(!Q.empty()&&!flag)\n            {\n                int u=Q.front();\n                for(iterator_t ix=G[u].begin();ix!=G[u].end()&&!flag;++ix)\n                {\n                    int v=edges[*ix].to;\n                    if(check[v]!=i)\n                    {\n                        check[v]=i;\n                        Q.push(matching[v]);\n                        if(matching[v]>=0)//此点为匹配点\n                        {\n                            prev[matching[v]]=u;\n                        }\n                        else//找到未匹配点，交替路变为增广路\n                        {\n                            flag=true;\n                            int d=u,e=v;\n                            while(d!=-1)\n                            {\n                                int t=matching[d];\n                                matching[t]=e;\n                                matching[e]=d;\n                                d=prev[d];\n                                e=t;\n                            }\n                        }\n                    }\n                }\n                Q.pop();\n            }\n            if(matching[i]!=-1)\n                ++ans;\n        }\n    }\n    return ans;\n}\nbool isprime(int x)\n{\n    if(x==1)\n        return false;\n    for(int i=2;i*i<=x;i++)\n    {\n        if(x%i==0)\n            return false;\n    }\n    return true;\n}\nint n;\nint a[(int)1e7+2];\nvector<int>pos[2];\nint main()\n{\n    scanf(\"%d\",&n);\n    int tem;\n    for(int i=1;i<=n;i++)\n    {\n        scanf(\"%d\",&tem);\n        a[tem]=1;\n    }\n    for(int i=tem+1;i>=1;i--)\n    {\n        a[i]=a[i]^a[i-1];\n        if(a[i])\n            pos[i%2].push_back(i);\n    }\n//    reverse(pos[0].begin(),pos[0].end());\n//    reverse(pos[1].begin(),pos[1].end());\n    num_left=pos[0].size(),num_right=pos[1].size();\n//    numedges=0;\n    //0——numleft-1 为偶数位置的点 numleft——numleft+numright-1为奇数位置的点\n    for(int i=0;i<num_left;i++)\n        for(int j=0;j<num_right;j++)\n        {\n            if(isprime(abs(pos[0][i]-pos[1][j])))\n            {\n//                    printf(\"!!\\n\");\n                    addedge(i,j+num_left);\n            }\n        }\n//    printf(\"%d\\n\",Hungarian());\n    int cnt=Hungarian();\n    cnt+=((num_left-cnt)/2+(num_right-cnt)/2)*2;\n    cnt+=(num_left%2)*3;\n    printf(\"%d\\n\",cnt);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<cstring>\nusing namespace std;\nint n;\nint res;\nvector<int>v;\nint lst=-1;\nint match[210];\nint me,mo;\nint mx;\nbool f[10000010];\nbool ok[210][210];\nbool vis[210];\nint prm[1000010];\nint sz;\nint l;\nbool bp(int x)\n{\n\tfor(int i=0;i<l;i++)\n\t{\n\t\tif(!ok[x][i])continue;\n\t\tif(vis[i])continue;\n\t\tvis[i]=vis[x]=true;\n\t\tbool f=false;\n\t\tif(match[i]=-1)f=true;\n\t\telse\n\t\t{\n\t\t\tint xx=match[i];\n\t\t\tmatch[i]=-1;\n\t\t\tmatch[xx]=-1;\n\t\t\tf=bp(xx);\n\t\t\tif(!f)match[i]=xx,match[xx]=i;\n\t\t} \n\t\tif(f)\n\t\t{\n\t\t\tmatch[i]=x;\n\t\t\tmatch[x]=i;\n\t\t\treturn true;\n\t\t}\n\t\tvis[i]=vis[x]=false;\n\t}\n\treturn false;\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint x;\n\t\tscanf(\"%d\",&x);\n\t\tif(x!=lst+1)\n\t\t{\n\t\t\tif(lst+1)v.push_back(lst+1);\n\t\t\tv.push_back(x);\n\t\t}\n\t\tlst=x;\n\t\tmx=lst+1;\n\t}\n\tv.push_back(lst+1);\n\tf[1]=true;\n\tfor(int i=2;i<=mx;i++)\n\t{\n\t\tif(!f[i])prm[++sz]=i;\n\t\tfor(int j=1;j<=sz;j++)\n\t\t{\n\t\t\tif(prm[j]*i>mx)break;\n\t\t\tf[prm[j]*i]=true;\n\t\t\tif(i%prm[j]==0)break;\n\t\t}\n\t}\n\tl=v.size();\n\tfor(int i=0;i<l;i++)\n\t{\n\t\tmatch[i]=-1;\n\t\tif(v[i]&1)mo++;else me++;\n\t\tfor(int j=i+1;j<l;j++)\n\t\t{\n\t\t\tif(v[j]-v[i]!=2 && !f[v[j]-v[i]])\n\t\t\t{\n\t\t\t\tok[i][j]=ok[j][i]=true;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<l;i++)\n\t{\n\t\tmemset(vis,false,sizeof(vis));\n\t\tif(bp(i))res++;\n\t}\n\tres/=2;\n\tprintf(\"%d\",res+((me-res)/2+(mo-res)/2)*2+((me-res)%2)*3);\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <iomanip>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <unordered_set>\n#include <unordered_map>\n#include <bitset>\n#include <limits>\n#include <random>\n#include <complex>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cassert>\nusing namespace std;\n\n#define REP(i,n) for (int i = 0; i < n; i++)\ntemplate <class T> using reversed_priority_queue = priority_queue<T, vector<T>, greater<T> >;\ntypedef long long ll;\n\ntemplate <class T> struct FordFulkerson {\n\n    vector < pair < int,int > > maching;\n\n    struct  Edge {\n        int to,rev; T cap;\n        Edge(int t, int r, T c) : to(t), rev(r), cap(c) {}\n    };\n    \n    const T INF = numeric_limits<T>::max() / 2;\n    vector< vector< Edge > > G;\n    vector< bool > used;\n    FordFulkerson (int n) : G(n+1), used(n+1) {}\n   \n    void add_edge(int from, int to, T cap) {\n        G[from].push_back(Edge(to,(int)G[to].size(),cap));\n        G[to].push_back(Edge(from,(int)G[from].size()-1,0));\n    }\n    \n    T dfs(int v, int t, T f) {\n        if (v == t) return f;\n        used[v] = true;\n        for (int i = 0; i < G[v].size(); i++) {\n            Edge &e = G[v][i];\n            if (!used[e.to] && e.cap > 0) {\n                T d = dfs(e.to, t, min(f,e.cap));\n                if (d > 0) {\n                    if (v != 990 && e.to != 991) {\n                        maching.push_back(make_pair(v, e.to - 500));\n                    }\n                    e.cap -= d;\n                    G[e.to][e.rev].cap += d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n   \n    T get_max (int source, int sink) {\n        T flow = 0;\n        while (true) {\n            for (int i = 0; i < used.size(); i++) used[i] = false;\n            T f = dfs(source, sink, INF);\n            if (f == 0) return flow;\n            flow += f;\n        }\n    }\n    \n};\n\n\nbool isPrime(long long n) {\n    if (n <= 2) return false;\n    for (long long i = 2; i * i <= n; i++) if (n % i == 0) return false;\n    return true;\n}\n\nbool flip[10000010];\n\nint main ()\n{\n    int N;\n    cin >> N;\n    vector < int > x(N);\n    REP(i,N) cin >> x[i];\n\n    REP(i,N) {\n        flip[x[i]] = !flip[x[i]];\n        flip[x[i] + 1] = !flip[x[i] + 1];\n    }\n\n    vector < int > xt;\n    for (int i = 0; i < 10000010; i++) {\n        if (flip[i]) xt.push_back(i);\n    }\n\n    FordFulkerson < int > inst(1000);\n    for (int i = 0; i < xt.size(); i++) {\n        for (int j = i; j < xt.size(); j++) {\n            if (i == j) continue;\n            int diff = abs(xt[i] - xt[j]);\n            if (isPrime(diff)) {\n                inst.add_edge(i, j + 500, 1);\n            }\n        }\n    }\n    REP(i,N) {\n        inst.add_edge(990, i, 1);\n        inst.add_edge(i + 500, 991, 1);\n    }\n\n    int maxt = inst.get_max (990, 991);\n    maxt /= 2;\n    vector < pair < int,int > > mc = inst.maching;\n\n    int odd = 0;\n    int even = 0;\n    REP(i,xt.size()) {\n        if (xt[i] % 2) {\n            even++;\n        } else {\n            odd++;\n        }\n    }\n\n    odd -= maxt;\n    even -= maxt;\n\n    int two = odd / 2 + even / 2;\n    int three = even % 2;\n    \n    cout << maxt + two * 2 + three * 3 << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <set>\n#include <map>\n#include <list>\n#include <time.h>\n#include <math.h>\n#include <random>\n#include <deque>\n#include <queue>\n#include <cassert>\n#include <unordered_map>\n#include <iomanip>\n\nusing namespace std;\n\ntypedef long long ll;\n\nmt19937 rnd(228);\n\nconst int M = 2e7 + 7;\nconst int N = 1e2 + 1;\n\nbool prime[M];\n\nll dp[N][N][2];\n\nint get(int x)\n{\n    if (x == 0)\n    {\n        return 0;\n    }\n    if (x > 2 && prime[x])\n    {\n        return 1;\n    }\n    else\n    {\n        return 2 + (x % 2);\n    }\n}\n\nint main()\n{\n#ifdef ONPC\n    freopen(\"a.in\", \"r\", stdin);\n#endif\n    for (int i = 0; i < M; i++)\n    {\n        prime[i] = 1;\n    }\n    prime[1] = 0;\n    for (int i = 2; i < M; i++)\n    {\n        if (prime[i])\n        {\n            for (int j = i + i; j < M; j += i)\n            {\n                prime[j] = 0;\n            }\n        }\n    }\n    int n;\n    scanf(\"%d\", &n);\n    vector <int> x(n);\n    for (int i = 0; i < n; i++)\n    {\n        for (int j = 0; j < n; j++)\n        {\n            dp[i][j][0] = 1e18;\n            dp[i][j][1] = 1e18;\n        }\n    }\n    for (int i = 0; i < n; i++)\n    {\n        scanf(\"%d\", &x[i]);\n        dp[i][i][0] = 0;\n    }\n    for (int len = 1; len <= n; len++)\n    {\n        for (int l = 0; l + len - 1 < n; l++)\n        {\n            int r = l + len - 1;\n            for (int t = 0; t < 2; t++)\n            {\n                for (int j = l; j < r; j++)\n                {\n                    for (int k = j + 1; k < r; k++)\n                    {\n                        ll cost = 0;\n                        cost += dp[l][j][t];\n                        cost += dp[j + 1][k][t];\n                        cost += dp[k + 1][r][t];\n                        if (t == 0)\n                        {\n                            cost += get(x[j + 1] - x[j] + 1);\n                            cost += get(x[k + 1] - x[k] + 1);\n                        }\n                        dp[l][r][t] = min(dp[l][r][t], cost);\n                    }\n                    dp[l][r][t] = min(dp[l][r][t], dp[l][j][t] + (t == 0 ? get(x[j + 1] - x[j] - 1) : 0) + dp[j + 1][r][t]);\n                }\n            }\n            for (int t = 0; t < 2; t++)\n            {\n                dp[l][r][t] = min(dp[l][r][t], dp[l][r][t ^ 1] + get(x[r] - x[l] + 1));\n            }\n        }\n    }\n    printf(\"%lld\\n\", dp[0][n - 1][1]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <queue>\n#define MAXN 210\n#define MAXM 10000010\nusing namespace std;\n\nstruct edge{\n\tint to,next,w;\n\tedge(int _to=0,int _next=0,int _w=0):to(_to),next(_next),w(_w){}\n}e[MAXM];\n\nint n,m,S,T;\nint g[MAXN],nume;\nbool flag[MAXM];\nint prime[MAXM],nump;\nint p0[MAXN],p[MAXN],tag[MAXN];\nint level[MAXN];\n\nvoid addEdge(int u,int v,int w){\n\te[nume]=edge(v,g[u],w);\n\tg[u]=nume++;\n\te[nume]=edge(u,g[v],0);\n\tg[v]=nume++;\n}\n\nvoid init(){\n\tflag[1]=1;\n\tfor(int i=2;i<MAXN;i++){\n\t\tif(!flag[i]) prime[++nump]=i;\n\t\tfor(int j=1;j<=nump && i*prime[j]<MAXN;j++){\n\t\t\tflag[i*prime[j]]=1;\n\t\t\tif(i%prime[j]==0) break;\n\t\t}\n\t}\n\tflag[2]=1;\n}\n\nbool bfs(){\n\tmemset(level,-1,sizeof level);\n\tstatic queue<int> Q;\n\tQ.push(S);\n\tlevel[S]=0;\n\twhile(!Q.empty()){\n\t\tint x=Q.front();\n\t\tQ.pop();\n\t\tfor(int i=g[x];~i;i=e[i].next)\n\t\t\tif(e[i].w && level[e[i].to]==-1){\n\t\t\t\tlevel[e[i].to]=level[x]+1;\n\t\t\t\tQ.push(e[i].to);\n\t\t\t}\n\t}\n\treturn level[T]!=-1;\n}\n\nint dfs(int x,int delta){\n\tif(x==T) return delta;\n\tif(!delta) return 0;\n\tint res=0;\n\tfor(int i=g[x];~i;i=e[i].next)\n\t\tif(e[i].w && level[e[i].to]==level[x]+1){\n\t\t\tint temp=dfs(e[i].to,min(delta,e[i].w));\n\t\t\tdelta-=temp;\n\t\t\tres+=temp;\n\t\t\te[i].w-=temp;\n\t\t\te[i^1].w+=temp;\n\t\t\tif(!delta) return res;\n\t\t}\n\treturn res;\n}\n\nint main(){\n#ifdef DEBUG\n\tfreopen(\"F.in\",\"r\",stdin);\n#endif\n\tmemset(g,-1,sizeof g);\n\tinit();\n\tscanf(\"%d\",&m);\n\tfor(int i=1;i<=m;i++) scanf(\"%d\",p0+i);\n\tp[++n]=p0[1]-1;\n\tfor(int i=1;i<m;i++)\n\t\tif(p0[i]+1<p0[i+1]){\n\t\t\tp[++n]=p0[i];\n\t\t\tp[++n]=p0[i+1]-1;\n\t\t}\n\tp[++n]=p0[m];\n\tint c0=0,c1=0;\n\tfor(int i=1;i<=n;i++)\n\t\tif(p[i]&1) tag[i]=1,c1++;\n\t\telse c0++;\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tif(!tag[i] && tag[j] && !flag[abs(p[i]-p[j])])\n\t\t\t\taddEdge(i,j,1);\n\tS=n+1; T=n+2;\n\tfor(int i=1;i<=n;i++)\n\t\tif(tag[i]) addEdge(i,T,1);\n\t\telse addEdge(S,i,1);\n\tint flow=0;\n\twhile(bfs()) flow+=dfs(S,0x77777777);\n\tint ans=flow+((c0-flow)/2+(c1-flow)/2)*2+((c0-flow)%2)*3;\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <assert.h>\n#include <iostream>\n#include <cstring>\n#include <vector>\n#include <cstdio>\n#include <cmath>\n\nusing namespace std;\n\nconst int MX = 205;\nconst int MP = 10000005;\n\ntemplate <typename T> void read(T &x)\n{\n\tx = 0; char c = getchar(); bool f = 0;\n\twhile(!isdigit(c) && c!='-') c = getchar();\n\tif(c == '-') f = 1, c = getchar();\n\twhile(isdigit(c)) x = x*10+c-'0', c = getchar();\n\tif(f) x = -x;\n}\n\nstruct GRAPH\n{\n\tint fst[MX], nxt[MX*MX*2], v[MX*MX*2], w[MX*MX*2], lnum;\n\t\n\tvoid init()\n\t{\n\t\tmemset(fst, 0xff, sizeof(fst));\n\t\tlnum = -1;\n\t}\n\t\n\tvoid addeg(int nu, int nv, int nw)\n\t{\n\t\tnxt[++lnum] = fst[nu];\n\t\tfst[nu] = lnum;\n\t\tv[lnum] = nv;\n\t\tw[lnum] = nw;\n\t}\n\t\n\tint vis[MX], dep[MX], que[MX], cur[MX];\n\t\n\tbool bfs(int frm, int tar)\n\t{\n\t\tint h = 1, t = 1;\n\t\tmemset(dep, 0xff, sizeof(dep));\n\t\tque[h] = frm;\n\t\tdep[frm] = 0;\n\t\twhile(h >= t)\n\t\t{\n\t\t\tint x = que[t++];\n\t\t\tfor(int i=fst[x]; ~i; i=nxt[i])\n\t\t\t\tif(dep[v[i]]==-1 && w[i])\n\t\t\t\t\tdep[v[i]] = dep[x]+1, que[++h] = v[i];\n\t\t}\n\t\treturn (dep[tar]!=-1);\n\t}\n\t\n\tint dinic(int x, int t, int mn)\n\t{\n\t\tif(x == t) return mn;\n\t\tint a, now = 0, y;\n\t\tfor(int &i=cur[x]; ~i; i=nxt[i])\n\t\t{\n\t\t\ty = v[i];\n\t\t\tif(dep[y]==dep[x]+1 && w[i])\n\t\t\t{\n\t\t\t\ta = dinic(y, t, min(mn-now, w[i]));\n\t\t\t\tnow += a;\n\t\t\t\tw[i] -= a;\n\t\t\t\tw[i^1] += a;\n\t\t\t\tif(now == mn) break;\n\t\t\t}\n\t\t}\n\t\treturn now;\n\t}\n\t\n\tint mxf(int frm, int tar)\n\t{\n\t\tint f = 0;\n\t\twhile(bfs(frm, tar))\n\t\t{\n\t\t\tmemmove(cur, fst, sizeof(cur));\n\t\t\tf += dinic(frm, tar, 1000);\n\t\t}\n\t\treturn f;\n\t}\n} G;\n\nint n, v;\nint pos[MX];\nint dif[MX];\nint odd[MX], odn, eve[MX], evn;\nbool vis[MP];\nint prm[MP], pnum;\n\nvoid init()\n{\n\tvis[1] = 1;\n\tfor(int i=2; i<MP; i++)\n\t{\n\t\tif(!vis[i]) prm[++pnum] = i;\n\t\tfor(int j=1; j<=pnum; j++)\n\t\t{\n\t\t\tif(i*prm[j] >= MP) break;\n\t\t\tvis[i*prm[j]] = 1;\n\t\t\tif(i%prm[j] == 0) break;\n\t\t}\n\t}\n}\n\nint main()\n{\n\tinit();\n\tread(n);\n\tfor(int i=1; i<=n; i++) read(pos[i]);\n\tfor(int i=1; i<=n; i++)\n\t{\n\t\tif(v && dif[v]==pos[i]) v--;\n\t\telse dif[++v] = pos[i];\n\t\tdif[++v] = pos[i]+1;\n\t}\n\tfor(int i=1; i<=v; i++)\n\t\tif(dif[i] & 1) odd[++odn] = dif[i];\n\t\telse eve[++evn] = dif[i];\n\tG.init();\n\tfor(int i=1; i<=odn; i++)\n\t\tfor(int j=1; j<=evn; j++)\n\t\t\tif(!vis[abs(odd[i]-eve[j])])\n\t\t\t{\n\t\t\t\tG.addeg(i, odn+j, 1);\n\t\t\t\tG.addeg(odn+j, i, 0);\n\t\t\t}\n\tfor(int i=1; i<=odn; i++) G.addeg(odn+evn+1, i, 1), G.addeg(i, odn+evn+1, 0);\n\tfor(int i=1; i<=evn; i++) G.addeg(odn+i, odn+evn+2, 1), G.addeg(odn+evn+2, odn+i, 0);\n\tint mch = G.mxf(odn+evn+1, odn+evn+2);\n\tprintf(\"%d\\n\", (odn-mch)/2*2 + (evn-mch)/2*2 + (odn-mch)%2*3 + mch);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\nconst int N = 105;\nconst int M = 1e7 + 77;\nint n;\nint x[N];\nbool p[M];\nint nxt[M + 1];\nvoid sieve(){\n\tfor(int i = 2 ; i * i < M ; ++i){\n\t\tif(!p[i]){\n\t\t\tfor(int j = i * i ; j < M ; j += i){\n\t\t\t\tp[j] = 1;\n\t\t\t}\n\t\t}\n\t}\n\tnxt[M] = 0;\n\tfor(int i = M - 1 ; i >= 3 ; --i){\n\t\tif(p[i]){\n\t\t\tnxt[i] = nxt[i + 1];\n\t\t}\n\t\telse{\n\t\t\tnxt[i] = i;\n\t\t}\n\t}\n\tnxt[2] = 3;\n\tnxt[1] = 3;\n\tp[2] = 1;\n\tp[1] = 1;\n\tp[0] = 1;\n}\ninline int cost(int size){\n\tif(size <= 0){\n\t\treturn 0;\n\t}\n\tif(p[size] == 0){\n\t\treturn 1;\n\t}\n\tif(size & 1){\n\t\treturn 3;\n\t}\n\treturn 2;\n}\nint dp[N][1000];\nint solve(int pos , int back){\n\tif(pos > n){\n\t\treturn cost(back);\n\t}\n\tif(dp[pos][back] != -1){\n\t\treturn dp[pos][back];\n\t}\n\tint res = 1e9;\n\tif(back){\n\t\tres = min(res , solve(pos , 0) + cost(back));\n\t\tint extra = cost(x[pos] - 1 - x[pos - 1] - back);\n\t\tfor(int i = pos ; i <= n ; ++i){\n\t\t\tres = min(res , solve(i + 1 , 0) + extra + cost(x[i] - x[pos - 1]));\n\t\t\tint siz = x[i] - x[pos - 1];\n\t\t\tint p = nxt[siz];\n\t\t\tif(x[pos - 1] + 1 + p - 1 < x[i + 1]){\n\t\t\t\tres = min(res , solve(i + 1 , x[pos - 1] + 1 + p - 1 - x[i]) + extra + 1);\n\t\t\t}\n\t\t\tif(i < n){\n\t\t\t\textra += cost(x[i + 1] - x[i] - 1);\n\t\t\t}\n\t\t}\n\t}\n\telse{\n\t\tint extra = 0;\n\t\tfor(int i = pos ; i <= n ; ++i){\n\t\t\tres = min(res , solve(i + 1 , 0) + extra + cost(x[i] - x[pos] + 1));\n\t\t\tint siz = x[i] - x[pos] + 1;\n\t\t\tint p = nxt[siz];\n\t\t\tif(x[pos] + p - 1 < x[i + 1]){\n\t\t\t\tres = min(res , solve(i + 1 , x[pos] + p - 1 - x[i]) + extra + 1);\n\t\t\t}\n\t\t\tif(i < n){\n\t\t\t\textra += cost(x[i + 1] - x[i] - 1);\n\t\t\t}\n\t\t}\n\t}\n\treturn dp[pos][back] = res;\n}\nint main(){\n\tsieve();\n\tscanf(\"%d\" , &n);\n\tfor(int i = 1 ; i <= n ; ++i){\n\t\tscanf(\"%d\" , x + i);\n\t}\n\tx[n + 1] = 1e8 + 8;\n\tsort(x + 1 , x + 1 + n);\n\tmemset(dp , -1 , sizeof(dp));\n\tprintf(\"%d\\n\" , solve(1 , 0));\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 610, INF = 0x3f3f3f3f;\nint n,p[N],x[N],cnt;\nstruct edge {\n  int la,b,cap,co;\n} con[N * N * 4];\nint tot=1,fir[N];\nvoid add(int from,int to,int capc,int cos) {\n  con[++tot] = (edge) {fir[from],to,capc,cos};\n  fir[from] = tot;\n  con[++tot] = (edge) {fir[to],from,0,-cos};\n  fir[to] = tot;\n}\nint st,en,ans,cur,vis[N],dis[N],inq[N];\nint dfs(int pos,int imp) {\n  if (pos == en || (!imp)) return ans += cur * imp, imp;\n  vis[pos] = 1;\n  int expo = 0, tmp;\n  for (int i = fir[pos] ; i ; i = con[i].la) {\n    if ((!con[i].co) && (!vis[con[i].b])) {\n      tmp = dfs(con[i].b,min(imp,con[i].cap));\n      con[i].cap -= tmp;\n      con[i^1].cap += tmp;\n      expo += tmp;\n      imp -= tmp;\n      if (!imp) break;\n    }\n  }\n  return expo;\n}\nbool spfa() {\n  static queue<int> q;\n  memset(dis,0x3f,sizeof dis);\n  while (!q.empty()) q.pop();\n  q.push(st);\n  dis[st] = 0;\n  inq[st] = 1;\n  for (int pos ; !q.empty() ; q.pop()) {\n    pos = q.front();\n    inq[pos] = 0;\n    for (int i = fir[pos] ; i ; i = con[i].la) {\n      if (con[i].cap && dis[con[i].b] > dis[pos] + con[i].co) {\n\tdis[con[i].b] = dis[pos] + con[i].co;\n\tif (!inq[con[i].b]) {\n\t  q.push(con[i].b);\n\t  inq[con[i].b] = 1;\n\t}\n      }\n    }\n  }\n  if (dis[en] == INF) return 0;\n  for (int pos = 1 ; pos <= n ; ++ pos) {\n    vis[pos] = 0;\n    for (int i = fir[pos] ; i ; i = con[i].la)\n      con[i].co += dis[pos] - dis[con[i].b];\n  }\n  cur += dis[en];\n  return 1;\n}\nconst int MAX = 10000010;\nint isp[MAX + 10], pri[MAX / 10], pcnt;\nset<int> prime;\nvoid prework() {\n  for (int i = 2 ; i <= MAX ; ++ i) {\n    if (!isp[i]) pri[++pcnt] = i;\n    for (int j = 1 ; j <= pcnt && pri[j] * i <= MAX ; ++ j) {\n      isp[pri[j] * i] = 1;\n      if (i % pri[j] == 0) break;\n    }\n  }\n  for (int i = 2 ; i <= pcnt ; ++ i)\n    prime.insert(pri[i]);\n}\nint main() {\n  prework();\n  scanf(\"%d\",&n);\n  for (int i = 1 ; i <= n ; ++ i) {\n    scanf(\"%d\",&x[i]);\n    if (x[i] == 1 || x[i] != x[i-1] + 1)\n      p[++cnt] = x[i];\n    if (i > 1 && x[i] != x[i-1] + 1)\n      p[++cnt] = x[i-1] + 1;\n  }\n  p[++cnt] = x[n] + 1;\n  n = cnt << 1;\n  st = ++n;\n  en = ++n;\n  for (int i = 1 ; i <= cnt ; ++ i) {\n    add(st,i,1,0);\n    for (int j = 1 ; j <= cnt ; ++ j) if (i != j) {\n      int d = abs(p[i] - p[j]), v;\n      if (prime.count(d)) v = 1;\n      else if (d&1) v = 3;\n      else v = 2;\n      add(i,j+cnt,1,v);\n    }\n    add(i+cnt,en,1,0);\n  }\n  while (spfa())\n    dfs(st,INF);\n  printf(\"%d\\n\",ans>>1);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=5e3+11;\nconst int M=7e6+11;\nconst int MAXN=1e7+11;\nconst int inf=2147483647;\nint n,tot,cnt,t1,t2,mx,S,T,hd[M];\nint ans,pri[M],L[N<<1],R[N<<1];\nbitset<MAXN> is,a;\nstruct Edge{int nxt,to,val;}e[M];\nvoid ins(int x,int y,int z){\n    e[++cnt].nxt=hd[x];\n    e[cnt].to=y;hd[x]=cnt;\n    e[cnt].val=z;\n}\nvoid prepare(){\n    is[0]=is[1]=1;\n    for(int i=2;i<MAXN;i++){\n        if(!is[i]) pri[++tot]=i;\n        for(int j=1;j<=tot&&i*pri[j]<=MAXN;j++){\n            is[pri[j]*i]=1;\n            if(i%pri[j]==0) break;\n        }\n    }\n}\nnamespace Network_Flow{\n    queue<int> p;\n    int dep[N<<1];\n    int bfs(){\n        memset(dep,0,sizeof(dep));\n        p.push(S);dep[S]=1;\n        while(!p.empty()){\n            int x=p.front();p.pop();\n            for(int i=hd[x];i;i=e[i].nxt){\n                int y=e[i].to,v=e[i].val;\n                if(!dep[y]&&v){\n\t\t\t\t\tdep[y]=dep[x]+1;\n                    p.push(y);\n                }\n            }\n        }\n        if(dep[T]) return 1;\n        return 0;\n    }\n    int dfs(int x,int flow){\n        if(x==T||flow<=0) return flow;\n        int rest=0;\n        for(int i=hd[x];i;i=e[i].nxt){\n            int j=e[i].to;int v=e[i].val;\n            if(dep[j]==dep[x]+1&&v){\n                int now=dfs(j,min(v,flow));\n                e[i].val-=now;\n                e[i^1].val+=now;\n                flow-=now;rest+=now;\n                if(flow<=0) break;\n            }\n        }if(!rest) dep[x]=-1;\n        return rest;\n    }\n    int dinic(){\n        int maxflow=0;\n        while(bfs()) maxflow+=dfs(S,inf);\n\t\treturn maxflow;\n    }\n}\nint read(){\n    int x=0,f=1;char ch=getchar();\n    while(!isdigit(ch)){if(ch=='-')f=-f;ch=getchar();}\n    while(isdigit(ch)){x=x*10+ch-48;ch=getchar();}\n    return x*f;\n}\nsigned main(){\n    freopen(\"oatmeal.in\",\"r\",stdin);\n    freopen(\"oatmeal.out\",\"w\",stdout);\n    prepare();n=read();\n    for(int i=1;i<=n;i++){\n        int x=read();\n        a[x]=1,mx=max(mx,x);\n    }\n    for(int i=1;i<=mx+1;i++)\n        if(a[i]!=a[i-1]) i&1?L[++t1]=i:R[++t2]=i;\n    S=0,T=t1+t2+1;\n    for(int i=1;i<=t1;i++)\n        ins(S,i,1),ins(i,S,0);\n    for(int i=1;i<=t2;i++)\n        ins(i+t1,T,1),ins(T,i+t1,0);\n    for(int i=1;i<=t1;i++)\n        for(int j=1;j<=t2;j++)\n            if(!is[abs(L[i]-R[j])])\n                ins(i,j+t1,1),ins(j+t1,i,0);\n    int Val=Network_Flow::dinic();\n    ans+=Val;ans+=(t1-Val)/2*2+(t2-Val)/2*2;\n    ans+=((t1-Val)&1)*3;printf(\"%d\\n\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint n,b,ans=0;\nint a[105],f[105][105];\nint x[2][105],cnt[2],c;\nint p[10000005],prime[3000005],tot=0;\nint vis[105],link[105];\n\nint dfs(int x){\n\tfor(int i=1;i<=cnt[1];i++){\n\t\tif(vis[i]==0&&f[x][i]==1){\n\t\t\tvis[i]=1;\n\t\t\tif(link[i]==0||dfs(link[i])){\n\t\t\t\tlink[i]=x;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint main(){\n\tscanf(\"%d\",&n);\n\ta[0]=-1;\n\tfor(int i=2;i<=10000000;i++){\n\t\tif(p[i]==0) prime[++tot]=i;\n\t\tfor(int j=1;j<=tot&&i*prime[j]<=10000000;j++){\n\t\t\tp[i*prime[j]]=1;\n\t\t\tif(i%prime[j]==0) break;\n\t\t}\n\t}\n\tp[1]=p[2]=1;\n\tfor(int i=1;i<=n;i++) scanf(\"%d\",&a[i]);\n\tsort(a+1,a+n+1);\n\tfor(int i=1;i<=n;i++){\n\t\tif(a[i]==a[i-1]+1) continue;\n\t\tif(a[i-1]!=-1) x[c=(a[i-1]+1)&1][++cnt[c]]=a[i-1]+1;\n\t\tx[c=a[i]&1][++cnt[c]]=a[i];\n\t}\n\tx[c=(a[n]+1)&1][++cnt[c]]=a[n]+1;\n\tfor(int i=1;i<=cnt[0];i++){\n\t\tfor(int j=1;j<=cnt[1];j++){\n\t\t\tif(p[abs(x[0][i]-x[1][j])]==0) f[i][j]=1;\n\t\t}\n\t}\n\tfor(int i=1;i<=cnt[0];i++) if(dfs(i)) ans++;\n\tcnt[1]-=ans,cnt[0]-=ans;\n\tans+=2*(cnt[1]/2+cnt[0]/2);\n\tif(cnt[1]&1) ans+=3;\n\tprintf(\"%d\\n\",ans);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<map>\n#define N 210\n#define M 10000010\nusing namespace std;\nstruct edge{int x, y, next;}a[40010];\nint T, n, l, p[M], flag[M], w[N], x, l1, l2, a1[N], a2[N], F[N], match[N], P[N], k, ans, ss;\nmap<int, int>mp;\nmap<int, int>::iterator it;\ninline void prev(){\n\tl=0; memset(flag, 0, sizeof(flag)); flag[1]=1;\n\tfor(int i=2; i<=10000000; i++){\n\t\tif(!flag[i])p[++l]=i;\n\t\tfor(int j=1; j<=l&&i*p[j]<=10000000; j++){\n\t\t\tflag[i*p[j]]=1; if(i%p[j]==0)break;\n\t\t}\n\t}\n}\ninline int ABS(int x){return x>0?x:-x;}\ninline void add(int x, int y){a[++l].x=x; a[l].y=y; a[l].next=P[x]; P[x]=l;}\ninline int dfs(int x){\n\tfor(int i=P[x]; i; i=a[i].next)if(F[a[i].y]<ss){\n\t\tF[a[i].y]=ss; if(!match[a[i].y]||dfs(match[a[i].y])){match[a[i].y]=x; return 1;}\n\t}\n\treturn 0;\n}\nint main(){\n\tprev();\n\tT=1;\n\tfor(int owo=1; owo<=T; owo++){\n\t\tscanf(\"%d\", &n); l1=l2=0; mp.clear();\n\t\tfor(int i=1; i<=n; i++){scanf(\"%d\", &x); mp[x]^=1; mp[x+1]^=1;}\n\t\tfor(it=mp.begin(); it!=mp.end(); it++)if(it->second){\n\t\t\tx=it->first;\n\t\t\tif(x&1)a1[++l1]=x; else a2[++l2]=x;\n\t\t}\n\t\tl=0; memset(P, 0, sizeof(P));\n\t\tfor(int i=1; i<=l1; i++)\n\t\t\tfor(int j=1; j<=l2; j++)if(!flag[ABS(a1[i]-a2[j])])add(i, j);\n\t\tk=ss=0; memset(F, 0, sizeof(F)); memset(match, 0, sizeof(match));\n\t\tfor(int i=1; i<=l1; i++){ss++; k+=dfs(i);}\n\t\tans=k+((l1-k)/2+(l2-k)/2)*2+((l1-k)%2)*3;\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#pragma comment(linker, \"/stack:16777216\")\n#include <string>\n#include <vector>\n#include <map>\n#include <list>\n#include <iterator>\n#include <cassert>\n#include <set>\n#include <queue>\n#include <iostream>\n#include <sstream>\n#include <stack>\n#include <deque>\n#include <cmath>\n#include <memory.h>\n#include <cstdlib>\n#include <cstdio>\n#include <cctype>\n#include <algorithm>\n#include <utility>\n#include <time.h>\n#include <complex>\nusing namespace std;\n\n#define FOR(i, a, b) for(int i=(a);i<(b);i++)\n#define RFOR(i, b, a) for(int i=(b)-1;i>=(a);--i)\n#define FILL(A,value) memset(A,value,sizeof(A))\n\n#define ALL(V) V.begin(), V.end()\n#define SZ(V) (int)V.size()\n#define PB push_back\n#define MP make_pair\n#define Pi 3.14159265358979\n#define x0 ikjnrmthklmnt\n#define y0 lkrjhkltr\n#define y1 ewrgrg\n\ntypedef long long Int;\ntypedef unsigned long long UInt;\ntypedef vector<int> VI;\ntypedef pair<int, int> PII;\ntypedef pair<Int, Int> PLL;\ntypedef pair<double, double> PDD;\ntypedef complex<double> base;\n\nconst int INF = 1000000000;\nconst int BASE = 1000000007;\nconst int MAX = 10000007;\nconst int MAX2 = 7777;\nconst int MAXE = 100000;\nconst int ADD = 1000000;\nconst int MOD = 1000000007;\nconst int CNT = 800;\n\nint p[MAX];\n\nvector<int> g[107];\nint M[107];\nbool U[107];\n\nbool dfs(int v) {\n\tif (U[v])  return 0;\n\tU[v] = 1;\n\tFOR(i,0,SZ(g[v]))\n\t{\n\t\tint to = g[v][i];\n\t\tif (M[to] == -1 || dfs(M[to])) {\n\t\t\tM[to] = v;\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nint main()\n{\n    //freopen(\"in.txt\", \"r\", stdin);\n    //freopen(\"distance.in\",  \"r\", stdin);\n    //freopen(\"distance.out\", \"w\", stdout);\n    //freopen(\"out.txt\" , \"w\" , stdout);\n\n\tfor(int i = 2; i * i < MAX; ++i)\n\t\tif (!p[i])\n\t\t\tfor(int j = i * i; j < MAX; j += i)\n\t\t\t\tp[j] = 1;\n\n\tp[2] = 1;\n\tp[1] = 1;\n\tp[0] = 1;\n\n\tvector<int> V[2];\n\n\tint n;\n\tcin >> n;\n\tVI A(n);\n\tFOR(i,0,n)\n\t{\n\t\tcin >> A[i];\n\t}\n\n\tFOR(i,0,n)\n\t{\n\t\tif (i == 0 || A[i - 1] + 1 != A[i])\n\t\t{\n\t\t\tV[A[i] % 2].push_back(A[i]);\n\t\t}\n\t\tif (i == n - 1 || A[i] + 1 != A[i + 1])\n\t\t{\n\t\t\tV[(A[i] + 1) % 2].push_back(A[i] + 1);\n\t\t}\n\t}\n\n\tFOR(i,0,SZ(V[0]))\n\t\tFOR(j,0,SZ(V[1]))\n\t\t{\n\t\t\tif (!p[abs(V[0][i] - V[1][j])])\n\t\t\t{\n\t\t\t\tg[i].push_back(j);\n\t\t\t}\n\t\t}\n\n\tint r = 0;\n\n\tFILL(M,-1);\n\tFOR(i,0,SZ(V[0]))\n\t{\n\t\tFILL(U,0);\n\t\tr += dfs(i);\n\t}\n\n\n\n\tint res = SZ(V[0]) + SZ(V[1]) - r;\n\n\tif ((SZ(V[0]) - r) % 2 == 1) ++ res;\n\n\tcout << res << endl;\n\n    return 0;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define INF 0x7fffffff\nusing namespace std;\n\nstruct Edge{int to,capa,flow,next;} e[10500];\nint h[210],sum=-1,s,t;\nbool vis[210];\nint d[210],cur[210];\n\nvoid AddEdge(int u,int v,int w)\n{\n\te[++sum].to=v;\n\te[sum].flow=0;\n\te[sum].capa=w;\n\te[sum].next=h[u];\n\th[u]=sum;\n}\n\nvoid add_edge(int u,int v,int w)\n{\n\tAddEdge(u,v,w);\n\tAddEdge(v,u,0);\n}\n\nbool BFS()\n{\n\tmemset(vis,0,sizeof(vis));\n\tqueue<int> q;\n\tq.push(s);\n\td[s]=0;vis[s]=1;\n\twhile(!q.empty())\n\t{\n\t\tint u=q.front();\n\t\tfor(int tmp=h[u];~tmp;tmp=e[tmp].next)\n\t\t\tif(e[tmp].capa>e[tmp].flow&&!vis[e[tmp].to])\n\t\t\t{\n\t\t\t\tvis[e[tmp].to]=1;\n\t\t\t\td[e[tmp].to]=d[u]+1;\n\t\t\t\tq.push(e[tmp].to);\n\t\t\t}\n\t\tq.pop();\n\t}\n\treturn vis[t];\n}\n\nint DFS(int u,int a)\n{\n\tif(u==t||a==0) return a;\n\tint f,flow=0;\n\tfor(int& tmp=cur[u];~tmp;tmp=e[tmp].next)\n\t\tif(d[e[tmp].to]==d[u]+1)\n\t\t{\n\t\t\tf=DFS(e[tmp].to,min(a,e[tmp].capa-e[tmp].flow));\n\t\t\tif(f>0)\n\t\t\t{\n\t\t\t\tflow+=f;a-=f;\n\t\t\t\te[tmp].flow+=f;\n\t\t\t\te[tmp^1].flow-=f;\n\t\t\t\tif(a==0) break;\n\t\t\t}\n\t\t}\n\treturn flow;\n}\n\nint Maxflow()\n{\n\tint flow=0;\n\twhile(BFS())\n\t{\n\t\tfor(int i=s;i<=t;i++) cur[i]=h[i];\n\t\tflow+=DFS(s,INF);\n\t}\n\treturn flow;\n}\n\nconst int N=10000000;\nbool mark[N+10],up[N+10];\nint prime[N/10],num=0;\nint lft[110],rht[110];\n\nvoid Init()\n{\n\tmark[1]=1;\n\tfor(int i=2;i<=N;i++)\n\t{\n\t\tif(!mark[i]) prime[++num]=i;\n\t\tfor(int j=1;j<=num&&i*prime[j]<=N;j++)\n\t\t{\n\t\t\tmark[i*prime[j]]=1;\n\t\t\tif(i%prime[j]==0) break;\n\t\t}\n\t}\n\tmark[2]=1;\n}\n\nint main()\n{\n\tint n,x;Init();\n\tscanf(\"%d\",&n);\n\tmemset(h,-1,sizeof(h));\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%d\",&x);\n\t\tup[x]=1;\n\t}\n\tint l=0,r=0;\n\tfor(int i=1;i<=N+1;i++)\n\t\tif(up[i]!=up[i-1])\n\t\t{\n\t\t\tif(i&1) lft[++l]=i;\n\t\t\telse rht[++r]=i;\n\t\t}\n\ts=0;t=l+r+1;\n\tfor(int i=1;i<=l;i++) add_edge(s,i,1);\n\tfor(int i=1;i<=r;i++) add_edge(l+i,t,1);\n\tfor(int i=1;i<=l;i++)\n\t\tfor(int j=1;j<=r;j++)\n\t\t\tif(!mark[abs(lft[i]-rht[j])])\n\t\t\t\tadd_edge(i,j+l,1);\n\tint falun=Maxflow(),dafa=falun;\n\tif(l>falun) dafa+=(l-falun)/2*2;\n\tif(r>falun) dafa+=(r-falun)/2*2;\n\tif((l-falun)&1) dafa+=3;\n\tprintf(\"%d\\n\",dafa);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N=1e7+1e2;\n\ntemplate<typename T>inline void read(T &x)\n{\n\tx=0;T c=getchar(),p=1;\n\twhile(!isdigit(c)){if(c=='-')p=-1;c=getchar();}\n\twhile(isdigit(c)){x=(x<<1)+(x<<3)+(c^'0');c=getchar();}\n\tx*=p;\n}\n\nint n;\nint P[105];\n\nint cnt,ispri[N],pri[N];\n\ninline void Getprime(int Up)\n{\n\tfor(int i=2;i<=Up;i++)ispri[i]=1;\n\tfor(int i=2;i<=Up;i++){\n\t\tif(ispri[i])pri[++cnt]=i;\n\t\tfor(int j=1;j<=cnt && 1ll*i*pri[j]<=Up;j++){\n\t\t\tispri[i*pri[j]]=0;\n\t\t\tif(i%pri[j]==0)break;\n\t\t}\n\t}\n}\n\ninline void File()\n{\n\tfreopen(\"magic.in\",\"r\",stdin);\n\tfreopen(\"magic.out\",\"w\",stdout);\n}\n\nconst int M=2e6+1e2;\n\nbool G[1505][1505];\nint tot,tot1,tot2,point,A[1005],B[1005],match[1005],vis[1005];\n\ninline bool Dfs(int x)\n{\n\tfor(int i=1;i<=tot2;i++){\n\t\tif(!vis[i] && G[x][i]){\n\t\t\tvis[i]=1;\n\t\t\tif(match[i]==-1 || Dfs(match[i])){\n\t\t\t\tmatch[i]=x;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint main()\n{\n\t//File();\n\tGetprime(N-10);\n\tread(n);\n\tfor(int i=1;i<=n;i++)read(P[i]);\n\tif(P[1]&1)A[++tot1]=P[1];\n\telse B[++tot2]=P[1];\n\tfor(int i=2;i<=n;i++){\n\t\tif(P[i]!=P[i-1]+1){\n\t\t\tif((P[i-1]+1)&1)A[++tot1]=P[i-1]+1;\n\t\t\telse B[++tot2]=P[i-1]+1;\n\t\t\tif(P[i]&1)A[++tot1]=P[i];\n\t\t\telse B[++tot2]=P[i];\n\t\t}\n\t}\n\tif((P[n]+1)&1)A[++tot1]=P[n]+1;\n\telse B[++tot2]=P[n]+1;\n\tfor(int i=1;i<=tot1;i++)\n\t\tfor(int j=1;j<=tot2;j++)\n\t\t\tif(ispri[abs(A[i]-B[j])])G[i][j]=1;\n\tint Ans=0;\n\tmemset(match,-1,sizeof match);\n\tfor(int i=1;i<=tot1;i++){\n\t\tmemset(vis,0,sizeof vis);\n\t\tif(Dfs(i))Ans++;\n\t}\n\t\n\tAns=Ans+(tot1-Ans)/2*2+(tot2-Ans)/2*2;\n\tif((tot1-Ans)&1)Ans+=3;\n\tprintf(\"%d\\n\",Ans);\n\treturn 0;\n}\t\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cctype>\n#include <cmath>\n#include <algorithm>\n#define rep(i, a, b) for (int i = (a), _ = (b); i <= _; ++ i)\n#define per(i, a, b) for (int i = (a), _ = (b); i >= _; -- i)\n#define For(i, a, b) for (int i = (a), _ = (b); i < _; ++ i)\n#define ri rd<int>\nusing namespace std;\nconst int maxN = 207;\nconst int M = 10000000;\nconst int maxM = 1e7 + 7;\n\ntemplate<class T> inline T rd() {\n\tbool f = 1; char c = getchar(); for (; !isdigit(c); c = getchar()) if (c == '-') f = 0;\n\tT x = 0; for (; isdigit(c); c = getchar()) x = x * 10 + c - 48; return f ? x : -x;\n}\n\nint n;\nint a[maxN];\nint b[maxN], m;\nbool ntpri[maxM];\nint pri[maxM], cnt;\nint link[maxN], vis[maxN];\nbool adj[maxN][maxN];\n\nvoid seive() {\n\tntpri[1] = 1;\n\trep (i, 2, M) {\n\t\tif (!ntpri[i]) pri[++cnt] = i;\n\t\trep (j, 1, cnt) {\n\t\t\tif (1LL * i * pri[j] > M) break;\n\t\t\tntpri[i * pri[j]] = 1;\n\t\t\tif (i % pri[j] == 0) break;\n\t\t}\n\t}\n\tntpri[2] = ntpri[0] = 1;\n}\n\nint match(int x) {\n\tvis[x] = 1;\n\trep (y, 1, m) if (adj[x][y] && (!link[y] || (!vis[link[y]] && match(link[y])))) {\n\t\tlink[y] = x;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nint main() {\n\n\tn = ri();\n\trep (i, 1, n) a[i] = ri();\n\n\tb[++m] = a[1] - 1;\n\trep (i, 2, n) if (a[i-1] + 1 < a[i]) b[++m] = a[i-1], b[++m] = a[i] - 1;\n\tb[++m] = a[n];\n\n\tseive();\n\n\trep (i, 1, m) if (b[i] & 1) \n\t\trep (j, 1, m) if (ntpri[abs(b[i] - b[j])] == 0) adj[i][j] = 1; \n\n\tint res = 0, cc = 0;\n\tmemset(link, 0, sizeof link);\n\trep (i, 1, m) if (b[i] & 1) {\n\t\tmemset(vis, 0, sizeof vis);\n\t\tres += match(i);\n\t\t++ cc;\n\t}\n\n\tint ans = res;\n\tans += ((cc - res) >> 1) << 1;\n\tans += ((m - cc - res) >> 1) << 1;\n\tans += 3 * ((m - cc - res) & 1);\n\n\tprintf(\"%d\\n\", ans);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define sar(a,n) {cout<<#a<<\":\";rep(pachico,n)cout<<\" \"<<a[pachico];cout<<endl;}\n\nusing namespace std;\n\ntemplate<typename S,typename T>auto&operator<<(ostream&o,pair<S,T>p){return o<<\"{\"<<p.fi<<\",\"<<p.se<<\"}\";}\ntemplate<typename T>auto&operator<<(ostream&o,set<T>s){for(auto&e:s)o<<e<<\" \";return o;}\ntemplate<typename S,typename T,typename U>\nauto&operator<<(ostream&o,priority_queue<S,T,U>q){while(!q.empty())o<<q.top()<<\" \",q.pop();return o;}\ntemplate<typename K,typename T>auto&operator<<(ostream&o,map<K,T>&m){for(auto&e:m)o<<e<<\" \";return o;}\ntemplate<typename T>auto&operator<<(ostream&o,vector<T>v){for(auto&e:v)o<<e<<\" \";return o;}\nvoid ashow(){cout<<endl;}template<typename T,typename...A>void ashow(T t,A...a){cout<<t<<\" \";ashow(a...);}\ntemplate<typename S,typename T,typename U>\nstruct TRI{S fi;T se;U th;TRI(){}TRI(S f,T s,U t):fi(f),se(s),th(t){}\nbool operator<(const TRI&_)const{return(fi==_.fi)?((se==_.se)?(th<_.th):(se<_.se)):(fi<_.fi);}};\ntemplate<typename S,typename T,typename U>\nauto&operator<<(ostream&o,TRI<S,T,U>&t){return o<<\"{\"<<t.fi<<\",\"<<t.se<<\",\"<<t.th<<\"}\";}\n\ntypedef pair<int, int> P;\ntypedef pair<ll, ll> pll;\ntypedef TRI<int, int, int> tri;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vi> vvi;\ntypedef vector<vl> vvl;\ntypedef vector<P> vp;\ntypedef vector<double> vd;\ntypedef vector<string> vs;\n\nconst int MAX_N = 10000005;\n\nbool x[MAX_N];\nbool is_prime[MAX_N];\n\nvoid sieve(){\n\tfor(int i=0;i<MAX_N;i++){\n\t\tis_prime[i] = true;\n\t}\n\tis_prime[0] = is_prime[1] = false;\n\tfor(int i=2;i<MAX_N;i++){\n\t\tif(is_prime[i]){\n\t\t\tfor(int j=2*i;j<MAX_N;j+=i){\n\t\t\t\tis_prime[j] = false;\n\t\t\t}\n\t\t}\n\t}\n}\n\nclass BM {\nprivate:\n    struct edge {\n        int to,cap,rev;\n    };\n    int U,V;\n    vector<vector<edge> > G;\n    vector<int> level;\n    vector<int> iter;\n\npublic:\n    BM(int u,int v) : U(u), V(v), G(U+V+2){\n        for(int i = 0; i < U; i++){\n            init_edge(0,i+1);\n        }\n        for(int i = 0; i < V; i++){\n            init_edge(U+i+1,U+V+1);\n        }\n    }\n    void init_edge(int from,int to) {\n        G[from].push_back((edge){to,1,(int)G[to].size()});\n    \tG[to].push_back((edge){from,0,(int)G[from].size()-1});\n    }\n    void add_edge(int from,int to) {\n        from += 1,to += U+1;\n    \tG[from].push_back((edge){to,1,(int)G[to].size()});\n    \tG[to].push_back((edge){from,0,(int)G[from].size()-1});\n    }\n    void bfs(int s) {\n        fill(level.begin(),level.end(),-1);\n    \tqueue<int> que;\n    \tlevel[s] = 0;\n    \tque.push(s);\n    \twhile(!que.empty()){\n            int v = que.front();\n            que.pop();\n            for(auto& e : G[v]){\n                if(e.cap > 0 && level[e.to] < 0){\n                    level[e.to] = level[v] + 1;\n                    que.push(e.to);\n                }\n            }\n        }\n    }\n    int dfs(int v,int t,int f) {\n        if(v==t){\n            return f;\n        }\n        for(int &i = iter[v];i<(int)G[v].size();i++){\n            edge &e = G[v][i];\n            if(e.cap > 0 && level[v] < level[e.to]){\n                int d = dfs(e.to,t,min(f,e.cap));\n                if(d>0){\n                    e.cap -= d;\n                    G[e.to][e.rev].cap += d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n    int solve() {\n        level.resize(U+V+2), iter.resize(U+V+2);\n        int flow = 0;\n        int s=0,t=U+V+1;\n        for(;;){\n            bfs(s);\n            if(level[t] < 0) return flow;\n            fill(iter.begin(),iter.end(),0);\n            int f;\n            while((f=dfs(s,t,numeric_limits<int>::max())) > 0){\n                flow += f;\n            }\n        }\n    }\n    vector<int> allocate() {\n        vector<int> res(U, -1);\n        for(int i = 0; i < U; i++){\n            for(auto& e : G[i+1]){\n                if(e.cap == 0 && e.to != 0){\n                    res[i] = e.to-U-1;\n                    break;\n                }\n            }\n        }\n        return res;\n    }\n};\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n;\n    cin >> n;\n    sieve();\n    rep(i,n){\n        int u;\n        cin >> u;\n        x[u] = true;\n    }\n    vector<int> val1, val2;\n    srep(i,1,MAX_N){\n        if(x[i-1] ^ x[i]){\n            if(i % 2) val1.pb(i);\n            else val2.pb(i);\n        }\n    }\n    const int a = (int)val1.size(), b = (int)val2.size();\n    if(a == 0 || b == 0){\n        cout << (a + b) / 2 * 2 + (a % 2) << \"\\n\";\n        return 0;\n    }\n    BM bm(a, b);\n    rep(i,a){\n        rep(j,b){\n            if(is_prime[abs(val1[i] - val2[j])]){\n                bm.add_edge(i, j);\n            }\n        }\n    }\n    const int res = bm.solve();\n    cout << res + (a + b - 2 * res) / 2 * 2 + ((a - res) % 2) << \"\\n\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n\n#include <iostream>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <unordered_set>\n#include <queue>\n#include <set>\n#include <algorithm>\n#include <numeric>\n#include <list>\nusing namespace std;\n\nusing QWORD  = uint64_t;\nusing SQWORD = int64_t;\nusing DWORD  = uint32_t;\nusing SDWORD = int32_t;\nusing WORD   = uint16_t;\nusing SWORD  = int16_t;\nusing BYTE   = uint8_t;\nusing SBYTE  = int8_t;\nusing DOUBLE = double;\nusing FLOAT  = float;\n\n#define MIN_SDWORD (-2147483648)\n#define MAX_SDWORD (2147483647)\n#define MIN_SBYTE (-128)\n#define MAX_SBYTE (127)\n\n#define MIN_SQWORD (0x8000000000000000)\n#define MAX_SQWORD (0x7FFFFFFFFFFFFFFF)\n\n#define MAX_QWORD  (0xFFFFFFFFFFFFFFFF)\n#define MAX_DWORD  (0xFFFFFFFF)\n#define MAX_WORD   (0xFFFF)\n#define MAX_BYTE   (0xFF)\n\n#define MAX_DOUBLE      (1.0e+308)\n#define DOUBLE_EPS      (1.0e-12)\n#define MIN_DOUBLE_N    (-1.0e+308)\n\n#define ArrayLength(a)  (sizeof(a) / sizeof(a[0]))\n\nstatic inline DOUBLE MAX(DOUBLE a, DOUBLE b) { return a > b ? a : b; }\nstatic inline QWORD MAX(QWORD a, QWORD b) { return a > b ? a : b; }\nstatic inline DWORD MAX(DWORD a, DWORD b) { return a > b ? a : b; }\nstatic inline SDWORD MAX(SDWORD a, SDWORD b) { return a > b ? a : b; }\nstatic inline DOUBLE MIN(DOUBLE a, DOUBLE b) { return a < b ? a : b; }\nstatic inline QWORD MIN(QWORD a, QWORD b) { return a < b ? a : b; }\nstatic inline DWORD MIN(DWORD a, DWORD b) { return a < b ? a : b; }\nstatic inline SDWORD MIN(SDWORD a, SDWORD b) { return a < b ? a : b; }\nstatic inline DOUBLE ABS(DOUBLE a) { return 0 < a ? a : -a; };\n\n#define BYTE_BITS   (8)\n#define WORD_BITS   (16)\n#define DWORD_BITS  (32)\n#define QWORD_BITS  (64)\n\nstatic inline void inputStringSpSeparated(char *pcStr)\n{\n    char *pcCur = pcStr;\n    for (;;) {\n        char c = getchar();\n        if (('\\n' == c) || (EOF == c) || (' ' == c)) {\n            break;\n        }\n        *pcCur = c;\n        pcCur++;\n    }\n    *pcCur = '\\0';\n}\n\nstatic inline void inputString(char *pcStr)\n{\n    char *pcCur = pcStr;\n    for (;;) {\n        char c = getchar();\n        if (('\\n' == c) || (EOF == c)) {\n            break;\n        }\n        *pcCur = c;\n        pcCur++;\n    }\n    *pcCur = '\\0';\n}\n\n\nstatic inline SQWORD inputSQWORD(void)\n{\n    SQWORD sqNumber = 0;\n    SQWORD sqMultiplier = 1;\n    bool bRead = false;\n    for (;;) {\n        char c = getchar();\n        if (!bRead) {\n            if ('-' == c) {\n                sqMultiplier = -1;\n            }\n        }\n        if (('0' <= c) && (c <= '9')) {\n            sqNumber *= 10LL;\n            sqNumber += (SQWORD)(c - '0');\n            bRead = true;\n        } else {\n            if (bRead) {\n                return sqNumber * sqMultiplier;\n            }\n        }\n    }\n}\n\n\nstatic inline SDWORD inputSDWORD(void)\n{\n    SDWORD lNumber = 0;\n    SDWORD lMultiplier = 1;\n    bool bRead = false;\n    for (;;) {\n        char c = getchar();\n        if (!bRead) {\n            if ('-' == c) {\n                lMultiplier = -1;\n            }\n        }\n        if (('0' <= c) && (c <= '9')) {\n            lNumber *= 10;\n            lNumber += (c - '0');\n            bRead = true;\n        } else {\n            if (bRead) {\n                return lNumber * lMultiplier;\n            }\n        }\n    }\n}\n\nstatic inline DOUBLE inputFP(void)\n{\n    DOUBLE dInt = 0.0;\n    DOUBLE dFrac = 0.0;\n    DOUBLE dMultiplier = 1.0;\n    DWORD dwFpCnt = 0;\n    DOUBLE *pdCur = &dInt;\n    bool bRead = false;\n    for (;;) {\n        char c = getchar();\n        if (!bRead) {\n            if ('-' == c) {\n                dMultiplier = -1;\n            }\n        }\n        if ('.' == c) {\n            pdCur = &dFrac;\n        } else if (('0' <= c) && (c <= '9')) {\n            (*pdCur) *= 10;\n            (*pdCur) += (DOUBLE)(c - '0');\n            bRead = true;\n            if (pdCur == &dFrac) {\n                dwFpCnt++;\n            }\n        } else {\n            if (bRead) {\n                return dMultiplier * (dInt + dFrac / (pow((DOUBLE)10.0 , (DOUBLE)dwFpCnt)));\n            }\n        }\n    }\n}\n\n\n/**\n *  mod による操作ライブラリ\n */\n\n#define ANS_MOD (1000000007LL)\n \nstatic SQWORD addMod(SQWORD x, SQWORD y)\n{ \n    return (x + y) % ANS_MOD;\n}\n \nstatic SQWORD subMod(SQWORD x, SQWORD y)\n{\n    return (x - y + ANS_MOD) % ANS_MOD;\n}\n \nstatic SQWORD mulMod(SQWORD x, SQWORD y) \n{\n    return (x * y) % ANS_MOD;\n}\n \nstatic SQWORD powMod(SQWORD x, SQWORD e) {\n    SQWORD v = 1;\n    for (; e; x = mulMod(x, x), e >>= 1) {\n        if (e & 1) {\n            v = mulMod(v, x);\n        }\n    }\n    return v;\n}\n \nstatic SQWORD divMod(SQWORD x, SQWORD y)\n{\n    return mulMod(x, powMod(y, ANS_MOD - 2));\n}\n \n \nstatic SQWORD combMod(SQWORD n, SQWORD k)\n{\n    SQWORD v=1;\n    for(SQWORD i=1; i<=k; i++) {\n        v = divMod(mulMod(v, n-i+1),i);\n    } \n    return v;\n}\n\n/*----------------------------------------------*/\n\ntypedef struct {\n    SDWORD lTo;\n    SQWORD sqCap;\n    SQWORD sqCost;\n    SDWORD lRev;\n} ST_EDGE;\n\n#define MAX_V   (202)\n\nstruct Flow {\nprivate:\n    vector<ST_EDGE> avGraph[MAX_V];\n    SDWORD  alDims[MAX_V];\n    SQWORD  sqEdgeNum;\n    SQWORD  asqDist[MAX_V];\n    SDWORD  alPrevV[MAX_V];   \n    SDWORD  alPrevEdge[MAX_V];      /*直前の頂点と辺 */\n\n    SDWORD  alDinic_Level[MAX_V];\n    SDWORD  alDinic_Iter[MAX_V];\n\npublic:\n    Flow() {\n        for (auto v: avGraph) {\n            v.clear();\n        }\n        memset(alDims, 0, sizeof(alDims));\n        memset(asqDist, 0, sizeof(asqDist));\n        memset(alPrevV, 0, sizeof(alPrevV)); \n        memset(alPrevEdge, 0, sizeof(alPrevEdge));\n        memset(alDinic_Level, 0, sizeof(alDinic_Level));\n        memset(alDinic_Iter, 0, sizeof(alDinic_Iter));\n    }\n    void addEdge(SDWORD lFrom, SDWORD lTo, SQWORD sqCap, SQWORD sqCost) {\n//        printf(\"%d ----[%lld] ----> %d\\n\", lFrom, sqCap, lTo);\n        \n        alDims[lFrom]++;\n        avGraph[lFrom].push_back((ST_EDGE){lTo, sqCap, sqCost, (SDWORD)(avGraph[lTo].size())});\n        avGraph[lTo].push_back((ST_EDGE){lFrom, 0, -sqCost, (SDWORD)(avGraph[lFrom].size() - 1)});\n    }\n\n    SDWORD minCostFlow(SDWORD lStart, SDWORD lTarget, SQWORD sqFlow)\n    {\n        SQWORD sqRes = 0;\n        SQWORD sqFlowRest = sqFlow;\n        while (0 < sqFlowRest) {\n            /* Bellman-Ford Method */\n            fill(asqDist, asqDist + ArrayLength(asqDist), MAX_SDWORD);\n            asqDist[lStart] = 0;\n            bool bIsUpdate = true;\n            while (bIsUpdate) {\n                bIsUpdate = false;\n                for (SDWORD lV = 0; lV < MAX_V; lV++) {\n                    for (SDWORD lIdx = 0; lIdx < avGraph[lV].size(); lIdx++) {\n                        ST_EDGE &stE = avGraph[lV][lIdx];\n                        if ((asqDist[lV] != MAX_SDWORD)\n                                && (0 < stE.sqCap)\n                                && (asqDist[lV] + stE.sqCost < asqDist[stE.lTo])) {\n                            asqDist[stE.lTo] = asqDist[lV] + stE.sqCost;\n                            alPrevV[stE.lTo] = lV;\n                            alPrevEdge[stE.lTo] = lIdx;\n                            bIsUpdate = true;\n                        }\n                    }\n                }\n            }\n            if (asqDist[lTarget] == MAX_SDWORD) {\n                return -1;\n            }\n\n            SQWORD sqAddFlow = MAX_SQWORD;\n            for (SDWORD lV = lTarget; lV != lStart; lV = alPrevV[lV]) {\n                sqAddFlow = min(sqAddFlow, avGraph[alPrevV[lV]][alPrevEdge[lV]].sqCap);\n            }\n            sqFlowRest -= sqAddFlow;\n            sqRes += sqAddFlow * asqDist[lTarget];      // 後で目的変数は書き換える\n            for (SDWORD lV = lTarget; lV != lStart; lV = alPrevV[lV]) {\n                ST_EDGE &stE = avGraph[alPrevV[lV]][alPrevEdge[lV]];\n                stE.sqCap -= sqAddFlow;\n                avGraph[lV][stE.lRev].sqCap += sqAddFlow;\n            }\n        }\n        return sqRes;\n    }\n\nprivate:\n    SQWORD maxFlowDinicBfs(SDWORD lS)\n    {\n        memset(alDinic_Level, -1, sizeof(alDinic_Level));\n        queue<SDWORD> queSearch;\n        alDinic_Level[lS] = 0;\n        queSearch.push(lS);\n        while (!queSearch.empty()) {\n            SDWORD lV = queSearch.front();\n            queSearch.pop();\n            for (SDWORD lIdx = 0; lIdx < avGraph[lV].size(); lIdx++) {\n                ST_EDGE &stE = avGraph[lV][lIdx];\n                if ((0 < stE.sqCap) && (alDinic_Level[stE.lTo] < 0)) {\n                    alDinic_Level[stE.lTo] = alDinic_Level[lV] + 1;\n                    queSearch.push(stE.lTo);\n                }\n            }\n        }\n\n        return 0;\n    }\n\n    SQWORD maxFlowDinicDfs(SDWORD lV, SDWORD lT, SQWORD sqF)\n    {\n        if (lV == lT) {\n            return sqF;\n        }\n        for (SDWORD &lI = alDinic_Iter[lV]; lI < avGraph[lV].size(); lI++) {\n            ST_EDGE &stE = avGraph[lV][lI];\n            if ((0 < stE.sqCap) && (alDinic_Level[lV] < alDinic_Level[stE.lTo])) {\n                SQWORD sqDiffFlow = maxFlowDinicDfs(stE.lTo, lT, min(sqF, stE.sqCap));\n                if (0 < sqDiffFlow) {\n                    stE.sqCap -= sqDiffFlow;\n                    avGraph[stE.lTo][stE.lRev].sqCap += sqDiffFlow;\n                    return sqDiffFlow;\n                }\n            }\n        }\n        return 0;\n    }\n\npublic:\n    SQWORD MaxFlow(SDWORD lStart, SDWORD lTarget)\n    {\n        SQWORD sqFlow = 0LL;\n        for (;;) {\n            maxFlowDinicBfs(lStart);\n            if (alDinic_Level[lTarget] < 0) {\n                return sqFlow;\n            }\n            memset(alDinic_Iter, 0, sizeof(alDinic_Iter));\n            while (1) {\n                SQWORD sqDiffFlow = maxFlowDinicDfs(lStart, lTarget, MAX_SQWORD);\n                sqFlow += sqDiffFlow;\n                if (0LL == sqDiffFlow) {\n                    break;\n                }\n            }\n        }\n    }\n\n    SQWORD getFlow(SDWORD lPnt)\n    {\n        SQWORD sqCapSum = 0; \n        for (auto e: avGraph[lPnt]) {\n            sqCapSum += e.sqCap;\n        }\n        return alDims[lPnt] - sqCapSum;\n    }\n};\n\n/*----------------------------------------------*/\n\nstatic void getPrimes(vector<SDWORD> &vlPrimes, SDWORD lMax)\n{\n    /* lSearchMax と ループ内の *2 の関係から、入力は3以上とすること */\n    if (!(1 <= lMax)) {\n        printf(\"Oops!\");\n        return;\n    }\n\n    /* 素数のリストを作る */\n    vector<bool> vbIsPrime(lMax + 1, true);\n    SDWORD lSearchMax = sqrt(lMax) + 1;\n    vbIsPrime[0] = false;\n    vbIsPrime[1] = false;\n    for (SDWORD lPrime = 2; lPrime < vbIsPrime.size(); lPrime++) {\n        if (vbIsPrime[lPrime]) {\n            vlPrimes.emplace_back(lPrime);\n            if (lPrime <= lSearchMax) {\n                for (SDWORD lCurNum = lPrime * 2; lCurNum <= lMax; lCurNum += lPrime) {\n                    vbIsPrime[lCurNum] = false;\n                }\n            }\n        }\n    }\n}    \n\n/*----------------------------------------------*/\n\n#define PNT_NO_START    (0)\n#define PNT_NO_OFFSET   (100)\n#define PNT_NO_TARGET   (201)\n#define FLOW_OFFSET     (1000000000)\n#define CAPACITY_INF    (1000000001)\n#define DUMMY_COST      (1)\n\nint main(void)\n{\n    SQWORD sqN = inputSQWORD();\n\n    Flow solverFlow;\n    vector<SQWORD> vsqA;\n    vector<SQWORD> vsqB;\n    vector<SDWORD> vlPrimes;\n\n    getPrimes(vlPrimes, 1e7 + 1);\n    vlPrimes.erase(find(vlPrimes.begin(), vlPrimes.end(), 2));\n\n    for (SQWORD sqIdx = 0; sqIdx < sqN; sqIdx++) {\n        SQWORD sqA = inputSQWORD();\n        vsqA.emplace_back(sqA);\n    }\n\n#if 0\n    for (SQWORD sqIdx = 0; sqIdx < sqN; sqIdx++) {\n        if (0 < sqIdx) {\n            if (!(vsqA[sqIdx - 1] == vsqA[sqIdx] - 1)) {\n                vsqB.emplace_back(vsqA[sqIdx]);\n            }\n        } else {\n            vsqB.emplace_back(vsqA[sqIdx]);      \n        }\n        if (sqIdx < sqN - 1) {\n            if (!(vsqA[sqIdx] + 1 == vsqA[sqIdx + 1])) {\n                vsqB.emplace_back(vsqA[sqIdx] + 1);\n            }\n        } else {\n            vsqB.emplace_back(vsqA[sqIdx] + 1);\n        }\n    }\n#else\n    vsqB = vsqA;\n#endif\n\n    vector<SQWORD> vsqCOdd;\n    vector<SQWORD> vsqCEven;\n    \n    map<SQWORD, SQWORD> mapCEven, mapCOdd;\n\n    SQWORD sqIdx = 1;\n    for (auto b: vsqB) {\n        if (0 == b % 2) {\n            vsqCEven.emplace_back(b);\n            mapCEven[b] = sqIdx;\n        } else {\n            vsqCOdd.emplace_back(b);\n            mapCOdd[b] = sqIdx;\n        }\n        sqIdx++;\n    }\n\n    /* 二部マッチング */\n    for (auto c: vsqCEven) {\n        solverFlow.addEdge(PNT_NO_START, mapCEven[c], 1, DUMMY_COST);\n    }\n    for (auto c: vsqCEven) {\n        solverFlow.addEdge(mapCOdd[c] + PNT_NO_OFFSET, PNT_NO_TARGET, 1, DUMMY_COST);\n    }\n\n    for (auto p: vlPrimes) {\n        for (auto c: vsqCEven) {\n            auto it = lower_bound(vsqCOdd.begin(), vsqCOdd.end(), c + p);\n            if (it != vsqCOdd.end()) {\n                if (*it == c + p) {\n                    if (c + p < 1e7 + 1) {\n                        solverFlow.addEdge(mapCEven[c], mapCOdd[c + p] + PNT_NO_OFFSET, 1, DUMMY_COST);\n                    }\n                }\n            }\n        }\n    }\n\n    SQWORD sqMaxFlow = solverFlow.MaxFlow(PNT_NO_START, PNT_NO_TARGET);\n    SQWORD vsqCRestEven = 0;\n    SQWORD vsqCRestOdd = 0;\n    for (auto c: vsqCEven) {\n        SQWORD sqFlow = solverFlow.getFlow(mapCEven[c]);\n        if (0 == sqFlow) {\n            vsqCRestEven++;\n        }\n    }\n    for (auto c: vsqCOdd) {\n        SQWORD sqFlow = solverFlow.getFlow(mapCOdd[c]);\n        if (0 == sqFlow) {\n            vsqCRestOdd++;\n        }\n    }\n\n    SQWORD sqAns = sqMaxFlow;    \n    sqAns += (vsqCRestEven / 2) * 2;\n    sqAns += (vsqCRestOdd / 2) * 2;\n    if (0 < (vsqCRestEven %  2)) {\n        sqAns += 3;\n    }\n\n    printf(\"%lld\\n\", sqAns);\n\n    return 0;\n}\n/*------------------------------------------*/\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define abs abs_\ninline int abs(int x){return x<0?-x:x;} \ninline bool chk(int n){if(n<=2)return false;for(int d=2;d*d<=n;d++)if(n%d==0)return false;return true;}\n\nconst int N=233,M=23333,inf=1e9;\n\nint S,T,h[N],nxt[M],to[M],flow[M],cnt=1,qu[N],ql,qr,d[N];\nvoid addedge(int u,int v,int c){\n\tto[++cnt]=v,nxt[cnt]=h[u],h[u]=cnt,flow[cnt]=c;\n\tto[++cnt]=u,nxt[cnt]=h[v],h[v]=cnt,flow[cnt]=0;\n}\nbool bfs(){\n\tfor(int i=S;i<=T;i++)d[i]=-1;\n\td[S]=0,qu[ql=qr=1]=S;\n\twhile(ql<=qr){\n\t\tint u=qu[ql++];\n\t\tfor(int i=h[u],v;i;i=nxt[i])if(d[v=to[i]]==-1&&flow[i])d[v]=d[u]+1,qu[++qr]=v;\n\t\tif(d[T]!=-1)break;\n\t}\n\treturn d[T]!=-1;\n}\nint dfs(int u,int mf){\n\tif(u==T)return mf;\n\tint r=0,p;\n\tfor(int i=h[u],v;i;i=nxt[i])if(d[v=to[i]]==d[u]+1&&flow[i])\n\t\tp=dfs(v,min(mf,flow[i])),flow[i]-=p,flow[i^1]+=p,r+=p,mf-=p; \n\treturn r;\n}\nint dinic(){\n\tint r=0;\n\twhile(bfs())r+=dfs(S,inf);\n\treturn r;\n}\n\nint n,m1,m2,odd[N],even[N];\nset<int> dat;\n\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=1,x;i<=n;i++){\n\t\tscanf(\"%d\",&x);\n\t\tif(dat.count(x))dat.erase(x);else dat.insert(x);\n\t\tx++;\n\t\tif(dat.count(x))dat.erase(x);else dat.insert(x);\n\t}\n\tfor(int x:dat)if(x&1)odd[++m1]=x;else even[++m2]=x;\n\tT=m1+m2+1;\n\tfor(int i=1;i<=m1;i++)addedge(S,i,1);\n\tfor(int i=1;i<=m2;i++)addedge(i+m1,T,1);\n\tfor(int i=1;i<=m1;i++)for(int j=1;j<=m2;j++)\n\t\tif(chk(abs(odd[i]-even[j])))addedge(i,j+m1,1);\n\tint mch=dinic(),ans=m1+m2-mch+((m1-mch)&1); \n\tprintf(\"%d\\n\",ans); \n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fi first\n#define se second\n#define rep(i,n) for(int i = 0; i < (n); ++i)\n#define rrep(i,n) for(int i = 1; i <= (n); ++i)\n#define drep(i,n) for(int i = (n)-1; i >= 0; --i)\n#define each(it,c) for(__typeof((c).begin()) it=(c).begin();it!=(c).end();it++)\n#define rng(a) a.begin(),a.end()\n#define maxs(x,y) x = max(x,y)\n#define mins(x,y) x = min(x,y)\n#define pb push_back\n#define sz(x) (int)(x).size()\n#define pcnt __builtin_popcount\n#define uni(x) x.erase(unique(rng(x)),x.end())\n#define snuke srand((unsigned)clock()+(unsigned)time(NULL));\n#define df(x) int x = in()\n#define dame { puts(\"-1\"); return 0;}\n#define show(x) cout<<#x<<\" = \"<<x<<endl;\n#define PQ(T) priority_queue<T,vector<T>,greater<T> >\n#define bn(x) ((1<<x)-1)\n#define newline puts(\"\")\n#define v(T) vector<T>\n#define vv(T) vector<vector<T>>\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned uint;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<P> vp;\ninline int in() { int x; scanf(\"%d\",&x); return x;}\ninline void priv(vi a) { rep(i,sz(a)) printf(\"%d%c\",a[i],i==sz(a)-1?'\\n':' ');}\ntemplate<typename T>istream& operator>>(istream&i,vector<T>&v)\n{rep(j,sz(v))i>>v[j];return i;}\ntemplate<typename T>string join(const vector<T>&v)\n{stringstream s;rep(i,sz(v))s<<' '<<v[i];return s.str().substr(1);}\ntemplate<typename T>ostream& operator<<(ostream&o,const vector<T>&v)\n{if(sz(v))o<<join(v);return o;}\ntemplate<typename T1,typename T2>istream& operator>>(istream&i,pair<T1,T2>&v)\n{return i>>v.fi>>v.se;}\ntemplate<typename T1,typename T2>ostream& operator<<(ostream&o,const pair<T1,T2>&v)\n{return o<<v.fi<<\",\"<<v.se;}\nconst int MX = 100005, INF = 1001001001;\nconst ll LINF = 1e18;\nconst double eps = 1e-10;\n\n// linear sieve\nvi ps, pf;\nvoid sieve(int mx) {\n  pf = vi(mx);\n  rep(i,mx) pf[i] = i;\n  for (int i = 2; i < mx; ++i) {\n    if (pf[i] == i) ps.pb(i);\n    for (int j = 0; j < sz(ps) && ps[j] <= pf[i]; ++j) {\n      int x = ps[j]*i;\n      if (x >= mx) break;\n      pf[x] = ps[j];\n    }\n  }\n}\ninline bool isp(int x) { return pf[x] == x && x >= 2;}\n//\n\n// binary matching\nstruct match {\n  vi used;\n  vvi to;\n  vi p;\n  int n, m;\n  match(int n, int m):used(n),to(n),p(m,-1),n(n),m(m){}\n  void add(int a, int b) { to[a].pb(b);}\n  bool dfs(int v){\n    if(used[v]) return false;\n    used[v] = 1;\n    rep(i,sz(to[v])) {\n      int u = to[v][i];\n      if (p[u] == -1 || dfs(p[u])){\n        p[u] = v;\n        return true;\n      }\n    }\n    return false;\n  }\n  int solve(){\n    int res = 0;\n    rep(i,n) {\n      rep(j,n) used[j] = 0;\n      if(dfs(i)) ++res;\n    }\n    return res;\n  }\n};\n//\n\n\n\nint main() {\n  sieve(10000005);\n  int n;\n  scanf(\"%d\",&n);\n  vi x(n);\n  cin>>x;\n  vi a;\n  int pre = -INF;\n  for (int s : x) {\n    if (pre == s-1) {\n      a.pop_back();\n    } else {\n      a.pb(s);\n    }\n    a.pb(s+1);\n    pre = s;\n  }\n  vvi d(2);\n  for (int s : a) {\n    d[s&1].pb(s);\n  }\n  n = sz(d[0]);\n  int m = sz(d[1]);\n  match g(n,m);\n  rep(i,n)rep(j,m) {\n    if (isp(abs(d[0][i]-d[1][j]))) g.add(i,j);\n  }\n  int c = g.solve();\n  n -= c; m -= c;\n  int ans = (n/2+m/2)*2+c;\n  n %= 2; m %= 2;\n  if (n) ans += 3;\n  cout<<ans<<endl;\n  return 0;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mo 1000000007\n#define pi 3.1415926535898\n#define eps 1e-9 \nusing namespace std;\nlong long read(){\n    long long xx=0,flagg=1;\n    char ch=getchar();\n    while((ch<'0'||ch>'9')&&ch!='-')\n        ch=getchar();\n    if(ch=='-'){\n        flagg=-1;\n        ch=getchar();\n    }\n    while(ch>='0'&&ch<='9'){\n        xx=xx*10+ch-'0';\n        ch=getchar();\n    }\n    return xx*flagg;\n}\nvoid pus(long long xx,long long flagg){\n    if(xx<0){\n        putchar('-');\n        xx=-xx;\n    }\n    if(xx>=10)\n        pus(xx/10,0);\n    putchar(xx%10+'0');\n    if(flagg==1)\n        putchar(' ');\n    if(flagg==2)\n        putchar('\\n');\n    return;\n}\n\nlong long ksc(long long u,long long v,long long n){\n\treturn (u*v-(long long)((long double)u/n*v)*n+n)%n;\n}\nlong long ksm(long long u,long long v,long long n){\n\tlong long o=1;\n\twhile(v){\n\t\tif(v&1)\n\t\t\to=ksc(o,u,n);\n\t\tu=ksc(u,u,n);\n\t\tv>>=1;\n\t}\n\treturn o;\n}\nlong long miller(long long n){\n\tif(n<=28){\n\t\tif(n==2||n==3||n==5||n==7||n==11||n==13||n==17||n==19||n==23)\n\t\t\treturn 1;\n\t\treturn 0;\n\t}\n\tlong long book[9]={2,3,5,7,11,13,17,19,23},i,j,x,y;\n\tfor(i=0;i<=8;i++){\n\t\tj=n-1;\n\t\twhile((j&1)==0)\n\t\t\tj>>=1;\n\t\tif(ksm(book[i],n-1,n)!=1)\n\t\t\treturn 0;\n\t\tx=ksm(book[i],j,n);\n\t\tif(x!=1){\n\t\t\twhile(j!=n-1){\n\t\t\t\tif(x==n-1)\n\t\t\t\t\tbreak;\n\t\t\t\tif(x==1)\n\t\t\t\t\treturn 0;\n\t\t\t\tx=ksc(x,x,n);\n\t\t\t\tj<<=1;\n\t\t\t}\n\t\t\tif(x!=n-1)\n\t\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}\nint n,m,s,t,i,j,x,y,z,zhan[100005],book[100005],flag,ans,a[10000005],top1,top2,b[205],c[205];\nint top,fir[100005],qu[200005],to[200005],nex[200005],iter[100005];\nint lj(int u,int v,int w){\n\ttop++;\n\tnex[top]=fir[u];\n\tfir[u]=top;\n\tto[top]=v;\n\tqu[top]=w;\n\treturn 0;\n}\nint BFS(){\n\tint head=0,tail=0,v;\n\tzhan[0]=s;book[s]=1;\n\twhile(head<=tail){\n\t\tv=zhan[head];\n\t\tfor(int top1=fir[v];top1;top1=nex[top1])\n\t\t\tif(book[to[top1]]==0&&qu[top1]){\n\t\t\t\ttail++;\n\t\t\t\tzhan[tail]=to[top1];\n\t\t\t\tbook[to[top1]]=book[v]+1;\n\t\t\t}\n\t\thead++;\n\t}\n\treturn 0;\n}\nint DFS(int v,int w){\n\tif(v==t){\n\t\tflag=w;\n\t\tans+=w;\n\t\treturn 0;\n\t}\n\tfor(int &top1=iter[v];top1;top1=nex[top1])\n\t\tif(book[to[top1]]==book[v]+1&&qu[top1]){\n\t\t\tDFS(to[top1],min(w,qu[top1]));\n\t\t\tif(flag){\n\t\t\t\tqu[top1]-=flag;\n\t\t\t\tif(top1&1)\n\t\t\t\t\tqu[top1+1]+=flag;\n\t\t\t\telse\n\t\t\t\t\tqu[top1-1]+=flag;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n}\nint main(){\n\t//freopen(\"7.in\",\"r\",stdin);\n    //freopen(\"7.out\",\"w\",stdout);\n   \tn=read();\n   \tfor(i=1;i<=n;i++){\n\t\tx=read();\n\t\ta[x-1]^=1;\n\t\ta[x]^=1;\n\t}\n\tfor(i=0;i<=10000000;i++)\n\t\tif(a[i]==1){\n\t\t\tif(i&1){\n\t\t\t\ttop1++;\n\t\t\t\tb[top1]=i;\n\t\t\t}\n\t\t\telse{\n\t\t\t\ttop2++;\n\t\t\t\tc[top2]=i;\n\t\t\t}\n\t\t}\n\ts=top1+top2+1;\n\tt=top1+top2+2;\n\tn=t;\n\tfor(i=1;i<=top1;i++)\n\t\tfor(j=1;j<=top2;j++)\n\t\t\tif(miller(abs(c[j]-b[i]))==1){\n\t\t\t\tlj(i,j+top1,1);\n\t\t\t\tlj(j+top1,i,0);\n\t\t\t}\n\tfor(i=1;i<=top1;i++){\n\t\tlj(s,i,1);\n\t\tlj(i,s,0);\n\t}\n\tfor(i=1;i<=top2;i++){\n\t\tlj(i+top1,t,1);\n\t\tlj(t,i+top1,0);\n\t}\n\tdo{\n\t\tfor(i=1;i<=n;i++){\n\t\t\tbook[i]=0;\n\t\t\titer[i]=fir[i];\n\t\t}\n\t\tBFS();\n\t\tdo{\n\t\t\tflag=0;\n\t\t\tDFS(s,2147483647);\n\t\t}while(flag);\n\t}while(book[t]);\n\tif(((top1-ans)&1)==0)\n\t\tpus(top1+top2-ans,2);\n\telse\n\t\tpus(top1+top2-ans+1,2);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MAXV = 10000100;\n\nbool np[MAXV];\n\nvoid precalc() {\n   np[0] = np[1] = true;\n   for (int i = 2; i < MAXV; ++i) {\n      if (np[i]) continue;\n      for (int j = i + i; j < MAXV; j += i) {\n         np[j] = true;\n      }\n   }\n}\n\nint main() {\n   ios_base::sync_with_stdio(false);\n   precalc();\n   int N;\n   cin >> N;\n   vector<int> X(N);\n   for (int i = 0; i < N; ++i) {\n      cin >> X[i];\n   }\n   {\n      vector<int> newX;\n      newX.emplace_back(X[0]);\n      for (int i = 0; i + 1 < N; ++i) {\n         if (X[i] + 1 != X[i + 1]) {\n            newX.emplace_back(X[i] + 1);\n            newX.emplace_back(X[i + 1]);\n         }\n      }\n      newX.emplace_back(X.back() + 1);\n      X = newX;\n      N = X.size();\n   }\n   vector<int> odds;\n   vector<int> evens;\n   for (int i = 0; i < N; ++i) {\n      if (X[i] & 1) {\n         odds.emplace_back(X[i]);\n      } else {\n         evens.emplace_back(X[i]);\n      }\n   }\n   int no = odds.size();\n   int ne = evens.size();\n   vector<vector<int>> adj(1000);\n   vector<int> mt(1000, -1);\n   vector<bool> visited(1000);\n   for (int i = 0; i < no; ++i) {\n      for (int j = 0; j < ne; ++j) {\n         if (!np[abs(odds[i] - evens[j])]) {\n            adj[i].emplace_back(j);\n         }\n      }\n   }\n   int tt = 0;\n   function<bool(int)> dfs = [&](int v) {\n      if (visited[v] == tt) return false;\n      visited[v] = tt;\n      for (int u : adj[v]) {\n         if (mt[u] == -1) {\n            mt[u] = v;\n            return true;\n         }\n      }\n      for (int u : adj[v]) {\n         if (dfs(mt[u])) {\n            mt[u] = v;\n            return true;\n         }\n      }\n      return false;\n   };\n   int ans = 0;\n   for (int i = 0; i < 1000; ++i) {\n      ++tt;\n      ans += dfs(i);\n   }\n   no -= ans;\n   ne -= ans;\n   ans += 2 * (no / 2);\n   ans += 2 * (ne / 2);\n   if (no & 1) ans += 3;\n   cout << ans << \"\\n\";\n   return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n  \nusing namespace std;\n  \n#define rep(i,n) REP(i,0,n)\n#define REP(i,s,e) for(int i=(s); i<(int)(e); i++)\n#define repr(i, n) REPR(i, n, 0)\n#define REPR(i, s, e) for(int i=(int)(s-1); i>=(int)(e); i--)\n#define pb push_back\n#define all(r) r.begin(),r.end()\n#define rall(r) r.rbegin(),r.rend()\n#define fi first\n#define se second\n  \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n \nconst int INF = 1e9;\nconst ll MOD = 1e9 + 7;\ndouble EPS = 1e-8;\n\n#define MAX_V 110\n \nstruct Edge\n{\n    int to, cap, rev;\n    Edge(){};\n    Edge(int to, int cap, int rev) : to(to), cap(cap), rev(rev){};\n};\n \nvector<Edge> G[MAX_V];\nbool used[MAX_V];\n \nvoid add_edge(int from, int to, int cap){\n    G[from].push_back({to, cap, (int)G[to].size()});\n    G[to].push_back({from, 0, (int)G[from].size()-1});\n}\n \nint dfs(int v, int t, int f){\n    if(v == t) return f;\n    used[v] = true;\n    for(int i = 0; i < G[v].size(); i++){\n        Edge& e = G[v][i];\n        if(!used[e.to] && e.cap > 0){\n            int d = dfs(e.to, t, min(f, e.cap));\n            if(d > 0){\n                e.cap -= d;\n                G[e.to][e.rev].cap += d;\n                return d;\n            }\n        }\n    }\n    return 0;\n}\n \nint max_flow(int s, int t){\n    int flow = 0;\n    while(1){\n        memset(used, 0, sizeof(used));\n        int f = dfs(s, t, INF);\n        if(f == 0) return flow;\n        flow += f;\n    }\n}\n\n//エラトステネスの篩を使用\nconst int MAX_PRIME = 1e7 + 10;\n \nvector<int> is_prime(MAX_PRIME,1);\n \nvoid calcPrime(){\n    is_prime[0]=is_prime[1]=0;\n    for(int i=2; i<MAX_PRIME; i++){\n        if(is_prime[i]==1){\n            for(int j=i*2; j<MAX_PRIME; j+=i){\n                is_prime[j]=0;\n            }\n        }\n    }\n}\n\nint main(){\n\tcalcPrime();\n\tint n;\n\tcin >> n;\n\tvi x(n);\n\trep(i, n) cin >> x[i];\n\tconst int MAX = 1e7+10;\n\tvi a(MAX), b(MAX);\n\trep(i, n) a[x[i]] = 1;\n\trep(i, MAX-1) b[i] = a[i]^a[i+1];\n\tvi odd, even;\n\trep(i, MAX) if(b[i]) (i&1?odd:even).pb(i);\n\trep(i, odd.size()) rep(j, even.size()) {\n\t\tif(is_prime[abs(odd[i]-even[j])]) add_edge(i, odd.size()+j, 1);\n\t}\n\trep(i, odd.size()) add_edge(n, i, 1);\n\trep(i, even.size()) add_edge(odd.size()+i, n+1, 1);\n\tint f = max_flow(n, n+1);\n\tint ans = f + (odd.size()-f)/2*2 + (even.size()-f)/2*2;\n\tif((odd.size()-f)&1) ans += 3;\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#define fo(i,a,b) for(int i=a;i<=b;i++)\n#define fd(i,b,a) for(int i=b;i>=a;i--)\n#define efo(i,u,v) for(int i=BB[u],v=B[BB[u]][1];i;v=B[i=B[i][0]][1])\n#define mset(a,x) memset(a,x,sizeof(a))\nusing namespace std;\ntypedef long long ll;\nchar ch;\nint read(){int n=0,p=1;for(ch=getchar();ch<'0' || '9'<ch;ch=getchar())if(ch=='-') p=-1;for(;'0'<=ch && ch<='9';ch=getchar()) n=n*10+ch-'0';return n*p;}\nconst int N=205,M=2e7+5;\nint n,m,a[N],d[N<<1],pr[M];\nbool b[M],c[M],bz[M];\nvoid prep()\n{\n\tmset(bz,1);\n\tbz[0]=bz[1]=0;\n\tfo(i,2,m)\n\t{\n\t\tif(bz[i]) pr[++pr[0]]=i;\n\t\tfo(j,1,pr[0])\n\t\t{\n\t\t\tll x=(ll)i*pr[j];\n\t\t\tif(x>m) break;\n\t\t\tbz[x]=0;\n\t\t\tif(i%pr[j]==0) break;\n\t\t}\n\t}\n}\n\nconst int V=N<<2,INF=1e9;\nconst int E=10*V*V;\nint ans,B0,S,T,BB[V],dis[V],B[E][4];\nbool vis[V];\nvoid link(int u,int v,int r,int w)\n{\n\tB[++B0][1]=v,B[B0][2]=r,B[B0][3]=w,B[B0][0]=BB[u],BB[u]=B0;\n\tif(!(B0&1)) link(v,u,0,-w);\n}\nint aug(int v,int flow)\n{\n\tvis[v]=1;\n\tif(v==T)\n\t{\n\t\tans+=dis[S]*flow;\n\t\treturn flow;\n\t}\n\tefo(i,v,u)\n\t\tif(B[i][2] && !vis[u] && dis[v]==dis[u]+B[i][3])\n\t\t{\n\t\t\tint f=aug(u,min(flow,B[i][2]));\n\t\t\tif(f)\n\t\t\t{\n\t\t\t\tB[i][2]-=f,B[i^1][2]+=f;\n\t\t\t\treturn f;\n\t\t\t}\n\t\t}\n\treturn 0;\n}\nbool change()\n{\n\tint minh=INF;\n\tfo(u,S,T) if(vis[u])\n\t\tefo(i,u,v) if(!vis[v])\n\t\t\tif(B[i][2]) minh=min(minh,dis[v]+B[i][3]-dis[u]);\n\tif(minh==INF) return 0;\n\tfo(i,S,T) if(vis[i]) dis[i]+=minh,vis[i]=0;\n\treturn 1;\n}\nint main()\n{\n\tn=read();\n\tfo(i,1,n) b[a[i]=read()]=1,m=max(m,a[i]);\n\t++m;\n\tprep();\n\tfo(i,1,m) c[i]=b[i]^b[i-1];\n\tfo(i,1,m) if(c[i]) d[++d[0]]=i;\n\t\n\tB0=1,S=0,T=d[0]+d[0]+1;\n\tfo(i,1,d[0]-1)\n\t\tfo(j,i+1,d[0])\n\t\t{\n\t\t\tif((d[j]-d[i])%2==0) link(i,d[0]+j,1,2),link(j,d[0]+i,1,2);\n\t\t\telse\n\t\t\tif(bz[d[j]-d[i]]) link(i,d[0]+j,1,1),link(j,d[0]+i,1,1);\n\t\t\telse link(i,d[0]+j,1,3),link(j,d[0]+i,1,3);\n\t\t}\n\tfo(i,1,d[0]) link(S,i,1,0),link(d[0]+i,T,1,0);\n\t\n\tdo\n\t{\n\t\twhile(aug(S,INF)) mset(vis,0);\n\t}\n\twhile(change());\n\tprintf(\"%d\",ans/2);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define ld long double\n#define ull unsigned long long\n#define poly vector<ll>\n#define pb push_back\n#define pii pair<int,int>\n#define fi first\n#define se second\n#define mp make_pair\n#define For(i,l,r) for(int i=(int)(l);i<=(int)(r);i++)\n#define Rep(i,r,l) for(int i=(int)(r);i>=(int)(l);i--)\ninline ll read(){\n\tll x=0;char ch=getchar();bool d=1;\n\tfor(;!isdigit(ch);ch=getchar()) if(ch=='-') d=0;\n\tfor(;isdigit(ch);ch=getchar()) x=x*10+ch-'0';\n\treturn d?x:-x;\n}\ninline void write(ll x){\n\tif(x<0) x=-x,putchar('-');\n\tif(x>=10) write(x/10);\n\tputchar('0'+x%10);\n}\ninline void writeln(ll x){write(x);puts(\"\");}\ninline void writep(ll x){write(x);putchar(' ');}\ninline ull rnd(){\n\treturn ((ull)rand()<<30^rand())<<4|rand()%4;\n}\nconst int N=205;\nint head[N],opt;\nstruct info{\n\tint to,nxt;\n}e[N*N*2];\nvoid add(int x,int y){\n\te[++opt]=(info){y,head[x]};head[x]=opt;\n\te[++opt]=(info){x,head[y]};head[y]=opt;\n}\nbool check(int x){\n\tif(x<=2) return 0;\n\tfor(int i=2;i*i<=x;i++){\n\t\tif(x%i) return 0;\n\t}\n\treturn 1;\n}\nint ma[N];\nbool used[N];\nbool dfs(int u){\n\tfor(int i=head[u];i;i=e[i].nxt){\n\t\tint k=e[i].to;\n\t\tif(used[k]) continue;\n\t\tused[k]=1;\n\t\tif(!ma[k]||dfs(ma[k])) return ma[k]=u,1;\n\t}\n\treturn 0;\n}\nint a[N],pos[N];\nint main(){\n\tint n=read(),m=0,cnt=0;\n\tFor(i,1,n){\n\t\ta[i]=read();\n\t\tif(i==1||a[i-1]<a[i]-1) pos[++m]=a[i];\n\t\tif(i>1&&a[i-1]+1<a[i]) pos[++m]=a[i-1]+1;\n\t}\n\tpos[++m]=a[n]+1;\n\tFor(i,1,m) if(pos[i]&1) cnt++;\n\tFor(i,1,m) if(pos[i]%2==0){\n\t\tFor(j,i+1,m) if(pos[j]%2==1){\n\t\t\tif(check(pos[j]-pos[i])) add(i,j);\n\t\t}\n\t}\n\tint ssw=0;\n\tFor(i,1,m) if(pos[i]%2==0){\n\t\tmemset(used,0,sizeof(used));\n\t\tssw+=dfs(i);\n\t}\n\tcout<<ssw+(m-ssw*2)+(cnt-ssw)%2;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ninline int gi()\n{\n\tchar c = getchar();\n\twhile (c < '0' || c > '9') c = getchar();\n\tint sum = 0;\n\twhile ('0' <= c && c <= '9') sum = sum * 10 + c - 48, c = getchar();\n\treturn sum;\n}\n\nconst int maxn = 2005, maxp = 1e7 + 5;\n\nint n, m, x[maxn], p[maxn];\nint Vis[maxp];\n\nstruct edge\n{\n\tint to, next, cap;\n} e[maxn * maxn * 2];\nint h[maxn], cur[maxn], tot = 1, dis[maxn], s, t;\nbool vis[maxn];\n\ninline void add(int u, int v, int w)\n{\n\te[++tot] = (edge) {v, h[u], w}; h[u] = tot;\n\te[++tot] = (edge) {u, h[v], 0}; h[v] = tot;\n}\n\nvoid pre()\n{\n\tstatic int p[maxp], cnt;\n\tVis[1] = 1;\n\tfor (int i = 2; i <= 1e7; ++i) {\n\t\tif (!Vis[i]) p[++cnt] = i, Vis[i] = i;\n\t\tfor (int j = 1; j <= cnt && i * p[j] <= 1e7; ++j) {\n\t\t\tVis[i * p[j]] = p[j];\n\t\t\tif (p[j] >= Vis[i]) break;\n\t\t}\n\t}\n\tVis[2] = 1;\n\tfor (int i = 2; i <= 1e7; ++i)\n\t\tif (Vis[i] == i) Vis[i] = 0;\n}\n\nbool bfs()\n{\n\tstatic int u, l, r, q[maxn];\n\tl = 0; q[r = 1] = s; vis[s] = 1;\n\twhile (l < r) {\n\t\tu = q[++l];\n\t\tfor (int i = h[u], v; v = e[i].to, i; i = e[i].next)\n\t\t\tif (!vis[v] && e[i].cap) {\n\t\t\t\tvis[v] = 1; dis[v] = dis[u] + 1;\n\t\t\t\tq[++r] = v;\n\t\t\t}\n\t}\n\treturn vis[t];\n}\n\nint dfs(int u, int a)\n{\n\tif (u == t || !a) return a;\n\tint f = 0, flow = 0;\n\tfor (int &i = cur[u], v; v = e[i].to, i; i = e[i].next)\n\t\tif (dis[v] == dis[u] + 1 && (f = dfs(v, min(e[i].cap, a)))) {\n\t\t\te[i].cap -= f; e[i ^ 1].cap += f;\n\t\t\tflow += f; a -= f;\n\t\t\tif (!a) break;\n\t\t}\n\treturn flow;\n}\n\nint dinic()\n{\n\tint res = 0;\n\twhile (bfs()) {\n\t\tmemset(vis + 1, 0, sizeof(bool) * t);\n\t\tmemcpy(cur + 1, h + 1, sizeof(int) * t);\n\t\tres += dfs(s, 1e9);\n\t}\n\treturn res;\n}\n\nint main()\n{\t\n\tn = gi();\n\tfor (int i = 1; i <= n; ++i) x[i] = gi();\n\tsort(x + 1, x + n + 1);\n\n\tpre();\n\n\tfor (int i = 1, j; i <= n; i = j + 1) {\n\t\tj = i;\n\t\twhile (x[j + 1] == x[j] + 1) ++j;\n\t\tp[++m] = x[i]; p[++m] = x[j] + 1;\n\t}\n\n\ts = m + 1; t = s + 1;\n\tint odd = 0;\n\tfor (int i = 1; i <= m; ++i)\n\t\tif (p[i] & 1) add(s, i, 1), ++odd;\n\t\telse add(i, t, 1);\n\tfor (int i = 1; i <= m; ++i)\n\t\tif (p[i] & 1)\n\t\t\tfor (int j = 1; j <= m; ++j)\n\t\t\t\tif ((~p[j] & 1) && !Vis[abs(p[i] - p[j])])\n\t\t\t\t\tadd(i, j, 1);\n\n\tint ans = dinic();\n\tprintf(\"%d\\n\", ans + ((odd - ans) / 2 + (m - odd - ans) / 2) * 2 + ((odd - ans) & 1) * 3);\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nlong long read()\n{\n\tchar ch=getchar();long long x=0,ff=1;\n\twhile(ch<'0'||ch>'9') {if(ch=='-') ff=-ff;ch=getchar();}\n\twhile(ch>='0'&&ch<='9') x=x*10+ch-'0',ch=getchar();\n\treturn x*ff;\n}\nvoid write(long long aa)\n{\n\tif(aa<0) putchar('-'),aa=-aa;\n\tif(aa>9) write(aa/10);\n\tputchar(aa%10+'0');\n\treturn;\n}\nlong long n,cnt,L,R,ans;\nlong long a[105],md[205];\nlong long l[205],r[205],no[205],yes[205],vis[205];\nlong long tot,head[205],nx[400005],to[400005];\nvoid add(long long aa,long long bb)\n{\n\ttot++;\n\tnx[tot]=head[aa];\n\tto[tot]=bb;\n\thead[aa]=tot;\n\treturn;\n}\nlong long ok(long long aa,long long bb)\n{\n\tlong long len=abs(md[aa]-md[bb]);if(len==1) return 0;\n\tfor(long long i=2;i*i<=len;++i) if(len%i==0) return 0;\n\treturn 1;\n}\nlong long dfs(long long rt)\n{\n\tfor(long long i=head[rt];i;i=nx[i])\n\t{\n\t\tlong long yy=to[i];\n\t\tif(vis[yy]) continue;vis[yy]=1;\n\t\tif(!no[yy]||dfs(no[yy])) {no[yy]=rt;yes[rt]=yy;return 1;}\n\t}\n\treturn 0;\n}\nint main()\n{\n\tn=read();a[0]=-10;\n\tfor(long long i=1;i<=n;++i) a[i]=read();\n\tfor(long long i=1;i<=n;++i) \n\t{\n\t\tif(a[i]!=a[i-1]+1) md[++cnt]=a[i]-1;\n\t\tif(a[i]+1!=a[i+1]) md[++cnt]=a[i];\n\t}\n\tfor(long long i=1;i<=cnt;++i) \n\tif(md[i]%2==0) l[++L]=i;\n\telse r[++R]=i;\n\tfor(long long i=1;i<=L;++i) for(long long j=1;j<=R;++j) \n\tif(ok(l[i],r[j])) add(l[i],r[j]);//,cout<<l[i]<<\" \"<<r[j]<<endl;\n\tfor(long long i=1;i<=L;++i) if(!yes[l[i]])\n\t{\n\t\tmemset(vis,0,sizeof(vis));\n\t\tif(dfs(l[i])) ans++;\n\t}\n\tlong long ls=L-ans,rs=R-ans;\n\tans+=ls/2*2;ans+=rs/2*2;\n\tif(ls%2==1) ans+=3;\n\twrite(ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define maxn 205\n#define maxp 10000007\nusing namespace std;\n\nint a[maxn],cnt,n;\nint pr[maxp],vis[maxp],cnt_pr;\nint usd[maxn],mat[maxn];\n\nint dfs(int u){\n\tfor(int i=1;i<=cnt;i++) if(vis[abs(a[u]-a[i])] == 0 && !usd[i]){\n\t\tusd[i] = 1;\n\t\tif(!mat[i] || dfs(mat[i])){\n\t\t\tmat[i] = u , mat[u] = i;\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nint main(){\n\tfor(int i=2;i<maxp;i++){\n\t\tif(!vis[i]) pr[cnt_pr++] = i;\n\t\tfor(int j=0;pr[j]*i<maxp;j++){\n\t\t\tvis[i*pr[j]] = 1;\n\t\t\tif(i % pr[j] == 0) break;\n\t\t}\n\t}\n\tvis[2] = vis[0] = vis[1] = 1;\n\tscanf(\"%d\",&n);\n\tint p = -10;\n\tfor(int i=1;i<=n;i++){int x;\n\t\tscanf(\"%d\",&x);\n\t\tif(x != p + 1){\n\t\t\tif(p>0)a[++cnt] = p + 1;\n\t\t\ta[++cnt] = x;\n\t\t}\n\t\tp = x;\n\t}\n\ta[++cnt] = p+1;\n\tint s[2] = {};\n\tfor(int i=1;i<=cnt;i++) assert(a[i] > 0) , s[a[i] % 2] ++;\n\tint ans = 0;\n\tfor(int i=1;i<=cnt;i++) if(a[i]%2 && !mat[i]) memset(usd,0,sizeof usd),ans += dfs(i);\n\tans += 2 * ((s[0] - ans) / 2 + (s[1] - ans) / 2);\n\tans += 3 * ((s[0] - ans) % 2 && (s[1] - ans) % 2);\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <algorithm>\n#include <queue>\n#include <vector>\n#include <stack>\n#include <cmath>\n#include <memory.h>\n#include <iomanip>\nusing namespace std;\n\n#define maxn 102\n#define FOR(i, l, r) for (int i=l; i<=r; ++i)\n#define FORD(i, r, l) for (int i=r; i>=l; --i)\n#define REP(i, r) for (int i=0; i<(int)r; ++i)\n#define REPD(i, r) for (int i=(int)r-1; i>=0; --i)\n#define fi first\n#define se second\n#define mk make_pair\n#define nil NULL\n#define y0 y902\n#define y1 y232\n#define x0 x92\n#define x1 x899\n#define next asdfa\n#define sz size\n#define Debug(X) {cerr << #X << \" = \" << X << '\\n';}\n#define PR(A, n) {cerr << #A << \" = \"; FOR(i, 1, n) cerr << A[i] << ' '; cerr << '\\n';}\n#define PR0(A, n) {cerr << #A << \" = \"; REP(i, n) cerr << A[i] << ' '; cerr << '\\n';}\ntypedef long long ll;\ntypedef double db;\ntypedef pair<db, db> dd;\ntypedef pair<int, int> ii;\ntypedef vector<int> vi;\nconst int inf = 1e9;\ntemplate<class T> int getbit(T x, int pos) {return (x>>(pos-1)) & 1;}\ntemplate<class T> void turn_on(T &x, int pos) {x = x | ((T)1<<(pos-1));}\ntemplate<class T> void turn_off(T &x, int pos) {x = x & ~((T)1<<(pos-1));}\ntemplate<class T> T sqr(T a) {return a*a;}\n\nint n, assigned[maxn], visited[maxn], t;\nvector<int> a[maxn], even, odd;\n\nbool visit(int u) {\n    if (visited[u]!=t) visited[u] = t;\n    else return false;\n    REP(i, a[u].sz()) {\n        int v = a[u][i];\n        if (!assigned[v] || visit(assigned[v])) {\n            assigned[v] = u;\n            return true;\n        }\n    }\n    return false;\n}\n\nint findMaximumMatching() {\n    int cnt = 0;\n    REP(i, even.sz()) {\n        ++t;\n        cnt += visit(i);\n    }\n    return cnt;\n}\n\nbool isPrime(int a) {       ///Function will return false if a=2\n    if (a<=2) return false;\n    FOR(i, 2, sqrt(a)) {\n        if (a%i==0) return false;\n    }\n    return true;\n}\n\nint main() {\n    //freopen(\"prflip.inp\", \"r\", stdin);\n    //freopen(\"\", \"w\", stdout);\n    //ios::sync_with_stdio(0); cin.tie(0);\n    scanf(\"%d\", &n);\n    int prev = -1;\n    FOR(i, 1, n) {\n        int x; scanf(\"%d\", &x);\n        if (x!=prev+1) {\n            if (prev!=-1 && (prev+1)%2==0) even.push_back(prev+1);\n            else if (prev!=-1) odd.push_back(prev+1);\n            if (x%2==0) even.push_back(x);\n            else odd.push_back(x);\n        }\n        prev = x;\n    }\n    if ((prev+1)%2==0) even.push_back(prev+1);\n    else odd.push_back(prev+1);\n    REP(i, even.sz()) REP(j, odd.sz()) {\n        if (isPrime(abs(even[i]-odd[j])))\n            a[i].push_back(j);\n    }\n    int k = findMaximumMatching(), res = inf;\n    FOR(i, 0, k) {\n        if (((int)even.sz()-k)%2==0) res = min(res, k+((int)even.sz()-k)+((int)odd.sz()-k));\n        else res = min(res, k+((int)even.sz()-1-k)+((int)odd.sz()-1-k)+3);\n    }\n    printf(\"%d\", res);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<cstring>\nusing namespace std;\nint n;\nint res;\nvector<int>v;\nint lst=-1;\nint match[210];\nint me,mo;\nint mx;\nbool f[10000010];\nvector<int>ok[210];\nbool vis[210];\nint prm[1000010];\nint sz;\nbool bp(int x)\n{\n\tfor(int i=0;i<ok[x].size();i++)\n\t{\n\t\tint y=ok[x][i];\n\t\tif(vis[y])continue;\n\t\tvis[y]=true;\n\t\tif(match[y]==-1 || bp(match[y]))\n\t\t{\n\t\t\tmatch[y]=x;\n\t\t\treturn true;\n\t\t}\n\t\tvis[y]=false;\n\t}\n\treturn false;\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint x;\n\t\tscanf(\"%d\",&x);\n\t\tif(x!=lst+1)\n\t\t{\n\t\t\tif(lst+1)v.push_back(lst+1);\n\t\t\tv.push_back(x);\n\t\t}\n\t\tlst=x;\n\t\tmx=lst+1;\n\t}\n\tv.push_back(lst+1);\n\tf[1]=true;\n\tfor(int i=2;i<=mx;i++)\n\t{\n\t\t/*if(!f[i])prm[++sz]=i;\n\t\tfor(int j=1;j<=sz && prm[j]*i<=mx;j++)\n\t\t{\n\t\t\tf[prm[j]*i]=true;\n\t\t\tif(i%prm[j]==0)break;\n\t\t}*/\n\t}\n\tint l=v.size();\n\tfor(int i=0;i<l;i++)\n\t{\n\t\tmatch[i]=-1;\n\t\tif(v[i]&1)mo++;else me++;\n\t\tfor(int j=i+1;j<l;j++)\n\t\t{\n\t\t\tif(v[j]-v[i]!=2 && !f[v[j]-v[i]])\n\t\t\t{\n\t\t\t\tok[i].push_back(j);\n\t\t\t\tok[j].push_back(i);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<l;i++)\n\t{\n\t\tmemset(vis,false,sizeof(vis));\n\t\tif(bp(i))res++;\n\t}\n\tres/=2;\n\tprintf(\"%d\",res+((me-res)/2+(mo-res)/2)*2+((me-res)%2)*3);\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cstdlib>\nusing namespace std;\n\n#define re_ return\n#define in_ inline\n#define op_ operator\n#define inc(l, i, r) for(i=l; i<r; ++i)\n#define st_ static\ntypedef long long ll;\n\nconst int mxn=1<<7;\n\nint n, m, a[mxn], b[mxn<<1], cnt[2], h[mxn<<1];\nstruct edge{int v, o;} e[mxn<<2];\n\nin_ ll dP(ll a, ll b, ll p)\n{\n    st_ ll r;\n    for(r=1; b; a=a*a%p, b>>=1)\n        b&1? r=r*a%p: 0;\n    re_ r;\n}\n\nin_ char chk(ll a, ll p)\n{\n    st_ ll s, r, i;\n    for(r=p-1, s=0; ~r&1; ++s, r/=2);\n    if(i=dP(a, r, p), i==1 || i==p-1) re_ 1;\n    for(;s--;)\n        if((i=i*i%p)==p-1) re_ 1;\n    re_ 0;\n}\n\nin_ char isP(int p)\n{\n    if(p==2) re_ 1;\n    if(p==1 || ~p&1) re_ 0;\n    st_  int i;\n    inc(0, i, 32)\n        if(!chk(rand()%(p-2)+1, p))\n            re_ 0;\n    re_ 1;\n}\n\nin_ void aE(int u, int v)\n{\n    st_ int tot;\n    e[++tot]=(edge){v, h[u]}, u[h]=tot;\n}\n\nchar Hun(int u)\n{\n    st_ int f[mxn<<1], vis[mxn<<1];\n    int i, v;\n    if(vis[u]) re_ 0; vis[u]=1;\n    for(i=u[h]; v=i[e].v; i=i[e].o)\n        if(!f[v] || Hun(f[v]))\n            re_ f[v]=u, vis[u]=0, 1;\n    re_ vis[u]=0;\n}\n\nint main()\n{\n    srand(998244353);\n    int i, j;\n    scanf(\"%d\", &n);\n    inc(0, i, n)\n        scanf(\"%d\", a+i);\n    inc(0, i, n)\n    {\n        if(!i || a[i]>a[i-1]+1)\n            b[++m]=a[i], ++cnt[a[i]&1];\n        if(i>n-2 || a[i]<a[i+1]-1)\n            b[++m]=a[i]+1, ++cnt[a[i]+1&1];\n    }\n    inc(1, i, m+1)\n        if(b[i]&1)\n            inc(1, j, m+1)\n                if(~b[j]&1 && isP(abs(b[i]-b[j])))\n                    aE(i, j);\n\n    j=0;\n    inc(1, i, m+1)\n        if(b[i]&1)\n            j+=Hun(i);\n\n    printf(\"%d\\n\", j+(cnt[0]-j&~1)+(cnt[1]-j&~1)+(cnt[0]-j&1? 3:0));\n//    for(;;) scanf(\"%d\", &i), printf(\"%d\\n\", isP(i));\n    re_ 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n#define N 205\n#define M 10000002\nbool cf[M+5],vis[M+5];\nint prime[M+5],tot;\nint cy[N],a[N],b[N],cntx,cnty;\nbool vs[N],c[N][N];\nvoid shai()\n{\n\tvis[1]=1;int i,j;\n\tfor(i=1;i<=M;i++){\n\t\tif(!vis[i])prime[++tot]=i;\n\t\tfor(j=1;j<=tot;j++){\n\t\t\tint tmp=i*prime[j];\n\t\t\tif(tmp>M)break;\n\t\t\tvis[tmp]=1;\n\t\t\tif(i%prime[j]==0)break;\n\t\t}\n\t\tif(cf[i]){\n\t\t\tif(i&1)a[++cntx]=i;\n\t\t\telse b[++cnty]=i;\n\t\t}\n\t}\n}\n//pay attention to vs\nbool dfs(int i)\n{\n\tfor(int j=1;j<=cnty;j++){\n\t\tif(c[i][j]&&vs[j]){\n\t\t\tvs[j]=1;\n\t\t\tif(!cy[j]||dfs(cy[j])){\n\t\t\t\tcy[j]=i;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nint maxmatch()\n{\n\tmemset(cy,0,sizeof(cy));\n\tint ret=0;\n\tfor(int i=1;i<=cntx;i++){\n\t\tmemset(vs,0,sizeof(vs));\n\t\tif(dfs(i))ret++;\n\t}\n\treturn ret;\n}\nint ab(int x){return x<0?-x:x;}\nint main()\n{\n\tint n,i,j,x,ans;\n\tscanf(\"%d\",&n);\n\tfor(i=1;i<=n;i++){\n\t\tscanf(\"%d\",&x);\n\t\tcf[x]^=1;cf[x+1]^=1;\n\t}\n\tshai();\n\tfor(i=1;i<=cntx;i++)\n\t\tfor(j=i+1;j<=cnty;j++)\n\t\t\tif(!vis[ab(b[j]-a[i])])c[i][j]=1;\n\tans=maxmatch();\n\tcntx-=ans;cnty-=ans;\n\tans+=(cntx/2)*2+(cnty/2)*2;\n\tif(cntx%2==1&&cnty%2==1)ans+=3;\n\tprintf(\"%d\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint x[105], n;\nvector<int> vt[2];\nbool notprime[100000015];\nbool X[10000015];\n\nvoid add(int t)\n{\n    if (X[t]) return;\n    X[t] = true;\n\n    bool a = binary_search(x, x + n, t);\n    bool b = binary_search(x, x + n, t - 1);\n    if (a != b) vt[t & 1].push_back(t);\n}\n\n// in: n, m, graph\n// out: match, matched\n// vertex cover: (reached[0][left_node] == 0) || (reached[1][right_node] == 1)\n// O(E*sqrt(V))\nstruct BipartiteMatching {\n    int n, m;\n    vector<vector<int>> graph;\n    vector<int> matched, match, edgeview, level;\n    vector<int> reached[2];\n    BipartiteMatching(int n, int m) : n(n), m(m), graph(n), matched(m, -1),\n    match(n, -1) {}\n    bool assignLevel() {\n        bool reachable = false;\n        level.assign(n, -1);\n        reached[0].assign(n, 0);\n        reached[1].assign(m, 0);\n        queue<int> q;\n        for (int i = 0; i < n; i++) {\n            if (match[i] == -1) {\n                level[i] = 0;\n                reached[0][i] = 1;\n                q.push(i);\n            }\n        }\n        while (!q.empty()) {\n            auto cur = q.front(); q.pop();\n            for (auto adj : graph[cur]) {\n                reached[1][adj] = 1;\n                auto next = matched[adj];\n                if (next == -1) {\n                    reachable = true;\n                }\n                else if (level[next] == -1) {\n                    level[next] = level[cur] + 1;\n                    reached[0][next] = 1;\n                    q.push(next);\n                }\n            }\n        }\n        return reachable;\n    }\n    int findpath(int nod) {\n        for (int &i = edgeview[nod]; i < graph[nod].size(); i++) {\n            int adj = graph[nod][i];\n            int next = matched[adj];\n            if (next >= 0 && level[next] != level[nod] + 1) continue;\n            if (next == -1 || findpath(next)) {\n                match[nod] = adj;\n                matched[adj] = nod;\n                return 1;\n            }\n        }\n        return 0;\n    }\n    int solve() {\n        int ans = 0;\n        while (assignLevel()) {\n            edgeview.assign(n, 0);\n            for (int i = 0; i < n; i++)\n                if (match[i] == -1)\n                    ans += findpath(i);\n        }\n        return ans;\n    }\n};\n\n\nint main()\n{\n    notprime[1] = true;\n    for (int i = 3; i <= 10000010; i += 2)\n    {\n        if (notprime[i]) continue;\n        for (int j = i * 3; j <= 10000010; j += i * 2)\n            notprime[j] = true;\n    }\n\n    scanf(\"%d\",&n);\n    for (int i = 0; i < n; i++) scanf(\"%d\", &x[i]);\n    sort(x, x + n);\n\n    for (int i = 0; i < n; i++)\n    {\n        add(x[i]);\n        add(x[i] + 1);\n    }\n\n    if (vt[0].empty() || vt[1].empty())\n    {\n        printf(\"%d\\n\", n);\n        return 0;\n    }\n\n    BipartiteMatching bm(vt[0].size(), vt[1].size());\n    for (int i = 0; i < vt[0].size(); i++)\n    {\n        for (int j = 0; j < vt[1].size(); j++)\n        {\n            if (notprime[abs(vt[0][i] - vt[1][j])] == false)\n                bm.graph[i].push_back(j);\n        }\n    }\n\n    int ret = bm.solve();\n\n    printf(\"%d\\n\", (int)(ret + (vt[0].size() - ret) / 2 * 2 + (vt[1].size() - ret) / 2 * 2 + (vt[0].size() - ret) % 2 * 3));\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\nconst int N=1e5;\nint ne[N],he[N],a[N],vis[N],g[N],t[N],tot,b1[N],x,y,b2[N];\nvoid ad(int x,int y)\n{\n\ttot++;\n\tne[tot]=he[x];\n\the[x]=tot;\n\tt[tot]=y;\n}\nvoid put(int v)\n{\n\tif (v&1) \n\t{\n\t\tx++;\n\t\tb1[x]=v;\n\t} else\n\t{\n\t\ty++;\n\t\tb2[x]=v;\n\t}\n}\nint pd(int x)\n{\n\tif (x%2==0) return 0;\n\tif (x==1) return 0;\n\tfor (int i=2;i<=sqrt(x);i++) if (x%i==0) return 0;\n\treturn 1;\n}\nint dfs(int x)\n{\n\tif (vis[x]==tot) return 0;\n\tvis[x]=tot;\n\tint i=he[x];\n\twhile (i)\n\t{\n\t\tif (g[t[i]]==0||dfs(g[t[i]])) \n\t\t{\n\t\t\tg[t[i]]=x;\n\t\t\treturn 1;\n\t\t}\n\t\ti=ne[i];\n\t}\n\treturn 0;\n}\nint main()\n{\n\tint n;\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<=n;i++) scanf(\"%d\",&a[i]);\n\tsort(a+1,a+n+1);\n    put(a[1]-1);\n\tfor (int i=2;i<=n;i++) \n\t{\n\t\tif (a[i]-a[i-1]!=1) \n\t\t{\n\t\t\tput(a[i-1]);\n\t\t\tput(a[i]-1);\n\t\t}\n\t}\n\tput(a[n]);\n\tfor (int i=1;i<=x;i++) for (int j=1;j<=y;j++) if (pd(abs(b2[j]-b1[i]))) ad(i,j+x);\n\tint ans=0;\n\tfor (int i=1;i<=x;i++) \n\t{\n\t\ttot++;\n\t\tans+=dfs(i);\n\t}\n\tx-=ans;\n\ty-=ans;\n\tif (x&1) \n\t{\n\t\tans+=3;\n\t\tx--;\n\t\ty--;\n\t}\n\tans+=x+y;\n\tprintf(\"%d\\n\",ans); \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nconst ull mod = 1e9 + 7;\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n\nstruct edge{\n    int to,cap,rev;\n};\n\nvector<edge> G[105];\nvector<int> check(105, 0);\n\nint dfs(int v, int t, int f){\n    if(v==t){return f;}\n    check[v]=1;\n    for(int i=0;i<G[v].size();i++){\n        edge &e = G[v][i];\n        if(check[e.to]==0 && e.cap > 0){\n            int ff =dfs(e.to,t,min(f,e.cap));\n            if(ff>0){\n                e.cap -= ff;\n                G[e.to][e.rev].cap += ff;\n                return ff;\n            }\n        }\n    }\n    return 0;\n}\n\nint maxflow(int s,int t){\n    int flow = 0;\n    while(1){\n        fill(check.begin(),check.end(),0);\n        int f = dfs(s,t,INT_MAX);\n        if(f==0){return flow;}\n        flow += f;\n    }\n}\n\nbool prime_check(ll X){\n    if(X<2) return false;\n    ll sqX = (int)sqrt(X)+1;\n    for(int i=2;i<sqX;i++){\n        if(X%i==0) return false;\n    }\n    return true;\n}\n\n\nint main(){\n    int N;\n    cin >> N;\n    ll x[N];\n    REP(i, N) cin >> x[i];\n    sort(x, x+N);\n    vector<ll> koma;\n    REP(i, N){\n        if(i==0||x[i]!=x[i-1]+1) koma.push_back(x[i]);\n        if(i==N-1||x[i+1]!=x[i]+1) koma.push_back(x[i]+1);\n    }\n    vector<ll> koma_even, koma_odd;\n    REP(i, koma.size()){\n        if(koma[i]%2==0){\n            koma_even.push_back(koma[i]);\n        }else{\n            koma_odd.push_back(koma[i]);\n        }\n    }\n    REP(i, koma_even.size()){\n        REP(j, koma_odd.size()){\n            ll dif = abs(koma_even[i]-koma_odd[j]);\n            if(prime_check(dif)){\n                int v1 = i;\n                int v2 = koma_even.size()+j;\n                G[v1].push_back((edge){v2, 1, G[v2].size()});\n                G[v2].push_back((edge){v1, 0, G[v1].size()-1});\n            }\n        }\n    }\n    REP(i, koma_even.size()){\n        int v1 = koma_even.size()+koma_odd.size();\n        int v2 = i;\n        G[v1].push_back((edge){v2, 1, G[v2].size()});\n        G[v2].push_back((edge){v1, 0, G[v1].size()-1});\n    }\n    REP(i, koma_odd.size()){\n        int v1 = koma_even.size()+i;\n        int v2 = koma_even.size()+koma_odd.size()+1;\n        G[v1].push_back((edge){v2, 1, G[v2].size()});\n        G[v2].push_back((edge){v1, 0, G[v1].size()-1});\n    }\n\n    int N1 = maxflow(koma_even.size()+koma_odd.size(), koma_even.size()+koma_odd.size()+1);\n    /*\n    printf(\"N1: %d\\n\", N1);\n    REP(i, koma.size()){\n        cout << koma[i] << endl;\n    }\n    */\n    int N2 = (koma_even.size()-N1)/2 + (koma_odd.size()-N1)/2;\n    int N3 = (koma_even.size()-N1)%2;\n    cout << N1+2*N2+3*N3 << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define x first\n#define y second\n#define mp make_pair\n#define all(a) a.begin(), a.end()\n#define pub push_back\n#define ll long long\n\t\t\t\t\t  \nusing namespace std;\n\nint n;\nint a[111];\nbool prime[10000007];\nvector<int> g[222];\nint dx[222], dy[222];\n\nbool wasIn(int x){\n\tfor (int i = 0; i < n; i++) if (a[i] == x) return 1;\n\treturn 0;\n}\n\nbool check(int x){\n\treturn wasIn(x) != wasIn(x + 1);\n}\n\nbool was[222];\nbool dfs(int v){\n\tif (was[v]) return 0;\n\twas[v] = 1;\n\tfor (int to : g[v]){\n\t\tif (dy[to] == -1){\n\t\t\tdx[v] = to;\n\t\t\tdy[to] = v;\n\t\t\treturn 1;\n\t\t}\n\t\tif (dfs(dy[to])){\n\t\t\tdx[v] = to;\n\t\t\tdy[to] = v;\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0; \n}\n\nint main(){\n\t//freopen(\"input.txt\", \"r\", stdin);\n\t//freopen(\"output.txt\", \"w\", stdout);\n\t//freopen(\"seating.in\", \"r\", stdin);\n\t//freopen(\"seating.out\", \"w\", stdout);\n\tfor (int i = 2; i < 10000007; i++){\n\t\tif (!prime[i]){\t\n\t\t\tfor (int j = 2 * i; j < 10000007; j += i) prime[j] = 1;\n\t\t}\n\t}\n\n\tprime[2] = 1;\n\tprime[1] = 1;\n\tprime[0] = 1;\n\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) cin >> a[i];\n\n\tvector<int> q, s, t;\n\tfor (int i = 0; i < n; i++){\n\t\tif (check(a[i] - 1)) q.pub(a[i] - 1);\n\t\tif (check(a[i])) q.pub(a[i]);\n\t}\n\n\tfor (int x : q) if (x % 2 == 0) s.pub(x); else t.pub(x);\n\n\tfor (int i = 0; i < s.size(); i++) for (int j = 0; j < t.size(); j++) if (!prime[abs(s[i] - t[j])]){\n\t\tg[i].pub(j);\n\t}\t\n\n\tfor (int i = 0; i < 222; i++) dx[i] = -1, dy[i] = -1;\n\n\tfor (int run = 1; run; ){\n\t\trun = 0;\n\t\tmemset(was, 0, sizeof(was));\n\t\tfor (int i = 0; i < s.size(); i++) if (dx[i] == -1 && dfs(i)) run = 1;\n\t}\n\n\tint dd = 0;\n\n\tfor (int i = 0; i < s.size(); i++) if (dx[i] != -1) dd++;\n\n\tint ans = (int)s.size() + (int)t.size() - dd;\n\n\tif (((int)s.size() - dd) % 2 == 1) ans++;\n\n\tcout << ans;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define maxn 205\n#define maxp 10000007\nusing namespace std;\n\nint a[maxn],cnt,n;\nint pr[maxp],vis[maxp],cnt_pr;\nint usd[maxn],mat[maxn];\n\nint dfs(int u){\n\tfor(int i=1;i<=cnt;i++) if(vis[abs(a[u]-a[i])] == 0){\n\t\tusd[i] = 1;\n\t\tif(!mat[i] || dfs(mat[i])){\n\t\t\tmat[i] = u , mat[u] = i;\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nint main(){\n\tfor(int i=2;i<maxp;i++){\n\t\tif(!vis[i]) pr[cnt_pr++] = i;\n\t\tfor(int j=0;pr[j]*i<maxp;j++){\n\t\t\tvis[i*pr[j]] = 1;\n\t\t\tif(i % pr[j] == 0) break;\n\t\t}\n\t}\n\tvis[2] = vis[0] = vis[1] = 1;\n\tscanf(\"%d\",&n);\n\tint p = -10;\n\tfor(int i=1;i<=n;i++){int x;\n\t\tscanf(\"%d\",&x);\n\t\tif(x != p + 1){\n\t\t\tif(p>0)a[++cnt] = p + 1;\n\t\t\ta[++cnt] = x;\n\t\t}\n\t\tp = x;\n\t}\n\ta[++cnt] = p+1;\n\tint s[2] = {};\n\tfor(int i=1;i<=cnt;i++) s[a[i] % 2] ++;\n\tint ans = 0;\n\tfor(int i=1;i<=cnt;i++) if(a[i]%2 && !mat[i]) memset(usd,0,sizeof usd),ans += dfs(i);\n\tans += 2 * ((s[0] - ans) / 2 + (s[1] - ans) / 2);\n\tans += 3 * ((s[0] - ans) % 2 && (s[1] - ans) % 2);\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<int , int> P2;\ntypedef pair<pair<int , int> , int> P3;\ntypedef pair<pair<int , int> , pair<int , int> > P4;\n#define PB(a) push_back(a)\n#define MP(a , b) make_pair((a) , (b))\n#define M3P(a , b , c) make_pair(make_pair((a) , (b)) , (c))\n#define M4P(a , b , c , d) make_pair(make_pair((a) , (b)) , make_pair((c) , (d)))\n#define repp(i,a,b) for(int i = (int)(a) ; i < (int)(b) ; ++i)\n#define repm(i,a,b) for(int i = (int)(a) ; i > (int)(b) ; --i)\n\nconst int EK_MAX = 210;\nconst int EK_EDGE_MAX = 10010;\n\ntemplate <class T> class EK{\n\tvector<int> V[EK_MAX];\n\tpair<int , int> edge[EK_EDGE_MAX];\n\tT f[EK_EDGE_MAX * 2];\n\tint d[EK_MAX];\n\tint n;\n\t\n\tint rev(int a){\n\t\treturn a / 2 * 2 + (a + 1) % 2;\n\t}\n\t\n\tvoid bfs(int s){\n\t\tfill(d , d + EK_MAX , -1);\n\t\td[s] = 0;\n\t\tqueue<int> Q;\n\t\tQ.push(s);\n\t\twhile(!Q.empty()){\n\t\t\tint x = Q.front(); Q.pop();\n\t\t\tfor(vector<int>::iterator it = V[x].begin() ; it != V[x].end() ; ++it){\n\t\t\t\tif(f[*it] == 0) continue;\n\t\t\t\tint y = (*it) % 2 == 1 ? edge[(*it)/2].first : edge[(*it)/2].second;\n\t\t\t\tif(d[y] >= 0) continue;\n\t\t\t\td[y] = d[x] + 1;\n\t\t\t\tQ.push(y);\n\t\t\t}\n\t\t}\n\t}\n\t\npublic:\n\t\n\tEK(){\n\t\tn = 0;\n\t\tfill(f , f + EK_EDGE_MAX * 2 , 0);\n\t}\n\t\n\tint put(int a , int b , T c){\n\t\tedge[n] = make_pair(a , b);\n\t\tV[a].push_back(2*n);\n\t\tV[b].push_back(2*n+1);\n\t\tf[2*n] = c;\n\t\tf[2*n+1] = 0;\n\t\treturn n++;\n\t}\n\t\n\tT ans(int s , int t){\n\t\twhile(1){\n\t\t\tbfs(s);\n\t\t\tif(d[t] < 0){\n\t\t\t\tT x = 0;\n\t\t\t\tfor(vector<int>::iterator it = V[s].begin() ; it != V[s].end() ; ++it){\n\t\t\t\t\tx += f[(*it)/2*2+1] * ((*it) % 2 == 0 ? 1 : -1);\n\t\t\t\t}\n\t\t\t\treturn x;\n\t\t\t}\n\t\t\tqueue<int> Q;\n\t\t\tT y = 123456789;\n\t\t\tfor(int i = t ; i != s ;){\n\t\t\t\tfor(vector<int>::iterator it = V[i].begin() ; it != V[i].end() ; ++it){\n\t\t\t\t\tif(f[rev(*it)] == 0) continue;\n\t\t\t\t\tint z = (*it) % 2 == 1 ? edge[(*it)/2].first : edge[(*it)/2].second;\n\t\t\t\t\tif(d[z] == d[i] - 1){\n\t\t\t\t\t\ti = z;\n\t\t\t\t\t\ty = min(y , f[rev(*it)]);\n\t\t\t\t\t\tQ.push(*it);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile(!Q.empty()){\n\t\t\t\tint x = Q.front(); Q.pop();\n\t\t\t\tf[rev(x)] -= y;\n\t\t\t\tf[x] += y;\n\t\t\t}\n\t\t}\n\t}\n};\n\nconst int MC = 10234567;\nint N;\nint x[111];\nbool p[MC];\nvector<int> V[2];\nEK<int> solve;\n\nint main(){\n\tscanf(\"%d%d\" , &N , x);\n\trepp(i,1,N){\n\t\tscanf(\"%d\" , x + i);\n\t\tif(x[i-1]+1 != x[i]){\n\t\t\tV[x[i-1]%2].PB(x[i-1]);\n\t\t\tV[(x[i]-1)%2].PB(x[i]-1);\n\t\t}\n\t}\n\tV[(x[0]-1)%2].PB(x[0]-1);\n\tV[x[N-1]%2].PB(x[N-1]);\n\tfill(p+3,p+MC,1);\n\tfor(int i = 4 ; i < MC ; i += 2) p[i] = 0;\n\tfor(int i = 3 ; i * i <= MC ; ++i) if(p[i]) for(int j = i*i ; j < MC ; j += i) p[j] = 0;\n\trepp(i,0,V[0].size()){\n\t\trepp(j,0,V[1].size()){\n\t\t\tif(p[abs(V[0][i]-V[1][j])]) solve.put(i,N+j,1);\n\t\t}\n\t\tsolve.put(N*2,i,1);\n\t}\n\trepp(j,0,V[1].size()) solve.put(N+j,N*2+1,1);\n\tint z = solve.ans(N*2,N*2+1);\n\tprintf(\"%d\\n\" , z + (V[0].size()-z)/2*2 + (V[1].size()-z)/2*2 + (V[0].size()-z)%2*3);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N;\nint X[101];\nint memo[101][101];\n\nbitset<1<<24> did,pr;\n\nint prime(int x) {\n\tif(x<=2) return 0;\n\tif(did[x]) return pr[x];\n\tdid[x]=1;\n\t\n\tfor(int a=2;a*a<=x;a++) if(x%a==0) return pr[x]=0;\n\treturn pr[x]=1;\n}\n\n\nint hoge(int L,int R) {\n\tif(R<=L) return 0;\n\tif(memo[L][R]>=0) return memo[L][R];\n\t\n\tint ret=101010;\n\tfor(int x=L+1;x<R;x++) ret=min(ret,hoge(L,x)+hoge(x,R));\n\t\n\tint ok=1,step=0;\n\tfor(int i=L;i<R-1;i++) if(X[i+1]-X[i]!=1) {\n\t\tif(prime(X[i+1]-X[i]-1)) step++;\n\t\telse ok=0;\n\t}\n\t\n\tif(ok==1) {\n\t\tint len=X[R-1]-X[L]+1;\n\t\tif(len%2==0) ret=min(ret,2+step);\n\t\telse ret=min(ret,3+step);\n\t}\n\t\n\tif(R-L>=2) {\n\t\tif(X[L]+1==X[R-1]) {\n\t\t\tret=2;\n\t\t}\n\t\telse if((X[R-1]-X[L])%2==1) {\n\t\t\tret=min(ret,4+hoge(L+1,R-1));\n\t\t}\n\t\telse {\n\t\t\tint len=X[R-1]-X[L]+1;\n\t\t\tif(prime(len)&&prime(len-2)) {\n\t\t\t\tret=min(ret,2+hoge(L+1,R-1));\n\t\t\t}\n\t\t}\n\t}\n\t\n\t\n\treturn memo[L][R]=ret;\n\t\n\t\n}\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N;\n\tFOR(i,N) cin>>X[i];\n\t\n\tMINUS(memo);\n\tcout<<hoge(0,N)<<endl;\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n';\n\tFOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tsolve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cstdlib>\nusing namespace std;\n\n#define re_ return\n#define in_ inline\n#define op_ operator\n#define inc(l, i, r) for(i=l; i<r; ++i)\n#define st_ static\ntypedef long long ll;\n\nconst int mxn=1<<7;\n\nint n, m, a[mxn], b[mxn<<1], cnt[2], h[mxn<<1];\nstruct edge{int v, o;} e[mxn<<2];\n\nin_ ll dP(ll a, ll b, ll p)\n{\n    st_ ll r;\n    for(r=1; b; a=a*a%p, b>>=1)\n        b&1? r=r*a%p: 0;\n    re_ r;\n}\n\nin_ char chk(ll a, ll p)\n{\n    st_ ll s, r, i;\n    for(r=p-1, s=0; ~r&1; ++s, r/=2);\n    if(i=dP(a, r, p), i==1 || i==p-1) re_ 1;\n    for(;s--;)\n        if((i=i*i%p)==p-1) re_ 1;\n    re_ 0;\n}\n\nin_ char isP(int p)\n{\n    if(p==2) re_ 1;\n    if(p==1 || ~p&1) re_ 0;\n    st_  int i;\n    inc(0, i, 32)\n        if(!chk(rand()%(p-2)+1, p))\n            re_ 0;\n    re_ 1;\n}\n\nin_ void aE(int u, int v)\n{\n    st_ int tot;\n    e[++tot]=(edge){v, h[u]}, u[h]=tot;\n}\n\nchar vis[mxn];\nchar Hun(int u)\n{\n    st_ int f[mxn<<1];\n    int i, v;\n    for(i=u[h]; v=i[e].v; i=i[e].o)\n        if(!vis[v])\n            if(vis[v]=1, !f[v] || Hun(f[v]))\n            re_ f[v]=u, 1;\n    re_ 0;\n}\n\nint main()\n{\n    srand(998244353);\n    int i, j;\n    scanf(\"%d\", &n);\n    inc(0, i, n)\n        scanf(\"%d\", a+i);\n    inc(0, i, n)\n    {\n        if(!i || a[i]>a[i-1]+1)\n            b[++m]=a[i], ++cnt[a[i]&1];\n        if(i>n-2 || a[i]<a[i+1]-1)\n            b[++m]=a[i]+1, ++cnt[a[i]+1&1];\n    }\n    inc(1, i, m+1)\n        if(b[i]&1)\n            inc(1, j, m+1)\n                if(~b[j]&1 && isP(abs(b[i]-b[j])))\n                    aE(i, j);\n\n    j=0;\n    inc(1, i, m+1)\n        if(b[i]&1)\n            memset(vis, 0, sizeof(vis)),\n                j+=Hun(i);\n\n    printf(\"%d\\n\", cnt[0]+cnt[1]-j+(cnt[0]-j&1));\n//    printf(\"%d\\n\", m);\n//    for(;;) scanf(\"%d\", &i), printf(\"%d\\n\", isP(i));\n    re_ 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//#define _GLIBCXX_DEBUG\n\n#include<bits/stdc++.h>\nusing namespace std;\n\n#define endl '\\n'\n#define lfs cout<<fixed<<setprecision(10)\n#define ALL(a)  (a).begin(),(a).end()\n#define ALLR(a)  (a).rbegin(),(a).rend()\n#define spa << \" \" <<\n#define fi first\n#define se second\n#define MP make_pair\n#define MT make_tuple\n#define PB push_back\n#define EB emplace_back\n#define rep(i,n,m) for(ll i = (n); i < (ll)(m); i++)\n#define rrep(i,n,m) for(ll i = (ll)(m) - 1; i >= (ll)(n); i--)\nusing ll = long long;\nusing ld = long double;\nconst ll MOD1 = 1e9+7;\nconst ll MOD9 = 998244353;\nconst ll INF = 1e18;\nusing P = pair<ll, ll>;\ntemplate<typename T1, typename T2>bool chmin(T1 &a,T2 b){if(a>b){a=b;return true;}else return false;}\ntemplate<typename T1, typename T2>bool chmax(T1 &a,T2 b){if(a<b){a=b;return true;}else return false;}\nll median(ll a,ll b, ll c){return a+b+c-max({a,b,c})-min({a,b,c});}\nvoid ans1(bool x){if(x) cout<<\"Yes\"<<endl;else cout<<\"No\"<<endl;}\nvoid ans2(bool x){if(x) cout<<\"YES\"<<endl;else cout<<\"NO\"<<endl;}\nvoid ans3(bool x){if(x) cout<<\"Yay!\"<<endl;else cout<<\":(\"<<endl;}\ntemplate<typename T1,typename T2>void ans(bool x,T1 y,T2 z){if(x)cout<<y<<endl;else cout<<z<<endl;}  \ntemplate<typename T>void debug(vector<vector<T>>&v,ll h,ll w){for(ll i=0;i<h;i++){cout<<v[i][0];for(ll j=1;j<w;j++)cout spa v[i][j];cout<<endl;}};\nvoid debug(vector<string>&v,ll h,ll w){for(ll i=0;i<h;i++){for(ll j=0;j<w;j++)cout<<v[i][j];cout<<endl;}};\ntemplate<typename T>void debug(vector<T>&v,ll n){if(n!=0)cout<<v[0];for(ll i=1;i<n;i++)cout spa v[i];cout<<endl;};\ntemplate<typename T>vector<vector<T>>vec(ll x, ll y, T w){vector<vector<T>>v(x,vector<T>(y,w));return v;}\nll gcd(ll x,ll y){ll r;while(y!=0&&(r=x%y)!=0){x=y;y=r;}return y==0?x:y;}\nvector<ll>dx={1,-1,0,0,1,1,-1,-1};vector<ll>dy={0,0,1,-1,1,-1,1,-1};\ntemplate<typename T>vector<T> make_v(size_t a,T b){return vector<T>(a,b);}\ntemplate<typename... Ts>auto make_v(size_t a,Ts... ts){return vector<decltype(make_v(ts...))>(a,make_v(ts...));}\ntemplate<typename T1, typename T2>ostream &operator<<(ostream &os, const pair<T1, T2>&p){return os << p.first << \" \" << p.second;}\ntemplate<typename T>ostream &operator<<(ostream &os, const vector<T> &v){for(auto &z:v)os << z << \" \";cout<<\"|\"; return os;}\n//mt19937 mt(chrono::steady_clock::now().time_since_epoch().count());\nvector< bool > prime_table(ll n) {\n  vector< bool > prime(n + 1, true);\n  if(n >= 0) prime[0] = false;\n  if(n >= 1) prime[1] = false;\n  for(ll i = 2; i * i <= n; i++) {\n    if(!prime[i]) continue;\n    for(ll j = i + i; j <= n; j += i) {\n      prime[j] = false;\n    }\n  }\n  return prime;\n}\ntemplate< typename flow_t, typename cost_t >\nstruct PrimalDual {\n  const cost_t INF;\n\n  struct edge {\n    ll to;\n    flow_t cap;\n    cost_t cost;\n    ll rev;\n    bool isrev;\n  };\n  vector< vector< edge > > graph;\n  vector< cost_t > potential, min_cost;\n  vector< ll > prevv, preve;\n\n  PrimalDual(ll V) : graph(V), INF(numeric_limits< cost_t >::max()) {}\n\n  void add_edge(ll from, ll to, flow_t cap, cost_t cost) {\n    graph[from].emplace_back((edge) {to, cap, cost, (ll) graph[to].size(), false});\n    graph[to].emplace_back((edge) {from, 0, -cost, (ll) graph[from].size() - 1, true});\n  }\n\n  cost_t min_cost_flow(ll s, ll t, flow_t f) {\n    ll V = (ll) graph.size();\n    cost_t ret = 0;\n    using Pi = pair< cost_t, ll >;\n    priority_queue< Pi, vector< Pi >, greater< Pi > > que;\n    potential.assign(V, 0);\n    preve.assign(V, -1);\n    prevv.assign(V, -1);\n\n    while(f > 0) {\n      min_cost.assign(V, INF);\n      que.emplace(0, s);\n      min_cost[s] = 0;\n      while(!que.empty()) {\n        Pi p = que.top();\n        que.pop();\n        if(min_cost[p.second] < p.first) continue;\n        for(ll i = 0; i < graph[p.second].size(); i++) {\n          edge &e = graph[p.second][i];\n          cost_t nextCost = min_cost[p.second] + e.cost + potential[p.second] - potential[e.to];\n          if(e.cap > 0 && min_cost[e.to] > nextCost) {\n            min_cost[e.to] = nextCost;\n            prevv[e.to] = p.second, preve[e.to] = i;\n            que.emplace(min_cost[e.to], e.to);\n          }\n        }\n      }\n      if(min_cost[t] == INF) return -1;\n      for(ll v = 0; v < V; v++) potential[v] += min_cost[v];\n      flow_t addflow = f;\n      for(ll v = t; v != s; v = prevv[v]) {\n        addflow = min(addflow, graph[prevv[v]][preve[v]].cap);\n      }\n      f -= addflow;\n      ret += addflow * potential[t];\n      for(ll v = t; v != s; v = prevv[v]) {\n        edge &e = graph[prevv[v]][preve[v]];\n        e.cap -= addflow;\n        graph[v][e.rev].cap += addflow;\n      }\n    }\n    return ret;\n  }\n\n  void output() {\n    for(ll i = 0; i < graph.size(); i++) {\n      for(auto &e : graph[i]) {\n        if(e.isrev) continue;\n        auto &rev_e = graph[e.to][e.rev];\n        cout << i << \"->\" << e.to << \" (flow: \" << rev_e.cap << \"/\" << rev_e.cap + e.cap << \")\" << endl;\n      }\n    }\n  }\n  using R=vector<pair<pair<ll,ll>,pair<flow_t,cost_t>>>;\n  R restore() {\n    R ret;\n    for(ll i = 0; i < graph.size(); i++) {\n      for(auto &e : graph[i]) {\n        if(e.isrev) continue;\n        auto &rev_e = graph[e.to][e.rev];\n        ret.emplace_back(make_pair(i,e.to),make_pair(rev_e.cap,e.cost));\n      }\n    }\n    return ret;\n  }\n};\nstruct HopcroftKarp {\n  vector< vector< int > > graph;\n  vector< int > dist, match;\n  vector< bool > used, vv;\n\n  HopcroftKarp(int n, int m) : graph(n), match(m, -1), used(n) {}\n\n  void add_edge(int u, int v) {\n    graph[u].push_back(v);\n  }\n\n  void bfs() {\n    dist.assign(graph.size(), -1);\n    queue< int > que;\n    for(int i = 0; i < graph.size(); i++) {\n      if(!used[i]) {\n        que.emplace(i);\n        dist[i] = 0;\n      }\n    }\n\n    while(!que.empty()) {\n      int a = que.front();\n      que.pop();\n      for(auto &b : graph[a]) {\n        int c = match[b];\n        if(c >= 0 && dist[c] == -1) {\n          dist[c] = dist[a] + 1;\n          que.emplace(c);\n        }\n      }\n    }\n  }\n\n  bool dfs(int a) {\n    vv[a] = true;\n    for(auto &b : graph[a]) {\n      int c = match[b];\n      if(c < 0 || (!vv[c] && dist[c] == dist[a] + 1 && dfs(c))) {\n        match[b] = a;\n        used[a] = true;\n        return (true);\n      }\n    }\n    return (false);\n  }\n\n  int bipartite_matching() {\n    int ret = 0;\n    while(true) {\n      bfs();\n      vv.assign(graph.size(), false);\n      int flow = 0;\n      for(int i = 0; i < graph.size(); i++) {\n        if(!used[i] && dfs(i)) ++flow;\n      }\n      if(flow == 0) return (ret);\n      ret += flow;\n    }\n  }\n\n  void output() {\n    for(int i = 0; i < match.size(); i++) {\n      if(~match[i]) {\n        cout << match[i] << \"-\" << i << endl;\n      }\n    }\n  }\n};\nint main(){\n  cin.tie(nullptr);\n  ios_base::sync_with_stdio(false);\n  ll res=0,buf=0;\n  bool judge = true;\n  ll lim=1e7+30;\n  //ll lim=1e3;cout<<\"naosu\"<<endl;\n  auto pr=prime_table(lim);\n  /*vector<ll>p;\n  rep(i,0,lim)if(pr[i])p.PB(i);\n  ll sz=p.size();*/\n  ll n;cin>>n;\n  vector<ll>x(n);\n  rep(i,0,n)cin>>x[i];\n  vector<vector<ll>>y(2);\n  rep(i,0,n){\n    if(i==0||x[i]-1>x[i-1])y[x[i]&1].PB(x[i]);\n    if(i==n-1||x[i]+1<x[i+1])y[~x[i]&1].PB(x[i]+1);\n  }\n  pr[2]=false;\n  vector<ll>sz(2);\n  rep(i,0,2)sz[i]=y[i].size();\n  HopcroftKarp fl(sz[0],sz[1]);\n  rep(i,0,sz[0])rep(j,0,sz[1]){\n    if(i==j)continue;\n    ll dif=abs(y[0][i]-y[1][j]);\n    ll cost=0;\n    if(pr[dif])fl.add_edge(i,j);\n    //cout<<dif spa cost spa y[i] spa y[j]<<endl;\n    //fl.add_edge(i,j+sz[0],1,cost);\n  }\n  /*ll S=sz[0]+sz[1],T=sz[0]+sz[1]+1;\n  rep(i,0,sz[0]){\n    fl.add_edge(S,i,1,0);\n    fl.add_edge(i+sz[0],T,1,0);\n  }*/\n  //cout<<sz<<endl;\n  //debug(y,sz);\n  ll lk=fl.bipartite_matching();\n  //assert(~lk&1);\n  ll r1=sz[0]-lk,r2=sz[1]-lk;\n  ll add=0;\n  if(r1&1)add+=3;\n  //cout<<lk spa r1 spa r2<<endl;\n  cout<<lk+r1/2*2+r2/2*2+add<<endl;\n  //map<P,ll>mp;\n  /*auto r=fl.restore();\n  for(auto z:r){\n    if(z.se.fi==1&&z.fi.fi<sz[0]&&z.fi.se<2*sz[0]){\n      cout<<y[0][z.fi.fi] spa y[1][z.fi.se-sz[0]]<<endl;\n      //assert(y[z.fi.fi]!=y[z.fi.se-sz]);\n      //mp[minmax(y[z.fi.fi],y[z.fi.se-sz])]++;\n    }\n  }*/\n  //for(auto z:mp)assert(~z.se&1);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <cmath>\n#include <iomanip>\n#include <cassert>\n#include <bitset>\nusing namespace std;\n\ntypedef pair<int, int> P;\n#define _rep(_1, _2, _3, _4, name, ...) name\n#define rep2(i, n) rep3(i, 0, n)\n#define rep3(i, a, b) rep4(i, a, b, 1)\n#define rep4(i, a, b, c) for (int i = int(a); i < int(b); i += int(c))\n#define rep(...) _rep(__VA_ARGS__, rep4, rep3, rep2, _)(__VA_ARGS__)\n#define all(c) (c).begin(), (c).end()\n#define uniq(c) c.erase(unique(all(c)), (c).end())\n#define _1 first\n#define _2 second\n#define pb push_back\n#define INF 1145141919\n#define MOD 1000000007\n\nusing i8 = signed char;\nusing i64 = long long;\n\ntemplate <typename WeightType>\nclass MaximumWeightedMatching {\n  /*\n  Maximum Weighted Matching in General Graphs\n  - O(n^3) time\n  - O(n + m) space\n  \n  Note: each vertex is 1-indexed.\n  */\npublic:\n  using weight_t = WeightType;\n  using weight_sum_t = long long;\n  struct Edge { int from, to; weight_t weight; };\n\nprivate:\n  enum TreeLabelNumber { INNER = -1, UNUSED = 0, OUTER = 1 };\n  enum LabelNumber { SEPARATED = -2, DEFAULT = -1 };\n  enum EdgeNumber { UNDEFINED = 1 << 30 };\n\n  //static constexpr weight_t INF = weight_t(1) << (sizeof(weight_t) * 8 - 2);\n\n  struct Node { int next, from, to; };\n  struct Label { int from, to; };\n  struct LinkedList { int eid, next; };\n\n  class Queue {\n  public:\n    Queue() {}\n    Queue(int N) : que(N), qh(0), qt(0) {}\n    void clear() { qh = qt = 0; }\n    int* data() { return que.data(); }\n    bool empty() const { return qh == qt; }\n    int dequeue() { return que[qh++]; }\n    void enqueue(int u) { que[qt++] = u; }\n    int operator [] (int i) const { return que[i]; }\n    int size() const { return qt; }\n\n    vector<int> que;\n    int qh, qt;\n  };\n\npublic:\n  MaximumWeightedMatching(int N, const vector<Edge>& raw_edges) \n      : N(N), B((N - 1) / 2), size(N + B + 1) {\n\n    offsets.assign(N + 2, 0);\n    for (auto& e : raw_edges) {\n      offsets[e.from + 1]++;\n      offsets[e.to + 1]++;\n    }\n    rep(i, 1, N + 1) offsets[i] += offsets[i - 1];\n    edges.resize(raw_edges.size() * 2);\n    rep(i, raw_edges.size()) {\n      auto& e = raw_edges[i];\n      edges[offsets[e.from]++] = {e.from, e.to, 2 * e.weight};\n      edges[offsets[e.to]++] = {e.to, e.from, 2 * e.weight};\n    }\n    rep(i, N + 1) offsets[N + 1 - i] = offsets[N - i];\n    offsets[0] = 0;\n  }\n\n  weight_sum_t maximum_weighted_matching() {\n    initialize();\n    set_potential();\n    rep(u, 1, N + 1) if (!mate[u]) {\n      for (int s = 0; !augmented(u, s); s = adjust_dual_solutions());\n      fix_blossom_bases();\n      clear_label();\n    }\n    weight_sum_t ret = 0;\n    rep(u, 1, N + 1) if (mate[u] > u) {\n      weight_t max_w = 0;\n      rep(eid, offsets[u], offsets[u + 1]) if (edges[eid].to == mate[u]) {\n        max_w = max(max_w, edges[eid].weight);\n      }\n      ret += max_w;\n    }\n    return ret >> 1;\n  }\n\nprivate:\n  inline int encode(int e) const {\n    return e + size + 1; // should be >= 3\n  }\n\n  inline weight_t reduced_cost(int u, int v, const Edge& e) const {\n    return potential[u] + potential[v] - e.weight;\n  }\n\n  inline weight_t reduced_cost(int eid) const {\n    return reduced_cost(edges[eid].from, edges[eid].to, edges[eid]);\n  }\n\n  void rematch(int v, int w) {\n    auto t = mate[v]; mate[v] = w;\n    if (mate[t] != v) return;\n    if (label[v].to == 0) {\n      mate[t] = label[v].from;\n      rematch(mate[t], t);\n    } else {\n      int x = label[v].from, y = label[v].to;\n      rematch(x, y); rematch(y, x);\n    }\n  }\n\n  Label search_blossom_edge(int bid) const {\n    int b = base[bid], bv = b;\n    for (; node[bv].next != b; bv = node[node[bv].next].next);\n    return {node[bv].from, node[bv].to};\n  }\n\n  void label_blossom(int bid, int m, Label l) {\n    label[bid] = {l.from, (l.to == surface[l.to]) ? 0 : l.to};\n    if (bid <= N) return;\n    int b = base[bid]; label_blossom(b, mate[bid] = m, l);\n    l = search_blossom_edge(bid);\n    for (int bv = b, bw; node[bv].next != b; bv = node[bw].next) {\n      label_blossom(bw = node[bv].next, 0, l);\n      label_blossom(node[bw].next, node[bw].from, {node[bv].from, node[bv].to});\n    }\n  }\n\n  int find_mate(int bid) {\n    return bid <= N ? mate[bid] : mate[bid] = find_mate(base[bid]);\n  }\n\n  void push_inner_blossom_rec(int bid, bool push=true) {\n    tree_label[bid] = (bid <= N) ? INNER : UNUSED;\n    if (bid > N) {\n      int v = base[bid], u = v;\n      do { push_inner_blossom_rec(v, push); } while ( (v = node[v].next) != u);\n    } else if (push) inner_vertices[inner_vertices_size++] = bid;\n  }\n\n  void push_inner_blossom(int bid) {\n    if (tree_label[bid] != UNUSED) return;\n    bool push = label[bid].from != SEPARATED;\n    if (bid > N) {\n      if (push) inner_blossoms[inner_blossom_size++] = bid; \n      push_inner_blossom_rec(bid, push);\n    } else if (push) inner_vertices[inner_vertices_size++] = bid;\n    tree_label[bid] = INNER;\n  }\n\n  void push_outer_blossom_rec(int bid) {\n    tree_label[bid] = (bid <= N) ? OUTER : UNUSED;\n    if (bid > N) {\n      int v = base[bid], u = v;\n      do { push_outer_blossom_rec(v); } while ( (v = node[v].next) != u );\n    } else outer_vertices.enqueue(bid);\n  }\n\n  void push_outer_blossom(int bid, bool push) {\n    push_outer_blossom_rec(bid);\n    if (bid <= N) return;\n    if (push) outer_blossoms[outer_blossom_size++] = bid, tree_label[bid] = OUTER;\n    else tree_label[bid] = UNUSED;\n  }\n\n  inline void merge_edge(int x, int bx, int eid) {\n    auto& e = edges[eid];\n    int y = e.to, by = surface[y];\n    if (tree_label[by] != OUTER || bx == by) return;\n    auto r_cost = reduced_cost(x, y, e);\n    if (r_cost < best_cost[by].first) {\n      if (best_cost[by].first == INF) merged_edges[merged_edge_size++] = by;\n      best_cost[by] = {r_cost, eid};\n    }\n  }\n\n  inline void merge_vertex(int x, int bx) {\n    rep(eid, offsets[x], offsets[x + 1]) merge_edge(x, bx, eid);\n    best_edge[x] = UNDEFINED;\n  }\n\n  void clear_best_edges(int b) {\n    if (b > N) {\n      int v = b = base[b];\n      do { clear_best_edges(v); } while ( (v = node[v].next) != b );\n    } else best_edge[b] = UNDEFINED;\n  }\n\n  void merge_outer(int b, int bid) {\n    if (b > N) {\n      for (int head = blist_head[b]; head >= 0; head = bnode[head].next) {\n        int eid = bnode[head].eid;\n        merge_edge(edges[eid].from, bid, eid);\n        next_bnode.push_back(head);\n      }\n      blist_head[b] = -1;\n      clear_best_edges(b);\n    } else merge_vertex(b, bid);\n  }\n\n  void merge_inner(int b, int bid) {\n    if (b > N) {\n      int v = b = base[b];\n      do { merge_inner(v, bid); } while ((v = node[v].next) != b);\n    } else merge_vertex(b, bid);\n  }\n\n  void build_linked_list(int bid) {\n    if (bid <= N) return;\n    int last = -1;\n    for (; merged_edge_size > 0; ) {\n      int nid = next_bnode.back(); next_bnode.pop_back();\n      int by = merged_edges[--merged_edge_size], eid = best_cost[by].second;\n      int x = edges[eid].from, y = edges[eid].to;\n      bnode[nid] = {eid, last};\n      if (tree_label[y] == OUTER) update_best_edge(y, by, best_cost[by].first, eid);\n      if (best_edge[x] == UNDEFINED || best_cost[by].first < reduced_cost(best_edge[x])) {\n        best_edge[x] = eid;\n      }\n      best_cost[by] = {INF, UNDEFINED};\n      last = nid;\n    }\n    blist_head[bid] = last;\n  }\n\n  void merge_best_edges(int bid, int inner_count) {\n    rep(i, inner_count) {\n      int bv = outer_blossoms[outer_blossom_size + i];\n      if (bv >= 0) merge_outer(bv, bid), merge_inner(node[bv].next, bid);\n      else merge_inner(~bv, bid), merge_outer(node[~bv].next, bid);\n    }\n    merge_outer(base[bid], bid);\n    build_linked_list(bid);\n  }\n\n  void contract(int x, int y, int eid) {\n    int s = surface[x], t = surface[y];\n    if (s == t) return;\n    auto h = label[surface[mate[s]]].from = label[surface[mate[t]]].from = -encode(eid);\n\n    int lca = -1;\n    for (; ; label[surface[mate[s]]].from = h) {\n      if (mate[t] != 0) swap(s, t);\n      s = lca = surface[label[s].from];\n      if (label[surface[mate[s]]].from == h) break;\n    }\n\n    int inner_count = 0;\n    for (int dir = 0; dir < 2; ++dir) {\n      int v = (dir == 0) ? x : y;\n      while (1) {\n        int bv = surface[v], mv = mate[bv], bmv = surface[mv];\n        if (bv == lca) break;\n        label[mv] = label[bmv] = {x, y};\n        auto n = node[bmv];\n        if (!dir) {\n          node[bv] = {bmv, mate[mv], mv};\n          node[bmv].next = surface[n.to];\n        } else {\n          node[surface[n.to]] = {bmv, n.to, n.from};\n          node[bmv] = {bv, mv, mate[mv]}; \n        }\n        push_outer_blossom(bmv, false);\n        v = label[bv].from;\n\n        // Caution: used as temporary array\n        outer_blossoms[outer_blossom_size + (inner_count++)] = !dir ? bv : ~bmv;\n      }\n    }\n    node[surface[y]] = {surface[x], y, x};\n\n    int bid = next_bid.back(); next_bid.pop_back();\n    base[bid] = lca, label[bid].from = label[lca].from, mate[bid] = mate[lca];\n\n    tree_label[bid] = OUTER;\n    set_surface(bid, bid);\n    merge_best_edges(bid, inner_count);\n\n    outer_blossoms[outer_blossom_size++] = bid;\n  }\n\n  inline void update_best_edge(int y, int by, weight_t r_cost, int eid) {\n    if (tree_label[by] != OUTER && best_edge[y] == UNDEFINED) {\n      neighbors[neighbor_size++] = y;\n    }\n    if (best_edge[y] == UNDEFINED || r_cost < reduced_cost(best_edge[y])) {\n      best_edge[y] = eid;\n    }\n  }\n\n  void build_edge_list(int b) {\n    if (b <= N) return;\n    merge_inner(b, b);\n    build_linked_list(b);\n  }\n\n  bool augmented(int root, int s) {\n    if (s == 0) {\n      int br = surface[root];\n      push_outer_blossom(br, true);\n      label_blossom(br, 0, {0, 0});\n      build_edge_list(br);\n    } \n    for (; !outer_vertices.empty() || s > 0; s = 0) {\n      auto x = (s > 0) ? s : outer_vertices.dequeue();\n      if (potential[x] == 0) {\n        if (root != x) rematch(x, 0);\n        return true;\n      }\n      rep(eid, offsets[x], offsets[x + 1]) {\n        int bx = surface[x], y = edges[eid].to, by = surface[y];\n        if (bx == by) continue;\n        auto r_cost = reduced_cost(x, y, edges[eid]);\n        if (r_cost > 0 || tree_label[by] != OUTER) {\n          update_best_edge(y, by, r_cost, eid);\n          if (r_cost > 0) continue;\n        }\n        if (label[by].from >= 0) {\n          contract(x, y, eid);\n          continue;\n        } \n        if (tree_label[by] == UNUSED) {\n          push_inner_blossom(by);\n          if (by != y) label_blossom(by, find_mate(by), {DEFAULT, 0});\n        }\n        int z = mate[by];\n        if (z == 0 && by != surface[root]) {\n          rematch(x, y); rematch(y, x);\n          return true;\n        }\n        int bz = surface[z];\n        if (label[bz].from < 0) {\n          node[by] = {-1, y, x};\n          push_outer_blossom(bz, true);\n          label_blossom(bz, mate[z], {x, y});\n          build_edge_list(bz);\n        }\n      }\n    }\n    return false;\n  }\n\n  void set_surface(int b, int bid) {\n    for (int v = base[b]; surface[v] != bid; v = node[v].next) {\n      if (v > N) tree_label[v] = UNUSED, set_surface(v, bid);\n      surface[v] = bid;\n    }\n  }\n  \n  void reset_surface(int b, int bid) {\n    surface[b] = bid;\n    if (b <= N) return;\n    for (b = base[b]; surface[b] != bid; b = node[b].next) reset_surface(b, bid);\n  }\n\n  void separate_blossom(int bid, bool push_blossom=true) {\n    tree_label[bid] = UNUSED, label[bid].from = SEPARATED;\n    if (bid <= N) return;\n    if (push_blossom) inner_blossoms[inner_blossom_size++] = bid;\n    for (int b = base[bid]; label[b].from != SEPARATED; b = node[b].next) {\n      separate_blossom(b, false);\n    }\n  }\n\n  void reverse_blossom(int b) {\n    int v = b, fr = node[b].from, to = node[b].to;\n    for (int nv = node[v].next; nv != b; ) {\n      int nnext = node[nv].next, nfr = node[nv].from, nto = node[nv].to;\n      node[nv].next = v, node[nv].from = to, node[nv].to = fr;\n      fr = nfr, to = nto, v = nv, nv = nnext;\n    }\n    node[b].next = v, node[b].from = to, node[b].to = fr;\n  }\n\n  void expand_blossom(int bid) {\n    next_bid.push_back(bid); tree_label[bid] = UNUSED;\n    for (int b = base[bid]; surface[b] == bid; b = node[b].next) reset_surface(b, b);\n    int old_base = base[bid], target = surface[node[bid].from]; \n    if (mate[node[target].from] == node[target].to) reverse_blossom(old_base);\n    for (int b = target; node[b].next != old_base; ) {\n      separate_blossom(b = node[b].next); separate_blossom(b = node[b].next);\n    }\n    node[target] = node[bid];\n    for (int b = old_base; ; b = node[b].next) {\n      label[b].from = DEFAULT, tree_label[b] = INNER; \n      if (b > N) inner_blossoms[inner_blossom_size++] = b;\n      int m = find_mate(b), bm = surface[m];\n      if (b != old_base) mate[bm] = mate[m];\n      label[m] = label[bm] = {node[b].to, node[b].from};\n      if (b == target) break;\n      push_outer_blossom(b = node[b].next, true);\n      build_edge_list(b);\n    }\n    base[bid] = bid, surface[bid] = bid;\n  }\n\n  void update_potential(int* vs, int s, weight_t delta, int label) {\n    rep(i, s) {\n      int x = vs[i];\n      if (tree_label[x] != label) continue;\n      potential[x] += delta;\n    }\n  }\n\n  int adjust_dual_solutions() {\n    pair<weight_t, int> delta1(INF, 0), delta2(INF, 0), delta3(INF, 0), delta4(INF, 0);\n    rep(i, outer_vertices.size()) {\n      int y = outer_vertices[i], eid = best_edge[y];\n      delta1 = min(delta1, {potential[y], y});\n      if (eid != UNDEFINED) {\n        delta3 = min(delta3, {reduced_cost(eid) >> 1, y});\n      }\n    }\n    rep(i, neighbor_size) {\n      int y = neighbors[i];\n      if (tree_label[y] == UNUSED) {\n        int eid = best_edge[y], x = edges[eid].from;\n        delta2 = min(delta2, {reduced_cost(x, y, edges[eid]), x});\n      }\n    }\n    rep(i, inner_blossom_size) if (tree_label[inner_blossoms[i]] == INNER) {\n      int b = inner_blossoms[i];\n      delta4 = min(delta4, {potential[b] >> 1, b});\n    }\n    auto delta = min(min(delta1, delta2), min(delta3, delta4));\n    auto d = delta.first;\n    update_potential(outer_vertices.data(), outer_vertices.size(), -1 * d, OUTER);\n    update_potential(inner_vertices.data(), inner_vertices_size,    1 * d, INNER);\n    update_potential(outer_blossoms.data(), outer_blossom_size,     2 * d, OUTER);\n    update_potential(inner_blossoms.data(), inner_blossom_size,    -2 * d, INNER);\n    if (delta4.first == d) {\n      expand_blossom(delta4.second);\n      return -1;\n    } else {\n      return delta.second;\n    }\n  }\n\n  void fix_blossom_bases() {\n    int remain = size - next_bid.size() - (N + 1);\n    for (int bid = N + 1; bid < size && remain > 0; ++bid) if (base[bid] != bid) {\n      int b = base[bid];\n      for (int skipped = 0; skipped < 2;) {\n        b = node[b].next;\n        if (mate[node[b].from] == node[b].to) skipped = 0;\n        else skipped++;\n      }\n      base[bid] = b;\n      --remain;\n    }\n  }\n\n  void free_edge_list(int x) {\n    for (int head = blist_head[x]; head >= 0; head = bnode[head].next) {\n      next_bnode.push_back(head);\n    }\n    blist_head[x] = -1;\n  }\n\n  void clear_vertices(int* vs, int size) {\n    rep(i, size) {\n      int v = vs[i]; \n      label[v] = {DEFAULT, 0}; tree_label[v] = UNUSED; best_edge[v] = UNDEFINED;\n    }\n  }\n\n  void clear_label() {\n    label[0] = {DEFAULT, 0};\n    clear_vertices(outer_vertices.data(), outer_vertices.size()); outer_vertices.clear();\n    clear_vertices(inner_vertices.data(), inner_vertices_size); inner_vertices_size = 0;\n    clear_vertices(outer_blossoms.data(), outer_blossom_size);\n    rep(i, outer_blossom_size) if (blist_head[outer_blossoms[i]] >= 0) free_edge_list(outer_blossoms[i]);\n    outer_blossom_size = 0;\n    clear_vertices(inner_blossoms.data(), inner_blossom_size); inner_blossom_size = 0;\n    rep(i, neighbor_size) best_edge[neighbors[i]] = UNDEFINED;\n    neighbor_size = 0;\n  }\n\n  void set_potential() {\n    potential.resize(size);\n    rep(u, 1, N + 1) {\n      weight_t max_w = 0;\n      rep(eid, offsets[u], offsets[u + 1]) max_w = max(max_w, edges[eid].weight);\n      potential[u] = max_w >> 1;\n    }\n  }\n\n  void initialize() {\n    mate.assign(size, 0);\n    label.assign(size, {-1, 0});\n\n    surface.resize(size); rep(i, size) surface[i] = i;\n    base.resize(size); rep(i, size) base[i] = i;\n    node.resize(size); rep(i, size) node[i] = {i, i, i};\n\n    outer_vertices = Queue(N);\n    inner_vertices.resize(N + 1); inner_vertices_size = 0;\n    outer_blossoms.resize(B); outer_blossom_size = 0;\n    inner_blossoms.resize(B); inner_blossom_size = 0;\n\n    tree_label.assign(size, UNUSED);\n\n    next_bid.resize(B);\n    rep(i, B) next_bid[i] = size - 1 - i;\n\n    merged_edges.resize(N + 1); merged_edge_size = 0;\n    best_cost.assign(size, {INF, UNDEFINED});\n\n    neighbors.resize(N + 1); neighbor_size = 0;\n    best_edge.assign(size, UNDEFINED);\n\n    blist_head.assign(size, -1);\n    next_bnode.resize(edges.size());\n    rep(i, edges.size()) next_bnode[i] = edges.size() - 1 - i;\n\n    bnode.resize(edges.size());\n  }\n\nprivate:\n  int N, B, size;\n  vector<Edge> edges;\n  vector<int> offsets;\n\n  vector<Label> label;\n  vector<int> mate, surface, base;\n  vector<Node> node;\n  vector<weight_t> potential;\n\n  vector<int> next_bid;\n\n  vector<i8> tree_label;\n\n  Queue outer_vertices;\n  vector<int> inner_vertices; int inner_vertices_size;\n  vector<int> outer_blossoms; int outer_blossom_size;\n  vector<int> inner_blossoms; int inner_blossom_size;\n\n  vector<int> merged_edges; int merged_edge_size;\n  vector< pair<weight_t, int> > best_cost;\n  vector<int> neighbors; int neighbor_size;\n  vector<int> best_edge;\n\n  vector<int> blist_head;\n  vector<LinkedList> bnode;\n  vector<int> next_bnode;\n};\n\n\n//#define INF 1145141919\nint N, V;\nint A[300];\nmap<int, int> mp;\n\nbool is_prime(int x) {\n  if (x == 1) return false;\n  for (int i=2; i<=sqrt(x); i++) {\n    if (x % i == 0) return false;\n  }\n  return true;\n}\n\nint f(int x) {\n  if (x % 2 == 0) return 2;\n  if (is_prime(x)) return 1;\n  return 3;\n}\nsigned main() {\n  ios::sync_with_stdio(false); cin.tie(0);\n  cin >> N;\n  rep(i, N) {\n    int x;\n    cin >> x;\n    mp[x]^=1;\n    mp[x+1]^=1;\n  }\n  for (auto p : mp) {\n    if (p._2 == 0) continue;\n    A[V++] = p._1;\n  }\n  sort(A, A+V);\n  assert(V <= 200);\n\n  using Edge = MaximumWeightedMatching<int>::Edge;\n  vector<Edge> edges;\n  int C = 4;\n  rep(i, V) {\n    rep(j, i) {\n      int cost = C-f(abs(A[i]-A[j]));\n      edges.pb({ i+1, j+1, cost });\n      edges.pb({ j+1, i+1, cost });\n    }\n  }\n  auto x = MaximumWeightedMatching<int>(V, edges);\n  cout << C*(V/2) - x.maximum_weighted_matching() << \"\\n\";\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fi first\n#define se second\nusing namespace std;\n\nconst int maxn = 200, maxm = 1e7;\nint n, m, k, p[maxm / 10 + 3], a[maxn + 3], mat[maxn + 3];\nmap<int, bool> M;\nbool b[maxm + 3], vis[maxn + 3];\nvector<int> G[maxn + 3];\n\nvoid prework(int n) {\n\tfor (int i = 2; i <= n; i++) {\n\t\tif (!b[i]) p[++k] = i;\n\t\tfor (int j = 1; j <= k && i * p[j] <= n; j++) {\n\t\t\tb[i * p[j]] = true;\n\t\t\tif (i % p[j] == 0) break;\n\t\t}\n\t}\n\tb[1] = b[2] = true;\n}\n\nbool dfs(int u) {\n\tfor (int i = 0, v; i < G[u].size(); i++) {\n\t\tif (!vis[v = G[u][i]]) {\n\t\t\tvis[v] = true;\n\t\t\tif (!mat[v] || dfs(mat[v])) {\n\t\t\t\tmat[v] = u, mat[u] = v;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\nint main() {\n\tprework(maxm);\n\tscanf(\"%d\", &n);\n\tfor (int i = 1, x; i <= n; i++) {\n\t\tscanf(\"%d\", &x);\n\t\tM[x] ^= 1, M[x + 1] ^= 1;\n\t}\n\tfor (map<int, bool>::iterator it = M.begin(); it != M.end(); it++) {\n\t\tif (it -> se) a[++m] = it -> fi;\n\t}\n\tfor (int i = 1; i <= m; i++) {\n\t\tfor (int j = i + 1; j <= m; j++) {\n\t\t\tif (!b[a[j] - a[i]]) {\n\t\t\t\tG[i].push_back(j), G[j].push_back(i);\n\t\t\t}\n\t\t}\n\t}\n\tint ans = 0;\n\tfor (int i = 1; i <= m; i++) if (a[i] % 2 && !mat[i]) {\n\t\tfill(vis + 1, vis + m + 1, false), ans += dfs(i);\n\t}\n\tint odd = 0, even = 0;\n\tfor (int i = 1; i <= m; i++) if (!mat[i]) {\n\t\tif (a[i] % 2) {\n\t\t\tif (odd) odd = 0, ans += 2;\n\t\t\telse odd = 1;\n\t\t} else {\n\t\t\tif (even) even = 0, ans += 2;\n\t\t\telse even = 1;\n\t\t}\n\t}\n\tif (odd && even) ans += 3;\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n\n#define ri register int\n#define ssd 10000010\n#define sid 205\n\nint n, N = 1e7;\nint pr[ssd / 10], tot;\nint nj, no, js[sid], os[sid];\nbool nop[ssd], e[ssd];\n\nint tim, vis[sid], mat[sid];\nbool ex[sid][sid];\n\ninline void Init() {\n    for(ri i = 2; i <= N + 1; i ++) {\n        if(!nop[i]) pr[++ tot] = i;\n        for(ri j = 1; j <= tot; j ++) {\n            int nx = i * pr[j]; if(nx > N + 1) break;\n            nop[nx] = 1; if(i % pr[j] == 0) break;\n        }\n    }\n    nop[1] = nop[2] = 1;\n}\n\ninline int dfs(int o) {\n    for(int i = 1; i <= no; i ++)\n    if(vis[i] != tim && ex[o][i]) {\n        vis[i] = tim;\n        if(!mat[i] || dfs(mat[i])) { mat[i] = o; return 1; }\n    } return 0;\n}\n\nint main() {\n    Init();\n    cin >> n;\n    for(ri i = 1; i <= n; i ++) { int x; cin >> x; e[x] = 1; }\n    \n    for(ri i = 1; i <= N + 1; i ++)\n    if(e[i] != e[i - 1])\n    if(i & 1) js[++ nj] = i;\n    else os[++ no] = i;\n\n    for(ri i = 1; i <= nj; i ++)\n    for(ri j = 1; j <= no; j ++)\n    if(!nop[abs(js[i] - os[j])]) ex[i][j] = 1;\n\n    int num = 0, ans = 0;\n\n    for(ri i = 1; i <= nj; i ++)\n    if(!mat[i]) ++ tim, num += dfs(i);\n\n    nj -= num; no -= num;\n    ans = num + nj / 2 * 2 + no / 2 * 2 + (nj & 1) * 3;\n    printf(\"%d\\n\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define LL long long\n#define uLL unsigned long long\n#define db double\n\nusing namespace std;\nconst int N=1e7+10,M=200+10,inf=1<<30;\nint rd()\n{\n\tint x=0,w=1;char ch=0;\n\twhile(ch<'0'||ch>'9'){if(ch=='-') w=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=(x<<3)+(x<<1)+(ch^48);ch=getchar();}\n\treturn x*w;\n}\nint to[M*M],nt[M*M],c[M*M],hd[M],tot=1;\nvoid add(int x,int y,int z)\n{\n\t++tot,to[tot]=y,nt[tot]=hd[x],c[tot]=z,hd[x]=tot;\n\t++tot,to[tot]=x,nt[tot]=hd[y],c[tot]=0,hd[y]=tot;\n}\nint ps,pt,nhd[M],lv[M];\nbool bfs()\n{\n\tqueue<int> q; \n\tfor(int i=1;i<=pt;++i) lv[i]=0;\n\tlv[ps]=1,q.push(ps);\n\twhile(!q.empty())\n\t{\n\t\tint x=q.front();\n\t\tq.pop();\n\t\tfor(int i=hd[x];i;i=nt[i])\n\t\t{\n\t\t\tint y=to[i];\n\t\t\tif(c[i]>0&&!lv[y])\n\t\t\t\tlv[y]=lv[x]+1,q.push(y);\n\t\t}\n\t}\n\treturn lv[pt];\n}\nint dfs(int x,int fw)\n{\n\tif(x==pt) return fw;\n\tint an=0;\n\tfor(int &i=nhd[x];i;i=nt[i])\n\t{\n\t\tint y=to[i];\n\t\tif(c[i]>0&&lv[y]==lv[x]+1)\n\t\t{\n\t\t\tint dt=dfs(y,min(fw,c[i]));\n\t\t\tc[i]-=dt,c[i^1]+=dt;\n\t\t\tfw-=dt,an+=dt;\n\t\t\tif(!fw) break;\n\t\t}\n\t}\n\treturn an;\n}\nint dinic()\n{\n\tint an=0,dt;\n\twhile(bfs())\n\t{\n\t\tmemcpy(nhd,hd,sizeof(int)*(pt+1));\n\t\twhile((dt=dfs(ps,inf))) an+=dt;\n\t}\n\treturn an;\n}\nint prm[M*M],tt;\nbool v[N];\nint n,a[M],id[M],b[N],ans;\n\nint main()\n{\n\tv[1]=1;\n\tfor(int i=2;i<=10000001;++i)\n\t{\n\t\tif(!v[i]) prm[++tt]=i;\n\t\tfor(int j=1;i*prm[j]<=10000001;++j)\n\t\t{\n\t\t\tv[i*prm[j]]=1;\n\t\t    if(i%prm[j]==0) break;\n\t\t}\n\t}\n\tv[0]=v[2]=1;\n\tn=rd();\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tint x=rd();\n\t\tb[x]^=1,b[x+1]^=1;\n\t}\n\tn=0;\n\tfor(int i=1;i<=N-5;++i)\n\t\tif(b[i]) a[++n]=i;\n\tps=0,pt=n+1;\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tif(a[i]&1)\n\t\t{\n\t\t\tadd(ps,i,1),id[i]=tot;\n\t\t\tfor(int j=1;j<=n;++j)\n\t\t\t\tif(!v[abs(a[i]-a[j])])\n\t\t\t\t\tadd(i,j,1);\n\t\t}\n\t\telse add(i,pt,1),id[i]=tot;\n\t}\n\tans=dinic();\n\tfor(int i=1;i<=n;++i)\n\t\tif(c[id[i]]) a[i]=N+1;\n\tsort(a+1,a+n+1);\n\twhile(a[n]>N) --n;\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tif(a[i]>N) continue;\n\t\tfor(int j=1;j<=n;++j)\n\t\t\tif(i!=j&&a[j]<N&&!((a[i]-a[j])&1))\n\t\t\t{++ans,++ans,a[i]=a[j]=N+1;break;}\n\t}\n\tsort(a+1,a+n+1);\n\twhile(a[n]>N) --n;\n\tans+=n/2*3;\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nconst int N=1e7+10;\nusing namespace std;\ninline int gi(){\n  char ch=getchar();int x=0,q=0;\n  while(ch<'0' || ch>'9') ch=='-'?q=1:0,ch=getchar();\n  while(ch>='0' && ch<='9') x=x*10+ch-'0',ch=getchar();\n  return q?(-x):x;\n}\nint mark[N],pri[N],tot,P=1e7+1,n,m,g[N];\nint c[105][105],bl[105],vis[105],a[105],b[105];\nvoid pre(){\n  for (int i=2,s; i<=P; ++i){\n    if (!mark[i]) pri[++tot]=i;\n    for (int j=1; j<=tot&&(s=i*pri[j])<=P; ++j){\n      mark[s]=1;\n      if (i%pri[j]==0) break;\n    }\n  }\n  return;\n}\nint dfs(int x){\n  for (int i=1; i<=m; ++i)\n    if (c[x][i]&&!vis[i]){\n      vis[i]=1;\n      if (!bl[i]||dfs(bl[i]))\n\treturn bl[i]=x;\n    }\n  return 0;\n}\nint main(){\n  int p=gi(),s;\n  pre();\n  for (int i=1; i<=p; ++i)\n    g[gi()]=1;\n  for (int i=P; i>=1; --i)\n    g[i]^=g[i-1];\n  for (int i=1; i<=P; ++i)\n    if (g[i]){\n      if (i&1) a[++n]=i;\n      else b[++m]=i;\n    }\n  for (int i=1; i<=n; ++i)\n    for (int j=1; j<=m; ++j){\n      s=abs(a[i]-b[j]);\n      if (s!=1&&!mark[s])\n\tc[i][j]=1;\n    }\n  int ans=0;\n  for (int i=1; i<=n; ++i){\n    memset(vis,0,sizeof(vis));\n    if (dfs(i)) ++ans;\n  }\n  cout<<ans+(n-ans)/2*2+(m-ans)/2*2+(((n-ans)&1)||((m-ans)&1))*3;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <time.h>\n#include <random>\n#include <fstream>\n#include <set>\n\nusing namespace std;\n\nconst int N = 1e7 + 2;\n\nint n;\n\nint c[N];\nint p[N];\nint a[200];\n\nvector<int> graph[400];\n\nint paired[400];\nint marked[400];\n\nint TryKuhn(int v)\n{\n    if (marked[v]) return 0;\n    marked[v] = 1;\n    for (auto u : graph[v])\n    {\n        if (paired[u] == -1 || TryKuhn(paired[u]))\n        {\n            paired[u] = v;\n            return 1;\n        }\n    }\n    return 0;\n}\n\nint G()\n{\n    int res = 0;\n    fill(paired, paired + 400, -1);\n    for (int i = 0; i < n; i++)\n    {\n        fill(marked, marked + 400, 0);\n        if (TryKuhn(i))\n            res++;\n    }\n    return res;\n}\n\nsigned main()\n{\n    srand(time(NULL));\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    for (int i = 2; i < N; i++)\n    {\n        if (p[i] == 0)\n        {\n            for (int j = 2; j * i < N; j++) p[i * j] = 1;\n        }\n    }\n    p[2] = 1;\n    p[1] = 1;\n    cin >> n;\n    for (int i = 0; i < n; i++)\n    {\n        int x;\n        cin >> x;\n        c[x] = 1;\n    }\n    n = 0;\n    for (int i = 0; i + 1 < N; i++)\n    {\n        if (c[i] != c[i + 1])\n        {\n            a[n] = i;\n            n++;\n        }\n    }\n    for (int i = 0; i < n; i++)\n    {\n        for (int j = 0; j < n; j++)\n        {\n            if (a[i] % 2 == 0 && a[j] % 2 == 1)\n            {\n                if (1 || !p[abs(a[i] - a[j])])\n                {\n                    graph[i].push_back(200 + j);\n                    graph[200 + j].push_back(i);\n                }\n            }\n        }\n    }\n    /*for (int i = 0; i < 400; i++)\n    {\n        for (auto u : graph[i])\n        {\n            cout << i << \" \" << u << endl;\n        }\n    }*/\n    int c0 = 0, c1 = 0, c2 = G();\n    for (int i = 0; i < n; i++)\n    {\n        if (a[i] % 2 == 0) c0++;\n        else c1++;\n    }\n    int ans = c2 + ((c0 - c2) / 2) * 2 + ((c1 - c2) / 2) * 2 + ((c1 - c0) % 2) * 3;\n    cout << ans;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 233;\nconst int INF = 1e9;\n\nstruct Edge {\n    int to, rev, cap;\n};\n\nint nv, sv, tv;\nvector<Edge> g[N];\nint dist[N], ptr[N];\n\nvoid add_edge(int a, int b, int c) {\n    g[a].push_back(Edge{b, int(g[b].size()), c});\n    g[b].push_back(Edge{a, int(g[a].size()) - 1, 0});\n    assert(max(a, b) < nv);\n}\n\nbool augment() {\n    fill_n(dist, nv, -1);\n    dist[sv] = 0;\n\n    vector<int> que;\n    que.push_back(sv);\n    for (int v: que) {\n        for (auto e: g[v]) {\n            if (dist[e.to] != -1 || e.cap == 0) {\n                continue;\n            }\n            dist[e.to] = dist[v] + 1;\n            if (e.to == tv) {\n                return true;\n            }\n            que.push_back(e.to);\n        }\n    }\n\n    return false;\n}\n\nint dfs(int v, int r) {\n    for (int& i = ptr[v]; i < int(g[v].size()); i++) {\n        auto& e = g[v][i];\n        if (dist[e.to] <= dist[v] || e.cap == 0) {\n            continue;\n        }\n        int d = dfs(e.to, min(r, e.cap));\n        if (d == 0) {\n            continue;\n        }\n        e.cap -= d;\n        g[e.to][e.rev].cap += d;\n        return d;\n    }\n    return 0;\n}\n\nint exec() {\n    int res = 0;\n    while (augment()) {\n        fill_n(ptr, nv, 0);\n        while (true) {\n            int d = dfs(sv, INF);\n            if (d == 0) {\n                break;\n            }\n            res += d;\n        }\n    }\n    return res;\n}\n\nconst int M = int(1e7 + 10);\n\nint n;\nbool isp[M];\n\nvoid precalc() {\n    fill(isp + 2, isp + M, true);\n    for (int i = 2; i * i < M; i++) {\n        if (!isp[i]) {\n            continue;\n        }\n        for (int j = i * i; j < M; j += i) {\n            isp[j] = false;\n        }\n    }\n}\n\nint main() {\n    precalc();\n\n    scanf(\"%d\", &n);\n\n    set<int> a;\n    auto add = [&](int x) {\n        auto it = a.find(x);\n        if (it != a.end()) {\n            a.erase(it);\n        } else {\n            a.insert(x);\n        }\n    };\n\n    for (int i = 0; i < n; i++) {\n        int x;\n        scanf(\"%d\", &x);\n        add(x);\n        add(x + 1);\n    }\n\n    vector<vector<int>> v(2);\n    for (int x: a) {\n        v[x % 2].push_back(x);\n    }\n    int v0s = v[0].size(), v1s = v[1].size();\n\n    sv = 0;\n    tv = 1;\n    nv = v0s + v1s + 2;\n    for (int i = 0; i < v0s; i++) {\n        add_edge(sv, 2 + i, 1);\n    }\n    for (int i = 0; i < v1s; i++) {\n        add_edge(2 + v0s + i, tv, 1);\n    }\n    for (int i = 0; i < v0s; i++) {\n        for (int j = 0; j < v1s; j++) {\n            int d = abs(v[0][i] - v[1][j]);\n            if (d > 2 && isp[d]) {\n                add_edge(2 + i, 2 + v0s + j, 1);\n            }\n        }\n    }\n\n    int used = exec();\n    int ans = used;\n    ans += 2 * ((v0s - used) / 2);\n    ans += 2 * ((v1s - used) / 2);\n    if ((v0s - used) % 2 == 1) {\n        ans += 3;\n    }\n\n    printf(\"%d\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#define STOPIT\n#include <bits/stdc++.h>\n#define loop(n) for (lint ngtkana_is_a_genius = 0; ngtkana_is_a_genius < lint(n); ngtkana_is_a_genius++)\n#define rep(i, begin, end) for (lint i = lint(begin); (i) < lint(end); i++)\n#define all(v) v.begin(), v.end()\n#define rand(l, r) std::uniform_int_distribution<>(l, r)(mt)\nusing lint = long long;\nauto mt = std::mt19937_64(std::random_device{}());\nauto cmn = [](auto& a, auto b){ if (a > b) {a = b; return true;} return false; };\nauto cmx = [](auto& a, auto b){ if (a < b) {a = b; return true;} return false; };\nvoid debug_impl() { std::cerr << std::endl; }\ntemplate <typename Head, typename... Tail>\nvoid debug_impl(Head head, Tail... tail) { std::cerr << \" \" << head; debug_impl(tail...); }\n#ifndef STOPIT\n#define debug(...)\\\n\tdo {\\\n\t\tstd::cerr << std::boolalpha << \"[\" << #__VA_ARGS__ << \"]:\";\\\n\t\tdebug_impl(__VA_ARGS__);\\\n\t\tstd::cerr << std::noboolalpha;\\\n\t} while (false)\n#else\n#define debug(...) {}\n#endif\n\nclass bipartite_matching {\n\t\tint L, R;\n\t\tstd::vector<std::vector<int>> graph;\n\t\tstd::vector<int> match, level;\n\n\t\tbool bfs() {\n\t\t\tstd::fill(level.begin(), level.end(), -1);\n\t\t\tstd::queue<int> que;\n\t\t\tfor (auto i = 0; i < L; i++) {\n\t\t\t\tif (match.at(i) < 0) {\n\t\t\t\t\tlevel.at(i) = 0;\n\t\t\t\t\tque.emplace(i);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbool ret = false;\n\t\t\twhile (!que.empty()) {\n\t\t\t\tauto crr = que.front(); que.pop();\n\t\t\t\tfor (auto nxt : graph.at(crr)) {\n\t\t\t\t\tif (level.at(nxt) != -1) continue;\n\t\t\t\t\tlevel.at(nxt) = level.at(crr) + 1;\n\t\t\t\t\tauto w = match.at(nxt);\n\t\t\t\t\tif (w == -1)\n\t\t\t\t\t\t{ ret = true; }\n\t\t\t\t\telse if (level.at(w) == -1) {\n\t\t\t\t\t\tlevel.at(w) = level.at(crr) + 1;\n\t\t\t\t\t\tque.emplace(w);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\n\t\tbool dfs(int crr) {\n\t\t\tfor (auto nxt : graph.at(crr)) {\n\t\t\t\tassert(level.at(nxt) <= level.at(crr) + 1);\n\t\t\t\tif (level.at(nxt) < level.at(crr) + 1) continue;\n\t\t\t\tlevel.at(nxt) = -1;\n\t\t\t\tauto w = match.at(nxt);\n\t\t\t\tif (w == -1 || dfs(w)) {\n\t\t\t\t\tmatch.at(nxt) = crr;\n\t\t\t\t\tmatch.at(crr) = nxt;\n\t\t\t\t\tlevel.at(crr) = -1;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tlevel.at(crr) = -1;\n\t\t\treturn false;\n\t\t}\n\n\tpublic:\n\t\tbipartite_matching()=default;\n\t\tbipartite_matching(int L, int R):\n\t\t\tL(L), R(R), graph(L + R), match(L + R, -1), level(L + R)\n\t\t\t{}\n\n\t\tvoid insert(int u, int v) {\n\t\t\tv += L;\n\t\t\tgraph.at(u).emplace_back(v);\n\t\t\tgraph.at(v).emplace_back(u);\n\t\t}\n\n\n\t\tint build () {\n\t\t\tauto ret = 0;\n\t\t\twhile (bfs()) {\n\t\t\t\tfor (int i = 0; i < L; i++) {\n\t\t\t\t\tif (match.at(i) == -1 && dfs(i))\n\t\t\t\t\t\t{ ret++; }\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\n\t\tauto collect() const {return match;}\n\n\t\tauto count() const {\n\t\t\tauto k = L + R - std::count(match.begin(), match.end(), -1);\n\t\t\tassert(k % 2 == 0);\n\t\t\treturn k / 2;\n\t\t}\n};\n\ntemplate < typename Container, typename Value = typename Container::value_type, std::enable_if_t<!std::is_same< Container, std::string >::value, std::nullptr_t> = nullptr>\nstd::istream& operator>> (std::istream& is, Container& v)\n\t{ for (auto & x : v) { is >> x; } return is; }\n\ntemplate < typename Container, typename Value = typename Container::value_type, std::enable_if_t<!std::is_same< Container, std::string >::value, std::nullptr_t> = nullptr >\nstd::ostream& operator<< (std::ostream& os, Container const& v) {\n os << \"{\";\n\tfor (auto it = v.begin(); it != v.end(); it++)\n\t\t{os << (it != v.begin() ? \",\" : \"\") << *it;}\n\treturn os << \"}\";\n}\n\ntemplate < class Container, class Value = typename Container::value_type >\nauto run_length(Container const& v) {\n\tauto n = (int)v.size();\n\tif (n == 0)\n\t\t{ return std::vector< std::pair< Value, int > >{}; }\n\tauto pos = std::vector< int >{};\n\tfor (auto i = 1; i < n; i++) {\n\t\tif (v.at(i - 1) != v.at(i))\n\t\t\t{ pos.emplace_back(i); }\n\t}\n\tpos.emplace_back(n);\n\tauto m = (int)pos.size();\n\tauto len = std::vector< int >(m);\n\tstd::adjacent_difference(pos.begin(), pos.end(), len.begin());\n\tauto ret = std::vector< std::pair< Value, int > >(m);\n\tfor (auto i = 0; i != m; i++)\n\t\t{ ret.at(i) = {v.at(pos.at(i) - 1), len.at(i)}; }\n\treturn ret;\n}\n\ntemplate < std::size_t I, typename Container,\n\ttypename Value = typename std::tuple_element_t< I, typename Container::value_type >>\ninline auto project(Container const& v) {\n\tstd::vector< Value > ret(v.size());\n\tstd::transform(v.begin(), v.end(), ret.begin(), [](auto&& t){ return std::get< I >(t); });\n\treturn ret;\n}\n\nint main() {\n\tstd::cin.tie(0); std::cin.sync_with_stdio(false);\n\tconstexpr int xmax = 10'000'010;\n\tauto isp = [&] {\n\t\tstd::vector<int> isp(xmax, true);\n\t\tisp.at(0) = false;\n\t\tisp.at(1) = false;\n\t\tfor (size_t p = 2; p < xmax; p++) {\n\t\t\tif (!isp.at(p)) continue;\n\t\t\tfor (size_t j = 2; j * p < xmax; j++) {\n\t\t\t\tisp.at(p * j) = false;\n\t\t\t}\n\t\t}\n\t\treturn isp;\n\t}();\n\n\tint n; std::cin >> n;\n\tstd::vector<int> a(n); std::cin>>a;\n\tdebug(a);\n\n\tstd::vector<int> ckd(xmax,false);\n\tfor (int x : a) ckd.at(x) = true;\n\tauto c = project<1>(run_length(ckd));\n\tdebug(c);\n\tc.pop_back();\n\tdebug(c);\n\tstd::partial_sum(all(c), c.begin());\n\n\tstd::vector<std::vector<int>> b(2);\n\tfor (int x : c) {\n\t  b.at(x%2).emplace_back(x);\n\t}\n\tdebug(b);\n\tstd::vector<int> sz(2);\n\tsz.at(0) = b.at(0).size();\n\tsz.at(1) = b.at(1).size();\n\tbipartite_matching bm(sz.at(0), sz.at(1));\n\n\trep(i0,0,sz.at(0))\n\trep(i1,0,sz.at(1)) {\n\t\tint x = b.at(0).at(i0);\n\t\tint y = b.at(1).at(i1);\n\t\tint z = x - y;\n\t\tif (z < 0) z = -z;\n\t\tif (isp.at(z)) {\n\t\t\tdebug(i0,i1);\n\t\t\tbm.insert(i0, sz.at(0) + i1);\n\t\t}\n\t}\n\n\tint k = sz.at(0);\n\tint l = sz.at(1);\n\tint m = bm.count();\n\tdebug(k,l,m);\n\tint ans = m + (k-m) + (l-m) + k%2;\n\tstd::cout << ans << std::endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n\nint bipartiteMatching(const vector<vector<int> > &g) {  //g: left side\n\tint nleft = g.size(), nright = 0;\n\tfor (auto es = g.begin(); es != g.end();es++) if (!es->empty()) nright = max(nright, *max_element(es->begin(), es->end()) + 1);\n\tvector<int> matchL(nleft, -1), matchR(nright, -1), prev(nleft), seen(nleft, -1);\n\tfor (int i = 0; i < nleft; i++) {\n\t\tvector<int> stk; stk.push_back(i);\n\t\tseen[i] = i; prev[i] = -1;\n\t\twhile (!stk.empty()) {\n\t\t\tint v = stk.back(); stk.pop_back();\n\t\t\tfor (auto ui = g[v].begin(); ui != g[v].end();ui++) {\n\t\t\t\tint u = *ui;\n\t\t\t\tint j = matchR[u];\n\t\t\t\tif (j == -1) {\n\t\t\t\t\twhile (v != -1) {\n\t\t\t\t\t\tmatchR[u] = v;\n\t\t\t\t\t\tswap(u, matchL[v]);\n\t\t\t\t\t\tv = prev[v];\n\t\t\t\t\t}\n\t\t\t\t\tgoto break_;\n\t\t\t\t}\n\t\t\t\telse if (seen[j] < i) {\n\t\t\t\t\tseen[j] = i; prev[j] = v;\n\t\t\t\t\tstk.push_back(j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\tbreak_:;\n\t}\n\treturn (int)matchL.size() - count(matchL.begin(), matchL.end(), -1);\n}\n\n#define MAX 10000002\n\nint n;\n\nbool use[MAX];\n\nvector<int> v[2];\n\n\nset<int> s;\n\nint main(){\n\tcin >> n;\n\tfor (int i = 0; i < n; i++){\n\t\tint x;\n\t\tscanf(\"%d\", &x);\n\t\ts.insert(x);\n\t}\n\tfor (auto it = s.begin(); it != s.end();it++){\n\t\tint ich = (*it);\n\t\tif (!s.count(ich - 1)){\n\t\t\tv[(ich - 1) & 1].push_back(ich - 1);\n\t\t}\n\t\tif (!s.count(ich + 1)){\n\t\t\tv[ich & 1].push_back(ich);\n\t\t}\n\t}\n\tfor (int i = 2; i < MAX; i++){\n\t\tif (use[i] == false){\n\t\t\tfor (int j = i * 2; j < MAX; j++){\n\t\t\t\tuse[j] = true;\n\t\t\t}\n\t\t}\n\t}\n\tvector<vector<int> > g(v[0].size());\n\tfor (int j = 0; j < v[0].size(); j++){\n\t\tfor (int k = 0; k < v[1].size(); k++){\n\t\t\tif (!use[abs(v[1][k] - v[0][j])]){\n\t\t\t\tg[j].push_back(k);\n\t\t\t}\n\t\t}\n\t}\n\tint num = bipartiteMatching(g);\n\tint f = ((v[0].size() - num) / 2)*2;\n\tf += num;\n\tf += ((v[1].size() - num) / 2) * 2;\n\tif ((v[0].size()-num) & 1){\n\t\tf += 3;\n\t}\n\tcout << f << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>     \n#define ll long long\n#define mk make_pair\n#define y1 yyyy\nusing namespace std;\n\nconst int N = 5e4 + 5;\nconst int mod = 1e9 + 7;\n\nint n, a[N], my[N], ans;\nbool b[N * 200];\nvector<int> V[2], G[N];\n\nbool find(int x) {\n\tfor (int i = 0; i < G[x].size(); i++) {\n\t\tint u = G[x][i];\n\t\tif (b[u]) continue; \n\t\tb[u] = 1;\n\t\tif (my[u] == -1 || find(my[u])) {\n\t\t\tmy[u] = x;\n\t\t\treturn 1;\n\t\t} \n\t}\n\treturn 0;\n}\n\nbool check(int x) { \n\tif (x <= 2) return 0;\n\tfor (int i = 2; i * i <= x; i++) {\n\t\tif (x % i == 0) return 0;\n\t}  \n\treturn 1;\n}\n\nint main() {\n\tcin >> n;\n\tfor (int i = 1; i <= n; i++) cin >> a[i], b[a[i]] = 1;\n\tfor (int i = 1; i <= 10000001; i++) {\n\t\tif (b[i] != b[i - 1]) V[i & 1].push_back(i);\n\t}\n\tmemset(my, -1, sizeof(my));\n\tfor (int i = 0; i < V[0].size(); i++) {\n\t\tfor (int j = 0; j < V[1].size(); j++) {\n\t\t\tif (check(abs(V[0][i] - V[1][j]))) \n\t\t\t\tG[i].push_back(j);\n\t\t}\n\t}\n\tfor (int i = 0; i < V[0].size(); i++) {\n\t\tfor (int j = 0; j < V[1].size(); j++) b[j] = 0;\n\t\tif (find(i)) ans++;\n\t}\n\tcout << my[1] << my[0] << endl; \n\tcout << ans + (V[0].size() - ans) / 2 * 2 + (V[1].size() - ans) / 2 * 2 + (V[0].size() - ans) % 2 * 3;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstruct hopcroft{\n\tvector<int> dist, pair_l, pair_r;\n\tvector<bool> seen;\n\tvector<vector<int>> to;\n\tint n1, n2;\n\thopcroft(int n1, int n2) : n1(n1), n2(n2){\n\t\tto.resize(n1);\n\t\tpair_l.assign(n1, -1);\n\t\tpair_r.assign(n2, -1);\n\t\tdist.resize(n1);\n\t\tseen.resize(n1);\n\t}\n\tvoid add_edge(int u, int v){\n\t\tto[u].push_back(v);\n\t}\n\tbool bfs(){\n\t\tfill(dist.begin(), dist.end(), -1);\n\t\tqueue<int> q;\n\t\tfor (int i = 0; i < n1; i++){\n\t\t\tif (pair_l[i] == -1){\n\t\t\t\tdist[i] = 0;\n\t\t\t\tq.push(i);\n\t\t\t}\n\t\t}\n\t\tbool reach_minus = false;\n\t\twhile (!q.empty()){\n\t\t\tint u = q.front();\n\t\t\tq.pop();\n\t\t\tfor (int adj : to[u]){\n\t\t\t\tint radj = pair_r[adj];\n\t\t\t\tif (radj == -1){\n\t\t\t\t\treach_minus = true;\n\t\t\t\t} else if (dist[radj] == -1){\n\t\t\t\t\tdist[radj] = dist[u] + 1;\n\t\t\t\t\tq.push(radj);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn reach_minus;\n\t}\n\tbool dfs(int u){\n\t\tseen[u] = true;\n\t\tfor (int adj : to[u]){\n\t\t\tint radj = pair_r[adj];\n\t\t\tif (radj == -1 || (!seen[radj] && dfs(radj))){\n\t\t\t\tpair_l[u] = adj;\n\t\t\t\tpair_r[adj] = u;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\tint max_matching(){\n\t\tint res = 0;\n\t\twhile (true){\n          \tbfs();\n\t\t\tfill(seen.begin(), seen.end(), false);\n          \tint f = 0;\n\t\t\tfor (int i = 0; i < n1; i++)\n\t\t\t\tif (dfs(i))\n\t\t\t\t\tres++, f++;\n         \tif(!f) break;\n\t\t}\n\t\treturn res;\n\t}\n};\nconst int lim = 10000002;\nbool prime[lim];\nvoid init(){\n\tmemset(prime, true, sizeof(prime));\n\tprime[0] = prime[1] = false;\n\tfor(int i = 2; i < lim; i++){\n\t\tif(prime[i]){\n\t\t\tfor(int j = i + i; j < lim; j += i)\n\t\t\t\tprime[j] = false;\n\t\t}\t\n\t}\n}\nint main(){\n\tinit();\n\tint n; cin >> n;\n\tbitset<lim> b;\n\tfor(int i = 0; i < n; i++){\n\t\tint x; cin >> x;\n\t\tb[x] = 1;\n\t}\n\tvector<int> p[2];\n\tfor(int i = 1; i < lim; i++){\n\t\tif(b[i] != b[i - 1]){\n\t\t\tp[i%2].push_back(i);\n\t\t}\n\t}\n\tint l0 = p[0].size(), l1 = p[1].size();\n\thopcroft ho(l0, l1);\n\tfor(int i = 0; i < l0; i++){\n\t\tfor(int j = 0; j < l1; j++){\n\t\t\tif(prime[abs(p[0][i] - p[1][j])]){\n\t\t\t\tho.add_edge(i, j);\n\t\t\t}\n\t\t}\n\t}\n\tint fl = ho.max_matching();\n\tint ans = fl + ((l0 - fl) / 2) * 2 + ((l1 - fl)/2) * 2 + ((l0 - fl) % 2) * 3;\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <cstdio>\n\nusing namespace std;\n\nconst int N=205;\nconst int M=N*N;\nconst int L=10000000;\n\nint last[N],bel[N];\nint nxt[M],tov[M];\nbool mark[L+5];\nint pos[2][N];\nbool vis[N];\nint n,tot,mx,match,ans;\n\ninline int iabs(int x){return x>0?x:-x;}\n\ninline void insert(int x,int y){tov[++tot]=y,nxt[tot]=last[x],last[x]=tot;}\n\ninline bool is_prime(int x)\n{\n\tfor (int i=1;i*i<=x;++i) if (!(x%i)) return 0;\n\treturn 1;\n}\n\nbool hungary(int x)\n{\n\tif (vis[x]) return 0;\n\tvis[x]=1;\n\tfor (int i=last[x],y;i;i=nxt[i])\n\t\tif (!bel[y=tov[i]]||hungary(y))\n\t\t\treturn bel[y]=x;\n\treturn 0;\n}\n\nint main()\n{\n\t//freopen(\"flip.in\",\"r\",stdin),freopen(\"flip.out\",\"w\",stdout);\n\tscanf(\"%d\",&n);\n\tfor (int i=1,x;i<=n;++i) scanf(\"%d\",&x),mx=max(mx,x),mark[x]=1;\n\tfor (int i=1;i<=mx+1;++i)\n\t\tif (mark[i]^mark[i-1])\n\t\t\tpos[i&1][++pos[i&1][0]]=i;\n\tfor (int i=1;i<=pos[0][0];++i)\n\t\tfor (int j=1;j<=pos[1][0];++j)\n\t\t{\n\t\t\tint d=iabs(pos[0][i]-pos[1][j]);\n\t\t\tif (is_prime(d)) insert(i,j);\n\t\t}\n\tmatch=0;\n\tfor (int i=1;i<=pos[0][0];++i) memset(vis,0,sizeof vis),match+=hungary(i);\n\tans=match,pos[0][0]-=match,pos[1][0]-=match;\n\tans+=(pos[0][0]&1)+pos[0][0]+pos[1][0];\n\tprintf(\"%d\\n\",ans);\n\t//fclose(stdin),fclose(stdout);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <cmath>\n#include <cstring>\n#define N 1000006\n#define M 10000007\n\nusing namespace std;\n\nstruct edge{\n\tint to, nxt;\n}e[M];\n\nint n, cnt, tot, numx, numy;\nint fir[N], a[N], b[N], prime[M], link[N], x[N], y[N];\nbool vis[M], book[N];\n\nvoid init();\nvoid add(int ,int);\nbool dfs(int);\n\nint main(){\n\tscanf(\"%d\", &n);init();\n\tfor(int i = 1; i <= n; ++i)\n\t\tscanf(\"%d\", a + i);\n\tsort(a + 1,a + 1 + n);a[0] = a[n + 1] = 99999999;\n\tfor(int i = 1; i <= n; ++i){\n\t\tif(a[i] != a[i - 1] + 1) b[++cnt] = a[i];\n\t\tif(a[i] != a[i + 1] - 1) b[++cnt] = a[i] + 1;\n\t}\n\tfor(int i = 1; i <= cnt; ++i){\n\t\tif(b[i] & 1) x[++numx] = b[i];\n\t\telse y[++numy] = b[i];\n\t}\n\tcnt = 0;\n\tfor(int i = 1; i <= numx; ++i)\n\t\tfor(int j = 1; j <= numy; ++j)\n\t\t\tif(!vis[abs(x[i] - y[j])])\n\t\t\t\tadd(i, j);\n\tfor(int i = 1; i <= numx; ++i){\n\t\tmemset(book, false, sizeof book);\n\t\tdfs(i);\n\t}\n\tint ans = 0;\n\tfor(int i = 1; i <= numy; ++i)\n\t\tif(link[i]) \n\t\t\t++ans;\n\tnumy -= ans;numx -= ans;\n\tans += (numy / 2) * 2 + (numx / 2) * 2;\n\tans += (numy % 2) * (numx % 2) * 3;\n\tcout << ans << endl;\n\treturn 0;\n}\n\nvoid add(int u,int v){\n\te[++cnt].to = v;e[cnt].nxt = fir[u];fir[u] = cnt;\n\treturn ;\n}\n\nvoid init(){\n\tint m = 1e7;\n\tfor(int i = 2; i <= m; ++i){\n\t\tif(!vis[i]) prime[++tot] = i;\n\t\tfor(int j = 1; j <= tot && i * prime[j] <= m; ++j){\n\t\t\tvis[i * prime[j]] = true;\n\t\t\tif(i % prime[j] == 0) break;\n\t\t}\n\t}\n\tvis[1] = vis[2] = true;\n\treturn ;\n}\n\nbool dfs(int u){\n\tif(book[u]) return false;\n\tbook[u] = true;\n\tfor(int i = fir[u]; i; i = e[i].nxt){\n\t\tint v = e[i].to;\n\t\tif(!link[v] || dfs(link[v])){\n\t\t\tlink[v] = u;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <string.h>\nusing namespace std;\n\n#define abs(x) ((x) > 0 ? (x) : -(x))\nbool prime[11000000];\nbool b[11000000];\nint n;\nbool used[210], go[210][210];\nint ans;\nint ind[210];\nint cnt0, cnt1;\nint m;\nint Link[210];\n\nbool fi(int x) {\n\tfor (int i = 1; i <= m; i++)\n\t\tif (go[x][i] && !used[i]) {\n\t\t\tif (!Link[i] || fi(Link[i])) {\n\t\t\t\tLink[i] = x;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\treturn false;\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 2; i <= 10000000; i++)\n\t\tprime[i] = true;\n\tfor (int i = 1; i * i <= 10000000; i++)\n\t\tif (prime[i])\n\t\t\tfor (int j = i * i; j <= 10000000; j += i)\n\t\t\t\tprime[j] = false;\n\tprime[2] = false;\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tint t;\n\t\tscanf(\"%d\", &t);\n\t\tb[t] ^= 1;\n\t\tb[t + 1] ^= 1;\n\t}\n\tfor (int i = 1; i <= 10000001; i++)\n\t\tif (b[i]) {\n\t\t\tm += 1;\n\t\t\tind[m] = i;\n\t\t}\n\tfor (int i = 1; i <= m; i++)\n\t\tif (ind[i] % 2 == 0) {\n\t\t\tcnt0 += 1;\n\t\t\tfor (int j = 1; j <= m; j++)\n\t\t\t\tif (ind[j] % 2 == 1 && prime[abs(ind[i] - ind[j])])\n\t\t\t\t\tgo[i][j] = true;\n\t\t}\n\tint ans = 0;\n\tfor (int i = 1; i <= m; i++)\n\t\tif (ind[i] % 2 == 0) {\n\t\t\tmemset(used, false, sizeof used);\n\t\t\tif (fi(i))\n\t\t\t\tans += 1;\n\t\t}\n\tint aa = ans;\n\tcnt1 = m - cnt0;\n\t// printf(\"?? %d %d\\n\", cnt0, cnt1);\n\tcnt0 -= ans;\n\tcnt1 -= ans;\n\tif (cnt0 % 2 == 0)\n\t\taa += cnt0 + cnt1;\n\telse\n\t\taa += 3 + (cnt0 - 1) + cnt1 - 1;\n\tprintf(\"%d\\n\", aa);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n \nusing namespace std;\nusing namespace __gnu_pbds;\n \n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define fbo find_by_order\n#define ook order_of_key\n \ntypedef long long ll;\ntypedef pair<int,int> ii;\ntypedef vector<int> vi;\ntypedef long double ld; \ntypedef tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> pbds;\ntypedef set<int>::iterator sit;\ntypedef map<int,int>::iterator mit;\ntypedef vector<int>::iterator vit;\n\nconst int MX = 255;\nconst int INF = int(1e9);\n\nstruct MaxFlow //by yutaka1999, have to define INF and MX (the Max number of vertices)\n{\n\tstruct edge\n\t{\n\t\tint to,cap,rev;\n\t\tedge(int to=0,int cap=0,int rev=0):to(to),cap(cap),rev(rev){}\n\t};\n\tvector <edge> vec[MX];\n\tint level[MX];\n\tint iter[MX];\n\t\n\tvoid addedge(int s,int t,int c) //adds an edge of cap c to the flow graph\n\t{\n\t\tint S=vec[s].size(),T=vec[t].size();\n\t\tvec[s].push_back(edge(t,c,T));\n\t\tvec[t].push_back(edge(s,0,S));\n\t}\n\tvoid bfs(int s)\n\t{\n\t\tmemset(level,-1,sizeof(level));\n\t\tqueue <int> que;\n\t\tlevel[s] = 0;\n\t\tque.push(s);\n\t\twhile (!que.empty())\n\t\t{\n\t\t\tint v = que.front();que.pop();\n\t\t\tfor(int i=0;i<vec[v].size();i++)\n\t\t\t{\n\t\t\t\tedge&e=vec[v][i];\n\t\t\t\tif (e.cap>0&&level[e.to]<0)\n\t\t\t\t{\n\t\t\t\t\tlevel[e.to]=level[v]+1;\n\t\t\t\t\tque.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tll flow_dfs(int v,int t,ll f)\n\t{\n\t\tif (v==t) return f;\n\t\tfor(int &i=iter[v];i<vec[v].size();i++)\n\t\t{\n\t\t\tedge &e=vec[v][i];\n\t\t\tif (e.cap>0&&level[v]<level[e.to])\n\t\t\t{\n\t\t\t\tll d=flow_dfs(e.to,t,min(f,ll(e.cap)));\n\t\t\t\tif (d>0)\n\t\t\t\t{\n\t\t\t\t\te.cap-=d;\n\t\t\t\t\tvec[e.to][e.rev].cap+=d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tll maxflow(int s,int t) //finds max flow using dinic from s to t\n\t{\n\t\tll flow = 0;\n\t\twhile(1)\n\t\t{\n\t\t\tbfs(s);\n\t\t\tif (level[t]<0) return flow;\n\t\t\tmemset(iter,0,sizeof(iter));\n\t\t\twhile (1)\n\t\t\t{\n\t\t\t\tll f=flow_dfs(s,t,INF);\n\t\t\t\tif(f==0) break;\n\t\t\t\tflow += f;\n\t\t\t}\n\t\t}\n\t}\n};\n\nstruct NumberTheory\n{\n\tvector<ll> primes;\n\tvector<bool> prime;\n\tvector<ll> totient;\n\tvector<ll> sumdiv;\n\tvector<ll> bigdiv;\n\tvoid Sieve(ll n)\n\t{\n\t\tprime.assign(n+1, 1);\n\t\tprime[1] = false;\n\t\tfor(ll i = 2; i <= n; i++)\n\t\t{\n\t\t\tif(prime[i])\n\t\t\t{\n\t\t\t\tprimes.pb(i);\n\t\t\t\tfor(ll j = i*2; j <= n; j += i)\n\t\t\t\t{\n\t\t\t\t\tprime[j] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tll phi(ll x)\n\t{\n\t\tmap<ll,ll> pf;\n\t\tll num = 1; ll num2 = x;\n\t\tfor(ll i = 0; primes[i]*primes[i] <= x; i++)\n\t\t{\n\t\t\tif(x%primes[i]==0)\n\t\t\t{\n\t\t\t\tnum2/=primes[i];\n\t\t\t\tnum*=(primes[i]-1);\n\t\t\t}\n\t\t\twhile(x%primes[i]==0)\n\t\t\t{\n\t\t\t\tx/=primes[i];\n\t\t\t\tpf[primes[i]]++;\n\t\t\t}\n\t\t}\n\t\tif(x>1)\n\t\t{\n\t\t\tpf[x]++; num2/=x; num*=(x-1);\n\t\t}\n\t\tx = 1;\n\t\tnum*=num2;\n\t\treturn num;\n\t}\n\t\n\tbool isprime(ll x)\n\t{\n\t\tif(x==1) return false;\n\t\tfor(ll i = 0; primes[i]*primes[i] <= x; i++)\n\t\t{\n\t\t\tif(x%primes[i]==0) return false;\n\t\t}\n\t\treturn true;\n\t}\n\n\tvoid SievePhi(ll n)\n\t{\n\t\ttotient.resize(n+1);\n\t\tfor (int i = 1; i <= n; ++i) totient[i] = i;\n\t\tfor (int i = 2; i <= n; ++i)\n\t\t{\n\t\t\tif (totient[i] == i)\n\t\t\t{\n\t\t\t\tfor (int j = i; j <= n; j += i)\n\t\t\t\t{\n\t\t\t\t\ttotient[j] -= totient[j] / i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvoid SieveSumDiv(ll n)\n\t{\n\t\tsumdiv.resize(n+1);\n\t\tfor(int i = 1; i <= n; ++i)\n\t\t{\n\t\t\tfor(int j = i; j <= n; j += i)\n\t\t\t{\n\t\t\t\tsumdiv[j] += i;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tll getPhi(ll n)\n\t{\n\t\treturn totient[n];\n\t}\n\t\n\tll getSumDiv(ll n)\n\t{\n\t\treturn sumdiv[n];\n\t}\n\t\n\tll modpow(ll a, ll b, ll mod)\n\t{\n\t\tll r = 1;\n\t\tif(b < 0) b += mod*100000LL;\n\t\twhile(b)\n\t\t{\n\t\t\tif(b&1) r = (r*a)%mod;\n\t\t\ta = (a*a)%mod;\n\t\t\tb>>=1;\n\t\t}\n\t\treturn r;\n\t}\n\t\n\tll inv(ll a, ll mod)\n\t{\n\t\treturn modpow(a, mod - 2, mod);\n\t}\n\t\n\tll invgeneral(ll a, ll mod)\n\t{\n\t\tll ph = phi(mod);\n\t\tph--;\n\t\treturn modpow(a, ph, mod);\n\t}\n\t\n\tvoid getpf(vector<ii>& pf, ll n)\n\t{\n\t\tfor(ll i = 0; primes[i]*primes[i] <= n; i++)\n\t\t{\n\t\t\tint cnt = 0;\n\t\t\twhile(n%primes[i]==0)\n\t\t\t{\n\t\t\t\tn/=primes[i]; cnt++;\n\t\t\t}\n\t\t\tif(cnt>0) pf.pb(ii(primes[i], cnt));\n\t\t}\n\t\tif(n>1)\n\t\t{\n\t\t\tpf.pb(ii(n, 1));\n\t\t}\n\t}\n\n\t//ll op;\n\tvoid getDiv(vector<ll>& div, vector<ii>& pf, ll n, int i)\n\t{\n\t\t//op++;\n\t\tll x, k;\n\t\tif(i >= pf.size()) return ;\n\t\tx = n;\n\t\tfor(k = 0; k <= pf[i].se; k++)\n\t\t{\n\t\t\tif(i==int(pf.size())-1) div.pb(x);\n\t\t\tgetDiv(div, pf, x, i + 1);\n\t\t\tx *= pf[i].fi;\n\t\t}\n\t}\n};\n\nMaxFlow mf;\nNumberTheory nt;\nset<int> S;\n\nvoid add(int z)\n{\n\tif(S.find(z)==S.end()) S.insert(z);\n\telse S.erase(z);\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tint n; cin>>n;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tint z; cin>>z;\n\t\tadd(z); add(z+1);\n\t}\n\tnt.Sieve(10000011);\n\tvi vec;\n\tfor(auto it=S.begin(); it != S.end(); it++) vec.pb(*it);\n\tnt.prime[2]=0;\n\tint s=MX-2; int e=MX-1;\n\tint o=0;\n\tfor(int i=0;i<vec.size();i++)\n\t{\n\t\tif(vec[i]&1) \n\t\t{\n\t\t\to++; mf.addedge(s,i,1);\n\t\t}\n\t\telse mf.addedge(i,e,1);\n\t\tfor(int j=i+1;j<vec.size();j++)\n\t\t{\n\t\t\tif(nt.prime[abs(vec[i]-vec[j])]) \n\t\t\t{\n\t\t\t\tif(vec[i]&1) mf.addedge(i,j,1);\n\t\t\t\telse mf.addedge(j,i,1);\n\t\t\t}\n\t\t}\t\n\t}\n\tint k=mf.maxflow(s,e);\n\tn=vec.size();\n\tcout<<k+(o&1)*3+((o-k)/2+(n-o-k)/2)*2<<'\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define reg register\n#define pr std::pair<int, int>\n#define fi first\n#define se second\n#define FIN(s) freopen(s, \"r\", stdin)\n#define FOUT(s) freopen(s, \"w\", stdout)\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define rep(i, l, r) for (int i = l; i <= r; ++i)\n#define lep(i, l, r) for (int i = l; i < r; ++i)\n#define irep(i, r, l) for (int i = r; i >= l; --i)\n#define ilep(i, r, l) for (int i = r; i > l; --i)\n#define Rep(i, n) rep(i, 1, n)\n#define Lep(i, n) lep(i, 1, n)\n#define IRep(i, n) irep(i, n, 1)\n#define ILep(i, n) ilep(i, n, 1)\ntypedef long long ll;\ntypedef long double ld;\n\nnamespace modular {\n    const int MOD = 1000000007;\n    inline int add(int x, int y) { return (x += y) >= MOD ? x -= MOD : x; }\n    inline void inc(int &x, int y) { (x += y) >= MOD ? x -= MOD : 0; }\n    inline int mul(int x, int y) { return 1LL * x * y % MOD; }\n    inline int qpow(int x, int y) {\n        int ans = 1;\n        for (; y; y >>= 1, x = mul(x, x))\n            if (y & 1)\n                ans = mul(ans, x);\n        return ans;\n    }\n}; // namespace modular\n\nnamespace Base {\n    template <typename Tp> inline Tp input() {\n        Tp x = 0, y = 1;\n        char c = getchar();\n        while ((c < '0' || '9' < c) && c != EOF) {\n            if (c == '-')\n                y = -1;\n            c = getchar();\n        }\n        if (c == EOF)\n            return 0;\n        while ('0' <= c && c <= '9')\n            x = x * 10 + c - '0', c = getchar();\n        return x *= y;\n    }\n    template <typename Tp> inline void read(Tp &x) { x = input<Tp>(); }\n    template <typename Tp> inline void chmax(Tp &x, Tp y) { x < y ? x = y : 0; }\n    template <typename Tp> inline void chmin(Tp &x, Tp y) { x > y ? x = y : 0; }\n}; // namespace Base\nusing namespace Base;\n/*----------------------------------------------------------------------------*/\n\n#define MAX_N 207\n#define MAX_P 10000007\n\nint N, res;\nint a[MAX_N], b[MAX_N];\nint pri[MAX_P / 10], tot;\nint match[MAX_N];\nbool check[MAX_P], con[MAX_N][MAX_N], vis[MAX_N];\n\nvoid sieve(int n) {\n    rep(i, 2, n) {\n        if (!check[i]) pri[++tot] = i;\n        Rep(j, tot) {\n            if (i * pri[j] > n) break;\n            check[i * pri[j]] = true;\n            if (i % pri[j] == 0) break;\n        }\n    }\n    check[2] = check[1] = 1;\n}\n\nbool dfs(int x) {\n    Rep(j, N) if (con[x][j]) {\n        if (!vis[j] && (!match[j] || dfs(match[j]))) {\n            vis[j] = true;\n            match[j] = x;\n            res++;\n            return true;\n        }\n    }\n    return false;\n}\n\nvoid solve() {\n    int top = 0;\n    std::sort(a + 1, a + N + 1);\n    b[top = 1] = a[1];\n    a[N + 1] = 0;\n    Rep(i, N) {\n        if (b[top] != a[i] && a[i - 1] != a[i] - 1) b[++top] = a[i];\n        if (a[i] + 1 != a[i + 1]) b[++top] = a[i] + 1;\n    }\n    N = top;\n    Rep(i, N) a[i] = b[i];\n    // Rep(i, N) printf(\"%d \", a[i]); puts(\"\");return;\n    Rep(i, N) if (a[i] & 1) {\n        Rep(j, N) if (a[j] % 2 == 0 && !check[std::abs(a[i] - a[j])]) con[i][j] = true;\n    }\n    Rep(i, N) if (a[i] & 1) {\n        Rep(j, N) vis[j] = false;\n        dfs(i);\n    }\n    Rep(i, N) vis[i] = false;\n    Rep(i, N) if (a[i] % 2 == 0 && match[i]) vis[i] = vis[match[i]] = true;\n    int cnt[2] = {0};\n    Rep(i, N) if (!vis[i]) cnt[a[i] & 1]++;\n    res += 2 * (cnt[0] / 2 + cnt[1] / 2);\n    if (cnt[0] & 1) res += 3;\n    printf(\"%d\\n\", res);\n}\n\nint main() {\n    read(N);\n    int mx = 0;\n    Rep(i, N) read(a[i]), chmax(mx, a[i]);\n    sieve(mx);\n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = (int)1e7 + 10;\ninline int read()\n{\n  int p=0; int f=1; char ch=getchar();\n  while(ch<'0' || ch>'9'){if(ch=='-') f=-1; ch=getchar();}\n  while(ch>='0' && ch<='9'){p=p*10+ch-'0'; ch=getchar();}\n  return p*f;\n}\n\nint prime[N],pri; bool v[N];\nvoid get_prime(int n)\n{\n  memset(v,1,sizeof(v)); v[0] = v[1] = 0; pri = 0;\n  for(int i=2;i<=n;i++)\n  {\n    if(v[i]) prime[++pri] = i;\n    for(int j=1;(j<=pri) && (i*prime[j] <= n);j++)\n    {\n      v[i*prime[j]] = 0;\n      if(i%prime[j]==0) break;\n    }\n  }\n  v[2] = 0;\n}\n\nstruct node{int x,y,next;}edge[100010]; int len,first[N];\nvoid ins(int x,int y){len++; edge[len].x=x; edge[len].y=y; edge[len].next=first[x]; first[x]=len;}\n\nint n,a[N],b[N];\n\n\nint chw[N],match[N];\nbool dfs(int x)\n{\n  for(int k=first[x];k!=-1;k=edge[k].next)\n  {\n    int y=edge[k].y;\n    if(!chw[y])\n    {\n      chw[y] = 1;\n      if((match[y] == 0) || dfs(match[y])) return 1;\n    }\n  }\n  return 0;\n}\n\nint main()\n{\n\n  get_prime(1e7+1);\n\n  n = read(); len = 0; memset(first,-1,sizeof(first));\n  for(int i=1;i<=n;i++) a[read()] = 1;\n  for(int i=1;i<=(int)1e7+1;i++) b[i] = abs(a[i] - a[i-1]);\n  for(int i=1;i<=(int)1e7+1;i++) a[i] = b[i];\n  int blen = 0; for(int i=1;i<=(int)1e7+1;i++) if(a[i] == 1) b[++blen] = i;\n  int c=0,d=0; for(int i=1;i<=blen;i++) if(b[i] & 1) c++; else d++;\n  for(int i=1;i<=blen;i++) if(b[i] & 1) for(int j=1;j<=blen;j++) if(!(b[j]&1)) if(v[abs(b[i] - b[j])]) ins(i,j);\n  int ans=0; for(int i=1;i<=blen;i++)\n  {\n    for(int j=1;j<=blen;j++) chw[i] = 0;\n    if(dfs(i)) ans++;\n  }\n \n  c-=ans; d-=ans;\n  ans += 2*(c/2 + d/2); c%=2; d%=2;\n  if(c && d) ans+=3;\n\n  return printf(\"%d\\n\",ans),0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fi first\n#define se second\nusing namespace std;\n\nconst int maxn = 200, maxm = 1e7 + 1;\nint n, m, k, p[maxm / 10 + 3], a[maxn + 3], mat[maxn + 3];\nmap<int, bool> M;\nbool b[maxm + 3], vis[maxn + 3];\nvector<int> G[maxn + 3];\n\nvoid prework(int n) {\n\tfor (int i = 2; i <= n; i++) {\n\t\tif (!b[i]) p[++k] = i;\n\t\tfor (int j = 1; j <= k && i * p[j] <= n; j++) {\n\t\t\tb[i * p[j]] = true;\n\t\t\tif (i % p[j] == 0) break;\n\t\t}\n\t}\n}\n\nbool dfs(int u) {\n\tfor (int i = 0, v; i < G[u].size(); i++) {\n\t\tif (!vis[v = G[u][i]]) {\n\t\t\tvis[v] = true;\n\t\t\tif (!mat[v] || dfs(v)) {\n\t\t\t\tmat[v] = u, mat[u] = v;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\nint main() {\n\tprework(maxm);\n\tscanf(\"%d\", &n);\n\tfor (int i = 1, x; i <= n; i++) {\n\t\tscanf(\"%d\", &x);\n\t\tM[x] ^= 1, M[x + 1] ^= 1;\n\t}\n\tfor (map<int, bool>::iterator it = M.begin(); it != M.end(); it++) {\n\t\tif (it -> se) a[++m] = it -> fi;\n\t}\n\tfor (int i = 1; i <= m; i++) {\n\t\tfor (int j = i + 1; j <= m; j++) {\n\t\t\tif (p[lower_bound(p + 1, p + k + 1, a[j] - a[i]) - p] == a[j] - a[i]) {\n\t\t\t\tG[i].push_back(j), G[j].push_back(i);\n\t\t\t}\n\t\t}\n\t}\n\tint ans = 0;\n\tfor (int i = 1; i <= m; i++) if (a[i] % 2 && !mat[i]) {\n\t\tfill(vis + 1, vis + m + 1, false), ans += dfs(i);\n\t}\n\tint odd = 0, even = 0;\n\tfor (int i = 1; i <= m; i++) if (!mat[i]) {\n\t\tif (a[i] % 2) {\n\t\t\tif (odd) odd = 0, ans += 2;\n\t\t\telse odd = 1;\n\t\t} else {\n\t\t\tif (even) even = 0, ans += 2;\n\t\t\telse even = 1;\n\t\t}\n\t}\n\tif (odd && even) ans += 3;\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,l,r) for(register int i = l ; i <= r ; i++)\n#define repd(i,r,l) for(register int i = r ; i >= l ; i--)\n#define rvc(i,S) for(register int i = 0 ; i < (int)S.size() ; i++)\n#define rvcd(i,S) for(register int i = ((int)S.size()) - 1 ; i >= 0 ; i--)\n#define fore(i,x)for (register int i = head[x] ; i ; i = e[i].next)\n#define forup(i,l,r) for (register int i = l ; i <= r ; i += lowbit(i))\n#define fordown(i,id) for (register int i = id ; i ; i -= lowbit(i))\n#define pb push_back\n#define prev prev_\n#define stack stack_\n#define mp make_pair\n#define fi first\n#define se second\n#define lowbit(x) (x&(-x))\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pr;\n\nconst ll MAX = 2e18;\nconst ld inf = 2e18;\nconst int maxn = 220;\nconst ll mod = 1e9 + 7;\n\ninline ll power(ll x,ll y){\n\ty = ((y % (mod - 1)) + (mod - 1)) % (mod - 1);\n//\tif ( y < 0 ) return power(power(x,-y),mod - 2);\n\tll res = 1;\n\twhile ( y ){\n\t\tif ( y & 1 ) res = res * x % mod;\n\t\tx = x * x % mod;\n\t\ty >>= 1;\n\t}\n\treturn res;\n}\nint a[maxn],n,odd[maxn],even[maxn],cnt1,cnt2;\nset <int> s;\nnamespace Prime{\n\tconst int N = 1e7;\n\tint prime[N + 20],tag[N + 20],mn[N + 20],Cnt;\t\n\tvoid init (){\n\t\trep(i,2,N){\n\t\t\tif ( !tag[i] ) prime[++Cnt] = i;\n\t\t\trep(j,1,Cnt){\n\t\t\t\tif ( prime[j] * i > N ) break;\n\t\t\t\ttag[i * prime[j]] = 1;\n\t\t\t\tmn[i * prime[j]] = prime[j];\n\t\t\t\tif ( i % prime[j] == 0 ) break;\n\t\t\t}\n\t\t}\n\t}\n}\nusing namespace Prime;\n\nstruct node{\n\tint next,to;\n}e[maxn * maxn];\nint head[maxn],cnt;\nint from[maxn],use[maxn],tot;\n\ninline void adde(int x,int y){\n\te[++cnt].to = y;\n\te[cnt].next = head[x];\n\thead[x] = cnt;\n}\nbool match(int x){\n\tfore(i,x){\n\t\tif ( !use[e[i].to] ){\n\t\t\tuse[e[i].to] = 1;\n\t\t\tif ( from[e[i].to] == -1 || match(e[i].to) ){\n\t\t\t\tfrom[e[i].to] = x;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nvoid hungary(){\n\ttot = 0;\n\tmemset(from,-1,sizeof(from));\n\tn = cnt1;\n\trep(i,1,n){\n\t\tmemset(use,0,sizeof(use));\n\t\tif ( match(i) ) ++tot;\n\t}\n}\n\n\nint main(){\n\tinit();\n\tscanf(\"%d\",&n);\n\trep(i,1,n){\n\t   \tscanf(\"%d\",&a[i]);\n\t\tif ( s.find(a[i]) == s.end() ) s.insert(a[i]);\n\t\telse s.erase(a[i]);\n\n\t\tif ( s.find(a[i] + 1) == s.end() ) s.insert(a[i] + 1);\n\t\telse s.erase(a[i] + 1);\n\t}\n\tfor (auto it = s.begin() ; it != s.end() ; ++it){\n\t\tint x = *it;\n\t\tif ( x & 1 ) odd[++cnt1] = x;\n\t\telse even[++cnt2] = x;\n\t}\n\trep(i,1,cnt1){\n\t\trep(j,1,cnt2){\n\t\t\tint c = abs(odd[i] - even[j]);\n\t\t\tif ( !tag[c] ) adde(i,j + cnt1);\n\t\t}\n\t}\n\tcout<<cnt1 + cnt2 - tot + ((cnt1 - tot) & 1)<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pp;\ntypedef pair<ll,ll> pll;\nvoid read(int& x){ scanf(\"%d\",&x); }\nvoid read(ll& x){ scanf(\"%lld\",&x); }\ntemplate<typename T,typename... Args>\nvoid read(T& a,Args&... b){ read(a); read(b...); }\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define eb emplace_back\n#define x first\n#define y second\n \nint n;\nint p[210];\n \nvoid in(){\n\tint t; read(t);\n\tint last;\n\tread(last);\n\tp[++n] = last;\n\tfor(;--t;){\n\t\tint x; read(x);\n\t\tif(last+1 < x){\n\t\t\tp[++n] = last+1;\n\t\t\tp[++n] = x;\n\t\t}\n\t\tlast = x;\n\t}\n\tp[++n] = last+1;\n}\n \nbool is_prime(int x){\n\tif(x==1) return 0;\n\tif(x==2) return 0;\n\tfor(int i=2; i*i<=x; ++i) if(x%i==0) return 0;\n\treturn 1;\n}\nvector<int>edge[210];\nint vis[210];\nint rev[210];\n \nbool dfs(int x){\n\tif(vis[x]) return 0;\n\tvis[x]=1;\n\tfor(int y:edge[x]){\n\t\tif(!rev[y] || dfs(rev[y])){\n\t\t\trev[y]=x;\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n \nint MM(){ int ret = 0;\n\tfor(int i=1; i<=n; ++i){\n\t\tfill(vis+1, vis+n+1, 0);\n\t\tif(dfs(i)) ret += 1;\n\t}\n\treturn ret;\n}\n \nint main()\n{\n\tin();\n\tint oc=0, ec=0;\n\tfor(int i=1; i<=n; ++i){\n\t\t((p[i]%2)?oc:ec)++;\n\t\tfor(int j=i+1; j<=n; ++j){\n\t\t\tif(is_prime(p[j]-p[i])){\n\t\t\t\tint a=i, b=j;\n\t\t\t\tif(p[a]%2) swap(a, b);\n\t\t\t\tedge[a].pb(b);\n\t\t\t}\n\t\t}\n\t}\n\tint mm = MM();\n\tint ans = 2e9;\n\tfor(int pu=0; pu<=mm; ++pu){\n\t\tint cur = 0;\n\t\tcur += (oc-pu)/2*2;\n\t\tcur += (ec-pu)/2*2;\n\t\tcur += ((oc-pu)%2)*((ec-pu)%2)*3;\n\t\tcur += pu;\n\t\tans = min(ans, cur);\n\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n\n#include <iostream>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <unordered_set>\n#include <queue>\n#include <set>\n#include <algorithm>\n#include <numeric>\n#include <list>\nusing namespace std;\n\nusing QWORD  = uint64_t;\nusing SQWORD = int64_t;\nusing DWORD  = uint32_t;\nusing SDWORD = int32_t;\nusing WORD   = uint16_t;\nusing SWORD  = int16_t;\nusing BYTE   = uint8_t;\nusing SBYTE  = int8_t;\nusing DOUBLE = double;\nusing FLOAT  = float;\n\n#define MIN_SDWORD (-2147483648)\n#define MAX_SDWORD (2147483647)\n#define MIN_SBYTE (-128)\n#define MAX_SBYTE (127)\n\n#define MIN_SQWORD (0x8000000000000000)\n#define MAX_SQWORD (0x7FFFFFFFFFFFFFFF)\n\n#define MAX_QWORD  (0xFFFFFFFFFFFFFFFF)\n#define MAX_DWORD  (0xFFFFFFFF)\n#define MAX_WORD   (0xFFFF)\n#define MAX_BYTE   (0xFF)\n\n#define MAX_DOUBLE      (1.0e+308)\n#define DOUBLE_EPS      (1.0e-12)\n#define MIN_DOUBLE_N    (-1.0e+308)\n\n#define ArrayLength(a)  (sizeof(a) / sizeof(a[0]))\n\nstatic inline DOUBLE MAX(DOUBLE a, DOUBLE b) { return a > b ? a : b; }\nstatic inline QWORD MAX(QWORD a, QWORD b) { return a > b ? a : b; }\nstatic inline DWORD MAX(DWORD a, DWORD b) { return a > b ? a : b; }\nstatic inline SDWORD MAX(SDWORD a, SDWORD b) { return a > b ? a : b; }\nstatic inline DOUBLE MIN(DOUBLE a, DOUBLE b) { return a < b ? a : b; }\nstatic inline QWORD MIN(QWORD a, QWORD b) { return a < b ? a : b; }\nstatic inline DWORD MIN(DWORD a, DWORD b) { return a < b ? a : b; }\nstatic inline SDWORD MIN(SDWORD a, SDWORD b) { return a < b ? a : b; }\nstatic inline DOUBLE ABS(DOUBLE a) { return 0 < a ? a : -a; };\n\n#define BYTE_BITS   (8)\n#define WORD_BITS   (16)\n#define DWORD_BITS  (32)\n#define QWORD_BITS  (64)\n\nstatic inline void inputStringSpSeparated(char *pcStr)\n{\n    char *pcCur = pcStr;\n    for (;;) {\n        char c = getchar();\n        if (('\\n' == c) || (EOF == c) || (' ' == c)) {\n            break;\n        }\n        *pcCur = c;\n        pcCur++;\n    }\n    *pcCur = '\\0';\n}\n\nstatic inline void inputString(char *pcStr)\n{\n    char *pcCur = pcStr;\n    for (;;) {\n        char c = getchar();\n        if (('\\n' == c) || (EOF == c)) {\n            break;\n        }\n        *pcCur = c;\n        pcCur++;\n    }\n    *pcCur = '\\0';\n}\n\n\nstatic inline SQWORD inputSQWORD(void)\n{\n    SQWORD sqNumber = 0;\n    SQWORD sqMultiplier = 1;\n    bool bRead = false;\n    for (;;) {\n        char c = getchar();\n        if (!bRead) {\n            if ('-' == c) {\n                sqMultiplier = -1;\n            }\n        }\n        if (('0' <= c) && (c <= '9')) {\n            sqNumber *= 10LL;\n            sqNumber += (SQWORD)(c - '0');\n            bRead = true;\n        } else {\n            if (bRead) {\n                return sqNumber * sqMultiplier;\n            }\n        }\n    }\n}\n\n\nstatic inline SDWORD inputSDWORD(void)\n{\n    SDWORD lNumber = 0;\n    SDWORD lMultiplier = 1;\n    bool bRead = false;\n    for (;;) {\n        char c = getchar();\n        if (!bRead) {\n            if ('-' == c) {\n                lMultiplier = -1;\n            }\n        }\n        if (('0' <= c) && (c <= '9')) {\n            lNumber *= 10;\n            lNumber += (c - '0');\n            bRead = true;\n        } else {\n            if (bRead) {\n                return lNumber * lMultiplier;\n            }\n        }\n    }\n}\n\nstatic inline DOUBLE inputFP(void)\n{\n    DOUBLE dInt = 0.0;\n    DOUBLE dFrac = 0.0;\n    DOUBLE dMultiplier = 1.0;\n    DWORD dwFpCnt = 0;\n    DOUBLE *pdCur = &dInt;\n    bool bRead = false;\n    for (;;) {\n        char c = getchar();\n        if (!bRead) {\n            if ('-' == c) {\n                dMultiplier = -1;\n            }\n        }\n        if ('.' == c) {\n            pdCur = &dFrac;\n        } else if (('0' <= c) && (c <= '9')) {\n            (*pdCur) *= 10;\n            (*pdCur) += (DOUBLE)(c - '0');\n            bRead = true;\n            if (pdCur == &dFrac) {\n                dwFpCnt++;\n            }\n        } else {\n            if (bRead) {\n                return dMultiplier * (dInt + dFrac / (pow((DOUBLE)10.0 , (DOUBLE)dwFpCnt)));\n            }\n        }\n    }\n}\n\n\n/**\n *  mod による操作ライブラリ\n */\n\n#define ANS_MOD (1000000007LL)\n \nstatic SQWORD addMod(SQWORD x, SQWORD y)\n{ \n    return (x + y) % ANS_MOD;\n}\n \nstatic SQWORD subMod(SQWORD x, SQWORD y)\n{\n    return (x - y + ANS_MOD) % ANS_MOD;\n}\n \nstatic SQWORD mulMod(SQWORD x, SQWORD y) \n{\n    return (x * y) % ANS_MOD;\n}\n \nstatic SQWORD powMod(SQWORD x, SQWORD e) {\n    SQWORD v = 1;\n    for (; e; x = mulMod(x, x), e >>= 1) {\n        if (e & 1) {\n            v = mulMod(v, x);\n        }\n    }\n    return v;\n}\n \nstatic SQWORD divMod(SQWORD x, SQWORD y)\n{\n    return mulMod(x, powMod(y, ANS_MOD - 2));\n}\n \n \nstatic SQWORD combMod(SQWORD n, SQWORD k)\n{\n    SQWORD v=1;\n    for(SQWORD i=1; i<=k; i++) {\n        v = divMod(mulMod(v, n-i+1),i);\n    } \n    return v;\n}\n\n/*----------------------------------------------*/\n\ntypedef struct {\n    SDWORD lTo;\n    SQWORD sqCap;\n    SQWORD sqCost;\n    SDWORD lRev;\n} ST_EDGE;\n\n#define MAX_V   (402)\n\nstruct Flow {\nprivate:\n    vector<ST_EDGE> avGraph[MAX_V];\n    SDWORD  alDimsFrom[MAX_V];\n    SDWORD  alDimsTo[MAX_V];\n    SQWORD  sqEdgeNum;\n    SQWORD  asqDist[MAX_V];\n    SDWORD  alPrevV[MAX_V];   \n    SDWORD  alPrevEdge[MAX_V];      /*直前の頂点と辺 */\n\n    SDWORD  alDinic_Level[MAX_V];\n    SDWORD  alDinic_Iter[MAX_V];\n\npublic:\n    Flow() {\n        for (auto v: avGraph) {\n            v.clear();\n        }\n        memset(alDimsFrom, 0, sizeof(alDimsFrom));\n        memset(alDimsTo, 0, sizeof(alDimsTo));\n        memset(asqDist, 0, sizeof(asqDist));\n        memset(alPrevV, 0, sizeof(alPrevV)); \n        memset(alPrevEdge, 0, sizeof(alPrevEdge));\n        memset(alDinic_Level, 0, sizeof(alDinic_Level));\n        memset(alDinic_Iter, 0, sizeof(alDinic_Iter));\n    }\n    void addEdge(SDWORD lFrom, SDWORD lTo, SQWORD sqCap, SQWORD sqCost) {\n//        printf(\"%d ----[%lld] ----> %d\\n\", lFrom, sqCap, lTo);\n        \n        alDimsFrom[lFrom]++;\n        alDimsTo[lTo]++;\n        avGraph[lFrom].push_back((ST_EDGE){lTo, sqCap, sqCost, (SDWORD)(avGraph[lTo].size())});\n        avGraph[lTo].push_back((ST_EDGE){lFrom, 0, -sqCost, (SDWORD)(avGraph[lFrom].size() - 1)});\n    }\n\n    SDWORD minCostFlow(SDWORD lStart, SDWORD lTarget, SQWORD sqFlow)\n    {\n        SQWORD sqRes = 0;\n        SQWORD sqFlowRest = sqFlow;\n        while (0 < sqFlowRest) {\n            /* Bellman-Ford Method */\n            fill(asqDist, asqDist + ArrayLength(asqDist), MAX_SDWORD);\n            asqDist[lStart] = 0;\n            bool bIsUpdate = true;\n            while (bIsUpdate) {\n                bIsUpdate = false;\n                for (SDWORD lV = 0; lV < MAX_V; lV++) {\n                    for (SDWORD lIdx = 0; lIdx < avGraph[lV].size(); lIdx++) {\n                        ST_EDGE &stE = avGraph[lV][lIdx];\n                        if ((asqDist[lV] != MAX_SDWORD)\n                                && (0 < stE.sqCap)\n                                && (asqDist[lV] + stE.sqCost < asqDist[stE.lTo])) {\n                            asqDist[stE.lTo] = asqDist[lV] + stE.sqCost;\n                            alPrevV[stE.lTo] = lV;\n                            alPrevEdge[stE.lTo] = lIdx;\n                            bIsUpdate = true;\n                        }\n                    }\n                }\n            }\n            if (asqDist[lTarget] == MAX_SDWORD) {\n                return -1;\n            }\n\n            SQWORD sqAddFlow = MAX_SQWORD;\n            for (SDWORD lV = lTarget; lV != lStart; lV = alPrevV[lV]) {\n                sqAddFlow = min(sqAddFlow, avGraph[alPrevV[lV]][alPrevEdge[lV]].sqCap);\n            }\n            sqFlowRest -= sqAddFlow;\n            sqRes += sqAddFlow * asqDist[lTarget];      // 後で目的変数は書き換える\n            for (SDWORD lV = lTarget; lV != lStart; lV = alPrevV[lV]) {\n                ST_EDGE &stE = avGraph[alPrevV[lV]][alPrevEdge[lV]];\n                stE.sqCap -= sqAddFlow;\n                avGraph[lV][stE.lRev].sqCap += sqAddFlow;\n            }\n        }\n        return sqRes;\n    }\n\nprivate:\n    SQWORD maxFlowDinicBfs(SDWORD lS)\n    {\n        memset(alDinic_Level, -1, sizeof(alDinic_Level));\n        queue<SDWORD> queSearch;\n        alDinic_Level[lS] = 0;\n        queSearch.push(lS);\n        while (!queSearch.empty()) {\n            SDWORD lV = queSearch.front();\n            queSearch.pop();\n            for (SDWORD lIdx = 0; lIdx < avGraph[lV].size(); lIdx++) {\n                ST_EDGE &stE = avGraph[lV][lIdx];\n                if ((0 < stE.sqCap) && (alDinic_Level[stE.lTo] < 0)) {\n                    alDinic_Level[stE.lTo] = alDinic_Level[lV] + 1;\n                    queSearch.push(stE.lTo);\n                }\n            }\n        }\n\n        return 0;\n    }\n\n    SQWORD maxFlowDinicDfs(SDWORD lV, SDWORD lT, SQWORD sqF)\n    {\n        if (lV == lT) {\n            return sqF;\n        }\n        for (SDWORD &lI = alDinic_Iter[lV]; lI < avGraph[lV].size(); lI++) {\n            ST_EDGE &stE = avGraph[lV][lI];\n            if ((0 < stE.sqCap) && (alDinic_Level[lV] < alDinic_Level[stE.lTo])) {\n                SQWORD sqDiffFlow = maxFlowDinicDfs(stE.lTo, lT, min(sqF, stE.sqCap));\n                if (0 < sqDiffFlow) {\n                    stE.sqCap -= sqDiffFlow;\n                    avGraph[stE.lTo][stE.lRev].sqCap += sqDiffFlow;\n                    return sqDiffFlow;\n                }\n            }\n        }\n        return 0;\n    }\n\npublic:\n    SQWORD MaxFlow(SDWORD lStart, SDWORD lTarget)\n    {\n        SQWORD sqFlow = 0LL;\n        for (;;) {\n            maxFlowDinicBfs(lStart);\n            if (alDinic_Level[lTarget] < 0) {\n                return sqFlow;\n            }\n            memset(alDinic_Iter, 0, sizeof(alDinic_Iter));\n            while (1) {\n                SQWORD sqDiffFlow = maxFlowDinicDfs(lStart, lTarget, MAX_SQWORD);\n                sqFlow += sqDiffFlow;\n                if (0LL == sqDiffFlow) {\n                    break;\n                }\n            }\n        }\n    }\n};\n\n/*----------------------------------------------*/\n\nstatic void getPrimes(vector<SDWORD> &vlPrimes, SDWORD lMax)\n{\n    /* lSearchMax と ループ内の *2 の関係から、入力は3以上とすること */\n    if (!(1 <= lMax)) {\n        printf(\"Oops!\");\n        return;\n    }\n\n    /* 素数のリストを作る */\n    vector<bool> vbIsPrime(lMax + 1, true);\n    SDWORD lSearchMax = sqrt(lMax) + 1;\n    vbIsPrime[0] = false;\n    vbIsPrime[1] = false;\n    for (SDWORD lPrime = 2; lPrime < vbIsPrime.size(); lPrime++) {\n        if (vbIsPrime[lPrime]) {\n            vlPrimes.emplace_back(lPrime);\n            if (lPrime <= lSearchMax) {\n                for (SDWORD lCurNum = lPrime * 2; lCurNum <= lMax; lCurNum += lPrime) {\n                    vbIsPrime[lCurNum] = false;\n                }\n            }\n        }\n    }\n}    \n\n/*----------------------------------------------*/\n\n#define PNT_NO_START    (0)\n#define PNT_NO_OFFSET   (200)\n#define PNT_NO_TARGET   (401)\n#define FLOW_OFFSET     (1000000000)\n#define CAPACITY_INF    (1000000001)\n#define DUMMY_COST      (1)\n\nint main(void)\n{\n    SQWORD sqN = inputSQWORD();\n\n    Flow solverFlow;\n    vector<SQWORD> vsqA;\n    vector<SQWORD> vsqB;\n    vector<SDWORD> vlPrimes;\n\n    getPrimes(vlPrimes, 1e7 + 1);\n    vlPrimes.erase(find(vlPrimes.begin(), vlPrimes.end(), 2));\n\n\n    for (SQWORD sqIdx = 0; sqIdx < sqN; sqIdx++) {\n        SQWORD sqA = inputSQWORD();\n        vsqA.emplace_back(sqA);\n    }\n\n#if 1\n    for (auto it = vsqA.begin(); it != vsqA.end(); ++it) {\n//        printf(\"%lld %lld\\n\", *it, *(it - 1));\n        if (it == vsqA.begin()) {\n            vsqB.emplace_back(*it);\n        } else {\n            if ((*it) - 1 != *(it - 1)) {\n                vsqB.emplace_back(*it);\n            }\n        }\n        if (it == vsqA.end() - 1) {\n            vsqB.emplace_back((*it) + 1);\n        } else {\n            if ((*it) + 1 != *(it + 1)) {\n                vsqB.emplace_back((*it) + 1);\n            }\n        }\n    }\n#else\n    vsqB = vsqA;\n#endif\n\n    vector<SQWORD> vsqCOdd;\n    vector<SQWORD> vsqCEven;\n    \n    unordered_map<SQWORD, SQWORD> mapCEven, mapCOdd;\n\n    SQWORD sqIdx = 1;\n    for (auto b: vsqB) {\n        if (0 == b % 2) {\n            vsqCEven.emplace_back(b);\n            mapCEven[b] = sqIdx;\n        } else {\n            vsqCOdd.emplace_back(b);\n            mapCOdd[b] = sqIdx;\n        }\n        sqIdx++;\n    }\n\n    /* 二部マッチング */\n    for (auto c: vsqCEven) {\n        solverFlow.addEdge(PNT_NO_START, mapCEven[c], 1, DUMMY_COST);\n    }\n    for (auto c: vsqCEven) {\n        solverFlow.addEdge(mapCOdd[c] + PNT_NO_OFFSET, PNT_NO_TARGET, 1, DUMMY_COST);\n    }\n\n    for (auto p: vlPrimes) {\n        for (auto c: vsqCEven) {\n            auto it = lower_bound(vsqCOdd.begin(), vsqCOdd.end(), c + p);\n            if (it != vsqCOdd.end()) {\n                if (*it == c + p) {\n                    solverFlow.addEdge(mapCEven[c], mapCOdd[c + p] + PNT_NO_OFFSET, 1, DUMMY_COST);\n                }\n            }\n        }\n        for (auto c: vsqCOdd) {\n            auto it = lower_bound(vsqCEven.begin(), vsqCEven.end(), c + p);\n            if (it != vsqCEven.end()) {\n                if (*it == c + p) {\n                    solverFlow.addEdge(mapCEven[c + p], mapCOdd[c] + PNT_NO_OFFSET, 1, DUMMY_COST);\n                }\n            }\n        }\n    }\n\n\n\n    SQWORD sqMaxFlow = solverFlow.MaxFlow(PNT_NO_START, PNT_NO_TARGET);\n    SQWORD vsqCRestEven = vsqCEven.size() - sqMaxFlow;\n    SQWORD vsqCRestOdd = vsqCOdd.size() - sqMaxFlow;\n\n    SQWORD sqAns = sqMaxFlow;    \n    sqAns += ((vsqCRestEven / 2) * 2);\n    sqAns += ((vsqCRestOdd / 2) * 2);\n    if (0 < (vsqCRestEven %  2)) {\n        sqAns += 3;\n    }\n\n    printf(\"%lld\\n\", sqAns);\n\n    return 0;\n}\n/*------------------------------------------*/\n"
  },
  {
    "language": "C++",
    "code": "//\n//  main.cpp\n//  F - Prime Flip\n//\n//  Created by Jędrzej Dudzicz on 04/02/2019.\n//  Copyright © 2019 Jędrzej Dudzicz. All rights reserved.\n//\n\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <algorithm>\n#include <cstdio>\n#include <utility>\nusing namespace std;\nconst int MXN=105;\nconst int MXM=1e7+1;\nint n,x;\nint s[MXM],s1[MXN];\nbool sito[MXM];\nint tab1[2*MXN],h;\nbool odw[2*MXN];\nint wynik;\nint main(){\n    for(int i=2;i*i<=MXM-1;i++){\n        if(sito[i]==0){\n            for(int j=i*i;j<=MXM-1;j+=i){\n                if(sito[j]==0)sito[j]=1;\n            }\n        }\n    }\n    sito[0]=1;\n    sito[1]=1;\n    sito[2]=1;\n    scanf(\"%d\",&n);\n    for(int i=0;i<n;i++){\n        scanf(\"%d\",&x);\n        s[x]=1;\n    }\n    for(int i=1;i<=10000001;i++){\n        if(s[i]!=s[i-1]){\n            s1[i]=1;\n            tab1[h++]=i;\n        }\n    }\n    for(int i=0;i<h;i++){\n        if(odw[i]==0){\n            for(int j=0;j<h;j++){\n                if(i!=j&&odw[j]==0&&abs(tab1[j]-tab1[i])>2&&sito[abs(tab1[j]-tab1[i])]==0){\n                    wynik++;\n                    odw[i]=1;odw[j]=1;\n                }\n            }\n        }\n    }\n    for(int i=0;i<h;i++){\n        if(odw[i]==0){\n            for(int j=0;j<h;j++){\n                if(i!=j&&odw[j]==0&&abs(tab1[j]-tab1[i])%2==0){\n                    wynik+=2;\n                    odw[i]=1;odw[j]=1;\n                }\n            }\n        }\n    }\n    for(int i=0;i<h;i++){\n        if(odw[i]==0){\n            for(int j=0;j<h;j++){\n                if(i!=j&&odw[j]==0&&abs(tab1[j]-tab1[i])%2==1){\n                    wynik+=3;\n                    odw[i]=1;odw[j]=1;\n                }\n            }\n        }\n    }\n    for(int i=0;i<h;i++){\n        if(odw[i]==0){\n            odw[i]=1;\n            wynik+=3;\n        }\n    }\n    printf(\"%d\\n\",wynik);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n\nint bipartiteMatching(const vector<vector<int> > &g) {  //g: left side\n\tint nleft = g.size(), nright = 0;\n\tfor (auto es = g.begin(); es != g.end();es++) if (!es->empty()) nright = max(nright, *max_element(es->begin(), es->end()) + 1);\n\tvector<int> matchL(nleft, -1), matchR(nright, -1), prev(nleft), seen(nleft, -1);\n\tfor (int i = 0; i < nleft; i++) {\n\t\tvector<int> stk; stk.push_back(i);\n\t\tseen[i] = i; prev[i] = -1;\n\t\twhile (!stk.empty()) {\n\t\t\tint v = stk.back(); stk.pop_back();\n\t\t\tfor (auto ui = g[v].begin(); ui != g[v].end();ui++) {\n\t\t\t\tint u = *ui;\n\t\t\t\tint j = matchR[u];\n\t\t\t\tif (j == -1) {\n\t\t\t\t\twhile (v != -1) {\n\t\t\t\t\t\tmatchR[u] = v;\n\t\t\t\t\t\tswap(u, matchL[v]);\n\t\t\t\t\t\tv = prev[v];\n\t\t\t\t\t}\n\t\t\t\t\tgoto break_;\n\t\t\t\t}\n\t\t\t\telse if (seen[j] < i) {\n\t\t\t\t\tseen[j] = i; prev[j] = v;\n\t\t\t\t\tstk.push_back(j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\tbreak_:;\n\t}\n\treturn (int)matchL.size() - count(matchL.begin(), matchL.end(), -1);\n}\n\n#define MAX 10000002\n\nint n;\n\nbool use[MAX];\n\nvector<int> v[2];\n\n\nset<int> s;\n\nint main(){\n\tcin >> n;\n\tfor (int i = 0; i < n; i++){\n\t\tint x;\n\t\tscanf(\"%d\", &x);\n\t\ts.insert(x);\n\t}\n\tfor (auto it = s.begin(); it != s.end();it++){\n\t\tint ich = (*it);\n\t\tif (!s.count(ich - 1)){\n\t\t\tv[(ich - 1) & 1].push_back(ich - 1);\n\t\t}\n\t\tif (!s.count(ich + 1)){\n\t\t\tv[ich & 1].push_back(ich);\n\t\t}\n\t}\n\tfor (int i = 2; i < MAX; i++){\n\t\tif (use[i] == false){\n\t\t\tfor (int j = i * 2; j < MAX; j++){\n\t\t\t\tuse[j] = true;\n\t\t\t}\n\t\t}\n\t}\n\tuse[0] = use[1] = use[2] = true;\n\tvector<vector<int> > g(v[0].size());\n\tfor (int j = 0; j < v[0].size(); j++){\n\t\tfor (int k = 0; k < v[1].size(); k++){\n\t\t\tif (!use[abs(v[1][k] - v[0][j])]){\n\t\t\t\tg[j].push_back(k);\n\t\t\t}\n\t\t}\n\t}\n\tint num = bipartiteMatching(g);\n\tint f = ((v[0].size() - num) / 2)*2;\n\tf += num;\n\tf += ((v[1].size() - num) / 2) * 2;\n\tif ((v[0].size()-num) & 1){\n\t\tif ((v[1].size() - num) % 2 == 0){\n\t\t\treturn 1;\n\t\t}\n\t\tf += 3;\n\t}\n\telse{\n\t\tif ((v[1].size() - num) & 1){\n\t\t\treturn 1;\n\t\t}\n\t}\n\tcout << f << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#define fo(i,a,b) for(int i=a;i<=b;i++)\n#define N 210\n#define M 10000010\nusing namespace std;\nint n,a[M],q[N],w[N],bz[M],p[M],last[N],nxt[N*N],to[N*N],tot=0,b[N],jy=0,ans=0;\nvoid link(int x,int y)\n{\n\tnxt[++tot]=last[x];last[x]=tot;to[tot]=y;\n}\nint dg(int x)\n{\n\tif(bz[x]==tot) return 0;\n\tbz[x]=tot;\n\tfor(int i=last[x];i;i=nxt[i])\n\t{\n\t\tint y=to[i];\n\t\tif(b[y]==0||dg(b[y]))\n\t\t{\n\t\t\tb[y]=x;return 1;\n\t\t}\n\t}\n\treturn 0;\n}\nint main()\n{\n\tfo(i,2,10000000)\n\t{\n\t\tif(!bz[i]) p[++p[0]]=i;\n\t\tfo(j,1,p[0])\n\t\t{\n\t\t\tint k=i*p[j];\n\t\t\tif(k>=10000000) break;\n\t\t\tbz[k]=1;\n\t\t\tif(i%p[j]==0) break;\n\t\t}\n\t}\n\tscanf(\"%d\",&n);\n\tfo(i,1,n)\n\t{\n\t\tint x;scanf(\"%d\",&x);\n\t\ta[x]=1;\n\t}\n\tfo(i,1,10000002)\n\tif(a[i]!=a[i-1])\n\t{\n\t\tif(i%2==1) q[++q[0]]=i;\n\t\telse w[++w[0]]=i;\n\t}\n\tbz[1]=bz[2]=1;\n\tfo(i,1,q[0]) fo(j,1,w[0]) if(bz[abs(q[i]-w[j])]==0) link(i,j);\n\tmemset(bz,0,sizeof(bz));\n\tfor(tot=1;tot<=n;tot++) jy+=dg(tot);\n\tans=jy;\n\tans+=2*((q[0]-jy)/2);\n\tans+=2*((w[0]-jy)/2);\n\tans+=3*((q[0]-jy)%2);\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>     \n#define ll long long\n#define mk make_pair\n#define y1 yyyy\nusing namespace std;\n\nconst int N = 5e4 + 5;\nconst int mod = 1e9 + 7;\n\nint n, a[N], my[N], ans;\nbool b[N * 200];\nvector<int> V[2], G[N];\n\nbool find(int x) {\n\tfor (int i = 0; i < G[x].size(); i++) {\n\t\tint u = G[x][i];\n\t\tif (b[u]) continue; \n\t\tb[u] = 1;\n\t\tif (my[u] == -1 || find(my[u])) {\n\t\t\tmy[u] = x;\n\t\t\treturn 1;\n\t\t} \n\t}\n\treturn 0;\n}\n\nbool check(int x) { \n\tif (x <= 2) return 0;\n\tfor (int i = 2; i * i <= x; i++) {\n\t\tif (x % i == 0) return 0;\n\t}  \n\treturn 1;\n}\n\nint main() {\n\tcin >> n;\n\tfor (int i = 1; i <= n; i++) cin >> a[i], b[a[i]] = 1;\n\tfor (int i = 1; i <= 10000001; i++) {\n\t\tif (b[i] != b[i - 1]) V[i & 1].push_back(i);\n\t}\n\tmemset(my, -1, sizeof(my));\n\tfor (int i = 0; i < V[0].size(); i++) {\n\t\tfor (int j = 0; j < V[1].size(); j++) {\n\t\t\tif (check(abs(V[0][i] - V[1][j]))) \n\t\t\t\tG[i].push_back(j);\n\t\t}\n\t}\n\tfor (int i = 0; i < V[0].size(); i++) {\n\t\tfor (int j = 0; j < V[1].size(); j++) b[j] = 0;\n\t\tif (find(i)) ans++;\n\t}\n\tcout << ans + (V[0].size() - ans) / 2 * 2 + (V[1].size() - ans) / 2 * 2 + (V[0].size() - ans) % 2 * 3;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#define fo(i,a,b) for(int i=a;i<=b;i++)\n#define N 210\n#define M 10000002\nusing namespace std;\nint n,a[M],q[N],w[N],bz[M],p[M],last[N],nxt[N],to[N],tot=0,b[N],jy=0,ans=9;\nvoid link(int x,int y)\n{\n\tnxt[++tot]=last[x];last[x]=tot;to[tot]=y;\n}\nint dg(int x)\n{\n\tif(bz[x]==tot) return 0;\n\tbz[x]=tot;\n\tfor(int i=last[x];i;i=nxt[i])\n\t{\n\t\tint y=to[i];\n\t\tif(b[y]==0||dg(b[y]))\n\t\t{\n\t\t\tb[y]=x;return 1;\n\t\t}\n\t}\n\treturn 0;\n}\nint main()\n{\n\tfo(i,2,M-1)\n\t{\n\t\tif(!bz[i]) p[++p[0]]=i;\n\t\tfo(j,1,p[0])\n\t\t{\n\t\t\tint k=i*p[j];\n\t\t\tif(k>=M) break;\n\t\t\tbz[k]=1;\n\t\t\tif(i%p[j]==0) break;\n\t\t}\n\t}\n\tscanf(\"%d\",&n);\n\tfo(i,1,n)\n\t{\n\t\tint x;scanf(\"%d\",&x);\n\t\ta[x]=1;\n\t}\n\tfo(i,1,M-1)\n\tif(a[i]!=a[i-1])\n\t{\n\t\tif(i%2==1) q[++q[0]]=i;\n\t\telse w[++w[0]]=i;\n\t}\n\tbz[1]=bz[2]=1;\n\tfo(i,1,q[0]) fo(j,1,w[0]) if(bz[abs(q[i]-w[j])]==0) link(i,j);\n\tmemset(bz,0,sizeof(bz));\n\tfor(tot=1;tot<=n;tot++) if(!bz[tot]&&b[tot]==0) jy+=dg(tot);\n\tans=(q[0]-jy)-(q[0]-jy)%2;\n\tans=ans+(w[0]-jy)-(w[0]-jy)%2;\n\tans+=jy;\n\tans+=3*((q[0]-jy)%2);\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <cmath>\n#include <set>\n#define lowbit(x) (x&(-x))\n#define MAX(a,b) (a<b?b:a)\n#define MIN(a,b) (a<b?a:b)\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\nconst int N = 1e7;\nconst int maxn = 3e5 + 5;\nll mod = 1e9 + 7;\n\nint n, vis[N + 5];\nvector<int> odd, even, g[205];\n\nint check(int n)\n{\n\tif (n <= 2) return 0;\n\tint m = sqrt(n);\n\tfor (int i = 2; i <= m; i++) if (n%i == 0) return 0;\n\treturn 1;\n}\n\nint link[205], used[205];\nint dfs(int u)\n{\n\tfor (int j = 0; j < g[u].size(); j++)\n\t{\n\t\tint v = g[u][j];\n\t\tif (!used[v])\n\t\t{\n\t\t\tused[v] = 1;\n\t\t\tif (link[v] == -1 || dfs(link[v]))\n\t\t\t{\n\t\t\t\tlink[v] = u;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tint x;\n\t\tscanf(\"%d\", &x);\n\t\tvis[x] = 1;\n\t}\n\tfor (int i = 1; i <= N + 1; i++)\n\t{\n\t\tif (vis[i] != vis[i - 1])\n\t\t{\n\t\t\tif (i & 1) odd.push_back(i);\n\t\t\telse even.push_back(i);\n\t\t}\n\t}\n\n\tint osz = odd.size(), esz = even.size();\n\tfor (int i = 0; i < osz; i++)\n\t{\n\t\tfor (int j = 0; j < esz; ++j)\n\t\t{\n\t\t\tif (check(abs(odd[i] - even[j])))  g[i].push_back(j);\n\t\t}\n\t}\n\n\tmemset(link, -1, sizeof(link));\n\tint k = 0;\n\tfor (int i = 0; i < osz; i++)\n\t{\n\t\tmemset(used, 0, sizeof(used));\n\t\tk += dfs(i);\n\t}\n\n\tprintf(\"%d\", k + ((osz - k) / 2 + (esz - k) / 2) * 2 + ((osz-k) % 2) * 3);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<cstring>\nusing namespace std;\nint n;\nint res;\nvector<int>v;\nint lst=-1;\nint match[210];\nint me,mo;\nint mx;\nbool f[10000010];\nvector<int>ok[210];\nbool vis[210];\nvector<int>prm;\nbool bp(int x)\n{\n\tfor(int i=0;i<ok[x].size();i++)\n\t{\n\t\tint y=ok[x][i];\n\t\tif(vis[y])continue;\n\t\tvis[y]=true;\n\t\tif(match[y]==-1 || bp(match[y]))\n\t\t{\n\t\t\tmatch[y]=x;\n\t\t\treturn true;\n\t\t}\n\t\tvis[y]=false;\n\t}\n\treturn false;\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint x;\n\t\tscanf(\"%d\",&x);\n\t\tif(x!=lst+1)\n\t\t{\n\t\t\tif(lst+1)v.push_back(lst+1);\n\t\t\tv.push_back(x);\n\t\t}\n\t\tlst=x;\n\t\tmx=lst+1;\n\t}\n\tv.push_back(lst+1);\n\tf[1]=true;\n\tfor(int i=2;i<=mx;i++)\n\t{\n\t\tif(f[i])continue;\n\t\tprm.push_back(i);\n\t\tfor(int j=0;j<prm.size() && prm[j]*i<=mx;j++)f[prm[j]*i]=true;\n\t}\n\tint l=v.size();\n\tfor(int i=0;i<l;i++)\n\t{\n\t\tmatch[i]=-1;\n\t\tif(v[i]&1)mo++;else me++;\n\t\tfor(int j=i+1;j<l;j++)\n\t\t{\n\t\t\tif(v[j]-v[i]!=2 && !f[v[j]-v[i]])\n\t\t\t{\n\t\t\t\tok[i].push_back(j);\n\t\t\t\tok[j].push_back(i);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<l;i++)\n\t{\n\t\tmemset(vis,false,sizeof(vis));\n\t\tif(bp(i))res++;\n\t}\n\tres/=2;\n\tprintf(\"%d\",res+((me-res)/2+(mo-res)/2)*2+((me-res)%2)*3);\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <set>\n#include <map>\n#include <list>\n#include <time.h>\n#include <math.h>\n#include <random>\n#include <deque>\n#include <queue>\n#include <cassert>\n#include <unordered_map>\n#include <iomanip>\n\nusing namespace std;\n\ntypedef long long ll;\n\nmt19937 rnd(228);\n\nconst int M = 2e7 + 7;\nconst int N = 1e2 + 1;\n\nbool prime[M];\n\nll dp[N][N][2];\n\nint get(int x)\n{\n    if (x == 0)\n    {\n        return 0;\n    }\n    if (x == 2)\n    {\n        return 3;\n    }\n    if (x > 2 && prime[x])\n    {\n        return 1;\n    }\n    else\n    {\n        return 2 + (x % 2);\n    }\n}\n\nint main()\n{\n#ifdef ONPC\n    freopen(\"a.in\", \"r\", stdin);\n#endif\n    for (int i = 0; i < M; i++)\n    {\n        prime[i] = 1;\n    }\n    prime[1] = 0;\n    for (int i = 2; i < M; i++)\n    {\n        if (prime[i])\n        {\n            for (int j = i + i; j < M; j += i)\n            {\n                prime[j] = 0;\n            }\n        }\n    }\n    int n;\n    scanf(\"%d\", &n);\n    vector <int> x(n);\n    for (int i = 0; i < n; i++)\n    {\n        for (int j = 0; j < n; j++)\n        {\n            dp[i][j][0] = 1e18;\n            dp[i][j][1] = 1e18;\n        }\n    }\n    for (int i = 0; i < n; i++)\n    {\n        scanf(\"%d\", &x[i]);\n        dp[i][i][0] = 0;\n    }\n    for (int len = 1; len <= n; len++)\n    {\n        for (int l = 0; l + len - 1 < n; l++)\n        {\n            int r = l + len - 1;\n            for (int t = 0; t < 2; t++)\n            {\n                for (int j = l; j < r; j++)\n                {\n                    for (int k = j + 1; k < r; k++)\n                    {\n                        ll cost = 0;\n                        cost += dp[l][j][t];\n                        cost += dp[j + 1][k][t];\n                        cost += dp[k + 1][r][t];\n                        if (t == 0)\n                        {\n                            cost += get(x[j + 1] - x[j] - 1);\n                            cost += get(x[k + 1] - x[k] - 1);\n                        }\n                        dp[l][r][t] = min(dp[l][r][t], cost);\n                    }\n                    dp[l][r][t] = min(dp[l][r][t], dp[l][j][t] + (t == 0 ? get(x[j + 1] - x[j] - 1) : 0) + dp[j + 1][r][t]);\n                }\n            }\n            for (int t = 0; t < 2; t++)\n            {\n                dp[l][r][t] = min(dp[l][r][t], dp[l][r][t ^ 1] + get(x[r] - x[l] + 1));\n            }\n        }\n    }\n    printf(\"%lld\\n\", dp[0][n - 1][1]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <iomanip>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <unordered_set>\n#include <unordered_map>\n#include <bitset>\n#include <limits>\n#include <random>\n#include <complex>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cassert>\nusing namespace std;\n\n#define REP(i,n) for (int i = 0; i < n; i++)\ntemplate <class T> using reversed_priority_queue = priority_queue<T, vector<T>, greater<T> >;\ntypedef long long ll;\n\ntemplate <class T> struct FordFulkerson {\n\n    vector < pair < int,int > > maching;\n\n    struct  Edge {\n        int to,rev; T cap;\n        Edge(int t, int r, T c) : to(t), rev(r), cap(c) {}\n    };\n    \n    const T INF = numeric_limits<T>::max() / 2;\n    vector< vector< Edge > > G;\n    vector< bool > used;\n    FordFulkerson (int n) : G(n+1), used(n+1) {}\n   \n    void add_edge(int from, int to, T cap) {\n        G[from].push_back(Edge(to,(int)G[to].size(),cap));\n        G[to].push_back(Edge(from,(int)G[from].size()-1,0));\n    }\n    \n    T dfs(int v, int t, T f) {\n        if (v == t) return f;\n        used[v] = true;\n        for (int i = 0; i < G[v].size(); i++) {\n            Edge &e = G[v][i];\n            if (!used[e.to] && e.cap > 0) {\n                T d = dfs(e.to, t, min(f,e.cap));\n                if (d > 0) {\n                    if (v != 290 && e.to != 291) {\n                        maching.push_back(make_pair(v, e.to - 150));\n                    }\n                    e.cap -= d;\n                    G[e.to][e.rev].cap += d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n   \n    T get_max (int source, int sink) {\n        T flow = 0;\n        while (true) {\n            for (int i = 0; i < used.size(); i++) used[i] = false;\n            T f = dfs(source, sink, INF);\n            if (f == 0) return flow;\n            flow += f;\n        }\n    }\n    \n};\n\n\nbool isPrime(long long n) {\n    if (n <= 2) return false;\n    for (long long i = 2; i * i <= n; i++) if (n % i == 0) return false;\n    return true;\n}\n\nbool flip[10000010];\n\nint main ()\n{\n    int N;\n    cin >> N;\n    vector < int > x(N);\n    REP(i,N) cin >> x[i];\n\n    REP(i,N) {\n        flip[x[i]] = !flip[x[i]];\n        flip[x[i] + 1] = !flip[x[i] + 1];\n    }\n\n    vector < int > xt;\n    for (int i = 0; i < 10000010; i++) {\n        if (flip[i]) xt.push_back(i);\n    }\n\n    FordFulkerson < int > inst(300);\n    for (int i = 0; i < xt.size(); i++) {\n        for (int j = i; j < xt.size(); j++) {\n            if (i == j) continue;\n            int diff = abs(xt[i] - xt[j]);\n            if (isPrime(diff)) {\n                inst.add_edge(i, j + 150, 1);\n            }\n        }\n    }\n    REP(i,N) {\n        inst.add_edge(290, i, 1);\n        inst.add_edge(i + 150, 291, 1);\n    }\n\n    int maxt = inst.get_max (290, 291);\n    vector < pair < int,int > > mc = inst.maching;\n    \n    REP(i,mc.size()) {\n        xt[mc[i].first]  = -1;\n        xt[mc[i].second] = -1;\n    }\n\n    int ans = maxt;\n    REP(i,xt.size()) {\n        REP(j,xt.size()) {\n            if (i == j) continue;\n            if (xt[i] == -1) continue;\n            if (xt[j] == -1) continue;\n            if (abs(xt[i] - xt[j]) % 2 == 0 && abs(xt[i] - xt[j]) != 2) {\n                xt[i] = -1;\n                xt[j] = -1;\n                ans += 2;\n            }\n        }\n    }\n    \n    int sum = 0;\n    REP(i,xt.size()) {\n        if (xt[i] != -1) {\n            sum += 3;\n        }\n    }\n\n    ans += sum / 2;\n    cout << ans << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <set>\n#include <algorithm>\n#include <vector>\n#define REP(i, x, y) for(int i = (int)x; i <= (int)y; i ++)\n#define PER(i, x, y) for(int i = (int)x; i >= (int)y; i --)\n#define FOR(i, x, y) for(int i = (int)x; i <  (int)y; i ++)\nusing namespace std;\n\ntypedef long long s64;\n\nconst int INF = 2147483647;\n\nconst int MaxN = 805;\nconst int MaxM = 200005;\n\ntemplate <class T>\ninline void tension(T &a, const T &b)\n{\n\tif (b < a)\n\t\ta = b;\n}\ntemplate <class T>\ninline void relax(T &a, const T &b)\n{\n\tif (b > a)\n\t\ta = b;\n}\ntemplate <class T>\ninline int size(const T &a)\n{\n\treturn (int)a.size();\n}\n\ninline int getint()\n{\n\tchar c;\n\twhile (c = getchar(), '0' > c || c > '9');\n\n\tint res = c - '0';\n\twhile (c = getchar(), '0' <= c && c <= '9')\n\t\tres = res * 10 + c - '0';\n\treturn res;\n}\n\nconst int MaxNX = MaxN + MaxN;\n\nstruct edge\n{\n\tint v, u, w;\n\n\tedge(){}\n\tedge(const int &_v, const int &_u, const int &_w)\n\t\t: v(_v), u(_u), w(_w){}\n};\n\nint n, m;\nedge mat[MaxNX + 1][MaxNX + 1];\n\nint n_matches;\ns64 tot_weight;\nint mate[MaxNX + 1];\nint lab[MaxNX + 1];\n\nint q_n, q[MaxN];\nint fa[MaxNX + 1], col[MaxNX + 1];\nint slackv[MaxNX + 1];\n\nint n_x;\nint bel[MaxNX + 1], blofrom[MaxNX + 1][MaxNX + 1];\nvector<int> bloch[MaxNX + 1];\n\ninline int e_delta(const edge &e) // does not work inside blossoms\n{\n\treturn lab[e.v] + lab[e.u] - mat[e.v][e.u].w * 2;\n}\ninline void update_slackv(int v, int x)\n{\n\tif (!slackv[x] || e_delta(mat[v][x]) < e_delta(mat[slackv[x]][x]))\n\t\tslackv[x] = v;\n}\ninline void calc_slackv(int x)\n{\n\tslackv[x] = 0;\n\tfor (int v = 1; v <= n; v++)\n\t\tif (mat[v][x].w > 0 && bel[v] != x && col[bel[v]] == 0)\n\t\t\tupdate_slackv(v, x);\n}\n\ninline void q_push(int x)\n{\n\tif (x <= n)\n\t\tq[q_n++] = x;\n\telse\n\t{\n\t\tfor (int i = 0; i < size(bloch[x]); i++)\n\t\t\tq_push(bloch[x][i]);\n\t}\n}\ninline void set_mate(int xv, int xu)\n{\n\tmate[xv] = mat[xv][xu].u;\n\tif (xv > n)\n\t{\n\t\tedge e = mat[xv][xu];\n\t\tint xr = blofrom[xv][e.v];\n\t\tint pr = find(bloch[xv].begin(), bloch[xv].end(), xr) - bloch[xv].begin();\n\t\tif (pr % 2 == 1)\n\t\t{\n\t\t\treverse(bloch[xv].begin() + 1, bloch[xv].end());\n\t\t\tpr = size(bloch[xv]) - pr;\n\t\t}\n\n\t\tfor (int i = 0; i < pr; i++)\n\t\t\tset_mate(bloch[xv][i], bloch[xv][i ^ 1]);\n\t\tset_mate(xr, xu);\n\n\t\trotate(bloch[xv].begin(), bloch[xv].begin() + pr, bloch[xv].end());\n\t}\n}\ninline void set_bel(int x, int b)\n{\n\tbel[x] = b;\n\tif (x > n)\n\t{\n\t\tfor (int i = 0; i < size(bloch[x]); i++)\n\t\t\tset_bel(bloch[x][i], b);\n\t}\n}\n\ninline void augment(int xv, int xu)\n{\n\twhile (true)\n\t{\n\t\tint xnu = bel[mate[xv]];\n\t\tset_mate(xv, xu);\n\t\tif (!xnu)\n\t\t\treturn;\n\t\tset_mate(xnu, bel[fa[xnu]]);\n\t\txv = bel[fa[xnu]], xu = xnu;\n\t}\n}\ninline int get_lca(int xv, int xu)\n{\n\tstatic bool book[MaxNX + 1];\n\tfor (int x = 1; x <= n_x; x++)\n\t\tbook[x] = false;\n\twhile (xv || xu)\n\t{\n\t\tif (xv)\n\t\t{\n\t\t\tif (book[xv])\n\t\t\t\treturn xv;\n\t\t\tbook[xv] = true;\n\t\t\txv = bel[mate[xv]];\n\t\t\tif (xv)\n\t\t\t\txv = bel[fa[xv]];\n\t\t}\n\t\tswap(xv, xu);\n\t}\n\treturn 0;\n}\n\ninline void add_blossom(int xv, int xa, int xu)\n{\n\tint b = n + 1;\n\twhile (b <= n_x && bel[b])\n\t\tb++;\n\tif (b > n_x)\n\t\tn_x++;\n\n\tlab[b] = 0;\n\tcol[b] = 0;\n\n\tmate[b] = mate[xa];\n\n\tbloch[b].clear();\n\tbloch[b].push_back(xa);\n\tfor (int x = xv; x != xa; x = bel[fa[bel[mate[x]]]])\n\t\tbloch[b].push_back(x), bloch[b].push_back(bel[mate[x]]), q_push(bel[mate[x]]);\n\treverse(bloch[b].begin() + 1, bloch[b].end());\n\tfor (int x = xu; x != xa; x = bel[fa[bel[mate[x]]]])\n\t\tbloch[b].push_back(x), bloch[b].push_back(bel[mate[x]]), q_push(bel[mate[x]]);\n\n\tset_bel(b, b);\n\n\tfor (int x = 1; x <= n_x; x++)\n\t{\n\t\tmat[b][x].w = mat[x][b].w = 0;\n\t\tblofrom[b][x] = 0;\n\t}\n\tfor (int i = 0; i < size(bloch[b]); i++)\n\t{\n\t\tint xs = bloch[b][i];\n\t\tfor (int x = 1; x <= n_x; x++)\n\t\t\tif (mat[b][x].w == 0 || e_delta(mat[xs][x]) < e_delta(mat[b][x]))\n\t\t\t\tmat[b][x] = mat[xs][x], mat[x][b] = mat[x][xs];\n\t\tfor (int x = 1; x <= n_x; x++)\n\t\t\tif (blofrom[xs][x])\n\t\t\t\tblofrom[b][x] = xs;\n\t}\n\tcalc_slackv(b);\n}\ninline void expand_blossom1(int b) // lab[b] == 1\n{\n\tfor (int i = 0; i < size(bloch[b]); i++)\n\t\tset_bel(bloch[b][i], bloch[b][i]);\n\n\tint xr = blofrom[b][mat[b][fa[b]].v];\n\tint pr = find(bloch[b].begin(), bloch[b].end(), xr) - bloch[b].begin();\n\tif (pr % 2 == 1)\n\t{\n\t\treverse(bloch[b].begin() + 1, bloch[b].end());\n\t\tpr = size(bloch[b]) - pr;\n\t}\n\n\tfor (int i = 0; i < pr; i += 2)\n\t{\n\t\tint xs = bloch[b][i], xns = bloch[b][i + 1];\n\t\tfa[xs] = mat[xns][xs].v;\n\t\tcol[xs] = 1, col[xns] = 0;\n\t\tslackv[xs] = 0, calc_slackv(xns);\n\t\tq_push(xns);\n\t}\n\tcol[xr] = 1;\n\tfa[xr] = fa[b];\n\tfor (int i = pr + 1; i < size(bloch[b]); i++)\n\t{\n\t\tint xs = bloch[b][i];\n\t\tcol[xs] = -1;\n\t\tcalc_slackv(xs);\n\t}\n\n\tbel[b] = 0;\n}\ninline void expand_blossom_final(int b) // at the final stage\n{\n\tfor (int i = 0; i < size(bloch[b]); i++)\n\t{\n\t\tif (bloch[b][i] > n && lab[bloch[b][i]] == 0)\n\t\t\texpand_blossom_final(bloch[b][i]);\n\t\telse\n\t\t\tset_bel(bloch[b][i], bloch[b][i]);\n\t}\n\tbel[b] = 0;\n}\n\ninline bool on_found_edge(const edge &e)\n{\n\tint xv = bel[e.v], xu = bel[e.u];\n\tif (col[xu] == -1)\n\t{\n\t\tint nv = bel[mate[xu]];\n\t\tfa[xu] = e.v;\n\t\tcol[xu] = 1, col[nv] = 0;\n\t\tslackv[xu] = slackv[nv] = 0;\n\t\tq_push(nv);\n\t}\n\telse if (col[xu] == 0)\n\t{\n\t\tint xa = get_lca(xv, xu);\n\t\tif (!xa)\n\t\t{\n\t\t\taugment(xv, xu), augment(xu, xv);\n\t\t\tfor (int b = n + 1; b <= n_x; b++)\n\t\t\t\tif (bel[b] == b && lab[b] == 0)\n\t\t\t\t\texpand_blossom_final(b);\n\t\t\treturn true;\n\t\t}\n\t\telse\n\t\t\tadd_blossom(xv, xa, xu);\n\t}\n\treturn false;\n}\n\nbool match()\n{\n\tfor (int x = 1; x <= n_x; x++)\n\t\tcol[x] = -1, slackv[x] = 0;\n\n\tq_n = 0;\n\tfor (int x = 1; x <= n_x; x++)\n\t\tif (bel[x] == x && !mate[x])\n\t\t\tfa[x] = 0, col[x] = 0, slackv[x] = 0, q_push(x);\n\tif (q_n == 0)\n\t\treturn false;\n\n\twhile (true)\n\t{\n\t\tfor (int i = 0; i < q_n; i++)\n\t\t{\n\t\t\tint v = q[i];\n\t\t\tfor (int u = 1; u <= n; u++)\n\t\t\t\tif (mat[v][u].w > 0 && bel[v] != bel[u])\n\t\t\t\t{\n\t\t\t\t\tint d = e_delta(mat[v][u]);\n\t\t\t\t\tif (d == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (on_found_edge(mat[v][u]))\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\telse if (col[bel[u]] == -1 || col[bel[u]] == 0)\n\t\t\t\t\t\tupdate_slackv(v, bel[u]);\n\t\t\t\t}\n\t\t}\n\n\t\tint d = INF;\n\t\tfor (int v = 1; v <= n; v++)\n\t\t\tif (col[bel[v]] == 0)\n\t\t\t\ttension(d, lab[v]);\n\t\tfor (int b = n + 1; b <= n_x; b++)\n\t\t\tif (bel[b] == b && col[b] == 1)\n\t\t\t\ttension(d, lab[b] / 2);\n\t\tfor (int x = 1; x <= n_x; x++)\n\t\t\tif (bel[x] == x && slackv[x])\n\t\t\t{\n\t\t\t\tif (col[x] == -1)\n\t\t\t\t\ttension(d, e_delta(mat[slackv[x]][x]));\n\t\t\t\telse if (col[x] == 0)\n\t\t\t\t\ttension(d, e_delta(mat[slackv[x]][x]) / 2);\n\t\t\t}\n\n\t\tfor (int v = 1; v <= n; v++)\n\t\t{\n\t\t\tif (col[bel[v]] == 0)\n\t\t\t\tlab[v] -= d;\n\t\t\telse if (col[bel[v]] == 1)\n\t\t\t\tlab[v] += d;\n\t\t}\n\t\tfor (int b = n + 1; b <= n_x; b++)\n\t\t\tif (bel[b] == b)\n\t\t\t{\n\t\t\t\tif (col[bel[b]] == 0)\n\t\t\t\t\tlab[b] += d * 2;\n\t\t\t\telse if (col[bel[b]] == 1)\n\t\t\t\t\tlab[b] -= d * 2;\n\t\t\t}\n\n\t\tq_n = 0;\n\t\tfor (int v = 1; v <= n; v++)\n\t\t\tif (lab[v] == 0) // all unmatched vertices' labels are zero! cheers!\n\t\t\t\treturn false;\n\t\tfor (int x = 1; x <= n_x; x++)\n\t\t\tif (bel[x] == x && slackv[x] && bel[slackv[x]] != x && e_delta(mat[slackv[x]][x]) == 0)\n\t\t\t{\n\t\t\t\tif (on_found_edge(mat[slackv[x]][x]))\n\t\t\t\t\treturn true;\n\t\t\t}\n\t\tfor (int b = n + 1; b <= n_x; b++)\n\t\t\tif (bel[b] == b && col[b] == 1 && lab[b] == 0)\n\t\t\t\texpand_blossom1(b);\n\t}\n\treturn false;\n}\n\nlong long ori_ans = 0;\n\nint pr[1000005], ptot, vis[10000005];\nvoid pret(){\n\tint n = 1e7;\n\tREP(i, 2, n){\n\t\tif(!vis[i]) pr[++ptot] = i;\n\t\tfor(int j = 1; j <= ptot && (long long)pr[j] * i <= n; j ++){\n\t\t\tvis[i * pr[j]] = 1;\n\t\t\tif(i % pr[j] == 0) break;\n\t\t}\n\t}\n\tvis[1] = 1;\n}\n\nint ask(int x){\n\tif(!vis[x]) return 1;\n\tif(!(x & 1)) return 2;\n\treturn 3;\n}\n\nvoid calc_max_weight_match()\n{\n\tfor (int v = 1; v <= n; v++)\n\t\tmate[v] = 0;\n\n\tn_x = n;\n\tn_matches = 0;\n\ttot_weight = ori_ans;\n\n\tbel[0] = 0;\n\tfor (int v = 1; v <= n; v++)\n\t\tbel[v] = v, bloch[v].clear();\n\tfor (int v = 1; v <= n; v++)\n\t\tfor (int u = 1; u <= n; u++)\n\t\t\tblofrom[v][u] = v == u ? v : 0;\n\n\tint w_max = 0;\n\tfor (int v = 1; v <= n; v++)\n\t\tfor (int u = 1; u <= n; u++)\n\t\t\trelax(w_max, mat[v][u].w);\n\tfor (int v = 1; v <= n; v++)\n\t\tlab[v] = w_max;\n\n\twhile (match())\n\t\tn_matches++;\n\n\tfor (int v = 1; v <= n; v++)\n\t\tif (mate[v] && mate[v] < v)\n\t\t\ttot_weight -= mat[v][mate[v]].w;\n}\n\n\nnamespace In{\n\ttemplate<typename T> inline void chkmin(T &a, const T &b) {if(a > b) a = b;}\n\ttemplate<typename T> inline void chkmax(T &a, const T &b) {if(a < b) a = b;}\n\n\tchar s[1005], t[1005];\n\tint ss[1005], n, cs[405][405];\n\n\tint nn, A[10005];\n\n\tvoid Init(){\n\t\t:: n = n;\n\t\tREP(u, 1, n) REP(v, 1, n) mat[u][v] = edge(u, v, 0);\n\t}\n\n\tvoid add(int u, int v, int w){\n\t\tmat[u][v].w = mat[v][u].w = w;\n\t}\n\n\tvoid Main(){\n/*\n\t\tscanf(\"%d\", &n);\n\n\t\tscanf(\"%s\", s + 1);\n\n\t\tn = strlen(t + 1);\n\n\t\tInit();\n\n\t\tREP(i, 1, n) ss[i] = (t[i] - 48) ^ (s[i] - 48);\n\n\t\tREP(i, 1, n) ss[i] = ss[i] ^ ss[i + 1];\n\n\t\tmemset(cs, 0x3f, sizeof cs);\n\t\tREP(i, 0, n) cs[i][i] = 0;\n\n\t\tREP(i, 1, n) REP(j, 1, n - i + 1){\n\t\t\tint u = i - 1, v = i + j - 1;\n\t\t\tscanf(\"%d\", &cs[u][v]);\n\t\t\tcs[v][u] = cs[u][v];\n\t\t}\n\n\t\tREP(k, 0, n) REP(i, 0, n) REP(j, 0, n) chkmin(cs[i][j], cs[i][k] + cs[k][j]);\n\n\n\t\tREP(i, 1, n) if(ss[i]) {\n\t\t\tori_ans += cs[0][i];\n\t\t\tREP(j, 1, i - 1) if(ss[j]) add(i, j, cs[0][i] + cs[0][j] - cs[i][j]);\n\t\t}\n*/\n\t\tpret();\n\n\t\tscanf(\"%d\", &nn);\n\n\t\tREP(i, 1, nn) scanf(\"%d\", A + i);\n\n\t\tset<int> st;\n\t\tREP(i, 1, nn){\n\t\t\tint u = A[i];\n\t\t\tif(u > 1 && A[i - 1] != A[i] - 1) st.insert(u - 1);\n\t\t\tif(A[i + 1] != A[i] + 1) st.insert(u);\n\t\t}\n\n\t\tstatic int pos[1005];\n\t\tmemset(pos, 0, sizeof pos);\n\t\tint gtot = 0;\n\t\tn = st.size();\n\t\tfor(auto i : st) pos[++ gtot] = i;\n\n\t\tREP(i, 0, n) cs[i][i] = 0;\n\t\tREP(i, 0, n) REP(j, i + 1, n){\n\t\t\tint u = pos[i], v = pos[j];\n\t\t\tcs[i][j] = cs[j][i] = ask(v - u);\n\t\t}\n\n\t\tInit();\n\n\t\tori_ans = 0;\n\t\tREP(i, 1, n){\n\t\t\tori_ans += cs[0][i];\n\t\t\tREP(j, 1, i - 1){\n\t\t\t\tadd(i, j, cs[0][i] + cs[0][j] - cs[i][j]);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\tIn :: Main();\n\tcalc_max_weight_match();\n\tcout << tot_weight << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n\n#define ri register int\n#define ssd 10000010\n#define sid 205\n\nint n, N = 1e7;\nint pr[ssd / 10], tot;\nint nj, no, js[sid], os[sid];\nbool nop[ssd], e[ssd];\n\nint tim, vis[sid], mat[sid];\nbool ex[sid][sid];\n\ninline void Init() {\n    for(ri i = 2; i <= N + 1; i ++) {\n        if(!nop[i]) pr[++ tot] = i;\n        for(ri j = 1; j <= tot; j ++) {\n            int nx = i * pr[j]; if(nx > N + 1) break;\n            nop[nx] = 1; if(i % pr[j] == 0) break;\n        }\n    }\n    nop[1] = nop[2] = 1;\n}\n\ninline int dfs(int o) {\n    for(int i = 1; i <= no; i ++)\n    if(ex[o][i] && vis[i] != tim) {\n        vis[i] = tim;\n        if(!mat[i] || dfs(mat[i])) \n        return mat[i] = o, 1;\n    }\n    return 0;\n}\n\nint main() {\n    Init();\n    cin >> n;\n    for(ri i = 1; i <= n; i ++) { int x; cin >> x; e[x] = 1; }\n    \n    for(ri i = 1; i <= N + 1; i ++)\n    if(e[i] != e[i - 1]) {\n        if(i & 1) js[++ nj] = i;\n        else os[++ no] = i;\n    }\n\n    for(ri i = 1; i <= nj; i ++)\n    for(ri j = 1; j <= no; j ++)\n    if(!nop[abs(js[i] - os[j])]) ex[i][j] = 1;\n\n    int num = 0, ans = 0;\n\n    for(ri i = 1; i <= nj; i ++)\n    ++ tim, num += dfs(i);\n\n    nj -= num; no -= num;\n    ans = num + nj / 2 * 2 + no / 2 * 2 + (nj & 1) * 3;\n    printf(\"%d\\n\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<cstring>\nusing namespace std;\nint n;\nint res;\nvector<int>v;\nint lst=-1;\nint match[210];\nint me,mo;\nint mx;\nbool f[10000010];\nvector<int>ok[210];\nbool vis[210];\nvector<int>prm;\nbool bp(int x)\n{\n\tfor(int i=0;i<ok[x].size();i++)\n\t{\n\t\tint y=ok[x][i];\n\t\tif(vis[y])continue;\n\t\tvis[y]=true;\n\t\tif(match[y]==-1 || bp(match[y]))\n\t\t{\n\t\t\tmatch[y]=x;\n\t\t\treturn true;\n\t\t}\n\t\tvis[y]=false;\n\t}\n\treturn false;\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint x;\n\t\tscanf(\"%d\",&x);\n\t\tif(x!=lst+1)\n\t\t{\n\t\t\tif(lst+1)v.push_back(lst+1);\n\t\t\tv.push_back(x);\n\t\t}\n\t\tlst=x;\n\t\tmx=lst+1;\n\t}\n\tv.push_back(lst+1);\n\tf[1]=true;\n\tfor(int i=2;i<=mx;i++)\n\t{\n\t\tif(f[i])continue;\n\t\tprm.push_back(i);\n\t\tfor(int j=0;j<prm.size() && prm[j]*i<=mx;j++)f[j]=true;\n\t}\n\tint l=v.size();\n\tfor(int i=0;i<l;i++)\n\t{\n\t\tmatch[i]=-1;\n\t\tif(v[i]&1)mo++;else me++;\n\t\tfor(int j=i+1;j<l;j++)\n\t\t{\n\t\t\tif(v[j]-v[i]!=2 && !f[v[j]-v[i]])\n\t\t\t{\n\t\t\t\tok[i].push_back(j);\n\t\t\t\tok[j].push_back(i);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<l;i++)\n\t{\n\t\tmemset(vis,false,sizeof(vis));\n\t\tif(bp(i))res++;\n\t}\n\tres/=2;\n\tprintf(\"%d\",res+((me-res)/2+(mo-res)/2)*2+((me-res)%2)*3);\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<cstring>\n#include<map>\n#include<queue>\n#include<cmath>\nusing namespace std;\ntypedef long long ll;\nconst int N=5005,INF=~0u>>2;\nstruct Edge{int nxt,to;}edge[(N*N)<<3];\nint b[N<<1],n,head[N<<1],num_edge,vis[N<<1],lk[N<<1],even[N<<1],odd[N<<1],even_num,odd_num,ans,k,tot,tim;\nint read(){\n\tint x=0,f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-') f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn f*x;\n}\nvoid add_edge(int from,int to){\n\tedge[++num_edge].nxt=head[from];\n\tedge[num_edge].to=to;\n\thead[from]=num_edge;\n}\nbool find(int x){\n\tfor(int i=head[x];i;i=edge[i].nxt){\n\t\tif(vis[edge[i].to]!=tim){\n\t\t\tvis[edge[i].to]=tim;\n\t\t\tif(!lk[edge[i].to]||find(edge[i].to)){\n\t\t\t\tlk[edge[i].to]=x;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nbool check(int x){\n\tif(x==1) return 0;\n\tfor(int i=2;i*i<=x;++i){\n\t\tif(x%i==0) return 0;\n\t}\n\treturn 1;\n}\nint main(){\n//\tfreopen(\"ex.in\",\"r\",stdin);\n\tn=read();\n\tfor(int i=1;i<=n;++i) b[i]=read();b[0]=-1;\n\tfor(int i=1;i<=n;++i){\n\t\tif(b[i]!=b[i-1]+1){\n\t\t\tif(b[i]%2) odd[++odd_num]=b[i];\n\t\t\telse even[++even_num]=b[i];\n\t\t}\n\t\tif(b[i]+1!=b[i+1]){\n\t\t\tif((b[i]+1)%2) odd[++odd_num]=b[i]+1;\n\t\t\telse even[++even_num]=b[i]+1;\n\t\t}\n\t}\n\tfor(int i=1;i<=odd_num;++i){\n\t\tfor(int j=1;j<=even_num;++j){\n\t\t\tif(check(abs(even[j]-odd[i]))) add_edge(i,j);\n\t\t}\n\t}\n\tfor(int i=1;i<=odd_num;++i){\n\t\ttim++;\n\t\tif(find(i)) k++;\n\t\telse break;\n\t}\n\tans=k+((even_num-k)/2+(odd_num-k)/2)*2+((even_num-k)%2)*3;\n\tprintf(\"%d\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \nconst int maxn = 1e7 + 700;\n \n \nint n,fre[maxn],p[220],ispr[maxn],even,odd,wrong;\nvector <int> edge[220],v2;\n \nbool fin(int u) {\n    if (fre[u]==wrong) return false;\n    fre[u]=wrong;\n    for (int j=0;j<edge[u].size();j++) {\n        int v=edge[u][j];\n       // cout<<u<<\" \"<<v<<endl;\n        if (p[v]==0 || fin(p[v])) {\n            p[v]=u;\n            p[u]=v;\n            return true;\n        }\n    }\n    return false;\n}\n \nint main() {\n  //  freopen(\"in.txt\",\"r\",stdin);\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    ispr[1]=1;\n    for (int i=2;i<maxn;i++)\n        if (ispr[i]==0) {\n            for (int j=i+i;j<maxn;j+=i) ispr[j]=1;\n        }\n    cin>>n;\n    for (int i=1;i<=n;i++) {\n        int x;\n        cin>>x;\n        fre[x]^=1;\n        fre[x+1]^=1;\n    }\n    even=0; odd=0; wrong=2;\n    for (int i=0;i<maxn;i++)\n        if (fre[i]==1) {\n            v2.push_back(i);\n            if (i%2==0) even++;\n            else odd++;\n        }\n    // for (int i=0;i<v2.size();i++) cout<<v2[i]<<\" \";\n   //  cout<<endl;\n   // cout<<\" \" <<even<<\" \"<<odd<<endl;\n    for (int i=0;i<v2.size();i++)\n        for (int j=0;j<v2.size();j++)\n            if (v2[i]%2==0 && v2[j]%2==1 && ispr[ abs(v2[j] - v2[i]) ]==0 && abs(v2[j] - v2[i])%2==1) {\n                edge[i].push_back(j);\n                edge[j].push_back(i);\n            }\n    int cnt=0;\n    for (int i=0;i<v2.size();i++)\n     if (p[i]==0) {\n        wrong++;\n        p[i]=i;\n        cnt+=(fin(i));\n    }\n    cout<< cnt + ((even-cnt)/2 + (odd-cnt)/2) * 2 + ((even-cnt)%2)*3;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h> //hsl2363\n\n#define rep(i, a, b) for(int i = a; i <= b; ++i)\n#define ll long long\n\nusing namespace std;\n\n#define N 5005\n#define M 10000005\n\nint n, tot;\nint prime[M], a[N];\nbool notprime[M], vis[N];\nint odd[N], even[N], cnt[3];\nint fir[N], nx[N * N], to[N * N], match[N];\n\ninline void init() {\n    int MAX = 1e7;\n    notprime[1] = 1;\n    notprime[1] = 1;\n    for (int i = 2; i <= MAX; ++i) {\n        if (!notprime[i]) prime[++tot] = i;\n        for (int j = 1; j <= tot && prime[j] * i <= MAX; ++j) {\n            notprime[i * prime[j]] = 1;\n            if (i % prime[j] == 0) break;\n        }\n    }\n}\n\ninline void Add(int x) { x & 1 ? odd[++cnt[1]] = x : even[++cnt[2]] = x; }\n\ninline void add(int _, int __) {\n    nx[++tot] = fir[_];\n    fir[_] = tot;\n    to[tot] = __;\n}\n\nbool dfs(int x) {\n    if (vis[x]) return false;\n    vis[x] = 1;\n    for (int i = fir[x]; i; i = nx[i]) {\n        int toi = to[i];\n        if (!match[toi] || dfs(match[toi])) {\n            match[toi] = x;\n            return true;\n        }\n    }\n    return false;\n}\n\nint main() {\n    init();\n    scanf (\"%d\", &n);\n    rep (i, 1, n) scanf (\"%d\", &a[i]);\n    sort(a + 1, a + n + 1);\n    int last = a[1];\n    rep (i, 2, n) if (a[i] != a[i - 1] + 1) Add(last), Add(a[i - 1] + 1), last = a[i];\n    Add(last), Add(a[n] + 1);\n//    rep (i, 1, cnt[1]) printf(\"%d%c\", odd[i], \" \\n\"[i == cnt[1]]);\n//    rep (i, 1, cnt[2]) printf(\"%d%c\", even[i], \" \\n\"[i == cnt[2]]);\n    rep (i, 1, cnt[1]) rep (j, 1, cnt[2]) if (!notprime[abs(odd[i] - even[j])])  add(i, j);\n    int res = 0;\n    rep (i, 1, cnt[1]) {\n        memset(vis, 0, sizeof vis);\n        if (dfs(i)) ++res;\n    }\n    int ans = res; cnt[1] -= res, cnt[2] -= res;\n    ans += cnt[1] + cnt[2] + (cnt[1] & 1);\n    printf(\"%d\\n\", ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define Rint register int\nusing namespace std;\nconst int N = 203;\nint n, m, x[N], y[N], ans, flyx[N], flyy[N];\nbool vis[N], edge[N][N];\nset<int> S;\ninline bool isp(int x){\n\tif(x <= 2) return false;\n\tfor(Rint i = 2;i * i <= x;i ++)\n\t\tif(!(x % i)) return false;\n\treturn true;\n}\ninline bool dfs(int x){\n\tfor(Rint y = 1;y <= m;y ++)\n\t\tif(edge[x][y] && !vis[y]){\n\t\t\tvis[y] = true;\n\t\t\tif(!flyy[y] || dfs(flyy[y])){\n\t\t\t\tflyx[x] = y; flyy[y] = x; return true;\n\t\t\t}\n\t\t}\n\treturn false;\n}\nint main(){\n\tscanf(\"%d\", &n);\n\tfor(Rint i = 1;i <= n;i ++){\n\t\tint v; scanf(\"%d\", &v);\n\t\tif(S.count(v)) S.erase(v);\n\t\telse S.insert(v);\n\t\tif(S.count(v + 1)) S.erase(v + 1);\n\t\telse S.insert(v + 1);\n\t}\n\tn = m = 0;\n\tfor(int v : S)\n\t\tif(v & 1) x[++ n] = v;\n\t\telse y[++ m] = v;\n\tfor(Rint i = 1;i <= n;i ++)\n\t\tfor(Rint j = 1;j <= m;j ++)\n\t\t\tedge[i][j] = isp(abs(x[i] - y[j]));\n\tfor(Rint i = 1;i <= n;i ++) if(!flyx[i]){\n\t\tmemset(vis, 0, sizeof vis); ans += dfs(i);\n\t}\n\tprintf(\"%d\\n\", n + m + (n - ans & 1) - ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int N=1005,M=40005,oo=1e9;\nstruct edge{\n\tint di,nextt,ed;\n}e[M];\nint son[N],nedge,cur[N],deep[N],n,m;\ninline void aedge(int a,int b,int c){\n\te[++nedge].nextt=son[a];\n\tson[a]=nedge;\n\te[nedge].ed=b;\n\te[nedge].di=c;\n}\ninline void insert(int a,int b,int c){\n\taedge(a,b,c); aedge(b,a,0); //cout<<a<<\" \"<<b<<endl;\n}\ninline bool bfs(int s,int t){\n\tfor(int i=1;i<N;i++)deep[i]=oo;\n    for(int i=1;i<N;i++)cur[i]=son[i];\n    deep[s]=0;\n    queue<int> q;\n    q.push(s);\n    while(!q.empty()){\n        int now=q.front();q.pop();\n        for(int tmp=son[now];tmp;tmp=e[tmp].nextt)\n            if(deep[e[tmp].ed]>=oo&&e[tmp].di){deep[e[tmp].ed]=deep[now]+1,q.push(e[tmp].ed);}\n    }\n    return deep[t]<oo;\n}\nint dfs(int now,int t,int limit){\n    if(!limit||now==t) return limit;\n    int flow=0,f;\n    for(int tmp=cur[now];tmp;tmp=e[tmp].nextt){\n        cur[now]=tmp;\n        if(deep[e[tmp].ed]==deep[now]+1&&(f=dfs(e[tmp].ed,t,min(limit,e[tmp].di)))){\n            flow+=f; limit-=f; e[tmp].di-=f; e[((tmp-1)^1)+1].di+=f; if(!limit)break;\n        }\n    }\n    return flow;\n}\ninline int dinic(int s,int t){\n    int ans=0;\n    while(bfs(s,t))ans+=dfs(s,t,oo);\n    return ans;\n}\ninline int read(){\n\tint x=0;char ch=getchar();bool positive=1;\n\tfor(;!isdigit(ch);ch=getchar())\tif(ch == '-')\tpositive=0;\n\tfor(;isdigit(ch);ch=getchar())\tx=x * 10 + ch - '0';\n\treturn positive ? x : -x;\n}\ninline void write(int a){\n    if(a>=10)write(a/10);\n    putchar('0'+a%10);\n}\ninline void writeln(int a){\n    if(a<0){\n    \ta=-a;putchar('-');\n\t}\n\twrite(a);puts(\"\");\n}\nconst int P=10000005;\nint tot,q[P/10];\nbool heshu[P],a[P];\nint b[205];\nint main(){\n    n=read();\n\tfor(int i=2;i*i<P;i++)if(!heshu[i]){\n\t\tfor(int j=i+i;j<P;j+=i)heshu[j]=1;\n\t}\n\ttot=0;\n\tfor(int i=1;i<=n;i++){\n\t\tint t=read(); a[t]^=1; a[t+1]^=1;\n\t}\n\theshu[1]=1;\n\tint jb=0;\n\tfor(int i=1;i<P;i++)if(a[i])b[++jb]=i;\n\tfor(int i=1;i<=jb;i++)if(b[i]&1){\n\t\tfor(int j=1;j<=jb;j++)if(b[j]%2==0){\n\t\t\tif(!heshu[abs(b[i]-b[j])]){insert(i,j,1);}\n\t\t}\n\t}\n\tint s=jb+1,t=jb+2;\n\tfor(int i=1;i<=jb;i++)if(b[i]&1){insert(s,i,1); tot++; }else insert(i,t,1);\n\tint jj=dinic(s,t); \n\tcout<<jj+(jb-jj*2)+((tot-jj)&1)<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define FOR(i, a, b) for(ll i = (a); i < (b); ++i)\n#define FORR(i, a, b) for(ll i = (a); i > (b); --i)\n#define REP(i, n) for(ll i = 0; i < (n); ++i)\n#define REPR(i, n) for(ll i = n; i >= 0; i--)\n#define FOREACH(x, a) for(auto &(x) : (a))\n#define VECCIN(x)                                                              \\\n    for(auto &youso_ : (x)) cin >> youso_\n#define bitcnt __builtin_popcount\n#define SZ(x) ((ll)(x).size())\n#define fi first\n#define se second\n#define All(a) (a).begin(), (a).end()\ntemplate <typename T = long long> inline T IN() {\n    T x;\n    cin >> x;\n    return (x);\n}\ninline void CIN() {}\ntemplate <class Head, class... Tail>\ninline void CIN(Head &&head, Tail &&... tail) {\n    cin >> head;\n    CIN(move(tail)...);\n}\n#define CINT(...)                                                              \\\n    int __VA_ARGS__;                                                           \\\n    CIN(__VA_ARGS__)\n#define DCIN(...)                                                              \\\n    double __VA_ARGS__;                                                        \\\n    CIN(__VA_ARGS__)\n#define LCIN(...)                                                              \\\n    ll __VA_ARGS__;                                                            \\\n    CIN(__VA_ARGS__)\n#define SCIN(...)                                                              \\\n    string __VA_ARGS__;                                                        \\\n    CIN(__VA_ARGS__)\n#define Yes(a) cout << (a ? \"Yes\" : \"No\") << \"\\n\"\n#define YES(a) cout << (a ? \"YES\" : \"NO\") << \"\\n\"\n#define Printv(v)                                                              \\\n    {                                                                          \\\n        FOREACH(x, v) { cout << x << \" \"; }                                    \\\n        cout << \"\\n\";                                                          \\\n    }\ntemplate <typename T = string> inline void eputs(T s) {\n    cout << s << \"\\n\";\n    exit(0);\n}\ntemplate <typename A, size_t N, typename T>\nvoid Fill(A (&array)[N], const T &val) {\n    std::fill((T *)array, (T *)(array + N), val);\n}\ntemplate <typename T> using PQG = priority_queue<T, vector<T>, greater<T>>;\ntemplate <typename T> using PQ = priority_queue<T>;\n\ntypedef long long ll;\ntypedef unsigned long long ul;\ntypedef vector<ll> VL;\ntypedef pair<ll, ll> PL;\n\nconst int INF = 1e9;\nconst int MOD = 1e9 + 7;\nconst double PI = atan(1.0) * 4.0;\n// const int MOD = 998244353;\nconst ll LINF = 9e18;\nconst ll dx[] = {1, 0, -1, 0};\nconst ll dy[] = {0, 1, 0, -1};\n\nvoid cinfast() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n}\n\nstruct edge {\n    ll to, cap, rev;\n};\n\nstruct Mflow {\n    vector<vector<edge>> G;\n    VL level, iter;\n    ll N;\n\n    Mflow(ll size) : N(size) { init(size); };\n\n    void init(ll size) { G.resize(N); }\n\n    void add_edge(ll from, ll to, ll cap) {\n        G[from].push_back({to, cap, (ll)G[to].size()});\n        G[to].push_back({from, 0, (ll)G[from].size() - 1});\n    }\n    void bfs(ll s) {\n        level.assign(N, -1);\n        queue<ll> q;\n        level[s] = 0;\n        q.push(s);\n        while(!q.empty()) {\n            ll now = q.front();\n            q.pop();\n            FOREACH(e, G[now]) {\n                if(e.cap > 0 && level[e.to] == -1) {\n                    level[e.to] = level[now] + 1;\n                    q.push(e.to);\n                }\n            }\n        }\n    }\n\n    ll dfs(ll now, ll t, ll f) {\n        if(now == t) return f;\n        for(ll &i = iter[now]; i < G[now].size(); i++) {\n            edge &e = G[now][i];\n            if(e.cap > 0 && level[now] < level[e.to]) {\n                ll d = dfs(e.to, t, min(f, e.cap));\n                if(d > 0) {\n                    e.cap -= d;\n                    G[e.to][e.rev].cap += d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n\n    ll max_flow(ll s, ll t) {\n        ll flow = 0;\n        while(1) {\n            bfs(s);\n            if(level[t] < 0) return flow;\n            iter.assign(N, 0);\n            ll f;\n            while((f = dfs(s, t, LINF)) > 0) {\n                flow += f;\n            }\n        }\n    }\n};\n\nll m, n;\nmap<ll, ll> com;\n\nbool is_prime[(ll)1e7 + 1];\nbool is_prime_small[(ll)1e7 + 1];\n\nVL seg_sieve(ll a, ll b) {\n    VL res;\n    for(ll i = 2; i * i < b; i++) is_prime_small[i] = true;\n    REP(i, b - a) is_prime[i] = true;\n    for(ll i = 2; i * i < b; i++) {\n        if(is_prime_small[i]) {\n            for(ll j = 2 * i; j * j < b; j += i) is_prime_small[j] = false;\n            for(ll j = max(2LL, (a + i - 1) / i) * i; j < b; j += i)\n                is_prime[j - a] = false;\n        }\n    }\n    REP(i, b - a) if(is_prime[i]) res.emplace_back(i + a);\n    return res;\n}\n\nsigned main() {\n    LCIN(N);\n    REP(i, N) {\n        LCIN(x);\n        com[x] ^= 1;\n        com[x + 1] ^= 1;\n    }\n    VL odd, even;\n    FOREACH(x, com) {\n        if(x.second) {\n            if(x.first % 2)\n                odd.emplace_back(x.first);\n            else\n                even.emplace_back(x.first);\n        }\n    }\n    ll o = odd.size(), e = even.size();\n    Mflow mf(o + e + 2);\n    REP(i, o) mf.add_edge(o + e, i, 1);\n    REP(i, e) mf.add_edge(o + i, o + e + 1, 1);\n    seg_sieve(0, 10000001);\n    REP(i, o) REP(j, e) {\n        if(is_prime[abs(odd[i] - even[j])] && abs(odd[i] - even[j]) > 2) {\n            mf.add_edge(i, o + j, 1);\n        }\n    }\n    ll ans = mf.max_flow(o + e, o + e + 1);\n    cout << ans + (o - ans) / 2 * 2 + (e - ans) / 2 * 2 + (o - ans) % 2 * 3\n         << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "\n// MAGRANT - GNC19 - TEMPLATE 2.1\n// 2017/8/6 - AtCoder Regular Contest 080 - Delta\n// Significant Time Tags:\n// Algorithm: #, #min/\n// Coding: #, #min.\n// Overall Summary:\n\n#define _CRT_SECURE_NO_WARNINGS\n\n#define N (1<<7)\n#define T (10000007)\n#define MODULO (1000000007)\n#define HA1 (2420609)\n#define HA2 (19260817)\n\n#include <cstdio>\n#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n#include <string>\n#include <algorithm>\n#include <stack>\n#include <vector>\n#include <set>\n#include <map>\n#include <deque>\n#include <queue>\n#include <complex>\nusing namespace std;\n\nnamespace MRAND\n{\n\tclass MRNDS\n\t{\n\tpublic:\n\t\tint ngf;\n\t\tunsigned int lgf;\n\t\tMRNDS()\n\t\t{\n\t\t\tngf = HA1*HA2;\n\t\t\tlgf = HA1 - HA2*ngf;\n\t\t}\n\t\tMRNDS(long long rgf)\n\t\t{\n\t\t\tlgf = rgf&((1LL << 32) - 1LL);\n\t\t\tngf = (rgf >> 31);\n\t\t\tngf += 2LL * lgf;\n\t\t\tngf *= HA2;\n\t\t\tlgf += HA1;\n\t\t}\n\t\tMRNDS operator* (const MRNDS &mrs)const\n\t\t{\n\t\t\tMRNDS Res;\n\t\t\tRes.ngf += ngf*mrs.lgf;\n\t\t\tRes.ngf -= mrs.ngf*lgf;\n\t\t\tRes.ngf *= HA1;\n\t\t\tRes.lgf *= HA2;\n\t\t\treturn Res;\n\t\t}\n\t}curl, curr;\n\tinline void InitRand(MRNDS &Lmrs, MRNDS &Rmrs)\n\t{\n\t\tcurl = Lmrs;\n\t\tcurr = Rmrs;\n\t\tcurl = curl*curr;\n\t\tcurl.ngf += HA2;\n\t}\n\tinline int GetRand()\n\t{\n\t\tcurl = curl*curr;\n\t\treturn (curl.lgf*HA1 - curr.ngf*HA2);\n\t}\n}\n\nint tot;\nbool chk[T];\nint prm[T];\nint n, cnt;\nint a[N];\npair<int, int> cp[N];\nint dp1[N][N], dp2[N][N];\nint len1[N][N], len2[N][N];\n\ninline int GetLen1(int uu, int vv)\n{\n\treturn len1[uu][vv];\n}\n\ninline int GetLen2(int uu, int vv)\n{\n\treturn len2[uu][vv];\n}\n\ninline int GetTms(int xx)\n{\n\tif (xx == 1)\n\t{\n\t\treturn 3;\n\t}\n\tif (!(xx & 1))\n\t{\n\t\treturn 2;\n\t}\n\telse if (!chk[xx])\n\t{\n\t\treturn 1;\n\t}\n\telse\n\t{\n\t\treturn 3;\n\t}\n}\n\nint main()\n{\n\tmemset(chk, false, sizeof(chk));\n\ttot = 0;\n\tfor (int i = 2;i < T - 4;i++)\n\t{\n\t\tif (!chk[i])\n\t\t{\n\t\t\tprm[tot++] = i;\n\t\t}\n\t\tfor (int j = 0;j < tot;j++)\n\t\t{\n\t\t\tif ((long long)i*(long long)prm[j] > (long long)(T - 3))\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tchk[i*prm[j]] = true;\n\t\t\tif (i%prm[j] == 0)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tscanf(\"%d\", &n);\n\tfor (int i = 0;i < n;i++)\n\t{\n\t\tscanf(\"%d\", &a[i]);\n\t}\n\tcp[0].first = 0;\n\tfor (int i = 1;i < n;i++)\n\t{\n\t\tif (a[i] != a[i - 1] + 1)\n\t\t{\n\t\t\tcp[cnt].second = i - 1;\n\t\t\tcp[++cnt].first = i;\n\t\t}\n\t}\n\tcp[cnt].second = n - 1;\n\tcnt++;\n\tfor (int i = 0;i < cnt;i++)\n\t{\n\t\tfor (int j = i;j < cnt;j++)\n\t\t{\n\t\t\tlen1[i][j] = a[cp[j].second] - a[cp[i].first] + 1;\n\t\t}\n\t}\n\tfor (int i = 0;i < cnt - 1;i++)\n\t{\n\t\tfor (int j = i;j < cnt - 1;j++)\n\t\t{\n\t\t\tlen2[i][j] = a[cp[j + 1].first] - a[cp[i].second] - 1;\n\t\t}\n\t}\n\tfor (int len = 1;len <= cnt;len++)\n\t{\n\t\tfor (int i = 0;i < cnt;i++)\n\t\t{\n\t\t\tint j = i + len - 1;\n\t\t\tif (j >= cnt)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (len == 1)\n\t\t\t{\n\t\t\t\tdp1[i][j] = GetTms(GetLen1(i, j));\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tdp1[i][j] = GetTms(GetLen1(i, j)) + dp2[i][j - 1];\n\t\t\t}\n\t\t\tfor (int kk = i;kk < j;kk++)\n\t\t\t{\n\t\t\t\tdp1[i][j] = min(dp1[i][j], dp1[i][kk] + dp1[kk + 1][j]);\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0;i < cnt - 1;i++)\n\t\t{\n\t\t\tint j = i + len - 1;\n\t\t\tif (j >= cnt - 1)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (len == 1)\n\t\t\t{\n\t\t\t\tdp2[i][j] = GetTms(GetLen2(i, j));\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tdp2[i][j] = GetTms(GetLen2(i, j)) + dp1[i + 1][j];\n\t\t\t}\n\t\t\tfor (int kk = i;kk < j;kk++)\n\t\t\t{\n\t\t\t\tdp2[i][j] = min(dp2[i][j], dp2[i][kk] + dp2[kk + 1][j]);\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\", dp1[0][cnt - 1]);\n\t//system(\"pause\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int inf=0x3f3f3f3f;\nint read()\n{\n\tint r=0,f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9')r=(r<<1)+(r<<3)+ch-'0',ch=getchar();\n\treturn r*f;\n}\nbool np[10000100];\nint pri[5000500],tot;\nvoid Euler()\n{\n\tnp[1]=1;int ma=1e7;\n\tfor(int i=2;i<=ma;++i)\n\t{\n\t\tif(!np[i])pri[++tot]=i;\n\t\tfor(int j=1;j<=tot&&i*pri[j]<=ma;++j)\n\t\t{\n\t\t\tnp[i*pri[j]]=1;\n\t\t\tif(i%pri[j]==0)break;\n\t\t}\n\t}\n}\nint n;\nbool po[10000100];\nint pos[110];\nstruct data{\n\tint to,nxt,c;\n}mp[100100];\nint head[220],cnt=1;\nint s,t;\nint cur[220];\nvoid link(int x,int y,int c)\n{\n\tmp[++cnt].to=y;\n\tmp[cnt].nxt=head[x];\n\tmp[cnt].c=c;\n\thead[x]=cnt;\n}\nvoid add(int x,int y,int c)\n{\n\tlink(x,y,c);link(y,x,0);\n//\tcout<<\"x: \"<<x<<\" y: \"<<y<<endl;\n}\nint dis[220];\nqueue<int>q;\nbool bfs()\n{\n\tfor(int i=1;i<=t;++i)dis[i]=0;\n\tdis[s]=1;q.push(s);\n\tint u;\n\twhile(!q.empty())\n\t{\n\t\tu=q.front();q.pop();\n\t\tfor(int i=head[u];i;i=mp[i].nxt)\n\t\t\tif(!dis[mp[i].to])\n\t\t\t\tdis[mp[i].to]=dis[u]+1,q.push(mp[i].to);\n\t}\n\treturn dis[t];\n}\nint dfs(int x,int f)\n{\n\tif(x==t)return f;\n//\tcout<<\"x: \"<<x<<\" f: \"<<f<<endl;\n\tint fl,rf=0;\n\tfor(int& i=cur[x];i;i=mp[i].nxt)\n\t\tif(dis[mp[i].to]==dis[x]+1&&mp[i].c)\n\t\t{\n\t\t\tfl=dfs(mp[i].to,min(f,mp[i].c));\n\t\t\tif(fl)\n\t\t\t{\n\t\t\t\tf-=fl;rf+=fl;\n\t\t\t\tmp[i].c-=fl;\n\t\t\t\tmp[i^1].c+=fl;\n\t\t\t\tif(!f)break;\n\t\t\t}\n\t\t}\n\treturn rf;\n}\nint Dinic()\n{\n\tint maxflow=0,flow;\n\twhile(bfs())\n\t{\n\t\tfor(int i=1;i<=t;++i)cur[i]=head[i];\n\t\twhile(flow=dfs(s,inf))maxflow+=flow;\n\t}\n\treturn maxflow;\n}\nint main()\n{\n\tEuler();\n//\tfor(int i=1;i<=10;++i)cout<<np[i]<<\" \";cout<<endl;\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;++i)po[read()]=1;\n\tn=0;\n\tfor(int i=1;i<=1e7+1;++i)\n\t\tif(po[i]!=po[i-1]) pos[++n]=i;\n\ts=n+1,t=n+2;\n\tint odd=0,even=0;\n//\tfor(int i=1;i<=n;++i)cout<<pos[i]<<\" \";cout<<endl;\n\tfor(int i=1;i<=n;++i)\n\t\tif(pos[i]&1)\n\t\t{\n\t\t\tadd(s,i,1);\n\t\t\todd++;\n\t\t\tfor(int j=1;j<=n;++j)\n\t\t\t\tif((!(pos[j]&1))&&(!np[abs(pos[i]-pos[j])]))\n\t\t\t\t\tadd(i,j,1);\n\t\t}\n\tfor(int i=1;i<=n;++i)\n\t\tif(!(pos[i]&1))add(i,t,1),even++;\n//\tcout<<\"even: \"<<even<<\" odd: \"<<odd<<endl;\n\tint ans=Dinic();\n//\tcout<<\"ans: \"<<ans<<endl;\n\teven-=ans;odd-=ans;\n\tif((even&1)||(odd&1))ans+=3;\n\teven-=even&1;odd-=odd&1;\n\tans+=even+odd;\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define maxn 10000005\n#define maxv 205\nusing namespace std;\nint prime[maxn/2];\nbool vis[maxn];\nint inde=0;\nvoid primejudge(int n)\n{\n    vis[1]=true;\n    int i,j;\n    for(i=2;i<=n;i++)\n    {\n        if(!vis[i])\n        {\n            prime[inde++]=i;\n        }\n        for(j=0;j<inde&&prime[j]*i<=n;j++)\n            {\n                vis[i*prime[j]]=true;\n                if(i%prime[j]==0) break;\n            }\n    }\n    vis[2]=true;\n}\nint cnt1,cnt2;\nbool used[maxv];\nint bel[maxv];\nbool v[maxn];\nint s[maxn];\nint mp1[maxv];\nint mp2[maxv];\nbool match[maxv][maxv];\nbool findd(int x)\n{   int i;\n    for(i=0;i<cnt2;i++)\n    {\n        if(match[x][i]&&used[i]==false)\n        {\n            used[i]=true;\n            if(!bel[i]||findd(bel[i]))\n            {\n                bel[i]=x;\n                return true;\n            }\n        }\n    }\n    return false;\n}\nint main()\n{\n  int n,i,u,cnt=0;\n  primejudge(10000003);\n  scanf(\"%d\",&n);\n  for(i=1;i<=n;i++)\n  {\n      scanf(\"%d\",&u);\n      v[u]=true;\n  }\n  for(i=1;i<=maxn-2;i++)\n  {\n      if(v[i]!=v[i-1])\n      {\n          s[cnt++]=i;\n      }\n  }\n  for(i=0;i<cnt;i++)\n  {\n      if(s[i]&1)\n      {\n          mp1[cnt1++]=s[i];\n      }\n      else\n      {\n          mp2[cnt2++]=s[i];\n      }\n  }\n  for(i=0;i<cnt1;i++)\n  {\n      for(int j=0;j<cnt2;j++)\n      {\n          if(!vis[abs(mp1[i]-mp2[j])])\n          {\n              match[i][j]=true;\n          }\n      }\n  }\n  int sum=0;\n  for(i=0;i<cnt1;i++)\n  {\n      memset(used,false,sizeof(used));\n      if(findd(i)) sum++;\n  }\n  int ans=sum;\n  cnt1-=sum;\n  cnt2-=sum;\n  ans+=cnt1/2*2;\n  ans+=cnt2/2*2;\n  ans+=cnt1%2*3;\n  cout<<ans<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <set>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <cmath>\n#include <vector>\n#include <bitset>\n#include <cstdio>\n#include <cctype>\n#include <string>\n#include <numeric>\n#include <cstring>\n#include <cassert>\n#include <climits>\n#include <cstdlib>\n#include <iostream>\n#include <algorithm>\n#include <functional>\nusing namespace std ;\n#define int long long\n#define rep(i, a, b) for (ll i = (a); i <= (b); ++i)\n#define per(i, a, b) for (ll i = (a); i >= (b); --i)\n#define loop(it, v) for (auto it = v.begin(); it != v.end(); it++)\n#define cont(i, x) for (ll i = head[x]; i; i = edge[i].nex)\n#define clr(a) memset(a, 0, sizeof(a))\n#define ass(a, cnt) memset(a, cnt, sizeof(a))\n#define cop(a, b) memcpy(a, b, sizeof(a))\n#define lowbit(x) (x & -x)\n#define all(x) x.begin(), x.end()\n#define SC(t, x) static_cast <t> (x)\n#define ub upper_bound\n#define lb lower_bound\n#define pqueue priority_queue\n#define mp make_pair\n#define pb push_back\n#define pof pop_front\n#define pob pop_back\n#define fi first\n#define se second\n#define y1 y1_\n#define Pi acos(-1.0)\n#define iv inline void\n#define enter putchar('\\n')\n#define siz(x) ((ll)x.size())\n#define file(x) freopen(x\".in\", \"r\", stdin),freopen(x\".out\", \"w\", stdout)\ntypedef double db ;\ntypedef long long ll ;\ntypedef unsigned long long ull ;\ntypedef pair <ll, ll> pii ;\ntypedef vector <ll> vi ;\ntypedef vector <pii> vii ;\ntypedef queue <ll> qi ;\ntypedef queue <pii> qii ;\ntypedef set <ll> si ;\ntypedef map <ll, ll> mii ;\ntypedef map <string, ll> msi ;\nconst ll maxn = 2e6 + 100 ;\nconst ll inf = 0x3f3f3f3f ;\nconst ll iinf = 1 << 30 ;\nconst ll linf = 2e18 ;\nconst ll mod = 998244353 ;\nconst double eps = 1e-7 ;\ntemplate <class T = ll> T chmin(T &a, T b) { return a = min(a, b);}\ntemplate <class T = ll> T chmax(T &a, T b) { return a = max(a, b);}\ntemplate <class T = ll> T read()\n{\n\tT f = 1, a = 0;\n\tchar ch = getchar() ;\n\twhile (!isdigit(ch)) { if (ch == '-') f = -1 ; ch = getchar() ; }\n\twhile (isdigit(ch)) { a =  (a << 3) + (a << 1) + ch - '0' ; ch = getchar() ; }\n\treturn a * f ;\n}\n\nll n, ans;\n\nll a[maxn], b[maxn], tot;\n\nsi s;\n\nvi edge[maxn];\n\nbool is_prime(ll x)\n{\n\tif(x == 2) return 0;\n\trep(i, 2, sqrt(x)) if(x % i == 0) return 0;\n\treturn 1;\n}\n\nll col[maxn];\n\nvoid paint(ll now, ll x)\n{\n\tif(col[now]) return ;\n\tcol[now] = x;\n\tif(x == 1) \n\tfor(ll to : edge[now]) paint(to, x ^ 3);\n}\n\nll match[maxn], vis[maxn];\n\nll dfs(ll now)\n{\n\tfor(ll to : edge[now])\n\t{\n\t\tif(vis[to]) continue;\n\t\tvis[to] = 1;\n\t\tif(!match[to] || dfs(match[to]))\n\t\t{\n\t\t\tmatch[now] = to, match[to] = now;\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nvoid hungarian()\n{\n\trep(i, 1, tot)\n\t{\n\t\tif(col[i] == 2) continue;\n\t\trep(j, 1, tot) vis[j] = 0;\n\t\tans += dfs(i);\n\t}\n}\n\nll odd, even;\n\nsigned main()\n{\n\tn = read();\n\trep(i, 1, n) a[i] = read();\n\ta[0] = -114514;\n\tsort(a + 1, a + n + 1);\n\t// rep(i, 1, n) printf(\"%lld%c\", a[i], \" \\n\"[i == n]);\n\trep(i, 1, n)\n\t{\n\t\tif(a[i - 1] != a[i] - 1) s.insert(a[i]);\n\t\tif(a[i + 1] != a[i] + 1) s.insert(a[i] + 1);\n\t}\n\tfor(ll i : s) b[++ tot] = i;//, printf(\"%lld \", i);\n\t// enter;\n\trep(i, 1, tot) rep(j, i + 1, tot) if(is_prime(b[j] - b[i])) edge[i].pb(j), edge[j].pb(i);//, printf(\"%lld -> %lld\\n\", i, j);\n\trep(i, 1, tot) if(!col[i]) paint(i, 1);\n\thungarian();\n\trep(i, 1, tot)\n\t{\n\t\tif(match[i]) continue;\n\t\tif(b[i] & 1) odd ++;\n\t\telse even ++;\n\t}\n\tans += odd / 2 * 2, ans += even / 2 * 2;\n\tif(odd & 1) ans += 3;\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nstruct edge {\n\tint to, cap, rev;\n};\n\nvector<edge>X[1009]; bool used[1009];\n\nvoid add_edge(int u, int v, int w) {\n\tX[u].push_back(edge{ v,w,(int)X[v].size() });\n\tX[v].push_back(edge{ u,0,(int)X[u].size() - 1 });\n}\nint dfs(int pos, int to, int flow) {\n\tif (pos == to) return flow;\n\tused[pos] = true;\n\tfor (int i = 0; i < X[pos].size(); i++) {\n\t\tif (used[X[pos][i].to] == true || X[pos][i].cap <= 0) continue;\n\t\tint G = dfs(X[pos][i].to, to, min(X[pos][i].cap, flow));\n\t\tif (G == 0) continue;\n\t\tX[pos][i].cap -= G;\n\t\tX[X[pos][i].to][X[pos][i].rev].cap += G;\n\t\treturn G;\n\t}\n\treturn 0;\n}\nint max_flow(int s, int t) {\n\tint F = 0;\n\twhile (true) {\n\t\tfor (int i = 0; i <= 500; i++) used[i] = false;\n\t\tint fl = dfs(s, t, 1000000007);\n\t\tif (fl == 0) break;\n\t\tF += fl;\n\t}\n\treturn F;\n}\n\nint n, x[109], g[10000009]; bool prime[10000009]; vector<int>J;\n\nint main() {\n\tfor (int i = 2; i <= 10000008; i++) prime[i] = true;\n\tfor (int i = 2; i*i <= 10000008; i++) {\n\t\tfor (int j = i*i; j <= 10000008; j += i) prime[j] = false;\n\t}\n\tcin >> n;\n\tfor (int i = 1; i <= n; i++) { cin >> x[i]; g[x[i]] ^= 1; g[x[i] + 1] ^= 1; }\n\tfor (int i = 1; i <= 10000002; i++) { if (g[i] >= 1) J.push_back(i); }\n\tfor (int i = 0; i < J.size(); i++) {\n\t\tfor (int j = i + 1; j < J.size(); j++) {\n\t\t\tif (prime[J[j] - J[i]] == true) {\n\t\t\t\tif (J[i] % 2 == 1) add_edge(i, j, 1);\n\t\t\t\telse add_edge(j, i, 1);\n\t\t\t}\n\t\t}\n\t}\n\tint kisuu = 0, gusuu = 0;\n\tfor (int i = 0; i < J.size(); i++) {\n\t\tif (J[i] % 2 == 1) {\n\t\t\tadd_edge(J.size(), i, 1);\n\t\t\tkisuu++;\n\t\t}\n\t\telse {\n\t\t\tadd_edge(i, J.size() + 1, 1);\n\t\t\tgusuu++;\n\t\t}\n\t}\n\tint res = max_flow(J.size(), J.size() + 1);\n\tint V1 = res, V2 = (kisuu - res) / 2 + (gusuu - res) / 2, V3 = (J.size() / 2 - V1 - V2);\n\tcout << V1 * 1 + V2 * 2 + V3 * 3 << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define mset(a, b) memset(a, b, sizeof(a))\n#define mcpy(a, b) memcpy(a, b, sizeof(a))\n#define rg register\nusing namespace std;\ntypedef long long LL;\nconst int N = 205;\nconst int MAXP = 1e7 + 5;\n\ntemplate <typename T> inline void read(T &AKNOI) {\n\tT x = 0, flag = 1;\n\tchar ch = getchar();\n\twhile (!isdigit(ch)) {\n\t\tif (ch == '-') flag = -1;\n\t\tch = getchar();\n\t}\n\twhile (isdigit(ch)) {\n\t\tx = x * 10 + ch - '0';\n\t\tch = getchar();\n\t}\n\tAKNOI = flag * x;\n}\n\nint n, a[N], pos[N], tot;\nint pr[MAXP], pcnt, notp[MAXP];\nint g[N][N], my[N], vis[N], tim;\n\nvoid sieve(int m) {\n\tfor (int i = 2; i <= m; ++i) {\n\t\tif (!notp[i]) {\n\t\t\tpr[++pcnt] = i;\n\t\t}\n\t\tfor (int j = 1; j <= pcnt && i * pr[j] <= m; ++j) {\n\t\t\tnotp[i * pr[j]] = 1;\n\t\t\tif (i % pr[j] == 0) break;\n\t\t}\n\t}\n}\n\nint Match(int u) {\n\tfor (int v = 1; v <= n; ++v) {\n\t\tif (g[u][v] && vis[v] != tim) {\n\t\t\tvis[v] = tim;\n\t\t\tif (!my[v] || Match(my[v])) {\n\t\t\t\tmy[v] = u;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nvoid init() {\n\tread(n);\n\tfor (int i = 1; i <= n; ++i) {\n\t\tread(a[i]);\n\t\tif (i == 1 || a[i - 1] != a[i] - 1) pos[++tot] = a[i];\n\t\tif (i != 1 && a[i - 1] + 1 != a[i]) pos[++tot] = a[i - 1] + 1;\n\t}\n\tpos[++tot] = a[n] + 1;\n\tsieve(a[n] + 1);\n}\n\nvoid solve() {\n\tint odd = 0;\n\tfor (int i = 1; i <= tot; ++i) {\n\t\tif (pos[i] & 1) {\n\t\t\t++odd;\n\t\t\tfor (int j = 1; j <= tot; ++j) {\n\t\t\t\tif (pos[j] & 1) continue;\n\t\t\t\tint dis = abs(pos[i] - pos[j]);\n\t\t\t\tif (dis > 2 && !notp[dis]) {\n\t\t\t\t\tg[i][j] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint ans = 0;\n\tfor (int i = 1; i <= tot; ++i) {\n\t\tif (pos[i] & 1) {\n\t\t\t++tim;\n\t\t\tans += Match(i);\n\t\t}\n\t}\n\tprintf(\"%d\\n\", ans + (tot - ans * 2) + ((odd - ans) & 1));\n}\n\nint main() {\n\tinit();\n\tsolve();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <cstdio>\n#include <utility>\n\n#define Int register int\n\nusing namespace std;\n\nconst int MAXN = 100, MAXV = 1e7, MAXM = 5e4, MAXP = 664579, INF = 0x3f3f3f3f;\nint n, L, S, T, d[MAXV + 5];\nint pn, Prime[MAXP + 5];\nint CntL, CntR, Left[MAXM + 5], Right[MAXM + 5];\nint Cnte = 1, Head[MAXM + 5];\nbool Vis[MAXV + 5];\npair<int, int> Path[MAXM + 5];\nqueue<int> Q;\n\nstruct Edge { int To, Flow, nxt; } Graph[MAXM * 2 + 5];\n\ninline int Abs ( const int x ) { return x < 0 ? ~ x + 1 : x; }\n\ninline int Min ( const int a, const int b ) { return a < b ? a : b; }\n\ninline void Link ( const int s, const int t, const int f ) { Graph[++ Cnte] = { t, f, Head[s] }, Head[s] = Cnte; }\n\ninline void AddEdge ( const int s, const int t, const int f ) {\n#ifdef __DEBUG\n\tprintf ( \"<%d, %d, %d>\\n\", s, t, f );\n#endif\n\tLink ( s, t, f ), Link ( f, t, 0 );\n}\n\ninline void Sieve ( const int n ) {\n\tVis[0] = Vis[1] = true;\n\tfor ( Int i = 2; i <= n; ++ i ) {\n\t\tif ( ! Vis[i] ) Prime[++ pn] = i;\n\t\tfor ( Int j = 1; j <= pn && i * Prime[j] <= n; ++ j ) {\n\t\t\tVis[i * Prime[j]] = true;\n\t\t\tif ( ! ( i % Prime[j] ) ) break;\n\t\t}\n\t}\n}\n\ninline bool BFS () {\n\tfor ( ; ! Q.empty (); Q.pop () );\n\tfor ( Int i = 1; i <= T; ++ i ) Vis[i] = false;\n\tQ.push ( S ), Vis[S] = true;\n\twhile ( ! Q.empty () ) {\n\t\tint u = Q.front (); Q.pop ();\n\t\tfor ( Int i = Head[u], v; i; i = Graph[i].nxt ) {\n\t\t\tif ( ! Vis[v = Graph[i].To] && Graph[i].Flow > 0 ) {\n\t\t\t\tQ.push ( v ), Vis[v] = true, Path[v] = { u, i };\n\t\t\t\tif ( v == T ) return true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\ninline int EK () {\n\tint ret = 0;\n\tfor ( ; BFS (); ) {\n\t\tint MinFlow = INF;\n\t\tfor ( Int u = T; u ^ S; u = Path[u].first ) MinFlow = Min ( MinFlow, Graph[Path[u].second].Flow );\n\t\tfor ( Int u = T; u ^ S; u = Path[u].first ) {\n\t\t\tGraph[Path[u].second].Flow -= MinFlow;\n\t\t\tGraph[Path[u].second ^ 1].Flow += MinFlow;\n\t\t}\n\t\tret += MinFlow;\n\t}\n\treturn ret;\n}\n\ninline void Work () {\n\tSieve ( MAXV );\n\tscanf ( \"%d\", &n );\n\tfor ( Int i = 1, x; i <= n; ++ i ) {\n\t\tscanf ( \"%d\", &x ), ++ d[x];\n\t\tL = L > x ? L : x;\n\t}\n\tfor ( Int i = 1; i <= L + 1; ++ i ) {\n\t\tif ( d[i] ^ d[i - 1] ) {\n\t\t\tif ( i & 1 ) {\n\t\t\t\tLeft[++ CntL] = i;\n\t\t\t} else {\n\t\t\t\tRight[++ CntR] = i;\n\t\t\t}\n\t\t}\n\t}\n\tS = CntL + CntR + 1, T = S + 1;\n\tfor ( Int i = 1; i <= CntL; ++ i ) AddEdge ( S, i, 1 );\n\tfor ( Int i = 1; i <= CntR; ++ i ) AddEdge ( i + CntL, T, 1 );\n\tfor ( Int i = 1; i <= CntL; ++ i ) {\n\t\tfor ( Int j = 1; j <= CntR; ++ j ) {\n\t\t\tif ( ! Vis[Abs ( Left[i] - Right[j] )] ) {\n\t\t\t\tAddEdge ( i, j + CntL, 1 );\n\t\t\t}\n\t\t}\n\t}\n\tint mxf = EK (), Ans = mxf;\n\tAns += ( CntL - mxf >> 1 << 1 ) + ( CntR - mxf >> 1 << 1 );\n\tAns += ( ( CntL - mxf ) & 1 ) * 3;\n\tprintf ( \"%d\\n\", Ans );\n}\n\nint main () {\n\tWork ();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>     \n#define ll long long\n#define mk make_pair\n#define y1 yyyy\nusing namespace std;\n\nconst int N = 5e4 + 5;\nconst int mod = 1e9 + 7;\n\nint n, a[N], my[N], ans;\nbool b[N * 200];\nvector<int> V[2], G[N];\n\nbool find(int x) {\n\tfor (int i = 0; i < G[x].size(); i++) {\n\t\tint u = G[x][i];\n\t\tif (b[u]) continue; \n\t\tb[u] = 1;\n\t\tif (my[u] == -1 || find(my[u])) {\n\t\t\tmy[u] = x;\n\t\t\treturn 1;\n\t\t} \n\t}\n\treturn 0;\n}\n\nbool check(int x) {\n\tif (x == 2) return 0;\n\tfor (int i = 2; i * i <= x; i++) {\n\t\tif (x % i == 0) return 0;\n\t}\n\treturn 1;\n}\n\nint main() {\n\tcin >> n;\n\tfor (int i = 1; i <= n; i++) cin >> a[i], b[a[i]] = 1;\n\tfor (int i = 1; i <= 10000001; i++) {\n\t\tif (b[i] != b[i - 1]) V[i & 1].push_back(i);\n\t}\n\tmemset(my, -1, sizeof(my));\n\tfor (int i = 0; i < V[0].size(); i++) {\n\t\tfor (int j = 0; j < V[1].size(); j++) {\n\t\t\tif (check(abs(V[0][i] - V[1][j]))) \n\t\t\t\tG[i].push_back(j);\n\t\t}\n\t}\n\tfor (int i = 0; i < V[0].size(); i++) {\n\t\tfor (int j = 0; j < V[1].size(); j++) b[j] = 0;\n\t\tif (find(i)) ans++;\n\t}\n\tcout << ans + (V[0].size() - ans) / 2 * 2 + (V[1].size() - ans) / 2 * 2 + V[0].size() % 2 * 3;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint N,M;\nconst int MAX_N = 111;\nint a[MAX_N],b[MAX_N*2],sz;\n\nvector<int> path[MAX_N*4];\nbool visit[MAX_N*2];\nint match[MAX_N*4];\n\nbool dfs(int a){\n\tif(visit[a])return false;\n\tvisit[a]=1;\n\tfor(int i=0;i<path[a].size();i++){\n\t\tint b=path[a][i];\n\t\tif(match[b]<0){\n\t\t\tmatch[b]=a;\n\t\t\treturn true;\n\t\t}else if(dfs(match[b])){\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nbool isPrime(int x){\n\tif(x==1)return false;\n\tif(x%2==0)return false; // 2 is exception\n\tfor(int i=3;i*i<=x;i+=2){\n\t\tif(x%i==0)return false;\n\t}\n\treturn true;\n}\n\nint main(){\n\t\n\tscanf(\"%d\",&N);\n\tfor(int i=1;i<=N;i++){\n\t\tscanf(\"%d\",&a[i]);\n\t}\n\ta[0]=-1;\n\ta[N+1]=1e9;\n\n\tint even=0,odd=0;\n\tfor(int i=1;i<=N+1;i++){\n\t\tif(a[i-1]+1<a[i]){\n\t\t\tif(i>1)b[sz++]=a[i-1]+1;\n\t\t\tif(i<=N)b[sz++]=a[i];\n\t\t}\n\t}\n\n\tfor(int i=0;i<sz;i++){\n\t\tif(b[i]%2==0)even++;\n\t\telse odd++;\n\t}\n\n\tfor(int i=0;i<sz;i++){\n\t\tfor(int j=i+1;j<sz;j++){\n\t\t\tif(isPrime(b[j]-b[i])){\n\t\t\t\tpath[i].push_back(j+sz);\n\t\t\t\tpath[j+sz].push_back(i);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int i=0;i<sz*2;i++){\n\t\tmatch[i]=-1;\n\t}\n\t\n\tint cnt=0;\n\tfor(int i=0;i<sz;i++){\n\t\tfor(int j=0;j<sz;j++)visit[j]=0;\n\t\tif(dfs(i))cnt++;\n\t}\n\teven-=cnt;\n\todd-=cnt;\n\tprintf(\"%d\\n\",cnt+(even/2+odd/2)*2+(even%2)*3);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define ld long double\n#define ull unsigned long long\n#define poly vector<ll>\n#define pb push_back\n#define pii pair<int,int>\n#define fi first\n#define se second\n#define mp make_pair\n#define For(i,l,r) for(int i=(int)(l);i<=(int)(r);i++)\n#define Rep(i,r,l) for(int i=(int)(r);i>=(int)(l);i--)\ninline ll read(){\n\tll x=0;char ch=getchar();bool d=1;\n\tfor(;!isdigit(ch);ch=getchar()) if(ch=='-') d=0;\n\tfor(;isdigit(ch);ch=getchar()) x=x*10+ch-'0';\n\treturn d?x:-x;\n}\ninline void write(ll x){\n\tif(x<0) x=-x,putchar('-');\n\tif(x>=10) write(x/10);\n\tputchar('0'+x%10);\n}\ninline void writeln(ll x){write(x);puts(\"\");}\ninline void writep(ll x){write(x);putchar(' ');}\ninline ull rnd(){\n\treturn ((ull)rand()<<30^rand())<<4|rand()%4;\n}\nconst int N=205;\nint head[N],opt;\nstruct info{\n\tint to,nxt;\n}e[N*N*2];\nvoid add(int x,int y){\n\te[++opt]=(info){y,head[x]};head[x]=opt;\n\te[++opt]=(info){x,head[y]};head[y]=opt;\n}\nbool check(int x){\n\tif(x<=2) return 0;\n\tfor(int i=2;i*i<=x;i++){\n\t\tif(x%i==0) return 0;\n\t}\n\treturn 1;\n}\nint ma[N];\nbool used[N];\nbool dfs(int u){\n\tfor(int i=head[u];i;i=e[i].nxt){\n\t\tint k=e[i].to;\n\t\tif(used[k]) continue;\n\t\tused[k]=1;\n\t\tif(!ma[k]||dfs(ma[k])) return ma[k]=u,1;\n\t}\n\treturn 0;\n}\nint a[N],pos[N];\nint main(){\n\t// freopen(\"ssw.in\",\"r\",stdin);\n\tint n=read(),m=0,cnt=0;\n\tFor(i,1,n){\n\t\ta[i]=read();\n\t\tif(i==1||a[i-1]<a[i]-1) pos[++m]=a[i];\n\t\tif(i>1&&a[i-1]+1<a[i]) pos[++m]=a[i-1]+1;\n\t}\n\tpos[++m]=a[n]+1;\n\tsort(pos+1,pos+m+1);\n\tFor(i,1,m) cerr<<pos[i]<<endl;\n\tFor(i,1,m) if(pos[i]&1) cnt++;\n\tFor(i,1,m) For(j,i+1,m){\n\t\tif(check(pos[j]-pos[i])) add(i,j);\n\t}\n\tint ssw=0;\n\tFor(i,1,m) if(pos[i]%2==0){\n\t\tmemset(used,0,sizeof(used));\n\t\tssw+=dfs(i);\n\t}\n\tcout<<ssw+(m-ssw*2)+(cnt-ssw)%2;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<list>\n#include<deque>\n#include<bitset>\n#include<set>\n#include<map>\n#include<unordered_map>\n#include<unordered_set>\n#include<cstring>\n#include<sstream>\n#include<complex>\n#include<iomanip>\n#include<numeric>\n#include<cassert>\n#define X first\n#define Y second\n#define pb push_back\n#define rep(X,Y) for (int (X) = 0;(X) < (Y);++(X))\n#define reps(X,S,Y) for (int (X) = S;(X) < (Y);++(X))\n#define rrep(X,Y) for (int (X) = (Y)-1;(X) >=0;--(X))\n#define rreps(X,S,Y) for (int (X) = (Y)-1;(X) >= (S);--(X))\n#define repe(X,Y) for ((X) = 0;(X) < (Y);++(X))\n#define peat(X,Y) for (;(X) < (Y);++(X))\n#define all(X) (X).begin(),(X).end()\n#define rall(X) (X).rbegin(),(X).rend()\n#define eb emplace_back\n#define UNIQUE(X) (X).erase(unique(all(X)),(X).end())\n#define Endl endl\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntemplate<class T> using vv=vector<vector<T>>;\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"{\"; rep(i,t.size()) {os<<t[i]<<\",\";} os<<\"}\"<<endl; return os;}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\ntemplate<class T> inline bool MX(T &l,const T &r){return l<r?l=r,1:0;}\ntemplate<class T> inline bool MN(T &l,const T &r){return l>r?l=r,1:0;}\n#define out(args...){vector<string> a_r_g_s=s_p_l_i_t(#args, ','); e_r_r(a_r_g_s.begin(), args); }\nvector<string> s_p_l_i_t(const string &s, char c){vector<string> v;int d=0,f=0;string t;for(char c:s){if(!d&&c==',')v.pb(t),t=\"\";else t+=c;if(c=='\\\"'||c=='\\'')f^=1;if(!f&&c=='(')++d;if(!f&&c==')')--d;}v.pb(t);return move(v);}\nvoid e_r_r(vector<string>::iterator it) {}\ntemplate<typename T, typename... Args> void e_r_r(vector<string>::iterator it, T a, Args... args){ if(*it==\" 1\"||*it==\"1\") cerr<<endl; else cerr << it -> substr((*it)[0] == ' ', it -> length()) << \" = \" << a << \", \"; e_r_r(++it, args...);}\nconst ll MOD=1e9+7;\nvector<int> primes,prime;\nclass PRPRPR{\npublic:\n  PRPRPR(int PRIME_MAX){\n    prime.resize(PRIME_MAX);\n    for(int i=2;i<PRIME_MAX;i++)if(!prime[i]){\n\t\t\t\tprimes.pb(i);\n\t\t\t\tfor(int j=i*2;j<PRIME_MAX;j+=i)\n\t\t\t\t\tprime[j]=1;\n      }\n  }\n} prprprpr(11234567);\n\nint dp[111][111];\n\nint main(){\n  ios_base::sync_with_stdio(false);\n  cout<<fixed<<setprecision(0);\n\tint n;\n\tcin>>n;\n\tvector<int> xs(n);\n\trep(i,n) cin>>xs[i];\n\n\tauto Cost=[&](int d){\n\t\tif(!d) return 0;\n\t\tif(d==4) return 2;\n\t\tif(d==1) return 3;\n\t\tif(d%2==0) return 2;\n\t\tif(d>2 && prime[d]==0) return 1;\n\t\treturn 3;\n\t};\n\n\treps(d,1,n+1)rep(i,n+1-d){\n\t\tfor(int l=i,r=i+d-1; l<=r; ++l, --r){\n\t\t\tif(r-l==xs[r]-xs[l]){\n\t\t\t\tdp[i][i+d-1]=Cost(xs[r]-xs[l]+1);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(l==r) dp[i][i+d-1]+=Cost(1);\n\t\t\telse dp[i][i+d-1]+=Cost(xs[r]-xs[l]+1)+Cost(xs[r]-xs[l]-1);\n\t\t}\n\t\treps(c,i,i+d) MN(dp[i][i+d-1], dp[i][c]+dp[c+1][i+d-1]);\n\t}\n\t//rep(i,n){rep(j,n)cout<<dp[i][j]<<\",\";cout<<endl;}\n\tcout<<dp[0][n-1]<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i, a, b) for(int i = a;i < (b); ++i)\n#define trav(a, x) for(auto& a : x)\n#define all(x) begin(x), end(x)\n#define sz(x) (int) (x).size()\ntypedef vector<int> vi;\n\nint n;\n\nbool is_prime(int x){\n    if(x == 1)\n        return false;\n    for(int i = 2;i * i <= x;i++){\n        if(x % i == 0)\n            return false;\n    }\n    return true;\n}\n\nbool find(int j, vector<vi>& g, vi& btoa, vi& vis) {\n\tif (btoa[j] == -1) return 1;\n\tvis[j] = 1; int di = btoa[j];\n\ttrav(e, g[di])\n\t\tif (!vis[e] && find(e, g, btoa, vis)) {\n\t\t\tbtoa[e] = di;\n\t\t\treturn 1;\n\t\t}\n\treturn 0;\n}\nint dfsMatching(vector<vi>& g, vi& btoa) {\n\tvi vis;\n\trep(i,0,sz(g)) {\n\t\tvis.assign(sz(btoa), 0);\n\t\ttrav(j,g[i])\n\t\t\tif (find(j, g, btoa, vis)) {\n\t\t\t\tbtoa[j] = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t}\n\treturn sz(btoa) - (int)count(all(btoa), -1);\n}\n\nvoid insert(set<int> &s, int x){\n    if(s.find(x) != s.end())\n        s.erase(x);\n    else\n        s.insert(x);\n}\n\nint main(){\n    ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n    cin >> n;\n    set<int> odd, even;\n    for(int i = 1;i <= n;i++){\n        int x;\n        cin >> x;\n        if(x & 1){\n            insert(odd, x);\n            insert(even, x + 1);\n        }else{\n            insert(odd, x + 1);\n            insert(even, x);\n        }\n    }\n    vi a, b;\n    for(auto it : odd){\n        a.push_back(it);\n    }\n    for(auto it : even){\n        b.push_back(it);\n    }\n    vector<vi> g;\n    for(int i = 0;i < a.size();i++){\n        vi adj;\n        for(int j = 0;j < b.size();j++){\n            int u = a[i], v = b[j];\n            if(is_prime(abs(u - v))){\n                adj.push_back(j);       \n            }  \n        }\n        g.push_back(adj);\n    }\n    vi btoa(b.size(), -1);\n    int k = dfsMatching(g, btoa);\n    int ans = k + ((a.size() - k) / 2 + (b.size() - k) / 2) * 2 + ((a.size() - k) % 2) * 3;\n    cout << ans << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long lint;\ntypedef long double louble;\n\ntemplate<typename T1,typename T2> inline T1 max(T1 a,T2 b){return a<b?b:a;}\ntemplate<typename T1,typename T2> inline T1 min(T1 a,T2 b){return a<b?a:b;}\n\nnamespace ae86\n{\n\tconst int bufl = 1<<15;\n\n\tchar buf[bufl],*s=buf,*t=buf;\n\n\tinline int fetch()\n\t{\n\t\tif(s==t){t=(s=buf)+fread(buf,1,bufl,stdin);if(s==t)return EOF;}\n\t\treturn *s++;\n\t}\n\n\tinline int ty()\n\t{\n\t\tint a=0,b=1,c=fetch();\n\t\twhile(!isdigit(c))b^=c=='-',c=fetch();\n\t\twhile(isdigit(c))a=a*10+c-48,c=fetch();\n\t\treturn b?a:-a;\n\t}\n}\nusing ae86::ty;\n\nconst int _ = 1007 , __ = 10000007 , inf = 0x3f3f3f3f;\n\nbool isnp[__]={0};\nint pri[_]={0},pcnt=0;\n\ninline void shai(int n=__-1)\n{\n\tisnp[1]=1;\n\tfor(int i=2;i<=n;i++)\n\t{\n\t\tif(!isnp[i])pri[++pcnt]=i;\n\t\tfor(int j=1;j<=pcnt && 1ll*i*pri[j]<=n;j++)\n\t\t{\n\t\t\tint a=i*pri[j];\n\t\t\tisnp[a]=1;\n\t\t\tif(i%pri[j]==0)break;\n\t\t}\n\t}\n}\n\nstruct netflow\n{\n\tstatic const int _n = _<<2 , _e = 9999999;\n\n\tint to[_e],ne[_e],ev[_e],he[_n],ecnt;\n\n\tinline void adde(int a,int b,int c){to[++ecnt]=b,ev[ecnt]=c,ne[ecnt]=he[a],he[a]=ecnt;}\n\tinline void addde(int a,int b,int c){adde(a,b,c),adde(b,a,0);}\n\n\tint dis[_n],gap[_n],dcnt,S,T;\n\n\tinline int dfs(int x,int f)\n\t{\n\t\tif(!x || !f || x==T)return f;\n\t\tint r=f,mid=dcnt-1;\n\t\tfor(int i=he[x];i;i=ne[i])\n\t\t{\n\t\t\tif(ev[i]<=0)continue;\n\t\t\tint b=to[i];\n\t\t\tif(dis[b]==dis[x]+1)\n\t\t\t{\n\t\t\t\tint g=dfs(b,min(r,ev[i]));\n\t\t\t\tr-=g,ev[i]-=g,ev[i^1]+=g;\n\t\t\t\tif(dis[T]>=dcnt)return f-r;\n\t\t\t\tif(!r)break;\n\t\t\t}\n\t\t\tmid=min(mid,dis[b]);\n\t\t}\n\n\t\tif(f==r)\n\t\t{\n\t\t\tif(--gap[dis[x]]==0)dis[T]=dcnt;\n\t\t\tdis[x]=mid+1,gap[dis[x]]++;\n\t\t}\n\n\t\treturn f-r;\n\t}\n\t\n\tinline int run(int s,int t)\n\t{\n\t\tmemset(dis,0,sizeof(dis));\n\t\tmemset(gap,0,sizeof(gap));\n\t\tgap[0]=dcnt;\n\t\tint sflw=0;\n\t\tS=s,T=t;\n\t\twhile(dis[T]<dcnt)sflw+=dfs(S,inf);\n\t\treturn sflw;\n\t}\n\t\n\tnetflow()\n\t{\n\t\tmemset(to,0,sizeof(to));\n\t\tmemset(ne,0,sizeof(ne));\n\t\tmemset(ev,0,sizeof(ev));\n\t\tmemset(he,0,sizeof(he));\n\t\tecnt=1,dcnt=0;\n\t}\n\t\n}nf;\n\nint n,got[_]={0};\nbool hav[__]={0};\nvector<int> ps[2];\n\nint main()\n{\n\tshai();\n\t\n\tn=ty();\n\tfor(int i=1;i<=n;i++)got[i]=ty(),hav[got[i]]=1;\n\tfor(int i=1;i<__;i++)if(hav[i]!=hav[i-1])ps[i&1].emplace_back(i);\n\n\tint sz0=ps[0].size(),sz1=ps[1].size();\n\tnf.dcnt=sz0+sz1;\n\tint s=++nf.dcnt,t=++nf.dcnt;\n\tfor(int i=0;i<sz0;i++)nf.addde(s,i+1,1);\n\tfor(int i=0;i<sz1;i++)nf.addde(sz0+i+1,t,1);\n\t\n\tfor(int i=0;i<sz0;i++)\n\t\tfor(int j=0;j<sz1;j++)\n\t\t\tif(!isnp[abs(ps[0][i]-ps[1][j])])\n\t\t\t\tnf.addde(i+1,sz0+j+1,1);\n\n\tint ans=nf.run(s,t);\n\t\n\tprintf(\"%d\\n\",ans+((sz0-ans)/2+(sz1-ans)/2)*2+((sz0-ans)&1)*3);\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i=(a);i<=(b);i++)\n#define re(i,a,b) for(int i=(a);i<(b);i++)\n#define repd(i,a,b) for(int i=(a);i>=(b);i--)\n#define run(a) for(int k=head[a];k;k=e[k].ne)\n#define clr(a) memset(a,0,sizeof(a));\n#define il inline\n#define sz(a) ((int)a.size())\n#define all(a) a.begin(),a.end()\n#define pb push_back \n#define w1 first\n#define w2 second\n#define adm(a,b,c) {a=a+b;if(a>=c)a-=c;else if(a<0)a+=c;}\ntypedef double db;\ntypedef long long ll;typedef long double ld;typedef unsigned long long ull;\ntypedef pair<ll,ll> pa;\nconst int N=3e2+5,M=1e7+5,INF=1e9,mod=998244353;\nconst ll linf=1e18;const double eps=1e-8,pi=acos(-1);\nil int gmin(int &a,int b){if(a>b)a=b;}il ll gmin(ll &a,ll b){if(a>b)a=b;}il int gmax(int &a,int b){if(a<b)a=b;}il ll gmax(ll &a,ll b){if(a<b)a=b;}\nil void read(ll&x){ll f=1,t=0;char ch=getchar();while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}while(ch>='0'&&ch<='9'){t=t*10+ch-'0';ch=getchar();}x=t*f;}il ll read(ll&x,ll&y){read(x);read(y);}\nil void read(int&x){int f=1,t=0;char ch=getchar();while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}while(ch>='0'&&ch<='9'){t=t*10+ch-'0';ch=getchar();}x=t*f;}il int read(int&x,int&y){read(x);read(y);}\nil void read(int&a,int&b,int&c){read(a);read(b);read(c);}il void read(ll&a,ll&b,ll&c){read(a);read(b);read(c);}\nil int read(){int x;read(x);return x;}\nil ll qpow(ll a,ll b,ll p){ll ret=1;for(;b;b>>=1,a=a*a%p)if(b&1)ret=ret*a%p;return ret;}il ll qpow(ll a,ll b){ll ret=1;for(;b;b>>=1,a=a*a%mod)if(b&1)ret=ret*a%mod;return ret;}\nil ll qmul(ll a,ll b,ll p){ll ret=0;for(;b;b>>=1,a=(a<<1)%p)if(b&1)adm(ret,a,p);return ret;}il ll qmul(ll a,ll b){ll ret=0;for(;b;b>>=1,a=(a<<1)%mod)if(b&1)adm(ret,a,mod);return ret;}\nil void judge(){\n\tfreopen(\"data.in\",\"r\",stdin);\n\tfreopen(\"data.out\",\"w\",stdout);}\nint f[M],st[N],top,c1,c0,e[N][N],vis[N],lk[N],n;\nint isp(int x){\n\tif(x<=2||x%2==0)return 0;\n\tfor(int i=2;i*i<=x;i++)if(x%i==0)return 0;\n\treturn 1;\n}\nint hungry(int x){\n\tvis[x]=1;\n\trep(i,1,top)if(e[x][i]){\n\t\tif(!lk[i]){lk[i]=x;return 1;}\n\t\tif(!vis[lk[i]]&&hungry(lk[i])){lk[i]=x;return 1;}\n\t}return 0;\n}\nint main(){\n\tread(n);rep(i,1,n)f[read()]=1;\n\trep(i,1,1e7+1)if(f[i]^f[i-1]){st[++top]=i;if(i&1)c1++;else c0++;}\n\trep(i,1,top)rep(j,i,top)if(isp(abs(st[i]-st[j])))e[i][j]=e[j][i]=1;\n\tint mat=0;\n\trep(i,1,top)if(st[i]&1){\n\t\tclr(vis);\n\t\tmat+=hungry(i);\n\t}\n\tc1-=mat;c0-=mat;\n\tint res=mat+c1+c0;if(c0&1)if(c1&1)res++;\n\tcout<<res<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int max_n=205;\nconst int max_m=40005;\nstruct edge{\n    int u,v,next;\n}G[max_m*2];\nint head[max_n],tot;\nvoid init(int n){\n    tot=0;\n    for(int i=0;i<=n;i++)head[i]=-1;\n}\nint match[max_n];\nbool used[max_n];\nvoid add_edge(int u,int v){\n    G[tot]={u,v,head[u]};\n    head[u]=tot++;\n}\nbool dfs(int u){\n    used[u]=true;\n    for(int i=head[u];~i;i=G[i].next){\n        int v=G[i].v,w=match[v];\n        if(w<0||!used[w]&&dfs(w)){\n            match[u]=v,match[v]=u;\n            return true;\n        }\n    }\n    return false;\n}\nint solve(int n,int m){\n    int res=0;\n    for(int i=0;i<=n+m;i++)match[i]=-1;\n    for(int u=1;u<=n;u++){\n        if(match[u]==-1){\n            for(int i=0;i<=n+m;i++)used[i]=false;\n            if(dfs(u))res++;\n        }\n    }\n    return res;\n}\nint n,a[max_n];\nbool vis[10000005];\nbool p[10000005];\nint pri[10000005],cnt;\nvoid sieve(int n){\n    p[0]=p[1]=true;\n    for(int i=2;i<=n;i++){\n        if(!p[i])pri[++cnt]=i;\n        for(int j=1;j<=cnt&&1ll*i*pri[j]<=n;j++){\n            p[i*pri[j]]=true;\n            if(i%pri[j]==0)break;\n        }\n    }\n}\nint main(){\n    scanf(\"%d\",&n);\n    for(int i=1;i<=n;i++)scanf(\"%d\",a+i);\n    for(int i=1;i<=n;i++)vis[a[i]]^=1,vis[a[i]+1]^=1;\n    sieve(10000000);\n    vector<int> odd,even;\n    for(int i=1;i<=10000001;i++){\n        if(vis[i]){\n            if(i&1)odd.push_back(i);\n            else even.push_back(i);\n        }\n    }\n    int nn=odd.size(),mm=even.size();\n    init(nn+mm);\n    for(int i=0;i<nn;i++){\n        for(int j=0;j<mm;j++){\n            if(odd[i]<even[j]){\n                if(!p[even[j]-odd[i]]&&even[j]-odd[i]!=2){\n                    add_edge(i+1,j+1+nn),add_edge(j+1+nn,i+1);\n                }\n            }\n        }\n    }\n    int x=solve(nn,mm);\n    int ans=x+(nn-x)/2*2+(mm-x)/2*2+nn%2*3;\n    printf(\"%d\\n\",ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n\n#include <iostream>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <unordered_set>\n#include <queue>\n#include <set>\n#include <algorithm>\n#include <numeric>\n#include <list>\nusing namespace std;\n\nusing QWORD  = uint64_t;\nusing SQWORD = int64_t;\nusing DWORD  = uint32_t;\nusing SDWORD = int32_t;\nusing WORD   = uint16_t;\nusing SWORD  = int16_t;\nusing BYTE   = uint8_t;\nusing SBYTE  = int8_t;\nusing DOUBLE = double;\nusing FLOAT  = float;\n\n#define MIN_SDWORD (-2147483648)\n#define MAX_SDWORD (2147483647)\n#define MIN_SBYTE (-128)\n#define MAX_SBYTE (127)\n\n#define MIN_SQWORD (0x8000000000000000)\n#define MAX_SQWORD (0x7FFFFFFFFFFFFFFF)\n\n#define MAX_QWORD  (0xFFFFFFFFFFFFFFFF)\n#define MAX_DWORD  (0xFFFFFFFF)\n#define MAX_WORD   (0xFFFF)\n#define MAX_BYTE   (0xFF)\n\n#define MAX_DOUBLE      (1.0e+308)\n#define DOUBLE_EPS      (1.0e-12)\n#define MIN_DOUBLE_N    (-1.0e+308)\n\n#define ArrayLength(a)  (sizeof(a) / sizeof(a[0]))\n\nstatic inline DOUBLE MAX(DOUBLE a, DOUBLE b) { return a > b ? a : b; }\nstatic inline QWORD MAX(QWORD a, QWORD b) { return a > b ? a : b; }\nstatic inline DWORD MAX(DWORD a, DWORD b) { return a > b ? a : b; }\nstatic inline SDWORD MAX(SDWORD a, SDWORD b) { return a > b ? a : b; }\nstatic inline DOUBLE MIN(DOUBLE a, DOUBLE b) { return a < b ? a : b; }\nstatic inline QWORD MIN(QWORD a, QWORD b) { return a < b ? a : b; }\nstatic inline DWORD MIN(DWORD a, DWORD b) { return a < b ? a : b; }\nstatic inline SDWORD MIN(SDWORD a, SDWORD b) { return a < b ? a : b; }\nstatic inline DOUBLE ABS(DOUBLE a) { return 0 < a ? a : -a; };\n\n#define BYTE_BITS   (8)\n#define WORD_BITS   (16)\n#define DWORD_BITS  (32)\n#define QWORD_BITS  (64)\n\nstatic inline void inputStringSpSeparated(char *pcStr)\n{\n    char *pcCur = pcStr;\n    for (;;) {\n        char c = getchar();\n        if (('\\n' == c) || (EOF == c) || (' ' == c)) {\n            break;\n        }\n        *pcCur = c;\n        pcCur++;\n    }\n    *pcCur = '\\0';\n}\n\nstatic inline void inputString(char *pcStr)\n{\n    char *pcCur = pcStr;\n    for (;;) {\n        char c = getchar();\n        if (('\\n' == c) || (EOF == c)) {\n            break;\n        }\n        *pcCur = c;\n        pcCur++;\n    }\n    *pcCur = '\\0';\n}\n\n\nstatic inline SQWORD inputSQWORD(void)\n{\n    SQWORD sqNumber = 0;\n    SQWORD sqMultiplier = 1;\n    bool bRead = false;\n    for (;;) {\n        char c = getchar();\n        if (!bRead) {\n            if ('-' == c) {\n                sqMultiplier = -1;\n            }\n        }\n        if (('0' <= c) && (c <= '9')) {\n            sqNumber *= 10LL;\n            sqNumber += (SQWORD)(c - '0');\n            bRead = true;\n        } else {\n            if (bRead) {\n                return sqNumber * sqMultiplier;\n            }\n        }\n    }\n}\n\n\nstatic inline SDWORD inputSDWORD(void)\n{\n    SDWORD lNumber = 0;\n    SDWORD lMultiplier = 1;\n    bool bRead = false;\n    for (;;) {\n        char c = getchar();\n        if (!bRead) {\n            if ('-' == c) {\n                lMultiplier = -1;\n            }\n        }\n        if (('0' <= c) && (c <= '9')) {\n            lNumber *= 10;\n            lNumber += (c - '0');\n            bRead = true;\n        } else {\n            if (bRead) {\n                return lNumber * lMultiplier;\n            }\n        }\n    }\n}\n\nstatic inline DOUBLE inputFP(void)\n{\n    DOUBLE dInt = 0.0;\n    DOUBLE dFrac = 0.0;\n    DOUBLE dMultiplier = 1.0;\n    DWORD dwFpCnt = 0;\n    DOUBLE *pdCur = &dInt;\n    bool bRead = false;\n    for (;;) {\n        char c = getchar();\n        if (!bRead) {\n            if ('-' == c) {\n                dMultiplier = -1;\n            }\n        }\n        if ('.' == c) {\n            pdCur = &dFrac;\n        } else if (('0' <= c) && (c <= '9')) {\n            (*pdCur) *= 10;\n            (*pdCur) += (DOUBLE)(c - '0');\n            bRead = true;\n            if (pdCur == &dFrac) {\n                dwFpCnt++;\n            }\n        } else {\n            if (bRead) {\n                return dMultiplier * (dInt + dFrac / (pow((DOUBLE)10.0 , (DOUBLE)dwFpCnt)));\n            }\n        }\n    }\n}\n\n\n/**\n *  mod による操作ライブラリ\n */\n\n#define ANS_MOD (1000000007LL)\n \nstatic SQWORD addMod(SQWORD x, SQWORD y)\n{ \n    return (x + y) % ANS_MOD;\n}\n \nstatic SQWORD subMod(SQWORD x, SQWORD y)\n{\n    return (x - y + ANS_MOD) % ANS_MOD;\n}\n \nstatic SQWORD mulMod(SQWORD x, SQWORD y) \n{\n    return (x * y) % ANS_MOD;\n}\n \nstatic SQWORD powMod(SQWORD x, SQWORD e) {\n    SQWORD v = 1;\n    for (; e; x = mulMod(x, x), e >>= 1) {\n        if (e & 1) {\n            v = mulMod(v, x);\n        }\n    }\n    return v;\n}\n \nstatic SQWORD divMod(SQWORD x, SQWORD y)\n{\n    return mulMod(x, powMod(y, ANS_MOD - 2));\n}\n \n \nstatic SQWORD combMod(SQWORD n, SQWORD k)\n{\n    SQWORD v=1;\n    for(SQWORD i=1; i<=k; i++) {\n        v = divMod(mulMod(v, n-i+1),i);\n    } \n    return v;\n}\n\n/*----------------------------------------------*/\n\ntypedef struct {\n    SDWORD lTo;\n    SQWORD sqCap;\n    SQWORD sqCost;\n    SDWORD lRev;\n} ST_EDGE;\n\n#define MAX_V   (202)\n\nstruct Flow {\nprivate:\n    vector<ST_EDGE> avGraph[MAX_V];\n    SDWORD  alDims[MAX_V];\n    SQWORD  sqEdgeNum;\n    SQWORD  asqDist[MAX_V];\n    SDWORD  alPrevV[MAX_V];   \n    SDWORD  alPrevEdge[MAX_V];      /*直前の頂点と辺 */\n\n    SDWORD  alDinic_Level[MAX_V];\n    SDWORD  alDinic_Iter[MAX_V];\n\npublic:\n    Flow() {\n        for (auto v: avGraph) {\n            v.clear();\n        }\n        memset(alDims, 0, sizeof(alDims));\n        memset(asqDist, 0, sizeof(asqDist));\n        memset(alPrevV, 0, sizeof(alPrevV)); \n        memset(alPrevEdge, 0, sizeof(alPrevEdge));\n        memset(alDinic_Level, 0, sizeof(alDinic_Level));\n        memset(alDinic_Iter, 0, sizeof(alDinic_Iter));\n    }\n    void addEdge(SDWORD lFrom, SDWORD lTo, SQWORD sqCap, SQWORD sqCost) {\n//        printf(\"%d ----[%lld] ----> %d\\n\", lFrom, sqCap, lTo);\n        \n        alDims[lFrom]++;\n        avGraph[lFrom].push_back((ST_EDGE){lTo, sqCap, sqCost, (SDWORD)(avGraph[lTo].size())});\n        avGraph[lTo].push_back((ST_EDGE){lFrom, 0, -sqCost, (SDWORD)(avGraph[lFrom].size() - 1)});\n    }\n\n    SDWORD minCostFlow(SDWORD lStart, SDWORD lTarget, SQWORD sqFlow)\n    {\n        SQWORD sqRes = 0;\n        SQWORD sqFlowRest = sqFlow;\n        while (0 < sqFlowRest) {\n            /* Bellman-Ford Method */\n            fill(asqDist, asqDist + ArrayLength(asqDist), MAX_SDWORD);\n            asqDist[lStart] = 0;\n            bool bIsUpdate = true;\n            while (bIsUpdate) {\n                bIsUpdate = false;\n                for (SDWORD lV = 0; lV < MAX_V; lV++) {\n                    for (SDWORD lIdx = 0; lIdx < avGraph[lV].size(); lIdx++) {\n                        ST_EDGE &stE = avGraph[lV][lIdx];\n                        if ((asqDist[lV] != MAX_SDWORD)\n                                && (0 < stE.sqCap)\n                                && (asqDist[lV] + stE.sqCost < asqDist[stE.lTo])) {\n                            asqDist[stE.lTo] = asqDist[lV] + stE.sqCost;\n                            alPrevV[stE.lTo] = lV;\n                            alPrevEdge[stE.lTo] = lIdx;\n                            bIsUpdate = true;\n                        }\n                    }\n                }\n            }\n            if (asqDist[lTarget] == MAX_SDWORD) {\n                return -1;\n            }\n\n            SQWORD sqAddFlow = MAX_SQWORD;\n            for (SDWORD lV = lTarget; lV != lStart; lV = alPrevV[lV]) {\n                sqAddFlow = min(sqAddFlow, avGraph[alPrevV[lV]][alPrevEdge[lV]].sqCap);\n            }\n            sqFlowRest -= sqAddFlow;\n            sqRes += sqAddFlow * asqDist[lTarget];      // 後で目的変数は書き換える\n            for (SDWORD lV = lTarget; lV != lStart; lV = alPrevV[lV]) {\n                ST_EDGE &stE = avGraph[alPrevV[lV]][alPrevEdge[lV]];\n                stE.sqCap -= sqAddFlow;\n                avGraph[lV][stE.lRev].sqCap += sqAddFlow;\n            }\n        }\n        return sqRes;\n    }\n\nprivate:\n    SQWORD maxFlowDinicBfs(SDWORD lS)\n    {\n        memset(alDinic_Level, -1, sizeof(alDinic_Level));\n        queue<SDWORD> queSearch;\n        alDinic_Level[lS] = 0;\n        queSearch.push(lS);\n        while (!queSearch.empty()) {\n            SDWORD lV = queSearch.front();\n            queSearch.pop();\n            for (SDWORD lIdx = 0; lIdx < avGraph[lV].size(); lIdx++) {\n                ST_EDGE &stE = avGraph[lV][lIdx];\n                if ((0 < stE.sqCap) && (alDinic_Level[stE.lTo] < 0)) {\n                    alDinic_Level[stE.lTo] = alDinic_Level[lV] + 1;\n                    queSearch.push(stE.lTo);\n                }\n            }\n        }\n\n        return 0;\n    }\n\n    SQWORD maxFlowDinicDfs(SDWORD lV, SDWORD lT, SQWORD sqF)\n    {\n        if (lV == lT) {\n            return sqF;\n        }\n        for (SDWORD &lI = alDinic_Iter[lV]; lI < avGraph[lV].size(); lI++) {\n            ST_EDGE &stE = avGraph[lV][lI];\n            if ((0 < stE.sqCap) && (alDinic_Level[lV] < alDinic_Level[stE.lTo])) {\n                SQWORD sqDiffFlow = maxFlowDinicDfs(stE.lTo, lT, min(sqF, stE.sqCap));\n                if (0 < sqDiffFlow) {\n                    stE.sqCap -= sqDiffFlow;\n                    avGraph[stE.lTo][stE.lRev].sqCap += sqDiffFlow;\n                    return sqDiffFlow;\n                }\n            }\n        }\n        return 0;\n    }\n\npublic:\n    SQWORD MaxFlow(SDWORD lStart, SDWORD lTarget)\n    {\n        SQWORD sqFlow = 0LL;\n        for (;;) {\n            maxFlowDinicBfs(lStart);\n            if (alDinic_Level[lTarget] < 0) {\n                return sqFlow;\n            }\n            memset(alDinic_Iter, 0, sizeof(alDinic_Iter));\n            while (1) {\n                SQWORD sqDiffFlow = maxFlowDinicDfs(lStart, lTarget, MAX_SQWORD);\n                sqFlow += sqDiffFlow;\n                if (0LL == sqDiffFlow) {\n                    break;\n                }\n            }\n        }\n    }\n\n    SQWORD getFlow(SDWORD lPnt)\n    {\n        SQWORD sqCapSum = 0; \n        for (auto e: avGraph[lPnt]) {\n            sqCapSum += e.sqCap;\n        }\n        return alDims[lPnt] - sqCapSum;\n    }\n};\n\n/*----------------------------------------------*/\n\nstatic void getPrimes(vector<SDWORD> &vlPrimes, SDWORD lMax)\n{\n    /* lSearchMax と ループ内の *2 の関係から、入力は3以上とすること */\n    if (!(1 <= lMax)) {\n        printf(\"Oops!\");\n        return;\n    }\n\n    /* 素数のリストを作る */\n    vector<bool> vbIsPrime(lMax + 1, true);\n    SDWORD lSearchMax = sqrt(lMax) + 1;\n    vbIsPrime[0] = false;\n    vbIsPrime[1] = false;\n    for (SDWORD lPrime = 2; lPrime < vbIsPrime.size(); lPrime++) {\n        if (vbIsPrime[lPrime]) {\n            vlPrimes.emplace_back(lPrime);\n            if (lPrime <= lSearchMax) {\n                for (SDWORD lCurNum = lPrime * 2; lCurNum <= lMax; lCurNum += lPrime) {\n                    vbIsPrime[lCurNum] = false;\n                }\n            }\n        }\n    }\n}    \n\n/*----------------------------------------------*/\n\n#define PNT_NO_START    (0)\n#define PNT_NO_OFFSET   (100)\n#define PNT_NO_TARGET   (201)\n#define FLOW_OFFSET     (1000000000)\n#define CAPACITY_INF    (1000000001)\n#define DUMMY_COST      (1)\n\nint main(void)\n{\n    SQWORD sqN = inputSQWORD();\n\n    Flow solverFlow;\n    vector<SQWORD> vsqA;\n    vector<SQWORD> vsqB;\n    vector<SDWORD> vlPrimes;\n\n    getPrimes(vlPrimes, 1e7 + 1);\n    vlPrimes.erase(find(vlPrimes.begin(), vlPrimes.end(), 2));\n\n    for (SQWORD sqIdx = 0; sqIdx < sqN; sqIdx++) {\n        SQWORD sqA = inputSQWORD();\n        vsqA.emplace_back(sqA);\n    }\n\n    for (SQWORD sqIdx = 0; sqIdx < sqN; sqIdx++) {\n        if (0 < sqIdx) {\n            if (!(vsqA[sqIdx - 1] == vsqA[sqIdx] - 1)) {\n                vsqB.emplace_back(vsqA[sqIdx]);\n            }\n        } else {\n            vsqB.emplace_back(vsqA[sqIdx]);      \n        }\n        if (sqIdx < sqN - 1) {\n            if (!(vsqA[sqIdx] + 1 == vsqA[sqIdx + 1])) {\n                vsqB.emplace_back(vsqA[sqIdx] + 1);\n            }\n        } else {\n            vsqB.emplace_back(vsqA[sqIdx] + 1);\n        }\n    }\n\n    vector<SQWORD> vsqCOdd;\n    vector<SQWORD> vsqCEven;\n    \n    map<SQWORD, SQWORD> mapCEven, mapCOdd;\n\n    SQWORD sqIdx = 1;\n    for (auto b: vsqB) {\n        if (0 == b % 2) {\n            vsqCEven.emplace_back(b);\n            mapCEven[b] = sqIdx;\n        } else {\n            vsqCOdd.emplace_back(b);\n            mapCOdd[b] = sqIdx;\n        }\n        sqIdx++;\n    }\n\n    /* 二部マッチング */\n    for (auto c: vsqCEven) {\n        solverFlow.addEdge(PNT_NO_START, mapCEven[c], 1, DUMMY_COST);\n    }\n    for (auto c: vsqCEven) {\n        solverFlow.addEdge(mapCOdd[c] + PNT_NO_OFFSET, PNT_NO_TARGET, 1, DUMMY_COST);\n    }\n\n    for (auto p: vlPrimes) {\n        for (auto c: vsqCEven) {\n            auto it = lower_bound(vsqCOdd.begin(), vsqCOdd.end(), c + p);\n            if (it != vsqCOdd.end()) {\n                if (*it == c + p) {\n                    if (c + p < 1e7 + 1) {\n                        solverFlow.addEdge(mapCEven[c], mapCOdd[c + p] + PNT_NO_OFFSET, 1, DUMMY_COST);\n                    }\n                }\n            }\n        }\n    }\n\n    SQWORD sqMaxFlow = solverFlow.MaxFlow(PNT_NO_START, PNT_NO_TARGET);\n    SQWORD vsqCRestEven = 0;\n    SQWORD vsqCRestOdd = 0;\n    for (auto c: vsqCEven) {\n        SQWORD sqFlow = solverFlow.getFlow(mapCEven[c]);\n        if (0 == sqFlow) {\n            vsqCRestEven++;\n        }\n    }\n    for (auto c: vsqCOdd) {\n        SQWORD sqFlow = solverFlow.getFlow(mapCOdd[c]);\n        if (0 == sqFlow) {\n            vsqCRestOdd++;\n        }\n    }\n\n    SQWORD sqAns = sqMaxFlow;    \n    sqAns += (vsqCRestEven / 2) * 2;\n    sqAns += (vsqCRestOdd / 2) * 2;\n    if (0 < (vsqCRestEven %  2)) {\n        sqAns += 3;\n    }\n\n    printf(\"%lld\\n\", sqAns);\n\n    return 0;\n}\n/*------------------------------------------*/\n"
  },
  {
    "language": "C++",
    "code": "#include<cstring>\n#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<queue>\n#include<stack>\n#include<cmath>\n#include<map>\n#include<complex>\n#define rep(i,l,r) for (int i=l;i<=r;i++)\n#define down(i,l,r) for (int i=l;i>=r;i--)\n#define clr(x,y) memset(x,y,sizeof(x))\n#define maxn 320500\n#define inf (int)1e9\n#define ll long long\n#define mm 1000000007\n#define eps 1e-13\n#define pb push_back\n#define low(x) x&(-x)\nusing namespace std;\n\nll read(){\n    ll x=0,f=1; char ch=getchar();\n    while (!isdigit(ch)) {if (ch=='-') f=-1; ch=getchar();}\n    while (isdigit(ch)){x=x*10+ch-'0'; ch=getchar();}\n    return x*f;\n}\nstruct data{int obj,pre,c,w;\n}e[105*105*2];\nint head[105*2],dis[105*2],uu[105*2],cur[105*2],a[105*2],b[105*2];\nint mp[10000005],pmp[10000005],vis[10000005],pri[1000500];\nint ans,t,tot=1,n,m;\nvoid insert(int x,int y,int c,int w){\n    e[++tot].obj=y; e[tot].pre=head[x]; e[tot].c=c; e[tot].w=w; head[x]=tot;\n    e[++tot].obj=x; e[tot].pre=head[y]; e[tot].c=0; e[tot].w=-w; head[y]=tot;\n}\nbool spfa(){\n    clr(uu,0);\n    rep(i,0,t) dis[i]=inf; dis[0]=0;\n    queue<int> q; q.push(0);\n    while (!q.empty()){\n        int u=q.front(); q.pop(); uu[u]=1;\n        for (int j=head[u];j;j=e[j].pre){\n            int v=e[j].obj;\n            if (e[j].c>0&&dis[v]>dis[u]+e[j].w){\n                dis[v]=dis[u]+e[j].w;\n                if (uu[v]==0) uu[v]=1,q.push(v);\n            }\n        }\n        uu[u]=0;\n    }\n    if (dis[t]>=inf) return 0;\n    return 1;\n}\nint dfs(int x,int mx){\n    //if (uu[x]==1) return 0;\n    if (x==t||mx==0) return mx;\n    uu[x]=1;\n    int used=0;\n    for (int j=cur[x];j;j=e[j].pre){\n        int v=e[j].obj;\n        if (dis[v]==dis[x]+e[j].w&&e[j].c>0&&uu[v]==0){\n            int w=dfs(v,min(e[j].c,mx-used));\n            ans+=w*e[j].w; \n            e[j].c-=w; e[j^1].c+=w; used+=w;\n            cur[x]=j;\n            if (used==mx) return used;\n        }\n    }\n    return used;\n}\nint main(){\n//\tfreopen(\"input.txt\",\"r\",stdin);\n//\tfreopen(\"output.txt\",\"w\",stdout);\n\tn=read();\n\tint mxn=10000001;\n\trep(i,1,n) a[i]=read(),mp[a[i]]=1;\n\t//rep(i,1,n) if (mp[a[i]-1]==mp[a[i]]) b[i]=0; else b[i]=1;\n\trep(i,1,mxn) if (mp[i]!=mp[i-1]) b[++m]=i; \n\trep(i,2,mxn) {\n\t\tif (!vis[i]) pri[++tot]=i,vis[i]=1,pmp[i]=1;\n\t\trep(j,1,tot) {\n\t\t\tif (i*pri[j]>mxn) break;\n\t\t\tvis[i*pri[j]]=1;\n\t\t}\n\t}\n//\trep(i,1,m) printf(\"%d \",b[i]);\n\tt=2*m+1;\n\trep(i,1,m) insert(0,i,1,0),insert(i+m,t,1,0);\n\trep(i,1,m) rep(j,1,m) {\n\t\tif (i==j) continue;\n\t\tif ((abs(b[i]-b[j])&1)==0) insert(i,j+m,1,2);\n\t\tif (abs(b[i]-b[j])&1){\n\t\t\tif (pmp[abs(b[i]-b[j])]) insert(i,j+m,1,1);\n\t\t\telse insert(i,j+m,1,3);\n\t\t}\n\t}\n\twhile (spfa()){\n        clr(uu,0); rep(i,0,t) cur[i]=head[i];\n        dfs(0,inf);\n    }\n    printf(\"%d\\n\",ans/2);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <set>\n#include <bitset>\nusing namespace std;\nint N;\nint x;\nset<int> S;\nvector<int> G[205];\nint L[205];\nint R[205];\nvector<int> Me,Mo;\nbitset<205> U;\nbool prime(int nr)\n{\n    for(int i=2;i*i<=nr;i++)if(nr%i==0)return 0;\n    return 1;\n}\nbool pairup(int nod)\n{\n    if(U[nod])return 0;\n    U[nod]=1;\n    for(auto it:G[nod])\n    {\n        if(!R[it])\n        {\n            L[nod]=it;\n            R[it]=nod;\n            return 1;\n        }\n    }\n    for(auto it:G[nod])\n    {\n        if(pairup(R[it]))\n        {\n            L[nod]=it;\n            R[it]=nod;\n            return 1;\n        }\n    }\n    return 0;\n}\nint main()\n{\n    cin>>N;\n    for(int i=1;i<=N;i++)\n    {\n        cin>>x;\n        if(S.find(x)!=S.end())\n        {\n            S.erase(x);\n        }\n        else\n        {\n            S.insert(x);\n        }\n        S.insert(x+1);\n    }\n    for(auto it:S)\n        if(it%2==0)\n            Me.push_back(it);\n        else\n            Mo.push_back(it);\n    for(int i=0;i<Me.size();i++)\n    {\n        for(int j=0;j<Mo.size();j++)\n        {\n            if(prime(abs(Mo[j]-Me[i])))\n                G[i].push_back(j);\n        }\n    }\n    bool ok=1;\n    int k=0;\n    while(ok)\n    {\n        ok=0;\n        U.reset();\n        for(int i=1;i<=N;i++)\n        {\n            if(!L[i]&&pairup(i))\n            {\n                k++;\n                ok=1;\n            }\n        }\n    }\n    int rez=k+(((int)Me.size()-k)/2)*2+(((int)Mo.size()-k)/2)*2+(((int)Me.size()-k)%2)*3;\n    cout<<rez;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 205;\nconst int MAXM = 10000005;\nint n, x[MAXN], f[MAXM], p[MAXM], cnt, match[MAXN], w[MAXN][MAXN];\nbool ip[MAXM], used[MAXN];\nvoid pre(int N) {\n\tfor(int i = 2; i <= N; ++i) {\n\t\tif(!ip[i]) p[++cnt] = i;\n\t\tfor(int j = 1; j <= cnt && p[j]*i <= N; ++j) {\n\t\t\tip[p[j]*i] = 1;\n\t\t\tif(i % p[j] == 0) break;\n\t\t}\n\t}\n}\nbool vis[MAXN];\nbool dfs(int u) {\n\tfor(int v = 1; v <= n; ++v)\n\t\tif(w[u][v] && !vis[v]) {\n\t\t\tvis[v] = 1;\n\t\t\tif(!match[v] || dfs(match[v])) {\n\t\t\t\tmatch[v] = u;\n\t\t\t\tmatch[u] = v;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\treturn 0;\n}\nvoid maxmatch() {\n\tfor(int i = 1; i <= n; ++i)\n\t\tif(!used[i] && (x[i]&1)) {\n\t\t\tmemset(vis,0,sizeof vis);\n\t\t\tdfs(i);\n\t\t}\n}\nint main () {\n\tscanf(\"%d\", &n);\n\tfor(int i = 1,y; i <= n; ++i) scanf(\"%d\", &y), f[y] = 1;\n\tfor(int i = 10000001; i >= 1; --i) f[i] ^= f[i-1];\n\tn = 0;\n\tfor(int i = 1; i <= 10000001; ++i) if(f[i]) x[++n] = i;\n\tpre(10000001); ip[2] = 1;\n\tfor(int i = 1; i <= n; ++i)\n\t\tfor(int j = i+1; j <= n; ++j)\n\t\t\tif(!ip[abs(x[i]-x[j])])\n\t\t\t\tw[i][j] = w[j][i] = 1;\n\t\t\telse w[i][j] = w[j][i] = 0;\n\tmaxmatch();\n\tint ans = 0;\n\tfor(int i = 1; i <= n; ++i)\n\t\tif(match[i] && !used[i]) {\n\t\t\t++ans;\n\t\t\tused[i] = used[match[i]] = 1;\n\t\t}\n\tint c1 = 0, c2 = 0;\n\tfor(int i = 1; i <= n; ++i)\n\t\tif(!used[i]) (x[i] & 1) ? ++c1 : ++c2;\n\tans += 2*(c1/2) + 2*(c2/2) + (c1&1)*3;\n\tprintf(\"%d\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define maxn 210\n#define maxm 10000010\nconst int lim=1e7;\ntemplate <typename T>inline T read()\n{\n    register T sum=0;\n    register char cc=getchar();\n    int sym=1;\n    while(cc!='-'&&(cc>'9'||cc<'0'))cc=getchar();\n    if(cc=='-')sym=-1,cc=getchar();\n    sum=sum*10+cc-'0';\n    cc=getchar();\n    while(cc>='0'&&cc<='9')sum=sum*10+cc-'0',cc=getchar();\n    return sym*sum;\n}\ntemplate <typename T>inline T read(T &a)\n{\n    a=read<T>();\n    return a;\n}\ntemplate <typename T,typename... Others> inline void read(T& a, Others&... b)\n{\n    a=read(a);\n\tread(b...);\n}\nstruct Edge\n{\n\tint v;\n\tEdge *next;\n\tEdge(int a=0,Edge *b=NULL)\n\t{\n\t\tv=a;\n\t\tnext=b;\n\t}\n}*head[maxn];\nint n,mx,tim,cnt,cnt1,cnt2,ans,maxflow,a[maxm];\nint L[maxn],R[maxn],p[maxm],vis[maxn],flg[maxm],match[maxn];\nbool Match(int k)\n{\n\tfor(Edge *i=head[k];i!=NULL;i=i->next)\n\t{\n\t\tif(vis[i->v]==tim)\n\t\t\tcontinue;\n\t\tvis[i->v]=tim;\n\t\tif(!match[i->v]||Match(match[i->v]))\n\t\t{\n\t\t\tmatch[i->v]=k;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\nvoid init()\n{\n\tflg[0]=flg[1]=true;\n\tfor(int i=2;i<=lim;i++)\n\t{\n\t\tif(!flg[i])\n\t\t\tp[++cnt]=i;\n\t\tfor(int j=1;j<=cnt&&p[j]*i<=lim;j++)\n\t\t{\n\t\t\tflg[i*p[j]]=true;\n\t\t\tif(i%p[j]==0)\n\t\t\t\tbreak;\n\t\t}\n\t}\n}\nint main()\n{\n\tinit();\n\tread(n);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint x;\n\t\tread(x);\n\t\ta[x]+=1;\n\t\tmx=max(mx,x);\n\t}\n\tfor(int i=1;i<=mx+1;i++)\n\t{\n\t\tif(a[i]!=a[i-1])\n\t\t{\n\t\t\tif(i&1)\n\t\t\t\tL[++cnt1]=i;\n\t\t\telse\n\t\t\t\tR[++cnt2]=i;\n\t\t}\n\t}\n\tfor(int i=1;i<=cnt1;i++)\n\t\tfor(int j=1;j<=cnt2;j++)\n\t\t\tif(!flg[abs(L[i]-R[j])])\n\t\t\t\thead[i]=new Edge(j,head[i]);\n\tfor(int i=1;i<=cnt1;i++)\n\t{\n\t\ttim+=1;\n\t\tmaxflow+=Match(i);\n\t}\n\tans=maxflow;\n\tans+=(cnt1-maxflow)/2*2+(cnt2-maxflow)/2*2;\n\tans+=((cnt1-maxflow)&1)*3;\n\tprintf(\"%d\\n\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n#include<cstdlib>\n\nusing namespace std;\n\nusing vi = vector<int>;\nvi X;\nint n;\nvector<vi> C;\nint used[207];\nbool isprime(int n) {\n\tfor (int i = 2; i*i < n; i++) {\n\t\tif (n%i == 0)return false;\n\t}\n\treturn true;\n}\nbool dfs(int v) {\n\tused[v] = true;\n\tfor (int i = 0; i < X.size() + 2; i++) {\n\t\tif (!used[i] && C[v][i] > 0) {\n\t\t\tif (dfs(i)) {\n\t\t\t\tC[v][i]--;\n\t\t\t\tC[i][v]++;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\nint main() {\n\tcin >> n;\n\tvi evens;\n\tvi odds;\n\tfor (int i = 0; i < n; i++) {\n\t\tint x;\n\t\tcin >> x;\n\t\tif (!X.empty() && X.back() == x) {\n\t\t\tX.pop_back();\n\t\t\tX.push_back(x + 1);\n\t\t}\n\t\telse {\n\t\t\tX.push_back(x);\n\t\t\tX.push_back(x + 1);\n\t\t}\n\t}\n\tint E = 0;\n\tint O = 0;\n\tfor (int x : X) {\n\t\tif (x % 2 == 0) {\n\t\t\tE++;\n\t\t}\n\t\telse {\n\t\t\tO++;\n\t\t}\n\t}\n\t\t\n\tC.resize(X.size()+2, vi(X.size()+2, 0));\n\tfor (int i = 0; i < X.size(); i++) {\n\t\tif (X[i] % 2 == 0) {\n\t\t\tC[n][i] = 1;\n\t\t}\n\t\telse {\n\t\t\tC[i][n + 1] = 1;\n\t\t}\n\t}\n\tfor (int i = 0; i < X.size(); i++) {\n\t\tfor (int j = i; j < n; j++) {\n\t\t\tif (isprime(abs(X[i] - X[j]))) {\n\t\t\t\tC[i][j] = 1;\n\t\t\t}\n\t\t}\n\t}\n\tint ans = 0;\n\twhile (dfs(X.size())) {\n\t\tmemset(used, false, sizeof(used));\n\t\tans++;\n\t}\n\tif ((E - ans) % 2 == 0) {\n\t\tcout << ans + (E - ans + O - ans) << endl;\n\t}\n\telse {\n\t\tcout << ans + (E - ans - 1 + O - ans - 1) + 3 << endl;\n\t}\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#include<bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n\n#define F first\n#define S second\n#define int long long\n#define ll long long\n//#define int  unsigned long long\n#define pb push_back\n//#define double long double\n\nusing namespace std;\nusing namespace __gnu_pbds;\ntypedef  tree< int , null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> ordered_set;\nconst int mod = 1e9 + 7;\nconst int N = 1000;\nstruct Edge {\n    int from, to, f, c, w;\n};\nvector < Edge >  edges;\nvector < int > g[N];\nint n, d[N], f[N];\nint p[N];\nvoid add(int a, int b, int c, int w){\n    Edge e;\n    e.from = a; e.to = b; e.c = c; e.w = w; e.f = 0;\n    edges.pb(e);\n    g[a].pb(edges.size() - 1);\n    e.w = -e.w; e.c = 0; swap(e.from, e.to);\n    edges.pb(e);\n    g[b].pb(edges.size() - 1);\n}\nbool spfa(int s, int t){\n    for (int i = 1; i < N; i++){\n        d[i] = 1e9;\n        f[i] = 0;\n    }\n    queue < int > q;\n    q.push(s);\n    d[s] = 0;\n    f[s] = 1;\n    while(!q.empty()){\n        int v = q.front();\n        q.pop();\n        f[v] = 0;\n        for (int i = 0; i < g[v].size(); i++){\n            Edge e = edges[g[v][i]];\n            if (e.f < e.c && d[e.to] > d[v] + e.w){\n                p[e.to] = g[v][i];\n                d[e.to] = d[v] + e.w;\n                if (!f[e.to])\n                    q.push(e.to);\n                f[e.to] = 1;\n            }\n        }\n    }\n    return d[t] != 1e9;\n}\nint flow(int s, int t){\n    int cost = 0;\n    while(spfa(s, t)){\n        int v = t;\n        while(v != s && v != 0){\n            auto k = p[v];\n            edges[k].f++;\n            edges[k ^ 1].f--;\n            cost += edges[k].w;\n            v = edges[k].from;\n        }\n    }\n    return cost;\n}\nint mx[N], mn[N];\nint ff(int x){\n    if (x == 2) return 2;\n    int pr = 1;\n    for (int i = 2; i * i <= x; i++){\n        if (x % i == 0) pr = 0;\n    }\n    if (pr) return 1;\n    return 2 + (x % 2);\n}\nmain(){\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    //freopen(\"input.txt\", \"r\", stdin);\n    cin >> n;\n    int p = -1;\n    vector < int > a;\n    for (int i = 1; i <= n; i++){\n        int x;\n        cin >> x;\n        if (x != p + 1){\n            if (p != -1) a.pb(p + 1);\n            a.pb(x);\n        }\n        p = x;\n    }\n    a.pb(p + 1);\n    n = a.size();\n    for (int i = 0; i < a.size(); i++){\n        add(2 * n + 1, i + 1, 1, 0);\n        add(n + i + 1, 2 * n + 2, 1, 0);\n        for (int j = i + 1; j < a.size(); j++){\n            int x = a[i];\n            int y = a[j];\n            add(i + 1, n + j + 1, 1, ff(abs(x - y)));\n        }\n    }\n    n = 2 * n + 2;\n    cout << flow(n - 1, n);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <cmath>\n#include <cstdlib>\n#include <vector>\n#include <set>\n#include <map>\n#include <cassert>\n#include <queue>\n#include <ctime>\n#include <string>\n#include <cstring>\n#include <random>\n#define mp make_pair\n#define pb push_back\n#define NAME \"\"\n#define y1 y1_423\n#define list lista\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\n\ntemplate<typename T>\nostream& operator << (ostream& cout, const vector<T> &a) {\n\tif ((int)a.size() == 0) {\n\t\treturn (cout << \"()\");\n\t}\n\tcout << \"(\" << a[0];\n\tfor (int i = 1; i < (int)a.size(); i++) {\n\t\tcout << \"; \" << a[i];\n\t}\n\treturn (cout << \")\");\n}\n\ntemplate<typename T>\nostream& operator << (ostream& cout, const set<T> &a) {\n\tif ((int)a.size() == 0) {\n\t\treturn (cout << \"{}\");\n\t}\n\tauto it = a.begin();\n\tcout << \"{\" << *it;\n\t++it;\n\tfor (; it != a.end(); ++it) {\n\t\tcout << \"; \" << *it;\n\t}\n\treturn (cout << \"}\");\n}\n\ntemplate<typename T>\nostream& operator << (ostream& cout, const multiset<T> &a) {\n\tif ((int)a.size() == 0) {\n\t\treturn (cout << \"{}\");\n\t}\n\tauto it = a.begin();\n\tcout << \"{\" << *it;\n\t++it;\n\tfor (; it != a.end(); ++it) {\n\t\tcout << \"; \" << *it;\n\t}\n\treturn (cout << \"}\");\n}\n\ntemplate<typename T1, typename T2>\nostream& operator << (ostream& cout, const pair<T1, T2> &a) {\n\treturn cout << \"(\" << a.first << \"; \" << a.second << \")\";\n}\n\nrandom_device gen;\nmt19937 rnd(gen());\n\nconst int nmax = 1000 * 1000 * 10 + 10;\nconst int inf = 2000 * 1000 * 1000;\nconst ll infl = 1000ll * 1000ll * 1000ll * 1000ll * 1000ll * 1000ll;\nconst int mod = 1000 * 1000 * 1000 + 7;\nconst ld pi = acos(-1.0);\n\nint used[nmax], u[nmax], p[nmax], b[nmax];\nvector<int> a, go[nmax];\n\nbool ok(int v) {\n\tif (u[v]) return false;\n\tfor (int u : go[v]) {\n\t\tif (p[u] == -1) {\n\t\t\tp[u] = v;\n\t\t\treturn true;\n\t\t}\n\t}\n\tfor (int u : go[v]) {\n\t\tif (ok(u)) {\n\t\t\tp[u] = v;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint main() {\n\t//freopen(\"input.txt\", \"r\", stdin);freopen(\"output.txt\", \"w\", stdout);\n\t//freopen(NAME\".in\", \"r\", stdin);freopen(NAME\".out\", \"w\", stdout);\n\tfor (int i = 2; i < nmax; i++) {\n\t\tused[i] = 1;\n\t}\n\tfor (ll i = 2; i * i < nmax; i++) {\n\t\tif (!used[i]) continue;\n\t\tfor (ll j = i * i; j < nmax; j += i) {\n\t\t\tused[j] = 0;\n\t\t}\n\t}\n\tused[0] = used[1] = used[2] = 0;\n\tint n;\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; i++) {\n\t\tint x;\n\t\tscanf(\"%d\", &x);\n\t\tb[x] ^= 1;\n\t\tb[x + 1] ^= 1;\n\t}\n\tfor (int i = 0; i < nmax; i++) {\n\t\tif (b[i] == 1) {\n\t\t\ta.pb(i);\n\t\t}\n\t}\n\tn = a.size();\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif (i == j) continue;\n\t\t\tif (used[abs(a[i] - a[j])]) {\n\t\t\t\tgo[i].pb(j);\n\t\t\t}\n\t\t}\n\t}\n\tint cnt0 = 0, cnt1 = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (a[i] % 2 == 0) {\n\t\t\tcnt0++;\n\t\t} else {\n\t\t\tcnt1++;\n\t\t}\n\t}\n\tfor (int j = 0; j < n; j++) {\n\t\tp[j] = -1;\n\t}\n\tint answer = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (a[i] % 2 == 0) continue;\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tu[j] = 0;\n\t\t}\n\t\tif (ok(i)) answer++;\n\t}\n\tcout << answer + ((cnt0 - answer) / 2 + (cnt1 - answer) / 2) * 2 + ((cnt1 - answer) % 2) * 3 << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n\nint N,x[101],A[101][101],D[101][101];\nbool isp[10000001];\n\nvoid mn(int &a, int b)\n{\n\tif (a > b)\n\t\ta = b;\n}\n\nint push(int l)\n{\n\tif (l == 0) return 0;\n\tif (!isp[l]) return 1;\n\tif (l % 2 == 0) return 2;\n\treturn 3;\n}\n\nint main()\n{\n\tscanf (\"%d\",&N);\n\tfor (int i=0;i<N;i++) scanf (\"%d\",&x[i]);\n\n\tfor (int i=2;i*i<=10000000;i++) if (!isp[i]){\n\t\tfor (int j=i*i;j<=10000000;j+=i) isp[j] = 1;\n\t}\n\tisp[0] = isp[1] = isp[2] = 1;\n\n\tfor (int l=0;l<N;l++){\n\t\tif (l == N-1){\n\t\t\tint c = 0;\n\t\t\tc++;\n\t\t}\n\t\tfor (int i=0,j=l;j<N;i++,j++){\n\t\t\tif (l == 0) D[i][j] = 3;\n\t\t\telse{\n\t\t\t\tD[i][j] = A[i][j] = 0x7fffffff;\n\t\t\t\tfor (int k=i;k<j;k++){\n\t\t\t\t\tmn(D[i][j],D[i][k]+D[k+1][j]);\n\t\t\t\t\tmn(A[i][j],A[i][k]+A[k+1][j]+push(x[k+1]-x[k]-1));\n\t\t\t\t}\n\t\t\t\tif (x[j] - x[i] == j - i) mn(D[i][j],push(j-i+1));\n\n\t\t\t\tfor (int k=i;k<j;k++){\n\t\t\t\t\tfor (int l=j;l>k;l--){\n\t\t\t\t\t\tint u = push(x[j]-x[i]+1) + push(x[l]-x[k]-1);\n\t\t\t\t\t\tmn(D[i][j],A[i][k]+D[k+1][l-1]+A[l][j]+u);\n\t\t\t\t\t\tint v = push(x[j]-x[k]) + push(x[l]-x[i]);\n\t\t\t\t\t\tmn(D[i][j],A[i][k]+D[k+1][l-1]+A[l][j]+v);\n\t\t\t\t\t\t\n\t\t\t\t\t\tmn(A[i][j],A[i][k]+D[k+1][l-1]+A[l][j]+push(x[l]-x[k]-1));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf (\"%d\\n\",D[0][N-1]);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define N 210\n#define pb push_back\nvector<int> v[N];\nint a[N],b[N],vis[N];\nint s[10000010];\ninline int read() {\n    int x=0;\n    char ch=getchar();\n    while (!isdigit(ch)) ch=getchar();\n    while (isdigit(ch)) x=x*10+ch-'0',ch=getchar();\n    return x;\n}\ninline int P(int x) {\n    if (x<2) return false;\n    for (int i=2;i<=sqrt(x);i++)\n        if (x%i==0) return false;\n    return true;\n}\nint mat[N];\ninline int dfs(int x) {\n    for (auto y:v[x]) {\n        if (vis[y]) continue;\n        if (!mat[y] || dfs(mat[y])) return mat[y]=x,1;\n    }\n    return false;\n}\nint main() {\n    int n=read(),Max=0,cnta=0,cntb=0,ans=0,res=0;\n    for (int i=1;i<=n;i++) s[Max=max(Max,read())]^=1;\n    for (int i=1;i<=Max+1;i++) if (s[i]!=s[i-1])\n        ((i&1)?(a[++cnta]):(b[++cntb]))=i;\n    // cout<<cnta<<endl;\n    // cout<<cntb<<endl;\n    for (int i=1;i<=cnta;i++)\n        for (int j=1;j<=cntb;j++) if (P(abs(a[i]-b[j]))) v[i].pb(j);\n    for (int i=1;i<=cnta;i++) {\n        for (int j=1;j<=cntb;j++) vis[j]=0; ans+=dfs(i);\n    }\n    // cout<<ans<<endl;\n    res+=(cnta-ans)/2*2;\n    res+=(cntb-ans)/2*2;\n    res+=ans+((cnta-ans)&1)*3;\n    cout<<res<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <set>\n#include <bitset>\nusing namespace std;\nint N;\nint x;\nset<int> S;\nvector<int> G[105];\nint L[105];\nint R[105];\nvector<int> Me,Mo;\nbitset<105> U;\nbool prime(int nr)\n{\n    for(int i=2;i*i<=nr;i++)if(nr%i==0)return 0;\n    return 1;\n}\nbool pairup(int nod)\n{\n    if(U[nod])return 0;\n    U[nod]=1;\n    for(auto it:G[nod])\n    {\n        if(!R[it])\n        {\n            L[nod]=it;\n            R[it]=nod;\n            return 1;\n        }\n    }\n    for(auto it:G[nod])\n    {\n        if(pairup(R[it]))\n        {\n            L[nod]=it;\n            R[it]=nod;\n            return 1;\n        }\n    }\n    return 0;\n}\nint main()\n{\n    cin>>N;\n    for(int i=1;i<=N;i++)\n    {\n        cin>>x;\n        if(S.find(x)!=S.end())\n        {\n            S.erase(x);\n        }\n        else\n        {\n            S.insert(x);\n        }\n        S.insert(x+1);\n    }\n    for(auto it:S)\n        if(it%2==0)\n            Me.push_back(it);\n        else\n            Mo.push_back(it);\n    for(int i=0;i<Me.size();i++)\n    {\n        for(int j=0;j<Mo.size();j++)\n        {\n            if(prime(abs(Mo[j]-Me[i])))\n                G[i].push_back(j);\n        }\n    }\n    bool ok=1;\n    int k=0;\n    while(ok)\n    {\n        ok=0;\n        U.reset();\n        for(int i=1;i<=N;i++)\n        {\n            if(!L[i]&&pairup(i))\n            {\n                k++;\n                ok=1;\n            }\n        }\n    }\n    int rez=k+(((int)Me.size()-k)/2)*2+(((int)Mo.size()-k)/2)*2+(((int)Me.size()-k)%2)*3;\n    cout<<rez;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(2)\n#include<bits/stdc++.h>\n#define ll long long\n#define maxn 1000005\n#define N 10000005\n#define inf 1e9\n#define pb push_back\n#define rep(i,a,b) for(int i=a;i<=b;i++)\n#define per(i,a,b) for(int i=a;i>=b;i--)\nusing namespace std;\n\ninline int read()\n{\n\tint x=0,w=1; char c=getchar();\n\twhile(c<'0'||c>'9') {if(c=='-') w=-1; c=getchar();}\n\twhile(c<='9'&&c>='0') {x=(x<<1)+(x<<3)+c-'0'; c=getchar();}\n\treturn w==1?x:-x;\n}\n\nbool x[N],is[N];\nint l[maxn],r[maxn],c[maxn],cr,cl,cnt,pri[maxn];\n\nstruct node{int from,to,cap,flow,cost;};\nvector <node> edges;\nvector <int> mp[maxn];\nint s,t,n,m,d[maxn],flow,cost,p[maxn],a[maxn];\nbool inq[maxn];\nqueue <int> que;\n\ninline void A(int u,int v,int w,int c)\n{\n\tedges.push_back((node){u,v,w,0,c});\n\tedges.push_back((node){v,u,0,0,-c});\n\tint pp=edges.size();\n\tmp[u].push_back(pp-2);\n\tmp[v].push_back(pp-1);\n}\n\ninline bool spfa()\n{\n\tfor(int i=0;i<=t;i++) d[i]=inf,inq[i]=0,a[i]=inf;\n\tque.push(s); d[s]=0;\n\twhile(!que.empty())\n\t{\n\t\tint u=que.front(); que.pop(); inq[u]=0;\n\t\tfor(int i=0;i<mp[u].size();i++)\n\t\t{\n\t\t\tnode &v=edges[mp[u][i]];\n\t\t\tif(v.cap-v.flow>0&&d[v.to]>d[u]+v.cost)\n\t\t\t{\n\t\t\t\td[v.to]=d[u]+v.cost;\n\t\t\t\ta[v.to]=min(a[u],v.cap-v.flow);\n\t\t\t\tp[v.to]=mp[u][i];\n\t\t\t\tif(inq[v.to]==0) que.push(v.to),inq[v.to]=1;\n\t\t\t}\n\t\t}\n\t}\n\tif(d[t]==inf) return false;\n\tflow+=a[t];\n\tcost+=a[t]*d[t];\n\tfor(int i=t;i!=s;i=edges[p[i]].from)\n\t{\n\t\tedges[p[i]].flow+=a[t];\n\t\tedges[p[i]^1].flow-=a[t];\n\t}\n\treturn true;\n}\n\ninline void pre()\n{\n\tfor(int i=2;i<=(N-4);i++)\n\t{\n\t\tif(!is[i]) pri[++cnt]=i;\n\t\tfor(int j=1;j<=cnt,pri[j]*i<=(N-5);j++)\n\t\t{\n\t\t\tis[pri[j]*i]=1;\n\t\t\tif(i%pri[j]==0) break;\n\t\t}\n\t}\n}\n\nint main()\n{\n\tn=read(); pre(); rep(i,1,n) c[i]=read(),x[c[i]]=1;\n\trep(i,1,(N-4))\n\t{\n\t\tif(x[i]!=x[i-1])\n\t\t{\n\t\t\tif(x[i]==0) r[++cr]=i-1;\n\t\t\telse l[++cl]=i;\n\t\t}\n\t}\n\t//rep(i,1,cl) cout<<l[i]<<\" \"; puts(\"\");\n\t//rep(i,1,cr) cout<<r[i]<<\" \"; puts(\"\");\n\ts=0; t=2*cl+1;\n\trep(i,1,cl) A(s,i,1,0); rep(i,1,cr) A(i+cl,t,1,0);\n\trep(i,1,cl) rep(j,1,cr)\n\t{\n\t\tint p=l[i]-1,p2=r[j]; if(p<p2) swap(p,p2);\n\t\tint len=p-p2;\n\t\tif(len%2==0) A(i,j+cl,1,2);\n\t\telse if(len==1) A(i,j+cl,1,3);\n\t\telse if(!is[len]) A(i,j+cl,1,1);\n\t\telse A(i,j+cl,1,3);\n\t}\n\twhile(spfa()); cout<<cost<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nconst int N=110,M=10001000,oo=1000000000;\nint i,j,k,n,nm,ans;\nint a[N],fg[M],pr[M/10],f[N][N],g[N][N];\nvoid pre(int n) {\n\tint i,j;\n\tfg[1]=3;\n\tfor (i=2;i<=n;i++) {\n\t\tif (fg[i]!=3) pr[++nm]=i,fg[i]=1;\n\t\tfor (j=1;j<=nm;j++) {\n\t\t\tif (i*pr[j]>n) break;\n\t\t\tfg[i*pr[j]]=3;\n\t\t\tif (i%pr[j]==0) break;\n\t\t}\n\t}\n\tfor (i=2;i<=n;i+=2) fg[i]=2;\n}\nint G(int l,int r);\nint F(int l,int r) {\n\tif (l==r) return 3;\n\tint &res=f[l][r];\n\tif (res!=-1) return res;\n\tres=oo;\n\tfor (int k=l;k<r;k++) res=min(res,min(F(l,k)+F(k+1,r),G(l,k)+G(k+1,r)+fg[a[k+1]-a[k]-1]+fg[a[r]-a[l]+1]));\n\treturn res;\n}\nint G(int l,int r) {\n\tif (l==r) return 0;\n\tint &res=g[l][r];\n\tif (res!=-1) return res;\n\tres=oo;\n\tfor (int k=l;k<r;k++) res=min(res,min(G(l,k)+G(k+1,r)+fg[a[k+1]-a[k]-1],F(l,k)+F(k+1,r)+fg[a[r]-a[l]+1]));\n\treturn res;\n}\nint main() {\n\tmemset(f,-1,sizeof f);\n\tmemset(g,-1,sizeof g);\n\tscanf(\"%d\",&n);\n\tfor (i=1;i<=n;i++) scanf(\"%d\",&a[i]);\n\tpre(a[n]);\n\tprintf(\"%d\\n\",F(1,n));\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn=105;\nint n,a[maxn],cnt[2],match[maxn];\nbool used[maxn];\nvector<int> G[maxn],diff;\nset<int> vis;\nbool dfs(int v) {\n    used[v]=1;\n    for (int i=0;i<(int)G[v].size();++i) {\n        int u=G[v][i],w=match[u];\n        if (!w||(!used[w]&&dfs(w))) {\n            match[v]=u;\n            match[u]=v;\n            return true;\n        }\n    }\n    return false;\n}\ninline int bipartite_matching() {\n    int ret=0;\n    for (int i=0;i<(int)diff.size();++i)\n        if (!match[i]) {\n            memset(used,0,sizeof used);\n            ret+=dfs(i);\n        }\n    return ret;\n}\nbool check(int x) {\n    if (x<=2)\n        return false;\n    for (int i=2;i*i<=x;++i)\n        if (x%i==0)\n            return false;\n    return true;\n}\nint main()\n{\n    scanf(\"%d\",&n);\n    for (int i=1;i<=n;++i) {\n        scanf(\"%d\",&a[i]);\n        vis.insert(a[i]);\n    }\n    for (int i=1;i<=n;++i) {\n        if (vis.find(a[i]-1)==vis.end()) {\n            diff.push_back(a[i]);\n            ++cnt[a[i]%2];\n        }\n        if (vis.find(a[i]+1)==vis.end()) {\n            diff.push_back(a[i]+1);\n            ++cnt[(a[i]+1)%2];\n        }\n    }\n    for (int i=0;i<(int)diff.size();++i)\n        for (int j=i+1;j<(int)diff.size();++j)\n            if (check(abs(diff[i]-diff[j]))) {\n                G[i].push_back(j);\n                G[j].push_back(i);\n            }\n    int k=bipartite_matching();\n    printf(\"%d\\n\",k+2*((cnt[0]-k)/2+(cnt[1]-k)/2)+3*(cnt[0]-k)%2*3);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\ntypedef long long ll;\n\n#define N 10000050\n#define INF 30000000\n#define Min(a,b) (a<b?a:b)\n\nint noprm[N];\nint prm[N/5],pcnt;\nvoid init(int lim)\n{\n\tnoprm[1]=1;\n\tfor(int i=2;i<=lim;i++)\n\t{\n\t\tif(!noprm[i])\n\t\t{\n\t\t\tprm[++pcnt]=i;\n\t\t}\n\t\tfor(int j=1;j<=pcnt && (ll)i*prm[j]<=lim;j++)\n\t\t{\n\t\t\tnoprm[i*prm[j]]=1;\n\t\t\tif(i%prm[j]==0) break;\n\t\t}\n\t}\n}\n\nint a[105];\nint tp[205],len[205];\nint f[2][205][205];\n\ninline int calc(int p)\n{\n\treturn (p&1)? (noprm[p]? 3: 1): 2;\n}\n\nint solve(int tp,int l,int r)\n{\n\tif(f[tp][l][r]!=-1) return f[tp][l][r];\n\tif(l==r) return INF;\n\tint &res1=f[tp][l][r];\n\tint &res2=f[tp^1][l][r];\n\tres1=res2=INF;\n\tfor(int i=l;i<=r;i++)\n\t\tfor(int j=i;j<=r;j++)\n\t\t{\n\t\t\tif(i==l && j==r) continue;\n\t\t\tint tmp1= i>l? solve(tp,l,i-1): 0;\n\t\t\tint tmp2=solve(tp^1,i,j);\n\t\t\tint tmp3= j<r? solve(tp,j+1,r): 0;\n\t\t\tint tmp4=calc(len[j]-len[i-1]);\n\t\t\tres1=Min(res1,tmp1+tmp2+tmp3+tmp4);\n\t\t\ttp^=1;\n\t\t\ttmp1= i>l? solve(tp,l,i-1): 0;\n\t\t\ttmp2=solve(tp^1,i,j);\n\t\t\ttmp3= j<r? solve(tp,j+1,r): 0;\n\t\t\tres2=Min(res2,tmp1+tmp2+tmp3+tmp4);\n\t\t\ttp^=1;\n\t\t}\n\tint tmp=calc(len[r]-len[l-1]);\n\tres1=Min(res1,res2+tmp);\n\tres2=Min(res2,res1+tmp);\n\treturn res1;\n}\n\nint main()\n{\n\tinit(10000000);\n\tint n;scanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)\n\t\tscanf(\"%d\",&a[i]);\n\tint scnt=0,start=1;\n\tif(a[1]>1)\n\t{\n\t\t++scnt;\n\t\ttp[scnt]=0;\n\t\tlen[scnt]=a[1]-1;\n\t}\n\t\n\tfor(int i=2;i<=n+1;i++)\n\t\tif(i==n+1)\n\t\t{\n\t\t\t++scnt;\n\t\t\ttp[scnt]=1,len[scnt]=a[i-1]-a[start]+1;\n\t\t}\n\t\telse if(a[i]!=a[i-1]+1)\n\t\t{\n\t\t\t++scnt;\n\t\t\ttp[scnt]=1,len[scnt]=a[i-1]-a[start]+1;\n\t\t\t++scnt;\n\t\t\ttp[scnt]=0,len[scnt]=a[i]-a[i-1]-1;\n\t\t\tstart=i;\n\t\t}\n\tmemset(f,-1,sizeof(f));\n\tfor(int i=1;i<=scnt;i++)\n\t\tf[tp[i]][i][i]=0,f[tp[i]^1][i][i]=calc(len[i]);\n\tfor(int i=1;i<=scnt;i++)\n\t\tlen[i]+=len[i-1];\n\tint ans=solve(0,1,scnt);\n\tprintf(\"%d\\n\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\nusing namespace std;\nconst int N=110;\nbool f[10001000],fl[N][N],fla[N];\nint n,p[1000100],cnt,a[N],cot,from[N],nj[N],no[N];\nbool match(int x)\n{\n    if(fla[x]) return false;\n    fla[x]=true;\n    for(int i=1;i<=nj[0];++i)\n        if(fl[x][i]&&(from[i]==0||match(from[i])))\n        {\n            from[i]=x;\n            return true;\n        }\n    return false;\n}\nvoid init()\n{\n    for(int i=2;i<=1000050;++i)\n    {\n        if(!f[i]) p[++cnt]=i;\n            for(int j=1;j<=cnt&&p[j]*i<=1000050;++j)\n            {\n                f[p[j]*i]=true;\n                if(i%p[j]==0) break;\n            }\n    }\n}\nint main()\n{\n    ios::sync_with_stdio(false);\n    init();\n    f[1]=true;\n    f[2]=false;\n    cin>>n;\n    int t=-10,t1;\n    for(int i=1;i<=n;++i)\n    {\n        cin>>t1;\n        if(t1-t!=1) \n        {\n            a[cot++]=t+1;\n            if(t1-t!=2) a[cot++]=t1;\n        }\n        t=t1;\n    }\n    a[cot]=t1+1;\n    for(int i=1;i<=cot;++i)\n    {\n        if(a[i]%2)\n            nj[++nj[0]]=a[i];\n        else\n            no[++no[0]]=a[i];\n    }\n    for(int i=1;i<=nj[0];++i)\n        for(int j=1;j<=no[0];++j)\n            fl[i][j]=!f[abs(nj[i]-no[i])];\n    int ans=0;\n    for(int i=1;i<=nj[0];++i)\n    {\n        memset(fla,false,sizeof(fla));\n        if(match(i)) ans++;\n    }\n    cout<< ans+(nj[0]-ans)/2*2+(no[0]-ans)/2*2+(nj[0]-ans)%2*3 <<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n\nint N,x[101],D[101][101];\nbool isp[10000001];\n\nvoid mn(int &a, int b)\n{\n\tif (a > b)\n\t\ta = b;\n}\n\nint push(int l)\n{\n\tif (!isp[l]) return 1;\n\tif (l % 2 == 0) return 2;\n\treturn 3;\n}\n\nint main()\n{\n\tscanf (\"%d\",&N);\n\tfor (int i=0;i<N;i++) scanf (\"%d\",&x[i]);\n\n\tfor (int i=2;i*i<=10000000;i++) if (!isp[i]){\n\t\tfor (int j=i*i;j<=10000000;j+=i) isp[j] = 1;\n\t}\n\tisp[0] = isp[1] = isp[2] = 1;\n\n\tfor (int l=0;l<N;l++){\n\t\tif (l == N-1){\n\t\t\tint c = 0;\n\t\t\tc++;\n\t\t}\n\t\tfor (int i=0,j=l;j<N;i++,j++){\n\t\t\tif (l == 0) D[i][j] = 3;\n\t\t\telse{\n\t\t\t\tD[i][j] = 0x7fffffff;\n\t\t\t\tfor (int k=i;k<j;k++) mn(D[i][j],D[i][k]+D[k+1][j]);\n\t\t\t\tif (x[j] - x[i] == j - i) mn(D[i][j],push(j-i+1));\n\n\t\t\t\tfor (int k=i;k<j;k++) if (x[k] - x[i] == k - i){\n\t\t\t\t\tfor (int l=j;l>k;l--) if (x[j] - x[l] == j - l){\n\t\t\t\t\t\tint u = push(x[j]-x[i]+1) + push(x[l]-x[k]-1);\n\t\t\t\t\t\tmn(D[i][j],D[k+1][l-1]+u);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf (\"%d\\n\",D[0][N-1]);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fi first\n#define se second\n#define pii pair<int,int>\n#define mp make_pair\n#define pb push_back\n#define space putchar(' ')\n#define enter putchar('\\n')\n#define MAXN 200005\n#define eps 1e-12\n//#define ivorysi\nusing namespace std;\ntypedef long long int64;\ntypedef unsigned int u32;\ntypedef double db;\ntemplate<class T>\nvoid read(T &res) {\n    res = 0;T f = 1;char c = getchar();\n    while(c < '0' || c > '9') {\n        if(c == '-') f = -1;\n        c = getchar();\n    }\n    while(c >= '0' && c <= '9') {\n        res = res * 10 + c - '0';\n        c = getchar();\n    }\n    res *= f;\n}\ntemplate<class T>\nvoid out(T x) {\n    if(x < 0) {x = -x;putchar('-');}\n    if(x >= 10) {\n        out(x / 10);\n    }\n    putchar('0' + x % 10);\n}\nint N;\nbool nonprime[10000005],vis[10000005];\nint prime[10000005],tot,x[205],b[205],M[2],matc[205];\nvector<int> to[505];\nbool used[205];\nbool match(int u) {\n    for(auto t : to[u]) {\n        if(!used[t]) {\n            used[t] = 1;\n            if(!matc[t] || match(matc[t])) {\n                matc[t] = u;\n                return true;\n            }\n        }\n    }\n    return false;\n}\nvoid Solve() {\n    read(N);\n    for(int i = 1 ; i <= N ; ++i) {\n        read(x[i]);\n        vis[x[i]] = 1;\n    }\n    for(int i = 2 ; i <= 10000000 ; ++i) {\n        if(!nonprime[i]) {\n            prime[++tot] = i;\n        }\n        for(int j = 1 ; j <= tot ; ++j) {\n            if(prime[j] > 10000000 / i) break;\n            nonprime[i * prime[j]] = 1;\n            if(i % prime[j] == 0) break;\n        }\n    }\n    tot = 0;\n    for(int i = 1 ; i <= 10000001 ; ++i) {\n        if(vis[i] != vis[i - 1]) b[++tot] = i;\n    }\n    for(int i = 1 ; i <= tot ; ++i) {\n        M[b[i] & 1]++;\n        for(int j = 1 ; j <= tot ; ++j) {\n            if(i == j) continue;\n            if(abs(b[i] - b[j]) < 3) continue;\n            if(!nonprime[abs(b[i] - b[j])]) to[i].pb(j);\n        }\n    }\n    int ans = 0;\n    for(int i = 1 ; i <= tot ; ++i) {\n        if(b[i] & 1) {\n            memset(used,0,sizeof(used));\n            if(match(i)) ++ans;\n        }\n    }\n    out(ans + ((M[0] - ans) / 2 + (M[1] - ans) / 2) * 2 + ((M[0] - ans) & 1) * 3);enter;\n}\nint main() {\n#ifdef ivorysi\n\tfreopen(\"f1.in\",\"r\",stdin);\n#endif\n    Solve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,l,r) for(register int i = l ; i <= r ; i++)\n#define repd(i,r,l) for(register int i = r ; i >= l ; i--)\n#define rvc(i,S) for(register int i = 0 ; i < (int)S.size() ; i++)\n#define rvcd(i,S) for(register int i = ((int)S.size()) - 1 ; i >= 0 ; i--)\n#define fore(i,x)for (register int i = head[x] ; i ; i = e[i].next)\n#define forup(i,l,r) for (register int i = l ; i <= r ; i += lowbit(i))\n#define fordown(i,id) for (register int i = id ; i ; i -= lowbit(i))\n#define pb push_back\n#define prev prev_\n#define stack stack_\n#define mp make_pair\n#define fi first\n#define se second\n#define lowbit(x) (x&(-x))\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pr;\n\nconst ll MAX = 2e18;\nconst ld inf = 2e18;\nconst int maxn = 220;\nconst ll mod = 1e9 + 7;\n\ninline ll power(ll x,ll y){\n\ty = ((y % (mod - 1)) + (mod - 1)) % (mod - 1);\n//\tif ( y < 0 ) return power(power(x,-y),mod - 2);\n\tll res = 1;\n\twhile ( y ){\n\t\tif ( y & 1 ) res = res * x % mod;\n\t\tx = x * x % mod;\n\t\ty >>= 1;\n\t}\n\treturn res;\n}\nint a[maxn],n,odd[maxn],even[maxn],cnt1,cnt2;\nset <int> s;\nnamespace Prime{\n\tconst int N = 1e7;\n\tint prime[N + 20],tag[N + 20],mn[N + 20],Cnt;\t\n\tvoid init (){\n\t\ttag[1] = 1;\n\t\trep(i,2,N){\n\t\t\tif ( !tag[i] ) prime[++Cnt] = i;\n\t\t\trep(j,1,Cnt){\n\t\t\t\tif ( prime[j] * i > N ) break;\n\t\t\t\ttag[i * prime[j]] = 1;\n\t\t\t\tmn[i * prime[j]] = prime[j];\n\t\t\t\tif ( i % prime[j] == 0 ) break;\n\t\t\t}\n\t\t}\n\t}\n}\nusing namespace Prime;\n\nstruct node{\n\tint next,to;\n}e[maxn * maxn];\nint head[maxn],cnt;\nint from[maxn],use[maxn],tot;\n\ninline void adde(int x,int y){\n\te[++cnt].to = y;\n\te[cnt].next = head[x];\n\thead[x] = cnt;\n}\nbool match(int x){\n\tfore(i,x){\n\t\tif ( !use[e[i].to] ){\n\t\t\tuse[e[i].to] = 1;\n\t\t\tif ( from[e[i].to] == -1 || match(from[e[i].to]) ){\n\t\t\t\tfrom[e[i].to] = x;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nvoid hungary(){\n\ttot = 0;\n\tmemset(from,-1,sizeof(from));\n\tn = cnt1;\n\trep(i,1,n){\n\t\tmemset(use,0,sizeof(use));\n\t\tif ( match(i) ) ++tot;\n\t}\n}\n\n\nint main(){\n\tinit();\n\tscanf(\"%d\",&n);\n\trep(i,1,n){\n\t   \tscanf(\"%d\",&a[i]);\n\t\tif ( s.find(a[i]) == s.end() ) s.insert(a[i]);\n\t\telse s.erase(a[i]);\n\n\t\tif ( s.find(a[i] + 1) == s.end() ) s.insert(a[i] + 1);\n\t\telse s.erase(a[i] + 1);\n\t}\n\tfor (auto it = s.begin() ; it != s.end() ; ++it){\n\t\tint x = *it;\n\t\tif ( x & 1 ) odd[++cnt1] = x;\n\t\telse even[++cnt2] = x;\n\t}\n\trep(i,1,cnt1){\n\t\trep(j,1,cnt2){\n\t\t\tint c = abs(odd[i] - even[j]);\n\t\t\tif ( !tag[c] ) adde(i,j + cnt1);\n\t\t}\n\t}\n\thungary();\n\tcout<<cnt1 + cnt2 - tot + ((cnt1 - tot) & 1)<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define forr(x,arr) for(auto&& x:arr)\n#define _overload3(_1,_2,_3,name,...) name\n#define _rep2(i,n) _rep3(i,0,n)\n#define _rep3(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload3(__VA_ARGS__,_rep3,_rep2,)(__VA_ARGS__)\n#define _rrep2(i,n) _rrep3(i,0,n)\n#define _rrep3(i,a,b) for(int i=int(b)-1;i>=int(a);i--)\n#define rrep(...) _overload3(__VA_ARGS__,_rrep3,_rrep2,)(__VA_ARGS__)\n#define all(x) (x).begin(),(x).end()\n#define bit(n) (1LL<<(n))\n#define sz(x) ((int)(x).size())\n#define TEN(n) ((ll)(1e##n))\n#define fst first\n#define snd second\n\nstring DBG_DLM(int &i){return(i++==0?\"\":\", \");}\n#define DBG_B(exp){int i=0;os<<\"{\";{exp;}os<<\"}\";return os;}\ntemplate<class T>ostream&operator<<(ostream&os,vector<T>v);\ntemplate<class T>ostream&operator<<(ostream&os,set<T>v);\ntemplate<class T>ostream&operator<<(ostream&os,queue<T>q);\ntemplate<class T>ostream&operator<<(ostream&os,priority_queue<T>q);\ntemplate<class T,class K>ostream&operator<<(ostream&os,pair<T,K>p);\ntemplate<class T,class K>ostream&operator<<(ostream&os,map<T,K>mp);\ntemplate<class T,class K>ostream&operator<<(ostream&os,unordered_map<T,K>mp);\ntemplate<int I,class TPL>void DBG(ostream&os,TPL t){}\ntemplate<int I,class TPL,class H,class...Ts>void DBG(ostream&os,TPL t){os<<(I==0?\"\":\", \")<<get<I>(t);DBG<I+1,TPL,Ts...>(os,t);}\ntemplate<class T,class K>void DBG(ostream&os,pair<T,K>p,string delim){os<<\"(\"<<p.first<<delim<<p.second<<\")\";}\ntemplate<class...Ts>ostream&operator<<(ostream&os,tuple<Ts...>t){os<<\"(\";DBG<0,tuple<Ts...>,Ts...>(os,t);os<<\")\";return os;}\ntemplate<class T,class K>ostream&operator<<(ostream&os,pair<T,K>p){DBG(os,p,\", \");return os;}\ntemplate<class T>ostream&operator<<(ostream&os,vector<T>v){DBG_B(forr(t,v){os<<DBG_DLM(i)<<t;});}\ntemplate<class T>ostream&operator<<(ostream&os,set<T>s){DBG_B(forr(t,s){os<<DBG_DLM(i)<<t;});}\ntemplate<class T>ostream&operator<<(ostream&os,queue<T>q){DBG_B(for(;q.size();q.pop()){os<<DBG_DLM(i)<<q.front();});}\ntemplate<class T>ostream&operator<<(ostream&os,priority_queue<T>q){DBG_B(for(;q.size();q.pop()){os<<DBG_DLM(i)<<q.top();});}\ntemplate<class T,class K>ostream&operator<<(ostream&os,map<T,K>m){DBG_B(forr(p,m){os<<DBG_DLM(i);DBG(os,p,\"->\");});}\ntemplate<class T,class K>ostream&operator<<(ostream&os,unordered_map<T,K>m){DBG_B(forr(p,m){os<<DBG_DLM(i);DBG(os,p,\"->\");});}\n#define DBG_OVERLOAD(_1,_2,_3,_4,_5,_6,macro_name,...)macro_name\n#define DBG_LINE(){char s[99];sprintf(s,\"line:%3d | \",__LINE__);cerr<<s;}\n#define DBG_OUTPUT(v){cerr<<(#v)<<\"=\"<<(v);}\n#define DBG1(v,...){DBG_OUTPUT(v);}\n#define DBG2(v,...){DBG_OUTPUT(v);cerr<<\", \";DBG1(__VA_ARGS__);}\n#define DBG3(v,...){DBG_OUTPUT(v);cerr<<\", \";DBG2(__VA_ARGS__);}\n#define DBG4(v,...){DBG_OUTPUT(v);cerr<<\", \";DBG3(__VA_ARGS__);}\n#define DBG5(v,...){DBG_OUTPUT(v);cerr<<\", \";DBG4(__VA_ARGS__);}\n#define DBG6(v,...){DBG_OUTPUT(v);cerr<<\", \";DBG5(__VA_ARGS__);}\n#define DEBUG0(){DBG_LINE();cerr<<endl;}\n#ifdef LOCAL\n#define out(...){DBG_LINE();DBG_OVERLOAD(__VA_ARGS__,DBG6,DBG5,DBG4,DBG3,DBG2,DBG1)(__VA_ARGS__);cerr<<endl;}\n#else\n#define out(...)\n#endif\n\nusing ll=long long;\nusing pii=pair<int,int>;using pll=pair<ll,ll>;using pil=pair<int,ll>;using pli=pair<ll,int>;\nusing vs=vector<string>;using vvs=vector<vs>;using vvvs=vector<vvs>;\nusing vb=vector<bool>;using vvb=vector<vb>;using vvvb=vector<vvb>;\nusing vi=vector<int>;using vvi=vector<vi>;using vvvi=vector<vvi>;\nusing vl=vector<ll>;using vvl=vector<vl>;using vvvl=vector<vvl>;\nusing vd=vector<double>;using vvd=vector<vd>;using vvvd=vector<vvd>;\nusing vpii=vector<pii>;using vvpii=vector<vpii>;using vvvpii=vector<vvpii>;\ntemplate<class A,class B>bool amax(A&a,const B&b){return b>a?a=b,1:0;}\ntemplate<class A,class B>bool amin(A&a,const B&b){return b<a?a=b,1:0;}\nll ri(){ll l;cin>>l;return l;} string rs(){string s;cin>>s;return s;}\n\nbool is_prime(const int64_t n) {\n  if (n < 2) return false;\n  if (n % 2 == 0) return false;\n  for (int64_t i = 3; i * i <= n; i += 2) {\n    if (n % i == 0) return false;\n  }\n  return true;\n}\n\nclass BipartiteMatching {\n  bool dfs(int v) {\n    used[v] = true;\n    for (int i = 0; i < (int)G[v].size(); i++) {\n      int u = G[v][i], w = match[u];\n      if (w < 0 || (!used[w] && dfs(w))) {\n        match[v] = u;\n        match[u] = v;\n        return true;\n      }\n    }\n    return false;\n  }\n\n  public:\n  int V;\n  vector<vector<int>> G;\n  vector<int> match;\n  vector<bool> used;\n\n  BipartiteMatching(int V) : V(V), G(V), match(V, -1), used(V) {}\n\n  void add_edge(int u, int v) {\n    G[u].push_back(v);\n    G[v].push_back(u);\n  }\n\n  int matching() {\n    int res = 0;\n    for (int v = 0; v < V; v++) {\n      if (match[v] < 0) {\n        fill(used.begin(), used.end(), 0);\n        if (dfs(v)) {\n          res++;\n        }\n      }\n    }\n    return res;\n  }\n};\n\nvoid Main() {\n  int n = ri();\n  vector<int> A(n);\n  rep(i, n) A[i] = ri();\n\n  sort(all(A));\n\n  vi B;\n  rep(i, n) {\n    if (i) {\n      if (A[i-1] != A[i] - 1) B.emplace_back(A[i]);\n    }\n    else {\n      B.emplace_back(A[i]);\n    }\n    if (i + 1 < n) {\n      if (A[i+1] != A[i] + 1) B.emplace_back(A[i]+1);\n    }\n    else {\n      B.emplace_back(A[i]+1);\n    }\n  }\n\n  out(A);\n  out(B);\n\n  vi E, O;\n  forr(b, B) (b % 2 ? O : E).emplace_back(b);\n\n  int e = sz(E);\n  int o = sz(O);\n\n  BipartiteMatching bm(e + o);\n\n  rep(i, e) rep(j, o) {\n    int d = E[i] - O[j];\n    if (is_prime(d)) {\n      bm.add_edge(i, e + j);\n    }\n  }\n\n  int k = bm.matching();\n\n  int k2_e = (e - k) / 2;\n  int k2_o = (o - k) / 2;\n\n  int k3 = (e - k) % 2;\n\n  int ans = k + k2_e * 2 + k2_o * 2 + k3 * 3;\n\n  cout << ans << endl;\n}\n\nsigned main() {\n  cin.tie(nullptr);\n  ios::sync_with_stdio(false);\n  Main();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\ntypedef long long ll;\nint odd=0,even=0,Odd[105],Even[105],ma[105];\nint flag[10000010],x[10000010],map[105][105],vis[105];\nint prime[10000010],a[105];\nint dfs(int u)\n{\n\tfor (int v=1;v<=even;v++)\n\t{\n\t\tif (!map[u][v]) continue;\n\t\tif (!vis[v])\n\t\t{\n\t\t\tvis[v]=1;\n\t\t\tif (ma[v]==-1||dfs(ma[v]))\n\t\t\t{\n\t\t\t\tma[v]=u;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nint main()\n{\n\tint n,cnt=0;\n\tscanf(\"%d\",&n);\n\tflag[1]=1;\n\tfor (int i=2;i<=10000001;i++)\n\t{\n\t\tif (!flag[i]) prime[++cnt]=i;\n\t\tfor (int j=1;j<=cnt;j++)\n\t\t{\n\t\t\tif (i*prime[j]>10000001) break;\n\t\t\tflag[i*prime[j]]=1;\n\t\t\tif (i%prime[j]==0) break;\n\t\t}\n\t}\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%d\",&a[i]);\n\t\tx[a[i]]^=1;\n\t}\n\tfor (int i=1;i<=10000001;i++)\n\t\tif (x[i]!=x[i-1])\n\t\t{\n\t\t\tif (i&1) Odd[++odd]=i;\n\t\t\telse Even[++even]=i; \n\t\t}\n\tfor (int i=1;i<=odd;i++)\n\t\tfor (int j=1;j<=even;j++)\n\t\t\tif (!flag[abs(Odd[i]-Even[j])]) map[i][j]=1;\n\tfor (int i=1;i<=even;i++)\n\t\tma[i]=-1;\n\tint sum=0;\n\tfor (int i=1;i<=odd;i++)\n\t{\n\t\tmemset(vis,0,sizeof(vis));\n\t\tif (dfs(i)) sum++;\n\t}\n\tint ans=sum+(((odd-sum)>>1)<<1)+(((even-sum)>>1)<<1)+(odd-sum)%2*3;\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define inf (1e9 + 7)\n#define mem(a, b) memset(a, b, sizeof(a))\nusing namespace std;\n\nint n, num[105], num2[205], nn = 0, ji = 0, ou = 0, lk[205], ans = 0;\nbool vis[205];\nvector<int> eg[205];\n\nbool dfs(int u)\n{\n    int lim = eg[u].size();\n    for(int i = 0;i < lim;i++)\n    {\n        int v = eg[u][i];\n        if(!vis[v])\n        {\n            vis[v] = 1;\n            if(lk[v] == -1||dfs(lk[v]))\n            {\n                lk[v] = u;\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\nbool jg(int a)\n{\n    if(a <= 2)\n        return false;\n    for(int i = 2;i * i <= a;i++)\n    {\n        if(a % i == 0)\n            return false;\n    }\n    return true;\n}\n\nint main()\n{\n    mem(lk, -1);\n    scanf(\"%d\", &n);\n    for(int i = 1;i <= n;i++)\n        scanf(\"%d\", &num[i]);\n    sort(num + 1, num + 1 + n);\n    num2[++nn] = num[1];\n    for(int i = 2;i <= n;i++)\n    {\n        if(num[i] - 1 != num[i - 1])\n        {\n            num2[++nn] = num[i - 1] + 1;\n            num2[++nn] = num[i];\n        }\n    }\n    num2[++nn] = num[n] + 1;\n    for(int i = 1;i <= nn;i++)\n    {\n        if(num2[i] % 2 == 0)\n        {\n            ou++;\n            for(int j = i + 1;j <= nn;j++)\n            {\n                if(jg(num2[j] - num2[i]))\n                    eg[j].push_back(i);\n            }\n        }\n        else\n        {\n            ji++;\n            for(int j = i + 1;j <= nn;j++)\n            {\n                if(jg(num2[j] - num2[i]))\n                    eg[i].push_back(j);\n            }\n        }\n    }\n    int res = 0;\n    for(int i = 1;i <= nn;i++)\n    {\n        if(num2[i] % 2 == 0)\n            continue;\n        mem(vis, 0);\n        if(dfs(i))\n            res++;\n    }\n    ans += res;\n    ji -= res;\n    ou -= res;\n    ans += ji / 2 * 2;\n    ji %= 2;\n    ans += ou / 2 * 2;\n    ou %= 2;\n    if(ji||ou)\n        ans += 3;\n    printf(\"%d\\n\", ans);\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define L long long\n#define pb push_back\n#define pi pair<int,int>\n#define pii pair<pair<int,int>,int>\n#define aa first\n#define bb second\n#define mp make_pair\n#define mpp(a,b,c) mp(mp(a,b),c)\nusing namespace std;\n#define SZ 666666\ntypedef long long ll;\nint fst[SZ],nxt[SZ],vb[SZ],cap[SZ],ff[SZ],M=1,N=0;\n#define add ad_dl\nvoid _ad_dl(int a,int b,int c) {++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;cap[M]=c;}\nvoid ad_dl(int a,int b,int c)\n{_ad_dl(a,b,c); _ad_dl(b,a,0);}\nint S,T,q[SZ],d[SZ];\nbool bfs()\n{\n    memset(d,-1,4*(N+1));\n    d[T]=0; q[1]=T; int h=1,t=2;\n    while(h!=t)\n    {\n        int cur=q[h++];\n        for(int e=fst[cur];e;e=nxt[e])\n        {\n            int b=vb[e];\n            if(d[b]==-1&&cap[e^1])\n            {\n                d[b]=d[cur]+1, q[t++]=b;\n                if(b==S) return 1; //???? \n            }\n        }\n    }\n    return d[S]!=-1;\n}\nint dfs(int x,int f)\n{\n    if(f<=0) return 0;\n    if(x==T) return f;\n    int ca=0;\n    for(int& e=fst[x];e;e=nxt[e]) //????? \n    {\n        int b=vb[e];\n        if(d[b]+1!=d[x]) continue;\n        int w=dfs(b,(cap[e]<f-ca)?cap[e]:(f-ca));\n        cap[e]-=w; cap[e^1]+=w; ca+=w;\n        if(ca==f) break;\n    }\n    if(!ca) d[x]=-1; //????? \n    return ca;\n}\n#define inf 2e9+3\nint dinic()\n{\n    int ans=0;\n    memcpy(ff,fst,4*(N+1));\n    while(bfs())\n    {\n        //?????\n        ans+=dfs(S,inf);\n        memcpy(fst,ff,4*(N+1));\n    }\n    return ans;\n}\nint n,m,x[110],f[210],p;\nbool a[10000010];\nint main()\n{\n\t//freopen(\".in\",\"r\",stdin);\n\t//freopen(\".out\",\"w\",stdout);\n\tint i,j,k;\n\tscanf(\"%d\",&n);\n\tfor(i=1;i<=n;i++)\n\t  scanf(\"%d\",&x[i]);\n\tsort(x+1,x+n+1);\n\tfor(i=2;i<=n;i++)\n\t  if(x[i-1]+1!=x[i])\n\t    {\n\t\t f[++m]=x[i-1]+1;\n\t\t f[++m]=x[i];\n\t\t}\n\tf[++m]=x[1];\n\tf[++m]=x[n]+1;\n\ta[1]=1;\n\tfor(i=2;i<=10000000;i++)\n\t  if(!a[i])\n\t    for(j=i;j<=10000000;j+=i)\n\t      a[j]=1;\n\ta[2]=1;\n\tN=m+2;\n\tS=m+2;\n\tT=m+1;\n\tfor(i=1;i<=m;i++)\n\t  if(f[i]&1)\n\t    add(m+2,i,1);\n\t  else\n\t    add(i,m+1,1);\n\tfor(i=1;i<=m;i++)\n\t  for(j=1;j<=m;j++)\n\t    if(i!=j && f[i]&1 && !a[abs(f[i]-f[j])])\n\t      add(i,j,1);\n\tp=k=dinic();\n\tfor(i=1,j=-k;i<=m;i++)\n\t  if(f[i]&1)\n\t    j++;\n\tp+=j/2*2;\n\tif(j&1)\n\t  p+=3;\n\tfor(i=1,j=-k;i<=m;i++)\n\t  if(!(f[i]&1))\n\t    j++;\n\tp+=j/2*2;\n\tprintf(\"%d\\n\",p);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// Prime Flip\n// * frank_c1\n// * 2017 / 12 / 24\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int maxn = 205;\nconst int maxM = (int)(1e7) + 5;\nint pr[maxM], chk[maxM];\n\nvoid gen() {\n\tint mx = (int)(1e7) + 1, tot = 0;\n\tchk[1] = 1;\n\tfor (int i = 2; i <= mx; ++i) {\n\t\tif (!chk[i]) {\n\t\t\tpr[++tot] = i;\n\t\t}\n\t\tfor (int j = 1; j <= tot; ++j) {\n\t\t\tif (i * pr[j] > mx) break;\n\t\t\tchk[i * pr[j]] = 1;\n\t\t\tif (i % pr[j] == 0) break;\n\t\t}\n\t}\n}\n\nint a[maxn], b[maxn], vi[maxn], lk[maxn];\nint idx;\n\nint Find(int x) {\n\tfor (int i = 1; i <= idx; ++i) \n\t\tif (!vi[i] && !(b[i] & 1)) \n\t\t\tif (!chk[max(b[x], b[i]) - min(b[x], b[i])]) {\n\t\t\t\tif (!lk[i] || Find(lk[i])) {\n\t\t\t\t\tlk[i] = x; return 1;\n\t\t\t\t}\n\t\t\t}\n\treturn 0;\n}\n\nint main() {\n\tgen();\n\tint n;\n\tscanf(\"%d\", &n); a[0] = -1;\n\tfor (int i = 1; i <= n; ++i) scanf(\"%d\", &a[i]);\n\tfor (int i = 1; i <= n; ++i) {\n\t\tif (a[i] - 1 != a[i - 1]) b[++idx] = a[i];\n\t\tif (a[i] + 1 != a[i + 1]) b[++idx] = a[i] + 1;\n\t}\n\tint ret = 0, cnt = 0;\n\tfor (int i = 1; i <= idx; ++i) if (b[i] & 1) {\n\t\tmemset(vi, 0, sizeof(vi)); ret += Find(i); ++cnt;\n\t}\n\treturn printf(\"%d\\n\", ret + ((cnt - ret) / 2 + (idx - cnt - ret) / 2) * 2 + ((cnt - ret) % 2) * 3), 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<iostream>\n#include<queue>\n#include<cmath>\nusing namespace std;\nvoid read(int &x){\n\tchar ch;bool ok;\n\tfor(ok=0,ch=getchar();!isdigit(ch);ch=getchar())if(ch=='-')ok=1;\n\tfor(x=0;isdigit(ch);x=x*10+ch-'0',ch=getchar());if(ok)x=-x;\n}\n#define rg register\nconst int maxn=210;bool vis[maxn];\nint f[maxn],n,ans,a[maxn],mp[maxn][maxn],b[maxn],tot1,tot2,x[maxn];\nbool check(int x){\n\tif(!(x&1))return 0;\n\tint n=sqrt(x);\n\tfor(rg int i=2;i<=n;i++)\n\t\tif(!(x%i))return 0;\n\treturn 1;\n}\nbool dfs(int x){\n\tfor(rg int i=1;i<=tot2;i++)\n\t\tif(!vis[i]&&mp[x][i]){\n\t\t\tvis[i]=1;\n\t\t\tif(!f[i]||dfs(f[i]))return f[i]=x,1;\n\t\t}\n\treturn 0;\n}\nint main(){\n\tread(n);\n\tfor(rg int i=1;i<=n;i++)read(x[i]);\n\tfor(rg int i=1;i<=n;i++){\n\t\tif(x[i+1]-x[i]!=1||i==n){\n\t\t\tif((x[i]+1)%2==0)a[++tot1]=x[i]+1;\n\t\t\telse b[++tot2]=x[i]+1;\n\t\t}\n\t\tif(x[i]-x[i-1]!=1||i==1){\n\t\t\tif(x[i]&1)b[++tot2]=x[i];\n\t\t\telse a[++tot1]=x[i];\n\t\t}\n\t}\n\tfor(rg int i=1;i<=tot1;i++)printf(\"%d \",a[i]);\n\tprintf(\"\\n\");\n\tfor(rg int j=1;j<=tot2;j++)printf(\"%d \",b[j]);\n\tprintf(\"\\n\");\n\tfor(rg int i=1;i<=tot1;i++)\n\t\tfor(rg int j=1;j<=tot2;j++)\n\t\t\tif(check(abs(a[i]-b[j])))mp[i][j]=1;\n\tfor(rg int i=1;i<=tot1;i++){\n\t\tmemset(vis,0,sizeof vis);\n\t\tif(dfs(i))ans++;\n\t}\n\tprintf(\"%d\\n\",ans+(tot1-ans)/2*2+(tot2-ans)/2*2+(tot1-ans)%2*3);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int maxn=205;\nconst int maxm=10000005;\nconst int INF=0x3f3f3f;\n\nint n;\nint c[maxm];\nint p1[maxn],tot1=0,p2[maxn],tot2=0,nn;\n\nstruct Edge\n{\n    int from,to,capa,flow,nxt;\n}e[maxn*maxn];\n\nint h[maxn],tot=-1;\n\ninline void addedge(int a,int b,int c) { e[++tot].from=a; e[tot].to=b; e[tot].capa=c; e[tot].flow=0; e[tot].nxt=h[a]; h[a]=tot; }\n\nbool check(int p)\n{\n    if (p==1) return 0;\n    for (int i=2;i*i<=p;i++) if (p%i==0) return 0;\n    return 1;\n}\n\nint s,t,d[maxn],cur[maxn],vis[maxn];\n\nint dfs(int p,int a)\n{\n    if (p==t || !a) return a;\n    int flow=0,f;\n    for (int &i=cur[p];~i;i=e[i].nxt)\n    if (d[e[i].to]==d[p]+1 && e[i].capa>e[i].flow)\n    {\n        f=dfs(e[i].to,min(a,e[i].capa-e[i].flow));\n        if (f)\n        {\n            flow+=f; a-=f;\n            e[i].flow+=f; e[i^1].flow-=f;\n        }\n        if (!a) break;\n    }\n    return flow;\n}\n\nint bfs()\n{\n    queue<int> q;\n    memset(vis,0,sizeof(vis));\n    q.push(s); vis[s]=1; d[s]=0;\n    while (!q.empty())\n    {\n        int o=q.front(); q.pop();\n        for (int i=h[o];~i;i=e[i].nxt)\n        if (!vis[e[i].to] && e[i].capa>e[i].flow)\n        {\n            vis[e[i].to]=1; q.push(e[i].to);\n            d[e[i].to]=d[o]+1;\n        }\n    }\n    return vis[t];\n}\n\nint Dinic()\n{\n    int flow=0;\n    while (bfs())\n    {\n        //cout<<\"GG\";\n        for (int i=0;i<=nn;i++) cur[i]=h[i];\n        flow+=dfs(s,INF);\n    }\n    return flow;\n}\n\nint main()\n{\n    scanf(\"%d\",&n);\n    int tmp,mx=0;\n    for (int i=1;i<=n;i++) { scanf(\"%d\",&tmp); mx=max(mx,tmp); c[tmp]=1; } mx++;\n    //for (int i=mx;i>=1;i--) c[i]=c[i-1]^c[i];\n    //for (int i=1;i<=mx;i++) cout<<c[i];\n    for (int i=1;i<=mx;i++)\n    if (c[i]!=c[i-1])\n    {\n        if (i&1) p1[++tot1]=i;\n            else p2[++tot2]=i;\n    }\n    nn=tot1+tot2+1; s=0; t=nn;\n    //cout<<nn<<endl;\n    memset(h,-1,sizeof(h));\n    for (int i=1;i<=tot1;i++) { addedge(s,i,1); addedge(i,s,0); }\n    for (int i=1;i<=tot2;i++) { addedge(i+tot1,t,1); addedge(t,i+tot1,0); }\n    for (int i=1;i<=tot1;i++)\n        for (int j=1;j<=tot2;j++)\n            if (check(abs(p2[j]-p1[i]))) { addedge(i,i+tot1,1); addedge(i+tot1,i,0); }\n    int flow=Dinic(),ans=0;\n    //cout<<\"GG\";\n    ans=flow;\n    ans+=(tot1-flow)/2*2+(tot2-flow)/2*2;\n    ans+=((tot1-flow)&1)*3;\n    cout<<ans;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int Nmax = 205, lim = 1e7 + 5;\n\nint n, a[Nmax];\nbitset<lim+3> prim;\n\n\nint modul(int x) { return (x>0?x:-x); }\n\nclass Graph\n{\n    vector<int> edge[Nmax];\n    bool marked[Nmax];\n    int L[Nmax], R[Nmax];\n\n    bool cupleaza(int node)\n    {\n        if(marked[node]) return 0;\n        marked[node] = 1;\n\n        for(auto it : edge[node])\n            if(R[it] == -1)\n            {\n                L[node] = it;\n                R[it] = node;\n                return 1;\n            }\n\n        for(auto it : edge[node])\n            if(cupleaza(R[it]))\n            {\n                L[node] = it;\n                R[it] = node;\n                return 1;\n            }\n        return 0;\n    }\n\npublic:\n    void add_edge(int x, int y)\n    {\n        edge[x].push_back(y);\n    }\n\n    int cuplaj(int n, int m)\n    {\n        int done = 1, i;\n        for(i=0; i<n; ++i) L[i] = -1;\n        for(i=0; i<m; ++i) R[i] = -1;\n\n        while(done)\n        {\n            done = 0;\n            memset(marked, 0, sizeof(marked));\n\n            for(i=0; i<n; ++i)\n                if(L[i] == -1) done |= cupleaza(i);\n        }\n\n        int cnt = 0;\n        for(i=0; i<n; ++i) cnt += (L[i] != -1);\n        return cnt;\n    }\n\n} graph;\n\nvoid prec()\n{\n    int i, j;\n\n    prim.set();\n    for(i=2; i*i <= lim; ++i)\n        if(prim[i])\n            for(j=i*i; j<=lim; j+=i)\n                prim[j] = 0;\n}\n\nint main()\n{\n  //  freopen(\"input\", \"r\", stdin);\n    cin.sync_with_stdio(false);\n\n    prec();\n\n    int i, j;\n    vector<int> p, impar, par;\n\n    cin >> n;\n    for(i=1; i<=n; ++i) cin >> a[i];\n\n    for(i=1; i<=n; ++i)\n    {\n        j = i;\n        while(a[j] - a[i] == j - i) ++j;\n\n        p.push_back(a[i]);\n        p.push_back(a[j-1] + 1);\n\n        i = j - 1;\n    }\n\n    for(auto it : p)\n        if(it & 1) impar.push_back(it);\n            else par.push_back(it);\n\n    for(i=0; i<impar.size(); ++i)\n        for(j=0; j<par.size(); ++j)\n            if(prim[modul(impar[i] - par[j])]) graph.add_edge(i, j);\n\n    int best = graph.cuplaj(impar.size(), par.size()), A, B;\n\n    A = impar.size() - best;\n    B = par.size() - best;\n\n    cout << best + 2 * (A/2 + B/2) + 3 * (A&1) << '\\n';\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std; \n\nconst int maxn = 1e7; \n\nint n, x[105], a[205], G[205][205]; \nint p[maxn + 5], flag[maxn + 5], tot, cnt, mat[205], vis[205];  \n\nint dfs(int u) {\n    for (int v = 1; v <= cnt; v++) {\n        if (!(x[v] & 1) && !vis[v] && G[u][v]) {\n            vis[v] = 1; \n            if (!mat[v] or dfs(mat[v])) {\n                mat[v] = u; \n                return 1; \n            }\n        }\n    }\n    return 0; \n}\n\nint main() {\n    scanf(\"%d\", &n); \n    for (int i = 1; i <= n; i++) {\n        scanf(\"%d\", &x[i]); \n    }\n    flag[1] = 1; \n    for (int i = 2; i <= maxn; i++) {\n        if (!flag[i]) {\n            p[++tot] = i; \n        }\n        for (int j = 1; j <= tot && i * p[j] <= maxn; j++) {\n            flag[i * p[j]] = 1; \n            if (i % p[j] == 0) break ; \n        }\n    }\n    flag[2] = 1;\n    x[0] = -1e9; \n    for (int i = 1; i <= n; i++) {\n        if (x[i - 1] != x[i] - 1) {\n            a[++cnt] = x[i]; \n        }\n        if (x[i + 1] != x[i] + 1) {\n            a[++cnt] = x[i] + 1; \n        }\n    }\n    for (int i = 1; i <= cnt; i++) {\n        for (int j = i + 1; j <= cnt; j++) {\n            if (!flag[abs(a[j] - a[i])]) {\n                G[i][j] = G[j][i] = 1; \n            }\n        }\n    }\n    int mx = 0, odd = 0, even; \n    for (int i = 1; i <= cnt; i++) {\n        if (a[i] & 1) {\n            memset(vis, 0, sizeof(vis)); \n            if (dfs(i)) mx++; \n            odd++; \n        }\n    }\n    even = cnt - odd; \n    odd -= mx, even -= mx; \n    int ans = mx; \n    if (odd & 1) {\n        ans += odd - 1 + even - 1 + 3; \n    }\n    else {\n        ans += odd + even; \n    }\n    cout << ans << '\\n'; \n    return 0; \n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\n#define X first\n#define Y second\n#define pb emplace_back\n#define FOR(i,a,b) for(int (i)=(a);i<(b);++(i))\n#define EFOR(i,a,b) for(int (i)=(a);i<=(b);++(i))\n#define rep(X,Y) for (int (X) = 0;(X) < (Y);++(X))\n#define REP rep\n#define rrep(X,Y) for (int (X) = (Y)-1;(X) >=0;--(X))\n#define all(X) (X).begin(),(X).end()\n#define eb emplace_back\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef ll LL;\ntypedef pii PII;\ntypedef pll PLL;\nconst ll MOD=1e9+7;\n\n#define rall(X) (X).rbegin(),(X).rend()\n#define UNIQUE(X) (X).erase(unique(all(X)),(X).end())\n#define reps(X,S,Y) for (int (X) = S;(X) < (Y);++(X))\n#define rreps(X,S,Y) for (int (X) = (Y)-1;(X) >= (S);--(X))\ntemplate<class T> inline bool MX(T &l,const T &r){return l<r?l=r,1:0;}\ntemplate<class T> inline bool MN(T &l,const T &r){return l>r?l=r,1:0;}\n\nint N;\nbool is_composite[11451419];\nmap<int, char> mp;\n\nint GetCost(int d) {\n  if (d == 2) return 2;\n  if (!is_composite[d]) return 1;\n  if (d%2 == 0) return 2;\n  return 3;\n}\n\nsigned main(){\n  is_composite[1] = true;\n  reps(i, 2, 11451419) {\n    if (is_composite[i]) continue;\n    for (int j=i+i; j<11451419; j+=i) {\n      is_composite[j] = true;\n    }\n  }\n\n  ios_base::sync_with_stdio(false);\n  cout<<fixed<<setprecision(0);\n\n  cin >> N;\n\n  rep(i, N) {\n    int x;\n    cin >> x;\n    mp[x] ^= 1;\n    mp[x+1] ^= 1;\n  }\n\n  vector<int> vs;\n  for (auto &p : mp) {\n    if (p.Y == 0) continue;\n    vs.eb(p.X);\n  }\n  int m = vs.size();\n  assert(m%2 == 0);\n  m /= 2;\n  vector<pii> ps;\n  rep(i, m) {\n    ps.eb(pii(vs[i*2], vs[i*2+1]));\n  }\n\n  while (1) {\n    bool found = false;\n    rep(i, m) {\n      int a, b;\n      tie(a, b) = ps[i];\n      reps(j, i+1, m) {\n        int c, d;\n        tie(c, d) = ps[j];\n\n        rep(k, 2) {\n          int pr = GetCost(abs(a-b)) + GetCost(abs(c-d));\n          int af = GetCost(abs(a-c)) + GetCost(abs(b-d));\n          if (pr > af) {\n            found = true;\n            ps[i] = pii(a, c);\n            ps[j] = pii(b, d);\n            goto L_END;\n          }\n\n          swap(c, d);\n        }\n      }\nL_END:\n      continue;\n    }\n\n    if (!found) break;\n  }\n\n  int ans = 0;\n  rep(i, m) {\n    ans += GetCost(abs(ps[i].X-ps[i].Y));\n  }\n  cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \nconst int maxn = 1e7 + 700;\n \n \nint n,fre[maxn],p[220],ispr[maxn],even,odd,wrong;\nvector <int> edge[220],v2;\n \nbool fin(int u) {\n    if (fre[u]==wrong) return false;\n    fre[u]=wrong;\n    for (int j=0;j<edge[u].size();j++) {\n        int v=edge[u][j];\n       // cout<<u<<\" \"<<v<<endl;\n        if (p[v]==0 || fin(p[v])) {\n            p[v]=u;\n            p[u]=v;\n            return true;\n        }\n    }\n    return false;\n}\n \nint main() {\n  //  freopen(\"in.txt\",\"r\",stdin);\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    ispr[1]=1;\n    for (int i=2;i<maxn;i++)\n        if (ispr[i]==0) {\n            for (int j=i+i;j<maxn;j+=i) ispr[j]=1;\n        }\n    cin>>n;\n    for (int i=1;i<=n;i++) {\n        int x;\n        cin>>x;\n        fre[x]^=1;\n        fre[x+1]^=1;\n    }\n    even=0; odd=0; wrong=2;\n    for (int i=0;i<maxn;i++)\n        if (fre[i]==1) {\n            v2.push_back(i);\n            if (i%2==0) even++;\n            else odd++;\n        }\n    // for (int i=0;i<v2.size();i++) cout<<v2[i]<<\" \";\n   //  cout<<endl;\n   // cout<<\" \" <<even<<\" \"<<odd<<endl;\n    for (int i=0;i<v2.size();i++)\n        for (int j=0;j<v2.size();j++)\n            if (v2[i]%2==0 && v2[j]%2==1 && ispr[ abs(v2[j] - v2[i]) ]==0 && abs(v2[j] - v2[i])%2==1) {\n                edge[i].push_back(j);\n                edge[j].push_back(i);\n            }\n    int cnt=0;\n    for (int i=0;i<v2.size();i++)\n     if (p[i]==0 && v2[i]%2==0) {\n        wrong++;\n        p[i]=i;\n        if (fin(i)) cnt++;\n    }\n    cout<< cnt + (even-cnt)/2 *2 + (odd-cnt)/2 * 2 + (even-cnt)%2*3;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ADD(a, b) a = (a + (ll)b) % mod\n#define MUL(a, b) a = (a * (ll)b) % mod\n#define MAX(a, b) a = max(a, b)\n#define MIN(a, b) a = min(a, b)\n#define rep(i, a, b) for(int i = (a); i < (b); i++)\n#define rer(i, a, b) for(int i = (a) - 1; i >= (b); i--)\n#define all(a) (a).begin(), (a).end()\n#define sz(v) (int)(v).size()\n#define pb push_back\n#define sec second\n#define fst first\n#define debug(fmt, ...) Debug(__LINE__, \":\", fmt, ##__VA_ARGS__)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pi;\ntypedef pair<int, pi> ppi;\ntypedef vector<ll> vi;\ntypedef complex<double> comp;\nvoid Debug() {cout << '\\n'; }\ntemplate<class FIRST, class... REST>void Debug(FIRST arg, REST... rest) { \n\tcout << arg << \" \"; Debug(rest...); }\ntemplate<class T>ostream& operator<< (ostream& out, const vector<T>& v) {\n\tout << \"[\";if(!v.empty()){rep(i,0,sz(v)-1)out<<v[i]<< \", \";out<<v.back();}out << \"]\";return out;}\ntemplate<class S, class T>ostream& operator<< (ostream& out, const pair<S, T>& v) {\n\tout << \"(\" << v.first << \", \" << v.second << \")\";return out;}\nconst int MAX_N = 200010;\nconst double eps = 1e-6;\nconst ll mod = 1000000007;\nconst int inf = 1 << 30;\nconst ll linf = 1LL << 60;\nconst double PI = 3.14159265358979323846;\n///////////////////////////////////////////////////////////////////////////////////////////////////\n\nnamespace MF { //init before you use it. when you use double, be careful.\n\n\tstruct edge {int to, cap, rev; };\n\n\tvector<edge> G[MAX_N];\n\tbool used[MAX_N];\n\n\tvoid init(int n) {\n\t\trep(i, 0, n) G[i].clear();\n\t}\n\n\tint add_edge(int from, int to, int cap) {\n\t\tG[from].push_back((edge){to, cap, (int)G[to].size()});\n\t\tG[to].push_back((edge){from, 0, (int)G[from].size() - 1});\n\t\treturn (int)G[from].size() - 1;\n\t}\n\n\tint dfs(int v, int t, int f, bool change = true) { //if you just want to dfs, change = false\n\t\tif(v == t) return f;\n\t\tused[v] = true;\n\t\tfor(int i = 0; i < (int)G[v].size(); i++) {\n\t\t\tedge &e = G[v][i];\n\t\t\tif(!used[e.to] && e.cap > 0) {\n\t\t\t\tint d = dfs(e.to, t, min(f, e.cap), change);\n\t\t\t\tif(d > 0) {\n\t\t\t\t\tif(change) {\n\t\t\t\t\t\te.cap -= d;\n\t\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\t}\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\n\tll get(int s, int t) {\n\t\tll flow = 0;\n\t\twhile(true) {\n\t\t\tmemset(used, 0, sizeof(used));\n\t\t\tint f = dfs(s, t, inf);\n\t\t\tif(f == 0) return flow;\n\t\t\tflow += f;\n\t\t}\n\t}\n}\n\nint N, M;\nint E, O;\nint A[110], B[210];\nint C[210], D[210];\n\nbool prime(int v) {\n\tif(v <= 2) return false;\n\tfor(int i = 2; i * i <= v; i++) {\n\t\tif(v % i == 0) return false;\n\t}\n\treturn true;\n}\n\nvoid solve() {\n\tcin >> N;\n\tM = 0;\n\trep(i, 0, N) cin >> A[i];\n\trep(i, 0, N) {\n\t\tint t1 = (find(A, A + N, A[i] - 1) != A + N);\n\t\tint t2 = (find(A, A + N, A[i] + 1) != A + N);\n\t\tif(t1 == 0) B[M++] = A[i] - 1;\n\t\tif(t2 == 0) B[M++] = A[i];\n\t}\n\tM = unique(B, B + M) - B;\n\n\tint s = M, t = M + 1;\n\tMF::init(M + 2);\n\n\trep(i, 0, M) {\n\t\tif(B[i] % 2 == 0) C[E++] = B[i];\n\t\telse D[O++] = B[i];\n\t}\n\trep(i, 0, E) {\n\t\trep(j, 0, O) {\n\t\t\tif(prime(abs(i - j))) {\n\t\t\t\tMF::add_edge(i, j + E, 1);\n\t\t\t}\n\t\t}\n\t}\n\trep(i, 0, E) MF::add_edge(s, i, 1);\n\trep(i, 0, O) MF::add_edge(i + E, t, 1);\n\n\tint res = MF::get(s, t);\n\tif((E - res) % 2 == 0) {\n\t\tcout << res + (E - res) + (O - res) << \"\\n\";\n\t}\n\telse {\n\t\tcout << res + (E - res - 1) + (O - res - 1) + 3 << \"\\n\";\n\t}\n}\n\nint main() {\n#ifndef LOCAL\n\tios::sync_with_stdio(false);\n    cin.tie(0);\n#endif\n    cout << fixed;\n\tcout.precision(5);\n#ifdef LOCAL\n    freopen(\"in.txt\", \"rt\", stdin);\n#endif\t\n\tsolve();\n#ifdef LOCAL\n    cerr << \"Time elapsed: \" << 1.0 * clock() / CLOCKS_PER_SEC << \" s.\\n\";\n#endif\n\treturn 0;\n}\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int maxm=1e7+10,maxn=210;\nint n,a[maxn],b[maxn],m,ans;\nint b1[maxn],b2[maxn],p1,p2;\nbool np[maxm],vis[maxn],g[maxn][maxn],s[maxm];\nint match[maxn];\nvector<int> p;\n\nvoid init(){\n\tnp[0]=np[1]=1;\n\tfor(int i=2;i<maxm;++i){\n\t\tif(!np[i]){\n\t\t\tp.push_back(i);\n\t\t\t//cerr<<i<<endl;\n\t\t\t//system(\"pause\");\n\t\t}\n\t\tfor(int j=0,j_end=p.size(),x;j<j_end&&(x=p[j]*i)<maxm;++j){\n\t\t\tnp[x]=true;\n\t\t\tif(i%p[j]==0)break;\n\t\t}\n\t}\n}\n\nbool dfs(int u){\n\tif(vis[u])return false;\n\tvis[u]=1;\n\tfor(int i=1;i<=p2;++i)if(g[u][i]){\n\t\tif(!match[i]||dfs(match[i])){\n\t\t\tmatch[i]=u;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\nvoid solve(){\n\tinit();\n\tcin>>n;\n\tfor(int i=1;i<=n;++i){cin>>a[i];s[a[i]]=1;}\n\tfor(int i=1;i<maxm;++i){\n\t\tif(s[i]!=s[i-1])b[++m]=i;\n\t}\n\tfor(int i=1;i<=m;++i){\n\t\tif(b[i]&1)b1[++p1]=b[i];\n\t\telse b2[++p2]=b[i];\n\t}\n\t//cerr<<p1<<\" \"<<p2<<endl;\n\tfor(int i=1;i<=p1;++i){\n\t\tfor(int j=1;j<=p2;++j){\n\t\t\tif(!np[abs(b1[i]-b2[j])]){\n\t\t\t\tg[i][j]=true;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor(int i=1;i<=p1;++i){\n\t\tif(!match[i]){\n\t\t\tmemset(vis,0,sizeof vis);\n\t\t\tif(dfs(i))++ans;//match()\n\t\t}\n\t}\n\tp1-=ans;p2-=ans;\n\t//cerr<<ans<<endl;\n\tans+=p1/2*2+p2/2*2;\n\tans+=p1%2*3;\n\tcout<<ans<<endl;\n}\nint main(){\n\tsolve();\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint n, lim = 10000001, pm[2000007], l[107], r[107], cntl, cntr, cnt;\nint h[207], cur[207], num[207], to[200007], w[200007], nxt[200007], tot, s, t, ans, res;\nbool is[10000007],ck[10000007];\nqueue<int>q;\nint read()\n{\n\tint num = 0;\n\tchar c = getchar();\n\twhile (c < '0' || c>'9')c = getchar();\n\twhile (c >= '0' && c <= '9')num = num * 10 + c - '0', c = getchar();\n\treturn num;\n}\nint add(int a, int b, int c)\n{\n\tto[tot] = b;\n\tw[tot] = c;\n\tnxt[tot] = h[a];\n\th[a] = tot;\n\ttot++;\n\tto[tot] = a;\n\tnxt[tot] = h[b];\n\th[b] = tot;\n\ttot++;\n\treturn 0;\n}\nint bfs()\n{\n\tmemcpy(cur, h, sizeof cur);\n\tmemset(num, 0, sizeof num);\n\tq.push(s);\n\tnum[s] = 1;\n\twhile (!q.empty())\n\t{\n\t\tint x = q.front();\n\t\tq.pop();\n\t\tfor (int i = h[x]; i != -1; i = nxt[i])\n\t\t\tif (w[i] && !num[to[i]])\n\t\t\t{\n\t\t\t\tnum[to[i]] = num[x] + 1;\n\t\t\t\tq.push(to[i]);\n\t\t\t}\n\t}\n\treturn num[t];\n}\nint dfs(int x, int l)\n{\n\tif (x == t)return l;\n\tint used = 0;\n\tfor (int& i = cur[x]; i != -1; i = nxt[i])\n\t\tif (w[i] && num[to[i]] == num[x] + 1)\n\t\t{\n\t\t\tint d = dfs(to[i], min(w[i], l - used));\n\t\t\tif (d)\n\t\t\t{\n\t\t\t\tw[i] -= d;\n\t\t\t\tw[i ^ 1] += d;\n\t\t\t\tused += d;\n\t\t\t\tif (l == used)break;\n\t\t\t}\n\t\t}\n\treturn used;\n}\nint main()\n{\n\tfor (int i = 2; i <= lim; i++)\n\t{\n\t\tif (!ck[i])pm[++cnt] = i;\n\t\tfor (int j = 1; j <= cnt && i * pm[j] <= lim; j++)\n\t\t{\n\t\t\tck[i * pm[j]] = 1;\n\t\t\tif (i % pm[j] == 0)break;\n\t\t}\n\t}\n\tck[0] = ck[1] = ck[2] = 1;\n\tn = read();\n\tfor (int i = 1; i <= n; i++)\n\t\tis[read()] = 1;\n\tfor (int i = 1; i <= lim; i++)\n\t\tif (is[i] != is[i - 1])\n\t\t\tif (i & 1)l[++cntl] = i;\n\t\t\telse r[++cntr] = i;\n\tt = cntl + cntr + 1;\n\tmemset(h, -1, sizeof h);\n\tfor (int i = 1; i <= cntl; i++)\n\t\tadd(s, i, 1);\n\tfor (int i = 1; i <= cntr; i++)\n\t\tadd(cntl + i, t, 1);\n\tfor (int i = 1; i <= cntl; i++)\n\t\tfor (int j = 1; j <= cntr; j++)\n\t\t\tif (!ck[abs(l[i] - r[j])])\n\t\t\t\tadd(i, cntl + j, 1);\n\twhile(bfs())\n\t\tans += dfs(s, 1e9);\n\tres = ans;\n\tres += (cntl - ans) / 2 * 2 + (cntr - ans) / 2 * 2;\n\tres += ((cntl - ans) & 1) * 3;\n\tcout << res << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <time.h>\n#include <random>\n#include <fstream>\n#include <set>\n\nusing namespace std;\n\nconst int N = 1e7 + 2;\n\nint n;\n\nint c[N];\nint p[N];\nint a[200];\n\nvector<int> graph[400];\n\nint paired[400];\nint marked[400];\n\nint TryKuhn(int v)\n{\n    if (marked[v]) return 0;\n    marked[v] = 1;\n    for (auto u : graph[v])\n    {\n        if (paired[u] == -1 || TryKuhn(paired[u]))\n        {\n            paired[u] = v;\n            return 1;\n        }\n    }\n    return 0;\n}\n\nint G()\n{\n    int res = 0;\n    fill(paired, paired + 400, -1);\n    for (int i = 0; i < n; i++)\n    {\n        fill(marked, marked + 400, 0);\n        if (TryKuhn(i))\n            res++;\n    }\n    return res;\n}\n\nsigned main()\n{\n    #ifdef LOCAL\n\n    #else\n        freopen(\"partition.in\", \"r\", stdin);\n        freopen(\"partition.out\", \"w\", stdout);\n    #endif // LOCAL\n    srand(time(NULL));\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    for (int i = 2; i < N; i++)\n    {\n        if (p[i] == 0)\n        {\n            for (int j = 2; j * i < N; j++) p[i * j] = 1;\n        }\n    }\n    p[2] = 1;\n    p[1] = 1;\n    cin >> n;\n    for (int i = 0; i < n; i++)\n    {\n        int x;\n        cin >> x;\n        c[x] = 1;\n    }\n    n = 0;\n    for (int i = 0; i + 1 < N; i++)\n    {\n        if (c[i] != c[i + 1])\n        {\n            a[n] = i;\n            n++;\n        }\n    }\n    for (int i = 0; i < n; i++)\n    {\n        for (int j = 0; j < n; j++)\n        {\n            if (a[i] % 2 == 0 && a[j] % 2 == 1)\n            {\n                if (!p[abs(a[i] - a[j])])\n                {\n                    graph[i].push_back(200 + j);\n                    graph[200 + j].push_back(i);\n                }\n            }\n        }\n    }\n    for (int i = 0; i < 400; i++)\n    {\n        for (auto u : graph[i])\n        {\n            cout << i << \" \" << u << endl;\n        }\n    }\n    int c0 = 0, c1 = 0, c2 = G();\n    for (int i = 0; i < n; i++)\n    {\n        if (a[i] % 2 == 0) c0++;\n        else c1++;\n    }\n    int ans = c2 + ((c0 - c2) / 2) * 2 + ((c1 - c2) / 2) * 2 + (c1 % 2) * 3;\n    cout << ans;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <cmath>\n#include <set>\n#define lowbit(x) (x&(-x))\n#define MAX(a,b) (a<b?b:a)\n#define MIN(a,b) (a<b?a:b)\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\nconst int N = 1e7;\nconst int maxn = 3e5 + 5;\nll mod = 1e9 + 7;\n\nint n, vis[N + 5];\nvector<int> odd, even, g[205];\n\nint check(int n)\n{\n\tif (n <= 2) return 0;\n\tint m = sqrt(n);\n\tfor (int i = 2; i <= m; i++) if (n%i == 0) return 0;\n\treturn 1;\n}\n\nint link[205], used[205];\nint dfs(int u)\n{\n\tfor (int j = 0; j < g[u].size(); j++)\n\t{\n\t\tint v = g[u][j];\n\t\tif (!used[v])\n\t\t{\n\t\t\tused[v] = 1;\n\t\t\tif (link[v] == -1 || dfs(link[v]))\n\t\t\t{\n\t\t\t\tlink[v] = u;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tint x;\n\t\tscanf(\"%d\", &x);\n\t\tvis[x] = 1;\n\t}\n\tfor (int i = 1; i <= N + 1; i++)\n\t{\n\t\tif (vis[i] != vis[i - 1])\n\t\t{\n\t\t\tif (i & 1) odd.push_back(i);\n\t\t\telse even.push_back(i);\n\t\t}\n\t}\n\n\tfor (int i = 0; i < odd.size(); i++)\n\t{\n\t\tfor (int j = 0; j < even.size(); ++j)\n\t\t{\n\t\t\tif (check(abs(odd[i] - even[j])))  g[i].push_back(j);\n\t\t}\n\t}\n\n\tmemset(link, -1, sizeof(link));\n\tint k = 0;\n\tfor (int i = 0; i < odd.size(); i++)\n\t{\n\t\tmemset(used, 0, sizeof(used));\n\t\tk += dfs(i);\n\t}\n\n\tprintf(\"%d\", k + ((int)(odd.size() - k) / 2 + (int)(even.size() - k) / 2) * 2 + (int)(odd.size() % 2) * 3);\n}"
  },
  {
    "language": "C++",
    "code": "#define C\ntypedef long long readtype;\n\n/* Header {{{ */\n#ifdef C\n#include <stdio.h>\n#include <math.h>\n#include <string.h>\n#define isdigit(a) ((a) >= '0' && (a) <= '9' ? true : false)\ntemplate<typename type> type abs(type a) { return a < 0 ? -a : a; }\ntemplate<typename type> type min(type a, type b) { return a < b ? a : b; }\ntemplate<typename type> type beMin(type &a, type b) { return a = (a < b ? a : b); }\ntemplate<typename type> type max(type a, type b) { return a > b ? a : b; }\ntemplate<typename type> type beMax(type &a, type b) { return a = (a > b ? a : b); }\ntemplate<typename type> void swap(type &a, type &b) { type c; c = a; a = b; b = c; }\n#endif\n\n#ifdef Cpp\n#include <bits/stdc++.h>\nusing namespace std;\n#endif\n\ntypedef long long var;\n\nreadtype read() {\n  readtype a = 0, c = getchar(), s = 0;\n  while (!isdigit(c)) s |= c == '-', c = getchar();\n  while (isdigit(c)) a = a * 10 + c - 48, c = getchar();\n  return s ? -a : a;\n}\n/* }}} */\n\nconst int N = 11004;\nconst int M = 1100006;\nconst int X = 1e7;\nconst int INF = 0x3f3f3f3f;\n\nint n, m, x[N];\nbool mark[X + 10];\nint cnt, prime[X];\nbool notprime[X + 10];\nint top = 1, fi[N], ne[M], to[M], fl[M];\nint S, T;\nint head, tail, q[N], deep[N];\nint cur[N];\n\nvoid add(int u, int v, int w);\nint Dinic();\nbool BFS();\nint DFS(int t, int f);\n\nint main() {\n  /*\n#ifndef ONLINE_JUDGE\n  freopen(\"arc080d.in\", \"r\", stdin);\n  freopen(\"arc080d.out\", \"w\", stdout);\n#endif\n*/\n  notprime[1] = true;\n  for (int i = 2; i <= X; ++i) {\n    if (!notprime[i]) prime[++cnt] = i;\n    for (int j = 1; j <= cnt; ++j) {\n      if (prime[j] * i > X) break;\n      notprime[prime[j] * i] = true;\n      if (!(i % prime[j])) break;\n    }\n  }\n  for (int i = read(); i >= 1; --i) mark[read()] = true;\n  for (int i = 1; i <= X + 1; ++i) {\n    if (mark[i] ^ mark[i - 1]) x[++n] = i;\n  }\n  S = n + 1, T = n + 2;\n  int oddNum = 0, evenNum = 0;\n  for (int i = 1; i <= n; ++i) {\n    if (!(x[i] % 2)) add(i, T, 1), evenNum++;\n    else add(S, i, 1), oddNum++;\n  }\n  for (int i = 1; i <= n; ++i) {\n    if (!(x[i] % 2)) continue;\n    for (int j = 1; j <= n; ++j) {\n      if (x[j] % 2 || notprime[abs(x[i] - x[j])]) continue;\n      add(i, j, 1);\n      // printf(\"%d %d %d\\n\", x[i], x[j], x[i] - x[j]);\n    }\n  }\n\n  /*\n  for (int i = 1; i <= n; ++i) printf(\"%d \", x[i]);\n  puts(\"\");\n  */\n\n  int k = Dinic();\n  int res = k + ((evenNum - k) / 2 + (oddNum - k) / 2) * 2 + ((evenNum - k) % 2) * 3;\n  printf(\"%d\\n\", res);\n  return 0;\n}\n\nvoid add(int u, int v, int w) {\n  ne[++top] = fi[u], fi[u] = top, to[top] = v, fl[top] = w;\n  ne[++top] = fi[v], fi[v] = top, to[top] = u, fl[top] = 0;\n  // printf(\"%d %d %d\\n\", u, v, w);\n}\n\nint Dinic() {\n  int res = 0;\n  while (BFS()) {\n    for (int i = 1; i <= T; ++i) cur[i] = fi[i];\n    res += DFS(S, INF);\n  }\n  return res;\n}\n\nbool BFS() {\n  memset(deep, 0, sizeof(deep));\n  q[head = tail = 1] = S;\n  deep[S] = 1;\n  while (head <= tail) {\n    int f = q[head++];\n    for (int i = fi[f]; i; i = ne[i]) {\n      if (deep[to[i]] || !fl[i]) continue;\n      deep[to[i]] = deep[f] + 1;\n      q[++tail] = to[i];\n    }\n  }\n  return deep[T];\n}\n\nint DFS(int t, int f) {\n  if (t == T) return f;\n  int sumflow = 0;\n  for (int &i = cur[t]; i; i = ne[i]) {\n    if (deep[to[i]] != deep[t] + 1 || !fl[i]) continue;\n    int tflow = DFS(to[i], min(fl[i], f - sumflow));\n    sumflow += tflow;\n    fl[i] -= tflow, fl[i ^ 1] += tflow;\n  }\n  return sumflow;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\nusing namespace std;\nstruct edge{\n\tint k,next;\n}e[2005];\nint n,a[105],x[1005],m,home[1005],cnt=-1,flag[1005],y[1005];\nbool vis[10000005];\nvoid add(int x,int y){\n\tcnt++;\n\te[cnt].k=y;\n\te[cnt].next=home[x];\n\thome[x]=cnt;\n}\nint prime[10000005],cc=-1;\nbool isprime[10000005];\nvoid init(){\n\tisprime[1]=1;\n\tfor(int i=2;i<=10000002;i++){\n\t\tif(!isprime[i]){\n\t\t\tprime[++cc]=i;\n\t\t}\n\t\tfor(int p=1;p<=cc&&prime[p]*i<=10000002;p++){\n\t\t\tisprime[prime[p]*i]=1;\n\t\t\tif(i%prime[p]==0) break;\n\t\t}\n\t}\n}\nint Abs(int a){return a<0?-a:a;}\nbool used[2005];\nbool dfs(int k){\n\tfor(int i=home[k];~i;i=e[i].next) if(!used[e[i].k]){\n\t\tused[e[i].k]=1;\n\t\tif(!flag[e[i].k]||dfs(flag[e[i].k])){\n\t\t\tflag[e[i].k]=k;\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\nint main(){\n\tinit();\n\tmemset(home,-1,sizeof(home));\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++) scanf(\"%d\",&a[i]),vis[a[i]]=1;\n\tint o=a[n]+1;n=0;\n\tfor(int i=1;i<=o;i++) if(vis[i]!=vis[i-1]){\n\t\tif(i&1) x[++n]=i;\n\t\telse y[++m]=i;\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int p=1;p<=m;p++) if(!isprime[Abs(x[i]-y[p])]) add(i,p);\n\t}\n\tint ans=0;\n\tfor(int i=1;i<=n;i++){\n\t\tmemset(used,0,sizeof(used));\n\t\tif(dfs(i)) ans++;\n\t}\n\tans+=(n-ans)/2*2+(m-ans)/2*2;\n\tn=(n-ans)%2;m=(m-ans)%2;\n\tif(n&&m) ans+=3;\n\tprintf(\"%d\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<algorithm>\n#include<queue>\n#include<cmath>\n#include<climits>\nusing namespace std;\ninline int read(){\n\tint f=1,ans=0;char c=getchar();\n\twhile(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}\n\twhile(c>='0'&&c<='9'){ans=ans*10+c-'0';c=getchar();}\n\treturn f*ans;\n}\nqueue<int> que;\nconst int MAXN=401;\nconst int MAXP=10000001;\nstruct node{\n\tint u,v,w,nex;\n}x[MAXN*MAXN<<1];\nint head[MAXN],cnt,dis[MAXN],vis[MAXN],S,T,INF=INT_MAX;\nvoid add(int u,int v,int w){\n\tx[cnt].u=u,x[cnt].v=v,x[cnt].w=w,x[cnt].nex=head[u],head[u]=cnt++;swap(u,v),w=0;\n\tx[cnt].u=u,x[cnt].v=v,x[cnt].w=w,x[cnt].nex=head[u],head[u]=cnt++;\n}\nbool bfs(){\n\tmemset(dis,127/3,sizeof(dis)),memset(vis,0,sizeof(vis));\n\tint inf=dis[0];dis[S]=0;\n\tque.push(S);\n\twhile(!que.empty()){\n\t\tint xx=que.front();que.pop();\n\t\tvis[xx]=0;\n\t\tfor(int i=head[xx];i!=-1;i=x[i].nex){\n\t\t\tif(x[i].w&&dis[x[i].v]>dis[xx]+1){\n\t\t\t\tdis[x[i].v]=dis[xx]+1;\n\t\t\t\tif(!vis[x[i].v]) vis[x[i].v]=1,que.push(x[i].v);\n\t\t\t}\n\t\t}\n\t}return dis[T]!=inf;\n}\nint dfs(int u,int flow){\n\tif(u==T) return flow;\n\tint used=0;\n\tfor(int i=head[u];i!=-1;i=x[i].nex){\n\t\tif(x[i].w&&dis[x[i].v]==dis[u]+1){\n\t\t\tint slow=dfs(x[i].v,min(flow-used,x[i].w));used+=slow;\n\t\t\tx[i].w-=slow,x[i^1].w+=slow;\n\t\t\tif(used==flow) break;\n\t\t}\n\t}if(!used) dis[u]=-1;\n\treturn used;\n}\nint dinic(){\n\tint Ans=0;\n\twhile(bfs()) Ans+=dfs(S,INF);\n\treturn Ans;\n}\nint n,g[MAXP],col[MAXP],Maxn,v[MAXP],prime[MAXP];\nvoid Get(){\n\tfor(int i=2;i<MAXP;i++){\n\t\tif(!v[i]){\n\t\t\tv[i]=i;\n\t\t\tprime[++prime[0]]=i;\n\t\t}\n\t\tfor(int j=1;prime[j]*i<MAXP&&j<=prime[0];j++){\n\t\t\tv[i*prime[j]]=prime[j];\n\t\t\tif(i%prime[j]==0) break;\n\t\t}\n\t}return;\n}\nint Ls[MAXP],Rs[MAXP],Ans;\nint main(){\n//\tfreopen(\"1.in\",\"r\",stdin);\n\tmemset(head,-1,sizeof(head));\n\tGet();\n\tn=read();\n\tfor(int i=1;i<=n;i++){\n\t\tint ps=read();\n\t\tMaxn=max(Maxn,ps+1);col[ps]=1;\n\t}\n\tMaxn++;\n\tfor(int i=1;i<=Maxn;i++){\n\t\tg[i]=col[i]^col[i-1];\n\t\tif(g[i]&1){\n\t\t\tif(i&1) Ls[++Ls[0]]=i;\n\t\t\telse Rs[++Rs[0]]=i;\n\t\t}\n\t}\n\tS=0,T=Ls[0]+Rs[0]+1;\n\tfor(int i=1;i<=Ls[0];i++) add(S,i,1);\n\tfor(int i=1;i<=Rs[0];i++) add(i+Ls[0],T,1);\n\tfor(int i=1;i<=Ls[0];i++)\n\t\tfor(int j=1;j<=Rs[0];j++){\n\t\t\tif(v[abs(Ls[i]-Rs[j])]==abs(Ls[i]-Rs[j])) add(i,Ls[0]+j,1);\n\t\t}\n\tint ans=dinic();\n\tAns+=ans;\n\tLs[0]-=ans,Rs[0]-=ans;\n\tAns+=((Ls[0]/2)*2)+((Rs[0]/2)*2);\n\tLs[0]&=1,Rs[0]&=1;\n\tif(Ls[0]+Rs[0]) Ans+=3;\n\tprintf(\"%d\\n\",Ans);return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//by yjz\n#include<bits/stdc++.h>\nusing namespace std;\n#define FF first\n#define SS second\n#define PB push_back\n#define MP make_pair\n#define bged(v) (v).begin(),(v).end()\n#define foreach(it,s) for(__typeof((s).begin()) it=(s).begin();it!=(s).end();it++)\n#define debug(...) (cerr<<\"'\"<<__FUNCTION__<<\"': \"),fprintf(stderr,__VA_ARGS__)\ntypedef long long ll;\nconst int Imx=2147483647;\nconst ll Lbig=2e18;\nconst int mod=1e9+7;\n//My i/o stream\nstruct fastio\n{\n\tchar s[100000];\n\tint it,len;\n\tfastio(){it=len=0;}\n\tinline char get()\n\t{\n\t\tif(it<len)return s[it++];it=0;\n\t\tlen=fread(s,1,100000,stdin);\n\t\tif(len==0)return EOF;else return s[it++];\n\t}\n\tbool notend()\n\t{\n\t\tchar c=get();\n\t\twhile(c==' '||c=='\\n')c=get();\n\t\tif(it>0)it--;\n\t\treturn c!=EOF;\n\t}\n}_buff;\n#define geti(x) x=getnum()\n#define getii(x,y) geti(x),geti(y)\n#define getiii(x,y,z) getii(x,y),geti(z)\n#define puti(x) putnum(x),putchar(' ')\n#define putii(x,y) puti(x),puti(y)\n#define putiii(x,y,z) putii(x,y),puti(z)\n#define putsi(x) putnum(x),putchar('\\n')\n#define putsii(x,y) puti(x),putsi(y)\n#define putsiii(x,y,z) putii(x,y),putsi(z)\ninline ll getnum()\n{\n\tll r=0;bool ng=0;char c;c=_buff.get();\n\twhile(c!='-'&&(c<'0'||c>'9'))c=_buff.get();\n\tif(c=='-')ng=1,c=_buff.get();\n\twhile(c>='0'&&c<='9')r=r*10+c-'0',c=_buff.get();\n\treturn ng?-r:r;\n}\ntemplate<class T> inline void putnum(T x)\n{\n\tif(x<0)putchar('-'),x=-x;\n\tregister short a[20]={},sz=0;\n\twhile(x)a[sz++]=x%10,x/=10;\n\tif(sz==0)putchar('0');\n\tfor(int i=sz-1;i>=0;i--)putchar('0'+a[i]);\n}\ninline char getreal(){char c=_buff.get();while(c==' '||c=='\\n')c=_buff.get();return c;}\nbool np[10001111];\nint n,a[111];\nint dp[111][111];\nint getcost(int x)\n{\n\tif(x%2==0)return 2;\n\telse if(np[x])return 3;\n\telse return 1;\n}\nint main()\n{\n\tnp[1]=1;\n\tfor(int i=2;i<=10000000;i++)\n\t{\n\t\tif(np[i])continue;\n\t\tfor(int j=i;j<=10000000;j+=i)np[j]=1;\n\t}\n\tgeti(n);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tgeti(a[i]);\n\t}\n\tfor(int i=n;i>=1;i--)\n\t{\n\t\tfor(int j=i;j<=n;j++)\n\t\t{\n\t\t\tif(i==j)dp[i][j]=getcost(1);\n\t\t\telse\n\t\t\t{\n\t\t\t\tdp[i][j]=Imx;\n\t\t\t\tint sum=0,cnt=1;\n\t\t\t\tfor(int k=i;k<j;k++)\n\t\t\t\t{\n\t\t\t\t\tdp[i][j]=min(dp[i][j],dp[i][k]+dp[k+1][j]);\n\t\t\t\t\tif(a[k+1]-a[k]-1>0)\n\t\t\t\t\t{\n\t\t\t\t\t\tsum+=getcost(a[k+1]-a[k]-1);\n\t\t\t\t\t\tcnt++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdp[i][j]=min(dp[i][j],min(cnt+2,sum+getcost(a[j]-a[i]+1)));\n\t\t\t}\n\t\t}\n\t}\n\tcout<<dp[1][n]<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <set>\n#include <map>\n#include <list>\n#include <time.h>\n#include <math.h>\n#include <random>\n#include <deque>\n#include <queue>\n#include <cassert>\n#include <unordered_map>\n#include <iomanip>\n\nusing namespace std;\n\ntypedef long long ll;\n\nmt19937 rnd(228);\n\nconst int M = 2e7 + 7;\nconst int N = 1e2 + 1;\n\nbool prime[M];\n\nll dp[N][N][2];\n\nint get(int x)\n{\n    if (x == 0)\n    {\n        return 0;\n    }\n    if (x > 2 && prime[x])\n    {\n        return 1;\n    }\n    else\n    {\n        return 2 + (x % 2);\n    }\n}\n\nint main()\n{\n#ifdef ONPC\n    freopen(\"a.in\", \"r\", stdin);\n#endif\n    for (int i = 0; i < M; i++)\n    {\n        prime[i] = 1;\n    }\n    prime[1] = 0;\n    for (int i = 2; i < M; i++)\n    {\n        if (prime[i])\n        {\n            for (int j = i + i; j < M; j += i)\n            {\n                prime[j] = 0;\n            }\n        }\n    }\n    int n;\n    scanf(\"%d\", &n);\n    vector <int> x(n);\n    for (int i = 0; i < n; i++)\n    {\n        for (int j = 0; j < n; j++)\n        {\n            dp[i][j][0] = 1e18;\n            dp[i][j][1] = 1e18;\n        }\n    }\n    for (int i = 0; i < n; i++)\n    {\n        scanf(\"%d\", &x[i]);\n        dp[i][i][0] = 0;\n    }\n    for (int i = 0; i + 1 < n; i++)\n    {\n        dp[i][i + 1][0] = get(x[i + 1] - x[i] - 1);\n    }\n    for (int len = 2; len <= n; len++)\n    {\n        for (int l = 0; l + len - 1 < n; l++)\n        {\n            int r = l + len - 1;\n            for (int t = 0; t < 2; t++)\n            {\n                for (int j = l; j < r; j++)\n                {\n                    dp[l][r][t] = min(dp[l][r][t], dp[l][j][t] + (t == 0 ? get(x[j + 1] - x[j] - 1) : 0) + dp[j + 1][r][t]);\n                }\n            }\n            for (int t = 0; t < 2; t++)\n            {\n                dp[l][r][t] = min(dp[l][r][t], dp[l][r][t ^ 1] + get(x[r] - x[l] + 1));\n            }\n        }\n    }\n    printf(\"%lld\\n\", dp[0][n - 1][1]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define pb push_back\n#define x first\n#define y second\nusing namespace std;\ntypedef long long LL;\ntypedef vector<int> VI;\nusing namespace std;\nconst int NMAX=200666;\nconst int INF=1000000666;\nconst LL INFLL=1000000000000666;\nconst LL maxv=100000;\nconst long double PI = acos(-1.0);\nconst int MAXT = 200000;\n\nint A[105];\nint dp[105];\nint n;\n\nmap<int, bool> M;\n\nbool isprime(int x){\n  int i = 2;\n  int q = 1;\n  if(x == 1){\n    q = 0;\n  }\n  while(i*i <= x){\n    if((x%i) == 0){\n      q=0; \n    }\n    i++;\n  }\n  return q;\n}\n\nint cost(int x){\n  if(x <= 0){\n    return 0;\n  }\n  if((x%2) == 0){\n    return 2;\n  }\n  else{\n    if(!M[x]){\n      if(isprime(x)){\n        return 1;\n        M[x] = 2;\n      }\n      else{\n        return 3;\n        M[x] = 1;\n      }\n    }\n    if(M[x] == 2){\n      return 1;\n    }\n    else\n    {\n      return 3;\n    }\n\n  }\n}\n\nvoid solve(){\n\n  cin>>n;\n  for(int i=1; i<=n; ++i){\n    cin>>A[i];\n  }\n\n  for(int i=1; i<=103; ++i){\n    dp[i] = INF;\n  }\n  //cout<<n<<\"\\n\";\n\n  dp[0] = 0;\n\n  for(int i=1; i<=n; ++i){\n    for(int j=1; j<=i; ++j){\n\n      int ss = cost(A[i] - A[j] + 1);\n      for(int k=j+1; k<=i; ++k){\n        ss += cost(A[k] - A[k-1] - 1);\n      }\n\n      dp[i] = min(dp[i], dp[j-1] + ss);\n    }\n    //cout<<dp[i]<<\" \"<<i<<\"\\n\";\n  }\n  cout<<dp[n]<<\"\\n\";\n\n}\n\n\nint main()\n{\n    // Tic\n    //clock_t t=clock();\n    cout<<setprecision(10)<<fixed;\n    ios_base::sync_with_stdio(0);\n\n    //freopen(\"simetrii.in\", \"rt\", stdin);\n    //freopen(\"simetrii.out\", \"wt\", stdout);\n\n    solve();\n\n    //Toc\n    //t=clock()-t;\n    //printf (\"It took me %d clicks (%f seconds).\\n\",t,((float)t)/CLOCKS_PER_SEC);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <bitset>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio>\n#include <cstring>\n#include <climits>\n#include <string.h>\n#include <stdio.h>\n#define LL long long\n#define all(x) (x).begin(),(x).end()\n#define pii pair<int,int>\n#define piii pair<int, pii >\n#define REP(i,n) for (int (i)=0;(i)<(n);(i)++)\n#define vi vector<int>\n#define vpi vector< pii >\n#define INF 2147483647\n#define big 19260817\n#define pb push_back\n#define mp make_pair\nusing namespace std;\nconst int Maxk=1005;\nstring mul(string a,string b){\n\tint res[Maxk];\n\tmemset(res,0,sizeof(res));\n\treverse(a.begin(),a.end());\n\treverse(b.begin(),b.end());\n\tfor (int i=0;i<a.length();i++){\n\t\tfor (int j=0;j<b.length();j++){\n\t\t\tres[i+j]+=(a[i]-'0')*(b[j]-'0');\n\t\t}\n\t}\n\tfor (int i=0;i<Maxk;i++){\n\t\tif (res[i]>=10) {\n\t\t\tres[i+1]+=(res[i]/10);\n\t\t\tres[i]%=10;\n\t\t}\n\t}\n\tstring ret;\n\tbool flag=false;\n\tfor (int i=Maxk-1;i>=0;i--){\n\t\tif (flag || res[i]){\n\t\t\tflag=true;\n\t\t\tret=ret+(char)(res[i]+'0');\n\t\t}\n\t}\n\tif (ret==\"\") ret=\"0\";\n\treturn ret;\n}\nstring add(string a,string b){\n\tif (a.length()<b.length()) swap(a,b);\n\twhile (a.length()!=b.length()){\n\t\tb='0'+b;\n\t}\n\tfor (int i=a.length()-1;i>=0;i--){\n\t\ta[i]+=(b[i]-'0');\n\t\tif (a[i]>'9' && i){\n\t\t\ta[i]-=10;\n\t\t\ta[i-1]++;\n\t\t}\n\t}\n\tif (a[0]>'9'){\n\t\ta[0]-=10;\n\t\ta='1'+a;\n\t}\n\treturn a;\n}\n\n// cf IO: I64d\n// atcoder IO: ｌｌｄ\ninline int read()\n{\n\tint x = 0, f = 1; char ch = getchar();\n\twhile (ch < '0' || ch > '9') { if (ch == '-') f = -1; ch = getchar(); }\n\twhile (ch >= '0' && ch <= '9') { x = x * 10 + ch - '0'; ch = getchar(); }\n\treturn x * f;\n}\nconst int Maxn=305;\nconst int Maxm=1e7+5;\nint cnt;\nint pos[Maxn],len[Maxn];\nint dp[Maxn][Maxn][2];\nbool isp[Maxm];\nvoid _init(){\n\tmemset(isp,true,sizeof(isp));\n\tisp[1]=isp[0]=false;\n\tfor (int i=2;i<Maxm;i++){\n\t\tif (isp[i]){\n\t\t\tfor (int j=i+i;j<Maxm;j+=i){\n\t\t\t\tisp[j]=false;\n\t\t\t}\n\t\t}\n\t}\n}\nint cost(int len){\n\tif (!len) return 0;\n\tif (len%2==0) return 2;\n\tif (isp[len]) return 1;\n\treturn 3;\n}\nint main(){\n\t_init();//cerr<<123<<endl;\n\tint n;\n\tscanf(\"%d\",&n);\n\tfor (int i=0;i<n;i++){\n\t\tscanf(\"%d\",&pos[i]);\n\t}\n\tint sum=1;\n\tfor (int i=1;i<n;i++){\n\t\tif (pos[i]==pos[i-1]+1) sum++;\n\t\telse{\n\t\t\tlen[++cnt]=sum;\n\t\t\tlen[++cnt]=pos[i]-pos[i-1]-1;\n\t\t\tsum=1;\n\t\t}\n\t}\n\tlen[++cnt]=sum;\n\tfor (int i=1;i<=cnt;i++){\n\t\tif (i%2==0)dp[i][i][0]=0;\n\t\telse dp[i][i][1]=0;\n\t\tif (i%2==0)dp[i][i][1]=cost(len[i]);\n\t\telse dp[i][i][0]=cost(len[i]);\n\t}\n\t//cout<<cnt<<endl;\n\tfor (int Len=2;Len<=cnt;Len++){\n\t\tfor (int i=1;i<=cnt;i++){\n\t\t\tint j=i+Len-1;\n\t\t\tif (j>cnt) continue;\n\t\t\tint totlen=0;\n\t\t\tfor (int k=i;k<=j;k++) totlen+=len[k];\n\t\t\tfor (int f=0;f<2;f++){\n\t\t\t\tfor (int k=i+1;k<=j;k++){\n\t\t\t\t\t// i~k-1 k~j\n\t\t\t\t\tdp[i][j][f]=dp[i][k-1][f]+dp[k][j][f];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (dp[i][j][0]>dp[i][j][1]){\n\t\t\t\tdp[i][j][0]=min(dp[i][j][0],dp[i][j][1]+cost(totlen));\n\t\t\t\tdp[i][j][1]=min(dp[i][j][1],dp[i][j][0]+cost(totlen));\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\",dp[1][cnt][0]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cstdlib>\nusing namespace std;\n\n#define re_ return\n#define in_ inline\n#define op_ operator\n#define inc(l, i, r) for(i=l; i<r; ++i)\n#define st_ static\ntypedef long long ll;\n\nconst int mxn=1<<8;\n\nint n, m, a[mxn], b[mxn<<1], cnt[2], h[mxn<<1];\nstruct edge{int v, o;} e[mxn<<2];\n\nin_ ll dP(ll a, ll b, ll p)\n{\n    st_ ll r;\n    for(r=1; b; a=a*a%p, b>>=1)\n        b&1? r=r*a%p: 0;\n    re_ r;\n}\n\nin_ char chk(ll a, ll p)\n{\n    st_ ll s, r, i;\n    for(r=p-1, s=0; ~r&1; ++s, r/=2);\n    if(i=dP(a, r, p), i==1 || i==p-1) re_ 1;\n    for(;s--;)\n        if((i=i*i%p)==p-1) re_ 1;\n    re_ 0;\n}\n\nin_ char isP(int p)\n{\n    if(p==2) re_ 1;\n    if(p==1 || ~p&1) re_ 0;\n    st_  int i;\n    inc(0, i, 32)\n        if(!chk(rand()%(p-2)+1, p))\n            re_ 0;\n    re_ 1;\n}\n\nin_ void aE(int u, int v)\n{\n    st_ int tot;\n    e[++tot]=(edge){v, h[u]}, u[h]=tot;\n}\n\nchar vis[mxn<<1];\nchar Hun(int u)\n{\n    st_ int f[mxn<<1];\n    int i, v;\n    for(i=u[h]; v=i[e].v; i=i[e].o)\n        if(!vis[v])\n            if(vis[v]=1, !f[v] || Hun(f[v]))\n            re_ f[v]=u, 1;\n    re_ 0;\n}\n\nint main()\n{\n    srand(998244353);\n    int i, j;\n    scanf(\"%d\", &n);\n    inc(0, i, n)\n        scanf(\"%d\", a+i);\n    sort(a, a+n);\n    inc(0, i, n)\n    {\n        if(!i || a[i]>a[i-1]+1)\n            b[++m]=a[i], ++cnt[a[i]&1];\n        if(i>n-2 || a[i]<a[i+1]-1)\n            b[++m]=a[i]+1, ++cnt[a[i]+1&1];\n    }\n    inc(1, i, m+1)\n        if(b[i]&1)\n            inc(1, j, m+1)\n                if(~b[j]&1 && isP(abs(b[i]-b[j])))\n                    aE(i, j);\n\n    j=0;\n    inc(1, i, m+1)\n        if(b[i]&1)\n            memset(vis, 0, sizeof(vis)),\n                j+=Hun(i);\n\n    printf(\"%d\\n\", cnt[0]+cnt[1]-j+(cnt[0]-j&1));\n//    printf(\"%d\\n\", m);\n//    for(;;) scanf(\"%d\", &i), printf(\"%d\\n\", isP(i));\n    re_ 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n#include <assert.h>\n#include <bitset>\n#include <cmath>\n#include <complex>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <limits.h>\n#include <map>\n#include <math.h>\n#include <queue>\n#include <set>\n#include <stdlib.h>\n#include <string.h>\n#include <string>\n#include <time.h>\n//#include <unordered_map>\n//#include <unordered_set>\n#include <vector>\n\n#pragma warning(disable:4996)\n#pragma comment(linker, \"/STACK:33554432\")\nusing namespace std;\n\n#define mp make_pair\n#define all(x) (x).begin(), (x).end()\n#define ldb ldouble\n#define rf(x) (x)=0;while(*p<48)p++;while(47<*p)(x)=((x)<<3)+((x)<<1)+(*p++&15);\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ldb;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\ntypedef pair <ll, int> pli;\ntypedef pair <db, db> pdd;\n//typedef tuple <int, int, int> t3;\n\nint IT_MAX = 1 << 18;\nconst ll MOD = 1000000009;\nconst int INF = 0x3f3f3f3f;\nconst ll LL_INF = 1234567890123456789ll;\nconst db PI = acos(-1);\nconst db EPS = 1e-8;\n#define szz(x) (int)(x).size()\n#define rep(i, n) for(int i=0;i<(n);i++)\n\nclass edge {\npublic:\n\tint s, e, f;\n\tint of;\n\tedge() {\n\t\t*this = edge(0, 0, 0);\n\t}\n\tedge(int s, int e, int f) : s(s), e(e), f(f) {}\n};\nvector <edge> E;\nvector <int> fconn[100050];\nvoid epush(int s, int e, int f) {\n\tfconn[s].push_back(E.size());\n\tfconn[e].push_back(E.size() + 1);\n\tE.emplace_back(s, e, f);\n\tE.emplace_back(e, s, 0);\n}\nint dchk[100050];\nint DFS(int n, int snk, int C, int F) {\n\tif (n == snk) return F;\n\tdchk[n] = C;\n\tfor (auto it : fconn[n]) {\n\t\tedge& ed = E[it];\n\t\tif (ed.f == 0 || dchk[ed.e] == C) continue;\n\t\tint t;\n\t\tif (t = DFS(ed.e, snk, C, min(F, ed.f))) {\n\t\t\ted.f -= t;\n\t\t\tE[it ^ 1].f += t;\n\t\t\treturn t;\n\t\t}\n\t}\n\treturn 0;\n}\nvoid init(int snk) {\n\tint i;\n\tfor (i = 0; i <= snk; i++) {\n\t\tfconn[i].clear();\n\t\tdchk[i] = false;\n\t}\n\tE.clear();\n}\n\nbool pchk[10000050];\n\nvector <int> Va;\nset <int> Sx;\nint in[105];\n\nvector <int> V1;\nvector <int> V2;\nint main() {\n\tint N, i, j;\n\n\tpchk[1] = true;\n\tfor (i = 2; i <= 10000030; i++) {\n\t\tif (pchk[i]) continue;\n\t\tfor (j = 2 * i; j <= 10000030; j += i) pchk[j] = true;\n\t}\n\n\tscanf(\"%d\", &N);\n\tfor (i = 1; i <= N; i++) {\n\t\tscanf(\"%d\", &in[i]);\n\t\tVa.push_back(in[i] - 1);\n\t\tVa.push_back(in[i]);\n\t\tSx.insert(in[i]);\n\t}\n\tsort(all(Va));\n\tfor (i = 0; i < Va.size(); i++) {\n\t\tint t = 0;\n\t\tif (Sx.count(Va[i])) t ^= 1;\n\t\tif (Sx.count(Va[i] + 1)) t ^= 1;\n\t\tif (!t) continue;\n\t\tif (Va[i] % 2) V1.push_back(Va[i]);\n\t\telse V2.push_back(Va[i]);\n\t}\n\n\tint src = V1.size() + V2.size();\n\tint snk = src + 1;\n\tfor (i = 0; i < V1.size(); i++) epush(src, i, 1);\n\tfor (i = 0; i < V2.size(); i++) epush(i + V1.size(), snk, 1);\n\tfor (i = 0; i < V1.size(); i++) {\n\t\tfor (j = 0; j < V2.size(); j++) {\n\t\t\tint t = abs(V1[i] - V2[j]);\n\t\t\tif (!pchk[t]) epush(i, j, 1);\n\t\t}\n\t}\n\t\n\tint f = 0;\n\twhile (DFS(src, snk, f + 1, INF)) f++;\n\n\tint ans = f * 2;\n\tint t1 = (int)V1.size() - f, t2 = (int)V2.size() - f;\n\twhile (t1 >= 2) {\n\t\tans += 2;\n\t\tt1 -= 2;\n\t}\n\twhile (t2 >= 2) {\n\t\tans += 2;\n\t\tt2 -= 2;\n\t}\n\tif (t1 == 1) ans += 3;\n\treturn !printf(\"%d\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <stack>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(n);i++)\n\nbool isp(int x){\n  if(x<=1)return false;\n  if(x==2)return true;\n  if(x%2==0)return false;\n  for(int y=3;y*y<=x;y+=2){\n    if(x%y==0)return false;\n  }\n  return true;\n}\n\nint n;\nint x[125];\nint cap[252][252];\nint main(void){\n  scanf(\"%d\",&n);\n  REP(i,n)scanf(\"%d\",x+i);\n  map<int,int> M;\n  REP(i,n){\n    M[x[i]] ^= 1;\n    M[x[i]+1] ^= 1;\n  }\n  vector<int> even,odd;\n  for(auto P : M)if(P.second==1){\n    (P.first%2==0 ? even : odd).push_back(P.first);\n  }\n  int ne = even.size();\n  int no = odd.size();\n  n = ne + no + 2;\n  int s = ne+no;\n  int t = ne+no+1;\n  REP(i,ne)cap[s][i] = 1;\n  REP(i,no)cap[ne+i][t] = 1;\n  REP(i,ne)REP(j,no){\n    int d = abs(even[i]-odd[j]);\n    if(d<3)continue;\n    if(isp(d)){\n      cap[i][ne+j] = 1;\n    }\n  }\n  int f = 0;\n  while(true){\n    vector<int> bef(n,-1);\n    vector<bool> vstd(n,false);\n    stack<int> S;\n    S.push(s);\n    vstd[s] = true;\n    while(S.size()){\n      int p = S.top(); S.pop();\n      if(p==t)break;\n      REP(i,n)if(cap[p][i] && !vstd[i]){\n        vstd[i] = true;\n        bef[i] = p;\n        S.push(i);\n      }\n    }\n    if(bef[t]==-1)break;\n    int cur = t;\n    while(true){\n      int nxt = bef[cur];\n      if(nxt==-1)break;\n      cap[nxt][cur] = 0;\n      cap[cur][nxt] = 1;\n      cur = nxt;\n    }\n  }\n  int ans = 0;\n  ans += f;\n  ans += (ne-f);\n  ans += (no-f);\n  if((ne-f)%2==1)ans++;\n  printf(\"%d\\n\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(2)\n#include<bits/stdc++.h>\n#define ll long long\n#define maxn 1000005\n#define N 10000005\n#define inf 1e9\n#define pb push_back\n#define rep(i,a,b) for(int i=a;i<=b;i++)\n#define per(i,a,b) for(int i=a;i>=b;i--)\nusing namespace std;\n\ninline int read()\n{\n\tint x=0,w=1; char c=getchar();\n\twhile(c<'0'||c>'9') {if(c=='-') w=-1; c=getchar();}\n\twhile(c<='9'&&c>='0') {x=(x<<1)+(x<<3)+c-'0'; c=getchar();}\n\treturn w==1?x:-x;\n}\n\nbool x[N],is[N];\nint l[maxn],r[maxn],c[maxn],cr,cl,cnt,pri[maxn];\n\nstruct node{int from,to,cap,flow,cost;};\nvector <node> edges;\nvector <int> mp[maxn];\nint s,t,n,m,d[maxn],flow,cost,p[maxn],a[maxn];\nbool inq[maxn];\nqueue <int> que;\n\ninline void A(int u,int v,int w,int c)\n{\n\tedges.push_back((node){u,v,w,0,c});\n\tedges.push_back((node){v,u,0,0,-c});\n\tint pp=edges.size();\n\tmp[u].push_back(pp-2);\n\tmp[v].push_back(pp-1);\n}\n\ninline bool spfa()\n{\n\tfor(int i=0;i<=t;i++) d[i]=inf,inq[i]=0,a[i]=inf;\n\tque.push(s); d[s]=0;\n\twhile(!que.empty())\n\t{\n\t\tint u=que.front(); que.pop(); inq[u]=0;\n\t\tfor(int i=0;i<mp[u].size();i++)\n\t\t{\n\t\t\tnode &v=edges[mp[u][i]];\n\t\t\tif(v.cap-v.flow>0&&d[v.to]>d[u]+v.cost)\n\t\t\t{\n\t\t\t\td[v.to]=d[u]+v.cost;\n\t\t\t\ta[v.to]=min(a[u],v.cap-v.flow);\n\t\t\t\tp[v.to]=mp[u][i];\n\t\t\t\tif(inq[v.to]==0) que.push(v.to),inq[v.to]=1;\n\t\t\t}\n\t\t}\n\t}\n\tif(d[t]==inf) return false;\n\tflow+=a[t];\n\tcost+=a[t]*d[t];\n\tfor(int i=t;i!=s;i=edges[p[i]].from)\n\t{\n\t\tedges[p[i]].flow+=a[t];\n\t\tedges[p[i]^1].flow-=a[t];\n\t}\n\treturn true;\n}\n\ninline void pre()\n{\n\tfor(int i=2;i<=(N-4);i++)\n\t{\n\t\tif(!is[i]) pri[++cnt]=i;\n\t\tfor(int j=1;j<=cnt,pri[j]*i<=(N-5);j++)\n\t\t{\n\t\t\tis[pri[j]*i]=1;\n\t\t\tif(i%pri[j]==0) break;\n\t\t}\n\t}\n}\n\nint main()\n{\n\tn=read(); pre(); rep(i,1,n) c[i]=read(),x[c[i]]=1;\n\trep(i,1,(N-4))\n\t{\n\t\tif(x[i]!=x[i-1])\n\t\t{\n\t\t\tif(x[i]==0) r[++cr]=i-1;\n\t\t\telse l[++cl]=i;\n\t\t}\n\t}\n\t//rep(i,1,cl) cout<<l[i]<<\" \"; puts(\"\");\n\t//rep(i,1,cr) cout<<r[i]<<\" \"; puts(\"\");\n\ts=0; t=2*cl+1;\n\trep(i,1,cl) A(s,i,1,0); rep(i,1,cr) A(i+cl,t,1,0);\n\trep(i,1,cl) rep(j,1,cr)\n\t{\n\t\tint p=l[i]-1,p2=r[j]; if(p<p2) swap(p,p2);\n\t\tint len=p-p2;\n\t\t//if(len==0) A(i,j+cl,1,-3);\n\t\tif(len%2==0) A(i,j+cl,1,-2);\n\t\telse if(len==1) A(i,j+cl,1,-3);\n\t\telse if(!is[len]) A(i,j+cl,1,-1);\n\t\telse A(i,j+cl,1,-3);\n\t}\n\twhile(spfa()); cout<<-cost<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n\nusing namespace std;\n\n#define sz(x) (int)(x.size())\n#define fr(i,a,b) for(int i=a;i<b;++i)\n///////////////////////\n\nint const N = 241;\nint const M = 1e7 + 41;\n\nint l[M], a[N], n, b[M];\nvector<int> p;\nint g[N][N], w[N], lp[N];\nvector<int> pt[2];\n\nvoid sieve(){\n\tfr(i, 2, M){\n\t\tif(l[i] == 0){\n\t\t\tl[i] = i;\n\t\t\tp.push_back(i);\n\t\t}\n\t\tfor(int j=0;j<sz(p) && p[j] * 1LL * i < M && p[j] <= l[i]; ++j){\n\t\t\tl[p[j] * i] = p[j];\n\t\t}\n\t}\n}\n\nbool isPrime(int v){\n\tif(v != 2 && l[v] == v) return true;\n\telse return false;\n}\n\nvoid clear(){\n\tfr(i, 0, N) w[i] = 0;\n}\n\nbool dfs(int u){\n\tw[u] = 1;\n\tfr(i, 0, sz(pt[1])){\n\t\tif(g[u][i]){\n\t\t\tif(lp[i] == -1 || !w[lp[i]] && dfs(lp[i])){\n\t\t\t\tlp[i] = u;\n\t\t\t\treturn true;\n\t\t\t} \n\t\t}\n\t}\n\treturn false;\n}\n\nvoid solve(){\n\tsieve();\n\tcin >> n;\n\tfr(i, 0, n) cin >> a[i];\n\tfr(i, 0, n) b[a[i]] = 1;\n\tfr(i, 1, M){\n\t\tif(b[i] != b[i-1]){\n\t\t\tpt[(i&1)].push_back(i);\n\t\t}\n\t}\n\tfr(i, 0, sz(pt[0])) fr(j, 0, sz(pt[1])){\n\t\tint dist = abs(pt[0][i] - pt[1][j]);\n\t\tif(isPrime(dist)) g[i][j] = 1;\n\t}\n\tfr(i, 0, sz(pt[1])) lp[i] = -1;\n\tfr(i, 0, sz(pt[0])){\n\t\tclear();\n\t\tdfs(i);\n\t}\n\tint ans = 0;\n\tint o = sz(pt[1]);\n\tint e = sz(pt[0]);\n\tfr(i, 0, sz(pt[1])){\n\t\tif(lp[i] != -1) ++ans;\n\t}\n\te -= ans;\n\to -= ans;\n\n\tans += (e / 2) * 2;\n\tans += (o / 2) * 2;\n\te %= 2;\n\to %= 2;\n\tif(o + e > 0) ans += 3;\n\n\tcout << ans << endl;\n}\n\nint main(){\n#ifdef _DEBUG\n\tfreopen(\"input.txt\",\"r\",stdin);\n\tfreopen(\"output.txt\",\"w\",stdout);\n#endif\n\n\tsolve();\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <chrono>\n#include <random>\n#include <cassert>\n#include <queue>\n\nstd::mt19937 rng((int) std::chrono::steady_clock::now().time_since_epoch().count());\n\ntemplate <class T = int>\nclass Dinic {\npublic:\n\tstruct Edge {\n\t\tEdge(int a, T b){to = a;cap = b;}\n\t\tint to;\n\t\tT cap;\n\t};\n\n\tDinic(int _n) : n(_n) {\n\t\tedges.resize(n);\n\t}\n\n\tT maxFlow(int src, int sink) {\n\t\tT ans = 0;\n\t\twhile(bfs(src, sink)) {\n\t\t\tT flow;\n\t\t\tpt = std::vector<int>(n, 0);\n\t\t\twhile((flow = dfs(src, sink))) {\n\t\t\t\tans += flow;\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n\n\tvoid addEdge(int from, int to, T cap = 1) {\n\t\tedges[from].push_back(list.size());\n\t\tlist.push_back(Edge(to, cap));\n\t\tedges[to].push_back(list.size());\n\t\tlist.push_back(Edge(from, 0));\n\t}\nprivate:\n\tint n;\n\tstd::vector<std::vector<int> > edges;\n\tstd::vector<Edge> list;\n\tstd::vector<int> h, pt;\n\n\tT dfs(int on, int sink, T flow = 1e9) {\n\t\tif(flow == 0) {\n\t\t\treturn 0;\n\t\t} if(on == sink) {\n\t\t\treturn flow;\n\t\t}\n\t\tfor(; pt[on] < (int) edges[on].size(); pt[on]++) {\n\t\t\tint cur = edges[on][pt[on]];\n\t\t\tif(h[on] + 1 != h[list[cur].to]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tT got = dfs(list[cur].to, sink, std::min(flow, list[cur].cap));\n\t\t\tif(got) {\n\t\t\t\tlist[cur].cap -= got;\n\t\t\t\tlist[cur ^ 1].cap += got;\n\t\t\t\treturn got;\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\n\tbool bfs(int src, int sink) {\n\t\th = std::vector<int>(n, n);\n\t\th[src] = 0;\n\t\tstd::queue<int> q;\n\t\tq.push(src);\n\t\twhile(!q.empty()) {\n\t\t\tint on = q.front();\n\t\t\tq.pop();\n\t\t\tfor(auto a : edges[on]) {\n\t\t\t\tif(list[a].cap == 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tint to = list[a].to;\n\t\t\t\tif(h[to] > h[on] + 1) {\n\t\t\t\t\th[to] = h[on] + 1;\n\t\t\t\t\tq.push(to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn h[sink] < n;\n\t}\n};\n\n\nint main() {\n\tstd::ios_base::sync_with_stdio(false); std::cin.tie(NULL);\n\tconst int ms = 10010000;\n\tstd::vector<bool> prime(ms, true);\n\tprime[0] = prime[1] = false;\n\tfor(int i = 2; i < ms; i++) {\n\t\tif(!prime[i]) continue;\n\t\tfor(int j = i+i; j < ms; j += i) {\n\t\t\tprime[j] = false;\n\t\t}\n\t}\n\tstd::vector<int> a(ms, 0);\n\tint n;\n\tstd::cin >> n;\n\tfor(int i = 0; i < n; i++) {\n\t\tint x;\n\t\tstd::cin >> x;\n\t\ta[x] ^= 1;\n\t\ta[x+1] ^= 1;\n\t}\n\tstd::vector<int> b;\n\tint f[2] = {0, 0};\n\tfor(int i = 1; i < ms; i++) {\n\t\tif(a[i]) {\n\t\t\tb.push_back(i);\n\t\t\tf[i%2]++;\n\t\t}\n\t}\n\tn = (int) b.size();\n\tDinic<int> graph(n+2);\n\tint src = n, sink = n+1;\n\tfor(int i = 0; i < n; i++) {\n\t\tif(b[i] % 2 == 0) graph.addEdge(src, i, 1);\n\t\telse graph.addEdge(i, sink, 1);\n\t\tfor(int j = 0; j < n; j++) {\n\t\t\tif(prime[abs(b[i] - b[j])] && b[i] % 2 == 0) {\n\t\t\t\tgraph.addEdge(i, j, 1);\n\t\t\t}\n\t\t}\n\t}\n\tint got = graph.maxFlow(src, sink);\n\tf[0] -= got;\n\tf[1] -= got;\n\tint ans = got + f[0] / 2 * 2 + f[1] / 2 * 2;\n\tf[0] %= 2;\n\tf[1] %= 2;\n\tans += f[0] * 3;\n\tassert(f[0] == f[1]);\n\tstd::cout << ans << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n \nusing namespace std;\nusing namespace __gnu_pbds;\n \n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define fbo find_by_order\n#define ook order_of_key\n \ntypedef long long ll;\ntypedef pair<int,int> ii;\ntypedef vector<int> vi;\ntypedef long double ld; \ntypedef tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> pbds;\ntypedef set<int>::iterator sit;\ntypedef map<int,int>::iterator mit;\ntypedef vector<int>::iterator vit;\n\nconst int MX = 255;\nconst int INF = int(1e9);\n\nstruct MaxFlow //by yutaka1999, have to define INF and MX (the Max number of vertices)\n{\n\tstruct edge\n\t{\n\t\tint to,cap,rev;\n\t\tedge(int to=0,int cap=0,int rev=0):to(to),cap(cap),rev(rev){}\n\t};\n\tvector <edge> vec[MX];\n\tint level[MX];\n\tint iter[MX];\n\t\n\tvoid addedge(int s,int t,int c) //adds an edge of cap c to the flow graph\n\t{\n\t\tint S=vec[s].size(),T=vec[t].size();\n\t\tvec[s].push_back(edge(t,c,T));\n\t\tvec[t].push_back(edge(s,0,S));\n\t}\n\tvoid bfs(int s)\n\t{\n\t\tmemset(level,-1,sizeof(level));\n\t\tqueue <int> que;\n\t\tlevel[s] = 0;\n\t\tque.push(s);\n\t\twhile (!que.empty())\n\t\t{\n\t\t\tint v = que.front();que.pop();\n\t\t\tfor(int i=0;i<vec[v].size();i++)\n\t\t\t{\n\t\t\t\tedge&e=vec[v][i];\n\t\t\t\tif (e.cap>0&&level[e.to]<0)\n\t\t\t\t{\n\t\t\t\t\tlevel[e.to]=level[v]+1;\n\t\t\t\t\tque.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tll flow_dfs(int v,int t,ll f)\n\t{\n\t\tif (v==t) return f;\n\t\tfor(int &i=iter[v];i<vec[v].size();i++)\n\t\t{\n\t\t\tedge &e=vec[v][i];\n\t\t\tif (e.cap>0&&level[v]<level[e.to])\n\t\t\t{\n\t\t\t\tll d=flow_dfs(e.to,t,min(f,ll(e.cap)));\n\t\t\t\tif (d>0)\n\t\t\t\t{\n\t\t\t\t\te.cap-=d;\n\t\t\t\t\tvec[e.to][e.rev].cap+=d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tll maxflow(int s,int t) //finds max flow using dinic from s to t\n\t{\n\t\tll flow = 0;\n\t\twhile(1)\n\t\t{\n\t\t\tbfs(s);\n\t\t\tif (level[t]<0) return flow;\n\t\t\tmemset(iter,0,sizeof(iter));\n\t\t\twhile (1)\n\t\t\t{\n\t\t\t\tll f=flow_dfs(s,t,INF);\n\t\t\t\tif(f==0) break;\n\t\t\t\tflow += f;\n\t\t\t}\n\t\t}\n\t}\n};\n\nstruct NumberTheory\n{\n\tvector<ll> primes;\n\tvector<bool> prime;\n\tvector<ll> totient;\n\tvector<ll> sumdiv;\n\tvector<ll> bigdiv;\n\tvoid Sieve(ll n)\n\t{\n\t\tprime.assign(n+1, 1);\n\t\tprime[1] = false;\n\t\tfor(ll i = 2; i <= n; i++)\n\t\t{\n\t\t\tif(prime[i])\n\t\t\t{\n\t\t\t\tprimes.pb(i);\n\t\t\t\tfor(ll j = i*2; j <= n; j += i)\n\t\t\t\t{\n\t\t\t\t\tprime[j] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tll phi(ll x)\n\t{\n\t\tmap<ll,ll> pf;\n\t\tll num = 1; ll num2 = x;\n\t\tfor(ll i = 0; primes[i]*primes[i] <= x; i++)\n\t\t{\n\t\t\tif(x%primes[i]==0)\n\t\t\t{\n\t\t\t\tnum2/=primes[i];\n\t\t\t\tnum*=(primes[i]-1);\n\t\t\t}\n\t\t\twhile(x%primes[i]==0)\n\t\t\t{\n\t\t\t\tx/=primes[i];\n\t\t\t\tpf[primes[i]]++;\n\t\t\t}\n\t\t}\n\t\tif(x>1)\n\t\t{\n\t\t\tpf[x]++; num2/=x; num*=(x-1);\n\t\t}\n\t\tx = 1;\n\t\tnum*=num2;\n\t\treturn num;\n\t}\n\t\n\tbool isprime(ll x)\n\t{\n\t\tif(x==1) return false;\n\t\tfor(ll i = 0; primes[i]*primes[i] <= x; i++)\n\t\t{\n\t\t\tif(x%primes[i]==0) return false;\n\t\t}\n\t\treturn true;\n\t}\n\n\tvoid SievePhi(ll n)\n\t{\n\t\ttotient.resize(n+1);\n\t\tfor (int i = 1; i <= n; ++i) totient[i] = i;\n\t\tfor (int i = 2; i <= n; ++i)\n\t\t{\n\t\t\tif (totient[i] == i)\n\t\t\t{\n\t\t\t\tfor (int j = i; j <= n; j += i)\n\t\t\t\t{\n\t\t\t\t\ttotient[j] -= totient[j] / i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvoid SieveSumDiv(ll n)\n\t{\n\t\tsumdiv.resize(n+1);\n\t\tfor(int i = 1; i <= n; ++i)\n\t\t{\n\t\t\tfor(int j = i; j <= n; j += i)\n\t\t\t{\n\t\t\t\tsumdiv[j] += i;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tll getPhi(ll n)\n\t{\n\t\treturn totient[n];\n\t}\n\t\n\tll getSumDiv(ll n)\n\t{\n\t\treturn sumdiv[n];\n\t}\n\t\n\tll modpow(ll a, ll b, ll mod)\n\t{\n\t\tll r = 1;\n\t\tif(b < 0) b += mod*100000LL;\n\t\twhile(b)\n\t\t{\n\t\t\tif(b&1) r = (r*a)%mod;\n\t\t\ta = (a*a)%mod;\n\t\t\tb>>=1;\n\t\t}\n\t\treturn r;\n\t}\n\t\n\tll inv(ll a, ll mod)\n\t{\n\t\treturn modpow(a, mod - 2, mod);\n\t}\n\t\n\tll invgeneral(ll a, ll mod)\n\t{\n\t\tll ph = phi(mod);\n\t\tph--;\n\t\treturn modpow(a, ph, mod);\n\t}\n\t\n\tvoid getpf(vector<ii>& pf, ll n)\n\t{\n\t\tfor(ll i = 0; primes[i]*primes[i] <= n; i++)\n\t\t{\n\t\t\tint cnt = 0;\n\t\t\twhile(n%primes[i]==0)\n\t\t\t{\n\t\t\t\tn/=primes[i]; cnt++;\n\t\t\t}\n\t\t\tif(cnt>0) pf.pb(ii(primes[i], cnt));\n\t\t}\n\t\tif(n>1)\n\t\t{\n\t\t\tpf.pb(ii(n, 1));\n\t\t}\n\t}\n\n\t//ll op;\n\tvoid getDiv(vector<ll>& div, vector<ii>& pf, ll n, int i)\n\t{\n\t\t//op++;\n\t\tll x, k;\n\t\tif(i >= pf.size()) return ;\n\t\tx = n;\n\t\tfor(k = 0; k <= pf[i].se; k++)\n\t\t{\n\t\t\tif(i==int(pf.size())-1) div.pb(x);\n\t\t\tgetDiv(div, pf, x, i + 1);\n\t\t\tx *= pf[i].fi;\n\t\t}\n\t}\n};\n\nMaxFlow mf;\nNumberTheory nt;\nset<int> S;\n\nvoid add(int z)\n{\n\tif(S.find(z)==S.end()) S.insert(z);\n\telse S.erase(z);\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tint n; cin>>n;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tint z; cin>>z;\n\t\tadd(z); add(z+1);\n\t}\n\tnt.Sieve(10000011);\n\tvi vec;\n\tfor(auto it=S.begin(); it != S.end(); it++) vec.pb(*it);\n\tnt.prime[2]=0;\n\tint s=MX-2; int e=MX-1;\n\tint o=0;\n\tfor(int i=0;i<vec.size();i++)\n\t{\n\t\tif(vec[i]&1) \n\t\t{\n\t\t\to++; mf.addedge(s,i,1);\n\t\t}\n\t\telse mf.addedge(i,e,1);\n\t\tfor(int j=i+1;j<vec.size();j++)\n\t\t{\n\t\t\tif(nt.prime[abs(vec[i]-vec[j])]) \n\t\t\t{\n\t\t\t\tif(vec[i]&1) mf.addedge(i,j,1);\n\t\t\t\telse mf.addedge(j,i,1);\n\t\t\t}\n\t\t}\t\n\t}\n\tint k=mf.maxflow(s,e);\n\tn=vec.size();\n\tcout<<k+((o-k)&1)*3+((o-k)/2+(n-o-k)/2)*2<<'\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cstring>\n#include<queue>\n#include<cmath>\nusing namespace std;\nstruct Edge{\n\tint v,c,nxt;\n}e[600010];int tot=1;\nint first[210];\nvoid build(int u,int v,int c)\n{\n\te[++tot]=(Edge){v,c,first[u]};\n\tfirst[u]=tot;\n\treturn ;\n}\nvoid adde(int u,int v,int c)\n{\n\tbuild(u,v,c);\n\tbuild(v,u,0);\n\treturn ;\n}\nint S,T;\nqueue<int>q;\nint dep[210];\nbool bfs()\n{\n\tmemset(dep,0,sizeof(dep));\n\tdep[S]=1;q.push(S);\n\twhile(!q.empty())\n\t{\n\t\tint u=q.front();q.pop();\n\t\tfor(int i=first[u];i;i=e[i].nxt)\n\t\t\tif(e[i].c&&!dep[e[i].v])\n\t\t\t{\n\t\t\t\tdep[e[i].v]=dep[u]+1;\n\t\t\t\tq.push(e[i].v);\n\t\t\t}\n\t}\n\treturn dep[T]>0;\n}\nint cur[210];\nint dfs(int u,int flow)\n{\n\tif(u==T)return flow;\n\tfor(int &i=cur[u];i;i=e[i].nxt)\n\t\tif(e[i].c&&dep[u]+1==dep[e[i].v])\n\t\t{\n\t\t\tint d=dfs(e[i].v,min(flow,e[i].c));\n\t\t\tif(d){\n\t\t\t\te[i].c-=d;\n\t\t\t\te[i^1].c+=d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\treturn 0;\n}\nint dinic()\n{\n\tint ans=0;\n\twhile(bfs()){\n\t\tfor(int i=S;i<=T;i++)\n\t\t\tcur[i]=first[i];\n\t\tint d;\n\t\twhile(d=dfs(S,1e9))\n\t\t\tans+=d;\n\t}\n\treturn ans;\n}\nbool check(int a)\n{\n\tif(a<=2)return false;\n\tfor(int i=2;i*i<=a;i++)\n\t\tif(a%i==0)return false;\n\treturn true;\n}\nint x[210];\nint vis[10000010];\nint main()\n{\n\tint n;scanf(\"%d\",&n);\n\tint N=0;\n\tint mx=0;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint a;scanf(\"%d\",&a);\n\t\tvis[a]=1;mx=max(mx,a);\n\t}\n\tfor(int i=1;i<=mx+1;i++)\n\t\tif(vis[i]!=vis[i-1])\n\t\t\tx[++N]=i;\n\tS=0;T=N+1;\n\tint cntx=0,cnty=0;\n\tfor(int i=1;i<=N;i++)\n\t\tif(x[i]&1){\n\t\t\tadde(S,i,1);\n\t\t\tcntx++;\n\t\t}\n\t\telse{\n\t\t\tadde(i,T,1);\n\t\t\tcnty++;\n\t\t}\n\tfor(int i=1;i<=N;i++)\n\t\tif(x[i]&1){\n\t\t\tfor(int j=1;j<=N;j++)\n\t\t\t\tif(check(abs(x[i]-x[j])))\n\t\t\t\t\tadde(i,j,1);\n\t\t}\n\tint res=dinic();\n\tint ans=res+(cntx-res)/2*2+(cnty-res)/2*2+((cntx-res)&1)*3;\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntemplate<class T> inline void read(T &x){\n\tx=0; register char c=getchar(); register bool f=0;\n\twhile(!isdigit(c))f^=c=='-',c=getchar();\n\twhile(isdigit(c))x=x*10+c-'0',c=getchar(); if(f)x=-x;\n}\ntemplate<class T> inline void print(T x){\n\tif(x<0)putchar('-'),x=-x;\n\tif(x>9)print(x/10); putchar(x%10+'0');\n}\ntemplate<class T> inline void print(T x,char c){print(x),putchar(c);}\nconst int N=2e3+10,E=4e6+10,M=1e7+10;\nbool vis[M],b[M];\nint n,s,e,max,cnt,ans,flow,cnt0,cnt1,tot=2;\nint pre[N],cur[N],hed[N],dep[N],gap[N],a[N],pri[M/10],val[E],nxt[E],to[E];\nint query(int x){\n\tif(x==2||x==4)return 2;\n\tif(!vis[x])return 1;\n\tif(x&1)return 3;\n\treturn 2;\n}\nvoid init(int n){\n\tvis[1]=1;\n\tfor(int i=2;i<=n;i++){\n\t\tif(!vis[i]){pri[++cnt]=i;}\n\t\tfor(int j=1;j<=cnt&&i*pri[j]<=n;j++){\n\t\t\tvis[i*pri[j]]=1;\n\t\t\tif(i%pri[j]==0)break;\n\t\t}\n\t}\n}\nvoid add_edge(int u,int v){\n\tnxt[tot]=hed[u],to[tot]=v,val[tot]=1,hed[u]=tot++;\n\tnxt[tot]=hed[v],to[tot]=u,val[tot]=0,hed[v]=tot++;\n}\nint isap(){\n\tint u=s,res=0;gap[0]=e;\n\twhile(dep[s]<e){\n\t\tbool flag=1;\n\t\tfor(int&i=cur[u];i;i=nxt[i]){\n\t\t\tif(val[i]&&dep[to[i]]+1==dep[u]){pre[to[i]]=i,u=to[i];flag=0;break;}\n\t\t}\n\t\tif(flag){\n\t\t\tif(!--gap[dep[u]])break;\n\t\t\tdep[u]=e;\n\t\t\tfor(int i=hed[u];i;i=nxt[i]){\n\t\t\t\tif(val[i]&&dep[to[i]]+1<dep[u])dep[u]=dep[to[i]]+1,cur[u]=i;\n\t\t\t}\n\t\t\t++gap[dep[u]];\n\t\t\tif(u!=s)u=to[pre[u]^1];\n\t\t}\n\t\tif(u==e){\n\t\t\tfor(int i=pre[e];i;i=pre[to[i^1]])val[i]--,val[i^1]++;\n\t\t\tu=s,res++;\n\t\t}\n\t}\n\treturn res;\n}\nint main(){\n\tread(n),init(1000);\n\tfor(int i=1;i<=n;i++)read(a[i]),max=std::max(max,a[i]+2);\n\tfor(int i=1;i<=n;i++)b[a[i]]=1; n=0;\n\tfor(int i=max;i;i--)b[i]^=b[i-1];\n\tfor(int i=1;i<=max;i++)if(b[i])a[++n]=i;\n\ts=n+1,e=n+2;\n\tfor(int i=1;i<=n;i++)(a[i]&1)?(++cnt1,add_edge(s,i)):(++cnt0,add_edge(i,e));\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=i+1;j<=n;j++)\n\t\t\tif(query(a[j]-a[i])==1){\n\t\t\t\t(a[i]&1)?add_edge(i,j):add_edge(j,i);\n\t\t\t\t// printf(\"> %d %d\\n\",i,j);\n\t\t\t}\n\t// for(int i=1;i<=n;i++)print(a[i],\" \\n\"[i==n]);\n\tans=flow=isap(),cnt0-=flow,cnt1-=flow; if(cnt1&1)ans+=3; ans+=((cnt0>>1)+(cnt1>>1))<<1;\n\t// printf(\"flow=%d cnt0=%d cnt1=%d\\n\",flow,cnt0,cnt1);\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef pair<ld,ld> pdd;\n\n#define X first\n#define Y second\n\nconst int MAXN = 110;\n\nint n;\nint a[MAXN], u[MAXN];\n\nll mul(ll a,ll b,ll p)\n{\n\tll t=0;\n\twhile (b)\n\t{\n\t\tif (b&1) t=(t+a)%p;\n\t\ta=a*2%p;\n\t\tb/=2;\n\t}\n\treturn t;\n}\n\nll power(ll a,ll b,ll p)\n{\n\tif (b==0) return 1;\n\tll t=power(a,b/2,p);\n\tt=mul(t,t,p);\n\tif (b&1) t=mul(t,a,p);\n\treturn t;\n}\n\nll getabs(ll x)\n{\n\treturn (x>=0)?x:-x;\n}\n\nll gcd(ll a,ll b)\n{\n\treturn b?gcd(b,a%b):a;\n}\n\nbool is_prime(ll p)\n{\n\tstatic ll a[]={2,3,5,7,11,13,17,19,23,29,31,37};\n\tif (p==1) return false;\n\tfor (int i=0;i<12&&a[i]<p;++i)\n\t{\n\t\tll t=p-1;\n\t\tint s=0;\n\t\twhile (t%2==0)\n\t\t{\n\t\t\tt/=2;\n\t\t\t++s;\n\t\t}\n\t\tll d=power(a[i],t,p);\n\t\tif (d==1||d==p-1) continue;\n\t\tint flag=0;\n\t\tfor (;s;--s)\n\t\t{\n\t\t\td=mul(d,d,p);\n\t\t\tif (d==p-1)\n\t\t\t{\n\t\t\t\tflag=1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!flag) return false;\n\t}\n\treturn true;\n}\n\nconst int INF = 1000000000;\nint F[MAXN];\n\nint calc(int x, int y)\n{\n\tint ret = 0;\n\tint t = a[y]-a[x]+1;\n\tif (t == 1)\n\t\treturn 3;\n\tif (is_prime(t))\n\t{\n\t\tret ++;\n\t\tif (t == 2) ret ++;\n\t}\n\telse\n\t{\n\t\tif (t%2 == 0)\n\t\t\tret += 2;\n\t\telse\n\t\t\tret += 3;\n\t}\n\tfor (int i = x; i < y; ++ i)\n\t{\n\t\tint t = a[i+1]-a[i]-1;\n\t\tif (!t) continue;\n\t\tif (is_prime(t))\n\t\t{\n\t\t\tret ++;\n\t\t\tif (t == 2) ret ++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (t%2 == 0)\n\t\t\t\tret += 2;\n\t\t\telse\n\t\t\t\tret += 3;\n\t\t}\n\t}\n\treturn ret;\n}\n\nint main()\n{\n\t\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; ++ i)\n\t{\n\t\tscanf(\"%d\", &a[i]);\n\t}\n\tF[0] = 0;\n\tfor (int i = 1; i <= n; ++ i)\n\t{\n\t\tF[i] = INF;\n\t\tfor (int j = 0; j < i; ++ j)\n\t\t{\n\t\t\tF[i] = min(F[i], F[j]+calc(j+1, i));\n\t\t}\n\t}\n\tcout << F[n] << endl;\n\t\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma region Macros\n#pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\n#define ll long long\n#define ld long double\n#define rep2(i, a, b) for(ll i = a; i <= b; ++i)\n#define rep(i, n) for(ll i = 0; i < n; ++i)\n#define rep3(i, a, b) for(ll i = a; i >= b; --i)\n#define pii pair<int, int>\n#define pll pair<ll, ll>\n#define pb push_back\n#define eb emplace_back\n#define vi vector<int>\n#define vll vector<ll>\n#define vpi vector<pii>\n#define vpll vector<pll>\n#define overload2(_1, _2, name, ...) name\n#define vec(type, name, ...) vector<type> name(__VA_ARGS__)\n#define VEC(type, name, size)                                                                                                                                  \\\n    vector<type> name(size);                                                                                                                                   \\\n    IN(name)\n#define vv(type, name, h, ...) vector<vector<type>> name(h, vector<type>(__VA_ARGS__))\n#define VV(type, name, h, w)                                                                                                                                   \\\n    vector<vector<type>> name(h, vector<type>(w));                                                                                                             \\\n    IN(name)\n#define vvv(type, name, h, w, ...) vector<vector<vector<type>>> name(h, vector<vector<type>>(w, vector<type>(__VA_ARGS__)))\n#define fi first\n#define se second\n#define all(c) begin(c), end(c)\n#define ios ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n#define lb(c, x) distance((c).begin(), lower_bound(all(c), (x)))\n#define ub(c, x) distance((c).begin(), upper_bound(all(c), (x)))\nusing namespace std;\ntemplate <class T> using pq = priority_queue<T>;\ntemplate <class T> using pqg = priority_queue<T, vector<T>, greater<T>>;\n#define Size(c) (int)(c).size()\n#define INT(...)                                                                                                                                               \\\n    int __VA_ARGS__;                                                                                                                                           \\\n    IN(__VA_ARGS__)\n#define LL(...)                                                                                                                                                \\\n    ll __VA_ARGS__;                                                                                                                                            \\\n    IN(__VA_ARGS__)\n#define ULL(...)                                                                                                                                               \\\n    ull __VA_ARGS__;                                                                                                                                           \\\n    IN(__VA_ARGS__)\n#define STR(...)                                                                                                                                               \\\n    string __VA_ARGS__;                                                                                                                                        \\\n    IN(__VA_ARGS__)\n#define CHR(...)                                                                                                                                               \\\n    char __VA_ARGS__;                                                                                                                                          \\\n    IN(__VA_ARGS__)\n#define DBL(...)                                                                                                                                               \\\n    double __VA_ARGS__;                                                                                                                                        \\\n    IN(__VA_ARGS__)\n#define LD(...)                                                                                                                                                \\\n    ld __VA_ARGS__;                                                                                                                                            \\\n    IN(__VA_ARGS__)\nint scan() { return getchar(); }\ntemplate <class T> void scan(T a) { cin >> a; }\nvoid scan(int &a) { cin >> a; }\nvoid scan(long long &a) { cin >> a; }\nvoid scan(char &a) { cin >> a; }\nvoid scan(double &a) { cin >> a; }\nvoid scan(long double &a) { cin >> a; }\nvoid scan(char a[]) { scanf(\"%s\", a); }\nvoid scan(string &a) { cin >> a; }\ntemplate <class T> void scan(vector<T> &);\ntemplate <class T, size_t size> void scan(array<T, size> &);\ntemplate <class T, class L> void scan(pair<T, L> &);\ntemplate <class T, size_t size> void scan(T (&)[size]);\ntemplate <class T> void scan(vector<T> &a) {\n    for(auto &i : a) scan(i);\n}\ntemplate <class T> void scan(deque<T> &a) {\n    for(auto &i : a) scan(i);\n}\ntemplate <class T, size_t size> void scan(array<T, size> &a) {\n    for(auto &i : a) scan(i);\n}\ntemplate <class T, class L> void scan(pair<T, L> &p) {\n    scan(p.first);\n    scan(p.second);\n}\ntemplate <class T, size_t size> void scan(T (&a)[size]) {\n    for(auto &i : a) scan(i);\n}\ntemplate <class T> void scan(T &a) { cin >> a; }\nvoid IN() {}\ntemplate <class Head, class... Tail> void IN(Head &head, Tail &... tail) {\n    scan(head);\n    IN(tail...);\n}\nstring stin() {\n    string s;\n    cin >> s;\n    return s;\n}\ntemplate <class T> inline bool chmax(T &a, T b) {\n    if(a < b) {\n        a = b;\n        return 1;\n    }\n    return 0;\n}\ntemplate <class T> inline bool chmin(T &a, T b) {\n    if(a > b) {\n        a = b;\n        return 1;\n    }\n    return 0;\n}\nvi iota(int n) {\n    vi a(n);\n    iota(all(a), 0);\n    return a;\n}\ntemplate <class T> void UNIQUE(vector<T> &x) {\n    sort(all(x));\n    x.erase(unique(all(x)), x.end());\n}\nint in() {\n    int x;\n    cin >> x;\n    return x;\n}\nll lin() {\n    unsigned long long x;\n    cin >> x;\n    return x;\n}\nvoid print() { putchar(' '); }\nvoid print(bool a) { cout << a; }\nvoid print(int a) { cout << a; }\nvoid print(long long a) { cout << a; }\nvoid print(char a) { cout << a; }\nvoid print(string &a) { cout << a; }\nvoid print(double a) { cout << a; }\ntemplate <class T> void print(const vector<T> &);\ntemplate <class T, size_t size> void print(const array<T, size> &);\ntemplate <class T, class L> void print(const pair<T, L> &p);\ntemplate <class T, size_t size> void print(const T (&)[size]);\ntemplate <class T> void print(const vector<T> &a) {\n    if(a.empty()) return;\n    print(a[0]);\n    for(auto i = a.begin(); ++i != a.end();) {\n        cout << \" \";\n        print(*i);\n    }\n    cout << endl;\n}\ntemplate <class T> void print(const deque<T> &a) {\n    if(a.empty()) return;\n    print(a[0]);\n    for(auto i = a.begin(); ++i != a.end();) {\n        cout << \" \";\n        print(*i);\n    }\n}\ntemplate <class T, size_t size> void print(const array<T, size> &a) {\n    print(a[0]);\n    for(auto i = a.begin(); ++i != a.end();) {\n        cout << \" \";\n        print(*i);\n    }\n}\ntemplate <class T, class L> void print(const pair<T, L> &p) {\n    cout << '(';\n    print(p.first);\n    cout << \",\";\n    print(p.second);\n    cout << ')';\n}\ntemplate <class T> void print(set<T> &x) {\n    for(auto e : x) print(e), cout << \" \";\n    cout << endl;\n}\ntemplate <class T> void print(multiset<T> &x) {\n    for(auto e : x) print(e), cout << \" \";\n    cout << endl;\n}\ntemplate <class T, size_t size> void print(const T (&a)[size]) {\n    print(a[0]);\n    for(auto i = a; ++i != end(a);) {\n        cout << \" \";\n        print(*i);\n    }\n}\ntemplate <class T> void print(const T &a) { cout << a; }\nint out() {\n    putchar('\\n');\n    return 0;\n}\ntemplate <class T> int out(const T &t) {\n    print(t);\n    putchar('\\n');\n    return 0;\n}\ntemplate <class Head, class... Tail> int out(const Head &head, const Tail &... tail) {\n    print(head);\n    putchar(' ');\n    out(tail...);\n    return 0;\n}\nll gcd(ll a, ll b) {\n    while(b) {\n        ll c = b;\n        b = a % b;\n        a = c;\n    }\n    return a;\n}\nll lcm(ll a, ll b) {\n    if(!a || !b) return 0;\n    return a * b / gcd(a, b);\n}\nvector<pll> factor(ll x) {\n    vector<pll> ans;\n    for(ll i = 2; i * i <= x; i++)\n        if(x % i == 0) {\n            ans.push_back({i, 1});\n            while((x /= i) % i == 0) ans.back().second++;\n        }\n    if(x != 1) ans.push_back({x, 1});\n    return ans;\n}\nvector<int> divisor(int x) {\n    vector<int> ans;\n    for(int i = 1; i * i <= x; i++)\n        if(x % i == 0) {\n            ans.pb(i);\n            if(i * i != x) ans.pb(x / i);\n        }\n    return ans;\n}\ntemplate <typename T> void zip(vector<T> &x) {\n    vector<T> y = x;\n    sort(all(y));\n    for(int i = 0; i < x.size(); ++i) { x[i] = lb(y, x[i]); }\n}\nint popcount(ll x) { return __builtin_popcountll(x); }\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nint rnd(int n) { return uniform_int_distribution<int>(0, n - 1)(rng); }\ntemplate <typename T> void shuffle(vector<T> &v) {\n    rep3(i, v.size() - 1, 1) { swap(v[i], v[rnd(i)]); }\n}\n#define endl '\\n'\nvector<string> YES{\"NO\", \"YES\"};\nvector<string> Yes{\"No\", \"Yes\"};\nvector<string> yes{\"no\", \"yes\"};\n\n#ifdef _LOCAL\n#undef endl\n#define debug(x)                                                                                                                                               \\\n    cout << #x << \": \";                                                                                                                                        \\\n    print(x);                                                                                                                                                  \\\n    cout << endl;\nvoid err() {}\ntemplate <class T> void err(const T &t) {\n    print(t);\n    cout << \" \";\n}\ntemplate <class Head, class... Tail> void err(const Head &head, const Tail &... tail) {\n    print(head);\n    putchar(' ');\n    out(tail...);\n}\n#else\n#define debug(x)\ntemplate <class... T> void err(const T &...) {}\n#endif\n\ntemplate <typename T> struct edge {\n    int from, to;\n    T cost;\n    int id;\n    edge(int to, T cost) : from(-1), to(to), cost(cost) {}\n    edge(int from, int to, T cost) : from(from), to(to), cost(cost) {}\n    // edge(int from,int to,T cost,int id):from(from),to(to),cost(cost),id(id){}\n    edge &operator=(const int &x) {\n        to = x;\n        return *this;\n    }\n    operator int() const { return to; }\n};\n\ntemplate <typename T> using Edges = vector<edge<T>>;\ntemplate <typename T> using WeightedTree = vector<Edges<T>>;\ntemplate <typename T> using Edges = vector<edge<T>>;\ntemplate <typename T> using WeightedGraph = vector<Edges<T>>;\ntemplate <typename T> using Matrix = vector<vector<T>>;\nusing Graph = vector<vector<int>>;\nusing tree = vector<vector<int>>;\n\ntree getTree(int n, int offset = 1) {\n    tree res(n);\n    for(int i = 0; i < n - 1; i++) {\n        int a, b;\n        cin >> a >> b;\n        a -= offset, b -= offset;\n        res[a].emplace_back(b);\n        res[b].emplace_back(a);\n    }\n    return res;\n}\ntemplate <typename T> WeightedTree<T> getWeightedTree(int n, int offset = 1) {\n    WeightedTree<T> res(n);\n    for(int i = 0; i < n - 1; i++) {\n        int a, b;\n        cin >> a >> b;\n        a -= offset, b -= offset;\n        T c;\n        cin >> c;\n        res[a].emplace_back(b, c);\n        res[b].emplace_back(a, c);\n    }\n    return res;\n}\n\nGraph getGraph(int n, int m, int offset = 1) {\n    Graph res(n);\n    for(int i = 0; i < m; ++i) {\n        int a, b;\n        cin >> a >> b;\n        a -= offset, b -= offset;\n        res[a].emplace_back(b);\n        res[b].emplace_back(a);\n    }\n    return res;\n}\n\ntemplate <typename T> WeightedGraph<T> getWeightedGraph(int n, int m, int offset = 1) {\n    WeightedGraph<T> res(n);\n    for(int i = 0; i < m; ++i) {\n        int a, b;\n        cin >> a >> b;\n        T c;\n        cin >> c;\n        res[a].emplace_back(b, c);\n        res[b].emplace_back(a, c);\n    }\n}\nstruct Setup_io {\n    Setup_io() {\n        ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n        cout << fixed << setprecision(15);\n    }\n} setup_io;\n#pragma endregion\n\n// _________コーディングはここから！！___________\n\nnamespace Factorize {\nusing i128 = __int128_t;\nll get_factor(ll n) {\n    if(n == 3 or n == 5) return 0;\n    ll x, y;\n    ll iter = 0;\n    while(true) {\n        ++iter;\n        x = iter % n;\n        y = (i128(iter) * i128(iter) + 1) % i128(n);\n        while(1) {\n            ll g = gcd(n, abs(x - y));\n            if(g == n) break;\n            if(g > 1) return g;\n            x = (i128(x) * i128(x) + 1) % i128(n);\n            y = (i128(y) * i128(y) + 1) % i128(n);\n            y = (i128(y) * i128(y) + 1) % i128(n);\n        }\n    }\n}\nll modpow(ll a, ll n, ll mod) {\n    ll res = 1;\n    while(n) {\n        if(n & 1) res = i128(a) * i128(res) % i128(mod);\n        n >>= 1, a = i128(a) * i128(a) % i128(mod);\n    }\n    return res;\n}\nbool miller_rabin_test(ll p, ll s, ll d, ll n) {\n    ll x = modpow(p, d, n);\n    if(x == 1) return true;\n    ll y = n - 1;\n    rep(i, s) {\n        if(x == y) return true;\n        x = i128(x) * i128(x) % i128(n);\n    }\n    return false;\n}\nbool miller_rabin(ll n) {\n    if(n == 1) return false;\n    ll d = n - 1, s = 0;\n    while(~d & 1) d >>= 1, ++s;\n    if(n < 4759123141LL) {\n        for(auto p : {2, 7, 61}) {\n            if(p >= n) break;\n            if(!miller_rabin_test(p, s, d, n)) return false;\n        }\n    } else {\n        for(auto p : {2, 325, 9375, 28178, 450775, 9780504, 1795265022}) {\n            if(p >= n) break;\n            if(!miller_rabin_test(p, s, d, n)) return false;\n        }\n    }\n    return true;\n}\n\nmap<ll, int> factorize(ll n) {\n    map<ll, int> res;\n    while(~n & 1) res[2]++, n >>= 1;\n    queue<ll> que;\n    que.emplace(n);\n    while(!que.empty()) {\n        ll now = que.front();\n        que.pop();\n        if(now == 1) continue;\n        if(miller_rabin(now)) {\n            res[now]++;\n            continue;\n        }\n        ll g = get_factor(now);\n        que.emplace(g);\n        que.emplace(now / g);\n    }\n    return res;\n}\n\nbool isPrime(ll n) { return miller_rabin(n); }\n} // namespace Factorize\nusing namespace Factorize;\nstruct HopcroftKarp {\n    vector<vector<int>> graph;\n    vector<int> dist, match;\n    vector<bool> used, vv;\n\n    HopcroftKarp(int n, int m) : graph(n), match(m, -1), used(n) {}\n\n    void add_edge(int u, int v) { graph[u].push_back(v); }\n\n    void bfs() {\n        dist.assign(graph.size(), -1);\n        queue<int> que;\n        for(int i = 0; i < graph.size(); i++) {\n            if(!used[i]) {\n                que.emplace(i);\n                dist[i] = 0;\n            }\n        }\n\n        while(!que.empty()) {\n            int a = que.front();\n            que.pop();\n            for(auto &b : graph[a]) {\n                int c = match[b];\n                if(c >= 0 && dist[c] == -1) {\n                    dist[c] = dist[a] + 1;\n                    que.emplace(c);\n                }\n            }\n        }\n    }\n\n    bool dfs(int a) {\n        vv[a] = true;\n        for(auto &b : graph[a]) {\n            int c = match[b];\n            if(c < 0 || (!vv[c] && dist[c] == dist[a] + 1 && dfs(c))) {\n                match[b] = a;\n                used[a] = true;\n                return (true);\n            }\n        }\n        return (false);\n    }\n\n    int bipartite_matching() {\n        int ret = 0;\n        while(true) {\n            bfs();\n            vv.assign(graph.size(), false);\n            int flow = 0;\n            for(int i = 0; i < graph.size(); i++) {\n                if(!used[i] && dfs(i)) ++flow;\n            }\n            if(flow == 0) return (ret);\n            ret += flow;\n        }\n    }\n\n    void output() {\n        for(int i = 0; i < match.size(); i++) {\n            if(~match[i]) { cout << match[i] << \"-\" << i << endl; }\n        }\n    }\n};\n\nmain() {\n    INT(n);\n    VEC(int, a, n);\n    const int N = 1e7 + 2;\n    vi p(N);\n    rep(i, n) p[a[i]]++;\n    rep(i, N - 1) { p[i] = p[i + 1] ^ p[i]; }\n    vi x[2];\n    rep(i, N) {\n        if(p[i]) x[i & 1].eb(i);\n    }\n    HopcroftKarp g(x[0].size(), x[1].size());\n    rep(i, x[0].size()) {\n        rep(j, x[1].size()) {\n            int d = abs(x[1][j] - x[0][i]);\n            if(isPrime(d)) g.add_edge(i, j);\n        }\n    }\n    int d = g.bipartite_matching();\n    int ans = x[0].size() + x[1].size() - d;\n    if((x[0].size() - d) & 1) ans++;\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<cmath>\nconst int N=102;\nint n,cnp,cnj,cnt,og[N],hx[N<<1],fir[N<<1],prm[460];\nbool npr[3200];\nstruct edge{\n\tint to,wi,nx;\n}eg[N*N<<1];\n\ninline void add(int a,int b,int v){\n\tstatic int cnt=1;\n\teg[++cnt]=(edge){b,v,fir[a]};\n\tfir[a]=cnt;\n\teg[++cnt]=(edge){a,0,fir[b]};\n\tfir[b]=cnt;\n}\n\ninline char get_c(){\n\tstatic char buf[20000],*h,*t;\n\tif(h==t){\n\t\tt=(h=buf)+fread(buf,1,20000,stdin);\n\t}\n\treturn h==t?EOF:*h++;\n}\n\ninline int nxi(){\n\tint x=0;\n\tchar c;\n\twhile((c=get_c())>'9'||c<'0');\n\twhile(x=x*10-48+c,(c=get_c())>='0'&&c<='9');\n\treturn x;\n}\n\ninline void init(){\n\tnpr[1]=1;\n\tfor(int i=2;i<3200;++i){\n\t\tif(!npr[i]) prm[++cnp]=i;\n\t\tfor(int j=1;j<=cnp&&i*prm[j]<3200;++j){\n\t\t\tnpr[i*prm[j]]=1;\n\t\t\tif(i%prm[j]==0) break;\n\t\t}\n\t}\n}\n\ninline bool ispr(int x){\n\tif(x<3200) return !npr[x];\n\tint sq=sqrt(x)+1;\n\tfor(int i=1;prm[i]<=sq;++i){\n\t\tif(x%prm[i]==0) return 0;\n\t}\n\treturn 1;\n}\n\nnamespace F{\n\tint dep[N<<1],que[N<<1],cur[N<<1];\n\n\tinline bool bfs(){\n\t\tmemset(dep,0,sizeof(dep));\n\t\tint hd=0,tl=1;\n\t\tdep[0]=1;\n\t\twhile(hd!=tl){\n\t\t\tint x=que[hd++];\n\t\t\tfor(int i=cur[x]=fir[x];i;i=eg[i].nx){\n\t\t\t\tint y=eg[i].to;\n\t\t\t\tif(eg[i].wi&&!dep[y]){\n\t\t\t\t\tdep[y]=dep[x]+1;\n\t\t\t\t\tque[tl++]=y;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn dep[(N<<1)-1];\n\t}\n\n\tint dfs(int x,int t){\n\t\tif(x==(N<<1)-1) return t;\n\t\tint tp,tt=t;\n\t\tfor(int &i=cur[x];i;i=eg[i].nx){\n\t\t\tint y=eg[i].to,v=eg[i].wi;\n\t\t\tif(v&&tt&&dep[x]+1==dep[y]&&(tp=dfs(y,std::min(v,tt)))){\n\t\t\t\teg[i].wi-=tp;\n\t\t\t\teg[i^1].wi+=tp;\n\t\t\t\ttt-=tp;\n\t\t\t\tif(!tt) break;\n\t\t\t}\n\t\t}\n\t\treturn t-tt;\n\t}\n}\n\nint main(){\n#ifndef ONLINE_JUDGE\n//\tfreopen(\"c.in\",\"r\",stdin);\n#endif\n\tinit();\n\tn=nxi();\n\tfor(int i=1;i<=n;++i){\n\t\tog[i]=nxi();\n\t}\n\tstd::sort(og+1,og+n+1);\n\tog[0]=-1;\n\tfor(int i=1;i<=n;++i){\n\t\tif(og[i]-og[i-1]>1){\n\t\t\tif(og[i-1]+1) hx[++cnt]=og[i-1]+1;\n\t\t\thx[++cnt]=og[i];\n\t\t}\n\t}\n\thx[++cnt]=og[n]+1;\n\tfor(int i=1;i<=cnt;++i){\n\t\tif(hx[i]&1) ++cnj;\n\t\tif(hx[i]&1) add(0,i,1);\n\t\telse add(i,(N<<1)-1,1);\n\t\tfor(int j=i+1;j<=cnt;++j){\n\t\t\tint p=hx[j]-hx[i];\n\t\t\tif((p&1)&&ispr(p)){\n\t\t\t\tif(hx[i]&1) add(i,j,1);\n\t\t\t\telse add(j,i,1);\n\t\t\t}\n\t\t}\n\t}\n\tint ans=0;\n\twhile(F::bfs()){\n\t\tans+=F::dfs(0,N);\n\t}\n\tprintf(\"%d\\n\",cnt-ans+(cnj&1));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<cstring>\nusing namespace std;\nint n;\nint res;\nvector<int>v;\nint lst=-1;\nint match[210];\nint me,mo;\nint mx;\nbool f[10000010];\nvector<int>ok[210];\nbool vis[210];\nint prm[1000010];\nint sz;\nbool bp(int x)\n{\n\tfor(int i=0;i<ok[x].size();i++)\n\t{\n\t\tint y=ok[x][i];\n\t\tif(vis[y])continue;\n\t\tvis[y]=true;\n\t\tif(match[y]==-1 || bp(match[y]))\n\t\t{\n\t\t\tmatch[y]=x;\n\t\t\treturn true;\n\t\t}\n\t\tvis[y]=false;\n\t}\n\treturn false;\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint x;\n\t\tscanf(\"%d\",&x);\n\t\tif(x!=lst+1)\n\t\t{\n\t\t\tif(lst+1)v.push_back(lst+1);\n\t\t\tv.push_back(x);\n\t\t}\n\t\tlst=x;\n\t\tmx=lst+1;\n\t}\n\tv.push_back(lst+1);\n\tf[1]=true;\n\tfor(int i=2;i<=mx;i++)\n\t{\n\t\tif(!f[i])prm[++sz]=i;\n\t\tfor(int j=1;j<=sz;j++)\n\t\t{\n\t\t\tif(prm[j]*i>mx)break;\n\t\t\tf[prm[j]*i]=true;\n\t\t\tif(i%prm[j]==0)break;\n\t\t}\n\t}\n\tint l=v.size();\n\tfor(int i=0;i<l;i++)\n\t{\n\t\tmatch[i]=-1;\n\t\tif(v[i]&1)mo++;else me++;\n\t\tfor(int j=i+1;j<l;j++)\n\t\t{\n\t\t\tif(v[j]-v[i]!=2 && !f[v[j]-v[i]])\n\t\t\t{\n\t\t\t\tok[i].push_back(j);\n\t\t\t\tok[j].push_back(i);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<l;i++)\n\t{\n\t\tmemset(vis,false,sizeof(vis));\n\t\tif(bp(i))res++;\n\t}\n\tres/=2;\n\tprintf(\"%d\",res+((me-res)/2+(mo-res)/2)*2+((me-res)%2)*3);\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define fi first\n#define se second\n\nconst int N = 1001;\nconst int Q = 10000010;\n\nusing namespace std;\n\nint n;\nint a[N];\nint p[N];\nbitset < Q > d;\nvector < int > v[N];\nbool used[N];\n\nbool dfs(int x)\n{\n        if(used[x]){\n                return false;\n        }\n        used[x] = true;\n        for(int y: v[x]){\n                if(p[y] == -1 || dfs(p[y])){\n                        p[y] = x;\n                        return true;\n                }\n        }\n        return false;\n}\n\nint main()\n{\n        ios_base::sync_with_stdio(0);\n\n        //freopen(\"input.txt\", \"r\", stdin);\n        //freopen(\"output.txt\", \"w\", stdout);\n\n        for(int i = 2; i * i < Q; i++){\n                if(d[i]){\n                        continue;\n                }\n                for(int j = i * i; j < Q; j += i){\n                        d[j] = 1;\n                }\n        }\n        d[0] = d[1] = d[2] = 1;\n\n        cin >> n;\n        for(int i = 1; i <= n; i++){\n                cin >> a[i];\n        }\n        vector < int > b;\n        b.push_back(a[1]);\n        for(int i = 2; i <= n; i++){\n                if(a[i - 1] + 1 < a[i]){\n                        b.push_back(a[i - 1] + 1);\n                        b.push_back(a[i]);\n                }\n        }\n        b.push_back(a[n] + 1);\n\n        n = b.size();\n        vector < int > A;\n        vector < int > B;\n        for(int i = 0; i < n; i++){\n                p[i] = -1;\n                if(b[i] % 2){\n                        A.push_back(i);\n                } else{\n                        B.push_back(i);\n                }\n                for(int j = 0; j < n; j++){\n                        if(d[abs(b[i] - b[j])] == 0){\n                                v[i].push_back(j);\n                        }\n                }\n        }\n        int cnt = 0;\n        for(int x: A){\n                for(int i = 0; i < n; i++){\n                        used[i] = 0;\n                }\n                cnt += dfs(x);\n        }\n        int res = cnt;\n        res += (A.size() - cnt) / 2 * 2;\n        res += (B.size() - cnt) / 2 * 2;\n        if((A.size() - cnt) % 2 || (B.size() - cnt) % 2){\n                res += 3;\n        }\n        cout << res << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\n \nint n,x,ans,tmp,v[10000005];\nint a[505],cnt1,b[505],cnt2;\nint edge[505][505],r[505];\nbool pri[10000005],vis[505];\n \nvoid get_prime(int maxn){\n    memset(pri,true,sizeof(pri));\n    pri[0]=pri[1]=false;\n    for(int i=2;i<=maxn;i++){\n        if(!pri[i])continue;\n        for(int j=2;i*j<=maxn;j++){\n            pri[i*j]=false;\n        }\n    }\n}\n \nbool find(int x){\n    for(int i=1;i<=cnt2;i++)\n        if(edge[x][i]&&!vis[i]){\n            vis[i]=true;\n            if(!r[i]||find(r[i]))\n                return r[i]=x,true;\n        }\n    return false;\n}\n \nint main(){\n    scanf(\"%d\",&n);\n    int maxn=0;\n    for(int i=1;i<=n;i++){\n        scanf(\"%d\",&x);\n        maxn=max(maxn,x);\n        v[x]^=1,v[x+1]^=1;\n    }\n    for(int i=1;i<=maxn+1;i++)\n        if(v[i]){\n            if(i&1)a[++cnt1]=i;\n            else b[++cnt2]=i;\n        }\n    get_prime(maxn);\n    for(int i=1;i<=cnt1;i++)\n    for(int j=1;j<=cnt2;j++){\n        if(pri[abs(a[i]-b[j])])edge[i][j]=1;\n    }\n    for(int i=1;i<=cnt1;i++){\n        memset(vis,0,sizeof(vis));\n        if(find(i))tmp++;\n    }\n    ans+=tmp;\n    cnt1-=tmp,cnt2-=tmp;\n    ans+=2*(cnt1/2)+2*(cnt2/2);\n    if(cnt1&1)ans+=3;\n    printf(\"%d\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nint n, m, odd[209], even[209], lft[209], rgt[209];\nbool C[209];\nmap < int, bool > b;\nvector < int > v[209];\nconst int lim = 10000001;\nunsigned char cr[(lim + 10) >> 3];\n\nbool pairUp (int nod)\n{\n    if (C[nod]) return 0;\n    for (auto i : v[nod])\n        if (lft[i] == 0 || pairUp (lft[i]))\n        {\n            lft[i] = nod, rgt[nod] = i;\n            return 1;\n        }\n    return 0;\n}\n\nint maxMatch ()\n{\n    bool ok = 1;\n    while (ok)\n    {\n        ok = 0;\n        for (int i=1; i<=n; i++)\n            C[i] = 0;\n        for (int i=1; i<=n; i++)\n            if (rgt[i] == 0)\n                ok |= pairUp (i);\n    }\n    int ans = 0;\n    for (int i=1; i<=n; i++)\n        ans += (rgt[i] > 0);\n    return ans;\n}\n\nint main ()\n{\n//freopen (\"input\", \"r\", stdin);\n//freopen (\"output\", \"w\", stdout);\n\nint N;\nscanf (\"%d\", &N);\nfor (int i=1; i<=N; i++)\n{\n    int x;\n    scanf (\"%d\", &x);\n    b[x] ^= 1, b[x + 1] ^= 1;\n}\nfor (auto it : b)\n    if (it.second)\n    {\n        if (it.first & 1) odd[++n] = it.first;\n        else even[++m] = it.second;\n    }\nfor (int i=2; i * i<=lim; i++)\n    if (cr[i >> 3] & (1 << (i & 7))) ;\n    else\n    {\n        for (int j=i * i; j<=lim; j+=i)\n            cr[j >> 3] |= 1 << (j & 7);\n    }\nfor (int i=1; i<=n; i++)\n    for (int j=1; j<=m; j++)\n    {\n        int val = odd[i] - even[j];\n        if (val < 0) val = -val;\n        if (val == 1 || (cr[val >> 3] & (1 << (val & 7)))) ;\n        else v[i].push_back (j);\n    }\nint T1 = maxMatch ();\nn -= T1, m -= T1;\nint T3 = n & 1, T2 = (n + m - 2 * T3) >> 1;\nprintf (\"%d\\n\", T1 + 2 * T2 + 3 * T3);\nreturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 205;\nconst int MAXM = 10000005;\nint n, x[MAXN], f[MAXM], p[MAXM], cnt, match[MAXN], w[MAXN][MAXN];\nbool ip[MAXM];\nvoid pre(int N) {\n\tfor(int i = 2; i <= N; ++i) {\n\t\tif(!ip[i]) p[++cnt] = i;\n\t\tfor(int j = 1; j <= cnt && p[j]*i <= N; ++j) {\n\t\t\tip[p[j]*i] = 1;\n\t\t\tif(i % p[j] == 0) break;\n\t\t}\n\t}\n}\nbool vis[MAXN];\nbool dfs(int u) {\n\tfor(int v = 1; v <= n; ++v)\n\t\tif(w[u][v] && !vis[v]) {\n\t\t\tvis[v] = 1;\n\t\t\tif(!match[v] || dfs(match[v])) {\n\t\t\t\tmatch[v] = u;\n\t\t\t\tmatch[u] = v;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\treturn 0;\n}\nint maxmatch() {\n\tint re = 0;\n\tfor(int i = 1; i <= n; ++i)\n\t\tif(x[i]&1) {\n\t\t\tmemset(vis,0,sizeof vis);\n\t\t\tre += dfs(i);\n\t\t}\n\treturn re;\n}\nint main () {\n\tscanf(\"%d\", &n);\n\tfor(int i = 1,y; i <= n; ++i) scanf(\"%d\", &y), f[y] = 1;\n\tfor(int i = 10000001; i >= 1; --i) f[i] ^= f[i-1];\n\tn = 0;\n\tfor(int i = 1; i <= 10000001; ++i) if(f[i]) x[++n] = i;\n\tpre(x[n]); ip[2] = ip[1] = 1;\n\tfor(int i = 1; i <= n; ++i)\n\t\tfor(int j = i+1; j <= n; ++j)\n\t\t\tif(!ip[x[j]-x[i]])\n\t\t\t\tw[i][j] = w[j][i] = 1;\n\tint ans = maxmatch();\n\tint c1 = 0, c2 = 0;\n\tfor(int i = 1; i <= n; ++i)\n\t\tif(!match[i]) (x[i] & 1) ? ++c1 : ++c2;\n\tans += 2*(c1/2) + 2*(c2/2) + (c1&1)*3;\n\tprintf(\"%d\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define MX 205\n#define MP 10000005\nint x[MX];\nvector<int> v;\nvector<int> g[MX];\nbool vis[MX];\nint lnk[MX];\nbool f[MP] = {1, 1};\n\nint dfs(int u) {\n\tfor(auto v : g[u]) {\n\t\tif(vis[v]) continue;\n\t\tvis[v] = true;\n\t\tif(lnk[v] < 0 || dfs(lnk[v])) {\n\t\t\tlnk[v] = u;\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nint main() {\n\tfor(int i = 2; i < MP; i++) {\n\t\tif(f[i]) continue;\n\t\tfor(int j = i + i; j < MP; j += i) f[j] = 1;\n\t}\n\tint n; scanf(\"%d\", &n);\n\tfor(int i = 0; i < n; i++) scanf(\"%d\", x + i);\n\tfor(int i = 0; i < n; i++) {\n\t\tif(x[i] + 1 != x[i + 1]) v.push_back(x[i]);\n\t\tif(!i || x[i] - 1 != x[i - 1]) v.push_back(x[i] - 1);\n\t}\n\tfor(int i = 0; i < v.size(); i++)\n\t\tfor(int j = 0; j < v.size(); j++)\n\t\t\tif(!f[abs(v[i] - v[j])]) g[i].push_back(j);\n\tint res = 0;\nmemset(lnk, 0xff, sizeof lnk);\n\tfor(int i = 0; i < v.size(); i++) {\n\t\tif(v[i] & 1) continue;\n\t\tmemset(vis, 0, sizeof vis);\n\t\tres += dfs(i);\n\t}\n\tint c[2] = {0};\n\tfor(auto u : v) c[u & 1]++;\n\tc[0] -= res; c[1] -= res;\n\tres += c[0] / 2 * 2; res += c[1] / 2 * 2;\n\tc[0] &= 1; c[1] &= 1;\n\tif(c[0] || c[1]) res += 3;\n\tprintf(\"%d\\n\", res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<cmath>\n#include<vector>\n#include<queue>\n#include<map>\n#include<bitset>\n#include<set>\n#define N (200010)\n#define P ()\n#define M (11000010)\n#define inf (0x7f7f7f7f)\n#define rg register int\n#define Label puts(\"NAIVE\")\n#define spa print(' ')\n#define ent print('\\n')\n#define rand() (((rand())<<(15))^(rand()))\n#define file(s) freopen(s\".in\",\"r\",stdin),freopen(s\".out\",\"w\",stdout)\ntypedef long double ld;\ntypedef long long LL;\ntypedef unsigned long long ull;\nusing namespace std;\nnamespace fastIO1{\n\tinline char read(){\n\t\tstatic const int IN_LEN=1000000;\n\t\tstatic char buf[IN_LEN],*s,*t;\n\t\treturn (s==t?t=(s=buf)+fread(buf,1,IN_LEN,stdin),(s==t?-1:*s++):*s++);\n\t}\n\ttemplate<class T>\n\tinline void read(T &x){\n\t\tstatic bool iosig;\n\t\tstatic char c;\n\t\tfor(iosig=false,c=read();!isdigit(c);c=read()){\n\t\t\tif(c=='-')iosig=true;\n\t\t\tif(c==-1)return;\n\t\t}\n\t\tfor(x=0;isdigit(c);c=read())x=((x+(x<<2))<<1)+(c^'0');\n\t\tif(iosig)x=-x;\n\t}\n\tinline char readc(char &c){\n\t\tfor(c=read();!isalpha(c)&&!isdigit(c);c=read())\n\t\tif(c==-1)return 0;\n\t}\n\tconst int OUT_LEN = 10000000;\n\tchar obuf[OUT_LEN],*ooh=obuf;\n\tinline void print(char c) {\n\t\tif(ooh==obuf+OUT_LEN)fwrite(obuf,1,OUT_LEN,stdout),ooh=obuf;\n\t\t*ooh++=c;\n\t}\n\ttemplate<class T>\n\tinline void print(T x){\n\t\tstatic int buf[30],cnt;\n\t\tif(x==0)print('0');\n\t\telse{\n\t\t\tif(x<0)print('-'),x=-x;\n\t\t\tfor(cnt=0;x;x/=10)buf[++cnt]=x%10+48;\n\t\t\twhile(cnt)print((char)buf[cnt--]);\n\t\t}\n\t}\n\tinline void flush(){fwrite(obuf,1,ooh-obuf,stdout);}\n}\nnamespace fastIO2{\n\ttemplate<class T>\n\tinline void read(T &x){\n\t\tstatic bool iosig; \n\t\tstatic char c;\n\t\tfor(iosig=false,c=getchar();!isdigit(c);c=getchar()){\n\t\t\tif(c=='-')iosig=true;\n\t\t\tif(c==-1)return;\n\t\t}\n\t\tfor(x=0;isdigit(c);c=getchar())x=((x+(x<<2))<<1)+(c^'0');\n\t\tif(iosig)x=-x;\n\t}\n}\nusing namespace fastIO1;\nint n,a[M],prime[M],sum,cnt1,cnt2,od[N],ev[N];\nbool pr[M]; queue<int> Q; int dis[N],cur[N];\nint fi[N],ne[N<<4],to[N<<4],c[N<<4],S,T,V,E;\nbool bfs(int S,int T){\n\twhile(!Q.empty())Q.pop(); Q.push(S);\n\tfor(int i=1;i<=V;i++)dis[i]=inf,cur[i]=fi[i]; dis[S]=0;\n\twhile(!Q.empty()){\n\t\tint u=Q.front();Q.pop();\n\t\tfor(int i=fi[u];i;i=ne[i])\n\t\tif(c[i]&&dis[to[i]]==inf){\n\t\t\tint v=to[i];\n\t\t\tdis[v]=dis[u]+1;\n\t\t\tif(v==T)return 1; Q.push(v);\n\t\t}\n\t}\n\treturn dis[T]<=V;\n}\nint dfs(int u,int T,int flow){\n\tif(u==T)return flow;\n\tint usd=0;\n\tfor(int i=cur[u];i;i=cur[u]=ne[i])\n\tif(c[i]&&dis[to[i]]==dis[u]+1){\n\t\tint fl=dfs(to[i],T,min(flow-usd,c[i]));\n\t\tif(!fl)continue;c[i]-=fl,c[i^1]+=fl,usd+=fl;\n\t\tif(usd>=flow)return usd;\n\t}\n\treturn usd;\n}\nint dinic(int S,int T){\n\tint ans=0;\n\twhile(bfs(S,T))ans+=dfs(S,T,inf);\n\treturn ans;\t\n}\nvoid add(int x,int y,int z){\n\tne[++E]=fi[x],fi[x]=E,to[E]=y,c[E]=z;\n\tne[++E]=fi[y],fi[y]=E,to[E]=x,c[E]=0;\n}\nvoid Eular(int n){\n\tpr[1]=1;\n\tfor(int i=2;i<=n;i++){\n\t\tif(!pr[i]){\n\t\t\tprime[++sum]=i;\n\t\t\tif(i==2)pr[i]=1;\n\t\t}\n\t\tfor(int j=1;j<=sum;j++){\n\t\t\tif(prime[j]*i>n)break;\n\t\t\tpr[prime[j]*i]=1;if(i%prime[j]==0)break;\n\t\t}\n\t}\n}\nint main(){\n\tread(n),E=1;\n\tEular(10000010);\n\tfor(int i=1;i<=n;i++){\n\t\tint x; read(x);\n\t\ta[x]=1;\n\t}\n\tfor(int i=1;i<=10000001;i++)\n\tif(a[i]!=a[i-1]){if(i&1)od[++cnt1]=i;else ev[++cnt2]=i;}\n\tS=cnt1+cnt2+1,T=S+1,V=T;\n\tfor(int i=1;i<=cnt1;i++){\n\t\tadd(S,i,1);\n\t\tfor(int j=1;j<=cnt2;j++){\n\t\t\tint d=(int)abs(od[i]-ev[j]);\n\t\t\tif(!pr[d])add(i,j+cnt1,1);\n\t\t\tif(i==1)add(j+cnt1,T,1);\n\t\t}\n\t} \n\tint ans=dinic(S,T); cnt1-=ans,cnt2-=ans;\n\tcout<<ans+(cnt1/2)*2+(cnt2/2)*2+((cnt1&1)*3);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 410, INF = 0x3f3f3f3f;\nint n,p[N],x[N],cnt;\nstruct edge {\n  int la,b,cap,co;\n} con[N * N * 4];\nint tot=1,fir[N];\nvoid add(int from,int to,int capc,int cos) {\n  con[++tot] = (edge) {fir[from],to,capc,cos};\n  fir[from] = tot;\n  con[++tot] = (edge) {fir[to],from,0,-cos};\n  fir[to] = tot;\n}\nint st,en,ans,cur,vis[N],dis[N],inq[N];\nint dfs(int pos,int imp) {\n  if (pos == en || (!imp)) return ans += cur * imp, imp;\n  vis[pos] = 1;\n  int expo = 0, tmp;\n  for (int i = fir[pos] ; i ; i = con[i].la) {\n    if (dis[con[i].b] == dis[pos] + con[i].co && (!vis[con[i].b])) {\n      tmp = dfs(con[i].b,min(imp,con[i].cap));\n      con[i].cap -= tmp;\n      con[i^1].cap += tmp;\n      expo += tmp;\n      imp -= tmp;\n      if (!imp) break;\n    }\n  }\n  return expo;\n}\nbool spfa() {\n  static queue<int> q;\n  memset(dis,0x3f,sizeof dis);\n  while (!q.empty()) q.pop();\n  q.push(st);\n  dis[st] = 0;\n  inq[st] = 1;\n  for (int pos ; !q.empty() ; q.pop()) {\n    pos = q.front();\n    inq[pos] = 0;\n    for (int i = fir[pos] ; i ; i = con[i].la) {\n      if (con[i].cap && dis[con[i].b] > dis[pos] + con[i].co) {\n\tdis[con[i].b] = dis[pos] + con[i].co;\n\tif (!inq[con[i].b]) {\n\t  q.push(con[i].b);\n\t  inq[con[i].b] = 1;\n\t}\n      }\n    }\n  }\n  if (dis[en] == INF) return 0;\n  for (int pos = 1 ; pos <= n ; ++ pos) {\n    vis[pos] = 0;\n    for (int i = fir[pos] ; i ; i = con[i].la)\n      con[i].co += dis[pos] - dis[con[i].b];\n  }\n  cur += dis[en];\n  return 1;\n}\nconst int MAX = 10000010;\nint isp[MAX + 10], pri[MAX / 10], pcnt;\nset<int> prime;\nvoid prework() {\n  for (int i = 2 ; i <= MAX ; ++ i) {\n    if (!isp[i]) pri[++pcnt] = i;\n    for (int j = 1 ; j <= pcnt && pri[j] * i <= MAX ; ++ j) {\n      isp[pri[j] * i] = 1;\n      if (i % pri[j] == 0) break;\n    }\n  }\n  for (int i = 2 ; i <= pcnt ; ++ i)\n    prime.insert(pri[i]);\n}\nint main() {\n  prework();\n  scanf(\"%d\",&n);\n  for (int i = 1 ; i <= n ; ++ i) {\n    scanf(\"%d\",&x[i]);\n    if (x[i] == 1 || x[i] != x[i-1] + 1)\n      p[++cnt] = x[i];\n    if (i > 1 && x[i] != x[i-1] + 1)\n      p[++cnt] = x[i-1] + 1;\n  }\n  p[++cnt] = x[n] + 1;\n  n = cnt << 1;\n  st = ++n;\n  en = ++n;\n  for (int i = 1 ; i <= cnt ; ++ i) {\n    add(st,i,1,0);\n    for (int j = 1 ; j <= cnt ; ++ j) if (i != j) {\n      int d = abs(p[i] - p[j]), v;\n      if (prime.count(d)) v = 1;\n      else if (d&1) v = 3;\n      else v = 2;\n      add(i,j+cnt,1,v);\n    }\n    add(i+cnt,en,1,0);\n  }\n  while (spfa())\n    dfs(st,INF);\n  printf(\"%d\\n\",ans>>1);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstring>\n#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<queue>\n#include<stack>\n#include<cmath>\n#include<map>\n#include<complex>\n#define rep(i,l,r) for (int i=l;i<=r;i++)\n#define down(i,l,r) for (int i=l;i>=r;i--)\n#define clr(x,y) memset(x,y,sizeof(x))\n#define maxn 320500\n#define inf (int)1e9\n#define ll long long\n#define mm 1000000007\n#define eps 1e-13\n#define pb push_back\n#define low(x) x&(-x)\nusing namespace std;\n\nll read(){\n    ll x=0,f=1; char ch=getchar();\n    while (!isdigit(ch)) {if (ch=='-') f=-1; ch=getchar();}\n    while (isdigit(ch)){x=x*10+ch-'0'; ch=getchar();}\n    return x*f;\n}\nstruct data{int obj,pre,c,w;\n}e[600500];\nint head[805],dis[805],uu[805],cur[805],a[805],b[805];\nint mp[10000005],pmp[10000005],vis[10000005],pri[1000500];\nint ans,t,tot=1,n,m;\nvoid insert(int x,int y,int c,int w){\n    e[++tot].obj=y; e[tot].pre=head[x]; e[tot].c=c; e[tot].w=w; head[x]=tot;\n    e[++tot].obj=x; e[tot].pre=head[y]; e[tot].c=0; e[tot].w=-w; head[y]=tot;\n}\nbool spfa(){\n    clr(uu,0);\n    rep(i,0,t) dis[i]=inf; dis[0]=0;\n    queue<int> q; q.push(0);\n    while (!q.empty()){\n        int u=q.front(); q.pop(); uu[u]=1;\n        for (int j=head[u];j;j=e[j].pre){\n            int v=e[j].obj;\n            if (e[j].c>0&&dis[v]>dis[u]+e[j].w){\n                dis[v]=dis[u]+e[j].w;\n                if (uu[v]==0) uu[v]=1,q.push(v);\n            }\n        }\n        uu[u]=0;\n    }\n    if (dis[t]>=inf) return 0;\n    return 1;\n}\nint dfs(int x,int mx){\n    //if (uu[x]==1) return 0;\n    if (x==t||mx==0) return mx;\n    uu[x]=1;\n    int used=0;\n    for (int j=cur[x];j;j=e[j].pre){\n        int v=e[j].obj;\n        if (dis[v]==dis[x]+e[j].w&&e[j].c>0&&uu[v]==0){\n            int w=dfs(v,min(e[j].c,mx-used));\n            ans+=w*e[j].w; \n            e[j].c-=w; e[j^1].c+=w; used+=w;\n            cur[x]=j;\n            if (used==mx) return used;\n        }\n    }\n    return used;\n}\nint main(){\n//\tfreopen(\"input.txt\",\"r\",stdin);\n//\tfreopen(\"output.txt\",\"w\",stdout);\n\tn=read();\n\tint mxn=10000001;\n\trep(i,1,n) a[i]=read(),mp[a[i]]=1;\n\t//rep(i,1,n) if (mp[a[i]-1]==mp[a[i]]) b[i]=0; else b[i]=1;\n\trep(i,1,mxn) if (mp[i]!=mp[i-1]) b[++m]=i; \n\trep(i,2,mxn) {\n\t\tif (!vis[i]) pri[++tot]=i,vis[i]=1,pmp[i]=1;\n\t\trep(j,1,tot) {\n\t\t\tif (i*pri[j]>mxn) break;\n\t\t\tvis[i*pri[j]]=1;\n\t\t}\n\t}\n//\trep(i,1,m) printf(\"%d \",b[i]);\n\tt=2*m+1;\n\trep(i,1,m) insert(0,i,1,0),insert(i+m,t,1,0);\n\trep(i,1,m) rep(j,1,m) {\n\t\tif (i==j) continue;\n\t\tif ((abs(b[i]-b[j])&1)==0) insert(i,j+m,1,2);\n\t\tif (abs(b[i]-b[j])&1){\n\t\t\tif (pmp[abs(b[i]-b[j])]) insert(i,j+m,1,1);\n\t\t\telse insert(i,j+m,1,3);\n\t\t}\n\t}\n\twhile (spfa()){\n        clr(uu,0); rep(i,0,t) cur[i]=head[i];\n        dfs(0,inf);\n    }\n    printf(\"%d\\n\",ans/2);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<cmath>\nusing namespace std;\n#define N 11000000\n#define INF 0x3f3f3f3f\n#define M 7031004\nstruct node{\n\tint to,next,res;\n}q[M];\nint head[22003],ss,prm[N],dep[23104],ct,a[N],S,T,que[20310],h[20310],cir[20104];bool ip[N];\nvoid addedge(int x,int y,int r)\n{\n\tq[++ss]=(node){y,head[x],r};head[x]=ss;\n\tq[++ss]=(node){x,head[y],0};head[y]=ss;\n}\nbool bfs()\n{\n\tmemset(dep,0,sizeof(dep));\n\tmemcpy(cir,head,4*(T+10));\n\tdep[S]=1;\n\tint f=1,e=0;\n\tque[++e]=S;\n\twhile(f<=e)\n\t{\n\t\tint u=que[f++];\n\t\tfor (int j=head[u];~j;j=q[j].next)\n\t\t\tif (q[j].res&&!dep[q[j].to])\n\t\t\t{\n\t\t\t\tint t=q[j].to;\n\t\t\t\tdep[t]=dep[u]+1;\n\t\t\t\tque[++e]=t;\n\t\t\t}\n\t}\n\treturn dep[T]>0;\n}\nint dfs(int i,int flow)\n{\n\tif (i==T||!flow) return flow;\n\tint f,dist=0;\n\tfor (int &j=cir[i];~j;j=q[j].next)\n\t\tif (dep[q[j].to]==dep[i]+1&&q[j].res&&(f=dfs(q[j].to,min(q[j].res,flow-dist))))\n\t\t{\n\t\t\tdist+=f;\n\t\t\tq[j].res-=f;\n\t\t\tq[j^1].res+=f;\n\t\t}\n\treturn dist;\n}\nint dinic()\n{\n\tint ans=0;\n\twhile(bfs()) ans+=dfs(S,INF);\n\treturn ans;\n}\nint main()\n{\n\tint n,TT=1,c=0,ans=0,odd;\n\tip[1]=true;ip[0]=true;\n\tfor (int i=2;i<=10000000;++i)\n\t{\n\t\tif (!ip[i]) prm[++ct]=i;\n\t\tfor (int j=1,to;j<=ct&&(to=i*prm[j])<=10000000;++j)\n\t\t{\n\t\t\tip[to]=true;\n\t\t\tif (i%prm[j]==0) break;\n\t\t}\n\t}\n\tip[2]=true;\n\ta[0]=-INF;\n\twhile(TT--)\n\t{\n\t\tscanf(\"%d\",&n);c=0;ss=-1;odd=0;\n\t\tmemset(head,-1,sizeof(head));\n\t\tfor (int i=1;i<=n;++i)\n\t\t{\n\t\t\tscanf(\"%d\",&a[i]);\n\t\t\tif (a[i]!=a[i-1]+1) h[++c]=a[i];\n\t\t\th[a[i]==a[i-1]+1?c:++c]=a[i]+1;\n\t\t}\n\t\tT=c+1;\n\t\tfor (int i=1;i<=c;++i)\n\t\t\tif (h[i]&1)\n\t\t\t{\n\t\t\t\taddedge(S,i,1);++odd;\n\t\t\t\tfor (int j=1;j<=c;++j)\n\t\t\t\t{\n\t\t\t\t\tint dis=abs(h[j]-h[i]);\n\t\t\t\t\tif (!ip[dis]) addedge(i,j,1);\n\t\t\t\t}\n\t\t\t}else addedge(i,T,1);\n\t\tans=dinic();\n\t\tc-=odd;odd-=ans;\n\t\tprintf(\"%d\\n\",ans+(odd/2*2)+(c-ans)/2*2+(odd&1?3:0));\n\t}\n\treturn 0;\n}\n\n//by qlwpc"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nusing namespace std;\n\nconst int maxn=10000000;\n\nint prime[2000005];\nbool check[maxn+5];\n\nvoid pre() {\n  check[1]=1;\n  int tot=0;\n  for(int i=2;i<=maxn;i++) {\n  \tif (!check[i]) prime[++tot]=i;\n  \tfor(int j=1;j<=tot&&i*prime[j]<=maxn;j++) {\n  \t  check[i*prime[j]]=1;\n  \t  if (i%prime[j]==0) break;\n    }\n  }\n}\n\nbool in[maxn+5];\nint num1[105],num2[105],s1,s2;\nbool e[105][105];\n\nbool vis[105];\nint link[105];\n\nbool dfs(int x) {\n  for(int i=1;i<=s2;i++)\n    if (e[x][i]&&!vis[i]) {\n    \tvis[i]=1;\n    \tif (!link[i]||dfs(link[i])) {\n    \t\tlink[i]=x;\n    \t\treturn 1;\n\t\t}\n\t}\n  return 0;\n}\n\nint match() {\n  int ans=0;\n  for(int i=1;i<=s1;i++) {\n  \tmemset(vis,0,sizeof(vis));\n  \tans+=dfs(i);\n  }\n  return ans;\n}\n\nint main() {\n  pre();\n  int n;\n  scanf(\"%d\",&n);\n  for(int i=1;i<=n;i++) {\n  \tint x;\n  \tscanf(\"%d\",&x);\n  \tin[x]^=1;\n  }\n  for(int i=1;i<=maxn+2;i++)\n    if (in[i]!=in[i-1]) {\n    \tif (i&1) num1[++s1]=i;\n    \telse num2[++s2]=i;\n\t}\n  for(int i=1;i<=s1;i++)\n    for(int j=1;j<=s2;j++)\n      if (!check[abs(num1[i]-num2[j])]) e[i][j]=1;\n  int sum=match(); \n  printf(\"%d\\n\",sum+((s1-sum)>>1<<1)+((s2-sum)>>1<<1)+((s1-sum)&1)*3);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n ***\n Question Name:\n ***\n Question Link:\n \n ***\n Idea:\n */\n\n#include <memory.h>\n#include <iomanip>\n#include <algorithm>\n#include <iostream>\n#include <iterator>\n#include <numeric>\n#include <sstream>\n#include <fstream>\n#include <cassert>\n#include <climits>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n#include <cstdio>\n#include <vector>\n#include <cmath>\n#include <functional>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <list>\n#include <map>\n#include <set>\n#include <unordered_set>\n#include <unordered_map>\n\n#define REP(i,s,n) for(int (i)=s; (i)<(int)(n);(i)++)\n#define RIT(it,c) for(__typeof(c.begin()) it = c.begin();it!=c.end();it++)\n#define ALL(x) x.begin(), x.end()\n#define SZ(x) (int)(x).size()\n#define MSET(m,v) memset(m,v,sizeof(m))\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef long double LD;\ntypedef vector<int> vi;\ntypedef pair<int,int> ii;\ntypedef vector<LL> vL;\ntypedef vector<bool> vb;\ntypedef unordered_set<int> ui;\ntypedef pair<LL,LL> pLL;\n\nclass PrimeFlip{\n    int N = 1E7, n, m;\n    vi mapping;\n    vb vist;\n    vector<vb> E;\n    void init(){\n        int K;\n        cin>>K;\n        unordered_set<int> cnt;\n        vi odds,evens;\n        for(int i=0;i<K;++i){\n            int x;\n            cin>>x;\n            if(cnt.count(x)) cnt.erase(x);\n            else cnt.insert(x);\n            cnt.insert(x+1);\n        }\n        for(auto k:cnt){\n            if(k%2) odds.push_back(k);\n            else evens.push_back(k);\n        }\n        cnt.clear();\n        n = (int)odds.size();\n        m = (int)evens.size();\n        mapping = vi(m,-1);\n        vist = vb(m,false);\n        E = vector<vb>(n,vb(m, false));\n        vb prime(N+1,true);\n        prime[0] = prime[1] = false;\n        for(int i=2;i<=N;++i) if(prime[i]){\n            for(int j=2;j*i<=N;++j) prime[i*j] = false;\n        }\n        prime[2] = false;\n        for(int i=0;i<n;++i) for(int j=0;j<m;++j) E[i][j] =prime[abs(odds[i]-evens[j])];\n        prime.clear();\n    }\n    bool arange(int i){\n        for(int j=0;j<m;++j) if(E[i][j]){\n            vist[j] = true;\n            if(mapping[j]==-1 || arange(mapping[j])){\n                mapping[j] = i;\n                return true;\n            }\n        }\n        return false;\n    }\npublic:\n    void solve(){\n        init();\n        int cnt = 0;\n        for(int i=0;i<n;++i) cnt += arange(i);\n        int ans = cnt + ((n-cnt)/2 + (m-cnt)/2)*2 + ((m-cnt)%2)*3;\n        cout<<ans<<endl;\n    }\n};\n\n\n\nint main(){\n    PrimeFlip().solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <cmath>\n\nusing namespace std;\n\nconst int N=105,M=1e7+5;\n\ntypedef long long LL;\n\nint n,tot,p[M],f[N],vis[N],now,ans,s1,a[N],s2,b[N],cnt;\n\nbool bz[M],Bit[M],g[N][N],u1[N],u2[N];\n\nbool Check(int x)\n{\n\tif (vis[x]==now) return 0;\n\tvis[x]=now;\n\tfor (int i=1;i<=s2;i++) if (g[x][i])\n\t{\n\t\tif (!f[i] || Check(f[i]))\n\t\t{\n\t\t\tf[i]=x; return 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nint main()\n{\n\tbz[1]=1;\n\tfor (int i=2;i<M;i++)\n\t{\n\t\tif (!bz[i]) p[tot++]=i;\n\t\tfor (int j=0;j<tot && i*p[j]<M;j++)\n\t\t{\n\t\t\tbz[i*p[j]]=1;\n\t\t\tif (i%p[j]==0) break;\n\t\t}\n\t}\n\tscanf(\"%d\",&n);\n\tfor (int x,i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%d\",&x);\n\t\tBit[x]^=1;\n\t}\n\tfor (int i=1;i<M;i++) if (Bit[i]^Bit[i-1])\n\t{\n\t\tif (i&1) a[++s1]=i;else b[++s2]=i;\n\t}\n\tfor (int i=1;i<=s1;i++) for (int j=1;j<=s2;j++) if (!bz[abs(a[i]-b[j])]) g[i][j]=1;\n\tfor (now=1;now<=s1;now++) ans+=Check(now);\n\tfor (int i=1;i<=s2;i++) if (f[i]) u1[f[i]]=u2[i]=1;\n\tfor (int i=1;i<=s1;i++) if (!u1[i]) cnt++;\n\tans+=(cnt/2)*2;\n\tcnt=0;\n\tfor (int i=1;i<=s2;i++) if (!u2[i]) cnt++;\n\tans+=(cnt/2)*2;\n\tif (cnt&1) ans+=3;\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define pb push_back\n#define x first\n#define y second\nusing namespace std;\ntypedef long long LL;\ntypedef vector<int> VI;\nusing namespace std;\nconst int NMAX=406;\nconst int INF=1000000666;\nconst LL INFLL=1000000000000666;\nconst LL maxv=100000;\nconst long double PI = acos(-1.0);\nconst int MAXT = 200000;\n\nint A[1005];\nint n;\n\nint l[NMAX], r[NMAX];\nvector<int> G[NMAX];\nbool viz[NMAX];\nint lf,rs;\n \nbool dfs(int v)\n{\n    if(viz[v])\n        return 0;\n    viz[v]=1;\n    for(auto w:G[v])\n        if(l[w] == 0 || dfs(l[w]))\n        {\n            l[w]=v;\n            r[v]=w;\n            return 1;\n        }\n    return 0;\n}\n\n\nbool isprime(int x){\n  int i = 2;\n  int q = 1;\n  if(x == 1){\n    q = 0;\n  }\n  while(i*i <= x){\n    if((x%i) == 0){\n      q=0; \n    }\n    i++;\n  }\n  return q;\n}\n\nvoid solve(){\n  cin>>n;\n  for(int i=1; i<=n; ++i){\n    cin>>A[i];\n  }\n  vector<int> df;\n  for(int i=1; i<=n; ++i){\n    if(A[i] - A[i-1] > 1 || i==1){\n      df.push_back(A[i]);\n    }\n    if(A[i+1] - A[i] > 1 || i==n){\n      df.push_back(A[i] + 1);\n    }\n  }\n  //sort(df.begin(), df.end());\n  vector<int> lft, rht;\n\n  for(auto el: df){\n    //cout<<el<<\" \";\n    if(el % 2){\n      rht.push_back(el);\n    }\n    else{\n      lft.push_back(el);\n    }\n  }\n  lf = lft.size();\n  for(int i=0; i<lft.size(); ++i){\n    for(int j=0; j<rht.size(); ++j){\n      if(isprime(abs(lft[i] - rht[j])))\n      {\n        G[i+1].push_back(j+lf+1);\n      }\n    }\n  }\n  bool q=1;\n  while(q)\n  {\n      q=0;\n      memset(viz, 0, sizeof(viz));\n      for(int i=1; i<=lf; ++i)\n      {\n          if(r[i]==0 && dfs(i))\n          {\n              q=1;\n              rs++;\n          }\n      }\n  }\n  int a = lf - rs, b = rht.size() - rs;\n  cout<<2*(a/2) + 2*(b/2) + 3*(a%2)<<\"\\n\";\n  \n\n}\n\n\nint main()\n{\n    // Tic\n    //clock_t t=clock();\n    cout<<setprecision(10)<<fixed;\n    ios_base::sync_with_stdio(0);\n\n    //freopen(\"simetrii.in\", \"rt\", stdin);\n    //freopen(\"simetrii.out\", \"wt\", stdout);\n\n    solve();\n\n    //Toc\n    //t=clock()-t;\n    //printf (\"It took me %d clicks (%f seconds).\\n\",t,((float)t)/CLOCKS_PER_SEC);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//\n//  main.cpp\n//  F - Prime Flip\n//\n//  Created by Jędrzej Dudzicz on 04/02/2019.\n//  Copyright © 2019 Jędrzej Dudzicz. All rights reserved.\n//\n\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <algorithm>\n#include <cstdio>\n#include <utility>\nusing namespace std;\nconst int MXN=205;\nconst int MXM=1e7+5;\nint n,x;\nint s[MXM],s1[MXN];\nbool sito[MXM];\nint tab1[2*MXN],h;\nbool odw[2*MXN];\nint wynik;\nint main(){\n    for(int i=2;i*i<=MXM-1;i++){\n        if(sito[i]==0){\n            for(int j=i*i;j<=MXM-1;j+=i){\n                if(sito[j]==0)sito[j]=1;\n            }\n        }\n    }\n    sito[0]=1;\n    sito[1]=1;\n    sito[2]=1;\n    scanf(\"%d\",&n);\n    for(int i=0;i<n;i++){\n        scanf(\"%d\",&x);\n        s[x]=1;\n    }\n    for(int i=1;i<=10000001;i++){\n        if(s[i]!=s[i-1]){\n            s1[i]=1;\n            tab1[h++]=i;\n        }\n    }\n    for(int i=0;i<h;i++){\n        if(odw[i]==0){\n            for(int j=0;j<h;j++){\n                if(i!=j&&odw[j]==0&&abs(tab1[j]-tab1[i])>2&&sito[abs(tab1[j]-tab1[i])]==0){\n                    wynik++;\n                    odw[i]=1;odw[j]=1;\n                }\n            }\n        }\n    }\n    for(int i=0;i<h;i++){\n        if(odw[i]==0){\n            for(int j=0;j<h;j++){\n                if(i!=j&&odw[j]==0&&abs(tab1[j]-tab1[i])%2==0){\n                    wynik+=2;\n                    odw[i]=1;odw[j]=1;\n                }\n            }\n        }\n    }\n    for(int i=0;i<h;i++){\n        if(odw[i]==0){\n            for(int j=0;j<h;j++){\n                if(i!=j&&odw[j]==0&&abs(tab1[j]-tab1[i])%2==1){\n                    wynik+=3;\n                    odw[i]=1;odw[j]=1;\n                }\n            }\n        }\n    }\n    for(int i=0;i<h;i++){\n        if(odw[i]==0){\n            odw[i]=1;\n            wynik+=3;\n        }\n    }\n    printf(\"%d\\n\",wynik);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <climits>\n#include <algorithm>\n\nusing std::min;\nusing std::max;\n\nconst int MAXX=1e7+5,MAXN=105;\nint n,cnt;\nint x_id[MAXN],y_id[MAXN],G[MAXN][MAXN],lx[MAXN],ly[MAXN],slack[MAXN],match[MAXN];\nbool up[MAXX],vis_x[MAXN],vis_y[MAXN];\n\ninline bool is_odd_prm(int x){\n\tfor(int i=3;i*i<=x;i+=2){\n\t\tif(x%i==0) return false;\n\t}\n\treturn true;\n}\n\ninline bool find_path(int x){\n\tvis_x[x]=true;\n\tfor(int y=1,dta;y<=cnt;++y){\n\t\tif(vis_y[y] || G[x][y]==0x7f) continue;\n\t\tdta=lx[x]-ly[y]-G[x][y];\n\t\tif(dta==0){\n\t\t\tvis_y[y]=true;\n\t\t\tif(!match[y] || find_path(match[y])){\n\t\t\t\tmatch[y]=x;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\telse slack[y]=min(slack[y],dta);\n\t}\n\treturn false;\n}\n\ninline int KM(){\n\tfor(int x=1;x<=cnt;++x){\n\t\tlx[x]=INT_MIN;\n\t\tfor(int y=1;y<=cnt;++y){\n\t\t\tif(G[x][y]<0x7f)\n\t\t\t\tlx[x]=max(lx[x],G[x][y]);\n\t\t}\n\t}\n\tfor(int nowx=1,dta;nowx<=cnt;++nowx){\n\t\tmemset(slack,0x7f,sizeof(slack));\n\t\twhile(true){\n\t\t\tmemset(vis_x,false,sizeof(vis_x));\n\t\t\tmemset(vis_y,false,sizeof(vis_y));\n\t\t\tif(find_path(nowx)) break;\n\t\t\telse{\n\t\t\t\tdta=INT_MAX;\n\t\t\t\tfor(int y=1;y<=cnt;++y){\n\t\t\t\t\tif(!vis_y[y]) dta=min(dta,slack[y]);\n\t\t\t\t}\n\t\t\t\tfor(int tmpx=1;tmpx<=cnt;++tmpx){\n\t\t\t\t\tif(vis_x[tmpx]) lx[tmpx]-=dta;\n\t\t\t\t}\n\t\t\t\tfor(int y=1;y<=cnt;++y){\n\t\t\t\t\tif(vis_y[y]) ly[y]+=dta;\n\t\t\t\t\telse slack[y]-=dta;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint ret=0;\n\tfor(int y=1;y<=cnt;++y){\n\t\tif(match[y]) ret+=G[match[y]][y];\n\t}\n\treturn ret;\n}\n\nint main(){\n\tscanf(\"%d\",&n);\n\tint x;\n\tfor(int i=1;i<=n;++i){\n\t\tscanf(\"%d\",&x);\n\t\tup[x]=true;\n\t}\n\tfor(int i=1;i<=x+1;++i){\n\t\tif(up[i]!=up[i-1])\n\t\t\t++cnt&1 ? x_id[(cnt+1)>>1]=i:y_id[(cnt+1)>>1]=i;\n\t}\n\tcnt>>=1;\n\tmemset(G,0x7f,sizeof(G));\n\tfor(int i=1;i<=cnt;++i){\n\t\tfor(int j=1,dta;j<=cnt;++j){\n\t\t\tdta=abs(x_id[i]-y_id[j]);\n\t\t\tif((dta&1)==0) G[i][j]=2;\n\t\t\telse if(is_odd_prm(dta)) G[i][j]=1;\n\t\t\telse G[i][j]=3;\n\t\t}\n\t}\n\tprintf(\"%d\",KM());\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define maxn 300\n#define maxm 100100\nusing namespace std;\nstruct edge{\n    int r,nxt,w;\n}e[maxm];\nint head[maxn],esz,S,T,dep[maxn],q[maxn],ql,qr,cur[maxn];\nvoid addedge(int u,int v,int w){\n    e[esz].r=v;\n    e[esz].nxt=head[u];\n    e[esz].w=w;\n    head[u]=esz++;\n    e[esz].r=u;\n    e[esz].nxt=head[v];\n    e[esz].w=0;\n    head[v]=esz++;\n}\nbool bfs(){\n    ql=qr=0;\n    q[qr++]=S;\n//\tprintf(\"[ok,%d,%d]\",S,T);\n    for(int i=S;i<=T;++i)dep[i]=0,cur[i]=head[i];\n    dep[S]=1;\n    while(ql<qr){\n        int x=q[ql++];\n        for(int t=head[x];t;t=e[t].nxt)if(!dep[e[t].r]&&e[t].w)\n            dep[e[t].r]=dep[x]+1,q[qr++]=e[t].r;\n    }\n    \n    return dep[T]!=0;\n}\nint find(int u,int flow){\n    if(u==T)return flow;\n    int a=0,used=0;\n    for(int& t=cur[u];t;t=e[t].nxt)if(e[t].w&&dep[e[t].r]==dep[u]+1&&(a=find(e[t].r,min(flow-used,e[t].w)))){\n        e[t].w-=a;e[t^1].w+=a,used+=a;\n        if(used==flow)return used;\n           \n    }\n    if(!used)dep[u]=0;\n    return used;\n}\nint dinic(){\n\tint ans=0,a=0;\n\twhile(bfs())\n\t\twhile(a=find(S,1<<30))ans+=a;\n\treturn ans;\n}\nconst int lim=10000010;\nint pri[lim],psz,n,a[maxn],tp,d[2];\nbool vis[lim],c[lim];\nint main(){\n\tfor(int i=2;i<lim;++i){\n\t\tif(!vis[i])pri[++psz]=i;\n\t\tfor(int j=1;j<=psz&&pri[j]*i<lim;++j){\n\t\t\tvis[i*pri[j]]=1;if(i%pri[j]==0)break;\n\t\t}\n\t}\n\tscanf(\"%d\",&n);\n\tfor(int i=1,x;i<=n;++i)scanf(\"%d\",&x),c[x]^=1,c[x+1]^=1;\n\tfor(int i=1;i<lim;++i)if(c[i])a[++tp]=i;\n\tS=0,T=tp+1,vis[2]=0;\n\tfor(int i=1;i<=tp;++i)\n\t\tfor(int j=i+1;j<=tp;++j)if((a[i]&1)!=(a[j]&1)){\n//\t\t\tprintf(\"{%d,%d}\",a[i],a[j]);\n\t\t\tif(!vis[a[j]-a[i]]){\n\t\t\t\tif(a[i]&1)addedge(i,j,1);\n\t\t\t\telse addedge(j,i,1);\n\t\t\t}\n\t\t}\n\tfor(int i=1;i<=tp;++i)if(a[i]&1)addedge(S,i,1);else addedge(i,T,1);\n\tint ans=dinic();\n\tfor(int i=1;i<=tp;++i)d[a[i]&1]++;\n\td[0]-=ans,d[1]-=ans;\n\tif(d[0]%2)ans+=3,d[0]--,d[1]--;\n\tans+=d[0]+d[1];\n\tprintf(\"%d\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "//#pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"Ofast,no-stack-protector\") \n//#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//#pragma GCC optimize(\"unroll-loops\")\n\n#include <bits/stdc++.h>\n\n#define int long long\n#define ll long long\n#define ull unsigned long long\n#define ld long double\n#define rep(i, l, r) for (int i = l; i < r; i++)\n#define repb(i, r, l) for (int i = r; i > l; i--)\n#define sz(a) (int)a.size()\n#define fi first\n#define se second\n#define all(x) x.begin(),x.end()\n#define pb push_back\n#define mp(a, b) make_pair(a, b)\n#define ret(a) {cout << a; exit(0);}\n\nusing namespace std;\n\nmt19937 mrand(random_device{}()); \nconst ll mod=1000000007;\nint rnd(int x) { return mrand() % x;}\nll powmod(ll a,ll b,ll mod) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\n\ntypedef pair < int , int > pii ;\ntypedef pair < long long  , long long > pll ;\n\nconst int N = 200 , K = 501;\nint n , m , k;\nint x[N];\nbool was[N] ;\nint mt[N];\nvector < int > gr[N];\nbool pr(int x){\n\tif(x <= 2)\n\t\treturn false;\n\tfor(int i = 2 ; i * i <= n; i++)\n\t\tif(n % i == 0)\t\n\t\t\treturn false;\n\treturn true;\n}\nbool kuhn(int v){\n\tif(was[v])return false;\n\twas[v] = 1;\n\tfor(auto to : gr[v])\n\t\tif(mt[to] == -1 or kuhn(mt[to])){\n\t\t\tmt[to] = v;\n\t\t\treturn true;\n\t\t}\n\treturn false;\n}\nmain(){\n\tios::sync_with_stdio(0); cin.tie(0);cout.tie(0);\n\tcin >> n;\n\tfor(int i = 1;i <= n; i++){\n\t\tcin >> x[i];\n\t}\n\tvector < int > v;\n\tx[0] = -1;\n\tfor(int i = 1 ;i <= n ; i++){\n\t\tif(x[i] != x[i - 1] + 1)\n\t\t\tv.pb(x[i]) ;\n\t\tif(x[i + 1] != x[i] + 1)\n\t\t\tv.pb(x[i] + 1);\t\t\t\n\t}\n/*\tfor(int i = 1; i <= 6 ; i++)\n\t\tcout << tmp[i];\n\tcout << endl;*/\n\tint cnt0 = 0 , cnt1 = 0;\n\tfor(auto i : v)\n\t\tcnt0 += i % 2 == 0,\n\t\tcnt1 += i % 2 == 1;\t\t\n\tfor(int i = 0 ; i < sz(v); i++){\n\t\tfor(int j = i + 1 ; j < sz(v); j++){\n\t\t\tif(pr(v[j] - v[i]))\n\t\t\t\tgr[i].pb(j) , gr[j].pb(i);\n\t\t}\n\t}\t\n\tfor(int i = 0 ;i < sz(v); i++)\n\t\tmt[i] = -1;\n\tfor(int i = 0 ; i < sz(v) ;i++){\n\t\tmemset(was , 0, sizeof(was));\n\t\tkuhn(i);\n\t}\n\tint tot = 0, d0 = 0 , d1 = 0;\n\tfor(int i = 0; i < sz(v) ; i++){\n\t\tif(mt[i] != -1)\n\t\t\ttot++,d0 += i % 2 == 0 , d1 += i % 2 == 1;\n\t}\n\ttot /= 2;\n\tcout << tot + ((cnt0 - tot)/2 + (cnt1 - tot)/2) * 2 + ((cnt1 - tot)%2)%2 * 3;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define For(i, j, k) for(int i = j; i <= k; ++i)\nusing namespace std;\n\ninline int read() {\n\tint x = 0, p = 1; char c = getchar();\n\twhile(!isdigit(c)) { if(c == '-') p = -1; c = getchar(); }\n\twhile(isdigit(c)) x = (x << 1) + (x << 3) + (c ^ 48), c = getchar();\n\treturn x *= p;\n}\n\ninline void File() {\n#ifndef ONLINE_JUDGE\n\tfreopen(\"magic.in\", \"r\", stdin);\n\tfreopen(\"magic.out\", \"w\", stdout);\n#endif\n}\n\nconst int N = 2e2 + 10, M = 1e7 + 10;\nint prime[M], isnot[M], cnt, S[M], x;\nint n, A[N], B[N], cnt1, cnt2, G[N][N];\nint match[N], vis[N];\n\ninline void Init(int n) {\n\tisnot[1] = 1;\n\tFor(i, 2, n) {\n\t\tif(!isnot[i]) prime[++cnt] = i;\n\t\tFor(j, 1, cnt) {\n\t\t\tif(1ll * i * prime[j] > n) break;\n\t\t\tisnot[i * prime[j]] = 1;\n\t\t\tif(i % prime[j] == 0) break;\n\t\t}\n\t}\n}\n\ninline bool dfs(int x) {\n\tFor(i, 1, cnt2)\t{\n\t\tif(G[x][i] && !vis[i]) {\n\t\t\tvis[i] = 1;\n\t\t\tif(match[i] == -1 || dfs(match[i])) {\n\t\t\t\tmatch[i] = x;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\nint main() {\n\tInit(M - 5);\n\tn = read();\n\tFor(i, 1, n) S[(x = read())] ^= 1;\n\t\n\tFor(i, 1, M - 5) if(S[i] != S[i - 1]) {\n\t\tif(i & 1) A[++cnt1] = i;\n\t\telse B[++cnt2] = i;\n\t}\n\tFor(i, 1, cnt1) For(j, 1, cnt2) \n\t\tif(!isnot[abs(A[i] - B[j])] && abs(A[i] - B[j]) != 2) G[i][j] = 1;\t\n\n\tmemset(match, -1, sizeof match);\n\tint res = 0, ans;\n\tFor(i, 1, cnt1) {\n\t\tmemset(vis, 0, sizeof vis);\n\t\tif(dfs(i)) ++ res;\n\t}\n\n\tans = res + (cnt1 - res >> 1) * 2 + (cnt2 - res >> 1) * 2;\n\tif(cnt1 - res & 1) ans += 3;\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cstdlib>\nusing namespace std;\n\n#define re_ return\n#define in_ inline\n#define op_ operator\n#define inc(l, i, r) for(i=l; i<r; ++i)\n#define st_ static\ntypedef long long ll;\n\nconst int mxn=1<<7;\n\nint n, m, a[mxn], b[mxn<<1], cnt[2], h[mxn<<1];\nstruct edge{int v, o;} e[mxn<<2];\n\nin_ ll dP(ll a, ll b, ll p)\n{\n    st_ ll r;\n    for(r=1; b; a=a*a%p, b>>=1)\n        b&1? r=r*a%p: 0;\n    re_ r;\n}\n\nin_ char chk(ll a, ll p)\n{\n    st_ ll s, r, i;\n    for(r=p-1, s=0; ~r&1; ++s, r/=2);\n    if(i=dP(a, r, p), i==1 || i==p-1) re_ 1;\n    for(;s--;)\n        if((i=i*i%p)==p-1) re_ 1;\n    re_ 0;\n}\n\nin_ char isP(int p)\n{\n    st_  int i;\n    inc(0, i, 32)\n        if(!chk(rand()%(p-2)+1, p))\n            re_ 0;\n    re_ 1;\n}\n\nin_ void aE(int u, int v)\n{\n    st_ int tot;\n    e[++tot]=(edge){v, h[u]}, u[h]=tot;\n}\n\nchar Hun(int u)\n{\n    st_ int f[mxn<<1], vis[mxn<<1];\n    int i, v;\n    if(vis[u]) re_ 0; vis[u]=1;\n    for(i=u[h]; v=i[e].v; i=i[e].o)\n        if(!f[v] || Hun(f[v]))\n            re_ f[v]=u, vis[u]=0, 1;\n    re_ vis[u]=0;\n}\n\nint main()\n{\n    srand(998244353);\n    int i, j;\n    scanf(\"%d\", &n);\n    inc(0, i, n)\n        scanf(\"%d\", a+i);\n    inc(0, i, n)\n    {\n        if(!i || a[i]>a[i-1]+1)\n            b[++m]=a[i], ++cnt[a[i]&1];\n        if(i>n-2 || a[i]<a[i+1]-1)\n            b[++m]=a[i]+1, ++cnt[a[i]+1&1];\n    }\n    inc(1, i, m+1)\n        if(b[i]&1)\n            inc(1, j, m+1)\n                if(~b[i]&1 && isP(b[i]-b[j]))\n                    aE(i, j);\n\n    j=0;\n    inc(1, i, m+1)\n        if(b[i]&1)\n            j+=Hun(i);\n\n    printf(\"%d\\n\", j+(cnt[0]-j&~1)+(cnt[1]-j&~1)+(cnt[0]-j&1? 3:0));\n    re_ 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define yabs(x) ((x<0)?(-(x)):(x))\n\nconst int N=1e7+5,Node=210;\n\nstruct Edge{ int to,next; }way[Node*Node];\nint n,x[Node],prime[N],cntprime,tot,num[Node],put[Node];\nbool v[N],notprime[N],use[Node];\n\nvoid Build(int a,int b) { way[++tot]=(Edge){b,num[a]}; num[a]=tot; }\n\nvoid AddEdge(int a,int b) { Build(a,b); Build(b,a); }\n\nvoid Init() {\n\tscanf(\"%d\",&n);\n\tint x;\n\tfor (int i=1;i<=n;++i) scanf(\"%d\",&x),v[x]=1;\n}\n\nvoid Euler() {\n\tnotprime[1]=1;\n\tfor (int i=2;i<=10000000;++i) {\n\t\tif (!notprime[i]) prime[++cntprime]=i;\n\t\tfor (int j=1;j<=cntprime && 1ll*i*prime[j]<=10000000;++j) {\n\t\t\tnotprime[i*prime[j]]=1;\n\t\t\tif (!(i%prime[j])) break;\n\t\t}\n\t}\n}\n\nbool Dfs(int x) {\n\tfor (int i=num[x];i;i=way[i].next) {\n\t\tint v=way[i].to;\n\t\tif (!use[v]) {\n\t\t\tuse[v]=1;\n\t\t\tif (put[v]==-1 || Dfs(put[v])) {\n\t\t\t\tput[v]=x;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nvoid Solve() {\n\tEuler();\n\tint top=0,cnt1=0,cnt0=0;\n\tv[0]=0;\n\tfor (int i=1;i<=10000001;++i) {\n\t\tbool fl=(v[i]!=v[i-1]);\n\t\tif (fl) x[++top]=i,cnt1+=i&1;\n\t}\n\tcnt0=top-cnt1;\n\tfor (int i=1;i<=top;++i) if (x[i]&1) {\n\t\tfor (int j=1;j<=top;++j) if (!(x[j]&1)) {\n\t\t\tif (!notprime[yabs(x[j]-x[i])]) {\n\t\t\t\tAddEdge(i,j);\n\t\t\t}\n\t\t}\n\t}\n\tint ans=0;\n\tfor (int i=1;i<=top;++i) put[i]=-1;\n\tfor (int i=1;i<=top;++i) if (x[i]&1) {\n\t\tmemset(use,0,sizeof(use));\n\t\tif (Dfs(i)) ans++;\n\t}\n\tprintf(\"%d\\n\",ans+(cnt0-ans)/2*2+(cnt1-ans)/2*2+(cnt0-ans)%2*3);\n}\n\nint main() {\n\tInit();\n\tSolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N = 5010, M = 1e7+6;\nint prime[M],pcnt,_v[M];\nint k,x[N];\ninline void sieve(int n = 1e7){\n\t_v[1]=1;\n\tfor(int i=2;i<=n;i++){\n\t\tif(!_v[i])prime[++pcnt]=i;\n\t\tfor(int j=1;j<=pcnt&&1ll*i*prime[j]<=n;j++){\n\t\t\t_v[i*prime[j]]=1;\n\t\t\tif(i%prime[j]==0)break;\n\t\t}\n\t}\n}\nint id1[N],id2[N],cnt1,cnt2;\nint match[N];\nbool vis[N];\nvector<int> g[N];\n\ninline void adde(int u,int v){\n\tg[u].push_back(v);\n}\n\ninline bool dfs(int x){\n\tfor(size_t i=0;i<g[x].size();i++){\n\t\tint v=g[x][i];\n\t\tif(!vis[v]){\n\t\t\tvis[v]=1;\n\t\t\tif(!match[v]||dfs(match[v])){\n\t\t\t\tmatch[v]=i;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint main()\n{\n//\tfreopen(\"oatmeal.in\",\"r\",stdin);\n//\tfreopen(\"oatmeal.out\",\"w\",stdout);\n\tsieve();\n\tcin >> k;\n\tfor(int i=1;i<=k;i++){\n\t\tscanf(\"%d\",&x[i]);\n\t}\n\tsort(x+1,x+k+1);\n\tfor(int u=1,v;u<=k;u=v+1){\n\t\tv=u;\n\t\twhile(v+1<=k&&x[v+1]==x[v]+1)++v;\n\t\tif(x[u]%2)id1[++cnt1]=x[u];\n\t\telse id2[++cnt2]=x[u];\n\t\tif((x[v]+1)%2)id1[++cnt1]=x[v]+1;\n\t\telse id2[++cnt2]=x[v]+1;\n\t}\n\tfor(int i=1;i<=cnt1;i++)for(int j=1;j<=cnt2;j++){\n\t\tif(!_v[abs(id1[i]-id2[j])]){\n\t\t\tadde(i,j);\n\t\t\t// cout << \"?\" << endl;\n\t\t}\n\t}\n\t// cout << cnt << endl;\n\tint ans=0;\n\tfor(int i=1;i<=cnt1;i++){\n\t\tfor(int j=1;j<N;j++)vis[j]=0;\n\t\tif(dfs(i))ans++;\n\t}\n\t// cout << cnt1 << \" \" << cnt2 << \" \" << ans << endl;\n\tcnt1-=ans,cnt2-=ans;\n\tif(cnt1%2==0){\n\t\tcout << cnt1+cnt2+ans << endl;\n\t}else{\n\t\tcout << cnt1+cnt2+ans+1 << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include\"bits/stdc++.h\"\n\n\n#define PB push_back\n#define PF push_front\n#define LB lower_bound\n#define UB upper_bound\n#define fr(x) freopen(x,\"r\",stdin)\n#define fw(x) freopen(x,\"w\",stdout)\n#define iout(x) printf(\"%d\\n\",x)\n#define lout(x) printf(\"%lld\\n\",x)\n#define REP(x,l,u) for(ll x = (l);x<=(u);x++)\n#define RREP(x,l,u) for(ll x = (l);x>=(u);x--)\n#define mst(x,a) memset(x,a,sizeof(x))\n#define PII pair<int,int>\n#define PLL pair<ll,ll>\n#define MP make_pair\n#define se second\n#define fi first\n#define dbg(x) cout<<#x<<\" = \"<<(x)<<endl;\n#define sz(x) ((int)x.size())\n#define cl(x) x.clear()\n\ntypedef  long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ld;\nusing namespace std;\n\nconst int maxn = 210;\nconst int mod = 1e9+7;\nconst int MAX = 0x7f7f7f7f;\nconst double eps = 1e-6;\nconst double PI = acos(-1);\n\ntemplate<typename T> inline void read(T &x){\nx=0;T f=1;char ch;do{ch=getchar();if(ch=='-')f=-1;}while(ch<'0'||ch>'9');do x=x*10+ch-'0',ch=getchar();while(ch<='9'&&ch>='0');x*=f;\n}\n\ntemplate<typename A,typename B> inline void read(A&x,B&y){read(x);read(y);}\ntemplate<typename A,typename B,typename C> inline void read(A&x,B&y,C&z){read(x);read(y);read(z);}\ntemplate<typename A,typename B,typename C,typename D> inline void read(A&x,B&y,C&z,D&w){read(x);read(y);read(z);read(w);}\ntemplate<typename A,typename B> inline A fexp(A x,B p){A ans=1;for(;p;p>>=1,x=1LL*x*x%mod)if(p&1)ans=1LL*ans*x%mod;return ans;}\ntemplate<typename A,typename B> inline A fexp(A x,B p,A mo){A ans=1;for(;p;p>>=1,x=1LL*x*x%mo)if(p&1)ans=1LL*ans*x%mo;return ans;}\n\nint n,m,Odd;\n\nint A[maxn],B[maxn];\n\nstruct Edge{\n\tint to,cap;\n\tEdge *next,*oppo;\n};\nEdge *E[maxn],Pr[maxn*maxn<<2];int cnt=0;\nvoid addedge(int u,int v,int cap){\n\tPr[++cnt].to=v;Pr[cnt].cap=cap;Pr[cnt].oppo=&Pr[cnt+1];Pr[cnt].next=E[u];E[u]=&Pr[cnt];\n\tPr[++cnt].to=u;Pr[cnt].cap=0;  Pr[cnt].oppo=&Pr[cnt-1];Pr[cnt].next=E[v];E[v]=&Pr[cnt];\n}\n\nint s,t;\nint H[maxn];\n\nbool Makelevel(){\n\tmemset(H,127,sizeof(H));H[s]=0;\n\tstatic queue<int> Q;Q.push(s);\n\twhile(!Q.empty()){int u=Q.front();Q.pop();\n\t\tfor(Edge *P=E[u];P;P=P->next)\n\t\t\tif(P->cap&&H[P->to]>H[u]+1){\n\t\t\t\tH[P->to]=H[u]+1;Q.push(P->to);\n\t\t\t}\n\t}\n\treturn H[t]!=MAX;\n}\n\nint extend(int u,int left){int r=0;\n\tif(u==t)return left;\n\tfor(Edge *P=E[u];P&&r<left;P=P->next)\n\t\tif(P->cap&&H[P->to]==H[u]+1){int t;\n\t\t\tt=extend(P->to,min(P->cap,left-r));\n\t\t\tr+=t;P->cap-=t;P->oppo->cap+=t;\n\t\t}\n\tif(!r)H[u]=MAX;\n\treturn r;\n}\n\nbool check(int n){\n\tif(n<=2)return false;\n\tfor(int i=2;1LL*i*i<=n;i++)if(n%i==0)return false;\n\treturn true;\n}\n\nvoid Work(){\n\tint ans=0;\n\twhile(Makelevel())ans+=extend(s,MAX);\n\tans+=(Odd-ans)/2*2+(n-Odd-ans)/2*2+((Odd-ans)%2==1?3:0);\n\tiout(ans);\n}\n\nvoid Init(){\n\tread(n);\n\tREP(i,1,n)read(A[i]);\n\t\n\tsort(A+1,A+n+1);A[0]=-1;\n\tREP(i,1,n){\n\t\tif(A[i]!=A[i-1]+1)B[++m]=A[i];\n\t\tif(A[i+1]!=A[i]+1)B[++m]=A[i]+1;\n\t}\n\t\n\tn=m;memcpy(A,B,sizeof(A));\n\t\n\ts=0;t=n+1;\n\tREP(i,1,n)if(A[i]&1)Odd++,addedge(s,i,1);else addedge(i,t,1);\n\tREP(i,1,n)if(A[i]&1)\n\t\tREP(j,1,n)if(A[j]&1);else if(check(abs(A[i]-A[j])))addedge(i,j,1);\n}\n\nint main(){\n\tInit();\n\tWork();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\nusing namespace std;\nconst int N=110*2;\nbool f[10001000],fl[N][N],fla[N];\nint n,p[1000100],cnt,a[N],cot,from[N],nj[N],no[N];\nbool match(int x)\n{\n    if(fla[x]) return false;\n    fla[x]=true;\n    for(int i=1;i<=nj[0];++i)\n        if(fl[x][i]&&(from[i]==0||match(from[i])))\n        {\n            from[i]=x;\n            return true;\n        }\n    return false;\n}\nvoid init()\n{\n    for(int i=2;i<=10000500;++i)\n    {\n        if(!f[i]) p[++cnt]=i;\n            for(int j=1;j<=cnt&&p[j]*i<=10000050;++j)\n            {\n                f[p[j]*i]=true;\n                if(i%p[j]==0) break;\n            }\n    }\n}\nint main()\n{\n    ios::sync_with_stdio(false);\n    init();\n    f[1]=true;\n    f[2]=false;\n    cin>>n;\n    int t=-10,t1;\n    for(int i=1;i<=n;++i)\n    {\n        cin>>t1;\n        if(t1-t!=1) \n        {\n            a[cot++]=t+1;\n            a[cot++]=t1;\n        }\n        t=t1;\n    }\n    a[cot]=t1+1;\n    for(int i=1;i<=cot;++i)\n    {\n        if(a[i]%2)\n            nj[++nj[0]]=a[i];\n        else\n            no[++no[0]]=a[i];\n    }\n    for(int i=1;i<=nj[0];++i)\n        for(int j=1;j<=no[0];++j)\n            fl[i][j]=!f[abs(nj[i]-no[j])];\n    int ans=0;\n    for(int i=1;i<=nj[0];++i)\n    {\n        memset(fla,false,sizeof(fla));\n        if(match(i)) ans++;\n    }\n    ans++;\n    cout<< ans+(nj[0]-ans)/2*2+(no[0]-ans)/2*2+(nj[0]-ans)%2*3 <<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define gc getchar()\n#define ll long long\n#define pb push_back\n#define mk make_pair\n#define rint register int \nusing namespace std;\ninline int read(){int w=1,s=0;char ch=getchar();while(!isdigit(ch)){if(ch=='-')w=-1;ch=getchar();}while(isdigit(ch)){s=s*10+ch-'0';ch=getchar();}return  w*s;}\nstruct node{\n\tint to,next;\n}e[1000010];\nint h[1000100],tot;\nint X[1000010];\nint N;int vis[10000010],prime[1000010],cnt;\nint pos1[1000010],num1,pos2[1000010],num2;\nint v[660],lk[1010];\ninline void add(int from,int to){e[++tot].next=h[from];h[from]=tot;e[tot].to=to;}\ninline void Init(int n)\n{\tvis[1]=1;\n\tfor(rint i=2;i<=n;++i)\n\t{\n\t\tif(!vis[i]) prime[++cnt]=i;\n\t\tfor(rint j=1;j<=cnt&&prime[j]*i<=n;++j)\n\t\t{\n\t\t\tvis[i*prime[j]]=1;\n\t\t\tif(i%prime[j]==0) break;\n\t\t}\n\t}vis[2]=1;\n}\nunordered_map<int,int> mp;\ninline void ADD(int x)\n{\n\tif(x&1) pos1[++num1]=x;\n\telse    pos2[++num2]=x;\n}\ninline bool DFS(int now)\n{\n\tfor(rint i=h[now];i;i=e[i].next)\n\t{\n\t\tint to=e[i].to;\n\t\tif(!v[to])\n\t\t{\n\t\t\tv[to]=1;\n\t\t\tif(!lk[to]||DFS(lk[to]))\n\t\t\t{\n\t\t\t\tlk[to]=now;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}return 0;\n}\nint main()\n{\tN=read();\n\tfor(rint i=1;i<=N;++i) X[i]=read(),mp[X[i]]=1;\n\tInit(1e7);\n\tfor(rint i=1;i<=N;++i)\n\t{\t\n\t\tint las=X[i]-1;\n\t\tint nxt=X[i]+1;\n\t\tif(mp[las]!=mp[X[i]]) ADD(X[i]);\n\t\tif(mp[nxt]!=mp[X[i]]) ADD(nxt);\n\t}\n//\tfor(rint i=1;i<=num1;++i) cout<<pos1[i]<<\" \";\n//\tfor(rint i=1;i<=num2;++i) cout<<pos2[i]<<\" \";\n\tfor(rint i=1;i<=num1;++i)\n\t{\n\t\tfor(rint j=1;j<=num2;++j)\n\t\t{\n\t\t\tif(!vis[abs(pos1[i]-pos2[j])])\n\t\t\t{\n\t\t\t\tadd(i,j);\n\t\t\t}\n\t\t}\n\t}int cnt=0;\n\tfor(rint i=1;i<=num1;++i) {memset(v,0,sizeof(v));if(DFS(i)) cnt++;}\n\tint x=num1-cnt,y=num2-cnt;\n\tint ans=cnt+(x/2)*2+(y/2)*2+(x&1)*3;\n\tcout<<ans;\n\treturn 0;\n}\n/*\nby was_n\n18.9.25\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define ii pair <int, int>\n#define app push_back\n#define all(a) a.begin(), a.end()\n#define bp __builtin_popcountll\n#define ll long long\n#define mp make_pair\n#define f first\n#define s second\n#define Time (double)clock()/CLOCKS_PER_SEC\n#define debug(x) std::cout << #x << \": \" << x << '\\n';\n\nconst int N = 207;\nconst int INF = 1e9+7;\nconst int C = 1e7+7;\n\nbool used[N];\n\nbool p[C];\n\nint get(int a, int b) {\n    if (b < a)\n        swap(a, b);\n\n    if (b - a == 1)\n        return INF;\n\n    if ((b - a) % 2 == 0)\n        return 2;\n    else if (p[b-a])\n        return 1;\n    else\n        return 3;\n}\n\nint cost[N][N];\nint dp[1 << 20];\n\nsigned main() {\n    #ifdef HOME\n    freopen(\"input.txt\", \"r\", stdin);\n    #else\n    #define endl '\\n'\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    #endif\n    for (int i = 2; i < C; ++i)\n        p[i] = 1;\n    for (int i = 2; i < C; ++i) \n        if (p[i])\n            for (int j = i * 2; j < C; j += i)\n                p[j] = 0;\n\n    int n;\n    cin >> n;\n    map <int, int> d;\n    while (n--) {\n        int x;\n        cin >> x;\n        d[x] ^= 1;\n        d[x+1] ^= 1;        \n    }\n\n    vector <int> c;\n    for (auto e : d) {\n        if (e.s)\n            c.app(e.f);\n    }   \n\n    #ifdef HOME\n    cout << \"C : \";\n    for (auto e : c)\n        cout << e << ' ';\n    cout << endl;\n    #endif\n\n    if (c.size() > 20)\n        exit(1);\n\n    for (int i = 0; i < c.size(); ++i) {\n        for (int j = i + 1; j < c.size(); ++j) {\n            cost[i][j] = cost[j][i] = get(c[i], c[j]);\n        }   \n    }    \n\n    for (int mask = 1; mask < (1 << c.size()); ++mask) {\n        dp[mask] = INF;\n        int l = -1;\n        for (int i = 0; i < c.size(); ++i)\n            if ((mask >> i) & 1) {\n                l = i;\n                break;\n            }\n        for (int i = l + 1; i < c.size(); ++i) {\n            if ((mask >> i) & 1) {\n                dp[mask] = min(dp[mask], dp[mask - (1 << l) - (1 << i)] + cost[i][l]);\n            }   \n        }   \n    }\n    cout << dp[(1 << c.size()) - 1] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<queue>\n#include<cmath>\n#include<vector>\n#define neko 1010\n#define chkmin(a,b) ((a)<(b)?(a):(b))\n#define f(i,a,b) for(register int i=(a);i<=(b);i=-(~(i)))\nint P[neko],n,ans,cnt,cntp,t=1,head[neko],cur[neko],dis[neko],inf=0x3f3f3f3f,S,T;\nint prime[10000010],isnprime[10000010];\nstruct node\n{\n\tint v,cap,nex;\n}e[neko*neko*2];\nvoid add(int x,int y,int z)\n{\n\te[++t].v=y;\n\te[t].cap=z;\n\te[t].nex=head[x];\n\thead[x]=t;\n\te[++t].v=x;\n\te[t].cap=0;\n\te[t].nex=head[y];\n\thead[y]=t;\n}\nnamespace NT\n{\n\tvoid sieve(int num)\n\t{\n\t\tisnprime[1]=1;\n\t\tf(i,2,num)\n\t\t{\n\t\t\tif(!isnprime[i])prime[++cntp]=i;\n\t\t\tfor(register int j=1;j<=cntp,i*prime[j]<=num;++j)\n\t\t\t{\n\t\t\t\tisnprime[i*prime[j]]=1;\n\t\t\t\tif(i%prime[j]==0)break;\n\t\t\t}\n\t\t}\n\t}\n}\nnamespace Netflow\n{\n\tusing namespace std;\n\tbool bfs()\n\t{\n\t\tqueue<int>q;memset(dis,0,sizeof(dis));\n\t\tdis[S]=1,q.push(S);\n\t\tint u;\n\t\twhile(!q.empty())\n\t\t{\n\t\t\tu=q.front(),q.pop();\n\t\t\tfor(register int i=head[u],v=e[i].v;i;i=e[i].nex,v=e[i].v)\n\t\t\t{\n\t\t\t\tif(!dis[v]&&e[i].cap)\n\t\t\t\t{\n\t\t\t\t\tdis[v]=dis[u]+1;\n\t\t\t\t\tif(v==T)return 1;\n\t\t\t\t\tq.push(v);\n\t\t\t\t}\n\t\t\t}\n\t\t}return 0;\n\t}\n\tint dfs(int u,int flow)\n\t{\n\t\tif(u==T||(!flow))return flow;\n\t\tint rescap=0,up;\n\t\tfor(register int &i=cur[u],v=e[i].v;i;i=e[i].nex,v=e[i].v)\n\t\t{\n\t\t\tif(dis[v]==dis[u]+1&&(up=dfs(v,chkmin(e[i].cap,flow))))\n\t\t\t{\n\t\t\t\te[i].cap-=up,e[i^1].cap+=up;\n\t\t\t\trescap+=up;\n\t\t\t\tif(!(flow-=up))break;\n\t\t\t}\n\t\t}return rescap;\n\t}\n\tvoid dinic()\n\t{while(bfs())memcpy(cur,head,sizeof(head)),ans+=dfs(S,inf);}\n}\n#define pb push_back\nstruct tag\n{int a,b;};\nstd::vector<tag>C;\nint main()\n{\n\tint now=0;\n\tNT::sieve(10000010);\n\tscanf(\"%d\",&n);\n\tf(i,1,n)\n\t{\n\t\tscanf(\"%d\",&P[i]);\n\t\tif(P[i-1]^(P[i]-1)||i==1){C.pb(tag{P[i],++cnt});if(i>1)C.pb(tag{P[i-1]+1,++cnt});}\n\t}C.pb(tag{P[n]+1,++cnt});\n\tS=cnt+1,T=cnt+2;\n\tfor(tag x:C)\n\t{\n\t\tif(x.a&1)\n\t\t{\n\t\t\tadd(S,x.b,1),++now;\n\t\t\tfor(tag y:C)if((!(y.a&1))&&(!isnprime[abs(y.a-x.a)]))add(x.b,y.b,1);\n\t\t}\n\t\telse add(x.b,T,1);\n\t}Netflow::dinic();\n\t//printf(\"%d\\n\",ans);\n\tint A=now-ans,B=(cnt-now)-ans;\n\tans=ans+A/2*2+B/2*2,A=A-A/2*2,B=B-B/2*2;\n\tif(A&&B)ans+=3;\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define forr(x,arr) for(auto&& x:arr)\n#define _overload3(_1,_2,_3,name,...) name\n#define _rep2(i,n) _rep3(i,0,n)\n#define _rep3(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload3(__VA_ARGS__,_rep3,_rep2,)(__VA_ARGS__)\n#define _rrep2(i,n) _rrep3(i,0,n)\n#define _rrep3(i,a,b) for(int i=int(b)-1;i>=int(a);i--)\n#define rrep(...) _overload3(__VA_ARGS__,_rrep3,_rrep2,)(__VA_ARGS__)\n#define all(x) (x).begin(),(x).end()\n#define bit(n) (1LL<<(n))\n#define sz(x) ((int)(x).size())\n#define TEN(n) ((ll)(1e##n))\n#define fst first\n#define snd second\n\nstring DBG_DLM(int &i){return(i++==0?\"\":\", \");}\n#define DBG_B(exp){int i=0;os<<\"{\";{exp;}os<<\"}\";return os;}\ntemplate<class T>ostream&operator<<(ostream&os,vector<T>v);\ntemplate<class T>ostream&operator<<(ostream&os,set<T>v);\ntemplate<class T>ostream&operator<<(ostream&os,queue<T>q);\ntemplate<class T>ostream&operator<<(ostream&os,priority_queue<T>q);\ntemplate<class T,class K>ostream&operator<<(ostream&os,pair<T,K>p);\ntemplate<class T,class K>ostream&operator<<(ostream&os,map<T,K>mp);\ntemplate<class T,class K>ostream&operator<<(ostream&os,unordered_map<T,K>mp);\ntemplate<int I,class TPL>void DBG(ostream&os,TPL t){}\ntemplate<int I,class TPL,class H,class...Ts>void DBG(ostream&os,TPL t){os<<(I==0?\"\":\", \")<<get<I>(t);DBG<I+1,TPL,Ts...>(os,t);}\ntemplate<class T,class K>void DBG(ostream&os,pair<T,K>p,string delim){os<<\"(\"<<p.first<<delim<<p.second<<\")\";}\ntemplate<class...Ts>ostream&operator<<(ostream&os,tuple<Ts...>t){os<<\"(\";DBG<0,tuple<Ts...>,Ts...>(os,t);os<<\")\";return os;}\ntemplate<class T,class K>ostream&operator<<(ostream&os,pair<T,K>p){DBG(os,p,\", \");return os;}\ntemplate<class T>ostream&operator<<(ostream&os,vector<T>v){DBG_B(forr(t,v){os<<DBG_DLM(i)<<t;});}\ntemplate<class T>ostream&operator<<(ostream&os,set<T>s){DBG_B(forr(t,s){os<<DBG_DLM(i)<<t;});}\ntemplate<class T>ostream&operator<<(ostream&os,queue<T>q){DBG_B(for(;q.size();q.pop()){os<<DBG_DLM(i)<<q.front();});}\ntemplate<class T>ostream&operator<<(ostream&os,priority_queue<T>q){DBG_B(for(;q.size();q.pop()){os<<DBG_DLM(i)<<q.top();});}\ntemplate<class T,class K>ostream&operator<<(ostream&os,map<T,K>m){DBG_B(forr(p,m){os<<DBG_DLM(i);DBG(os,p,\"->\");});}\ntemplate<class T,class K>ostream&operator<<(ostream&os,unordered_map<T,K>m){DBG_B(forr(p,m){os<<DBG_DLM(i);DBG(os,p,\"->\");});}\n#define DBG_OVERLOAD(_1,_2,_3,_4,_5,_6,macro_name,...)macro_name\n#define DBG_LINE(){char s[99];sprintf(s,\"line:%3d | \",__LINE__);cerr<<s;}\n#define DBG_OUTPUT(v){cerr<<(#v)<<\"=\"<<(v);}\n#define DBG1(v,...){DBG_OUTPUT(v);}\n#define DBG2(v,...){DBG_OUTPUT(v);cerr<<\", \";DBG1(__VA_ARGS__);}\n#define DBG3(v,...){DBG_OUTPUT(v);cerr<<\", \";DBG2(__VA_ARGS__);}\n#define DBG4(v,...){DBG_OUTPUT(v);cerr<<\", \";DBG3(__VA_ARGS__);}\n#define DBG5(v,...){DBG_OUTPUT(v);cerr<<\", \";DBG4(__VA_ARGS__);}\n#define DBG6(v,...){DBG_OUTPUT(v);cerr<<\", \";DBG5(__VA_ARGS__);}\n#define DEBUG0(){DBG_LINE();cerr<<endl;}\n#ifdef LOCAL\n#define out(...){DBG_LINE();DBG_OVERLOAD(__VA_ARGS__,DBG6,DBG5,DBG4,DBG3,DBG2,DBG1)(__VA_ARGS__);cerr<<endl;}\n#else\n#define out(...)\n#endif\n\nusing ll=long long;\nusing pii=pair<int,int>;using pll=pair<ll,ll>;using pil=pair<int,ll>;using pli=pair<ll,int>;\nusing vs=vector<string>;using vvs=vector<vs>;using vvvs=vector<vvs>;\nusing vb=vector<bool>;using vvb=vector<vb>;using vvvb=vector<vvb>;\nusing vi=vector<int>;using vvi=vector<vi>;using vvvi=vector<vvi>;\nusing vl=vector<ll>;using vvl=vector<vl>;using vvvl=vector<vvl>;\nusing vd=vector<double>;using vvd=vector<vd>;using vvvd=vector<vvd>;\nusing vpii=vector<pii>;using vvpii=vector<vpii>;using vvvpii=vector<vvpii>;\ntemplate<class A,class B>bool amax(A&a,const B&b){return b>a?a=b,1:0;}\ntemplate<class A,class B>bool amin(A&a,const B&b){return b<a?a=b,1:0;}\nll ri(){ll l;cin>>l;return l;} string rs(){string s;cin>>s;return s;}\n\nbool is_prime(const int64_t n) {\n  if (n < 2) return false;\n  if (n % 2 == 0) return false;\n  for (int64_t i = 3; i * i <= n; i += 2) {\n    if (n % i == 0) return false;\n  }\n  return true;\n}\n\nclass BipartiteMatching {\n  bool dfs(int v) {\n    used[v] = true;\n    for (int i = 0; i < (int)G[v].size(); i++) {\n      int u = G[v][i], w = match[u];\n      if (w < 0 || (!used[w] && dfs(w))) {\n        match[v] = u;\n        match[u] = v;\n        return true;\n      }\n    }\n    return false;\n  }\n\n  public:\n  int V;\n  vector<vector<int>> G;\n  vector<int> match;\n  vector<bool> used;\n\n  BipartiteMatching(int V) : V(V), G(V), match(V, -1), used(V) {}\n\n  void add_edge(int u, int v) {\n    G[u].push_back(v);\n    G[v].push_back(u);\n  }\n\n  int matching() {\n    int res = 0;\n    for (int v = 0; v < V; v++) {\n      if (match[v] < 0) {\n        fill(used.begin(), used.end(), 0);\n        if (dfs(v)) {\n          res++;\n        }\n      }\n    }\n    return res;\n  }\n};\n\nvoid Main() {\n  int n = ri();\n  vector<int> A(n);\n  rep(i, n) A[i] = ri();\n\n  sort(all(A));\n\n  vi B;\n  rep(i, n) {\n    if (i) {\n      if (A[i-1] != A[i] - 1) B.emplace_back(A[i]);\n    }\n    else {\n      B.emplace_back(A[i]);\n    }\n    if (i + 1 < n) {\n      if (A[i+1] != A[i] + 1) B.emplace_back(A[i]+1);\n    }\n    else {\n      B.emplace_back(A[i]+1);\n    }\n  }\n\n  out(A);\n  out(B);\n\n  vi E, O;\n  forr(b, B) (b % 2 ? O : E).emplace_back(b);\n\n  int e = sz(E);\n  int o = sz(O);\n\n  BipartiteMatching bm(e + o);\n\n  rep(i, e) rep(j, o) {\n    int d = abs(E[i] - O[j]);\n    if (is_prime(d)) {\n      bm.add_edge(i, e + j);\n    }\n  }\n\n  int k = bm.matching();\n\n  int k2_e = (e - k) / 2;\n  int k2_o = (o - k) / 2;\n\n  int k3 = (e - k) % 2;\n\n  int ans = k + k2_e * 2 + k2_o * 2 + k3 * 3;\n\n  cout << ans << endl;\n}\n\nsigned main() {\n  cin.tie(nullptr);\n  ios::sync_with_stdio(false);\n  Main();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\nusing namespace std;\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a < b) ? (a = b, 1) : 0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b < a) ? (a = b, 1) : 0;}\n\nusing ll = long long;\nusing R = long double;\nconst R EPS = 1e-9L; // [-1000,1000]->EPS=1e-8 [-10000,10000]->EPS=1e-7\ninline int sgn(const R& r) {return (r > EPS) - (r < -EPS);}\ninline R sq(R x) {return sqrt(max(x, 0.0L));}\n\nconst int dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nconst int dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\n\n// Problem Specific Parameter:\n\nconst ll limit = 10000010;\nbool isprime[limit];\nbool x[limit];\n\nconst int inf = 1 << 20;\n\nvoid init() {\n\trep(i, limit)  isprime[i] = true;\n\tisprime[0] = isprime[1] = false;\n\n\tfor (ll i = 2; i < limit; ++i) {\n\t\tif (isprime[i]) {\n\t\t\tfor (ll j = 1LL * i * i ; j < limit; j += i) {\n\t\t\t\tisprime[j] = false;\n\t\t\t}\n\t\t}\n\t}\n}\n\n//Appropriately Changed\nusing W = ll;\nusing edge = struct {int to, rev; W cap, flow;};\nusing G = vector<vector<edge>>;\n\n//Appropriately Changed\nvoid add_edge(G &graph, int from, int to, W cap) {\n\tgraph[from].push_back({to, int(graph[to].size()) , cap , 0});\n\tgraph[to].push_back({from, int(graph[from].size()) - 1, 0 , 0});\n}\n\n// Description: グラフに対する最大流\n// TimeComplexity: $ \\mathcal{O}(EV^2) $ but fast\n// Verifyed: AOJ GRL_6_A\n\nW dinic(G &graph, int s, int t) {\n\tconst W inf = 1LL << 50;\n\tconst int n = graph.size();\n\tvector<int> level(n), iter(n);\n\n\tauto bfs = [&](int s, int t) {\n\t\tfill(begin(level), end(level), -1);\n\t\tqueue<int> q;\n\t\tlevel[s] = 0, q.push(s);\n\n\t\twhile (!q.empty()) {\n\t\t\tint v = q.front(); q.pop();\n\t\t\tfor (auto &e : graph[v]) {\n\t\t\t\tif (level[e.to] == - 1 and e.cap > e.flow) {\n\t\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\t\tq.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn (level[t] !=  -1);\n\t};\n\n\tauto dfs = [&](int v, int t, W f) {\n\t\tauto func = [&](int v, int t, W f, auto func)->W{\n\n\t\t\tif (v == t) return f;\n\t\t\tfor (int &i = iter[v]; i < graph[v].size(); i++) {\n\t\t\t\tedge &e = graph[v][i];\n\n\t\t\t\tif (e.cap > e.flow and level[v] < level[e.to]) {\n\n\t\t\t\t\tW d = func(e.to, t, min(f, e.cap - e.flow), func);\n\n\t\t\t\t\tif (d > 0) {\n\t\t\t\t\t\te.flow += d, graph[e.to][e.rev].flow -= d;\n\t\t\t\t\t\treturn d;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn 0;\n\t\t};\n\t\treturn func(v, t, f, func);\n\t};\n\n\twhile (bfs(s, t)) {\n\t\tfill(begin(iter), end(iter), 0);\n\t\twhile (dfs(s, t, inf) != 0 );\n\t}\n\n\tW ret = 0;\n\tfor (auto &e : graph[s]) ret += e.flow;\n\treturn ret;\n}\n\n\nint main(void) {\n\tinit();\n\n\tint n;\n\tcin >> n;\n\n\trep(i, n) {\n\t\tint in;\n\t\tcin >> in;\n\t\tx[in] = 1;\n\t}\n\n\trep(i, limit - 1) x[i] ^= x[i + 1];\n\n\tvector<int> number[2];\n\trep(i, limit) if (x[i]) number[i & 1].push_back(i);\n\n\tconst int s = number[0].size() + number[1].size();\n\tconst int t = s + 1;\n\tconst int all = t + 1;\n\n\tG graph(all);\n\n\trep(i, number[0].size()) add_edge(graph, s, i, 1);\n\trep(i, number[0].size()) {\n\t\trep(j, number[1].size()) {\n\t\t\tconst int diff = abs(number[1][j] - number[0][i]);\n\t\t\t//cerr << diff << endl;\n\t\t\tif (isprime[diff]) add_edge(graph, i, number[0].size() + j, 1);\n\t\t}\n\t}\n\trep(j, number[1].size()) add_edge(graph, number[0].size() + j, t, 1);\n\n\tconst int res = dinic(graph,s,t);\n\t//cerr << res << endl;\n\tint ans = res;\n\tans += (number[0].size() + number[1].size() - 2 * res);\n\tif( (number[0].size() - res) % 2 == 1) ans++;\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<string.h>\nusing namespace std;\n\nconst int maxn = 2e5+7;\nconst int maxm = 1e7+7;\nint n,a[maxm];\nvector<int>v[2],E[maxn];\nbool bio[maxn];\nint conn[maxn];\nvoid init(){\n    scanf(\"%d\",&n);\n    for(int i=1;i<=n;i++){\n        int x;\n        scanf(\"%d\",&x);\n        a[x]=1;\n    }\n}\nbool prime(int x){\n    if(x==1)return false;\n    for(int i=2;i*i<=x;i++)\n        if(x%i==0)return false;\n    return true;\n}\nbool dfs(int x){\n    if(bio[x])return false;\n    bio[x]=true;\n    for(auto it : E[x]){\n        if(conn[it] == -1 || dfs(conn[it])){\n            conn[it] = x;\n            return true;\n        }\n    }\n    return false;\n}\nint main(){\n    init();\n    memset(conn,-1,sizeof(conn));\n    for(int i=maxm-1;i;i--){\n        a[i]^=a[i-1];\n        if(a[i])v[i%2].push_back(i);\n    }\n    for(int i=0;i<v[0].size();i++){\n        for(int j=0;j<v[1].size();j++){\n            if(prime(abs(v[0][i]-v[1][j]))){\n                E[i].push_back(j);\n            }\n        }\n    }\n    \n    int match = 0;\n    for(int i=0;i<v[0].size();i++){\n        memset(bio,false,sizeof(bio));\n        match+=dfs(i);\n    }\n    cout<<v[0].size()+v[1].size()-match+(v[0].size()-match)%2;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <cmath>\n#include <iomanip>\n#include <cassert>\n#include <bitset>\nusing namespace std;\n\ntypedef pair<int, int> P;\n#define rep(i, n) for (int i=0; i<(n); i++)\n#define all(c) (c).begin(), (c).end()\n#define uniq(c) c.erase(unique(all(c)), (c).end())\n#define _1 first\n#define _2 second\n#define pb push_back\n#define INF 1145141919\n#define MOD 1000000007\n\nint N, V;\nint A[300];\nmap<int, int> mp;\nint cost[300][300];\nint dp[300][300];\n\nbool is_prime(int x) {\n  for (int i=2; i<=sqrt(x); i++) {\n    if (x % i == 0) return false;\n  }\n  return true;\n}\n\nint f(int x) {\n  if (x % 2 == 0) return 2;\n  if (is_prime(x)) return 1;\n  return 3;\n}\nsigned main() {\n  ios::sync_with_stdio(false); cin.tie(0);\n  cin >> N;\n  rep(i, N) {\n    int x;\n    cin >> x;\n    mp[x]^=1;\n    mp[x+1]^=1;\n  }\n  for (auto p : mp) {\n    if (p._2 == 0) continue;\n    A[V++] = p._1;\n  }\n  sort(A, A+V);\n\n  rep(i, V) rep(j, V) cost[i][j] = INF;\n  rep(i, V) {\n    cost[i][i] = 0;\n    rep(j, i) {\n      cost[i][j] = cost[j][i] = f(abs(A[i]-A[j]));\n    }\n  }\n  rep(i, V) {\n    rep(j, V) {\n      dp[i][j] = INF;\n    }\n  }\n  for (int len=1; len<V; len++) {\n    rep(l, V) {\n      int r = l+len;\n      if (r >= V) break;\n      // [l, r]\n      for (int k=l+1; k<r; k++) {\n        // [l, k] + [k+1, r]\n        if (dp[l][k] == INF || dp[k+1][r] == INF) continue;\n        dp[l][r] = min(dp[l][r], dp[l][k] + dp[k+1][r]);\n      }\n      // ( x )\n      int s = INF;\n      if (len == 1) s = 0;\n      else s = dp[l+1][r-1];\n      dp[l][r] = s+cost[l][r];\n    }\n  }\n  assert(dp[0][V-1] != INF);\n  cout << dp[0][V-1] << \"\\n\";\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\n#define dd second\n#define mp make_pair\n#define pb push_back\n#define ff first\n#define dd second\n#define pp pair<int,int>\nusing namespace std;\n\nint n;\n\nstruct Turbo\n{\n    int n, m;\n    vector<int> lm, rm;\n    vector<bool> visited;\n    vector<vector<int>> graph;\n\n    Turbo(int n, int m)\n    {\n        this->n = n;\n        this->m = m;\n        lm.resize(n,-1); rm.resize(m,-1);\n        visited.resize(n,false);\n        graph.resize(n);\n    }\n\n    void addEdge(int a, int b)\n    {\n        graph[a].pb(b);\n    }\n\n    int bestMatching()\n    {\n        int res = 0;\n        while(1)\n        {\n            bool change = false;\n            for(int i = 0; i < n; ++i) visited[i] = false;\n            for(int i = 0; i < n; ++i)\n            {\n                if(lm[i] == -1 and findPath(i))\n                {\n                    res++;\n                    change = true;\n                }\n            }\n            if(!change) break;\n        }\n        return res;\n    }\n\n    bool findPath(int x)\n    {\n        if(visited[x]) return false;\n        visited[x] = true;\n        for(auto &i:graph[x])\n        {\n            if(rm[i] == -1 or findPath(rm[i]))\n            {\n                lm[x] = rm[i];\n                rm[i] = x;\n                return true;\n            }\n        }\n        return false;\n    }\n\n};\n\nbool prime(int x)\n{\n    if(x < 3) return false;\n    for(int i = 2; i*i <= x; ++i) if(x % i == 0) return false;\n    return true;\n}\n\nmain()\n{\n    ios_base::sync_with_stdio(false);\n    cin >> n;\n    vector<int> ev, od;\n    for(int i = 0; i < n; ++i)\n    {\n        int temp; cin >> temp;\n        if(temp & 1)\n        {\n            if(od.size() > 0 and od.back() == temp) od.pop_back(); else od.pb(temp);\n            ev.pb(temp+1);\n        }\n        else\n        {\n            if(ev.size() > 0 and ev.back() == temp) ev.pop_back(); else ev.pb(temp);\n            od.pb(temp+1);\n        }\n    }\n\n    Turbo turbo(ev.size(), od.size());\n    for(int a = 0; a < ev.size(); ++a)\n        for(int b = 0; b < od.size(); ++b)\n        {\n            if(prime(abs(od[b]-ev[a]))) turbo.addEdge(a,b);\n        }\n    int k = turbo.bestMatching();\n    int ans = k + ((ev.size()-k)/2+(od.size()-k)/2) * 2 + ((ev.size()-k) % 2) * 3;\n    cout << ans << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAX = 1e7;\n\nint main()\n{\n\tvector<int> is(MAX + 1, 1);\n\tis[0] = 0; is[1] = 3;\n\tfor (int i = 2; i <= MAX; i += 2) {\n\t\tis[i] = 2;\n\t}\n\tfor (int i = 3; i * i <= MAX; i++) {\n\t\tif (is[i] == 1) {\n\t\t\tfor (int j = i * 3; j <= MAX; j += i) {\n\t\t\t\tis[j] = j & 1 ? 3 : 2;\n\t\t\t}\n\t\t}\n\t}\n\tint N;\n\tcin >> N;\n\tvector<int> x(N);\n\tfor (int i = 0; i < N; i++) {\n\t\tcin >> x[i];\n\t}\n\tvector<int> st;\n\tfor (int i = 0; i < N; i++) {\n\t\tif (!st.empty() && st.back() == x[i]) {\n\t\t\tst.back() += 1;\n\t\t}\n\t\telse {\n\t\t\tst.push_back(x[i]);\n\t\t\tst.push_back(x[i] + 1);\n\t\t}\n\t}\n\tN = st.size();\n\tvector<vector<int>> dp(N, vector<int>(N + 1));\n\tfor (int l = 2; l <= N; l += 2) {\n\t\tfor (int i = 0; i + l <= N; i++) {\n\t\t\tint j = i + l;\n\t\t\tdp[i][j] = is[st[j - 1] - st[i]] + dp[i + 1][j - 1];\n\t\t\tfor (int k = i + 2; k <= j - 2; k += 2) {\n\t\t\t\tdp[i][j] = min(dp[i][j], dp[i][k] + dp[k][j]);\n\t\t\t}\n\t\t}\n\t}\n\tcout << dp[0][N] << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n\nint N,x[101],D[101][101];\nbool isp[10000001];\n\nvoid mn(int &a, int b)\n{\n\tif (a > b)\n\t\ta = b;\n}\n\nint push(int l)\n{\n\tif (!isp[l]) return 1;\n\tif (l % 2 == 0) return 2;\n\treturn 3;\n}\n\nint main()\n{\n\tscanf (\"%d\",&N);\n\tfor (int i=0;i<N;i++) scanf (\"%d\",&x[i]);\n\n\tfor (int i=2;i*i<=10000000;i++) if (!isp[i]){\n\t\tfor (int j=i*i;j<=10000000;j+=i) isp[j] = 1;\n\t}\n\tisp[0] = isp[1] = isp[2] = 1;\n\n\tfor (int l=0;l<N;l++){\n\t\tif (l == N-1){\n\t\t\tint c = 0;\n\t\t\tc++;\n\t\t}\n\t\tfor (int i=0,j=l;j<N;i++,j++){\n\t\t\tif (l == 0) D[i][j] = 3;\n\t\t\telse{\n\t\t\t\tD[i][j] = 0x7fffffff;\n\t\t\t\tfor (int k=i;k<j;k++) mn(D[i][j],D[i][k]+D[k+1][j]);\n\t\t\t\tif (x[j] - x[i] == j - i) mn(D[i][j],push(j-i+1));\n\n\t\t\t\tfor (int k=i;k<j;k++) if (x[k] - x[i] == k - i){\n\t\t\t\t\tfor (int l=j;l>k;l--) if (x[j] - x[l] == j - l){\n\t\t\t\t\t\tint u = push(x[j]-x[i]+1) + push(x[l]-x[k]-1);\n\t\t\t\t\t\tmn(D[i][j],D[k+1][l-1]+u);\n\t\t\t\t\t\tint v = push(x[j]-x[k]) + push(x[l]-x[i]);\n\t\t\t\t\t\tmn(D[i][j],D[k+1][l-1]+v);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf (\"%d\\n\",D[0][N-1]);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<cassert>\n#define PB push_back\n#define MP make_pair\n#define sz(v) (in((v).size()))\n#define forn(i,n) for(in i=0;i<(n);++i)\n#define forv(i,v) forn(i,sz(v))\n#define fors(i,s) for(auto i=(s).begin();i!=(s).end();++i)\n#define all(v) (v).begin(),(v).end()\nusing namespace std;\ntypedef int in;\ntypedef vector<in> VI;\ntypedef vector<VI> VVI;\nstruct bipm{\n  in n,m;\n  VVI a;\n  VI pr,vs;\n  void ini(in pn, in pm){\n    n=pn;\n    m=pm;\n    a.clear();\n    a.resize(n);\n    pr.clear();\n    pr.resize(m,-1);\n  }\n  void ad(in u, in v){\n    a[u].PB(v);\n  }\n  bool mm(in u){\n    if(vs[u])\n      return 0;\n    vs[u]=1;\n    in tt;\n    forv(i,a[u]){\n      tt=a[u][i];\n      if(pr[tt]==-1){\n    pr[tt]=u;\n    return 1;\n      }\n      if(mm(pr[tt])){\n    pr[tt]=u;\n    return 1;\n      }\n    }\n    return 0;\n  }\n  in mmat(){\n    vs.resize(n);\n    in sm=0;\n    forn(i,n){\n      forn(j,n)\n    vs[j]=0;\n      sm+=mm(i);\n    }\n    return sm;\n  }\n};\nbipm mat;\nbool isp(in a){\n  if(a<=2)\n    return 0;\n  for(in i=2;i*i<=a;++i){\n    if(a%i==0)\n      return 0;\n  }\n  return 1;\n}\nin ab(in a){\n  return a<0?-a:a;\n}\nint main(){\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  in n;\n  cin>>n;\n  VI x(n);\n  forn(i,n)\n    cin>>x[i];\n  VI lft,rgt;\n  in c;\n  forv(i,x){\n    if(i==0 || x[i-1]+1!=x[i]){\n      c=x[i];\n      if(c%2==0)\n    lft.PB(c);\n      else\n    rgt.PB(c);\n    }\n    if(i==n-1 || x[i]+1!=x[i+1]){\n      c=x[i]+1;\n      if(c%2==0)\n    lft.PB(c);\n      else\n    rgt.PB(c);\n    }\n  }\n  in l=sz(lft);\n  in r=sz(rgt);\n  mat.ini(l,r);\n  forv(i,lft){\n    forv(j,rgt){\n      if(isp(ab(rgt[j]-lft[i])))\n    mat.ad(i,j);\n    }\n  }\n  c=mat.mmat();\n  in res=c;\n  l-=c;\n  r-=c;\n  assert(l%2==r%2);\n  if(l%2){\n    res+=3;\n    --l;\n    --r;\n  }\n  res+=l+r;\n  cout<<res<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define pb push_back\nconst int maxn=210;\nint n,k,pri[10000010],linker[maxn],a[maxn],b[maxn];\nbool mark[10000010],vis[maxn];\nvector<int> v[maxn];\nvoid pre()\n{\n\tn=10000000;\n\tmark[1]=true;\n\tfor (int i=2;i<=n;i++)\n\t{\n\t\tif (!mark[i])\n\t\t{\n\t\t\tpri[k++]=i;\n\t\t\t//cerr<<i<<endl;\n\t\t}\n\t\tfor (int j=0;j<k;j++)\n\t\t{\n\t\t\tint m=i*pri[j];\n\t\t\tif (m>n)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmark[m]=true;\n\t\t\tif (i%pri[j]==0)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\nbool dfs(int x)\n{\n\tfor (int i=0;i<v[x].size();i++)\n\t{\n\t\tint y=v[x][i];\n\t\tif (vis[y])\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\t\tif (linker[y]==-1 || dfs(linker[y]))\n\t\t{\n\t\t\tlinker[y]=x;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\nint main()\n{\n\tpre();\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%d\",&a[i]);\n\t}\n\tint k=0;\n\tb[++k]=a[1]-1;\n\tfor (int i=2;i<=n;i++)\n\t{\n\t\tif (a[i]!=a[i-1]+1)\n\t\t{\n\t\t\tb[++k]=a[i-1];\n\t\t\tb[++k]=a[i]-1;\n\t\t}\n\t}\n\tb[++k]=a[n];\n\tn=k;\n\tif (n>200)\n\t{\n\t\treturn 0;\n\t}\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tlinker[i]=-1;\n\t\t//cerr<<b[i]<<endl;\n\t\tfor (int j=i+1;j<=n;j++)\n\t\t{\n\t\t\tif (abs(b[i]-b[j])>10000000)\n\t\t\t{\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif ((b[i]+b[j])&1 && !mark[abs(b[i]-b[j])])\n\t\t\t{\n\t\t\t\t//cerr<<i<<\" \"<<j<<\" \"<<abs(b[i]-b[j])<<\" \"<<mark[9]<<endl;\n\t\t\t\tif (b[i]&1)\n\t\t\t\t{\n\t\t\t\t\tv[i].pb(j);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tv[j].pb(i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint s=0;\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tif (!(b[i]&1))\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\t\tmemset(vis,false,sizeof(vis));\n\t\tif (dfs(i))\n\t\t{\n\t\t\ts++;\n\t\t}\n\t}\n\tint s1=0,s2=0;\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tif (b[i]&1)\n\t\t{\n\t\t\ts1++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\ts2++;\n\t\t}\n\t}\n\tint ans=s+((s1-s)/2+(s2-s)/2)*2+((s1-s)&1)*3;\n\tcout<<ans<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct Bip {\n    int n,m; // #l, #r\n    vector<vector<int>> g;\n    vector<int> left;\n    vector<bool> trk;\n\n    Bip() {}\n    Bip(int _n) : n(_n), m(_n) {\n        init();\n    }\n    Bip(int _n, int _m) : n(_n), m(_m) {\n        init();\n    }\n    void init() {\n        g.resize(n);\n        left.assign(m, -1);\n        trk.assign(n, false);\n    }\n    inline void add(int l, int r) {\n        assert(0 <= l && l < n);\n        assert(0 <= r && r < m);\n        g[l].emplace_back(r);\n    }\n\n    bool dfs(int l) {\n        if (trk[l]) return false;\n        trk[l] = true;\n        for (int r: g[l]) {\n            if (left[r] == -1 || dfs(left[r])) {\n                left[r] = l;\n                return true;\n            }\n        }\n        return false;\n    }\n    int match() {\n        int cnt = 0;\n        for (int i = 0; i < n; i++) {\n            fill(trk.begin(), trk.end(), false);\n            if (dfs(i)) cnt++;\n        }\n        return cnt;\n    }\n};\n\nusing u64=unsigned long long ;\n\nu64 mod_mul(u64 x, u64 y, u64 m) {\n    if (__builtin_clzll(x)+__builtin_clzll(y) >= 64) {\n        x *= y;\n        return (x>=m? x%m : x);\n    } else {\n        return (__uint128_t)x*y %m;\n    }\n}\n\nu64 mod_pow(u64 x, u64 e, u64 m) {\n    u64 res = 1;\n    for (; e; e >>= 1) {\n        if (e & 1) res = mod_mul(res, x, m);\n        x = mod_mul(x, x, m);\n    }\n    return res;\n}\n\n// [0, 2^32) 0.2 sec / 10^6.\n// [0, 2^64) 1.3 sec / 10^6\n// pass u32/u64 plz, avoid potential negative.\nbool miller_rabin(u64 p) {\n    static pair<u64, valarray<u64>> WIT[] = {\n        {2'046, {2}},\n        {1'373'652, {2, 3}},\n        {9'080'190, {31, 73}},\n        {25'326'000, {2, 3, 5}},\n        {4'759'123'140, {2, 7, 61}},\n        {1'112'004'669'632, {2, 13, 23, 1662803}},\n        {2'152'302'898'746, {2, 3, 5, 7, 11}},\n        {3'474'749'660'382, {2, 3, 5, 7, 11, 13}},\n        {341'550'071'728'320, {2, 3, 5, 7, 11, 13, 17}},\n        {0xFFFF'FFFF'FFFF'FFFF, {2, 3, 5, 7, 11, 13, 17, 19, 23}}};\n\n    if (p%2 == 0) return p==2;\n    if (p == 1) return false;\n    u64 d = p - 1, e = 0;\n    while (d%2 == 0) d/=2, e++;\n    int _k = 0;\n    while (WIT[_k].first < p) _k++;\n    for (const auto& a: WIT[_k].second) {\n        u64 t = mod_pow(a, d, p);\n        if (t == 1 || t == p-1) continue;\n        bool ok = false;\n        for (size_t _ = 0; _ < e; _++) {\n            t = mod_mul(t, t, p);\n            if (t == 1) return false;\n            if (t == p-1) {ok=true; break;}\n        }\n        if (ok) continue;\n        else return false;\n    }\n    return true;\n}\n\nvoid solve() {\n    int n; cin >> n;\n    set<int> bar;\n    for (int _ = 0; _ < n; _++) {\n        int x; cin >> x;\n        if (bar.find(x) == bar.end())\n            bar.insert(x);\n        else bar.erase(x);\n\n        if (bar.find(x+1) == bar.end())\n            bar.insert(x+1);\n        else bar.erase(x+1);\n    }\n    vector<int> a[2];\nassert(bar.size()%2 == 0);\n    for (auto& x: bar) {\n        a[x&1].emplace_back(x);\n    }\n\n    n = a[0].size();\n    int m = a[1].size();\n    Bip g(n,m);\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            u64 d = abs(a[0][i] - a[1][j]);\n            if (d <= 2) continue;\n            if (miller_rabin(d))\n                g.add(i, j);\n        }\n    }\n    int k = g.match();\n\n    int res = k + ((n-k)/2 + (m-k)/2) * 2 + ((m-k)&1)*3;\n    cout << res;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    solve();\n    cout << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace std;\nusing namespace __gnu_pbds;\n\n#define ll long long\n#define db long double\n#define ii pair<int,int>\n#define vi vector<int>\n#define fi first\n#define se second\n#define sz(a) (int)(a).size()\n#define all(a) (a).begin(),(a).end()\n#define pb push_back\n#define mp make_pair\n#define FN(i, n) for (int i = 0; i < (int)(n); ++i)\n#define FEN(i,n) for (int i = 1;i <= (int)(n); ++i)\n#define rep(i,a,b) for(int i=a;i<b;i++)\n#define repv(i,a,b) for(int i=b-1;i>=a;i--)\n#define SET(A, val) memset(A, val, sizeof(A))\ntypedef tree<int ,null_type,less<int>,rb_tree_tag,tree_order_statistics_node_update>ordered_set ;\n// order_of_key (val): returns the no. of values less than val\n// find_by_order (k): returns the kth largest element.(0-based)\n#define TRACE\n#ifdef TRACE\n#define trace(...) __f(#__VA_ARGS__, __VA_ARGS__)\ntemplate <typename Arg1>\nvoid __f(const char* name, Arg1&& arg1){\n  cerr << name << \" : \" << arg1 << std::endl;\n}\ntemplate <typename Arg1, typename... Args>\nvoid __f(const char* names, Arg1&& arg1, Args&&... args){\n  const char* comma = strchr(names + 1, ','); cerr.write(names, comma - names) << \" : \" << arg1<<\" | \";__f(comma+1, args...);\n}\n#else\n#define trace(...)\n#endif\nconst int N=205,L=1e7+5;\nbool mark[L],prime[L];\nnamespace match\n{\n  const int N=205;\n  int l[N],r[N],n,m;\n  bool a[N][N],seen[N];\n  bool findmatch(int i)\n  {\n    rep(j,0,m)\n      {\n\tif(a[i][j] && !seen[j])\n\t  {\n\t    seen[j]=true;\n\t    if(r[j]<0 || findmatch(r[j]))\n\t      {\n\t\tl[i]=j; r[j]=i;\n\t\treturn true;\n\t      }\n\t  }\n      }\n    return false;\n  }\n  int bipartitematch()\n  {\n    int cnt=0;\n    rep(i,0,n) l[i]=-1;\n    rep(i,0,m) r[i]=-1;\n    rep(i,0,n)\n      {\n\trep(j,0,m) seen[j]=false;\n\tif(findmatch(i)) cnt++;\n      }\n    return cnt;\n  }\n};\nint main()\n{\n  std::ios::sync_with_stdio(false);\n  cin.tie(NULL) ; cout.tie(NULL) ;\n  memset(prime,true,sizeof(prime));\n  prime[1]=false;\n  rep(i,2,L)\n    {\n      if(!prime[i]) continue;\n      for(int j=2*i;j<L;j+=i)\n\tprime[j]=false;\n    }\n  prime[2]=false;\n  int n,x;\n  cin>>n;\n  rep(i,1,n+1)\n    {\n      cin>>x;\n      mark[x]=true;\n    }\n  vi arr;\n  rep(i,1,L-1)\n    if((mark[i-1] && !mark[i])  || (!mark[i-1] && mark[i]))\n      arr.pb(i);\n  match::n=match::m=sz(arr);\n  int odd=0,even=0;\n  for(int x:arr)\n    {\n      if(x%2==0) even++;\n      else odd++;\n    }\n  rep(i,0,sz(arr))\n    rep(j,i+1,sz(arr))\n    {\n      if(prime[arr[j]-arr[i]]) match::a[i][j]=1;\n      else match::a[i][j]=0;\n    }\n  int k=match::bipartitematch();\n  int ans=k+((even-k)/2+(odd-k)/2)*2;\n  if((even-odd)&1==0) ans+=3*((even-k)&1);\n  else\n    {\n      ans+=((even-k)&1)*3;\n      ans+=((odd-k)&1)*3;\n    }\n  cout<<ans<<endl;\n  return 0 ;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n#define rep(i, n) for (int i = 0; i < (int) (n); i++)\n#define reps(i, n) for (int i = 1; i <= (int) (n); i++)\n#define all(x) (x).begin(), (x).end()\n#define uniq(x) (x).erase(unique(all(x)), (x).end())\n#define bit(n) (1LL << (n))\n#define dump(x) cerr << #x \" = \" << (x) << endl\nusing vint = vector<int>;\nusing vvint = vector<vint>;\nusing pint = pair<int, int>;\nusing vpint = vector<pint>;\ntemplate<typename T> using priority_queue_rev = priority_queue<T, vector<T>, greater<T>>;\nconstexpr double PI = 3.1415926535897932384626433832795028;\nconstexpr int DY[9] = {0, 1, 0, -1, 1, 1, -1, -1, 0};\nconstexpr int DX[9] = {1, 0, -1, 0, 1, -1, -1, 1, 0};\nint sign(int x) { return (x > 0) - (x < 0); }\nint gcd(int a, int b) {\n    while (b) { swap(a %= b, b); }\n    return a;\n}\nint lcm(int a, int b) { return a / gcd(a, b) * b; }\nint cdiv(int a, int b) { return (a - 1 + b) / b; }\ntemplate<typename T> void fin(T mes) {\n    cout << mes << endl;\n    exit(0);\n}\ntemplate<typename T, typename U> bool chmax(T &a, const U &b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate<typename T, typename U> bool chmin(T &a, const U &b) {\n    if (b < a) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate<typename T, typename U> ostream &operator<<(ostream &os, const pair<T, U> &rhs) {\n    os << \"(\" << rhs.first << \", \" << rhs.second << \")\";\n    return os;\n}\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &rhs) {\n    os << \"{\";\n    for (auto itr = rhs.begin(); itr != rhs.end(); itr++) {\n        os << *itr << (next(itr) != rhs.end() ? \", \" : \"\");\n    }\n    os << \"}\";\n    return os;\n}\ntemplate<typename T> ostream &operator<<(ostream &os, const deque<T> &rhs) {\n    os << \"{\";\n    for (auto itr = rhs.begin(); itr != rhs.end(); itr++) {\n        os << *itr << (next(itr) != rhs.end() ? \", \" : \"\");\n    }\n    os << \"}\";\n    return os;\n}\ntemplate<typename T> ostream &operator<<(ostream &os, const set<T> &rhs) {\n    os << \"{\";\n    for (auto itr = rhs.begin(); itr != rhs.end(); itr++) {\n        os << *itr << (next(itr) != rhs.end() ? \", \" : \"\");\n    }\n    os << \"}\";\n    return os;\n}\ntemplate<typename T, typename U> ostream &operator<<(ostream &os, const map<T, U> &rhs) {\n    os << \"{\";\n    for (auto itr = rhs.begin(); itr != rhs.end(); itr++) {\n        os << *itr << (next(itr) != rhs.end() ? \", \" : \"\");\n    }\n    os << \"}\";\n    return os;\n}\nstruct setup {\n    static constexpr int PREC = 20;\n    setup() {\n        cout << fixed << setprecision(PREC);\n        cerr << fixed << setprecision(PREC);\n    };\n} setup;\n\ntemplate<typename M>\nstruct dinic {\n    using T = typename M::T;\n    struct edge {\n        int to, rev;\n        T cap;\n        bool is_rev;\n    };\n    int n;\n    std::vector<std::vector<edge>> graph;\n    std::vector<int> level, iter;\n    void add_edge(int from, int to, T cap) {\n        graph[from].push_back({to, (int) graph[to].size(), cap, false});\n        graph[to].push_back({from, (int) graph[from].size() - 1, M::id(), true});\n    }\n    dinic(const std::vector<std::vector<int>> &adj, const std::vector<std::vector<typename M::T>> &cap)\n        : n(adj.size()), graph(n), level(n), iter(n) {\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < adj[i].size(); j++) { add_edge(i, adj[i][j], cap[i][j]); }\n        }\n    }\n    void bfs(int s) {\n        fill(level.begin(), level.end(), -1);\n        std::queue<int> que;\n        level[s] = 0;\n        que.push(s);\n        while (!que.empty()) {\n            int v = que.front();\n            que.pop();\n            for (int i = 0; i < graph[v].size(); i++) {\n                edge &e = graph[v][i];\n                if (M::is_id(e.cap) || level[e.to] >= 0) { continue; }\n                level[e.to] = level[v] + 1;\n                que.push(e.to);\n            }\n        }\n    }\n    T dfs(int v, int t, T f) {\n        if (v == t) { return f; }\n        for (int &i = iter[v]; i < graph[v].size(); i++) {\n            edge &e = graph[v][i];\n            if (level[v] >= level[e.to] || M::is_id(e.cap)) { continue; }\n            T d = dfs(e.to, t, M::gr(f, e.cap) ? e.cap : f);\n            if (M::is_id(d)) { continue; }\n            e.cap = M::op(e.cap, M::inv(d));\n            graph[e.to][e.rev].cap = M::op(graph[e.to][e.rev].cap, d);\n            return d;\n        }\n        return M::id();\n    }\n    T calc_max_flow(int s, int t, T lim) {\n        T ret = M::id();\n        while (true) {\n            bfs(s);\n            if (level[t] < 0 || M::is_id(lim)) { return ret; }\n            fill(iter.begin(), iter.end(), 0);\n            T f;\n            while (!M::is_id(f = dfs(s, t, lim))) {\n                ret = M::op(ret, f);\n                lim = M::op(lim, M::inv(f));\n            }\n        }\n    }\n    T calc_max_flow(int s, int t) { return calc_max_flow(s, t, M::ab()); }\n    std::map<std::pair<int, int>, T> get_max_flow() {\n        std::map<std::pair<int, int>, T> ret;\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < graph[i].size(); j++) {\n                edge &e = graph[i][j];\n                if (e.is_rev) { ret[{e.to, i}] = e.cap; }\n            }\n        }\n        return ret;\n    }\n    std::map<std::pair<int, int>, T> get_min_cut(int s) {\n        std::map<std::pair<int, int>, T> ret;\n        std::vector<int> visited(n);\n        std::queue<int> que;\n        que.push(s);\n        while (!que.empty()) {\n            int v = que.front();\n            que.pop();\n            if (visited[v]) { continue; }\n            visited[v] = true;\n            for (int i = 0; i < graph[v].size(); i++) {\n                edge &e = graph[v][i];\n                if (!M::is_id(e.cap)) { que.push(e.to); }\n            }\n        }\n        for (int i = 0; i < n; i++) {\n            if (visited[i]) { continue; }\n            for (int j = 0; j < graph[i].size(); j++) {\n                edge &e = graph[i][j];\n                if (e.is_rev && visited[e.to]) { ret[{e.to, i}] = e.cap; }\n            }\n        }\n        return ret;\n    }\n};\n\nstruct int_dinic {\n    using T = int;\n    static T id() { return 0; }\n    static T ab() { return std::numeric_limits<T>::max(); }\n    static T inv(const T &a) { return -a; }\n    static T op(const T &a, const T &b) { return a + b; }\n    static bool gr(const T &a, const T &b) { return a > b; }\n    static bool is_id(const T &a) { return a == id(); };\n};\n\nstd::vector<long long> get_divisors(long long n) {\n    std::vector<long long> ret;\n    long long i;\n    for (i = 1; i * i < n; i++) {\n        if (n % i == 0) {\n            ret.push_back(i);\n            ret.push_back(n / i);\n        }\n    }\n    if (i * i == n) { ret.push_back(i); }\n    std::sort(ret.begin(), ret.end());\n    return ret;\n}\n\nint N;\nint x[110];\nsigned main() {\n    cin >> N;\n    rep(i, N) { cin >> x[i]; }\n    vint v;\n    rep(i, N) {\n        if (!v.empty() && v.back() == x[i]) { v.pop_back(); }\n        else { v.emplace_back(x[i]); }\n        v.emplace_back(x[i] + 1);\n    }\n    vint even, odd;\n    rep(i, v.size()) {\n        if (v[i] & 1) { odd.emplace_back(v[i]); }\n        else { even.emplace_back(v[i]); }\n    }\n    vvint adj(330), cap(330);\n    dinic<int_dinic> dnc(adj, cap);\n    rep(i, even.size()) { dnc.add_edge(0, 100 + i, 1); }\n    rep(i, odd.size()) { dnc.add_edge(200 + i, 300, 1); }\n    rep(i, even.size()) {\n        rep(j, odd.size()) {\n            if (get_divisors(abs(even[i] - odd[j])).size() == 2) {\n                dnc.add_edge(100 + i, 200 + j, 1);\n            }\n        }\n    }\n    int f = dnc.calc_max_flow(0, 300);\n    int ans = v.size() + f;\n    if ((even.size() - f) & 1) { ans++; }\n    cout << ans-1 << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <iostream>\n#include <algorithm>\n#define fo(i,a,b) for(int i=a;i<=b;i++)\n#define fod(i,a,b) for(int i=a;i>=b;i--)\n#define N 1005\nusing namespace std;\nint l[N],n,a[N],r[N],w[N],pr[2000005],f[N],a1[N][N];\nbool bz[10000005],bp[N];\nvoid prp()\n{\n\tfo(i,2,10000000)\n\t{\n\t\tif(!bz[i]) pr[++pr[0]]=i;\n\t\tfor(int j=1;j<=pr[0]&&i*pr[j]<=10000000;j++)\n\t\t{\n\t\t\tbz[i*pr[j]]=1;\n\t\t\tif(i%pr[j]==0) break;\n\t\t}\n\t}\n\tbz[2]=0;\n}\nbool find(int k)\n{\n\tfo(i,1,a1[k][0])\n\t{\n\t\tint p=a1[k][i];\n\t\tif(!bp[p])\n\t\t{\n\t\t\tbp[p]=1;\n\t\t\tif(!f[p]||find(f[p])) \n\t\t\t{\n\t\t\t\tf[p]=k;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nint main()\n{\n\tcin>>n;\n\tprp();\n\tfo(i,1,n) scanf(\"%d\",&a[i]);\n\tsort(a+1,a+n+1);\n\tfo(i,1,n) \n\t{\n\t\tif(i==1||a[i-1]!=a[i]-1) w[++w[0]]=i;\n\t\tif(a[i+1]!=a[i]+1) w[++w[0]]=i+1;\n\t}\n\tsort(w+1,w+w[0]+1);\n\tfo(i,1,w[0]) \n\t\tif(w[i]%2==0) l[++l[0]]=i;\n\t\telse r[++r[0]]=i;\n\tfo(i,1,l[0])\n\t{\n\t\tfo(j,1,r[0])\n\t\t{\n\t\t\tif(bz[abs(l[i]-r[j])]) a1[i][++a1[i][0]]=j;\n\t\t}\n\t}\n\tint s=0;\n\tfo(i,1,l[0]) \n\t{\n\t\tmemset(bp,0,sizeof(bp));\n\t\tif(find(i)) s++;\n\t}\n\tprintf(\"%d\",s+2*(l[0]-s)/2+2*(r[0]-s)/2+3*(l[0]-s)%2);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <algorithm>\n#include <vector>\nusing std::vector;\nconst int maxn = 205;\nconst int maxm = 1e7+5;\nint n, m;\nint a[maxn], b[maxm], x[maxm], vis1[maxn], vis2[maxn];\nint is_prime[maxm], prime[maxm], cnt;\nvector<int> to[maxn];\nint X[maxn], Y[maxn], cnt1, cnt2;\nvoid pre() {\n    scanf(\"%d\", &n);\n    for(int i = 1; i <= n; i++) {\n\tscanf(\"%d\", &a[i]);\n\tm = std::max(m, a[i]);\n\tx[a[i]] = 1;\n    }\n    m++;\n    for(int i = 1; i <= m; i++) {\n\tb[i] = x[i] ^ x[i-1];\n\tif(b[i] == 1) {\n\t    if(i & 1) X[++cnt1] = i;\n\t    else Y[++cnt2] = i;\n\t}\n    }\n} \nvoid add_edge(int u, int v) {\n    to[u].push_back(v);\n}\nvoid add(int u, int v) {\n    add_edge(u, v);\n    add_edge(v, u);\n}\nvoid build_graph() {\n    for(int i = 1; i <= cnt1; i++) \n       for(int j = 1; j <= cnt2; j++) \n\t    if(!is_prime[abs(X[i] - Y[j])]) add(i, j + n); \n}\nvoid shake(int n) {\n    is_prime[1] = 1;\n    for(int i = 2; i <= n; i++) {\n\tif(!is_prime[i]) prime[++cnt] = i;\n\tfor(int j = 1; j <= cnt && i * prime[j] <= n; j++) {\n\t    is_prime[i * prime[j]] = 1;\n\t    if((i % prime[j]) == 0) break;\n\t}\n    }\n}\nbool dfs(int x) {\n    for(int i = 0; i < to[x].size(); i++) {\n\tint v = to[x][i];\n\tif(!vis1[v]) {\n\t    vis1[v] = 1;\n\t    if(vis2[v] == -1 || dfs(vis2[v])) {\n\t\tvis2[x] = v;\n\t\tvis2[v] = x;\n\t\treturn true;\n\t    }\n\t}\n    }\n    return false;\n}\nint bi() {\n    int ans = 0;\n    memset(vis2, -1, sizeof(vis1));\n    for(int i = 1; i <= cnt1; i++) {\n\tif(vis2[i] == -1) {\n\t    memset(vis1, 0, sizeof(vis1));\n\t    if(dfs(i)) ans++;\n\t}\n    }\n    return ans;\n}\nint solve() {\n    shake(m + 1);\n    build_graph();\n    return bi(); \n}\nint main() {\n#ifdef orz\n    freopen(\"input\", \"r\", stdin);\n#endif\n    pre();\n    int k = solve();\n    printf(\"%d\\n\", k + 2 * ((cnt1-k) / 2 + (cnt2-k) / 2) + 3 * ((cnt1-k) % 2));\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<string>\n#include<cmath>\nusing namespace std;\n#define clr(a) memset(a,0,sizeof(a))\n//--Container\n#include<set>\n//\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pi;\n \nstruct eg{int u,v,nx;}gp[50010];int cnt,hd[210],mth[210];bool bd[210];\nvoid psh(int u,int v){++cnt;gp[cnt].u=u,gp[cnt].v=v,gp[cnt].nx=hd[u],hd[u]=cnt;};\n \nbool fdp(int v){\n    int i;for(i=hd[v];i;i=gp[i].nx)if(!bd[gp[i].v]){\n        bd[gp[i].v]=1;\n        if(!mth[gp[i].v]||fdp(mth[gp[i].v])){\n            mth[gp[i].v]=v;\n            return 1;\n        }\n    }\n    return 0;\n};\nint hgy(int n){\n    int rs=0,i;for(clr(mth),i=1;i<=n;++i){\n        clr(bd);if(fdp(i))++rs;\n    }\n    return rs;\n};\n \nint ar[110],dr[210],cr[2][210],dn,n;\n \nbool _ck(int n){\n    if(n==1)return 0;int d=sqrt(n),i=2;for(;i<=d;++i)if(!(n%i))return 0;\n    return 1;\n};\n \nbool cl(){\n\tif(scanf(\"%d\",&n)==-1)return 0;\n    int i,j,t,a,b,k;for(i=1;i<=n;scanf(\"%d\",&ar[i++]));sort(ar+1,ar+n+1);n=unique(ar+1,ar+n+1)-ar-1;\n    for(dn=1,dr[1]=ar[1],i=2;i<=n;++i){\n        if(ar[i]==ar[i-1]+1)continue;\n        dr[++dn]=ar[i-1]+1,dr[++dn]=ar[i];\n    }\n    dr[++dn]=ar[n]+1;\n    for(a=b=0,i=1;i<=dn;++i){\n        if(dr[i]&1)cr[1][++a]=dr[i];\n        else\n            cr[0][++b]=dr[i];\n    }\n    for(cnt=0,clr(hd),i=1;i<=a;++i)for(j=1;j<=b;++j)if(_ck(abs(cr[1][i]-cr[0][j])))\n        psh(i,j);\n    t=hgy(a);\n    printf(\"%d\\n\",t+((a-t)/2*2)+((b-t)/2*2)+((a-t)%2*3));\n\treturn 1;\n};\n \nint main() {\n    while(cl());\n    return 0;\n};"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst double eps = 1e-9;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\n\n#define sz(c) int((c).size())\n#define all(c) (c).begin(), (c).end()\n#define FOR(i,a,b) for (int i = (a); i < (b); i++)\n#define FORD(i,a,b) for (int i = int(b)-1; i >= (a); i--)\n#define FORIT(i,c) for (__typeof__((c).begin()) i = (c).begin(); i != (c).end(); i++)\n#define mp make_pair\n#define pb push_back\n\nvi primes;\nbool hasEdge(int n){\n    if(n == 1)return false;\n    if(n%2 == 0)return false;\n    for(auto p: primes){\n        if(p*p > n)return true;\n        if(n%p==0)return false;\n    }\n    return true;\n}\n\nvi adj[512];\nint prev_[512];\nbool mark[512];\n\nbool find_match(int n){\n    if(n == -1)return true;\n    if(mark[n])return false;\n    mark[n] = true;\n    for(auto it: adj[n])if(find_match(prev_[it])){\n        prev_[it] = n;\n        return true;\n    }\n    return false;\n}\n\nint main(){\n    ios::sync_with_stdio(false);\n    for(int i = 3; i < 10000; i++){\n        bool ok = true;\n        for(auto p: primes)if(i%p==0){\n            ok = false;\n            break;\n        }\n        if(ok)primes.pb(i);\n    }\n    int N;\n    set<int> nums;\n    cin >> N;\n    FOR(i,0,N){\n        int x;\n        cin >> x;\n        if(nums.find(x) != nums.end())nums.erase(x);\n        else nums.insert(x);\n        if(nums.find(x+1) != nums.end())nums.erase(x+1);\n        else nums.insert(x+1);\n    }\n    vi even, odd;\n    for(auto it: nums){\n        if(it%2==0)even.pb(it);\n        else odd.pb(it);\n    }\n    int E = sz(even);\n    int O = sz(odd);\n    FOR(i,0,E)adj[i].clear();\n    FOR(e,0,E)FOR(o,0,O)if(hasEdge(abs(even[e]-odd[o]))){\n        adj[e].pb(o);\n    }\n    assert(max(E,O) < 512);\n    FOR(i,0,O)prev_[i] = -1;\n    int M = 0;\n    FOR(i,0,E){\n        FOR(j,0,E)mark[j] = 0;\n        if(find_match(i))M++;\n    }\n    int res = M;\n    E -= M;\n    O -= M;\n    res += 2 * (E / 2);\n    E%=2;\n    res += 2 * (O / 2);\n    O %= 2;\n    if(E)res += 3;\n    cout << res << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(3)\n#include<iostream>\n#include<iomanip>\n#include<stack>\n#include<queue>\n#include<list>\n#include<vector>\n#include<set> \n#include<map>\n#include<string>\n#include<algorithm>\n#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<ctime>\n#define ll long long\n#define db double\n#define inf 10000001\n#define infm 50001\n#define INF (int)1e8 \n#define mod (int)(1e9+7)\n#define pi acos(-1)\n#define rd(n) {n=0;char ch;int f=0;do{ch=getchar();if(ch=='-'){f=1;}}while(ch<'0'||ch>'9');while('0'<=ch&&ch<='9'){n=(n<<1)+(n<<3)+ch-48;ch=getchar();}if(f)n=-n;}\nusing namespace std;\n\nint p[inf],ckp[inf],pcnt;\nconst int lim=10000000;\n\nvoid pre_work(void){\n    ckp[0]=ckp[1]=1;\n    for (int i=2;i<=lim;i++){\n        if (!ckp[i]){\n            p[++pcnt]=i;\n        }\n        for (int j=1;j<=pcnt && p[j]*i<=lim;j++){\n            ckp[p[j]*i]=1;\n            if (i%p[j]==0){\n                break;\n            }\n        }\n    }\n    return;\n}\n\nint S,T;\n\nstruct edge{\n    int nxt,y,s;\n}e[infm*2];\nint ecnt=1,head[infm],h[infm];\n\nvoid addedge(int x,int y,int s){\n    ecnt++;\n    e[ecnt].nxt=head[x];\n    e[ecnt].y=y;\n    e[ecnt].s=s;\n    head[x]=ecnt;\n    return;\n}\n\nvoid ae(int x,int y,int s){\n    addedge(x,y,s);\n    addedge(y,x,0);\n    return;\n}\n\nqueue <int> q;\nint dep[inf];\n\nint dfs(int u,int flow){\n    if (!flow || u==T){\n        return flow;\n    }\n    int ans=0;\n    for (int i=h[u];i;i=e[i].nxt){\n        h[u]=i;\n        int v=e[i].y,s=e[i].s,now;\n        if (dep[v]!=dep[u]+1){\n            continue;\n        }\n        now=dfs(v,min(flow,s));\n        if (now){\n            ans+=now;\n            flow-=now;\n            e[i].s-=now;\n            e[i^1].s+=now;\n            if (!flow){\n                break;\n            }\n        }\n    }\n    return ans;\n}\n\nint dinic(void){\n    int ans=0;\n    while (1){\n        while (!q.empty()){\n            q.pop();\n        }\n        memcpy(h,head,sizeof(head));\n        memset(dep,-1,sizeof(dep));\n        dep[S]=0;\n        q.push(S);\n        while (!q.empty()){\n            int u=q.front(),v,s;\n            q.pop();\n            for (int i=head[u];i;i=e[i].nxt){\n                v=e[i].y,s=e[i].s;\n                if (dep[v]<0 && s){\n                    dep[v]=dep[u]+1;\n                    q.push(v);\n                }\n            }\n        }\n        if (dep[T]<0){\n            break;\n        }\n        ans+=dfs(S,INF);\n    }\n    return ans;\n}\n\nint n;\nint a[inf];\nint L[inf],R[inf];\n\nint main(){\n    pre_work();\n    rd(n)\n    int x,mx=0;\n    for (int i=1;i<=n;i++){\n        rd(x)\n        a[x]++;\n        mx=max(mx,x);\n    }\n    int cntl=0,cntr=0;\n    for (int i=1;i<=mx+1;i++){\n        if (a[i]!=a[i-1]){\n            if (i&1){\n                L[++cntl]=i;\n            }\n            else{\n                R[++cntr]=i;\n            }\n        }\n    }\n    S=0,T=cntl+cntr+1;\n    for (int i=1;i<=cntl;i++){\n        ae(S,i,1);\n    }\n    for (int i=1;i<=cntr;i++){\n        ae(i+cntl,T,1);\n    }\n    for (int i=1;i<=cntl;i++){\n        for (int j=1;j<=cntr;j++){\n            if (!ckp[abs(L[i]-R[j])]){\n                ae(i,j+cntl,1);\n            }\n        }\n    }\n    int mxf=dinic();\n    int ans=mxf;\n    ans+=(cntl-mxf)/2*2+(cntr-mxf)/2*2;\n    ans+=((cntl-mxf)&1)*3;\n    printf(\"%d\\n\",ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nconst int N=1005,INF=~0u>>2;\nint b[N],n,vis[N],lk[N],even[N],odd[N],even_num,odd_num,ans,k,tot,tim,v[N][N];\nint abs(int x){return x>0?x:-x;}\nbool find(int x){\n\tvis[x]=tim;\n\tfor(int i=1;i<=even_num;++i){\n\t\tif(v[x][i]&&vis[lk[i]]!=tim){\n\t\t\tif(!lk[i]||find(lk[i])) return lk[i]=x,1;\n\t\t}\n\t}\n\treturn 0;\n}\nbool check(int x){\n\tif(x==1) return 0;\n\tfor(int i=2;i*i<=x;++i){\n\t\tif(x%i==0) return 0;\n\t}\n\treturn 1;\n}\nvoid solve(int x){\n\tif(x&1) odd[++odd_num]=x;\n\telse even[++even_num]=x;\n}\nint main(){\n//\tfreopen(\"ex.in\",\"r\",stdin);\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;++i) scanf(\"%d\",&b[i]);b[0]=-1;\n\tfor(int i=1;i<=n;++i){\n\t\tif(b[i]!=b[i-1]+1) solve(b[i]);\n\t\tif(b[i]+1!=b[i+1]) solve(b[i]+1);\n\t}\n\tfor(int i=1;i<=odd_num;++i)\n\t\tfor(int j=1;j<=even_num;++j)\n\t\t\tif(check(abs(even[j]-odd[i]))) v[i][j]=1;\n\tfor(int i=1;i<=odd_num;++i){\n\t\ttim++;\n\t\tif(find(i)) k++;\n\t}\n\tans=k+((even_num-k)/2+(odd_num-k)/2)*2+((odd_num-k)%2)*3;\n\tprintf(\"%d\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntemplate< typename T = int >\nT Hungarian(vector< vector< T > > &A)\n{\n  const T infty = numeric_limits< T >::max();\n  const int N = (int) A.size() - 1;\n  const int M = (int) A[0].size() - 1;\n  vector< int > P(M + 1), way(M + 1);\n  vector< T > U(N + 1, 0), V(M + 1, 0), minV;\n  vector< bool > used;\n\n  for(int i = 1; i <= N; i++) {\n    P[0] = i;\n    minV.assign(M + 1, infty);\n    used.assign(M + 1, false);\n    int j0 = 0;\n    while(P[j0] != 0) {\n      int i0 = P[j0], j1 = 0;\n      used[j0] = true;\n      T delta = infty;\n      for(int j = 1; j <= M; j++) {\n        if(used[j]) continue;\n        T curr = A[i0][j] - U[i0] - V[j];\n        if(curr < minV[j]) minV[j] = curr, way[j] = j0;\n        if(minV[j] < delta) delta = minV[j], j1 = j;\n      }\n      for(int j = 0; j <= M; j++) {\n        if(used[j]) U[P[j]] += delta, V[j] -= delta;\n        else minV[j] -= delta;\n      }\n      j0 = j1;\n    }\n    do {\n      P[j0] = P[way[j0]];\n      j0 = way[j0];\n    } while(j0 != 0);\n  }\n  return (-V[0]);\n}\n\nconst int LIM = (int) 1e7;\nbool prime[LIM + 1];\n\nint main()\n{\n  prime[0] = prime[1] = true;\n  for(int i = 2; i * i <= LIM; i++) {\n    if(!prime[i]) {\n      for(int j = i + i; j <= LIM; j += i) {\n        prime[j] = true;\n      }\n    }\n  }\n\n  int N;\n  cin >> N;\n  vector< int > vs;\n  for(int i = 0; i < N; i++) {\n    int x;\n    cin >> x;\n    if(vs.empty() || vs.back() + 1 != x) {\n      vs.emplace_back(x - 1);\n      vs.emplace_back(x);\n    } else {\n      ++vs.back();\n    }\n  }\n\n  vector< int > latte, malta;\n  for(auto &p : vs) {\n    if(p & 1) latte.emplace_back(p);\n    else malta.emplace_back(p);\n  }\n\n  int ret = 0;\n\n  if(!latte.empty() && !malta.empty()) {\n    vector< vector< int > > g(latte.size() + 1, vector< int >(malta.size() + 1, 0));\n    for(int i = 0; i < latte.size(); i++) {\n      for(int j = 0; j < malta.size(); j++) {\n        if(!prime[abs(latte[i] - malta[j])]) {\n          g[i + 1][j + 1] = -1;\n        }\n      }\n    }\n    ret = -Hungarian(g);\n  }\n\n  int beet1 = latte.size() - ret;\n  int beet2 = malta.size() - ret;\n  ret += beet1 / 2 * 2;\n  ret += beet2 / 2 * 2;\n  ret += beet1 % 2 * 3;\n  cout << ret << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 209\nusing namespace std;\n\nint n,a[N],b[2],pre[N]; bool mp[N][N],bo[N],tg[10000009];\nbool isprm(int x){\n\tif (x==1) return 0;\n\tint i;\n\tfor (i=2; i*i<=x; i++) if (!(x%i)) return 0;\n\treturn 1;\n}\nbool dfs(int x){\n\tint i;\n\tfor (i=1; i<=n; i++) if (bo[i] && mp[x][i]){\n\t\tbo[i]=0;\n\t\tif (!pre[i] || dfs(pre[i])){\n\t\t\tpre[i]=x; return 1;\n\t\t}\n\t}\n\treturn 0;\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tint i,j,k;\n\tfor (i=1; i<=n; i++){\n\t\tscanf(\"%d\",&k); tg[k]=1;\n\t}\n\tfor (i=1,n=0; i<=10000001; i++)\n\t\tif (tg[i]^tg[i-1]) a[++n]=i;\n\tfor (i=1; i<=n; i++) if (a[i]&1)\n\t\tfor (j=1; j<=n; j++) if (a[j]&1^1)\n\t\t\tmp[i][j]=isprm(abs(a[i]-a[j]));\n\tint sum=0;\n\tfor (i=1; i<=n; i++) if (a[i]&1){\n\t\tmemset(bo,1,sizeof(bo));\n\t\tsum+=dfs(i);\n\t}\n\tfor (i=1; i<=n; i++) b[a[i]&1]++;\n\tb[0]-=sum; b[1]-=sum;\n\tprintf(\"%d\\n\",sum+b[0]+b[1]+(b[0]&b[1]&1));\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <set>\n#include <bitset>\nusing namespace std;\nint N;\nint x;\nset<int> S;\nvector<int> G[205];\nint L[205];\nint R[205];\nvector<int> Me,Mo;\nbitset<205> U;\nbool prime(int nr)\n{\n    if(nr<=2)return 0;\n    for(int i=2;i*i<=nr;i++)if(nr%i==0)return 0;\n    return 1;\n}\nbool pairup(int nod)\n{\n    if(U[nod])return 0;\n    U[nod]=1;\n    for(auto it:G[nod])\n    {\n        if(!R[it])\n        {\n            L[nod]=it;\n            R[it]=nod;\n            return 1;\n        }\n    }\n    for(auto it:G[nod])\n    {\n        if(pairup(R[it]))\n        {\n            L[nod]=it;\n            R[it]=nod;\n            return 1;\n        }\n    }\n    return 0;\n}\nint main()\n{\n    cin>>N;\n    for(int i=1;i<=N;i++)\n    {\n        cin>>x;\n        if(S.find(x)!=S.end())\n        {\n            S.erase(x);\n        }\n        else\n        {\n            S.insert(x);\n        }\n        S.insert(x+1);\n    }\n    for(auto it:S)\n        if(it%2==0)\n            Me.push_back(it);\n        else\n            Mo.push_back(it);\n    for(int i=0;i<Me.size();i++)\n    {\n        for(int j=0;j<Mo.size();j++)\n        {\n            if(prime(abs(Mo[j]-Me[i])))\n                G[i+1].push_back(j+1);\n        }\n    }\n    bool ok=1;\n    int k=0;\n    while(ok)\n    {\n        ok=0;\n        U.reset();\n        for(int i=0;i<Me.size();i++)\n        {\n            if(!L[i+1]&&pairup(i+1))\n            {\n                k++;\n                ok=1;\n            }\n        }\n    }\n    int rez=k+(((int)Me.size()-k)/2)*2+(((int)Mo.size()-k)/2)*2+(((int)Me.size()-k)%2)*3;\n    cout<<rez;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"O2,unroll-loops\")\n#pragma GCC target(\"avx,popcnt\")\n#include<bits/stdc++.h>\n#define all(x) x.begin(), x.end()\n#define pb push_back\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nconst int maxn = 304, mod = 1e9 + 7, i2 = (mod+1)/2;\nint n, dp[maxn], p[1<<24];\nvector<pair<int, int>> a;\nvoid sieve() {\n\tfor(int i = 2; i < 1<<24; i++) {\n\t\tif(!p[i]) p[i] = i;\n\t\tfor(ll j = i*1ll*i; j < 1<<24; j += i) if(!p[j]) p[j] = i;\n\t}\n}\nmap<int, int> meme;\nint d(int x) {\n\tassert(x < 1<<25);\n\tif(meme.count(x)) return meme[x];\n\tif(p[x] == x && x > 2) return meme[x] = 1;\n\tint t = 2 + (x&1);\n\tfor(int i = 3; x-i > 2; i++)\n\t\tif(p[i]==i&&p[x-i]==x-i) {t = 2; break;}\n\treturn meme[x] = t;\n}\nint main() {\n\tcin.tie(0)->sync_with_stdio(0);\n\tsieve();\n\tcin >> n;\n\tfor(int p = -1, x, i = 0; i < n; i++) {\n\t\tcin >> x;\n\t\tif(x-p > 1) {\n\t\t\tif(p != -1) a.push_back({x-p-1, 0});\n\t\t\ta.push_back({0, 1});\n\t\t}\n\t\tp = x;\n\t\ta.back().first++;\n\t}\n\tmemset(dp, 0x3f, sizeof dp);\n\tdp[0] = 0;\n\tfor(int i = 0; i < a.size(); i++) {\n\t\t//cout << i << \" \" << dp[i] << \" - \" << a[i].first << \" \" << a[i].second << endl;\n\t\tif(a[i].second == 0) dp[i+1] = min(dp[i+1], dp[i]);\n\t\tint c = 0, l = 0;\n\t\tfor(int j = i; j+1 <= a.size(); j++) {\n\t\t\tl += a[j].first;\n\t\t\tif(a[j].second == 0)\n\t\t\t\tc += d(a[j].first);\n\t\t\t//cout <<i << \"-> \" << j+1 << \" \" << dp[i] << \" \" << c << \" \" << d(l) << '\\n';\n\t\t\tint x=  dp[i] + c + d(l);\n\t\t\t//cout <<i << \"-> \" << j+1 << \" \" << dp[i] << \" \" << c << \" \" << d(l) << '\\n';\n\t\t\tdp[j+1] = min(dp[j+1], x);\n\t\t}\n\t}\n\tcout << dp[a.size()];\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <climits>\n#include <queue>\n#include <algorithm>\n\nusing std::queue;\nusing std::min;\n\nconst int MAXX=1e7+5,MAXN=205;\nint n,cnt_x,cnt_y;\nint x_id[MAXN],y_id[MAXN];\nbool up[MAXX];\n\nstruct node{int he,iter,dis;}d[MAXN];\nstruct line{int to,nex,cap;}ed[MAXN*MAXN<<1];\n\ninline bool is_odd_prm(int x){\n\tfor(int i=2;i*i<=x;++i){\n\t\tif(x%i==0) return false;\n\t}\n\treturn true;\n}\n\ninline void addE(int u,int v,int cap){\n\tstatic int cnt=1;\n\ted[++cnt]=(line){v,d[u].he,cap};\n\td[u].he=cnt;\n}\n\ninline int revE(int i){return i^1;}\n\ninline bool BFS(int s,int t,int n){\n\tfor(int i=1;i<=n;++i)\n\t\td[i].dis=-1;\n\tstatic queue<int> q;\n\td[s].dis=0;\n\tq.push(s);\n\tint u;\n\twhile(q.size()){\n\t\tu=q.front();\n\t\tq.pop();\n\t\tfor(int i=d[u].he,v;i;i=ed[i].nex){\n\t\t\tif(ed[i].cap==0) continue;\n\t\t\tv=ed[i].to;\n\t\t\tif(d[v].dis==-1){\n\t\t\t\td[v].dis=d[u].dis+1;\n\t\t\t\tq.push(v);\n\t\t\t}\n\t\t}\n\t}\n\treturn d[t].dis!=-1;\n}\n\nint aug(int u,int rest,const int t){\n\tif(u==t) return rest;\n\tint ret=0;\n\tfor(int &i=d[u].iter,v,cap,flow;i;i=ed[i].nex){\n\t\tv=ed[i].to,cap=ed[i].cap;\n\t\tif(d[v].dis!=d[u].dis+1 || cap==0)\n\t\t\tcontinue;\n\t\tflow=aug(v,min(cap,rest),t);\n\t\ted[i].cap-=flow,ed[revE(i)].cap+=flow;\n\t\tret+=flow,rest-=flow;\n\t\tif(rest==0) return ret;\n\t}\n\tif(ret==0) d[u].dis=-1;\n\treturn ret;\n}\n\ninline int Dinic(int s,int t,int n){\n\tint ret=0;\n\twhile(BFS(s,t,n)){\n\t\tfor(int i=1;i<=n;++i)\n\t\t\td[i].iter=d[i].he;\n\t\tret+=aug(s,INT_MAX,t);\n\t}\n\treturn ret;\n}\n\ninline void build(){\n\tfor(int i=1;i<=cnt_x;++i){\n\t\tfor(int j=1,v;j<=cnt_y;++j){\n\t\t\tif(is_odd_prm(abs(x_id[i]-y_id[j]))){\n\t\t\t\tv=j+cnt_x;\n\t\t\t\taddE(i,v,INT_MAX),addE(v,i,0);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=1,s=cnt_x+cnt_y+1;i<=cnt_x;++i)\n\t\taddE(s,i,1),addE(i,s,0);\n\tfor(int i=1,u,t=cnt_x+cnt_y+2;i<=cnt_y;++i){\n\t\tu=cnt_x+i;\n\t\taddE(u,t,1),addE(t,u,0);\n\t}\n}\n\nint main(){\n\tscanf(\"%d\",&n);\n\tint x;\n\tfor(int i=1;i<=n;++i){\n\t\tscanf(\"%d\",&x);\n\t\tup[x]=true;\n\t}\n\tfor(int i=1;i<=x+1;++i){\n\t\tif(up[i]!=up[i-1])\n\t\t\ti&1 ? x_id[++cnt_x]=i:y_id[++cnt_y]=i;\n\t}\n\tbuild();\n\tint k=Dinic((cnt_x+cnt_y)+1,cnt_x+cnt_y+2,cnt_x+cnt_y+2);\n\tprintf(\"%d\",k+((cnt_x-k)/2+(cnt_y-k)/2)*2+3*((cnt_x-k)%2 && (cnt_y-k)%2));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/********************************************************************************\n\t\n\tCode by a weak man named CYJian, and he hopes the code can get more points.\n\n\tAlgorithm: \n\n ********************************************************************************/\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\n//{{{ FAST IO AND SOME FUNCTIONS\nconst int __SIZE = 1 << 18;\nchar ibuf[__SIZE], *iS, *iT;\n\n#define ge (iS == iT ? (iT = (iS = ibuf) + fread(ibuf, 1, __SIZE, stdin), (iS == iT ? EOF : *iS++)) : *iS++)\n#define ri read_int()\n#define rl read_ll()\n#define FILE(s) freopen(s\"in\", \"r\", stdin), freopen(s\"out\", \"w\", stdout)\n\ntemplate<typename T>\ninline void read(T &x) {\n\tchar ch, t = 0; x = 0;\n\twhile(!isdigit(ch = ge)) t |= ch == '-';\n\twhile(isdigit(ch)) x = x * 10 + (ch ^ 48), ch = ge;\n\tx = t ? -x : x;\n}\ninline int read_int() { int x; return read(x), x; }\ninline ll read_ll() { ll x; return read(x), x; }\n\ntemplate<typename T> inline void chkmin(T&a, T b) { a = a < b ? a : b; }\ntemplate<typename T> inline void chkmax(T&a, T b) { a = a > b ? a : b; }\n//}}}\n\nint tot;\nint pri[5010];\nint chk[5010];\n\ninline void Sieve(int n) {\n\tchk[1] = 1;\n\tfor(int i = 2; i <= n; i++) {\n\t\tif(!chk[i]) pri[++tot] = i;\n\t\tfor(int j = 1; j <= tot; j++) {\n\t\t\tif(i * pri[j] > n) break;\n\t\t\tchk[i * pri[j]] = 1;\n\t\t\tif(i % pri[j] == 0) break;\n\t\t}\n\t}\n}\n\ninline int check(int x) {\n\tif(x <= 5000) return !chk[x];\n\tfor(int *p = pri + 1;; ++p) {\n\t\tif((*p) * (*p) > x) return 1;\n\t\tif(x % (*p) == 0) return 0;\n\t}\n}\n\nvector<int>to[210];\nint vis[210];\nint arr[210];\nint p[210];\nint tim, N;\n\ninline int Try(int x) {\n\tfor(auto u : to[x]) {\n\t\tif(arr[u] == tim) continue;\n\t\tarr[u] = tim;\n\t\tif(!vis[u] || Try(vis[u])) {\n\t\t\tvis[u] = x;\n\t\t\tvis[x] = u;\n\t\t\treturn 1;\n\t\t}\n\t} return 0;\n}\n\nint main() {\n#ifdef LOCAL\n\tFILE(\"\");\n#endif\n\n\tSieve(5000);\n\tint n = ri, ce = 0, co = 0;\n\n\tfor(int i = 1; i <= n; i++) {\n\t\tint x = ri;\n\t\tif(p[N] == x) --N;\n\t\telse p[++N] = x;\n\t\tp[++N] = x + 1;\n\t}\n\n\tfor(int i = 1; i <= N; i++) \n\t\tp[i] & 1 ? ++co : ++ce;\n\n\tfor(int i = 1; i <= N; i++)\n\t\tfor(int j = i + 1; j <= N; j++)\n\t\t\tif(((p[i] ^ p[j]) & 1) && check(p[j] - p[i]))\n\t\t\t\tto[i].push_back(j), to[j].push_back(i);\n\n\tint res = 0;\n\tfor(int i = tim = 1; i <= N; ++i, ++tim)\n\t\tif((p[i] & 1) && Try(i))\n\t\t\t--co, --ce, ++res;\n\n\tres += (co / 2 + ce / 2) << 1;\n\tif((co | ce) & 1) res += 3;\n\n\tcout << res << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// arc080_f\n#include <bits/stdc++.h>\n#ifdef LOCAL\n#include \"../cxx-prettyprint/prettyprint.hpp\"\n#endif\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\n\n#define REP(i, n) for (int (i) = 0 ; (i) < (int)(n) ; ++(i))\n#define REPN(i, m, n) for (int (i) = m ; (i) < (int)(n) ; ++(i))\n#define REP_REV(i, n) for (int (i) = (int)(n) - 1 ; (i) >= 0 ; --(i))\n#define REPN_REV(i, m, n) for (int (i) = (int)(n) - 1 ; (i) >= m ; --(i))\n#define ALL(x) x.begin(), x.end()\n\n#define INF ((1 << 29)-1)\n#define MOD (1000000007)\n\n#define print2D(h, w, arr) REP(i, h) { REP(j, w) cout << arr[i][j] << \" \"; cout << endl; }\n#define print_line(vec, n) {for(int i=0;i<(n-1);i++) cout << (vec)[i] << \" \"; cout << (vec)[(n)-1] << endl;}\ntemplate<class T> void print(const T& x){cout << x << endl;}\ntemplate<class T, class... A> void print(const T& first, const A&... rest) { cout << first << \" \"; print(rest...); }\nstruct PreMain {PreMain(){cin.tie(0);ios::sync_with_stdio(false);cout<<fixed<<setprecision(20);}} premain;\n\n// dinic\ntemplate <typename T = long long>\nstruct Dinic {\n    struct edge { int to; T cap; int rev; };\n    vector<vector<edge>> G;\n    vector<int> itr, level;\n    int n;\n    T inf;\n\n    explicit Dinic(int n): n(n), G(n) {inf=numeric_limits<T>::max();}\n\n    void add_edge(int from, int to, T cap) {\n        G[from].push_back((edge) {to, cap, (int) G[to].size()});\n        G[to].push_back((edge) {from, 0, (int) G[from].size()-1});\n    }\n\n    void bfs(int s) {\n        level.assign(n, -1);\n        queue<int> q;\n        level[s] = 0;\n        q.push(s);\n        while (!q.empty()) {\n            int v = q.front();\n            q.pop();\n            for (auto &e: G[v]) {\n                if (e.cap > 0 and level[e.to] < 0) {\n                    level[e.to] = level[v] + 1;\n                    q.push(e.to);\n                }\n            }\n        }\n    }\n\n    T dfs(int v, int t, T f) {\n        if (v == t) return f;\n        for (int& i = itr[v]; i < (int) G[v].size(); ++i) {\n            edge& e = G[v][i];\n            if (e.cap > 0 and level[v] < level[e.to]) {\n                T d = dfs(e.to, t, min(f, e.cap));\n                if (d > 0) {\n                    e.cap -= d;\n                    G[e.to][e.rev].cap += d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n\n    T max_flow(int s, int t) {\n        T ret = 0, f;\n        while (bfs(s), level[t] >= 0) {\n            itr.assign(n, 0);\n            while ((f = dfs(s, t, inf)) > 0) ret += f;\n        }\n        return ret;\n    }\n};\n\nbool is_prime(int n){\n    if (n == 1) return false;\n    for (int a=2; a*a <= n; a++) if (n % a == 0) return false;\n    return true;\n}\n\nint main() {\n#ifdef LOCAL\n    ifstream in(\"../arg.txt\"); cin.rdbuf(in.rdbuf());\n#endif\n\n    int N;\n    cin >> N;\n    vector<int> X(N);\n    REP(i, N) cin >> X[i];\n    sort(ALL(X));\n\n    vector<int> M;\n    REP(i, N){\n        M.emplace_back(X[i]);\n        while (i < N-1 && X[i]+1 == X[i+1]) i++;\n        M.emplace_back(X[i]+1);\n    }\n\n    int m = M.size();\n    Dinic<> flow(m+2);\n    int s = m, t = s+1;\n\n    int me=0, mo=0;\n    REP(i, m) {\n\n        if (M[i] % 2 == 0) {\n            flow.add_edge(s, i, 1);\n            me++;\n\n            REP(j, m){\n                int diff = abs(M[i] - M[j]);\n                if (diff >= 3 && is_prime(diff)){\n                    flow.add_edge(i, j, 1);\n                }\n            }\n\n        } else {\n            flow.add_edge(i, t, 1);\n            mo++;\n        }\n    }\n\n    int k = flow.max_flow(s, t);\n\n    int ans = 0;\n    ans += k;\n    ans += ((me-k)/2 + (mo-k)/2) * 2;\n    ans += (me-k) % 2 == 0 ? 0 : 3;\n\n    print(ans);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n#define rep(i, n) for (int i = 0; i < (int) (n); i++)\n#define reps(i, n) for (int i = 1; i <= (int) (n); i++)\n#define all(x) (x).begin(), (x).end()\n#define uniq(x) (x).erase(unique(all(x)), (x).end())\n#define bit(n) (1LL << (n))\n#define dump(x) cerr << #x \" = \" << (x) << endl\nusing vint = vector<int>;\nusing vvint = vector<vint>;\nusing pint = pair<int, int>;\nusing vpint = vector<pint>;\ntemplate<typename T> using priority_queue_rev = priority_queue<T, vector<T>, greater<T>>;\nconstexpr double PI = 3.1415926535897932384626433832795028;\nconstexpr int DY[9] = {0, 1, 0, -1, 1, 1, -1, -1, 0};\nconstexpr int DX[9] = {1, 0, -1, 0, 1, -1, -1, 1, 0};\nint sign(int x) { return (x > 0) - (x < 0); }\nint gcd(int a, int b) {\n    while (b) { swap(a %= b, b); }\n    return a;\n}\nint lcm(int a, int b) { return a / gcd(a, b) * b; }\nint cdiv(int a, int b) { return (a - 1 + b) / b; }\ntemplate<typename T> void fin(T mes) {\n    cout << mes << endl;\n    exit(0);\n}\ntemplate<typename T, typename U> bool chmax(T &a, const U &b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate<typename T, typename U> bool chmin(T &a, const U &b) {\n    if (b < a) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate<typename T, typename U> ostream &operator<<(ostream &os, const pair<T, U> &rhs) {\n    os << \"(\" << rhs.first << \", \" << rhs.second << \")\";\n    return os;\n}\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &rhs) {\n    os << \"{\";\n    for (auto itr = rhs.begin(); itr != rhs.end(); itr++) {\n        os << *itr << (next(itr) != rhs.end() ? \", \" : \"\");\n    }\n    os << \"}\";\n    return os;\n}\ntemplate<typename T> ostream &operator<<(ostream &os, const deque<T> &rhs) {\n    os << \"{\";\n    for (auto itr = rhs.begin(); itr != rhs.end(); itr++) {\n        os << *itr << (next(itr) != rhs.end() ? \", \" : \"\");\n    }\n    os << \"}\";\n    return os;\n}\ntemplate<typename T> ostream &operator<<(ostream &os, const set<T> &rhs) {\n    os << \"{\";\n    for (auto itr = rhs.begin(); itr != rhs.end(); itr++) {\n        os << *itr << (next(itr) != rhs.end() ? \", \" : \"\");\n    }\n    os << \"}\";\n    return os;\n}\ntemplate<typename T, typename U> ostream &operator<<(ostream &os, const map<T, U> &rhs) {\n    os << \"{\";\n    for (auto itr = rhs.begin(); itr != rhs.end(); itr++) {\n        os << *itr << (next(itr) != rhs.end() ? \", \" : \"\");\n    }\n    os << \"}\";\n    return os;\n}\nstruct setup {\n    static constexpr int PREC = 20;\n    setup() {\n        cout << fixed << setprecision(PREC);\n        cerr << fixed << setprecision(PREC);\n    };\n} setup;\n\ntemplate<typename M>\nstruct dinic {\n    using T = typename M::T;\n    struct edge {\n        int to, rev;\n        T cap;\n        bool is_rev;\n    };\n    int n;\n    std::vector<std::vector<edge>> graph;\n    std::vector<int> level, iter;\n    void add_edge(int from, int to, T cap) {\n        graph[from].push_back({to, (int) graph[to].size(), cap, false});\n        graph[to].push_back({from, (int) graph[from].size() - 1, M::id(), true});\n    }\n    dinic(const std::vector<std::vector<int>> &adj, const std::vector<std::vector<typename M::T>> &cap)\n        : n(adj.size()), graph(n), level(n), iter(n) {\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < adj[i].size(); j++) { add_edge(i, adj[i][j], cap[i][j]); }\n        }\n    }\n    void bfs(int s) {\n        fill(level.begin(), level.end(), -1);\n        std::queue<int> que;\n        level[s] = 0;\n        que.push(s);\n        while (!que.empty()) {\n            int v = que.front();\n            que.pop();\n            for (int i = 0; i < graph[v].size(); i++) {\n                edge &e = graph[v][i];\n                if (M::is_id(e.cap) || level[e.to] >= 0) { continue; }\n                level[e.to] = level[v] + 1;\n                que.push(e.to);\n            }\n        }\n    }\n    T dfs(int v, int t, T f) {\n        if (v == t) { return f; }\n        for (int &i = iter[v]; i < graph[v].size(); i++) {\n            edge &e = graph[v][i];\n            if (level[v] >= level[e.to] || M::is_id(e.cap)) { continue; }\n            T d = dfs(e.to, t, M::gr(f, e.cap) ? e.cap : f);\n            if (M::is_id(d)) { continue; }\n            e.cap = M::op(e.cap, M::inv(d));\n            graph[e.to][e.rev].cap = M::op(graph[e.to][e.rev].cap, d);\n            return d;\n        }\n        return M::id();\n    }\n    T calc_max_flow(int s, int t, T lim) {\n        T ret = M::id();\n        while (true) {\n            bfs(s);\n            if (level[t] < 0 || M::is_id(lim)) { return ret; }\n            fill(iter.begin(), iter.end(), 0);\n            T f;\n            while (!M::is_id(f = dfs(s, t, lim))) {\n                ret = M::op(ret, f);\n                lim = M::op(lim, M::inv(f));\n            }\n        }\n    }\n    T calc_max_flow(int s, int t) { return calc_max_flow(s, t, M::ab()); }\n    std::map<std::pair<int, int>, T> get_max_flow() {\n        std::map<std::pair<int, int>, T> ret;\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < graph[i].size(); j++) {\n                edge &e = graph[i][j];\n                if (e.is_rev) { ret[{e.to, i}] = e.cap; }\n            }\n        }\n        return ret;\n    }\n    std::map<std::pair<int, int>, T> get_min_cut(int s) {\n        std::map<std::pair<int, int>, T> ret;\n        std::vector<int> visited(n);\n        std::queue<int> que;\n        que.push(s);\n        while (!que.empty()) {\n            int v = que.front();\n            que.pop();\n            if (visited[v]) { continue; }\n            visited[v] = true;\n            for (int i = 0; i < graph[v].size(); i++) {\n                edge &e = graph[v][i];\n                if (!M::is_id(e.cap)) { que.push(e.to); }\n            }\n        }\n        for (int i = 0; i < n; i++) {\n            if (visited[i]) { continue; }\n            for (int j = 0; j < graph[i].size(); j++) {\n                edge &e = graph[i][j];\n                if (e.is_rev && visited[e.to]) { ret[{e.to, i}] = e.cap; }\n            }\n        }\n        return ret;\n    }\n};\n\nstruct int_dinic {\n    using T = int;\n    static T id() { return 0; }\n    static T ab() { return std::numeric_limits<T>::max(); }\n    static T inv(const T &a) { return -a; }\n    static T op(const T &a, const T &b) { return a + b; }\n    static bool gr(const T &a, const T &b) { return a > b; }\n    static bool is_id(const T &a) { return a == id(); };\n};\n\nstd::vector<long long> get_divisors(long long n) {\n    std::vector<long long> ret;\n    long long i;\n    for (i = 1; i * i < n; i++) {\n        if (n % i == 0) {\n            ret.push_back(i);\n            ret.push_back(n / i);\n        }\n    }\n    if (i * i == n) { ret.push_back(i); }\n    std::sort(ret.begin(), ret.end());\n    return ret;\n}\n\nint N;\nint x[110];\nsigned main() {\n    cin >> N;\n    rep(i, N) { cin >> x[i]; }\n    vint v;\n    rep(i, N) {\n        if (!v.empty() && v.back() == x[i]) { v.pop_back(); }\n        else { v.emplace_back(x[i]); }\n        v.emplace_back(x[i] + 1);\n    }\n    vint even, odd;\n    rep(i, v.size()) {\n        if (v[i] & 1) { odd.emplace_back(v[i]); }\n        else { even.emplace_back(v[i]); }\n    }\n    vvint adj(330), cap(330);\n    dinic<int_dinic> dnc(adj, cap);\n    rep(i, even.size()) { dnc.add_edge(0, 100 + i, 1); }\n    rep(i, odd.size()) { dnc.add_edge(200 + i, 300, 1); }\n    rep(i, even.size()) {\n        rep(j, odd.size()) {\n            if (get_divisors(abs(even[i] - odd[j])).size() == 2) { dnc.add_edge(100 + i, 200 + j, 1); }\n        }\n    }\n    int f = dnc.calc_max_flow(0, 300);\n    int ans = v.size() + f;\n    if ((even.size() - f) & 1) { ans++; }\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<string>\n#include<deque>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<set>\n#include<cmath>\n#include<tuple>\n#include<chrono>\n#include<functional>\n#include<iterator>\n#include<random>\n#include<unordered_set>\n#include<map>\nusing namespace std;\ntypedef long long int llint;\n#define mp make_pair\n#define mt make_tuple\n#define pub push_back\n#define puf push_front\n#define pob pop_back\n#define pof pop_front\n#define fir first\n#define sec second\n#define res resize\n#define ins insert\n#define era erase\nconst int mod=1000000007;\nconst llint big=1e18+10;\nconst long double pai=3.141592653589793238462643383279502884197;\nconst long double eps=1e-9;\ntemplate <class T,class U>void mineq(T& a,U b){if(a>b){a=b;}}\ntemplate <class T,class U>void maxeq(T& a,U b){if(a<b){a=b;}}\nint gcd(int a,int b){if(a%b==0){return b;}else return gcd(b,a%b);}\n\nstruct edge{int to,cap,rev;};\nvector<edge> G[202];\nbool used[202];\nint dfs(int v,int t,int f){\n\tif(v==t){return f;}\n\tused[v]=true;\n\tfor(int i=0;i<G[v].size();i++){\n\t\tedge &e=G[v][i];\n\t\tif(!used[e.to]&&e.cap>0){\n\t\t\tint d=dfs(e.to,t,min(f,e.cap));\n\t\t\tif(d>0){\n\t\t\t\te.cap-=d;\n\t\t\t\tG[e.to][e.rev].cap+=d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\treturn 0;\n}\nint max_flow(int s,int t){\n\tint flow=0;\n\twhile(-1){\n\t\tfor(int i=0;i<202;i++){\n\t\t\tused[i]=0;\n\t\t}\n\t\tint f=dfs(s,t,mod);\n\t\tif(f==0){return flow;}\n\t\tflow+=f;\n\t}\n}\nvoid add_edge(int from,int to,int cap){\n\tedge E;\n\tE.to=to,E.cap=cap;E.rev=(int)G[to].size();\n\tG[from].pub(E);\n\tE.to=from,E.cap=0;E.rev=(int)G[from].size()-1;\n\tG[to].pub(E);\n}\nvector<int>primelist;\nbool isprime(int it){\n\tfor(int i=0;i<primelist.size();i++){\n\t\tint p=primelist[i];\n\t\tif(p*p>it){break;}\n\t\tif(it%p==0){return false;}\n\t}\n\treturn true;\n}\nvoid primeinit(void){\n\tfor(int i=2;i<3200;i++){//root(1e7)\n\t\tif(isprime(i)){primelist.pub(i);}\n\t}\n}\n\nint main(void){\n\tllint n,i,j,q,ans=0;cin>>n;\n\t//頂点名\n\t//0 start\n\t//1~100 奇数\n\t//101~200 偶数\n\t//201 goal\n\tvector<int>flip;\n\tprimeinit();\n\tfor(i=0;i<n;i++){\n\t\tcin>>q;\n\t\tif(i==0||flip.back()!=q){flip.pub(q);}\n\t\telse{flip.pob();}\n\t\tflip.pub(q+1);\n\t}\n\tint kif[100]={0};\n\tint guf[100]={0};\n\tint kisu=0,gusu=0;\n\tfor(i=0;i<flip.size();i++){\n\t\tif(flip[i]%2==1){\n\t\t\tkif[kisu]=flip[i];kisu++;\n\t\t}else{\n\t\t\tguf[gusu]=flip[i];gusu++;\n\t\t}\n\t}\n\tfor(i=0;i<kisu;i++){\n\t\tfor(j=0;j<gusu;j++){\n\t\t\tif(isprime(abs(kif[i]-guf[j]))){\n\t\t\t\tadd_edge(i+1,j+101,1);\n\t\t\t}\n\t\t}\n\t}\n\tfor(i=0;i<kisu;i++){add_edge(0,i+1,1);}\n\tfor(i=0;i<gusu;i++){add_edge(i+101,201,1);}\n\tint match=max_flow(0,201);\n\tans+=match;\n\tans+=((kisu-match)/2)*2;\n\tans+=((gusu-match)/2)*2;\n\tif((kisu-match)%2==1){ans+=3;}\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#ifndef ONLINE_JUDGE\n#define dbg(x...) do { cout << \"\\033[32;1m \" << #x << \" -> \"; err(x); } while (0)\nvoid err() { cout << \"\\033[39;0m\" << endl; }\ntemplate<template<typename...> class T, typename t, typename... A>\nvoid err(T<t> a, A... x) { for (auto v: a) cout << v << ' '; err(x...); }\ntemplate<typename T, typename... A>\nvoid err(T a, A... x) { cout << a << ' '; err(x...); }\n#else\n#define dbg(...)\n#endif\ntypedef long long ll;\ntypedef pair<int,int> pi;\ntypedef vector<int> vi;\ntemplate<class T> using vc=vector<T>;\ntemplate<class T> using vvc=vc<vc<T>>;\ntemplate<class T> void mkuni(vector<T>&v)\n{\n    sort(v.begin(),v.end());\n    v.erase(unique(v.begin(),v.end()),v.end());\n}\ntemplate<class T>\nvoid print(T x,int suc=1)\n{\n    cout<<x;\n    if(suc==1) cout<<'\\n';\n    else cout<<' ';\n}\ntemplate<class T>\nvoid print(const vector<T>&v,int suc=1)\n{\n    for(int i=0;i<v.size();i++)\n    print(v[i],i==(int)(v.size())-1?suc:2);\n}\nconst int maxn=1e7+7;\nvi prime;\nbool vis[maxn];\nvoid db()\n{\n    for(int i=2;i<maxn;i++)\n    {\n        if(!vis[i])\n            prime.push_back(i);\n        for(auto p:prime)\n        {\n            if(i*p>=maxn) break;\n            vis[i*p]=1;\n            if(i%p==0) break;\n        }\n    }\n    vis[1]=1;\n    vis[2]=1;\n}\nint x[105];\nbool b[maxn];\nint pp[205];\nbool vv[205];\nvi even,odd;\nbool dfs(int u)\n{\n    if(vv[u]) return false;\n    vv[u]=1;\n    for(int i=0;i<odd.size();i++)\n    {\n        if(!vis[abs(even[u]-odd[i])])\n        {\n            if(pp[i]==-1||dfs(pp[i]))\n            {\n                pp[i]=i;\n                return true;\n            }\n        }\n    }\n    return false;\n}\nint main()\n{\n    db();\n    int n;\n    cin>>n;\n    for(int i=1;i<=n;i++)\n    {\n        cin>>x[i];\n        b[x[i]]^=1;\n        b[x[i]+1]^=1;\n    }\n    for(int i=1;i<maxn;i++)\n    {\n        if(b[i])\n        {\n            if(i&1) odd.push_back(i);\n            else even.push_back(i);\n        }\n    }\n    memset(pp,-1,sizeof(pp));\n    int ans=0;\n    for(int i=0;i<even.size();i++)\n    {\n        memset(vv,0,sizeof(vv));\n        if(dfs(i))\n            ans++;\n    }\n    ans=ans+((even.size()-ans)/2+(odd.size()-ans)/2)*2+(even.size()-ans)%2*3;\n    print(ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MAXN\t105\n#define MAXP\t405\n#define MAXQ\t1000005\n#define MAXV\t100000005\n#define INF\t1e9\ntemplate <typename T> void read(T &x) {\n\tx = 0; int f = 1;\n\tchar c = getchar();\n\tfor (; !isdigit(c); c = getchar()) if (c == '-') f = -f;\n\tfor (; isdigit(c); c = getchar()) x = x * 10 + c - '0';\n\tx *= f;\n}\nstruct edge {int dest, flow; unsigned home; };\nvector <edge> a[MAXP];\nunsigned curr[MAXP];\nint s, t, dist[MAXP];\nint odd, vodd[MAXN], even, veven[MAXN];\nint tot, f[MAXV], prime[MAXV];\nbool isprime[MAXV], mark[MAXV];\nvoid addedge(int x, int y, int z) {\n\ta[x].push_back((edge) {y, z, a[y].size()});\n\ta[y].push_back((edge) {x, 0, a[x].size() - 1});\n}\nbool bfs() {\n\tstatic int q[MAXP];\n\tmemset(dist, 0, sizeof(dist));\n\tint l = 0, r = 0;\n\tq[0] = s; dist[s] = 1;\n\twhile (l <= r) {\n\t\tint now = q[l];\n\t\tfor (unsigned i = 0; i < a[now].size(); i++)\n\t\t\tif (dist[a[now][i].dest] == 0 && a[now][i].flow != 0) {\n\t\t\t\tdist[a[now][i].dest] = dist[now] + 1;\n\t\t\t\tq[++r] = a[now][i].dest;\n\t\t\t}\n\t\tl++;\n\t}\n\treturn dist[t] != 0;\n}\nint dinic(int pos, int limit) {\n\tif (pos == t) return limit;\n\tint used = 0, tmp;\n\tfor (unsigned &i = curr[pos]; i < a[pos].size(); i++)\n\t\tif (dist[a[pos][i].dest] == dist[pos] + 1 && a[pos][i].flow && (tmp = dinic(a[pos][i].dest, min(limit - used, a[pos][i].flow)))) {\n\t\t\tused += tmp;\n\t\t\ta[pos][i].flow -= tmp;\n\t\t\ta[a[pos][i].dest][a[pos][i].home].flow += tmp;\n\t\t\tif (used == limit) return used;\n\t\t}\n\treturn used;\n}\nint main() {\n\tint n; read(n);\n\tfor (int i = 1; i <= n; i++) {\n\t\tint x; read(x);\n\t\tmark[x] ^= true;\n\t\tmark[x + 1] ^= true;\n\t}\n\tfor (int i = 1; i < MAXV; i++)\n\t\tif (mark[i]) {\n\t\t\tif (i & 1) vodd[++odd] = i;\n\t\t\telse veven[++even] = i;\n\t\t}\n\tfor (int i = 2; i < MAXV; i++) {\n\t\tif (f[i] == i) {\n\t\t\tf[i] = i;\n\t\t\tprime[++tot] = i;\n\t\t\tisprime[i] = true;\n\t\t}\n\t\tfor (int j = 1; j <= tot && prime[j] <= f[i]; j++) {\n\t\t\tint tmp = prime[j] * i;\n\t\t\tif (tmp >= MAXV) break;\n\t\t\tf[tmp] = prime[j];\n\t\t}\n\t}\n\ts = 0, t = odd + even + 1;\n\tfor (int i = 1; i <= odd; i++)\n\t\taddedge(s, i, 1);\n\tfor (int i = 1; i <= even; i++)\n\t\taddedge(i + odd, t, 1);\n\tfor (int i = 1; i <= odd; i++)\n\tfor (int j = 1; j <= even; j++)\n\t\tif (isprime[abs(vodd[i] - veven[j])]) addedge(i, j + odd, 1);\n\tint ans = 0;\n\twhile (bfs()) {\n\t\tmemset(curr, 0, sizeof(curr));\n\t\tans += dinic(s, INF);\n\t}\n\tcout << ans + (odd - ans) / 2 * 2 + (even - ans) / 2 * 2 + (odd - ans) % 2 * 3 << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<stack>\n#include <cstring>\nusing namespace std;\nconst int maxn = 1e7 + 100;\nint prime[maxn],primesize,phi[maxn];\nbool isprime[maxn];\nvoid getlist(int listsize)\n{\n    memset(isprime,1,sizeof(isprime));\n    isprime[1]=false;\n    for(int i=2;i<=listsize;i++)\n    {\n        if(isprime[i])prime[++primesize]=i;\n         for(int j=1;j<=primesize&&i*prime[j]<=listsize;j++)\n         {\n            isprime[i*prime[j]]=false;\n            if(i%prime[j]==0)break;\n        }\n    }\n}\n\nint x[110];\n\nint main()\n{\n    getlist(maxn-1);\n    int ans = 0,n;\n    cin>>n;\n    stack<int> S;\n    for(int i=1;i<=n;i++){\n        cin>>x[i];\n    }\n    sort(x+1,x+n+1);\n    int len = 1;\n    for(int i=2;i<=n;i++){\n        if(x[i] - x[i-1] == 1)\n            len++;\n        else{\n            S.push(len);\n            len = 1;\n        }\n    }\n    if(len) S.push(len);\n    while(S.size()){\n        int res = S.top();\n        S.pop();\n        while(res!=2 && res!=1 && res!=0 ){\n            int *sig = lower_bound(prime,prime+primesize,res);\n            res -= *(sig-1);\n            ans++;\n        }\n        if(res == 2 || res == 1)\n            ans+=2;\n    }\n    cout<<ans<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n\nconst int N=205;\nconst int inf=10000000;\n\nint n,prime[inf+5],match[N],a[N],b[N],a1,b1,tot;\nbool s[inf+5],not_prime[inf+5],vis[N],ma[N][N];\n\nvoid get_prime(int n)\n{\n\tfor (int i=2;i<=n;i++)\n\t{\n\t\tif (!not_prime[i]) prime[++tot]=i;\n\t\tfor (int j=1;j<=tot&&i*prime[j]<=n;j++)\n\t\t{\n\t\t\tnot_prime[i*prime[j]]=1;\n\t\t\tif (i%prime[j]==0) break;\n\t\t}\n\t}\n}\n\nbool find(int x)\n{\n\tfor (int i=1;i<=b1;i++)\n\t\tif (ma[x][i]&&!vis[i])\n\t\t{\n\t\t\tvis[i]=1;\n\t\t\tif (!match[i]||find(match[i]))\n\t\t\t{\n\t\t\t\tmatch[i]=x;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\treturn 0;\n}\n\nint main()\n{\n\tget_prime(inf);\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tint x;scanf(\"%d\",&x);\n\t\ts[x]=1;\n\t}\n\tfor (int i=1;i<=inf;i++)\n\t\tif (s[i]!=s[i-1])\n\t\t{\n\t\t\tif (i&1) a[++a1]=i;\n\t\t\telse b[++b1]=i;\n\t\t}\n\tfor (int i=1;i<=a1;i++)\n\t\tfor (int j=1;j<=b1;j++)\n\t\t\tif (!not_prime[abs(a[i]-b[j])]) ma[i][j]=1;\n\tint ans=0,tmp=0;\n\tfor (int i=1;i<=a1;i++)\n\t{\n\t\tmemset(vis,0,sizeof(vis));\n\t\tif (find(i)) tmp++,ans++;\n\t}\n\tans+=(a1-tmp)/2*2+(b1-tmp)/2*2;\n\tif (a1&1) ans+=3;\n\tprintf(\"%d\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\n\n#define forn(i, a, n) for (int i = (int)(a); i < (int)(n); ++i)\n#define ford(i, a, n) for (int i = (int)(n - 1); i >= (int)(a); --i)\n#define fore(i, a, n) for (int i = (int)(a); i <= (int)(n); ++i)\n#define all(a) (a).begin(), (a).end()\n#define fs first\n#define sn second\n#define trace(a)\\\n    for (auto i : a) cerr << i << ' ';\\\n    cerr << '\\n'\n#define eb emplace_back\n\n#ifndef M_PI\nconst ld M_PI = acos(-1.0);\n#endif\n\ntemplate<typename T>\ninline void setmax(T& a, T b) {\n    if (a < b) a = b;\n}\n\ntemplate<typename T>\ninline void setmin(T& a, T b) {\n    if (a > b) a = b;\n}\n\nconst ld eps = 1e-9;\nconst int INF = 2000000000;\nconst ll LINF = 1ll * INF * INF;\nconst ll MOD = 1000000007;\n\nint n, k;\nvector < vector<int> > g;\nvector<int> mt;\nvector<char> used;\n\n\nbool try_kuhn (int v) {\n    if (used[v])\n        return false;\n    used[v] = true;\n    for (size_t i=0; i<g[v].size(); ++i) {\n        int to = g[v][i];\n        if (mt[to] == -1 || try_kuhn (mt[to])) {\n            mt[to] = v;\n            return true;\n        }\n    }\n    return false;\n}\n\nbool prime(int x) {\n    if (x <= 2) return false;\n    for (int i = 2; i * i <= x; ++i)\n        if (x % i == 0)\n            return false;\n    return true;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cin >> n;\n    set<int> a;\n    forn(i, 0, n) {\n        int x;\n        cin >> x;\n        if (a.count(x)) a.erase(x);\n        else a.insert(x);\n        ++x;\n        if (a.count(x)) a.erase(x);\n        else a.insert(x);\n    }\n    g.resize(n);\n    vector<int> odds, evens;\n    for (int x : a) {\n        if (x % 2) odds.eb(x);\n        else evens.eb(x);\n    }\n    n = odds.size(), k = evens.size();\n    forn(i, 0, n) forn(j, 0, k) if (prime(abs(odds[i] - evens[j]))) {\n        g[i].eb(j);\n    }\n    mt.assign (k, -1);\n    int cnt = 0;\n    for (int v=0; v<n; ++v) {\n\tused.assign (n, false);\n\tif (try_kuhn (v)) ++cnt;\n    }\n    int ans = cnt;\n    int restO = n - cnt, restE = k - cnt;\n    assert(restO % 2 == restE % 2);\n    ans += restO / 2 * 2;\n    ans += restE / 2 * 2;\n    if (restO % 2) ans += 3;\n    cout << ans << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define maxn 205\nusing namespace std;\nint n,m,a[maxn],lk[maxn];\nvector<int>G[maxn];\nbool vis[maxn];\nbool dfs(int u){\n\tfor(int v:G[u]) if(!vis[v]){\n\t\tvis[v]=1;\n\t\tif(!lk[v]||dfs(lk[v])) return lk[v]=u,1;\n\t}\n\treturn 0;\n}\ninline bool check(int x){\n\tif(x<=2) return 0;\n\tfor(int i=2;i*i<=x;i++) if(x%i==0) return 0;\n\treturn 1;\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1,pre=-1,now;i<=n;i++,pre=now){\n\t\tscanf(\"%d\",&now);\n\t\tif(pre<now-1) a[++m]=now,a[++m]=now+1;\n\t\telse a[m]=now+1;\n\t}\n\tint cnt[2]={0},ans=0;\n\tfor(int i=1;i<=m;i++) cnt[a[i]&1]++; \n\tfor(int i=1;i<=m;i++) if(!(a[i]&1))\n\t\tfor(int j=1;j<=m;j++) if((a[j]&1)&&check(abs(a[j]-a[i])))\n\t\t\tG[i].push_back(j);\n\tfor(int i=1;i<=m;i++) if(!(a[i]&1)) memset(vis,0,sizeof vis),ans+=dfs(i);\n\tprintf(\"%d\\n\",ans+(m-2*ans)+(cnt[0]-ans)%2);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\n#define dd second\n#define mp make_pair\n#define pb push_back\n#define ff first\n#define dd second\n#define pp pair<int,int>\nusing namespace std;\n\nint n;\n\nstruct Turbo\n{\n    int n, m;\n    vector<int> lm, rm;\n    vector<bool> visited;\n    vector<vector<int>> graph;\n\n    Turbo(int n, int m)\n    {\n        this->n = n;\n        this->m = m;\n        lm.resize(n,-1); rm.resize(m,-1);\n        visited.resize(n,false);\n        graph.resize(n);\n    }\n\n    void addEdge(int a, int b)\n    {\n        graph[a].pb(b);\n    }\n\n    int bestMatching()\n    {\n        int res = 0;\n        while(1)\n        {\n            bool change = false;\n            for(int i = 0; i < n; ++i) visited[i] = false;\n            for(int i = 0; i < n; ++i)\n            {\n                if(lm[i] == -1 and findPath(i))\n                {\n                    res++;\n                    change = true;\n                }\n            }\n            if(!change) break;\n        }\n        return res;\n    }\n\n    bool findPath(int x)\n    {\n        if(visited[x]) return false;\n        visited[x] = true;\n        for(auto &i:graph[x])\n        {\n            if(rm[i] == -1 or findPath(rm[i]))\n            {\n                lm[x] = i;\n                rm[i] = x;\n                return true;\n            }\n        }\n        return false;\n    }\n\n};\n\nbool prime(int x)\n{\n    if(x < 3) return false;\n    for(int i = 2; i*i <= x; ++i) if(x % i == 0) return false;\n    return true;\n}\n\nmain()\n{\n    ios_base::sync_with_stdio(false);\n    cin >> n;\n    vector<int> ev, od;\n    for(int i = 0; i < n; ++i)\n    {\n        int temp; cin >> temp;\n        if(temp & 1)\n        {\n            if(od.size() > 0 and od.back() == temp) od.pop_back(); else od.pb(temp);\n            ev.pb(temp+1);\n        }\n        else\n        {\n            if(ev.size() > 0 and ev.back() == temp) ev.pop_back(); else ev.pb(temp);\n            od.pb(temp+1);\n        }\n    }\n\n    Turbo turbo(ev.size(), od.size());\n    for(int a = 0; a < ev.size(); ++a)\n        for(int b = 0; b < od.size(); ++b)\n        {\n            if(prime(abs(od[b]-ev[a]))) turbo.addEdge(a,b);\n        }\n    int k = turbo.bestMatching();\n    int ans = k + ((ev.size()-k)/2+(od.size()-k)/2) * 2 + ((ev.size()-k) % 2) * 3;\n    cout << ans << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<cmath>\n#define N 210\n#define M 1000010\nusing namespace std;\nint prime[M],link[N],tot;\nbool p[M],vis[N];\nint n;\nbool can[N][N],s[M];\nvector<int>v[2];\nbool check(int u)\n{\n\tfor(int i=1;i<=v[1].size();i++)\n\tif(can[u][i] && !vis[i])\n\t{\n\t\tvis[i]=1;\n\t\tif(!link[i] || check(link[i]))\n \t\t{\n\t\t\tlink[i]=u;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\nint main()\n{\n\tp[1]=true;\n\tfor(int i=2;i<=M-10;i++)\n\t{\n\t\tif(!p[i]) prime[++tot]=i;\n\t\tfor(int j=1;j<=tot && i*prime[j]<=N-10;j++)\n\t\t{\n\t\t\tp[i*prime[j]]=1;\n\t\t\tif(i%prime[j]==0) break;\n\t\t}\n\t}\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint u;\n\t\tscanf(\"%d\",&u);\n\t\ts[u]=true;\n\t}\n\tfor(int i=2;i<=M-10;i++)\n\tif(s[i]^s[i-1]) v[i&1].push_back(i);\n\tfor(int i=0;i<v[0].size();i++)\n\t\tfor(int j=0;j<v[1].size();j++)\n\t\tif(!p[abs(v[0][i]-v[1][j])]) can[i+1][j+1]=true;\n\tint ans=0;\n    for(int i=0;i<v[0].size();i++)\n\t{\n\t\tmemset(vis,0,sizeof(vis));\n\t\tans+=check(i+1);\n\t}\n\tans+=(v[0].size()-ans)/2*2+(v[1].size()-ans)/2*2;\n    if((v[0].size()&1)!=(ans&1)) ans+=3;\n\tprintf(\"%d\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define For(i, j, k) for(int i = j; i <= k; ++i)\nusing namespace std;\n\ninline int read() {\n\tint x = 0, p = 1; char c = getchar();\n\twhile(!isdigit(c)) { if(c == '-') p = -1; c = getchar(); }\n\twhile(isdigit(c)) x = (x << 1) + (x << 3) + (c ^ 48), c = getchar();\n\treturn x *= p;\n}\n\ninline void File() {\n#ifndef ONLINE_JUDGE\n\tfreopen(\"magic.in\", \"r\", stdin);\n\tfreopen(\"magic.out\", \"w\", stdout);\n#endif\n}\n\nconst int N = 2e2 + 10, M = 1e7 + 10;\nint prime[M], isnot[M], cnt, S[M], x;\nint n, A[N], B[N], cnt1, cnt2, G[N][N];\nint match[N], vis[N];\n\ninline void Init(int n) {\n\tisnot[1] = 1;\n\tFor(i, 2, n) {\n\t\tif(!isnot[i]) prime[++cnt] = i;\n\t\tFor(j, 1, cnt) {\n\t\t\tif(1ll * i * prime[j] > n) break;\n\t\t\tisnot[i * prime[j]] = 1;\n\t\t}\n\t}\n}\n\ninline bool dfs(int x) {\n\tFor(i, 1, cnt2)\t{\n\t\tif(G[x][i] && !vis[i]) {\n\t\t\tvis[i] = 1;\n\t\t\tif(match[i] == -1 || dfs(match[i])) {\n\t\t\t\tmatch[i] = x;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\nint main() {\n\tInit(M - 5);\n\tn = read();\n\tFor(i, 1, n) S[(x = read())] ^= 1;\n\t\n\tFor(i, 1, M - 5) if(S[i] != S[i - 1]) {\n\t\tif(i & 1) A[++cnt1] = i;\n\t\telse B[++cnt2] = i;\n\t}\n\tFor(i, 1, cnt1) For(j, 1, cnt2) \n\t\tif(!isnot[abs(A[i] - B[j])]) G[i][j] = 1;\t\n\n\tmemset(match, -1, sizeof match);\n\tint res = 0, ans;\n\tFor(i, 1, cnt1) {\n\t\tFor(j, 1, cnt2) vis[i] = 0;\n\t\tif(dfs(i)) ++ res;\n\t}\n\n\tans = res + (cnt1 - res >> 1) * 2 + (cnt2 - res >> 1) * 2;\n\tif((cnt1 - res) & 1) ans += 3;\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n\n#include <iostream>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <unordered_set>\n#include <queue>\n#include <set>\n#include <algorithm>\n#include <numeric>\n#include <list>\nusing namespace std;\n\nusing QWORD  = uint64_t;\nusing SQWORD = int64_t;\nusing DWORD  = uint32_t;\nusing SDWORD = int32_t;\nusing WORD   = uint16_t;\nusing SWORD  = int16_t;\nusing BYTE   = uint8_t;\nusing SBYTE  = int8_t;\nusing DOUBLE = double;\nusing FLOAT  = float;\n\n#define MIN_SDWORD (-2147483648)\n#define MAX_SDWORD (2147483647)\n#define MIN_SBYTE (-128)\n#define MAX_SBYTE (127)\n\n#define MIN_SQWORD (0x8000000000000000)\n#define MAX_SQWORD (0x7FFFFFFFFFFFFFFF)\n\n#define MAX_QWORD  (0xFFFFFFFFFFFFFFFF)\n#define MAX_DWORD  (0xFFFFFFFF)\n#define MAX_WORD   (0xFFFF)\n#define MAX_BYTE   (0xFF)\n\n#define MAX_DOUBLE      (1.0e+308)\n#define DOUBLE_EPS      (1.0e-12)\n#define MIN_DOUBLE_N    (-1.0e+308)\n\n#define ArrayLength(a)  (sizeof(a) / sizeof(a[0]))\n\nstatic inline DOUBLE MAX(DOUBLE a, DOUBLE b) { return a > b ? a : b; }\nstatic inline QWORD MAX(QWORD a, QWORD b) { return a > b ? a : b; }\nstatic inline DWORD MAX(DWORD a, DWORD b) { return a > b ? a : b; }\nstatic inline SDWORD MAX(SDWORD a, SDWORD b) { return a > b ? a : b; }\nstatic inline DOUBLE MIN(DOUBLE a, DOUBLE b) { return a < b ? a : b; }\nstatic inline QWORD MIN(QWORD a, QWORD b) { return a < b ? a : b; }\nstatic inline DWORD MIN(DWORD a, DWORD b) { return a < b ? a : b; }\nstatic inline SDWORD MIN(SDWORD a, SDWORD b) { return a < b ? a : b; }\nstatic inline DOUBLE ABS(DOUBLE a) { return 0 < a ? a : -a; };\n\n#define BYTE_BITS   (8)\n#define WORD_BITS   (16)\n#define DWORD_BITS  (32)\n#define QWORD_BITS  (64)\n\nstatic inline void inputStringSpSeparated(char *pcStr)\n{\n    char *pcCur = pcStr;\n    for (;;) {\n        char c = getchar();\n        if (('\\n' == c) || (EOF == c) || (' ' == c)) {\n            break;\n        }\n        *pcCur = c;\n        pcCur++;\n    }\n    *pcCur = '\\0';\n}\n\nstatic inline void inputString(char *pcStr)\n{\n    char *pcCur = pcStr;\n    for (;;) {\n        char c = getchar();\n        if (('\\n' == c) || (EOF == c)) {\n            break;\n        }\n        *pcCur = c;\n        pcCur++;\n    }\n    *pcCur = '\\0';\n}\n\n\nstatic inline SQWORD inputSQWORD(void)\n{\n    SQWORD sqNumber = 0;\n    SQWORD sqMultiplier = 1;\n    bool bRead = false;\n    for (;;) {\n        char c = getchar();\n        if (!bRead) {\n            if ('-' == c) {\n                sqMultiplier = -1;\n            }\n        }\n        if (('0' <= c) && (c <= '9')) {\n            sqNumber *= 10LL;\n            sqNumber += (SQWORD)(c - '0');\n            bRead = true;\n        } else {\n            if (bRead) {\n                return sqNumber * sqMultiplier;\n            }\n        }\n    }\n}\n\n\nstatic inline SDWORD inputSDWORD(void)\n{\n    SDWORD lNumber = 0;\n    SDWORD lMultiplier = 1;\n    bool bRead = false;\n    for (;;) {\n        char c = getchar();\n        if (!bRead) {\n            if ('-' == c) {\n                lMultiplier = -1;\n            }\n        }\n        if (('0' <= c) && (c <= '9')) {\n            lNumber *= 10;\n            lNumber += (c - '0');\n            bRead = true;\n        } else {\n            if (bRead) {\n                return lNumber * lMultiplier;\n            }\n        }\n    }\n}\n\nstatic inline DOUBLE inputFP(void)\n{\n    DOUBLE dInt = 0.0;\n    DOUBLE dFrac = 0.0;\n    DOUBLE dMultiplier = 1.0;\n    DWORD dwFpCnt = 0;\n    DOUBLE *pdCur = &dInt;\n    bool bRead = false;\n    for (;;) {\n        char c = getchar();\n        if (!bRead) {\n            if ('-' == c) {\n                dMultiplier = -1;\n            }\n        }\n        if ('.' == c) {\n            pdCur = &dFrac;\n        } else if (('0' <= c) && (c <= '9')) {\n            (*pdCur) *= 10;\n            (*pdCur) += (DOUBLE)(c - '0');\n            bRead = true;\n            if (pdCur == &dFrac) {\n                dwFpCnt++;\n            }\n        } else {\n            if (bRead) {\n                return dMultiplier * (dInt + dFrac / (pow((DOUBLE)10.0 , (DOUBLE)dwFpCnt)));\n            }\n        }\n    }\n}\n\n\n/**\n *  mod による操作ライブラリ\n */\n\n#define ANS_MOD (1000000007LL)\n \nstatic SQWORD addMod(SQWORD x, SQWORD y)\n{ \n    return (x + y) % ANS_MOD;\n}\n \nstatic SQWORD subMod(SQWORD x, SQWORD y)\n{\n    return (x - y + ANS_MOD) % ANS_MOD;\n}\n \nstatic SQWORD mulMod(SQWORD x, SQWORD y) \n{\n    return (x * y) % ANS_MOD;\n}\n \nstatic SQWORD powMod(SQWORD x, SQWORD e) {\n    SQWORD v = 1;\n    for (; e; x = mulMod(x, x), e >>= 1) {\n        if (e & 1) {\n            v = mulMod(v, x);\n        }\n    }\n    return v;\n}\n \nstatic SQWORD divMod(SQWORD x, SQWORD y)\n{\n    return mulMod(x, powMod(y, ANS_MOD - 2));\n}\n \n \nstatic SQWORD combMod(SQWORD n, SQWORD k)\n{\n    SQWORD v=1;\n    for(SQWORD i=1; i<=k; i++) {\n        v = divMod(mulMod(v, n-i+1),i);\n    } \n    return v;\n}\n\n/*----------------------------------------------*/\n\ntypedef struct {\n    SDWORD lTo;\n    SQWORD sqCap;\n    SQWORD sqCost;\n    SDWORD lRev;\n} ST_EDGE;\n\n#define MAX_V   (202)\n\nstruct Flow {\nprivate:\n    vector<ST_EDGE> avGraph[MAX_V];\n    SDWORD  alDims[MAX_V];\n    SQWORD  sqEdgeNum;\n    SQWORD  asqDist[MAX_V];\n    SDWORD  alPrevV[MAX_V];   \n    SDWORD  alPrevEdge[MAX_V];      /*直前の頂点と辺 */\n\n    SDWORD  alDinic_Level[MAX_V];\n    SDWORD  alDinic_Iter[MAX_V];\n\npublic:\n    Flow() {\n        for (auto v: avGraph) {\n            v.clear();\n        }\n        memset(alDims, 0, sizeof(alDims));\n        memset(asqDist, 0, sizeof(asqDist));\n        memset(alPrevV, 0, sizeof(alPrevV)); \n        memset(alPrevEdge, 0, sizeof(alPrevEdge));\n        memset(alDinic_Level, 0, sizeof(alDinic_Level));\n        memset(alDinic_Iter, 0, sizeof(alDinic_Iter));\n    }\n    void addEdge(SDWORD lFrom, SDWORD lTo, SQWORD sqCap, SQWORD sqCost) {\n//        printf(\"%d ----[%lld] ----> %d\\n\", lFrom, sqCap, lTo);\n        \n        alDims[lFrom]++;\n        avGraph[lFrom].push_back((ST_EDGE){lTo, sqCap, sqCost, (SDWORD)(avGraph[lTo].size())});\n        avGraph[lTo].push_back((ST_EDGE){lFrom, 0, -sqCost, (SDWORD)(avGraph[lFrom].size() - 1)});\n    }\n\n    SDWORD minCostFlow(SDWORD lStart, SDWORD lTarget, SQWORD sqFlow)\n    {\n        SQWORD sqRes = 0;\n        SQWORD sqFlowRest = sqFlow;\n        while (0 < sqFlowRest) {\n            /* Bellman-Ford Method */\n            fill(asqDist, asqDist + ArrayLength(asqDist), MAX_SDWORD);\n            asqDist[lStart] = 0;\n            bool bIsUpdate = true;\n            while (bIsUpdate) {\n                bIsUpdate = false;\n                for (SDWORD lV = 0; lV < MAX_V; lV++) {\n                    for (SDWORD lIdx = 0; lIdx < avGraph[lV].size(); lIdx++) {\n                        ST_EDGE &stE = avGraph[lV][lIdx];\n                        if ((asqDist[lV] != MAX_SDWORD)\n                                && (0 < stE.sqCap)\n                                && (asqDist[lV] + stE.sqCost < asqDist[stE.lTo])) {\n                            asqDist[stE.lTo] = asqDist[lV] + stE.sqCost;\n                            alPrevV[stE.lTo] = lV;\n                            alPrevEdge[stE.lTo] = lIdx;\n                            bIsUpdate = true;\n                        }\n                    }\n                }\n            }\n            if (asqDist[lTarget] == MAX_SDWORD) {\n                return -1;\n            }\n\n            SQWORD sqAddFlow = MAX_SQWORD;\n            for (SDWORD lV = lTarget; lV != lStart; lV = alPrevV[lV]) {\n                sqAddFlow = min(sqAddFlow, avGraph[alPrevV[lV]][alPrevEdge[lV]].sqCap);\n            }\n            sqFlowRest -= sqAddFlow;\n            sqRes += sqAddFlow * asqDist[lTarget];      // 後で目的変数は書き換える\n            for (SDWORD lV = lTarget; lV != lStart; lV = alPrevV[lV]) {\n                ST_EDGE &stE = avGraph[alPrevV[lV]][alPrevEdge[lV]];\n                stE.sqCap -= sqAddFlow;\n                avGraph[lV][stE.lRev].sqCap += sqAddFlow;\n            }\n        }\n        return sqRes;\n    }\n\nprivate:\n    SQWORD maxFlowDinicBfs(SDWORD lS)\n    {\n        memset(alDinic_Level, -1, sizeof(alDinic_Level));\n        queue<SDWORD> queSearch;\n        alDinic_Level[lS] = 0;\n        queSearch.push(lS);\n        while (!queSearch.empty()) {\n            SDWORD lV = queSearch.front();\n            queSearch.pop();\n            for (SDWORD lIdx = 0; lIdx < avGraph[lV].size(); lIdx++) {\n                ST_EDGE &stE = avGraph[lV][lIdx];\n                if ((0 < stE.sqCap) && (alDinic_Level[stE.lTo] < 0)) {\n                    alDinic_Level[stE.lTo] = alDinic_Level[lV] + 1;\n                    queSearch.push(stE.lTo);\n                }\n            }\n        }\n\n        return 0;\n    }\n\n    SQWORD maxFlowDinicDfs(SDWORD lV, SDWORD lT, SQWORD sqF)\n    {\n        if (lV == lT) {\n            return sqF;\n        }\n        for (SDWORD &lI = alDinic_Iter[lV]; lI < avGraph[lV].size(); lI++) {\n            ST_EDGE &stE = avGraph[lV][lI];\n            if ((0 < stE.sqCap) && (alDinic_Level[lV] < alDinic_Level[stE.lTo])) {\n                SQWORD sqDiffFlow = maxFlowDinicDfs(stE.lTo, lT, min(sqF, stE.sqCap));\n                if (0 < sqDiffFlow) {\n                    stE.sqCap -= sqDiffFlow;\n                    avGraph[stE.lTo][stE.lRev].sqCap += sqDiffFlow;\n                    return sqDiffFlow;\n                }\n            }\n        }\n        return 0;\n    }\n\npublic:\n    SQWORD MaxFlow(SDWORD lStart, SDWORD lTarget)\n    {\n        SQWORD sqFlow = 0LL;\n        for (;;) {\n            maxFlowDinicBfs(lStart);\n            if (alDinic_Level[lTarget] < 0) {\n                return sqFlow;\n            }\n            memset(alDinic_Iter, 0, sizeof(alDinic_Iter));\n            while (1) {\n                SQWORD sqDiffFlow = maxFlowDinicDfs(lStart, lTarget, MAX_SQWORD);\n                sqFlow += sqDiffFlow;\n                if (0LL == sqDiffFlow) {\n                    break;\n                }\n            }\n        }\n    }\n\n    SQWORD getFlow(SDWORD lPnt)\n    {\n        SQWORD sqCapSum = 0; \n        for (auto e: avGraph[lPnt]) {\n            sqCapSum += e.sqCap;\n        }\n        return alDims[lPnt] - sqCapSum;\n    }\n};\n\n/*----------------------------------------------*/\n\nstatic void getPrimes(vector<SDWORD> &vlPrimes, SDWORD lMax)\n{\n    /* lSearchMax と ループ内の *2 の関係から、入力は3以上とすること */\n    if (!(1 <= lMax)) {\n        printf(\"Oops!\");\n        return;\n    }\n\n    /* 素数のリストを作る */\n    vector<bool> vbIsPrime(lMax + 1, true);\n    SDWORD lSearchMax = sqrt(lMax) + 1;\n    vbIsPrime[0] = false;\n    vbIsPrime[1] = false;\n    for (SDWORD lPrime = 2; lPrime < vbIsPrime.size(); lPrime++) {\n        if (vbIsPrime[lPrime]) {\n            vlPrimes.emplace_back(lPrime);\n            if (lPrime <= lSearchMax) {\n                for (SDWORD lCurNum = lPrime * 2; lCurNum <= lMax; lCurNum += lPrime) {\n                    vbIsPrime[lCurNum] = false;\n                }\n            }\n        }\n    }\n}    \n\n/*----------------------------------------------*/\n\n#define PNT_NO_START    (0)\n#define PNT_NO_OFFSET   (100)\n#define PNT_NO_TARGET   (201)\n#define FLOW_OFFSET     (1000000000)\n#define CAPACITY_INF    (1000000001)\n#define DUMMY_COST      (1)\n\nint main(void)\n{\n    SQWORD sqN = inputSQWORD();\n\n    Flow solverFlow;\n    vector<SQWORD> vsqA;\n    vector<SQWORD> vsqB;\n    vector<SDWORD> vlPrimes;\n\n    getPrimes(vlPrimes, 1e7 + 1);\n    vlPrimes.erase(find(vlPrimes.begin(), vlPrimes.end(), 2));\n\n    for (SQWORD sqIdx = 0; sqIdx < sqN; sqIdx++) {\n        SQWORD sqA = inputSQWORD();\n        vsqA.emplace_back(sqA);\n    }\n\n#if 1\n    for (auto it = vsqA.begin(); it != vsqA.end(); ++it) {\n        if (it == vsqA.begin()) {\n            vsqB.emplace_back(*it);\n        } else {\n            if (*it - 1 != *(it - 1)) {\n                vsqB.emplace_back(*it);\n            }\n        }\n        if (it != vsqA.end() - 1) {\n            vsqB.emplace_back(*it + 1);\n        } else {\n            if (*it + 1 != *(it + 1)) {\n                vsqB.emplace_back(*it + 1);\n            }\n        }\n    }\n\n#else\n    vsqB = vsqA;\n#endif\n\n    vector<SQWORD> vsqCOdd;\n    vector<SQWORD> vsqCEven;\n    \n    unordered_map<SQWORD, SQWORD> mapCEven, mapCOdd;\n\n    SQWORD sqIdx = 1;\n    for (auto b: vsqB) {\n        if (0 == b % 2) {\n            vsqCEven.emplace_back(b);\n            mapCEven[b] = sqIdx;\n        } else {\n            vsqCOdd.emplace_back(b);\n            mapCOdd[b] = sqIdx;\n        }\n        sqIdx++;\n    }\n\n    /* 二部マッチング */\n    for (auto c: vsqCEven) {\n        solverFlow.addEdge(PNT_NO_START, mapCEven[c], 1, DUMMY_COST);\n    }\n    for (auto c: vsqCEven) {\n        solverFlow.addEdge(mapCOdd[c] + PNT_NO_OFFSET, PNT_NO_TARGET, 1, DUMMY_COST);\n    }\n\n    for (auto p: vlPrimes) {\n        for (auto c: vsqCEven) {\n            auto it = lower_bound(vsqCOdd.begin(), vsqCOdd.end(), c + p);\n            if (it != vsqCOdd.end()) {\n                if (*it == c + p) {\n                    if (c + p < 1e7 + 1) {\n                        solverFlow.addEdge(mapCEven[c], mapCOdd[c + p] + PNT_NO_OFFSET, 1, DUMMY_COST);\n                    }\n                }\n            }\n        }\n    }\n\n    SQWORD sqMaxFlow = solverFlow.MaxFlow(PNT_NO_START, PNT_NO_TARGET);\n    SQWORD vsqCRestEven = 0;\n    SQWORD vsqCRestOdd = 0;\n    for (auto c: vsqCEven) {\n        SQWORD sqFlow = solverFlow.getFlow(mapCEven[c]);\n        if (0 == sqFlow) {\n            vsqCRestEven++;\n        }\n    }\n    for (auto c: vsqCOdd) {\n        SQWORD sqFlow = solverFlow.getFlow(mapCOdd[c]);\n        if (0 == sqFlow) {\n            vsqCRestOdd++;\n        }\n    }\n\n    SQWORD sqAns = sqMaxFlow;    \n    sqAns += (vsqCRestEven / 2) * 2;\n    sqAns += (vsqCRestOdd / 2) * 2;\n    if (0 < (vsqCRestEven %  2)) {\n        sqAns += 3;\n    }\n\n    printf(\"%lld\\n\", sqAns);\n\n    return 0;\n}\n/*------------------------------------------*/\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nconst int N=1005,INF=~0u>>2;\nint b[N],n,vis[N],lk[N],even[N],odd[N],even_num,odd_num,ans,k,tot,tim,v[N][N];\nint abs(int x){return x>0?x:-x;}\nbool find(int x){\n\tfor(int i=1;i<=even_num;++i){\n\t\tif(v[x][i]&&vis[i]!=tim){\n\t\t\tvis[i]=tim;\n\t\t\tif(!lk[i]||find(lk[i])) return lk[i]=x,1;\n\t\t}\n\t}\n\treturn 0;\n}\n//bool find(int x){\n//\tvis[x]=tim;\n//\tfor(int i=1;i<=even_num;++i){\n//\t\tif(v[x][i]&&vis[lk[i]]!=tim){\n//\t\t\tif(!lk[i]||find(lk[i])) return lk[i]=x,1;\n//\t\t}\n//\t}\n//\treturn 0;\n//}\n//bool find(int x){\n//\tfor(int i=head[x];i;i=edge[i].nxt){\n//\t\tif(vis[edge[i].to]!=tim){\n//\t\t\tvis[edge[i].to]=tim;\n//\t\t\tif(!lk[edge[i].to]||find(edge[i].to)){\n//\t\t\t\tlk[edge[i].to]=x;\n//\t\t\t\treturn 1;\n//\t\t\t}\n//\t\t}\n//\t}\n//\treturn 0;\n//}\nbool check(int x){\n\tif(x==1) return 0;\n\tfor(int i=2;i*i<=x;++i){\n\t\tif(x%i==0) return 0;\n\t}\n\treturn 1;\n}\nvoid solve(int x){\n\tif(x&1) odd[++odd_num]=x;\n\telse even[++even_num]=x;\n}\nint main(){\n//\tfreopen(\"ex.in\",\"r\",stdin);\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;++i) scanf(\"%d\",&b[i]);b[0]=-1;\n\tfor(int i=1;i<=n;++i){\n\t\tif(b[i]!=b[i-1]+1) solve(b[i]);\n\t\tif(b[i]+1!=b[i+1]) solve(b[i]+1);\n\t}\n\tfor(int i=1;i<=odd_num;++i)\n\t\tfor(int j=1;j<=even_num;++j)\n\t\t\tif(check(abs(even[j]-odd[i]))) v[i][j]=1;\n\tfor(int i=1;i<=odd_num;++i){\n\t\ttim++;\n\t\tif(find(i)) k++;\n\t}\n\tans=k+((even_num-k)/2+(odd_num-k)/2)*2+((odd_num-k)%2)*3;\n\tprintf(\"%d\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=2e3+9,U=1e7+5;\nint n,nn,XX[N],X[N],i,j,ls,flw;\nstruct edge{int to,next,f;}e[1<<21|1];\nint h[N],cur[N],xb=1,S,T,d[N];\ninline void addedge(int x,int y,int f){\n\te[++xb]=(edge){y,h[x],f};h[x]=xb;\n\te[++xb]=(edge){x,h[y],0};h[y]=xb;\n}\ninline bool bfs(){\n\tstatic int q[N],t,w;int u,i;\n\tq[t=0,w=1]=S;memset(d+1,0,T<<2);d[S]=1;\n\tfor(;t<w;)for(i=h[u=q[++t]];i;i=e[i].next)if(e[i].f && !d[e[i].to])d[q[++w]=e[i].to]=d[u]+1;\n\treturn d[T];\n}\ninline int dfs(int x,int f){\n\tif(x==T)return f;\n\tint ans=0,&i=cur[x],t;\n\tfor(;i;i=e[i].next)if(d[e[i].to]==d[x]+1 && e[i].f && (t=dfs(e[i].to,min(f,e[i].f)))){\n\t\te[i].f-=t;e[i^1].f+=t;ans+=t;f-=t;\n\t\tif(!f)break;\n\t}\n\treturn ans;\n}\nbool b[U];\nint main(){\n\tscanf(\"%d\",&n);for(i=1;i<=n;++i)scanf(\"%d\",XX+i);\n\tfor(i=2;i<U;++i)if(!b[i])for(j=i*2;j<U;j+=i)b[j]=1;b[2]=b[1]=b[0]=1;\n\tsort(XX+1,XX+n+1);X[nn=1]=XX[1];if(n==1 || XX[1]+1<XX[2])X[++nn]=XX[1]+1;\n\tfor(i=2;i<=n;++i){\n\t\tif(XX[i]>XX[i-1]+1)X[++nn]=XX[i];\n\t\tif(i==n || XX[i]+1<XX[i+1])X[++nn]=XX[i]+1;\n\t}\n\tS=nn+1;T=S+1;\n\tfor(i=1;i<=nn;++i)if(X[i]&1){\n\t\taddedge(S,i,1);++ls;\n\t\tfor(j=1;j<=nn;++j)if(!b[abs(X[i]-X[j])])addedge(i,j,1);\n\t}else addedge(i,T,1);\n\tfor(;bfs();)memcpy(cur+1,h+1,T<<2),flw+=dfs(S,1<<25);\n\tprintf(\"%d\\n\",nn-flw+(ls-flw)%2);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstring>\n#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<queue>\n#include<stack>\n#include<cmath>\n#include<map>\n#include<complex>\n#define rep(i,l,r) for (int i=l;i<=r;i++)\n#define down(i,l,r) for (int i=l;i>=r;i--)\n#define clr(x,y) memset(x,y,sizeof(x))\n#define maxn 320500\n#define inf (int)1e9\n#define ll long long\n#define mm 1000000007\n#define eps 1e-13\n#define pb push_back\n#define low(x) x&(-x)\nusing namespace std;\n\nll read(){\n    ll x=0,f=1; char ch=getchar();\n    while (!isdigit(ch)) {if (ch=='-') f=-1; ch=getchar();}\n    while (isdigit(ch)){x=x*10+ch-'0'; ch=getchar();}\n    return x*f;\n}\nstruct data{int obj,pre,c,w;\n}e[1200500];\nint head[805],dis[805],uu[805],cur[805],a[805],b[805];\nint mp[10000005],pmp[10000005],vis[10000005],pri[1000500];\nint ans,t,tot=1,ptot,n,m;\nvoid insert(int x,int y,int c,int w){\n    e[++tot].obj=y; e[tot].pre=head[x]; e[tot].c=c; e[tot].w=w; head[x]=tot;\n    e[++tot].obj=x; e[tot].pre=head[y]; e[tot].c=0; e[tot].w=-w; head[y]=tot;\n}\n\nbool spfa(){\n    clr(uu,0);\n    rep(i,0,t) dis[i]=inf; dis[0]=0;\n   \tqueue<int> q; q.push(0);\n    while (!q.empty()){\n        int u=q.front(); q.pop(); uu[u]=1;\n        for (int j=head[u];j;j=e[j].pre){\n            int v=e[j].obj;\n            if (e[j].c>0&&dis[v]>dis[u]+e[j].w){\n                dis[v]=dis[u]+e[j].w;\n                if (uu[v]==0) uu[v]=1,q.push(v);\n            }\n        }\n        uu[u]=0;\n    }\n    if (dis[t]>=inf) return 0;\n    return 1;\n}\nint dfs(int x,int mx){\n    //if (uu[x]==1) return 0;\n    if (x==t||mx==0) return mx;\n    uu[x]=1;\n    int used=0;\n    for (int j=cur[x];j;j=e[j].pre){\n        int v=e[j].obj;\n        if (dis[v]==dis[x]+e[j].w&&e[j].c>0&&uu[v]==0){\n            int w=dfs(v,min(e[j].c,mx-used));\n            ans+=w*e[j].w; \n            e[j].c-=w; e[j^1].c+=w; used+=w;\n            cur[x]=j;\n            if (used==mx) return used;\n        }\n    }\n    return used;\n}\nint main(){\n\tfreopen(\"input.txt\",\"r\",stdin);\n//\tfreopen(\"output.txt\",\"w\",stdout);\n\tn=read();\n\tint mxn=10000001;\n\trep(i,1,n) a[i]=read(),mp[a[i]]=1;\n\t//rep(i,1,n) if (mp[a[i]-1]==mp[a[i]]) b[i]=0; else b[i]=1;\n\trep(i,1,mxn) if (mp[i]!=mp[i-1]) b[++m]=i; \n\trep(i,2,mxn) {\n\t\tif (!vis[i]) pri[++ptot]=i,vis[i]=1,pmp[i]=1;\n\t\trep(j,1,ptot) {\n\t\t\tif (i*pri[j]>mxn) break;\n\t\t\tvis[i*pri[j]]=1;\n\t\t}\n\t}\n//\trep(i,1,m) printf(\"%d \",b[i]);\n\tt=2*m+1;\n\trep(i,1,m) insert(0,i,1,0),insert(i+m,t,1,0);\n\trep(i,1,m) rep(j,1,m) {\n\t\tif (i==j) continue;\n\t\tif ((abs(b[i]-b[j])&1)==0) insert(i,j+m,1,2);\n\t\tif (abs(b[i]-b[j])&1){\n\t\t\tif (pmp[abs(b[i]-b[j])]) insert(i,j+m,1,1);\n\t\t\telse insert(i,j+m,1,3);\n\t\t}\n\t}\n\twhile (spfa()){\n        clr(uu,0); rep(i,0,t) cur[i]=head[i];\n        dfs(0,inf);\n    }\n    printf(\"%d\\n\",ans/2);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\nconst int N = 203, M = 10001003;\nbool ispri[M], vs[N];\nint a[N], tot;\nint n, Ans;\n\nvoid input() {\n\tint x, y;\n\tscanf(\"%d%d\", &n, &x);\n\ta[tot = 1] = x;\n\tfor(int i=2;i<=n;++i) {\n\t\tscanf(\"%d\", &y);\n\t\tif(x+1 != y) a[++tot] = x+1, a[++tot] = y;\n\t\tx = y;\n\t}\n\ta[++tot] = ++x;\n\t\n\tfor(int i=2;i<=x;++i) ispri[i] = true;\n\tfor(int i=2;i<=x;++i) if(ispri[i])\n\t\tfor(int j=i+i;j<=x;j+=i) ispri[j] = false;\n\tispri[2] = false;\n}\n\nnamespace Part1 {\n\tstruct Edge {int v, w, nxt;} e[N*N];\n\tint head[N], cur[N];\n\tint q[N], he, ta, dis[N];\n\tint s, t, _;\n\t\n\tinline void add(int x, int y) {\n\t\te[++_].v = y, e[_].w = 1, e[_].nxt = head[x], head[x] = _;\n\t\te[++_].v = x, e[_].w = 0, e[_].nxt = head[y], head[y] = _;\n\t}\n\t\n\tvoid init() {\n\t\ts = tot + 1, t = s + 1, _ = 1;\n\t\tfor(int i=1;i<=t;++i) head[i] = 0;\n\t}\n\t\n\tbool bfs() {\n\t\tfor(int i=1;i<=t;++i) dis[i] = -1;\n\t\tdis[q[he = ta = 1] = s] = 0;\n\t\twhile(he <= ta) {\n\t\t\tint x = q[he++];\n\t\t\tfor(int i=head[x];i;i=e[i].nxt)\n\t\t\t\tif(e[i].w and -1 == dis[e[i].v]) {\n\t\t\t\t\tdis[q[++ta] = e[i].v] = dis[x] + 1;\n\t\t\t\t\tif(e[i].v == t) return true;\n\t\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\t\n\tint dfs(int x, int flw) {\n\t\tif(x == t or !flw) return flw;\n\t\tint res = 0, tmp;\n\t\tfor(int&i=cur[x];i;i=e[i].nxt)\n\t\t\tif(e[i].w and dis[e[i].v] == dis[x] + 1)\n\t\t\tif(tmp = dfs(e[i].v, e[i].w)) {\n\t\t\t\te[i].w -= tmp, e[i^1].w += tmp, res += tmp;\n\t\t\t\tif(res == flw) return res;\n\t\t\t}\n\t\tif(!res) dis[x] = -1;\n\t\treturn res;\n\t}\n\t\n\tint Dinic() {\n\t\tconst int oo = 1e9;\n\t\tint res = 0;\n\t\twhile(bfs()) {\n\t\t\tfor(int i=1;i<=t;++i) cur[i] = head[i];\n\t\t\tres += dfs(s, +oo);\n\t\t}\n\t\treturn res;\n\t}\n\n\tinline int abs(const int x) {return x < 0 ? -x : x;}\t\n\t\n\tvoid work() {\n\t\tinit();\n\t\tfor(int i=1;i<=tot;++i)\n\t\t\tif(a[i]&1) add(s, i);\n\t\t\n\t\tfor(int i=1;i<=tot;++i) if(a[i]&1)\n\t\tfor(int j=1;j<=tot;++j) if(~a[j]&1)\n\t\t\tif(ispri[abs(a[i] - a[j])]) add(i, j);\n\t\t\n\t\tfor(int i=1;i<=tot;++i)\n\t\t\tif(~a[i]&1) add(i, t);\n\t\n\t\tAns += Dinic();\n\t\tfor(int i=head[s];i;i=e[i].nxt)\n\t\t\tif(!e[i].w) vs[e[i].v] = true;\n\t\tfor(int i=head[t];i;i=e[i].nxt)\n\t\t\tif(e[i].w) vs[e[i].v] = true;\n\t}\n}\n\nvoid Part23() {\n\tint ct[2] = {0, 0};\n\tfor(int i=1;i<=tot;++i)\n\t\tif(!vs[i]) ++ct[a[i]&1];\n\tAns += ct[0] ^ (ct[0] & 1);\n\tAns += ct[1] ^ (ct[1] & 1);\n\tAns += (ct[0] & ct[1] & 1) * 3;\n}\n\nint main() {\n\tinput();\n\t\n\tPart1::work();\n\tPart23();\n\t\n\tprintf(\"%d\\n\", Ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// This amazing code is by Eric Sunli Chen.\n#include <algorithm>\n#include <bitset>\n#include <cmath>\n#include <cstring>\n#include <cstdio>\n#include <cstdlib>\n#include <ctime>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <string>\n#include <utility>\n#include <vector>\nusing namespace std;\ntemplate<typename T> void get_int(T &x)\n{\n\tchar t=getchar();\n\tbool neg=false;\n\tx=0;\n\tfor(; (t>'9'||t<'0')&&t!='-'; t=getchar());\n\tif(t=='-')neg=true,t=getchar();\n\tfor(; t<='9'&&t>='0'; t=getchar())x=x*10+t-'0';\n\tif(neg)x=-x;\n}\ntemplate<typename T> void print_int(T x)\n{\n\tif(x<0)putchar('-'),x=-x;\n\tshort a[20]= {},sz=0;\n\twhile(x>0)a[sz++]=x%10,x/=10;\n\tif(sz==0)putchar('0');\n\tfor(int i=sz-1; i>=0; i--)putchar('0'+a[i]);\n}\n#define ff first\n#define ss second\n#define pb push_back\n#define mp make_pair\n#define get1(a) get_int(a)\n#define get2(a,b) get1(a),get1(b)\n#define get3(a,b,c) get1(a),get2(b,c)\n#define printendl(a) print_int(a),puts(\"\")\ntypedef long long LL;\ntypedef unsigned long long uLL;\ntypedef pair<int,int> pii;\nconst int inf=0x3f3f3f3f;\nconst LL Linf=1ll<<61;\nconst double pi=acos(-1.0);\n\nconst int maxn=233;\nstruct Hungary\n{\n\tvector<int> g[maxn];\n\tint match[maxn],mark[maxn],cur;\n\tbool dfs(int x)\n\t{\n\t\tmark[x]=cur;\n\t\tfor(int i=0;i<(int)g[x].size();i++)\n\t\t\tif(match[g[x][i]]==-1||(mark[match[g[x][i]]]!=cur&&dfs(match[g[x][i]])))\n\t\t\t{\n\t\t\t\tmatch[x]=g[x][i];\n\t\t\t\tmatch[g[x][i]]=x;\n\t\t\t\treturn true;\n\t\t\t}\n\t\treturn false;\n\t}\n\tint bipartite(int n)\n\t{\n\t\tmemset(match,-1,sizeof(match));\n\t\tint ret=0;\n\t\tfor(cur=1;cur<=n;cur++)if(match[cur]==-1)ret+=dfs(cur);\n\t\treturn ret;\n\t}\n}m1;\n\nint n,a[111],t[222],k;\nbool prime(int x)\n{\n\tif(x<=2||x%2==0)return false;\n\tfor(int i=3;i*i<=x;i+=2)if(x%i==0)return false;\n\treturn true;\n}\nint main()\n{\n\tget1(n);\n\ta[0]=-1;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tget1(a[i]);\n\t\tif(a[i]-1!=a[i-1])\n\t\t{\n\t\t\tif(i>1)t[++k]=a[i-1]+1;\n\t\t\tt[++k]=a[i];\n\t\t}\n\t}\n\tt[++k]=a[n]+1;\n//\tfor(int i=1;i<=k;i++)printf(\"%d \",t[i]);puts(\"\");\n\tfor(int i=1;i<=k;i++)for(int j=1;j<=k;j++)if(prime(abs(t[i]-t[j])))m1.g[i].pb(j);\n\tint c0=0,c1=0,c2=m1.bipartite(k);\n\tfor(int i=1;i<=k;i++)if(t[i]%2==0)c0++;else c1++;\n\tc0-=c2;c1-=c2;\n\tprintendl(c2+c0/2*2+c1/2*2+(c0%2)*3);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma comment(linker, \"/STACK:1024000000,1024000000\")\n#include<algorithm>\n#include<iostream>\n#include<cstring>\n#include<fstream>\n#include<bitset>\n#include<cstdio>\n#include<string>\n#include<vector>\n#include<cmath>\n#include<queue>\n#include<stack>\n#include<map>\n#include<set>\n#define INF 0X3F3F3F3F\n#define N 100005\n#define M 2000005\n#define LL long long\n#define FF(i, a, b) for(int i = a; i <= b; ++i)\n#define RR(i, a, b) for(int i = a; i >= b; --i)\n#define FJ(i, a, b) for(int i = a; i < b; ++i)\n#define SC(x) scanf(\"%d\", &x)\n#define SCC(x, y) scanf(\"%d%d\", &x, &y)\n#define SCCC(x, y, z) scanf(\"%d%d%d\", &x, &y, &z)\n#define SS(x) scanf(\"%s\", x)\n#define PR(x) printf(\"%d\\n\", x)\n#define CL(a, x) memset(a, x, sizeof(a))\n#define _P fd[rt]\n#define _L fd[rt << 1]\n#define _R fd[rt << 1 | 1]\n#define MID int mid = ((l + r) >> 1)\n#define lson rt<<1 ,l, mid\n#define rson rt<<1 | 1, mi d + 1, r\n#define PII pair<int, int>\n#define PLL pair<long long, long long>\n#define MP make_pair\n#define PB push_back\n#define IN freopen(\"in.txt\", \"r\", stdin)\n#define OUT freopen(\"out.txt\", \"w\", stdout)\nusing namespace std;\nconst int MOD = 1000000007;\nconst double PI = acos(-1.0);\nconst double EPS = 1e-8;\ninline void II(int &n){char ch = getchar(); n = 0; bool t = 0;\nfor(; ch < '0'; ch = getchar()) if(ch == '-') t = 1;\nfor(; ch >= '0'; n = n * 10 + ch - '0', ch = getchar()); if(t) n =- n;}\ninline void OO(int a){if(a < 0) {putchar('-'); a = -a;}\nif(a >= 10) OO(a / 10); putchar(a % 10 + '0');}\ninline int sgn(double x){return (x > EPS) - (x < -EPS);}\nint vis[10000005], pri[M], prn;\nvoid init(){\n    for(int i = 2; i < 10000000; ++i){\n        if(vis[i] == 0) pri[++prn] = i;\n        for(int j = 1; j <= prn && i * pri[j] <= 10000000; ++j){\n            vis[i * pri[j]] = 1;\n            if(i % pri[j] == 0) break;\n        }\n    }\n}\nint n, a[300], c[300], cnt, l[300], r[300], ln, rn;\nbool mp[300][300];\nint vv[300], link[300], ii;\nbool dfs(int u){\n    FF(v, 1, rn) if(mp[u][v]){\n        if(vv[v] != ii){\n            vv[v] = ii;\n            if(!link[v] || dfs(link[v])){\n                link[v] = u;\n                return 1;\n            }\n        }\n    }\n    return 0;\n}\nint main(){\n//    IN;\n    init();\n    vis[0] = vis[1] = vis[2] = 1;\n    SC(n);\n    FF(i, 1, n) SC(a[i]);\n    int p = 1;\n    while(p <= n){\n        c[++cnt] = a[p];\n        int pp = p;\n        while(pp < n && a[pp + 1] == a[pp] + 1) ++pp;\n        c[++cnt] = a[pp] + 1;\n        p = pp + 1;\n    }\n    FF(i, 1, cnt){\n        if(c[i] & 1) l[++ln] = c[i];\n        else r[++rn] = c[i];\n    }\n    FF(i, 1, ln)FF(j, 1, rn){\n        if(vis[abs(l[i] - r[j])] == 0) mp[i][j] = 1;\n    }\n    int s = 0;\n    for(ii = 1; ii <= ln; ++ii){\n        if(dfs(ii)){\n            ++s;\n        }\n    }\n    int ans = s;\n    ans += ((ln - s) / 2 + (rn - s) / 2) * 2;\n    ans += (ln - s) % 2 ? 3 : 0;\n    printf(\"%d\\n\", ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define REP(I, A) for (int(I) = 0; (I) < (A); (I)++)\n#define pb(I) push_back(I)\nconst int N = 10000000;\n\nset<int> s, e;\nvector<int> vx, vy, Gx[200];\nint matl[1000], matr[1000];\nbool vis[1000];\n\nbool is_prime(int x) {\n\tif(x < 3) return false;\n\tfor (int i = 3; i*i <= x; i++) if(x % i == 0) return false;\n\treturn true;\n}\n\nbool dfs(int x) {\n\tfor (int v : Gx[x]) {\n\t\tif (!vis[v]) {\n\t\t\tvis[v] = true;\n\t\t\tif (matl[v] == -1 || dfs(matl[v])) {\n\t\t\t\tmatl[v] = x;\n\t\t\t\tmatr[x] = v;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\nint domatch() {\n\tmemset(matl, -1, sizeof(matl));\n\tmemset(matr, -1, sizeof(matr));\n\tint cnt = 0;\n\tREP(i, vx.size()) {\n\t\tif (matr[i] != -1)\n\t\t\tcontinue;\n\t\tmemset(vis, 0, sizeof(vis));\n\t\tcnt += dfs(i);\n\t}\n\treturn cnt;\n}\n\nint main() {\n\tint n, x;\n\tscanf(\"%d\", &n);\n\tREP(i, n) {\n\t\tscanf(\"%d\", &x);\n\t\ts.insert(x);\n\t}\n\tfor (int u : s) {\n\t\tif (!s.count(u - 1))\n\t\t\te.insert(u);\n\t\tif (!s.count(u + 1))\n\t\t\te.insert(u + 1);\n\t}\n\tfor (int u : e)\n\t\tif (u & 1)\n\t\t\tvx.pb(u);\n\t\telse\n\t\t\tvy.pb(u);\n\tREP(i, vx.size())\n\tREP(j, vy.size())\n\tif (is_prime(abs(vx[i] - vy[j])))\n\t\tGx[i].pb(j);\n\tint t = domatch();\n\tint l1 = vx.size() - t, l2 = vy.size() - t;\n\tint res = t;\n\tres += l1 / 2 * 2;\n\tres += l2 / 2 * 2;\n\tif (l1 % 2 == 1 && l2 % 2 == 1)\n\t\tres += 3;\n\tcout << res << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<cstring>\n#include<map>\n#include<queue>\n#include<cmath>\nusing namespace std;\ntypedef long long ll;\nconst int N=1005,INF=~0u>>2;\nstruct Edge{int nxt,to;}edge[(N*N)<<3];\nint a[N],b[N<<1],n,head[N<<1],num_edge,vis[N<<1],lk[N<<1],even[N<<1],odd[N<<1],even_num,odd_num,ans,k,tot,tim;\nint read(){\n\tint x=0,f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-') f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn f*x;\n}\nvoid add_edge(int from,int to){\n\tedge[++num_edge].nxt=head[from];\n\tedge[num_edge].to=to;\n\thead[from]=num_edge;\n}\nbool find(int x){\n\tfor(int i=head[x];i;i=edge[i].nxt){\n\t\tif(vis[edge[i].to]!=tim){\n\t\t\tvis[edge[i].to]=tim;\n\t\t\tif(!lk[edge[i].to]||find(edge[i].to)){\n\t\t\t\tlk[edge[i].to]=x;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nbool check(int x){\n\tif(x==1) return 0;\n\tfor(int i=2;i*i<=x;++i){\n\t\tif(x%i==0) return 0;\n\t}\n\treturn 1;\n}\nint main(){\n//\tfreopen(\"ex.in\",\"r\",stdin);\n\tn=read();\n\tfor(int i=1;i<=n;++i) b[i]=read();b[0]=-1;\n\tfor(int i=1;i<=n;++i){\n\t\tif(b[i]!=b[i-1]+1){\n\t\t\tif(i%2) odd[++odd_num]=b[i];\n\t\t\telse even[++even_num]=b[i];\n\t\t}\n\t\tif(b[i]+1!=b[i+1]){\n\t\t\tif((i+1)%2) odd[++odd_num]=b[i]+1;\n\t\t\telse even[++even_num]=b[i]+1;\n\t\t}\n\t}\n\tfor(int i=1;i<=odd_num;++i){\n\t\tfor(int j=1;j<=even_num;++j){\n\t\t\tif(check(abs(even[j]-odd[i]))) add_edge(i,j+odd_num),add_edge(j+odd_num,i);\n\t\t}\n\t}\n\tfor(int i=1;i<=odd_num;++i){\n\t\ttim++;\n\t\tif(find(i)) k++;\n\t\telse break;\n\t}\n\tans=k+((even_num-k)/2+(odd_num-k)/2)*2+((even_num-k)%2)*3;\n\tprintf(\"%d\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define inf (1e9 + 7)\n#define mem(a, b) memset(a, b, sizeof(a))\nusing namespace std;\n\nint n, num[105], num2[205], nn = 0, ji = 0, ou = 0, lk[205], ans = 0, num3[205];\nbool vis[205];\nvector<int> eg[205];\n\nbool dfs(int u)\n{\n    int lim = eg[u].size();\n    for(int i = 0;i < lim;i++)\n    {\n        int v = eg[u][i];\n        if(!vis[v])\n        {\n            num3[++num3[0]] = v;\n            vis[v] = 1;\n            if(lk[v] == -1||dfs(lk[v]))\n            {\n                lk[v] = u;\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\nbool jg(int a)\n{\n    if(a <= 2)\n        return false;\n    for(int i = 2;i * i <= a;i++)\n    {\n        if(a % i == 0)\n            return false;\n    }\n    return true;\n}\n\nint main()\n{\n    mem(lk, -1);\n    mem(vis, 0);\n    scanf(\"%d\", &n);\n    for(int i = 1;i <= n;i++)\n        scanf(\"%d\", &num[i]);\n    sort(num + 1, num + 1 + n);\n    num2[++nn] = num[1];\n    for(int i = 2;i <= n;i++)\n    {\n        if(num[i] - 1 != num[i - 1])\n        {\n            num2[++nn] = num[i - 1] + 1;\n            num2[++nn] = num[i];\n        }\n    }\n    num2[++nn] = num[n] + 1;\n    for(int i = 1;i <= nn;i++)\n    {\n        if(num2[i] % 2 == 0)\n        {\n            ou++;\n            for(int j = i + 1;j <= nn;j++)\n            {\n                if(jg(num2[j] - num2[i]))\n                    eg[j].push_back(i);\n            }\n        }\n        else\n        {\n            ji++;\n            for(int j = i + 1;j <= nn;j++)\n            {\n                if(jg(num2[j] - num2[i]))\n                    eg[i].push_back(j);\n            }\n        }\n    }\n    int res = 0;\n    for(int i = 1;i <= nn;i++)\n    {\n        if(num2[i] % 2 == 0)\n            continue;\n        num3[0] = 0;\n        if(dfs(i))\n            res++;\n        for(int j = 1;j <= num3[0];j++)\n            vis[num3[j]] = 0;\n    }\n    ans += res;\n    ji -= res;\n    ou -= res;\n    ans += ji / 2 * 2;\n    ji %= 2;\n    ans += ou / 2 * 2;\n    ou %= 2;\n    if(ji||ou)\n        ans += 3;\n    printf(\"%d\\n\", ans);\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#pragma comment(linker, \"/STACK:1024000000,1024000000\")\n#include<algorithm>\n#include<iostream>\n#include<cstring>\n#include<fstream>\n#include<bitset>\n#include<cstdio>\n#include<string>\n#include<vector>\n#include<cmath>\n#include<queue>\n#include<stack>\n#include<map>\n#include<set>\n#define INF 0X3F3F3F3F\n#define N 100005\n#define M 2000005\n#define LL long long\n#define FF(i, a, b) for(int i = a; i <= b; ++i)\n#define RR(i, a, b) for(int i = a; i >= b; --i)\n#define FJ(i, a, b) for(int i = a; i < b; ++i)\n#define SC(x) scanf(\"%d\", &x)\n#define SCC(x, y) scanf(\"%d%d\", &x, &y)\n#define SCCC(x, y, z) scanf(\"%d%d%d\", &x, &y, &z)\n#define SS(x) scanf(\"%s\", x)\n#define PR(x) printf(\"%d\\n\", x)\n#define CL(a, x) memset(a, x, sizeof(a))\n#define _P fd[rt]\n#define _L fd[rt << 1]\n#define _R fd[rt << 1 | 1]\n#define MID int mid = ((l + r) >> 1)\n#define lson rt<<1 ,l, mid\n#define rson rt<<1 | 1, mi d + 1, r\n#define PII pair<int, int>\n#define PLL pair<long long, long long>\n#define MP make_pair\n#define PB push_back\n#define IN freopen(\"in.txt\", \"r\", stdin)\n#define OUT freopen(\"out.txt\", \"w\", stdout)\nusing namespace std;\nconst int MOD = 1000000007;\nconst double PI = acos(-1.0);\nconst double EPS = 1e-8;\ninline void II(int &n){char ch = getchar(); n = 0; bool t = 0;\nfor(; ch < '0'; ch = getchar()) if(ch == '-') t = 1;\nfor(; ch >= '0'; n = n * 10 + ch - '0', ch = getchar()); if(t) n =- n;}\ninline void OO(int a){if(a < 0) {putchar('-'); a = -a;}\nif(a >= 10) OO(a / 10); putchar(a % 10 + '0');}\ninline int sgn(double x){return (x > EPS) - (x < -EPS);}\nint vis[10000005], pri[M], prn;\nvoid init(){\n    for(int i = 2; i < 10000000; ++i){\n        if(vis[i] == 0) pri[++prn] = i;\n        for(int j = 1; j <= prn && i * pri[j] <= 10000000; ++j){\n            vis[i * pri[j]] = 1;\n            if(i % pri[j] == 0) break;\n        }\n    }\n}\nint n, a[300], c[300], cnt, l[300], r[300], ln, rn;\nbool mp[300][300];\nint vv[300], link[300], ii;\nbool dfs(int u){\n    FF(v, 1, cnt) if(mp[u][v]){\n        if(vv[v] != ii){\n            vv[v] = ii;\n            if(!link[v] || dfs(link[v])){\n                link[v] = u;\n                return 1;\n            }\n        }\n    }\n    return 0;\n}\nint main(){\n //   IN;\n    init();\n    vis[0] = vis[1] = vis[2] = 1;\n    SC(n);\n    FF(i, 1, n) SC(a[i]);\n    int p = 1;\n    while(p <= n){\n        c[++cnt] = a[p];\n        int pp = p;\n        while(pp < n && a[pp + 1] == a[pp] + 1) ++pp;\n        c[++cnt] = a[pp] + 1;\n        p = pp + 1;\n    }\n    FF(i, 1, cnt){\n        if(c[i] & 1) l[++ln] = c[i];\n        else r[++rn] = c[i];\n    }\n    FF(i, 1, cnt) FF(j, i + 1, cnt){\n        if(vis[abs(c[i] - c[j])] == 0) mp[i][j] = mp[j][i] = 1;\n    }\n    int s = 0;\n    for(ii = 1; ii <= cnt; ++ii){\n        if(dfs(ii)){\n            ++s;\n        }\n    }\n    s /= 2;\n    int ans = s;\n    ans += ((ln - s) / 2 + (rn - s) / 2) * 2;\n    ans += (ln - s) % 2 ? 3 : 0;\n    printf(\"%d\\n\", ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\n#define X first\n#define Y second\n#define pb emplace_back\n#define FOR(i,a,b) for(int (i)=(a);i<(b);++(i))\n#define EFOR(i,a,b) for(int (i)=(a);i<=(b);++(i))\n#define rep(X,Y) for (int (X) = 0;(X) < (Y);++(X))\n#define REP rep\n#define rrep(X,Y) for (int (X) = (Y)-1;(X) >=0;--(X))\n#define all(X) (X).begin(),(X).end()\n#define eb emplace_back\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef ll LL;\ntypedef pii PII;\ntypedef pll PLL;\nconst ll MOD=1e9+7;\n\n#define rall(X) (X).rbegin(),(X).rend()\n#define UNIQUE(X) (X).erase(unique(all(X)),(X).end())\n#define reps(X,S,Y) for (int (X) = S;(X) < (Y);++(X))\n#define rreps(X,S,Y) for (int (X) = (Y)-1;(X) >= (S);--(X))\ntemplate<class T> inline bool MX(T &l,const T &r){return l<r?l=r,1:0;}\ntemplate<class T> inline bool MN(T &l,const T &r){return l>r?l=r,1:0;}\n\nint N;\nbool is_composite[11451419];\nmap<int, char> mp;\n\nint GetCost(int d) {\n  if (d == 2) return 2;\n  if (!is_composite[d]) return 1;\n  if (d%2 == 0) return 2;\n  return 3;\n}\n\nsigned main(){\n  is_composite[1] = true;\n  reps(i, 2, 11451419) {\n    if (is_composite[i]) continue;\n    for (int j=i+i; j<11451419; j+=i) {\n      is_composite[j] = true;\n    }\n  }\n\n  ios_base::sync_with_stdio(false);\n  cout<<fixed<<setprecision(0);\n\n  cin >> N;\n\n  rep(i, N) {\n    int x;\n    cin >> x;\n    mp[x] ^= 1;\n    mp[x+1] ^= 1;\n  }\n\n  vector<int> vs;\n  for (auto &p : mp) {\n    if (p.Y == 0) continue;\n    vs.eb(p.X);\n  }\n  int m = vs.size();\n  assert(m%2 == 0);\n  m /= 2;\n  vector<pii> ps;\n  rep(i, m) {\n    ps.eb(pii(vs[i*2], vs[i*2+1]));\n  }\n\n  while (1) {\n    bool found = false;\n    rep(i, m) {\n      int a, b;\n      tie(a, b) = ps[i];\n      reps(j, i+1, m) {\n        int c, d;\n        tie(c, d) = ps[j];\n\n        rep(k, 2) {\n          int pr = GetCost(abs(a-b)) + GetCost(abs(c-d));\n          int af = GetCost(abs(a-c)) + GetCost(abs(b-d));\n          if (pr > af) {\n            found = true;\n            ps[i] = pii(a, c);\n            ps[j] = pii(b, d);\n            goto L_END;\n          } else if (pr == af && af == 4 && GetCost(abs(a-c))%2 && GetCost(abs(a-b))%2 == 0) {\n            found = true;\n            ps[i] = pii(a, c);\n            ps[j] = pii(b, d);\n            goto L_END;\n          }\n\n          swap(c, d);\n        }\n      }\nL_END:\n      continue;\n    }\n\n    if (!found) break;\n  }\n\n  int ans = 0;\n  rep(i, m) {\n    ans += GetCost(abs(ps[i].X-ps[i].Y));\n  }\n  cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<cstring>\n#include<map>\n#include<queue>\n#include<cmath>\nusing namespace std;\ntypedef long long ll;\nconst int N=10005,INF=~0u>>2;\nstruct Edge{int nxt,to;}edge[(N*N)<<3];\nint b[N<<1],n,head[N<<1],num_edge,vis[N<<1],lk[N<<1],even[N<<1],odd[N<<1],even_num,odd_num,ans,k,tot,tim;\nint read(){\n\tint x=0,f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-') f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn f*x;\n}\nvoid add_edge(int from,int to){\n\tedge[++num_edge].nxt=head[from];\n\tedge[num_edge].to=to;\n\thead[from]=num_edge;\n}\nbool find(int x){\n\tfor(int i=head[x];i;i=edge[i].nxt){\n\t\tif(vis[edge[i].to]!=tim){\n\t\t\tvis[edge[i].to]=tim;\n\t\t\tif(!lk[edge[i].to]||find(edge[i].to)){\n\t\t\t\tlk[edge[i].to]=x;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nbool check(int x){\n\tif(x==1) return 0;\n\tfor(int i=2;i*i<=x;++i){\n\t\tif(x%i==0) return 0;\n\t}\n\treturn 1;\n}\nint main(){\n//\tfreopen(\"ex.in\",\"r\",stdin);\n\tn=read();\n\tfor(int i=1;i<=n;++i) b[i]=read();b[0]=-1;\n\tfor(int i=1;i<=n;++i){\n\t\tif(b[i]!=b[i-1]+1){\n\t\t\tif(b[i]%2) odd[++odd_num]=b[i];\n\t\t\telse even[++even_num]=b[i];\n\t\t}\n\t\tif(b[i]+1!=b[i+1]){\n\t\t\tif((b[i]+1)%2) odd[++odd_num]=b[i]+1;\n\t\t\telse even[++even_num]=b[i]+1;\n\t\t}\n\t}\n\tfor(int i=1;i<=odd_num;++i){\n\t\tfor(int j=1;j<=even_num;++j){\n\t\t\tif(check(abs(even[j]-odd[i]))) add_edge(i,j+odd_num);\n\t\t}\n\t}\n\tfor(int i=1;i<=odd_num;++i){\n\t\ttim++;\n\t\tif(find(i)) k++;\n\t\telse break;\n\t}\n\tans=k+((even_num-k)/2+(odd_num-k)/2)*2+((even_num-k)%2)*3;\n\tprintf(\"%d\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define left lft\n\nconst int N=1e7+5;\nconst int maxn=N+10;\n\nint n,m,m0,m1,c[210],k1,left[210];\nbool vis[210];\nbool comp[maxn]; //composite\nint primes,prime[maxn/10];\n\nvoid prework()\n{\n\tint i,j;\n\tcomp[0]=comp[1]=1;\n\tfor (i=2;i<=N;i++)\n\t{\n\t\tif (!comp[i]) prime[++primes]=i;\n\t\tfor (j=1;j<=primes&&i*prime[j]<=N;j++)\n\t\t{\n\t\t\tcomp[i*prime[j]]=1;\n\t\t\tif (i%prime[j]==0) break;\n\t\t}\n\t}\n\tcomp[2]=1;\n}\n\nbool match(int u)\n{\n\tfor (int v=1;v<=m;v++)\n\t{\n\t\tif (comp[abs(u-c[v])]||vis[v]) continue;\n\t\tvis[v]=1;\n\t\tif (!left[v]||match(left[v]))\n\t\t{\n\t\t\tleft[v]=u;\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nint main()\n{\n#ifdef h10\n\tfreopen(\"F.in\",\"r\",stdin);\n\tfreopen(\"F.out\",\"w\",stdout);\n#endif\n\tint i,x;\n\tprework();\n\tscanf(\"%d\",&n);\n\tfor (i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%d\",&x);\n\t\tc[(i<<1)-1]=x;\n\t\tc[i<<1]=x+1;\n\t}\n\tsort(c+1,c+n+n+1);\n\tfor (i=1;i<=n+n;i++)\n\t\tc[i]==c[m]?m--:c[++m]=c[i];\n\tfor (i=1;i<=m;i++)\n\t\tc[i]&1?m1++:m0++;\n\tfor (i=1;i<=m;i++)\n\t{\n\t\tmemset(vis,0,sizeof(vis));\n\t\tif (c[i]&1) k1+=match(i);\n\t}\n\tm0-=k1; m1-=k1;\n\tprintf(\"%d\\n\",k1+((m0>>1)+(m1>>1))*2+(m0&1)*3);\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n\n#include <iostream>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <unordered_set>\n#include <queue>\n#include <set>\n#include <algorithm>\n#include <numeric>\n#include <list>\nusing namespace std;\n\nusing QWORD  = uint64_t;\nusing SQWORD = int64_t;\nusing DWORD  = uint32_t;\nusing SDWORD = int32_t;\nusing WORD   = uint16_t;\nusing SWORD  = int16_t;\nusing BYTE   = uint8_t;\nusing SBYTE  = int8_t;\nusing DOUBLE = double;\nusing FLOAT  = float;\n\n#define MIN_SDWORD (-2147483648)\n#define MAX_SDWORD (2147483647)\n#define MIN_SBYTE (-128)\n#define MAX_SBYTE (127)\n\n#define MIN_SQWORD (0x8000000000000000)\n#define MAX_SQWORD (0x7FFFFFFFFFFFFFFF)\n\n#define MAX_QWORD  (0xFFFFFFFFFFFFFFFF)\n#define MAX_DWORD  (0xFFFFFFFF)\n#define MAX_WORD   (0xFFFF)\n#define MAX_BYTE   (0xFF)\n\n#define MAX_DOUBLE      (1.0e+308)\n#define DOUBLE_EPS      (1.0e-12)\n#define MIN_DOUBLE_N    (-1.0e+308)\n\n#define ArrayLength(a)  (sizeof(a) / sizeof(a[0]))\n\nstatic inline DOUBLE MAX(DOUBLE a, DOUBLE b) { return a > b ? a : b; }\nstatic inline QWORD MAX(QWORD a, QWORD b) { return a > b ? a : b; }\nstatic inline DWORD MAX(DWORD a, DWORD b) { return a > b ? a : b; }\nstatic inline SDWORD MAX(SDWORD a, SDWORD b) { return a > b ? a : b; }\nstatic inline DOUBLE MIN(DOUBLE a, DOUBLE b) { return a < b ? a : b; }\nstatic inline QWORD MIN(QWORD a, QWORD b) { return a < b ? a : b; }\nstatic inline DWORD MIN(DWORD a, DWORD b) { return a < b ? a : b; }\nstatic inline SDWORD MIN(SDWORD a, SDWORD b) { return a < b ? a : b; }\nstatic inline DOUBLE ABS(DOUBLE a) { return 0 < a ? a : -a; };\n\n#define BYTE_BITS   (8)\n#define WORD_BITS   (16)\n#define DWORD_BITS  (32)\n#define QWORD_BITS  (64)\n\nstatic inline void inputStringSpSeparated(char *pcStr)\n{\n    char *pcCur = pcStr;\n    for (;;) {\n        char c = getchar();\n        if (('\\n' == c) || (EOF == c) || (' ' == c)) {\n            break;\n        }\n        *pcCur = c;\n        pcCur++;\n    }\n    *pcCur = '\\0';\n}\n\nstatic inline void inputString(char *pcStr)\n{\n    char *pcCur = pcStr;\n    for (;;) {\n        char c = getchar();\n        if (('\\n' == c) || (EOF == c)) {\n            break;\n        }\n        *pcCur = c;\n        pcCur++;\n    }\n    *pcCur = '\\0';\n}\n\n\nstatic inline SQWORD inputSQWORD(void)\n{\n    SQWORD sqNumber = 0;\n    SQWORD sqMultiplier = 1;\n    bool bRead = false;\n    for (;;) {\n        char c = getchar();\n        if (!bRead) {\n            if ('-' == c) {\n                sqMultiplier = -1;\n            }\n        }\n        if (('0' <= c) && (c <= '9')) {\n            sqNumber *= 10LL;\n            sqNumber += (SQWORD)(c - '0');\n            bRead = true;\n        } else {\n            if (bRead) {\n                return sqNumber * sqMultiplier;\n            }\n        }\n    }\n}\n\n\nstatic inline SDWORD inputSDWORD(void)\n{\n    SDWORD lNumber = 0;\n    SDWORD lMultiplier = 1;\n    bool bRead = false;\n    for (;;) {\n        char c = getchar();\n        if (!bRead) {\n            if ('-' == c) {\n                lMultiplier = -1;\n            }\n        }\n        if (('0' <= c) && (c <= '9')) {\n            lNumber *= 10;\n            lNumber += (c - '0');\n            bRead = true;\n        } else {\n            if (bRead) {\n                return lNumber * lMultiplier;\n            }\n        }\n    }\n}\n\nstatic inline DOUBLE inputFP(void)\n{\n    DOUBLE dInt = 0.0;\n    DOUBLE dFrac = 0.0;\n    DOUBLE dMultiplier = 1.0;\n    DWORD dwFpCnt = 0;\n    DOUBLE *pdCur = &dInt;\n    bool bRead = false;\n    for (;;) {\n        char c = getchar();\n        if (!bRead) {\n            if ('-' == c) {\n                dMultiplier = -1;\n            }\n        }\n        if ('.' == c) {\n            pdCur = &dFrac;\n        } else if (('0' <= c) && (c <= '9')) {\n            (*pdCur) *= 10;\n            (*pdCur) += (DOUBLE)(c - '0');\n            bRead = true;\n            if (pdCur == &dFrac) {\n                dwFpCnt++;\n            }\n        } else {\n            if (bRead) {\n                return dMultiplier * (dInt + dFrac / (pow((DOUBLE)10.0 , (DOUBLE)dwFpCnt)));\n            }\n        }\n    }\n}\n\n\n/**\n *  mod による操作ライブラリ\n */\n\n#define ANS_MOD (1000000007LL)\n \nstatic SQWORD addMod(SQWORD x, SQWORD y)\n{ \n    return (x + y) % ANS_MOD;\n}\n \nstatic SQWORD subMod(SQWORD x, SQWORD y)\n{\n    return (x - y + ANS_MOD) % ANS_MOD;\n}\n \nstatic SQWORD mulMod(SQWORD x, SQWORD y) \n{\n    return (x * y) % ANS_MOD;\n}\n \nstatic SQWORD powMod(SQWORD x, SQWORD e) {\n    SQWORD v = 1;\n    for (; e; x = mulMod(x, x), e >>= 1) {\n        if (e & 1) {\n            v = mulMod(v, x);\n        }\n    }\n    return v;\n}\n \nstatic SQWORD divMod(SQWORD x, SQWORD y)\n{\n    return mulMod(x, powMod(y, ANS_MOD - 2));\n}\n \n \nstatic SQWORD combMod(SQWORD n, SQWORD k)\n{\n    SQWORD v=1;\n    for(SQWORD i=1; i<=k; i++) {\n        v = divMod(mulMod(v, n-i+1),i);\n    } \n    return v;\n}\n\n/*----------------------------------------------*/\n\ntypedef struct {\n    SDWORD lTo;\n    SQWORD sqCap;\n    SQWORD sqCost;\n    SDWORD lRev;\n} ST_EDGE;\n\n#define MAX_V   (202)\n\nstruct Flow {\nprivate:\n    vector<ST_EDGE> avGraph[MAX_V];\n    SDWORD  alDims[MAX_V];\n    SQWORD  sqEdgeNum;\n    SQWORD  asqDist[MAX_V];\n    SDWORD  alPrevV[MAX_V];   \n    SDWORD  alPrevEdge[MAX_V];      /*直前の頂点と辺 */\n\n    SDWORD  alDinic_Level[MAX_V];\n    SDWORD  alDinic_Iter[MAX_V];\n\npublic:\n    Flow() {\n        for (auto v: avGraph) {\n            v.clear();\n        }\n        memset(alDims, 0, sizeof(alDims));\n        memset(asqDist, 0, sizeof(asqDist));\n        memset(alPrevV, 0, sizeof(alPrevV)); \n        memset(alPrevEdge, 0, sizeof(alPrevEdge));\n        memset(alDinic_Level, 0, sizeof(alDinic_Level));\n        memset(alDinic_Iter, 0, sizeof(alDinic_Iter));\n    }\n    void addEdge(SDWORD lFrom, SDWORD lTo, SQWORD sqCap, SQWORD sqCost) {\n//        printf(\"%d ----[%lld] ----> %d\\n\", lFrom, sqCap, lTo);\n        \n        alDims[lFrom]++;\n        avGraph[lFrom].push_back((ST_EDGE){lTo, sqCap, sqCost, (SDWORD)(avGraph[lTo].size())});\n        avGraph[lTo].push_back((ST_EDGE){lFrom, 0, -sqCost, (SDWORD)(avGraph[lFrom].size() - 1)});\n    }\n\n    SDWORD minCostFlow(SDWORD lStart, SDWORD lTarget, SQWORD sqFlow)\n    {\n        SQWORD sqRes = 0;\n        SQWORD sqFlowRest = sqFlow;\n        while (0 < sqFlowRest) {\n            /* Bellman-Ford Method */\n            fill(asqDist, asqDist + ArrayLength(asqDist), MAX_SDWORD);\n            asqDist[lStart] = 0;\n            bool bIsUpdate = true;\n            while (bIsUpdate) {\n                bIsUpdate = false;\n                for (SDWORD lV = 0; lV < MAX_V; lV++) {\n                    for (SDWORD lIdx = 0; lIdx < avGraph[lV].size(); lIdx++) {\n                        ST_EDGE &stE = avGraph[lV][lIdx];\n                        if ((asqDist[lV] != MAX_SDWORD)\n                                && (0 < stE.sqCap)\n                                && (asqDist[lV] + stE.sqCost < asqDist[stE.lTo])) {\n                            asqDist[stE.lTo] = asqDist[lV] + stE.sqCost;\n                            alPrevV[stE.lTo] = lV;\n                            alPrevEdge[stE.lTo] = lIdx;\n                            bIsUpdate = true;\n                        }\n                    }\n                }\n            }\n            if (asqDist[lTarget] == MAX_SDWORD) {\n                return -1;\n            }\n\n            SQWORD sqAddFlow = MAX_SQWORD;\n            for (SDWORD lV = lTarget; lV != lStart; lV = alPrevV[lV]) {\n                sqAddFlow = min(sqAddFlow, avGraph[alPrevV[lV]][alPrevEdge[lV]].sqCap);\n            }\n            sqFlowRest -= sqAddFlow;\n            sqRes += sqAddFlow * asqDist[lTarget];      // 後で目的変数は書き換える\n            for (SDWORD lV = lTarget; lV != lStart; lV = alPrevV[lV]) {\n                ST_EDGE &stE = avGraph[alPrevV[lV]][alPrevEdge[lV]];\n                stE.sqCap -= sqAddFlow;\n                avGraph[lV][stE.lRev].sqCap += sqAddFlow;\n            }\n        }\n        return sqRes;\n    }\n\nprivate:\n    SQWORD maxFlowDinicBfs(SDWORD lS)\n    {\n        memset(alDinic_Level, -1, sizeof(alDinic_Level));\n        queue<SDWORD> queSearch;\n        alDinic_Level[lS] = 0;\n        queSearch.push(lS);\n        while (!queSearch.empty()) {\n            SDWORD lV = queSearch.front();\n            queSearch.pop();\n            for (SDWORD lIdx = 0; lIdx < avGraph[lV].size(); lIdx++) {\n                ST_EDGE &stE = avGraph[lV][lIdx];\n                if ((0 < stE.sqCap) && (alDinic_Level[stE.lTo] < 0)) {\n                    alDinic_Level[stE.lTo] = alDinic_Level[lV] + 1;\n                    queSearch.push(stE.lTo);\n                }\n            }\n        }\n\n        return 0;\n    }\n\n    SQWORD maxFlowDinicDfs(SDWORD lV, SDWORD lT, SQWORD sqF)\n    {\n        if (lV == lT) {\n            return sqF;\n        }\n        for (SDWORD &lI = alDinic_Iter[lV]; lI < avGraph[lV].size(); lI++) {\n            ST_EDGE &stE = avGraph[lV][lI];\n            if ((0 < stE.sqCap) && (alDinic_Level[lV] < alDinic_Level[stE.lTo])) {\n                SQWORD sqDiffFlow = maxFlowDinicDfs(stE.lTo, lT, min(sqF, stE.sqCap));\n                if (0 < sqDiffFlow) {\n                    stE.sqCap -= sqDiffFlow;\n                    avGraph[stE.lTo][stE.lRev].sqCap += sqDiffFlow;\n                    return sqDiffFlow;\n                }\n            }\n        }\n        return 0;\n    }\n\npublic:\n    SQWORD MaxFlow(SDWORD lStart, SDWORD lTarget)\n    {\n        SQWORD sqFlow = 0LL;\n        for (;;) {\n            maxFlowDinicBfs(lStart);\n            if (alDinic_Level[lTarget] < 0) {\n                return sqFlow;\n            }\n            memset(alDinic_Iter, 0, sizeof(alDinic_Iter));\n            while (1) {\n                SQWORD sqDiffFlow = maxFlowDinicDfs(lStart, lTarget, MAX_SQWORD);\n                sqFlow += sqDiffFlow;\n                if (0LL == sqDiffFlow) {\n                    break;\n                }\n            }\n        }\n    }\n\n    SQWORD getFlow(SDWORD lPnt)\n    {\n        SQWORD sqCapSum = 0; \n        for (auto e: avGraph[lPnt]) {\n            sqCapSum += e.sqCap;\n        }\n        return alDims[lPnt] - sqCapSum;\n    }\n};\n\n/*----------------------------------------------*/\n\nstatic void getPrimes(vector<SDWORD> &vlPrimes, SDWORD lMax)\n{\n    /* lSearchMax と ループ内の *2 の関係から、入力は3以上とすること */\n    if (!(1 <= lMax)) {\n        printf(\"Oops!\");\n        return;\n    }\n\n    /* 素数のリストを作る */\n    vector<bool> vbIsPrime(lMax + 1, true);\n    SDWORD lSearchMax = sqrt(lMax) + 1;\n    vbIsPrime[0] = false;\n    vbIsPrime[1] = false;\n    for (SDWORD lPrime = 2; lPrime < vbIsPrime.size(); lPrime++) {\n        if (vbIsPrime[lPrime]) {\n            vlPrimes.emplace_back(lPrime);\n            if (lPrime <= lSearchMax) {\n                for (SDWORD lCurNum = lPrime * 2; lCurNum <= lMax; lCurNum += lPrime) {\n                    vbIsPrime[lCurNum] = false;\n                }\n            }\n        }\n    }\n}    \n\n/*----------------------------------------------*/\n\n#define PNT_NO_START    (0)\n#define PNT_NO_OFFSET   (100)\n#define PNT_NO_TARGET   (201)\n#define FLOW_OFFSET     (1000000000)\n#define CAPACITY_INF    (1000000001)\n#define DUMMY_COST      (1)\n\nint main(void)\n{\n    SQWORD sqN = inputSQWORD();\n\n    Flow solverFlow;\n    vector<SQWORD> vsqA;\n    vector<SQWORD> vsqB;\n    vector<SDWORD> vlPrimes;\n\n    getPrimes(vlPrimes, 1e7 + 1);\n    vlPrimes.erase(find(vlPrimes.begin(), vlPrimes.end(), 2));\n\n    for (SQWORD sqIdx = 0; sqIdx < sqN; sqIdx++) {\n        SQWORD sqA = inputSQWORD();\n        vsqA.emplace_back(sqA);\n    }\n\n    for (SQWORD sqIdx = 0; sqIdx < sqN; sqIdx++) {\n        if (0 < sqIdx) {\n            if (!(vsqA[sqIdx - 1] == vsqA[sqIdx] - 1)) {\n                vsqB.emplace_back(vsqA[sqIdx]);\n            }\n        } else {\n            vsqB.emplace_back(vsqA[sqIdx]);      \n        }\n        if (sqIdx < sqN - 1) {\n            if (!(vsqA[sqIdx] + 1 == vsqA[sqIdx + 1])) {\n                vsqB.emplace_back(vsqA[sqIdx] + 1);\n            }\n        } else {\n            vsqB.emplace_back(vsqA[sqIdx] + 1);\n        }\n    }\n\n    map<SQWORD, SQWORD> mapB;\n\n    for (SQWORD sqIdx = 0; sqIdx < vsqB.size(); sqIdx++) {\n        mapB[vsqB[sqIdx]] = sqIdx + 1;\n    }\n\n    /* 二部マッチング */\n    for (auto b: vsqB) {\n        solverFlow.addEdge(PNT_NO_START,            mapB[b],       1, DUMMY_COST);\n        solverFlow.addEdge(mapB[b] + PNT_NO_OFFSET, PNT_NO_TARGET, 1, DUMMY_COST);\n    }\n\n    for (auto p: vlPrimes) {\n        for (auto b: vsqB) {\n            auto it = lower_bound(vsqB.begin(), vsqB.end(), b + p);\n            if (it != vsqB.end()) {\n                if (*it == b + p) {\n                    if (b + p < 1e7 + 1) {\n                        solverFlow.addEdge(mapB[b], mapB[b + p] + PNT_NO_OFFSET, 1, DUMMY_COST);\n                    }\n                }\n            }\n        }\n    }\n\n    SQWORD sqMaxFlow = solverFlow.MaxFlow(PNT_NO_START, PNT_NO_TARGET);\n    vector<SQWORD> vsqBRestEven;\n    vector<SQWORD> vsqBRestOdd;\n    for (auto b: vsqB) {\n        SQWORD sqFlow = solverFlow.getFlow(mapB[b]);\n\n        if (0 == sqFlow) {\n            if (0 == b % 2) {\n                vsqBRestEven.emplace_back(b);\n            } else {\n                vsqBRestOdd.emplace_back(b);\n            }\n        }\n    }\n\n    SQWORD sqAns = sqMaxFlow;    \n    sqAns += (vsqBRestEven.size() / 2) * 2;\n    sqAns += (vsqBRestOdd.size() / 2) * 2;\n    if (0 < (vsqBRestEven.size() %  2)) {\n        sqAns += 3;\n    }\n\n    printf(\"%lld\\n\", sqAns);\n\n    return 0;\n}\n/*------------------------------------------*/\n"
  },
  {
    "language": "C++",
    "code": "/// d.cpp\n# include <stdio.h>\n# include <bits/stdc++.h>\nusing namespace std;\nconst pair < int , int > DD[] = {{1,0},{1,1},{0,1},{-1,1},{-1,0},{-1,-1},{0,-1},{1,-1}};\n# define fi cin\n# define fo cout\n# define x first\n# define y second\n# define ll long long\n# define IOS ios_base :: sync_with_stdio(0);cin.tie(0)\n# define p(v) cerr << #v << \" = \" << v << '\\n'\n# define p2(v) cerr << #v << \" = \" << (complex < decltype(v.x) > (v.x,v.y)) << '\\n'\n# define vi vector < int >\n# define vl vector < ll >\n# define pll pair < ll , ll >\n# define pii pair < int , int >\n# define mp make_pair\n# define db long double\n# define fail puts(\"-1\")\n# define yes puts(\"YES\")\n# define no puts(\"NO\")\n# define PP puts(\"Possible\")\n# define II puts(\"Impossible\")\n# define vii vector < pii >\n# define vll vector < pll >\n# define pb push_back\n# define pdd pair < db , db >\n# define all(s) s.begin(),s.end()\ntemplate < class T > T smin(T &a,T b) {if (a > b) a = b;return a;}\ntemplate < class T > T smax(T &a,T b) {if (a < b) a = b;return a;}\nint main(void)\n{\n    #ifdef CF\n    freopen(\"input\",\"r\",stdin);\n    #endif // CF\n    srand(time(0));\n    fo << fixed << setprecision(7);\n    cerr << fixed << setprecision(7);\n    int n;\n    fi>>n;\n    static int s[1 << 20];\n    for (int i = 1;i <= n;++i)\n        fi>>s[i];\n    static bitset < (1 << 24) > prime;\n    const int N = 1e7;\n    for (int i = 2;i <= N;++i)\n        prime[i] = 1;\n    for (int i = 2;i <= N;++i)\n        if (prime[i])\n            for (int j = i + i;j <= N;j += i)\n                prime[j] = 0;\n    auto get = [&](int k)\n    {\n        if (!k)\n            return 0;\n        if (!(k & 1))\n            return 2;\n        if (prime[k])\n            return 1;\n        return 3;\n    };\n    static int dp[1 << 20];\n    dp[0] = 0;\n    dp[1] = 1;\n    for (int i = 2;i <= n;++i)\n    {\n        dp[i] = dp[i - 1] + get(1);\n        int offset = 0;\n        for (int j = i;j;--j)\n        {\n            offset += get(s[j] - s[j - 1] - 1);\n            smin(dp[i],offset + dp[j - 1] + get(s[i] - s[j - 1]));\n            if (j >= 2)\n                smin(dp[i],offset + dp[j - 2] + get(s[i] - s[j - 1] + 1));\n        }\n    }\n    fo << dp[n] << '\\n';\n    cerr << \"Time elapsed :\" << clock() * 1000.0 / CLOCKS_PER_SEC << \" ms\" << '\\n';\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntemplate<typename T> read(T &x)\n{\n\tchar ch=getchar();\n\tfor (x=0;ch<'0'||ch>'9';ch=getchar());\n\tfor (;ch>='0'&&ch<='9';x=x*10+ch-'0',ch=getchar());\n}\n#define INF 0x3f3f3f3f\nvector<int> odd,even;\nbool vis[10000010];\nint prime[1000010],p_cnt;\nint n;\nint a[110];\nnamespace Network\n{\n\tstruct edge{\n\t\tint s,t,cap,next;\n\t}e[100010];\n\tint head[510],cnt;\n\tvoid addedge(int s,int t,int cap)\n\t{\n\t\te[cnt].s=s;e[cnt].t=t;e[cnt].cap=cap;e[cnt].next=head[s];head[s]=cnt++;\n\t\te[cnt].s=t;e[cnt].t=s;e[cnt].cap=0;e[cnt].next=head[t];head[t]=cnt++;\n\t}\n\tqueue<int> q;\n\tint s,t;\n\tint dis[510]; \n\tbool bfs()\n\t{\n\t\tq.push(s);\n\t\tmemset(dis,0x3f,sizeof(dis));\n\t\tdis[s]=0;\n\t\twhile (!q.empty())\n\t\t{\n\t\t\tint tmp=q.front();\n\t\t\tq.pop();\n\t\t\tfor (int i=head[tmp];i!=-1;i=e[i].next)\n\t\t\t\tif (e[i].cap && dis[e[i].t]==INF)\n\t\t\t\t{\n\t\t\t\t\tdis[e[i].t]=dis[tmp]+1;\n\t\t\t\t\tq.push(e[i].t);\n\t\t\t\t}\n\t\t}\n\t\treturn dis[t]!=INF;\n\t}\n\tint find(int x,int low)\n\t{\n\t    if (x==t)\n\t        return low;\n\t    int used=0;\n\t    for (int i=head[x];i!=-1;i=e[i].next)\n\t        if (e[i].cap>0 && dis[e[i].t]==dis[x]+1)\n\t        {\n\t            int flow=find(e[i].t,min(low-used,e[i].cap));\n                e[i].cap-=flow;\n                e[i^1].cap+=flow;\n                used+=flow;\n                if (used==low)\n                    return low;\n\t        }\n\t    if (!used)\n\t        dis[x]=-1;\n\t    return used;\n\t}\n\tint dinic()\n\t{\n\t\tmemset(head,0xff,sizeof(head));\n\t\tcnt=0;\n\t\ts=0,t=odd.size()+even.size()+1;\n\t\tfor (int i=0;i<odd.size();i++)\n\t\t\taddedge(s,i+1,1);\n\t\tfor (int i=0;i<even.size();i++)\n\t\t\taddedge(odd.size()+i+1,t,1);\n\t\tfor (int i=0;i<odd.size();i++)\n\t\t\tfor (int j=0;j<even.size();j++)\n\t\t\t\tif (!vis[abs(odd[i]-even[j])])\n\t\t\t\t\taddedge(i+1,odd.size()+j+1,1);\n\t    int ans=0;\n\t    while (bfs())\n\t        ans+=find(s,INF);\n\t    return ans;\n\t}\n}\nvoid ins(int x)\n{\n\tif (x&1)\n\t\todd.push_back(x);\n\telse\n\t\teven.push_back(x);\n}\nvoid pre()\n{\n\tvis[1]=1; \n    for (int i=2;i<=10000000;i++)\n    {\n        if (!vis[i])\n            prime[++p_cnt]=i;\n        for (int j=1;j<=p_cnt&&i*prime[j]<=10000000;j++)\n        {\n            vis[i*prime[j]]=1;\n            if (i%prime[j]==0)\n                break;\n        }\n    }\n}\nint main()\n{\n\tread(n);\n\tfor (int i=1;i<=n;i++)\n\t\tread(a[i]);\n\tsort(a+1,a+n+1);\n\ta[0]=-1;\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tif (a[i-1]!=a[i]-1)\n\t\t\tins(a[i]);\n\t\tif (a[i+1]!=a[i]+1)\n\t\t\tins(a[i]+1);\n\t}\n\tpre();\n\tint k=Network::dinic();\n\tprintf(\"%d\\n\",k+2*((odd.size()-k)/2+(even.size()-k)/2)+3*(odd.size()%2));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\nconst ld eps = 1e-9;\n\nvector<int>primes;\nvoid hurui(const int amax) {\n\tstatic bool flag = false;\n\tif (flag)return;\n\tvector<int>sos;\n\tsos = vector<int>(amax + 1, true);\n\tsos[0] = false; sos[1] = false;\n\tfor (int i = 2; i <= amax; ++i) {\n\t\tif (sos[i]) {\n\t\t\tfor (int j = 2 * i; j <= amax; j += i)sos[j] = false;\n\t\t}\n\t}\n\tfor (int i = 0; i <= amax; ++i) {\n\t\tif (sos[i]) {\n\t\t\tprimes.push_back(i);\n\t\t}\n\t}\n\tflag = true;\n}\n\nint main() {\n\thurui(1e7);\n\tint N; cin >> N;\n\tif (N == 1) {\n\t\tcout << 3 << endl;\n\t}\n\telse {\n\n\t\tvector<int>as;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tint a; cin >> a;\n\t\t\tas.emplace_back(a);\n\t\t}\n\t\tint ans = 0;\n\t\tint t = as.back() - as.front()+1;\n\t\tif (t % 2) {\n\t\t\tif (binary_search(primes.begin(), primes.end(), t)) {\n\t\t\t\tans = 1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tans = 3;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tans = 2;\n\t\t}\n\t\tfor (int i = 0; i < N - 1; ++i) {\n\t\t\tint k = as[i + 1] - as[i]-1;\n\t\t\tif (k % 2) {\n\t\t\t\tif (binary_search(primes.begin(), primes.end(), k)) {\n\t\t\t\t\tans += 1;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tans += 3;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (k == 0)ans += 0;\n\t\t\t\telse ans += 2;\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/********************************************************************************\n\t\n\tCode by a weak man named CYJian, and he hopes the code can get more points.\n\n\tAlgorithm: \n\n ********************************************************************************/\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\n//{{{ FAST IO AND SOME FUNCTIONS\nconst int __SIZE = 1 << 18;\nchar ibuf[__SIZE], *iS, *iT;\n\n#define ge (iS == iT ? (iT = (iS = ibuf) + fread(ibuf, 1, __SIZE, stdin), (iS == iT ? EOF : *iS++)) : *iS++)\n#define ri read_int()\n#define rl read_ll()\n#define FILE(s) freopen(s\"in\", \"r\", stdin), freopen(s\"out\", \"w\", stdout)\n\ntemplate<typename T>\ninline void read(T &x) {\n\tchar ch, t = 0; x = 0;\n\twhile(!isdigit(ch = ge)) t |= ch == '-';\n\twhile(isdigit(ch)) x = x * 10 + (ch ^ 48), ch = ge;\n\tx = t ? -x : x;\n}\ninline int read_int() { int x; return read(x), x; }\ninline ll read_ll() { ll x; return read(x), x; }\n\ntemplate<typename T> inline void chkmin(T&a, T b) { a = a < b ? a : b; }\ntemplate<typename T> inline void chkmax(T&a, T b) { a = a > b ? a : b; }\n//}}}\n\nint tot;\nint pri[5010];\nint chk[5010];\n\ninline void Sieve(int n) {\n\tchk[1] = 0;\n\tfor(int i = 2; i <= n; i++) {\n\t\tif(!chk[i]) pri[++tot] = i;\n\t\tfor(int j = 1; j <= tot; j++) {\n\t\t\tif(i * pri[j] > n) break;\n\t\t\tchk[i * pri[j]] = 1;\n\t\t\tif(i % pri[j] == 0) break;\n\t\t}\n\t}\n}\n\ninline int check(int x) {\n\tif(x <= 5000) return !chk[x];\n\tfor(int *p = pri + 1;; ++p) {\n\t\tif((*p) * (*p) > x) return 1;\n\t\tif(x % (*p) == 0) return 0;\n\t}\n}\n\nvector<int>to[210];\nint vis[210];\nint arr[210];\nint p[210];\nint tim, N;\n\ninline int Try(int x) {\n\tfor(auto u : to[x]) {\n\t\tif(arr[u] == tim) continue;\n\t\tarr[u] = tim;\n\t\tif(!vis[u] || Try(vis[u])) {\n\t\t\tvis[u] = x;\n\t\t\tvis[x] = u;\n\t\t\treturn 1;\n\t\t}\n\t} return 0;\n}\n\nint main() {\n#ifdef LOCAL\n\tFILE(\"\");\n#endif\n\n\tSieve(5000);\n\tint n = ri, ce = 0, co = 0;\n\n\tfor(int i = 1; i <= n; i++) {\n\t\tint x = ri;\n\t\tif(p[N] == x) --N;\n\t\telse p[++N] = x;\n\t\tp[++N] = x + 1;\n\t}\n\n\tfor(int i = 1; i <= N; i++) \n\t\tp[i] & 1 ? ++co : ++ce;\n\n\tfor(int i = 1; i <= N; i++)\n\t\tfor(int j = i + 1; j <= N; j++)\n\t\t\tif(((p[i] ^ p[j]) & 1) && check(p[j] - p[i]))\n\t\t\t\tto[i].push_back(j), to[j].push_back(i);\n\n\tint res = 0;\n\tfor(int i = tim = 1; i <= N; ++i, ++tim)\n\t\tif((p[i] & 1) && Try(i))\n\t\t\t--co, --ce, ++res;\n\n\tres += (co / 2 + ce / 2) << 1;\n\tif((co | ce) & 1) res += 3;\n\n\tcout << res << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "///Bismillahir Rahmanir Rahim\n#include \"bits/stdc++.h\"\n\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC optimize (\"unroll-loops\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n\n#pragma warning(disable:4786)\n#pragma warning(disable:4996)\n\n#define                           ll                          long long\n#define                           int                         ll\n#define                           fi                          first\n#define                           si                          second\n#define                           mp                          make_pair\n#define                           pb                          push_back\n#define                           pi                          pair<ll,ll>\n#define                           clr(x)                      memset(x,0,sizeof(x));\n#define                           f(i,l,r)                    for(int i=l;i<=r;i++)\n#define                           rf(i,r,l)                   for(int i=r;i>=l;i--)\n#define                           done(i)                     cout<<\"done = \"<<i<<endl;\n#define                           show(x,y)                   cout<<x<<\" : \";for(auto z:y)cout<<z<<\" \";cout<<endl;\n#define                           fast                        ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n\nusing namespace std;\n\nconst ll inf=1e18;\nconst int mod=1e9+7;\nconst int M=10000005;\nint spf[M+3];\nvoid sieve()\n{\n    spf[1]=1;\n    f(i,1,M)spf[i]=i;\n    for(int i=4;i<=M;i=i+2)\n    {\n        spf[i]=2;\n    }\n    for(int i=3;i*i<=M;i=i+2)\n    {\n        if(spf[i]==i)\n        {\n           for(int j=i*i;j<=M;j=j+i)\n           {\n               if(spf[j]==j)\n               {\n                   spf[j]=i;\n               }\n           }\n        }\n    }\n}\nint memo[M];\nint w_memo[M];\nint yo(int );\nint work(int x)\n{\n    int &ret=w_memo[x];\n    if(ret!=(-1))return ret;\n    int cost=inf;\n    for(int i=3;i<x;i=i+2)\n    {\n        int tmp=yo(i)+yo(x-i);\n        cost=min(cost,tmp);\n    }\n    ret=cost;\n    return cost;\n}\nint yo(int val)\n{   int &ret=memo[val];\n    if(ret!=(-1))return ret;\n    ret=0;\n    if(val==1 || val==2)return ret=inf;\n    if(val%2==0)\n    {\n        ret=work(val);\n        return ret;\n    }\n    while(val!=1)\n    {\n        int p=spf[val],cnt=1;\n        while(val%p==0)val=val/p,cnt=cnt*p;\n        cnt=cnt/p;\n        ret+=cnt;\n    }\n    return ret;\n}\nint n,mx;\nbool vis[M];\nvector<pi>vec;\nint last=0,cnt=0;\nconst int N=10000000;\nint dp[205];\n main()\n\n{\n    memset(memo,-1,sizeof memo);\n    memset(w_memo,-1,sizeof w_memo);\n    sieve();\n    scanf(\"%lld\",&n);\n    f(i,1,n)\n    {\n        int x;\n        scanf(\"%lld\",&x);\n        vis[x]=1;\n    }\n    f(i,1,N)\n    {\n       if(vis[i]==last)\n       {\n           cnt++;\n       }\n       else\n       {\n           if(cnt>=1)vec.pb(pi(cnt,last));\n           last=vis[i];\n           cnt=1;\n       }\n    }\n    if(cnt>=1)vec.pb(mp(cnt,last));\n    int sz=vec.size();\n    f(i,1,sz)dp[i]=inf;\n    for(int i=1;i<=sz;i++)\n    {\n        int typ[]={0,0};\n        int sum=0;\n        for(int j=i;j>=1;j--)\n        {\n\n\n                 typ[vec[j-1].si]+=yo(vec[j-1].fi);\n\n\n             sum+=vec[j-1].fi;\n\n                 int aro_cost=yo(sum);\n                 dp[i]=min(dp[i],dp[j-1]+typ[0]+aro_cost);\n\n\n                 dp[i]=min(dp[i],dp[j-1]+typ[1]);\n\n        }\n    }\n    int cur=1;\n//    cout<<\"sz \"<<sz<<endl;\n//    for(auto z:vec)\n//    {\n//        cout<<z.fi<<\" \"<<z.si<<\" \"<<dp[cur]<<endl;cur++;\n//    }\n    printf(\"%lld\\n\",dp[sz]);\n    return 0;\n\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <cstring>\n\nusing namespace std;\n\nstruct edge { int to, cap, rev; };\n#define MAX_V\t(102)\n#define INF\t\t(2000000000)\n\nvector<edge> G[MAX_V];\nint level[MAX_V];\nint iter[MAX_V];\n\nvoid add_edge(int from, int to, int cap) {\n\tG[from].push_back(edge{ to, cap, (int)G[to].size() });\n\tG[to].push_back(edge{ from, 0, (int)G[from].size() - 1 });\n}\n\nvoid bfs(int s) {\n\tmemset(level, -1, sizeof(level));\n\tqueue<int> que;\n\tlevel[s] = 0;\n\tque.push(s);\n\twhile (!que.empty()) {\n\t\tint v = que.front();\n\t\tque.pop();\n\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\tedge& e = G[v][i];\n\t\t\tif (e.cap > 0 && level[e.to] < 0) {\n\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\tque.push(e.to);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint dfs(int v, int t, int f) {\n\tif (v == t) return f;\n\tfor (int& i = iter[v]; i < G[v].size(); i++) {\n\t\tedge& e = G[v][i];\n\t\tif (e.cap > 0 && level[v] < level[e.to]) {\n\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\tif (d > 0) {\n\t\t\t\te.cap -= d;\n\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint max_flow(int s, int t) {\n\tint flow = 0;\n\twhile (true) {\n\t\tbfs(s);\n\t\tif (level[t] < 0) return flow;\n\t\tmemset(iter, 0, sizeof(iter));\n\t\tint f;\n\t\twhile ((f = dfs(s, t, INF)) > 0) {\n\t\t\tflow += f;\n\t\t}\n\t}\n}\n\nbool is_prime(int n) {\n\tif (1 == n) return false;\n\tfor (int i = 2; i * i <= n; i++)if (0 == n % i) return false;\n\treturn true;\n}\n\nint main()\n{\n\tint N;\n\tcin >> N;\n\tvector<int> x(N);\n\tfor (int i = 0; i < N; i++) {\n\t\tcin >> x[i];\n\t}\n\tvector<int> p;\n\tfor (int i = 0; i < N; i++) {\n\t\tp.push_back(x[i]);\n\t\tfor (; i < N - 1 && x[i] + 1 == x[i + 1]; i++);/* 連続スキップ */\n\t\tp.push_back(x[i] + 1);\n\t}\n\tint s = MAX_V - 2;\n\tint t = s + 1;\n\tint num = p.size();\n\tint evenNum = 0;\n\tfor (int i = 0; i < num; i++) {\n\t\tif (0 == (p[i] % 2)) {\n\t\t\tadd_edge(s, i, 1);\n\t\t\tevenNum++;\n\t\t\tfor (int j = 0; j < num; j++) {\n\t\t\t\tint dst = abs(p[i] - p[j]);\n\t\t\t\tif (dst > 2 && is_prime(dst)) add_edge(i, j, 1);\n\t\t\t}\n\t\t} else {\n\t\t\tadd_edge(i, t, 1);\n\t\t}\n\t}\n\tint f = max_flow(s, t);\n\tint ans = f;\n\tans += ((evenNum - f)/2 + (num - evenNum - f)/2)*2 ;\n\tans += ((evenNum - f) % 2) * 3;\n\tcout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define inf 1e9\nusing namespace std;\nstruct node{\n\tint nxt,to,weigh;\n}edge[400010];\nint head[100100],n,S,T,cnt=1,level[100100];\nint a[10010],b[10010],c[10001000],sum,tot,ans;\nqueue<int> qu;\nbool check(int a){\n\tfor(int i=2;i<=sqrt(a);i++)\n\t\tif(a%i==0)return false;\n\treturn true;\n}\nvoid addedge(int x,int y,int z){\n\tedge[++cnt].nxt=head[x];\n\tedge[cnt].to=y;\n\tedge[cnt].weigh=z;\n\thead[x]=cnt;\n\tedge[++cnt].nxt=head[y];\n\tedge[cnt].to=x;\n\tedge[cnt].weigh=0;\n\thead[y]=cnt;\t\n}\nbool bfs(){\n\tmemset(level,-1,sizeof(level));\n\tlevel[S]=0;\n\tqu.push(S);\n\twhile(!qu.empty()){\n\t\tint u=qu.front();\n\t\tqu.pop();\n\t\tfor(int i=head[u];i;i=edge[i].nxt){\n\t\t\tint upup=edge[i].to;\n\t\t\tif(edge[i].weigh!=0 && level[upup]==-1){\n\t\t\t\tlevel[upup]=level[u]+1;\n\t\t\t\tqu.push(upup);\n\t\t\t}\n\t\t}\n\t}\n\tif(level[T]==-1)return false;\n\treturn true;\n}\nint dfs(int x,int flow){\n\tif(x==T)return flow;\n\tint rest=0;\n\tfor(int i=head[x];i;i=edge[i].nxt){\n\t\tint upup=edge[i].to;\n\t\tif(rest==flow)break;\n\t\tif(level[upup]==level[x]+1){\n\t\t\tint sum=dfs(upup,min(flow-rest,edge[i].weigh));\n\t\t\trest+=sum,edge[i].weigh-=sum;edge[i^1].weigh+=sum;\n\t\t}\n\t} \n\treturn rest;\n}\nint Dinic(){\n\tint ans=0;\n\twhile(bfs())\n\t\tans+=dfs(S,inf);\n\treturn ans;\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++){\n\t\tscanf(\"%d\",&a[i]);\n\t\tc[a[i]]=1;\n\t}\n\tfor(int i=1;i<=10000000;i++)\n\t\tif(c[i]!=c[i-1])\n\t\t\tb[++sum]=i;\n\tS=0,T=sum+1;\n\tfor(int i=1;i<=sum;i++)\n\t\tif(b[i]&1){\n\t\t\ttot++;\n\t\t\taddedge(S,i,1);\n\t\t\tfor(int j=1;j<=sum;j++)\n\t\t\t\tif(!b[j]&1&&check(abs(b[j]-b[i])))\n\t\t\t\t\taddedge(i,j,1);\n\t\t}\n\t\telse addedge(i,T,1);\n\tans=Dinic();\n\tprintf(\"%d\\n\",sum-ans+(tot-ans)%2);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define LL long long\n#define uLL unsigned long long\n#define db double\n\nusing namespace std;\nconst int N=1e7+10,M=200+10,inf=1<<30;\nint rd()\n{\n\tint x=0,w=1;char ch=0;\n\twhile(ch<'0'||ch>'9'){if(ch=='-') w=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=(x<<3)+(x<<1)+(ch^48);ch=getchar();}\n\treturn x*w;\n}\nint to[M*M],nt[M*M],c[M*M],hd[M],tot=1;\nvoid add(int x,int y,int z)\n{\n\t++tot,to[tot]=y,nt[tot]=hd[x],c[tot]=z,hd[x]=tot;\n\t++tot,to[tot]=x,nt[tot]=hd[y],c[tot]=0,hd[y]=tot;\n}\nint ps,pt,nhd[M],lv[M];\nbool bfs()\n{\n\tqueue<int> q; \n\tfor(int i=1;i<=pt;++i) lv[i]=0;\n\tlv[ps]=1,q.push(ps);\n\twhile(!q.empty())\n\t{\n\t\tint x=q.front();\n\t\tq.pop();\n\t\tfor(int i=hd[x];i;i=nt[i])\n\t\t{\n\t\t\tint y=to[i];\n\t\t\tif(c[i]>0&&!lv[y])\n\t\t\t\tlv[y]=lv[x]+1,q.push(y);\n\t\t}\n\t}\n\treturn lv[pt];\n}\nint dfs(int x,int fw)\n{\n\tif(x==pt) return fw;\n\tint an=0;\n\tfor(int &i=nhd[x];i;i=nt[i])\n\t{\n\t\tint y=to[i];\n\t\tif(c[i]>0&&lv[y]==lv[x]+1)\n\t\t{\n\t\t\tint dt=dfs(y,min(fw,c[i]));\n\t\t\tc[i]-=dt,c[i^1]+=dt;\n\t\t\tfw-=dt,an+=dt;\n\t\t\tif(!fw) break;\n\t\t}\n\t}\n\treturn an;\n}\nint dinic()\n{\n\tint an=0,dt;\n\twhile(bfs())\n\t{\n\t\tmemcpy(nhd,hd,sizeof(int)*(pt+1));\n\t\twhile((dt=dfs(ps,inf))) an+=dt;\n\t}\n\treturn an;\n}\nint prm[N],tt;\nbool v[N];\nint n,a[M],id[M],b[N],ans;\n\nint main()\n{\n\tv[1]=1;\n\tfor(int i=2;i<=10000001;++i)\n\t{\n\t\tif(!v[i]) prm[++tt]=i;\n\t\tfor(int j=1;i*prm[j]<=10000001;++j)\n\t\t{\n\t\t\tv[i*prm[j]]=1;\n\t\t    if(i%prm[j]==0) break;\n\t\t}\n\t}\n\tv[0]=v[2]=1;\n\tn=rd();\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tint x=rd();\n\t\tb[x]^=1,b[x+1]^=1;\n\t}\n\tn=0;\n\tfor(int i=1;i<=N-5;++i)\n\t\tif(b[i]) a[++n]=i;\n\tps=0,pt=n+1;\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tif(a[i]&1)\n\t\t{\n\t\t\tadd(ps,i,1),id[i]=tot;\n\t\t\tfor(int j=1;j<=n;++j)\n\t\t\t\tif(!v[abs(a[i]-a[j])])\n\t\t\t\t\tadd(i,j,1);\n\t\t}\n\t\telse add(i,pt,1),id[i]=tot;\n\t}\n\tans=dinic();\n\tfor(int i=1;i<=n;++i)\n\t\tif(c[id[i]]) a[i]=N+1;\n\tsort(a+1,a+n+1);\n\twhile(a[n]>N) --n;\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tif(a[i]>N) continue;\n\t\tfor(int j=1;j<=n;++j)\n\t\t\tif(i!=j&&a[j]<N&&!((a[i]-a[j])&1))\n\t\t\t{++ans,++ans,a[i]=a[j]=N+1;break;}\n\t}\n\tsort(a+1,a+n+1);\n\twhile(a[n]>N) --n;\n\tans+=n/2*3;\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define N 10000010\n#define M 110\nint p[N],isp[N],s[N],a[M],b[M],vis[M*2],mat[M*2];\nvector <int> E[M];\nbool dfs(int x){\n\tfor (auto &i:E[x]){\n\t\tif (!vis[i]){\n\t\t\tvis[i]=1;\n\t\t\tif (!mat[i] || dfs(mat[i])){\n\t\t\t\tmat[i]=x;return 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\ninline int read(){\n\tint x=0,f=1;\n\tchar ch=getchar();\n\twhile (ch<'0' || ch>'9'){\n\t\tif (ch=='-') f=-1;\n\t\tch=getchar();\n\t}\n\twhile (ch>='0' && ch<='9'){\n\t\tx=x*10+ch-'0';ch=getchar();\n\t}\n\treturn x*f;\n}\nint main(){\n\tint tot=0,cnt1=0,cnt2=0,ans=0;\n\tfor (int i=2;i<N;++i){\n\t\tif (!isp[i]) p[++tot]=i;\n\t\tfor (int j=1;j<=tot && i*p[j]<N;++j){\n\t\t\tisp[i*p[j]]=1;\n\t\t\tif (i%p[j]==0) break;\n\t\t}\n\t}\n\tint n=read();isp[1]=1;\n\tfor (int i=1;i<=n;++i) s[read()]=1;\n\tfor (int i=1;i<N;++i){\n\t\tif (s[i]!=s[i-1]){\n\t\t\tif (i&1) a[++cnt1]=i;\n\t\t\telse b[++cnt2]=i;\n\t\t}\n\t}\n\tfor (int i=1;i<=cnt1;++i){\n\t\tfor (int j=1;j<=cnt2;++j){\n\t\t\tif (!isp[abs(a[i]-b[j])]) E[i].push_back(j);\n\t\t}\n\t}\n\tfor (int i=1;i<=cnt1;++i){\n\t\tmemset(vis,0,sizeof(vis));ans+=dfs(i);\n\t}\n\tcout<<ans+(cnt1-ans)/2*2+(cnt2-ans)/2*2+((cnt1-ans)&1)*3<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <iostream>\n#include <algorithm>\n#define fo(i,a,b) for(int i=a;i<=b;i++)\n#define fod(i,a,b) for(int i=a;i>=b;i--)\n#define N 2005\nusing namespace std;\nint l[N],n,a[N],r[N],w[N],pr[5000005],f[N],a1[N][N];\nbool bz[20000005],bp[N];\nvoid prp()\n{\n\tbz[1]=1;\n\tbz[0]=1;\n\tfo(i,2,20000000)\n\t{\n\t\tif(!bz[i]) pr[++pr[0]]=i;\n\t\tfor(int j=1;j<=pr[0]&&i*pr[j]<=20000000;j++)\n\t\t{\n\t\t\tbz[i*pr[j]]=1;\n\t\t\tif(i%pr[j]==0) break;\n\t\t}\n\t}\n\tbz[2]=1;\n}\nbool find(int k)\n{\n\tfo(i,1,a1[k][0])\n\t{\n\t\tint p=a1[k][i];\n\t\tif(!bp[p])\n\t\t{\n\t\t\tbp[p]=1;\n\t\t\tif(!f[p]||find(f[p])) \n\t\t\t{\n\t\t\t\tf[p]=k;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nint main()\n{\n\tcin>>n;\n\tprp();\n\tfo(i,1,n) scanf(\"%d\",&a[i]);\n\tsort(a+1,a+n+1);\n\tfo(i,1,n) \n\t{\n\t\tif(i==1||a[i-1]!=a[i]-1) w[++w[0]]=i;\n\t\tif(a[i+1]!=a[i]+1) w[++w[0]]=i+1;\n\t}\n\tsort(w+1,w+w[0]+1);\n\tfo(i,1,w[0]) \n\t\tif(w[i]%2==0) l[++l[0]]=i;\n\t\telse r[++r[0]]=i;\n\tfo(i,1,l[0])\n\t{\n\t\tfo(j,1,r[0])\n\t\t{\n\t\t\tif(!bz[abs(l[i]-r[j])]) a1[i][++a1[i][0]]=j;\n\t\t}\n\t}\n\tlong long s=0;\n\tfo(i,1,l[0]) \n\t{\n\t\tmemset(bp,0,sizeof(bp));\n\t\tif(find(i)) s++;\n\t}\n\tprintf(\"%lld\",s+2*(long long)((l[0]-s)/2)+2*(long long)((r[0]-s)/2)+3*(long long)((l[0]-s)%2));\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define L long long\n#define pb push_back\n#define pi pair<int,int>\n#define pii pair<pair<int,int>,int>\n#define aa first\n#define bb second\n#define mp make_pair\n#define mpp(a,b,c) mp(mp(a,b),c)\nusing namespace std;\n#define SZ 666666\ntypedef long long ll;\nint fst[SZ],nxt[SZ],vb[SZ],cap[SZ],ff[SZ],M=1,N=0;\n#define add ad_dl\nvoid _ad_dl(int a,int b,int c) {++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;cap[M]=c;}\nvoid ad_dl(int a,int b,int c)\n{_ad_dl(a,b,c); _ad_dl(b,a,0);}\nint S,T,q[SZ],d[SZ];\nbool bfs()\n{\n    memset(d,-1,4*(N+1));\n    d[T]=0; q[1]=T; int h=1,t=2;\n    while(h!=t)\n    {\n        int cur=q[h++];\n        for(int e=fst[cur];e;e=nxt[e])\n        {\n            int b=vb[e];\n            if(d[b]==-1&&cap[e^1])\n            {\n                d[b]=d[cur]+1, q[t++]=b;\n                if(b==S) return 1; //???? \n            }\n        }\n    }\n    return d[S]!=-1;\n}\nint dfs(int x,int f)\n{\n    if(f<=0) return 0;\n    if(x==T) return f;\n    int ca=0;\n    for(int& e=fst[x];e;e=nxt[e]) //????? \n    {\n        int b=vb[e];\n        if(d[b]+1!=d[x]) continue;\n        int w=dfs(b,(cap[e]<f-ca)?cap[e]:(f-ca));\n        cap[e]-=w; cap[e^1]+=w; ca+=w;\n        if(ca==f) break;\n    }\n    if(!ca) d[x]=-1; //????? \n    return ca;\n}\n#define inf 2e9+3\nint dinic()\n{\n    int ans=0;\n    memcpy(ff,fst,4*(N+1));\n    while(bfs())\n    {\n        //?????\n        ans+=dfs(S,inf);\n        memcpy(fst,ff,4*(N+1));\n    }\n    return ans;\n}\nint n,m,x[110],f[210],p;\nbool a[10000010];\nint main()\n{\n\t//freopen(\".in\",\"r\",stdin);\n\t//freopen(\".out\",\"w\",stdout);\n\tint i,j,k;\n\tscanf(\"%d\",&n);\n\tfor(i=1;i<=n;i++)\n\t  scanf(\"%d\",&x[i]);\n\tfor(i=2;i<=n;i++)\n\t  if(x[i-1]+1!=x[i])\n\t    {\n\t\t f[++m]=x[i-1]+1;\n\t\t f[++m]=x[i];\n\t\t}\n\tf[++m]=x[1];\n\tf[++m]=x[n]+1;\n\ta[1]=1;\n\tfor(i=2;i<=10000000;i++)\n\t  if(!a[i])\n\t    for(j=i;j<=10000000;j+=i)\n\t      a[j]=1;\n\ta[2]=1;\n\tN=m+2;\n\tS=m+2;\n\tT=m+1;\n\tfor(i=1;i<=m;i++)\n\t  if(f[i]&1)\n\t    add(m+2,i,1);\n\t  else\n\t    add(i,m+1,1);\n\tfor(i=1;i<=m;i++)\n\t  for(j=1;j<=m;j++)\n\t    if(i!=j && f[i]&1 && !a[abs(f[i]-f[j])])\n\t      add(i,j,1);\n\tp=k=dinic();\n\tfor(i=1,j=-k;i<=m;i++)\n\t  if(f[i]&1)\n\t    j++;\n\tp+=j/2*2;\n\tif(j&1)\n\t  p+=3;\n\tfor(i=1,j=-k;i<=m;i++)\n\t  if(!(f[i]&1))\n\t    j++;\n\tp+=j/2*2;\n\tprintf(\"%d\\n\",p);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define N 11116\n#define inf 1111111116\n#define next nxt\n\nint n,k,a[N],b[N],f[N],next[N],p[N],now[N],d[N],h[N],cnt,ans;\nvector<int> x;\nqueue<int> q;\n\nvoid add(int x,int y){\n\ta[++k]=x;b[k]=y;f[k]=1;next[k]=p[x];p[x]=k;\n\ta[++k]=y;b[k]=x;f[k]=0;next[k]=p[y];p[y]=k;\n}\n\nbool travel(){\n\tmemcpy(now,p,sizeof(p));\n\tfill(d+1,d+n+3,inf);d[n+1]=0;\n\tq.push(n+1);h[n+1]=1;\n\twhile (!q.empty()){\n\t\tint x=q.front();q.pop();h[x]=0;\n\t\tfor (int t=p[x];t;t=next[t])\n\t\t\tif (f[t]&&d[x]+1<d[b[t]]){\n\t\t\t\td[b[t]]=d[x]+1;\n\t\t\t\tif (!h[b[t]]) q.push(b[t]),h[b[t]]=1;\n\t\t\t}\n\t}\n\treturn d[n+2]<inf;\n}\n\nint dinic(int x,int lmt){\n\tif (x==n+2) return lmt;int cnt=0;\n\tfor (int t=now[x];t;t=now[x]=next[t])\n\t\tif (f[t]&&d[x]<d[b[t]]){\n\t\t\tint tmp=dinic(b[t],min(f[t],lmt-cnt));\n\t\t\tf[t]-=tmp;f[t^1]+=tmp;cnt+=tmp;\n\t\t\tif (cnt==lmt) return lmt;\n\t\t}\n\treturn cnt;\n}\n\nbool check(int x){\n\tif (x%2==0||x==1) return false;\n\tfor (int i=2;i*i<=x;i++)\n\t\tif (x%i==0) return false;\n\treturn true;\n}\n\nint read(){\n\tint x=0,f=1;char ch=getchar();\n\tfor (;!isdigit(ch);ch=getchar()) if (ch=='-')  f=-f;\n\tfor (;isdigit(ch);ch=getchar()) x=x*10+ch-'0';\n\treturn x*f;\n}\n\nint main(){\n\tn=read();k=1;x.push_back(0);\n\tfor (int i=1;i<=n;i++){\n\t\tint t=read();\n\t\tif (x.back()==t) x.pop_back();\n\t\telse x.push_back(t);\n\t\tx.push_back(t+1);\n\t}\n\tn=x.size()-1;\n\tfor (int i=1;i<=n;i++)\n\t\tif (x[i]&1) add(n+1,i),cnt++;\n\t\telse {\n\t\t\tfor (int j=1;j<=n;j++)\n\t\t\t\tif (check(x[i]+x[j])) add(i,j);\n\t\t\tadd(i,n+2);\n\t\t}\n\twhile (travel()) ans+=dinic(n+1,inf);\n\tprintf(\"%d\\n\",n-ans+(cnt-ans)%2);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <bits/stdc++.h>\nusing namespace std;\n// #define int long long\n// #define double long double\n#define rep(i,n) for (int i=0; i<(int)(n); ++i)\n#define rep1(i,n) for (int i=1; i<(int)(n); ++i)\n#define repeq(i,n) for (int i=0; i<=(int)(n); ++i)\n#define rep1eq(i,n) for (int i=1; i<=(int)(n); ++i)\n#define rrep(i,n) for (int i=(int)(n)-1; i>=0; --i)\n#define rrep1(i,n) for (int i=(int)(n)-1; i>0; --i)\n#define rrepeq(i,n) for (int i=(int)(n); i>=0; --i)\n#define rrep1eq(i,n) for (int i=(int)(n); i>0; --i)\n#define REP(i,a,b) for (int i=(int)(a); i<=(int)(b); ++i)\n#define RREP(i,a,b) for (int i=(int)(a); i>=(int)(b); --i)\n#define ALL(a) (a).begin(), (a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\nusing ll = long long;\nusing vi = vector<int>;\nusing vl = vector<ll>;\nusing vb = vector<bool>;\ntemplate<typename T> using Graph = vector<vector<T>>;\ntemplate<typename T> using Spacial = vector<vector<vector<T>>>;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\ntemplate<typename T> using greater_priority_queue = priority_queue<T, vector<T>, greater<T>>;\nconst int MOD = 1e9+7;\nconst int MOD2 = 998244353;\n// const double EPS = 1e-9;\nconst int dx[4] = {1, 0, -1, 0};\nconst int dy[4] = {0, 1, 0, -1};\nstring interval[2] = {\" \", \"\\n\"}; // {\" \", \"\\n\"}\n\ntemplate<typename T> struct is_plural : false_type{};\ntemplate<typename T1, typename T2> struct is_plural<pair<T1, T2>> : true_type{};\ntemplate<typename T> struct is_plural<vector<T>> : true_type{};\ntemplate<typename T> struct is_plural<complex<T>> : true_type{};\n \ntemplate<typename T1, typename T2> istream &operator>>(istream &is, pair<T1, T2> &p) { return is >> p.first >> p.second; }\ntemplate<typename T1, typename T2> ostream &operator<<(ostream &os, const pair<T1, T2> &p) { return os << p.first << \" \" << p.second; }\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &vec) { for (auto itr = vec.begin(); itr != vec.end(); ++itr) is >> *itr; return is; }\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &vec) { if (vec.empty()) return os; bool pl = is_plural<T>(); os << vec.front(); for (auto itr = ++vec.begin(); itr != vec.end(); ++itr) os << interval[pl] << *itr; return os; }\n \nbool CoutYN(bool a, string y = \"Yes\", string n = \"No\") { cout << (a ? y : n) << \"\\n\"; return a; }\n\ntemplate<typename T1, typename T2> inline bool chmax(T1 &a, T2 b) { return a < b && (a = b, true); }\ntemplate<typename T1, typename T2> inline bool chmin(T1 &a, T2 b) { return a > b && (a = b, true); }\n\nlong long modpow(int a, long long n, int mod = MOD) { long long ret = 1; do { if (n & 1) ret = ret * a % mod; a = 1LL * a * a % mod; } while (n >>= 1); return ret; }\n\ntemplate<typename T> T GCD(T a, T b) { return b ? GCD(b, a%b) : a; }\ntemplate<typename T> T LCM(T a, T b) { return a / GCD(a, b) * b; }\n\ntemplate<typename T1, typename T2> bool CompareBySecond(pair<T1, T2> a, pair<T1, T2> b) { return a.second != b.second ? a.second < b.second : a.first < b.first; }\ntemplate<typename T1, typename T2> bool CompareByInverse(pair<T1, T2> a, pair<T1, T2> b) { return a.first != b.first ? a.first < b.first : a.second > b.second; }\n\n\n/* -------- <templates end> -------- */\n\n\nvi prime;\n\nint add(int d) {\n  if (d == 1) return 3;\n  if (!(d & 1)) return 2;\n  for (int &p : prime) {\n    if (p * p > d) break;\n    if (d % p == 0) return 3;\n  }\n  return 1;\n}\n\nvoid solve() {\n  int n; cin >> n;\n  vi arr(n); cin >> arr;\n\n  vi sec = {arr[0], arr[0] + 1};\n  rep1(i,n) {\n    if (sec.back() == arr[i]) {\n      ++sec.back();\n    } else {\n      sec.emplace_back(arr[i]);\n      sec.emplace_back(arr[i] + 1);\n    }\n  }\n\n  vb seen(3200, false);\n\n  for (int i=3; i<3200; i+=2) {\n    if (!seen[i]) {\n      prime.emplace_back(i);\n      for (int j=i*3; j<3200; j+=i*2) {\n        seen[j] = true;\n      }\n    }\n  }\n\n  int sz = sec.size();\n\n  Graph<int> dp(sz, vi(sz, 0));\n\n  rep1(j,sz) {\n    for (int i=j-1; i>=0; i-=2) {\n      int d = sec[j] - sec[i];\n      dp[i][j] = dp[i+1][j-1] + add(d);\n      for (int k=i+1; k<j; k+=2) {\n        chmin(dp[i][j], dp[i][k] + dp[k+1][j]);\n      }\n    }\n  }\n\n  cout << dp[0][sz-1] << endl;\n}\n\n\n/* -------- <programs end> -------- */\n\n\nsigned main() {\n  cin.tie(nullptr);\n  ios::sync_with_stdio(false);\n  cout << fixed << setprecision(10);\n  solve();\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<cassert>\n#define PB push_back\n#define MP make_pair\n#define sz(v) (in((v).size()))\n#define forn(i,n) for(in i=0;i<(n);++i)\n#define forv(i,v) forn(i,sz(v))\n#define fors(i,s) for(auto i=(s).begin();i!=(s).end();++i)\n#define all(v) (v).begin(),(v).end()\nusing namespace std;\ntypedef int in;\ntypedef vector<in> VI;\ntypedef vector<VI> VVI;\nstruct bipm{\n  in n,m;\n  VVI a;\n  VI pr,vs;\n  void ini(in pn, in pm){\n    n=pn;\n    m=pm;\n    a.clear();\n    a.resize(n);\n    pr.clear();\n    pr.resize(m,-1);\n  }\n  void ad(in u, in v){\n    a[u].PB(v);\n  }\n  bool mm(in u){\n    if(vs[u])\n      return 0;\n    vs[u]=1;\n    in tt;\n    forv(i,a[u]){\n      tt=a[u][i];\n      if(pr[tt]==-1){\n\tpr[tt]=u;\n\treturn 1;\n      }\n      if(mm(pr[tt])){\n\tpr[tt]=u;\n\treturn 1;\n      }\n    }\n    return 0;\n  }\n  in mmat(){\n    vs.resize(n);\n    in sm=0;\n    forn(i,n){\n      forn(j,n)\n\tvs[j]=0;\n      sm+=mm(i);\n    }\n    return sm;\n  }\n};\nbipm mat;\nbool isp(in a){\n  if(a<=2)\n    return 0;\n  for(in i=2;i*i<=a;++i){\n    if(a%i==0)\n      return 0;\n  }\n  return 1;\n}\nin ab(in a){\n  return a<0?-a:a;\n}\nint main(){\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  in n;\n  cin>>n;\n  VI x(n);\n  forn(i,n)\n    cin>>x[i];\n  VI lft,rgt;\n  in c;\n  forv(i,x){\n    if(i==0 || x[i-1]+1!=x[i]){\n      c=x[i];\n      if(c%2==0)\n\tlft.PB(c);\n      else\n\trgt.PB(c);\n    }\n    if(i==n-1 || x[i]+1!=x[i+1]){\n      c=x[i]+1;\n      if(c%2==0)\n\tlft.PB(c);\n      else\n\trgt.PB(c);\n    }\n  }\n  in l=sz(lft);\n  in r=sz(rgt);\n  mat.ini(l,r);\n  forv(i,lft){\n    forv(j,rgt){\n      if(isp(ab(rgt[j]-lft[i])))\n\tmat.ad(i,j);\n    }\n  }\n  c=mat.mmat();\n  in res=c;\n  l-=c;\n  r-=c;\n  assert(l%2==r%2);\n  if(l%2){\n    res+=3;\n    --l;\n    --r;\n  }\n  res+=l+r;\n  cout<<res<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 233;\nconst int INF = 1e9;\n\nstruct Edge {\n    int to, rev, cap;\n};\n\nint nv, sv, tv;\nvector<Edge> g[N];\nint dist[N], ptr[N];\n\nvoid add_edge(int a, int b, int c) {\n    g[a].push_back(Edge{b, int(g[b].size()), c});\n    g[b].push_back(Edge{a, int(g[a].size()) - 1, 0});\n}\n\nbool augment() {\n    fill_n(dist, nv, -1);\n    dist[sv] = 0;\n\n    vector<int> que;\n    que.push_back(sv);\n    for (int v: que) {\n        for (auto e: g[v]) {\n            if (dist[e.to] == -1 || e.cap == 0) {\n                continue;\n            }\n            dist[e.to] = dist[v] + 1;\n            if (e.to == tv) {\n                return true;\n            }\n            que.push_back(e.to);\n        }\n    }\n\n    return false;\n}\n\nint dfs(int v, int r) {\n    for (int& i = ptr[v]; i < int(g[v].size()); i++) {\n        auto& e = g[v][i];\n        if (dist[e.to] <= dist[v] || e.cap == 0) {\n            continue;\n        }\n        int d = dfs(e.to, min(r, e.cap));\n        if (d == 0) {\n            continue;\n        }\n        e.cap -= d;\n        g[e.to][e.rev].cap += d;\n        return d;\n    }\n    return 0;\n}\n\nint exec() {\n    int res = 0;\n    while (augment()) {\n        fill_n(ptr, nv, 0);\n        while (true) {\n            int d = dfs(sv, INF);\n            if (d == 0) {\n                break;\n            }\n            res += d;\n        }\n    }\n    return res;\n}\n\nconst int M = int(1e7 + 10);\n\nint n;\nbool isp[M];\n\nvoid precalc() {\n    fill(isp + 2, isp + M, true);\n    for (int i = 2; i * i < M; i++) {\n        if (!isp[i]) {\n            continue;\n        }\n        for (int j = i * i; j < M; j += i) {\n            isp[j] = false;\n        }\n    }\n}\n\nint main() {\n    precalc();\n\n    scanf(\"%d\", &n);\n\n    set<int> a;\n    auto add = [&](int x) {\n        auto it = a.find(x);\n        if (it != a.end()) {\n            a.erase(it);\n        } else {\n            a.insert(x);\n        }\n    };\n\n    for (int i = 0; i < n; i++) {\n        int x;\n        scanf(\"%d\", &x);\n        add(x);\n        add(x + 1);\n    }\n\n    vector<vector<int>> v(2);\n    for (int x: a) {\n        v[x % 2].push_back(x);\n    }\n    int v0s = v[0].size(), v1s = v[1].size();\n\n    sv = 0;\n    tv = 1;\n    nv = v0s + v1s + 2;\n    for (int i = 0; i < v0s; i++) {\n        add_edge(sv, 2 + i, 1);\n    }\n    for (int i = 0; i < v1s; i++) {\n        add_edge(2 + v0s + i, tv, 1);\n    }\n    for (int i = 0; i < v0s; i++) {\n        for (int j = 0; j < v1s; j++) {\n            int d = abs(v[0][i] - v[1][j]);\n            if (d > 2 && isp[d]) {\n                add_edge(2 + i, 2 + v0s + j, 1);\n            }\n        }\n    }\n\n    int used = exec();\n    int ans = used;\n    ans += 2 * ((v0s - used) / 2);\n    ans += 2 * ((v1s - used) / 2);\n    if ((v0s - used) % 2 == 1) {\n        ans += 3;\n    }\n\n    printf(\"%d\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<queue>\n#include<algorithm>\nusing namespace std;\nconst int maxn=510,maxL=10000010,inf=0x3f3f3f3f;\nstruct cyc{int v,flow,from;}e[maxn*maxn*2];\nint tot=1,cnt,n,first[maxn],d[maxn],S,T,num[maxn],b[maxn],cur[maxn];\nbool c[maxL];\ninline int ab(int x){return x>0?x:-x;}\nbool isprime(int x){\n    if(x<=2)return 0;\n    for(int i=2;i*i<=x;i++)if(x%i==0)return 0;\n    return 1;\n}\nvoid insert(int u,int v,int w){\n    tot++;e[tot].v=v;e[tot].flow=w;e[tot].from=first[u];first[u]=tot;\n    tot++;e[tot].v=u;e[tot].flow=0;e[tot].from=first[v];first[v]=tot;\n}\nqueue<int>q;\nbool bfs(){\n    memset(d,-1,sizeof(d));\n    q.push(S);d[S]=0;\n    while(!q.empty()){\n        int x=q.front();q.pop();\n        for(int i=first[x];i;i=e[i].from)\n        if(d[e[i].v]==-1&&e[i].flow){\n            d[e[i].v]=d[x]+1;\n            q.push(e[i].v);\n        }\n    }\n    return d[T]!=-1;\n}\nint dinic(int x,int a){\n    if(x==T||a==0)return a;\n    int f,flow=0;\n    for(int& i=cur[x];i;i=e[i].from)\n    if(d[e[i].v]==d[x]+1&&e[i].flow&&(f=dinic(e[i].v,min(a,e[i].flow)))>0){\n        e[i].flow-=f;\n        e[i^1].flow+=f;\n        a-=f;\n        flow+=f;\n        if(a==0)break;\n    }\n    return flow;\n}\nint main(){\n    scanf(\"%d\",&n);\n    for(int i=1;i<=n;i++){scanf(\"%d\",&num[i]);c[num[i]]=1;}\n    for(int i=1;i<=maxL-5;i++)if(c[i]!=c[i-1])b[++cnt]=i;\n    S=0;T=cnt+1;\n    int m1=0;\n    for(int i=1;i<=cnt;i++)if(b[i]&1){\n        m1++;\n        insert(S,i,1);\n        for(int j=1;j<=cnt;j++)if(!(b[j]&1)&&isprime(ab(b[i]-b[j])))insert(i,j,1);\n    }else{\n        insert(i,T,1);\n    }\n    int ans=0;\n    while(bfs()){\n        for(int i=S;i<=T;i++)cur[i]=first[i];\n        ans+=dinic(S,inf);\n    }\n    printf(\"%d\",cnt-ans+(m1-ans)%2);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\nusing namespace std;\nconst int N=110*2;\nbool f[10001000],fl[N][N],fla[N];\nint n,p[1000100],cnt,a[N],cot,from[N],nj[N],no[N];\nbool match(int x)\n{\n    if(fla[x]) return false;\n    fla[x]=true;\n    for(int i=1;i<=nj[0];++i)\n        if(fl[x][i]&&(from[i]==0||match(from[i])))\n        {\n            from[i]=x;\n            return true;\n        }\n    return false;\n}\nvoid init()\n{\n    for(int i=2;i<=1000050;++i)\n    {\n        if(!f[i]) p[++cnt]=i;\n            for(int j=1;j<=cnt&&p[j]*i<=1000050;++j)\n            {\n                f[p[j]*i]=true;\n                if(i%p[j]==0) break;\n            }\n    }\n}\nint main()\n{\n    ios::sync_with_stdio(false);\n    init();\n    f[1]=true;\n    f[2]=false;\n    cin>>n;\n    int t=-10,t1;\n    for(int i=1;i<=n;++i)\n    {\n        cin>>t1;\n        if(t1-t!=1) \n        {\n            a[cot++]=t+1;\n            a[cot++]=t1;\n        }\n        t=t1;\n    }\n    a[cot]=t1+1;\n    for(int i=1;i<=cot;++i)\n    {\n        if(a[i]%2)\n            nj[++nj[0]]=a[i];\n        else\n            no[++no[0]]=a[i];\n    }\n    for(int i=1;i<=nj[0];++i)\n        for(int j=1;j<=no[0];++j)\n            fl[i][j]=!f[abs(nj[i]-no[j])];\n    int ans=0;\n    for(int i=1;i<=nj[0];++i)\n    {\n        memset(fla,false,sizeof(fla));\n        if(match(i)) ans++;\n    }\n    cout<< ans+(nj[0]-ans)/2*2+(no[0]-ans)/2*2+(nj[0]-ans)%2*3 <<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <cstdio>\n#include <cstring>\n\ninline int Abs(const int x){return x>=0?x:-x;}\n\nint n,a[205],b[205],Mat[205],Ans;\nbool G[205][205],Vis[205];\nstd::map<int,int> M;\n\nbool Prime(int x)\n{\n    if(x<2)return false;\n    for(int i=2;i*i<=x;++i)\n        if(x%i==0)return false;\n    return true;\n}\n\nbool DFS(int x)\n{\n    for(int y=1;y<=n;++y)\n        if(!Vis[y]&&G[x][y])\n            if(Vis[y]=true,!Mat[y]||DFS(Mat[y]))\n                return Mat[y]=x,true;\n    return false;\n}\n\nint main()\n{\n    scanf(\"%d\",&n);\n    for(int i=1,x;i<=n;++i)scanf(\"%d\",&x),M[x]^=1,M[x+1]^=1;\n    for(auto i:M)if(i.second)(i.first&1?a[++*a]:b[++*b])=i.first;\n    for(int i=1;i<=*a;++i)\n        for(int j=1;j<=*b;++j)\n            G[i][j]=Prime(Abs(a[i]-b[j]));\n    for(int i=1;i<=*a;++i)memset(Vis,0,sizeof Vis),Ans+=DFS(i);\n    printf(\"%d\\n\",Ans+(*a-Ans)/2*2+(*b-Ans)/2*2+(*a-Ans)%2*3);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define forn(i, n) for (llong i = 0ll; i < (llong) n; ++i)\n#define fornn(i, l, r) for (llong i = (llong) l; i < (llong) r; ++i)\n#define size(x) ((int) (x.size()))\n \nusing namespace std;\n \ntypedef long long llong;\nconst llong inf = (llong) 1e+9 + 7ll;\nconst llong linf = (llong) 1e+18 + 7ll;\nconst long double eps = (long double) 1e-9;\nconst long double pi = acosl((long double) -1.0);\nconst int alph = 26;\n\nmt19937 mrand(random_device{} ()); \n\ntemplate<typename T, typename U> inline llong umin(const T& a, const U& b) { return a < b ? a : b; }\ntemplate<typename T, typename U> inline llong umax(const T& a, const U& b) { return a > b ? a : b; }\n \nstatic char buff[(int) 2e6 + 17]; // reads std::string\nconst int maxn = (int) 1e7 + 17;\n\nint n;\nint a[200], mt[200];\nvector<int> g[200];\nbool pr[maxn], used[200];\n\nbool read()\n{\n\tif (scanf(\"%d\", &n) != 1)\n\t\treturn false;\n\n\tforn (i, n)\n\t\tscanf(\"%d\", a + i);\n\n\treturn true;\n}\n\nbool dfs(int v)\n{\n\tif (used[v])\n\t\treturn false;\n\n\tused[v] = true;\n\n\tfor (auto to : g[v])\n\t\tif (mt[to] == -1 || dfs(mt[to]))\n\t\t\treturn true;\n\n\treturn false;\n}\n\nvoid solve()\n{\n\tfor (int i = 2; i < maxn; ++i)\n\t\tpr[i] = true;\n\n\tfor (int i = 2; i < maxn; ++i)\n\t\tif (pr[i] && 1ll * i * i < maxn)\n\t\t\tfor (int j = i * i; j < maxn; j += maxn)\n\t\t\t\tpr[j] = false;\n\n\tpr[2] = false;\n\tset<int> s;\n\n\tfor (int i = 0; i < n; ++i)\n\t{\n\t\ts.insert(a[i] + 1);\n\n\t\tif (s.count(a[i]))\n\t\t\ts.erase(a[i]);\n\t\telse\n\t\t\ts.insert(a[i]);\n\t}\n\n\tvector<int> v0, v1;\n\n\tfor (auto i : s)\n\t\ti % 2 == 0 ? v0.push_back(i) : v1.push_back(i);\n\n\tfor (int i = 0; i < size(v0); ++i)\n\t\tfor (int j = 0; j < size(v1); ++j)\n\t\t\tif (pr[abs(v0[i] - v1[j])])\n\t\t\t\tg[i].push_back(j);\n\n\tfor (int i = 0; i < size(v0); ++i)\n\t\tmt[i] = -1;\n\n\tfor (int i = 0; i < size(v0); ++i)\n\t{\n\t\tfill(used, used + size(v0), false);\n\t\tdfs(i);\n\t}\n\n\tint matching = 0;\n\n\tfor (int i = 0; i < size(v0); ++i)\n\t\tmatching += mt[i] != -1;\n\n\tint ans = matching;\n\tans += 2 * ((size(v0) - matching) / 2);\n\tans += 2 * ((size(v1) - matching) / 2);\n\tans += 3 * ((size(v0) - matching) % 2);\n\tprintf(\"%d\\n\", ans);\n}\n\nint main()\n{\n#if SEREZHKA\n\tfreopen(\"file.in\", \"r\", stdin);\n#endif\n\n\twhile (read())\n\t\tsolve();\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 300\n#define M 10000000\nusing namespace std;\n\ninline int read()\n{\n\tint x=0,f=1; char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1; ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0'; ch=getchar();}\n\treturn x*f;\n}\nint n,A[N],B[N],a[M+10],pri[M];\nint mps[N][N],lk[N],vis[N];\nmap<int,int> Ms;\ninline int find(int x)\n{\n\tfor(int i=1;i<=B[0];i++) if(!vis[i]&&mps[x][i])\n\t{\n\t\tvis[i]=1; if(!lk[i]||find(lk[i]))\n\t\t{\n\t\t\tlk[i]=x; return 1;\n\t\t}\n\t}\n\treturn 0;\n}\nint main()\n{\n\ta[1]=1; for(int i=2;i<=M;i++)\n\t{\n\t\tif(!a[i]) pri[++pri[0]]=i;\n\t\tfor(int j=1;j<=pri[0]&&pri[j]*i<=M;j++)\n\t\t{\n\t\t\ta[pri[j]*i]=1; if(i%pri[j]==0) break;\n\t\t}\n\t}\n\tn=read();\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint x=read(); Ms[x]^=1; Ms[x+1]^=1;\n\t}\n\tmap<int,int> ::iterator it=Ms.begin();\n\tfor(;it!=Ms.end();it++) if(it->second)\n\t{\n\t\tif(it->first&1) A[++A[0]]=it->first;\n\t\telse B[++B[0]]=it->first;\n\t}\n\tfor(int i=1;i<=A[0];i++) for(int j=1;j<=B[0];j++)\n\t\tif(!a[abs(A[j]-B[j])]) mps[i][j]=1;\n\tint ct=0; for(int i=1;i<=A[0];i++)\n\t\tmemset(vis,0,sizeof vis),ct+=find(i);\n\tcout << ct+((A[0]-ct)/2+(B[0]-ct)/2)*2+(A[0]-ct)%2*3 << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<map>\n#include<vector>\nusing namespace std;\n#define INF (1 << 29)\nbool prime(int x){\n  if(x == 1)return false;\n  for(int i = 2;i * i <= x;i++){\n    if(x % i == 0)return false;\n  }\n  return true;\n}\n\nclass E{\npublic:\n  int to, lim, inv;\n  E(int a, int b, int c){\n    to = a;\n    lim = b;\n    inv = c;\n  }\n};\n\nvector<E> edge[300];\nint n, x;\nmap<int, int> cnt;\nvector<int> odd, even;\n\nvoid add_edge(int u, int v, int f){\n  edge[u].push_back(E(v, f, edge[v].size()));\n  edge[v].push_back(E(u, 0, edge[u].size() - 1));\n}\n\n\nbool come[300];\nint flow(int s, int t, int f){\n  if(come[s])return 0;\n  come[s] = true;\n  if(s == t)return f;\n  for(int i = 0;i < edge[s].size();i++){\n    E &e = edge[s][i];\n    if(e.lim == 0)continue;\n    int tmp = flow(e.to, t, min(f, e.lim));\n    if(tmp == 0)continue;\n    e.lim -= tmp;\n    edge[e.to][e.inv].lim += tmp;\n    return tmp;\n  }\n  return 0;\n}\n\nint max_flow(int s, int t){\n  int res = 0;\n  while(true){\n    for(int i = 0;i < 300;i++)come[i] = false;\n    int tmp = flow(s, t, INF);\n    if(tmp == 0)return res;\n    res += tmp;\n  }\n}\n\n\nint main(){\n  cin >> n;\n  for(int i = 0;i < n;i++){\n    cin >> x;\n    cnt[x]^=1;\n    cnt[x-1]^=1;\n  }\n  map<int, int>::iterator it;\n  for(it = cnt.begin();it != cnt.end();it++){\n    if(it->second == 0)continue;\n    x = it->first;\n    if(x % 2 == 0)even.push_back(x);\n    if(x % 2 == 1)odd.push_back(x);\n  }\n  int s = even.size() + odd.size() + 1;\n  int t = s + 1;\n  for(int i = 0;i < even.size();i++)add_edge(s, i, 1);\n  for(int i = 0;i < odd.size();i++)add_edge(even.size() + i, t, 1);\n  \n  for(int i = 0;i < even.size();i++){\n    for(int j = 0;j < odd.size();j++){\n      int dif = abs(even[i] - odd[j]);\n      if(prime(dif))add_edge(i, even.size() + j, 1);\n    }\n  }\n\n  int mxf = max_flow(s, t);\n  cout << mxf + (even.size() - mxf) / 2 * 2 + (odd.size() - mxf) / 2 * 2 + (even.size() - mxf) % 2 * 3 << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <map>\n#include <ctime>\n#include <set>\n\n#define Rep(i, n) for (int i = 1; i <= n; i ++)\n#define Rep0(i, n) for (int i = 0; i <= n; i ++)\n#define RepG(i, x) for (int i = head[x]; i; i = edge[i].next)\n#define v edge[i].to\n#define mp(a, b) make_pair(a, b)\n#define fi first\n#define se second\n\nusing namespace std;\n\nconst int N = 210;\n\nbool isnotprime[10000010];\nint prime[10000010], cnt;\nvoid get_prime()\n{\n\tisnotprime[1] = true;\n\tfor (int i = 2; i <= 10000000; i ++) {\n\t\tif (!isnotprime[i]) prime[++ cnt] = i;\n\t\tfor (int j = 1; j <= cnt && i * prime[j] <= 10000000; j ++) {\n\t\t\tisnotprime[i * prime[j]] = true;\n\t\t\tif (!(i % prime[j])) break;\n\t\t}\n\t}\n}\n\nint vv[10000010], p[N], d0[N], d1[N], lnk[N], cd0, cd1;\nbool vis[N];\nbool dfs(int x)\n{\n\tRep(i, cd1) if (!isnotprime[abs(d0[x] - d1[i])] && !vis[i]) {\n\t//\tprintf(\"!%d\\n\", abs(d0[x] - d1[i]));\n\t\tvis[i] = true;\n\t\tif (lnk[i] == -1 || dfs(lnk[i])){ lnk[i] = x; return true;} \n\t}\n\treturn false;\n}\n\nint main()\n{\n\tget_prime();\n\t\n\tint T = 1;\n\t//scanf(\"%d\", &T);\n\twhile (T --){\n\t\tint n;\n\t\tscanf(\"%d\", &n);\n\t\tcd0 = cd1 = 0;\n\t\tRep(i, n) {\n\t\t\tscanf(\"%d\", &p[i]);\n\t\t\tif (vv[p[i]] != T + 1) vv[p[i]] = T + 1;\n\t\t}\n\t\tRep(i, n) {\n\t\t\tif (vv[p[i]] != vv[p[i] - 1]) {\n\t\t\t\tif (p[i] & 1) d1[++ cd1] = p[i];\n\t\t\t\telse d0[++ cd0] = p[i];\n\t\t\t}\n\t\t\tif (vv[p[i]] != vv[p[i] + 1]) {\n\t\t\t\tif (p[i] & 1) d0[++ cd0] = p[i] + 1;\n\t\t\t\telse d1[++ cd1] = p[i] + 1;\n\t\t\t}\n\t\t}\n\t//\tprintf(\"%d %d\\n\", cd0, cd1);\n\t//\tRep(i, cd0) printf(\"_%d \", d0[i]); printf(\"\\n\");\n\t//\tRep(i, cd1) printf(\"_%d \", d1[i]); printf(\"\\n\");\n\t\t\n\t\tint ans = 0, t0 = cd0, t1 = cd1;\n\t\tmemset(lnk, -1, sizeof(lnk));\n\t\tRep(i, cd0) {\n\t\t\tmemset(vis, false, sizeof(vis));\n\t\t\tif (dfs(i)) ans ++, t0 --, t1 --;\n\t\t}\n\t\tans += (t0 / 2) * 2 + (t1 / 2) * 2;\n\t\tif (t0 & 1) ans += 3;\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\t\n\treturn 0;\n}\n/*\n3\n2\n2 3\n3\n1 2 4\n5\n101 102 103 104 105\n*/"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define ui unsigned int\n#define ull unsigned long long\n#define db double\n#define ld long double\n#define pii pair<ll,int>\n#define X first\n#define Y second\n#define mp make_pair\n#define pb push_back\n#define vi vector<int>\n#define vii vector<vi>\n#define lb lower_bound\n#define rep(i,a,b) for(int i=(a);i<=(b);++i)\n#define per(i,b,a) for(int i=(b);i>=(a);--i)\n#define rep0(i,a,b) for(int i=(a);i<(b);++i)\n#define fore(i,a) for(int i=0;i<a.size();++i)\n#define gc() getchar()\n#define ls x<<1,l,m\n#define rs x<<1|1,m+1,r\ninline int rd()\n{\n\tint x=0;char c=gc();while(!isdigit(c))c=gc();\n\twhile(isdigit(c))x=x*10+c-48,c=gc();return x;\n}\nconst int N=205,M=1e7+10;\nint n,cc,tt,a[N],b[M],vis[M],pr[M],hd[N],vv[N],lk[N];\nstruct E{int v,nxt;}e[N*N];\ninline void add(int u,int v){e[++tt]=(E){v,hd[u]};hd[u]=tt;}\nvoid init(int n)\n{\n\tvis[1]=1;\n\trep(i,2,n)\n\t{\n\t\tif(!vis[i])pr[++cc]=i;\n\t\tfor(int j=1;j<=cc&&1ll*i*pr[j]<=n;j++)\n\t\t{\n\t\t\tvis[i*pr[j]]=1;\n\t\t\tif(i%pr[j]==0)break;\n\t\t}\n\t}\n}\nbool dfs(int x)\n{\n\tfor(int i=hd[x],y;i;i=e[i].nxt)if(!vv[y=e[i].v])\n\t{\n\t\tvv[y]=1;\n\t\tif(!lk[y]||dfs(lk[y])){lk[y]=x;return 1;}\n\t}\n\treturn 0;\n}\nint main()\n{\n\tinit(1e7+5);n=rd();\n\trep(i,1,n)a[i]=rd(),b[a[i]]^=1;\n\tn=0;rep0(i,1,M)if(b[i]!=b[i-1])a[++n]=i;\n\tint s=0,n1=0,n2=0;\n\trep(i,1,n)if(a[i]&1)n1++;else n2++;\n\trep(i,1,n)rep(j,i+1,n)if(!vis[abs(a[i]-a[j])])add(i,j),add(j,i);\n\trep(i,1,n)if(a[i]&1){memset(vv,0,sizeof(vv));s+=dfs(i);}\n\tn1-=s;s=n-s+(n1&1);printf(\"%d\\n\",s);return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//satyaki3794\n#include <bits/stdc++.h>\n#define ff first\n#define ss second\n#define pb push_back\n#define MOD (1000000007LL)\n#define LEFT(n) (2*(n))\n#define RIGHT(n) (2*(n)+1)\n \nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> ii;\ntypedef pair<int, ii> iii;\n \nll pwr(ll base, ll p, ll mod=MOD){\nll ans = 1;while(p){if(p&1)ans=(ans*base)%mod;base=(base*base)%mod;p/=2;}return ans;\n}\n \n \nll gcd(ll a, ll b){\n    if(b == 0)  return a;\n    return gcd(b, a%b);\n}\n\n\nconst int N = 1000*10000;\nint n, arr[102], sz, match[1002], sieve[N+2];\nbool visited[1002];\nbool marked[N+2];\nvector<int> evens, odds, adj[1002];\n\n\nint cost(int n){\n\tif(n < 3)\treturn -1;\n\tif(sieve[n] == 0)\treturn 1;\n\tif(n % 2 == 0)\treturn 2;\n\treturn 3;\n}\n\nbool dfs(int v){\n\tfor(auto vv : adj[v])\n\t\tif(!visited[vv]){\n\t\t\tvisited[vv] = true;\n\t\t\tif(match[vv] == -1 || dfs(match[vv])){\n\t\t\t\tmatch[vv] = v;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\treturn false;\n}\n\n\nint bipartite_matching(){\n\tint ans = 0;\n    memset(visited, 0, sizeof(visited));\n    memset(match, -1, sizeof(match));\n    for(int i=1;i<=(int)odds.size();i++)\n        if(dfs(i)){\n            ans++;\n            memset(visited, 0, sizeof(visited));\n        } \n    return ans;\n}\n\n\nint main(){\n \n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n\n    cin>>n;\n    for(int i=1;i<=n;i++){\n    \tcin>>arr[i];\n    \tmarked[arr[i]] = true;\n    }\n\n    sieve[1] = 1;\n    for(int i=2;i<=1000*10000+1;i+=2)\n    \tsieve[i] = 1;\n    for(int i=3;i<=1000*10000+1;i+=2)\n    \tif(!sieve[i])\n    \t\tfor(int j=i;1LL*i*j<=1000*10000+1;j+=2)\n    \t\t\tsieve[i*j] = 1;\n    \n    for(int i=1;i<=N+1;i++)\n    \tif(marked[i] != marked[i-1]){\n    \t\tif(i % 2 == 0)\n    \t\t\tevens.pb(i);\n    \t\telse\n    \t\t\todds.pb(i);\n    \t}\n\n// cout<<\"odds: \";for(auto it : odds)\tcout<<it<<\" \";cout<<endl;\n// cout<<\"evens: \";for(auto it : evens)\tcout<<it<<\" \";cout<<endl;\n\n    for(int i=0;i<(int)odds.size();i++)\n    \tfor(int j=0;j<(int)evens.size();j++)\n    \t\tif(cost(abs(odds[i] - evens[j])) == 1){\n// cout<<\"added edge from \"<<i+1<<\" to \"<<j+1<<endl;\n    \t\t\tadj[i+1].pb(j+1);\n    \t\t}\n\n    int singles = bipartite_matching();\n    int ans = singles*1 + (((int)odds.size()-singles)/2)*2 + (((int)evens.size()-singles)/2)*2 + (((int)odds.size()-singles)%2)*3;\n    cout<<ans;\n    return 0;\n}\n \n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define x first\n#define y second\n#define dbg(x) cout << #x << '=' << x << '\\n';\n#define ll long long\n#define pi pair<int,int>\n#define pl pair<long long,long long>\n#define lg length()\n#define pb push_back\nifstream in(\"file.in\");\nofstream out(\"file.out\");\n#define MAXN 100005\n#define INF 1000000005\n#define LINF 1000000000000000005\n\nint n,x[105],m,p[205],g[205][205],f[205][205],mxf,t,vz[205],ans=1e9,a,b;\nvector <int> q;\n\nbool isP(int n){\n    if(n<3) return 0;\n    int s=sqrt(n);\n    for(int i=2;i<=s;i++){\n        if(!(n%i)) return 0;\n    }\n    return 1;\n}\n\nbool DFS(int nod, int x){\n    int b;\n    vz[nod]=1;\n    q.push_back(nod);\n    if(nod==m+1){\n        mxf=x;\n        return 1;\n    }\n    for(int i=0;i<=m+1;i++){\n        if(!vz[i] && g[nod][i]-f[nod][i]){\n            b=DFS(i,min(x,g[nod][i]-f[nod][i]));\n            if(b) return 1;\n        }\n    }\n    q.pop_back();\n    return 0;\n}\n\nint32_t main(){\n    ios_base :: sync_with_stdio(0);\n    cin >> n;\n    x[0]=-1;\n    for(int i=1;i<=n;i++){\n        cin >> x[i];\n        if(x[i-1]!=x[i]-1){\n            if(m) p[++m]=x[i-1]+1;\n            p[++m]=x[i];\n        }\n    }\n    p[++m]=x[n]+1;\n    for(int i=1;i<=m;i++){\n        if(p[i]%2) a++;\n        else b++;\n        for(int j=i+1;j<=m;j++){\n            if(isP(p[j]-p[i])){\n                if(p[i]%2){\n                    g[0][i]=1;\n                    g[i][j]=1;\n                    g[j][m+1]=1;\n                }\n                else{\n                    g[0][j]=1;\n                    g[j][i]=1;\n                    g[i][m+1]=1;\n                }\n            }\n        }\n    }\n    while(DFS(0,1e9)){\n        for(int i=1;i<q.size();i++){\n            f[q[i-1]][q[i]]+=mxf;\n            f[q[i]][q[i-1]]-=mxf;\n        }\n        t+=mxf;\n        q.clear();\n        mxf=0;\n        for(int i=0;i<=m+1;i++) vz[i]=0;\n    }\n    for(int i=0;i<=t;i++){\n        ans=min(ans,i+((a-i)/2+(b-i)/2)*2+((a-i)%2)*3);\n    }\n    cout << ans;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=110,M=1e7+10;\nint n,x[N],dp[N][N],prime[M],cnt;bool isp[M];\nvoid init(){\n\tisp[1]=1;\n\tfor (int i=2;i<M;i++){\n\t\tif (!isp[i]) prime[++cnt]=i;\n\t\tfor (int j=1;j<=cnt&&i*prime[j]<M;j++){\n\t\t\tisp[i*prime[j]]=1;\n\t\t\tif (i%prime[j]==0) break;\n\t\t}\n\t}\n\tisp[2]=1;\n}\nint calc(int x){\n    if (!x) return 0;\n    if (!isp[x]) return 1;\n    return 2+(x&1);\n}\nint main()\n{\n\tinit();\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<=n;i++) scanf(\"%d\",&x[i]);\n\tfor (int i=1;i<=n;i++) dp[i][i]=3;\n\tfor (int L=1;L<n;L++)\n    for (int l=1;l+L<=n;l++){\n        int r=l+L;\n        dp[l][r]=dp[l+1][r-1]+calc(x[r]-x[l]+1)+calc(x[r]-x[l]-1);\n        if (r-l==x[r]-x[l]) dp[l][r]=calc(x[r]-x[l]+1);\n        for (int i=l;i<r;i++) dp[l][r]=min(dp[l][r],dp[l][i]+dp[i+1][r]);\n\t}\n\tprintf(\"%d\\n\",dp[1][n]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<cstring>\nusing namespace std;\nint n;\nint res;\nvector<int>v;\nint lst=-1;\nint match[210];\nint me,mo;\nint mx;\nbool f[10000010];\nvector<int>ok[210];\nbool vis[210];\nvector<int>prm;\nbool bp(int x)\n{\n\tfor(int i=0;i<ok[x].size();i++)\n\t{\n\t\tint y=ok[x][i];\n\t\tif(vis[y])continue;\n\t\tvis[y]=true;\n\t\tif(match[y]==-1 || bp(match[y]))\n\t\t{\n\t\t\tmatch[y]=x;\n\t\t\treturn true;\n\t\t}\n\t\tvis[y]=false;\n\t}\n\treturn false;\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint x;\n\t\tscanf(\"%d\",&x);\n\t\tif(x!=lst+1)\n\t\t{\n\t\t\tif(lst+1)v.push_back(lst+1);\n\t\t\tv.push_back(x);\n\t\t}\n\t\tlst=x;\n\t\tmx=lst+1;\n\t}\n\tv.push_back(lst+1);\n\tf[1]=true;\n\tfor(int i=2;i<=mx;i++)\n\t{\n\t\tif(!f[i])prm.push_back(i);\n\t\tfor(int j=0;j<prm.size() && prm[j]*i<=mx;j++)f[prm[j]*i]=true;\n\t}\n\tint l=v.size();\n\tfor(int i=0;i<l;i++)\n\t{\n\t\tmatch[i]=-1;\n\t\tif(v[i]&1)mo++;else me++;\n\t\tfor(int j=i+1;j<l;j++)\n\t\t{\n\t\t\tif(v[j]-v[i]!=2 && !f[v[j]-v[i]])\n\t\t\t{\n\t\t\t\tok[i].push_back(j);\n\t\t\t\tok[j].push_back(i);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<l;i++)\n\t{\n\t\tmemset(vis,false,sizeof(vis));\n\t\tif(bp(i))res++;\n\t}\n\tres/=2;\n\tprintf(\"%d\",res+((me-res)/2+(mo-res)/2)*2+((me-res)%2)*3);\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\nint n;\nvector<int>vi,vecc,vec[2];\nint O,E;\nstruct edge\n{\n\tint to,cap,rev;\n};\nvector<edge>G[405];\nbool used[405];\n\nvoid add_edge(int from,int to,int cap)\n{\n\tG[from].push_back((edge){to,cap,G[to].size()});\n\tG[to].push_back((edge){from,0,G[from].size()-1});\n}\nint dfs(int v,int t,int f)\n{ \n\tif(v==t) return f;\n\tused[v]=true;\n\tfor(int i=0;i<G[v].size();i++)\n\t{\n\t\tedge &e=G[v][i];\n\t\tif(!used[e.to] && e.cap>0)\n\t\t{ \n\t\t\tint d=dfs(e.to,t,min(f,e.cap));\n\t\t\tif(d>0) \n\t\t\t{ \n\t\t\t\te.cap-=d;\n\t\t\t\tG[e.to][e.rev].cap+=d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nint max_flow(int s,int t)\n{ \n\tint flow=0;\n\twhile(1)\n\t{ \n\t\tmemset(used,0,sizeof(used));\n\t\tint f=dfs(s,t,INF);\n\t\tif(!f) return flow;\n\t\tflow+=f;\n\t}\n}\nbool f(int v){\n\tfor(int i=2;i*i<=v;i++) if(v%i==0) return 0;\n\treturn 1;\n}\nint main(){\n\tcin >> n;\n\tfor(int i=0;i<n;i++){\n\t\tint a; cin >> a; vi.pb(a);\n\t\tif(i==0 || vi[i-1]+1 != vi[i]){\n\t\t\tvecc.pb(a);\n\t\t}\n\t\tif(i && vi[i-1]+1 != vi[i]){\n\t\t\tvecc.pb(vi[i-1]+1);\n\t\t}\n\t\tif(i==n-1){\n\t\t\tvecc.pb(vi[i]+1);\n\t\t}\n\t}\n\tfor(int i=0;i<vecc.size();i++){\n\t\tvec[vecc[i]%2].pb(vecc[i]);\n\t}\n\tO = vec[1].size(),E = vec[0].size();\n\tfor(int i=0;i<O;i++) add_edge(403,i,1);\n\tfor(int i=0;i<E;i++) add_edge(O+i,404,1);\n\tfor(int i=0;i<O;i++){\n\t\tfor(int j=0;j<E;j++){\n\t\t\tint x = abs(vec[1][i]-vec[0][j]);\n\t\t\tif(x>=3 && f(x)) add_edge(i,O+j,1);\n\t\t}\n\t}\n\tint ans = max_flow(403,404);\n\tO-=ans; E-=ans;\n\tif( (O%2) + (E%2) == 2) ans += O+E+1;\n\telse ans += O+E;\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nstruct Bipartite_Matching\n{\n  vector< vector< int > > graph;\n  vector< int > match, alive, used;\n  int timestamp;\n\n  Bipartite_Matching(int n)\n  {\n    timestamp = 0;\n    graph.resize(n);\n    alive.assign(n, 1);\n    used.assign(n, 0);\n    match.assign(n, -1);\n  }\n\n  void add_edge(int u, int v)\n  {\n    graph[u].push_back(v);\n    graph[v].push_back(u);\n  }\n\n  bool dfs(int v)\n  {\n    used[v] = timestamp;\n    for(int i = 0; i < graph[v].size(); i++) {\n      int u = graph[v][i], w = match[u];\n      if(alive[u] == 0) continue;\n      if(w == -1 || (used[w] != timestamp && dfs(w))) {\n        match[v] = u;\n        match[u] = v;\n        return (true);\n      }\n    }\n    return (false);\n  }\n\n  int bipartite_matching()\n  {\n    int ret = 0;\n    for(int i = 0; i < graph.size(); i++) {\n      if(alive[i] == 0) continue;\n      if(match[i] == -1) {\n        ++timestamp;\n        ret += dfs(i);\n      }\n    }\n    return (ret);\n  }\n};\n\n\nconst int LIM = (int) 1e7;\nbool prime[LIM + 1];\n\nint main()\n{\n  prime[0] = prime[1] = true;\n  for(int i = 2; i * i <= LIM; i++) {\n    if(!prime[i]) {\n      for(int j = i + i; j <= LIM; j += i) {\n        prime[j] = true;\n      }\n    }\n  }\n\n  int N;\n  cin >> N;\n  vector< int > vs;\n  for(int i = 0; i < N; i++) {\n    int x;\n    cin >> x;\n    if(vs.empty() || vs.back() + 1 != x) {\n      vs.emplace_back(x - 1);\n      vs.emplace_back(x);\n    } else {\n      ++vs.back();\n    }\n  }\n\n  vector< int > latte, malta;\n  for(auto &p : vs) {\n    if(p & 1) latte.emplace_back(p);\n    else malta.emplace_back(p);\n  }\n\n  int ret = 0;\n\n  if(!latte.empty() && !malta.empty()) {\n    Bipartite_Matching flow(latte.size() + malta.size());\n    for(int i = 0; i < latte.size(); i++) {\n      for(int j = 0; j < malta.size(); j++) {\n        if(!prime[abs(latte[i] - malta[j])]) {\n          flow.add_edge(i, j + latte.size());\n        }\n      }\n    }\n    ret = flow.bipartite_matching();\n  }\n\n  int beet1 = latte.size() - ret;\n  int beet2 = malta.size() - ret;\n  ret += beet1 / 2 * 2;\n  ret += beet2 / 2 * 2;\n  ret += beet1 % 2 * 3;\n  cout << ret << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N=1e7+1e2;\n\ntemplate<typename T>inline void read(T &x)\n{\n\tx=0;T c=getchar(),p=1;\n\twhile(!isdigit(c)){if(c=='-')p=-1;c=getchar();}\n\twhile(isdigit(c)){x=(x<<1)+(x<<3)+(c^'0');c=getchar();}\n\tx*=p;\n}\n\nint n;\nint P[105];\n\nint cnt,ispri[N],pri[N];\n\ninline void Getprime(int Up)\n{\n\tfor(int i=2;i<=Up;i++)ispri[i]=1;\n\tfor(int i=2;i<=Up;i++){\n\t\tif(ispri[i])pri[++cnt]=i;\n\t\tfor(int j=1;j<=cnt && i*pri[j]<=Up;j++){\n\t\t\tispri[i*pri[j]]=0;\n\t\t\tif(i%pri[j]==0)break;\n\t\t}\n\t}\n}\n\ninline void File()\n{\n\tfreopen(\"magic.in\",\"r\",stdin);\n\tfreopen(\"magic.out\",\"w\",stdout);\n}\n\nconst int M=2e6+1e2;\n\nint e,tot,tot1,tot2,point,A[505],B[505],pre[505],match[505],vis[505],beg[2030],nex[2030],to[2030];\n\ninline void add(int x,int y)\n{\n\te++;\n\tnex[e]=beg[x];\n\tbeg[x]=e;\n\tto[e]=y;\n}\n\ninline bool Dfs(int x)\n{\n\tfor(int i=beg[x];i;i=nex[i]){\n\t\tint y=to[i];\n\t\tif(vis[y]!=tot){\n\t\t\tvis[y]=tot;\n\t\t\tif(match[y]==-1 || Dfs(match[y])){\n\t\t\t\tmatch[y]=x;\n\t\t\t\tpre[x]=y;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint main()\n{\n\t//File();\n\tGetprime(N);\n\tread(n);\n\tfor(int i=1;i<=n;i++)read(P[i]);\n\tif(P[1]&1)A[++tot1]=P[1];\n\telse B[++tot2]=P[1];\n\tfor(int i=2;i<=n;i++){\n\t\tif(P[i]!=P[i-1]+1){\n\t\t\tif((P[i-1]+1)&1)A[++tot1]=P[i-1]+1;\n\t\t\telse B[++tot2]=P[i-1]+1;\n\t\t\tif(P[i]&1)A[++tot1]=P[i];\n\t\t\telse B[++tot2]=P[i];\n\t\t}\n\t}\n\tif((P[n]+1)&1)A[++tot1]=P[n]+1;\n\telse B[++tot2]=P[n]+1;\n\tfor(int i=1;i<=tot1;i++)\n\t\tfor(int j=1;j<=tot2;j++)\n\t\t\tif(ispri[abs(A[i]-B[j])])add(i,j);\n\tint Ans=0;\n\tmemset(match,-1,sizeof match);\n\tfor(int i=1;i<=tot1;i++){\n\t\ttot++;\n\t\tAns+=Dfs(i);\n\t}\n\tint T=0,D=0;\n\tfor(int i=1;i<=tot1;i++)\n\t\tif(!pre[i])T++;\n\tfor(int i=1;i<=tot2;i++)\n\t\tif(match[i]==-1)D++;\n\tAns+=T/2*2;Ans+=D/2*2;\n\tif(T&1)Ans+=3;\n\tprintf(\"%d\\n\",Ans);\n\treturn 0;\n}\t\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<cmath>\n#define N 210\n#define M 10000010\nusing namespace std;\nint prime[M],link[N],tot;\nbool p[M],vis[N];\nint n;\nbool can[N][N],s[M];\nvector<int>v[2];\nbool check(int u)\n{\n\tfor(int i=1;i<=v[1].size();i++)\n\tif(can[u][i] && !vis[i])\n\t{\n\t\tvis[i]=1;\n\t\tif(!link[i] || check(link[i]))\n \t\t{\n\t\t\tlink[i]=u;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\nint main()\n{\n\tp[1]=true;\n\tfor(int i=2;i<=M-10;i++)\n\t{\n\t\tif(!p[i]) prime[++tot]=i;\n\t\tfor(int j=1;j<=tot && i*prime[j]<=N-10;j++)\n\t\t{\n\t\t\tp[i*prime[j]]=1;\n\t\t\tif(i%prime[j]==0) break;\n\t\t}\n\t}\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint u;\n\t\tscanf(\"%d\",&u);\n\t\ts[u]=true;\n\t}\n\tfor(int i=1;i<=M-10;i++)\n\tif(s[i]^s[i-1]) v[i&1].push_back(i);\n\tfor(int i=0;i<v[0].size();i++)\n\t\tfor(int j=0;j<v[1].size();j++)\n\t\tif(!p[abs(v[0][i]-v[1][j])]) can[i+1][j+1]=true;\n\tint ans=0;\n    for(int i=0;i<v[0].size();i++)\n\t{\n\t\tmemset(vis,0,sizeof(vis));\n\t\tans+=check(i+1);\n\t}\n\tint tmp=ans;\n\tans+=(v[0].size()-ans)/2*2+(v[1].size()-ans)/2*2;\n    if((v[0].size()&1)!=(tmp&1)) ans+=3;\n\tprintf(\"%d\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntemplate< typename T = int >\nT Hungarian(vector< vector< T > > &A)\n{\n  const T infty = numeric_limits< T >::max();\n  const int N = (int) A.size() - 1;\n  const int M = (int) A[0].size() - 1;\n  vector< int > P(M + 1), way(M + 1);\n  vector< T > U(N + 1, 0), V(M + 1, 0), minV;\n  vector< bool > used;\n\n  for(int i = 1; i <= N; i++) {\n    P[0] = i;\n    minV.assign(M + 1, infty);\n    used.assign(M + 1, false);\n    int j0 = 0;\n    while(P[j0] != 0) {\n      int i0 = P[j0], j1 = 0;\n      used[j0] = true;\n      T delta = infty;\n      for(int j = 1; j <= M; j++) {\n        if(used[j]) continue;\n        T curr = A[i0][j] - U[i0] - V[j];\n        if(curr < minV[j]) minV[j] = curr, way[j] = j0;\n        if(minV[j] < delta) delta = minV[j], j1 = j;\n      }\n      for(int j = 0; j <= M; j++) {\n        if(used[j]) U[P[j]] += delta, V[j] -= delta;\n        else minV[j] -= delta;\n      }\n      j0 = j1;\n    }\n    do {\n      P[j0] = P[way[j0]];\n      j0 = way[j0];\n    } while(j0 != 0);\n  }\n  return (-V[0]);\n}\n\nconst int LIM = (int) 1e7;\nbool prime[LIM + 1];\n\nint main()\n{\n  prime[0] = prime[1] = true;\n  for(int i = 2; i * i <= LIM; i++) {\n    if(!prime[i]) {\n      for(int j = i + i; j <= LIM; j += i) {\n        prime[j] = true;\n      }\n    }\n  }\n\n  int N;\n  cin >> N;\n  vector< int > vs;\n  for(int i = 0; i < N; i++) {\n    int x;\n    cin >> x;\n    if(vs.empty() || vs.back() + 1 != x) {\n      vs.emplace_back(x - 1);\n      vs.emplace_back(x);\n    } else {\n      ++vs.back();\n    }\n  }\n\n  vector< int > latte, malta;\n  for(auto &p : vs) {\n    if(p & 1) latte.emplace_back(p);\n    else malta.emplace_back(p);\n  }\n\n  int ret = 0;\n\n  if(!latte.empty() && !malta.empty()) {\n    if(latte.size() > malta.size()) swap(latte, malta);\n    vector< vector< int > > g(latte.size() + 1, vector< int >(malta.size() + 1, 0));\n    for(int i = 0; i < latte.size(); i++) {\n      for(int j = 0; j < malta.size(); j++) {\n        if(!prime[abs(latte[i] - malta[j])]) {\n          g[i + 1][j + 1] = -1;\n        }\n      }\n    }\n    ret = -Hungarian(g);\n  }\n\n  int beet1 = latte.size() - ret;\n  int beet2 = malta.size() - ret;\n  ret += beet1 / 2 * 2;\n  ret += beet2 / 2 * 2;\n  ret += beet1 % 2 * 3;\n  cout << ret << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>     \n#define ll long long\n#define mk make_pair\n#define y1 yyyy\nusing namespace std;\n\nconst int N = 5e4 + 5;\nconst int mod = 1e9 + 7;\n\nint n, a[N], my[N], ans;\nbool b[N * 200];\nvector<int> V[2], G[N];\n\nbool find(int x) {\n\tb[x] = 1;\n\tfor (int i = 0; i < G[x].size(); i++) {\n\t\tint u = G[x][i];\n\t\tif (my[u] == -1) {\n\t\t\tmy[u] = x;\n\t\t\treturn 1;\n\t\t} else {\n\t\t\tif (!b[my[u]] && find(my[u])) {\n\t\t\t\tmy[u] = x;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nbool check(int x) {\n\tif (x == 2) return 0;\n\tfor (int i = 2; i * i <= x; i++) {\n\t\tif (x % i == 0) return 0;\n\t}\n\treturn 1;\n}\n\nint main() {\n\tcin >> n;\n\tfor (int i = 1; i <= n; i++) cin >> a[i], b[a[i]] = 1;\n\tfor (int i = 1; i <= 10000001; i++) {\n\t\tif (b[i] != b[i - 1]) V[i & 1].push_back(i);\n\t}\n\tmemset(my, -1, sizeof(my));\n\tfor (int i = 0; i < V[0].size(); i++) {\n\t\tfor (int j = 0; j < V[1].size(); j++) {\n\t\t\tif (check(abs(V[0][i] - V[1][j]))) \n\t\t\t\tG[i].push_back(j);\n\t\t}\n\t}\n\tfor (int i = 0; i < V[0].size(); i++) {\n\t\tfor (int j = 0; j < V[0].size(); j++) b[j] = 0;\n\t\tif (find(i)) ans++;\n\t}\n\tcout << ans + (V[0].size() - ans) / 2 + (V[1].size() - ans) / 2 + V[0].size() % 2;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define REP(i, a, b) for(int i = (a), i##end = (b); i <= i##end; ++ i)\n#define CLR(i, a) memset(i, a, sizeof(i))\n#define REPD(i, a, b) for(int i = (a), i##end = (b); i >= i##end; -- i)\n#define REPG(i, x) for(int i = head[x], v; i; i = edge[i].next)\n\ntypedef long long LL;\ntypedef double DB;\n \n#define pc putchar\n#define gc getchar\n#define endl '\\n'\ninline LL rd() {\t\n\tchar ch = gc(); LL ret = 0, sgn = 1;\n\twhile(ch < '0' || ch >'9') {\n\t\tif(ch == '-') sgn = -1;\n\t\tch = gc();\n\t}\n\twhile(ch >= '0' && ch <= '9')\n\t\tret = ret * 10 + ch - '0', ch = gc();\n\treturn ret * sgn;\n}\n \ninline void out(LL x) {\n\tstatic int buf[50], btp;\n\tif(x < 0) x = -x, pc('-');\n\tif(!x) pc('0');\n\telse {\n\t\tbtp = 0;\n\t\tfor(; x; x /= 10) buf[++ btp] = x % 10;\n\t\twhile(btp) pc('0' + buf[btp --]);\n\t}\n}\n \nDB _BEGIN;\n#define LOG(x) cerr << #x << \":\" << x << endl\n#define DBG(...) fprintf(stderr, __VA_ARGS__)\n#define OK DBG(\"Passing [%s] in LINE %d...\\n\", __FUNCTION__, __LINE__)\n#define _TIME (int((clock() - _BEGIN) / (DB)CLOCKS_PER_SEC * 1000))\n\n/**************************************/\n\nconst int N = 250 + 3;\n\nint head[N], cnt;\nstruct qwq { int v, next; } edge[(210 * 210) << 1];\ninline void add(int x, int y) {\n\tedge[++ cnt] = (qwq) { y, head[x] }, head[x] = cnt;\n}\nint lft[N], rt[N], lsz, rsz;\nconst int M = 1e7 + 2;\nbool isnotp[M + 1];\nint tot, p[700000], vis[N], tim, opn[N], n, a[N];\ninline void Sieve() {\n\tisnotp[1] = 1;\n\tREP(i, 2, M) {\n\t\tif(!isnotp[i]) p[++ tot] = i;\n\t\tREP(j, 1, tot) {\n\t\t\tif((LL)i * p[j] > M) break;\n\t\t\tisnotp[i * p[j]] = 1;\n\t\t\tif(i % p[j] == 0) break;\n\t\t}\n\t}\n}\n\nint Aug(int x) {\n\t// LOG(x);\n\tREPG(i, x) if(vis[(v = edge[i].v)] != tim) { \n\t\tvis[v] = tim;\n\t\tif(!opn[v] || Aug(opn[v])) {\n\t\t\topn[x] = v, opn[v] = x;\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nint main() {\n#ifdef LOCAL\n\tfreopen(\"light_example_3.in\", \"r\", stdin);\n#endif\n\tSieve();\n\t// for(int T = rd(); T; -- T) {\n\t\t// cout<<T<<endl;\n\t\tn = rd();\n\t\tcnt = 0;\n\t\t\n\t\tlsz = rsz = 0;\n\t\tREP(i, 1, n) a[i] = rd();\n\t\t\n\t\tif(a[1] & 1) rt[++ rsz] = a[1];\n\t\telse lft[++ lsz] = a[1];\n\t\tREP(i, 2, n) {\n\t\t\tif(a[i - 1] != a[i] - 1) {\n\t\t\t\tif(a[i] & 1) rt[++ rsz] = a[i];\n\t\t\t\telse lft[++ lsz] = a[i];\n\t\t\t} \n\t\t\tif(a[i - 1] + 1 != a[i]) {\n\t\t\t\tif((a[i - 1] + 1) & 1) rt[++ rsz] = a[i - 1] + 1;\n\t\t\t\telse lft[++ lsz] = a[i - 1] + 1;\n\t\t\t}\n\t\t}\n\t\tif((a[n] + 1) & 1) rt[++ rsz] = a[n] + 1;\n\t\telse lft[++ lsz] = a[n] + 1;\n\n\t\tREP(i, 1, lsz) {\n\t\t\tREP(j, 1, rsz) {\n\t\t\t\tint x = lft[i], y = rt[j];\n\t\t\t\tif(isnotp[abs(x - y)]) continue;\n\t\t\t\tif(abs(x - y) & 1) add(i, lsz + j), add(lsz + j, i);\n\t\t\t}\n\t\t}\n\n\t\tfill(vis + 1, vis + lsz + rsz + 1, 0);\n\t\tfill(opn + 1, opn + lsz + rsz + 1, 0);\n\t\ttim = 0;\n\t\tint ret = 0;\n\t\tREP(i, 1, lsz) if(!opn[i]) {\n\t\t\t++ tim;\n\t\t\tret += Aug(i);\n\t\t}\n\n\t\tint ans = ret;\n\t\tans += ((lsz - ret) / 2 + (rsz - ret) / 2) * 2;\n\t\tans += ((rsz - ret) % 2) * 3;\n\t\tout(ans), pc(endl);\n\t\t// fflush(stdout);\n\n\t\tfill(head + 1, head + lsz + rsz + 1, 0);\n\t// }\n\n#ifdef LOCAL\n\tLOG(_TIME);\n#endif\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <map>\n#include <set>\n#include <bitset>\n#include <numeric>\n#include <utility>\n#include <iomanip>\n#include <algorithm>\n#include <functional>\nusing namespace std;\n \n#define COUT(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << endl\n#define EACH(i, s) for (__typeof__((s).begin()) i = (s).begin(); i != (s).end(); ++i)\n \ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\ntemplate<class T1, class T2> ostream& operator << (ostream &s, pair<T1,T2> P)\n{ return s << '<' << P.first << \", \" << P.second << '>'; }\ntemplate<class T> ostream& operator << (ostream &s, vector<T> P)\n{ for (int i = 0; i < P.size(); ++i) { if (i > 0) { s << \" \"; } s << P[i]; } return s; }\ntemplate<class T> ostream& operator << (ostream &s, vector<vector<T> > P)\n{ for (int i = 0; i < P.size(); ++i) { s << endl << P[i]; } return s << endl; }\ntemplate<class T1, class T2> ostream& operator << (ostream &s, map<T1,T2> P)\n{ EACH(it, P) { s << \"<\" << it->first << \"->\" << it->second << \"> \"; } return s << endl; }\n\n\n\nconst int MAX_L = 2100;\nconst int MAX_R = 2100;\n\nstruct Graph {\n\tint L;\n\tvector<int> list[MAX_L];\n\n\tvoid init(int n = 0) { L = n; for (int i = 0; i < MAX_L; ++i) list[i].clear(); }\n\tinline vector<int>& operator [] (int i) { return list[i]; }\n\tvoid addedge(int from, int to) { list[from].push_back(to); }\n\tfriend ostream& operator << (ostream& s, const Graph& G) {\n\t\ts << endl; for (int i = 0; i < G.L; ++i) { s << i << \" : \" << G.list[i] << endl; }return s;\n\t}\n};\n\nGraph G;\n\nint L = 0;\nbool seen[MAX_L];\nbool matched[MAX_L];\nint level[MAX_L];\nint matching[MAX_R];\n\nvoid hobfs(Graph &G) {\n\tqueue<int> que;\n\tfor (int left = 0; left < L; ++left) {\n\t\tlevel[left] = -1;\n\t\tif (!matched[left]) {\n\t\t\tque.push(left);\n\t\t\tlevel[left] = 0;\n\t\t}\n\t}\n\tlevel[L] = L;\n\twhile (!que.empty()) {\n\t\tint left = que.front();\n\t\tque.pop();\n\t\tfor (int i = 0; i < G[left].size(); ++i) {\n\t\t\tint right = G[left][i];\n\t\t\tint next = matching[right];\n\t\t\tif (level[next] == -1) {\n\t\t\t\tlevel[next] = level[left] + 1;\n\t\t\t\tque.push(next);\n\t\t\t}\n\t\t}\n\t}\n}\n\nbool hodfs(Graph &G, int left) {\n\tif (left == L) return true;\n\tif (seen[left]) return false;\n\tseen[left] = true;\n\tfor (int i = 0; i < G[left].size(); ++i) {\n\t\tint right = G[left][i];\n\t\tint next = matching[right];\n\t\tif (level[next] > level[left] && hodfs(G, next)) {\n\t\t\tmatching[right] = left;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint Hopcroft_Karp(Graph &G) {\n\tL = G.L;\n\tfor (int i = 0; i < MAX_R; ++i) matching[i] = L;\n\tmemset(matched, 0, sizeof(matched));\n\n\tint res = 0;\n\twhile (true) {\n\t\thobfs(G);\n\t\tmemset(seen, 0, sizeof(seen));\n\t\tbool finished = true;\n\t\tfor (int left = 0; left < L; ++left) {\n\t\t\tif (!matched[left] && hodfs(G, left)) {\n\t\t\t\tmatched[left] = true;\n\t\t\t\t++res;\n\t\t\t\tfinished = false;\n\t\t\t}\n\t\t}\n\t\tif (finished) break;\n\t}\n\treturn res;\n}\n\n\nconst int MAX = 10001000;\nbool IsPrime[MAX];\nvector<int> Era(int n = MAX) {\n    vector<int> res;\n\tIsPrime[0] = false; IsPrime[1] = false; \n\tfor (int i = 2; i < n; ++i) IsPrime[i] = true;\n\tfor (int i = 2; i < n; ++i) {\n\t\tif (IsPrime[i]) {\n            res.push_back(i);\n\t\t\tfor (int j = i*2; j < n; j += i) IsPrime[j] = false;\n\t\t}\n\t}\n    return res;\n}\n\n\nint N;\nint a[MAX];\nint diff[MAX];\n\nint solve() {\n  diff[0] = a[0];\n  for (int i = 0; i+1 < MAX; ++i) {\n\tdiff[i+1] = a[i+1] ^ a[i];\n  }\n  vector<int> odd, even;\n  for (int i = 0; i < MAX; ++i) {\n\tif (diff[i] == 1) {\n\t  if (i % 2 == 0) even.push_back(i);\n\t  else odd.push_back(i);\n\t}\n  }\n\n  G.init(odd.size());\n  \n  for (int i = 0; i < odd.size(); ++i) {\n\tfor (int j = 0; j < even.size(); ++j) {\n\t  if (IsPrime[abs(odd[i] - even[j])]) {\n\t\tG.addedge(i, j);\n\t  }\n\t}\n  }\n\n  int Max = Hopcroft_Karp(G);\n  int evenrem = even.size() - Max;\n  int oddrem = odd.size() - Max;\n\n  int res = Max + evenrem / 2 * 2 + oddrem / 2 * 2;\n  if (evenrem & 1) {\n\tres += 3;\n  }\n\t\t\t\t \n  return res;\n}\n\nint main() {\n  Era();\n  while (cin >> N) {\n\tmemset(a, 0, sizeof(a));\n\tfor (int i = 0; i < N; ++i) {\n\t  int x;\n\t  cin >> x;\n\t  a[x] = 1;\n\t}\n\tcout << solve() << endl;\n  }\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define X first\n#define Y second\n#define mp make_pair\n#define pb push_back\n#define rep(i,a,n) for(int i=(a);i<=(n);++i)\n#define dep(i,a,n) for(int i=(a);i>=(n);--i)\n#define eps 1e-8\n#define pi 3.1415926535897\n#define sqr(x) ((x)*(x))\n#define MAX(a,b) a=max(a,b)\n#define MIN(a,b) a=min(a,b)\n#define SZ(x) ((int)(x).size())\n#define CPY(a,b) memcpy(a,b,sizeof(a))\n#define CLR(a) memset(a,0,sizeof(a))\n#define POSIN(x,y) (1<=(x)&&(x)<=n&&1<=(y)&&(y)<=m)\n#define all(x) (x).begin(),(x).end()\n#define COUT(S,x) cout<<fixed<<setprecision(x)<<S<<endl\n#define buli(x) (__builtin_popcountll(x))\n#define bur0(x) (__builtin_ctzll(x))\n#define bul2(x) (63-__builtin_clzll(x))\n#define pw(x) ((ll(1))<<(x))\n#define upmo(a,b) (((a)=((a)+(b))%mo)<0?(a)+=mo:(a))\n#define mmo(a,b) (((a)=1ll*(a)*(b)%mo)<0?(a)+=mo:(a))\n#define y0 y0z\n#define y1 y1z\n#define yn ynz\n#define j0 j0z\n#define j1 j1z\n#define jn jnz\n#define tm tmz\n#ifdef LOCAL\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#else\n#define debug(...) \n#endif\ntypedef long long ll;\ntypedef double lf;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef pair<lf,lf> pff;\ntypedef complex<double> CD;\nconst int inf=0x3f3f3f3f;\nconst int mo=1000000007;\ninline void gn(long long&x){\n\tint sg=1;char c;while(((c=getchar())<'0'||c>'9')&&c!='-');c=='-'?(sg=-1,x=0):(x=c-'0');\n\twhile((c=getchar())>='0'&&c<='9')x=x*10+c-'0';x*=sg;\n}\ninline void gn(int&x){long long t;gn(t);x=t;}\ninline void gn(unsigned long long&x){long long t;gn(t);x=t;}\ninline void gn(double&x){double t;scanf(\"%lf\",&t);x=t;}\ninline void gn(long double&x){double t;scanf(\"%lf\",&t);x=t;}\ntemplate<class T1,class T2>inline void gn(T1&r,T2&s){gn(r),gn(s);}\ntemplate<class T1,class T2,class T3>inline void gn(T1&r,T2&s,T3&t){gn(r),gn(s),gn(t);}\ntemplate<class T1,class T2,class T3,class T4>inline void gn(T1&r,T2&s,T3&t,T4&u){gn(r),gn(s),gn(t),gn(u);}\ninline void gs(char *s){scanf(\"%s\",s);}\ninline void gc(char &c){while((c=getchar())>126 || c<33);}\ninline void pc(char c){putchar(c);}\nconst int DX[]={1,0,-1,0},DY[]={0,1,0,-1};\nll powmod(ll a,ll b) {ll res=1;a%=mo;for(;b;b>>=1){if(b&1)res=res*a%mo;a=a*a%mo;}return res;}\nll powmod(ll a,ll b,ll mo) {ll res=1;a%=mo;for(;b;b>>=1){if(b&1)res=res*a%mo;a=a*a%mo;}return res;}\nll gcd(ll a,ll b) { return b?gcd(b,a%b):a;}\n//*******************************************\n\n\nnamespace Factor {\n    const int N=5010000;\n    ll C,fac[10010],n,mut,a[5001000];\n    int T,cnt,i,l,prime[N],p[N],psize,_cnt,tot=0;\n    ll _e[100],_pr[100];\n    vector<ll> d;\n    inline ll mul(ll a,ll b,ll p) {\n        if (p<=1000000000) return a*b%p;\n        else if (p<=1000000000000ll) return (((a*(b>>20)%p)<<20)+(a*(b&((1<<20)-1))))%p;\n        else {\n            ll d=(ll)floor(a*(long double)b/p+0.5);\n            ll ret=(a*b-d*p)%p;\n            if (ret<0) ret+=p;\n            return ret;\n        }\n    }\n    void prime_table(){\n        int i,j,t1;\n        for (i=1;i<=psize;i++) p[i]=i;\n        for (i=2,tot=0;i<=psize;i++){\n            if (p[i]==i) prime[++tot]=i;\n            for (j=1;j<=tot && (t1=prime[j]*i)<=psize;j++){\n                p[t1]=prime[j];\n                if (i%prime[j]==0) break;\n            }\n        }\n    }\n    void init(int ps) {\n        psize=ps;\n        prime_table();\n    }\n    ll powl(ll a,ll n,ll p) {\n        ll ans=1;\n        for (;n;n>>=1) {\n            if (n&1) ans=mul(ans,a,p);\n            a=mul(a,a,p);\n        }\n        return ans;\n    }\n    bool witness(ll a,ll n) {\n        int t=0;\n        ll u=n-1;\n        for (;~u&1;u>>=1) t++;\n        ll x=powl(a,u,n),_x=0;\n        for (;t;t--) {\n            _x=mul(x,x,n);\n            if (_x==1 && x!=1 && x!=n-1) return 1;\n            x=_x;\n        }\n        return _x!=1;\n    }\n    bool miller(ll n) {\n        if (n<2) return 0;\n        if (n<=psize) return p[n]==n;\n        if (~n&1) return 0;\n        for (int j=0;j<=7;j++) if (witness(rand()%(n-1)+1,n)) return 0;\n        return 1;\n    }\n    ll gcd(ll a,ll b) {\n        ll ret=1;\n        while (a!=0) {\n            if ((~a&1) && (~b&1)) ret<<=1,a>>=1,b>>=1;\n            else if (~a&1) a>>=1; else if (~b&1) b>>=1;\n            else {\n                if (a<b) swap(a,b);\n                a-=b;\n            }\n        }\n        return ret*b;\n    }\n    ll rho(ll n) {\n        for (;;) {\n            ll X=rand()%n,Y,Z,T=1,*lY=a,*lX=lY;\n            int tmp=20;\n            C=rand()%10+3;\n            X=mul(X,X,n)+C;*(lY++)=X;lX++;\n            Y=mul(X,X,n)+C;*(lY++)=Y;\n            for(;X!=Y;) {\n                ll t=X-Y+n;\n                Z=mul(T,t,n);\n                if(Z==0) return gcd(T,n);\n                tmp--;\n                if (tmp==0) {\n                    tmp=20;\n                    Z=gcd(Z,n);\n                    if (Z!=1 && Z!=n) return Z;\n                }\n                T=Z;\n                Y=*(lY++)=mul(Y,Y,n)+C;\n                Y=*(lY++)=mul(Y,Y,n)+C;\n                X=*(lX++);\n            }\n        }\n    }\n    void _factor(ll n) {\n        for (int i=0;i<cnt;i++) {\n            if (n%fac[i]==0) n/=fac[i],fac[cnt++]=fac[i];}\n        if (n<=psize) {\n            for (;n!=1;n/=p[n]) fac[cnt++]=p[n];\n            return;\n        }\n        if (miller(n)) fac[cnt++]=n;\n        else {\n            ll x=rho(n);\n            _factor(x);_factor(n/x);\n        }\n    }\n    void dfs(ll x,int dep) {\n        if (dep==_cnt) d.pb(x);\n        else {\n            dfs(x,dep+1);\n            for (int i=1;i<=_e[dep];i++) dfs(x*=_pr[dep],dep+1);\n        }\n    }\n    void norm() {\n        sort(fac,fac+cnt);\n        _cnt=0;\n        rep(i,0,cnt-1) if (i==0||fac[i]!=fac[i-1]) _pr[_cnt]=fac[i],_e[_cnt++]=1;\n            else _e[_cnt-1]++;\n    }\n    vector<ll> getd() {\n        d.clear();\n        dfs(1,0);\n        return d;\n    }\n    vector<ll> factor(ll n) {\n        cnt=0;\n        _factor(n);\n        norm();\n        return getd();\n    }\n    vector<pll> factorG(ll n) {\n        cnt=0;\n        _factor(n);\n        norm();\n        vector<pll> d;\n        rep(i,0,_cnt-1) d.pb(mp(_pr[i],_e[i]));\n        return d;\n    }\n    bool is_primitive(ll a,ll p) {\n        //assert(miller(p));\n        vector<pll> D=factorG(p-1);\n        rep(i,0,SZ(D)-1) if (powmod(a,(p-1)/D[i].X,p)==1) return 0;\n        return 1;\n    }\n    vector<int> pows(ll n) {\n        vector<pll> w = factorG(n);\n        vector<int> ret;\n        ret.clear();\n        for (vector<pll>::iterator it = w.begin(); it != w.end(); it++)\n            ret.push_back(it->second);\n        return ret;\n    }\n}\n\n\nconst int N=111,M=111111;\nint l,m,n,t,C;\nint a[N];\nint dp[N][N];\nint calc(int x){\n    if(x%2==0)return 2;\n    if(Factor::miller(x))return 1;\n    return 3;\n}\nint main(){\n#ifdef LOCAL\n\tfreopen(\"F.in\",\"r\",stdin);//freopen(\"F.out\",\"w\",stdout);\n#endif\n\tFactor::init(1000000);\n    scanf(\"%d\",&n);rep(i,1,n)scanf(\"%d\",&a[i]);\n    rep(l,1,n)rep(i,1,n-l+1){\n        int j=l+i-1;\n        dp[i][j]=inf;\n        rep(k,i,j-1)MIN(dp[i][j],dp[i][k]+dp[k+1][j]);\n        int I=i,J=j;\n        while(a[I+1]==a[I]+1)++I;\n        while(a[J-1]==a[J]-1)--J;\n        if(I>=j)MIN(dp[i][j],calc(a[j]-a[i]+1));\n        else MIN(dp[i][j],calc(a[j]-a[i]+1)+calc(a[J]-a[I]-1)+dp[I+1][J-1]);\n        //printf(\"%d %d %d\\n\",i,j,dp[i][j]);\n    }\n    printf(\"%d\\n\",dp[1][n]);\n\treturn 0;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <chrono>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstring>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <iomanip>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n#include <cstdint>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\n#define MP make_pair\n#define PB push_back\n#define inf 1000000007\n#define rep(i,n) for(int i = 0; i < (int)(n); ++i)\n#define all(x) (x).begin(),(x).end()\n\ntemplate<typename A, size_t N, typename T>\nvoid Fill(A (&array)[N], const T &val){\n    std::fill( (T*)array, (T*)(array+N), val );\n}\n \ntemplate<class T> inline bool chmax(T &a, T b){\n    if(a<b){\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T> inline bool chmin(T &a, T b){\n    if(a>b){\n        a = b;\n        return true;\n    }\n    return false;\n}\n\n#define MAX_N 10000001\n\nvector<int> prime;\nbool is_prime[MAX_N];\n\nvoid sieve(int n){\n    for(int i=0;i<=n;i++){\n        is_prime[i] = true;\n    }\n    is_prime[0] = is_prime[1] = false;\n    for(int i=2;i<=n;i++){\n        if(is_prime[i]){\n            prime.push_back(i);\n            for(int j=2*i;j<=n;j+=i){\n                is_prime[j] = false;\n            }\n        }\n    }\n}\n\n\nint dp[201][201];\nbool p[201][201];\nvector<int>L,R;\nint m;\nint dfs(int l, int r){\n    if(p[l][r])return dp[l][r];\n    p[l][r] = 1;\n    if(l==r){\n        int s = R[l] - L[l] + 1;\n        if(is_prime[s]){\n            return dp[l][r] = 1;\n        }else if(s%2==0){\n            return dp[l][r] = 2;\n        }else{\n            return dp[l][r] = 3;\n        }\n    }\n    int s = R[r] - L[l] + 1;\n    int mi = inf;\n    if(is_prime[s]){\n        mi = 1 + dfs(l+1,r-1);\n    }else if(s%2==0){\n        mi = 2 + dfs(l+1,r-1);\n    }else{\n        mi = 3 + dfs(l+1,r-1);\n    }\n    for(int k=l;k<r;k+=2){\n        mi = min(mi,dfs(l,k) + dfs(k+2,r));\n    }\n    return dp[l][r] = mi;\n}\n\nint main(){\n    sieve(10000000);\n    is_prime[2] = 0;\n    int n;\n    cin >> n;\n    vector<int>a(n);\n    rep(i,n)cin >> a[i];\n    int l = a[0];\n    int r = a[0];\n    rep(i,n){\n        if(a[i]-r<=1){\n            r = a[i];\n        }else{\n            L.push_back(l);\n            R.push_back(r);\n            L.push_back(r+1);\n            R.push_back(a[i]-1);\n            l = a[i];\n            r = a[i];\n        }\n    }\n    L.push_back(l);\n    R.push_back(r);\n    m = L.size();\n    cout << dfs(0,m-1) << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#define _GLIBCXX_DEBUG\n\n#include<bits/stdc++.h>\nusing namespace std;\n\n#define endl '\\n'\n#define lfs cout<<fixed<<setprecision(10)\n#define ALL(a)  (a).begin(),(a).end()\n#define ALLR(a)  (a).rbegin(),(a).rend()\n#define spa << \" \" <<\n#define fi first\n#define se second\n#define MP make_pair\n#define MT make_tuple\n#define PB push_back\n#define EB emplace_back\n#define rep(i,n,m) for(ll i = (n); i < (ll)(m); i++)\n#define rrep(i,n,m) for(ll i = (ll)(m) - 1; i >= (ll)(n); i--)\nusing ll = long long;\nusing ld = long double;\nconst ll MOD1 = 1e9+7;\nconst ll MOD9 = 998244353;\nconst ll INF = 1e18;\nusing P = pair<ll, ll>;\ntemplate<typename T1, typename T2>bool chmin(T1 &a,T2 b){if(a>b){a=b;return true;}else return false;}\ntemplate<typename T1, typename T2>bool chmax(T1 &a,T2 b){if(a<b){a=b;return true;}else return false;}\nll median(ll a,ll b, ll c){return a+b+c-max({a,b,c})-min({a,b,c});}\nvoid ans1(bool x){if(x) cout<<\"Yes\"<<endl;else cout<<\"No\"<<endl;}\nvoid ans2(bool x){if(x) cout<<\"YES\"<<endl;else cout<<\"NO\"<<endl;}\nvoid ans3(bool x){if(x) cout<<\"Yay!\"<<endl;else cout<<\":(\"<<endl;}\ntemplate<typename T1,typename T2>void ans(bool x,T1 y,T2 z){if(x)cout<<y<<endl;else cout<<z<<endl;}  \ntemplate<typename T>void debug(vector<vector<T>>&v,ll h,ll w){for(ll i=0;i<h;i++){cout<<v[i][0];for(ll j=1;j<w;j++)cout spa v[i][j];cout<<endl;}};\nvoid debug(vector<string>&v,ll h,ll w){for(ll i=0;i<h;i++){for(ll j=0;j<w;j++)cout<<v[i][j];cout<<endl;}};\ntemplate<typename T>void debug(vector<T>&v,ll n){if(n!=0)cout<<v[0];for(ll i=1;i<n;i++)cout spa v[i];cout<<endl;};\ntemplate<typename T>vector<vector<T>>vec(ll x, ll y, T w){vector<vector<T>>v(x,vector<T>(y,w));return v;}\nll gcd(ll x,ll y){ll r;while(y!=0&&(r=x%y)!=0){x=y;y=r;}return y==0?x:y;}\nvector<ll>dx={1,-1,0,0,1,1,-1,-1};vector<ll>dy={0,0,1,-1,1,-1,1,-1};\ntemplate<typename T>vector<T> make_v(size_t a,T b){return vector<T>(a,b);}\ntemplate<typename... Ts>auto make_v(size_t a,Ts... ts){return vector<decltype(make_v(ts...))>(a,make_v(ts...));}\ntemplate<typename T1, typename T2>ostream &operator<<(ostream &os, const pair<T1, T2>&p){return os << p.first << \" \" << p.second;}\ntemplate<typename T>ostream &operator<<(ostream &os, const vector<T> &v){for(auto &z:v)os << z << \" \";cout<<\"|\"; return os;}\n//mt19937 mt(chrono::steady_clock::now().time_since_epoch().count());\nvector< bool > prime_table(ll n) {\n  vector< bool > prime(n + 1, true);\n  if(n >= 0) prime[0] = false;\n  if(n >= 1) prime[1] = false;\n  for(ll i = 2; i * i <= n; i++) {\n    if(!prime[i]) continue;\n    for(ll j = i + i; j <= n; j += i) {\n      prime[j] = false;\n    }\n  }\n  return prime;\n}\ntemplate< typename flow_t, typename cost_t >\nstruct PrimalDual {\n  const cost_t INF;\n\n  struct edge {\n    ll to;\n    flow_t cap;\n    cost_t cost;\n    ll rev;\n    bool isrev;\n  };\n  vector< vector< edge > > graph;\n  vector< cost_t > potential, min_cost;\n  vector< ll > prevv, preve;\n\n  PrimalDual(ll V) : graph(V), INF(numeric_limits< cost_t >::max()) {}\n\n  void add_edge(ll from, ll to, flow_t cap, cost_t cost) {\n    graph[from].emplace_back((edge) {to, cap, cost, (ll) graph[to].size(), false});\n    graph[to].emplace_back((edge) {from, 0, -cost, (ll) graph[from].size() - 1, true});\n  }\n\n  cost_t min_cost_flow(ll s, ll t, flow_t f) {\n    ll V = (ll) graph.size();\n    cost_t ret = 0;\n    using Pi = pair< cost_t, ll >;\n    priority_queue< Pi, vector< Pi >, greater< Pi > > que;\n    potential.assign(V, 0);\n    preve.assign(V, -1);\n    prevv.assign(V, -1);\n\n    while(f > 0) {\n      min_cost.assign(V, INF);\n      que.emplace(0, s);\n      min_cost[s] = 0;\n      while(!que.empty()) {\n        Pi p = que.top();\n        que.pop();\n        if(min_cost[p.second] < p.first) continue;\n        for(ll i = 0; i < graph[p.second].size(); i++) {\n          edge &e = graph[p.second][i];\n          cost_t nextCost = min_cost[p.second] + e.cost + potential[p.second] - potential[e.to];\n          if(e.cap > 0 && min_cost[e.to] > nextCost) {\n            min_cost[e.to] = nextCost;\n            prevv[e.to] = p.second, preve[e.to] = i;\n            que.emplace(min_cost[e.to], e.to);\n          }\n        }\n      }\n      if(min_cost[t] == INF) return -1;\n      for(ll v = 0; v < V; v++) potential[v] += min_cost[v];\n      flow_t addflow = f;\n      for(ll v = t; v != s; v = prevv[v]) {\n        addflow = min(addflow, graph[prevv[v]][preve[v]].cap);\n      }\n      f -= addflow;\n      ret += addflow * potential[t];\n      for(ll v = t; v != s; v = prevv[v]) {\n        edge &e = graph[prevv[v]][preve[v]];\n        e.cap -= addflow;\n        graph[v][e.rev].cap += addflow;\n      }\n    }\n    return ret;\n  }\n\n  void output() {\n    for(ll i = 0; i < graph.size(); i++) {\n      for(auto &e : graph[i]) {\n        if(e.isrev) continue;\n        auto &rev_e = graph[e.to][e.rev];\n        cout << i << \"->\" << e.to << \" (flow: \" << rev_e.cap << \"/\" << rev_e.cap + e.cap << \")\" << endl;\n      }\n    }\n  }\n  using R=vector<pair<pair<ll,ll>,pair<flow_t,cost_t>>>;\n  R restore() {\n    R ret;\n    for(ll i = 0; i < graph.size(); i++) {\n      for(auto &e : graph[i]) {\n        if(e.isrev) continue;\n        auto &rev_e = graph[e.to][e.rev];\n        ret.emplace_back(make_pair(i,e.to),make_pair(rev_e.cap,e.cost));\n      }\n    }\n    return ret;\n  }\n};\nstruct HopcroftKarp {\n  vector< vector< int > > graph;\n  vector< int > dist, match;\n  vector< bool > used, vv;\n\n  HopcroftKarp(int n, int m) : graph(n), match(m, -1), used(n) {}\n\n  void add_edge(int u, int v) {\n    graph[u].push_back(v);\n  }\n\n  void bfs() {\n    dist.assign(graph.size(), -1);\n    queue< int > que;\n    for(int i = 0; i < graph.size(); i++) {\n      if(!used[i]) {\n        que.emplace(i);\n        dist[i] = 0;\n      }\n    }\n\n    while(!que.empty()) {\n      int a = que.front();\n      que.pop();\n      for(auto &b : graph[a]) {\n        int c = match[b];\n        if(c >= 0 && dist[c] == -1) {\n          dist[c] = dist[a] + 1;\n          que.emplace(c);\n        }\n      }\n    }\n  }\n\n  bool dfs(int a) {\n    vv[a] = true;\n    for(auto &b : graph[a]) {\n      int c = match[b];\n      if(c < 0 || (!vv[c] && dist[c] == dist[a] + 1 && dfs(c))) {\n        match[b] = a;\n        used[a] = true;\n        return (true);\n      }\n    }\n    return (false);\n  }\n\n  int bipartite_matching() {\n    int ret = 0;\n    while(true) {\n      bfs();\n      vv.assign(graph.size(), false);\n      int flow = 0;\n      for(int i = 0; i < graph.size(); i++) {\n        if(!used[i] && dfs(i)) ++flow;\n      }\n      if(flow == 0) return (ret);\n      ret += flow;\n    }\n  }\n\n  void output() {\n    for(int i = 0; i < match.size(); i++) {\n      if(~match[i]) {\n        cout << match[i] << \"-\" << i << endl;\n      }\n    }\n  }\n};\nint main(){\n  cin.tie(nullptr);\n  ios_base::sync_with_stdio(false);\n  ll res=0,buf=0;\n  bool judge = true;\n  ll lim=1e7+30;\n  //ll lim=1e3;cout<<\"naosu\"<<endl;\n  auto pr=prime_table(lim);\n  /*vector<ll>p;\n  rep(i,0,lim)if(pr[i])p.PB(i);\n  ll sz=p.size();*/\n  ll n;cin>>n;\n  vector<ll>x(n);\n  rep(i,0,n)cin>>x[i];\n  vector<vector<ll>>y(2);\n  rep(i,0,n){\n    if(i==0||x[i]-1>x[i-1])y[x[i]&1].PB(x[i]);\n    if(i==n-1||x[i]+1<x[i+1])y[~x[i]&1].PB(x[i]+1);\n  }\n  pr[2]=false;\n  vector<ll>sz(2);\n  rep(i,0,2)sz[i]=y[i].size();\n  HopcroftKarp fl(sz[0],sz[1]);\n  rep(i,0,sz[0])rep(j,0,sz[1]){\n    ll dif=abs(y[0][i]-y[1][j]);\n    ll cost=0;\n    if(pr[dif])fl.add_edge(i,j);\n    //cout<<dif spa cost spa y[i] spa y[j]<<endl;\n    //fl.add_edge(i,j+sz[0],1,cost);\n  }\n  /*ll S=sz[0]+sz[1],T=sz[0]+sz[1]+1;\n  rep(i,0,sz[0]){\n    fl.add_edge(S,i,1,0);\n    fl.add_edge(i+sz[0],T,1,0);\n  }*/\n  //cout<<sz<<endl;\n  //debug(y,sz);\n  ll lk=fl.bipartite_matching();\n  //assert(~lk&1);\n  ll r1=sz[0]-lk,r2=sz[1]-lk;\n  ll add=0;\n  if(r1&1)add+=3;\n  //cout<<lk spa r1 spa r2<<endl;\n  cout<<lk+r1/2*2+r2/2*2+add<<endl;\n  //map<P,ll>mp;\n  /*auto r=fl.restore();\n  for(auto z:r){\n    if(z.se.fi==1&&z.fi.fi<sz[0]&&z.fi.se<2*sz[0]){\n      cout<<y[0][z.fi.fi] spa y[1][z.fi.se-sz[0]]<<endl;\n      //assert(y[z.fi.fi]!=y[z.fi.se-sz]);\n      //mp[minmax(y[z.fi.fi],y[z.fi.se-sz])]++;\n    }\n  }*/\n  //for(auto z:mp)assert(~z.se&1);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<iostream>\n#include<queue>\n#include<cmath>\nusing namespace std;\nvoid read(int &x){\n\tchar ch;bool ok;\n\tfor(ok=0,ch=getchar();!isdigit(ch);ch=getchar())if(ch=='-')ok=1;\n\tfor(x=0;isdigit(ch);x=x*10+ch-'0',ch=getchar());if(ok)x=-x;\n}\n#define rg register\nconst int maxn=110;\nint n,a[maxn],f[maxn][maxn],g[maxn][maxn];\nbool check(int x){\n\tint n=sqrt(x);\n\tfor(rg int i=2;i<=n;i++)\n\t\tif(!(x%i))return 0;\n\treturn 1;\n}\nint get(int x){\n\tif(!x)return 0;\n\tif(x==1||x==2)return 2;\n\tif(check(x))return 1;\n\tif(check(x-2))return 3;\n\treturn 2;\n}\nint main(){\n\tread(n);memset(f,63,sizeof f);\n\tfor(rg int i=1;i<=n;i++)read(a[i]),f[i][i]=g[i][i]=3;\n\tfor(rg int l=1;l<=n;l++)\n\t\tfor(rg int r=l+1;r<=n;r++){\n\t\t\tg[l][r]=get(a[r]-a[l]+1);\n\t\t\tfor(rg int k=l;k<r;k++)\n\t\t\t\tg[l][r]+=get(a[k+1]-a[k]-1);\n\t\t}\n\tfor(rg int len=2;len<=n;len++){\n\t\tfor(rg int l=1;l+len-1<=n;l++){\n\t\t\tint r=l+len-1;\n\t\t\tfor(rg int k=l;k<r;k++)\n\t\t\t\tf[l][r]=min(f[l][k]+min(f[k+1][r],g[k+1][r]),f[l][r]);\n\t\t\tf[l][r]=min(g[l][r],f[l][r]);\n\t\t}\n\t}\n\tprintf(\"%d\\n\",f[1][n]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<cstring>\n#include<map>\n#include<queue>\n#include<cmath>\nusing namespace std;\ntypedef long long ll;\nconst int N=1005,INF=~0u>>2;\nstruct Edge{int nxt,to;}edge[(N*N)<<3];\nint a[N],b[N<<1],n,head[N<<1],num_edge,vis[N<<1],lk[N<<1],even[N<<1],odd[N<<1],even_num,odd_num,ans,k,tot,tim;\nint read(){\n\tint x=0,f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-') f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn f*x;\n}\nvoid add_edge(int from,int to){\n\tedge[++num_edge].nxt=head[from];\n\tedge[num_edge].to=to;\n\thead[from]=num_edge;\n}\nbool find(int x){\n\tfor(int i=head[x];i;i=edge[i].nxt){\n\t\tif(vis[edge[i].to]!=tim){\n\t\t\tvis[edge[i].to]=tim;\n\t\t\tif(!lk[edge[i].to]||find(edge[i].to)){\n\t\t\t\tlk[edge[i].to]=x;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nbool check(int x){\n\tif(x==1) return 0;\n\tfor(int i=2;i*i<=x;++i){\n\t\tif(x%i==0) return 0;\n\t}\n\treturn 1;\n}\nint main(){\n//\tfreopen(\"ex.in\",\"r\",stdin);\n\tn=read();\n\tfor(int i=1;i<=n;++i) b[i]=read();b[0]=-1;\n\tfor(int i=1;i<=n;++i){\n\t\tif(b[i]!=b[i-1]+1){\n\t\t\tif(b[i]%2) odd[++odd_num]=b[i];\n\t\t\telse even[++even_num]=b[i];\n\t\t}\n\t\tif(b[i]+1!=b[i+1]){\n\t\t\tif((b[i]+1)%2) odd[++odd_num]=b[i]+1;\n\t\t\telse even[++even_num]=b[i]+1;\n\t\t}\n\t}\n\tfor(int i=1;i<=odd_num;++i){\n\t\tfor(int j=1;j<=even_num;++j){\n\t\t\tif(check(abs(even[j]-odd[i]))) add_edge(i,j+odd_num),add_edge(j+odd_num,i);\n\t\t}\n\t}\n\tfor(int i=1;i<=odd_num;++i){\n\t\ttim++;\n\t\tif(find(i)) k++;\n\t\telse break;\n\t}\n\tans=k+((even_num-k)/2+(odd_num-k)/2)*2+((even_num-k)%2)*3;\n\tprintf(\"%d\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <bits/stdc++.h>\nusing namespace std;\n// #define int long long\n// #define double long double\n#define rep(i,n) for (int i=0; i<(int)(n); ++i)\n#define rep1(i,n) for (int i=1; i<(int)(n); ++i)\n#define repeq(i,n) for (int i=0; i<=(int)(n); ++i)\n#define rep1eq(i,n) for (int i=1; i<=(int)(n); ++i)\n#define rrep(i,n) for (int i=(int)(n)-1; i>=0; --i)\n#define rrep1(i,n) for (int i=(int)(n)-1; i>0; --i)\n#define rrepeq(i,n) for (int i=(int)(n); i>=0; --i)\n#define rrep1eq(i,n) for (int i=(int)(n); i>0; --i)\n#define REP(i,a,b) for (int i=(int)(a); i<=(int)(b); ++i)\n#define RREP(i,a,b) for (int i=(int)(a); i>=(int)(b); --i)\n#define ALL(a) (a).begin(), (a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\nusing ll = long long;\nusing vi = vector<int>;\nusing vl = vector<ll>;\nusing vb = vector<bool>;\ntemplate<typename T> using Graph = vector<vector<T>>;\ntemplate<typename T> using Spacial = vector<vector<vector<T>>>;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\ntemplate<typename T> using greater_priority_queue = priority_queue<T, vector<T>, greater<T>>;\nconst int MOD = 1e9+7;\nconst int MOD2 = 998244353;\n// const double EPS = 1e-9;\nconst int dx[4] = {1, 0, -1, 0};\nconst int dy[4] = {0, 1, 0, -1};\nstring interval[2] = {\" \", \"\\n\"}; // {\" \", \"\\n\"}\n\ntemplate<typename T> struct is_plural : false_type{};\ntemplate<typename T1, typename T2> struct is_plural<pair<T1, T2>> : true_type{};\ntemplate<typename T> struct is_plural<vector<T>> : true_type{};\ntemplate<typename T> struct is_plural<complex<T>> : true_type{};\n \ntemplate<typename T1, typename T2> istream &operator>>(istream &is, pair<T1, T2> &p) { return is >> p.first >> p.second; }\ntemplate<typename T1, typename T2> ostream &operator<<(ostream &os, const pair<T1, T2> &p) { return os << p.first << \" \" << p.second; }\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &vec) { for (auto itr = vec.begin(); itr != vec.end(); ++itr) is >> *itr; return is; }\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &vec) { if (vec.empty()) return os; bool pl = is_plural<T>(); os << vec.front(); for (auto itr = ++vec.begin(); itr != vec.end(); ++itr) os << interval[pl] << *itr; return os; }\n \nbool CoutYN(bool a, string y = \"Yes\", string n = \"No\") { cout << (a ? y : n) << \"\\n\"; return a; }\n\ntemplate<typename T1, typename T2> inline bool chmax(T1 &a, T2 b) { return a < b && (a = b, true); }\ntemplate<typename T1, typename T2> inline bool chmin(T1 &a, T2 b) { return a > b && (a = b, true); }\n\nlong long modpow(int a, long long n, int mod = MOD) { long long ret = 1; do { if (n & 1) ret = ret * a % mod; a = 1LL * a * a % mod; } while (n >>= 1); return ret; }\n\ntemplate<typename T> T GCD(T a, T b) { return b ? GCD(b, a%b) : a; }\ntemplate<typename T> T LCM(T a, T b) { return a / GCD(a, b) * b; }\n\ntemplate<typename T1, typename T2> bool CompareBySecond(pair<T1, T2> a, pair<T1, T2> b) { return a.second != b.second ? a.second < b.second : a.first < b.first; }\ntemplate<typename T1, typename T2> bool CompareByInverse(pair<T1, T2> a, pair<T1, T2> b) { return a.first != b.first ? a.first < b.first : a.second > b.second; }\n\n\n/* -------- <templates end> -------- */\n\n\ntemplate<typename flow_t>\nstruct FordFulkerson {\n  struct edge {\n    int to;\n    flow_t cap;\n    int rev;\n    bool isrev;\n    int idx;\n  };\n\n  vector<vector<edge>> graph;\n  vector<int> used;\n  const flow_t INF;\n  int timestamp;\n\n  FordFulkerson(int n) : INF(numeric_limits<flow_t>::max()), timestamp(0) {\n    graph.resize(n);\n    used.assign(n, -1);\n  }\n\n  void add_edge(int from, int to, flow_t cap, bool undirected = false, int idx = -1) {\n    graph[from].emplace_back((edge) {to, cap, (int) graph[to].size(), false, idx});\n    graph[to].emplace_back((edge) {from, undirected ? cap : 0, (int) graph[from].size() - 1, true, idx});\n  }\n\n  flow_t dfs(int idx, const int t, flow_t flow) {\n    if (idx == t) return flow;\n    used[idx] = timestamp;\n    for (auto &e : graph[idx]) {\n      if (e.cap > 0 && used[e.to] != timestamp) {\n        flow_t d = dfs(e.to, t, min(flow, e.cap));\n        if (d > 0) {\n          e.cap -= d;\n          graph[e.to][e.rev].cap += d;\n          return d;\n        }\n      }\n    }\n    return 0;\n  }\n\n  flow_t max_flow(int s, int t) {\n    flow_t flow = 0;\n    for (flow_t f; (f = dfs(s, t, INF)) > 0; ++timestamp) {\n      flow += f;\n    }\n    return flow;\n  }\n};\n\nvi prime;\n\nbool is_prime(int n) {\n  if (n == 1 || !(n & 1)) return false;\n  for (int &p : prime) {\n    if (p * p > n) break;\n    if (n % p == 0) return false;\n  }\n  return true;\n}\n\nvoid solve() {\n  int n; cin >> n;\n  vi arr(n); cin >> arr;\n\n  vi sec = {arr[0], arr[0] + 1};\n  rep1(i,n) {\n    if (sec.back() == arr[i]) {\n      ++sec.back();\n    } else {\n      sec.emplace_back(arr[i]);\n      sec.emplace_back(arr[i] + 1);\n    }\n  }\n\n  vb seen(3200, false);\n  for (int i=3; i<3200; i+=2) {\n    if (!seen[i]) {\n      prime.emplace_back(i);\n      for (int j=i*i; j<3200; j+=i*2) {\n        seen[j] = true;\n      }\n    }\n  }\n\n  int sz = sec.size();\n\n  FordFulkerson<int> g(sz+2);\n  int odd = 0;\n\n  rep(j,sz) {\n    bool is_odd = sec[j] & 1;\n    if (is_odd) {\n      g.add_edge(sz, j, 1);\n      ++odd;\n    } else {\n      g.add_edge(j, sz+1, 1);\n    }\n    rep(i,j) {\n      if (is_prime(sec[j] - sec[i])) {\n        if (is_odd) g.add_edge(j, i, 1);\n        else g.add_edge(i, j, 1);\n      }\n    }\n  }\n\n  int sum = g.max_flow(sz, sz+1);\n  int ans = sz - sum + ((odd - sum) & 1);\n  cout << ans << endl;\n}\n\n\n/* -------- <programs end> -------- */\n\n\nsigned main() {\n  cin.tie(nullptr);\n  ios::sync_with_stdio(false);\n  cout << fixed << setprecision(10);\n  solve();\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<set>\n#include<map>\n#include<deque>\n#include<queue>\n#include<stack>\n#include<cmath>\n#include<ctime>\n#include<bitset>\n#include<string>\n#include<vector>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<climits>\n#include<complex>\n#include<iostream>\n#include<algorithm>\n#define ll long long\nusing namespace std;\n \nconst int maxn = 1e7+10;\nconst int maxm = 210;\n \nint p[4100000],pri;\nbool v[maxn];\n \nvoid pre()\n{\n    for(int i=2;i<maxn;i++)\n    {\n        if(!v[i]) p[++pri]=i;\n        for(int j=1,k=i*p[j];j<=pri;j++,k=i*p[j])\n        {\n            if(k>=maxn) break;\n            v[k]=true;\n            if(i%p[j]==0) break;\n        }\n    }v[1]=v[2]=true;\n}\n \nint n,m;\nint a[maxm],b[maxm];\nbool s[maxn];\nint p1[maxm],p2[maxm];\nint p1n,p2n;\n \nbool mp[maxm][maxm],ev[maxm];\nint match[maxm],bel[maxm];\nbool Find(const int x)\n{\n    if(ev[x]) return false;\n    ev[x]=true;\n    for(int i=1;i<=p2n;i++) if(mp[x][i])\n    {\n        if(!bel[i]||Find(bel[i])) { bel[i]=x; return true; }\n    }\n    return false;\n}\n \nint main()\n{\n    pre();\n    scanf(\"%d\",&n);\n    for(int i=1;i<=n;i++) scanf(\"%d\",&a[i]),s[a[i]]=true;\n    for(int i=1;i<maxn;i++)\n        if(s[i]!=s[i-1]) b[++m]=i;\n \n    for(int i=1;i<=m;i++)\n    {\n        if(b[i]&1) p1[++p1n]=b[i];\n        else p2[++p2n]=b[i];\n    }\n    for(int i=1;i<=p1n;i++)\n    {\n        for(int j=1;j<=p2n;j++) if(!v[abs(p1[i]-p2[j])]) mp[i][j]=true;\n    }\n    int k=0;\n    for(int i=1;i<=p1n;i++)\n    {\n        for(int j=1;j<=p1n;j++) ev[j]=false;\n        if(Find(i)) k++;\n    }\n    p1n-=k; p2n-=k;\n    int re=k;\n    re+=p1n/2*2+p2n/2*2;\n    re+=p1n%2*3;\n     printf(\"%d\\n\",re);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cassert>\n#include <cctype>\n#include <algorithm>\nusing namespace std;\ntypedef long long lint;\n#define cout cerr\n#define ni (next_num<int>())\ntemplate<class T>inline T next_num(){\n\tT i=0;char c;\n\twhile(!isdigit(c=getchar())&&c!='-');\n\tbool flag=c=='-';\n\tflag?c=getchar():0;\n\twhile(i=i*10-'0'+c,isdigit(c=getchar()));\n\treturn flag?-i:i;\n}\ntemplate<class T1,class T2>inline void apmax(T1 &a,const T2 &b){if(a<b)a=b;}\ntemplate<class T1,class T2>inline void apmin(T1 &a,const T2 &b){if(b<a)a=b;}\ntemplate<class T>inline T cabs(const T &x){return x>=0?x:-x;}\nconst int N=210,M=10000010;\nint prime[M],ps=0;\nbool isp[M];\ninline void gmath(int n){\n\tmemset(isp,true,sizeof(isp));\n\tisp[1]=false;\n\tfor(int i=2;i<=n;i++){\n\t\tif(isp[i]){\n\t\t\tprime[ps++]=i;\n\t\t}\n\t\tfor(int j=0,cur=2;j<ps&&i*cur<=n;cur=prime[++j]){\n\t\t\tisp[i*cur]=false;\n\t\t\tif(i%cur==0)break;\n\t\t}\n\t}\n}\nint pos[N];\nint x[N],y[N];\nint lcnt=0,rcnt=0;\nbool vis[N];\nint lnk[N];\nbool dfs(int x){\n\tfor(int v=1;v<=rcnt;v++){\n\t\tif(!vis[v]&&isp[cabs(::x[x]-y[v])]){\n\t\t\tvis[v]=true;\n\t\t\tif(lnk[v]==-1||dfs(lnk[v])){\n\t\t\t\tlnk[v]=x;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\nint main(){\n\tint n=ni,xs=0,cnt=0;\n\tfor(int i=1;i<=n;i++){\n\t\tint cur=ni;\n\t\tif(cur==pos[xs]){\n\t\t\tpos[xs]++;\n\t\t}else{\n\t\t\tpos[++xs]=cur,pos[++xs]=cur+1;\n\t\t}\n\t}\n\tgmath(pos[xs]);\n\tfor(int i=1;i<=xs;i++){\n\t\tif(pos[i]&1){\n\t\t\tx[++lcnt]=pos[i];\n\t\t}else{\n\t\t\ty[++rcnt]=pos[i];\n\t\t}\n\t}\n\tmemset(lnk,-1,sizeof(lnk));\n\tfor(int i=1;i<=lcnt;i++){\n\t\tmemset(vis+1,0,rcnt);\n\t\tcnt+=dfs(i);\n\t}\n\tprintf(\"%d\\n\",xs+((lcnt^cnt)&1)-cnt);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<ctime>\n#include<cstdlib>\n#include<algorithm>\n#include<cmath>\n#include<queue>\n#include<cstring>\n#include<map>\n#include<vector>\n#include<set>\n#define rep(i,j,k) for(register int i = j; i <= k; i++) \n#define dow(i,j,k) for(register int i = j; i >= k; i--)\n#define fi first\n#define se second\n//#define P pair<ull,ull>\n//#define PP pair<int,pair<int,int> >\n//#define mp(a,b) make_pair(a,b)\n#define ll long long\n#define ull unsigned long long\nusing namespace std;\n \ninline int read() { \n\tint s = 0, t = 1; char c = getchar();\n\twhile( !isdigit(c) ) { if( c == '-' ) t = -1; c = getchar(); }\n\twhile( isdigit(c) ) s = s * 10 + c - 48, c = getchar();\n\treturn s * t;\n}\n\nconst int N = 1e7+5, M = 205; \nbool vis[N]; int p[N], v[M], f[2][M], tot = 0;\ninline void pre(int n=1e7) { \n\tint t;\n\tvis[1] = 1;\n\trep(i,2,n) { \n\t\tif( !vis[i] ) p[++tot] = i;\n\t\tfor(register int j = 1; j <= tot && (t = p[j] * i) <= n; j++) { \n\t\t\tvis[t] = 1;\n\t\t\tif( i % p[j] == 0 ) break;\n\t\t}\n\t}  \n\tvis[2] = 1;\n}\n\nint dy[M]; bool ti[M];\nstruct edge{ int to, nxt; } e[M*M];\nint head[M], cnt = 0;\ninline void add(int x,int y) { \n\te[++cnt].to = y, e[cnt].nxt = head[x], head[x] = cnt;\n}\n#define ez(i,j) for(register int i = head[j]; i; i=e[i].nxt)\n#define to e[i].to\ninline bool dfs(int x) { \n\tez(i,x) if( !ti[to] ) { \n\t\tti[to] = 1;\n\t\tif( !dy[to] || dfs(dy[to]) ) return dy[to] = x, 1;\n\t} return 0;\n} \n\nint main() {\n\tpre();\n\tint n = read(), x;\n\trep(i,1,n) v[i] = read();\n\trep(i,1,n) { \n\t\tif( i == 1 || v[i] - 1 != v[i-1] ) {\n\t\t\tx = v[i] & 1;\n\t\t\tf[x][++f[x][0]] = v[i];\n\t\t} \n\t\tif( i == n || v[i] + 1 != v[i+1] ) { \n\t\t\tx = (v[i] + 1) & 1;\n\t\t\tf[x][++f[x][0]] = v[i] + 1;\n\t\t}\n\t}\n\t\n\trep(i,1,f[0][0]) { \n\t\trep(j,1,f[1][0]) { \n\t\t\tif( !vis[abs(f[0][i]-f[1][j])] ) add(i,j);\n\t\t}\n\t}\n\tint ans = 0;\n\trep(i,1,f[0][0]) memset(ti,0,sizeof(ti)), ans += dfs(i);\n\tf[0][0] -= ans;\n\tf[1][0] -= ans;\n\t\n\tans += f[0][0] + f[1][0];\n\tf[0][0] %= 2;\n\tans += f[0][0];\n\tcout<<ans<<endl;\n\treturn 0; \n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n\n#include <iostream>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <unordered_set>\n#include <queue>\n#include <set>\n#include <algorithm>\n#include <numeric>\n#include <list>\nusing namespace std;\n\nusing QWORD  = uint64_t;\nusing SQWORD = int64_t;\nusing DWORD  = uint32_t;\nusing SDWORD = int32_t;\nusing WORD   = uint16_t;\nusing SWORD  = int16_t;\nusing BYTE   = uint8_t;\nusing SBYTE  = int8_t;\nusing DOUBLE = double;\nusing FLOAT  = float;\n\n#define MIN_SDWORD (-2147483648)\n#define MAX_SDWORD (2147483647)\n#define MIN_SBYTE (-128)\n#define MAX_SBYTE (127)\n\n#define MIN_SQWORD (0x8000000000000000)\n#define MAX_SQWORD (0x7FFFFFFFFFFFFFFF)\n\n#define MAX_QWORD  (0xFFFFFFFFFFFFFFFF)\n#define MAX_DWORD  (0xFFFFFFFF)\n#define MAX_WORD   (0xFFFF)\n#define MAX_BYTE   (0xFF)\n\n#define MAX_DOUBLE      (1.0e+308)\n#define DOUBLE_EPS      (1.0e-12)\n#define MIN_DOUBLE_N    (-1.0e+308)\n\n#define ArrayLength(a)  (sizeof(a) / sizeof(a[0]))\n\nstatic inline DOUBLE MAX(DOUBLE a, DOUBLE b) { return a > b ? a : b; }\nstatic inline QWORD MAX(QWORD a, QWORD b) { return a > b ? a : b; }\nstatic inline DWORD MAX(DWORD a, DWORD b) { return a > b ? a : b; }\nstatic inline SDWORD MAX(SDWORD a, SDWORD b) { return a > b ? a : b; }\nstatic inline DOUBLE MIN(DOUBLE a, DOUBLE b) { return a < b ? a : b; }\nstatic inline QWORD MIN(QWORD a, QWORD b) { return a < b ? a : b; }\nstatic inline DWORD MIN(DWORD a, DWORD b) { return a < b ? a : b; }\nstatic inline SDWORD MIN(SDWORD a, SDWORD b) { return a < b ? a : b; }\nstatic inline DOUBLE ABS(DOUBLE a) { return 0 < a ? a : -a; };\n\n#define BYTE_BITS   (8)\n#define WORD_BITS   (16)\n#define DWORD_BITS  (32)\n#define QWORD_BITS  (64)\n\nstatic inline void inputStringSpSeparated(char *pcStr)\n{\n    char *pcCur = pcStr;\n    for (;;) {\n        char c = getchar();\n        if (('\\n' == c) || (EOF == c) || (' ' == c)) {\n            break;\n        }\n        *pcCur = c;\n        pcCur++;\n    }\n    *pcCur = '\\0';\n}\n\nstatic inline void inputString(char *pcStr)\n{\n    char *pcCur = pcStr;\n    for (;;) {\n        char c = getchar();\n        if (('\\n' == c) || (EOF == c)) {\n            break;\n        }\n        *pcCur = c;\n        pcCur++;\n    }\n    *pcCur = '\\0';\n}\n\n\nstatic inline SQWORD inputSQWORD(void)\n{\n    SQWORD sqNumber = 0;\n    SQWORD sqMultiplier = 1;\n    bool bRead = false;\n    for (;;) {\n        char c = getchar();\n        if (!bRead) {\n            if ('-' == c) {\n                sqMultiplier = -1;\n            }\n        }\n        if (('0' <= c) && (c <= '9')) {\n            sqNumber *= 10LL;\n            sqNumber += (SQWORD)(c - '0');\n            bRead = true;\n        } else {\n            if (bRead) {\n                return sqNumber * sqMultiplier;\n            }\n        }\n    }\n}\n\n\nstatic inline SDWORD inputSDWORD(void)\n{\n    SDWORD lNumber = 0;\n    SDWORD lMultiplier = 1;\n    bool bRead = false;\n    for (;;) {\n        char c = getchar();\n        if (!bRead) {\n            if ('-' == c) {\n                lMultiplier = -1;\n            }\n        }\n        if (('0' <= c) && (c <= '9')) {\n            lNumber *= 10;\n            lNumber += (c - '0');\n            bRead = true;\n        } else {\n            if (bRead) {\n                return lNumber * lMultiplier;\n            }\n        }\n    }\n}\n\nstatic inline DOUBLE inputFP(void)\n{\n    DOUBLE dInt = 0.0;\n    DOUBLE dFrac = 0.0;\n    DOUBLE dMultiplier = 1.0;\n    DWORD dwFpCnt = 0;\n    DOUBLE *pdCur = &dInt;\n    bool bRead = false;\n    for (;;) {\n        char c = getchar();\n        if (!bRead) {\n            if ('-' == c) {\n                dMultiplier = -1;\n            }\n        }\n        if ('.' == c) {\n            pdCur = &dFrac;\n        } else if (('0' <= c) && (c <= '9')) {\n            (*pdCur) *= 10;\n            (*pdCur) += (DOUBLE)(c - '0');\n            bRead = true;\n            if (pdCur == &dFrac) {\n                dwFpCnt++;\n            }\n        } else {\n            if (bRead) {\n                return dMultiplier * (dInt + dFrac / (pow((DOUBLE)10.0 , (DOUBLE)dwFpCnt)));\n            }\n        }\n    }\n}\n\n\n/**\n *  mod による操作ライブラリ\n */\n\n#define ANS_MOD (1000000007LL)\n \nstatic SQWORD addMod(SQWORD x, SQWORD y)\n{ \n    return (x + y) % ANS_MOD;\n}\n \nstatic SQWORD subMod(SQWORD x, SQWORD y)\n{\n    return (x - y + ANS_MOD) % ANS_MOD;\n}\n \nstatic SQWORD mulMod(SQWORD x, SQWORD y) \n{\n    return (x * y) % ANS_MOD;\n}\n \nstatic SQWORD powMod(SQWORD x, SQWORD e) {\n    SQWORD v = 1;\n    for (; e; x = mulMod(x, x), e >>= 1) {\n        if (e & 1) {\n            v = mulMod(v, x);\n        }\n    }\n    return v;\n}\n \nstatic SQWORD divMod(SQWORD x, SQWORD y)\n{\n    return mulMod(x, powMod(y, ANS_MOD - 2));\n}\n \n \nstatic SQWORD combMod(SQWORD n, SQWORD k)\n{\n    SQWORD v=1;\n    for(SQWORD i=1; i<=k; i++) {\n        v = divMod(mulMod(v, n-i+1),i);\n    } \n    return v;\n}\n\n/*----------------------------------------------*/\n\n#define MAX_V   (500)\n#define INF 2e9\n\n/* 辺を表す構造体 */\nstruct edge {int to, cap ,rev; };\n \n/* グラフの隣接リスト表現 */\nvector<edge> G[MAX_V];\n/* DFSですべに調べたかのグラフ */\nbool used[MAX_V];\n \n/* fromからtoへ向かう容量capの辺をグラフに追加する */\n/* 相互参照できるようにしている */\nvoid add_edge(int from, int to, int cap){\n    G[from].push_back((edge){to, cap, (int)G[to].size()});\n    G[to].push_back((edge){from, 0, (int)G[from].size() - 1});    \n}\n \n/* 増加パスをdfsで探す */\nint dfs(int v, int t, int f){\n    if(v==t) return f;\n    used[v] = true;\n    for(int i=0; i<G[v].size(); i++){\n        edge &e = G[v][i];\n        if(!used[e.to] && e.cap>0){\n            int d = dfs(e.to, t, min(f, e.cap));\n            if(d>0){\n                e.cap -= d;\n                G[e.to][e.rev].cap += d;\n                return d;\n            }\n        }\n    }\n    return 0;\n}\n \nint max_flow(int s, int t){\n    int flow = 0;\n    for(;;){\n        memset(used, 0, sizeof(used));\n        int f = dfs(s, t, INF);\n        if(f==0) return flow;\n        flow += f;\n    }\n}\n/*----------------------------------------------*/\n\nclass PrimeTable {\n    vector<bool> vbIsPrime;\n\npublic:\n    PrimeTable(SDWORD lMax) {\n        /* lSearchMax と ループ内の *2 の関係から、入力は3以上とすること */\n        if (!(1 <= lMax)) {\n            printf(\"Oops!\");\n            return;\n        }\n\n        /* 素数のリストを作る */\n        vbIsPrime.resize(lMax + 1, true);\n        SDWORD lSearchMax = sqrt(lMax) + 1;\n        vbIsPrime[0] = false;\n        vbIsPrime[1] = false;\n        for (SDWORD lPrime = 2; lPrime < lSearchMax; lPrime++) {\n            if (vbIsPrime[lPrime]) {\n                for (SDWORD lCurNum = lPrime * 2; lCurNum <= lMax; lCurNum += lPrime) {\n                    vbIsPrime[lCurNum] = false;\n                }\n            }\n        }\n    };\n\n    bool IsPrime(SQWORD sqN)\n    {\n        return vbIsPrime[sqN];\n    }\n};\n\n\n/*----------------------------------------------*/\n\n#define PNT_NO_START    (0)\n#define PNT_NO_OFFSET   (200)\n#define PNT_NO_TARGET   (401)\n#define FLOW_OFFSET     (1000000000)\n#define CAPACITY_INF    (1000000001)\n#define DUMMY_COST      (1)\n\nint main(void)\n{\n    SQWORD sqN = inputSQWORD();\n\n    vector<SQWORD> vsqA;\n    vector<SQWORD> vsqB;\n\n    PrimeTable prime(1e7 + 1);\n \n    map<SQWORD, SQWORD> mapB;\n\n    for (SQWORD sqIdx = 0; sqIdx < sqN; sqIdx++) {\n        SQWORD sqA = inputSQWORD();\n        vsqA.emplace_back(sqA);\n\n        mapB[sqA] ^= 1;\n        mapB[sqA + 1] ^= 1;\n    }\n\n    vector<SQWORD> vsqBEven, vsqBOdd;\n\n    for (auto b: mapB) {\n        if (0 < b.second) {\n            if (0 == (b.first % 2)) {\n                vsqBEven.emplace_back(b.first);\n            } else {\n                vsqBOdd.emplace_back(b.first);\n            }\n        }\n    }\n\n    SQWORD sqNodeEven = 0;\n    for (auto e: vsqBEven) {\n        SQWORD sqNodeOdd = 0;\n        for (auto o: vsqBOdd) {\n            if (prime.IsPrime(abs(e - o))) {\n                add_edge(sqNodeOdd, sqNodeOdd + PNT_NO_OFFSET, 1);\n            }\n            sqNodeOdd++;\n        }\n        sqNodeEven++;\n    }\n    for (SQWORD sqIdx = 1; sqIdx <= vsqBEven.size(); sqIdx++) {\n        add_edge(PNT_NO_START, sqIdx, 1);\n    }\n    for (SQWORD sqIdx = 1; sqIdx <= vsqBOdd.size(); sqIdx++) {\n        add_edge(sqIdx + PNT_NO_OFFSET, PNT_NO_TARGET, 1);\n    }\n\n\n\n    SQWORD sqMaxFlow = max_flow(PNT_NO_START, PNT_NO_TARGET);\n    SQWORD vsqCRestEven = vsqBEven.size() - sqMaxFlow;\n    SQWORD vsqCRestOdd  = vsqBOdd.size() - sqMaxFlow;\n\n    SQWORD sqAns = sqMaxFlow;    \n    sqAns += ((vsqCRestEven / 2) * 2);\n    sqAns += ((vsqCRestOdd / 2) * 2);\n    if (0 < (vsqCRestEven %  2)) {\n        sqAns += 3;\n    }\n\n    printf(\"%lld\\n\", sqAns);\n\n    return 0;\n}\n/*------------------------------------------*/\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\nstruct edge { int to, cap, rev; };\n\nvector<edge> G[210];\nint level[210];\nint iter[210];\nint INF = 10000000;\n\nvoid add_edge(int from, int to, int cap) {\n\tG[from].push_back({ to, cap, (int)G[to].size() });\n\tG[to].push_back({ from, cap, (int)G[from].size() - 1 });\n}\n\nvoid add_multi_edge(int v1, int v2, int cap) {\n\tG[v1].push_back({ v2, cap, (int)G[v2].size() });\n\tG[v2].push_back({ v1, cap, (int)G[v1].size() - 1 });\n}\n\nvoid BFS(int S) {\n\tmemset(level, -1, sizeof(level));\n\tqueue<int> Q;\n\tlevel[S] = 0;\n\tQ.push(S);\n\twhile (!Q.empty()) {\n\t\tint V = Q.front(); Q.pop();\n\t\tfor (edge E : G[V]) {\n\t\t\tif (E.cap > 0 && level[E.to] < 0) {\n\t\t\t\tlevel[E.to] = level[V] + 1;\n\t\t\t\tQ.push(E.to);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint DFS(int V, int T, int F) {\n\tif (V == T) return F;\n\tfor (int& i = iter[V]; i < G[V].size(); i++) {\n\t\tedge& E = G[V][i];\n\t\tif (E.cap > 0 && level[V] < level[E.to]) {\n\t\t\tint D = DFS(E.to, T, min(F, E.cap));\n\t\t\tif (D > 0) {\n\t\t\t\tE.cap -= D;\n\t\t\t\tG[E.to][E.rev].cap += D;\n\t\t\t\treturn D;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint max_flow(int S, int T) {\n\tint flow = 0;\n\twhile (1) {\n\t\tBFS(S);\n\t\tif (level[T] < 0) return flow;\n\t\tmemset(iter, 0, sizeof(iter));\n\t\tint F;\n\t\twhile ((F = DFS(S, T, INF)) > 0) {\n\t\t\tflow += F;\n\t\t}\n\t}\n}\n\nbool isPrime(long long X) {\n\tif (X <= 1) return false;\n\tfor (long long i = 2; i * i <= X; i++) if (X % i == 0) return false;\n\treturn true;\n}\n\nint main() {\n\tlong long N, X[100];\n\tmap<long long, bool> mp;\n\tcin >> N;\n\tfor (int i = 0; i < N; i++) cin >> X[i], mp[X[i]] = true;\n\tvector<long long> V;\n\tfor (int i = 0; i < N; i++) {\n\t\tif (!mp[X[i] - 1]) V.push_back(X[i]);\n\t\tif (!mp[X[i] + 1]) V.push_back(X[i] + 1);\n\t}\n\tlong long Even = 0, Odd = 0;\n\tfor (int i = 0; i < V.size(); i++) {\n\t\tif (V[i] % 2 == 0) add_edge(201, i, 1), Even++;\n\t\telse add_edge(i, 202, 1), Odd++;\n\t}\n\tfor (int i = 0; i < V.size(); i++) {\n\t\tif (V[i] % 2 == 1) continue;\n\t\tfor (int j = 0; j < V.size(); j++) {\n\t\t\tif (V[j] % 2 == 0) continue;\n\t\t\tif (isPrime(abs(V[i] - V[j]))) add_edge(i, j, 1);\n\t\t}\n\t}\n\tlong long MAX = max_flow(201, 202);\n\tcout << MAX + ((Even - MAX) / 2 + (Odd - MAX) / 2) * 2 + ((Even - MAX) % 2) * 3 << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 10000001;\n\n\nint n,fre[maxn],p[220],ispr[maxn],even,odd,wrong;\nvector <int> edge[220],v2;\n\nbool fin(int u) {\n    if (fre[u]==wrong) return false;\n    fre[u]=wrong;\n    for (int j=0;j<edge[u].size();j++) {\n        int v=edge[u][j];\n       // cout<<u<<\" \"<<v<<endl;\n        if (p[v]==0 || fin(p[v])) {\n            p[v]=u;\n            p[u]=v;\n            return true;\n        }\n    }\n    return false;\n}\n\nint main() {\n  //  freopen(\"in.txt\",\"r\",stdin);\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    ispr[1]=1;\n    for (int i=2;i<maxn;i++)\n        if (ispr[i]==0) {\n            for (int j=i+i;j<maxn;j+=i) ispr[j]=1;\n        }\n    cin>>n;\n    for (int i=1;i<=n;i++) {\n        int x;\n        cin>>x;\n        fre[x]^=1;\n        fre[x+1]^=1;\n    }\n    even=0; odd=0; wrong=2;\n    for (int i=0;i<maxn;i++)\n        if (fre[i]==1) {\n            v2.push_back(i);\n            if (i%2==0) even++;\n            else odd++;\n        }\n    // for (int i=0;i<v2.size();i++) cout<<v2[i]<<\" \";\n   //  cout<<endl;\n   // cout<<\" \" <<even<<\" \"<<odd<<endl;\n    for (int i=0;i<v2.size();i++)\n        for (int j=0;j<v2.size();j++)\n            if (v2[i]%2==0 && v2[j]%2==1 && ispr[ abs(v2[j] - v2[i]) ]==0) {\n                edge[i+1].push_back(j+1);\n                edge[j+1].push_back(i+1);\n            }\n    int cnt=0;\n    for (int i=0;i<v2.size();i++)\n     if (p[i+1]==0) {\n        wrong++;\n        p[i+1]=i+1;\n        //cout<<fin(i+1)<<endl;\n        cnt+=(fin(i+1));\n       // cout<<p[i+1]<<endl;\n      //  cout<<\"fuck\"<<endl;\n    }\n    cout<< cnt + ((even-cnt)/2 + (odd-cnt)/2) * 2 + (even%2)*3;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <algorithm>\n#include <memory.h>\n#include <queue>\n\nusing namespace std;\ntypedef long long LL;\nconst int maxn = 10000005;\nconst int maxm = 505;\n\nint prm[maxn/10],tot;bool is[maxn];\nint n,x[maxm],a[maxm],m,e[maxm][maxm];\nint match[maxm],vis[maxm],ans,odd,even;\nvoid predo(int n) {\n\tis[0]=is[1]=1;\n\tfor (int i=2;i<=n;i++)\n\t{\n\t\tif (!is[i]) prm[++tot]=i;\n\t\tfor (int j=1;j<=tot;j++)\n\t\t{\n\t\t\tint num=prm[j]*i;\n\t\t\tif (num>n) break;\n\t\t\tif (i%prm[j]) is[num]=1;\n\t\t\telse {is[num]=1;break;}\n\t\t}\n\t}\n}\nbool Hungray(int u) {\n\tfor (int v=1;v<=m;v++)\n\tif (e[u][v]&&!vis[v]) {\n\t\tvis[v]=true;\n\t\tif (!match[v]||Hungray(match[v])) {\n\t\t\tmatch[v]=u;return true;\n\t\t}\n\t}\n\treturn false;\n}\nint main()\n{\n\t#ifdef Amberframe\n\t\tfreopen(\"arc080f.in\",\"r\",stdin);\n\t\tfreopen(\"arc080f.out\",\"w\",stdout);\n\t#endif\n\tpredo(1e7);scanf(\"%d\",&n);x[0]=-1;\n\tfor (int i=1;i<=n;i++) scanf(\"%d\",&x[i]);\n\tfor (int i=1;i<=n;i++) x[i]!=x[i-1]+1?a[++m]=x[i]:0;\n\tfor (int i=1;i<=n;i++) x[i]!=x[i+1]-1?a[++m]=x[i]+1:0;\n\tsort(a+1,a+m+1);is[2]=1;\n\tfor (int i=1;i<=m;i++)\n\tfor (int j=i+1;j<=m;j++)\n\t\tif (!is[a[j]-a[i]]) e[i][j]=e[j][i]=1;\n\tfor (int i=1;i<=m;i++)\n\tif (a[i]&1) {\n\t\t++odd;memset(vis,0,sizeof vis);\n\t\tif (Hungray(i)) ++ans;\n\t}\n\telse ++even;\n\todd-=ans;even-=ans;\n\tans+=2*(odd/2+even/2)+(odd&1)*3;\n\tprintf(\"%d\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstruct hopcroft{\n\tvector<int> dist, pair_l, pair_r;\n\tvector<bool> seen;\n\tvector<vector<int>> to;\n\tint n1, n2;\n\thopcroft(int n1, int n2) : n1(n1), n2(n2){\n\t\tto.resize(n1);\n\t\tpair_l.assign(n1, -1);\n\t\tpair_r.assign(n2, -1);\n\t\tdist.resize(n1);\n\t\tseen.resize(n1);\n\t}\n\tvoid add_edge(int u, int v){\n\t\tto[u].push_back(v);\n\t}\n\tbool bfs(){\n\t\tfill(dist.begin(), dist.end(), -1);\n\t\tqueue<int> q;\n\t\tfor (int i = 0; i < n1; i++){\n\t\t\tif (pair_l[i] == -1){\n\t\t\t\tdist[i] = 0;\n\t\t\t\tq.push(i);\n\t\t\t}\n\t\t}\n\t\tbool reach_minus = false;\n\t\twhile (!q.empty()){\n\t\t\tint u = q.front();\n\t\t\tq.pop();\n\t\t\tfor (int adj : to[u]){\n\t\t\t\tint radj = pair_r[adj];\n\t\t\t\tif (radj == -1){\n\t\t\t\t\treach_minus = true;\n\t\t\t\t} else if (dist[radj] == -1){\n\t\t\t\t\tdist[radj] = dist[u] + 1;\n\t\t\t\t\tq.push(radj);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn reach_minus;\n\t}\n\tbool dfs(int u){\n\t\tseen[u] = true;\n\t\tfor (int adj : to[u]){\n\t\t\tint radj = pair_r[adj];\n\t\t\tif (radj == -1 || (!seen[radj] && dist[radj] == dist[u] + 1 && dfs(radj))){\n\t\t\t\tpair_l[u] = adj;\n\t\t\t\tpair_r[adj] = u;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\tint max_matching(){\n\t\tint res = 0;\n\t\twhile (bfs()){\n\t\t\tfill(seen.begin(), seen.end(), false);\n\t\t\tfor (int i = 0; i < n1; i++)\n\t\t\t\tif (pair_l[i] == -1 && dfs(i))\n\t\t\t\t\tres++;\n\t\t}\n\t\treturn res;\n\t}\n};\nconst int lim = 10000002;\nbool prime[lim];\nvoid init(){\n\tmemset(prime, true, sizeof(prime));\n\tprime[0] = prime[1] = false;\n\tfor(int i = 2; i < lim; i++){\n\t\tif(prime[i]){\n\t\t\tfor(int j = i + i; j < lim; j += i)\n\t\t\t\tprime[j] = false;\n\t\t}\t\n\t}\n}\nint main(){\n\tinit();\n\tint n; cin >> n;\n\tbitset<lim> b;\n\tfor(int i = 0; i < n; i++){\n\t\tint x; cin >> x;\n\t\tb[x] = 1;\n\t}\n\tvector<int> p[2];\n\tfor(int i = 1; i < lim; i++){\n\t\tif(b[i] != b[i - 1]){\n\t\t\tp[i%2].push_back(i);\n\t\t}\n\t}\n\tint l0 = p[0].size(), l1 = p[1].size();\n\thopcroft ho(l0, l1);\n\tassert((l0 + l1) % 2 == 0);\n\tfor(int i = 0; i < l0; i++){\n\t\tfor(int j = 0; j < l1; j++){\n\t\t\tif(prime[abs(p[0][i] - p[1][j])]){\n\t\t\t\tho.add_edge(i, j);\n\t\t\t}\n\t\t}\n\t}\n\tint fl = ho.max_matching();\n\tint ans = fl + ((l0 - fl) / 2) * 2 + ((l1 - fl)/2) * 2 + ((((l0 - fl) % 2) + ((l1 - fl) % 2))/2) * 3;\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \nconst int maxn = 1e7 + 700;\n \n \nint n,fre[maxn],p[220],ispr[maxn],dd[maxn],even,odd,wrong;\nvector <int> edge[220],v2;\n \nbool fin(int u) {\n    if (fre[u]==wrong) return false;\n    fre[u]=wrong;\n    for (int j=0;j<edge[u].size();j++) {\n        int v=edge[u][j];\n       // cout<<u<<\" \"<<v<<endl;\n        if (p[v]==0 || fin(p[v])) {\n            p[v]=u;\n            return true;\n        }\n    }\n    return false;\n}\n \nint main() {\n  //  freopen(\"in.txt\",\"r\",stdin);\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    ispr[1]=1;\n    for (int i=2;i<maxn;i++)\n        if (ispr[i]==0) {\n            for (int j=i+i;j<maxn;j+=i) ispr[j]=1;\n        }\n    cin>>n;\n    for (int i=1;i<=n;i++) {\n        int x;\n        cin>>x;\n        if (dd[x]==1) continue;\n        dd[x]=1;\n        fre[x]^=1;\n        fre[x+1]^=1;\n    }\n    even=0; odd=0; wrong=2;\n    for (int i=0;i<maxn;i++)\n        if (fre[i]==1) {\n            v2.push_back(i);\n            if (i%2==0) even++;\n            else odd++;\n        }\n    // for (int i=0;i<v2.size();i++) cout<<v2[i]<<\" \";\n   //  cout<<endl;\n   // cout<<\" \" <<even<<\" \"<<odd<<endl;\n    for (int i=0;i<v2.size();i++)\n        for (int j=0;j<v2.size();j++)\n            if (v2[i]%2==0 && v2[j]%2==1 && ispr[ abs(v2[j] - v2[i]) ]==0 && abs(v2[j] - v2[i])%2==1) {\n                edge[i].push_back(j);\n                edge[j].push_back(i);\n            }\n    int cnt=0;\n    for (int i=0;i<v2.size();i++)\n     if (v2[i]%2==0) {\n        wrong++;\n        if (fin(i)) cnt++;\n    }\n    cout<< cnt + (even-cnt)/2 *2 + (odd-cnt)/2 * 2 + (even-cnt)%2*3;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=10010<<1,INF=0x3f3f3f3f;\n\ninline char nc(){\n    static char buf[100000],*p1=buf,*p2=buf;\n    return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;\n}\ninline int read(){\n    char ch=nc();int sum=0;\n    while(!(ch>='0'&&ch<='9'))ch=nc();\n    while(ch>='0'&&ch<='9')sum=sum*10+ch-48,ch=nc();\n    return sum;\n}\n\nstruct E{\n\tint f,t,capa,flow,xt;\n}e[N];\n\nint h[N],cnt;\n\ninline void adge(int f,int t,int capa){\n\te[++cnt]=(E){f,t,capa,0,h[f]};h[f]=cnt;\n\te[++cnt]=(E){t,f,0,0,h[t]};h[t]=cnt;\n}\n\nint d[N],cur[N],p[N],num[N];\n\nint ISAP(int s,int t,int n){     \t\t\t//ISAP大法好！！！！！！！ \n\tfor(int i=0;i<=n;i++) cur[i]=h[i],d[i]=INF;\n\tint flow=0;\n\tqueue<int>q;\n\tq.push(t);\n\td[t]=0;\n\twhile(!q.empty()){\n\t\tint u=q.front();q.pop();\n\t\tfor(int i=h[u];~i;i=e[i].xt){\n\t\t\tif(d[e[i].t]==INF) num[d[e[i].t]=d[u]+1]++,q.push(e[i].t);\n\t\t}\n\t}\n\tfor(int x=s;d[s]<n;){\n\t\tif(x==t){\n\t\t\tint a=INF;\n\t\t\tfor(;x!=s;x=e[p[x]].f) a=min(a,e[p[x]].capa-e[p[x]].flow);\n\t\t\tfor(x=t;x!=s;x=e[p[x]].f) e[p[x]].flow+=a,e[p[x]^1].flow-=a;\n\t\t\tflow+=a;\n\t\t}\n\t\tbool ok=0;\n\t\tfor(int i=cur[x];~i;i=e[i].xt){\n\t\t\tif(e[i].capa>e[i].flow&&d[e[i].t]==d[x]-1){\n\t\t\t\tok=1;\n\t\t\t\tcur[x]=i;\n\t\t\t\tx=e[i].t;\n\t\t\t\tp[x]=i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(!ok){\n\t\t\tint m=n-1;\n\t\t\tfor(int i=cur[x]=h[x];~i;i=e[i].xt){\n\t\t\t\tif(e[i].capa>e[i].flow) m=min(m,d[e[i].t]);\n\t\t\t}\n\t\t\tif(--num[d[x]]==0) break;\n\t\t\tnum[d[x]=m+1]++;\n\t\t\tif(x!=s) x=e[p[x]].f;\n\t\t}\n\t}\n\treturn flow;\n}\n\nint pos[110],od[110],ev[110],c1,c2;\n\nbool isp(int n){\n\tif(n==0||n==1) return 0;\n\tint m=sqrt(n);\n\tfor(int i=2;i<=m;i++)\n\t\tif(n%i==0) return 0;\n\treturn 1;\n}\n\ninline void add(int x){\n\tif(x&1) od[++c1]=x;\n\telse ev[++c2]=x;\n}\nint main(){\n\tmemset(h,cnt=-1,sizeof(h));\n\tint n;\n\tn=read();\n\tfor(int i=1;i<=n;i++){\n\t\tpos[i]=read();\n\t\tif(pos[i-1]+1!=pos[i]||i==1){\t\t\n\t\t\tif(i>1) add(pos[i-1]+1);\n\t\t\tadd(pos[i]);\n\t\t}\n\t}\n\tadd(pos[n]+1);\n\tfor(int i=1;i<=c1;i++){\n\t\tfor(int j=1;j<=c2;j++){\n\t\t\tif(isp(abs(od[i]-ev[j]))){\n\t\t\t\tadge(i,j+c1,1);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=1;i<=c1;i++) adge(0,i,1);\n\tfor(int i=1;i<=c2;i++) adge(i+c1,c1+c2+1,1);\n\tint ans=ISAP(0,c1+c2+1,c1+c2+1);\n\tint t=ans;\n\tans=ans+(c1-t)/2*2;\n\tans=ans+(c2-t)/2*2;\n\tif((c1-t)%2) ans+=3;\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \nconst int maxn = 1e7 + 700;\n \n \nint n,fre[maxn],p[220],ispr[maxn],even,odd,wrong;\nvector <int> edge[220],v2;\n \nbool fin(int u) {\n    if (fre[u]==wrong) return false;\n    fre[u]=wrong;\n    for (int j=0;j<edge[u].size();j++) {\n        int v=edge[u][j];\n       // cout<<u<<\" \"<<v<<endl;\n        if (p[v]==0 || fin(p[v])) {\n            p[v]=u;\n            p[u]=v;\n            return true;\n        }\n    }\n    return false;\n}\n \nint main() {\n  //  freopen(\"in.txt\",\"r\",stdin);\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    ispr[1]=1;\n    for (int i=2;i<maxn;i++)\n        if (ispr[i]==0) {\n            for (int j=i+i;j<maxn;j+=i) ispr[j]=1;\n        }\n    cin>>n;\n    for (int i=1;i<=n;i++) {\n        int x;\n        cin>>x;\n        fre[x]^=1;\n        fre[x+1]^=1;\n    }\n    even=0; odd=0; wrong=2;\n    for (int i=0;i<maxn;i++)\n        if (fre[i]==1) {\n            v2.push_back(i);\n            if (i%2==0) even++;\n            else odd++;\n        }\n    // for (int i=0;i<v2.size();i++) cout<<v2[i]<<\" \";\n   //  cout<<endl;\n   // cout<<\" \" <<even<<\" \"<<odd<<endl;\n    for (int i=0;i<v2.size();i++)\n        for (int j=0;j<v2.size();j++)\n            if (v2[i]%2==0 && v2[j]%2==1 && ispr[ abs(v2[j] - v2[i]) ]==0 && abs(v2[j] - v2[i])%2==1) {\n                edge[i].push_back(j);\n                edge[j].push_back(i);\n            }\n    int cnt=0;\n    for (int i=0;i<v2.size();i++)\n     if (p[i]==0) {\n        wrong++;\n        p[i]=i;\n        if (fin(i)) cnt++;\n    }\n    cout<< cnt + (even-cnt)/2 *2 + (odd-cnt)/2 * 2 + (even-cnt)%2*3;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<cstring>\nusing namespace std;\nint n;\nint res;\nvector<int>v;\nint lst=-1;\nint match[210];\nint me,mo;\nint mx;\nbool f[10000010];\nvector<int>ok[210];\nbool vis[210];\nint prm[1000010];\nint sz;\nbool bp(int x)\n{\n\tfor(int i=0;i<ok[x].size();i++)\n\t{\n\t\tint y=ok[x][i];\n\t\tif(vis[y])continue;\n\t\tvis[y]=true;\n\t\tif(match[y]==-1 || bp(match[y]))\n\t\t{\n\t\t\tmatch[y]=x;\n\t\t\tmatch[x]=y;\n\t\t\treturn true;\n\t\t}\n\t\tvis[y]=false;\n\t}\n\treturn false;\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint x;\n\t\tscanf(\"%d\",&x);\n\t\tif(x!=lst+1)\n\t\t{\n\t\t\tif(lst+1)v.push_back(lst+1);\n\t\t\tv.push_back(x);\n\t\t}\n\t\tlst=x;\n\t\tmx=lst+1;\n\t}\n\tv.push_back(lst+1);\n\tf[1]=true;\n\tfor(int i=2;i<=mx;i++)\n\t{\n\t\tif(!f[i])prm[++sz]=i;\n\t\tfor(int j=1;j<=sz;j++)\n\t\t{\n\t\t\tif(prm[j]*i>mx)break;\n\t\t\tf[prm[j]*i]=true;\n\t\t\tif(i%prm[j]==0)break;\n\t\t}\n\t}\n\tint l=v.size();\n\tfor(int i=0;i<l;i++)\n\t{\n\t\tmatch[i]=-1;\n\t\tif(v[i]&1)mo++;else me++;\n\t\tfor(int j=i+1;j<l;j++)\n\t\t{\n\t\t\tif(v[j]-v[i]!=2 && !f[v[j]-v[i]])\n\t\t\t{\n\t\t\t\tok[i].push_back(j);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<l;i++)\n\t{\n\t\tif(match[i]!=-1)continue;\n\t\tmemset(vis,false,sizeof(vis));\n\t\tif(bp(i))res++;\n\t}\n\tprintf(\"%d\",res+((me-res)/2+(mo-res)/2)*2+((me-res)%2)*3);\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<cmath>\n#define N 210\n#define M 10000010\nusing namespace std;\nint prime[M+10],link[N],tot;\nbool p[M+10],vis[N];\nint n,m;\nbool can[N][N],s[M+10];\nvector<int>v[2];\nbool check(int u)\n{\n\tfor(int i=1;i<=m;i++)\n\tif(can[u][i] && !vis[i])\n\t{\n\t\tvis[i]=1;\n\t\tif(!link[i] || check(link[i]))\n \t\t{\n\t\t\tlink[i]=u;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\nint main()\n{\n\tp[1]=true;\n\tfor(int i=2;i<=M;i++)\n\t{\n\t\tif(!p[i]) prime[++tot]=i;\n\t\tfor(int j=1;j<=tot && i*prime[j]<=M;j++)\n\t\t{\n\t\t\tp[i*prime[j]]=1;\n\t\t\tif(i%prime[j]==0) break;\n\t\t}\n\t}\n\tscanf(\"%d\",&n);\n\tfor(int i=1,u;i<=n;i++) scanf(\"%d\",&u),s[u]=true;\n\tfor(int i=1;i<=M;i++)\n\tif(s[i]^s[i-1]) v[i&1].push_back(i);\n\tn=v[0].size(),m=v[1].size();\n\tfor(int i=0;i<n;i++)\n\t\tfor(int j=0;j<m;j++)\n\t\tif(!p[abs(v[0][i]-v[1][j])]) can[i+1][j+1]=true;\n\tint ans=0;\n    for(int i=1;i<=n;i++)\n\t{\n\t\tmemset(vis,0,sizeof(vis));\n\t\tans+=check(i);\n\t}\n\tint tmp=ans;\n\tans+=(n-ans)/2*2+(m-ans)/2*2;\n\tprintf(\"%d\",ans+((n&1)!=(tmp&1)?3:0));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<algorithm>\n#include<cstdio>\n#include<cmath>\n#include<cassert>\n#define ll long long\nusing namespace std;\ninline int read(){\n\tint re=0,flag=1;char ch=getchar();\n\twhile(ch>'9'||ch<'0'){\n\t\tif(ch=='-') flag=-1;\n\t\tch=getchar();\n\t}\n\twhile(ch>='0'&&ch<='9') re=(re<<1)+(re<<3)+ch-'0',ch=getchar();\n\treturn re*flag;\n}\nint vis[10000010],pri[1000010],cntp;\nvoid init(){\n\tint i,j,k;vis[1]=1;\n\tfor(i=2;i<=10000000;i++){\n\t\tif(!vis[i]) pri[++cntp]=i;\n\t\tfor(j=1;j<=cntp;j++){\n\t\t\tk=i*pri[j];if(k>=10000000) break;\n\t\t\tvis[k]=1;\n\t\t\tif(i%pri[j]==0) break;\n\t\t}\n\t}\n}\nstruct graph{//DINIC´ó·¨ºÃ£¡ÍøÂçÁ÷Ó¦¸Ã±ÈÐÙÑÀÀû¿ì°É...... \n\tint first[1010],dep[1010],cur[1010],cnte;\n\tstruct edge{\n\t\tint to,next,w;\n\t}a[100010];\n\tgraph(){\n\t\tmemset(first,-1,sizeof(first));cnte=-1;\n\t}\n\tinline void add(int u,int v,int w){\n//\t\tcout<<\"addedge \"<<u<<' '<<v<<' '<<w<<'\\n';\n\t\ta[++cnte]=(edge){v,first[u],w};first[u]=cnte;\n\t\ta[++cnte]=(edge){u,first[v],0};first[v]=cnte;\n\t}\n\tbool bfs(int s,int t){\n\t\tint q[1010],head=0,tail=1,i,u,v;\n\t\tfor(i=s;i<=t;i++) dep[i]=-1,cur[i]=first[i];\n\t\tdep[s]=0;q[0]=s;\n\t\twhile(head<tail){\n\t\t\tu=q[head++];\n\t\t\tfor(i=first[u];~i;i=a[i].next){\n\t\t\t\tv=a[i].to;if(~dep[v]||!a[i].w) continue;\n\t\t\t\tdep[v]=dep[u]+1;q[tail++]=v;\n\t\t\t}\n\t\t}\n\t\treturn ~dep[t];\n\t}\n\tint dfs(int u,int t,int lim){\n\t\tif(u==t||!lim) return lim;\n\t\tint i,v,f,flow=0;\n\t\tfor(i=cur[u];~i;i=a[i].next){\n\t\t\tv=a[i].to;cur[u]=i;\n\t\t\tif(dep[v]=dep[u]+1&&(f=dfs(v,t,min(lim,a[i].w)))){\n\t\t\t\ta[i].w-=f;a[i^1].w+=f;\n\t\t\t\tflow+=f;lim-=f;\n\t\t\t\tif(!lim) return flow; \n\t\t\t}\n\t\t}\n\t\treturn flow;\n\t}\n\tint dinic(int s,int t){\n\t\tint re=0;\n\t\twhile(bfs(s,t)) re+=dfs(s,t,1e9);\n\t\treturn re;\n\t}\n}G;\nint n,x[110],one[210],cnt,l[210],cntl,r[210],cntr;\nint main(){\n\tinit();int i,j,match;\n\tn=read();\n\tfor(i=1;i<=n;i++) x[i]=read();\n\tfor(i=1;i<=n;i=j+1){\n\t\tj=i;\n\t\twhile((x[j+1]==x[j]+1)&&j<n) j++;\n\t\tone[++cnt]=x[i];one[++cnt]=x[j]+1;\n\t}\n\tfor(i=1;i<=cnt;i++){\n\t\tif(one[i]%2) l[++cntl]=one[i];\n\t\telse r[++cntr]=one[i];\n\t}\n\tfor(i=1;i<=cntl;i++) G.add(0,i,1);\n\tfor(i=1;i<=cntr;i++) G.add(i+cntl,cntl+cntr+1,1);\n\tfor(i=1;i<=cntl;i++){\n\t\tfor(j=1;j<=cntr;j++){\n//\t\t\tcout<<\"do \"<<i<<' '<<j<<' '<<l[i]<<' '<<r[j]<<'\\n';\n\t\t\tif(!vis[abs(l[i]-r[j])]) G.add(i,cntl+j,1);\n\t\t}\n\t}\n\tmatch=G.dinic(0,cntl+cntr+1);\n\tprintf(\"%d\\n\",match+((cntl-match)/2+(cntr-match)/2)*2+((cntl-match)%2)*3);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <iostream>\n#include <algorithm>\n#define fo(i,a,b) for(int i=a;i<=b;i++)\n#define fod(i,a,b) for(int i=a;i>=b;i--)\n#define N 2005\nusing namespace std;\nint l[N],n,a[N],r[N],w[N],pr[5000005],f[N],a1[N][N];\nbool bz[20000005],bp[N];\nvoid prp()\n{\n\tbz[1]=1;\n\tbz[0]=1;\n\tfo(i,2,20000000)\n\t{\n\t\tif(!bz[i]) pr[++pr[0]]=i;\n\t\tfor(int j=1;j<=pr[0]&&i*pr[j]<=20000000;j++)\n\t\t{\n\t\t\tbz[i*pr[j]]=1;\n\t\t\tif(i%pr[j]==0) break;\n\t\t}\n\t}\n\tbz[2]=1;\n}\nbool find(int k)\n{\n\tfo(i,1,a1[k][0])\n\t{\n\t\tint p=a1[k][i];\n\t\tif(!bp[p])\n\t\t{\n\t\t\tbp[p]=1;\n\t\t\tif(!f[p]||find(f[p])) \n\t\t\t{\n\t\t\t\tf[p]=k;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nint main()\n{\n\tcin>>n;\n\tprp();\n\tfo(i,1,n) scanf(\"%d\",&a[i]);\n\tsort(a+1,a+n+1);\n\tfo(i,1,n) \n\t{\n\t\tif(i==1||a[i-1]!=a[i]-1) w[++w[0]]=i;\n\t\tif(a[i+1]!=a[i]+1) w[++w[0]]=i+1;\n\t}\n\tsort(w+1,w+w[0]+1);\n\tfo(i,1,w[0]) \n\t\tif(w[i]%2==0) l[++l[0]]=w[i];\n\t\telse r[++r[0]]=w[i];\n\tfo(i,1,l[0])\n\t{\n\t\tfo(j,1,r[0])\n\t\t{\n\t\t\tif(!bz[abs(l[i]-r[j])]) a1[i][++a1[i][0]]=j;\n\t\t}\n\t}\n\tlong long s=0;\n\tfo(i,1,l[0]) \n\t{\n\t\tmemset(bp,0,sizeof(bp));\n\t\tif(find(i)) s++;\n\t}\n\tprintf(\"%lld\",s+2*(long long)((l[0]-s)/2)+2*(long long)((r[0]-s)/2)+3*(long long)((l[0]-s)%2));\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <math.h>\n#include <string.h>\n#include <time.h>\n#include <stdlib.h>\n#include <string>\n#include <bitset>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <algorithm>\n#include <sstream>\n#include <stack>\n#include <iomanip>\nusing namespace std;\n#define pb push_back\n#define mp make_pair\ntypedef pair<int,int> pii;\ntypedef long long ll;\ntypedef double ld;\ntypedef vector<int> vi;\n#define fi first\n#define se second\n#define fe first\n#define FO(x) {freopen(#x\".in\",\"r\",stdin);freopen(#x\".out\",\"w\",stdout);}\n#define Edg int M=0,fst[SZ],vb[SZ],nxt[SZ];void ad_de(int a,int b){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;}void adde(int a,int b){ad_de(a,b);ad_de(b,a);}\n#define Edgc int M=0,fst[SZ],vb[SZ],nxt[SZ],vc[SZ];void ad_de(int a,int b,int c){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;vc[M]=c;}void adde(int a,int b,int c){ad_de(a,b,c);ad_de(b,a,c);}\n#define es(x,e) (int e=fst[x];e;e=nxt[e])\n#define esb(x,e,b) (int e=fst[x],b=vb[e];e;e=nxt[e],b=vb[e])\nmap<int,bool> ps;\n#define SZ 2333 \nint n,x[SZ];\nvector<int> s[2];\n#define SZ 233333\nint M=1;typedef long long ll;\nint fst[SZ],nxt[SZ],vb[SZ],cap[SZ];\nvoid _ad_dl(int a,int b,int c) {++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;cap[M]=c;}\nvoid ad_dl(int a,int b,int c) {_ad_dl(a,b,c); _ad_dl(b,a,0);}\nint S,T,q[SZ],d[SZ];\nbool bfs()\n{\n    memset(d,-1,sizeof(d));\n    d[S]=0; q[1]=S; int h=1,t=2;\n    while(h!=t)\n    {\n        int cur=q[h++];\n        for(int e=fst[cur];e;e=nxt[e])\n        {\n            int b=vb[e];\n            if(d[b]==-1&&cap[e]) d[b]=d[cur]+1, q[t++]=b;\n        }\n    }\n    return d[T]!=-1;\n}\nint dfs(int x,int f)\n{\n    if(f<=0) return 0;\n    if(x==T) return f;\n    int ca=0;\n    for(int e=fst[x];e;e=nxt[e])\n    {\n        int b=vb[e];\n        if(d[b]!=d[x]+1) continue;\n        int w=dfs(b,min(cap[e],f-ca));\n        cap[e]-=w; cap[e^1]+=w; ca+=w;\n        if(ca==f) break;\n    }\n    if(!ca) d[x]=-1;\n    return ca;\n}\n#define inf 1000000000\nint dinic()\n{\n    int ans=0;\n    while(bfs()) ans+=dfs(S,inf);\n    return ans;\n}\nint N;\n#define SS 12345678\nbool npp[SS];\nint main()\n{\n\tnpp[1]=1;\n\tfor(int i=2;i*i<SS;++i) if(!npp[i])\n\t\tfor(int j=i*i;j<SS;j+=i) npp[j]=1;\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;++i)\t\n\t\tscanf(\"%d\",x+i),\n\t\tps[x[i]]^=1,ps[x[i]+1]^=1;\n\tfor(auto x:ps)\n\t\tif(x.se) s[x.fi&1].pb(x.fi);\n\tN=0; S=++N; T=++N;\n\tint a=N+1,b=N+1+s[0].size();\n\tfor(int i=0;i<s[0].size();++i)\n\t\tfor(int j=0;j<s[1].size();++j)\n\t\t\tif(!npp[abs(s[0][i]-s[1][j])])\n\t\t\t\tad_dl(a+i,b+j,1);\n\tfor(int i=0;i<s[0].size();++i)\n\t\tad_dl(S,a+i,1);\n\tfor(int i=0;i<s[1].size();++i)\n\t\tad_dl(b+i,T,1);\n\tint mx=dinic();\n\tint ans=mx+2*((s[0].size()-mx)/2+(s[1].size()-mx)/2)\n\t+3*((s[0].size()-mx)%2);\n\tprintf(\"%d\\n\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <bitset>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio>\n#include <cstring>\n#include <climits>\n#include <string.h>\n#include <stdio.h>\n#define LL long long\n#define all(x) (x).begin(),(x).end()\n#define pii pair<int,int>\n#define piii pair<int, pii >\n#define REP(i,n) for (int (i)=0;(i)<(n);(i)++)\n#define vi vector<int>\n#define vpi vector< pii >\n#define INF 2147483647\n#define big 19260817\n#define pb push_back\n#define mp make_pair\nusing namespace std;\nconst int Maxk=1005;\nstring mul(string a,string b){\n\tint res[Maxk];\n\tmemset(res,0,sizeof(res));\n\treverse(a.begin(),a.end());\n\treverse(b.begin(),b.end());\n\tfor (int i=0;i<a.length();i++){\n\t\tfor (int j=0;j<b.length();j++){\n\t\t\tres[i+j]+=(a[i]-'0')*(b[j]-'0');\n\t\t}\n\t}\n\tfor (int i=0;i<Maxk;i++){\n\t\tif (res[i]>=10) {\n\t\t\tres[i+1]+=(res[i]/10);\n\t\t\tres[i]%=10;\n\t\t}\n\t}\n\tstring ret;\n\tbool flag=false;\n\tfor (int i=Maxk-1;i>=0;i--){\n\t\tif (flag || res[i]){\n\t\t\tflag=true;\n\t\t\tret=ret+(char)(res[i]+'0');\n\t\t}\n\t}\n\tif (ret==\"\") ret=\"0\";\n\treturn ret;\n}\nstring add(string a,string b){\n\tif (a.length()<b.length()) swap(a,b);\n\twhile (a.length()!=b.length()){\n\t\tb='0'+b;\n\t}\n\tfor (int i=a.length()-1;i>=0;i--){\n\t\ta[i]+=(b[i]-'0');\n\t\tif (a[i]>'9' && i){\n\t\t\ta[i]-=10;\n\t\t\ta[i-1]++;\n\t\t}\n\t}\n\tif (a[0]>'9'){\n\t\ta[0]-=10;\n\t\ta='1'+a;\n\t}\n\treturn a;\n}\n\n// cf IO: I64d\n// atcoder IO: ｌｌｄ\ninline int read()\n{\n\tint x = 0, f = 1; char ch = getchar();\n\twhile (ch < '0' || ch > '9') { if (ch == '-') f = -1; ch = getchar(); }\n\twhile (ch >= '0' && ch <= '9') { x = x * 10 + ch - '0'; ch = getchar(); }\n\treturn x * f;\n}\nconst int Maxn=305;\nconst int Maxm=1e7+5;\nint cnt;\nint pos[Maxn],len[Maxn];\nint dp[Maxn][Maxn][2];\nbool isp[Maxm];\nvoid _init(){\n\tmemset(isp,true,sizeof(isp));\n\tisp[1]=isp[0]=false;\n\tfor (int i=2;i<Maxm;i++){\n\t\tif (isp[i]){\n\t\t\tfor (int j=i+i;j<Maxm;j+=i){\n\t\t\t\tisp[j]=false;\n\t\t\t}\n\t\t}\n\t}\n}\nint cost(int len){\n\tif (!len) return 0;\n\tif (len%2==0) return 2;\n\tif (isp[len]) return 1;\n\treturn 3;\n}\nint main(){\n\t_init();//cerr<<123<<endl;\n\tint n;\n\tscanf(\"%d\",&n);\n\tfor (int i=0;i<n;i++){\n\t\tscanf(\"%d\",&pos[i]);\n\t}\n\tint sum=1;\n\tfor (int i=1;i<n;i++){\n\t\tif (pos[i]==pos[i-1]+1) sum++;\n\t\telse{\n\t\t\tlen[++cnt]=sum;\n\t\t\tlen[++cnt]=pos[i]-pos[i-1]-1;\n\t\t\tsum=1;\n\t\t}\n\t}\n\tlen[++cnt]=sum;\n\tfor (int i=1;i<=cnt;i++){\n\t\tdp[i][i][0]=0;\n\t\tdp[i][i][1]=cost(len[i]);\n\t}\n\t//cout<<cnt<<endl;\n\tfor (int Len=2;Len<=cnt;Len++){\n\t\tfor (int i=1;i<=cnt;i++){\n\t\t\tint j=i+Len-1;\n\t\t\tif (j>cnt) continue;\n\t\t\tint totlen=0;\n\t\t\tfor (int k=i;k<=j;k++) totlen+=len[k];\n\t\t\tint fuck=min(cost(len[i])+cost(len[j]),cost(totlen-len[i])+cost(totlen-len[j]));\n\t\t\tdp[i][j][0]=min(dp[i+1][j-1][1],dp[i+1][j-1][0]+fuck+cost(totlen));\n\t\t\tdp[i][j][1]=min(dp[i+1][j-1][0]+fuck,dp[i+1][j-1][1]+cost(totlen));\n\t\t}\n\t}\n\tprintf(\"%d\\n\",dp[1][cnt][1]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cmath>\n#include<cstring>\n#include<algorithm>\n#define LL long long\n#define fo(i,j,k) for(int i=j;i<=k;i++)\n#define fd(i,j,k) for(int i=j;i>=k;i--)\n#define fr(i,j) for(int i=beg[j];i;i=nex[i])\nusing namespace std;\nint const mn=100+3,ma=1e7;\nint n,a[mn],tag[ma],ss[ma],b[2][mn],\n\tgra,beg[mn],to[mn*mn],nex[mn*mn],vis[mn],re[mn];\nvoid ins(int u,int v){\n\tto[++gra]=v;\n\tnex[gra]=beg[u];\n\tbeg[u]=gra;\n}\nint dfs(int p){\n\tfr(i,p)if((!re[to[i]])||dfs(re[to[i]])){\n\t\tre[to[i]]=p;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tfo(i,1,n)scanf(\"%d\",&a[i]);\n\tsort(a+1,a+n+1);\n\tb[a[1]&1][++b[a[1]&1][0]]=a[1];\n\tb[(a[n]+1)&1][++b[(a[n]+1)&1][0]]=a[n]+1;\n\tfo(i,2,n)if(a[i-1]+1!=a[i])\n\t\tb[(a[i-1]+1)&1][++b[(a[i-1]+1)&1][0]]=a[i-1]+1,\n\t\tb[a[i]&1][++b[a[i]&1][0]]=a[i];\n\ttag[1]=1;\n\tfo(i,2,ma){\n\t\tif(!tag[i])ss[++ss[0]]=i;\n\t\tfo(j,1,ss[0]){\n\t\t\tif(1ll*i*ss[j]>ma)break;\n\t\t\ttag[i*ss[j]]=1;\n\t\t\tif(!(i%ss[j]))break;\n\t\t}\n\t}\n\tfo(i,1,b[0][0])fo(j,1,b[1][0])\n\t\tif(!tag[abs(b[0][i]-b[1][j])])ins(i,j);\n\tint tmp=0;\n\tfo(i,1,b[0][0]){\n\t\tmemset(vis,0,sizeof(vis));\n\t\ttmp+=dfs(i);\n\t}\n\tprintf(\"%d\",tmp+2*((b[0][0]-tmp)/2+(b[1][0]-tmp)/2)+3*((b[0][0]-tmp)&1));\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define pb push_back\n\nusing namespace std;\n\nconst int MX = 10000001;\n\nint n , a, x[MX + 1], visId, match[300], vis[300];\nbool b[MX + 1], np[MX + 1];\nvector<int> me, mo, g[300];\n\nbool dfs(int u) {\n\tvis[u] = visId;\n\tfor (int i = 0 ; i < g[u].size(); ++i) {\n\t\tint v = g[u][i];\n\t\tif (match[v] == -1 || (vis[u] != visId && dfs(match[v]))) {\n\t\t\tmatch[v] = u;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n\n}\nint main() {\n\tfor (int i = 2; i <= MX; ++i) {\n\t\tif (np[i])continue;\n\t\tfor (int j = i + i; j <= MX ; j+=i){\n\t\t\tnp[j] = 1;\n\t\t}\n\t}\n\tnp[0] = np[1] = np[2] = 1;\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; ++i) {\n\t\tscanf(\"%d\", &a);\n\t\tx[a] = 1;\n\t}\n\tfor (int i = 1; i <= MX ; ++i) {\n\t\tb[i] = x[i] != x[i - 1];\n\t\tif (b[i] && (i % 2 == 0))me.pb(i);\n\t\tif (b[i] && (i % 2 == 1))mo.pb(i);\n\t}\n\tfor (int i = 0; i < me.size(); ++i) {\n\t\tfor (int j = 0 ; j < mo.size(); ++j) {\n\t\t\tif (!np[abs(me[i] - mo[j])]) {\n\t\t\t\tg[i].pb(j);\n\t\t\t}\n\t\t}\n\t}\n\tassert((me.size()+mo.size())%2 == 0);\n\tint res = 0;\n\tmemset(match,-1,sizeof match);\n\tfor (int i = 0; i < me.size(); ++i) {\n\t\tvisId++;\n\t\tif (dfs(i))res++;\n\t}\n\tint even = me.size() - res;\n\tint odd = mo.size() - res;\n\tint ans = res + (even / 2) * 2 + (odd / 2) * 2 + (odd%2)*3;\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define pi 3.1415926535897932384626\nusing namespace std;\n      \nstruct P{\n  int x,y;\n  bool operator < (const P &a )const{\n    //if(y!=a.y)\n    return y>a.y;\n  };\n};\n\nint a,b,c,d,i,k,n,m,e[333],dx[10]={1,0,-1,0,1,1,-1,-1},dy[10]={0,1,0,-1,1,-1,1,-1};\nint o[310];\nint l[10000001];\nint j[331];\n\nlong long x,y,z,mod=1000000007;\n//string r;\nchar r[2];\n\nP u[1];\nqueue<int> q;\n//stack<int> s;\nset<int> s;\nmap<int,int> p;\n\nvector<int> v1;\nstruct S{\n  int x,l,r;\n};\nvector<S> v[444];\n\nbool as(P a,P b)\n{\n  return a.x<b.x;\n}\n\nvoid mk(int n,int m)\n{\n  v[n].push_back({m,1,(int)v[m].size()});\n  v[m].push_back({n,0,(int)v[n].size()-1});\n}\n\nvoid dfs()\n{\n  memset(j,-1,sizeof(j));\n  j[205]=0;\n  q.push(205);\n  for(;q.size();q.pop())\n  for(int h=0;h<v[q.front()].size();h++)\n  if(v[q.front()][h].l&&j[v[q.front()][h].x]<0)\n  {\n    j[v[q.front()][h].x]=j[q.front()]+1;\n    q.push(v[q.front()][h].x);\n  }\n}\n\nint f(int n,int m,int l)\n{\n  if(n==m) return l;\n  for(;e[n]<v[n].size();e[n]++)\n  if(v[n][e[n]].l&&j[v[n][e[n]].x]==j[n]+1)\n  {\n    int k=f(v[n][e[n]].x,m,min(l,v[n][e[n]].l));\n    if(k)\n    {\n      v[n][e[n]].l-=k;\n      v[v[n][e[n]].x][v[n][e[n]].r].l+=k;\n      return k;\n    }\n  }\n  return 0;\n}\n\nint main()\n{\n  l[1]=l[2]=1;\n  for(int t=3;t<=10000000;t+=2)\n  if(l[t]==0)\n  {\n    //v.push_back(t);\n    for(long long i=(long long)t*t;i<=10000000;i+=t)\n    l[i]=1;\n  }\n  scanf(\"%d\",&a);\n  for(int t=1;t<=a;t++)\n    scanf(\"%d\",&o[t]);\n  o[0]=-1;\n  for(int t=1;t<=a;t++)\n  {\n    if(o[t-1]+1!=o[t]) v1.push_back(t);\n    if(o[t]+1!=o[t+1]) v1.push_back(t+1);\n  }\n  for(int h=0;h<v1.size();h++)\n  if(v1[h]%2) n++,mk(205,h);\n  else m++,mk(h,210);\n  for(int i=0;i<v1.size();i++)\n  if(v1[i]%2)\n  for(int j=0;j<v1.size();j++)\n  if(v1[j]%2==0&&l[abs(v1[i]-v1[j])]==0)\n  {\n    mk(i,j);\n  }\n  for(;;)\n  {\n    dfs();\n    if(j[210]<0) break;\n    memset(e,0,sizeof(e));\n    d=f(205,210,555);\n    if(!d) break;\n    else k+=d;\n  }\n  //printf(\"%d %d %d\",n,m,k);\n  printf(\"%d\",k+(n-k)/2*2+(m-k)/2*2+abs(n-k)%2*3);\n}\n//664579\n\n\n\n//3\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<cmath>\n#define N 210\n#define M 10000010\nusing namespace std;\nint prime[M],link[N],tot;\nbool p[M],vis[N];\nint n;\nbool can[N][N],s[M];\nvector<int>v[2];\nbool check(int u)\n{\n\tfor(int i=1;i<=v[1].size();i++)\n\tif(can[u][i] && !vis[i])\n\t{\n\t\tvis[i]=1;\n\t\tif(!link[i] || check(link[i]))\n \t\t{\n\t\t\tlink[i]=u;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\nint main()\n{\n\tp[1]=true;\n\tfor(int i=2;i<=M-10;i++)\n\t{\n\t\tif(!p[i]) prime[++tot]=i;\n\t\tfor(int j=1;j<=tot && i*prime[j]<=N-10;j++)\n\t\t{\n\t\t\tp[i*prime[j]]=1;\n\t\t\tif(i%prime[j]==0) break;\n\t\t}\n\t}\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint u;\n\t\tscanf(\"%d\",&u);\n\t\ts[u]=true;\n\t}\n\tfor(int i=2;i<=M-10;i++)\n\tif(s[i]^s[i-1]) v[i&1].push_back(i);\n\tfor(int i=0;i<v[0].size();i++)\n\t\tfor(int j=0;j<v[1].size();j++)\n\t\tif(!p[abs(v[0][i]-v[1][j])]) can[i+1][j+1]=true;\n\tint ans=0;\n    for(int i=0;i<v[0].size();i++)\n\t{\n\t\tmemset(vis,0,sizeof(vis));\n\t\tans+=check(i+1);\n\t}\n\tint tmp=ans;\n\tans+=(v[0].size()-ans)/2*2+(v[1].size()-ans)/2*2;\n    if((v[0].size()&1)!=(tmp&1)) ans+=3;\n\tprintf(\"%d\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstring>\n#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<queue>\n#include<stack>\n#include<cmath>\n#include<map>\n#include<complex>\n#define rep(i,l,r) for (int i=l;i<=r;i++)\n#define down(i,l,r) for (int i=l;i>=r;i--)\n#define clr(x,y) memset(x,y,sizeof(x))\n#define maxn 320500\n#define inf (int)1e9\n#define ll long long\n#define mm 1000000007\n#define eps 1e-13\n#define pb push_back\n#define low(x) x&(-x)\nusing namespace std;\n\nll read(){\n    ll x=0,f=1; char ch=getchar();\n    while (!isdigit(ch)) {if (ch=='-') f=-1; ch=getchar();}\n    while (isdigit(ch)){x=x*10+ch-'0'; ch=getchar();}\n    return x*f;\n}\nint aa[805],b[805];\nint matl[405],lnk[405],matr[405],q[2005000],visl[405],visr[405],labl[405],labr[405],a[405][405],slack[405];\nint mp[10000005],pmp[10000005],vis[10000005],pri[1000500];\nint ans,t,tot=1,ptot,n,m,idx;\nvoid modify(int x){\n\tfor (int t;x;x=t) t=matl[lnk[x]],matl[matr[x]=lnk[x]]=x;\n}\nvoid solve(int x){\n\tint l,r,d;\n\tq[l=r=1]=x; visl[x]=++idx;\n\twhile (1){\n\t\twhile (l<=r){\n\t\t\tint u=q[l++]; \n\t\t\trep(v,1,n) if (visr[v]!=idx){\n\t\t\t\td=labl[u]+labr[v]-a[u][v];\n\t\t\t\tif (!d){\n\t\t\t\t\tlnk[v]=u;\n\t\t\t\t\tif (!matr[v]) {modify(v); return;}\n\t\t\t\t\tvisr[v]=idx;\n\t\t\t\t\tif (visl[matr[v]]!=idx) q[++r]=matr[v],visl[matr[v]]=idx;\n\t\t\t\t}else if (d<slack[v]) slack[v]=d,lnk[v]=u; \n\t\t\t}\n\t\t}\n\t\td=inf;\n\t\trep(i,1,n) if (visr[i]!=idx) d=min(d,slack[i]);\n\t\trep(i,1,n) if (visl[i]==idx) labl[i]-=d;\n\t\trep(i,1,n) if (visr[i]==idx) labr[i]+=d;else if (slack[i]<inf) slack[i]-=d;\n\t\trep(i,1,n) if (visr[i]!=idx&&slack[i]==0) {\n\t\t\tif (!matr[i]){modify(i); return;}\n\t\t\tvisr[i]=idx;\n\t\t\tif (visl[matr[i]]!=idx) q[++r]=matr[i],visl[matr[i]]=idx;\n\t\t}\t\n\t}\n}\nint main(){\n//\tfreopen(\"input.txt\",\"r\",stdin);\n//\tfreopen(\"output.txt\",\"w\",stdout);\n\tn=read();\n\tint mxn=10000001;\n\trep(i,1,n) aa[i]=read(),mp[aa[i]]=1;\n\t//rep(i,1,n) if (mp[a[i]-1]==mp[a[i]]) b[i]=0; else b[i]=1;\n\trep(i,1,mxn) if (mp[i]!=mp[i-1]) b[++m]=i; \n\trep(i,2,mxn) {\n\t\tif (!vis[i]) pri[++ptot]=i,vis[i]=1,pmp[i]=1;\n\t\trep(j,1,ptot) {\n\t\t\tif (i*pri[j]>mxn) break;\n\t\t\tvis[i*pri[j]]=1;\n\t\t}\n\t}\n//\trep(i,1,m) printf(\"%d \",b[i]);\n\tn=m;\n\trep(i,1,m) labl[i]=-inf;\n\trep(i,1,m) rep(j,1,m) {\n\t\tif (i==j) continue;\n\t\tif ((abs(b[i]-b[j])&1)==0) a[i][j]=-2,labl[i]=max(labl[i],-2);;\n\t\tif (abs(b[i]-b[j])&1){\n\t\t\tif (pmp[abs(b[i]-b[j])]) a[i][j]=-1,labl[i]=max(labl[i],-1);\n\t\t\telse a[i][j]=-3,labl[i]=max(labl[i],-3);;\n\t\t}\n\t}\n\trep(i,1,n){\n\t\trep(j,1,n) slack[j]=inf,lnk[j]=0;\n\t\tsolve(i);\n\t}\n\trep(i,1,n) ans+=labl[i]+labr[i];\n    printf(\"%d\\n\",-ans/2);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n\n#define Int register int\n#define int long long\n#define MAXN 10000005\n\nint Abs (int x){return x > 0 ? x : -x;}\n\nint tot;\nint prime[MAXN];\n\nbool vis[MAXN];\n\nvoid Prime (int n)\n{\n\tvis[1] = 1;\n\tfor (Int i = 2;i <= n;++ i)\n\t{\n\t\tif (!vis[i]) prime[++ tot] = i;\n\t\tfor (Int j = 1;j <= tot && i * prime[j] <= n;++ j)\n\t\t{\n\t\t\tvis[i * prime[j]] = 1;\n\t\t\tif (i % prime[j] == 0) break;\n\t\t}\n\t}\n}\n\nbool check (int x){return !vis[x];}\n\nbool rev[MAXN];\n\nint read ()\n{\n\tint x = 0;char c = getchar();int f = 1;\n\twhile (c < '0' || c > '9'){if (c == '-') f = -f;c = getchar();}\n\twhile (c >= '0' && c <= '9'){x = (x << 3) + (x << 1) + c - '0';c = getchar();}\n\treturn x * f;\n}\n\nvoid write (int x)\n{\n\tif (x < 0){x = -x;putchar ('-');}\n\tif (x > 9) write (x / 10);\n\tputchar (x % 10 + '0');\n}\n\nvector <int> s1,s2;\n\n\nvector <int> G[MAXN];\n\nint my[MAXN];\nbool visit[MAXN];\n\nint dfs (int u)\n{\n\tfor (Int i = 0;i < G[u].size();++ i)\n\t{\n\t\tint v = G[u][i];\n\t\tif (visit[v]) continue;\n\t\tvisit[v] = 1;\n\t\tif (my[v] == -1 || dfs (my[v]))\n\t\t{\n\t\t\tmy[v] = u;\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nint Hungry ()\n{\n\tint cnt = 0;\n\tmemset (my,-1,sizeof (my));\n\tfor (Int i = 0;i < s1.size();++ i)\n\t{\n\t\tmemset (visit,0,sizeof (visit));\n\t\tcnt += dfs (i);\n\t}\n\treturn cnt;\n}\n\nsigned main()\n{\n\tint n = read ();\n\tint Maxn = 0;\n\tfor (Int i = 1;i <= n;++ i)\n\t{\n\t\tint x = read ();\n\t\trev[x] ^= 1;\n\t\tMaxn = max (Maxn,x + 1);\n\t}\n\tPrime (Maxn);\n\tfor (Int i = 1;i <= Maxn;++ i)\n\t\tif (rev[i] != rev[i - 1])\n\t\t{\n\t\t\tif (i & 1)\n\t\t\t\ts1.push_back(i);\n\t\t\telse \n\t\t\t\ts2.push_back(i);\n\t\t}\n\tfor (Int i = 0;i < s1.size();++ i)\n\t\tfor (Int j = 0;j < s2.size();++ j)\n\t\t\tif (check (Abs (s1[i] - s2[j])))\n\t\t\t\tG[i].push_back(j); \n\tint Ans = Hungry ();\n\twrite (Ans + (s1.size() - Ans) / 2 * 2 + (s2.size() - Ans) / 2 * 2 + s1.size() % 2 * 3),putchar ('\\n'); \n\treturn 0; \n}"
  },
  {
    "language": "C++",
    "code": "// Copyright (C) 2017 __debug.\n\n// This program is free software; you can redistribute it and/or\n// modify it under the terms of the GNU General Public License as\n// published by the Free Software Foundation; version 3\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program; If not, see <http://www.gnu.org/licenses/>.\n\n\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/priority_queue.hpp>\n\n#define x first\n#define y second\n#define MP std::make_pair\n#define SZ(x) ((int)(x).size())\n#define ALL(x) (x).begin(), (x).end()\n#define DEBUG(...) fprintf(stderr, __VA_ARGS__)\n#ifdef __linux__\n#define getchar getchar_unlocked\n#define putchar putchar_unlocked\n#endif\n\nusing std::pair;\nusing std::vector;\nusing std::string;\n\ntypedef long long LL;\ntypedef pair<int, int> Pii;\n\nconst int oo = 0x3f3f3f3f;\n\ntemplate<typename T> inline bool chkmax(T &a, T b) { return a < b ? a = b, true : false; }\ntemplate<typename T> inline bool chkmin(T &a, T b) { return b < a ? a = b, true : false; }\nstring procStatus()\n{\n    std::ifstream t(\"/proc/self/status\");\n    return string(std::istreambuf_iterator<char>(t), std::istreambuf_iterator<char>());\n}\ntemplate<typename T> T read(T &x)\n{\n    int f = 1;\n    char ch = getchar();\n    for (; !isdigit(ch); ch = getchar())\n        f = (ch == '-' ? -1 : 1);\n    for (x = 0; isdigit(ch); ch = getchar())\n        x = 10 * x + ch - '0';\n    return x *= f;\n}\ntemplate<typename T> void write(T x)\n{\n    if (x == 0) {\n        putchar('0');\n        return;\n    }\n    if (x < 0) {\n        putchar('-');\n        x = -x;\n    }\n    static char s[20];\n    int top = 0;\n    for (; x; x /= 10)\n        s[++top] = x % 10 + '0';\n    while (top)\n        putchar(s[top--]);\n}\n// EOT\n\nconst int MAXN = 105, RNG = 1e7 + 5;\n\nint N;\nint X[MAXN];\n\nvoid input()\n{\n    read(N);\n    for (int i = 1; i <= N; ++i) {\n        read(X[i]);\n    }\n}\n\nint primes[RNG], totprimes;\nbool composite[RNG];\n\nvoid sieve(int n)\n{\n    composite[1] = true;\n    for (int i = 2; i <= n; ++i) {\n        if (!composite[i])\n            primes[totprimes++] = i;\n        for (int j = 0, x; (x = primes[j] * i) <= n; ++j) {\n            composite[x] = true;\n            if (i % primes[j] == 0)\n                break;\n        }\n    }\n}\n\nvector<int> odd, even;\nbool G[MAXN][MAXN];\nint match[MAXN];\nbool vis[MAXN];\n\nbool augment(int u)\n{\n    for (int v = 0; v < SZ(even); ++v) {\n        if (G[u][v] && !vis[v]) {\n            vis[v] = true;\n            if (!~match[v] || augment(match[v])) {\n                match[v] = u;\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\nvoid solve()\n{\n    sieve(X[N]);\n\n    X[0] = -1;\n    X[N + 1] = RNG;\n    for (int i = 1; i <= N; ++i) {\n        if (X[i - 1] + 1 < X[i])\n            (X[i] & 1 ? odd : even).push_back(X[i]);\n        if (X[i] + 1 < X[i + 1])\n            ((X[i] + 1) & 1 ? odd : even).push_back(X[i] + 1);\n    }\n\n    for (int i = 0; i < SZ(odd); ++i) {\n        for (int j = 0; j < SZ(even); ++j) {\n            if (!composite[std::abs(odd[i] - even[j])])\n                G[i][j] = true;\n        }\n    }\n\n    int t = 0;\n    memset(match, -1, sizeof(match));\n    for (int i = 0; i < SZ(odd); ++i) {\n        memset(vis, 0, sizeof(vis));\n        t += augment(i);\n    }\n    int ans = t + ((SZ(odd) - t) / 2 + (SZ(even) - t) / 2) * 2 + (SZ(odd) - t) % 2 * 3;\n\n    printf(\"%d\\n\", ans);\n}\n\nint main()\n{\n#ifdef __DEBUG\n    freopen(\"F.in\", \"r\", stdin);\n    freopen(\"F.out\", \"w\", stdout);\n#endif\n\n    input();\n    solve();\n\n    return 0;\n}\n\n//              滥竽充数\n//            [先秦] 韩非\n//\n// 齐宣王使人吹竽，必三百人。\n// 南郭处士请为王吹竽，宣王说之，廪食以数百人。\n// 宣王死，湣王立，好一一听之，处士逃。\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n#include<cstring>\n\nusing namespace std;\n\nusing vi = vector<int>;\nvi X;\nint n;\nvector<vi> C;\nint used[207];\nbool isprime(int n) {\n\tif (n <= 2)return false;\n\tfor (int i = 2; i*i <= n; i++) {\n\t\tif (n%i == 0)return false;\n\t}\n\treturn true;\n}\nbool dfs(int v) {\n\tused[v] = true;\n\tfor (int i = 0; i < X.size() + 2; i++) {\n\t\tif (!used[i] && C[v][i] > 0) {\n\t\t\tif (dfs(i)) {\n\t\t\t\tC[v][i]--;\n\t\t\t\tC[i][v]++;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\nint main() {\n\tcin >> n;\n\tvi evens;\n\tvi odds;\n\tfor (int i = 0; i < n; i++) {\n\t\tint x;\n\t\tcin >> x;\n\t\tif (!X.empty() && X.back() == x) {\n\t\t\tX.pop_back();\n\t\t\tX.push_back(x + 1);\n\t\t}\n\t\telse {\n\t\t\tX.push_back(x);\n\t\t\tX.push_back(x + 1);\n\t\t}\n\t}\n\tint E = 0;\n\tint O = 0;\n\tfor (int x : X) {\n\t\tif (x % 2 == 0) {\n\t\t\tE++;\n\t\t}\n\t\telse {\n\t\t\tO++;\n\t\t}\n\t}\n\t\t\n\tC.resize(X.size()+2, vi(X.size()+2, 0));\n\tfor (int i = 0; i < X.size(); i++) {\n\t\tif (X[i] % 2 == 0) {\n\t\t\tC[X.size()][i] = 1;\n\t\t}\n\t\telse {\n\t\t\tC[i][X.size() + 1] = 1;\n\t\t}\n\t}\n\tfor (int i = 0; i < X.size(); i++) {\n\t\tfor (int j = i; j < X.size(); j++) {\n\t\t\tif (isprime(abs(X[i] - X[j]))) {\n\t\t\t\tint a = i;\n\t\t\t\tint b = j;\n\t\t\t\tif (b % 2 == 0)swap(a, b);\n\t\t\t\tC[a][b] = 1;\n\t\t\t}\n\t\t}\n\t}\n\tint ans = 0;\n\twhile (dfs(X.size())) {\n\t\tmemset(used, false, sizeof(used));\n\t\tans++;\n\t}\n\tif ((E - ans) % 2 == 0) {\n\t\tcout << ans + (E - ans + O - ans) << endl;\n\t}\n\telse {\n\t\tcout << ans + (E - ans - 1 + O - ans - 1) + 3 << endl;\n\t}\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n//#define int long long\n#define _rep(_1, _2, _3, _4, name, ...) name\n#define rep2(i, n) rep3(i, 0, n)\n#define rep3(i, a, b) rep4(i, a, b, 1)\n#define rep4(i, a, b, c) for (int i = int(a); i < int(b); i += int(c))\n#define rep(...) _rep(__VA_ARGS__, rep4, rep3, rep2, _)(__VA_ARGS__)\n\n\nusing i8 = signed char;\nusing i64 = long long;\n\n\n\ntemplate <typename WeightType>\nclass MaximumWeightedMatching {\n\t/*\n\tMaximum Weighted Matching in General Graphs\n\t- O(n^3) time\n\t- O(n + m) space\n\n\tNote: each vertex is 1-indexed.\n\t*/\npublic:\n\tusing weight_t = WeightType;\n\tusing weight_sum_t = i64;\n\tstruct Edge { int from, to; weight_t weight; };\n\nprivate:\n\tenum TreeLabelNumber { INNER = -1, UNUSED = 0, OUTER = 1 };\n\tenum LabelNumber { SEPARATED = -2, DEFAULT = -1 };\n\tenum EdgeNumber { UNDEFINED = 1 << 30 };\n\n\tstatic constexpr weight_t INF = weight_t(1) << (sizeof(weight_t) * 8 - 2);\n\n\tstruct Node { int next, from, to; };\n\tstruct Label { int from, to; };\n\tstruct LinkedList { int eid, next; };\n\n\tclass Queue {\n\tpublic:\n\t\tQueue() {}\n\t\tQueue(int N) : que(N), qh(0), qt(0) {}\n\t\tvoid clear() { qh = qt = 0; }\n\t\tint* data() { return que.data(); }\n\t\tbool empty() const { return qh == qt; }\n\t\tint dequeue() { return que[qh++]; }\n\t\tvoid enqueue(int u) { que[qt++] = u; }\n\t\tint operator [] (int i) const { return que[i]; }\n\t\tint size() const { return qt; }\n\n\t\tvector<int> que;\n\t\tint qh, qt;\n\t};\n\npublic:\n\tMaximumWeightedMatching(int N, const vector<Edge>& raw_edges)\n\t\t: N(N), B((N - 1) / 2), size(N + B + 1) {\n\n\t\toffsets.assign(N + 2, 0);\n\t\tfor (auto& e : raw_edges) {\n\t\t\toffsets[e.from + 1]++;\n\t\t\toffsets[e.to + 1]++;\n\t\t}\n\t\trep(i, 1, N + 1) offsets[i] += offsets[i - 1];\n\t\tedges.resize(raw_edges.size() * 2);\n\t\trep(i, raw_edges.size()) {\n\t\t\tauto& e = raw_edges[i];\n\t\t\tedges[offsets[e.from]++] = { e.from, e.to, 2 * e.weight };\n\t\t\tedges[offsets[e.to]++] = { e.to, e.from, 2 * e.weight };\n\t\t}\n\t\trep(i, N + 1) offsets[N + 1 - i] = offsets[N - i];\n\t\toffsets[0] = 0;\n\t}\n\n\tweight_sum_t maximum_weighted_matching() {\n\t\tinitialize();\n\t\tset_potential();\n\t\trep(u, 1, N + 1) if (!mate[u]) {\n\t\t\tfor (int s = 0; !augmented(u, s); s = adjust_dual_solutions());\n\t\t\tfix_blossom_bases();\n\t\t\tclear_label();\n\t\t}\n\t\tweight_sum_t ret = 0;\n\t\trep(u, 1, N + 1) if (mate[u] > u) {\n\t\t\tweight_t max_w = 0;\n\t\t\trep(eid, offsets[u], offsets[u + 1]) if (edges[eid].to == mate[u]) {\n\t\t\t\tmax_w = max(max_w, edges[eid].weight);\n\t\t\t}\n\t\t\tret += max_w;\n\t\t}\n\t\treturn ret >> 1;\n\t}\n\nprivate:\n\tinline int encode(int e) const {\n\t\treturn e + size + 1; // should be >= 3\n\t}\n\n\tinline weight_t reduced_cost(int u, int v, const Edge& e) const {\n\t\treturn potential[u] + potential[v] - e.weight;\n\t}\n\n\tinline weight_t reduced_cost(int eid) const {\n\t\treturn reduced_cost(edges[eid].from, edges[eid].to, edges[eid]);\n\t}\n\n\tvoid rematch(int v, int w) {\n\t\tauto t = mate[v]; mate[v] = w;\n\t\tif (mate[t] != v) return;\n\t\tif (label[v].to == 0) {\n\t\t\tmate[t] = label[v].from;\n\t\t\trematch(mate[t], t);\n\t\t}\n\t\telse {\n\t\t\tint x = label[v].from, y = label[v].to;\n\t\t\trematch(x, y); rematch(y, x);\n\t\t}\n\t}\n\n\tLabel search_blossom_edge(int bid) const {\n\t\tint b = base[bid], bv = b;\n\t\tfor (; node[bv].next != b; bv = node[node[bv].next].next);\n\t\treturn{ node[bv].from, node[bv].to };\n\t}\n\n\tvoid label_blossom(int bid, int m, Label l) {\n\t\tlabel[bid] = { l.from, (l.to == surface[l.to]) ? 0 : l.to };\n\t\tif (bid <= N) return;\n\t\tint b = base[bid]; label_blossom(b, mate[bid] = m, l);\n\t\tl = search_blossom_edge(bid);\n\t\tfor (int bv = b, bw; node[bv].next != b; bv = node[bw].next) {\n\t\t\tlabel_blossom(bw = node[bv].next, 0, l);\n\t\t\tlabel_blossom(node[bw].next, node[bw].from, { node[bv].from, node[bv].to });\n\t\t}\n\t}\n\n\tint find_mate(int bid) {\n\t\treturn bid <= N ? mate[bid] : mate[bid] = find_mate(base[bid]);\n\t}\n\n\tvoid push_inner_blossom_rec(int bid, bool push = true) {\n\t\ttree_label[bid] = (bid <= N) ? INNER : UNUSED;\n\t\tif (bid > N) {\n\t\t\tint v = base[bid], u = v;\n\t\t\tdo { push_inner_blossom_rec(v, push); } while ((v = node[v].next) != u);\n\t\t}\n\t\telse if (push) inner_vertices[inner_vertices_size++] = bid;\n\t}\n\n\tvoid push_inner_blossom(int bid) {\n\t\tif (tree_label[bid] != UNUSED) return;\n\t\tbool push = label[bid].from != SEPARATED;\n\t\tif (bid > N) {\n\t\t\tif (push) inner_blossoms[inner_blossom_size++] = bid;\n\t\t\tpush_inner_blossom_rec(bid, push);\n\t\t}\n\t\telse if (push) inner_vertices[inner_vertices_size++] = bid;\n\t\ttree_label[bid] = INNER;\n\t}\n\n\tvoid push_outer_blossom_rec(int bid) {\n\t\ttree_label[bid] = (bid <= N) ? OUTER : UNUSED;\n\t\tif (bid > N) {\n\t\t\tint v = base[bid], u = v;\n\t\t\tdo { push_outer_blossom_rec(v); } while ((v = node[v].next) != u);\n\t\t}\n\t\telse outer_vertices.enqueue(bid);\n\t}\n\n\tvoid push_outer_blossom(int bid, bool push) {\n\t\tpush_outer_blossom_rec(bid);\n\t\tif (bid <= N) return;\n\t\tif (push) outer_blossoms[outer_blossom_size++] = bid, tree_label[bid] = OUTER;\n\t\telse tree_label[bid] = UNUSED;\n\t}\n\n\tinline void merge_edge(int x, int bx, int eid) {\n\t\tauto& e = edges[eid];\n\t\tint y = e.to, by = surface[y];\n\t\tif (tree_label[by] != OUTER || bx == by) return;\n\t\tauto r_cost = reduced_cost(x, y, e);\n\t\tif (r_cost < best_cost[by].first) {\n\t\t\tif (best_cost[by].first == INF) merged_edges[merged_edge_size++] = by;\n\t\t\tbest_cost[by] = { r_cost, eid };\n\t\t}\n\t}\n\n\tinline void merge_vertex(int x, int bx) {\n\t\trep(eid, offsets[x], offsets[x + 1]) merge_edge(x, bx, eid);\n\t\tbest_edge[x] = UNDEFINED;\n\t}\n\n\tvoid clear_best_edges(int b) {\n\t\tif (b > N) {\n\t\t\tint v = b = base[b];\n\t\t\tdo { clear_best_edges(v); } while ((v = node[v].next) != b);\n\t\t}\n\t\telse best_edge[b] = UNDEFINED;\n\t}\n\n\tvoid merge_outer(int b, int bid) {\n\t\tif (b > N) {\n\t\t\tfor (int head = blist_head[b]; head >= 0; head = bnode[head].next) {\n\t\t\t\tint eid = bnode[head].eid;\n\t\t\t\tmerge_edge(edges[eid].from, bid, eid);\n\t\t\t\tnext_bnode.push_back(head);\n\t\t\t}\n\t\t\tblist_head[b] = -1;\n\t\t\tclear_best_edges(b);\n\t\t}\n\t\telse merge_vertex(b, bid);\n\t}\n\n\tvoid merge_inner(int b, int bid) {\n\t\tif (b > N) {\n\t\t\tint v = b = base[b];\n\t\t\tdo { merge_inner(v, bid); } while ((v = node[v].next) != b);\n\t\t}\n\t\telse merge_vertex(b, bid);\n\t}\n\n\tvoid build_linked_list(int bid) {\n\t\tif (bid <= N) return;\n\t\tint last = -1;\n\t\tfor (; merged_edge_size > 0; ) {\n\t\t\tint nid = next_bnode.back(); next_bnode.pop_back();\n\t\t\tint by = merged_edges[--merged_edge_size], eid = best_cost[by].second;\n\t\t\tint x = edges[eid].from, y = edges[eid].to;\n\t\t\tbnode[nid] = { eid, last };\n\t\t\tif (tree_label[y] == OUTER) update_best_edge(y, by, best_cost[by].first, eid);\n\t\t\tif (best_edge[x] == UNDEFINED || best_cost[by].first < reduced_cost(best_edge[x])) {\n\t\t\t\tbest_edge[x] = eid;\n\t\t\t}\n\t\t\tbest_cost[by] = { INF, UNDEFINED };\n\t\t\tlast = nid;\n\t\t}\n\t\tblist_head[bid] = last;\n\t}\n\n\tvoid merge_best_edges(int bid, int inner_count) {\n\t\trep(i, inner_count) {\n\t\t\tint bv = outer_blossoms[outer_blossom_size + i];\n\t\t\tif (bv >= 0) merge_outer(bv, bid), merge_inner(node[bv].next, bid);\n\t\t\telse merge_inner(~bv, bid), merge_outer(node[~bv].next, bid);\n\t\t}\n\t\tmerge_outer(base[bid], bid);\n\t\tbuild_linked_list(bid);\n\t}\n\n\tvoid contract(int x, int y, int eid) {\n\t\tint s = surface[x], t = surface[y];\n\t\tif (s == t) return;\n\t\tauto h = label[surface[mate[s]]].from = label[surface[mate[t]]].from = -encode(eid);\n\n\t\tint lca = -1;\n\t\tfor (; ; label[surface[mate[s]]].from = h) {\n\t\t\tif (mate[t] != 0) swap(s, t);\n\t\t\ts = lca = surface[label[s].from];\n\t\t\tif (label[surface[mate[s]]].from == h) break;\n\t\t}\n\n\t\tint inner_count = 0;\n\t\tfor (int dir = 0; dir < 2; ++dir) {\n\t\t\tint v = (dir == 0) ? x : y;\n\t\t\twhile (1) {\n\t\t\t\tint bv = surface[v], mv = mate[bv], bmv = surface[mv];\n\t\t\t\tif (bv == lca) break;\n\t\t\t\tlabel[mv] = label[bmv] = { x, y };\n\t\t\t\tauto n = node[bmv];\n\t\t\t\tif (!dir) {\n\t\t\t\t\tnode[bv] = { bmv, mate[mv], mv };\n\t\t\t\t\tnode[bmv].next = surface[n.to];\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tnode[surface[n.to]] = { bmv, n.to, n.from };\n\t\t\t\t\tnode[bmv] = { bv, mv, mate[mv] };\n\t\t\t\t}\n\t\t\t\tpush_outer_blossom(bmv, false);\n\t\t\t\tv = label[bv].from;\n\n\t\t\t\t// Caution: used as temporary array\n\t\t\t\touter_blossoms[outer_blossom_size + (inner_count++)] = !dir ? bv : ~bmv;\n\t\t\t}\n\t\t}\n\t\tnode[surface[y]] = { surface[x], y, x };\n\n\t\tint bid = next_bid.back(); next_bid.pop_back();\n\t\tbase[bid] = lca, label[bid].from = label[lca].from, mate[bid] = mate[lca];\n\n\t\ttree_label[bid] = OUTER;\n\t\tset_surface(bid, bid);\n\t\tmerge_best_edges(bid, inner_count);\n\n\t\touter_blossoms[outer_blossom_size++] = bid;\n\t}\n\n\tinline void update_best_edge(int y, int by, weight_t r_cost, int eid) {\n\t\tif (tree_label[by] != OUTER && best_edge[y] == UNDEFINED) {\n\t\t\tneighbors[neighbor_size++] = y;\n\t\t}\n\t\tif (best_edge[y] == UNDEFINED || r_cost < reduced_cost(best_edge[y])) {\n\t\t\tbest_edge[y] = eid;\n\t\t}\n\t}\n\n\tvoid build_edge_list(int b) {\n\t\tif (b <= N) return;\n\t\tmerge_inner(b, b);\n\t\tbuild_linked_list(b);\n\t}\n\n\tbool augmented(int root, int s) {\n\t\tif (s == 0) {\n\t\t\tint br = surface[root];\n\t\t\tpush_outer_blossom(br, true);\n\t\t\tlabel_blossom(br, 0, { 0, 0 });\n\t\t\tbuild_edge_list(br);\n\t\t}\n\t\tfor (; !outer_vertices.empty() || s > 0; s = 0) {\n\t\t\tauto x = (s > 0) ? s : outer_vertices.dequeue();\n\t\t\tif (potential[x] == 0) {\n\t\t\t\tif (root != x) rematch(x, 0);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\trep(eid, offsets[x], offsets[x + 1]) {\n\t\t\t\tint bx = surface[x], y = edges[eid].to, by = surface[y];\n\t\t\t\tif (bx == by) continue;\n\t\t\t\tauto r_cost = reduced_cost(x, y, edges[eid]);\n\t\t\t\tif (r_cost > 0 || tree_label[by] != OUTER) {\n\t\t\t\t\tupdate_best_edge(y, by, r_cost, eid);\n\t\t\t\t\tif (r_cost > 0) continue;\n\t\t\t\t}\n\t\t\t\tif (label[by].from >= 0) {\n\t\t\t\t\tcontract(x, y, eid);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (tree_label[by] == UNUSED) {\n\t\t\t\t\tpush_inner_blossom(by);\n\t\t\t\t\tif (by != y) label_blossom(by, find_mate(by), { DEFAULT, 0 });\n\t\t\t\t}\n\t\t\t\tint z = mate[by];\n\t\t\t\tif (z == 0 && by != surface[root]) {\n\t\t\t\t\trematch(x, y); rematch(y, x);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tint bz = surface[z];\n\t\t\t\tif (label[bz].from < 0) {\n\t\t\t\t\tnode[by] = { -1, y, x };\n\t\t\t\t\tpush_outer_blossom(bz, true);\n\t\t\t\t\tlabel_blossom(bz, mate[z], { x, y });\n\t\t\t\t\tbuild_edge_list(bz);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tvoid set_surface(int b, int bid) {\n\t\tfor (int v = base[b]; surface[v] != bid; v = node[v].next) {\n\t\t\tif (v > N) tree_label[v] = UNUSED, set_surface(v, bid);\n\t\t\tsurface[v] = bid;\n\t\t}\n\t}\n\n\tvoid reset_surface(int b, int bid) {\n\t\tsurface[b] = bid;\n\t\tif (b <= N) return;\n\t\tfor (b = base[b]; surface[b] != bid; b = node[b].next) reset_surface(b, bid);\n\t}\n\n\tvoid separate_blossom(int bid, bool push_blossom = true) {\n\t\ttree_label[bid] = UNUSED, label[bid].from = SEPARATED;\n\t\tif (bid <= N) return;\n\t\tif (push_blossom) inner_blossoms[inner_blossom_size++] = bid;\n\t\tfor (int b = base[bid]; label[b].from != SEPARATED; b = node[b].next) {\n\t\t\tseparate_blossom(b, false);\n\t\t}\n\t}\n\n\tvoid reverse_blossom(int b) {\n\t\tint v = b, fr = node[b].from, to = node[b].to;\n\t\tfor (int nv = node[v].next; nv != b; ) {\n\t\t\tint nnext = node[nv].next, nfr = node[nv].from, nto = node[nv].to;\n\t\t\tnode[nv].next = v, node[nv].from = to, node[nv].to = fr;\n\t\t\tfr = nfr, to = nto, v = nv, nv = nnext;\n\t\t}\n\t\tnode[b].next = v, node[b].from = to, node[b].to = fr;\n\t}\n\n\tvoid expand_blossom(int bid) {\n\t\tnext_bid.push_back(bid); tree_label[bid] = UNUSED;\n\t\tfor (int b = base[bid]; surface[b] == bid; b = node[b].next) reset_surface(b, b);\n\t\tint old_base = base[bid], target = surface[node[bid].from];\n\t\tif (mate[node[target].from] == node[target].to) reverse_blossom(old_base);\n\t\tfor (int b = target; node[b].next != old_base; ) {\n\t\t\tseparate_blossom(b = node[b].next); separate_blossom(b = node[b].next);\n\t\t}\n\t\tnode[target] = node[bid];\n\t\tfor (int b = old_base; ; b = node[b].next) {\n\t\t\tlabel[b].from = DEFAULT, tree_label[b] = INNER;\n\t\t\tif (b > N) inner_blossoms[inner_blossom_size++] = b;\n\t\t\tint m = find_mate(b), bm = surface[m];\n\t\t\tif (b != old_base) mate[bm] = mate[m];\n\t\t\tlabel[m] = label[bm] = { node[b].to, node[b].from };\n\t\t\tif (b == target) break;\n\t\t\tpush_outer_blossom(b = node[b].next, true);\n\t\t\tbuild_edge_list(b);\n\t\t}\n\t\tbase[bid] = bid, surface[bid] = bid;\n\t}\n\n\tvoid update_potential(int* vs, int s, weight_t delta, int label) {\n\t\trep(i, s) {\n\t\t\tint x = vs[i];\n\t\t\tif (tree_label[x] != label) continue;\n\t\t\tpotential[x] += delta;\n\t\t}\n\t}\n\n\tint adjust_dual_solutions() {\n\t\tpair<weight_t, int> delta1(INF, 0), delta2(INF, 0), delta3(INF, 0), delta4(INF, 0);\n\t\trep(i, outer_vertices.size()) {\n\t\t\tint y = outer_vertices[i], eid = best_edge[y];\n\t\t\tdelta1 = min(delta1, { potential[y], y });\n\t\t\tif (eid != UNDEFINED) {\n\t\t\t\tdelta3 = min(delta3, { reduced_cost(eid) >> 1, y });\n\t\t\t}\n\t\t}\n\t\trep(i, neighbor_size) {\n\t\t\tint y = neighbors[i];\n\t\t\tif (tree_label[y] == UNUSED) {\n\t\t\t\tint eid = best_edge[y], x = edges[eid].from;\n\t\t\t\tdelta2 = min(delta2, { reduced_cost(x, y, edges[eid]), x });\n\t\t\t}\n\t\t}\n\t\trep(i, inner_blossom_size) if (tree_label[inner_blossoms[i]] == INNER) {\n\t\t\tint b = inner_blossoms[i];\n\t\t\tdelta4 = min(delta4, { potential[b] >> 1, b });\n\t\t}\n\t\tauto delta = min(min(delta1, delta2), min(delta3, delta4));\n\t\tauto d = delta.first;\n\t\tupdate_potential(outer_vertices.data(), outer_vertices.size(), -1 * d, OUTER);\n\t\tupdate_potential(inner_vertices.data(), inner_vertices_size, 1 * d, INNER);\n\t\tupdate_potential(outer_blossoms.data(), outer_blossom_size, 2 * d, OUTER);\n\t\tupdate_potential(inner_blossoms.data(), inner_blossom_size, -2 * d, INNER);\n\t\tif (delta4.first == d) {\n\t\t\texpand_blossom(delta4.second);\n\t\t\treturn -1;\n\t\t}\n\t\telse {\n\t\t\treturn delta.second;\n\t\t}\n\t}\n\n\tvoid fix_blossom_bases() {\n\t\tint remain = size - next_bid.size() - (N + 1);\n\t\tfor (int bid = N + 1; bid < size && remain > 0; ++bid) if (base[bid] != bid) {\n\t\t\tint b = base[bid];\n\t\t\tfor (int skipped = 0; skipped < 2;) {\n\t\t\t\tb = node[b].next;\n\t\t\t\tif (mate[node[b].from] == node[b].to) skipped = 0;\n\t\t\t\telse skipped++;\n\t\t\t}\n\t\t\tbase[bid] = b;\n\t\t\t--remain;\n\t\t}\n\t}\n\n\tvoid free_edge_list(int x) {\n\t\tfor (int head = blist_head[x]; head >= 0; head = bnode[head].next) {\n\t\t\tnext_bnode.push_back(head);\n\t\t}\n\t\tblist_head[x] = -1;\n\t}\n\n\tvoid clear_vertices(int* vs, int size) {\n\t\trep(i, size) {\n\t\t\tint v = vs[i];\n\t\t\tlabel[v] = { DEFAULT, 0 }; tree_label[v] = UNUSED; best_edge[v] = UNDEFINED;\n\t\t}\n\t}\n\n\tvoid clear_label() {\n\t\tlabel[0] = { DEFAULT, 0 };\n\t\tclear_vertices(outer_vertices.data(), outer_vertices.size()); outer_vertices.clear();\n\t\tclear_vertices(inner_vertices.data(), inner_vertices_size); inner_vertices_size = 0;\n\t\tclear_vertices(outer_blossoms.data(), outer_blossom_size);\n\t\trep(i, outer_blossom_size) if (blist_head[outer_blossoms[i]] >= 0) free_edge_list(outer_blossoms[i]);\n\t\touter_blossom_size = 0;\n\t\tclear_vertices(inner_blossoms.data(), inner_blossom_size); inner_blossom_size = 0;\n\t\trep(i, neighbor_size) best_edge[neighbors[i]] = UNDEFINED;\n\t\tneighbor_size = 0;\n\t}\n\n\tvoid set_potential() {\n\t\tpotential.resize(size);\n\t\trep(u, 1, N + 1) {\n\t\t\tweight_t max_w = 0;\n\t\t\trep(eid, offsets[u], offsets[u + 1]) max_w = max(max_w, edges[eid].weight);\n\t\t\tpotential[u] = max_w >> 1;\n\t\t}\n\t}\n\n\tvoid initialize() {\n\t\tmate.assign(size, 0);\n\t\tlabel.assign(size, { -1, 0 });\n\n\t\tsurface.resize(size); rep(i, size) surface[i] = i;\n\t\tbase.resize(size); rep(i, size) base[i] = i;\n\t\tnode.resize(size); rep(i, size) node[i] = { i, i, i };\n\n\t\touter_vertices = Queue(N);\n\t\tinner_vertices.resize(N + 1); inner_vertices_size = 0;\n\t\touter_blossoms.resize(B); outer_blossom_size = 0;\n\t\tinner_blossoms.resize(B); inner_blossom_size = 0;\n\n\t\ttree_label.assign(size, UNUSED);\n\n\t\tnext_bid.resize(B);\n\t\trep(i, B) next_bid[i] = size - 1 - i;\n\n\t\tmerged_edges.resize(N + 1); merged_edge_size = 0;\n\t\tbest_cost.assign(size, { INF, UNDEFINED });\n\n\t\tneighbors.resize(N + 1); neighbor_size = 0;\n\t\tbest_edge.assign(size, UNDEFINED);\n\n\t\tblist_head.assign(size, -1);\n\t\tnext_bnode.resize(edges.size());\n\t\trep(i, edges.size()) next_bnode[i] = edges.size() - 1 - i;\n\n\t\tbnode.resize(edges.size());\n\t}\n\nprivate:\n\tint N, B, size;\n\tvector<Edge> edges;\n\tvector<int> offsets;\n\n\tvector<Label> label;\n\tvector<int> mate, surface, base;\n\tvector<Node> node;\n\tvector<weight_t> potential;\n\n\tvector<int> next_bid;\n\n\tvector<i8> tree_label;\n\n\tQueue outer_vertices;\n\tvector<int> inner_vertices; int inner_vertices_size;\n\tvector<int> outer_blossoms; int outer_blossom_size;\n\tvector<int> inner_blossoms; int inner_blossom_size;\n\n\tvector<int> merged_edges; int merged_edge_size;\n\tvector< pair<weight_t, int> > best_cost;\n\tvector<int> neighbors; int neighbor_size;\n\tvector<int> best_edge;\n\n\tvector<int> blist_head;\n\tvector<LinkedList> bnode;\n\tvector<int> next_bnode;\n};\n\nbool isprime(int s){\n\tfor (int i = 2; i*i <= s; i++) {\n\t\tif (s % i == 0) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\nint cntp(int a, int b) {\n\tint s = abs(b - a);\n\tif (s % 2 == 0) return 2;\n\tif (s == 1) return 3;\n\tif (isprime(s)) {\n\t\t\n\t\treturn 1;\n\t}\n\telse {\n\t\treturn 3;\n\t}\n}\nsigned main() {\n\tint N;\n\tcin >> N;\n\tvector<int> a(N);\n\tvector<vector<int> > res;;\n\tfor (int i = 0; i < N; i++) {\n\t\tcin >> a[i];\n\t}\n\tvector<int> k;\n\tint st = -1;\n\tfor (int i = 0; i < N; i++) {\n\t\tif ((i < N - 1) && (a[i] + 1 == a[i + 1])) {\n\t\t\tif (st == -1) {\n\t\t\t\tst = a[i];\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (st == -1) st = a[i];\n\t\tk.push_back(st);\n\t\tk.push_back(a[i] + 1);\n\t\tst = -1;\n\t}\n\t\n\tint p = k.size();\n\tres.resize(p);\n\tfor (int i = 0; i < p; i++) {\n\t\t//cerr << k[i] << endl;\n\t\tres[i].resize(p);\n\t}\n\tint t;\n\t\n\tusing Edge = MaximumWeightedMatching<int>::Edge;\n\t\n\tvector<Edge> edges;\n\tfor (int i = 1; i < p; i++) {\n\t\tfor (int j = 0; j < i; j++) {\n\t\t\tt = cntp(k[i], k[j]);\n\t\t\tedges.push_back({ i + 1, j + 1, 3-t });\t\n\t\t\t//cerr << i << \" \" << j << \" \" << t << endl;\n\t\t}\n\t}\n\tauto MWM = MaximumWeightedMatching<int>(p, edges);\n\tauto ans = MWM.maximum_weighted_matching();\n\tcout << (3*(p/2)-ans) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntypedef vector<int> vi;\n\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fi first\n#define se second\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define ALL(c) (c).begin(),(c).end()\n\n//bipartite matching\nconst int MAX_V = 210;\n\nint V; \nvector<int> g[MAX_V];\nint match[MAX_V];\nbool used[MAX_V];\n\ninline void add_edge(int u, int v)\n{\n\tg[u].push_back(v);\n\tg[v].push_back(u);\n}\n\nbool dfs(int v)\n{\n\tused[v] = true;\n\n\tfor (int u : g[v]) {\n\t\tint w = match[u];\n\t\tif (w < 0 || (!used[w] && dfs(w))) {\n\t\t\tmatch[v] = u;\n\t\t\tmatch[u] = v;\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\nint bipartite_matching()\n{\n\tint res = 0;\n\tmemset(match, -1, sizeof(match));\n\n\tfor (int v = 0; v < V; ++v) {\n\t\tif (match[v] < 0) {\n\t\t\tmemset(used, 0, sizeof(used));\n\t\t\tres += dfs(v);\n\t\t}\n\t}\n\n\treturn res;\n}\n\nconst int MX = 10000010;\nbool pr[MX];\nbool e[MX];\n\nint main() {\n\tpr[0] = pr[1] = 1;\n\tfor (int i = 2; i < MX; ++i) {\n\t\tif (!pr[i]) {\n\t\t\tfor (int j = i * 2; j < MX; j += i) {\n\t\t\t\tpr[j] = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tint N; cin >> N;\n\tvi x(N);\n\trep(i, N) {\n\t\tcin >> x[i];\n\t\te[x[i]] = 1;\n\t}\n\n\tvi vx;\n\trep(i, MX-1) {\n\t\tif (e[i] != e[i+1]) {\n\t\t\tvx.pb(i);\n\t\t}\n\t}\n\n\tvi vl, vr;\n\n\tV = vx.size();\n\n\trep(i, V) {\n\t\tif (vx[i] & 1) {\n\t\t\tvl.pb(vx[i]);\n\t\t} else {\n\t\t\tvr.pb(vx[i]);\n\t\t}\n\t}\n\n\trep(i, vl.size()) {\n\t\trep(j, vr.size()) {\n\t\t\tint t = abs(vl[i] - vr[j]);\n\t\t\tif (!pr[t]) {\n\t\t\t\tadd_edge(i, vl.size() + j);\n\t\t\t}\n\t\t}\n\t}\n\n\tint t = bipartite_matching();\n\tint nl = vl.size() - t, nr = vr.size() - t;\n\tint ans = t;\n\tint d = nl / 2;\n\tans += d * 2;\n\tnl -= d * 2;\n\td = nr / 2;\n\tans += d * 2;\n\tnr -= d * 2;\n\tans += 3 * nl;\n\n\tcout << ans << endl;\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nstruct edge{\n  long to,cap,rev;//capは残りどれだけ流せるか, revはv[to][rev]が自分への逆辺を表す\n  edge(){}\n  edge(long t,long c,long r):to(t),cap(c),rev(r){}\n};\nclass flow{\n  long n;\n  vector<vector<edge>>v;\n  vector<bool>used;\n  public:\n  \n  long dfs(long s,long t,long f){\n    if(s==t)return f;\n    used[s]=1;\n    for(long i=0;i<v[s].size();i++){\n      edge e=v[s][i];\n      if(!used[e.to]&&e.cap>0){\n        long r=dfs(e.to,t,min(f,e.cap));\n        if(r>0){\n          v[s][i].cap-=r;v[e.to][e.rev].cap+=r;\n          return r;\n        }\n      }\n    }\n    return 0;\n  }\n  long solve(long s,long t){//最大流を求める\n    long ans=0;\n    while(1){\n      used.clear();used=vector<bool>(n,0);\n      long f=dfs(s,t,LONG_MAX);\n      if(f==0)return ans;\n      else ans+=f;\n    }\n  }\n  flow(){}\n  flow(const vector<vector<edge>>&v_)\n    :n(v_.size()),v(vector<vector<edge>>(v_.size())){\n      for(long i=0;i<n;i++)for(long j=0;j<v_[i].size();j++){\n        edge e=v_[i][j];\n        v[i].push_back(edge(e.to,e.cap,v[e.to].size()));//辺の追加\n        v[e.to].push_back(edge(i,0,v[i].size()-1));//逆辺の追加\n      }\n    }\n};\n\nint main(){\n  //素数前処理\n  long M=10000001;\n  vector<bool>prime(M,1);prime[0]=0,prime[1]=0;\n  for(long i=2;i<=M;i++){\n    if(prime[i]){\n      for(long j=2;i*j<=M;j++)prime[i*j]=0;\n    }\n  }\n  \n  long N;cin>>N;\n  vector<long>X(N);for(long i=0;i<N;i++)cin>>X[i];\n  vector<long>O,E;\n  for(long i=0;i<N;i++){\n    if(i==0||X[i]-1!=X[i-1]){if(X[i]%2)O.push_back(X[i]);else E.push_back(X[i]);}\n    if(i==N-1||X[i]+1!=X[i+1]){if((X[i]+1)%2)O.push_back(X[i]+1);else E.push_back(X[i]+1);}\n  }\n  \n  vector<vector<edge>>A(2+O.size()+E.size());\n  for(long i=0;i<O.size();i++)A[0].push_back(edge(1+i,LONG_MAX,0));\n  for(long i=0;i<E.size();i++)A[1+O.size()+i].push_back(edge(1+O.size()+E.size(),LONG_MAX,0));\n  for(long i=0;i<O.size();i++)for(long j=0;j<E.size();j++){\n    long d=abs(O[i]-E[j]);\n    if(prime[d])A[1+i].push_back(edge(1+O.size()+j,1,0));\n  }\n  flow f(A);long k=f.solve(0,1+O.size()+E.size());\n  long ans=k+2*((O.size()-k)/2)+2*((E.size()-k)/2)+3*((O.size()-k)%2);\n  cout<<ans;\n}\n\n/*\n*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstruct hopcroft{\n\tvector<int> dist, pair_l, pair_r;\n\tvector<bool> seen;\n\tvector<vector<int>> to;\n\tint n1, n2;\n\thopcroft(int n1, int n2) : n1(n1), n2(n2){\n\t\tto.resize(n1);\n\t\tpair_l.assign(n1, -1);\n\t\tpair_r.assign(n2, -1);\n\t\tdist.resize(n1);\n\t\tseen.resize(n1);\n\t}\n\tvoid add_edge(int u, int v){\n\t\tto[u].push_back(v);\n\t}\n\tbool bfs(){\n\t\tfill(dist.begin(), dist.end(), -1);\n\t\tqueue<int> q;\n\t\tfor (int i = 0; i < n1; i++){\n\t\t\tif (pair_l[i] == -1){\n\t\t\t\tdist[i] = 0;\n\t\t\t\tq.push(i);\n\t\t\t}\n\t\t}\n\t\tbool reach_minus = false;\n\t\twhile (!q.empty()){\n\t\t\tint u = q.front();\n\t\t\tq.pop();\n\t\t\tfor (int adj : to[u]){\n\t\t\t\tint radj = pair_r[adj];\n\t\t\t\tif (radj == -1){\n\t\t\t\t\treach_minus = true;\n\t\t\t\t} else if (dist[radj] == -1){\n\t\t\t\t\tdist[radj] = dist[u] + 1;\n\t\t\t\t\tq.push(radj);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn reach_minus;\n\t}\n\tbool dfs(int u){\n\t\tseen[u] = true;\n\t\tfor (int adj : to[u]){\n\t\t\tint radj = pair_r[adj];\n\t\t\tif (radj == -1 || (!seen[radj] && dist[radj] == dist[u] + 1 && dfs(radj))){\n\t\t\t\tpair_l[u] = adj;\n\t\t\t\tpair_r[adj] = u;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\tint max_matching(){\n\t\tint res = 0;\n\t\twhile (bfs()){\n\t\t\tfill(seen.begin(), seen.end(), false);\n\t\t\tfor (int i = 0; i < n1; i++)\n\t\t\t\tif (dfs(i))\n\t\t\t\t\tres++;\n\t\t}\n\t\treturn res;\n\t}\n};\nconst int lim = 10000002;\nbool prime[lim];\nvoid init(){\n\tmemset(prime, true, sizeof(prime));\n\tprime[0] = prime[1] = false;\n\tfor(int i = 2; i < lim; i++){\n\t\tif(prime[i]){\n\t\t\tfor(int j = i + i; j < lim; j += i)\n\t\t\t\tprime[j] = false;\n\t\t}\t\n\t}\n}\nint main(){\n\tinit();\n\tint n; cin >> n;\n\tbitset<lim> b;\n\tfor(int i = 0; i < n; i++){\n\t\tint x; cin >> x;\n\t\tb[x] = 1;\n\t}\n\tvector<int> p[2];\n\tfor(int i = 1; i < lim; i++){\n\t\tif(b[i] != b[i - 1]){\n\t\t\tp[i%2].push_back(i);\n\t\t}\n\t}\n\tint l0 = p[0].size(), l1 = p[1].size();\n\thopcroft ho(l0, l1);\n\tassert((l0 + l1) % 2 == 0);\n\tfor(int i = 0; i < l0; i++){\n\t\tfor(int j = 0; j < l1; j++){\n\t\t\tif(prime[abs(p[0][i] - p[1][j])]){\n\t\t\t\tho.add_edge(i, j);\n\t\t\t}\n\t\t}\n\t}\n\tint fl = ho.max_matching();\n\tint ans = fl + ((l0 - fl) / 2) * 2 + ((l1 - fl)/2) * 2 + ((l0 - fl) % 2) * 3;\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//\n//  main.cpp\n//  F - Prime Flip\n//\n//  Created by Jędrzej Dudzicz on 04/02/2019.\n//  Copyright © 2019 Jędrzej Dudzicz. All rights reserved.\n//\n\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <algorithm>\n#include <cstdio>\n#include <utility>\nusing namespace std;\nconst int MXN=205;\nconst int MXM=1e7+5;\nint n,x;\nint s[MXM],s1[MXN];\nbool sito[MXM];\nint tab1[2*MXN],h;\nbool odw[2*MXN];\nint wynik;\nint main(){\n    for(int i=2;i*i<=MXM-1;i++){\n        if(sito[i]==0){\n            for(int j=i*i;j<=MXM-1;j+=i){\n                if(sito[j]==0)sito[j]=1;\n            }\n        }\n    }\n    sito[0]=1;\n    sito[1]=1;\n    scanf(\"%d\",&n);\n    for(int i=0;i<n;i++){\n        scanf(\"%d\",&x);\n        s[x]=1;\n    }\n    for(int i=1;i<=10000001;i++){\n        if(s[i]!=s[i-1]){\n            s1[i]=1;\n            tab1[h++]=i;\n        }\n    }\n    for(int i=0;i<h;i++){\n        if(odw[i]==0){\n            for(int j=0;j<h;j++){\n                if(i!=j&&odw[j]==0&&abs(tab1[j]-tab1[i])>=2&&sito[abs(tab1[j]-tab1[i])]==0){\n                    wynik++;\n                    odw[i]=1;odw[j]=1;\n                    //printf(\"%d %d\\n\",tab1[i],tab1[j]);\n                    break;\n                }\n            }\n        }\n    }\n    for(int i=0;i<h;i++){\n        if(odw[i]==0){\n            for(int j=0;j<h;j++){\n                if(i!=j&&odw[j]==0&&abs(tab1[j]-tab1[i])%2==0){\n                    wynik+=2;\n                    odw[i]=1;odw[j]=1;\n                    break;\n                }\n            }\n        }\n    }\n    for(int i=0;i<h;i++){\n        if(odw[i]==0){\n            for(int j=0;j<h;j++){\n                if(i!=j&&odw[j]==0&&abs(tab1[j]-tab1[i])%2==1){\n                    wynik+=3;\n                    odw[i]=1;odw[j]=1;\n                    break;\n                }\n            }\n        }\n    }\n    for(int i=0;i<h;i++){\n        if(odw[i]==0){\n            odw[i]=1;\n            wynik+=3;\n        }\n    }\n    printf(\"%d\\n\",wynik);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define INF 0x7fffffff\nusing namespace std;\n\nstruct Edge{int to,capa,flow,next;} e[10500];\nint h[210],sum=-1,s,t;\nbool vis[210];\nint d[210],cur[210];\n\nvoid AddEdge(int u,int v,int w)\n{\n\te[++sum].to=v;\n\te[sum].flow=0;\n\te[sum].capa=w;\n\te[sum].next=h[u];\n\th[u]=sum;\n}\n\nvoid add_edge(int u,int v,int w)\n{\n\tAddEdge(u,v,w);\n\tAddEdge(v,u,0);\n}\n\nbool BFS()\n{\n\tmemset(vis,0,sizeof(vis));\n\tqueue<int> q;\n\tq.push(s);\n\td[s]=0;vis[s]=1;\n\twhile(!q.empty())\n\t{\n\t\tint u=q.front();\n\t\tfor(int tmp=h[u];~tmp;tmp=e[tmp].next)\n\t\t\tif(e[tmp].capa>e[tmp].flow&&!vis[e[tmp].to])\n\t\t\t{\n\t\t\t\tvis[e[tmp].to]=1;\n\t\t\t\td[e[tmp].to]=d[u]+1;\n\t\t\t\tq.push(e[tmp].to);\n\t\t\t}\n\t\tq.pop();\n\t}\n\treturn vis[t];\n}\n\nint DFS(int u,int a)\n{\n\tif(u==t||a==0) return a;\n\tint f,flow=0;\n\tfor(int& tmp=cur[u];~tmp;tmp=e[tmp].next)\n\t\tif(d[e[tmp].to]==d[u]+1)\n\t\t{\n\t\t\tf=DFS(e[tmp].to,min(a,e[tmp].capa-e[tmp].flow));\n\t\t\tif(f>0)\n\t\t\t{\n\t\t\t\tflow+=f;a-=f;\n\t\t\t\te[tmp].flow+=f;\n\t\t\t\te[tmp^1].flow-=f;\n\t\t\t\tif(a==0) break;\n\t\t\t}\n\t\t}\n\treturn flow;\n}\n\nint Maxflow()\n{\n\tint flow=0;\n\twhile(BFS())\n\t{\n\t\tfor(int i=s;i<=t;i++) cur[i]=h[i];\n\t\tflow+=DFS(s,INF);\n\t}\n\treturn flow;\n}\n\nconst int N=10000000;\nint lft[110],rht[110],num=0;\nbool up[N+10];\n\nint Pow(int a,int b,int p)\n{\n\tint ans=1;\n\tfor(;b;b>>=1,a=1ll*a*a%p)\n\t\tif(b&1) ans=1ll*ans*a%p;\n\treturn ans;\n}\n\nbool isprime(int n)\n{\n\tif(n==2) return true;\n\tif(n<2||!(n&1)) return false;\n\tint t=0;\n\tint a,x,y,u=n-1;\n\twhile(!(u&1)) t++,u>>=1;\n\tfor(int i=0;i<10;i++)\n\t{\n\t\ta=rand()%(n-1)+1;\n\t\tx=Pow(a,u,n);\n\t\tfor(int j=0;j<t;j++,x=y)\n\t\t{\n\t\t\ty=1ll*x*x%n;\n\t\t\tif(y==1&&x!=1&&x!=n-1) return false;\n\t\t}\n\t\tif (x!=1) return false;\n\t}\n\treturn true;\n}\n\nint main()\n{\n\tint n,x;\n\tscanf(\"%d\",&n);\n\tmemset(h,-1,sizeof(h));\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%d\",&x);\n\t\tup[x]=1;\n\t}\n\tint l=0,r=0;\n\tfor(int i=1;i<=N+1;i++)\n\t\tif(up[i]!=up[i-1])\n\t\t{\n\t\t\tif(i&1) lft[++l]=i;\n\t\t\telse rht[++r]=i;\n\t\t}\n\ts=0;t=l+r+1;\n\tfor(int i=1;i<=l;i++) add_edge(s,i,1);\n\tfor(int i=1;i<=r;i++) add_edge(l+i,t,1);\n\tfor(int i=1;i<=l;i++)\n\t\tfor(int j=1;j<=r;j++)\n\t\t\tif(isprime(abs(lft[i]-rht[j])))\n\t\t\t\tadd_edge(i,j+l,1);\n\tint falun=Maxflow(),dafa=falun;\n\tif(l>falun) dafa+=(l-falun)/2*2;\n\tif(r>falun) dafa+=(r-falun)/2*2;\n\tif((l-falun)&1) dafa+=3;\n\tprintf(\"%d\\n\",dafa);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<set>\n#include<map>\n#include<deque>\n#include<queue>\n#include<stack>\n#include<cmath>\n#include<ctime>\n#include<bitset>\n#include<string>\n#include<vector>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<climits>\n#include<complex>\n#include<iostream>\n#include<algorithm>\n#define ll long long\nusing namespace std;\n\nconst int maxn = 1e7+10;\nconst int maxm = 210;\n\nint p[4100000],pri;\nbool v[maxn];\n\nvoid pre()\n{\n\tfor(int i=2;i<maxn;i++)\n\t{\n\t\tif(!v[i]) p[++pri]=i;\n\t\tfor(int j=1,k=i*p[j];j<=pri;j++,k=i*p[j])\n\t\t{\n\t\t\tif(k>=maxn) break;\n\t\t\tv[k]=true;\n\t\t\tif(i%p[j]==0) break;\n\t\t}\n\t}v[1]=v[2]=true;\n}\n\nint n,m;\nint a[maxm],b[maxm];\nbool s[maxn];\nint p1[maxm],p2[maxm];\nint p1n,p2n;\n\nbool mp[maxm][maxm],ev[maxm];\nint match[maxm],bel[maxm];\nbool Find(const int x)\n{\n\tif(ev[x]) return false;\n\tev[x]=true;\n\tfor(int i=1;i<=p2n;i++) if(mp[x][i])\n\t{\n\t\tif(!bel[i]||Find(bel[i])) { bel[i]=x; return true; }\n\t}\n\treturn false;\n}\n\nint main()\n{\n\tpre();\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++) scanf(\"%d\",&a[i]),s[a[i]]=true;\n\tfor(int i=1;i<maxn;i++)\n\t\tif(s[i]!=s[i-1]) b[++m]=i;\n\t\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tif(b[i]&1) p1[++p1n]=b[i];\n\t\telse p2[++p2n]=b[i];\n\t}\n\tfor(int i=1;i<=p1n;i++)\n\t{\n\t\tfor(int j=1;j<=p2n;j++) if(!v[abs(p1[i]-p2[j])]) mp[i][j]=true;\n\t}\n\tint k=0;\n\tfor(int i=1;i<=p1n;i++) if(!match[i])\n\t{\n\t\tfor(int j=1;j<=p1n;j++) ev[j]=false;\n\t\tif(Find(i)) k++;\n\t}\n\tp1n-=k; p2n-=k;\n\tint re=k;\n\tre+=p1n/2*2+p2n/2*2;\n\tre+=p1n%2*3;\n\tprintf(\"%d\\n\",re);\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <queue>\n#include <set> \n#include <string>\n#include <string.h>\n#include <stdio.h> \n#include <stack>\n#define rep(N) for(int i=0;i<N;i++)\n#define repj(N) for(int j=0;j<N;j++)\n#define ll long long\n#define pii pair<int,int>\nusing namespace std;\n\nint main()\n{\n\tcout<<3<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<string.h>\n\n#ifdef LOCAL\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n#define NDEBUG\n#define eprintf(...) do {} while (0)\n#endif\n#include<cassert>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef vector<int> VI;\n\n#define REP(i,n) for(int i=0, i##_len=(n); i<i##_len; ++i)\n#define EACH(i,c) for(__typeof((c).begin()) i=(c).begin(),i##_end=(c).end();i!=i##_end;++i)\n\ntemplate<class T> inline void amin(T &x, const T &y) { if (y<x) x=y; }\ntemplate<class T> inline void amax(T &x, const T &y) { if (x<y) x=y; }\ntemplate<class Iter> void rprintf(const char *fmt, Iter begin, Iter end) {\n    for (bool sp=0; begin!=end; ++begin) { if (sp) putchar(' '); else sp = true; printf(fmt, *begin); }\n    putchar('\\n');\n}\n\nconst int MAX = 10000000;\nint min_factor[MAX+1];\nvector<int>prime;\nvoid make_prime() {\n    for (int i=2; i<=MAX; i+=2) min_factor[i] = 2;\n    for (int i=3; i<=MAX; i+=3) if (!min_factor[i]) min_factor[i] = 3;\n    for (int i=5, d=2; i*i<=MAX; ) {\n\tif (!min_factor[i]) {\n\t    min_factor[i] = i;\n\t    for (int j=i*i; j<=MAX; j+=i)\n\t\tif (!min_factor[j]) min_factor[j] = i;\n\t}\n\ti += d; d = 6 - d;\n    }\n    for (int i=2; i<=MAX; i++) {\n\tif (min_factor[i]==0) min_factor[i] = i;\n\tif (min_factor[i]==i) prime.push_back(i);\n    }\n}\nbool is_prime(LL n) {\n    if (n<=MAX) return min_factor[n] == n;\n    for (int i=0; (LL)prime[i]*prime[i]<=n; i++)\n\tif (n%prime[i]==0) return false;\n    return true;\n}\n\n\n\nstruct Matching2 { // for bipartite graph\n    vector<int>matchM, matchW, use;\n    int ans;\n    bool dfs(const VI G[], int v) {\n\tif (use[v]) return false;\n\tuse[v] = true;\n\tfor (int i=0; i<(int)G[v].size(); i++) {\n\t    int u = G[v][i];\n\t    if (matchW[u] == -1 || dfs(G, matchW[u])) {\n\t\tmatchM[v] = u;\n\t\tmatchW[u] = v;\n\t\treturn true;\n\t    }\n\t}\n\treturn false;\n    }\n    Matching2(const VI G[], int sizeM, int sizeW): matchM(sizeM, -1), matchW(sizeW, -1), ans(0) {\n\tuse = vector<int>(sizeM, 0);\n\tfor (int i=0; i<sizeM; i++) {\n\t    fill(use.begin(), use.end(), 0);\n\t    if (dfs(G, i)) ans++;\n\t}\n    }\n};\n\nint N;\nint X[111];\nVI G[211];\n\nvoid MAIN() {\n    make_prime();\n    scanf(\"%d\", &N);\n    REP (i, N) scanf(\"%d\", X+i);\n\n    VI S;\n    REP (i, N) {\n\tif (i == 0 || X[i-1] + 1 < X[i]) {\n\t    S.push_back(X[i]);\n\t}\n\tif (i == N-1 || X[i] + 1 < X[i+1]) {\n\t    S.push_back(X[i]+1);\n\t}\n    }\n    VI E, O;\n    EACH (e, S) {\n\tif (*e & 1) O.push_back(*e);\n\telse E.push_back(*e);\n    }\n\n    REP (i, O.size()) REP (j, E.size()) if (abs(O[i] - E[j]) > 2 && is_prime(abs(O[i] - E[j]))) {\n\tG[i].push_back(j);\n    }\n    Matching2 M(G, O.size(), E.size());\n\n    int ans;\n    if ((O.size() ^ M.ans) & 1) {\n\tans = E.size() + O.size() - M.ans + 1;\n    } else {\n\tans = E.size() + O.size() - M.ans;\n    }\n\n    printf(\"%d\\n\", ans);\n}\n\nint main() {\n    int TC = 1;\n//    scanf(\"%d\", &TC);\n    REP (tc, TC) MAIN();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int maxn = 220;\nconst int maxx = 11000000;\n\nint x[maxn];\nvector<int> pos;\nbool nprm[maxx] = {true, true};\nvector<int> g[maxn];\nvector<int> x1, x2;\nbool vis[maxn];\nint link[maxn];\n\ninline bool dfs(int u) {\n\tif(vis[u]) return false;\n\tvis[u] = true;\n\tfor(auto v : g[u]) {\n\t\tif(link[v] == -1 || dfs(link[v])) {\n\t\t\tlink[v] = u;\n\t\t\tlink[u] = v;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\ninline void init() {\n\tfor(int i = 2; i * i < maxx; ++ i) if(!nprm[i])\n\t\tfor(int j = i + i; j < maxx; j += i) nprm[j] = true;\n}\n\nint main() {\n\tios::sync_with_stdio(0);\n\tcin.tie(0); cout.tie(0);\n\tinit();\n\tint n; cin >> n;\n\tfor(int i = 1; i <= n; ++ i) cin >> x[i];\n\tpos.push_back(x[1]);\n\tfor(int i = 2; i <= n; ++ i) {\n\t\tif(x[i] == x[i - 1] + 1) continue;\n\t\tpos.push_back(x[i - 1] + 1); pos.push_back(x[i]);\n\t}\n\tpos.push_back(x[n] + 1);\n\tint sz = pos.size();\n\tfor(int i = 0; i < sz; ++ i) if(pos[i] & 1) x1.push_back(i); else x2.push_back(i);\n\tfor(auto i : x1) for(auto j : x2) if(i < j && !nprm[pos[j] - pos[i]]) g[i].push_back(j);\n\tmemset(link, 0xff, sizeof link);\n\tint mx = 0;\n\tfor(auto i : x1) {\n\t\tmemset(vis, false, sizeof vis);\n\t\tif(dfs(i)) ++ mx;\n\t}\n\tint ans = mx;\n\tint c1 = (x1.size() - mx) / 2, l1 = (x1.size() - mx) & 1;\n\tint c2 = (x2.size() - mx) / 2, l2 = (x2.size() - mx) & 1;\n\tif(l1 && l2) {\n\t\tans += 3;\n\t\tl1 = l2 = 0;\n\t}\n\tans += c1 * 2 + l1 * 3;\n\tans += c2 * 2 + l2 * 3;\n\tcout << ans << \"\\n\";\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <algorithm>\n#include <queue>\n#include <vector>\n#include <stack>\n#include <cmath>\n#include <memory.h>\n#include <iomanip>\nusing namespace std;\n\n#define maxn 202\n#define FOR(i, l, r) for (int i=l; i<=r; ++i)\n#define FORD(i, r, l) for (int i=r; i>=l; --i)\n#define REP(i, r) for (int i=0; i<(int)r; ++i)\n#define REPD(i, r) for (int i=(int)r-1; i>=0; --i)\n#define fi first\n#define se second\n#define mk make_pair\n#define nil NULL\n#define y0 y902\n#define y1 y232\n#define x0 x92\n#define x1 x899\n#define next asdfa\n#define sz size\n#define Debug(X) {cerr << #X << \" = \" << X << '\\n';}\n#define PR(A, n) {cerr << #A << \" = \"; FOR(i, 1, n) cerr << A[i] << ' '; cerr << '\\n';}\n#define PR0(A, n) {cerr << #A << \" = \"; REP(i, n) cerr << A[i] << ' '; cerr << '\\n';}\ntypedef long long ll;\ntypedef double db;\ntypedef pair<db, db> dd;\ntypedef pair<int, int> ii;\ntypedef vector<int> vi;\nconst int inf = 1e9;\ntemplate<class T> int getbit(T x, int pos) {return (x>>(pos-1)) & 1;}\ntemplate<class T> void turn_on(T &x, int pos) {x = x | ((T)1<<(pos-1));}\ntemplate<class T> void turn_off(T &x, int pos) {x = x & ~((T)1<<(pos-1));}\ntemplate<class T> T sqr(T a) {return a*a;}\n\nint n, assigned[maxn], visited[maxn], t;\nvector<int> a[maxn], even, odd;\n\nint visit(int u) {\n    if (visited[u]!=t) visited[u] = t;\n    else return 0;\n    REP(i, a[u].sz()) {\n        int v = a[u][i];\n        if (!assigned[v] || visit(assigned[v])) {\n            assigned[v] = u;\n            return 1;\n        }\n    }\n    return 0;\n}\n\nint findMaximumMatching() {\n    int cnt = 0;\n    REP(i, even.sz()) {\n        ++t;\n        cnt += visit(i);\n    }\n    return cnt;\n}\n\nbool isPrime(int a) {       ///notice that function will return false if a=2\n    if (a<=2) return false;\n    FOR(i, 2, sqrt(a)) {\n        if (a%i==0) return false;\n    }\n    return true;\n}\n\nint main() {\n    //freopen(\"prflip.inp\", \"r\", stdin);\n    //freopen(\"prflip.ans\", \"w\", stdout);\n    //ios::sync_with_stdio(0); cin.tie(0);\n    scanf(\"%d\", &n);\n    int prev = -1;\n    FOR(i, 1, n) {\n        int x; scanf(\"%d\", &x);\n        if (x!=prev+1) {\n            if (prev!=-1 && (prev+1)%2==0) even.push_back(prev+1);\n            else if (prev!=-1) odd.push_back(prev+1);\n            if (x%2==0) even.push_back(x);\n            else odd.push_back(x);\n        }\n        prev = x;\n    }\n    if ((prev+1)%2==0) even.push_back(prev+1);\n    else odd.push_back(prev+1);\n    REP(i, even.sz()) REP(j, odd.sz()) {\n        if (isPrime(abs(even[i]-odd[j])))\n            a[i].push_back(j);\n    }\n    int k = findMaximumMatching(), res = inf;\n    FOR(i, 0, k) {\n        if (((int)even.sz()-k)%2==0) res = min(res, k+((int)even.sz()-k)+((int)odd.sz()-k));\n        else res = min(res, k+((int)even.sz()-1-k)+((int)odd.sz()-1-k)+3);\n    }\n    printf(\"%d\", res);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ninline int read(){int x=0,f=1;char ch=getchar();while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}return x*f;}\n\nconst int maxn = 100 + 15;\nconst int Maxsz = 2e7;\nconst int inf = 1e9 + 7;\n\nint Prime[Maxsz + 1] , Primelen , Vis[Maxsz + 1] , Pf[Maxsz + 1] , Have[Maxsz + 5] , n , Used[maxn << 1] , Link[maxn];\nvector < int > odd , even , Edge[maxn << 1];\n\n\nvoid Init(){\n\tfor(int i = 2 ; i <= Maxsz ; ++ i){\n\t\tif( !Vis[i] )\n\t\t\tPrime[Primelen ++] = i;\n\t\tfor(int j = 0 ; j < Primelen && Prime[j] * i <= Maxsz ; ++ j){\n\t\t\tVis[i * Prime[j]] = 1;\n\t\t\tif( i % Prime[j] == 0 ) break;\n\t\t}\n\t}\n}\n\nbool Dfs( int x ){\n\tfor(auto && v : Edge[x]){\n\t\tif( Used[v] ) continue;\n\t\tUsed[v] = 1;\n\t\tif( Link[v] == -1 || Dfs( Link[v] ) ){\n\t\t\tLink[v] = x;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint main( int argc , char * argv[] ){\n\tInit();\n\tn = read();\n\tfor(int i = 1 ; i <= n ; ++ i){\n\t\tint x = read();\n\t\tHave[x] = 1;\n\t}\n\tfor(int i = 1 ; i <= Maxsz ; ++ i){\n\t\tif( Have[i] ^ Have[i - 1] ){\n\t\t\tif( i & 1 ) odd.emplace_back( i );\n\t\t\telse even.emplace_back( i );\n\t\t} \n\t}\n\tVis[1] = 1;\n\tfor(int i = 0 ; i < odd.size() ; ++ i)\n\t\tfor(int j = 0 ; j < even.size() ; ++ j)\n\t\t\tif( ( abs( odd[i] - even[j] ) & 1 ) && Vis[ abs( odd[i] - even[j] ) ] == 0 )\n\t\t\t\tEdge[i].emplace_back( j );\n\tmemset( Link , -1 , sizeof( Link ) );\n\tint K = 0;\n\tfor(int i = 0 ; i < odd.size() ; ++ i){\n\t\tmemset( Used , 0 , sizeof( Used ) );\n\t\tK += Dfs( i );\n\t}\n\tint ret = K + ( ( odd.size() - K ) / 2 + ( even.size() - K ) / 2 ) * 2 + ( odd.size() - K ) % 2 * 3;\n\tprintf( \"%d\\n\" , ret );\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<cstring>\n#include<map>\n#include<queue>\n#include<cmath>\nusing namespace std;\ntypedef long long ll;\nconst int N=5005,INF=~0u>>2;\nstruct Edge{int nxt,to;}edge[(N*N)<<3];\nint b[N<<1],n,head[N<<1],num_edge,vis[N<<1],lk[N<<1],even[N<<1],odd[N<<1],even_num,odd_num,ans,k,tot,tim;\nint read(){\n\tint x=0,f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-') f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn f*x;\n}\nvoid add_edge(int from,int to){\n\tedge[++num_edge].nxt=head[from];\n\tedge[num_edge].to=to;\n\thead[from]=num_edge;\n}\nbool find(int x){\n\tfor(int i=head[x];i;i=edge[i].nxt){\n\t\tif(vis[edge[i].to]!=tim){\n\t\t\tvis[edge[i].to]=tim;\n\t\t\tif(!lk[edge[i].to]||find(edge[i].to)){\n\t\t\t\tlk[edge[i].to]=x;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nbool check(int x){\n\tif(x==1) return 0;\n\tfor(int i=2;i*i<=x;++i){\n\t\tif(x%i==0) return 0;\n\t}\n\treturn 1;\n}\nint main(){\n//\tfreopen(\"ex.in\",\"r\",stdin);\n\tn=read();\n\tfor(int i=1;i<=n;++i) b[i]=read();b[0]=-1;\n\tfor(int i=1;i<=n;++i){\n\t\tif(b[i]!=b[i-1]+1){\n\t\t\tif(b[i]%2) odd[++odd_num]=b[i];\n\t\t\telse even[++even_num]=b[i];\n\t\t}\n\t\tif(b[i]+1!=b[i+1]){\n\t\t\tif((b[i]+1)%2) odd[++odd_num]=b[i]+1;\n\t\t\telse even[++even_num]=b[i]+1;\n\t\t}\n\t}\n\tfor(int i=1;i<=odd_num;++i){\n\t\tfor(int j=1;j<=even_num;++j){\n\t\t\tif(check(abs(even[j]-odd[i]))) add_edge(i,j+odd_num);\n\t\t}\n\t}\n\tfor(int i=1;i<=odd_num;++i){\n\t\ttim++;\n\t\tif(find(i)) k++;\n\t\telse break;\n\t}\n\tans=k+((even_num-k)/2+(odd_num-k)/2)*2+((even_num-k)%2)*3;\n\tprintf(\"%d\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <cstdio>\nconst int N = 205;\nconst int M = 1e7 + 5; \nusing namespace std;\n\nint lim = 10000001, n, path[N][N], l[N], r[N], cntl, cntr, vis[M], bl[N], prm[M], top, s[M]; \n\ntemplate < typename T >\ninline T read()\n{\n\tT x = 0, w = 1; char c = getchar();\n\twhile(c < '0' || c > '9') { if(c == '-') w = -1; c = getchar(); }\n\twhile(c >= '0' && c <= '9') x = x * 10 + c - '0', c = getchar();\n\treturn x * w; \n}\n\nbool dfs(int u)\n{\n\tfor(int i = 1; i <= cntr; i++)\n\t\tif(!vis[i] && path[u][i])\n\t\t{\n\t\t\tvis[i] = 1; \n\t\t\tif(!bl[i] || dfs(bl[i]))\n\t\t\t{\n\t\t\t\tbl[i] = u; return 1; \n\t\t\t}\n\t\t}\n\treturn 0; \n}\n\nint hungary()\n{\n\tint cnt = 0;\n\tfor(int i = 1; i <= cntl; i++)\n\t{\n\t\tfor(int j = 1; j <= max(cntl, cntr); j++) vis[j] = 0; \n\t\tif(dfs(i)) cnt++; \n\t}\n\treturn cnt; \n}\n\nvoid Euler()\n{\n\tvis[1] = 1; \n\tfor(int i = 2; i <= lim; i++)\n\t{\n\t\tif(!vis[i]) prm[++top] = i;\n\t\tfor(int j = 1; i * prm[j] <= lim; j++)\n\t\t{\n\t\t\tvis[i * prm[j]] = 1; \n\t\t\tif(i % prm[j] == 0) break; \n\t\t}\n\t}\n}\n\nint main()\n{\n#ifndef ONLINE_JUDGE\n\tfreopen(\"cpp.in\", \"r\", stdin); \n#endif\n\tEuler();\n\tn = read <int> ();\n\tfor(int x, i = 1; i <= n; i++) x = read <int> (), s[x] = 1;\n\tfor(int i = 1; i <= lim; i++)\n\t\tif(s[i] != s[i - 1])\n\t\t{\n\t\t\tif(i & 1) l[++cntl] = i; \n\t\t\telse r[++cntr] = i; \n\t\t}\n\tfor(int i = 1; i <= cntl; i++)\n\t\tfor(int j = 1; j <= cntr; j++)\n\t\t\tif(!vis[l[i] - r[j] > 0 ? l[i] - r[j] : r[j] - l[i]])\n\t\t\t\tpath[i][j] = 1; \n\tint tmp = hungary(), ans = tmp;\n\tcntl -= tmp, cntr -= tmp, ans += cntl / 2 * 2, cntl %= 2, ans += cntr / 2 * 2, cntr %= 2;\n\tif(cntl && cntr) ans += 3;\n\tprintf(\"%d\\n\", ans); \n\treturn 0; \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ninline int gi()\n{\n\tchar c = getchar();\n\twhile (c < '0' || c > '9') c = getchar();\n\tint sum = 0;\n\twhile ('0' <= c && c <= '9') sum = sum * 10 + c - 48, c = getchar();\n\treturn sum;\n}\n\nconst int maxn = 2005, maxp = 1e7 + 5;\n\nint n, m, x[maxn], p[maxn];\nint Vis[maxp];\n\nstruct edge\n{\n\tint to, next, cap;\n} e[maxn * maxn * 2];\nint h[maxn], cur[maxn], tot = 1, dis[maxn], s, t;\nbool vis[maxn];\n\ninline void add(int u, int v, int w)\n{\n\te[++tot] = (edge) {v, h[u], w}; h[u] = tot;\n\te[++tot] = (edge) {u, h[v], 0}; h[v] = tot;\n}\n\nvoid pre()\n{\n\tstatic int p[maxp], cnt;\n\tVis[1] = 1;\n\tfor (int i = 2; i <= 1e7; ++i) {\n\t\tif (!Vis[i]) p[++cnt] = i, Vis[i] = i;\n\t\tfor (int j = 1; j <= cnt && i * p[j] <= 1e7; ++j) {\n\t\t\tVis[i * p[j]] = p[j];\n\t\t\tif (p[j] >= Vis[i]) break;\n\t\t}\n\t}\n\tVis[2] = 1;\n\tfor (int i = 2; i <= 1e7; ++i)\n\t\tif (Vis[i] == i) Vis[i] = 0;\n}\n\nbool bfs()\n{\n\tstatic int u, l, r, q[maxn];\n\tl = 0; q[r = 1] = s; vis[s] = 1;\n\twhile (l < r) {\n\t\tu = q[++l];\n\t\tfor (int i = h[u], v; v = e[i].to, i; i = e[i].next)\n\t\t\tif (!vis[v] && e[i].cap) {\n\t\t\t\tvis[v] = 1; dis[v] = dis[u] + 1;\n\t\t\t\tq[++r] = v;\n\t\t\t}\n\t}\n\treturn vis[t];\n}\n\nint dfs(int u, int a)\n{\n\tif (u == t || !a) return a;\n\tint f = 0, flow = 0;\n\tfor (int &i = cur[u], v; v = e[i].to, i; i = e[i].next)\n\t\tif (dis[v] == dis[u] + 1 && (f = dfs(v, min(e[i].cap, a)))) {\n\t\t\te[i].cap -= f; e[i ^ 1].cap += f;\n\t\t\tflow += f; a -= f;\n\t\t\tif (!a) break;\n\t\t}\n\treturn flow;\n}\n\nint dinic()\n{\n\tint res = 0;\n\twhile (bfs()) {\n\t\tmemset(vis + 1, 0, sizeof(bool) * t);\n\t\tmemcpy(cur + 1, h + 1, sizeof(int) * t);\n\t\tres += dfs(s, 1e9);\n\t}\n\treturn res;\n}\n\nint main()\n{\n\tn = gi();\n\tfor (int i = 1; i <= n; ++i) x[i] = gi();\n\tsort(x + 1, x + n + 1);\n\n\tpre();\n\n\tfor (int i = 1, j; i <= n; i = j + 1) {\n\t\tj = i;\n\t\twhile (x[j + 1] == x[j] + 1) ++j;\n\t\tp[++m] = x[i]; p[++m] = x[j] + 1;\n\t}\n\n\ts = m + 1; t = s + 1;\n\tint odd = 0;\n\tfor (int i = 1; i <= m; ++i)\n\t\tif (p[i] & 1) add(s, i, 1), ++odd;\n\t\telse add(i, t, 1);\n\tfor (int i = 1; i <= m; ++i)\n\t\tif (p[i] & 1)\n\t\t\tfor (int j = 1; j <= m; ++j)\n\t\t\t\tif ((~p[j] & 1) && !Vis[abs(p[i] - p[j])])\n\t\t\t\t\tadd(i, j, 1);\n\n\tint ans = dinic();\n\tprintf(\"%d\\n\", ans + ((odd - ans) / 2 + (m - odd - ans) / 2) * 2 + ((odd - ans) & 1) * 3);\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define go(x, i) for(register int i = head[x]; i; i = nxt[i])\n#define For(i, a, b) for(register int i = a; i <= b; ++ i)\n#define SZ(x) int(x.size())\n\nusing namespace std;\n\nconst int maxn = 100 + 4, maxm = 1e7 + 10;\nint P[maxn], C[maxn], n, vis[maxm];\nint notprim[maxm], S[maxm];\nvector<int> num, prime;\n\nvoid Get_prime(int m)\n{\n\tnotprim[0] = notprim[1] = 1;\n\tFor(i, 2, m)\n\t{\n\t\tif(!notprim[i])\n\t\t\tprime.push_back(i);\n\t\tint len = prime.size();\n\t\tFor(j, 0, len - 1)\n\t\t{\n\t\t\tif(prime[j] * i > m)\n\t\t\t\tbreak;\n\t\t\tnotprim[prime[j] * i] = 1;\n\t\t\tif(i % prime[j] == 0)\n\t\t\t\tbreak;\n\t\t}\n\t}\n}\n\nnamespace Match\n{\n\tconst int N = 1e3 + 10;\n\tint to[N], head[N], nxt[N], e;\n\tint pre[N], vis[N], G[N], O[N], now, sum;\n\tvoid add(int x, int y)\n\t{\n\t\tto[++ e] = y;\n\t\tnxt[e] = head[x];\n\t\thead[x] = e;\n\t}\n\tbool dfs(int x)\n\t{\n\t\tgo(x, i)\n\t\t{\n\t\t\tif(vis[to[i]] != now)\n\t\t\t{\n\t\t\t\tvis[to[i]] = now;\n\t\t\t\tif(!pre[to[i]] || dfs(pre[to[i]]))\n\t\t\t\t{\n\t\t\t\t\tpre[to[i]] = x;\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tint match()\n\t{\n\t\tint res = 0;\n\t\tfor(now = 1; now <= G[0]; ++ now)\n\t\t\tres += dfs(now);\n\t\treturn res;\n\t}\n\tvoid solve()\n\t{\n\t\tint res = 0;\n\t\tFor(i, 0, SZ(num) - 1)\n\t\t\tif(num[i] & 1)\n\t\t\t\tG[++ G[0]] = num[i];\n\t\t\telse\n\t\t\t\tO[++ O[0]] = num[i];\n\t\tFor(i, 1, G[0])\n\t\t\tFor(j, 1, O[0])\n\t\t\t\tif(!notprim[abs(G[i] - O[j])])\n\t\t\t\t\tadd(i, j);\n\t\tres += match();\n\t\tmemset(vis, 0, sizeof(vis));\n\t\tG[0] -= res, O[0] -= res;\n\t\tres += G[0] / 2 * 2, G[0] %= 2;\n\t\tres += O[0] / 2 * 2, O[0] %= 2;\n\t\tif(G[0] * O[0])\n\t\t\tres += 3;\n\t\tcout << res << endl;\n\t}\n}\n\nint main()\n{\n//\tfreopen(\"magic.in\", \"r\", stdin);\n//\tfreopen(\"magic.out\", \"w\", stdout);\n\tGet_prime(1e7 + 5);\n\tscanf(\"%d\", &n);\n\tFor(i, 1, n)\n\t\tscanf(\"%d\", &P[i]), vis[P[i]] ^= 1;\n\tFor(i, 1, maxm - 1)\n\t\tif(vis[i] != vis[i - 1])\n\t\t\tnum.push_back(i);\n\tmemset(vis, 0, sizeof(vis));\n\tMatch::solve();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<iostream>\nusing namespace std;\nint prime[10000010],pr=0;\nbool vis[10000010];\nint m,s[10000010],last=0,n=0;\nint map[210][210],a[210],t1=0,b[210],t2=0,chw[210],match[210],tim=0;\nbool findma(int x)\n{\n\tfor(int i=1;i<=t2;i++)\n\t{\n\t\tif(chw[i]==tim||!map[x][i]) continue;\n\t\tchw[i]=tim;\n\t\tif(!match[i]||findma(match[i])) return match[i]=x,true;\n\t}\n\treturn false;\n}\nvoid pre()\n{\n\tmemset(vis,true,sizeof(vis));\n\tvis[1]=false;\n\tfor(int i=2;i<=10000000;i++)\n\t{\n\t\tif(vis[i]) prime[++pr]=i;\n\t\tfor(int j=1;j<=pr&&prime[j]*i<=10000000;j++)\n\t\t{\n\t\t\tvis[prime[j]*i]=false;\n\t\t\tif(i%prime[j]==0) break;\n\t\t}\n\t}\n}\nint main()\n{\n\tpre();\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint c;scanf(\"%d\",&c);\n\t\ts[c]=1;\n\t}\n\tfor(int i=1;i<=1e7+1;i++)\n\t\tif(s[i]!=s[i-1])\n\t\t{\n\t\t\t//printf(\"%d\\n\",i);\n\t\t\tif(i&1) a[++t1]=i;\n\t\t\telse b[++t2]=i;\n\t\t}\n\tfor (int i=1;i<=t1;i++)\n        for (int j=1;j<=t2;j++)\n            if (vis[abs(a[i]-b[j])]) map[i][j]=1;\n    int ans=0,tmp=0;\n    //printf(\"ok\\n\");\n    for(int i=1;i<=t1;i++)\n    {\n    \ttim++;\n    \tif(findma(i)) ans++,tmp++;\n\t}\n\t//printf(\"%d %d %d\\n\",tmp,t1,t2);\n\tans+=(t1-tmp)/2*2+(t2-tmp)/2*2;\n    if (t1%2!=tmp%2) ans+=3;\n    printf(\"%d\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include<queue>\n#include<iostream>\n#include<set>\n#include<vector>\n#include<algorithm>\n#include<map>\n#include<tuple>\n\nusing namespace std;\n\ntypedef pair<int,int> pii;\ntypedef tuple<int,int,int> t3;\ntypedef tuple<int,int,int,int> t4;\n\nconst int MX = 205;\n\nint D[MX];\nvector<int> L[MX];\nint R[MX];\nint vst[MX], t = 1;\n\nint dfs(int x){\n\tif( vst[x] == t ) return 0;\n\tfor(int c : L[x]){\n\t\tif( !R[c] || dfs(R[c])){\n\t\t\tR[c] = x;\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nint is_prime(int a){\n\tif( a < 0) a = -a;\n\tif( a == 1 ) return false;\n\tfor(int i = 2; i*i <= a; i++) if( a%i == 0 ) return false;\n\treturn true;\n}\n\nint main()\n{\n\tint N;\n\tscanf(\"%d\", &N);\n\tfor(int i = 1; i <= N; i++) scanf(\"%d\", D+i);\n\n\tint M = 1, E[MX] = {0, D[1]};\n\tfor(int i = 2; i <= N; i++){\n\t\tif( D[i-1] != D[i]-1){\n\t\t\tE[++M] = D[i-1]+1;\n\t\t\tE[++M] = D[i];\n\t\t}\n\t}\n\tE[++M] = D[N]+1;\n\n\tint a = 0, b = 0;\n\tfor(int i = 1; i <= M; i++){\n\t\tif( E[i]%2 == 0) a++;\n\t\telse b++;\n\t}\n\tfor(int i = 1; i <= M; i++){\n\t\tfor(int j = 1; j <= M; j++){\n\t\t\tif( E[i]%2 == 0 && E[j]%2 == 1 );\n\t\t\telse continue;\n\t\t\tif( is_prime(E[i] - E[j]) ) L[i].push_back(j);\n\t\t}\n\t}\n\tint ans = 0;\n\tfor(int i = 1; i <= M; i++){\n\t\tt++; if(dfs(i)) ans++, a--, b--;\n\t}\n\tans += (a/2 + b/2) * 2;\n\tif( a%2 == 1 ) ans += 3;\n\tprintf(\"%d\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define xx first\n#define yy second\n#define mp make_pair\n#define pb push_back\n#define mset(x, y) memset(x, y, sizeof x)\n#define mcpy(x, y) memcpy(x, y, sizeof x)\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair <int, int> pii;\n\ninline int Read()\n{\n\tint x = 0, f = 1, c = getchar();\n\tfor (; !isdigit(c); c = getchar())\n\t\tif (c == '-')\n\t\t\tf = -1;\n\tfor (;  isdigit(c); c = getchar())\n\t\tx = x * 10 + c - '0';\n\treturn x * f;\n}\n\nnamespace Flow\n{\n\tconst int MAXN = 205;\n\tconst int MAXM = 50005;\n\tconst int INF = 0x3f3f3f3f;\n\n\tstruct Edge\n\t{\n\t\tint p, v, w;\n\t} e[MAXM];\n\n\tint e_cnt, S, T, V, ql, qr, q[MAXN], hed[MAXN], dis[MAXN], cur[MAXN];\n\n\tinline void Init(int n)\n\t{\n\t\tV = n;\n\t\tfor (int i = 0; i < V; i ++)\n\t\t\thed[i] = 0;\n\t\te_cnt = 1;\n\t}\n\n\tinline void Addedge(int x, int y, int w)\n\t{\n\t\te[++ e_cnt] = {y, hed[x], w}; hed[x] = e_cnt;\n\t\te[++ e_cnt] = {x, hed[y], 0}; hed[y] = e_cnt;\n\t}\n\n\tinline bool Bfs()\n\t{\n\t\tfor (int i = 0; i < V; i ++)\n\t\t\tdis[i] = 0;\n\t\tdis[q[ql = 0] = S] = qr = 1;\n\t\twhile (ql ^ qr)\n\t\t{\n\t\t\tint x = q[ql ++];\n\t\t\tfor (int i = hed[x]; i; i = e[i].v)\n\t\t\t\tif (e[i].w && !dis[e[i].p])\n\t\t\t\t\tdis[q[qr ++] = e[i].p] = dis[x] + 1;\n\t\t}\n\t\treturn dis[T];\n\t}\n\n\tinline int Dfs(int x, int f)\n\t{\n\t\tif (x == T)\n\t\t\treturn f;\n\t\tint ret = 0, t = 0;\n\t\tfor (int &i = cur[x]; i; i = e[i].v)\n\t\t\tif (e[i].w && dis[e[i].p] == dis[x] + 1)\n\t\t\t{\n\t\t\t\tt = Dfs(e[i].p, min(f, e[i].w));\n\t\t\t\tf -= t; ret += t; e[i].w -= t; e[i ^ 1].w += t;\n\t\t\t\tif (!f)\n\t\t\t\t\treturn ret;\n\t\t\t}\n\t\treturn dis[x] = -1, ret;\n\t}\n\n\tinline int Dinic()\n\t{\n\t\tint ret = 0;\n\t\twhile (Bfs())\n\t\t{\n\t\t\tfor (int i = 0; i < V; i ++)\n\t\t\t\tcur[i] = hed[i];\n\t\t\tret += Dfs(S, INF);\n\t\t}\n\t\treturn ret;\n\t}\n}\n\nconst int MAXN = 10000005;\n\nint n, l, r, tp, p_cnt, a[105], st[205], p[MAXN];\nbool chk[MAXN];\n\ninline void Init(int n)\n{\n\tchk[1] = 1;\n\tfor (int i = 2; i <= n; i ++)\n\t{\n\t\tif (!chk[i])\n\t\t\tp[++ p_cnt] = i;\n\t\tfor (int j = 1; i * p[j] <= n; j ++)\n\t\t{\n\t\t\tchk[i * p[j]] = 1;\n\t\t\tif (i % p[j] == 0)\n\t\t\t\tbreak;\n\t\t}\n\t}\n}\n\nint main()\n{\n#ifdef wxh010910\n\tfreopen(\"data.in\", \"r\", stdin);\n#endif\n\tn = Read();\n\tfor (int i = 1; i <= n; i ++)\n\t\ta[i] = Read();\n\tfor (int l = 1, r = 1; l <= n; l = r)\n\t{\n\t\tfor (r ++; a[r] == a[r - 1] + 1; r ++);\n\t\tst[++ tp] = a[l], st[++ tp] = a[r - 1] + 1;\n\t}\n\tn = tp;\n\tFlow::Init(n + 2), Flow::T = n + 1;\n\tfor (int i = 1; i <= n; i ++)\n\t\tif (st[i] & 1)\n\t\t\tFlow::Addedge(0, i, 1), l ++;\n\t\telse\n\t\t\tFlow::Addedge(i, n + 1, 1), r ++;\n\tInit(st[n]);\n\tfor (int i = 1; i <= n; i ++)\n\t\tif (st[i] & 1)\n\t\t\tfor (int j = 1; j <= n; j ++)\n\t\t\t\tif (!(st[j] & 1))\n\t\t\t\t\tif (!chk[abs(st[j] - st[i])])\n\t\t\t\t\t\tFlow::Addedge(i, j, 1);\n\tint ret = Flow::Dinic(), ans = ret;\n\tl -= ret, r -= ret;\n\tif (l & 1)\n\t\tans += 3, l --, r --;\n\tans += l + r;\n\treturn printf(\"%d\\n\", ans), 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=3e3+11;\nconst int M=7e5+1;\nconst int MAXN=1e7+11;\nconst int inf=2147483647;\nint n,tot,cnt,t1,t2,mx,S,T,hd[M];\nint ans,pri[M],L[N<<1],R[N<<1];\nbitset<MAXN> is,a;\nstruct Edge{int nxt,to,val;}e[M];\nvoid ins(int x,int y,int z){\n    e[++cnt].nxt=hd[x];\n    e[cnt].to=y;hd[x]=cnt;\n    e[cnt].val=z;\n}\nvoid prepare(){\n    is[0]=is[1]=1;\n    for(int i=2;i<MAXN;i++){\n        if(!is[i]) pri[++tot]=i;\n        for(int j=1;j<=tot&&i*pri[j]<=MAXN;j++){\n            is[pri[j]*i]=1;\n            if(i%pri[j]==0) break;\n        }\n    }\n}\nnamespace Network_Flow{\n    queue<int> p;\n    int dep[N<<1];\n    int bfs(){\n        memset(dep,0,sizeof(dep));\n        p.push(S);dep[S]=1;\n        while(!p.empty()){\n            int x=p.front();p.pop();\n            for(int i=hd[x];i;i=e[i].nxt){\n                int y=e[i].to,v=e[i].val;\n                if(!dep[y]&&v){\n\t\t\t\t\tdep[y]=dep[x]+1;\n                    p.push(y);\n                }\n            }\n        }\n        if(dep[T]) return 1;\n        return 0;\n    }\n    int dfs(int x,int flow){\n        if(x==T||flow<=0) return flow;\n        int rest=0;\n        for(int i=hd[x];i;i=e[i].nxt){\n            int j=e[i].to;int v=e[i].val;\n            if(dep[j]==dep[x]+1&&v){\n                int now=dfs(j,min(v,flow));\n                e[i].val-=now;\n                e[i^1].val+=now;\n                flow-=now;rest+=now;\n                if(flow<=0) break;\n            }\n        }if(!rest) dep[x]=-1;\n        return rest;\n    }\n    int dinic(){\n        int maxflow=0;\n        while(bfs()) maxflow+=dfs(S,inf);\n\t\treturn maxflow;\n    }\n}\nint read(){\n    int x=0,f=1;char ch=getchar();\n    while(!isdigit(ch)){if(ch=='-')f=-f;ch=getchar();}\n    while(isdigit(ch)){x=x*10+ch-48;ch=getchar();}\n    return x*f;\n}\nsigned main(){\n    prepare();n=read();\n    for(int i=1;i<=n;i++){\n        int x=read();\n        a[x]=1,mx=max(mx,x);\n    }\n    for(int i=1;i<=mx+1;i++)\n        if(a[i]!=a[i-1]) i&1?L[++t1]=i:R[++t2]=i;\n    S=0,T=t1+t2+1;\n    for(int i=1;i<=t1;i++)\n        ins(S,i,1),ins(i,S,0);\n    for(int i=1;i<=t2;i++)\n        ins(i+t1,T,1),ins(T,i+t1,0);\n    for(int i=1;i<=t1;i++)\n        for(int j=1;j<=t2;j++)\n            if(!is[abs(L[i]-R[j])])\n                ins(i,j+t1,1),ins(j+t1,i,0);\n    int Val=Network_Flow::dinic();\n    ans+=Val;ans+=(t1-Val)/2*2+(t2-Val)/2*2;\n    ans+=((t1-Val)&1)*3;printf(\"%d\\n\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N = 205,M=10000008;\nint n,y[N],x[N],pr[M],tot,k,fa[N],m;\nbool vis[M],vv[N];\nvector<int>S,T,v[N];\nint dfs(int x)\n{\n    for(auto i:v[x])\n    {\n        if(!vv[i])\n        {\n            vv[i]=1;\n            if(!fa[i]||dfs(fa[i]))\n            {\n                fa[i]=x;\n                return 1;\n            }\n        }\n    }\n    return 0;\n}\nint main()\n{\n    cin>>n;\n    for(int i=1;i<=n;i++)scanf(\"%d\",&y[i]);\n    sort(y+1,y+n+1);\n    x[m=1]=y[1];\n    if(y[1]+1!=y[2])x[++m]=y[1]+1;\n    for(int i=2;i<=n;i++)\n    {\n        if(y[i]!=y[i-1]+1)x[++m]=y[i];\n        if(y[i]!=y[i+1]-1)x[++m]=y[i]+1;\n    }\n    n=m;vis[1]=1;\n    for(int i=2;i<=10000000;i++)\n    {\n        if(!vis[i])pr[++tot]=i;\n        for(int j=1;j<=tot&&i*pr[j]<=10000000;j++)\n        {\n            vis[i*pr[j]]=1;\n            if(i%pr[j]==0)break;\n        }\n    }\n    for(int i=1;i<=n;i++)\n        if(x[i]&1)S.push_back(i);\n        else T.push_back(i);\n    for(auto i:S)for(auto j:T)if(!vis[abs(x[i]-x[j])])v[i].push_back(j);\n    for(auto i:S)\n    {\n        memset(vv,0,sizeof(vv));\n        if(dfs(i))k++;\n    }\n    printf(\"%d\\n\",k+(S.size()-k)/2*2+(T.size()-k)/2*2+((S.size()-k)%2)*3);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 10000010;\n\n\nint n,fre[220],p[220],isprime[maxn],even,odd,wrong;\nvector <int> edge[220],v2;\n\nbool fin(int u) {\n    if (fre[u]=wrong) return false;\n    fre[u]=wrong;\n    for (int j=0;j<edge[u].size();j++) {\n        int v=edge[u][j];\n        if (p[v]=0 || fin(p[v])) {\n            p[u]=v;\n            p[v]=u;\n            return true;\n        }\n    }\n    return false;\n}\n\nint main() {\n  //  freopen(\"in.txt\",\"r\",stdin);\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    isprime[1]=1;\n    for (int i=2;i<=maxn;i++)\n        if (isprime[i]==0) {\n            for (int j=i+i;j<=maxn;j+=i) isprime[j]=1;\n        }\n    cin>>n;\n    for (int i=1;i<=n;i++) {\n        int x;\n        cin>>x;\n        fre[x]=1;\n    }\n    even=0; odd=0; wrong=2;\n    int id=1;\n    while (id<=maxn) {\n        if (fre[id]==0) id++;\n        else {\n            v2.push_back(id);\n            if (id%2==0) even++; else odd++ ;\n            id++;\n            while (id<=maxn && fre[id]==1) id++;\n            v2.push_back(id);\n            if (id%2==0) even++; else odd++ ;\n        }\n    }\n    // for (int i=0;i<v2.size();i++) cout<<v2[i]<<\" \";\n   //  cout<<endl;\n   // cout<<\" \" <<even<<\" \"<<odd<<endl;\n    for (int i=0;i<v2.size();i++)\n        for (int j=i+1;j<v2.size();j++)\n            if (isprime[ v2[j] - v2[i] ]==0) {\n                edge[i+1].push_back(j+1);\n                edge[j+1].push_back(i+1);\n            }\n    int cnt=0;\n    for (int i=0;i<v2.size();i++) {\n        wrong++;\n        cnt+=(fin(i));\n    }\n   // cout<<cnt<<\" \" <<even<<\" \"<<odd<<endl;\n    cout<< cnt + ((even-cnt)/2 + (odd-cnt)/2) * 2 + (even%2)*3;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(3)\n#include<iostream>\n#include<iomanip>\n#include<stack>\n#include<queue>\n#include<list>\n#include<vector>\n#include<set> \n#include<map>\n#include<string>\n#include<algorithm>\n#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<ctime>\n#define ll long long\n#define db double\n#define inf 10000001\n#define infm 50001\n#define INF (int)1e8 \n#define mod (int)(1e9+7)\n#define pi acos(-1)\n#define rd(n) {n=0;char ch;int f=0;do{ch=getchar();if(ch=='-'){f=1;}}while(ch<'0'||ch>'9');while('0'<=ch&&ch<='9'){n=(n<<1)+(n<<3)+ch-48;ch=getchar();}if(f)n=-n;}\nusing namespace std;\n \nint p[inf],ckp[inf],pcnt;\nconst int lim=10000000;\n \nvoid pre_work(void){\n    ckp[0]=ckp[1]=1;\n    for (int i=2;i<=lim;i++){\n        if (!ckp[i]){\n            p[++pcnt]=i;\n        }\n        for (int j=1;j<=pcnt && p[j]*i<=lim;j++){\n            ckp[p[j]*i]=1;\n            if (i%p[j]==0){\n                break;\n            }\n        }\n    }\n    return;\n}\n \nint S,T;\n \nstruct edge{\n    int nxt,y,s;\n}e[infm*2];\nint ecnt=1,head[infm],h[infm];\n \nvoid addedge(int x,int y,int s){\n    ecnt++;\n    e[ecnt].nxt=head[x];\n    e[ecnt].y=y;\n    e[ecnt].s=s;\n    head[x]=ecnt;\n    return;\n}\n \nvoid ae(int x,int y,int s){\n    addedge(x,y,s);\n    addedge(y,x,0);\n    return;\n}\n \nqueue <int> q;\nint dep[inf];\n \nint dfs(int u,int flow){\n    if (!flow || u==T){\n        return flow;\n    }\n    int ans=0;\n    for (int i=h[u];i;i=e[i].nxt){\n        h[u]=i;\n        int v=e[i].y,s=e[i].s,now;\n        if (dep[v]!=dep[u]+1){\n            continue;\n        }\n        now=dfs(v,min(flow,s));\n        if (now){\n            ans+=now;\n            flow-=now;\n            e[i].s-=now;\n            e[i^1].s+=now;\n            if (!flow){\n                break;\n            }\n        }\n    }\n    return ans;\n}\n \nint dinic(void){\n    int ans=0;\n    while (1){\n        while (!q.empty()){\n            q.pop();\n        }\n        memcpy(h,head,sizeof(head));\n        memset(dep,-1,sizeof(dep));\n        dep[S]=0;\n        q.push(S);\n        while (!q.empty()){\n            int u=q.front(),v,s;\n            q.pop();\n            for (int i=head[u];i;i=e[i].nxt){\n                v=e[i].y,s=e[i].s;\n                if (dep[v]<0 && s){\n                    dep[v]=dep[u]+1;\n                    q.push(v);\n                }\n            }\n        }\n        if (dep[T]<0){\n            break;\n        }\n        ans+=dfs(S,INF);\n    }\n    return ans;\n}\n \nint n;\nint a[inf];\nint L[inf],R[inf];\n \nint main(){\n    pre_work();\n    rd(n)\n    int x,mx=0;\n    for (int i=1;i<=n;i++){\n        rd(x)\n        a[x]++;\n        mx=max(mx,x);\n    }\n    int cntl=0,cntr=0;\n    for (int i=1;i<=mx+1;i++){\n        if (a[i]!=a[i-1]){\n            if (i&1){\n                L[++cntl]=i;\n            }\n            else{\n                R[++cntr]=i;\n            }\n        }\n    }\n    S=0,T=cntl+cntr+1;\n    for (int i=1;i<=cntl;i++){\n        ae(S,i,1);\n    }\n    for (int i=1;i<=cntr;i++){\n        ae(i+cntl,T,1);\n    }\n    for (int i=1;i<=cntl;i++){\n        for (int j=1;j<=cntr;j++){\n            if (!ckp[abs(L[i]-R[j])]){\n                ae(i,j+cntl,1);\n            }\n        }\n    }\n    int mxf=dinic();\n    int ans=mxf;\n    ans+=(cntl-mxf)/2*2+(cntr-mxf)/2*2;\n    ans+=((cntl-mxf)&1)*3;\n    printf(\"%d\\n\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nconst int N=1005,INF=~0u>>2;\nstruct Edge{int nxt,to;}edge[N*N];\nint b[N],n,head[N],num_edge,vis[N],lk[N],even[N],odd[N],even_num,odd_num,ans,k,tot,tim;\nint abs(int x){return x>0?x:-x;}\nint read(){\n\tint x=0,f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-') f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn f*x;\n}\nvoid add_edge(int from,int to){\n\tedge[++num_edge].nxt=head[from];\n\tedge[num_edge].to=to;\n\thead[from]=num_edge;\n}\nbool find(int x){\n\tfor(int i=head[x];i;i=edge[i].nxt){\n\t\tif(vis[edge[i].to]!=tim){\n\t\t\tvis[edge[i].to]=tim;\n\t\t\tif(!lk[edge[i].to]||find(edge[i].to)){\n\t\t\t\tlk[edge[i].to]=x;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nbool check(int x){\n\tif(x==1) return 0;\n\tfor(int i=2;i*i<=x;++i){\n\t\tif(x%i==0) return 0;\n\t}\n\treturn 1;\n}\nvoid solve(int x){\n\tif(x&1) odd[++odd_num]=x;\n\telse even[++even_num]=x;\n}\nint main(){\n//\tfreopen(\"ex.in\",\"r\",stdin);\n\tn=read();\n\tfor(int i=1;i<=n;++i) b[i]=read();b[0]=-1;\n\tfor(int i=1;i<=n;++i){\n\t\tif(b[i]!=b[i-1]+1) solve(b[i]);\n\t\tif(b[i]+1!=b[i+1]) solve(b[i]+1);\n\t}\n\tfor(int i=1;i<=odd_num;++i){\n\t\tfor(int j=1;j<=even_num;++j){\n\t\t\tif(check(abs(even[j]-odd[i]))) add_edge(i,j);\n\t\t}\n\t}\n\tfor(int i=1;i<=odd_num;++i){\n\t\ttim++;\n\t\tif(find(i)) k++;\n\t}\n\tans=k+((even_num-k)/2+(odd_num-k)/2)*2+((odd_num-k)%2)*3;\n\tprintf(\"%d\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <set>\n#include <algorithm>\n#include <vector>\n#include<cstring>\n#define REP(i, x, y) for(int i = (int)x; i <= (int)y; i ++)\n#define PER(i, x, y) for(int i = (int)x; i >= (int)y; i --)\n#define FOR(i, x, y) for(int i = (int)x; i <  (int)y; i ++)\nusing namespace std;\n\ntypedef long long s64;\n\nconst int INF = 2147483647;\n\nconst int MaxN = 805;\nconst int MaxM = 200005;\n\ntemplate <class T>\ninline void tension(T &a, const T &b)\n{\n\tif (b < a)\n\t\ta = b;\n}\ntemplate <class T>\ninline void relax(T &a, const T &b)\n{\n\tif (b > a)\n\t\ta = b;\n}\ntemplate <class T>\ninline int size(const T &a)\n{\n\treturn (int)a.size();\n}\n\ninline int getint()\n{\n\tchar c;\n\twhile (c = getchar(), '0' > c || c > '9');\n\n\tint res = c - '0';\n\twhile (c = getchar(), '0' <= c && c <= '9')\n\t\tres = res * 10 + c - '0';\n\treturn res;\n}\n\nconst int MaxNX = MaxN + MaxN;\n\nstruct edge\n{\n\tint v, u, w;\n\n\tedge(){}\n\tedge(const int &_v, const int &_u, const int &_w)\n\t\t: v(_v), u(_u), w(_w){}\n};\n\nint n, m;\nedge mat[MaxNX + 1][MaxNX + 1];\n\nint n_matches;\ns64 tot_weight;\nint mate[MaxNX + 1];\nint lab[MaxNX + 1];\n\nint q_n, q[MaxN];\nint fa[MaxNX + 1], col[MaxNX + 1];\nint slackv[MaxNX + 1];\n\nint n_x;\nint bel[MaxNX + 1], blofrom[MaxNX + 1][MaxNX + 1];\nvector<int> bloch[MaxNX + 1];\n\ninline int e_delta(const edge &e) // does not work inside blossoms\n{\n\treturn lab[e.v] + lab[e.u] - mat[e.v][e.u].w * 2;\n}\ninline void update_slackv(int v, int x)\n{\n\tif (!slackv[x] || e_delta(mat[v][x]) < e_delta(mat[slackv[x]][x]))\n\t\tslackv[x] = v;\n}\ninline void calc_slackv(int x)\n{\n\tslackv[x] = 0;\n\tfor (int v = 1; v <= n; v++)\n\t\tif (mat[v][x].w > 0 && bel[v] != x && col[bel[v]] == 0)\n\t\t\tupdate_slackv(v, x);\n}\n\ninline void q_push(int x)\n{\n\tif (x <= n)\n\t\tq[q_n++] = x;\n\telse\n\t{\n\t\tfor (int i = 0; i < size(bloch[x]); i++)\n\t\t\tq_push(bloch[x][i]);\n\t}\n}\ninline void set_mate(int xv, int xu)\n{\n\tmate[xv] = mat[xv][xu].u;\n\tif (xv > n)\n\t{\n\t\tedge e = mat[xv][xu];\n\t\tint xr = blofrom[xv][e.v];\n\t\tint pr = find(bloch[xv].begin(), bloch[xv].end(), xr) - bloch[xv].begin();\n\t\tif (pr % 2 == 1)\n\t\t{\n\t\t\treverse(bloch[xv].begin() + 1, bloch[xv].end());\n\t\t\tpr = size(bloch[xv]) - pr;\n\t\t}\n\n\t\tfor (int i = 0; i < pr; i++)\n\t\t\tset_mate(bloch[xv][i], bloch[xv][i ^ 1]);\n\t\tset_mate(xr, xu);\n\n\t\trotate(bloch[xv].begin(), bloch[xv].begin() + pr, bloch[xv].end());\n\t}\n}\ninline void set_bel(int x, int b)\n{\n\tbel[x] = b;\n\tif (x > n)\n\t{\n\t\tfor (int i = 0; i < size(bloch[x]); i++)\n\t\t\tset_bel(bloch[x][i], b);\n\t}\n}\n\ninline void augment(int xv, int xu)\n{\n\twhile (true)\n\t{\n\t\tint xnu = bel[mate[xv]];\n\t\tset_mate(xv, xu);\n\t\tif (!xnu)\n\t\t\treturn;\n\t\tset_mate(xnu, bel[fa[xnu]]);\n\t\txv = bel[fa[xnu]], xu = xnu;\n\t}\n}\ninline int get_lca(int xv, int xu)\n{\n\tstatic bool book[MaxNX + 1];\n\tfor (int x = 1; x <= n_x; x++)\n\t\tbook[x] = false;\n\twhile (xv || xu)\n\t{\n\t\tif (xv)\n\t\t{\n\t\t\tif (book[xv])\n\t\t\t\treturn xv;\n\t\t\tbook[xv] = true;\n\t\t\txv = bel[mate[xv]];\n\t\t\tif (xv)\n\t\t\t\txv = bel[fa[xv]];\n\t\t}\n\t\tswap(xv, xu);\n\t}\n\treturn 0;\n}\n\ninline void add_blossom(int xv, int xa, int xu)\n{\n\tint b = n + 1;\n\twhile (b <= n_x && bel[b])\n\t\tb++;\n\tif (b > n_x)\n\t\tn_x++;\n\n\tlab[b] = 0;\n\tcol[b] = 0;\n\n\tmate[b] = mate[xa];\n\n\tbloch[b].clear();\n\tbloch[b].push_back(xa);\n\tfor (int x = xv; x != xa; x = bel[fa[bel[mate[x]]]])\n\t\tbloch[b].push_back(x), bloch[b].push_back(bel[mate[x]]), q_push(bel[mate[x]]);\n\treverse(bloch[b].begin() + 1, bloch[b].end());\n\tfor (int x = xu; x != xa; x = bel[fa[bel[mate[x]]]])\n\t\tbloch[b].push_back(x), bloch[b].push_back(bel[mate[x]]), q_push(bel[mate[x]]);\n\n\tset_bel(b, b);\n\n\tfor (int x = 1; x <= n_x; x++)\n\t{\n\t\tmat[b][x].w = mat[x][b].w = 0;\n\t\tblofrom[b][x] = 0;\n\t}\n\tfor (int i = 0; i < size(bloch[b]); i++)\n\t{\n\t\tint xs = bloch[b][i];\n\t\tfor (int x = 1; x <= n_x; x++)\n\t\t\tif (mat[b][x].w == 0 || e_delta(mat[xs][x]) < e_delta(mat[b][x]))\n\t\t\t\tmat[b][x] = mat[xs][x], mat[x][b] = mat[x][xs];\n\t\tfor (int x = 1; x <= n_x; x++)\n\t\t\tif (blofrom[xs][x])\n\t\t\t\tblofrom[b][x] = xs;\n\t}\n\tcalc_slackv(b);\n}\ninline void expand_blossom1(int b) // lab[b] == 1\n{\n\tfor (int i = 0; i < size(bloch[b]); i++)\n\t\tset_bel(bloch[b][i], bloch[b][i]);\n\n\tint xr = blofrom[b][mat[b][fa[b]].v];\n\tint pr = find(bloch[b].begin(), bloch[b].end(), xr) - bloch[b].begin();\n\tif (pr % 2 == 1)\n\t{\n\t\treverse(bloch[b].begin() + 1, bloch[b].end());\n\t\tpr = size(bloch[b]) - pr;\n\t}\n\n\tfor (int i = 0; i < pr; i += 2)\n\t{\n\t\tint xs = bloch[b][i], xns = bloch[b][i + 1];\n\t\tfa[xs] = mat[xns][xs].v;\n\t\tcol[xs] = 1, col[xns] = 0;\n\t\tslackv[xs] = 0, calc_slackv(xns);\n\t\tq_push(xns);\n\t}\n\tcol[xr] = 1;\n\tfa[xr] = fa[b];\n\tfor (int i = pr + 1; i < size(bloch[b]); i++)\n\t{\n\t\tint xs = bloch[b][i];\n\t\tcol[xs] = -1;\n\t\tcalc_slackv(xs);\n\t}\n\n\tbel[b] = 0;\n}\ninline void expand_blossom_final(int b) // at the final stage\n{\n\tfor (int i = 0; i < size(bloch[b]); i++)\n\t{\n\t\tif (bloch[b][i] > n && lab[bloch[b][i]] == 0)\n\t\t\texpand_blossom_final(bloch[b][i]);\n\t\telse\n\t\t\tset_bel(bloch[b][i], bloch[b][i]);\n\t}\n\tbel[b] = 0;\n}\n\ninline bool on_found_edge(const edge &e)\n{\n\tint xv = bel[e.v], xu = bel[e.u];\n\tif (col[xu] == -1)\n\t{\n\t\tint nv = bel[mate[xu]];\n\t\tfa[xu] = e.v;\n\t\tcol[xu] = 1, col[nv] = 0;\n\t\tslackv[xu] = slackv[nv] = 0;\n\t\tq_push(nv);\n\t}\n\telse if (col[xu] == 0)\n\t{\n\t\tint xa = get_lca(xv, xu);\n\t\tif (!xa)\n\t\t{\n\t\t\taugment(xv, xu), augment(xu, xv);\n\t\t\tfor (int b = n + 1; b <= n_x; b++)\n\t\t\t\tif (bel[b] == b && lab[b] == 0)\n\t\t\t\t\texpand_blossom_final(b);\n\t\t\treturn true;\n\t\t}\n\t\telse\n\t\t\tadd_blossom(xv, xa, xu);\n\t}\n\treturn false;\n}\n\nbool match()\n{\n\tfor (int x = 1; x <= n_x; x++)\n\t\tcol[x] = -1, slackv[x] = 0;\n\n\tq_n = 0;\n\tfor (int x = 1; x <= n_x; x++)\n\t\tif (bel[x] == x && !mate[x])\n\t\t\tfa[x] = 0, col[x] = 0, slackv[x] = 0, q_push(x);\n\tif (q_n == 0)\n\t\treturn false;\n\n\twhile (true)\n\t{\n\t\tfor (int i = 0; i < q_n; i++)\n\t\t{\n\t\t\tint v = q[i];\n\t\t\tfor (int u = 1; u <= n; u++)\n\t\t\t\tif (mat[v][u].w > 0 && bel[v] != bel[u])\n\t\t\t\t{\n\t\t\t\t\tint d = e_delta(mat[v][u]);\n\t\t\t\t\tif (d == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (on_found_edge(mat[v][u]))\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\telse if (col[bel[u]] == -1 || col[bel[u]] == 0)\n\t\t\t\t\t\tupdate_slackv(v, bel[u]);\n\t\t\t\t}\n\t\t}\n\n\t\tint d = INF;\n\t\tfor (int v = 1; v <= n; v++)\n\t\t\tif (col[bel[v]] == 0)\n\t\t\t\ttension(d, lab[v]);\n\t\tfor (int b = n + 1; b <= n_x; b++)\n\t\t\tif (bel[b] == b && col[b] == 1)\n\t\t\t\ttension(d, lab[b] / 2);\n\t\tfor (int x = 1; x <= n_x; x++)\n\t\t\tif (bel[x] == x && slackv[x])\n\t\t\t{\n\t\t\t\tif (col[x] == -1)\n\t\t\t\t\ttension(d, e_delta(mat[slackv[x]][x]));\n\t\t\t\telse if (col[x] == 0)\n\t\t\t\t\ttension(d, e_delta(mat[slackv[x]][x]) / 2);\n\t\t\t}\n\n\t\tfor (int v = 1; v <= n; v++)\n\t\t{\n\t\t\tif (col[bel[v]] == 0)\n\t\t\t\tlab[v] -= d;\n\t\t\telse if (col[bel[v]] == 1)\n\t\t\t\tlab[v] += d;\n\t\t}\n\t\tfor (int b = n + 1; b <= n_x; b++)\n\t\t\tif (bel[b] == b)\n\t\t\t{\n\t\t\t\tif (col[bel[b]] == 0)\n\t\t\t\t\tlab[b] += d * 2;\n\t\t\t\telse if (col[bel[b]] == 1)\n\t\t\t\t\tlab[b] -= d * 2;\n\t\t\t}\n\n\t\tq_n = 0;\n\t\tfor (int v = 1; v <= n; v++)\n\t\t\tif (lab[v] == 0) // all unmatched vertices' labels are zero! cheers!\n\t\t\t\treturn false;\n\t\tfor (int x = 1; x <= n_x; x++)\n\t\t\tif (bel[x] == x && slackv[x] && bel[slackv[x]] != x && e_delta(mat[slackv[x]][x]) == 0)\n\t\t\t{\n\t\t\t\tif (on_found_edge(mat[slackv[x]][x]))\n\t\t\t\t\treturn true;\n\t\t\t}\n\t\tfor (int b = n + 1; b <= n_x; b++)\n\t\t\tif (bel[b] == b && col[b] == 1 && lab[b] == 0)\n\t\t\t\texpand_blossom1(b);\n\t}\n\treturn false;\n}\n\nlong long ori_ans = 0;\n\nint pr[1000005], ptot, vis[10000005];\nvoid pret(){\n\tint n = 1e7;\n\tREP(i, 2, n){\n\t\tif(!vis[i]) pr[++ptot] = i;\n\t\tfor(int j = 1; j <= ptot && (long long)pr[j] * i <= n; j ++){\n\t\t\tvis[i * pr[j]] = 1;\n\t\t\tif(i % pr[j] == 0) break;\n\t\t}\n\t}\n\tvis[1] = 1;\n}\n\nint ask(int x){\n\tif(!vis[x]) return 1;\n\tif(!(x & 1)) return 2;\n\treturn 3;\n}\n\nvoid calc_max_weight_match()\n{\n\tfor (int v = 1; v <= n; v++)\n\t\tmate[v] = 0;\n\n\tn_x = n;\n\tn_matches = 0;\n\ttot_weight = ori_ans;\n\n\tbel[0] = 0;\n\tfor (int v = 1; v <= n; v++)\n\t\tbel[v] = v, bloch[v].clear();\n\tfor (int v = 1; v <= n; v++)\n\t\tfor (int u = 1; u <= n; u++)\n\t\t\tblofrom[v][u] = v == u ? v : 0;\n\n\tint w_max = 0;\n\tfor (int v = 1; v <= n; v++)\n\t\tfor (int u = 1; u <= n; u++)\n\t\t\trelax(w_max, mat[v][u].w);\n\tfor (int v = 1; v <= n; v++)\n\t\tlab[v] = w_max;\n\n\twhile (match())\n\t\tn_matches++;\n\n\tfor (int v = 1; v <= n; v++)\n\t\tif (mate[v] && mate[v] < v)\n\t\t\ttot_weight -= mat[v][mate[v]].w;\n}\n\n\nnamespace In{\n\ttemplate<typename T> inline void chkmin(T &a, const T &b) {if(a > b) a = b;}\n\ttemplate<typename T> inline void chkmax(T &a, const T &b) {if(a < b) a = b;}\n\n\tchar s[1005], t[1005];\n\tint ss[1005], n, cs[405][405];\n\n\tint nn, A[10005];\n\n\tvoid Init(){\n\t\t:: n = n;\n\t\tREP(u, 1, n) REP(v, 1, n) mat[u][v] = edge(u, v, 0);\n\t}\n\n\tvoid add(int u, int v, int w){\n\t\tmat[u][v].w = mat[v][u].w = w;\n\t}\n\n\tvoid Main(){\n/*\n\t\tscanf(\"%d\", &n);\n\n\t\tscanf(\"%s\", s + 1);\n\n\t\tn = strlen(t + 1);\n\n\t\tInit();\n\n\t\tREP(i, 1, n) ss[i] = (t[i] - 48) ^ (s[i] - 48);\n\n\t\tREP(i, 1, n) ss[i] = ss[i] ^ ss[i + 1];\n\n\t\tmemset(cs, 0x3f, sizeof cs);\n\t\tREP(i, 0, n) cs[i][i] = 0;\n\n\t\tREP(i, 1, n) REP(j, 1, n - i + 1){\n\t\t\tint u = i - 1, v = i + j - 1;\n\t\t\tscanf(\"%d\", &cs[u][v]);\n\t\t\tcs[v][u] = cs[u][v];\n\t\t}\n\n\t\tREP(k, 0, n) REP(i, 0, n) REP(j, 0, n) chkmin(cs[i][j], cs[i][k] + cs[k][j]);\n\n\n\t\tREP(i, 1, n) if(ss[i]) {\n\t\t\tori_ans += cs[0][i];\n\t\t\tREP(j, 1, i - 1) if(ss[j]) add(i, j, cs[0][i] + cs[0][j] - cs[i][j]);\n\t\t}\n*/\n\t\tpret();\n\n\t\tscanf(\"%d\", &nn);\n\n\t\tREP(i, 1, nn) scanf(\"%d\", A + i);\n\n\t\tset<int> st;\n\t\tREP(i, 1, nn){\n\t\t\tint u = A[i];\n\t\t\tif(u > 1 && A[i - 1] != A[i] - 1) st.insert(u - 1);\n\t\t\tif(A[i + 1] != A[i] + 1) st.insert(u);\n\t\t}\n\n\t\tstatic int pos[1005];\n\t\tmemset(pos, 0, sizeof pos);\n\t\tint gtot = 0;\n\t\tn = st.size();\n\t\tfor(auto i : st) pos[++ gtot] = i;\n\n\t\tREP(i, 0, n) cs[i][i] = 0;\n\t\tREP(i, 0, n) REP(j, i + 1, n){\n\t\t\tint u = pos[i], v = pos[j];\n\t\t\tcs[i][j] = cs[j][i] = ask(v - u);\n\t\t}\n\n\t\tInit();\n\n\t\tori_ans = 0;\n\t\tREP(i, 1, n){\n\t\t\tori_ans += cs[0][i];\n\t\t\tREP(j, 1, i - 1){\n\t\t\t\tadd(i, j, cs[0][i] + cs[0][j] - cs[i][j]);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\tIn :: Main();\n\tcalc_max_weight_match();\n\tcout << tot_weight << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<stack>\n#include <cstring>\nusing namespace std;\nconst int maxn = 1e7 + 100;\nint prime[maxn],primesize,phi[maxn];\nbool isprime[maxn];\nvoid getlist(int listsize)\n{\n    memset(isprime,1,sizeof(isprime));\n    isprime[1]=false;\n    for(int i=2;i<=listsize;i++)\n    {\n        if(isprime[i])prime[++primesize]=i;\n         for(int j=1;j<=primesize&&i*prime[j]<=listsize;j++)\n         {\n            isprime[i*prime[j]]=false;\n            if(i%prime[j]==0)break;\n        }\n    }\n}\n\nint x[110];\n\nint main()\n{\n    getlist(maxn-1);\n    int ans = 0,n;\n    cin>>n;\n    stack<int> S;\n    for(int i=1;i<=n;i++){\n        cin>>x[i];\n    }\n    sort(x+1,x+n+1);\n    int len = 1;\n    for(int i=2;i<=n;i++){\n        if(x[i] - x[i-1] == 1)\n            len++;\n        else{\n            S.push(len);\n            len = 1;\n        }\n    }\n    if(len) S.push(len);\n    while(S.size()){\n        int res = S.top();\n        S.pop();\n        while(res!=2 && res!=1 && res!=0 ){\n            int *sig = upper_bound(prime,prime+primesize,res);\n//            cout<<(*(sig-1))<<endl;\n            res -= *(sig-1);\n            ans++;\n        }\n        if(res == 2 || res == 1)\n            ans+=2;\n    }\n    cout<<ans<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<iostream>\n#include<queue>\n#include<cmath>\nusing namespace std;\nvoid read(int &x){\n\tchar ch;bool ok;\n\tfor(ok=0,ch=getchar();!isdigit(ch);ch=getchar())if(ch=='-')ok=1;\n\tfor(x=0;isdigit(ch);x=x*10+ch-'0',ch=getchar());if(ok)x=-x;\n}\n#define rg register\nconst int maxn=210;bool vis[maxn];\nint f[maxn],n,ans,a[maxn],mp[maxn][maxn],b[maxn],tot1,tot2,x[maxn];\nbool check(int x){\n\tif((!(x&1))||x==1)return 0;\n\tint n=sqrt(x);\n\tfor(rg int i=2;i<=n;i++)\n\t\tif(!(x%i))return 0;\n\treturn 1;\n}\nbool dfs(int x){\n\tfor(rg int i=1;i<=tot2;i++)\n\t\tif(!vis[i]&&mp[x][i]){\n\t\t\tvis[i]=1;\n\t\t\tif(!f[i]||dfs(f[i]))return f[i]=x,1;\n\t\t}\n\treturn 0;\n}\nint main(){\n\tread(n);\n\tfor(rg int i=1;i<=n;i++)read(x[i]);\n\tif(n==1){printf(\"3\\n\");return 0;}\n\tfor(rg int i=1;i<=n;i++){\n\t\tif(x[i+1]-x[i]!=1||i==n){\n\t\t\tif((x[i]+1)%2==0)a[++tot1]=x[i]+1;\n\t\t\telse b[++tot2]=x[i]+1;\n\t\t}\n\t\tif(x[i]-x[i-1]!=1||i==1){\n\t\t\tif(x[i]&1)b[++tot2]=x[i];\n\t\t\telse a[++tot1]=x[i];\n\t\t}\n\t}\n\tfor(rg int i=1;i<=tot1;i++)\n\t\tfor(rg int j=1;j<=tot2;j++)\n\t\t\tif(check(abs(a[i]-b[j])))mp[i][j]=1;\n\tfor(rg int i=1;i<=tot1;i++){\n\t\tmemset(vis,0,sizeof vis);\n\t\tif(dfs(i))ans++;\n\t}\n\t//\tprintf(\"%d\\n\",ans);\n\tprintf(\"%d\\n\",ans+(tot1-ans)/2*2+(tot2-ans)/2*2+(tot1-ans)%2*3);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i, n) for (int (i) = 0 ; (i) < (int)(n) ; ++(i))\n#define repn(i, m, n) for (int (i) = (m) ; (i) < (int)(n) ; ++(i))\n#define rep_rev(i, n) for (int (i) = (int)(n) - 1 ; (i) >= 0 ; --(i))\n#define repn_rev(i, m, n) for (int (i) = (int)(n) - 1 ; (i) >= (m) ; --(i))\n\n#define INF 2e9\n#define ll long long\n#define MOD 1e9+7\n#define MAX_V 205\n\n#define print2D(h, w, arr) REP(i, h) { REP(j, w) cout << arr[i][j] << \" \"; cout << endl; }\n#define print_line(vec, n) {for(int i=0;i<(n-1);i++) cout << (vec)[i] << \" \"; cout << (vec)[(n)-1] << endl;}\ntemplate<class T> void print(const T& x){cout << x << endl;}\ntemplate<class T, class... A> void print(const T& first, const A&... rest) { cout << first << \" \"; print(rest...); }\nstruct PreMain {PreMain(){cin.tie(0);ios::sync_with_stdio(false);cout<<fixed<<setprecision(20);}} premain; \n\n\n/* 辺を表す構造体 */\nstruct edge {int to, cap ,rev; };\n \n/* グラフの隣接リスト表現 */\nvector<edge> G[MAX_V];\n/* DFSですべに調べたかのグラフ */\nbool used[MAX_V];\n \n/* fromからtoへ向かう容量capの辺をグラフに追加する */\n/* 相互参照できるようにしている */\nvoid add_edge(int from, int to, int cap){\n    G[from].push_back((edge){to, cap, (int)G[to].size()});\n    G[to].push_back((edge){from, 0, (int)G[from].size() - 1});    \n}\n \n/* 増加パスをdfsで探す */\nint dfs(int v, int t, int f){\n    if(v==t) return f;\n    used[v] = true;\n    for(int i=0; i<G[v].size(); i++){\n        edge &e = G[v][i];\n        if(!used[e.to] && e.cap>0){\n            int d = dfs(e.to, t, min(f, e.cap));\n            if(d>0){\n                e.cap -= d;\n                G[e.to][e.rev].cap += d;\n                return d;\n            }\n        }\n    }\n    return 0;\n}\n \nint max_flow(int s, int t){\n    int flow = 0;\n    for(;;){\n        memset(used, 0, sizeof(used));\n        int f = dfs(s, t, INF);\n        if(f==0) return flow;\n        flow += f;\n    }\n}\n\nbool diffIsPrime(int a, int b) {\n    if(a > b) swap(a, b);\n    a = b - a;\n    if(a <= 2) return false;\n    repn(i, 2, sqrt(a)+1) if(a % i == 0) return false;\n\n    return true;\n}\n\nint main(){\n    int n;\n    cin >> n;\n    vector<int> x(n);\n    map<int, int> mp;\n    rep(i, n) {\n        int tmp;\n        cin >> tmp;\n        mp[tmp]++;\n        mp[tmp+1]++;\n    }\n\n    /* 一発でいける分を探す。偶奇の組み合わせしかないので二部マッチング */\n    vector<int> odd, even;\n    for(auto it = mp.begin(); it != mp.end(); it++) {\n        if(it->second % 2 == 1) {\n            if(it->first % 2 == 0) {\n                even.push_back(it->first);\n            } else {\n                odd.push_back(it->first);\n            }\n        }\n    }\n\n    int start = 0, end = 201;\n    rep(i, even.size()) add_edge(start, i+1, 1);\n    rep(i, odd.size()) add_edge(i+101, end, 1);\n    rep(i, even.size()) rep(j, odd.size()) if(diffIsPrime(even[i], odd[j])) add_edge(i+1, j+101, 1);\n\n    int ans_tmp = max_flow(start, end);\n    int ans = ans_tmp;\n\n    /* 偶数同士と奇数同士は。差が偶数なので二回でいける */\n    ans += even.size() - ans_tmp;\n    ans += odd.size() - ans_tmp;\n\n    /* あまったやつは差が奇数なので三回でいける */\n    if(even.size() % 2 != 0) ans += 3;\n\n    cout << ans << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//\n//  main.cpp\n//  F - Prime Flip\n//\n//  Created by Jędrzej Dudzicz on 04/02/2019.\n//  Copyright © 2019 Jędrzej Dudzicz. All rights reserved.\n//\n\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <algorithm>\n#include <cstdio>\n#include <utility>\nusing namespace std;\nconst int MXN=105;\nconst int MXM=1e7+2;\nint n,x;\nint s[MXM],s1[MXN];\nbool sito[MXM];\nint tab1[2*MXN],h;\nbool odw[2*MXN];\nint wynik;\nint main(){\n    for(int i=2;i*i<=MXM-1;i++){\n        if(sito[i]==0){\n            for(int j=i*i;j<=MXM-1;j+=i){\n                if(sito[j]==0)sito[j]=1;\n            }\n        }\n    }\n    sito[0]=1;\n    sito[1]=1;\n    sito[2]=1;\n    scanf(\"%d\",&n);\n    for(int i=0;i<n;i++){\n        scanf(\"%d\",&x);\n        s[x]=1;\n    }\n    for(int i=1;i<=10000001;i++){\n        if(s[i]!=s[i-1]){\n            s1[i]=1;\n            tab1[h++]=i;\n        }\n    }\n    for(int i=0;i<h;i++){\n        if(odw[i]==0){\n            for(int j=0;j<h;j++){\n                if(i!=j&&odw[j]==0&&abs(tab1[j]-tab1[i])>2&&sito[abs(tab1[j]-tab1[i])]==0){\n                    wynik++;\n                    odw[i]=1;odw[j]=1;\n                }\n            }\n        }\n    }\n    for(int i=0;i<h;i++){\n        if(odw[i]==0){\n            for(int j=0;j<h;j++){\n                if(i!=j&&odw[j]==0&&abs(tab1[j]-tab1[i])%2==0){\n                    wynik+=2;\n                    odw[i]=1;odw[j]=1;\n                }\n            }\n        }\n    }\n    for(int i=0;i<h;i++){\n        if(odw[i]==0){\n            for(int j=0;j<h;j++){\n                if(i!=j&&odw[j]==0&&abs(tab1[j]-tab1[i])%2==1){\n                    wynik+=3;\n                    odw[i]=1;odw[j]=1;\n                }\n            }\n        }\n    }\n    for(int i=0;i<h;i++){\n        if(odw[i]==0){\n            odw[i]=1;\n            wynik+=3;\n        }\n    }\n    printf(\"%d\\n\",wynik);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n\n#include <iostream>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <unordered_set>\n#include <queue>\n#include <set>\n#include <algorithm>\n#include <numeric>\n#include <list>\nusing namespace std;\n\nusing QWORD  = uint64_t;\nusing SQWORD = int64_t;\nusing DWORD  = uint32_t;\nusing SDWORD = int32_t;\nusing WORD   = uint16_t;\nusing SWORD  = int16_t;\nusing BYTE   = uint8_t;\nusing SBYTE  = int8_t;\nusing DOUBLE = double;\nusing FLOAT  = float;\n\n#define MIN_SDWORD (-2147483648)\n#define MAX_SDWORD (2147483647)\n#define MIN_SBYTE (-128)\n#define MAX_SBYTE (127)\n\n#define MIN_SQWORD (0x8000000000000000)\n#define MAX_SQWORD (0x7FFFFFFFFFFFFFFF)\n\n#define MAX_QWORD  (0xFFFFFFFFFFFFFFFF)\n#define MAX_DWORD  (0xFFFFFFFF)\n#define MAX_WORD   (0xFFFF)\n#define MAX_BYTE   (0xFF)\n\n#define MAX_DOUBLE      (1.0e+308)\n#define DOUBLE_EPS      (1.0e-12)\n#define MIN_DOUBLE_N    (-1.0e+308)\n\n#define ArrayLength(a)  (sizeof(a) / sizeof(a[0]))\n\nstatic inline DOUBLE MAX(DOUBLE a, DOUBLE b) { return a > b ? a : b; }\nstatic inline QWORD MAX(QWORD a, QWORD b) { return a > b ? a : b; }\nstatic inline DWORD MAX(DWORD a, DWORD b) { return a > b ? a : b; }\nstatic inline SDWORD MAX(SDWORD a, SDWORD b) { return a > b ? a : b; }\nstatic inline DOUBLE MIN(DOUBLE a, DOUBLE b) { return a < b ? a : b; }\nstatic inline QWORD MIN(QWORD a, QWORD b) { return a < b ? a : b; }\nstatic inline DWORD MIN(DWORD a, DWORD b) { return a < b ? a : b; }\nstatic inline SDWORD MIN(SDWORD a, SDWORD b) { return a < b ? a : b; }\nstatic inline DOUBLE ABS(DOUBLE a) { return 0 < a ? a : -a; };\n\n#define BYTE_BITS   (8)\n#define WORD_BITS   (16)\n#define DWORD_BITS  (32)\n#define QWORD_BITS  (64)\n\nstatic inline void inputStringSpSeparated(char *pcStr)\n{\n    char *pcCur = pcStr;\n    for (;;) {\n        char c = getchar();\n        if (('\\n' == c) || (EOF == c) || (' ' == c)) {\n            break;\n        }\n        *pcCur = c;\n        pcCur++;\n    }\n    *pcCur = '\\0';\n}\n\nstatic inline void inputString(char *pcStr)\n{\n    char *pcCur = pcStr;\n    for (;;) {\n        char c = getchar();\n        if (('\\n' == c) || (EOF == c)) {\n            break;\n        }\n        *pcCur = c;\n        pcCur++;\n    }\n    *pcCur = '\\0';\n}\n\n\nstatic inline SQWORD inputSQWORD(void)\n{\n    SQWORD sqNumber = 0;\n    SQWORD sqMultiplier = 1;\n    bool bRead = false;\n    for (;;) {\n        char c = getchar();\n        if (!bRead) {\n            if ('-' == c) {\n                sqMultiplier = -1;\n            }\n        }\n        if (('0' <= c) && (c <= '9')) {\n            sqNumber *= 10LL;\n            sqNumber += (SQWORD)(c - '0');\n            bRead = true;\n        } else {\n            if (bRead) {\n                return sqNumber * sqMultiplier;\n            }\n        }\n    }\n}\n\n\nstatic inline SDWORD inputSDWORD(void)\n{\n    SDWORD lNumber = 0;\n    SDWORD lMultiplier = 1;\n    bool bRead = false;\n    for (;;) {\n        char c = getchar();\n        if (!bRead) {\n            if ('-' == c) {\n                lMultiplier = -1;\n            }\n        }\n        if (('0' <= c) && (c <= '9')) {\n            lNumber *= 10;\n            lNumber += (c - '0');\n            bRead = true;\n        } else {\n            if (bRead) {\n                return lNumber * lMultiplier;\n            }\n        }\n    }\n}\n\nstatic inline DOUBLE inputFP(void)\n{\n    DOUBLE dInt = 0.0;\n    DOUBLE dFrac = 0.0;\n    DOUBLE dMultiplier = 1.0;\n    DWORD dwFpCnt = 0;\n    DOUBLE *pdCur = &dInt;\n    bool bRead = false;\n    for (;;) {\n        char c = getchar();\n        if (!bRead) {\n            if ('-' == c) {\n                dMultiplier = -1;\n            }\n        }\n        if ('.' == c) {\n            pdCur = &dFrac;\n        } else if (('0' <= c) && (c <= '9')) {\n            (*pdCur) *= 10;\n            (*pdCur) += (DOUBLE)(c - '0');\n            bRead = true;\n            if (pdCur == &dFrac) {\n                dwFpCnt++;\n            }\n        } else {\n            if (bRead) {\n                return dMultiplier * (dInt + dFrac / (pow((DOUBLE)10.0 , (DOUBLE)dwFpCnt)));\n            }\n        }\n    }\n}\n\n\n/**\n *  mod による操作ライブラリ\n */\n\n#define ANS_MOD (1000000007LL)\n \nstatic SQWORD addMod(SQWORD x, SQWORD y)\n{ \n    return (x + y) % ANS_MOD;\n}\n \nstatic SQWORD subMod(SQWORD x, SQWORD y)\n{\n    return (x - y + ANS_MOD) % ANS_MOD;\n}\n \nstatic SQWORD mulMod(SQWORD x, SQWORD y) \n{\n    return (x * y) % ANS_MOD;\n}\n \nstatic SQWORD powMod(SQWORD x, SQWORD e) {\n    SQWORD v = 1;\n    for (; e; x = mulMod(x, x), e >>= 1) {\n        if (e & 1) {\n            v = mulMod(v, x);\n        }\n    }\n    return v;\n}\n \nstatic SQWORD divMod(SQWORD x, SQWORD y)\n{\n    return mulMod(x, powMod(y, ANS_MOD - 2));\n}\n \n \nstatic SQWORD combMod(SQWORD n, SQWORD k)\n{\n    SQWORD v=1;\n    for(SQWORD i=1; i<=k; i++) {\n        v = divMod(mulMod(v, n-i+1),i);\n    } \n    return v;\n}\n\n/*----------------------------------------------*/\n\ntypedef struct {\n    SDWORD lTo;\n    SQWORD sqCap;\n    SQWORD sqCost;\n    SDWORD lRev;\n} ST_EDGE;\n\n#define MAX_V   (402)\n\nstruct Flow {\nprivate:\n    vector<ST_EDGE> avGraph[MAX_V];\n    SDWORD  alDimsFrom[MAX_V];\n    SDWORD  alDimsTo[MAX_V];\n    SQWORD  sqEdgeNum;\n    SQWORD  asqDist[MAX_V];\n    SDWORD  alPrevV[MAX_V];   \n    SDWORD  alPrevEdge[MAX_V];      /*直前の頂点と辺 */\n\n    SDWORD  alDinic_Level[MAX_V];\n    SDWORD  alDinic_Iter[MAX_V];\n\npublic:\n    Flow() {\n        for (auto v: avGraph) {\n            v.clear();\n        }\n        memset(alDimsFrom, 0, sizeof(alDimsFrom));\n        memset(alDimsTo, 0, sizeof(alDimsTo));\n        memset(asqDist, 0, sizeof(asqDist));\n        memset(alPrevV, 0, sizeof(alPrevV)); \n        memset(alPrevEdge, 0, sizeof(alPrevEdge));\n        memset(alDinic_Level, 0, sizeof(alDinic_Level));\n        memset(alDinic_Iter, 0, sizeof(alDinic_Iter));\n    }\n    void addEdge(SDWORD lFrom, SDWORD lTo, SQWORD sqCap, SQWORD sqCost) {\n//        printf(\"%d ----[%lld] ----> %d\\n\", lFrom, sqCap, lTo);\n        \n        alDimsFrom[lFrom]++;\n        alDimsTo[lTo]++;\n        avGraph[lFrom].push_back((ST_EDGE){lTo, sqCap, sqCost, (SDWORD)(avGraph[lTo].size())});\n        avGraph[lTo].push_back((ST_EDGE){lFrom, 0, -sqCost, (SDWORD)(avGraph[lFrom].size() - 1)});\n    }\n\n    SDWORD minCostFlow(SDWORD lStart, SDWORD lTarget, SQWORD sqFlow)\n    {\n        SQWORD sqRes = 0;\n        SQWORD sqFlowRest = sqFlow;\n        while (0 < sqFlowRest) {\n            /* Bellman-Ford Method */\n            fill(asqDist, asqDist + ArrayLength(asqDist), MAX_SDWORD);\n            asqDist[lStart] = 0;\n            bool bIsUpdate = true;\n            while (bIsUpdate) {\n                bIsUpdate = false;\n                for (SDWORD lV = 0; lV < MAX_V; lV++) {\n                    for (SDWORD lIdx = 0; lIdx < avGraph[lV].size(); lIdx++) {\n                        ST_EDGE &stE = avGraph[lV][lIdx];\n                        if ((asqDist[lV] != MAX_SDWORD)\n                                && (0 < stE.sqCap)\n                                && (asqDist[lV] + stE.sqCost < asqDist[stE.lTo])) {\n                            asqDist[stE.lTo] = asqDist[lV] + stE.sqCost;\n                            alPrevV[stE.lTo] = lV;\n                            alPrevEdge[stE.lTo] = lIdx;\n                            bIsUpdate = true;\n                        }\n                    }\n                }\n            }\n            if (asqDist[lTarget] == MAX_SDWORD) {\n                return -1;\n            }\n\n            SQWORD sqAddFlow = MAX_SQWORD;\n            for (SDWORD lV = lTarget; lV != lStart; lV = alPrevV[lV]) {\n                sqAddFlow = min(sqAddFlow, avGraph[alPrevV[lV]][alPrevEdge[lV]].sqCap);\n            }\n            sqFlowRest -= sqAddFlow;\n            sqRes += sqAddFlow * asqDist[lTarget];      // 後で目的変数は書き換える\n            for (SDWORD lV = lTarget; lV != lStart; lV = alPrevV[lV]) {\n                ST_EDGE &stE = avGraph[alPrevV[lV]][alPrevEdge[lV]];\n                stE.sqCap -= sqAddFlow;\n                avGraph[lV][stE.lRev].sqCap += sqAddFlow;\n            }\n        }\n        return sqRes;\n    }\n\nprivate:\n    SQWORD maxFlowDinicBfs(SDWORD lS)\n    {\n        memset(alDinic_Level, -1, sizeof(alDinic_Level));\n        queue<SDWORD> queSearch;\n        alDinic_Level[lS] = 0;\n        queSearch.push(lS);\n        while (!queSearch.empty()) {\n            SDWORD lV = queSearch.front();\n            queSearch.pop();\n            for (SDWORD lIdx = 0; lIdx < avGraph[lV].size(); lIdx++) {\n                ST_EDGE &stE = avGraph[lV][lIdx];\n                if ((0 < stE.sqCap) && (alDinic_Level[stE.lTo] < 0)) {\n                    alDinic_Level[stE.lTo] = alDinic_Level[lV] + 1;\n                    queSearch.push(stE.lTo);\n                }\n            }\n        }\n\n        return 0;\n    }\n\n    SQWORD maxFlowDinicDfs(SDWORD lV, SDWORD lT, SQWORD sqF)\n    {\n        if (lV == lT) {\n            return sqF;\n        }\n        for (SDWORD &lI = alDinic_Iter[lV]; lI < avGraph[lV].size(); lI++) {\n            ST_EDGE &stE = avGraph[lV][lI];\n            if ((0 < stE.sqCap) && (alDinic_Level[lV] < alDinic_Level[stE.lTo])) {\n                SQWORD sqDiffFlow = maxFlowDinicDfs(stE.lTo, lT, min(sqF, stE.sqCap));\n                if (0 < sqDiffFlow) {\n                    stE.sqCap -= sqDiffFlow;\n                    avGraph[stE.lTo][stE.lRev].sqCap += sqDiffFlow;\n                    return sqDiffFlow;\n                }\n            }\n        }\n        return 0;\n    }\n\npublic:\n    SQWORD MaxFlow(SDWORD lStart, SDWORD lTarget)\n    {\n        SQWORD sqFlow = 0LL;\n        for (;;) {\n            maxFlowDinicBfs(lStart);\n            if (alDinic_Level[lTarget] < 0) {\n                return sqFlow;\n            }\n            memset(alDinic_Iter, 0, sizeof(alDinic_Iter));\n            while (1) {\n                SQWORD sqDiffFlow = maxFlowDinicDfs(lStart, lTarget, MAX_SQWORD);\n                sqFlow += sqDiffFlow;\n                if (0LL == sqDiffFlow) {\n                    break;\n                }\n            }\n        }\n    }\n\n    SQWORD getFlow(SDWORD lPnt, bool bFrom)\n    {\n        SQWORD sqCapSum = 0; \n        for (auto e: avGraph[lPnt]) {\n            sqCapSum += e.sqCap;\n        }\n        if (bFrom) {\n            return alDimsFrom[lPnt] - sqCapSum;\n        } else {\n            return alDimsTo[lPnt] - sqCapSum;\n        }\n    }\n};\n\n/*----------------------------------------------*/\n\nstatic void getPrimes(vector<SDWORD> &vlPrimes, SDWORD lMax)\n{\n    /* lSearchMax と ループ内の *2 の関係から、入力は3以上とすること */\n    if (!(1 <= lMax)) {\n        printf(\"Oops!\");\n        return;\n    }\n\n    /* 素数のリストを作る */\n    vector<bool> vbIsPrime(lMax + 1, true);\n    SDWORD lSearchMax = sqrt(lMax) + 1;\n    vbIsPrime[0] = false;\n    vbIsPrime[1] = false;\n    for (SDWORD lPrime = 2; lPrime < vbIsPrime.size(); lPrime++) {\n        if (vbIsPrime[lPrime]) {\n            vlPrimes.emplace_back(lPrime);\n            if (lPrime <= lSearchMax) {\n                for (SDWORD lCurNum = lPrime * 2; lCurNum <= lMax; lCurNum += lPrime) {\n                    vbIsPrime[lCurNum] = false;\n                }\n            }\n        }\n    }\n}    \n\n/*----------------------------------------------*/\n\n#define PNT_NO_START    (0)\n#define PNT_NO_OFFSET   (200)\n#define PNT_NO_TARGET   (401)\n#define FLOW_OFFSET     (1000000000)\n#define CAPACITY_INF    (1000000001)\n#define DUMMY_COST      (1)\n\nint main(void)\n{\n    SQWORD sqN = inputSQWORD();\n\n    Flow solverFlow;\n    vector<SQWORD> vsqA;\n    vector<SQWORD> vsqB;\n    vector<SDWORD> vlPrimes;\n\n    getPrimes(vlPrimes, 1e7 + 1);\n    vlPrimes.erase(find(vlPrimes.begin(), vlPrimes.end(), 2));\n\n    for (SQWORD sqIdx = 0; sqIdx < sqN; sqIdx++) {\n        SQWORD sqA = inputSQWORD();\n        vsqA.emplace_back(sqA);\n    }\n\n#if 1\n    for (auto it = vsqA.begin(); it != vsqA.end(); ++it) {\n//        printf(\"%lld %lld\\n\", *it, *(it - 1));\n        if (it == vsqA.begin()) {\n            vsqB.emplace_back(*it);\n        } else {\n            if ((*it) - 1 != *(it - 1)) {\n                vsqB.emplace_back(*it);\n            }\n        }\n        if (it == vsqA.end() - 1) {\n            vsqB.emplace_back((*it) + 1);\n        } else {\n            if ((*it) + 1 != *(it + 1)) {\n                vsqB.emplace_back((*it) + 1);\n            }\n        }\n    }\n#else\n    vsqB = vsqA;\n#endif\n\n    vector<SQWORD> vsqCOdd;\n    vector<SQWORD> vsqCEven;\n    \n    unordered_map<SQWORD, SQWORD> mapCEven, mapCOdd;\n\n    SQWORD sqIdx = 1;\n    for (auto b: vsqB) {\n        if (0 == b % 2) {\n            vsqCEven.emplace_back(b);\n            mapCEven[b] = sqIdx;\n        } else {\n            vsqCOdd.emplace_back(b);\n            mapCOdd[b] = sqIdx;\n        }\n        sqIdx++;\n    }\n\n    /* 二部マッチング */\n    for (auto c: vsqCEven) {\n        solverFlow.addEdge(PNT_NO_START, mapCEven[c], 1, DUMMY_COST);\n    }\n    for (auto c: vsqCEven) {\n        solverFlow.addEdge(mapCOdd[c] + PNT_NO_OFFSET, PNT_NO_TARGET, 1, DUMMY_COST);\n    }\n\n    for (auto p: vlPrimes) {\n        for (auto c: vsqCEven) {\n            auto it = lower_bound(vsqCOdd.begin(), vsqCOdd.end(), c + p);\n            if (it != vsqCOdd.end()) {\n                if (*it == c + p) {\n                    if (c + p < 1e7 + 1) {\n                        solverFlow.addEdge(mapCEven[c], mapCOdd[c + p] + PNT_NO_OFFSET, 1, DUMMY_COST);\n                    }\n                }\n            }\n        }\n        for (auto c: vsqCOdd) {\n            auto it = lower_bound(vsqCEven.begin(), vsqCEven.end(), c + p);\n            if (it != vsqCEven.end()) {\n                if (*it == c + p) {\n                    if (c + p < 1e7 + 1) {\n                        solverFlow.addEdge(mapCEven[c + p], mapCOdd[c] + PNT_NO_OFFSET, 1, DUMMY_COST);\n                    }\n                }\n            }\n        }\n    }\n\n\n\n    SQWORD sqMaxFlow = solverFlow.MaxFlow(PNT_NO_START, PNT_NO_TARGET);\n    SQWORD vsqCRestEven = 0;\n    SQWORD vsqCRestOdd = 0;\n    for (auto c: vsqCEven) {\n        SQWORD sqFlow = solverFlow.getFlow(mapCEven[c], true);\n        if (0 == sqFlow) {\n            vsqCRestEven++;\n        }\n    }\n    for (auto c: vsqCOdd) {\n        SQWORD sqFlow = solverFlow.getFlow(mapCOdd[c] + PNT_NO_OFFSET, false);\n        if (0 == sqFlow) {\n            vsqCRestOdd++;\n        }\n    }\n\n    SQWORD sqAns = sqMaxFlow;    \n    sqAns += ((vsqCRestEven / 2) * 2);\n    sqAns += ((vsqCRestOdd / 2) * 2);\n    if (0 < (vsqCRestEven %  2)) {\n        sqAns += 3;\n    }\n\n    printf(\"%lld\\n\", sqAns);\n\n    return 0;\n}\n/*------------------------------------------*/\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <queue>\n#define file(x) freopen(#x\".in\", \"r\", stdin), freopen(#x\".out\", \"w\", stdout)\n\ninline int read()\n{\n\tint data = 0, w = 1; char ch = getchar();\n\twhile (ch != '-' && (ch < '0' || ch > '9')) ch = getchar();\n\tif (ch == '-') w = -1, ch = getchar();\n\twhile (ch >= '0' && ch <= '9') data = data * 10 + (ch ^ 48), ch = getchar();\n\treturn data * w;\n}\n\nconst int N(105), LIM(1e7), M(LIM + 10), INF(0x3f3f3f3f);\nstruct edge { int next, to, cap; } e[N * N * 2];\nint n, a[M], head[N], e_num = -1, cnt, L[N], R[N], cntl, cntr;\nint lev[N], cur[N], S, T, not_prime[M], prime[M];\ninline int Abs(int x) { return x < 0 ? -x : x; }\ninline void Add(int from, int to, int cap)\n{\n\te[++e_num] = (edge) {head[from], to, cap}, head[from] = e_num;\n\te[++e_num] = (edge) {head[to], from,  0 }, head[to]   = e_num;\n}\n\nvoid Init()\n{\n\tnot_prime[1] = 1;\n\tfor (int i = 2; i <= LIM; i++)\n\t{\n\t\tif (!not_prime[i]) prime[++cnt] = i;\n\t\tfor (int j = 1; j <= cnt && 1ll * i * prime[j] <= LIM; j++)\n\t\t{\n\t\t\tnot_prime[i * prime[j]] = 1;\n\t\t\tif (!(i % prime[j])) break;\n\t\t}\n\t}\n}\n\nint bfs()\n{\n\tstd::queue<int> Q; Q.push(S);\n\tmemset(lev, 0, (T + 1) << 2), lev[S] = 1;\n\twhile (!Q.empty())\n\t{\n\t\tint x = Q.front(); Q.pop();\n\t\tfor (int i = head[x]; ~i; i = e[i].next)\n\t\t{\n\t\t\tint to = e[i].to; if (lev[to] || !e[i].cap) continue;\n\t\t\tlev[to] = lev[x] + 1, Q.push(to);\n\t\t}\n\t}\n\treturn lev[T];\n}\n\nint dfs(int x, int f)\n{\n\tif (x == T || !f) return f;\n\tint ans = 0, cap;\n\tfor (int &i = cur[x]; ~i; i = e[i].next)\n\t{\n\t\tint to = e[i].to;\n\t\tif (lev[to] == lev[x] + 1 && e[i].cap)\n\t\t{\n\t\t\tcap = dfs(to, std::min(f - ans, e[i].cap));\n\t\t\te[i].cap -= cap, e[i ^ 1].cap += cap, ans += cap;\n\t\t\tif (ans == f) break;\n\t\t}\n\t}\n\tif (!ans) lev[x] = 0;\n\treturn ans;\n}\n\nint Dinic()\n{\n\tint ans = 0;\n\twhile (bfs()) memcpy(cur, head, (T + 1) << 2), ans += dfs(S, INF);\n\treturn ans;\n}\n\nint main()\n{\n\tInit(), n = read(), memset(head, -1, sizeof head);\n\tfor (int i = 1; i <= n; i++) ++a[read()];\n\tfor (int i = 0; i <= LIM; i++) if (a[i] != a[i + 1])\n\t\t(i & 1) ? R[++cntr] = i + 1 : L[++cntl] = i + 1;\n\tS = 0, T = cntl + cntr + 1;\n\tfor (int i = 1; i <= cntl; i++) Add(S, i, 1);\n\tfor (int i = 1; i <= cntr; i++) Add(i + cntl, T, 1);\n\tfor (int i = 1; i <= cntl; i++) for (int j = 1; j <= cntr; j++)\n\t\tif (!not_prime[Abs(L[i] - R[j])]) Add(i, j + cntl, 1);\n\tint f = Dinic(), ans = f, tl = cntl - f, tr = cntr - f;\n\tans += tl - (tl & 1) + tr - (tr & 1), ans += 3 * (tl & 1);\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#include<bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n\n#define F first\n#define S second\n#define int long long\n#define ll long long\n//#define int  unsigned long long\n#define pb push_back\n//#define double long double\n\nusing namespace std;\nusing namespace __gnu_pbds;\ntypedef  tree< int , null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> ordered_set;\nconst int mod = 1e9 + 7;\nconst int N = 1000;\nstruct Edge {\n    int from, to, f, c, w;\n};\nvector < Edge >  edges;\nvector < int > g[N];\nint n, d[N], f[N], b[N][N];\nint p[N];\nvoid add(int a, int b, int c, int w){\n    Edge e;\n    e.from = a; e.to = b; e.c = c; e.w = w; e.f = 0;\n    edges.pb(e);\n  //  cout << a << \" \" << b << \" \" << c << \" \" << w << endl;\n    g[a].pb(edges.size() - 1);\n    e.w = -e.w; e.c = 0; swap(e.from, e.to);\n    edges.pb(e);\n    g[b].pb(edges.size() - 1);\n}\nbool spfa(int s, int t){\n    for (int i = 1; i < N; i++){\n        d[i] = 1e9;\n        f[i] = 0;\n    }\n    queue < int > q;\n    q.push(s);\n    d[s] = 0;\n    f[s] = 1;\n    while(!q.empty()){\n        int v = q.front();\n        q.pop();\n        f[v] = 0;\n        for (int i = 0; i < g[v].size(); i++){\n            Edge e = edges[g[v][i]];\n            if (e.f < e.c && d[e.to] > d[v] + e.w){\n                p[e.to] = g[v][i];\n                d[e.to] = d[v] + e.w;\n                if (!f[e.to])\n                    q.push(e.to);\n                f[e.to] = 1;\n            }\n        }\n    }\n    return d[t] != 1e9;\n}\nint flow(int s, int t){\n    int cost = 0;\n    while(spfa(s, t)){\n        int v = t;\n        while(v != s && v != 0){\n            auto k = p[v];\n            edges[k].f++;\n            edges[k ^ 1].f--;\n            cost += edges[k].w;\n            v = edges[k].from;\n        }\n    }\n    return cost;\n}\nint mx[N], mn[N];\nint ff(int x){\n    if (x == 2) return 2;\n    if (x == 1) return 3;\n    int pr = 1;\n    for (int i = 2; i * i <= x; i++){\n        if (x % i == 0) pr = 0;\n    }\n    if (pr) return 1;\n    return 2 + (x % 2);\n}\nint usedd[N];\nvector < int > gr[N];\nvoid dfss(int v){\n    usedd[v] = 1;\n    for (auto u: gr[v]){\n        if (usedd[u]) continue;\n        dfss(u);\n    }\n}\nmain(){\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    //freopen(\"input.txt\", \"r\", stdin);\n    cin >> n;\n    int p = -1;\n    vector < int > a;\n    for (int i = 1; i <= n; i++){\n        int x;\n        cin >> x;\n        if (x != p + 1){\n            if (p != -1) a.pb(p + 1);\n            a.pb(x);\n        }\n        p = x;\n    }\n    a.pb(p + 1);\n    n = a.size();\n    int cnt = 0;\n    for (int i = 0; i < a.size(); i++){\n        add(2 * n + 1, i + 1, 1, 0);\n        add(n + i + 1, 2 * n + 2, 1, 0);\n        if (a[i] % 2) cnt++;\n        for (int j = i + 1; j < a.size(); j++){\n            if (i == j) continue;\n            int x = a[i];\n            int y = a[j];\n            if (ff(abs(x - y)) == 1){\n                add(i + 1, n + j + 1, 1, 1);\n            }\n            if (ff(abs(x - y)) != 3){\n                gr[i + 1].pb(j + 1);\n                gr[j + 1].pb(i + 1);\n            }\n        }\n    }\n    n = 2 * n + 2;\n    int ans = flow(n - 1, n);\n    dfss(1);\n    int k = 0;\n    n = (n - 2) / 2;\n    if ((cnt - ans) % 2){\n        ans = ans + (n - 2 * ans) / 2 * 2 + 1;\n    } else{\n        ans = ans + (n - 2 * ans) / 2 * 2;\n    }\n    cout << ans;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MAXV = 10000100;\n\nbool np[MAXV];\n\nvoid precalc() {\n   np[0] = np[1] = true;\n   for (int i = 2; i < MAXV; ++i) {\n      if (np[i]) continue;\n      for (int j = i + i; j < MAXV; j += i) {\n         np[j] = true;\n      }\n   }\n}\n\nint main() {\n   ios_base::sync_with_stdio(false);\n   precalc();\n   int N;\n   cin >> N;\n   vector<int> X(N);\n   for (int i = 0; i < N; ++i) {\n      cin >> X[i];\n   }\n   {\n      vector<int> newX;\n      newX.emplace_back(X[0]);\n      for (int i = 0; i + 1 < N; ++i) {\n         if (X[i] + 1 != X[i + 1]) {\n            newX.emplace_back(X[i] + 1);\n            newX.emplace_back(X[i + 1]);\n         }\n      }\n      newX.emplace_back(X.back() + 1);\n      X = newX;\n      N = X.size();\n   }\n   vector<int> odds;\n   vector<int> evens;\n   for (int i = 0; i < N; ++i) {\n      if (X[i] & 1) {\n         odds.emplace_back(X[i]);\n      } else {\n         evens.emplace_back(X[i]);\n      }\n   }\n   int no = odds.size();\n   int ne = evens.size();\n   vector<vector<int>> adj(no);\n   vector<int> mt(ne, -1);\n   vector<int> visited(no);\n   for (int i = 0; i < no; ++i) {\n      for (int j = 0; j < ne; ++j) {\n         if (!np[abs(odds[i] - evens[j])]) {\n            adj[i].emplace_back(j);\n         }\n      }\n   }\n   int tt = 0;\n   function<bool(int)> dfs = [&](int v) {\n      if (visited[v] == tt) return false;\n      visited[v] = tt;\n      for (int u : adj[v]) {\n         if (mt[u] == -1) {\n            mt[u] = v;\n            return true;\n         }\n      }\n      for (int u : adj[v]) {\n         if (dfs(mt[u])) {\n            mt[u] = v;\n            return true;\n         }\n      }\n      return false;\n   };\n   int ans = 0;\n   for (int i = 0; i < no; ++i) {\n      ++tt;\n      ans += dfs(i);\n   }\n   no -= ans;\n   ne -= ans;\n   ans += 2 * (no / 2);\n   ans += 2 * (ne / 2);\n   if (no & 1) ans += 3;\n   cout << ans << \"\\n\";\n   return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 10000001;\n\n\nint n,fre[maxn],p[220],ispr[maxn],even,odd,wrong;\nvector <int> edge[220],v2;\n\nbool fin(int u) {\n    if (fre[u]==wrong) return false;\n    fre[u]=wrong;\n    for (int j=0;j<edge[u].size();j++) {\n        int v=edge[u][j];\n       // cout<<u<<\" \"<<v<<endl;\n        if (p[v]==0 || fin(p[v])) {\n            p[v]=u;\n            p[u]=v;\n            return true;\n        }\n    }\n    return false;\n}\n\nint main() {\n    //freopen(\"in.txt\",\"r\",stdin);\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    ispr[1]=1;\n    for (int i=2;i<maxn;i++)\n        if (ispr[i]==0) {\n            for (int j=i+i;j<maxn;j+=i) ispr[j]=1;\n        }\n    cin>>n;\n    for (int i=1;i<=n;i++) {\n        int x;\n        cin>>x;\n        fre[x]^=1;\n        fre[x+1]^=1;\n    }\n    even=0; odd=0; wrong=2;\n    for (int i=0;i<maxn;i++)\n        if (fre[i]==1) {\n            v2.push_back(i);\n            if (i%2==0) even++;\n            else odd++;\n        }\n    // for (int i=0;i<v2.size();i++) cout<<v2[i]<<\" \";\n   //  cout<<endl;\n   // cout<<\" \" <<even<<\" \"<<odd<<endl;\n    for (int i=0;i<v2.size();i++)\n        for (int j=0;j<v2.size();j++)\n            if (v2[i]%2==0 && v2[j]%2==1 && ispr[ v2[j] - v2[i] ]==0) {\n              //  cout<<i<<\" \"<<j<<\" \"<<v2[i]<<\" \"<<v2[j]<<endl;\n                edge[i+1].push_back(j+1);\n                edge[j+1].push_back(i+1);\n            }\n    int cnt=0;\n    for (int i=0;i<v2.size();i++)\n     if (p[i+1]==0) {\n        wrong++;\n        p[i+1]=i+1;\n        //cout<<fin(i+1)<<endl;\n        cnt+=(fin(i+1));\n       // cout<<p[i+1]<<endl;\n      //  cout<<\"fuck\"<<endl;\n    }\n   // cout<<cnt<<\" \" <<even<<\" \"<<odd<<endl;\n    cout<< cnt + ((even-cnt)/2 + (odd-cnt)/2) * 2 + (even%2)*3;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 205;\nconst int MAXM = 10000005;\nint n, x[MAXN], f[MAXM], p[MAXM], cnt, match[MAXN], w[MAXN][MAXN];\nbool ip[MAXM], used[MAXN];\nvoid pre(int N) {\n\tfor(int i = 2; i <= N; ++i) {\n\t\tif(!ip[i]) p[++cnt] = i;\n\t\tfor(int j = 1; j <= cnt && p[j]*i <= N; ++j) {\n\t\t\tip[p[j]*i] = 1;\n\t\t\tif(i % p[j] == 0) break;\n\t\t}\n\t}\n}\nbool vis[MAXN];\nbool dfs(int u) {\n\tfor(int v = 1; v <= n; ++v)\n\t\tif(w[u][v] && !vis[v]) {\n\t\t\tvis[v] = 1;\n\t\t\tif(!match[v] || dfs(match[v])) {\n\t\t\t\tmatch[v] = u;\n\t\t\t\tmatch[u] = v;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\treturn 0;\n}\nvoid maxmatch() {\n\tfor(int i = 1; i <= n; ++i)\n\t\tif(!used[i] && (x[i]&1)) {\n\t\t\tmemset(vis,0,sizeof vis);\n\t\t\tdfs(i);\n\t\t}\n}\nint main () {\n\tscanf(\"%d\", &n);\n\tfor(int i = 1,y; i <= n; ++i) scanf(\"%d\", &y), f[y] = 1;\n\tfor(int i = 10000001; i >= 1; --i) f[i] ^= f[i-1];\n\tn = 0;\n\tfor(int i = 1; i <= 10000001; ++i) if(f[i]) x[++n] = i;\n\tpre(10000001); ip[2] = 1;\n\tfor(int i = 1; i <= n; ++i)\n\t\tfor(int j = i+1; j <= n; ++j)\n\t\t\tif(!vis[abs(x[i]-x[j])])\n\t\t\t\tw[i][j] = w[j][i] = 1;\n\t\t\telse w[i][j] = w[j][i] = 0;\n\tmaxmatch();\n\tint ans = 0;\n\tfor(int i = 1; i <= n; ++i)\n\t\tif(match[i] && !used[i]) {\n\t\t\t++ans;\n\t\t\tused[i] = used[match[i]] = 1;\n\t\t}\n\tint c1 = 0, c2 = 0;\n\tfor(int i = 1; i <= n; ++i)\n\t\tif(!used[i]) (x[i] & 1) ? ++c1 : ++c2;\n\tans += 2*(c1/2) + 2*(c2/2) + (c1&1)*3;\n\tprintf(\"%d\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define INF INT_MAX\n#define MAXN 205\nstruct edge{\n    int u,v,w;\n    edge(){}\n    edge(int u,int v,int w):u(u),v(v),w(w){}\n};\nint n,n_x;\nedge g[MAXN*2+1][MAXN*2+1];\nint lab[MAXN*2+1];\nint match[MAXN*2+1],slack[MAXN*2+1],st[MAXN*2+1],pa[MAXN*2+1];\nint flower_from[MAXN*2+1][MAXN+1],S[MAXN*2+1],vis[MAXN*2+1];\nvector<int> flower[MAXN*2+1];\nqueue<int> q;\ninline int e_delta(const edge &e){ // does not work inside blossoms\n    return lab[e.u]+lab[e.v]-g[e.u][e.v].w*2;\n}\ninline void update_slack(int u,int x){\n    if(!slack[x]||e_delta(g[u][x])<e_delta(g[slack[x]][x]))slack[x]=u;\n}\ninline void set_slack(int x){\n    slack[x]=0;\n    for(int u=1;u<=n;++u)\n        if(g[u][x].w>0&&st[u]!=x&&S[st[u]]==0)update_slack(u,x);\n}\nvoid q_push(int x){\n    if(x<=n)q.push(x);\n    else for(size_t i=0;i<flower[x].size();i++)q_push(flower[x][i]);\n}\ninline void set_st(int x,int b){\n    st[x]=b;\n    if(x>n)for(size_t i=0;i<flower[x].size();++i)\n               set_st(flower[x][i],b);\n}\ninline int get_pr(int b,int xr){\n    int pr=find(flower[b].begin(),flower[b].end(),xr)-flower[b].begin();\n    if(pr%2==1){//檢查他在前一層圖是奇點還是偶點\n        reverse(flower[b].begin()+1,flower[b].end());\n        return (int)flower[b].size()-pr;\n    }else return pr;\n}\ninline void set_match(int u,int v){\n    match[u]=g[u][v].v;\n    if(u>n){\n        edge e=g[u][v];\n        int xr=flower_from[u][e.u],pr=get_pr(u,xr);\n        for(int i=0;i<pr;++i)set_match(flower[u][i],flower[u][i^1]);\n        set_match(xr,v);\n        rotate(flower[u].begin(),flower[u].begin()+pr,flower[u].end());\n    }\n}\ninline void augment(int u,int v){\n    for(;;){\n        int xnv=st[match[u]];\n        set_match(u,v);\n        if(!xnv)return;\n        set_match(xnv,st[pa[xnv]]);\n        u=st[pa[xnv]],v=xnv;\n    }\n}\ninline int get_lca(int u,int v){\n    static int t=0;\n    for(++t;u||v;swap(u,v)){\n        if(u==0)continue;\n        if(vis[u]==t)return u;\n        vis[u]=t;//這種方法可以不用清空v陣列\n        u=st[match[u]];\n        if(u)u=st[pa[u]];\n    }\n    return 0;\n}\ninline void add_blossom(int u,int lca,int v){\n    int b=n+1;\n    while(b<=n_x&&st[b])++b;\n    if(b>n_x)++n_x;\n    lab[b]=0,S[b]=0;\n    match[b]=match[lca];\n    flower[b].clear();\n    flower[b].push_back(lca);\n    for(int x=u,y;x!=lca;x=st[pa[y]])\n        flower[b].push_back(x),flower[b].push_back(y=st[match[x]]),q_push(y);\n    reverse(flower[b].begin()+1,flower[b].end());\n    for(int x=v,y;x!=lca;x=st[pa[y]])\n        flower[b].push_back(x),flower[b].push_back(y=st[match[x]]),q_push(y);\n    set_st(b,b);\n    for(int x=1;x<=n_x;++x)g[b][x].w=g[x][b].w=0;\n    for(int x=1;x<=n;++x)flower_from[b][x]=0;\n    for(size_t i=0;i<flower[b].size();++i){\n        int xs=flower[b][i];\n        for(int x=1;x<=n_x;++x)\n            if(g[b][x].w==0||e_delta(g[xs][x])<e_delta(g[b][x]))\n                g[b][x]=g[xs][x],g[x][b]=g[x][xs];\n        for(int x=1;x<=n;++x)\n            if(flower_from[xs][x])flower_from[b][x]=xs;\n    }\n    set_slack(b);\n}\ninline void expand_blossom(int b){ // S[b] == 1\n    for(size_t i=0;i<flower[b].size();++i)\n        set_st(flower[b][i],flower[b][i]);\n    int xr=flower_from[b][g[b][pa[b]].u],pr=get_pr(b,xr);\n    for(int i=0;i<pr;i+=2){\n        int xs=flower[b][i],xns=flower[b][i+1];\n        pa[xs]=g[xns][xs].u;\n        S[xs]=1,S[xns]=0;\n        slack[xs]=0,set_slack(xns);\n        q_push(xns);\n    }\n    S[xr]=1,pa[xr]=pa[b];\n    for(size_t i=pr+1;i<flower[b].size();++i){\n        int xs=flower[b][i];\n        S[xs]=-1,set_slack(xs);\n    }\n    st[b]=0;\n}\ninline bool on_found_edge(const edge &e){\n    int u=st[e.u],v=st[e.v];\n    if(S[v]==-1){\n        pa[v]=e.u,S[v]=1;\n        int nu=st[match[v]];\n        slack[v]=slack[nu]=0;\n        S[nu]=0,q_push(nu);\n    }else if(S[v]==0){\n        int lca=get_lca(u,v);\n        if(!lca)return augment(u,v),augment(v,u),true;\n        else add_blossom(u,lca,v);\n    }\n    return false;\n}\ninline bool matching(){\n    memset(S+1,-1,sizeof(int)*n_x);\n    memset(slack+1,0,sizeof(int)*n_x);\n    q=queue<int>();\n    for(int x=1;x<=n_x;++x)\n        if(st[x]==x&&!match[x])pa[x]=0,S[x]=0,q_push(x);\n    if(q.empty())return false;\n    for(;;){\n        while(q.size()){\n            int u=q.front();q.pop();\n            if(S[st[u]]==1)continue;\n            for(int v=1;v<=n;++v)\n                if(g[u][v].w>0&&st[u]!=st[v]){\n                    if(e_delta(g[u][v])==0){\n                        if(on_found_edge(g[u][v]))return true;\n                    }else update_slack(u,st[v]);\n                }\n        }\n        int d=INF;\n        for(int b=n+1;b<=n_x;++b)\n            if(st[b]==b&&S[b]==1)d=min(d,lab[b]/2);\n        for(int x=1;x<=n_x;++x)\n            if(st[x]==x&&slack[x]){\n                if(S[x]==-1)d=min(d,e_delta(g[slack[x]][x]));\n                else if(S[x]==0)d=min(d,e_delta(g[slack[x]][x])/2);\n            }\n        for(int u=1;u<=n;++u){\n            if(S[st[u]]==0){\n                if(lab[u]<=d)return 0;\n                lab[u]-=d;\n            }else if(S[st[u]]==1)lab[u]+=d;\n        }\n        for(int b=n+1;b<=n_x;++b)\n            if(st[b]==b){\n                if(S[st[b]]==0)lab[b]+=d*2;\n                else if(S[st[b]]==1)lab[b]-=d*2;\n            }\n        q=queue<int>();\n        for(int x=1;x<=n_x;++x)\n            if(st[x]==x&&slack[x]&&st[slack[x]]!=x&&e_delta(g[slack[x]][x])==0)\n                if(on_found_edge(g[slack[x]][x]))return true;\n        for(int b=n+1;b<=n_x;++b)\n            if(st[b]==b&&S[b]==1&&lab[b]==0)expand_blossom(b);\n    }\n    return false;\n}\ninline pair<long long,int> weight_blossom(){\n    memset(match+1,0,sizeof(int)*n);\n    n_x=n;\n    int n_matches=0;\n    long long tot_weight=0;\n    for(int u=0;u<=n;++u)st[u]=u,flower[u].clear();\n    int w_max=0;\n    for(int u=1;u<=n;++u)\n        for(int v=1;v<=n;++v){\n            flower_from[u][v]=(u==v?u:0);\n            w_max=max(w_max,g[u][v].w);\n        }\n    for(int u=1;u<=n;++u)lab[u]=w_max;\n    while(matching())++n_matches;\n    for(int u=1;u<=n;++u)\n        if(match[u]&&match[u]<u)\n            tot_weight+=g[u][match[u]].w;\n    return make_pair(tot_weight,n_matches);\n}\ninline void init_weight_graph(){\n    for(int u=1;u<=n;++u)\n        for(int v=1;v<=n;++v)\n            g[u][v]=edge(u,v,0);\n}\ninline bool isprime(int x) {\n    if (x < 3) return 0;\n    for (int i = 2 ; i * i <= x ; ++ i) {\n        if (x % i == 0) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    scanf(\"%d\" , &n);\n    set<int> d;\n    map<int , bool> h;\n    for (int i = 0 ; i < n ; ++ i) {\n        int x;\n        scanf(\"%d\" , &x);\n        d.insert(x);\n        d.insert(x - 1);\n        h[x] = 1;\n    }\n    vector<int> v;\n    for (auto &x : d) {\n        if (h[x + 1] ^ h[x]) {\n            v.push_back(x);\n        }\n    }\n    n = v.size();\n    //for (auto &y : v) cout << y << endl;\n    init_weight_graph();\n    for (int i = 1 ; i <= n ; ++ i) {\n        for (int j = i + 1 ; j <= n ; ++ j) {\n            int dd = abs(v[i - 1] - v[j - 1]) , ww;\n            if (isprime(dd)) {\n                ww = 1;\n            } else if (dd & 1) {\n                ww = 3;\n            } else {\n                ww = 2;\n            }\n            g[i][j].w = g[j][i].w = 10000 - ww;\n            //cout << i << ' ' << j << ' ' << g[i][j].w << endl;\n        }\n    }\n    printf(\"%lld\\n\", n * 5000 - weight_blossom().first);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef pair<ld,ld> pdd;\n\n#define X first\n#define Y second\n\nconst int MAXN = 110;\n\nint n;\nint a[MAXN], u[MAXN];\n\nll mul(ll a,ll b,ll p)\n{\n\tll t=0;\n\twhile (b)\n\t{\n\t\tif (b&1) t=(t+a)%p;\n\t\ta=a*2%p;\n\t\tb/=2;\n\t}\n\treturn t;\n}\n\nll power(ll a,ll b,ll p)\n{\n\tif (b==0) return 1;\n\tll t=power(a,b/2,p);\n\tt=mul(t,t,p);\n\tif (b&1) t=mul(t,a,p);\n\treturn t;\n}\n\nll getabs(ll x)\n{\n\treturn (x>=0)?x:-x;\n}\n\nll gcd(ll a,ll b)\n{\n\treturn b?gcd(b,a%b):a;\n}\n\nbool is_prime(ll p)\n{\n\tstatic ll a[]={2,3,5,7,11,13,17,19,23,29,31,37};\n\tif (p==1) return false;\n\tfor (int i=0;i<12&&a[i]<p;++i)\n\t{\n\t\tll t=p-1;\n\t\tint s=0;\n\t\twhile (t%2==0)\n\t\t{\n\t\t\tt/=2;\n\t\t\t++s;\n\t\t}\n\t\tll d=power(a[i],t,p);\n\t\tif (d==1||d==p-1) continue;\n\t\tint flag=0;\n\t\tfor (;s;--s)\n\t\t{\n\t\t\td=mul(d,d,p);\n\t\t\tif (d==p-1)\n\t\t\t{\n\t\t\t\tflag=1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!flag) return false;\n\t}\n\treturn true;\n}\n\nconst int INF = 1000000000;\nint F[MAXN];\n\nint calc(int x, int y)\n{\n\tint ret = 0;\n\tif (!is_prime(a[y]-a[x]+1)) return INF;\n\tret ++;\n\tfor (int i = x; i < y; ++ i)\n\t{\n\t\tint t = a[i+1]-a[i]-1;\n\t\tif (!t) continue;\n\t\tif (!is_prime(t)) return INF;\n\t\tret ++;\n\t}\n\treturn ret;\n}\n\nint main()\n{\n\t\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; ++ i)\n\t{\n\t\tscanf(\"%d\", &a[i]);\n\t}\n\tF[0] = 0;\n\tfor (int i = 1; i <= n; ++ i)\n\t{\n\t\tF[i] = INF;\n\t\tfor (int j = 0; j < i; ++ j)\n\t\t{\n\t\t\tF[i] = min(F[i], F[j]+calc(j+1, i));\n\t\t}\n\t}\n\tcout << F[n] << endl;\n\t\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <algorithm>\n#include <cmath>\n#include <cstring>\n#include <complex>\n\nusing namespace std;\n\n//typedef\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long ll;\n\n#define omajinai ios::sync_with_stdio(false);cin.tie(0)\n\n//container util\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define UNIQUE(a)  (a).erase(unique((a).begin(),(a).end()),(a).end())\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(auto i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n#define RFOR(i,b,a) for(int i=(b)-1;i>=(a);--i)\n#define RREP(i,n) RFOR(i,n,0)\n\n//debug\n#define dump(x)  cerr << \"[L \" << __LINE__ << \"] \" << #x << \" = \" << (x) << \"\\n\";\n\n// i love camel\n\n/// flow\nstruct edge {int to, cap, rev;}; // rev Index\nconst int _V = 200 + 2; // _N + source + sink\nvector<edge> G[_V];\nbool used[_V];\n\nvoid addEdge(int from, int to){\n\tG[from].push_back((edge) {to, 1, G[to].size()});\n\tG[to].push_back((edge) {from, 0, G[from].size() - 1}); // rev\n}\n\nint dfs(int v, int t){\n\tif(v==t)return 1;\n\tused[v] = true;\n\tREP(i, G[v].size()){\n\t\tedge &e = G[v][i];\n\t\tif(!used[e.to] && e.cap > 0){\n\t\t\tint d = dfs(e.to, t);\n\t\t\te.cap -= d;\n\t\t\tG[e.to][e.rev].cap += d;\n\t\t\treturn d;\n\t\t}\n\t}\n\treturn 0;\n}\n\nint maxFlow(int s, int t){\n\tint flow=0;\n\twhile(true){\n\t\tmemset(used, 0, sizeof used);\n\t\tint p = dfs(s, t);\n\t\tif(!p)return flow;\n\t\tflow += p;\n\t}\n}\n\n///\n\nbool isPrime(int x){ // exclusive 2\n\tif(x < 3)return false;\n\tfor(int i=3;i*i<=x;i++){\n\t\tif(x%i==0)return false;\n\t}\n\treturn true;\n}\n\nVI diff_odd, diff_even;\nint main() {\n\tint n;\n\tcin >> n;\n\tint last=-1;\n#define ADD(a) ((a)%2 ? diff_odd : diff_even).push_back(a)\n\tREP(i, n){\n\t\tint x;\n\t\tcin >> x;\n\t\tif(x!=last+1){ // not 隣接\n\t\t\tADD(x-1);\n\t\t\tif(last>0)ADD(last);\n\t\t}\n\t\tlast = x;\n\t}\n\tADD(last);\n\tREP(i, diff_odd.size())addEdge(200, i);\n\tREP(j, diff_even.size())addEdge(j + diff_odd.size(), 201);\n\tREP(i, diff_odd.size()){\n\t\tREP(j, diff_even.size()){\n\t\t\tint o = diff_odd[i], e = diff_even[j];\n\t\t\tif(isPrime(abs(o-e)))addEdge(i, j + diff_odd.size());\n\t\t}\n\t}\n\tint ans, k = ans = maxFlow(200, 201);\n\tans += (diff_odd.size() - k)/2*2;\n\tans += (diff_even.size() - k)/2*2;\n\tans += (diff_odd.size() - k) % 2 * 3;\n\tcout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\nconst int MAX1=100;\nconst int MAX2=10000000;\nconst int INF=0x3f3f3f3f;\nint n,a[MAX1+5],p[MAX2+5],chk[MAX1*2+5],ans;\nvector<int> cx,c[2],seq;\nvector<pii> conn[MAX1+5];\nint dfs(int x,int y){\n    int flow=0;\n    if(x==y) return INF;\n    chk[x]=1;\n    for(int i=0;i<conn[x].size();i++) if(chk[conn[x][i].first]==0&&conn[x][i].second>0){\n        int t=dfs(conn[x][i].first,y);\n        if(t>0){\n            flow=min(t,conn[x][i].second);\n            seq.push_back(x);\n            break;\n        }\n    }\n    chk[x]=0;\n    return flow;\n}\nint fflow(int x,int y){\n    seq.clear(); seq.push_back(y);\n    int flow=dfs(x,y);\n    for(int i=0;i<seq.size()-1;i++) {\n        int a=seq[i+1],b=seq[i];\n        for(int j=0;j<conn[a].size();j++) if(conn[a][j].first==b) conn[a][j].second-=flow;\n        for(int j=0;j<conn[b].size();j++) if(conn[b][j].first==a) conn[b][j].second+=flow;\n    }\n    return flow;\n}\nint main(){\n    scanf(\"%d\",&n);\n    for(int i=0;i<n;i++) scanf(\"%d\",&a[i]);\n    cx.push_back(a[0]), cx.push_back(a[0]+1);\n    for(int i=1;i<n;i++){\n        if(cx[cx.size()-1]==a[i]) cx.pop_back();\n        else cx.push_back(a[i]);\n        cx.push_back(a[i]+1);\n    }\n    for(int i=2;i<=MAX2;i++){\n        if(p[i]==0){\n            p[i]=1;\n            if(i<=10000) {for(int j=i*i;j<=MAX2;j+=i) p[j]=-1;}\n        }\n    }\n    p[2]=-1;\n    for(int i=0;i<cx.size();i++) c[cx[i]%2].push_back(cx[i]);\n    for(int i=0;i<c[0].size();i++) for(int j=0;j<c[1].size();j++) if(p[abs(c[0][i]-c[1][j])]==1) {\n        //printf(\"%d %d %d\\n\",i,j,abs(c[0][i]-c[1][j]));\n        conn[i].push_back(make_pair(c[0].size()+j,1));\n        conn[c[0].size()+j].push_back(make_pair(i,0));\n    }\n    for(int i=0;i<c[0].size();i++) {\n        conn[c[0].size()+c[1].size()].push_back(make_pair(i,1));\n        conn[i].push_back(make_pair(c[0].size()+c[1].size(),0));\n    }\n    for(int i=0;i<c[1].size();i++) {\n        conn[i+c[1].size()].push_back(make_pair(c[0].size()+c[1].size()+1,1));\n        conn[c[0].size()+c[1].size()+1].push_back(make_pair(i+c[1].size(),0));\n    }\n    while(fflow(c[0].size()+c[1].size(),c[0].size()+c[1].size()+1)) ans++;\n    printf(\"%d\\n\",c[0].size()+c[1].size()-ans+(c[0].size()-ans)%2);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<cmath>\nconst int N=102;\nint n,cnp,cnj,cnt,og[N],hx[N<<1],fir[N<<1],prm[460];\nbool npr[3200];\nstruct edge{\n\tint to,wi,nx;\n}eg[N*N];\n\ninline void add(int a,int b,int v){\n\tstatic int cnt=1;\n\teg[++cnt]=(edge){b,v,fir[a]};\n\tfir[a]=cnt;\n\teg[++cnt]=(edge){a,0,fir[b]};\n\tfir[b]=cnt;\n}\n\ninline char get_c(){\n\tstatic char buf[20000],*h,*t;\n\tif(h==t){\n\t\tt=(h=buf)+fread(buf,1,20000,stdin);\n\t}\n\treturn h==t?EOF:*h++;\n}\n\ninline int nxi(){\n\tint x=0;\n\tchar c;\n\twhile((c=get_c())>'9'||c<'0');\n\twhile(x=x*10-48+c,(c=get_c())>='0'&&c<='9');\n\treturn x;\n}\n\ninline void init(){\n\tnpr[1]=1;\n\tfor(int i=2;i<3200;++i){\n\t\tif(!npr[i]) prm[++cnp]=i;\n\t\tfor(int j=1;j<=cnp&&i*prm[j]<3200;++j){\n\t\t\tnpr[i*prm[j]]=1;\n\t\t\tif(i%prm[j]==0) break;\n\t\t}\n\t}\n}\n\ninline bool ispr(int x){\n\tif(x<3200) return !npr[x];\n\tint sq=sqrt(x)+1;\n\tfor(int i=1;prm[i]<=sq;++i){\n\t\tif(x%prm[i]==0) return 0;\n\t}\n\treturn 1;\n}\n\nnamespace F{\n\tint dep[N<<1],que[N<<1],cur[N<<1];\n\n\tinline bool bfs(){\n\t\tint hd=0,tl=1;\n\t\tdep[0]=1;\n\t\twhile(hd!=tl){\n\t\t\tint x=que[hd++];\n\t\t\tfor(int i=cur[x]=fir[x];i;i=eg[i].nx){\n\t\t\t\tint y=eg[i].to;\n\t\t\t\tif(eg[i].wi&&!dep[y]){\n\t\t\t\t\tdep[y]=dep[x]+1;\n\t\t\t\t\tque[tl++]=y;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn dep[(N<<1)-1];\n\t}\n\n\tint dfs(int x,int t){\n\t\tif(x==(N<<1)-1) return t;\n\t\tint tp,tt=t;\n\t\tfor(int &i=cur[x];i;i=eg[i].nx){\n\t\t\tint y=eg[i].to,v=eg[i].wi;\n\t\t\tif(v&&tt&&dep[x]+1==dep[y]&&(tp=dfs(y,std::min(v,tt)))){\n\t\t\t\teg[i].wi-=tp;\n\t\t\t\teg[i^1].wi+=tp;\n\t\t\t\ttt-=tp;\n\t\t\t\tif(!tt) break;\n\t\t\t}\n\t\t}\n\t\treturn t-tt;\n\t}\n}\n\nint main(){\n#ifndef ONLINE_JUDGE\n\tfreopen(\"c.in\",\"r\",stdin);\n#endif\n\tinit();\n\tn=nxi();\n\tfor(int i=1;i<=n;++i){\n\t\tog[i]=nxi();\n\t}\n\tstd::sort(og+1,og+n+1);\n\tog[0]=-1;\n\tfor(int i=1;i<=n;++i){\n\t\tif(og[i]-og[i-1]>1){\n\t\t\tif(og[i-1]+1) hx[++cnt]=og[i-1]+1;\n\t\t\thx[++cnt]=og[i];\n\t\t}\n\t}\n\thx[++cnt]=og[n]+1;\n\tfor(int i=1;i<=cnt;++i){\n\t\tif(hx[i]&1) ++cnj;\n\t\tif(hx[i]&1) add(0,i,1);\n\t\telse add(i,(N<<1)-1,1);\n\t\tfor(int j=i+1;j<=cnt;++j){\n\t\t\tint p=hx[j]-hx[i];\n\t\t\tif((p&1)&&ispr(p)){\n\t\t\t\tif(hx[i]&1) add(i,j,1);\n\t\t\t\telse add(j,i,1);\n\t\t\t}\n\t\t}\n\t}\n\tint ans=0;\n\twhile(F::bfs()){\n\t\tans+=F::dfs(0,N);\n\t}\n//\tprintf(\"%d %d %d\\n\",cnt,ans,cnj&1);\n\tprintf(\"%d\\n\",cnt-ans+(cnj&1));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cmath>\nconst int N=1005,INF=~0u>>2;\nstruct Edge{int nxt,to;}edge[N*N];\nint b[N],n,head[N],num_edge,vis[N],lk[N],even[N],odd[N],even_num,odd_num,ans,k,tot,tim;\nint read(){\n\tint x=0,f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-') f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn f*x;\n}\nvoid add_edge(int from,int to){\n\tedge[++num_edge].nxt=head[from];\n\tedge[num_edge].to=to;\n\thead[from]=num_edge;\n}\nbool find(int x){\n\tfor(int i=head[x];i;i=edge[i].nxt){\n\t\tif(vis[edge[i].to]!=tim){\n\t\t\tvis[edge[i].to]=tim;\n\t\t\tif(!lk[edge[i].to]||find(edge[i].to)){\n\t\t\t\tlk[edge[i].to]=x;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nbool check(int x){\n\tif(x==1) return 0;\n\tfor(int i=2;i*i<=x;++i){\n\t\tif(x%i==0) return 0;\n\t}\n\treturn 1;\n}\nvoid solve(int x){\n\tif(x&1) odd[++odd_num]=x;\n\telse even[++even_num]=x;\n}\nint main(){\n//\tfreopen(\"ex.in\",\"r\",stdin);\n\tn=read();\n\tfor(int i=1;i<=n;++i) b[i]=read();b[0]=-1;\n\tfor(int i=1;i<=n;++i){\n\t\tif(b[i]!=b[i-1]+1) solve(b[i]);\n\t\tif(b[i]+1!=b[i+1]) solve(b[i]+1);\n\t}\n\tfor(int i=1;i<=odd_num;++i){\n\t\tfor(int j=1;j<=even_num;++j){\n\t\t\tif(check(abs(even[j]-odd[i]))) add_edge(i,j+odd_num);\n\t\t}\n\t}\n\tfor(int i=1;i<=odd_num;++i){\n\t\ttim++;\n\t\tif(find(i)) k++;\n\t}\n\tans=k+((even_num-k)/2+(odd_num-k)/2)*2+((odd_num-k)%2)*3;\n\tprintf(\"%d\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define Mem(a,b) memset(a,b,sizeof(a))\n#define ll long long\n#define lson root<<1\n#define rson root<<1|1\n#define Mid int mid=(l+r)>>1\n#define FREI freopen(\"in.txt\",\"r\",stdin)\n#define FREO freopen(\"out.txt\",\"w\",stdout)\n#define inf 0x3f3f3f3f\n#define mod 1000000007\n#define PB push_back\nusing namespace std;\nconst int MAXN=1e7+10;\nint n;\nint vis[200];\nstruct fc{\n    int v,cost;\n};\nvector<int>point;\nvector<int>X,Y;\nvector<fc>G[110];\nbool used[220];\nint pre[220];\nvoid pretreat(){\n    Mem(vis,0);\n    point.clear();\n    scanf(\"%d\",&n);\n    for(int i=0;i<n;i++){\n        scanf(\"%d\",&vis[i]);\n    }\n    sort(vis,vis+n);\n    for(int i=0;i<n;i++){\n        if(i==0) point.PB(vis[i]);\n        if(i>0&&vis[i]!=vis[i-1]+1) {\n            point.PB(vis[i]);\n            //cout<<i<<' '<<vis[i]<<endl;\n        }\n        if(vis[i+1]!=vis[i]+1){\n            point.PB(vis[i]+1);\n            //cout<<vis[i]+1<<endl;\n        }\n    }\n    for(auto u:point){\n        if(u&1) Y.push_back(u);\n        else X.push_back(u);\n    }\n//    for(auto u:X){\n//        cout<<u<<' ';\n//    }\n//    cout<<endl;\n//    for(auto v:Y){\n//        cout<<v<<' ';\n//    }\n//    cout<<endl;\n}\nbool isprime(int x){\n    for(int i=2;i*i<=x;i++){\n        if(x%i==0) return false;\n    }\n    return true;\n}\nvoid build_graph(){\n    for(int i=0;i<X.size();i++){\n        for(int j=0;j<Y.size();j++){\n            //cout<<i+1<<' '<<j+1<<' '<<abs(Y[j]-X[i])<<endl;\n            if(isprime(abs(Y[j]-X[i])))\n                G[i+1].PB({j+1,abs(Y[j]-X[i])});\n        }\n    }\n}\n\nbool dfs(int u){\n    for(int i=0;i<G[u].size();i++){\n        int v=G[u][i].v,cost=G[u][i].cost;\n\n        if(!used[v]){\n            used[v]=1;\n            if(!pre[v]||dfs(pre[v])){\n                pre[v]=u;\n                return true;\n            }\n        }\n    }\n    return false;\n}\nint solve(){\n    Mem(pre,0);\n    int ans=0;\n    for(int i=1;i<=X.size();i++){\n        Mem(used,0);\n        if(dfs(i)) ans++;\n    }\n    //for(int i=1;i<=Y.size();i++) cout<<pre[i]<<endl;\n    //cout<<ans<<endl;\n    //cout<<X.size()<<endl;\n    return ans+(X.size()-ans)/2*2+(Y.size()-ans)/2*2+((X.size()-ans)%2)*3;\n}\nint main() {\n    //FREI;\n    //cout<<isprime(165)<<endl;\n    pretreat();\n    build_graph();\n    printf(\"%d\\n\",solve());\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint N,M;\nconst int MAX_N = 111;\nint a[MAX_N],b[MAX_N*2],sz;\nvector<int> odd,even;\n\nvector<int> path[MAX_N*2];\nbool visit[MAX_N*2];\nint match[MAX_N*2];\n\nbool dfs(int x){\n\tif(visit[x])return false;\n\tvisit[x]=1;\n\tfor(int i=0;i<path[x].size();i++){\n\t\tint y=path[x][i];\n\t\tif(match[y]<0){\n\t\t\tmatch[y]=x;\n\t\t\treturn true;\n\t\t}else if(dfs(match[y])){\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nbool isPrime(int x){\n\tif(x==1)return false;\n\tif(x%2==0)return false; // 2 is exception\n\tfor(int i=3;i*i<=x;i+=2){\n\t\tif(x%i==0)return false;\n\t}\n\treturn true;\n}\n\nint main(){\n\tscanf(\"%d\",&N);\n\tfor(int i=0;i<N;i++){\n\t\tscanf(\"%d\",&a[i]);\n\t}\n\n\tb[sz++]=a[0];\n\tfor(int i=1;i<N;i++){\n\t\tif(a[i-1]+1<a[i]){\n\t\t\tb[sz++]=a[i-1]+1;\n\t\t\tb[sz++]=a[i];\n\t\t}\n\t}\n\tb[sz++]=a[N-1]+1;\n\n\tfor(int i=0;i<sz;i++){\n\t\tif(b[i]%2==0)even.push_back(b[i]);\n\t\telse odd.push_back(b[i]);\n\t}\n\n\tfor(int i=0;i<even.size();i++){\n\t\tfor(int j=0;j<odd.size();j++){\n\t\t\tif(isPrime(abs(even[i]-odd[j]))){\n\t\t\t\tpath[i].push_back(j);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int i=0;i<odd.size();i++){\n\t\tmatch[i]=-1;\n\t}\n\t\n\tint cnt=0;\n\tfor(int i=0;i<even.size();i++){\n\t\tfor(int j=0;j<even.size();j++)visit[j]=0;\n\t\tif(dfs(i))cnt++;\n\t}\n\n\tint z0=even.size()-cnt;\n\tint z1=odd.size()-cnt;\n\tprintf(\"%d\\n\",cnt+(z0/2+z1/2)*2+(z0%2)*3);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n\n#include <random>\n\n#define _rep(_1, _2, _3, _4, name, ...) name\n#define rep2(i, n) rep3(i, 0, n)\n#define rep3(i, a, b) rep4(i, a, b, 1)\n#define rep4(i, a, b, c) for (int i = int(a); i < int(b); i += int(c))\n#define rep(...) _rep(__VA_ARGS__, rep4, rep3, rep2, _)(__VA_ARGS__)\n\nusing namespace std;\nusing i8 = signed char;\nusing i64 = long long;\n\ntemplate <typename WeightType>\nclass MaximumWeightedMatching {\n  /*\n  Maximum Weighted Matching in General Graphs\n  - O(n^3) time\n  - O(n + m) space\n\n  Note: each vertex is 1-indexed.\n  */\npublic:\n  using weight_t = WeightType;\n  using weight_sum_t = i64;\n  struct Edge { int from, to; weight_t weight; };\n\nprivate:\n  enum TreeLabelNumber { INNER = -1, UNUSED = 0, OUTER = 1 };\n  enum LabelNumber { SEPARATED = -2, DEFAULT = -1 };\n  enum EdgeNumber { UNDEFINED = 1 << 30};\n\n  const  weight_t INF = weight_t(1) << (sizeof(weight_t) * 8 - 2);\n\n  struct Node { int next, from, to; };\n  struct Label { int from, to; };\n  struct LinkedList { int eid, next; };\n\n  class Queue {\n  public:\n    Queue() {}\n    Queue(int N) : que(N), qh(0), qt(0) {}\n    void clear() { qh = qt = 0; }\n    int* data() { return que.data(); }\n    bool empty() const { return qh == qt; }\n    int dequeue() { return que[qh++]; }\n    void enqueue(int u) { que[qt++] = u; }\n    int operator [] (int i) const { return que[i]; }\n    int size() const { return qt; }\n\n    vector<int> que;\n    int qh, qt;\n  };\n\npublic:\n  MaximumWeightedMatching(int N, const vector<Edge>& raw_edges)\n      : N(N), B((N - 1) / 2), size(N + B + 1) {\n\n    offsets.assign(N + 2, 0);\n    for (auto& e : raw_edges) {\n      offsets[e.from + 1]++;\n      offsets[e.to + 1]++;\n    }\n    rep(i, 1, N + 1) offsets[i] += offsets[i - 1];\n    edges.resize(raw_edges.size() * 2);\n    rep(i, raw_edges.size()) {\n      auto& e = raw_edges[i];\n      edges[offsets[e.from]++] = {e.from, e.to, 2 * e.weight};\n      edges[offsets[e.to]++] = {e.to, e.from, 2 * e.weight};\n    }\n    rep(i, N + 1) offsets[N + 1 - i] = offsets[N - i];\n    offsets[0] = 0;\n  }\n\n  weight_sum_t maximum_weighted_matching() {\n    initialize();\n    set_potential();\n    rep(u, 1, N + 1) if (!mate[u]) {\n      for (int s = 0; !augmented(u, s); s = adjust_dual_solutions());\n      fix_blossom_bases();\n      clear_label();\n    }\n    weight_sum_t ret = 0;\n    rep(u, 1, N + 1) if (mate[u] > u) {\n      weight_t max_w = 0;\n      rep(eid, offsets[u], offsets[u + 1]) if (edges[eid].to == mate[u]) {\n        max_w = max(max_w, edges[eid].weight);\n      }\n      ret += max_w;\n    }\n    return ret >> 1;\n  }\n\nprivate:\n  inline int encode(int e) const {\n    return e + size + 1; // should be >= 3\n  }\n\n  inline weight_t reduced_cost(int u, int v, const Edge& e) const {\n    return potential[u] + potential[v] - e.weight;\n  }\n\n  inline weight_t reduced_cost(int eid) const {\n    return reduced_cost(edges[eid].from, edges[eid].to, edges[eid]);\n  }\n\n  void rematch(int v, int w) {\n    auto t = mate[v]; mate[v] = w;\n    if (mate[t] != v) return;\n    if (label[v].to == 0) {\n      mate[t] = label[v].from;\n      rematch(mate[t], t);\n    } else {\n      int x = label[v].from, y = label[v].to;\n      rematch(x, y); rematch(y, x);\n    }\n  }\n\n  Label search_blossom_edge(int bid) const {\n    int b = base[bid], bv = b;\n    for (; node[bv].next != b; bv = node[node[bv].next].next);\n    return {node[bv].from, node[bv].to};\n  }\n\n  void label_blossom(int bid, int m, Label l) {\n    label[bid] = {l.from, (l.to == surface[l.to]) ? 0 : l.to};\n    if (bid <= N) return;\n    int b = base[bid]; label_blossom(b, mate[bid] = m, l);\n    l = search_blossom_edge(bid);\n    for (int bv = b, bw; node[bv].next != b; bv = node[bw].next) {\n      label_blossom(bw = node[bv].next, 0, l);\n      label_blossom(node[bw].next, node[bw].from, {node[bv].from, node[bv].to});\n    }\n  }\n\n  int find_mate(int bid) {\n    return bid <= N ? mate[bid] : mate[bid] = find_mate(base[bid]);\n  }\n\n  void push_inner_blossom_rec(int bid, bool push=true) {\n    tree_label[bid] = (bid <= N) ? INNER : UNUSED;\n    if (bid > N) {\n      int v = base[bid], u = v;\n      do { push_inner_blossom_rec(v, push); } while ( (v = node[v].next) != u);\n    } else if (push) inner_vertices[inner_vertices_size++] = bid;\n  }\n\n  void push_inner_blossom(int bid) {\n    if (tree_label[bid] != UNUSED) return;\n    bool push = label[bid].from != SEPARATED;\n    if (bid > N) {\n      if (push) inner_blossoms[inner_blossom_size++] = bid;\n      push_inner_blossom_rec(bid, push);\n    } else if (push) inner_vertices[inner_vertices_size++] = bid;\n    tree_label[bid] = INNER;\n  }\n\n  void push_outer_blossom_rec(int bid) {\n    tree_label[bid] = (bid <= N) ? OUTER : UNUSED;\n    if (bid > N) {\n      int v = base[bid], u = v;\n      do { push_outer_blossom_rec(v); } while ( (v = node[v].next) != u );\n    } else outer_vertices.enqueue(bid);\n  }\n\n  void push_outer_blossom(int bid, bool push) {\n    push_outer_blossom_rec(bid);\n    if (bid <= N) return;\n    if (push) outer_blossoms[outer_blossom_size++] = bid, tree_label[bid] = OUTER;\n    else tree_label[bid] = UNUSED;\n  }\n\n  inline void merge_edge(int x, int bx, int eid) {\n    auto& e = edges[eid];\n    int y = e.to, by = surface[y];\n    if (tree_label[by] != OUTER || bx == by) return;\n    auto r_cost = reduced_cost(x, y, e);\n    if (r_cost < best_cost[by].first) {\n      if (best_cost[by].first == INF) merged_edges[merged_edge_size++] = by;\n      best_cost[by] = {r_cost, eid};\n    }\n  }\n\n  inline void merge_vertex(int x, int bx) {\n    rep(eid, offsets[x], offsets[x + 1]) merge_edge(x, bx, eid);\n    best_edge[x] = UNDEFINED;\n  }\n\n  void clear_best_edges(int b) {\n    if (b > N) {\n      int v = b = base[b];\n      do { clear_best_edges(v); } while ( (v = node[v].next) != b );\n    } else best_edge[b] = UNDEFINED;\n  }\n\n  void merge_outer(int b, int bid) {\n    if (b > N) {\n      for (int head = blist_head[b]; head >= 0; head = bnode[head].next) {\n        int eid = bnode[head].eid;\n        merge_edge(edges[eid].from, bid, eid);\n        next_bnode.push_back(head);\n      }\n      blist_head[b] = -1;\n      clear_best_edges(b);\n    } else merge_vertex(b, bid);\n  }\n\n  void merge_inner(int b, int bid) {\n    if (b > N) {\n      int v = b = base[b];\n      do { merge_inner(v, bid); } while ((v = node[v].next) != b);\n    } else merge_vertex(b, bid);\n  }\n\n  void build_linked_list(int bid) {\n    if (bid <= N) return;\n    int last = -1;\n    for (; merged_edge_size > 0; ) {\n      int nid = next_bnode.back(); next_bnode.pop_back();\n      int by = merged_edges[--merged_edge_size], eid = best_cost[by].second;\n      int x = edges[eid].from, y = edges[eid].to;\n      bnode[nid] = {eid, last};\n      if (tree_label[y] == OUTER) update_best_edge(y, by, best_cost[by].first, eid);\n      if (best_edge[x] == UNDEFINED || best_cost[by].first < reduced_cost(best_edge[x])) {\n        best_edge[x] = eid;\n      }\n      best_cost[by] = {INF, UNDEFINED};\n      last = nid;\n    }\n    blist_head[bid] = last;\n  }\n\n  void merge_best_edges(int bid, int inner_count) {\n    rep(i, inner_count) {\n      int bv = outer_blossoms[outer_blossom_size + i];\n      if (bv >= 0) merge_outer(bv, bid), merge_inner(node[bv].next, bid);\n      else merge_inner(~bv, bid), merge_outer(node[~bv].next, bid);\n    }\n    merge_outer(base[bid], bid);\n    build_linked_list(bid);\n  }\n\n  void contract(int x, int y, int eid) {\n    int s = surface[x], t = surface[y];\n    if (s == t) return;\n    auto h = label[surface[mate[s]]].from = label[surface[mate[t]]].from = -encode(eid);\n\n    int lca = -1;\n    for (; ; label[surface[mate[s]]].from = h) {\n      if (mate[t] != 0) swap(s, t);\n      s = lca = surface[label[s].from];\n      if (label[surface[mate[s]]].from == h) break;\n    }\n\n    int inner_count = 0;\n    for (int dir = 0; dir < 2; ++dir) {\n      int v = (dir == 0) ? x : y;\n      while (1) {\n        int bv = surface[v], mv = mate[bv], bmv = surface[mv];\n        if (bv == lca) break;\n        label[mv] = label[bmv] = {x, y};\n        auto n = node[bmv];\n        if (!dir) {\n          node[bv] = {bmv, mate[mv], mv};\n          node[bmv].next = surface[n.to];\n        } else {\n          node[surface[n.to]] = {bmv, n.to, n.from};\n          node[bmv] = {bv, mv, mate[mv]};\n        }\n        push_outer_blossom(bmv, false);\n        v = label[bv].from;\n\n        // Caution: used as temporary array\n        outer_blossoms[outer_blossom_size + (inner_count++)] = !dir ? bv : ~bmv;\n      }\n    }\n    node[surface[y]] = {surface[x], y, x};\n\n    int bid = next_bid.back(); next_bid.pop_back();\n    base[bid] = lca, label[bid].from = label[lca].from, mate[bid] = mate[lca];\n\n    tree_label[bid] = OUTER;\n    set_surface(bid, bid);\n    merge_best_edges(bid, inner_count);\n\n    outer_blossoms[outer_blossom_size++] = bid;\n  }\n\n  inline void update_best_edge(int y, int by, weight_t r_cost, int eid) {\n    if (tree_label[by] != OUTER && best_edge[y] == UNDEFINED) {\n      neighbors[neighbor_size++] = y;\n    }\n    if (best_edge[y] == UNDEFINED || r_cost < reduced_cost(best_edge[y])) {\n      best_edge[y] = eid;\n    }\n  }\n\n  void build_edge_list(int b) {\n    if (b <= N) return;\n    merge_inner(b, b);\n    build_linked_list(b);\n  }\n\n  bool augmented(int root, int s) {\n    if (s == 0) {\n      int br = surface[root];\n      push_outer_blossom(br, true);\n      label_blossom(br, 0, {0, 0});\n      build_edge_list(br);\n    }\n    for (; !outer_vertices.empty() || s > 0; s = 0) {\n      auto x = (s > 0) ? s : outer_vertices.dequeue();\n      if (potential[x] == 0) {\n        if (root != x) rematch(x, 0);\n        return true;\n      }\n      rep(eid, offsets[x], offsets[x + 1]) {\n        int bx = surface[x], y = edges[eid].to, by = surface[y];\n        if (bx == by) continue;\n        auto r_cost = reduced_cost(x, y, edges[eid]);\n        if (r_cost > 0 || tree_label[by] != OUTER) {\n          update_best_edge(y, by, r_cost, eid);\n          if (r_cost > 0) continue;\n        }\n        if (label[by].from >= 0) {\n          contract(x, y, eid);\n          continue;\n        }\n        if (tree_label[by] == UNUSED) {\n          push_inner_blossom(by);\n          if (by != y) label_blossom(by, find_mate(by), {DEFAULT, 0});\n        }\n        int z = mate[by];\n        if (z == 0 && by != surface[root]) {\n          rematch(x, y); rematch(y, x);\n          return true;\n        }\n        int bz = surface[z];\n        if (label[bz].from < 0) {\n          node[by] = {-1, y, x};\n          push_outer_blossom(bz, true);\n          label_blossom(bz, mate[z], {x, y});\n          build_edge_list(bz);\n        }\n      }\n    }\n    return false;\n  }\n\n  void set_surface(int b, int bid) {\n    for (int v = base[b]; surface[v] != bid; v = node[v].next) {\n      if (v > N) tree_label[v] = UNUSED, set_surface(v, bid);\n      surface[v] = bid;\n    }\n  }\n\n  void reset_surface(int b, int bid) {\n    surface[b] = bid;\n    if (b <= N) return;\n    for (b = base[b]; surface[b] != bid; b = node[b].next) reset_surface(b, bid);\n  }\n\n  void separate_blossom(int bid, bool push_blossom=true) {\n    tree_label[bid] = UNUSED, label[bid].from = SEPARATED;\n    if (bid <= N) return;\n    if (push_blossom) inner_blossoms[inner_blossom_size++] = bid;\n    for (int b = base[bid]; label[b].from != SEPARATED; b = node[b].next) {\n      separate_blossom(b, false);\n    }\n  }\n\n  void reverse_blossom(int b) {\n    int v = b, fr = node[b].from, to = node[b].to;\n    for (int nv = node[v].next; nv != b; ) {\n      int nnext = node[nv].next, nfr = node[nv].from, nto = node[nv].to;\n      node[nv].next = v, node[nv].from = to, node[nv].to = fr;\n      fr = nfr, to = nto, v = nv, nv = nnext;\n    }\n    node[b].next = v, node[b].from = to, node[b].to = fr;\n  }\n\n  void expand_blossom(int bid) {\n    next_bid.push_back(bid); tree_label[bid] = UNUSED;\n    for (int b = base[bid]; surface[b] == bid; b = node[b].next) reset_surface(b, b);\n    int old_base = base[bid], target = surface[node[bid].from];\n    if (mate[node[target].from] == node[target].to) reverse_blossom(old_base);\n    for (int b = target; node[b].next != old_base; ) {\n      separate_blossom(b = node[b].next); separate_blossom(b = node[b].next);\n    }\n    node[target] = node[bid];\n    for (int b = old_base; ; b = node[b].next) {\n      label[b].from = DEFAULT, tree_label[b] = INNER;\n      if (b > N) inner_blossoms[inner_blossom_size++] = b;\n      int m = find_mate(b), bm = surface[m];\n      if (b != old_base) mate[bm] = mate[m];\n      label[m] = label[bm] = {node[b].to, node[b].from};\n      if (b == target) break;\n      push_outer_blossom(b = node[b].next, true);\n      build_edge_list(b);\n    }\n    base[bid] = bid, surface[bid] = bid;\n  }\n\n  void update_potential(int* vs, int s, weight_t delta, int label) {\n    rep(i, s) {\n      int x = vs[i];\n      if (tree_label[x] != label) continue;\n      potential[x] += delta;\n    }\n  }\n\n  int adjust_dual_solutions() {\n    pair<weight_t, int> delta1(INF, 0), delta2(INF, 0), delta3(INF, 0), delta4(INF, 0);\n    rep(i, outer_vertices.size()) {\n      int y = outer_vertices[i], eid = best_edge[y];\n      delta1 = min(delta1, {potential[y], y});\n      if (eid != UNDEFINED) {\n        delta3 = min(delta3, {reduced_cost(eid) >> 1, y});\n      }\n    }\n    rep(i, neighbor_size) {\n      int y = neighbors[i];\n      if (tree_label[y] == UNUSED) {\n        int eid = best_edge[y], x = edges[eid].from;\n        delta2 = min(delta2, {reduced_cost(x, y, edges[eid]), x});\n      }\n    }\n    rep(i, inner_blossom_size) if (tree_label[inner_blossoms[i]] == INNER) {\n      int b = inner_blossoms[i];\n      delta4 = min(delta4, {potential[b] >> 1, b});\n    }\n    auto delta = min(min(delta1, delta2), min(delta3, delta4));\n    auto d = delta.first;\n    update_potential(outer_vertices.data(), outer_vertices.size(), -1 * d, OUTER);\n    update_potential(inner_vertices.data(), inner_vertices_size,    1 * d, INNER);\n    update_potential(outer_blossoms.data(), outer_blossom_size,     2 * d, OUTER);\n    update_potential(inner_blossoms.data(), inner_blossom_size,    -2 * d, INNER);\n    if (delta4.first == d) {\n      expand_blossom(delta4.second);\n      return -1;\n    } else {\n      return delta.second;\n    }\n  }\n\n  void fix_blossom_bases() {\n    int remain = size - next_bid.size() - (N + 1);\n    for (int bid = N + 1; bid < size && remain > 0; ++bid) if (base[bid] != bid) {\n      int b = base[bid];\n      for (int skipped = 0; skipped < 2;) {\n        b = node[b].next;\n        if (mate[node[b].from] == node[b].to) skipped = 0;\n        else skipped++;\n      }\n      base[bid] = b;\n      --remain;\n    }\n  }\n\n  void free_edge_list(int x) {\n    for (int head = blist_head[x]; head >= 0; head = bnode[head].next) {\n      next_bnode.push_back(head);\n    }\n    blist_head[x] = -1;\n  }\n\n  void clear_vertices(int* vs, int size) {\n    rep(i, size) {\n      int v = vs[i];\n      label[v] = {DEFAULT, 0}; tree_label[v] = UNUSED; best_edge[v] = UNDEFINED;\n    }\n  }\n\n  void clear_label() {\n    label[0] = {DEFAULT, 0};\n    clear_vertices(outer_vertices.data(), outer_vertices.size()); outer_vertices.clear();\n    clear_vertices(inner_vertices.data(), inner_vertices_size); inner_vertices_size = 0;\n    clear_vertices(outer_blossoms.data(), outer_blossom_size);\n    rep(i, outer_blossom_size) if (blist_head[outer_blossoms[i]] >= 0) free_edge_list(outer_blossoms[i]);\n    outer_blossom_size = 0;\n    clear_vertices(inner_blossoms.data(), inner_blossom_size); inner_blossom_size = 0;\n    rep(i, neighbor_size) best_edge[neighbors[i]] = UNDEFINED;\n    neighbor_size = 0;\n  }\n\n  void set_potential() {\n    potential.resize(size);\n    rep(u, 1, N + 1) {\n      weight_t max_w = 0;\n      rep(eid, offsets[u], offsets[u + 1]) max_w = max(max_w, edges[eid].weight);\n      potential[u] = max_w >> 1;\n    }\n  }\n\n  void initialize() {\n    mate.assign(size, 0);\n    label.assign(size, {-1, 0});\n\n    surface.resize(size); rep(i, size) surface[i] = i;\n    base.resize(size); rep(i, size) base[i] = i;\n    node.resize(size); rep(i, size) node[i] = {i, i, i};\n\n    outer_vertices = Queue(N);\n    inner_vertices.resize(N + 1); inner_vertices_size = 0;\n    outer_blossoms.resize(B); outer_blossom_size = 0;\n    inner_blossoms.resize(B); inner_blossom_size = 0;\n\n    tree_label.assign(size, UNUSED);\n\n    next_bid.resize(B);\n    rep(i, B) next_bid[i] = size - 1 - i;\n\n    merged_edges.resize(N + 1); merged_edge_size = 0;\n    best_cost.assign(size, {INF, UNDEFINED});\n\n    neighbors.resize(N + 1); neighbor_size = 0;\n    best_edge.assign(size, UNDEFINED);\n\n    blist_head.assign(size, -1);\n    next_bnode.resize(edges.size());\n    rep(i, edges.size()) next_bnode[i] = edges.size() - 1 - i;\n\n    bnode.resize(edges.size());\n  }\n\nprivate:\n  int N, B, size;\n  vector<Edge> edges;\n  vector<int> offsets;\n\n  vector<Label> label;\n  vector<int> mate, surface, base;\n  vector<Node> node;\n  vector<weight_t> potential;\n\n  vector<int> next_bid;\n\n  vector<i8> tree_label;\n\n  Queue outer_vertices;\n  vector<int> inner_vertices; int inner_vertices_size;\n  vector<int> outer_blossoms; int outer_blossom_size;\n  vector<int> inner_blossoms; int inner_blossom_size;\n\n  vector<int> merged_edges; int merged_edge_size;\n  vector< pair<weight_t, int> > best_cost;\n  vector<int> neighbors; int neighbor_size;\n  vector<int> best_edge;\n\n  vector<int> blist_head;\n  vector<LinkedList> bnode;\n  vector<int> next_bnode;\n};\n\nconst int MAX_P=11111111;\nbool prime[MAX_P];\n\n#include<set>\n#include<algorithm>\nint main() {\n    fill_n(prime,MAX_P,1);\n    prime[0]=prime[1]=0;\n    for(int i=2;i<MAX_P;i++){\n        if(!prime[i])continue;\n        for(int j=i+i;j<MAX_P;j+=i)prime[j]=0;\n    }\n    int N;\n    cin>>N;\n    vector<int>X(N);\n    rep(i,N)cin>>X[i];\n\n    set<int>xs;\n    rep(i,N)xs.insert(X[i]);\n\n    vector<int> A;\n    rep(i,N){\n        if(xs.find(X[i]-1)==xs.end())A.push_back(X[i]);\n        if(xs.find(X[i]+1)==xs.end())A.push_back(X[i]+1);\n    }\n\n    sort(A.begin(),A.end());\n\n  using Edge = MaximumWeightedMatching<int>::Edge;\n  vector<Edge> edges;\n  rep(i,A.size())for(int j=i+1;j<A.size();j++){\n    int cost;\n    int d=A[j]-A[i];\n    if(d%2&&prime[d])cost=1;\n    else if(d%2==0)cost=2;\n    else cost=3;\n    cost=5-cost;\n    edges.push_back({i+1,j+1,cost});\n  }\n  auto MWM = MaximumWeightedMatching<int>(A.size(), edges);\n  auto ans = MWM.maximum_weighted_matching();\n\n    cout<<-ans+5*(A.size()/2)<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 1e7 + 100;\n\n\nint n,fre[maxn],p[220],isprime[maxn],even,odd,wrong;\nvector <int> edge[220],v2;\n\nbool fin(int u) {\n    if (fre[u]==wrong) return false;\n    fre[u]=wrong;\n    for (int j=0;j<edge[u].size();j++) {\n        int v=edge[u][j];\n       // cout<<u<<\" \"<<v<<endl;\n        if (p[v]==0 || fin(p[v])) {\n            p[v]=u;\n            p[u]=v;\n            return true;\n        }\n    }\n    return false;\n}\n\nint main() {\n   // freopen(\"in.txt\",\"r\",stdin);\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    isprime[1]=1;\n    for (int i=2;i<maxn;i++)\n        if (isprime[i]==0) {\n            for (int j=i+i;j<maxn;j+=i) isprime[j]=1;\n        }\n    cin>>n;\n    for (int i=1;i<=n;i++) {\n        int x;\n        cin>>x;\n        fre[x]=1;\n    }\n    even=0; odd=0; wrong=2;\n    int id=1;\n    while (id<=maxn) {\n        if (fre[id]==0) id++;\n        else if (fre[id]==1) {\n            v2.push_back(id);\n            if (id%2==0) even++; else odd++ ;\n            id++;\n            while (id<=maxn && fre[id]==1) id++;\n            v2.push_back(id);\n            if (id%2==0) even++; else odd++ ;\n        }\n    }\n    // for (int i=0;i<v2.size();i++) cout<<v2[i]<<\" \";\n   //  cout<<endl;\n   // cout<<\" \" <<even<<\" \"<<odd<<endl;\n    for (int i=0;i<v2.size();i++)\n        for (int j=i+1;j<v2.size();j++)\n            if (isprime[ v2[j] - v2[i] ]==0) {\n              //  cout<<i<<\" \"<<j<<\" \"<<v2[i]<<\" \"<<v2[j]<<endl;\n                edge[i+1].push_back(j+1);\n                edge[j+1].push_back(i+1);\n            }\n    int cnt=0;\n    for (int i=0;i<v2.size();i++)\n     if (p[i+1]==0) {\n        wrong++;\n        p[i+1]=i+1;\n        //cout<<fin(i+1)<<endl;\n        cnt+=(fin(i+1));\n       // cout<<p[i+1]<<endl;\n      //  cout<<\"fuck\"<<endl;\n    }\n   // cout<<cnt<<\" \" <<even<<\" \"<<odd<<endl;\n    cout<< cnt + ((even-cnt)/2 + (odd-cnt)/2) * 2 + (even%2)*3;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define Rint register int\nusing namespace std;\nconst int N = 203;\nint n, m, x[N], y[N], ans, flyx[N], flyy[N];\nbool vis[N];\nbool edge[N][N];\nset<int> S;\ninline bool isp(int x){\n\tif(x <= 2) return false;\n\tfor(Rint i = 2;i * i <= x;i ++)\n\t\tif(!(x % i)) return false;\n\treturn true;\n}\ninline bool dfs(int x){\n\tfor(Rint y = 1;y <= m;y ++)\n\t\tif(edge[x][y] && !vis[y]){\n\t\t\tvis[y] = true;\n\t\t\tif(!flyy[y] || dfs(flyy[y])){\n\t\t\t\tflyx[x] = y; flyy[y] = x; return true;\n\t\t\t}\n\t\t}\n\treturn false;\n}\nint main(){\n\tscanf(\"%d\", &n);\n\tfor(Rint i = 1;i <= n;i ++){\n\t\tint v; scanf(\"%d\", &v);\n\t\tif(S.count(v)) S.erase(v);\n\t\telse S.insert(v);\n\t\tif(S.count(v + 1)) S.erase(v + 1);\n\t\telse S.insert(v + 1);\n\t}\n\tn = m = 0;\n\tfor(int v : S)\n\t\tif(v & 1) x[++ n] = v;\n\t\telse y[++ m] = v;\n\tfor(Rint i = 1;i <= n;i ++)\n\t\tfor(Rint j = 1;j <= m;j ++)\n\t\t\tedge[i][j] = edge[j][i] = isp(abs(x[i] - y[j]));\n\tfor(Rint i = 1;i <= n;i ++) if(!flyx[i]){\n\t\tmemset(vis, 0, sizeof vis); ans += dfs(i);\n\t}\n\tprintf(\"%d\\n\", n + m + (n - ans & 1) - ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <random>\n#include <chrono>\n#include <tuple>\n#include <random>\n#include <cmath>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\n#define fastInp cin.tie(0); cout.tie(0); ios_base::sync_with_stdio(0);\n\nconst ll SZ = 1e7 + 100, INF = 1e9 * 1e9 + 10;\n\nvector<ll> vec;\n\nll dp[102];\nbool prime[SZ];\n\nint main()\n{\n\tfastInp;\n\n\tll n;\n\tcin >> n;\n\tvec.resize(n);\n\tif (n == 1) {\n\t\tcout << \"3\";\n\t\treturn 0;\n\t}\n\t\n\tprime[0] = 1;\n\tprime[1] = 1;\n\tfor (auto &cur : vec) cin >> cur;\n\n\tfor (ll i = 2; i < SZ; i++) {\n\t\tif (prime[i]) continue;\n\n\t\tfor (ll j = (i * i); j < SZ; j += i) {\n\t\t\tprime[j] = 1;\n\t\t}\n\t}\n\n\tfor (int i = 0; i < n; i++) {\n\t\tdp[i + 1] = dp[i] + 3;\n\t\tll curCnt = 0;\n\t\tfor (int j = i - 1; j >= 0; j--) {\n\t\t\tif (!prime[vec[j + 1] - vec[j]]) {\n\t\t\t\tcurCnt++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcurCnt += 2;\n\t\t\t\tif (vec[j + 1] - vec[j] == 2) {\n\t\t\t\t\tcurCnt++;\n\t\t\t\t}\n\t\t\t\telse if ((vec[j + 1] - vec[j]) % 2 == 0) {\n\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tcurCnt++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tll vl = 0;\n\t\t\tif (!prime[vec[i] - vec[j]]) {\n\t\t\t\tvl = 1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tvl = 2;\n\t\t\t\tif (vec[i] - vec[j] == 2) {\n\t\t\t\t\tvl++;\n\t\t\t\t}\n\t\t\t\telse if ((vec[i] - vec[j]) % 2 == 0) {\n\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tvl++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdp[i + 1] = min(dp[i + 1], curCnt + vl + dp[j]);\n\t\t}\n\t}\n\n\tcout << dp[n];\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 10000010;\n\n\nint n,fre[maxn],p[220],isprime[maxn],even,odd,wrong;\nvector <int> edge[220],v2;\n\nbool fin(int u) {\n    if (fre[u]=wrong) return false;\n    fre[u]=wrong;\n    for (int j=0;j<edge[u].size();j++) {\n        int v=edge[u][j];\n        if (p[v]=0 || fin(p[v])) {\n            p[u]=v;\n            p[v]=u;\n            return true;\n        }\n    }\n    return false;\n}\n\nint main() {\n  //  freopen(\"in.txt\",\"r\",stdin);\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    isprime[1]=1;\n    for (int i=2;i<=maxn;i++)\n        if (isprime[i]==0) {\n            for (int j=i+i;j<=maxn;j+=i) isprime[j]=1;\n        }\n    cin>>n;\n    for (int i=1;i<=n;i++) {\n        int x;\n        cin>>x;\n        fre[x]=1;\n    }\n    even=0; odd=0; wrong=2;\n    int id=1;\n    while (id<=maxn) {\n        if (fre[id]==0) id++;\n        else {\n            v2.push_back(id);\n            if (id%2==0) even++; else odd++ ;\n            id++;\n            while (id<=maxn && fre[id]==1) id++;\n            v2.push_back(id);\n            if (id%2==0) even++; else odd++ ;\n        }\n    }\n    // for (int i=0;i<v2.size();i++) cout<<v2[i]<<\" \";\n   //  cout<<endl;\n   // cout<<\" \" <<even<<\" \"<<odd<<endl;\n    for (int i=0;i<v2.size();i++)\n        for (int j=i+1;j<v2.size();j++)\n            if (isprime[ v2[j] - v2[i] ]==0) {\n               // cout<<i<<\" \"<<j<<endl;\n                edge[i+1].push_back(j+1);\n                edge[j+1].push_back(i+1);\n            }\n    int cnt=0;\n    for (int i=0;i<v2.size();i++) {\n        wrong++;\n        cnt+=(fin(i));\n    }\n   // cout<<cnt<<\" \" <<even<<\" \"<<odd<<endl;\n    cout<< cnt + ((even-cnt)/2 + (odd-cnt)/2) * 2 + (even%2)*3;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <climits>\n#include <queue>\n#include <algorithm>\n\nusing std::queue;\nusing std::min;\n\nconst int MAXX=1e7+5,MAXN=105;\nint n,cnt_x,cnt_y;\nint x_id[MAXN],y_id[MAXN];\nbool up[MAXX];\n\nstruct node{int he,iter,dis;}d[MAXN];\nstruct line{int to,nex,cap;}ed[MAXN*MAXN];\n\ninline bool is_odd_prm(int x){\n\tif(x==2) return false;\n\tfor(int i=3;i*i<=x;i+=2){\n\t\tif(x%i==0) return false;\n\t}\n\treturn true;\n}\n\ninline void addE(int u,int v,int cap){\n\tstatic int cnt=1;\n\ted[++cnt]=(line){v,d[u].he};\n\td[u].he=cnt;\n}\n\ninline int revE(int i){return i^1;}\n\ninline bool BFS(int s,int t,int n){\n\tfor(int i=1;i<=n;++i)\n\t\td[i].dis=-1;\n\tstatic queue<int> q;\n\td[s].dis=0;\n\tq.push(s);\n\tint u;\n\twhile(q.size()){\n\t\tu=q.front();\n\t\tq.pop();\n\t\tfor(int i=d[u].he,v;i;i=ed[i].nex){\n\t\t\tif(ed[i].cap==0) continue;\n\t\t\tv=ed[i].to;\n\t\t\tif(d[v].dis==-1){\n\t\t\t\td[v].dis=d[u].dis+1;\n\t\t\t\tq.push(v);\n\t\t\t}\n\t\t}\n\t}\n\treturn d[t].dis!=-1;\n}\n\nint aug(int u,int rest,const int t){\n\tif(u==t) return rest;\n\tint ret=0;\n\tfor(int &i=d[u].iter,v,cap,flow;i;i=ed[i].nex){\n\t\tv=ed[i].to,cap=ed[i].cap;\n\t\tif(d[v].dis!=d[u].dis+1 || cap==0)\n\t\t\tcontinue;\n\t\tflow=aug(v,min(cap,rest-ret),t);\n\t\ted[i].cap-=flow,ed[revE(i)].cap+=flow;\n\t\tret+=flow;\n\t\tif(ret==rest) return ret;\n\t}\n\tif(ret==0) d[u].dis=-1;\n\treturn ret;\n}\n\ninline int Dinic(int s,int t,int n){\n\tint ret=0;\n\twhile(BFS(s,t,n)){\n\t\tfor(int i=1;i<=n;++i)\n\t\t\td[i].iter=d[i].he;\n\t\tret+=aug(s,INT_MAX,t);\n\t}\n\treturn ret;\n}\n\ninline void build(){\n\tfor(int i=1;i<=cnt_x;++i){\n\t\tfor(int j=1,v;j<=cnt_y;++j){\n\t\t\tif(is_odd_prm(abs(x_id[i]-y_id[j]))){\n\t\t\t\tv=j+cnt_x;\n\t\t\t\taddE(i,v,INT_MAX),addE(v,i,0);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=1,s=cnt_x+cnt_y+1;i<=cnt_x;++i)\n\t\taddE(s,i,1),addE(i,s,0);\n\tfor(int i=1,u,t=cnt_x+cnt_y+2;i<=cnt_y;++i){\n\t\tu=cnt_x+i;\n\t\taddE(u,t,1),addE(t,u,0);\n\t}\n}\n\nint main(){\n\tscanf(\"%d\",&n);\n\tint x;\n\tfor(int i=1;i<=n;++i){\n\t\tscanf(\"%d\",&x);\n\t\tup[x]=true;\n\t}\n\tfor(int i=1;i<=x+1;++i){\n\t\tif(up[i]!=up[i-1])\n\t\t\ti&1 ? x_id[++cnt_x]=i:y_id[++cnt_y]=i;\n\t}\n\tbuild();\n\tint k=Dinic((cnt_x+cnt_y)|1,cnt_x+cnt_y+2,cnt_x+cnt_y+2);\n\tprintf(\"%d\",k+((((cnt_x-k)>>1)+((cnt_y-k)>>1))<<1)+(cnt_x-k)%2*3);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define sqr(x) ((x)*(x))\n#define ll long long\n#define ull unsigned long long\n#define ui unsigned int\n#define ld long double\n#define vi vector<int>\n#define HEAP(T) priority_queue<T>\n#define heap(...) priority_queue<__VA_ARGS__,vector<__VA_ARGS__>,greater<__VA_ARGS__> > \n#define pii pair<int,int>\n#define pb push_back\n#define mp make_pair\n#define debuge cerr<<\"isok\"<<endl\n#define debug(x) cerr<<#x<<\"=\"<<x<<endl\n#define error(...) fprintf(stderr,__VA_ARGS__)\n#define SS second\n#define FF first\n#define ls (k<<1)\n#define rs (k<<1|1)\n#define inf 0x3f3f3f3f\n#define LL long long\n#define clr(a,x) memset(a,x,sizeof(a))\n#define cpy(a,x) memcpy(a,x,sizeof(a))\n#define file(x) freopen(x\".in\",\"r\",stdin),freopen(x\".out\",\"w\",stdout)\nusing namespace std;\n\nconst int N=20000005,M=100005,mod=1e9+7;\ntemplate<class T> inline void gmin(T &x,const T &y){if(x>y) x=y;}\ntemplate<class T> inline void gmax(T &x,const T &y){if(x<y) x=y;}\ntemplate<class T,class S> inline void ch(T &x,const S y){x=(x+y)%mod;}\nconst int BufferSize=1<<16;\nchar buffer[BufferSize],*Bufferhead,*Buffertail;\nbool Terminal;\ninline char Getchar(){\n\tif(Bufferhead==Buffertail){\n\t\tint l=fread(buffer,1,BufferSize,stdin);\n\t\tif(!l){Terminal=1;return 0;}\n\t\tBuffertail=(Bufferhead=buffer)+l;\n\t}\n\treturn *Bufferhead++;\n}\ntemplate<class T>inline bool read(T &x){\n\tx=0;char c=Getchar(),rev=0;\n\twhile(c<'0'||c>'9'){c=Getchar();rev|=c=='-';if(Terminal)return 0;}\n\twhile(c>='0'&&c<='9') x=x*10+c-'0',c=Getchar();\n\tx=rev?-x:x;\n\treturn 1;\n}\ninline bool reads(char *x){\n\tchar c=Getchar();\n\twhile(c<33||c>126){c=Getchar();if(Terminal)return 0;}\n\twhile(c>=33&&c<=126) (*x++)=c,c=Getchar();\n\t*x=0;return 1;\n}\ntemplate<class T>inline void print(T x,const char c){\n\tif(!x){putchar('0');putchar(c);return;}\n\tif(x<0) putchar('-'),x=-x;\n\tint m=0,a[10];\n\twhile(x) a[m++]=x%10,x/=10;\n\twhile(m--) putchar(a[m]+'0');\n\tputchar(c);\n}\ninline int exp(int x,int y,const int mod=::mod){\n\tint ans=1;\n\twhile(y){\n\t\tif(y&1) ans=(ll)ans*x%mod;\n\t\tx=(ll)x*x%mod;y>>=1;\n\t}return ans;\n}\n\nconst int Infinity = 2147483647;\n\nconst int MaxN = 400;\nconst int MaxM = 79800;\n\ntemplate <class T>\ninline void tension(T &a, const T &b)\n{\n\tif (b < a)\n\t\ta = b;\n}\ntemplate <class T> \ninline void relax(T &a, const T &b)\n{\n\tif (b > a)\n\t\ta = b;\n}\ntemplate <class T>\ninline int size(const T &a)\n{\n\treturn (int)a.size();\n}\n\nconst int MaxNX = MaxN + MaxN;\n\nstruct EDGE\n{\n\tint v, u, w;\n\n\tEDGE(){}\n\tEDGE(const int &_v, const int &_u, const int &_w)\n\t\t: v(_v), u(_u), w(_w){}\n};\n\nstruct blossom{\nint n, m;\nEDGE mat[MaxNX + 1][MaxNX + 1];\n\nint n_matches;\nLL tot_weight;\nint mate[MaxNX + 1];\nint lab[MaxNX + 1];\n\nint q_n, q[MaxN];\nint fa[MaxNX + 1], col[MaxNX + 1];\nint slackv[MaxNX + 1];\n\nint n_x;\nint bel[MaxNX + 1], blofrom[MaxNX + 1][MaxNX + 1];\nvector<int> bloch[MaxNX + 1];\n\ninline void prepare(int p){n=p;}\ninline void add_edge(int x,int y,int w){\n\tmat[x][y]=(EDGE){x,y,w};\n\tmat[y][x]=(EDGE){y,x,w};\n}\ninline int e_delta(const EDGE &e) // does not work inside blossoms\n{\n\treturn lab[e.v] + lab[e.u] - mat[e.v][e.u].w * 2;\n}\ninline void update_slackv(int v, int x)\n{\n\tif (!slackv[x] || e_delta(mat[v][x]) < e_delta(mat[slackv[x]][x]))\n\t\tslackv[x] = v;\n}\ninline void calc_slackv(int x)\n{\n\tslackv[x] = 0;\n\tfor (int v = 1; v <= n; v++)\n\t\tif (mat[v][x].w > 0 && bel[v] != x && col[bel[v]] == 0)\n\t\t\tupdate_slackv(v, x);\n}\n\ninline void q_push(int x)\n{\n\tif (x <= n)\n\t\tq[q_n++] = x;\n\telse\n\t{\n\t\tfor (int i = 0; i < size(bloch[x]); i++)\n\t\t\tq_push(bloch[x][i]);\n\t}\n}\ninline void set_mate(int xv, int xu)\n{\n\tmate[xv] = mat[xv][xu].u;\n\tif (xv > n)\n\t{\n\t\tEDGE e = mat[xv][xu];\n\t\tint xr = blofrom[xv][e.v];\n\t\tint pr = find(bloch[xv].begin(), bloch[xv].end(), xr) - bloch[xv].begin();\n\t\tif (pr % 2 == 1)\n\t\t{\n\t\t\treverse(bloch[xv].begin() + 1, bloch[xv].end());\n\t\t\tpr = size(bloch[xv]) - pr;\n\t\t}\n\n\t\tfor (int i = 0; i < pr; i++)\n\t\t\tset_mate(bloch[xv][i], bloch[xv][i ^ 1]);\n\t\tset_mate(xr, xu);\n\n\t\trotate(bloch[xv].begin(), bloch[xv].begin() + pr, bloch[xv].end());\n\t}\n}\ninline void set_bel(int x, int b)\n{\n\tbel[x] = b;\n\tif (x > n)\n\t{\n\t\tfor (int i = 0; i < size(bloch[x]); i++)\n\t\t\tset_bel(bloch[x][i], b);\n\t}\n}\n\ninline void augment(int xv, int xu)\n{\n\twhile (true)\n\t{\n\t\tint xnu = bel[mate[xv]];\n\t\tset_mate(xv, xu);\n\t\tif (!xnu)\n\t\t\treturn;\n\t\tset_mate(xnu, bel[fa[xnu]]);\n\t\txv = bel[fa[xnu]], xu = xnu;\n\t}\n}\ninline int get_lca(int xv, int xu)\n{\n\tstatic bool book[MaxNX + 1];\n\tfor (int x = 1; x <= n_x; x++)\n\t\tbook[x] = false;\n\twhile (xv || xu)\n\t{\n\t\tif (xv)\n\t\t{\n\t\t\tif (book[xv])\n\t\t\t\treturn xv;\n\t\t\tbook[xv] = true;\n\t\t\txv = bel[mate[xv]];\n\t\t\tif (xv)\n\t\t\t\txv = bel[fa[xv]];\n\t\t}\n\t\tswap(xv, xu);\n\t}\n\treturn 0;\n}\n\ninline void add_blossom(int xv, int xa, int xu)\n{\n\tint b = n + 1;\n\twhile (b <= n_x && bel[b])\n\t\tb++;\n\tif (b > n_x)\n\t\tn_x++;\n\n\tlab[b] = 0;\n\tcol[b] = 0;\n\n\tmate[b] = mate[xa];\n\n\tbloch[b].clear();\n\tbloch[b].push_back(xa);\n\tfor (int x = xv; x != xa; x = bel[fa[bel[mate[x]]]])\n\t\tbloch[b].push_back(x), bloch[b].push_back(bel[mate[x]]), q_push(bel[mate[x]]);\n\treverse(bloch[b].begin() + 1, bloch[b].end());\n\tfor (int x = xu; x != xa; x = bel[fa[bel[mate[x]]]])\n\t\tbloch[b].push_back(x), bloch[b].push_back(bel[mate[x]]), q_push(bel[mate[x]]);\n\n\tset_bel(b, b);\n\n\tfor (int x = 1; x <= n_x; x++)\n\t{\n\t\tmat[b][x].w = mat[x][b].w = 0;\n\t\tblofrom[b][x] = 0;\n\t}\n\tfor (int i = 0; i < size(bloch[b]); i++)\n\t{\n\t\tint xs = bloch[b][i];\n\t\tfor (int x = 1; x <= n_x; x++)\n\t\t\tif (mat[b][x].w == 0 || e_delta(mat[xs][x]) < e_delta(mat[b][x]))\n\t\t\t\tmat[b][x] = mat[xs][x], mat[x][b] = mat[x][xs];\n\t\tfor (int x = 1; x <= n_x; x++)\n\t\t\tif (blofrom[xs][x])\n\t\t\t\tblofrom[b][x] = xs;\n\t}\n\tcalc_slackv(b);\n}\ninline void expand_blossom1(int b) // lab[b] == 1\n{\n\tfor (int i = 0; i < size(bloch[b]); i++)\n\t\tset_bel(bloch[b][i], bloch[b][i]);\n\n\tint xr = blofrom[b][mat[b][fa[b]].v];\n\tint pr = find(bloch[b].begin(), bloch[b].end(), xr) - bloch[b].begin();\n\tif (pr % 2 == 1)\n\t{\n\t\treverse(bloch[b].begin() + 1, bloch[b].end());\n\t\tpr = size(bloch[b]) - pr;\n\t}\n\n\tfor (int i = 0; i < pr; i += 2)\n\t{\n\t\tint xs = bloch[b][i], xns = bloch[b][i + 1];\n\t\tfa[xs] = mat[xns][xs].v;\n\t\tcol[xs] = 1, col[xns] = 0;\n\t\tslackv[xs] = 0, calc_slackv(xns);\n\t\tq_push(xns);\n\t}\n\tcol[xr] = 1;\n\tfa[xr] = fa[b];\n\tfor (int i = pr + 1; i < size(bloch[b]); i++)\n\t{\n\t\tint xs = bloch[b][i];\n\t\tcol[xs] = -1;\n\t\tcalc_slackv(xs);\n\t}\n\n\tbel[b] = 0;\n}\ninline void expand_blossom_final(int b) // at the final stage\n{\n\tfor (int i = 0; i < size(bloch[b]); i++)\n\t{\n\t\tif (bloch[b][i] > n && lab[bloch[b][i]] == 0)\n\t\t\texpand_blossom_final(bloch[b][i]);\n\t\telse\n\t\t\tset_bel(bloch[b][i], bloch[b][i]);\n\t}\n\tbel[b] = 0;\n}\n\ninline bool on_found_EDGE(const EDGE &e)\n{\n\tint xv = bel[e.v], xu = bel[e.u];\n\tif (col[xu] == -1)\n\t{\n\t\tint nv = bel[mate[xu]];\n\t\tfa[xu] = e.v;\n\t\tcol[xu] = 1, col[nv] = 0;\n\t\tslackv[xu] = slackv[nv] = 0;\n\t\tq_push(nv);\n\t}\n\telse if (col[xu] == 0)\n\t{\n\t\tint xa = get_lca(xv, xu);\n\t\tif (!xa)\n\t\t{\n\t\t\taugment(xv, xu), augment(xu, xv);\n\t\t\tfor (int b = n + 1; b <= n_x; b++)\n\t\t\t\tif (bel[b] == b && lab[b] == 0)\n\t\t\t\t\texpand_blossom_final(b);\n\t\t\treturn true;\n\t\t}\n\t\telse\n\t\t\tadd_blossom(xv, xa, xu);\n\t}\n\treturn false;\n}\n\nbool match()\n{\n\tfor (int x = 1; x <= n_x; x++)\n\t\tcol[x] = -1, slackv[x] = 0;\n\n\tq_n = 0;\n\tfor (int x = 1; x <= n_x; x++)\n\t\tif (bel[x] == x && !mate[x])\n\t\t\tfa[x] = 0, col[x] = 0, slackv[x] = 0, q_push(x);\n\tif (q_n == 0)\n\t\treturn false;\n\n\twhile (true)\n\t{\n\t\tfor (int i = 0; i < q_n; i++)\n\t\t{\n\t\t\tint v = q[i];\n\t\t\tfor (int u = 1; u <= n; u++)\n\t\t\t\tif (mat[v][u].w > 0 && bel[v] != bel[u])\n\t\t\t\t{\n\t\t\t\t\tint d = e_delta(mat[v][u]);\n\t\t\t\t\tif (d == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (on_found_EDGE(mat[v][u]))\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\telse if (col[bel[u]] == -1 || col[bel[u]] == 0)\n\t\t\t\t\t\tupdate_slackv(v, bel[u]);\n\t\t\t\t}\n\t\t}\n\n\t\tint d = Infinity;\n\t\tfor (int v = 1; v <= n; v++)\n\t\t\tif (col[bel[v]] == 0)\n\t\t\t\ttension(d, lab[v]);\n\t\tfor (int b = n + 1; b <= n_x; b++)\n\t\t\tif (bel[b] == b && col[b] == 1)\n\t\t\t\ttension(d, lab[b] / 2);\n\t\tfor (int x = 1; x <= n_x; x++)\n\t\t\tif (bel[x] == x && slackv[x])\n\t\t\t{\n\t\t\t\tif (col[x] == -1)\n\t\t\t\t\ttension(d, e_delta(mat[slackv[x]][x]));\n\t\t\t\telse if (col[x] == 0)\n\t\t\t\t\ttension(d, e_delta(mat[slackv[x]][x]) / 2);\n\t\t\t}\n\n\t\tfor (int v = 1; v <= n; v++)\n\t\t{\n\t\t\tif (col[bel[v]] == 0)\n\t\t\t\tlab[v] -= d;\n\t\t\telse if (col[bel[v]] == 1)\n\t\t\t\tlab[v] += d;\n\t\t}\n\t\tfor (int b = n + 1; b <= n_x; b++)\n\t\t\tif (bel[b] == b)\n\t\t\t{\n\t\t\t\tif (col[bel[b]] == 0)\n\t\t\t\t\tlab[b] += d * 2;\n\t\t\t\telse if (col[bel[b]] == 1)\n\t\t\t\t\tlab[b] -= d * 2;\n\t\t\t}\n\n\t\tq_n = 0;\n\t\tfor (int v = 1; v <= n; v++)\n\t\t\tif (lab[v] == 0) // all unmatched vertices' labels are zero! cheers!\n\t\t\t\treturn false;\n\t\tfor (int x = 1; x <= n_x; x++)\n\t\t\tif (bel[x] == x && slackv[x] && bel[slackv[x]] != x && e_delta(mat[slackv[x]][x]) == 0)\n\t\t\t{\n\t\t\t\tif (on_found_EDGE(mat[slackv[x]][x]))\n\t\t\t\t\treturn true;\n\t\t\t}\n\t\tfor (int b = n + 1; b <= n_x; b++)\n\t\t\tif (bel[b] == b && col[b] == 1 && lab[b] == 0)\n\t\t\t\texpand_blossom1(b);\n\t}\n\treturn false;\n}\n\nvoid calc_max_weight_match()\n{\n\tfor (int v = 1; v <= n; v++)\n\t\tmate[v] = 0;\n\n\tn_x = n;\n\tn_matches = 0;\n\ttot_weight = 0;\n\n\tbel[0] = 0;\n\tfor (int v = 1; v <= n; v++)\n\t\tbel[v] = v, bloch[v].clear();\n\tfor (int v = 1; v <= n; v++)\n\t\tfor (int u = 1; u <= n; u++)\n\t\t\tblofrom[v][u] = v == u ? v : 0;\n\n\tint w_max = 0;\n\tfor (int v = 1; v <= n; v++)\n\t\tfor (int u = 1; u <= n; u++)\n\t\t\trelax(w_max, mat[v][u].w);\n\tfor (int v = 1; v <= n; v++)\n\t\tlab[v] = w_max;\n\n\twhile (match())\n\t\tn_matches++;\n\n\tfor (int v = 1; v <= n; v++)\n\t\tif (mate[v] && mate[v] < v)\n\t\t\ttot_weight += mat[v][mate[v]].w;\n}\nint return_value(){\n\tcalc_max_weight_match();\n\treturn tot_weight;\n}\n}p;\n\ninline bool check(int x){\n\tif(x==1) return 0;\n\tfor(int i=2;i*i<=x;i++)\t\n\t\tif(x%i==0) return 0;\n\treturn 1;\t\n}\nint calc(int n){\n\tif(!n) return 0;\n\tif(n%2==0) return 2;\n\tif(check(n)) return 3;\n\treturn 1;\n}\nbool f[N];\nint n,a[205];\n\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++){\n\t\tint x;scanf(\"%d\",&x);\n\t\tf[x]=1;\n\t}\n\tn=0;\n\tfor(int i=1;i<=10000001;i++) \n\t\tif(f[i]^f[i-1]) a[++n]=i;\n\tp.prepare(n);\n\tfor(int v=1;v<=n;v++)\n\t\tfor(int u=1;u<=n;u++)\n\t\t\tif(u!=v) p.add_edge(v,u,calc(abs(a[u]-a[v])));\n\tprintf(\"%d\\n\", n*2-p.return_value());\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <utility>\n#include <vector>\n#include <cmath>\n#include <queue>\n#include <cstring>\n#include <cstdlib>\n\nusing namespace std;\ntypedef pair<int,int> P;\n\nint N;\nint x[110];\nint y[210];\nbool isPrimeNumber(int x) {\n  if (x<=2) {\n    return false;\n  }\n  for(int i=2;i<=sqrt(x)+1;++i) {\n    if (x%i==0) {\n      return false;\n    }\n  }\n  return true;\n}\nclass Dinic {\npublic:\n  struct Edge{\n    int from,to,capacity,flow;\n    int calcRest(bool isRev) {\n      return isRev ? flow : capacity-flow;\n    }\n    int getNext(bool isRev) {\n      return isRev ? from : to;\n    }\n  };\n  static const int MAX_E=100000;\n  static const int MAX_V=500;\n  static const int INF=1000000;\n  int levels[MAX_V];\n  Edge edgeInstances[MAX_E];\n  vector<Edge*> edges[MAX_V][2]; // 1 => reverse edge\n  int E=0;\n\n  void addEdge(Edge edge) {\n    edgeInstances[E] = edge;\n    edges[edge.from][0].push_back(&edgeInstances[E]);\n    edges[edge.to][1].push_back(&edgeInstances[E]);\n    E++;\n  }\n\n  bool setLevels(int s, int t) {\n    memset(levels,-1,sizeof(levels));\n    queue<int> Q;\n    Q.push(s);\n    levels[s] = 0;\n    while(!Q.empty()) {\n      int current = Q.front();\n      Q.pop();\n      if(current==t) {\n        return true;\n      }\n\n      for(int j=0;j<2;++j) {\n        bool revEdge = j == 1;\n        vector<Edge*>& edgeList=edges[current][j];\n        for(int i=0;i<edgeList.size();++i) {\n          Edge& edge = *edgeList[i];\n          int rest = edge.calcRest(revEdge), next = edge.getNext(revEdge);\n          if(levels[next]!=-1) continue;\n          if(rest > 0){\n            levels[next] = levels[current] + 1;\n            Q.push(next);\n          }\n        }\n      }\n    }\n    return false;\n  }\n\n  int calcMaxFlow(int s, int t) {\n    int max_flow=0;\n    while(true) {\n      bool continueFlag = setLevels(s,t);\n      if(!continueFlag) {\n        break;\n      }\n      while(true) {\n        int flow = findFlow(s, t, INF);\n        max_flow += flow;\n        if(flow==0) {\n          break;\n        }\n      }\n    }\n    return max_flow;\n  }\n\n  int findFlow(int current, int destination, int flow) {\n    if(current == destination) return flow;\n\n    for(int j=0;j<2;++j) {\n      bool revEdge = j == 1;\n      vector<Edge*>& edgeList=edges[current][j];\n      for(int i=0;i<edgeList.size();++i) {\n        Edge& edge = *edgeList[i];\n        int rest = edge.calcRest(revEdge), next = edge.getNext(revEdge);\n        if(levels[next]<=levels[current])continue;\n        if(rest > 0){\n          int max_flow = findFlow(next, destination, min(rest,flow));\n          edge.flow += revEdge ? -max_flow: max_flow;\n          if(max_flow>0) {\n            return max_flow;\n          }\n        }\n      }\n    }\n    return 0;\n  }\n\n};\n\nDinic dinic;\nint main() {\n  int num=0;\n  int numEven=0;\n  int numOdd=0;\n  memset(y,0,sizeof(y));\n  memset(x,-1,sizeof(x));\n  scanf(\"%d\", &N);\n  for(int i=0;i<N;++i) {\n    scanf(\"%d\", &x[i]);\n  }\n  for(int i=0;i<N;++i) {\n    if (i==0) {\n      y[num++] = x[i];\n    } else if(x[i-1]!=x[i]-1) {\n      y[num++] = x[i];\n    }\n    if (x[i]!=x[i+1]-1) {\n      y[num++] = x[i]+1;\n    }\n  }\n  for(int i=0;i<num;++i) {\n    if(y[i]%2==0) {\n      numEven++;\n    } else {\n      numOdd++;\n    }\n  }\n  for(int i=0;i<num;++i) {\n    dinic.addEdge({0,i+1,1,0});\n    dinic.addEdge({201+i,450,1,0});\n    for(int j=0;j<num;++j) {\n      if(y[i]%2==1 && y[j]%2==0 && isPrimeNumber(abs(y[j]-y[i]))) {\n        dinic.addEdge({i+1,201+j,1,0});\n      }\n    }\n  }\n  int maxk=dinic.calcMaxFlow(0, 450);\n  printf(\"%d\\n\", maxk + ((numEven-maxk)/2+(numOdd-maxk)/2)*2 + ((numEven-maxk)%2) * 3);\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <map>\n#include <ctime>\n#include <set>\n\n#define Rep(i, n) for (int i = 1; i <= n; i ++)\n#define Rep0(i, n) for (int i = 0; i <= n; i ++)\n#define RepG(i, x) for (int i = head[x]; i; i = edge[i].next)\n#define v edge[i].to\n#define mp(a, b) make_pair(a, b)\n#define fi first\n#define se second\n\nusing namespace std;\n\nconst int N = 210;\n\nbool isnotprime[10000010];\nint prime[10000010], cnt;\nvoid get_prime()\n{\n\tisnotprime[1] = true;\n\tfor (int i = 2; i <= 10000000; i ++) {\n\t\tif (!isnotprime[i]) prime[++ cnt] = i;\n\t\tfor (int j = 1; j <= cnt && i * prime[j] <= 10000000; j ++) {\n\t\t\tisnotprime[i * prime[j]] = true;\n\t\t\tif (!(i % prime[j])) break;\n\t\t}\n\t}\n}\n\nint vv[10000010], p[N], d0[N], d1[N], lnk[N], cd0, cd1;\nbool vis[N];\nbool dfs(int x)\n{\n\tRep(i, cd1) if (!isnotprime[abs(d0[x] - d1[i])] && !vis[i]) {\n\t//\tprintf(\"!%d\\n\", abs(d0[x] - d1[i]));\n\t\tvis[i] = true;\n\t\tif (lnk[i] == -1 || dfs(lnk[i])){ lnk[i] = x; return true;} \n\t}\n\treturn false;\n}\n\nint main()\n{\n\tget_prime();\n\t\n\tint T = 1;\n\t//scanf(\"%d\", &T);\n\twhile (T --){\n\t\tint n;\n\t\tscanf(\"%d\", &n);\n\t\tcd0 = cd1 = 0;\n\t\tRep(i, n) {\n\t\t\tscanf(\"%d\", &p[i]);\n\t\t\tif (vv[p[i]] != T + 1) vv[p[i]] = T + 1;\n\t\t}\n\t\tRep(i, n) {\n\t\t\tif (vv[p[i]] != vv[p[i] - 1]) {\n\t\t\t\tif (p[i] & 1) d1[++ cd1] = p[i];\n\t\t\t\telse d0[++ cd0] = p[i];\n\t\t\t}\n\t\t\tif (vv[p[i]] != vv[p[i] + 1]) {\n\t\t\t\tif (p[i] & 1) d0[++ cd0] = p[i] + 1;\n\t\t\t\telse d1[++ cd1] = p[i] + 1;\n\t\t\t}\n\t\t}\n\t//\tprintf(\"%d %d\\n\", cd0, cd1);\n\t//\tRep(i, cd0) printf(\"_%d \", d0[i]); printf(\"\\n\");\n\t//\tRep(i, cd1) printf(\"_%d \", d1[i]); printf(\"\\n\");\n\t\t\n\t\tint ans = 0;\n\t\tmemset(lnk, -1, sizeof(lnk));\n\t\tRep(i, cd0) {\n\t\t\tmemset(vis, false, sizeof(vis));\n\t\t\tif (dfs(i)) ans ++;\n\t\t}\n\t\tans += ((cd0 - ans) / 2) * 2 + ((cd1 - ans) / 2) * 2;\n\t\tif ((cd0 - ans) & 1) ans += 3;\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\t\n\treturn 0;\n}\n/*\n3\n2\n2 3\n3\n1 2 4\n5\n101 102 103 104 105\n*/"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<cmath>\nusing namespace std;\n#define N 11000000\n#define INF 0x3f3f3f3f\n#define M 7031004\nstruct node{\n\tint to,next,res;\n}q[M];\nint head[22003],ss,prm[N],dep[23104],ct,a[N],S,T,que[20310],h[20310],cir[20104];bool ip[N];\nvoid addedge(int x,int y,int r)\n{\n\tq[++ss]=(node){y,head[x],r};head[x]=ss;\n\tq[++ss]=(node){x,head[y],0};head[y]=ss;\n}\nbool bfs()\n{\n\tmemset(dep,0,sizeof(dep));\n\tmemcpy(cir,head,4*(T+10));\n\tdep[S]=1;\n\tint f=1,e=0;\n\tque[++e]=S;\n\twhile(f<=e)\n\t{\n\t\tint u=que[f++];\n\t\tfor (int j=head[u];~j;j=q[j].next)\n\t\t\tif (q[j].res&&!dep[q[j].to])\n\t\t\t{\n\t\t\t\tint t=q[j].to;\n\t\t\t\tdep[t]=dep[u]+1;\n\t\t\t\tque[++e]=t;\n\t\t\t}\n\t}\n\treturn dep[T]>0;\n}\nint dfs(int i,int flow)\n{\n\tif (i==T||!flow) return flow;\n\tint f,dist=0;\n\tfor (int &j=cir[i];~j;j=q[j].next)\n\t\tif (dep[q[j].to]==dep[i]+1&&q[j].res&&(f=dfs(q[j].to,min(q[j].res,flow-dist))))\n\t\t{\n\t\t\tdist+=f;\n\t\t\tq[j].res-=f;\n\t\t\tq[j^1].res+=f;\n\t\t}\n\treturn dist;\n}\nint dinic()\n{\n\tint ans=0;\n\twhile(bfs()) ans+=dfs(S,INF);\n\treturn ans;\n}\nint main()\n{\n\tint n,TT,c=0,ans=0,odd;\n\tscanf(\"%d\",&TT);\n\tip[1]=true;ip[0]=true;\n\tfor (int i=2;i<=10000000;++i)\n\t{\n\t\tif (!ip[i]) prm[++ct]=i;\n\t\tfor (int j=1,to;j<=ct&&(to=i*prm[j])<=10000000;++j)\n\t\t{\n\t\t\tip[to]=true;\n\t\t\tif (i%prm[j]==0) break;\n\t\t}\n\t}\n\tip[2]=true;\n\ta[0]=-INF;\n\twhile(TT--)\n\t{\n\t\tscanf(\"%d\",&n);c=0;ss=-1;odd=0;\n\t\tmemset(head,-1,sizeof(head));\n\t\tfor (int i=1;i<=n;++i)\n\t\t{\n\t\t\tscanf(\"%d\",&a[i]);\n\t\t\tif (a[i]!=a[i-1]+1) h[++c]=a[i];\n\t\t\th[a[i]==a[i-1]+1?c:++c]=a[i]+1;\n\t\t}\n\t\tT=c+1;\n\t\tfor (int i=1;i<=c;++i)\n\t\t\tif (h[i]&1)\n\t\t\t{\n\t\t\t\taddedge(S,i,1);++odd;\n\t\t\t\tfor (int j=1;j<=c;++j)\n\t\t\t\t\tif (!ip[abs(h[j]-h[i])]) addedge(i,j,1);\n\t\t\t}else addedge(i,T,1);\n\t\tans=dinic();\n\t\tc-=odd;odd-=ans;\n\t\tprintf(\"%d\\n\",ans+(odd/2*2)+(c-ans)/2*2+(odd&1?3:0));\n\t}\n\treturn 0;\n}\n\n//by qlwpc"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define ii pair <int, int>\n#define app push_back\n#define all(a) a.begin(), a.end()\n#define bp __builtin_popcountll\n#define ll long long\n#define mp make_pair\n#define f first\n#define s second\n#define Time (double)clock()/CLOCKS_PER_SEC\n#define debug(x) std::cout << #x << \": \" << x << '\\n';\n\nnamespace Mag {\n#define forn(i, n) for (int i = 0; i < (int)(n); ++i)\nconst int maxn = 505;\ntypedef vector<int> vi;\n\n// BEGIN_CODE\nint n;\nvi e[maxn];\nint mt[maxn], p[maxn], base[maxn], b[maxn], blos[maxn];\nint q[maxn];\nint blca[maxn]; // used for lca\n\nvoid clear() {\n    for (int i = 0; i < maxn; ++i)  \n        e[i].clear();\n    memset(mt, 0, sizeof mt);\n    memset(p, 0, sizeof p);\n    memset(base, 0, sizeof base);\n    memset(b, 0, sizeof b);\n    memset(blos, 0, sizeof blos);\n    memset(q, 0, sizeof q);\n    memset(blca, 0, sizeof blca);\n}   \n\nint lca(int u, int v) {\n    forn(i, n) blca[i] = 0;\n    while (true) {\n        u = base[u];\n        blca[u] = 1;\n        if (mt[u] == -1) break;\n        u = p[mt[u]];\n    }\n    while (!blca[base[v]]) {\n        v = p[mt[base[v]]];\n    }\n    return base[v];\n}\n\nvoid mark_path(int v, int b, int ch) {\n    while (base[v] != b) {\n        blos[base[v]] = blos[base[mt[v]]] = 1;\n        p[v] = ch;\n        ch = mt[v];\n        v = p[mt[v]];\n    }\n}\n\nint find_path(int root) {\n    forn(i, n) {\n        base[i] = i;\n        p[i] = -1;\n        b[i] = 0;\n    }\n\n    b[root] = 1;\n    q[0] = root;\n    int lq = 0, rq = 1;\n    while (lq != rq) {\n        int v = q[lq++];\n        for (int to: e[v]) {\n            if (base[v] == base[to] || mt[v] == to) continue;\n            if (to==root || (mt[to] != -1 && p[mt[to]] != -1)) {\n                int curbase = lca(v, to);\n                forn(i, n) blos[i] = 0;\n                mark_path(v, curbase, to);\n                mark_path(to, curbase, v);\n                forn(i, n) if (blos[base[i]]) {\n                    base[i] = curbase;\n                    if (!b[i]) b[i] = 1, q[rq++] = i;\n                }\n            } else if (p[to] == -1) {\n                p[to] = v;\n                if (mt[to] == -1) {\n                    return to;\n                }\n                to = mt[to];\n                b[to] = 1;\n                q[rq++] = to;\n\n            }\n        }\n    }\n    return -1;\n}\n\nint matching() {\n    forn(i, n) mt[i] = -1;\n    int res = 0;\n    forn(i, n) if (mt[i] == -1) {\n        int v = find_path(i);\n        if (v != -1) {\n            ++res;\n            while (v != -1) {\n                int pv = p[v], ppv = mt[p[v]];\n                mt[v] = pv, mt[pv] = v;\n                v = ppv;\n            }\n        }\n    }\n    return res;\n}\n// END_CODE\n\nint match(int n_, int m, vector <ii> ed) {\n    clear();\n\n    n = n_;\n    for (auto t : ed) {\n        e[t.f].app(t.s);\n        e[t.s].app(t.f);\n    }   \n    int res = matching();\n    return res;\n}\n\n};\n\nconst int N = 207;\nconst int INF = 1e9+7;\nconst int C = 1e7+7;\n\nbool used[N];\n\nbool p[C];\n\nint get(int a, int b) {\n    if (b < a)\n        swap(a, b);\n\n    if ((b - a) % 2 == 0)\n        return 2;\n    else if (p[b-a])\n        return 1;\n    else\n        return 3;\n}\n\nint cost[N][N];\nint dp[1 << 20];\n\nsigned main() {\n    #ifdef HOME\n    freopen(\"input.txt\", \"r\", stdin);\n    #else\n    #define endl '\\n'\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    #endif\n    for (int i = 2; i < C; ++i)\n        p[i] = 1;\n    for (int i = 2; i < C; ++i) \n        if (p[i])\n            for (int j = i * 2; j < C; j += i)\n                p[j] = 0;\n\n    int n;\n    cin >> n;\n    map <int, int> d;\n    while (n--) {\n        int x;\n        cin >> x;\n        d[x] ^= 1;\n        d[x+1] ^= 1;        \n    }\n\n    vector <int> c;\n    for (auto e : d) {\n        if (e.s)\n            c.app(e.f);\n    }   \n\n    #ifdef HOME\n    cout << \"C : \";\n    for (auto e : c)\n        cout << e << ' ';\n    cout << endl;\n    #endif\n\n    if (c.size() > 20)\n        exit(1);\n\n    int ans = 0;\n    vector <ii> ed;\n    for (int i = 0; i < c.size(); ++i) {\n        for (int j = i + 1; j < c.size(); ++j) {\n            if (get(c[i], c[j]) == 1) {\n                ++ans;\n                ed.app(mp(i,j));\n            }\n        }   \n    }    \n    vector <int> cnt(2);\n    for (auto e : c)\n        cnt[e&1]++;\n    for (int t = 0; t < 2; ++t)\n        cnt[t] -= ans;\n\n    for (int t = 0; t < 2; ++t) {\n        ans += cnt[t] - (cnt[t]&1);\n        cnt[t] &= 1;\n    }\n\n    if (cnt[0]) {\n        ans += 3;\n    }   \n\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n\n#include <iostream>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <unordered_set>\n#include <queue>\n#include <set>\n#include <algorithm>\n#include <numeric>\n#include <list>\nusing namespace std;\n\nusing QWORD  = uint64_t;\nusing SQWORD = int64_t;\nusing DWORD  = uint32_t;\nusing SDWORD = int32_t;\nusing WORD   = uint16_t;\nusing SWORD  = int16_t;\nusing BYTE   = uint8_t;\nusing SBYTE  = int8_t;\nusing DOUBLE = double;\nusing FLOAT  = float;\n\n#define MIN_SDWORD (-2147483648)\n#define MAX_SDWORD (2147483647)\n#define MIN_SBYTE (-128)\n#define MAX_SBYTE (127)\n\n#define MIN_SQWORD (0x8000000000000000)\n#define MAX_SQWORD (0x7FFFFFFFFFFFFFFF)\n\n#define MAX_QWORD  (0xFFFFFFFFFFFFFFFF)\n#define MAX_DWORD  (0xFFFFFFFF)\n#define MAX_WORD   (0xFFFF)\n#define MAX_BYTE   (0xFF)\n\n#define MAX_DOUBLE      (1.0e+308)\n#define DOUBLE_EPS      (1.0e-12)\n#define MIN_DOUBLE_N    (-1.0e+308)\n\n#define ArrayLength(a)  (sizeof(a) / sizeof(a[0]))\n\nstatic inline DOUBLE MAX(DOUBLE a, DOUBLE b) { return a > b ? a : b; }\nstatic inline QWORD MAX(QWORD a, QWORD b) { return a > b ? a : b; }\nstatic inline DWORD MAX(DWORD a, DWORD b) { return a > b ? a : b; }\nstatic inline SDWORD MAX(SDWORD a, SDWORD b) { return a > b ? a : b; }\nstatic inline DOUBLE MIN(DOUBLE a, DOUBLE b) { return a < b ? a : b; }\nstatic inline QWORD MIN(QWORD a, QWORD b) { return a < b ? a : b; }\nstatic inline DWORD MIN(DWORD a, DWORD b) { return a < b ? a : b; }\nstatic inline SDWORD MIN(SDWORD a, SDWORD b) { return a < b ? a : b; }\nstatic inline DOUBLE ABS(DOUBLE a) { return 0 < a ? a : -a; };\n\n#define BYTE_BITS   (8)\n#define WORD_BITS   (16)\n#define DWORD_BITS  (32)\n#define QWORD_BITS  (64)\n\nstatic inline void inputStringSpSeparated(char *pcStr)\n{\n    char *pcCur = pcStr;\n    for (;;) {\n        char c = getchar();\n        if (('\\n' == c) || (EOF == c) || (' ' == c)) {\n            break;\n        }\n        *pcCur = c;\n        pcCur++;\n    }\n    *pcCur = '\\0';\n}\n\nstatic inline void inputString(char *pcStr)\n{\n    char *pcCur = pcStr;\n    for (;;) {\n        char c = getchar();\n        if (('\\n' == c) || (EOF == c)) {\n            break;\n        }\n        *pcCur = c;\n        pcCur++;\n    }\n    *pcCur = '\\0';\n}\n\n\nstatic inline SQWORD inputSQWORD(void)\n{\n    SQWORD sqNumber = 0;\n    SQWORD sqMultiplier = 1;\n    bool bRead = false;\n    for (;;) {\n        char c = getchar();\n        if (!bRead) {\n            if ('-' == c) {\n                sqMultiplier = -1;\n            }\n        }\n        if (('0' <= c) && (c <= '9')) {\n            sqNumber *= 10LL;\n            sqNumber += (SQWORD)(c - '0');\n            bRead = true;\n        } else {\n            if (bRead) {\n                return sqNumber * sqMultiplier;\n            }\n        }\n    }\n}\n\n\nstatic inline SDWORD inputSDWORD(void)\n{\n    SDWORD lNumber = 0;\n    SDWORD lMultiplier = 1;\n    bool bRead = false;\n    for (;;) {\n        char c = getchar();\n        if (!bRead) {\n            if ('-' == c) {\n                lMultiplier = -1;\n            }\n        }\n        if (('0' <= c) && (c <= '9')) {\n            lNumber *= 10;\n            lNumber += (c - '0');\n            bRead = true;\n        } else {\n            if (bRead) {\n                return lNumber * lMultiplier;\n            }\n        }\n    }\n}\n\nstatic inline DOUBLE inputFP(void)\n{\n    DOUBLE dInt = 0.0;\n    DOUBLE dFrac = 0.0;\n    DOUBLE dMultiplier = 1.0;\n    DWORD dwFpCnt = 0;\n    DOUBLE *pdCur = &dInt;\n    bool bRead = false;\n    for (;;) {\n        char c = getchar();\n        if (!bRead) {\n            if ('-' == c) {\n                dMultiplier = -1;\n            }\n        }\n        if ('.' == c) {\n            pdCur = &dFrac;\n        } else if (('0' <= c) && (c <= '9')) {\n            (*pdCur) *= 10;\n            (*pdCur) += (DOUBLE)(c - '0');\n            bRead = true;\n            if (pdCur == &dFrac) {\n                dwFpCnt++;\n            }\n        } else {\n            if (bRead) {\n                return dMultiplier * (dInt + dFrac / (pow((DOUBLE)10.0 , (DOUBLE)dwFpCnt)));\n            }\n        }\n    }\n}\n\n\n/**\n *  mod による操作ライブラリ\n */\n\n#define ANS_MOD (1000000007LL)\n \nstatic SQWORD addMod(SQWORD x, SQWORD y)\n{ \n    return (x + y) % ANS_MOD;\n}\n \nstatic SQWORD subMod(SQWORD x, SQWORD y)\n{\n    return (x - y + ANS_MOD) % ANS_MOD;\n}\n \nstatic SQWORD mulMod(SQWORD x, SQWORD y) \n{\n    return (x * y) % ANS_MOD;\n}\n \nstatic SQWORD powMod(SQWORD x, SQWORD e) {\n    SQWORD v = 1;\n    for (; e; x = mulMod(x, x), e >>= 1) {\n        if (e & 1) {\n            v = mulMod(v, x);\n        }\n    }\n    return v;\n}\n \nstatic SQWORD divMod(SQWORD x, SQWORD y)\n{\n    return mulMod(x, powMod(y, ANS_MOD - 2));\n}\n \n \nstatic SQWORD combMod(SQWORD n, SQWORD k)\n{\n    SQWORD v=1;\n    for(SQWORD i=1; i<=k; i++) {\n        v = divMod(mulMod(v, n-i+1),i);\n    } \n    return v;\n}\n\n/*----------------------------------------------*/\n\ntypedef struct {\n    SDWORD lTo;\n    SQWORD sqCap;\n    SQWORD sqCost;\n    SDWORD lRev;\n} ST_EDGE;\n\n#define MAX_V   (402)\n\nstruct Flow {\nprivate:\n    vector<ST_EDGE> avGraph[MAX_V];\n    SDWORD  alDimsFrom[MAX_V];\n    SDWORD  alDimsTo[MAX_V];\n    SQWORD  sqEdgeNum;\n    SQWORD  asqDist[MAX_V];\n    SDWORD  alPrevV[MAX_V];   \n    SDWORD  alPrevEdge[MAX_V];      /*直前の頂点と辺 */\n\n    SDWORD  alDinic_Level[MAX_V];\n    SDWORD  alDinic_Iter[MAX_V];\n\npublic:\n    Flow() {\n        for (auto v: avGraph) {\n            v.clear();\n        }\n        memset(alDimsFrom, 0, sizeof(alDimsFrom));\n        memset(alDimsTo, 0, sizeof(alDimsTo));\n        memset(asqDist, 0, sizeof(asqDist));\n        memset(alPrevV, 0, sizeof(alPrevV)); \n        memset(alPrevEdge, 0, sizeof(alPrevEdge));\n        memset(alDinic_Level, 0, sizeof(alDinic_Level));\n        memset(alDinic_Iter, 0, sizeof(alDinic_Iter));\n    }\n    void addEdge(SDWORD lFrom, SDWORD lTo, SQWORD sqCap, SQWORD sqCost) {\n//        printf(\"%d ----[%lld] ----> %d\\n\", lFrom, sqCap, lTo);\n        \n        alDimsFrom[lFrom]++;\n        alDimsTo[lTo]++;\n        avGraph[lFrom].push_back((ST_EDGE){lTo, sqCap, sqCost, (SDWORD)(avGraph[lTo].size())});\n        avGraph[lTo].push_back((ST_EDGE){lFrom, 0, -sqCost, (SDWORD)(avGraph[lFrom].size() - 1)});\n    }\n\n    SDWORD minCostFlow(SDWORD lStart, SDWORD lTarget, SQWORD sqFlow)\n    {\n        SQWORD sqRes = 0;\n        SQWORD sqFlowRest = sqFlow;\n        while (0 < sqFlowRest) {\n            /* Bellman-Ford Method */\n            fill(asqDist, asqDist + ArrayLength(asqDist), MAX_SDWORD);\n            asqDist[lStart] = 0;\n            bool bIsUpdate = true;\n            while (bIsUpdate) {\n                bIsUpdate = false;\n                for (SDWORD lV = 0; lV < MAX_V; lV++) {\n                    for (SDWORD lIdx = 0; lIdx < avGraph[lV].size(); lIdx++) {\n                        ST_EDGE &stE = avGraph[lV][lIdx];\n                        if ((asqDist[lV] != MAX_SDWORD)\n                                && (0 < stE.sqCap)\n                                && (asqDist[lV] + stE.sqCost < asqDist[stE.lTo])) {\n                            asqDist[stE.lTo] = asqDist[lV] + stE.sqCost;\n                            alPrevV[stE.lTo] = lV;\n                            alPrevEdge[stE.lTo] = lIdx;\n                            bIsUpdate = true;\n                        }\n                    }\n                }\n            }\n            if (asqDist[lTarget] == MAX_SDWORD) {\n                return -1;\n            }\n\n            SQWORD sqAddFlow = MAX_SQWORD;\n            for (SDWORD lV = lTarget; lV != lStart; lV = alPrevV[lV]) {\n                sqAddFlow = min(sqAddFlow, avGraph[alPrevV[lV]][alPrevEdge[lV]].sqCap);\n            }\n            sqFlowRest -= sqAddFlow;\n            sqRes += sqAddFlow * asqDist[lTarget];      // 後で目的変数は書き換える\n            for (SDWORD lV = lTarget; lV != lStart; lV = alPrevV[lV]) {\n                ST_EDGE &stE = avGraph[alPrevV[lV]][alPrevEdge[lV]];\n                stE.sqCap -= sqAddFlow;\n                avGraph[lV][stE.lRev].sqCap += sqAddFlow;\n            }\n        }\n        return sqRes;\n    }\n\nprivate:\n    SQWORD maxFlowDinicBfs(SDWORD lS)\n    {\n        memset(alDinic_Level, -1, sizeof(alDinic_Level));\n        queue<SDWORD> queSearch;\n        alDinic_Level[lS] = 0;\n        queSearch.push(lS);\n        while (!queSearch.empty()) {\n            SDWORD lV = queSearch.front();\n            queSearch.pop();\n            for (SDWORD lIdx = 0; lIdx < avGraph[lV].size(); lIdx++) {\n                ST_EDGE &stE = avGraph[lV][lIdx];\n                if ((0 < stE.sqCap) && (alDinic_Level[stE.lTo] < 0)) {\n                    alDinic_Level[stE.lTo] = alDinic_Level[lV] + 1;\n                    queSearch.push(stE.lTo);\n                }\n            }\n        }\n\n        return 0;\n    }\n\n    SQWORD maxFlowDinicDfs(SDWORD lV, SDWORD lT, SQWORD sqF)\n    {\n        if (lV == lT) {\n            return sqF;\n        }\n        for (SDWORD &lI = alDinic_Iter[lV]; lI < avGraph[lV].size(); lI++) {\n            ST_EDGE &stE = avGraph[lV][lI];\n            if ((0 < stE.sqCap) && (alDinic_Level[lV] < alDinic_Level[stE.lTo])) {\n                SQWORD sqDiffFlow = maxFlowDinicDfs(stE.lTo, lT, min(sqF, stE.sqCap));\n                if (0 < sqDiffFlow) {\n                    stE.sqCap -= sqDiffFlow;\n                    avGraph[stE.lTo][stE.lRev].sqCap += sqDiffFlow;\n                    return sqDiffFlow;\n                }\n            }\n        }\n        return 0;\n    }\n\npublic:\n    SQWORD MaxFlow(SDWORD lStart, SDWORD lTarget)\n    {\n        SQWORD sqFlow = 0LL;\n        for (;;) {\n            maxFlowDinicBfs(lStart);\n            if (alDinic_Level[lTarget] < 0) {\n                return sqFlow;\n            }\n            memset(alDinic_Iter, 0, sizeof(alDinic_Iter));\n            while (1) {\n                SQWORD sqDiffFlow = maxFlowDinicDfs(lStart, lTarget, MAX_SQWORD);\n                sqFlow += sqDiffFlow;\n                if (0LL == sqDiffFlow) {\n                    break;\n                }\n            }\n        }\n    }\n\n    SQWORD getFlow(SDWORD lPnt, bool bFrom)\n    {\n        SQWORD sqCapSum = 0; \n        for (auto e: avGraph[lPnt]) {\n            sqCapSum += e.sqCap;\n        }\n        if (bFrom) {\n            return alDimsFrom[lPnt] - sqCapSum;\n        } else {\n            return alDimsTo[lPnt] - sqCapSum;\n        }\n    }\n};\n\n/*----------------------------------------------*/\n\nstatic void getPrimes(vector<SDWORD> &vlPrimes, SDWORD lMax)\n{\n    /* lSearchMax と ループ内の *2 の関係から、入力は3以上とすること */\n    if (!(1 <= lMax)) {\n        printf(\"Oops!\");\n        return;\n    }\n\n    /* 素数のリストを作る */\n    vector<bool> vbIsPrime(lMax + 1, true);\n    SDWORD lSearchMax = sqrt(lMax) + 1;\n    vbIsPrime[0] = false;\n    vbIsPrime[1] = false;\n    for (SDWORD lPrime = 2; lPrime < vbIsPrime.size(); lPrime++) {\n        if (vbIsPrime[lPrime]) {\n            vlPrimes.emplace_back(lPrime);\n            if (lPrime <= lSearchMax) {\n                for (SDWORD lCurNum = lPrime * 2; lCurNum <= lMax; lCurNum += lPrime) {\n                    vbIsPrime[lCurNum] = false;\n                }\n            }\n        }\n    }\n}    \n\n/*----------------------------------------------*/\n\n#define PNT_NO_START    (0)\n#define PNT_NO_OFFSET   (200)\n#define PNT_NO_TARGET   (401)\n#define FLOW_OFFSET     (1000000000)\n#define CAPACITY_INF    (1000000001)\n#define DUMMY_COST      (1)\n\nint main(void)\n{\n    SQWORD sqN = inputSQWORD();\n\n    Flow solverFlow;\n    vector<SQWORD> vsqA;\n    vector<SQWORD> vsqB;\n    vector<SDWORD> vlPrimes;\n\n    getPrimes(vlPrimes, 1e7 + 1);\n    vlPrimes.erase(find(vlPrimes.begin(), vlPrimes.end(), 2));\n\n    for (SQWORD sqIdx = 0; sqIdx < sqN; sqIdx++) {\n        SQWORD sqA = inputSQWORD();\n        vsqA.emplace_back(sqA);\n    }\n\n#if 1\n    for (auto it = vsqA.begin(); it != vsqA.end(); ++it) {\n//        printf(\"%lld %lld\\n\", *it, *(it - 1));\n        if (it == vsqA.begin()) {\n            vsqB.emplace_back(*it);\n        } else {\n            if ((*it) - 1 != *(it - 1)) {\n                vsqB.emplace_back(*it);\n            }\n        }\n        if (it == vsqA.end() - 1) {\n            vsqB.emplace_back((*it) + 1);\n        } else {\n            if ((*it) + 1 != *(it + 1)) {\n                vsqB.emplace_back((*it) + 1);\n            }\n        }\n    }\n#else\n    vsqB = vsqA;\n#endif\n\n    vector<SQWORD> vsqCOdd;\n    vector<SQWORD> vsqCEven;\n    \n    unordered_map<SQWORD, SQWORD> mapCEven, mapCOdd;\n\n    SQWORD sqIdx = 1;\n    for (auto b: vsqB) {\n        if (0 == b % 2) {\n            vsqCEven.emplace_back(b);\n            mapCEven[b] = sqIdx;\n        } else {\n            vsqCOdd.emplace_back(b);\n            mapCOdd[b] = sqIdx;\n        }\n        sqIdx++;\n    }\n\n    /* 二部マッチング */\n    for (auto c: vsqCEven) {\n        solverFlow.addEdge(PNT_NO_START, mapCEven[c], 1, DUMMY_COST);\n    }\n    for (auto c: vsqCEven) {\n        solverFlow.addEdge(mapCOdd[c] + PNT_NO_OFFSET, PNT_NO_TARGET, 1, DUMMY_COST);\n    }\n\n    for (auto p: vlPrimes) {\n        for (auto c: vsqCEven) {\n            auto it = lower_bound(vsqCOdd.begin(), vsqCOdd.end(), c + p);\n            if (it != vsqCOdd.end()) {\n                if (*it == c + p) {\n                    solverFlow.addEdge(mapCEven[c], mapCOdd[c + p] + PNT_NO_OFFSET, 1, DUMMY_COST);\n                }\n            }\n        }\n        for (auto c: vsqCOdd) {\n            auto it = lower_bound(vsqCEven.begin(), vsqCEven.end(), c + p);\n            if (it != vsqCEven.end()) {\n                if (*it == c + p) {\n                    solverFlow.addEdge(mapCEven[c + p], mapCOdd[c] + PNT_NO_OFFSET, 1, DUMMY_COST);\n                }\n            }\n        }\n    }\n\n\n\n    SQWORD sqMaxFlow = solverFlow.MaxFlow(PNT_NO_START, PNT_NO_TARGET);\n    SQWORD vsqCRestEven = 0;\n    SQWORD vsqCRestOdd = 0;\n    for (auto c: vsqCEven) {\n        SQWORD sqFlow = solverFlow.getFlow(mapCEven[c], true);\n        if (0 == sqFlow) {\n            vsqCRestEven++;\n        }\n    }\n    for (auto c: vsqCOdd) {\n        SQWORD sqFlow = solverFlow.getFlow(mapCOdd[c] + PNT_NO_OFFSET, false);\n        if (0 == sqFlow) {\n            vsqCRestOdd++;\n        }\n    }\n\n    SQWORD sqAns = sqMaxFlow;    \n    sqAns += ((vsqCRestEven / 2) * 2);\n    sqAns += ((vsqCRestOdd / 2) * 2);\n    if (0 < (vsqCRestEven %  2)) {\n        sqAns += 3;\n    }\n\n    printf(\"%lld\\n\", sqAns);\n\n    return 0;\n}\n/*------------------------------------------*/\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<cstring>\nusing namespace std;\nint n;\nint res;\nvector<int>v;\nint lst=-1;\nint match[210];\nint me,mo;\nint mx;\nbool f[10000010];\nvector<int>ok[210];\nbool vis[210];\nint prm[1000010];\nint sz;\nint l;\nbool bp(int x)\n{\n\tfor(int i=0;i<ok[x].size();i++)\n\t{\n\t\tint y=ok[x][i];\n\t\tif(vis[y])continue;\n\t\tvis[y]=true;\n\t\tif(match[y]==x)continue;\n\t\tif(match[y]==-1 || bp(match[y]))\n\t\t{\n\t\t\tmatch[y]=x;\n\t\t\tmatch[x]=y;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint x;\n\t\tscanf(\"%d\",&x);\n\t\tif(x!=lst+1)\n\t\t{\n\t\t\tif(lst+1)v.push_back(lst+1);\n\t\t\tv.push_back(x);\n\t\t}\n\t\tlst=x;\n\t\tmx=lst+1;\n\t}\n\tv.push_back(lst+1);\n\tf[1]=true;\n\tfor(int i=2;i<=mx;i++)\n\t{\n\t\tif(!f[i])prm[++sz]=i;\n\t\tfor(int j=1;j<=sz;j++)\n\t\t{\n\t\t\tif(prm[j]*i>mx)break;\n\t\t\tf[prm[j]*i]=true;\n\t\t\tif(i%prm[j]==0)break;\n\t\t}\n\t}\n\tl=v.size();\n\tfor(int i=0;i<l;i++)\n\t{\n\t\tmatch[i]=-1;\n\t\tif(v[i]&1)mo++;else me++;\n\t\tfor(int j=i+1;j<l;j++)\n\t\t{\n\t\t\tif(v[j]-v[i]!=2 && !f[v[j]-v[i]])\n\t\t\t{\n\t\t\t\tok[i].push_back(j);\n\t\t\t\tok[j].push_back(i);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<l;i++)\n\t{\n\t\tmemset(vis,false,sizeof(vis));\n\t\tvis[i]=true;\n\t\tif(bp(i))res++;\n\t}\n\tprintf(\"%d\",res+((me-res)/2+(mo-res)/2)*2+((me-res)%2)*3);\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\n#define X first\n#define Y second\n#define pb emplace_back\n#define FOR(i,a,b) for(int (i)=(a);i<(b);++(i))\n#define EFOR(i,a,b) for(int (i)=(a);i<=(b);++(i))\n#define rep(X,Y) for (int (X) = 0;(X) < (Y);++(X))\n#define REP rep\n#define rrep(X,Y) for (int (X) = (Y)-1;(X) >=0;--(X))\n#define all(X) (X).begin(),(X).end()\n#define eb emplace_back\n\nusing namespace std;\ntemplate<class T> using vv = vector<vector<T>>;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef ll LL;\ntypedef pii PII;\ntypedef pll PLL;\nconst ll MOD=1e9+7;\n\n#define rall(X) (X).rbegin(),(X).rend()\n#define UNIQUE(X) (X).erase(unique(all(X)),(X).end())\n#define reps(X,S,Y) for (int (X) = S;(X) < (Y);++(X))\n#define rreps(X,S,Y) for (int (X) = (Y)-1;(X) >= (S);--(X))\ntemplate<class T> inline bool MX(T &l,const T &r){return l<r?l=r,1:0;}\ntemplate<class T> inline bool MN(T &l,const T &r){return l>r?l=r,1:0;}\n\nint N;\nbool is_composite[11451419];\nmap<int, char> mp;\n\nstruct wg{\n  template<class T> using vv = vector<vector<T>>;\n\tstruct edge{\n\t\tint u, v, w;\n\t\tedge(int u=-1, int v=-1, int w = 0) : u(u), v(v), w(w) {}\n\t};\n\n\tconst int inf = 1e9;\n\n\tvv<edge> g;\n\tint n; //n%2==0\n\tvector<int> label, pa, slackpa, bel, tp, vis, match;\n\tqueue<int> q;\n\tvv<int> flower,flower_from;\n\n\tint e_delta(const edge& e) { //does not work inside blossoms\n\t\treturn label[e.u] + label[e.v] - g[e.u][e.v].w * 2;\n\t}\n\tvoid update_slackpa(int u, int x) {\n\t\tif (slackpa[x]==-1 || e_delta(g[u][x]) < e_delta(g[slackpa[x]][x])) slackpa[x] = u;\n\t}\n\tvoid set_slackpa(int x) {\n\t\tslackpa[x] = -1;\n    rep(u, n) if (bel[u] != x && tp[bel[u]] == 0) update_slackpa(u,x);\n\t}\n\tvoid q_push(int u) {\n\t\tif (u < n) q.push(u);\n\t\telse for (int v : flower[u]) q_push(v);\n\t}\n\tvoid set_st(int x, int b) {\n\t\tbel[x] = b;\n\t\tif (x >= n) for (int v : flower[x]) set_st(v, b);\n\t}\n\tint get_pr(int b, int xr) {\n\t\tint pr = find(all(flower[b]), xr) - flower[b].begin();\n\t\tif (pr%2) {\n\t\t\treverse(flower[b].begin()+1, flower[b].end());\n\t\t\tpr = (int)flower[b].size()-pr;\n\t\t}\n\t\treturn pr;\n\t}\n\tvoid set_match(int u, int v) {\n\t\tmatch[u] = g[u][v].v;\n\t\tif (u>=n) {\n\t\t\tedge e = g[u][v];\n\t\t\tint xr = flower_from[u][e.u];\n\t\t\tint pr = get_pr(u, xr);\n      rep(i, pr) {\n        set_match(flower[u][i], flower[u][i^1]);\n      }\n\t\t\tset_match(xr, v);\n\t\t\trotate(flower[u].begin(), flower[u].begin()+pr, flower[u].end());\n\t\t}\n\t}\n\tvoid augment(int u, int v) {\n\t\twhile (1) {\n\t\t\tint xnv = -1;\n\t\t\tif (match[u] != -1) xnv = bel[match[u]];\n\t\t\tset_match(u,v);\n\t\t\tif (xnv == -1) return;\n\t\t\tset_match(xnv, bel[pa[xnv]]);\n\t\t\tu = bel[pa[xnv]];\n\t\t\tv = xnv;\n\t\t}\n\t}\n\tint get_lca(int u, int v) {\n\t\tstatic int t=0;\n\t\tfor (++t; u!=-1 || v!=-1; swap(u,v)) {\n\t\t\tif (u == -1) continue;\n\t\t\tif (vis[u] == t) return u;\n\t\t\tvis[u] = t;\n\t\t\tif (match[u] == -1) {\n\t\t\t\tu = -1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tu = bel[match[u]];\n\t\t\tif (u!=-1) u = bel[pa[u]];\n\t\t}\n\t\treturn -1;\n\t}\n\tvoid add_blossom(int u, int lca, int v) {\n\t\tint b = n;\n\t\twhile(!flower[b].empty()) b++;\n\n\t\tlabel[b] = 0;\n\t\ttp[b] = 0;\n\t\tmatch[b] = match[lca];\n\t\tflower[b].clear();\n\t\tflower[b].push_back(lca);\n\n    int y;\n\t\tfor(int x=u; x!=lca; x = bel[pa[y]]){\n\t\t\tflower[b].push_back(x);\n\t\t\tflower[b].push_back(y = bel[match[x]]);\n\t\t\tq_push(y);\n\t\t}\n\t\treverse(flower[b].begin()+1,flower[b].end());\n\t\tfor(int x=v; x!=lca; x = bel[pa[y]]){\n\t\t\tflower[b].push_back(x);\n\t\t\tflower[b].push_back(y = bel[match[x]]);\n\t\t\tq_push(y);\n\t\t}\n\t\tset_st(b, b);\n    rep(x, 2*n) {\n      g[b][x] = g[x][b]= edge();\n    }\n    rep(x, n) {\n      flower_from[b][x] = -1;\n    }\n    for (int xs : flower[b]) {\n      rep(x, 2*n) {\n\t\t\t\tif (g[b][x].u == -1 || e_delta(g[xs][x]) < e_delta(g[b][x])) {\n          g[b][x] = g[xs][x];\n          g[x][b] = g[x][xs];\n        }\n\t\t\t}\n      rep(x, n) if(flower_from[xs][x] != -1) flower_from[b][x] = xs;\n\t\t}\n\t\tset_slackpa(b);\n\t}\n\tvoid expand_blossom(int b) { //tp[b] == 1\n    for (int v : flower[b]) set_st(v, v);\n\t\tint xr = flower_from[b][g[b][pa[b]].u];\n\t\tint pr = get_pr(b, xr);\n\t\tfor (int i=0; i<pr; i+=2) {\n\t\t\tint xs = flower[b][i];\n\t\t\tint xns = flower[b][i+1];\n\t\t\tpa[xs] = g[xns][xs].u;\n\t\t\ttp[xs] = 1;\n\t\t\ttp[xns] = 0;\n\t\t\tslackpa[xs] = -1;\n\t\t\tset_slackpa(xns);\n\t\t\tq_push(xns);\n\t\t}\n\t\ttp[xr] = 1;\n\t\tpa[xr] = pa[b];\n\t\tfor (int i=pr+1; i<flower[b].size(); i++) {\n\t\t\tint xs = flower[b][i];\n\t\t\ttp[xs] = -1;\n\t\t\tset_slackpa(xs);\n\t\t}\n\t\tbel[b] = -1;\n\t\tmatch[b] = -1;\n\t\tflower[b].clear();\n\t}\n\tbool found_edge(const edge& e) {\n\t\tint u = bel[e.u];\n\t\tint v = bel[e.v];\n\t\tif (tp[v]==-1) {\n\t\t\ttp[v] = 1;\n\t\t\tpa[v] = e.u;\n\t\t\tint nu = bel[match[v]];\n\t\t\tslackpa[v] = slackpa[nu] = -1;\n\t\t\ttp[nu] = 0;\n\t\t\tq_push(nu);\n\t\t} else if (tp[v]==0) {\n\t\t\tint lca = get_lca(u,v);\n\t\t\tif(lca == -1){\n\t\t\t\taugment(u,v);\n\t\t\t\taugment(v,u);\n\t\t\t\treturn true;\n\t\t\t} else add_blossom(u,lca,v);\n\t\t}\n\t\treturn false;\n\t}\n\tbool matching() {\n\t\ttp.assign(2*n,-1);\n\t\tslackpa.assign(2*n,-1);\n\t\tq = queue<int>();\n    rep(i, 2*n) {\n      if (bel[i] == i && match[i] == -1) {\n\t\t\t  tp[i] = 0;\n\t\t\t  pa[i] = -1;\n\t\t\t  q_push(i);\n      }\n\t\t}\n\n\t\tif(q.empty()) return false;\n\n\t\twhile (1) {\n\t\t\twhile (!q.empty()) {\n\t\t\t\tint u = q.front(); q.pop();\n\t\t\t\tif (tp[bel[u]] == 1) continue;\n        rep(v, n) {\n\t\t\t\t\tif (bel[u] != bel[v]) {\n\t\t\t\t\t\tif (e_delta(g[u][v]) == 0) {\n\t\t\t\t\t\t\tif (found_edge(g[u][v])) return true;\n\t\t\t\t\t\t} else update_slackpa(u, bel[v]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint d = inf;\n      reps(b, n, 2*n) {\n        if (bel[b] == b && tp[b] == 1) d = min(d, label[b]/2);\n      }\n      rep(x, 2*n) {\n\t\t\t  if (bel[x] == x && slackpa[x] != -1) {\n\t\t\t\t  if (tp[x] == -1)    d = min(d, e_delta(g[slackpa[x]][x]));\n\t\t\t\t  else if (tp[x] == 0) d = min(d, e_delta(g[slackpa[x]][x])/2);\n        }\n\t\t\t}\n      rep(u, n) {\n\t\t\t\tif (tp[bel[u]] == 0) label[u] -= d;\n\t\t\t\telse if (tp[bel[u]] == 1) label[u] += d;\n\t\t\t}\n      reps(b, n, 2*n) {\n\t\t\t\tif (bel[b] == b) {\n\t\t\t\t\tif (tp[b] == 0) label[b] += d*2;\n\t\t\t\t\telse if (tp[b] == 1) label[b] -= d*2;\n\t\t\t\t}\n\t\t\t}\n      reps(b, n, 2*n) {\n\t\t\t\tif (bel[b] == b && tp[b]==1 && label[b]==0) expand_blossom(b);\n      }\n      rep(x, 2*n) {\n\t\t\t\tif (bel[x] == x && slackpa[x] != -1 && bel[slackpa[x]] != x && e_delta(g[slackpa[x]][x]) == 0) {\n\t\t\t\t\tif(found_edge(g[slackpa[x]][x])) return true;\n        }\n      }\n\t\t}\n\t}\n\tvoid init_g(vv<int> &weight){\n\t\tint sz = (int)weight.size();\n\t\tn = sz+sz%2;\n\t\tg.assign(2*n, vector<edge>(2*n, edge()));\n    rep(i, n) {\n      rep(j, n) {\n\t\t\t\tif (i < sz && j < weight[i].size()) g[i][j] = edge(i, j, weight[i][j]);\n\t\t\t\telse g[i][j] = edge(i, j, 0);\n\t\t\t}\n\t\t}\n\t}\n\tLL solve(){\n\t\tlabel.assign(2*n,0);\n\t\tpa.assign(2*n,-1);\n\t\tmatch.assign(2*n,-1);\n\t\tvis.assign(2*n,0);\n\t\tflower.assign(2*n,vector<int>());\n\t\tflower_from.assign(2*n,vector<int>(n,-1));\n\t\tbel.assign(2*n,-1);\n    rep(i, n) {\n      bel[i] = i;\n\t\t  flower_from[i][i] = i;\n    }\n\t\tint w_max = -inf;\n    rep(i, n) {\n      rep(j, n) {\n\t\t\t\tif (i == j) continue;\n\t\t\t\tw_max = max(w_max, g[i][j].w);\n\t\t\t}\n\t\t}\n    rep(i, n) label[i] = w_max;\n\t\twhile (matching());\n\t\tLL re = 0LL;\n    rep(i, n) {\n\t\t\tassert(match[i] != -1);\n\t\t\tif (match[i] > i) re += 1LL*g[i][match[i]].w;\n\t\t}\n\t\treturn re;\n\t}\n};\n\nint GetCost(int d) {\n  if (d == 2) return 2;\n  if (!is_composite[d]) return 1;\n  if (d%2 == 0) return 2;\n  return 3;\n}\n\nsigned main(){\n  is_composite[1] = true;\n  reps(i, 2, 11451419) {\n    if (is_composite[i]) continue;\n    for (int j=i+i; j<11451419; j+=i) {\n      is_composite[j] = true;\n    }\n  }\n\n  ios_base::sync_with_stdio(false);\n  cout<<fixed<<setprecision(0);\n\n  cin >> N;\n\n  rep(i, N) {\n    int x;\n    cin >> x;\n    mp[x] ^= 1;\n    mp[x+1] ^= 1;\n  }\n\n  vector<int> vs;\n  for (auto &p : mp) {\n    if (p.Y == 0) continue;\n    vs.eb(p.X);\n  }\n  int m = vs.size();\n  assert(m%2 == 0);\n  vv<int> G(m);\n  rep(i, m) {\n    G[i].resize(m);\n    rep(j, m) {\n      if (i == j) continue;\n      G[i][j] = 10000-GetCost(abs(vs[i]-vs[j]));\n    }\n  }\n  wg match;\n  match.init_g(G);\n  //cout << match.solve() << endl;\n  cout << 10000*(m/2)-match.solve() << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n#define N 205\n#define M 10000002\nbool cf[M+5],vis[M+5];\nint prime[M+5],tot;\nint cy[N],a[N],b[N],cntx,cnty;\nbool vs[N],c[N][N];\nvoid shai()\n{\n\tvis[1]=1;int i,j;\n\tfor(i=1;i<=M;i++){\n\t\tif(!vis[i])prime[++tot]=i;\n\t\tfor(j=1;j<=tot;j++){\n\t\t\tint tmp=i*prime[j];\n\t\t\tif(tmp>M)break;\n\t\t\tvis[tmp]=1;\n\t\t\tif(i%prime[j]==0)break;\n\t\t}\n\t\tif(cf[i]){\n\t\t\tif(i&1)a[++cntx]=i;\n\t\t\telse b[++cnty]=i;\n\t\t}\n\t}\n}\n//pay attention to vs\nbool dfs(int i)\n{\n\tfor(int j=1;j<=cnty;j++){\n\t\tif(c[i][j]){\n\t\t\tvs[j]=1;\n\t\t\tif(!cy[j]||dfs(cy[j])){\n\t\t\t\tcy[j]=i;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nint maxmatch()\n{\n\tmemset(cy,0,sizeof(cy));\n\tint ret=0;\n\tfor(int i=1;i<=cntx;i++){\n\t\tmemset(vs,0,sizeof(vs));\n\t\tif(dfs(i))ret++;\n\t}\n\treturn ret;\n}\nint ab(int x){return x<0?-x:x;}\nint main()\n{\n\tint n,i,j,x,ans;\n\tscanf(\"%d\",&n);\n\tfor(i=1;i<=n;i++){\n\t\tscanf(\"%d\",&x);\n\t\tcf[x]^=1;cf[x+1]^=1;\n\t}\n\tshai();\n\tfor(i=1;i<=cntx;i++)\n\t\tfor(j=i+1;j<=cnty;j++)\n\t\t\tif(!vis[ab(b[j]-a[i])])c[i][j]=1;\n\tans=maxmatch();\n\tcntx-=ans;cnty-=ans;\n\tans+=(cntx/2)*2+(cnty/2)*2;\n\tif(cntx%2==1&&cnty%2==1)ans+=3;\n\tprintf(\"%d\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nbool bo[10000010];\nint n,a[1010],val[1010],cnt,sum[1010],Cnt;\nstruct seg{unsigned int b[7]; int v;}s[100010];\nunsigned int xxj[201][7],nw[7],nww[7],boo[201][630],Boo[630];\n\nbool cmp(seg a,seg b) {return a.v<b.v;}\nint calc(int x) {return (x==0)?0:((x&1)?(bo[x]?3:1):2);}\n\nint main()\n{\n\tbo[1]=1;\n\tfor (int i=2; i<=10000000; i++) if (!bo[i])\n\t\tfor (int j=(i<<1); j<=10000000; j+=i) bo[j]=1;\n\tscanf(\"%d\",&n),cnt=0;\n\tfor (int i=1; i<=n; i++) scanf(\"%d\",&a[i]);\n\tfor (int i=1; i<n; i++) \n\t{\n\t\tval[++cnt]=1,nww[cnt>>5]|=(1u<<(cnt&31));\n\t\tif (a[i+1]!=a[i]+1) val[++cnt]=a[i+1]-a[i]-1;\n\t}\n\tval[++cnt]=1,nww[cnt>>5]|=(1u<<(cnt&31));\n\tsum[0]=Cnt=0;\n\tfor (int i=1; i<=cnt; i++) sum[i]=sum[i-1]+val[i];\n\tfor (int i=1; i<=cnt; i++)\n\t\tfor (int j=i; j<=cnt; j++)\n\t\t{\n\t\t\tCnt++;\n\t\t\tfor (int k=i; k<=j; k++) s[Cnt].b[k>>5]|=(1u<<(k&31));\n\t\t\ts[Cnt].v=calc(sum[j]-sum[i-1]);\n\t\t}\n\tsort(s+1,s+1+Cnt,cmp);\n\tmemset(xxj,0,sizeof(xxj));\n\tfor (int i=1,po; i<=Cnt; i++)\n\t{\n\t\tbool bo=0;\n\t\tfor (int j=0; j<=6; j++) nw[j]=s[i].b[j];\n\t\tfor (int j=1; j<=cnt; j++)\n\t\t\tif (s[i].b[j>>5]>>(j&31)&1)\n\t\t\t{\n\t\t\t\tif (!(xxj[j][j>>5]>>(j&31)&1))\n\t\t\t\t{\n\t\t\t\t\tbo=1,po=j;\n\t\t\t\t\tfor (int k=0; k<=6; k++) xxj[j][k]=s[i].b[k];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tfor (int k=0; k<=6; k++) s[i].b[k]^=xxj[j][k];\n\t\t\t}\n\t\tif (bo)\n\t\t{\n\t\t\tfor (int j=0; j<630; j++) Boo[j]=0;\n\t\t\tBoo[i>>5]|=(1u<<(i&31));\n\t\t\tfor (int j=1; j<=cnt; j++)\n\t\t\t\tif (nw[j>>5]>>(j&31)&1)\n\t\t\t\t{\n\t\t\t\t\tif (po==j) \n\t\t\t\t\t{\n\t\t\t\t\t\tfor (int k=0; k<630; k++) boo[j][k]=Boo[k];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tfor (int k=0; k<=6; k++) nw[k]^=xxj[j][k];\n\t\t\t\t\tfor (int k=0; k<630; k++) Boo[k]^=boo[j][k];\n\t\t\t\t}\n\t\t}\n\t}\n\tfor (int j=0; j<630; j++) Boo[j]=0;\n\tfor (int j=0; j<=6; j++) nw[j]=nww[j];\n\tfor (int j=1; j<=cnt; j++)\n\t\tif (nw[j>>5]>>(j&31)&1)\n\t\t{\n\t\t\tfor (int k=0; k<=6; k++) nw[k]^=xxj[j][k];\n\t\t\tfor (int k=0; k<630; k++) Boo[k]^=boo[j][k];\n\t\t}\n\tint ans=0;\n\tfor (int k=1; k<=Cnt; k++)\n\t\tif (Boo[k>>5]>>(k&31)&1) ans+=s[k].v;\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\ntypedef long long ll;\nint odd,even,Odd[105],Even[105],ma[105];\nint flag[10000010],x[10000010],map[105][105],vis[105];\nint prime[10000010],a[105];\nint dfs(int u)\n{\n\tfor (int v=1;v<=even;v++)\n\t{\n\t\tif (!map[u][v]) continue;\n\t\tif (!vis[v])\n\t\t{\n\t\t\tint t=ma[v];\n\t\t\tma[v]=u;\n\t\t\tvis[v]=1;\n\t\t\tif (t==-1||dfs(t)) return 1;\n\t\t\tma[v]=t;\n\t\t}\n\t}\n\treturn 0;\n}\nint main()\n{\n\tint n,cnt=0;\n\tscanf(\"%d\",&n);\n\tflag[1]=1;\n\tfor (int i=2;i<=10000001;i++)\n\t{\n\t\tif (!flag[i]) prime[++cnt]=i;\n\t\tfor (int j=1;j<=cnt;j++)\n\t\t{\n\t\t\tif (i*prime[j]>10000001) break;\n\t\t\tflag[i*prime[j]]=1;\n\t\t\tif (i%prime[j]==0) break;\n\t\t}\n\t}\n\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%d\",&a[i]);\n\t\tx[a[i]]^=1;\n\t}\n\tfor (int i=1;i<=10000001;i++)\n\t\tif (x[i]!=x[i-1])\n\t\t{\n\t\t\tif (i&1) Odd[++odd]=i;\n\t\t\telse Even[++even]=i; \n\t\t}\n\tfor (int i=1;i<=odd;i++)\n\t\tfor (int j=1;j<=even;j++)\n\t\t\tif (flag[abs(Odd[i]-Even[j])]) map[i][j]=1;\n\tmemset(ma,-1,sizeof(ma));\n\tint sum=0;\n\tfor (int i=1;i<=odd;i++)\n\t{\n\t\tmemset(vis,0,sizeof(vis));\n\t\tif (dfs(i)) sum++;\n\t}\n\tll ans=sum+(((odd-sum)>>1)<<1)+(((even-sum)>>1)<<1)+(odd-sum)%2*3;\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pp;\ntypedef pair<ll,ll> pll;\nvoid read(int& x){ scanf(\"%d\",&x); }\nvoid read(ll& x){ scanf(\"%lld\",&x); }\ntemplate<typename T,typename... Args>\nvoid read(T& a,Args&... b){ read(a); read(b...); }\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define eb emplace_back\n#define x first\n#define y second\n\nint n;\nint p[210];\n\nvoid in(){\n\tint t; read(t);\n\tint last;\n\tread(last);\n\tp[++n] = last;\n\tfor(;--t;){\n\t\tint x; read(x);\n\t\tif(last+1 < x){\n\t\t\tp[++n] = last+1;\n\t\t\tp[++n] = x;\n\t\t}\n\t\tlast = x;\n\t}\n\tp[++n] = last+1;\n}\n\nbool is_prime(int x){\n\tif(x==1) return 0;\n\tif(x==2) return 0;\n\tfor(int i=2; i*i<=x; ++i) if(x%i==0) return 0;\n\treturn 1;\n}\nvector<int>edge[210];\nint vis[210];\nint rev[210];\n\nbool dfs(int x){\n\tif(vis[x]) return 0;\n\tvis[x]=1;\n\tfor(int y:edge[x]){\n\t\tif(!rev[y] || dfs(rev[y])){\n\t\t\trev[y]=x;\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nbool aug(){\n\tfor(int i=1; i<=n; ++i){\n\t\tfill(vis+1, vis+n+1, 0);\n\t\tif(dfs(i)) return 1;\n\t}\n\treturn 0;\n}\n\nint main()\n{\n\tin();\n\tint oc=0, ec=0;\n\tfor(int i=1; i<=n; ++i){\n\t\t((p[i]%2)?oc:ec)++;\n\t\tfor(int j=i+1; j<=n; ++j){\n\t\t\tif(is_prime(p[j]-p[i])){\n\t\t\t\tint a=i, b=j;\n\t\t\t\tif(p[a]%2) swap(a, b);\n\t\t\t\tedge[a].pb(b);\n\t\t\t}\n\t\t}\n\t}\n\tint mm = 0;\n\twhile(aug()) ++mm;\n\tint ans = 2e9;\n\tfor(int pu=0; pu<=mm; ++pu){\n\t\tint cur = 0;\n\t\tcur += (oc-pu)/2*2;\n\t\tcur += (ec-pu)/2*2;\n\t\tcur += ((oc-pu)%2)*((ec-pu)%2)*3;\n\t\tcur += pu;\n\t\tans = min(ans, cur);\n\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<map>\n#include<vector>\nusing namespace std;\n#define INF (1 << 29)\nbool prime(int x){\n  if(x == 1)return false;\n  for(int i = 2;i * i <= x;i++){\n    if(x % i == 0)return false;\n  }\n  return true;\n}\n\nint edge[300][300];\n\nint n, x;\nmap<int, int> cnt;\nvector<int> odd, even;\n\nvoid add_edge(int u, int v, int f){\n  edge[u][v] = f;\n}\n\n\nbool come[300];\nint flow(int s, int t){\n  if(come[s])return 0;\n  come[s] = true;\n  if(s == t)return 1;\n  for(int i = 0;i < 300;i++){\n    if(edge[s][i] == 0)continue;\n    if(flow(i, t)){\n      edge[s][i]--;\n      edge[i][s]++;\n      return 1;\n    }\n  }\n  return 0;\n}\n\nint max_flow(int s, int t){\n  int res = 0;\n  while(flow(s, t)){\n    res++;\n    for(int i = 0;i < 300;i++)come[i] = false;\n  }\n  return res;\n}\n\n\nint main(){\n  cin >> n;\n  for(int i = 0;i < n;i++){\n    cin >> x;\n    cnt[x]^=1;\n    cnt[x-1]^=1;\n  }\n  map<int, int>::iterator it;\n  for(it = cnt.begin();it != cnt.end();it++){\n    if(it->second == 0)continue;\n    x = it->first;\n    if(x % 2 == 0)even.push_back(x);\n    if(x % 2 == 1)odd.push_back(x);\n  }\n  int s = even.size() + odd.size() + 1;\n  int t = s + 1;\n  for(int i = 0;i < even.size();i++)add_edge(s, i, 1);\n  for(int i = 0;i < odd.size();i++)add_edge(even.size() + i, t, 1);\n  \n  for(int i = 0;i < even.size();i++){\n    for(int j = 0;j < odd.size();j++){\n      int dif = abs(even[i] - odd[j]);\n      if(prime(dif))add_edge(i, even.size() + j, 1);\n    }\n  }\n\n  int mxf = max_flow(s, t);\n  cout << mxf + (even.size() - mxf) / 2 * 2 + (odd.size() - mxf) / 2 * 2 + (even.size() - mxf) % 2 * 3 << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef double db;\ntypedef long long ll;\n#define w1 first\n#define w2 second\n#define ls (x<<1)\n#define rs (x<<1|1)\n#define pb push_back\n#define mid ((l+r)>>1)\n#define SZ(x) ((x).size())\n#define All(x) (x).begin(),(x).end()\n#define rep(i,a,b) for(int (i)=(a);(i)<=(b);(i)++)\n#define rep2(i,a,b) for(int (i)=(a);(i)<(b);(i)++)\n#define per(i,a,b) for(int (i)=(a);(i)>=(b);(i)--)\n#define Rep(p,x) for(int (p)=head[(x)];(p);(p)=nxt[(p)])\n#define Rep2(p,x) for(int (p)=cur[(x)];(p);(p)=nxt[(p)])\ntemplate<class T>void read(T&num){\n\tnum=0;T f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9')num=num*10+ch-'0',ch=getchar();\n\tnum*=f;\n}\nint power(int x,int k,int p){int res=1;for(;k;k>>=1,x=1ll*x*x%p)if(k&1)res=1ll*res*x%p;return res;}\nconst int lim=1e7,maxn=1e7+5;\nint n;\nint x[maxn],p[maxn],vis[maxn];\nvector<int>a[2];\nnamespace Network{\n\tconst int maxn=1e3+5,maxm=1e6+5,inf=1e9;\n\tint S,T,tot;\n\tint head[maxn],from[maxm],des[maxm],nxt[maxm],f[maxm];\n\tint cur[maxn],h[maxn],pre[maxn],d[maxn];\n\tvoid init(int _S,int _T){\n\t\tmemset(head,0,sizeof head);tot=1;\n\t\tS=_S;T=_T;\n\t}\n\tvoid adde(int x,int y,int z){\n\t\tfrom[++tot]=x;des[tot]=y;f[tot]=z;nxt[tot]=head[x];head[x]=tot;\n\t\tfrom[++tot]=y;des[tot]=x;f[tot]=0;nxt[tot]=head[y];head[y]=tot;\n\t}\n\tint isap(int n){\n\t\tint u=S,maxflow=0;\n\t\trep(i,1,n)cur[i]=head[i],d[i]=pre[i]=0;\n\t\th[0]=n;\n\t\twhile(d[S]<n){\n\t\t\tif(u==T){\n\t\t\t\tint re=S,minflow=inf;\n\t\t\t\tfor(;u!=S;u=from[pre[u]])if(f[pre[u]]<minflow)minflow=f[pre[u]],re=from[pre[u]];\n\t\t\t\tu=T;maxflow+=minflow;\n\t\t\t\tfor(u=T;u!=S;u=from[pre[u]])f[pre[u]]-=minflow,f[pre[u]^1]+=minflow;\n\t\t\t\tu=re;\n\t\t\t}\n\t\t\tint flag=0;\n\t\t\tRep2(p,u){\n\t\t\t\tif(f[p]&&d[des[p]]==d[u]-1){\n\t\t\t\t\tflag=1;u=des[p];pre[u]=p;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcur[u]=p;\n\t\t\t}\n\t\t\tif(flag)continue;\n\t\t\tcur[u]=head[u];int mind=n;\n\t\t\tRep2(p,u)if(f[p]&&d[des[p]]<mind)mind=d[des[p]],cur[u]=p;\n\t\t\th[d[u]]--;if(!h[d[u]])break;\n\t\t\td[u]=mind+1;h[d[u]]++;\n\t\t\tif(u!=S)u=from[pre[u]];\n\t\t}\n\t\treturn maxflow;\n\t}\n}\nint main(){\n\tint tot=0;\n\tvis[1]=1;\n\trep(i,2,lim){\n\t\tif(!vis[i])p[++tot]=i;\n\t\trep(j,1,tot){\n\t\t\tif(p[j]*i>lim)break;\n\t\t\tvis[p[j]*i]=1;\n\t\t\tif(i%p[j]==0)break;\n\t\t}\n\t}\n\tx[0]=-1;\n\tread(n);\n\trep(i,1,n){\n\t\tread(x[i]);\n\t\tif(x[i]!=x[i-1]+1){\n\t\t\ta[x[i]&1].pb(x[i]);\n\t\t\tif(i>1)a[(x[i-1]+1)&1].pb(x[i-1]+1);\n\t\t}\n\t\tif(i==n)a[(x[i]+1)&1].pb(x[i]+1);\n\t}\n//\trep2(i,0,SZ(a[0]))cerr<<a[0][i]<<\" \";cerr<<endl;\n//\trep2(i,0,SZ(a[1]))cerr<<a[1][i]<<\" \";cerr<<endl;\n\tint n1=SZ(a[0]),n2=SZ(a[1]),S=n1+n2+1,T=n1+n2+2;\n\tNetwork::init(S,T);\n\trep2(i,0,n1)rep2(j,0,n2)if(!vis[abs(a[0][i]-a[1][j])])Network::adde(i+1,j+1+n1,1);\n\trep2(i,0,n1)Network::adde(S,i+1,1);\n\trep2(i,0,n2)Network::adde(i+1+SZ(a[0]),T,1);\n\tint cnt=Network::isap(T);n1-=cnt,n2-=cnt;\n\tint ans=cnt;\n\tif(n1&1)ans+=3,n1--,n2--;\n\tans+=n1+n2;\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 1e4 + 5;\nconst int E = 1e7 + 10;\n#define st first\n#define nd second\n#define make(a,b) make_pair(a,b)\n\ntypedef pair<int,int> pun;\ntypedef long long ll;\n\nvector<int> G[N];\nbool vis[N];\nint mate[N];\nbool sko[N];\nbool not_prime[E];\n\nvoid eratos() {\n\tfor (int i = 2; i < E; i ++) {\n\t\tif (not not_prime[i]) {\n\t\t\tfor (int j = 2 * i; j < E; j += i) {\n\t\t\t\tnot_prime[j] = true;\n\t\t\t}\n\t\t}\n\t}\n}\n\nbool dfs(int x) {\n\tif (vis[x]) return false;\n\tvis[x] = true;\n\tfor (int y: G[x]) {\n\t\tif (mate[y] == 0 || dfs(mate[y])) {\n\t\t\tmate[y] = x;\n\t\t\tsko[x] = true;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint main() {\n\tint n;\n\tscanf(\"%d\", &n);\n\teratos();\n\t\n\tvector<int> data;\n\tfor (int i = 0; i < n; i ++) {\n\t\tint a;\n\t\tscanf(\"%d\", &a);\n\t\tdata.push_back(a);\n\t}\n\tsort(data.begin(), data.end());\n\tint last = -1;\n\tvector<int> tokens;\n\tfor (int d: data) {\n\t\tif (last < d) {\n\t\t\tif (last != -1) {\n\t\t\t\ttokens.push_back(last);\n\t\t\t}\n\t\t\ttokens.push_back(d);\n\t\t}\n\t\tlast = d + 1;\n\t}\n\ttokens.push_back(last);\n\tvector<int> nodes[2];\n\tfor (int t: tokens) {\n\t\tnodes[t % 2].push_back(t);\n\t}\n\tfor (int i = 0; i < tokens.size(); i ++) {\n// \t\tprintf(\"%d \", tokens[i]);\n\t}\n// \tprintf(\"tokens \\n\");\n\tnot_prime[2] = true;\n\tnot_prime[1] = true;\n\tfor (int i = 0; i < nodes[0].size(); i ++) {\n\t\tfor (int j = 0; j < nodes[1].size(); j ++) {\n\t\t\tif (not not_prime[abs(nodes[0][i] - nodes[1][j])]) {\n\t\t\t\tG[i+1].push_back(j+1);\n\t\t\t}\n\t\t}\n\t}\n\tbool still = true;\n\tint wynik = 0;\n\twhile(still) {\n\t\tstill = false;\n\t\tfor (int i = 0; i <= nodes[0].size(); i ++) {\n\t\t\tvis[i] = false;\n\t\t}\n\t\tfor (int i = 1; i <= nodes[0].size(); i ++) {\n\t\t\tif (sko[i]) continue;\n\t\t\tif (dfs(i)) {\n\t\t\t\twynik ++;\n\t\t\t\tstill = true;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\", wynik + 2 * ((tokens.size() - 2 * wynik) / 2) + (nodes[0].size() - wynik) % 2);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cctype>\n#include<cstring>\n#include<iostream>\n#include<vector>\n#include<bitset>\n#include<ctime>\n#include<cmath>\n#include<queue>\n\nusing namespace std;\n\n#define bomb exit(1)\n#define INF 1061109567\n#define LINF 4557430888798830399ll\n#define pprint(x) print(x),putchar(' ')\n#define fprint(x) print(x),putchar('\\n')\n#define EE(x); struct edge { int nxt,to,w; }e[M << 1]; int head[N],ecnt = 1;\\\n\tvoid add(int u,int v,ll w = 0) { e[++ecnt].w = w,e[ecnt].to = v,e[ecnt].nxt = head[u];head[u] = ecnt; }\\\n\tvoid add_edge(int u,int v,ll w = 0) { add(u,v,w),add(v,u,w * x); }\n#define ll long long\nconst double pi = acos(-1);\nint mod = 1000000007;\nll Mod(ll x) { return x >= mod ? x - mod : x; }\n#define eps 0.0000000001\n#define sqr(x) ((x) * (x))\n#define iter iterator\n#define fi first\n#define se second\n//#define getchar() (SS == TT && (TT = (SS = BB) + fread(BB,1,1 << 15,stdin),TT == SS) ? EOF : *SS++)\n//char BB[1 << 15],*SS = BB,*TT = BB;\nll read()\n{\n\tll x = 0;int f = 1;char ch = getchar();\n\tfor(;!isdigit(ch);ch = getchar()) if(ch == '-') f = -1;\n\tfor(;isdigit(ch);ch = getchar()) x = x * 10 + (ch ^ 48);\n\treturn x * f;\n}\nvoid print(ll x)\n{\n\tif(x < 0) putchar('-'),x = -x;\n\tif(x > 9) print(x / 10);putchar(x % 10 + '0');\n}\n\nconst int N = 110;\n\nstruct MAX_FLOW\n{\n\tstatic const int N = 210,M = N * N;\n\tEE(0);\n\tint S,T;\n\tqueue<int> q;int dis[N],cur[N];\n\tbool BFS()\n\t{\n\t\tmemset(dis,-1,sizeof(dis));\n\t\tq.push(S),dis[S] = 0;\n\t\twhile(!q.empty())\n\t\t{\n\t\t\tint u = q.front();q.pop();\n\t\t\tfor(int i = cur[u] = head[u];i;i = e[i].nxt)\n\t\t\t{\n\t\t\t\tint v = e[i].to;\n\t\t\t\tif(!~dis[v] && e[i].w) q.push(v),dis[v] = dis[u] + 1;\n\t\t\t}\n\t\t}return ~dis[T];\n\t}\n\tint DFS(int u,int exp)\n\t{\n\t\tif(u == T) return exp;\n\t\tint flow = 0,f;\n\t\tfor(int &i = cur[u];i;i = e[i].nxt)\n\t\t{\n\t\t\tint v = e[i].to;\n\t\t\tif(e[i].w && dis[v] == dis[u] + 1)\n\t\t\t{\n\t\t\t\tf = DFS(v,min(exp,e[i].w));\n\t\t\t\texp -= f,flow += f;\n\t\t\t\te[i].w -= f,e[i ^ 1].w += f;\n\t\t\t\tif(!exp) break;\n\t\t\t}\n\t\t}return flow;\n\t}\n\tint Dinic()\n\t{\n\t\tint maxflow = 0,f;\n\t\twhile(BFS()) while(f = DFS(S,INF)) maxflow += f;\n\t\treturn maxflow;\n\t}\n}G;\n\nint prime[1000010],tot;\nbool vis[10000010];\nvoid init(int n)\n{\n\tvis[0] = vis[1] = 1;\n\tfor(int i = 2;i <= n;i++)\n\t{\n\t\tif(!vis[i]) prime[++tot] = i;\n\t\tfor(int j = 1;j <= tot && i * prime[j] <= n;j++)\n\t\t{\n\t\t\tvis[i * prime[j]] = 1;\n\t\t\tif(i % prime[j] == 0) break;\n\t\t}\n\t}\n}\n\nint n,a[N];\nint L[N << 1],R[N << 1],cntl,cntr;\nvoid push(int x) { if(x & 1) L[++cntl] = x;else R[++cntr] = x; }\nint main()\n{\n\tinit(10000000);\n\tn = read();for(int i = 1;i <= n;i++) a[i] = read();sort(a + 1,a + 1 + n);\n\tfor(int i = 1;i <= n;i++)\n\t{\n\t\tif(a[i - 1] + 1 != a[i] || i == 1) push(a[i]);\n\t\tif(a[i + 1] - 1 != a[i]) push(a[i] + 1);\n\t}\n\tG.S = 0,G.T = cntl + cntr + 1;\n\tfor(int i = 1;i <= cntl;i++) G.add_edge(G.S,i,1);\n\tfor(int i = 1;i <= cntr;i++) G.add_edge(i + cntl,G.T,1);\n\tfor(int i = 1;i <= cntl;i++) for(int j = 1;j <= cntr;j++)\n\t\tif(!vis[abs(L[i] - R[j])]) G.add_edge(i,j + cntl,1);\n\tint maxflow = G.Dinic();\n\tint ans = maxflow;\n\tans += (cntl - maxflow) / 2 * 2 + (cntr - maxflow) / 2 * 2;\n\tans += ((cntl - maxflow) & 1) * 3;\n\tfprint(ans);\n}"
  },
  {
    "language": "C++",
    "code": "///////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////\n//                       _oo0oo_                         //\n//                      o8888888o                        //\n//                      88\" . \"88      ------ hzt1       //\n//                      (| -_- |)                        //\n//                      0\\  =  /0                        //\n//                    ___/`---'\\___                      //\n//                  .' \\|     |// '.                     //\n//                 / \\|||  :  |||// \\                    //\n//                / _||||| -:- |||||- \\                  //\n//               |   | \\  -  /// |     |                 //\n//               | \\_|  ''\\---/''  |_/ |                 //\n//               \\  .-\\__  '-'  ___/-. /                 //\n//             ___'. .'  /--.--\\  `. .'___               //\n//          .\"\" '<  `.___\\_<|>_/___.' >' \"\".             //\n//         | | :  `- \\`.;`\\ _ /`;.`/ - ` : | |           //\n//         \\  \\ `_.   \\_ __\\ /__ _/   .-` /  /           //\n//     =====`-.____`.___ \\_____/___.-`___.-'=====        //\n//                       `=---='                         //\n//                                                       //\n//                                                       //\n//     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~       //\n//                                                       //\n//                 God-He Bless All.                     //\n//           This Code Will Never Explode.               //\n//                                                       //\n//                                                       //\n///////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////\n#include<cstdio>\n#include<cstring>\n#include<cctype>\n#include<algorithm>\n#include<vector>\n#define pb push_back\n#define mp make_pair\n#define xx first\n#define yy second\n#define rep(i,a,b) for(int i=(a),i##_end_=(b);i<=i##_end_;i++)\n#define dwn(i,a,b) for(int i=(a),i##_end_=(b);i>=i##_end_;i--)\nusing namespace std;\nconst int Size=1<<16;\nchar buffer[Size],*head,*tail;\ninline char Getchar() {\n    if(head==tail) {\n        int l=fread(buffer,1,Size,stdin);\n        tail=(head=buffer)+l;\n    }\n    if(head==tail) return -1;\n    return *head++;\n}\ninline int read() {\n    int x=0,f=1;char c=getchar();\n    for(;!isdigit(c);c=getchar()) if(c=='-') f=-1;\n    for(;isdigit(c);c=getchar()) x=x*10+c-'0';\n    return x*f;\n}\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int maxn=210;\nconst int maxm=10000010;\nint A[maxn],e[maxn][maxn],cnt;\nint pri[maxm/10],vis[maxm],tot;\nvoid init(int n) {\n\tvis[1]=1;\n\trep(i,2,n) {\n\t\tif(!vis[i]) pri[++tot]=i;\n\t\trep(j,1,tot) {\n\t\t\tif(i*pri[j]>n) break;\n\t\t\tvis[i*pri[j]]=1;\n\t\t\tif(i%pri[j]==0) break;\n\t\t}\n\t}\n}\nint left[maxn],T[maxn];\nint match(int x) {\n\trep(v,1,cnt) if(e[x][v]) {\n\t\tif(T[v]) continue;T[v]=1;\n\t\tif(!left[v]||match(left[v])) {left[v]=x;return 1;}\n\t} \n\treturn 0;\n}\nint main() {\n\tinit(10000000);\n\tint n=read();\n\trep(i,1,n) {\n\t\tint x=read();\n\t\tA[i]=x;\n\t\tA[i+n]=x+1;\n\t}\n\tsort(A+1,A+2*n+1);\n\trep(i,1,n*2) if(A[i]!=A[cnt]) A[++cnt]=A[i];else cnt--;\n\tint c1=0,c2=0;\n\trep(i,1,cnt) if(A[i]&1) {\n\t\tc1++;\n\t\trep(j,1,cnt) if(!(A[j]&1)) {\n\t\t\te[i][j]=!vis[abs(A[i]-A[j])];\n\t\t}\n\t}\n\tc2=cnt-c1;\n\tint ans=0;\n\trep(i,1,cnt) if(A[i]&1) {\n\t\tmemset(T,0,sizeof(T));\n\t\tif(match(i)) ans++;\n\t}\n\tc1-=ans;c2-=ans;\n\tans+=(c1/2)*2+(c2/2)*2;\n\tif(c1&1) ans+=3;\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n/*\n7\n1 2 3 4 5 6 7\n*/"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=5e3+11;\nconst int M=7e5+11;\nconst int MAXN=1e7+11;\nconst int inf=2147483647;\nint n,tot,cnt,t1,t2,mx,S,T,hd[M];\nint ans,pri[M],L[N<<1],R[N<<1];\nbitset<MAXN> is,a;\nstruct Edge{int nxt,to,val;}e[M];\nvoid ins(int x,int y,int z){\n    e[++cnt].nxt=hd[x];\n    e[cnt].to=y;hd[x]=cnt;\n    e[cnt].val=z;\n}\nvoid prepare(){\n    is[0]=is[1]=1;\n    for(int i=2;i<MAXN;i++){\n        if(!is[i]) pri[++tot]=i;\n        for(int j=1;j<=tot&&i*pri[j]<=MAXN;j++){\n            is[pri[j]*i]=1;\n            if(i%pri[j]==0) break;\n        }\n    }\n}\nnamespace Network_Flow{\n    queue<int> p;\n    int dep[N<<1];\n    int bfs(){\n        memset(dep,0,sizeof(dep));\n        p.push(S);dep[S]=1;\n        while(!p.empty()){\n            int x=p.front();p.pop();\n            for(int i=hd[x];i;i=e[i].nxt){\n                int y=e[i].to,v=e[i].val;\n                if(!dep[y]&&v){\n\t\t\t\t\tdep[y]=dep[x]+1;\n                    p.push(y);\n                }\n            }\n        }\n        if(dep[T]) return 1;\n        return 0;\n    }\n    int dfs(int x,int flow){\n        if(x==T||flow<=0) return flow;\n        int rest=0;\n        for(int i=hd[x];i;i=e[i].nxt){\n            int j=e[i].to;int v=e[i].val;\n            if(dep[j]==dep[x]+1&&v){\n                int now=dfs(j,min(v,flow));\n                e[i].val-=now;\n                e[i^1].val+=now;\n                flow-=now;rest+=now;\n                if(flow<=0) break;\n            }\n        }if(!rest) dep[x]=-1;\n        return rest;\n    }\n    int dinic(){\n        int maxflow=0;\n        while(bfs()) maxflow+=dfs(S,inf);\n\t\treturn maxflow;\n    }\n}\nint read(){\n    int x=0,f=1;char ch=getchar();\n    while(!isdigit(ch)){if(ch=='-')f=-f;ch=getchar();}\n    while(isdigit(ch)){x=x*10+ch-48;ch=getchar();}\n    return x*f;\n}\nsigned main(){\n    prepare();n=read();\n    for(int i=1;i<=n;i++){\n        int x=read();\n        a[x]=1,mx=max(mx,x);\n    }\n    for(int i=1;i<=mx+1;i++)\n        if(a[i]!=a[i-1]) i&1?L[++t1]=i:R[++t2]=i;\n    S=0,T=t1+t2+1;\n    for(int i=1;i<=t1;i++)\n        ins(S,i,1),ins(i,S,0);\n    for(int i=1;i<=t2;i++)\n        ins(i+t1,T,1),ins(T,i+t1,0);\n    for(int i=1;i<=t1;i++)\n        for(int j=1;j<=t2;j++)\n            if(!is[abs(L[i]-R[j])])\n                ins(i,j+t1,1),ins(j+t1,i,0);\n    int Val=Network_Flow::dinic();\n    ans+=Val;ans+=(t1-Val)/2*2+(t2-Val)/2*2;\n    ans+=((t1-Val)&1)*3;printf(\"%d\\n\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<algorithm>\n#define LL long long\n#define int LL\n#define MAXN 205\n#define MAXP (MAXN*MAXN)\n#pragma GCC optimize(2)\n#define rg register\nusing namespace std;\ninline int read() {\n\tint f = 1,x = 0;char s = getchar();\n\twhile(s < '0' || s > '9') {if(s == '-') f = -1;s = getchar();}\n\twhile(s >= '0' && s <= '9') {x = x * 10 + s - '0';s = getchar();}\n\treturn x * f;\n}\nstruct it{\n\tint x;\n\tLL s;\n};\nstruct ed{\n\tint v,id;\n\ted(){v = id = 0;}\n\ted(int V,int I){v = V;id = I;} \n};\nbool operator < (it a,it b) {\n\treturn a.s < b.s;\n}\n//int dx[4] = {1,-1,0,0};\n//int dy[4] = {0,0,1,-1};\nvector<ed> g[MAXP];\nint w[MAXP*8];\nbool f[MAXP];\nint d[MAXP];\nint po[MAXN][MAXN];\nint n,m,q,i,j,s,o,k,t,cnt,cn;\nqueue<it> b;\nint fan(int x) {\n\tif(x > MAXP*4) return x - MAXP*4;\n\treturn x + MAXP*4;\n}\nint adde(int x,int y,int wi,int wj) {\n\tg[x].push_back(ed(y,++cnt));\n\tw[cnt] = wi;\n\tg[y].push_back(ed(x,fan(cnt)));\n\tw[fan(cnt)] = wj;\n\treturn cnt;\n}\nqueue<int> qq;\nbool init_bfs() {\n\twhile(!qq.empty()) qq.pop();\n\tmemset(f,0,sizeof(f));\n\tmemset(d,0,sizeof(d));\n\tqq.push(s);\n\tf[s] = 1;\n\td[s] = 1;\n\twhile(!qq.empty()) {\n\t\tint t1 = qq.front();\n\t\tqq.pop();\n//\t\tprintf(\"x:%d s:%lf\\n\",t1.x,t1.s);\n\t\tif(t1 == t) {\n\t\t\treturn 1;\n\t\t}\n\t\tfor(rg int i = 0;i < g[t1].size();i ++) {\n\t\t\tint y = g[t1][i].v,id = g[t1][i].id;\n\t\t\tif(!f[y] && w[id] > 0) {\n\t\t\t\tf[y] = 1;\n\t\t\t\td[y] = d[t1] + 1;\n\t\t\t\tqq.push(y);\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nLL dfs(int x,int minn) {\n\tif(!f[x]) return 0;\n\tif(x == t || minn == 0) return minn;\n\tint ans = 0;\n\tf[x] = 0;\n\tfor(rg int i = 0;i < g[x].size();i ++) {\n\t\tint y = g[x][i].v,id = g[x][i].id,as;\n\t\tif(d[y] == d[x] + 1 && (as = dfs(y,min(minn,w[id]))) > 0) {\n\t\t\tw[id] -= as;\n\t\t\tw[fan(id)] += as;\n\t\t\tans += as;\n\t\t\tminn -= as;\n\t\t\tif(!minn) break;\n\t\t}\n\t}\n\treturn ans;\n}\nint Dinic() {\n\tint ans = 0;\n\twhile(init_bfs()) {\n//\t\tcout<<\"in--ok\"<<endl;\n\t\tans += dfs(s,0x7f7f7f7f);\n//\t\tcout<<\"out--ok\"<<endl;\n\t}\n\treturn ans;\n}\nint A[105];\nint B[205],cntb;\nint prim[4000005],cp = 0;\nbool f2[10000005];\nvoid sieve(int n) {\n\tf2[1] = 1;\n\tfor(int i = 2;i <= n;i ++) {\n\t\tif(!f2[i]) prim[++cp] = i;\n\t\tfor(int j = 1;j <= cp && i * prim[j] <= n;j ++) {\n\t\t\tf2[i * prim[j]] = 1;\n\t\t\tif(i % prim[j] == 0) break;\n\t\t}\n\t}return ;\n}\nint pted[205];\nsigned main() {\n\tn = read(); A[0] = -1; cntb = 0;cnt = 0;\n\tfor(int i = 1;i <= n;i ++) {\n\t\tA[i] = read();\n\t\tif(A[i-1] < A[i] - 1 && i-1) B[++cntb] = A[i-1] + 1;\n\t\tif(A[i] > A[i-1] + 1) B[++cntb] = A[i];\n\t}A[n+1] = 0x7f7f7f7f;B[++cntb] = A[n] + 1;\n\tsieve(B[cntb]);\n\ts = cntb + 1; t = cntb + 2;\n\tfor(int i = 1;i <= cntb;i ++) {\n\t\tif(B[i] & 1) pted[i] = adde(s,i,1,0);\n\t\telse pted[i] = adde(i,t,1,0);\n//\t\tcout<<pted[i]<<\" \";\n\t\tfor(int j = i+1;j <= cntb;j ++) {\n\t\t\tif(!f2[B[j] - B[i]] && (B[j] - B[i] & 1)) {\n\t\t\t\tadde(i,j,1,0);\n\t\t\t}\n\t\t}\n\t}\n//\tputchar('\\n');\n\tint ans = Dinic();\n//\tcout<<\"1:\"<<ans<<endl;\n\tint cnt1 = 0,cnt2 = 0;\n\tfor(int i = 1;i <= cntb;i ++) {\n\t\tif(w[pted[i]]) {\n\t\t\tif(B[i] & 1) cnt1 ++;\n\t\t\telse cnt2 ++;\n\t\t}\n\t}\n\tans += ((LL)cnt1 / 2) * 2 + ((LL)cnt2 / 2) * 2;\n//\tcout<<cnt1<<\" \"<<cnt2<<endl;\n//\tcout<<\"2:\"<<ans<<endl;\n\tif((cnt1 & 1) || (cnt2 & 1)) ans += 3;\n//\tcout<<\"3:\"<<ans<<endl;\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\nbool so[10000001];\nint main(){\n  int n,x[100];\n  cin>>n;\n  for(int i=2;i*i<=1e7;i++)\n    if(!so[i])for(int j=2;i*j<=1e7;j++)so[j*i]=1;\n  \n  for(int i=0;i<n;i++)cin>>x[i];\n  \n  int ans=1,y=x[n-1]-x[0]+1;\n  if(so[y]||y==2){\n    if(y%2)ans+=2;\n    else ans++;\n  }\n  \n  for(int i=0;i<n-1;i++){\n    int t=x[i+1]-x[i]-1;\n    if(!t)continue;\n    if(t%2){\n      if(so[t])ans+=3;\n      else ans++;\n    }else ans+=2;\n  }\n  cout<<ans<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#define ri register int\nnamespace io {\n    const int SIZE = (1 << 21) + 1;\n    char ibuf[SIZE], *iS, *iT, obuf[SIZE], *oS = obuf, *oT = oS + SIZE - 1, c, qu[55]; int f, qr;\n    // getchar\n    #define gc() (iS == iT ? (iT = (iS = ibuf) + fread (ibuf, 1, SIZE, stdin), (iS == iT ? EOF : *iS ++)) : *iS ++)\n    // print the remaining part\n    inline void flush () {\n        fwrite (obuf, 1, oS - obuf, stdout);\n        oS = obuf;\n    }\n    // putchar\n    inline void putc (register char x) {\n        *oS ++ = x;\n        if (oS == oT) flush ();\n    }\n    // input a signed integer\n    template <class I>\n    inline void gi (I &x) {\n        for (f = 1, c = gc(); c < '0' || c > '9'; c = gc()) if (c == '-') f = -1;\n        for (x = 0; c <= '9' && c >= '0'; c = gc()) x = (x << 1) + (x << 3) + (c & 15); x *= f;\n    }\n    // print a signed integer\n    template <class I>\n    inline void print (I x) {\n        if (!x) putc ('0'); if (x < 0) putc ('-'), x = -x;\n        while (x) qu[++ qr] = x % 10 + '0',  x /= 10;\n        while (qr) putc (qu[qr --]);\n    }\n    //no need to call flush at the end manually!\n    struct Flusher_ {~Flusher_(){flush();}}io_flusher_;\n}\nusing io :: gi;\nusing io :: putc;\nusing io :: print;\nconst int N=205;\nint a[N],b[N],pos[N],ta,tb,tot,head[N],nxt[N*N],adj[N*N],link[N],vis[N];\ninline void addedge(ri x,ri y){\n\tnxt[++tot]=head[x];\n\tadj[head[x]=tot]=y;\n}\ninline void push(ri x){\n\tif(x&1)\n\t\ta[++ta]=x;\n\telse\n\t\tb[++tb]=x;\n}\ninline bool prime(ri n){ // n是否为级质数 \n\tif(n<=2) return false;\n\tfor(ri i=2;i*i<=n;++i)\n\t\tif(n%i==0) return false;\n\treturn true;\n}\ninline int abs(ri x){\n\treturn x>0 ? x:-x;\n}\ninline int dfs(ri x){\n\tfor(ri y,i=head[x];i;i=nxt[i])\n\t\tif(!vis[y=adj[i]]){\n\t\t\tvis[y]=1;\n\t\t\tif(!link[y]||dfs(link[y])){\n\t\t\t\tlink[y]=x;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\treturn false;\n}\nint main(){\n\tri n,i,j,x,last,ans;\n\tgi(n);\n\tfor(i=1;i<=n;++i){\n\t\tgi(x);\n\t\tif(i==1) push(x);\n\t\telse if(last+1!=x) push(last+1),push(x); \n\t\tlast=x;\n\t}\n\tpush(last+1);\n//\tprintf(\"ta=%d\\n\",ta);\n//\tfor(i=1;i<=ta;++i) printf(\"%d \",a[i]); puts(\"\");\n//\tprintf(\"tb=%d\\n\",tb);\n//\tfor(i=1;i<=tb;++i) printf(\"%d \",b[i]); puts(\"\");\n\t// ta + tb 为偶数 \n\tfor(i=1;i<=ta;++i)\n\t\tfor(j=1;j<=tb;++j)\n\t\t\tif(prime(abs(a[i]-b[j])))\n\t\t\t\taddedge(i,j);\n\tans=0;\n\tfor(i=1;i<=ta;++i){\n\t\tfor(j=1;j<=tb;++j) vis[j]=0;\n\t\tans+=dfs(i);\n\t}\n\tans+=(ta-ans)/2*2+(tb-ans)/2*2+(ta-ans)%2*3;\n\tprintf(\"%d\\n\",ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\nconst int N = 105;\nconst int M = 1e7 + 77;\nint n;\nint x[N];\nbool p[M];\nint nxt[M + 1];\nvoid sieve(){\n\tfor(int i = 2 ; i * i < M ; ++i){\n\t\tif(!p[i]){\n\t\t\tfor(int j = i * i ; j < M ; j += i){\n\t\t\t\tp[j] = 1;\n\t\t\t}\n\t\t}\n\t}\n\tnxt[M] = 0;\n\tfor(int i = M - 1 ; i >= 3 ; --i){\n\t\tif(p[i]){\n\t\t\tnxt[i] = nxt[i + 1];\n\t\t}\n\t\telse{\n\t\t\tnxt[i] = i;\n\t\t}\n\t}\n\tnxt[2] = 3;\n\tnxt[1] = 3;\n\tp[2] = 1;\n\tp[1] = 1;\n\tp[0] = 1;\n}\ninline int cost(int size){\n\tif(size <= 0){\n\t\treturn 0;\n\t}\n\tif(p[size] == 0){\n\t\treturn 1;\n\t}\n\tif(size & 1){\n\t\treturn 3;\n\t}\n\treturn 2;\n}\nint dp[N][1000];\nint solve(int pos , int back){\n\tif(pos > n){\n\t\treturn cost(back);\n\t}\n\tif(dp[pos][back] != -1){\n\t\treturn dp[pos][back];\n\t}\n\tint res = 1e9;\n\tif(back){\n\t\tres = min(res , solve(pos , 0) + cost(back));\n\t\tint extra = cost(x[pos] - 1 - x[pos - 1] - back);\n\t\tfor(int i = pos ; i <= n ; ++i){\n\t\t\tres = min(res , solve(i + 1 , 0) + extra + cost(x[i] - x[pos - 1]));\n\t\t\tint siz = x[i] - x[pos - 1];\n\t\t\tint p = nxt[siz];\n\t\t\tif(x[pos - 1] + 1 + p - 1 < x[i + 1]){\n\t\t\t\tres = min(res , solve(i + 1 , x[pos - 1] + 1 + p - 1 - x[i]) + p + extra + 1);\n\t\t\t}\n\t\t\tif(i < n){\n\t\t\t\textra += cost(x[i + 1] - x[i] - 1);\n\t\t\t}\n\t\t}\n\t}\n\telse{\n\t\tint extra = 0;\n\t\tfor(int i = pos ; i <= n ; ++i){\n\t\t\tres = min(res , solve(i + 1 , 0) + extra + cost(x[i] - x[pos] + 1));\n\t\t\tint siz = x[i] - x[pos] + 1;\n\t\t\tint p = nxt[siz];\n\t\t\tif(x[pos] + p - 1 < x[i + 1]){\n\t\t\t\tres = min(res , solve(i + 1 , x[pos] + p - 1 - x[i]) + p + extra + 1);\n\t\t\t}\n\t\t\tif(i < n){\n\t\t\t\textra += cost(x[i + 1] - x[i] - 1);\n\t\t\t}\n\t\t}\n\t}\n\treturn dp[pos][back] = res;\n}\nint main(){\n\tsieve();\n\tscanf(\"%d\" , &n);\n\tfor(int i = 1 ; i <= n ; ++i){\n\t\tscanf(\"%d\" , x + i);\n\t}\n\tx[n + 1] = 1e8 + 8;\n\tsort(x + 1 , x + 1 + n);\n\tmemset(dp , -1 , sizeof(dp));\n\tprintf(\"%d\\n\" , solve(1 , 0));\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<cstring>\n\nusing namespace std;\nint n;\nconst int maxn = 1e7+5;//40M\nconst int S = 1e7+1;\nint pri[maxn],cnt; bool mk[maxn];\nint A[maxn];\nvoid oula() {\n\tmk[1] = mk[0] = 1;\n\tfor(int i=1;i<=S;i++) {\n\t\tif(!mk[i]) { pri[++cnt]=i; }\n\t\tfor(int j=1;j<=cnt&&1ll*pri[j]*i<=S;j++) {\n\t\t\tint k = pri[j]*i;\n\t\t\tmk[k] = 1;\n\t\t\tif(i%pri[j]==0) break;\n\t\t}\n\t}\n}\nint la[405],en[405*305],owo,nt[405*405];\nvoid adg(int x,int y) {\n\ten[++owo]=y; nt[owo]=la[x]; la[x]=owo;\n}\nint cc[2];\nint yo[2][405];\nint link[405],vis[405],vtm;\nbool hungary(int x,int tm) {\n\tfor(int it=la[x];it;it=nt[it]) {\n\t\tint y = en[it];\n\t\tif(vis[y]==tm) continue;\n\t\tvis[y] = tm;\n\t\tif((!link[y])||(hungary(link[y],tm))) {\n\t\t\tlink[y] = x; return 1;\n\t\t}\n\t}\n\treturn 0;\n}\nint main() {\n\toula();\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++) {\n\t\tint x; scanf(\"%d\",&x); A[x] = 1;\n\t}\n\tfor(int i=1;i<=S;i++) {\n\t\tint cf = A[i-1]^A[i];\n\t\tif(cf) {\n\t\t\t++cc[i&1];\n\t\t\tyo[i&1][cc[i&1]] = i;\n\t\t}\n\t}\n\tfor(int i=1;i<=cc[0];i++) {\n\t\tfor(int j=1;j<=cc[1];j++) {\n\t\t\tif(!mk[abs(yo[0][i]-yo[1][i])]) adg(i,j);\n\t\t}\n\t}\n\tint ans = 0;\n\tfor(int i=1;i<=cc[0];i++) {\n\t\tans += hungary(i,++vtm);\n\t}\n\tcc[0]-=ans; cc[1]-=ans;\n\tprintf(\"%d\",ans+cc[0]/2*2 + cc[1]/2*2 + (cc[0]&1)*3 );\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<cstring>\n#include<algorithm>\n#include<string>\n#include<map>\n#include<set>\n#include<ctime>\n#include<cstdlib>\n#include<queue>\nusing namespace std;\n#define N 806\n#define ll long long\n#define mp make_pair\nll read()\n{\n\tll f=1,x=0;\n\tchar c=getchar();\n\twhile(c>'9'||c<'0')\n\t{\n\t\tif(c=='-') f=-1;\n\t\tc=getchar();\n\t}\n\twhile(c>='0'&&c<='9')\n\t{\n\t\tx=x*10+c-'0';\n\t\tc=getchar();\n\t}\n\treturn f*x;\n}\nint t,n,x[N],st[N],dep[N],top,size,head[N],S,T,pre[10000020],cnt;\nbool isp[10000020];\nstruct ndoe{\n\tint next,to,vlu;\n}mem[N*N*4];\nvoid add(int u,int v,int vlu)\n{\n\tmem[++size].to=v;mem[size].next=head[u];head[u]=size;mem[size].vlu=vlu;\n\tmem[++size].to=u;mem[size].next=head[v];head[v]=size;mem[size].vlu=0;\n}\nvoid init()\n{\n\tint top=1e7;\n\tisp[1]=1;\n\tfor(int i=2;i<=top;++i)\n\t{\n\t\tif(!isp[i]) pre[++cnt]=i;\n\t\tfor(int j=1;j<=cnt&&pre[j]*i<=top;++j)\n\t\t{\n\t\t\tisp[pre[j]*i]=1;\n\t\t\tif(i%pre[j]==0) break;\n\t\t}\n\t}\n}\nqueue<int>q;\nbool bfs(){\n\tmemset(dep,0,sizeof(dep));\n\tdep[S]=1;\n\tq.push(S);\n\twhile(!q.empty())\n\t{\n\t\tint x=q.front();q.pop();\n\t\tfor(int i=head[x];i;i=mem[i].next)\n\t\t{\n\t\t\tint v=mem[i].to;\n\t\t\tif(mem[i].vlu&&!dep[v])\n\t\t\t{\n\t\t\t\tdep[v]=dep[x]+1;\n\t\t\t\tq.push(v);\n\t\t\t}\n\t\t}\n\t}\n\treturn dep[T];\n}\nint dfs(int x,int flow)\n{\n\tif(x==T) return flow;\n\tint now,used=0;\n\tfor(int i=head[x];i;i=mem[i].next)\n\t{\n\t\tint v=mem[i].to;\n\t\tif(mem[i].vlu&&dep[v]==dep[x]+1)\n\t\t{\n\t\t\tnow=dfs(v,min(mem[i].vlu,flow-used));\n\t\t\tused+=now;\n\t\t\tmem[i].vlu-=now;\n\t\t\tmem[i^1].vlu+=now;\n\t\t\tif(used==flow) break;\n\t\t}\n\t}\n\tif(used!=flow) dep[x]=-1;\n\treturn used;\n}\nint main()\n{\n//\tfreopen(\"light3.in\",\"r\",stdin);\n//\tfreopen(\"B.out\",\"w\",stdout);\n\tinit();\n\tt=1;\n\twhile(t--)\n\t{\n\t\ttop=0;\n\t\tsize=1;\n\t\tmemset(head,0,sizeof(head));\n\t\tn=read();\n\t\tfor(int i=1;i<=n;++i) x[i]=read();\n\t\tfor(int i=1;i<=n;++i)\n\t\t{\n\t\t\tst[++top]=x[i]-1;\n\t\t\tint now=x[i],r=i;\n\t\t\twhile(x[r]==now&&r<=n) now++,r++;\n\t\t\ti=r-1;\n\t\t\tst[++top]=x[r-1];\n\t\t}\n\t//\tfor(int i=1;i<=top;++i) cout<<st[i]<<\" \";cout<<'\\n';\n\t\tS=top+1,T=S+1;\n\t\tint s1=0,s2=0;\n\t\tfor(int i=1;i<=top;++i)\n\t\t{\n\t\t\tif(st[i]&1) add(S,i,1),s1++;\n\t\t\telse add(i,T,1),s2++;\n\t\t\tfor(int j=i+1;j<=top;++j) if(st[j]-st[i]!=2&&!isp[st[j]-st[i]])\n\t\t\tif(st[i]&1) add(i,j,1);\n\t\t\telse add(j,i,1);\n\t\t}\n\t\tint k=0;\n\t\t\n\t\twhile(bfs()) k+=dfs(S,1e9);\n\t//\tcout<<\"k\"<<k<<\" \"<<s1<<\" \"<<s2<<'\\n';\n\t\tcout<<k+2*((s1-k)/2+(s2-k)/2)+3*((s1-k)%2)<<'\\n';\n\t}\n\treturn 0;\n}\n/*\n1\n1\n6\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <vector>\n#include <stdio.h>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nconst int N = 256, M = 1e7 + 10;\n\ninline void Read(int &x) {\n\tx = 0; register char cc = '\\0'; int fff = 1;\n\tfor (; cc < '0' || cc > '9'; cc = getchar())\n\t\tif (cc == '-') fff = -1;\n\tfor (; cc >= '0' && cc <= '9'; cc = getchar())\n\t\tx = (x << 1) + (x << 3) + (cc & 15);\n\tx *= fff;\n}\n\nmap<int, int> mp;\nbool vis[N], Pr[M + 10], G[N][N];\nint n, tot, fans, fsum, cnt0, cnt1, p[M], bel[N], a[N], buf0[N], buf1[N];\n\ninline int Abs(int x) {\n\treturn x >= 0 ? x : -x;\n}\n\ninline void Getprime() {\n\tPr[0] = Pr[1] = true;\n\tfor (int i = 2; i <= M; ++i) {\n\t\tif (!Pr[i]) p[++tot] = i;\n\t\tfor (int j = 1; j <= tot && i * p[j] <= M; ++j) {\n\t\t\tPr[i * p[j]] = true/* false */;\n\t\t\tif (i % p[j] == 0) break;\n\t\t}\n\t}\n\tPr[2] = true;\n}\n\nbool Find(int x) {\n\tfor (int j = 1; j <= cnt1; ++j)\n\t\tif (G[x][j] && (!vis[j])) {\n\t\t\tvis[j] = true;\n\t\t\tif ((!bel[j]) || (Find(bel[j]))) {\n\t\t\t\tbel[j] = x;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\treturn false;\n}\n\ninline void Hungary() {\n\tfor (int i = 1; i <= cnt0; ++i) {\n\t\tmemset(vis, false, sizeof(vis));\n\t\tif (Find(i)) ++fsum;\n\t}\n}\n\nint main()\n{\n\tGetprime();\n\tRead(n);\n\tfor (int i = 1; i <= n; ++i) {\n\t\tRead(a[i]);\n\t\tmp[a[i]] ^= 1;\n\t\tmp[a[i] + 1] ^= 1;\n\t}\n\tfor (map<int, int> :: iterator it = mp.begin(); it != mp.end(); ++it)\n\t\tif (it -> second) {\n\t\t\tif ((it -> first) & 1) buf1[++cnt1] = it -> first;\n\t\t\telse buf0[++cnt0] = it -> first;\n\t\t} // exist (cnt0 & 1) == (cnt1 & 1)\n\tfor (int i = 1; i <= cnt0; ++i)\n\t\tfor (int j = 1; j <= cnt1; ++j)\n\t\t\tif (!Pr[Abs(buf0[i] - buf1[j])])\n\t\t\t\tG[i][j] = true;\n\tHungary();\n\tfans = fsum + ((cnt0 - fsum) / 2) * 2 + ((cnt1 - fsum) / 2) * 2 + ((cnt0 - fsum) & 1) * 3;\n\tprintf(\"%d\\n\", fans);\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdio>\n#define MN 200\n#define S 0\n#define T 201\n#define MV 10000000\nusing namespace std;\ninline int read()\n{\n    int x=0,f=1;char ch=getchar();\n    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n    while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n    return x*f;\n}\nbool b[MV+5],B[MV+5];\nint n,a[MN+5],head[MN+5],c[MN+5],d[MN+5],q[MN+5],top,cnt=1,s[MV/5],num,ans,cc,Num[2];\nstruct edge{int to,next,w;}e[MN*MN*10+5];\ninline void ins(int f,int t,int w)\n{\n    e[++cnt]=(edge){t,head[f],w};head[f]=cnt;\n    e[++cnt]=(edge){f,head[t],0};head[t]=cnt;\n}\ninline int Abs(int x){return x<0?-x:x;}\nbool bfs()\n{\n    memset(d,0,sizeof(d));int i,j;\n    for(d[q[top=i=1]=S]=1;i<=top;++i)\n        for(j=c[q[i]]=head[q[i]];j;j=e[j].next)\n            if(e[j].w&&!d[e[j].to]) d[q[++top]=e[j].to]=d[q[i]]+1;\n    return d[T];\n}\nint dfs(int x,int f)\n{\n    if(x==T) return f;int used=0;\n    for(int&i=c[x];i;i=e[i].next)\n        if(e[i].w&&d[e[i].to]==d[x]+1)\n        {\n            int w=dfs(e[i].to,min(f-used,e[i].w));\n            used+=w;e[i].w-=w;e[i^1].w+=w;\n            if(used==f) return f;\n        }\n    return d[x]=-1,used;\n}\nint main()\n{\n    n=read();\n    for(int i=1;i<=n;++i) a[i]=read(),B[a[i]]^=1,B[a[i]+1]^=1;\n    for(int i=1;i<=n;++i)\n    {\n        if(B[a[i]]) s[++cc]=a[i],++Num[a[i]&1];\n        if(B[a[i]+1]) s[++cc]=a[i]+1,++Num[(a[i]&1)^1];\n    }\n    for(int i=2;i<=MV;++i)\n    {\n        if(!b[i]) s[++num]=i;\n        for(int j=1;s[j]*i<=MV;++j)\n        {\n            b[s[j]*i]=1;\n            if(i%s[j]==0) break;\n        }\n    }\n    for(int i=1;i<=cc;++i)\n    {\n        if(s[i]&1) ins(S,i,1); else ins(i,T,1);\n        if(s[i]&1)for(int j=1;j<=cc;++j)if((~s[j]&1)&&!b[Abs(s[i]-s[j])]) ins(i,j,1);\n    }\n    while(bfs()) ans+=dfs(S,10000);\n    printf(\"%d\",ans+(Num[0]-ans)/2*2+(Num[1]-ans)/2*2+((Num[0]-ans)&1)*3);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<cstdio>\n#include<cstring>\nusing namespace std;\nconst int N=1e7;\nint n,x,ans,t[N+5],p[4500005],b[205][205],d1[205],d2[205],s[205];\nbool bz[N+5],bz1[N+5],v[205];\nbool dg(int x)\n{\n\tfor (int i=1;i<=d2[0];i++)\n\tif (b[x][i] && !v[i])\n\t{\n\t\tv[i]=1;\n\t\tif (!s[i] || dg(s[i]))\n\t\t{\n\t\t\ts[i]=x;\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<=n;i++) scanf(\"%d\",&x),bz[x]=1;\n\tfor (int i=1;i<=N;i++) \n\tif (bz[i]^bz[i-1]) \n\t{\n\t\tif (i&1) d1[++d1[0]]=i; \n\t\t\telse d2[++d2[0]]=i;\n\t}\n\tmemset(bz,0,sizeof(bz));\n\tfor (int i=2;i<=N;i++)\n\t{\n\t\tif (!bz[i]) p[++p[0]]=i,bz1[i]=1;\n\t\tfor (int j=1;j<=p[0] && i*p[j]<=N;j++)\n\t\t{\n\t\t\tbz[i*p[j]]=1;\n\t\t\tif (i%p[j]==0) break;\n\t\t}\n\t}\n\tfor (int i=1;i<=d1[0];i++)\n\t\tfor (int j=1;j<=d2[0];j++)\n\t\tif (bz1[abs(d1[i]-d2[j])]) b[i][j]=1;\n\tfor (int i=1;i<=d1[0];i++)\n\t{\n\t\tmemset(v,0,sizeof(v));\n\t\tif (dg(i)) ans++;\n\t}\n\td1[0]-=ans,d2[0]-=ans;\n\tans+=d1[0]/2*2+d2[0]/2*2+d1[0]%2*3;\n\tprintf(\"%d\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cctype>\n#include <cmath>\n#include <algorithm>\n#define rep(i, a, b) for (int i = (a), _ = (b); i <= _; ++ i)\n#define per(i, a, b) for (int i = (a), _ = (b); i >= _; -- i)\n#define For(i, a, b) for (int i = (a), _ = (b); i < _; ++ i)\n#define ri rd<int>\nusing namespace std;\nconst int maxN = 107;\nconst int M = 10000000;\nconst int maxM = 1e7 + 7;\n\ntemplate<class T> inline T rd() {\n\tbool f = 1; char c = getchar(); for (; !isdigit(c); c = getchar()) if (c == '-') f = 0;\n\tT x = 0; for (; isdigit(c); c = getchar()) x = x * 10 + c - 48; return f ? x : -x;\n}\n\nint n;\nint a[maxN];\nint b[maxN], m;\nbool ntpri[maxM];\nint pri[maxM], cnt;\nint link[maxN], vis[maxN];\nbool adj[maxN][maxN];\n\nvoid seive() {\n\tntpri[1] = 1;\n\trep (i, 2, M) {\n\t\tif (!ntpri[i]) pri[++cnt] = i;\n\t\trep (j, 1, cnt) {\n\t\t\tif (1LL * i * pri[j] > M) break;\n\t\t\tntpri[i * pri[j]] = 1;\n\t\t\tif (i % pri[j] == 0) break;\n\t\t}\n\t}\n\tntpri[2] = ntpri[0] = 1;\n}\n\nint match(int x) {\n\tvis[x] = 1;\n\trep (y, 1, m) if (adj[x][y] && (!link[y] || (!vis[link[y]] && match(link[y])))) {\n\t\tlink[y] = x;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nint main() {\n\n\tn = ri();\n\trep (i, 1, n) a[i] = ri();\n\n\tb[++m] = a[1] - 1;\n\trep (i, 2, n) if (a[i-1] + 1 < a[i]) b[++m] = a[i-1], b[++m] = a[i] - 1;\n\tb[++m] = a[n];\n\n\tseive();\n\n\trep (i, 1, m) if (b[i] & 1) \n\t\trep (j, 1, m) if (ntpri[abs(b[i] - b[j])] == 0) adj[i][j] = 1; \n\n\tint res = 0, cc = 0;\n\tmemset(link, 0, sizeof link);\n\trep (i, 1, m) if (b[i] & 1) {\n\t\tmemset(vis, 0, sizeof vis);\n\t\tres += match(i);\n\t\t++ cc;\n\t}\n\n\tres += ((cc - res) >> 1) << 1;\n\tres += ((m - cc) >> 1) << 1;\n\tres += 3 * ((m - cc) & 1);\n\n\tprintf(\"%d\\n\", res);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int inf=0x3f3f3f3f;\nint read()\n{\n\tint r=0,f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9')r=(r<<1)+(r<<3)+ch-'0',ch=getchar();\n\treturn r*f;\n}\nbool np[10000100];\nint pri[5000500],tot;\nvoid Euler()\n{\n\tnp[1]=1;int ma=1e7;\n\tfor(int i=2;i<=ma;++i)\n\t{\n\t\tif(!np[i])pri[++tot]=i;\n\t\tfor(int j=1;j<=tot&&i*pri[j]<=ma;++j)\n\t\t{\n\t\t\tnp[i*pri[j]]=1;\n\t\t\tif(i%pri[j]==0)break;\n\t\t}\n\t}\n}\nint n;\nbool po[10000100];\nint pos[110];\nstruct data{\n\tint to,nxt,c;\n}mp[100100];\nint head[220],cnt=1;\nint s,t;\nint cur[220];\nvoid link(int x,int y,int c)\n{\n\tmp[++cnt].to=y;\n\tmp[cnt].nxt=head[x];\n\tmp[cnt].c=c;\n\thead[x]=cnt;\n}\nvoid add(int x,int y,int c)\n{\n\tlink(x,y,c);link(y,x,0);\n//\tcout<<\"x: \"<<x<<\" y: \"<<y<<endl;\n}\nint dis[220];\nqueue<int>q;\nbool bfs()\n{\n\tfor(int i=1;i<=t;++i)dis[i]=0;\n\tdis[s]=1;q.push(s);\n\tint u;\n\twhile(!q.empty())\n\t{\n\t\tu=q.front();q.pop();\n\t\tfor(int i=head[u];i;i=mp[i].nxt)\n\t\t\tif(!dis[mp[i].to])\n\t\t\t\tdis[mp[i].to]=dis[u]+1,q.push(mp[i].to);\n\t}\n\treturn dis[t];\n}\nint dfs(int x,int f)\n{\n\tif(x==t)return f;\n//\tcout<<\"x: \"<<x<<\" f: \"<<f<<endl;\n\tint fl,rf=0;\n\tfor(int& i=cur[x];i;i=mp[i].nxt)\n\t\tif(dis[mp[i].to]==dis[x]+1&&mp[i].c)\n\t\t{\n\t\t\tfl=dfs(mp[i].to,min(f,mp[i].c));\n\t\t\tif(fl)\n\t\t\t{\n\t\t\t\tf-=fl;rf+=fl;\n\t\t\t\tmp[i].c-=fl;\n\t\t\t\tmp[i^1].c+=fl;\n\t\t\t\tif(!f)break;\n\t\t\t}\n\t\t}\n\treturn rf;\n}\nint Dinic()\n{\n\tint maxflow=0,flow;\n\twhile(bfs())\n\t{\n\t\tfor(int i=1;i<=t;++i)cur[i]=head[i];\n\t\twhile(flow=dfs(s,inf))maxflow+=flow;\n\t}\n\treturn maxflow;\n}\nint main()\n{\n\tEuler();\n//\tfor(int i=1;i<=10;++i)cout<<np[i]<<\" \";cout<<endl;\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;++i)po[read()]=1;\n\tn=0;\n\tfor(int i=1;i<=1e7+1;++i)\n\t\tif(po[i]!=po[i-1]) pos[++n]=i;\n\ts=n+1,t=n+2;\n\tint odd=0,even=0;\n//\tfor(int i=1;i<=n;++i)cout<<pos[i]<<\" \";cout<<endl;\n\tfor(int i=1;i<=n;++i)\n\t\tif(pos[i]&1)\n\t\t{\n\t\t\tadd(s,i,1);\n\t\t\todd++;\n\t\t\tfor(int j=1;j<=n;++j)\n\t\t\t\tif((!(pos[j]&1))&&(!np[abs(pos[i]-pos[j])]))\n\t\t\t\t\tadd(i,j,1);\n\t\t}\n\tfor(int i=1;i<=n;++i)\n\t\tif(!(pos[i]&1))add(i,t,1),even++;\n//\tcout<<\"even: \"<<even<<\" odd: \"<<odd<<endl;\n\tint ans=Dinic();\n//\tcout<<\"ans: \"<<ans<<endl;\n\teven-=ans;odd-=ans;\n\tif((even&1)||(odd&1))ans+=3;\n\teven-=even&1;odd-=odd&1;\n\tans+=even+odd;\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <cmath>\nusing namespace std;\nconst int maxn=101;\n\nint n,a[maxn];\nvector<int> q,odd,eve;\nvector<int> po[maxn*2],pe[maxn*2];\nint to,te,s;\nbool vis[maxn*2];\nint match[maxn*2];\n\nbool prime(int p)\n{\n\tif (p<=2) return false;\n\tfor(int i=2;i<=sqrt(p);i++)\n\t\tif (p%i==0) return false;\n\treturn true;\n}\n\nbool calc(int p)\n{\n\tfor(int i=0;i<po[p].size();i++)\n\t{\n\t\tint nxt=po[p][i];\n\t\tif (vis[nxt]) continue;\n\t\tvis[nxt]=true;\n\t\t\n\t\tif (!match[nxt] || calc(match[nxt]))\n\t\t{\n\t\t\tmatch[nxt]=p;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)\n\t\tscanf(\"%d\",&a[i]);\n\t\n\tq.push_back(a[1]);\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tif (a[i]+1<a[i+1])\n\t\t{\n\t\t\tq.push_back(a[i]+1);\n\t\t\tq.push_back(a[i+1]);\n\t\t}\n\t}\n\tq.push_back(a[n]+1);\n\t\n\todd.push_back(0);\n\teve.push_back(0);\n\tfor(int i=0;i<q.size();i++)\n\t{\n\t\tif (q[i]%2) odd.push_back(q[i]),to++;\n\t\telse eve.push_back(q[i]),te++;\n\t}\n\t\n\tfor(int i=1;i<=to;i++)\n\t{\n\t\tfor(int j=1;j<=te;j++)\n\t\t{\n\t\t\tif (prime(abs(odd[i]-eve[j])))\n\t\t\t{\n\t\t\t\tpo[i].push_back(j);\n\t\t\t\tpe[j].push_back(i);\n\t\t\t}\n\t\t}\n\t}\n\t\n\ts=0;\n\tfor(int i=1;i<=to;i++)\n\t{\n\t\tfor(int j=1;j<=te;j++)\n\t\t\tvis[j]=false;\n\t\tif (calc(i)) s++;\n\t}\n\t\n\tint ans=s+((to-s)/2+(te-s)/2)*2+(to-s)%2*3;\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <cmath>\n#include <set>\n#define lowbit(x) (x&(-x))\n#define MAX(a,b) (a<b?b:a)\n#define MIN(a,b) (a<b?a:b)\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\nconst int N = 1e7;\nconst int maxn = 3e5 + 5;\nll mod = 1e9 + 7;\n\nint n, vis[N + 5];\nvector<int> odd, even, g[105];\n\nint check(int n)\n{\n\tif (n <= 2) return 0;\n\tint m = sqrt(n);\n\tfor (int i = 2; i <= m; i++) if (n%i == 0) return 0;\n\treturn 1;\n}\n\nint link[105], used[105];\nint dfs(int u)\n{\n\tfor (int j = 0; j < g[u].size(); j++)\n\t{\n\t\tint v = g[u][j];\n\t\tif (!used[v])\n\t\t{\n\t\t\tused[v] = 1;\n\t\t\tif (link[v] == -1 || dfs(link[v]))\n\t\t\t{\n\t\t\t\tlink[v] = u;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tint x;\n\t\tscanf(\"%d\", &x);\n\t\tvis[x] = 1;\n\t}\n\tfor (int i = 1; i <= N + 1; i++)\n\t{\n\t\tif (vis[i] != vis[i - 1])\n\t\t{\n\t\t\tif (i & 1) odd.push_back(i);\n\t\t\telse even.push_back(i);\n\t\t}\n\t}\n\n\tfor (int i = 0; i < odd.size(); i++)\n\t{\n\t\tfor (int j = 0; j < even.size(); ++j)\n\t\t{\n\t\t\tif (check(abs(odd[i] - even[j])))  g[i].push_back(odd.size() + j);\n\t\t}\n\t}\n\n\tmemset(link, -1, sizeof(link));\n\tint k = 0;\n\tfor (int i = 0; i < odd.size(); i++)\n\t{\n\t\tk += dfs(i);\n\t}\n\n\tprintf(\"%d\", k + ((int)(odd.size() - k) / 2 + (int)(even.size() - k) / 2) * 2 + (int)(odd.size() % 2) * 3);\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<cstring>\n#include<cctype>\n#include<cstdio>\n#define rep(i,x,y) for(int i=x; i<=y; ++i)\n\nusing namespace std;\nconst int N=105,M=10000005,INF=1000000000;\nint n,a[N],L[N],R[N],totl,totr;\nbool vis[M];\nint prm[M],ans;\nint s,t,h[N<<1],cnt,cur[N<<1],g[N<<1],dis[N<<1];\nstruct edge{int v,f,n;} e[(N*N+N+N)*2];\n\nint getint()\n{\n\tchar ch;\n\twhile(!isdigit(ch=getchar()));\n\tint x=ch-48;\n\twhile(isdigit(ch=getchar())) x=x*10+ch-48;\n\treturn x;\n}\n\nvoid addedge(int u,int v)\n{\n\te[cnt]=(edge){v,1,h[u]},h[u]=cnt++;\n\te[cnt]=(edge){u,0,h[v]},h[v]=cnt++;\n}\n\nint isap(int x,int rt)\n{\n\tif(x==t) return rt;\n\tint sum=0;\n\tfor(int i=cur[x]; i!=-1; i=e[i].n)\n\t\tif(e[i].f && dis[x]==dis[e[i].v]+1)\n\t\t{\n\t\t\tint f=isap(e[i].v,min(rt-sum,e[i].f));\n\t\t\te[i].f-=f,e[i^1].f+=f,sum+=f;\n\t\t\tif(cur[x]=i,sum==rt || dis[s]>=t) return sum;\n\t\t}\n\tif(!(--g[dis[x]++])) dis[s]=t;\n\t++g[dis[x]],cur[x]=h[x];\n\treturn sum;\n}\n\nint main()\n{\n\tn=getint();\n\trep(i,1,n) a[i]=getint();\n\tfor(int i=1,j; i<=n; i=j+1)\n\t{\n\t\tfor(j=i; j+1<=n && a[j]+1==a[j+1]; ++j);\n\t\tif(a[i]&1) ++totl,L[totl]=a[i];\n\t\telse ++totr,R[totr]=a[i];\n\t\tif((a[j]+1)&1) ++totl,L[totl]=a[j]+1;\n\t\telse ++totr,R[totr]=a[j]+1;\n\t}\n\t\n\tvis[1]=1;\n\trep(i,2,a[n])\n\t{\n\t\tif(!vis[i]) prm[++*prm]=i;\n\t\trep(j,1,*prm)\n\t\t{\n\t\t\tif(i*prm[j]>a[n]) break;\n\t\t\tvis[i*prm[j]]=1;\n\t\t\tif(i%prm[j]==0) break;\n\t\t}\n\t}\n\n\ts=totl+totr+1,t=s+1;\n\tmemset(h,-1,sizeof(h));\n\trep(i,1,totl) rep(j,1,totr) if(!vis[abs(L[i]-R[j])]) addedge(i,j+totl);\n\trep(i,1,totl) addedge(s,i);\n\trep(i,1,totr) addedge(i+totl,t);\n\tmemcpy(cur,h,sizeof(h));\n\tfor(g[0]=t; dis[s]<t; ans+=isap(s,INF));\n\tprintf(\"%d\\n\",ans+(totl-ans>>1)*2+(totr-ans>>1)*2+((totl-ans)&1)*3);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <cstdio>\n\nusing namespace std;\n\nconst int N=105;\nconst int M=N*N;\nconst int L=10000000;\n\nint last[N],bel[N];\nint nxt[M],tov[M];\nbool mark[L+5];\nint pos[2][N];\nbool vis[N];\nint n,tot,mx,match,ans;\n\ninline int iabs(int x){return x>0?x:-x;}\n\ninline void insert(int x,int y){tov[++tot]=y,nxt[tot]=last[x],last[x]=tot;}\n\ninline bool is_prime(int x)\n{\n\tif (x==1) return 0;\n\tfor (int i=2;i*i<=x;++i) if (!(x%i)) return 0;\n\treturn 1;\n}\n\nbool hungary(int x)\n{\n\tif (vis[x]) return 0;\n\tvis[x]=1;\n\tfor (int i=last[x],y;i;i=nxt[i])\n\t\tif (!bel[y=tov[i]]||hungary(y))\n\t\t\treturn bel[y]=x;\n\treturn 0;\n}\n\nint main()\n{\n\t//freopen(\"flip.in\",\"r\",stdin),freopen(\"flip.out\",\"w\",stdout);\n\tscanf(\"%d\",&n);\n\tfor (int i=1,x;i<=n;++i) scanf(\"%d\",&x),mx=max(mx,x),mark[x]=1;\n\tfor (int i=1;i<=mx+1;++i)\n\t\tif (mark[i]^mark[i-1])\n\t\t\tpos[i&1][++pos[i&1][0]]=i;\n\tfor (int i=1;i<=pos[0][0];++i)\n\t\tfor (int j=1;j<=pos[1][0];++j)\n\t\t{\n\t\t\tint d=iabs(pos[0][i]-pos[1][j]);\n\t\t\tif (is_prime(d)) insert(i,j);\n\t\t}\n\tmatch=0;\n\tfor (int i=1;i<=pos[0][0];++i) memset(vis,0,sizeof vis),match+=hungary(i);\n\tans=match,pos[0][0]-=match,pos[1][0]-=match;\n\tans+=(pos[0][0]&1)+pos[0][0]+pos[1][0];\n\tprintf(\"%d\\n\",ans);\n\t//fclose(stdin),fclose(stdout);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdio>\n#define MN 200\n#define S 0\n#define T 201\n#define MV 10000000\nusing namespace std;\ninline int read()\n{\n    int x=0,f=1;char ch=getchar();\n    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n    while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n    return x*f;\n}\nbool b[MV+5],B[MV+5];\nint n,a[MN+5],head[MN+5],c[MN+5],d[MN+5],q[MN+5],top,cnt=1,s[MV/5],num,ans,cc,Num[2];\nstruct edge{int to,next,w;}e[MN*MN*10+5];\ninline void ins(int f,int t,int w)\n{\n    e[++cnt]=(edge){t,head[f],w};head[f]=cnt;\n    e[++cnt]=(edge){f,head[t],0};head[t]=cnt;\n}\ninline int Abs(int x){return x<0?-x:x;}\nbool bfs()\n{\n    memset(d,0,sizeof(d));int i,j;\n    for(d[q[top=i=1]=S]=1;i<=top;++i)\n        for(j=c[q[i]]=head[q[i]];j;j=e[j].next)\n            if(e[j].w&&!d[e[j].to]) d[q[++top]=e[j].to]=d[q[i]]+1;\n    return d[T];\n}\nint dfs(int x,int f)\n{\n    if(x==T) return f;int used=0;\n    for(int&i=c[x];i;i=e[i].next)\n        if(e[i].w&&d[e[i].to]==d[x]+1)\n        {\n            int w=dfs(e[i].to,min(f-used,e[i].w));\n            used+=w;e[i].w-=w;e[i^1].w+=w;\n            if(used==f) return f;\n        }\n    return d[x]=-1,used;\n}\nint main()\n{\n    n=read();\n    for(int i=1;i<=n;++i) a[i]=read(),B[a[i]]^=1,B[a[i]+1]^=1;\n    for(int i=1;i<=n;++i)\n    {\n        if(B[a[i]]) s[++cc]=a[i],++Num[a[i]&1];\n        if(B[a[i]+1]) s[++cc]=a[i]+1,++Num[(a[i]&1)^1];\n    }\n    for(int i=2;i<=MV;++i)\n    {\n        if(!b[i]) s[++num]=i;\n        for(int j=1;s[j]*i<=MV;++j)\n        {\n            b[s[j]*i]=1;\n            if(i%s[j]==0) break;\n        }\n    }\n    for(int i=1;i<=cc;++i)\n    {\n        if(s[i]&1) ins(S,i,1); else ins(i,T,1);\n        if(s[i]&1)for(int j=1;j<=cc;++j)if((~s[j]&1)&&Abs(s[i]-s[j])>2&&!b[Abs(s[i]-s[j])]) ins(i,j,1);\n    }\n    while(bfs()) ans+=dfs(S,10000);\n    printf(\"%d\",ans+(Num[0]-ans)/2*2+(Num[1]-ans)/2*2+((Num[0]-ans)&1)*3);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n#include <utility>\n#include <cstdlib>\n#include <memory>\n#include <queue>\n#include <cassert>\n#include <cmath>\n#include <ctime>\n#include <complex>\n#include <bitset>\n#include <fstream>\n#include <unordered_map>\n#include <unordered_set>\n#include <numeric>\n\nusing namespace std;\n\n#define ws ws_____________________\n#define y1 y1_____________________\n#define y0 y0_____________________\n#define left left_________________\n#define right right_______________\n#define next next_________________\n#define prev prev_________________\n#define hash hash_________________\n\n#define pb push_back\n#define fst first\n#define snd second\n#define mp make_pair \n#define sz(C) ((int) (C).size())\n#define forn(i, n) for (int i = 0; i < int(n); ++i)\n#define ford(i, n) for (int i = int(n) - 1; i >= 0; --i)\n#define all(C) begin(C), end(C)\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef unsigned int uint;\ntypedef pair<int,int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<ll> vll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vii;\ntypedef long double ld;\ntypedef complex<double> cd;\n\n#ifdef LOCAL\n#define eprintf(args...) fprintf(stderr, args), fflush(stderr)\n#else\n#define eprintf(...) ;\n#endif\n\n#define FILE_NAME \"a\"\n\n\nint n;\nvi xs;\n\nbool read() {\n\tif  (scanf(\"%d\", &n) < 1) {\n\t\treturn 0;\n\t}\n\txs.resize(n);\n\tforn(i, n) {\n\t\tscanf(\"%d\", &xs[i]);\n\t}\n\treturn 1;\n}\n\nconst int MAX = 1e7 + 10;\n\nint A[MAX];\nint B[MAX];\nbool prime[MAX];\n\nstruct Graph {\n\tvvi g;\n\tvi mt;\n\tvi used;\n\tint n, m;\n\n\tGraph() = default;\n\n\tGraph(int n, int m) : n(n), m(m) {\n\t\tg.resize(n);\n\t}\n\n\tvoid addE(int v, int to) {\n\t\tg[v].pb(to);\n\t} \n\n\tbool dfs(int v) {\n\t\tif  (used[v]) {\n\t\t\treturn 0;\n\t\t}\n\t\tused[v] = 1;\n\t\tfor (int to : g[v]) {\n\t\t\tif  (mt[to] == -1 || dfs(mt[to])) {\n\t\t\t\tmt[to] = v;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\n\tvii getMatch() {\n\t\tmt.assign(m, -1);\n\t\tforn(v, n) {\n\t\t\tused.assign(n, 0);\n\t\t\tdfs(v);\n\t\t}\n\n\t\tvii res;\n\t\tforn(i, m) {\n\t\t\tif  (mt[i] != -1) {\n\t\t\t\tres.pb(mp(mt[i], i));\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n};\n\nint calc() {\n\tvi vals;\n\tforn(i, MAX) {\n\t\tif  (B[i]) {\n\t\t\tvals.pb(i);\n\t\t}\n\t}\n\n\tsort(all(vals));\n\teprintf(\"vals:\\n\");\n\tfor (int val : vals) {\n\t\teprintf(\"%d \", val);\n\t}\n\teprintf(\"\\n\");\n\n\tassert(sz(vals) % 2 == 0);\n\n\tvi odd;\n\tvi even;\n\tfor (int val : vals) {\n\t\tif  (val & 1) {\n\t\t\todd.pb(val);\n\t\t} else {\n\t\t\teven.pb(val);\n\t\t}\n\t}\n\n\tGraph g(sz(odd), sz(even));\n\tforn(i, sz(odd)) {\n\t\tforn(j, sz(even)) {\n\t\t\tconst int p = abs(odd[i] - even[j]);\n\t\t\tif  (p >= 3 && prime[p]) {\n\t\t\t\tg.addE(i, j);\n\t\t\t}\n\t\t}\n\t}\n\n\tvii match = g.getMatch();\n\tint ans = sz(match);\n\n\tint cnt_even = sz(even) - sz(match);\n\tint cnt_odd = sz(odd) - sz(match);\n\n\tans += 2 * (cnt_even / 2);\n\tcnt_even %= 2;\n\n\tans += 2 * (cnt_odd / 2);\n\tcnt_odd %= 2;\n\n\tassert(cnt_odd == cnt_even);\n\tif  (cnt_even) {\n\t\tans += 3;\n\t}\n\n\treturn ans;\n}\n\nint solve() {\n\tmemset (prime, 0, sizeof prime);\n\tfor (int i = 2; i < MAX; ++i) {\n\t\tprime[i] = 1;\n\t}\n\tfor (int i = 2; i < MAX; ++i) {\n\t\tif  (prime[i]) {\n\t\t\tfor (int j = i + i; j < MAX; j += i) {\n\t\t\t\tprime[j] = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tmemset (A, 0, sizeof A);\n\tfor (int x : xs) {\n\t\tA[x] ^= 1;\n\t}\n\n\tforn(i, MAX) {\n\t\tB[i] = A[i] ^ A[i + 1];\n\t}\n\n\tint ans = calc();\n\treturn ans;\n}\n\nint main() {\n#ifdef LOCAL\n\tfreopen(FILE_NAME \".in\", \"r\", stdin);\n\t// freopen(FILE_NAME \".out\", \"w\", stdout);\n#endif\n\n\twhile (read()) {\n\t\tprintf(\"%d\\n\", solve());\n\t}\n\n#ifdef LOCAL\n\tcerr.precision(5);\n\tcerr << \"Time: \" << fixed << (double) clock() / CLOCKS_PER_SEC << endl;\n#endif\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<cstring>\n#include<map>\n#include<queue>\nusing namespace std;\ntypedef long long ll;\nconst int N=105,INF=~0u>>2;\nstruct Edge{int nxt,to;}edge[(N*N)<<2];\nint a[N],b[N],n,head[N<<2],num_edge,vis[N<<2],lk[N<<2],even[N],odd[N],even_num,odd_num,ans,k,tot,tim;\nint read(){\n\tint x=0,f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-') f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn f*x;\n}\nvoid add_edge(int from,int to){\n\tedge[++num_edge].nxt=head[from];\n\tedge[num_edge].to=to;\n\thead[from]=num_edge;\n}\nbool find(int x){\n\tfor(int i=head[x];i;i=edge[i].nxt){\n\t\tif(vis[edge[i].to]!=tim){\n\t\t\tvis[edge[i].to]=tim;\n\t\t\tif(!lk[edge[i].to]||find(edge[i].to)){\n\t\t\t\tlk[edge[i].to]=x;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nbool check(int x){\n\tfor(int i=2;i*i<=x;++i){\n\t\tif(x%i==0) return 0;\n\t}\n\treturn 1;\n}\nint main(){\n//\tfreopen(\"ex.in\",\"r\",stdin);\n\tn=read();\n\tfor(int i=1;i<=n;++i) b[i]=read();b[0]=-INF;b[n+1]=INF;\n\tfor(int i=1;i<=n;++i){\n\t\tif(b[i]!=b[i-1]+1){\n\t\t\tif(i%2) odd[++odd_num]=b[i];\n\t\t\telse even[++even_num]=b[i];\n\t\t}\n\t\tif(b[i]+1!=b[i+1]){\n\t\t\tif((i+1)%2) odd[++odd_num]=b[i]+1;\n\t\t\telse even[++even_num]=b[i]+1;\n\t\t}\n\t}\n\tfor(int i=1;i<=odd_num;++i){\n\t\tfor(int j=1;j<=even_num;++j){\n\t\t\tif(odd[i]>even[j]) continue;\n\t\t\tif(check(even[j]-odd[i])) add_edge(i,odd_num+j),add_edge(odd_num+j,i);\n\t\t}\n\t}\n\tfor(int i=1;i<=odd_num;++i,++tim){\n\t\tif(find(i)) k++;\n\t\telse break;\n\t}\n\tans=k+((even_num-k)/2+(odd_num-k)/2)*2+((even_num-k)%2)*3;\n\tprintf(\"%d\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\ntypedef long long ll;\nint odd=0,even=0,Odd[105],Even[105],ma[105];\nint flag[10000010],x[10000010],map[105][105],vis[105];\nint prime[10000010],a[105];\nint dfs(int u)\n{\n\tfor (int v=1;v<=even;v++)\n\t{\n\t\tif (!map[u][v]) continue;\n\t\tif (!vis[v])\n\t\t{\n\t\t\tvis[v]=1;\n\t\t\tif (ma[v]==-1||dfs(ma[v]))\n\t\t\t{\n\t\t\t\tma[v]=u;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nint main()\n{\n\tint n,cnt=0;\n\tscanf(\"%d\",&n);\n\tflag[1]=1;\n\tfor (int i=2;i<=10000001;i++)\n\t{\n\t\tif (!flag[i]) prime[++cnt]=i;\n\t\tfor (int j=1;j<=cnt;j++)\n\t\t{\n\t\t\tif (i*prime[j]>10000001) break;\n\t\t\tflag[i*prime[j]]=1;\n\t\t\tif (i%prime[j]==0) break;\n\t\t}\n\t}\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%d\",&a[i]);\n\t\tx[a[i]]^=1;\n\t}\n\tfor (int i=1;i<=10000001;i++)\n\t\tif (x[i]!=x[i-1])\n\t\t{\n\t\t\tif (i&1) Odd[++odd]=i;\n\t\t\telse Even[++even]=i; \n\t\t}\n\tfor (int i=1;i<=odd;i++)\n\t\tfor (int j=1;j<=even;j++)\n\t\t\tif (flag[abs(Odd[i]-Even[j])]) map[i][j]=1;\n\tfor (int i=1;i<=even;i++)\n\t\tma[i]=-1;\n\tint sum=0;\n\tfor (int i=1;i<=odd;i++)\n\t{\n\t\tmemset(vis,0,sizeof(vis));\n\t\tif (dfs(i)) sum++;\n\t}\n\tll ans=sum+(((odd-sum)>>1)<<1)+(((even-sum)>>1)<<1)+(odd-sum)%2*3;\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define Mem(a,b) memset(a,b,sizeof(a))\n#define ll long long\n#define lson root<<1\n#define rson root<<1|1\n#define Mid int mid=(l+r)>>1\n#define FREI freopen(\"in.txt\",\"r\",stdin)\n#define FREO freopen(\"out.txt\",\"w\",stdout)\n#define inf 0x3f3f3f3f\n#define mod 1000000007\n#define PB push_back\nusing namespace std;\nconst int MAXN=1e7+10;\nint n;\nint vis[200];\nstruct fc{\n    int v,cost;\n};\nvector<int>point;\nvector<int>X,Y;\nvector<fc>G[110];\nbool used[220];\nint pre[220];\nvoid pretreat(){\n    Mem(vis,0);\n    point.clear();\n    scanf(\"%d\",&n);\n    for(int i=0;i<n;i++){\n        scanf(\"%d\",&vis[i]);\n    }\n    sort(vis,vis+n);\n    for(int i=0;i<n;i++){\n        if(i==0) point.PB(vis[i]);\n        if(i>0&&vis[i]!=vis[i-1]+1) {\n            point.PB(vis[i]);\n            //cout<<i<<' '<<vis[i]<<endl;\n        }\n        if(vis[i+1]!=vis[i]+1){\n            point.PB(vis[i]+1);\n            //cout<<vis[i]+1<<endl;\n        }\n    }\n    for(auto u:point){\n        //cout<<u<<' ';\n        if(u&1) Y.push_back(u);\n        else X.push_back(u);\n    }\n    //cout<<endl;\n}\nvoid build_graph(){\n    for(int i=0;i<X.size();i++){\n        for(int j=0;j<Y.size();j++){\n            G[i+1].PB({j+1,abs(Y[j]-X[i])});\n        }\n    }\n}\nbool isprime(int x){\n    for(int i=2;i*i<=x;i++){\n        if(x%i==0) return false;\n    }\n    return true;\n}\nbool dfs(int u){\n    for(int i=0;i<G[u].size();i++){\n        int v=G[u][i].v,cost=G[u][i].cost;\n        //cout<<cost<<endl;\n        if(!used[v]&&isprime(cost)){\n            used[v]=1;\n            if(!pre[v]||dfs(pre[v])){\n                pre[v]=u;\n                return true;\n            }\n        }\n    }\n    return false;\n}\nint solve(){\n    Mem(pre,0);\n    int ans=0;\n    for(int i=1;i<=X.size();i++){\n        Mem(used,0);\n        if(dfs(i)) ans++;\n    }\n    //cout<<ans<<endl;\n    //cout<<X.size()<<endl;\n    return ans+(X.size()-ans)/2*2+(Y.size()-ans)/2*2+((X.size()-ans)%2)*3;\n}\nint main() {\n    //FREI;\n    pretreat();\n    build_graph();\n    printf(\"%d\\n\",solve());\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\ninline int read()\n{\n\tint x = 0, op = 1; char ch = 0;\n\twhile(not isdigit(ch = getchar())) if(ch == '-') op = -op;\n\tdo x = x * 10 + (ch - '0'); while(isdigit(ch = getchar()));\n\treturn op * x;\n}\ninline bool check(int a, int x, int y, int z)\n{\n\tint u = 0, v = 0, w = 0;\n\t#define pows(a, b) \\\n\t\tu = (a), v = (b), w = 1;\\\n\t\twhile(v) { if(v & 1) w = w * u % x; u = u * u % x, v >>= 1; }\n\tpows(a, z);\n\tif(w > 1) { \n\t\tfor(int i = 0; i < y; i++) \n\t\t\tif(w == x - 1) return true;\n\t\treturn false;\n\t}\n\telse return true;\n}\nbool isprime(int x)\n{\n\tif(x == 2 || x == 7 || x == 61 || x == 3) return true;\n\tif(!(x % 2 && x % 7 && x % 61 && x % 3) || x == 1) return false;\n\tint y = 0, z = x - 1; while(!(z & 1)) y++, z >>= 1;\n\tbool ok = true;\t\n\tok &= check(2, x, y, z);\n\tok &= check(3, x, y, z);\n\tok &= check(7, x, y, z);\n\tok &= check(61, x, y, z);\n\treturn ok;\n}\nint n = 0, m = 0, pos[150], whi[300];\nbool used[300]; int ans = 0;\nint pygo[300]; bool insta[300];\nbool dfs(int x, int p)\n{\n\t#define able(a, b) (abs(whi[a] - whi[b]) > 2 && isprime(abs(whi[a] - whi[b])))\n\tfor(int i = 1; i <= m; i++)\n\t\tif(not insta[i] && able(x, i) && p != i)\n\t\t{\n\t\t\tinsta[i] = true;\n\t\t\tif(!pygo[i] || dfs(pygo[i], p))\n\t\t\t{\n\t\t\t\tpygo[x] = i, pygo[i] = x;\n\t\t\t\tused[x] = used[i] = true;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\treturn false;\n}\nsigned main()\n{\n\tn = read();\n\tfor(int i = 1; i <= n; i++) pos[i] = read();\n\tsort(pos + 1, pos + n + 1);\n\tfor(int i = 1; i <= n; i++)\n\t{\n\t\tif(i == 1 || pos[i] != pos[i - 1] + 1) whi[++m] = pos[i];\n\t\tif(i == n || pos[i] != pos[i + 1] - 1) whi[++m] = pos[i] + 1;\n\t}\n\tfor(int i = 1; i <= m; i++)\n\t\tif(not used[i]) memset(insta, 0, sizeof sta), dfs(i, i);\n\tfor(int i = 1; i <= n; i++)\n\t\tif(used[i]) ans++;\n\tans >>= 1LL;\n\tint tot[2] = {0, 0};\n\tfor(int i = 1; i <= m; i++)\n\t\tif(not used[i]) tot[whi[i] & 1]++;\n\tans += (((tot[0] >> 1LL) + (tot[1] >> 1LL)) << 1LL) + (tot[0] & 1LL) * 3LL;\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define LL long long\n#define RG register\n#define R RG int\n#define G if(++ip==ie)if(fread(ip=buf,1,SZ,stdin))\n#define S 0\nusing namespace std;\nconst int SZ=1<<19,N=2009,M=2*N*N;\nint T,p=1,a[N],b[N],he[N],ne[M],to[M],f[M],d[N],q[N],cur[N];\nbitset<10000009>np;\nchar buf[SZ],*ie=buf+SZ,*ip=ie-1;\ninline int in(){\n\tG;while(*ip<'-')G;\n\tR x=*ip&15;G;\n\twhile(*ip>'-'){x*=10;x+=*ip&15;G;}\n\treturn x;\n}\ninline void add(R x,R y){\n\tne[++p]=he[x];he[x]=p;to[p]=y;f[p]=1;\n\tne[++p]=he[y];he[y]=p;to[p]=x;\n}\nbool dfs(R x){\n\tif(x==T)return 1;\n\tfor(R&i=cur[x];i;i=ne[i])\n\t\tif(f[i]&&d[to[i]]==d[x]+1&&dfs(to[i]))\n\t\t\treturn f[i]^=1,f[i^1]^=1,1;\n\treturn 0;\n}\nint main(){\n\tR n=in(),m=0,lst=0,ans=0;\n\tfor(R i=1;i<=n;++i)b[i]=in();\n\tsort(b+1,b+n+1);\n\tfor(R i=1;i<=n;++i){\n\t\tif(b[i]!=lst){\n\t\t\tif(lst)a[++m]=lst;\n\t\t\ta[++m]=b[i];\n\t\t}\n\t\tlst=b[i]+1;\n\t}\n\ta[++m]=lst;\n\tfor(R i=2,lim=sqrt(lst)+1;i<lim;++i)\n\t\tif(!np[i])for(R j=i*i;j<lst;j+=i)np[j]=1;\n\tnp[1]=np[2]=1;\n\tT=m+1;\n\tfor(R i=1;i<=m;++i){\n\t\t1&a[i]?add(S,i):add(i,T);\n\t\tfor(R j=1;j<i;++j)\n\t\t\tif(!np[a[i]-a[j]])1&a[i]?add(i,j):add(j,i);\n\t}\n\twhile(1){\n\t\tmemset(d+1,1,4*T);\n\t\tfor(R h=0,t=0;h<=t;++h)\n\t\t\tfor(R i=he[q[h]],dd=d[q[h]]+1;i;i=ne[i])\n\t\t\t\tif(f[i]&&d[to[i]]>dd)\n\t\t\t\t\tq[++t]=to[i],d[to[i]]=dd;\n\t\tif(d[T]==0x01010101)break;\n\t\tmemcpy(cur,he,4*(T+1));\n\t\twhile(dfs(S))++ans;\n\t}\n\tlst=ans;\n\tfor(R i=he[S];i;i=ne[i])ans+=f[i];\n\tans+=1&(ans-lst);\n\tfor(R i=he[T];i;i=ne[i])ans+=f[i^1];\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<algorithm>\n#include<cstdio>\n#include<vector>\n#include<cmath>\nusing namespace std;\n\nconst int M = 1001;\nint n,m,k,a[M],d[M],vis[M],ver[M],s0,s1,w0[M],w1[M],t;\nvector<int> v[M];\n\nbool check(int x)\n{\n\tx=max(x,-x);\n\tif(x==1) return 0;\n\tint k=sqrt(x);\n\tfor(int i=2;i<=k;i++) if(x%i==0) return 0;\n\treturn 1;\n}\n\nvoid ins(int k)\n{\n\tif(k%2) w1[++s1]=k;\n\telse w0[++s0]=k;\n}\n\nint dfs(int x)\n{\n\tfor(int i=0;i<v[x].size();i++)\n\t{\n\t\tif(vis[v[x][i]]==t) continue; vis[v[x][i]]=t;\n\t\tif(!ver[v[x][i]] || dfs(ver[v[x][i]])) \n\t\t{\n\t\t\tver[v[x][i]]=x; \n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nint main()\n{\n\tscanf(\"%d\",&n); a[0]=-1;\n\tfor(int i=1;i<=n;i++) scanf(\"%d\",&a[i]);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tif(a[i]!=a[i-1]+1) ins(a[i]);\n\t\tif(a[i+1]!=a[i]+1) ins(a[i]+1);\n\t}\n\tfor(int i=1;i<=s1;i++)\n\t\tfor(int j=1;j<=s0;j++)\n\t\t\tif(check(w1[i]-w0[j])) v[i].push_back(j);\n\tfor(t=1;t<=s1;t++) k+=dfs(t);\n\tprintf(\"%d\",s1+s0-k+(s1-k)%2);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<algorithm>\n#include<cstdio>\n#include<cmath>\n#include<cassert>\n#define ll long long\nusing namespace std;\ninline int read(){\n\tint re=0,flag=1;char ch=getchar();\n\twhile(ch>'9'||ch<'0'){\n\t\tif(ch=='-') flag=-1;\n\t\tch=getchar();\n\t}\n\twhile(ch>='0'&&ch<='9') re=(re<<1)+(re<<3)+ch-'0',ch=getchar();\n\treturn re*flag;\n}\nint vis[10000010],pri[1000010],cntp;\nvoid init(){\n\tint i,j,k;vis[1]=1;\n\tfor(i=2;i<=10000005;i++){\n\t\tif(!vis[i]) pri[++cntp]=i;\n\t\tfor(j=1;j<=cntp;j++){\n\t\t\tk=i*pri[j];if(k>=10000005) break;\n\t\t\tvis[k]=1;\n\t\t\tif(i%pri[j]==0) break;\n\t\t}\n\t}\n}\nstruct graph{//DINIC大法好！网络流应该比匈牙利快吧...... \n\tint first[1010],dep[1010],cur[1010],cnte;\n\tstruct edge{\n\t\tint to,next,w;\n\t}a[100010];\n\tgraph(){\n\t\tmemset(first,-1,sizeof(first));cnte=-1;\n\t}\n\tinline void add(int u,int v,int w){\n//\t\tcout<<\"addedge \"<<u<<' '<<v<<' '<<w<<'\\n';\n\t\ta[++cnte]=(edge){v,first[u],w};first[u]=cnte;\n\t\ta[++cnte]=(edge){u,first[v],0};first[v]=cnte;\n\t}\n\tbool bfs(int s,int t){\n\t\tint q[1010],head=0,tail=1,i,u,v;\n\t\tfor(i=s;i<=t;i++) dep[i]=-1,cur[i]=first[i];\n\t\tdep[s]=0;q[0]=s;\n\t\twhile(head<tail){\n\t\t\tu=q[head++];\n\t\t\tfor(i=first[u];~i;i=a[i].next){\n\t\t\t\tv=a[i].to;if(~dep[v]||!a[i].w) continue;\n\t\t\t\tdep[v]=dep[u]+1;q[tail++]=v;\n\t\t\t}\n\t\t}\n\t\treturn ~dep[t];\n\t}\n\tint dfs(int u,int t,int lim){\n\t\tif(u==t||!lim) return lim;\n\t\tint i,v,f,flow=0;\n\t\tfor(i=cur[u];~i;i=a[i].next){\n\t\t\tv=a[i].to;cur[u]=i;\n\t\t\tif(dep[v]==dep[u]+1&&(f=dfs(v,t,min(lim,a[i].w)))){\n\t\t\t\ta[i].w-=f;a[i^1].w+=f;\n\t\t\t\tflow+=f;lim-=f;\n\t\t\t\tif(!lim) return flow; \n\t\t\t}\n\t\t}\n\t\treturn flow;\n\t}\n\tint dinic(int s,int t){\n\t\tint re=0;\n\t\twhile(bfs(s,t)) re+=dfs(s,t,1e9);\n\t\treturn re;\n\t}\n}G;\nint n,x[110],one[210],cnt,l[210],cntl,r[210],cntr;\nint main(){\n\tinit();int i,j,match;\n\tn=read();\n\tfor(i=1;i<=n;i++) x[i]=read();\n\tfor(i=1;i<=n;i=j+1){\n\t\tj=i;\n\t\twhile((x[j+1]==x[j]+1)&&j<n) j++;\n\t\tone[++cnt]=x[i];one[++cnt]=x[j]+1;\n\t}\n\tfor(i=1;i<=cnt;i++){\n\t\tif(one[i]%2) l[++cntl]=one[i];\n\t\telse r[++cntr]=one[i];\n\t}\n\tfor(i=1;i<=cntl;i++) G.add(0,i,1);\n\tfor(i=1;i<=cntr;i++) G.add(i+cntl,cntl+cntr+1,1);\n\tfor(i=1;i<=cntl;i++){\n\t\tfor(j=1;j<=cntr;j++){\n//\t\t\tcout<<\"do \"<<i<<' '<<j<<' '<<l[i]<<' '<<r[j]<<'\\n';\n\t\t\tif(!vis[abs(l[i]-r[j])]) G.add(i,cntl+j,1);\n\t\t}\n\t}\n\tmatch=G.dinic(0,cntl+cntr+1);\n\tprintf(\"%d\\n\",match+((cntl-match)/2+(cntr-match)/2)*2+((cntl-match)%2)*3);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <climits>\n#include <queue>\n#include <algorithm>\n\nusing std::queue;\nusing std::min;\n\nconst int MAXX=1e7+5,MAXN=1005;\nint n,cnt_x,cnt_y;\nint x_id[MAXN],y_id[MAXN];\nbool up[MAXX];\n\nstruct node{int he,iter,dis;}d[MAXN];\nstruct line{int to,nex,cap;}ed[MAXN*MAXN];\n\ninline bool is_odd_prm(int x){\n\tfor(int i=2;i*i<=x;++i){\n\t\tif(x%i==0) return false;\n\t}\n\treturn true;\n}\n\ninline void addE(int u,int v,int cap){\n\tstatic int cnt=1;\n\ted[++cnt]=(line){v,d[u].he,cap};\n\td[u].he=cnt;\n}\n\ninline int revE(int i){return i^1;}\n\ninline bool BFS(int s,int t,int n){\n\tfor(int i=1;i<=n;++i)\n\t\td[i].dis=-1;\n\tstatic queue<int> q;\n\td[s].dis=0;\n\tq.push(s);\n\tint u;\n\twhile(q.size()){\n\t\tu=q.front();\n\t\tq.pop();\n\t\tfor(int i=d[u].he,v;i;i=ed[i].nex){\n\t\t\tif(ed[i].cap==0) continue;\n\t\t\tv=ed[i].to;\n\t\t\tif(d[v].dis==-1){\n\t\t\t\td[v].dis=d[u].dis+1;\n\t\t\t\tq.push(v);\n\t\t\t}\n\t\t}\n\t}\n\treturn d[t].dis!=-1;\n}\n\nint aug(int u,int rest,const int t){\n\tif(u==t) return rest;\n\tint ret=0;\n\tfor(int &i=d[u].iter,v,cap,flow;i;i=ed[i].nex){\n\t\tv=ed[i].to,cap=ed[i].cap;\n\t\tif(d[v].dis!=d[u].dis+1 || cap==0)\n\t\t\tcontinue;\n\t\tflow=aug(v,min(cap,rest),t);\n\t\ted[i].cap-=flow,ed[revE(i)].cap+=flow;\n\t\tret+=flow,rest-=flow;\n\t\tif(rest==0) return ret;\n\t}\n\tif(ret==0) d[u].dis=-1;\n\treturn ret;\n}\n\ninline int Dinic(int s,int t,int n){\n\tint ret=0;\n\twhile(BFS(s,t,n)){\n\t\tfor(int i=1;i<=n;++i)\n\t\t\td[i].iter=d[i].he;\n\t\tret+=aug(s,INT_MAX,t);\n\t}\n\treturn ret;\n}\n\ninline void build(){\n\tfor(int i=1;i<=cnt_x;++i){\n\t\tfor(int j=1,v;j<=cnt_y;++j){\n\t\t\tif(is_odd_prm(abs(x_id[i]-y_id[j]))){\n\t\t\t\tv=j+cnt_x;\n\t\t\t\taddE(i,v,INT_MAX),addE(v,i,0);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=1,s=(cnt_x+cnt_y)|1;i<=cnt_x;++i)\n\t\taddE(s,i,1),addE(i,s,0);\n\tfor(int i=1,u,t=cnt_x+cnt_y+2;i<=cnt_y;++i){\n\t\tu=cnt_x+i;\n\t\taddE(u,t,1),addE(t,u,0);\n\t}\n}\n\nint main(){\n\tscanf(\"%d\",&n);\n\tint x;\n\tfor(int i=1;i<=n;++i){\n\t\tscanf(\"%d\",&x);\n\t\tup[x]=true;\n\t}\n\tfor(int i=1;i<=x+1;++i){\n\t\tif(up[i]!=up[i-1])\n\t\t\ti&1 ? x_id[++cnt_x]=i:y_id[++cnt_y]=i;\n\t}\n\tbuild();\n\tint k=Dinic((cnt_x+cnt_y)|1,cnt_x+cnt_y+2,cnt_x+cnt_y+2);\n\tprintf(\"%d\",k+((((cnt_x-k)>>1)+((cnt_y-k)>>1))<<1)+(cnt_x-k)%2*3);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nint n, m, odd[209], even[209], lft[209], rgt[209];\nbool C[209];\nmap < int, bool > b;\nvector < int > v[209];\nconst int lim = 10000001;\nunsigned char cr[(lim + 10) >> 3];\n\nbool pairUp (int nod)\n{\n    if (C[nod]) return 0;\n    C[nod] = 1;\n    for (auto i : v[nod])\n        if (lft[i] == 0 || pairUp (lft[i]))\n        {\n            lft[i] = nod, rgt[nod] = i;\n            return 1;\n        }\n    return 0;\n}\n\nint maxMatch ()\n{\n    bool ok = 1;\n    while (ok)\n    {\n        ok = 0;\n        for (int i=1; i<=n; i++)\n            C[i] = 0;\n        for (int i=1; i<=n; i++)\n            if (rgt[i] == 0)\n                ok |= pairUp (i);\n    }\n    int ans = 0;\n    for (int i=1; i<=n; i++)\n        ans += (rgt[i] > 0);\n    return ans;\n}\n\nint main ()\n{\n//freopen (\"input\", \"r\", stdin);\n//freopen (\"output\", \"w\", stdout);\n\nint N;\nscanf (\"%d\", &N);\nfor (int i=1; i<=N; i++)\n{\n    int x;\n    scanf (\"%d\", &x);\n    b[x] ^= 1, b[x + 1] ^= 1;\n}\nfor (auto it : b)\n    if (it.second)\n    {\n        if (it.first & 1) odd[++n] = it.first;\n        else even[++m] = it.second;\n    }\nfor (int i=2; i * i<=lim; i++)\n    if (cr[i >> 3] & (1 << (i & 7))) ;\n    else\n    {\n        for (int j=i * i; j<=lim; j+=i)\n            cr[j >> 3] |= 1 << (j & 7);\n    }\nfor (int i=1; i<=n; i++)\n    for (int j=1; j<=m; j++)\n    {\n        int val = odd[i] - even[j];\n        if (val < 0) val = -val;\n        if (val <= 2 || (cr[val >> 3] & (1 << (val & 7)))) ;\n        else v[i].push_back (j);\n    }\nint T1 = maxMatch ();\nn -= T1, m -= T1;\nint T3 = n & 1, T2 = n / 2 + m / 2;\nprintf (\"%d\\n\", T1 + 2 * T2 + 3 * T3);\nreturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <cstdio>\n\nusing namespace std;\n\nconst int N=105;\nconst int M=N*N;\nconst int L=10000000;\n\nint last[N],bel[N];\nint nxt[M],tov[M];\nbool mark[L+5];\nint pos[2][N];\nbool vis[N];\nint n,tot,mx,match,ans;\n\ninline int iabs(int x){return x>0?x:-x;}\n\ninline void insert(int x,int y){tov[++tot]=y,nxt[tot]=last[x],last[x]=tot;}\n\ninline bool is_prime(int x)\n{\n\tif (x==1) return 0;\n\tfor (int i=2;i*i<=x;++i) if (!(x%i)) return 0;\n\treturn 1;\n}\n\nbool hungary(int x)\n{\n\tif (vis[x]) return 0;\n\tvis[x]=1;\n\tfor (int i=last[x],y;i;i=nxt[i])\n\t\tif (!bel[y=tov[i]]||hungary(bel[y]))\n\t\t\treturn bel[y]=x;\n\treturn 0;\n}\n\nint main()\n{\n\t//freopen(\"flip.in\",\"r\",stdin),freopen(\"flip.out\",\"w\",stdout);\n\tscanf(\"%d\",&n);\n\tfor (int i=1,x;i<=n;++i) scanf(\"%d\",&x),mx=max(mx,x),mark[x]=1;\n\tfor (int i=1;i<=mx+1;++i)\n\t\tif (mark[i]^mark[i-1])\n\t\t\tpos[i&1][++pos[i&1][0]]=i;\n\tfor (int i=1;i<=pos[0][0];++i)\n\t\tfor (int j=1;j<=pos[1][0];++j)\n\t\t{\n\t\t\tint d=iabs(pos[0][i]-pos[1][j]);\n\t\t\tif (is_prime(d)) insert(i,j);\n\t\t}\n\tmatch=0;\n\tfor (int i=1;i<=pos[0][0];++i) memset(vis,0,sizeof vis),match+=hungary(i);\n\tans=match,pos[0][0]-=match,pos[1][0]-=match;\n\tans+=(pos[0][0]&1)+pos[0][0]+pos[1][0];\n\tprintf(\"%d\\n\",ans);\n\t//fclose(stdin),fclose(stdout);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\nll match[maxn], vis[maxn];\n\nll dfs(ll now)\n{\n\tfor(ll to : edge[now])\n\t{\n\t\tif(vis[to]) continue;\n\t\tvis[to] = 1;\n\t\tif(!match[to] || dfs(match[to]))\n\t\t{\n\t\t\tmatch[now] = to, match[to] = now;\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nvoid hungarian()\n{\n\trep(i, 1, tot)\n\t{\n\t\tif(col[i] == 2) continue;\n\t\trep(j, 1, tot) vis[j] = 0;\n\t\tans += dfs(i);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\nconst int maxv=1e7;\nconst int maxn=100;\nint n,cnt_a,cnt_b,tot,cnt;\nint V[maxn+8],a[maxn+8],b[maxn+8],prime[maxv+8],match[maxn+8];\nbool map[maxn+8][maxn+8],vis[maxv+8],inq[maxn+8];\n\nint read()\n{\n    int x=0,f=1;char ch=getchar();\n    for (;ch<'0'||ch>'9';ch=getchar()) if (ch=='-') f=-1;\n    for (;ch>='0'&&ch<='9';ch=getchar()) x=x*10+ch-'0';\n    return x*f;\n}\n\nvoid add(int x){x&1?a[++cnt_a]=x:b[++cnt_b]=x;}\n\nvoid prepare()\n{\n    vis[1]=1;\n    for (int i=2;i<=maxv+1;i++)\n\t{\n\t    if (!vis[i]) prime[++tot]=i;\n\t    for (int j=1;j<=tot&&1ll*prime[j]*i<=maxv+1;j++)\n\t\t{\n\t\t    vis[prime[j]*i]=1;\n\t\t    if (i%prime[j]==0) break;\n\t\t}\n\t}\n}\n\nbool extra(int x)\n{\n    for (int i=1;i<=cnt_b;i++)\n\t{\n\t    if (inq[i]||(map[x][i]==0)) continue;\n\t    inq[i]=1;\n\t    if ((!match[i])||(extra(match[i])))\n\t\t{\n\t\t    match[i]=x;\n\t\t    return 1;\n\t\t}\n\t}\n    return 0;\n}\n\nvoid solve()\n{\n    int ans=0,rest_a=cnt_a,rest_b=cnt_b;\n    for (int i=1;i<=cnt_a;i++)\n\t{\n\t    memset(inq,0,sizeof(inq));\n\t    if (extra(i)) ans++;\n\t}\n    for (int i=1;i<=cnt_b;i++) if (match[i]) rest_a--,rest_b--;\n    ans+=rest_a+rest_b+(rest_a&1);\n    printf(\"%d\\n\",ans);\n}\n\nint main()\n{\n    n=read();\n    for (int i=1;i<=n;i++) V[i]=read();\n    sort(V+1,V+n+1);\n    add(V[1]);\n    for (int i=2;i<=n;i++)if (V[i]!=V[i-1]+1) add(V[i-1]+1),add(V[i]);add(V[n]+1);\n    prepare();\n    for (int i=1;i<=cnt_a;i++)\n\tfor (int j=1;j<=cnt_b;j++)\n\t    map[i][j]=!vis[abs(a[i]-b[j])];\n    solve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cstring>\n#include<queue>\n#include<cmath>\nusing namespace std;\nstruct Edge{\n\tint v,c,nxt;\n}e[600010];int tot=1;\nint first[210];\nvoid build(int u,int v,int c)\n{\n\te[++tot]=(Edge){v,c,first[u]};\n\tfirst[u]=tot;\n\treturn ;\n}\nvoid adde(int u,int v,int c)\n{\n\tbuild(u,v,c);\n\tbuild(v,u,c);\n\treturn ;\n}\nint S,T;\nqueue<int>q;\nint dep[210];\nbool bfs()\n{\n\tmemset(dep,0,sizeof(dep));\n\tdep[S]=1;q.push(S);\n\twhile(!q.empty())\n\t{\n\t\tint u=q.front();q.pop();\n\t\tfor(int i=first[u];i;i=e[i].nxt)\n\t\t\tif(e[i].c&&!dep[e[i].v])\n\t\t\t{\n\t\t\t\tdep[e[i].v]=dep[u]+1;\n\t\t\t\tq.push(e[i].v);\n\t\t\t}\n\t}\n\treturn dep[T]>0;\n}\nint cur[210];\nint dfs(int u,int flow)\n{\n\tif(u==T)return flow;\n\tfor(int &i=cur[u];i;i=e[i].nxt)\n\t\tif(e[i].c&&dep[u]+1==dep[e[i].v])\n\t\t{\n\t\t\tint d=dfs(e[i].v,min(flow,e[i].c));\n\t\t\tif(d){\n\t\t\t\te[i].c-=d;\n\t\t\t\te[i^1].c+=d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\treturn 0;\n}\nint dinic()\n{\n\tint ans=0;\n\twhile(bfs()){\n\t\tfor(int i=S;i<=T;i++)\n\t\t\tcur[i]=first[i];\n\t\tint d;\n\t\twhile(d=dfs(S,1e9))\n\t\t\tans+=d;\n\t}\n\treturn ans;\n}\nbool check(int a)\n{\n\tif(a<=2)return false;\n\tfor(int i=2;i*i<=a;i++)\n\t\tif(a%i==0)return false;\n\treturn true;\n}\nint x[210];\nint vis[10000010];\nint main()\n{\n\tint n;scanf(\"%d\",&n);\n\tint N=0;\n\tint mx=0;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint a;scanf(\"%d\",&a);\n\t\tvis[a]=1;mx=max(mx,a);\n\t}\n\tfor(int i=1;i<=mx+1;i++)\n\t\tif(vis[i]!=vis[i-1])\n\t\t\tx[++N]=i;\n\tS=0;T=N+1;\n\tint cntx=0,cnty=0;\n\tfor(int i=1;i<=N;i++)\n\t\tif(x[i]&1){\n\t\t\tadde(S,i,1);\n\t\t\tcntx++;\n\t\t}\n\t\telse{\n\t\t\tadde(i,T,1);\n\t\t\tcnty++;\n\t\t}\n\tfor(int i=1;i<=N;i++)\n\t\tif(x[i]&1){\n\t\t\tfor(int j=1;j<=N;j++)\n\t\t\t\tif(check(abs(x[i]-x[j])))\n\t\t\t\t\tadde(i,j,1);\n\t\t}\n\tint res=dinic();\n\tint ans=res+(cntx-res)/2*2+(cnty-res)/2*2+((cntx-res)&1)*3;\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define db double\n#define inf 10000001\n#define infm 50001\n#define INF (int)1e8 \n#define mod (int)(1e9+7)\n#define pi acos(-1)\n#define rd(n) {n=0;char ch;int f=0;do{ch=getchar();if(ch=='-'){f=1;}}while(ch<'0'||ch>'9');while('0'<=ch&&ch<='9'){n=(n<<1)+(n<<3)+ch-48;ch=getchar();}if(f)n=-n;}\nusing namespace std;\n\nint p[inf],ckp[inf],pcnt;\nconst int lim=10000000;\n\nvoid pre_work(void){\n    ckp[0]=ckp[1]=1;\n    for (int i=2;i<=lim;i++){\n        if (!ckp[i]){\n            p[++pcnt]=i;\n        }\n        for (int j=1;j<=pcnt && p[j]*i<=lim;j++){\n            ckp[p[j]*i]=1;\n            if (i%p[j]==0){\n                break;\n            }\n        }\n    }\n    return;\n}\n\nint S,T;\n\nstruct edge{\n    int nxt,y,s;\n}e[infm*2];\nint ecnt=1,head[infm],h[infm];\n\nvoid addedge(int x,int y,int s){\n    ecnt++;\n    e[ecnt].nxt=head[x];\n    e[ecnt].y=y;\n    e[ecnt].s=s;\n    head[x]=ecnt;\n    return;\n}\n\nvoid ae(int x,int y,int s){\n    addedge(x,y,s);\n    addedge(y,x,0);\n    return;\n}\n\nqueue <int> q;\nint dep[inf];\n\nint dfs(int u,int flow){\n    if (!flow || u==T){\n        return flow;\n    }\n    int ans=0;\n    for (int i=h[u];i;i=e[i].nxt){\n        h[u]=i;\n        int v=e[i].y,s=e[i].s,now;\n        if (dep[v]!=dep[u]+1){\n            continue;\n        }\n        now=dfs(v,min(flow,s));\n        if (now){\n            ans+=now;\n            flow-=now;\n            e[i].s-=now;\n            e[i^1].s+=now;\n            if (!flow){\n                break;\n            }\n        }\n    }\n    return ans;\n}\n\nint dinic(void){\n    int ans=0;\n    while (1){\n        while (!q.empty()){\n            q.pop();\n        }\n        memcpy(h,head,sizeof(head));\n        memset(dep,-1,sizeof(dep));\n        dep[S]=0;\n        q.push(S);\n        while (!q.empty()){\n            int u=q.front(),v,s;\n            q.pop();\n            for (int i=head[u];i;i=e[i].nxt){\n                v=e[i].y,s=e[i].s;\n                if (dep[v]<0 && s){\n                    dep[v]=dep[u]+1;\n                    q.push(v);\n                }\n            }\n        }\n        if (dep[T]<0){\n            break;\n        }\n        ans+=dfs(S,INF);\n    }\n    return ans;\n}\n\nint n;\nint a[inf];\nint L[inf],R[inf];\n\nint main(){\n    pre_work();\n    rd(n)\n    int x,mx=0;\n    for (int i=1;i<=n;i++){\n        rd(x)\n        a[x]++;\n        mx=max(mx,x);\n    }\n    int cntl=0,cntr=0;\n    for (int i=1;i<=mx+1;i++){\n        if (a[i]!=a[i-1]){\n            if (i&1){\n                L[++cntl]=i;\n            }\n            else{\n                R[++cntr]=i;\n            }\n        }\n    }\n    S=0,T=cntl+cntr+1;\n    for (int i=1;i<=cntl;i++){\n        ae(S,i,1);\n    }\n    for (int i=1;i<=cntr;i++){\n        ae(i+cntl,T,1);\n    }\n    for (int i=1;i<=cntl;i++){\n        for (int j=1;j<=cntr;j++){\n            if (!ckp[abs(L[i]-R[j])]){\n                ae(i,j+cntl,1);\n            }\n        }\n    }\n    int mxf=dinic();\n    int ans=mxf;\n    ans+=(cntl-mxf)/2*2+(cntr-mxf)/2*2;\n    ans+=((cntl-mxf)&1)*3;\n    printf(\"%d\\n\",ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <bitset>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio>\n#include <cstring>\n#include <climits>\n#include <string.h>\n#include <stdio.h>\n#define LL long long\n#define all(x) (x).begin(),(x).end()\n#define pii pair<int,int>\n#define piii pair<int, pii >\n#define REP(i,n) for (int (i)=0;(i)<(n);(i)++)\n#define vi vector<int>\n#define vpi vector< pii >\n#define INF 2147483647\n#define big 19260817\n#define pb push_back\n#define mp make_pair\nusing namespace std;\nconst int Maxk=1005;\nstring mul(string a,string b){\n\tint res[Maxk];\n\tmemset(res,0,sizeof(res));\n\treverse(a.begin(),a.end());\n\treverse(b.begin(),b.end());\n\tfor (int i=0;i<a.length();i++){\n\t\tfor (int j=0;j<b.length();j++){\n\t\t\tres[i+j]+=(a[i]-'0')*(b[j]-'0');\n\t\t}\n\t}\n\tfor (int i=0;i<Maxk;i++){\n\t\tif (res[i]>=10) {\n\t\t\tres[i+1]+=(res[i]/10);\n\t\t\tres[i]%=10;\n\t\t}\n\t}\n\tstring ret;\n\tbool flag=false;\n\tfor (int i=Maxk-1;i>=0;i--){\n\t\tif (flag || res[i]){\n\t\t\tflag=true;\n\t\t\tret=ret+(char)(res[i]+'0');\n\t\t}\n\t}\n\tif (ret==\"\") ret=\"0\";\n\treturn ret;\n}\nstring add(string a,string b){\n\tif (a.length()<b.length()) swap(a,b);\n\twhile (a.length()!=b.length()){\n\t\tb='0'+b;\n\t}\n\tfor (int i=a.length()-1;i>=0;i--){\n\t\ta[i]+=(b[i]-'0');\n\t\tif (a[i]>'9' && i){\n\t\t\ta[i]-=10;\n\t\t\ta[i-1]++;\n\t\t}\n\t}\n\tif (a[0]>'9'){\n\t\ta[0]-=10;\n\t\ta='1'+a;\n\t}\n\treturn a;\n}\n\n// cf IO: I64d\n// atcoder IO: ｌｌｄ\ninline int read()\n{\n\tint x = 0, f = 1; char ch = getchar();\n\twhile (ch < '0' || ch > '9') { if (ch == '-') f = -1; ch = getchar(); }\n\twhile (ch >= '0' && ch <= '9') { x = x * 10 + ch - '0'; ch = getchar(); }\n\treturn x * f;\n}\nconst int Maxn=305;\nconst int Maxm=1e7+5;\nint cnt;\nint pos[Maxn],len[Maxn];\nint dp[Maxn][Maxn][2];\nbool isp[Maxm];\nvoid _init(){\n\tmemset(isp,true,sizeof(isp));\n\tisp[1]=isp[0]=false;\n\tfor (int i=2;i<Maxm;i++){\n\t\tif (isp[i]){\n\t\t\tfor (int j=i+i;j<Maxm;j+=i){\n\t\t\t\tisp[j]=false;\n\t\t\t}\n\t\t}\n\t}\n}\nint cost(int len){\n\tif (!len) return 0;\n\tif (len%2==0) return 2;\n\tif (isp[len]) return 1;\n\treturn 3;\n}\nint main(){\n\t_init();//cerr<<123<<endl;\n\tint n;\n\tscanf(\"%d\",&n);\n\tfor (int i=0;i<n;i++){\n\t\tscanf(\"%d\",&pos[i]);\n\t}\n\tint sum=1;\n\tfor (int i=1;i<n;i++){\n\t\tif (pos[i]==pos[i-1]+1) sum++;\n\t\telse{\n\t\t\tlen[++cnt]=sum;\n\t\t\tlen[++cnt]=pos[i]-pos[i-1]-1;\n\t\t\tsum=1;\n\t\t}\n\t}\n\tlen[++cnt]=sum;\n\tfor (int i=1;i<=cnt;i++){\n\t\tif (i%2==0)dp[i][i][0]=0;\n\t\telse dp[i][i][1]=0;\n\t\tif (i%2==0)dp[i][i][1]=cost(len[i]);\n\t\telse dp[i][i][0]=cost(len[i]);\n\t}\n\t//cout<<cnt<<endl;\n\tfor (int Len=2;Len<=cnt;Len++){\n\t\tfor (int i=1;i<=cnt;i++){\n\t\t\tint j=i+Len-1;\n\t\t\tif (j>cnt) continue;\n\t\t\tint totlen=0;\n\t\t\tfor (int k=i;k<=j;k++) totlen+=len[k];\n\t\t\tfor (int f=0;f<2;f++){\n\t\t\t\tdp[i][j][f]=1e9;\n\t\t\t\tfor (int k=i+1;k<=j;k++){\n\t\t\t\t\t// i~k-1 k~j\n\t\t\t\t\tdp[i][j][f]=min(dp[i][j][f],dp[i][k-1][f]+dp[k][j][f]);\n\t\t\t\t}\n\t\t\t}\n\t\t\t//cout<<i<<' '<<j<<' '<<totlen<<' '<<cost(totlen)<<' '<<dp[i][j][0]<<' '<<dp[i][j][1]<<endl;\n\t\t\tif (dp[i][j][0]>dp[i][j][1]){\n\t\t\t\tdp[i][j][0]=min(dp[i][j][0],dp[i][j][1]+cost(totlen));\n\t\t\t\t\n\t\t\t}\n\t\t\telse{\n\t\t\t\tdp[i][j][1]=min(dp[i][j][1],dp[i][j][0]+cost(totlen));\n\t\t\t}\n\t\t\t\n\t\t}\n\t}\n//\tcout<<dp[1][1][1]<<' '<<dp[2][4][1]<<endl;\n\tprintf(\"%d\\n\",dp[1][cnt][0]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ninline int read(){int x=0,f=1;char ch=getchar();while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}return x*f;}\n\nconst int maxn = 100 + 15;\nconst int Maxsz = 2e7;\nconst int inf = 1e9 + 7;\n\nint Dp[maxn][maxn] , n , x[maxn] , Prime[Maxsz + 1] , Primelen , Vis[Maxsz + 1];\n\nvoid Init(){\n\tfor(int i = 2 ; i <= Maxsz ; ++ i){\n\t\tif( !Vis[i] )\n\t\t\tPrime[Primelen ++] = i;\n\t\tfor(int j = 0 ; j < Primelen && Prime[j] * i <= Maxsz ; ++ j){\n\t\t\tVis[i * Prime[j]] = 1;\n\t\t\tif( i % Prime[j] == 0 ) break;\n\t\t}\n\t}\n}\n\nint Dfs( int l , int r ){\n\tif( ~Dp[l][r] ) return Dp[l][r];\n\tint & ans = Dp[l][r] = inf;\n\tif( l > r ) return ans = 0;\n\tif( l == r ) return ans = 3;\n\tint ret = 0;\n\tfor(int i = l + 1 ; i <= r ; ++ i){\n\t\tif( x[i] - x[i - 1] - 1 == 0 ) ret += 0;\n\t\telse if( x[i] - x[i - 1] - 1 == 1 ) ret += 3;\n\t\telse if( x[i] - x[i - 1] - 1 == 2 ) ret += 2;\n\t\telse if( Vis[ x[i] - x[i - 1] - 1 ] == 0 ) ret += 1;\n\t\telse ret += 2;\n\t}\n\tint length = x[r] - x[l] + 1;\n\tif( length == 2 ) ret += 2;\n\telse if( Vis[length] == 0 ) ret += 1;\n\telse if( length & 1 ) ret += 3;\n\telse ret += 2;\n\tfor(int i = l ; i <= r ; ++ i)\n\t\tfor(int j = i ; j <= r ; ++ j)\n\t\t\tans = min( ans , Dfs( l , i - 1 ) + Dfs( i , j ) + Dfs( j + 1 , r ) );\n\treturn ans = min( ans , ret );\n}\n\nint main( int argc , char * argv[] ){\n\tInit();\n\tn = read();\n\tfor(int i = 1 ; i <= n ; ++ i)\n\t\tx[i] = read();\n\tmemset( Dp , -1 , sizeof( Dp ) );\n\tprintf( \"%d\\n\" , Dfs( 1 , n ) );\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int N=110;\nint n,lL[N],lR[N],mL[N],mR[N],vis[N],g[N][N],ans,nl,nr;\nset<int>L,R;\nbool is_prime(int x){\n\tif(x==1)return 0;\n\tfor(int i=2;i*i<=x;++i)if(x%i==0)return 0;\n\treturn 1;\n}\n\nvoid ins(int x){\n\tif(x&1){if(L.count(x))L.erase(x);else L.insert(x);}\n\telse{if(R.count(x))R.erase(x);else R.insert(x);}\n}\n\nint dfs(int x){\n\tfor(int i=1;i<=nr;++i)if(!vis[i]&&g[x][i]){\n\t\tvis[i]=1;\n\t\tif(!mL[i]||dfs(mL[i])){mL[i]=x;mR[x]=i;return 1;}\n\t}\n\treturn 0;\n}\n\nint main(){\n\tios::sync_with_stdio(0);cin.tie(0);cout.tie(0);\n\tcin>>n;\n\tfor(int i=1;i<=n;++i){int x;cin>>x;ins(x);ins(x+1);}\n\tfor(int i:L)lL[++nl]=i;for(int i:R)lR[++nr]=i;\n\tfor(int i=1;i<=nl;++i)\n\t\tfor(int j=1;j<=nr;++j)\n\t\t\tg[i][j]=is_prime(abs(lL[i]-lR[j]));\n\tfor(int i=1;i<=nl;++i)if(!mR[i]){\n\t\tmemset(vis,0,sizeof vis);\n\t\tif(dfs(i))++ans;\n\t}\n\tnl-=ans;nr-=ans;\n\tans+=nl/2*2+nr/2*2;\n\tnl%=2;nr%=2;\n\tassert(nl==nr);\n\tans+=nl*3;\n\tcout<<ans<<'\\n';\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nconst int N=1005,INF=~0u>>2;\nstruct Edge{int nxt,to;}edge[N*N];\nint b[N],n,head[N],num_edge,vis[N],lk[N],even[N],odd[N],even_num,odd_num,ans,k,tot,tim;\nint abs(int x){return x>0?x:-x;}\nint read(){\n\tint x=0,f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-') f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn f*x;\n}\nvoid add_edge(int from,int to){\n\tedge[++num_edge].nxt=head[from];\n\tedge[num_edge].to=to;\n\thead[from]=num_edge;\n}\nbool find(int x){\n\tfor(int i=head[x];i;i=edge[i].nxt){\n\t\tif(vis[edge[i].to]!=tim){\n\t\t\tvis[edge[i].to]=tim;\n\t\t\tif(!lk[edge[i].to]||find(edge[i].to)){\n\t\t\t\tlk[edge[i].to]=x;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nbool check(int x){\n\tif(x==1) return 0;\n\tfor(int i=2;i*i<=x;++i){\n\t\tif(x%i==0) return 0;\n\t}\n\treturn 1;\n}\nvoid solve(int x){\n\tif(x&1) odd[++odd_num]=x;\n\telse even[++even_num]=x;\n}\nint main(){\n//\tfreopen(\"ex.in\",\"r\",stdin);\n\tn=read();\n\tfor(int i=1;i<=n;++i) b[i]=read();b[0]=-1;\n\tfor(int i=1;i<=n;++i){\n\t\tif(b[i]!=b[i-1]+1) solve(b[i]);\n\t\tif(b[i]+1!=b[i+1]) solve(b[i]+1);\n\t}\n\tfor(int i=1;i<=odd_num;++i){\n\t\tfor(int j=1;j<=even_num;++j){\n\t\t\tif(check(abs(even[j]-odd[i]))) add_edge(i,j+odd_num);\n\t\t}\n\t}\n\tfor(int i=1;i<=odd_num;++i){\n\t\ttim++;\n\t\tif(find(i)) k++;\n\t}\n\tans=k+((even_num-k)/2+(odd_num-k)/2)*2+((odd_num-k)%2)*3;\n\tprintf(\"%d\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "     #include <bits/stdc++.h>\n\n//    #include <boost/multiprecision/cpp_int.hpp>\n #define int long long\n #define inf  1000000007\n #define pa pair<int,int>\n #define ll long long\n #define pal pair<double,double>\n #define ppap pair<pa,int>\n  #define PI 3.14159265358979323846\n  #define paa pair<int,char>\n  #define  mp make_pair\n  #define  pb push_back\n  #define EPS (1e-10)\n                                          \n    int dx[8]={0,1,0,-1,1,1,-1,-1};\n    int dy[8]={1,0,-1,0,-1,1,1,-1};\n                                            using namespace std;\n                                   \t\t\tclass pa3{\n                                            \tpublic:\n                                            \tint x;\n                                   \t\t\t\tint y,z;\n                                            \tpa3(int x=0,int y=0,int z=0):x(x),y(y),z(z) {}\n                                            \tbool operator < (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\t return z<p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                   \t\t\t\tbool operator > (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\t return z>p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa3 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z;\n                                            \t}\n                                            \t\tbool operator != (const pa3 &p) const{\n                                            \t\t\treturn !( x==p.x && y==p.y && z==p.z);\n                                            \t}\n                                            \n                                            };\n                                            \n                                            class pa4{\n                                            \tpublic:\n                                            \tint x;\n                                            \tint y,z,w;\n                                            \tpa4(int x=0,int y=0,int z=0,int w=0):x(x),y(y),z(z),w(w) {}\n                                            \tbool operator < (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\tif(z!=p.z)return z<p.z;\n                                            \t\treturn w<p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator > (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\tif(z!=p.z)return z>p.z;\n                                            \t\treturn w>p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa4 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z &&w==p.w;\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            class pa2{\n                                            \tpublic:\n                                            \tint x,y;\n                                            \tpa2(int x=0,int y=0):x(x),y(y) {}\n                                            \tpa2 operator + (pa2 p) {return pa2(x+p.x,y+p.y);}\n                                            \tpa2 operator - (pa2 p) {return pa2(x-p.x,y-p.y);}\n                                            \tbool operator < (const pa2 &p) const{\n                                            \t\treturn y != p.y ? y<p.y: x<p.x;\n                                            \t}\n                                            \tbool operator > (const pa2 &p) const{\n                                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa2 &p) const{\n                                            \t\treturn abs(x-p.x)==0 && abs(y-p.y)==0;\n                                            \t}\n                                            \tbool operator != (const pa2 &p) const{\n                                            \t\treturn !(abs(x-p.x)==0 && abs(y-p.y)==0);\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            \n/*\n                                            class Point{\n                                            \tpublic:\n                                            \tdouble x,y;\n                                            \tPoint(double x=0,double y=0):x(x),y(y) {}\n                                            \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                                            \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                                            \tPoint operator * (double a) {return Point(x*a,y*a);}\n                                            \tPoint operator / (double a) {return Point(x/a,y/a);}\n                                            \tdouble absv() {return sqrt(norm());}\n                                            \tdouble norm() {return x*x+y*y;}\n                                            \tbool operator < (const Point &p) const{\n                                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const Point &p) const{\n                                            \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                                            \t}\n                                            };\n                                            typedef Point Vector;\n                                     #define pl pair<int,pas>\n                                            struct Segment{\n                                            Point p1,p2;\n                                            };\n                                             double dot(Vector a,Vector b){\n                                            \treturn a.x*b.x+a.y*b.y;\n                                            }\n                                            double cross(Vector a,Vector b){\n                                            \treturn a.x*b.y-a.y*b.x;\n                                            }\n                                        \n                bool parareru(Point a,Point b,Point c,Point d){\n                //\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n                \treturn abs(cross(a-b,d-c))<EPS;\n                }\n                double distance_ls_p(Point a, Point b, Point c) {\n                  if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n                  if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n                  return abs(cross(b-a, c-a)) / (b-a).absv();\n                }\n                bool is_intersected_ls(Segment a,Segment b) {\n                \tif(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n                \tif(parareru((a.p2),(a.p1),(a.p1),(b.p2))&&parareru((a.p2),(a.p1),(a.p1),(b.p1))){\n                //\t\tcout<<\"sss\"<<endl;\n                \t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n                \t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n                \t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n                \t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n                \t\treturn false;\n                \t}\n                  else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n                }\n                 \n                double segment_dis(Segment a,Segment b){\n                \tif(is_intersected_ls(a,b))return 0;\n                \tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n                \tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n                \tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n                \tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n                \treturn r;\n                }\n                Point intersection_ls(Segment a, Segment b) {\n                  Point ba = b.p2-b.p1;\n                  double d1 = abs(cross(ba, a.p1-b.p1));\n                  double d2 = abs(cross(ba, a.p2-b.p1));\n                  double t = d1 / (d1 + d2);\n                 \n                  return a.p1 + (a.p2-a.p1) * t;\n                }\n */                \n                                string itos( int i ) {\n                                ostringstream s ;\n                                s << i ;\n                                return s.str() ;\n                                }\n                                 \n                                int gcd(int v,int b){\n                                \tif(v>b) return gcd(b,v);\n                                \tif(v==b) return b;\n                                \tif(b%v==0) return v;\n                                \treturn gcd(v,b%v);\n                                }\n                 \n                                double distans(double x1,double y1,double x2,double y2){\n                                \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                                \treturn sqrt(rr);\n                                \t\n                                }\n                                int mod;\nint extgcd(int a, int b, int &x, int &y) {\n    if (b == 0) {\n        x = 1;\n        y = 0;\n        return a;\n    }\n    int d = extgcd(b, a%b, y, x);\n    y -= a/b * x;\n    return d;\n}\npa operator+(const pa & l,const pa & r) {   \n    return {l.first+r.first,l.second+r.second};                                    \n}    \n                                \n                int pr[1000010];\n                int inv[1000010];\n                \n                int beki(int wa,int rr,int warukazu){\n                \tif(rr==0) return 1%warukazu;\n                \tif(rr==1) return wa%warukazu;\n                \twa%=warukazu;\n                \tif(rr%2==1) return ((ll)beki(wa,rr-1,warukazu)*(ll)wa)%warukazu;\n                \tll zx=beki(wa,rr/2,warukazu);\n                \treturn (zx*zx)%warukazu;\n                }\n    double bekid(double w,int r){\n    \tif(r==0) return 1.0;\n    \tif(r==1) return w;\n    \tif(r%2) return bekid(w,r-1)*w;\n    \tdouble f=bekid(w,r/2);\n    \treturn f*f;\n    }\n                \n    \t\t\tint comb(int nn,int rr){\n    \t\t\t\tint r=pr[nn]*inv[rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\tr*=inv[nn-rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\treturn r;\n    \t\t\t}\n                \n                void gya(int ert){\n                \tpr[0]=1;\n                \tfor(int i=1;i<ert;i++){\n                \t\tpr[i]=(pr[i-1]*i)%mod;\n                \t}\n                \tfor(int i=0;i<ert;i++) inv[i]=beki(pr[i],mod-2,mod);\n                \t\n                }\n                \n              //   cin.tie(0);\n    \t\t//\tios::sync_with_stdio(false);\n    \t\t\t//priority_queue<pa3,vector<pa3>,greater<pa3>> pq;            \n                 //sort(ve.begin(),ve.end(),greater<int>());\n    \n                                     //----------------kokomade tenpure------------\ntypedef pair<int,int> P;\nstruct edge{ int to,cap,cost,rev;};\nvector<int> G[100010];\nbool used[100010];\nint match[100010];\nint V;//Vは頂点数\n\nvoid add_edge(int u,int v){\nG[u].push_back(v);\nG[v].push_back(u);\n}\n\nbool ddffss(int v){\nused[v]=true;\n  for(int i=0;i<G[v].size();i++){\n    int u=G[v][i],w=match[u];\n    if(w<0 || !used[w] &&ddffss(w)){\n      match[v]=u;\n      match[u]=v;\n      return true;\n    }\n  }\n  return false;\n}\n\nint bi_match(){\n  int res=0;\n  memset(match,-1,sizeof(match));\n  for(int v=0;v<V;v++){\n    if(match[v]<0){\n      memset(used,0,sizeof(used));\n      if(ddffss(v)){\n        res++;\n      }\n    }\n  }\n  return res;\n}\nbool so[10010002];\n\n signed main(){\n\n    \t       cin.tie(0);\n   \t\t\tios::sync_with_stdio(false);\n\n \tint n;\n \tcin>>n;\nmap<int,int>ma;\n \tfor(int i=0;i<n;i++){\n \t\tint y;\n \t\tcin>>y;\n \t\tma[y]++;\n \t\tma[y+1]++;\n \t}\n \tvector<int> gu,ki;\n \tfor(auto it=ma.begin();it!=ma.end();it++){\n \t\tif(it->second%2==0) continue;\n \t\tif(it->first%2)ki.pb(it->first);\n \t\telse gu.pb(it->first);\n \t}\n \tso[1]=1;\n \tfor(int i=2;i<=10000010;i++)if(so[i]==0){\n \t\tfor(int j=2*i;j<=10000010;j+=i)so[j]=1;\n \t}\n \tV=400;\n \tint t0=gu.size();\n \tint t1=ki.size();\n \t\n \tfor(int i=0;i<t0;i++)for(int j=0;j<t1;j++){\n \t\tif(!so[abs(ki[j]-gu[i])])add_edge(i,t0+j);\n \t}\n \tint r=bi_match();\n \t\n \tint nokori0=t0-r;\n \tint nokori1=t1-r;\n \t\n \tassert(nokori0%2 == nokori1%2);\n \t\n \tif(nokori0%2==0){\n \t\tcout<<r+(nokori0+nokori1)<<endl;\n \t\treturn 0;\n \t}\n \telse{\n \t\tint ans=(nokori0/2+nokori1/2)*2+3+r;\n \t\tcout<<ans<<endl;\n \t}\n \treturn 0;\n  }\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 10000001;\n\n\nint n,fre[maxn],p[220],isprime[maxn],even,odd,wrong;\nvector <int> edge[220],v2;\n\nbool fin(int u) {\n    if (fre[u]=wrong) return false;\n    fre[u]=wrong;\n    for (int j=0;j<edge[u].size();j++) {\n        int v=edge[u][j];\n        if (p[v]=0 || fin(p[v])) {\n            p[u]=v;\n            p[v]=u;\n            return true;\n        }\n    }\n    return false;\n}\n\nint main() {\n   // freopen(\"in.txt\",\"r\",stdin);\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    isprime[1]=1;\n    for (int i=2;i<=maxn;i++)\n        if (isprime[i]==0) {\n            for (int j=i+i;j<=maxn;j+=i) isprime[j]=1;\n        }\n    cin>>n;\n    for (int i=1;i<=n;i++) {\n        int x;\n        cin>>x;\n        fre[x]=1;\n    }\n    even=0; odd=0; wrong=2;\n    int id=1;\n    while (id<=maxn) {\n        if (fre[id]==0) id++;\n        else if (fre[id]==1) {\n            v2.push_back(id);\n            if (id%2==0) even++; else odd++ ;\n            id++;\n            while (id<=maxn && fre[id]==1) id++;\n            v2.push_back(id);\n            if (id%2==0) even++; else odd++ ;\n        }\n    }\n    // for (int i=0;i<v2.size();i++) cout<<v2[i]<<\" \";\n   //  cout<<endl;\n   // cout<<\" \" <<even<<\" \"<<odd<<endl;\n    for (int i=0;i<v2.size();i++)\n        for (int j=i+1;j<v2.size();j++)\n            if (isprime[ v2[j] - v2[i] ]==0) {\n               // cout<<i<<\" \"<<j<<endl;\n                edge[i+1].push_back(j+1);\n                edge[j+1].push_back(i+1);\n            }\n    int cnt=0;\n    for (int i=0;i<v2.size();i++) {\n        wrong++;\n        cnt+=(fin(i));\n    }\n   // cout<<cnt<<\" \" <<even<<\" \"<<odd<<endl;\n    cout<< cnt + ((even-cnt)/2 + (odd-cnt)/2) * 2 + (even%2)*3;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define x first\n#define y second\n#define mp make_pair\n#define all(a) a.begin(), a.end()\n#define pub push_back\n#define ll long long\n\t\t\t\t\t  \nusing namespace std;\n\nint n;\nint a[111];\nbool prime[10000007];\nvector<int> g[222];\nint dx[222], dy[222];\n\nbool wasIn(int x){\n\tfor (int i = 0; i < n; i++) if (a[i] == x) return 1;\n\treturn 0;\n}\n\nbool check(int x){\n\treturn wasIn(x) != wasIn(x + 1);\n}\n\nbool was[222];\nbool dfs(int v){\n\tif (was[v]) return 0;\n\twas[v] = 1;\n\tfor (int to : g[v]){\n\t\tif (dy[to] == -1){\n\t\t\tdx[v] = to;\n\t\t\tdy[to] = v;\n\t\t\treturn 1;\n\t\t}\n\t\tif (dfs(dy[to])){\n\t\t\tdx[v] = to;\n\t\t\tdy[to] = v;\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0; \n}\n\nint main(){\n\t//freopen(\"input.txt\", \"r\", stdin);\n\t//freopen(\"output.txt\", \"w\", stdout);\n\t//freopen(\"seating.in\", \"r\", stdin);\n\t//freopen(\"seating.out\", \"w\", stdout);\n\tfor (int i = 2; i < 10000007; i++){\n\t\tif (!prime[i]){\t\n\t\t\tfor (int j = 2 * i; j < 10000007; j += i) prime[j] = 1;\n\t\t}\n\t}\n\n\tprime[2] = 1;\n\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) cin >> a[i];\n\n\tvector<int> q, s, t;\n\tfor (int i = 0; i < n; i++){\n\t\tif (check(a[i] - 1)) q.pub(a[i] - 1);\n\t\tif (check(a[i])) q.pub(a[i]);\n\t}\n\n\tfor (int x : q) if (x % 2 == 0) s.pub(x); else t.pub(x);\n\n\tfor (int i = 0; i < s.size(); i++) for (int j = 0; j < t.size(); j++) if (!prime[abs(s[i] - t[j])]){\n\t\tg[i].pub(j);\n\t}\t\n\n\tfor (int i = 0; i < 222; i++) dx[i] = -1, dy[i] = -1;\n\n\tfor (int run = 1; run; ){\n\t\trun = 0;\n\t\tmemset(was, 0, sizeof(was));\n\t\tfor (int i = 0; i < s.size(); i++) if (dx[i] == -1 && dfs(i)) run = 1;\n\t}\n\n\tint dd = 0;\n\n\tfor (int i = 0; i < s.size(); i++) if (dx[i] != -1) dd++;\n\n\tint ans = (int)s.size() + (int)t.size() - dd;\n\n\tif (((int)s.size() - dd) % 2 == 1) ans++;\n\n\tcout << ans;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <cmath>\n#include <cstdlib>\n#include <vector>\n#include <set>\n#include <map>\n#include <cassert>\n#include <queue>\n#include <ctime>\n#include <string>\n#include <cstring>\n#include <random>\n#define mp make_pair\n#define pb push_back\n#define NAME \"\"\n#define y1 y1_423\n#define list lista\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\n\ntemplate<typename T>\nostream& operator << (ostream& cout, const vector<T> &a) {\n\tif ((int)a.size() == 0) {\n\t\treturn (cout << \"()\");\n\t}\n\tcout << \"(\" << a[0];\n\tfor (int i = 1; i < (int)a.size(); i++) {\n\t\tcout << \"; \" << a[i];\n\t}\n\treturn (cout << \")\");\n}\n\ntemplate<typename T>\nostream& operator << (ostream& cout, const set<T> &a) {\n\tif ((int)a.size() == 0) {\n\t\treturn (cout << \"{}\");\n\t}\n\tauto it = a.begin();\n\tcout << \"{\" << *it;\n\t++it;\n\tfor (; it != a.end(); ++it) {\n\t\tcout << \"; \" << *it;\n\t}\n\treturn (cout << \"}\");\n}\n\ntemplate<typename T>\nostream& operator << (ostream& cout, const multiset<T> &a) {\n\tif ((int)a.size() == 0) {\n\t\treturn (cout << \"{}\");\n\t}\n\tauto it = a.begin();\n\tcout << \"{\" << *it;\n\t++it;\n\tfor (; it != a.end(); ++it) {\n\t\tcout << \"; \" << *it;\n\t}\n\treturn (cout << \"}\");\n}\n\ntemplate<typename T1, typename T2>\nostream& operator << (ostream& cout, const pair<T1, T2> &a) {\n\treturn cout << \"(\" << a.first << \"; \" << a.second << \")\";\n}\n\nrandom_device gen;\nmt19937 rnd(gen());\n\nconst int nmax = 1000 * 1000 * 10 + 10;\nconst int inf = 2000 * 1000 * 1000;\nconst ll infl = 1000ll * 1000ll * 1000ll * 1000ll * 1000ll * 1000ll;\nconst int mod = 1000 * 1000 * 1000 + 7;\nconst ld pi = acos(-1.0);\n\nbool used[nmax], u[nmax];\nint p[300];\nint b[nmax];\nvector<int> a, go[300];\n\nbool ok(int v) {\n\tif (u[v]) return false;\n\tu[v] = true;\n\tfor (int u : go[v]) {\n\t\tif (p[u] == -1) {\n\t\t\tp[u] = v;\n\t\t\treturn true;\n\t\t}\n\t}\n\tfor (int u : go[v]) {\n\t\tif (ok(u)) {\n\t\t\tp[u] = v;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint main() {\n\t//freopen(\"input.txt\", \"r\", stdin);freopen(\"output.txt\", \"w\", stdout);\n\t//freopen(NAME\".in\", \"r\", stdin);freopen(NAME\".out\", \"w\", stdout);\n\tfor (int i = 2; i < nmax; i++) {\n\t\tused[i] = 1;\n\t}\n\tfor (ll i = 2; i * i < nmax; i++) {\n\t\tif (!used[i]) continue;\n\t\tfor (ll j = i * i; j < nmax; j += i) {\n\t\t\tused[j] = 0;\n\t\t}\n\t}\n\tused[0] = used[1] = used[2] = 0;\n\tint n;\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; i++) {\n\t\tint x;\n\t\tscanf(\"%d\", &x);\n\t\tb[x] ^= 1;\n\t\tb[x + 1] ^= 1;\n\t}\n\tfor (int i = 0; i < nmax; i++) {\n\t\tif (b[i] == 1) {\n\t\t\ta.pb(i);\n\t\t}\n\t}\n\tn = a.size();\n\tassert(n < 300);\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif (i == j) continue;\n\t\t\tif (used[abs(a[i] - a[j])]) {\n\t\t\t\tgo[i].pb(j);\n\t\t\t}\n\t\t}\n\t}\n\tint cnt0 = 0, cnt1 = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (a[i] % 2 == 0) {\n\t\t\tcnt0++;\n\t\t} else {\n\t\t\tcnt1++;\n\t\t}\n\t}\n\tfor (int j = 0; j < n; j++) {\n\t\tp[j] = -1;\n\t}\n\tint answer = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (a[i] % 2 == 0) continue;\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tu[j] = 0;\n\t\t}\n\t\tif (ok(i)) answer++;\n\t}\n\tcout << answer + ((cnt0 - answer) / 2 + (cnt1 - answer) / 2) * 2 + ((cnt1 - answer) % 2) * 3 << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 1e7 + 700;\n\n\nint n,fre[maxn],p[220],ispr[maxn],dd[maxn],even,odd,wrong;\nvector <int> edge[220],v2;\n\nbool fin(int u) {\n    if (fre[u]==wrong) return false;\n    fre[u]=wrong;\n    for (int j=0;j<edge[u].size();j++) {\n        int v=edge[u][j];\n       // cout<<u<<\" \"<<v<<endl;\n        if (p[v]==-1 || fin(p[v])) {\n            p[v]=u;\n            return true;\n        }\n    }\n    return false;\n}\n\nint main() {\n //   freopen(\"in.txt\",\"r\",stdin);\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    ispr[1]=1;\n    for (int i=2;i<maxn;i++)\n        if (ispr[i]==0) {\n            for (int j=i+i;j<maxn;j+=i) ispr[j]=1;\n        }\n    cin>>n;\n    for (int i=1;i<=n;i++) {\n        int x;\n        cin>>x;\n        if (dd[x]==1) continue;\n        dd[x]=1;\n        fre[x]^=1;\n        fre[x+1]^=1;\n    }\n    even=0; odd=0; wrong=2;\n    for (int i=0;i<maxn;i++)\n        if (fre[i]==1) {\n            v2.push_back(i);\n            if (i%2==0) even++;\n            else odd++;\n        }\n    // for (int i=0;i<v2.size();i++) cout<<v2[i]<<\" \";\n   //  cout<<endl;\n    for (int i=0;i<v2.size();i++)\n        for (int j=0;j<v2.size();j++)\n            if (v2[i]%2==0 && v2[j]%2==1 && ispr[ abs(v2[j] - v2[i]) ]==0 && abs(v2[j] - v2[i])%2==1) {\n                edge[i].push_back(j);\n                //cout<<i<<\" \"<<j<<\" \"<<v2[i]<<\" \"<<v2[j]<<endl;\n            }\n    int cnt=0;\n     for (int i=0;i<v2.size();i++) if (v2[i]%2==1) p[i]=-1;\n    for (int i=0;i<v2.size();i++)\n     if (v2[i]%2==0) {\n        wrong++;\n        cnt+=fin(i);\n    }\n  //   cout<<\" \" <<even<<\" \"<<odd<<\" \"<<cnt<<endl;\n    cout<< cnt + (even-cnt)/2 *2 + (odd-cnt)/2 * 2 + (even-cnt)%2*3;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pp;\ntypedef pair<ll,ll> pll;\nvoid read(int& x){ scanf(\"%d\",&x); }\nvoid read(ll& x){ scanf(\"%lld\",&x); }\ntemplate<typename T,typename... Args>\nvoid read(T& a,Args&... b){ read(a); read(b...); }\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define eb emplace_back\n#define x first\n#define y second\n \nint n;\nint p[210];\n \nvoid in(){\n\tint t; read(t);\n\tint last;\n\tread(last);\n\tp[++n] = last;\n\tfor(;--t;){\n\t\tint x; read(x);\nassert(last < x);\n\t\tif(last+1 < x){\n\t\t\tp[++n] = last+1;\n\t\t\tp[++n] = x;\n\t\t}\n\t\tlast = x;\n\t}\n\tp[++n] = last+1;\n}\n \nbool is_prime(int x){\n\tif(x==1) return 0;\n\tif(x==2) return 0;\n\tfor(int i=2; i*i<=x; ++i) if(x%i==0) return 0;\n\treturn 1;\n}\nvector<int>edge[210];\nint vis[210];\nint rev[210];\n \nbool dfs(int x){\n\tif(vis[x]) return 0;\n\tvis[x]=1;\n\tfor(int y:edge[x]){\n\t\tif(!rev[y] || dfs(rev[y])){\n\t\t\trev[y]=x;\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n \nbool aug(){\n\tfor(int i=1; i<=n; ++i){\n\t\tfill(vis+1, vis+n+1, 0);\n\t\tif(dfs(i)) return 1;\n\t}\n\treturn 0;\n}\n \nint main()\n{\n\tin();\nassert(n % 2 == 0);\n\tint oc=0, ec=0;\n\tfor(int i=1; i<=n; ++i){\n\t\t((p[i]%2)?oc:ec)++;\n\t\tfor(int j=i+1; j<=n; ++j){\n\t\t\tif(is_prime(p[j]-p[i])){\n\t\t\t\tint a=i, b=j;\n\t\t\t\tif(p[a]%2) swap(a, b);\nassert(p[a] % 2 != p[b] % 2);\n\t\t\t\tedge[a].pb(b);\n\t\t\t}\n\t\t}\n\t}\n\tint mm = 0;\n\twhile(aug()) ++mm;\nassert(oc %2 == ec %2);\n//assert(mm <= oc);\n//assert(mm <= ec);\n\tint ans = 2e9;\n\tfor(int pu=0; pu<=mm; ++pu){\n\t\tint cur = 0;\n\t\tcur += (oc-pu)/2*2;\n\t\tcur += (ec-pu)/2*2;\n\t\tcur += ((oc-pu)%2)*((ec-pu)%2)*3;\n\t\tcur += pu;\n\t\tans = min(ans, cur);\n\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<cstring>\n#include<cmath>\n#include<cstdlib>\nusing namespace std;\nint n,tot,prime[11000000],nprime[11000000];\nint ans,cnt1,cnt2,s[11000000];\nint a[210],b[210],vis[410],match[410];\nvector<int> vec[410];\nchar Getchar(){\n    static char now[1<<20],*S,*T;\n    if (T==S){\n        T=(S=now)+fread(now,1,1<<20,stdin);\n        if (T==S) return EOF;\n    }\n    return *S++;\n}\nint read(){\n    int x=0,f=1;\n    char ch=Getchar();\n    while (ch<'0'||ch>'9'){\n        if (ch=='-') f=-1;\n        ch=Getchar();\n    }\n    while (ch<='9'&&ch>='0') x=x*10+ch-'0',ch=Getchar();\n    return x*f;\n}\nbool dfs(int x){\n\tint y;\n\tfor (int i=0;i<(int)vec[x].size();i++){\n\t\ty=vec[x][i];\n\t\tif (!vis[y]){\n\t\t\tvis[y]=true;\n\t\t\tif (!match[y]||dfs(match[y])){\n\t\t\t\tmatch[y]=x;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\nint main(){\n\tfor (int i=2;i<=10000001;i++){\n\t\tif (!nprime[i]) prime[++tot]=i;\n\t\tfor (int j=1;j<=tot&&i*prime[j]<=10000001;j++){\n\t\t\tnprime[i*prime[j]]=true;\n\t\t\tif (i%prime[j]==0) break;\n\t\t}\n\t}\n\tn=read(); nprime[1]=1;\n\tfor (int i=1;i<=n;i++) s[read()]=1;\n\tfor (int i=1;i<=10000001;i++)\n\t\tif (s[i]!=s[i-1]){\n\t\t\tif (i&1) a[++cnt1]=i;\n\t\t\telse b[++cnt2]=i;\n\t\t}\n\tfor (int i=1;i<=cnt1;i++)\n\t\tfor (int j=1;j<=cnt2;j++)\n\t\t\tif (!nprime[abs(a[i]-b[j])])\n\t\t\t\tvec[i].push_back(j);\n\tfor (int i=1;i<=cnt1;i++){\n\t\tmemset(vis,false,sizeof(vis));\n\t\tans+=dfs(i);\n\t}\n\tprintf(\"%d\\n\",ans+(cnt1-ans)/2*2+(cnt2-ans)/2*2+((cnt1-ans)&1)*3);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define C\ntypedef long long readtype;\n\n/* Header {{{ */\n#ifdef C\n#include <stdio.h>\n#include <math.h>\n#include <string.h>\n#define isdigit(a) ((a) >= '0' && (a) <= '9' ? true : false)\ntemplate<typename type> type abs(type a) { return a < 0 ? -a : a; }\ntemplate<typename type> type min(type a, type b) { return a < b ? a : b; }\ntemplate<typename type> type beMin(type &a, type b) { return a = (a < b ? a : b); }\ntemplate<typename type> type max(type a, type b) { return a > b ? a : b; }\ntemplate<typename type> type beMax(type &a, type b) { return a = (a > b ? a : b); }\ntemplate<typename type> void swap(type &a, type &b) { type c; c = a; a = b; b = c; }\n#endif\n\n#ifdef Cpp\n#include <bits/stdc++.h>\nusing namespace std;\n#endif\n\ntypedef long long var;\n\nreadtype read() {\n  readtype a = 0, c = getchar(), s = 0;\n  while (!isdigit(c)) s |= c == '-', c = getchar();\n  while (isdigit(c)) a = a * 10 + c - 48, c = getchar();\n  return s ? -a : a;\n}\n/* }}} */\n\nconst int N = 1103;\nconst int X = 1e7 + 100;\nconst int INF = 0x3f3f3f3f;\n\nint n, x[N];\nbool mark[X + 10];\nint cnt, prime[X];\nbool notprime[X + 10];\nint top, fi[N], ne[N * N], to[N * N], fl[N * N];\nint S, T;\nint head, tail, q[N], deep[N];\nint cur[N];\n\nvoid add(int u, int v, int w);\nint Dinic();\nbool BFS();\nint DFS(int t, int f);\n\nint main() {\n  /*\n#ifndef ONLINE_JUDGE\n  freopen(\"arc080d.in\", \"r\", stdin);\n  freopen(\"arc080d.out\", \"w\", stdout);\n#endif\n  */\n  notprime[1] = true;\n  for (int i = 2; i <= X; ++i) {\n    if (!notprime[i]) prime[++cnt] = i;\n    for (int j = 1; j <= cnt; ++j) {\n      if (prime[j] * i > X) break;\n      notprime[prime[j] * i] = true;\n      if (!(i % prime[j])) break;\n    }\n  }\n  for (int i = read(); i >= 1; --i) mark[read()] = true;\n  for (int i = 1; i <= X + 1; ++i) {\n    if (mark[i] ^ mark[i - 1]) x[++n] = i;\n  }\n  S = n + 1, T = n + 2;\n  int oddNum = 0, evenNum = 0;\n  for (int i = 1; i <= n; ++i) {\n    if (!(x[i] % 2)) add(i, T, 1), evenNum++;\n    else add(S, i, 1), oddNum++;\n  }\n  for (int i = 1; i <= n; ++i) {\n    if (!(x[i] % 2)) continue;\n    for (int j = 1; j <= n; ++j) {\n      if (x[j] % 2 || notprime[abs(x[i] - x[j])]) continue;\n      add(i, j, 1);\n      // printf(\"%d %d %d\\n\", x[i], x[j], x[i] - x[j]);\n    }\n  }\n\n  /*\n  for (int i = 1; i <= n; ++i) printf(\"%d \", x[i]);\n  puts(\"\");\n  */\n\n  int k = Dinic();\n  int res = k + ((evenNum - k) / 2) * 2  + ((oddNum - k) / 2) * 2 + ((oddNum - k) % 2) * 3;\n  printf(\"%d\\n\", res);\n  return 0;\n}\n\nvoid add(int u, int v, int w) {\n  ne[++top] = fi[u], fi[u] = top, to[top] = v, fl[top] = w;\n  ne[++top] = fi[v], fi[v] = top, to[top] = u, fl[top] = 0;\n  // printf(\"%d %d %d\\n\", u, v, w);\n}\n\nint Dinic() {\n  int res = 0;\n  while (BFS()) {\n    for (int i = 1; i <= T; ++i) cur[i] = fi[i];\n    res += DFS(S, INF);\n  }\n  return res;\n}\n\nbool BFS() {\n  memset(deep, 0, sizeof(deep));\n  q[head = tail = 1] = S;\n  deep[S] = 1;\n  while (head <= tail) {\n    int f = q[head++];\n    for (int i = fi[f]; i; i = ne[i]) {\n      if (deep[to[i]] || !fl[i]) continue;\n      deep[to[i]] = deep[f] + 1;\n      q[++tail] = to[i];\n    }\n  }\n  return deep[T];\n}\n\nint DFS(int t, int f) {\n  if (t == T) return f;\n  int sumflow = 0;\n  for (int &i = cur[t]; i; i = ne[i]) {\n    if (deep[to[i]] != deep[t] + 1 || !fl[i]) continue;\n    int tflow = DFS(to[i], min(fl[i], f - sumflow));\n    sumflow += tflow;\n    fl[i] -= tflow, fl[i ^ 1] += tflow;\n  }\n  return sumflow;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n//ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n//clock_t start=clock();clock_t end=clock();cout<<(double)(end-start)/CLOCKS_PER_SEC<<endl;\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef unsigned int ui;\ntypedef pair<int,int> pii;\ntypedef pair<pii,int> ppii;\ntypedef pair<int,pii> pipi;\ntypedef pair<ll,ll> pll;\ntypedef pair<pll,ll> ppll;\ntypedef pair<ll,pll> plpl;\ntypedef tuple<ll,ll,ll> tl;\ntypedef pair<double,double> pdd;\ntypedef vector<vector<ll>> mat;\nll mod=1000000007;\nll mod2=998244353;\nll mod3=1000003;\nll mod4=998244853;\nll mod5=1000000009;\nll inf=1LL<<60;\ndouble pi=3.141592653589793238462643383279L;\ndouble eps=1e-14;\n#define rep(i,m,n) for(ll i=m;i<n;i++)\n#define rrep(i,n,m) for(ll i=n;i>=m;i--)\n#define srep(itr,st) for(auto itr=st.begin();itr!=st.end();itr++)\n#define mrep(itr,mp) for(auto itr=mp.begin();itr!=mp.end();itr++)\n#define Max(a,b) a=max(a,b)\n#define Min(a,b) a=min(a,b)\nint dh[4]={1,-1,0,0};\nint dw[4]={0,0,1,-1};\nint ddh[8]={-1,-1,-1,0,0,1,1,1};\nint ddw[8]={-1,0,1,-1,1,-1,0,1};\nll gcd(ll a,ll b){\n    if(a<b)swap(a,b);\n    if(b==0)return a;\n    if(a%b==0)return b;\n    return gcd(b,a%b);\n}\nll Pow(ll n,ll k){\n    ll ret=1;\n    ll now=n;\n    while(k>0){\n        if(k&1)ret*=now;\n        now*=now;\n        k/=2;\n    }\n    return ret;\n}\nll beki(ll n,ll k,ll md){\n  ll ret=1;\n  ll now=n;\n  while(k>0){\n    if(k%2==1){\n      ret*=now;\n      ret%=md;\n    }\n    now*=now;\n    now%=md;\n    k/=2;\n  }\n  return ret;\n}\nll gyaku(ll n,ll md){\n  return beki(n,md-2,md);\n}\nll popcount(ll n){\n    ll ret=0;\n    ll u=n;\n    while(u>0){\n        ret+=u%2;\n        u/=2;\n        \n    }\n    return ret;\n}\nbool pri(int n){\n    if(n<=2)return false;\n    for(int i=2;i*i<=n;i++){\n        if(n%i==0)return false;\n    }\n    return true;\n}\nint h(int n){\n    if(pri(n))return 1;\n    else if(n%2==0)return 2;\n    else return 3;\n}\nint x[101];\nint n;\nint dfs(set<pii> st,vector<int> v,int las){\n  \n    if(st.size()==0){\n        int cnt[2]={0,0};\n        rep(i,0,v.size())cnt[v[i]%2]++;\n      //cout<<cnt[0]<<\" \"<<cnt[1]<<\" \"<<las<<endl;\n        if(cnt[0]%2==0){\n          if(cnt[1]%2==0)return 0;\n          else{\n            if(las%2==0)return 1;\n            else return 2;\n          }\n        }\n      else{\n        if(cnt[1]%2==0){\n          if(las%2==1)return 1;\n            else return 2;\n        }\n        else{\n          return 1;\n        }\n      }\n    }\n    int mi=1000000000;\n    pii pp=*st.begin();\n    int now=pp.first;\n    srep(itr,st){\n        pii p=*itr;\n        int ri=p.second;\n        if(pri(ri-now+1)==false)continue;\n      //cout<<ri<<endl;\n        set<pii> ne=st;\n        if(itr==st.begin()){\n            ne.erase(ne.begin());\n            if(ne.size()>0)ne.erase(ne.begin());\n            Min(mi,dfs(ne,v,las)+1);\n            continue;\n        }\n        auto itr2=itr;\n        itr2++;\n        if(itr2==st.end()){\n            ne.erase(ne.begin());\n            auto itr3=ne.end();\n            itr3--;\n            ne.erase(itr3);\n            itr3=ne.end();\n            int nl=las;\n            if(ne.size()>0){\n                itr3--;\n                pii ppp=*itr3;\n                nl=ppp.second;\n            }\n            Min(mi,dfs(ne,v,nl)+1);\n            continue;\n        }\n        itr2=itr;\n        pii f=*itr2;\n        itr2++;\n        pii g=*itr2;\n        pii h={f.first,g.second};\n        srep(itr3,ne){\n            pii p2=*itr3;\n            if(p2.first==f.first){\n                itr3=ne.erase(itr3);\n                itr3=ne.erase(itr3);\n                ne.insert(h);\n                break;\n            }\n        }\n        ne.erase(ne.begin());\n        Min(mi,dfs(ne,v,las)+1);\n    }\n    pii ppp=*st.begin();\n    v.push_back(ppp.first);\n    st.erase(st.begin());\n    Min(mi,dfs(st,v,las)+1);\n    return mi;\n}\nint main(){\n    ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n    cin>>n;\n    bool used[10000001];\n    fill(used,used+10000001,false);\n    rep(i,0,n){\n        cin>>x[i];\n        used[x[i]]=true;\n    }\n    set<pii> st;\n    int now=x[0];\n    rep(i,x[0]+1,x[n-1]+2){\n        if(used[i]!=used[i-1]){\n            st.insert({now,i-1});\n            now=i;\n        }\n    }\n    /*srep(itr,st){\n        pii p=*itr;\n        cout<<p.first<<\" \"<<p.second<<endl;\n    }return 0;*/\n    cout<<dfs(st,{},x[n-1])<<endl;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<iostream>\n#include<queue>\n#include<cmath>\nusing namespace std;\nvoid read(int &x){\n\tchar ch;bool ok;\n\tfor(ok=0,ch=getchar();!isdigit(ch);ch=getchar())if(ch=='-')ok=1;\n\tfor(x=0;isdigit(ch);x=x*10+ch-'0',ch=getchar());if(ok)x=-x;\n}\n#define rg register\nconst int maxn=210;bool vis[maxn];\nint f[maxn],n,ans,a[maxn],mp[maxn][maxn],b[maxn],tot1,tot2,x[maxn];\nbool check(int x){\n\tif(!(x&1))return 0;\n\tint n=sqrt(x);\n\tfor(rg int i=2;i<=n;i++)\n\t\tif(!(x%i))return 0;\n\treturn 1;\n}\nbool dfs(int x){\n\tfor(rg int i=1;i<=tot2;i++)\n\t\tif(!vis[i]&&mp[x][i]){\n\t\t\tvis[i]=1;\n\t\t\tif(!f[i]||dfs(f[i]))return f[i]=x,1;\n\t\t}\n\treturn 0;\n}\nint main(){\n\tread(n);\n\tfor(rg int i=1;i<=n;i++)read(x[i]);\n\tfor(rg int i=1;i<=n;i++){\n\t\tif(x[i+1]-x[i]!=1||i==n){\n\t\t\tif((x[i]+1)%2==0)a[++tot1]=x[i]+1;\n\t\t\telse b[++tot2]=x[i]+1;\n\t\t}\n\t\tif(x[i]-x[i-1]!=1||i==1){\n\t\t\tif(x[i]&1)b[++tot2]=x[i];\n\t\t\telse a[++tot1]=x[i];\n\t\t}\n\t}\n\tfor(rg int i=1;i<=tot1;i++)\n\t\tfor(rg int j=1;j<=tot2;j++)\n\t\t\tif(check(abs(a[i]-b[j])+1))mp[i][j]=1;\n\tfor(rg int i=1;i<=tot1;i++){\n\t\tmemset(vis,0,sizeof vis);\n\t\tif(dfs(i))ans++;\n\t}\n\tprintf(\"%d\\n\",ans+(tot1-ans)/2*2+(tot2-ans)/2*2+(tot1-ans)%2*3);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cassert>\n#include <cctype>\n#include <algorithm>\n#include <set>\nusing namespace std;\ntypedef long long lint;\n#define cout cerr\n#define ni (next_num<int>())\ntemplate<class T>inline T next_num(){\n\tT i=0;char c;\n\twhile(!isdigit(c=getchar())&&c!='-');\n\tbool flag=c=='-';\n\tflag?c=getchar():0;\n\twhile(i=i*10-'0'+c,isdigit(c=getchar()));\n\treturn flag?-i:i;\n}\ntemplate<class T1,class T2>inline void apmax(T1 &a,const T2 &b){if(a<b)a=b;}\ntemplate<class T1,class T2>inline void apmin(T1 &a,const T2 &b){if(b<a)a=b;}\nconst int N=110,M=10000010;\nint prime[M],ps=0;\nbool isp[M];\ninline void gmath(int n){\n\tmemset(isp,true,sizeof(isp));\n\tisp[1]=false;\n\tfor(int i=2;i<=n;i++){\n\t\tif(isp[i]){\n\t\t\tprime[ps++]=i;\n\t\t}\n\t\tfor(int j=0,cur=2;j<ps&&i*cur<=n;cur=prime[++j]){\n\t\t\tisp[i*cur]=false;\n\t\t\tif(i%cur==0)break;\n\t\t}\n\t}\n}\nset<int>s;\ntypedef set<int>::iterator iter;\ninline void flip(int x){\n\titer it=s.find(x);\n\tif(it==s.end()){\n\t\ts.insert(x);\n\t}else{\n\t\ts.erase(x);\n\t}\n}\nint main(){\n\tint n=ni,mx=0;\n\tfor(int i=1;i<=n;i++){\n\t\tint cur=ni;\n\t\tapmax(mx,cur);\n\t\tflip(cur),flip(cur+1);\n\t}\n\tgmath(mx);\n\tint ans=s.size(),cnt=0;\n\tfor(iter i=s.begin(),j;i!=s.end();){\n\t\tfor(j=i;++j!=s.end()&&!isp[*j-*i];);\n\t\tif(j==s.end()){\n\t\t\ti++;\n\t\t}else{\n\t\t\tcnt++;\n\t\t\titer nxt=i;\n\t\t\tnxt++;\n\t\t\ts.erase(i),s.erase(j);\n\t\t\ti=nxt;\n\t\t}\n\t}\n\tprintf(\"%d\\n\",ans+(cnt&1)-cnt);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,l,r) for(register int i = l ; i <= r ; i++)\n#define repd(i,r,l) for(register int i = r ; i >= l ; i--)\n#define rvc(i,S) for(register int i = 0 ; i < (int)S.size() ; i++)\n#define rvcd(i,S) for(register int i = ((int)S.size()) - 1 ; i >= 0 ; i--)\n#define fore(i,x)for (register int i = head[x] ; i ; i = e[i].next)\n#define forup(i,l,r) for (register int i = l ; i <= r ; i += lowbit(i))\n#define fordown(i,id) for (register int i = id ; i ; i -= lowbit(i))\n#define pb push_back\n#define prev prev_\n#define stack stack_\n#define mp make_pair\n#define fi first\n#define se second\n#define lowbit(x) (x&(-x))\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pr;\n\nconst ll MAX = 2e18;\nconst ld inf = 2e18;\nconst int maxn = 220;\nconst ll mod = 1e9 + 7;\n\ninline ll power(ll x,ll y){\n\ty = ((y % (mod - 1)) + (mod - 1)) % (mod - 1);\n//\tif ( y < 0 ) return power(power(x,-y),mod - 2);\n\tll res = 1;\n\twhile ( y ){\n\t\tif ( y & 1 ) res = res * x % mod;\n\t\tx = x * x % mod;\n\t\ty >>= 1;\n\t}\n\treturn res;\n}\nint a[maxn],n,odd[maxn],even[maxn],cnt1,cnt2;\nset <int> s;\nnamespace Prime{\n\tconst int N = 1e7;\n\tint prime[N + 20],tag[N + 20],mn[N + 20],Cnt;\t\n\tvoid init (){\n\t\ttag[1] = 1;\n\t\trep(i,2,N){\n\t\t\tif ( !tag[i] ) prime[++Cnt] = i;\n\t\t\trep(j,1,Cnt){\n\t\t\t\tif ( prime[j] * i > N ) break;\n\t\t\t\ttag[i * prime[j]] = 1;\n\t\t\t\tmn[i * prime[j]] = prime[j];\n\t\t\t\tif ( i % prime[j] == 0 ) break;\n\t\t\t}\n\t\t}\n\t}\n}\nusing namespace Prime;\n\nstruct node{\n\tint next,to;\n}e[maxn * maxn];\nint head[maxn],cnt;\nint mx[maxn],my[maxn],dx[maxn],dy[maxn],q[maxn],hh,tt,tot,vis[maxn];\n\ninline void adde(int x,int y){\n\te[++cnt].to = y;\n\te[cnt].next = head[x];\n\thead[x] = cnt;\n}\n\nbool find(int x){\n\tfore(i,x){\n\t\tint to = e[i].to;\n\t\tif ( !vis[to] && dy[to] == dx[x] + 1 ){\n\t\t\tvis[to] = 1;\n\t\t\tif ( !my[to] || find(my[to]) ){\n\t\t\t\tmx[x] = to;\n\t\t\t\tmy[to] = x;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nvoid match(){\n\tmemset(mx,0,sizeof(mx));\n\tmemset(my,0,sizeof(my));\n\ttot = 0;\n\twhile ( 1 ){\n\t\tbool flag = 0;\n\t\ttt = hh = 0;\n\t\trep(i,1,cnt1) if ( !mx[i] ) q[tt++] = i;\n\t\twhile ( hh < tt ){\n\t\t\tint x = q[hh++];\n\t\t\tfore(i,x){\n\t\t\t\tint to = e[i].to;\n\t\t\t\tif ( !dy[to] ){\n\t\t\t\t\tdy[to] = dx[x] + 1;\n\t\t\t\t\tif ( my[to] ){\n\t\t\t\t\t\tdx[my[to]] = dy[to] + 1;\n\t\t\t\t\t\tq[tt++] = my[to]; //入队的点只有左边的点\n\t\t\t\t\t}\n\t\t\t\t\telse flag = 1;//找到增广路\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif ( !flag ) break;\n\t\tmemset(vis,0,sizeof(vis));\n\t\trep(i,1,cnt1) if ( !mx[i] && find(i) ) tot++;\n\t}\n}\n\n\nint main(){\n\tinit();\n\tscanf(\"%d\",&n);\n\trep(i,1,n){\n\t   \tscanf(\"%d\",&a[i]);\n\t\tif ( s.find(a[i]) == s.end() ) s.insert(a[i]);\n\t\telse s.erase(a[i]);\n\n\t\tif ( s.find(a[i] + 1) == s.end() ) s.insert(a[i] + 1);\n\t\telse s.erase(a[i] + 1);\n\t}\n\tfor (auto it = s.begin() ; it != s.end() ; ++it){\n\t\tint x = *it;\n\t\tif ( x & 1 ) odd[++cnt1] = x;\n\t\telse even[++cnt2] = x;\n\t}\n\trep(i,1,cnt1){\n\t\trep(j,1,cnt2){\n\t\t\tint c = abs(odd[i] - even[j]);\n\t\t\tif ( !tag[c] ) adde(i,j);\n\t\t}\n\t}\n\tmatch();\n\tcout<<cnt1 + cnt2 - tot + ((cnt1 - tot) & 1)<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint V, E, src, snk;\nvector<int> la, nxt, oppo, capa;\nvoid init() {\n    E = 0;\n    la.clear(); nxt.clear(); oppo.clear(); capa.clear();\n    la = vector<int>(V, -1);\n}\nvoid add(int u, int v, int c) {\n    nxt.push_back(la[u]);\n    la[u] = E++;\n    oppo.push_back(v);\n    capa.push_back(c);\n}\nvector<int> dist;\nqueue<int> q;\nbool bfs() {\n    dist = vector<int>(V, -1);\n    q.push(src);\n    dist[src] = 0;\n    while(!q.empty()) {\n        int u = q.front(); q.pop();\n\n        for(int i = la[u]; i != -1; i = nxt[i]) {\n            int v = oppo[i];\n            if(capa[i] && dist[v] == -1) {\n                q.push(v);\n                dist[v] = dist[u] + 1;\n            }\n        }\n    }\n    return dist[snk] != -1;\n}\nvector<int> laa;\nint dfs(int u, int f) {\n    if(u == snk) return f;\n    for(int i = laa[u]; i != -1; i = nxt[i]) {\n        laa[u] = i;\n        int v = oppo[i];\n        if(capa[i] && dist[v] == dist[u] + 1) {\n            if(int tmp = dfs(v, min(capa[i], f))) {\n                capa[i] -= tmp;\n                capa[i^1] += tmp;\n                return tmp;\n            }\n        }\n    }\n    return 0;\n}\nint dinic() {\n    int tf = 0;\n    while(bfs()) {\n        laa = la;\n        while(int tmp = dfs(src, 1e9)) tf += tmp;\n    }\n    return tf;\n}\n\nvector<int> pchk;\nvoid getPrime() {\n    pchk = vector<int>(10000010, 0);\n    for(int i = 2; i < 10000010; i++) {\n        if(pchk[i]) continue;\n        int mul = 2;\n        while(i * mul < 10000010) {\n            pchk[i * mul] = 1;\n            mul++;\n        }\n    }\n    pchk[1] = 1;\n    pchk[2] = 1;\n}\n\nint N;\nvector<int> X;\nvector<int> B;\nvector<int> Me, Mo;\n\nint main() {\n    getPrime();\n\n    scanf(\"%d\", &N);\n    X.resize(N);\n    for(int i = 0; i < N; i++) {\n        scanf(\"%d\", &X[i]);\n    }\n    for(int i = 0; i < N; i++) {\n        if(i == 0 || X[i] != X[i - 1] + 1) {\n            B.push_back(X[i]);\n        }\n        if(i == N - 1 || X[i] + 1 != X[i + 1]) {\n            B.push_back(X[i] + 1);\n        }\n    }\n    for(int i = 0; i < B.size(); i++) {\n        if(B[i] % 2) Mo.push_back(B[i]);\n        else Me.push_back(B[i]);\n    }\n\n    V = Me.size() + Mo.size() + 2, src = V - 2, snk = V - 1;\n    init();\n\n    for(int i = 0; i < Me.size(); i++) {\n        add(src, i, 1);\n        add(i, src, 0);\n    }\n    for(int i = 0; i < Mo.size(); i++) {\n        add(Me.size() + i, snk, 1);\n        add(snk, Me.size() + i, 0);\n    }\n    for(int i = 0; i < Me.size(); i++) {\n        for(int j = 0; j < Mo.size(); j++) {\n            if(!pchk[ abs(Me[i] - Mo[j]) ]) {\n                add(i, Me.size() + j, 1);\n                add(Me.size() + j, i, 0);\n            }\n        }\n    }\n    int K = dinic();\n    cout<<K + (((int)Me.size() - K)/2 + ((int)Mo.size() - K)/2)*2 + (Me.size() % 2)*3;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<queue>\n#include<stack>\n#include<cstring>\n#include<algorithm>\n#include<vector>\n#include<cmath>\nusing namespace std;\nint e[201][201];\nint vis[201];\nint match[201];\nint tot1=0,tot2=0;\nbool find(int u)\n{\n\tfor(int i=1;i<=tot2;i++)\n\t{\n\t\tif(vis[i]==0&&e[u][i])\n\t\t{\n\t\t\tvis[i]=1;\n\t\t\tif(!match[i]||find(match[i]))\n\t\t\t{\n\t\t\t\tmatch[i]=u;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n}\nbool isprime(int x)\n{\n\tif(x==1) return false;\n\tfor(int i=2;i<=sqrt(x);i++)\n\t\tif(x%i==0)\n\t\t\treturn false;\n\treturn true;\n}\nint x[201];\nint odd[201];\nint even[201];\nsigned main()\n{\n\tint n;\n\tscanf(\"%d\",&n);\n\tif(n==1){printf(\"3\");return 0;}\n\tfor(int i=1;i<=n;i++)\n\t\tscanf(\"%d\",&x[i]);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tif(i==1||x[i-1]!=x[i]-1)\n\t\t{\n\t\t\tif(x[i]%2==1) odd[++tot1]=x[i];\n\t\t\telse even[++tot2]=x[i];\n\t\t}\n\t\tif(i==n||x[i+1]!=x[i]+1)\n\t\t{\n\t\t\tif(x[i]%2==1) even[++tot2]=x[i]+1;\n\t\t\telse odd[++tot1]=x[i]+1;\n\t\t}\n\t}\n\tfor(int i=1;i<=tot1;i++)\n\t\tfor(int j=1;j<=tot2;j++)\n\t\t\tif(isprime(abs(odd[i]-even[j])))\n\t\t\t\te[i][j]=1;\n\tint ans=0;\n\tfor(int i=1;i<=tot1;i++)\n\t{\n\t\tmemset(vis,0,sizeof(vis));\n\t\tif(find(i))\n\t\t\tans++;\n\t}\n\tprintf(\"%d\",ans+(tot1-ans)/2*2+(tot2-ans)/2*2+(tot1-ans)%2*3);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<cstring>\n#include<map>\n#include<queue>\n#include<cmath>\nusing namespace std;\ntypedef long long ll;\nconst int N=105,INF=~0u>>2;\nstruct Edge{int nxt,to;}edge[(N*N)<<3];\nint a[N],b[N<<1],n,head[N<<1],num_edge,vis[N<<1],lk[N<<1],even[N<<1],odd[N<<1],even_num,odd_num,ans,k,tot,tim;\nint read(){\n\tint x=0,f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-') f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn f*x;\n}\nvoid add_edge(int from,int to){\n\tedge[++num_edge].nxt=head[from];\n\tedge[num_edge].to=to;\n\thead[from]=num_edge;\n}\nbool find(int x){\n\tfor(int i=head[x];i;i=edge[i].nxt){\n\t\tif(vis[edge[i].to]!=tim){\n\t\t\tvis[edge[i].to]=tim;\n\t\t\tif(!lk[edge[i].to]||find(edge[i].to)){\n\t\t\t\tlk[edge[i].to]=x;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nbool check(int x){\n\tif(x==1) return 0;\n\tfor(int i=2;i*i<=x;++i){\n\t\tif(x%i==0) return 0;\n\t}\n\treturn 1;\n}\nint main(){\n//\tfreopen(\"ex.in\",\"r\",stdin);\n\tn=read();\n\tfor(int i=1;i<=n;++i) b[i]=read();b[0]=-INF;b[n+1]=INF;\n\tfor(int i=1;i<=n;++i){\n\t\tif(b[i]!=b[i-1]+1){\n\t\t\tif(i%2) odd[++odd_num]=b[i];\n\t\t\telse even[++even_num]=b[i];\n\t\t}\n\t\tif(b[i]+1!=b[i+1]){\n\t\t\tif((i+1)%2) odd[++odd_num]=b[i]+1;\n\t\t\telse even[++even_num]=b[i]+1;\n\t\t}\n\t}\n\tfor(int i=1;i<=odd_num;++i){\n\t\tfor(int j=1;j<=even_num;++j){\n\t\t\tif(check(abs(even[j]-odd[i]))) add_edge(even[j],odd[i]),add_edge(odd[i],even[j]);\n\t\t}\n\t}\n\tfor(int i=1;i<=odd_num;++i){\n\t\ttim++;\n\t\tif(find(odd[i])) k++;\n\t\telse break;\n\t}\n\tans=k+((even_num-k)/2+(odd_num-k)/2)*2+((even_num-k)%2)*3;\n\tprintf(\"%d\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int max_n=205;\nconst int max_m=10005;\nstruct edge{\n    int u,v,next;\n}G[max_m*2];\nint head[max_n],tot;\nvoid init(int n){\n    tot=0;\n    for(int i=0;i<=n;i++)head[i]=-1;\n}\nint match[max_n];\nbool used[max_n];\nvoid add_edge(int u,int v){\n    G[tot]={u,v,head[u]};\n    head[u]=tot++;\n}\nbool dfs(int u){\n    used[u]=true;\n    for(int i=head[u];~i;i=G[i].next){\n        int v=G[i].v,w=match[v];\n        if(w<0||!used[w]&&dfs(w)){\n            match[u]=v,match[v]=u;\n            return true;\n        }\n    }\n    return false;\n}\nint solve(int n,int m){\n    int res=0;\n    for(int i=0;i<=n+m;i++)match[i]=-1;\n    for(int u=1;u<=n;u++){\n        if(match[u]==-1){\n            for(int i=0;i<=n+m;i++)used[i]=false;\n            if(dfs(u))res++;\n        }\n    }\n    return res;\n}\nint n,a[max_n];\nbool vis[10000005];\nbool p[10000005];\nint pri[10000005],cnt;\nvoid sieve(int n){\n    p[0]=p[1]=true;\n    for(int i=2;i<=n;i++){\n        if(!p[i])pri[++cnt]=i;\n        for(int j=1;j<=cnt&&1ll*i*pri[j]<=n;j++){\n            p[i*pri[j]]=true;\n            if(i%pri[j]==0)break;\n        }\n    }\n}\nint main(){\n    scanf(\"%d\",&n);\n    for(int i=1;i<=n;i++)scanf(\"%d\",a+i);\n    for(int i=1;i<=n;i++)vis[a[i]]^=1,vis[a[i]+1]^=1;\n    sieve(10000000);\n    vector<int> odd,even;\n    for(int i=1;i<=10000001;i++){\n        if(vis[i]){\n            if(i&1)odd.push_back(i);\n            else even.push_back(i);\n        }\n    }\n    int nn=odd.size(),mm=even.size();\n    init(nn+mm);\n    for(int i=0;i<nn;i++){\n        for(int j=0;j<mm;j++){\n            if(!p[abs(even[j]-odd[i])]){\n                add_edge(i+1,j+1+nn),add_edge(j+1+nn,i+1);\n            }\n        }\n    }\n    int x=solve(nn,mm);\n    int ans=x+(nn-x)/2*2+(mm-x)/2*2+nn%2*3;\n    printf(\"%d\\n\",ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<cstring>\n\nusing namespace std;\nint n;\nconst int maxn = 1e7+5;//40M\nconst int S = 1e7+1;\nint pri[maxn],cnt; bool mk[maxn];\nint A[maxn];\nvoid oula() {\n\tmk[1] = mk[0] = 1;\n\tfor(int i=1;i<=S;i++) {\n\t\tif(!mk[i]) { pri[++cnt]=i; }\n\t\tfor(int j=1;j<=cnt&&1ll*pri[j]*i<=S;j++) {\n\t\t\tint k = pri[j]*i;\n\t\t\tmk[k] = 1;\n\t\t\tif(i%pri[j]==0) break;\n\t\t}\n\t}\n}\nint la[405],en[405*405],owo,nt[405*405];\nvoid adg(int x,int y) {\n\ten[++owo]=y; nt[owo]=la[x]; la[x]=owo;\n}\nint cc[2];\nint yo[2][405];\nint link[405],vis[405],vtm;\nbool hungary(int x,int tm) {\n\tfor(int it=la[x];it;it=nt[it]) {\n\t\tint y = en[it];\n\t\tif(vis[y]==tm) continue;\n\t\tvis[y] = tm;\n\t\tif((!link[y])||(hungary(link[y],tm))) {\n\t\t\tlink[y] = x; return 1;\n\t\t}\n\t}\n\treturn 0;\n}\nint main() {\n\toula();\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++) {\n\t\tint x; scanf(\"%d\",&x); A[x] = 1;\n\t}\n\tfor(int i=1;i<=S;i++) {\n\t\tint cf = A[i-1]^A[i];\n\t\tif(cf) {\n\t\t\t++cc[i&1];\n\t\t\tyo[i&1][cc[i&1]] = i;\n\t\t}\n\t}\n\tfor(int i=1;i<=cc[0];i++) {\n\t\tfor(int j=1;j<=cc[1];j++) {\n\t\t\tif(!mk[abs(yo[0][i]-yo[1][i])]) adg(i,j);\n\t\t}\n\t}\n\tint ans = 0;\n\tfor(int i=1;i<=cc[0];i++) {\n\t\tans += hungary(i,++vtm);\n\t}\n\tcc[0]-=ans; cc[1]-=ans;\n\tprintf(\"%d\",ans+cc[0]/2*2 + cc[1]/2*2 + (cc[0]&1)*3 );\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define fi first\n#define se second\n#define mp make_pair\n#define gc getchar\n#define pb push_back\n#define eb emplace_back\n#define all(x) (x).begin(),(x).end()\n#define x1 uvuvwevwevwe\n#define y1 onyetenyevwe\n#define x2 ugwemubwem\n#define y2 ossas\ntypedef long long LL;\ntypedef long double LD;\ntypedef pair<int,int> pii;\nconst int batasprima=5000;\ntemplate <typename T> void scan(T &angka){\n\tangka=0;char input=gc();T kali=1;\n\twhile(!(48<=input&&input<=57)){\tif(input=='-')\tkali=-1;input=gc();}\n\twhile(48<=input&&input<=57)\tangka=(angka<<3)+(angka<<1)+input-48,input=gc();angka*=kali;\n}\ntemplate <typename T1,typename T2> void scan(T1 &angka1,T2 &angka2){\n\tscan(angka1);scan(angka2);\n}\nint match[205],totalmatch=0,k=0,ans;\nvector <int> daftar,adj[205],prime;\nbitset<205> visited;\nvoid sieve(){\n\tbool isprime[batasprima+5];\n\tmemset(isprime,true,sizeof(isprime));\n\tfor(int i=2;i<=batasprima;i++)\n\t{\n\t\tif(!isprime[i])\n\t\t\tcontinue;\n\t\tprime.pb(i);\n\t\tfor(int j=i+i;j<=batasprima;j+=i)\n\t\t\tisprime[j]=false;\n\t}\n}\nbool isprime(int angka){\n\tif(angka<2)\n\t\treturn false;\n\tfor(auto isi:prime)\n\t{\n\t\tif(angka%isi==0)\n\t\t\treturn false;\n\t}\n\treturn true;\n}\nbool matching(int pos){\n\tif(visited[pos])\n\t\treturn false;\n\tvisited[pos]=true;\n\tfor(auto isi:adj[pos])\n\t{\n\t\tif(match[isi]==-1||matching(match[isi]))\n\t\t{\n\t\t\tmatch[isi]=pos;\n\t\t\tmatch[pos]=isi;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\nvoid buatgraph(){\t\n\tfor(int i=0;i<daftar.size();i++)\n\t{\n\t\tfor(int j=0;j<daftar.size();j++)\n\t\t{\n\t\t\tif(isprime(abs(daftar[i]-daftar[j])))\n\t\t\t\tadj[i].pb(j);\n\t\t}\n\t}\n}\nvoid hitungk(){\n\tfor(int i=0;i<daftar.size();i++)\n\t{\n\t\tif(match[i]!=-1)\n\t\t\tcontinue;\n\t\tvisited.reset();\n\t\tif(matching(i))\n\t\t\tk++;\n\t}\n}\nvoid hitungans(){\n\tint genap=0,ganjil=0;\n\tfor(auto isi:daftar)\n\t{\n\t\tif(isi&1)\n\t\t\tganjil++;\n\t\telse\n\t\t\tgenap++;\n\t}\n\tassert(ganjil>=k&&genap>=k);\n\tans=k+(ganjil/2+genap/2)*2+(ganjil%2)*3;\n}\nvoid isidaftar(){\n\tint n;\n\tscan(n);\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tint input;\n\t\tscan(input);\n\t\tif(daftar.size()&&daftar.back()==input)\n\t\t\tdaftar.back()=input+1;\t\t\t//nanti mau sa coba\n\t\telse\n\t\t\tdaftar.pb(input),daftar.pb(input+1);\n\t}\n}\nint main()\n{\n\tsieve();\n\tmemset(match,-1,sizeof(match));\n\tisidaftar();\n\tbuatgraph();\n\thitungk();\n\thitungans();\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<cstdio>\n#include<cstring>\nusing namespace std;\nconst int N=1e7+5;\nint n,x,ans,t[N+5],p[1000005],b[205][205],d1[205],d2[205],s[205];\nbool bz[N+5],v[205];\nbool dg(int x)\n{\n\tfor (int i=1;i<=d2[0];i++)\n\tif (b[x][i] && !v[i])\n\t{\n\t\tv[i]=1;\n\t\tif (!s[i] || dg(s[i]))\n\t\t{\n\t\t\ts[i]=x;\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<=n;i++) scanf(\"%d\",&x),bz[x]=1;\n\tfor (int i=1;i<=N;i++) \n\tif (bz[i]^bz[i-1]) \n\t{\n\t\tif (i&1) d1[++d1[0]]=i; \n\t\t\telse d2[++d2[0]]=i;\n\t}\n\tmemset(bz,0,sizeof(bz));\n\tbz[1]=1;\n\tfor (int i=2;i<=N;i++)\n\t{\n\t\tif (!bz[i]) p[++p[0]]=i;\n\t\tfor (int j=1;j<=p[0] && i*p[j]<=N;j++)\n\t\t{\n\t\t\tbz[i*p[j]]=1;\n\t\t\tif (i%p[j]==0) break;\n\t\t}\n\t}\n\tfor (int i=1;i<=d1[0];i++)\n\t\tfor (int j=1;j<=d2[0];j++)\n\t\tif (!bz[abs(d1[i]-d2[j])]) b[i][j]=1;\n\tfor (int i=1;i<=d1[0];i++)\n\t{\n\t\tmemset(v,0,sizeof(v));\n\t\tif (dg(i)) ans++;\n\t}\n\td1[0]-=ans,d2[0]-=ans;\n\tans+=d1[0]/2*2+d2[0]/2*2+d1[0]%2*3;\n\tprintf(\"%d\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define REP(i, n) for (int i = 0; i < int(n); ++i)\n#define REPE(i, a, b) for (int i = (a); i <= int(b); ++i)\n#define SZ(x) ((int)(x).size())\n#define ALL(x) x.begin(), x.end()\n#define PB push_back\n#define EB emplace_back\nusing LL = long long;\nusing PII = pair<int, int>;\n#define F first\n#define S second\n\nnamespace BPM {\nconst int maxn = 110;\nvector<int> g[maxn];\nint n, m, l[maxn];\nbool vis[maxn];\nbool match(int x) {\n  for (int y : g[x])\n    if (!vis[y]) {\n      vis[y] = true;\n      if (l[y] == -1 || match(l[y])) {\n        l[y] = x;\n        return true;\n      }\n    }\n  return false;\n}\nint solve() {\n  memset(l, -1, sizeof l);\n  int ans = 0;\n  for (int i = 0; i < n; ++i) {\n    memset(vis, 0, sizeof vis);\n    if (match(i))\n      ans++;\n  }\n  return ans;\n}\n}\n\nnamespace Sieve {\nconst int maxn = 1e7 + 10;\nbool vis[maxn] = {};\nvector<int> prime;\nvoid linear_sieve(int n) {\n  for (int i = 2; i < n; ++i) {\n    for (int y : prime) {\n      if (1LL * i * y >= n)\n        break;\n      int t = i * y;\n      vis[t] = true;\n      if (i % y == 0) {\n        break;\n      }\n    }\n  }\n}\n}\n\nint n, a[110];\nvector<int> b[2];\nint main() {\n  Sieve::linear_sieve(Sieve::maxn);\n  scanf(\"%d\", &n);\n  set<int> s;\n  REP(i, n) {\n    scanf(\"%d\", &a[i]);\n  }\n  REP(i, n) {\n    if (i == 0 || a[i] - 1 != a[i - 1]) s.insert(a[i]);\n    if (i == n - 1 || a[i] + 1 != a[i + 1]) s.insert(a[i + 1]); \n  }\n  for (int x : s) b[x&1].PB(x);\n  BPM::n = SZ(b[0]);\n  BPM::m = SZ(b[1]);\n  REP(i, BPM::n) REP(j, BPM::m) {\n    int d = abs(b[0][i] - b[1][j]);\n    if (d >= 3 && !Sieve::vis[d]) BPM::g[i].PB(j);\n  }\n  int k = BPM::solve();\n  int ans = k + ((BPM::n - k) / 2 + (BPM::m - k) / 2) * 2 + ((BPM::n - k) % 2) * 3;\n  printf(\"%d\\n\", ans);\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"math.h\"\n#include <algorithm>\n#include <complex>\n#include <cstdio>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <string>\n#include <vector>\n#define ifor(i, a, b) for (int i = (a); i < (b); i++)\n#define rfor(i, a, b) for (int i = (b)-1; i >= (a); i--)\n#define rep(i, n) for (int i = 0; i < (n); i++)\n#define rrep(i, n) for (int i = (n)-1; i >= 0; i--)\nusing namespace std;\ntypedef long double ld;\ntypedef long long int lli;\ntypedef complex<double> P;\nconst double eps = 1e-11;\nint vex[4] = {1, 0, -1, 0};\nint vey[4] = {0, 1, 0, -1};\ntypedef vector<double> Vec;\ntypedef vector<int> vec;\ntypedef vector<Vec> MAT;\ntypedef vector<vec> mat;\nlli MOD = 1000000007;\nint INF = 100000000;\nstruct edge {\n    int to, cap, rev;\n    edge(int to, int cap, int rev)\n    {\n        this->to = to;\n        this->cap = cap;\n        this->rev = rev;\n    }\n};\n\n#define MAX_V 100005\nvector<edge> G[MAX_V];\nint level[MAX_V];\nint iter[MAX_V];\nvoid add_edge(int from, int to, int cap)\n{\n    G[from].push_back(edge(to, cap, G[to].size()));\n    G[to].push_back(edge(from, 0, G[from].size() - 1));\n}\nlli gcd(lli a, lli b)\n{\n    return b > a ? gcd(b, a) : (b == 0 ? a : gcd(b, a % b));\n}\nvoid bfs(int s)\n{\n    //memset(level, -1, sizeof(level));\n    rep(i, MAX_V) level[i] = -1;\n    queue<int> que;\n    level[s] = 0;\n    que.push(s);\n    while (!que.empty()) {\n        int v = que.front();\n        que.pop();\n        for (int i = 0; i < G[v].size(); i++) {\n            edge& e = G[v][i];\n            if (e.cap > 0 && level[e.to] < 0) {\n                level[e.to] = level[v] + 1;\n                que.push(e.to);\n            }\n        }\n    }\n}\nint dfs(int v, int t, int f)\n{\n    if (v == t)\n        return f;\n    for (int& i = iter[v]; i < G[v].size(); i++) {\n        edge& e = G[v][i];\n        if (e.cap > 0 && level[v] < level[e.to]) {\n            int d = dfs(e.to, t, min(f, e.cap));\n            if (d > 0) {\n                e.cap -= d;\n                G[e.to][e.rev].cap += d;\n                return d;\n            }\n        }\n    }\n    return 0;\n}\nint max_flow(int s, int t)\n{\n    int flow = 0;\n    while (true) {\n        bfs(s);\n        if (level[t] < 0)\n            return flow;\n        //memset(iter, 0, sizeof(iter));\n        rep(i, MAX_V) iter[i] = 0;\n        int f;\n        while ((f = dfs(s, t, INF)) > 0) {\n            flow += f;\n        }\n    }\n}\nvoid init()\n{\n    rep(i, 2005)\n    {\n        G[i].clear();\n        level[i] = 0;\n        iter[i] = 0;\n    }\n}\nint main()\n{\n\n    int n;\n    cin >> n;\n    int x[1005];\n    rep(i, n) cin >> x[i];\n    map<int, int> m;\n    rep(i, n)\n    {\n        m[x[i]] = 1;\n    }\n    map<int, int> b;\n    auto mm = m;\n    for (auto s : mm) {\n        b[s.first] = s.second ^ m[s.first - 1];\n        b[s.first + 1] = s.second ^ m[s.first + 1];\n    }\n\n    init();\n    vector<int> v_odd, v_even;\n    for (auto a : b) {\n        if (a.second == 1) {\n            if (a.first & 1)\n                v_odd.push_back(a.first);\n            else\n                v_even.push_back(a.first);\n            //cout << a.first << endl;\n        }\n    }\n    int sz = v_odd.size() + v_even.size();\n    int s = sz;\n    int t = sz + 1;\n    auto prime = [](lli a) -> bool {\n        for (int i = 2; i * i <= a; i++) {\n            if (a % i == 0)\n                return false;\n        }\n        return true;\n    };\n    rep(i, v_odd.size()) add_edge(s, i, 1);\n    rep(i, v_even.size()) add_edge(v_odd.size() + i, t, 1);\n    rep(i, v_odd.size())\n    {\n        rep(j, v_even.size())\n        {\n            int h = abs(v_odd[i] - v_even[j]);\n            if (h & 1 and h >= 3 and prime(h)) {\n                add_edge(i, v_odd.size() + j, 1);\n            }\n        }\n    }\n    lli hoge = max_flow(s, t);\n    cout << hoge + ((v_even.size() - hoge) / 2) * 2 + ((v_odd.size() - hoge) / 2) * 2 + ((v_even.size() - hoge) % 2) * 3 << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define fi first\n#define se second\n#define mp make_pair\n#define gc getchar\n#define pb push_back\n#define eb emplace_back\n#define all(x) (x).begin(),(x).end()\n#define x1 uvuvwevwevwe\n#define y1 onyetenyevwe\n#define x2 ugwemubwem\n#define y2 ossas\ntypedef long long LL;\ntypedef long double LD;\ntypedef pair<int,int> pii;\nconst int batasprima=10000;\ntemplate <typename T> void scan(T &angka){\n\tangka=0;char input=gc();T kali=1;\n\twhile(!(48<=input&&input<=57)){\tif(input=='-')\tkali=-1;input=gc();}\n\twhile(48<=input&&input<=57)\tangka=(angka<<3)+(angka<<1)+input-48,input=gc();angka*=kali;\n}\ntemplate <typename T1,typename T2> void scan(T1 &angka1,T2 &angka2){\n\tscan(angka1);scan(angka2);\n}\nint match[205],k=0,ans;\nvector <int> daftar,adj[205],prime;\nbitset<205> visited;\nvoid sieve(){\n\tbool isprime[batasprima+5];\n\tmemset(isprime,true,sizeof(isprime));\n\tfor(int i=2;i<=batasprima;i++)\n\t{\n\t\tif(!isprime[i])\n\t\t\tcontinue;\n\t\tprime.pb(i);\n\t\tfor(int j=i+i;j<=batasprima;j+=i)\n\t\t\tisprime[j]=false;\n\t}\n}\nbool isprime(int angka){\n\tif(angka<2)\n\t\treturn false;\n\tfor(auto isi:prime)\n\t{\n\t\tif(angka%isi==0)\n\t\t\treturn false;\n\t}\n\treturn true;\n}\nbool matching(int pos){\n\tif(visited[pos])\n\t\treturn false;\n\tvisited[pos]=true;\n\tfor(auto isi:adj[pos])\n\t{\n\t\tif(match[isi]==-1||matching(match[isi]))\n\t\t{\n\t\t\tmatch[isi]=pos;\n\t\t\tmatch[pos]=isi;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\nvoid buatgraph(){\t\n\tfor(int i=0;i<daftar.size();i++)\n\t{\n\t\tfor(int j=0;j<daftar.size();j++)\n\t\t{\n\t\t\tif(isprime(abs(daftar[i]-daftar[j])))\n\t\t\t\tadj[i].pb(j);\n\t\t}\n\t}\n}\nvoid hitungk(){\n\tmemset(match,-1,sizeof(match));\n\tfor(int i=0;i<daftar.size();i++)\n\t{\n\t\tif(match[i]!=-1)\n\t\t\tcontinue;\n\t\tvisited.reset();\n\t\tif(matching(i))\n\t\t\tk++;\n\t}\n}\nvoid hitungans(){\n\tint genap=0,ganjil=0;\n\tfor(auto isi:daftar)\n\t{\n\t\tif(isi&1)\n\t\t\tganjil++;\n\t\telse\n\t\t\tgenap++;\n\t}\n\tassert(ganjil>=k&&genap>=k);\n\tassert(ganjil%2==genap%2);\n\tans=k+(ganjil/2+genap/2)*2+(ganjil%2)*3;\n}\nvoid isidaftar(){\n\tint n;\n\tscan(n);\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tint input;\n\t\tscan(input);\n\t\tif(daftar.size()&&daftar.back()==input)\n\t\t\tdaftar[daftar.size()-1]=input+1;\t\t\t//nanti mau sa coba\n\t\telse\n\t\t\tdaftar.pb(input),daftar.pb(input+1);\n\t}\n}\nint main()\n{\n\tsieve();\n\tisidaftar();\n\tbuatgraph();\n\thitungk();\n\thitungans();\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint n, x, z;\nint a[220], b[220], ac, bc, l[220];\nbool g[220][220], v[220];\nmap<int, int> q;\nbool P(int x) {\n\tif (x < 2) {\n\t\treturn false;\n\t}\n\tfor (int i = 2; i * i <= x; i++) {\n\t\tif (x % i == 0) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\nbool dfs(int x) {\n\tfor (int i = 0; i < bc; i++) {\n\t\tif (g[x][i] && !v[i]) {\n\t\t\tv[i] = true;\n\t\t\tif (l[i] == -1 || dfs(l[i])) {\n\t\t\t\treturn l[i] = x, true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d\", &x);\n\t\tq[x] ^= 1;\n\t\tq[x + 1] ^= 1;\n\t}\n\tfor (pair<int, int> i: q) {\n\t\tif (i.second == 0) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (i.first & 1) {\n\t\t\ta[ac++] = i.first;\n\t\t} else {\n\t\t\tb[bc++] = i.first;\n\t\t}\n\t}\n\tfor (int i = 0; i < ac; i++) {\n\t\tfor (int j = 0; j < bc; j++) {\n\t\t\tif (P(abs(a[i] - b[j]))) {\n\t\t\t\tg[i][j] = true;\n\t\t\t}\n\t\t}\n\t}\n\tmemset(l, -1, sizeof l);\n\tfor (int i = 0; i < ac; i++) {\n\t\tmemset(v, 0, sizeof v);\n\t\tif (dfs(i)) {\n\t\t\tz++;\n\t\t}\n\t}\n\tif ((ac - z) & 1) {\n\t\tz--;\n\t}\n\tprintf(\"%d\\n\", ac + bc - z);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define maxn 300\n#define maxm 100100\nusing namespace std;\nstruct edge{\n    int r,nxt,w;\n}e[maxm];\nint head[maxn],esz=1,S,T,dep[maxn],q[maxn],ql,qr,cur[maxn];\nvoid addedge(int u,int v,int w){\n//\tprintf(\"[%d->%d]\\n\",u,v);\n    e[++esz].r=v;\n    e[esz].nxt=head[u];\n    e[esz].w=w;\n    head[u]=esz;\n    e[++esz].r=u;\n    e[esz].nxt=head[v];\n    e[esz].w=0;\n    head[v]=esz;\n}\nbool bfs(){\n    ql=qr=0;\n    q[qr++]=S;\n//\tprintf(\"[ok,%d,%d]\",S,T);\n    for(int i=S;i<=T;++i)dep[i]=0,cur[i]=head[i];\n    dep[S]=1;\n    while(ql<qr){\n        int x=q[ql++];\n        for(int t=head[x];t;t=e[t].nxt)if(!dep[e[t].r]&&e[t].w)\n            dep[e[t].r]=dep[x]+1,q[qr++]=e[t].r;\n    }\n    return dep[T]!=0;\n}\nint find(int u,int flow){\n    if(u==T)return flow;\n    int a=0,used=0;\n    for(int& t=cur[u];t;t=e[t].nxt)if(e[t].w&&dep[e[t].r]==dep[u]+1&&(a=find(e[t].r,min(flow-used,e[t].w)))){\n        e[t].w-=a;e[t^1].w+=a,used+=a;\n        if(used==flow)return used;\n    }\n    if(!used)dep[u]=0;\n    return used;\n}\nint dinic(){\n\tint ans=0,a=0;\n\twhile(bfs())\n\t\twhile(a=find(S,1<<30))ans+=a;\n\treturn ans;\n}\nconst int lim=10000010;\nint pri[lim],psz,n,a[maxn],tp,d[2];\nbool vis[lim],c[lim];\nint main(){\n\tfor(int i=2;i<lim;++i){\n\t\tif(!vis[i])pri[++psz]=i;\n\t\tfor(int j=1;j<=psz&&pri[j]*i<lim;++j){\n\t\t\tvis[i*pri[j]]=1;if(i%pri[j]==0)break;\n\t\t}\n\t}\n\tscanf(\"%d\",&n);\n\tfor(int i=1,x;i<=n;++i)scanf(\"%d\",&x),c[x]^=1,c[x+1]^=1;\n\tfor(int i=1;i<lim;++i)if(c[i])a[++tp]=i;\n\tS=0,T=tp+3,vis[1]=vis[2]=1;\n\tfor(int i=1;i<=tp;++i)\n\t\tfor(int j=i+1;j<=tp;++j)if((a[i]&1)!=(a[j]&1)){\n//\t\t\tprintf(\"{%d,%d}\",a[i],a[j]);\n\t\t\tif(!vis[a[j]-a[i]]){\n\t\t\t\tif(a[i]&1)addedge(i,j,1);\n\t\t\t\telse addedge(j,i,1);\n\t\t\t}\n\t\t}\n\tfor(int i=1;i<=tp;++i)\n\t\tif(a[i]&1)addedge(S,i,1);\n\t\telse addedge(i,T,1);\n\tint ans=dinic();\n\tfor(int i=1;i<=tp;++i)d[a[i]&1]++;\n\td[0]-=ans,d[1]-=ans;\n//\tprintf(\"[%d,%d,%d]\",d[0],d[1],ans);\n\tif(d[0]%2)ans+=3,d[0]--,d[1]--;\n\tans+=d[0]+d[1];\n\tprintf(\"%d\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n\n#include <iostream>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <unordered_set>\n#include <queue>\n#include <set>\n#include <algorithm>\n#include <numeric>\n#include <list>\nusing namespace std;\n\nusing QWORD  = uint64_t;\nusing SQWORD = int64_t;\nusing DWORD  = uint32_t;\nusing SDWORD = int32_t;\nusing WORD   = uint16_t;\nusing SWORD  = int16_t;\nusing BYTE   = uint8_t;\nusing SBYTE  = int8_t;\nusing DOUBLE = double;\nusing FLOAT  = float;\n\n#define MIN_SDWORD (-2147483648)\n#define MAX_SDWORD (2147483647)\n#define MIN_SBYTE (-128)\n#define MAX_SBYTE (127)\n\n#define MIN_SQWORD (0x8000000000000000)\n#define MAX_SQWORD (0x7FFFFFFFFFFFFFFF)\n\n#define MAX_QWORD  (0xFFFFFFFFFFFFFFFF)\n#define MAX_DWORD  (0xFFFFFFFF)\n#define MAX_WORD   (0xFFFF)\n#define MAX_BYTE   (0xFF)\n\n#define MAX_DOUBLE      (1.0e+308)\n#define DOUBLE_EPS      (1.0e-12)\n#define MIN_DOUBLE_N    (-1.0e+308)\n\n#define ArrayLength(a)  (sizeof(a) / sizeof(a[0]))\n\nstatic inline DOUBLE MAX(DOUBLE a, DOUBLE b) { return a > b ? a : b; }\nstatic inline QWORD MAX(QWORD a, QWORD b) { return a > b ? a : b; }\nstatic inline DWORD MAX(DWORD a, DWORD b) { return a > b ? a : b; }\nstatic inline SDWORD MAX(SDWORD a, SDWORD b) { return a > b ? a : b; }\nstatic inline DOUBLE MIN(DOUBLE a, DOUBLE b) { return a < b ? a : b; }\nstatic inline QWORD MIN(QWORD a, QWORD b) { return a < b ? a : b; }\nstatic inline DWORD MIN(DWORD a, DWORD b) { return a < b ? a : b; }\nstatic inline SDWORD MIN(SDWORD a, SDWORD b) { return a < b ? a : b; }\nstatic inline DOUBLE ABS(DOUBLE a) { return 0 < a ? a : -a; };\n\n#define BYTE_BITS   (8)\n#define WORD_BITS   (16)\n#define DWORD_BITS  (32)\n#define QWORD_BITS  (64)\n\nstatic inline void inputStringSpSeparated(char *pcStr)\n{\n    char *pcCur = pcStr;\n    for (;;) {\n        char c = getchar();\n        if (('\\n' == c) || (EOF == c) || (' ' == c)) {\n            break;\n        }\n        *pcCur = c;\n        pcCur++;\n    }\n    *pcCur = '\\0';\n}\n\nstatic inline void inputString(char *pcStr)\n{\n    char *pcCur = pcStr;\n    for (;;) {\n        char c = getchar();\n        if (('\\n' == c) || (EOF == c)) {\n            break;\n        }\n        *pcCur = c;\n        pcCur++;\n    }\n    *pcCur = '\\0';\n}\n\n\nstatic inline SQWORD inputSQWORD(void)\n{\n    SQWORD sqNumber = 0;\n    SQWORD sqMultiplier = 1;\n    bool bRead = false;\n    for (;;) {\n        char c = getchar();\n        if (!bRead) {\n            if ('-' == c) {\n                sqMultiplier = -1;\n            }\n        }\n        if (('0' <= c) && (c <= '9')) {\n            sqNumber *= 10LL;\n            sqNumber += (SQWORD)(c - '0');\n            bRead = true;\n        } else {\n            if (bRead) {\n                return sqNumber * sqMultiplier;\n            }\n        }\n    }\n}\n\n\nstatic inline SDWORD inputSDWORD(void)\n{\n    SDWORD lNumber = 0;\n    SDWORD lMultiplier = 1;\n    bool bRead = false;\n    for (;;) {\n        char c = getchar();\n        if (!bRead) {\n            if ('-' == c) {\n                lMultiplier = -1;\n            }\n        }\n        if (('0' <= c) && (c <= '9')) {\n            lNumber *= 10;\n            lNumber += (c - '0');\n            bRead = true;\n        } else {\n            if (bRead) {\n                return lNumber * lMultiplier;\n            }\n        }\n    }\n}\n\nstatic inline DOUBLE inputFP(void)\n{\n    DOUBLE dInt = 0.0;\n    DOUBLE dFrac = 0.0;\n    DOUBLE dMultiplier = 1.0;\n    DWORD dwFpCnt = 0;\n    DOUBLE *pdCur = &dInt;\n    bool bRead = false;\n    for (;;) {\n        char c = getchar();\n        if (!bRead) {\n            if ('-' == c) {\n                dMultiplier = -1;\n            }\n        }\n        if ('.' == c) {\n            pdCur = &dFrac;\n        } else if (('0' <= c) && (c <= '9')) {\n            (*pdCur) *= 10;\n            (*pdCur) += (DOUBLE)(c - '0');\n            bRead = true;\n            if (pdCur == &dFrac) {\n                dwFpCnt++;\n            }\n        } else {\n            if (bRead) {\n                return dMultiplier * (dInt + dFrac / (pow((DOUBLE)10.0 , (DOUBLE)dwFpCnt)));\n            }\n        }\n    }\n}\n\n\n/**\n *  mod による操作ライブラリ\n */\n\n#define ANS_MOD (1000000007LL)\n \nstatic SQWORD addMod(SQWORD x, SQWORD y)\n{ \n    return (x + y) % ANS_MOD;\n}\n \nstatic SQWORD subMod(SQWORD x, SQWORD y)\n{\n    return (x - y + ANS_MOD) % ANS_MOD;\n}\n \nstatic SQWORD mulMod(SQWORD x, SQWORD y) \n{\n    return (x * y) % ANS_MOD;\n}\n \nstatic SQWORD powMod(SQWORD x, SQWORD e) {\n    SQWORD v = 1;\n    for (; e; x = mulMod(x, x), e >>= 1) {\n        if (e & 1) {\n            v = mulMod(v, x);\n        }\n    }\n    return v;\n}\n \nstatic SQWORD divMod(SQWORD x, SQWORD y)\n{\n    return mulMod(x, powMod(y, ANS_MOD - 2));\n}\n \n \nstatic SQWORD combMod(SQWORD n, SQWORD k)\n{\n    SQWORD v=1;\n    for(SQWORD i=1; i<=k; i++) {\n        v = divMod(mulMod(v, n-i+1),i);\n    } \n    return v;\n}\n\n/*----------------------------------------------*/\n\ntypedef struct {\n    SDWORD lTo;\n    SQWORD sqCap;\n    SQWORD sqCost;\n    SDWORD lRev;\n} ST_EDGE;\n\n#define MAX_V   (402)\n\nstruct Flow {\nprivate:\n    vector<ST_EDGE> avGraph[MAX_V];\n    SDWORD  alDimsFrom[MAX_V];\n    SDWORD  alDimsTo[MAX_V];\n    SQWORD  sqEdgeNum;\n    SQWORD  asqDist[MAX_V];\n    SDWORD  alPrevV[MAX_V];   \n    SDWORD  alPrevEdge[MAX_V];      /*直前の頂点と辺 */\n\n    SDWORD  alDinic_Level[MAX_V];\n    SDWORD  alDinic_Iter[MAX_V];\n\npublic:\n    Flow() {\n        for (auto v: avGraph) {\n            v.clear();\n        }\n        memset(alDimsFrom, 0, sizeof(alDimsFrom));\n        memset(alDimsTo, 0, sizeof(alDimsTo));\n        memset(asqDist, 0, sizeof(asqDist));\n        memset(alPrevV, 0, sizeof(alPrevV)); \n        memset(alPrevEdge, 0, sizeof(alPrevEdge));\n        memset(alDinic_Level, 0, sizeof(alDinic_Level));\n        memset(alDinic_Iter, 0, sizeof(alDinic_Iter));\n    }\n    void addEdge(SDWORD lFrom, SDWORD lTo, SQWORD sqCap, SQWORD sqCost) {\n//        printf(\"%d ----[%lld] ----> %d\\n\", lFrom, sqCap, lTo);\n        \n        alDimsFrom[lFrom]++;\n        alDimsTo[lTo]++;\n        avGraph[lFrom].push_back((ST_EDGE){lTo, sqCap, sqCost, (SDWORD)(avGraph[lTo].size())});\n        avGraph[lTo].push_back((ST_EDGE){lFrom, 0, -sqCost, (SDWORD)(avGraph[lFrom].size() - 1)});\n    }\n\n    SDWORD minCostFlow(SDWORD lStart, SDWORD lTarget, SQWORD sqFlow)\n    {\n        SQWORD sqRes = 0;\n        SQWORD sqFlowRest = sqFlow;\n        while (0 < sqFlowRest) {\n            /* Bellman-Ford Method */\n            fill(asqDist, asqDist + ArrayLength(asqDist), MAX_SDWORD);\n            asqDist[lStart] = 0;\n            bool bIsUpdate = true;\n            while (bIsUpdate) {\n                bIsUpdate = false;\n                for (SDWORD lV = 0; lV < MAX_V; lV++) {\n                    for (SDWORD lIdx = 0; lIdx < avGraph[lV].size(); lIdx++) {\n                        ST_EDGE &stE = avGraph[lV][lIdx];\n                        if ((asqDist[lV] != MAX_SDWORD)\n                                && (0 < stE.sqCap)\n                                && (asqDist[lV] + stE.sqCost < asqDist[stE.lTo])) {\n                            asqDist[stE.lTo] = asqDist[lV] + stE.sqCost;\n                            alPrevV[stE.lTo] = lV;\n                            alPrevEdge[stE.lTo] = lIdx;\n                            bIsUpdate = true;\n                        }\n                    }\n                }\n            }\n            if (asqDist[lTarget] == MAX_SDWORD) {\n                return -1;\n            }\n\n            SQWORD sqAddFlow = MAX_SQWORD;\n            for (SDWORD lV = lTarget; lV != lStart; lV = alPrevV[lV]) {\n                sqAddFlow = min(sqAddFlow, avGraph[alPrevV[lV]][alPrevEdge[lV]].sqCap);\n            }\n            sqFlowRest -= sqAddFlow;\n            sqRes += sqAddFlow * asqDist[lTarget];      // 後で目的変数は書き換える\n            for (SDWORD lV = lTarget; lV != lStart; lV = alPrevV[lV]) {\n                ST_EDGE &stE = avGraph[alPrevV[lV]][alPrevEdge[lV]];\n                stE.sqCap -= sqAddFlow;\n                avGraph[lV][stE.lRev].sqCap += sqAddFlow;\n            }\n        }\n        return sqRes;\n    }\n\nprivate:\n    SQWORD maxFlowDinicBfs(SDWORD lS)\n    {\n        memset(alDinic_Level, -1, sizeof(alDinic_Level));\n        queue<SDWORD> queSearch;\n        alDinic_Level[lS] = 0;\n        queSearch.push(lS);\n        while (!queSearch.empty()) {\n            SDWORD lV = queSearch.front();\n            queSearch.pop();\n            for (SDWORD lIdx = 0; lIdx < avGraph[lV].size(); lIdx++) {\n                ST_EDGE &stE = avGraph[lV][lIdx];\n                if ((0 < stE.sqCap) && (alDinic_Level[stE.lTo] < 0)) {\n                    alDinic_Level[stE.lTo] = alDinic_Level[lV] + 1;\n                    queSearch.push(stE.lTo);\n                }\n            }\n        }\n\n        return 0;\n    }\n\n    SQWORD maxFlowDinicDfs(SDWORD lV, SDWORD lT, SQWORD sqF)\n    {\n        if (lV == lT) {\n            return sqF;\n        }\n        for (SDWORD &lI = alDinic_Iter[lV]; lI < avGraph[lV].size(); lI++) {\n            ST_EDGE &stE = avGraph[lV][lI];\n            if ((0 < stE.sqCap) && (alDinic_Level[lV] < alDinic_Level[stE.lTo])) {\n                SQWORD sqDiffFlow = maxFlowDinicDfs(stE.lTo, lT, min(sqF, stE.sqCap));\n                if (0 < sqDiffFlow) {\n                    stE.sqCap -= sqDiffFlow;\n                    avGraph[stE.lTo][stE.lRev].sqCap += sqDiffFlow;\n                    return sqDiffFlow;\n                }\n            }\n        }\n        return 0;\n    }\n\npublic:\n    SQWORD MaxFlow(SDWORD lStart, SDWORD lTarget)\n    {\n        SQWORD sqFlow = 0LL;\n        for (;;) {\n            maxFlowDinicBfs(lStart);\n            if (alDinic_Level[lTarget] < 0) {\n                return sqFlow;\n            }\n            memset(alDinic_Iter, 0, sizeof(alDinic_Iter));\n            while (1) {\n                SQWORD sqDiffFlow = maxFlowDinicDfs(lStart, lTarget, MAX_SQWORD);\n                sqFlow += sqDiffFlow;\n                if (0LL == sqDiffFlow) {\n                    break;\n                }\n            }\n        }\n    }\n\n    SQWORD getFlow(SDWORD lPnt, bool bFrom)\n    {\n        SQWORD sqCapSum = 0; \n        for (auto e: avGraph[lPnt]) {\n            sqCapSum += e.sqCap;\n        }\n        if (bFrom) {\n            return alDimsFrom[lPnt] - sqCapSum;\n        } else {\n            return alDimsTo[lPnt] - sqCapSum;\n        }\n    }\n};\n\n/*----------------------------------------------*/\n\nstatic void getPrimes(vector<SDWORD> &vlPrimes, SDWORD lMax)\n{\n    /* lSearchMax と ループ内の *2 の関係から、入力は3以上とすること */\n    if (!(1 <= lMax)) {\n        printf(\"Oops!\");\n        return;\n    }\n\n    /* 素数のリストを作る */\n    vector<bool> vbIsPrime(lMax + 1, true);\n    SDWORD lSearchMax = sqrt(lMax) + 1;\n    vbIsPrime[0] = false;\n    vbIsPrime[1] = false;\n    for (SDWORD lPrime = 2; lPrime < vbIsPrime.size(); lPrime++) {\n        if (vbIsPrime[lPrime]) {\n            vlPrimes.emplace_back(lPrime);\n            if (lPrime <= lSearchMax) {\n                for (SDWORD lCurNum = lPrime * 2; lCurNum <= lMax; lCurNum += lPrime) {\n                    vbIsPrime[lCurNum] = false;\n                }\n            }\n        }\n    }\n}    \n\n/*----------------------------------------------*/\n\n#define PNT_NO_START    (0)\n#define PNT_NO_OFFSET   (200)\n#define PNT_NO_TARGET   (401)\n#define FLOW_OFFSET     (1000000000)\n#define CAPACITY_INF    (1000000001)\n#define DUMMY_COST      (1)\n\nint main(void)\n{\n    SQWORD sqN = inputSQWORD();\n\n    Flow solverFlow;\n    vector<SQWORD> vsqA;\n    vector<SQWORD> vsqB;\n    vector<SDWORD> vlPrimes;\n\n    getPrimes(vlPrimes, 1e7 + 1);\n    vlPrimes.erase(find(vlPrimes.begin(), vlPrimes.end(), 2));\n\n    for (SQWORD sqIdx = 0; sqIdx < sqN; sqIdx++) {\n        SQWORD sqA = inputSQWORD();\n        vsqA.emplace_back(sqA);\n    }\n\n#if 1\n    for (auto it = vsqA.begin(); it != vsqA.end(); ++it) {\n//        printf(\"%lld %lld\\n\", *it, *(it - 1));\n        if (it == vsqA.begin()) {\n            vsqB.emplace_back(*it);\n        } else {\n            if ((*it) - 1 != *(it - 1)) {\n                vsqB.emplace_back(*it);\n            }\n        }\n        if (it == vsqA.end() - 1) {\n            vsqB.emplace_back((*it) + 1);\n        } else {\n            if ((*it) + 1 != *(it + 1)) {\n                vsqB.emplace_back((*it) + 1);\n            }\n        }\n    }\n#else\n    vsqB = vsqA;\n#endif\n\n    vector<SQWORD> vsqCOdd;\n    vector<SQWORD> vsqCEven;\n    \n    unordered_map<SQWORD, SQWORD> mapCEven, mapCOdd;\n\n    SQWORD sqIdx = 1;\n    for (auto b: vsqB) {\n        if (0 == b % 2) {\n            vsqCEven.emplace_back(b);\n            mapCEven[b] = sqIdx;\n        } else {\n            vsqCOdd.emplace_back(b);\n            mapCOdd[b] = sqIdx;\n        }\n        sqIdx++;\n    }\n\n    /* 二部マッチング */\n    for (auto c: vsqCEven) {\n        solverFlow.addEdge(PNT_NO_START, mapCEven[c], 1, DUMMY_COST);\n    }\n    for (auto c: vsqCEven) {\n        solverFlow.addEdge(mapCOdd[c] + PNT_NO_OFFSET, PNT_NO_TARGET, 1, DUMMY_COST);\n    }\n\n    for (auto p: vlPrimes) {\n        for (auto c: vsqCEven) {\n            auto it = lower_bound(vsqCOdd.begin(), vsqCOdd.end(), c + p);\n            if (it != vsqCOdd.end()) {\n                if (*it == c + p) {\n                    if (c + p < 1e7 + 1) {\n                        solverFlow.addEdge(mapCEven[c], mapCOdd[c + p] + PNT_NO_OFFSET, 1, DUMMY_COST);\n                    }\n                }\n            }\n        }\n    }\n\n    SQWORD sqMaxFlow = solverFlow.MaxFlow(PNT_NO_START, PNT_NO_TARGET);\n    SQWORD vsqCRestEven = 0;\n    SQWORD vsqCRestOdd = 0;\n    for (auto c: vsqCEven) {\n        SQWORD sqFlow = solverFlow.getFlow(mapCEven[c], true);\n        if (0 == sqFlow) {\n            vsqCRestEven++;\n        }\n    }\n    for (auto c: vsqCOdd) {\n        SQWORD sqFlow = solverFlow.getFlow(mapCOdd[c] + PNT_NO_OFFSET, false);\n        if (0 == sqFlow) {\n            vsqCRestOdd++;\n        }\n    }\n\n    SQWORD sqAns = sqMaxFlow;    \n    sqAns += (vsqCRestEven / 2) * 2;\n    sqAns += (vsqCRestOdd / 2) * 2;\n    if (0 < (vsqCRestEven %  2)) {\n        sqAns += 3;\n    }\n\n    printf(\"%lld\\n\", sqAns);\n\n    return 0;\n}\n/*------------------------------------------*/\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <bitset>\n#include <algorithm>\n#include <complex>\n#include <array>\nusing namespace std;\n \n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n#define ALL(c) (c).begin(), (c).end()\n \ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<VI> VVI;\ntypedef vector<VL> VVL;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\ntypedef vector<double> VD;\ntypedef vector<VD> VVD;\n\ntemplate<typename T> void chmin(T &a, T b) { if (a > b) a = b; }\ntemplate<typename T> void chmax(T &a, T b) { if (a < b) a = b; }\n\nint in() { int x; scanf(\"%d\", &x); return x; }\nll lin() { ll x; scanf(\"%lld\", &x); return x; }\n\nstruct bipartite_matching{\n    int n, x, y;\n    VVI e;\n    VI match;\n    vector<bool> used;\n\n    void init(int a, int b){\n        x = a;\n        y = b;\n        n = x + y;\n        e.resize(n);\n        match.resize(n);\n        used.resize(n);\n    }\n\n    void add_edge(int u, int v){\n        e[u].push_back(v + x);\n        e[v + x].push_back(u);\n    }\n\n    bool dfs(int v){\n        used[v] = true;\n        for (int u : e[v]){\n            int w = match[u];\n            if (w < 0 || (!used[w] && dfs(w))){\n                match[v] = u;\n                match[u] = v;\n                return true;\n            }\n        }\n        return false;\n    }\n\n    int calc_matching(){\n        int res = 0;\n        fill(ALL(match), -1);\n        REP(v,n){\n            if (match[v] < 0){\n                used.assign(n, 0);\n                if (dfs(v)) res++;\n            }\n        }\n        return res;\n    }\n};\n\nbool isprime(int x){\n    if (x <= 2) return false;\n    for (int i = 2; i * i <= x; i++){\n        if (x % i == 0) return false;\n    }\n    return true;\n}\n\nint main() {\n    int n;\n    cin >> n;\n    VI a(n);\n    REP(i,n) a[i] = in();\n    set<int> st;\n    REP(i,n){\n        if (st.count(a[i])) st.erase(a[i]);\n        else st.insert(a[i]);\n        st.insert(a[i] + 1);\n    }\n    VI odd, even;\n    for (int x : st){\n        // cout << x << endl;\n        if (x % 2) odd.push_back(x);\n        else even.push_back(x);\n    }\n    int x = odd.size(), y = even.size();\n    bipartite_matching bp;\n    bp.init(x, y);\n    REP(i,x) REP(j,y){\n        if (isprime(abs(odd[i] - even[j]))) bp.add_edge(i, j);\n    }\n    int c = bp.calc_matching();\n    x -= c;\n    y -= c;\n    int ans = c + x / 2 * 2 + y / 2 * 2 + 3 * (x % 2);\n    cout << ans << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#define fo(i,a,b) for(i=a;i<=b;i++)\nusing namespace std;\nconst int maxn=100+10;\nint x[maxn];\nbool bz[maxn];\nint i,j,k,l,t,n,m,ans;\nint main(){\n\tfo(i,2,100)\n\t\tif (!bz[i])\n\t\t\tfo(j,2,100/i) bz[i*j]=1;\n\tscanf(\"%d\",&n);\n\tfo(i,1,n) scanf(\"%d\",&x[i]);\n\ti=1;\n\twhile (i<=n){\n\t\tl=1;\n\t\twhile (i<n&&x[i+1]==x[i]+1){\n\t\t\ti++;\n\t\t\tl++;\n\t\t}\n\t\tif (l==1||l==2||l==4||l>=6&&l%2==0) ans+=2;\n\t\telse if (!bz[l]) ans++;\n\t\telse ans+=3;\n\t\ti++;\n\t}\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<cstring>\nusing namespace std;\nint n;\nint res;\nvector<int>v;\nint lst=-1;\nint match[210];\nint me,mo;\nint mx;\nvector<int>ok[210];\nbool vis[210];\nbool bp(int x)\n{\n\tfor(int i=0;i<ok[x].size();i++)\n\t{\n\t\tint y=ok[x][i];\n\t\tif(vis[y])continue;\n\t\tvis[y]=true;\n\t\tif(match[y]==-1 || bp(match[y]))\n\t\t{\n\t\t\tmatch[y]=x;\n\t\t\treturn true;\n\t\t}\n\t\tvis[y]=false;\n\t}\n\treturn false;\n}\nbool isp(int x)\n{\n\tif(x==1)return false;\n\tfor(int i=2;i*i<=x;i++)\n\t{\n\t\tif(x%i==0)return false;\n\t}\n\treturn true;\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint x;\n\t\tscanf(\"%d\",&x);\n\t\tif(x!=lst+1)\n\t\t{\n\t\t\tif(lst+1)v.push_back(lst+1);\n\t\t\tv.push_back(x);\n\t\t}\n\t\tlst=x;\n\t\tmx=lst+1;\n\t}\n\tv.push_back(lst+1);\n\tint l=v.size();\n\tfor(int i=0;i<l;i++)\n\t{\n\t\tmatch[i]=-1;\n\t\tif(v[i]&1)mo++;else me++;\n\t\tfor(int j=i+1;j<l;j++)\n\t\t{\n\t\t\tif(v[j]-v[i]!=2 && isp(v[j]-v[i]))\n\t\t\t{\n\t\t\t\tok[i].push_back(j);\n\t\t\t\tok[j].push_back(i);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<l;i++)\n\t{\n\t\tmemset(vis,false,sizeof(vis));\n\t\tif(bp(i))res++;\n\t}\n\tres/=2;\n\tprintf(\"%d\",res+((me-res)/2+(mo-res)/2)*2+((me-res)%2)*3);\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define pb push_back\n#define x first\n#define y second\nusing namespace std;\ntypedef long long LL;\ntypedef vector<int> VI;\nusing namespace std;\nconst int NMAX=200666;\nconst int INF=1000000666;\nconst LL INFLL=1000000000000666;\nconst LL maxv=100000;\nconst long double PI = acos(-1.0);\nconst int MAXT = 200000;\n\nint A[105];\nint dp[105];\nint n;\n\nmap<int, bool> M;\n\nbool isprime(int x){\n  int i = 2;\n  int q = 1;\n  if(x == 1){\n    q = 0;\n  }\n  while(i*i <= x){\n    if((x%i) == 0){\n      q=0; \n    }\n    i++;\n  }\n  return q;\n}\n\nint cost(int x){\n  if(x <= 0){\n    return 0;\n  }\n  if((x%2) == 0){\n    return 2;\n  }\n  else{\n    if(M[x] == 2){\n      return 1;\n    }\n    else\n    {\n      return 3;\n    }\n    if(!M[x]){\n      if(isprime(x)){\n        return 1;\n        M[x] = 2;\n      }\n      else{\n        return 3;\n        M[x] = 1;\n      }\n\n    }\n  }\n}\n\nvoid solve(){\n\n  cin>>n;\n  for(int i=1; i<=n; ++i){\n    cin>>A[i];\n  }\n\n  for(int i=1; i<=103; ++i){\n    dp[i] = INF;\n  }\n  //cout<<n<<\"\\n\";\n\n  dp[0] = 0;\n\n  for(int i=1; i<=n; ++i){\n    for(int j=1; j<=i; ++j){\n\n      int ss = cost(A[i] - A[j] + 1);\n      for(int k=j+1; k<=i; ++k){\n        ss += cost(A[k] - A[k-1] - 1);\n      }\n\n      dp[i] = min(dp[i], dp[j-1] + ss);\n    }\n    //cout<<dp[i]<<\" \"<<i<<\"\\n\";\n  }\n  cout<<dp[n]<<\"\\n\";\n\n}\n\n\nint main()\n{\n    // Tic\n    //clock_t t=clock();\n    cout<<setprecision(10)<<fixed;\n    ios_base::sync_with_stdio(0);\n\n    //freopen(\"simetrii.in\", \"rt\", stdin);\n    //freopen(\"simetrii.out\", \"wt\", stdout);\n\n    solve();\n\n    //Toc\n    //t=clock()-t;\n    //printf (\"It took me %d clicks (%f seconds).\\n\",t,((float)t)/CLOCKS_PER_SEC);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define ii pair <int, int>\n#define app push_back\n#define all(a) a.begin(), a.end()\n#define bp __builtin_popcountll\n#define ll long long\n#define mp make_pair\n#define f first\n#define s second\n#define Time (double)clock()/CLOCKS_PER_SEC\n#define debug(x) std::cout << #x << \": \" << x << '\\n';\n\nconst int N = 207;\n\nbool used[N];\n\nstruct Edge {\n    int u, v, c;\n    bool operator < (Edge e) {\n        return c < e.c;\n    }   \n};\n\nconst int INF = 1e9+7, C = 1e7+7;\n\nbool p[C];\n\nint get(int a, int b) {\n    if (b < a)\n        swap(a, b);\n\n    if (b - a == 1)\n        return INF;\n\n    if ((b - a) % 2 == 0)\n        return 2;\n    else if (p[b-a])\n        return 1;\n    else\n        return 3;\n}\n\nint cost[N][N];\n\nsigned main() {\n    #ifdef HOME\n    freopen(\"input.txt\", \"r\", stdin);\n    #else\n    #define endl '\\n'\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    #endif\n    for (int i = 2; i < C; ++i)\n        p[i] = 1;\n    for (int i = 2; i < C; ++i) \n        if (p[i])\n            for (int j = i * 2; j < C; j += i)\n                p[j] = 0;\n\n    int n;\n    cin >> n;\n    map <int, int> d;\n    while (n--) {\n        int x;\n        cin >> x;\n        d[x] ^= 1;\n        d[x+1] ^= 1;        \n    }\n\n    vector <int> c;\n    for (auto e : d) {\n        if (e.s)\n            c.app(e.f);\n    }   \n\n    #ifdef HOME\n    cout << \"C : \";\n    for (auto e : c)\n        cout << e << ' ';\n    cout << endl;\n    #endif\n\n    vector <Edge> ed;        \n    for (int i = 0; i < c.size(); ++i) {\n        for (int j = i + 1; j < c.size(); ++j) {\n            cost[i][j] = get(c[i], c[j]);\n            ed.app({i, j, cost[i][j]});\n        }   \n    }    \n    sort(all(ed));\n    int ans = 0;\n    for (auto e : ed) {\n        if (!used[e.u] && !used[e.v]) {\n            used[e.u] = used[e.v] = 1;\n            ans += e.c;\n        }   \n    }   \n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<cmath>\nconst int N=102;\nint n,cnp,cnj,cnt,og[N],hx[N<<1],fir[N<<1],prm[460];\nbool npr[3200];\nstruct edge{\n\tint to,wi,nx;\n}eg[N*N];\n\ninline void add(int a,int b,int v){\n\tstatic int cnt=1;\n\teg[++cnt]=(edge){b,v,fir[a]};\n\tfir[a]=cnt;\n\teg[++cnt]=(edge){a,0,fir[b]};\n\tfir[b]=cnt;\n}\n\ninline char get_c(){\n\tstatic char buf[20000],*h,*t;\n\tif(h==t){\n\t\tt=(h=buf)+fread(buf,1,20000,stdin);\n\t}\n\treturn h==t?EOF:*h++;\n}\n\ninline int nxi(){\n\tint x=0;\n\tchar c;\n\twhile((c=get_c())>'9'||c<'0');\n\twhile(x=x*10-48+c,(c=get_c())>='0'&&c<='9');\n\treturn x;\n}\n\ninline void init(){\n\tnpr[1]=1;\n\tfor(int i=2;i<3200;++i){\n\t\tif(!npr[i]) prm[++cnp]=i;\n\t\tfor(int j=1;j<=cnp&&i*prm[j]<3200;++j){\n\t\t\tnpr[i*prm[j]]=1;\n\t\t\tif(i%prm[j]==0) break;\n\t\t}\n\t}\n}\n\ninline bool ispr(int x){\n\tif(x<3200) return !npr[x];\n\tint sq=sqrt(x)+1;\n\tfor(int i=1;prm[i]<=sq;++i){\n\t\tif(x%prm[i]==0) return 0;\n\t}\n\treturn 1;\n}\n\nnamespace F{\n\tint dep[N<<1],que[N<<1],cur[N<<1];\n\n\tinline bool bfs(){\n\t\tmemset(dep,0,sizeof(dep));\n\t\tint hd=0,tl=1;\n\t\tdep[0]=1;\n\t\twhile(hd!=tl){\n\t\t\tint x=que[hd++];\n\t\t\tfor(int i=cur[x]=fir[x];i;i=eg[i].nx){\n\t\t\t\tint y=eg[i].to;\n\t\t\t\tif(eg[i].wi&&!dep[y]){\n\t\t\t\t\tdep[y]=dep[x]+1;\n\t\t\t\t\tque[tl++]=y;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn dep[(N<<1)-1];\n\t}\n\n\tint dfs(int x,int t){\n\t\tif(x==(N<<1)-1) return t;\n\t\tint tp,tt=t;\n\t\tfor(int &i=cur[x];i;i=eg[i].nx){\n\t\t\tint y=eg[i].to,v=eg[i].wi;\n\t\t\tif(v&&tt&&dep[x]+1==dep[y]&&(tp=dfs(y,std::min(v,tt)))){\n\t\t\t\teg[i].wi-=tp;\n\t\t\t\teg[i^1].wi+=tp;\n\t\t\t\ttt-=tp;\n\t\t\t\tif(!tt) break;\n\t\t\t}\n\t\t}\n\t\treturn t-tt;\n\t}\n}\n\nint main(){\n#ifndef ONLINE_JUDGE\n//\tfreopen(\"c.in\",\"r\",stdin);\n#endif\n\tinit();\n\tn=nxi();\n\tfor(int i=1;i<=n;++i){\n\t\tog[i]=nxi();\n\t}\n\tstd::sort(og+1,og+n+1);\n\tog[0]=-1;\n\tfor(int i=1;i<=n;++i){\n\t\tif(og[i]-og[i-1]>1){\n\t\t\tif(og[i-1]+1) hx[++cnt]=og[i-1]+1;\n\t\t\thx[++cnt]=og[i];\n\t\t}\n\t}\n\thx[++cnt]=og[n]+1;\n\tfor(int i=1;i<=cnt;++i){\n\t\tif(hx[i]&1) ++cnj;\n\t\tif(hx[i]&1) add(0,i,1);\n\t\telse add(i,(N<<1)-1,1);\n\t\tfor(int j=i+1;j<=cnt;++j){\n\t\t\tint p=hx[j]-hx[i];\n\t\t\tif((p&1)&&ispr(p)){\n\t\t\t\tif(hx[i]&1) add(i,j,1);\n\t\t\t\telse add(j,i,1);\n\t\t\t}\n\t\t}\n\t}\n\tint ans=0;\n\twhile(F::bfs()){\n\t\tans+=F::dfs(0,N);\n\t}\n\tprintf(\"%d\\n\",cnt-ans+((cnj-ans)&1));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int max_n = 1e2 + 5, max_x = 1e7 + 5;\n\nbool sito[max_x];\n\nint dodaj(int x){\n    if (x % 2){\n        if (!sito[x])\n            return 1;\n        else\n            return 3;\n    }\n    return 2;\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    sito[1] = true;\n    for (int i = 2; i * i <= 1e7; i++)\n        if (!sito[i])\n            for (int j = i * i; j <= 1e7; j += i)\n                sito[j] = true;\n    int n, poprzedni_1 = 0, aktu_1 = 0, ile = 0, wynik = 0, poprzedni_2 = 0, aktu_2 = 0, koniec = 0, pom_1, pom_2 = 0, ile_o;\n    cin >> n;\n    for (int i = 0; i < n; i++){\n        cin >> pom_1;\n        if (i && pom_1 != pom_2 + 1){\n            wynik += dodaj(ile);\n            if (koniec){\n                aktu_1 = poprzedni_2 + dodaj(ile_o) + dodaj(ile) - dodaj(pom_2 - ile - koniec);\n                aktu_2 = max(poprzedni_1, poprzedni_2);\n                poprzedni_1 = aktu_1;\n                poprzedni_2 = aktu_2;\n            }\n            koniec = pom_2;\n            ile_o = ile;\n            ile = 0;\n        }\n        pom_2 = pom_1;\n        ile++;\n    }\n    wynik += dodaj(ile);\n    if (koniec){\n        aktu_1 = poprzedni_2 + dodaj(pom_2 - ile - koniec);\n        aktu_2 = max(poprzedni_1, poprzedni_2);\n        poprzedni_1 = aktu_1;\n        aktu_2 = poprzedni_2;\n    }\n    //cout << sito[9999539] << \"\\n\";\n    cout << wynik - max(aktu_1, aktu_2) << \"\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<cstring>\nusing namespace std;\nint n;\nint res;\nvector<int>v;\nint lst=-1;\nint match[210];\nint me,mo;\nint mx;\nbool f[10000010];\nvector<int>ok[210];\nint vis[210];\nint prm[1000010];\nint sz;\nint l;\nbool bp(int x,int p)\n{\n\tvis[x]=p;\n\tfor(int i=0;i<ok[x].size();i++)\n\t{\n\t\tint y=ok[x][i];\n\t\tif(vis[y])continue;\n\t\tif(match[y]!=-1 && vis[match[y]]==p)continue;\n\t\tif(match[y]==-1 || bp(match[y],p))\n\t\t{\n\t\t\tmatch[y]=x;\n\t\t\tmatch[x]=y;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint x;\n\t\tscanf(\"%d\",&x);\n\t\tif(x!=lst+1)\n\t\t{\n\t\t\tif(lst+1)v.push_back(lst+1);\n\t\t\tv.push_back(x);\n\t\t}\n\t\tlst=x;\n\t\tmx=lst+1;\n\t}\n\tv.push_back(lst+1);\n\tf[1]=true;\n\tfor(int i=2;i<=mx;i++)\n\t{\n\t\tif(!f[i])prm[++sz]=i;\n\t\tfor(int j=1;j<=sz;j++)\n\t\t{\n\t\t\tif(prm[j]*i>mx)break;\n\t\t\tf[prm[j]*i]=true;\n\t\t\tif(i%prm[j]==0)break;\n\t\t}\n\t}\n\tl=v.size();\n\tfor(int i=0;i<l;i++)\n\t{\n\t\tmatch[i]=-1;\n\t\tif(v[i]&1)mo++;else me++;\n\t\tfor(int j=i+1;j<l;j++)\n\t\t{\n\t\t\tif(v[j]-v[i]!=2 && !f[v[j]-v[i]])\n\t\t\t{\n\t\t\t\tok[i].push_back(j);\n\t\t\t\tok[j].push_back(i);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<l;i++)\n\t{\n\t\tmemset(vis,0,sizeof(vis));\n\t\tif(bp(i,i+1))res++;\n\t}\n\tprintf(\"%d\",res+((me-res)/2+(mo-res)/2)*2+((me-res)%2)*3);\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <algorithm>\n#include <cmath>\n#include <cstring>\n#include <complex>\n\nusing namespace std;\n\n//typedef\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long ll;\n\n#define omajinai ios::sync_with_stdio(false);cin.tie(0)\n\n//container util\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define UNIQUE(a)  (a).erase(unique((a).begin(),(a).end()),(a).end())\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(auto i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n#define RFOR(i,b,a) for(int i=(b)-1;i>=(a);--i)\n#define RREP(i,n) RFOR(i,n,0)\n\n//debug\n#define dump(x)  cerr << \"[L \" << __LINE__ << \"] \" << #x << \" = \" << (x) << \"\\n\";\n\n// i love camel\n\n/// flow\nstruct edge {int to, cap, rev;}; // rev Index\nconst int _V = 200 + 2; // _N + source + sink\nvector<edge> G[_V];\nbool used[_V];\n\nvoid addEdge(int from, int to){\n\tG[from].push_back((edge) {to, 1, G[to].size()});\n\tG[to].push_back((edge) {from, 0, G[from].size() - 1}); // rev\n}\n\nint dfs(int v, int t){\n\tif(v==t)return 1;\n\tused[v] = true;\n\tREP(i, G[v].size()){\n\t\tedge &e = G[v][i];\n\t\tif(!used[e.to] && e.cap > 0){\n\t\t\tint d = dfs(e.to, t);\n\t\t\tif(d){\n\t\t\t\te.cap -= d;\n\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint maxFlow(int s, int t){\n\tint flow=0;\n\twhile(true){\n\t\tmemset(used, 0, sizeof used);\n\t\tint p = dfs(s, t);\n\t\tif(!p)return flow;\n\t\tflow += p;\n\t}\n}\n\n///\n\nbool isPrime(int x){\n\tif(x==1)return false;\n\tfor(int i=2;i*i<=x;i++){\n\t\tif(x%i==0)return false;\n\t}\n\treturn true;\n}\n\nVI diff_odd, diff_even;\nint main() {\n\tint n;\n\tcin >> n;\n\tint last=-1;\n#define ADD(a) ((a)%2 ? diff_odd : diff_even).push_back(a)\n\tREP(i, n){\n\t\tint x;\n\t\tcin >> x;\n\t\tif(x!=last+1){ // not 隣接\n\t\t\tif(last>0)ADD(last);\n\t\t\tADD(x-1);\n\t\t}\n\t\tlast = x;\n\t}\n\tADD(last);\n\tREP(i, diff_odd.size())addEdge(200, i);\n\tREP(j, diff_even.size())addEdge(j + diff_odd.size(), 201);\n\tREP(i, diff_odd.size()){\n\t\tREP(j, diff_even.size()){\n\t\t\tint o = diff_odd[i], e = diff_even[j];\n\t\t\tif(isPrime(abs(o-e)))addEdge(i, j + diff_odd.size());\n\t\t}\n\t}\n\tint ans, k = ans = maxFlow(200, 201);\n\tans += (diff_odd.size() - k)/2*2;\n\tans += (diff_even.size() - k)/2*2;\n\tans += (diff_odd.size() - k) % 2 * 3;\n\tcout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n#include<cstdlib>\n\nusing namespace std;\n\nusing vi = vector<int>;\nvi X;\nint n;\nvector<vi> C;\nint used[207];\nbool isprime(int n) {\n\tif (n <= 2)return false;\n\tfor (int i = 2; i*i <= n; i++) {\n\t\tif (n%i == 0)return false;\n\t}\n\treturn true;\n}\nbool dfs(int v) {\n\tused[v] = true;\n\tfor (int i = 0; i < X.size() + 2; i++) {\n\t\tif (!used[i] && C[v][i] > 0) {\n\t\t\tif (dfs(i)) {\n\t\t\t\tC[v][i]--;\n\t\t\t\tC[i][v]++;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\nint main() {\n\tcin >> n;\n\tvi evens;\n\tvi odds;\n\tfor (int i = 0; i < n; i++) {\n\t\tint x;\n\t\tcin >> x;\n\t\tif (!X.empty() && X.back() == x) {\n\t\t\tX.pop_back();\n\t\t\tX.push_back(x + 1);\n\t\t}\n\t\telse {\n\t\t\tX.push_back(x);\n\t\t\tX.push_back(x + 1);\n\t\t}\n\t}\n\tint E = 0;\n\tint O = 0;\n\tfor (int x : X) {\n\t\tif (x % 2 == 0) {\n\t\t\tE++;\n\t\t}\n\t\telse {\n\t\t\tO++;\n\t\t}\n\t}\n\t\t\n\tC.resize(X.size()+2, vi(X.size()+2, 0));\n\tfor (int i = 0; i < X.size(); i++) {\n\t\tif (X[i] % 2 == 0) {\n\t\t\tC[X.size()][i] = 1;\n\t\t}\n\t\telse {\n\t\t\tC[i][X.size() + 1] = 1;\n\t\t}\n\t}\n\tfor (int i = 0; i < X.size(); i++) {\n\t\tfor (int j = i; j < X.size(); j++) {\n\t\t\tif (isprime(abs(X[i] - X[j]))) {\n\t\t\t\tint a = i;\n\t\t\t\tint b = j;\n\t\t\t\tif (b % 2 == 0)swap(a, b);\n\t\t\t\tC[a][b] = 1;\n\t\t\t}\n\t\t}\n\t}\n\tint ans = 0;\n\twhile (dfs(X.size())) {\n\t\tmemset(used, false, sizeof(used));\n\t\tans++;\n\t}\n\tif ((E - ans) % 2 == 0) {\n\t\tcout << ans + (E - ans + O - ans) << endl;\n\t}\n\telse {\n\t\tcout << ans + (E - ans - 1 + O - ans - 1) + 3 << endl;\n\t}\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define RI register int\n\nusing namespace std;\n\nint Notprime[10000005], Prime[10000005], tot;\nvoid Euler(int MAX) {\n  Notprime[1] = 1;\n  for (RI i = 2; i <= MAX; ++i) {\n    if (!Notprime[i]) Prime[++tot] = i;\n    for (RI j = 1; j <= tot && Prime[j] * i <= MAX; ++j) {\n      Notprime[i * Prime[j]] = 1;\n      if (i % Prime[j] == 0) break;\n    }\n  }\n}\n\nint const MAXN = 505;\nstruct Edges {\n  int to, next;\n} e[MAXN * MAXN];\nint a[MAXN], odd[MAXN], even[MAXN], cnt1, cnt2;\nint vis[MAXN], fa[MAXN], head[MAXN], ttott;\n\ninline void Add(int k) { k & 1 ? odd[++cnt1] = k : even[++cnt2] = k; }\ninline void addedge(int from, int to) {\n  e[++ttott] = (Edges){to, head[from]};\n  head[from] = ttott;\n}\n\nbool xyl(int k) {\n  if (vis[k]) return 0;\n  vis[k] = 1;\n  for (RI i = head[k]; i; i = e[i].next)\n    if (!fa[e[i].to] || xyl(fa[e[i].to])) {\n      fa[e[i].to] = k;\n      return 1;\n    }\n  return 0;\n}\n\nint main() {\n//  freopen(\"prime.in\", \"r\", stdin);\n//  freopen(\"prime.out\", \"w\", stdout);\n  Euler(1e7);\n  int n; scanf(\"%d\", &n);\n  for (RI i = 1; i <= n; ++i) scanf(\"%d\", &a[i]);\n  sort(a + 1, a + 1 + n);\n  int last = a[1];\n  for (RI i = 2; i <= n; ++i)\n    if (a[i] != a[i - 1] + 1)\n      Add(last), Add(a[i - 1] + 1), last = a[i];\n  Add(last), Add(a[n] + 1);\n  for (RI i = 1; i <= cnt1; ++i)\n    for (RI j = 1; j <= cnt2; ++j)\n      if (!Notprime[abs(odd[i] - even[j])])\n        addedge(i, j);\n  int Sucs = 0;\n  for (RI i = 1; i <= cnt1; ++i, memset(vis, 0, sizeof(vis)))\n    if (xyl(i)) ++Sucs;\n  int ans = Sucs; cnt1 -= Sucs, cnt2 -= Sucs;\n  ans += cnt1 + cnt2;\n  ans += cnt1 & 1;\n  printf(\"%d\\n\", ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <iomanip>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <unordered_set>\n#include <unordered_map>\n#include <bitset>\n#include <limits>\n#include <random>\n#include <complex>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cassert>\nusing namespace std;\n\n#define REP(i,n) for (int i = 0; i < n; i++)\ntemplate <class T> using reversed_priority_queue = priority_queue<T, vector<T>, greater<T> >;\ntypedef long long ll;\n\ntemplate <class T> struct FordFulkerson {\n\n    vector < pair < int,int > > maching;\n\n    struct  Edge {\n        int to,rev; T cap;\n        Edge(int t, int r, T c) : to(t), rev(r), cap(c) {}\n    };\n    \n    const T INF = numeric_limits<T>::max() / 2;\n    vector< vector< Edge > > G;\n    vector< bool > used;\n    FordFulkerson (int n) : G(n+1), used(n+1) {}\n   \n    void add_edge(int from, int to, T cap) {\n        G[from].push_back(Edge(to,(int)G[to].size(),cap));\n        G[to].push_back(Edge(from,(int)G[from].size()-1,0));\n    }\n    \n    T dfs(int v, int t, T f) {\n        if (v == t) return f;\n        used[v] = true;\n        for (int i = 0; i < G[v].size(); i++) {\n            Edge &e = G[v][i];\n            if (!used[e.to] && e.cap > 0) {\n                T d = dfs(e.to, t, min(f,e.cap));\n                if (d > 0) {\n                    if (v != 990 && e.to != 991) {\n                        maching.push_back(make_pair(v, e.to - 500));\n                    }\n                    e.cap -= d;\n                    G[e.to][e.rev].cap += d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n   \n    T get_max (int source, int sink) {\n        T flow = 0;\n        while (true) {\n            for (int i = 0; i < used.size(); i++) used[i] = false;\n            T f = dfs(source, sink, INF);\n            if (f == 0) return flow;\n            flow += f;\n        }\n    }\n    \n};\n\n\nbool isPrime(long long n) {\n    if (n <= 2) return false;\n    for (long long i = 2; i * i <= n; i++) if (n % i == 0) return false;\n    return true;\n}\n\nbool flip[10000010];\n\nint main ()\n{\n    int N;\n    cin >> N;\n    vector < int > x(N);\n    REP(i,N) cin >> x[i];\n\n    REP(i,N) {\n        flip[x[i]] = !flip[x[i]];\n        flip[x[i] + 1] = !flip[x[i] + 1];\n    }\n\n    vector < int > xt;\n    for (int i = 0; i < 10000010; i++) {\n        if (flip[i]) xt.push_back(i);\n    }\n\n    FordFulkerson < int > inst(1000);\n    for (int i = 0; i < xt.size(); i++) {\n        for (int j = i; j < xt.size(); j++) {\n            if (i == j) continue;\n            int diff = abs(xt[i] - xt[j]);\n            if (isPrime(diff)) {\n                inst.add_edge(i, j + 500, 1);\n            }\n        }\n    }\n    REP(i,N) {\n        inst.add_edge(990, i, 1);\n        inst.add_edge(i + 500, 991, 1);\n    }\n\n    int maxt = inst.get_max (990, 991);\n    vector < pair < int,int > > mc = inst.maching;\n    \n    REP(i,mc.size()) {\n        xt[mc[i].first]  = -1;\n        xt[mc[i].second] = -1;\n    }\n\n    int ans = maxt;\n    REP(i,xt.size()) {\n        REP(j,xt.size()) {\n            if (i == j) continue;\n            if (xt[i] == -1) continue;\n            if (xt[j] == -1) continue;\n            if (abs(xt[i] - xt[j]) % 2 == 0) {\n                xt[i] = -1;\n                xt[j] = -1;\n                ans += 2;\n            }\n        }\n    }\n\n    int sum = 0;\n    REP(i,xt.size()) {\n        if (xt[i] != -1) {\n            sum += 3;\n        }\n    }\n\n    ans += sum / 2;\n    cout << ans << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define MX 205\n#define MP 10000005\nint x[MX];\nvector<int> v;\nvector<int> g[MX];\nbool vis[MX];\nint lnk[MX];\nbool f[MP] = {1, 1};\n\nint dfs(int u) {\n\tfor(auto v : g[u]) {\n\t\tif(vis[v]) continue;\n\t\tvis[v] = true;\n\t\tif(lnk[v] < 0 || dfs(lnk[v])) {\n\t\t\tlnk[v] = u;\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nint main() {\n\tfor(int i = 2; i < MP; i++) {\n\t\tif(f[i]) continue;\n\t\tfor(int j = i + i; j < MP; j += i) f[j] = 1;\n\t} f[2] = 1;\n\tint n; scanf(\"%d\", &n);\n\tfor(int i = 0; i < n; i++) scanf(\"%d\", x + i);\n\tfor(int i = 0; i < n; i++) {\n\t\tif(x[i] + 1 != x[i + 1]) v.push_back(x[i]);\n\t\tif(!i || x[i] - 1 != x[i - 1]) v.push_back(x[i] - 1);\n\t}\n\tfor(int i = 0; i < v.size(); i++)\n\t\tfor(int j = 0; j < v.size(); j++)\n\t\t\tif(!f[abs(v[i] - v[j])]) g[i].push_back(j);\n\tint res = 0;\nmemset(lnk, 0xff, sizeof lnk);\n\tfor(int i = 0; i < v.size(); i++) {\n\t\tif(v[i] & 1) continue;\n\t\tmemset(vis, 0, sizeof vis);\n\t\tres += dfs(i);\n\t}\n\tint c[2] = {0};\n\tfor(auto u : v) c[u & 1]++;\n\tc[0] -= res; c[1] -= res;\n\tres += c[0] / 2 * 2; res += c[1] / 2 * 2;\n\tc[0] &= 1; c[1] &= 1;\n\tif(c[0] || c[1]) res += 3;\n\tprintf(\"%d\\n\", res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<cstring>\n\nusing namespace std;\nint n;\nconst int maxn = 1e7+5;//40M\nconst int S = 1e7+2;\nint pri[maxn],cnt; bool mk[maxn];\nint A[maxn];\nvoid oula() {\n\tmk[1] = mk[0] = 1;\n\tfor(int i=2;i<=S;i++) {\n\t\tif(!mk[i]) { pri[++cnt]=i; }\n\t\tfor(int j=1;j<=cnt&&1ll*pri[j]*i<=S;j++) {\n\t\t\tint k = pri[j]*i;\n\t\t\tmk[k] = 1;\n\t\t\tif(i%pri[j]==0) break;\n\t\t}\n\t}\n}\nint la[405],en[405*405],owo,nt[405*405];\nvoid adg(int x,int y) {\n\ten[++owo]=y; nt[owo]=la[x]; la[x]=owo;\n}\nint cc[2];\nint yo[2][405];\nint link[405],vis[405];\nint hungary(int x) {\n\tfor(int it=la[x];it;it=nt[it]) {\n\t\tint y = en[it];\n\t\tif(vis[y]) continue;\n\t\tvis[y] = 1;\n\t\tif((!link[y])||(hungary(link[y]))) {\n\t\t\tlink[y] = x; return 1;\n\t\t}\n\t}\n\treturn 0;\n}\nint main() {\n\toula();\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++) {\n\t\tint x; scanf(\"%d\",&x); A[x] = 1;\n\t}\n\tfor(int i=1;i<=S;i++) {\n\t\tint cf = A[i-1]^A[i];\n\t\tif(cf) {\n\t\t\t++cc[i&1];\n\t\t\tyo[i&1][ cc[i&1] ] = i;\n\t\t}\n\t}\n\tfor(int i=1;i<=cc[0];i++) {\n\t\tfor(int j=1;j<=cc[1];j++) {\n\t\t\tif(!mk[abs(yo[0][i]-yo[1][j])])\n\t\t\tadg(i,j);\n\t\t}\n\t}\n\tint ans = 0;\n\tfor(int i=1;i<=cc[0];i++) {\n\t\tfor(int j=1;j<=cc[1];j++) vis[j] = 0;\n\t\tans += hungary(i);\n\t}\n\tcc[0]-=ans; cc[1]-=ans;\n\tans += cc[0]/2*2 + cc[1]/2*2 + (cc[0]&1)*3;\n\tprintf(\"%d\",ans );\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<string> vs;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<int,P> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<30;\nconst ll INF=1ll<<60;\nconst double pi=acos(-1);\nconst double eps=1e-8;\nconst ll mod=1e9+7;\nconst int dx[4]={-1,0,1,0},dy[4]={0,-1,0,1};\n\nclass Graph{\n\tprivate:\n\tint n;\n\tvvi g;\n\tpublic:\n\tvi match,used;\n\tbool BM_dfs(int v){\n\t\tused[v]=1;\n\t\tfor(auto u:g[v]){\n\t\t\tint w=match[u];\n\t\t\tif(w<0||!used[w]&&BM_dfs(w)){\n\t\t\t\tmatch[v]=u;\n\t\t\t\tmatch[u]=v;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tint BM(){\n\t\tint res=0;\n\t\tmatch=vi(n,-1);\n\t\tfor(int i=0;i<n;i++) if(match[i]<0){\n\t\t\tused=vi(n);\n\t\t\tif(BM_dfs(i)) res++;\n\t\t}\n\t\treturn res;\n\t}\n\tGraph(int v){\n\t\tn=v;\n\t\tg=vvi(v);\n\t}\n\tvoid add_edge(int s,int t){\n\t\tg[s].push_back(t);\n\t\tg[t].push_back(s);\n\t}\n};\n\nint n;\nvi a;\n\nint main(){\n\tcin>>n;\n\ta=vi(n);\n\tfor(auto &i:a) cin>>i;\n\tvvi b(2);\n\tfor(int i=0;i<n;i++){\n\t\tif(i==0||a[i-1]!=a[i]-1){\n\t\t\tb[a[i]%2].push_back(a[i]);\n\t\t}\n\t\tif(i==n-1||a[i]!=a[i+1]-1){\n\t\t\tb[(a[i]+1)%2].push_back(a[i]+1);\n\t\t}\n\t}\n\tint n1=b[0].size(),n2=b[1].size();\n\tGraph g(n1+n2);\n\tfor(int i=0;i<n1;i++) for(int j=0;j<n2;j++){\n\t\tint t=abs(b[0][i]-b[1][j]);\n\t\tbool B=1;\n\t\tfor(int k=2;k*k<=t&&B;k++) if(t%k==0) B=0;\n\t\tif(t==1) B=0;\n\t\tif(B) g.add_edge(i,n1+j);\n\t}\n\tint t=g.BM(),res=t;\n\tn1-=t;n2-=t;\n\tres+=n1/2*2+n2/2*2;\n\tif(n1%2==1) res+=3;\n\tcout<<res<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<queue>\n#define N 210\n#define M 10000010\n#define ll long long\n#define inf 2147483647\nusing namespace std;\n\nstruct edge{int x, y, l, next;}a[100010];\nint n, m, last, x, w[N], l, P[M], p[N], flag[M], T, q[N], ans, lev[N], sum[2];\n\ninline void prev(){\n\tl=0; memset(flag, 0, sizeof(flag)); flag[1]=1;\n\tfor(int i=2; i<=10000000; i++){\n\t\tif(!flag[i])P[++l]=i;\n\t\tfor(int j=1; j<=l&&(ll)i*P[j]<=10000000; j++){\n\t\t\tflag[i*P[j]]=1;\n\t\t\tif(i%P[j]==0)break;\n\t\t}\n\t}\n}\n\ninline void add(int x, int y, int z){\n\ta[++l].x=x; a[l].y=y; a[l].l=z; a[l].next=p[x]; p[x]=l;\n\ta[++l].x=y; a[l].y=x; a[l].l=0; a[l].next=p[y]; p[y]=l;\n}\ninline int bfs(){\n\tqueue<int>q; q.push(0);\n\tmemset(lev, 0, sizeof(lev)); lev[0]=1;\n\twhile(!q.empty()){\n\t\tint v=q.front(); q.pop();\n\t\tfor(int i=p[v]; i; i=a[i].next)\n\t\t\tif(a[i].l&&!lev[a[i].y]){\n\t\t\t\tlev[a[i].y]=lev[v]+1;\n\t\t\t\tif(a[i].y==T)return 1;\n\t\t\t\tq.push(a[i].y);\n\t\t\t}\n\t}\n\treturn 0;\n}\ninline int dfs(int x, int ss){\n\tif(x==T||!ss)return ss;\n\tint s1=ss;\n\tfor(int i=q[x]; i&&ss; i=a[i].next)\n\t\tif(lev[a[i].y]==lev[x]+1){\n\t\t\tint tt=dfs(a[i].y, min(a[i].l, ss));\n\t\t\tss-=tt; a[i].l-=tt; a[i^1].l+=tt; q[x]=i;\n\t\t}\n\tif(s1==ss)lev[x]=-1;\n\treturn s1-ss;\n}\n\nint main(){\n\tscanf(\"%d\", &m); n=0; last=0;\n\tfor(int i=1; i<=m; i++){\n\t\tscanf(\"%d\", &x);\n\t\tif(last&&last+1<x){w[++n]=last+1; w[++n]=x;}\n\t\tif(!last)w[++n]=x;\n\t\tlast=x;\n\t}\n\tprev();\n\tw[++n]=last+1; sum[0]=sum[1]=0;\n\tl=1; memset(p, 0, sizeof(p)); T=n+1;\n\tfor(int i=1; i<=n; i++){\n\t\tif(w[i]&1){sum[1]++; add(i, T, 1);}\n\t\telse{sum[0]++; add(0, i, 1);}\n\t}\n\tfor(int i=1; i<=n; i++)if(!(w[i]&1))\n\t\tfor(int j=1; j<=n; j++)if(w[j]&1){\n\t\t\tx=max(w[i]-w[j], w[j]-w[i]);\n\t\t\tif(!flag[x])add(i, j, 1);\n\t\t}\n\tans=0; while(bfs()){memcpy(q, p, sizeof(q)); ans+=dfs(0, inf);}\n\tsum[0]-=ans; sum[1]-=ans;\n\tprintf(\"%d\", ans+sum[0]/2*2+sum[1]/2*2+(sum[0]&1)*3);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int maxp=1000050;\nint n;\nint sum[105],a[105],l[105],pos[105];\nint tot=0,tot1=0;\nint prime[maxp],primesize;\nbool isprime[maxp];\nvoid getlist(int listsize)\n{\n    memset(isprime,1,sizeof(isprime));\n    isprime[1]=false;\n    for(int i=2;i<=listsize;i++)\n    {\n        if(isprime[i]&&i!=2)\n\t\t\tprime[++primesize]=i;\n\t\tif(!isprime[i])\n\t\t\tcontinue;\n\t\tfor(int j=1;j<=primesize&&i*prime[j]<=listsize;j++)\n\t\t{\n            isprime[i*prime[j]]=false;\n            if(i%prime[j]==0)\n\t\t\t\tbreak;\n        }\n    }\n}\nint main() {\n\tgetlist(maxp-50);\n\tscanf(\"%d\",&n);\n\tsum[++tot]=1;\n\tfor(int i=1;i<=n;i++) {\n\t\tscanf(\"%d\",&a[i]);\n\t\tif(i==1)\n\t\t\tcontinue;\n\t\tif(a[i]==a[i-1]+1)\n\t\t\tsum[tot]++;\n\t\telse {\n\t\t\tif(sum[tot]==1) {\n\t\t\t\tl[++tot1]=tot;\n\t\t\t\tpos[tot1]=a[i-1];\n\t\t\t}\n\t\t\tsum[++tot]=1;\n\t\t}\n\t}\n\tif(sum[tot]==1) {\n\t\tl[++tot1]=tot;\n\t\tpos[tot1]=a[n];\n\t}\n\tint sumx=0;\n\tfor(int i=1;i<=tot;i++) {\n\t\tint tmp=sum[i];\n\t\tif(isprime[tmp]&&tmp!=2) {\n\t\t\tsumx++;\n\t\t\tcontinue;\n\t\t}\n\t\telse if(tmp%2==0) {\n\t\t\tsumx+=2;\n\t\t\tcontinue;\n\t\t}\n\t\telse if(tmp%2==1&&tmp!=1) {\n\t\t\tsumx+=3;\n\t\t\tcontinue;\n\t\t}\n\t\telse if(tmp==1)\n\t\t\tcontinue;\n\t}\n//\tcout<<tot1<<endl;\n\tfor(int i=1;i<=tot1;) {\n\t\tif(i<tot1) {\n\t\t\tif(l[i]==l[i+1]-1) {\n\t\t\t\tint tmp=pos[i+1],tmp1=pos[i];\n\t\t\t\tint tmp2=tmp-tmp1-1;\n\t\t\t\tint tmp3=tmp-tmp1;\n\t\t\t\tint tmp4=tmp-tmp1+1;\n\t\t\t\tif(isprime[tmp3]) {\n\t\t\t\t\tsumx+=2;\n\t\t\t\t\ti+=2;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\telse if(tmp2%2==0) {\n\t\t\t\t\tsumx+=4;\n\t\t\t\t\ti+=2;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\telse if(isprime[tmp2]&&isprime[tmp4]) {\n\t\t\t\t\tsumx+=2;\n\t\t\t\t\ti+=2;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\telse if((isprime[tmp2]&&!isprime[tmp4])||(isprime[tmp4]&&!isprime[tmp2])) {\n\t\t\t\t\tsumx+=4;\n\t\t\t\t\ti+=2;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\telse if(!isprime[tmp2]&&!isprime[tmp4]) {\n\t\t\t\t\tsumx+=6;\n\t\t\t\t\ti+=2;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsumx+=3;\n\t\t\t\ti++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\telse if(i==tot1) {\n\t\t\tsumx+=3;\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\t}\n\tprintf(\"%d\\n\",sumx);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int N=1005,M=40005,oo=1e9;\nstruct edge{\n\tint di,nextt,ed;\n}e[M];\nint son[N],nedge,cur[N],deep[N],n,m;\ninline void aedge(int a,int b,int c){\n\te[++nedge].nextt=son[a];\n\tson[a]=nedge;\n\te[nedge].ed=b;\n\te[nedge].di=c;\n}\ninline void insert(int a,int b,int c){\n\taedge(a,b,c); aedge(b,a,0); //cout<<a<<\" \"<<b<<endl;\n}\ninline bool bfs(int s,int t){\n\tfor(int i=1;i<N;i++)deep[i]=oo;\n    for(int i=1;i<N;i++)cur[i]=son[i];\n    deep[s]=0;\n    queue<int> q;\n    q.push(s);\n    while(!q.empty()){\n        int now=q.front();q.pop();\n        for(int tmp=son[now];tmp;tmp=e[tmp].nextt)\n            if(deep[e[tmp].ed]>=oo&&e[tmp].di){deep[e[tmp].ed]=deep[now]+1,q.push(e[tmp].ed);}\n    }\n    return deep[t]<oo;\n}\nint dfs(int now,int t,int limit){\n    if(!limit||now==t) return limit;\n    int flow=0,f;\n    for(int tmp=cur[now];tmp;tmp=e[tmp].nextt){\n        cur[now]=tmp;\n        if(deep[e[tmp].ed]==deep[now]+1&&(f=dfs(e[tmp].ed,t,min(limit,e[tmp].di)))){\n            flow+=f; limit-=f; e[tmp].di-=f; e[((tmp-1)^1)+1].di+=f; if(!limit)break;\n        }\n    }\n    return flow;\n}\ninline int dinic(int s,int t){\n    int ans=0;\n    while(bfs(s,t))ans+=dfs(s,t,oo);\n    return ans;\n}\ninline int read(){\n\tint x=0;char ch=getchar();bool positive=1;\n\tfor(;!isdigit(ch);ch=getchar())\tif(ch == '-')\tpositive=0;\n\tfor(;isdigit(ch);ch=getchar())\tx=x * 10 + ch - '0';\n\treturn positive ? x : -x;\n}\ninline void write(int a){\n    if(a>=10)write(a/10);\n    putchar('0'+a%10);\n}\ninline void writeln(int a){\n    if(a<0){\n    \ta=-a;putchar('-');\n\t}\n\twrite(a);puts(\"\");\n}\nconst int P=10000005;\nint tot,q[P/10];\nbool heshu[P],a[P];\nint b[205];\nint main(){\n    n=read();\n\tfor(int i=2;i<P;i++){\n\t\tif(!heshu[i])q[++tot]=i;\n\t\tfor(int j=1;j<=tot&&i*q[j]<P;j++){\n\t\t\theshu[i*q[j]]=1; if(i%q[j]==0)break;\n\t\t}\n\t}\n\ttot=0;\n\tfor(int i=1;i<=n;i++){\n\t\tint t=read(); a[t]^=1; a[t+1]^=1;\n\t}\n\theshu[1]=1;\n\tint jb=0;\n\tfor(int i=1;i<P;i++)if(a[i])b[++jb]=i;\n\tfor(int i=1;i<=jb;i++)if(b[i]&1){\n\t\tfor(int j=1;j<=jb;j++)if(b[j]%2==0){\n\t\t\tif(!heshu[abs(b[i]-b[j])]){insert(i,j,1);}\n\t\t}\n\t}\n\tint s=jb+1,t=jb+2;\n\tfor(int i=1;i<=jb;i++)if(b[i]&1){insert(s,i,1); tot++; }else insert(i,t,1);\n\tint jj=dinic(s,t); \n\tcout<<jj+(jb-jj*2)+((tot-jj)&1)<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std; \n\nconst int maxn = 1e7 + 1; \n\nint n, a[505], G[505][505], col[maxn + 5]; \nint p[maxn + 5], flag[maxn + 5], tot, cnt, mat[205], vis[205];  \n\nint dfs(int u) {\n    for (int v = 1; v <= cnt; v++) {\n        if (!(a[v] & 1) && !vis[v] && G[u][v]) {\n            vis[v] = 1; \n            if (!mat[v] or dfs(mat[v])) {\n                mat[v] = u; \n                return 1; \n            }\n        }\n    }\n    return 0; \n}\n\nint main() {\n    scanf(\"%d\", &n); \n    for (int i = 1; i <= n; i++) {\n        int t; \n        scanf(\"%d\", &t); \n        col[t] = 1;  \n    }\n    flag[1] = 1; \n    if (col[1] != col[0]) a[++cnt] = 1; \n    for (int i = 2; i <= maxn; i++) {\n        if (col[i] != col[i - 1]) a[++cnt] = i; \n        if (!flag[i]) {\n            p[++tot] = i; \n        }\n        for (int j = 1; j <= tot && i * p[j] <= maxn; j++) {\n            flag[i * p[j]] = 1; \n            if (i % p[j] == 0) break ; \n        }\n    }\n    flag[2] = 1;\n    for (int i = 1; i <= cnt; i++) {\n        for (int j = i + 1; j <= cnt; j++) {\n            if (!flag[abs(a[j] - a[i])]) {\n                G[i][j] = G[j][i] = 1; \n            }\n        }\n    }\n    int mx = 0, odd = 0, even; \n    for (int i = 1; i <= cnt; i++) {\n        if (a[i] & 1) {\n            memset(vis, 0, sizeof(vis)); \n            if (dfs(i)) mx++; \n            odd++; \n        }\n    }\n    even = cnt - odd; \n    odd -= mx, even -= mx; \n    int ans = mx; \n    if (odd & 1) {\n        ans += odd - 1 + even - 1 + 3; \n    }\n    else {\n        ans += odd + even; \n    }\n    cout << ans << '\\n'; \n    return 0; \n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cmath>\n#include<cstring>\n#include<cstdio>\nusing namespace std;\n#define CLR(a,b) memset(a,b,sizeof(a))\nconst int maxn = 1e7 + 10;\nint a[maxn];\nint b[maxn];\nint n;\n\nint point[210];\nint edge[210][210];\nint cnt = 0;\n\nint nx,ny;\nint vis[220];\nint cx[220],cy[220];\nint dx[220],dy[220];\n\nint prime[maxn],primesize,phi[maxn];\nbool isprime[maxn];\nvoid getlist(int listsize)\n{\n    memset(isprime,1,sizeof(isprime));\n    isprime[1]=false;\n    for(int i=2;i<=listsize;i++)\n    {\n        if(isprime[i])prime[++primesize]=i;\n         for(int j=1;j<=primesize&&i*prime[j]<=listsize;j++)\n         {\n            isprime[i*prime[j]]=false;\n            if(i%prime[j]==0)break;\n        }\n    }\n}\n\n\nvoid pre()\n{\n    getlist(maxn-1);\n    cin>>n;\n    for(int i=1;i<=n; i++){\n        int num;\n        cin>>num;\n        a[num] = 1;\n        if(a[num-1]!=a[num]) b[num] = 1;\n        else b[num] = 0;\n        if(a[num]!=a[num+1]) b[num+1] = 1;\n        else b[num+1] = 0;\n    }\n    for(int i=1; i<maxn; i++){\n        if(b[i] == 1) point[++cnt] = i;\n    }\n    for(int i=1; i<=cnt; i++){\n        if(point[i]%2 == 1) nx++,dx[nx] = point[i];\n        else ny++,dy[ny] = point[i];\n    }\n//    cout<<nx<<\" \"<<ny<<endl;\n    for(int i=1; i<=nx; i++){\n        for(int j=1; j<=ny; j++){\n            if(isprime[abs(dx[i] - dy[j])])\n                edge[i][j] = 1;\n//            cout<<dx[i]<<\" \"<<dy[j]<<endl;\n        }\n    }\n}\n\nbool path(int u)\n{\n    for(int i=1; i<=ny; i++){\n        if(edge[u][i] && !vis[i]){\n            vis[i] = 1;\n            if(path(cy[i]) || cy[i] == -1){\n                cx[u] = i;\n                cy[i] = u;\n                return 1;\n            }\n        }\n    }\n    return 0;\n}\n\nint maxmatch()\n{\n    int res = 0;\n    CLR(cx,0xff);\n    CLR(cy,0xff);\n\n    for(int i=1;i<=nx;i++){\n        CLR(vis,0);\n        res += path(i);\n    }\n    return res;\n}\n\nint main()\n{\n//    freopen(\"in.txt\",\"r\",stdin);\n    pre();\n    int ans = 0;\n    int edgenum = maxmatch();\n//    cout<<\"edge \"<<edgenum<<endl;\n//    for(int i = 1; i<=nx; i++)\n//        cout<<dx[i]<<\" \"<<dy[cx[i]]<<endl;\n    ans += edgenum;\n    ans += ((nx-edgenum)/2)*2;\n    ans += ((ny-edgenum)/2)*2;\n    if((nx-edgenum)%2 == 1) ans+=3;\n    cout<<ans<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<string>\n#include<cmath>\nusing namespace std;\n#define clr(a) memset(a,0,sizeof(a))\n//--Container\n#include<set>\n//\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pi;\n  \nstruct eg{int u,v,nx;}gp[50010];int cnt,hd[210],mth[210];bool bd[210];\nvoid psh(int u,int v){++cnt;gp[cnt].u=u,gp[cnt].v=v,gp[cnt].nx=hd[u],hd[u]=cnt;};\n  \nbool fdp(int v){\n    int i;for(i=hd[v];i;i=gp[i].nx)if(!bd[gp[i].v]){\n        bd[gp[i].v]=1;\n        if(!mth[gp[i].v]||fdp(mth[gp[i].v])){\n            mth[gp[i].v]=v;\n            return 1;\n        }\n    }\n    return 0;\n};\nint hgy(int n){\n    int rs=0,i;for(clr(mth),i=1;i<=n;++i){\n        clr(bd);if(fdp(i))++rs;\n    }\n    return rs;\n};\n  \nint ar[110],dr[210],cr[2][210],dn,n;\n  \nbool _ck(int n){\n    if(n==1)return 0;int d=sqrt(n),i=2;for(;i<=d;++i)if(!(n%i))return 0;\n    return 1;\n};\n  \nbool cl(){\n    if(scanf(\"%d\",&n)==-1)return 0;\n    int i,j,t,a,b,k;for(i=1;i<=n;scanf(\"%d\",&ar[i++]));sort(ar+1,ar+n+1);n=unique(ar+1,ar+n+1)-ar-1;\n    for(dn=1,dr[1]=ar[1],i=2;i<=n;++i){\n        if(ar[i]==ar[i-1]+1)continue;\n        dr[++dn]=ar[i-1]+1,dr[++dn]=ar[i];\n    }\n    dr[++dn]=ar[n]+1;\n    for(a=b=0,i=1;i<=dn;++i){\n        if(dr[i]&1)cr[1][++a]=dr[i];\n        else\n            cr[0][++b]=dr[i];\n    }\n    for(cnt=0,clr(hd),i=1;i<=a;++i)for(j=1;j<=b;++j)if(_ck(abs(cr[1][i]-cr[0][j])))\n        psh(i,j);\n    t=hgy(a);\n    printf(\"%d\\n\",t+((a-t)/2*2)+((b-t)/2*2)+((a-t)%2*3));\n    return 1;\n};\n  \nint main() {\n    while(cl());\n    return 0;\n};"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\nusing std::vector;\nconst int maxn = 205;\nconst int maxm = 1e7+5;\nint n, m;\nint a[maxn], b[maxm], x[maxm], vis1[maxn], vis2[maxn];\nint is_prime[maxm], prime[maxm], cnt;\nvector<int> to[maxn];\nint X[maxn], Y[maxn], cnt1, cnt2;\nvoid pre() {\n    scanf(\"%d\", &n);\n    for(int i = 1; i <= n; i++) {\n\tscanf(\"%d\", &a[i]);\n\tm = std::max(m, a[i]);\n\tx[a[i]] = 1;\n    }\n    m++;\n    for(int i = 1; i <= m; i++) {\n\tb[i] = x[i] ^ x[i-1];\n\tif(b[i] == 1) {\n\t    if(i & 1) X[++cnt1] = i;\n\t    else Y[++cnt2] = i;\n\t}\n    }\n} \nvoid add_edge(int u, int v) {\n    to[u].push_back(v);\n}\nvoid add(int u, int v) {\n    add_edge(u, v);\n    add_edge(v, u);\n}\nvoid build_graph() {\n    for(int i = 1; i <= cnt1; i++) \n       for(int j = 1; j <= cnt2; j++) \n\t    if(is_prime[abs(X[i] - Y[j])]) add(i, j + n); \n}\nvoid shake(int n) {\n    for(int i = 2; i <= n; i++) {\n\tif(!is_prime[i]) prime[++cnt] = i;\n\tfor(int j = 1; j <= cnt && i * prime[j] <= n; j++) {\n\t    is_prime[i * prime[j]] = 1;\n\t    if((i % prime[j]) == 0) break;\n\t}\n    }\n}\nbool dfs(int x) {\n    for(int i = 0; i < to[x].size(); i++) {\n\tint v = to[x][i];\n\tif(!vis2[v]) {\n\t    vis2[v] = 1;\n\t    if(vis1[v] == 0 || dfs(vis1[v])) {\n\t\tvis1[x] = v;\n\t\tvis1[v] = x;\n\t\treturn true;\n\t    }\n\t}\n    }\n    return false;\n}\nint bi() {\n    int ans = 0;\n    memset(vis1, -1, sizeof(vis1));\n    for(int i = 1; i <= cnt1; i++) {\n\tif(!vis1[i]) {\n\t    memset(vis2, 0, sizeof(vis2));\n\t    if(dfs(i)) ans++;\n\t}\n    }\n    return ans;\n}\nint solve() {\n    shake(m);\n    build_graph();\n    return bi(); \n}\nint main() {\n#ifdef orz\n    freopen(\"input\", \"r\", stdin);\n#endif\n    pre();\n    int k = solve();\n    printf(\"%d\\n\", k + 2 * ((cnt1-k) / 2 + (cnt2-k) / 2) + 3 * ((cnt1-k) % 2));\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<queue>\n#include<algorithm>\nusing namespace std;\nconst int maxn=510,maxL=10000010,inf=0x3f3f3f3f;\nstruct cyc{int v,flow,from;}e[maxn*maxn*2];\nint tot=1,cnt,n,first[maxn],d[maxn],S,T,num[maxn],b[maxn],cur[maxn];\nbool c[maxL];\ninline int ab(int x){return x>0?x:-x;}\nbool isprime(int x){\n\tfor(int i=2;i*i<=x;i++)if(x%i==0)return 0;\n\treturn 1;\n}\nvoid insert(int u,int v,int w){\n\ttot++;e[tot].v=v;e[tot].flow=w;e[tot].from=first[u];first[u]=tot;\n\ttot++;e[tot].v=u;e[tot].flow=0;e[tot].from=first[v];first[v]=tot;\n}\nqueue<int>q;\nbool bfs(){\n\tmemset(d,-1,sizeof(d));\n\tq.push(S);d[S]=0;\n\twhile(!q.empty()){\n\t\tint x=q.front();q.pop();\n\t\tfor(int i=first[x];i;i=e[i].from)\n\t\tif(d[e[i].v]==-1&&e[i].flow){\n\t\t\td[e[i].v]=d[x]+1;\n\t\t\tq.push(e[i].v);\n\t\t}\n\t}\n\treturn d[T]!=-1;\n}\nint dinic(int x,int a){\n\tif(x==T||a==0)return a;\n\tint f,flow=0;\n\tfor(int& i=cur[x];i;i=e[i].from)\n\tif(d[e[i].v]==d[x]+1&&e[i].flow&&(f=dinic(e[i].v,min(a,e[i].flow)))>0){\n\t\te[i].flow-=f;\n\t\te[i^1].flow+=f;\n\t\ta-=f;\n\t\tflow+=f;\n\t\tif(a==0)break;\n\t}\n\treturn flow;\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++){scanf(\"%d\",&num[i]);c[num[i]]=1;}\n\tfor(int i=1;i<=maxL-5;i++)if(c[i]!=c[i-1])b[++cnt]=i;\n\tS=0;T=cnt+1;\n//\tfor(int i=1;i<=cnt;i++)printf(\"%d \",b[i]);printf(\"\\n\");\n\tint m1=0;\n\tfor(int i=1;i<=cnt;i++)if(b[i]&1){\n\t\tm1++;\n\t\tinsert(S,i,1);\n\t\tfor(int j=1;j<=cnt;j++)if(!(b[j]&1)&&isprime(ab(b[i]-b[j])))insert(i,j,1);\n\t}else{\n\t\tinsert(i,T,1);\n\t}\n\tint ans=0;\n\twhile(bfs()){\n\t\tfor(int i=S;i<=T;i++)cur[i]=first[i];\n\t\tans+=dinic(S,inf);\n\t}\n\t//if((m1-ans)%2)printf(\"%d\",cnt-ans+1);else\n\t//printf(\"%d\",cnt-ans);\n\tprintf(\"%d\",cnt-ans+(m1-ans)%2);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<cmath>\nusing namespace std;\n#define N 11000000\n#define INF 0x3f3f3f3f\n#define M 7031004\nstruct node{\n\tint to,next,res;\n}q[M];\nint head[22003],ss,prm[N],dep[23104],ct,a[N],S,T,que[20310],h[20310],cir[20104];bool ip[N];\nvoid addedge(int x,int y,int r)\n{\n\tq[++ss]=(node){y,head[x],r};head[x]=ss;\n\tq[++ss]=(node){x,head[y],0};head[y]=ss;\n}\nbool bfs()\n{\n\tmemset(dep,0,sizeof(dep));\n\tmemcpy(cir,head,4*(T+10));\n\tdep[S]=1;\n\tint f=1,e=0;\n\tque[++e]=S;\n\twhile(f<=e)\n\t{\n\t\tint u=que[f++];\n\t\tfor (int j=head[u];~j;j=q[j].next)\n\t\t\tif (q[j].res&&!dep[q[j].to])\n\t\t\t{\n\t\t\t\tint t=q[j].to;\n\t\t\t\tdep[t]=dep[u]+1;\n\t\t\t\tque[++e]=t;\n\t\t\t}\n\t}\n\treturn dep[T]>0;\n}\nint dfs(int i,int flow)\n{\n\tif (i==T||!flow) return flow;\n\tint f,dist=0;\n\tfor (int &j=cir[i];~j;j=q[j].next)\n\t\tif (dep[q[j].to]==dep[i]+1&&q[j].res&&(f=dfs(q[j].to,min(q[j].res,flow-dist))))\n\t\t{\n\t\t\tdist+=f;\n\t\t\tq[j].res-=f;\n\t\t\tq[j^1].res+=f;\n\t\t}\n\treturn dist;\n}\nint dinic()\n{\n\tint ans=0;\n\twhile(bfs()) ans+=dfs(S,INF);\n\treturn ans;\n}\nint main()\n{\n\tint n,TT,c=0,ans=0,odd;\n\tscanf(\"%d\",&TT);\n\tip[1]=true;ip[0]=true;\n\tfor (int i=2;i<=10000000;++i)\n\t{\n\t\tif (!ip[i]) prm[++ct]=i;\n\t\tfor (int j=1,to;j<=ct&&(to=i*prm[j])<=10000000;++j)\n\t\t{\n\t\t\tip[to]=true;\n\t\t\tif (i%prm[j]==0) break;\n\t\t}\n\t}\n\tip[2]=true;\n\ta[0]=-INF;\n\twhile(TT--)\n\t{\n\t\tscanf(\"%d\",&n);c=0;ss=-1;odd=0;\n\t\tmemset(head,-1,sizeof(head));\n\t\tfor (int i=1;i<=n;++i)\n\t\t{\n\t\t\tscanf(\"%d\",&a[i]);\n\t\t\tif (a[i]!=a[i-1]+1) h[++c]=a[i];\n\t\t\th[a[i]==a[i-1]+1?c:++c]=a[i]+1;\n\t\t}\n\t\tT=c+1;\n\t\tfor (int i=1;i<=c;++i)\n\t\t\tif (h[i]&1)\n\t\t\t{\n\t\t\t\taddedge(S,i,1);++odd;\n\t\t\t\tfor (int j=1;j<=c;++j)\n\t\t\t\t{\n\t\t\t\t\tint dis=abs(h[j]-h[i]);\n\t\t\t\t\tif (!ip[dis]) addedge(i,j,1);\n\t\t\t\t}\n\t\t\t}else addedge(i,T,1);\n\t\tans=dinic();\n\t\tc-=odd;odd-=ans;\n\t\tprintf(\"%d\\n\",ans+(odd/2*2)+(c-ans)/2*2+(odd&1?3:0));\n\t}\n\treturn 0;\n}\n\n//by qlwpc"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\ntypedef long long ll;\nint odd,even,Odd[105],Even[105],ma[105];\nbool flag[10000010],x[10000010],map[105][105],vis[105];\nint prime[10000010],a[105];\nint dfs(int u)\n{\n\tfor (int v=1;v<=even;v++)\n\t{\n\t\tif (!map[u][v]) continue;\n\t\tif (!vis[v])\n\t\t{\n\t\t\tint t=ma[v];\n\t\t\tma[v]=u;\n\t\t\tif (t==-1||dfs(t)) return 1;\n\t\t\tma[v]=t;\n\t\t}\n\t}\n\treturn 0;\n}\nint main()\n{\n\tint n,cnt=0;\n\tscanf(\"%d\",&n);\n//\tflag[1]=1;\n\tfor (int i=2;i<=10000000;i++)\n\t{\n\t\tif (!flag[i]) prime[+cnt]=i;\n\t\tfor (int j=1;j<=cnt;j++)\n\t\t{\n\t\t\tif (i*prime[j]>10000000) break;\n\t\t\tflag[i*prime[j]]=1;\n\t\t\tif (i%prime[j]==0) break;\n\t\t}\n\t}\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%d\",&a[i]);\n\t\tx[a[i]]^=1;\n\t}\n\tfor (int i=1;i<=10000000;i++)\n\t\tif (x[i]!=x[i-1])\n\t\t{\n\t\t\tif (i&1) Odd[++odd]=i;\n\t\t\telse Even[++even]=i; \n\t\t}\n\tfor (int i=1;i<=odd;i++)\n\t\tfor (int j=1;j<=even;j++)\n\t\t\tif (flag[abs(Odd[i]-Even[j])]) map[i][j]=1;\n\tmemset(ma,-1,sizeof(ma));\n\tint sum=0;\n\tfor (int i=1;i<=odd;i++)\n\t{\n\t\tmemset(vis,0,sizeof(vis));\n\t\tif (dfs(i)) sum++;\n\t}\n\tll ans=sum+(((odd-sum)>>1)<<1)+(((even-sum)>>1)<<1)+(odd-sum)%2*3;\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n\n#include <iostream>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <unordered_set>\n#include <queue>\n#include <set>\n#include <algorithm>\n#include <numeric>\n#include <list>\nusing namespace std;\n\nusing QWORD  = uint64_t;\nusing SQWORD = int64_t;\nusing DWORD  = uint32_t;\nusing SDWORD = int32_t;\nusing WORD   = uint16_t;\nusing SWORD  = int16_t;\nusing BYTE   = uint8_t;\nusing SBYTE  = int8_t;\nusing DOUBLE = double;\nusing FLOAT  = float;\n\n#define MIN_SDWORD (-2147483648)\n#define MAX_SDWORD (2147483647)\n#define MIN_SBYTE (-128)\n#define MAX_SBYTE (127)\n\n#define MIN_SQWORD (0x8000000000000000)\n#define MAX_SQWORD (0x7FFFFFFFFFFFFFFF)\n\n#define MAX_QWORD  (0xFFFFFFFFFFFFFFFF)\n#define MAX_DWORD  (0xFFFFFFFF)\n#define MAX_WORD   (0xFFFF)\n#define MAX_BYTE   (0xFF)\n\n#define MAX_DOUBLE      (1.0e+308)\n#define DOUBLE_EPS      (1.0e-12)\n#define MIN_DOUBLE_N    (-1.0e+308)\n\n#define ArrayLength(a)  (sizeof(a) / sizeof(a[0]))\n\nstatic inline DOUBLE MAX(DOUBLE a, DOUBLE b) { return a > b ? a : b; }\nstatic inline QWORD MAX(QWORD a, QWORD b) { return a > b ? a : b; }\nstatic inline DWORD MAX(DWORD a, DWORD b) { return a > b ? a : b; }\nstatic inline SDWORD MAX(SDWORD a, SDWORD b) { return a > b ? a : b; }\nstatic inline DOUBLE MIN(DOUBLE a, DOUBLE b) { return a < b ? a : b; }\nstatic inline QWORD MIN(QWORD a, QWORD b) { return a < b ? a : b; }\nstatic inline DWORD MIN(DWORD a, DWORD b) { return a < b ? a : b; }\nstatic inline SDWORD MIN(SDWORD a, SDWORD b) { return a < b ? a : b; }\nstatic inline DOUBLE ABS(DOUBLE a) { return 0 < a ? a : -a; };\n\n#define BYTE_BITS   (8)\n#define WORD_BITS   (16)\n#define DWORD_BITS  (32)\n#define QWORD_BITS  (64)\n\nstatic inline void inputStringSpSeparated(char *pcStr)\n{\n    char *pcCur = pcStr;\n    for (;;) {\n        char c = getchar();\n        if (('\\n' == c) || (EOF == c) || (' ' == c)) {\n            break;\n        }\n        *pcCur = c;\n        pcCur++;\n    }\n    *pcCur = '\\0';\n}\n\nstatic inline void inputString(char *pcStr)\n{\n    char *pcCur = pcStr;\n    for (;;) {\n        char c = getchar();\n        if (('\\n' == c) || (EOF == c)) {\n            break;\n        }\n        *pcCur = c;\n        pcCur++;\n    }\n    *pcCur = '\\0';\n}\n\n\nstatic inline SQWORD inputSQWORD(void)\n{\n    SQWORD sqNumber = 0;\n    SQWORD sqMultiplier = 1;\n    bool bRead = false;\n    for (;;) {\n        char c = getchar();\n        if (!bRead) {\n            if ('-' == c) {\n                sqMultiplier = -1;\n            }\n        }\n        if (('0' <= c) && (c <= '9')) {\n            sqNumber *= 10LL;\n            sqNumber += (SQWORD)(c - '0');\n            bRead = true;\n        } else {\n            if (bRead) {\n                return sqNumber * sqMultiplier;\n            }\n        }\n    }\n}\n\n\nstatic inline SDWORD inputSDWORD(void)\n{\n    SDWORD lNumber = 0;\n    SDWORD lMultiplier = 1;\n    bool bRead = false;\n    for (;;) {\n        char c = getchar();\n        if (!bRead) {\n            if ('-' == c) {\n                lMultiplier = -1;\n            }\n        }\n        if (('0' <= c) && (c <= '9')) {\n            lNumber *= 10;\n            lNumber += (c - '0');\n            bRead = true;\n        } else {\n            if (bRead) {\n                return lNumber * lMultiplier;\n            }\n        }\n    }\n}\n\nstatic inline DOUBLE inputFP(void)\n{\n    DOUBLE dInt = 0.0;\n    DOUBLE dFrac = 0.0;\n    DOUBLE dMultiplier = 1.0;\n    DWORD dwFpCnt = 0;\n    DOUBLE *pdCur = &dInt;\n    bool bRead = false;\n    for (;;) {\n        char c = getchar();\n        if (!bRead) {\n            if ('-' == c) {\n                dMultiplier = -1;\n            }\n        }\n        if ('.' == c) {\n            pdCur = &dFrac;\n        } else if (('0' <= c) && (c <= '9')) {\n            (*pdCur) *= 10;\n            (*pdCur) += (DOUBLE)(c - '0');\n            bRead = true;\n            if (pdCur == &dFrac) {\n                dwFpCnt++;\n            }\n        } else {\n            if (bRead) {\n                return dMultiplier * (dInt + dFrac / (pow((DOUBLE)10.0 , (DOUBLE)dwFpCnt)));\n            }\n        }\n    }\n}\n\n\n/**\n *  mod による操作ライブラリ\n */\n\n#define ANS_MOD (1000000007LL)\n \nstatic SQWORD addMod(SQWORD x, SQWORD y)\n{ \n    return (x + y) % ANS_MOD;\n}\n \nstatic SQWORD subMod(SQWORD x, SQWORD y)\n{\n    return (x - y + ANS_MOD) % ANS_MOD;\n}\n \nstatic SQWORD mulMod(SQWORD x, SQWORD y) \n{\n    return (x * y) % ANS_MOD;\n}\n \nstatic SQWORD powMod(SQWORD x, SQWORD e) {\n    SQWORD v = 1;\n    for (; e; x = mulMod(x, x), e >>= 1) {\n        if (e & 1) {\n            v = mulMod(v, x);\n        }\n    }\n    return v;\n}\n \nstatic SQWORD divMod(SQWORD x, SQWORD y)\n{\n    return mulMod(x, powMod(y, ANS_MOD - 2));\n}\n \n \nstatic SQWORD combMod(SQWORD n, SQWORD k)\n{\n    SQWORD v=1;\n    for(SQWORD i=1; i<=k; i++) {\n        v = divMod(mulMod(v, n-i+1),i);\n    } \n    return v;\n}\n\n/*----------------------------------------------*/\n\ntypedef struct {\n    SDWORD lTo;\n    SQWORD sqCap;\n    SQWORD sqCost;\n    SDWORD lRev;\n} ST_EDGE;\n\n#define MAX_V   (202)\n\nstruct Flow {\nprivate:\n    vector<ST_EDGE> avGraph[MAX_V];\n    SDWORD  alDims[MAX_V];\n    SQWORD  sqEdgeNum;\n    SQWORD  asqDist[MAX_V];\n    SDWORD  alPrevV[MAX_V];   \n    SDWORD  alPrevEdge[MAX_V];      /*直前の頂点と辺 */\n\n    SDWORD  alDinic_Level[MAX_V];\n    SDWORD  alDinic_Iter[MAX_V];\n\npublic:\n    Flow() {\n        for (auto v: avGraph) {\n            v.clear();\n        }\n        memset(alDims, 0, sizeof(alDims));\n        memset(asqDist, 0, sizeof(asqDist));\n        memset(alPrevV, 0, sizeof(alPrevV)); \n        memset(alPrevEdge, 0, sizeof(alPrevEdge));\n        memset(alDinic_Level, 0, sizeof(alDinic_Level));\n        memset(alDinic_Iter, 0, sizeof(alDinic_Iter));\n    }\n    void addEdge(SDWORD lFrom, SDWORD lTo, SQWORD sqCap, SQWORD sqCost) {\n//        printf(\"%d ----[%lld] ----> %d\\n\", lFrom, sqCap, lTo);\n        \n        alDims[lFrom]++;\n        avGraph[lFrom].push_back((ST_EDGE){lTo, sqCap, sqCost, (SDWORD)(avGraph[lTo].size())});\n        avGraph[lTo].push_back((ST_EDGE){lFrom, 0, -sqCost, (SDWORD)(avGraph[lFrom].size() - 1)});\n    }\n\n    SDWORD minCostFlow(SDWORD lStart, SDWORD lTarget, SQWORD sqFlow)\n    {\n        SQWORD sqRes = 0;\n        SQWORD sqFlowRest = sqFlow;\n        while (0 < sqFlowRest) {\n            /* Bellman-Ford Method */\n            fill(asqDist, asqDist + ArrayLength(asqDist), MAX_SDWORD);\n            asqDist[lStart] = 0;\n            bool bIsUpdate = true;\n            while (bIsUpdate) {\n                bIsUpdate = false;\n                for (SDWORD lV = 0; lV < MAX_V; lV++) {\n                    for (SDWORD lIdx = 0; lIdx < avGraph[lV].size(); lIdx++) {\n                        ST_EDGE &stE = avGraph[lV][lIdx];\n                        if ((asqDist[lV] != MAX_SDWORD)\n                                && (0 < stE.sqCap)\n                                && (asqDist[lV] + stE.sqCost < asqDist[stE.lTo])) {\n                            asqDist[stE.lTo] = asqDist[lV] + stE.sqCost;\n                            alPrevV[stE.lTo] = lV;\n                            alPrevEdge[stE.lTo] = lIdx;\n                            bIsUpdate = true;\n                        }\n                    }\n                }\n            }\n            if (asqDist[lTarget] == MAX_SDWORD) {\n                return -1;\n            }\n\n            SQWORD sqAddFlow = MAX_SQWORD;\n            for (SDWORD lV = lTarget; lV != lStart; lV = alPrevV[lV]) {\n                sqAddFlow = min(sqAddFlow, avGraph[alPrevV[lV]][alPrevEdge[lV]].sqCap);\n            }\n            sqFlowRest -= sqAddFlow;\n            sqRes += sqAddFlow * asqDist[lTarget];      // 後で目的変数は書き換える\n            for (SDWORD lV = lTarget; lV != lStart; lV = alPrevV[lV]) {\n                ST_EDGE &stE = avGraph[alPrevV[lV]][alPrevEdge[lV]];\n                stE.sqCap -= sqAddFlow;\n                avGraph[lV][stE.lRev].sqCap += sqAddFlow;\n            }\n        }\n        return sqRes;\n    }\n\nprivate:\n    SQWORD maxFlowDinicBfs(SDWORD lS)\n    {\n        memset(alDinic_Level, -1, sizeof(alDinic_Level));\n        queue<SDWORD> queSearch;\n        alDinic_Level[lS] = 0;\n        queSearch.push(lS);\n        while (!queSearch.empty()) {\n            SDWORD lV = queSearch.front();\n            queSearch.pop();\n            for (SDWORD lIdx = 0; lIdx < avGraph[lV].size(); lIdx++) {\n                ST_EDGE &stE = avGraph[lV][lIdx];\n                if ((0 < stE.sqCap) && (alDinic_Level[stE.lTo] < 0)) {\n                    alDinic_Level[stE.lTo] = alDinic_Level[lV] + 1;\n                    queSearch.push(stE.lTo);\n                }\n            }\n        }\n\n        return 0;\n    }\n\n    SQWORD maxFlowDinicDfs(SDWORD lV, SDWORD lT, SQWORD sqF)\n    {\n        if (lV == lT) {\n            return sqF;\n        }\n        for (SDWORD &lI = alDinic_Iter[lV]; lI < avGraph[lV].size(); lI++) {\n            ST_EDGE &stE = avGraph[lV][lI];\n            if ((0 < stE.sqCap) && (alDinic_Level[lV] < alDinic_Level[stE.lTo])) {\n                SQWORD sqDiffFlow = maxFlowDinicDfs(stE.lTo, lT, min(sqF, stE.sqCap));\n                if (0 < sqDiffFlow) {\n                    stE.sqCap -= sqDiffFlow;\n                    avGraph[stE.lTo][stE.lRev].sqCap += sqDiffFlow;\n                    return sqDiffFlow;\n                }\n            }\n        }\n        return 0;\n    }\n\npublic:\n    SQWORD MaxFlow(SDWORD lStart, SDWORD lTarget)\n    {\n        SQWORD sqFlow = 0LL;\n        for (;;) {\n            maxFlowDinicBfs(lStart);\n            if (alDinic_Level[lTarget] < 0) {\n                return sqFlow;\n            }\n            memset(alDinic_Iter, 0, sizeof(alDinic_Iter));\n            while (1) {\n                SQWORD sqDiffFlow = maxFlowDinicDfs(lStart, lTarget, MAX_SQWORD);\n                sqFlow += sqDiffFlow;\n                if (0LL == sqDiffFlow) {\n                    break;\n                }\n            }\n        }\n    }\n\n    SQWORD getFlow(SDWORD lPnt)\n    {\n        SQWORD sqCapSum = 0; \n        for (auto e: avGraph[lPnt]) {\n            sqCapSum += e.sqCap;\n        }\n        return alDims[lPnt] - sqCapSum;\n    }\n};\n\n/*----------------------------------------------*/\n\nstatic void getPrimes(vector<SDWORD> &vlPrimes, SDWORD lMax)\n{\n    /* lSearchMax と ループ内の *2 の関係から、入力は3以上とすること */\n    if (!(1 <= lMax)) {\n        printf(\"Oops!\");\n        return;\n    }\n\n    /* 素数のリストを作る */\n    vector<bool> vbIsPrime(lMax + 1, true);\n    SDWORD lSearchMax = sqrt(lMax) + 1;\n    vbIsPrime[0] = false;\n    vbIsPrime[1] = false;\n    for (SDWORD lPrime = 2; lPrime < vbIsPrime.size(); lPrime++) {\n        if (vbIsPrime[lPrime]) {\n            vlPrimes.emplace_back(lPrime);\n            if (lPrime <= lSearchMax) {\n                for (SDWORD lCurNum = lPrime * 2; lCurNum <= lMax; lCurNum += lPrime) {\n                    vbIsPrime[lCurNum] = false;\n                }\n            }\n        }\n    }\n}    \n\n/*----------------------------------------------*/\n\n#define PNT_NO_START    (0)\n#define PNT_NO_OFFSET   (100)\n#define PNT_NO_TARGET   (201)\n#define FLOW_OFFSET     (1000000000)\n#define CAPACITY_INF    (1000000001)\n#define DUMMY_COST      (1)\n\nint main(void)\n{\n    SQWORD sqN = inputSQWORD();\n\n    Flow solverFlow;\n    vector<SQWORD> vsqA;\n    vector<SQWORD> vsqB;\n    vector<SDWORD> vlPrimes;\n\n    getPrimes(vlPrimes, 1e7 + 1);\n    vlPrimes.erase(find(vlPrimes.begin(), vlPrimes.end(), 2));\n\n    for (SQWORD sqIdx = 0; sqIdx < sqN; sqIdx++) {\n        SQWORD sqA = inputSQWORD();\n        vsqA.emplace_back(sqA);\n    }\n\n    for (SQWORD sqIdx = 0; sqIdx < sqN; sqIdx++) {\n        if (0 < sqIdx) {\n            if (!(vsqA[sqIdx - 1] == vsqA[sqIdx] - 1)) {\n                vsqB.emplace_back(vsqA[sqIdx]);\n            }\n        } else {\n            vsqB.emplace_back(vsqA[sqIdx]);      \n        }\n        if (sqIdx < sqN - 1) {\n            if (!(vsqA[sqIdx] + 1 == vsqA[sqIdx + 1])) {\n                vsqB.emplace_back(vsqA[sqIdx] + 1);\n            }\n        } else {\n            vsqB.emplace_back(vsqA[sqIdx] + 1);\n        }\n    }\n\n    map<SQWORD, SQWORD> mapB;\n\n    for (SQWORD sqIdx = 0; sqIdx < vsqB.size(); sqIdx++) {\n        mapB[vsqB[sqIdx]] = sqIdx + 1;\n    }\n\n    /* 二部マッチング */\n    for (auto b: vsqB) {\n        solverFlow.addEdge(PNT_NO_START,            mapB[b],       1, DUMMY_COST);\n        solverFlow.addEdge(mapB[b] + PNT_NO_OFFSET, PNT_NO_TARGET, 1, DUMMY_COST);\n    }\n\n    for (auto p: vlPrimes) {\n        for (auto b: vsqB) {\n            if (*(lower_bound(vsqB.begin(), vsqB.end(), b + p)) == b + p) {\n                if (b + p < 1e7 + 1) {\n                    solverFlow.addEdge(mapB[b], mapB[b + p] + PNT_NO_OFFSET, 1, DUMMY_COST);\n                }\n            }\n        }\n    }\n\n    SQWORD sqMaxFlow = solverFlow.MaxFlow(PNT_NO_START, PNT_NO_TARGET);\n    vector<SQWORD> vsqBRestEven;\n    vector<SQWORD> vsqBRestOdd;\n    for (auto b: vsqB) {\n        SQWORD sqFlow = solverFlow.getFlow(mapB[b]);\n\n        if (0 == sqFlow) {\n            if (0 == b % 2) {\n                vsqBRestEven.emplace_back(b);\n            } else {\n                vsqBRestOdd.emplace_back(b);\n            }\n        }\n    }\n\n    SQWORD sqAns = sqMaxFlow;    \n    sqAns += (vsqBRestEven.size() / 2) * 2;\n    sqAns += (vsqBRestOdd.size() / 2) * 2;\n    if (0 < (vsqBRestEven.size() %  2)) {\n        sqAns += 3;\n    }\n\n    printf(\"%lld\\n\", sqAns);\n\n    return 0;\n}\n/*------------------------------------------*/\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define N 510\n#define pb push_back\nvector<int> v[N];\nint a[N],b[N],vis[N];\nint s[10000010];\ninline int read() {\n    int x=0;\n    char ch=getchar();\n    while (!isdigit(ch)) ch=getchar();\n    while (isdigit(ch)) x=x*10+ch-'0',ch=getchar();\n    return x;\n}\ninline int P(int x) {\n    if (x<2) return false;\n    for (int i=2;i<=sqrt(x);i++)\n        if (x%i==0) return false;\n    return true;\n}\nint mat[N];\ninline int dfs(int x) {\n    for (auto y:v[x]) {\n        if (vis[y]) continue; vis[y]=true;\n        if (!mat[y] || dfs(mat[y])) return mat[y]=x,1;\n    }\n    return false;\n}\nint main() {\n    int n=read(),Max=0,cnta=0,cntb=0,ans=0,res=0;\n    for (int i=1;i<=n;i++) s[Max=max(Max,read())]^=1;\n    for (int i=1;i<=Max+1;i++) if (s[i]!=s[i-1])\n        ((i&1)?(a[++cnta]):(b[++cntb]))=i;\n    // cout<<cnta<<endl;\n    // cout<<cntb<<endl;\n    for (int i=1;i<=cnta;i++)\n        for (int j=1;j<=cntb;j++) if (P(abs(a[i]-b[j]))) v[i].pb(j);\n    for (int i=1;i<=cnta;i++) {\n        for (int j=1;j<=cntb;j++) vis[j]=0; ans+=dfs(i);\n    }\n    // cout<<ans<<endl;\n    res+=(cnta-ans)/2*2;\n    res+=(cntb-ans)/2*2;\n    res+=ans+((cnta-ans)&1)*3;\n    cout<<res<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i, n) for (int (i) = 0 ; (i) < (int)(n) ; ++(i))\n#define repn(i, m, n) for (int (i) = (m) ; (i) < (int)(n) ; ++(i))\n#define rep_rev(i, n) for (int (i) = (int)(n) - 1 ; (i) >= 0 ; --(i))\n#define repn_rev(i, m, n) for (int (i) = (int)(n) - 1 ; (i) >= (m) ; --(i))\n\n#define INF 2e9\n#define ll long long\n#define MOD 1e9+7\n#define MAX_V 305\n\n#define print2D(h, w, arr) REP(i, h) { REP(j, w) cout << arr[i][j] << \" \"; cout << endl; }\n#define print_line(vec, n) {for(int i=0;i<(n-1);i++) cout << (vec)[i] << \" \"; cout << (vec)[(n)-1] << endl;}\ntemplate<class T> void print(const T& x){cout << x << endl;}\ntemplate<class T, class... A> void print(const T& first, const A&... rest) { cout << first << \" \"; print(rest...); }\nstruct PreMain {PreMain(){cin.tie(0);ios::sync_with_stdio(false);cout<<fixed<<setprecision(20);}} premain; \n\n\n/* 辺を表す構造体 */\nstruct edge {int to, cap ,rev; };\n \n/* グラフの隣接リスト表現 */\nvector<edge> G[MAX_V];\n/* DFSですべに調べたかのグラフ */\nbool used[MAX_V];\n \n/* fromからtoへ向かう容量capの辺をグラフに追加する */\n/* 相互参照できるようにしている */\nvoid add_edge(int from, int to, int cap){\n    G[from].push_back((edge){to, cap, (int)G[to].size()});\n    G[to].push_back((edge){from, 0, (int)G[from].size() - 1});    \n}\n \n/* 増加パスをdfsで探す */\nint dfs(int v, int t, int f){\n    if(v==t) return f;\n    used[v] = true;\n    for(int i=0; i<G[v].size(); i++){\n        edge &e = G[v][i];\n        if(!used[e.to] && e.cap>0){\n            int d = dfs(e.to, t, min(f, e.cap));\n            if(d>0){\n                e.cap -= d;\n                G[e.to][e.rev].cap += d;\n                return d;\n            }\n        }\n    }\n    return 0;\n}\n \nint max_flow(int s, int t){\n    int flow = 0;\n    for(;;){\n        memset(used, 0, sizeof(used));\n        int f = dfs(s, t, INF);\n        if(f==0) return flow;\n        flow += f;\n    }\n}\n\nbool diffIsPrime(int a, int b) {\n    a = abs(a - b);\n    if(a <= 2) return false;\n    repn(i, 2, sqrt(a)+1) if(a % i == 0) return false;\n\n    return true;\n}\n\nint main(){\n    int n;\n    cin >> n;\n    vector<int> x(n);\n    map<int, int> mp;\n    rep(i, n) {\n        int tmp;\n        cin >> tmp;\n        mp[tmp] ^= 1;\n        mp[tmp+1] ^= 1;\n    }\n\n    /* 一発でいける分を探す。偶奇の組み合わせしかないので二部マッチング */\n    vector<int> odd, even;\n    for(auto it = mp.begin(); it != mp.end(); it++) {\n        if(it->second == 1) {\n            if(it->first % 2 == 0) {\n                even.push_back(it->first);\n            } else {\n                odd.push_back(it->first);\n            }\n        }\n    }\n\n    int start = 0, end = 201;\n    rep(i, even.size()) add_edge(start, i+1, 1);\n    rep(i, odd.size()) add_edge(i+101, end, 1);\n    rep(i, even.size()) rep(j, odd.size()) {\n        if(diffIsPrime(even[i], odd[j])) add_edge(i+1, j+101, 1);\n    }\n\n    int ans_tmp = max_flow(start, end);\n    int ans = ans_tmp;\n\n    /* 偶数同士と奇数同士は。差が偶数なので二回でいける */\n    ans += ((even.size() - ans_tmp) / 2) * 2;\n    ans += ((odd.size() - ans_tmp) / 2) * 2;\n\n    /* あまったやつは差が奇数なので三回でいける */\n    if((even.size() - ans_tmp) % 2 != 0) ans += 3;\n\n    cout << ans << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define left lft\n\nconst int N=1e7+5;\nconst int maxn=N+10;\n\nint n,m,m0,m1,c[210],k1,left[210];\nbool vis[210];\nbool comp[maxn]; //composite\nint primes,prime[maxn/10];\n\nvoid prework()\n{\n\tint i,j;\n\tcomp[0]=comp[1]=1;\n\tfor (i=2;i<=N;i++)\n\t{\n\t\tif (!comp[i]) prime[++primes]=i;\n\t\tfor (j=1;j<=primes&&i*prime[j]<=N;j++)\n\t\t{\n\t\t\tcomp[i*prime[j]]=1;\n\t\t\tif (i%prime[j]==0) break;\n\t\t}\n\t}\n\tcomp[2]=1;\n}\n\nbool match(int u)\n{\n\tfor (int v=1;v<=m;v++)\n\t{\n\t\tif (comp[abs(c[u]-c[v])]||vis[v]) continue;\n\t\tvis[v]=1;\n\t\tif (!left[v]||match(left[v]))\n\t\t{\n\t\t\tleft[v]=u;\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nint main()\n{\n#ifdef h10\n\tfreopen(\"F.in\",\"r\",stdin);\n\tfreopen(\"F.out\",\"w\",stdout);\n#endif\n\tint i,x;\n\tprework();\n\tscanf(\"%d\",&n);\n\tfor (i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%d\",&x);\n\t\tc[(i<<1)-1]=x;\n\t\tc[i<<1]=x+1;\n\t}\n\tsort(c+1,c+n+n+1);\n\tfor (i=1;i<=n+n;i++)\n\t\tc[i]==c[m]?m--:c[++m]=c[i];\n\n\tfor (i=1;i<=m;i++)\n\t\tc[i]&1?m1++:m0++;\n\tfor (i=1;i<=m;i++)\n\t{\n\t\tmemset(vis,0,sizeof(vis));\n\t\tif (c[i]&1) k1+=match(i);\n\t}\n\tm0-=k1; m1-=k1;\n\tprintf(\"%d\\n\",k1+((m0>>1)+(m1>>1))*2+(m0&1)*3);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 610, INF = 0x3f3f3f3f;\nint p[N],n,cnt,st,en,x[N];\nstruct edge {\n  int la,b,cap;\n} con[N * N * 2];\nint tot=1,fir[N];\nvoid add(int from,int to,int capc) {\n  con[++tot] = (edge) {fir[from],to,capc};\n  fir[from] = tot;\n  con[++tot] = (edge) {fir[to],from,0};\n  fir[to] = tot;\n}\nint cur[N], dis[N];\nint dfs(int pos,int imp) {\n  if (pos == en || (!imp)) return imp;\n  int expo = 0, tmp;\n  for (int &i = cur[pos] ; i ; i = con[i].la) {\n    if (dis[con[i].b] == dis[pos] + 1) {\n      tmp = dfs(con[i].b,min(imp,con[i].cap));\n      con[i].cap -= tmp;\n      con[i^1].cap += tmp;\n      expo += tmp;\n      imp -= tmp;\n      if (!imp) break;\n    }\n  }\n  return expo;\n}\nbool bfs() {\n  static queue<int> q;\n  while (!q.empty()) q.pop();\n  memset(dis,0,sizeof dis);\n  for (int i = 1 ; i <= n ; ++ i)\n    cur[i] = fir[i];\n  dis[st] = 1;\n  q.push(st);\n  for (int pos ; !q.empty() ; q.pop()) {\n    pos = q.front();\n    for (int i = fir[pos] ; i ; i = con[i].la) {\n      if (con[i].cap && (!dis[con[i].b])) {\n\tdis[con[i].b] = dis[pos] + 1;\n\tq.push(con[i].b);\n      }\n    }\n  }\n  if (!dis[en]) return 0;\n  return 1;\n}\nconst int MAX = 10000010;\nint isp[MAX + 10], pri[MAX / 10], pcnt, num[2];\nset<int> prime;\nvoid prework() {\n  for (int i = 2 ; i <= MAX ; ++ i) {\n    if (!isp[i]) pri[++pcnt] = i;\n    for (int j = 1 ; j <= pcnt && pri[j] * i <= MAX ; ++ j) {\n      isp[pri[j] * i] = 1;\n      if (i % pri[j] == 0) break;\n    }\n  }\n  for (int i = 2 ; i <= pcnt ; ++ i)\n    prime.insert(pri[i]);\n}\nint main() {\n  scanf(\"%d\",&n);\n  for (int i = 1 ; i <= n ; ++ i) {\n    scanf(\"%d\",&x[i]);\n    if (x[i] == 1 || x[i] != x[i-1] + 1)\n      p[++cnt] = x[i];\n    if (i > 1 && x[i] != x[i-1] + 1)\n      p[++cnt] = x[i-1] + 1;\n  }\n  p[++cnt] = x[n] + 1;\n  n = cnt;\n  st = ++n;\n  en = ++n;\n  for (int i = 1 ; i <= cnt ; ++ i) {\n    ++ num[p[i]&1];\n    if (p[i]&1) {\n      add(st,i,1);\n      for (int j = 1 ; j <= cnt ; ++ j) {\n\tint d = abs(p[i] - p[j]);\n\tif (prime.count(d))\n\t  add(i,j,1);\n      }\n    } else add(i,en,1);\n  }\n  int ans = 0;\n  while (bfs())\n    ans += dfs(st,INF);\n  printf(\"%d\\n\",ans + 2 * ((num[0] - ans) / 2 + (num[1] - ans) / 2) + ((num[1] - ans)&1) * 3);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n#define OUT(x)  cerr << #x << \" = \" << x << endl;\n#define all(x)  x.begin(), x.end()\n#define mp      make_pair\n#define pii     pair<int, int>\n#define pll     pair<long long, long long>\n#define ll      long long\n\nbool is_prime(int x) {\n        if (x == 1) return false;\n        for (int i = 2; i * i <= x; i ++) {\n                if (x % i == 0) return false;\n        }\n        return true;\n}\n\nstruct edge {\n        int to, cap, rev;\n};\nbool used[101010];\nvector<edge> g[101010];\nstatic const int INF = 0x3f3f3f3f;\nvoid add_edge(int from, int to, int cap) {\n        g[from].push_back((edge) { to, cap, (int)g[to].size() });\n        g[to].push_back((edge) { from, 0, (int)g[from].size() - 1 });\n}\nint dfs(int v, int t, int f) {\n        if (v == t) return f;\n        used[v] = true;\n        for (int i = 0; i < g[v].size(); i ++) {\n                edge& e = g[v][i];\n                if (!used[e.to] && e.cap > 0) {\n                        int d = dfs(e.to, t, min(f, e.cap));\n                        if (d > 0) {\n                                e.cap -= d;\n                                g[e.to][e.rev].cap += d;\n                                return  d;\n                        }\n                }\n        }\n        return 0;\n}\nint MaxFlow(int s, int t) {\n        int flow = 0;\n        while (true) {\n                memset(used, false, sizeof(used));\n                int f = dfs(s, t, INF);\n                if (f == 0) return flow;\n                flow += f;\n        }\n}\n\nvector<int> even, odd;\n\nvoid push(int x) {\n        if (x & 1) odd.push_back(x);\n        else even.push_back(x);\n}\n\nint main() {\n        int n;\n        cin >> n;\n        vector<int> x(n);\n        for (int i = 0; i < n; i ++) cin >> x[i];\n        for (int i = 0; i < n; i ++) {\n                if (i == 0 || x[i] - 1 != x[i - 1]) push(x[i]);\n                if (i == n - 1 || x[i] + 1 != x[i + 1]) push(x[i] + 1);\n        }\n        int o = odd.size(), e = even.size();\n        int s = 0, t = o + e + 1;\n        for (int i = 0; i < o; i ++) add_edge(s, i + 1, 1);\n        for (int i = 0; i < e; i ++) add_edge(i + o + 1, t, 1);\n        for (int i = 0; i < o; i ++) {\n                for (int j = 0; j < e; j ++) {\n                        int d = abs(odd[i] - even[j]);\n                        if ((d & 1) && is_prime(d)) add_edge(i + 1, j + o + 1, 1);\n                }\n        }\n        int k = MaxFlow(s, t);\n        int ans = k + ((e - k) / 2 + (o - k) / 2) * 2 + ((o - k) % 2) * 3;\n        cout << ans << endl;\n        return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint n;\nconst int N = 210;\nconst int M = 10000010;\nint prime[M], not_prime[M], tot_prime;\nint xi[N], A[N], B[N], totA, totB;\nint V[N][N], pA[N], vA[N];\nvoid insert(int t)\n{\n    if (t & 1) A[++ totA] = t;\n    else B[++ totB] = t;\n}\nint dfs(int t)\n{\n    vA[t] = 1;\n    for (int i = 1; i <= totB; ++ i) if (V[t][i] && !vA[pA[i]])\n        if (!pA[i] || dfs(pA[i]))\n            return pA[i] = t, 1;\n    return 0;\n}\nint main()\n{\n    not_prime[1] = 1;\n    for (int i = 2; i < M; ++ i)\n    {\n        if (!not_prime[i]) prime[++ tot_prime] = i;\n        for (int j = 1; j <= tot_prime && i * prime[j] < M; ++ j)\n        {\n            not_prime[i * prime[j]] = 1;\n            if (i % prime[j] == 0) break;\n        }\n    }\n    cin >> n;\n    for (int i = 1; i <= n; ++ i) cin >> xi[i];\n    xi[0] = -1;\n    for (int i = 1; i <= n; ++ i)\n    {\n        if (xi[i] - xi[i - 1] != 1) insert(xi[i]);\n        if (xi[i + 1] - xi[i] != 1) insert(xi[i] + 1);\n    }\n    for (int a = 1; a <= totA; ++ a)\n        for (int b = 1; b <= totB; ++ b)\n            if (!not_prime[abs(A[a] - B[b])])\n                V[a][b] = 1;\n    int match = 0;\n    for (int i = 1; i <= totA; ++ i)\n    {\n        for (int j = 1; j <= totA; ++ j) vA[j] = 0;\n        if (dfs(i)) match ++;\n    }\n    int ans = match + (totA - match) / 2 * 2 + (totB - match) / 2 * 2 + (totA - match) % 2 * 3;\n    cout << ans;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint V, E, src, snk;\nvector<int> la, nxt, oppo, capa;\nvoid init() {\n    E = 0;\n    la.clear(); nxt.clear(); oppo.clear(); capa.clear();\n    la = vector<int>(V, -1);\n}\nvoid add(int u, int v, int c) {\n    nxt.push_back(la[u]);\n    la[u] = E++;\n    oppo.push_back(v);\n    capa.push_back(c);\n}\nvector<int> dist;\nqueue<int> q;\nbool bfs() {\n    dist = vector<int>(V, -1);\n    q.push(src);\n    dist[src] = 0;\n    while(!q.empty()) {\n        int u = q.front(); q.pop();\n\n        for(int i = la[u]; i != -1; i = nxt[i]) {\n            int v = oppo[i];\n            if(capa[i] && dist[v] == -1) {\n                q.push(v);\n                dist[v] = dist[u] + 1;\n            }\n        }\n    }\n    return dist[snk] != -1;\n}\nvector<int> laa;\nint dfs(int u, int f) {\n    if(u == snk) return f;\n    for(int i = laa[u]; i != -1; i = nxt[i]) {\n        laa[u] = i;\n        int v = oppo[i];\n        if(capa[i] && dist[v] == dist[u] + 1) {\n            if(int tmp = dfs(v, min(capa[i], f))) {\n                capa[i] -= tmp;\n                capa[i^1] += tmp;\n                return tmp;\n            }\n        }\n    }\n    return 0;\n}\nint dinic() {\n    int tf = 0;\n    while(bfs()) {\n        laa = la;\n        while(int tmp = dfs(src, 1e9)) tf += tmp;\n    }\n    return tf;\n}\n\nvector<int> pchk;\nvoid getPrime() {\n    pchk = vector<int>(10000010, 0);\n    for(int i = 2; i < 10000010; i++) {\n        if(pchk[i]) continue;\n        int mul = 2;\n        while(i * mul < 10000010) {\n            pchk[i * mul] = 1;\n            mul++;\n        }\n    }\n    pchk[0] = 1;\n    pchk[1] = 1;\n    pchk[2] = 1;\n}\n\nint N;\nvector<int> X;\nvector<int> B;\nvector<int> Me, Mo;\n\nint main() {\n    getPrime();\n\n    scanf(\"%d\", &N);\n    X.resize(N);\n    for(int i = 0; i < N; i++) {\n        scanf(\"%d\", &X[i]);\n    }\n    for(int i = 0; i < N; i++) {\n        if(i == 0 || X[i] != X[i - 1] + 1) {\n            B.push_back(X[i]);\n        }\n        if(i == N - 1 || X[i] + 1 != X[i + 1]) {\n            B.push_back(X[i] + 1);\n        }\n    }\n    for(int i = 0; i < B.size(); i++) {\n        if(B[i] % 2) Mo.push_back(B[i]);\n        else Me.push_back(B[i]);\n    }\n\n    V = Me.size() + Mo.size() + 2, src = V - 2, snk = V - 1;\n    init();\n\n    for(int i = 0; i < Me.size(); i++) {\n        add(src, i, 1);\n        add(i, src, 0);\n    }\n    for(int i = 0; i < Mo.size(); i++) {\n        add(Me.size() + i, snk, 1);\n        add(snk, Me.size() + i, 0);\n    }\n    for(int i = 0; i < Me.size(); i++) {\n        for(int j = 0; j < Mo.size(); j++) {\n            if(!pchk[ abs(Me[i] - Mo[j]) ]) {\n                add(i, Me.size() + j, 1);\n                add(Me.size() + j, i, 0);\n            }\n        }\n    }\n    int K = dinic();\n    cout<<K + (((int)Me.size() - K)/2 + ((int)Mo.size() - K)/2)*2 + ((Me.size() - K) % 2)*3;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef unsigned long long int ull;\ntypedef long long int ll;\ntypedef pair<ll,ll> pll;\ntypedef long double D;\ntypedef complex<D> P;\n#define F first\n#define S second\nconst ll MOD=1000000007;\n//const ll MOD=998244353;\n\ntemplate<typename T,typename U>istream & operator >> (istream &i,pair<T,U> &A){i>>A.F>>A.S; return i;}\ntemplate<typename T>istream & operator >> (istream &i,vector<T> &A){for(auto &I:A){i>>I;} return i;}\ntemplate<typename T,typename U>ostream & operator << (ostream &o,const pair<T,U> &A){o<<A.F<<\" \"<<A.S; return o;}\ntemplate<typename T>ostream & operator << (ostream &o,const vector<T> &A){ll i=A.size(); for(auto &I:A){o<<I<<(--i?\" \":\"\");} return o;}\n\ntemplate <typename WeightType, typename TotalWeightType=int64_t>\nclass MaximumWeightedMatching {\n  /*\n  Maximum Weighted Matching in General Graphs\n  - O(n^3) time\n  - O(n + m) space\n  Note: each vertex is 1-indexed.\n  */\npublic:\n  using weight_t = WeightType;\n  using total_weight_t = TotalWeightType;\n  struct Edge { int from, to; weight_t weight; };\n\nprivate:\n  enum TreeLabelNumber { INNER = -1, UNUSED = 0, OUTER = 1 };\n  enum LabelNumber { SEPARATED = -2, DEFAULT = -1 };\n  enum EdgeNumber { UNDEFINED = 1 << 30 };\n  static constexpr weight_t INF = weight_t(1) << (sizeof(weight_t) * 8 - 2);\n  struct Node { int next, from, to; };\n  struct Label { int from, to; };\n  class Queue {\n  public:\n    Queue() {}\n    Queue(int N) : que(N), qh(0), qt(0) {}\n    void clear() { qh = qt = 0; }\n    int* data() { return que.data(); }\n    bool empty() const { return qh == qt; }\n    int dequeue() { return que[qh++]; }\n    void enqueue(int u) { que[qt++] = u; }\n    int operator [] (int i) const { return que[i]; }\n    int size() const { return qt; }\n\n    vector<int> que;\n    int qh, qt;\n  };\n\npublic:\n  MaximumWeightedMatching(int N, const vector<Edge>& raw_edges) \n      : N(N), B((N - 1) / 2), size(N + B + 1) {\n\n    ofs.assign(N + 2, 0);\n    for (auto& e : raw_edges) {\n      ofs[e.from + 1]++;\n      ofs[e.to + 1]++;\n    }\n    for (int i = 1; i <= N; ++i) ofs[i] += ofs[i - 1];\n    edges.resize(raw_edges.size() * 2);\n    for (int i = 0; i < (int) raw_edges.size(); ++i) {\n      auto& e = raw_edges[i];\n      edges[ofs[e.from]++] = {e.from, e.to, 2 * e.weight};\n      edges[ofs[e.to]++] = {e.to, e.from, 2 * e.weight};\n    }\n    for (int i = 0; i <= N; ++i) ofs[N + 1 - i] = ofs[N - i];\n    ofs[0] = 0;\n  }\n\n  total_weight_t maximum_weighted_matching() {\n    initialize();\n    set_potential();\n    for (int u = 1; u <= N; ++u) if (!mate[u]) {\n      for (int s = 0; !augmented(u, s); s = adjust_dual_solutions());\n      fix_blossom_bases();\n      clear_label();\n    }\n    total_weight_t ret = 0;\n    for (int u = 1; u <= N; ++u) if (mate[u] > u) {\n      weight_t max_w = 0;\n      for (int eid = ofs[u]; eid < ofs[u + 1]; ++eid) {\n        if (edges[eid].to == mate[u]) max_w = max(max_w, edges[eid].weight);\n      }\n      ret += max_w;\n    }\n    return ret >> 1;\n  }\n\nprivate:\n  inline int encode(int e) const {\n    return e + size + 1; // should be >= 3\n  }\n\n  inline weight_t reduced_cost(int u, int v, const Edge& e) const {\n    return potential[u] + potential[v] - e.weight;\n  }\n\n  inline weight_t reduced_cost(int eid) const {\n    return reduced_cost(edges[eid].from, edges[eid].to, edges[eid]);\n  }\n\n  void rematch(int v, int w) {\n    auto t = mate[v]; mate[v] = w;\n    if (mate[t] != v) return;\n    if (label[v].to == 0) {\n      mate[t] = label[v].from;\n      rematch(mate[t], t);\n    } else {\n      int x = label[v].from, y = label[v].to;\n      rematch(x, y); rematch(y, x);\n    }\n  }\n\n  Label search_blossom_edge(int bid) const {\n    int b = base[bid], bv = b;\n    for (; node[bv].next != b; bv = node[node[bv].next].next);\n    return {node[bv].from, node[bv].to};\n  }\n\n  void label_blossom(int bid, int m, Label l) {\n    label[bid] = {l.from, (l.to == surface[l.to]) ? 0 : l.to};\n    if (bid <= N) return;\n    int b = base[bid]; label_blossom(b, mate[bid] = m, l);\n    l = search_blossom_edge(bid);\n    for (int bv = b, bw; node[bv].next != b; bv = node[bw].next) {\n      label_blossom(bw = node[bv].next, 0, l);\n      label_blossom(node[bw].next, node[bw].from, {node[bv].from, node[bv].to});\n    }\n  }\n\n  int find_mate(int bid) {\n    return bid <= N ? mate[bid] : mate[bid] = find_mate(base[bid]);\n  }\n\n  void push_inner_blossom_rec(int bid, bool push=true) {\n    tree_label[bid] = (bid <= N) ? INNER : UNUSED;\n    if (bid > N) {\n      int v = base[bid], u = v;\n      do { push_inner_blossom_rec(v, push); } while ( (v = node[v].next) != u);\n    } else if (push) inner_vertices[inner_vertices_size++] = bid;\n  }\n\n  void push_inner_blossom(int bid) {\n    if (tree_label[bid] != UNUSED) return;\n    bool push = label[bid].from != SEPARATED;\n    if (bid > N) {\n      if (push) inner_blossoms[inner_blossom_size++] = bid; \n      push_inner_blossom_rec(bid, push);\n    } else if (push) inner_vertices[inner_vertices_size++] = bid;\n    tree_label[bid] = INNER;\n  }\n\n  void push_outer_blossom_rec(int bid) {\n    tree_label[bid] = (bid <= N) ? OUTER : UNUSED;\n    if (bid > N) {\n      int v = base[bid], u = v;\n      do { push_outer_blossom_rec(v); } while ( (v = node[v].next) != u );\n    } else outer_vertices.enqueue(bid);\n  }\n\n  void push_outer_blossom(int bid, bool push) {\n    push_outer_blossom_rec(bid);\n    if (bid <= N) return;\n    if (push) outer_blossoms[outer_blossom_size++] = bid, tree_label[bid] = OUTER;\n    else tree_label[bid] = UNUSED;\n  }\n\n  inline void merge_edge(int x, int bx, int eid) {\n    auto& e = edges[eid];\n    int y = e.to, by = surface[y];\n    if (tree_label[by] != OUTER || bx == by) return;\n    auto r_cost = reduced_cost(x, y, e);\n    if (r_cost < best_cost[by].first) {\n      if (best_cost[by].first == INF) merged_edges[merged_edge_size++] = by;\n      best_cost[by] = {r_cost, eid};\n    }\n  }\n\n  inline void merge_vertex(int x, int bx) {\n    for (int eid = ofs[x]; eid < ofs[x + 1]; ++eid) merge_edge(x, bx, eid);\n    best_edge[x] = UNDEFINED;\n  }\n\n  void clear_best_edges(int b) {\n    if (b > N) {\n      int v = b = base[b];\n      do { clear_best_edges(v); } while ( (v = node[v].next) != b );\n    } else best_edge[b] = UNDEFINED;\n  }\n\n  void merge_outer(int b, int bid) {\n    if (b > N) {\n      for (int eid = be_head[b]; eid >= 0; eid = be_next[eid]) {\n        merge_edge(edges[eid].from, bid, eid);\n      }\n      be_head[b] = -1;\n      clear_best_edges(b);\n    } else merge_vertex(b, bid);\n  }\n\n  void merge_inner(int b, int bid) {\n    if (b > N) {\n      int v = b = base[b];\n      do { merge_inner(v, bid); } while ((v = node[v].next) != b);\n    } else merge_vertex(b, bid);\n  }\n\n  void build_linked_list(int bid) {\n    if (bid <= N) return;\n    int last = -1;\n    for (; merged_edge_size > 0; ) {\n      int by = merged_edges[--merged_edge_size], eid = best_cost[by].second;\n      int x = edges[eid].from, y = edges[eid].to;\n      be_next[eid] = last;\n      if (tree_label[y] == OUTER) update_best_edge(y, by, best_cost[by].first, eid);\n      if (best_edge[x] == UNDEFINED || best_cost[by].first < reduced_cost(best_edge[x])) {\n        best_edge[x] = eid;\n      }\n      best_cost[by] = {INF, UNDEFINED};\n      last = eid;\n    }\n    be_head[bid] = last;\n  }\n\n  void merge_best_edges(int bid, int inner_count) {\n    for (int i = 0; i < inner_count; ++i) {\n      int bv = outer_blossoms[outer_blossom_size + i];\n      if (bv >= 0) merge_outer(bv, bid), merge_inner(node[bv].next, bid);\n      else merge_inner(~bv, bid), merge_outer(node[~bv].next, bid);\n    }\n    merge_outer(base[bid], bid);\n    build_linked_list(bid);\n  }\n\n  void contract(int x, int y, int eid) {\n    int s = surface[x], t = surface[y];\n    if (s == t) return;\n    auto h = label[surface[mate[s]]].from = label[surface[mate[t]]].from = -encode(eid);\n\n    int lca = -1;\n    for (; ; label[surface[mate[s]]].from = h) {\n      if (mate[t] != 0) swap(s, t);\n      s = lca = surface[label[s].from];\n      if (label[surface[mate[s]]].from == h) break;\n    }\n\n    int inner_count = 0;\n    for (int dir = 0; dir < 2; ++dir) {\n      int v = (dir == 0) ? x : y;\n      while (1) {\n        int bv = surface[v], mv = mate[bv], bmv = surface[mv];\n        if (bv == lca) break;\n        label[mv] = label[bmv] = {x, y};\n        auto n = node[bmv];\n        if (!dir) {\n          node[bv] = {bmv, mate[mv], mv};\n          node[bmv].next = surface[n.to];\n        } else {\n          node[surface[n.to]] = {bmv, n.to, n.from};\n          node[bmv] = {bv, mv, mate[mv]}; \n        }\n        push_outer_blossom(bmv, false);\n        v = label[bv].from;\n\n        // Caution: used as temporary array\n        outer_blossoms[outer_blossom_size + (inner_count++)] = !dir ? bv : ~bmv;\n      }\n    }\n    node[surface[y]] = {surface[x], y, x};\n\n    int bid = next_bid.back(); next_bid.pop_back();\n    base[bid] = lca, label[bid].from = label[lca].from, mate[bid] = mate[lca];\n\n    tree_label[bid] = OUTER;\n    set_surface(bid, bid);\n    merge_best_edges(bid, inner_count);\n\n    outer_blossoms[outer_blossom_size++] = bid;\n  }\n\n  inline void update_best_edge(int y, int by, weight_t r_cost, int eid) {\n    if (tree_label[by] != OUTER && best_edge[y] == UNDEFINED) {\n      neighbors[neighbor_size++] = y;\n    }\n    if (best_edge[y] == UNDEFINED || r_cost < reduced_cost(best_edge[y])) {\n      best_edge[y] = eid;\n    }\n  }\n\n  void build_edge_list(int b) {\n    if (b <= N) return;\n    merge_inner(b, b);\n    build_linked_list(b);\n  }\n\n  bool augmented(int root, int s) {\n    if (s == 0) {\n      int br = surface[root];\n      push_outer_blossom(br, true);\n      label_blossom(br, 0, {0, 0});\n      build_edge_list(br);\n    } \n    for (; !outer_vertices.empty() || s > 0; s = 0) {\n      auto x = (s > 0) ? s : outer_vertices.dequeue();\n      if (potential[x] == 0) {\n        if (root != x) rematch(x, 0);\n        return true;\n      }\n      for (int eid = ofs[x]; eid < ofs[x + 1]; ++eid) {\n        int bx = surface[x], y = edges[eid].to, by = surface[y];\n        if (bx == by) continue;\n        auto r_cost = reduced_cost(x, y, edges[eid]);\n        if (r_cost > 0 || tree_label[by] != OUTER) {\n          update_best_edge(y, by, r_cost, eid);\n          if (r_cost > 0) continue;\n        }\n        if (label[by].from >= 0) {\n          contract(x, y, eid);\n          continue;\n        } \n        if (tree_label[by] == UNUSED) {\n          push_inner_blossom(by);\n          if (by != y) label_blossom(by, find_mate(by), {DEFAULT, 0});\n        }\n        int z = mate[by];\n        if (z == 0 && by != surface[root]) {\n          rematch(x, y); rematch(y, x);\n          return true;\n        }\n        int bz = surface[z];\n        if (label[bz].from < 0) {\n          node[by] = {-1, y, x};\n          push_outer_blossom(bz, true);\n          label_blossom(bz, mate[z], {x, y});\n          build_edge_list(bz);\n        }\n      }\n    }\n    return false;\n  }\n\n  void set_surface(int b, int bid) {\n    for (int v = base[b]; surface[v] != bid; v = node[v].next) {\n      if (v > N) tree_label[v] = UNUSED, set_surface(v, bid);\n      surface[v] = bid;\n    }\n  }\n  \n  void reset_surface(int b, int bid) {\n    surface[b] = bid;\n    if (b <= N) return;\n    for (b = base[b]; surface[b] != bid; b = node[b].next) reset_surface(b, bid);\n  }\n\n  void separate_blossom(int bid, bool push_blossom=true) {\n    tree_label[bid] = UNUSED, label[bid].from = SEPARATED;\n    if (bid <= N) return;\n    if (push_blossom) inner_blossoms[inner_blossom_size++] = bid;\n    for (int b = base[bid]; label[b].from != SEPARATED; b = node[b].next) {\n      separate_blossom(b, false);\n    }\n  }\n\n  void reverse_blossom(int b) {\n    int v = b, fr = node[b].from, to = node[b].to;\n    for (int nv = node[v].next; nv != b; ) {\n      int nnext = node[nv].next, nfr = node[nv].from, nto = node[nv].to;\n      node[nv].next = v, node[nv].from = to, node[nv].to = fr;\n      fr = nfr, to = nto, v = nv, nv = nnext;\n    }\n    node[b].next = v, node[b].from = to, node[b].to = fr;\n  }\n\n  void expand_blossom(int bid) {\n    next_bid.push_back(bid); tree_label[bid] = UNUSED;\n    for (int b = base[bid]; surface[b] == bid; b = node[b].next) reset_surface(b, b);\n    int old_base = base[bid], target = surface[node[bid].from]; \n    if (mate[node[target].from] == node[target].to) reverse_blossom(old_base);\n    for (int b = target; node[b].next != old_base; ) {\n      separate_blossom(b = node[b].next); separate_blossom(b = node[b].next);\n    }\n    node[target] = node[bid];\n    for (int b = old_base; ; b = node[b].next) {\n      label[b].from = DEFAULT, tree_label[b] = INNER; \n      if (b > N) inner_blossoms[inner_blossom_size++] = b;\n      int m = find_mate(b), bm = surface[m];\n      if (b != old_base) mate[bm] = mate[m];\n      label[m] = label[bm] = {node[b].to, node[b].from};\n      if (b == target) break;\n      push_outer_blossom(b = node[b].next, true);\n      build_edge_list(b);\n    }\n    base[bid] = bid, surface[bid] = bid;\n  }\n\n  void update_potential(int* vs, int s, weight_t delta, int label) {\n    for (int i = 0; i < s; ++i) {\n      int x = vs[i];\n      if (tree_label[x] != label) continue;\n      potential[x] += delta;\n    }\n  }\n\n  int adjust_dual_solutions() {\n    pair<weight_t, int> delta1(INF, 0), delta2(INF, 0), delta3(INF, 0), delta4(INF, 0);\n    for (int i = 0; i < outer_vertices.size(); ++i) {\n      int y = outer_vertices[i], eid = best_edge[y];\n      delta1 = min(delta1, {potential[y], y});\n      if (eid != UNDEFINED) {\n        delta3 = min(delta3, {reduced_cost(eid) >> 1, y});\n      }\n    }\n    for (int i = 0; i < neighbor_size; ++i) {\n      int y = neighbors[i];\n      if (tree_label[y] == UNUSED) {\n        int eid = best_edge[y], x = edges[eid].from;\n        delta2 = min(delta2, {reduced_cost(x, y, edges[eid]), x});\n      }\n    }\n    for (int i = 0; i < inner_blossom_size; ++i) {\n      if (tree_label[inner_blossoms[i]] == INNER) {\n        int b = inner_blossoms[i];\n        delta4 = min(delta4, {potential[b] >> 1, b});\n      }\n    }\n    auto delta = min(min(delta1, delta2), min(delta3, delta4));\n    auto d = delta.first;\n    update_potential(outer_vertices.data(), outer_vertices.size(), -1 * d, OUTER);\n    update_potential(inner_vertices.data(), inner_vertices_size,    1 * d, INNER);\n    update_potential(outer_blossoms.data(), outer_blossom_size,     2 * d, OUTER);\n    update_potential(inner_blossoms.data(), inner_blossom_size,    -2 * d, INNER);\n    if (delta4.first == d) {\n      expand_blossom(delta4.second);\n      return -1;\n    } else {\n      return delta.second;\n    }\n  }\n\n  void fix_blossom_bases() {\n    int remain = size - next_bid.size() - (N + 1);\n    for (int bid = N + 1; bid < size && remain > 0; ++bid) if (base[bid] != bid) {\n      int b = base[bid];\n      for (int skipped = 0; skipped < 2;) {\n        b = node[b].next;\n        if (mate[node[b].from] == node[b].to) skipped = 0;\n        else skipped++;\n      }\n      base[bid] = b;\n      --remain;\n    }\n  }\n\n  void free_edge_list(int x) {\n    be_head[x] = -1;\n  }\n\n  void clear_vertices(int* vs, int size) {\n    for (int i = 0; i < size; ++i) {\n      int v = vs[i]; \n      label[v] = {DEFAULT, 0}; tree_label[v] = UNUSED; best_edge[v] = UNDEFINED;\n    }\n  }\n\n  void clear_label() {\n    label[0] = {DEFAULT, 0};\n    clear_vertices(outer_vertices.data(), outer_vertices.size()); outer_vertices.clear();\n    clear_vertices(inner_vertices.data(), inner_vertices_size); inner_vertices_size = 0;\n    clear_vertices(outer_blossoms.data(), outer_blossom_size);\n    for (int i = 0; i < outer_blossom_size; ++i) {\n      if (be_head[outer_blossoms[i]] >= 0) free_edge_list(outer_blossoms[i]);\n    }\n    outer_blossom_size = 0;\n    clear_vertices(inner_blossoms.data(), inner_blossom_size); inner_blossom_size = 0;\n    for (int i = 0; i < neighbor_size; ++i) best_edge[neighbors[i]] = UNDEFINED;\n    neighbor_size = 0;\n  }\n\n  void set_potential() {\n    potential.resize(size);\n    for (int u = 1; u <= N; ++u) {\n      weight_t max_w = 0;\n      for (int eid = ofs[u]; eid < ofs[u + 1]; ++eid) {\n        max_w = max(max_w, edges[eid].weight);\n      }\n      potential[u] = max_w >> 1;\n    }\n  }\n\n  void initialize() {\n    mate.assign(size, 0);\n    label.assign(size, {-1, 0});\n\n    surface.resize(size); for (int i = 0; i < size; ++i) surface[i] = i;\n    base.resize(size); for (int i = 0; i < size; ++i) base[i] = i;\n    node.resize(size); for (int i = 0; i < size; ++i) node[i] = {i, i, i};\n\n    outer_vertices = Queue(N);\n    inner_vertices.resize(N + 1); inner_vertices_size = 0;\n    outer_blossoms.resize(B); outer_blossom_size = 0;\n    inner_blossoms.resize(B); inner_blossom_size = 0;\n\n    tree_label.assign(size, UNUSED);\n\n    next_bid.resize(B);\n    for (int i = 0; i < B; ++i) next_bid[i] = size - 1 - i;\n\n    merged_edges.resize(N + 1); merged_edge_size = 0;\n    best_cost.assign(size, {INF, UNDEFINED});\n\n    neighbors.resize(N + 1); neighbor_size = 0;\n    best_edge.assign(size, UNDEFINED);\n\n    be_head.assign(size, -1);\n    be_next.resize(edges.size());\n  }\n\nprivate:\n  int N, B, size;\n  vector<Edge> edges;\n  vector<int> ofs;\n\n  vector<Label> label;\n  vector<int> mate, surface, base;\n  vector<Node> node;\n  vector<weight_t> potential;\n\n  vector<int> next_bid;\n\n  vector<int8_t> tree_label;\n\n  Queue outer_vertices;\n  vector<int> inner_vertices; int inner_vertices_size;\n  vector<int> outer_blossoms; int outer_blossom_size;\n  vector<int> inner_blossoms; int inner_blossom_size;\n\n  vector<int> merged_edges; int merged_edge_size;\n  vector< pair<weight_t, int> > best_cost;\n  vector<int> neighbors; int neighbor_size;\n  vector<int> best_edge;\n\n  vector<int> be_head, be_next;\n};\n\nconst ll MX=10000100;\n\nint main(){\n  vector<bool> prime(MX,true);\n  prime[0]=prime[1]=false;\n  for(ll i=2;i*i<MX;i++){\n    for(ll j=2;i*j<MX;j++){prime[i*j]=false;}\n  }\n  ll N;\n  cin>>N;\n  vector<bool> A(MX,false);\n  for(int i=0;i<N;i++){\n    ll x;\n    cin>>x;\n    A[x]=true;\n  }\n  vector<ll> pt;\n  for(ll i=1;i<MX;i++){\n    if(A[i-1]!=A[i]){pt.push_back(i);}\n  }\n  ll M=pt.size();\n  using Edge = MaximumWeightedMatching<int>::Edge;\n  vector<Edge> E;\n  for(int i=0;i<M;i++){\n    for(int j=0;j<i;j++){\n      if((pt[i]-pt[j])&1){\n        if(prime[pt[i]-pt[j]]){E.push_back({j+1,i+1,1});}\n        else{E.push_back({j+1,i+1,3});}\n      }\n      else{\n        E.push_back({j+1,i+1,2});\n      }\n    }\n  }\n  //cout<<E.size()<<endl;\n  //for(auto &I:E){cout<<I.from<<\" \"<<I.to<<\" \"<<I.weight<<endl;}\n  MaximumWeightedMatching<int> MM(N,E);\n  cout<<MM.maximum_weighted_matching()<<endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<cstring>\nusing namespace std;\nint n;\nint res;\nvector<int>v;\nint lst=-1;\nint match[210];\nint me,mo;\nint mx;\nbool f[10000010];\nbool ok[210][210];\nbool vis[210];\nint prm[1000010];\nint sz;\nint l;\nbool bp(int x)\n{\n\tfor(int i=0;i<l;i++)\n\t{\n\t\tif(!ok[x][i])continue;\n\t\tif(vis[i])continue;\n\t\tvis[i]=true;\n\t\tif(match[i]==-1 || bp(match[i]))\n\t\t{\n\t\t\tmatch[i]=x;\n\t\t\treturn true;\n\t\t}\n\t\tvis[i]=false;\n\t}\n\treturn false;\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint x;\n\t\tscanf(\"%d\",&x);\n\t\tif(x!=lst+1)\n\t\t{\n\t\t\tif(lst+1)v.push_back(lst+1);\n\t\t\tv.push_back(x);\n\t\t}\n\t\tlst=x;\n\t\tmx=lst+1;\n\t}\n\tv.push_back(lst+1);\n\tf[1]=true;\n\tfor(int i=2;i<=mx;i++)\n\t{\n\t\tif(!f[i])prm[++sz]=i;\n\t\tfor(int j=1;j<=sz;j++)\n\t\t{\n\t\t\tif(prm[j]*i>mx)break;\n\t\t\tf[prm[j]*i]=true;\n\t\t\tif(i%prm[j]==0)break;\n\t\t}\n\t}\n\tl=v.size();\n\tfor(int i=0;i<l;i++)\n\t{\n\t\tmatch[i]=-1;\n\t\tif(v[i]&1)mo++;else me++;\n\t\tfor(int j=i+1;j<l;j++)\n\t\t{\n\t\t\tif(v[j]-v[i]!=2 && !f[v[j]-v[i]])\n\t\t\t{\n\t\t\t\tok[i][j]=ok[j][i]=true;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<l;i++)\n\t{\n\t\tif(match[i]!=-1)continue;\n\t\tmemset(vis,false,sizeof(vis));\n\t\tif(bp(i))res++;\n\t}\n\tprintf(\"%d\",res+((me-res)/2+(mo-res)/2)*2+((me-res)%2)*3);\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <bitset>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio>\n#include <memory.h>\nusing namespace std;\n\nconst int source=201,sink=202;\n\ntypedef pair<int,int> pi;\n\nint n;\nvector<int> b[2];\nint c[105][105];\nint capa[205][205];\nvector<int> adj[205];\nbool used[205];\n\n\n\nbool prime(int n){\n\tn=abs(n);\n\tif(n==1) return false;\n\tfor(int i=2;i<=sqrt(n);i++){\n\t\tif(n%i==0) return false;\n\t}\nreturn true;\n}\n\nint dfs(int v,int t){\n\tif(v==t) return 1;\n\tfor(int i=0;i<adj[v].size();i++){\n\t\tif(capa[v][adj[v][i]]==1&&!used[adj[v][i]]){\n\t\t\tused[adj[v][i]]=true;\n\t\t\tint d=dfs(adj[v][i],t);\n\t\t\tif(d>0){\n\t\t\t\tcapa[v][adj[v][i]]-=d;\n\t\t\t\tcapa[adj[v][i]][v]+=d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\nreturn 0;\n} \n\nint main(){\n\tscanf(\"%d\",&n);\n\tint last=-1;\n\tfor(int i=1;i<=n;i++){\n\t\tint x;\n\t\tscanf(\"%d\",&x);\n\t\tif(x>last+1&&last!=-1) {\n\t\t\tb[(last+1)%2].push_back(last+1);\n\t\t\tb[x%2].push_back(x);\n\t\t}\n\t\telse if(x>last+1) b[x%2].push_back(x);\n\t\tlast=x;\n\t}\n\tb[(last+1)%2].push_back(last+1);\n\tfor(int i=0;i<b[0].size();i++){\n\t\tfor(int j=0;j<b[1].size();j++){\n\t\t\tint x=b[0][i]-b[1][j];\n\t\t\tif(x%2){\n\t\t\t\tif(prime(x)) c[i][j]=1;\n\t\t\t\telse c[i][j]=3;\n\t\t\t}\n\t\t\telse c[i][j]=2;\n\t\t}\n\t}\n\tfor(int i=0;i<b[0].size();i++){\n\t\tadj[source].push_back(i);\n\t\tadj[i].push_back(source);\n\t\tcapa[source][i]=1;\n\t}\n\tfor(int i=0;i<b[1].size();i++){\n\t\tadj[100+i].push_back(sink);\n\t\tadj[sink].push_back(100+i);\n\t\tcapa[100+i][sink]=1;\n\t}\n\tfor(int i=0;i<b[0].size();i++){\n\t\tfor(int j=0;j<b[1].size();j++){\n\t\t\tif(c[i][j]==1){\n\t\t\t\tadj[i].push_back(100+j);\n\t\t\t\tadj[100+j].push_back(i);\n\t\t\t\tcapa[i][100+j]=1;\n\t\t\t}\n\t\t}\n\t}\n\tint pairnum=0;\n\twhile(dfs(source,sink)){\n\t\tpairnum++;\n\t\tmemset(used,false,sizeof used);\n\t}\n\tint ans=0;\n\tans+=pairnum;\n\tint x=b[0].size()-pairnum,y=b[1].size()-pairnum;\n\tif(x%2&&y%2) ans+=x+y+1;\n\telse ans+=x+y;\n\tprintf(\"%d\\n\",ans);\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N = 5010, M = 1e7+6;\nint prime[M],pcnt,_v[M];\nint k,x[N];\ninline void sieve(int n = 10000000+5){\n\t_v[1]=1;\n\tfor(int i=2;i<=n;i++){\n\t\tif(!_v[i])prime[++pcnt]=i;\n\t\tfor(int j=1;j<=pcnt&&1ll*i*prime[j]<=n;j++){\n\t\t\t_v[i*prime[j]]=1;\n\t\t\tif(i%prime[j]==0)break;\n\t\t}\n\t}\n}\nint id1[N],id2[N],cnt1,cnt2;\nint match[N];\nbool vis[N];\nvector<int> g[N];\n\ninline void adde(int u,int v){\n\tg[u].push_back(v);\n}\n\ninline bool dfs(int x){\n\tfor(size_t i=0;i<g[x].size();i++){\n\t\tint v=g[x][i];\n\t\tif(!vis[v]){\n\t\t\tvis[v]=1;\n\t\t\tif(!match[v]||dfs(match[v])){\n\t\t\t\tmatch[v]=i;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint main()\n{\n//\tfreopen(\"oatmeal.in\",\"r\",stdin);\n//\tfreopen(\"oatmeal.out\",\"w\",stdout);\n\tsieve();\n\tcin >> k;\n\tfor(int i=1;i<=k;i++){\n\t\tscanf(\"%d\",&x[i]);\n\t}\n\tsort(x+1,x+k+1);\n\tfor(int u=1,v;u<=k;u=v+1){\n\t\tv=u;\n\t\twhile(v+1<=k&&x[v+1]==x[v]+1)++v;\n\t\tif(x[u]%2)id1[++cnt1]=x[u];\n\t\telse id2[++cnt2]=x[u];\n\t\tif((x[v]+1)%2)id1[++cnt1]=x[v]+1;\n\t\telse id2[++cnt2]=x[v]+1;\n\t}\n\tfor(int i=1;i<=cnt1;i++)for(int j=1;j<=cnt2;j++){\n\t\tif(!_v[abs(id1[i]-id2[j])]){\n\t\t\tadde(i,j);\n\t\t\t// cout << \"?\" << endl;\n\t\t}\n\t}\n\t// cout << cnt << endl;\n\tint ans=0;\n\tfor(int i=1;i<=cnt1;i++){\n\t\tfor(int j=1;j<N;j++)vis[j]=0;\n\t\tif(dfs(i))ans++;\n\t}\n\t// cout << cnt1 << \" \" << cnt2 << \" \" << ans << endl;\n\tcnt1-=ans,cnt2-=ans;\n\tif(cnt1%2==0){\n\t\tcout << cnt1+cnt2+ans << endl;\n\t}else{\n\t\tcout << cnt1+cnt2+ans+1 << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 209\nusing namespace std;\n\nint n,a[N],pre[N]; bool mp[N][N],bo[N],tg[10000009];\nbool isprm(int x){\n\tif (x==1) return 0;\n\tint i;\n\tfor (i=2; i*i<=x; i++) if (!(x%i)) return 0;\n\treturn 1;\n}\nbool dfs(int x){\n\tint i;\n\tfor (i=1; i<=n; i++) if (bo[i] && mp[x][i]){\n\t\tbo[i]=0;\n\t\tif (!pre[i] || dfs(pre[i])){\n\t\t\tpre[i]=x; return 1;\n\t\t}\n\t}\n\treturn 0;\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tint i,j,k;\n\tfor (i=1; i<=n; i++){\n\t\tscanf(\"%d\",&k); tg[k]=1;\n\t}\n\tfor (i=1,n=0; i<=10000001; i++)\n\t\tif (tg[i]^tg[i-1]) a[++n]=i;\n\tfor (i=1; i<=n; i++) if (a[i]&1)\n\t\tfor (j=1; j<=n; j++) if (a[j]&1^1)\n\t\t\tmp[i][j]=isprm(abs(a[i]-a[j]));\n\tint sum=0;\n\tfor (i=1; i<=n; i++) if (a[i]&1){\n\t\tmemset(bo,1,sizeof(bo));\n\t\tsum+=dfs(i);\n\t}\n\tint b[2];\n\tfor (i=1; i<=n; i++) b[a[i]&1]++;\n\tb[0]-=sum; b[1]-=sum;\n\tprintf(\"%d\\n\",sum+b[0]+b[1]+(b[0]&b[1]&1));\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<cstdio>\n#include<iostream>\n#include<cstring>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nconst int N=1010,INF=1000000007;\nvector<int>s[N],w[N],back[N];\nint cur[N],vis[N],d[N],q[N];\nint g[N],A[N],B[N],a[N];\nint notprime[10101010],pri[10101010];\nint cnt,cntt;\nvoid cl(int n)\n{\n\tint i;\n\tfor(i=0;i<=n;i++)\n\t\ts[i].clear(),w[i].clear(),back[i].clear();\n}\nvoid jiantu(int x,int y,int l)\n{\n    s[x].push_back(y);\n    s[y].push_back(x);\n    w[x].push_back(l);\n    w[y].push_back(0);\n    back[x].push_back(s[y].size()-1);\n    back[y].push_back(s[x].size()-1);\n}\nint bfs(int st,int en)\n{\n    int h=0,t=1,x,c,i,y;\n    memset(cur,0,sizeof(cur));\n    memset(d,0,sizeof(d));\n    memset(vis,0,sizeof(vis));\n    vis[st]=1,q[h]=st;\n    while(h<t)\n    {\n        x=q[h++];\n        if(x==en)\n            continue;\n        c=s[x].size();\n        for(i=0;i<c;i++)\n        {\n            y=s[x][i];\n            if(w[x][i]==0||vis[y]==1)\t\n                continue;\n            vis[y]=1;\n            d[y]=d[x]+1;\n            q[t++]=y;\n        }\n    }\n    return d[en];\n}\nint dfs(int x,int en,int f)\n{\n    if(x==en) return f;\n    int tmp,ans=0,c,i,y;\n    c=s[x].size();\n    for(i=cur[x];i<c;i++)\n    {\n        cur[x]=i;\n        y=s[x][i];\n        if(w[x][i]==0||d[y]!=d[x]+1)\n            continue;\n        tmp=dfs(y,en,min(f-ans,w[x][i]));\n        ans+=tmp;\n        w[x][i]-=tmp;\n        w[y][back[x][i]]+=tmp;\n        if(ans==f)\n            return ans;\n    }\n    d[x]=-1;\n    return ans;\n}\nint dinic(int st,int en)\n{\n    int ans=0;\n    while(bfs(st,en))\n        ans+=dfs(st,en,INF);\n    return ans;\n}\nvoid sieve(int n)\n{\n\tint i,j;\n\tnotprime[1]=1;\n\tfor(i=2;i<=n;i++)\n\t{\n\t\tif(!notprime[i])\n\t\t\tpri[++cntt]=i;\n\t\tfor(j=1;j<=cntt;j++)\n\t\t{\n\t\t\tif(i*pri[j]>n)\n\t\t\t\tbreak;\n\t\t\tnotprime[i*pri[j]]=1;\n\t\t\tif(i%pri[j]==0)\n\t\t\t\tbreak;\n\t\t}\n\t}\n}\nint main()\n{\n\tint T,n,i,j,sum1,sum2,st,en,ans;\n\t//freopen(\".in\",\"r\",stdin);\n\t//freopen(\".out\",\"w\",stdout);\n//\tscanf(\"%d\",&T);\n\tT=1;\n\tsieve(10000000);\n\twhile(T--)\n\t{\n\t\tcnt=0;\n\t\tscanf(\"%d\",&n);\n\t\tfor(i=1;i<=n;i++)\n\t\t\tscanf(\"%d\",&a[i]);\n\t\ta[n+1]=1e9,a[0]=-1e9;\n\t\tfor(i=1;i<=n;i++)\n\t\t{\n\t\t\tif(a[i]!=a[i-1]+1)\n\t\t\t\tg[++cnt]=a[i];\n\t\t\tif(a[i]+1!=a[i+1])\n\t\t\t\tg[++cnt]=a[i]+1;\n\t\t}\n\t\tsum1=sum2=0;\n\t\tfor(i=1;i<=cnt;i++)\n\t\t{\n\t\t\tif(g[i]&1)\n\t\t\t\tsum1++,A[sum1]=g[i];\n\t\t\telse\n\t\t\t\tsum2++,B[sum2]=g[i];\n\t\t}\n//\t\tprintf(\"%d %d\\n\",sum1,sum2);\n\t\tst=0,en=cnt+1;\n\t\tfor(i=1;i<=sum1;i++)\n\t\t\tjiantu(st,i,1);\n\t\tfor(i=1;i<=sum2;i++)\n\t\t\tjiantu(i+sum1,en,1);\n\t\tfor(i=1;i<=sum1;i++)\n\t\t\tfor(j=1;j<=sum2;j++)\n\t\t\t\tif(!notprime[abs(A[i]-B[j])])\n\t\t\t\t\tjiantu(i,j+sum1,1);\n\t\tans=dinic(st,en);\n\t\tcl(en);\n\t\tprintf(\"%d\\n\",ans+((sum1-ans)/2)*2+((sum2-ans)/2)*2+((sum1-ans)&1)*3);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int maxn=205;\nconst int maxm=10000005;\nconst int INF=0x3f3f3f;\n\nint n;\nint c[maxm];\nint p1[maxn],tot1=0,p2[maxn],tot2=0,nn;\n\nstruct Edge\n{\n\tint from,to,capa,flow,nxt;\n}e[maxn*maxn];\n\nint h[maxn],tot=-1;\n\ninline void addedge(int a,int b,int c) { e[++tot].from=a; e[tot].to=b; e[tot].capa=c; e[tot].flow=0; e[tot].nxt=h[a]; h[a]=tot; }\n\nbool check(int p)\n{\n\tif (p==1) return 0;\n\tfor (int i=2;i*i<=p;i++) if (p%i==0) return 0;\n\treturn 1;\n}\n\nint s,t,d[maxn],cur[maxn],vis[maxn];\n\nint dfs(int p,int a)\n{\n\tif (p==t || !a) return a;\n\tint flow=0,f;\n\tfor (int &i=cur[p];~i;i=e[i].nxt)\n\tif (d[e[i].to]==d[p]+1 && e[i].capa>e[i].flow)\n\t{\n\t\tf=dfs(e[i].to,min(a,e[i].capa-e[i].flow));\n\t\tif (f)\n\t\t{\n\t\t\tflow+=f; a-=f;\n\t\t\te[i].flow+=f; e[i^1].flow-=f;\n\t\t}\n\t\tif (!a) break;\n\t}\n\tif (a) d[p]=-1;\n\treturn flow;\n}\n\nint bfs()\n{\n\tqueue<int> q;\n\tmemset(vis,0,sizeof(vis));\n\tq.push(s); vis[s]=1; d[s]=0;\n\twhile (!q.empty())\n\t{\n\t\tint o=q.front(); q.pop();\n\t\tfor (int i=h[o];~i;i=e[i].nxt)\n\t\tif (!vis[e[i].to] && e[i].capa>e[i].flow)\n\t\t{\n\t\t\tvis[e[i].to]=1; q.push(e[i].to);\n\t\t\td[e[i].to]=d[o]+1;\n\t\t}\n\t}\n\treturn vis[t];\n}\n\nint Dinic()\n{\n\tint flow=0;\n\twhile (bfs())\n\t{\n\t\t//cout<<\"GG\";\n\t\tfor (int i=1;i<=nn;i++) cur[i]=h[i];\n\t\tflow+=dfs(s,INF);\n\t}\n\treturn flow;\n}\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\tint tmp,mx=0;\n\tfor (int i=1;i<=n;i++) { scanf(\"%d\",&tmp); mx=max(mx,tmp); c[tmp]=1; } mx++;\n\t//for (int i=mx;i>=1;i--) c[i]=c[i-1]^c[i];\n\t//for (int i=1;i<=mx;i++) cout<<c[i];\n\tfor (int i=1;i<=mx;i++)\n\tif (c[i]!=c[i-1])\n\t{\n\t\tif (i&1) p1[++tot1]=i;\n\t\t\telse p2[++tot2]=i;\n\t}\n\tnn=tot1+tot2+1; s=0; t=nn;\n\t//cout<<nn<<endl;\n\tmemset(h,-1,sizeof(h));\n\tfor (int i=1;i<=tot1;i++) { addedge(s,i,1); addedge(i,s,0); }\n\tfor (int i=1;i<=tot2;i++) { addedge(i+tot1,t,1); addedge(t,i+tot1,0); }\n\tfor (int i=1;i<=tot1;i++)\n\t\tfor (int j=1;j<=tot2;j++)\n\t\t\tif (check(abs(p2[j]-p1[i]))) { addedge(i,i+tot1,1); addedge(i+tot1,i,0); }\n\tint flow=Dinic(),ans=0;\n\t//cout<<\"GG\";\n\tans=flow;\n\tans+=(tot1-flow)/2*2+(tot2-flow)/2*2;\n    ans+=((tot1-flow)&1)*3;\n    cout<<ans;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cstdlib>\nusing namespace std;\n\n#define re_ return\n#define in_ inline\n#define op_ operator\n#define inc(l, i, r) for(i=l; i<r; ++i)\n#define st_ static\ntypedef long long ll;\n\nconst int mxn=1<<9;\n\nint n, m, a[mxn], b[mxn<<1], cnt[2], h[mxn<<1];\nstruct edge{int v, o;} e[mxn<<2];\n\nin_ ll dP(ll a, ll b, ll p)\n{\n    st_ ll r;\n    for(r=1; b; a=a*a%p, b>>=1)\n        b&1? r=r*a%p: 0;\n    re_ r;\n}\n\nin_ char chk(ll a, ll p)\n{\n    st_ ll s, r, i;\n    for(r=p-1, s=0; ~r&1; ++s, r/=2);\n    if(i=dP(a, r, p), i==1 || i==p-1) re_ 1;\n    for(;s--;)\n        if((i=i*i%p)==p-1) re_ 1;\n    re_ 0;\n}\n\nin_ char isP(int p)\n{\n    if(p==2) re_ 1;\n    if(p==1 || ~p&1) re_ 0;\n    st_  int i;\n    inc(0, i, 32)\n        if(!chk(rand()%(p-2)+1, p))\n            re_ 0;\n    re_ 1;\n}\n\nin_ void aE(int u, int v)\n{\n    st_ int tot;\n    e[++tot]=(edge){v, h[u]}, u[h]=tot;\n}\n\nchar vis[mxn<<1];\nchar Hun(int u)\n{\n    st_ int f[mxn<<1];\n    int i, v;\n    for(i=u[h]; v=i[e].v; i=i[e].o)\n        if(!vis[v])\n            if(vis[v]=1, !f[v] || Hun(f[v]))\n            re_ f[v]=u, 1;\n    re_ 0;\n}\n\nint main()\n{\n    srand(998244353);\n    int i, j;\n    scanf(\"%d\", &n);\n    inc(0, i, n)\n        scanf(\"%d\", a+i);\n    sort(a, a+n);\n    inc(0, i, n)\n    {\n        if(!i || a[i]>a[i-1]+1)\n            b[++m]=a[i], ++cnt[a[i]&1];\n        if(i>n-2 || a[i]<a[i+1]-1)\n            b[++m]=a[i]+1, ++cnt[a[i]+1&1];\n    }\n    inc(1, i, m+1)\n        if(b[i]&1)\n            inc(1, j, m+1)\n                if(~b[j]&1 && isP(abs(b[i]-b[j])))\n                    aE(i, j);\n\n    j=0;\n    inc(1, i, m+1)\n        if(b[i]&1)\n            memset(vis, 0, sizeof(vis)),\n                j+=Hun(i);\n\n    printf(\"%d\\n\", cnt[0]+cnt[1]-j+(cnt[0]-j&1));\n//    printf(\"%d\\n\", m);\n//    for(;;) scanf(\"%d\", &i), printf(\"%d\\n\", isP(i));\n    re_ 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <cstdio>\nusing namespace std;\n\nconst int M = 1e7;\nconst int N = 2e2 + 10;\nstruct E {int v, nt;} e[N*N];\nint n, c, cnt, tot, h[N], x[N], p[M+10], mask[N], used[N];\n\ninline void add(int u, int v) {\n\te[++tot] = (E){v, h[u]}, h[u] = tot;\n\te[++tot] = (E){u, h[v]}, h[v] = tot;\n}\n\ntemplate <class T> inline void in(T &x) {\n\tx = 0; int f = 1; char ch = getchar();\n\tfor (; ch<'0' || ch>'9';) {if (ch=='-') f=-1; ch = getchar();}\n\tfor (; ch>='0' && ch<='9';) x = x*10 + ch-'0', ch = getchar();\n\tx *= f;\n}\n\ninline void init() {\n\tfor (int i = 3; i <= M; i += 2) p[i] = 1;\n\tfor (int i = 3; i * i <= M; i += 2) {\n\t\tif (!p[i]) continue;\n\t\tfor (int j = i * i; j <= M; j += i) p[j] = 0;\n\t}\n}\n\ninline int dfs(int x) {\n\tint v; used[x] = 1;\n\tfor (int v, i = h[x]; i; i = e[i].nt)\n\t\tif (!mask[v = e[i].v] || (!used[mask[v]] && dfs(mask[v]))) {\n\t\t\tmask[v] = x, mask[x] = v; return 1;\n\t\t}\n\treturn 0;\n}\n\ninline int match() {\n\tint res = 0;\n\tfill(mask + 1, mask + c + 1, 0);\n\tfor (int i = 1; i <= c; ++i)\n\t\tif (!mask[i]) {\n\t\t\tfill(used + 1, used + c + 1, 0);\n\t\t\tif (dfs(i)) ++res;\n\t\t}\n\treturn res;\n}\n\ninline void work() {\n\tint val; in(n);\n\tfor (int i = 1; i <= n; ++i) {\n\t\tin(val);\n\t\tif (!c || val != x[c]) x[++c] = val;\n\t\telse --c;\n\t\tx[++c] = val + 1;\n\t}\n\tfor (int i = 1; i <= c; ++i) if (x[i] % 2 == 0) ++cnt;\n\tfor (int i = 1; i <= c; ++i)\n\t\tfor (int j = i + 1; j <= c; ++j)\n\t\t\tif (p[x[j] - x[i]]) add(i, j);\n\tint ret = match();\n\tprintf(\"%d\\n\", c / 2 + (c / 2 - ret) + (cnt - ret) % 2);\n}\n\nint main() {init(), work(); return 0;}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\ntypedef std::pair <int, int> pr;\ntypedef std::map <int, int> map;\nconst int N = 108;\n\nint n, O, E;\nint o[N], e[N];\nmap S;\nint pn = 0, c[10000054], p[666666];\n\nvoid sieve(int n) {\n\tint i, j, v;\n\tmemset(c, -1, sizeof c);\n\tfor (i = 2; i <= n; ++i) {\n\t\tif (!~c[i]) p[pn] = i, c[i] = pn++;\n\t\tfor (j = 0; (v = i * p[j]) <= n && j <= c[i]; ++j) c[v] = j;\n\t}\n}\n\ninline bool is_prime(int x) {return p[c[x]] == x;}\n\nnamespace F {\n\t#define ad(x) ((x - 1 ^ 1) + 1)\n\n\tconst int N = 2000, M = 100000;\n\n\tstruct edge {\n\t\tint u, v, f;\n\t\tedge (int u0 = 0, int v0 = 0, int f0 = 0) : u(u0), v(v0), f(f0) {}\n\t} e[M];\n\n\tint V = 2, E = 0, si = 1, ti = 2, flow;\n\tint first[N], next[M];\n\tint dep[N], cur[N], que[N];\n\n\tinline void addedge(int u, int v, int f) {\n\t\te[++E] = edge(u, v, f), next[E] = first[u], first[u] = E;\n\t\te[++E] = edge(v, u), next[E] = first[v], first[v] = E;\n\t}\n\n\tbool bfs() {\n\t\tint h, t = 1, i, x, y;\n\t\tmemset(dep, -1, sizeof dep);\n\t\tque[0] = si, dep[si] = 0;\n\t\tfor (h = 0; h < t; h++) {\n\t\t\tif ((x = que[h]) == ti) return true;\n\t\t\tfor (i = first[x]; i; i = next[i])\n\t\t\t\tif (dep[y = e[i].v] == -1 && e[i].f)\n\t\t\t\t\tque[t++] = y, dep[y] = dep[x] + 1;\n\t\t}\n\t\treturn false;\n\t}\n\n\tint dfs(int x, int lim) {\n\t\tint a, c, f = 0;\n\t\tif (x == ti || !lim) return lim;\n\t\tfor (int &i = cur[x]; i; i = next[i])\n\t\t\tif (dep[e[i].v] == dep[x] + 1 && e[i].f) {\n\t\t\t\ta = std::min(lim - f, e[i].f);\n\t\t\t\tc = dfs(e[i].v, a);\n\t\t\t\te[i].f -= c; e[ad(i)].f += c;\n\t\t\t\tif ((f += c) == lim) return f;\n\t\t\t}\n\t\treturn f;\n\t}\n\n\tint Dinic() {\n\t\tfor (flow = 0; bfs(); flow += dfs(si, INT_MAX))\n\t\t\tmemcpy(cur, first, sizeof cur);\n\t\treturn flow;\n\t}\n}\n\nint main() {\n\tint i, j, x;\n\tscanf(\"%d\", &n), sieve(10000053);\n\tfor (i = 0; i < n; ++i) scanf(\"%d\", &x), ++S[x], ++S[x + 1];\n\tfor (const pr &p : S) if (p.second & 1) (p.first & 1 ? o[O++] : e[E++]) = p.first;\n\tfor (i = 0; i < O; ++i) F::addedge(1, 3 + i, 1);\n\tfor (j = 0; j < E; ++j) F::addedge(3 + O + j, 2, 1);\n\tfor (i = 0; i < O; ++i)\n\t\tfor (j = 0; j < E; ++j)\n\t\t\tif (is_prime(abs(o[i] - e[j]))) F::addedge(3 + i, 3 + O + j, 1);\n\tx = F::Dinic(), O -= x, E -= x;\n\tprintf(\"%d\\n\", x + O + E + (O & 1));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define REP(I, A) for (int(I) = 0; (I) < (A); (I)++)\n#define pb(I) push_back(I)\nconst int N = 10000000;\n\nset<int> s, e;\nvector<int> vx, vy, Gx[200], pri;\nbool is_prime[N];\nint mat[1000], R;\nbool vis[1000];\n\nvoid prepare() {\n\tis_prime[0] = is_prime[1] = true;\n\tfor (int i = 2; i < N; i++) {\n\t\tif(!is_prime[i]) pri.pb(i);\n\t\tREP(j, pri.size()) {\n\t\t\tif(pri[j] * i >= N) break;\n\t\t\tis_prime[pri[j]*i] = true;\n\t\t\tif(i % pri[j] == 0) break;\n\t\t}\n\t}\n\t//REP(i, 100) printf(\"%d \", pri[i]);\n}\n\nbool dfs(int x) {\n\tfor (int v : Gx[x]) {\n\t\tif (!vis[v]) {\n\t\t\tvis[v] = true;\n\t\t\tif (mat[v + R] == -1 || dfs(mat[v + R])) {\n\t\t\t\tmat[v + R] = x;\n\t\t\t\tmat[x] = v;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\nint domatch() {\n\tmemset(mat, -1, sizeof(mat));\n\tint cnt = 0;\n\tREP(i, vx.size()) {\n\t\tif (mat[i])\n\t\t\tcontinue;\n\t\tmemset(vis, 0, sizeof(vis));\n\t\tcnt += dfs(vx[i]);\n\t}\n\treturn cnt;\n}\n\nint main() {\n\tprepare();\n\tint n, x;\n\tscanf(\"%d\", &n);\n\tR = 110;\n\tREP(i, n) {\n\t\tscanf(\"%d\", &x);\n\t\ts.insert(x);\n\t}\n\tfor (int u : s) {\n\t\tif (!s.count(u - 1))\n\t\t\te.insert(u);\n\t\tif (!s.count(u + 1))\n\t\t\te.insert(u + 1);\n\t}\n\tfor (int u : e)\n\t\tif (u & 1)\n\t\t\tvx.pb(u);\n\t\telse\n\t\t\tvy.pb(u);\n\tREP(i, vx.size())\n\tREP(j, vy.size())\n\tif (!is_prime[abs(vx[i] - vy[j])])\n\t\tGx[i].pb(j);\n\tint t = domatch();\n\tint l1 = vx.size() - t, l2 = vy.size() - t;\n\tint res = t;\n\tres += l1 / 2 * 2;\n\tres += l2 / 2 * 2;\n\tif (l1 % 2 == 1 && l2 % 2 == 1)\n\t\tres += 3;\n\tcout << res << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int inf=2147483647,N=50050;\nstruct edge{\n\tint to,nxt,w;\n}e[N<<1];\nint head[N],cnt,cur[N],deep[N],pos[N];\nint n,m,s,t,ans,tot,even,a[N];\nvoid add(int u,int v,int w)\n{\n\te[++cnt].nxt=head[u];\n\te[cnt].to=v;\n\te[cnt].w=w;\n\thead[u]=cnt;\n}\nbool dinic_bfs(){\n\tqueue<int> q;\n\tmemset(deep,0,sizeof(deep));\n\tdeep[s]=1;\n\tq.push(s);\n\twhile (!q.empty()){\n\t\tint x=q.front();\n\t\tq.pop();\n\t\tfor (int i=head[x];~i;i=e[i].nxt)\n\t\t\tif (e[i].w>0 && deep[e[i].to]==0){\n\t\t\t\tdeep[e[i].to]=deep[x]+1;\n\t\t\t\tq.push(e[i].to);\n\t\t\t}\n\t}\n\treturn deep[t];\n}\n int dinic_dfs(int u,int now){\n        if(u==t)\n            return now;\n        int ret=0;\n        for(int i=cur[u];~i;i=e[i].nxt) {\n            cur[u]=i;\n            if(deep[e[i].to]==deep[u]+1 && e[i].w){\n                int di=dinic_dfs(e[i].to,min(e[i].w,now-ret)); \n                if(di){     \n                    e[i].w-=di;\n                    e[i^1].w+=di;\n                    ret+=di;\n                    if(ret==now)\n                        break;\n                    \n\t\t\t\t}\n            }\n\t\t} \n\t\tdeep[u]=-1;\n        return ret;\n    }\nint dinic(){\n    int ret=0;\n    while(dinic_bfs()){    \n            memcpy(cur,head,sizeof(head));      \n            ret+=dinic_dfs(s,inf);      \n        }\n      return ret; \n}\nbool pd(int n) {\n\tif (n==1||n==2) return false;\n\tfor (int i=2;i*i<=n;i++)\n\t\tif (!(n%i)) return false;\n\treturn true;\n}\nint main(){\n\tmemset(head,-1,sizeof(head));\n    cnt=-1;\n\tscanf(\"%d\",&n);\n    for (int i=1;i<=n;++i){\n        scanf(\"%d\",&a[i]);  \n    }\n\tpos[++tot]=a[1];\n\tfor (int i=2;i<=n;++i)\n\t\tif(a[i-1]<a[i]-1) {\n        \tpos[++tot]=a[i];\n        \tpos[++tot]=a[i-1]+1;\n\t\t}\n    pos[++tot]=a[n]+1;\n    s=0,t=tot+1;\n    for(int i=1;i<=tot;++i){\n    \tif(!(pos[i]&1)) {\n    \t\t++even;\n    \t\tadd(s,i,1);\n\t\t\tadd(i,s,0); \n\t\t}else{\n\t\t\tadd(i,t,1);\n\t\t\tadd(t,i,0);\n\t\t}\n\t}\n    for(int i=1;i<=tot;++i)\n\t\tif(!(pos[i]&1)){\n       \t\tfor(int j=1;j<=tot;++j)\n\t\t\t\tif((pos[j]&1)&&pd(abs(pos[j]-pos[i]))){\n\t\t\t\t\tadd(i,j,1);\n\t\t\t\t\tadd(j,i,0);\n\t\t\t\t}\n\t\t\t\t\t\n    }\n    int ans=dinic();\n    printf(\"%d\\n\",tot-ans+((even-ans)&1));\t\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\nconst int N=1e5;\nint ne[N],he[N],a[N],vis[N],g[N],t[N],tot,b1[N],x,y,b2[N];\nvoid ad(int x,int y)\n{\n\ttot++;\n\tne[tot]=he[x];\n\the[x]=tot;\n\tt[tot]=y;\n}\nvoid put(int v)\n{\n\tif (v&1) \n\t{\n\t\tx++;\n\t\tb1[x]=v;\n\t} else\n\t{\n\t\ty++;\n\t\tb2[x]=v;\n\t}\n}\nint pd(int x)\n{\n\tif (x%2==0) return 0;\n\tif (x==1) return 0;\n\tfor (int i=2;i<=sqrt(x);i++) if (x%i==0) return 0;\n\treturn 1;\n}\nint dfs(int x)\n{\n\tif (vis[x]==tot) return 0;\n\tvis[x]=tot;\n\tint i=he[x];\n\twhile (i)\n\t{\n\t\tif (g[t[i]]==0||dfs(g[t[i]])) \n\t\t{\n\t\t\tg[t[i]]=x;\n\t\t\treturn 1;\n\t\t}\n\t\ti=ne[i];\n\t}\n\treturn 0;\n}\nint main()\n{\n\tint n;\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<=n;i++) scanf(\"%d\",&a[i]);\n\tsort(a+1,a+n+1);\n    put(a[1]-1);\n\tfor (int i=2;i<=n;i++) \n\t{\n\t\tif (a[i]-a[i-1]!=1) \n\t\t{\n\t\t\tput(a[i-1]);\n\t\t\tput(a[i]);\n\t\t}\n\t}\n\tput(a[n]);\n\tfor (int i=1;i<=x;i++) for (int j=1;j<=y;j++) if (pd(abs(b2[j]-b1[i]))) ad(i,j+x);\n\tint ans=0;\n\tfor (int i=1;i<=x;i++) \n\t{\n\t\ttot++;\n\t\tans+=dfs(i);\n\t}\n\tx-=ans;\n\ty-=ans;\n\tif (x&1) \n\t{\n\t\tans+=3;\n\t\tx--;\n\t\ty--;\n\t}\n\tans+=x+y;\n\tprintf(\"%d\\n\",ans); \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fi first\n#define se second\nusing namespace std;\n\nconst int maxn = 200, maxm = 1e7;\nint n, m, k, p[maxm / 10 + 3], a[maxn + 3], mat[maxn + 3];\nmap<int, bool> M;\nbool b[maxm + 3], vis[maxn + 3];\nvector<int> G[maxn + 3];\n\nvoid prework(int n) {\n\tb[1] = true;\n\tfor (int i = 2; i <= n; i++) {\n\t\tif (!b[i]) p[++k] = i;\n\t\tfor (int j = 1; j <= k && i * p[j] <= n; j++) {\n\t\t\tb[i * p[j]] = true;\n\t\t\tif (i % p[j] == 0) break;\n\t\t}\n\t}\n}\n\nbool dfs(int u) {\n\tfor (int i = 0, v; i < G[u].size(); i++) {\n\t\tif (!vis[v = G[u][i]]) {\n\t\t\tvis[v] = true;\n\t\t\tif (!mat[v] || dfs(v)) {\n\t\t\t\tmat[v] = u, mat[u] = v;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\nint main() {\n\tprework(maxm);\n\tscanf(\"%d\", &n);\n\tfor (int i = 1, x; i <= n; i++) {\n\t\tscanf(\"%d\", &x);\n\t\tM[x] ^= 1, M[x + 1] ^= 1;\n\t}\n\tfor (map<int, bool>::iterator it = M.begin(); it != M.end(); it++) {\n\t\tif (it -> se) a[++m] = it -> fi;\n\t}\n\tfor (int i = 1; i <= m; i++) {\n\t\tfor (int j = i + 1; j <= m; j++) {\n\t\t\tif (!b[a[j] - a[i]]) {\n\t\t\t\tG[i].push_back(j), G[j].push_back(i);\n\t\t\t}\n\t\t}\n\t}\n\tint ans = 0;\n\tfor (int i = 1; i <= m; i++) if (a[i] % 2 && !mat[i]) {\n\t\tfill(vis + 1, vis + m + 1, false), ans += dfs(i);\n\t}\n\tint odd = 0, even = 0;\n\tfor (int i = 1; i <= m; i++) if (!mat[i]) {\n\t\tif (a[i] % 2) {\n\t\t\tif (odd) odd = 0, ans += 2;\n\t\t\telse odd = 1;\n\t\t} else {\n\t\t\tif (even) even = 0, ans += 2;\n\t\t\telse even = 1;\n\t\t}\n\t}\n\tif (odd && even) ans += 3;\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define sz(x) ((int)(x).size())\n#define rep(i,a,b) for (int i=(a); i<(b); i++)\n#define per(i,a,b) for (int i=(b-1); i>=(a); i--)\n#define de(x) cout << #x << \" => \" << x << endl\nusing namespace std;\n\n#define fi first\n#define se second\n#define mp make_pair\ntypedef pair<int,int> pii;\n\n#define pb push_back\ntypedef vector<int> vi;\n\ntypedef long long ll;\ntypedef long double ld;\n\n///----------------------------------------------\nstruct Hug {\n    static const int Hug_N = 7 + 3000;\n    int nx, ny;\n    vi G[Hug_N];\n    int par[Hug_N];\n    bool vis[Hug_N];\n    ///init\n    void link(int a, int b) { G[a].pb(b); }\n    void init(int _nx, int _ny) {\n        nx = _nx; ny = _ny;\n        rep(i, 1, nx + 1) G[i].clear();\n    }\n    ///find\n    bool find(int u) {\n        rep(i, 0, sz(G[u])) {\n            int v = G[u][i]; if (vis[v]) continue;\n            for (vis[v] = true; !~par[v] || find(par[v]); ) return par[v] = u, true;\n        }\n        return false;\n    }\n    ///work\n    int work( ) {\n        int ret = 0;\n        rep(i, 1, ny + 1) par[i] = -1;\n        rep(i, 1, nx + 1) {\n            rep(k, 1, ny + 1) vis[k] = false;\n            if (find(i)) ret++;\n        }\n        return ret;\n    }\n}   hug;\n///-----\nbool isP(int dig) {\n    if (dig < 2) return false;\n    for (int i = 2; i * i <= dig; i++)\n        if (dig % i == 0) return false;\n    return true;\n}\n///-----\nvi v[2]; void add(int dig) { v[dig&1].pb(dig); }\n///-----\nint main() {\n\n    ///freopen ( \"xx.in\" , \"r\" , stdin );\n\n    ///read\n    int n; cin >> n;\n    int pre = -1;\n    rep(i, 0, n) {\n        int dig; scanf(\"%d\",&dig);\n        if (dig != pre + 1) {\n            add(dig);\n            if (~pre) add(pre + 1);\n        }\n        pre = dig;\n    }\n    add(pre + 1);\n\n    ///work\n    hug.init(sz(v[0]), sz(v[1]));\n    rep(i, 0, sz(v[0])) {\n        rep(j, 0, sz(v[1])) {\n            if (isP(abs(v[0][i] - v[1][j]))) hug.link(i + 1, j + 1);\n        }\n    }\n\n    ///print\n    int can = hug.work();\n    int ans = can;\n    ans += (sz(v[0]) - can) / 2 * 2;\n    ans += (sz(v[1]) - can) / 2 * 2;\n    if ((sz(v[0]) - can)&1) ans += 3;\n    printf(\"%d\", ans);\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint read(){\n    int x=0,f=1;char ch=getchar();\n    for(;!isdigit(ch);ch=getchar())if(ch=='-')f=-1;\n    for(;isdigit(ch);ch=getchar())x=x*10+ch-'0';\n    return x*f;\n}\nconst int N=1e4+28,M=1e7+28,inf=0x3f3f3f3f;\nint st,ed,ans;\nint head[N],cnt=1,dis[N],pre[N],lst[N];\nstruct Line{int to,nxt,val;}l[2*N];\nvoid Ins(int x,int y,int z){\n    l[++cnt].to=y;\n    l[cnt].nxt=head[x];\n    l[cnt].val=z;\n    head[x]=cnt;\n}\nqueue<int>q;\nbool Bfs(){\n    memset(dis,0,sizeof(dis));\n    while(q.size())q.pop();\n    dis[st]=1,q.push(st);\n    while(q.size()){\n\tint x=q.front();q.pop();\n\tfor(int i=head[x];i;i=l[i].nxt){\n\t    if(l[i].val&&!dis[l[i].to]){\n\t\tdis[l[i].to]=dis[x]+1;\n\t\tif(l[i].to==ed)return true;\n\t\tq.push(l[i].to);\n\t    }\n\t}\n    }\n    return false;\n}\nint Dinic(int x,int limit){\n    if(x==ed)return limit;\n    int re=0;\n    for(int i=head[x],k;i;i=l[i].nxt){\n\tif(dis[l[i].to]==dis[x]+1&&(k=Dinic(l[i].to,min(limit,l[i].val)))){\n\t    l[i^1].val+=k,l[i].val-=k;\n\t    re+=k,limit-=k;\n\t    if(!limit)break;\n\t}\n    }\n    return re;\n}\nint pr[M],apr[M],tot;\nvoid Pre(int n=1e7+20){\n    apr[0]=apr[1]=1;\n    for(int i=2;i<=n;i++){\n\tif(!apr[i])pr[++tot]=i;\n\tfor(int j=1;j<=tot&&pr[j]*i<=n;j++){\n\t    apr[pr[j]*i]=1;\n\t    if(i%pr[j]==0)break;\n\t}\n    }\n}\nint k,a[M],L[N],R[N],sum,mx,n,c1,c2;\nsigned main(){\n    //freopen(\"oatmeal.in\",\"r\",stdin);\n    //freopen(\"oatmeal.out\",\"w\",stdout);\n    Pre();\n    k=read();\n    for(int i=1;i<=k;i++){\n\tint x=read();\n\ta[x]=1;\n\tmx=max(x,mx);\n    }\n    for(int i=1;i<=mx+1;i++){\n\tif(a[i]!=a[i-1]){\n\t    if(i&1)L[++c1]=i;\n\t    else R[++c2]=i;\n\t}\n    }\n    st=c1+c2+1,ed=c1+c2+2;\n    for(int i=1;i<=c1;i++)\n\tIns(st,i,1),Ins(i,st,0);\n    for(int i=1;i<=c2;i++)\n\tIns(i+c1,ed,1),Ins(ed,i+c1,0);\n    for(int i=1;i<=c1;i++){\n\tfor(int j=1;j<=c2;j++){\n\t    if(apr[abs(L[i]-R[j])])continue;\n\t    Ins(i,j+c1,1);\n\t    Ins(j+c1,i,0);\n\t}\n    }\n    while(Bfs())ans+=Dinic(st,inf);\n    int tmp=ans;\n    c1-=tmp,c2-=tmp;\n    ans+=2*(c1/2)+2*(c2/2);\n    if(c1&1)ans+=3;\n    printf(\"%lld\",ans);\n    return 0;\n}\n/*\n9\n1 2 3 4 5 6 7 8 9\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ninline int read(){int x=0,f=1;char ch=getchar();while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}return x*f;}\n\nconst int maxn = 100 + 15;\nconst int Maxsz = 2e7;\nconst int inf = 1e9 + 7;\n\nint Dp[maxn][maxn] , n , x[maxn] , Prime[Maxsz + 1] , Primelen , Vis[Maxsz + 1];\n\nvoid Init(){\n\tfor(int i = 2 ; i <= Maxsz ; ++ i){\n\t\tif( !Vis[i] )\n\t\t\tPrime[Primelen ++] = i;\n\t\tfor(int j = 0 ; j < Primelen && Prime[j] * i <= Maxsz ; ++ j){\n\t\t\tVis[i * Prime[j]] = 1;\n\t\t\tif( i % Prime[j] == 0 ) break;\n\t\t}\n\t}\n}\n\nint Dfs( int l , int r ){\n\tif( ~Dp[l][r] ) return Dp[l][r];\n\tint & ans = Dp[l][r] = inf;\n\tif( l == r ) return ans = 3;\n\tint ret = 0;\n\tfor(int i = l + 1 ; i <= r ; ++ i){\n\t\tif( x[i] - x[i - 1] - 1 == 0 ) ret += 0;\n\t\telse if( x[i] - x[i - 1] - 1 == 1 ) ret += 3;\n\t\telse if( x[i] - x[i - 1] - 1 == 2 ) ret += 2;\n\t\telse if( Vis[ x[i] - x[i - 1] - 1 ] == 0 ) ret += 1;\n\t\telse ret += 2;\n\t}\n\tint length = x[r] - x[l] + 1;\n\tif( length == 2 ) ret += 2;\n\telse if( Vis[length] == 0 ) ret += 1;\n\telse if( length & 1 ) ret += 3;\n\telse ret += 2;\n\tfor(int i = l ; i < r ; ++ i)\n\t\tans = min( ans , Dfs( l , i ) + Dfs( i + 1 , r ) );\n\treturn ans = min( ans , ret );\n}\n\nint main( int argc , char * argv[] ){\n\tInit();\n\tn = read();\n\tfor(int i = 1 ; i <= n ; ++ i)\n\t\tx[i] = read();\n\tmemset( Dp , -1 , sizeof( Dp ) );\n\tprintf( \"%d\\n\" , Dfs( 1 , n ) );\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector> \n#include <list> \n#include <map> \n#include <set> \n#include <deque> \n#include <queue> \n#include <stack> \n#include <bitset> \n#include <algorithm> \n#include <functional> \n#include <numeric> \n#include <utility> \n#include <sstream> \n#include <iostream> \n#include <iomanip> \n#include <cstdio> \n#include <cmath> \n#include <cstdlib> \n#include <cctype> \n#include <string> \n#include <cstring> \n#include <ctime> \n\nusing namespace std;\n\n#define _int64 long long\n\nint b[11000000];\nint a[200];\nint d[200];\n\nint solve(int x)\n{\n  if (x==0) return 0;\n  else if (b[x]==0) return 1;\n  else if (x%2==0) return 2;\n  else return 3;\n}\n\nint main()\n{\n  int i,j,k,n,tot,totans,tmp;\n  memset(b,0,sizeof(b));\n  b[1]=1;\n  for (i=2;i<11000000;i++)\n    if (b[i]==0)\n    {\n      for (j=i+i;j<11000000;j+=i)\n        b[j]=1;\n    }\n  b[2]=1;\n  scanf(\"%d\",&n);\n  for (i=0;i<n;i++)\n    scanf(\"%d\",&a[i]);\n  d[0]=0;\n  for (i=1;i<=n;i++)\n  {\n    d[i]=2000000000;\n    tot=1;\n    totans=0;\n    for (j=i-1;j>=0;j--)\n    {\n      tmp=solve(tot);\n      //cout<<i<<\" \"<<j<<\" \"<<tot<<\" \"<<tmp<<\" \"<<totans<<endl;\n      if (tmp+totans+d[j]<d[i])\n        d[i]=tmp+totans+d[j];\n      if (j>0)\n      {\n        tot=a[i-1]-a[j-1]+1;\n        totans+=solve(a[j]-a[j-1]-1);\n      }\n    }\n    //cout<<\"i:\"<<d[i]<<endl;\n  }\n  printf(\"%d\\n\",d[n]);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define rep(i,n) REP(i,0,n)\n#define REP(i,s,e) for(int i=(s); i<(int)(e); i++)\n#define repr(i, n) REPR(i, n, 0)\n#define REPR(i, s, e) for(int i=(int)(s-1); i>=(int)(e); i--)\n#define pb push_back\n#define all(r) r.begin(),r.end()\n#define rall(r) r.rbegin(),r.rend()\n#define fi first\n#define se second\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int INF = 1e9;\nconst ll MOD = 1e9 + 7;\ndouble EPS = 1e-8;\n\n\nstruct MaxFlow {\n\tstruct Edge {\n\t\tint to, cap, rev;\n\t\tEdge() {};\n\t\tEdge(int to, int cap, int rev) : to(to), cap(cap), rev(rev) {};\n\t};\n\tint V;\n\tvector<vector<Edge>> G;\n\tvector<int> used;\n\n\tMaxFlow(int V) : V(V), G(V, vector<Edge>()), used(V){}\n\n\tvoid add_edge(int from, int to, int cap) {\n\t\tG[from].push_back({to, cap, (int)G[to].size()});\n\t\tG[to].push_back({from, 0, (int)G[from].size() - 1});\n\t}\n\n\tint dfs(int v, int t, int f) {\n\t\tif (v == t) return f;\n\t\tused[v] = true;\n\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\tEdge& e = G[v][i];\n\t\t\tif (!used[e.to] && e.cap > 0) {\n\t\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\t\tif (d > 0) {\n\t\t\t\t\te.cap -= d;\n\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\n\tint max_flow(int s, int t) {\n\t\tint flow = 0;\n\t\twhile (1) {\n\t\t\t// memset(used, 0, sizeof(used));\n\t\t\tused = vector<int>(V, 0);\n\t\t\tint f = dfs(s, t, INF);\n\t\t\tif (f == 0) return flow;\n\t\t\tflow += f;\n\t\t}\n\t}\n};\n\n\n//エラトステネスの篩を使用\nconst int MAX_PRIME = 1e7 + 10;\n\nvector<int> is_prime(MAX_PRIME, 1);\n\nvoid calcPrime() {\n\tis_prime[0] = is_prime[1] = 0;\n\tfor (int i = 2; i < MAX_PRIME; i++) {\n\t\tif (is_prime[i] == 1) {\n\t\t\tfor (int j = i + i; j < MAX_PRIME; j += i) is_prime[j] = 0;\n\t\t}\n\t}\n}\n\nint main() {\n\tcalcPrime();\n\tint n;\n\tcin >> n;\n\tvi x(n);\n\trep(i, n) cin >> x[i];\n\tmap<int, int> mp;\n\trep(i, n) {\n\t\tmp[x[i]] ^= 1;\n\t\tmp[x[i] + 1] ^= 1;\n\t}\n\tMaxFlow flow(3500);\n\tvi odd, even;\n\tfor (auto& p : mp) if (p.se) (p.fi & 1 ? odd : even).pb(p.fi);\n\trep(i, odd.size()) rep(j, even.size()) {\n\t\tif (is_prime[abs(odd[i] - even[j])]) flow.add_edge(1000 + i, 2000 + j, 1);\n\t}\n\trep(i, odd.size()) flow.add_edge(0, 1000 + i, 1);\n\trep(i, even.size()) flow.add_edge(2000 + i, 1, 1);\n\tint f = flow.max_flow(0, 1);\n\tint ans = f + (((int)odd.size() - f) / 2) * 2 + (((int)even.size() - f) / 2) * 2;\n\tif (((int)odd.size() - f) & 1) ans += 3;\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// #include {{{\n#include <iostream>\n#include <cassert>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <ctime>\n#include <queue>\n#include <set>\n#include <map>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <vector>\n#include <complex>\n#include <algorithm>\nusing namespace std;\n// }}}\n// #define {{{\ntypedef long long ll;\ntypedef double db;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\n#define de(x) cout << #x << \"=\" << x << endl\n#define rep(i,a,b) for(int i=a;i<(b);++i)\n#define per(i,a,b) for(int i=(b)-1;i>=(a);--i)\n#define all(x) (x).begin(),(x).end()\n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\n// }}}\n\nconst int N = 210;\nint link[N] , vis[N] , n;\nvi g[N];\nint dfs(int c) {\n    for(auto t : g[c]) if(!vis[t]) {\n        vis[t] = true;\n        if(link[t]==-1||dfs(link[t]))\n            return link[t]=c,1;\n    }\n    return 0;\n}\nint bipart(int n,int m){\n    fill_n(link,m,-1);\n    int res=0;\n    rep(i,0,n){\n        memset(vis,0,m*sizeof(int));\n        res += dfs(i);\n    }\n    return res;\n}\nbool isoddprim(int x){\n    if(x <= 2) return false;\n    for(int i=2;i*i<=x;++i) if(x%i==0)\n        return false;\n    return true;\n}\n\nint main(){\n    cin >> n;\n    map<int,int> vis;\n    rep(i,0,n){\n        int x;\n        cin>>x;\n        vis[x]^=1;\n        vis[x+1]^=1;\n    }\n    vi odd , even;\n    for(auto e : vis) if(e.se == 1) {\n        (e.fi & 1 ? odd : even).pb(e.fi);\n    }\n    int n = sz(odd) , m = sz(even);\n    rep(i,0,n) rep(j,0,m) if(isoddprim(abs(odd[i] - even[j])))\n        g[i].pb(j);\n    int maxmatch = bipart(n , m);\n    cout << maxmatch + ((n - maxmatch) / 2 + (m - maxmatch) / 2) * 2 + ((n - maxmatch) & 1) * 3 << endl;;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<queue>\n#define inf 1e9\nusing namespace std;\nstruct node{\n\tint nxt,to,weigh;\n}edge[400010];\nint head[100100],n,S,T,cnt=1,level[100100];\nint a[10010],b[10010],c[10001000],sum,tot,ans;\nqueue<int> qu;\nbool check(int a){\n\tfor(int i=2;i<=sqrt(a);i++)\n\t\tif(a%i==0)return false;\n\treturn true;\n}\nvoid addedge(int x,int y,int z){\n\tedge[++cnt].nxt=head[x];\n\tedge[cnt].to=y;\n\tedge[cnt].weigh=z;\n\thead[x]=cnt;\n\tedge[++cnt].nxt=head[y];\n\tedge[cnt].to=x;\n\tedge[cnt].weigh=0;\n\thead[y]=cnt;\t\n}\nbool bfs(){\n\tmemset(level,-1,sizeof(level));\n\tlevel[S]=0;\n\tqu.push(S);\n\twhile(!qu.empty()){\n\t\tint u=qu.front();\n\t\tqu.pop();\n\t\tfor(int i=head[u];i;i=edge[i].nxt){\n\t\t\tint upup=edge[i].to;\n\t\t\tif(edge[i].weigh!=0 && level[upup]==-1){\n\t\t\t\tlevel[upup]=level[u]+1;\n\t\t\t\tqu.push(upup);\n\t\t\t}\n\t\t}\n\t}\n\tif(level[T]==-1)return false;\n\treturn true;\n}\nint dfs(int x,int flow){\n\tif(x==T)return flow;\n\tint rest=0;\n\tfor(int i=head[x];i;i=edge[i].nxt){\n\t\tint upup=edge[i].to;\n\t\tif(rest==flow)break;\n\t\tif(level[upup]==level[x]+1){\n\t\t\tint sum=dfs(upup,min(flow-rest,edge[i].weigh));\n\t\t\trest+=sum,edge[i].weigh-=sum;edge[i^1].weigh+=sum;\n\t\t}\n\t} \n\treturn rest;\n}\nint Dinic(){\n\tint ans=0;\n\twhile(bfs())\n\t\tans+=dfs(S,inf);\n\treturn ans;\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++){\n\t\tscanf(\"%d\",&a[i]);\n\t\tc[a[i]]=1;\n\t}\n\tfor(int i=1;i<=10000000;i++)\n\t\tif(c[i]!=c[i-1])\n\t\t\tb[++sum]=i;\n\tS=0,T=sum+1;\n\tfor(int i=1;i<=sum;i++)\n\t\tif(b[i]&1){\n\t\t\ttot++;\n\t\t\taddedge(S,i,1);\n\t\t\tfor(int j=1;j<=sum;j++)\n\t\t\t\tif(!b[j]&1&&check(abs(b[j]-b[i])))\n\t\t\t\t\taddedge(i,j,1);\n\t\t}\n\t\telse addedge(i,T,1);\n\tans=Dinic();\n\tprintf(\"%d\\n\",sum-ans+(tot-ans)%2);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define pb push_back\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\n\nstruct hopcroft_karp {\n\tint N,M;\n\tvector<vector<int>> E;\n\tvector<int> dist,match,Q;\n\thopcroft_karp(int n, int m):N(n),M(m),E(N),dist(N+M),match(N+M,-1),Q(N+M){}\n\n\tinline void add_edge(int i, int j) {E[i].push_back(j);}\n\n\tbool bfs() {\n\t\tfill(&dist[0],&dist[0]+N+M,-1);\n\t\tint qf = 0, qb = 0, u;\n\t\tbool ok = false;\n\t\tfor(int i = 0; i < N; ++i)\n\t\t\tif(match[i] == -1)\n\t\t\t\tQ[qb++] = i, dist[i] = 0;\n\t\twhile(qf != qb) {\n\t\t\tif((u = Q[qf++]) < N) {\n\t\t\t\tfor(int v : E[u])\n\t\t\t\t\tif(dist[N+v] == -1)\n\t\t\t\t\t\tdist[Q[qb++] = N+v] = dist[u] + 1;\n\t\t\t} else {\n\t\t\t\tif(match[u] == -1) ok = true;\n\t\t\t\telse if(dist[match[u]] == -1)\n\t\t\t\t\tdist[Q[qb++] = match[u]] = dist[u] + 1;\n\t\t\t}\n\t\t}\n\t\treturn ok;\n\t}\n\n\tbool dfs(int u) {\n\t\tfor(int &i = Q[u]; i < E[u].size(); ++i) {\n\t\t\tint v = N+E[u][i];\n\t\t\tif(dist[v] == dist[u]+1 && (match[v] == -1 || (dist[match[v]] == dist[v]+1 && dfs(match[v])))) {\n\t\t\t\tmatch[v] = u, match[u] = v-N;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tint solve() {\n\t\tint ans = 0;\n\t\twhile(bfs()) {\n\t\t\tfill(&Q[0],&Q[0]+N,0);\n\t\t\tfor(int i = 0; i < N; ++i)\n\t\t\t\tif(match[i] == -1 && dfs(i))\n\t\t\t\t\t++ans;\n\t\t}\n\t\treturn ans;\n\t}\n};\n\nconst int N = 105, P = 1e7+5;\nint a[N]={-1};\nbool p[P];\nvi odd,evn;\n\ninline void add(int i) {\n\t((i&1)?odd:evn).pb(i);\n}\n\nint main() {\n\tfill(p,p+P,1);\n\tp[0] = p[1] = false;\n\tfor(int i = 2; 1LL * i * i < P; ++i)\n\t\tif(p[i])\n\t\t\tfor(int j = i * i; j < P; j += i)\n\t\t\t\tp[j] = false;\n\tp[2] = false;\n\tint n;\n\tscanf(\"%d\",&n);\n\tfor(int i = 1; i <= n; ++i)\n\t\tscanf(\"%d\",a+i);\n\tfor(int i = 1; i <= n; ++i) {\n\t\tif(a[i-1] != a[i]-1) add(a[i]-1);\n\t\tif(a[i+1] != a[i]+1) add(a[i]);\n\t}\n\thopcroft_karp HK(evn.size(), odd.size());\n\tfor(int i = 0; i < evn.size(); ++i)\n\t\tfor(int j = 0; j < odd.size(); ++j)\n\t\t\tif(p[abs(evn[i]-odd[j])])\n\t\t\t\tHK.add_edge(i,j);\n\tint k = HK.solve();\n\tprintf(\"%d\\n\",k + int((odd.size()-k)/2*2 + (evn.size()-k)/2*2 + ((odd.size()-k)&1)*3));\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define M 100010\nusing namespace std;\nint n,A[10000010];\nbool pri[10000010];\nvoid init(int N){\n\tfor(int i=2;i<=N;i++)\n\tif(!pri[i])\n\tfor(int j=i+i;j<=N;j+=i)pri[j]=1;\n\tpri[1]=pri[2]=1;\n}\nint q1[3010],q2[3010],t1,t2,S,T;\nint k,cnt,h,t;\nint F[M],L[M],N[M],a[M],c[M],dis[M],q[M];\nvoid add(int x,int y,int z){\n\ta[++k]=y;c[k]=z;\n\tN[k]=F[x];F[x]=k;\n}\nbool BFS(int x,int y){\n\tq[t=1]=x;h=0;\n\tfor(int i=1;i<=n;i++)dis[i]=1000000000;\n\tdis[x]=0;\n\twhile(h<t){\n\t\tx=q[++h];\n\t\tfor(int i=F[x];i;i=N[i])if(c[i]&&dis[a[i]]>n){\n\t\t\tdis[a[i]]=dis[x]+1;\n\t\t\tif(a[i]==y)return 1;\n\t\t\tq[++t]=a[i];\n\t\t}\n\t}\n\treturn dis[y]<=n;\n}\nint dfs(int x,int T,int flow){\n\tif(x==T)return flow;\n\tint used=0;\n\tfor(int i=F[x];i;i=N[i])if(c[i]&&dis[a[i]]==dis[x]+1){\n\t\tconst int v=dfs(a[i],T,min(flow-used,c[i]));\n\t\tif(!v)continue;c[i]-=v;c[i^1]+=v;used+=v;\n\t\tif(used>=flow)return used;\n\t}\n\treturn used;\n}\nint dinic(int S,int T){\n\tint ans=0;\n\twhile(BFS(S,T))ans+=dfs(S,T,1000000000);\n\treturn ans;\n}\nint main(){\n\tscanf(\"%d\",&n);init(10000000);k=1;\n\tfor(int i=1;i<=n;i++){\n\t\tint x;\n\t\tscanf(\"%d\",&x);\n\t\tA[x]^=1;\n\t}\n\tfor(int i=1;i<=10000001;i++)if(A[i]!=A[i-1]){\n\t\tif(i&1)q1[++t1]=i;\n\t\telse q2[++t2]=i;\n\t}\n\tfor(int i=1;i<=t1;i++)\n\tfor(int j=1;j<=t2;j++)if(!pri[abs(q1[i]-q2[j])]){\n\t\tadd(i,j+t1,1),add(j+t1,i,0);\n\t}\n\t\n\tS=t1+t2+1;T=n=t1+t2+2;\n\tfor(int i=1;i<=t1;i++)add(S,i,1),add(i,S,0);\n\tfor(int i=1;i<=t2;i++)add(i+t1,T,1),add(T,i+t1,0);\n\tint v=dinic(S,T);\n\tcout<<(t1-v)/2*2+(t2-v)/2*2+((t1-v)&1)*3+v;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// Written By NewbieChd\n#include <cstdio>\n#include <cctype>\n#include <cstring>\n#include <algorithm>\n#include <queue>\nusing namespace std;\n\nconst int BUF = 1000000;\nchar buf[BUF], *p1, *p2;\ninline char getChar() { return p1 == p2 && (p2 = (p1 = buf) + fread(buf, 1, BUF, stdin), p1 == p2) ? EOF : *p1++; }\ninline int read() {\n    int f = 0;\n    bool b = 1;\n    char c;\n    while (!isdigit(c = getChar()))\n        if (c == 45)\n            b = 0;\n    do\n        f = f * 10 + (c ^ 48);\n    while (isdigit(c = getChar()));\n    return b ? f : ~f + 1;\n}\n\nconst int maxN = 10003, maxE = 4000003, S = maxN - 2, T = maxN - 1, inf = 0x3f3f3f3f;\nint cntNode;\n\nint h[maxN], cntEdge = 1;\nstruct Edge {\n    int tar, val, nxt;\n    Edge() {}\n    Edge(int tar, int val, int nxt) : tar(tar), val(val), nxt(nxt) {}\n}ed[maxE];\ninline void addEdge(int x, int y, int z) { ed[++cntEdge] = Edge(y, z, h[x]), h[x] = cntEdge, ed[++cntEdge] = Edge(x, 0, h[y]), h[y] = cntEdge; }\n\nint cur[maxN], dep[maxN];\nqueue<int> que;\ninline bool bfs() {\n    int i, x, y;\n    memset(dep + 1, 0, sizeof(int) * cntNode), memcpy(cur + 1, h + 1, sizeof(int) * cntNode), cur[S] = h[S], dep[S] = 1, dep[T] = 0, que.push(S);\n    while (!que.empty()) {\n        x = que.front(), que.pop();\n        for (i = h[x]; i; i = ed[i].nxt)\n            if (ed[i].val && !dep[y = ed[i].tar])\n                dep[y] = dep[x] + 1, que.push(y);\n    }\n    return dep[T];\n}\nint dfs(int x, int flow) {\n    if (x == T)\n        return flow;\n    int res = flow, k, i, y;\n    for (i = cur[x]; i && res; i = ed[i].nxt) {\n        cur[x] = i;\n        if (ed[i].val && dep[y = ed[i].tar] == dep[x] + 1 && (k = dfs(y, min(res, ed[i].val))))\n            res -= k, ed[i].val -= k, ed[i ^ 1].val += k;\n    }\n    return flow - res;\n}\n\ninline int Dinic() {\n    int maxFlow = 0, k;\n    while (bfs())\n        while ((k = dfs(S, inf)))\n            maxFlow += k;\n    return maxFlow;\n}\n\nconst int maxL = 10000003, lim = 1e7 + 1;\nint prime[maxL];\nbool notP[maxL];\n\nbool flag[maxL];\nint pos[maxN], ind[maxN];\ninline int absolute(int x) { return x >= 0 ? x : ~x + 1; }\n\nint main() {\n    int n = read(), cntP = 0, i, j;\n    for (i = 2; i <= lim; ++i) {\n        if (!notP[i])\n            prime[++cntP] = i;\n        for (j = 1; j <= lim && i * prime[j] <= lim; ++j) {\n            notP[i * prime[j]] = 1;\n            if (i % prime[j] == 0)\n                break;\n        }\n    }\n    \n    for (i = 1; i <= n; ++i)\n        flag[read()] = 1;\n    for (i = 1; i <= lim; ++i)\n        if (flag[i] ^ flag[i - 1])\n            pos[++cntNode] = i;\n    notP[1] = 1;\n    for (i = 1; i <= cntNode; ++i) {\n        if (pos[i] & 1) {\n            for (j = 1; j <= cntNode; ++j)\n                if (!(pos[j] & 1) && (!notP[absolute(pos[i] - pos[j])]))\n                    addEdge(i, j, 1);\n            addEdge(S, i, 1);\n        }\n        else\n            addEdge(i, T, 1);\n        ind[i] = cntEdge ^ 1;\n    }\n    int ans = Dinic(), tax[2];\n    tax[0] = tax[1] = 0;\n    for (i = 1; i <= cntNode; ++i)\n        if (ed[ind[i]].val)\n            ++tax[pos[i] & 1];\n    ans += (((tax[0] >> 1) + (tax[1] >> 1)) << 1) + ((tax[0] & 1) | (tax[1] & 1)) * 3;\n    \n    printf(\"%d\\n\", ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define For(i, j, k) for(int i = j; i <= k; i++)\n#define pb push_back\n\nusing namespace std;\n\nconst int N = 210;\nconst int M = 1e7 + 10;\n\nbool vis[M];\nint prm[M], tot;\n\nvoid init(int n){\n\tvis[1] = true;\n\tFor(i, 2, n){\n\t\tif(!vis[i]) prm[++tot] = i;\n\t\tfor(int j = 1; j <= tot && prm[j] * i <= n; ++j){\n\t\t\tvis[prm[j] * i] = true;\n\t\t\tif(i % prm[j] == 0) break;\n\t\t}\n\t}\n}\n\nint n, m;\nvector<int> G[N];\nint pos[N], match[N], used[N];\n\nbool Hungary(int o){\n\tif(used[o]) return false;\n\tused[o] = true;\n\tfor(int v : G[o]){\n\t\tint &x = match[v];\n\t\tif(!x || Hungary(x)){\n\t\t\tx = o;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint main(){\n\t\n\tinit(M - 5);\n\tscanf(\"%d\", &n);\n\tFor(i, 1, n){\n\t\tint x;\n\t\tscanf(\"%d\", &x);\n\t\tpos[++m] = x, pos[++m] = x + 1;\n\t}\n\n\tsort(pos + 1, pos + m + 1);\n\tint node = 0;\n\tFor(i, 1, m){\n\t\tif(pos[i + 1] == pos[i]) ++i;\n\t\telse pos[++node] = pos[i];\n\t}\n\tFor(i, 1, node) if(pos[i] & 1)\n\t\tFor(j, 1, node){\n\t\t\tint x = abs(pos[i] - pos[j]);\n\t\t\tif(pos[j] % 2 == 0 && !vis[x]){\n\t\t\t\tG[i].pb(j);\n\t\t\t}\n\t\t}\n\n\tint ret = 0, odd = 0;\n\tFor(i, 1, node) if(pos[i] & 1){\n\t\t++odd;\n\t\tmemset(used, false, sizeof used);\n\t\tret += Hungary(i);\n\t}\n\n\tint even = node - odd - ret;\n\todd -= ret;\n\tif(even & 1) ret = node - ret + 1;\n\telse ret = node - ret;\n\n\tprintf(\"%d\\n\", ret);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#define fo(i,a,b) for(int i=a;i<=b;i++)\n#define fd(i,b,a) for(int i=b;i>=a;i--)\n#define efo(i,u,v) for(int i=BB[u],v=B[BB[u]][1];i;v=B[i=B[i][0]][1])\n#define mset(a,x) memset(a,x,sizeof(a))\nusing namespace std;\ntypedef long long ll;\nchar ch;\nint read(){int n=0,p=1;for(ch=getchar();ch<'0' || '9'<ch;ch=getchar())if(ch=='-') p=-1;for(;'0'<=ch && ch<='9';ch=getchar()) n=n*10+ch-'0';return n*p;}\nconst int N=205,M=2e7+5;\nint n,m,a[N],d[N<<1],pr[M];\nbool b[M],c[M],bz[M];\nvoid prep()\n{\n\tmset(bz,1);\n\tbz[0]=bz[1]=0;\n\tfo(i,2,m)\n\t{\n\t\tif(bz[i]) pr[++pr[0]]=i;\n\t\tfo(j,1,pr[0])\n\t\t{\n\t\t\tll x=(ll)i*pr[j];\n\t\t\tif(x>m) break;\n\t\t\tbz[x]=0;\n\t\t\tif(i%pr[j]==0) break;\n\t\t}\n\t}\n}\nconst int V=N<<3,INF=1e9;\nconst int E=10*V*V;\nint B0,BB[V],pos[V],B[E][2];\nbool vis[V];\nvoid link(int u,int v){B[++B0][1]=v,B[B0][0]=BB[u],BB[u]=B0;}\nbool match(int x)\n{\n\tif(vis[x]==1) return 0;\n\tvis[x]=1;\n\tefo(i,x,y)\n\t\tif(!pos[y] || match(pos[y]))\n\t\t{\n\t\t\tpos[y]=x;\n\t\t\treturn 1;\n\t\t}\n\treturn 0;\n}\nint main()\n{\n\tn=read();\n\tfo(i,1,n) a[i]=read(),b[a[i]]=1,m=max(m,a[i]);\n\t++m;\n\tprep();\n\tfo(i,1,m) c[i]=b[i]^b[i-1];\n\tfo(i,1,m) if(c[i]) d[++d[0]]=i;\n\tfo(i,1,d[0])if(d[i]&1)\n\t\tfo(j,1,d[0])if(!(d[j]&1))\n\t\t\tif(bz[abs(d[i]-d[j])]) link(i,d[0]+j);\n\tint cnt=0,odd=0,even=0;\n\tfo(i,1,d[0]+d[0])\n\t{\n\t\tmset(vis,0);\n\t\tif(match(i)) ++cnt;\n\t}\n\tfo(i,1,d[0])if(d[i]&1) ++odd;else ++even;\n\tint ans=cnt+((odd-cnt)/2)*2+((even-cnt)/2)*2;\n\tif((odd-cnt)%2==1) ans+=3;\n\tprintf(\"%d\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N = 205, M = 1e7 + 8;\n\nint n, x[N], prime[M], tot, k, own[N], m, y[N];\nbool vis[M], use[N];\nvector<int>S, T, V[N];\n\nint find (int x) {\n\tfor (auto v : V[x]) if (!use[v]) {\n\t\tuse[v] = 1;\n\t\tif (!own[v] || find(own[v])) {\n\t\t\town[v] = x;\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nint main () {\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; ++i) scanf(\"%d\", &y[i]);\n\tsort(y + 1, y + n + 1);\n\tx[m = 1] = y[1];\n\tif (y[1] + 1 != y[2]) x[++m] = y[1] + 1;\n\tfor (int i = 2; i <= n; ++i) {\n\t\tif (y[i] != y[i - 1] + 1) x[++m] = y[i];\n\t\tif (y[i] != y[i + 1] - 1) x[++m] = y[i] + 1;\n\t}\n\tn = m;\n\tvis[1] = 1;\n\tfor (int i = 2; i <= 1e7; ++i) {\n\t\tif (!vis[i]) prime[++tot] = i;\n\t\tfor (int j = 1; j <= tot && i * prime[j] <= 1e7; ++j) {\n\t\t\tvis[i * prime[j]] = 1;\n\t\t\tif (i % prime[j] == 0) break;\n\t\t}\n\t}\n\tfor (int i = 1; i <= n; ++i) if (x[i] & 1) S.emplace_back(i); else T.emplace_back(i);\n\tfor (auto u : S) for (auto v : T) if (!vis[abs(x[u] - x[v])]) V[u].emplace_back(v);\n\tfor (auto u : S) if (memset(use, 0, sizeof use), find(u)) ++k;\n\tprintf(\"%d\\n\", (S.size() - k) / 2 * 2 + (T.size() - k) / 2 * 2 + (S.size() & 1) * 3 + k);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=a;i<b;i++)\n#define rrep(i,a,b) for(int i=a;i>=b;i--)\n#define fore(i,a) for(auto &i:a)\n#pragma GCC optimize (\"-O3\")\nusing namespace std; void _main(); int main() { cin.tie(0); ios::sync_with_stdio(false); _main(); }\n//---------------------------------------------------------------------------------------------------\ntypedef int Weight;\nstruct Edge {\n    int src, dst; Weight weight; Edge() {};\n    Edge(int src_, int dst_, Weight weight_) : src(src_), dst(dst_), weight(weight_) { }\n};\ntypedef vector<Edge> Edges;\nstruct MaxWeightMatching {\n    typedef vector<int> vi;\n    int nEdge, nVertex;\n    Weight maxWeight;\n    vi endPoint, mate, label, labelEdge,\n        inBlossom, blossomParent, blossomBase,\n        bestEdge, unusedBlossoms, allowEdge,\n        blossomBestEdgesUsed,\n        sVerteices;\n    vector<Weight> dualVar;\n    vector<vi> neighbEnd, blossomChilds, blossomEdges,\n        blossomBestEdges;\n    Edges edges;\n    bool maxCardinality;\n\n    Weight slack(int k) {\n        Edge &e = edges[k];\n        return dualVar[e.src] + dualVar[e.dst] - 2 * e.weight;\n    }\n    struct BlossomLeaves {\n        int b;\n        MaxWeightMatching *mw;\n        enum { INITAL, END, NEXT, THIRD } state;\n        vi::const_iterator iter, endi;\n        BlossomLeaves *bl;\n        BlossomLeaves(MaxWeightMatching *mw_, int b_) :\n            mw(mw_), b(b_), state(INITAL), bl(NULL) {}\n        bool next(int &r) {\n            int t;\n            switch (state) {\n            case INITAL:\n                if (b < mw->nVertex) {\n                    r = b;\n                    state = END;\n                    return true;\n                }\n                else {\n                    iter = mw->blossomChilds[b].begin();\n                    endi = mw->blossomChilds[b].end();\n                    state = NEXT;\n                    return next(r);\n                }\n            case END:\n                return false;\n            case NEXT:\n                if (iter == endi)\n                    return false;\n                t = *iter;\n                ++iter;\n                if (t < mw->nVertex) {\n                    r = t;\n                    return true;\n                }\n                else {\n                    bl = new BlossomLeaves(mw, t);\n                    state = THIRD;\n                    return next(r);\n                }\n            case THIRD:\n                if (!bl->next(t)) {\n                    state = NEXT;\n                    delete bl; bl = NULL;\n                    return next(r);\n                }\n                else {\n                    r = t;\n                    return true;\n                }\n            }\n            return false;\n        }\n    };\n    void assignLabel(int w, int t, int p) {\n        int b = inBlossom[w];\n        label[w] = label[b] = t;\n        labelEdge[w] = labelEdge[b] = p;\n        bestEdge[w] = bestEdge[b] = -1;\n        if (t == 1) {\n            BlossomLeaves bl(this, b);\n            for (int r; bl.next(r); ) sVerteices.push_back(r);\n        }\n        else if (t == 2) {\n            int base = blossomBase[b];\n            assignLabel(endPoint[mate[base]], 1, mate[base] ^ 1);\n        }\n    }\n    int scanBlossom(int v, int w) {\n        vi path;\n        int base = -1;\n        while (v != -1) {\n            int b = inBlossom[v];\n            if (label[b] & 4) {\n                base = blossomBase[b];\n                break;\n            }\n            path.push_back(b);\n            label[b] = 5;\n            if (labelEdge[b] == -1) {\n                v = -1;\n            }\n            else {\n                v = endPoint[labelEdge[b]];\n                b = inBlossom[v];\n                v = endPoint[labelEdge[b]];\n            }\n            if (w != -1)\n                swap(v, w);\n        }\n        fore(it, path) label[it] = 1;\n        return base;\n    }\n    void addBlossom(int base, int k) {\n        Edge &e = edges[k];\n        int bb = inBlossom[base],\n            bv = inBlossom[e.src],\n            bw = inBlossom[e.dst];\n        int b = unusedBlossoms.back(); unusedBlossoms.pop_back();\n        blossomBase[b] = base;\n        blossomParent[b] = -1;\n        blossomParent[bb] = b;\n        blossomChilds[b].clear();\n        blossomEdges[b].clear();\n        vi &bChilds = blossomChilds[b];\n        vi &bEdges = blossomEdges[b];\n        while (bv != bb) {\n            blossomParent[bv] = b;\n            bChilds.push_back(bv);\n            bEdges.push_back(labelEdge[bv]);\n            bv = inBlossom[endPoint[labelEdge[bv]]];\n        }\n        bChilds.push_back(bb);\n        reverse(bChilds.begin(), bChilds.end());\n        reverse(bEdges.begin(), bEdges.end());\n        bEdges.push_back(2 * k);\n        while (bw != bb) {\n            blossomParent[bw] = b;\n            bChilds.push_back(bw);\n            bEdges.push_back(labelEdge[bw] ^ 1);\n            bw = inBlossom[endPoint[labelEdge[bw]]];\n        }\n        label[b] = 1;\n        labelEdge[b] = labelEdge[bb];\n        dualVar[b] = 0;\n        BlossomLeaves bl(this, b);\n        for (int v; bl.next(v); ) {\n            if (label[inBlossom[v]] == 2)\n                sVerteices.push_back(v);\n            inBlossom[v] = b;\n        }\n        vi bestEdgeTo(2 * nVertex, -1);\n        fore(it, bChilds) {\n            int bv2 = it;\n            vector<vi> nbLists;\n            if (!blossomBestEdgesUsed[bv2]) {\n                BlossomLeaves bl2(this, bv2);\n                for (int v2; bl2.next(v2); ) {\n                    nbLists.push_back(neighbEnd[v2]);\n                    vi &vv = nbLists.back();\n                    fore(i, vv) i /= 2;\n                }\n            }\n            else {\n                nbLists.push_back(blossomBestEdges[bv2]);\n            }\n            fore(itt, nbLists) {\n                fore(ittt, itt) {\n                    int k2 = ittt;\n                    Edge &e2 = edges[k2];\n                    int i = e2.src, j = e2.dst;\n                    if (inBlossom[j] == b)\n                        swap(i, j);\n                    int bj = inBlossom[j];\n                    if (bj != b && label[bj] == 1 &&\n                        (bestEdgeTo[bj] == -1 ||\n                            slack(k2) < slack(bestEdgeTo[bj]))) {\n                        bestEdgeTo[bj] = k2;\n                    }\n                }\n            }\n            blossomBestEdgesUsed[bv2] = false;\n            blossomBestEdges[bv2].clear();\n            bestEdge[bv2] = -1;\n        }\n        blossomBestEdgesUsed[b] = true;\n        blossomBestEdges[b].clear();\n        fore(it, bestEdgeTo) if (it != -1) blossomBestEdges[b].push_back(it);\n        bestEdge[b] = -1;\n        fore(it, blossomBestEdges[b])\n            if (bestEdge[b] == -1 || slack(it) < slack(bestEdge[b]))\n                bestEdge[b] = it;\n    }\n    void expandBlossom(int b, bool endStage) {\n        int cSize = blossomChilds[b].size();\n        fore(it, blossomChilds[b]) {\n            int s = it;\n            blossomParent[s] = -1;\n            if (s < nVertex)\n                inBlossom[s] = s;\n            else if (endStage && dualVar[s] == 0)\n                expandBlossom(s, endStage);\n            else {\n                BlossomLeaves bl(this, s);\n                for (int v; bl.next(v); )\n                    inBlossom[v] = s;\n            }\n        }\n        if (!endStage && label[b] == 2) {\n            int entryChild = inBlossom[endPoint[labelEdge[b] ^ 1]];\n            int j = find(blossomChilds[b].begin(), blossomChilds[b].end(), entryChild) - blossomChilds[b].begin();\n            int jStep, evenOdd;\n            if (j & 1)\n                jStep = 1, evenOdd = 0;\n            else\n                jStep = -1, evenOdd = 1;\n            int p = labelEdge[b];\n            while (j != 0) {\n                label[endPoint[p ^ 1]] = 0;\n                label[endPoint[blossomEdges[b][j - evenOdd] ^ evenOdd ^ 1]] = 0;\n                assignLabel(endPoint[p ^ 1], 2, p);\n                allowEdge[blossomEdges[b][j - evenOdd] / 2] = true;\n                j = (j + jStep + cSize) % cSize;\n                p = blossomEdges[b][j - evenOdd] ^ evenOdd;\n                allowEdge[p / 2] = true;\n                j = (j + jStep + cSize) % cSize;\n            }\n            int bv = blossomChilds[b][j];\n            label[endPoint[p ^ 1]] = label[bv] = 2;\n            labelEdge[endPoint[p ^ 1]] = labelEdge[bv] = p;\n            bestEdge[bv] = -1;\n            j = (j + jStep + cSize) % cSize;\n            while (blossomChilds[b][j] != entryChild) {\n                bv = blossomChilds[b][j];\n                if (label[bv] == 1) {\n                    j = (j + jStep + cSize) % cSize;\n                    continue;\n                }\n                BlossomLeaves bl(this, bv);\n                int v;\n                while (bl.next(v))\n                    if (label[v] != 0)\n                        break;\n                if (label[v] != 0) {\n                    label[v] = 0;\n                    label[endPoint[mate[blossomBase[bv]]]] = 0;\n                    assignLabel(v, 2, labelEdge[v]);\n                }\n                j = (j + jStep + cSize) % cSize;\n            }\n        }\n        label[b] = labelEdge[b] = -1;\n        blossomChilds[b].clear();\n        blossomEdges[b].clear();\n        blossomBestEdgesUsed[b] = false;\n        blossomBestEdges[b].clear();\n        bestEdge[b] = -1;\n        unusedBlossoms.push_back(b);\n    }\n    void augmentBlossom(int b, int v) {\n        int cSize = blossomChilds[b].size();\n        int t = v;\n        while (blossomParent[t] != b)\n            t = blossomParent[t];\n        if (t >= nVertex)\n            augmentBlossom(t, v);\n        int i, j, jStep, evenOdd;\n        i = j = find(blossomChilds[b].begin(), blossomChilds[b].end(), t) - blossomChilds[b].begin();\n        if (i & 1)\n            jStep = 1, evenOdd = 0;\n        else\n            jStep = -1, evenOdd = 1;\n        while (j != 0) {\n            j = (j + jStep + cSize) % cSize;\n            t = blossomChilds[b][j];\n            int p = blossomEdges[b][j - evenOdd] ^ evenOdd;\n            if (t >= nVertex)\n                augmentBlossom(t, endPoint[p]);\n            j = (j + jStep + cSize) % cSize;\n            t = blossomChilds[b][j];\n            if (t >= nVertex)\n                augmentBlossom(t, endPoint[p ^ 1]);\n            mate[endPoint[p]] = p ^ 1;\n            mate[endPoint[p ^ 1]] = p;\n        }\n        rotate(blossomChilds[b].begin(), blossomChilds[b].begin() + i, blossomChilds[b].end());\n        rotate(blossomEdges[b].begin(), blossomEdges[b].begin() + i, blossomEdges[b].end());\n        blossomBase[b] = blossomBase[blossomChilds[b][0]];\n    }\n    void augmentMatching(int k) {\n        Edge &e = edges[k];\n        int v = e.src, w = e.dst;\n        rep(ii, 0, 2) {\n            int s = ii == 0 ? v : w, p = ii == 0 ? 2 * k + 1 : 2 * k;\n            while (true) {\n                int bs = inBlossom[s];\n                if (bs >= nVertex)\n                    augmentBlossom(bs, s);\n                mate[s] = p;\n                if (labelEdge[bs] == -1)\n                    break;\n                int bt = inBlossom[endPoint[labelEdge[bs]]];\n                s = endPoint[labelEdge[bt]];\n                int j = endPoint[labelEdge[bt] ^ 1];\n                if (bt >= nVertex)\n                    augmentBlossom(bt, j);\n                mate[j] = labelEdge[bt];\n                p = labelEdge[bt] ^ 1;\n            }\n        }\n    }\n    void mainLoop() {\n        rep(t, 0, nVertex) {\n            label.assign(2 * nVertex, 0);\n            bestEdge.assign(2 * nVertex, -1);\n            fill(blossomBestEdgesUsed.begin() + nVertex, blossomBestEdgesUsed.end(), false);\n            allowEdge.assign(nEdge, false);\n            sVerteices.clear();\n            rep(v, 0, nVertex)\n                if (mate[v] == -1 && label[inBlossom[v]] == 0)\n                    assignLabel(v, 1, -1);\n            bool augmented = false;\n            while (true) {\n                Weight kSlack;\n                while (!sVerteices.empty() && !augmented) {\n                    int v = sVerteices.back(); sVerteices.pop_back();\n                    fore(it, neighbEnd[v]) {\n                        int p = it;\n                        int k = p / 2, w = endPoint[p];\n                        if (inBlossom[v] == inBlossom[w])\n                            continue;\n                        if (!allowEdge[k]) {\n                            kSlack = slack(k);\n                            if (kSlack <= 0)\n                                allowEdge[k] = true;\n                        }\n                        if (allowEdge[k]) {\n                            if (label[inBlossom[w]] == 0) {\n                                assignLabel(w, 2, p ^ 1);\n                            }\n                            else if (label[inBlossom[w]] == 1) {\n                                int base = scanBlossom(v, w);\n                                if (base >= 0) {\n                                    addBlossom(base, k);\n                                }\n                                else {\n                                    augmentMatching(k);\n                                    augmented = true;\n                                    break;\n                                }\n                            }\n                            else if (label[w] == 0) {\n                                label[w] = 2;\n                                labelEdge[w] = p ^ 1;\n                            }\n                        }\n                        else if (label[inBlossom[w]] == 1) {\n                            int b = inBlossom[v];\n                            if (bestEdge[b] == -1 || kSlack < slack(bestEdge[b]))\n                                bestEdge[b] = k;\n                        }\n                        else if (label[w] == 0) {\n                            if (bestEdge[w] == -1 || kSlack < slack(bestEdge[w]))\n                                bestEdge[w] = k;\n                        }\n                    }\n                }\n                if (augmented)\n                    break;\n                int deltaType = -1;\n                Weight delta;\n                int deltaEdge, deltaBlossom;\n                if (!maxCardinality) {\n                    deltaType = 1;\n                    delta = *min_element(dualVar.begin(), dualVar.begin() + nVertex);\n                }\n                rep(v, 0, nVertex) {\n                    if (label[inBlossom[v]] == 0 && bestEdge[v] != -1) {\n                        Weight d = slack(bestEdge[v]);\n                        if (deltaType == -1 || d < delta) {\n                            delta = d;\n                            deltaType = 2;\n                            deltaEdge = bestEdge[v];\n                        }\n                    }\n                }\n                rep(b, 0, 2 * nVertex) {\n                    if (blossomParent[b] == -1 && label[b] == 1 && bestEdge[b] != -1) {\n                        kSlack = slack(bestEdge[b]);\n                        Weight d = kSlack / 2;\n                        if (deltaType == -1 || d < delta) {\n                            delta = d;\n                            deltaType = 3;\n                            deltaEdge = bestEdge[b];\n                        }\n                    }\n                }\n                rep(b, nVertex, 2 * nVertex) {\n                    if (blossomBase[b] >= 0 && blossomParent[b] == -1 &&\n                        label[b] == 2 &&\n                        (deltaType == -1 || dualVar[b] < delta)) {\n                        delta = dualVar[b];\n                        deltaType = 4;\n                        deltaBlossom = b;\n                    }\n                }\n                if (deltaType == -1) {\n                    deltaType = 1;\n                    delta = max((Weight)-INT_MAX/2, *min_element(dualVar.begin(), dualVar.begin() + nVertex));\n                }\n                rep(v, 0, nVertex) {\n                    if (label[inBlossom[v]] == 1) {\n                        dualVar[v] -= delta;\n                    }\n                    else if (label[inBlossom[v]] == 2) {\n                        dualVar[v] += delta;\n                    }\n                }\n                rep(b, nVertex, 2 * nVertex) {\n                    if (blossomBase[b] >= 0 && blossomParent[b] == -1) {\n                        if (label[b] == 1) {\n                            dualVar[b] += delta;\n                        }\n                        else if (label[b] == 2) {\n                            dualVar[b] -= delta;\n                        }\n                    }\n                }\n                if (deltaType == 1) {\n                    break;\n                }\n                else if (deltaType == 2) {\n                    allowEdge[deltaEdge] = true;\n                    Edge &e = edges[deltaEdge];\n                    int i = e.src, j = e.dst;\n                    if (label[inBlossom[i]] == 0)\n                        swap(i, j);\n                    sVerteices.push_back(i);\n                }\n                else if (deltaType == 3) {\n                    allowEdge[deltaEdge] = true;\n                    Edge &e = edges[deltaEdge];\n                    int i = e.src;\n                    sVerteices.push_back(i);\n                }\n                else if (deltaType == 4) {\n                    expandBlossom(deltaBlossom, false);\n                }\n            }\n            if (!augmented)\n                break;\n            rep(b, nVertex, 2 * nVertex)\n                if (blossomParent[b] == -1 && blossomBase[b] >= 0 &&\n                    label[b] == 1 && dualVar[b] == 0)\n                    expandBlossom(b, true);\n        }\n    }\n    vi matching(const Edges& edges_, bool maxCardinality_ = false) {\n        edges = edges_; maxCardinality = maxCardinality_;\n        nEdge = edges.size();\n        nVertex = 0;\n        fore(i, edges) {\n            if (i.src >= nVertex) nVertex = i.src + 1;\n            if (i.dst >= nVertex) nVertex = i.dst + 1;\n        }\n        maxWeight = 0;\n        endPoint.clear();\n        neighbEnd.assign(nVertex, vi());\n        rep(i, 0, nEdge) {\n            Edge &e = edges[i];\n            maxWeight = max(maxWeight, e.weight);\n            endPoint.push_back(e.src);\n            endPoint.push_back(e.dst);\n            neighbEnd[e.src].push_back(2 * i + 1);\n            neighbEnd[e.dst].push_back(2 * i);\n        }\n        mate.assign(nVertex, -1);\n        label.assign(2 * nVertex, 0);\n        labelEdge.assign(2 * nVertex, -1);\n        inBlossom.clear();\n        blossomBase.clear();\n        blossomParent.assign(2 * nVertex, -1);\n        blossomChilds.assign(2 * nVertex, vi());\n        blossomEdges.assign(2 * nVertex, vi());\n        bestEdge.assign(2 * nVertex, -1);\n        blossomBestEdgesUsed.assign(2 * nVertex, false);\n        blossomBestEdges.assign(2 * nVertex, vi());\n        unusedBlossoms.clear();\n        dualVar.clear();\n        rep(i, 0, nVertex)\n            inBlossom.push_back(i),\n            blossomBase.push_back(i),\n            unusedBlossoms.push_back(nVertex + i),\n            dualVar.push_back(maxWeight);\n        rep(i, 0, nVertex)\n            blossomBase.push_back(-1),\n            dualVar.push_back(0);\n        allowEdge.assign(nEdge, 0);\n        sVerteices = vi();\n        mainLoop();\n        rep(v, 0, nVertex)\n            if (mate[v] >= 0)\n                mate[v] = endPoint[mate[v]];\n        return mate;\n    }\n    Weight getWeight(const Edges& e, bool maxCardinality_ = false) {\n        vector<int> v = matching(e, maxCardinality_);\n        Weight w = 0;\n        rep(i, 0, v.size()) if (v[i] != -1)\n            fore(j, e) if (i == j.src && j.dst == v[i]) w += j.weight;\n        return w;\n    }\n};\nbool isprime(int v) {\n    if (v == 1) return false;\n    for (int i = 2; 1LL * i*i <= v; i++) if (v%i == 0) return false;\n    return true;\n}\n/*---------------------------------------------------------------------------------------------------\n　　　　　　　　　　　 ∧＿∧  \n　　　　　 ∧＿∧ 　（´<_｀ ）　 Welcome to My Coding Space!\n　　　　 （ ´_ゝ`）　/　 ⌒i     \n　　　　／　　　＼　 　  |　|     \n　　　 /　　 /￣￣￣￣/　　|  \n　 ＿_(__ﾆつ/　    ＿/ .| .|＿＿＿＿  \n　 　　　＼/＿＿＿＿/　（u　⊃  \n---------------------------------------------------------------------------------------------------*/\n\n\n\nint N, X[101];\n//---------------------------------------------------------------------------------------------------\nvoid _main() {\n    cin >> N; rep(i, 0, N) cin >> X[i];\n\n    map<int, int> c;\n    rep(i, 0, N) c[X[i] - 1]++, c[X[i]]++;\n\n    vector<int> v;\n    fore(p, c) if (p.second == 1) {\n        v.push_back(p.first);\n        //printf(\"[%d]\\n\", p.first);\n    }\n\n    int n = v.size();\n    Edges e;\n    rep(a, 0, n) rep(b, a + 1, n) {\n        int d = v[b] - v[a];\n\n        int c = -1;\n        if (d % 2 == 0) c = 2;\n        else if (isprime(d)) c = 1;\n        else c = 3;\n\n        e.push_back(Edge(a, b, 5 - c));\n    }\n\n    MaxWeightMatching m;\n    int ans = m.getWeight(e);\n    ans = 5 * (n / 2) - ans;\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n\n#define Rep(i, n) for (int i = 1; i <= n; i ++)\n\nusing namespace std;\n\nconst int N = 410, N0 = 1e7 + 10;\n\nint d0[N], d[N], cd;\n\nbool isnotprime[N0];\nint prime[N0], cnt;\nvoid get_prime()\n{\n\tisnotprime[1] = true;\n\tfor (int i = 2; i <= 1e7; i ++){\n\t\tif (!isnotprime[i]) prime[++ cnt] = i;\n\t\tfor (int j = 1; j <= cnt && i * prime[j] <= 1e7; j ++) {\n\t\t\tisnotprime[i * prime[j]] = true;\n\t\t\tif (!(i % prime[j])) break;\n\t\t}\n\t}\n}\n\nbool g[N][N], vis[N];\nint lnk[N];\n\nbool dfs(int x)\n{\n\tvis[x] = true;\n\tRep(i, cd) if (g[x][i] && !vis[i]){\n\t\tif (lnk[i] == -1 || dfs(lnk[i])) {\n\t\t\tlnk[i] = x;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint main()\n{\n\tint n;\n\tscanf(\"%d\", &n);\n\tRep(i, n) scanf(\"%d\", &d0[i]);\n\td0[0] = -1;\n\tRep(i, n) {\n\t\tif (d0[i - 1] != d0[i] - 1) d[++ cd] = d0[i];\n\t\tif (d0[i + 1] != d0[i] + 1) d[++ cd] = d0[i] + 1;\n\t}\n\t\n\tget_prime();\n\tRep(i, cd) if (d[i] & 1)\n\t\tRep(j, cd) if (!(d[j] & 1))\n\t\t\tif (!isnotprime[(int)abs(d[j] - d[i])]) g[i][j] = true;\n\t\n\tint c0 = 0, c1 = 0, cc = 0;\n\tRep(i, cd) lnk[i] = -1;\n\tRep(i, cd) {\n\t\t//printf(\"%d\\n\", d[i]);\n\t\tif (d[i] & 1) {\n\t\t\tRep(j, cd) vis[j] = false;\n\t\t\tif (dfs(i)) cc ++;\n\t\t\tc1 ++;\n\t\t}\n\t\telse c0 ++;\n\t}\n\t//printf(\"%d %d %d\\n\", cc, c0, c1);\n\tint ans = cc;\n\tc0 -= cc, c1 -= cc;\n\tans += (c0 / 2) * 2, c0 %= 2;\n\tans += (c1 / 2) * 2, c1 %= 2;\n\tif (c0 && c1) ans += 3;\n\t\n\tprintf(\"%d\\n\", ans);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long int\n\nvector<int> odd, even;\nvector<int> prime_Lst;\n\ntemplate<typename T>\nclass Maxflow\n{\n    struct edge { int to; T cap; int rev; };\n    std::vector<std::vector<edge> > edges;\n    std::vector<int> level;\n    std::vector<int> iter;\n    std::vector<int> used;\n\n    void bfs(int s)\n    {\n        level = std::vector<int>(edges.size(), -1);\n        std::queue<int> q;\n        level[s] = 0;\n        q.push(s);\n        while (!q.empty())\n        {\n            int v = q.front();\n            q.pop();\n            for (edge &e : edges[v])\n            {\n                if (e.cap > 0 && level[e.to] < 0)\n                {\n                    level[e.to] = level[v] + 1;\n                    q.push(e.to);\n                }\n            }\n        }\n    }\n\n    T dfs_d(int v, int goal, T f)\n    {\n        if (v == goal) return f;\n        for (int &i = iter[v]; i < (int)edges[v].size(); i++)\n        {\n            edge &e = edges[v][i];\n            if (e.cap > 0 && level[v] < level[e.to])\n            {\n                T d = dfs_d(e.to, goal, std::min(f, e.cap));\n                if (d > 0)\n                {\n                    e.cap -= d;\n                    edges[e.to][e.rev].cap += d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n\n    T dfs_ff(int v, int goal, T f)\n    {\n        if (v == goal) return f;\n        used[v] = true;\n        for (int i = 0; i < (int)edges[v].size(); i++)\n        {\n            edge &e = edges[v][i];\n            if (e.cap > 0 && !used[e.to])\n            {\n                T d = dfs_ff(e.to, goal, std::min(f, e.cap));\n                if (d > 0)\n                {\n                    e.cap -= d;\n                    edges[e.to][e.rev].cap += d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n\npublic:\n    Maxflow(int N) { edges.resize(N); }\n    void add_edge(int from, int to, T capacity)\n    {\n        edges[from].push_back(edge{to, capacity, (int)edges[to].size()});\n        edges[to].push_back(edge{from, (T)0, (int)edges[from].size() - 1});\n    }\n\n    T Dinic(int s, int t)\n    {\n        constexpr T INF = std::numeric_limits<T>::max();\n        T flow = 0;\n        while (true)\n        {\n            bfs(s);\n            if (level[t] < 0) return flow;\n            iter = std::vector<int>(edges.size(), 0);\n            T f;\n            while ((f = dfs_d(s, t, INF)) > 0) flow += f;\n        }\n    }\n\n    T FF(int s, int t)\n    {\n        constexpr T INF = std::numeric_limits<T>::max();\n        T flow = 0;\n        while (true)\n        {\n            used = std::vector<int>(edges.size(), 0);\n            T f = dfs_ff(s, t, INF);\n            if (f == 0) return flow;\n            flow += f;\n        }\n    }\n};\n\nvoid find_prime(int t)\n{\n    vector<bool> ok(t+1, true);\n    ok[0] = ok[1] = false;\n    for (int i=2; i*i<=t; i++)\n    {\n        if (ok[i] && i>2) prime_Lst.push_back(i);\n        for (int j=i; j<=t; j += i) ok[j] = false;\n    }\n}\n\nsigned main()\n{\n    int len;\n    cin >> len;\n    int tmp = -1;\n    for (int i=0; i<len; i++)\n    {\n        cin >> tmp;\n        if (tmp&1)\n        {\n            if (odd.size() == 0 || odd.back() != tmp)\n            {\n                odd.push_back(tmp);\n            }\n            else\n            {\n                odd.pop_back();\n            }\n            even.push_back(tmp+1);\n        }\n        else\n        {\n            if (even.size() == 0 || even.back() != tmp)\n            {\n                even.push_back(tmp);\n            }\n            else\n            {\n                even.pop_back();\n            }\n            odd.push_back(tmp+1);\n        }\n    }\n\n    find_prime(len);\n\n    int N = odd.size(), M = even.size();\n    Maxflow<int> flow(1+N+M+1);\n    for (int i=1; i<=N; i++) flow.add_edge(0, i, 1);\n    for (int i=1; i<=M; i++) flow.add_edge(N+i, 1+N+M, 1);\n    for (int i=1; i<=N; i++)\n    {\n        for (int j=1; j<=M; j++)\n        {\n            if (binary_search(prime_Lst.begin(), prime_Lst.end(), abs(odd[i-1] - even[j-1]))) flow.add_edge(i, N+j, 1);\n        }\n    }\n    int res = flow.FF(0, 1+N+M);\n    N -= res; M -= res;\n    \n    res += N+M;\n    if (N&1) res++;\n    cout << res << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define reg register\n#define pr std::pair<int, int>\n#define fi first\n#define se second\n#define FIN(s) freopen(s, \"r\", stdin)\n#define FOUT(s) freopen(s, \"w\", stdout)\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define rep(i, l, r) for (int i = l; i <= r; ++i)\n#define lep(i, l, r) for (int i = l; i < r; ++i)\n#define irep(i, r, l) for (int i = r; i >= l; --i)\n#define ilep(i, r, l) for (int i = r; i > l; --i)\n#define Rep(i, n) rep(i, 1, n)\n#define Lep(i, n) lep(i, 1, n)\n#define IRep(i, n) irep(i, n, 1)\n#define ILep(i, n) ilep(i, n, 1)\ntypedef long long ll;\ntypedef long double ld;\n\nnamespace modular {\n    const int MOD = 1000000007;\n    inline int add(int x, int y) { return (x += y) >= MOD ? x -= MOD : x; }\n    inline void inc(int &x, int y) { (x += y) >= MOD ? x -= MOD : 0; }\n    inline int mul(int x, int y) { return 1LL * x * y % MOD; }\n    inline int qpow(int x, int y) {\n        int ans = 1;\n        for (; y; y >>= 1, x = mul(x, x))\n            if (y & 1)\n                ans = mul(ans, x);\n        return ans;\n    }\n}; // namespace modular\n\nnamespace Base {\n    template <typename Tp> inline Tp input() {\n        Tp x = 0, y = 1;\n        char c = getchar();\n        while ((c < '0' || '9' < c) && c != EOF) {\n            if (c == '-')\n                y = -1;\n            c = getchar();\n        }\n        if (c == EOF)\n            return 0;\n        while ('0' <= c && c <= '9')\n            x = x * 10 + c - '0', c = getchar();\n        return x *= y;\n    }\n    template <typename Tp> inline void read(Tp &x) { x = input<Tp>(); }\n    template <typename Tp> inline void chmax(Tp &x, Tp y) { x < y ? x = y : 0; }\n    template <typename Tp> inline void chmin(Tp &x, Tp y) { x > y ? x = y : 0; }\n}; // namespace Base\nusing namespace Base;\n/*----------------------------------------------------------------------------*/\n\n#define MAX_N 107\n#define MAX_P 10000007\n\nint N, res;\nint a[MAX_N], b[MAX_N];\nint pri[MAX_P / 10], tot;\nint match[MAX_N];\nbool check[MAX_P], con[MAX_N][MAX_N], vis[MAX_N];\n\nvoid sieve(int n) {\n    rep(i, 2, n) {\n        if (!check[i]) pri[++tot] = i;\n        Rep(j, tot) {\n            if (i * pri[j] > n) break;\n            check[i * pri[j]] = true;\n            if (i % pri[j] == 0) break;\n        }\n    }\n    check[2] = check[1] = 1;\n}\n\nbool dfs(int x) {\n    Rep(j, N) if (con[x][j]) {\n        if (!vis[j] && (!match[j] || dfs(match[j]))) {\n            vis[j] = true;\n            match[j] = x;\n            res++;\n            return true;\n        }\n    }\n    return false;\n}\n\nvoid solve() {\n    int top = 0;\n    std::sort(a + 1, a + N + 1);\n    b[top = 1] = a[1];\n    a[N + 1] = 0;\n    Rep(i, N) {\n        if (b[top] != a[i] && a[i - 1] != a[i] - 1) b[++top] = a[i];\n        if (a[i] + 1 != a[i + 1]) b[++top] = a[i] + 1;\n    }\n    N = top;\n    Rep(i, N) a[i] = b[i];\n    // Rep(i, N) printf(\"%d \", a[i]); puts(\"\");return;\n    Rep(i, N) if (a[i] & 1) {\n        Rep(j, N) if (a[j] % 2 == 0 && !check[std::abs(a[i] - a[j])]) con[i][j] = true;\n    }\n    Rep(i, N) if (a[i] & 1) {\n        Rep(j, N) vis[j] = false;\n        dfs(i);\n    }\n    Rep(i, N) vis[i] = false;\n    Rep(i, N) if (a[i] % 2 == 0 && match[i]) vis[i] = vis[match[i]] = true;\n    int cnt[2] = {0};\n    Rep(i, N) if (!vis[i]) cnt[a[i] & 1]++;\n    res += 2 * (cnt[0] / 2 + cnt[1] / 2);\n    if (cnt[0] & 1) res += 3;\n    printf(\"%d\\n\", res);\n}\n\nint main() {\n    read(N);\n    int mx = 0;\n    Rep(i, N) read(a[i]), chmax(mx, a[i]);\n    sieve(mx);\n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <set>\n#include <map>\n#include <cmath>\n#include <string>\n#include <cstring>\n#include <sstream>\n#include <algorithm>\nusing namespace std;\n\nconst int Maxn = 105;\nconst int Inf = 1000000000;\n\nint n;\nint x[Maxn];\nint dp[Maxn];\n\nbool Prime(int x)\n{\n\tif (x <= 1) return false;\n\tif (x == 2) return true;\n\tif (x % 2 == 0) return false;\n\tfor (int i = 3; i * i <= x; i += 2)\n\t\tif (x % i == 0) return false;\n\treturn true;\n}\n\nint Get(int x)\n{\n\tif (x == 0) return 0;\n\tif (Prime(x) && x != 2) return 1;\n\tif (x % 2 == 0 && Prime(x - 2)) return 4;\n\tif (x % 2 == 0) return 2;\n\treturn 3;\n}\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; i++)\n\t\tscanf(\"%d\", &x[i]);\n\tfill(dp, dp + n + 1, Inf); dp[0] = 0;\n\tfor (int i = 0; i < n; i++) if (dp[i] < Inf) {\n\t\tint add = 0;\n\t\tfor (int j = i; j < n; j++) {\n\t\t\tdp[j + 1] = min(dp[j + 1], dp[i] + add + Get(x[j] - x[i] + 1));\n\t\t\tif (j + 1 < n) add += Get(x[j + 1] - x[j] - 1);\n\t\t}\n\t}\n\tprintf(\"%d\\n\", dp[n]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "# include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nconst int maxn(2005);\nconst int mxsz(1e7);\n\nint n, x[maxn], pr[mxsz / 10], tot, pos[maxn], vis[maxn];\nint first[maxn], cnt, idx, match[maxn], num;\nbitset <mxsz + 5> ispr;\n\nstruct Edge {\n\tint to, next;\n} edge[maxn * maxn];\n\ninline void Add(int u, int v) {\n\tedge[cnt] = (Edge){v, first[u]}, first[u] = cnt++;\n}\n\nint Dfs(int u) {\n\tint e, v;\n\tfor (e = first[u]; ~e; e = edge[e].next)\n\t\tif (vis[v = edge[e].to] != idx) {\n\t\t\tvis[v] = idx;\n\t\t\tif (!match[v] || Dfs(match[v]))\treturn match[v] = u, 1;\n\t\t}\n\treturn 0;\n}\n\nint main() {\n\tmemset(first, -1, sizeof(first));\n\tint i, j, ans, cnt0, cnt1;\n\tscanf(\"%d\", &n);\n\tfor (i = 1; i <= n; ++i) scanf(\"%d\", &x[i]);\n\tsort(x + 1, x + n + 1);\n\tfor (i = 2; i <= x[n]; ++i) {\n\t\tif (!ispr[i]) pr[++tot] = i;\n\t\tfor (j = 1; j <= tot && pr[j] * i <= x[n]; ++j) {\n\t\t\tispr[pr[j] * i] = 1;\n\t\t\tif (!(i % pr[j])) break;\n\t\t}\n\t}\n\tans = cnt0 = cnt1 = 0;\n\tfor (i = j = 1; i <= n; i = j) {\n\t\twhile (x[j] == x[i] + j - i) ++j;\n\t\tpos[++num] = x[i], pos[++num] = x[j - 1] + 1;\n\t}\n\tfor (i = 1; i <= num; ++i)\n\t\tif (pos[i] & 1) ++cnt1;\n\t\telse ++cnt0;\n\tfor (i = 1; i <= num; ++i)\n\t\tif (pos[i] & 1)\n\t\t\tfor (j = 1; j <= num; ++j)\n\t\t\t\tif ((~pos[j] & 1) && abs(pos[j] - pos[i]) > 2 && !ispr[abs(pos[j] - pos[i])]) Add(i, j);\n\tfor (i = 1; i <= num; ++i)\n\t\tif (pos[i] & 1) ++idx, ans += Dfs(i);\n\tcnt0 -= ans, cnt1 -= ans;\n\tans += (cnt0 / 2) * 2 + (cnt1 / 2) * 2;\n\tif (cnt0 & 1) ans += 3;\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cstdlib>\nusing namespace std;\n\n#define re_ return\n#define in_ inline\n#define op_ operator\n#define inc(l, i, r) for(i=l; i<r; ++i)\n#define st_ static\ntypedef long long ll;\n\nconst int mxn=1<<9;\n\nint n, m, a[mxn], b[mxn<<1], cnt[2], h[mxn<<1];\nstruct edge{int v, o;} e[1<<20];\n\nin_ ll dP(ll a, ll b, ll p)\n{\n    st_ ll r;\n    for(r=1; b; a=a*a%p, b>>=1)\n        b&1? r=r*a%p: 0;\n    re_ r;\n}\n\nin_ char chk(ll a, ll p)\n{\n    st_ ll s, r, i;\n    for(r=p-1, s=0; ~r&1; ++s, r/=2);\n    if(i=dP(a, r, p), i==1 || i==p-1) re_ 1;\n    for(;s--;)\n        if((i=i*i%p)==p-1) re_ 1;\n    re_ 0;\n}\n\nin_ char isP(int p)\n{\n    if(p==2) re_ 1;\n    if(p==1 || ~p&1) re_ 0;\n    st_  int i;\n//    inc(0, i, 48)\n//        if(!chk(rand()%(p-2)+1, p))\n//            re_ 0;\n\n    for(i=2; i*i<=p; ++i)\n        if(p%i==0)\n            re_ 0;\n    re_ 1;\n}\n\nin_ void aE(int u, int v)\n{\n    st_ int tot;\n    e[++tot]=(edge){v, h[u]}, u[h]=tot;\n}\n\nchar vis[mxn<<1];\nchar Hun(int u)\n{\n    st_ int f[mxn<<1];\n    int i, v;\n    for(i=u[h]; v=i[e].v; i=i[e].o)\n        if(!vis[v])\n            if(vis[v]=1, !f[v] || Hun(f[v]))\n            re_ f[v]=u, 1;\n    re_ 0;\n}\n\nint main()\n{\n    srand(998244353);\n    int i, j;\n    scanf(\"%d\", &n);\n    inc(0, i, n)\n        scanf(\"%d\", a+i);\n    sort(a, a+n);\n    inc(0, i, n)\n    {\n        if(!i || a[i]>a[i-1]+1)\n            b[++m]=a[i], ++cnt[a[i]&1];\n        if(i>n-2 || a[i]<a[i+1]-1)\n            b[++m]=a[i]+1, ++cnt[a[i]+1&1];\n    }\n    inc(1, i, m+1)\n        if(b[i]&1)\n            inc(1, j, m+1)\n                if(~b[j]&1 && isP(abs(b[i]-b[j])))\n                    aE(i, j);\n\n    j=0;\n    inc(1, i, m+1)\n        if(b[i]&1)\n            memset(vis, 0, sizeof(vis)),\n                j+=Hun(i);\n\n    printf(\"%d\\n\", cnt[0]+cnt[1]-j+(cnt[0]-j&1));\n//    printf(\"%d\\n\", m);\n//    for(;;) scanf(\"%d\", &i), printf(\"%d\\n\", isP(i));\n    0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <cstdio>\n#include <utility>\n\n#define Int register int\n\nusing namespace std;\n\nconst int MAXN = 100, MAXV = 1e7, MAXM = 5e4, MAXP = 664579, INF = 0x3f3f3f3f;\nint n, L, S, T;\nint pn, Prime[MAXP + 5];\nint CntL, CntR, Left[MAXV + 5], Right[MAXV + 5];\nint Cnte = 1, Head[MAXV + 5];\nbool Vis[MAXV + 5], d[MAXV + 5];\npair<int, int> Path[MAXV + 5];\nqueue<int> Q;\n\nstruct Edge { int To, Flow, nxt; } Graph[MAXV * 2 + 5];\n\ninline int Abs ( const int x ) { return x < 0 ? ~ x + 1 : x; }\n\ninline int Min ( const int a, const int b ) { return a < b ? a : b; }\n\ninline void Link ( const int s, const int t, const int f ) { Graph[++ Cnte] = { t, f, Head[s] }, Head[s] = Cnte; }\n\ninline void AddEdge ( const int s, const int t, const int f ) { Link ( s, t, f ), Link ( f, t, 0 ); }\n\ninline void Sieve ( const int n ) {\n\tVis[0] = Vis[1] = true;\n\tfor ( Int i = 2; i <= n; ++ i ) {\n\t\tif ( ! Vis[i] ) Prime[++ pn] = i;\n\t\tfor ( Int j = 1; j <= pn && i * Prime[j] <= n; ++ j ) {\n\t\t\tVis[i * Prime[j]] = true;\n\t\t\tif ( ! ( i % Prime[j] ) ) break;\n\t\t}\n\t}\n}\n\ninline bool BFS () {\n\tfor ( ; ! Q.empty (); Q.pop () );\n\tfor ( Int i = 1; i <= T; ++ i ) Vis[i] = false;\n\tQ.push ( S ), Vis[S] = true;\n\twhile ( ! Q.empty () ) {\n\t\tint u = Q.front (); Q.pop ();\n\t\tfor ( Int i = Head[u], v; i; i = Graph[i].nxt ) {\n\t\t\tif ( ! Vis[v = Graph[i].To] && Graph[i].Flow > 0 ) {\n\t\t\t\tQ.push ( v ), Vis[v] = true, Path[v] = { u, i };\n\t\t\t\tif ( v == T ) return true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\ninline int EK () {\n\tint ret = 0;\n\tfor ( ; BFS (); ) {\n\t\tint MinFlow = INF;\n\t\tfor ( Int u = T; u ^ S; u = Path[u].first ) MinFlow = Min ( MinFlow, Graph[Path[u].second].Flow );\n\t\tfor ( Int u = T; u ^ S; u = Path[u].first ) {\n\t\t\tGraph[Path[u].second].Flow -= MinFlow;\n\t\t\tGraph[Path[u].second ^ 1].Flow += MinFlow;\n\t\t}\n\t\tret += MinFlow;\n\t}\n\treturn ret;\n}\n\ninline void Work () {\n\tSieve ( MAXV );\n\tscanf ( \"%d\", &n );\n\tfor ( Int i = 1, x; i <= n; ++ i ) {\n\t\tscanf ( \"%d\", &x ), d[x] = true;\n\t\tL = L > x ? L : x;\n\t}\n\tfor ( Int i = 1; i <= L + 1; ++ i ) {\n\t\tif ( d[i] ^ d[i - 1] ) {\n\t\t\tif ( i & 1 ) {\n\t\t\t\tLeft[++ CntL] = i;\n\t\t\t} else {\n\t\t\t\tRight[++ CntR] = i;\n\t\t\t}\n\t\t}\n\t}\n\tS = 0, T = CntL + CntR + 1;\n\tfor ( Int i = 1; i <= CntL; ++ i ) AddEdge ( S, i, 1 );\n\tfor ( Int i = 1; i <= CntR; ++ i ) AddEdge ( i + CntL, T, 1 );\n\tfor ( Int i = 1; i <= CntL; ++ i ) {\n\t\tfor ( Int j = 1; j <= CntR; ++ j ) {\n\t\t\tif ( ! Vis[Abs ( Left[i] - Right[j] )] ) {\n\t\t\t\tAddEdge ( i, j + CntL, 1 );\n\t\t\t}\n\t\t}\n\t}\n\tint mxf = EK (), Ans = mxf;\n\tAns += ( CntL - mxf >> 1 << 1 ) + ( CntR - mxf >> 1 << 1 );\n\tAns += ( ( CntL - mxf ) & 1 ) * 3;\n\tprintf ( \"%d\\n\", Ans );\n}\n\nint main () {\n\tWork ();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace std;\nusing namespace __gnu_pbds;\n\n#define ll long long\n#define db long double\n#define ii pair<int,int>\n#define vi vector<int>\n#define fi first\n#define se second\n#define sz(a) (int)(a).size()\n#define all(a) (a).begin(),(a).end()\n#define pb push_back\n#define mp make_pair\n#define FN(i, n) for (int i = 0; i < (int)(n); ++i)\n#define FEN(i,n) for (int i = 1;i <= (int)(n); ++i)\n#define rep(i,a,b) for(int i=a;i<b;i++)\n#define repv(i,a,b) for(int i=b-1;i>=a;i--)\n#define SET(A, val) memset(A, val, sizeof(A))\ntypedef tree<int ,null_type,less<int>,rb_tree_tag,tree_order_statistics_node_update>ordered_set ;\n// order_of_key (val): returns the no. of values less than val\n// find_by_order (k): returns the kth largest element.(0-based)\n#define TRACE\n#ifdef TRACE\n#define trace(...) __f(#__VA_ARGS__, __VA_ARGS__)\ntemplate <typename Arg1>\nvoid __f(const char* name, Arg1&& arg1){\n  cerr << name << \" : \" << arg1 << std::endl;\n}\ntemplate <typename Arg1, typename... Args>\nvoid __f(const char* names, Arg1&& arg1, Args&&... args){\n  const char* comma = strchr(names + 1, ','); cerr.write(names, comma - names) << \" : \" << arg1<<\" | \";__f(comma+1, args...);\n}\n#else\n#define trace(...)\n#endif\nconst int N=105,L=1e7+5;\nbool mark[L],prime[L];\nnamespace match\n{\n  const int N=105;\n  int l[N],r[N],n,m;\n  bool a[N][N],seen[N];\n  bool findmatch(int i)\n  {\n    rep(j,0,m)\n      {\n\tif(a[i][j] && !seen[j])\n\t  {\n\t    seen[j]=true;\n\t    if(r[j]<0 || findmatch(r[j]))\n\t      {\n\t\tl[i]=j; r[j]=i;\n\t\treturn true;\n\t      }\n\t  }\n      }\n    return false;\n  }\n  int bipartitematch()\n  {\n    int cnt=0;\n    rep(i,0,n) l[i]=-1;\n    rep(i,0,m) r[i]=-1;\n    rep(i,0,n)\n      {\n\trep(j,0,m) seen[j]=false;\n\tif(findmatch(i)) cnt++;\n      }\n    return cnt;\n  }\n};\nint main()\n{\n  std::ios::sync_with_stdio(false);\n  cin.tie(NULL) ; cout.tie(NULL) ;\n  memset(prime,true,sizeof(prime));\n  prime[1]=false;\n  rep(i,2,L)\n    {\n      if(!prime[i]) continue;\n      for(int j=2*i;j<L;j+=i)\n\tprime[j]=false;\n    }\n  prime[2]=false;\n  int n,x;\n  cin>>n;\n  rep(i,1,n+1)\n    {\n      cin>>x;\n      mark[x]=true;\n    }\n  vi arr;\n  rep(i,1,L-1)\n    if((mark[i-1] && !mark[i])  || (!mark[i-1] && mark[i]))\n      arr.pb(i);\n  match::n=match::m=sz(arr);\n  int odd=0,even=0;\n  for(int x:arr)\n    {\n      if(x%2==0) even++;\n      else odd++;\n    }\n  rep(i,0,sz(arr))\n    rep(j,i+1,sz(arr))\n    {\n      if(prime[arr[j]-arr[i]]) match::a[i][j]=1;\n      else match::a[i][j]=0;\n    }\n  assert((even-odd)%2==0);\n  int k=match::bipartitematch();\n  int ans=k+((even-k)/2+(odd-k)/2)*2+((even-k)&1)*3;\n  cout<<ans<<endl;\n  return 0 ;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstring>\n#include <cstdio>\nint a[205],fst[205],match[205],p[1000000],tot=0;\nbool u[10000005],vis[205];\nstruct Edge{int to,nxt;}e[10005];\nvoid addedge(int x,int y){\n\te[++tot].to=y;e[tot].nxt=fst[x];fst[x]=tot;\n}\nvoid init(int n){\n\tfor (int i=2;i<=n;i++){\n\t\tif (!u[i]) p[++p[0]]=i;\n\t\tfor (int j=1;j<=p[0] && i*p[j]<=n;j++){\n\t\t\tu[i*p[j]]=1;\n\t\t\tif (i%p[j]==0) break;\n\t\t}\n\t}\n\tu[0]=u[1]=u[2]=1;\n}\nbool dfs(int x){\n\tif (vis[x]) return 0;\n\tvis[x]=1;\n\tfor (int i=fst[x];i;i=e[i].nxt){\n\t\tint y=e[i].to;\n\t\tif (!match[y] || dfs(match[y])){\n\t\t\tmatch[y]=x;\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\nint main(){\n\tint n,m=0;\n\tscanf(\"%d\\n\",&n);\n\tfor (int i=1;i<=n;i++){\n\t\tint x;scanf(\"%d\",&x);\n\t\tif (a[m]==x) m--;else a[++m]=x;\n\t\ta[++m]=x+1;\n\t}\n\tinit(a[m]-a[1]);\n\tfor (int i=1;i<=m;i++)\n\tif (a[i]&1)\n\t\tfor (int j=1;j<=m;j++)\n\t\tif (!u[abs(a[i]-a[j])]) addedge(i,j);\n\tint ans=0,cnt=0;\n\tfor (int i=1;i<=m;i++)\n\tif (a[i]&1){\n\t\tmemset(vis,0,sizeof vis);\n\t\tif (dfs(i)) ans++;else cnt++;\n\t}\n\tprintf(\"%d\\n\",m-ans+(cnt&1));\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n\n#include <iostream>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <unordered_set>\n#include <queue>\n#include <set>\n#include <algorithm>\n#include <numeric>\n#include <list>\nusing namespace std;\n\nusing QWORD  = uint64_t;\nusing SQWORD = int64_t;\nusing DWORD  = uint32_t;\nusing SDWORD = int32_t;\nusing WORD   = uint16_t;\nusing SWORD  = int16_t;\nusing BYTE   = uint8_t;\nusing SBYTE  = int8_t;\nusing DOUBLE = double;\nusing FLOAT  = float;\n\n#define MIN_SDWORD (-2147483648)\n#define MAX_SDWORD (2147483647)\n#define MIN_SBYTE (-128)\n#define MAX_SBYTE (127)\n\n#define MIN_SQWORD (0x8000000000000000)\n#define MAX_SQWORD (0x7FFFFFFFFFFFFFFF)\n\n#define MAX_QWORD  (0xFFFFFFFFFFFFFFFF)\n#define MAX_DWORD  (0xFFFFFFFF)\n#define MAX_WORD   (0xFFFF)\n#define MAX_BYTE   (0xFF)\n\n#define MAX_DOUBLE      (1.0e+308)\n#define DOUBLE_EPS      (1.0e-12)\n#define MIN_DOUBLE_N    (-1.0e+308)\n\n#define ArrayLength(a)  (sizeof(a) / sizeof(a[0]))\n\nstatic inline DOUBLE MAX(DOUBLE a, DOUBLE b) { return a > b ? a : b; }\nstatic inline QWORD MAX(QWORD a, QWORD b) { return a > b ? a : b; }\nstatic inline DWORD MAX(DWORD a, DWORD b) { return a > b ? a : b; }\nstatic inline SDWORD MAX(SDWORD a, SDWORD b) { return a > b ? a : b; }\nstatic inline DOUBLE MIN(DOUBLE a, DOUBLE b) { return a < b ? a : b; }\nstatic inline QWORD MIN(QWORD a, QWORD b) { return a < b ? a : b; }\nstatic inline DWORD MIN(DWORD a, DWORD b) { return a < b ? a : b; }\nstatic inline SDWORD MIN(SDWORD a, SDWORD b) { return a < b ? a : b; }\nstatic inline DOUBLE ABS(DOUBLE a) { return 0 < a ? a : -a; };\n\n#define BYTE_BITS   (8)\n#define WORD_BITS   (16)\n#define DWORD_BITS  (32)\n#define QWORD_BITS  (64)\n\nstatic inline void inputStringSpSeparated(char *pcStr)\n{\n    char *pcCur = pcStr;\n    for (;;) {\n        char c = getchar();\n        if (('\\n' == c) || (EOF == c) || (' ' == c)) {\n            break;\n        }\n        *pcCur = c;\n        pcCur++;\n    }\n    *pcCur = '\\0';\n}\n\nstatic inline void inputString(char *pcStr)\n{\n    char *pcCur = pcStr;\n    for (;;) {\n        char c = getchar();\n        if (('\\n' == c) || (EOF == c)) {\n            break;\n        }\n        *pcCur = c;\n        pcCur++;\n    }\n    *pcCur = '\\0';\n}\n\n\nstatic inline SQWORD inputSQWORD(void)\n{\n    SQWORD sqNumber = 0;\n    SQWORD sqMultiplier = 1;\n    bool bRead = false;\n    for (;;) {\n        char c = getchar();\n        if (!bRead) {\n            if ('-' == c) {\n                sqMultiplier = -1;\n            }\n        }\n        if (('0' <= c) && (c <= '9')) {\n            sqNumber *= 10LL;\n            sqNumber += (SQWORD)(c - '0');\n            bRead = true;\n        } else {\n            if (bRead) {\n                return sqNumber * sqMultiplier;\n            }\n        }\n    }\n}\n\n\nstatic inline SDWORD inputSDWORD(void)\n{\n    SDWORD lNumber = 0;\n    SDWORD lMultiplier = 1;\n    bool bRead = false;\n    for (;;) {\n        char c = getchar();\n        if (!bRead) {\n            if ('-' == c) {\n                lMultiplier = -1;\n            }\n        }\n        if (('0' <= c) && (c <= '9')) {\n            lNumber *= 10;\n            lNumber += (c - '0');\n            bRead = true;\n        } else {\n            if (bRead) {\n                return lNumber * lMultiplier;\n            }\n        }\n    }\n}\n\nstatic inline DOUBLE inputFP(void)\n{\n    DOUBLE dInt = 0.0;\n    DOUBLE dFrac = 0.0;\n    DOUBLE dMultiplier = 1.0;\n    DWORD dwFpCnt = 0;\n    DOUBLE *pdCur = &dInt;\n    bool bRead = false;\n    for (;;) {\n        char c = getchar();\n        if (!bRead) {\n            if ('-' == c) {\n                dMultiplier = -1;\n            }\n        }\n        if ('.' == c) {\n            pdCur = &dFrac;\n        } else if (('0' <= c) && (c <= '9')) {\n            (*pdCur) *= 10;\n            (*pdCur) += (DOUBLE)(c - '0');\n            bRead = true;\n            if (pdCur == &dFrac) {\n                dwFpCnt++;\n            }\n        } else {\n            if (bRead) {\n                return dMultiplier * (dInt + dFrac / (pow((DOUBLE)10.0 , (DOUBLE)dwFpCnt)));\n            }\n        }\n    }\n}\n\n\n/**\n *  mod による操作ライブラリ\n */\n\n#define ANS_MOD (1000000007LL)\n \nstatic SQWORD addMod(SQWORD x, SQWORD y)\n{ \n    return (x + y) % ANS_MOD;\n}\n \nstatic SQWORD subMod(SQWORD x, SQWORD y)\n{\n    return (x - y + ANS_MOD) % ANS_MOD;\n}\n \nstatic SQWORD mulMod(SQWORD x, SQWORD y) \n{\n    return (x * y) % ANS_MOD;\n}\n \nstatic SQWORD powMod(SQWORD x, SQWORD e) {\n    SQWORD v = 1;\n    for (; e; x = mulMod(x, x), e >>= 1) {\n        if (e & 1) {\n            v = mulMod(v, x);\n        }\n    }\n    return v;\n}\n \nstatic SQWORD divMod(SQWORD x, SQWORD y)\n{\n    return mulMod(x, powMod(y, ANS_MOD - 2));\n}\n \n \nstatic SQWORD combMod(SQWORD n, SQWORD k)\n{\n    SQWORD v=1;\n    for(SQWORD i=1; i<=k; i++) {\n        v = divMod(mulMod(v, n-i+1),i);\n    } \n    return v;\n}\n\n/*----------------------------------------------*/\n\n#define MAX_V   (500)\n#define INF 2e9\n\n/* 辺を表す構造体 */\nstruct edge {int to, cap ,rev; };\n \n/* グラフの隣接リスト表現 */\nvector<edge> G[MAX_V];\n/* DFSですべに調べたかのグラフ */\nbool used[MAX_V];\n \n/* fromからtoへ向かう容量capの辺をグラフに追加する */\n/* 相互参照できるようにしている */\nvoid add_edge(int from, int to, int cap){\n    G[from].push_back((edge){to, cap, (int)G[to].size()});\n    G[to].push_back((edge){from, 0, (int)G[from].size() - 1});    \n}\n \n/* 増加パスをdfsで探す */\nint dfs(int v, int t, int f){\n    if(v==t) return f;\n    used[v] = true;\n    for(int i=0; i<G[v].size(); i++){\n        edge &e = G[v][i];\n        if(!used[e.to] && e.cap>0){\n            int d = dfs(e.to, t, min(f, e.cap));\n            if(d>0){\n                e.cap -= d;\n                G[e.to][e.rev].cap += d;\n                return d;\n            }\n        }\n    }\n    return 0;\n}\n \nint max_flow(int s, int t){\n    int flow = 0;\n    for(;;){\n        memset(used, 0, sizeof(used));\n        int f = dfs(s, t, INF);\n        if(f==0) return flow;\n        flow += f;\n    }\n}\n/*----------------------------------------------*/\n\nclass PrimeTable {\n    vector<bool> vbIsPrime;\n\npublic:\n    PrimeTable(SDWORD lMax) {\n        /* lSearchMax と ループ内の *2 の関係から、入力は3以上とすること */\n        if (!(1 <= lMax)) {\n            printf(\"Oops!\");\n            return;\n        }\n\n        /* 素数のリストを作る */\n        vbIsPrime.resize(lMax + 1, true);\n        SDWORD lSearchMax = sqrt(lMax) + 1;\n        vbIsPrime[0] = false;\n        vbIsPrime[1] = false;\n        for (SDWORD lPrime = 2; lPrime < lSearchMax; lPrime++) {\n            if (vbIsPrime[lPrime]) {\n                for (SDWORD lCurNum = lPrime * 2; lCurNum <= lMax; lCurNum += lPrime) {\n                    vbIsPrime[lCurNum] = false;\n                }\n            }\n        }\n    };\n\n    bool IsPrime(SQWORD sqN)\n    {\n#if 0\n        return vbIsPrime[sqN];\n#else\n        if(sqN <= 2) return false;\n        for (int i = sqrt(sqN)+1; 2 < i; i--) if(sqN % i == 0) return false;\n    \n        return true;\n#endif\n    }\n};\n\n\n/*----------------------------------------------*/\n\n#define PNT_NO_START    (0)\n#define PNT_NO_OFFSET   (200)\n#define PNT_NO_TARGET   (401)\n#define FLOW_OFFSET     (1000000000)\n#define CAPACITY_INF    (1000000001)\n#define DUMMY_COST      (1)\n\nint main(void)\n{\n    SQWORD sqN = inputSQWORD();\n\n    vector<SQWORD> vsqB;\n\n    PrimeTable prime(1e7 + 1);\n \n    map<SQWORD, SQWORD> mapB;\n\n    for (SQWORD sqIdx = 0; sqIdx < sqN; sqIdx++) {\n        SQWORD sqA = inputSQWORD();\n        mapB[sqA] ^= 1;\n        mapB[sqA + 1] ^= 1;\n    }\n\n    vector<SQWORD> vsqBEven, vsqBOdd;\n\n    for (auto b: mapB) {\n        if (0 < b.second) {\n            if (0 == (b.first % 2)) {\n                vsqBEven.emplace_back(b.first);\n            } else {\n                vsqBOdd.emplace_back(b.first);\n            }\n        }\n    }\n\n    SQWORD sqNodeEven = 1;\n    for (auto e: vsqBEven) {\n        SQWORD sqNodeOdd = 1;\n        for (auto o: vsqBOdd) {\n            if (prime.IsPrime(abs(e - o))) {\n                add_edge(sqNodeEven, sqNodeOdd + PNT_NO_OFFSET, 1);\n            }\n            sqNodeOdd++;\n        }\n        sqNodeEven++;\n    }\n    for (SQWORD sqIdx = 1; sqIdx <= vsqBEven.size(); sqIdx++) {\n        add_edge(PNT_NO_START, sqIdx, 1);\n    }\n    for (SQWORD sqIdx = 1; sqIdx <= vsqBOdd.size(); sqIdx++) {\n        add_edge(sqIdx + PNT_NO_OFFSET, PNT_NO_TARGET, 1);\n    }\n\n\n\n    SQWORD sqMaxFlow = max_flow(PNT_NO_START, PNT_NO_TARGET);\n    SQWORD vsqCRestEven = vsqBEven.size() - sqMaxFlow;\n    SQWORD vsqCRestOdd  = vsqBOdd.size() - sqMaxFlow;\n\n    SQWORD sqAns = sqMaxFlow;    \n    sqAns += ((vsqCRestEven / 2) * 2);\n    sqAns += ((vsqCRestOdd / 2) * 2);\n    if (0 < (vsqCRestEven %  2)) {\n        sqAns += 3;\n    }\n\n    printf(\"%lld\\n\", sqAns);\n\n    return 0;\n}\n/*------------------------------------------*/\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <algorithm>\n#include <cmath>\n#include <cstring>\n#include <complex>\n\nusing namespace std;\n\n//typedef\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long ll;\n\n#define omajinai ios::sync_with_stdio(false);cin.tie(0)\n\n//container util\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define UNIQUE(a)  (a).erase(unique((a).begin(),(a).end()),(a).end())\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(auto i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n#define RFOR(i,b,a) for(int i=(b)-1;i>=(a);--i)\n#define RREP(i,n) RFOR(i,n,0)\n\n//debug\n#define dump(x)  cerr << \"[L \" << __LINE__ << \"] \" << #x << \" = \" << (x) << \"\\n\";\n\n// i love camel\n\n/// flow\nstruct edge {int to, cap, rev;}; // rev Index\nconst int _V = 200 + 2; // _N + source + sink\nvector<edge> G[_V];\nbool used[_V];\n\nvoid addEdge(int from, int to){\n\tG[from].push_back((edge) {to, 1, G[to].size()});\n\tG[to].push_back((edge) {from, 0, G[from].size() - 1}); // rev\n}\n\nint dfs(int v, int t){\n\tif(v==t)return 1;\n\tused[v] = true;\n\tREP(i, G[v].size()){\n\t\tedge &e = G[v][i];\n\t\tif(!used[e.to] && e.cap > 0){\n\t\t\tint d = dfs(e.to, t);\n\t\t\te.cap -= d;\n\t\t\tG[e.to][e.rev].cap += d;\n\t\t\treturn d;\n\t\t}\n\t}\n\treturn 0;\n}\n\nint maxFlow(int s, int t){\n\tint flow=0;\n\twhile(true){\n\t\tmemset(used, 0, sizeof used);\n\t\tint p = dfs(s, t);\n\t\tif(!p)return flow;\n\t\tflow += p;\n\t}\n}\n\n///\n\nbool isPrime(int x){\n\tif(x==1)return false;\n\tfor(int i=2;i*i<=x;i++){\n\t\tif(x%i==0)return false;\n\t}\n\treturn true;\n}\n\nVI diff_odd, diff_even;\nint main() {\n\tint n;\n\tcin >> n;\n\tint last=-1;\n#define ADD(a) ((a)%2 ? diff_odd : diff_even).push_back(a)\n\tREP(i, n){\n\t\tint x;\n\t\tcin >> x;\n\t\tif(x!=last+1){ // not 隣接\n\t\t\tif(last>0)ADD(last);\n\t\t\tADD(x-1);\n\t\t}\n\t\tlast = x;\n\t}\n\tADD(last);\n\tREP(i, diff_odd.size())addEdge(200, i);\n\tREP(j, diff_even.size())addEdge(j + diff_odd.size(), 201);\n\tREP(i, diff_odd.size()){\n\t\tREP(j, diff_even.size()){\n\t\t\tint o = diff_odd[i], e = diff_even[j];\n\t\t\tif(isPrime(abs(o-e)))addEdge(i, j + diff_odd.size());\n\t\t}\n\t}\n\tint ans, k = ans = maxFlow(200, 201);\n\tans += (diff_odd.size() - k)/2*2;\n\tans += (diff_even.size() - k)/2*2;\n\tans += (diff_odd.size() - k) % 2 * 3;\n\tcout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <cmath>\n#include <cstring>\n#define N 1000006\n#define M 10000007\n\nusing namespace std;\n\nstruct edge{\n\tint to, nxt;\n}e[M];\n\nint n, cnt, tot, numx, numy;\nint fir[N], a[N], b[N], prime[M], link[N], x[N], y[N];\nbool vis[M], book[N];\n\nvoid init();\nvoid add(int ,int);\nbool dfs(int);\n\nint main(){\n\tscanf(\"%d\", &n);init();\n\tfor(int i = 1; i <= n; ++i)\n\t\tscanf(\"%d\", a + i);\n\tsort(a + 1,a + 1 + n);a[0] = a[n + 1] = 99999999;\n\tfor(int i = 1; i <= n; ++i){\n\t\tif(a[i] != a[i - 1] + 1) b[++cnt] = a[i];\n\t\tif(a[i] != a[i + 1] - 1) b[++cnt] = a[i] + 1;\n\t}\n\tfor(int i = 1; i <= cnt; ++i){\n\t\tif(b[i] & 1) x[++numx] = b[i];\n\t\telse y[++numy] = b[i];\n\t}\n\tcnt = 0;\n\tfor(int i = 1; i <= numx; ++i)\n\t\tfor(int j = 1; j <= numy; ++j)\n\t\t\tif(!vis[abs(x[i] - y[j])])\n\t\t\t\tadd(i, j);\n\tfor(int i = 1; i <= numx; ++i){\n\t\tmemset(book, false, sizeof book);\n\t\tdfs(i);\n\t}\n\tint ans = 0;\n\tfor(int i = 1; i <= numy; ++i)\n\t\tif(link[i]) \n\t\t\t++ans;\n\tnumy -= ans;numx -= ans;\n\tans += (numy / 2) * 2 + (numx / 2) * 2;\n\tans += (numy % 2) * (numx % 2) * 3;\n\tcout << ans << endl;\n\treturn 0;\n}\n\nvoid add(int u,int v){\n\te[++cnt].to = v;e[cnt].nxt = fir[u];fir[u] = cnt;\n\treturn ;\n}\n\nvoid init(){\n\tint m = 1e7;\n\tfor(int i = 2; i <= m; ++i){\n\t\tif(!vis[i]) prime[++tot] = i;\n\t\tfor(int j = 1; j <= tot && i * prime[j] <= m; ++j){\n\t\t\tvis[i * prime[j]] = true;\n\t\t\tif(i % prime[j] == 0) break;\n\t\t}\n\t}\n\tvis[1] = vis[2] = true;\n\treturn ;\n}\n\nbool dfs(int u){\n\tif(book[u]) return false;\n\tbook[u] = true;\n\tfor(int i = fir[u]; i; i = e[i].nxt){\n\t\tint v = e[i].to;\n\t\tif(!link[v] || dfs(link[v])){\n\t\t\tlink[v] = u;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<cstring>\nusing namespace std;\nint n;\nint res;\nvector<int>v;\nint lst=-1;\nint match[210];\nint me,mo;\nint mx;\nbool f[10000010];\nbool ok[210][210];\nbool vis[210];\nint prm[1000010];\nint sz;\nint l;\nbool bp(int x)\n{\n\tfor(int i=0;i<l;i++)\n\t{\n\t\tif(!ok[x][i])continue;\n\t\tif(vis[i])continue;\n\t\tvis[i]=true;\n\t\tif(match[i]==-1 || bp(match[i]))\n\t\t{\n\t\t\tmatch[i]=x;\n\t\t\treturn true;\n\t\t}\n\t\tvis[i]=false;\n\t}\n\treturn false;\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint x;\n\t\tscanf(\"%d\",&x);\n\t\tif(x!=lst+1)\n\t\t{\n\t\t\tif(lst+1)v.push_back(lst+1);\n\t\t\tv.push_back(x);\n\t\t}\n\t\tlst=x;\n\t\tmx=lst+1;\n\t}\n\tv.push_back(lst+1);\n\tf[1]=true;\n\tfor(int i=2;i<=mx;i++)\n\t{\n\t\tif(!f[i])prm[++sz]=i;\n\t\tfor(int j=1;j<=sz;j++)\n\t\t{\n\t\t\tif(prm[j]*i>mx)break;\n\t\t\tf[prm[j]*i]=true;\n\t\t\tif(i%prm[j]==0)break;\n\t\t}\n\t}\n\tl=v.size();\n\tfor(int i=0;i<l;i++)\n\t{\n\t\tmatch[i]=-1;\n\t\tif(v[i]&1)mo++;else me++;\n\t\tfor(int j=i+1;j<l;j++)\n\t\t{\n\t\t\tif(v[j]-v[i]!=2 && !f[v[j]-v[i]])\n\t\t\t{\n\t\t\t\tok[i][j]=ok[j][i]=true;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<l;i++)\n\t{\n\t\tmemset(vis,false,sizeof(vis));\n\t\tif(bp(i))res++;\n\t}\n\tres/=2;\n\tprintf(\"%d\",res+((me-res)/2+(mo-res)/2)*2+((me-res)%2)*3);\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<algorithm>\n#include<cstdio>\n#include<cmath>\n#include<cassert>\n#define ll long long\nusing namespace std;\ninline int read(){\n\tint re=0,flag=1;char ch=getchar();\n\twhile(ch>'9'||ch<'0'){\n\t\tif(ch=='-') flag=-1;\n\t\tch=getchar();\n\t}\n\twhile(ch>='0'&&ch<='9') re=(re<<1)+(re<<3)+ch-'0',ch=getchar();\n\treturn re*flag;\n}\nint vis[10000010],pri[1000010],cntp;\nvoid init(){\n\tint i,j,k;vis[1]=1;\n\tfor(i=2;i<=10000005;i++){\n\t\tif(!vis[i]) pri[++cntp]=i;\n\t\tfor(j=1;j<=cntp;j++){\n\t\t\tk=i*pri[j];if(k>=10000005) break;\n\t\t\tvis[k]=1;\n\t\t\tif(i%pri[j]==0) break;\n\t\t}\n\t}\n}\nstruct graph{//DINIC大法好！网络流应该比匈牙利快吧...... \n\tint first[1010],dep[1010],cur[1010],cnte;\n\tstruct edge{\n\t\tint to,next,w;\n\t}a[100010];\n\tgraph(){\n\t\tmemset(first,-1,sizeof(first));cnte=-1;\n\t}\n\tinline void add(int u,int v,int w){\n//\t\tcout<<\"addedge \"<<u<<' '<<v<<' '<<w<<'\\n';\n\t\ta[++cnte]=(edge){v,first[u],w};first[u]=cnte;\n\t\ta[++cnte]=(edge){u,first[v],0};first[v]=cnte;\n\t}\n\tbool bfs(int s,int t){\n\t\tint q[1010],head=0,tail=1,i,u,v;\n\t\tfor(i=s;i<=t;i++) dep[i]=-1,cur[i]=first[i];\n\t\tdep[s]=0;q[0]=s;\n\t\twhile(head<tail){\n\t\t\tu=q[head++];\n\t\t\tfor(i=first[u];~i;i=a[i].next){\n\t\t\t\tv=a[i].to;if(~dep[v]||!a[i].w) continue;\n\t\t\t\tdep[v]=dep[u]+1;q[tail++]=v;\n\t\t\t}\n\t\t}\n\t\treturn ~dep[t];\n\t}\n\tint dfs(int u,int t,int lim){\n\t\tif(u==t||!lim) return lim;\n\t\tint i,v,f,flow=0;\n\t\tfor(i=cur[u];~i;i=a[i].next){\n\t\t\tv=a[i].to;cur[u]=i;\n\t\t\tif(dep[v]==dep[u]+1&&(f=dfs(v,t,min(lim,a[i].w)))){\n\t\t\t\ta[i].w-=f;a[i^1].w+=f;\n\t\t\t\tflow+=f;lim-=f;\n\t\t\t\tif(!lim) return flow; \n\t\t\t}\n\t\t}\n\t\treturn flow;\n\t}\n\tint dinic(int s,int t){\n\t\tint re=0;\n\t\twhile(bfs(s,t)) re+=dfs(s,t,1e9);\n\t\treturn re;\n\t}\n}G;\nint n,x[110],one[210],cnt,l[210],cntl,r[210],cntr;\nint main(){\n\tinit();int i,j,match;\n\tn=read();\n\tfor(i=1;i<=n;i++) x[i]=read();\n\tfor(i=1;i<=n;i=j+1){\n\t\tj=i;\n\t\twhile((x[j+1]==x[j]+1)&&j<n) j++;\n\t\tone[++cnt]=x[i];one[++cnt]=x[j]+1;\n\t}\n\tfor(i=1;i<=cnt;i++){\n\t\tif(one[i]%2) l[++cntl]=one[i];\n\t\telse r[++cntr]=one[i];\n\t}\n\tfor(i=1;i<=cntl;i++) G.add(0,i,1);\n\tfor(i=1;i<=cntr;i++) G.add(i+cntl,cntl+cntr+1,1);\n\tfor(i=1;i<=cntl;i++){\n\t\tfor(j=1;j<=cntr;j++){\n//\t\t\tcout<<\"do \"<<i<<' '<<j<<' '<<l[i]<<' '<<r[j]<<'\\n';\n\t\t\tif(!vis[abs(l[i]-r[j])]) G.add(i,cntl+j,1);\n\t\t}\n\t}\n\tmatch=G.dinic(0,cntl+cntr+1);\n\tprintf(\"%d\\n\",match+((cntl-match)/2+(cntr-match)/2)*2+((cntl-match)%2)*3);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nstruct edge{\n  long to,cap,rev;//capは残りどれだけ流せるか, revはv[to][rev]が自分への逆辺を表す\n  edge(){}\n  edge(long t,long c,long r):to(t),cap(c),rev(r){}\n};\nclass flow{\n  long n;\n  vector<vector<edge>>v;\n  vector<bool>used;\n  public:\n  \n  long dfs(long s,long t,long f){\n    if(s==t)return f;\n    used[s]=1;\n    for(long i=0;i<v[s].size();i++){\n      edge e=v[s][i];\n      if(!used[e.to]&&e.cap>0){\n        long r=dfs(e.to,t,min(f,e.cap));\n        if(r>0){\n          v[s][i].cap-=r;v[e.to][e.rev].cap+=r;\n          return r;\n        }\n      }\n    }\n    return 0;\n  }\n  long solve(long s,long t){//最大流を求める\n    long ans=0;\n    while(1){\n      used.clear();used=vector<bool>(n,0);\n      long f=dfs(s,t,LONG_MAX);\n      if(f==0)return ans;\n      else ans+=f;\n    }\n  }\n  flow(){}\n  flow(const vector<vector<edge>>&v_)\n    :n(v_.size()),v(vector<vector<edge>>(v_.size())){\n      for(long i=0;i<n;i++)for(long j=0;j<v_[i].size();j++){\n        edge e=v_[i][j];\n        v[i].push_back(edge(e.to,e.cap,v[e.to].size()));//辺の追加\n        v[e.to].push_back(edge(i,0,v[i].size()-1));//逆辺の追加\n      }\n    }\n};\n\nint main(){\n  //素数前処理\n  long M=10000001;\n  vector<bool>prime(M,1);prime[0]=0,prime[1]=0;\n  for(long i=2;i<=M;i++){\n    if(prime[i]){\n      for(long j=2;i*j<=M;j++)prime[i*j]=0;\n    }\n  }\n  \n  long N;cin>>N;\n  vector<long>X(N);for(long i=0;i<N;i++)cin>>X[i];\n  vector<long>O,E;\n  for(long i=0;i<N;i++){\n    if(i==0||X[i]-1!=X[i-1]){if(X[i]%2)O.push_back(X[i]);else E.push_back(X[i]);}\n    if(i==N-1||X[i]+1!=X[i+1]){if((X[i]+1)%2)O.push_back(X[i]+1);else E.push_back(X[i]+1);}\n  }\n  \n  vector<vector<edge>>A(2+O.size()+E.size());\n  for(long i=0;i<O.size();i++)A[0].push_back(edge(1+i,1,0));\n  for(long i=0;i<E.size();i++)A[1+O.size()+i].push_back(edge(1+O.size()+E.size(),1,0));\n  for(long i=0;i<O.size();i++)for(long j=0;j<E.size();j++){\n    long d=abs(O[i]-E[j]);\n    if(prime[d])A[1+i].push_back(edge(1+O.size()+j,1,0));\n  }\n  flow f(A);long k=f.solve(0,1+O.size()+E.size());\n  long ans=k+2*((O.size()-k)/2)+2*((E.size()-k)/2)+3*((O.size()-k)%2);\n  cout<<ans;\n}\n\n/*\n*/"
  },
  {
    "language": "C++",
    "code": "// #includes {{{\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define RREP(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define FOR(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();++i)\n#define LET(x,a) __typeof(a) x(a)\n//#define IFOR(i,it,c) for(__typeof((c).begin())it=(c).begin();it!=(c).end();++it,++i)\n#define ALL(c) (c).begin(), (c).end()\n#define MP make_pair\n\n#define EXIST(e,s) ((s).find(e)!=(s).end())\n\n#define RESET(a) memset((a),0,sizeof(a))\n#define SET(a) memset((a),-1,sizeof(a))\n#define PB push_back\n#define DEC(it,command) __typeof(command) it=command\n\n//debug\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n#define debug2(x) cerr << #x << \" = [\";REP(__ind,(x).size()){cerr << (x)[__ind] << \", \";}cerr << \"] (L\" << __LINE__ << \")\" << endl;\n\nconst int INF=0x3f3f3f3f;\n\ntypedef long long Int;\ntypedef unsigned long long uInt;\ntypedef long double rn;\n\ntypedef pair<int,int> pii;\n\n/*\n#ifdef MYDEBUG\n#include\"debug.h\"\n#include\"print.h\"\n#endif\n*/\n// }}}\n\n//{{{ io\nFILE *file_in=stdin,*file_out=stdout;\n#define fin normal_in\n#define fout normal_out\n//const char fname[]=\"\";\n//FILE *fin=fopen(fname,\"r\"),*fout=fopen(fname,\"w\");\n#ifdef __MINGW32__\n#define LLD \"%I64d\"\n#define LLU \"%I64u\"\n#else\n#define LLD \"%lld\"\n#define LLU \"%llu\"\n#endif\nstruct NORMAL_IN{\n\tbool cnt;\n\tNORMAL_IN():cnt(true){}\n\toperator int() const {return cnt;}\n#define endl \"\\n\"\n\tNORMAL_IN& operator>>(int &n){cnt=fscanf(file_in,\"%d\",&n)!=EOF;return *this;}\n\tNORMAL_IN& operator>>(unsigned int &n){cnt=fscanf(file_in,\"%u\",&n)!=EOF;return *this;}\n\tNORMAL_IN& operator>>(long long &n){cnt=fscanf(file_in,LLD,&n)!=EOF;return *this;}\n\tNORMAL_IN& operator>>(unsigned long long &n){cnt=fscanf(file_in,LLU,&n)!=EOF;return *this;}\n\tNORMAL_IN& operator>>(double &n){cnt=fscanf(file_in,\"%lf\",&n)!=EOF;return *this;}\n\tNORMAL_IN& operator>>(long double &n){cnt=fscanf(file_in,\"%Lf\",&n)!=EOF;return *this;}\n\tNORMAL_IN& operator>>(char *c){cnt=fscanf(file_in,\"%s\",c)!=EOF;return *this;}\n\tNORMAL_IN& operator>>(string &s){\n\t\ts.clear();\n\t\tfor(bool r=false;;){\n\t\t\tconst char c=getchar();\n\t\t\tif(c==EOF){ cnt=false; break;}\n\t\t\tconst int t=isspace(c);\n\t\t\tif(!r and !t)r=true;\n\t\t\tif(r){\n\t\t\t\tif(!t)s.push_back(c);\n\t\t\t\telse break;\n\t\t\t}\n\t\t}\n\t\treturn *this;\n\t}\n\ttemplate<class T>\n\t\tNORMAL_IN& operator>>(vector<T> &v){\n\t\t\tint n;fscanf(file_in,\"%d\",&n);\n\t\t\tREP(i,n){\n\t\t\t\tT t;*this>>t;\n\t\t\t\tv.push_back(t);\n\t\t\t}\n\t\t}\n} normal_in;\n\nstruct NORMAL_OUT{\n\tNORMAL_OUT& operator<<(const int &n){fprintf(file_out,\"%d\",n);return *this;}\n\tNORMAL_OUT& operator<<(const unsigned int &n){fprintf(file_out,\"%u\",n);return *this;}\n\tNORMAL_OUT& operator<<(const long long &n){fprintf(file_out,LLD,n);return *this;}\n\tNORMAL_OUT& operator<<(const unsigned long long &n){fprintf(file_out,LLU,n);return *this;}\n\tNORMAL_OUT& operator<<(const double &n){fprintf(file_out,\"%lf\",n);return *this;}\n\tNORMAL_OUT& operator<<(const long double &n){fprintf(file_out,\"%Lf\",n);return *this;}\n\tNORMAL_OUT& operator<<(const char c[]){fprintf(file_out,\"%s\",c);return *this;}\n\tNORMAL_OUT& operator<<(const string &s){fprintf(file_out,\"%s\",s.c_str());return *this;}\n} normal_out;\n//}}}\n\n//{{{ Graph\ntypedef int Weight;\nstruct Edge {\n\tint src, dst, rev;\n\tWeight weight;\n\tEdge(int src, int dst, Weight weight=1,int rev=-1) :\n\t\tsrc(src), dst(dst), weight(weight), rev(rev) { }\n};\nbool operator < (const Edge &e, const Edge &f) {\n\treturn e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n\t\te.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vector<Edge> Edges;\n//typedef vector<Edges> Graph;\n\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n\nstruct Graph:vector<Edges>{\n\tGraph(){}\n\tGraph(const int &n){this->assign(n,Edges());}\n\t//add bi-directional edge\n\tvoid addBiEdge(int from ,int to, Weight w=1){\n\t\twhile(this->size()<max(from,to)+1)this->push_back(Edges());\n\t\tthis->at(from).push_back(Edge(from,to,w,this->at(to).size()));\n\t\tthis->at(to).push_back(Edge(to,from,w,this->at(from).size()-1));\n\t}\n\t//add directional edge\n\tvoid addEdge(int from ,int to, Weight w=1){\n\t\twhile(this->size()<from+1)this->push_back(Edges());\n\t\tthis->at(from).push_back(Edge(from,to,w));\n\t}\n};\n#ifdef DEBUG\n#include\"graph/graphviz.h\"\n#endif\n//}}}\n\ntypedef Weight Flow;\ntypedef long long Cost;\n\nconst Cost CINF=1e+18;\nconst Flow FINF=1e+9;\n\n//{{{ addFlowEdge(Graph,vector<vector<Cost> >, from,to,Flow,Cost)\nvoid addFlowEdge(Graph &g,vector<vector<Cost> > &costv,int from,int to,Flow cap,Cost cost){\n\tg[from].push_back(Edge(from,to,cap,g[to].size()));\n\tg[to].push_back(Edge(to,from,0,g[from].size()-1));\n\tcostv[from].push_back(cost);\n\tcostv[to].push_back(-cost);\n}\n//}}}\n//{{{ minCostFlow(Graph g,vector<vector<Cost> > cost,int s,int t,int f)\nvector<vector<Flow> > flow;\n\nCost minCostFlow(const Graph &g,const vector<vector<Cost> > &cost,int s,int t,Flow f){\n\tconst int n=g.size();\n\tflow.assign(n,vector<Flow>());\n\tREP(i,n)REP(j,g[i].size())flow[i].push_back(g[i][j].weight);\n\tvector<Cost> dist(n);\n\tvector<int> prevv(n),preve(n);\n\tInt res=0;\n\twhile(f>0){\n\t\tfill(ALL(dist),CINF);\n\t\tdist[s]=0;\n\t\tbool update=true;\n\t\twhile(update){\n\t\t\tupdate=false;\n\t\t\tfor(int v=0;v<n;v++){\n\t\t\t\tif(dist[v]==CINF)continue;\n\t\t\t\tfor(int i=0;i<g[v].size();i++){\n\t\t\t\t\tconst Edge &e=g[v][i];\n\t\t\t\t\tif(flow[v][i]>0 && dist[e.dst]>dist[v]+cost[v][i]){\n\t\t\t\t\t\tdist[e.dst]=dist[v]+cost[v][i];\n\t\t\t\t\t\tprevv[e.dst]=v;preve[e.dst]=i;\n\t\t\t\t\t\tupdate=true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(dist[t]==CINF){\n\t\t\treturn -1;\n\t\t}\n\t\tFlow d=f;\n\t\tfor(int v=t;v!=s;v=prevv[v]){\n\t\t\td=min(d,flow[prevv[v]][preve[v]]);\n\t\t}\n\t\tf-=d;\n\t\tres+=d*dist[t];\n\t\tfor(int v=t;v!=s;v=prevv[v]){\n\t\t\tconst Edge &e=g[prevv[v]][preve[v]];\n\t\t\tflow[prevv[v]][preve[v]]-=d;\n\t\t\tflow[v][e.rev]+=d;\n\t\t}\n\t}\n\treturn res;\n}\n//}}}\n\nconst int SMAX=10000;\nint pdiv[SMAX];\nvector<int> primes;\n//{{{ eratosthenes\nvoid sieve_of_eratosthenes(int n) {\n\tfor (int i = 2; i < n; ++i)\n\t\tpdiv[i] = i;\n\tfor (int i = 2; i*i < n; ++i)\n\t\tif (pdiv[i]==i)\n\t\t\tfor (int j = i*i; j < n; j+=i)\n\t\t\t\tpdiv[j] = i;\n}\n//}}}\nbool is_prime(int n){\n\tif(n==1)return false;\n\tfor(int i=0;;i++){\n\t\tint p = primes[i];\n\t\tif(p*p>n)break;\n\t\tif(n%p==0)return false;\n\t}\n\treturn true;\n}\n\nvoid solve(long long N, vector<long long> x){\n\tvector<int> v0,v1;\n\tfor(int i=0;i<x.size();){\n\t\tint j;\n\t\tfor(j=i+1;j<x.size();j++){\n\t\t\tif(x[j-1]+1!=x[j])break;\n\t\t}\n\t\t//[ x[i], x[j-1]+1 )\n\t\tauto v({x[i],x[j-1]+1});\n\t\tfor(auto u:v){\n\t\t\tif(u%2==0)v0.push_back(u);\n\t\t\telse v1.push_back(u);\n\t\t}\n\t\ti = j;\n\t}\n\tGraph g(v0.size()+v1.size()+2);\n\tvector<vector<Cost> > cost(g.size(),vector<Cost>());\n\tint s = v0.size() + v1.size(), t = s + 1;\n\tREP(i,v0.size())REP(j,v1.size()){\n\t\tif(is_prime(abs(v0[i]-v1[j]))){\n\t\t\taddFlowEdge(g,cost,i,j+v0.size(),10000,1);\n\t\t}else{\n\t\t\taddFlowEdge(g,cost,i,j+v0.size(),10000,3);\n\t\t}\n\t}\n\tREP(i,v0.size())addFlowEdge(g,cost,s,i,1,0);\n\tREP(j,v1.size())addFlowEdge(g,cost,j+v0.size(),t,1,0);\n\tInt ans = INF;\n\tint r = v0.size()%2;\n\tfor(int f=r;;f+=2){\n\t\tif(v0.size()<f or v1.size()<f)break;\n\t\tCost c = minCostFlow(g,cost,s,t,f);\n\t\tc+=v0.size()+v1.size()-f*2;\n\t\tans = min(c,ans);\n\t}\n\tfout<<ans<<endl;\n}\n\nint main(){\t\n\tsieve_of_eratosthenes(SMAX);\n\tfor(int p=2;p<SMAX;p++)if(pdiv[p]==p)primes.push_back(p);\n\tlong long N;\n\tfin >> N;\n\tvector<long long> x(N-1+1);\n\tfor(int i = 0 ; i <= N-1 ; i++){\n\t\tfin >> x[i];\n\t}\n\tsolve(N, x);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <cstdio>\n#include <cmath>\nusing namespace std;\n\nconst int MaxN = 200;\nconst int MaxM = 10000000;\nconst int MaxNV = MaxN * 2;\n\nint n;\nbool f[MaxM + 1];\n\nint nL, qL[MaxNV + 1];\nint nR, qR[MaxNV + 1];\n\nbool mat[MaxNV + 1][MaxNV + 1];\n\nbool bookR[MaxNV + 1];\nint mateR[MaxNV + 1];\n\nint pri_n, pri[MaxM / 8];\nbool book[MaxM + 1];\n\ninline void init_sieve(int n = MaxM)\n{\n\tbook[1] = true;\n\tfor (int i = 2; i <= n; ++i)\n\t{\n\t\tif (!book[i])\n\t\t\tpri[pri_n++] = i;\n\n\t\tfor (int j = 0; j < pri_n; ++j)\n\t\t{\n\t\t\tint p = pri[j], d = i * p;\n\t\t\tif (d > n)\n\t\t\t\tbreak;\n\t\t\tbook[d] = true;\n\n\t\t\tif (i % p == 0)\n\t\t\t\tbreak;\n\t\t}\n\t}\n}\n\nbool match(const int &u)\n{\n\tfor (int v = 1; v <= nR; ++v)\n\t\tif (mat[u][v] && !bookR[v])\n\t\t{\n\t\t\tbookR[v] = true;\n\t\t\tif (!mateR[v] || match(mateR[v]))\n\t\t\t{\n\t\t\t\tmateR[v] = u;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\treturn false;\n}\n\nint main()\n{\n\tinit_sieve();\n\n\tcin >> n;\n\tfor (int i = 0, x; i < n; ++i)\n\t{\n\t\tcin >> x;\n\t\tf[x] = true;\n\t}\n\n\tnL = nR = 0;\n\tfor (int i = 1; i <= MaxM; ++i)\n\t\tif (f[i] != f[i - 1])\n\t\t{\n\t\t\tif (i & 1)\n\t\t\t\tqL[++nL] = i;\n\t\t\telse\n\t\t\t\tqR[++nR] = i;\n\t\t}\n\n\tfor (int i = 1; i <= nL; ++i)\n\t\tfor (int j = 1; j <= nR; ++j)\n\t\t\tif (!book[abs(qL[i] - qR[j])])\n\t\t\t\tmat[i][j] = true;\n\n\tint n_matches = 0;\n\tfor (int u = 1; u <= nL; ++u)\n\t{\n\t\tfor (int v = 1; v <= nR; ++v)\n\t\t\tbookR[v] = true;\n\n\t\tn_matches += match(u);\n\t}\n\n\tint res = n_matches;\n\tres += (nL - n_matches >> 1) << 1;\n\tres += (nR - n_matches >> 1) << 1;\n\tres += 3 * ((nL ^ n_matches) & 1);\n\n\tcout << res << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint N,M;\nconst int MAX_N = 111;\nint a[MAX_N],b[MAX_N*2],sz;\nvector<int> odd,even;\n\nvector<int> path[MAX_N*2];\nbool visit[MAX_N*2];\nint match[MAX_N*2];\n\nbool dfs(int a){\n\tif(visit[a])return false;\n\tvisit[a]=1;\n\tfor(int i=0;i<path[a].size();i++){\n\t\tint b=path[a][i];\n\t\tif(match[b]<0){\n\t\t\tmatch[b]=a;\n\t\t\treturn true;\n\t\t}else if(dfs(match[b])){\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nbool isPrime(int x){\n\tif(x==1)return false;\n\tif(x%2==0)return false; // 2 is exception\n\tfor(int i=3;i*i<=x;i+=2){\n\t\tif(x%i==0)return false;\n\t}\n\treturn true;\n}\n\nint main(){\n\t\n\tscanf(\"%d\",&N);\n\tfor(int i=1;i<=N;i++){\n\t\tscanf(\"%d\",&a[i]);\n\t}\n\ta[0]=-1;\n\ta[N+1]=1e9;\n\n\tfor(int i=1;i<=N+1;i++){\n\t\tif(a[i-1]+1<a[i]){\n\t\t\tif(i>1)b[sz++]=a[i-1]+1;\n\t\t\tif(i<=N)b[sz++]=a[i];\n\t\t}\n\t}\n\n\tfor(int i=0;i<sz;i++){\n\t\tif(b[i]%2==0)even.push_back(b[i]);\n\t\telse odd.push_back(b[i]);\n\t}\n\n\tfor(int i=0;i<even.size();i++){\n\t\tfor(int j=0;j<odd.size();j++){\n\t\t\tif(isPrime(abs(odd[j]-even[i]))){\n\t\t\t\tpath[i].push_back(j);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int i=0;i<even.size();i++){\n\t\tmatch[i]=-1;\n\t}\n\t\n\tint cnt=0;\n\tfor(int i=0;i<even.size();i++){\n\t\tfor(int j=0;j<even.size();j++)visit[j]=0;\n\t\tif(dfs(i))cnt++;\n\t}\n\n\tint z0=even.size()-cnt;\n\tint z1=odd.size()-cnt;\n\tprintf(\"%d\\n\",cnt+(z0/2+z1/2)*2+(z0%2)*3);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <algorithm>\n#include <cmath>\n#include <cstring>\n#include <complex>\n\nusing namespace std;\n\n//typedef\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long ll;\n\n#define omajinai ios::sync_with_stdio(false);cin.tie(0)\n\n//container util\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define UNIQUE(a)  (a).erase(unique((a).begin(),(a).end()),(a).end())\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(auto i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n#define RFOR(i,b,a) for(int i=(b)-1;i>=(a);--i)\n#define RREP(i,n) RFOR(i,n,0)\n\n//debug\n#define dump(x)  cerr << \"[L \" << __LINE__ << \"] \" << #x << \" = \" << (x) << \"\\n\";\n\n// i love camel\n\n/// flow\nstruct edge {int to, cap, rev;}; // rev Index\nconst int _V = 100 + 2; // _N + source + sink\nvector<edge> G[_V];\nbool used[_V];\n\nvoid addEdge(int from, int to){\n\tG[from].push_back((edge) {to, 1, G[to].size()});\n\tG[to].push_back((edge) {from, 0, G[from].size() - 1}); // rev\n}\n\nint dfs(int v, int t){\n\tif(v==t)return 1;\n\tused[v] = true;\n\tREP(i, G[v].size()){\n\t\tedge &e = G[v][i];\n\t\tif(!used[e.to] && e.cap > 0){\n\t\t\tint d = dfs(e.to, t);\n\t\t\te.cap -= d;\n\t\t\tG[e.to][e.rev].cap += d;\n\t\t\treturn d;\n\t\t}\n\t}\n\treturn 0;\n}\n\nint maxFlow(int s, int t){\n\tint flow=0;\n\twhile(true){\n\t\tmemset(used, 0, sizeof used);\n\t\tint p = dfs(s, t);\n\t\tif(!p)return flow;\n\t\tflow += p;\n\t}\n}\n\n///\n\nbool isPrime(int x){ // exclusive 2\n\tif(x < 3)return false;\n\tfor(int i=3;i*i<=x;i++){\n\t\tif(x%i==0)return false;\n\t}\n\treturn true;\n}\n\nVI diff_odd, diff_even;\nint main() {\n\tint n;\n\tcin >> n;\n\tint last=-1;\n#define ADD(a) ((a)%2 ? diff_odd : diff_even).push_back(a)\n\tREP(i, n){\n\t\tint x;\n\t\tcin >> x;\n\t\tif(x!=last+1){ // not 隣接\n\t\t\tADD(x-1);\n\t\t\tif(last>0)ADD(last);\n\t\t}\n\t\tlast = x;\n\t}\n\tADD(last);\n\tREP(i, diff_odd.size())addEdge(100, i);\n\tREP(j, diff_even.size())addEdge(j + diff_odd.size(), 101);\n\tREP(i, diff_odd.size()){\n\t\tREP(j, diff_even.size()){\n\t\t\tint o = diff_odd[i], e = diff_even[j];\n\t\t\tif(isPrime(abs(o-e)))addEdge(i, j + diff_odd.size());\n\t\t}\n\t}\n\tint ans, k = ans = maxFlow(100, 101);\n\tans += (diff_odd.size() - k)/2*2;\n\tans += (diff_even.size() - k)/2*2;\n\tans += (diff_odd.size() - k) % 2 * 3;\n\tcout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint n,b,ans=0;\nint a[105],f[105][105];\nint x[2][105],cnt[2],c;\nint p[10000005],prime[3000005],tot=0;\nint vis[105],link[105];\n\nint dfs(int x){\n\tfor(int i=1;i<=cnt[1];i++){\n\t\tif(vis[i]==0&&f[x][i]==1){\n\t\t\tvis[i]=1;\n\t\t\tif(link[i]==0||dfs(link[i])){\n\t\t\t\tlink[i]=x;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint main(){\n\tscanf(\"%d\",&n);\n\ta[0]=-1;\n\tfor(int i=2;i<=10000000;i++){\n\t\tif(p[i]==0) prime[++tot]=i;\n\t\tfor(int j=1;j<=tot&&i*prime[j]<=10000000;j++){\n\t\t\tp[i*prime[j]]=1;\n\t\t\tif(i%prime[j]==0) break;\n\t\t}\n\t}\n\tp[1]=p[2]=1;\n\tfor(int i=1;i<=n;i++) scanf(\"%d\",&a[i]);\n\tfor(int i=1;i<=n;i++){\n\t\tif(a[i]==a[i-1]+1) continue;\n\t\tif(a[i-1]!=-1) x[c=(a[i-1]+1)&1][++cnt[c]]=a[i-1]+1;\n\t\tx[c=a[i]&1][++cnt[c]]=a[i];\n\t}\n\tx[c=(a[n]+1)&1][++cnt[c]]=a[n]+1;\n\tfor(int i=1;i<=cnt[0];i++){\n\t\tfor(int j=1;j<=cnt[1];j++){\n\t\t\tif(p[abs(x[0][i]-x[1][j])]==0) f[i][j]=1;\n\t\t}\n\t}\n\tfor(int i=1;i<=cnt[0];i++) if(dfs(i)) ans++;\n\tcnt[1]-=ans,cnt[0]-=ans;\n\tans+=2*(cnt[1]/2+cnt[0]/2);\n\tif(cnt[1]&1) ans+=3;\n\tprintf(\"%d\\n\",ans);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<iostream>\n#include<queue>\n#include<cmath>\nusing namespace std;\nvoid read(int &x){\n\tchar ch;bool ok;\n\tfor(ok=0,ch=getchar();!isdigit(ch);ch=getchar())if(ch=='-')ok=1;\n\tfor(x=0;isdigit(ch);x=x*10+ch-'0',ch=getchar());if(ok)x=-x;\n}\n#define rg register\nconst int maxn=210;bool vis[maxn];\nint f[maxn],n,ans,a[maxn],mp[maxn][maxn],b[maxn],tot1,tot2,x[maxn];\nbool check(int x){\n\tif(!(x&1))return 0;\n\tint n=sqrt(x);\n\tfor(rg int i=2;i<=n;i++)\n\t\tif(!(x%i))return 0;\n\treturn 1;\n}\nbool dfs(int x){\n\tfor(rg int i=1;i<=tot2;i++)\n\t\tif(!vis[i]&&mp[x][i]){\n\t\t\tvis[i]=1;\n\t\t\tif(!f[i]||dfs(f[i]))return f[i]=x,1;\n\t\t}\n\treturn 0;\n}\nint main(){\n\tread(n);\n\tfor(rg int i=1;i<=n;i++)read(x[i]);\n\tfor(rg int i=1;i<=n;i++){\n\t\tif(x[i+1]-x[i]!=1||i==n){\n\t\t\tif((x[i]+1)%2==0)a[++tot1]=x[i]+1;\n\t\t\telse b[++tot2]=x[i]+1;\n\t\t}\n\t\tif(x[i]-x[i-1]!=1||i==1){\n\t\t\tif(x[i]&1)b[++tot2]=x[i];\n\t\t\telse a[++tot1]=x[i];\n\t\t}\n\t}\n\tfor(rg int i=1;i<=tot1;i++)\n\t\tfor(rg int j=1;j<=tot2;j++)\n\t\t\tif(check(abs(a[i]-b[j])))mp[i][j]=1;\n\tfor(rg int i=1;i<=tot1;i++){\n\t\tmemset(vis,0,sizeof vis);\n\t\tif(dfs(i))ans++;\n\t}\n\tprintf(\"%d\\n\",ans+(tot1-ans)/2*2+(tot2-ans)/2*2+(tot1-ans)%2*3);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<ctime>\n#define fo(i,a,b) for(int i=a;i<=b;i++)\n#define fd(i,b,a) for(int i=b;i>=a;i--)\n#define efo(i,u,v) for(int i=BB[u],v=B[BB[u]][1];i;v=B[i=B[i][0]][1])\n#define mset(a,x) memset(a,x,sizeof(a))\nusing namespace std;\ntypedef long long ll;\ntypedef double db;\nchar ch;\nint read(){int n=0,p=1;for(ch=getchar();ch<'0' || '9'<ch;ch=getchar())if(ch=='-') p=-1;for(;'0'<=ch && ch<='9';ch=getchar()) n=n*10+ch-'0';return n*p;}\nint a[10000];\nint main()\n{\n\n\tsrand(time(0));rand();\n\tint n=100;\n\tfo(i,1,n/2) a[i]=(rand()*rand()+rand())%int(100)+1;\n\tfo(i,n/2+1,n) a[i]=(rand()*rand()+rand())%int(1000000)+1;\n\tsort(a+1,a+n+1);\n\tn=unique(a+1,a+n+1)-a-1;\n\tprintf(\"%d\\n\",n);\n\tfo(i,1,n) printf(\"%d \",a[i]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <climits>\n#include <queue>\n#include <algorithm>\n\nusing std::queue;\nusing std::min;\n\nconst int MAXX=1e7+5,MAXN=205;\nint n,cnt_x,cnt_y;\nint x_id[MAXN],y_id[MAXN];\nbool up[MAXX];\n\nstruct node{int he,iter,dis;}d[MAXN];\nstruct line{int to,nex,cap;}ed[MAXN*MAXN<<1];\n\ninline bool is_odd_prm(int x){\n\tfor(int i=2;i*i<=x;++i){\n\t\tif(x%i==0) return false;\n\t}\n\treturn true;\n}\n\ninline void addE(int u,int v,int cap){\n\tstatic int cnt=1;\n\ted[++cnt]=(line){v,d[u].he,cap};\n\td[u].he=cnt;\n}\n\ninline int revE(int i){return i^1;}\n\ninline bool BFS(int s,int t,int n){\n\tfor(int i=1;i<=n;++i)\n\t\td[i].dis=-1;\n\tstatic queue<int> q;\n\td[s].dis=0;\n\tq.push(s);\n\tint u;\n\twhile(q.size()){\n\t\tu=q.front();\n\t\tq.pop();\n\t\tfor(int i=d[u].he,v;i;i=ed[i].nex){\n\t\t\tif(ed[i].cap==0) continue;\n\t\t\tv=ed[i].to;\n\t\t\tif(d[v].dis==-1){\n\t\t\t\td[v].dis=d[u].dis+1;\n\t\t\t\tq.push(v);\n\t\t\t}\n\t\t}\n\t}\n\treturn d[t].dis!=-1;\n}\n\nint aug(int u,int rest,const int t){\n\tif(u==t) return rest;\n\tint ret=0;\n\tfor(int &i=d[u].iter,v,cap,flow;i;i=ed[i].nex){\n\t\tv=ed[i].to,cap=ed[i].cap;\n\t\tif(d[v].dis!=d[u].dis+1 || cap==0)\n\t\t\tcontinue;\n\t\tflow=aug(v,min(cap,rest),t);\n\t\ted[i].cap-=flow,ed[revE(i)].cap+=flow;\n\t\tret+=flow,rest-=flow;\n\t\tif(rest==0) return ret;\n\t}\n\tif(ret==0) d[u].dis=-1;\n\treturn ret;\n}\n\ninline int Dinic(int s,int t,int n){\n\tint ret=0;\n\twhile(BFS(s,t,n)){\n\t\tfor(int i=1;i<=n;++i)\n\t\t\td[i].iter=d[i].he;\n\t\tret+=aug(s,INT_MAX,t);\n\t}\n\treturn ret;\n}\n\ninline void build(){\n\tfor(int i=1;i<=cnt_x;++i){\n\t\tfor(int j=1,v;j<=cnt_y;++j){\n\t\t\tif(is_odd_prm(abs(x_id[i]-y_id[j]))){\n\t\t\t\tv=j+cnt_x;\n\t\t\t\taddE(i,v,INT_MAX),addE(v,i,0);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=1,s=(cnt_x+cnt_y)|1;i<=cnt_x;++i)\n\t\taddE(s,i,1),addE(i,s,0);\n\tfor(int i=1,u,t=cnt_x+cnt_y+2;i<=cnt_y;++i){\n\t\tu=cnt_x+i;\n\t\taddE(u,t,1),addE(t,u,0);\n\t}\n}\n\nint main(){\n\tscanf(\"%d\",&n);\n\tint x;\n\tfor(int i=1;i<=n;++i){\n\t\tscanf(\"%d\",&x);\n\t\tup[x]=true;\n\t}\n\tfor(int i=1;i<=x+1;++i){\n\t\tif(up[i]!=up[i-1])\n\t\t\ti&1 ? x_id[++cnt_x]=i:y_id[++cnt_y]=i;\n\t}\n\tbuild();\n\tint k=Dinic((cnt_x+cnt_y)+1,cnt_x+cnt_y+2,cnt_x+cnt_y+2);\n\tprintf(\"%d\",k+((cnt_x-k)/2+(cnt_y-k)/2)*2+3*((cnt_x-k)%2 && (cnt_y-k)%2));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pp;\ntypedef pair<ll,ll> pll;\nvoid read(int& x){ scanf(\"%d\",&x); }\nvoid read(ll& x){ scanf(\"%lld\",&x); }\ntemplate<typename T,typename... Args>\nvoid read(T& a,Args&... b){ read(a); read(b...); }\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define eb emplace_back\n#define x first\n#define y second\n \nint n;\nint p[210];\n \nvoid in(){\n\tint t; read(t);\n\tint last;\n\tread(last);\n\tp[++n] = last;\n\tfor(;--t;){\n\t\tint x; read(x);\n\t\tif(last+1 < x){\n\t\t\tp[++n] = last+1;\n\t\t\tp[++n] = x;\n\t\t}\n\t\tlast = x;\n\t}\n\tp[++n] = last+1; assert(n % 2 == 0);\n}\n \nbool is_prime(int x){\n\tif(x==1) return 0;\n\tif(x==2) return 0;\n\tfor(int i=2; i*i<=x; ++i) if(x%i==0) return 0;\n\treturn 1;\n}\nvector<int>edge[210];\nint vis[210];\nint rev[210];\n \nbool dfs(int x){\n\tif(vis[x]) return 0;\n\tvis[x]=1;\n\tfor(int y:edge[x]){\n\t\tif(!rev[y] || dfs(rev[y])){\n\t\t\trev[y]=x;\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n \nbool aug(){\n\tfor(int i=1; i<=n; ++i){\n\t\tfill(vis+1, vis+n+1, 0);\n\t\tif(dfs(i)) return 1;\n\t}\n\treturn 0;\n}\n \nint main()\n{\n\tin();\n\tint oc=0, ec=0;\n\tfor(int i=1; i<=n; ++i){\n\t\t((p[i]%2)?oc:ec)++;\n\t\tfor(int j=i+1; j<=n; ++j){\n\t\t\tif(is_prime(p[j]-p[i])){\n\t\t\t\tint a=i, b=j;\n\t\t\t\tif(p[a]%2) swap(a, b);\nassert(p[a] % 2 != p[b] % 2);\n\t\t\t\tedge[a].pb(b);\n\t\t\t}\n\t\t}\n\t}\n\tint mm = 0;\n\twhile(aug()) ++mm;\nassert(oc %2 == ec %2);\nassert(mm <= oc);\nassert(mm <= ec);\n\tint ans = 2e9;\n\tfor(int pu=0; pu<=mm; ++pu){\n\t\tint cur = 0;\n\t\tcur += (oc-pu)/2*2;\n\t\tcur += (ec-pu)/2*2;\n\t\tcur += ((oc-pu)%2)*((ec-pu)%2)*3;\n\t\tcur += pu;\n\t\tans = min(ans, cur);\n\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MAXV = 10000100;\n\nbool np[MAXV];\n\nvoid precalc() {\n   np[0] = np[1] = true;\n   for (int i = 2; i < MAXV; ++i) {\n      if (np[i]) continue;\n      for (int j = i + i; j < MAXV; j += i) {\n         np[j] = true;\n      }\n   }\n}\n\nint main() {\n   ios_base::sync_with_stdio(false);\n   precalc();\n   int N;\n   cin >> N;\n   vector<int> X(N);\n   for (int i = 0; i < N; ++i) {\n      cin >> X[i];\n   }\n   {\n      vector<int> newX;\n      newX.emplace_back(X[0]);\n      for (int i = 0; i + 1 < N; ++i) {\n         if (X[i] + 1 != X[i + 1]) {\n            newX.emplace_back(X[i] + 1);\n            newX.emplace_back(X[i + 1]);\n         }\n      }\n      newX.emplace_back(X.back() + 1);\n      X = newX;\n      N = X.size();\n   }\n   vector<int> odds;\n   vector<int> evens;\n   for (int i = 0; i < N; ++i) {\n      if (X[i] & 1) {\n         odds.emplace_back(X[i]);\n      } else {\n         evens.emplace_back(X[i]);\n      }\n   }\n   int no = odds.size();\n   int ne = evens.size();\n   vector<vector<int>> adj(no);\n   vector<int> mt(ne, -1);\n   vector<bool> visited(no);\n   for (int i = 0; i < no; ++i) {\n      for (int j = 0; j < ne; ++j) {\n         if (!np[abs(odds[i] - evens[j])]) {\n            adj[i].emplace_back(j);\n         }\n      }\n   }\n   int tt = 0;\n   function<bool(int)> dfs = [&](int v) {\n      if (visited[v] == tt) return false;\n      visited[v] = tt;\n      for (int u : adj[v]) {\n         if (mt[u] == -1) {\n            mt[u] = v;\n            return true;\n         }\n      }\n      for (int u : adj[v]) {\n         if (dfs(mt[u])) {\n            mt[u] = v;\n            return true;\n         }\n      }\n      return false;\n   };\n   int ans = 0;\n   for (int i = 0; i < no; ++i) {\n      ++tt;\n      ans += dfs(i);\n   }\n   no -= ans;\n   ne -= ans;\n   ans += 2 * (no / 2);\n   ans += 2 * (ne / 2);\n   if (no & 1) ans += 3;\n   cout << ans << \"\\n\";\n   return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<map>\nusing namespace std;\nint F[210][210], n, A[210], B[210], CA, CB, sink, v[210], cur = 1;\nmap<int,int>Map;\nbool Prime(int a){\n    if(a<0)a=-a;\n    if(a==1)return false;\n    int i;\n    for(i=2;i*i<=a;i++)if(a%i==0)return false;\n    return true;\n}\nint MaxFlow(int a){\n    if(a==sink)return 1;\n    v[a] = cur;\n    int i;\n    for(i=0;i<=sink;i++){\n        if(F[a][i] && v[i]!=cur){\n            if(MaxFlow(i)){\n                F[a][i]--;\n                F[i][a]++;\n                return 1;\n            }\n        }\n    }\n    return 0;\n}\nint main(){\n    int i, a, j, f = 0;\n    scanf(\"%d\",&n);\n    for(i=1;i<=n;i++){\n        scanf(\"%d\",&a);\n        Map[a]++;\n        Map[a+1]++;\n    }\n    for(auto &p : Map){\n        if(p.second%2 == 1){\n            if(p.first%2 == 0) A[++CA] = p.first;\n            else B[++CB] = p.first;\n        }\n    }\n    sink = CA+CB+1;\n    for(i=1;i<=CA;i++){\n        for(j=1;j<=CB;j++){\n            if(Prime(B[j]-A[i])){\n                F[i][CA+j] = 1;\n            }\n        }\n        F[0][i]=1;\n    }\n    for(i=CA+1;i<=CA+CB;i++)F[i][sink]=1;\n    while(MaxFlow(0)){\n        f++,cur++;\n    }\n    printf(\"%d\\n\", f + (CA-f)/2*2 + (CB-f)/2*2 + (CA-f)%2*3);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <algorithm>\n#include <cstdio>\n#include <cmath>\n#include <set>\n#include <map>\n#include <queue>\n#include <string>\n#include <cstring>\n#include <bitset>\n#include <functional>\n#include <random>\n#define REP(i,a,n) for(int i=a;i<=n;++i)\n#define PER(i,a,n) for(int i=n;i>=a;--i)\n#define hr putchar(10)\n#define pb push_back\n#define lc (o<<1)\n#define rc (lc|1)\n#define mid ((l+r)>>1)\n#define ls lc,l,mid\n#define rs rc,mid+1,r\n#define x first\n#define y second\n#define io std::ios::sync_with_stdio(false)\n#define endl '\\n'\n#define DB(a) ({REP(__i,1,n) cout<<a[__i]<<' ';hr;})\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int P = 1e9+7, INF = 0x3f3f3f3f;\nll gcd(ll a,ll b) {return b?gcd(b,a%b):a;}\nll qpow(ll a,ll n) {ll r=1%P;for (a%=P;n;a=a*a%P,n>>=1)if(n&1)r=r*a%P;return r;}\nll inv(ll x){return x<=1?1:inv(P%x)*(P-P/x)%P;}\ninline int rd() {int x=0;char p=getchar();while(p<'0'||p>'9')p=getchar();while(p>='0'&&p<='9')x=x*10+p-'0',p=getchar();return x;}\n//head\n\n\n\nconst int N = 1e6+20;\nint n;\nvector<int> g[N], h[N];\n\nint dfs(int x, int f, int d) {\n\th[x].clear();\n\tfor (int y:g[x]) if (y!=f) h[x].pb(dfs(y,x,d));\t\n\tif (h[x].size()%2==0) h[x].pb(0);\n\tif (h[x].size()==1) return h[x][0]+1;\n\tsort(h[x].begin(),h[x].end());\n\tint sz=h[x].size(),l=0,r=sz-1,ans=-1;\n\twhile (l<=r) {\n\t\tint ql=0,qr=sz-1,ok=1;\n\t\twhile (1) {\n\t\t\tif (ql==mid) ++ql;\n\t\t\tif (qr==mid) --qr;\n\t\t\tif (ql>qr) break;\n\t\t\tif (h[x][ql]+h[x][qr]>d) ok=0;\n\t\t\t++ql,--qr;\n\t\t}\n\t\tif (ok) ans=mid,r=mid-1;\n\t\telse l=mid+1;\n\t}\n\treturn ans<0?INF:h[x][ans]+1; \n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tREP(i,2,n) {\n\t\tint u, v;\n\t\tscanf(\"%d%d\", &u, &v);\n\t\tg[u].pb(v),g[v].pb(u);\n\t}\n\tint cnt = 0, rt = 0;\n\tREP(i,1,n) if (g[i].size()&1) rt = i, ++cnt;\n\tcnt /= 2;\n\tint l = 0, r = n-1, ans;\n\twhile (l<=r) {\n\t\tif (dfs(rt,0,mid)<=mid+1) ans=mid,r=mid-1;\n\t\telse l=mid+1;\n\t}\n\tprintf(\"%d %d\\n\", cnt, ans);\n}\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nconst int N=1e7+10;\nusing namespace std;\ninline int gi(){\n  char ch=getchar();int x=0,q=0;\n  while(ch<'0' || ch>'9') ch=='-'?q=1:0,ch=getchar();\n  while(ch>='0' && ch<='9') x=x*10+ch-'0',ch=getchar();\n  return q?(-x):x;\n}\nint mark[N],pri[N],tot,P=1e7+1,n,m,g[N];\nint c[105][105],bl[105],vis[105],a[105],b[105];\nvoid pre(){\n  for (int i=2,s; i<=P; ++i){\n    if (!mark[i]) pri[++tot]=i;\n    for (int j=1; j<=tot&&(s=i*pri[j])<=P; ++j){\n      mark[s]=1;\n      if (i%pri[j]==0) break;\n    }\n  }\n  return;\n}\nint dfs(int x){\n  for (int i=1; i<=m; ++i)\n    if (c[x][i]&&!vis[i]){\n      vis[i]=1;\n      if (!bl[i]||dfs(bl[i]))\n\treturn bl[i]=x;\n    }\n  return 0;\n}\nint main(){\n  int p=gi(),s;\n  pre();\n  for (int i=1; i<=p; ++i)\n    g[gi()]=1;\n  for (int i=P; i>=1; --i)\n    g[i]^=g[i-1];\n  for (int i=1; i<=P; ++i)\n    if (g[i]){\n      if (i&1) a[++n]=i;\n      else b[++m]=i;\n    }\n  for (int i=1; i<=n; ++i)\n    for (int j=1; j<=m; ++j){\n      s=abs(a[i]-b[j]);\n      if (s!=1&&!mark[s])\n\tc[i][j]=1;\n    }\n  int ans=0;\n  for (int i=1; i<=n; ++i){\n    memset(vis,0,sizeof(vis));\n    if (dfs(i)) ++ans;\n  }\n  cout<<ans+(n-ans)/2*2+(m-ans)/2*2+((n&1)||(m&1))*3;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <cstdio>\n#include <algorithm>\n#include <cmath>\n#define maxn 10005\n#define maxm 10000005\n#define Rint register int\n#define INF 0x3f3f3f3f\nusing namespace std;\ntypedef long long lxl;\n\ntemplate <typename T>\ninline void read(T &x)\n{\n\tx=0;T f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9') {if(ch=='-') f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9') {x=(x<<1)+(x<<3)+ch-'0';ch=getchar();}\n\tx*=f;\n}\n\nint prime[maxm],cnt;\nbool flag[maxm];\n\ninline void sieve()\n{\n\tfor(int i=2;i<maxm;++i)\n\t{\n\t\tif(!flag[i]) prime[++cnt]=i;\n\t\tfor(int j=1;j<=cnt&&i*prime[j]<maxm;++j)\n\t\t{\n\t\t\tflag[i*prime[j]]=true;\n\t\t\tif(!(i%prime[j])) break;\n\t\t}\n\t}\n\tflag[1]=flag[2]=true;\n}\n\nstruct edge\n{\n\tint u,v,next;\n\tedge(int u,int v,int next):u(u),v(v),next(next){}\n\tedge(){}\n}e[maxn<<1];\n\nint head[maxn],k;\n\ninline void add(int u,int v)\n{\n\te[k]=edge(u,v,head[u]);\n\thead[u]=k++;\n}\n\nint n;\nint a[maxn],f[maxm],L[maxn],R[maxn];\nint match[maxn];\nbool vis[maxn];\n\ninline int findpath(int u)\n{\n\tfor(int i=head[u];~i;i=e[i].next)\n\t{\n\t\tint v=e[i].v;\n\t\tif(!vis[v])\n\t\t{\n\t\t\tvis[v]=true;\n\t\t\tif(!match[v]||findpath(match[v]))\n\t\t\t{\n\t\t\t\tmatch[v]=u;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\ninline int Hungary()\n{\n\tint res=0;\n\tfor(int i=1;i<=L[0];++i)\n\t{\n\t\tmemset(vis,0,sizeof(vis));\n\t\tres+=findpath(i);\n\t}\n\treturn res;\n}\n\nint main()\n{\n\tsieve();\n\tread(n);\n\tint up=0;\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tread(a[i]);\n\t\t++f[a[i]];\n\t\tup=max(up,a[i]);\n\t}\n\tfor(int i=1;i<=up+1;++i)\n\t\tif(f[i]!=f[i-1])\n\t\t{\n\t\t\tif(i&1) L[++L[0]]=i;\n\t\t\telse R[++R[0]]=i;\n\t\t}\n\tmemset(head,-1,sizeof(head));\n\tfor(int i=1;i<=L[0];++i)\n\t\tfor(int j=1;j<=R[0];++j)\n\t\t\tif(!flag[abs(L[i]-R[j])])\n\t\t\t\tadd(i,j);\n\tint maxmatch=Hungary();\n\tint ans=maxmatch;\n\tans+=(L[0]-maxmatch)/2*2+(R[0]-maxmatch)/2*2;\n\tans+=((L[0]-maxmatch)&1)*3;\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <cstdio>\n#include <cmath>\nusing namespace std;\n\nconst int MaxN = 200;\nconst int MaxM = 10000000;\nconst int MaxNV = MaxN * 2;\n\nint n;\nbool f[MaxM + 2];\n\nint nL, qL[MaxNV + 1];\nint nR, qR[MaxNV + 1];\n\nbool mat[MaxNV + 1][MaxNV + 1];\n\nbool bookR[MaxNV + 1];\nint mateR[MaxNV + 1];\n\nint pri_n, pri[MaxM / 8];\nbool book[MaxM + 2];\n\ninline void init_sieve(int n = MaxM + 1)\n{\n\tbook[1] = true;\n\tfor (int i = 2; i <= n; ++i)\n\t{\n\t\tif (!book[i])\n\t\t\tpri[pri_n++] = i;\n\n\t\tfor (int j = 0; j < pri_n; ++j)\n\t\t{\n\t\t\tint p = pri[j], d = i * p;\n\t\t\tif (d > n)\n\t\t\t\tbreak;\n\t\t\tbook[d] = true;\n\n\t\t\tif (i % p == 0)\n\t\t\t\tbreak;\n\t\t}\n\t}\n}\n\nbool match(const int &u)\n{\n\tfor (int v = 1; v <= nR; ++v)\n\t\tif (mat[u][v] && !bookR[v])\n\t\t{\n\t\t\tbookR[v] = true;\n\t\t\tif (!mateR[v] || match(mateR[v]))\n\t\t\t{\n\t\t\t\tmateR[v] = u;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\treturn false;\n}\n\nint main()\n{\n\tinit_sieve();\n\n\tcin >> n;\n\tfor (int i = 0, x; i < n; ++i)\n\t{\n\t\tcin >> x;\n\t\tf[x] = true;\n\t}\n\n\tnL = nR = 0;\n\tfor (int i = 1; i <= MaxM + 1; ++i)\n\t\tif (f[i] != f[i - 1])\n\t\t{\n\t\t\tif (i & 1)\n\t\t\t\tqL[++nL] = i;\n\t\t\telse\n\t\t\t\tqR[++nR] = i;\n\t\t}\n\n\tfor (int i = 1; i <= nL; ++i)\n\t\tfor (int j = 1; j <= nR; ++j)\n\t\t\tif (!book[abs(qL[i] - qR[j])])\n\t\t\t\tmat[i][j] = true;\n\n\tint n_matches = 0;\n\tfor (int u = 1; u <= nL; ++u)\n\t{\n\t\tfor (int v = 1; v <= nR; ++v)\n\t\t\tbookR[v] = true;\n\n\t\tn_matches += match(u);\n\t}\n\n\tint res = n_matches;\n\tres += (nL - n_matches >> 1) << 1;\n\tres += (nR - n_matches >> 1) << 1;\n\tres += 3 * ((nL ^ n_matches) & 1);\n\n\tcout << res << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define inf 1e9\nusing namespace std;\nstruct node{\n\tint nxt,to,weigh;\n}edge[400010];\nint head[100100],n,S,T,cnt=1,level[100100];\nint a[10010],b[10010],c[10001000],sum,tot,ans;\nqueue<int> qu;\nbool check(int a){\n\tif(a<=2)return false; \n\tfor(int i=2;i<=sqrt(a);i++)\n\t\tif(a%i==0)return false;\n\treturn true;\n}\nvoid addedge(int x,int y,int z){\n\tedge[++cnt].nxt=head[x];\n\tedge[cnt].to=y;\n\tedge[cnt].weigh=z;\n\thead[x]=cnt;\n\tedge[++cnt].nxt=head[y];\n\tedge[cnt].to=x;\n\tedge[cnt].weigh=0;\n\thead[y]=cnt;\t\n}\nbool bfs(){\n\tmemset(level,-1,sizeof(level));\n\tlevel[S]=0;\n\tqu.push(S);\n\twhile(!qu.empty()){\n\t\tint u=qu.front();\n\t\tqu.pop();\n\t\tfor(int i=head[u];i;i=edge[i].nxt){\n\t\t\tint upup=edge[i].to;\n\t\t\tif(edge[i].weigh!=0 && level[upup]==-1){\n\t\t\t\tlevel[upup]=level[u]+1;\n\t\t\t\tqu.push(upup);\n\t\t\t}\n\t\t}\n\t}\n\tif(level[T]==-1)return false;\n\treturn true;\n}\nint dfs(int x,int flow){\n\tif(x==T)return flow;\n\tint rest=0;\n\tfor(int i=head[x];i;i=edge[i].nxt){\n\t\tint upup=edge[i].to;\n\t\tif(rest==flow)break;\n\t\tif(level[upup]==level[x]+1){\n\t\t\tint sum=dfs(upup,min(flow-rest,edge[i].weigh));\n\t\t\trest+=sum,edge[i].weigh-=sum;edge[i^1].weigh+=sum;\n\t\t}\n\t} \n\treturn rest;\n}\nint Dinic(){\n\tint ans=0;\n\twhile(bfs())\n\t\tans+=dfs(S,inf);\n\treturn ans;\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++){\n\t\tscanf(\"%d\",&a[i]);\n\t\tc[a[i]]=1;\n\t}\n\tfor(int i=1;i<=10000000;i++)\n\t\tif(c[i]!=c[i-1])\n\t\t\tb[++sum]=i;\n\tS=0,T=sum+1;\n\tfor(int i=1;i<=sum;i++)\n\t\tif(b[i]&1){\n\t\t\ttot++;\n\t\t\taddedge(S,i,1);\n\t\t\tfor(int j=1;j<=sum;j++)\n\t\t\t\tif(!(b[j]&1)&&check(abs(b[j]-b[i])))\n\t\t\t\t\taddedge(i,j,1);\n\t\t}\n\t\telse addedge(i,T,1);\n\tans=Dinic();\n\tprintf(\"%d\\n\",sum-ans+(tot-ans)%2);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define abs abs_\ninline int abs(int x){return x<0?-x:x;} \ninline bool chk(int n){if(n<=2)return false;for(int d=2;d*d<=n;d++)if(n%d==0)return false;return true;}\n\nconst int N=233,M=23333,inf=1e9;\n\nint S,T,h[N],nxt[M],to[M],flow[M],cnt=1,qu[N],ql,qr,d[N];\nvoid addedge(int u,int v,int c){\n\tto[++cnt]=v,nxt[cnt]=h[u],h[u]=cnt,flow[cnt]=c;\n\tto[++cnt]=u,nxt[cnt]=h[v],h[v]=cnt,flow[cnt]=0;\n}\nbool bfs(){\n\tfor(int i=S;i<=T;i++)d[i]=-1;\n\td[S]=0,qu[ql=qr=1]=S;\n\twhile(ql<=qr){\n\t\tint u=qu[ql++];\n\t\tfor(int i=h[u],v;i;i=nxt[i])if(d[v=to[i]]==-1&&flow[i])d[v]=d[u]+1,qu[++qr]=v;\n\t\tif(d[T]!=-1)break;\n\t}\n\treturn d[T]!=-1;\n}\nint dfs(int u,int mf){\n\tif(u==T)return mf;\n\tint r=0,p;\n\tfor(int i=h[u],v;i;i=nxt[i])if(d[v=to[i]]==d[u]+1&&flow[i])\n\t\tp=dfs(v,min(mf,flow[i])),flow[i]-=p,flow[i^1]+=p,r+=p,mf-=p; \n\treturn r;\n}\nint dinic(){\n\tint r=0;\n\twhile(bfs())r+=dfs(S,inf);\n\treturn r;\n}\n\nint n,m1,m2,odd[N],even[N];\nset<int> dat;\n\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=1,x;i<=n;i++){\n\t\tscanf(\"%d\",&x);\n\t\tif(dat.count(x))dat.erase(x);else dat.insert(x);\n\t\tx++;\n\t\tif(dat.count(x))dat.erase(x);else dat.insert(x);\n\t}\n\tfor(int x:dat)if(x&1)odd[++m1]=x;else even[++m2]=x;\n\tT=m1+m2+1;\n\tfor(int i=1;i<=m1;i++)addedge(S,i,1);\n\tfor(int i=1;i<=m2;i++)addedge(i+n,T,1);\n\tfor(int i=1;i<=m1;i++)for(int j=1;j<=m2;j++)\n\t\tif(chk(abs(odd[i]-even[j])))addedge(i,j+n,1);\n\tint mch=dinic(),ans=m1+m2-mch+((m1-mch)&1);\n\tprintf(\"%d\\n\",ans); \n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N;\nll X[101];\nint memo[101][101];\n\nbitset<1<<24> did,pr;\n\nint prime(int x) {\n\tif(x<=2) return 0;\n\tif(did[x]) return pr[x];\n\tdid[x]=1;\n\t\n\tfor(int a=2;a*a<=x;a++) {\n\t\tif(x%a==0) return pr[x]=0;;\n\t}\n\treturn pr[x]=1;\n}\n\n\nint hoge(int L,int R) {\n\tif(R<=L) return 0;\n\tif(memo[L][R]>=0) return memo[L][R];\n\tif(L+1==R) return memo[L][R]=2;\n\t\n\tint ret=101010;\n\tfor(int x=L+1;x<R;x++) ret=min(ret,hoge(L,x)+hoge(x,R));\n\t\n\tint ok=1,step=0;\n\tfor(int i=L;i<R-1;i++) if(X[i+1]-X[i]!=1) {\n\t\tif(prime(X[i+1]-X[i]-1)) step++;\n\t\telse ok=0;\n\t}\n\t\n\tif(ok==1) {\n\t\tint len=X[R-1]-X[L]+1;\n\t\tif(len%2==0) ret=min(ret,2+step);\n\t\telse ret=min(ret,3+step);\n\t}\n\t\n\t\n\treturn memo[L][R]=ret;\n\t\n\t\n}\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N;\n\tFOR(i,N) cin>>X[i];\n\t\n\tMINUS(memo);\n\tcout<<hoge(0,N)<<endl;\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n';\n\tFOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tsolve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<bitset>\n#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<string>\n#include<stack>\n#define REP(i,x,y) for(ll i=x;i<=y;i++)\n#define SIZE(a) ll(a.size())\n#define vll vector<ll> \n#define MEMSET(a, n, m) for(ll i=0;i<=n;i++) a[i] = m\n#define BIT(n) (ll(1)<<n)\n#define UNIQUE(v) v.erase(unique(v.begin(),v.end()),v.end()) \n#define UNIQUE_ARRAY(a,n) n = unique(a + 1, a + x + 1) - a - 1\n#define SORT(a,n) sort(a+1,a+n+1)\n#define SORT_O(a,n,order) sort(a+1,a+n+1,order)\n#define PER(i,y,x) for(ll i=y;i>=x;i--)\ntypedef long long ll;\nusing namespace std;\n/*\nstruct point\n{\nlong long dist; long long name;\nbool operator<(const point& rhs) const {\nreturn dist > rhs.dist;\n}\n};\n*/\n\nmap<ll, ll> mp;\n\nbool is_prime(ll x) {\n\tif (x == 1) return false;\n\tfor (ll i = 2; i*i <= x; i++) {\n\t\tif (x%i == 0) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\nll times(ll x) {\n\tll t = mp[x];\n\tif (t != 0) {\n\t\treturn t;\n\t}\n\telse {\n\t\tif (x % 2 == 0) {\n\t\t\tmp[x] = 2;\n\t\t\treturn 2;\n\t\t}\n\t\telse {\n\t\t\tif (is_prime(x)) {\n\t\t\t\tmp[x] = 1;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tmp[x] = 3;\n\t\t\t\treturn 3;\n\t\t\t}\n\t\t}\n\t}\n}\n\nll const MAX = 1005;\n\nll a[MAX];\nll b[MAX];\nll c[MAX];\nll dp[MAX][MAX];\n\nll f_dp(ll i, ll j) {\n\tif (i < j) {\n\t\treturn 0;\n\t}\n\telse {\n\t\treturn dp[i][j];\n\t}\n}\n\nint main() {\n\tll n;\n\tcin >> n;\n\tREP(i, 1, n) {\n\t\tcin >> a[i];\n\t}\n\tSORT(a, n);\n\tll v = 1;\n\tll cnt = 1;\n\tb[1] = 1;\n\tREP(i, 2, n) {\n\t\tif (a[i] == a[i - 1] + 1) {\n\t\t\tb[cnt]++;\n\t\t}\n\t\telse {\n\t\t\tcnt++;\n\t\t\tb[cnt] = a[i] - a[i - 1] - 1;\n\t\t\tcnt++;\n\t\t\tb[cnt] = 1;\n\t\t}\n\t}\n\tll m = cnt;\n\tc[0] = 0;\n\tREP(i, 1, m) {\n\t\tc[i] = b[i] + c[i - 1];\n\t}\n\t\n\t\n\tREP(i, 1, m) {\n\t\tdp[i][i] = times(b[i]);\n\n\t\tfor (ll j = i - 2; j >= 1; j -= 2) {\n\t\t\tll t = 10000000000;\n\t\t\tfor (ll k = i; k >= j; k -= 2) {\n\t\t\t\tll cnt = 0;\n\t\t\t\tcnt += times(c[i] - c[k - 1]);\n\t\t\t\t//cout << i << \" \" << j << \" \" << k << \" \";\n\t\t\t\t//cout << cnt << \" \";\n\t\t\t\tcnt += f_dp(i - 1, k + 1) + f_dp(k - 2, j);\n\t\t\t\t//cout << f_dp(i - 1, k + 1) << \" \" << f_dp(k - 2, j) << endl;\n\t\t\t\tt = min(cnt, t);\n\t\t\t}\n\t\t\tdp[i][j] = t;\n\t\t}\n\t}\n\t/*\n\tREP(i, 1, m) {\n\t\tREP(j, 1, m) {\n\t\t\tcout << dp[i][j] << \" \";\n\t\t}\n\t\tcout << endl;\n\t}\n\t*/\n\tcout << dp[m][1] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "// arc080_f\n#include <bits/stdc++.h>\n#ifdef LOCAL\n#include \"../cxx-prettyprint/prettyprint.hpp\"\n#endif\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\n\n#define REP(i, n) for (int (i) = 0 ; (i) < (int)(n) ; ++(i))\n#define REPN(i, m, n) for (int (i) = m ; (i) < (int)(n) ; ++(i))\n#define REP_REV(i, n) for (int (i) = (int)(n) - 1 ; (i) >= 0 ; --(i))\n#define REPN_REV(i, m, n) for (int (i) = (int)(n) - 1 ; (i) >= m ; --(i))\n#define ALL(x) x.begin(), x.end()\n\n#define INF ((1 << 29)-1)\n#define MOD (1000000007)\n\n#define print2D(h, w, arr) REP(i, h) { REP(j, w) cout << arr[i][j] << \" \"; cout << endl; }\n#define print_line(vec, n) {for(int i=0;i<(n-1);i++) cout << (vec)[i] << \" \"; cout << (vec)[(n)-1] << endl;}\ntemplate<class T> void print(const T& x){cout << x << endl;}\ntemplate<class T, class... A> void print(const T& first, const A&... rest) { cout << first << \" \"; print(rest...); }\nstruct PreMain {PreMain(){cin.tie(0);ios::sync_with_stdio(false);cout<<fixed<<setprecision(20);}} premain;\n\n// dinic\ntemplate <typename T = long long>\nstruct Dinic {\n    struct edge { int to; T cap; int rev; };\n    vector<vector<edge>> G;\n    vector<int> itr, level;\n    int n;\n    T inf;\n\n    explicit Dinic(int n): n(n), G(n) {inf=numeric_limits<T>::max();}\n\n    void add_edge(int from, int to, T cap) {\n        G[from].push_back((edge) {to, cap, (int) G[to].size()});\n        G[to].push_back((edge) {from, 0, (int) G[from].size()-1});\n    }\n\n    void bfs(int s) {\n        level.assign(n, -1);\n        queue<int> q;\n        level[s] = 0;\n        q.push(s);\n        while (!q.empty()) {\n            int v = q.front();\n            q.pop();\n            for (auto &e: G[v]) {\n                if (e.cap > 0 and level[e.to] < 0) {\n                    level[e.to] = level[v] + 1;\n                    q.push(e.to);\n                }\n            }\n        }\n    }\n\n    T dfs(int v, int t, T f) {\n        if (v == t) return f;\n        for (int& i = itr[v]; i < (int) G[v].size(); ++i) {\n            edge& e = G[v][i];\n            if (e.cap > 0 and level[v] < level[e.to]) {\n                T d = dfs(e.to, t, min(f, e.cap));\n                if (d > 0) {\n                    e.cap -= d;\n                    G[e.to][e.rev].cap += d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n\n    T max_flow(int s, int t) {\n        T ret = 0, f;\n        while (bfs(s), level[t] >= 0) {\n            itr.assign(n, 0);\n            while ((f = dfs(s, t, inf)) > 0) ret += f;\n        }\n        return ret;\n    }\n};\n\nbool is_prime(int n){\n    for (int a=2; a*a <= n; a++) if (n % a == 0) return false;\n    return true;\n}\n\nint main() {\n#ifdef LOCAL\n    ifstream in(\"../arg.txt\"); cin.rdbuf(in.rdbuf());\n#endif\n\n    int N;\n    cin >> N;\n    vector<int> X(N);\n    REP(i, N) cin >> X[i];\n    sort(ALL(X));\n\n    vector<int> M;\n    REP(i, N){\n        M.emplace_back(X[i]);\n        while (i < N-1 && X[i]+1 == X[i+1]) i++;\n        M.emplace_back(X[i]+1);\n    }\n\n    int m = M.size();\n    Dinic<> flow(m+2);\n    int s = m, t = s+1;\n\n    int me=0, mo=0;\n    REP(i, m) {\n\n        if (M[i] % 2 == 0) {\n            flow.add_edge(s, i, 1);\n            me++;\n\n            REP(j, mo){\n                int diff = abs(M[i] - M[j]);\n                if (diff >= 3 && is_prime(diff)){\n                    flow.add_edge(i, j, 1);\n                }\n            }\n\n        } else {\n            flow.add_edge(i, t, 1);\n            mo++;\n        }\n    }\n\n    int k = flow.max_flow(s, t);\n\n    int ans = 0;\n    ans += k;\n    ans += ((me-k)/2 + (mo-k)/2) * 2;\n    ans += (me-k) % 2 == 0 ? 0 : 3;\n\n    print(ans);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define pb push_back\n\nusing namespace std;\n\nconst int MX = 10000001;\n\nint n , a, x[MX + 1], visId, match[300], vis[300];\nbool b[MX + 1], np[MX + 1];\nvector<int> me, mo, g[300];\n\nbool dfs(int u) {\n\tvis[u] = visId;\n\tfor (int i = 0 ; i < g[u].size(); ++i) {\n\t\tint v = g[u][i];\n\t\tif (match[v] == -1 || vis[match[v]] != visId && dfs(match[v])) {\n\t\t\tmatch[v] = u;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n\n}\nint main() {\n\tfor (int i = 2; i <= MX; ++i) {\n\t\tif (np[i])continue;\n\t\tfor (int j = i + i; j <= MX ; j+=i){\n\t\t\tnp[j] = 1;\n\t\t}\n\t}\n\tnp[0] = np[1] = np[2] = 1;\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; ++i) {\n\t\tscanf(\"%d\", &a);\n\t\tx[a] = 1;\n\t}\n\tfor (int i = 1; i <= MX ; ++i) {\n\t\tb[i] = x[i] != x[i - 1];\n\t\tif (b[i] && (i % 2 == 0))me.pb(i);\n\t\tif (b[i] && (i % 2 == 1))mo.pb(i);\n\t}\n\tfor (int i = 0; i < me.size(); ++i) {\n\t\tfor (int j = 0 ; j < mo.size(); ++j) {\n\t\t\tif (!np[abs(me[i] - mo[j])]) {\n\t\t\t\tg[i].pb(j);\n\t\t\t}\n\t\t}\n\t}\n\tassert((me.size()+mo.size())%2 == 0);\n\tint res = 0;\n\tmemset(match,-1,sizeof match);\n\tfor (int i = 0; i < me.size(); ++i) {\n\t\tvisId++;\n\t\tif (dfs(i))res++;\n\t}\n\tint even = me.size() - res;\n\tint odd = mo.size() - res;\n\tint ans = res + (even / 2) * 2 + (odd / 2) * 2 + (odd%2)*3;\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nvector<int> pr, pchk;\nvoid getPrime() {\n    pchk = vector<int>(10000010, 0);\n    for(int i = 2; i < 10000010; i++) {\n        if(pchk[i]) continue;\n        int mul = 2;\n        while(i * mul < 10000010) {\n            pchk[i * mul] = 1;\n            mul++;\n        }\n    }\n}\n\nint N;\nvector<int> X;\n\nvector<vector<int> > cc;\nint dp(int l, int r) {\n    int &ret = cc[l][r];\n    if(ret != -1) return ret;\n\n\n    int pre = X[l];\n    int tmp = 0;\n    for(int i = l + 1; i <= r + 1; i++) {\n        if(i == r + 1 || X[i - 1] + 1 != X[i]) {\n            tmp += (pchk[ X[i - 1] - pre + 1 ]? (((X[i - 1] - pre + 1) % 2)? 3 : 2) : 1);\n            if(i != r + 1) pre = X[i];\n        }\n    }\n    ret = tmp;\n    pre = 1;\n    tmp = 0;\n    for(int i = l; i <= r; i++) {\n        tmp += (X[i] - pre) % 2 == 0? (X[i] - pre == 0? 0 : 2) : (pchk[ X[i] - pre ]? 3 : 1);\n        pre = X[i] + 1;\n    }\n    if(pchk[ X[r] ]) tmp += (X[r] % 2 == 0? 2 : 3);\n    else tmp++;\n\n    ret = min(ret, tmp);\n    for(int i = l; i < r; i++) {\n        ret = min(ret, dp(l, i) + dp(i + 1, r));\n    }\n    return ret;\n}\n\nint main() {\n    getPrime();\n\n    scanf(\"%d\", &N);\n    X.resize(N);\n    for(int i = 0; i < N; i++) {\n        scanf(\"%d\", &X[i]);\n    }\n\n    cc = vector<vector<int> >(N, vector<int>(N, -1));\n    cout<<dp(0, N - 1);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int maxm=1e7+10,maxn=210;\nint n,a[maxn],b[maxn],m,ans;\nint b1[maxn],b2[maxn],p1,p2;\nbool np[maxm],vis[maxn],g[maxn][maxn],s[maxm];\nint match[maxn];\nvector<int> p;\n\nvoid init(){\n\tnp[0]=np[1]=1;\n\tfor(int i=2;i<maxm;++i){\n\t\tif(!np[i]){\n\t\t\tp.push_back(i);\n\t\t\t//cerr<<i<<endl;\n\t\t\t//system(\"pause\");\n\t\t}\n\t\tfor(int j=0,j_end=p.size(),x;j<j_end&&(x=p[j]*i)<maxm;++j){\n\t\t\tnp[x]=true;\n\t\t\tif(i%p[j]==0)break;\n\t\t}\n\t}\n\tnp[2]=1;\n}\n\nbool dfs(int u){\n\tfor(int i=1;i<=p2;++i)if(g[u][i]&&!vis[i]){\n\t\tvis[i]=1;\n\t\tif(!match[i]||dfs(match[i])){\n\t\t\tmatch[i]=u;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\nvoid solve(){\n\tinit();\n\tcin>>n;\n\tfor(int i=1;i<=n;++i){cin>>a[i];s[a[i]]=1;}\n\tfor(int i=1;i<maxm;++i){\n\t\tif(s[i]!=s[i-1])b[++m]=i;//,cerr<<b[m]<<endl;\n\t}\n\t//cerr<<m<<endl;\n\tfor(int i=1;i<=m;++i){\n\t\tif(b[i]&1)b1[++p1]=b[i];\n\t\telse b2[++p2]=b[i];\n\t}\n\t//cerr<<p1<<\" \"<<p2<<endl;\n\tfor(int i=1;i<=p1;++i){\n\t\tfor(int j=1;j<=p2;++j){\n\t\t\tif(!np[abs(b1[i]-b2[j])]){\n\t\t\t\t//cerr<<i<<\" \"<<j<<endl;\n\t\t\t\tg[i][j]=true;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor(int i=1;i<=p1;++i){\n\t\tmemset(vis,0,sizeof vis);\n\t\tif(dfs(i))++ans;//match()\n\t}\n\tp1-=ans;p2-=ans;\n\t//cerr<<ans<<endl;\n\tans+=p1/2*2+p2/2*2;\n\tans+=p1%2*3;\n\tcerr<<ans<<endl;\n\tcout<<ans<<endl;\n}\nint main(){\n\t#ifndef ONLINE_JUDGE\n\tfreopen(\"a.in\",\"r\",stdin);\n\tfreopen(\"a.out\",\"w\",stdout);\n\t#endif\n\tsolve();\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define N 1116\n#define M 111116\n#define inf 1111111116\n#define next nxt\n \nint n,k,a[M],b[M],f[M],next[M],p[N],now[N],d[N],h[N],cnt,ans;\nvector<int> x;\nqueue<int> q;\n \nvoid add(int x,int y){\n\ta[++k]=x;b[k]=y;f[k]=1;next[k]=p[x];p[x]=k;\n\ta[++k]=y;b[k]=x;f[k]=0;next[k]=p[y];p[y]=k;\n}\n \nbool travel(){\n\tmemcpy(now,p,sizeof(p));\n\tfill(d+1,d+n+3,inf);d[n+1]=0;\n\tq.push(n+1);h[n+1]=1;\n\twhile (!q.empty()){\n\t\tint x=q.front();q.pop();h[x]=0;\n\t\tfor (int t=p[x];t;t=next[t])\n\t\t\tif (f[t]&&d[x]+1<d[b[t]]){\n\t\t\t\td[b[t]]=d[x]+1;\n\t\t\t\tif (!h[b[t]]) q.push(b[t]),h[b[t]]=1;\n\t\t\t}\n\t}\n\treturn d[n+2]<inf;\n}\n \nint dinic(int x,int lmt){\n\tif (x==n+2) return lmt;int cnt=0;\n\tfor (int t=now[x];t;t=now[x]=next[t])\n\t\tif (f[t]&&d[x]<d[b[t]]){\n\t\t\tint tmp=dinic(b[t],min(f[t],lmt-cnt));\n\t\t\tf[t]-=tmp;f[t^1]+=tmp;cnt+=tmp;\n\t\t\tif (cnt==lmt) return lmt;\n\t\t}\n\treturn cnt;\n}\n \nbool check(int x){\n\tif (x%2==0||x==1) return false;\n\tfor (int i=2;i*i<=x;i++)\n\t\tif (x%i==0) return false;\n\treturn true;\n}\n \nint read(){\n\tint x=0,f=1;char ch=getchar();\n\tfor (;!isdigit(ch);ch=getchar()) if (ch=='-')  f=-f;\n\tfor (;isdigit(ch);ch=getchar()) x=x*10+ch-'0';\n\treturn x*f;\n}\n \nint main(){\n\tn=read();k=1;x.push_back(0);\n\tfor (int i=1;i<=n;i++){\n\t\tint t=read();\n\t\tif (x.back()==t) x.pop_back();\n\t\telse x.push_back(t);\n\t\tx.push_back(t+1);\n\t}\n\tn=x.size()-1;\n\tfor (int i=1;i<=n;i++)\n\t\tif (x[i]&1) add(n+1,i),cnt++;\n\t\telse {\n\t\t\tfor (int j=1;j<=n;j++)\n\t\t\t\tif (check(x[i]+x[j])) add(j,i);\n\t\t\tadd(i,n+2);\n\t\t}\n\twhile (travel()) ans+=dinic(n+1,inf);\n\tprintf(\"%d\\n\",n-ans+(cnt-ans)%2);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n\nconst int N=205;\nconst int inf=10000001;\n\nint n,prime[inf+5],match[N],a[N],b[N],a1,b1,tot;\nbool s[inf+5],not_prime[inf+5],vis[N],ma[N][N];\n\nvoid get_prime(int n)\n{\n\tfor (int i=2;i<=n;i++)\n\t{\n\t\tif (!not_prime[i]) prime[++tot]=i;\n\t\tfor (int j=1;j<=tot&&i*prime[j]<=n;j++)\n\t\t{\n\t\t\tnot_prime[i*prime[j]]=1;\n\t\t\tif (i%prime[j]==0) break;\n\t\t}\n\t}\n}\n\nbool find(int x)\n{\n\tfor (int i=1;i<=b1;i++)\n\t\tif (ma[x][i]&&!vis[i])\n\t\t{\n\t\t\tvis[i]=1;\n\t\t\tif (!match[i]||find(match[i]))\n\t\t\t{\n\t\t\t\tmatch[i]=x;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\treturn 0;\n}\n\nint main()\n{\n\tget_prime(inf);\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tint x;scanf(\"%d\",&x);\n\t\ts[x]=1;\n\t}\n\tfor (int i=1;i<=inf;i++)\n\t\tif (s[i]!=s[i-1])\n\t\t{\n\t\t\tif (i&1) a[++a1]=i;\n\t\t\telse b[++b1]=i;\n\t\t}\n\tfor (int i=1;i<=a1;i++)\n\t\tfor (int j=1;j<=b1;j++)\n\t\t\tif (!not_prime[abs(a[i]-b[j])]) ma[i][j]=1;\n\tint ans=0,tmp=0;\n\tfor (int i=1;i<=a1;i++)\n\t{\n\t\tmemset(vis,0,sizeof(vis));\n\t\tif (find(i)) tmp++,ans++;\n\t}\n\tans+=(a1-tmp)/2*2+(b1-tmp)/2*2;\n\tif (a1%2!=tmp%2) ans+=3;\n\tprintf(\"%d\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nstruct edge{\n  long to,cap,rev;//capは残りどれだけ流せるか, revはv[to][rev]が自分への逆辺を表す\n  edge(){}\n  edge(long t,long c,long r):to(t),cap(c),rev(r){}\n};\nclass flow{\n  long n;\n  vector<vector<edge>>v;\n  vector<bool>used;\n  public:\n  \n  long dfs(long s,long t,long f){\n    if(s==t)return f;\n    used[s]=1;\n    for(long i=0;i<v[s].size();i++){\n      edge e=v[s][i];\n      if(!used[e.to]&&e.cap>0){\n        long r=dfs(e.to,t,min(f,e.cap));\n        if(r>0){\n          v[s][i].cap-=r;v[e.to][e.rev].cap+=r;\n          return r;\n        }\n      }\n    }\n    return 0;\n  }\n  long solve(long s,long t){//最大流を求める\n    long ans=0;\n    while(1){\n      used.clear();used=vector<bool>(n,0);\n      long f=dfs(s,t,LONG_MAX);\n      if(f==0)return ans;\n      else ans+=f;\n    }\n  }\n  flow(){}\n  flow(const vector<vector<edge>>&v_)\n    :n(v_.size()),v(vector<vector<edge>>(v_.size())){\n      for(long i=0;i<n;i++)for(long j=0;j<v_[i].size();j++){\n        edge e=v_[i][j];\n        v[i].push_back(edge(e.to,e.cap,v[e.to].size()));//辺の追加\n        v[e.to].push_back(edge(i,0,v[i].size()-1));//逆辺の追加\n      }\n    }\n};\n\nint main(){\n  //素数前処理\n  long M=10000001;\n  vector<bool>prime(M,1);prime[0]=0,prime[1]=0;\n  for(long i=2;i<=M;i++){\n    if(prime[i]){\n      for(long j=2;i*j<M;j++)prime[i*j]=0;\n    }\n  }\n  \n  long N;cin>>N;\n  vector<long>X(N);for(long i=0;i<N;i++)cin>>X[i];\n  vector<long>O,E;\n  for(long i=0;i<N;i++){\n    if(i==0||X[i]-1!=X[i-1]){if(X[i]%2)O.push_back(X[i]);else E.push_back(X[i]);}\n    if(i==N-1||X[i]+1!=X[i+1]){if((X[i]+1)%2)O.push_back(X[i]+1);else E.push_back(X[i]+1);}\n  }\n  \n  vector<vector<edge>>A(2+O.size()+E.size());\n  for(long i=0;i<O.size();i++)A[0].push_back(edge(1+i,LONG_MAX,0));\n  for(long i=0;i<E.size();i++)A[1+O.size()+i].push_back(edge(1+O.size()+E.size(),LONG_MAX,0));\n  for(long i=0;i<O.size();i++)for(long j=0;j<E.size();j++){\n    long d=abs(O[i]-E[j]);\n    if(prime[d])A[1+i].push_back(edge(1+O.size()+j,1,0));\n  }\n  flow f(A);long k=f.solve(0,1+O.size()+E.size());\n  long ans=k+2*((O.size()-k)/2)+2*((E.size()-k)/2)+3*((O.size()-k)%2);\n  cout<<ans;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 100 + 5;\nint n, x[N], a[N], b[N], an, bn, G[N][N], vis[N], id[N];\nmap<int, int> M;\nint pri(int x) {\n\tif(x == 1) return 0;\n\tfor(int i = 3; i * i <= x; ++i) if (x % i == 0) return 0;\n\treturn 1;\n}\nint dfs(int x) {\n\tfor(int i = 1; i <= bn; ++i) if (G[x][i] == 1 && !vis[i]) {\n\t\tvis[i] = 1;\n\t\tif (!id[i] || dfs(id[i])) {\n\t\t\tid[i] = x;\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\nint main() {\n\tscanf(\"%d\", &n);\n\tfor(int i = 1; i <= n; ++i) scanf(\"%d\", &x[i]), M[x[i]] ^= 1, M[x[i] + 1] ^= 1;\n\tfor(auto x:M) if (x.second) { (x.first & 1 ? a[++an] : b[++bn]) = x.first; }\n\tfor(int i = 1; i <= an; ++i) for(int j = 1; j <= bn; ++j) if (pri(abs(a[i] - b[j]))) G[i][j] = 1;\n\tint ans = 0;\n\tfor(int i = 1; i <= an; ++i) {\n\t\tmemset (vis, 0, sizeof vis);\n\t\tans += dfs(i);\n\t}\n\tans += ((an - ans) / 2 + (bn - ans) / 2) * 2 + ((an - ans) & 1) * 3;\n\tprintf (\"%d\\n\", ans);\n\treturn 0;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<cstring>\n#include<cmath>\nusing namespace std;\nint n,tot,prime[11000000],nprime[11000000];\nint ans,cnt1,cnt2,s[11000000];\nint a[210],b[210],vis[410],match[410];\nvector<int> vec[410];\nchar Getchar(){\n    static char now[1<<20],*S,*T;\n    if (T==S){\n        T=(S=now)+fread(now,1,1<<20,stdin);\n        if (T==S) return EOF;\n    }\n    return *S++;\n}\nint read(){\n    int x=0,f=1;\n    char ch=Getchar();\n    while (ch<'0'||ch>'9'){\n        if (ch=='-') f=-1;\n        ch=Getchar();\n    }\n    while (ch<='9'&&ch>='0') x=x*10+ch-'0',ch=Getchar();\n    return x*f;\n}\nbool dfs(int x){\n\tint y;\n\tfor (int i=0;i<(int)vec[x].size();i++){\n\t\ty=vec[x][i];\n\t\tif (!vis[y]){\n\t\t\tvis[y]=true;\n\t\t\tif (!match[y]||dfs(match[y])){\n\t\t\t\tmatch[y]=x;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\nint main(){\n\tfor (int i=2;i<=10000001;i++){\n\t\tif (!nprime[i]) prime[++tot]=i;\n\t\tfor (int j=1;j<=tot&&i*prime[j]<=10000001;j++){\n\t\t\tnprime[i*prime[j]]=true;\n\t\t\tif (i%prime[j]==0) break;\n\t\t}\n\t}\n\tn=read(); nprime[1]=1;\n\tfor (int i=1;i<=n;i++) s[read()]=1;\n\tfor (int i=1;i<=10000001;i++)\n\t\tif (s[i]!=s[i-1]){\n\t\t\tif (i&1) a[++cnt1]=i;\n\t\t\telse b[++cnt2]=i;\n\t\t}\n\tfor (int i=1;i<=cnt1;i++)\n\t\tfor (int j=1;j<=cnt2;j++)\n\t\t\tif (!nprime[abs(a[i]-b[j])])\n\t\t\t\tvec[i].push_back(j);\n\tfor (int i=1;i<=cnt1;i++){\n\t\tmemset(vis,false,sizeof(vis));\n\t\tans+=dfs(i);\n\t}\n\tprintf(\"%d\\n\",ans+(cnt1-ans)/2*2+(cnt2-ans)/2*2+((cnt1-ans)&1)*3);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nusing namespace std;\nconst int N=110,M=10001000;\nint i,j,k,n,nm,ans;\nint a[N],fg[M],pr[M/10];\nvoid pre(int n) {\n\tint i,j;\n\tfg[1]=1;\n\tfor (i=2;i<=n;i++) {\n\t\tif (!fg[i]) pr[++nm]=i;\n\t\tfor (j=1;j<=nm;j++) {\n\t\t\tif (i*pr[j]>n) break;\n\t\t\tfg[i*pr[j]]=1;\n\t\t\tif (i%pr[j]==0) break;\n\t\t}\n\t}\n}\nint main() {\n\tscanf(\"%d\",&n);\n\tfor (i=1;i<=n;i++) scanf(\"%d\",&a[i]);\n\tpre(a[n]);\n\tk=a[n]-a[1]+1;\n\tif (k&1) {\n\t\tif (fg[k]) ans=3;\n\t\telse ans=1;\n\t}\n\telse ans=2;\n\tfor (i=2;i<=n;i++) {\n\t\tk=a[i]-a[i-1]-1;\n\t\tif (!k) continue;\n\t\tif (k&1) {\n\t\t\tif (fg[k]) ans+=3;\n\t\t\telse ans++;\n\t\t}\n\t\telse ans+=2;\n\t}\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<string.h>\nusing namespace std;\n\nconst int maxn = 2e5+7;\nconst int maxm = 1e7+7;\nint n,a[maxm];\nvector<int>v[2],E[maxn];\nbool bio[maxn];\nint conn[maxn];\nvoid init(){\n    scanf(\"%d\",&n);\n    for(int i=1;i<=n;i++){\n        int x;\n        scanf(\"%d\",&x);\n        a[x]=1;\n    }\n}\nbool prime(int x){\n    if(x==1)return false;\n    for(int i=2;i*i<=x;i++)\n        if(x%i==0)return false;\n    return true;\n}\nbool dfs(int x){\n    if(bio[x])return false;\n    bio[x]=true;\n    for(auto it : E[x]){\n        if(conn[it] == -1 || dfs(conn[it])){\n            conn[it] = x;\n            return true;\n        }\n    }\n    return false;\n}\nint main(){\n    init();\n    memset(conn,-1,sizeof(conn));\n    for(int i=maxm-1;i;i--){\n        a[i]^=a[i-1];\n        if(a[i])v[i%2].push_back(i);\n    }\n    for(int i=0;i<v[0].size();i++){\n        for(int j=0;j<v[1].size();j++){\n            if(prime(abs(v[0][i]-v[1][j]))){\n                E[i].push_back(j);\n            }\n        }\n    }\n    \n    int match = 0;\n    for(int i=0;i<v[0].size();i++){\n        memset(bio,false,sizeof(bio));\n        match+=dfs(i);\n    }\n    cout<<v[0].size()+v[1].size()-match+(v[0].size()-match)%2;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\nusing namespace std;\nconst int N=110*2;\nbool f[10001000],fl[N][N],fla[N];\nint n,p[1000100],cnt,a[N],cot,from[N],nj[N],no[N];\nbool match(int x)\n{\n    if(fla[x]) return false;\n    fla[x]=true;\n    for(int i=1;i<=nj[0];++i)\n        if(fl[x][i]&&(from[i]==0||match(from[i])))\n        {\n            from[i]=x;\n            return true;\n        }\n    return false;\n}\nvoid init()\n{\n    for(int i=2;i<=10000500;++i)\n    {\n        if(!f[i]) p[++cnt]=i;\n            for(int j=1;j<=cnt&&p[j]*i<=10000050;++j)\n            {\n                f[p[j]*i]=true;\n                if(i%p[j]==0) break;\n            }\n    }\n}\nint main()\n{\n    ios::sync_with_stdio(false);\n    init();\n    f[1]=true;\n    f[2]=false;\n    cin>>n;\n    int t=-10,t1;\n    for(int i=1;i<=n;++i)\n    {\n        cin>>t1;\n        if(t1-t!=1) \n        {\n            a[cot++]=t+1;\n            a[cot++]=t1;\n        }\n        t=t1;\n    }\n    a[cot]=t1+1;\n    for(int i=1;i<=cot;++i)\n    {\n        if(a[i]%2)\n            nj[++nj[0]]=a[i];\n        else\n            no[++no[0]]=a[i];\n    }\n    for(int i=1;i<=nj[0];++i)\n        for(int j=1;j<=no[0];++j)\n            fl[i][j]=!f[abs(nj[i]-no[j])];\n    int ans=0;\n    for(int i=1;i<=nj[0];++i)\n    {\n        memset(fla,false,sizeof(fla));\n        if(match(i)) ans++;\n    }\n    cout<< ans+(nj[0]-ans)/2*2+(no[0]-ans)/2*2+(nj[0]-ans)%2*3 <<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define maxn 10000005\n#define maxv 105\nusing namespace std;\nint prime[4100000];\nbool vis[maxn]={0};\nint sum=0;\n    int cnt1=0;\n    int cnt2=0;\nvoid primejudge(int n)\n{   memset(vis,false,sizeof(vis));\n    vis[1]=true;\n    for(int i=2;i<=n;i++)\n    {\n        if(!vis[i])\n        {\n            prime[sum++]=i;\n        }\n        for(int j=0;j<sum&&i*prime[j]<=n;j++)\n            {\n                vis[i*prime[j]]=true;\n                if(i%prime[j]==0) break;\n            }\n    }\n    vis[2]=true;\n}\nint a[maxv*5];\nint x[maxv*5];\nint mp1[maxv*5];\nint mp2[maxv*5];\nbool used[maxv*5];\nbool mps[maxv*2][maxv*2];\nint bel[maxv*5];\nbool findd(int q)\n{\n    int i,j;\n    for(j=0;j<cnt2;j++)\n    {\n        if(mps[q][j]==true&&used[j]==false)\n        {\n            used[j]=true;\n            if(bel[j]==0||findd(bel[j]))\n            {\n                bel[j]=q;\n                return true;\n            }\n        }\n    }\n    return false;\n}\nint main()\n{\n    int n,i;\n    int match[maxv]={0};\n    scanf(\"%d\",&n);\n    for(i=1; i<=n; i++)\n    {\n        scanf(\"%d\",&a[i]);\n        vis[a[i]]=true;\n    }\n    //cout<<\"ggggg\"<<endl;\n    int cnt=0;\n    for(i=1; i<maxn; i++)\n    {\n        if(vis[i]!=vis[i-1])\n        {\n            x[cnt++]=i;\n        }\n    }\n    primejudge(10000003);\n    //cout<<\"ggggg\"<<endl;\n    for(i=0;i<cnt;i++)\n    {\n        if(x[i]&1) mp1[cnt1++]=x[i];\n        else mp2[cnt2++]=x[i];\n    }\n    //cout<<\"ggggg\"<<endl;\n    for(i=0;i<cnt1;i++)\n    {\n        for(int j=0;j<cnt2;j++)\n        {\n            if(!vis[abs(mp1[i]-mp2[j])])\n            {\n                mps[i][j]=true;\n            }\n        }\n    }\n    int temp=0;\n    for(i=0;i<cnt1;i++)\n    {\n    memset(used,false,sizeof(used));\n    if(findd(i)) temp++;\n    }\n    cnt1-=temp;\n    cnt2-=temp;\n    int ans=temp;\n    ans=cnt1+cnt2+cnt1%2*3;\n    cout<<ans<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<queue>\n#include<stack>\n#include<cstring>\n#include<algorithm>\n#include<vector>\n#include<cmath>\nusing namespace std;\nint e[201][201];\nint vis[201];\nint match[201];\nint tot1=0,tot2=0;\nbool find(int u)\n{\n\tfor(int i=1;i<=tot2;i++)\n\t{\n\t\tif(e[u][i])\n\t\t{\n\t\t\tvis[i]=1;\n\t\t\tif(!match[i]||find(match[i]))\n\t\t\t{\n\t\t\t\tmatch[i]=u;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n}\nbool isprime(int x)\n{\n\tif(x==1) return false;\n\tfor(int i=2;i<=sqrt(x);i++)\n\t\tif(x%i==0)\n\t\t\treturn false;\n\treturn true;\n}\nint x[201];\nint odd[201];\nint even[201];\nsigned main()\n{\n\tint n;\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)\n\t\tscanf(\"%d\",&x[i]);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tif(i==1||x[i-1]!=x[i]-1)\n\t\t{\n\t\t\tif(x[i]%2==1) odd[++tot1]=x[i];\n\t\t\telse even[++tot2]=x[i];\n\t\t}\n\t\tif(i==n||x[i+1]!=x[i]+1)\n\t\t{\n\t\t\tif(x[i]%2==1) even[++tot2]=x[i]+1;\n\t\t\telse odd[++tot1]=x[i]+1;\n\t\t}\n\t}\n\tfor(int i=1;i<=tot1;i++)\n\t\tfor(int j=1;j<=tot2;j++)\n\t\t\tif(isprime(abs(odd[i]-even[j])))\n\t\t\t\te[i][j]=1;\n\tint ans=0;\n\tfor(int i=1;i<=tot1;i++)\n\t{\n\t\tmemset(vis,0,sizeof(vis));\n\t\tif(find(i))\n\t\t\tans++;\n\t}\n\tprintf(\"%d\",ans+(tot1-ans)/2*2+(tot2-ans)/2*2+(tot1-ans)%2*3);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define int ll\n\n#define FOR(i,a,b) for(int i=int(a);i<int(b);i++)\n#define REP(i,b) FOR(i,0,b)\n#define MP make_pair\n#define PB push_back\n#define ALL(x) x.begin(),x.end()\n#define REACH cerr<<\"reached line \"<<__LINE__<<endl\n#define DMP(x) cerr<<\"line \"<<__LINE__<<\" \"<<#x<<\":\"<<x<<endl\n#define ZERO(x) memset(x,0,sizeof(x))\n\nusing pi=pair<int,int>;\nusing vi=vector<int>;\nusing ld=long double;\n\ntemplate<class T,class U>\nostream& operator<<(ostream& os,const pair<T,U>& p){\n\tos<<\"(\"<<p.first<<\",\"<<p.second<<\")\";\n\treturn os;\n}\n\ntemplate<class T>\nostream& operator <<(ostream& os,const vector<T>& v){\n\tos<<\"[\";\n\tREP(i,(int)v.size()){\n\t\tif(i)os<<\",\";\n\t\tos<<v[i];\n\t}\n\tos<<\"]\";\n\treturn os;\n}\n\nint read(){\n\tint i;\n\tscanf(\"%lld\",&i);\n\treturn i;\n}\n\nvoid printSpace(){\n\tprintf(\" \");\n}\n\nvoid printEoln(){\n\tprintf(\"\\n\");\n}\n\nvoid print(int x,int suc=1){\n\tprintf(\"%lld\",x);\n\tif(suc==1)\n\t\tprintEoln();\n\tif(suc==2)\n\t\tprintSpace();\n}\n\nstring readString(){\n\tstatic char buf[3341919];\n\tscanf(\"%s\",buf);\n\treturn string(buf);\n}\n\nchar* readCharArray(){\n\tstatic char buf[3341919];\n\tstatic int bufUsed=0;\n\tchar* ret=buf+bufUsed;\n\tscanf(\"%s\",ret);\n\tbufUsed+=strlen(ret)+1;\n\treturn ret;\n}\n\ntemplate<class T,class U>\nvoid chmax(T& a,U b){\n\tif(a<b)\n\t\ta=b;\n}\n\ntemplate<class T,class U>\nvoid chmin(T& a,U b){\n\tif(a>b)\n\t\ta=b;\n}\n\ntemplate<class T>\nT Sq(const T& t){\n\treturn t*t;\n}\n\nconst int inf=LLONG_MAX/3;\n\nnamespace MaxFlow{\n\tusing CapType=int;\n\tconst CapType inf=1145141919;\n\tstruct Edge{\n\t\tint to,rev;\n\t\tCapType cap;\n\t};\n\tvector<vector<Edge>> g;\n\tvi itr,level;\n\tvoid Init(int n){\n\t\tg.assign(n,vector<Edge>());\n\t\titr.assign(n,0);\n\t\tlevel.assign(n,0);\n\t}\n\tvoid AddEdge(int from,int to,CapType cap){\n\t\tg[from].PB({to,(int)g[to].size(),cap});\n\t\tg[to].PB({from,(int)g[from].size()-1,0});\n\t}\n\tvoid bfs(int s){\n\t\tfill(level.begin(),level.end(),-1);\n\t\tlevel[s]=0;\n\t\tqueue<int> q;\n\t\tq.push(s);\n\t\twhile(!q.empty()){\n\t\t\tint v=q.front();q.pop();\n\t\t\tfor(auto e:g[v])if(e.cap>0&&level[e.to]==-1){\n\t\t\t\tlevel[e.to]=level[v]+1;\n\t\t\t\tq.push(e.to);\n\t\t\t}\n\t\t}\n\t}\n\tCapType dfs(int v,int t,CapType f){\n\t\tif(v==t)\n\t\t\treturn f;\n\t\tfor(int&i=itr[v];i<(int)g[v].size();i++){\n\t\t\tEdge& e=g[v][i];\n\t\t\tif(e.cap>0&&level[e.to]==level[v]+1){\n\t\t\t\tCapType d=dfs(e.to,t,min(f,e.cap));\n\t\t\t\tif(d>0){\n\t\t\t\t\te.cap-=d;\n\t\t\t\t\tg[e.to][e.rev].cap+=d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tCapType Calc(int s,int t){\n\t\tCapType flow=0;\n\t\twhile(1){\n\t\t\tbfs(s);\n\t\t\tif(level[t]==-1)\n\t\t\t\treturn flow;\n\t\t\tfill(itr.begin(),itr.end(),0);\n\t\t\tCapType f;\n\t\t\twhile((f=dfs(s,t,inf))>0)\n\t\t\t\tflow+=f;\n\t\t}\n\t}\n}\n\nbool isPrime(int x){\n\tif(x==1)return false;\n\tfor(int i=3;i*i<=x;i+=2)\n\t\tif(x%i==0)return false;\n\treturn true;\n}\n\nsigned main(){\n\tint n=read();\n\tvi x(n);REP(i,n)x[i]=read();\n\tvi e,o;\n\tREP(i,n){\n\t\tif(i==0||x[i-1]+1!=x[i])\n\t\t\t(x[i]%2==0?e:o).PB(x[i]);\n\t\tif(i==n-1||x[i]+1!=x[i+1])\n\t\t\t((x[i]+1)%2==0?e:o).PB(x[i]+1);\n\t}\n\tint s=e.size(),t=o.size();\n\tMaxFlow::Init(1+s+t+1);\n\tREP(i,s)\n\t\tMaxFlow::AddEdge(0,1+i,1);\n\tREP(i,t)\n\t\tMaxFlow::AddEdge(1+s+i,1+s+t,1);\n\tREP(i,s)REP(j,t)if(isPrime(abs(e[i]-o[j])))\n\t\tMaxFlow::AddEdge(1+i,1+s+j,1);\n\tint f=MaxFlow::Calc(0,1+s+t),ans=f;\n\tif((s-f)&1)ans+=3;\n\tans+=(s-f)/2*2+(t-f)/2*2;\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\nint n;\nvector<int>vi;\nint O,E;\nint main(){\n\tcin >> n;\n\tfor(int i=0;i<n;i++){\n\t\tint a; cin >> a; vi.pb(a);\n\t\tif(i==0 || vi[i-1]+1 != vi[i]){\n\t\t\tif(a%2 == 0) E++; else O++;\n\t\t}\n\t\tif(i && vi[i-1]+1 != vi[i]){\n\t\t\tif(vi[i-1]%2 == 0) O++; else E++;\n\t\t}\n\t\tif(i==n-1){\n\t\t\tif(vi[i]%2 == 0) O++; else E++;\n\t\t}\n\t}\n\tif( (O%2) + (E%2) == 2) printf(\"%d\\n\",O+E+1);\n\telse printf(\"%d\\n\",O+E);\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n\n#include <iostream>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <unordered_set>\n#include <queue>\n#include <set>\n#include <algorithm>\n#include <numeric>\n#include <list>\nusing namespace std;\n\nusing QWORD  = uint64_t;\nusing SQWORD = int64_t;\nusing DWORD  = uint32_t;\nusing SDWORD = int32_t;\nusing WORD   = uint16_t;\nusing SWORD  = int16_t;\nusing BYTE   = uint8_t;\nusing SBYTE  = int8_t;\nusing DOUBLE = double;\nusing FLOAT  = float;\n\n#define MIN_SDWORD (-2147483648)\n#define MAX_SDWORD (2147483647)\n#define MIN_SBYTE (-128)\n#define MAX_SBYTE (127)\n\n#define MIN_SQWORD (0x8000000000000000)\n#define MAX_SQWORD (0x7FFFFFFFFFFFFFFF)\n\n#define MAX_QWORD  (0xFFFFFFFFFFFFFFFF)\n#define MAX_DWORD  (0xFFFFFFFF)\n#define MAX_WORD   (0xFFFF)\n#define MAX_BYTE   (0xFF)\n\n#define MAX_DOUBLE      (1.0e+308)\n#define DOUBLE_EPS      (1.0e-12)\n#define MIN_DOUBLE_N    (-1.0e+308)\n\n#define ArrayLength(a)  (sizeof(a) / sizeof(a[0]))\n\nstatic inline DOUBLE MAX(DOUBLE a, DOUBLE b) { return a > b ? a : b; }\nstatic inline QWORD MAX(QWORD a, QWORD b) { return a > b ? a : b; }\nstatic inline DWORD MAX(DWORD a, DWORD b) { return a > b ? a : b; }\nstatic inline SDWORD MAX(SDWORD a, SDWORD b) { return a > b ? a : b; }\nstatic inline DOUBLE MIN(DOUBLE a, DOUBLE b) { return a < b ? a : b; }\nstatic inline QWORD MIN(QWORD a, QWORD b) { return a < b ? a : b; }\nstatic inline DWORD MIN(DWORD a, DWORD b) { return a < b ? a : b; }\nstatic inline SDWORD MIN(SDWORD a, SDWORD b) { return a < b ? a : b; }\nstatic inline DOUBLE ABS(DOUBLE a) { return 0 < a ? a : -a; };\n\n#define BYTE_BITS   (8)\n#define WORD_BITS   (16)\n#define DWORD_BITS  (32)\n#define QWORD_BITS  (64)\n\nstatic inline void inputStringSpSeparated(char *pcStr)\n{\n    char *pcCur = pcStr;\n    for (;;) {\n        char c = getchar();\n        if (('\\n' == c) || (EOF == c) || (' ' == c)) {\n            break;\n        }\n        *pcCur = c;\n        pcCur++;\n    }\n    *pcCur = '\\0';\n}\n\nstatic inline void inputString(char *pcStr)\n{\n    char *pcCur = pcStr;\n    for (;;) {\n        char c = getchar();\n        if (('\\n' == c) || (EOF == c)) {\n            break;\n        }\n        *pcCur = c;\n        pcCur++;\n    }\n    *pcCur = '\\0';\n}\n\n\nstatic inline SQWORD inputSQWORD(void)\n{\n    SQWORD sqNumber = 0;\n    SQWORD sqMultiplier = 1;\n    bool bRead = false;\n    for (;;) {\n        char c = getchar();\n        if (!bRead) {\n            if ('-' == c) {\n                sqMultiplier = -1;\n            }\n        }\n        if (('0' <= c) && (c <= '9')) {\n            sqNumber *= 10LL;\n            sqNumber += (SQWORD)(c - '0');\n            bRead = true;\n        } else {\n            if (bRead) {\n                return sqNumber * sqMultiplier;\n            }\n        }\n    }\n}\n\n\nstatic inline SDWORD inputSDWORD(void)\n{\n    SDWORD lNumber = 0;\n    SDWORD lMultiplier = 1;\n    bool bRead = false;\n    for (;;) {\n        char c = getchar();\n        if (!bRead) {\n            if ('-' == c) {\n                lMultiplier = -1;\n            }\n        }\n        if (('0' <= c) && (c <= '9')) {\n            lNumber *= 10;\n            lNumber += (c - '0');\n            bRead = true;\n        } else {\n            if (bRead) {\n                return lNumber * lMultiplier;\n            }\n        }\n    }\n}\n\nstatic inline DOUBLE inputFP(void)\n{\n    DOUBLE dInt = 0.0;\n    DOUBLE dFrac = 0.0;\n    DOUBLE dMultiplier = 1.0;\n    DWORD dwFpCnt = 0;\n    DOUBLE *pdCur = &dInt;\n    bool bRead = false;\n    for (;;) {\n        char c = getchar();\n        if (!bRead) {\n            if ('-' == c) {\n                dMultiplier = -1;\n            }\n        }\n        if ('.' == c) {\n            pdCur = &dFrac;\n        } else if (('0' <= c) && (c <= '9')) {\n            (*pdCur) *= 10;\n            (*pdCur) += (DOUBLE)(c - '0');\n            bRead = true;\n            if (pdCur == &dFrac) {\n                dwFpCnt++;\n            }\n        } else {\n            if (bRead) {\n                return dMultiplier * (dInt + dFrac / (pow((DOUBLE)10.0 , (DOUBLE)dwFpCnt)));\n            }\n        }\n    }\n}\n\n\n/**\n *  mod による操作ライブラリ\n */\n\n#define ANS_MOD (1000000007LL)\n \nstatic SQWORD addMod(SQWORD x, SQWORD y)\n{ \n    return (x + y) % ANS_MOD;\n}\n \nstatic SQWORD subMod(SQWORD x, SQWORD y)\n{\n    return (x - y + ANS_MOD) % ANS_MOD;\n}\n \nstatic SQWORD mulMod(SQWORD x, SQWORD y) \n{\n    return (x * y) % ANS_MOD;\n}\n \nstatic SQWORD powMod(SQWORD x, SQWORD e) {\n    SQWORD v = 1;\n    for (; e; x = mulMod(x, x), e >>= 1) {\n        if (e & 1) {\n            v = mulMod(v, x);\n        }\n    }\n    return v;\n}\n \nstatic SQWORD divMod(SQWORD x, SQWORD y)\n{\n    return mulMod(x, powMod(y, ANS_MOD - 2));\n}\n \n \nstatic SQWORD combMod(SQWORD n, SQWORD k)\n{\n    SQWORD v=1;\n    for(SQWORD i=1; i<=k; i++) {\n        v = divMod(mulMod(v, n-i+1),i);\n    } \n    return v;\n}\n\n/*----------------------------------------------*/\n\ntypedef struct {\n    SDWORD lTo;\n    SQWORD sqCap;\n    SQWORD sqCost;\n    SDWORD lRev;\n} ST_EDGE;\n\n#define MAX_V   (202)\n\nstruct Flow {\nprivate:\n    vector<ST_EDGE> avGraph[MAX_V];\n    SDWORD  alDims[MAX_V];\n    SQWORD  sqEdgeNum;\n    SQWORD  asqDist[MAX_V];\n    SDWORD  alPrevV[MAX_V];   \n    SDWORD  alPrevEdge[MAX_V];      /*直前の頂点と辺 */\n\n    SDWORD  alDinic_Level[MAX_V];\n    SDWORD  alDinic_Iter[MAX_V];\n\npublic:\n    Flow() {\n        for (auto v: avGraph) {\n            v.clear();\n        }\n        memset(alDims, 0, sizeof(alDims));\n        memset(asqDist, 0, sizeof(asqDist));\n        memset(alPrevV, 0, sizeof(alPrevV)); \n        memset(alPrevEdge, 0, sizeof(alPrevEdge));\n        memset(alDinic_Level, 0, sizeof(alDinic_Level));\n        memset(alDinic_Iter, 0, sizeof(alDinic_Iter));\n    }\n    void addEdge(SDWORD lFrom, SDWORD lTo, SQWORD sqCap, SQWORD sqCost) {\n//        printf(\"%d ----[%lld] ----> %d\\n\", lFrom, sqCap, lTo);\n        \n        alDims[lFrom]++;\n        avGraph[lFrom].push_back((ST_EDGE){lTo, sqCap, sqCost, (SDWORD)(avGraph[lTo].size())});\n        avGraph[lTo].push_back((ST_EDGE){lFrom, 0, -sqCost, (SDWORD)(avGraph[lFrom].size() - 1)});\n    }\n\n    SDWORD minCostFlow(SDWORD lStart, SDWORD lTarget, SQWORD sqFlow)\n    {\n        SQWORD sqRes = 0;\n        SQWORD sqFlowRest = sqFlow;\n        while (0 < sqFlowRest) {\n            /* Bellman-Ford Method */\n            fill(asqDist, asqDist + ArrayLength(asqDist), MAX_SDWORD);\n            asqDist[lStart] = 0;\n            bool bIsUpdate = true;\n            while (bIsUpdate) {\n                bIsUpdate = false;\n                for (SDWORD lV = 0; lV < MAX_V; lV++) {\n                    for (SDWORD lIdx = 0; lIdx < avGraph[lV].size(); lIdx++) {\n                        ST_EDGE &stE = avGraph[lV][lIdx];\n                        if ((asqDist[lV] != MAX_SDWORD)\n                                && (0 < stE.sqCap)\n                                && (asqDist[lV] + stE.sqCost < asqDist[stE.lTo])) {\n                            asqDist[stE.lTo] = asqDist[lV] + stE.sqCost;\n                            alPrevV[stE.lTo] = lV;\n                            alPrevEdge[stE.lTo] = lIdx;\n                            bIsUpdate = true;\n                        }\n                    }\n                }\n            }\n            if (asqDist[lTarget] == MAX_SDWORD) {\n                return -1;\n            }\n\n            SQWORD sqAddFlow = MAX_SQWORD;\n            for (SDWORD lV = lTarget; lV != lStart; lV = alPrevV[lV]) {\n                sqAddFlow = min(sqAddFlow, avGraph[alPrevV[lV]][alPrevEdge[lV]].sqCap);\n            }\n            sqFlowRest -= sqAddFlow;\n            sqRes += sqAddFlow * asqDist[lTarget];      // 後で目的変数は書き換える\n            for (SDWORD lV = lTarget; lV != lStart; lV = alPrevV[lV]) {\n                ST_EDGE &stE = avGraph[alPrevV[lV]][alPrevEdge[lV]];\n                stE.sqCap -= sqAddFlow;\n                avGraph[lV][stE.lRev].sqCap += sqAddFlow;\n            }\n        }\n        return sqRes;\n    }\n\nprivate:\n    SQWORD maxFlowDinicBfs(SDWORD lS)\n    {\n        memset(alDinic_Level, -1, sizeof(alDinic_Level));\n        queue<SDWORD> queSearch;\n        alDinic_Level[lS] = 0;\n        queSearch.push(lS);\n        while (!queSearch.empty()) {\n            SDWORD lV = queSearch.front();\n            queSearch.pop();\n            for (SDWORD lIdx = 0; lIdx < avGraph[lV].size(); lIdx++) {\n                ST_EDGE &stE = avGraph[lV][lIdx];\n                if ((0 < stE.sqCap) && (alDinic_Level[stE.lTo] < 0)) {\n                    alDinic_Level[stE.lTo] = alDinic_Level[lV] + 1;\n                    queSearch.push(stE.lTo);\n                }\n            }\n        }\n\n        return 0;\n    }\n\n    SQWORD maxFlowDinicDfs(SDWORD lV, SDWORD lT, SQWORD sqF)\n    {\n        if (lV == lT) {\n            return sqF;\n        }\n        for (SDWORD &lI = alDinic_Iter[lV]; lI < avGraph[lV].size(); lI++) {\n            ST_EDGE &stE = avGraph[lV][lI];\n            if ((0 < stE.sqCap) && (alDinic_Level[lV] < alDinic_Level[stE.lTo])) {\n                SQWORD sqDiffFlow = maxFlowDinicDfs(stE.lTo, lT, min(sqF, stE.sqCap));\n                if (0 < sqDiffFlow) {\n                    stE.sqCap -= sqDiffFlow;\n                    avGraph[stE.lTo][stE.lRev].sqCap += sqDiffFlow;\n                    return sqDiffFlow;\n                }\n            }\n        }\n        return 0;\n    }\n\npublic:\n    SQWORD MaxFlow(SDWORD lStart, SDWORD lTarget)\n    {\n        SQWORD sqFlow = 0LL;\n        for (;;) {\n            maxFlowDinicBfs(lStart);\n            if (alDinic_Level[lTarget] < 0) {\n                return sqFlow;\n            }\n            memset(alDinic_Iter, 0, sizeof(alDinic_Iter));\n            while (1) {\n                SQWORD sqDiffFlow = maxFlowDinicDfs(lStart, lTarget, MAX_SQWORD);\n                sqFlow += sqDiffFlow;\n                if (0LL == sqDiffFlow) {\n                    break;\n                }\n            }\n        }\n    }\n\n    SQWORD getFlow(SDWORD lPnt)\n    {\n        SQWORD sqCapSum = 0; \n        for (auto e: avGraph[lPnt]) {\n            sqCapSum += e.sqCap;\n        }\n        return alDims[lPnt] - sqCapSum;\n    }\n};\n\n/*----------------------------------------------*/\n\nstatic void getPrimes(vector<SDWORD> &vlPrimes, SDWORD lMax)\n{\n    /* lSearchMax と ループ内の *2 の関係から、入力は3以上とすること */\n    if (!(1 <= lMax)) {\n        printf(\"Oops!\");\n        return;\n    }\n\n    /* 素数のリストを作る */\n    vector<bool> vbIsPrime(lMax + 1, true);\n    SDWORD lSearchMax = sqrt(lMax) + 1;\n    vbIsPrime[0] = false;\n    vbIsPrime[1] = false;\n    for (SDWORD lPrime = 2; lPrime < vbIsPrime.size(); lPrime++) {\n        if (vbIsPrime[lPrime]) {\n            vlPrimes.emplace_back(lPrime);\n            if (lPrime <= lSearchMax) {\n                for (SDWORD lCurNum = lPrime * 2; lCurNum <= lMax; lCurNum += lPrime) {\n                    vbIsPrime[lCurNum] = false;\n                }\n            }\n        }\n    }\n}    \n\n/*----------------------------------------------*/\n\n#define PNT_NO_START    (0)\n#define PNT_NO_OFFSET   (100)\n#define PNT_NO_TARGET   (201)\n#define FLOW_OFFSET     (1000000000)\n#define CAPACITY_INF    (1000000001)\n#define DUMMY_COST      (1)\n\nint main(void)\n{\n    SQWORD sqN = inputSQWORD();\n\n    Flow solverFlow;\n    vector<SQWORD> vsqA;\n    vector<SQWORD> vsqB;\n    vector<SDWORD> vlPrimes;\n\n    getPrimes(vlPrimes, 1e7 + 1);\n    vlPrimes.erase(find(vlPrimes.begin(), vlPrimes.end(), 2));\n\n    for (SQWORD sqIdx = 0; sqIdx < sqN; sqIdx++) {\n        SQWORD sqA = inputSQWORD();\n        vsqA.emplace_back(sqA);\n    }\n\n#if 1\n    for (auto it = vsqA.begin(); it != vsqA.end(); ++it) {\n//        printf(\"%lld %lld\\n\", *it, *(it - 1));\n        if (it == vsqA.begin()) {\n            vsqB.emplace_back(*it);\n        } else {\n            if ((*it) - 1 != *(it - 1)) {\n                vsqB.emplace_back(*it);\n            }\n        }\n        if (it == vsqA.end() - 1) {\n            vsqB.emplace_back((*it) + 1);\n        } else {\n            if ((*it) + 1 != *(it + 1)) {\n                vsqB.emplace_back((*it) + 1);\n            }\n        }\n    }\n#else\n    vsqB = vsqA;\n#endif\n\n    vector<SQWORD> vsqCOdd;\n    vector<SQWORD> vsqCEven;\n    \n    unordered_map<SQWORD, SQWORD> mapCEven, mapCOdd;\n\n    SQWORD sqIdx = 1;\n    for (auto b: vsqB) {\n        if (0 == b % 2) {\n            vsqCEven.emplace_back(b);\n            mapCEven[b] = sqIdx;\n        } else {\n            vsqCOdd.emplace_back(b);\n            mapCOdd[b] = sqIdx;\n        }\n        sqIdx++;\n    }\n\n    /* 二部マッチング */\n    for (auto c: vsqCEven) {\n        solverFlow.addEdge(PNT_NO_START, mapCEven[c], 1, DUMMY_COST);\n    }\n    for (auto c: vsqCEven) {\n        solverFlow.addEdge(mapCOdd[c] + PNT_NO_OFFSET, PNT_NO_TARGET, 1, DUMMY_COST);\n    }\n\n    for (auto p: vlPrimes) {\n        for (auto c: vsqCEven) {\n            auto it = lower_bound(vsqCOdd.begin(), vsqCOdd.end(), c + p);\n            if (it != vsqCOdd.end()) {\n                if (*it == c + p) {\n                    if (c + p < 1e7 + 1) {\n                        solverFlow.addEdge(mapCEven[c], mapCOdd[c + p] + PNT_NO_OFFSET, 1, DUMMY_COST);\n                    }\n                }\n            }\n        }\n    }\n\n    SQWORD sqMaxFlow = solverFlow.MaxFlow(PNT_NO_START, PNT_NO_TARGET);\n    SQWORD vsqCRestEven = 0;\n    SQWORD vsqCRestOdd = 0;\n    for (auto c: vsqCEven) {\n        SQWORD sqFlow = solverFlow.getFlow(mapCEven[c]);\n        if (0 == sqFlow) {\n            vsqCRestEven++;\n        }\n    }\n    for (auto c: vsqCOdd) {\n        SQWORD sqFlow = solverFlow.getFlow(mapCOdd[c]);\n        if (0 == sqFlow) {\n            vsqCRestOdd++;\n        }\n    }\n\n    SQWORD sqAns = sqMaxFlow;    \n    sqAns += (vsqCRestEven / 2) * 2;\n    sqAns += (vsqCRestOdd / 2) * 2;\n    if (0 < (vsqCRestEven %  2)) {\n        sqAns += 3;\n    }\n\n    printf(\"%lld\\n\", sqAns);\n\n    return 0;\n}\n/*------------------------------------------*/\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N = 5010, M = 1e7+6;\nint prime[M],pcnt,_v[M];\nint k,x[N];\ninline void sieve(int n = 10000000+2){\n\t_v[0]=_v[1]=1;\n\tfor(int i=2;i<=n;i++){\n\t\tif(!_v[i])prime[++pcnt]=i;\n\t\tfor(int j=1;j<=pcnt&&1ll*i*prime[j]<=n;j++){\n\t\t\t_v[i*prime[j]]=1;\n\t\t\tif(i%prime[j]==0)break;\n\t\t}\n\t}\n}\nint id1[N],id2[N],cnt1,cnt2;\nvector<int> g[N];\n\ninline void adde(int u,int v){\n\tg[u].push_back(v);\n}\nstruct node{int x,y,next;}edge[100010]; int len,first[N];\nvoid ins(int x,int y){len++; edge[len].x=x; edge[len].y=y; edge[len].next=first[x]; first[x]=len;}\nint chw[N],match[N];\nbool dfs(int x)\n{\n  for(int k=first[x];k!=-1;k=edge[k].next)\n  {\n    int y=edge[k].y;\n    if(!chw[y])\n    {\n      chw[y] = 1;\n      if((match[y] == 0) || dfs(match[y])){match[y] = x; return 1;}\n    }\n  }\n  return 0;\n}\n\nint main()\n{\n//\tfreopen(\"oatmeal.in\",\"r\",stdin);\n//\tfreopen(\"oatmeal.out\",\"w\",stdout);\n\tsieve();\n\tcin >> k;\n\tfor(int i=1;i<=k;i++){\n\t\tscanf(\"%d\",&x[i]);\n\t}\n\tsort(x+1,x+k+1);\n\tfor(int u=1,v;u<=k;u=v+1){\n\t\tv=u;\n\t\twhile(v+1<=k&&x[v+1]==x[v]+1)++v;\n\t\tif(x[u]%2)id1[++cnt1]=x[u];\n\t\telse id2[++cnt2]=x[u];\n\t\tif((x[v]+1)%2)id1[++cnt1]=x[v]+1;\n\t\telse id2[++cnt2]=x[v]+1;\n\t}\n\tfor(int i=1;i<=cnt1;i++)for(int j=1;j<=cnt2;j++){\n\t\tif(!_v[abs(id1[i]-id2[j])]){\n\t\t\tadde(i,j);\n\t\t\t// cout << \"?\" << endl;\n\t\t}\n\t}\n\t// cout << cnt << endl;\n\tint ans=0;\n\tfor(int i=1;i<=cnt1;i++){\n\t\tfor(int j=1;j<N;j++)chw[j]=0;\n\t\tif(dfs(i))ans++;\n\t}\n\t// cout << cnt1 << \" \" << cnt2 << \" \" << ans << endl;\n\tcnt1-=ans,cnt2-=ans;\n\tif(cnt1%2==0){\n\t\tcout << cnt1+cnt2+ans << endl;\n\t}else{\n\t\tcout << cnt1+cnt2+ans+1 << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nint n, m, odd[209], even[209], lft[209], rgt[209];\nbool C[209];\nmap < int, bool > b;\nvector < int > v[209];\nconst int lim = 10000001;\nunsigned char cr[(lim + 10) >> 3];\n\nbool pairUp (int nod)\n{\n    if (C[nod]) return 0;\n    C[nod] = 1;\n    for (auto i : v[nod])\n        if (lft[i] == 0 || pairUp (lft[i]))\n        {\n            lft[i] = nod, rgt[nod] = i;\n            return 1;\n        }\n    return 0;\n}\n\nint maxMatch ()\n{\n    bool ok = 1;\n    while (ok)\n    {\n        ok = 0;\n        for (int i=1; i<=n; i++)\n            C[i] = 0;\n        for (int i=1; i<=n; i++)\n            if (rgt[i] == 0)\n                ok |= pairUp (i);\n    }\n    int ans = 0;\n    for (int i=1; i<=n; i++)\n        ans += (rgt[i] > 0);\n    return ans;\n}\n\nint main ()\n{\n//freopen (\"input\", \"r\", stdin);\n//freopen (\"output\", \"w\", stdout);\n\nint N;\nscanf (\"%d\", &N);\nfor (int i=1; i<=N; i++)\n{\n    int x;\n    scanf (\"%d\", &x);\n    b[x] ^= 1, b[x + 1] ^= 1;\n}\nfor (auto it : b)\n    if (it.second)\n    {\n//        printf (\"%d\\n\", it.first);\n        if (it.first & 1) odd[++n] = it.first;\n        else even[++m] = it.first;\n    }\nfor (int i=2; i * i<=lim; i++)\n    if (cr[i >> 3] & (1 << (i & 7))) ;\n    else\n    {\n        for (int j=i * i; j<=lim; j+=i)\n            cr[j >> 3] |= 1 << (j & 7);\n    }\nfor (int i=1; i<=n; i++)\n    for (int j=1; j<=m; j++)\n    {\n        int val = odd[i] - even[j];\n        if (val < 0) val = -val;\n        if (val <= 2 || (cr[val >> 3] & (1 << (val & 7)))) ;\n        else v[i].push_back (j);\n    }\nint T1 = maxMatch ();\nn -= T1, m -= T1;\nint T3 = n & 1, T2 = n / 2 + m / 2;\nprintf (\"%d\\n\", T1 + 2 * T2 + 3 * T3);\nreturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#define fo(i,a,b) for(i=a;i<=b;i++)\nusing namespace std;\ntypedef long long ll;\nconst int maxn=200+10,maxd=10000000+10;\nint x[maxn],s[maxd],pri[maxd],r[maxn],a[maxn],b[maxn];\nbool bz[maxd],dis[maxn][maxn],pd[maxn];\nint i,j,k,l,t,n,m,tot,top,num,sum,tmp,ans;\nvoid prepare(){\n    bz[1]=1;\n    fo(i,2,maxd-10){\n        if (!bz[i]) pri[++top]=i;\n        fo(j,1,top){\n            if ((ll)i*pri[j]>maxd-10) break;\n            bz[i*pri[j]]=1;\n            if (i%pri[j]==0) break;\n        }\n    }\n}\nbool dfs(int x){\n    int i;\n    fo(i,1,sum)\n        if (dis[x][i]&&!pd[i]){\n            pd[i]=1;\n            if (!r[i]||dfs(r[i])){\n                r[i]=x;\n                return 1;\n            }\n        }\n    return 0;\n}\nint main(){\n    prepare();\n    scanf(\"%d\",&n);\n    fo(i,1,n){\n        scanf(\"%d\",&x[i]);\n        s[x[i]]^=1;\n    }\n    fo(i,1,maxd-9){\n        if (s[i]!=s[i-1]){\n            if (i%2==1) a[++num]=i;\n            else b[++sum]=i;\n        }\n    }\n    fo(i,1,num)\n        fo(j,1,sum)\n            if (!bz[abs(a[i]-b[j])]) dis[i][j]=1;\n    fo(i,1,num){\n        fo(j,1,sum) pd[j]=0;\n        if (dfs(i)) tmp++;\n    }\n    ans+=2*((num-tmp)/2);\n    ans+=2*((sum-tmp)/2);\n    ans+=tmp;\n    if (num%2!=tmp%2) ans+=3;\n    printf(\"%d\\n\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<map>\n\ninline int Abs(const int x) { return x >= 0 ? x : -x; }\n\nint n, a[205], b[205], mat[205], ans;\nbool G[205][205], vis[205];\nstd::map<int, int>mp;\n\nbool prime(int x) {\n\tif (x < 2)return false;\n\tfor (int i = 2; i * i <= x; i++) {\n\t\tif (x % i == 0)return false;\n\t}\n\treturn true;\n}\n\nbool dfs(int x) {\n\tfor (int y = 1; y <= n; y++) {\n\t\tif (!vis[y] && G[x][y]) {\n\t\t\tif (vis[y] = true, !mat[y] || dfs(mat[y])) {\n\t\t\t\treturn mat[y] = x, true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 1, x; i <= n; i++)scanf(\"%d\", &x), mp[x] ^= 1, mp[x + 1] ^= 1;\n\tfor (auto& i : mp)if (i.second)(i.first & 1 ? a[++ * a] : b[++ * b]) = i.first;\n\tfor (int i = 1; i <= *a; i++) {\n\t\tfor (int j = 1; j <= *b; j++) {\n\t\t\tG[i][j] = prime(Abs(a[i] - b[j]));\n\t\t}\n\t}\n\tfor (int i = 1; i <= *a; i++)memset(vis, 0, sizeof vis), ans += dfs(i);\n\tprintf(\"%d\\n\", ans + (*a - ans) / 2 * 2 + (*b - ans) / 2 * 2 + (*a - ans) % 2 * 3);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <cstdio>\n#include <utility>\n\n#define Int register int\n\nusing namespace std;\n\nconst int MAXN = 100, MAXV = 1e7, MAXM = 5e4, MAXP = 664579, INF = 0x3f3f3f3f;\nint n, L, S, T, d[MAXV + 5];\nint pn, Prime[MAXP + 5];\nint CntL, CntR, Left[MAXM + 5], Right[MAXM + 5];\nint Cnte = 1, Head[MAXM + 5];\nbool Vis[MAXV + 5];\npair<int, int> Path[MAXM + 5];\nqueue<int> Q;\n\nstruct Edge { int To, Flow, nxt; } Graph[MAXV + 5];\n\ninline int Abs ( const int x ) { return x < 0 ? ~ x + 1 : x; }\n\ninline int Min ( const int a, const int b ) { return a < b ? a : b; }\n\ninline void Link ( const int s, const int t, const int f ) { Graph[++ Cnte] = { t, f, Head[s] }, Head[s] = Cnte; }\n\ninline void AddEdge ( const int s, const int t, const int f ) { Link ( s, t, f ), Link ( f, t, 0 ); }\n\ninline void Sieve ( const int n ) {\n\tVis[0] = Vis[1] = true;\n\tfor ( Int i = 2; i <= n; ++ i ) {\n\t\tif ( ! Vis[i] ) Prime[++ pn] = i;\n\t\tfor ( Int j = 1; j <= pn && i * Prime[j] <= n; ++ j ) {\n\t\t\tVis[i * Prime[j]] = true;\n\t\t\tif ( ! ( i % Prime[j] ) ) break;\n\t\t}\n\t}\n}\n\ninline bool BFS () {\n\tfor ( ; ! Q.empty (); Q.pop () );\n\tfor ( Int i = 1; i <= T; ++ i ) Vis[i] = false;\n\tQ.push ( S ), Vis[S] = true;\n\twhile ( ! Q.empty () ) {\n\t\tint u = Q.front (); Q.pop ();\n\t\tfor ( Int i = Head[u], v; i; i = Graph[i].nxt ) {\n\t\t\tif ( ! Vis[v = Graph[i].To] && Graph[i].Flow > 0 ) {\n\t\t\t\tQ.push ( v ), Vis[v] = true, Path[v] = { u, i };\n\t\t\t\tif ( v == T ) return true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\ninline int EK () {\n\tint ret = 0;\n\tfor ( ; BFS (); ) {\n\t\tint MinFlow = INF;\n\t\tfor ( Int u = T; u ^ S; u = Path[u].first ) MinFlow = Min ( MinFlow, Graph[Path[u].second].Flow );\n\t\tfor ( Int u = T; u ^ S; u = Path[u].first ) {\n\t\t\tGraph[Path[u].second].Flow -= MinFlow;\n\t\t\tGraph[Path[u].second ^ 1].Flow += MinFlow;\n\t\t}\n\t\tret += MinFlow;\n\t}\n\treturn ret;\n}\n\ninline void Work () {\n\tSieve ( MAXV );\n\tscanf ( \"%d\", &n );\n\tfor ( Int i = 1, x; i <= n; ++ i ) {\n\t\tscanf ( \"%d\", &x ), ++ d[x];\n\t\tL = L > x ? L : x;\n\t}\n\tfor ( Int i = 1; i <= L + 1; ++ i ) {\n\t\tif ( d[i] ^ d[i - 1] ) {\n\t\t\tif ( i & 1 ) {\n\t\t\t\tLeft[++ CntL] = i;\n\t\t\t} else {\n\t\t\t\tRight[++ CntR] = i;\n\t\t\t}\n\t\t}\n\t}\n\tS = CntL + CntR + 1, T = S + 1;\n\tfor ( Int i = 1; i <= CntL; ++ i ) AddEdge ( S, i, 1 );\n\tfor ( Int i = 1; i <= CntR; ++ i ) AddEdge ( i + CntL, T, 1 );\n\tfor ( Int i = 1; i <= CntL; ++ i ) {\n\t\tfor ( Int j = 1; j <= CntR; ++ j ) {\n\t\t\tif ( ! Vis[Abs ( Left[i] - Right[j] )] ) {\n\t\t\t\tAddEdge ( i, j + CntL, 1 );\n\t\t\t}\n\t\t}\n\t}\n\tint mxf = EK (), Ans = mxf;\n\tAns += ( CntL - mxf >> 1 << 1 ) + ( CntR - mxf >> 1 << 1 );\n\tAns += ( ( CntL - mxf ) & 1 ) * 3;\n\tprintf ( \"%d\\n\", Ans );\n}\n\nint main () {\n\tWork ();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define x first\n#define y second\n#define mp make_pair\n#define all(a) a.begin(), a.end()\n#define pub push_back\n#define ll long long\n\t\t\t\t\t  \nusing namespace std;\n\nint n;\nint a[111];\nbool prime[10000007];\nvector<int> g[222];\nint dx[222], dy[222];\n\nbool wasIn(int x){\n\tfor (int i = 0; i < n; i++) if (a[i] == x) return 1;\n\treturn 0;\n}\n\nbool check(int x){\n\treturn wasIn(x) != wasIn(x + 1);\n}\n\nbool dfs(int v){\n\tfor (int to : g[v]){\n\t\tif (dy[to] == -1){\n\t\t\tdx[v] = to;\n\t\t\tdy[to] = v;\n\t\t\treturn 1;\n\t\t}\n\t\tif (dfs(dy[to])){\n\t\t\tdx[v] = to;\n\t\t\tdy[to] = v;\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0; \n}\n\nint main(){\n\t//freopen(\"input.txt\", \"r\", stdin);\n\t//freopen(\"output.txt\", \"w\", stdout);\n\t//freopen(\"seating.in\", \"r\", stdin);\n\t//freopen(\"seating.out\", \"w\", stdout);\n\tfor (int i = 2; i < 10000007; i++){\n\t\tif (!prime[i]){\t\n\t\t\tfor (int j = 2 * i; j < 10000007; j += i) prime[j] = 1;\n\t\t}\n\t}\n\n\tprime[2] = 1;\n\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) cin >> a[i];\n\n\tvector<int> q, s, t;\n\tfor (int i = 0; i < n; i++){\n\t\tif (check(a[i] - 1)) q.pub(a[i] - 1);\n\t\tif (check(a[i])) q.pub(a[i]);\n\t}\n\n\tfor (int x : q) if (x % 2 == 0) s.pub(x); else t.pub(x);\n\n\tfor (int i = 0; i < s.size(); i++) for (int j = 0; j < t.size(); j++) if (!prime[abs(s[i] - t[j])]){\n\t\tg[i].pub(j);\n\t}\t\n\n\tfor (int i = 0; i < 222; i++) dx[i] = -1, dy[i] = 1;\n\n\tfor (int run = 1; run; ){\n\t\trun = 0;\n\t\tfor (int i = 0; i < s.size(); i++) if (dx[i] == -1 && dfs(i)) run = 1;\n\t}\n\n\tint ans = 0;\n\tint dd = 0;\n\n\tfor (int i = 0; i < s.size(); i++) if (dx[i] != -1) dd++;\n\n\tans += (int)s.size() + (int)t.size() - dd;\n\n\tif (((int)s.size() - dd) % 2 == 1) ans++;\n\n\tcout << ans;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\nusing namespace std;\nconst int N=110*2;\nbool f[10001000],fl[N][N],fla[N];\nint n,p[1000100],cnt,a[N],cot,from[N],nj[N],no[N];\nbool match(int x)\n{\n    if(fla[x]) return false;\n    fla[x]=true;\n    for(int i=1;i<=no[0];++i)\n        if(fl[x][i]&&(from[i]==0||match(from[i])))\n        {\n            from[i]=x;\n            return true;\n        }\n    return false;\n}\nvoid init()\n{\n    for(int i=2;i<=10000500;++i)\n    {\n        if(!f[i]) p[++cnt]=i;\n            for(int j=1;j<=cnt&&p[j]*i<=10000050;++j)\n            {\n                f[p[j]*i]=true;\n                if(i%p[j]==0) break;\n            }\n    }\n}\nint main()\n{\n    ios::sync_with_stdio(false);\n    init();\n    f[1]=true;\n    f[2]=false;\n    cin>>n;\n    int t=-10,t1;\n    for(int i=1;i<=n;++i)\n    {\n        cin>>t1;\n        if(t1-t!=1) \n        {\n            a[cot++]=t+1;\n            a[cot++]=t1;\n        }\n        t=t1;\n    }\n    a[cot]=t1+1;\n    for(int i=1;i<=cot;++i)\n    {\n        if(a[i]%2)\n            nj[++nj[0]]=a[i];\n        else\n            no[++no[0]]=a[i];\n    }\n    for(int i=1;i<=nj[0];++i)\n        for(int j=1;j<=no[0];++j)\n            fl[i][j]=!f[abs(nj[i]-no[j])];\n    int ans=0;\n    for(int i=1;i<=nj[0];++i)\n    {\n        memset(fla,false,sizeof(fla));\n        if(match(i)) ans++;\n    }\n    cout<< ans+(nj[0]-ans)/2*2+(no[0]-ans)/2*2+(nj[0]-ans)%2*3 <<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n\n#define Int register int\n#define int long long\n#define MAXN 10000005\n\nint Abs (int x){return x > 0 ? x : -x;}\n\nint tot;\nint prime[MAXN];\n\nbool vis[MAXN];\n\nvoid Prime (int n)\n{\n\tvis[1] = 1;\n\tfor (Int i = 2;i <= n;++ i)\n\t{\n\t\tif (!vis[i]) prime[++ tot] = i;\n\t\tfor (Int j = 1;j <= tot && i * prime[j] <= n;++ j)\n\t\t{\n\t\t\tvis[i * prime[j]] = 1;\n\t\t\tif (i % prime[j] == 0) break;\n\t\t}\n\t}\n}\n\nbool check (int x){return !vis[x];}\n\nbool rev[MAXN];\n\nint read ()\n{\n\tint x = 0;char c = getchar();int f = 1;\n\twhile (c < '0' || c > '9'){if (c == '-') f = -f;c = getchar();}\n\twhile (c >= '0' && c <= '9'){x = (x << 3) + (x << 1) + c - '0';c = getchar();}\n\treturn x * f;\n}\n\nvoid write (int x)\n{\n\tif (x < 0){x = -x;putchar ('-');}\n\tif (x > 9) write (x / 10);\n\tputchar (x % 10 + '0');\n}\n\nvector <int> s1,s2;\n\n\nvector <int> G[MAXN];\n\nint my[MAXN];\nbool visit[MAXN];\n\nint dfs (int u)\n{\n\tfor (Int i = 0;i < G[u].size();++ i)\n\t{\n\t\tint v = G[u][i];\n\t\tif (visit[v]) continue;\n\t\tvisit[v] = 1;\n\t\tif (my[v] == -1 || dfs (my[v]))\n\t\t{\n\t\t\tmy[v] = u;\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nint Hungry ()\n{\n\tint cnt = 0;\n\tmemset (my,-1,sizeof (my));\n\tfor (Int i = 0;i < s1.size();++ i)\n\t{\n\t\tmemset (visit,0,sizeof (visit));\n\t\tcnt += dfs (i);\n\t}\n\treturn cnt;\n}\n\nsigned main()\n{\n\tint n = read ();\n\tint Maxn = 0;\n\tfor (Int i = 1;i <= n;++ i)\n\t{\n\t\tint x = read ();\n\t\trev[x] ^= 1;\n\t\tMaxn = max (Maxn,x + 1);\n\t}\n\tPrime (Maxn);\n\tfor (Int i = 1;i <= Maxn;++ i)\n\t\tif (rev[i] != rev[i - 1])\n\t\t{\n\t\t\tif (i & 1)\n\t\t\t\ts1.push_back(i);\n\t\t\telse \n\t\t\t\ts2.push_back(i);\n\t\t}\n\tfor (Int i = 0;i < s1.size();++ i)\n\t\tfor (Int j = 0;j < s2.size();++ j)\n\t\t\tif (check (Abs (s1[i] - s2[j])))\n\t\t\t\tG[i].push_back(j); \n\tint Ans = Hungry ();\n\twrite (Ans + (s1.size() - Ans) / 2 * 2 + (s2.size() - Ans) / 2 * 2 + (s1.size() - Ans) % 2 * 3),putchar ('\\n'); \n\treturn 0; \n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<list>\n#include<deque>\n#include<bitset>\n#include<set>\n#include<map>\n#include<unordered_map>\n#include<unordered_set>\n#include<cstring>\n#include<sstream>\n#include<complex>\n#include<iomanip>\n#include<numeric>\n#include<cassert>\n#define X first\n#define Y second\n#define pb push_back\n#define rep(X,Y) for (int (X) = 0;(X) < (Y);++(X))\n#define reps(X,S,Y) for (int (X) = S;(X) < (Y);++(X))\n#define rrep(X,Y) for (int (X) = (Y)-1;(X) >=0;--(X))\n#define rreps(X,S,Y) for (int (X) = (Y)-1;(X) >= (S);--(X))\n#define repe(X,Y) for ((X) = 0;(X) < (Y);++(X))\n#define peat(X,Y) for (;(X) < (Y);++(X))\n#define all(X) (X).begin(),(X).end()\n#define rall(X) (X).rbegin(),(X).rend()\n#define eb emplace_back\n#define UNIQUE(X) (X).erase(unique(all(X)),(X).end())\n#define Endl endl\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntemplate<class T> using vv=vector<vector<T>>;\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"{\"; rep(i,t.size()) {os<<t[i]<<\",\";} os<<\"}\"<<endl; return os;}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\ntemplate<class T> inline bool MX(T &l,const T &r){return l<r?l=r,1:0;}\ntemplate<class T> inline bool MN(T &l,const T &r){return l>r?l=r,1:0;}\n#define out(args...){vector<string> a_r_g_s=s_p_l_i_t(#args, ','); e_r_r(a_r_g_s.begin(), args); }\nvector<string> s_p_l_i_t(const string &s, char c){vector<string> v;int d=0,f=0;string t;for(char c:s){if(!d&&c==',')v.pb(t),t=\"\";else t+=c;if(c=='\\\"'||c=='\\'')f^=1;if(!f&&c=='(')++d;if(!f&&c==')')--d;}v.pb(t);return move(v);}\nvoid e_r_r(vector<string>::iterator it) {}\ntemplate<typename T, typename... Args> void e_r_r(vector<string>::iterator it, T a, Args... args){ if(*it==\" 1\"||*it==\"1\") cerr<<endl; else cerr << it -> substr((*it)[0] == ' ', it -> length()) << \" = \" << a << \", \"; e_r_r(++it, args...);}\nconst ll MOD=1e9+7;\nvector<int> primes,prime;\nclass PRPRPR{\npublic:\n  PRPRPR(int PRIME_MAX){\n    prime.resize(PRIME_MAX);\n    for(int i=2;i<PRIME_MAX;i++)if(!prime[i]){\n\t\t\t\tprimes.pb(i);\n\t\t\t\tfor(int j=i*2;j<PRIME_MAX;j+=i)\n\t\t\t\t\tprime[j]=1;\n      }\n  }\n} prprprpr(11234567);\n\nint dp[111][111];\n\nint main(){\n  ios_base::sync_with_stdio(false);\n  cout<<fixed<<setprecision(0);\n\tint n;\n\tcin>>n;\n\tvector<int> xs(n);\n\trep(i,n) cin>>xs[i];\n\n\tauto Cost=[&](int d){\n\t\tif(!d) return 0;\n\t\tif(d==4) return 2;\n\t\tif(d==1) return 3;\n\t\tif(d%2==0) return 2;\n\t\tif(d>2 && prime[d]==0) return 1;\n\t\treturn 3;\n\t};\n\n\treps(d,1,n+1)rep(i,n+1-d){\n\t\tif(d==xs[i+d-1]-xs[i]+1){\n\t\t\tdp[i][i+d-1]+=Cost(xs[i+d-1]-xs[i]+1);\n\t\t}else{\n\t\t\tdp[i][i+d-1]+=Cost(xs[i+d-1]-xs[i]+1)+Cost(xs[i+d-1]-xs[i]-1)+dp[i+1][i+d-2];\n\t\t}\n\t\treps(c,i,i+d) MN(dp[i][i+d-1], dp[i][c]+dp[c+1][i+d-1]);\n\t}\n\t//rep(i,n){rep(j,n)cout<<dp[i][j]<<\",\";cout<<endl;}\n\tcout<<dp[0][n-1]<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int maxp=10000050;\nint n;\nint sum[105],a[105],l[105],pos[105];\nint tot=0,tot1=0;\nint prime[maxp],primesize;\nbool isprime[maxp];\nvoid getlist(int listsize)\n{\n    memset(isprime,1,sizeof(isprime));\n    isprime[1]=false;\n    for(int i=2;i<=listsize;i++)\n    {\n        if(isprime[i]&&i!=2)\n\t\t\tprime[++primesize]=i;\n\t\tif(!isprime[i])\n\t\t\tcontinue;\n\t\tfor(int j=1;j<=primesize&&i*prime[j]<=listsize;j++)\n\t\t{\n            isprime[i*prime[j]]=false;\n            if(i%prime[j]==0)\n\t\t\t\tbreak;\n        }\n    }\n}\nint main() {\n\tgetlist(maxp-50);\n\tscanf(\"%d\",&n);\n\tsum[++tot]=1;\n\tfor(int i=1;i<=n;i++) {\n\t\tscanf(\"%d\",&a[i]);\n\t\tif(i==1)\n\t\t\tcontinue;\n\t\tif(a[i]==a[i-1]+1)\n\t\t\tsum[tot]++;\n\t\telse {\n\t\t\tif(sum[tot]==1) {\n\t\t\t\tl[++tot1]=tot;\n\t\t\t\tpos[tot1]=a[i-1];\n\t\t\t}\n\t\t\tsum[++tot]=1;\n\t\t}\n\t}\n\tif(sum[tot]==1) {\n\t\tl[++tot1]=tot;\n\t\tpos[tot1]=a[n];\n\t}\n\tint sumx=0;\n\tfor(int i=1;i<=tot;i++) {\n\t\tint tmp=sum[i];\n\t\tif(isprime[tmp]&&tmp!=2) {\n\t\t\tsumx++;\n\t\t\tcontinue;\n\t\t}\n\t\telse if(tmp%2==0) {\n\t\t\tsumx+=2;\n\t\t\tcontinue;\n\t\t}\n\t\telse if(tmp%2==1&&tmp!=1) {\n\t\t\tsumx+=3;\n\t\t\tcontinue;\n\t\t}\n\t\telse if(tmp==1)\n\t\t\tcontinue;\n\t}\n//\tcout<<tot1<<endl;\n\tfor(int i=1;i<=tot1;) {\n\t\tif(i<tot1) {\n\t\t\tif(l[i]==l[i+1]-1) {\n\t\t\t\tint tmp=pos[i+1],tmp1=pos[i];\n\t\t\t\tint tmp2=tmp-tmp1-1;\n\t\t\t\tint tmp3=tmp-tmp1;\n\t\t\t\tint tmp4=tmp-tmp1+1;\n\t\t\t\tif(isprime[tmp3]) {\n\t\t\t\t\tsumx+=2;\n\t\t\t\t\ti+=2;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\telse if(tmp2%2==0) {\n\t\t\t\t\tsumx+=4;\n\t\t\t\t\ti+=2;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\telse if(isprime[tmp2]&&isprime[tmp4]) {\n\t\t\t\t\tsumx+=2;\n\t\t\t\t\ti+=2;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\telse if((isprime[tmp2]&&!isprime[tmp4])||(isprime[tmp4]&&!isprime[tmp2])) {\n\t\t\t\t\tsumx+=4;\n\t\t\t\t\ti+=2;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\telse if(!isprime[tmp2]&&!isprime[tmp4]) {\n\t\t\t\t\tsumx+=6;\n\t\t\t\t\ti+=2;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsumx+=3;\n\t\t\t\ti++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\telse if(i==tot1) {\n\t\t\tsumx+=3;\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\t}\n\tprintf(\"%d\\n\",sumx);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define Mem(a,b) memset(a,b,sizeof(a))\n#define ll long long\n#define lson root<<1\n#define rson root<<1|1\n#define Mid int mid=(l+r)>>1\n#define FREI freopen(\"in.txt\",\"r\",stdin)\n#define FREO freopen(\"out.txt\",\"w\",stdout)\n#define inf 0x3f3f3f3f\n#define mod 1000000007\n#define PB push_back\nusing namespace std;\nconst int MAXN=1e7+10;\nint n;\nint vis[200];\nstruct fc{\n    int v,cost;\n};\nvector<int>point;\nvector<int>X,Y;\nvector<fc>G[110];\nbool used[220];\nint pre[220];\nvoid pretreat(){\n    Mem(vis,0);\n    scanf(\"%d\",&n);\n    for(int i=0;i<n;i++){\n        int x;\n        scanf(\"%d\",&x);\n        vis[i]=x;\n    }\n    sort(vis,vis+n);\n    for(int i=0;i<n;i++){\n        if(i==0) point.PB(vis[i]);\n        if(i>0&&vis[i]!=vis[i-1]+1) {\n            point.PB(vis[i]);\n        }\n        if(vis[i+1]!=vis[i]+1){\n            point.PB(vis[i]+1);\n        }\n    }\n    for(auto u:point){\n        //cout<<u<<' ';\n        if(u&1) Y.push_back(u);\n        else X.push_back(u);\n    }\n    //cout<<endl;\n}\nvoid build_graph(){\n    for(int i=0;i<X.size();i++){\n        for(int j=0;j<Y.size();j++){\n            G[i+1].PB({j+1,abs(Y[j]-X[i])});\n        }\n    }\n}\nbool isprime(int x){\n    for(int i=2;i*i<=x;i++){\n        if(x%i==0) return false;\n    }\n    return true;\n}\nbool dfs(int u){\n    for(int i=0;i<G[u].size();i++){\n        int v=G[u][i].v,cost=G[u][i].cost;\n        if(!used[v]&&isprime(cost)){\n            used[v]=1;\n            if(!pre[v]&&dfs(pre[v])){\n                pre[v]=u;\n                return true;\n            }\n        }\n    }\n    return false;\n}\nint solve(){\n    Mem(pre,0);\n    int ans=0;\n    for(int i=1;i<=X.size();i++){\n        Mem(used,0);\n        if(dfs(i)) ans++;\n    }\n    return ans+(X.size()-ans)/2*2+(Y.size()-ans)/2*2+((X.size()-ans)%2)*3;\n}\nint main() {\n    //FREI;\n    pretreat();\n    build_graph();\n    printf(\"%d\\n\",solve());\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define inf (1e9 + 7)\n#define mem(a, b) memset(a, b, sizeof(a))\nusing namespace std;\n\nint pp[10000005], n, num[105], num2[205], nn = 0, ji = 0, ou = 0, lk[205], ans = 0;\nbool vis[205];\nvector<int> eg[205];\nmap<int, int> mps;\n\nvoid inits()\n{\n    mem(lk, -1);\n    for(int i = 2;i <= 10000000;i++)\n    {\n        if(!pp[i])\n            pp[++pp[0]] = i;\n        for(int j = 1;j <= pp[0]&&10000000 / i >= pp[j];j++)\n        {\n            pp[i * pp[j]] = 1;\n            if(i % pp[j] == 0)\n                break;\n        }\n    }\n}\n\nbool dfs(int u)\n{\n    int lim = eg[u].size();\n    for(int i = 0;i < lim;i++)\n    {\n        int v = eg[u][i];\n        if(!vis[v])\n        {\n            vis[v] = 1;\n            if(lk[v] == -1||dfs(lk[v]))\n            {\n                lk[v] = u;\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\nint main()\n{\n    inits();\n    int mx = 0;\n    scanf(\"%d\", &n);\n    for(int i = 1;i <= n;i++)\n        scanf(\"%d\", &num[i]);\n    sort(num + 1, num + 1 + n);\n    num2[++nn] = num[1];\n    for(int i = 2;i <= n;i++)\n    {\n        if(num[i] - 1 != num[i - 1])\n        {\n            num2[++nn] = num[i - 1] + 1;\n            num2[++nn] = num[i];\n        }\n    }\n    num2[++nn] = num[n] + 1;\n    for(int i = 1;i <= nn;i++)\n    {\n        if(num2[i] % 2 == 0)\n        {\n            ou++;\n            continue;\n        }\n        else\n            ji++;\n        for(int j = 2;j <= pp[0];j++)\n        {\n            if(num2[i] + pp[j] > mx)\n                break;\n            if(mps.find(num2[i] + pp[j]) != mps.end())\n            {\n                int pos = mps[num2[i] + pp[j]];\n                eg[i].push_back(pos);\n            }\n        }\n    }\n    int res = 0;\n    for(int i = 1;i <= nn;i++)\n    {\n        if(num2[i] % 2 == 0)\n            continue;\n        mem(vis, 0);\n        if(dfs(i))\n            res++;\n    }\n    ans += res;\n    ji -= res;\n    ou -= res;\n    ans += ji / 2 * 2;\n    ji %= 2;\n    ans += ou / 2 * 2;\n    ou %= 2;\n    if(ji||ou)\n        ans += 3;\n    printf(\"%d\\n\", ans);\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define For(i,j,k) for(int i=j;i<=k;++i)\n#define Forr(i,j,k) for(int i=j;i>=k;--i)\n#define Rep(i,u) for(int i=Begin[u],v=to[i];i;i=Next[i],v=to[i])\n#define ll long long \nusing namespace std;\nconst int N=210,INF=0x3f3f3f3f;\ntemplate<class T>void read(T &x){\n\tx=0;char c=getchar();\n\twhile(!isdigit(c))c=getchar();\n\twhile( isdigit(c))x=x*10+c-48,c=getchar();\n}\nint n,Link[N],Begin[N],Next[N*N],to[N*N],e;\ninline void add(int x,int y){\n\tto[++e]=y,Next[e]=Begin[x],Begin[x]=e;\n}\ninline void file(){\n#ifndef ONLINE_JUDGE\n\tfreopen(\"test.in\",\"r\",stdin);\n\tfreopen(\"test.out\",\"w\",stdout);\n#endif \n}\nint X[N],x[N],y[N],totx,toty;\n\nnamespace divide{\n\tconst int N=70,S=13,pri[S]={2,3,5,7,11,13,17,19,23,29,31,37,41};\n\tll pr[N],p[N];int c[N],cnt;\n\tll qpow(ll a,ll b,ll P){\n\t\tll ret=1;\n\t\tfor(;b;b>>=1,a=a*a%P)if(b&1)ret=ret*a%P;\n\t\treturn ret;\n\t}\n\tinline bool Miller_Rabin(ll x){\n\t\tint C=0,Times=S;\n\t\tll val,t=x-1,lst;\n\t\tFor(i,0,S-1)if(x==pri[i])return 1;\n\t\tif(x==1)return 0;\n\t\twhile(!(t&1))C++,t>>=1;\n\t\twhile(Times--){\n\t\t\tll a=pri[Times]%x;\n\t\t\tlst=qpow(a,t,x);\n\t\t\tFor(i,1,C){\n\t\t\t\tval=lst*lst%x;\n\t\t\t\tif(val==1&&lst!=x-1&&lst!=1)return 0;\n\t\t\t\tlst=val;\n\t\t\t}\n\t\t\tif(val!=1)return 0;\n\t\t}\n\t\treturn 1;\n\t}\n}namespace D=divide;\nbool check(int p){\n\tif(p==2)return 0;\n\treturn D::Miller_Rabin(p);\n}\nvoid init(){\n\tread(n);\n\tFor(i,1,n)read(X[i]);\n\tX[0]=-1;\n\tFor(i,1,n){\n\t\tif(X[i-1]!=X[i]-1){\n\t\t\tif(X[i]&1)x[++totx]=X[i];\n\t\t\telse y[++toty]=X[i];\n\t\t}\n\t\tif(X[i+1]!=X[i]+1){\n\t\t\tif((X[i]+1)&1)x[++totx]=X[i]+1;\n\t\t\telse y[++toty]=X[i]+1;\n\t\t}\n\t}\n\t//For(i,1,totx)printf(\"%d \",x[i]);puts(\"\");\n\t//For(i,1,toty)printf(\"%d \",y[i]);puts(\"\");\n\tFor(i,1,totx)\n\t\tFor(j,1,toty)\n\t\t\tif(check(abs(y[j]-x[i])))add(i,j);\n}\nint vis[N];\nbool Hungary(int u){\n\tRep(i,u)if(!vis[v]){\n\t\tvis[v]=1;\n\t\tif(!Link[v]||Hungary(v))return Link[v]=u,1;\n\t}\n\treturn 0;\n}\nvoid solve(){\n\tint ret=0,ans=0;\n\tFor(i,1,totx){\n\t\tFor(j,1,toty)vis[j]=0;\n\t\tret+=Hungary(i);\n\t}\n\tans=ret;\n\tans+=(totx-ret)/2*2;\n\tans+=(toty-ret)/2*2;\n\tif(ret%2!=totx%2)ans+=3;\n\tprintf(\"%d\\n\",ans);\n}\nint main(){\n\tinit();\n\tsolve();\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#define fo(i,a,b) for(int i=a;i<=b;i++)\n#define fd(i,b,a) for(int i=b;i>=a;i--)\n#define efo(i,u,v) for(int i=BB[u],v=B[BB[u]][1];i;v=B[i=B[i][0]][1])\n#define mset(a,x) memset(a,x,sizeof(a))\nusing namespace std;\ntypedef long long ll;\nchar ch;\nint read(){int n=0,p=1;for(ch=getchar();ch<'0' || '9'<ch;ch=getchar())if(ch=='-') p=-1;for(;'0'<=ch && ch<='9';ch=getchar()) n=n*10+ch-'0';return n*p;}\nconst int N=105,M=1e7+5;\nint n,m,a[N],d[N<<1],pr[M];\nbool b[M],c[M],bz[M];\nvoid prep()\n{\n\tmset(bz,1);\n\tbz[0]=bz[1]=0;\n\tfo(i,2,m)\n\t{\n\t\tif(bz[i]) pr[++pr[0]]=i;\n\t\tfo(j,1,pr[0])\n\t\t{\n\t\t\tll x=(ll)i*pr[j];\n\t\t\tif(x>m) break;\n\t\t\tbz[x]=0;\n\t\t\tif(i%pr[j]==0) break;\n\t\t}\n\t}\n}\n\nconst int V=N<<2,INF=1e9;\nconst int E=4*V*V;\nint ans,B0,S,T,BB[V],dis[V],B[E][4];\nbool vis[V];\nvoid link(int u,int v,int r,int w)\n{\n\tB[++B0][1]=v,B[B0][2]=r,B[B0][3]=w,B[B0][0]=BB[u],BB[u]=B0;\n\tif(!(B0&1)) link(v,u,0,-w);\n}\nint aug(int v,int flow)\n{\n\tvis[v]=1;\n\tif(v==T) \n\t{\n\t\tans+=dis[S]*flow;\n\t\treturn flow;\n\t}\n\tefo(i,v,u)\n\t\tif(B[i][2] && dis[v]==dis[u]+B[i][3])\n\t\t{\n\t\t\tint f=aug(u,min(flow,B[i][2]));\n\t\t\tif(f)\n\t\t\t{\n\t\t\t\tB[i][2]-=f,B[i^1][2]+=f;\n\t\t\t\treturn f;\n\t\t\t}\n\t\t}\n\treturn 0;\n}\nbool change()\n{\n\tint minh=INF;\n\tfo(u,S,T) if(vis[u])\n\t\tefo(i,u,v) if(!vis[v])\n\t\t\tif(B[i][2]) minh=min(minh,dis[u]+B[i][3]-dis[v]);\n\tif(minh==INF) return 0;\n\tfo(i,S,T) if(vis[i]) dis[i]+=minh;\n\treturn 1;\n}\nint main()\n{\n\tn=read();\n\tfo(i,1,n) b[a[i]=read()]=1,m=max(m,a[i]);\n\t++m;\n\tprep();\n\tfo(i,1,m) c[i]=b[i]^b[i-1];\n\tfo(i,1,m) if(c[i]) d[++d[0]]=i;\n\t\n\tB0=1,S=0,T=d[0]+d[0]+1;\n\tfo(i,1,d[0]-1)\n\t\tfo(j,i+1,d[0])\n\t\t{\n\t\t\tif((d[j]-d[i])%2==0) link(i,d[0]+j,1,2),link(j,d[0]+i,1,2);\n\t\t\telse\n\t\t\tif(bz[d[j]-d[i]]) link(i,d[0]+j,1,1),link(j,d[0]+i,1,1);\n\t\t\telse link(i,d[0]+j,1,3),link(j,d[0]+i,1,3);\n\t\t}\n\tfo(i,1,d[0]) link(S,i,1,0),link(d[0]+i,T,1,0);\n\t\n\tdo\n\t{\n\t\twhile(aug(S,INF)) mset(vis,0);\n\t}\n\twhile(change());\n\tprintf(\"%d\",ans/2);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\ninline int read()\n{\n\tint x;char c;\n\twhile((c=getchar())<'0'||c>'9');\n\tfor(x=c-'0';(c=getchar())>='0'&&c<='9';)x=x*10+c-'0';\n\treturn x;\n}\n#define MX 10000001\nint p[MX+5],pn,u[MX+5],v[MX+5],a[MX+5],an,b[MX+5],bn;\nnamespace MaxFlow\n{\n\tconst int MV=200,ME=10200,S=MV+1,T=MV+2,INF=0x7FFFFFFF;\n\tstruct edge{int nx,t,w;}e[ME*2+5];\n\tint h[MV+5],en=1,d[MV+5],q[MV+5],qn,c[MV+5];\n\tinline void ins(int x,int y,int w)\n\t{\n\t\te[++en]=(edge){h[x],y,w};h[x]=en;\n\t\te[++en]=(edge){h[y],x,0};h[y]=en;\n\t}\n\tbool bfs()\n\t{\n\t\tint i,j;\n\t\tmemset(d,0,sizeof(d));\n\t\tfor(d[q[i=qn=0]=S]=1;i<=qn;++i)for(j=c[q[i]]=h[q[i]];j;j=e[j].nx)\n\t\t\tif(e[j].w&&!d[e[j].t])d[q[++qn]=e[j].t]=d[q[i]]+1;\n\t\treturn d[T];\n\t}\n\tint dfs(int x,int r)\n\t{\n\t\tif(x==T)return r;\n\t\tint k,u=0;\n\t\tfor(int&i=c[x];i;i=e[i].nx)if(e[i].w&&d[e[i].t]==d[x]+1)\n\t\t{\n\t\t\tk=dfs(e[i].t,r-u<e[i].w?r-u:e[i].w);\n\t\t\tu+=k;e[i].w-=k;e[i^1].w+=k;\n\t\t\tif(u==r)return r;\n\t\t}\n\t\treturn d[x]=0,u;\n\t}\n\tint dinic(){int ans=0;while(bfs())ans+=dfs(S,INF);return ans;}\n};\nint main()\n{\n\tint n,i,j,ans=0;\n\tfor(u[1]=1,i=2;i<=MX;++i)\n\t{\n\t\tif(!u[i])p[++pn]=i;\n\t\tfor(j=1;i*p[j]<=MX;++j){u[i*p[j]]=1;if(i%p[j]==0)break;}\n\t}\n\tfor(n=read();n--;)v[i=read()]^=1,v[i+1]^=1;\n\tfor(i=1;i<=MX;++i)if(v[i])i&1?a[++an]=i:b[++bn]=i;\n\tusing namespace MaxFlow; \n\tfor(i=1;i<=an;++i)ins(S,i,1);\n\tfor(j=1;j<=bn;++j)ins(an+j,T,1);\n\tfor(i=1;i<=an;++i)for(j=1;j<=bn;++j)if(!u[abs(a[i]-b[j])])ins(i,an+j,1);\n\tans=dinic();\n\tans+=((an-ans)&1)+(an+bn-2*ans);\n\tprintf(\"%d\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n#include<cstring>\n\nusing namespace std;\nusing vi = vector<int>;\nvi X;\nint n;\nvector<vi> C;\nint used[207];\nint S;\nbool isprime(int n) {\n\tif (n <= 2)return false;\n\tfor (int i = 2; i*i <= n; i++) {\n\t\tif (n%i == 0)return false;\n\t}\n\treturn true;\n}\nbool dfs(int v) {\n\tused[v] = true;\n\tif (v == S + 1) return true;\n\tfor (int i = 0; i < S + 2; i++) {\n\t\tif (!used[i] && C[v][i] > 0) {\n\t\t\tif (dfs(i)) {\n\t\t\t\tC[v][i]--;\n\t\t\t\tC[i][v]++;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\nint main() {\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) {\n\t\tint x;\n\t\tcin >> x;\n\t\tif (!X.empty() && X.back() == x) {\n\t\t\tX.pop_back();\n\t\t\tX.push_back(x + 1);\n\t\t}\n\t\telse {\n\t\t\tX.push_back(x);\n\t\t\tX.push_back(x + 1);\n\t\t}\n\t}\n\tint E = 0;\n\tint O = 0;\n\tfor (int x : X) {\n\t\tif (x % 2 == 0) {\n\t\t\tE++;\n\t\t}\n\t\telse {\n\t\t\tO++;\n\t\t}\n\t}\n\tS = X.size();\n\tC.resize(S+2,vi(S+2,0));\n\tfor (int i = 0; i < S; i++) {\n\t\tif (X[i] % 2 == 0) {\n\t\t\tC[S][i] = 1;\n\t\t}\n\t\telse {\n\t\t\tC[i][S + 1] = 1;\n\t\t}\n\t}\n\tfor (int i = 0; i < S; i++) {\n\t\tfor (int j = i; j < S; j++) {\n\t\t\tif (isprime(abs(X[i] - X[j]))) {\n\t\t\t\tint a = i;\n\t\t\t\tint b = j;\n\t\t\t\tif (X[b] % 2 == 0)swap(a, b);\n\t\t\t\tC[a][b] = 1;\n\t\t\t}\n\t\t}\n\t}\n\tint ans = 0;\n\twhile (dfs(S)) {\n\t\tmemset(used, 0, sizeof(used));\n\t\tans++;\n\t}\n\tif ((E - ans) % 2 == 0) {\n\t\tcout << ans + (E - ans + O - ans) << endl;\n\t}\n\telse {\n\t\tcout << ans + (E - ans - 1 + O - ans - 1) + 3 << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int maxn=1e7+10;\nint n,a[110],b[110],m,ans;\nint b1[110],b2[110],p1,p2;\nbool np[maxn],vis[110],g[110][110],s[maxn];\nint match[110];\nvector<int> p;\n\nvoid init(){\n\tnp[0]=np[1]=1;\n\tfor(int i=2;i<maxn;++i){\n\t\tif(!np[i]){\n\t\t\tp.push_back(i);\n\t\t\t//cerr<<i<<endl;\n\t\t\t//system(\"pause\");\n\t\t}\n\t\tfor(int j=0,j_end=p.size(),x;j<j_end&&(x=p[j]*i)<maxn;++j){\n\t\t\tnp[x]=true;\n\t\t\tif(i%p[j]==0)break;\n\t\t}\n\t}\n}\n\nbool dfs(int u){\n\tif(vis[u])return false;\n\tvis[u]=1;\n\tfor(int i=1;i<=p2;++i)if(g[u][i]){\n\t\tif(!match[i]||dfs(match[i])){\n\t\t\tmatch[i]=u;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\nvoid solve(){\n\tinit();\n\tcin>>n;\n\tfor(int i=1;i<=n;++i){cin>>a[i];s[a[i]]=1;}\n\tfor(int i=1;i<maxn;++i){\n\t\tif(s[i]!=s[i-1])b[++m]=i;\n\t}\n\tfor(int i=1;i<=m;++i){\n\t\tif(b[i]&1)b1[++p1]=b[i];\n\t\telse b2[++p2]=b[i];\n\t}\n\t//cerr<<p1<<\" \"<<p2<<endl;\n\tfor(int i=1;i<=p1;++i){\n\t\tfor(int j=1;j<=p2;++j){\n\t\t\tif(!np[abs(b1[i]-b2[j])]){\n\t\t\t\tg[i][j]=true;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor(int i=1;i<=p1;++i){\n\t\tif(!match[i]){\n\t\t\tmemset(vis,0,sizeof vis);\n\t\t\tif(dfs(i))++ans;//match()\n\t\t}\n\t}\n\tp1-=ans;p2-=ans;\n\t//cerr<<ans<<endl;\n\tans+=p1/2*2+p2/2*2;\n\tans+=p1%2*3;\n\tcout<<ans<<endl;\n}\nint main(){\n\tsolve();\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int max_n = 1e2 + 5, max_x = 1e7 + 5;\n\nbool sito[max_x];\n\nint dodaj(int x){\n    if (x % 2){\n        if (!sito[x])\n            return 1;\n        else\n            return 3;\n    }\n    return 2;\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    sito[1] = true;\n    for (int i = 2; i * i <= 1e7; i++)\n        if (!sito[i])\n            for (int j = i * i; j <= 1e7; j += i)\n                sito[j] = true;\n    int n, poprzedni_1 = 0, aktu_1 = 0, ile = 0, wynik = 0, poprzedni_2 = 0, aktu_2 = 0, koniec = 0, pom_1, pom_2 = 0;\n    cin >> n;\n    for (int i = 0; i < n; i++){\n        cin >> pom_1;\n        if (i && pom_1 != pom_2 + 1){\n            wynik += dodaj(ile);\n            if (koniec){\n                aktu_1 = poprzedni_2 + dodaj(pom_2 - ile - koniec);\n                aktu_2 = max(poprzedni_1, poprzedni_2);\n                poprzedni_1 = aktu_1;\n                poprzedni_2 = aktu_2;\n            }\n            koniec = pom_2;\n            ile = 0;\n        }\n        pom_2 = pom_1;\n        ile++;\n    }\n    wynik += dodaj(ile);\n    if (koniec){\n        aktu_1 = poprzedni_2 + dodaj(pom_2 - ile - koniec);\n        aktu_2 = max(poprzedni_1, poprzedni_2);\n        poprzedni_1 = aktu_1;\n        aktu_2 = poprzedni_2;\n    }\n    //cout << sito[9999539] << \"\\n\";\n    cout << wynik - max(aktu_1, aktu_2) << \"\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define ii pair <int, int>\n#define app push_back\n#define all(a) a.begin(), a.end()\n#define bp __builtin_popcountll\n#define ll long long\n#define mp make_pair\n#define f first\n#define s second\n#define Time (double)clock()/CLOCKS_PER_SEC\n#define debug(x) std::cout << #x << \": \" << x << '\\n';\n\nnamespace Mag {\n#define forn(i, n) for (int i = 0; i < (int)(n); ++i)\nconst int maxn = 505;\ntypedef vector<int> vi;\n\n// BEGIN_CODE\nint n;\nvi e[maxn];\nint mt[maxn], p[maxn], base[maxn], b[maxn], blos[maxn];\nint q[maxn];\nint blca[maxn]; // used for lca\n\nvoid clear() {\n    for (int i = 0; i < maxn; ++i)  \n        e[i].clear();\n    memset(mt, 0, sizeof mt);\n    memset(p, 0, sizeof p);\n    memset(base, 0, sizeof base);\n    memset(b, 0, sizeof b);\n    memset(blos, 0, sizeof blos);\n    memset(q, 0, sizeof q);\n    memset(blca, 0, sizeof blca);\n}   \n\nint lca(int u, int v) {\n    forn(i, n) blca[i] = 0;\n    while (true) {\n        u = base[u];\n        blca[u] = 1;\n        if (mt[u] == -1) break;\n        u = p[mt[u]];\n    }\n    while (!blca[base[v]]) {\n        v = p[mt[base[v]]];\n    }\n    return base[v];\n}\n\nvoid mark_path(int v, int b, int ch) {\n    while (base[v] != b) {\n        blos[base[v]] = blos[base[mt[v]]] = 1;\n        p[v] = ch;\n        ch = mt[v];\n        v = p[mt[v]];\n    }\n}\n\nint find_path(int root) {\n    forn(i, n) {\n        base[i] = i;\n        p[i] = -1;\n        b[i] = 0;\n    }\n\n    b[root] = 1;\n    q[0] = root;\n    int lq = 0, rq = 1;\n    while (lq != rq) {\n        int v = q[lq++];\n        for (int to: e[v]) {\n            if (base[v] == base[to] || mt[v] == to) continue;\n            if (to==root || (mt[to] != -1 && p[mt[to]] != -1)) {\n                int curbase = lca(v, to);\n                forn(i, n) blos[i] = 0;\n                mark_path(v, curbase, to);\n                mark_path(to, curbase, v);\n                forn(i, n) if (blos[base[i]]) {\n                    base[i] = curbase;\n                    if (!b[i]) b[i] = 1, q[rq++] = i;\n                }\n            } else if (p[to] == -1) {\n                p[to] = v;\n                if (mt[to] == -1) {\n                    return to;\n                }\n                to = mt[to];\n                b[to] = 1;\n                q[rq++] = to;\n\n            }\n        }\n    }\n    return -1;\n}\n\nint matching() {\n    forn(i, n) mt[i] = -1;\n    int res = 0;\n    forn(i, n) if (mt[i] == -1) {\n        int v = find_path(i);\n        if (v != -1) {\n            ++res;\n            while (v != -1) {\n                int pv = p[v], ppv = mt[p[v]];\n                mt[v] = pv, mt[pv] = v;\n                v = ppv;\n            }\n        }\n    }\n    return res;\n}\n// END_CODE\n\nint match(int n_, int m, vector <ii> ed) {\n    clear();\n\n    n = n_;\n    for (auto t : ed) {\n        e[t.f].app(t.s);\n        e[t.s].app(t.f);\n    }   \n    int res = matching();\n    return res;\n}\n\n};\n\nconst int N = 207;\nconst int INF = 1e9+7;\nconst int C = 1e7+7;\n\nbool used[N];\n\nbool p[C];\n\nint get(int a, int b) {\n    if (b < a)\n        swap(a, b);\n\n    if ((b - a) % 2 == 0)\n        return 2;\n    else if (p[b-a])\n        return 1;\n    else\n        return 3;\n}\n\nint cost[N][N];\nint dp[1 << 20];\n\nsigned main() {\n    #ifdef HOME\n    freopen(\"input.txt\", \"r\", stdin);\n    #else\n    #define endl '\\n'\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    #endif\n    for (int i = 2; i < C; ++i)\n        p[i] = 1;\n    for (int i = 2; i < C; ++i) \n        if (p[i])\n            for (int j = i * 2; j < C; j += i)\n                p[j] = 0;\n\n    int n;\n    cin >> n;\n    map <int, int> d;\n    while (n--) {\n        int x;\n        cin >> x;\n        d[x] ^= 1;\n        d[x+1] ^= 1;        \n    }\n\n    vector <int> c;\n    for (auto e : d) {\n        if (e.s)\n            c.app(e.f);\n    }   \n\n    #ifdef HOME\n    cout << \"C : \";\n    for (auto e : c)\n        cout << e << ' ';\n    cout << endl;\n    #endif\n\n    int ans = 0;\n    vector <ii> ed;\n    for (int i = 0; i < c.size(); ++i) {\n        for (int j = i + 1; j < c.size(); ++j) {\n            if (get(c[i], c[j]) == 1) {\n                ++ans;\n                ed.app(mp(i,j));\n            }\n        }   \n    }    \n    vector <int> cnt(2);\n    for (auto e : c)\n        cnt[e&1]++;\n    for (int t = 0; t < 2; ++t)\n        cnt[t] -= ans;\n\n    for (int t = 0; t < 2; ++t) {\n        ans += cnt[t] - (cnt[t]&1);\n        cnt[t] &= 1;\n    }\n\n    if (cnt[0]) {\n        ans += 3;\n    }   \n\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <bits/stdc++.h>\n     \n#define uint unsigned int\n#define ll long long\n#define ull unsigned long long\n#define ld long double\n#define rep(i, l, r) for (int i = l; i < r; i++)\n#define repb(i, r, l) for (int i = r; i > l; i--)\n#define sz(a) (int)a.size()\n#define fi first\n#define se second\n#define mp(a, b) make_pair(a, b)\n\nusing namespace std;\n\nconst int N = 200000;\nconst int inf = (int)1e9 + 1;\nconst ll big = (ll)1e18 + 1;\nconst int P = 239;\nconst int MOD = (int)1e9 + 7;\nconst int MOD1 = (int)1e9 + 9;\nconst double eps = 1e-6;\nconst double pi = atan2(0, -1);\nconst int ABC = 26;\n\nbool prime(int x)\n{\n    if (x < 3)\n        return false;\n    for (int i = 2; i * i <= x; i++)\n        if (x % i == 0)\n            return false;\n    return true;\n}\n\nvector<int> p0, p1;\n\nvoid add(int x)\n{\n    if (x % 2 == 0)\n        p0.push_back(x);\n    else\n        p1.push_back(x);\n}\n\nvector<vector<int> > g;\nvector<bool> used;\nvector<int> mt;\n\nbool dfs(int u)\n{\n    if (used[u])\n        return false;\n    used[u] = true;\n    for (int v : g[u])\n        if (mt[v] == -1 || dfs(mt[v]))\n        {\n            mt[v] = u;\n            return true;\n        }\n    return false;\n}\n\nint main()\n{\n    //freopen(\"a.in\", \"r\", stdin);\n    //freopen(\"a.out\", \"w\", stdout);\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cout.precision(20);\n    cout << fixed;\n    //ll TL = 1.95 * CLOCKS_PER_SEC;\n    //clock_t time = clock();\n    int n;\n    cin >> n;\n    int a[n];\n    rep(i, 0, n)\n        cin >> a[i];\n    sort(a, a + n);\n    rep(i, 0, n)\n    {\n        if (i == 0 || a[i - 1] != a[i] - 1)\n            add(a[i] - 1);\n        if (i == n - 1 || a[i + 1] != a[i] + 1)\n            add(a[i]);\n    }\n    n = sz(p0); int m = sz(p1);\n    g.resize(n);\n    rep(i, 0, n)\n        rep(j, 0, m)\n            if (prime(abs(p0[i] - p1[j])))\n                g[i].push_back(j);\n    used.resize(n);\n    mt.resize(m, -1);\n    rep(i, 0, n)\n    {\n        used.assign(n, false);\n        dfs(i);\n    }\n    int ans = 0;\n    rep(i, 0, m)\n        if (mt[i] != -1)\n            ans++;\n    cout << ans + (n - ans) / 2 * 2 + (m - ans) / 2 * 2 + ((n - ans) % 2 == 1 && (m - ans) % 2 == 1 ? 3 : 0) << \"\\n\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <cstring>\n#include <cmath>\nusing namespace std;\n\nconst int MAX_N = 100 + 9;\nconst int MAX_M = 1e7 + 9;\n\nint N, x, cnt, match[MAX_N * 2], V;\nbool is_prime[MAX_M + 1], rev[MAX_M + 1], used[MAX_N * 2];\nvector<int> primes, v1, v2, G[MAX_N * 2];\n\nvoid sieve() {\n\tmemset(is_prime, 1, sizeof(is_prime));\n\tis_prime[0] = is_prime[1] = 0;\n\tfor (int i = 2; i <= MAX_M; i++) {\n\t\tif (is_prime[i]) {\n\t\t\tprimes.push_back(i);\n\t\t\tfor (int j = i * 2; j <= MAX_M; j += i) is_prime[j] = 0;\n\t\t}\n\t}\n}\n\nbool dfs(int v) {\n\tused[v] = true;\n\tfor (int i = 0; i < G[i].size(); i++) {\n\t\tint u = G[u][i], w = match[u];\n\t\tif (w < 0 || !used[u] && dfs(w)) {\n\t\t\tmatch[v] = u;\n\t\t\tmatch[u] = v;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nvoid bipartite_matching() {\n\tmemset(match, -1, sizeof(match));\n\tfor (int v = 0; v < V; v++) {\n\t\tif (match[v] < 0) {\n\t\t\tmemset(used, 0, sizeof(used));\n\t\t\tif (dfs(v)) {\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\tscanf(\"%d\", &N); sieve();\n\tfor (int i = 1; i <= N; i++) scanf(\"%d\", &x), rev[x] ^= true;\n\tfor (int i = 1; i <= MAX_M; i++) {\n\t\tif (rev[i] != rev[i - 1]) {\n\t\t\tif (i & 1) v1.push_back(i);\n\t\t\telse v2.push_back(i);\n\t\t}\n\t}\n\tfor (int i = 0; i < v1.size(); i++) {\n\t\tfor (int j = 0; j < v2.size(); j++) {\n\t\t\tif (is_prime[(int)abs(v1[i] - v2[j])]) G[i].push_back(j + v1.size());\n\t\t}\n\t}\n\tV = v1.size() + v2.size();\n\tbipartite_matching();\n\tprintf(\"%d\", cnt + (v1.size() - cnt >> 1 << 1) + (v2.size() - cnt >> 1 << 1) + ((v1.size() - cnt) & 1) * 3);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdlib>\n#include<vector>\n#include<cstring>\nusing namespace std;\nconst int N=205,M=1e7+10;\nint n,a[N],pri[M/10],tot,ans;\nbool vis[M],b[M],ur[N];\nint ld[N],rd[N],cl,cr,even,odd;\nint lf[N];\nvector<int>G[N];\nvoid sieve(int n){\n\tvis[1]=1;\n\tfor(int i=2;i<=n;++i){\n\t\tif(!vis[i])pri[++tot]=i;\n\t\tfor(int j=1;j<=tot&&i*pri[j]<=n;++j){\n\t\t\tvis[i*pri[j]]=1;\n\t\t\tif(i%pri[j]==0)break;\n\t\t}\n\t}\n}\nbool dfs(int u){\n\tfor(int to:G[u])\n\tif(!ur[to]){\n\t\tur[to]=1;\n\t\tif(!lf[to]||dfs(lf[to])){\n\t\t\tlf[to]=u;\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\nint main(){\n\tios::sync_with_stdio(0),cin.tie(0),cout.tie(0);\n\tcin>>n;\n\tfor(int i=1;i<=n;++i){\n\t\tcin>>a[i];\n\t\tb[a[i]]=1;\n\t}\n\tfor(int i=10000001;i;--i)if(b[i]^=b[i-1]){\n\t\tif(i&1)ld[++cl]=i;else rd[++cr]=i;\n\t}\n\tsieve(10000000);\n\tfor(int i=1;i<=cl;++i)\n\tfor(int j=1;j<=cr;++j)if(!vis[abs(ld[i]-rd[j])])G[i].push_back(j);\n\tmemset(lf,0,sizeof lf);\n\tfor(int i=1;i<=cl;++i){\n\t\tmemset(ur,0,sizeof ur);\n\t\tans+=dfs(i);\n\t}\n\tmemset(ur,0,sizeof ur);\n\tfor(int i=1;i<=cr;++i)ur[lf[i]]=1;\n\tfor(int i=1;i<=cl;++i)if(!ur[i])++odd;\n\tfor(int i=1;i<=cr;++i)if(!lf[i])++even;\n\tans+=(odd>>1<<1)+(even>>1<<1)+(odd&1)*3;\n\tcout<<ans<<'\\n';\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define x first\n#define y second\n#define mp make_pair\n#define all(a) a.begin(), a.end()\n#define pub push_back\n#define ll long long\n\t\t\t\t\t  \nusing namespace std;\n\nint n;\nint a[111];\nbool prime[10000007];\nvector<int> g[222];\nint dx[222], dy[222];\n\nbool wasIn(int x){\n\tfor (int i = 0; i < n; i++) if (a[i] == x) return 1;\n\treturn 0;\n}\n\nbool check(int x){\n\treturn wasIn(x) != wasIn(x + 1);\n}\n\nbool was[222];\nbool dfs(int v){\n\tif (was[v]) return 0;\n\twas[v] = 1;\n\tfor (int to : g[v]){\n\t\tif (dy[to] == -1){\n\t\t\tdx[v] = to;\n\t\t\tdy[to] = v;\n\t\t\treturn 1;\n\t\t}\n\t\tif (dfs(dy[to])){\n\t\t\tdx[v] = to;\n\t\t\tdy[to] = v;\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0; \n}\n\nint main(){\n\t//freopen(\"input.txt\", \"r\", stdin);\n\t//freopen(\"output.txt\", \"w\", stdout);\n\t//freopen(\"seating.in\", \"r\", stdin);\n\t//freopen(\"seating.out\", \"w\", stdout);\n\tfor (int i = 2; i < 10000007; i++){\n\t\tif (!prime[i]){\t\n\t\t\tfor (int j = 2 * i; j < 10000007; j += i) prime[j] = 1;\n\t\t}\n\t}\n\n\tprime[2] = 1;\n\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) cin >> a[i];\n\n\tvector<int> q, s, t;\n\tfor (int i = 0; i < n; i++){\n\t\tif (check(a[i] - 1)) q.pub(a[i] - 1);\n\t\tif (check(a[i])) q.pub(a[i]);\n\t}\n\n\tfor (int x : q) if (x % 2 == 0) s.pub(x); else t.pub(x);\n\n\tfor (int i = 0; i < s.size(); i++) for (int j = 0; j < t.size(); j++) if (!prime[abs(s[i] - t[j])]){\n\t\tg[i].pub(j);\n\t}\t\n\n\tfor (int i = 0; i < 222; i++) dx[i] = -1, dy[i] = 1;\n\n\tfor (int run = 1; run; ){\n\t\trun = 0;\n\t\tmemset(was, 0, sizeof(was));\n\t\tfor (int i = 0; i < s.size(); i++) if (dx[i] == -1 && dfs(i)) run = 1;\n\t}\n\n\tint ans = 0;\n\tint dd = 0;\n\n\tfor (int i = 0; i < s.size(); i++) if (dx[i] != -1) dd++;\n\n\tans += (int)s.size() + (int)t.size() - dd;\n\n\tif (((int)s.size() - dd) % 2 == 1) ans++;\n\n\tcout << ans;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define REP(I, A) for (int(I) = 0; (I) < (A); (I)++)\n#define pb(I) push_back(I)\n\nset<int> s, e;\nvector<int> vx, vy, Gx[200];\nint matl[1000], matr[1000];\nbool vis[1000];\n\nbool is_prime(int x) {\n\tif(x < 3) return false;\n\tfor (int i = 3; i*i <= x; i++) if(x % i == 0) return false;\n\treturn true;\n}\n\nbool dfs(int x) {\n\tfor (int v : Gx[x]) {\n\t\tif (!vis[v]) {\n\t\t\tvis[v] = true;\n\t\t\tif (matl[v] == -1 || dfs(matl[v])) {\n\t\t\t\tmatl[v] = x;\n\t\t\t\tmatr[x] = v;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\nint domatch() {\n\tmemset(matl, -1, sizeof(matl));\n\tmemset(matr, -1, sizeof(matr));\n\tint cnt = 0;\n\tREP(i, vx.size()) {\n\t\tif (matr[i] != -1)\n\t\t\tcontinue;\n\t\tmemset(vis, 0, sizeof(vis));\n\t\tcnt += dfs(i);\n\t}\n\treturn cnt;\n}\n\nint main() {\n\tint n, x;\n\tscanf(\"%d\", &n);\n\tREP(i, n) {\n\t\tscanf(\"%d\", &x);\n\t\ts.insert(x);\n\t}\n\tfor (int u : s) {\n\t\tif (!s.count(u - 1))\n\t\t\te.insert(u);\n\t\tif (!s.count(u + 1))\n\t\t\te.insert(u + 1);\n\t}\n\tfor (int u : e)\n\t\tif (u & 1)\n\t\t\tvx.pb(u);\n\t\telse\n\t\t\tvy.pb(u);\n\tREP(i, vx.size())\n\tREP(j, vy.size())\n\tif (is_prime(abs(vx[i] - vy[j])))\n\t\tGx[i].pb(j);\n\tint t = domatch();\n\tcout << t + (vx.size()/2+vy.size()/2)*2 + (vx.size() & 1) * 3 << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define all(v) (v).begin(), (v).end()\n\nusing li = long long;\n\nbool isPrime(int x)\n{\n    for (int y = 2; y * y <= x; y++)\n        if (x % y == 0)\n            return false;\n        \n    return true;\n}\n\nint dcost(int d) {\n    int answer = 0;\n    if (d == 0) answer = 0;\n    else if (d == 1) answer += 3;\n    else if (d == 2) answer += 2;\n    else if (isPrime(d))\n        answer++;\n    else\n        answer += 2;\n    \n    return answer;\n}\n\nvoid solve(bool read) {\n    int n;\n    cin >> n;\n    \n    vector<int> a(n);\n    for (int i = 0; i < n; i++)\n        cin >> a[i];\n    \n    if (n == 1) {\n        cout << \"3\\n\";\n        return;\n    }\n    \n    int answer = 0;\n    for (int i = 0; i + 1 < n; i++) {\n        int d = a[i + 1] - a[i] - 1;\n        //printf(\"%d %d\\n\", d, dcost(d));\n        answer += dcost(d);\n    }\n    \n    answer += dcost(a[n - 1] - a[0] + 1);\n    \n    cout << answer << \"\\n\";\n}\n\nint main() {\n#ifndef LOCAL\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n#endif\n    \n    solve(true);\n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef complex<double> point;\n#define xx real()\n#define yy imag()\n\n#define REP(i, a, b) for(int i = (a); i < (int)(b); i++)\n#define REPN(i, a, b) for(int i = (a); i <= (int)(b); i++)\n#define FA(it, x) for(__typeof((x).begin()) it = (x).begin(); it != (x).end(); it++)\n#define SZ(x) (int)(x).size()\n#define BE(x) (x).begin(), (x).end()\n#define SORT(x) sort(BE(x))\n#define _1 first\n#define _2 second\n\n#define x1 gray_cat_x1\n#define y1 gray_cat_y1\n\ntemplate<class T> T gcd(T a, T b) { return b ? gcd(b, a % b) : a; }\n\n#define file \"I1\"\n\nconst double EPS = 1e-9;\nconst double PI = acos(-1.);\nconst int INF = 1e9;\nconst ll MOD = 1e9 + 7;\n\n// Maximal prime value\nconst int MAXVAL = 1e7 + 5;\n\nstruct erat_sieve{\n\tchar is_p[MAXVAL];\n\tint top_p;\n\n\tvoid get_primes(){\n\t\tis_p[0] = is_p[1] = 1;\n\t\tfor(int i = 2; i * i < MAXVAL; i++){\n\t\t\tif (!is_p[i]){\n\t\t\t\tfor(int j = i * i; j < MAXVAL; j += i){\n\t\t\t\t\tis_p[j] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n} erat;\n\nconst int MAXN = 2e2 + 5;\n\nstruct graph {\n\t// Number of vertices for two parts\n\tint n1, n2;\n\t\n\t// graph (1 -> 2)\n\tvi g[MAXN];\n\t\n\t// Col for Kuhn series (1st part)\n\tint col[MAXN];\n\t\n\t// Current color for Kuhn series\n\tint cur_col;\n\t\n\t// Nxt for Kuhn (2nd part)\n\tint nxt[MAXN];\n\t\n\t// Final matching\n\tvector<pii> matching;\n\t\n\t// Adding edge\n\tvoid add_edge(int a, int b){\t\t\n\t\tg[a].pb(b);\n\t}\t\n\t\n\t// Try_kuhn\n\tint try_kuhn(int s){\n\t\tif (col[s] == cur_col){\n\t\t\treturn 0;\n\t\t}\n\t\tcol[s] = cur_col;\n\t\tREP(i, 0, SZ(g[s])){\n\t\t\tint to = g[s][i];\n\t\t\tif (!nxt[to] || try_kuhn(nxt[to])){\n\t\t\t\tnxt[to] = s;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\t\n\t// Set random matching for speeding up Kuhn\n\tvoid set_random_matching(){\n\t\tREPN(i, 1, n1){\n\t\t\tif (col[i] == 0){\n\t\t\t\tREP(j, 0, SZ(g[i])){\n\t\t\t\t\tint to = g[i][j];\n\t\t\t\t\tif (nxt[to] == 0){\n\t\t\t\t\t\tcol[i] = 1;\n\t\t\t\t\t\tnxt[to] = i;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t// Find matching\n\tvoid get_matching(){\n\t\t// Init\n\t\tREPN(i, 1, n1){\n\t\t\tcol[i] = 0;\n\t\t}\n\t\tREPN(i, 1, n2){\n\t\t\tnxt[i] = 0;\n\t\t}\n\t\tmatching.clear();\n\t\t\n\t\t// Random matching\n\t\tcur_col = 1;\n\t\tset_random_matching();\n\t\t\t\t\t\t\n\t\t// Go Kuhn\n\t\tREPN(i, 1, n1){\n\t\t\tif (col[i] == 0){\n\t\t\t\tcur_col++;\n\t\t\t\ttry_kuhn(i);\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Restore matching\n\t\tREPN(i, 1, n2){\n\t\t\tif (nxt[i] != 0){\n\t\t\t\tmatching.pb(mp(nxt[i], i));\n\t\t\t\t//printf(\"%d %d\\n\", i, nxt[i]);\n\t\t\t}\n\t\t}\n\t}\t\n} gg;\n\nvi v0, v1, vals;\n\nint v[MAXN];\n\nvoid solve(){\n\terat.get_primes();\t\n\tint n;\n\tscanf(\"%d\", &n);\n\tREP(i, 0, n){\n\t\tscanf(\"%d\", &v[i]);\n\t}\n\tfor(int i = 0; i < n; ){\n\t\tint j;\n\t\tfor(j = i + 1; j < n && j - i == v[j] - v[i]; j++);\n\t\tj--;\n\t\tvals.pb(v[i]);\n\t\tvals.pb(v[j] + 1);\n\t\ti = j + 1;\n\t}\n\tREP(i, 0, SZ(vals)){\n\t\tif (vals[i] % 2 == 0){\n\t\t\tv0.pb(vals[i]);\n\t\t} else {\n\t\t\tv1.pb(vals[i]);\n\t\t}\n\t}\n\tgg.n2 = SZ(v0);\n\tgg.n1 = SZ(v1);\n\tREP(i, 0, gg.n1){\n\t\tREP(j, 0, gg.n2){\n\t\t\tint tmp = v1[i] - v0[j];\n\t\t\tif (tmp < 0){\n\t\t\t\ttmp -= tmp;\n\t\t\t}\n\t\t\tif (!erat.is_p[tmp]){\n\t\t\t\tgg.add_edge(i + 1, j + 1);\n\t\t\t\t//printf(\"%d %d\\n\", v1[i], v0[j]);\n\t\t\t}\n\t\t}\n\t}\n\tgg.get_matching();\n\tint cnt_m = SZ(gg.matching);\n\tint cnt_1 = gg.n1 - cnt_m;\n\tint cnt_2 = gg.n2 - cnt_m;\n\tint ans = cnt_m + (cnt_1 + cnt_1 % 2) + (cnt_2);\n\tprintf(\"%d\\n\", ans);\n\t//printf(\"%d\\n\", cnt_m);\t\n}   \n\nint main(){\n\n    //freopen(file\".in\", \"r\", stdin); freopen(file\".out\", \"w\", stdout);\n    int t = 1;\n    //cin >> t;\n    while(t--){\n        solve();    \n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int, int> pii;\n\n#define FOR(i, a, b) for (int i=a; i<b; i++)\n#define F0R(i, a) for (int i=0; i<a; i++)\n#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\n \n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n\nconst int MOD = 1000000007;\ndouble PI = 4*atan(1);\n\nint N, pre[202], visit[202];\nvi x, y[2];\nset<int> adj[202];\n\nbool oddprime(int x) {\n    x = abs(x);\n    if (x <= 2) return 0;\n    for (int i = 2; i*i <= x; ++i) if (x % i == 0) return 0;\n    return 1;\n}\n\nint calc(int flow) {\n    return flow+2*((y[0].size()-flow)/2+(y[1].size()-flow)/2)+3*((y[0].size()-flow)%2);    \n}\n\nvoid dfs(int x) {\n    visit[x] = 1;\n    for (int i: adj[x]) if (!visit[i]) {\n        if (visit[201]) break;\n        pre[i] = x;\n        dfs(i);\n    }\n}\n\nvoid backtrack(int x) {\n    if (x == 0) return;\n    int x1 = pre[x];\n    adj[x1].erase(x);\n    adj[x].insert(x1);\n    backtrack(x1);\n}\n\nint main() {\n    cin >> N; x.resize(N); \n    F0R(i,N) cin >> x[i];\n    F0R(i,N) {\n        if (i == 0 || x[i-1]+1 != x[i]) y[(x[i]-1)%2].pb(x[i]-1);\n        if (i == N-1 || x[i]+1 != x[i+1]) y[x[i]%2].pb(x[i]);\n    }\n    \n    F0R(i,y[0].size()) adj[0].insert(i+1);\n    F0R(i,y[1].size()) adj[i+y[0].size()+1].insert(201);\n    F0R(i,y[0].size()) F0R(j,y[1].size()) \n        if (oddprime(y[0][i]-y[1][j])) adj[i+1].insert(j+1+y[0].size());\n        \n    int flow = 0;\n    while (1) {\n        memset(visit,0,sizeof visit);\n        dfs(0);\n        if (!visit[201]) {\n            cout << calc(flow);\n            return 0;\n        }\n        backtrack(201);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\ntypedef long long ll;\nint odd,even,Odd[105],Even[105],ma[105];\nbool flag[10000010],x[10000010],map[105][105],vis[105];\nint prime[10000010],a[105];\nint dfs(int u)\n{\n\tfor (int v=1;v<=even;v++)\n\t{\n\t\tif (!map[u][v]) continue;\n\t\tif (!vis[v])\n\t\t{\n\t\t\tint t=ma[v];\n\t\t\tma[v]=u;\n\t\t\tif (t==-1||dfs(t)) return 1;\n\t\t\tma[v]=t;\n\t\t}\n\t}\n\treturn 0;\n}\nint main()\n{\n\tint n,cnt=0;\n\tscanf(\"%d\",&n);\n\tflag[1]=1;\n\tfor (int i=2;i<=10000000;i++)\n\t{\n\t\tif (!flag[i]) prime[++cnt]=i;\n\t\tfor (int j=1;j<=cnt;j++)\n\t\t{\n\t\t\tif (i*prime[j]>10000000) break;\n\t\t\tflag[i*prime[j]]=1;\n\t\t\tif (i%prime[j]==0) break;\n\t\t}\n\t}\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%d\",&a[i]);\n\t\tx[a[i]]^=1;\n\t}\n\tfor (int i=1;i<=10000000;i++)\n\t\tif (x[i]!=x[i-1])\n\t\t{\n\t\t\tif (i&1) Odd[++odd]=i;\n\t\t\telse Even[++even]=i; \n\t\t}\n\tfor (int i=1;i<=odd;i++)\n\t\tfor (int j=1;j<=even;j++)\n\t\t\tif (flag[abs(Odd[i]-Even[j])]) map[i][j]=1;\n\tmemset(ma,-1,sizeof(ma));\n\tint sum=0;\n\tfor (int i=1;i<=odd;i++)\n\t{\n\t\tmemset(vis,0,sizeof(vis));\n\t\tif (dfs(i)) sum++;\n\t}\n\tll ans=sum+(((odd-sum)>>1)<<1)+(((even-sum)>>1)<<1)+(odd-sum)%2*3;\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 1e7 + 700;\n\n\nint n,fre[maxn],p[220],ispr[maxn],even,odd,wrong;\nvector <int> edge[220],v2;\n\nbool fin(int u) {\n    if (fre[u]==wrong) return false;\n    fre[u]=wrong;\n    for (int j=0;j<edge[u].size();j++) {\n        int v=edge[u][j];\n       // cout<<u<<\" \"<<v<<endl;\n        if (p[v]==0 || fin(p[v])) {\n            p[v]=u;\n            p[u]=v;\n            return true;\n        }\n    }\n    return false;\n}\n\nint main() {\n //   freopen(\"in.txt\",\"r\",stdin);\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    ispr[1]=1;\n    for (int i=2;i<maxn;i++)\n        if (ispr[i]==0) {\n            for (int j=i+i;j<maxn;j+=i) ispr[j]=1;\n        }\n    cin>>n;\n    for (int i=1;i<=n;i++) {\n        int x;\n        cin>>x;\n        fre[x]^=1;\n        fre[x+1]^=1;\n    }\n    even=0; odd=0; wrong=2;\n    for (int i=0;i<maxn;i++)\n        if (fre[i]==1) {\n            v2.push_back(i);\n            if (i%2==0) even++;\n            else odd++;\n        }\n    // for (int i=0;i<v2.size();i++) cout<<v2[i]<<\" \";\n   //  cout<<endl;\n   // cout<<\" \" <<even<<\" \"<<odd<<endl;\n    for (int i=0;i<v2.size();i++)\n        for (int j=0;j<v2.size();j++)\n            if (v2[i]%2==0 && v2[j]%2==1 && ispr[ abs(v2[j] - v2[i]) ]==0) {\n                edge[i+1].push_back(j+1);\n                edge[j+1].push_back(i+1);\n            }\n    int cnt=0;\n    for (int i=0;i<v2.size();i++)\n     if (p[i+1]==0) {\n        wrong++;\n        p[i+1]=i+1;\n        //cout<<fin(i+1)<<endl;\n        cnt+=(fin(i+1));\n       // cout<<p[i+1]<<endl;\n      //  cout<<\"fuck\"<<endl;\n    }\n    cout<< cnt + ((even-cnt)/2 + (odd-cnt)/2) * 2 + (even%2)*3;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*input\n9\n1 2 3 4 5 6 7 8 9\n*/\n#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <utility>\n#include <vector>\nusing namespace std;\n#define sp ' '\n#define endl '\\n'\n#define fi first\n#define se second\n#define mp make_pair\n#define int long long\n#define N 205\n#define bit(x,y) ((x>>y)&1LL)\n#define show(x) cout << (#x) << \": \" << x << endl;\n#define ii pair<int,int>\nostream& operator << (ostream &os, vector<int>&x) {\n\tfor (int i = 0; i < x.size(); i++) os << x[i] << sp;\n\treturn os;\n}\nostream& operator << (ostream &os, pair<int, int> x) {\n\tcout << x.fi << sp << x.se << sp;\n\treturn os;\n}\nostream& operator << (ostream &os, vector<pair<int, int> >&x) {\n\tfor (int i = 0; i < x.size(); i++) os << x[i] << endl;\n\treturn os;\n}\n\nclass max_matching {\nprivate:\n\tconst int INF = 1e18;\n\tint match[N];\n\tint dis[N];\n\tvector<vector<int> > a;\n\tint n;\n\tbool bfs() {\n\t\tfill(dis, dis + N, INF);\n\t\tqueue<int> q;\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tif (!match[i]) {\n\t\t\t\tdis[i] = 0;\n\t\t\t\tq.push(i);\n\t\t\t}\n\t\t}\n\t\twhile (!q.empty()) {\n\t\t\tint u = q.front(); q.pop();\n\t\t\tif (u == 0) break;\n\t\t\tfor (int i = 0; i < a[u].size(); i++) {\n\t\t\t\tint v = a[u][i]; v = match[v];\n\t\t\t\tif (dis[v] > dis[u] + 1) {\n\t\t\t\t\tdis[v] = dis[u] + 1;\n\t\t\t\t\tq.push(v);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn dis[0] != INF;\n\t}\n\tbool dfs(int u) {\n\t\tif (u == 0) return true;\n\t\tfor (int i = 0; i < a[u].size(); i++) {\n\t\t\tint v = a[u][i];\n\t\t\tif (dis[match[v]] == dis[u] + 1 && dfs(match[v])) {\n\t\t\t\tmatch[u] = v;\n\t\t\t\tmatch[v] = u;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\npublic:\n\tint whmatch(int x) {\n\t\treturn match[x];\n\t}\n\tmax_matching(int _n) {\n\t\tn = _n;\n\t\ta.assign(n + 5, vector<int>());\n\t\tmemset(match, 0, sizeof(match));\n\t\tmemset(dis, 0, sizeof(dis));\n\t}\n\tvoid add_egde(int u, int v) {\n\t\ta[u].push_back(v); a[v].push_back(u);\n\t}\n\tint solve() {\n\t\tint ret = 0;\n\t\twhile (bfs()) {\n\t\t\tfor (int i = 1; i <= n; i++)\n\t\t\t\tif (match[i] == 0 && dfs(i)) ret++;\n\t\t}\n\t\treturn ret;\n\t}\n};\n\n#define M 10000005\nint primes[M];\nvoid eratosthene() {\n\tfor (int i = 2; i <= M - 5; i++) if (primes[i] == 0) for (int j = i; j <= M - 5; j += i) primes[j] = i;\n}\n\nint n;\nbool mark[10000005];\nvector<int> a;\n\nsigned main() {\n\teratosthene();\n\tcin >> n;\n\tfor (int i = 1; i <= n; i++) {\n\t\tint t; cin >> t;\n\t\tmark[t] = true;\n\t}\n\tfor (int i = 0; i <= 10000000; i++) {\n\t\tif (mark[i] != mark[i + 1]) a.push_back(i);\n\t}\n\tint ME = 0, MO = 0;\n\tfor (int i = 0; i < a.size(); i++) {\n\t\tif (a[i] & 1) MO++;\n\t\telse ME++;\n\t}\n\tmax_matching D(a.size());\n\tfor (int i = 1; i < a.size(); i++) {\n\t\tfor (int j = 0; j < i; j++) {\n\t\t\tif (primes[a[i] - a[j]] == a[i] - a[j] && a[i] - a[j] > 2) {\n\t\t\t\tD.add_egde(j + 1, i + 1);\n\t\t\t}\n\t\t}\n\t}\n\tint rec = D.solve();\n\tcout << rec * 1 + ((ME - rec) / 2 + (MO - rec) / 2) * 2 + (ME - rec) % 2 * 3 << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint N,M;\nconst int MAX_N = 111;\nconst int MAX_M = 444;\n\nint a[MAX_N],b[MAX_N*2],sz;\n\nstruct edge{int u,cap,cost,rev;};\nvector<edge> path[MAX_M];\n\nvoid add_edge(int v,int u,int cap,int cost){\n\tpath[v].push_back(edge{u,cap,cost,path[u].size()});\n\tpath[u].push_back(edge{v,0,-cost,path[v].size()-1});\n}\n\nint get_cost(int x){\n\tif(x==1)return 1e9;\n\tif(x%2==0)return 2;\n\tfor(int i=3;i*i<=x;i+=2){\n\t\tif(x%i==0)return 3;\n\t}\n\treturn 1;\n}\n\nint p[MAX_M],pi[MAX_M],dist[MAX_M];\n\nbool findPath(int S,int T){\n\tfor(int i=0;i<=M;i++){\n\t\tdist[i]=1e9;\n\t}\n\tdist[S]=0;\n\t\n\tfor(int t=0;t<=M;t++){\n\t\tfor(int v=0;v<=M;v++){\n\t\t\tfor(int i=0;i<path[v].size();i++){\n\t\t\t\tif(path[v][i].cap<=0)continue;\n\t\t\t\tint u=path[v][i].u;\n\t\t\t\tif(dist[u]>dist[v]+path[v][i].cost){\n\t\t\t\t\tdist[u]=dist[v]+path[v][i].cost;\n\t\t\t\t\tp[u]=v,pi[u]=i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn dist[T]<1e9;\n}\n\nint netFlow(int S,int T){\n\tint ret=0;\n\twhile(findPath(S,T)){\n\t\tint f=1e9;\n\t\tfor(int u=T,v;u!=S;u=v){\n\t\t\tv=p[u];\n\t\t\tf=min(f,path[v][pi[u]].cap);\n\t\t}\n\t\tfor(int u=T,v;u!=S;u=v){\n\t\t\tv=p[u];\n\t\t\tpath[v][pi[u]].cap-=f;\n\t\t\tpath[u][path[v][pi[u]].rev].cap+=f;\n\t\t}\n\n\t\tret+=f*dist[T];\n\t}\n\treturn ret;\n}\n\nint main(){\n\t\n\tscanf(\"%d\",&N);\n\tfor(int i=1;i<=N;i++){\n\t\tscanf(\"%d\",&a[i]);\n\t}\n\ta[0]=-1;\n\ta[N+1]=1e9;\n\n\tfor(int i=1;i<=N+1;i++){\n\t\tif(a[i-1]+1<a[i]){\n\t\t\tif(i>1)b[sz++]=a[i-1]+1;\n\t\t\tif(i<=N)b[sz++]=a[i];\n\t\t}\n\t}\n\n\tM=sz*2+2;\n\n\tfor(int i=0;i<sz;i++){\n\t\tfor(int j=i+1;j<sz;j++){\n\t\t\tadd_edge(i+2,j+2+sz,1,get_cost(b[j]-b[i]));\n\t\t}\n\t}\n\tfor(int i=0;i<sz;i++){\n\t\tadd_edge(1,i+2,1,0);\n\t\tadd_edge(i+2+sz,sz*2+2,1,0);\n\t}\n\tadd_edge(0,1,sz/2,0);\n\n\tprintf(\"%d\\n\",netFlow(0,M));\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<cstring>\n#include<map>\n#include<queue>\n#include<cmath>\nusing namespace std;\ntypedef long long ll;\nconst int N=1005,INF=~0u>>2;\nstruct Edge{int nxt,to;}edge[(N*N)<<3];\nint a[N],b[N<<1],n,head[N<<1],num_edge,vis[N<<1],lk[N<<1],even[N<<1],odd[N<<1],even_num,odd_num,ans,k,tot,tim;\nint read(){\n\tint x=0,f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-') f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn f*x;\n}\nvoid add_edge(int from,int to){\n\tedge[++num_edge].nxt=head[from];\n\tedge[num_edge].to=to;\n\thead[from]=num_edge;\n}\nbool find(int x){\n\tfor(int i=head[x];i;i=edge[i].nxt){\n\t\tif(vis[edge[i].to]!=tim){\n\t\t\tvis[edge[i].to]=tim;\n\t\t\tif(!lk[edge[i].to]||find(edge[i].to)){\n\t\t\t\tlk[edge[i].to]=x;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nbool check(int x){\n\tif(x==1||x==2) return 0;\n\tfor(int i=2;i*i<=x;++i){\n\t\tif(x%i==0) return 0;\n\t}\n\treturn 1;\n}\nint main(){\n//\tfreopen(\"ex.in\",\"r\",stdin);\n\tn=read();\n\tfor(int i=1;i<=n;++i) b[i]=read();b[0]=-1;\n\tfor(int i=1;i<=n;++i){\n\t\tif(b[i]!=b[i-1]+1){\n\t\t\tif(i%2) odd[++odd_num]=b[i];\n\t\t\telse even[++even_num]=b[i];\n\t\t}\n\t\tif(b[i]+1!=b[i+1]){\n\t\t\tif((i+1)%2) odd[++odd_num]=b[i]+1;\n\t\t\telse even[++even_num]=b[i]+1;\n\t\t}\n\t}\n\tfor(int i=1;i<=odd_num;++i){\n\t\tfor(int j=1;j<=even_num;++j){\n\t\t\tif(check(abs(even[j]-odd[i]))) add_edge(i,j+odd_num),add_edge(j+odd_num,i);\n\t\t}\n\t}\n\tfor(int i=1;i<=odd_num;++i){\n\t\ttim++;\n\t\tif(find(i)) k++;\n\t\telse break;\n\t}\n\tans=k+((even_num-k)/2+(odd_num-k)/2)*2+((even_num-k)%2)*3;\n\tprintf(\"%d\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define MX 205\n#define MP 10000005\nint x[MX];\nvector<int> v;\nvector<int> g[MX];\nbool vis[MX];\nint lnk[MX];\nbool f[MP] = {1, 1};\n\nint dfs(int u) {\n\tfor(auto v : g[u]) {\n\t\tif(vis[v]) continue;\n\t\tvis[v] = true;\n\t\tif(lnk[v] < 0 || dfs(lnk[v])) {\n\t\t\tlnk[v] = u;\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nint main() {\n\tfor(int i = 2; i < MP; i++) {\n\t\tif(f[i]) continue;\n\t\tfor(int j = i + i; j < MP; j += i) f[j] = 1;\n\t}\n\tint n; scanf(\"%d\", &n);\n\tfor(int i = 0; i < n; i++) scanf(\"%d\", x + i);\n\tfor(int i = 0; i < n; i++) {\n\t\tif(x[i] + 1 != x[i + 1]) v.push_back(x[i]);\n\t\tif(!i || x[i] - 1 != x[i - 1]) v.push_back(x[i] - 1);\n\t}\n\tsort(v.begin(), v.end());\n\tfor(int i = 0; i < v.size(); i++)\n\t\tfor(int j = 0; j < v.size(); j++)\n\t\t\tif(!f[abs(v[i] - v[j])]) g[i].push_back(j);\n\tint res = 0;\n\tfor(int i = 0; i < v.size(); i++) {\n\t\tif(v[i] & 1) continue;\n\t\tmemset(lnk, 0xff, sizeof lnk);\n\t\tres += dfs(i);\n\t}\n\tint c[2] = {0};\n\tfor(auto u : v) c[u & 1]++;\n\tc[0] -= res; c[1] -= res;\n\tres += c[0] / 2 * 2; res += c[1] / 2 * 2;\n\tc[0] &= 1; c[1] &= 1;\n\tif(c[0] || c[1]) res += 3;\n\tprintf(\"%d\\n\", res);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint n, x, z;\nint a[220], b[220], ac, bc, l[220];\nbool g[220][220], v[220];\nmap<int, int> q;\nbool P(int x) {\n\tif (x < 2) {\n\t\treturn false;\n\t}\n\tfor (int i = 2; i * i <= x; i++) {\n\t\tif (x % i == 0) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\nbool dfs(int x) {\n\tfor (int i = 0; i < bc; i++) {\n\t\tif (g[x][i] && !v[i]) {\n\t\t\tv[i] = true;\n\t\t\tif (l[i] == -1 || dfs(l[i])) {\n\t\t\t\treturn l[i] = x, true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d\", &x);\n\t\tq[x] ^= 1;\n\t\tq[x + 1] ^= 1;\n\t}\n\tfor (pair<int, int> i: q) {\n\t\tif (i.second == 0) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (i.first & 1) {\n\t\t\ta[ac++] = i.first;\n\t\t} else {\n\t\t\tb[bc++] = i.first;\n\t\t}\n\t}\n\tfor (int i = 0; i < ac; i++) {\n\t\tfor (int j = 0; j < bc; j++) {\n\t\t\tif (P(abs(a[i] - b[i]))) {\n\t\t\t\tg[i][j] = true;\n\t\t\t}\n\t\t}\n\t}\n\tmemset(l, -1, sizeof l);\n\tfor (int i = 0; i < ac; i++) {\n\t\tmemset(v, 0, sizeof v);\n\t\tif (dfs(i)) {\n\t\t\tz++;\n\t\t}\n\t}\n\tif ((ac - z) & 1) {\n\t\tz--;\n\t}\n\tprintf(\"%d\\n\", ac + bc - z);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<cstring>\nusing namespace std;\nint n;\nint res;\nvector<int>v;\nint lst=-1;\nint match[210];\nint me,mo;\nint mx;\nbool f[10000010];\nbool ok[210][210];\nbool vis[210];\nint prm[1000010];\nint sz;\nint l;\nbool bp(int x)\n{\n\tfor(int i=0;i<l;i++)\n\t{\n\t\tif(!ok[x][i])continue;\n\t\tif(vis[i])continue;\n\t\tvis[i]=vis[x]=true;\n\t\tif(match[i]==-1 || bp(match[i]))\n\t\t{\n\t\t\tmatch[i]=x;\n\t\t\treturn true;\n\t\t}\n\t\tvis[i]=vis[x]=false;\n\t}\n\treturn false;\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint x;\n\t\tscanf(\"%d\",&x);\n\t\tif(x!=lst+1)\n\t\t{\n\t\t\tif(lst+1)v.push_back(lst+1);\n\t\t\tv.push_back(x);\n\t\t}\n\t\tlst=x;\n\t\tmx=lst+1;\n\t}\n\tv.push_back(lst+1);\n\tf[1]=true;\n\tfor(int i=2;i<=mx;i++)\n\t{\n\t\tif(!f[i])prm[++sz]=i;\n\t\tfor(int j=1;j<=sz;j++)\n\t\t{\n\t\t\tif(prm[j]*i>mx)break;\n\t\t\tf[prm[j]*i]=true;\n\t\t\tif(i%prm[j]==0)break;\n\t\t}\n\t}\n\tl=v.size();\n\tfor(int i=0;i<l;i++)\n\t{\n\t\tmatch[i]=-1;\n\t\tif(v[i]&1)mo++;else me++;\n\t\tfor(int j=i+1;j<l;j++)\n\t\t{\n\t\t\tif(v[j]-v[i]!=2 && !f[v[j]-v[i]])\n\t\t\t{\n\t\t\t\tok[i][j]=ok[j][i]=true;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<l;i++)\n\t{\n\t\tmemset(vis,false,sizeof(vis));\n\t\tif(bp(i))res++;\n\t}\n\tres/=2;\n\tprintf(\"%d\",res+((me-res)/2+(mo-res)/2)*2+((me-res)%2)*3);\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n#include<cstring>\n\nusing namespace std;\n\nusing vi = vector<int>;\nvi X;\nint n;\nvector<vi> C;\nint used[207];\nbool isprime(int n) {\n\tfor (int i = 2; i*i < n; i++) {\n\t\tif (n%i == 0)return false;\n\t}\n\treturn true;\n}\nbool dfs(int v) {\n\tused[v] = true;\n\tfor (int i = 0; i < X.size() + 2; i++) {\n\t\tif (!used[i] && C[v][i] > 0) {\n\t\t\tif (dfs(i)) {\n\t\t\t\tC[v][i]--;\n\t\t\t\tC[i][v]++;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\nint main() {\n\tcin >> n;\n\tvi evens;\n\tvi odds;\n\tfor (int i = 0; i < n; i++) {\n\t\tint x;\n\t\tcin >> x;\n\t\tif (!X.empty() && X.back() == x) {\n\t\t\tX.pop_back();\n\t\t\tX.push_back(x + 1);\n\t\t}\n\t\telse {\n\t\t\tX.push_back(x);\n\t\t\tX.push_back(x + 1);\n\t\t}\n\t}\n\tint E = 0;\n\tint O = 0;\n\tfor (int x : X) {\n\t\tif (x % 2 == 0) {\n\t\t\tE++;\n\t\t}\n\t\telse {\n\t\t\tO++;\n\t\t}\n\t}\n\t\t\n\tC.resize(X.size()+2, vi(X.size()+2, 0));\n\tfor (int i = 0; i < X.size(); i++) {\n\t\tif (X[i] % 2 == 0) {\n\t\t\tC[n][i] = 1;\n\t\t}\n\t\telse {\n\t\t\tC[i][n + 1] = 1;\n\t\t}\n\t}\n\tfor (int i = 0; i < X.size(); i++) {\n\t\tfor (int j = i; j < n; j++) {\n\t\t\tif (isprime(abs(X[i] - X[j]))) {\n\t\t\t\tC[i][j] = 1;\n\t\t\t}\n\t\t}\n\t}\n\tint ans = 0;\n\twhile (dfs(X.size())) {\n\t\tmemset(used, false, sizeof(used));\n\t\tans++;\n\t}\n\tif ((E - ans) % 2 == 0) {\n\t\tcout << ans + (E - ans + O - ans) << endl;\n\t}\n\telse {\n\t\tcout << ans + (E - ans - 1 + O - ans - 1) + 3 << endl;\n\t}\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<cstring>\nusing namespace std;\nint n;\nint res;\nvector<int>v;\nint lst=-1;\nint match[210];\nint me,mo;\nint mx;\nbool f[10000010];\nbool ok[210][210];\nbool vis[210];\nint prm[1000010];\nint sz;\nint l;\nbool bp(int x)\n{\n\tfor(int i=0;i<l;i++)\n\t{\n\t\tif(!ok[x][i])continue;\n\t\tif(vis[i])continue;\n\t\tvis[i]=true;\n\t\tif(match[i]==-1 || bp(match[i]))\n\t\t{\n\t\t\tmatch[i]=x;\n\t\t\tmatch[x]=i;\n\t\t\treturn true;\n\t\t}\n\t\tvis[i]=false;\n\t}\n\treturn false;\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint x;\n\t\tscanf(\"%d\",&x);\n\t\tif(x!=lst+1)\n\t\t{\n\t\t\tif(lst+1)v.push_back(lst+1);\n\t\t\tv.push_back(x);\n\t\t}\n\t\tlst=x;\n\t\tmx=lst+1;\n\t}\n\tv.push_back(lst+1);\n\tf[1]=true;\n\tfor(int i=2;i<=mx;i++)\n\t{\n\t\tif(!f[i])prm[++sz]=i;\n\t\tfor(int j=1;j<=sz;j++)\n\t\t{\n\t\t\tif(prm[j]*i>mx)break;\n\t\t\tf[prm[j]*i]=true;\n\t\t\tif(i%prm[j]==0)break;\n\t\t}\n\t}\n\tl=v.size();\n\tfor(int i=0;i<l;i++)\n\t{\n\t\tmatch[i]=-1;\n\t\tif(v[i]&1)mo++;else me++;\n\t\tfor(int j=i+1;j<l;j++)\n\t\t{\n\t\t\tif(v[j]-v[i]!=2 && !f[v[j]-v[i]])\n\t\t\t{\n\t\t\t\tok[i][j]=ok[j][i]=true;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<l;i++)\n\t{\n\t\tif(match[i])continue;\n\t\tmemset(vis,false,sizeof(vis));\n\t\tif(bp(i))res++;\n\t}\n\tres/=2;\n\tprintf(\"%d\",res+((me-res)/2+(mo-res)/2)*2+((me-res)%2)*3);\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <vector>\n#define rep(i,st,ed) for (int i=st;i<=ed;++i)\n\nconst int N=20005;\nconst int M=10000005;\n\nstd:: vector <int> vec[2];\n\nstruct edge {int x,y,next;} e[N*2];\n\nint link[N],vis[N],a[M];\nint ls[N],p[M/10],edCnt;\n\nbool np[M];\n\nint read() {\n\tint x=0,v=1; char ch=getchar();\n\tfor (;ch<'0'||ch>'9';v=(ch=='-')?(-1):v,ch=getchar());\n\tfor (;ch<='9'&&ch>='0';x=x*10+ch-'0',ch=getchar());\n\treturn x*v;\n}\n\nvoid add_edge(int x,int y) {\n\te[++edCnt]=(edge) {x,y,ls[x]}; ls[x]=edCnt;\n\te[++edCnt]=(edge) {y,x,ls[y]}; ls[y]=edCnt;\n}\n\nvoid pre(int n) {\n\tnp[1]=1;\n\trep(i,2,n) {\n\t\tif (!np[i]) p[++p[0]]=i;\n\t\tfor (int j=1;i*p[j]<=n;++j) {\n\t\t\tnp[i*p[j]]=1;\n\t\t\tif (i%p[j]==0) break;\n\t\t}\n\t}\n}\n\nint find(int x,int id) {\n\tfor (int i=ls[x];i;i=e[i].next) {\n\t\tif (vis[e[i].y]==id) continue;\n\t\tvis[e[i].y]=id;\n\t\tif (!link[e[i].y]||find(link[e[i].y],id)) {\n\t\t\tlink[e[i].y]=x;\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nint main(void) {\n\tint n=read(),mx=0;\n\trep(i,1,n) {\n\t\tint x=read();\n\t\ta[x]=1;\n\t\tmx=std:: max(mx,x);\n\t}\n\tpre(mx+1);\n\trep(i,1,mx+1) if (a[i]!=a[i-1]) {\n\t\tvec[i&1].push_back(i);\n\t}\n\tint ta=vec[0].size(),tb=vec[1].size();\n\tfor (int i=0;i<ta;++i) {\n\t\tfor (int j=0;j<tb;++j) {\n\t\t\tint d=abs(vec[0][i]-vec[1][j]);\n\t\t\tif (!np[d]&&(d&1)) {\n\t\t\t\tadd_edge(i+1,j+1+ta);\n\t\t\t}\n\t\t}\n\t}\n\tint ans=0;\n\trep(i,1,ta) ans+=find(i,i);\n\tta-=ans,tb-=ans;\n\tans+=(ta/2)*2+(tb/2)*2;\n\tif ((ta&1)||(tb&1)) ans+=3;\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#define fo(i,a,b) for(int i=a;i<=b;i++)\n#define fd(i,b,a) for(int i=b;i>=a;i--)\n#define efo(i,u,v) for(int i=BB[u],v=B[BB[u]][1];i;v=B[i=B[i][0]][1])\n#define mset(a,x) memset(a,x,sizeof(a))\nusing namespace std;\ntypedef long long ll;\nchar ch;\nint read(){int n=0,p=1;for(ch=getchar();ch<'0' || '9'<ch;ch=getchar())if(ch=='-') p=-1;for(;'0'<=ch && ch<='9';ch=getchar()) n=n*10+ch-'0';return n*p;}\nconst int N=205,M=2e7+5;\nint n,m,a[N],d[N<<1],pr[M];\nbool b[M],c[M],bz[M];\nvoid prep()\n{\n\tmset(bz,1);\n\tbz[0]=bz[1]=0;\n\tfo(i,2,m)\n\t{\n\t\tif(bz[i]) pr[++pr[0]]=i;\n\t\tfo(j,1,pr[0])\n\t\t{\n\t\t\tll x=(ll)i*pr[j];\n\t\t\tif(x>m) break;\n\t\t\tbz[x]=0;\n\t\t\tif(i%pr[j]==0) break;\n\t\t}\n\t}\n}\n\nconst int V=N<<2,INF=1e9;\nconst int E=4*V*V;\nint ans,B0,S,T,BB[V],dis[V],B[E][4];\nbool vis[V];\nvoid link(int u,int v,int r,int w)\n{\n\tB[++B0][1]=v,B[B0][2]=r,B[B0][3]=w,B[B0][0]=BB[u],BB[u]=B0;\n\tif(!(B0&1)) link(v,u,0,-w);\n}\nint aug(int v,int flow)\n{\n\tvis[v]=1;\n\tif(v==T) \n\t{\n\t\tans+=dis[S]*flow;\n\t\treturn flow;\n\t}\n\tefo(i,v,u)\n\t\tif(B[i][2] && dis[v]==dis[u]+B[i][3])\n\t\t{\n\t\t\tint f=aug(u,min(flow,B[i][2]));\n\t\t\tif(f)\n\t\t\t{\n\t\t\t\tB[i][2]-=f,B[i^1][2]+=f;\n\t\t\t\treturn f;\n\t\t\t}\n\t\t}\n\treturn 0;\n}\nbool change()\n{\n\tint minh=INF;\n\tfo(u,S,T) if(vis[u])\n\t\tefo(i,u,v) if(!vis[v])\n\t\t\tif(B[i][2]) minh=min(minh,dis[u]+B[i][3]-dis[v]);\n\tif(minh==INF) return 0;\n\tfo(i,S,T) if(vis[i]) dis[i]+=minh;\n\treturn 1;\n}\nint main()\n{\n\tn=read();\n\tfo(i,1,n) b[a[i]=read()]=1,m=max(m,a[i]);\n\t++m;\n\tprep();\n\tfo(i,1,m) c[i]=b[i]^b[i-1];\n\tfo(i,1,m) if(c[i]) d[++d[0]]=i;\n\t\n\tB0=1,S=0,T=d[0]+d[0]+1;\n\tfo(i,1,d[0]-1)\n\t\tfo(j,i+1,d[0])\n\t\t{\n\t\t\tif((d[j]-d[i])%2==0) link(i,d[0]+j,1,2),link(j,d[0]+i,1,2);\n\t\t\telse\n\t\t\tif(bz[d[j]-d[i]]) link(i,d[0]+j,1,1),link(j,d[0]+i,1,1);\n\t\t\telse link(i,d[0]+j,1,3),link(j,d[0]+i,1,3);\n\t\t}\n\tfo(i,1,d[0]) link(S,i,1,0),link(d[0]+i,T,1,0);\n\t\n\tdo\n\t{\n\t\twhile(aug(S,INF)) mset(vis,0);\n\t}\n\twhile(change());\n\tprintf(\"%d\",ans/2);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint x[105], n;\nvector<int> vt[2];\nbool notprime[100000015];\n\nvoid add(int t)\n{\n    bool a = binary_search(x, x + n, t);\n    bool b = binary_search(x, x + n, t - 1);\n    if (a != b) vt[t & 1].push_back(t);\n}\n\n// in: n, m, graph\n// out: match, matched\n// vertex cover: (reached[0][left_node] == 0) || (reached[1][right_node] == 1)\n// O(E*sqrt(V))\nstruct BipartiteMatching {\n    int n, m;\n    vector<vector<int>> graph;\n    vector<int> matched, match, edgeview, level;\n    vector<int> reached[2];\n    BipartiteMatching(int n, int m) : n(n), m(m), graph(n), matched(m, -1),\n    match(n, -1) {}\n    bool assignLevel() {\n        bool reachable = false;\n        level.assign(n, -1);\n        reached[0].assign(n, 0);\n        reached[1].assign(m, 0);\n        queue<int> q;\n        for (int i = 0; i < n; i++) {\n            if (match[i] == -1) {\n                level[i] = 0;\n                reached[0][i] = 1;\n                q.push(i);\n            }\n        }\n        while (!q.empty()) {\n            auto cur = q.front(); q.pop();\n            for (auto adj : graph[cur]) {\n                reached[1][adj] = 1;\n                auto next = matched[adj];\n                if (next == -1) {\n                    reachable = true;\n                }\n                else if (level[next] == -1) {\n                    level[next] = level[cur] + 1;\n                    reached[0][next] = 1;\n                    q.push(next);\n                }\n            }\n        }\n        return reachable;\n    }\n    int findpath(int nod) {\n        for (int &i = edgeview[nod]; i < graph[nod].size(); i++) {\n            int adj = graph[nod][i];\n            int next = matched[adj];\n            if (next >= 0 && level[next] != level[nod] + 1) continue;\n            if (next == -1 || findpath(next)) {\n                match[nod] = adj;\n                matched[adj] = nod;\n                return 1;\n            }\n        }\n        return 0;\n    }\n    int solve() {\n        int ans = 0;\n        while (assignLevel()) {\n            edgeview.assign(n, 0);\n            for (int i = 0; i < n; i++)\n                if (match[i] == -1)\n                    ans += findpath(i);\n        }\n        return ans;\n    }\n};\n\n\nint main()\n{\n    notprime[1] = true;\n    for (int i = 3; i <= 10000010; i += 2)\n    {\n        if (notprime[i]) continue;\n        for (int j = i * 3; j <= 10000010; j += i * 2)\n            notprime[j] = true;\n    }\n\n    scanf(\"%d\",&n);\n    for (int i = 0; i < n; i++) scanf(\"%d\", &x[i]);\n    sort(x, x + n);\n\n    for (int i = 0; i < n; i++)\n    {\n        add(x[i]);\n        add(x[i] + 1);\n    }\n\n    if (vt[0].empty() || vt[1].empty())\n    {\n        printf(\"%d\\n\", n);\n        return 0;\n    }\n\n    BipartiteMatching bm(vt[0].size(), vt[1].size());\n    for (int i = 0; i < vt[0].size(); i++)\n    {\n        for (int j = 0; j < vt[1].size(); j++)\n        {\n            if (notprime[abs(vt[0][i] - vt[1][j])] == false)\n                bm.graph[i].push_back(j);\n        }\n    }\n\n    int ret = bm.solve();\n\n    printf(\"%d\\n\", (int)(ret + (vt[0].size() - ret) / 2 * 2 + (vt[1].size() - ret) / 2 * 2 + (vt[0].size() - ret) % 2 * 3));\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define rg register\nusing namespace std;\nconst int MAXN=1010;\nstruct gao{   int u,v,Next;   }Edge[MAXN<<1];\nint n,Lo,Le,Seq[10000010],Odd[MAXN],Even[MAXN];\nint Ans,Es,Ps,First[MAXN],Match[MAXN],Vis[MAXN];\ninline int Read()\n{   rg int a=0,c=1;   rg char b=getchar();\n\twhile(b!='-'&&(b<'0'||b>'9'))b=getchar();\n\tif(b=='-')c=-1,b=getchar();\n\twhile(b>='0'&&b<='9')a=a*10+b-48,b=getchar();\n\treturn a*c;\n}\ninline void Link(rg int u,rg int v)\n{   Edge[++Es]=(gao){u,v,First[u]},First[u]=Es;   }\ninline int Abs(rg int A){   return A<0?-A:A;   }\ninline bool Judge(rg int Num)\n{   if(Num%2==0||Num<=2) return 0;\n\tfor(rg int i=3,End=sqrt(Num);i<=End;i+=2)\n\t\tif(Num%i==0) return 0;\n\treturn 1;\n}\ninline bool Couple(rg int Now,rg int Sign)\n{   for(rg int i=First[Now];i!=-1;i=Edge[i].Next)\n\t{   rg int v=Edge[i].v;   if(Vis[v]==Sign) continue ;\n\t\tVis[Now]=Sign;\n\t\tif(!Match[v]||Couple(Match[v],Sign)) return Match[v]=Now,Match[Now]=v,1;\n\t}\n\treturn 0;\n}\nint main()\n{   scanf(\"%d\",&n);\n\tmemset(First,-1,sizeof(First));\n\tfor(rg int i=1;i<=n;i++) Seq[Read()]=1;\n\tfor(rg int i=1e7+1;i>=1;i--) Seq[i]=Seq[i]!=Seq[i-1];\n\tfor(rg int i=1;i<=1e7+1;i++) if(Seq[i]) i%2?Odd[++Lo]=i:Even[++Le]=i;\n\tif((Lo+Le)%2) return puts(\"0\");\n\tfor(rg int i=1;i<=Lo;i++)\n\t\tfor(rg int j=1;j<=Le;j++) if(Judge(Abs(Odd[i]-Even[j]))) Link(i,Lo+j),Link(Lo+j,i);\n\tfor(rg int i=1;i<=Lo;i++) if(!Match[i]) Ps+=Couple(i,i);\n\tAns=Ps+(Lo-Ps)/2*2+(Le-Ps)/2*2+((Lo-Ps)%2)*3,printf(\"%d\\n\",Ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author\n */\n\n#ifndef MAJK_LIB\n#define MAJK_LIB\n\n#include <vector>\n#include <stack>\n#include <iostream>\n#include <unordered_map>\n#include <map>\n#include <iomanip>\n#include <set>\n#include <functional>\n#include <fstream>\n#include <algorithm>\n#include <cassert>\n#include <cmath>\n#include <string>\n#include <sstream>\n#include <queue>\n#include <bitset>\nusing namespace std;\n\n#define x first\n#define y second\nconstexpr int MOD = 1000000007;\n\ntypedef std::pair<int,int> pii;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef unsigned int ui;\n\n\ntemplate<typename T, typename F> T foo(T t, T g, F f) {\n\treturn t;\n}\n\n\ntemplate <typename T, typename U> std::istream&operator>>(std::istream&i, pair<T,U>&p) {i >> p.x >> p.y; return i;}\ntemplate<typename T>std::istream&operator>>(std::istream&i,vector<T>&t) {for(auto&v:t){i>>v;}return i;}\ntemplate<typename T>std::ostream&operator<<(std::ostream&o,const vector<T>&t) {for(size_t i=0;i<t.size();++i){o<<t[i]<<\" \\n\"[i == t.size()-1];}return o;}\ntemplate<typename T> using minheap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<typename T> using maxheap = priority_queue<T, vector<T>, less<T>>;\nauto fraclt = [](const pii&a,const pii&b) { return (ll)a.x * b.y < (ll)b.x * a.y; };\nstruct cmpfrac { bool operator()(const pii&a,const pii&b)const { return (ll)a.x * b.y < (ll)b.x * a.y; }};\ntemplate <typename T> bool in(T a, T b, T c) { return a <= b && b < c; }\nint logceil(ll x) {int b=0;while(x){x>>=1;++b;}return b;}\n\nnamespace std {\n    template<typename T,typename U>struct hash<pair<T,U>>{hash<T>t;hash<U>u;size_t operator()(const pair<T,U>&p)const{return t(p.x)^(u(p.y)<<7);}};\n}\ntemplate<typename T,typename F>T bsh(T l,T h,const F&f){T r=-1,m;while(l<=h){m=(l+h)/2;if(f(m)){l=m+1;r=m;}else{h=m-1;}}return r;}\ntemplate<typename T,typename F>T bsl(T l,T h,const F&f){T r=-1,m;while(l<=h){m=(l+h)/2;if(f(m)){h=m-1;r=m;}else{l=m+1;}}return r;}\ntemplate<typename T> T gcd(T a,T b) { if (a<b) swap(a,b); return b?gcd(b,a%b):a; }\n\ntemplate<typename T>class vector2:public vector<vector<T>>{public:vector2(){} vector2(size_t a,size_t b,T t=T()):vector<vector<T>>(a,vector<T>(b,t)){}};\ntemplate<typename T>class vector3:public vector<vector<vector<T>>>{public:vector3(){} vector3(size_t a,size_t b,size_t c,T t=T()):vector<vector<vector<T>>>(a,vector<vector<T>>(b,vector<T>(c,t))){}};\ntemplate <typename T> struct bounded_priority_queue {\n\tinline bounded_priority_queue(ui X) : A(X), B(0) {}\n\tinline void push(ui L, T V) { B = max(B, L); A[L].push(V); }\n\tinline const T &top() const { return A[B].front(); }\n\tinline void pop() { A[B].pop(); while (B > 0 && A[B].empty()) --B; }\n\tinline bool empty() const { return A[B].empty(); }\n\tinline void clear() { B = 0; for (auto &a: A) a = queue<T>(); }\nprivate:\n\tvector<queue<T>> A; ui B;\n};\n\n\n#endif\n#ifndef PRIMES_H\n#define PRIMES_H\n\n\n\n\nstruct Sieve : public std::vector<bool> {\n\texplicit Sieve(int n) : vector<bool>(n+1, true), n(n) {\n\t\tat(0) = false;\n\t\tat(1) = false;\n\t\tfor (int i = 2; i*i <= n; ++i) {\n\t\t\tif (at(i)) for (int j = i*i; j <= n; j+=i) (*this)[j] = false;\n\t\t}\n\t}\n\n\tvector<int> primes() const {\n\t\tvector<int> ans;\n\t\tfor (int i=2; i<=n; ++i) if (at(i)) ans.push_back(i);\n\t\treturn ans;\n\t}\n\nprivate:\n\tint n;\n};\n\nstruct Moebius : public std::vector<std::pair<int, int>> {\n\texplicit Moebius(int n) : Moebius(n, Sieve{n}.primes()) {}\n\n\tMoebius(int n, const vector<int>& primes) {\n\t\tsearch(-1, 1, 1, n, primes);\n\t\tstd::sort(begin(), end());\n\t}\nprivate:\n\tvoid search(int i, int x, int y, int n, const vector<int>&primes) {\n\t\tpush_back({x,y});\n\t\twhile (++i < primes.size() && (ll)x * primes[i] <= n) search(i, x*primes[i], -y, n, primes);\n\t}\n};\n\n#endif //PRIMES_H\n\n\nclass F {\npublic:\n\tSieve S{10000000};\n\tvector<int> X;\n\n\tint cost(int x) {\n\t\tif (x == 0) return 0;\n\t\tif (x%2==0) return 2;\n\t\tif (S[x]) return 1;\n\t\treturn 3;\n\t}\n\n\tvoid solve(istream& cin, ostream& cout) {\n\t\tint N; cin >> N;\n\t\tX.resize(N);\n\t\tcin >> X;\n\n\t\tvector2<int> D(N, N, 10000);\n\t\tvector2<int> J(N, N, 10000);\n\t\tfor (int l = 0; l < N; ++l) {\n \t\t\tfor (int i = 0; i + l < N; ++i) {\n\t\t\t\tint j = i + l;\n\t\t\t\tif (l == 0) {\n\t\t\t\t\tD[i][j] = 3;\n\t\t\t\t\tJ[i][j] = 0;\n\t\t\t\t}\n\t\t\t\tfor (int k = i; k < j; ++k) {\n\t\t\t\t\tJ[i][j] = min(J[i][j], J[i][k] + J[k+1][j] + cost(X[k+1] - X[k] - 1));\n\t\t\t\t\tD[i][j] = min(D[i][j], D[i][k] + D[k+1][j]);\n\t\t\t\t\tD[i][j] = min(D[i][j], J[i][k] + J[k+1][j] + cost(X[j] - X[k]) + cost(X[k+1] - X[i]));\n\t\t\t\t}\n\n\t\t\t\tfor (int k = i; k < j-1; ++k) {\n\t\t\t\t\tfor (int m = k+1; m < j; ++m) {\n\t\t\t\t\t\tJ[i][j] = min(J[i][j], J[i][k] + J[m+1][j] + D[k+1][m] + cost(X[m+1] - X[k] - 1));\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tD[i][j] = min(D[i][j], J[i][j] + cost(X[j] - X[i] + 1));\n\t\t\t\tJ[i][j] = min(J[i][j], D[i][j] + cost(X[j] - X[i] + 1));\n\n\t\t\t}\n\t\t}\n\n\t\t//cerr << D;\n\t\t//cerr << J;\n\n\n\t\tcout << D[0][N-1] << endl;\n    }\n};\n\n\nint main() {\n\tios_base::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr);\n\tF solver;\n\tstd::istream& in(std::cin);\n\tstd::ostream& out(std::cout);\n\tsolver.solve(in, out);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <cstdio>\n\nusing namespace std;\n\nconst int N=105;\nconst int M=N*N;\nconst int L=10000000;\n\nint last[N],bel[N];\nint nxt[M],tov[M];\nbool mark[L+5];\nint pos[2][N];\nbool vis[N];\nint n,tot,mx,match,ans;\n\ninline int iabs(int x){return x>0?x:-x;}\n\ninline void insert(int x,int y){tov[++tot]=y,nxt[tot]=last[x],last[x]=tot;}\n\ninline bool is_prime(int x)\n{\n\tfor (int i=1;i*i<=x;++i) if (!(x%i)) return 0;\n\treturn 1;\n}\n\nbool hungary(int x)\n{\n\tif (vis[x]) return 0;\n\tvis[x]=1;\n\tfor (int i=last[x],y;i;i=nxt[i])\n\t\tif (!bel[y=tov[i]]||hungary(y))\n\t\t\treturn bel[y]=x;\n\treturn 0;\n}\n\nint main()\n{\n\t//freopen(\"flip.in\",\"r\",stdin),freopen(\"flip.out\",\"w\",stdout);\n\tscanf(\"%d\",&n);\n\tfor (int i=1,x;i<=n;++i) scanf(\"%d\",&x),mx=max(mx,x),mark[x]=1;\n\tfor (int i=1;i<=mx+1;++i)\n\t\tif (mark[i]^mark[i-1])\n\t\t\tif (i&1) pos[1][++pos[1][0]]=i;\n\t\t\telse pos[0][++pos[0][0]]=i;\n\tfor (int i=1;i<=pos[0][0];++i)\n\t\tfor (int j=1;j<=pos[1][0];++j)\n\t\t{\n\t\t\tint d=iabs(i-j);\n\t\t\tif ((d&1)&&is_prime(d)) insert(i,j);\n\t\t}\n\tmatch=0;\n\tfor (int i=1;i<=pos[0][0];++i) memset(vis,0,sizeof vis),match+=hungary(i);\n\tans=match,pos[0][0]-=match,pos[1][0]-=match;\n\tans+=(pos[0][0]>>1)+(pos[1][0]>>1)<<1;\n\tpos[0][0]&=1,pos[1][0]&=1;\n\tif (pos[0][0]) ans+=3;\n\tprintf(\"%d\\n\",ans);\n\t//fclose(stdin),fclose(stdout);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#define fo(i,a,b) for(int i=a;i<=b;i++)\n#define fd(i,b,a) for(int i=b;i>=a;i--)\n#define efo(i,u,v) for(int i=BB[u],v=B[BB[u]][1];i;v=B[i=B[i][0]][1])\n#define mset(a,x) memset(a,x,sizeof(a))\nusing namespace std;\ntypedef long long ll;\nchar ch;\nint read(){int n=0,p=1;for(ch=getchar();ch<'0' || '9'<ch;ch=getchar())if(ch=='-') p=-1;for(;'0'<=ch && ch<='9';ch=getchar()) n=n*10+ch-'0';return n*p;}\nconst int N=205,M=2e7+5;\nint n,m,a[N],d[N<<1],pr[M];\nbool b[M],c[M],bz[M];\nvoid prep()\n{\n\tmset(bz,1);\n\tbz[0]=bz[1]=0;\n\tfo(i,2,m)\n\t{\n\t\tif(bz[i]) pr[++pr[0]]=i;\n\t\tfo(j,1,pr[0])\n\t\t{\n\t\t\tll x=(ll)i*pr[j];\n\t\t\tif(x>m) break;\n\t\t\tbz[x]=0;\n\t\t\tif(i%pr[j]==0) break;\n\t\t}\n\t}\n}\n\nconst int V=N<<3,INF=1e9;\nconst int E=10*V*V;\nint B0,S,T,BB[V];\nll ans,dis[V],B[E][4];\nbool vis[V];\nvoid link(int u,int v,int r,ll w)\n{\n\tB[++B0][1]=v,B[B0][2]=r,B[B0][3]=w,B[B0][0]=BB[u],BB[u]=B0;\n\tif(!(B0&1)) link(v,u,0,-w);\n}\nll aug(int v,ll flow)\n{\n\tvis[v]=1;\n\tif(v==T)\n\t{\n\t\tans+=dis[S]*flow;\n\t\treturn flow;\n\t}\n\tefo(i,v,u)\n\t\tif(B[i][2] && !vis[u] && dis[v]==dis[u]+B[i][3])\n\t\t{\n\t\t\tll f=aug(u,min(flow,B[i][2]));\n\t\t\tif(f)\n\t\t\t{\n\t\t\t\tB[i][2]-=f,B[i^1][2]+=f;\n\t\t\t\treturn f;\n\t\t\t}\n\t\t}\n\treturn 0;\n}\nbool change()\n{\n\tll minh=INF;\n\tfo(u,S,T) if(vis[u])\n\t\tefo(i,u,v) if(!vis[v])\n\t\t\tif(B[i][2]) minh=min(minh,dis[v]+B[i][3]-dis[u]);\n\tif(minh==INF) return 0;\n\tfo(i,S,T) if(vis[i]) dis[i]+=minh,vis[i]=0;\n\treturn 1;\n}\nint main()\n{\n\tn=read();\n\tfo(i,1,n) b[a[i]=read()]=1,m=max(m,a[i]);\n\t++m;\n\tprep();\n\tfo(i,1,m) c[i]=b[i]^b[i-1];\n\tfo(i,1,m) if(c[i]) d[++d[0]]=i;\n\t\n\tB0=1,S=0,T=d[0]+d[0]+1;\n\tfo(i,1,d[0]-1)\n\t\tfo(j,i+1,d[0])\n\t\t{\n\t\t\tif((d[j]-d[i])%2==0) link(i,d[0]+j,1,2),link(j,d[0]+i,1,2);\n\t\t\telse\n\t\t\tif(bz[d[j]-d[i]]) link(i,d[0]+j,1,1),link(j,d[0]+i,1,1);\n\t\t\telse link(i,d[0]+j,1,3),link(j,d[0]+i,1,3);\n\t\t}\n\tfo(i,1,d[0]) link(S,i,1,0),link(d[0]+i,T,1,0);\n\t\n\tdo\n\t{\n\t\twhile(aug(S,INF)) mset(vis,0);\n\t}\n\twhile(change());\n\tprintf(\"%lld\",ans/2);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/********************************************************************************\n\t\n\tCode by a weak man named CYJian, and he hopes the code can get more points.\n\n\tAlgorithm: \n\n ********************************************************************************/\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\n//{{{ FAST IO AND SOME FUNCTIONS\nconst int __SIZE = 1 << 18;\nchar ibuf[__SIZE], *iS, *iT;\n\n#define ge (iS == iT ? (iT = (iS = ibuf) + fread(ibuf, 1, __SIZE, stdin), (iS == iT ? EOF : *iS++)) : *iS++)\n#define ri read_int()\n#define rl read_ll()\n#define FILE(s) freopen(s\"in\", \"r\", stdin), freopen(s\"out\", \"w\", stdout)\n\ntemplate<typename T>\ninline void read(T &x) {\n\tchar ch, t = 0; x = 0;\n\twhile(!isdigit(ch = ge)) t |= ch == '-';\n\twhile(isdigit(ch)) x = x * 10 + (ch ^ 48), ch = ge;\n\tx = t ? -x : x;\n}\ninline int read_int() { int x; return read(x), x; }\ninline ll read_ll() { ll x; return read(x), x; }\n\ntemplate<typename T> inline void chkmin(T&a, T b) { a = a < b ? a : b; }\ntemplate<typename T> inline void chkmax(T&a, T b) { a = a > b ? a : b; }\n//}}}\n\nint tot;\nint pri[5010];\nint chk[5010];\n\ninline void Sieve(int n) {\n\tchk[1] = 0;\n\tfor(int i = 2; i <= n; i++) {\n\t\tif(!chk[i]) pri[++tot] = i;\n\t\tfor(int j = 1; j <= tot; j++) {\n\t\t\tif(i * pri[j] > n) break;\n\t\t\tchk[i * pri[j]] = 0;\n\t\t\tif(i % pri[j] == 0) break;\n\t\t}\n\t}\n}\n\ninline int check(int x) {\n\tif(x <= 5000) return !chk[x];\n\tfor(int *p = pri + 1;; ++p) {\n\t\tif((*p) * (*p) > x) return 1;\n\t\tif(x % (*p) == 0) return 0;\n\t}\n}\n\nvector<int>to[210];\nint vis[210];\nint inq[210];\nint p[210];\nint N;\n\ninline int Try(int x) {\n\tinq[x] = 1;\n\tfor(auto u : to[x]) {\n\t\tif(!vis[u]) {\n\t\t\tvis[u] = x;\n\t\t\tvis[x] = u;\n\t\t\tinq[x] = 0;\n\t\t\treturn 1;\n\t\t} else if(!inq[vis[u]] && Try(vis[u])) {\n\t\t\tvis[u] = x;\n\t\t\tvis[x] = u;\n\t\t\tinq[x] = 0;\n\t\t\treturn 1;\n\t\t}\n\t} return inq[x] = 0;\n}\n\nint main() {\n#ifdef LOCAL\n\tFILE(\"\");\n#endif\n\n\tSieve(5000);\n\tint n = ri, ce = 0, co = 0;\n\n\tfor(int i = 1; i <= n; i++) {\n\t\tint x = ri;\n\t\tif(p[N] == x) --N;\n\t\telse p[++N] = x;\n\t\tp[++N] = x + 1;\n\t}\n\n\tfor(int i = 1; i <= N; i++) \n\t\tp[i] & 1 ? ++co : ++ce;\n\n\tfor(int i = 1; i <= N; i++)\n\t\tfor(int j = i + 1; j <= N; j++) {\n\t\t\tif(((p[i] ^ p[j]) & 1) && check(p[j] - p[i]))\n\t\t\t\tto[i].push_back(j), to[j].push_back(i);\n\t\t}\n\n\tint res = 0;\n\tfor(int i = 1; i <= N; i++)\n\t\tif((p[i] & 1) && Try(i))\n\t\t\t--co, --ce, ++res;\n\n\tres += (co / 2 + ce / 2) << 1;\n\tif((co | ce) & 1) res += 3;\n\n\tcout << res << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int max_n=205;\nconst int max_m=10005;\nstruct edge{\n    int u,v,next;\n}G[max_m*2];\nint head[max_n],tot;\nvoid init(int n){\n    tot=0;\n    for(int i=0;i<=n;i++)head[i]=-1;\n}\nint match[max_n];\nbool used[max_n];\nvoid add_edge(int u,int v){\n    G[tot]={u,v,head[u]};\n    head[u]=tot++;\n}\nbool dfs(int u){\n    used[u]=true;\n    for(int i=head[u];~i;i=G[i].next){\n        int v=G[i].v,w=match[v];\n        if(w<0||!used[w]&&dfs(w)){\n            match[u]=v,match[v]=u;\n            return true;\n        }\n    }\n    return false;\n}\nint solve(int n,int m){\n    int res=0;\n    for(int i=0;i<=n+m;i++)match[i]=-1;\n    for(int u=1;u<=n;u++){\n        if(match[u]==-1){\n            for(int i=0;i<=n+m;i++)used[i]=false;\n            if(dfs(u))res++;\n        }\n    }\n    return res;\n}\nint n,a[max_n];\nbool vis[10000005];\nbool p[10000005];\nint pri[10000005],cnt;\nvoid sieve(int n){\n    p[0]=p[1]=true;\n    for(int i=2;i<=n;i++){\n        if(!p[i])pri[++cnt]=i;\n        for(int j=1;j<=cnt&&1ll*i*pri[j]<=n;j++){\n            p[i*pri[j]]=true;\n            if(i%pri[j]==0)break;\n        }\n    }\n}\nint main(){\n    scanf(\"%d\",&n);\n    for(int i=1;i<=n;i++)scanf(\"%d\",a+i);\n    for(int i=1;i<=n;i++)vis[a[i]]^=1,vis[a[i]+1]^=1;\n    sieve(10000000);\n    vector<int> odd,even;\n    for(int i=1;i<=10000001;i++){\n        if(vis[i]){\n            if(i&1)odd.push_back(i);\n            else even.push_back(i);\n        }\n    }\n    int nn=odd.size(),mm=even.size();\n    init(nn+mm);\n    for(int i=0;i<nn;i++){\n        for(int j=0;j<mm;j++){\n            if(!p[abs(even[j]-odd[i])]){\n                add_edge(i+1,j+1+nn),add_edge(j+1+nn,i+1);\n            }\n        }\n    }\n    int x=solve(nn,mm);\n    int ans=x+(nn-x)/2*2+(mm-x)/2*2+(nn-x)%2*3;\n    printf(\"%d\\n\",ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntemplate<typename T> read(T &x)\n{\n\tchar ch=getchar();\n\tfor (x=0;ch<'0'||ch>'9';ch=getchar());\n\tfor (;ch>='0'&&ch<='9';x=x*10+ch-'0',ch=getchar());\n}\n#define INF 0x3f3f3f3f\nvector<int> odd,even;\nbool vis[10000010];\nint prime[1000010],p_cnt;\nint n;\nint a[110];\nnamespace Network\n{\n\tstruct edge{\n\t\tint s,t,cap,next;\n\t}e[100010];\n\tint head[510],cnt;\n\tvoid addedge(int s,int t,int cap)\n\t{\n\t\te[cnt].s=s;e[cnt].t=t;e[cnt].cap=cap;e[cnt].next=head[s];head[s]=cnt++;\n\t\te[cnt].s=t;e[cnt].t=s;e[cnt].cap=0;e[cnt].next=head[t];head[t]=cnt++;\n\t}\n\tqueue<int> q;\n\tint s,t;\n\tint dis[510]; \n\tbool bfs()\n\t{\n\t\tq.push(s);\n\t\tmemset(dis,0x3f,sizeof(dis));\n\t\tdis[s]=0;\n\t\twhile (!q.empty())\n\t\t{\n\t\t\tint tmp=q.front();\n\t\t\tq.pop();\n\t\t\tfor (int i=head[tmp];i!=-1;i=e[i].next)\n\t\t\t\tif (e[i].cap && dis[e[i].t]==INF)\n\t\t\t\t{\n\t\t\t\t\tdis[e[i].t]=dis[tmp]+1;\n\t\t\t\t\tq.push(e[i].t);\n\t\t\t\t}\n\t\t}\n\t\treturn dis[t]!=INF;\n\t}\n\tint find(int x,int low)\n\t{\n\t    if (x==t)\n\t        return low;\n\t    int used=0;\n\t    for (int i=head[x];i!=-1;i=e[i].next)\n\t        if (e[i].cap>0 && dis[e[i].t]==dis[x]+1)\n\t        {\n\t            int flow=find(e[i].t,min(low-used,e[i].cap));\n                e[i].cap-=flow;\n                e[i^1].cap+=flow;\n                used+=flow;\n                if (used==low)\n                    return low;\n\t        }\n\t    if (!used)\n\t        dis[x]=-1;\n\t    return used;\n\t}\n\tint dinic()\n\t{\n\t\tmemset(head,0xff,sizeof(head));\n\t\tcnt=0;\n\t\ts=0,t=odd.size()+even.size()+1;\n\t\tfor (int i=0;i<odd.size();i++)\n\t\t\taddedge(s,i+1,1);\n\t\tfor (int i=0;i<even.size();i++)\n\t\t\taddedge(odd.size()+i+1,t,1);\n\t\tfor (int i=0;i<odd.size();i++)\n\t\t\tfor (int j=0;j<even.size();j++)\n\t\t\t\tif (!vis[abs(odd[i]-even[j])])\n\t\t\t\t\taddedge(i+1,odd.size()+j+1,1);\n\t    int ans=0;\n\t    while (bfs())\n\t        ans+=find(s,INF);\n\t    return ans;\n\t}\n}\nvoid ins(int x)\n{\n\tif (x&1)\n\t\todd.push_back(x);\n\telse\n\t\teven.push_back(x);\n}\nvoid pre()\n{\n\tvis[1]=1; \n    for (int i=2;i<=10000000;i++)\n    {\n        if (!vis[i])\n            prime[++p_cnt]=i;\n        for (int j=1;j<=p_cnt&&i*prime[j]<=10000000;j++)\n        {\n            vis[i*prime[j]]=1;\n            if (i%prime[j]==0)\n                break;\n        }\n    }\n}\nint main()\n{\n\tread(n);\n\tfor (int i=1;i<=n;i++)\n\t\tread(a[i]);\n\tsort(a+1,a+n+1);\n\ta[0]=-1;\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tif (a[i-1]!=a[i]-1)\n\t\t\tins(a[i]);\n\t\tif (a[i+1]!=a[i]+1)\n\t\t\tins(a[i]+1);\n\t}\n\tpre();\n\tint k=Network::dinic();\n\tprintf(\"%d\\n\",k+2*((odd.size()-k)/2+(even.size()-k)/2)+3*(odd.size()%2));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nconst int N = 205, M = 10000005;\nint tot = 0, s[N];\n\nbool prime(int n) {\n\tif (n <= 2) return 0;\n\tfor (int i = 2; i * i <= n; ++i)\n\t\tif (n % i == 0) return 0;\n\treturn 1;\n}\nbool e[N][N];\n\nstd::vector<int> L, R;\nint l, r, bel[N], match; bool vis[N];\n\nbool dfs(int x) {\n\tfor (int i = 0; i < r; ++i) if (e[x][i] && !vis[i]) {\n\t\tvis[i] = 1;\n\t\tif (!~bel[i] || dfs(bel[i])) {\n\t\t\tbel[i] = x; return 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nint main() {\n\tstd::ios::sync_with_stdio(0), std::cin.tie(0);\n\tint n; std::cin >> n;\n\tfor (int i = 0; i < n; ++i) {\n\t\tint x; std::cin >> x;\n\t\tif (s[tot] == x) --tot;\n\t\telse s[++tot] = x;\n\t\ts[++tot] = x + 1;\n\t}\n\tfor (int i = 1; i <= tot; ++i)\n\t\t(s[i] & 1 ? L : R).emplace_back(s[i]);\n\tl = L.size(), r = R.size(), std::memset(bel, -1, sizeof bel);\n\tfor (int i = 0; i < l; ++i)\n\t\tfor (int j = 0; j < r; ++j)\n\t\t\te[i][j] = prime(std::abs(L[i] - R[j]));\n\tfor (int i = 0; i < l; ++i) std::memset(vis, 0, r), match += dfs(i);\n\tstd::cout << l + r - match + (l - match & 1) << '\\n';\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<cstring>\n\nusing namespace std;\nint n;\nconst int maxn = 1e7+5;//40M\nconst int S = 1e7+2;\nint pri[maxn],cnt; bool mk[maxn];\nint A[maxn];\nvoid oula() {\n\tmk[1] = mk[0] = 1;\n\tfor(int i=1;i<=S;i++) {\n\t\tif(!mk[i]) { pri[++cnt]=i; }\n\t\tfor(int j=1;j<=cnt&&1ll*pri[j]*i<=S;j++) {\n\t\t\tint k = pri[j]*i;\n\t\t\tmk[k] = 1;\n\t\t\tif(i%pri[j]==0) break;\n\t\t}\n\t}\n}\nint la[405],en[405*405],owo,nt[405*405];\nvoid adg(int x,int y) {\n\ten[++owo]=y; nt[owo]=la[x]; la[x]=owo;\n}\nint cc[2];\nint yo[2][405];\nint link[405],vis[405];\nbool hungary(int x) {\n\tfor(int it=la[x];it;it=nt[it]) {\n\t\tint y = en[it];\n\t\tif(vis[y]) continue;\n\t\tvis[y] = 1;\n\t\tif((!link[y])||(hungary(link[y]))) {\n\t\t\tlink[y] = x; return 1;\n\t\t}\n\t}\n\treturn 0;\n}\nint main() {\n\toula();\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++) {\n\t\tint x; scanf(\"%d\",&x); A[x] = 1;\n\t}\n\tfor(int i=1;i<=S;i++) {\n\t\tint cf = A[i-1]^A[i];\n\t\tif(cf) {\n\t\t\t++cc[i&1];\n\t\t\tyo[i&1][cc[i&1]] = i;\n\t\t}\n\t}\n\tfor(int i=1;i<=cc[0];i++) {\n\t\tfor(int j=1;j<=cc[1];j++) {\n\t\t\tif(!mk[abs(yo[0][i]-yo[1][i])]) adg(i,j);\n\t\t}\n\t}\n\tint ans = 0;\n\tfor(int i=1;i<=cc[0];i++) {\n\t\tfor(int j=1;j<=cc[1];j++) vis[j] = 0;\n\t\tans += hungary(i);\n\t}\n\tcc[0]-=ans; cc[1]-=ans;\n\tprintf(\"%d\",ans+cc[0]/2*2 + cc[1]/2*2 + (cc[0]&1)*3 );\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nconst int N=205;\nint n,Mat[N],a[N],b[N],Ans;\nbool G[N][N],v[N];\nstd::map<int,int> M;\n\nbool Prime(int x)\n{\n\tif(x<=1)return false;\n\tfor(int i=2;i*i<=n;++i)if(x%i==0)return false;\n\treturn true;\n}\n\nbool DFS(int i) {\n\tfor(int j=1;j<=n;j++)\n\t\tif(!v[j]&&G[i][j]) {\n\t\t\tv[j]=1;\n\t\t\tif(!Mat[j]||DFS(Mat[j])) { Mat[j]=i;return 1; }\n\t\t}\n\treturn 0;\n}\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1,x;i<=n;++i)scanf(\"%d\",&x),M[x]^=1,M[x+1]^=1;\n\tfor(auto x:M)if(x.second)(x.first&1?a[++*a]:b[++*b])=x.first;\n\tfor(int i=1;i<=*a;++i)\n\t\tfor(int j=1;j<=*b;++j)\n\t\t\tif(Prime(std::abs(a[i]-b[j])))\n\t\t\t\tG[i][j]=1;\n\tfor(int i=1;i<=*a;++i)memset(v,0,sizeof v),Ans+=DFS(i);\n\treturn printf(\"%d\\n\",Ans+(*a-Ans)/2*2+(*b-Ans)/2*2+(*a-Ans)%2*3),0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <cstring>\n#include <cmath>\nusing namespace std;\n\nconst int MAX_N = 100 + 9;\nconst int MAX_M = 1e7;\n\nint N, x, cnt, match[MAX_N], V;\nbool is_prime[MAX_M + 1], rev[MAX_M + 1], used[MAX_N];\nvector<int> primes, v1, v2, G[MAX_N];\n\nvoid sieve() {\n\tmemset(is_prime, 1, sizeof(is_prime));\n\tis_prime[0] = is_prime[1] = 0;\n\tfor (int i = 2; i <= MAX_M; i++) {\n\t\tif (is_prime[i]) {\n\t\t\tprimes.push_back(i);\n\t\t\tfor (int j = i * 2; j <= MAX_M; j += i) is_prime[j] = 0;\n\t\t}\n\t}\n}\n\nbool dfs(int v) {\n\tused[v] = true;\n\tfor (int i = 0; i < G[i].size(); i++) {\n\t\tint u = G[u][i], w = match[u];\n\t\tif (w < 0 || !used[u] && dfs(w)) {\n\t\t\tmatch[v] = u;\n\t\t\tmatch[u] = v;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nvoid bipartite_matching() {\n\tmemset(match, -1, sizeof(match));\n\tfor (int v = 0; v < V; v++) {\n\t\tif (match[v] < 0) {\n\t\t\tmemset(used, 0, sizeof(used));\n\t\t\tif (dfs(v)) {\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\tscanf(\"%d\", &N); sieve();\n\tfor (int i = 1; i <= N; i++) scanf(\"%d\", &x), rev[x] ^= true;\n\tfor (int i = 1; i <= MAX_M; i++) {\n\t\tif (rev[i] != rev[i - 1]) {\n\t\t\tif (i & 1) v1.push_back(i);\n\t\t\telse v2.push_back(i);\n\t\t}\n\t}\n\tfor (int i = 0; i < v1.size(); i++) {\n\t\tfor (int j = 0; j < v2.size(); j++) {\n\t\t\tif (is_prime[(int)abs(v1[i] - v2[j])]) G[i].push_back(j + v1.size());\n\t\t}\n\t}\n\tV = v1.size() + v2.size();\n\tbipartite_matching();\n\tprintf(\"%d\", cnt + (v1.size() - cnt >> 1 << 1) + (v2.size() - cnt >> 1 << 1) + ((v1.size() - cnt) & 1) * 3);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<queue>\n#include<algorithm>\nusing namespace std;\nconst int maxn=510,maxL=10000010,inf=0x3f3f3f3f;\nstruct cyc{int v,flow,from;}e[maxn*maxn*2];\nint tot=1,cnt,n,first[maxn],d[maxn],S,T,num[maxn],b[maxn],cur[maxn];\nbool c[maxL];\ninline int ab(int x){return x>0?x:-x;}\nbool isprime(int x){\n\tif(x<=2)return 0;\n\tfor(int i=2;i*i<=x;i++)if(x%i==0)return 0;\n\treturn 1;\n}\nvoid insert(int u,int v,int w){\n\ttot++;e[tot].v=v;e[tot].flow=w;e[tot].from=first[u];first[u]=tot;\n\ttot++;e[tot].v=u;e[tot].flow=0;e[tot].from=first[v];first[v]=tot;\n}\nqueue<int>q;\nbool bfs(){\n\tmemset(d,-1,sizeof(d));\n\tq.push(S);d[S]=0;\n\twhile(!q.empty()){\n\t\tint x=q.front();q.pop();\n\t\tfor(int i=first[x];i;i=e[i].from)\n\t\tif(d[e[i].v]==-1&&e[i].flow){\n\t\t\td[e[i].v]=d[x]+1;\n\t\t\tq.push(e[i].v);\n\t\t}\n\t}\n\treturn d[T]!=-1;\n}\nint dinic(int x,int a){\n\tif(x==T||a==0)return a;\n\tint f,flow=0;\n\tfor(int& i=cur[x];i;i=e[i].from)\n\tif(d[e[i].v]==d[x]+1&&e[i].flow&&(f=dinic(e[i].v,min(a,e[i].flow)))>0){\n\t\te[i].flow-=f;\n\t\te[i^1].flow+=f;\n\t\ta-=f;\n\t\tflow+=f;\n\t\tif(a==0)break;\n\t}\n\treturn flow;\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++){scanf(\"%d\",&num[i]);c[num[i]]=1;}\n\tfor(int i=1;i<=maxL-5;i++)if(c[i]!=c[i-1])b[++cnt]=i;\n\tS=0;T=cnt+1;\n//\tfor(int i=1;i<=cnt;i++)printf(\"%d \",b[i]);printf(\"\\n\");\n\tint m1=0;\n\tfor(int i=1;i<=cnt;i++)if(b[i]&1){\n\t\tm1++;\n\t\tinsert(S,i,1);\n\t\tfor(int j=1;j<=cnt;j++)if(!(b[j]&1)&&isprime(ab(b[i]-b[j])))insert(i,j,1);\n\t}else{\n\t\tinsert(i,T,1);\n\t}\n\tint ans=0;\n\twhile(bfs()){\n\t\tfor(int i=S;i<=T;i++)cur[i]=first[i];\n\t\tans+=dinic(S,inf);\n\t}\n\t//if((m1-ans)%2)printf(\"%d\",cnt-ans+1);else\n\t//printf(\"%d\",cnt-ans);\n\tprintf(\"%d\",cnt-ans+(m1-ans)%2);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//\n//  main.cpp\n//  F - Prime Flip\n//\n//  Created by Jędrzej Dudzicz on 04/02/2019.\n//  Copyright © 2019 Jędrzej Dudzicz. All rights reserved.\n//\n\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <algorithm>\n#include <cstdio>\n#include <utility>\nusing namespace std;\nconst int MXN=205;\nconst int MXM=1e7+5;\nint n,x;\nint s[MXM],s1[MXN];\nbool sito[MXM];\nint tab1[2*MXN],h;\nbool odw[2*MXN];\nint wynik;\nint main(){\n    for(int i=2;i*i<=MXM-1;i++){\n        if(sito[i]==0){\n            for(int j=i*i;j<=MXM-1;j+=i){\n                if(sito[j]==0)sito[j]=1;\n            }\n        }\n    }\n    sito[0]=1;\n    sito[1]=1;\n    scanf(\"%d\",&n);\n    for(int i=0;i<n;i++){\n        scanf(\"%d\",&x);\n        s[x]=1;\n    }\n    for(int i=1;i<=10000001;i++){\n        if(s[i]!=s[i-1]){\n            s1[i]=1;\n            tab1[h++]=i;\n        }\n    }\n    for(int i=0;i<h;i++){\n        if(odw[i]==0){\n            for(int j=0;j<h;j++){\n                if(i!=j&&odw[j]==0&&abs(tab1[j]-tab1[i])>=3&&sito[abs(tab1[j]-tab1[i])]==0){\n                    wynik++;\n                    odw[i]=1;odw[j]=1;\n                    //printf(\"%d %d\\n\",tab1[i],tab1[j]);\n                    break;\n                }\n            }\n        }\n    }\n    for(int i=0;i<h;i++){\n        if(odw[i]==0){\n            for(int j=0;j<h;j++){\n                if(i!=j&&odw[j]==0&&abs(tab1[j]-tab1[i])%2==0){\n                    wynik+=2;\n                    odw[i]=1;odw[j]=1;\n                    break;\n                }\n            }\n        }\n    }\n    for(int i=0;i<h;i++){\n        if(odw[i]==0){\n            for(int j=0;j<h;j++){\n                if(i!=j&&odw[j]==0&&abs(tab1[j]-tab1[i])%2==1){\n                    wynik+=3;\n                    odw[i]=1;odw[j]=1;\n                    break;\n                }\n            }\n        }\n    }\n    for(int i=0;i<h;i++){\n        if(odw[i]==0){\n            odw[i]=1;\n            wynik+=3;\n        }\n    }\n    printf(\"%d\\n\",wynik);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define pb push_back\nconst int maxn=210;\nint n,k,pri[10000010],linker[maxn],a[maxn],b[maxn];\nbool mark[10000010],vis[maxn];\nvector<int> v[maxn];\nvoid pre()\n{\n\tn=10000000;\n\tmark[1]=true;\n\tfor (int i=2;i<=n;i++)\n\t{\n\t\tif (!mark[i])\n\t\t{\n\t\t\tpri[k++]=i;\n\t\t\t//cerr<<i<<endl;\n\t\t}\n\t\tfor (int j=0;j<k;j++)\n\t\t{\n\t\t\tint m=i*pri[j];\n\t\t\tif (m>n)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmark[m]=true;\n\t\t\tif (i%pri[j]==0)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\nbool dfs(int x)\n{\n\tvis[x]=true;\n\tfor (int i=0;i<v[x].size();i++)\n\t{\n\t\tint y=v[x][i];\n\t\tif (vis[y])\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\t\tif (linker[y]==-1 || dfs(linker[y]))\n\t\t{\n\t\t\tlinker[y]=x;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\nint main()\n{\n\tpre();\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%d\",&a[i]);\n\t}\n\tint k=0;\n\tb[++k]=a[1]-1;\n\tfor (int i=2;i<=n;i++)\n\t{\n\t\tif (a[i]!=a[i-1]+1)\n\t\t{\n\t\t\tb[++k]=a[i-1];\n\t\t\tb[++k]=a[i]-1;\n\t\t}\n\t}\n\tb[++k]=a[n];\n\tn=k;\n\t/*\n\tif (n>200)\n\t{\n\t\treturn 0;\n\t}\n\t*/\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tlinker[i]=-1;\n\t\t//cerr<<b[i]<<endl;\n\t\tfor (int j=i+1;j<=n;j++)\n\t\t{\n\t\t\t/*\n\t\t\tif (abs(b[i]-b[j])>10000000)\n\t\t\t{\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\t*/\n\t\t\tif ((b[i]+b[j])&1 && !mark[abs(b[i]-b[j])])\n\t\t\t{\n\t\t\t\t//cerr<<i<<\" \"<<j<<\" \"<<abs(b[i]-b[j])<<\" \"<<mark[9]<<endl;\n\t\t\t\tif (b[i]&1)\n\t\t\t\t{\n\t\t\t\t\tv[i].pb(j);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tv[j].pb(i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint s=0;\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tif (!(b[i]&1))\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\t\tmemset(vis,false,sizeof(vis));\n\t\tif (dfs(i))\n\t\t{\n\t\t\ts++;\n\t\t}\n\t}\n\tint s1=0,s2=0;\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tif (b[i]&1)\n\t\t{\n\t\t\ts1++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\ts2++;\n\t\t}\n\t}\n\tint ans=s+((s1-s)/2+(s2-s)/2)*2+((s1-s)&1)*3;\n\tcout<<ans<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int maxm=1e7+10,maxn=210;\nint n,a[maxn],b[maxn],m,ans;\nint b1[maxn],b2[maxn],p1,p2;\nbool np[maxm],vis[maxn],g[maxn][maxn],s[maxm];\nint match[maxn];\nvector<int> p;\n\nvoid init(){\n\tnp[0]=np[1]=1;\n\tfor(int i=2;i<maxm;++i){\n\t\tif(!np[i]){\n\t\t\tp.push_back(i);\n\t\t\t//cerr<<i<<endl;\n\t\t\t//system(\"pause\");\n\t\t}\n\t\tfor(int j=0,j_end=p.size(),x;j<j_end&&(x=p[j]*i)<maxm;++j){\n\t\t\tnp[x]=true;\n\t\t\tif(i%p[j]==0)break;\n\t\t}\n\t}\n\tnp[2]=1;\n}\n\nbool dfs(int u){\n\tfor(int i=1;i<=p2;++i)if(g[u][i]&&!vis[i]){\n\t\tvis[i]=1;\n\t\tif(!match[i]||dfs(match[i])){\n\t\t\tmatch[i]=u;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\nvoid solve(){\n\tinit();\n\tcin>>n;\n\tfor(int i=1;i<=n;++i){cin>>a[i];s[a[i]]=1;}\n\tfor(int i=1;i<maxm;++i){\n\t\tif(s[i]!=s[i-1])b[++m]=i;//,cerr<<b[m]<<endl;\n\t}\n\t//cerr<<m<<endl;\n\tfor(int i=1;i<=m;++i){\n\t\tif(b[i]&1)b1[++p1]=b[i];\n\t\telse b2[++p2]=b[i];\n\t}\n\t//cerr<<p1<<\" \"<<p2<<endl;\n\tfor(int i=1;i<=p1;++i){\n\t\tfor(int j=1;j<=p2;++j){\n\t\t\tif(!np[abs(b1[i]-b2[j])]){\n\t\t\t\t//cerr<<i<<\" \"<<j<<endl;\n\t\t\t\tg[i][j]=true;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor(int i=1;i<=p1;++i){\n\t\tmemset(vis,0,sizeof vis);\n\t\tif(dfs(i))++ans;//match()\n\t}\n\tp1-=ans;p2-=ans;\n\t//cerr<<ans<<endl;\n\tans+=p1/2*2+p2/2*2;\n\tans+=p1%2*3;\n\t//cerr<<ans<<endl;\n\tcout<<ans<<endl;\n}\nint main(){\n\t/*#ifndef ONLINE_JUDGE\n\tfreopen(\"a.in\",\"r\",stdin);\n\tfreopen(\"a.out\",\"w\",stdout);\n\t#endif*/\n\tsolve();\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n ***\n Question Name:\n ***\n Question Link:\n \n ***\n Idea:\n */\n\n#include <memory.h>\n#include <iomanip>\n#include <algorithm>\n#include <iostream>\n#include <iterator>\n#include <numeric>\n#include <sstream>\n#include <fstream>\n#include <cassert>\n#include <climits>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n#include <cstdio>\n#include <vector>\n#include <cmath>\n#include <functional>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <list>\n#include <map>\n#include <set>\n#include <unordered_set>\n#include <unordered_map>\n\n#define REP(i,s,n) for(int (i)=s; (i)<(int)(n);(i)++)\n#define RIT(it,c) for(__typeof(c.begin()) it = c.begin();it!=c.end();it++)\n#define ALL(x) x.begin(), x.end()\n#define SZ(x) (int)(x).size()\n#define MSET(m,v) memset(m,v,sizeof(m))\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef long double LD;\ntypedef vector<int> vi;\ntypedef pair<int,int> ii;\ntypedef vector<LL> vL;\ntypedef vector<bool> vb;\ntypedef unordered_set<int> ui;\ntypedef pair<LL,LL> pLL;\n\nclass PrimeFlip{\n    int N = 1E7, n, m;\n    unordered_set<int> cnt;\n    vi odds,evens,mapping;\n    vb prime,vist;\n    vector<vb> E;\n    void init(){\n        int K;\n        cin>>K;\n        for(int i=0;i<K;++i){\n            int x;\n            cin>>x;\n            if(cnt.count(x)) cnt.erase(x);\n            else cnt.insert(x);\n            cnt.insert(x+1);\n        }\n        for(auto k:cnt){\n            if(k%2) odds.push_back(k);\n            else evens.push_back(k);\n        }\n        n = (int)odds.size();\n        m = (int)evens.size();\n        mapping = vi(m,-1);\n        vist = vb(m,false);\n        E = vector<vb>(n,vb(m, false));\n        prime = vb(N+1,true);\n        prime[0] = prime[1] = false;\n        for(int i=2;i<=N;++i) if(prime[i]){\n            for(int j=2;j*i<=N;++j) prime[i*j] = false;\n        }\n        prime[2] = false;\n        for(int i=0;i<n;++i) for(int j=0;j<m;++j) E[i][j] =prime[abs(odds[i]-evens[j])];\n    }\n    bool arange(int i){\n        for(int j=0;j<m;++j) if(E[i][j]){\n            vist[j] = true;\n            if(mapping[j]==-1 || arange(mapping[j])){\n                mapping[j] = i;\n                return true;\n            }\n        }\n        return false;\n    }\npublic:\n    void solve(){\n        init();\n        int cnt = 0;\n        for(int i=0;i<n;++i) cnt += arange(i);\n        int ans = cnt + ((n-cnt)/2 + (m-cnt)/2)*2 + ((m-cnt)%2)*3;\n        cout<<ans<<endl;\n    }\n};\n\n\n\nint main(){\n    PrimeFlip().solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include<map>\n\ninline int Abs(const int x) { return x >= 0 ? x : -x; }\n\nint n, a[205], b[205], Mat[205], Ans;\nbool G[205][205], Vis[205];\nstd::map<int, int> M;\n\nbool Prime(int x)\n{\n\tif (x < 2)return false;\n\tfor (int i = 2; i * i <= x; ++i)\n\t\tif (x % i == 0)return false;\n\treturn true;\n}\n\nbool DFS(int x)\n{\n\tfor (int y = 1; y <= n; ++y)\n\t\tif (!Vis[y] && G[x][y])\n\t\t\tif (Vis[y] = true, !Mat[y] || DFS(Mat[y]))\n\t\t\t\treturn Mat[y] = x, true;\n\treturn false;\n}\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\tfor (int i = 1, x; i <= n; ++i)scanf(\"%d\", &x), M[x] ^= 1, M[x + 1] ^= 1;\n\tfor (auto i : M)if (i.second)(i.first & 1 ? a[++ * a] : b[++ * b]) = i.first;\n\tfor (int i = 1; i <= *a; ++i)\n\t\tfor (int j = 1; j <= *b; ++j)\n\t\t\tG[i][j] = Prime(Abs(a[i] - b[j]));\n\tfor (int i = 1; i <= *a; ++i)memset(Vis, 0, sizeof Vis), Ans += DFS(i);\n\tprintf(\"%d\\n\", Ans + (*a - Ans) / 2 * 2 + (*b - Ans) / 2 * 2 + (*a - Ans) % 2 * 3);\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <algorithm>\n#include <cstdio>\n#include <cmath>\n#include <set>\n#include <map>\n#include <queue>\n#include <string>\n#include <cstring>\n#include <bitset>\n#include <functional>\n#include <random>\n#define REP(i,a,n) for(int i=a;i<=n;++i)\n#define PER(i,a,n) for(int i=n;i>=a;--i)\n#define hr putchar(10)\n#define pb push_back\n#define lc (o<<1)\n#define rc (lc|1)\n#define mid ((l+r)>>1)\n#define ls lc,l,mid\n#define rs rc,mid+1,r\n#define x first\n#define y second\n#define io std::ios::sync_with_stdio(false)\n#define endl '\\n'\n#define DB(a) ({REP(__i,1,n) cout<<a[__i]<<' ';hr;})\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n\nconst int N = 1e6+10, S = N-2, T = N-1, INF = 0x3f3f3f3f;\nconst int M = 1e7+10;\nint n, f[M];\nstruct edge {\n    int to,w,next;\n    edge(int to=0,int w=0,int next=0):to(to),w(w),next(next){}\n} e[N];\nint head[N], dep[N], vis[N], cur[N], cnt=1;\nqueue<int> Q;\nint bfs() {\n    REP(i,1,n) dep[i]=INF,vis[i]=0,cur[i]=head[i];\n    dep[S]=INF,vis[S]=0,cur[S]=head[S];\n    dep[T]=INF,vis[T]=0,cur[T]=head[T];\n    dep[S]=0,Q.push(S);\n    while (Q.size()) {\n        int u = Q.front(); Q.pop();\n        for (int i=head[u]; i; i=e[i].next) {\n            if (dep[e[i].to]>dep[u]+1&&e[i].w) {\n                dep[e[i].to]=dep[u]+1;\n                Q.push(e[i].to);\n            }\n        }\n    }\n    return dep[T]!=INF;\n}\nint dfs(int x, int w) {\n    if (x==T) return w;\n    int used = 0;\n    for (int i=cur[x]; i; i=e[i].next) {\n        cur[x] = i;\n        if (dep[e[i].to]==dep[x]+1&&e[i].w) {\n            int f = dfs(e[i].to,min(w-used,e[i].w));\n            if (f) used+=f,e[i].w-=f,e[i^1].w+=f;\n            if (used==w) break;\n        }\n    }\n    return used;\n}\nint dinic() {\n    int ans = 0;\n    while (bfs()) ans+=dfs(S,INF);\n    return ans;\n}\nvoid add(int u, int v, int w) {\n    e[++cnt] = edge(v,w,head[u]);\n    head[u] = cnt;\n    e[++cnt] = edge(u,0,head[v]);\n    head[v] = cnt;\n}\n\nint chk(int x) {\n\tif (x<=2) return 0;\n\tint mx = sqrt(x+0.5);\n\tREP(i,2,mx) if (x%i==0) return 0;\n\treturn 1;\n}\nint main() {\n\tscanf(\"%d\", &n);\n\tREP(i,1,n) { \n\t\tint t;\n\t\tscanf(\"%d\", &t);\n\t\tf[t] = 1;\n\t}\n\tvector<pii> A, B;\n\tint now = 0;\n\tREP(i,1,M-1) if (f[i]!=f[i-1]) {\n\t\tif (i&1) A.pb(pii(i,++now)),add(S,now,1);\n\t\telse B.pb(pii(i,++now)),add(now,T,1);\n\t}\n\tfor (auto t:A) for (auto tt:B) { \n\t\tif (chk(abs(t.x-tt.x))) {\n\t\t\tadd(t.y,tt.y,1);\n\t\t}\n\t}\n\tint flow = dinic();\n\tint ans = flow, x = A.size()-flow, y = B.size()-flow;\n\tans += x/2*2, x %= 2;\n\tans += y/2*2, y %= 2;\n\tif (x) ans += 3;\n\tprintf(\"%d\\n\", ans);\n}\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "// warm heart, wagging tail,and a smile just for you!\n//                                                                     ███████████\n//                                                                   ███╬╬╬╬╬╬╬╬╬╬███\n//                                                                ███╬╬╬╬╬████╬╬╬╬╬╬███\n//                                            ███████████       ██╬╬╬╬╬████╬╬████╬╬╬╬╬██\n//                                      █████████╬╬╬╬╬████████████╬╬╬╬╬██╬╬╬╬╬╬███╬╬╬╬╬██\n//                               ████████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████████╬╬╬╬╬╬██╬╬╬╬╬╬╬██\n//                             ████╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████████╬╬╬╬╬╬╬╬╬╬╬██\n//                           ███╬╬╬█╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬███╬╬╬╬╬╬╬█████\n//                         ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬████████╬╬╬╬╬██\n//                       ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬╬╬╬╬╬███\n//                     ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬██\n//                 ████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████╬╬╬╬╬████\n//     █████████████╬╬╬╬╬╬╬╬██╬╬╬╬╬████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬██████\n//   ████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬██████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██████╬╬╬╬╬╬╬███████████╬╬╬╬╬╬╬╬██╬╬╬██╬╬╬██\n// ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████╬╬╬╬╬╬╬╬╬╬╬█╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬██\n// ██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬▓▓▓▓▓▓╬╬╬████╬╬████╬╬╬╬╬╬╬▓▓▓▓▓▓▓▓██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬███\n// ██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██████▓▓▓▓▓▓▓╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬▓▓▓▓▓▓▓██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬█████\n// ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████████\n//   ███╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██\n//       ██████████████  ████╬╬╬╬╬╬███████████████████████████╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████\n//                         ███████                           █████  ███████████████████  \n//\n#include \"bits/stdc++.h\"\nusing namespace std;\n#define INF (1<<30)\n#define LINF (1LL<<60)\n#define fs first\n#define sc second\n#define int long long\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define RFOR(i,a,b) for(int i = (b-1);i>=(a);--i)\n#define REP(i,n)  FOR(i,0,(n))\n#define RREP(i,n) RFOR(i,0,(n))\n#define ITR(itr,mp) for(auto itr = (mp).begin(); itr != (mp).end(); ++itr)\n#define RITR(itr,mp) for(auto itr = (mp).rbegin(); itr != (mp).rend(); ++itr)\n#define range(i,a,b) ((a)<=(i) && (i)<(b))\n#define debug(x)  cout << #x << \" = \" << (x) << endl\n#define SP << \" \" << \ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n#define MSB(x) (63-__builtin_clzll(x))\n#define pcnt(x) (__builtin_popcountll(x))\n#define parity(i,j) (i&(1LL<<j))\ntypedef pair<int,int> P;\ntypedef tuple<int,int,int> T;\ntypedef vector<int> vec;\ntypedef vector<vector<int>> mat;\n\nvector<bool> pri((int)1e7+10,false);\nvoid init(int x){\n  vector<bool> flag(x+1,false);\n  for(int i = 2; i <= x; i++){\n    if(flag[i]) continue;\n    pri[i] = true;\n    for(int j = i; j <= x; j+=i) flag[j] = true;\n  }\n}\n\nstruct max_flow{\n  public:\n  struct edge {int to,cap,rev;};\n  int V;\n  vector<vector<edge>> G;\n  vector<int> level,iter;\n\n  max_flow(int v){\n    V = v; G.resize(v);\n  }\n\n  void add_edge(int from, int to, int cap){\n    G[from].push_back((edge){to,cap,G[to].size()});\n    G[to].push_back((edge){from,0,G[from].size()-1});\n  }\n\n  void bfs(int s){\n    level.assign(V,-1);\n    queue<int> que;\n    level[s] = 0;\n    que.push(s);\n    while(!que.empty()){\n      int v = que.front();\n      que.pop();\n      REP(i,G[v].size()){\n        edge &e = G[v][i];\n        if(e.cap > 0 && level[e.to] < 0){\n          level[e.to] = level[v] + 1;\n          que.push(e.to);\n        }\n      }\n    }\n  }\n\n  int dfs(int v, int t, int f){\n    if(v == t) return f;\n    for(int &i = iter[v]; i < G[v].size(); i++){\n      edge &e = G[v][i];\n      if(e.cap > 0 && level[v] < level[e.to]){\n        int d = dfs(e.to,t,min(f,e.cap));\n        if(d > 0){\n          e.cap -= d;\n          G[e.to][e.rev].cap += d;\n          return d;\n        }\n      }\n    }\n    return 0;\n  }\n\n  int run(int s, int t){\n    int flow = 0;\n    while(1){\n      bfs(s);\n      if(level[t] < 0) return flow;\n      iter.assign(V,0);\n      int tmp;\n      while((tmp = dfs(s,t,INF)) > 0){\n        flow += tmp;\n      }\n    }\n  }\n};\n// INFが大きすぎないか？\n\nsigned main(){\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n\n  int n;\n  cin >> n;\n\n  vector<int> a(n);\n  REP(i,n) cin >> a[i], a[i]--;\n  \n  init((int)1e7+5);\n  pri[2] = false;\n\n  map<int,int> mp;\n  REP(i,n){\n    mp[a[i]] ^= 1;\n    mp[a[i]+1] ^= 1;\n  }\n\n  vec b;\n  ITR(itr,mp) if(itr->sc) b.push_back(itr->fs);\n\n  int m = b.size();\n\n  max_flow mf(m+2);\n  REP(i,m) REP(j,m){\n    if(b[i]%2) continue;\n    if(pri[abs(b[i]-b[j])]) mf.add_edge(i,j,1);\n  }\n\n  int e = 0, o = 0;\n  REP(i,m){\n    if(b[i]%2) mf.add_edge(i,m+1,1), o++;\n    else mf.add_edge(m,i,1), e++;\n  }\n\n  int mx = mf.run(m,m+1);\n  o -= mx; e -= mx;\n  cout << mx + (o/2+e/2)*2 + o%2*3 << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n \nusing namespace std;\nusing namespace __gnu_pbds;\n \n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define fbo find_by_order\n#define ook order_of_key\n \ntypedef long long ll;\ntypedef pair<int,int> ii;\ntypedef vector<int> vi;\ntypedef long double ld; \ntypedef tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> pbds;\ntypedef set<int>::iterator sit;\ntypedef map<int,int>::iterator mit;\ntypedef vector<int>::iterator vit;\n\nconst int MX = 255;\nconst int INF = int(1e9);\n\nstruct MaxFlow //by yutaka1999, have to define INF and MX (the Max number of vertices)\n{\n\tstruct edge\n\t{\n\t\tint to,cap,rev;\n\t\tedge(int to=0,int cap=0,int rev=0):to(to),cap(cap),rev(rev){}\n\t};\n\tvector <edge> vec[MX];\n\tint level[MX];\n\tint iter[MX];\n\t\n\tvoid addedge(int s,int t,int c) //adds an edge of cap c to the flow graph\n\t{\n\t\tint S=vec[s].size(),T=vec[t].size();\n\t\tvec[s].push_back(edge(t,c,T));\n\t\tvec[t].push_back(edge(s,0,S));\n\t}\n\tvoid bfs(int s)\n\t{\n\t\tmemset(level,-1,sizeof(level));\n\t\tqueue <int> que;\n\t\tlevel[s] = 0;\n\t\tque.push(s);\n\t\twhile (!que.empty())\n\t\t{\n\t\t\tint v = que.front();que.pop();\n\t\t\tfor(int i=0;i<vec[v].size();i++)\n\t\t\t{\n\t\t\t\tedge&e=vec[v][i];\n\t\t\t\tif (e.cap>0&&level[e.to]<0)\n\t\t\t\t{\n\t\t\t\t\tlevel[e.to]=level[v]+1;\n\t\t\t\t\tque.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tll flow_dfs(int v,int t,ll f)\n\t{\n\t\tif (v==t) return f;\n\t\tfor(int &i=iter[v];i<vec[v].size();i++)\n\t\t{\n\t\t\tedge &e=vec[v][i];\n\t\t\tif (e.cap>0&&level[v]<level[e.to])\n\t\t\t{\n\t\t\t\tll d=flow_dfs(e.to,t,min(f,ll(e.cap)));\n\t\t\t\tif (d>0)\n\t\t\t\t{\n\t\t\t\t\te.cap-=d;\n\t\t\t\t\tvec[e.to][e.rev].cap+=d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tll maxflow(int s,int t) //finds max flow using dinic from s to t\n\t{\n\t\tll flow = 0;\n\t\twhile(1)\n\t\t{\n\t\t\tbfs(s);\n\t\t\tif (level[t]<0) return flow;\n\t\t\tmemset(iter,0,sizeof(iter));\n\t\t\twhile (1)\n\t\t\t{\n\t\t\t\tll f=flow_dfs(s,t,INF);\n\t\t\t\tif(f==0) break;\n\t\t\t\tflow += f;\n\t\t\t}\n\t\t}\n\t}\n};\n\nstruct NumberTheory\n{\n\tvector<ll> primes;\n\tvector<bool> prime;\n\tvector<ll> totient;\n\tvector<ll> sumdiv;\n\tvector<ll> bigdiv;\n\tvoid Sieve(ll n)\n\t{\n\t\tprime.assign(n+1, 1);\n\t\tprime[1] = false;\n\t\tfor(ll i = 2; i <= n; i++)\n\t\t{\n\t\t\tif(prime[i])\n\t\t\t{\n\t\t\t\tprimes.pb(i);\n\t\t\t\tfor(ll j = i*2; j <= n; j += i)\n\t\t\t\t{\n\t\t\t\t\tprime[j] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tll phi(ll x)\n\t{\n\t\tmap<ll,ll> pf;\n\t\tll num = 1; ll num2 = x;\n\t\tfor(ll i = 0; primes[i]*primes[i] <= x; i++)\n\t\t{\n\t\t\tif(x%primes[i]==0)\n\t\t\t{\n\t\t\t\tnum2/=primes[i];\n\t\t\t\tnum*=(primes[i]-1);\n\t\t\t}\n\t\t\twhile(x%primes[i]==0)\n\t\t\t{\n\t\t\t\tx/=primes[i];\n\t\t\t\tpf[primes[i]]++;\n\t\t\t}\n\t\t}\n\t\tif(x>1)\n\t\t{\n\t\t\tpf[x]++; num2/=x; num*=(x-1);\n\t\t}\n\t\tx = 1;\n\t\tnum*=num2;\n\t\treturn num;\n\t}\n\t\n\tbool isprime(ll x)\n\t{\n\t\tif(x==1) return false;\n\t\tfor(ll i = 0; primes[i]*primes[i] <= x; i++)\n\t\t{\n\t\t\tif(x%primes[i]==0) return false;\n\t\t}\n\t\treturn true;\n\t}\n\n\tvoid SievePhi(ll n)\n\t{\n\t\ttotient.resize(n+1);\n\t\tfor (int i = 1; i <= n; ++i) totient[i] = i;\n\t\tfor (int i = 2; i <= n; ++i)\n\t\t{\n\t\t\tif (totient[i] == i)\n\t\t\t{\n\t\t\t\tfor (int j = i; j <= n; j += i)\n\t\t\t\t{\n\t\t\t\t\ttotient[j] -= totient[j] / i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvoid SieveSumDiv(ll n)\n\t{\n\t\tsumdiv.resize(n+1);\n\t\tfor(int i = 1; i <= n; ++i)\n\t\t{\n\t\t\tfor(int j = i; j <= n; j += i)\n\t\t\t{\n\t\t\t\tsumdiv[j] += i;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tll getPhi(ll n)\n\t{\n\t\treturn totient[n];\n\t}\n\t\n\tll getSumDiv(ll n)\n\t{\n\t\treturn sumdiv[n];\n\t}\n\t\n\tll modpow(ll a, ll b, ll mod)\n\t{\n\t\tll r = 1;\n\t\tif(b < 0) b += mod*100000LL;\n\t\twhile(b)\n\t\t{\n\t\t\tif(b&1) r = (r*a)%mod;\n\t\t\ta = (a*a)%mod;\n\t\t\tb>>=1;\n\t\t}\n\t\treturn r;\n\t}\n\t\n\tll inv(ll a, ll mod)\n\t{\n\t\treturn modpow(a, mod - 2, mod);\n\t}\n\t\n\tll invgeneral(ll a, ll mod)\n\t{\n\t\tll ph = phi(mod);\n\t\tph--;\n\t\treturn modpow(a, ph, mod);\n\t}\n\t\n\tvoid getpf(vector<ii>& pf, ll n)\n\t{\n\t\tfor(ll i = 0; primes[i]*primes[i] <= n; i++)\n\t\t{\n\t\t\tint cnt = 0;\n\t\t\twhile(n%primes[i]==0)\n\t\t\t{\n\t\t\t\tn/=primes[i]; cnt++;\n\t\t\t}\n\t\t\tif(cnt>0) pf.pb(ii(primes[i], cnt));\n\t\t}\n\t\tif(n>1)\n\t\t{\n\t\t\tpf.pb(ii(n, 1));\n\t\t}\n\t}\n\n\t//ll op;\n\tvoid getDiv(vector<ll>& div, vector<ii>& pf, ll n, int i)\n\t{\n\t\t//op++;\n\t\tll x, k;\n\t\tif(i >= pf.size()) return ;\n\t\tx = n;\n\t\tfor(k = 0; k <= pf[i].se; k++)\n\t\t{\n\t\t\tif(i==int(pf.size())-1) div.pb(x);\n\t\t\tgetDiv(div, pf, x, i + 1);\n\t\t\tx *= pf[i].fi;\n\t\t}\n\t}\n};\n\nMaxFlow mf;\nNumberTheory nt;\nset<int> S;\n\nvoid add(int z)\n{\n\tif(S.find(z)==S.end()) S.insert(z);\n\telse S.erase(z);\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tint n; cin>>n;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tint z; cin>>z;\n\t\tadd(z); add(z+1);\n\t}\n\tnt.Sieve(10000011);\n\tvi vec;\n\tfor(auto it=S.begin(); it != S.end(); it++) vec.pb(*it);\n\tnt.prime[2]=0;\n\tint s=MX-2; int e=MX-1;\n\tint o=0;\n\tfor(int i=0;i<vec.size();i++)\n\t{\n\t\tif(vec[i]&1) \n\t\t{\n\t\t\to++; mf.addedge(s,i,1);\n\t\t}\n\t\telse mf.addedge(i,e,1);\n\t\tfor(int j=i+1;j<vec.size();j++)\n\t\t{\n\t\t\tif(nt.prime[abs(vec[i]-vec[j])]) \n\t\t\t{\n\t\t\t\tif(vec[i]&1) mf.addedge(i,j,1);\n\t\t\t\telse mf.addedge(j,i,1);\n\t\t\t}\n\t\t}\t\n\t}\n\tint k=mf.maxflow(s,e);\n\tn=vec.size();\n\tcout<<k+((o-k)&1)*3+((o-k)/2+(n-o-k)/2)*2<<'\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n\n#include <iostream>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <unordered_set>\n#include <queue>\n#include <set>\n#include <algorithm>\n#include <numeric>\n#include <list>\nusing namespace std;\n\nusing QWORD  = uint64_t;\nusing SQWORD = int64_t;\nusing DWORD  = uint32_t;\nusing SDWORD = int32_t;\nusing WORD   = uint16_t;\nusing SWORD  = int16_t;\nusing BYTE   = uint8_t;\nusing SBYTE  = int8_t;\nusing DOUBLE = double;\nusing FLOAT  = float;\n\n#define MIN_SDWORD (-2147483648)\n#define MAX_SDWORD (2147483647)\n#define MIN_SBYTE (-128)\n#define MAX_SBYTE (127)\n\n#define MIN_SQWORD (0x8000000000000000)\n#define MAX_SQWORD (0x7FFFFFFFFFFFFFFF)\n\n#define MAX_QWORD  (0xFFFFFFFFFFFFFFFF)\n#define MAX_DWORD  (0xFFFFFFFF)\n#define MAX_WORD   (0xFFFF)\n#define MAX_BYTE   (0xFF)\n\n#define MAX_DOUBLE      (1.0e+308)\n#define DOUBLE_EPS      (1.0e-12)\n#define MIN_DOUBLE_N    (-1.0e+308)\n\n#define ArrayLength(a)  (sizeof(a) / sizeof(a[0]))\n\nstatic inline DOUBLE MAX(DOUBLE a, DOUBLE b) { return a > b ? a : b; }\nstatic inline QWORD MAX(QWORD a, QWORD b) { return a > b ? a : b; }\nstatic inline DWORD MAX(DWORD a, DWORD b) { return a > b ? a : b; }\nstatic inline SDWORD MAX(SDWORD a, SDWORD b) { return a > b ? a : b; }\nstatic inline DOUBLE MIN(DOUBLE a, DOUBLE b) { return a < b ? a : b; }\nstatic inline QWORD MIN(QWORD a, QWORD b) { return a < b ? a : b; }\nstatic inline DWORD MIN(DWORD a, DWORD b) { return a < b ? a : b; }\nstatic inline SDWORD MIN(SDWORD a, SDWORD b) { return a < b ? a : b; }\nstatic inline DOUBLE ABS(DOUBLE a) { return 0 < a ? a : -a; };\n\n#define BYTE_BITS   (8)\n#define WORD_BITS   (16)\n#define DWORD_BITS  (32)\n#define QWORD_BITS  (64)\n\nstatic inline void inputStringSpSeparated(char *pcStr)\n{\n    char *pcCur = pcStr;\n    for (;;) {\n        char c = getchar();\n        if (('\\n' == c) || (EOF == c) || (' ' == c)) {\n            break;\n        }\n        *pcCur = c;\n        pcCur++;\n    }\n    *pcCur = '\\0';\n}\n\nstatic inline void inputString(char *pcStr)\n{\n    char *pcCur = pcStr;\n    for (;;) {\n        char c = getchar();\n        if (('\\n' == c) || (EOF == c)) {\n            break;\n        }\n        *pcCur = c;\n        pcCur++;\n    }\n    *pcCur = '\\0';\n}\n\n\nstatic inline SQWORD inputSQWORD(void)\n{\n    SQWORD sqNumber = 0;\n    SQWORD sqMultiplier = 1;\n    bool bRead = false;\n    for (;;) {\n        char c = getchar();\n        if (!bRead) {\n            if ('-' == c) {\n                sqMultiplier = -1;\n            }\n        }\n        if (('0' <= c) && (c <= '9')) {\n            sqNumber *= 10LL;\n            sqNumber += (SQWORD)(c - '0');\n            bRead = true;\n        } else {\n            if (bRead) {\n                return sqNumber * sqMultiplier;\n            }\n        }\n    }\n}\n\n\nstatic inline SDWORD inputSDWORD(void)\n{\n    SDWORD lNumber = 0;\n    SDWORD lMultiplier = 1;\n    bool bRead = false;\n    for (;;) {\n        char c = getchar();\n        if (!bRead) {\n            if ('-' == c) {\n                lMultiplier = -1;\n            }\n        }\n        if (('0' <= c) && (c <= '9')) {\n            lNumber *= 10;\n            lNumber += (c - '0');\n            bRead = true;\n        } else {\n            if (bRead) {\n                return lNumber * lMultiplier;\n            }\n        }\n    }\n}\n\nstatic inline DOUBLE inputFP(void)\n{\n    DOUBLE dInt = 0.0;\n    DOUBLE dFrac = 0.0;\n    DOUBLE dMultiplier = 1.0;\n    DWORD dwFpCnt = 0;\n    DOUBLE *pdCur = &dInt;\n    bool bRead = false;\n    for (;;) {\n        char c = getchar();\n        if (!bRead) {\n            if ('-' == c) {\n                dMultiplier = -1;\n            }\n        }\n        if ('.' == c) {\n            pdCur = &dFrac;\n        } else if (('0' <= c) && (c <= '9')) {\n            (*pdCur) *= 10;\n            (*pdCur) += (DOUBLE)(c - '0');\n            bRead = true;\n            if (pdCur == &dFrac) {\n                dwFpCnt++;\n            }\n        } else {\n            if (bRead) {\n                return dMultiplier * (dInt + dFrac / (pow((DOUBLE)10.0 , (DOUBLE)dwFpCnt)));\n            }\n        }\n    }\n}\n\n\n/**\n *  mod による操作ライブラリ\n */\n\n#define ANS_MOD (1000000007LL)\n \nstatic SQWORD addMod(SQWORD x, SQWORD y)\n{ \n    return (x + y) % ANS_MOD;\n}\n \nstatic SQWORD subMod(SQWORD x, SQWORD y)\n{\n    return (x - y + ANS_MOD) % ANS_MOD;\n}\n \nstatic SQWORD mulMod(SQWORD x, SQWORD y) \n{\n    return (x * y) % ANS_MOD;\n}\n \nstatic SQWORD powMod(SQWORD x, SQWORD e) {\n    SQWORD v = 1;\n    for (; e; x = mulMod(x, x), e >>= 1) {\n        if (e & 1) {\n            v = mulMod(v, x);\n        }\n    }\n    return v;\n}\n \nstatic SQWORD divMod(SQWORD x, SQWORD y)\n{\n    return mulMod(x, powMod(y, ANS_MOD - 2));\n}\n \n \nstatic SQWORD combMod(SQWORD n, SQWORD k)\n{\n    SQWORD v=1;\n    for(SQWORD i=1; i<=k; i++) {\n        v = divMod(mulMod(v, n-i+1),i);\n    } \n    return v;\n}\n\n/*----------------------------------------------*/\n\ntypedef struct {\n    SDWORD lTo;\n    SQWORD sqCap;\n    SQWORD sqCost;\n    SDWORD lRev;\n} ST_EDGE;\n\n#define MAX_V   (202)\n\nstruct Flow {\nprivate:\n    vector<ST_EDGE> avGraph[MAX_V];\n    SDWORD  alDims[MAX_V];\n    SQWORD  sqEdgeNum;\n    SQWORD  asqDist[MAX_V];\n    SDWORD  alPrevV[MAX_V];   \n    SDWORD  alPrevEdge[MAX_V];      /*直前の頂点と辺 */\n\n    SDWORD  alDinic_Level[MAX_V];\n    SDWORD  alDinic_Iter[MAX_V];\n\npublic:\n    Flow() {\n        for (auto v: avGraph) {\n            v.clear();\n        }\n        memset(alDims, 0, sizeof(alDims));\n        memset(asqDist, 0, sizeof(asqDist));\n        memset(alPrevV, 0, sizeof(alPrevV)); \n        memset(alPrevEdge, 0, sizeof(alPrevEdge));\n        memset(alDinic_Level, 0, sizeof(alDinic_Level));\n        memset(alDinic_Iter, 0, sizeof(alDinic_Iter));\n    }\n    void addEdge(SDWORD lFrom, SDWORD lTo, SQWORD sqCap, SQWORD sqCost) {\n//        printf(\"%d ----[%lld] ----> %d\\n\", lFrom, sqCap, lTo);\n        \n        alDims[lFrom]++;\n        avGraph[lFrom].push_back((ST_EDGE){lTo, sqCap, sqCost, (SDWORD)(avGraph[lTo].size())});\n        avGraph[lTo].push_back((ST_EDGE){lFrom, 0, -sqCost, (SDWORD)(avGraph[lFrom].size() - 1)});\n    }\n\n    SDWORD minCostFlow(SDWORD lStart, SDWORD lTarget, SQWORD sqFlow)\n    {\n        SQWORD sqRes = 0;\n        SQWORD sqFlowRest = sqFlow;\n        while (0 < sqFlowRest) {\n            /* Bellman-Ford Method */\n            fill(asqDist, asqDist + ArrayLength(asqDist), MAX_SDWORD);\n            asqDist[lStart] = 0;\n            bool bIsUpdate = true;\n            while (bIsUpdate) {\n                bIsUpdate = false;\n                for (SDWORD lV = 0; lV < MAX_V; lV++) {\n                    for (SDWORD lIdx = 0; lIdx < avGraph[lV].size(); lIdx++) {\n                        ST_EDGE &stE = avGraph[lV][lIdx];\n                        if ((asqDist[lV] != MAX_SDWORD)\n                                && (0 < stE.sqCap)\n                                && (asqDist[lV] + stE.sqCost < asqDist[stE.lTo])) {\n                            asqDist[stE.lTo] = asqDist[lV] + stE.sqCost;\n                            alPrevV[stE.lTo] = lV;\n                            alPrevEdge[stE.lTo] = lIdx;\n                            bIsUpdate = true;\n                        }\n                    }\n                }\n            }\n            if (asqDist[lTarget] == MAX_SDWORD) {\n                return -1;\n            }\n\n            SQWORD sqAddFlow = MAX_SQWORD;\n            for (SDWORD lV = lTarget; lV != lStart; lV = alPrevV[lV]) {\n                sqAddFlow = min(sqAddFlow, avGraph[alPrevV[lV]][alPrevEdge[lV]].sqCap);\n            }\n            sqFlowRest -= sqAddFlow;\n            sqRes += sqAddFlow * asqDist[lTarget];      // 後で目的変数は書き換える\n            for (SDWORD lV = lTarget; lV != lStart; lV = alPrevV[lV]) {\n                ST_EDGE &stE = avGraph[alPrevV[lV]][alPrevEdge[lV]];\n                stE.sqCap -= sqAddFlow;\n                avGraph[lV][stE.lRev].sqCap += sqAddFlow;\n            }\n        }\n        return sqRes;\n    }\n\nprivate:\n    SQWORD maxFlowDinicBfs(SDWORD lS)\n    {\n        memset(alDinic_Level, -1, sizeof(alDinic_Level));\n        queue<SDWORD> queSearch;\n        alDinic_Level[lS] = 0;\n        queSearch.push(lS);\n        while (!queSearch.empty()) {\n            SDWORD lV = queSearch.front();\n            queSearch.pop();\n            for (SDWORD lIdx = 0; lIdx < avGraph[lV].size(); lIdx++) {\n                ST_EDGE &stE = avGraph[lV][lIdx];\n                if ((0 < stE.sqCap) && (alDinic_Level[stE.lTo] < 0)) {\n                    alDinic_Level[stE.lTo] = alDinic_Level[lV] + 1;\n                    queSearch.push(stE.lTo);\n                }\n            }\n        }\n\n        return 0;\n    }\n\n    SQWORD maxFlowDinicDfs(SDWORD lV, SDWORD lT, SQWORD sqF)\n    {\n        if (lV == lT) {\n            return sqF;\n        }\n        for (SDWORD &lI = alDinic_Iter[lV]; lI < avGraph[lV].size(); lI++) {\n            ST_EDGE &stE = avGraph[lV][lI];\n            if ((0 < stE.sqCap) && (alDinic_Level[lV] < alDinic_Level[stE.lTo])) {\n                SQWORD sqDiffFlow = maxFlowDinicDfs(stE.lTo, lT, min(sqF, stE.sqCap));\n                if (0 < sqDiffFlow) {\n                    stE.sqCap -= sqDiffFlow;\n                    avGraph[stE.lTo][stE.lRev].sqCap += sqDiffFlow;\n                    return sqDiffFlow;\n                }\n            }\n        }\n        return 0;\n    }\n\npublic:\n    SQWORD MaxFlow(SDWORD lStart, SDWORD lTarget)\n    {\n        SQWORD sqFlow = 0LL;\n        for (;;) {\n            maxFlowDinicBfs(lStart);\n            if (alDinic_Level[lTarget] < 0) {\n                return sqFlow;\n            }\n            memset(alDinic_Iter, 0, sizeof(alDinic_Iter));\n            while (1) {\n                SQWORD sqDiffFlow = maxFlowDinicDfs(lStart, lTarget, MAX_SQWORD);\n                sqFlow += sqDiffFlow;\n                if (0LL == sqDiffFlow) {\n                    break;\n                }\n            }\n        }\n    }\n\n    SQWORD getFlow(SDWORD lPnt)\n    {\n        SQWORD sqCapSum = 0; \n        for (auto e: avGraph[lPnt]) {\n            sqCapSum += e.sqCap;\n        }\n        return alDims[lPnt] - sqCapSum;\n    }\n};\n\n/*----------------------------------------------*/\n\nstatic void getPrimes(vector<SDWORD> &vlPrimes, SDWORD lMax)\n{\n    /* lSearchMax と ループ内の *2 の関係から、入力は3以上とすること */\n    if (!(1 <= lMax)) {\n        printf(\"Oops!\");\n        return;\n    }\n\n    /* 素数のリストを作る */\n    vector<bool> vbIsPrime(lMax + 1, true);\n    SDWORD lSearchMax = sqrt(lMax) + 1;\n    vbIsPrime[0] = false;\n    vbIsPrime[1] = false;\n    for (SDWORD lPrime = 2; lPrime < vbIsPrime.size(); lPrime++) {\n        if (vbIsPrime[lPrime]) {\n            vlPrimes.emplace_back(lPrime);\n            if (lPrime <= lSearchMax) {\n                for (SDWORD lCurNum = lPrime * 2; lCurNum <= lMax; lCurNum += lPrime) {\n                    vbIsPrime[lCurNum] = false;\n                }\n            }\n        }\n    }\n}    \n\n/*----------------------------------------------*/\n\n#define PNT_NO_START    (0)\n#define PNT_NO_OFFSET   (100)\n#define PNT_NO_TARGET   (201)\n#define FLOW_OFFSET     (1000000000)\n#define CAPACITY_INF    (1000000001)\n#define DUMMY_COST      (1)\n\nint main(void)\n{\n    SQWORD sqN = inputSQWORD();\n\n    Flow solverFlow;\n    vector<SQWORD> vsqA;\n    vector<SQWORD> vsqB;\n    vector<SDWORD> vlPrimes;\n\n    getPrimes(vlPrimes, 1e7 + 1);\n    vlPrimes.erase(find(vlPrimes.begin(), vlPrimes.end(), 2));\n\n    for (SQWORD sqIdx = 0; sqIdx < sqN; sqIdx++) {\n        SQWORD sqA = inputSQWORD();\n        vsqA.emplace_back(sqA);\n    }\n\n#if 1\n    for (SQWORD sqIdx = 0; sqIdx < sqN; sqIdx++) {\n        if (0 == sqIdx) {\n            vsqB.emplace_back(vsqA[sqIdx]);      \n        } else {\n            if (vsqA[sqIdx - 1] != (vsqA[sqIdx] - 1)) {\n                vsqB.emplace_back(vsqA[sqIdx]);\n            }\n        }\n        if (sqN - 1 == sqIdx) {\n            vsqB.emplace_back(vsqA[sqIdx] + 1);           \n        } else {\n            if ((vsqA[sqIdx] + 1) != vsqA[sqIdx + 1]) {\n                vsqB.emplace_back(vsqA[sqIdx] + 1);\n            }\n        }\n    }\n#else\n    vsqB = vsqA;\n#endif\n\n    vector<SQWORD> vsqCOdd;\n    vector<SQWORD> vsqCEven;\n    \n    map<SQWORD, SQWORD> mapCEven, mapCOdd;\n\n    SQWORD sqIdx = 1;\n    for (auto b: vsqB) {\n        if (0 == b % 2) {\n            vsqCEven.emplace_back(b);\n            mapCEven[b] = sqIdx;\n        } else {\n            vsqCOdd.emplace_back(b);\n            mapCOdd[b] = sqIdx;\n        }\n        sqIdx++;\n    }\n\n    /* 二部マッチング */\n    for (auto c: vsqCEven) {\n        solverFlow.addEdge(PNT_NO_START, mapCEven[c], 1, DUMMY_COST);\n    }\n    for (auto c: vsqCEven) {\n        solverFlow.addEdge(mapCOdd[c] + PNT_NO_OFFSET, PNT_NO_TARGET, 1, DUMMY_COST);\n    }\n\n    for (auto p: vlPrimes) {\n        for (auto c: vsqCEven) {\n            auto it = lower_bound(vsqCOdd.begin(), vsqCOdd.end(), c + p);\n            if (it != vsqCOdd.end()) {\n                if (*it == c + p) {\n                    if (c + p < 1e7 + 1) {\n                        solverFlow.addEdge(mapCEven[c], mapCOdd[c + p] + PNT_NO_OFFSET, 1, DUMMY_COST);\n                    }\n                }\n            }\n        }\n    }\n\n    SQWORD sqMaxFlow = solverFlow.MaxFlow(PNT_NO_START, PNT_NO_TARGET);\n    SQWORD vsqCRestEven = 0;\n    SQWORD vsqCRestOdd = 0;\n    for (auto c: vsqCEven) {\n        SQWORD sqFlow = solverFlow.getFlow(mapCEven[c]);\n        if (0 == sqFlow) {\n            vsqCRestEven++;\n        }\n    }\n    for (auto c: vsqCOdd) {\n        SQWORD sqFlow = solverFlow.getFlow(mapCOdd[c]);\n        if (0 == sqFlow) {\n            vsqCRestOdd++;\n        }\n    }\n\n    SQWORD sqAns = sqMaxFlow;    \n    sqAns += (vsqCRestEven / 2) * 2;\n    sqAns += (vsqCRestOdd / 2) * 2;\n    if (0 < (vsqCRestEven %  2)) {\n        sqAns += 3;\n    }\n\n    printf(\"%lld\\n\", sqAns);\n\n    return 0;\n}\n/*------------------------------------------*/\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(2)\n#include<bits/stdc++.h>\n#define ll long long\n#define maxn 1000005\n#define N 10000005\n#define inf 1e9\n#define pb push_back\n#define rep(i,a,b) for(int i=a;i<=b;i++)\n#define per(i,a,b) for(int i=a;i>=b;i--)\nusing namespace std;\n\ninline int read()\n{\n\tint x=0,w=1; char c=getchar();\n\twhile(c<'0'||c>'9') {if(c=='-') w=-1; c=getchar();}\n\twhile(c<='9'&&c>='0') {x=(x<<1)+(x<<3)+c-'0'; c=getchar();}\n\treturn w==1?x:-x;\n}\n\nbool x[N],is[N];\nint l[maxn],r[maxn],c[maxn],cr,cl,cnt,pri[maxn];\n\nstruct node{int from,to,cap,flow,cost;};\nvector <node> edges;\nvector <int> mp[maxn];\nint s,t,n,m,d[maxn],flow,cost,p[maxn],a[maxn];\nbool inq[maxn];\nqueue <int> que;\n\ninline void A(int u,int v,int w,int c)\n{\n\tedges.push_back((node){u,v,w,0,c});\n\tedges.push_back((node){v,u,0,0,-c});\n\tint pp=edges.size();\n\tmp[u].push_back(pp-2);\n\tmp[v].push_back(pp-1);\n}\n\ninline bool spfa()\n{\n\tfor(int i=0;i<=t;i++) d[i]=inf,inq[i]=0,a[i]=inf;\n\tque.push(s); d[s]=0;\n\twhile(!que.empty())\n\t{\n\t\tint u=que.front(); que.pop(); inq[u]=0;\n\t\tfor(int i=0;i<mp[u].size();i++)\n\t\t{\n\t\t\tnode &v=edges[mp[u][i]];\n\t\t\tif(v.cap-v.flow>0&&d[v.to]>d[u]+v.cost)\n\t\t\t{\n\t\t\t\td[v.to]=d[u]+v.cost;\n\t\t\t\ta[v.to]=min(a[u],v.cap-v.flow);\n\t\t\t\tp[v.to]=mp[u][i];\n\t\t\t\tif(inq[v.to]==0) que.push(v.to),inq[v.to]=1;\n\t\t\t}\n\t\t}\n\t}\n\tif(d[t]==inf) return false;\n\tflow+=a[t];\n\tcost+=a[t]*d[t];\n\tfor(int i=t;i!=s;i=edges[p[i]].from)\n\t{\n\t\tedges[p[i]].flow+=a[t];\n\t\tedges[p[i]^1].flow-=a[t];\n\t}\n\treturn true;\n}\n\ninline void pre()\n{\n\tfor(int i=2;i<=(N-4);i++)\n\t{\n\t\tif(!is[i]) pri[++cnt]=i;\n\t\tfor(int j=1;j<=cnt,pri[j]*i<=(N-5);j++)\n\t\t{\n\t\t\tis[pri[j]*i]=1;\n\t\t\tif(i%pri[j]==0) break;\n\t\t}\n\t}\n}\n\nint main()\n{\n\tn=read(); pre(); rep(i,1,n) c[i]=read(),x[c[i]]=1;\n\trep(i,1,(N-4))\n\t{\n\t\tif(x[i]!=x[i-1])\n\t\t{\n\t\t\tif(x[i]==0) r[++cr]=i-1;\n\t\t\telse l[++cl]=i;\n\t\t}\n\t}\n\t//rep(i,1,cl) cout<<l[i]<<\" \"; puts(\"\");\n\t//rep(i,1,cr) cout<<r[i]<<\" \"; puts(\"\");\n\ts=0; t=2*cl+1;\n\trep(i,1,cl) A(s,i,1,0); rep(i,1,cr) A(i+cl,t,1,0);\n\trep(i,1,cl) rep(j,1,cr)\n\t{\n\t\tint p=l[i]-1,p2=r[j]; if(p<p2) swap(p,p2);\n\t\tint len=p-p2;\n\t\tif(len==0) A(i,j+cl,1,-3);\n\t\telse if(len%2==0) A(i,j+cl,1,-2);\n\t\telse if(len==1) A(i,j+cl,1,-3);\n\t\telse if(!is[len]) A(i,j+cl,1,-1);\n\t\telse A(i,j+cl,1,-3);\n\t}\n\twhile(spfa()); cout<<-cost<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define N 205\n#define M 10000007\n#define INF 0x3f3f3f3f\nint n;\nint pos[N],pcnt;\nint dp[N][N];\nbool p[M];\nint main(){\n    scanf(\"%d\",&n);\n    for(int i=1,t;i<=n;i++){\n        scanf(\"%d\",&t);\n        if(pcnt>0&&pos[pcnt]==t) pos[pcnt]=t+1;\n        else pos[++pcnt]=t,pos[++pcnt]=t+1;\n    }\n    for(int i=2;i<M;i++){\n        p[i]=!p[i];\n        if(p[i])\n           for(int j=i+i;j<M;j+=i) p[j]=true;\n    }\n    for(int i=pcnt;i>=1;i--){\n        for(int j=i+1,d;j<=pcnt;j+=2){\n            dp[i][j]=INF;\n            for(int k=i+1;k<=j;k+=2)\n                dp[i][j]=min(dp[i][j],dp[i+1][k-1]+dp[k+1][j]+ ((pos[k]-pos[i])%2==0 ? 2:(p[pos[k]-pos[i]] ? 1:3)) );\n        }\n    }\n    cout<<dp[1][pcnt]<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#define repu(i,x,y) for (int i=x; i<=y; ++i)\nusing namespace std;\n\nint tot,n,m,a[210],b[210],prm[10010],map[210][210],link[210],ans;\nbool flag[10010];\n\nvoid insert(int x)\n{\n    (x&1?a[++n]:b[++m])=x;\n}\n\nbool check(int x)\n{\n    if (x<=2)\n        return 0;\n    for (int i=1; prm[i]*prm[i]<=x; ++i)\n        if (!(x%prm[i]))\n            return 0;\n    return 1;\n}\n\nbool hungary(int x)\n{\n    repu(i,1,map[x][0])\n        if (!flag[map[x][i]])\n        {\n            flag[map[x][i]]=1;\n            if (!link[map[x][i]] || hungary(link[map[x][i]]))\n            {\n                link[map[x][i]]=i;\n                return 1;\n            }\n        }\n    return 0;\n}\n\nint main()\n{\n    scanf(\"%d\",&tot);\n    repu(i,1,tot)\n        scanf(\"%d\",&a[i]);\n    for (int i=1,j; i<=tot; i=j+1)\n    {\n        for (j=i; j<tot && a[j+1]==a[j]+1; ++j);\n        insert(a[i]),insert(a[j]+1);\n    }\n    tot=0;\n    repu(i,2,1e4)\n        if (!flag[i])\n        {\n            prm[++tot]=i;\n            for (int j=i*2; j<=1e4; flag[j]=1,j+=i);\n        }\n    repu(i,1,n)\n        repu(j,1,m)\n            if (check(abs(a[i]-b[j])))\n                map[i][++map[i][0]]=j;\n    repu(i,1,n)\n    {\n        memset(flag,0,sizeof(int)*(m+10));\n        ans+=hungary(i);\n    }\n    printf(\"%d\\n\",n+m-ans+((n-ans)&1));\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define rep(i, a, b) for(int i = a; i < (b); ++i)\n#define trav(a, x) for(auto& a : x)\n#define all(x) begin(x), end(x)\n#define sz(x) (int)(x).size()\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\nbool dfs(int a, int L, vector<vi>& g, vi& btoa, vi& A, vi& B) {\n\tif (A[a] != L) return 0;\n\tA[a] = -1;\n\ttrav(b, g[a]) if (B[b] == L + 1) {\n\t\tB[b] = 0;\n\t\tif (btoa[b] == -1 || dfs(btoa[b], L + 1, g, btoa, A, B))\n\t\t\treturn btoa[b] = a, 1;\n\t}\n\treturn 0;\n}\n\nint hopcroftKarp(vector<vi>& g, vi& btoa) {\n\tint res = 0;\n\tvi A(g.size()), B(btoa.size()), cur, next;\n\tfor (;;) {\n\t\tfill(all(A), 0);\n\t\tfill(all(B), 0);\n\t\t/// Find the starting nodes for BFS (i.e. layer 0).\n\t\tcur.clear();\n\t\ttrav(a, btoa) if(a != -1) A[a] = -1;\n\t\trep(a,0,sz(g)) if(A[a] == 0) cur.push_back(a);\n\t\t/// Find all layers using bfs.\n\t\tfor (int lay = 1;; lay++) {\n\t\t\tbool islast = 0;\n\t\t\tnext.clear();\n\t\t\ttrav(a, cur) trav(b, g[a]) {\n\t\t\t\tif (btoa[b] == -1) {\n\t\t\t\t\tB[b] = lay;\n\t\t\t\t\tislast = 1;\n\t\t\t\t}\n\t\t\t\telse if (btoa[b] != a && !B[b]) {\n\t\t\t\t\tB[b] = lay;\n\t\t\t\t\tnext.push_back(btoa[b]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (islast) break;\n\t\t\tif (next.empty()) return res;\n\t\t\ttrav(a, next) A[a] = lay;\n\t\t\tcur.swap(next);\n\t\t}\n\t\t/// Use DFS to scan for augmenting paths.\n\t\trep(a,0,sz(g))\n\t\t\tres += dfs(a, 0, g, btoa, A, B);\n\t}\n}\n\nconst int V = 1.1e7;\nbool isPrime[V + 1];\n\nint main() {\n\tios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\tfor (int i = 2; i <= V; i++) isPrime[i] = true;\n\tfor (int p = 2; p <= V; p++) {\n\t\tif (!isPrime[p]) continue;\n\t\tfor (int j = p+p; j <= V; j += p) isPrime[j] = false;\n\t}\n\n\tint N; cin >> N;\n\tvector<int> X(N);\n\tmap<int, int> evtCnt;\n\tfor (int i = 0; i < N; i++) {\n\t\tcin >> X[i];\n\t\tevtCnt[X[i]] ^= 1;\n\t\tevtCnt[X[i]+1] ^= 1;\n\t}\n\tvector<int> left;\n\tvector<int> right;\n\tfor (auto it : evtCnt) {\n\t\tif (it.second == 0) continue;\n\t\tif (it.first & 1) right.push_back(it.first);\n\t\telse left.push_back(it.first);\n\t}\n\n\tint A = int(left.size());\n\tint B = int(right.size());\n\tvector<vector<int>> g(A);\n\tvector<int> btoa(B, -1);\n\tisPrime[2] = false;\n\tfor (int i = 0; i < A; i++) {\n\t\tfor (int j = 0; j < B; j++) {\n\t\t\tif (isPrime[abs(left[i] - right[j])]) {\n\t\t\t\tg[i].push_back(j);\n\t\t\t}\n\t\t}\n\t}\n\n\tint ans = hopcroftKarp(g, btoa); // number that can be paired\n\tA -= ans, B -= ans;\n\tcout << ans + (A/2) + (B/2) + (A % 2 ? 3 : 0) << '\\n';\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cstdlib>\nusing namespace std;\n\n#define re_ return\n#define in_ inline\n#define op_ operator\n#define inc(l, i, r) for(i=l; i<r; ++i)\n#define st_ static\ntypedef long long ll;\n\nconst int mxn=1<<9;\n\nint n, m, a[mxn], b[mxn<<1], cnt[2], h[mxn<<1];\nstruct edge{int v, o;} e[1<<20];\n\nin_ ll dP(ll a, ll b, ll p)\n{\n    st_ ll r;\n    for(r=1; b; a=a*a%p, b>>=1)\n        b&1? r=r*a%p: 0;\n    re_ r;\n}\n\nin_ char chk(ll a, ll p)\n{\n    st_ ll s, r, i;\n    for(r=p-1, s=0; ~r&1; ++s, r/=2);\n    if(i=dP(a, r, p), i==1 || i==p-1) re_ 1;\n    for(;s--;)\n        if((i=i*i%p)==p-1) re_ 1;\n    re_ 0;\n}\n\nin_ char isP(int p)\n{\n    if(p==2) re_ 1;\n    if(p==1 || ~p&1) re_ 0;\n    st_  int i;\n    inc(0, i, 48)\n        if(!chk(rand()%(p-2)+1, p))\n            re_ 0;\n\n//    for(i=2; i*i<=p; ++i)\n//        if(p%i==0)\n//            re_ 0;\n    re_ 1;\n}\n\nin_ void aE(int u, int v)\n{\n    st_ int tot;\n    e[++tot]=(edge){v, h[u]}, u[h]=tot;\n}\n\nchar vis[mxn<<1];\nchar Hun(int u)\n{\n    st_ int f[mxn<<1];\n    int i, v;\n    for(i=u[h]; v=i[e].v; i=i[e].o)\n        if(!vis[v])\n            if(vis[v]=1, !f[v] || Hun(f[v]))\n            re_ f[v]=u, 1;\n    re_ 0;\n}\n\nint main()\n{\n    srand(998244353);\n    int i, j;\n    scanf(\"%d\", &n);\n    inc(0, i, n)\n        scanf(\"%d\", a+i);\n    sort(a, a+n);\n    inc(0, i, n)\n    {\n        if(!i || a[i]>a[i-1]+1)\n            b[++m]=a[i], ++cnt[a[i]&1];\n        if(i>n-2 || a[i]<a[i+1]-1)\n            b[++m]=a[i]+1, ++cnt[a[i]+1&1];\n    }\n    inc(1, i, m+1)\n        if(b[i]&1)\n            inc(1, j, m+1)\n                if(~b[j]&1 && isP(abs(b[i]-b[j])))\n                    aE(i, j);\n\n    j=0;\n    inc(1, i, m+1)\n        if(b[i]&1)\n            memset(vis, 0, sizeof(vis)),\n                j+=Hun(i);\n\n    printf(\"%d\\n\", cnt[0]+cnt[1]-j+(cnt[0]-j&1));\n//    printf(\"%d\\n\", m);\n//    for(;;) scanf(\"%d\", &i), printf(\"%d\\n\", isP(i));\n    0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int, int> pii;\n\n#define FOR(i, a, b) for (int i=a; i<b; i++)\n#define F0R(i, a) for (int i=0; i<a; i++)\n#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\n \n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n\nconst int MOD = 1000000007;\ndouble PI = 4*atan(1);\n\nint N, pre[202], visit[202];\nvi x, y[2];\nset<int> adj[202];\n\nbool oddprime(int x) {\n    x = abs(x);\n    if (x <= 2) return 0;\n    for (int i = 2; i*i <= x; ++i) if (x % i == 0) return 0;\n    return 1;\n}\n\nint calc(int flow) {\n    return flow+2*((y[0].size()-flow)/2+(y[1].size()-flow)/2)+3*((y[0].size()-flow)%2);    \n}\n\nvoid dfs(int x) {\n    visit[x] = 1;\n    for (int i: adj[x]) if (!visit[i]) {\n        if (visit[201]) break;\n        pre[i] = x;\n        dfs(i);\n    }\n}\n\nvoid backtrack(int x) {\n    if (x == 0) return;\n    int x1 = pre[x];\n    adj[x1].erase(x);\n    adj[x].insert(x1);\n    backtrack(x1);\n}\n\nint main() {\n    cin >> N; x.resize(N); \n    F0R(i,N) cin >> x[i];\n    F0R(i,N) {\n        if (i == 0 || x[i-1]+1 != x[i]) y[(x[i]-1)%2].pb(x[i]-1);\n        if (i == N-1 || x[i]+1 != x[i+1]) y[x[i]%2].pb(x[i]);\n    }\n    \n    F0R(i,y[0].size()) adj[0].insert(i+1);\n    F0R(i,y[1].size()) adj[i+y[0].size()+1].insert(201);\n    F0R(i,y[0].size()) F0R(j,y[1].size()) \n        if (oddprime(y[0][i]-y[1][j])) adj[i+1].insert(j+1+y[0].size());\n        \n    int flow = 0;\n    while (1) {\n        memset(visit,0,sizeof visit);\n        dfs(0);\n        if (!visit[201]) {\n            cout << calc(flow);\n            return 0;\n        }\n        flow++;\n        backtrack(201);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint N,M;\nconst int MAX_N = 111;\nint a[MAX_N],b[MAX_N*2],sz;\nvector<int> odd,even;\n\nvector<int> path[MAX_N*2];\nbool visit[MAX_N*2];\nint match[MAX_N*2];\n\nbool dfs(int x){\n\tif(visit[x])return false;\n\tvisit[x]=1;\n\tfor(int i=0;i<path[x].size();i++){\n\t\tint y=path[x][i];\n\t\tif(match[y]<0){\n\t\t\tmatch[y]=x;\n\t\t\treturn true;\n\t\t}else if(dfs(match[y])){\n\t\t\tmatch[y]=x;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nbool isPrime(int x){\n\tif(x==1)return false;\n\tif(x%2==0)return false; // 2 is exception\n\tfor(int i=3;i*i<=x;i+=2){\n\t\tif(x%i==0)return false;\n\t}\n\treturn true;\n}\n\nint main(){\n\tscanf(\"%d\",&N);\n\tfor(int i=0;i<N;i++){\n\t\tscanf(\"%d\",&a[i]);\n\t}\n\n\tb[sz++]=a[0];\n\tfor(int i=1;i<N;i++){\n\t\tif(a[i-1]+1<a[i]){\n\t\t\tb[sz++]=a[i-1]+1;\n\t\t\tb[sz++]=a[i];\n\t\t}\n\t}\n\tb[sz++]=a[N-1]+1;\n\n\tfor(int i=0;i<sz;i++){\n\t\tif(b[i]%2==0)even.push_back(b[i]);\n\t\telse odd.push_back(b[i]);\n\t}\n\n\tfor(int i=0;i<even.size();i++){\n\t\tfor(int j=0;j<odd.size();j++){\n\t\t\tif(isPrime(abs(even[i]-odd[j]))){\n\t\t\t\tpath[i].push_back(j);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int i=0;i<odd.size();i++){\n\t\tmatch[i]=-1;\n\t}\n\t\n\tint cnt=0;\n\tfor(int i=0;i<even.size();i++){\n\t\tfor(int j=0;j<even.size();j++)visit[j]=0;\n\t\tif(dfs(i))cnt++;\n\t}\n\n\tint z0=even.size()-cnt;\n\tint z1=odd.size()-cnt;\n\tprintf(\"%d\\n\",cnt+(z0/2+z1/2)*2+(z0%2)*3);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\nint A, B, p[200], q[200], N, a[100], m[10000001], pr[664580], v;\ninline void insert(int x)\n{\n\t(x & 1 ? p[++A] : q[++B]) = x;\n}\ntemplate < int xn, int xe > struct flow\n{\n\tint head[xn], next[xe], to[xe], fl[xe], N, E, cur[xn], dep[xn], q[xn + 1];\n\tinline void add(int u, int v, int f)\n\t{\n\t\tnext[E] = head[u], to[E] = v, fl[E] = f, head[u] = E++;\n\t\tnext[E] = head[v], to[E] = u, fl[E] = 0, head[v] = E++;\n\t}\n\tvoid clear(int n)\n\t{\n\t\tN = n, E = 0;\n\t\tfor (int i = 0; i < N; i++)\n\t\t\thead[i] = -1;\n\t}\n\tbool BFS()\n\t{\n\t\tfor (int i = 0; i < N; i++)\n\t\t{\n\t\t\tdep[i] = 0;\n\t\t\tcur[i] = head[i];\n\t\t}\n\t\tint H = 0, T = 1, u;\n\t\tdep[0] = 1;\n\t\tq[1] = 0;\n\t\twhile (H < T)\n\t\t\tfor (int e = head[u = q[++H]]; ~e; e = next[e])\n\t\t\t\tif (fl[e] && !dep[to[e]])\n\t\t\t\t{\n\t\t\t\t\tdep[q[++T] = to[e]] = dep[u] + 1;\n\t\t\t\t\tif (to[e] == N - 1)\n\t\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\treturn false;\n\t}\n\tint DFS(int p, int f)\n\t{\n\t\tif (p == N - 1)\n\t\t\treturn f;\n\t\tint u = 0, y;\n\t\tfor (int &e = cur[p]; ~e; e = next[e])\n\t\t\tif (fl[e] && dep[to[e]] == dep[p] + 1 && (y = DFS(to[e], std::min(f, fl[e]))))\n\t\t\t{\n\t\t\t\tfl[e] -= y;\n\t\t\t\tfl[e ^ 1] += y;\n\t\t\t\tu += y;\n\t\t\t\tf -= y;\n\t\t\t\tif (!f)\n\t\t\t\t\treturn u;\n\t\t\t}\n\t\tif (!u)\n\t\t\tdep[p] = 0;\n\t\treturn u;\n\t}\n\tint operator () ()\n\t{\n\t\tint r = 0;\n\t\twhile (BFS())\n\t\t\tr += DFS(0, 1000000000);\n\t\treturn r;\n\t}\n};\nflow < 202, 100000 > G;\ninline bool is_prime(int x)\n{\n\treturn m[x] == x;\n}\nint main()\n{\n\tfor (int i = 2; i <= 10000000; i++)\n\t{\n\t\tif (!m[i])\n\t\t\tm[i] = pr[++v] = i;\n\t\tfor (int j = 1; j <= v && pr[j] <= m[i] && pr[j] * i <= 10000000; j++)\n\t\t\tm[pr[j] * i] = pr[j];\n\t}\n\tscanf(\"%d\", &N);\n\tfor (int i = 0; i < N; i++)\n\t\tscanf(\"%d\", a + i);\n\tfor (int i = 0, j; i < N; i = j)\n\t{\n\t\tj = i + 1;\n\t\twhile (j < N && a[j] == a[j - 1] + 1)\n\t\t\tj++;\n\t\tinsert(a[i]);\n\t\tinsert(a[i] + j - i);\n\t}\n\tG.clear(A + B + 2);\n\tfor (int i = 1; i <= A; i++)\n\t\tG.add(0, i, 1);\n\tfor (int i = 1; i <= B; i++)\n\t\tG.add(A + i, G.N - 1, 1);\n\tfor (int i = 1; i <= A; i++)\n\t\tfor (int j = 1; j <= B; j++)\n\t\t\tif (is_prime(p[i] < q[j] ? q[j] - p[i] : p[i] - q[j]))\n\t\t\t\tG.add(i, A + j, 1);\n\tprintf(\"%d\\n\", A + B - (G() - (A & 1) >> 1 << 1) - (A & 1));\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nconst int N=210;\nint bel[N],a[N],b[N],n;\nbool G[N][N],vis[N];\nstd::map<int,int> M;\n \nbool isprime(int n) {\n\tif(n==1) return 0;\n\tfor(int i=2;i*i<=n;i++)\n\t\tif(n%i==0) return 0;\n\treturn 1;\n}\n \nbool DFS(int i) {\n\tfor(int j=1;j<=n;j++)\n\t\tif(!vis[j]&&G[i][j]) {\n\t\t\tvis[j]=1;\n\t\t\tif(!bel[j]||DFS(bel[j])) { bel[j]=i;return 1; }\n\t\t}\n\treturn 0;\n}\n \nint main() {\n\tstd::cin>>n;\n\tfor(int i=1,x;i<=n;i++) std::cin>>x,M[x]^=1,M[x+1]^=1;\n\tfor(auto x:M)\n\t\tif(x.second) (x.first&1?a[++*a]:b[++*b])=x.first;\n\tint ans=0;\n\tfor(int i=1;i<=*a;i++)\n\t\tfor(int j=1;j<=*b;j++)\n\t\t\tif(isprime(std::abs(a[i]-b[j]))) G[i][j]=1;\n\tfor(int i=1;i<=*a;i++) {\n\t\tmemset(vis,0,sizeof(vis));\n\t\tans+=DFS(i);\n\t}\n\tstd::cout<<ans+(*a-ans)/2*2+(*b-ans)/2*2+(*a-ans)%2*3<<std::endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cstdlib>\nusing namespace std;\n\n#define re_ return\n#define in_ inline\n#define op_ operator\n#define inc(l, i, r) for(i=l; i<r; ++i)\n#define st_ static\ntypedef long long ll;\n\nconst int mxn=1<<9;\n\nint n, m, a[mxn], b[mxn<<1], cnt[2], h[mxn<<1];\nstruct edge{int v, o;} e[mxn<<2];\n\nin_ ll dP(ll a, ll b, ll p)\n{\n    st_ ll r;\n    for(r=1; b; a=a*a%p, b>>=1)\n        b&1? r=r*a%p: 0;\n    re_ r;\n}\n\nin_ char chk(ll a, ll p)\n{\n    st_ ll s, r, i;\n    for(r=p-1, s=0; ~r&1; ++s, r/=2);\n    if(i=dP(a, r, p), i==1 || i==p-1) re_ 1;\n    for(;s--;)\n        if((i=i*i%p)==p-1) re_ 1;\n    re_ 0;\n}\n\nin_ char isP(int p)\n{\n    if(p==2) re_ 1;\n    if(p==1 || ~p&1) re_ 0;\n    st_  int i;\n//    inc(0, i, 48)\n//        if(!chk(rand()%(p-2)+1, p))\n//            re_ 0;\n\n    for(i=2; i*i<=p; ++i)\n        if(p%i==0)\n            re_ 0;\n    re_ 1;\n}\n\nin_ void aE(int u, int v)\n{\n    st_ int tot;\n    e[++tot]=(edge){v, h[u]}, u[h]=tot;\n}\n\nchar vis[mxn<<1];\nchar Hun(int u)\n{\n    st_ int f[mxn<<1];\n    int i, v;\n    for(i=u[h]; v=i[e].v; i=i[e].o)\n        if(!vis[v])\n            if(vis[v]=1, !f[v] || Hun(f[v]))\n            re_ f[v]=u, 1;\n    re_ 0;\n}\n\nint main()\n{\n    srand(998244353);\n    int i, j;\n    scanf(\"%d\", &n);\n    inc(0, i, n)\n        scanf(\"%d\", a+i);\n    sort(a, a+n);\n    inc(0, i, n)\n    {\n        if(!i || a[i]>a[i-1]+1)\n            b[++m]=a[i], ++cnt[a[i]&1];\n        if(i>n-2 || a[i]<a[i+1]-1)\n            b[++m]=a[i]+1, ++cnt[a[i]+1&1];\n    }\n    inc(1, i, m+1)\n        if(b[i]&1)\n            inc(1, j, m+1)\n                if(~b[j]&1 && isP(abs(b[i]-b[j])))\n                    aE(i, j);\n\n    j=0;\n    inc(1, i, m+1)\n        if(b[i]&1)\n            memset(vis, 0, sizeof(vis)),\n                j+=Hun(i);\n\n    printf(\"%d\\n\", cnt[0]+cnt[1]-j+(cnt[0]-j&1));\n//    printf(\"%d\\n\", m);\n//    for(;;) scanf(\"%d\", &i), printf(\"%d\\n\", isP(i));\n    0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define pb push_back\nconst int maxn=210;\nint n,k,pri[10000010],linker[maxn],a[maxn],b[maxn];\nbool mark[10000010],vis[maxn];\nvector<int> v[maxn];\nvoid pre()\n{\n\tn=10000000;\n\tmark[1]=true;\n\tfor (int i=2;i<=n;i++)\n\t{\n\t\tif (!mark[i])\n\t\t{\n\t\t\tpri[k++]=i;\n\t\t\t//cerr<<i<<endl;\n\t\t}\n\t\tfor (int j=0;j<k;j++)\n\t\t{\n\t\t\tint m=i*pri[j];\n\t\t\tif (m>n)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmark[m]=true;\n\t\t\tif (i%pri[j]==0)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\nbool dfs(int x)\n{\n\tfor (int i=0;i<v[x].size();i++)\n\t{\n\t\tint y=v[x][i];\n\t\tif (vis[y])\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\t\tif (linker[y]==-1 || dfs(linker[y]))\n\t\t{\n\t\t\tlinker[y]=x;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\nint main()\n{\n\tpre();\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%d\",&a[i]);\n\t}\n\tint k=0;\n\tb[++k]=a[1]-1;\n\tfor (int i=2;i<=n;i++)\n\t{\n\t\tif (a[i]!=a[i-1]+1)\n\t\t{\n\t\t\tb[++k]=a[i-1];\n\t\t\tb[++k]=a[i]-1;\n\t\t}\n\t}\n\tb[++k]=a[n];\n\tn=k;\n\tassert(n<=200);\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tlinker[i]=-1;\n\t\t//cerr<<b[i]<<endl;\n\t\tfor (int j=i+1;j<=n;j++)\n\t\t{\n\t\t\tif ((b[i]+b[j])&1 && !mark[abs(b[i]-b[j])])\n\t\t\t{\n\t\t\t\t//cerr<<i<<\" \"<<j<<\" \"<<abs(b[i]-b[j])<<\" \"<<mark[9]<<endl;\n\t\t\t\tif (b[i]&1)\n\t\t\t\t{\n\t\t\t\t\tv[i].pb(j);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tv[j].pb(i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint s=0;\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tif (!(b[i]&1))\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\t\tmemset(vis,false,sizeof(vis));\n\t\tif (dfs(i))\n\t\t{\n\t\t\ts++;\n\t\t}\n\t}\n\tint s1=0,s2=0;\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tif (b[i]&1)\n\t\t{\n\t\t\ts1++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\ts2++;\n\t\t}\n\t}\n\tint ans=s+((s1-s)/2+(s2-s)/2)*2+((s1-s)&1)*3;\n\tcout<<ans<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n\nusing namespace std;\n\nusing ll = long long;\nusing ld = long double;\n\n#define mp make_pair\n\nconst int p = 998244353;\n\n\nint mul(int a, int b) {\n    return (1LL * a * b) % p;\n}\n\nint add(int a, int b) {\n    int s = (a+b);\n    if (s>=p) s-=p;\n    return s;\n}\n\nint sub(int a, int b) {\n    int s = (a+p-b);\n    if (s>=p) s-=p;\n    return s;\n}\n\nint po(int a, int deg)\n{\n    if (deg==0) return 1;\n    if (deg%2==1) return mul(a, po(a, deg-1));\n    int t = po(a, deg/2);\n    return mul(t, t);\n}\n\nint inv(int n)\n{\n    return po(n, p-2);\n}\n\n/*struct DSU {\n    vector<int> sz;\n    vector<int> parent;\n\n    void make_set(int v) {\n        parent[v] = v;\n        sz[v] = 1;\n    }\n\n    int find_set(int v) {\n        if (v == parent[v])\n            return v;\n        return parent[v] = find_set(parent[v]);\n    }\n\n    void union_sets(int a, int b) {\n        a = find_set(a);\n        b = find_set(b);\n        if (a != b) {\n            if (sz[a] < sz[b])\n                swap(a, b);\n            parent[b] = a;\n            sz[a] += sz[b];\n        }\n    }\n\n    DSU(int n) {\n        sz.resize(n);\n        parent.resize(n);\n        for (int i = 0; i < n; i++) make_set(i);\n    }\n};*/\n\n/*const int N = 1200000;\n\nvector<int> facs(N), invfacs(N);\n\nvoid init()\n{\n    facs[0] = 1;\n    for (int i = 1; i<N; i++) facs[i] = mul(facs[i-1], i);\n    invfacs[N-1] = inv(facs[N-1]);\n    for (int i = N-2; i>=0; i--) invfacs[i] = mul(invfacs[i+1], i+1);\n}\n\nint C(int n, int k)\n{\n    return mul(facs[n], mul(invfacs[k], invfacs[n-k]));\n}*/\n\n/*const int N = 1e9;\n\nstruct MinSegTree\n{\n    int n;\n    vector<int> t;\n\n    void build(vector<int> &a, int v, int tl, int tr) {\n        if (tl == tr) {\n            t[v] = a[tl];\n        } else {\n            int tm = (tl + tr) / 2;\n            build(a, v*2, tl, tm);\n            build(a, v*2+1, tm+1, tr);\n            t[v] = min(t[v*2], t[v*2+1]);\n        }\n    }\n\n    int minn(int v, int tl, int tr, int l, int r) {\n        if (l > r)\n            return N;\n        if (l == tl && r == tr) {\n            return t[v];\n        }\n        int tm = (tl + tr) / 2;\n        return min(minn(v*2, tl, tm, l, min(r, tm)), minn(v*2+1, tm+1, tr, max(l, tm+1), r));\n    }\n\n    MinSegTree(vector<int> &a)\n    {\n        n = a.size();\n        t.resize(4*n);\n        build(a, 1, 0, n-1);\n    }\n\n};*/\n\n\ntemplate<int V, class T=long long>\nclass max_flow {\n    static const T INF = numeric_limits<T>::max();\n\n    unordered_map<int, T> cap[V];\n    int dist[V];\n    bool blocked[V];\n\n    void bfs(int s) {\n        memset(dist, -1, sizeof dist);\n        dist[s] = 0;\n        queue<int> q;\n        q.push(s);\n        while (!q.empty()) {\n            int n = q.front();\n            q.pop();\n            for (auto p : cap[n]) {\n                if (p.second && dist[p.first] == -1) {\n                    dist[p.first] = dist[n] + 1;\n                    q.push(p.first);\n                }\n            }\n        }\n    }\n\n    T augment(int n, T amt, int t) {\n        if (n == t) return amt;\n        if (blocked[n]) return 0;\n        T remaining = amt;\n        for (auto p : cap[n]) {\n            if (dist[p.first] != dist[n] + 1) continue;\n            T flowpart = min(remaining, cap[n][p.first]);\n            if (flowpart) {\n                T cur = augment(p.first, flowpart, t);\n                remaining -= cur;\n                cap[n][p.first] -= cur;\n                cap[p.first][n] += cur;\n            }\n        }\n        if (remaining) blocked[n] = true;\n        return amt - remaining;\n    }\n\npublic:\n    void add(int u, int v, T f=1) {\n        cap[u][v] += f;\n    }\n\n    T calc(int s, int t) {\n        T ans = 0;\n        while (true) {\n            bfs(s);\n            memset(blocked, false, sizeof blocked);\n            T aug = augment(s, INF, t);\n            if (!aug) break;\n            ans += aug;\n        }\n        return ans;\n    }\n\n    void clear() {\n        for (int i = 0; i < V; i++) {\n            cap[i].clear();\n        }\n    }\n};\n\n\nconst int N = 1e7 + 100;\n\n//set<int> primes;\nvector<bool> check(N);\n\nvoid init()\n{\n    check[1] = true;\n    for (int i = 2; i<N; i++) if (!check[i])\n    {\n        for (int j = 2*i; j<N; j+=i) check[j] = true;\n    }\n}\n\nint main() {\n    ios_base::sync_with_stdio(0);\n    cin.tie(nullptr);\n\n    init();\n\n    int n;\n    cin>>n;\n    vector<int> x(n);\n    for (int i = 0; i<n; i++) cin>>x[i];\n    set<int> even, odd;\n    for (int i = 0; i<n; i++)\n    {\n        int l = x[i]-1;\n        int r = x[i];\n        if (l%2) swap(l, r);\n        if (even.count(l)) even.erase(l); else even.insert(l);\n        if (odd.count(r)) odd.erase(r); else odd.insert(r);\n    }\n\n    int E = even.size();\n    int O = odd.size();\n\n    vector<int> e(even.begin(), even.end()); vector<int> o(odd.begin(), odd.end());\n\n\n    max_flow<300> network;\n\n    for (int i = 0; i<E; i++) network.add(0, i+1, 1);\n    for (int i = 0; i<O; i++) network.add(1 + E + i, E + O + 1, 1);\n\n    for (int i = 0; i<E; i++)\n        for (int j = 0; j<O; j++) if (!check[abs(e[i] - o[j])])\n        {\n            network.add(i + 1, 1 + E + j, 1);\n        }\n\n    int match = network.calc(0, E + O + 1);\n\n    E-=match; O-=match;\n\n    if (E%2==0) cout<<match + E + O;\n    else cout<<match + E + O + 1;\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <iomanip>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <unordered_set>\n#include <unordered_map>\n#include <bitset>\n#include <limits>\n#include <random>\n#include <complex>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cassert>\nusing namespace std;\n\n#define REP(i,n) for (int i = 0; i < n; i++)\ntemplate <class T> using reversed_priority_queue = priority_queue<T, vector<T>, greater<T> >;\ntypedef long long ll;\n\ntemplate <class T> struct FordFulkerson {\n\n    vector < pair < int,int > > maching;\n\n    struct  Edge {\n        int to,rev; T cap;\n        Edge(int t, int r, T c) : to(t), rev(r), cap(c) {}\n    };\n    \n    const T INF = numeric_limits<T>::max() / 2;\n    vector< vector< Edge > > G;\n    vector< bool > used;\n    FordFulkerson (int n) : G(n+1), used(n+1) {}\n   \n    void add_edge(int from, int to, T cap) {\n        G[from].push_back(Edge(to,(int)G[to].size(),cap));\n        G[to].push_back(Edge(from,(int)G[from].size()-1,0));\n    }\n    \n    T dfs(int v, int t, T f) {\n        if (v == t) return f;\n        used[v] = true;\n        for (int i = 0; i < G[v].size(); i++) {\n            Edge &e = G[v][i];\n            if (!used[e.to] && e.cap > 0) {\n                T d = dfs(e.to, t, min(f,e.cap));\n                if (d > 0) {\n                    if (v != 990 && e.to != 991) {\n                        maching.push_back(make_pair(v, e.to - 500));\n                    }\n                    e.cap -= d;\n                    G[e.to][e.rev].cap += d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n   \n    T get_max (int source, int sink) {\n        T flow = 0;\n        while (true) {\n            for (int i = 0; i < used.size(); i++) used[i] = false;\n            T f = dfs(source, sink, INF);\n            if (f == 0) return flow;\n            flow += f;\n        }\n    }\n    \n};\n\n\nbool isPrime(long long n) {\n    if (n <= 2) return false;\n    for (long long i = 2; i * i <= n; i++) if (n % i == 0) return false;\n    return true;\n}\n\nbool flip[10000010];\n\nint main ()\n{\n    int N;\n    cin >> N;\n    vector < int > x(N);\n    REP(i,N) cin >> x[i];\n\n    REP(i,N) {\n        flip[x[i]] = !flip[x[i]];\n        flip[x[i] + 1] = !flip[x[i] + 1];\n    }\n\n    vector < int > xt;\n    for (int i = 0; i < 10000010; i++) {\n        if (flip[i]) xt.push_back(i);\n    }\n\n    FordFulkerson < int > inst(1000);\n    for (int i = 0; i < xt.size(); i++) {\n        for (int j = i; j < xt.size(); j++) {\n            if (i == j) continue;\n            int diff = abs(xt[i] - xt[j]);\n            if (isPrime(diff)) {\n                inst.add_edge(i, j + 500, 1);\n            }\n        }\n    }\n    REP(i,N) {\n        inst.add_edge(990, i, 1);\n        inst.add_edge(i + 500, 991, 1);\n    }\n\n    int maxt = inst.get_max (990, 991);\n    vector < pair < int,int > > mc = inst.maching;\n\n    int odd = 0;\n    int even = 0;\n    REP(i,xt.size()) {\n        if (xt[i] % 2) {\n            even++;\n        } else {\n            odd++;\n        }\n    }\n\n    odd -= maxt;\n    even -= maxt;\n\n    int two = odd / 2 + even / 2;\n    int three = odd % 2;\n    \n    cout << maxt + two * 2 + three * 3 << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<cmath>\n#define N 210\n#define M 10000010\nusing namespace std;\nint prime[M],link[N],tot;\nbool p[M],vis[N];\nint n;\nbool can[N][N],s[M];\nvector<int>v[2];\nbool check(int u)\n{\n\tfor(int i=1;i<=v[1].size();i++)\n\tif(can[u][i] && !vis[i])\n\t{\n\t\tvis[i]=1;\n\t\tif(!link[i] || check(link[i]))\n \t\t{\n\t\t\tlink[i]=u;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\nint main()\n{\n\tp[1]=true;\n\tfor(int i=2;i<=M-10;i++)\n\t{\n\t\tif(!p[i]) prime[++tot]=i;\n\t\tfor(int j=1;j<=tot && i*prime[j]<=N-10;j++)\n\t\t{\n\t\t\tp[i*prime[j]]=1;\n\t\t\tif(i%prime[j]==0) break;\n\t\t}\n\t}\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint u;\n\t\tscanf(\"%d\",&u);\n\t\ts[u]=true;\n\t}\n\tfor(int i=2;i<=M-10;i++)\n\tif(s[i]^s[i-1]) v[i&1].push_back(i);\n\tfor(int i=0;i<v[0].size();i++)\n\t\tfor(int j=0;j<v[1].size();j++)\n\t\tif(!p[abs(v[0][i]-v[1][j])]) can[i+1][j+1]=true;\n\tint ans=0;\n    for(int i=0;i<v[0].size();i++)\n\t{\n\t\tmemset(vis,0,sizeof(vis));\n\t\tans+=check(i+1);\n\t}\n\tans+=(v[0].size()-ans)/2*2+(v[1].size()-ans)/2*2;\n    if((v[0].size()&1)!=(ans&1)) ans+=3;\n\tprintf(\"%d\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<cstring>\n\nusing namespace std;\nint n;\nconst int maxn = 1e7+10;//40M\nconst int S = 1e7+2;\nint pri[maxn],cnt; bool mk[maxn];\nint A[maxn];\nvoid oula() {\n\tmk[1] = mk[0] = 1;\n\tfor(int i=1;i<=S;i++) {\n\t\tif(!mk[i]) { pri[++cnt]=i; }\n\t\tfor(int j=1;j<=cnt&&1ll*pri[j]*i<=S;j++) {\n\t\t\tint k = pri[j]*i;\n\t\t\tmk[k] = 1;\n\t\t\tif(i%pri[j]==0) break;\n\t\t}\n\t}\n}\nint la[1005],en[405*405],owo,nt[405*405];\nvoid adg(int x,int y) {\n\ten[++owo]=y; nt[owo]=la[x]; la[x]=owo;\n}\nint cc[2];\nint yo[2][1005];\nint link[1005],vis[4005],vtm;\nbool hungary(int x,int tm) {\n\tfor(int it=la[x];it;it=nt[it]) {\n\t\tint y = en[it];\n\t\tif(vis[y]==tm) continue;\n\t\tvis[y] = tm;\n\t\tif((!link[y])||(hungary(link[y],tm))) {\n\t\t\tlink[y] = x; return 1;\n\t\t}\n\t}\n\treturn 0;\n}\nint main() {\n\toula();\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++) {\n\t\tint x; scanf(\"%d\",&x); A[x] = 1;\n\t}\n\tfor(int i=1;i<=S;i++) {\n\t\tint cf = A[i-1]^A[i];\n\t\tif(cf) {\n\t\t\t++cc[i&1];\n\t\t\tyo[i&1][cc[i&1]] = i;\n\t\t}\n\t}\n\tfor(int i=1;i<=cc[0];i++) {\n\t\tfor(int j=1;j<=cc[1];j++) {\n\t\t\tif(!mk[abs(yo[0][i]-yo[1][i])]) adg(i,j);\n\t\t}\n\t}\n\tint ans = 0;\n\tfor(int i=1;i<=cc[0];i++) {\n\t\tans += hungary(i,++vtm);\n\t}\n\tcc[0]-=ans; cc[1]-=ans;\n\tprintf(\"%d\",ans+cc[0]/2*2 + cc[1]/2*2 + (cc[0]&1)*3 );\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#define fo(i,a,b) for(i=a;i<=b;i++)\nusing namespace std;\ntypedef long long ll;\nconst int maxn=200+10,maxd=10000000+10;\nint x[maxn],s[maxd],pri[maxd],r[maxn],a[maxn],b[maxn];\nbool bz[maxd],dis[maxn][maxn],pd[maxn];\nint i,j,k,l,t,n,m,tot,top,num,sum,tmp,ans;\nvoid prepare(){\n    bz[1]=1;\n    fo(i,2,maxd-10){\n        if (!bz[i]) pri[++top]=i;\n        fo(j,1,top){\n            if ((ll)i*pri[j]>maxd-10) break;\n            bz[i*pri[j]]=1;\n            if (i%pri[j]==0) break;\n        }\n    }\n}\nbool dfs(int x){\n    int i;\n    fo(i,1,sum)\n        if (dis[x][i]&&!pd[i]){\n            pd[i]=1;\n            if (!r[i]||dfs(r[i])){\n                r[i]=x;\n                return 1;\n            }\n        }\n    return 0;\n}\nint main(){\n    prepare();\n    scanf(\"%d\",&n);\n    fo(i,1,n){\n        scanf(\"%d\",&x[i]);\n        s[x[i]]^=1;\n    }\n    fo(i,1,maxd-9){\n        if (s[i]!=s[i-1]){\n            if (i%2==1) a[++num]=i;\n            else b[++sum]=i;\n        }\n    }\n    fo(i,1,num)\n        fo(j,1,sum)\n            if (!bz[abs(a[i]-b[j])]) dis[i][j]=1;\n    fo(i,1,num){\n        fo(j,1,sum) pd[j]=0;\n        if (dfs(i)) tmp++;\n    }\n    ans+=2*((num-tmp)/2);\n    ans+=2*((sum-tmp)/2);\n    ans+=tmp;\n    if (num%2!=tmp%2) ans+=3;\n    printf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<queue>\n#include<stack>\n#include<cstring>\n#include<algorithm>\n#include<vector>\n#include<cmath>\nusing namespace std;\nint e[201][201];\nint vis[201];\nint match[201];\nint tot1=0,tot2=0;\nbool find(int u)\n{\n\tfor(int i=1;i<=tot2;i++)\n\t{\n\t\tif(vis[i]==0&&e[u][i])\n\t\t{\n\t\t\tvis[i]=1;\n\t\t\tif(!match[i]||find(match[i]))\n\t\t\t{\n\t\t\t\tmatch[i]=u;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n}\nbool isprime(int x)\n{\n\tif(x==1) return false;\n\tfor(int i=2;i<=sqrt(x);i++)\n\t\tif(x%i==0)\n\t\t\treturn false;\n\treturn true;\n}\nint x[201];\nint odd[201];\nint even[201];\nsigned main()\n{\n\tint n;\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)\n\t\tscanf(\"%d\",&x[i]);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tif(i==1||x[i-1]!=x[i]-1)\n\t\t{\n\t\t\tif(x[i]%2==1) odd[++tot1]=x[i];\n\t\t\telse even[++tot2]=x[i];\n\t\t}\n\t\tif(i==n||x[i+1]!=x[i]+1)\n\t\t{\n\t\t\tif(x[i]%2==1) even[++tot2]=x[i]+1;\n\t\t\telse odd[++tot1]=x[i]+1;\n\t\t}\n\t}\n\tfor(int i=1;i<=tot1;i++)\n\t\tfor(int j=1;j<=tot2;j++)\n\t\t\tif(isprime(abs(odd[i]-even[j])))\n\t\t\t\te[i][j]=1;\n\tint ans=0;\n\tfor(int i=1;i<=tot1;i++)\n\t{\n\t\tmemset(vis,0,sizeof(vis));\n\t\tif(find(i))\n\t\t\tans++;\n\t}\n\tprintf(\"%d\",ans+(tot1-ans)/2*2+(tot2-ans)/2*2+(tot1-ans)%2*3);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef unsigned long long int ull;\ntypedef long long int ll;\ntypedef pair<ll,ll> pll;\ntypedef long double D;\ntypedef complex<D> P;\n#define F first\n#define S second\nconst ll MOD=1000000007;\n//const ll MOD=998244353;\n\ntemplate<typename T,typename U>istream & operator >> (istream &i,pair<T,U> &A){i>>A.F>>A.S; return i;}\ntemplate<typename T>istream & operator >> (istream &i,vector<T> &A){for(auto &I:A){i>>I;} return i;}\ntemplate<typename T,typename U>ostream & operator << (ostream &o,const pair<T,U> &A){o<<A.F<<\" \"<<A.S; return o;}\ntemplate<typename T>ostream & operator << (ostream &o,const vector<T> &A){ll i=A.size(); for(auto &I:A){o<<I<<(--i?\" \":\"\");} return o;}\n\ntemplate <typename WeightType, typename TotalWeightType=int64_t>\nclass MaximumWeightedMatching {\n  /*\n  Maximum Weighted Matching in General Graphs\n  - O(n^3) time\n  - O(n + m) space\n  Note: each vertex is 1-indexed.\n  */\npublic:\n  using weight_t = WeightType;\n  using total_weight_t = TotalWeightType;\n  struct Edge { int from, to; weight_t weight; };\n\nprivate:\n  enum TreeLabelNumber { INNER = -1, UNUSED = 0, OUTER = 1 };\n  enum LabelNumber { SEPARATED = -2, DEFAULT = -1 };\n  enum EdgeNumber { UNDEFINED = 1 << 30 };\n  static constexpr weight_t INF = weight_t(1) << (sizeof(weight_t) * 8 - 2);\n  struct Node { int next, from, to; };\n  struct Label { int from, to; };\n  class Queue {\n  public:\n    Queue() {}\n    Queue(int N) : que(N), qh(0), qt(0) {}\n    void clear() { qh = qt = 0; }\n    int* data() { return que.data(); }\n    bool empty() const { return qh == qt; }\n    int dequeue() { return que[qh++]; }\n    void enqueue(int u) { que[qt++] = u; }\n    int operator [] (int i) const { return que[i]; }\n    int size() const { return qt; }\n\n    vector<int> que;\n    int qh, qt;\n  };\n\npublic:\n  MaximumWeightedMatching(int N, const vector<Edge>& raw_edges) \n      : N(N), B((N - 1) / 2), size(N + B + 1) {\n\n    ofs.assign(N + 2, 0);\n    for (auto& e : raw_edges) {\n      ofs[e.from + 1]++;\n      ofs[e.to + 1]++;\n    }\n    for (int i = 1; i <= N; ++i) ofs[i] += ofs[i - 1];\n    edges.resize(raw_edges.size() * 2);\n    for (int i = 0; i < (int) raw_edges.size(); ++i) {\n      auto& e = raw_edges[i];\n      edges[ofs[e.from]++] = {e.from, e.to, 2 * e.weight};\n      edges[ofs[e.to]++] = {e.to, e.from, 2 * e.weight};\n    }\n    for (int i = 0; i <= N; ++i) ofs[N + 1 - i] = ofs[N - i];\n    ofs[0] = 0;\n  }\n\n  total_weight_t maximum_weighted_matching() {\n    initialize();\n    set_potential();\n    for (int u = 1; u <= N; ++u) if (!mate[u]) {\n      for (int s = 0; !augmented(u, s); s = adjust_dual_solutions());\n      fix_blossom_bases();\n      clear_label();\n    }\n    total_weight_t ret = 0;\n    for (int u = 1; u <= N; ++u) if (mate[u] > u) {\n      weight_t max_w = 0;\n      for (int eid = ofs[u]; eid < ofs[u + 1]; ++eid) {\n        if (edges[eid].to == mate[u]) max_w = max(max_w, edges[eid].weight);\n      }\n      ret += max_w;\n    }\n    return ret >> 1;\n  }\n\nprivate:\n  inline int encode(int e) const {\n    return e + size + 1; // should be >= 3\n  }\n\n  inline weight_t reduced_cost(int u, int v, const Edge& e) const {\n    return potential[u] + potential[v] - e.weight;\n  }\n\n  inline weight_t reduced_cost(int eid) const {\n    return reduced_cost(edges[eid].from, edges[eid].to, edges[eid]);\n  }\n\n  void rematch(int v, int w) {\n    auto t = mate[v]; mate[v] = w;\n    if (mate[t] != v) return;\n    if (label[v].to == 0) {\n      mate[t] = label[v].from;\n      rematch(mate[t], t);\n    } else {\n      int x = label[v].from, y = label[v].to;\n      rematch(x, y); rematch(y, x);\n    }\n  }\n\n  Label search_blossom_edge(int bid) const {\n    int b = base[bid], bv = b;\n    for (; node[bv].next != b; bv = node[node[bv].next].next);\n    return {node[bv].from, node[bv].to};\n  }\n\n  void label_blossom(int bid, int m, Label l) {\n    label[bid] = {l.from, (l.to == surface[l.to]) ? 0 : l.to};\n    if (bid <= N) return;\n    int b = base[bid]; label_blossom(b, mate[bid] = m, l);\n    l = search_blossom_edge(bid);\n    for (int bv = b, bw; node[bv].next != b; bv = node[bw].next) {\n      label_blossom(bw = node[bv].next, 0, l);\n      label_blossom(node[bw].next, node[bw].from, {node[bv].from, node[bv].to});\n    }\n  }\n\n  int find_mate(int bid) {\n    return bid <= N ? mate[bid] : mate[bid] = find_mate(base[bid]);\n  }\n\n  void push_inner_blossom_rec(int bid, bool push=true) {\n    tree_label[bid] = (bid <= N) ? INNER : UNUSED;\n    if (bid > N) {\n      int v = base[bid], u = v;\n      do { push_inner_blossom_rec(v, push); } while ( (v = node[v].next) != u);\n    } else if (push) inner_vertices[inner_vertices_size++] = bid;\n  }\n\n  void push_inner_blossom(int bid) {\n    if (tree_label[bid] != UNUSED) return;\n    bool push = label[bid].from != SEPARATED;\n    if (bid > N) {\n      if (push) inner_blossoms[inner_blossom_size++] = bid; \n      push_inner_blossom_rec(bid, push);\n    } else if (push) inner_vertices[inner_vertices_size++] = bid;\n    tree_label[bid] = INNER;\n  }\n\n  void push_outer_blossom_rec(int bid) {\n    tree_label[bid] = (bid <= N) ? OUTER : UNUSED;\n    if (bid > N) {\n      int v = base[bid], u = v;\n      do { push_outer_blossom_rec(v); } while ( (v = node[v].next) != u );\n    } else outer_vertices.enqueue(bid);\n  }\n\n  void push_outer_blossom(int bid, bool push) {\n    push_outer_blossom_rec(bid);\n    if (bid <= N) return;\n    if (push) outer_blossoms[outer_blossom_size++] = bid, tree_label[bid] = OUTER;\n    else tree_label[bid] = UNUSED;\n  }\n\n  inline void merge_edge(int x, int bx, int eid) {\n    auto& e = edges[eid];\n    int y = e.to, by = surface[y];\n    if (tree_label[by] != OUTER || bx == by) return;\n    auto r_cost = reduced_cost(x, y, e);\n    if (r_cost < best_cost[by].first) {\n      if (best_cost[by].first == INF) merged_edges[merged_edge_size++] = by;\n      best_cost[by] = {r_cost, eid};\n    }\n  }\n\n  inline void merge_vertex(int x, int bx) {\n    for (int eid = ofs[x]; eid < ofs[x + 1]; ++eid) merge_edge(x, bx, eid);\n    best_edge[x] = UNDEFINED;\n  }\n\n  void clear_best_edges(int b) {\n    if (b > N) {\n      int v = b = base[b];\n      do { clear_best_edges(v); } while ( (v = node[v].next) != b );\n    } else best_edge[b] = UNDEFINED;\n  }\n\n  void merge_outer(int b, int bid) {\n    if (b > N) {\n      for (int eid = be_head[b]; eid >= 0; eid = be_next[eid]) {\n        merge_edge(edges[eid].from, bid, eid);\n      }\n      be_head[b] = -1;\n      clear_best_edges(b);\n    } else merge_vertex(b, bid);\n  }\n\n  void merge_inner(int b, int bid) {\n    if (b > N) {\n      int v = b = base[b];\n      do { merge_inner(v, bid); } while ((v = node[v].next) != b);\n    } else merge_vertex(b, bid);\n  }\n\n  void build_linked_list(int bid) {\n    if (bid <= N) return;\n    int last = -1;\n    for (; merged_edge_size > 0; ) {\n      int by = merged_edges[--merged_edge_size], eid = best_cost[by].second;\n      int x = edges[eid].from, y = edges[eid].to;\n      be_next[eid] = last;\n      if (tree_label[y] == OUTER) update_best_edge(y, by, best_cost[by].first, eid);\n      if (best_edge[x] == UNDEFINED || best_cost[by].first < reduced_cost(best_edge[x])) {\n        best_edge[x] = eid;\n      }\n      best_cost[by] = {INF, UNDEFINED};\n      last = eid;\n    }\n    be_head[bid] = last;\n  }\n\n  void merge_best_edges(int bid, int inner_count) {\n    for (int i = 0; i < inner_count; ++i) {\n      int bv = outer_blossoms[outer_blossom_size + i];\n      if (bv >= 0) merge_outer(bv, bid), merge_inner(node[bv].next, bid);\n      else merge_inner(~bv, bid), merge_outer(node[~bv].next, bid);\n    }\n    merge_outer(base[bid], bid);\n    build_linked_list(bid);\n  }\n\n  void contract(int x, int y, int eid) {\n    int s = surface[x], t = surface[y];\n    if (s == t) return;\n    auto h = label[surface[mate[s]]].from = label[surface[mate[t]]].from = -encode(eid);\n\n    int lca = -1;\n    for (; ; label[surface[mate[s]]].from = h) {\n      if (mate[t] != 0) swap(s, t);\n      s = lca = surface[label[s].from];\n      if (label[surface[mate[s]]].from == h) break;\n    }\n\n    int inner_count = 0;\n    for (int dir = 0; dir < 2; ++dir) {\n      int v = (dir == 0) ? x : y;\n      while (1) {\n        int bv = surface[v], mv = mate[bv], bmv = surface[mv];\n        if (bv == lca) break;\n        label[mv] = label[bmv] = {x, y};\n        auto n = node[bmv];\n        if (!dir) {\n          node[bv] = {bmv, mate[mv], mv};\n          node[bmv].next = surface[n.to];\n        } else {\n          node[surface[n.to]] = {bmv, n.to, n.from};\n          node[bmv] = {bv, mv, mate[mv]}; \n        }\n        push_outer_blossom(bmv, false);\n        v = label[bv].from;\n\n        // Caution: used as temporary array\n        outer_blossoms[outer_blossom_size + (inner_count++)] = !dir ? bv : ~bmv;\n      }\n    }\n    node[surface[y]] = {surface[x], y, x};\n\n    int bid = next_bid.back(); next_bid.pop_back();\n    base[bid] = lca, label[bid].from = label[lca].from, mate[bid] = mate[lca];\n\n    tree_label[bid] = OUTER;\n    set_surface(bid, bid);\n    merge_best_edges(bid, inner_count);\n\n    outer_blossoms[outer_blossom_size++] = bid;\n  }\n\n  inline void update_best_edge(int y, int by, weight_t r_cost, int eid) {\n    if (tree_label[by] != OUTER && best_edge[y] == UNDEFINED) {\n      neighbors[neighbor_size++] = y;\n    }\n    if (best_edge[y] == UNDEFINED || r_cost < reduced_cost(best_edge[y])) {\n      best_edge[y] = eid;\n    }\n  }\n\n  void build_edge_list(int b) {\n    if (b <= N) return;\n    merge_inner(b, b);\n    build_linked_list(b);\n  }\n\n  bool augmented(int root, int s) {\n    if (s == 0) {\n      int br = surface[root];\n      push_outer_blossom(br, true);\n      label_blossom(br, 0, {0, 0});\n      build_edge_list(br);\n    } \n    for (; !outer_vertices.empty() || s > 0; s = 0) {\n      auto x = (s > 0) ? s : outer_vertices.dequeue();\n      if (potential[x] == 0) {\n        if (root != x) rematch(x, 0);\n        return true;\n      }\n      for (int eid = ofs[x]; eid < ofs[x + 1]; ++eid) {\n        int bx = surface[x], y = edges[eid].to, by = surface[y];\n        if (bx == by) continue;\n        auto r_cost = reduced_cost(x, y, edges[eid]);\n        if (r_cost > 0 || tree_label[by] != OUTER) {\n          update_best_edge(y, by, r_cost, eid);\n          if (r_cost > 0) continue;\n        }\n        if (label[by].from >= 0) {\n          contract(x, y, eid);\n          continue;\n        } \n        if (tree_label[by] == UNUSED) {\n          push_inner_blossom(by);\n          if (by != y) label_blossom(by, find_mate(by), {DEFAULT, 0});\n        }\n        int z = mate[by];\n        if (z == 0 && by != surface[root]) {\n          rematch(x, y); rematch(y, x);\n          return true;\n        }\n        int bz = surface[z];\n        if (label[bz].from < 0) {\n          node[by] = {-1, y, x};\n          push_outer_blossom(bz, true);\n          label_blossom(bz, mate[z], {x, y});\n          build_edge_list(bz);\n        }\n      }\n    }\n    return false;\n  }\n\n  void set_surface(int b, int bid) {\n    for (int v = base[b]; surface[v] != bid; v = node[v].next) {\n      if (v > N) tree_label[v] = UNUSED, set_surface(v, bid);\n      surface[v] = bid;\n    }\n  }\n  \n  void reset_surface(int b, int bid) {\n    surface[b] = bid;\n    if (b <= N) return;\n    for (b = base[b]; surface[b] != bid; b = node[b].next) reset_surface(b, bid);\n  }\n\n  void separate_blossom(int bid, bool push_blossom=true) {\n    tree_label[bid] = UNUSED, label[bid].from = SEPARATED;\n    if (bid <= N) return;\n    if (push_blossom) inner_blossoms[inner_blossom_size++] = bid;\n    for (int b = base[bid]; label[b].from != SEPARATED; b = node[b].next) {\n      separate_blossom(b, false);\n    }\n  }\n\n  void reverse_blossom(int b) {\n    int v = b, fr = node[b].from, to = node[b].to;\n    for (int nv = node[v].next; nv != b; ) {\n      int nnext = node[nv].next, nfr = node[nv].from, nto = node[nv].to;\n      node[nv].next = v, node[nv].from = to, node[nv].to = fr;\n      fr = nfr, to = nto, v = nv, nv = nnext;\n    }\n    node[b].next = v, node[b].from = to, node[b].to = fr;\n  }\n\n  void expand_blossom(int bid) {\n    next_bid.push_back(bid); tree_label[bid] = UNUSED;\n    for (int b = base[bid]; surface[b] == bid; b = node[b].next) reset_surface(b, b);\n    int old_base = base[bid], target = surface[node[bid].from]; \n    if (mate[node[target].from] == node[target].to) reverse_blossom(old_base);\n    for (int b = target; node[b].next != old_base; ) {\n      separate_blossom(b = node[b].next); separate_blossom(b = node[b].next);\n    }\n    node[target] = node[bid];\n    for (int b = old_base; ; b = node[b].next) {\n      label[b].from = DEFAULT, tree_label[b] = INNER; \n      if (b > N) inner_blossoms[inner_blossom_size++] = b;\n      int m = find_mate(b), bm = surface[m];\n      if (b != old_base) mate[bm] = mate[m];\n      label[m] = label[bm] = {node[b].to, node[b].from};\n      if (b == target) break;\n      push_outer_blossom(b = node[b].next, true);\n      build_edge_list(b);\n    }\n    base[bid] = bid, surface[bid] = bid;\n  }\n\n  void update_potential(int* vs, int s, weight_t delta, int label) {\n    for (int i = 0; i < s; ++i) {\n      int x = vs[i];\n      if (tree_label[x] != label) continue;\n      potential[x] += delta;\n    }\n  }\n\n  int adjust_dual_solutions() {\n    pair<weight_t, int> delta1(INF, 0), delta2(INF, 0), delta3(INF, 0), delta4(INF, 0);\n    for (int i = 0; i < outer_vertices.size(); ++i) {\n      int y = outer_vertices[i], eid = best_edge[y];\n      delta1 = min(delta1, {potential[y], y});\n      if (eid != UNDEFINED) {\n        delta3 = min(delta3, {reduced_cost(eid) >> 1, y});\n      }\n    }\n    for (int i = 0; i < neighbor_size; ++i) {\n      int y = neighbors[i];\n      if (tree_label[y] == UNUSED) {\n        int eid = best_edge[y], x = edges[eid].from;\n        delta2 = min(delta2, {reduced_cost(x, y, edges[eid]), x});\n      }\n    }\n    for (int i = 0; i < inner_blossom_size; ++i) {\n      if (tree_label[inner_blossoms[i]] == INNER) {\n        int b = inner_blossoms[i];\n        delta4 = min(delta4, {potential[b] >> 1, b});\n      }\n    }\n    auto delta = min(min(delta1, delta2), min(delta3, delta4));\n    auto d = delta.first;\n    update_potential(outer_vertices.data(), outer_vertices.size(), -1 * d, OUTER);\n    update_potential(inner_vertices.data(), inner_vertices_size,    1 * d, INNER);\n    update_potential(outer_blossoms.data(), outer_blossom_size,     2 * d, OUTER);\n    update_potential(inner_blossoms.data(), inner_blossom_size,    -2 * d, INNER);\n    if (delta4.first == d) {\n      expand_blossom(delta4.second);\n      return -1;\n    } else {\n      return delta.second;\n    }\n  }\n\n  void fix_blossom_bases() {\n    int remain = size - next_bid.size() - (N + 1);\n    for (int bid = N + 1; bid < size && remain > 0; ++bid) if (base[bid] != bid) {\n      int b = base[bid];\n      for (int skipped = 0; skipped < 2;) {\n        b = node[b].next;\n        if (mate[node[b].from] == node[b].to) skipped = 0;\n        else skipped++;\n      }\n      base[bid] = b;\n      --remain;\n    }\n  }\n\n  void free_edge_list(int x) {\n    be_head[x] = -1;\n  }\n\n  void clear_vertices(int* vs, int size) {\n    for (int i = 0; i < size; ++i) {\n      int v = vs[i]; \n      label[v] = {DEFAULT, 0}; tree_label[v] = UNUSED; best_edge[v] = UNDEFINED;\n    }\n  }\n\n  void clear_label() {\n    label[0] = {DEFAULT, 0};\n    clear_vertices(outer_vertices.data(), outer_vertices.size()); outer_vertices.clear();\n    clear_vertices(inner_vertices.data(), inner_vertices_size); inner_vertices_size = 0;\n    clear_vertices(outer_blossoms.data(), outer_blossom_size);\n    for (int i = 0; i < outer_blossom_size; ++i) {\n      if (be_head[outer_blossoms[i]] >= 0) free_edge_list(outer_blossoms[i]);\n    }\n    outer_blossom_size = 0;\n    clear_vertices(inner_blossoms.data(), inner_blossom_size); inner_blossom_size = 0;\n    for (int i = 0; i < neighbor_size; ++i) best_edge[neighbors[i]] = UNDEFINED;\n    neighbor_size = 0;\n  }\n\n  void set_potential() {\n    potential.resize(size);\n    for (int u = 1; u <= N; ++u) {\n      weight_t max_w = 0;\n      for (int eid = ofs[u]; eid < ofs[u + 1]; ++eid) {\n        max_w = max(max_w, edges[eid].weight);\n      }\n      potential[u] = max_w >> 1;\n    }\n  }\n\n  void initialize() {\n    mate.assign(size, 0);\n    label.assign(size, {-1, 0});\n\n    surface.resize(size); for (int i = 0; i < size; ++i) surface[i] = i;\n    base.resize(size); for (int i = 0; i < size; ++i) base[i] = i;\n    node.resize(size); for (int i = 0; i < size; ++i) node[i] = {i, i, i};\n\n    outer_vertices = Queue(N);\n    inner_vertices.resize(N + 1); inner_vertices_size = 0;\n    outer_blossoms.resize(B); outer_blossom_size = 0;\n    inner_blossoms.resize(B); inner_blossom_size = 0;\n\n    tree_label.assign(size, UNUSED);\n\n    next_bid.resize(B);\n    for (int i = 0; i < B; ++i) next_bid[i] = size - 1 - i;\n\n    merged_edges.resize(N + 1); merged_edge_size = 0;\n    best_cost.assign(size, {INF, UNDEFINED});\n\n    neighbors.resize(N + 1); neighbor_size = 0;\n    best_edge.assign(size, UNDEFINED);\n\n    be_head.assign(size, -1);\n    be_next.resize(edges.size());\n  }\n\nprivate:\n  int N, B, size;\n  vector<Edge> edges;\n  vector<int> ofs;\n\n  vector<Label> label;\n  vector<int> mate, surface, base;\n  vector<Node> node;\n  vector<weight_t> potential;\n\n  vector<int> next_bid;\n\n  vector<int8_t> tree_label;\n\n  Queue outer_vertices;\n  vector<int> inner_vertices; int inner_vertices_size;\n  vector<int> outer_blossoms; int outer_blossom_size;\n  vector<int> inner_blossoms; int inner_blossom_size;\n\n  vector<int> merged_edges; int merged_edge_size;\n  vector< pair<weight_t, int> > best_cost;\n  vector<int> neighbors; int neighbor_size;\n  vector<int> best_edge;\n\n  vector<int> be_head, be_next;\n};\n\nconst ll MX=10000100;\n\nint main(){\n  vector<bool> prime(MX,true);\n  prime[0]=prime[1]=false;\n  for(ll i=2;i*i<MX;i++){\n    for(ll j=2;i*j<MX;j++){prime[i*j]=false;}\n  }\n  ll N;\n  cin>>N;\n  vector<bool> A(MX,false);\n  for(int i=0;i<N;i++){\n    ll x;\n    cin>>x;\n    A[x]=true;\n  }\n  vector<ll> pt;\n  for(ll i=1;i<MX;i++){\n    if(A[i-1]!=A[i]){pt.push_back(i);}\n  }\n  ll M=pt.size();\n  using Edge = MaximumWeightedMatching<int>::Edge;\n  vector<Edge> E;\n  for(int i=0;i<M;i++){\n    for(int j=0;j<i;j++){\n      if((pt[i]-pt[j])&1){\n        if(prime[pt[i]-pt[j]]){E.push_back({j+1,i+1,1});}\n        else{E.push_back({j+1,i+1,3});}\n      }\n      else{\n        E.push_back({j+1,i+1,2});\n      }\n    }\n  }\n  cout<<E.size()<<endl;\n  for(auto &I:E){cout<<I.from<<\" \"<<I.to<<\" \"<<I.weight<<endl;}\n  MaximumWeightedMatching<int> MM(N,E);\n  cout<<MM.maximum_weighted_matching()<<endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace std;\nusing namespace __gnu_pbds;\n\n#define ll long long\n#define db long double\n#define ii pair<int,int>\n#define vi vector<int>\n#define fi first\n#define se second\n#define sz(a) (int)(a).size()\n#define all(a) (a).begin(),(a).end()\n#define pb push_back\n#define mp make_pair\n#define FN(i, n) for (int i = 0; i < (int)(n); ++i)\n#define FEN(i,n) for (int i = 1;i <= (int)(n); ++i)\n#define rep(i,a,b) for(int i=a;i<b;i++)\n#define repv(i,a,b) for(int i=b-1;i>=a;i--)\n#define SET(A, val) memset(A, val, sizeof(A))\ntypedef tree<int ,null_type,less<int>,rb_tree_tag,tree_order_statistics_node_update>ordered_set ;\n// order_of_key (val): returns the no. of values less than val\n// find_by_order (k): returns the kth largest element.(0-based)\n#define TRACE\n#ifdef TRACE\n#define trace(...) __f(#__VA_ARGS__, __VA_ARGS__)\ntemplate <typename Arg1>\nvoid __f(const char* name, Arg1&& arg1){\n  cerr << name << \" : \" << arg1 << std::endl;\n}\ntemplate <typename Arg1, typename... Args>\nvoid __f(const char* names, Arg1&& arg1, Args&&... args){\n  const char* comma = strchr(names + 1, ','); cerr.write(names, comma - names) << \" : \" << arg1<<\" | \";__f(comma+1, args...);\n}\n#else\n#define trace(...)\n#endif\nconst int N=205,L=1e7+5;\nbool mark[L],prime[L];\nnamespace match\n{\n  const int N=205;\n  int l[N],r[N],n,m;\n  bool a[N][N],seen[N];\n  bool findmatch(int i)\n  {\n    rep(j,0,m)\n      {\n\tif(a[i][j] && !seen[j])\n\t  {\n\t    seen[j]=true;\n\t    if(r[j]<0 || findmatch(r[j]))\n\t      {\n\t\tl[i]=j; r[j]=i;\n\t\treturn true;\n\t      }\n\t  }\n      }\n    return false;\n  }\n  int bipartitematch()\n  {\n    int cnt=0;\n    rep(i,0,n) l[i]=-1;\n    rep(i,0,m) r[i]=-1;\n    rep(i,0,n)\n      {\n\trep(j,0,m) seen[j]=false;\n\tif(findmatch(i)) cnt++;\n      }\n    return cnt;\n  }\n};\nint main()\n{\n  std::ios::sync_with_stdio(false);\n  cin.tie(NULL) ; cout.tie(NULL) ;\n  memset(prime,true,sizeof(prime));\n  prime[0]=prime[1]=false;\n  rep(i,2,L)\n    {\n      if(!prime[i]) continue;\n      for(int j=2*i;j<L;j+=i)\n\tprime[j]=false;\n    }\n  prime[2]=false;\n  int n,x;\n  cin>>n;\n  rep(i,1,n+1)\n    {\n      cin>>x;\n      mark[x]=true;\n    }\n  vi arr;\n  int odd=0,even=0;\n  rep(i,1,L-1)\n    if(mark[i]!=mark[i-1])\n      {\n\tarr.pb(i);\n\tif(i&1) odd++;\n\telse even++;\n      }\n  match::n=match::m=sz(arr);\n  rep(i,0,sz(arr))\n    rep(j,0,sz(arr))\n    {\n      if(prime[abs(arr[i]-arr[j])]) match::a[i][j]=1;\n      else match::a[i][j]=0;\n    }\n  int k=match::bipartitematch();\n  assert((even-odd)%2==0);\n  even-=k; odd-=k;\n  int ans=k+(even/2+odd/2)*2+(even&1)*3;\n  cout<<ans<<endl;\n  return 0 ;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 1e7 + 700;\n\n\nint n,fre[maxn],p[220],ispr[maxn],even,odd,wrong;\nvector <int> edge[220],v2;\n\nbool fin(int u) {\n    if (fre[u]==wrong) return false;\n    fre[u]=wrong;\n    for (int j=0;j<edge[u].size();j++) {\n        int v=edge[u][j];\n       // cout<<u<<\" \"<<v<<endl;\n        if (p[v]==0 || fin(p[v])) {\n            p[v]=u;\n            return true;\n        }\n    }\n    return false;\n}\n\nint main() {\n//    freopen(\"in.txt\",\"r\",stdin);\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    ispr[1]=1;\n    for (int i=2;i<maxn;i++)\n        if (ispr[i]==0) {\n            for (int j=i+i;j<maxn;j+=i) ispr[j]=1;\n        }\n    cin>>n;\n    for (int i=1;i<=n;i++) {\n        int x;\n        cin>>x;\n        fre[x]^=1;\n        fre[x+1]^=1;\n    }\n    even=0; odd=0; wrong=2;\n    for (int i=0;i<maxn;i++)\n        if (fre[i]==1) {\n            v2.push_back(i);\n            if (i%2==0) even++;\n            else odd++;\n        }\n    // for (int i=0;i<v2.size();i++) cout<<v2[i]<<\" \";\n   //  cout<<endl;\n   // cout<<\" \" <<even<<\" \"<<odd<<endl;\n    for (int i=0;i<v2.size();i++)\n        for (int j=0;j<v2.size();j++)\n            if (v2[i]%2==0 && v2[j]%2==1 && ispr[ abs(v2[j] - v2[i]) ]==0) {\n                edge[i+1].push_back(j+1);\n                edge[j+1].push_back(i+1);\n            }\n    int cnt=0;\n    for (int i=0;i<v2.size();i++) {\n        wrong++;\n        //cout<<fin(i+1)<<endl;\n        cnt+=(fin(i+1));\n       // cout<<p[i+1]<<endl;\n      //  cout<<\"fuck\"<<endl;\n    }\n    cout<< cnt + ((even-cnt)/2 + (odd-cnt)/2) * 2 + (even%2)*3;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define L long long\n#define pb push_back\n#define pi pair<int,int>\n#define pii pair<pair<int,int>,int>\n#define aa first\n#define bb second\n#define mp make_pair\n#define mpp(a,b,c) mp(mp(a,b),c)\nusing namespace std;\n#define SZ 666666\ntypedef long long ll;\nint fst[SZ],nxt[SZ],vb[SZ],cap[SZ],ff[SZ],M=1,N=0;\n#define add ad_dl\nvoid _ad_dl(int a,int b,int c) {++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;cap[M]=c;}\nvoid ad_dl(int a,int b,int c)\n{_ad_dl(a,b,c); _ad_dl(b,a,0);}\nint S,T,q[SZ],d[SZ];\nbool bfs()\n{\n    memset(d,-1,4*(N+1));\n    d[T]=0; q[1]=T; int h=1,t=2;\n    while(h!=t)\n    {\n        int cur=q[h++];\n        for(int e=fst[cur];e;e=nxt[e])\n        {\n            int b=vb[e];\n            if(d[b]==-1&&cap[e^1])\n            {\n                d[b]=d[cur]+1, q[t++]=b;\n                if(b==S) return 1; //???? \n            }\n        }\n    }\n    return d[S]!=-1;\n}\nint dfs(int x,int f)\n{\n    if(f<=0) return 0;\n    if(x==T) return f;\n    int ca=0;\n    for(int& e=fst[x];e;e=nxt[e]) //????? \n    {\n        int b=vb[e];\n        if(d[b]+1!=d[x]) continue;\n        int w=dfs(b,(cap[e]<f-ca)?cap[e]:(f-ca));\n        cap[e]-=w; cap[e^1]+=w; ca+=w;\n        if(ca==f) break;\n    }\n    if(!ca) d[x]=-1; //????? \n    return ca;\n}\n#define inf 2e9+3\nint dinic()\n{\n    int ans=0;\n    memcpy(ff,fst,4*(N+1));\n    while(bfs())\n    {\n        //?????\n        ans+=dfs(S,inf);\n        memcpy(fst,ff,4*(N+1));\n    }\n    return ans;\n}\nint n,m,x[110],f[210],p;\nbool a[10000010];\nint main()\n{\n\t//freopen(\".in\",\"r\",stdin);\n\t//freopen(\".out\",\"w\",stdout);\n\tint i,j,k;\n\tscanf(\"%d\",&n);\n\tfor(i=1;i<=n;i++)\n\t  scanf(\"%d\",&x[i]);\n\tfor(i=2;i<=n;i++)\n\t  if(x[i-1]+1!=x[i])\n\t    {\n\t\t f[++m]=x[i-1]+1;\n\t\t f[++m]=x[i];\n\t\t}\n\tf[++m]=x[1];\n\tf[++m]=x[n]+1;\n\ta[1]=1;\n\tfor(i=2;i<=1e7;i++)\n\t  if(!a[i])\n\t    for(j=i;j<=1e7;j+=i)\n\t      a[j]=1;\n\ta[2]=1;\n\tN=m+2;\n\tS=m+2;\n\tT=m+1;\n\tfor(i=1;i<=m;i++)\n\t  if(f[i]&1)\n\t    add(m+2,i,1);\n\t  else\n\t    add(i,m+1,1);\n\tfor(i=1;i<=m;i++)\n\t  for(j=1;j<=m;j++)\n\t    if(f[i]&1 && !a[abs(f[i]-f[j])])\n\t      add(i,j,1);\n\tp=k=dinic();\n\tfor(i=1,j=-k;i<=m;i++)\n\t  if(f[i]&1)\n\t    j++;\n\tp+=j/2*2;\n\tif(j&1)\n\t  p+=3;\n\tfor(i=1,j=-k;i<=m;i++)\n\t  if(!(f[i]&1))\n\t    j++;\n\tp+=j/2*2;\n\tprintf(\"%d\\n\",p);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ninline int read(){int x=0,f=1;char ch=getchar();while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}return x*f;}\n\nconst int maxn = 100 + 15;\nconst int Maxsz = 2e7;\nconst int inf = 1e9 + 7;\n\nint Dp[maxn][maxn] , n , x[maxn] , Prime[Maxsz + 1] , Primelen , Vis[Maxsz + 1];\n\nvoid Init(){\n\tfor(int i = 2 ; i <= Maxsz ; ++ i){\n\t\tif( !Vis[i] )\n\t\t\tPrime[Primelen ++] = i;\n\t\tfor(int j = 0 ; j < Primelen && Prime[j] * i <= Maxsz ; ++ j){\n\t\t\tVis[i * Prime[j]] = 1;\n\t\t\tif( i % Prime[j] == 0 ) break;\n\t\t}\n\t}\n}\n\nint Dfs( int l , int r ){\n\tif( ~Dp[l][r] ) return Dp[l][r];\n\tint & ans = Dp[l][r] = inf;\n\tif( l > r ) return ans = 0;\n\tif( l == r ) return ans = 3;\n\tint ret = 0;\n\tfor(int i = l + 1 ; i <= r ; ++ i){\n\t\tif( x[i] - x[i - 1] - 1 == 0 ) ret += 0;\n\t\telse if( x[i] - x[i - 1] - 1 == 1 ) ret += 3;\n\t\telse if( x[i] - x[i - 1] - 1 == 2 ) ret += 2;\n\t\telse if( Vis[ x[i] - x[i - 1] - 1 ] == 0 ) ret += 1;\n\t\telse if( ( x[i] - x[i - 1] - 1 ) & 1  ) ret += 3;\n\t\telse ret += 2;\n\t}\n\tint length = x[r] - x[l] + 1;\n\tif( length == 2 ) ret += 2;\n\telse if( Vis[length] == 0 ) ret += 1;\n\telse if( length & 1 ) ret += 3;\n\telse ret += 2;\n\tfor(int i = l ; i <= r ; ++ i)\n\t\tfor(int j = i ; j <= r ; ++ j)\n\t\t\tans = min( ans , Dfs( l , i - 1 ) + Dfs( i , j ) + Dfs( j + 1 , r ) );\n\treturn ans = min( ans , ret );\n}\n\nint main( int argc , char * argv[] ){\n\tInit();\n\tn = read();\n\tfor(int i = 1 ; i <= n ; ++ i)\n\t\tx[i] = read();\n\tmemset( Dp , -1 , sizeof( Dp ) );\n\tprintf( \"%d\\n\" , Dfs( 1 , n ) );\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio> \n#include<algorithm>\n#include<cstring>\n#include<cmath>\n#include<set>\n#include<map>\nusing namespace std;\n#define fo(i,j,k) for(i=j;i<=k;i++)\n#define fd(i,j,k) for(i=j;i>=k;i--)\n#define cmax(a,b) (a=(a>b)?a:b)\n#define cmin(a,b) (a=(a<b)?a:b)\ntypedef long long ll;\nconst int N=1e6+5,M=1e7+50,mo=1e9+7;\nint vis[N],pdd[N],pd[M],pri[N],Ref[N],d[N],e[N],c[M],x,ttt,n,i,j,ans,y;\nint tt,b[N],nxt[N],fst[N];\nvoid cr(int x,int y)\n{\n\ttt++;\n\tb[tt]=y;\n\tnxt[tt]=fst[x];\n\tfst[x]=tt;\n}\nint dfs(int x)\n{\n\tif (vis[x]==ttt) return 0;\n\tvis[x]=ttt;\n\tfor (int p=fst[x];p;p=nxt[p])\n\t{\n\t\tif (!Ref[b[p]]||dfs(Ref[b[p]]))\n\t\t{\n\t\t\tRef[b[p]]=x;\n\t\t\tpdd[x]=b[p];\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\nvoid match()\n{\n\tfo(i,1,n)\n\t\tif (!pdd[i])\n\t\t{\n\t\t\tttt++;\n\t\t\tif (dfs(i)) ans++;\n\t\t}\n}\nvoid predo(int n)\n{\n\tfo(i,2,n)\n\t{\n\t\tif (!pd[i]) pri[++pri[0]]=i;\n\t\tfo(j,1,pri[0])\n\t\t{\n\t\t\tif (1ll*i*pri[j]>n) break;\n\t\t\tpd[i*pri[j]]=1;\n\t\t}\n\t}\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfo(i,1,n)\n\t{\n\t\tscanf(\"%d\",&x);\n\t\tc[x]^=1;\n\t\tc[x+1]^=1;\n\t}\n\tpredo(1e7+5);\n\tfo(i,1,1e7+5)\n\t\tif (c[i])\n\t\t{\n\t\t\tif (i%2)\n\t\t\t\td[++d[0]]=i;\n\t\t\telse e[++e[0]]=i;\n\t\t}\n\tpd[1]=pd[2]=1;\n\tfo(i,1,d[0])\n\t\tfo(j,1,e[0])\n\t\tif (!pd[abs(e[j]-d[i])])\n\t\t\tcr(i,j);\n\tans=0;\n\tmatch();\n\tx=y=0;\n\tfo(i,1,d[0]) if (!pdd[i]) x++;\n\tfo(i,1,e[0]) if (!Ref[i]) y++;\n\tans+=x-x%2+y-y%2;\n\tif (x%2) ans+=3;\n\tprintf(\"%d\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<vector>\n\nusing namespace std;\n\nvector<int> prime,point[201],v1,v2;\nint match[201],N,x,cnt;\nbool check[10000001],rev[10000002],vis[201];\n\nvoid sieve(){\n\tcheck[1]=true;for(int i=2;i<=10000000;++i){\n\t\tif(!check[i])prime.push_back(i);\n\t\tfor(int j:prime){if(1ll*i*j>10000000)break;check[i*j]=true;if(i%j==0)break;}\n\t}\n}\n\nbool dfs(int x){\n\tfor(int y:point[x])if(!vis[y]){vis[y]=true;if(match[y]<0||dfs(match[y])){match[y]=x;return true;}}\n\treturn false;\n}\n\nint main(){\n\tsieve();\n\tscanf(\"%d\",&N);for(int i=1;i<=N;++i)scanf(\"%d\",&x),rev[x]^=true;\n\tfor(int i=1;i<=10000001;++i)if(rev[i]!=rev[i-1])if(i&1)v1.push_back(i);else v2.push_back(i);\n\tfor(int i=0;i<v1.size();++i)for(int j=0;j<v2.size();++j)if(!check[abs(v1[i]-v2[j])])point[i].push_back(j);\n\tmemset(match,-1,sizeof(match));for(int i=0;i<v1.size();++i){memset(vis,false,sizeof(vis));if(dfs(i))++cnt;}\n\tprintf(\"%d\",cnt+(v1.size()-cnt>>1<<1)+(v2.size()-cnt>>1<<1)+((v1.size()-cnt)&1)*3);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint n,x,pri[10000005],np[10000005],s[10000005],cnt1,cnt2,a[105],b[105],vis[205],mch[205],tot,ans;\nvector<int>e[105];\nbool dfs(int x)\n{\n\tfor(int i=0;i<e[x].size();i++) if(!vis[e[x][i]])\n\t{\n\t\tvis[e[x][i]]=1;\n\t\tif(!mch[e[x][i]]||dfs(mch[e[x][i]])){mch[e[x][i]]=x;return 1;}\n\t}\n\treturn 0;\n}\nint main()\n{\n\tfor(int i=2;i<=1e7;i++)\n\t{\n\t\tif(!np[i]) pri[++tot]=i;\n\t\tfor(int j=1;j<=tot&&i*pri[j]<=1e7;j++){np[i*pri[j]]=1;if(i%pri[j]==0) break;}\n\t}\n\tscanf(\"%d\",&n);np[1]=1;\n\tfor(int i=1;i<=n;i++) scanf(\"%d\",&x),s[x]=1;\n\tfor(int i=1;i<=10000001;i++) if(s[i]!=s[i-1]) (i&1)?a[++cnt1]=i:b[++cnt2]=i;\n\tfor(int i=1;i<=cnt1;i++) for(int j=1;j<=cnt2;j++) if(!np[abs(a[i]-b[j])]) e[i].push_back(j);\n\tfor(int i=1;i<=cnt1;i++) memset(vis,0,sizeof(vis)),ans+=dfs(i);\n\tprintf(\"%d\\n\",ans+(cnt1-ans)/2*2+(cnt2-ans)/2*2+((cnt1-ans)&1)*3);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,l,r) for(register int i = l ; i <= r ; i++)\n#define repd(i,r,l) for(register int i = r ; i >= l ; i--)\n#define rvc(i,S) for(register int i = 0 ; i < (int)S.size() ; i++)\n#define rvcd(i,S) for(register int i = ((int)S.size()) - 1 ; i >= 0 ; i--)\n#define fore(i,x)for (register int i = head[x] ; i ; i = e[i].next)\n#define forup(i,l,r) for (register int i = l ; i <= r ; i += lowbit(i))\n#define fordown(i,id) for (register int i = id ; i ; i -= lowbit(i))\n#define pb push_back\n#define prev prev_\n#define stack stack_\n#define mp make_pair\n#define fi first\n#define se second\n#define lowbit(x) (x&(-x))\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pr;\n\nconst ll MAX = 2e18;\nconst ld inf = 2e18;\nconst int maxn = 220;\nconst ll mod = 1e9 + 7;\n\ninline ll power(ll x,ll y){\n\ty = ((y % (mod - 1)) + (mod - 1)) % (mod - 1);\n//\tif ( y < 0 ) return power(power(x,-y),mod - 2);\n\tll res = 1;\n\twhile ( y ){\n\t\tif ( y & 1 ) res = res * x % mod;\n\t\tx = x * x % mod;\n\t\ty >>= 1;\n\t}\n\treturn res;\n}\nint a[maxn],n,odd[maxn],even[maxn],cnt1,cnt2;\nset <int> s;\nnamespace Prime{\n\tconst int N = 1e7;\n\tint prime[N + 20],tag[N + 20],mn[N + 20],Cnt;\t\n\tvoid init (){\n\t\trep(i,2,N){\n\t\t\tif ( !tag[i] ) prime[++Cnt] = i;\n\t\t\trep(j,1,Cnt){\n\t\t\t\tif ( prime[j] * i > N ) break;\n\t\t\t\ttag[i * prime[j]] = 1;\n\t\t\t\tmn[i * prime[j]] = prime[j];\n\t\t\t\tif ( i % prime[j] == 0 ) break;\n\t\t\t}\n\t\t}\n\t}\n}\nusing namespace Prime;\n\nstruct node{\n\tint next,to;\n}e[maxn * maxn];\nint head[maxn],cnt;\nint from[maxn],use[maxn],tot;\n\ninline void adde(int x,int y){\n\te[++cnt].to = y;\n\te[cnt].next = head[x];\n\thead[x] = cnt;\n}\nbool match(int x){\n\tfore(i,x){\n\t\tif ( !use[e[i].to] ){\n\t\t\tuse[e[i].to] = 1;\n\t\t\tif ( from[e[i].to] == -1 || match(from[e[i].to]) ){\n\t\t\t\tfrom[e[i].to] = x;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nvoid hungary(){\n\ttot = 0;\n\tmemset(from,-1,sizeof(from));\n\tn = cnt1;\n\trep(i,1,n){\n\t\tmemset(use,0,sizeof(use));\n\t\tif ( match(i) ) ++tot;\n\t}\n}\n\n\nint main(){\n\tinit();\n\tscanf(\"%d\",&n);\n\trep(i,1,n){\n\t   \tscanf(\"%d\",&a[i]);\n\t\tif ( s.find(a[i]) == s.end() ) s.insert(a[i]);\n\t\telse s.erase(a[i]);\n\n\t\tif ( s.find(a[i] + 1) == s.end() ) s.insert(a[i] + 1);\n\t\telse s.erase(a[i] + 1);\n\t}\n\tfor (auto it = s.begin() ; it != s.end() ; ++it){\n\t\tint x = *it;\n\t\tif ( x & 1 ) odd[++cnt1] = x;\n\t\telse even[++cnt2] = x;\n\t}\n\trep(i,1,cnt1){\n\t\trep(j,1,cnt2){\n\t\t\tint c = abs(odd[i] - even[j]);\n\t\t\tif ( !tag[c] ) adde(i,j + cnt1);\n\t\t}\n\t}\n\thungary();\n\tcout<<cnt1 + cnt2 - tot + ((cnt1 - tot) & 1)<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <iomanip>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <unordered_set>\n#include <unordered_map>\n#include <bitset>\n#include <limits>\n#include <random>\n#include <complex>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cassert>\nusing namespace std;\n\n#define REP(i,n) for (int i = 0; i < n; i++)\ntemplate <class T> using reversed_priority_queue = priority_queue<T, vector<T>, greater<T> >;\ntypedef long long ll;\n\ntemplate <class T> struct FordFulkerson {\n\n    vector < pair < int,int > > maching;\n\n    struct  Edge {\n        int to,rev; T cap;\n        Edge(int t, int r, T c) : to(t), rev(r), cap(c) {}\n    };\n    \n    const T INF = numeric_limits<T>::max() / 2;\n    vector< vector< Edge > > G;\n    vector< bool > used;\n    FordFulkerson (int n) : G(n+1), used(n+1) {}\n   \n    void add_edge(int from, int to, T cap) {\n        G[from].push_back(Edge(to,(int)G[to].size(),cap));\n        G[to].push_back(Edge(from,(int)G[from].size()-1,0));\n    }\n    \n    T dfs(int v, int t, T f) {\n        if (v == t) return f;\n        used[v] = true;\n        for (int i = 0; i < G[v].size(); i++) {\n            Edge &e = G[v][i];\n            if (!used[e.to] && e.cap > 0) {\n                T d = dfs(e.to, t, min(f,e.cap));\n                if (d > 0) {\n                    if (v != 990 && e.to != 991) {\n                        maching.push_back(make_pair(v, e.to - 500));\n                    }\n                    e.cap -= d;\n                    G[e.to][e.rev].cap += d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n   \n    T get_max (int source, int sink) {\n        T flow = 0;\n        while (true) {\n            for (int i = 0; i < used.size(); i++) used[i] = false;\n            T f = dfs(source, sink, INF);\n            if (f == 0) return flow;\n            flow += f;\n        }\n    }\n    \n};\n\n\nbool isPrime(long long n) {\n    if (n <= 2) return false;\n    for (long long i = 2; i * i <= n; i++) if (n % i == 0) return false;\n    return true;\n}\n\nbool flip[10000010];\n\nint main ()\n{\n    int N;\n    cin >> N;\n    vector < int > x(N);\n    REP(i,N) cin >> x[i];\n\n    REP(i,N) {\n        flip[x[i]] = !flip[x[i]];\n        flip[x[i] + 1] = !flip[x[i] + 1];\n    }\n\n    vector < int > xt;\n    for (int i = 0; i < 10000010; i++) {\n        if (flip[i]) xt.push_back(i);\n    }\n\n    FordFulkerson < int > inst(1000);\n    for (int i = 0; i < xt.size(); i++) {\n        for (int j = i; j < xt.size(); j++) {\n            if (i == j) continue;\n            int diff = abs(xt[i] - xt[j]);\n            if (isPrime(diff)) {\n                inst.add_edge(i, j + 500, 1);\n            }\n        }\n    }\n    REP(i,xt.size()) {\n        inst.add_edge(990, i, 1);\n        inst.add_edge(i + 500, 991, 1);\n    }\n\n    int maxt = inst.get_max (990, 991);\n    vector < pair < int,int > > mc = inst.maching;\n\n    int odd = 0;\n    int even = 0;\n    REP(i,xt.size()) {\n        if (xt[i] % 2) {\n            even++;\n        } else {\n            odd++;\n        }\n    }\n\n    odd -= maxt;\n    even -= maxt;\n\n    int two = odd / 2 + even / 2;\n    int three = even % 2;\n    \n    cout << maxt + two * 2 + three * 3 << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<algorithm>\n#include<queue>\n#include<cstring>\n#include<vector>\n#define pa pair<int,int>\n#define fi first\n#define se second\n#define pb push_back\n#define mp make_pair\nusing namespace std;\nconst int M=1e7+10,N=2e3+10;\nstruct edge{int next,to,w;}a[N*N*2];\nint pri[M],tot,head[N],cnt=1,cur[N],S,T;\nint dep[N],nod,dis[N],n,ans;\nbool ispri[M],A[M],B[M];\nvector<pa> L,R;\nqueue<int> Q;\nvoid Pre()\n{\n\tint u=1e7;\n\tfor(int i=2;i<=u;i++)\n\t{\n\t\tif(!ispri[i]) pri[++tot]=i;\n\t\tfor(int j=1;j<=tot&&pri[j]*i<=u;j++)\n\t\t{\n\t\t\tispri[i*pri[j]]=1;\n\t\t\tif(i%pri[j]==0) break;\n\t\t}\n\t}\n\tispri[1]=ispri[2]=1;\n}\nvoid link(int x,int y,int w)\n{\n\ta[++cnt]=(edge){head[x],y,w};head[x]=cnt;\n\ta[++cnt]=(edge){head[y],x,0};head[y]=cnt;\n}\nint BFS()\n{\n\tmemset(dep,0,sizeof(dep));\n\tdep[S]=1;Q.push(S);\n\twhile(!Q.empty())\n\t{\n\t\tint x=Q.front();Q.pop();\n\t\tfor(int i=head[x];i;i=a[i].next)\n\t\t\tif(!dep[a[i].to]&&a[i].w)\n\t\t\t\tdep[a[i].to]=dep[x]+1,Q.push(a[i].to);\n\t}\n\treturn dep[T];\n}\nint DFS(int x,int flow)\n{\n\tif(x==T) return flow;\n\tfor(int &i=cur[x];i;i=a[i].next)\n\t{\n\t\tint R=a[i].to;\n\t\tif(!a[i].w||dep[R]!=dep[x]+1) continue;\n\t\tint k=DFS(R,min(flow,a[i].w));\n\t\tif(k) {a[i].w-=k;a[i^1].w+=k;return k;}\n\t}\n\treturn 0;\n}\nint main()\n{\n\tPre();cin>>n;\n\tfor(int i=1,x;i<=n;i++) cin>>x,A[x]=1;\n\tfor(int i=1;i<=1e7+1;i++)\n\t\tif(A[i]!=A[i-1]) i%2?L.pb(mp(++nod,i)):R.pb(mp(++nod,i));\n\tS=nod+1;T=S+1;\n\tfor(auto x:L) link(S,x.fi,1);\n\tfor(auto x:R) link(x.fi,T,1);\n\tfor(auto x:L)\n\t\tfor(auto y:R)\n\t\t\tif(!ispri[abs(y.se-x.se)])\n\t\t\t\tlink(x.fi,y.fi,1);\n\twhile(BFS())\n\t{\n\t\tfor(int i=1;i<=T;i++) cur[i]=head[i];\n\t\twhile(int tmp=DFS(S,100000)) ans+=tmp;\n\t}\n\tint res1=(L.size()-ans)/2;\n\tint res2=(R.size()-ans)/2;\n\tint res3=(L.size()-ans)%2;\n\tans=ans+res1*2+res2*2+res3*3;\n\tcout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include <algorithm>\n#include <vector>\n#include <deque>\n#include <set>\n#include <queue>\nusing namespace std;\n\n// dinic\nclass max_flow {\n    struct edge { int to, cap, rev; };\n    static const int INT_MAX = 2147483647;\n    int V;\n    vector<vector<edge>> G;\n    vector<int> level;\n\npublic:\n    max_flow(int V) : V(V) { G.assign(V,vector<edge>()); }\n\n    void add_edge(int from, int to, int cap) {\n        G[from].push_back((edge) {to, cap, (int) G[to].size()});\n        G[to].push_back((edge) {from, 0, (int) G[from].size()-1});\n    }\n\n    void bfs(int s) {\n        level.assign(V,-1);\n        queue<int> q;\n        level[s] = 0; q.push(s);\n        while (!q.empty()) {\n            int v = q.front(); q.pop();\n            for(auto &e: G[v]){\n                if (e.cap > 0 and level[e.to] < 0) {\n                    level[e.to] = level[v] + 1;\n                    q.push(e.to);\n                }\n            }\n        }\n    }\n\n    int dfs(int v, int t, int f) {\n        if (v == t) return f;\n        for (int i = 0; i < (int) G[v].size();i++) {\n            edge& e = G[v][i];\n            if (e.cap > 0 and level[v] < level[e.to]) {\n                int d = dfs(e.to, t, min(f, e.cap));\n                if (d > 0) {\n                    e.cap -= d;\n                    G[e.to][e.rev].cap += d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n\n    int run(int s, int t) {\n        int ret = 0, f;\n        while (bfs(s), level[t] >= 0) {\n            while ((f = dfs(s, t, INT_MAX)) > 0) ret += f;\n        }\n        return ret;\n    }\n};\n\n\nint main()\n{\n    // 整数の入力\n    long long N,a_i,a_i_1,i;\n    a_i_1 = -1;\n    vector<long long>B;\n    vector<long long> odds;\n    vector<long long> evens;\n    set<long long>primes;\n    cin >> N;\n    cin >> a_i;\n    B.push_back(a_i);\n    a_i_1 = a_i;\n\n    for (i= 1; i< N ; i++) {\n        cin >> a_i;\n        if (a_i != a_i_1 + 1){\n            B.push_back(a_i_1 + 1);\n            B.push_back(a_i);\n        }\n        a_i_1 = a_i;\n    }\n\n    B.push_back(a_i_1 + 1);\n\n    for(i=2;i<3163;i++){\n        if(all_of(primes.begin(),primes.end(),[i](long long p) {return i % p != 0;})){\n            primes.insert(i);\n        }\n    }\n\n    for (i=0;i<B.size();i++){\n        if (B[i] %2 == 0){\n            evens.push_back(B[i]);\n        }else{\n            odds.push_back(B[i]);\n        }\n    }\n\n    max_flow flow(B.size()+2);\n    for(int i=0;i<odds.size();i++){\n        flow.add_edge(0,i+1,1);\n    }\n    for(int i=0;i<evens.size();i++){\n        flow.add_edge(odds.size()+i+1,B.size()+1,1);\n    }\n\n    for(int i=0;i<odds.size();i++){\n        for(int j = 0;j<evens.size();j++){\n            if(abs(odds[i] - evens[j]) > 2 &&\n                all_of(primes.begin(),primes.end(), [&](long long p){return (abs(odds[i] - evens[j])) == p || (abs(odds[i] - evens[j])) % p != 0;})){\n                flow.add_edge(i+1,odds.size()+j+1,1);\n            }\n        }\n    }\n    int K = flow.run(0,B.size()+1);\n    cout << K + ((odds.size() - K)/2 + (evens.size() - K)/2) * 2 + ((odds.size() - K)%2)* 3 << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long long ll;\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,a) FOR(i,0,a)\n\t\nusing namespace std;\nconst int MAX_N=100,MAX_X=1e7;\nint N;\nint sto[2][MAX_N*2],ston[2];\nvector<int> G[MAX_N*2];\nbool used[MAX_N*2];\nint pa[MAX_N*2];\nbool isp[MAX_X+1];\nbool dfs(int v){\n\tused[v]=true;\n\tfor(auto e:G[v]){\n\t\tif (pa[e]==-1 || (!used[pa[e]] && dfs(pa[e]))){\n\t\t\tpa[v]=e;\n\t\t\tpa[e]=v;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\nint matching(){\n\tint ret=0;\n\tmemset(pa,-1,sizeof(pa));\n\tREP(v,ston[0]){\n\t\tfill(used,used+ston[0]+ston[1],false);\n\t\tif (pa[v]==-1 && dfs(v)){\n\t\t\tret++;\n\t\t}\n\t}\n\treturn ret;\n}\nint main(){\n\tcin>>N;\n\t{\n\t\tvector<bool> a((int)1e7+2),b((int)1e7+1);\n\t\tREP(i,N){\n\t\t\tint x;\n\t\t\tcin>>x;\n\t\t\ta[x]=1;\n\t\t}\n\t\tREP(i,(int)1e7+1){\n\t\t\tb[i]=a[i]^a[i+1];\n\t\t}\n\t\tREP(i,(int)1e7+1){\n\t\t\tif (b[i]){\n\t\t\t\tif (i&1){\n\t\t\t\t\tsto[1][ston[1]]=i;\n\t\t\t\t\tston[1]++;\n\t\t\t\t}else{\n\t\t\t\t\tsto[0][ston[0]]=i;\n\t\t\t\t\tston[0]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tmemset(isp,1,sizeof(isp));\n\tisp[0]=isp[1]=false;\n\tFOR(i,2,MAX_X+1){\n\t\tif (isp[i]){\n\t\t\tfor(int j=i*2;j<=MAX_X;j+=i){\n\t\t\t\tisp[j]=false;\n\t\t\t}\n\t\t}\n\t}\n\tREP(i,ston[0]){\n\t\tREP(j,ston[1]){\n\t\t\tint n=abs(sto[0][i]-sto[1][j]);\n\t\t\tif (n%2 && isp[n]){\n\t\t\t\tG[i].push_back(j);\n\t\t\t\tG[j].push_back(i);\n\t\t\t}\n\t\t}\n\t}\n\tint mat=matching();\n\tint ans=mat+(ston[0]-mat)/2*2+(ston[1]-mat)/2*2;\n\tif ((ston[0]-mat)%2){\n\t\tans+=3;\n\t}\n\tcout<<ans<<endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define maxn 210\n#define maxm 10000010\nconst int lim=1e7;\ntemplate <typename T>inline T read()\n{\n    register T sum=0;\n    register char cc=getchar();\n    int sym=1;\n    while(cc!='-'&&(cc>'9'||cc<'0'))cc=getchar();\n    if(cc=='-')sym=-1,cc=getchar();\n    sum=sum*10+cc-'0';\n    cc=getchar();\n    while(cc>='0'&&cc<='9')sum=sum*10+cc-'0',cc=getchar();\n    return sym*sum;\n}\ntemplate <typename T>inline T read(T &a)\n{\n    a=read<T>();\n    return a;\n}\ntemplate <typename T,typename... Others> inline void read(T& a, Others&... b)\n{\n    a=read(a);\n\tread(b...);\n}\nstruct Edge\n{\n\tint v;\n\tEdge *next;\n\tEdge(int a=0,Edge *b=NULL)\n\t{\n\t\tv=a;\n\t\tnext=b;\n\t}\n}*head[maxm];\nint n,mx,tim,cnt,cnt1,cnt2,ans,maxflow,a[maxm];\nint L[maxm],R[maxm],p[maxm],vis[maxm],match[maxm];\nbool Match(int k)\n{\n\tfor(Edge *i=head[k];i!=NULL;i=i->next)\n\t{\n\t\tif(vis[i->v]==tim)\n\t\t\tcontinue;\n\t\tvis[i->v]=tim;\n\t\tif(!match[i->v]||Match(match[i->v]))\n\t\t{\n\t\t\tmatch[i->v]=k;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\nvoid init()\n{\n\tvis[0]=vis[1]=true;\n\tfor(int i=2;i<=lim;i++)\n\t{\n\t\tif(!vis[i])\n\t\t\tp[++cnt]=i;\n\t\tfor(int j=1;j<=cnt&&p[j]*i<=lim;j++)\n\t\t{\n\t\t\tvis[i*p[j]]=true;\n\t\t\tif(i%p[j]==0)\n\t\t\t\tbreak;\n\t\t}\n\t}\n}\nint main()\n{\n\tinit();\n\tread(n);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint x;\n\t\tread(x);\n\t\ta[x]+=1;\n\t\tmx=max(mx,x);\n\t}\n\tfor(int i=1;i<=mx+1;i++)\n\t{\n\t\tif(a[i]!=a[i-1])\n\t\t{\n\t\t\tif(i&1)\n\t\t\t\tL[++cnt1]=i;\n\t\t\telse\n\t\t\t\tR[++cnt2]=i;\n\t\t}\n\t}\n\tfor(int i=1;i<=cnt1;i++)\n\t\tfor(int j=1;j<=cnt2;j++)\n\t\t\tif(!vis[abs(L[i]-R[j])])\n\t\t\t\thead[i]=new Edge(j,head[i]);\n\tfor(int i=1;i<=cnt1;i++)\n\t{\n\t\ttim+=1;\n\t\tmaxflow+=Match(i);\n\t}\n\tans=maxflow;\n\tans+=(cnt1-maxflow)/2*2+(cnt2-maxflow)/2*2;\n\tans+=((cnt1-maxflow)&1)*3;\n\tprintf(\"%d\\n\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <cstdio>\n#include <utility>\n\n#define Int register int\n\nusing namespace std;\n\nconst int MAXN = 100, MAXV = 1e7, MAXE = 5e4, MAXP = 664579, INF = 0x3f3f3f3f;\nint n, L, S, T, d[MAXV + 5];\nint pn, Prime[MAXP + 5];\nint CntL, CntR, Left[MAXV + 5], Right[MAXV + 5];\nint Cnte = 1, Head[MAXV + 5];\nbool Vis[MAXV + 5];\npair<int, int> Path[MAXV + 5];\n\nstruct Edge { int To, Flow, nxt; } Graph[MAXE * 2 + 5];\n\ninline int Abs ( const int x ) { return x < 0 ? ~ x + 1 : x; }\n\ninline int Min ( const int a, const int b ) { return a < b ? a : b; }\n\ninline void Link ( const int s, const int t, const int f ) { Graph[++ Cnte] = { t, f, Head[s] }, Head[s] = Cnte; }\n\ninline void AddEdge ( const int s, const int t, const int f ) {\n#ifdef __DEBUG\n\tprintf ( \"<%d, %d, %d>\\n\", s, t, f );\n#endif\n\tLink ( s, t, f ), Link ( f, t, 0 );\n}\n\ninline void Sieve ( const int n ) {\n\tVis[0] = Vis[1] = true;\n\tfor ( Int i = 2; i <= n; ++ i ) {\n\t\tif ( ! Vis[i] ) Prime[++ pn] = i;\n\t\tfor ( Int j = 1; j <= pn && i * Prime[j] <= n; ++ j ) {\n\t\t\tVis[i * Prime[j]] = true;\n\t\t\tif ( ! ( i % Prime[j] ) ) break;\n\t\t}\n\t}\n\tVis[2] = true;\n}\n\ninline bool BFS () {\n\tstatic queue<int> Q;\n\tfor ( ; ! Q.empty (); Q.pop () );\n\tfor ( Int i = 1; i <= T; ++ i ) Vis[i] = false;\n\twhile ( ! Q.empty () ) {\n\t\tint u = Q.front (); Q.pop ();\n\t\tfor ( Int i = Head[u], v; i; i = Graph[i].nxt ) {\n\t\t\tif ( ! Vis[v = Graph[i].To] && Graph[i].Flow > 0 ) {\n\t\t\t\tQ.push ( v ), Vis[v] = true, Path[v] = { u, i };\n\t\t\t\tif ( v == T ) return true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\ninline int EK () {\n\tint ret = 0;\n\tfor ( ; BFS (); ) {\n\t\tint MinFlow = INF;\n\t\tfor ( Int u = T; u ^ S; u = Path[u].first ) MinFlow = Min ( MinFlow, Graph[Path[u].second].Flow );\n\t\tfor ( Int u = T; u ^ S; u = Path[u].first ) {\n\t\t\tGraph[Path[u].second].Flow -= MinFlow;\n\t\t\tGraph[Path[u].second ^ 1].Flow += MinFlow;\n\t\t}\n\t\tret += MinFlow;\n\t}\n\treturn ret;\n}\n\ninline void Work () {\n\tSieve ( MAXV );\n\tscanf ( \"%d\", &n );\n\tfor ( Int i = 1, x; i <= n; ++ i ) {\n\t\tscanf ( \"%d\", &x ), ++ d[x];\n\t\tL = L > x ? L : x;\n\t}\n\tfor ( Int i = 1; i <= L + 1; ++ i ) {\n\t\tif ( d[i] ^ d[i - 1] ) {\n\t\t\tif ( i & 1 ) {\n\t\t\t\tLeft[++ CntL] = i;\n\t\t\t} else {\n\t\t\t\tRight[++ CntR] = i;\n\t\t\t}\n\t\t}\n\t}\n\tS = CntL + CntR + 1, T = S + 1;\n\tfor ( Int i = 1; i <= CntL; ++ i ) AddEdge ( S, i, 1 );\n\tfor ( Int i = 1; i <= CntR; ++ i ) AddEdge ( i + CntL, T, 1 );\n\tfor ( Int i = 1; i <= CntL; ++ i ) {\n\t\tfor ( Int j = 1; j <= CntR; ++ j ) {\n\t\t\tif ( ! Vis[Abs ( Left[i] - Right[j] )] ) {\n\t\t\t\tAddEdge ( i, j + CntR, 1 );\n\t\t\t}\n\t\t}\n\t}\n\tint mxf = EK (), Ans = mxf;\n\tAns += ( CntL - mxf >> 1 << 1 ) + ( CntR - mxf >> 1 << 1 );\n\tAns += ( ( CntL - mxf ) & 1 ) * 3;\n\tprintf ( \"%d\\n\", Ans );\n}\n\nint main () {\n\tWork ();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nnamespace prime{\n\tconst int mx = 10000001;\n\tbool f[mx];\n\tint p[777777],lp;\n\tvoid init(){\n\t\tfor(int i=2; i<mx; i++){\n\t\t\tif(!f[i])p[lp++]=i;\n\t\t\tfor(int j=0; j<lp; j++){\n\t\t\t\tint w = p[j] * i;\n\t\t\t\tif(w >= mx)break;\n\t\t\t\tf[w] = true;\n\t\t\t\tif(i%p[j]==0)break;\n\t\t\t}\n\t\t}\n\t}\n\tbool isprime(int x){\n\t\tif(x<2)return false;\n\t\treturn !f[x];\n\t}\n};\n\nbool g[10000002];\n\nint lk[333];\nbool b[333];\nint A[333],B[333],LA,LB;\nbool fd(int x){\n\tfor(int j=0; j<LB; j++)\n\t\tif(!b[j] && prime::isprime(labs(A[x]-B[j]))){\n\t\t\tb[j] = true;\n\t\t\tif(lk[j] == -1 || fd(lk[j])){\n\t\t\t\tlk[j] = x;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\treturn false;\n}\nint main(){\n\tprime::init();\n\tint x,z;\n\tfor(scanf(\"%d\",&x); x--;){\n\t\tscanf(\"%d\",&z);\n\t\tg[z] = true;\n\t}\n\tfor(int i=0; i<=z; i++)if(g[i] != g[i+1]){\n\t\tif(i%2==0)A[LA++] = i;else\n\t\t\tB[LB++] = i;\n\t}\n\tmemset(lk,-1,sizeof(lk));\n\tint R = 0;\n\tfor(int i=0; i<LA; i++){\n\t\tmemset(b,0,sizeof(b));\n\t\tif(fd(i))R++;\n\t}\n\tLA -= R;\n\tLB -= R;\n\tif(LA % 2 == 1)R += 3;\n\tR += LA / 2 * 2 + LB / 2 * 2;\n\tprintf(\"%d\\n\",R);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<cstring>\nusing namespace std;\nint n;\nint res;\nvector<int>v;\nint lst=-1;\nint match[210];\nint me,mo;\nint mx;\nbool f[10000010];\nvector<int>ok[210];\nint vis[210];\nint prm[1000010];\nint sz;\nint l;\nbool bp(int x,int p)\n{\n\tvis[x]=p;\n\tfor(int i=0;i<ok[x].size();i++)\n\t{\n\t\tint y=ok[x][i];\n\t\tif(match[y]==-1 || vis[match[y]]!=p && bp(match[y],p))\n\t\t{\n\t\t\tmatch[y]=x;\n\t\t\tmatch[x]=y;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint x;\n\t\tscanf(\"%d\",&x);\n\t\tif(x!=lst+1)\n\t\t{\n\t\t\tif(lst+1)v.push_back(lst+1);\n\t\t\tv.push_back(x);\n\t\t}\n\t\tlst=x;\n\t\tmx=lst+1;\n\t}\n\tv.push_back(lst+1);\n\tf[1]=true;\n\tfor(int i=2;i<=mx;i++)\n\t{\n\t\tif(!f[i])prm[++sz]=i;\n\t\tfor(int j=1;j<=sz;j++)\n\t\t{\n\t\t\tif(prm[j]*i>mx)break;\n\t\t\tf[prm[j]*i]=true;\n\t\t\tif(i%prm[j]==0)break;\n\t\t}\n\t}\n\tl=v.size();\n\tfor(int i=0;i<l;i++)\n\t{\n\t\tmatch[i]=-1;\n\t\tif(v[i]&1)mo++;else me++;\n\t\tfor(int j=i+1;j<l;j++)\n\t\t{\n\t\t\tif(v[j]-v[i]!=2 && !f[v[j]-v[i]])\n\t\t\t{\n\t\t\t\tok[i].push_back(j);\n\t\t\t\tok[j].push_back(i);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<l;i++)\n\t{\n\t\tmemset(vis,0,sizeof(vis));\n\t\tif(bp(i,i+1))res++;\n\t}\n\tprintf(\"%d\",res+((me-res)/2+(mo-res)/2)*2+((me-res)%2)*3);\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=110;\nbool pd(int k){\n\tif(k==1) return 0;\n\tint sk=sqrt(k);\n\tfor(int i=2;i<=sk;i++) if(!(k%i)) return 0;\n\treturn 1;\n}\nint n,b[N<<1],link[N],e[N<<1],o[N<<1];\nbool g[N][N],vis[N];\nbool dfs(int k){\n\tfor(int i=1;i<=e[0];i++){\n\t\tif(g[k][i]&&!vis[i]){\n\t\t\tvis[i]=1;\n\t\t\tif(link[i]||dfs(link[i])){\n\t\t\t\tlink[i]=k;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nint main(){\n\tint tx;\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++){\n\t\tscanf(\"%d\",&tx);\n\t\tif(b[b[0]]==tx) b[b[0]]++;\n\t\telse b[++b[0]]=tx,b[++b[0]]=tx+1;\n\t}\n\tfor(int i=1;i<=b[0];i++){\n\t\tif(b[i]&1) o[++o[0]]=b[i];\n\t\telse e[++e[0]]=b[i];\n\t}\n\tfor(int i=1;i<=o[0];i++)\n\t\tfor(int j=1;j<=e[0];j++){\n\t\t\tif(pd(abs(o[i]-e[j]))) g[i][j]=1;\n\t\t}\n\tint k=0;\n\tfor(int i=1;i<=o[0];i++){\n\t\tmemset(vis,0,sizeof(vis));\n\t\tif(dfs(i)) k++;\n\t}\n//\tcout<<k<<endl;\n\tcout<<k+((o[0]-k)/2+(e[0]-k)/2)*2+((e[0]-k)%2)*3<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cassert>\n#include <cctype>\n#include <algorithm>\nusing namespace std;\ntypedef long long lint;\n#define cout cerr\n#define ni (next_num<int>())\ntemplate<class T>inline T next_num(){\n\tT i=0;char c;\n\twhile(!isdigit(c=getchar())&&c!='-');\n\tbool flag=c=='-';\n\tflag?c=getchar():0;\n\twhile(i=i*10-'0'+c,isdigit(c=getchar()));\n\treturn flag?-i:i;\n}\ntemplate<class T1,class T2>inline void apmax(T1 &a,const T2 &b){if(a<b)a=b;}\ntemplate<class T1,class T2>inline void apmin(T1 &a,const T2 &b){if(b<a)a=b;}\nconst int N=210,M=10000010;\nint prime[M],ps=0;\nbool isp[M];\ninline void gmath(int n){\n\tmemset(isp,true,sizeof(isp));\n\tisp[1]=false;\n\tfor(int i=2;i<=n;i++){\n\t\tif(isp[i]){\n\t\t\tprime[ps++]=i;\n\t\t}\n\t\tfor(int j=0,cur=2;j<ps&&i*cur<=n;cur=prime[++j]){\n\t\t\tisp[i*cur]=false;\n\t\t\tif(i%cur==0)break;\n\t\t}\n\t}\n}\nint x[N];\nbool vis[N];\nint main(){\n\tint n=ni,xs=0,cnt=0;\n\tfor(int i=1;i<=n;i++){\n\t\tint cur=ni;\n\t\tif(cur==x[xs]){\n\t\t\tx[xs]++;\n\t\t}else{\n\t\t\tx[++xs]=cur,x[++xs]=cur+1;\n\t\t}\n\t}\n\tgmath(x[xs]);\n\tmemset(vis,0,sizeof(vis));\n\tfor(int i=1,j;i<=xs;i++){\n\t\tif(!vis[i]){\n\t\t\tfor(j=i+1;j<=xs;j++){\n\t\t\t\tif(!vis[j]&&isp[x[j]-x[i]])break;\n\t\t\t}\n\t\t\tif(j<=xs){\n\t\t\t\tvis[i]=vis[j]=true;\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\",xs+(cnt&1)-cnt);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;\nconst int mx=1e7;\nbool aa[mx+10],v[mx+10],mp[1010][1010];\nint n,pr[2000010],a[1010],b[1010],bb[1010],c[1010],ans,mlby;\nvoid ycl(){\n\tint i,j;\n\tfor(i=2;i<=mx;i++){\n\t\tif(!v[i])pr[++pr[0]]=i;\n\t\tfor(j=1;j<=pr[0]&&i*pr[j]<=mx;j++){\n\t\t\tv[i*pr[j]]=1;\n\t\t\tif(i%pr[j]==0)break;\n\t\t}\n\t}\n\tv[1]=v[2]=1;\n}\nint pd(int x){\n\tint i;\n\tif(bb[x])return 0;\n\tbb[x]=1;\n\tfor(i=1;i<=b[0];i++)if(mp[x][i]&&(!c[i]||pd(c[i]))){\n\t\tc[i]=x;return 1;\n\t}\n\treturn 0;\n}\nint main(){\n\tint i,x,j;\n\tycl();\n\tscanf(\"%d\",&n);\n\tfor(i=1;i<=n;i++){\n\t\tscanf(\"%d\",&x);\n\t\taa[x]=1;\n\t}\n\tfor(i=1;i<=mx+1;i++)if(aa[i]!=aa[i-1]){\n\t\tif(i%2)a[++a[0]]=i;\n\t\t else b[++b[0]]=i;\n\t}\n\tfor(i=1;i<=a[0];i++)\n\t for(j=1;j<=b[0];j++)if(!v[abs(a[i]-b[j])])mp[i][j]=1;\n\tfor(i=1;i<=a[0];i++){\n\t\tfor(j=1;j<=a[0];j++)bb[j]=0;\n\t\tif(pd(i))ans++;\n\t}\n\tmlby=ans+2*((a[0]-ans)/2+(b[0]-ans)/2);\n\tif((a[0]-ans)%2)mlby+=3;\n\tprintf(\"%d\",mlby);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pp;\ntypedef pair<ll,ll> pll;\nvoid read(int& x){ scanf(\"%d\",&x); }\nvoid read(ll& x){ scanf(\"%lld\",&x); }\ntemplate<typename T,typename... Args>\nvoid read(T& a,Args&... b){ read(a); read(b...); }\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define eb emplace_back\n#define x first\n#define y second\n \nint n;\nint p[210];\n \nvoid in(){\n\tint t; read(t);\n\tint last;\n\tread(last);\n\tp[++n] = last;\n\tfor(;--t;){\n\t\tint x; read(x);\n\t\tif(last+1 < x){\n\t\t\tp[++n] = last+1;\n\t\t\tp[++n] = x;\n\t\t}\n\t\tlast = x;\n\t}\n\tp[++n] = last+1; assert(n % 2 == 0);\n}\n \nbool is_prime(int x){\n\tif(x==1) return 0;\n\tif(x==2) return 0;\n\tfor(int i=2; i*i<=x; ++i) if(x%i==0) return 0;\n\treturn 1;\n}\nvector<int>edge[210];\nint vis[210];\nint rev[210];\n \nbool dfs(int x){\n\tif(vis[x]) return 0;\n\tvis[x]=1;\n\tfor(int y:edge[x]){\n\t\tif(!rev[y] || dfs(rev[y])){\n\t\t\trev[y]=x;\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n \nbool aug(){\n\tfor(int i=1; i<=n; ++i){\n\t\tfill(vis+1, vis+n+1, 0);\n\t\tif(dfs(i)) return 1;\n\t}\n\treturn 0;\n}\n \nint main()\n{\n\tin();\n\tint oc=0, ec=0;\n\tfor(int i=1; i<=n; ++i){\n\t\t((p[i]%2)?oc:ec)++;\n\t\tfor(int j=i+1; j<=n; ++j){\n\t\t\tif(is_prime(p[j]-p[i])){\n\t\t\t\tint a=i, b=j;\n\t\t\t\tif(p[a]%2) swap(a, b);\n\t\t\t\tedge[a].pb(b);\n\t\t\t}\n\t\t}\n\t}\n\tint mm = 0;\n\twhile(aug()) ++mm;\nassert(oc %2 == ec %2);\nassert(mm <= oc);\nassert(mm <= ec);\n\tint ans = 2e9;\n\tfor(int pu=0; pu<=mm; ++pu){\n\t\tint cur = 0;\n\t\tcur += (oc-pu)/2*2;\n\t\tcur += (ec-pu)/2*2;\n\t\tcur += ((oc-pu)%2)*((ec-pu)%2)*3;\n\t\tcur += pu;\n\t\tans = min(ans, cur);\n\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <climits>\n#include <queue>\n#include <algorithm>\n\nusing std::queue;\nusing std::min;\n\nconst int MAXX=1e7+5,MAXN=1001;\nint n,cnt_x,cnt_y;\nint x_id[MAXN],y_id[MAXN];\nbool up[MAXX];\n\nstruct node{int he,iter,dis;}d[MAXN];\nstruct line{int to,nex,cap;}ed[MAXN*MAXN];\n\ninline bool is_odd_prm(int x){\n\tfor(int i=2;i*i<=x;++i){\n\t\tif(x%i==0) return false;\n\t}\n\treturn true;\n}\n\ninline void addE(int u,int v,int cap){\n\tstatic int cnt=1;\n\ted[++cnt]=(line){v,d[u].he,cap};\n\td[u].he=cnt;\n}\n\ninline int revE(int i){return i^1;}\n\ninline bool BFS(int s,int t,int n){\n\tfor(int i=1;i<=n;++i)\n\t\td[i].dis=-1;\n\tstatic queue<int> q;\n\td[s].dis=0;\n\tq.push(s);\n\tint u;\n\twhile(q.size()){\n\t\tu=q.front();\n\t\tq.pop();\n\t\tfor(int i=d[u].he,v;i;i=ed[i].nex){\n\t\t\tif(ed[i].cap==0) continue;\n\t\t\tv=ed[i].to;\n\t\t\tif(d[v].dis==-1){\n\t\t\t\td[v].dis=d[u].dis+1;\n\t\t\t\tq.push(v);\n\t\t\t}\n\t\t}\n\t}\n\treturn d[t].dis!=-1;\n}\n\nint aug(int u,int rest,const int t){\n\tif(u==t) return rest;\n\tint ret=0;\n\tfor(int &i=d[u].iter,v,cap,flow;i;i=ed[i].nex){\n\t\tv=ed[i].to,cap=ed[i].cap;\n\t\tif(d[v].dis!=d[u].dis+1 || cap==0)\n\t\t\tcontinue;\n\t\tflow=aug(v,min(cap,rest),t);\n\t\tif(flow==0)continue;\n\t\ted[i].cap-=flow,ed[revE(i)].cap+=flow;\n\t\tret+=flow,rest-=flow;\n\t\tif(rest==ret)break;\n\t}\n\tif(ret==0) d[u].dis=-1;\n\treturn ret;\n}\n\ninline int Dinic(int s,int t,int n){\n\tint ret=0;\n\twhile(BFS(s,t,n)){\n\t\tfor(int i=1;i<=n;++i)\n\t\t\td[i].iter=d[i].he;\n\t\tret+=aug(s,INT_MAX,t);\n\t}\n\treturn ret;\n}\n\ninline void build(){\n\tfor(int i=1;i<=cnt_x;++i){\n\t\tfor(int j=1,v;j<=cnt_y;++j){\n\t\t\tif(is_odd_prm(abs(x_id[i]-y_id[j]))){\n\t\t\t\tv=j+cnt_x;\n\t\t\t\taddE(i,v,INT_MAX),addE(v,i,0);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=1,s=(cnt_x+cnt_y)|1;i<=cnt_x;++i)\n\t\taddE(s,i,1),addE(i,s,0);\n\tfor(int i=1,u,t=cnt_x+cnt_y+2;i<=cnt_y;++i){\n\t\tu=cnt_x+i;\n\t\taddE(u,t,1),addE(t,u,0);\n\t}\n}\n\nint main(){\n\tscanf(\"%d\",&n);\n\tint x;\n\tfor(int i=1;i<=n;++i){\n\t\tscanf(\"%d\",&x);\n\t\tup[x]=true;\n\t}\n\tfor(int i=1;i<=x+1;++i){\n\t\tif(up[i]!=up[i-1])\n\t\t\ti&1 ? x_id[++cnt_x]=i:y_id[++cnt_y]=i;\n\t}\n\tbuild();\n\tint k=Dinic((cnt_x+cnt_y)|1,cnt_x+cnt_y+2,cnt_x+cnt_y+2);\n\tprintf(\"%d\",k+((((cnt_x-k)>>1)+((cnt_y-k)>>1))<<1)+(cnt_x-k)%2*3);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n\nint bipartiteMatching(const vector<vector<int> > &g) {  //g: left side\n\tint nleft = g.size(), nright = 0;\n\tfor (auto es = g.begin(); es != g.end();es++) if (!es->empty()) nright = max(nright, *max_element(es->begin(), es->end()) + 1);\n\tvector<int> matchL(nleft, -1), matchR(nright, -1), prev(nleft), seen(nleft, -1);\n\tfor (int i = 0; i < nleft; i++) {\n\t\tvector<int> stk; stk.push_back(i);\n\t\tseen[i] = i; prev[i] = -1;\n\t\twhile (!stk.empty()) {\n\t\t\tint v = stk.back(); stk.pop_back();\n\t\t\tfor (auto ui = g[v].begin(); ui != g[v].end();ui++) {\n\t\t\t\tint u = *ui;\n\t\t\t\tint j = matchR[u];\n\t\t\t\tif (j == -1) {\n\t\t\t\t\twhile (v != -1) {\n\t\t\t\t\t\tmatchR[u] = v;\n\t\t\t\t\t\tswap(u, matchL[v]);\n\t\t\t\t\t\tv = prev[v];\n\t\t\t\t\t}\n\t\t\t\t\tgoto break_;\n\t\t\t\t}\n\t\t\t\telse if (seen[j] < i) {\n\t\t\t\t\tseen[j] = i; prev[j] = v;\n\t\t\t\t\tstk.push_back(j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\tbreak_:;\n\t}\n\treturn (int)matchL.size() - count(matchL.begin(), matchL.end(), -1);\n}\n\n#define MAX 10000002\n\nint n;\n\nbool use[MAX];\n\nvector<int> v[2];\n\n\nset<int> s;\n\nint main(){\n\tcin >> n;\n\tfor (int i = 0; i < n; i++){\n\t\tint x;\n\t\tscanf(\"%d\", &x);\n\t\ts.insert(x);\n\t}\n\tfor (auto it = s.begin(); it != s.end();it++){\n\t\tint ich = (*it);\n\t\tif (!s.count(ich - 1)){\n\t\t\tv[(ich - 1) & 1].push_back(ich - 1);\n\t\t}\n\t\tif (!s.count(ich + 1)){\n\t\t\tv[ich & 1].push_back(ich);\n\t\t}\n\t}\n\tfor (int i = 2; i < MAX; i++){\n\t\tif (use[i] == false){\n\t\t\tfor (int j = i * 2; j < MAX; j++){\n\t\t\t\tuse[j] = true;\n\t\t\t}\n\t\t}\n\t}\n\tuse[0] = use[1] = use[2] = true;\n\tvector<vector<int> > g(v[0].size());\n\tfor (int j = 0; j < v[0].size(); j++){\n\t\tfor (int k = 0; k < v[1].size(); k++){\n\t\t\tif (!use[abs(v[1][k] - v[0][j])]){\n\t\t\t\tg[j].push_back(k);\n\t\t\t}\n\t\t}\n\t}\n\tint num = bipartiteMatching(g);\n\tint f = ((v[0].size() - num) / 2)*2;\n\tf += num;\n\tf += ((v[1].size() - num) / 2) * 2;\n\tif ((v[0].size()-num) & 1){\n\t\tf += 3;\n\t}\n\tcout << f << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <algorithm>\n#include <queue>\n#include <vector>\n#include <stack>\n#include <cmath>\n#include <memory.h>\n#include <iomanip>\n#include <cassert>\nusing namespace std;\n\n#define maxn 202\n#define FOR(i, l, r) for (int i=l; i<=r; ++i)\n#define FORD(i, r, l) for (int i=r; i>=l; --i)\n#define REP(i, r) for (int i=0; i<(int)r; ++i)\n#define REPD(i, r) for (int i=(int)r-1; i>=0; --i)\n#define fi first\n#define se second\n#define mk make_pair\n#define nil NULL\n#define y0 y902\n#define y1 y232\n#define x0 x92\n#define x1 x899\n#define next asdfa\n#define sz size\n#define Debug(X) {cerr << #X << \" = \" << X << '\\n';}\n#define PR(A, n) {cerr << #A << \" = \"; FOR(i, 1, n) cerr << A[i] << ' '; cerr << '\\n';}\n#define PR0(A, n) {cerr << #A << \" = \"; REP(i, n) cerr << A[i] << ' '; cerr << '\\n';}\ntypedef long long ll;\ntypedef double db;\ntypedef pair<db, db> dd;\ntypedef pair<int, int> ii;\ntypedef vector<int> vi;\nconst int inf = 1e9;\ntemplate<class T> int getbit(T x, int pos) {return (x>>(pos-1)) & 1;}\ntemplate<class T> void turn_on(T &x, int pos) {x = x | ((T)1<<(pos-1));}\ntemplate<class T> void turn_off(T &x, int pos) {x = x & ~((T)1<<(pos-1));}\ntemplate<class T> T sqr(T a) {return a*a;}\n\nint n, assigned[maxn], visited[maxn], t;\nvector<int> a[maxn], even, odd;\n\nint visit(int u) {\n    if (visited[u]!=t) visited[u] = t;\n    else return 0;\n    REP(i, a[u].sz()) {\n        int v = a[u][i];\n        if (!assigned[v] || visit(assigned[v])) {\n            assigned[v] = u;\n            return 1;\n        }\n    }\n    return 0;\n}\n\nint findMaximumMatching() {\n    int cnt = 0;\n    REP(i, even.sz()) {\n        ++t;\n        cnt += visit(i);\n    }\n    return cnt;\n}\n\nbool isPrime(int a) {       ///notice that function will return false if a=2\n    if (a<=2) return false;\n    FOR(i, 2, sqrt(a)) {\n        if (a%i==0) return false;\n    }\n    return true;\n}\n\nint main() {\n    freopen(\"prflip.inp\", \"r\", stdin);\n    //freopen(\"prflip.ans\", \"w\", stdout);\n    //ios::sync_with_stdio(0); cin.tie(0);\n    scanf(\"%d\", &n);\n    int prev = -1;\n    FOR(i, 1, n) {\n        int x; scanf(\"%d\", &x);\n        if (x!=prev+1) {\n            if (prev!=-1 && (prev+1)%2==0) even.push_back(prev+1);\n            else if (prev!=-1) odd.push_back(prev+1);\n            if (x%2==0) even.push_back(x);\n            else odd.push_back(x);\n        }\n        prev = x;\n    }\n    if ((prev+1)%2==0) even.push_back(prev+1);\n    else odd.push_back(prev+1);\n    REP(i, even.sz()) REP(j, odd.sz()) {\n        if (isPrime(abs(even[i]-odd[j])))\n            a[i].push_back(j);\n    }\n    int k = findMaximumMatching(), res = inf;\n    assert(even.sz()%2==odd.sz()%2);\n    FOR(i, 0, k) {\n        if (((int)even.sz()-k)%2==0) res = min(res, k+((int)even.sz()-k)+((int)odd.sz()-k));\n        else res = min(res, k+((int)even.sz()-1-k)+((int)odd.sz()-1-k)+3);\n    }\n    printf(\"%d\", res);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nconst ull mod = 1e9 + 7;\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n\nstruct edge{\n    int to,cap,rev;\n};\n\nvector<edge> G[105];\nvector<int> check(105, 0);\n\nint dfs(int v, int t, int f){\n    if(v==t){return f;}\n    check[v]=1;\n    for(int i=0;i<G[v].size();i++){\n        edge &e = G[v][i];\n        if(check[e.to]==0 && e.cap > 0){\n            int ff =dfs(e.to,t,min(f,e.cap));\n            if(ff>0){\n                e.cap -= ff;\n                G[e.to][e.rev].cap += ff;\n                return ff;\n            }\n        }\n    }\n    return 0;\n}\n\nint maxflow(int s,int t){\n    int flow = 0;\n    while(1){\n        fill(check.begin(),check.end(),0);\n        int f = dfs(s,t,INT_MAX);\n        if(f==0){return flow;}\n        flow += f;\n    }\n}\n\nbool prime_check(ll X){\n    if(X<2) return false;\n    ll sqX = (int)sqrt(X)+1;\n    for(int i=2;i<sqX;i++){\n        if(X%i==0) return false;\n    }\n    return true;\n}\n\n\nint main(){\n    int N;\n    cin >> N;\n    ll x[N];\n    REP(i, N) cin >> x[i];\n    sort(x, x+N);\n    vector<ll> koma;\n    REP(i, N){\n        if(i==0||x[i]!=x[i-1]+1) koma.push_back(x[i]);\n        if(i==N-1||x[i+1]!=x[i]+1) koma.push_back(x[i]+1);\n    }\n    vector<ll> koma_even, koma_odd;\n    REP(i, koma.size()){\n        if(koma[i]%2==0){\n            koma_even.push_back(koma[i]);\n        }else{\n            koma_odd.push_back(koma[i]);\n        }\n    }\n    REP(i, koma_even.size()){\n        REP(j, koma_odd.size()){\n            ll dif = abs(koma_even[i]-koma_odd[j]);\n            if(prime_check(dif)){\n                int v1 = i;\n                int v2 = koma_even.size()+j;\n                G[v1].push_back((edge){v2, 1, G[v2].size()});\n                G[v2].push_back((edge){v1, 0, G[v1].size()-1});\n            }\n        }\n    }\n    REP(i, koma_even.size()){\n        int v1 = koma_even.size()+koma_odd.size();\n        int v2 = i;\n        G[v1].push_back((edge){v2, 1, G[v2].size()});\n        G[v2].push_back((edge){v1, 0, G[v1].size()-1});\n    }\n    REP(i, koma_odd.size()){\n        int v1 = koma_even.size()+i;\n        int v2 = koma_even.size()+koma_odd.size()+1;\n        G[v1].push_back((edge){v2, 1, G[v2].size()});\n        G[v2].push_back((edge){v1, 0, G[v1].size()-1});\n    }\n\n    int N1 = maxflow(koma_even.size()+koma_odd.size(), koma_even.size()+koma_odd.size()+1);\n    /*\n    printf(\"N1: %d\\n\", N1);\n    REP(i, koma.size()){\n        cout << koma[i] << endl;\n    }\n    */\n    int N2 = (koma_even.size()-N1)/2 + (koma_odd.size()-N1)/2;\n    int N3 = (koma_even.size()-N1)%2;\n    cout << N1+2*N2+3*N3 << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cstdlib>\nusing namespace std;\n\n#define re_ return\n#define in_ inline\n#define op_ operator\n#define inc(l, i, r) for(i=l; i<r; ++i)\n#define st_ static\ntypedef long long ll;\n\nconst int mxn=1<<7;\n\nint n, m, a[mxn], b[mxn<<1], cnt[2], h[mxn<<1];\nstruct edge{int v, o;} e[mxn<<2];\n\nin_ ll dP(ll a, ll b, ll p)\n{\n    st_ ll r;\n    for(r=1; b; a=a*a%p, b>>=1)\n        b&1? r=r*a%p: 0;\n    re_ r;\n}\n\nin_ char chk(ll a, ll p)\n{\n    st_ ll s, r, i;\n    for(r=p-1, s=0; ~r&1; ++s, r/=2);\n    if(i=dP(a, r, p), i==1 || i==p-1) re_ 1;\n    for(;s--;)\n        if((i=i*i%p)==p-1) re_ 1;\n    re_ 0;\n}\n\nin_ char isP(int p)\n{\n    if(p==2) re_ 1;\n    if(p==1 || ~p&1) re_ 0;\n    st_  int i;\n    inc(0, i, 32)\n        if(!chk(rand()%(p-2)+1, p))\n            re_ 0;\n    re_ 1;\n}\n\nin_ void aE(int u, int v)\n{\n    st_ int tot;\n    e[++tot]=(edge){v, h[u]}, u[h]=tot;\n}\n\nchar vis[mxn<<1];\nchar Hun(int u)\n{\n    st_ int f[mxn<<1];\n    int i, v;\n    for(i=u[h]; v=i[e].v; i=i[e].o)\n        if(!vis[v])\n            if(vis[v]=1, !f[v] || Hun(f[v]))\n            re_ f[v]=u, 1;\n    re_ 0;\n}\n\nint main()\n{\n    srand(998244353);\n    int i, j;\n    scanf(\"%d\", &n);\n    inc(0, i, n)\n        scanf(\"%d\", a+i);\n    inc(0, i, n)\n    {\n        if(!i || a[i]>a[i-1]+1)\n            b[++m]=a[i], ++cnt[a[i]&1];\n        if(i>n-2 || a[i]<a[i+1]-1)\n            b[++m]=a[i]+1, ++cnt[a[i]+1&1];\n    }\n    inc(1, i, m+1)\n        if(b[i]&1)\n            inc(1, j, m+1)\n                if(~b[j]&1 && isP(abs(b[i]-b[j])))\n                    aE(i, j);\n\n    j=0;\n    inc(1, i, m+1)\n        if(b[i]&1)\n            memset(vis, 0, sizeof(vis)),\n                j+=Hun(i);\n\n    printf(\"%d\\n\", cnt[0]+cnt[1]-j+(cnt[0]-j&1));\n//    printf(\"%d\\n\", m);\n//    for(;;) scanf(\"%d\", &i), printf(\"%d\\n\", isP(i));\n    re_ 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstruct hopcroft{\n\tvector<int> dist, pair_l, pair_r;\n\tvector<bool> seen;\n\tvector<vector<int>> to;\n\tint n1, n2;\n\thopcroft(int n1, int n2) : n1(n1), n2(n2){\n\t\tto.resize(n1);\n\t\tpair_l.assign(n1, -1);\n\t\tpair_r.assign(n2, -1);\n\t\tdist.resize(n1);\n\t\tseen.resize(n1);\n\t}\n\tvoid add_edge(int u, int v){\n\t\tto[u].push_back(v);\n\t}\n\tbool bfs(){\n\t\tfill(dist.begin(), dist.end(), -1);\n\t\tqueue<int> q;\n\t\tfor (int i = 0; i < n1; i++){\n\t\t\tif (pair_l[i] == -1){\n\t\t\t\tdist[i] = 0;\n\t\t\t\tq.push(i);\n\t\t\t}\n\t\t}\n\t\tbool reach_minus = false;\n\t\twhile (!q.empty()){\n\t\t\tint u = q.front();\n\t\t\tq.pop();\n\t\t\tfor (int adj : to[u]){\n\t\t\t\tint radj = pair_r[adj];\n\t\t\t\tif (radj == -1){\n\t\t\t\t\treach_minus = true;\n\t\t\t\t} else if (dist[radj] == -1){\n\t\t\t\t\tdist[radj] = dist[u] + 1;\n\t\t\t\t\tq.push(radj);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn reach_minus;\n\t}\n\tbool dfs(int u){\n\t\tseen[u] = true;\n\t\tfor (int adj : to[u]){\n\t\t\tint radj = pair_r[adj];\n\t\t\tif (radj == -1 || (!seen[radj] && dist[radj] == dist[u] + 1 && dfs(radj))){\n\t\t\t\tpair_l[u] = adj;\n\t\t\t\tpair_r[adj] = u;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\tint max_matching(){\n\t\tint res = 0;\n\t\twhile (bfs()){\n\t\t\tfill(seen.begin(), seen.end(), false);\n\t\t\tfor (int i = 0; i < n1; i++)\n\t\t\t\tif (pair_l[i] == -1 && dfs(i))\n\t\t\t\t\tres++;\n\t\t}\n\t\treturn res;\n\t}\n};\nconst int lim = 10000002;\nnamespace sieve {\n        vector<bool> is_prime;\n        void sieve(int n){\n                if(is_prime.size() >= n + 1) \n                        return;\n                is_prime.assign(n + 1, true);\n                is_prime[0] = false;\n                is_prime[1] = false;\n                int sqrtn = sqrt(n) + 1;\n                for(int i = 2; i <= sqrtn; i++) if(is_prime[i]){\n                        for(int j = i * i; j <= n; j += i){\n                                is_prime[j] = false;\n                        }\n                }\n        }\n};\nint main(){\n\tsieve::sieve(lim);\n\tint n; cin >> n;\n\tbitset<lim> b;\n\tfor(int i = 0; i < n; i++){\n\t\tint x; cin >> x;\n\t\tb[x] = 1;\n\t}\n\tvector<int> p[2];\n\tfor(int i = 1; i < lim; i++){\n\t\tif(b[i] != b[i - 1]){\n\t\t\tp[i%2].push_back(i);\n\t\t}\n\t}\n\tint l0 = p[0].size(), l1 = p[1].size();\n\thopcroft ho(l0, l1);\n\tassert((l0 + l1) % 2 == 0);\n\tfor(int i = 0; i < l0; i++){\n\t\tfor(int j = 0; j < l1; j++){\n\t\t\tif(sieve::is_prime[abs(p[0][i] - p[1][j])]){\n\t\t\t\tho.add_edge(i, j);\n\t\t\t}\n\t\t}\n\t}\n\tint fl = ho.max_matching();\n\tint ans = fl + ((l0 - fl) / 2) * 2 + ((l1 - fl)/2) * 2 + ((((l0 - fl) % 2) + ((l1 - fl) % 2))/2) * 3;\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define fi first\n#define se second\n#define U unsigned\n#define P std::pair<int,int>\n#define LL long long\n#define pb push_back\n#define MP std::make_pair\n#define all(x) x.begin(),x.end()\n#define CLR(i,a) memset(i,a,sizeof(i))\n#define FOR(i,a,b) for(int i = a;i <= b;++i)\n#define ROF(i,a,b) for(int i = a;i >= b;--i)\n#define DEBUG(x) std::cerr << #x << '=' << x << std::endl\n\nconst int MAXN = 1e5 + 5;\nconst int MAXM = 1e7+5;\n\nnamespace Flow{\n\tstruct Edge{\n\t\tint to,w,nxt;\n\t}e[MAXN<<1];\n\tint head[MAXN],cur[MAXN],cnt=1;\n\tint dep[MAXN];\n\tint S,T,N;\n\n\tinline void add(int u,int v,int w){\n\t\te[++cnt] = (Edge){v,w,head[u]};head[u] = cnt;\n\t\te[++cnt] = (Edge){u,0,head[v]};head[v] = cnt;\n\t}\n\n\tinline bool bfs(){\n\t\tFOR(i,0,N) cur[i] = head[i],dep[i] = 0;\n\t\tstd::queue<int> q;q.push(S);dep[S] = 1;\n\t\twhile(!q.empty()){\n\t\t\tint v = q.front();q.pop();\n\t\t\tfor(int i = head[v];i;i = e[i].nxt){\n\t\t\t\tif(e[i].w > 0 && !dep[e[i].to]){\n\t\t\t\t\tdep[e[i].to] = dep[v] + 1;\n\t\t\t\t\tif(e[i].to == T) return true;\n\t\t\t\t\tq.push(e[i].to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn dep[T];\n\t}\n\n\tinline int dfs(int v,int flow=1e9){\n\t\tif(v == T) return flow;\n\t\tif(!flow) return 0;\n\t\tint ans = 0;\n\t\tfor(int &i = cur[v];i;i = e[i].nxt){\n\t\t\tif(e[i].w > 0 && dep[e[i].to] == dep[v] + 1){\n\t\t\t\tint t = dfs(e[i].to,std::min(flow,e[i].w));\n\t\t\t\tif(t>0){\n\t\t\t\t\tans += t;flow -= t;\n\t\t\t\t\te[i].w -= t;e[i^1].w += t;\n\t\t\t\t\tif(!flow) break;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n\n\tinline int Dinic(){\n\t\tint ans = 0,t = 0;\n\t\twhile(bfs()) while((t=dfs(S))) ans += t;\n\t\treturn ans;\n\t}\n};\nusing namespace Flow;\n\ninline bool isprime(int x){\n\tif(x == 1) return 0;\n\tint q = std::sqrt(1.0*x);\n\tFOR(i,2,q){\n\t\tif(!(x%i)) return 0;\n\t}\n\treturn 1;\n}\nstd::vector<int> s,t;\nint a[MAXM];\n\nint main(){\n//\tfreopen(\"../TestData/2.in\", \"r\", stdin);\n\tint n;scanf(\"%d\",&n);\n\tFOR(i,1,n){\n\t\tint x;scanf(\"%d\",&x);a[x] = 1;\n\t}\n\tFOR(i,1,MAXM-1){\n\t\tif(a[i]^a[i-1]){\n\t\t\tif(i&1) s.pb(i);\n\t\t\telse t.pb(i);\n\t\t}\n\t}\n\tN = s.size()+t.size();S = ++N;T = ++N;\n\tFOR(i,0,(int)s.size()-1) add(S,i+1,1);\n\tFOR(i,0,(int)t.size()-1) add(s.size()+i+1,T,1);\n\tFOR(i,0,(int)s.size()-1){\n\t\tFOR(j,0,(int)t.size()-1){\n\t\t\tif(isprime(std::abs(s[i]-t[j]))){\n\t\t\t\tadd(i+1,j+s.size()+1,1);\n\t\t\t}\n\t\t}\n\t}\n\tint ans = Dinic();\n\tprintf(\"%d\\n\",ans+(((int)s.size()-ans)/2)*2+(((int)t.size()-ans)/2)*2+3*(((int)s.size()-ans)&1));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <iomanip>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <unordered_set>\n#include <unordered_map>\n#include <bitset>\n#include <limits>\n#include <random>\n#include <complex>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cassert>\nusing namespace std;\n\n#define REP(i,n) for (int i = 0; i < n; i++)\ntemplate <class T> using reversed_priority_queue = priority_queue<T, vector<T>, greater<T> >;\ntypedef long long ll;\n\ntemplate <class T> struct FordFulkerson {\n\n    vector < pair < int,int > > maching;\n\n    struct  Edge {\n        int to,rev; T cap;\n        Edge(int t, int r, T c) : to(t), rev(r), cap(c) {}\n    };\n    \n    const T INF = numeric_limits<T>::max() / 2;\n    vector< vector< Edge > > G;\n    vector< bool > used;\n    FordFulkerson (int n) : G(n+1), used(n+1) {}\n   \n    void add_edge(int from, int to, T cap) {\n        G[from].push_back(Edge(to,(int)G[to].size(),cap));\n        G[to].push_back(Edge(from,(int)G[from].size()-1,0));\n    }\n    \n    T dfs(int v, int t, T f) {\n        if (v == t) return f;\n        used[v] = true;\n        for (int i = 0; i < G[v].size(); i++) {\n            Edge &e = G[v][i];\n            if (!used[e.to] && e.cap > 0) {\n                T d = dfs(e.to, t, min(f,e.cap));\n                if (d > 0) {\n                    if (v != 990 && e.to != 991) {\n                        maching.push_back(make_pair(v, e.to - 500));\n                    }\n                    e.cap -= d;\n                    G[e.to][e.rev].cap += d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n   \n    T get_max (int source, int sink) {\n        T flow = 0;\n        while (true) {\n            for (int i = 0; i < used.size(); i++) used[i] = false;\n            T f = dfs(source, sink, INF);\n            if (f == 0) return flow;\n            flow += f;\n        }\n    }\n    \n};\n\n\nbool isPrime(long long n) {\n    if (n <= 2) return false;\n    for (long long i = 2; i * i <= n; i++) if (n % i == 0) return false;\n    return true;\n}\n\nbool flip[10000010];\n\nint main ()\n{\n    int N;\n    cin >> N;\n    vector < int > x(N);\n    REP(i,N) cin >> x[i];\n\n    REP(i,N) {\n        flip[x[i]] = !flip[x[i]];\n        flip[x[i] + 1] = !flip[x[i] + 1];\n    }\n\n    vector < int > xt;\n    for (int i = 0; i < 10000010; i++) {\n        if (flip[i]) xt.push_back(i);\n    }\n\n    FordFulkerson < int > inst(1000);\n    for (int i = 0; i < xt.size(); i++) {\n        for (int j = i; j < xt.size(); j++) {\n            if (i == j) continue;\n            int diff = abs(xt[i] - xt[j]);\n            if (isPrime(diff)) {\n                inst.add_edge(i, j + 500, 1);\n            }\n        }\n    }\n    REP(i,N) {\n        inst.add_edge(990, i, 1);\n        inst.add_edge(i + 500, 991, 1);\n    }\n\n    int maxt = inst.get_max (990, 991);\n    vector < pair < int,int > > mc = inst.maching;\n    \n    REP(i,mc.size()) {\n        xt[mc[i].first]  = -1;\n        xt[mc[i].second] = -1;\n    }\n\n    int ans = maxt;\n    REP(i,xt.size()) {\n        REP(j,xt.size()) {\n            if (i == j) continue;\n            if (xt[i] == -1) continue;\n            if (xt[j] == -1) continue;\n            if (abs(xt[i] - xt[j]) % 2 == 0 && abs(xt[i] - xt[j]) != 2) {\n                xt[i] = -1;\n                xt[j] = -1;\n                ans += 2;\n            }\n        }\n    }\n\n    int sum = 0;\n    REP(i,xt.size()) {\n        if (xt[i] != -1) {\n            sum += 3;\n        }\n    }\n\n    ans += sum / 2;\n    cout << ans << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 1e7 + 700;\n\n\nint n,fre[maxn],p[220],ispr[maxn],even,odd,wrong;\nvector <int> edge[220],v2;\n\nbool fin(int u) {\n    if (fre[u]==wrong) return false;\n    fre[u]=wrong;\n    for (int j=0;j<edge[u].size();j++) {\n        int v=edge[u][j];\n       // cout<<u<<\" \"<<v<<endl;\n        if (p[v]==0 || fin(p[v])) {\n            p[v]=u;\n            return true;\n        }\n    }\n    return false;\n}\n\nint main() {\n   // freopen(\"in.txt\",\"r\",stdin);\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    ispr[1]=1;\n    for (int i=2;i<maxn;i++)\n        if (ispr[i]==0) {\n            for (int j=i+i;j<maxn;j+=i) ispr[j]=1;\n        }\n    cin>>n;\n    for (int i=1;i<=n;i++) {\n        int x;\n        cin>>x;\n        fre[x]^=1;\n        fre[x+1]^=1;\n    }\n    even=0; odd=0; wrong=2;\n    for (int i=0;i<maxn;i++)\n        if (fre[i]==1) {\n            v2.push_back(i);\n            if (i%2==0) even++;\n            else odd++;\n        }\n    // for (int i=0;i<v2.size();i++) cout<<v2[i]<<\" \";\n   //  cout<<endl;\n   // cout<<\" \" <<even<<\" \"<<odd<<endl;\n    for (int i=0;i<v2.size();i++)\n        for (int j=0;j<v2.size();j++)\n            if (v2[i]%2==0 && v2[j]%2==1 && ispr[ abs(v2[j] - v2[i]) ]==0) {\n                edge[i+1].push_back(j+1);\n                edge[j+1].push_back(i+1);\n            }\n    int cnt=0;\n    for (int i=0;i<v2.size();i++)\n     if (p[i+1]==0) {\n        wrong++;\n        p[i+1]=i+1;\n        //cout<<fin(i+1)<<endl;\n        cnt+=(fin(i+1));\n       // cout<<p[i+1]<<endl;\n      //  cout<<\"fuck\"<<endl;\n    }\n    cout<< cnt + ((even-cnt)/2 + (odd-cnt)/2) * 2 + (even%2)*3;\n}\n"
  },
  {
    "language": "C++",
    "code": "// warm heart, wagging tail,and a smile just for you!\n//                                                                     ███████████\n//                                                                   ███╬╬╬╬╬╬╬╬╬╬███\n//                                                                ███╬╬╬╬╬████╬╬╬╬╬╬███\n//                                            ███████████       ██╬╬╬╬╬████╬╬████╬╬╬╬╬██\n//                                      █████████╬╬╬╬╬████████████╬╬╬╬╬██╬╬╬╬╬╬███╬╬╬╬╬██\n//                               ████████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████████╬╬╬╬╬╬██╬╬╬╬╬╬╬██\n//                             ████╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████████╬╬╬╬╬╬╬╬╬╬╬██\n//                           ███╬╬╬█╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬███╬╬╬╬╬╬╬█████\n//                         ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬████████╬╬╬╬╬██\n//                       ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬╬╬╬╬╬███\n//                     ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬██\n//                 ████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████╬╬╬╬╬████\n//     █████████████╬╬╬╬╬╬╬╬██╬╬╬╬╬████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬██████\n//   ████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬██████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██████╬╬╬╬╬╬╬███████████╬╬╬╬╬╬╬╬██╬╬╬██╬╬╬██\n// ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████╬╬╬╬╬╬╬╬╬╬╬█╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬██\n// ██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬▓▓▓▓▓▓╬╬╬████╬╬████╬╬╬╬╬╬╬▓▓▓▓▓▓▓▓██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬███\n// ██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██████▓▓▓▓▓▓▓╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬▓▓▓▓▓▓▓██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬█████\n// ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████████\n//   ███╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██\n//       ██████████████  ████╬╬╬╬╬╬███████████████████████████╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████\n//                         ███████                           █████  ███████████████████  \n//\n#include \"bits/stdc++.h\"\nusing namespace std;\n#define INF (1<<30)\n#define LINF (1LL<<60)\n#define fs first\n#define sc second\n#define int long long\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define RFOR(i,a,b) for(int i = (b-1);i>=(a);--i)\n#define REP(i,n)  FOR(i,0,(n))\n#define RREP(i,n) RFOR(i,0,(n))\n#define ITR(itr,mp) for(auto itr = (mp).begin(); itr != (mp).end(); ++itr)\n#define RITR(itr,mp) for(auto itr = (mp).rbegin(); itr != (mp).rend(); ++itr)\n#define range(i,a,b) ((a)<=(i) && (i)<(b))\n#define debug(x)  cout << #x << \" = \" << (x) << endl\n#define SP << \" \" << \ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n#define MSB(x) (63-__builtin_clzll(x))\n#define pcnt(x) (__builtin_popcountll(x))\n#define parity(i,j) (i&(1LL<<j))\ntypedef pair<int,int> P;\ntypedef tuple<int,int,int> T;\ntypedef vector<int> vec;\ntypedef vector<vector<int>> mat;\n\nvector<bool> pri((int)1e7+10,false);\nvoid init(int x){\n  vector<bool> flag(x+1,false);\n  for(int i = 2; i <= x; i++){\n    if(flag[i]) continue;\n    pri[i] = true;\n    for(int j = i; j <= x; j+=i) flag[j] = true;\n  }\n}\n\nstruct max_flow{\n  public:\n  struct edge {int to,cap,rev;};\n  int V;\n  vector<vector<edge>> G;\n  vector<int> level,iter;\n\n  max_flow(int v){\n    V = v; G.resize(v);\n  }\n\n  void add_edge(int from, int to, int cap){\n    G[from].push_back((edge){to,cap,G[to].size()});\n    G[to].push_back((edge){from,0,G[from].size()-1});\n  }\n\n  void bfs(int s){\n    level.assign(V,-1);\n    queue<int> que;\n    level[s] = 0;\n    que.push(s);\n    while(!que.empty()){\n      int v = que.front();\n      que.pop();\n      REP(i,G[v].size()){\n        edge &e = G[v][i];\n        if(e.cap > 0 && level[e.to] < 0){\n          level[e.to] = level[v] + 1;\n          que.push(e.to);\n        }\n      }\n    }\n  }\n\n  int dfs(int v, int t, int f){\n    if(v == t) return f;\n    for(int &i = iter[v]; i < G[v].size(); i++){\n      edge &e = G[v][i];\n      if(e.cap > 0 && level[v] < level[e.to]){\n        int d = dfs(e.to,t,min(f,e.cap));\n        if(d > 0){\n          e.cap -= d;\n          G[e.to][e.rev].cap += d;\n          return d;\n        }\n      }\n    }\n    return 0;\n  }\n\n  int run(int s, int t){\n    int flow = 0;\n    while(1){\n      bfs(s);\n      if(level[t] < 0) return flow;\n      iter.assign(V,0);\n      int tmp;\n      while((tmp = dfs(s,t,INF)) > 0){\n        flow += tmp;\n      }\n    }\n  }\n};\n// INFが大きすぎないか？\n\nsigned main(){\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n\n  int n;\n  cin >> n;\n\n  vector<int> a(n);\n  REP(i,n) cin >> a[i], a[i]--;\n  \n  init((int)1e7+5);\n  pri[2] = false;\n\n  map<int,int> mp;\n  REP(i,n){\n    mp[a[i]] ^= 1;\n    mp[a[i]+1] ^= 1;\n  }\n\n  vec b;\n  ITR(itr,mp) if(itr->sc) b.push_back(itr->fs);\n\n  int m = b.size();\n\n  max_flow mf(m+2);\n  REP(i,m) REP(j,m){\n    if(b[i]%2) continue;\n    if(pri[abs(b[i]-b[j])]) mf.add_edge(i,j,1);\n  }\n\n  int e = 0, o = 0;\n  REP(i,m){\n    if(b[i]%2) mf.add_edge(i,m+1,INF), o++;\n    else mf.add_edge(m,i,INF), e++;\n  }\n\n  int mx = mf.run(m,m+1);\n  o -= mx; e -= mx;\n  cout << mx + (o/2+e/2)*2 + o%2*3 << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntemplate< typename T = int >\nT Hungarian(vector< vector< T > > &A)\n{\n  const T infty = numeric_limits< T >::max();\n  const int N = (int) A.size() - 1;\n  const int M = (int) A[0].size() - 1;\n  vector< int > P(M + 1), way(M + 1);\n  vector< T > U(N + 1, 0), V(M + 1, 0), minV;\n  vector< bool > used;\n\n  for(int i = 1; i <= N; i++) {\n    P[0] = i;\n    minV.assign(M + 1, infty);\n    used.assign(M + 1, false);\n    int j0 = 0;\n    while(P[j0] != 0) {\n      int i0 = P[j0], j1 = 0;\n      used[j0] = true;\n      T delta = infty;\n      for(int j = 1; j <= M; j++) {\n        if(used[j]) continue;\n        T curr = A[i0][j] - U[i0] - V[j];\n        if(curr < minV[j]) minV[j] = curr, way[j] = j0;\n        if(minV[j] < delta) delta = minV[j], j1 = j;\n      }\n      for(int j = 0; j <= M; j++) {\n        if(used[j]) U[P[j]] += delta, V[j] -= delta;\n        else minV[j] -= delta;\n      }\n      j0 = j1;\n    }\n    do {\n      P[j0] = P[way[j0]];\n      j0 = way[j0];\n    } while(j0 != 0);\n  }\n  return (-V[0]);\n}\n\n\nconst int LIM = (int) 1e7;\nbool prime[LIM + 1];\n\nint main()\n{\n  prime[0] = prime[1] = true;\n  for(int i = 2; i * i <= LIM; i++) {\n    if(!prime[i]) {\n      for(int j = i + i; j <= LIM; j += i) {\n        prime[j] = true;\n      }\n    }\n  }\n  prime[2] = true;\n\n  int N;\n  cin >> N;\n  vector< int > vs;\n  for(int i = 0; i < N; i++) {\n    int x;\n    cin >> x;\n    if(vs.empty() || vs.back() + 1 != x) {\n      vs.emplace_back(x - 1);\n      vs.emplace_back(x);\n    } else {\n      ++vs.back();\n    }\n  }\n\n  vector< int > latte, malta;\n  for(auto &p : vs) {\n    if(p & 1) latte.emplace_back(p);\n    else malta.emplace_back(p);\n  }\n\n  int ret = 0;\n\n  if(!latte.empty() && !malta.empty()) {\n    if(latte.size() > malta.size()) swap(latte, malta);\n    vector< vector< int > > mat(latte.size(), vector< int >(malta.size(), 0));\n    for(int i = 0; i < latte.size(); i++) {\n      for(int j = 0; j < malta.size(); j++) {\n        if(!prime[abs(latte[i] - malta[j])]) {\n          mat[i][j] = -1;\n        }\n      }\n    }\n    ret = -Hungarian(mat);\n  }\n\n  int beet1 = latte.size() - ret;\n  int beet2 = malta.size() - ret;\n  ret += beet1 / 2 * 2;\n  ret += beet2 / 2 * 2;\n  ret += beet1 % 2 * 3;\n  cout << ret << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<cstring>\n#include<map>\n#include<queue>\n#include<cmath>\nusing namespace std;\ntypedef long long ll;\nconst int N=5005,INF=~0u>>2;\nstruct Edge{int nxt,to;}edge[(N*N)<<3];\nint b[N<<1],n,head[N<<1],num_edge,vis[N<<1],lk[N<<1],even[N<<1],odd[N<<1],even_num,odd_num,ans,k,tot,tim;\nint read(){\n\tint x=0,f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-') f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn f*x;\n}\nvoid add_edge(int from,int to){\n\tedge[++num_edge].nxt=head[from];\n\tedge[num_edge].to=to;\n\thead[from]=num_edge;\n}\nbool find(int x){\n\tfor(int i=head[x];i;i=edge[i].nxt){\n\t\tif(vis[edge[i].to]!=tim){\n\t\t\tvis[edge[i].to]=tim;\n\t\t\tif(!lk[edge[i].to]||find(edge[i].to)){\n\t\t\t\tlk[edge[i].to]=x;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nbool check(int x){\n\tif(x==1) return 0;\n\tfor(int i=2;i*i<=x;++i){\n\t\tif(x%i==0) return 0;\n\t}\n\treturn 1;\n}\nint main(){\n//\tfreopen(\"ex.in\",\"r\",stdin);\n\tn=read();\n\tfor(int i=1;i<=n;++i) b[i]=read();b[0]=-1;\n\tfor(int i=1;i<=n;++i){\n\t\tif(b[i]!=b[i-1]+1){\n\t\t\tif(b[i]%2) odd[++odd_num]=b[i];\n\t\t\telse even[++even_num]=b[i];\n\t\t}\n\t\tif(b[i]+1!=b[i+1]){\n\t\t\tif((b[i]+1)%2) odd[++odd_num]=b[i]+1;\n\t\t\telse even[++even_num]=b[i]+1;\n\t\t}\n\t}\n\tfor(int i=1;i<=odd_num;++i){\n\t\tfor(int j=1;j<=even_num;++j){\n\t\t\tif(check(abs(even[j]-odd[i]))) add_edge(i,j);\n\t\t}\n\t}\n\tfor(int i=1;i<=odd_num;++i){\n\t\ttim++;\n\t\tif(find(i)) k++;\n\t}\n\tans=k+((even_num-k)/2+(odd_num-k)/2)*2+((odd_num-k)%2)*3;\n\tprintf(\"%d\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n#define N 11000000\n#define INF 0x3f3f3f3f\n#define M 7031004\nstruct node{\n\tint to,next,res;\n}q[M];\nint head[22003],ss,prm[N],dep[23104],ct,a[N],S,T,que[20310],h[20310],cir[20104];bool ip[N];\nvoid addedge(int x,int y,int r)\n{\n\tq[++ss]=(node){y,head[x],r};head[x]=ss;\n\tq[++ss]=(node){x,head[y],0};head[y]=ss;\n}\nbool bfs()\n{\n\tmemset(dep,0,sizeof(dep));\n\tmemcpy(cir,head,4*(T+10));\n\tdep[S]=1;\n\tint f=1,e=0;\n\tque[++e]=S;\n\twhile(f<=e)\n\t{\n\t\tint u=que[f++];\n\t\tfor (int j=head[u];~j;j=q[j].next)\n\t\t\tif (q[j].res&&!dep[q[j].to])\n\t\t\t{\n\t\t\t\tint t=q[j].to;\n\t\t\t\tdep[t]=dep[u]+1;\n\t\t\t\tque[++e]=t;\n\t\t\t}\n\t}\n\treturn dep[T]>0;\n}\nint dfs(int i,int flow)\n{\n\tif (i==T||!flow) return flow;\n\tint f,dist=0;\n\tfor (int &j=cir[i];~j;j=q[j].next)\n\t\tif (dep[q[j].to]==dep[i]+1&&q[j].res&&(f=dfs(q[j].to,min(q[j].res,flow-dist))))\n\t\t{\n\t\t\tdist+=f;\n\t\t\tq[j].res-=f;\n\t\t\tq[j^1].res+=f;\n\t\t}\n\treturn dist;\n}\nint dinic()\n{\n\tint ans=0;\n\twhile(bfs()) ans+=dfs(S,INF);\n\treturn ans;\n}\nint main()\n{\n\tint n,TT,c=0,ans=0,odd;\n\tscanf(\"%d\",&TT);\n\tip[1]=true;ip[0]=true;\n\tfor (int i=2;i<=10000000;++i)\n\t{\n\t\tif (!ip[i]) prm[++ct]=i;\n\t\tfor (int j=1,to;j<=ct&&(to=i*prm[j])<=10000000;++j)\n\t\t{\n\t\t\tip[to]=true;\n\t\t\tif (i%prm[j]==0) break;\n\t\t}\n\t}\n\tip[2]=true;\n\ta[0]=-INF;\n\twhile(TT--)\n\t{\n\t\tscanf(\"%d\",&n);c=0;ss=-1;odd=0;\n\t\tmemset(head,-1,sizeof(head));\n\t\tfor (int i=1;i<=n;++i)\n\t\t{\n\t\t\tscanf(\"%d\",&a[i]);\n\t\t\tif (a[i]!=a[i-1]+1) h[++c]=a[i];\n\t\t\th[a[i]==a[i-1]+1?c:++c]=a[i]+1;\n\t\t}\n\t\tT=c+1;\n\t\tfor (int i=1;i<=c;++i)\n\t\t\tif (h[i]&1)\n\t\t\t{\n\t\t\t\taddedge(S,i,1);++odd;\n\t\t\t\tfor (int j=1;j<=c;++j)\n\t\t\t\t\tif (!ip[abs(h[j]-h[i])]) addedge(i,j,1);\n\t\t\t}else addedge(i,T,1);\n\t\tans=dinic();\n\t\tc-=odd;odd-=ans;\n\t\tprintf(\"%d\\n\",ans+(odd/2*2)+(c-ans)/2*2+(odd&1?3:0));\n\t}\n\treturn 0;\n}\n\n//by qlwpc"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAX_P = 1e7 + 2000;\nbool p_check[MAX_P];\nint plist[MAX_P];\nint p_cnt;\nint a[200];\nvoid prime_init()\n{\n    memset(p_check, false, sizeof(p_check));\n    p_cnt = 0;\n    for (int i = 2; i <= MAX_P - 5; i++) {\n        if (!p_check[i]) plist[p_cnt++] = i;\n        for (int j = 0; j < p_cnt; j++) {\n            int x = plist[j];\n            if (i * x > MAX_P - 5) break;\n            p_check[i * x] = true;\n            if (i % x == 0) break;\n        }\n    }\n}\nint main() {\n    prime_init();\n    int ans = 0, n, pos = 1, x;\n    scanf(\"%d\", &n);\n    for (int i = 1; i <= n; i++) {\n        scanf(\"%d\", &a[i]);\n    }\n    while (true) {\n        if (pos > n) break;\n        else if (pos == n) {\n            ans += 3;\n            break;\n        }\n        else if (pos == n - 1) {\n            x = a[n] - a[n - 1];\n            if (x == 1) {\n                ans += 2;\n                break;\n            }\n            else if (x == 4) {\n                ans += 2;\n                break;\n            }\n            else if (p_check[x]) {\n                ans += 2;\n            }\n            else if (x % 2 == 0) {\n                ans += 4;\n            }\n            else ans += 6;\n            ans += 2;\n            break;\n        }\n        else {\n            x = a[pos + 1] - a[pos];\n            if (x == 1) {\n                if (a[pos + 2] - a[pos + 1] == 1) {\n                    ans++;\n                    pos += 3;\n                }\n                else {\n                    ans += 2;\n                    pos += 2;\n                }\n            }\n            else {\n                if (x == 4) {\n                ans += 2;\n                pos += 2;\n            }\n            else if (p_check[x]) {\n                ans += 2;\n            }\n            else if (x % 2 == 0) {\n                ans += 4;\n            }\n            else ans += 6;\n            if (a[pos + 2] - a[pos + 1] == 1) {\n                ans++;\n                pos += 3;\n            }\n            else {\n                a[pos + 1]++;\n                pos += 1;\n                ans++;\n            }\n            }\n        }\n    }\n    printf(\"%d\\n\", ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <array>\n#include <bitset>\n#include <cassert>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstring>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <locale>\n#include <iostream>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <sstream>\n#include <string>\n#include <tuple>\n#include <unordered_map>\n#include <unordered_set>\n#include <utility>\n#include <vector>\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\n\nusing namespace std;\n\nusing ll = long long;\nusing ld = long double;\n\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate <typename T> int len(const T &x) { return x.size(); }\n\ntemplate<typename T>\nvector<T> table(int n, T v) { return vector<T>(n, v); }\n\ntemplate <class... Args>\nauto table(int n, Args... args) {\n  auto val = table(args...);\n  return vector<decltype(val)>(n, move(val));\n}\n\nstruct yes_no : numpunct<char> {\n  string_type do_truename()  const { return \"YES\"; }\n  string_type do_falsename() const { return \"NO\"; }\n};\n\nclass BipartiteMatching {\n  int size;\n  vector<vector<int>> g;\n  vector<int> match;\n  vector<bool> used;\n  bool dfs(int v) {\n    used[v] = true;\n    for (int u: g[v]) {\n      int w = match[u];\n      if (w < 0 || (!used[w] && dfs(w))) {\n        match[v] = u;\n        match[u] = v;\n        return true;\n      }\n    }\n    return false;\n  }\npublic:\n  BipartiteMatching(int v) : size(v), g(v), match(v), used(v) {}\n  void add_edge(int u, int v) {\n    g[u].push_back(v);\n    g[v].push_back(u);\n  }\n  int maximum_matching(void) {\n    int res = 0;\n    fill(begin(match), end(match), -1);\n    for (int v = 0; v < size; ++v) {\n      if (match[v] >= 0) continue;\n      fill(begin(used), end(used), 0);\n      if (dfs(v)) ++res;\n    }\n    return res;\n  }\n};\n\nconst int Prime_N = 1024000 * 10;\n\nbitset<Prime_N> is_prime;\n\nvector<int> primes() {\n  is_prime.set();\n  is_prime[0] = false;\n  is_prime[1] = false;\n  for (int i = 2; i * i < Prime_N; ++i) {\n    if (is_prime[i]) {\n      for (int j = i * i; j < Prime_N; j += i) {\n        is_prime[j] = false;\n      }\n    }\n  }\n  vector<int> res;\n  for (int i = 2; i < Prime_N; ++i) {\n    if (is_prime[i]) res.push_back(i);\n  }\n  return res;\n}\n\nvoid add(vector<int> &v, int x) {\n  auto it = find(ALL(v), x);\n  if (it == end(v)) v.push_back(x);\n  else v.erase(it);\n}\n\nvoid solve(ll N, vector<ll> x) {\n  primes();\n  vector<int> v;\n  for (ll i: x) {\n    add(v, i);\n    add(v, i + 1);\n  }\n  sort(ALL(v));\n\n  BipartiteMatching mat(N);\n  REP(i,N) REP(j,N) {\n    if (v[i] % 2 == 0 && v[j] % 2 == 1) {\n      int d = abs(v[i] - v[j]);\n      if (d >= 3 && is_prime[d]) mat.add_edge(i, j);\n    }\n  }\n  int maxv = mat.maximum_matching();\n\n  int even = 0, odd = 0;\n  for (int i: v) {\n    if (i % 2 == 0) ++even; else ++odd;\n  }\n  int res = 0;\n  res += maxv;\n  odd -= maxv; even -= maxv;\n\n  res += even / 2 * 2;\n  res += odd / 2 * 2;\n  if (even % 2) res += 3;\n  cout << res << endl;\n}\n\nint main() {\n  locale loc(locale(), new yes_no);\n  cout << boolalpha << setprecision(12) << fixed;\n  cout.imbue(loc);\n\tll N;\n\tscanf(\"%lld\", &N);\n\tvector<ll> x(N-1+1);\n\tfor (int i = 0 ; i <= N-1 ; i++) {\n\t  scanf(\"%lld\", &x[i]);\n\t}\n\tsolve(N, x);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define REP(i,n) for(int i=0;i<n;i++)\n#define REP1(i,n) for(int i=1;i<=n;i++)\n#define SZ(i) int(i.size())\n#ifdef tmd\n#define IOS()\n#define debug(...) fprintf(stderr,\"%s - %d (%s) = \",__PRETTY_FUNCTION__,__LINE__,#__VA_ARGS__);_do(__VA_ARGS__);\ntemplate<typename T> void _do(T &&x){cerr<<x<<endl;}\ntemplate<typename T, typename ...S> void _do(T &&x, S &&...y){cerr<<x<<\", \";_do(y...);}\n#else\n#define IOS() ios_base::sync_with_stdio(0);cin.tie(0);\n#define endl '\\n'\n#define debug(...)\n#endif\n\nconst int MAXN = 202;\nconst int MAXC = 10000007;\nconst ll MOD = 1000000007;\n\nint n, a[MAXN];\nvector<int> b;\nvector<int> odd, even;\nvector<int> edg[MAXN];\n\nbool sieve[MAXC];\nvector<int> prime;\nvoid build_prime () {\n    for (int i=2; i<MAXC; i++) {\n        if (!sieve[i]) {\n            prime.emplace_back(i);\n        }\n        for (int j=0; j<SZ(prime)&&i*prime[j]<MAXC; j++) {\n            sieve[i*prime[j]] = true;\n            if (i % prime[j] == 0) {\n                break;\n            }\n        }\n    }\n}\n\nbool vis[MAXN];\nint yp[MAXN];\n\nbool match (int nd) {\n    if (vis[nd]) {\n        return false;\n    }\n    vis[nd] = true;\n    for (auto v : edg[nd]) {\n        if (yp[v] == -1 || match(yp[v])) {\n            yp[v] = nd;\n            return true;\n        }\n    }\n    return false;\n}\n/*********************GoodLuck***********************/\nint main () {\n    IOS();\n    build_prime();\n    sieve[1] = true;\n    cin >> n;\n    REP1 (i, n) {\n        cin >> a[i];\n    }\n\n    a[0] = -1;\n    REP1 (i, n) {\n        if (a[i] != a[i-1] + 1) {\n            b.emplace_back(a[i]);\n        }\n        if (a[i] != a[i+1] - 1) {\n            b.emplace_back(a[i]+1);\n        }\n    }\n\n    for (auto v : b) {\n        if (v & 1) {\n            odd.emplace_back(v);\n        } else {\n            even.emplace_back(v);\n        }\n    }\n\n    REP (i, SZ(odd)) {\n        REP (j, SZ(even)) {\n            if (!sieve[abs(odd[i] - even[j])]) {\n                edg[i].emplace_back(j);\n            }\n        }\n    }\n\n    memset(yp, -1, sizeof(yp));\n\n    int cnt = 0;\n    REP (i, SZ(odd)) {\n        memset(vis, 0, sizeof(vis));\n        if (match(i)) {\n            cnt++;\n        }\n    }\n\n    #ifdef tmd\n    debug(SZ(odd));\n    for (auto v : odd) {\n        cout << v << \" \";\n    }\n    cout << endl;\n\n    debug(SZ(even));\n    for (auto v : even) {\n        cout << v << \" \";\n    }\n    cout << endl;\n\n    debug(cnt);\n    #endif\n    cout << cnt + ((SZ(odd)-cnt)/2 + (SZ(even)-cnt)/2)*2 + (SZ(odd)-cnt)%2*3 << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntemplate<class T> inline void read(T &x){\n\tx=0; register char c=getchar(); register bool f=0;\n\twhile(!isdigit(c))f^=c=='-',c=getchar();\n\twhile(isdigit(c))x=x*10+c-'0',c=getchar(); if(f)x=-x;\n}\ntemplate<class T> inline void print(T x){\n\tif(x<0)putchar('-'),x=-x;\n\tif(x>9)print(x/10); putchar(x%10+'0');\n}\ntemplate<class T> inline void print(T x,char c){print(x),putchar(c);}\nconst int N=2e3+10,E=4e6+10,M=1e7+10;\nbool vis[M],b[M];\nint n,s,e,max,cnt,ans,flow,cnt0,cnt1,tot=2;\nint pre[N],cur[N],hed[N],dep[N],gap[N],a[N],pri[M/10],val[E],nxt[E],to[E];\nint query(int x){\n\tif(x==2||x==4)return 2;\n\tif(!vis[x])return 1;\n\tif(x&1)return 3;\n\treturn 2;\n}\nvoid init(int n){\n\tvis[1]=1;\n\tfor(int i=2;i<=n;i++){\n\t\tif(!vis[i]){pri[++cnt]=i;}\n\t\tfor(int j=1;j<=cnt&&i*pri[j]<=n;j++){\n\t\t\tvis[i*pri[j]]=1;\n\t\t\tif(i%pri[j]==0)break;\n\t\t}\n\t}\n}\nvoid add_edge(int u,int v){\n\tnxt[tot]=hed[u],to[tot]=v,val[tot]=1,hed[u]=tot++;\n\tnxt[tot]=hed[v],to[tot]=u,val[tot]=0,hed[v]=tot++;\n}\nint isap(){\n\tint u=s,res=0;gap[0]=e;\n\twhile(dep[s]<e){\n\t\tbool flag=1;\n\t\tfor(int&i=cur[u];i;i=nxt[i]){\n\t\t\tif(val[i]&&dep[to[i]]+1==dep[u]){pre[to[i]]=i,u=to[i];flag=0;break;}\n\t\t}\n\t\tif(flag){\n\t\t\tif(!--gap[dep[u]])break;\n\t\t\tdep[u]=e;\n\t\t\tfor(int i=hed[u];i;i=nxt[i]){\n\t\t\t\tif(val[i]&&dep[to[i]]+1<dep[u])dep[u]=dep[to[i]]+1,cur[u]=i;\n\t\t\t}\n\t\t\t++gap[dep[u]];\n\t\t\tif(u!=s)u=to[pre[u]^1];\n\t\t}\n\t\tif(u==e){\n\t\t\tfor(int i=pre[e];i;i=pre[to[i^1]])val[i]--,val[i^1]++;\n\t\t\tu=s,res++;\n\t\t}\n\t}\n\treturn res;\n}\nint main(){\n\t// freopen(\"oatmeal.in\",\"r\",stdin);\n\t// freopen(\"oatmeal.out\",\"w\",stdout);\n\tread(n),init(1e7);\n\tfor(int i=1;i<=n;i++)read(a[i]),max=std::max(max,a[i]+2);\n\tfor(int i=1;i<=n;i++)b[a[i]]=1; n=0;\n\tfor(int i=max;i;i--)b[i]^=b[i-1];\n\tfor(int i=1;i<=max;i++)if(b[i])a[++n]=i;\n\ts=n+1,e=n+2;\n\tfor(int i=1;i<=n;i++)(a[i]&1)?(++cnt1,add_edge(s,i)):(++cnt0,add_edge(i,e));\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=i+1;j<=n;j++)\n\t\t\tif(query(a[j]-a[i])==1){\n\t\t\t\t(a[i]&1)?add_edge(i,j):add_edge(j,i);\n\t\t\t\t// printf(\"> %d %d\\n\",i,j);\n\t\t\t}\n\t// for(int i=1;i<=n;i++)print(a[i],\" \\n\"[i==n]);\n\tans=flow=isap(),cnt0-=flow,cnt1-=flow; if(cnt1&1)ans+=3; ans+=((cnt0>>1)+(cnt1>>1))<<1;\n\t// printf(\"flow=%d cnt0=%d cnt1=%d\\n\",flow,cnt0,cnt1);\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define sz(x) ((int)(x).size())\n#define rep(i,a,b) for (int i=(a); i<(b); i++)\n#define per(i,a,b) for (int i=(b-1); i>=(a); i--)\n#define de(x) cout << #x << \" => \" << x << endl\nusing namespace std;\n\n#define fi first\n#define se second\n#define mp make_pair\ntypedef pair<int,int> pii;\n\n#define pb push_back\ntypedef vector<int> vi;\n\ntypedef long long ll;\ntypedef long double ld;\n\n///----------------------------------------------\nstruct Hug {\n    static const int Hug_N = 7 + 1000;\n    int nx, ny;\n    vi G[Hug_N];\n    int par[Hug_N];\n    bool vis[Hug_N];\n    ///init\n    void link(int a, int b) { G[a].pb(b); }\n    void init(int _nx, int _ny) {\n        nx = _nx; ny = _ny;\n        rep(i, 1, nx + 1) G[i].clear();\n    }\n    ///find\n    bool find(int u) {\n        rep(i, 0, sz(G[u])) {\n            int v = G[u][i]; if (vis[v]) continue;\n            for (vis[v] = true; !~par[v] || find(par[v]); ) return par[v] = u, true;\n        }\n        return false;\n    }\n    ///work\n    int work( ) {\n        int ret = 0;\n        rep(i, 1, ny + 1) par[i] = -1;\n        rep(i, 1, nx + 1) {\n            rep(k, 1, ny + 1) vis[k] = false;\n           // if (find(i)) ret++;\n        }\n        return ret;\n    }\n}   hug;\n///-----\nbool isP(int dig) {\n    if (dig < 2) return false;\n    for (int i = 2; i * i <= dig; i++)\n        if (dig % i == 0) return false;\n    return true;\n}\n///-----\nvi v[2]; void add(int dig) { v[dig&1].pb(dig); }\n///-----\nint main() {\n\n    ///freopen ( \"xx.in\" , \"r\" , stdin );\n\n    ///read\n    int n; cin >> n;\n    int pre = -1;\n    rep(i, 0, n) {\n        int dig; scanf(\"%d\",&dig);\n        if (dig != pre + 1) {\n            add(dig);\n            if (~pre) add(pre + 1);\n        }\n        pre = dig;\n    }\n    add(pre + 1);\n    //rep(i, 0, sz(v[0])) de(v[0][i]);\n    //rep(i, 0, sz(v[1])) de(v[1][i]);\n    /// 0 0 0 1 0 1\n\n    ///work\n    hug.init(sz(v[0]), sz(v[1]));\n    rep(i, 0, sz(v[0])) {\n        rep(j, 0, sz(v[1])) {\n            if (isP(abs(v[0][i] - v[1][j]) + 1)) hug.link(i + 1, j + 1);\n        }\n    }\n\n    ///print\n    int can = hug.work();\n    int ans = can;\n    ans += (sz(v[0]) - can) / 2 * 2;\n    ans += (sz(v[1]) - can) / 2 * 2;\n    if ((sz(v[0]) - can)&1 || (sz(v[1]) - can) & 1) ans += 3;\n    printf(\"%d\", ans);\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#define DREP(i, s, e) for(int i = s; i >= e ;i--)\n#define  REP(i, s, e) for(int i = s; i <= e ;i++)\n\n#define DEBUG fprintf(stderr, \"Passing [%s] in Line %d\\n\", __FUNCTION__, __LINE__)\n#define chkmax(a, b) a = max(a, b)\n#define chkmin(a, b) a = min(a, b)\n\n#include <iostream>\n#include <cstring>\n#include <cstdio>\n#include <bitset>\n\nusing namespace std;\nconst int maxn = 100 + 5 << 1, N = 1e7;\n\nint n, x[maxn];\n\nbitset <N + 5> notp, s;\nint p[N], p_cnt;\ninline void init()\n{\n\tnotp[1] = 1;\n\tREP(i, 2, N)\n\t{\n\t\tif (!notp[i]) p[++p_cnt] = i;\n\t\tREP(j, 1, p_cnt)\n\t\t{\n\t\t\tif (i * p[j] > N) break;\n\t\t\tnotp[i * p[j]] = 1;\n\t\t\tif (i % p[j] == 0) break;\n\t\t}\n\t}\n}\nint a[maxn], b[maxn], cntA, cntB;\nbitset <maxn> G[maxn];\n\nint match[maxn], vis[maxn];\nint dfs(int x)\n{\n\tREP(i, 1, cntB)\n\t\tif (G[x][i] && !vis[i])\n\t\t{\n\t\t\tvis[i] = 1;\n\t\t\tif (!match[i] || dfs(match[i])) return match[i] = x;\n\t\t}\n\treturn 0;\n}\n\nint main()\n{\n#ifdef CraZYali\n\tfreopen(\"F.in\", \"r\", stdin);\n\tfreopen(\"F.out\", \"w\", stdout);\n#endif\n\tinit();\n\tcin >> n;\n\tREP(i, 1, n)\n\t{\n\t\tscanf(\"%d\", x + i);\n\t\ts.flip(x[i]);\n\t}\n\tREP(i, 1, N + 1)\n\t\tif (s[i] != s[i-1]) i & 1 ? a[++cntA] = i : b[++cntB] = i;\n\tREP(i, 1, cntA)\n\t\tREP(j, 1, cntB)\n\t\tif (!notp[abs(a[i] - b[j])]) G[i][j] = 1;\n\tint ans(0), temp(0);\n\tREP(i, 1, cntA)\n\t{\n\t\tmemset(vis, 0, sizeof(vis));\n\t\ttemp += (dfs(i) > 0);\n\t}\n\tans += cntA - temp >> 1 << 1;\n\tans += cntB - temp >> 1 << 1;\n\tans += temp;\n\tif ((cntA & 1) ^ (temp & 1)) ans += 3;\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nbool notP[10000005];\n\nint prime[1000005], tot = 0;\n\nvoid getPrime() {\n    int n = 10000000;\n    for (int i = 2; i <= n; ++i) {\n        if (!notP[i])\n            prime[tot++] = i;\n        for (int j = 0; j < tot && i * prime[j] <= n; ++j) {\n            notP[i * prime[j]] = true;\n            if (i % prime[j] == 0)\n                break;\n        }\n    }\n}\n\nvector <int> A[2];\n\nvector <int> G[105];\n\nint mat[105], used[105], tag = 0;\n\nint dfs(int u) {\n    for (auto v : G[u]) {\n        if (used[v] == tag)\n            continue;\n        used[v] = tag;\n        if (mat[v] == -1 || dfs(mat[v])) {\n            mat[v] = u;\n            return 1;\n        }\n    }\n    return 0;\n}\n\nint main() {\n    getPrime();\n    int n, p = -1;\n    scanf(\"%d\", &n);\n    for (int i = 0; i < n; ++i) {\n        int x;\n        scanf(\"%d\", &x);\n        if (p != x - 1) {\n            if (p != -1)\n                A[(p + 1) & 1].push_back(p + 1);\n            A[x & 1].push_back(x);\n        }\n        p = x;\n    }\n    A[(p + 1) & 1].push_back(p + 1);\n    for (int i = 0; i < (int)A[0].size(); ++i) {\n        for (int j = 0; j < (int)A[1].size(); ++j) {\n            int d = abs(A[0][i] - A[1][j]);\n            if (d >= 3 && !notP[d])\n                G[i].push_back(j);\n        }\n    }\n    memset(mat, -1, sizeof(mat));\n    int k = 0;\n    for (int i = 0; i < (int)A[0].size(); ++i) {\n        ++ tag;\n        k += dfs(i);\n    }\n    int ans = k + (A[0].size() - k) / 2 * 2 + (A[1].size() - k) / 2 * 2;\n    if ((A[0].size() - k) % 2)\n        ans += 3;\n    printf(\"%d\\n\", ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//#pragma comment(linker, \"/stack:200000000\")\n//#pragma GCC optimize(\"Ofast\")\n//#pragma GCC optimize(3)\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//#pragma GCC target(\"sse3\",\"sse2\",\"sse\")\n//#pragma GCC target(\"avx\",\"sse4\",\"sse4.1\",\"sse4.2\",\"ssse3\")\n//#pragma GCC target(\"f16c\")\n//#pragma GCC optimize(\"inline\",\"fast-math\",\"unroll-loops\",\"no-stack-protector\")\n//#pragma GCC diagnostic error \"-fwhole-program\"\n//#pragma GCC diagnostic error \"-fcse-skip-blocks\"\n//#pragma GCC diagnostic error \"-funsafe-loop-optimizations\"\n//#pragma GCC diagnostic error \"-std=c++14\"\n#include \"bits/stdc++.h\"\n//#include \"ext/pb_ds/tree_policy.hpp\"\n//#include \"ext/pb_ds/assoc_container.hpp\"\n#define PB push_back\n#define PF push_front\n#define LB lower_bound\n#define UB upper_bound\n#define fr(x) freopen(x,\"r\",stdin)\n#define fw(x) freopen(x,\"w\",stdout)\n#define iout(x) printf(\"%d\\n\",x)\n#define lout(x) printf(\"%lld\\n\",x)\n#define REP(x,l,u) for(ll x = l;x<u;x++)\n#define RREP(x,l,u) for(ll x = l;x>=u;x--)\n#define complete_unique(a) a.erase(unique(a.begin(),a.end()),a.end())\n#define mst(x,a) memset(x,a,sizeof(x))\n#define all(a) begin(a),end(a)\n#define PII pair<int,int>\n#define PLL pair<ll,ll>\n#define MP make_pair\n#define lowbit(x) ((x)&(-(x)))\n#define lson (ind<<1)\n#define rson (ind<<1|1)\n#define se second\n#define fi first\n#define sz(x) ((int)x.size())\n#define EX0 exit(0);\n\ntypedef  long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ld;\nusing namespace std;\ntypedef vector<ll> VLL;\ntypedef vector<int> VI;\nconst int block_size = 320;\ntypedef complex<ll> point;\nconst ll mod = 1e9+7;\nconst ll inf = 1e9+7;\nconst ld eps = 1e-9;\nconst db PI = atan(1)*4;\ntemplate<typename T>\ninline int sign(const T&a) {if(a<0)return -1;if(a>0)return 1;return 0;}\nstring to_string(string s) {return '\"' + s + '\"';}string to_string(const char* s) {return to_string((string) s);}string to_string(bool b) {return (b ? \"true\" : \"false\");}template <typename A, typename B>string to_string(pair<A, B> p) {return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\";}template <typename A>string to_string(A v) {bool first = true;string res = \"{\";for (const auto &x : v) {if (!first) {res += \", \";}first = false;res += to_string(x);}res += \"}\";return res;}void debug_out() { cerr << endl; }template <typename Head, typename... Tail>void debug_out(Head H, Tail... T) {cerr << \" \" << to_string(H);debug_out(T...);}\n\n#ifndef ONLINE_JUDGE\n#define dbg(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define dbg(...) {}\n#endif\n\ntemplate<typename T,typename S>inline bool upmin(T&a,const S&b){return a>b?a=b,1:0;}\ntemplate<typename T,typename S>inline bool upmax(T&a,const S&b){return a<b?a=b,1:0;}\n\ntemplate<typename T> inline void in(T &x) {x = 0;T f = 1;char ch = getchar();while (!isdigit(ch)) {if (ch == '-') f = -1;ch = getchar();}while (isdigit(ch))  {x = x * 10 + ch - '0';ch = getchar();}x *= f;}\nll twop(int x) {return 1LL<<x;}\ntemplate<typename T>T MOD(T a, T m){a %= m;if (a < 0)a += m;return a;}\ntemplate<typename T>T inverse(T a, T m){a = MOD(a, m);if (a <= 1)return a;return MOD((1 - inverse(m, a) * m) / a, m);}template<typename A,typename B > inline void in(A&x,B&y) {in(x);in(y);}\ntemplate<typename A,typename B,typename C>inline void in(A&x,B&y,C&z) {in(x);in(y);in(z);}\ntemplate<typename A,typename B,typename C,typename D> inline void in(A&x,B&y,C&z,D&d) {in(x);in(y);in(z);in(d);}\ntemplate <typename T>T sqr(T x){return x*x;}\nll gcd(ll a,ll b){return b==0?a:gcd(b,a%b);}\nll fast(ll a,ll b,ll mod){ll ans = 1;while(b){if(b&1){b--;ans = ans * a % mod;}else{a = a * a % mod;b/=2;}}return ans%mod;}\n\n\ntypedef long long s64;\n\nconst int INF = 2147483647;\n\nconst int MaxN = 400;\nconst int MaxM = 79800;\n\ntemplate <class T>\ninline void tension(T &a, const T &b)\n{\n    if (b < a)\n        a = b;\n}\ntemplate <class T>\ninline void relax(T &a, const T &b)\n{\n    if (b > a)\n        a = b;\n}\ntemplate <class T>\ninline int size(const T &a)\n{\n    return (int)a.size();\n}\n\ninline int getint()\n{\n    char c;\n    while (c = getchar(), '0' > c || c > '9');\n    \n    int res = c - '0';\n    while (c = getchar(), '0' <= c && c <= '9')\n        res = res * 10 + c - '0';\n    return res;\n}\n\nconst int MaxNX = MaxN + MaxN;\n\nstruct edge\n{\n    int v, u, w;\n    \n    edge(){}\n    edge(const int &_v, const int &_u, const int &_w)\n    : v(_v), u(_u), w(_w){}\n};\n\nint n, m;\nedge mat[MaxNX + 1][MaxNX + 1];\n\nint n_matches;\ns64 tot_weight;\nint mate[MaxNX + 1];\nint lab[MaxNX + 1];\n\nint q_n, q[MaxN];\nint fa[MaxNX + 1], col[MaxNX + 1];\nint slackv[MaxNX + 1];\n\nint n_x;\nint bel[MaxNX + 1], blofrom[MaxNX + 1][MaxN + 1];\nvector<int> bloch[MaxNX + 1];\n\ninline int e_delta(const edge &e) // does not work inside blossoms\n{\n    return lab[e.v] + lab[e.u] - mat[e.v][e.u].w * 2;\n}\ninline void update_slackv(int v, int x)\n{\n    if (!slackv[x] || e_delta(mat[v][x]) < e_delta(mat[slackv[x]][x]))\n        slackv[x] = v;\n}\ninline void calc_slackv(int x)\n{\n    slackv[x] = 0;\n    for (int v = 1; v <= n; v++)\n        if (mat[v][x].w > 0 && bel[v] != x && col[bel[v]] == 0)\n            update_slackv(v, x);\n}\n\ninline void q_push(int x)\n{\n    if (x <= n)\n        q[q_n++] = x;\n    else\n    {\n        for (int i = 0; i < size(bloch[x]); i++)\n            q_push(bloch[x][i]);\n    }\n}\ninline void set_mate(int xv, int xu)\n{\n    mate[xv] = mat[xv][xu].u;\n    if (xv > n)\n    {\n        edge e = mat[xv][xu];\n        int xr = blofrom[xv][e.v];\n        int pr = find(bloch[xv].begin(), bloch[xv].end(), xr) - bloch[xv].begin();\n        if (pr % 2 == 1)\n        {\n            reverse(bloch[xv].begin() + 1, bloch[xv].end());\n            pr = size(bloch[xv]) - pr;\n        }\n        \n        for (int i = 0; i < pr; i++)\n            set_mate(bloch[xv][i], bloch[xv][i ^ 1]);\n        set_mate(xr, xu);\n        \n        rotate(bloch[xv].begin(), bloch[xv].begin() + pr, bloch[xv].end());\n    }\n}\ninline void set_bel(int x, int b)\n{\n    bel[x] = b;\n    if (x > n)\n    {\n        for (int i = 0; i < size(bloch[x]); i++)\n            set_bel(bloch[x][i], b);\n    }\n}\n\ninline void augment(int xv, int xu)\n{\n    while (true)\n    {\n        int xnu = bel[mate[xv]];\n        set_mate(xv, xu);\n        if (!xnu)\n            return;\n        set_mate(xnu, bel[fa[xnu]]);\n        xv = bel[fa[xnu]], xu = xnu;\n    }\n}\ninline int get_lca(int xv, int xu)\n{\n    static bool book[MaxNX + 1];\n    for (int x = 1; x <= n_x; x++)\n        book[x] = false;\n    while (xv || xu)\n    {\n        if (xv)\n        {\n            if (book[xv])\n                return xv;\n            book[xv] = true;\n            xv = bel[mate[xv]];\n            if (xv)\n                xv = bel[fa[xv]];\n        }\n        swap(xv, xu);\n    }\n    return 0;\n}\n\ninline void add_blossom(int xv, int xa, int xu)\n{\n    int b = n + 1;\n    while (b <= n_x && bel[b])\n        b++;\n    if (b > n_x)\n        n_x++;\n    \n    lab[b] = 0;\n    col[b] = 0;\n    \n    mate[b] = mate[xa];\n    \n    bloch[b].clear();\n    bloch[b].push_back(xa);\n    for (int x = xv; x != xa; x = bel[fa[bel[mate[x]]]])\n        bloch[b].push_back(x), bloch[b].push_back(bel[mate[x]]), q_push(bel[mate[x]]);\n    reverse(bloch[b].begin() + 1, bloch[b].end());\n    for (int x = xu; x != xa; x = bel[fa[bel[mate[x]]]])\n        bloch[b].push_back(x), bloch[b].push_back(bel[mate[x]]), q_push(bel[mate[x]]);\n    \n    set_bel(b, b);\n    \n    for (int x = 1; x <= n_x; x++)\n    {\n        mat[b][x].w = mat[x][b].w = 0;\n        blofrom[b][x] = 0;\n    }\n    for (int i = 0; i < size(bloch[b]); i++)\n    {\n        int xs = bloch[b][i];\n        for (int x = 1; x <= n_x; x++)\n            if (mat[b][x].w == 0 || e_delta(mat[xs][x]) < e_delta(mat[b][x]))\n                mat[b][x] = mat[xs][x], mat[x][b] = mat[x][xs];\n        for (int x = 1; x <= n_x; x++)\n            if (blofrom[xs][x])\n                blofrom[b][x] = xs;\n    }\n    calc_slackv(b);\n}\ninline void expand_blossom1(int b) // lab[b] == 1\n{\n    for (int i = 0; i < size(bloch[b]); i++)\n        set_bel(bloch[b][i], bloch[b][i]);\n    \n    int xr = blofrom[b][mat[b][fa[b]].v];\n    int pr = find(bloch[b].begin(), bloch[b].end(), xr) - bloch[b].begin();\n    if (pr % 2 == 1)\n    {\n        reverse(bloch[b].begin() + 1, bloch[b].end());\n        pr = size(bloch[b]) - pr;\n    }\n    \n    for (int i = 0; i < pr; i += 2)\n    {\n        int xs = bloch[b][i], xns = bloch[b][i + 1];\n        fa[xs] = mat[xns][xs].v;\n        col[xs] = 1, col[xns] = 0;\n        slackv[xs] = 0, calc_slackv(xns);\n        q_push(xns);\n    }\n    col[xr] = 1;\n    fa[xr] = fa[b];\n    for (int i = pr + 1; i < size(bloch[b]); i++)\n    {\n        int xs = bloch[b][i];\n        col[xs] = -1;\n        calc_slackv(xs);\n    }\n    \n    bel[b] = 0;\n}\ninline void expand_blossom_final(int b) // at the final stage\n{\n    for (int i = 0; i < size(bloch[b]); i++)\n    {\n        if (bloch[b][i] > n && lab[bloch[b][i]] == 0)\n            expand_blossom_final(bloch[b][i]);\n        else\n            set_bel(bloch[b][i], bloch[b][i]);\n    }\n    bel[b] = 0;\n}\n\ninline bool on_found_edge(const edge &e)\n{\n    int xv = bel[e.v], xu = bel[e.u];\n    if (col[xu] == -1)\n    {\n        int nv = bel[mate[xu]];\n        fa[xu] = e.v;\n        col[xu] = 1, col[nv] = 0;\n        slackv[xu] = slackv[nv] = 0;\n        q_push(nv);\n    }\n    else if (col[xu] == 0)\n    {\n        int xa = get_lca(xv, xu);\n        if (!xa)\n        {\n            augment(xv, xu), augment(xu, xv);\n            for (int b = n + 1; b <= n_x; b++)\n                if (bel[b] == b && lab[b] == 0)\n                    expand_blossom_final(b);\n            return true;\n        }\n        else\n            add_blossom(xv, xa, xu);\n    }\n    return false;\n}\n\nbool match()\n{\n    for (int x = 1; x <= n_x; x++)\n        col[x] = -1, slackv[x] = 0;\n    \n    q_n = 0;\n    for (int x = 1; x <= n_x; x++)\n        if (bel[x] == x && !mate[x])\n            fa[x] = 0, col[x] = 0, slackv[x] = 0, q_push(x);\n    if (q_n == 0)\n        return false;\n    \n    while (true)\n    {\n        for (int i = 0; i < q_n; i++)\n        {\n            int v = q[i];\n            for (int u = 1; u <= n; u++)\n                if (mat[v][u].w > 0 && bel[v] != bel[u])\n                {\n                    int d = e_delta(mat[v][u]);\n                    if (d == 0)\n                    {\n                        if (on_found_edge(mat[v][u]))\n                            return true;\n                    }\n                    else if (col[bel[u]] == -1 || col[bel[u]] == 0)\n                        update_slackv(v, bel[u]);\n                }\n        }\n        \n        int d = INF;\n        for (int v = 1; v <= n; v++)\n            if (col[bel[v]] == 0)\n                tension(d, lab[v]);\n        for (int b = n + 1; b <= n_x; b++)\n            if (bel[b] == b && col[b] == 1)\n                tension(d, lab[b] / 2);\n        for (int x = 1; x <= n_x; x++)\n            if (bel[x] == x && slackv[x])\n            {\n                if (col[x] == -1)\n                    tension(d, e_delta(mat[slackv[x]][x]));\n                else if (col[x] == 0)\n                    tension(d, e_delta(mat[slackv[x]][x]) / 2);\n            }\n        \n        for (int v = 1; v <= n; v++)\n        {\n            if (col[bel[v]] == 0)\n                lab[v] -= d;\n            else if (col[bel[v]] == 1)\n                lab[v] += d;\n        }\n        for (int b = n + 1; b <= n_x; b++)\n            if (bel[b] == b)\n            {\n                if (col[bel[b]] == 0)\n                    lab[b] += d * 2;\n                else if (col[bel[b]] == 1)\n                    lab[b] -= d * 2;\n            }\n        \n        q_n = 0;\n        for (int v = 1; v <= n; v++)\n            if (lab[v] == 0) // all unmatched vertices' labels are zero! cheers!\n                return false;\n        for (int x = 1; x <= n_x; x++)\n            if (bel[x] == x && slackv[x] && bel[slackv[x]] != x && e_delta(mat[slackv[x]][x]) == 0)\n            {\n                if (on_found_edge(mat[slackv[x]][x]))\n                    return true;\n            }\n        for (int b = n + 1; b <= n_x; b++)\n            if (bel[b] == b && col[b] == 1 && lab[b] == 0)\n                expand_blossom1(b);\n    }\n    return false;\n}\n\nvoid calc_max_weight_match()\n{\n    for (int v = 1; v <= n; v++)\n        mate[v] = 0;\n    \n    n_x = n;\n    n_matches = 0;\n    tot_weight = 0;\n    \n    bel[0] = 0;\n    for (int v = 1; v <= n; v++)\n        bel[v] = v, bloch[v].clear();\n    for (int v = 1; v <= n; v++)\n        for (int u = 1; u <= n; u++)\n            blofrom[v][u] = v == u ? v : 0;\n    \n    int w_max = 0;\n    for (int v = 1; v <= n; v++)\n        for (int u = 1; u <= n; u++)\n            relax(w_max, mat[v][u].w);\n    for (int v = 1; v <= n; v++)\n        lab[v] = w_max;\n    \n    while (match())\n        n_matches++;\n    \n    for (int v = 1; v <= n; v++)\n        if (mate[v] && mate[v] < v)\n            tot_weight += mat[v][mate[v]].w;\n}\nbool is_prime(int x){\n    if(x<=2)return 0;\n    for(int i = 2;i*i<=x;i++)if(x%i==0)return false;\n    return true;\n}\nint dis(int a,int b){\n    if(a>b)swap(a, b);\n    if(a == b)return 3;\n    if(is_prime(b-a))return 1;\n    if((b-a)%2 == 0)return 2;\n    return 3;\n}\nvector<int>critical;\n\nint gao()\n{\n    n = critical.size();\n   m = n*(n-1)/2;\n    \n    for (int v = 1; v <= n; v++)\n        for (int u = 1; u <= n; u++)\n            mat[v][u] = edge(v, u, 0);\n    \n    for(int v = 1;v<=n;v++){\n        for(int u = v+1;u<=n;u++){\n            mat[v][u].w = mat[u][v].w = 10-dis(critical[v-1], critical[u-1]);\n//            dbg(v,u,mat[v][u].w);\n        }\n    }\n//    exit(0);\n//    for (int i = 0; i < m; i++)\n//    {\n//        int v = getint(), u = getint(), w = getint();\n//        mat[v][u].w = mat[u][v].w = w;\n//    }\n\n    calc_max_weight_match();\n\n    printf(\"%lld\\n\", sz(critical)/2 * 10 - tot_weight);\n\n    return 0;\n}\n\nnamespace SOLVE {\n    map<int, int>mp;\n\n    void main(){\n        set<int>possible;\n        int n;cin>>n;\n        REP(i,0,n){\n            int x;in(x);\n            possible.insert(x);\n            possible.insert(x+1);\n            mp[x]++;\n        }\n        for(auto i:possible){\n            if((mp[i]-mp[i-1])%2)critical.PB(i);\n        }\n        gao();\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n    }\n}\n\n\nsigned main() {\n    \n    \n    \n    \n    int t = 1;\n//    in(t);\n    while(t--){\n        SOLVE::main();\n\n    }\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//#include \"stdafx.h\"\n#include <iostream>\n#include <set>\n#include <queue>\n#include <vector>\n#include <algorithm>\n#include <math.h>\n#include <cmath>\n#include <string>\n#include <cstring>\n#include <climits>\n#include <sstream>\n#include <iomanip>\n#include <map>\n#include <stack>\n#include <tuple>\n#include <numeric>\n#include <assert.h>\n#include <functional>\n#include <unordered_map>\n\nusing namespace std;\n\n/*-----------------------------------------------------------------------------\n　定義\n -------------------------------------------------------------------------------*/\n#define REP(i, n)\t\t\t\tfor (int (i) = 0 ; (i) < (int)(n) ; ++(i))\n#define REPN(i, m, n)\t\t\tfor (int (i) = m ; (i) < (int)(n) ; ++(i))\n#define INF\t\t\t\t\t\t2e9\n#define MOD\t\t\t\t\t\t(1000 * 1000 * 1000 + 7)\n#define Ceil(x, n)\t\t\t\t(((((x))+((n)-1))/n))\t\t/* Nの倍数に切り上げ割り算 */\n#define CeilN(x, n)\t\t\t\t(((((x))+((n)-1))/n)*n)\t\t/* Nの倍数に切り上げ */\n#define FloorN(x, n)\t\t\t((x)-(x)%(n))\t\t\t\t/* Nの倍数に切り下げ */\n#define IsOdd(x)\t\t\t\t(((x)&0x01UL) == 0x01UL)\t\t\t\n#define IsEven(x)\t\t\t\t(!IsOdd((x)))\t\t\t\t\t\t\n#define ArrayLength(x)\t\t\t(sizeof( x ) / sizeof( x[ 0 ]))\n#define\tMAX_QWORD\t\t\t\t((QWORD)0xFFFFFFFFFFFFFFFF)\n#define M_PI\t\t\t\t\t3.14159265358979323846\ntypedef long long\t\t\t\tll;\ntypedef unsigned long long int\tQWORD;\ntypedef pair<ll, ll>\t\t\tP;\n\n/*-----------------------------------------------------------------------------\n　処理\n -------------------------------------------------------------------------------*/\n// 枝定義\nstruct Edge\n{\n\tint\ttoIdx;\n\tint\trevIdx;\n\tint\tcap;\n\tEdge(){}\n\tEdge(int to, int rev, int capArg): toIdx(to), revIdx(rev), cap(capArg){}\n};\n\n// グラフ定義(二次元配列)\nusing Graph = vector<vector<Edge>>;\n \n// フォード・ファルカーソン\nclass FordFulkerson \n{\nprivate:\n\tint V;\n\tGraph G;\n\tvector<bool> isUsed;\n\nprivate:\n\tint dfs(int from, int sinkPos, int flow)\n\t{\n\t\tif (from == sinkPos) {\n\t\t\treturn flow;\n\t\t}\n\n\t\tint flowOne = 0;\n\t\tisUsed[from] = true;\n\t\tfor (Edge &edge : G[from]) {\n\t\t\tint to = edge.toIdx;\n\t\t\tif (!isUsed[to]) {\n\t\t\t\tif (0 < edge.cap) {\n\t\t\t\t\tflowOne = dfs(to, sinkPos, min(flow, edge.cap));\n\t\t\t\t\tif (0 < flowOne) {\n\t\t\t\t\t\tedge.cap -= flowOne;\n\t\t\t\t\t\tG[to][edge.revIdx].cap += flowOne;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn flowOne;\n\t}\n\npublic:\n\tFordFulkerson(int N)\n\t{\n\t\tG.resize(N);\n\t}\n\n\t// 枝を追加\n\tvoid AddEdge(int from, int to, int cap)\n\t{\n\t\tint revIdxTo = G[to].size();\n\t\tint revIdxFrom = G[from].size();\n\t\tG[from].emplace_back(to, revIdxTo, cap);\n\t\tG[to].emplace_back(from, revIdxFrom, 0);\n\t}\n\n\t// 最大フローを求める\n\tint GetMaxFlow(int startPos, int endPos)\n\t{\n\t\tint maxFlow = 0;\n\t\tV = (int)G.size();\n\t\tisUsed.resize(V);\n\t\tfor (;;) {\n\t\t\tfill(isUsed.begin(), isUsed.end(), false);\n\t\t\tint flowOne = dfs(startPos, endPos, (int)INF);\n\t\t\tif (flowOne == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmaxFlow += flowOne;\n\t\t}\n\t\treturn maxFlow;\n\t}\n};\n\n/* 素数判定 */\nbool isPrime(ll p) \n{\n\tfor (ll i = 2; i <= sqrt(p); i++) if (p % i == 0) return false;\n\treturn p > 1;\n}\n\nint main()\n{\n\tint N;\n\tcin >> N;\n\tvector<int> x(N);\n\tmap<int, int> y;\n\tREP(i, N) cin >> x[i];\n\tREP(i, N) {\n\t\ty[x[i]]++;\n\t\ty[x[i] + 1]++;\n\t}\n\n\tvector<int> odd;\n\tvector<int> even;\n\tfor (auto it = y.begin(); it != y.end(); it++) {\n\t\tif (IsOdd(it->second)) {\n\t\t\tif (IsEven(it->first)) {\n\t\t\t\teven.emplace_back(it->first);\n\t\t\t} else {\n\t\t\t\todd.emplace_back(it->first);\n\t\t\t}\n\t\t}\n\t}\n\n\t// 始点→偶数\n\tFordFulkerson res(4 * 1000);\n\tint start = 0;\n\tREP(i, even.size()) {\n\t\tres.AddEdge(start, 1000 + i, 1);\n\t}\n\t\n\t// 奇数→終点\n\tint end = 1;\n\tREP(i, odd.size()) {\n\t\tres.AddEdge(2000 + i, 1, 1);\n\t}\n\t\n\t// 偶数→奇数(素数)\n\tREP(i, even.size()) {\n\t\tREP(j, odd.size()) {\n\t\t\tif (isPrime(abs(even[i] - odd[j]))) {\n\t\t\t\tres.AddEdge(1000 + i, 2000 + j, 1);\n\t\t\t}\n\t\t}\n\t}\n\t\n\t// 最大流量\n\tint primeCnt = res.GetMaxFlow(start, end);\n\t\n\t// 残りは貪欲\n\tint evenCnt = (even.size() - primeCnt) / 2 + (odd.size() - primeCnt) / 2;\n\tint oddCnt = (even.size() - primeCnt) % 2;\n\n\tcout << primeCnt + evenCnt * 2 + oddCnt * 3 << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int MAXN = 1000100;\n\n#define rep(i, a, b) for(int i = a; i < (b); ++i)\n#define trav(a, x) for(auto& a : x)\n#define all(x) begin(x), end(x)\n#define sz(x) (int)(x).size()\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\nint N;\nint arr[MAXN];\n \nstruct Dinic {\n    struct Edge {\n        int to, rev;\n        ll c, f;\n    };\n    vi lvl, ptr, q;\n    vector<vector<Edge>> adj;\n    Dinic(int n) : lvl(n), ptr(n), q(n), adj(n) {}\n    void addEdge(int a, int b, ll c, int rcap = 0) {\n        adj[a].push_back({b, sz(adj[b]), c, 0});\n        adj[b].push_back({a, sz(adj[a]) - 1, rcap, 0});\n    }\n    ll dfs(int v, int t, ll f) {\n        if (v == t || !f) return f;\n        for (int& i = ptr[v]; i < sz(adj[v]); i++) {\n            Edge& e = adj[v][i];\n            if (lvl[e.to] == lvl[v] + 1)\n                if (ll p = dfs(e.to, t, min(f, e.c - e.f))) {\n                    e.f += p, adj[e.to][e.rev].f -= p;\n                    return p;\n                }\n        }\n        return 0;\n    }\n    ll calc(int s, int t) {\n        ll flow = 0; q[0] = s;\n        rep(L,0,31) do { // 'int L=30' maybe faster for random data\n            lvl = ptr = vi(sz(q));\n            int qi = 0, qe = lvl[s] = 1;\n            while (qi < qe && !lvl[t]) {\n                int v = q[qi++];\n                trav(e, adj[v])\n                    if (!lvl[e.to] && (e.c - e.f) >> (30 - L))\n                        q[qe++] = e.to, lvl[e.to] = lvl[v] + 1;\n            }\n            while (ll p = dfs(s, t, LLONG_MAX)) flow += p;\n        } while (lvl[t]);\n        return flow;\n    }\n};\n\nbool pr (int x)\n{\n    for (int i = 2; i * i <= x; i++)\n        if (x % i == 0) return false;\n    return true;\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(0);\n\n    cin >> N;\n    for (int i = 0; i < N; i++)\n        cin >> arr[i];\n    vector <int> v;\n    for (int i = 0; i < N; i++)\n    {\n        if (i == 0 || arr[i-1] + 1 < arr[i])\n            v.push_back(arr[i]);\n        if (i == N - 1 || arr[i+1] - 1 > arr[i])\n            v.push_back(arr[i]+1);\n    }\n\n    int m = v.size();\n    Dinic d (m + 2);\n    int ne = 0, no = 0;\n    for (int i = 0; i < m; i++)\n    {\n        if (v[i] % 2 == 0)\n        {\n            d.addEdge (m, i, 1);\n            ne++;\n        }\n        else\n        {\n            d.addEdge (i, m + 1, 1);\n            no++;\n        }\n    }\n    for (int i = 0; i < m; i++)\n        for (int j = 0; j < m; j++)\n        {\n            if (v[i] % 2 == 0 && v[j] % 2 == 1)\n            {\n                if (pr (abs (i - j)))\n                    d.addEdge (i, j, 1);\n            }\n        }\n\n    int r = d.calc (m, m + 1);\n\n    int res = r;\n    ne -= r;\n    no -= r;\n    res += 2 * (ne / 2 + no / 2);\n    res += 3 * (ne % 2 + no % 2);\n    cout << res << \"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<cstring>\nusing namespace std;\nint n;\nint res;\nvector<int>v;\nint lst=-1;\nint match[210];\nint me,mo;\nint mx;\nbool f[10000010];\nvector<int>ok[210];\nint vis[210];\nint prm[1000010];\nint sz;\nint l;\nbool bp(int x,int p)\n{\n\tvis[x]=p;\n\tfor(int i=0;i<ok[x].size();i++)\n\t{\n\t\tint y=ok[x][i];\n\t\tif(match[y]==-1 || (vis[match[y]]!=p && bp(match[y],p)))\n\t\t{\n\t\t\tmatch[y]=x;\n\t\t\tmatch[x]=y;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint x;\n\t\tscanf(\"%d\",&x);\n\t\tif(x!=lst+1)\n\t\t{\n\t\t\tif(lst+1)v.push_back(lst+1);\n\t\t\tv.push_back(x);\n\t\t}\n\t\tlst=x;\n\t\tmx=lst+1;\n\t}\n\tv.push_back(lst+1);\n\tf[1]=true;\n\tfor(int i=2;i<=mx;i++)\n\t{\n\t\tif(!f[i])prm[++sz]=i;\n\t\tfor(int j=1;j<=sz;j++)\n\t\t{\n\t\t\tif(prm[j]*i>mx)break;\n\t\t\tf[prm[j]*i]=true;\n\t\t\tif(i%prm[j]==0)break;\n\t\t}\n\t}\n\tl=v.size();\n\tfor(int i=0;i<l;i++)\n\t{\n\t\tmatch[i]=-1;\n\t\tif(v[i]&1)mo++;else me++;\n\t\tfor(int j=i+1;j<l;j++)\n\t\t{\n\t\t\tif(v[j]-v[i]!=2 && !f[v[j]-v[i]])\n\t\t\t{\n\t\t\t\tok[i].push_back(j);\n\t\t\t\tok[j].push_back(i);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<l;i++)\n\t{\n\t\tif(match[i]>=0)continue;\n\t\tmemset(vis,-1,sizeof(vis));\n\t\tif(bp(i,i))res++;\n\t}\n\tprintf(\"%d\",res+((me-res)/2+(mo-res)/2)*2+((me-res)%2)*3);\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#endif\n//#pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\nint n;\nconst int maxN = 205;\nint x[maxN];\nconst int maxP = 1e7 + 10;\nint f[maxP];\nvector < int > g[maxN];\nvector < int > by[2];\nbool used[maxN];\nint mt[maxN];\nbool dfs(int v) {\n    if (used[v]) return false;\n    used[v] = true;\n    for (int to : g[v]) {\n        if (mt[to] == -1 || dfs(mt[to])) {\n            mt[to] = v;\n            return true;\n        }\n    }\n    return false;\n}\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n//    freopen(\"input.txt\", \"r\", stdin);\n    for (int i = 2; i < maxP; i++) {\n        if (f[i] == 0) {\n            f[i] = i;\n            for (int j = 2 * i; j < maxP; j += i) f[j] = i;\n        }\n    }\n    cin >> n;\n    for (int i = 1; i <= n; i++) {\n        cin >> x[i];\n    }\n    sort(x + 1, x + n + 1);\n    vector < int > f;\n    for (int i = 1; i <= n; i++) {\n        if (x[i] + 1 != x[i + 1]) f.emplace_back(x[i] + 1);\n        if (i == 1 || x[i] != x[i - 1] + 1) f.emplace_back(x[i]);\n    }\n    sort(f.begin(), f.end());\n    f.erase(unique(f.begin(), f.end()), f.end());\n    assert(f.size() % 2 == 0);\n    for (int j = 0; j < f.size(); j++) {\n        by[f[j] % 2].emplace_back(f[j]);\n    }\n\n\n    for (int i = 0; i < by[0].size(); i++) {\n        for (int j = 0; j < by[1].size(); j++) {\n            if (::f[abs(by[0][i] - by[1][j])] == abs(by[0][i] - by[1][j])) {\n                g[i].emplace_back(j);\n            }\n        }\n    }\n\n    int tot = f.size();\n    memset(mt, -1, sizeof mt);\n    for (int i = 0; i < by[0].size(); i++) {\n        memset(used, 0, sizeof used);\n        dfs(i);\n    }\n    int c = 0;\n    for (int j = 0; j < by[1].size(); j++) {\n        if (mt[j] != -1) c++;\n    }\n    int lft1 = by[0].size() - c;\n    cout << c + (tot - 2 * c) + (lft1 % 2 == 1)  << '\\n';\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nusing namespace std;\nint cnt,last[205],a[205],b[205],x[205],vis[205],match[205],prime[10000005],isprime[10000005],s[10000005];\nstruct node{\n\tint to,next;\n}e[1000005];\nvoid add(int a,int b){\n\te[++cnt].to=b;\n\te[cnt].next=last[a];\n\tlast[a]=cnt;\n}\nint dfs(int x){\n\tfor (int i=last[x]; i; i=e[i].next){\n\t\tint V=e[i].to;\n\t\tif (!vis[V]){\n\t\t\tvis[V]=1;\n\t\t\tif (!match[V] || dfs(match[V])){\n\t\t\t\tmatch[V]=x;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nint abs1(int x){\n\tif (x<0) return -x;\n\treturn x;\n}\nint main(){\n\tisprime[1]=1;\n\tfor (int i=2; i<=10000000; i++){\n\t\tif (!isprime[i]) prime[++cnt]=i;\n\t\tfor (int j=1; j<=cnt && i*prime[j]<=10000000; j++){\n\t\t\tisprime[i*prime[j]]=1;\n\t\t\tif (i%prime[j]==0) break;\n\t\t}\n\t}\n\tint n;\n\tscanf(\"%d\",&n);\n\tfor (int i=1; i<=n; i++){\n\t\tscanf(\"%d\",&x[i]);\n\t\ts[x[i]]^=1;\n\t}\n\tint num=0,sum=0;\n\tfor (int i=1; i<=10000001; i++)\n\t\tif (s[i]!=s[i-1]){\n\t\t\tif (i%2==1) a[++num]=i;\n\t\t\telse b[++sum]=i;\n\t\t}\n\tfor (int i=1; i<=num; i++)\n\t\tfor (int j=1; j<=sum; j++)\n\t\t\tif (!isprime[abs1(a[i]-b[j])]) add(i,j);\n\tint ss=0;\n\tfor (int i=1; i<=num; i++){\n\t\tfor (int j=1; j<=sum; j++) vis[j]=0;\n\t\tif (dfs(i)) ss++;\n\t}\n\tint ans=(num-ss)/2*2+(sum-ss)/2*2+ss+((num&1)!=(ss&1)?3:0);\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint n;\nclass graph\n{\n\tpublic:\n\t\tvector<int> v[1010];\n\t\tint match[1010];\n\t\tbool vis[1010];\n\t\tbool dfs(int np)\n\t\t{\n\t\t\tfor(auto &x:v[np])\n\t\t\t{\n\t\t\t\tif(!vis[x])\n\t\t\t\t{\n\t\t\t\t\tvis[x]=1;\n\t\t\t\t\tif(!match[x]||dfs(match[x]))\n\t\t\t\t\t{\n\t\t\t\t\t\tmatch[x]=np;\n\t\t\t\t\t\treturn 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n}G;\nvector<int> prime;\nbool flag[10000010];\nvoid init()\n{\n\tflag[1]=1;\n\tfor(int i=2;i<=10000000;i++)\n\t{\n\t\tif(!flag[i])prime.push_back(i);\n\t\tfor(int j=0;j<prime.size()&&i*prime[j]<=10000000;j++)\n\t\t{\n\t\t\tflag[i*prime[j]]=1;\n\t\t\tif(i%prime[j]==0)break;\n\t\t}\n\t}\n}\nvector<int> v1,v2;\nint col[10000010],m2[1010];\nint main()\n{\n//\tfreopen(\"c.in\",\"r\",stdin);\n\tinit();\n\tscanf(\"%d\",&n);\n\tv1.push_back(0);v2.push_back(0);\n\tfor(int i=1,ti;i<=n;i++)\n\t{\n\t\tscanf(\"%d\",&ti);\n\t\tcol[ti]=1;\n\t}\n\tfor(int i=1;i<=10000001;i++)\n\t{\n\t\tif(col[i]!=col[i-1])\n\t\t{\n\t\t\tif(i&1)v1.push_back(i);\n\t\t\telse v2.push_back(i);\n\t\t}\n\t}\n\tfor(int i=1;i<v1.size();i++)\n\t{\n\t\tfor(int j=1;j<v2.size();j++)\n\t\t{\n\t\t\tif(!flag[abs(v2[j]-v1[i])])G.v[i].push_back(j);\n\t\t}\n\t}\n\tfor(int i=1;i<v1.size();i++)\n\t{\n\t\tmemset(G.vis,0,sizeof(G.vis));\n\t\tG.dfs(i);\n\t}\n\tint cnt1=0,cnt2=0,ans=0;\n\tfor(int i=1;i<v2.size();i++)\n\t{\n\t\tif(G.match[i])m2[G.match[i]]=i,ans++;\n\t\telse cnt2++;\n\t}\n\tfor(int i=1;i<v1.size();i++)\n\t{\n\t\tif(!m2[i])cnt1++;\n\t}\n\tans+=(cnt1/2)*2;ans+=(cnt2/2)*2;\n\tcnt1%=2;cnt2%=2;\n\tif(cnt1&&cnt2)ans+=3;\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <cstring>\nconst int maxP = 1e7;\nconst int maxn = 205;\nconst int S = 0;\nconst int T = 204;\nusing namespace std;\nvector <int> p; bool isp[maxP + 5];\nvoid install(){\n\tisp[1] = 1;\n\tfor (int i = 2; i <= maxP; i++){\n\t\tif (!isp[i]) p.push_back(i);\n\t\tfor (int j = 0; j < p.size() && i * p[j] <= maxP; j++){\n\t\t\tisp[i * p[j]] = 1;\n\t\t\tif (i % p[j] == 0) break;\n\t\t}\n\t}\n}\nstruct E{\n\tint to, nxt;\n}e[maxn * maxn];\nint head[maxn], tot = 1;\nvoid addedge(int u, int v){\n\te[++tot].to = v, e[tot].nxt = head[u];\n\thead[u] = tot;\n}\nint mat[maxn]; bool vis[maxn];\nbool dfs(int cur){ \n\tfor (int i = head[cur]; i; i = e[i].nxt){\n\t\tint v = e[i].to;\n\t\tif (vis[v]) continue;\n\t\tvis[v] = 1;\n\t\tif (mat[v] == -1 || dfs(mat[v])){\n\t\t\tmat[v] = cur; mat[cur] = v;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\nint abs(int x){return x < 0 ? -x : x;}\nvector <int> x[2]; int n, c[maxP + 5];\nint main(){\n\tinstall();\n\tscanf(\"%d\", &n);\n\tfor (int a, i = 1; i <= n; i++){\n\t\tscanf(\"%d\", &a); c[a]++;\n\t}\n\tfor (int i = 1; i <= maxP + 1; i++)\n\t\tif (c[i] != c[i - 1]) x[i & 1].push_back(i);\n\tfor (int i = 0; i < x[0].size(); i++)\n\t\tfor (int j = 0; j < x[1].size(); j++)\n\t\t\tif (!isp[abs(x[1][j] - x[0][i])]) addedge(i, j + x[0].size());\n\tint flow = 0;\n\tmemset(mat, -1, sizeof mat);\n\tfor (int i = 0; i < x[0].size() + x[1].size(); i++){\n\t\tif (mat[i] == -1){\n\t\t\tmemset(vis, 0, sizeof vis);\n\t\t\tflow += dfs(i);\n\t\t}\n\t}\n\tprintf(\"%d\\n\", flow + (x[0].size() - flow) / 2 * 2 + (x[1].size() - flow) / 2 * 2 + (x[0].size() - flow) % 2 * 3);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntemplate< typename T = int >\nT Hungarian(vector< vector< T > > &A)\n{\n  const T infty = numeric_limits< T >::max();\n  const int N = (int) A.size() - 1;\n  const int M = (int) A[0].size() - 1;\n  vector< int > P(M + 1), way(M + 1);\n  vector< T > U(N + 1, 0), V(M + 1, 0), minV;\n  vector< bool > used;\n\n  for(int i = 1; i <= N; i++) {\n    P[0] = i;\n    minV.assign(M + 1, infty);\n    used.assign(M + 1, false);\n    int j0 = 0;\n    while(P[j0] != 0) {\n      int i0 = P[j0], j1 = 0;\n      used[j0] = true;\n      T delta = infty;\n      for(int j = 1; j <= M; j++) {\n        if(used[j]) continue;\n        T curr = A[i0][j] - U[i0] - V[j];\n        if(curr < minV[j]) minV[j] = curr, way[j] = j0;\n        if(minV[j] < delta) delta = minV[j], j1 = j;\n      }\n      for(int j = 0; j <= M; j++) {\n        if(used[j]) U[P[j]] += delta, V[j] -= delta;\n        else minV[j] -= delta;\n      }\n      j0 = j1;\n    }\n    do {\n      P[j0] = P[way[j0]];\n      j0 = way[j0];\n    } while(j0 != 0);\n  }\n  return (-V[0]);\n}\n\n\nconst int LIM = (int) 1e7;\nbool prime[LIM + 1];\n\nint main()\n{\n  prime[0] = prime[1] = true;\n  for(int i = 2; i * i <= LIM; i++) {\n    if(!prime[i]) {\n      for(int j = i + i; j <= LIM; j += i) {\n        prime[j] = true;\n      }\n    }\n  }\n  prime[2] = true;\n\n  int N;\n  cin >> N;\n  vector< int > vs;\n  for(int i = 0; i < N; i++) {\n    int x;\n    cin >> x;\n    if(vs.empty() || vs.back() + 1 != x) {\n      vs.emplace_back(x - 1);\n      vs.emplace_back(x);\n    } else {\n      ++vs.back();\n    }\n  }\n\n  vector< int > latte, malta;\n  for(auto &p : vs) {\n    if(p & 1) latte.emplace_back(p);\n    else malta.emplace_back(p);\n  }\n\n  int ret = 0;\n\n  if(!latte.empty() && !malta.empty()) {\n    vector< vector< int > > mat(latte.size(), vector< int >(malta.size(), 0));\n    for(int i = 0; i < latte.size(); i++) {\n      for(int j = 0; j < malta.size(); j++) {\n        cout << abs(latte[i] - malta[j]) << endl;\n        if(!prime[abs(latte[i] - malta[j])]) {\n          mat[i][j] = -1;\n        }\n      }\n    }\n    ret = -Hungarian(mat);\n  }\n\n  int beet1 = latte.size() - ret;\n  int beet2 = malta.size() - ret;\n  ret += beet1 / 2 * 2;\n  ret += beet2 / 2 * 2;\n  ret += beet1 % 2 * 3;\n  cout << ret << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 10000001;\n\n\nint n,fre[maxn],p[220],isprime[maxn],even,odd,wrong;\nvector <int> edge[220],v2;\n\nbool fin(int u) {\n    if (fre[u]==wrong) return false;\n    fre[u]=wrong;\n    for (int j=0;j<edge[u].size();j++) {\n        int v=edge[u][j];\n       // cout<<u<<\" \"<<v<<endl;\n        if (p[v]==0 || fin(p[v])) {\n            p[v]=u;\n            p[u]=v;\n            return true;\n        }\n    }\n    return false;\n}\n\nint main() {\n  //  freopen(\"in.txt\",\"r\",stdin);\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    isprime[1]=1;\n    for (int i=2;i<=maxn;i++)\n        if (isprime[i]==0) {\n            for (int j=i+i;j<=maxn;j+=i) isprime[j]=1;\n        }\n    cin>>n;\n    for (int i=1;i<=n;i++) {\n        int x;\n        cin>>x;\n        fre[x]=1;\n    }\n    even=0; odd=0; wrong=2;\n    int id=1;\n    while (id<=maxn) {\n        if (fre[id]==0) id++;\n        else if (fre[id]==1) {\n            v2.push_back(id);\n            if (id%2==0) even++; else odd++ ;\n            id++;\n            while (id<=maxn && fre[id]==1) id++;\n            v2.push_back(id);\n            if (id%2==0) even++; else odd++ ;\n        }\n    }\n    // for (int i=0;i<v2.size();i++) cout<<v2[i]<<\" \";\n   //  cout<<endl;\n   // cout<<\" \" <<even<<\" \"<<odd<<endl;\n    for (int i=0;i<v2.size();i++)\n        for (int j=i+1;j<v2.size();j++)\n            if (isprime[ v2[j] - v2[i] ]==0) {\n              //  cout<<i<<\" \"<<j<<\" \"<<v2[i]<<\" \"<<v2[j]<<endl;\n                edge[i+1].push_back(j+1);\n                edge[j+1].push_back(i+1);\n            }\n    int cnt=0;\n    for (int i=0;i<v2.size();i++)\n     if (p[i+1]==0) {\n        wrong++;\n        p[i+1]=i+1;\n        //cout<<fin(i+1)<<endl;\n        cnt+=(fin(i+1));\n       // cout<<p[i+1]<<endl;\n      //  cout<<\"fuck\"<<endl;\n    }\n   // cout<<cnt<<\" \" <<even<<\" \"<<odd<<endl;\n    cout<< cnt + ((even-cnt)/2 + (odd-cnt)/2) * 2 + (even%2)*3;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define go(x, i) for(register int i = head[x]; i; i = nxt[i])\n#define For(i, a, b) for(register int i = a; i <= b; ++ i)\n#define SZ(x) int(x.size())\n\nusing namespace std;\n\nconst int maxn = 100 + 4, maxm = 1e7 + 10;\nint P[maxn], C[maxn], n, vis[maxm];\nint notprim[maxm], S[maxm];\nvector<int> num, prime;\n\nvoid Get_prime(int m)\n{\n\tnotprim[0] = notprim[1] = 1;\n\tFor(i, 2, m)\n\t{\n\t\tif(!notprim[i])\n\t\t\tprime.push_back(i);\n\t\tint len = prime.size();\n\t\tFor(j, 0, len - 1)\n\t\t{\n\t\t\tif(prime[j] * i > m)\n\t\t\t\tbreak;\n\t\t\tnotprim[prime[j] * i] = 1;\n\t\t\tif(i % prime[j] == 0)\n\t\t\t\tbreak;\n\t\t}\n\t}\n}\n\nnamespace Match\n{\n\tconst int N = 1e7 + 10;\n\tint to[N], head[N], nxt[N], e;\n\tint pre[N], vis[N], G[N], O[N], now, sum;\n\tvoid add(int x, int y)\n\t{\n\t\tto[++ e] = y;\n\t\tnxt[e] = head[x];\n\t\thead[x] = e;\n\t}\n\tbool dfs(int x)\n\t{\n\t\tgo(x, i)\n\t\t{\n\t\t\tif(vis[to[i]] != now)\n\t\t\t{\n\t\t\t\tvis[to[i]] = now;\n\t\t\t\tif(!pre[to[i]] || dfs(pre[to[i]]))\n\t\t\t\t{\n\t\t\t\t\tpre[to[i]] = x;\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tint match()\n\t{\n\t\tint res = 0;\n\t\tfor(now = 1; now <= G[0]; ++ now)\n\t\t\tres += dfs(now);\n\t\treturn res;\n\t}\n\tvoid solve()\n\t{\n\t\tint res = 0;\n\t\tFor(i, 0, SZ(num) - 1)\n\t\t\tif(num[i] & 1)\n\t\t\t\tG[++ G[0]] = num[i];\n\t\t\telse\n\t\t\t\tO[++ O[0]] = num[i];\n\t\tFor(i, 1, G[0])\n\t\t\tFor(j, 1, O[0])\n\t\t\t\tif(!notprim[abs(G[i] - O[j])])\n\t\t\t\t\tadd(i, j);\n\t\tres += match();\n\t\tmemset(vis, 0, sizeof(vis));\n\t\tG[0] -= res, O[0] -= res;\n\t\tres += G[0] / 2 * 2, G[0] %= 2;\n\t\tres += O[0] / 2 * 2, O[0] %= 2;\n\t\tif(G[0] * O[0])\n\t\t\tres += 3;\n\t\tcout << res << endl;\n\t}\n}\n\nint main()\n{\n\tGet_prime(1e7 + 5);\n\tscanf(\"%d\", &n);\n\tFor(i, 1, n)\n\t\tscanf(\"%d\", &P[i]), vis[P[i]] ^= 1;\n\tFor(i, 1, maxm - 1)\n\t\tif(vis[i] != vis[i - 1])\n\t\t\tnum.push_back(i);\n\tmemset(vis, 0, sizeof(vis));\n\tMatch::solve();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\ntypedef long long ll;\nint odd,even,Odd[105],Even[105],ma[105];\nint flag[10000010],x[10000010],map[105][105],vis[105];\nint prime[10000010],a[105];\nint dfs(int u)\n{\n\tfor (int v=1;v<=even;v++)\n\t{\n\t\tif (!map[u][v]) continue;\n\t\tif (!vis[v])\n\t\t{\n\t\t\tint t=ma[v];\n\t\t\tma[v]=u;\n\t\t\tvis[v]=1;\n\t\t\tif (t==-1||dfs(t)) return 1;\n\t\t\tma[v]=t;\n\t\t}\n\t}\n\treturn 0;\n}\nint main()\n{\n\tint n,cnt=0;\n\tscanf(\"%d\",&n);\n\tflag[1]=1;\n\tfor (int i=2;i<=10000001;i++)\n\t{\n\t\tif (!flag[i]) prime[++cnt]=i;\n\t\tfor (int j=1;j<=cnt;j++)\n\t\t{\n\t\t\tif (i*prime[j]>10000001) break;\n\t\t\tflag[i*prime[j]]=1;\n\t\t\tif (i%prime[j]==0) break;\n\t\t}\n\t}\n\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%d\",&a[i]);\n\t\tx[a[i]]^=1;\n\t}\n\tfor (int i=1;i<=10000001;i++)\n\t\tif (x[i]!=x[i-1])\n\t\t{\n\t\t\tif (i&1) Odd[++odd]=i;\n\t\t\telse Even[++even]=i; \n\t\t}\n\tfor (int i=1;i<=odd;i++)\n\t\tfor (int j=1;j<=even;j++)\n\t\t\tif (flag[abs(Odd[i]-Even[j])]) map[i][j]=1;\n\tmemset(ma,-1,sizeof(ma));\n\tint sum=0;\n\tfor (int i=1;i<=odd;i++)\n\t{\n\t\tmemset(vis,0,sizeof(vis));\n\t\tif (dfs(i)) sum++;\n\t}\n\tll ans=sum+(((odd-sum)>>1)<<1)+(((even-sum)>>1)<<1)+(odd-sum)%2*3+(even-sum)%2*3;\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define For(i,j,k) for(int i=j;i<=k;++i)\n#define Forr(i,j,k) for(int i=j;i>=k;--i)\n#define Rep(i,u) for(int i=Begin[u],v=to[i];i;i=Next[i],v=to[i])\n#define ll long long \nusing namespace std;\nconst int N=210,INF=0x3f3f3f3f;\ntemplate<class T>void read(T &x){\n\tx=0;char c=getchar();\n\twhile(!isdigit(c))c=getchar();\n\twhile( isdigit(c))x=x*10+c-48,c=getchar();\n}\nint n,Link[N],Begin[N],Next[N*N],to[N*N],e;\ninline void add(int x,int y){\n\tto[++e]=y,Next[e]=Begin[x],Begin[x]=e;\n}\ninline void file(){\n#ifndef ONLINE_JUDGE\n\tfreopen(\"test.in\",\"r\",stdin);\n\tfreopen(\"test.out\",\"w\",stdout);\n#endif \n}\nint X[N],x[N],y[N],totx,toty;\n\nnamespace divide{\n\tconst int N=70,S=13,pri[S]={2,3,5,7,11,13,17,19,23,29,31,37,41};\n\tll pr[N],p[N];int c[N],cnt;\n\tll qpow(ll a,ll b,ll P){\n\t\tll ret=1;\n\t\tfor(;b;b>>=1,a=a*a%P)if(b&1)ret=ret*a%P;\n\t\treturn ret;\n\t}\n\tinline bool Miller_Rabin(ll x){\n\t\tint C=0,Times=S;\n\t\tll val,t=x-1,lst;\n\t\tFor(i,0,S-1)if(x==pri[i])return 1;\n\t\tif(x==1)return 0;\n\t\twhile(!(t&1))C++,t>>=1;\n\t\twhile(Times--){\n\t\t\tll a=pri[Times]%x;\n\t\t\tlst=qpow(a,t,x);\n\t\t\tFor(i,1,C){\n\t\t\t\tval=lst*lst%x;\n\t\t\t\tif(val==1&&lst!=x-1&&lst!=1)return 0;\n\t\t\t\tlst=val;\n\t\t\t}\n\t\t\tif(val!=1)return 0;\n\t\t}\n\t\treturn 1;\n\t}\n}namespace D=divide;\nbool check(int p){\n\tif(p==2)return 0;\n\treturn D::Miller_Rabin(p);\n}\nvoid init(){\n\tread(n);\n\tFor(i,1,n)read(X[i]);\n\tX[0]=-1;\n\tFor(i,1,n){\n\t\tif(X[i-1]!=X[i]-1){\n\t\t\tif(X[i]&1)x[++totx]=X[i];\n\t\t\telse y[++toty]=X[i];\n\t\t}\n\t\tif(X[i+1]!=X[i]+1){\n\t\t\tif((X[i]+1)&1)x[++totx]=X[i]+1;\n\t\t\telse y[++toty]=X[i]+1;\n\t\t}\n\t}\n\t//For(i,1,totx)printf(\"%d \",x[i]);puts(\"\");\n\t//For(i,1,toty)printf(\"%d \",y[i]);puts(\"\");\n\tFor(i,1,totx)\n\t\tFor(j,1,toty)\n\t\t\tif(check(abs(y[j]-x[i])))add(i,j);\n}\nint vis[N];\nbool Hungary(int u){\n\tRep(i,u)if(!vis[v]){\n\t\tvis[v]=1;\n\t\tif(!Link[v]||Hungary(v))return Link[v]=u,1;\n\t}\n\treturn 0;\n}\nvoid solve(){\n\tint ret=0,ans=0;\n\tFor(i,1,totx){\n\t\tFor(j,1,toty)vis[j]=0;\n\t\tret+=Hungary(i);\n\t}\n\tans=ret;\n\tans+=(totx-ret)/2*2;\n\tans+=(toty-ret)/2*2;\n\tif(ret%2!=totx%2)ans+=3;\n\tprintf(\"%d\\n\",ans);\n}\nint main(){\n\tfile();\n\tinit();\n\tsolve();\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint n,b,ans=0;\nint a[105],f[105][105];\nint x[2][105],cnt[2],c;\nint p[10000005],prime[3000005],tot=0;\nint vis[105],link[105];\n\nint dfs(int x){\n\tfor(int i=1;i<=cnt[1];i++){\n\t\tif(vis[i]==0&&f[x][i]==1){\n\t\t\tvis[i]=1;\n\t\t\tif(link[i]==0||dfs(link[i])){\n\t\t\t\tlink[i]=x;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint main(){\n\tscanf(\"%d\",&n);\n\ta[0]=-1;\n\tfor(int i=2;i<=10000000;i++){\n\t\tif(p[i]==0) prime[++tot]=i;\n\t\tfor(int j=1;j<=tot&&i*prime[j]<=10000000;j++){\n\t\t\tp[i*prime[j]]=1;\n\t\t\tif(i%prime[j]==0) break;\n\t\t}\n\t}\n\tp[1]=p[2]=1;\n\tfor(int i=1;i<=n;i++) scanf(\"%d\",&a[i]);\n\tfor(int i=1;i<=n;i++){\n\t\tif(a[i]==a[i-1]+1) continue;\n\t\tif(a[i-1]!=-1) x[c=(a[i-1]+1)&1][++cnt[c]]=a[i-1]+1;\n\t\tx[c=a[i]&1][++cnt[c]]=a[i];\n\t}\n\tx[c=(a[n]+1)&1][++cnt[c]]=a[n]+1;\n\tfor(int i=1;i<=cnt[0];i++){\n\t\tfor(int j=1;j<=cnt[1];j++){\n\t\t\tif(p[abs(x[0][i]-x[1][j])]==0) f[i][j]=1;\n\t\t}\n\t}\n\tfor(int i=1;i<=cnt[0];i++) if(dfs(i)) ans++;\n\tcnt[1]-=ans,cnt[0]-=ans;\n\tans+=2*(cnt[1]/2+cnt[0]/2);\n\tif(cnt[1]&1) ans+=3;\n\tprintf(\"%d\\n\",ans);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 205;\nconst int MAXM = 10000005;\nint n, x[MAXN], f[MAXM], p[MAXM], cnt, match[MAXN], w[MAXN][MAXN];\nbool ip[MAXM];\nvoid pre(int N) {\n\tfor(int i = 2; i <= N; ++i) {\n\t\tif(!ip[i]) p[++cnt] = i;\n\t\tfor(int j = 1; j <= cnt && p[j]*i <= N; ++j) {\n\t\t\tip[p[j]*i] = 1;\n\t\t\tif(i % p[j] == 0) break;\n\t\t}\n\t}\n}\nbool vis[MAXN];\nbool dfs(int u) {\n\tfor(int v = 1; v <= n; ++v)\n\t\tif(w[u][v] && !vis[v]) {\n\t\t\tvis[v] = 1;\n\t\t\tif(!match[v] || dfs(match[v])) {\n\t\t\t\tmatch[v] = u;\n\t\t\t\tmatch[u] = v;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\treturn 0;\n}\nint maxmatch() {\n\tint re = 0;\n\tfor(int i = 1; i <= n; ++i)\n\t\tif(x[i]&1) {\n\t\t\tmemset(vis,0,sizeof vis);\n\t\t\tre += dfs(i);\n\t\t}\n\treturn re;\n}\nint main () {\n\tscanf(\"%d\", &n);\n\tfor(int i = 1,y; i <= n; ++i) scanf(\"%d\", &y), f[y] = 1;\n\tfor(int i = 10000001; i >= 1; --i) f[i] ^= f[i-1];\n\tn = 0;\n\tfor(int i = 1; i <= 10000001; ++i) if(f[i]) x[++n] = i;\n\tpre(x[n]); ip[2] = 1;\n\tfor(int i = 1; i <= n; ++i)\n\t\tfor(int j = i+1; j <= n; ++j)\n\t\t\tif(!ip[x[j]-x[i]])\n\t\t\t\tw[i][j] = w[j][i] = 1;\n\t\t\telse w[i][j] = w[j][i] = 0;\n\tint ans = maxmatch();\n\tint c1 = 0, c2 = 0;\n\tfor(int i = 1; i <= n; ++i)\n\t\tif(!match[i]) (x[i] & 1) ? ++c1 : ++c2;\n\tans += 2*(c1/2) + 2*(c2/2) + (c1&1)*3;\n\tprintf(\"%d\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "/**\n *    author:  tourist\n *    created: 20.11.2019 08:57:54       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  const int N = (int) 1e7 + 10;\n  vector<bool> prime(N, true);\n  for (int i = 2; i < N; i++) if (prime[i]) for (int j = i + i; j < N; j += i) prime[j] = false;\n  int n;\n  cin >> n;\n  vector<int> a(n);\n  for (int i = 0; i < n; i++) cin >> a[i];\n  vector<int> s(1, 1);\n  for (int i = 1; i < n; i++)\n    if (a[i] == a[i - 1] + 1) s.back() += 1;\n    else { s.push_back(a[i] - a[i - 1] - 1); s.push_back(1); }\n  n = (int) s.size();\n  vector<vector<int>> dp(n, vector<int>(n));\n  for (int i = n - 1; i >= 0; i--) {\n    for (int j = i; j < n; j += 2) {\n      int ss = accumulate(s.begin() + i, s.begin() + j + 1, 0);\n      dp[i][j] = (ss % 2 == 0 ? 2 : (prime[ss] ? 1 : 3)) + (i < j ? dp[i + 1][j - 1] : 0);\n      for (int k = i; k < j; k += 2) dp[i][j] = min(dp[i][j], dp[i][k] + dp[k + 2][j]);\n    } \n  }\n  cout << dp[0][n - 1] << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define fi first\n#define se second\n#define mp make_pair\n#define gc getchar\n#define pb push_back\n#define eb emplace_back\n#define all(x) (x).begin(),(x).end()\n#define x1 uvuvwevwevwe\n#define y1 onyetenyevwe\n#define x2 ugwemubwem\n#define y2 ossas\ntypedef long long LL;\ntypedef long double LD;\ntypedef pair<int,int> pii;\nconst int batasprima=10000;\ntemplate <typename T> void scan(T &angka){\n\tangka=0;char input=gc();T kali=1;\n\twhile(!(48<=input&&input<=57)){\tif(input=='-')\tkali=-1;input=gc();}\n\twhile(48<=input&&input<=57)\tangka=(angka<<3)+(angka<<1)+input-48,input=gc();angka*=kali;\n}\ntemplate <typename T1,typename T2> void scan(T1 &angka1,T2 &angka2){\n\tscan(angka1);scan(angka2);\n}\nint match[205],k=0,ans;\nvector <int> daftar,adj[205],prime;\nbitset<205> visited;\nvoid sieve(){\n\tbool isprime[batasprima+5];\n\tmemset(isprime,true,sizeof(isprime));\n\tfor(int i=2;i<=batasprima;i++)\n\t{\n\t\tif(!isprime[i])\n\t\t\tcontinue;\n\t\tprime.pb(i);\n\t\tfor(int j=i+i;j<=batasprima;j+=i)\n\t\t\tisprime[j]=false;\n\t}\n}\nbool isprime(int angka){\n\tif(angka<2)\n\t\treturn false;\n\tfor(auto isi:prime)\n\t{\n\t\tif(angka%isi==0)\n\t\t\treturn false;\n\t}\n\treturn true;\n}\nbool matching(int pos){\n\tif(visited[pos])\n\t\treturn false;\n\tvisited[pos]=true;\n\tfor(auto isi:adj[pos])\n\t{\n\t\tif(match[isi]==-1||matching(match[isi]))\n\t\t{\n\t\t\tmatch[isi]=pos;\n\t\t\tmatch[pos]=isi;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\nvoid buatgraph(){\t\n\tfor(int i=0;i<daftar.size();i++)\n\t{\n\t\tfor(int j=0;j<daftar.size();j++)\n\t\t{\n\t\t\tif(isprime(abs(daftar[i]-daftar[j])))\n\t\t\t\tadj[i].pb(j);\n\t\t}\n\t}\n}\nvoid hitungk(){\n\tmemset(match,-1,sizeof(match));\n\tfor(int i=0;i<daftar.size();i++)\n\t{\n\t\tif(match[i]!=-1)\n\t\t\tcontinue;\n\t\tvisited.reset();\n\t\tif(matching(i))\n\t\t\tk++;\n\t}\n}\nvoid hitungans(){\n\tint genap=0,ganjil=0;\n\tfor(auto isi:daftar)\n\t{\n\t\tif(isi&1)\n\t\t\tganjil++;\n\t\telse\n\t\t\tgenap++;\n\t}\n\tassert(ganjil>=k&&genap>=k);\n\tassert(ganjil%2==genap%2);\n\tans=k+((ganjil-k)/2+(genap-k)/2)*2+((ganjil-k)%2)*3;\n}\nvoid isidaftar(){\n\tint n,tadi=0;\n\tscan(n);\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tint input;\n\t\tscan(input);\n\t\tassert(tadi<input);\n\t\ttadi=input;\n\t\tif(daftar.size()&&daftar.back()==input)\n\t\t\tdaftar[daftar.size()-1]=input+1;\t\t\t//nanti mau sa coba\n\t\telse\n\t\t\tdaftar.pb(input),daftar.pb(input+1);\n\t}\n}\nint main()\n{\n\tsieve();\n\tisidaftar();\n\tbuatgraph();\n\thitungk();\n\thitungans();\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\ntemplate <typename _tp> inline void read(_tp&x){\n\tchar ch=getchar(),ob=0;x=0;\n\twhile(ch!='-'&&!isdigit(ch))ch=getchar();if(ch=='-')ob=1,ch=getchar();\n\twhile(isdigit(ch))x=x*10+ch-'0',ch=getchar();if(ob)x=-x;\n}\n\nconst int N = 203, M = 10001003;\nbool ispri[M], vs[N];\nint a[N], tot;\nint n, Ans;\n\nvoid input() {\n\tread(n);\n\tint x, y; read(x);\n\ta[tot = 1] = x;\n\tfor(int i=2;i<=n;++i) {\n\t\tread(y);\n\t\tif(x+1 != y) a[++tot] = x+1, a[++tot] = y;\n\t\tx = y;\n\t}\n\ta[++tot] = ++x;\n\t\n\tfor(int i=2;i<=x;++i) ispri[i] = true;\n\tfor(int i=2;i<=x;++i) if(ispri[i])\n\t\tfor(int j=i+i;j<=x;j+=i) ispri[j] = false;\n\tispri[2] = false;\n}\n\nnamespace Part1 {\n\tstruct Edge {int v, w, nxt;} e[N*N];\n\tint head[N], cur[N];\n\tint q[N], he, ta, dis[N];\n\tint s, t, _;\n\t\n\tinline void add(int x, int y) {\n\t\te[++_].v = y, e[_].w = 1, e[_].nxt = head[x], head[x] = _;\n\t\te[++_].v = x, e[_].w = 0, e[_].nxt = head[y], head[y] = _;\n\t}\n\t\n\tvoid init() {\n\t\ts = tot + 1, t = s + 1, _ = 1;\n\t\tfor(int i=1;i<=t;++i) head[i] = 0;\n\t}\n\t\n\tbool bfs() {\n\t\tfor(int i=1;i<=t;++i) dis[i] = -1;\n\t\tdis[q[he = ta = 1] = s] = 0;\n\t\twhile(he <= ta) {\n\t\t\tint x = q[he++];\n\t\t\tfor(int i=head[x];i;i=e[i].nxt)\n\t\t\t\tif(e[i].w and -1 == dis[e[i].v]) {\n\t\t\t\t\tdis[q[++ta] = e[i].v] = dis[x] + 1;\n\t\t\t\t\tif(e[i].v == t) return true;\n\t\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\t\n\tint dfs(int x, int flw) {\n\t\tif(x == t or !flw) return flw;\n\t\tint res = 0, tmp;\n\t\tfor(int&i=cur[x];i;i=e[i].nxt)\n\t\t\tif(e[i].w and dis[e[i].v] == dis[x] + 1)\n\t\t\tif(tmp = dfs(e[i].v, e[i].w)) {\n\t\t\t\te[i].w -= tmp, e[i^1].w += tmp, res += tmp;\n\t\t\t\tif(res == flw) return res;\n\t\t\t}\n\t\tif(!res) dis[x] = -1;\n\t\treturn res;\n\t}\n\t\n\tint Dinic() {\n\t\tconst int oo = 1e9;\n\t\tint res = 0;\n\t\twhile(bfs()) {\n\t\t\tfor(int i=1;i<=t;++i) cur[i] = head[i];\n\t\t\tres += dfs(s, +oo);\n\t\t}\n\t\treturn res;\n\t}\n\n\tvoid work() {\n\t\tinit();\n\t\tfor(int i=1;i<=tot;++i)\n\t\t\tif(a[i]&1) add(s, i);\n\t\n\t\tfor(int i=1;i<=tot;++i) if(a[i]&1)\n\t\tfor(int j=1;j<=tot;++j) if(~a[j]&1)\n\t\t\tif(ispri[abs(a[i] - a[j])]) add(i, j);\n\t\t\n\t\tfor(int i=1;i<=tot;++i)\n\t\t\tif(~a[i]&1) add(i, t);\n\t\n\t\tAns += Dinic();\n\t\tfor(int i=head[s];i;i=e[i].nxt)\n\t\t\tif(!e[i].w) vs[e[i].v] = true;\n\t\tfor(int i=head[t];i;i=e[i].nxt)\n\t\t\tif(e[i].w) vs[e[i].v] = true;\n\t}\n}\n\nvoid Part23() {\n\tint ct[2] = {0, 0};\n\tfor(int i=1;i<=tot;++i)\n\t\tif(!vs[i]) ++ct[a[i]&1];\n\tAns += ct[0] ^ (ct[0] & 1);\n\tAns += ct[1] ^ (ct[1] & 1);\n\tAns += (ct[0] & ct[1] & 1) * 3;\n}\n\nint main() {\n\tinput();\n\t\n\tPart1::work();\n\tPart23();\n\t\n\tprintf(\"%d\\n\", Ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define dbg(...) do{cerr<<__LINE__<<\": \";dbgprint(#__VA_ARGS__, __VA_ARGS__);}while(0);\n\nusing namespace std;\n\nnamespace std{template<class S,class T>struct hash<pair<S,T>>{size_t operator()(const pair<S,T>&p)const{return ((size_t)1e9+7)*hash<S>()(p.first)+hash<T>()(p.second);}};template<class T>struct hash<vector<T>>{size_t operator()(const vector<T> &v)const{size_t h=0;for(auto i : v)h=h*((size_t)1e9+7)+hash<T>()(i)+1;return h;}};}\ntemplate<class T>ostream& operator<<(ostream &os, const vector<T> &v){os<<\"[ \";rep(i,v.size())os<<v[i]<<(i==v.size()-1?\" ]\":\", \");return os;}template<class T>ostream& operator<<(ostream &os,const set<T> &v){os<<\"{ \"; for(const auto &i:v)os<<i<<\", \";return os<<\"}\";}\ntemplate<class T,class U>ostream& operator<<(ostream &os,const map<T,U> &v){os<<\"{\";for(const auto &i:v)os<<\" \"<<i.first<<\": \"<<i.second<<\",\";return os<<\"}\";}template<class T,class U>ostream& operator<<(ostream &os,const pair<T,U> &p){return os<<\"(\"<<p.first<<\", \"<<p.second<<\")\";}\nvoid dbgprint(const string &fmt){cerr<<endl;}template<class H,class... T>void dbgprint(const string &fmt,const H &h,const T&... r){cerr<<fmt.substr(0,fmt.find(\",\"))<<\"= \"<<h<<\" \";dbgprint(fmt.substr(fmt.find(\",\")+1),r...);}\ntypedef long long ll;typedef vector<int> vi;typedef pair<int,int> pi;const int inf = (int)1e9;const double INF = 1e12, EPS = 1e-9;\nstruct FlowGraph{\n\tstruct edge{ int to, cap, rev; };\n\t\n\tint n, *level, *iter;\n\tvector<vector<edge> > G;\n\t\n\tFlowGraph(int sz) : n(sz){\n\t\tG.resize(n);\n\t\titer = new int[n]; level = new int[n];\n\t}\n\t~FlowGraph(){\n\t\tdelete [] iter; delete [] level;\n\t}\n\t\n\tvoid add(int s, int t, int cap){\n\t\tG[s].pb((edge){t, cap, (int)G[t].size()});\n\t\tG[t].pb((edge){s, 0, (int)G[s].size() - 1});\n\t}\n\tvoid bfs(int s){\n\t\trep(i, n) level[i] = -1;\n\t\tqueue<int> q;\n\t\tlevel[s] = 0;\n\t\tq.push(s);\n\t\twhile(!q.empty()){\t\n\t\t\tint v = q.front();\n\t\t\tq.pop();\n\t\t\trep(i, G[v].size()){\n\t\t\t\tedge &e = G[v][i];\n\t\t\t\tif(e.cap > 0 && level[e.to] < 0){\n\t\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\t\tq.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint dfs(int v, int t, int f){\n\t\tif(v == t) return f;\n\t\tfor(int &i = iter[v]; i < (int)G[v].size(); i++){\n\t\t\tedge &e = G[v][i];\n\t\t\tif(e.cap > 0 && level[v] < level[e.to]){\n\t\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\t\tif(d > 0){\n\t\t\t\t\te.cap -= d;\n\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tint max_flow(int s, int t){\n\t\tint flow = 0;\n\t\twhile(1){\n\t\t\tbfs(s);\n\t\t\tif(level[t] < 0) return flow;\n\t\t\trep(i, n) iter[i] = 0;\n\t\t\tint f;\n\t\t\twhile((f = dfs(s, t, inf)) > 0) flow += f;\n\t\t}\n\t}\n};\nint main(){\n\tcin.tie(0); cin.sync_with_stdio(0);\n\t\n\tint n; cin >> n;\n\tvi v(n), u; rep(i, n) cin >> v[i];\n\tint cnt = 0;\n\trep(i, n){\n\t\tif(i && v[i] != v[i - 1] + 1){\n\t\t\tu.pb(v[i - 1] + 1);\n\t\t\tu.pb(v[i - 1] + 1 - cnt);\n\t\t\tcnt = 1;\n\t\t}\n\t\telse cnt++;\n\t}\n\tu.pb(v[n - 1] + 1);\n\tu.pb(v[n - 1] + 1 - cnt);\n\t\n\tauto isPrime = [](int x){\n\t\tif(x <= 2) return 0;\n\t\tfor(int i = 2; i * i <= x; i++) if(x % i == 0) return 0;\n\t\treturn 1;\n\t};\n\t\n\tdbg(u);\n\t\n\tvi o, e;\n\tfor(int i : u) if(i % 2) o.pb(i); else e.pb(i);\n\tint s = o.size() + e.size(), t = s + 1;\n\tFlowGraph g(o.size() + e.size() + 2);\n\t{\n\t\trep(i, o.size()) rep(j, e.size()) if(isPrime(abs(o[i] - e[j]))) g.add(i, j + o.size(), 1);\n\t\trep(i, o.size()) g.add(s, i, 1);\n\t\trep(i, e.size()) g.add(i + o.size(), t, 1);\n\t}\n\tint f = g.max_flow(s, t);\n\t\n\tint ans = f + ((o.size() - f) / 2 + (e.size() - f) / 2) * 2 + (o.size() % 2) * 3;\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<string>\n#include<cmath>\nusing namespace std;\n#define clr(a) memset(a,0,sizeof(a))\n//--Container\n#include<set>\n//\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pi;\n \nstruct eg{int u,v,nx;}gp[50010];int cnt,hd[210],mth[210];bool bd[210];\nvoid psh(int u,int v){++cnt;gp[cnt].u=u,gp[cnt].v=v,gp[cnt].nx=hd[u],hd[u]=cnt;};\n \nbool fdp(int v){\n    int i;for(i=hd[v];i;i=gp[i].nx)if(!bd[gp[i].v]){\n        bd[gp[i].v]=1;\n        if(!mth[gp[i].v]||fdp(mth[gp[i].v])){\n            mth[gp[i].v]=v;\n            return 1;\n        }\n    }\n    return 0;\n};\nint hgy(int n){\n    int rs=0,i;for(clr(bd),i=1;i<=n;++i){\n        clr(mth);if(fdp(i))++rs;\n    }\n    return rs;\n};\n \nint ar[110],dr[210],cr[2][210],dn,n;\n \nbool _ck(int n){\n    if(n<3)return 0;int d=sqrt(n),i=2;for(;i<=d;++i)if(!(n%i))return 0;\n    return 1;\n};\n \nbool cl(){\n\tif(scanf(\"%d\",&n)==-1)return 0;\n    int i,j,t,a,b,k;for(i=1;i<=n;scanf(\"%d\",&ar[i++]));sort(ar+1,ar+n+1);n=unique(ar+1,ar+n+1)-ar-1;\n    for(dn=1,dr[1]=ar[1],i=2;i<=n;++i){\n        if(ar[i]==ar[i-1]+1)continue;\n        dr[++dn]=ar[i-1]+1,dr[++dn]=ar[i];\n    }\n    dr[++dn]=ar[n]+1;\n    for(a=b=0,i=1;i<=dn;++i){\n        if(dr[i]&1)cr[1][++a]=dr[i];\n        else\n            cr[0][++b]=dr[i];\n    }\n    for(cnt=0,clr(hd),i=1;i<=a;++i)for(j=1;j<=b;++j)if(_ck(abs(cr[1][i]-cr[0][j])))\n        psh(i,j);\n    t=hgy(a);\n    printf(\"%d\\n\",t+(a-t)/2*2+(b-t)/2*2+(a-t)%2*3);\n\treturn 1;\n};\n \nint main() {\n    while(cl());\n    return 0;\n};"
  },
  {
    "language": "C++",
    "code": "// Written By NewbieChd\n#include <cstdio>\n#include <cctype>\n#include <cstring>\n#include <algorithm>\n#include <queue>\nusing namespace std;\n\nconst int BUF = 1000000;\nchar buf[BUF], *p1, *p2;\ninline char getChar() { return p1 == p2 && (p2 = (p1 = buf) + fread(buf, 1, BUF, stdin), p1 == p2) ? EOF : *p1++; }\ninline int read() {\n    int f = 0;\n    bool b = 1;\n    char c;\n    while (!isdigit(c = getChar()))\n        if (c == 45)\n            b = 0;\n    do\n        f = f * 10 + (c ^ 48);\n    while (isdigit(c = getChar()));\n    return b ? f : ~f + 1;\n}\n\nconst int maxN = 1003, maxE = 1000003, S = maxN - 2, T = maxN - 1, inf = 0x3f3f3f3f;\nint cntNode;\n\nint h[maxN], cntEdge = 1;\nstruct Edge {\n    int tar, val, nxt;\n    Edge() {}\n    Edge(int tar, int val, int nxt) : tar(tar), val(val), nxt(nxt) {}\n}ed[maxE];\ninline void addEdge(int x, int y, int z) { ed[++cntEdge] = Edge(y, z, h[x]), h[x] = cntEdge, ed[++cntEdge] = Edge(x, 0, h[y]), h[y] = cntEdge; }\n\nint cur[maxN], dep[maxN];\nqueue<int> que;\ninline bool bfs() {\n    int i, x, y;\n    memset(dep + 1, 0, sizeof(int) * cntNode), memcpy(cur + 1, h + 1, sizeof(int) * cntNode), cur[S] = h[S], dep[S] = 1, dep[T] = 0, que.push(S);\n    while (!que.empty()) {\n        x = que.front(), que.pop();\n        for (i = h[x]; i; i = ed[i].nxt)\n            if (ed[i].val && !dep[y = ed[i].tar])\n                dep[y] = dep[x] + 1, que.push(y);\n    }\n    return dep[T];\n}\nint dfs(int x, int flow) {\n    if (x == T)\n        return flow;\n    int res = flow, k, i, y;\n    for (i = cur[x]; i && res; i = ed[i].nxt) {\n        cur[x] = i;\n        if (ed[i].val && dep[y = ed[i].tar] == dep[x] + 1 && (k = dfs(y, min(res, ed[i].val))))\n            res -= k, ed[i].val -= k, ed[i ^ 1].val += k;\n    }\n    return flow - res;\n}\n\ninline int Dinic() {\n    int maxFlow = 0, k;\n    while (bfs())\n        while ((k = dfs(S, inf)))\n            maxFlow += k;\n    return maxFlow;\n}\n\nconst int maxL = 10000003, lim = 1e7;\nint prime[maxL];\nbool notP[maxL];\n\nbool flag[maxL];\nint pos[maxN], ind[maxN];\ninline int absolute(int x) { return x >= 0 ? x : ~x + 1; }\n\nint main() {\n    int n = read(), cntP = 0, i, j;\n    for (i = 2; i <= n; ++i) {\n        if (!notP[i])\n            prime[++cntP] = i;\n        for (j = 1; j <= lim && i * prime[j] <= lim; ++j) {\n            notP[i * prime[j]] = 1;\n            if (i % prime[j] == 0)\n                break;\n        }\n    }\n    \n    for (i = 1; i <= n; ++i)\n        flag[read()] = 1;\n    for (i = 1; i <= lim; ++i)\n        if (flag[i] ^ flag[i - 1])\n            pos[++cntNode] = i;\n    for (i = 1; i <= cntNode; ++i) {\n        if (pos[i] & 1) {\n            for (j = 1; j <= cntNode; ++j)\n                if (!(pos[j] & 1) && (!notP[absolute(pos[i] - pos[j])]))\n                    addEdge(i, j, 1);\n            addEdge(S, i, 1);\n        }\n        else\n            addEdge(i, T, 1);\n        ind[i] = cntEdge ^ 1;\n    }\n    int ans = Dinic(), tax[2];\n    tax[0] = tax[1] = 0;\n    for (i = 1; i <= cntNode; ++i)\n        if (ed[ind[i]].val)\n            ++tax[pos[i] & 1];\n    ans += ((tax[0] >> 1) << 1) + ((tax[1] >> 1) << 1) + ((tax[0] & 1) | (tax[1] & 1)) * 3;\n    \n    printf(\"%d\\n\", ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int _ = 1e7 + 7;\nbool nprm[_]; int arr[_] , N; vector < int > ch[2] , Ed[3003];\n\nvoid shai(int mx){\n\tnprm[1] = 1;\n\tfor(int i = 2 ; i <= mx ; ++i)\n\t\tif(!nprm[i]) for(int j = i ; j <= mx / i ; ++j) nprm[i * j] = 1;\n}\n\nint match[3003]; bool vis[3003];\n\nbool dfs(int x){\n\tfor(int i = 0 ; i < Ed[x].size() ; ++i)\n\t\tif(!vis[Ed[x][i]]){vis[Ed[x][i]] = 1; if(match[Ed[x][i]] == -1 || dfs(match[Ed[x][i]])){match[Ed[x][i]] = x; return 1;}}\n\treturn 0;\n}\n\nint main(){\n\tscanf(\"%d\" , &N); int mx = 0; for(int i = 1 , p ; i <= N ; ++i){scanf(\"%d\" , &p); arr[p] = 1; mx = max(mx , p + 1);}\n\tshai(mx); for(int i = 1 ; i <= mx ; ++i) if(arr[i] ^ arr[i - 1]) ch[i & 1].push_back(i);\n\tfor(int i = 0 ; i < ch[0].size() ; ++i)\n\t\tfor(int j = 0 ; j < ch[1].size() ; ++j)\n\t\t\tif(!nprm[abs(ch[1][j] - ch[0][i])]) Ed[i].push_back(j);\n\tmemset(match , -1 , sizeof(match)); int ans = 0;\n\tfor(int i = 0 ; i < ch[0].size() ; ++i){memset(vis , 0 , sizeof(vis)); ans += dfs(i);}\n\tcout << (ans + ((ch[0].size() - ans) / 2 + (ch[1].size() - ans) / 2) * 2 + ((ch[0].size() - ans) & 1) * 3); return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cmath>\n#include<cstring>\n#include<string>\n#include<algorithm>\n#include<vector>\n\n#define maxn 205\n#define maxm 10000005\n\nusing namespace std;\n\ninline int getint()\n{\n\tint num=0,flag=1;char c;\n\twhile((c=getchar())<'0'||c>'9')if(c=='-')flag=-1;\n\twhile(c>='0'&&c<='9')num=num*10+c-48,c=getchar();\n\treturn num*flag;\n}\n\nint n,N;\nint a[maxn],w[maxn][maxn],link[maxn];\nint pri[maxm],cnt;\nbool np[maxm],col[maxm],vis[maxn];\nint X[maxn],Y[maxn],ans;\n\ninline void init()\n{\n\tnp[1]=1;\n\tfor(int i=2;i<=N;i++)\n\t{\n\t\tif(!np[i])pri[++cnt]=i;\n\t\tfor(int j=1;j<=cnt&&i*pri[j]<=N;j++)np[i*pri[j]]=1;\n\t}\n}\n\ninline bool match(int x)\n{\n\tfor(int i=1;i<=Y[0];i++)if(w[x][i]&&!vis[i])\n\t{\n\t\tif(vis[i]=1&&(!link[i]||match(link[i]))){link[i]=x;return 1;}\n\t}\n\treturn 0;\n}\n\nint main()\n{\n\tn=getint();\n\tfor(int i=1;i<=n;i++)N=max(N,a[i]=getint()),col[a[i]]=1;\n\tN++;init();\n\tfor(int i=1;i<=N;i++)if(col[i]^col[i-1])i&1?X[++X[0]]=i:Y[++Y[0]]=i;\n\tfor(int i=1;i<=X[0];i++)for(int j=1;j<=Y[0];j++)w[i][j]=!np[abs(X[i]-Y[j])];\n\tfor(int i=1;i<=X[0];i++)\n\t{\n\t\tmemset(vis,0,sizeof vis);\n\t\tans+=match(i);\n\t}\n\tans+=2*((X[0]-ans)/2)+2*((Y[0]-ans)/2)+3*((X[0]-ans)&1);\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nvector<int> pr, pchk;\nvoid getPrime() {\n    pchk = vector<int>(10000010, 0);\n    for(int i = 2; i < 10000010; i++) {\n        if(pchk[i]) continue;\n        int mul = 2;\n        while(i * mul < 10000010) {\n            pchk[i * mul] = 1;\n            mul++;\n        }\n    }\n}\n\nint N;\nvector<int> X;\n\nint main() {\n    getPrime();\n\n    scanf(\"%d\", &N);\n    X.resize(N);\n    for(int i = 0; i < N; i++) {\n        scanf(\"%d\", &X[i]);\n    }\n    int ans = 3*N;\n\n    int pre = 1;\n    int tmp = 0;\n    for(int i = 0; i < N; i++) {\n        tmp += (X[i] - pre) % 2 == 0? (X[i] - pre == 0? 0 : 2) : (pchk[ X[i] - pre ]? 3 : 1);\n        pre = X[i] + 1;\n        //cout<<tmp<<endl;\n    }\n    if(pchk[ X[N - 1] ]) tmp += (X[N - 1] % 2 == 0? 2 : 3);\n    else tmp++;\n    ans = min(ans, tmp);\n    cout<<ans;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<cstring>\n#include<map>\n#include<queue>\n#include<cmath>\nusing namespace std;\ntypedef long long ll;\nconst int N=1005,INF=~0u>>2;\nstruct Edge{int nxt,to;}edge[(N*N)<<3];\nint a[N],b[N<<1],n,head[N<<1],num_edge,vis[N<<1],lk[N<<1],even[N<<1],odd[N<<1],even_num,odd_num,ans,k,tot,tim;\nint read(){\n\tint x=0,f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-') f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn f*x;\n}\nvoid add_edge(int from,int to){\n\tedge[++num_edge].nxt=head[from];\n\tedge[num_edge].to=to;\n\thead[from]=num_edge;\n}\nbool find(int x){\n\tfor(int i=head[x];i;i=edge[i].nxt){\n\t\tif(vis[edge[i].to]!=tim){\n\t\t\tvis[edge[i].to]=tim;\n\t\t\tif(!lk[edge[i].to]||find(edge[i].to)){\n\t\t\t\tlk[edge[i].to]=x;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nbool check(int x){\n\tif(x==1) return 0;\n\tfor(int i=2;i*i<=x;++i){\n\t\tif(x%i==0) return 0;\n\t}\n\treturn 1;\n}\nint main(){\n//\tfreopen(\"ex.in\",\"r\",stdin);\n\tn=read();\n\tfor(int i=1;i<=n;++i) b[i]=read();b[0]=-INF;b[n+1]=INF;\n\tfor(int i=1;i<=n;++i){\n\t\tif(b[i]!=b[i-1]+1){\n\t\t\tif(i%2) odd[++odd_num]=b[i];\n\t\t\telse even[++even_num]=b[i];\n\t\t}\n\t\tif(b[i]+1!=b[i+1]){\n\t\t\tif((i+1)%2) odd[++odd_num]=b[i]+1;\n\t\t\telse even[++even_num]=b[i]+1;\n\t\t}\n\t}\n\tfor(int i=1;i<=odd_num;++i){\n\t\tfor(int j=1;j<=even_num;++j){\n\t\t\tif(check(abs(even[j]-odd[i]))) add_edge(even[j],odd[i]);\n\t\t}\n\t}\n\tfor(int i=1;i<=odd_num;++i){\n\t\ttim++;\n\t\tif(find(odd[i])) k++;\n\t\telse break;\n\t}\n\tans=k+((even_num-k)/2+(odd_num-k)/2)*2+((even_num-k)%2)*3;\n\tprintf(\"%d\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#include<bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n\n#define F first\n#define S second\n#define int long long\n#define ll long long\n//#define int  unsigned long long\n#define pb push_back\n//#define double long double\n\nusing namespace std;\nusing namespace __gnu_pbds;\ntypedef  tree< int , null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> ordered_set;\nconst int mod = 1e9 + 7;\nconst int N = 1000;\nstruct Edge {\n    int from, to, f, c, w;\n};\nvector < Edge >  edges;\nvector < int > g[N];\nint n, d[N], f[N];\nint p[N];\nvoid add(int a, int b, int c, int w){\n    Edge e;\n    e.from = a; e.to = b; e.c = c; e.w = w; e.f = 0;\n    edges.pb(e);\n    //cout << a << \" \" << b << \" \" << c << \" \" << w << endl;\n    g[a].pb(edges.size() - 1);\n    e.w = -e.w; e.c = 0; swap(e.from, e.to);\n    edges.pb(e);\n    g[b].pb(edges.size() - 1);\n}\nbool spfa(int s, int t){\n    for (int i = 1; i < N; i++){\n        d[i] = 1e9;\n        f[i] = 0;\n    }\n    queue < int > q;\n    q.push(s);\n    d[s] = 0;\n    f[s] = 1;\n    while(!q.empty()){\n        int v = q.front();\n        q.pop();\n        f[v] = 0;\n        for (int i = 0; i < g[v].size(); i++){\n            Edge e = edges[g[v][i]];\n            if (e.f < e.c && d[e.to] > d[v] + e.w){\n                p[e.to] = g[v][i];\n                d[e.to] = d[v] + e.w;\n                if (!f[e.to])\n                    q.push(e.to);\n                f[e.to] = 1;\n            }\n        }\n    }\n    return d[t] != 1e9;\n}\nint flow(int s, int t){\n    int cost = 0;\n    while(spfa(s, t)){\n        int v = t;\n        while(v != s && v != 0){\n            auto k = p[v];\n            edges[k].f++;\n            edges[k ^ 1].f--;\n            cost += edges[k].w;\n            v = edges[k].from;\n        }\n    }\n    return cost;\n}\nint mx[N], mn[N];\nint ff(int x){\n    if (x == 2) return 2;\n    if (x == 1) return 3;\n    int pr = 1;\n    for (int i = 2; i * i <= x; i++){\n        if (x % i == 0) pr = 0;\n    }\n    if (pr) return 1;\n    return 2 + (x % 2);\n}\nmain(){\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n   // freopen(\"input.txt\", \"r\", stdin);\n    cin >> n;\n    int p = -1;\n    vector < int > a;\n    for (int i = 1; i <= n; i++){\n        int x;\n        cin >> x;\n        if (x != p + 1){\n            if (p != -1) a.pb(p + 1);\n            a.pb(x);\n        }\n        p = x;\n    }\n    a.pb(p + 1);\n    n = a.size();\n  //  for (auto i: a) cout << i << \" \";\n   // cout << \"----------------\" << endl;\n    for (int i = 0; i < a.size(); i++){\n        add(2 * n + 1, i + 1, 1, 0);\n        add(n + i + 1, 2 * n + 2, 1, 0);\n        for (int j = 0; j < a.size(); j++){\n            if (i == j) continue;\n            int x = a[i];\n            int y = a[j];\n            add(i + 1, n + j + 1, 1, ff(abs(x - y)));\n        }\n    }\n    n = 2 * n + 2;\n    cout << flow(n - 1, n) / 2;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n\n#define Rep(i, n) for (int i = 1; i <= n; i ++)\n\nusing namespace std;\n\nconst int N = 210, N0 = 1e7 + 10;\n\nint d0[N], d[N], cd;\n\nbool isnotprime[N0];\nint prime[N0], cnt;\nvoid get_prime()\n{\n\tisnotprime[1] = true;\n\tfor (int i = 2; i <= 1e7; i ++){\n\t\tif (!isnotprime[i]) prime[++ cnt] = i;\n\t\tfor (int j = 1; j <= cnt && i * prime[j] <= 1e7; j ++) {\n\t\t\tisnotprime[i * prime[j]] = true;\n\t\t\tif (!(i % prime[j])) break;\n\t\t}\n\t}\n}\n\nbool g[N][N], vis[N];\nint lnk[N];\n\nbool dfs(int x)\n{\n\tvis[x] = true;\n\tRep(i, cd) if (g[x][i] && !vis[i]){\n\t\tif (lnk[i] == -1 || dfs(lnk[i])) {\n\t\t\tlnk[i] = x;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint main()\n{\n\tint n;\n\tscanf(\"%d\", &n);\n\tRep(i, n) scanf(\"%d\", &d0[i]);\n\td0[0] = -1;\n\tRep(i, n) {\n\t\tif (d0[i - 1] != d0[i] - 1) d[++ cd] = d0[i];\n\t\tif (d0[i + 1] != d0[i] + 1) d[++ cd] = d0[i] + 1;\n\t}\n\t\n\tget_prime();\n\tRep(i, cd) if (d[i] & 1)\n\t\tRep(j, cd) if (!(d[j] & 1))\n\t\t\tif (!isnotprime[(int)abs(d[j] - d[i])]) g[i][j] = true;\n\t\n\tint c0 = 0, c1 = 0, cc = 0;\n\tRep(i, cd) lnk[i] = -1;\n\tRep(i, cd) {\n\t\t//printf(\"%d\\n\", d[i]);\n\t\tif (d[i] & 1) {\n\t\t\tRep(j, cd) vis[j] = false;\n\t\t\tif (dfs(i)) cc ++;\n\t\t\tc1 ++;\n\t\t}\n\t\telse c0 ++;\n\t}\n\t//printf(\"%d %d %d\\n\", cc, c0, c1);\n\tint ans = cc;\n\tc0 -= cc, c1 -= cc;\n\tans += (c0 / 2) * 2, c0 %= 2;\n\tans += (c1 / 2) * 2, c1 %= 2;\n\tif (c0 && c1) ans += 3;\n\t\n\tprintf(\"%d\\n\", ans);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef unsigned long long int ull;\ntypedef long long int ll;\ntypedef pair<ll,ll> pll;\ntypedef long double D;\ntypedef complex<D> P;\n#define F first\n#define S second\nconst ll MOD=1000000007;\n//const ll MOD=998244353;\n\ntemplate<typename T,typename U>istream & operator >> (istream &i,pair<T,U> &A){i>>A.F>>A.S; return i;}\ntemplate<typename T>istream & operator >> (istream &i,vector<T> &A){for(auto &I:A){i>>I;} return i;}\ntemplate<typename T,typename U>ostream & operator << (ostream &o,const pair<T,U> &A){o<<A.F<<\" \"<<A.S; return o;}\ntemplate<typename T>ostream & operator << (ostream &o,const vector<T> &A){ll i=A.size(); for(auto &I:A){o<<I<<(--i?\" \":\"\");} return o;}\n\ntemplate <typename CostType, typename TotalCostType=int64_t>\nclass MaximumWeightedMatching {\n  /*\n    Maximum Weighted Matching in General Graphs.\n    - O(nm \\log(n)) time\n    - O(n + m) space \n    Note: each vertex is 1-indexed.\n    Ref: \n      Harold N. Gabow, \n      \"Data Structures for Weighted Matching and \n       Extensions to b-matching and f-factors\" (2016)\n      (https://arxiv.org/abs/1611.07541)\n  */\npublic:\n  using cost_t = CostType;\n  using tcost_t = TotalCostType;\n\nprivate:\n  enum Label { kSeparated = -2, kInner = -1, kFree = 0, kOuter = 1 };\n  static constexpr cost_t Inf = cost_t(1) << (sizeof(cost_t) * 8 - 2);\n\nprivate:\n  template <typename T>\n  class BinaryHeap {\n  public:\n    struct Node {\n      bool operator < (const Node& rhs) const { return value < rhs.value; }\n      T value; int id;\n    };\n    BinaryHeap() {}\n    BinaryHeap(int N) : size_(0), node(N + 1), index(N, 0) {}\n    int size() const { return size_; }\n    bool empty() const { return size_ == 0; }\n    void clear() { while (size_ > 0) index[node[size_--].id] = 0; }\n    T min() const { return node[1].value; }\n    int argmin() const { return node[1].id; } // argmin ?\n    T get_val(int id) const { return node[index[id]].value; }\n    void pop() { if (size_ > 0) pop(1); }\n    void erase(int id) { if (index[id]) pop(index[id]); }\n    bool has(int id) const { return index[id] != 0; }\n    void update(int id, T v) {\n      if (!has(id)) return push(id, v);\n      bool up = (v < node[index[id]].value);\n      node[index[id]].value = v;\n      if (up) up_heap(index[id]);\n      else down_heap(index[id]);\n    }\n    void decrease_key(int id, T v) {\n      if (!has(id)) return push(id, v);\n      if (v < node[index[id]].value) node[index[id]].value = v, up_heap(index[id]);\n    }\n    void push(int id, T v) {\n      // assert(!has(id));\n      index[id] = ++size_; node[size_] = {v, id};\n      up_heap(size_);\n    }\n  private:\n    void pop(int pos) {\n      index[node[pos].id] = 0;\n      if (pos == size_) { --size_; return; }\n      bool up = (node[size_].value < node[pos].value);\n      node[pos] = node[size_--]; index[node[pos].id] = pos;\n      if (up) up_heap(pos);\n      else down_heap(pos);\n    }\n    void swap_node(int a, int b) {\n      swap(node[a], node[b]); index[node[a].id] = a; index[node[b].id] = b;\n    }\n    void down_heap(int pos) {\n      for (int k = pos, nk = k; 2 * k <= size_; k = nk) {\n        if (node[2 * k] < node[nk]) nk = 2 * k;\n        if (2 * k + 1 <= size_ && node[2 * k + 1] < node[nk]) nk = 2 * k + 1;\n        if (nk == k) break;\n        swap_node(k, nk);\n      }\n    }\n    void up_heap(int pos) {\n      for (int k = pos; k > 1 && node[k] < node[k >> 1]; k >>= 1) swap_node(k, k >> 1);\n    }\n    int size_;\n    vector<Node> node;\n    vector<int> index;\n  };\n\n  template <typename Key>\n  class PairingHeaps {\n  private:\n    struct Node {\n      Node() : prev(-1) {} // \"prev < 0\" means the node is unused.\n      Node(Key v) : key(v), child(0), next(0), prev(0) {}\n      Key key; int child, next, prev;\n    };\n  public:\n    PairingHeaps(int H, int N) : heap(H), node(N) {\n      // It consists of `H` Pairing heaps.\n      // Each heap-node ID can appear at most 1 time(s) among heaps\n      // and should be in [1, N).\n    }\n\n    void clear(int h) { if (heap[h]) clear_rec(heap[h]), heap[h] = 0; }\n    void clear_all() {\n      for (size_t i = 0; i < heap.size(); ++i) heap[i] = 0;\n      for (size_t i = 0; i < node.size(); ++i) node[i] = Node();\n    }\n    bool empty(int h) const { return !heap[h]; }\n    bool used(int v) const { return node[v].prev >= 0; }\n    Key min(int h) const { return node[heap[h]].key; }\n    int argmin(int h) const { return heap[h]; }\n\n    void pop(int h) {\n      // assert(!empty(h));\n      erase(h, heap[h]);\n    }\n    void push(int h, int v, Key key) {\n      // assert(!used(v));\n      node[v] = Node(key);\n      heap[h] = merge(heap[h], v);\n    }\n    void erase(int h, int v) {\n      if (!used(v)) return;\n      int w = two_pass_pairing(node[v].child);\n      if (!node[v].prev) heap[h] = w;\n      else {\n        cut(v);\n        heap[h] = merge(heap[h], w);\n      }\n      node[v].prev = -1;\n    }\n    void decrease_key(int h, int v, Key key) {\n      if (!used(v)) return push(h, v, key);\n      if (!node[v].prev) node[v].key = key;\n      else {\n        cut(v); node[v].key = key;\n        heap[h] = merge(heap[h], v);\n      }\n    }\n\n  private:\n    void clear_rec(int v) {\n      for (; v; v = node[v].next) {\n        if (node[v].child) clear_rec(node[v].child);\n        node[v].prev = -1;\n      }\n    }\n    \n    inline void cut(int v) {\n      auto& n = node[v]; int pv = n.prev, nv = n.next;\n      auto& pn = node[pv];\n      if (pn.child == v) pn.child = nv;\n      else pn.next = nv;\n      node[nv].prev = pv;\n      n.next = n.prev = 0;\n    }\n\n    int merge(int l, int r) {\n      if (!l) return r;\n      if (!r) return l;\n      if (node[l].key > node[r].key) swap(l, r);\n      int lc = node[r].next = node[l].child;\n      node[l].child = node[lc].prev = r;\n      return node[r].prev = l;\n    }\n\n    int two_pass_pairing(int root) {\n      if (!root) return 0;\n      int a = root; root = 0;\n      while (a) {\n        int b = node[a].next, na = 0;\n        node[a].prev = node[a].next = 0;\n        if (b) na = node[b].next, node[b].prev = node[b].next = 0;\n        a = merge(a, b);\n        node[a].next = root; root = a; a = na;\n      }\n      int s = node[root].next; node[root].next = 0;\n      while (s) {\n        int t = node[s].next; node[s].next = 0;\n        root = merge(root, s);\n        s = t;\n      }\n      return root;\n    }\n\n  private:\n    vector<int> heap;\n    vector<Node> node;\n  };\n\n  template <typename T>\n  struct PriorityQueue : public priority_queue< T, vector<T>, greater<T> > {\n    PriorityQueue() {}\n    PriorityQueue(int N) { this->c.reserve(N);}\n    T min() const { return this->top(); }\n    void clear() { this->c.clear(); }\n  };\n\n  template <typename T>\n  struct Queue {\n    Queue() {}\n    Queue(int N) : qh(0), qt(0), data(N) {}\n    T operator [] (int i) const { return data[i]; }\n    void enqueue(int u) { data[qt++] = u; }\n    int dequeue() { return data[qh++]; }\n    bool empty() const { return qh == qt; }\n    void clear() { qh = qt = 0; }\n    int size() const { return qt; }\n    int qh, qt;\n    vector<T> data;\n  };\n\npublic:\n  struct InputEdge { int from, to; cost_t cost; };\n\nprivate:\n  template <typename T> using ModifiableHeap = BinaryHeap<T>;\n  template <typename T> using ModifiableHeaps = PairingHeaps<T>;\n  template <typename T> using FastHeap = PriorityQueue<T>;\n\n  struct Edge { int to; cost_t cost; };\n  struct Link { int from, to; };\n  struct Node { \n    struct NodeLink { int b, v; };\n    Node() {}\n    Node(int u) : parent(0), size(1) { link[0] = link[1] = {u, u}; }\n    int next_v() const { return link[0].v; }\n    int next_b() const { return link[0].b; }\n    int prev_v() const { return link[1].v; }\n    int prev_b() const { return link[1].b; }\n    int parent, size;\n    NodeLink link[2];\n  };\n  struct Event {\n    Event() {}\n    Event(cost_t time, int id) : time(time), id(id) {}\n    bool operator < (const Event& rhs) const { return time < rhs.time; }\n    bool operator > (const Event& rhs) const { return time > rhs.time; }\n    cost_t time; int id;\n  };\n  struct EdgeEvent {\n    EdgeEvent() {}\n    EdgeEvent(cost_t time, int from, int to) : time(time), from(from), to(to) {}\n    bool operator > (const EdgeEvent& rhs) const { return time > rhs.time; }\n    bool operator < (const EdgeEvent& rhs) const { return time < rhs.time; }\n    cost_t time; int from, to; \n  };\n\npublic:\n  MaximumWeightedMatching(int N, const vector<InputEdge>& in)\n      : N(N), B((N - 1) / 2), S(N + B + 1), ofs(N + 2), edges(in.size() * 2),\n        heap2(S), heap2s(S, S), heap3(edges.size()), heap4(S) {\n\n    for (auto& e : in) ofs[e.from + 1]++, ofs[e.to + 1]++;\n    for (int i = 1; i <= N + 1; ++i) ofs[i] += ofs[i - 1];\n    for (auto& e : in) {\n      edges[ofs[e.from]++] = {e.to, e.cost * 2};\n      edges[ofs[e.to]++] = {e.from, e.cost * 2};\n    }\n    for (int i = N + 1; i > 0; --i) ofs[i] = ofs[i - 1];\n    ofs[0] = 0;\n  }\n\n  tcost_t maximum_weighted_matching(bool init_matching=false) {\n    initialize();\n    set_potential();\n    if (init_matching) find_maximal_matching();\n    for (int u = 1; u <= N; ++u) if (!mate[u]) do_edmonds_search(u);\n    tcost_t ret = compute_optimal_value();\n    return ret;\n  }\n\nprivate:\n  tcost_t compute_optimal_value() const {\n    tcost_t ret = 0;\n    for (int u = 1; u <= N; ++u) if (mate[u] > u) {\n      cost_t max_c = 0;\n      for (int eid = ofs[u]; eid < ofs[u + 1]; ++eid) {\n        if (edges[eid].to == mate[u]) max_c = max(max_c, edges[eid].cost);\n      }\n      ret += max_c;\n    }\n    return ret >> 1;\n  }\n\n  inline tcost_t reduced_cost(int u, int v, const Edge& e) const {\n    return tcost_t(potential[u]) + potential[v] - e.cost;\n  }\n\n  void rematch(int v, int w) {\n    int t = mate[v]; mate[v] = w;\n    if (mate[t] != v) return;\n    if (link[v].to == surface[link[v].to]) {\n      mate[t] = link[v].from;\n      rematch(mate[t], t);\n    } else {\n      int x = link[v].from, y = link[v].to;\n      rematch(x, y); rematch(y, x);\n    }\n  }\n\n  void fix_mate_and_base(int b) {\n    if (b <= N) return;\n    int bv = base[b], mv = node[bv].link[0].v, bmv = node[bv].link[0].b;\n    int d = (node[bmv].link[1].v == mate[mv]) ? 0 : 1;\n    while (1) {\n      int mv = node[bv].link[d].v, bmv = node[bv].link[d].b;\n      if (node[bmv].link[1 ^ d].v != mate[mv]) break;\n      fix_mate_and_base(bv); fix_mate_and_base(bmv);\n      bv = node[bmv].link[d].b;\n    }\n    fix_mate_and_base(base[b] = bv);\n    mate[b] = mate[bv];\n  }\n\n  void reset_time() {\n    time_current_ = 0; event1 = {Inf, 0};\n  }\n\n  void reset_blossom(int b) {\n    label[b] = kFree; link[b].from = 0; slack[b] = Inf; lazy[b] = 0;\n  }\n\n  void reset_all() {\n    label[0] = kFree; link[0].from = 0;\n    for (int v = 1; v <= N; ++v) { // should be optimized for sparse graphs.\n      if (label[v] == kOuter) potential[v] -= time_current_;\n      else {\n        int bv = surface[v];\n        potential[v] += lazy[bv];\n        if (label[bv] == kInner) potential[v] += time_current_ - time_created[bv];\n      }\n      reset_blossom(v);\n    }\n    for (int b = N + 1, r = B - unused_bid_idx_; r > 0 && b < S; ++b) if (base[b] != b) {\n      if (surface[b] == b) {\n        fix_mate_and_base(b);\n        if (label[b] == kOuter) potential[b] += (time_current_ - time_created[b]) << 1;\n        else if (label[b] == kInner) fix_blossom_potential<kInner>(b);\n        else fix_blossom_potential<kFree>(b);\n      }\n      heap2s.clear(b);\n      reset_blossom(b); --r;\n    }\n\n    que.clear();\n    reset_time(); heap2.clear();\n    heap3.clear(); heap4.clear();\n  }\n\n  void do_edmonds_search(int root) {\n    if (potential[root] == 0) return;\n    link_blossom(surface[root], {0, 0});\n    push_outer_and_fix_potentials(surface[root], 0);\n    for (bool augmented = false; !augmented; ) {\n      augmented = augment(root);\n      if (augmented) break;\n      augmented = adjust_dual_variables(root);\n    }\n    reset_all();\n  }\n\n  template <Label Lab>\n  inline cost_t fix_blossom_potential(int b) {\n    // Return the amount.\n    // (If v is an atom, the potential[v] will not be changed.)\n    cost_t d = lazy[b]; lazy[b] = 0;\n    if (Lab == kInner) {\n      cost_t dt = time_current_ - time_created[b];\n      if (b > N) potential[b] -= dt << 1;\n      d += dt;\n    }\n    return d;\n  }\n\n  template <Label Lab>\n  inline void update_heap2(int x, int y, int by, cost_t t) {\n    if (t >= slack[y]) return;\n    slack[y] = t; best_from[y] = x;\n    if (y == by) {\n      if (Lab != kInner) heap2.decrease_key(y, EdgeEvent(t + lazy[y], x, y));\n    } else {\n      int gy = group[y];\n      if (gy != y) {\n        if (t >= slack[gy]) return;\n        slack[gy] = t;\n      }\n      heap2s.decrease_key(by, gy, EdgeEvent(t, x, y));\n      if (Lab == kInner) return;\n      EdgeEvent m = heap2s.min(by);\n      heap2.decrease_key(by, EdgeEvent(m.time + lazy[by], m.from, m.to));\n    }\n  }\n\n  void activate_heap2_node(int b) {\n    if (b <= N) {\n      if (slack[b] < Inf) heap2.push(b, EdgeEvent(slack[b] + lazy[b], best_from[b], b));\n    } else {\n      if (heap2s.empty(b)) return;\n      EdgeEvent m = heap2s.min(b);\n      heap2.push(b, EdgeEvent(m.time + lazy[b], m.from, m.to));\n    }\n  }\n\n  void swap_blossom(int a, int b) {\n    // Assume that `b` is a maximal blossom.\n    swap(base[a], base[b]); if (base[a] == a) base[a] = b;\n    swap(heavy[a], heavy[b]); if (heavy[a] == a) heavy[a] = b;\n    swap(link[a], link[b]);\n    swap(mate[a], mate[b]);\n    swap(potential[a], potential[b]); swap(lazy[a], lazy[b]);\n    swap(time_created[a], time_created[b]);\n    for (int d = 0; d < 2; ++d) node[node[a].link[d].b].link[1 ^ d].b = b;\n    swap(node[a], node[b]);\n  }\n\n  void set_surface_and_group(int b, int sf, int g) {\n    surface[b] = sf, group[b] = g;\n    if (b <= N) return;\n    for (int bb = base[b]; surface[bb] != sf; bb = node[bb].next_b()) {\n      set_surface_and_group(bb, sf, g);\n    }\n  }\n\n  void merge_smaller_blossoms(int bid) {\n    int lb = bid, largest_size = 1;\n    for (int beta = base[bid], b = beta; ;) {\n      if (node[b].size > largest_size) largest_size = node[b].size, lb = b;\n      if ((b = node[b].next_b()) == beta) break;\n    }\n    for (int beta = base[bid], b = beta; ;) {\n      if (b != lb) set_surface_and_group(b, lb, b);\n      if ((b = node[b].next_b()) == beta) break;\n    }\n    group[lb] = lb;\n    if (largest_size > 1) {\n      surface[bid] = heavy[bid] = lb; \n      swap_blossom(lb, bid);\n    } else heavy[bid] = 0;\n  }\n\n  void contract(int x, int y, int eid) {\n    int bx = surface[x], by = surface[y]; assert(bx != by);\n    const int h = -(eid + 1);\n    link[surface[mate[bx]]].from = link[surface[mate[by]]].from = h;\n\n    int lca = -1;\n    while (1) {\n      if (mate[by] != 0) swap(bx, by);\n      bx = lca = surface[link[bx].from];\n      if (link[surface[mate[bx]]].from == h) break;\n      link[surface[mate[bx]]].from = h;\n    }\n\n    const int bid = unused_bid[--unused_bid_idx_]; assert(unused_bid_idx_ >= 0);\n    int tree_size = 0;\n    for (int d = 0; d < 2; ++d) {\n      for (int bv = surface[x]; bv != lca; ) {\n        int mv = mate[bv], bmv = surface[mv], v = mate[mv];\n        int f = link[v].from, t = link[v].to;\n        tree_size += node[bv].size + node[bmv].size;\n        link[mv] = {x, y};\n\n        if (bv > N) potential[bv] += (time_current_ - time_created[bv]) << 1;\n        if (bmv > N) heap4.erase(bmv);\n        push_outer_and_fix_potentials(bmv, fix_blossom_potential<kInner>(bmv));\n\n        node[bv].link[d] = {bmv, mv};\n        node[bmv].link[1 ^ d] = {bv, v}; node[bmv].link[d] = {bv = surface[f], f};\n        node[bv].link[1 ^ d] = {bmv, t};\n      }\n      node[surface[x]].link[1 ^ d] = {surface[y], y};\n      swap(x, y);\n    }\n    if (lca > N) potential[lca] += (time_current_ - time_created[lca]) << 1;\n    node[bid].size = tree_size + node[lca].size;\n    base[bid] = lca; link[bid] = link[lca]; mate[bid] = mate[lca];\n    label[bid] = kOuter;\n    surface[bid] = bid; time_created[bid] = time_current_;\n    potential[bid] = 0; lazy[bid] = 0;\n\n    merge_smaller_blossoms(bid); // O(n log n) time / Edmonds search\n  }\n\n  void link_blossom(int v, Link l) {\n    link[v] = {l.from, l.to};\n    if (v <= N) return;\n    int b = base[v]; link_blossom(b, l);\n    int pb = node[b].prev_b();\n    l = {node[pb].next_v(), node[b].prev_v()};\n    for (int bv = b; ; ) {\n      int bw = node[bv].next_b();\n      if (bw == b) break;\n      link_blossom(bw, l);\n      Link nl = {node[bw].prev_v(), node[bv].next_v()};\n      bv = node[bw].next_b();\n      link_blossom(bv, nl);\n    }\n  }\n\n  void push_outer_and_fix_potentials(int v, cost_t d) {\n    label[v] = kOuter;\n    if (v > N) {\n      for (int b = base[v]; label[b] != kOuter; b = node[b].next_b()) {\n        push_outer_and_fix_potentials(b, d);\n      }\n    } else {\n      potential[v] += time_current_ + d;\n      if (potential[v] < event1.time) event1 = {potential[v], v};\n      que.enqueue(v);\n    }\n  }\n\n  bool grow(int x, int y) {\n    int by = surface[y];\n    bool visited = (label[by] != kFree);\n    if (!visited) link_blossom(by, {0, 0});\n    label[by] = kInner; time_created[by] = time_current_; heap2.erase(by);\n    if (y != by) heap4.update(by, time_current_ + (potential[by] >> 1));\n    int z = mate[by];\n    if (z == 0) {\n      rematch(x, y); rematch(y, x);\n      return true;\n    }\n    int bz = surface[z];\n    if (!visited) link_blossom(bz, {x, y}); \n    else link[bz] = link[z] = {x, y};\n    push_outer_and_fix_potentials(bz, fix_blossom_potential<kFree>(bz));\n    time_created[bz] = time_current_; heap2.erase(bz);\n    return false;\n  }\n\n  void free_blossom(int bid) {\n    unused_bid[unused_bid_idx_++] = bid;\n    base[bid] = bid;\n  }\n\n  int recalculate_minimum_slack(int b, int g) {\n    // Return the destination of the best edge of blossom `g`.\n    if (b <= N) {\n      if (slack[b] >= slack[g]) return 0;\n      slack[g] = slack[b]; best_from[g] = best_from[b];\n      return b;\n    }\n    int v = 0;\n    for (int beta = base[b], bb = beta; ; ) {\n      int w = recalculate_minimum_slack(bb, g);\n      if (w != 0) v = w;\n      if ((bb = node[bb].next_b()) == beta) break;\n    }\n    return v;\n  }\n\n  void construct_smaller_components(int b, int sf, int g) {\n    surface[b] = sf, group[b] = g; // `group[b] = g` is unneeded.\n    if (b <= N) return;\n    for (int bb = base[b]; surface[bb] != sf; bb = node[bb].next_b()) {\n      if (bb == heavy[b]) {\n        construct_smaller_components(bb, sf, g);\n      } else {\n        set_surface_and_group(bb, sf, bb);\n        int to = 0;\n        if (bb > N) slack[bb] = Inf, to = recalculate_minimum_slack(bb, bb);\n        else if (slack[bb] < Inf) to = bb;\n        if (to > 0) heap2s.push(sf, bb, EdgeEvent(slack[bb], best_from[bb], to));\n      }\n    }\n  }\n\n  void move_to_largest_blossom(int bid) {\n    const int h = heavy[bid];\n    cost_t d = (time_current_ - time_created[bid]) + lazy[bid]; lazy[bid] = 0;\n    for (int beta = base[bid], b = beta; ;) {\n      time_created[b] = time_current_;\n      lazy[b] = d;\n      if (b != h) construct_smaller_components(b, b, b), heap2s.erase(bid, b);\n      if ((b = node[b].next_b()) == beta) break;\n    }\n    if (h > 0) swap_blossom(h, bid), bid = h;\n    free_blossom(bid);\n  }\n\n  void expand(int bid) {\n    int mv = mate[base[bid]];\n    move_to_largest_blossom(bid); // O(n log n) time / Edmonds search\n    Link old_link = link[mv];\n    int old_base = surface[mate[mv]], root = surface[old_link.to];\n    int d = (mate[root] == node[root].link[0].v) ? 1 : 0;\n    for (int b = node[old_base].link[d ^ 1].b; b != root; ) {\n      label[b] = kSeparated; activate_heap2_node(b); b = node[b].link[d ^ 1].b;\n      label[b] = kSeparated; activate_heap2_node(b); b = node[b].link[d ^ 1].b;\n    }\n    for (int b = old_base; ; b = node[b].link[d].b) {\n      label[b] = kInner;\n      int nb = node[b].link[d].b;\n      if (b == root) link[mate[b]] = old_link;\n      else link[mate[b]] = {node[b].link[d].v, node[nb].link[d ^ 1].v};\n      link[surface[mate[b]]] = link[mate[b]]; // fix tree links\n      if (b > N) {\n        if (potential[b] == 0) expand(b);\n        else heap4.push(b, time_current_ + (potential[b] >> 1));\n      }\n      if (b == root) break;\n      push_outer_and_fix_potentials(nb, fix_blossom_potential<kInner>(b = nb));\n    }\n  }\n\n  bool augment(int root) {\n    // Return true if an augmenting path is found.\n    while (!que.empty()) {\n      int x = que.dequeue(), bx = surface[x];\n      if (potential[x] == time_current_) {\n        if (x != root) rematch(x, 0);\n        return true;\n      }\n      for (int eid = ofs[x]; eid < ofs[x + 1]; ++eid) {\n        auto& e = edges[eid]; int y = e.to, by = surface[y];\n        if (bx == by) continue;\n        Label l = label[by];\n        if (l == kOuter) {\n          cost_t t = reduced_cost(x, y, e) >> 1; // < 2 * Inf\n          if (t == time_current_) {\n            contract(x, y, eid); bx = surface[x];\n          } else if (t < event1.time) {\n            heap3.emplace(t, x, eid);\n          }\n        } else {\n          tcost_t t = reduced_cost(x, y, e); // < 3 * Inf\n          if (t >= Inf) continue;\n          if (l != kInner) {\n            if (cost_t(t) + lazy[by] == time_current_) {\n              if (grow(x, y)) return true;\n            } else update_heap2<kFree>(x, y, by, t);\n          } else {\n            if (mate[x] != y) update_heap2<kInner>(x, y, by, t);\n          } \n        }\n      }\n    }\n    return false;\n  }\n\n  bool adjust_dual_variables(int root) {\n    // delta1 : rematch\n    cost_t time1 = event1.time;\n\n    // delta2 : grow\n    cost_t time2 = Inf;\n    if (!heap2.empty()) time2 = heap2.min().time;\n\n    // delta3 : contract : O(m log n) time / Edmonds search [ bottleneck (?) ]\n    cost_t time3 = Inf;\n    while (!heap3.empty()) {\n      EdgeEvent e = heap3.min();\n      int x = e.from, y = edges[e.to].to; // e.to is some edge id.\n      if (surface[x] != surface[y]) {\n        time3 = e.time;\n        break;\n      } else heap3.pop();\n    }\n\n    // delta4 : expand\n    cost_t time4 = Inf;\n    if (!heap4.empty()) time4 = heap4.min();\n\n    // -- events --\n    cost_t time_next = min(min(time1, time2), min(time3, time4));\n    assert(time_current_ <= time_next && time_next < Inf);\n    time_current_ = time_next;\n\n    if (time_current_ == event1.time) {\n      int x = event1.id;\n      if (x != root) rematch(x, 0);\n      return true;\n    }\n    while (!heap2.empty() && heap2.min().time == time_current_) {\n      int x = heap2.min().from, y = heap2.min().to;\n      if (grow(x, y)) return true; // `grow` function will call `heap2.erase(by)`.\n    }\n    while (!heap3.empty() && heap3.min().time == time_current_) {\n      int x = heap3.min().from, eid = heap3.min().to;\n      int y = edges[eid].to; heap3.pop();\n      if (surface[x] == surface[y]) continue;\n      contract(x, y, eid);\n    }\n    while (!heap4.empty() && heap4.min() == time_current_) {\n      int b = heap4.argmin(); heap4.pop();\n      expand(b);\n    }\n    return false;\n  }\n\nprivate:\n  void initialize() {\n    que = Queue<int>(N);\n    mate.assign(S, 0);\n    link.assign(S, {0, 0});\n    label.assign(S, kFree);\n    base.resize(S); for (int u = 1; u < S; ++u) base[u] = u;\n    surface.resize(S); for (int u = 1; u < S; ++u) surface[u] = u;\n\n    potential.resize(S);\n    node.resize(S); for (int b = 1; b < S; ++b) node[b] = Node(b);\n\n    unused_bid.resize(B); for (int i = 0; i < B; ++i) unused_bid[i] = N + B - i;\n    unused_bid_idx_ = B;\n\n    // for O(nm log n) implementation\n    reset_time();\n    time_created.resize(S);\n    slack.resize(S); for (int i = 0; i < S; ++i) slack[i] = Inf;\n    best_from.assign(S, 0);\n    heavy.assign(S, 0);\n    lazy.assign(S, 0);\n    group.resize(S); for (int i = 0; i < S; ++i) group[i] = i;\n  }\n\n  void set_potential() {\n    for (int u = 1; u <= N; ++u) {\n      cost_t max_c = 0;\n      for (int eid = ofs[u]; eid < ofs[u + 1]; ++eid) {\n        max_c = max(max_c, edges[eid].cost);\n      }\n      potential[u] = max_c >> 1;\n    }\n  }\n\n  void find_maximal_matching() {\n    // Find a maximal matching naively.\n    for (int u = 1; u <= N; ++u) if (!mate[u]) {\n      for (int eid = ofs[u]; eid < ofs[u + 1]; ++eid) {\n        auto& e = edges[eid]; int v = e.to;\n        if (mate[v] > 0 || reduced_cost(u, v, e) > 0) continue;\n        mate[u] = v; mate[v] = u;\n        break;\n      }\n    }\n  }\n\nprivate:\n  const int N, B, S; // N = |V|, B = (|V| - 1) / 2, S = N + B + 1\n  vector<int> ofs;\n  vector<Edge> edges;\n\n  Queue<int> que;\n  vector<int> mate, surface, base;\n  vector<Link> link;\n  vector<Label> label;\n  vector<cost_t> potential;\n\n  vector<int> unused_bid; int unused_bid_idx_;\n  vector<Node> node;\n\n  // for O(nm log n) implementation\n  vector<int> heavy, group;\n  vector<cost_t> time_created, lazy, slack;\n  vector<int> best_from;\n\n  cost_t time_current_;\n  Event event1;\n  ModifiableHeap<EdgeEvent> heap2;\n  ModifiableHeaps<EdgeEvent> heap2s;\n  FastHeap<EdgeEvent> heap3;\n  ModifiableHeap<cost_t> heap4;\n};\n\nusing MWM = MaximumWeightedMatching<int>;\nusing Edge = MWM::InputEdge;\n\n\nconst ll MX=10000100;\n\nint main(){\n  vector<bool> prime(MX,true);\n  prime[0]=prime[1]=false;\n  for(ll i=2;i*i<MX;i++){\n    for(ll j=2;i*j<MX;j++){prime[i*j]=false;}\n  }\n  ll N;\n  cin>>N;\n  vector<bool> A(MX,false);\n  for(int i=0;i<N;i++){\n    ll x;\n    cin>>x;\n    A[x]=true;\n  }\n  vector<ll> pt;\n  for(ll i=1;i<MX;i++){\n    if(A[i-1]!=A[i]){pt.push_back(i);}\n  }\n  ll M=pt.size();\n  vector<Edge> E;\n  for(int i=0;i<M;i++){\n    for(int j=0;j<i;j++){\n      if((pt[i]-pt[j])&1){\n        if(prime[pt[i]-pt[j]]){E.push_back({j+1,i+1,4});}\n        else{E.push_back({j+1,i+1,2});}\n      }\n      else{\n        E.push_back({j+1,i+1,3});\n      }\n    }\n  }\n  MaximumWeightedMatching<int> MM(M,E);\n  cout<<5LL*M/2-MM.maximum_weighted_matching()<<endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\nconst int MAX1=100;\nconst int MAX2=10000000;\nconst int INF=0x3f3f3f3f;\nint n,a[MAX1+5],p[MAX2+5],chk[MAX1*2+5],ans;\nvector<int> cx,c[2],seq;\nvector<pii> conn[2*MAX1+5];\nint dfs(int x,int y){\n    int flow=0;\n    if(x==y) return INF;\n    chk[x]=1;\n    for(int i=0;i<conn[x].size();i++) if(chk[conn[x][i].first]==0&&conn[x][i].second>0){\n        int t=dfs(conn[x][i].first,y);\n        if(t>0){\n            flow=min(t,conn[x][i].second);\n            seq.push_back(x);\n            break;\n        }\n    }\n    chk[x]=0;\n    return flow;\n}\nint fflow(int x,int y){\n    seq.clear(); seq.push_back(y);\n    int flow=dfs(x,y);\n    for(int i=0;i<seq.size()-1;i++) {\n        int a=seq[i+1],b=seq[i];\n        for(int j=0;j<conn[a].size();j++) if(conn[a][j].first==b) conn[a][j].second-=flow;\n        for(int j=0;j<conn[b].size();j++) if(conn[b][j].first==a) conn[b][j].second+=flow;\n    }\n    return flow;\n}\nint main(){\n    scanf(\"%d\",&n);\n    for(int i=0;i<n;i++) scanf(\"%d\",&a[i]);\n    cx.push_back(a[0]), cx.push_back(a[0]+1);\n    for(int i=1;i<n;i++){\n        if(cx[cx.size()-1]==a[i]) cx.pop_back();\n        else cx.push_back(a[i]);\n        cx.push_back(a[i]+1);\n    }\n    for(int i=2;i<=MAX2;i++){\n        if(p[i]==0){\n            p[i]=1;\n            if(i<=10000) {for(int j=i*i;j<=MAX2;j+=i) p[j]=-1;}\n        }\n    }\n    p[2]=-1;\n    for(int i=0;i<cx.size();i++) c[cx[i]%2].push_back(cx[i]);\n    for(int i=0;i<c[0].size();i++) for(int j=0;j<c[1].size();j++) if(p[abs(c[0][i]-c[1][j])]==1) {\n        conn[i].push_back(make_pair(c[0].size()+j,1));\n        conn[c[0].size()+j].push_back(make_pair(i,0));\n    }\n    for(int i=0;i<c[0].size();i++) {\n        conn[c[0].size()+c[1].size()].push_back(make_pair(i,1));\n        conn[i].push_back(make_pair(c[0].size()+c[1].size(),0));\n    }\n    for(int i=0;i<c[1].size();i++) {\n        conn[i+c[1].size()].push_back(make_pair(c[0].size()+c[1].size()+1,1));\n        conn[c[0].size()+c[1].size()+1].push_back(make_pair(i+c[1].size(),0));\n    }\n    while(fflow(c[0].size()+c[1].size(),c[0].size()+c[1].size()+1)) ans++;\n    printf(\"%d\\n\",c[0].size()+c[1].size()-ans+(c[0].size()-ans)%2);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define maxn 210\n#define maxm 10000010\nconst int lim=1e7;\ntemplate <typename T>inline T read()\n{\n    register T sum=0;\n    register char cc=getchar();\n    int sym=1;\n    while(cc!='-'&&(cc>'9'||cc<'0'))cc=getchar();\n    if(cc=='-')sym=-1,cc=getchar();\n    sum=sum*10+cc-'0';\n    cc=getchar();\n    while(cc>='0'&&cc<='9')sum=sum*10+cc-'0',cc=getchar();\n    return sym*sum;\n}\ntemplate <typename T>inline T read(T &a)\n{\n    a=read<T>();\n    return a;\n}\ntemplate <typename T,typename... Others> inline void read(T& a, Others&... b)\n{\n    a=read(a);\n\tread(b...);\n}\nstruct Edge\n{\n\tint v;\n\tEdge *next;\n\tEdge(int a=0,Edge *b=NULL)\n\t{\n\t\tv=a;\n\t\tnext=b;\n\t}\n}*head[maxn];\nint n,mx,tim,cnt,cnt1,cnt2,ans,maxflow,a[maxm];\nint L[maxn],R[maxn],p[maxm],vis[maxn],flg[maxm],match[maxn];\nbool Match(int k)\n{\n\tfor(Edge *i=head[k];i!=NULL;i=i->next)\n\t{\n\t\tif(vis[i->v]==tim)\n\t\t\tcontinue;\n\t\tvis[i->v]=tim;\n\t\tif(!match[i->v]||Match(match[i->v]))\n\t\t{\n\t\t\tmatch[i->v]=k;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\nvoid init()\n{\n\tflg[0]=flg[1]=true;\n\tfor(int i=2;i<=lim;i++)\n\t{\n\t\tif(!flg[i])\n\t\t\tp[++cnt]=i;\n\t\tfor(int j=1;j<=cnt&&p[j]*i<=lim;j++)\n\t\t{\n\t\t\tflg[i*p[j]]=true;\n\t\t\tif(i%p[j]==0)\n\t\t\t\tbreak;\n\t\t}\n\t}\n}\nint main()\n{\n\tinit();\n\tread(n);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint x;\n\t\tread(x);\n\t\ta[x]+=1;\n\t\tmx=max(mx,x);\n\t}\n\tfor(int i=1;i<=mx+1;i++)\n\t{\n\t\tif(a[i]!=a[i-1])\n\t\t{\n\t\t\tif(i&1)\n\t\t\t\tL[++cnt1]=i;\n\t\t\telse\n\t\t\t\tR[++cnt2]=i;\n\t\t}\n\t}\n\tfor(int i=1;i<=cnt1;i++)\n\t\tfor(int j=1;j<=cnt2;j++)\n\t\t\tif(!flg[abs(L[i]-R[j])])\n\t\t\t\thead[i]=new Edge(j,head[i]);\n\tfor(int i=1;i<=cnt1;i++)\n\t{\n\t\ttim+=1;\n\t\tmaxflow+=Match(i);\n\t}\n\tans=maxflow;\n\tans+=(cnt1-maxflow)/2*2+(cnt2-maxflow)/2*2;\n\tans+=((cnt1-maxflow)&1)*3;\n\tprintf(\"%d\\n\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define maxn 10000007\n#define maxm 2001\n#define reg register\nusing namespace std;\nbool not_prime[maxn];\nint n,  pos[maxm], d[maxn], prime[maxn],a[maxm], m, cnt, siz[maxm]; \nint nt[maxm], fi[maxm], go[maxm], vis[maxm], visx[maxm], link[maxm]; \ninline int  read() {\n    reg int s = 0, t = 0; reg char ch = getchar();\n    while(ch > '9' || ch < '0') t |= ch == '-', ch = getchar();\n    while(ch >= '0' && ch <= '9') s = (s << 1) + (s << 3) + (ch ^ 48), ch = getchar();\n    return t ? -s : s;\n}\nvoid add(int x, int y){\n    nt[++cnt] = fi[x]; fi[x] = cnt; go[cnt] = y;\n    nt[++cnt] = fi[y]; fi[y] = cnt; go[cnt] = x;\n}\nvoid col(int x){\n    for(int i = fi[x]; i; i = nt[i]){\n        int v = go[i]; \n        if(!vis[v]) {\n            vis[v] = 3 - vis[x]; col(v);\n        }\n    }\n}\nint find(int x, int tim){\n    if(visx[x] == tim) return 0; visx[x] = tim;\n    for(int i = fi[x]; i; i = nt[i]){\n        int v =  go[i];\n        if(!link[v] || find(link[v], tim)){\n            link[v] = x; return 1;\n        }\n    }\n    return 0;\n}\nint main(){\n    n = read(); int ans = 0;\n    for(int i = 1; i <= n; i++) \n        pos[i] = read(), d[pos[i]] = 1; a[0] = -1;\n    sort(pos + 1, pos + n + 1);\n    for(int i = 1; i <= n; i++) {\n        if(!d[pos[i] - 1] && a[m] != pos[i]) a[++m] = pos[i];\n        if(!d[pos[i] + 1]) a[++m] = pos[i] + 1; \n    }\n    for(int i = 2; i < maxn; i++) {\n        if(!not_prime[i]) prime[++cnt] = i;\n        for(int j = 1; j <= cnt && prime[j] * i < maxn; j++){\n            not_prime[i * prime[j]] = 1;\n            if(i % prime[j] == 0) break;\n        }\n    }\n    not_prime[2] = 1; cnt = 0; not_prime[1] = 1;\n    for(int i = 1; i <= m; i++)\n        for(int j = i + 1; j <= m; j++)\n            if(!not_prime[a[j] - a[i]]) add(i, j); \n    for(int i = 1; i <= m; i++)\n        if(!vis[i]) { vis[i] = 1; col(i); }\n    for(int i = 1; i <= m; i++)\n        if(vis[i] == 1) ans += (link[i] = find(i, i));       \n    int sum1 = 0, sum2 = 0;\n    for(int i = 1; i <= m; i++){\n        if(link[i]) continue; \n        sum1 += (a[i] & 1);\n        sum2 += (a[i] % 2 == 0);\n    }\n    if(sum1 & 1) ans += 3;\n    ans += sum1 / 2 * 2 + sum2 / 2 * 2;\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#define C\ntypedef long long readtype;\n\n/* Header {{{ */\n#ifdef C\n#include <stdio.h>\n#include <math.h>\n#include <string.h>\n#define isdigit(a) ((a) >= '0' && (a) <= '9' ? true : false)\ntemplate<typename type> type abs(type a) { return a < 0 ? -a : a; }\ntemplate<typename type> type min(type a, type b) { return a < b ? a : b; }\ntemplate<typename type> type beMin(type &a, type b) { return a = (a < b ? a : b); }\ntemplate<typename type> type max(type a, type b) { return a > b ? a : b; }\ntemplate<typename type> type beMax(type &a, type b) { return a = (a > b ? a : b); }\ntemplate<typename type> void swap(type &a, type &b) { type c; c = a; a = b; b = c; }\n#endif\n\n#ifdef Cpp\n#include <bits/stdc++.h>\nusing namespace std;\n#endif\n\ntypedef long long var;\n\nreadtype read() {\n  readtype a = 0, c = getchar(), s = 0;\n  while (!isdigit(c)) s |= c == '-', c = getchar();\n  while (isdigit(c)) a = a * 10 + c - 48, c = getchar();\n  return s ? -a : a;\n}\n/* }}} */\n\nconst int N = 1103;\nconst int X = 1e7;\nconst int INF = 0x3f3f3f3f;\n\nint n, x[N];\nbool mark[X + 10];\nint cnt, prime[X];\nbool notprime[X + 10];\nint top, fi[N], ne[N * N], to[N * N], fl[N * N];\nint S, T;\nint head, tail, q[N], deep[N];\nint cur[N];\n\nvoid add(int u, int v, int w);\nint Dinic();\nbool BFS();\nint DFS(int t, int f);\n\nint main() {\n#ifndef ONLINE_JUDGE\n  freopen(\"arc080d.in\", \"r\", stdin);\n  freopen(\"arc080d.out\", \"w\", stdout);\n#endif\n  notprime[1] = true;\n  for (int i = 2; i <= X; ++i) {\n    if (!notprime[i]) prime[++cnt] = i;\n    for (int j = 1; j <= cnt; ++j) {\n      if (prime[j] * i > X) break;\n      notprime[prime[j] * i] = true;\n      if (!(i % prime[j])) break;\n    }\n  }\n  for (int i = read(); i >= 1; --i) mark[read()] = true;\n  for (int i = 1; i <= X + 1; ++i) {\n    if (mark[i] ^ mark[i - 1]) x[++n] = i;\n  }\n  S = n + 1, T = n + 2;\n  int oddNum = 0, evenNum = 0;\n  for (int i = 1; i <= n; ++i) {\n    if (!(x[i] % 2)) add(i, T, 1), evenNum++;\n    else add(S, i, 1), oddNum++;\n  }\n  for (int i = 1; i <= n; ++i) {\n    if (!(x[i] % 2)) continue;\n    for (int j = 1; j <= n; ++j) {\n      if (x[j] % 2 || notprime[abs(x[i] - x[j])]) continue;\n      add(i, j, 1);\n      // printf(\"%d %d %d\\n\", x[i], x[j], x[i] - x[j]);\n    }\n  }\n\n  /*\n  for (int i = 1; i <= n; ++i) printf(\"%d \", x[i]);\n  puts(\"\");\n  */\n\n  int k = Dinic();\n  // printf(\"%d\\n\", k);\n  int res = k + ((evenNum - k) / 2 + (oddNum - k) / 2) * 2 + ((evenNum - k) % 2) * 3;\n  printf(\"%d\\n\", res);\n  return 0;\n}\n\nvoid add(int u, int v, int w) {\n  ne[++top] = fi[u], fi[u] = top, to[top] = v, fl[top] = w;\n  ne[++top] = fi[v], fi[v] = top, to[top] = u, fl[top] = 0;\n  // printf(\"%d %d %d\\n\", u, v, w);\n}\n\nint Dinic() {\n  int res = 0;\n  while (BFS()) {\n    for (int i = 1; i <= T; ++i) cur[i] = fi[i];\n    res += DFS(S, INF);\n  }\n  return res;\n}\n\nbool BFS() {\n  memset(deep, 0, sizeof(deep));\n  q[head = tail = 1] = S;\n  deep[S] = 1;\n  while (head <= tail) {\n    int f = q[head++];\n    for (int i = fi[f]; i; i = ne[i]) {\n      if (deep[to[i]] || !fl[i]) continue;\n      deep[to[i]] = deep[f] + 1;\n      q[++tail] = to[i];\n    }\n  }\n  return deep[T];\n}\n\nint DFS(int t, int f) {\n  if (t == T) return f;\n  int sumflow = 0;\n  for (int &i = cur[t]; i; i = ne[i]) {\n    if (deep[to[i]] != deep[t] + 1 || !fl[i]) continue;\n    int tflow = DFS(to[i], min(fl[i], f - sumflow));\n    sumflow += tflow;\n    fl[i] -= tflow, fl[i ^ 1] += tflow;\n  }\n  return sumflow;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ninline void read(int &x){\n    char ch;bool ok;\n    for(ok=0,ch=getchar();!isdigit(ch);ch=getchar())if(ch=='-')ok=1;\n    for(x=0;isdigit(ch);x=x*10+ch-'0',ch=getchar());if(ok)x=-x;\n}\n#define rg register\nconst int maxn=210;bool vis[maxn];\nint f[maxn],n,ans,a[maxn],mp[maxn][maxn],b[maxn],tot1,tot2,x[maxn];\nbool check(int x){\n    if((!(x&1))||x==1)return 0;\n    int n=sqrt(x);\n    for(rg int i=2;i<=n;i++)\n        if(!(x%i))return 0;\n    return 1;\n}\ninline bool dfs(int x){\n    for(rg int i=1;i<=tot2;i++)\n        if(!vis[i]&&mp[x][i]){\n            vis[i]=1;\n            if(!f[i]||dfs(f[i]))return f[i]=x,1;\n        }\n    return 0;\n}\nint main(){\n    read(n);\n    for(rg int i=1;i<=n;i++)read(x[i]);\n    if(n==1){printf(\"3\\n\");return 0;}\n    for(rg int i=1;i<=n;i++){\n        if(x[i+1]-x[i]!=1||i==n){\n            if((x[i]+1)%2==0)a[++tot1]=x[i]+1;\n            else b[++tot2]=x[i]+1;\n        }\n        if(x[i]-x[i-1]!=1||i==1){\n            if(x[i]&1)b[++tot2]=x[i];\n            else a[++tot1]=x[i];\n        }\n    }\n    for(rg int i=1;i<=tot1;i++)\n        for(rg int j=1;j<=tot2;j++)\n            if(check(abs(a[i]-b[j])))mp[i][j]=1;\n    for(rg int i=1;i<=tot1;i++){\n        memset(vis,0,sizeof vis);\n        if(dfs(i))ans++;\n    }\n    printf(\"%d\\n\",ans+(tot1-ans)/2*2+(tot2-ans)/2*2+(tot1-ans)%2*3);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntemplate< typename T = int >\nT Hungarian(vector< vector< T > > &A)\n{\n  const T infty = numeric_limits< T >::max();\n  const int N = (int) A.size() - 1;\n  const int M = (int) A[0].size() - 1;\n  vector< int > P(M + 1), way(M + 1);\n  vector< T > U(N + 1, 0), V(M + 1, 0), minV;\n  vector< bool > used;\n\n  for(int i = 1; i <= N; i++) {\n    P[0] = i;\n    minV.assign(M + 1, infty);\n    used.assign(M + 1, false);\n    int j0 = 0;\n    while(P[j0] != 0) {\n      int i0 = P[j0], j1 = 0;\n      used[j0] = true;\n      T delta = infty;\n      for(int j = 1; j <= M; j++) {\n        if(used[j]) continue;\n        T curr = A[i0][j] - U[i0] - V[j];\n        if(curr < minV[j]) minV[j] = curr, way[j] = j0;\n        if(minV[j] < delta) delta = minV[j], j1 = j;\n      }\n      for(int j = 0; j <= M; j++) {\n        if(used[j]) U[P[j]] += delta, V[j] -= delta;\n        else minV[j] -= delta;\n      }\n      j0 = j1;\n    }\n    do {\n      P[j0] = P[way[j0]];\n      j0 = way[j0];\n    } while(j0 != 0);\n  }\n  return (-V[0]);\n}\n\n\nconst int LIM = (int) 1e7;\nbool prime[LIM + 1];\n\nint main()\n{\n  prime[0] = prime[1] = true;\n  for(int i = 2; i * i <= LIM; i++) {\n    if(!prime[i]) {\n      for(int j = i + i; j <= LIM; j += i) {\n        prime[j] = true;\n      }\n    }\n  }\n  prime[2] = true;\n\n  int N;\n  cin >> N;\n  vector< int > vs;\n  for(int i = 0; i < N; i++) {\n    int x;\n    cin >> x;\n    if(vs.empty() || vs.back() + 1 != x) {\n      vs.emplace_back(x - 1);\n      vs.emplace_back(x);\n    } else {\n      ++vs.back();\n    }\n  }\n\n  vector< int > latte, malta;\n  for(auto &p : vs) {\n    if(p & 1) latte.emplace_back(p);\n    else malta.emplace_back(p);\n  }\n\n  int ret = 0;\n\n  if(!latte.empty() && !malta.empty()) {\n    vector< vector< int > > mat(latte.size(), vector< int >(malta.size(), 0));\n    for(int i = 0; i < latte.size(); i++) {\n      for(int j = 0; j < malta.size(); j++) {\n        if(!prime[abs(latte[i] - malta[j])]) {\n          mat[i][j] = -1;\n        }\n      }\n    }\n    ret = -Hungarian(mat);\n  }\n\n  int beet1 = latte.size() - ret;\n  int beet2 = malta.size() - ret;\n  ret += beet1 / 2 * 2;\n  ret += beet2 / 2 * 2;\n  ret += beet1 % 2 * 3;\n  cout << ret << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\nconst int maxn=103;\nconst int maxt=10000007;\n\nint n,a[maxn],pr[maxt],sz,N,o[maxn],e[maxn],szo,sze,match[maxn];\nbool np[maxt],vis[maxn];\n\nint dfs(int x){\n\tfor(int i=1;i<=sze;++i){\n\t\tif(!vis[i]&&!np[abs(e[i]-o[x])]){\n\t\t\tvis[i]=true;\n\t\t\tif(!match[i]||dfs(match[i])){\n\t\t\t\tmatch[i]=x;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nvector<int> v;\nbool flag[maxt];\nint main(){\n\tscanf(\"%d\",&n);\n\ta[0]=-1;\n\tfor(int i=1;i<=n;++i){\n\t\tscanf(\"%d\",&a[i]);\n\t\tflag[a[i]]=true;\n\t}\n\tfor(int i=1;i<maxt;++i){\n\t\tif((flag[i]^flag[i-1])==1)\n\t\t\tv.push_back(i);\n\t}\n\tnp[1]=1;\n\tfor(int i=2;i<maxt;++i){\n\t\tif(!np[i])\n\t\t\tpr[sz++]=i;\n\t\tfor(int j=0;j<sz&&1ll*pr[j]*i<maxt;++j){\n\t\t\tnp[pr[j]*i]=1;\n\t\t\tif(i%pr[j]==0)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\t--sz;N=v.size();\n//\tfor(int i=0;i<N;++i)\n//\t\tprintf(\"%d \",v[i]);\n//\tputs(\"\");\n\tfor(int i=0;i<N;++i){\n\t\tif(v[i]%2==0) o[++szo]=v[i];\n\t\telse e[++sze]=v[i];\n\t}\n\tint  k=0;\n\tfor(int i=1;i<=szo;++i){\n\t\tmemset(vis,0,sizeof(vis));\n\t\tif(dfs(i)) ++k;\n\t}\n\tsze-=k;szo-=k;\n//\tprintf(\"%d %d %d *\\n\",k,sze,szo);\n\tint res=k+((sze/2)+(szo/2))*2+(sze%2)*3;\n\tprintf(\"%d\\n\",res);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define ui unsigned int\n#define ull unsigned long long\n#define db double\n#define ld long double\n#define pii pair<ll,int>\n#define X first\n#define Y second\n#define mp make_pair\n#define pb push_back\n#define vi vector<int>\n#define vii vector<vi>\n#define lb lower_bound\n#define rep(i,a,b) for(int i=(a);i<=(b);++i)\n#define per(i,b,a) for(int i=(b);i>=(a);--i)\n#define rep0(i,a,b) for(int i=(a);i<(b);++i)\n#define fore(i,a) for(int i=0;i<a.size();++i)\n#define gc() getchar()\n#define ls x<<1,l,m\n#define rs x<<1|1,m+1,r\ninline int rd()\n{\n\tint x=0;char c=gc();while(!isdigit(c))c=gc();\n\twhile(isdigit(c))x=x*10+c-48,c=gc();return x;\n}\nconst int N=205,M=1e7+10;\nint n,cc,tt,a[N],b[M],vis[M],pr[M],hd[N],vv[N],lk[N];\nstruct E{int v,nxt;}e[N*N];\ninline void add(int u,int v){e[++tt]=(E){v,hd[u]};hd[u]=tt;}\nvoid init(int n)\n{\n\tvis[1]=1;\n\trep(i,2,n)\n\t{\n\t\tif(!vis[i])pr[++cc]=i;\n\t\tfor(int j=1;j<=cc&&1ll*i*pr[j]<=n;j++)\n\t\t{\n\t\t\tvis[i*pr[j]]=1;\n\t\t\tif(i%pr[j]==0)break;\n\t\t}\n\t}\n\tvis[2]=1;\n}\nbool dfs(int x)\n{\n\tfor(int i=hd[x],y;i;i=e[i].nxt)if(!vv[y=e[i].v])\n\t{\n\t\tvv[y]=1;\n\t\tif(!lk[y]||dfs(lk[y])){lk[y]=x;return 1;}\n\t}\n\treturn 0;\n}\nint main()\n{\n\tinit(1e7+5);n=rd();\n\trep(i,1,n)a[i]=rd(),b[a[i]]^=1;\n\tn=0;rep0(i,1,M)if(b[i]!=b[i-1])a[++n]=i;\n\tint s=0,n1=0,n2=0;\n\trep(i,1,n)if(a[i]&1)n1++;else n2++;\n\trep(i,1,n)rep(j,i+1,n)if(!vis[abs(a[i]-a[j])])add(i,j),add(j,i);\n\trep(i,1,n)if(a[i]&1){memset(vv,0,sizeof(vv));s+=dfs(i);}\n\tn1-=s;s=n-s+(n1&1);printf(\"%d\\n\",s);return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n \nusing namespace std;\nusing namespace __gnu_pbds;\n \n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define fbo find_by_order\n#define ook order_of_key\n \ntypedef long long ll;\ntypedef pair<int,int> ii;\ntypedef vector<int> vi;\ntypedef long double ld; \ntypedef tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> pbds;\ntypedef set<int>::iterator sit;\ntypedef map<int,int>::iterator mit;\ntypedef vector<int>::iterator vit;\n\nconst int MX = 255;\nconst int INF = int(1e9);\n\nstruct MaxFlow //by yutaka1999, have to define INF and MX (the Max number of vertices)\n{\n\tstruct edge\n\t{\n\t\tint to,cap,rev;\n\t\tedge(int to=0,int cap=0,int rev=0):to(to),cap(cap),rev(rev){}\n\t};\n\tvector <edge> vec[MX];\n\tint level[MX];\n\tint iter[MX];\n\t\n\tvoid addedge(int s,int t,int c) //adds an edge of cap c to the flow graph\n\t{\n\t\tint S=vec[s].size(),T=vec[t].size();\n\t\tvec[s].push_back(edge(t,c,T));\n\t\tvec[t].push_back(edge(s,0,S));\n\t}\n\tvoid bfs(int s)\n\t{\n\t\tmemset(level,-1,sizeof(level));\n\t\tqueue <int> que;\n\t\tlevel[s] = 0;\n\t\tque.push(s);\n\t\twhile (!que.empty())\n\t\t{\n\t\t\tint v = que.front();que.pop();\n\t\t\tfor(int i=0;i<vec[v].size();i++)\n\t\t\t{\n\t\t\t\tedge&e=vec[v][i];\n\t\t\t\tif (e.cap>0&&level[e.to]<0)\n\t\t\t\t{\n\t\t\t\t\tlevel[e.to]=level[v]+1;\n\t\t\t\t\tque.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tll flow_dfs(int v,int t,ll f)\n\t{\n\t\tif (v==t) return f;\n\t\tfor(int &i=iter[v];i<vec[v].size();i++)\n\t\t{\n\t\t\tedge &e=vec[v][i];\n\t\t\tif (e.cap>0&&level[v]<level[e.to])\n\t\t\t{\n\t\t\t\tll d=flow_dfs(e.to,t,min(f,ll(e.cap)));\n\t\t\t\tif (d>0)\n\t\t\t\t{\n\t\t\t\t\te.cap-=d;\n\t\t\t\t\tvec[e.to][e.rev].cap+=d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tll maxflow(int s,int t) //finds max flow using dinic from s to t\n\t{\n\t\tll flow = 0;\n\t\twhile(1)\n\t\t{\n\t\t\tbfs(s);\n\t\t\tif (level[t]<0) return flow;\n\t\t\tmemset(iter,0,sizeof(iter));\n\t\t\twhile (1)\n\t\t\t{\n\t\t\t\tll f=flow_dfs(s,t,INF);\n\t\t\t\tif(f==0) break;\n\t\t\t\tflow += f;\n\t\t\t}\n\t\t}\n\t}\n};\n\nstruct NumberTheory\n{\n\tvector<ll> primes;\n\tvector<bool> prime;\n\tvector<ll> totient;\n\tvector<ll> sumdiv;\n\tvector<ll> bigdiv;\n\tvoid Sieve(ll n)\n\t{\n\t\tprime.assign(n+1, 1);\n\t\tprime[1] = false;\n\t\tfor(ll i = 2; i <= n; i++)\n\t\t{\n\t\t\tif(prime[i])\n\t\t\t{\n\t\t\t\tprimes.pb(i);\n\t\t\t\tfor(ll j = i*2; j <= n; j += i)\n\t\t\t\t{\n\t\t\t\t\tprime[j] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tll phi(ll x)\n\t{\n\t\tmap<ll,ll> pf;\n\t\tll num = 1; ll num2 = x;\n\t\tfor(ll i = 0; primes[i]*primes[i] <= x; i++)\n\t\t{\n\t\t\tif(x%primes[i]==0)\n\t\t\t{\n\t\t\t\tnum2/=primes[i];\n\t\t\t\tnum*=(primes[i]-1);\n\t\t\t}\n\t\t\twhile(x%primes[i]==0)\n\t\t\t{\n\t\t\t\tx/=primes[i];\n\t\t\t\tpf[primes[i]]++;\n\t\t\t}\n\t\t}\n\t\tif(x>1)\n\t\t{\n\t\t\tpf[x]++; num2/=x; num*=(x-1);\n\t\t}\n\t\tx = 1;\n\t\tnum*=num2;\n\t\treturn num;\n\t}\n\t\n\tbool isprime(ll x)\n\t{\n\t\tif(x==1) return false;\n\t\tfor(ll i = 0; primes[i]*primes[i] <= x; i++)\n\t\t{\n\t\t\tif(x%primes[i]==0) return false;\n\t\t}\n\t\treturn true;\n\t}\n\n\tvoid SievePhi(ll n)\n\t{\n\t\ttotient.resize(n+1);\n\t\tfor (int i = 1; i <= n; ++i) totient[i] = i;\n\t\tfor (int i = 2; i <= n; ++i)\n\t\t{\n\t\t\tif (totient[i] == i)\n\t\t\t{\n\t\t\t\tfor (int j = i; j <= n; j += i)\n\t\t\t\t{\n\t\t\t\t\ttotient[j] -= totient[j] / i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvoid SieveSumDiv(ll n)\n\t{\n\t\tsumdiv.resize(n+1);\n\t\tfor(int i = 1; i <= n; ++i)\n\t\t{\n\t\t\tfor(int j = i; j <= n; j += i)\n\t\t\t{\n\t\t\t\tsumdiv[j] += i;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tll getPhi(ll n)\n\t{\n\t\treturn totient[n];\n\t}\n\t\n\tll getSumDiv(ll n)\n\t{\n\t\treturn sumdiv[n];\n\t}\n\t\n\tll modpow(ll a, ll b, ll mod)\n\t{\n\t\tll r = 1;\n\t\tif(b < 0) b += mod*100000LL;\n\t\twhile(b)\n\t\t{\n\t\t\tif(b&1) r = (r*a)%mod;\n\t\t\ta = (a*a)%mod;\n\t\t\tb>>=1;\n\t\t}\n\t\treturn r;\n\t}\n\t\n\tll inv(ll a, ll mod)\n\t{\n\t\treturn modpow(a, mod - 2, mod);\n\t}\n\t\n\tll invgeneral(ll a, ll mod)\n\t{\n\t\tll ph = phi(mod);\n\t\tph--;\n\t\treturn modpow(a, ph, mod);\n\t}\n\t\n\tvoid getpf(vector<ii>& pf, ll n)\n\t{\n\t\tfor(ll i = 0; primes[i]*primes[i] <= n; i++)\n\t\t{\n\t\t\tint cnt = 0;\n\t\t\twhile(n%primes[i]==0)\n\t\t\t{\n\t\t\t\tn/=primes[i]; cnt++;\n\t\t\t}\n\t\t\tif(cnt>0) pf.pb(ii(primes[i], cnt));\n\t\t}\n\t\tif(n>1)\n\t\t{\n\t\t\tpf.pb(ii(n, 1));\n\t\t}\n\t}\n\n\t//ll op;\n\tvoid getDiv(vector<ll>& div, vector<ii>& pf, ll n, int i)\n\t{\n\t\t//op++;\n\t\tll x, k;\n\t\tif(i >= pf.size()) return ;\n\t\tx = n;\n\t\tfor(k = 0; k <= pf[i].se; k++)\n\t\t{\n\t\t\tif(i==int(pf.size())-1) div.pb(x);\n\t\t\tgetDiv(div, pf, x, i + 1);\n\t\t\tx *= pf[i].fi;\n\t\t}\n\t}\n};\n\nMaxFlow mf;\nNumberTheory nt;\nset<int> S;\n\nvoid add(int z)\n{\n\tif(S.find(z)==S.end()) S.insert(z);\n\telse S.erase(z);\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tint n; cin>>n;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tint z; cin>>z;\n\t\tadd(z); add(z+1);\n\t}\n\tnt.Sieve(10000011);\n\tvi vec;\n\tfor(auto it=S.begin(); it != S.end(); it++) vec.pb(*it);\n\tnt.prime[2]=0;\n\tint s=MX-2; int e=MX-1;\n\tint o=0;\n\tfor(int i=0;i<vec.size();i++)\n\t{\n\t\tif(vec[i]&1) \n\t\t{\n\t\t\to++; mf.addedge(s,i,1);\n\t\t}\n\t\telse mf.addedge(i,e,1);\n\t\tfor(int j=i+1;j<vec.size();j++)\n\t\t{\n\t\t\tif(nt.prime[abs(vec[i]-vec[j])]) \n\t\t\t{\n\t\t\t\tif(vec[i]&1) mf.addedge(i,j,1);\n\t\t\t\telse mf.addedge(j,i,1);\n\t\t\t}\n\t\t}\t\n\t}\n\tint k=mf.maxflow(s,e);\n\tn=vec.size();\n\tcout<<k+((o-k)&1)*3+((o-k)/2+(n-o-k)/2)*2<<'\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <iostream>\n#include <algorithm>\n#define fo(i,a,b) for(int i=a;i<=b;i++)\n#define fod(i,a,b) for(int i=a;i>=b;i--)\n#define N 1005\nusing namespace std;\nint l[N],n,a[N],r[N],w[N],pr[2000005],f[N],a1[N][N];\nbool bz[10000005],bp[N];\nvoid prp()\n{\n\tfo(i,2,10000000)\n\t{\n\t\tif(!bz[i]) pr[++pr[0]]=i;\n\t\tfor(int j=1;j<=pr[0]&&i*pr[j]<=10000000;j++)\n\t\t{\n\t\t\tbz[i*pr[j]]=1;\n\t\t\tif(i%pr[j]==0) break;\n\t\t}\n\t}\n\tbz[2]=0;\n}\nbool find(int k)\n{\n\tfo(i,1,a1[k][0])\n\t{\n\t\tint p=a1[k][i];\n\t\tif(!bp[p])\n\t\t{\n\t\t\tbp[p]=1;\n\t\t\tif(!f[p]||find(f[p])) \n\t\t\t{\n\t\t\t\tf[p]=k;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nint main()\n{\n\tcin>>n;\n\tprp();\n\tfo(i,1,n) scanf(\"%d\",&a[i]);\n\tsort(a+1,a+n+1);\n\tfo(i,1,n) \n\t{\n\t\tif(i==1||a[i-1]!=a[i]-1) w[++w[0]]=i;\n\t\tif(a[i+1]!=a[i]+1) w[++w[0]]=i+1;\n\t}\n\tsort(w+1,w+w[0]+1);\n\tfo(i,1,w[0]) \n\t\tif(w[i]%2==0) l[++l[0]]=i;\n\t\telse r[++r[0]]=i;\n\tfo(i,1,l[0])\n\t{\n\t\tfo(j,1,r[0])\n\t\t{\n\t\t\tif(bz[abs(l[i]-r[j])]) a1[i][++a1[i][0]]=j;\n\t\t}\n\t}\n\tlong long s=0;\n\tfo(i,1,l[0]) \n\t{\n\t\tmemset(bp,0,sizeof(bp));\n\t\tif(find(i)) s++;\n\t}\n\tprintf(\"%lld\",s+2*(long long)((l[0]-s)/2)+2*(long long)((r[0]-s)/2)+3*(long long)((l[0]-s)%2));\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cstring>\n#include<queue>\n#include<cmath>\nusing namespace std;\nstruct Edge{\n\tint v,c,nxt;\n}e[600010];int tot=1;\nint first[210];\nvoid build(int u,int v,int c)\n{\n\te[++tot]=(Edge){v,c,first[u]};\n\tfirst[u]=tot;\n\treturn ;\n}\nvoid adde(int u,int v,int c)\n{\n\tbuild(u,v,c);\n\tbuild(v,u,c);\n\treturn ;\n}\nint S,T;\nqueue<int>q;\nint dep[210];\nbool bfs()\n{\n\tmemset(dep,0,sizeof(dep));\n\tdep[S]=1;q.push(S);\n\twhile(!q.empty())\n\t{\n\t\tint u=q.front();q.pop();\n\t\tfor(int i=first[u];i;i=e[i].nxt)\n\t\t\tif(e[i].c&&!dep[e[i].v])\n\t\t\t{\n\t\t\t\tdep[e[i].v]=dep[u]+1;\n\t\t\t\tq.push(e[i].v);\n\t\t\t}\n\t}\n\treturn dep[T]>0;\n}\nint cur[210];\nint dfs(int u,int flow)\n{\n\tif(u==T)return flow;\n\tfor(int &i=cur[u];i;i=e[i].nxt)\n\t\tif(e[i].c&&dep[u]+1==dep[e[i].v])\n\t\t{\n\t\t\tint d=dfs(e[i].v,min(flow,e[i].c));\n\t\t\tif(d){\n\t\t\t\te[i].c-=d;\n\t\t\t\te[i^1].c+=d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\treturn 0;\n}\nint dinic()\n{\n\tint ans=0;\n\twhile(bfs()){\n\t\tfor(int i=S;i<=T;i++)\n\t\t\tcur[i]=first[i];\n\t\tint d;\n\t\twhile(d=dfs(S,1e9))\n\t\t\tans+=d;\n\t}\n\treturn ans;\n}\nbool check(int a)\n{\n\tif(a<=2)return false;\n\tfor(int i=2;i*i<=a;i++)\n\t\tif(a%i==0)return false;\n\treturn true;\n}\nint x[210];\nint main()\n{\n\tint n;scanf(\"%d\",&n);\n\tint N=0,lst=-1;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint a;scanf(\"%d\",&a);\n\t\tif(lst+1<a){\n\t\t\tif(i>1)x[++N]=lst+1;\n\t\t\tx[++N]=a;\n\t\t}\n\t\tlst=a;\n\t}\n\tx[++N]=lst+1;\n\tS=0;T=N+1;\n\tint cntx=0,cnty=0;\n\tfor(int i=1;i<=N;i++)\n\t\tif(x[i]&1){\n\t\t\tadde(S,i,1);\n\t\t\tcntx++;\n\t\t}\n\t\telse{\n\t\t\tadde(i,T,1);\n\t\t\tcnty++;\n\t\t}\n\tfor(int i=1;i<=N;i++)\n\t\tif(x[i]&1){\n\t\t\tfor(int j=1;j<=N;j++)\n\t\t\t\tif(check(abs(x[i]-x[j])))\n\t\t\t\t\tadde(i,j,1);\n\t\t}\n\tint res=dinic();\n\tint ans=res+(cntx-res)+(cnty-res)+((cntx-res)&1);\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcount\n\n#define INF 1e16\n#define mod 1000000007\n\nint V;\nvector<int> G[300];\nint match[300];\nbool used[300];\n\nvoid init(int v){\n  V=v;\n  for(int i=0;i<V;i++)G[i].clear();\n}\n\nvoid add_edge(int u,int v){\n  G[u].push_back(v);\n  G[v].push_back(u);\n}\n\nbool dfs(int v){\n  used[v]=true;\n  for(int i=0; i<(int)G[v].size();i++){\n    int u=G[v][i],w=match[u];\n    if(w<0||(!used[w]&&dfs(w))){\n      match[v]=u;\n      match[u]=v;\n      return true;\n    }\n  }\n  return false;\n}\n\nint bipartite_match(){\n  int res=0;\n  memset(match,-1,sizeof(match));\n  for(int v=0; v<V;v++){\n    if(match[v]<0){\n      memset(used,0,sizeof(used));\n      if(dfs(v))res++;\n    }\n  }\n  return res;\n}\n\nbool isprime[10000010];\n\nint N;\nint x[110];\nvector<int> xb;\n\nint main(){\n  repl(i,2,10000010)isprime[i]=true;\n  repl(i,2,10000001){\n    if(!isprime[i])continue;\n    for(ll j=i*2;j<=10000000;j+=i)isprime[j]=false;\n  }\n  isprime[2]=false;\n  cin>>N;\n  rep(i,N){\n    cin>>x[i];\n  }\n  for(ll i=0;i<N;){\n    xb.push_back(x[i]-1);\n    ll j=i;\n    while(j<N&&x[j]-x[i]==j-i)j++;\n    xb.push_back(x[j-1]);\n    i=j;\n  }\n\n  N=xb.size();\n  init(N);\n  ll cnto=0,cnte=0;\n  rep(i,N)repl(j,i+1,N){\n    if(isprime[xb[j]-xb[i]]){\n      add_edge(i,j);\n    }\n  }\n  rep(i,N){\n    if(xb[i]%2==0) cnte++;\n    else cnto++;\n  }\n  ll k=bipartite_match();\n  cnte-=k; cnto-=k;\n\n  cout<<k+(cnte/2+cnto/2)*2+(cnte%2)*3<<endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \nconst int maxn = 1e7 + 700;\n \n \nint n,fre[maxn],p[220],ispr[maxn],even,odd,wrong;\nvector <int> edge[220],v2;\n \nbool fin(int u) {\n    if (fre[u]==wrong) return false;\n    fre[u]=wrong;\n    for (int j=0;j<edge[u].size();j++) {\n        int v=edge[u][j];\n       // cout<<u<<\" \"<<v<<endl;\n        if (p[v]==0 || fin(p[v])) {\n            p[v]=u;\n            return true;\n        }\n    }\n    return false;\n}\n \nint main() {\n  //  freopen(\"in.txt\",\"r\",stdin);\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    ispr[1]=1;\n    for (int i=2;i<maxn;i++)\n        if (ispr[i]==0) {\n            for (int j=i+i;j<maxn;j+=i) ispr[j]=1;\n        }\n    cin>>n;\n    for (int i=1;i<=n;i++) {\n        int x;\n        cin>>x;\n        fre[x]^=1;\n        fre[x+1]^=1;\n    }\n    even=0; odd=0; wrong=2;\n    for (int i=0;i<maxn;i++)\n        if (fre[i]==1) {\n            v2.push_back(i);\n            if (i%2==0) even++;\n            else odd++;\n        }\n    // for (int i=0;i<v2.size();i++) cout<<v2[i]<<\" \";\n   //  cout<<endl;\n   // cout<<\" \" <<even<<\" \"<<odd<<endl;\n    for (int i=0;i<v2.size();i++)\n        for (int j=0;j<v2.size();j++)\n            if (v2[i]%2==0 && v2[j]%2==1 && ispr[ abs(v2[j] - v2[i]) ]==0 && abs(v2[j] - v2[i])%2==1) {\n                edge[i].push_back(j);\n                edge[j].push_back(i);\n            }\n    int cnt=0;\n    for (int i=0;i<v2.size();i++) {\n        wrong++;\n        if (fin(i)) cnt++;\n    }\n    cout<< cnt + (even-cnt)/2 *2 + (odd-cnt)/2 * 2 + ((even-cnt)%2)*3;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define pb push_back\nconst int maxn=210;\nint n,k,pri[10000010],linker[maxn],a[maxn],b[maxn];\nbool mark[10000010],vis[maxn];\nvector<int> v[maxn];\nvoid pre()\n{\n\tn=10000000;\n\tmark[1]=true;\n\tfor (int i=2;i<=n;i++)\n\t{\n\t\tif (!mark[i])\n\t\t{\n\t\t\tpri[k++]=i;\n\t\t\t//cerr<<i<<endl;\n\t\t}\n\t\tfor (int j=0;j<k;j++)\n\t\t{\n\t\t\tint m=i*pri[j];\n\t\t\tif (m>n)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmark[m]=true;\n\t\t\tif (i%pri[j]==0)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\nbool dfs(int x)\n{\n\tfor (int i=0;i<v[x].size();i++)\n\t{\n\t\tint y=v[x][i];\n\t\tif (vis[y])\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\t\tif (linker[y]==-1 || dfs(linker[y]))\n\t\t{\n\t\t\tlinker[y]=x;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\nint main()\n{\n\tpre();\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%d\",&a[i]);\n\t}\n\tint k=0;\n\tb[++k]=a[1]-1;\n\tfor (int i=2;i<=n;i++)\n\t{\n\t\tif (a[i]!=a[i-1]+1)\n\t\t{\n\t\t\tb[++k]=a[i-1];\n\t\t\tb[++k]=a[i]-1;\n\t\t}\n\t}\n\tb[++k]=a[n];\n\tn=k;\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tlinker[i]=-1;\n\t\t//cerr<<b[i]<<endl;\n\t\tfor (int j=i+1;j<=n;j++)\n\t\t{\n\t\t\tif ((b[i]+b[j])&1 && !mark[abs(b[i]-b[j])])\n\t\t\t{\n\t\t\t\t//cerr<<i<<\" \"<<j<<\" \"<<abs(b[i]-b[j])<<\" \"<<mark[9]<<endl;\n\t\t\t\tif (b[i]&1)\n\t\t\t\t{\n\t\t\t\t\tv[i].pb(j);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tv[j].pb(i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint s=0;\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tif (!(b[i]&1))\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\t\tmemset(vis,false,sizeof(vis));\n\t\tif (dfs(i))\n\t\t{\n\t\t\ts++;\n\t\t}\n\t}\n\tint s1=0,s2=0;\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tif (b[i]&1)\n\t\t{\n\t\t\ts1++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\ts2++;\n\t\t}\n\t}\n\tint ans=s+((s1-s)/2+(s2-s)/2)*2+((s1-s)&1)*3;\n\tcout<<ans<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=5e3+11;\nconst int M=7e5+11;\nconst int MAXN=1e7+11;\nconst int inf=2147483647;\nint n,tot,cnt=1,t1,t2,mx,S,T,hd[M];\nint ans,pri[M],L[N<<1],R[N<<1];\nbitset<MAXN> is,a;\nstruct Edge{int nxt,to,val;}e[M];\nvoid ins(int x,int y,int z){\n    e[++cnt].nxt=hd[x];\n    e[cnt].to=y;hd[x]=cnt;\n    e[cnt].val=z;\n}\nvoid prepare(){\n    is[0]=is[1]=1;\n    for(int i=2;i<MAXN;i++){\n        if(!is[i]) pri[++tot]=i;\n        for(int j=1;j<=tot&&i*pri[j]<=MAXN;j++){\n            is[pri[j]*i]=1;\n            if(i%pri[j]==0) break;\n        }\n    }\n}\nnamespace Network_Flow{\n    queue<int> p;\n    int dep[N<<1];\n    int bfs(){\n        memset(dep,0,sizeof(dep));\n        p.push(S);dep[S]=1;\n        while(!p.empty()){\n            int x=p.front();p.pop();\n            for(int i=hd[x];i;i=e[i].nxt){\n                int y=e[i].to,v=e[i].val;\n                if(!dep[y]&&v){\n\t\t\t\t\tdep[y]=dep[x]+1;\n                    p.push(y);\n                }\n            }\n        }\n        if(dep[T]) return 1;\n        return 0;\n    }\n    int dfs(int x,int flow){\n        if(x==T||flow<=0) return flow;\n        int rest=0;\n        for(int i=hd[x];i;i=e[i].nxt){\n            int j=e[i].to;int v=e[i].val;\n            if(dep[j]==dep[x]+1&&v){\n                int now=dfs(j,min(v,flow));\n                e[i].val-=now;\n                e[i^1].val+=now;\n                flow-=now;rest+=now;\n                if(flow<=0) break;\n            }\n        }if(!rest) dep[x]=-1;\n        return rest;\n    }\n    int dinic(){\n        int maxflow=0;\n        while(bfs()) maxflow+=dfs(S,inf);\n\t\treturn maxflow;\n    }\n}\nint read(){\n    int x=0,f=1;char ch=getchar();\n    while(!isdigit(ch)){if(ch=='-')f=-f;ch=getchar();}\n    while(isdigit(ch)){x=x*10+ch-48;ch=getchar();}\n    return x*f;\n}\nsigned main(){\n    prepare();n=read();\n    for(int i=1;i<=n;i++){\n        int x=read();\n        a[x]=1,mx=max(mx,x);\n    }\n    for(int i=1;i<=mx+1;i++)\n        if(a[i]!=a[i-1]) i&1?L[++t1]=i:R[++t2]=i;\n    S=0,T=t1+t2+1;\n    for(int i=1;i<=t1;i++)\n        ins(S,i,1),ins(i,S,0);\n    for(int i=1;i<=t2;i++)\n        ins(i+t1,T,1),ins(T,i+t1,0);\n    for(int i=1;i<=t1;i++)\n        for(int j=1;j<=t2;j++)\n            if(!is[abs(L[i]-R[j])])\n                ins(i,j+t1,1),ins(j+t1,i,0);\n    int Val=Network_Flow::dinic();\n    ans+=Val;ans+=(t1-Val)/2*2+(t2-Val)/2*2;\n    ans+=((t1-Val)&1)*3;printf(\"%d\\n\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,a,b) for(int i=a;i<=b;++i)\ntypedef long long ll;\n\nusing namespace std;\n\nvoid File(){\n\tfreopen(\"ARC80F.in\",\"r\",stdin);\n\tfreopen(\"ARC80F.out\",\"w\",stdout);\n}\n\nconst int maxn=100+10;\nint n,a[maxn],pos[maxn],tot,cnt,ans;\nint be[maxn],cnte,to[maxn*maxn],las[maxn*maxn],beg[maxn];\nbool vis[maxn];\n\nvoid add(int u,int v){\n\tlas[++cnte]=beg[u];\n\tbeg[u]=cnte;\n\tto[cnte]=v;\n}\n\nbool pd(int x){\n\tif(x==1 || x==2)return false;\n\tint y=sqrt(x);\n\tREP(i,2,y)if(x%i==0)return false;\n\treturn true;\n}\n\nbool Hungary(int u){\n\tfor(int i=beg[u];i;i=las[i]){\n\t\tif(vis[to[i]])continue;\n\t\tvis[to[i]]=1;\n\t\tif(!be[to[i]] || Hungary(be[to[i]])){\n\t\t\tbe[to[i]]=u;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint main(){\n\t//File();\n\tscanf(\"%d\",&n);\n\tREP(i,1,n){\n\t\tscanf(\"%d\",&a[i]);\n\t\tif(i==1 || a[i-1]<a[i]-1)pos[++tot]=a[i];\n\t\tif(i!=1 && a[i]>a[i-1]+1)pos[++tot]=a[i-1]+1;\n\t}\n\tpos[++tot]=a[n]+1;\n\tREP(i,1,tot)if(pos[i]%2)++cnt;\n\tREP(i,1,tot)if(pos[i]%2==0){\n\t\tREP(j,1,tot)if(pos[j]%2==1 && pd(abs(pos[j]-pos[i]))){\n\t\t\tcout<<pos[j]-pos[i]<<endl;\n\t\t\tadd(i,j);\n\t\t}\n\t}\n\tREP(i,1,tot)if(pos[i]%2==0){\n\t\tmemset(vis,0,sizeof(vis));\n\t\tans+=Hungary(i);\n\t}\n\tprintf(\"%d\\n\",ans+(tot-ans*2)+(cnt-ans)%2);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\nconst int N = 2e2 + 2;\nconst int M = 1e7 + 7;\nint n;\nint x[N];\nint arr[N];\nint siz;\nbool p[M];\nvoid pre(){\n\tfor(int i = 2 ; i * i < M ; ++i){\n\t\tif(!p[i]){\n\t\t\tfor(int j = i * i ; j < M ; j += i){\n\t\t\t\tp[j] = 1;\n\t\t\t}\n\t\t}\n\t}\n\tp[0] = 1;\n\tp[1] = 1;\n\tp[2] = 1;\n}\nvector < int > v[N];\nint lft , rgt;\nint match[N];\nint timer;\nint visited[N];\nbool dfs(int node){\n\tif(visited[node] == timer){\n\t\treturn 0;\n\t}\n\tvisited[node] = timer;\n\tfor(int next : v[node]){\n\t\tif(!match[next] || dfs(match[next])){\n\t\t\tmatch[next] = node;\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\nint main(){\n\tpre();\n\tscanf(\"%d\" , &n);\n\tfor(int i = 1 ; i <= n ; ++i){\n\t\tscanf(\"%d\" , x + i);\n\t}\n\tint cur = x[1];\n\tint str = x[1];\n\tfor(int i = 2 ; i <= n ; ++i){\n\t\tif(cur + 1 != x[i]){\n\t\t\tarr[++siz] = str;\n\t\t\tarr[++siz] = cur + 1;\n\t\t\tstr = x[i];\n\t\t\tcur = x[i];\n\t\t}\n\t\telse{\n\t\t\t++cur;\n\t\t}\n\t}\n\tarr[++siz] = str;\n\tarr[++siz] = cur + 1;\n\tn = siz;\n\tfor(int i = 1 ; i <= n ; ++i){\n\t\tif(arr[i] & 1){\n\t\t\t++lft;\n\t\t}\n\t\telse{\n\t\t\t++rgt;\n\t\t}\n\t}\n\tfor(int i = 1 ; i <= n ; ++i){\n\t\tif(arr[i] & 1){\n\t\t\tfor(int j = 1 ; j <= n ; ++j){\n\t\t\t\tif(!p[abs(arr[j] - arr[i])]){\n\t\t\t\t\tv[i].emplace_back(j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint tot = 0;\n\tfor(int i = 1 ; i <= n ; ++i){\n\t\tif(arr[i] & 1){\n\t\t\t++timer;\n\t\t\ttot += dfs(i);\n\t\t}\n\t}\n\tint ans = 0;\n\tans += tot;\n\tans += ((lft - tot) >> 1) << 1;\n\tans += ((rgt - tot) >> 1) << 1;\n\tans += (lft & 1) * 3;\n\tprintf(\"%d\\n\" , ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef pair<ld,ld> pdd;\n\n#define X first\n#define Y second\n\nconst int MAXN = 110;\n\nint n;\nint a[MAXN], u[MAXN];\n\nll mul(ll a,ll b,ll p)\n{\n\tll t=0;\n\twhile (b)\n\t{\n\t\tif (b&1) t=(t+a)%p;\n\t\ta=a*2%p;\n\t\tb/=2;\n\t}\n\treturn t;\n}\n\nll power(ll a,ll b,ll p)\n{\n\tif (b==0) return 1;\n\tll t=power(a,b/2,p);\n\tt=mul(t,t,p);\n\tif (b&1) t=mul(t,a,p);\n\treturn t;\n}\n\nll getabs(ll x)\n{\n\treturn (x>=0)?x:-x;\n}\n\nll gcd(ll a,ll b)\n{\n\treturn b?gcd(b,a%b):a;\n}\n\nbool is_prime(ll p)\n{\n\tstatic ll a[]={2,3,5,7,11,13,17,19,23,29,31,37};\n\tif (p==1) return false;\n\tfor (int i=0;i<12&&a[i]<p;++i)\n\t{\n\t\tll t=p-1;\n\t\tint s=0;\n\t\twhile (t%2==0)\n\t\t{\n\t\t\tt/=2;\n\t\t\t++s;\n\t\t}\n\t\tll d=power(a[i],t,p);\n\t\tif (d==1||d==p-1) continue;\n\t\tint flag=0;\n\t\tfor (;s;--s)\n\t\t{\n\t\t\td=mul(d,d,p);\n\t\t\tif (d==p-1)\n\t\t\t{\n\t\t\t\tflag=1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!flag) return false;\n\t}\n\treturn true;\n}\n\nconst int INF = 1000000000;\nint F[MAXN];\n\nint calc(int x, int y)\n{\n\tif (x == y)\n\t\treturn 3;\n\tint ret = 0;\n\tint t = a[y]-a[x]+1;\n\tif (!is_prime(t)) return INF;\n\tret ++;\n\tif (t == 2) ret ++;\n\tfor (int i = x; i < y; ++ i)\n\t{\n\t\tint t = a[i+1]-a[i]-1;\n\t\tif (!t) continue;\n\t\tif (!is_prime(t)) return INF;\n\t\tret ++;\n\t\tif (t == 2) ret ++;\n\t}\n\treturn ret;\n}\n\nint main()\n{\n\t\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; ++ i)\n\t{\n\t\tscanf(\"%d\", &a[i]);\n\t}\n\tF[0] = 0;\n\tfor (int i = 1; i <= n; ++ i)\n\t{\n\t\tF[i] = INF;\n\t\tfor (int j = 0; j < i; ++ j)\n\t\t{\n\t\t\tF[i] = min(F[i], F[j]+calc(j+1, i));\n\t\t}\n\t}\n\tcout << F[n] << endl;\n\t\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <cstring>\n#include <cmath>\nusing namespace std;\n\nconst int MAX_N = 100 + 9;\nconst int MAX_M = 1e7 + 9;\n\nint N, x, cnt, match[MAX_N * 2 + 2], V;\nbool is_prime[MAX_M + 1], rev[MAX_M + 2], used[MAX_N * 2 + 2];\nvector<int> primes, v1, v2, G[MAX_N * 2 + 2];\n\nvoid sieve() {\n\tmemset(is_prime, 1, sizeof(is_prime));\n\tis_prime[0] = is_prime[1] = 0;\n\tfor (int i = 2; i <= MAX_M; i++) {\n\t\tif (is_prime[i]) {\n\t\t\tprimes.push_back(i);\n\t\t\tfor (int j = i * 2; j <= MAX_M; j += i) is_prime[j] = 0;\n\t\t}\n\t}\n}\n\nbool dfs(int v) {\n\tused[v] = true;\n\tfor (int i = 0; i < G[i].size(); i++) {\n\t\tint u = G[u][i], w = match[u];\n\t\tif (w < 0 || !used[u] && dfs(w)) {\n\t\t\tmatch[v] = u;\n\t\t\tmatch[u] = v;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nvoid bipartite_matching() {\n\tmemset(match, -1, sizeof(match));\n\tfor (int v = 0; v < V; v++) {\n\t\tif (match[v] < 0) {\n\t\t\tmemset(used, 0, sizeof(used));\n\t\t\tif (dfs(v)) {\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\tscanf(\"%d\", &N); sieve();\n\tfor (int i = 1; i <= N; i++) scanf(\"%d\", &x), rev[x] ^= true;\n\tfor (int i = 1; i <= MAX_M; i++) {\n\t\tif (rev[i] != rev[i - 1]) {\n\t\t\tif (i & 1) v1.push_back(i);\n\t\t\telse v2.push_back(i);\n\t\t}\n\t}\n\tfor (int i = 0; i < v1.size(); i++) {\n\t\tfor (int j = 0; j < v2.size(); j++) {\n\t\t\tif (is_prime[(int)abs(v1[i] - v2[j])]) G[i].push_back(j + v1.size());\n\t\t}\n\t}\n\tV = v1.size() + v2.size();\n\tbipartite_matching();\n\tprintf(\"%d\", cnt + (v1.size() - cnt >> 1 << 1) + (v2.size() - cnt >> 1 << 1) + ((v1.size() - cnt) & 1) * 3);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#define fo(i,a,b) for(int i=a;i<=b;i++)\n#define N 210\n#define M 10000002\nusing namespace std;\nint n,a[M],q[N],w[N],bz[M],p[M],last[N],nxt[N],to[N],tot=0,b[N],jy=0,ans=9;\nvoid link(int x,int y)\n{\n\tnxt[++tot]=last[x];last[x]=tot;to[tot]=y;\n}\nint dg(int x)\n{\n\tif(bz[x]==tot) return 0;\n\tbz[x]=tot;\n\tfor(int i=last[x];i;i=nxt[i])\n\t{\n\t\tint y=to[i];\n\t\tif(b[y]==0||dg(b[y]))\n\t\t{\n\t\t\tb[y]=x;return 1;\n\t\t}\n\t}\n\treturn 0;\n}\nint main()\n{\n\tfo(i,2,M-1)\n\t{\n\t\tif(!bz[i]) p[++p[0]]=i;\n\t\tfo(j,1,p[0])\n\t\t{\n\t\t\tint k=i*p[j];\n\t\t\tif(k>=M) break;\n\t\t\tbz[k]=1;\n\t\t\tif(i%p[j]==0) break;\n\t\t}\n\t}\n\tscanf(\"%d\",&n);\n\tfo(i,1,n)\n\t{\n\t\tint x;scanf(\"%d\",&x);\n\t\ta[x]=1;\n\t}\n\tfo(i,1,M-1)\n\tif(a[i]!=a[i-1])\n\t{\n\t\tif(i%2==1) q[++q[0]]=i;\n\t\telse w[++w[0]]=i;\n\t}\n\tbz[1]=bz[2]=1;\n\tfo(i,1,q[0]) fo(j,1,w[0]) if(bz[abs(q[i]-w[j])]==0) link(i,j);\n\tmemset(bz,0,sizeof(bz));\n\tfor(tot=1;tot<=n;tot++) if(!bz[tot]&&b[tot]==0) jy+=dg(tot);\n\tans=(q[0]-jy)-(q[0]-jy)%2;\n\tans=ans+(w[0]-jy)-(w[0]-jy)%2;\n\tans+=jy;\n\tans+=3*((q[0]-jy)%2);\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n\n#include <iostream>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <unordered_set>\n#include <queue>\n#include <set>\n#include <algorithm>\n#include <numeric>\n#include <list>\nusing namespace std;\n\nusing QWORD  = uint64_t;\nusing SQWORD = int64_t;\nusing DWORD  = uint32_t;\nusing SDWORD = int32_t;\nusing WORD   = uint16_t;\nusing SWORD  = int16_t;\nusing BYTE   = uint8_t;\nusing SBYTE  = int8_t;\nusing DOUBLE = double;\nusing FLOAT  = float;\n\n#define MIN_SDWORD (-2147483648)\n#define MAX_SDWORD (2147483647)\n#define MIN_SBYTE (-128)\n#define MAX_SBYTE (127)\n\n#define MIN_SQWORD (0x8000000000000000)\n#define MAX_SQWORD (0x7FFFFFFFFFFFFFFF)\n\n#define MAX_QWORD  (0xFFFFFFFFFFFFFFFF)\n#define MAX_DWORD  (0xFFFFFFFF)\n#define MAX_WORD   (0xFFFF)\n#define MAX_BYTE   (0xFF)\n\n#define MAX_DOUBLE      (1.0e+308)\n#define DOUBLE_EPS      (1.0e-12)\n#define MIN_DOUBLE_N    (-1.0e+308)\n\n#define ArrayLength(a)  (sizeof(a) / sizeof(a[0]))\n\nstatic inline DOUBLE MAX(DOUBLE a, DOUBLE b) { return a > b ? a : b; }\nstatic inline QWORD MAX(QWORD a, QWORD b) { return a > b ? a : b; }\nstatic inline DWORD MAX(DWORD a, DWORD b) { return a > b ? a : b; }\nstatic inline SDWORD MAX(SDWORD a, SDWORD b) { return a > b ? a : b; }\nstatic inline DOUBLE MIN(DOUBLE a, DOUBLE b) { return a < b ? a : b; }\nstatic inline QWORD MIN(QWORD a, QWORD b) { return a < b ? a : b; }\nstatic inline DWORD MIN(DWORD a, DWORD b) { return a < b ? a : b; }\nstatic inline SDWORD MIN(SDWORD a, SDWORD b) { return a < b ? a : b; }\nstatic inline DOUBLE ABS(DOUBLE a) { return 0 < a ? a : -a; };\n\n#define BYTE_BITS   (8)\n#define WORD_BITS   (16)\n#define DWORD_BITS  (32)\n#define QWORD_BITS  (64)\n\nstatic inline void inputStringSpSeparated(char *pcStr)\n{\n    char *pcCur = pcStr;\n    for (;;) {\n        char c = getchar();\n        if (('\\n' == c) || (EOF == c) || (' ' == c)) {\n            break;\n        }\n        *pcCur = c;\n        pcCur++;\n    }\n    *pcCur = '\\0';\n}\n\nstatic inline void inputString(char *pcStr)\n{\n    char *pcCur = pcStr;\n    for (;;) {\n        char c = getchar();\n        if (('\\n' == c) || (EOF == c)) {\n            break;\n        }\n        *pcCur = c;\n        pcCur++;\n    }\n    *pcCur = '\\0';\n}\n\n\nstatic inline SQWORD inputSQWORD(void)\n{\n    SQWORD sqNumber = 0;\n    SQWORD sqMultiplier = 1;\n    bool bRead = false;\n    for (;;) {\n        char c = getchar();\n        if (!bRead) {\n            if ('-' == c) {\n                sqMultiplier = -1;\n            }\n        }\n        if (('0' <= c) && (c <= '9')) {\n            sqNumber *= 10LL;\n            sqNumber += (SQWORD)(c - '0');\n            bRead = true;\n        } else {\n            if (bRead) {\n                return sqNumber * sqMultiplier;\n            }\n        }\n    }\n}\n\n\nstatic inline SDWORD inputSDWORD(void)\n{\n    SDWORD lNumber = 0;\n    SDWORD lMultiplier = 1;\n    bool bRead = false;\n    for (;;) {\n        char c = getchar();\n        if (!bRead) {\n            if ('-' == c) {\n                lMultiplier = -1;\n            }\n        }\n        if (('0' <= c) && (c <= '9')) {\n            lNumber *= 10;\n            lNumber += (c - '0');\n            bRead = true;\n        } else {\n            if (bRead) {\n                return lNumber * lMultiplier;\n            }\n        }\n    }\n}\n\nstatic inline DOUBLE inputFP(void)\n{\n    DOUBLE dInt = 0.0;\n    DOUBLE dFrac = 0.0;\n    DOUBLE dMultiplier = 1.0;\n    DWORD dwFpCnt = 0;\n    DOUBLE *pdCur = &dInt;\n    bool bRead = false;\n    for (;;) {\n        char c = getchar();\n        if (!bRead) {\n            if ('-' == c) {\n                dMultiplier = -1;\n            }\n        }\n        if ('.' == c) {\n            pdCur = &dFrac;\n        } else if (('0' <= c) && (c <= '9')) {\n            (*pdCur) *= 10;\n            (*pdCur) += (DOUBLE)(c - '0');\n            bRead = true;\n            if (pdCur == &dFrac) {\n                dwFpCnt++;\n            }\n        } else {\n            if (bRead) {\n                return dMultiplier * (dInt + dFrac / (pow((DOUBLE)10.0 , (DOUBLE)dwFpCnt)));\n            }\n        }\n    }\n}\n\n\n/**\n *  mod による操作ライブラリ\n */\n\n#define ANS_MOD (1000000007LL)\n \nstatic SQWORD addMod(SQWORD x, SQWORD y)\n{ \n    return (x + y) % ANS_MOD;\n}\n \nstatic SQWORD subMod(SQWORD x, SQWORD y)\n{\n    return (x - y + ANS_MOD) % ANS_MOD;\n}\n \nstatic SQWORD mulMod(SQWORD x, SQWORD y) \n{\n    return (x * y) % ANS_MOD;\n}\n \nstatic SQWORD powMod(SQWORD x, SQWORD e) {\n    SQWORD v = 1;\n    for (; e; x = mulMod(x, x), e >>= 1) {\n        if (e & 1) {\n            v = mulMod(v, x);\n        }\n    }\n    return v;\n}\n \nstatic SQWORD divMod(SQWORD x, SQWORD y)\n{\n    return mulMod(x, powMod(y, ANS_MOD - 2));\n}\n \n \nstatic SQWORD combMod(SQWORD n, SQWORD k)\n{\n    SQWORD v=1;\n    for(SQWORD i=1; i<=k; i++) {\n        v = divMod(mulMod(v, n-i+1),i);\n    } \n    return v;\n}\n\n/*----------------------------------------------*/\n\ntypedef struct {\n    SDWORD lTo;\n    SQWORD sqCap;\n    SQWORD sqCost;\n    SDWORD lRev;\n} ST_EDGE;\n\n#define MAX_V   (402)\n\nstruct Flow {\nprivate:\n    vector<ST_EDGE> avGraph[MAX_V];\n    SDWORD  alDimsFrom[MAX_V];\n    SDWORD  alDimsTo[MAX_V];\n    SQWORD  sqEdgeNum;\n    SQWORD  asqDist[MAX_V];\n    SDWORD  alPrevV[MAX_V];   \n    SDWORD  alPrevEdge[MAX_V];      /*直前の頂点と辺 */\n\n    SDWORD  alDinic_Level[MAX_V];\n    SDWORD  alDinic_Iter[MAX_V];\n\npublic:\n    Flow() {\n        for (auto v: avGraph) {\n            v.clear();\n        }\n        memset(asqDist, 0, sizeof(asqDist));\n        memset(alPrevV, 0, sizeof(alPrevV)); \n        memset(alPrevEdge, 0, sizeof(alPrevEdge));\n        memset(alDinic_Level, 0, sizeof(alDinic_Level));\n        memset(alDinic_Iter, 0, sizeof(alDinic_Iter));\n    }\n    void addEdge(SDWORD lFrom, SDWORD lTo, SQWORD sqCap, SQWORD sqCost) {\n        avGraph[lFrom].push_back((ST_EDGE){lTo, sqCap, sqCost, (SDWORD)(avGraph[lTo].size())});\n        avGraph[lTo].push_back((ST_EDGE){lFrom, 0, -sqCost, (SDWORD)(avGraph[lFrom].size() - 1)});\n    }\n\n    SDWORD minCostFlow(SDWORD lStart, SDWORD lTarget, SQWORD sqFlow)\n    {\n        SQWORD sqRes = 0;\n        SQWORD sqFlowRest = sqFlow;\n        while (0 < sqFlowRest) {\n            /* Bellman-Ford Method */\n            fill(asqDist, asqDist + ArrayLength(asqDist), MAX_SDWORD);\n            asqDist[lStart] = 0;\n            bool bIsUpdate = true;\n            while (bIsUpdate) {\n                bIsUpdate = false;\n                for (SDWORD lV = 0; lV < MAX_V; lV++) {\n                    for (SDWORD lIdx = 0; lIdx < avGraph[lV].size(); lIdx++) {\n                        ST_EDGE &stE = avGraph[lV][lIdx];\n                        if ((asqDist[lV] != MAX_SDWORD)\n                                && (0 < stE.sqCap)\n                                && (asqDist[lV] + stE.sqCost < asqDist[stE.lTo])) {\n                            asqDist[stE.lTo] = asqDist[lV] + stE.sqCost;\n                            alPrevV[stE.lTo] = lV;\n                            alPrevEdge[stE.lTo] = lIdx;\n                            bIsUpdate = true;\n                        }\n                    }\n                }\n            }\n            if (asqDist[lTarget] == MAX_SDWORD) {\n                return -1;\n            }\n\n            SQWORD sqAddFlow = MAX_SQWORD;\n            for (SDWORD lV = lTarget; lV != lStart; lV = alPrevV[lV]) {\n                sqAddFlow = min(sqAddFlow, avGraph[alPrevV[lV]][alPrevEdge[lV]].sqCap);\n            }\n            sqFlowRest -= sqAddFlow;\n            sqRes += sqAddFlow * asqDist[lTarget];      // 後で目的変数は書き換える\n            for (SDWORD lV = lTarget; lV != lStart; lV = alPrevV[lV]) {\n                ST_EDGE &stE = avGraph[alPrevV[lV]][alPrevEdge[lV]];\n                stE.sqCap -= sqAddFlow;\n                avGraph[lV][stE.lRev].sqCap += sqAddFlow;\n            }\n        }\n        return sqRes;\n    }\n\nprivate:\n    SQWORD maxFlowDinicBfs(SDWORD lS)\n    {\n        memset(alDinic_Level, -1, sizeof(alDinic_Level));\n        queue<SDWORD> queSearch;\n        alDinic_Level[lS] = 0;\n        queSearch.push(lS);\n        while (!queSearch.empty()) {\n            SDWORD lV = queSearch.front();\n            queSearch.pop();\n            for (SDWORD lIdx = 0; lIdx < avGraph[lV].size(); lIdx++) {\n                ST_EDGE &stE = avGraph[lV][lIdx];\n                if ((0 < stE.sqCap) && (alDinic_Level[stE.lTo] < 0)) {\n                    alDinic_Level[stE.lTo] = alDinic_Level[lV] + 1;\n                    queSearch.push(stE.lTo);\n                }\n            }\n        }\n\n        return 0;\n    }\n\n    SQWORD maxFlowDinicDfs(SDWORD lV, SDWORD lT, SQWORD sqF)\n    {\n        if (lV == lT) {\n            return sqF;\n        }\n        for (SDWORD &lI = alDinic_Iter[lV]; lI < avGraph[lV].size(); lI++) {\n            ST_EDGE &stE = avGraph[lV][lI];\n            if ((0 < stE.sqCap) && (alDinic_Level[lV] < alDinic_Level[stE.lTo])) {\n                SQWORD sqDiffFlow = maxFlowDinicDfs(stE.lTo, lT, min(sqF, stE.sqCap));\n                if (0 < sqDiffFlow) {\n                    stE.sqCap -= sqDiffFlow;\n                    avGraph[stE.lTo][stE.lRev].sqCap += sqDiffFlow;\n                    return sqDiffFlow;\n                }\n            }\n        }\n        return 0;\n    }\n\npublic:\n    SQWORD MaxFlow(SDWORD lStart, SDWORD lTarget)\n    {\n        SQWORD sqFlow = 0LL;\n        for (;;) {\n            maxFlowDinicBfs(lStart);\n            if (alDinic_Level[lTarget] < 0) {\n                return sqFlow;\n            }\n            memset(alDinic_Iter, 0, sizeof(alDinic_Iter));\n            while (1) {\n                SQWORD sqDiffFlow = maxFlowDinicDfs(lStart, lTarget, MAX_SQWORD);\n                sqFlow += sqDiffFlow;\n                if (0LL == sqDiffFlow) {\n                    break;\n                }\n            }\n        }\n    }\n};\n\n/*----------------------------------------------*/\n\nclass PrimeTable {\n    vector<bool> vbIsPrime;\n\npublic:\n    PrimeTable(SDWORD lMax) {\n        /* lSearchMax と ループ内の *2 の関係から、入力は3以上とすること */\n        if (!(1 <= lMax)) {\n            printf(\"Oops!\");\n            return;\n        }\n\n        /* 素数のリストを作る */\n        vbIsPrime.resize(lMax + 1, true);\n        SDWORD lSearchMax = sqrt(lMax) + 1;\n        vbIsPrime[0] = false;\n        vbIsPrime[1] = false;\n        for (SDWORD lPrime = 2; lPrime < lSearchMax; lPrime++) {\n            if (vbIsPrime[lPrime]) {\n                for (SDWORD lCurNum = lPrime * 2; lCurNum <= lMax; lCurNum += lPrime) {\n                    vbIsPrime[lCurNum] = false;\n                }\n            }\n        }\n    };\n\n    bool IsPrime(SQWORD sqN)\n    {\n        return vbIsPrime[sqN];\n    }\n};\n\n\n/*----------------------------------------------*/\n\n#define PNT_NO_START    (0)\n#define PNT_NO_OFFSET   (200)\n#define PNT_NO_TARGET   (401)\n#define FLOW_OFFSET     (1000000000)\n#define CAPACITY_INF    (1000000001)\n#define DUMMY_COST      (1)\n\nint main(void)\n{\n    SQWORD sqN = inputSQWORD();\n\n    Flow solverFlow;\n    vector<SQWORD> vsqA;\n    vector<SQWORD> vsqB;\n\n    PrimeTable prime(1e7 + 1);\n \n    map<SQWORD, SQWORD> mapB;\n\n    for (SQWORD sqIdx = 0; sqIdx < sqN; sqIdx++) {\n        SQWORD sqA = inputSQWORD();\n        vsqA.emplace_back(sqA);\n\n        mapB[sqA] ^= 1;\n        mapB[sqA + 1] ^= 1;\n    }\n\n    vector<SQWORD> vsqBEven, vsqBOdd;\n\n    for (auto b: mapB) {\n        if (0 < b.second) {\n            if (0 == (b.first % 2)) {\n                vsqBEven.emplace_back(b.first);\n            } else {\n                vsqBOdd.emplace_back(b.first);\n            }\n        }\n    }\n\n    SQWORD sqNodeEven = 0;\n    for (auto e: vsqBEven) {\n        SQWORD sqNodeOdd = 0;\n        for (auto o: vsqBOdd) {\n            if (prime.IsPrime(abs(e - o))) {\n                solverFlow.addEdge(sqNodeEven, sqNodeOdd + PNT_NO_OFFSET, 1, DUMMY_COST);\n            }\n            sqNodeOdd++;\n        }\n        sqNodeEven++;\n    }\n    for (SQWORD sqIdx = 1; sqIdx <= vsqBEven.size(); sqIdx++) {\n        solverFlow.addEdge(PNT_NO_START, sqIdx, 1, DUMMY_COST);\n    }\n    for (SQWORD sqIdx = 1; sqIdx <= vsqBOdd.size(); sqIdx++) {\n        solverFlow.addEdge(sqIdx + PNT_NO_OFFSET, PNT_NO_TARGET, 1, DUMMY_COST);\n    }\n\n\n\n    SQWORD sqMaxFlow = solverFlow.MaxFlow(PNT_NO_START, PNT_NO_TARGET);\n    SQWORD vsqCRestEven = vsqBEven.size() - sqMaxFlow;\n    SQWORD vsqCRestOdd  = vsqBOdd.size() - sqMaxFlow;\n\n    SQWORD sqAns = sqMaxFlow;    \n    sqAns += ((vsqCRestEven / 2) * 2);\n    sqAns += ((vsqCRestOdd / 2) * 2);\n    if (0 < (vsqCRestEven %  2)) {\n        sqAns += 3;\n    }\n\n    printf(\"%lld\\n\", sqAns);\n\n    return 0;\n}\n/*------------------------------------------*/\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <queue>\n#define file(x) freopen(#x\".in\", \"r\", stdin), freopen(#x\".out\", \"w\", stdout)\n\ninline int read()\n{\n\tint data = 0, w = 1; char ch = getchar();\n\twhile (ch != '-' && (ch < '0' || ch > '9')) ch = getchar();\n\tif (ch == '-') w = -1, ch = getchar();\n\twhile (ch >= '0' && ch <= '9') data = data * 10 + (ch ^ 48), ch = getchar();\n\treturn data * w;\n}\n\nconst int N(205), LIM(1e7), M(LIM + 10), INF(0x3f3f3f3f);\nstruct edge { int next, to, cap; } e[N * N * 2];\nint n, a[M], head[N], e_num = -1, cnt, L[N], R[N], cntl, cntr;\nint lev[N], cur[N], S, T, not_prime[M], prime[M];\ninline int Abs(int x) { return x < 0 ? -x : x; }\ninline void Add(int from, int to, int cap)\n{\n\te[++e_num] = (edge) {head[from], to, cap}, head[from] = e_num;\n\te[++e_num] = (edge) {head[to], from,  0 }, head[to]   = e_num;\n}\n\nvoid Init()\n{\n\tnot_prime[1] = 1;\n\tfor (int i = 2; i <= LIM; i++)\n\t{\n\t\tif (!not_prime[i]) prime[++cnt] = i;\n\t\tfor (int j = 1; j <= cnt && 1ll * i * prime[j] <= LIM; j++)\n\t\t{\n\t\t\tnot_prime[i * prime[j]] = 1;\n\t\t\tif (!(i % prime[j])) break;\n\t\t}\n\t}\n}\n\nint bfs()\n{\n\tstd::queue<int> Q; Q.push(S);\n\tmemset(lev, 0, (T + 1) << 2), lev[S] = 1;\n\twhile (!Q.empty())\n\t{\n\t\tint x = Q.front(); Q.pop();\n\t\tfor (int i = head[x]; ~i; i = e[i].next)\n\t\t{\n\t\t\tint to = e[i].to; if (lev[to] || !e[i].cap) continue;\n\t\t\tlev[to] = lev[x] + 1, Q.push(to);\n\t\t}\n\t}\n\treturn lev[T];\n}\n\nint dfs(int x, int f)\n{\n\tif (x == T || !f) return f;\n\tint ans = 0, cap;\n\tfor (int &i = cur[x]; ~i; i = e[i].next)\n\t{\n\t\tint to = e[i].to;\n\t\tif (lev[to] == lev[x] + 1 && e[i].cap)\n\t\t{\n\t\t\tcap = dfs(to, std::min(f - ans, e[i].cap));\n\t\t\te[i].cap -= cap, e[i ^ 1].cap += cap, ans += cap;\n\t\t\tif (ans == f) break;\n\t\t}\n\t}\n\tif (!ans) lev[x] = 0;\n\treturn ans;\n}\n\nint Dinic()\n{\n\tint ans = 0;\n\twhile (bfs()) memcpy(cur, head, (T + 1) << 2), ans += dfs(S, INF);\n\treturn ans;\n}\n\nint main()\n{\n\tInit(), n = read(), memset(head, -1, sizeof head);\n\tfor (int i = 1; i <= n; i++) ++a[read()];\n\tfor (int i = 0; i <= LIM; i++) if (a[i] != a[i + 1])\n\t\t(i & 1) ? R[++cntr] = i + 1 : L[++cntl] = i + 1;\n\tS = 0, T = cntl + cntr + 1;\n\tfor (int i = 1; i <= cntl; i++) Add(S, i, 1);\n\tfor (int i = 1; i <= cntr; i++) Add(i + cntl, T, 1);\n\tfor (int i = 1; i <= cntl; i++) for (int j = 1; j <= cntr; j++)\n\t\tif (!not_prime[Abs(L[i] - R[j])]) Add(i, j + cntl, 1);\n\tint f = Dinic(), ans = f, tl = cntl - f, tr = cntr - f;\n\tans += tl - (tl & 1) + tr - (tr & 1), ans += 3 * (tl & 1);\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nbool bo[10001000],vis[210];\nint st[210],mp[210][210],part[210],top,js0,js1;\nbool isprime(int p)\n{\n\tif ((p<=2)||(!(p&1))) return false;\n\tfor (int i=2;i*i<=p;i++) if (p%i==0) return false;\n\treturn true;\n}\nbool search(int s)\n{\n\tvis[s]=true;\n\tfor (int i=1;i<=top;i++) if (mp[s][i])\n\t{\n\t\tif (!part[i]) {part[i]=s;return true;}\n\t\telse if ((!vis[i])&&(search(part[i]))) {part[i]=s;return true;}\n\t}\n\treturn false;\n}\nint main()\n{\n\tint n;scanf(\"%d\",&n);\n\tfor (int i=1;i<=n;i++) {int w;scanf(\"%d\",&w);bo[w]=true;}\n\tfor (int i=1;i<=10000001;i++) if (bo[i]^bo[i-1]) {st[++top]=i;if (i&1) js1++;else js0++;}\n\tfor (int i=1;i<=top;i++) if (st[i]&1)\n\tfor (int j=1;j<=top;j++) if (isprime(abs(st[i]-st[j]))) mp[i][j]=1;\n\tint sum=0;\n\tfor (int i=1;i<=top;i++) if (st[i]&1)\n\t{\n\t\tmemset(vis,0,sizeof(vis));\n\t\tsum+=search(i);\n\t}\n\tjs0-=sum;js1-=sum;\n\tcout<<sum+js0+js1+(js0&js1&1)<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<list>\n#include<deque>\n#include<bitset>\n#include<set>\n#include<map>\n#include<unordered_map>\n#include<unordered_set>\n#include<cstring>\n#include<sstream>\n#include<complex>\n#include<iomanip>\n#include<numeric>\n#include<cassert>\n#define X first\n#define Y second\n#define pb push_back\n#define rep(X,Y) for (int (X) = 0;(X) < (Y);++(X))\n#define reps(X,S,Y) for (int (X) = S;(X) < (Y);++(X))\n#define rrep(X,Y) for (int (X) = (Y)-1;(X) >=0;--(X))\n#define rreps(X,S,Y) for (int (X) = (Y)-1;(X) >= (S);--(X))\n#define repe(X,Y) for ((X) = 0;(X) < (Y);++(X))\n#define peat(X,Y) for (;(X) < (Y);++(X))\n#define all(X) (X).begin(),(X).end()\n#define rall(X) (X).rbegin(),(X).rend()\n#define eb emplace_back\n#define UNIQUE(X) (X).erase(unique(all(X)),(X).end())\n#define Endl endl\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntemplate<class T> using vv=vector<vector<T>>;\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"{\"; rep(i,t.size()) {os<<t[i]<<\",\";} os<<\"}\"<<endl; return os;}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\ntemplate<class T> inline bool MX(T &l,const T &r){return l<r?l=r,1:0;}\ntemplate<class T> inline bool MN(T &l,const T &r){return l>r?l=r,1:0;}\n#define out(args...){vector<string> a_r_g_s=s_p_l_i_t(#args, ','); e_r_r(a_r_g_s.begin(), args); }\nvector<string> s_p_l_i_t(const string &s, char c){vector<string> v;int d=0,f=0;string t;for(char c:s){if(!d&&c==',')v.pb(t),t=\"\";else t+=c;if(c=='\\\"'||c=='\\'')f^=1;if(!f&&c=='(')++d;if(!f&&c==')')--d;}v.pb(t);return move(v);}\nvoid e_r_r(vector<string>::iterator it) {}\ntemplate<typename T, typename... Args> void e_r_r(vector<string>::iterator it, T a, Args... args){ if(*it==\" 1\"||*it==\"1\") cerr<<endl; else cerr << it -> substr((*it)[0] == ' ', it -> length()) << \" = \" << a << \", \"; e_r_r(++it, args...);}\nconst ll MOD=1e9+7;\nvector<int> primes,prime;\nclass PRPRPR{\npublic:\n  PRPRPR(int PRIME_MAX){\n    prime.resize(PRIME_MAX);\n    for(int i=2;i<PRIME_MAX;i++)if(!prime[i]){\n\t\t\t\tprimes.pb(i);\n\t\t\t\tfor(int j=i*2;j<PRIME_MAX;j+=i)\n\t\t\t\t\tprime[j]=1;\n      }\n  }\n} prprprpr(11234567);\n\nint dp[111][111];\n\nint main(){\n  ios_base::sync_with_stdio(false);\n  cout<<fixed<<setprecision(0);\n\tint n;\n\tcin>>n;\n\tvector<int> xs(n);\n\trep(i,n) cin>>xs[i];\n\n\tauto Cost=[&](int d){\n\t\tif(!d) return 0;\n\t\tif(d==4) return 2;\n\t\tif(d==1) return 3;\n\t\tif(d%2==0) return 2;\n\t\tif(d>2 && prime[d]==0) return 1;\n\t\treturn 3;\n\t};\n\n\treps(d,1,n+1)rep(i,n+1-d){\n\t\tfor(int l=i,r=i+d-1; l<=r; ++l, --r){\n\t\t\tif(r-l==xs[r]-xs[l]){\n\t\t\t\tdp[i][i+d-1]=Cost(xs[r]-xs[l]+1);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(l==r) dp[i][i+d-1]+=Cost(1);\n\t\t\telse dp[i][i+d-1]+=Cost(xs[r]-xs[l]+1)+Cost(xs[r]-xs[l]-1);\n\t\t}\n\t\treps(c,i,i+d-1) MN(dp[i][i+d-1], dp[i][c]+dp[c+1][i+d-1]);\n\t}\n\t//rep(i,n){rep(j,n)cout<<dp[i][j]<<\",\";cout<<endl;}\n\tcout<<dp[0][n-1]<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// ====================================\n//   author: M_sea\n//   website: https://m-sea-blog.com/\n// ====================================\n#include <bits/stdc++.h>\n#define file(x) freopen(#x\".in\",\"r\",stdin); freopen(#x\".out\",\"w\",stdout)\n#define debug(...) fprintf(stderr,__VA_ARGS__)\nusing namespace std;\ntypedef long long ll;\n\nint read() {\n\tint X=0,w=1; char c=getchar();\n\twhile (c<'0'||c>'9') { if (c=='-') w=-1; c=getchar(); }\n\twhile (c>='0'&&c<='9') X=X*10+c-'0',c=getchar();\n\treturn X*w;\n}\n\nconst int N=200+10,M=10000000+10;\n\nint p[M],v[M],cnt=0;\nvoid sieve(int n) {\n\tv[1]=1;\n\tfor (int i=2;i<=n;++i) {\n\t\tif (!v[i]) p[++cnt]=i;\n\t\tfor (int j=1;j<=cnt&&i*p[j]<=n;++j) {\n\t\t\tv[i*p[j]]=1;\n\t\t\tif (i%p[j]==0) break;\n\t\t}\n\t}\n}\n\nint n,a[M];\nvector<int> L,R,E[N];\n\nint vis[N],lnk[N];\nbool dfs(int u) {\n\tfor (int v:E[u]) {\n\t\tif (vis[v]) continue;\n\t\tvis[v]=1;\n\t\tif (!lnk[v]||dfs(lnk[v])) { lnk[v]=u; return 1; }\n\t}\n\treturn 0;\n}\nint Hungary() {\n\tint res=0;\n\tfor (int i=1;i<=L.size();++i) {\n\t\tmemset(vis,0,sizeof(vis));\n\t\tif (dfs(i)) ++res;\n\t}\n\treturn res;\n}\n\nint main() {\n\tsieve(10000000);\n\tn=read();\n\tfor (int i=1;i<=n;++i) a[read()]=1;\n\tfor (int i=1;i<M;++i) {\n\t\tif (a[i]==a[i-1]) continue;\n\t\tif (i&1) L.emplace_back(i);\n\t\telse R.emplace_back(i);\n\t}\n\tfor (int i=0;i<L.size();++i)\n\t\tfor (int j=0;j<R.size();++j) {\n\t\t\tif (v[abs(L[i]-R[j])]) continue;\n\t\t\tE[i+1].emplace_back(j+1);\n\t\t}\n\tint f=Hungary();\n\tprintf(\"%lld\\n\",f+(L.size()-f)/2*2+(R.size()-f)/2*2+(L.size()&1)*3);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)n;++i)\n#define each(a, b) for(auto (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout <<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout <<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define svec(v) cout<<#v<<\":\";rep(kbrni,v.size())cout<<\" \"<<v[kbrni];cout<<endl\n#define sset(s) cout<<#s<<\":\";each(kbrni,s)cout <<\" \"<<kbrni;cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int>P;\n\nconst int MAX_N = 10000005;\nconst int MAX_M = 300;\n\nint prime[MAX_N];\nbool is_prime[MAX_N];\n\nint sieve(int n)\n{\n\tint p = 0;\n\tfor(int i=0;i<=n;i++){\n\t\tis_prime[i] = true;\n\t}\n\tis_prime[0] = is_prime[1] = false;\n\tfor(int i=2;i<=n;i++){\n\t\tif(is_prime[i]){\n\t\t\tprime[p++] = i;\n\t\t\tfor(int j=2*i;j<=n;j+=i){\n\t\t\t\tis_prime[j] = false;\n\t\t\t}\n\t\t}\n\t}\n\treturn p;\n}\n\nstruct edge\n{\n\tint to,cap,rev;\n};\n\nvector<edge> G[MAX_M];\nint level[MAX_M];\nint iter[MAX_M];\n\nvoid add_edge(int from,int to,int cap)\n{\n\tG[from].push_back((edge){to,cap,G[to].size()});\n\tG[to].push_back((edge){from,0,G[from].size()-1});\n}\n\nvoid bfs(int s)\n{\n\tmemset(level,-1,sizeof(level));\n\tqueue<int> que;\n\tlevel[s] = 0;\n\tque.push(s);\n\twhile(!que.empty()){\n\t\tint v = que.front();\n\t\tque.pop();\n\t\trep(i,G[v].size()){\n\t\t\tedge &e = G[v][i];\n\t\t\tif(e.cap > 0 && level[e.to] < 0){\n\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\tque.push(e.to);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint dfs(int v,int t,int f)\n{\n\tif(v==t){\n\t\treturn f;\n\t}\n\tfor(int &i = iter[v];i<G[v].size();i++){\n\t\tedge &e = G[v][i];\n\t\tif(e.cap > 0 && level[v] < level[e.to]){\n\t\t\tint d = dfs(e.to,t,min(f,e.cap));\n\t\t\tif(d>0){\n\t\t\t\te.cap -= d;\n\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint max_flow(int s,int t)\n{\n\tint flow = 0;\n\tfor(;;){\n\t\tbfs(s);\n\t\tif(level[t]<0){\n\t\t\treturn flow;\n\t\t}\n\t\tmemset(iter,0,sizeof(iter));\n\t\tint f;\n\t\twhile((f=dfs(s,t,INF)) > 0){\n\t\t\tflow += f;\n\t\t}\n\t}\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n;\n    cin >> n;\n    vector<int> vec(n,0);\n    rep(i,n){\n        cin >> vec[i];\n    }\n    sort(all(vec));\n    vector<int> b;\n    b.pb(vec[0]);\n    rep(i,n){\n        if(i >= 1){\n            if(vec[i] != vec[i-1]+1){\n                b.pb(vec[i]);\n            }\n        }\n        if(i < n-1){\n            if(vec[i+1] != vec[i]+1){\n                b.pb(vec[i]+1);\n            }\n        }\n    }\n    b.pb(vec[n-1]+1);\n    vector<int> ev,od;\n    rep(i,b.size()){\n        if(b[i]%2 == 0){\n            ev.pb(b[i]);\n        }else{\n            od.pb(b[i]);\n        }\n    }\n    int hoge = sieve(vec[n-1]+1);\n    int u = (int)ev.size();\n    int v = (int)od.size();\n    rep(i,ev.size()){\n        add_edge(0,i,1);\n    }\n    rep(i,ev.size()){\n        rep(j,od.size()){\n            int diff = abs(ev[i]-od[j]);\n            if(diff%2 == 1 && is_prime[diff]){\n                add_edge(i+1,u+1+j,INF);\n            }\n        }\n    }\n    rep(i,od.size()){\n        add_edge(u+i+1,u+v+1,1);\n    }\n    int res = max_flow(0,u+v+1);\n    cout << res + (u-res)/2*2 + (v-res)/2*2 + (u-res)%2*3 << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int Nmax = 205, lim = 2e7 + 5;\n\nint n, a[Nmax];\nbitset<lim+3> prim;\n\n\nclass Graph\n{\n    vector<int> edge[Nmax];\n    bool marked[Nmax];\n    int L[Nmax], R[Nmax];\n\n    bool cupleaza(int node)\n    {\n        if(marked[node]) return 0;\n        marked[node] = 1;\n\n        for(auto it : edge[node])\n            if(R[it] == -1)\n            {\n                L[node] = it;\n                R[it] = node;\n                return 1;\n            }\n\n        for(auto it : edge[node])\n            if(cupleaza(R[it]))\n            {\n                L[node] = it;\n                R[it] = node;\n                return 1;\n            }\n        return 0;\n    }\n\npublic:\n    void add_edge(int x, int y)\n    {\n        edge[x].push_back(y);\n    }\n\n    int cuplaj(int n, int m)\n    {\n        int done = 1, i;\n        for(i=0; i<n; ++i) L[i] = -1;\n        for(i=0; i<m; ++i) R[i] = -1;\n\n        while(done)\n        {\n            done = 0;\n            memset(marked, 0, sizeof(marked));\n\n            for(i=0; i<n; ++i)\n                if(!L[i]) done |= cupleaza(i);\n        }\n\n        int cnt = 0;\n        for(i=0; i<n; ++i) cnt += (L[i] != -1);\n        return cnt;\n    }\n\n} graph;\n\nvoid prec()\n{\n    int i, j;\n\n    prim.set();\n    for(i=2; i*i <= lim; ++i)\n        if(prim[i])\n            for(j=i*i; j<=lim; j+=i)\n                prim[j] = 0;\n}\n\nint main()\n{\n //   freopen(\"input\", \"r\", stdin);\n    cin.sync_with_stdio(false);\n\n    prec();\n\n    int i, j;\n    vector<int> p, impar, par;\n\n    cin >> n;\n    for(i=1; i<=n; ++i) cin >> a[i];\n\n    for(i=1; i<=n; ++i)\n    {\n        j = i;\n        while(a[j] - a[i] == j - i) ++j;\n\n        p.push_back(a[i]);\n        p.push_back(a[j-1] + 1);\n\n        i = j - 1;\n    }\n\n    for(auto it : p)\n        if(it & 1) impar.push_back(it);\n            else par.push_back(it);\n\n    for(i=0; i<impar.size(); ++i)\n        for(j=0; j<par.size(); ++j)\n            if(prim[impar[i] + par[j]]) graph.add_edge(i, j);\n\n    int best = graph.cuplaj(impar.size(), par.size()), A, B;\n\n    A = impar.size() - best;\n    B = par.size() - best;\n\n    cout << best + 2 * (A/2 + B/2) + 3 * (A&1) << '\\n';\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define M 10000005\nusing namespace std;\nint d[700005],t,m,e[M],n,cnt,vis[205],w[205],g[205],u[40005],v[40005],nex[40005],a[205],b[205],A,B;\nint find(int x){\n\tfor (int i=g[x];i;i=nex[i])\n\tif (!vis[v[i]]){\n\t\tvis[v[i]]=1;\n\t\tif (!w[v[i]]||find(w[v[i]])){\n\t\t\tw[v[i]]=x; return 1;\n\t\t}\n\t}\n\treturn 0;\n}\nint main(){\n\tfor (int i=2;i<M;++i){\n\t\tif (!e[i]) d[++t]=i;\n\t\tfor (int j=1;j<=t;++j){\n\t\t\tn=i*d[j]; if (n>=M) break;\n\t\t\te[n]=1;\tif (i%d[j]==0) break;\n\t\t}\n\t}\n\tscanf(\"%d\",&n); t=0; e[0]=e[1]=e[2]=1;\n\tfor (int i=1;i<=n;++i) scanf(\"%d\",&a[i]);\n\tfor (int i=1,j;i<=n;i=j+1){\n\t\tfor (j=i;a[j+1]==a[j]+1;++j);\n\t\tb[++t]=a[i]; b[++t]=a[j]+1;\n\t}\n\tn=t;\n\tfor (int i=1;i<=n;++i)\n\tif (b[i]&1)\n\tfor (int j=1;j<=n;++j)\n\tif (!e[abs(b[j]-b[i])])\n\t\tu[++m]=i,v[m]=j,nex[m]=g[i],g[i]=m;\n\tfor (int i=1;i<=n;++i)\n\tif (b[i]&1){\n\t\tfor (int j=1;j<=n;++j) vis[j]=0;\n\t\tif (find(i)) ++cnt; ++A;\n\t}\n\tB=n-A-cnt; A-=cnt;\n\tcnt+=A/2*2+B/2*2;\n\tif (A&1) cnt+=3;\n\tprintf(\"%d\\n\",cnt);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// luogu-judger-enable-o2\n#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<cmath>\n#define maxn 10000010\nusing namespace std;\nint read()\n{\n    int x=0,f=1;\n    char ch=getchar();\n    while(ch-'0'<0||ch-'0'>9){if(ch=='-') f=-1;ch=getchar();}\n    while(ch-'0'>=0&&ch-'0'<=9){x=x*10+ch-'0';ch=getchar();}\n    return x*f;\n}\nint n;\nint prime[maxn],primesize;\nbool isprime[maxn];\nvoid get_prime()\n{\n    memset(isprime,true,sizeof(isprime));\n    isprime[1]=false;\n    for(int i=2;i<=maxn-10;i++)\n    {\n        if(isprime[i])  prime[++primesize]=i;\n        for(int j=1;j<=primesize&&i*prime[j]<=maxn-10;j++)\n        {\n            isprime[i*prime[j]]=false;\n            if(i%prime[j]==0)  break;\n        }\n    }\n}\nint s[maxn];\nint a[101],b[201];\nint top1,top2;\nint re[101][101];\nint match[101];\nint vis[101];\nbool dfs(int x)\n{\n    for(int i=1;i<=top2;i++)\n    {\n        if(re[x][i]&&!vis[i])\n        {\n            vis[i]=1;\n            if(!match[i]||dfs(match[i]))\n            {\n                match[i]=x;\n                return true;\n            }\n        }\n    }\n    return false;\n}\nint main()\n{\n    get_prime();\n    n=read();\n    for(int i=1;i<=n;i++)  s[read()]^=1;\n    for(int i=1;i<=maxn-9;i++)\n    {\n        if(s[i]!=s[i-1])\n        {\n            if(i&1)  a[++top1]=i;\n            else     b[++top2]=i;\n        }\n    }\n    for(int i=1;i<=top1;i++)\n      for(int j=1;j<=top2;j++)  if(isprime[abs(a[i]-b[j])])  re[i][j]=1;\n    int a=0;\n    for(int i=1;i<=top1;i++)\n    {\n        memset(vis,0,sizeof(vis));\n        if(dfs(i))  a++;\n    }\n    printf(\"%d\\n\",a+((top1-a)/2)*2+((top2-a)/2)*2+(top1-a)%2*(top2-a)%2*3);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 1e7 + 700;\n\n\nint n,fre[maxn],p[220],ispr[maxn],dd[maxn],even,odd,wrong;\nvector <int> edge[220],v2;\n\nbool fin(int u) {\n    if (fre[u]==wrong) return false;\n    fre[u]=wrong;\n    for (int j=0;j<edge[u].size();j++) {\n        int v=edge[u][j];\n       // cout<<u<<\" \"<<v<<endl;\n        if (p[v]==-1 || fin(p[v])) {\n            p[v]=u;\n            return true;\n        }\n    }\n    return false;\n}\n\nint main() {\n    freopen(\"in.txt\",\"r\",stdin);\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    ispr[1]=1;\n    for (int i=2;i<maxn;i++)\n        if (ispr[i]==0) {\n            for (int j=i+i;j<maxn;j+=i) ispr[j]=1;\n        }\n    cin>>n;\n    for (int i=1;i<=n;i++) {\n        int x;\n        cin>>x;\n        if (dd[x]==1) continue;\n        dd[x]=1;\n        fre[x]^=1;\n        fre[x+1]^=1;\n    }\n    even=0; odd=0; wrong=2;\n    for (int i=0;i<maxn;i++)\n        if (fre[i]==1) {\n            v2.push_back(i);\n            if (i%2==0) even++;\n            else odd++;\n        }\n    // for (int i=0;i<v2.size();i++) cout<<v2[i]<<\" \";\n   //  cout<<endl;\n    for (int i=0;i<v2.size();i++)\n        for (int j=0;j<v2.size();j++)\n            if (v2[i]%2==0 && v2[j]%2==1 && ispr[ abs(v2[j] - v2[i]) ]==0 && abs(v2[j] - v2[i])%2==1) {\n                edge[i].push_back(j);\n                //cout<<i<<\" \"<<j<<\" \"<<v2[i]<<\" \"<<v2[j]<<endl;\n            }\n    int cnt=0;\n     for (int i=0;i<v2.size();i++) if (v2[i]%2==1) p[i]=-1;\n    for (int i=0;i<v2.size();i++)\n     if (v2[i]%2==0) {\n        wrong++;\n        cnt+=fin(i);\n    }\n  //   cout<<\" \" <<even<<\" \"<<odd<<\" \"<<cnt<<endl;\n    cout<< cnt + (even-cnt)/2 *2 + (odd-cnt)/2 * 2 + (even-cnt)%2*3;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\nusing namespace std;\ntemplate<class S,class T> ostream& operator<<(ostream& o,const pair<S,T> &p){return o<<\"(\"<<p.fs<<\",\"<<p.sc<<\")\";}\ntemplate<class T> ostream& operator<<(ostream& o,const vector<T> &vc){o<<\"sz = \"<<vc.size()<<endl<<\"[\";for(const T& v:vc) o<<v<<\",\";o<<\"]\";return o;}\n\nstruct Bipartite_matching{\n\tint V;\n\tvector< vector<int> > G;\n\tvector<int> match;\n\tvector<bool> used;\n\tvoid init(int N){\n\t\tV=N;\n\t\tG.assign(V,vector<int>());\n\t\tmatch.assign(V,0);\n\t\tused.assign(V,false);\n\t}\n\tvoid add_edge(int v,int u){\n\t\tG[v].pb(u);\n\t\tG[u].pb(v);\n\t}\n\tbool dfs(int v){\n\t\tused[v]=true;\n\t\trep(i,G[v].size()){\n\t\t\tint u=G[v][i],w=match[u];\n\t\t\tif(w<0 || (!used[w] && dfs(w))){\n\t\t\t\tmatch[v]=u;\n\t\t\t\tmatch[u]=v;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\tint max_matching(){\n\t\tint res=0;\n\t\tfill(all(match),-1);\n\t\trep(v,V){\n\t\t\tif(match[v]<0){\n\t\t\t\tfill(all(used),false);\n\t\t\t\tif(dfs(v)) res++;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n};\n\nbool isprime(int x){\n\tif(x<=2) return 0;\n\tfor(int i=2;i*i<=x;i++){\n\t\tif(x%i==0) return 0;\n\t}\n\treturn 1;\n}\n\nint main(){\n\tint N;\n\tcin>>N;\n\tmap<int,int> mp;\n\trep(i,N){\n\t\tint x;\n\t\tcin>>x;\n\t\tmp[x]++;\n\t\tmp[x-1]++;\n\t}\n\tvector<int> vs;\n\tfor(pair<int,int> p:mp){\n\t\tif(p.sc!=2) vs.pb(p.fs);\n\t}\n\tint K = vs.size();\n\tBipartite_matching bip;\n\tbip.init(K);\n\trep(i,K) rep(j,i){\n\t\tint d = vs[i]-vs[j];\n\t\tif(isprime(d)) bip.add_edge(i,j);\n\t}\n\tint o = 0;\n\trep(i,K) if(vs[i]%2==0) o++;\n\tint m = bip.max_matching();\n\tif((o-m)%2==1) m--;\n\tcout<<K-m<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<string>\n#include<set>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<functional>\n#include<map>\n#include<iomanip>\n#include<limits>\n#include<unordered_set> \n#include<cmath>\n#include <numeric>\n#include <array>\n#include <complex>\nusing namespace std;\n//long long p = 998244353;\nlong long p = 1000000007;\n#define int long long\n#define vel vector<long long>\n#define vvel vector<vel>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define sor(v) sort(v.begin(),v.end())\n#define mmax(a,b) a=max(a,b)\n#define mmin(a,b) a=min(a,b)\n#define mkp make_pair\n#define pin pair<int,int>\n#define qin pair<pin,int>\n#define V vector\n#define Endl endl\n#define veb vector<bool>\n#define fcout cout << fixed << setprecision(15)\n#define rev(s) reverse(s.begin(),s.end())\n#define lower(h,val) lower_bound(h.begin(),h.end(),val)-h.begin()\n#define upper(h,val) upper_bound(h.begin(),h.end(),val)-h.begin()\nint max_kai = 300000;\nvel kai(max_kai, 1);\nvel inv_kai(max_kai, 1);\nint rui(int a, int n, int mod) {\n    if (n == 0) { return 1 % mod; }\n    int x = rui(a, n / 2, mod);\n    x *= x; x %= mod;\n    if (n % 2 == 1) { x *= a; x %= mod; }\n    return x;\n}\nint root(int x,vel &pa) {\n    if (pa[x] == -1) { return x; }\n    int ans = root(pa[x],pa); pa[x] = ans;\n    return ans;\n}\nbool mar(int x, int y,vel &pa) {\n    x = root(x,pa);\n    y = root(y,pa);\n    if (x != y) { pa[x] = y; }\n    return (x != y);\n}\nint gcd(int x, int y) {\n    if (x < y) { return gcd(y, x); }\n    if (y == 0) { return x; }\n    return gcd(y, x % y);\n}\nlong long modinv(long long a, long long m) {\n    long long b = m, u = 1, v = 0;\n    while (b) {\n        long long t = a / b;\n        a -= t * b; swap(a, b);\n        u -= t * v; swap(u, v);\n    }\n    u %= m;\n    if (u < 0) u += m;\n    return u;\n}\nvoid make_kai() {\n    rep(i, max_kai - 1) {\n        kai[i + 1] = kai[i] * (i + 1); kai[i + 1] %= p;\n        inv_kai[i + 1] = modinv(kai[i + 1], p);\n    }\n}\nint com(int n, int r) {\n    if ((n < 0) || (r < 0) || (r > n)) { return 0; }\n    int ans = (kai[n] * inv_kai[r]) % p;\n    return (ans * inv_kai[n - r]) % p;\n}\nvel uni(vel x) {\n    if (x.size() == 0) { return x; }\n    sor(x);\n    int n = x.size();\n    vel ans(1, x[0]);\n    for (int j = 1; j < n; j++) {\n        if (x[j - 1] != x[j]) { ans.push_back(x[j]); }\n    }\n    x = ans;\n    return x;\n}\nvoid pr(vel& v) {\n    int n = v.size();\n    if (n != 0) {\n        cout << v[0];\n        rep(i, n - 1) {\n            cout << \" \" << v[i + 1];\n        }\n        cout << endl;\n    }\n}\nvel dijk(V<V<pin>>& way, int st,int inf) {\n    int n = way.size();\n    vel dist(n, inf); dist[st] = 0;\n    priority_queue<pin, vector<pin>, greater<pin>> pq;\n    pq.push(mkp(0, st));\n    veb is_checked(n, false);\n    while (!pq.empty()) {\n        pin x = pq.top(); pq.pop();\n        int pot = x.second;\n        if (!is_checked[pot]) {\n            is_checked[pot] = true;\n            for (auto y : way[pot]) {\n                int nex_dist = x.first + y.second;\n                int nex_pot = y.first;\n                if (dist[nex_pot] > nex_dist) {\n                    dist[nex_pot] = nex_dist;\n                    pq.push(mkp(nex_dist, y.first));\n                }\n            }\n        }\n    }\n    return dist;\n}\ntemplate< typename Monoid >\nstruct SegmentTree {\n    using F = function< Monoid(Monoid, Monoid) >;\n\n    int sz;\n    vector< Monoid > seg;\n\n    const F f;\n    const Monoid M1;\n\n    SegmentTree(int n, const F f, const Monoid& M1) : f(f), M1(M1) {\n        sz = 1;\n        while (sz < n) sz <<= 1;\n        seg.assign(2 * sz, M1);\n    }\n\n    void set(int k, const Monoid& x) {\n        seg[k + sz] = x;\n    }\n\n    void build() {\n        for (int k = sz - 1; k > 0; k--) {\n            seg[k] = f(seg[2 * k + 0], seg[2 * k + 1]);\n        }\n    }\n\n    void update(int k, const Monoid& x) {\n        k += sz;\n        seg[k] = x;\n        while (k >>= 1) {\n            seg[k] = f(seg[2 * k + 0], seg[2 * k + 1]);\n        }\n    }\n\n    Monoid query(int a, int b) {\n        Monoid L = M1, R = M1;\n        for (a += sz, b += sz; a < b; a >>= 1, b >>= 1) {\n            if (a & 1) L = f(L, seg[a++]);\n            if (b & 1) R = f(seg[--b], R);\n        }\n        return f(L, R);\n    }\n\n    Monoid operator[](const int& k) const {\n        return seg[k + sz];\n    }\n\n    template< typename C >\n    int find_subtree(int a, const C& check, Monoid& M, bool type) {\n        while (a < sz) {\n            Monoid nxt = type ? f(seg[2 * a + type], M) : f(M, seg[2 * a + type]);\n            if (check(nxt)) a = 2 * a + type;\n            else M = nxt, a = 2 * a + 1 - type;\n        }\n        return a - sz;\n    }\n\n\n    template< typename C >\n    int find_first(int a, const C& check) {\n        Monoid L = M1;\n        if (a <= 0) {\n            if (check(f(L, seg[1]))) return find_subtree(1, check, L, false);\n            return -1;\n        }\n        int b = sz;\n        for (a += sz, b += sz; a < b; a >>= 1, b >>= 1) {\n            if (a & 1) {\n                Monoid nxt = f(L, seg[a]);\n                if (check(nxt)) return find_subtree(a, check, L, false);\n                L = nxt;\n                ++a;\n            }\n        }\n        return -1;\n    }\n\n    template< typename C >\n    int find_last(int b, const C& check) {\n        Monoid R = M1;\n        if (b >= sz) {\n            if (check(f(seg[1], R))) return find_subtree(1, check, R, true);\n            return -1;\n        }\n        int a = sz;\n        for (b += sz; a < b; a >>= 1, b >>= 1) {\n            if (b & 1) {\n                Monoid nxt = f(seg[--b], R);\n                if (check(nxt)) return find_subtree(b, check, R, true);\n                R = nxt;\n            }\n        }\n        return -1;\n    }\n};\nvel mul(vel& a, vel& b) {\n    int n = a.size();\n    int m = b.size();\n    vel ans(n + m - 1, 0);\n    rep(i, n) {\n        rep(j, m) {\n            ans[i + j] += a[i] * b[j];\n            ans[i + j] %= p;\n        }\n    }\n    return ans;\n}\nint rui_p(int& a, int n) {\n    if (n == 0) { return 1; }\n    int qans = rui_p(a, n / 2);\n    qans = qans * qans;\n    qans %= p;\n    if (n % 2 == 1) {\n        qans = qans * a; qans %= p;\n    }\n    return qans;\n}\nvvel disj_min(vel& v) {\n    int n = v.size();\n    vvel ret(22, vel(n));\n    ret[0] = v;\n    rep(i, 21) {\n        rep(j, n) {\n            int nex = j + (1 << i);\n            if (nex < n) {\n                ret[i + 1][j] = min(ret[i][j], ret[i][nex]);\n            }\n            else {\n                ret[i + 1][j] = ret[i][j];\n            }\n        }\n    }\n    return ret;\n}\nvvel disj_max(vel& v) {\n    int n = v.size();\n    vvel ret(20, vel(n));\n    ret[0] = v;\n    rep(i, 19) {\n        rep(j, n) {\n            int nex = j + (1 << i);\n            if (nex < n) {\n                ret[i + 1][j] = max(ret[i][j], ret[i][nex]);\n            }\n            else {\n                ret[i + 1][j] = ret[i][j];\n            }\n        }\n    }\n    return ret;\n}\nint find_min(vvel& dv,int l,int r) {\n    int i = 19;\n    while (l + (1 << i) > r) {\n        i--;\n    }\n    return min(dv[i][l], dv[i][r - (1 << i)]);\n}\nint find_max(vvel& dv, int l, int r) {\n    int i = 19;\n    while (l + (1 << i) > r) {\n        i--;\n    }\n    return max(dv[i][l], dv[i][r - (1 << i)]);\n}\nvoid del(vel& v) {\n    vel ans;\n    for (auto x : v) {\n        int count = upper_bound(v.begin(), v.end(),x) - lower_bound(v.begin(), v.end(), x);\n        if (count == 1) {\n            ans.push_back(x);\n        }\n    }\n    v = ans;\n}\nbool is_odd_prime(int n) {\n    if (n == 0 || n == 1||n==2) { return false; }\n    for (int i = 2; i * i <= n; i++) {\n        if (n % i == 0) { return false; }\n    }\n    return true;\n}\nstruct BipartiteMatching {\n    vector< vector< int > > graph;\n    vector< int > match, alive, used;\n    int timestamp;\n\n    BipartiteMatching(int n) : graph(n), alive(n, 1), used(n, 0), match(n, -1), timestamp(0) {}\n\n    void add_edge(int u, int v) {\n        graph[u].push_back(v);\n        graph[v].push_back(u);\n    }\n\n    bool dfs(int idx) {\n        used[idx] = timestamp;\n        for (auto& to : graph[idx]) {\n            int to_match = match[to];\n            if (alive[to] == 0) continue;\n            if (to_match == -1 || (used[to_match] != timestamp && dfs(to_match))) {\n                match[idx] = to;\n                match[to] = idx;\n                return true;\n            }\n        }\n        return false;\n    }\n\n    int bipartite_matching() {\n        int ret = 0;\n        for (int i = 0; i < graph.size(); i++) {\n            if (alive[i] == 0) continue;\n            if (match[i] == -1) {\n                ++timestamp;\n                ret += dfs(i);\n            }\n        }\n        return ret;\n    }\n\n    void output() {\n        for (int i = 0; i < graph.size(); i++) {\n            if (i < match[i]) {\n                cout << i << \"-\" << match[i] << endl;\n            }\n        }\n    }\n};\n\nsigned main() {\n    int n; cin >> n;\n    vel odd, even;\n    rep(i, n) {\n        int x; cin >> x;\n        if (x % 2 == 0) {\n            even.push_back(x);\n            odd.push_back(x - 1);\n        }\n        else {\n            odd.push_back(x);\n            even.push_back(x - 1);\n        }\n    }\n    del(odd); del(even);\n    n = odd.size();\n    int m = even.size();\n    vector<int> x;\n    BipartiteMatching bm(n + m);\n    rep(i, n) {\n        rep(j, m) {\n            if (is_odd_prime(abs(odd[i] - even[j]))) {\n                bm.add_edge(i, n + j);\n            }\n        }\n    }\n    int ans = bm.bipartite_matching();\n    int ret = n + m;\n    ret -= ans;\n    if (n % 2 != ans % 2) { ret++; }\n    cout << ret << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int maxm=1e7+10,maxn=210;\nint n,a[maxn],b[maxn],m,ans;\nint b1[maxn],b2[maxn],p1,p2;\nbool np[maxm],vis[maxn],g[maxn][maxn],s[maxm];\nint match[maxn];\nvector<int> p;\n\nvoid init(){\n\tnp[0]=np[1]=1;\n\tfor(int i=2;i<maxm;++i){\n\t\tif(!np[i]){\n\t\t\tp.push_back(i);\n\t\t\t//cerr<<i<<endl;\n\t\t\t//system(\"pause\");\n\t\t}\n\t\tfor(int j=0,j_end=p.size(),x;j<j_end&&(x=p[j]*i)<maxm;++j){\n\t\t\tnp[x]=true;\n\t\t\tif(i%p[j]==0)break;\n\t\t}\n\t}\n}\n\nbool dfs(int u){\n\tif(vis[u])return false;\n\tvis[u]=1;\n\tfor(int i=1;i<=m;++i)if(g[u][i]){\n\t\tif(!match[i]||dfs(match[i])){\n\t\t\tmatch[i]=u;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\nvoid solve(){\n\tinit();\n\tcin>>n;\n\tfor(int i=1;i<=n;++i){cin>>a[i];s[a[i]]=1;}\n\tfor(int i=1;i<maxm;++i){\n\t\tif(s[i]!=s[i-1])b[++m]=i;\n\t}\n\tfor(int i=1;i<=m;++i){\n\t\tif(b[i]&1)b1[++p1]=b[i];\n\t\telse b2[++p2]=b[i];\n\t}\n\t//cerr<<p1<<\" \"<<p2<<endl;\n\tfor(int i=1;i<=p1;++i){\n\t\tfor(int j=1;j<=p2;++j){\n\t\t\tif(!np[abs(b1[i]-b2[j])]){\n\t\t\t\tg[i][j]=true;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor(int i=1;i<=m;++i){\n\t\tif(!match[i]){\n\t\t\tmemset(vis,0,sizeof vis);\n\t\t\tif(dfs(i))++ans;//match()\n\t\t}\n\t}\n\tp1-=ans;p2-=ans;\n\t//cerr<<ans<<endl;\n\tans+=p1/2*2+p2/2*2;\n\tans+=p1%2*3;\n\tcout<<ans<<endl;\n}\nint main(){\n\tsolve();\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define ii pair <int, int>\n#define app push_back\n#define all(a) a.begin(), a.end()\n#define bp __builtin_popcountll\n#define ll long long\n#define mp make_pair\n#define f first\n#define s second\n#define Time (double)clock()/CLOCKS_PER_SEC\n#define debug(x) std::cout << #x << \": \" << x << '\\n';\n\nconst int N = 207;\nconst int INF = 1e9+7;\nconst int C = 1e7+7;\n\nbool used[N];\n\nbool p[C];\n\nint get(int a, int b) {\n    if (b < a)\n        swap(a, b);\n\n    if ((b - a) % 2 == 0)\n        return 2;\n    else if (p[b-a])\n        return 1;\n    else\n        return 3;\n}\n\nint cost[N][N];\nint dp[1 << 20];\n\nsigned main() {\n    #ifdef HOME\n    freopen(\"input.txt\", \"r\", stdin);\n    #else\n    #define endl '\\n'\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    #endif\n    for (int i = 2; i < C; ++i)\n        p[i] = 1;\n    for (int i = 2; i < C; ++i) \n        if (p[i])\n            for (int j = i * 2; j < C; j += i)\n                p[j] = 0;\n\n    int n;\n    cin >> n;\n    map <int, int> d;\n    while (n--) {\n        int x;\n        cin >> x;\n        d[x] ^= 1;\n        d[x+1] ^= 1;        \n    }\n\n    vector <int> c;\n    for (auto e : d) {\n        if (e.s)\n            c.app(e.f);\n    }   \n\n    #ifdef HOME\n    cout << \"C : \";\n    for (auto e : c)\n        cout << e << ' ';\n    cout << endl;\n    #endif\n\n    if (c.size() > 20)\n        exit(1);\n\n    for (int i = 0; i < c.size(); ++i) {\n        for (int j = i + 1; j < c.size(); ++j) {\n            cost[i][j] = cost[j][i] = get(c[i], c[j]);\n        }   \n    }    \n\n    for (int mask = 1; mask < (1 << c.size()); ++mask) {\n        dp[mask] = INF;\n        int l = -1;\n        for (int i = 0; i < c.size(); ++i)\n            if ((mask >> i) & 1) {\n                l = i;\n                break;\n            }\n        for (int i = l + 1; i < c.size(); ++i) {\n            if ((mask >> i) & 1) {\n                dp[mask] = min(dp[mask], dp[mask - (1 << l) - (1 << i)] + cost[i][l]);\n            }   \n        }   \n    }\n    cout << dp[(1 << c.size()) - 1] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define INF INT_MAX\n#define MAXN 205\nstruct edge{\n    int u,v,w;\n    edge(){}\n    edge(int u,int v,int w):u(u),v(v),w(w){}\n};\nint n,n_x;\nedge g[MAXN*2+1][MAXN*2+1];\nint lab[MAXN*2+1];\nint match[MAXN*2+1],slack[MAXN*2+1],st[MAXN*2+1],pa[MAXN*2+1];\nint flower_from[MAXN*2+1][MAXN+1],S[MAXN*2+1],vis[MAXN*2+1];\nvector<int> flower[MAXN*2+1];\nqueue<int> q;\ninline int e_delta(const edge &e){ // does not work inside blossoms\n    return lab[e.u]+lab[e.v]-g[e.u][e.v].w*2;\n}\ninline void update_slack(int u,int x){\n    if(!slack[x]||e_delta(g[u][x])<e_delta(g[slack[x]][x]))slack[x]=u;\n}\ninline void set_slack(int x){\n    slack[x]=0;\n    for(int u=1;u<=n;++u)\n        if(g[u][x].w>0&&st[u]!=x&&S[st[u]]==0)update_slack(u,x);\n}\nvoid q_push(int x){\n    if(x<=n)q.push(x);\n    else for(size_t i=0;i<flower[x].size();i++)q_push(flower[x][i]);\n}\ninline void set_st(int x,int b){\n    st[x]=b;\n    if(x>n)for(size_t i=0;i<flower[x].size();++i)\n               set_st(flower[x][i],b);\n}\ninline int get_pr(int b,int xr){\n    int pr=find(flower[b].begin(),flower[b].end(),xr)-flower[b].begin();\n    if(pr%2==1){//檢查他在前一層圖是奇點還是偶點\n        reverse(flower[b].begin()+1,flower[b].end());\n        return (int)flower[b].size()-pr;\n    }else return pr;\n}\ninline void set_match(int u,int v){\n    match[u]=g[u][v].v;\n    if(u>n){\n        edge e=g[u][v];\n        int xr=flower_from[u][e.u],pr=get_pr(u,xr);\n        for(int i=0;i<pr;++i)set_match(flower[u][i],flower[u][i^1]);\n        set_match(xr,v);\n        rotate(flower[u].begin(),flower[u].begin()+pr,flower[u].end());\n    }\n}\ninline void augment(int u,int v){\n    for(;;){\n        int xnv=st[match[u]];\n        set_match(u,v);\n        if(!xnv)return;\n        set_match(xnv,st[pa[xnv]]);\n        u=st[pa[xnv]],v=xnv;\n    }\n}\ninline int get_lca(int u,int v){\n    static int t=0;\n    for(++t;u||v;swap(u,v)){\n        if(u==0)continue;\n        if(vis[u]==t)return u;\n        vis[u]=t;//這種方法可以不用清空v陣列\n        u=st[match[u]];\n        if(u)u=st[pa[u]];\n    }\n    return 0;\n}\ninline void add_blossom(int u,int lca,int v){\n    int b=n+1;\n    while(b<=n_x&&st[b])++b;\n    if(b>n_x)++n_x;\n    lab[b]=0,S[b]=0;\n    match[b]=match[lca];\n    flower[b].clear();\n    flower[b].push_back(lca);\n    for(int x=u,y;x!=lca;x=st[pa[y]])\n        flower[b].push_back(x),flower[b].push_back(y=st[match[x]]),q_push(y);\n    reverse(flower[b].begin()+1,flower[b].end());\n    for(int x=v,y;x!=lca;x=st[pa[y]])\n        flower[b].push_back(x),flower[b].push_back(y=st[match[x]]),q_push(y);\n    set_st(b,b);\n    for(int x=1;x<=n_x;++x)g[b][x].w=g[x][b].w=0;\n    for(int x=1;x<=n;++x)flower_from[b][x]=0;\n    for(size_t i=0;i<flower[b].size();++i){\n        int xs=flower[b][i];\n        for(int x=1;x<=n_x;++x)\n            if(g[b][x].w==0||e_delta(g[xs][x])<e_delta(g[b][x]))\n                g[b][x]=g[xs][x],g[x][b]=g[x][xs];\n        for(int x=1;x<=n;++x)\n            if(flower_from[xs][x])flower_from[b][x]=xs;\n    }\n    set_slack(b);\n}\ninline void expand_blossom(int b){ // S[b] == 1\n    for(size_t i=0;i<flower[b].size();++i)\n        set_st(flower[b][i],flower[b][i]);\n    int xr=flower_from[b][g[b][pa[b]].u],pr=get_pr(b,xr);\n    for(int i=0;i<pr;i+=2){\n        int xs=flower[b][i],xns=flower[b][i+1];\n        pa[xs]=g[xns][xs].u;\n        S[xs]=1,S[xns]=0;\n        slack[xs]=0,set_slack(xns);\n        q_push(xns);\n    }\n    S[xr]=1,pa[xr]=pa[b];\n    for(size_t i=pr+1;i<flower[b].size();++i){\n        int xs=flower[b][i];\n        S[xs]=-1,set_slack(xs);\n    }\n    st[b]=0;\n}\ninline bool on_found_edge(const edge &e){\n    int u=st[e.u],v=st[e.v];\n    if(S[v]==-1){\n        pa[v]=e.u,S[v]=1;\n        int nu=st[match[v]];\n        slack[v]=slack[nu]=0;\n        S[nu]=0,q_push(nu);\n    }else if(S[v]==0){\n        int lca=get_lca(u,v);\n        if(!lca)return augment(u,v),augment(v,u),true;\n        else add_blossom(u,lca,v);\n    }\n    return false;\n}\ninline bool matching(){\n    memset(S+1,-1,sizeof(int)*n_x);\n    memset(slack+1,0,sizeof(int)*n_x);\n    q=queue<int>();\n    for(int x=1;x<=n_x;++x)\n        if(st[x]==x&&!match[x])pa[x]=0,S[x]=0,q_push(x);\n    if(q.empty())return false;\n    for(;;){\n        while(q.size()){\n            int u=q.front();q.pop();\n            if(S[st[u]]==1)continue;\n            for(int v=1;v<=n;++v)\n                if(g[u][v].w>0&&st[u]!=st[v]){\n                    if(e_delta(g[u][v])==0){\n                        if(on_found_edge(g[u][v]))return true;\n                    }else update_slack(u,st[v]);\n                }\n        }\n        int d=INF;\n        for(int b=n+1;b<=n_x;++b)\n            if(st[b]==b&&S[b]==1)d=min(d,lab[b]/2);\n        for(int x=1;x<=n_x;++x)\n            if(st[x]==x&&slack[x]){\n                if(S[x]==-1)d=min(d,e_delta(g[slack[x]][x]));\n                else if(S[x]==0)d=min(d,e_delta(g[slack[x]][x])/2);\n            }\n        for(int u=1;u<=n;++u){\n            if(S[st[u]]==0){\n                if(lab[u]<=d)return 0;\n                lab[u]-=d;\n            }else if(S[st[u]]==1)lab[u]+=d;\n        }\n        for(int b=n+1;b<=n_x;++b)\n            if(st[b]==b){\n                if(S[st[b]]==0)lab[b]+=d*2;\n                else if(S[st[b]]==1)lab[b]-=d*2;\n            }\n        q=queue<int>();\n        for(int x=1;x<=n_x;++x)\n            if(st[x]==x&&slack[x]&&st[slack[x]]!=x&&e_delta(g[slack[x]][x])==0)\n                if(on_found_edge(g[slack[x]][x]))return true;\n        for(int b=n+1;b<=n_x;++b)\n            if(st[b]==b&&S[b]==1&&lab[b]==0)expand_blossom(b);\n    }\n    return false;\n}\ninline pair<long long,int> weight_blossom(){\n    memset(match+1,0,sizeof(int)*n);\n    n_x=n;\n    int n_matches=0;\n    long long tot_weight=0;\n    for(int u=0;u<=n;++u)st[u]=u,flower[u].clear();\n    int w_max=0;\n    for(int u=1;u<=n;++u)\n        for(int v=1;v<=n;++v){\n            flower_from[u][v]=(u==v?u:0);\n            w_max=max(w_max,g[u][v].w);\n        }\n    for(int u=1;u<=n;++u)lab[u]=w_max;\n    while(matching())++n_matches;\n    for(int u=1;u<=n;++u)\n        if(match[u]&&match[u]<u)\n            tot_weight+=g[u][match[u]].w;\n    return make_pair(tot_weight,n_matches);\n}\ninline void init_weight_graph(){\n    for(int u=1;u<=n;++u)\n        for(int v=1;v<=n;++v)\n            g[u][v]=edge(u,v,0);\n}\n\nint main() {\n    scanf(\"%d\" , &n);\n    set<int> d;\n    map<int , bool> h;\n    for (int i = 0 ; i < n ; ++ i) {\n        int x;\n        scanf(\"%d\" , &x);\n        d.insert(x);\n        d.insert(x - 1);\n        h[x] = 1;\n    }\n    vector<int> v;\n    for (auto &x : d) {\n        if (h[x + 1] ^ h[x]) {\n            v.push_back(x);\n        }\n    }\n    n = v.size();\n    init_weight_graph();\n    for (int i = 1 ; i <= n ; ++ i) {\n        for (int j = i + 1 ; j <= n ; ++ j) {\n            g[i][j].w = g[j][i].w = 100 - (2 + abs(v[i - 1] - v[j - 1]) % 2);\n            //cout << i << ' ' << j << ' ' << g[i][j].w << endl;\n        }\n    }\n    printf(\"%lld\\n\", n * 50 - weight_blossom().first);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint V, E, src, snk;\nvector<int> la, nxt, oppo, capa;\nvoid init() {\n    E = 0;\n    la.clear(); nxt.clear(); oppo.clear(); capa.clear();\n    la = vector<int>(V, -1);\n}\nvoid add(int u, int v, int c) {\n    nxt.push_back(la[u]);\n    la[u] = E++;\n    oppo.push_back(v);\n    capa.push_back(c);\n}\nvector<int> dist;\nqueue<int> q;\nbool bfs() {\n    dist = vector<int>(V, -1);\n    q.push(src);\n    dist[src] = 0;\n    while(!q.empty()) {\n        int u = q.front(); q.pop();\n\n        for(int i = la[u]; i != -1; i = nxt[i]) {\n            int v = oppo[i];\n            if(capa[i] && dist[v] == -1) {\n                q.push(v);\n                dist[v] = dist[u] + 1;\n            }\n        }\n    }\n    return dist[snk] != -1;\n}\nvector<int> laa;\nint dfs(int u, int f) {\n    if(u == snk) return f;\n    for(int i = laa[u]; i != -1; i = nxt[i]) {\n        laa[u] = i;\n        int v = oppo[i];\n        if(capa[i] && dist[v] == dist[u] + 1) {\n            if(int tmp = dfs(v, min(capa[i], f))) {\n                capa[i] -= tmp;\n                capa[i^1] += tmp;\n                return tmp;\n            }\n        }\n    }\n    return 0;\n}\nint dinic() {\n    int tf = 0;\n    while(bfs()) {\n        laa = la;\n        while(int tmp = dfs(src, 1e9)) tf += tmp;\n    }\n    return tf;\n}\n\nvector<int> pchk;\nvoid getPrime() {\n    pchk = vector<int>(10000010, 0);\n    for(int i = 2; i < 10000010; i++) {\n        if(pchk[i]) continue;\n        int mul = 2;\n        while(i * mul < 10000010) {\n            pchk[i * mul] = 1;\n            mul++;\n        }\n    }\n}\n\nint N;\nvector<int> X;\nvector<int> B;\nvector<int> Me, Mo;\n\nint main() {\n    getPrime();\n\n    scanf(\"%d\", &N);\n    X.resize(N);\n    for(int i = 0; i < N; i++) {\n        scanf(\"%d\", &X[i]);\n    }\n    for(int i = 0; i < N; i++) {\n        if(i == 0 || X[i] != X[i - 1] + 1) {\n            B.push_back(X[i]);\n        }\n        if(i == N - 1 || X[i] + 1 != X[i + 1]) {\n            B.push_back(X[i] + 1);\n        }\n    }\n    for(int i = 0; i < B.size(); i++) {\n        if(B[i] % 2) Mo.push_back(B[i]);\n        else Me.push_back(B[i]);\n    }\n\n    V = Me.size() + Mo.size() + 2, src = V - 2, snk = V - 1;\n    init();\n\n    for(int i = 0; i < Me.size(); i++) {\n        for(int j = 0; j < Mo.size(); j++) {\n            if(!pchk[ abs(Me[i] - Mo[j]) ]) {\n                add(i, Me.size() + j, 1);\n                add(Me.size() + j, i, 0);\n            }\n        }\n    }\n    int K = dinic();\n    cout<<K + (((int)Me.size() - K)/2 + ((int)Mo.size() - K)/2)*2 + (Me.size() % 2)*3;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n// MAGRANT - GNC19 - TEMPLATE 2.1\n// 2017/8/6 - AtCoder Regular Contest 080 - Delta\n// Significant Time Tags:\n// Algorithm: #, #min/\n// Coding: #, #min.\n// Overall Summary:\n\n#define _CRT_SECURE_NO_WARNINGS\n\n#define N (1<<7)\n#define T (10000007)\n#define MODULO (1000000007)\n#define HA1 (2420609)\n#define HA2 (19260817)\n\n#include <cstdio>\n#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n#include <string>\n#include <algorithm>\n#include <stack>\n#include <vector>\n#include <set>\n#include <map>\n#include <deque>\n#include <queue>\n#include <complex>\nusing namespace std;\n\nnamespace MRAND\n{\n\tclass MRNDS\n\t{\n\tpublic:\n\t\tint ngf;\n\t\tunsigned int lgf;\n\t\tMRNDS()\n\t\t{\n\t\t\tngf = HA1*HA2;\n\t\t\tlgf = HA1 - HA2*ngf;\n\t\t}\n\t\tMRNDS(long long rgf)\n\t\t{\n\t\t\tlgf = rgf&((1LL << 32) - 1LL);\n\t\t\tngf = (rgf >> 31);\n\t\t\tngf += 2LL * lgf;\n\t\t\tngf *= HA2;\n\t\t\tlgf += HA1;\n\t\t}\n\t\tMRNDS operator* (const MRNDS &mrs)const\n\t\t{\n\t\t\tMRNDS Res;\n\t\t\tRes.ngf += ngf*mrs.lgf;\n\t\t\tRes.ngf -= mrs.ngf*lgf;\n\t\t\tRes.ngf *= HA1;\n\t\t\tRes.lgf *= HA2;\n\t\t\treturn Res;\n\t\t}\n\t}curl, curr;\n\tinline void InitRand(MRNDS &Lmrs, MRNDS &Rmrs)\n\t{\n\t\tcurl = Lmrs;\n\t\tcurr = Rmrs;\n\t\tcurl = curl*curr;\n\t\tcurl.ngf += HA2;\n\t}\n\tinline int GetRand()\n\t{\n\t\tcurl = curl*curr;\n\t\treturn (curl.lgf*HA1 - curr.ngf*HA2);\n\t}\n}\n\nint tot;\nbool chk[T];\nint prm[T];\nint n, cnt;\nint a[N];\npair<int, int> cp[N];\nint dp1[N][N], dp2[N][N];\nint len1[N][N], len2[N][N];\n\ninline int GetLen1(int uu, int vv)\n{\n\treturn len1[uu][vv];\n}\n\ninline int GetLen2(int uu, int vv)\n{\n\treturn len2[uu][vv];\n}\n\ninline int GetTms(int xx)\n{\n\tif (xx == 1)\n\t{\n\t\treturn 3;\n\t}\n\tif (!(xx & 1))\n\t{\n\t\treturn 2;\n\t}\n\telse if (!chk[xx])\n\t{\n\t\treturn 1;\n\t}\n\telse\n\t{\n\t\treturn 3;\n\t}\n}\n\nint main()\n{\n\tmemset(chk, false, sizeof(chk));\n\ttot = 0;\n\tfor (int i = 2;i < T - 4;i++)\n\t{\n\t\tif (!chk[i])\n\t\t{\n\t\t\tprm[tot++] = i;\n\t\t}\n\t\tfor (int j = 0;j < tot;j++)\n\t\t{\n\t\t\tif ((long long)i*(long long)prm[j] > (long long)(T - 3))\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tchk[i*prm[j]] = true;\n\t\t\tif (i%prm[j] == 0)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tscanf(\"%d\", &n);\n\tfor (int i = 0;i < n;i++)\n\t{\n\t\tscanf(\"%d\", &a[i]);\n\t}\n\tcp[0].first = 0;\n\tfor (int i = 1;i < n;i++)\n\t{\n\t\tif (a[i] != a[i - 1] + 1)\n\t\t{\n\t\t\tcp[cnt].second = i - 1;\n\t\t\tcp[++cnt].first = i;\n\t\t}\n\t}\n\tcp[cnt].second = n - 1;\n\tcnt++;\n\tfor (int i = 0;i < cnt;i++)\n\t{\n\t\tfor (int j = i;j < cnt;j++)\n\t\t{\n\t\t\tlen1[i][j] = a[cp[j].second] - a[cp[i].first] + 1;\n\t\t}\n\t}\n\tfor (int i = 0;i < cnt - 1;i++)\n\t{\n\t\tfor (int j = i;j < cnt - 1;j++)\n\t\t{\n\t\t\tlen2[i][j] = a[cp[j + 1].first] - a[cp[i].second] - 1;\n\t\t}\n\t}\n\tfor (int len = 1;len <= cnt;len++)\n\t{\n\t\tfor (int i = 0;i < cnt;i++)\n\t\t{\n\t\t\tint j = i + len - 1;\n\t\t\tif (j >= cnt)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (len == 1)\n\t\t\t{\n\t\t\t\tdp1[i][j] = GetTms(GetLen1(i, j));\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tdp1[i][j] = GetTms(GetLen1(i, j)) + dp2[i][j - 1];\n\t\t\t}\n\t\t\tfor (int kk = i;kk < j;kk++)\n\t\t\t{\n\t\t\t\tdp1[i][j] = min(dp1[i][j], dp1[i][kk] + dp1[kk + 1][j]);\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0;i < cnt - 1;i++)\n\t\t{\n\t\t\tint j = i + len - 1;\n\t\t\tif (j >= cnt - 1)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (len == 1)\n\t\t\t{\n\t\t\t\tdp2[i][j] = GetTms(GetLen2(i, j));\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tdp2[i][j] = GetTms(GetLen2(i, j)) + dp1[i + 1][j];\n\t\t\t}\n\t\t\tfor (int kk = i;kk < j;kk++)\n\t\t\t{\n\t\t\t\tdp2[i][j] = min(dp2[i][j], dp2[i][kk] + dp2[kk + 1][j]);\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\", dp1[0][cnt - 1]);\n\t//system(\"pause\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\nconst int MAX1=100;\nconst int MAX2=10000000;\nconst int INF=0x3f3f3f3f;\nint n,a[MAX1+5],p[MAX2+5],chk[MAX1*2+5],dir[MAX1*2+5][MAX1*2+5],ans;\nvector<int> cx,c[2],seq;\nvector<pii> conn[2*MAX1+5];\nint dfs(int x,int y){\n    int flow=0;\n    if(x==y) return INF;\n    chk[x]=1;\n    for(int i=0;i<conn[x].size();i++) if(chk[conn[x][i].first]==0&&conn[x][i].second>0){\n        int t=dfs(conn[x][i].first,y);\n        if(t>0){\n            flow=min(t,conn[x][i].second);\n            seq.push_back(x);\n            break;\n        }\n    }\n    return flow;\n}\nint fflow(int x,int y){\n    seq.clear(); seq.push_back(y);\n    for(int i=0;i<c[0].size()+c[1].size()+2;i++) chk[i]=0;\n    int flow=dfs(x,y);\n    for(int i=0;i<seq.size()-1;i++) {\n        int a=seq[i+1],b=seq[i];\n        conn[a][dir[a][b]].second-=flow;\n        conn[b][dir[b][a]].second+=flow;\n        //for(int j=0;j<conn[a].size();j++) if(conn[a][j].first==b) conn[a][j].second-=flow;\n        //for(int j=0;j<conn[b].size();j++) if(conn[b][j].first==a) conn[b][j].second+=flow;\n    }\n    return flow;\n}\nint main(){\n    scanf(\"%d\",&n);\n    for(int i=0;i<n;i++) scanf(\"%d\",&a[i]);\n    cx.push_back(a[0]), cx.push_back(a[0]+1);\n    for(int i=1;i<n;i++){\n        if(cx[cx.size()-1]==a[i]) cx.pop_back();\n        else cx.push_back(a[i]);\n        cx.push_back(a[i]+1);\n    }\n    for(int i=2;i<=MAX2;i++){\n        if(p[i]==0){\n            p[i]=1;\n            if(i<=3163) {for(int j=i*i;j<=MAX2;j+=i) p[j]=-1;}\n        }\n    }\n    p[2]=-1;\n    for(int i=0;i<cx.size();i++) c[cx[i]%2].push_back(cx[i]);\n    for(int i=0;i<c[0].size();i++) for(int j=0;j<c[1].size();j++) if(p[abs(c[0][i]-c[1][j])]==1) {\n        dir[i][c[0].size()+j]=conn[i].size();\n        dir[c[0].size()+j][i]=conn[c[0].size()+j].size();\n        conn[i].push_back(make_pair(c[0].size()+j,1));\n        conn[c[0].size()+j].push_back(make_pair(i,0));\n    }\n    for(int i=0;i<c[0].size();i++) {\n        dir[c[0].size()+c[1].size()][i]=conn[c[0].size()+c[1].size()].size();\n        dir[i][c[0].size()+c[1].size()]=conn[i].size();\n        conn[c[0].size()+c[1].size()].push_back(make_pair(i,1));\n        conn[i].push_back(make_pair(c[0].size()+c[1].size(),0));\n    }\n    for(int i=0;i<c[1].size();i++) {\n        dir[i+c[0].size()][c[0].size()+c[1].size()+1]=conn[i+c[0].size()].size();\n        dir[c[0].size()+c[1].size()+1][i+c[0].size()]=conn[c[0].size()+c[1].size()+1].size();\n        conn[i+c[0].size()].push_back(make_pair(c[0].size()+c[1].size()+1,1));\n        conn[c[0].size()+c[1].size()+1].push_back(make_pair(i+c[0].size(),0));\n    }\n    while(fflow(c[0].size()+c[1].size(),c[0].size()+c[1].size()+1)) ans++;\n    printf(\"%d\\n\",c[0].size()+c[1].size()-ans+(c[0].size()-ans)%2);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <bitset>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio>\n#include <cstring>\n#include <climits>\n#include <string.h>\n#include <stdio.h>\n#define LL long long\n#define all(x) (x).begin(),(x).end()\n#define pii pair<int,int>\n#define piii pair<int, pii >\n#define REP(i,n) for (int (i)=0;(i)<(n);(i)++)\n#define vi vector<int>\n#define vpi vector< pii >\n#define INF 2147483647\n#define big 19260817\n#define pb push_back\n#define mp make_pair\nusing namespace std;\nconst int Maxk=1005;\nstring mul(string a,string b){\n\tint res[Maxk];\n\tmemset(res,0,sizeof(res));\n\treverse(a.begin(),a.end());\n\treverse(b.begin(),b.end());\n\tfor (int i=0;i<a.length();i++){\n\t\tfor (int j=0;j<b.length();j++){\n\t\t\tres[i+j]+=(a[i]-'0')*(b[j]-'0');\n\t\t}\n\t}\n\tfor (int i=0;i<Maxk;i++){\n\t\tif (res[i]>=10) {\n\t\t\tres[i+1]+=(res[i]/10);\n\t\t\tres[i]%=10;\n\t\t}\n\t}\n\tstring ret;\n\tbool flag=false;\n\tfor (int i=Maxk-1;i>=0;i--){\n\t\tif (flag || res[i]){\n\t\t\tflag=true;\n\t\t\tret=ret+(char)(res[i]+'0');\n\t\t}\n\t}\n\tif (ret==\"\") ret=\"0\";\n\treturn ret;\n}\nstring add(string a,string b){\n\tif (a.length()<b.length()) swap(a,b);\n\twhile (a.length()!=b.length()){\n\t\tb='0'+b;\n\t}\n\tfor (int i=a.length()-1;i>=0;i--){\n\t\ta[i]+=(b[i]-'0');\n\t\tif (a[i]>'9' && i){\n\t\t\ta[i]-=10;\n\t\t\ta[i-1]++;\n\t\t}\n\t}\n\tif (a[0]>'9'){\n\t\ta[0]-=10;\n\t\ta='1'+a;\n\t}\n\treturn a;\n}\n\n// cf IO: I64d\n// atcoder IO: ｌｌｄ\ninline int read()\n{\n\tint x = 0, f = 1; char ch = getchar();\n\twhile (ch < '0' || ch > '9') { if (ch == '-') f = -1; ch = getchar(); }\n\twhile (ch >= '0' && ch <= '9') { x = x * 10 + ch - '0'; ch = getchar(); }\n\treturn x * f;\n}\nconst int Maxn=105;\nconst int Maxm=1e7+5;\nint cnt;\nint pos[Maxn],len[Maxn];\nint dp[Maxn][Maxn][2];\nbool isp[Maxm];\nvoid _init(){\n\tmemset(isp,true,sizeof(isp));\n\tisp[1]=isp[0]=false;\n\tfor (int i=2;i<Maxm;i++){\n\t\tif (isp[i]){\n\t\t\tfor (int j=i+i;j<Maxm;j+=i){\n\t\t\t\tisp[j]=false;\n\t\t\t}\n\t\t}\n\t}\n}\nint cost(int len){\n\tif (!len) return 0;\n\tif (len%2==0) return 2;\n\tif (isp[len]) return 1;\n\treturn 3;\n}\nint main(){\n\t_init();//cerr<<123<<endl;\n\tint n;\n\tscanf(\"%d\",&n);\n\tfor (int i=0;i<n;i++){\n\t\tscanf(\"%d\",&pos[i]);\n\t}\n\tint sum=1;\n\tfor (int i=1;i<n;i++){\n\t\tif (pos[i]==pos[i-1]+1) sum++;\n\t\telse{\n\t\t\tlen[++cnt]=sum;\n\t\t\tlen[++cnt]=pos[i]-pos[i-1]-1;\n\t\t\tsum=1;\n\t\t}\n\t}\n\tlen[++cnt]=sum;\n\tfor (int i=1;i<=cnt;i++){\n\t\tdp[i][i][0]=0;\n\t\tdp[i][i][1]=cost(len[i]);\n\t}\n\t//cout<<cnt<<endl;\n\tfor (int Len=2;Len<=cnt;Len++){\n\t\tfor (int i=1;i<=cnt;i++){\n\t\t\tint j=i+Len-1;\n\t\t\tif (j>cnt) continue;\n\t\t\tint totlen=0;\n\t\t\tfor (int k=i;k<=j;k++) totlen+=len[k];\n\t\t\tdp[i][j][0]=min(dp[i+1][j-1][1],dp[i+1][j-1][0]+cost(len[i])+cost(len[j])+cost(totlen));\n\t\t\tdp[i][j][1]=min(dp[i+1][j-1][0]+cost(len[i])+cost(len[j]),dp[i+1][j-1][1]+cost(totlen));\n\t\t}\n\t}\n\tprintf(\"%d\\n\",dp[1][cnt][1]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#if defined(LOCAL)\n#define PROBLEM_NAME \"d\"\nconst double _max_double_error = 1e-9;\n#include \"testutils.h\"\n#define L(x...) debug(x)\n#else\n#define L(x, ...) (x)\n#include <bits/stdc++.h>\n#endif\n\nusing namespace std;\nusing vi = vector<int>; using vvi = vector<vi>;\nusing ii = pair<int,int>; using vii = vector<ii>;\nusing l = long long; using vl = vector<l>; using vvl = vector<vl>;\nusing ll = pair<l,l>; using vll = vector<ll>; using vvll = vector<vll>;\nusing lu = unsigned long long;\nusing vb = vector<bool>; using vvb = vector<vb>;\nusing vd = vector<double>; using vvd = vector<vd>;\nusing mll = unordered_map<l, l>;\nconst l INF = numeric_limits<l>::max();\nconst double EPS = 1e-10; static constexpr auto PI = acos(-1);\nconst l e0=1, e3=1000, e5=100000, e6=10*e5, e7=10*e6, e8=10*e7, e9=10*e8;\nconst char lf = '\\n';\n#define all(x) begin(x), end(x)\n#define F(a,b,c) for (l a = l(b); a < l(c); a++)\n#define B(a,b,c) for (l a = l(c) - 1; a >= l(b); a--)\n\n#if defined(LOCAL)\n#define L(x...) debug(x)\n#else\n#define L(x, ...) (x)\n#endif\n\nconst l MAX_PRIME = 5000;\n// returns v[i] = smallest prime divisor of i or 1\nvl sieve_primes(vl& primes) {\n  vl next_div(MAX_PRIME, 1);\n  for (l i = 2; i < MAX_PRIME; i++) {\n    if (next_div[i] != 1) continue;\n    primes.emplace_back(i);\n    for (l j = i; j < MAX_PRIME; j += i) if (next_div[j] == 1) next_div[j] = i;\n  }\n  return next_div;\n}\n\nbool is_prime(l n, vl& primes) {\n  if (n == 1) return false;\n  for (auto p : primes) {\n    if (n == p) return true;\n    if (n % p) return false;\n    if (p * p > n) return false;\n  }\n  return true;\n}\n\nvoid solve(istream& cin, ostream& cout) {\n  vl primes;\n  sieve_primes(primes);\n  l n;\n  cin >> n;\n  vl v(n); F(i, 0, n) cin >> v[i];\n  vvl m(n, vl(n));\n  F(i, 0, n) {\n    B(j, 0, i + 1) {\n      // full cover\n      // - holes\n      l t = 0;\n      F(k, j, i) {\n        l d = v[k + 1] - v[k] - 1;\n        if (d == 0) continue;\n        if (d % 2) {\n          if (is_prime(d, primes)) t++; else t += 3;\n        } else {\n          t += 2;\n        }\n      }\n      // - tail\n      l d = v[i] - v[j] + 1;\n      if (d % 2) {\n        if (is_prime(d, primes)) t++; else t += 3;\n      } else {\n        t += 2;\n      }\n      m[j][i] = t;\n      F(k, j, i) m[j][i] = min(m[j][i], m[j][k] + m[k + 1][i]);\n    }\n  }\n  cout << m[0][n - 1] << lf;\n}\n\nint main() {\n  ios_base::sync_with_stdio(false); cin.tie(0);\n  cout << fixed << setprecision(15);\n#if defined(LOCAL)\n  // _generate_random_test = generate_random;\n  // _solve_brute = solve_brute;\n  // _player_b = player_b;\n  // _custom_solution_checker = solution_checker;\n  maybe_run_tests(cin, cout);\n#else\n  solve(cin, cout);\n#endif\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\n#include<queue>\nusing namespace std;\n#define SIZE 222\n#define INF 1000000\ntypedef pair<int, int>pii;\nclass maxflow\n{\npublic:\n\tvector<int>pat[SIZE];\n\tvector<int>cap[SIZE];\n\tvector<int>rev[SIZE];\n\tbool flag[SIZE];\n\tint dist[SIZE];\n\tint now[SIZE], ind[SIZE];\n\tint idx[SIZE];\n\tint flow;\n\tint gd;\n\tvoid adde(int s, int t, int cp)//多重辺は消してから s->tの容量cpの辺をはる\n\t{\n\t\tpat[s].push_back(t);\n\t\tpat[t].push_back(s);\n\t\tcap[s].push_back(cp);\n\t\tcap[t].push_back(0);\n\t\trev[s].push_back(pat[t].size() - 1);\n\t\trev[t].push_back(pat[s].size() - 1);\n\t}\n\tvoid blockflow(int node, int len, int go, int pt)//ブロックフローを求めて流す\n\t{\n\t\tif (pt == len)\n\t\t{\n\t\t\tif (node != go)return;\n\t\t\tint mini = INF, rr = -1;\n\t\t\tfor (int i = 0; i < pt; i++)if (cap[now[i]][ind[i]] < mini)mini = cap[now[i]][ind[i]], rr = i;\n\t\t\tfor (int i = 0; i < pt; i++)cap[now[i]][ind[i]] -= mini, cap[pat[now[i]][ind[i]]][rev[now[i]][ind[i]]] += mini;\n\t\t\tflow += mini;//mini==INFになったら非有界\n\t\t\tgd = rr;\n\t\t\treturn;\n\t\t}\n\t\tnow[pt] = node;\n\t\tfor (int i = idx[node]; i < pat[node].size(); i++)\n\t\t{\n\t\t\tif (dist[pat[node][i]] == dist[node] + 1 && cap[node][i]>0)\n\t\t\t{\n\t\t\t\tind[pt] = i;\n\t\t\t\tblockflow(pat[node][i], len, go, pt + 1);\n\t\t\t\tif (gd < pt)break;\n\t\t\t\telse gd = INF;\n\t\t\t}\n\t\t\tidx[node]++;\n\t\t}\n\t}\n\tvoid dinic(int st, int go, int num)//dinicのアルゴリズムで最大流を求める 変数flowにmaxflowの値が入る\n\t{\n\t\tflow = 0;\n\t\tfor (;;)\n\t\t{\n\t\t\tqueue<pii>que;\n\t\t\tfill(dist, dist + num, INF);\n\t\t\tfill(flag, flag + num, false);\n\t\t\tque.push(make_pair(st, 0));\n\t\t\tfor (;;)\n\t\t\t{\n\t\t\t\tif (que.empty())break;\n\t\t\t\tpii z = que.front();\n\t\t\t\tque.pop();\n\t\t\t\tif (flag[z.first])continue;\n\t\t\t\tflag[z.first] = true;\n\t\t\t\tdist[z.first] = z.second;\n\t\t\t\tfor (int i = 0; i < pat[z.first].size(); i++)\n\t\t\t\t{\n\t\t\t\t\tif (dist[pat[z.first][i]]>z.second + 1 && cap[z.first][i] > 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tdist[pat[z.first][i]] = z.second + 1;\n\t\t\t\t\t\tque.push(make_pair(pat[z.first][i], z.second + 1));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (dist[go] == INF)return;\n\t\t\tgd = INF;\n\t\t\tfill(idx, idx + SIZE, 0);\n\t\t\tblockflow(st, dist[go], go, 0);\n\t\t}\n\t}\n\tvector<int>getcut(int st, int go, int num)//頂点iがmincutのst側なら1 そうでなければ0\n\t{\n\t\tdinic(st, go, num);\n\t\tvector<int>ret;\n\t\tfor (int i = 0; i < num; i++)ret.push_back(flag[i]);\n\t\treturn ret;\n\t}\n};\nmaxflow gr;\nbool np[10101010];\nint d[111];\nint main()\n{\n\tint num;\n\tscanf(\"%d\", &num);\n\tfor (int i = 0; i < num; i++)scanf(\"%d\", &d[i]);\n\tvector<int>zv;\n\tfor (int i = 0; i < num; i++)\n\t{\n\t\tif (i == 0)zv.push_back(d[i]);\n\t\telse if (d[i - 1] + 1 != d[i])zv.push_back(d[i]);\n\t\tif (i == num - 1)zv.push_back(d[i] + 1);\n\t\telse if (d[i + 1] - 1 != d[i])zv.push_back(d[i] + 1);\n\t}\n\tvector<int>v1, v2;\n\tfor (int i = 0; i < zv.size(); i++)\n\t{\n\t\tif (zv[i] % 2 == 0)v1.push_back(zv[i]);\n\t\telse v2.push_back(zv[i]);\n\t}\n\tnp[1] = true;\n\tfor (int i = 2; i <= 10000000; i++)\n\t{\n\t\tif (np[i])continue;\n\t\tfor (int j = i + i; j <= 10000000; j += i)np[j] = true;\n\t}\n\tfor (int i = 0; i < v1.size(); i++)\n\t{\n\t\tfor (int j = 0; j < v2.size(); j++)\n\t\t{\n\t\t\tint t = v2[j] - v1[i];\n\t\t\tif (t < 0)t = -t;\n\t\t\tif (!np[t])gr.adde(2 + i, 2 + num + j, 1);\n\t\t}\n\t}\n\tfor (int i = 0; i < num; i++)gr.adde(0, i + 2, 1), gr.adde(i + num + 2, 1, 1);\n\tgr.dinic(0, 1, 202);\n\tint r = gr.flow;\n\tint a = v1.size() - r, b = v2.size() - r;\n\tif ((v1.size() - r) % 2)r++;\n\tprintf(\"%d\\n\", r + a + b);\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cmath>\nconst int N=1005,INF=~0u>>2;\nint b[N],n,vis[N],lk[N],even[N],odd[N],even_num,odd_num,ans,k,tot,tim,v[N][N];\nbool find(int x){\n\tvis[x]=tim;\n\tfor(int i=1;i<=even_num;++i){\n\t\tif(v[x][i]&&vis[lk[i]]!=tim){\n\t\t\tif(!lk[i]||find(lk[i])) return lk[i]=x,1;\n\t\t}\n\t}\n\treturn 0;\n}\nbool check(int x){\n\tif(x==1) return 0;\n\tfor(int i=2;i*i<=x;++i){\n\t\tif(x%i==0) return 0;\n\t}\n\treturn 1;\n}\nvoid solve(int x){\n\tif(x&1) odd[++odd_num]=x;\n\telse even[++even_num]=x;\n}\nint main(){\n//\tfreopen(\"ex.in\",\"r\",stdin);\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;++i) scanf(\"%d\",&b[i]);b[0]=-1;\n\tfor(int i=1;i<=n;++i){\n\t\tif(b[i]!=b[i-1]+1) solve(b[i]);\n\t\tif(b[i]+1!=b[i+1]) solve(b[i]+1);\n\t}\n\tfor(int i=1;i<=odd_num;++i)\n\t\tfor(int j=1;j<=even_num;++j)\n\t\t\tif(check(abs(even[j]-odd[i]))) v[i][j]=1;\n\tfor(int i=1;i<=odd_num;++i){\n\t\ttim++;\n\t\tif(find(i)) k++;\n\t}\n\tans=k+((even_num-k)/2+(odd_num-k)/2)*2+((odd_num-k)%2)*3;\n\tprintf(\"%d\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define ld long double\n#define ull unsigned long long\n#define poly vector<ll>\n#define pb push_back\n#define pii pair<int,int>\n#define fi first\n#define se second\n#define mp make_pair\n#define For(i,l,r) for(int i=(int)(l);i<=(int)(r);i++)\n#define Rep(i,r,l) for(int i=(int)(r);i>=(int)(l);i--)\ninline ll read(){\n\tll x=0;char ch=getchar();bool d=1;\n\tfor(;!isdigit(ch);ch=getchar()) if(ch=='-') d=0;\n\tfor(;isdigit(ch);ch=getchar()) x=x*10+ch-'0';\n\treturn d?x:-x;\n}\ninline void write(ll x){\n\tif(x<0) x=-x,putchar('-');\n\tif(x>=10) write(x/10);\n\tputchar('0'+x%10);\n}\ninline void writeln(ll x){write(x);puts(\"\");}\ninline void writep(ll x){write(x);putchar(' ');}\ninline ull rnd(){\n\treturn ((ull)rand()<<30^rand())<<4|rand()%4;\n}\nconst int N=205;\nint head[N],opt;\nstruct info{\n\tint to,nxt;\n}e[N*N*2];\nvoid add(int x,int y){\n\te[++opt]=(info){y,head[x]};head[x]=opt;\n\te[++opt]=(info){x,head[y]};head[y]=opt;\n}\nbool check(int x){\n\tif(x<=2) return 0;\n\tfor(int i=2;i*i<=x;i++){\n\t\tif(x%i) return 0;\n\t}\n\treturn 1;\n}\nint ma[N];\nbool used[N];\nbool dfs(int u){\n\tfor(int i=head[u];i;i=e[i].nxt){\n\t\tint k=e[i].to;\n\t\tif(used[k]) continue;\n\t\tif(!ma[k]||dfs(ma[k])) return ma[k]=u,1;\n\t}\n\treturn 0;\n}\nint a[N],pos[N];\nint main(){\n\tint n=read(),m=0,cnt=0;\n\tFor(i,1,n){\n\t\ta[i]=read();\n\t\tif(i==1||a[i-1]<a[i]-1) pos[++m]=a[i];\n\t\tif(i>1&&a[i-1]+1<a[i]) pos[++m]=a[i-1]+1;\n\t}\n\tpos[++m]=a[n]+1;\n\tFor(i,1,m) if(pos[i]&1) cnt++;\n\tFor(i,1,m) if(pos[i]%2==0){\n\t\tFor(j,i+1,m) if(pos[j]%2==1){\n\t\t\tif(check(pos[j]-pos[i])) add(i,j);\n\t\t}\n\t}\n\tint ssw=0;\n\tFor(i,1,m) if(pos[i]%2==0){\n\t\tmemset(used,0,sizeof(used));\n\t\tssw+=dfs(i);\n\t}\n\tcout<<ssw+(m-ssw*2)+(cnt-ssw)%2;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 10000010;\nbool pd[N];\nint prime[N],tot;\nvoid find_prime(){\n\tmemset(pd,true,sizeof(pd));\n\tfor(int i=2;i<N;i++){\n\t\tif(pd[i]) prime[++tot]=i;\n\t\tfor(int j=1;j<=tot;j++){\n\t\t\tif(prime[j]*i>=N) break;\n\t\t\tpd[prime[j]*i]=false;\n\t\t\tif(i%prime[j]==0) break;\n\t\t}\n\t}\n\tpd[1]=pd[2]=false;\n}\nbool pd2[N];\nint n,a[110];\nvector<int> v[2];\nvector<int> g[300];\nbool flag[300];\nint last[300];\nbool find(int x){\n\tint t;\n\tfor(int i = 0;i<g[x].size();i++) if(flag[t=g[x][i]]){\n\t\tflag[t] = false;\n\t\tif(last[t]==0) {\n\t\t\tlast[t] = x+1;\n\t\t\treturn true;\n\t\t} else if(find(last[t]-1)){\n\t\t\tlast[t] = x;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\nint main(){\n\tfind_prime();\n\tscanf(\"%d\",&n);\n\tfor(int i = 1;i<=n;i++)scanf(\"%d\",a+i),pd2[a[i]]=true;\n\tfor(int i = 1;i<N;i++) if(pd2[i]!=pd2[i-1]) v[i&1].push_back(i);\n\tfor(int i = 0;i<v[0].size();i++){\n\t\tfor(int j = 0;j<v[1].size();j++){\n\t\t\tif(pd[abs(v[0][i]-v[1][j])]) g[i].push_back(j),puts(\"YYY\");\n\t\t}\n\t}\n\tint tot = 0;\n\t//for(int i = 0;i<v[1].size();i++) cout<<v[1][i]<<endl;\n\tfor(int i = 0;i<v[0].size();i++) {\n\t\tmemset(flag,true,sizeof(flag));\t\n\t\tif(find(i)) tot++;\n\t}\n\t//cout<<tot<<endl;\n\tprintf(\"%d\\n\",tot+(v[0].size()-tot)/2*2+(v[1].size()-tot)/2*2+(v[0].size()-tot)%2*3);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <algorithm>\n#include <cstdio>\n#include <cmath>\n#include <set>\n#include <map>\n#include <queue>\n#include <string>\n#include <cstring>\n#include <bitset>\n#include <functional>\n#include <random>\n#define REP(i,a,n) for(int i=a;i<=n;++i)\n#define PER(i,a,n) for(int i=n;i>=a;--i)\n#define hr putchar(10)\n#define pb push_back\n#define lc (o<<1)\n#define rc (lc|1)\n#define mid ((l+r)>>1)\n#define ls lc,l,mid\n#define rs rc,mid+1,r\n#define x first\n#define y second\n#define io std::ios::sync_with_stdio(false)\n#define endl '\\n'\n#define DB(a) ({REP(__i,1,n) cout<<a[__i]<<' ';hr;})\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int P = 1e9+7, INF = 0x3f3f3f3f;\nll gcd(ll a,ll b) {return b?gcd(b,a%b):a;}\nll qpow(ll a,ll n) {ll r=1%P;for (a%=P;n;a=a*a%P,n>>=1)if(n&1)r=r*a%P;return r;}\nll inv(ll x){return x<=1?1:inv(P%x)*(P-P/x)%P;}\ninline int rd() {int x=0;char p=getchar();while(p<'0'||p>'9')p=getchar();while(p>='0'&&p<='9')x=x*10+p-'0',p=getchar();return x;}\n//head\n\n\n\nconst int N = 10;\nint n;\nvector<int> g[N], h[N];\n\nint dfs(int x, int f, int d) {\n\th[x].clear();\n\tfor (int y:g[x]) if (y!=f) h[x].pb(dfs(y,x,d));\t\n\tif (h[x].size()%2==0) h[x].pb(0);\n\tif (h[x].size()==1) return h[x][0]+1;\n\tsort(h[x].begin(),h[x].end());\n\tint sz=h[x].size(),l=0,r=sz-1,ans=-1;\n\twhile (l<=r) {\n\t\tint ql=0,qr=sz-1,ok=1;\n\t\twhile (1) {\n\t\t\tif (ql==mid) ++ql;\n\t\t\tif (qr==mid) --qr;\n\t\t\tif (ql>qr) break;\n\t\t\tif (h[x][ql]+h[x][qr]>d) ok=0;\n\t\t\t++ql,--qr;\n\t\t}\n\t\tif (ok) ans=mid,r=mid-1;\n\t\telse l=mid+1;\n\t}\n\treturn ans<0?INF:h[x][ans]+1; \n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tREP(i,2,n) {\n\t\tint u, v;\n\t\tscanf(\"%d%d\", &u, &v);\n\t\tg[u].pb(v),g[v].pb(u);\n\t}\n\tint cnt = 0, rt = 0;\n\tREP(i,1,n) if (g[i].size()&1) rt = i, ++cnt;\n\tcnt /= 2;\n\tint l = 0, r = n-1, ans;\n\twhile (l<=r) {\n\t\tif (dfs(rt,0,mid)<=mid+1) ans=mid,r=mid-1;\n\t\telse l=mid+1;\n\t}\n\tprintf(\"%d %d\\n\", cnt, ans);\n}\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "/*=======================================\n * Author : ylsoi\n * Problem : ARC80F\n * Algorithm : Graph Matching and Greed\n * Time : 2018.7.16\n * ===================================*/\n#include<bits/stdc++.h>\n\n#define REP(i,a,b) for(int i=a;i<=b;++i)\ntypedef long long ll;\n\nusing namespace std;\n\nvoid File(){\n    freopen(\"ARC80F.in\",\"r\",stdin);\n    freopen(\"ARC80F.out\",\"w\",stdout);\n}\n\nconst int maxn=500+10;\nint n,a[maxn],pos[maxn],tot,cnt,ans;\nint be[maxn],cnte,to[maxn*maxn],las[maxn*maxn],beg[maxn];\nbool vis[maxn];\n\nvoid add(int u,int v){\n    las[++cnte]=beg[u];\n    beg[u]=cnte;\n    to[cnte]=v;\n}\n\nbool pd(int x){\n    if(x==1 || x==2)return false;\n    int y=sqrt(x);\n    REP(i,2,y)if(x%i==0)return false;\n    return true;\n}\n\nbool Hungary(int u){\n    for(int i=beg[u];i;i=las[i]){\n        if(vis[to[i]])continue;\n        vis[to[i]]=1;\n        if(!be[to[i]] || Hungary(be[to[i]])){\n            be[to[i]]=u;\n            return true;\n        }\n    }\n    return false;\n}\n\nint main(){\n    File();\n    scanf(\"%d\",&n);\n    REP(i,1,n){\n        scanf(\"%d\",&a[i]);\n        if(i==1 || a[i-1]<a[i]-1)pos[++tot]=a[i];\n        if(i!=1 && a[i]>a[i-1]+1)pos[++tot]=a[i-1]+1;\n    }\n    pos[++tot]=a[n]+1;\n    REP(i,1,tot)if(pos[i]%2)++cnt;\n    REP(i,1,tot)if(pos[i]%2==0){\n        REP(j,1,tot)if(pos[j]%2==1 && pd(abs(pos[j]-pos[i])))\n            add(i,j);\n    }\n    REP(i,1,tot)if(pos[i]%2==0){\n        memset(vis,0,sizeof(vis));\n        ans+=Hungary(i);\n    }\n    printf(\"%d\\n\",ans+(tot-ans*2)+(cnt-ans)%2);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nnamespace Dinic{\n\t#define N 205\n\t#define M 80005\n\t#define INF 0x3f3f3f3f\n\tstruct edge{\n\t\tint flow,t,next;\n\t}e[M];int ecnt,head[N];\n\tvoid addedge(int f,int t,int fl){\n\t\te[++ecnt]=(edge){fl,t,head[f]};head[f]=ecnt;\n\t\te[++ecnt]=(edge){0,f,head[t]};head[t]=ecnt;\n\t}\n\t//----------------\n\tint S,T;\n\tint dis[N],cur[N];\n\tbool BFS(){\n\t\tmemset(dis,0x3f,sizeof(dis));\n\t\tdis[S]=0;queue<int> que;que.push(S);\n\t\twhile(!que.empty()){\n\t\t\tint u=que.front();que.pop();\n\t\t\tfor(int i=head[u];i;i=e[i].next){\n\t\t\t\tif(e[i].flow!=0&&dis[e[i].t]==0x3f3f3f3f){\n\t\t\t\t\tdis[e[i].t]=dis[u]+1,que.push(e[i].t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn dis[T]!=INF;\n\t}\n\t\n\tint DFS(int u,int a){\n\t\tif(u==T||a==0) return a;\n\t\tint ret=0;\n\t\tfor(int &i=cur[u];i;i=e[i].next){\n\t\t\tif(e[i].flow==0||dis[e[i].t]!=dis[u]+1) continue;\n\t\t\tint f=DFS(e[i].t,a<e[i].flow? a:e[i].flow);\n\t\t\tif(f){\n\t\t\t\te[i].flow-=f;e[i^1].flow+=f;\n\t\t\t\tret+=f;a-=f;\n\t\t\t\tif(a==0) return ret;\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\tint work(int S1,int T1){\n\t\tS=S1,T=T1;\n\t\tint ret=0;\n\t\twhile(BFS()){\n\t\t\tmemcpy(cur,head,sizeof(cur));\n\t\t\tret+=DFS(S1,INF);\n\t\t}\n\t\treturn ret;\n\t}\n\tvoid initialize(){\n\t\tecnt=1;memset(head,0,sizeof(head));\n\t}\n\t#undef N\n\t#undef M\n\t#undef INF\n}\n\n#define N 205\n#define M 10000007\n#define INF 0x3f3f3f3f\n\nint n;\nint pos[N],pcnt;\nint dp[N][N];\nbool p[M];\nint main(){\n    scanf(\"%d\",&n);\n    for(int i=1,t;i<=n;i++){\n        scanf(\"%d\",&t);\n        if(pcnt>0&&pos[pcnt]==t) pos[pcnt]=t+1;\n        else pos[++pcnt]=t,pos[++pcnt]=t+1;\n    }\n    for(int i=2;i<M;i++){\n        p[i]=!p[i];\n        if(p[i])\n           for(int j=i+i;j<M;j+=i) p[j]=true;\n    }\n    int nodd=0,neven=0;\n    for(int i=1;i<=pcnt;i++)\n        pos[i]%2==0? neven++:nodd++;\n    \n    Dinic::initialize();\n    for(int i=1;i<=pcnt;i++)    \n        for(int j=1;j<=pcnt;j++)\n            if(pos[i]%2==0 && pos[i]%2==1 && p[abs(pos[i]-pos[j])])\n                Dinic::addedge(i,j,1);\n    int S=pcnt+1,T=S+1;\n    for(int i=1;i<=pcnt;i++)\n        if(pos[i]%2==0) Dinic::addedge(S,i,1);\n        else Dinic::addedge(i,T,1);\n    \n    int ans=Dinic::work(S,T);\n    cout<<ans+(nodd-ans)/2*2+(neven-ans)/2*2+(nodd-ans)%2*3;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(n) for(lint I = 0; (I) < (lint)(n); ++(I))\n#define repeat(i, n) for(lint i = 0; (i) < (lint)(n); ++(i))\n#define repeat_to(i, n) for(lint i = 0; (i) <= (lint)(n); ++(i))\n#define repeat_from(i, m, n) for(lint i = (m); (i) < (lint)(n); ++(i))\n#define repeat_from_to(i, m, n) for(lint i = (m); (i) <= (lint)(n); ++(i))\n#define el cout<<endl\n#define dump(x) cout<<\" \"<<#x<<\"=\"<<x\n#define vdump(v) for(size_t I=0; I<v.size(); ++I){cout<<\" \"<<#v<<\"[\"<<I<<\"]=\"<<v[I];} cout<<endl\nusing namespace std;\nusing lint = long long;\nusing ld = long double;\n\n// 2部グラフの最大マッチング O(f(N+M)) f:=最大マッチング数で高々N\nclass bipartite_matching {\npublic:\n    int n;\n    std::vector<std::vector<int>> g;\n    std::vector<int> match;\n\n    bipartite_matching(int n_) : n(n_), g(n_), match(n_), used(n_) {}\n\n    void add_edge(int u, int v) {\n        g[u].push_back(v);\n        g[v].push_back(u);\n    }\n\n    int maximum_matching(void) {\n        int res = 0;\n        fill(begin(match), end(match), -1);\n        for (int v = 0; v < n; ++v) {\n            if (match[v] == -1) {\n                fill(begin(used), end(used), false);\n                if (dfs(v)) res++;\n            }\n        }\n        return res;\n    }\n\nprivate:\n    std::vector<int> used;\n    bool dfs(int v) {\n        used[v] = true;\n        for (int u : g[v]) {\n            int w = match[u];\n            if (w == -1 || (!used[w] && dfs(w))) {\n                match[v] = u;\n                match[u] = v;\n                return true;\n            }\n        }\n        return false;\n    }\n};\n\n// エラトステネスの篩[2,n]を列挙 O(nloglogn)\nvector<lint> sieve_of_eratosthenes(lint n) {\n    vector<bool> is_prime(n+1, true);\n    is_prime[0] = is_prime[1] = false;\n    for (lint i = 2; i*i <= n; ++i)\n        if (is_prime[i])\n            for (lint k = i+i; k <= n; k += i)\n                is_prime[k] = false;\n    vector<lint> primes;\n    for (lint i = 2; i <= n; ++i)\n        if (is_prime[i])\n            primes.push_back(i);\n    return primes;\n}\n\nint main(void) {\n    int n; cin >> n;\n    \n    vector<int> x, y_tag, y;\n    rep(n) {\n        int a; cin >> a;\n        x.push_back(a);\n    }\n    \n    repeat(i, n) {\n        y_tag.push_back(x[i] - 1);\n        y_tag.push_back(x[i]);\n    }\n    \n    repeat(i, y_tag.size()) {\n        if (count(y_tag.begin(), y_tag.end(), y_tag[i]) % 2 == 1) {\n            y.push_back(y_tag[i]);\n        }\n    }\n    sort(y.begin(), y.end());\n    \n    // 1 - 10^7+1 の奇素数リスト\n    vector<lint> primes = sieve_of_eratosthenes(1e7 + 1);\n    \n    auto is_odd_prime = [&primes](const lint p) -> bool {\n        assert(p > 0);\n        if (p == 1) return false;\n        if (p % 2 == 0) return false;\n        if (!binary_search(primes.begin(), primes.end(), p)) return false;\n        return true;\n    };\n    \n    lint odds_num = 0, evens_num = 0;\n    repeat(i, y.size()) {\n        if (y[i] % 2 == 1) ++odds_num;\n        else ++evens_num;\n    }\n    \n    bipartite_matching bm(y.size());\n    \n    repeat(i, y.size()) {\n        repeat_from(j, i + 1, y.size()) {\n            lint d = y[j] - y[i];\n            if (y[i] % 2 != y[j] % 2 && is_odd_prime(d)) {\n                bm.add_edge(i, j);\n            }\n        }\n    }\n    \n    lint matching_num = bm.maximum_matching();\n    \n    lint ans = matching_num;\n    lint odds_remains = odds_num - matching_num;\n    lint evens_remains = evens_num - matching_num;\n    \n    if ( odds_remains % 2 == 0) {\n        ans += ((odds_remains) / 2) * 2;\n        ans += ((evens_remains) / 2) * 2;\n    }\n    else {\n        ans += ((odds_remains) / 2) * 2;\n        ans += ((evens_remains) / 2) * 2;\n        ans += 3;\n    }\n    cout << ans << endl;\n    \n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<cstring>\n#include<map>\n#include<queue>\nusing namespace std;\ntypedef long long ll;\nconst int N=105,INF=~0u>>2;\nstruct Edge{int nxt,to;}edge[(N*N)<<2];\nint a[N],b[N],n,head[N<<2],num_edge,vis[N<<2],lk[N<<2],even[N],odd[N],even_num,odd_num,ans,k,tot,tim;\nint read(){\n\tint x=0,f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-') f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn f*x;\n}\nvoid add_edge(int from,int to){\n\tedge[++num_edge].nxt=head[from];\n\tedge[num_edge].to=to;\n\thead[from]=num_edge;\n}\nbool find(int x){\n\tfor(int i=head[x];i;i=edge[i].nxt){\n\t\tif(vis[edge[i].to]!=tim){\n\t\t\tvis[edge[i].to]=tim;\n\t\t\tif(!lk[edge[i].to]||find(edge[i].to)){\n\t\t\t\tlk[edge[i].to]=x;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nbool check(int x){\n\tfor(int i=2;i*i<=x;++i){\n\t\tif(x%i==0) return 0;\n\t}\n\treturn 1;\n}\nint main(){\n//\tfreopen(\"ex.in\",\"r\",stdin);\n\tn=read();\n\tfor(int i=1;i<=n;++i) b[i]=read();\n\tfor(int i=1;i<=n;++i){\n\t\tif(b[i]!=b[i-1]+1){\n\t\t\ta[++tot]=i;\n\t\t\tif(i%2) odd[++odd_num]=i;\n\t\t\telse even[++even_num]=i;\n\t\t}\n\t\tif(b[i]+1!=b[i+1]){\n\t\t\ta[++tot]=i+1;\n\t\t\tif((i+1)%2) odd[++odd_num]=i+1;\n\t\t\telse even[++even_num]=i+1;\n\t\t}\n\t}\n\tfor(int i=1;i<=odd_num;++i){\n\t\tfor(int j=1;j<=even_num;++j){\n\t\t\tif(odd[i]>even[j]) continue;\n\t\t\tif(check(even[j]-odd[i])) add_edge(i,odd_num+j),add_edge(odd_num+j,i);\n\t\t}\n\t}\n\tfor(int i=1;i<=odd_num;++i,++tim){\n\t\tif(find(i)) k++;\n\t\telse break;\n\t}\n\tans=k+((even_num-k)/2+(odd_num-k)/2)*2+((even_num-k)%2)*3;\n\tprintf(\"%d\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*#include<cstdio>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nvector<int> T[260];\nint n, m, cnt, Num[260][260];\nint L[260][260], R[260][260], X[260][260], A[260][260];\nclass HiddenRabbits{\npublic:\n    vector <int> whereAreTheRabbits(vector <int> p, int M, vector <int> r, vector <int> a, vector <int> b, vector <int> x){\n        m = M;\n        int i, j;\n        n = p.size() + 1;\n        for(i=0;i<n-1;i++){\n            T[i+2].push_back(p[i]+1);\n            T[p[i]+1].push_back(i+2);\n        }\n        for(i=1;i<=n;i++){\n            for(j=0;j<T[i].size();j++){\n                Num[i][T[i][j]] = j;\n                L[i][j] = ++cnt;\n                R[i][j] = ++cnt;\n                X[i][j] = ++cnt;\n                A[i][j] = ++cnt;\n            }\n        }\n        for(i=1;i<=n;i++){\n            int sz = T[i].size();\n            Same(L[i][0], A[T[i][0]][Num[T[i][0]][i]]);\n            Same(R[i][sz-1], A[T[i][sz-1]][Num[T[i][sz-1]][i]]);\n            for(j=0;j<T[i].size();j++){\n                Same(\n            }\n        }\n    }\n};\n*/\n\n#include<cstdio>\n#include<algorithm>\n#include<map>\nusing namespace std;\nint F[210][210], n, A[210], B[210], CA, CB, sink, v[210], cur = 1;\nmap<int,int>Map;\nbool Prime(int a){\n    if(a<0)a=-a;\n    if(a==1)return false;\n    int i;\n    for(i=2;i*i<=a;i++)if(a%i==0)return false;\n    return true;\n}\nint MaxFlow(int a){\n    if(a==sink)return 1;\n    v[a] = cur;\n    int i;\n    for(i=0;i<=sink;i++){\n        if(F[a][i] && v[i]!=cur){\n            if(MaxFlow(i)){\n                F[a][i]--;\n                F[i][a]++;\n                return 1;\n            }\n        }\n    }\n    return 0;\n}\nint main(){\n    int i, a, j, f = 0;\n    scanf(\"%d\",&n);\n    for(i=1;i<=n;i++){\n        scanf(\"%d\",&a);\n        Map[a]++;\n        Map[a+1]++;\n    }\n    for(auto &p : Map){\n        if(p.second%2 == 1){\n            if(p.first%2 == 0) A[++CA] = p.first;\n            else B[++CB] = p.second;\n        }\n    }\n    sink = CA+CB+1;\n    for(i=1;i<=CA;i++){\n        for(j=1;j<=CB;j++){\n            if(Prime(B[j]-A[i])){\n                F[i][CA+j] = 1;\n            }\n        }\n        F[0][i]=1;\n    }\n    for(i=CA+1;i<=CA+CB;i++)F[i][sink]=1;\n    while(MaxFlow(0)){\n        f++,cur++;\n    }\n    printf(\"%d\\n\", f + (CA-f)/2*2 + (CB-f)/2*2 + (CA-f)%2*3);\n}"
  },
  {
    "language": "C++",
    "code": "/********************************************************************************\n\t\n\tCode by a weak man named CYJian, and he hopes the code can get more points.\n\n\tAlgorithm: \n\n ********************************************************************************/\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\n//{{{ FAST IO AND SOME FUNCTIONS\nconst int __SIZE = 1 << 18;\nchar ibuf[__SIZE], *iS, *iT;\n\n#define ge (iS == iT ? (iT = (iS = ibuf) + fread(ibuf, 1, __SIZE, stdin), (iS == iT ? EOF : *iS++)) : *iS++)\n#define ri read_int()\n#define rl read_ll()\n#define FILE(s) freopen(s\"in\", \"r\", stdin), freopen(s\"out\", \"w\", stdout)\n\ntemplate<typename T>\ninline void read(T &x) {\n\tchar ch, t = 0; x = 0;\n\twhile(!isdigit(ch = ge)) t |= ch == '-';\n\twhile(isdigit(ch)) x = x * 10 + (ch ^ 48), ch = ge;\n\tx = t ? -x : x;\n}\ninline int read_int() { int x; return read(x), x; }\ninline ll read_ll() { ll x; return read(x), x; }\n\ntemplate<typename T> inline void chkmin(T&a, T b) { a = a < b ? a : b; }\ntemplate<typename T> inline void chkmax(T&a, T b) { a = a > b ? a : b; }\n//}}}\n\nint tot;\nint pri[5010];\nint chk[5010];\n\ninline void Sieve(int n) {\n\tchk[1] = 1;\n\tfor(int i = 2; i <= n; i++) {\n\t\tif(!chk[i]) pri[++tot] = i;\n\t\tfor(int j = 1; j <= tot; j++) {\n\t\t\tif(i * pri[j] > n) break;\n\t\t\tchk[i * pri[j]] = 1;\n\t\t\tif(i % pri[j] == 0) break;\n\t\t}\n\t}\n}\n\ninline int check(int x) {\n\tif(x <= 5000) return !chk[x];\n\tfor(int *p = pri + 1;; ++p) {\n\t\tif((*p) * (*p) > x) return 1;\n\t\tif(x % (*p) == 0) return 0;\n\t}\n}\n\nvector<int>to[210];\nint vis[210];\nint arr[210];\nint p[210];\nint tim, N;\n\ninline int Try(int x) {\n\tfor(auto u : to[x]) {\n\t\tif(arr[u] == tim) continue;\n\t\tarr[u] = tim;\n\t\tif(!vis[u] || Try(vis[u])) {\n\t\t\tvis[u] = x;\n\t\t\tvis[x] = u;\n\t\t\treturn 1;\n\t\t}\n\t} return 0;\n}\n\nint main() {\n#ifdef LOCAL\n\tFILE(\"\");\n#endif\n\n\tSieve(5000);\n\tint n = ri, ce = 0, co = 0;\n\n\tfor(int i = 1; i <= n; i++) {\n\t\tint x = ri;\n\t\tif(p[N] == x) --N;\n\t\telse p[++N] = x;\n\t\tp[++N] = x + 1;\n\t}\n\n\tfor(int i = 1; i <= N; i++) \n\t\tp[i] & 1 ? ++co : ++ce;\n\n\tfor(int i = 1; i <= N; i++)\n\t\tfor(int j = i + 1; j <= N; j++)\n\t\t\tif(((p[i] ^ p[j]) & 1) && check(p[j] - p[i]))\n\t\t\t\tto[i].push_back(j), to[j].push_back(i);\n\n\tint res = 0;\n\tfor(int i = tim = 1; i <= N; ++i, ++tim)\n\t\tif((p[i] & 1) && Try(i))\n\t\t\t--co, --ce, ++res;\n\n\tres += (co / 2 + ce / 2) << 1;\n\tif((co | ce) & 1) res += 3;\n\n\tcout << res << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <vector>\nstatic const int MAXN = 102;\nstatic const int MAXX = 1e7 + 200;\nstatic const int INF = 0x3fffffff;\n\nint n, x[MAXN];\nint m, y[MAXN * 2], k;\n\nbool not_prime[MAXX] = { false };\nint primes[MAXX / 10], prime_ct = 0;\n\ninline void sieve()\n{\n    not_prime[0] = not_prime[1] = true;\n    for (int i = 2; i < MAXX; ++i) {\n        if (!not_prime[i]) primes[prime_ct++] = i;\n        for (int j = 0; j < prime_ct && i * primes[j] < MAXX; ++j) {\n            not_prime[i * primes[j]] = true;\n            if (i % primes[j] == 0) break;\n        }\n    }\n}\n\nnamespace nwf {\n\nstatic const int MAXN = ::MAXN * 2 + 2;\n\nint n, source, sink;\nstruct edge {\n    int dest, cap, resi;\n    edge() { }\n    edge(int dest, int cap, int resi)\n        : dest(dest), cap(cap), resi(resi) { }\n};\nstd::vector<edge> e[MAXN];\n\ninline void init(int _n) {\n    n = _n;\n    for (int i = 0; i < n; ++i) e[i].clear();\n}\n\ninline void add_edge(int u, int v, int c, int r = 0) {\n    e[u].push_back(edge(v, c, e[v].size()));\n    e[v].push_back(edge(u, r, e[u].size() - 1));\n}\n\nint lim;\nint d[MAXN];\n\ninline bool level_graph() {\n    static int q[MAXN], qhead, qtail;\n    for (int i = 0; i < n; ++i) d[i] = -1;\n    d[source] = 0, q[0] = source, qhead = 0, qtail = 1;\n\n    while (qhead < qtail) {\n        int u = q[qhead++];\n        for (std::vector<edge>::iterator w = e[u].begin(); w != e[u].end(); ++w)\n            if (w->cap >= lim && d[w->dest] == -1) {\n                d[w->dest] = d[u] + 1;\n                q[qtail++] = w->dest;\n            }\n    }\n\n    return (d[sink] >= 0);\n}\n\nint cur[MAXN];\n\ninline int augment(int u, int cur_cap) {\n    if (u == sink) return cur_cap;\n    int new_cap;\n    for (int &i = cur[u]; i < e[u].size(); ++i) {\n        edge &w = e[u][i];\n        if (w.cap >= lim && d[w.dest] == d[u] + 1 &&\n            (new_cap = augment(w.dest, std::min(w.cap, cur_cap))) >= lim)\n        {\n            w.cap -= new_cap;\n            e[w.dest][w.resi].cap += new_cap;\n            return new_cap;\n        }\n    }\n    return 0;\n}\n\ninline int deluge() {\n    int ans = 0, aug;\n    for (lim = 1 << 22; lim > 0; lim >>= 1) {\n        while (level_graph()) {\n            for (int i = 0; i < n; ++i) cur[i] = 0;\n            while ((aug = augment(source, INF)) > 0) ans += aug;\n        }\n    }\n    return ans;\n}\n\n}\n\nint main()\n{\n    sieve();\n\n    scanf(\"%d\", &n);\n    for (int i = 0; i < n; ++i) scanf(\"%d\", &x[i]);\n    y[0] = x[0]; m = 1;\n    for (int i = 1; i < n; ++i)\n        if (x[i] != x[i - 1] + 1) { y[m++] = x[i - 1] + 1; y[m++] = x[i]; }\n    y[m++] = x[n - 1] + 1;\n\n    k = std::partition(y, y + m, [] (int x) { return x & 1; }) - &y[0];\n\n    nwf::init(m + 2);\n    nwf::source = m, nwf::sink = m + 1;\n    for (int i = 0; i < k; ++i) nwf::add_edge(nwf::source, i, 1);\n    for (int i = k; i < m; ++i) nwf::add_edge(i, nwf::sink, 1);\n    for (int i = 0; i < k; ++i)\n        for (int j = k; j < m; ++j)\n            if (!not_prime[std::abs(y[j] - y[i])]) nwf::add_edge(i, j, 1);\n\n    int match = nwf::deluge();\n    int ans = match * 1 + ((k - match) / 2) * 2 + ((m - k - match) / 2) * 2 + ((k - match) & 1) * 3;\n    printf(\"%d\\n\", ans);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fi first\n#define se second\n#define pii pair<int,int>\n#define mp make_pair\n#define pb push_back\n#define space putchar(' ')\n#define enter putchar('\\n')\n#define MAXN 200005\n#define eps 1e-12\n//#define ivorysi\nusing namespace std;\ntypedef long long int64;\ntypedef unsigned int u32;\ntypedef double db;\ntemplate<class T>\nvoid read(T &res) {\n    res = 0;T f = 1;char c = getchar();\n    while(c < '0' || c > '9') {\n        if(c == '-') f = -1;\n        c = getchar();\n    }\n    while(c >= '0' && c <= '9') {\n        res = res * 10 + c - '0';\n        c = getchar();\n    }\n    res *= f;\n}\ntemplate<class T>\nvoid out(T x) {\n    if(x < 0) {x = -x;putchar('-');}\n    if(x >= 10) {\n        out(x / 10);\n    }\n    putchar('0' + x % 10);\n}\nint N;\nbool nonprime[10000005],vis[10000005];\nint prime[5000005],tot,x[205],b[205],M[2],matc[205];\nvector<int> to[505];\nbool used[205];\nbool match(int u) {\n    for(auto t : to[u]) {\n        if(!used[t]) {\n            used[t] = 1;\n            if(!matc[t] || match(matc[t])) {\n                matc[t] = u;\n                return true;\n            }\n        }\n    }\n    return false;\n}\nvoid Solve() {\n    read(N);\n    for(int i = 1 ; i <= N ; ++i) {\n        read(x[i]);\n        vis[x[i]] = 1;\n    }\n    for(int i = 2 ; i <= 10000000 ; ++i) {\n        if(!nonprime[i]) {\n            prime[++tot] = i;\n        }\n        for(int j = 1 ; j <= tot ; ++j) {\n            if(prime[j] > 10000000 / i) break;\n            nonprime[i * prime[j]] = 1;\n            if(i % prime[j] == 0) break;\n        }\n    }\n    tot = 0;\n    for(int i = 1 ; i <= 10000001 ; ++i) {\n        if(vis[i] != vis[i - 1]) b[++tot] = i;\n    }\n    for(int i = 1 ; i <= tot ; ++i) {\n        M[b[i] & 1]++;\n        for(int j = 1 ; j <= tot ; ++j) {\n            if(i == j) continue;\n            if(!nonprime[abs(b[i] - b[j])]) to[i].pb(j);\n        }\n    }\n    int ans = 0;\n    for(int i = 1 ; i <= tot ; ++i) {\n        if(b[i] & 1) {\n            memset(used,0,sizeof(used));\n            if(match(i)) ++ans;\n        }\n    }\n    out(ans + ((M[0] - ans) / 2 + (M[1] - ans) / 2) * 2 + ((M[0] - ans) & 1) * 3);enter;\n}\nint main() {\n#ifdef ivorysi\n\tfreopen(\"f1.in\",\"r\",stdin);\n#endif\n    Solve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#pragma GCC optimize(2)\nusing namespace std;\nlong long read()\n{\n\tchar ch=getchar();long long x=0,ff=1;\n\twhile(ch<'0'||ch>'9') {if(ch=='-') ff=-ff;ch=getchar();}\n\twhile(ch>='0'&&ch<='9') x=x*10+ch-'0',ch=getchar();\n\treturn x*ff;\n}\nvoid write(long long aa)\n{\n\tif(aa<0) putchar('-'),aa=-aa;\n\tif(aa>9) write(aa/10);\n\tputchar(aa%10+'0');\n\treturn;\n}\nlong long n,cnt,L,R,ans;\nlong long a[105],md[205];\nlong long l[205],r[205],dy[205],vis[205];\nlong long tot,head[205],nx[400005],to[400005];\nvoid add(long long aa,long long bb)\n{\n\ttot++;\n\tnx[tot]=head[aa];\n\tto[tot]=bb;\n\thead[aa]=tot;\n\treturn;\n}\nlong long ok(long long aa,long long bb)\n{\n\tlong long len=abs(md[aa]-md[bb]);\n\tfor(long long i=2;i*i<=len;++i) if(len%i==0) return 0;\n\treturn 1;\n}\nlong long dfs(long long rt)\n{\n\tfor(long long i=head[rt];i;i=nx[i])\n\t{\n\t\tlong long yy=to[i];\n\t\tif(vis[yy]) continue;vis[yy]=1;\n\t\tif(!dy[yy]||dfs(dy[yy])) {dy[yy]=rt;return 1;}\n\t}\n\treturn 0;\n}\nint main()\n{\n\tn=read();a[0]=-10;\n\tfor(long long i=1;i<=n;++i) a[i]=read();\n\tfor(long long i=1;i<=n;++i) \n\t{\n\t\tif(a[i]!=a[i-1]+1) md[++cnt]=a[i]-1;\n\t\tif(a[i]+1!=a[i+1]) md[++cnt]=a[i];\n\t}\n\tfor(long long i=1;i<=cnt;++i) \n\tif(md[i]%2==0) l[++L]=i;\n\telse r[++R]=i;\n\tfor(long long i=1;i<=L;++i) for(long long j=1;j<=R;++j) \n\tif(ok(l[i],r[j])) add(l[i],r[j]);\n\tfor(long long i=1;i<=L;++i) \n\t{\n\t\tmemset(vis,0,sizeof(vis));\n\t\tif(dfs(l[i])) ans++;\n\t}\n\tlong long ls=L-ans,rs=R-ans;\n\tans+=ls/2*2;ans+=rs/2*2;\n\tif(ls%2==1) ans+=3;\n\twrite(ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n#include<cstring>\n\nusing namespace std;\n\nusing vi = vector<int>;\nvi X;\nint n;\nvector<vi> C;\nint used[207];\nbool isprime(int n) {\n\tif (n <= 2)return false;\n\tfor (int i = 2; i*i <= n; i++) {\n\t\tif (n%i == 0)return false;\n\t}\n\treturn true;\n}\nbool dfs(int v) {\n\tused[v] = true;\n\tif (v == X.size() + 1) return true;\n\tfor (int i = 0; i < X.size() + 2; i++) {\n\t\tif (!used[i] && C[v][i] > 0) {\n\t\t\tif (dfs(i)) {\n\t\t\t\tC[v][i]--;\n\t\t\t\tC[i][v]++;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\nint main() {\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) {\n\t\tint x;\n\t\tcin >> x;\n\t\tif (!X.empty() && X.back() == x) {\n\t\t\tX.pop_back();\n\t\t\tX.push_back(x + 1);\n\t\t}\n\t\telse {\n\t\t\tX.push_back(x);\n\t\t\tX.push_back(x + 1);\n\t\t}\n\t}\n\tint E = 0;\n\tint O = 0;\n\tfor (int x : X) {\n\t\tif (x % 2 == 0) {\n\t\t\tE++;\n\t\t}\n\t\telse {\n\t\t\tO++;\n\t\t}\n\t}\n\t\t\n\tC.resize(X.size()+2, vi(X.size()+2, 0));\n\tfor (int i = 0; i < X.size(); i++) {\n\t\tif (X[i] % 2 == 0) {\n\t\t\tC[X.size()][i] = 1;\n\t\t}\n\t\telse {\n\t\t\tC[i][X.size() + 1] = 1;\n\t\t}\n\t}\n\tfor (int i = 0; i < X.size(); i++) {\n\t\tfor (int j = i; j < X.size(); j++) {\n\t\t\tif (isprime(abs(X[i] - X[j]))) {\n\t\t\t\tint a = i;\n\t\t\t\tint b = j;\n\t\t\t\tif (X[b] % 2 == 0)swap(a, b);\n\t\t\t\tC[a][b] = 1;\n\t\t\t}\n\t\t}\n\t}\n\tint ans = 0;\n\twhile (dfs(X.size())) {\n\t\tfor (int i = 0; i < 207; i++)used[i] = false;\n\t\tans++;\n\t}\n\tif ((E - ans) % 2 == 0) {\n\t\tcout << ans + (E - ans + O - ans) << endl;\n\t}\n\telse {\n\t\tcout << ans + (E - ans - 1 + O - ans - 1) + 3 << endl;\n\t}\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <algorithm>\n#include <cstdio>\n#include <cmath>\n#include <set>\n#include <map>\n#include <queue>\n#include <string>\n#include <cstring>\n#include <bitset>\n#include <functional>\n#include <random>\n#define REP(i,a,n) for(int i=a;i<=n;++i)\n#define PER(i,a,n) for(int i=n;i>=a;--i)\n#define hr putchar(10)\n#define pb push_back\n#define lc (o<<1)\n#define rc (lc|1)\n#define mid ((l+r)>>1)\n#define ls lc,l,mid\n#define rs rc,mid+1,r\n#define x first\n#define y second\n#define io std::ios::sync_with_stdio(false)\n#define endl '\\n'\n#define DB(a) ({REP(__i,1,n) cout<<a[__i]<<' ';hr;})\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n\nconst int N = 1e6+10, S = N-2, T = N-1, INF = 0x3f3f3f3f;\nconst int M = 1e7+10;\nint n, m, f[M];\nstruct edge {\n    int to,w,next;\n    edge(int to=0,int w=0,int next=0):to(to),w(w),next(next){}\n} e[N];\nint head[N], dep[N], vis[N], cur[N], cnt=1;\nqueue<int> Q;\nint bfs() {\n    REP(i,1,m) dep[i]=INF,vis[i]=0,cur[i]=head[i];\n    dep[S]=INF,vis[S]=0,cur[S]=head[S];\n    dep[T]=INF,vis[T]=0,cur[T]=head[T];\n    dep[S]=0,Q.push(S);\n    while (Q.size()) {\n        int u = Q.front(); Q.pop();\n        for (int i=head[u]; i; i=e[i].next) {\n            if (dep[e[i].to]>dep[u]+1&&e[i].w) {\n                dep[e[i].to]=dep[u]+1;\n                Q.push(e[i].to);\n            }\n        }\n    }\n    return dep[T]!=INF;\n}\nint dfs(int x, int w) {\n    if (x==T) return w;\n    int used = 0;\n    for (int i=cur[x]; i; i=e[i].next) {\n        cur[x] = i;\n        if (dep[e[i].to]==dep[x]+1&&e[i].w) {\n            int f = dfs(e[i].to,min(w-used,e[i].w));\n            if (f) used+=f,e[i].w-=f,e[i^1].w+=f;\n            if (used==w) break;\n        }\n    }\n    return used;\n}\nint dinic() {\n    int ans = 0;\n    while (bfs()) ans+=dfs(S,INF);\n    return ans;\n}\nvoid add(int u, int v, int w) {\n    e[++cnt] = edge(v,w,head[u]);\n    head[u] = cnt;\n    e[++cnt] = edge(u,0,head[v]);\n    head[v] = cnt;\n}\n\nint chk(int x) {\n\tif (x<=2) return 0;\n\tint mx = sqrt(x+0.5);\n\tREP(i,2,mx) if (x%i==0) return 0;\n\treturn 1;\n}\nint main() {\n\tscanf(\"%d\", &n);\n\tREP(i,1,n) { \n\t\tint t;\n\t\tscanf(\"%d\", &t);\n\t\tf[t] = 1;\n\t}\n\tvector<pii> A, B;\n\tREP(i,1,M-1) if (f[i]!=f[i-1]) {\n\t\tif (i&1) A.pb(pii(i,++m)),add(S,m,1);\n\t\telse B.pb(pii(i,++m)),add(m,T,1);\n\t}\n\tfor (auto t:A) for (auto tt:B) { \n\t\tif (chk(abs(t.x-tt.x))) {\n\t\t\tadd(t.y,tt.y,1);\n\t\t}\n\t}\n\tint flow = dinic();\n\tint ans = flow, x = A.size()-flow, y = B.size()-flow;\n\tans += x/2*2, x %= 2;\n\tans += y/2*2, y %= 2;\n\tif (x) ans += 3;\n\tprintf(\"%d\\n\", ans);\n}\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define inf (1e9 + 7)\n#define mem(a, b) memset(a, b, sizeof(a))\nusing namespace std;\n\nint n, num[105], num2[205], nn = 0, ji = 0, ou = 0, lk[205], ans = 0;\nbool vis[205];\nvector<int> eg[205];\n\nbool dfs(int u)\n{\n    int lim = eg[u].size();\n    for(int i = 0;i < lim;i++)\n    {\n        int v = eg[u][i];\n        if(!vis[v])\n        {\n            vis[v] = 1;\n            if(lk[v] == -1||dfs(lk[v]))\n            {\n                lk[v] = u;\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\nbool jg(int a)\n{\n    if(a < 2)\n        return false;\n    if(a == 2)\n        return true;\n    for(int i = 2;i * i <= a;i++)\n    {\n        if(a % i == 0)\n            return false;\n    }\n    return true;\n}\n\nint main()\n{\n    mem(lk, -1);\n    scanf(\"%d\", &n);\n    for(int i = 1;i <= n;i++)\n        scanf(\"%d\", &num[i]);\n    sort(num + 1, num + 1 + n);\n    num2[++nn] = num[1];\n    for(int i = 2;i <= n;i++)\n    {\n        if(num[i] - 1 != num[i - 1])\n        {\n            num2[++nn] = num[i - 1] + 1;\n            num2[++nn] = num[i];\n        }\n    }\n    num2[++nn] = num[n] + 1;\n    for(int i = 1;i <= nn;i++)\n    {\n        if(num2[i] % 2 == 0)\n        {\n            ou++;\n            for(int j = i + 1;j <= nn;j++)\n            {\n                if(jg(num2[j] - num2[i]))\n                    eg[j].push_back(i);\n            }\n        }\n        else\n        {\n            ji++;\n            for(int j = i + 1;j <= nn;j++)\n            {\n                if(jg(num2[j] - num2[i]))\n                    eg[i].push_back(j);\n            }\n        }\n    }\n    int res = 0;\n    for(int i = 1;i <= nn;i++)\n    {\n        if(num2[i] % 2 == 0)\n            continue;\n        mem(vis, 0);\n        if(dfs(i))\n            res++;\n    }\n    ans += res;\n    ji -= res;\n    ou -= res;\n    ans += ji / 2 * 2;\n    ji %= 2;\n    ans += ou / 2 * 2;\n    ou %= 2;\n    if(ji||ou)\n        ans += 3;\n    printf(\"%d\\n\", ans);\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(n) for(lint I = 0; (I) < (lint)(n); ++(I))\n#define repeat(i, n) for(lint i = 0; (i) < (lint)(n); ++(i))\n#define repeat_to(i, n) for(lint i = 0; (i) <= (lint)(n); ++(i))\n#define repeat_from(i, m, n) for(lint i = (m); (i) < (lint)(n); ++(i))\n#define repeat_from_to(i, m, n) for(lint i = (m); (i) <= (lint)(n); ++(i))\n#define el cout<<endl\n#define dump(x) cout<<\" \"<<#x<<\"=\"<<x\n#define vdump(v) for(size_t I=0; I<v.size(); ++I){cout<<\" \"<<#v<<\"[\"<<I<<\"]=\"<<v[I];} cout<<endl\nusing namespace std;\nusing lint = long long;\nusing ld = long double;\n\n// 2部グラフの最大マッチング O(f(N+M)) f:=最大マッチング数で高々N\nclass bipartite_matching {\npublic:\n    int n;\n    vector<vector<int>> g;\n    vector<int> match;\n\n    bipartite_matching(int n_) : n(n_), g(n_), match(n_), used(n_) {}\n\n    void add_edge(int u, int v) {\n        g[u].push_back(v);\n        g[v].push_back(u);\n    }\n\n    int maximum_matching(void) {\n        int res = 0;\n        fill(begin(match), end(match), -1);\n        for (int v = 0; v < n; ++v) {\n            if (match[v] == -1) {\n                fill(begin(used), end(used), false);\n                if (dfs(v)) res++;\n            }\n        }\n        return res;\n    }\n\nprivate:\n    vector<int> used;\n    bool dfs(int v) {\n        used[v] = true;\n        for (int u : g[v]) {\n            int w = match[u];\n            if (w == -1 || (!used[w] && dfs(w))) {\n                match[v] = u;\n                match[u] = v;\n                return true;\n            }\n        }\n        return false;\n    }\n};\n\n// エラトステネスの篩[2,n]を列挙 O(nloglogn)\nvector<lint> sieve_of_eratosthenes(lint n) {\n    vector<bool> is_prime(n+1, true);\n    is_prime[0] = is_prime[1] = false;\n    for (lint i = 2; i*i <= n; ++i)\n        if (is_prime[i])\n            for (lint k = i+i; k <= n; k += i)\n                is_prime[k] = false;\n    vector<lint> primes;\n    for (lint i = 2; i <= n; ++i)\n        if (is_prime[i])\n            primes.push_back(i);\n    return primes;\n}\n\nint main(void) {\n    int n; cin >> n;\n    \n    vector<int> x, y_tag, y;\n    rep(n) {\n        int a; cin >> a;\n        x.push_back(a);\n    }\n    \n    repeat(i, n) {\n        y_tag.push_back(x[i] - 1);\n        y_tag.push_back(x[i]);\n    }\n    \n    repeat(i, y_tag.size()) {\n        if (count(y_tag.begin(), y_tag.end(), y_tag[i]) % 2 == 1) {\n            y.push_back(y_tag[i]);\n        }\n    }\n    sort(y.begin(), y.end());\n    \n    // 1 - 10^7+1 の奇素数リスト\n    vector<lint> primes = sieve_of_eratosthenes(1e7 + 1);\n    \n    auto is_odd_prime = [&primes](const lint p) -> bool {\n        assert(p > 0);\n        if (p == 1) return false;\n        if (p % 2 == 0) return false;\n        if (!binary_search(primes.begin(), primes.end(), p)) return false;\n        return true;\n    };\n    \n    lint odds_num = 0, evens_num = 0;\n    repeat(i, y.size()) {\n        if (y[i] % 2 == 1) ++odds_num;\n        else ++evens_num;\n    }\n    \n    bipartite_matching bm(y.size());\n    \n    repeat(i, y.size()) {\n        repeat_from(j, i + 1, y.size()) {\n            lint d = y[j] - y[i];\n            if (y[i] % 2 != y[j] % 2 && is_odd_prime(d)) {\n                bm.add_edge(i, j);\n            }\n        }\n    }\n    \n    lint matching_num = bm.maximum_matching();\n    \n    lint ans = matching_num;\n    lint odds_remains = odds_num - matching_num;\n    lint evens_remains = evens_num - matching_num;\n    \n    if ( odds_remains % 2 == 0) {\n        ans += ((odds_remains) / 2) * 2;\n        ans += ((evens_remains) / 2) * 2;\n    }\n    else {\n        ans += ((odds_remains) / 2) * 2;\n        ans += ((evens_remains) / 2) * 2;\n        ans += 3;\n    }\n    cout << ans << endl;\n    \n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <cmath>\n\nusing namespace std;\n\nconst int MAXN = 200 + 100;\nconst int MAXM = 10000000 + 100;\n\nint pri[MAXM], totp = 0;\nbool isp[MAXM];\n\nvoid init()\n{\n\tmemset(isp, true, sizeof(isp));\n\tisp[0] = isp[1] = false;\n\tfor(int i = 2; i < MAXM; i++)\n\t{\n\t\tif(isp[i])\n\t\t\tpri[++totp] = i;\n\t\tfor(int j = 1; j <= totp && i * pri[j] < MAXM; j++)\n\t\t{\n\t\t\tisp[i * pri[j]] = false;\n\t\t\tif(i % pri[j] == 0) break;\n\t\t}\n\t}\n}\n\nstruct Edge\n{\n\tint next, to;\n}\ne[MAXN * MAXN];\nint p[MAXN], l = 2;\nvoid addE(int x, int y)\n{\n\te[l] = (Edge){p[x], y};\n\tp[x] = l++;\n}\nint size[2], vis[2][MAXN], match[2][MAXN];\n\nbool dfs(int x)\n{\n\tvis[0][x] = true;\n\tfor(int i = p[x]; i; i = e[i].next)\n\t\tif(!vis[1][e[i].to])\n\t\t{\n\t\t\tint y = e[i].to;\n\t\t\tvis[1][y] = true;\n\t\t\tif(!match[1][y] || dfs(match[1][y]))\n\t\t\t{\n\t\t\t\tmatch[0][x] = y;\n\t\t\t\tmatch[1][y] = x;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\treturn false;\n}\n\nint hungary()\n{\n\tint ret = 0;\n\tfor(int i = 1; i <= size[0]; i++)\n\t{\n\t\tmemset(vis, 0, sizeof(vis));\n\t\tif(dfs(i))\n\t\t\tret++;\n\t}\n\treturn ret;\n}\n\nint n, a[MAXN], b[MAXN], id[MAXN];\n\nint main()\n{\n\tios::sync_with_stdio(false);\n\t// freopen(\"1.in\", \"r\", stdin);\n\t// freopen(\"1.out\", \"w\", stdout);\n\n\tinit();\n\n\tint n0;\n\tcin >> n0;\n\tfor(int i = 1; i <= n0; i++)\n\t\tcin >> a[i];\n\ta[0] = -1, a[n0 + 1] = MAXM + 1;\n\n\tfor(int i = 1; i <= n0; i++)\n\t{\n\t\tif(a[i - 1] != a[i] - 1)\n\t\t\tb[++n] = a[i];\n\t\tif(a[i] + 1 != a[i + 1])\n\t\t\tb[++n] = a[i] + 1;\n\t}\n\t// for(int i = 1; i <= n; i++)\n\t// \tcerr << b[i] << ' ';\n\t// cerr << endl;\n\n\tfor(int i = 1; i <= n; i++)\n\t\tid[i] = ++size[b[i] % 2];\n\t// cerr << size[0] << ' '<< size[1] << endl;\n\n\tfor(int i = 1; i <= n; i++)\n\t\tif(b[i] % 2 == 0)\n\t\t\tfor(int j = 1; j <= n; j++)\n\t\t\t\tif(b[j] % 2 == 1)\n\t\t\t\t\tif(isp[abs(b[i] - b[j])])\n\t\t\t\t\t\taddE(id[i], id[j]);\n\tint k = hungary();\n\t// cerr << k << endl;\n\n\tint ans = 1 * k + 2 * ((size[0] - k) / 2 + (size[1] - k) / 2) + 3 * ((size[0] - k) & 1);\n\tcout << ans << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n#include <utility>\n#include <cstdlib>\n#include <memory>\n#include <queue>\n#include <cassert>\n#include <cmath>\n#include <ctime>\n#include <complex>\n#include <bitset>\n#include <fstream>\n#include <unordered_map>\n#include <unordered_set>\n#include <numeric>\n\nusing namespace std;\n\n#define ws ws_____________________\n#define y1 y1_____________________\n#define y0 y0_____________________\n#define left left_________________\n#define right right_______________\n#define next next_________________\n#define prev prev_________________\n#define hash hash_________________\n\n#define pb push_back\n#define fst first\n#define snd second\n#define mp make_pair \n#define sz(C) ((int) (C).size())\n#define forn(i, n) for (int i = 0; i < int(n); ++i)\n#define ford(i, n) for (int i = int(n) - 1; i >= 0; --i)\n#define all(C) begin(C), end(C)\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef unsigned int uint;\ntypedef pair<int,int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<ll> vll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vii;\ntypedef long double ld;\ntypedef complex<double> cd;\n\n#ifdef LOCAL\n#define eprintf(args...) fprintf(stderr, args), fflush(stderr)\n#else\n#define eprintf(...) ;\n#endif\n\n#define FILE_NAME \"a\"\n\n\nint n;\nvi xs;\n\nbool read() {\n\tif  (scanf(\"%d\", &n) < 1) {\n\t\treturn 0;\n\t}\n\txs.resize(n);\n\tforn(i, n) {\n\t\tscanf(\"%d\", &xs[i]);\n\t}\n\treturn 1;\n}\n\nconst int MAX = 1e7 + 10;\n\nint A[MAX];\nint B[MAX];\nbool prime[MAX];\n\nstruct Graph {\n\tvvi g;\n\tvi mt;\n\tvi used;\n\tint n, m;\n\n\tGraph() = default;\n\n\tGraph(int n, int m) : n(n), m(m) {\n\t\tg.resize(n);\n\t}\n\n\tvoid addE(int v, int to) {\n\t\tg[v].pb(to);\n\t} \n\n\tbool dfs(int v) {\n\t\tif  (used[v]) {\n\t\t\treturn 0;\n\t\t}\n\t\tfor (int to : g[v]) {\n\t\t\tif  (mt[to] == -1 || dfs(mt[to])) {\n\t\t\t\tmt[to] = v;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t\tused[v] = 1;\n\t\treturn 0;\n\t}\n\n\tvii getMatch() {\n\t\tmt.assign(m, -1);\n\t\tforn(v, n) {\n\t\t\tused.assign(n, 0);\n\t\t\tdfs(v);\n\t\t}\n\n\t\tvii res;\n\t\tforn(i, m) {\n\t\t\tif  (mt[i] != -1) {\n\t\t\t\tres.pb(mp(mt[i], i));\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n};\n\nint calc() {\n\tvi vals;\n\tforn(i, MAX) {\n\t\tif  (B[i]) {\n\t\t\tvals.pb(i);\n\t\t}\n\t}\n\n\tsort(all(vals));\n\teprintf(\"vals:\\n\");\n\tfor (int val : vals) {\n\t\teprintf(\"%d \", val);\n\t}\n\teprintf(\"\\n\");\n\n\t// assert(sz(vals) % 2 == 0);\n\n\tvi odd;\n\tvi even;\n\tfor (int val : vals) {\n\t\tif  (val & 1) {\n\t\t\todd.pb(val);\n\t\t} else {\n\t\t\teven.pb(val);\n\t\t}\n\t}\n\n\tGraph g(sz(odd), sz(even));\n\tforn(i, sz(odd)) {\n\t\tforn(j, sz(even)) {\n\t\t\tconst int p = abs(odd[i] - even[j]);\n\t\t\tif  (p >= 3 && prime[p]) {\n\t\t\t\tg.addE(i, j);\n\t\t\t}\n\t\t}\n\t}\n\n\tvii match = g.getMatch();\n\tint ans = sz(match);\n\n\tint cnt_even = sz(even) - sz(match);\n\tint cnt_odd = sz(odd) - sz(match);\n\n\tans += 2 * (cnt_even / 2);\n\tcnt_even %= 2;\n\n\tans += 2 * (cnt_odd / 2);\n\tcnt_odd %= 2;\n\n\t// assert(cnt_odd == cnt_even);\n\tif  (cnt_even) {\n\t\tans += 3;\n\t}\n\n\treturn ans;\n}\n\nint solve() {\n\tmemset (prime, true, sizeof prime);\n\tfor (int i = 2; i < MAX; ++i) {\n\t\tif  (prime[i]) {\n\t\t\tfor (int j = i + i; j < MAX; j += i) {\n\t\t\t\tprime[j] = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tmemset (A, 0, sizeof A);\n\tfor (int x : xs) {\n\t\tA[x] ^= 1;\n\t}\n\n\tmemset (B, 0, sizeof B);\n\tforn(i, MAX) {\n\t\tB[i] = A[i] ^ A[i + 1];\n\t}\n\n\tint ans = calc();\n\treturn ans;\n}\n\nint main() {\n#ifdef LOCAL\n\tfreopen(FILE_NAME \".in\", \"r\", stdin);\n\t// freopen(FILE_NAME \".out\", \"w\", stdout);\n#endif\n\n\twhile (read()) {\n\t\tprintf(\"%d\\n\", solve());\n\t}\n\n#ifdef LOCAL\n\tcerr.precision(5);\n\tcerr << \"Time: \" << fixed << (double) clock() / CLOCKS_PER_SEC << endl;\n#endif\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <chrono>\n#include <random>\n#include <cassert>\n#include <queue>\n\nstd::mt19937 rng((int) std::chrono::steady_clock::now().time_since_epoch().count());\n\ntemplate <class T = int>\nclass Dinic {\npublic:\n\tstruct Edge {\n\t\tEdge(int a, T b){to = a;cap = b;}\n\t\tint to;\n\t\tT cap;\n\t};\n\n\tDinic(int _n) : n(_n) {\n\t\tedges.resize(n);\n\t}\n\n\tT maxFlow(int src, int sink) {\n\t\tT ans = 0;\n\t\twhile(bfs(src, sink)) {\n\t\t\tT flow;\n\t\t\tpt = std::vector<int>(n, 0);\n\t\t\twhile((flow = dfs(src, sink))) {\n\t\t\t\tans += flow;\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n\n\tvoid addEdge(int from, int to, T cap = 1) {\n\t\tedges[from].push_back(list.size());\n\t\tlist.push_back(Edge(to, cap));\n\t\tedges[to].push_back(list.size());\n\t\tlist.push_back(Edge(from, 0));\n\t}\nprivate:\n\tint n;\n\tstd::vector<std::vector<int> > edges;\n\tstd::vector<Edge> list;\n\tstd::vector<int> h, pt;\n\n\tT dfs(int on, int sink, T flow = 1e9) {\n\t\tif(flow == 0) {\n\t\t\treturn 0;\n\t\t} if(on == sink) {\n\t\t\treturn flow;\n\t\t}\n\t\tfor(; pt[on] < (int) edges[on].size(); pt[on]++) {\n\t\t\tint cur = edges[on][pt[on]];\n\t\t\tif(h[on] + 1 != h[list[cur].to]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tT got = dfs(list[cur].to, sink, std::min(flow, list[cur].cap));\n\t\t\tif(got) {\n\t\t\t\tlist[cur].cap -= got;\n\t\t\t\tlist[cur ^ 1].cap += got;\n\t\t\t\treturn got;\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\n\tbool bfs(int src, int sink) {\n\t\th = std::vector<int>(n, n);\n\t\th[src] = 0;\n\t\tstd::queue<int> q;\n\t\tq.push(src);\n\t\twhile(!q.empty()) {\n\t\t\tint on = q.front();\n\t\t\tq.pop();\n\t\t\tfor(auto a : edges[on]) {\n\t\t\t\tif(list[a].cap == 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tint to = list[a].to;\n\t\t\t\tif(h[to] > h[on] + 1) {\n\t\t\t\t\th[to] = h[on] + 1;\n\t\t\t\t\tq.push(to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn h[sink] < n;\n\t}\n};\n\n\nint main() {\n\tstd::ios_base::sync_with_stdio(false); std::cin.tie(NULL);\n\tconst int ms = 10010000;\n\tstd::vector<bool> prime(ms, true);\n\tprime[0] = prime[1] = false;\n\tfor(int i = 2; i < ms; i++) {\n\t\tif(!prime[i]) continue;\n\t\tfor(int j = i+i; j < ms; j += i) {\n\t\t\tprime[j] = false;\n\t\t}\n\t}\n\tprime[2] = false;\n\tstd::vector<int> a(ms, 0);\n\tint n;\n\tstd::cin >> n;\n\tfor(int i = 0; i < n; i++) {\n\t\tint x;\n\t\tstd::cin >> x;\n\t\ta[x] ^= 1;\n\t\ta[x+1] ^= 1;\n\t}\n\tstd::vector<int> b;\n\tint f[2] = {0, 0};\n\tfor(int i = 1; i < ms; i++) {\n\t\tif(a[i]) {\n\t\t\tb.push_back(i);\n\t\t\tf[i%2]++;\n\t\t}\n\t}\n\tn = (int) b.size();\n\tDinic<int> graph(n+2);\n\tint src = n, sink = n+1;\n\tfor(int i = 0; i < n; i++) {\n\t\tif(b[i] % 2 == 0) graph.addEdge(src, i, 1);\n\t\telse graph.addEdge(i, sink, 1);\n\t\tfor(int j = 0; j < n; j++) {\n\t\t\tif(prime[abs(b[i] - b[j])] && b[i] % 2 == 0) {\n\t\t\t\tgraph.addEdge(i, j, 1);\n\t\t\t}\n\t\t}\n\t}\n\tint got = graph.maxFlow(src, sink);\n\tf[0] -= got;\n\tf[1] -= got;\n\tint ans = got + f[0] / 2 * 2 + f[1] / 2 * 2;\n\tf[0] %= 2;\n\tf[1] %= 2;\n\tans += f[0] * 3;\n\tassert(f[0] == f[1]);\n\tstd::cout << ans << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define For(i, j, k) for(int i = j; i <= k; ++i)\nusing namespace std;\n\ninline int read() {\n\tint x = 0, p = 1; char c = getchar();\n\twhile(!isdigit(c)) { if(c == '-') p = -1; c = getchar(); }\n\twhile(isdigit(c)) x = (x << 1) + (x << 3) + (c ^ 48), c = getchar();\n\treturn x *= p;\n}\n\ninline void File() {\n#ifndef ONLINE_JUDGE\n\tfreopen(\"magic.in\", \"r\", stdin);\n\tfreopen(\"magic.out\", \"w\", stdout);\n#endif\n}\n\nconst int N = 2e2 + 10, M = 1e7 + 10;\nint prime[M], isnot[M], cnt, S[M], x;\nint n, A[N], B[N], cnt1, cnt2, G[N][N];\nint match[N], vis[N];\n\ninline void Init(int n) {\n\tisnot[1] = 1;\n\tFor(i, 2, n) {\n\t\tif(!isnot[i]) prime[++cnt] = i;\n\t\tFor(j, 1, cnt) {\n\t\t\tif(1ll * i * prime[j] > n) break;\n\t\t\tisnot[i * prime[j]] = 1;\n\t\t}\n\t}\n}\n\ninline bool dfs(int x) {\n\tFor(i, 1, cnt2)\t{\n\t\tif(G[x][i] && !vis[i]) {\n\t\t\tvis[i] = 1;\n\t\t\tif(match[i] == -1 || dfs(match[i])) {\n\t\t\t\tmatch[i] = x;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\nint main() {\n\tInit(M - 5);\n\tn = read();\n\tFor(i, 1, n) S[(x = read())] ^= 1;\n\t\n\tFor(i, 1, M - 5) if(S[i] != S[i - 1]) {\n\t\tif(i & 1) A[++cnt1] = i;\n\t\telse B[++cnt2] = i;\n\t}\n\tFor(i, 1, cnt1) For(j, 1, cnt2) \n\t\tif(!isnot[abs(A[i] - B[j])] && abs(A[i] - B[j]) != 2) G[i][j] = 1;\t\n\n\tmemset(match, -1, sizeof match);\n\tint res = 0, ans;\n\tFor(i, 1, cnt1) {\n\t\tFor(j, 1, cnt2) vis[i] = 0;\n\t\tif(dfs(i)) ++ res;\n\t}\n\n\tans = res + (cnt1 - res >> 1) * 2 + (cnt2 - res >> 1) * 2;\n\tif((cnt1 - res) & 1) ans += 3;\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<list>\n#include<deque>\n#include<bitset>\n#include<set>\n#include<map>\n#include<unordered_map>\n#include<unordered_set>\n#include<cstring>\n#include<sstream>\n#include<complex>\n#include<iomanip>\n#include<numeric>\n#include<cassert>\n#define X first\n#define Y second\n#define pb push_back\n#define rep(X,Y) for (int (X) = 0;(X) < (Y);++(X))\n#define reps(X,S,Y) for (int (X) = S;(X) < (Y);++(X))\n#define rrep(X,Y) for (int (X) = (Y)-1;(X) >=0;--(X))\n#define rreps(X,S,Y) for (int (X) = (Y)-1;(X) >= (S);--(X))\n#define repe(X,Y) for ((X) = 0;(X) < (Y);++(X))\n#define peat(X,Y) for (;(X) < (Y);++(X))\n#define all(X) (X).begin(),(X).end()\n#define rall(X) (X).rbegin(),(X).rend()\n#define eb emplace_back\n#define UNIQUE(X) (X).erase(unique(all(X)),(X).end())\n#define Endl endl\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntemplate<class T> using vv=vector<vector<T>>;\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"{\"; rep(i,t.size()) {os<<t[i]<<\",\";} os<<\"}\"<<endl; return os;}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\ntemplate<class T> inline bool MX(T &l,const T &r){return l<r?l=r,1:0;}\ntemplate<class T> inline bool MN(T &l,const T &r){return l>r?l=r,1:0;}\n#define out(args...){vector<string> a_r_g_s=s_p_l_i_t(#args, ','); e_r_r(a_r_g_s.begin(), args); }\nvector<string> s_p_l_i_t(const string &s, char c){vector<string> v;int d=0,f=0;string t;for(char c:s){if(!d&&c==',')v.pb(t),t=\"\";else t+=c;if(c=='\\\"'||c=='\\'')f^=1;if(!f&&c=='(')++d;if(!f&&c==')')--d;}v.pb(t);return move(v);}\nvoid e_r_r(vector<string>::iterator it) {}\ntemplate<typename T, typename... Args> void e_r_r(vector<string>::iterator it, T a, Args... args){ if(*it==\" 1\"||*it==\"1\") cerr<<endl; else cerr << it -> substr((*it)[0] == ' ', it -> length()) << \" = \" << a << \", \"; e_r_r(++it, args...);}\nconst ll MOD=1e9+7;\nvector<int> primes,prime;\nclass PRPRPR{\npublic:\n  PRPRPR(int PRIME_MAX){\n    prime.resize(PRIME_MAX);\n    for(int i=2;i<PRIME_MAX;i++)if(!prime[i]){\n\t\t\t\tprimes.pb(i);\n\t\t\t\tfor(int j=i*2;j<PRIME_MAX;j+=i)\n\t\t\t\t\tprime[j]=1;\n      }\n  }\n} prprprpr(11234567);\n\nint dp[111][111];\n\nint main(){\n  ios_base::sync_with_stdio(false);\n  cout<<fixed<<setprecision(0);\n\tint n;\n\tcin>>n;\n\tvector<int> xs(n);\n\trep(i,n) cin>>xs[i];\n\n\tauto Cost=[&](int d){\n\t\tif(!d) return 0;\n\t\tif(d==4) return 2;\n\t\tif(d==1) return 3;\n\t\tif(d%2==0) return 2;\n\t\tif(d>2 && prime[d]==0) return 1;\n\t\treturn 3;\n\t};\n\n\treps(d,1,n+1)rep(i,n+1-d){\n\t\tfor(int l=i,r=i+d-1; l<=r; ++l, --r){\n\t\t\tif(r-l==xs[r]-xs[l]){\n\t\t\t\tdp[i][i+d-1]+=Cost(xs[r]-xs[l]+1);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(l==r) dp[i][i+d-1]+=Cost(1);\n\t\t\telse dp[i][i+d-1]+=Cost(xs[r]-xs[l]+1)+Cost(xs[r]-xs[l]-1);\n\t\t}\n\t\treps(c,i,i+d) MN(dp[i][i+d-1], dp[i][c]+dp[c+1][i+d-1]);\n\t}\n\t//rep(i,n){rep(j,n)cout<<dp[i][j]<<\",\";cout<<endl;}\n\tcout<<dp[0][n-1]<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cmath>\n#include<cstring>\n#include<string>\n#include<algorithm>\n#include<vector>\n\n#define maxn 205\n#define maxm 10000005\n\nusing namespace std;\n\ninline int getint()\n{\n\tint num=0,flag=1;char c;\n\twhile((c=getchar())<'0'||c>'9')if(c=='-')flag=-1;\n\twhile(c>='0'&&c<='9')num=num*10+c-48,c=getchar();\n\treturn num*flag;\n}\n\nint n,N;\nint a[maxn],w[maxn][maxn],link[maxn];\nint pri[maxm],cnt;\nbool np[maxm],col[maxm],vis[maxn];\nint X[maxn],Y[maxn],ans;\n\ninline void init()\n{\n\tnp[1]=1;\n\tfor(int i=2;i<=N;i++)\n\t{\n\t\tif(!np[i])pri[++cnt]=i;\n\t\tfor(int j=1;j<=cnt&&i*pri[j]<=N;j++)np[i*pri[j]]=1;\n\t}\n}\n\ninline bool match(int x)\n{\n\tfor(int i=1;i<=Y[0];i++)if(w[x][i]&&!vis[i])\n\t{\n\t\tvis[i]=1;\n\t\tif(!link[i]||match(link[i])){link[i]=x;return 1;}\n\t}\n\treturn 0;\n}\n\nint main()\n{\n\tn=getint();\n\tfor(int i=1;i<=n;i++)N=max(N,a[i]=getint()),col[a[i]]=1;\n\tN++;init();\n\tfor(int i=1;i<=N;i++)if(col[i]^col[i-1])i&1?X[++X[0]]=i:Y[++Y[0]]=i;\n\tfor(int i=1;i<=X[0];i++)for(int j=1;j<=Y[0];j++)w[i][j]=!np[abs(X[i]-Y[j])];\n\tfor(int i=1;i<=X[0];i++)\n\t{\n\t\tmemset(vis,0,sizeof vis);\n\t\tans+=match(i);\n\t}\n\tans+=2*((X[0]-ans)/2)+2*((Y[0]-ans)/2)+3*((X[0]-ans)&1);\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#define fo(i,a,b) for(i=a;i<=b;i++)\nusing namespace std;\ntypedef long long ll;\nconst int maxn=200+10,maxd=10000000+10;\nint x[maxn],s[maxd],pri[maxd],r[maxn],a[maxn],b[maxn];\nbool bz[maxd],dis[maxn][maxn],pd[maxn];\nint i,j,k,l,t,n,m,tot,top,num,sum,tmp,ans;\nvoid prepare(){\n\tbz[1]=1;\n\tfo(i,2,maxd-10){\n\t\tif (!bz[i]) pri[++top]=i;\n\t\tfo(j,1,top){\n\t\t\tif ((ll)i*pri[j]>maxd-10) break;\n\t\t\tbz[i*pri[j]]=1;\n\t\t\tif (i%pri[j]==0) break;\n\t\t}\n\t}\n}\nbool dfs(int x){\n\tint i;\n\tfo(i,1,sum)\n\t\tif (dis[x][i]&&!pd[i]){\n\t\t\tpd[i]=1;\n\t\t\tif (!r[i]||dfs(r[i])){\n\t\t\t\tr[i]=x;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\treturn 0;\n}\nint main(){\n\tprepare();\n\tscanf(\"%d\",&n);\n\tfo(i,1,n){\n\t\tscanf(\"%d\",&x[i]);\n\t\ts[x[i]]^=1;\n\t}\n\tfo(i,1,maxd-9){\n\t\tif (s[i]!=s[i-1]){\n\t\t\tif (i%2==1) a[++num]=i;\n\t\t\telse b[++sum]=i;\n\t\t}\n\t}\n\tfo(i,1,num)\n\t\tfo(j,1,sum)\n\t\t\tif (!bz[abs(a[i]-b[j])]) dis[i][j]=1;\n\tfo(i,1,num){\n\t\tfo(j,1,sum) pd[j]=0;\n\t\tif (dfs(i)) tmp++;\n\t}\n\tans+=2*((num-tmp)/2);\n\tans+=2*((sum-tmp)/2);\n\tans+=tmp;\n\tif (num%2!=tmp%2) ans+=3;\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n  \nusing namespace std;\n  \n#define rep(i,n) REP(i,0,n)\n#define REP(i,s,e) for(int i=(s); i<(int)(e); i++)\n#define repr(i, n) REPR(i, n, 0)\n#define REPR(i, s, e) for(int i=(int)(s-1); i>=(int)(e); i--)\n#define pb push_back\n#define all(r) r.begin(),r.end()\n#define rall(r) r.rbegin(),r.rend()\n#define fi first\n#define se second\n  \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n \nconst int INF = 1e9;\nconst ll MOD = 1e9 + 7;\ndouble EPS = 1e-8;\n\n#define MAX_V 2200\n \nstruct Edge\n{\n    int to, cap, rev;\n    Edge(){};\n    Edge(int to, int cap, int rev) : to(to), cap(cap), rev(rev){};\n};\n \nvector<Edge> G[MAX_V];\nbool used[MAX_V];\n \nvoid add_edge(int from, int to, int cap){\n    G[from].push_back({to, cap, (int)G[to].size()});\n    G[to].push_back({from, 0, (int)G[from].size()-1});\n}\n \nint dfs(int v, int t, int f){\n    if(v == t) return f;\n    used[v] = true;\n    for(int i = 0; i < G[v].size(); i++){\n        Edge& e = G[v][i];\n        if(!used[e.to] && e.cap > 0){\n            int d = dfs(e.to, t, min(f, e.cap));\n            if(d > 0){\n                e.cap -= d;\n                G[e.to][e.rev].cap += d;\n                return d;\n            }\n        }\n    }\n    return 0;\n}\n \nint max_flow(int s, int t){\n    int flow = 0;\n    while(1){\n        memset(used, 0, sizeof(used));\n        int f = dfs(s, t, INF);\n        if(f == 0) return flow;\n        flow += f;\n    }\n}\n\n//エラトステネスの篩を使用\nconst int MAX_PRIME = 1e7 + 10;\n \nvector<int> is_prime(MAX_PRIME,1);\n \nvoid calcPrime(){\n    is_prime[0]=is_prime[1]=0;\n    for(int i=2; i<MAX_PRIME; i++){\n        if(is_prime[i]==1){\n            for(int j=i*2; j<MAX_PRIME; j+=i){\n                is_prime[j]=0;\n            }\n        }\n    }\n}\n\nint main(){\n\tcalcPrime();\n\tint n;\n\tcin >> n;\n\tvi x(n);\n\trep(i, n) cin >> x[i];\n\tmap<int, int> mp;\n\trep(i, n) {\n\t\tmp[x[i]]^=1;\n\t\tmp[x[i]+1]^=1;\n\t}\n\tvi odd, even;\n\tfor(auto& p : mp) if(p.se) (p.fi&1?odd:even).pb(p.se);\n\trep(i, odd.size()) rep(j, even.size()) {\n\t\tif(is_prime[abs(odd[i]-even[j])]) add_edge(i, odd.size()+j, 1);\n\t}\n\tn = odd.size()+even.size();\n\trep(i, odd.size()) add_edge(n, i, 1);\n\trep(i, even.size()) add_edge(odd.size()+i, n+1, 1);\n\tint f = max_flow(n, n+1);\n\tint ans = f + (((int)odd.size()-f)/2)*2 + (((int)even.size()-f)/2)*2;\n\tif(((int)odd.size()-f)&1) ans += 3;\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\ntypedef long long ll;\nint odd=0,even=0,Odd[105],Even[105],ma[105];\nint flag[10000010],x[10000010],map[105][105],vis[105];\nint prime[10000010],a[105];\nint dfs(int u)\n{\n\tfor (int v=1;v<=even;v++)\n\t{\n\t\tif (!map[u][v]) continue;\n\t\tif (!vis[v])\n\t\t{\n\t\t\tvis[v]=1;\n\t\t\tif (ma[v]==-1||dfs(ma[v]))\n\t\t\t{\n\t\t\t\tma[v]=u;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nint main()\n{\n\tint n,cnt=0;\n\tscanf(\"%d\",&n);\n\tfor (int i=2;i<=10000001;i++)\n\t{\n\t\tif (!flag[i]) prime[++cnt]=i;\n\t\tfor (int j=1;j<=cnt;j++)\n\t\t{\n\t\t\tif (i*prime[j]>10000001) break;\n\t\t\tflag[i*prime[j]]=1;\n\t\t\tif (i%prime[j]==0) break;\n\t\t}\n\t}\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%d\",&a[i]);\n\t\tx[a[i]]^=1;\n\t}\n\tfor (int i=1;i<=10000001;i++)\n\t\tif (x[i]!=x[i-1])\n\t\t{\n\t\t\tif (i&1) Odd[++odd]=i;\n\t\t\telse Even[++even]=i; \n\t\t}\n\tfor (int i=1;i<=odd;i++)\n\t\tfor (int j=1;j<=even;j++)\n\t\t\tif (flag[abs(Odd[i]-Even[j])]) map[i][j]=1;\n\tfor (int i=1;i<=even;i++)\n\t\tma[i]=-1;\n\tint sum=0;\n\tfor (int i=1;i<=odd;i++)\n\t{\n\t\tmemset(vis,0,sizeof(vis));\n\t\tif (dfs(i)) sum++;\n\t}\n\tint ans=sum+(((odd-sum)>>1)<<1)+(((even-sum)>>1)<<1)+(odd-sum)%2*3;\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef double db;\ntypedef long long ll;\n#define w1 first\n#define w2 second\n#define ls (x<<1)\n#define rs (x<<1|1)\n#define pb push_back\n#define mid ((l+r)>>1)\n#define SZ(x) ((x).size())\n#define All(x) (x).begin(),(x).end()\n#define rep(i,a,b) for(int (i)=(a);(i)<=(b);(i)++)\n#define rep2(i,a,b) for(int (i)=(a);(i)<(b);(i)++)\n#define per(i,a,b) for(int (i)=(a);(i)>=(b);(i)--)\n#define Rep(p,x) for(int (p)=head[(x)];(p);(p)=nxt[(p)])\ntemplate<class T>void read(T&num){\n\tnum=0;T f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9')num=num*10+ch-'0',ch=getchar();\n\tnum*=f;\n}\nint power(int x,int k,int p){int res=1;for(;k;k>>=1,x=1ll*x*x%p)if(k&1)res=1ll*res*x%p;return res;}\nconst int maxn=1e2+5;\nint n,m;\nint q[maxn],x[maxn],f[maxn];\nint main(){\n\tread(n);\n\trep(i,1,n)read(x[i]);\n\tq[m=1]=1;\n\trep(i,2,n){\n\t\tif(x[i]==x[i-1]+1)q[m]++;\n\t\telse q[++m]=x[i]-x[i-1]-1,q[++m]=1;\n\t}\n\tmemset(f,127,sizeof f);\n\tf[0]=0;\n\trep(i,1,m)if(i&1){\n\t\trep(j,0,i-1)if(!(j&1)){\n\t\t\tint ans=0,tot=0;\n\t\t\trep(k,j+1,i){\n\t\t\t\tif(k&1)ans+=2+(q[k]&1);\n\t\t\t\ttot+=q[k];\n\t\t\t}\n\t\t\tf[i]=min(f[i],f[j]+ans);\n\t\t\tans=2+(tot&1);\n\t\t\trep(k,j+1,i)if(!(k&1))ans+=2+(q[k]&1);\n\t\t\tf[i]=min(f[i],f[j]+ans);\n\t\t}\n\t}else f[i]=f[i-1];\n\tprintf(\"%d\\n\",f[m]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<set>\n#include<map>\n#include<deque>\n#include<queue>\n#include<stack>\n#include<cmath>\n#include<ctime>\n#include<bitset>\n#include<string>\n#include<vector>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<climits>\n#include<complex>\n#include<iostream>\n#include<algorithm>\n#define ll long long\nusing namespace std;\n\nconst int maxn = 1e7+10;\nconst int maxm = 210;\n\nint p[4100000],pri;\nbool v[maxn];\n\nvoid pre()\n{\n    for(int i=2;i<maxn;i++)\n    {\n        if(!v[i]) p[++pri]=i;\n        for(int j=1,k=i*p[j];j<=pri;j++,k=i*p[j])\n        {\n            if(k>=maxn) break;\n            v[k]=true;\n            if(i%p[j]==0) break;\n        }\n    }v[1]=v[2]=true;\n}\n\nint n,m;\nint a[maxm],b[maxm];\nbool s[maxn];\nint p1[maxm],p2[maxm];\nint p1n,p2n;\n\nbool mp[maxm][maxm],ev[maxm];\nint match[maxm],bel[maxm];\nbool Find(const int x)\n{\n    if(ev[x]) return false;\n    ev[x]=true;\n    for(int i=1;i<=p2n;i++) if(mp[x][i])\n    {\n        if(!bel[i]||Find(bel[i])) { bel[i]=x; return true; }\n    }\n    return false;\n}\n\nint main()\n{\n    pre();\n    scanf(\"%d\",&n);\n    for(int i=1;i<=n;i++) scanf(\"%d\",&a[i]),s[a[i]]=true;\n    for(int i=1;i<maxn;i++)\n        if(s[i]!=s[i-1]) b[++m]=i;\n\n    for(int i=1;i<=m;i++)\n    {\n        if(b[i]&1) p1[++p1n]=b[i];\n        else p2[++p2n]=b[i];\n    }\n    for(int i=1;i<=p1n;i++)\n    {\n        for(int j=1;j<=p2n;j++) if(!v[abs(p1[i]-p2[j])]) mp[i][j]=true;\n    }\n    int k=0;\n    for(int i=1;i<=p1n;i++) if(!match[i])\n    {\n        for(int j=1;j<=p1n;j++) ev[j]=false;\n        if(Find(i)) k++;\n    }\n    p1n-=k; p2n-=k;\n    int re=k;\n    re+=p1n/2*2+p2n/2*2;\n    re+=p1n%2*3;\n     printf(\"%d\\n\",re);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// Written By NewbieChd\n#include <cstdio>\n#include <cctype>\n#include <cstring>\n#include <algorithm>\n#include <queue>\nusing namespace std;\n\nconst int BUF = 1000000;\nchar buf[BUF], *p1, *p2;\ninline char getChar() { return p1 == p2 && (p2 = (p1 = buf) + fread(buf, 1, BUF, stdin), p1 == p2) ? EOF : *p1++; }\ninline int read() {\n    int f = 0;\n    bool b = 1;\n    char c;\n    while (!isdigit(c = getChar()))\n        if (c == 45)\n            b = 0;\n    do\n        f = f * 10 + (c ^ 48);\n    while (isdigit(c = getChar()));\n    return b ? f : ~f + 1;\n}\n\nconst int maxN = 1003, maxE = 1000003, S = maxN - 2, T = maxN - 1, inf = 0x3f3f3f3f;\nint cntNode;\n\nint h[maxN], cntEdge = 1;\nstruct Edge {\n    int tar, val, nxt;\n    Edge() {}\n    Edge(int tar, int val, int nxt) : tar(tar), val(val), nxt(nxt) {}\n}ed[maxE];\ninline void addEdge(int x, int y, int z) { ed[++cntEdge] = Edge(y, z, h[x]), h[x] = cntEdge, ed[++cntEdge] = Edge(x, 0, h[y]), h[y] = cntEdge; }\n\nint cur[maxN], dep[maxN];\nqueue<int> que;\ninline bool bfs() {\n    int i, x, y;\n    memset(dep + 1, 0, sizeof(int) * cntNode), memcpy(cur + 1, h + 1, sizeof(int) * cntNode), cur[S] = h[S], dep[S] = 1, dep[T] = 0, que.push(S);\n    while (!que.empty()) {\n        x = que.front(), que.pop();\n        for (i = h[x]; i; i = ed[i].nxt)\n            if (ed[i].val && !dep[y = ed[i].tar])\n                dep[y] = dep[x] + 1, que.push(y);\n    }\n    return dep[T];\n}\nint dfs(int x, int flow) {\n    if (x == T)\n        return flow;\n    int res = flow, k, i, y;\n    for (i = cur[x]; i && res; i = ed[i].nxt) {\n        cur[x] = i;\n        if (ed[i].val && dep[y = ed[i].tar] == dep[x] + 1 && (k = dfs(y, min(res, ed[i].val))))\n            res -= k, ed[i].val -= k, ed[i ^ 1].val += k;\n    }\n    return flow - res;\n}\n\ninline int Dinic() {\n    int maxFlow = 0, k;\n    while (bfs())\n        while ((k = dfs(S, inf)))\n            maxFlow += k;\n    return maxFlow;\n}\n\nconst int maxL = 10000003, lim = 1e7;\nint prime[maxL];\nbool notP[maxL];\n\nbool flag[maxL];\nint pos[maxN], ind[maxN];\ninline int absolute(int x) { return x >= 0 ? x : ~x + 1; }\n\nint main() {\n    int n = read(), cntP = 0, i, j;\n    for (i = 2; i <= n; ++i) {\n        if (!notP[i])\n            prime[++cntP] = i;\n        for (j = 1; j <= lim && i * prime[j] <= lim; ++j) {\n            notP[i * prime[j]] = 1;\n            if (i % prime[j] == 0)\n                break;\n        }\n    }\n    \n    for (i = 1; i <= n; ++i)\n        flag[read()] = 1;\n    for (i = 1; i <= lim; ++i)\n        if (flag[i] ^ flag[i - 1])\n            pos[++cntNode] = i;\n    notP[1] = 1;\n    for (i = 1; i <= cntNode; ++i) {\n        if (pos[i] & 1) {\n            for (j = 1; j <= cntNode; ++j)\n                if (!(pos[j] & 1) && (!notP[absolute(pos[i] - pos[j])]))\n                    addEdge(i, j, 1);\n            addEdge(S, i, 1);\n        }\n        else\n            addEdge(i, T, 1);\n        ind[i] = cntEdge ^ 1;\n    }\n    int ans = Dinic(), tax[2];\n    tax[0] = tax[1] = 0;\n    for (i = 1; i <= cntNode; ++i)\n        if (ed[ind[i]].val)\n            ++tax[pos[i] & 1];\n    ans += (((tax[0] >> 1) + (tax[1] >> 1)) << 1) + ((tax[0] & 1) | (tax[1] & 1)) * 3;\n    \n    printf(\"%d\\n\", ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n\nusing namespace std;\n\nusing vi = vector<int>;\nvi X;\nint n;\nvector<vi> C;\nint used[207];\nbool isprime(int n) {\n\tfor (int i = 2; i*i < n; i++) {\n\t\tif (n%i == 0)return false;\n\t}\n\treturn true;\n}\nbool dfs(int v) {\n\tused[v] = true;\n\tfor (int i = 0; i < X.size() + 2; i++) {\n\t\tif (!used[i] && C[v][i] > 0) {\n\t\t\tif (dfs(i)) {\n\t\t\t\tC[v][i]--;\n\t\t\t\tC[i][v]++;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\nint main() {\n\tcin >> n;\n\tvi evens;\n\tvi odds;\n\tfor (int i = 0; i < n; i++) {\n\t\tint x;\n\t\tcin >> x;\n\t\tif (!X.empty() && X.back() == x) {\n\t\t\tX.pop_back();\n\t\t\tX.push_back(x + 1);\n\t\t}\n\t\telse {\n\t\t\tX.push_back(x);\n\t\t\tX.push_back(x + 1);\n\t\t}\n\t}\n\tint E = 0;\n\tint O = 0;\n\tfor (int x : X) {\n\t\tif (x % 2 == 0) {\n\t\t\tE++;\n\t\t}\n\t\telse {\n\t\t\tO++;\n\t\t}\n\t}\n\t\t\n\tC.resize(X.size()+2, vi(X.size()+2, 0));\n\tfor (int i = 0; i < X.size(); i++) {\n\t\tif (X[i] % 2 == 0) {\n\t\t\tC[n][i] = 1;\n\t\t}\n\t\telse {\n\t\t\tC[i][n + 1] = 1;\n\t\t}\n\t}\n\tfor (int i = 0; i < X.size(); i++) {\n\t\tfor (int j = i; j < n; j++) {\n\t\t\tif (isprime(abs(X[i] - X[j]))) {\n\t\t\t\tC[i][j] = 1;\n\t\t\t}\n\t\t}\n\t}\n\tint ans = 0;\n\twhile (dfs(X.size())) {\n\t\tmemset(used, false, sizeof(used));\n\t\tans++;\n\t}\n\tif ((E - ans) % 2 == 0) {\n\t\tcout << ans + (E - ans + O - ans) << endl;\n\t}\n\telse {\n\t\tcout << ans + (E - ans - 1 + O - ans - 1) + 3 << endl;\n\t}\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <cmath>\n#include <iomanip>\n#include <cassert>\n#include <bitset>\nusing namespace std;\n\ntypedef pair<int, int> P;\n#define rep(i, n) for (int i=0; i<(n); i++)\n#define all(c) (c).begin(), (c).end()\n#define uniq(c) c.erase(unique(all(c)), (c).end())\n#define _1 first\n#define _2 second\n#define pb push_back\n#define INF 1145141919\n#define MOD 1000000007\n\nint N, V;\nint A[300];\nmap<int, int> mp;\nint cost[300][300];\nint dp[300][300];\n\nbool is_prime(int x) {\n  if (x == 1) return false;\n  for (int i=2; i<=sqrt(x); i++) {\n    if (x % i == 0) return false;\n  }\n  return true;\n}\n\nint f(int x) {\n  if (x % 2 == 0) return 2;\n  if (is_prime(x)) return 1;\n  return 3;\n}\nsigned main() {\n  ios::sync_with_stdio(false); cin.tie(0);\n  cin >> N;\n  rep(i, N) {\n    int x;\n    cin >> x;\n    mp[x]^=1;\n    mp[x+1]^=1;\n  }\n  for (auto p : mp) {\n    if (p._2 == 0) continue;\n    A[V++] = p._1;\n  }\n  //rep(i, V) cout<<A[i]<<\",\"; cout<<\"\\n\";\n  sort(A, A+V);\n\n  rep(i, V) rep(j, V) cost[i][j] = INF;\n  rep(i, V) {\n    cost[i][i] = 0;\n    rep(j, i) {\n      cost[i][j] = cost[j][i] = f(abs(A[i]-A[j]));\n      //cout<<i<<\"<->\"<<j<<\": \"<<cost[i][j]<<\" diff=\"<<A[i]-A[j]<<\"\\n\";\n    }\n  }\n  rep(i, V) {\n    rep(j, V) {\n      dp[i][j] = INF;\n    }\n  }\n  for (int len=1; len<V; len++) {\n    rep(l, V) {\n      int r = l+len;\n      if (r >= V) break;\n      // [l, r]\n      for (int k=l+1; k<r; k++) {\n        // [l, k] + [k+1, r]\n        if (dp[l][k] == INF || dp[k+1][r] == INF) continue;\n        dp[l][r] = min(dp[l][r], dp[l][k] + dp[k+1][r]);\n        //cout<<\"[\"<<l<<\",\"<<r<<\"] <- [\"<<l<<\",\"<<k<<\"] + [\"<<k+1<<\",\"<<r<<\"] = \"<<dp[l][k]<<\"+\"<<dp[k+1][r]<<\"\\n\";\n      }\n      // ( x )\n      int s = INF;\n      if (len == 1) s = 0;\n      else s = dp[l+1][r-1];\n      dp[l][r] = min(dp[l][r], s+cost[l][r]);\n    }\n  }\n  assert(dp[0][V-1] != INF);\n  cout << dp[0][V-1] << \"\\n\";\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#ifndef ONLINE_JUDGE\n#define dbg(x...) do { cout << \"\\033[32;1m \" << #x << \" -> \"; err(x); } while (0)\nvoid err() { cout << \"\\033[39;0m\" << endl; }\ntemplate<template<typename...> class T, typename t, typename... A>\nvoid err(T<t> a, A... x) { for (auto v: a) cout << v << ' '; err(x...); }\ntemplate<typename T, typename... A>\nvoid err(T a, A... x) { cout << a << ' '; err(x...); }\n#else\n#define dbg(...)\n#endif\ntypedef long long ll;\ntypedef pair<int,int> pi;\ntypedef vector<int> vi;\ntemplate<class T> using vc=vector<T>;\ntemplate<class T> using vvc=vc<vc<T>>;\ntemplate<class T> void mkuni(vector<T>&v)\n{\n    sort(v.begin(),v.end());\n    v.erase(unique(v.begin(),v.end()),v.end());\n}\ntemplate<class T>\nvoid print(T x,int suc=1)\n{\n    cout<<x;\n    if(suc==1) cout<<'\\n';\n    else cout<<' ';\n}\ntemplate<class T>\nvoid print(const vector<T>&v,int suc=1)\n{\n    for(int i=0;i<v.size();i++)\n    print(v[i],i==(int)(v.size())-1?suc:2);\n}\nconst int maxn=1e7+7;\nvi prime;\nbool vis[maxn];\nvoid db()\n{\n    for(int i=2;i<maxn;i++)\n    {\n        if(!vis[i])\n            prime.push_back(i);\n        for(auto p:prime)\n        {\n            if(i*p>=maxn) break;\n            vis[i*p]=1;\n            if(i%p==0) break;\n        }\n    }\n    vis[1]=1;\n    vis[2]=1;\n}\nint x[105];\nbool b[maxn];\nint pp[205];\nbool vv[205];\nvi even,odd;\nbool dfs(int u)\n{\n    if(vv[u]) return false;\n    vv[u]=1;\n    for(int i=0;i<odd.size();i++)\n    {\n        if(!vis[abs(even[u]-odd[i])])\n        {\n            if(pp[i]==-1||dfs(pp[i]))\n            {\n                pp[i]=u;\n                return true;\n            }\n        }\n    }\n    return false;\n}\nint main()\n{\n    db();\n    int n;\n    cin>>n;\n    for(int i=1;i<=n;i++)\n    {\n        cin>>x[i];\n        b[x[i]]^=1;\n        b[x[i]+1]^=1;\n    }\n    for(int i=1;i<maxn;i++)\n    {\n        if(b[i])\n        {\n            if(i&1) odd.push_back(i);\n            else even.push_back(i);\n        }\n    }\n    memset(pp,-1,sizeof(pp));\n    int ans=0;\n    for(int i=0;i<even.size();i++)\n    {\n        memset(vv,0,sizeof(vv));\n        if(dfs(i))\n            ans++;\n    }\n    ans=ans+((even.size()-ans)/2+(odd.size()-ans)/2)*2+(even.size()-ans)%2*3;\n    print(ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<iostream>\n#include<cstdio>\n#include<cstring>\nusing namespace std;\n#define ll long long\n//{{{ read()\ninline int read(){\n\tregister int x=0,f=1;\n\tregister char ch=getchar();\n\twhile(ch<'0'||ch>'9'){\n\t\tif(ch=='-')\tf=-1;\n\t\tch=getchar();\n\t}\n\twhile(ch>='0'&&ch<='9')\tx=x*10+(ch^48),ch=getchar();\n\treturn x*f;\n}\n//}}}\nconst int N=1e7+5;\nint n,mx,cnt,ans,now,las,a[N],mc[N],vs[N],vi[N];\nbool dfs(int x,int tg){\n\tif(vs[x]==tg) return false;\n\telse\tvs[x]=tg;\n\tfor(int i=1;i<=cnt;i++)\n\t\tif(!vi[abs(a[x]-a[i])]&&(!mc[i]||dfs(mc[i],tg))){\n\t\t\tmc[i]=x; return true;\n\t\t}\n\treturn false;\n}\nint main(){\n\t//freopen(\".in\",\"r\",stdin);\n\t//freopen(\".out\",\"w\",stdout);\n\tn=read();\n\tfor(int i=1;i<=n;i++){\n\t\tint x=read();\n\t\tif(!las) a[++cnt]=x;\n\t\telse\tif(x!=las+1){\n\t\t\ta[++cnt]=x;\n\t\t\ta[++cnt]=las+1;\n\t\t}\n\t\tlas=x;\n\t}\n\ta[++cnt]=las+1,mx=las+1,vi[0]=vi[1]=1;\n\tfor(int i=2;i<=mx;i++){\n\t\tif(vi[i]) continue;\n\t\tfor(int j=i*2;j<=mx;j+=i) vi[j]=1;\n\t} vi[2]=1;\n\tfor(int i=1;i<=cnt;i++)\n\t\tif(a[i]&1) ans+=dfs(i,i);\n\tint A=-ans,B=-ans;\n\tfor(int i=1;i<=cnt;i++)\n\t\tif(a[i]&1) ++A;\n\t\telse\t++B;\n\tif(A&1)\tans+=3;\n\tans+=A/2*2+B/2*2;\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n  \nusing namespace std;\n  \n#define rep(i,n) REP(i,0,n)\n#define REP(i,s,e) for(int i=(s); i<(int)(e); i++)\n#define repr(i, n) REPR(i, n, 0)\n#define REPR(i, s, e) for(int i=(int)(s-1); i>=(int)(e); i--)\n#define pb push_back\n#define all(r) r.begin(),r.end()\n#define rall(r) r.rbegin(),r.rend()\n#define fi first\n#define se second\n  \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n \nconst int INF = 1e9;\nconst ll MOD = 1e9 + 7;\ndouble EPS = 1e-8;\n\n#define MAX_V 3200\n \nstruct Edge\n{\n    int to, cap, rev;\n    Edge(){};\n    Edge(int to, int cap, int rev) : to(to), cap(cap), rev(rev){};\n};\n \nvector<Edge> G[MAX_V];\nbool used[MAX_V];\n \nvoid add_edge(int from, int to, int cap){\n    G[from].push_back({to, cap, (int)G[to].size()});\n    G[to].push_back({from, 0, (int)G[from].size()-1});\n}\n \nint dfs(int v, int t, int f){\n    if(v == t) return f;\n    used[v] = true;\n    for(int i = 0; i < G[v].size(); i++){\n        Edge& e = G[v][i];\n        if(!used[e.to] && e.cap > 0){\n            int d = dfs(e.to, t, min(f, e.cap));\n            if(d > 0){\n                e.cap -= d;\n                G[e.to][e.rev].cap += d;\n                return d;\n            }\n        }\n    }\n    return 0;\n}\n \nint max_flow(int s, int t){\n    int flow = 0;\n    while(1){\n        memset(used, 0, sizeof(used));\n        int f = dfs(s, t, INF);\n        if(f == 0) return flow;\n        flow += f;\n    }\n}\n\n//エラトステネスの篩を使用\nconst int MAX_PRIME = 1e7 + 10;\n \nvector<int> is_prime(MAX_PRIME,1);\n \nvoid calcPrime(){\n    is_prime[0]=is_prime[1]=0;\n    for(int i=2; i<MAX_PRIME; i++){\n        if(is_prime[i]==1){\n            for(int j=i*2; j<MAX_PRIME; j+=i){\n                is_prime[j]=0;\n            }\n        }\n    }\n}\n\nint main(){\n\tcalcPrime();\n\tint n;\n\tcin >> n;\n\tvi x(n);\n\trep(i, n) cin >> x[i];\n\tmap<int, int> mp;\n\trep(i, n) {\n\t\tmp[x[i]]^=1;\n\t\tmp[x[i]+1]^=1;\n\t}\n\tvi odd, even;\n\tfor(auto& p : mp) if(p.se) (p.fi&1?odd:even).pb(p.fi);\n\trep(i, odd.size()) rep(j, even.size()) {\n\t\tif(is_prime[abs(odd[i]-even[j])]) add_edge(1000+i, 2000+j, 1);\n\t}\n\trep(i, odd.size()) add_edge(0, 1000+i, 1);\n\trep(i, even.size()) add_edge(2000+i, 1, 1);\n\tint f = max_flow(0, 1);\n\tint ans = f + (((int)odd.size()-f)/2)*2 + (((int)even.size()-f)/2)*2;\n\tif(((int)odd.size()-f)&1) ans += 3;\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define N\t100\n#define A\t10000000\n\nchar composite[A + 1];\n\nvoid init() {\n\tint a, b;\n\n\tfor (a = 2; a <= A / a; a++) {\n\t\tif (composite[a])\n\t\t\tcontinue;\n\t\tfor (b = a * a; b <= A; b += a)\n\t\t\tcomposite[b] = 1;\n\t}\n}\n\nint *ov[1 + N], oo[1 + N];\n\nvoid link(int u, int v) {\n\tint o = oo[u]++;\n\n\tif (o >= 2 && (o & o - 1) == 0)\n\t\tov[u] = (int *) realloc(ov[u], o * 2 * sizeof *ov[u]);\n\tov[u][o] = v;\n}\n\nint vv[1 + N], uu[1 + N], dd[1 + N];\n\nint bfs(int n) {\n\tstatic int qu[1 + N];\n\tint u, head, cnt;\n\n\tfor (u = 0; u <= n; u++)\n\t\tdd[u] = n;\n\thead = cnt = 0;\n\tfor (u = 1; u <= n; u++)\n\t\tif (!vv[u])\n\t\t\tdd[u] = 0, qu[head + cnt++] = u;\n\twhile (cnt) {\n\t\tint d, o;\n\n\t\tu = qu[cnt--, head++], d = dd[u] + 1;\n\t\tfor (o = 0; o < oo[u]; o++) {\n\t\t\tint v = ov[u][o], w = uu[v];\n\n\t\t\tif (dd[w] == n) {\n\t\t\t\tdd[w] = d;\n\t\t\t\tif (w == 0)\n\t\t\t\t\treturn 1;\n\t\t\t\tqu[head + cnt++] = w;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint dfs(int u, int n) {\n\tint d, o;\n\n\tif (u == 0)\n\t\treturn 1;\n\td = dd[u] + 1;\n\tfor (o = 0; o < oo[u]; o++) {\n\t\tint v = ov[u][o], w = uu[v];\n\n\t\tif (dd[w] == d && dfs(v, n)) {\n\t\t\tvv[u] = v, uu[v] = u;\n\t\t\treturn 1;\n\t\t}\n\t}\n\tdd[u] = n;\n\treturn 0;\n}\n\nint hopcroft_karp(int n) {\n\tint cnt = 0;\n\n\twhile (bfs(n)) {\n\t\tint u;\n\n\t\tfor (u = 1; u <= n; u++)\n\t\t\tif (!vv[u] && dfs(u, n))\n\t\t\t\tcnt++;\n\t}\n\treturn cnt;\n}\n\nint main() {\n\tstatic int xx[N], xx0[N], xx1[N];\n\tint n, n0, n1, m, i, u, v;\n\n\tinit();\n\tscanf(\"%d\", &n);\n\tfor (i = 0; i < n; i++)\n\t\tscanf(\"%d\", &xx[i]);\n\tn0 = n1 = 0;\n\tfor (i = 0; i < n; i++) {\n\t\tif (i == 0 || xx[i - 1] + 1 != xx[i]) {\n\t\t\tif (xx[i] % 2 == 0)\n\t\t\t\txx0[n0++] = xx[i];\n\t\t\telse\n\t\t\t\txx1[n1++] = xx[i];\n\t\t}\n\t\tif (i + 1 == n || xx[i] + 1 != xx[i + 1]) {\n\t\t\tif ((xx[i] + 1) % 2 == 0)\n\t\t\t\txx0[n0++] = xx[i] + 1;\n\t\t\telse\n\t\t\t\txx1[n1++] = xx[i] + 1;\n\t\t}\n\t}\n\tfor (u = 1; u <= n0; u++)\n\t\tov[u] = (int *) malloc(2 * sizeof *ov[u]);\n\tfor (u = 0; u < n0; u++)\n\t\tfor (v = 0; v < n1; v++) {\n\t\t\tint x = abs(xx0[u] - xx1[v]);\n\n\t\t\tif (x > 2 && !composite[x])\n\t\t\t\tlink(1 + u, 1 + v);\n\t\t}\n\tm = hopcroft_karp(n0);\n\tprintf(\"%d\\n\", m + (n0 + n1 - m * 2) + (n0 - m) % 2);\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "/*\ncat <<EOF >mistaken-paste\n*/\n\n#pragma GCC diagnostic ignored \"-Wincompatible-pointer-types\"\n#define _USE_MATH_DEFINES\n\n#include <stdio.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdbool.h>\n#include <math.h>\n#include <time.h>\n\n#define BIG 2000000007\n#define VERYBIG 2000000000000007LL\n\n#define MOD 1000000007\n#define FOD  998244353\ntypedef uint64_t ull;\ntypedef  int64_t sll;\n\n#define N_MAX 1000000\n#define M_MAX 200000\n\n#ifdef __cplusplus\n#include <queue>\n#include <stack>\n#include <tuple>\n#include <set>\n#include <map>\n#include <string>\n\nusing std::queue;\nusing std::priority_queue;\nusing std::stack;\nusing std::tuple;\nusing std::set;\nusing std::map;\nusing std::vector;\nusing std::greater;\nusing std::pair;\nusing std::string;\n\n#endif\n\ntypedef struct {\n\tint32_t a;\n\tint32_t b;\n} hw;\n\ntypedef struct {\n\tsll a;\n\tsll b;\n} hwll;\n\ntypedef struct {\n\tsll a;\n\tsll b;\n\tsll c;\n} hwllc;\n\ntypedef struct {\n\thwll a;\n\thwll b;\n} linell;\n\null n, m;\null h, w;\null k;\null q;\nsll va, vb, vc, vd, ve, vf;\null ua, ub, uc, ud, ue, uf;\nlong double vra, vrb, vrc;\ndouble vda, vdb, vdc;\nchar ch, dh;\n\null umin (ull x, ull y) {\n\treturn (x < y) ? x : y;\n}\n\null umax (ull x, ull y) {\n\treturn (x > y) ? x : y;\n}\n\nsll smin (sll x, sll y) {\n\treturn (x < y) ? x : y;\n}\n\nsll smax (sll x, sll y) {\n\treturn (x > y) ? x : y;\n}\n\null gcd (ull x, ull y) {\n\tif (x < y) {\n\t\treturn gcd(y, x);\n\t} else if (y == 0) {\n\t\treturn x;\n\t} else {\n\t\treturn gcd(y, x % y);\n\t}\n}\n\null bitpow (ull a, ull x, ull modulo) {\n\tull result = 1;\n\twhile (x) {\n\t\tif (x & 1) {\n\t\t\tresult *= a;\n\t\t\tresult %= modulo;\n\t\t}\n\t\tx /= 2;\n\t\ta = (a * a) % modulo;\n\t}\n\treturn result;\n}\n\null divide (ull a, ull b, ull modulo) {\n\treturn (a * bitpow(b, modulo - 2, modulo)) % modulo;\n}\n\null udiff (ull a, ull b) {\n\tif (a >= b) {\n\t\treturn a - b;\n\t} else {\n\t\treturn b - a;\n\t}\n}\n\nsll sdiff (sll a, sll b) {\n\tif (a >= b) {\n\t\treturn a - b;\n\t} else {\n\t\treturn b - a;\n\t}\n}\n\nint bitcount (ull n) {\n\tint result = 0;\n\twhile (n) {\n\t\tif (n & 1) result++;\n\t\tn /= 2;\n\t}\n\treturn result;\n}\n\n// double distance (sll x1, sll y1, sll x2, sll y2) {\n// \tdouble xdist2, ydist2, origindist, dist;\n\n// \txdist2 = (x1 - x2) * (x1 - x2);\n// \tydist2 = (y1 - y2) * (y1 - y2);\n// \treturn sqrt(xdist2 + ydist2);\n// }\n\nint32_t pullcomp (const void *left, const void *right) {\n\tull l = *(ull*)left;\n\tull r = *(ull*)right;\n\tif (l < r) {\n\t\treturn -1;\n\t}\n\tif (l > r) {\n\t\treturn +1;\n\t}\n\treturn 0;\n}\n\nint32_t psllcomp (const void *left, const void *right) {\n\tsll l = *(sll*)left;\n\tsll r = *(sll*)right;\n\tif (l < r) {\n\t\treturn -1;\n\t}\n\tif (l > r) {\n\t\treturn +1;\n\t}\n\treturn 0;\n}\n\nint32_t pcharcomp (const void *left, const void *right) {\n\tchar l = *(char*)left;\n\tchar r = *(char*)right;\n\tif (l < r) {\n\t\treturn -1;\n\t}\n\tif (l > r) {\n\t\treturn +1;\n\t}\n\treturn 0;\n}\n\nint32_t pdoublecomp (const void *left, const void *right) {\n\tdouble l = *(double*)left;\n\tdouble r = *(double*)right;\n\tif (l < r) {\n\t\treturn -1;\n\t}\n\tif (l > r) {\n\t\treturn +1;\n\t}\n\treturn 0;\n}\n\nint32_t pstrcomp (const void *left, const void *right) {\n\tchar* l = *(char**)left;\n\tchar* r = *(char**)right;\n\n\treturn strcmp(l, r);\n}\n\nint32_t phwllABcomp (const void *left, const void *right) {\n\thwll l = *(hwll*)left;\n\thwll r = *(hwll*)right;\n\tif (l.a < r.a) {\n\t\treturn -1;\n\t}\n\tif (l.a > r.a) {\n\t\treturn +1;\n\t}\n\tif (l.b < r.b) {\n\t\treturn -1;\n\t}\n\tif (l.b > r.b) {\n\t\treturn +1;\n\t}\n\treturn 0;\n}\n\nint32_t phwllREVcomp (const void *left, const void *right) {\n\thwll l = *(hwll*)left;\n\thwll r = *(hwll*)right;\n\tif (l.b < r.b) {\n\t\treturn -1;\n\t}\n\tif (l.b > r.b) {\n\t\treturn +1;\n\t}\n\tif (l.a < r.a) {\n\t\treturn -1;\n\t}\n\tif (l.a > r.a) {\n\t\treturn +1;\n\t}\n\treturn 0;\n}\n\nint32_t ptriplecomp (const void *left, const void *right) {\n\thwllc l = *(hwllc*)left;\n\thwllc r = *(hwllc*)right;\n\n\tif (l.a < r.a) {\n\t\treturn -1;\n\t}\n\tif (l.a > r.a) {\n\t\treturn +1;\n\t}\n\tif (l.b < r.b) {\n\t\treturn -1;\n\t}\n\tif (l.b > r.b) {\n\t\treturn +1;\n\t}\n\tif (l.c < r.c) {\n\t\treturn -1;\n\t}\n\tif (l.c > r.c) {\n\t\treturn +1;\n\t}\n\treturn 0;\n}\n\nbool isinrange (sll left, sll x, sll right) {\n\treturn (left <= x && x <= right);\n}\n\nbool isinrange_soft (sll left, sll x, sll right) {\n\treturn (left <= x && x <= right) || (left >= x && x >= right);\n}\n\nsll a[N_MAX];\n// sll a[3001][3001];\nsll b[N_MAX];\n// sll b[3001][3001];\nsll c[N_MAX];\n// sll d[N_MAX];\n// sll e[N_MAX];\nchar s[N_MAX + 1];\n// char s[3010][3010];\nchar t[N_MAX + 1];\n// char t[3010][3010];\n// hwll xy[N_MAX];\n// sll table[1000][1000];\n\null g[1000][1000];\nhwll sorted[N_MAX];\n\nbool isprime (ull x) {\n\tif (x <= 1) return false;\n\tfor (ull i = 2; i * i <= x; i++) {\n\t\tif (x % i == 0) return false;\n\t}\n\treturn true;\n}\n\nbool iswatched[1000];\null dfs (ull s, ull t, ull f, ull n) {\n\tif (s == t) return f;\n\n\tiswatched[s] = true;\n\n\tfor (ull v = 0; v < n; v++) {\n\t\tif (iswatched[v]) continue;\n\t\tif (!g[s][v]) continue;\n\n\t\tull x = dfs(v, t, umin(f, g[s][v]), n);\n\t\tif (x) {\n\t\t\tg[s][v] -= x;\n\t\t\tg[v][s] += x;\n\t\t\treturn x;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\null flow (ull s, ull t, ull n) {\n\tull r = 0;\n\twhile (true) {\n\t\tfor (ull i = 0; i < n; i++) iswatched[i] = false;\n\t\tull f = dfs(s, t, VERYBIG, n);\n\t\tif (!f) return r;\n\t\tr += f;\n\t}\n}\n\null solve () {\n\tsll i, j, ki, li;\n\tull result = 0;\n\t// sll result = 0;\n\tdouble dresult = 0;\n\t// ull maybe = 0;\n\tsll maybe = 0;\n\t// ull sum = 0;\n\tsll sum = 0;\n\tsll item;\n\tull *dpcell;\n\n\tm = 0;\n\tfor (i = 0; i < n; i++) {\n\t\tif (i == 0 || a[i - 1] + 1 < a[i]) {\n\t\t\tb[m++] = a[i];\n\t\t}\n\t\tif (i == n - 1 || a[i] + 1 < a[i + 1]) {\n\t\t\tb[m++] = a[i] + 1;\n\t\t}\n\t}\n\n\tbool iseven = true;\n\tfor (i = 0; i < m; i++) {\n\t\tif (b[i] % 2) {\n\t\t\tg[i][m + 1] = 1;\n\t\t\tcontinue;\n\t\t} else {\n\t\t\tg[m][i] = 1;\n\t\t\tiseven = !iseven;\n\t\t}\n\n\t\tfor (j = 0; j < m; j++) {\n\t\t\tif ((b[i] ^ b[j]) & 1) {\n\t\t\t\tif (isprime(udiff(b[i], b[j]))) {\n\t\t\t\t\tg[i][j] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tull match = flow(m, m + 1, m + 2);\n\n\tif (iseven) {\n\t\tull ones = match - match % 2;\n\t\tresult = (m / 2 - ones) * 2 + ones;\n\t} else {\n\t\tif (!match) {\n\t\t\tresult = (m / 2 - 1) * 2 + 3;\n\t\t} else {\n\t\t\tull ones = match - 1 + match % 2;\n\t\t\tresult = (m / 2 - ones) * 2 + ones;\n\t\t}\n\t}\n\n\tprintf(\"%lld\\n\", result);\n\t// printf(\"%.15lf\\n\", dresult);\n\t// puts(s);\n\n\treturn 0;\n\n\tsuccess:\n\t// puts(\"YES\");\n\tputs(\"Yes\");\n\t// printf(\"%llu\\n\", result);\n\t// puts(\"0\");\n\t// puts(\"AC\");\n\treturn 0;\n\n\tfail:\n\t// puts(\"NO\");\n\tputs(\"No\");\n\t// puts(\"0\");\n\t// puts(\"-1\");\n\t// puts(\"-1 -1 -1\");\n\t// puts(\"WA\");\n\treturn 1;\n}\n\nint32_t main (void) {\n\tint32_t i, j;\n\tint32_t x, y;\n\n\tscanf(\"%llu\", &n, &m);\n\t// scanf(\"%llu\", &k, &n, &m);\n\t// scanf(\"%llu%llu\", &h, &w);\n\t// scanf(\"%lld\", &va, &vb, &vc, &vd);\n\t// scanf(\"%llu%llu\", &ua, &ub, &uc, &ud);\n\t// scanf(\"%llu\", &q);\n\t// scanf(\"%s\", s);\n\t// scanf(\"%s\", t);\n\tfor (i = 0; i < n; i++) {\n\t\t// scanf(\"%lld%lld\", &xy[i].a, &xy[i].b);\n\t\tscanf(\"%lld\", &a[i]);\n\t\t// scanf(\"%lld\", &b[i]);\n\t\t// scanf(\"%lld\", &c[i]);\n\t\t// scanf(\"%lld\", &d[i]);\n\t\t// a[i]--;\n\t\t// b[i]--;\n\t\t// c[i]--;\n\t}\n\t// scanf(\"%llu\", &m, &k);\n\t// scanf(\"%llu\", &q);\n\t// for (i = 0; i < k; i++) {\n\t// \tscanf(\"%lld\", &e[i]);\n\t// \te[i]--;\n\t// \tscanf(\"%lld\", &d[i]);\n\t// }\n\n\t// for (i = 0; i < n; i++) {\n\t// \tfor (j = 0; j < n; j++) {\n\t// \t\tscanf(\"%llu\", &table[i][j]);\n\t// \t}\n\t// }\n\t// for (i = 0; i < h; i++) {\n\t// \tscanf(\"%s\", &s[i]);\n\t// }\n\n\tsolve();\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "int printf();\nint scanf();\nvoid *malloc();\nvoid *realloc();\nvoid free();\n\nint isprime(int x){\n  int i;\n  if(x<2)return 0;\n  if(x==2)return 1;\n  if(x-(x/2)*2==0)return 0;\n  i=3;\n  while(i*i<x+1){\n    if(x-(x/i)*i==0)return 0;\n    i = i + 2;\n  }\n  return 1;\n}\n\n/* [size, maxlen, v[0], v[1], ...] */\nint *vector_init(){\n  int *v;\n  int n;\n  n = 256;\n  v = malloc(4 * (2+n));\n  *(v+0) = 0; /* v[0] := size */\n  *(v+1) = 4; /* v[1] := maxlen */\n  return v;\n}\nint *vector_push_back(int *vector, int value){\n  int size;\n  int maxlen;\n  size = *(vector+0);\n  maxlen = *(vector+1);\n  if(size == maxlen){\n    maxlen = maxlen * 2;\n    vector = realloc(vector, 4 * (2+maxlen));\n    *(vector+1) = maxlen;\n  }\n  *(vector+2+size) = value;\n  size = size + 1;\n  *(vector+0) = size;\n  return vector;\n}\nint *vector_pop_back(int *vector){\n  int size;\n  size = *(vector+0);\n  if(size == 0){\n    return vector;\n  }else{\n    *(vector+0) = size - 1;\n    return vector;\n  }\n}\nint *vector_back(int *vector){\n  int size;\n  size = *(vector+0);\n  if(size==0)return vector;\n  return vector+1+size;\n}\n\nint calc_max_flow(int n, int **cap, int s, int t){\n  int flow;\n  int i;\n  flow = 0;\n  while(1){\n    int cur;\n    int *bef;\n    int *visited;\n    int *stack;\n    bef = malloc(4 * n);\n    visited = malloc(4 * n);\n    i = 0;\n    while(i < n){\n      *(bef+i) = -1;\n      *(visited+i) = 0;\n      i = i + 1;\n    }\n    stack = vector_init();\n    stack = vector_push_back(stack, s);\n    *(visited+s) = 1;\n    while(!(*(stack+0) == 0)){\n      int p;\n      p = *vector_back(stack);\n      stack = vector_pop_back(stack);\n      if(p==t)goto goal;\n      i = 0;\n      while(i < n){\n        if(*(*(cap+p)+i)==1 && !*(visited+i)){\n          *(visited+i) = 1;\n          *(bef+i) = p;\n          stack = vector_push_back(stack, i);\n        }\n        i = i + 1;\n      }\n    }\ngoal:\n    free(stack);\n    free(visited);\n    if(*(bef+t)==-1){\n      free(bef);\n      return flow;\n    }\n    flow = flow + 1;\n    /* reverse */\n    cur = t;\n    while(1){\n      int nxt;\n      nxt = *(bef+cur);\n      if(nxt == -1)goto reverse_end;\n      *(*(cap+nxt)+cur) = 0;\n      *(*(cap+cur)+nxt) = 1;\n      cur = nxt;\n    }\nreverse_end:\n    free(bef);\n  }\n  return flow;\n}\n\nint n;\nint *x;\nint **cap;\nint main(){\n  int i;\n  int j;\n  int *b;\n  int size;\n  int *head;\n  int *even;\n  int *odd;\n  int m;\n  int source;\n  int sink;\n  int evensize;\n  int oddsize;\n  int *evenhead;\n  int *oddhead;\n  int flow;\n  int ans;\n\n  /* input */\n  /* n */\n  scanf(\"%d\", &n);\n  /* x */\n  x = malloc(4 * n);\n  i = 0;\n  while(i<n){\n    scanf(\"%d\", x+i);\n    i = i + 1;\n  }\n\n  /* convert to b-array */\n  b = vector_init();\n  i = 0;\n  while(i<n){\n    int val;\n    int *back;\n    val = *(x+i);\n    back = vector_back(b);\n    if((!(back == b)) && (*back == val)){\n      *back = val + 1;\n    }else{\n      b = vector_push_back(b, val);\n      b = vector_push_back(b, val + 1);\n    }\n    i = i + 1;\n  }\n\n  /* split into even and odd */\n  even = vector_init();\n  odd = vector_init();\n  size = *(b+0);\n  head = b+2;\n  i = 0;\n  while(i<size){\n    int val;\n    val = *(head+i);\n    if(val-(val/2)*2==0){\n      even = vector_push_back(even, val);\n    }else{\n      odd = vector_push_back(odd, val);\n    }\n    i = i + 1;\n  }\n\n  /* construct graph */\n  m = size + 2;\n  source = size;\n  sink = size + 1;\n  evensize = *(even+0);\n  oddsize = *(odd+0);\n  evenhead = even + 2;\n  oddhead = odd + 2;\n\n  cap = malloc(8 * m);\n\n  i = 0;\n  while(i < m){\n    *(cap+i) = malloc(4 * m);\n    i = i + 1;\n  }\n\n  i = 0;\n  while(i < evensize){\n    *(*(cap+source)+i) = 1;\n    i = i + 1;\n  }\n\n  i = 0;\n  while(i < oddsize){\n    *(*(cap+evensize+i)+sink) = 1;\n    i = i + 1;\n  }\n\n  i = 0;\n  while(i < evensize){\n    j = 0;\n    while(j < oddsize){\n      int d;\n      d = *(evenhead+i) - *(oddhead+j);\n      if(d < 0)d = -d;\n      if(!(d<3) && isprime(d)){\n        *(*(cap+i)+evensize+j) = 1;\n      }\n      j = j + 1;\n    }\n    i = i + 1;\n  }\n\n  /* flow */\n  flow = calc_max_flow(m, cap, source, sink);\n  ans = flow + (evensize-flow) + (oddsize-flow);\n  evensize = evensize - flow;\n  if(evensize - (evensize/2)*2 == 1){\n    ans = ans + 1;\n  }\n  printf(\"%d\\n\", ans);\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define N\t100\n#define A\t10000000\n\nchar composite[A + 1];\n\nvoid init() {\n\tint a, b;\n\n\tfor (a = 2; a <= A / a; a++) {\n\t\tif (composite[a])\n\t\t\tcontinue;\n\t\tfor (b = a * a; b <= A; b += a)\n\t\t\tcomposite[b] = 1;\n\t}\n}\n\nint *ov[1 + N], oo[1 + N];\n\nvoid link(int u, int v) {\n\tint o = oo[u]++;\n\n\tif (o >= 2 && (o & o - 1) == 0)\n\t\tov[u] = (int *) realloc(ov[u], o * 2 * sizeof *ov[u]);\n\tov[u][o] = v;\n}\n\nint vv[1 + N], uu[1 + N], dd[1 + N];\n\nint bfs(int n) {\n\tstatic int qu[1 + N];\n\tint u, head, cnt;\n\n\tfor (u = 0; u <= n; u++)\n\t\tdd[u] = n;\n\thead = cnt = 0;\n\tfor (u = 1; u <= n; u++)\n\t\tif (!vv[u])\n\t\t\tdd[u] = 0, qu[head + cnt++] = u;\n\twhile (cnt) {\n\t\tint d, o;\n\n\t\tu = qu[cnt--, head++], d = dd[u] + 1;\n\t\tfor (o = 0; o < oo[u]; o++) {\n\t\t\tint v = ov[u][o], w = uu[v];\n\n\t\t\tif (dd[w] == n) {\n\t\t\t\tdd[w] = d;\n\t\t\t\tif (w == 0)\n\t\t\t\t\treturn 1;\n\t\t\t\tqu[head + cnt++] = w;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint dfs(int u, int n) {\n\tint d, o;\n\n\tif (u == 0)\n\t\treturn 1;\n\td = dd[u] + 1;\n\tfor (o = 0; o < oo[u]; o++) {\n\t\tint v = ov[u][o], w = uu[v];\n\n\t\tif (dd[w] == d && dfs(w, n)) {\n\t\t\tvv[u] = v, uu[v] = u;\n\t\t\treturn 1;\n\t\t}\n\t}\n\tdd[u] = n;\n\treturn 0;\n}\n\nint hopcroft_karp(int n) {\n\tint cnt = 0;\n\n\twhile (bfs(n)) {\n\t\tint u;\n\n\t\tfor (u = 1; u <= n; u++)\n\t\t\tif (!vv[u] && dfs(u, n))\n\t\t\t\tcnt++;\n\t}\n\treturn cnt;\n}\n\nint main() {\n\tstatic int xx[N], xx0[N], xx1[N];\n\tint n, n0, n1, m, i, u, v;\n\n\tinit();\n\tscanf(\"%d\", &n);\n\tfor (i = 0; i < n; i++)\n\t\tscanf(\"%d\", &xx[i]);\n\tn0 = n1 = 0;\n\tfor (i = 0; i < n; i++) {\n\t\tif (i == 0 || xx[i - 1] + 1 != xx[i]) {\n\t\t\tif (xx[i] % 2 == 0)\n\t\t\t\txx0[n0++] = xx[i];\n\t\t\telse\n\t\t\t\txx1[n1++] = xx[i];\n\t\t}\n\t\tif (i + 1 == n || xx[i] + 1 != xx[i + 1]) {\n\t\t\tif ((xx[i] + 1) % 2 == 0)\n\t\t\t\txx0[n0++] = xx[i] + 1;\n\t\t\telse\n\t\t\t\txx1[n1++] = xx[i] + 1;\n\t\t}\n\t}\n\tfor (u = 1; u <= n0; u++)\n\t\tov[u] = (int *) malloc(2 * sizeof *ov[u]);\n\tfor (u = 0; u < n0; u++)\n\t\tfor (v = 0; v < n1; v++) {\n\t\t\tint x = abs(xx0[u] - xx1[v]);\n\n\t\t\tif (x > 2 && !composite[x])\n\t\t\t\tlink(1 + u, 1 + v);\n\t\t}\n\tm = hopcroft_karp(n0);\n\tprintf(\"%d\\n\", m + (n0 + n1 - m * 2) + (n0 - m) % 2);\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "/*\ncat <<EOF >mistaken-paste\n*/\n\n#pragma GCC diagnostic ignored \"-Wincompatible-pointer-types\"\n#define _USE_MATH_DEFINES\n\n#include <stdio.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdbool.h>\n#include <math.h>\n#include <time.h>\n\n#define BIG 2000000007\n#define VERYBIG 2000000000000007LL\n\n#define MOD 1000000007\n#define FOD  998244353\ntypedef uint64_t ull;\ntypedef  int64_t sll;\n\n#define N_MAX 1000000\n#define M_MAX 200000\n\n#ifdef __cplusplus\n#include <queue>\n#include <stack>\n#include <tuple>\n#include <set>\n#include <map>\n#include <string>\n\nusing std::queue;\nusing std::priority_queue;\nusing std::stack;\nusing std::tuple;\nusing std::set;\nusing std::map;\nusing std::vector;\nusing std::greater;\nusing std::pair;\nusing std::string;\n\n#endif\n\ntypedef struct {\n\tint32_t a;\n\tint32_t b;\n} hw;\n\ntypedef struct {\n\tsll a;\n\tsll b;\n} hwll;\n\ntypedef struct {\n\tsll a;\n\tsll b;\n\tsll c;\n} hwllc;\n\ntypedef struct {\n\thwll a;\n\thwll b;\n} linell;\n\null n, m;\null h, w;\null k;\null q;\nsll va, vb, vc, vd, ve, vf;\null ua, ub, uc, ud, ue, uf;\nlong double vra, vrb, vrc;\ndouble vda, vdb, vdc;\nchar ch, dh;\n\null umin (ull x, ull y) {\n\treturn (x < y) ? x : y;\n}\n\null umax (ull x, ull y) {\n\treturn (x > y) ? x : y;\n}\n\nsll smin (sll x, sll y) {\n\treturn (x < y) ? x : y;\n}\n\nsll smax (sll x, sll y) {\n\treturn (x > y) ? x : y;\n}\n\null gcd (ull x, ull y) {\n\tif (x < y) {\n\t\treturn gcd(y, x);\n\t} else if (y == 0) {\n\t\treturn x;\n\t} else {\n\t\treturn gcd(y, x % y);\n\t}\n}\n\null bitpow (ull a, ull x, ull modulo) {\n\tull result = 1;\n\twhile (x) {\n\t\tif (x & 1) {\n\t\t\tresult *= a;\n\t\t\tresult %= modulo;\n\t\t}\n\t\tx /= 2;\n\t\ta = (a * a) % modulo;\n\t}\n\treturn result;\n}\n\null divide (ull a, ull b, ull modulo) {\n\treturn (a * bitpow(b, modulo - 2, modulo)) % modulo;\n}\n\null udiff (ull a, ull b) {\n\tif (a >= b) {\n\t\treturn a - b;\n\t} else {\n\t\treturn b - a;\n\t}\n}\n\nsll sdiff (sll a, sll b) {\n\tif (a >= b) {\n\t\treturn a - b;\n\t} else {\n\t\treturn b - a;\n\t}\n}\n\nint bitcount (ull n) {\n\tint result = 0;\n\twhile (n) {\n\t\tif (n & 1) result++;\n\t\tn /= 2;\n\t}\n\treturn result;\n}\n\n// double distance (sll x1, sll y1, sll x2, sll y2) {\n// \tdouble xdist2, ydist2, origindist, dist;\n\n// \txdist2 = (x1 - x2) * (x1 - x2);\n// \tydist2 = (y1 - y2) * (y1 - y2);\n// \treturn sqrt(xdist2 + ydist2);\n// }\n\nint32_t pullcomp (const void *left, const void *right) {\n\tull l = *(ull*)left;\n\tull r = *(ull*)right;\n\tif (l < r) {\n\t\treturn -1;\n\t}\n\tif (l > r) {\n\t\treturn +1;\n\t}\n\treturn 0;\n}\n\nint32_t psllcomp (const void *left, const void *right) {\n\tsll l = *(sll*)left;\n\tsll r = *(sll*)right;\n\tif (l < r) {\n\t\treturn -1;\n\t}\n\tif (l > r) {\n\t\treturn +1;\n\t}\n\treturn 0;\n}\n\nint32_t pcharcomp (const void *left, const void *right) {\n\tchar l = *(char*)left;\n\tchar r = *(char*)right;\n\tif (l < r) {\n\t\treturn -1;\n\t}\n\tif (l > r) {\n\t\treturn +1;\n\t}\n\treturn 0;\n}\n\nint32_t pdoublecomp (const void *left, const void *right) {\n\tdouble l = *(double*)left;\n\tdouble r = *(double*)right;\n\tif (l < r) {\n\t\treturn -1;\n\t}\n\tif (l > r) {\n\t\treturn +1;\n\t}\n\treturn 0;\n}\n\nint32_t pstrcomp (const void *left, const void *right) {\n\tchar* l = *(char**)left;\n\tchar* r = *(char**)right;\n\n\treturn strcmp(l, r);\n}\n\nint32_t phwllABcomp (const void *left, const void *right) {\n\thwll l = *(hwll*)left;\n\thwll r = *(hwll*)right;\n\tif (l.a < r.a) {\n\t\treturn -1;\n\t}\n\tif (l.a > r.a) {\n\t\treturn +1;\n\t}\n\tif (l.b < r.b) {\n\t\treturn -1;\n\t}\n\tif (l.b > r.b) {\n\t\treturn +1;\n\t}\n\treturn 0;\n}\n\nint32_t phwllREVcomp (const void *left, const void *right) {\n\thwll l = *(hwll*)left;\n\thwll r = *(hwll*)right;\n\tif (l.b < r.b) {\n\t\treturn -1;\n\t}\n\tif (l.b > r.b) {\n\t\treturn +1;\n\t}\n\tif (l.a < r.a) {\n\t\treturn -1;\n\t}\n\tif (l.a > r.a) {\n\t\treturn +1;\n\t}\n\treturn 0;\n}\n\nint32_t ptriplecomp (const void *left, const void *right) {\n\thwllc l = *(hwllc*)left;\n\thwllc r = *(hwllc*)right;\n\n\tif (l.a < r.a) {\n\t\treturn -1;\n\t}\n\tif (l.a > r.a) {\n\t\treturn +1;\n\t}\n\tif (l.b < r.b) {\n\t\treturn -1;\n\t}\n\tif (l.b > r.b) {\n\t\treturn +1;\n\t}\n\tif (l.c < r.c) {\n\t\treturn -1;\n\t}\n\tif (l.c > r.c) {\n\t\treturn +1;\n\t}\n\treturn 0;\n}\n\nbool isinrange (sll left, sll x, sll right) {\n\treturn (left <= x && x <= right);\n}\n\nbool isinrange_soft (sll left, sll x, sll right) {\n\treturn (left <= x && x <= right) || (left >= x && x >= right);\n}\n\nsll a[N_MAX];\n// sll a[3001][3001];\nsll b[N_MAX];\n// sll b[3001][3001];\nsll c[N_MAX];\n// sll d[N_MAX];\n// sll e[N_MAX];\nchar s[N_MAX + 1];\n// char s[3010][3010];\nchar t[N_MAX + 1];\n// char t[3010][3010];\n// hwll xy[N_MAX];\n// sll table[1000][1000];\n\null g[1000][1000];\n\nbool isprime (ull x) {\n\tif (x <= 1) return false;\n\tfor (ull i = 2; i * i <= x; i++) {\n\t\tif (x % i == 0) return false;\n\t}\n\treturn true;\n}\n\nbool iswatched[1000];\null dfs (ull s, ull t, ull f, ull n) {\n\tif (s == t) return f;\n\n\tiswatched[s] = true;\n\n\tfor (ull v = 0; v < n; v++) {\n\t\tif (iswatched[v]) continue;\n\t\tif (!g[s][v]) continue;\n\n\t\tull x = dfs(v, t, umin(f, g[s][v]), n);\n\t\tif (x) {\n\t\t\treturn x;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\null flow (ull s, ull t, ull n) {\n\tull r = 0;\n\twhile (true) {\n\t\tfor (ull i = 0; i < n; i++) iswatched[i] = false;\n\t\tull f = dfs(s, t, VERYBIG, n);\n\t\tif (!f) return r;\n\t\tr += f;\n\t}\n}\n\null solve () {\n\tsll i, j, ki, li;\n\tull result = 0;\n\t// sll result = 0;\n\tdouble dresult = 0;\n\t// ull maybe = 0;\n\tsll maybe = 0;\n\t// ull sum = 0;\n\tsll sum = 0;\n\tsll item;\n\tull *dpcell;\n\n\tm = 0;\n\tfor (i = 0; i < n; i++) {\n\t\tif (i == 0 || a[i - 1] + 1 < a[i]) {\n\t\t\tb[m++] = a[i];\n\t\t}\n\t\tif (i == n - 1 || a[i] + 1 < a[i + 1]) {\n\t\t\tb[m++] = a[i] + 1;\n\t\t}\n\t}\n\n\tbool iseven = true;\n\tfor (i = 0; i < m; i++) {\n\t\tif (b[i] % 2) {\n\t\t\tg[i][m + 1] = 1;\n\t\t\tcontinue;\n\t\t} else {\n\t\t\tg[m][i] = 1;\n\t\t\tiseven = !iseven;\n\t\t}\n\n\t\tfor (j = 0; j < m; j++) {\n\t\t\tif ((b[i] ^ b[j]) & 1) {\n\t\t\t\tif (isprime(udiff(b[i], b[j]))) {\n\t\t\t\t\tg[i][j] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tull match = flow(m, m + 1, m + 2);\n\n\tif (iseven) {\n\t\tull ones = match - match % 2;\n\t\tresult = (m / 2 - ones) * 2 + ones;\n\t} else {\n\t\tif (!match) {\n\t\t\tresult = (m / 2 - 1) * 2 + 3;\n\t\t} else {\n\t\t\tull ones = match - 1 + match % 2;\n\t\t\tresult = (m / 2 - ones) * 2 + ones;\n\t\t}\n\t}\n\n\tprintf(\"%lld\\n\", result);\n\t// printf(\"%.15lf\\n\", dresult);\n\t// puts(s);\n\n\treturn 0;\n\n\tsuccess:\n\t// puts(\"YES\");\n\tputs(\"Yes\");\n\t// printf(\"%llu\\n\", result);\n\t// puts(\"0\");\n\t// puts(\"AC\");\n\treturn 0;\n\n\tfail:\n\t// puts(\"NO\");\n\tputs(\"No\");\n\t// puts(\"0\");\n\t// puts(\"-1\");\n\t// puts(\"-1 -1 -1\");\n\t// puts(\"WA\");\n\treturn 1;\n}\n\nint32_t main (void) {\n\tint32_t i, j;\n\tint32_t x, y;\n\n\tscanf(\"%llu\", &n, &m);\n\t// scanf(\"%llu\", &k, &n, &m);\n\t// scanf(\"%llu%llu\", &h, &w);\n\t// scanf(\"%lld\", &va, &vb, &vc, &vd);\n\t// scanf(\"%llu%llu\", &ua, &ub, &uc, &ud);\n\t// scanf(\"%llu\", &q);\n\t// scanf(\"%s\", s);\n\t// scanf(\"%s\", t);\n\tfor (i = 0; i < n; i++) {\n\t\t// scanf(\"%lld%lld\", &xy[i].a, &xy[i].b);\n\t\tscanf(\"%lld\", &a[i]);\n\t\t// scanf(\"%lld\", &b[i]);\n\t\t// scanf(\"%lld\", &c[i]);\n\t\t// scanf(\"%lld\", &d[i]);\n\t\t// a[i]--;\n\t\t// b[i]--;\n\t\t// c[i]--;\n\t}\n\t// scanf(\"%llu\", &m, &k);\n\t// scanf(\"%llu\", &q);\n\t// for (i = 0; i < k; i++) {\n\t// \tscanf(\"%lld\", &e[i]);\n\t// \te[i]--;\n\t// \tscanf(\"%lld\", &d[i]);\n\t// }\n\n\t// for (i = 0; i < n; i++) {\n\t// \tfor (j = 0; j < n; j++) {\n\t// \t\tscanf(\"%llu\", &table[i][j]);\n\t// \t}\n\t// }\n\t// for (i = 0; i < h; i++) {\n\t// \tscanf(\"%s\", &s[i]);\n\t// }\n\n\tsolve();\n\n\treturn 0;\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        FastScanner in = new FastScanner(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskF solver = new TaskF();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskF {\n        final int N = (int) (1e7 + 100);\n        boolean[] isPrime = new boolean[N];\n\n        public void solve(int testNumber, FastScanner in, PrintWriter out) {\n            Arrays.fill(isPrime, true);\n            isPrime[0] = false;\n            isPrime[1] = false;\n            for (int i = 2; i < N; i++) {\n                for (int j = i + i; j < N; j += i) {\n                    isPrime[j] = false;\n                }\n            }\n\n            int n = in.nextInt();\n            int[] x = new int[n];\n            for (int i = 0; i < n; i++) {\n                x[i] = in.nextInt();\n            }\n\n            int[] d = new int[n];\n            for (int i = 0; i < n; i++) {\n                d[i] = 3 * (i + 1);\n                for (int j = 0; j < i; j++) {\n                    if (x[i] - x[j] == 1) {\n                        continue;\n                    }\n                    int cur = f(x[i] - x[j] + 1);\n                    for (int k = j; k < i; k++) {\n                        cur += f(x[k + 1] - x[k] - 1);\n                    }\n                    if (j > 0) {\n                        cur += d[j - 1];\n                    }\n                    d[i] = Math.min(d[i], cur);\n                }\n\n                if (i > 0 && x[i] == x[i - 1] + 1) {\n                    int cur = 2;\n                    if (i > 1) {\n                        cur += d[i - 1];\n                    }\n                    d[i] = Math.min(d[i], cur);\n                }\n            }\n            out.println(d[n - 1]);\n        }\n\n        private int f(int len) {\n            if (len < 1) {\n                return 0;\n            }\n            if (isPrime[len]) {\n                return 1;\n            }\n            if (len % 2 == 0) {\n                return 2;\n            }\n            return 4;\n        }\n\n    }\n\n    static class FastScanner {\n        private BufferedReader in;\n        private StringTokenizer st;\n\n        public FastScanner(InputStream stream) {\n            in = new BufferedReader(new InputStreamReader(stream));\n        }\n\n        public String next() {\n            while (st == null || !st.hasMoreTokens()) {\n                try {\n                    st = new StringTokenizer(in.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return st.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.io.IOException;\nimport java.io.Reader;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.io.BufferedReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author tanzaku\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        MyInput in = new MyInput(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskF solver = new TaskF();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskF {\n        public void solve(int testNumber, MyInput in, PrintWriter out) {\n            int n = in.nextInt();\n            List<Integer> ones = new ArrayList<>();\n            int[] xs = in.nextIntArray(n);\n            for (int i = 0; i < n; i++) {\n                if (i == 0 || xs[i] - xs[i - 1] != 1) ones.add(xs[i]);\n                if (i == n - 1 || xs[i + 1] - xs[i] != 1) ones.add(xs[i] + 1);\n            }\n\n            boolean[] isPrime = eratosthenes(10000000);\n            int m = ones.size();\n            int S = m * 2, T = S + 1;\n//        PushRelabelBaseMaxFlow flow = new PushRelabelBaseMaxFlow(T + 1);\n            Dinic flow = new Dinic(T + 1);\n            int[] cnt = new int[2];\n            for (int i = 0; i < ones.size(); i++) {\n                cnt[ones.get(i) % 2]++;\n                flow.addEdge(S, i, 1);\n                flow.addEdge(i + m, T, 1);\n                for (int j = 0; j < i; j++) {\n                    final int a = ones.get(i);\n                    final int b = ones.get(i);\n                    if (a == b) break;\n                    if (a - b != 2 && isPrime[a - b]) {\n                        flow.addEdge(i, j + m, 1);\n                        flow.addEdge(j, i + m, 1);\n                    }\n                }\n            }\n//        int f1 = (int)(flow.relabelToFront(S, T) / 2);\n            int f1 = (int) (flow.MaxFlow(S, T) / 2);\n            cnt[0] -= f1;\n            cnt[1] -= f1;\n            int f2 = cnt[0] / 2 + cnt[1] / 2;\n            int f3 = cnt[0] % 2 != 0 ? 1 : 0;\n            out.println(f1 * 1 + f2 * 2 + f3 * 3);\n        }\n\n        private static boolean[] eratosthenes(int n) {\n            final boolean[] p = new boolean[n + 1];\n            Arrays.fill(p, true);\n            p[0] = p[1] = false;\n            for (int i = 2; i * i <= n; i++) {\n                if (p[i]) {\n                    for (int j = i * i; j <= n; j += i) {\n                        p[j] = false;\n                    }\n                }\n            }\n            return p;\n        }\n\n    }\n\n    static class Dinic {\n        final int INF = 1 << 29;\n        Dinic.AdjListGraph g;\n        int[] level;\n        int[] iter;\n        int[] q;\n        List<int[]> es = new ArrayList<>();\n\n        void bfs(int s) {\n            for (int i = 0; i < level.length; i++) level[i] = -1;\n//\t\tQueue<Integer> q = new LinkedList<Integer>();\n            int qs = 0, qt = 0;\n            level[s] = 0;\n            q[qt++] = s;\n            while (qs != qt) {\n                int v = q[qs++];\n                for (int e = g.head[v]; e != -1; e = g.next[e]) {\n                    final int t = g.to[e];\n                    if (g.cap[e] > 0 && level[t] < 0) {\n                        level[t] = level[v] + 1;\n                        q[qt++] = t;\n                    }\n                }\n            }\n        }\n\n        int dfs(int v, int t, int f) {\n            if (v == t) return f;\n            for (int i = iter[v]; i != -1; i = iter[v] = g.next[i]) {\n                if (g.cap[i] > 0 && level[v] < level[g.to[i]]) {\n                    int d = dfs(g.to[i], t, Math.min(f, g.cap[i]));\n                    if (d > 0) {\n                        g.cap[i] -= d;\n                        g.cap[g.rev[i]] += d;\n                        return d;\n                    }\n                }\n            }\n            return 0;\n        }\n\n        public void addEdge(int from, int to, int cap) {\n            es.add(new int[]{from, to, cap,});\n//\t\tg.addEdge(from, to, cap, g.m + 1);\n//\t\tg.addEdge(to, from, 0, g.m - 1);\n        }\n\n        private void build() {\n            if (g == null) {\n                g = new Dinic.AdjListGraph(level.length, 2 * es.size() * 2);\n                for (int[] e : es) {\n                    g.addEdge(e[0], e[1], e[2], g.m + 1);\n                    g.addEdge(e[1], e[0], 0, g.m - 1);\n                }\n            }\n        }\n\n        public int MaxFlow(int s, int t) {\n            build();\n            int flow = 0;\n            for (; ; ) {\n                bfs(s);\n                if (level[t] < 0) return flow;\n                for (int i = 0; i < iter.length; i++) iter[i] = g.head[i];\n                for (int f = 0; (f = dfs(s, t, INF)) > 0; )\n                    flow += f;\n            }\n        }\n\n        public Dinic(int size) {\n            level = new int[size];\n            iter = new int[size];\n            q = new int[size];\n        }\n\n        static class AdjListGraph {\n            int m;\n            int[] head;\n            int[] next;\n            int[] to;\n            int[] rev;\n            int[] cap;\n\n            public AdjListGraph(int V, int E) {\n                head = new int[V];\n                next = new int[E];\n                to = new int[E];\n                cap = new int[E];\n                rev = new int[E];\n                clear();\n            }\n\n            public void clear() {\n                m = 0;\n                Arrays.fill(head, -1);\n            }\n\n            public void addEdge(int s, int t, int c, int r) {\n                next[m] = head[s];\n                head[s] = m;\n                to[m] = t;\n                cap[m] = c;\n                rev[m++] = r;\n            }\n\n        }\n\n    }\n\n    static class MyInput {\n        private final BufferedReader in;\n        private static int pos;\n        private static int readLen;\n        private static final char[] buffer = new char[1024 * 8];\n        private static char[] str = new char[500 * 8 * 2];\n        private static boolean[] isDigit = new boolean[256];\n        private static boolean[] isSpace = new boolean[256];\n        private static boolean[] isLineSep = new boolean[256];\n\n        static {\n            for (int i = 0; i < 10; i++) {\n                isDigit['0' + i] = true;\n            }\n            isDigit['-'] = true;\n            isSpace[' '] = isSpace['\\r'] = isSpace['\\n'] = isSpace['\\t'] = true;\n            isLineSep['\\r'] = isLineSep['\\n'] = true;\n        }\n\n        public MyInput(InputStream is) {\n            in = new BufferedReader(new InputStreamReader(is));\n        }\n\n        public int read() {\n            if (pos >= readLen) {\n                pos = 0;\n                try {\n                    readLen = in.read(buffer);\n                } catch (IOException e) {\n                    throw new RuntimeException();\n                }\n                if (readLen <= 0) {\n                    throw new MyInput.EndOfFileRuntimeException();\n                }\n            }\n            return buffer[pos++];\n        }\n\n        public int nextInt() {\n            int len = 0;\n            str[len++] = nextChar();\n            len = reads(len, isSpace);\n            int i = 0;\n            int ret = 0;\n            if (str[0] == '-') {\n                i = 1;\n            }\n            for (; i < len; i++) ret = ret * 10 + str[i] - '0';\n            if (str[0] == '-') {\n                ret = -ret;\n            }\n            return ret;\n        }\n\n        public char nextChar() {\n            while (true) {\n                final int c = read();\n                if (!isSpace[c]) {\n                    return (char) c;\n                }\n            }\n        }\n\n        int reads(int len, boolean[] accept) {\n            try {\n                while (true) {\n                    final int c = read();\n                    if (accept[c]) {\n                        break;\n                    }\n                    if (str.length == len) {\n                        char[] rep = new char[str.length * 3 / 2];\n                        System.arraycopy(str, 0, rep, 0, str.length);\n                        str = rep;\n                    }\n                    str[len++] = (char) c;\n                }\n            } catch (MyInput.EndOfFileRuntimeException e) {\n            }\n            return len;\n        }\n\n        public int[] nextIntArray(final int n) {\n            final int[] res = new int[n];\n            for (int i = 0; i < n; i++) {\n                res[i] = nextInt();\n            }\n            return res;\n        }\n\n        static class EndOfFileRuntimeException extends RuntimeException {\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.StringTokenizer;\nimport java.io.BufferedReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        FastScanner in = new FastScanner(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskF solver = new TaskF();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskF {\n        public void solve(int testNumber, FastScanner in, PrintWriter out) {\n            int n = in.nextInt();\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++) {\n                a[i] = in.nextInt();\n            }\n\n            List<Integer> b = new ArrayList<>();\n            {\n                int l = -1;\n                int r = -1;\n                for (int x : a) {\n                    if (x == r + 1) {\n                        ++r;\n                    } else {\n                        if (l >= 0) {\n                            b.add(l);\n                            b.add(r + 1);\n                        }\n                        l = x;\n                        r = x;\n                    }\n                }\n                if (l >= 0) {\n                    b.add(l);\n                    b.add(r + 1);\n                }\n            }\n\n            List<Integer> even = new ArrayList<>();\n            List<Integer> odd = new ArrayList<>();\n            for (int x : b) {\n                if (x % 2 == 0) {\n                    even.add(x);\n                } else {\n                    odd.add(x);\n                }\n            }\n            boolean[][] g = new boolean[even.size()][odd.size()];\n            for (int i = 0; i < even.size(); i++) {\n                for (int j = 0; j < odd.size(); j++) {\n                    if (f(Math.abs(even.get(i) - odd.get(j))) == 1) {\n                        g[i][j] = true;\n                    }\n                }\n            }\n            int k = matching(g);\n            if (b.size() % 2 != 0) {\n                throw new AssertionError();\n            }\n            int ans = k;\n            ans += ((even.size() - k) / 2) * 2;\n            ans += ((odd.size() - k) / 2) * 2;\n            if ((even.size() - k) % 2 != 0) {\n                ans += 3;\n            }\n            out.println(ans);\n        }\n\n        private int f(int len) {\n            if (len < 1) {\n                return 0;\n            }\n            if (len == 1) {\n                return 3;\n            }\n            if (len % 2 == 0) {\n                return 2;\n            }\n            for (int d = 3; d * d <= len; d += 2) {\n                if (len % d == 0) {\n                    return 3;\n                }\n            }\n            return 1;\n        }\n\n        private int matching(boolean[][] g) {\n            int n = g.length;\n            int m = n == 0 ? 0 : g[0].length;\n            int[] pair = new int[m];\n            Arrays.fill(pair, -1);\n            int res = 0;\n            boolean[] was = new boolean[n];\n            for (int i = 0; i < n; i++) {\n                Arrays.fill(was, false);\n                if (dfs(i, g, was, pair)) {\n                    ++res;\n                }\n            }\n            return res;\n        }\n\n        private boolean dfs(int v, boolean[][] g, boolean[] was, int[] pair) {\n            if (was[v]) {\n                return false;\n            }\n            was[v] = true;\n            for (int u = 0; u < g[v].length; u++) {\n                if (!g[v][u]) {\n                    continue;\n                }\n                if (pair[u] < 0 || dfs(pair[u], g, was, pair)) {\n                    pair[u] = v;\n                    return true;\n                }\n            }\n            return false;\n        }\n\n    }\n\n    static class FastScanner {\n        private BufferedReader in;\n        private StringTokenizer st;\n\n        public FastScanner(InputStream stream) {\n            in = new BufferedReader(new InputStreamReader(stream));\n        }\n\n        public String next() {\n            while (st == null || !st.hasMoreTokens()) {\n                try {\n                    st = new StringTokenizer(in.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return st.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.StringTokenizer;\nimport java.io.BufferedReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        FastScanner in = new FastScanner(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskF solver = new TaskF();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskF {\n        public void solve(int testNumber, FastScanner in, PrintWriter out) {\n            int n = in.nextInt();\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++) {\n                a[i] = in.nextInt();\n            }\n\n            List<Integer> b = new ArrayList<>();\n            {\n                int l = -1;\n                int r = -1;\n                for (int x : a) {\n                    if (x == r + 1) {\n                        ++r;\n                    } else {\n                        if (l >= 0) {\n                            b.add(l);\n                            b.add(r + 1);\n                        }\n                        l = x;\n                        r = x;\n                    }\n                }\n                if (l >= 0) {\n                    b.add(l);\n                    b.add(r + 1);\n                }\n            }\n\n            List<Integer> even = new ArrayList<>();\n            List<Integer> odd = new ArrayList<>();\n            for (int x : b) {\n                if (x % 2 == 0) {\n                    even.add(x);\n                } else {\n                    odd.add(x);\n                }\n            }\n            boolean[][] g = new boolean[even.size()][odd.size()];\n            for (int i = 0; i < even.size(); i++) {\n                for (int j = 0; j < odd.size(); j++) {\n                    if (f(Math.abs(even.get(i) - odd.get(j))) == 1) {\n                        g[i][j] = true;\n                    }\n                }\n            }\n            int k = matching(g);\n            if (b.size() % 2 != 0) {\n                throw new AssertionError();\n            }\n            int ans = k;\n            ans += ((even.size() - k) / 2) * 2;\n            ans += ((odd.size() - k) / 2) * 2;\n            if ((even.size() - k) % 2 != 0) {\n                ans += 3;\n            }\n            out.println(ans);\n        }\n\n        private int f(int len) {\n            if (len < 1) {\n                return 0;\n            }\n            if (len == 1) {\n                return 3;\n            }\n            if (len % 2 == 0) {\n                return 2;\n            }\n            for (int d = 3; d * d <= len; d += 2) {\n                if (len % d == 0) {\n                    return 3;\n                }\n            }\n            return 1;\n        }\n\n        private int matching(boolean[][] g) {\n            int n = g.length;\n            int m = g[0].length;\n            int[] pair = new int[m];\n            Arrays.fill(pair, -1);\n            int res = 0;\n            boolean[] was = new boolean[n];\n            for (int i = 0; i < n; i++) {\n                Arrays.fill(was, false);\n                if (dfs(i, g, was, pair)) {\n                    ++res;\n                }\n            }\n            return res;\n        }\n\n        private boolean dfs(int v, boolean[][] g, boolean[] was, int[] pair) {\n            if (was[v]) {\n                return false;\n            }\n            was[v] = true;\n            for (int u = 0; u < g[v].length; u++) {\n                if (!g[v][u]) {\n                    continue;\n                }\n                if (pair[u] < 0 || dfs(pair[u], g, was, pair)) {\n                    pair[u] = v;\n                    return true;\n                }\n            }\n            return false;\n        }\n\n    }\n\n    static class FastScanner {\n        private BufferedReader in;\n        private StringTokenizer st;\n\n        public FastScanner(InputStream stream) {\n            in = new BufferedReader(new InputStreamReader(stream));\n        }\n\n        public String next() {\n            while (st == null || !st.hasMoreTokens()) {\n                try {\n                    st = new StringTokenizer(in.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return st.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "// package arc.arc080;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\nimport java.util.List;\n\npublic class Main {\n    public static void main(String[] args) {\n        InputReader in = new InputReader(System.in);\n        PrintWriter out = new PrintWriter(System.out);\n\n        int n = in.nextInt();\n        int[] a = new int[n];\n        for (int i = 0; i < n ; i++) {\n            a[i] = in.nextInt();\n        }\n\n        List<Integer> even = new ArrayList<>();\n        List<Integer> odd = new ArrayList<>();\n        for (int i = 0 ; i < n ; i++) {\n            if (i >= 1 && a[i-1] + 1 == a[i]) {\n                // same\n            } else {\n                if (a[i] % 2 == 1) {\n                    odd.add(a[i]);\n                } else {\n                    even.add(a[i]);\n                }\n            }\n            if (i+1 == n || a[i] + 1 < a[i+1]) {\n                if (a[i] % 2 == 1) {\n                    even.add(a[i]+1);\n                } else {\n                    odd.add(a[i]+1);\n                }\n            }\n        }\n\n        int nodes = even.size() + odd.size() + 2;\n        int source = nodes - 2;\n        int sink = source + 1;\n        MaxFlowDinic dinic = new MaxFlowDinic();\n        dinic.init(nodes);\n        for (int i = 0; i < even.size() ; i++) {\n            dinic.edge(source, i, 1);\n        }\n        for (int i = 0; i < odd.size() ; i++) {\n            dinic.edge(even.size() + i, sink, 1);\n        }\n\n        boolean[] isp = generatePrimes(10000010);\n        for (int i = 0; i < even.size() ; i++) {\n            for (int j = 0; j < odd.size(); j++) {\n                int diff = Math.abs(even.get(i) - odd.get(j));\n                if (isp[diff]) {\n                    dinic.edge(i, even.size() + j, 1);\n                }\n            }\n        }\n\n        int flow = dinic.max_flow(source, sink);\n        int evenLeft = even.size() - flow;\n        int oddLeft = odd.size() - flow;\n\n        int ans = flow + ((evenLeft / 2) + (oddLeft / 2)) * 2 + ((evenLeft % 2 == 1) ? 3 : 0);\n        out.println(ans);\n        out.flush();\n    }\n\n    public static class MaxFlowDinic {\n        public List<int[]>[] graph;\n        public int[] deg;\n\n        public int[] level;\n        public int[] itr;\n\n        public int[] que;\n\n        @SuppressWarnings(\"unchecked\")\n        public void init(int size) {\n            graph = new List[size];\n            for (int i = 0; i < size ; i++) {\n                graph[i] = new ArrayList<int[]>();\n            }\n            deg = new int[size];\n            level = new int[size];\n            itr = new int[size];\n            que = new int[size+10];\n        }\n        public void edge(int from, int to, int cap) {\n            int fdeg = deg[from];\n            int tdeg = deg[to];\n            graph[from].add(new int[]{to, cap, tdeg});\n            graph[to].add(new int[]{from, 0, fdeg});\n            deg[from]++;\n            deg[to]++;\n        }\n\n        public int dfs(int v, int t, int f) {\n            if (v == t) return f;\n            for (int i = itr[v] ; i < graph[v].size() ; i++) {\n                itr[v] = i;\n                int[] e = graph[v].get(i);\n                if (e[1] > 0 && level[v] < level[e[0]]) {\n                    int d = dfs(e[0], t, Math.min(f, e[1]));\n                    if (d > 0) {\n                        e[1] -= d;\n                        graph[e[0]].get(e[2])[1] += d;\n                        return d;\n                    }\n                }\n            }\n            return 0;\n        }\n\n        public void bfs(int s) {\n            Arrays.fill(level, -1);\n            int qh = 0;\n            int qt = 0;\n            level[s] = 0;\n            que[qh++] = s;\n            while (qt < qh) {\n                int v = que[qt++];\n                for (int i = 0; i < graph[v].size() ; i++) {\n                    int[] e = graph[v].get(i);\n                    if (e[1] > 0 && level[e[0]] < 0) {\n                        level[e[0]] = level[v] + 1;\n                        que[qh++] = e[0];\n                    }\n                }\n            }\n        }\n\n        public int max_flow(int s, int t) {\n            int flow = 0;\n            while (true) {\n                bfs(s);\n                if (level[t] < 0) {\n                    return flow;\n                }\n                Arrays.fill(itr, 0);\n                while (true) {\n                    int f = dfs(s, t, Integer.MAX_VALUE);\n                    if (f <= 0) {\n                        break;\n                    }\n                    flow += f;\n                }\n            }\n        }\n    }\n\n    /**\n     * Generates primes less than upto.\n     *\n     * O(nlog(logn))\n     *\n     * @param upto limit\n     * @return array of primes\n     */\n    static boolean[] generatePrimes(int upto) {\n        boolean[] isp = new boolean[upto];\n        Arrays.fill(isp, true);\n        isp[0] = isp[1] = false;\n\n        int pi = 0;\n        for (int i = 2; i < upto ; i++) {\n            if (isp[i]) {\n                pi++;\n                for (int j = i * 2; j < upto; j += i) {\n                    isp[j] = false;\n                }\n            }\n        }\n\n        return isp;\n    }\n\n    public static void debug(Object... o) {\n        System.err.println(Arrays.deepToString(o));\n    }\n\n    public static class InputReader {\n        private static final int BUFFER_LENGTH = 1 << 12;\n        private InputStream stream;\n        private byte[] buf = new byte[BUFFER_LENGTH];\n        private int curChar;\n        private int numChars;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        private int next() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0)\n                    return -1;\n            }\n            return buf[curChar++];\n        }\n\n        public char nextChar() {\n            return (char) skipWhileSpace();\n        }\n\n        public String nextToken() {\n            int c = skipWhileSpace();\n            StringBuilder res = new StringBuilder();\n            do {\n                res.append((char) c);\n                c = next();\n            } while (!isSpaceChar(c));\n            return res.toString();\n        }\n\n        public int nextInt() {\n            return (int) nextLong();\n        }\n\n        public long nextLong() {\n            int c = skipWhileSpace();\n            long sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = next();\n            }\n            long res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = next();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public double nextDouble() {\n            return Double.valueOf(nextToken());\n        }\n\n        int skipWhileSpace() {\n            int c = next();\n            while (isSpaceChar(c)) {\n                c = next();\n            }\n            return c;\n        }\n\n        boolean isSpaceChar(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.util.Arrays;\nimport java.io.IOException;\nimport java.util.Random;\nimport java.util.ArrayList;\nimport java.io.UncheckedIOException;\nimport java.util.List;\nimport java.io.Closeable;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in Actual solution is at the top\n * \n * @author daltao\n */\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        Thread thread = new Thread(null, new TaskAdapter(), \"daltao\", 1 << 27);\n        thread.start();\n        thread.join();\n    }\n\n    static class TaskAdapter implements Runnable {\n        @Override\n        public void run() {\n            InputStream inputStream = System.in;\n            OutputStream outputStream = System.out;\n            FastInput in = new FastInput(inputStream);\n            FastOutput out = new FastOutput(outputStream);\n            TaskD solver = new TaskD();\n            solver.solve(1, in, out);\n            out.close();\n        }\n    }\n    static class TaskD {\n        NumberTheory.EulerSieve es = new NumberTheory.EulerSieve(10000000);\n\n        public void solve(int testNumber, FastInput in, FastOutput out) {\n            int n = in.readInt();\n\n            IntList oneList = new IntList();\n            int last = in.readInt();\n            oneList.add(last - 1);\n            for (int i = 1; i < n; i++) {\n                int x = in.readInt();\n                if (x - last != 1) {\n                    oneList.add(last);\n                    oneList.add(x - 1);\n                }\n                last = x;\n            }\n            oneList.add(last);\n\n            oneList.unique();\n\n\n            IntList oddList = new IntList();\n            IntList evenList = new IntList();\n            for (int i = 0; i < oneList.size(); i++) {\n                int v = oneList.get(i);\n                if (v % 2 == 0) {\n                    evenList.add(v);\n                } else {\n                    oddList.add(v);\n                }\n            }\n\n\n            KMAlgo km = new KMAlgo(oddList.size(), evenList.size());\n            for (int i = 0; i < oddList.size(); i++) {\n                for (int j = 0; j < evenList.size(); j++) {\n                    int dist = Math.abs(oddList.get(i) - evenList.get(j));\n                    if (dist > 2 && es.isPrime(dist)) {\n                        km.addEdge(i, j);\n                    }\n                }\n            }\n\n            int match = 0;\n            for (int i = 0; i < oddList.size(); i++) {\n                match += km.matchLeft(i) ? 1 : 0;\n            }\n\n            int ans = match * 1 + (oddList.size() - match) / 2 * 2 + (evenList.size() - match) / 2 * 2\n                            + (oddList.size() - match) % 2 * 3;\n\n            out.println(ans);\n\n        }\n\n    }\n    static class Randomized {\n        static Random random = new Random();\n\n        public static void randomizedArray(int[] data, int from, int to) {\n            to--;\n            for (int i = from; i <= to; i++) {\n                int s = nextInt(i, to);\n                int tmp = data[i];\n                data[i] = data[s];\n                data[s] = tmp;\n            }\n        }\n\n        public static int nextInt(int l, int r) {\n            return random.nextInt(r - l + 1) + l;\n        }\n\n    }\n    static class IntList {\n        private int size;\n        private int cap;\n        private int[] data;\n        private static final int[] EMPTY = new int[0];\n\n        public IntList(int cap) {\n            this.cap = cap;\n            if (cap == 0) {\n                data = EMPTY;\n            } else {\n                data = new int[cap];\n            }\n        }\n\n        public IntList(IntList list) {\n            this.size = list.size;\n            this.cap = list.cap;\n            this.data = Arrays.copyOf(list.data, size);\n        }\n\n        public IntList() {\n            this(0);\n        }\n\n        private void ensureSpace(int need) {\n            int req = size + need;\n            if (req > cap) {\n                while (cap < req) {\n                    cap = Math.max(cap + 10, 2 * cap);\n                }\n                data = Arrays.copyOf(data, cap);\n            }\n        }\n\n        private void checkRange(int i) {\n            if (i < 0 || i >= size) {\n                throw new ArrayIndexOutOfBoundsException();\n            }\n        }\n\n        public int get(int i) {\n            checkRange(i);\n            return data[i];\n        }\n\n        public void add(int x) {\n            ensureSpace(1);\n            data[size++] = x;\n        }\n\n        public void sort() {\n            if (size <= 1) {\n                return;\n            }\n            Randomized.randomizedArray(data, 0, size);\n            Arrays.sort(data, 0, size);\n        }\n\n        public void unique() {\n            if (size <= 1) {\n                return;\n            }\n\n            sort();\n            int wpos = 1;\n            for (int i = 1; i < size; i++) {\n                if (data[i] != data[wpos - 1]) {\n                    data[wpos++] = data[i];\n                }\n            }\n            size = wpos;\n        }\n\n        public int size() {\n            return size;\n        }\n\n        public int[] toArray() {\n            return Arrays.copyOf(data, size);\n        }\n\n        public String toString() {\n            return Arrays.toString(toArray());\n        }\n\n    }\n    static class KMAlgo {\n        KMAlgo.Node[] leftSides;\n        KMAlgo.Node[] rightSides;\n        int version;\n\n        public KMAlgo(int l, int r) {\n            leftSides = new KMAlgo.Node[l];\n            for (int i = 0; i < l; i++) {\n                leftSides[i] = new KMAlgo.Node();\n                leftSides[i].id = i;\n                leftSides[i].leftSide = true;\n            }\n            rightSides = new KMAlgo.Node[r];\n            for (int i = 0; i < r; i++) {\n                rightSides[i] = new KMAlgo.Node();\n                rightSides[i].id = i;\n            }\n        }\n\n        public void addEdge(int lId, int rId) {\n            leftSides[lId].nodes.add(rightSides[rId]);\n            rightSides[rId].nodes.add(leftSides[lId]);\n        }\n\n        private void prepare() {\n            version++;\n        }\n\n        public boolean matchLeft(int id) {\n            if (leftSides[id].partner != null) {\n                return false;\n            }\n            prepare();\n            return findPartner(leftSides[id]);\n        }\n\n        private boolean findPartner(KMAlgo.Node src) {\n            if (src.visited == version) {\n                return false;\n            }\n            src.visited = version;\n            for (KMAlgo.Node node : src.nodes) {\n                if (!tryRelease(node)) {\n                    continue;\n                }\n                node.partner = src;\n                src.partner = node;\n                return true;\n            }\n            return false;\n        }\n\n        private boolean tryRelease(KMAlgo.Node src) {\n            if (src.visited == version) {\n                return false;\n            }\n            src.visited = version;\n            if (src.partner == null) {\n                return true;\n            }\n            if (findPartner(src.partner)) {\n                src.partner = null;\n                return true;\n            }\n            return false;\n        }\n\n        public String toString() {\n            StringBuilder builder = new StringBuilder();\n            for (int i = 0; i < leftSides.length; i++) {\n                if (leftSides[i].partner == null) {\n                    continue;\n                }\n                builder.append(leftSides[i].id).append(\" - \").append(leftSides[i].partner.id).append(\"\\n\");\n            }\n            return builder.toString();\n        }\n\n        public static class Node {\n            List<KMAlgo.Node> nodes = new ArrayList(2);\n            int visited;\n            KMAlgo.Node partner;\n            int id;\n            boolean leftSide;\n\n            public String toString() {\n                return \"\" + id;\n            }\n\n        }\n\n    }\n    static class FastOutput implements AutoCloseable, Closeable {\n        private StringBuilder cache = new StringBuilder(10 << 20);\n        private final Writer os;\n\n        public FastOutput(Writer os) {\n            this.os = os;\n        }\n\n        public FastOutput(OutputStream os) {\n            this(new OutputStreamWriter(os));\n        }\n\n        public FastOutput println(int c) {\n            cache.append(c).append('\\n');\n            return this;\n        }\n\n        public FastOutput flush() {\n            try {\n                os.append(cache);\n                os.flush();\n                cache.setLength(0);\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n            return this;\n        }\n\n        public void close() {\n            flush();\n            try {\n                os.close();\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n        }\n\n    }\n    static class NumberTheory {\n        public static class EulerSieve {\n            private int[] primes;\n            private boolean[] isComp;\n            private int primeLength;\n\n            public boolean isPrime(int x) {\n                if (x == 1) {\n                    return false;\n                }\n                return !isComp[x];\n            }\n\n            public EulerSieve(int limit) {\n                isComp = new boolean[limit + 1];\n                primes = new int[limit + 1];\n                primeLength = 0;\n                for (int i = 2; i <= limit; i++) {\n                    if (!isComp[i]) {\n                        primes[primeLength++] = i;\n                    }\n                    for (int j = 0, until = limit / i; j < primeLength && primes[j] <= until; j++) {\n                        int pi = primes[j] * i;\n                        isComp[pi] = true;\n                        if (i % primes[j] == 0) {\n                            break;\n                        }\n                    }\n                }\n            }\n\n        }\n\n    }\n    static class FastInput {\n        private final InputStream is;\n        private byte[] buf = new byte[1 << 13];\n        private int bufLen;\n        private int bufOffset;\n        private int next;\n\n        public FastInput(InputStream is) {\n            this.is = is;\n        }\n\n        private int read() {\n            while (bufLen == bufOffset) {\n                bufOffset = 0;\n                try {\n                    bufLen = is.read(buf);\n                } catch (IOException e) {\n                    bufLen = -1;\n                }\n                if (bufLen == -1) {\n                    return -1;\n                }\n            }\n            return buf[bufOffset++];\n        }\n\n        public void skipBlank() {\n            while (next >= 0 && next <= 32) {\n                next = read();\n            }\n        }\n\n        public int readInt() {\n            int sign = 1;\n\n            skipBlank();\n            if (next == '+' || next == '-') {\n                sign = next == '+' ? 1 : -1;\n                next = read();\n            }\n\n            int val = 0;\n            if (sign == 1) {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 + next - '0';\n                    next = read();\n                }\n            } else {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 - next + '0';\n                    next = read();\n                }\n            }\n\n            return val;\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\t// long t = System.currentTimeMillis();\n\t\tnew Main().run();\n\t\t// System.err.println(System.currentTimeMillis() - t);\n\t}\n\n\tint min_cost_flow(int s, int t, ArrayList<Edge>[] g) {\n\t\tclass Vertice implements Comparable<Vertice> {\n\t\t\tint id;\n\t\t\tlong dist;\n\n\t\t\tpublic Vertice(int id, long dist) {\n\t\t\t\tthis.id = id;\n\t\t\t\tthis.dist = dist;\n\t\t\t}\n\n\t\t\tpublic int compareTo(Vertice o) {\n\t\t\t\treturn Long.compare(this.dist, o.dist);\n\t\t\t};\n\t\t}\n\n\t\tint n = g.length;\n\n\t\tint min_cost = 0;\n\t\tg[t].add(new Edge(t, s, (1 << 30), 0));\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < g[i].size(); j++) {\n\t\t\t\tEdge e = g[i].get(j);\n\t\t\t\tg[e.src].get(j).rev_id = g[e.dst].size();\n\t\t\t\tg[e.dst].add(new Edge(e.dst, e.src, 0, -e.cost));\n\t\t\t\tg[e.dst].get(g[e.dst].size() - 1).rev_id = j;\n\t\t\t}\n\t\t}\n\n\t\tlong[] potential = new long[n];\n\t\tint[] excess = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (Edge e : g[i]) {\n\t\t\t\tif (e.cost < 0) {\n\t\t\t\t\te.add_flow(e.cap);\n\t\t\t\t\texcess[e.dst] += e.flow;\n\t\t\t\t\texcess[e.src] -= e.flow;\n\t\t\t\t\tg[e.dst].get(e.rev_id).add_flow(-e.cap);\n\t\t\t\t\tmin_cost += e.cost * e.flow;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tArrayList<Integer> sink_v = new ArrayList<>();\n\t\tArrayDeque<Integer> source_v = new ArrayDeque<>();\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (excess[i] < 0)\n\t\t\t\tsink_v.add(i);\n\t\t\telse if (excess[i] > 0)\n\t\t\t\tsource_v.add(i);\n\t\t}\n\t\twhile (!source_v.isEmpty()) {\n\n\t\t\tPriorityQueue<Vertice> priority_queue = new PriorityQueue<>();\n\t\t\tint[] pre_v = new int[n];\n\t\t\tint[] pre_e = new int[n];\n\t\t\tlong[] dist = new long[n];\n\t\t\tArrays.fill(pre_v, -1);\n\t\t\tArrays.fill(pre_e, -1);\n\t\t\tArrays.fill(dist, 1L << 60);\n\t\t\tint source = source_v.poll();\n\t\t\tdist[source] = 0;\n\t\t\tpre_v[source] = -1;\n\t\t\tpre_e[source] = -1;\n\t\t\tboolean[] looked = new boolean[n];\n\n\t\t\tpriority_queue.add(new Vertice(source, 0));\n\n\t\t\twhile (!priority_queue.isEmpty()) {\n\t\t\t\tint v = priority_queue.poll().id;\n\t\t\t\tif (looked[v])\n\t\t\t\t\tcontinue;\n\t\t\t\telse\n\t\t\t\t\tlooked[v] = true;\n\t\t\t\tfor (int i = 0; i < g[v].size(); i++) {\n\t\t\t\t\tEdge e = g[v].get(i);\n\t\t\t\t\tif (e.residue > 0) {\n\t\t\t\t\t\tif (dist[e.dst] > dist[v] + e.cost - potential[v] + potential[e.dst]) {\n\t\t\t\t\t\t\tdist[e.dst] = dist[v] + e.cost - potential[v] + potential[e.dst];\n\n\t\t\t\t\t\t\tpriority_queue.add(new Vertice(e.dst, dist[e.dst]));\n\t\t\t\t\t\t\tpre_v[e.dst] = v;\n\t\t\t\t\t\t\tpre_e[e.dst] = i;\n\t\t\t\t\t\t\tlooked[e.dst] = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint sink = -1;\n\t\t\tfor (int i = 0; i < sink_v.size(); i++) {\n\t\t\t\tif (pre_v[sink_v.get(i)] != -1) {\n\t\t\t\t\tsink = sink_v.get(i);\n\t\t\t\t\tsink_v.remove(i);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (sink == -1) {\n\t\t\t\tsource_v.add(source);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tif (dist[i] < (1L << 60))\n\t\t\t\t\tpotential[i] -= dist[i];\n\t\t\t\telse\n\t\t\t\t\tpotential[i] -= (1 << 30);\n\t\t\t}\n\n\t\t\tint delta = Math.min(Math.abs(excess[source]), Math.abs(excess[sink]));\n\n\t\t\tfor (int i = sink; i != source; i = pre_v[i]) {\n\t\t\t\tdelta = Math.min(delta, g[pre_v[i]].get(pre_e[i]).residue);\n\t\t\t}\n\t\t\tfor (int i = sink; i != source; i = pre_v[i]) {\n\t\t\t\tEdge e = g[pre_v[i]].get(pre_e[i]);\n\t\t\t\te.add_flow(delta);\n\t\t\t\tg[i].get(e.rev_id).add_flow(-delta);\n\t\t\t\tmin_cost += delta * e.cost;\n\t\t\t}\n\t\t\texcess[sink] += delta;\n\t\t\texcess[source] -= delta;\n\t\t\tif (excess[sink] < 0)\n\t\t\t\tsink_v.add(sink);\n\t\t\tif (excess[source] > 0)\n\t\t\t\tsource_v.add(source);\n\n\t\t}\n\n\t\treturn min_cost;\n\t}\n\n\tclass Edge {\n\t\tint src;\n\t\tint dst;\n\t\tint cap;\n\t\tint cost;\n\t\tint residue;\n\t\tint flow = 0;\n\t\tint rev_id = -1;\n\n\t\tEdge(int src, int dst, int cap, int cost) {\n\t\t\tthis.src = src;\n\t\t\tthis.dst = dst;\n\t\t\tthis.cap = cap;\n\t\t\tthis.cost = cost;\n\t\t\tresidue = this.cap - flow;\n\t\t}\n\n\t\tvoid add_flow(int flow) {\n\t\t\tthis.flow += flow;\n\t\t\tresidue = cap - this.flow;\n\t\t}\n\n\t}\n\n\tboolean[] isPrime = new boolean[1_000_000_3];\n\t{\n\t\tArrays.fill(isPrime, true);\n\t\tisPrime[0] = false;\n\t\tisPrime[1] = false;\n\t\tfor (int i = 2; i < isPrime.length; ++i) {\n\t\t\tif (isPrime[i]) {\n\t\t\t\tfor (int j = 2 * i; j < isPrime.length; j += i) {\n\t\t\t\t\tisPrime[j] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tisPrime[2] = false;\n\t}\n\n\tvoid solve(int n, int[] x) {\n\t\tArrayList<Integer> list = new ArrayList<>();\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tint j = i;\n\t\t\twhile (j + 1 < n && x[j] + 1 == x[j + 1]) {\n\t\t\t\t++j;\n\t\t\t}\n\t\t\tlist.add(x[i]);\n\t\t\tlist.add(x[j] + 1);\n\t\t\ti = j;\n\t\t}\n\t\tx = new int[list.size()];\n\t\tint even = 0, odd = 0;\n\t\tfor (int i = 0; i < x.length; ++i) {\n\t\t\tx[i] = list.get(i);\n\t\t\tif (x[i] % 2 == 0)\n\t\t\t\t++even;\n\t\t\telse\n\t\t\t\t++odd;\n\t\t}\n\t\tArrayList<Edge>[] g = new ArrayList[list.size() + 2];\n\t\tfor (int i = 0; i < g.length; ++i) {\n\t\t\tg[i] = new ArrayList<>();\n\t\t}\n\t\tint src = g.length - 2;\n\t\tint dst = g.length - 1;\n\t\tfor (int i = 0; i < x.length; i++) {\n\t\t\tfor (int j = 0; j < x.length; j++) {\n\t\t\t\tif (x[i] % 2 == 0 && x[j] % 2 == 1 && isPrime[Math.abs(x[i] - x[j])])\n\t\t\t\t\tg[i].add(new Edge(i, j, 1, -1));\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < list.size(); ++i) {\n\t\t\tif (x[i] % 2 == 0)\n\t\t\t\tg[src].add(new Edge(src, i, 1, 0));\n\t\t\telse\n\t\t\t\tg[i].add(new Edge(i, dst, 1, 0));\n\t\t}\n\t\tint ret = 0;\n\t\tint c = -min_cost_flow(src, dst, g);\n\t\tret = c + (even - c) / 2 * 2 + (odd - c) / 2 * 2;\n\t\tif ((even - c) % 2 == 1)\n\t\t\tret += 3;\n\t\tSystem.out.println(ret);\n\t}\n\n\tpublic void run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint[] x = new int[n];\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tx[i] = sc.nextInt();\n\t\t}\n\t\tsolve(n, x);\n\t}\n\n\tstatic void tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\n\npublic class Main {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\t\n\tstatic void solve()\n\t{\n\t\tint n = ni();\n\t\tint[] a = na(n);\n\t\tint[] b = new int[2*n];\n\t\tint p = 0;\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tb[p++] = a[i];\n\t\t\tb[p++] = a[i]+1;\n\t\t}\n\t\tint q = 0;\n\t\tfor(int i = 0;i < 2*n;i++){\n\t\t\tif(i+1 < 2*n && b[i] == b[i+1]){\n\t\t\t\ti++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tb[q++] = b[i];\n\t\t}\n\t\tb = Arrays.copyOf(b, q);\n\t\t\n\t\tint pe = 0, po = 0;\n\t\tint[] be = new int[q];\n\t\tint[] bo = new int[q];\n\t\tfor(int v : b){\n\t\t\tif(v % 2 == 0){\n\t\t\t\tbe[pe++] = v;\n\t\t\t}else{\n\t\t\t\tbo[po++] = v;\n\t\t\t}\n\t\t}\n\t\tbe = Arrays.copyOf(be, pe);\n\t\tbo = Arrays.copyOf(bo, po);\n\t\t\n\t\tlong[] isp = isp(11000000);\n\t\tboolean[][] g = new boolean[pe][po];\n\t\tfor(int i = 0;i < pe;i++){\n\t\t\tfor(int j = 0;j < po;j++){\n\t\t\t\tint s = Math.abs(be[i] - bo[j]);\n\t\t\t\tif(isp[s>>>6]<<~s<0){\n\t\t\t\t\tg[i][j] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint F = doBipartiteMatchingHK(g);\n\t\tout.println(F + (pe-F)/2*2 + (po-F)/2*2 + ((pe-F)%2 == 1 ? 3 : 0));\n\t}\n\t\n\tpublic static int doBipartiteMatchingHK(boolean[][] g)\n\t{\n\t\tint n = g.length;\n\t\tif(n == 0)return 0;\n\t\tint m = g[0].length;\n\t\tint[] from = new int[m];\n\t\tint[] to = new int[n];\n\t\tArrays.fill(to, -1);\n\t\tArrays.fill(from, n);\n\t\t\n\t\tint[] d = new int[n+1];\n\t\tint mat = 0;\n\t\twhile(true){\n\t\t\tArrays.fill(d, -1);\n\t\t\tint[] q = new int[n];\n\t\t\tint r = 0;\n\t\t\tfor(int i = 0;i < n;i++){\n\t\t\t\tif(to[i] == -1){\n\t\t\t\t\td[i] = 0;\n\t\t\t\t\tq[r++] = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor(int p = 0;p < r;p++) {\n\t\t\t\tint cur = q[p];\n\t\t\t\tfor(int adj = 0;adj < m;adj++){\n\t\t\t\t\tif(g[cur][adj]){\n\t\t\t\t\t\tint nex = from[adj];\n\t\t\t\t\t\tif(d[nex] == -1) {\n\t\t\t\t\t\t\tif(nex != n)q[r++] = nex;\n\t\t\t\t\t\t\td[nex] = d[cur] + 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(d[n] == -1)break;\n\t\t\t\n\t\t\tfor(int i = 0;i < n;i++){\n\t\t\t\tif(to[i] == -1){\n\t\t\t\t\tif(dfsHK(d, g, n, m, to, from, i))mat++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn mat;\n\t}\n\t\n\tstatic boolean dfsHK(int[] d, boolean[][] g, int n, int m, int[] to, int[] from, int cur)\n\t{\n\t\tif(cur == n)return true;\n\t\tfor(int adj = 0;adj < m;adj++){\n\t\t\tif(g[cur][adj]){\n\t\t\t\tint nex = from[adj];\n\t\t\t\tif(d[nex] == d[cur] + 1 && dfsHK(d, g, n, m, to, from, nex)){\n\t\t\t\t\tto[cur] = adj;\n\t\t\t\t\tfrom[adj] = cur;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\td[cur] = -1;\n\t\treturn false;\n\t}\n\n\t\n\t\n\t\n\t\n\tpublic static long[] isp(int n)\n\t{\n\t\tint[] tprimes = {2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61};\n\t\tif(n <= 64){\n\t\t\tlong ptn = 0;\n\t\t\tfor(int p : tprimes)if(p <= n)ptn |= 1L<<p;\n\t\t\treturn new long[]{ptn};\n\t\t}\n\t\t\n\t\tlong[] isnp = new long[(n+1)/64+1];\n\t\tint sup = (n+1)/64+1;\n\t\t\n\t\tisnp[0] |= 1<<1;\n\t\tfor(int tp : tprimes){\n\t\t\tlong[] ptn = new long[tp];\n\t\t\tfor(int i = 0;i < tp<<6;i+=tp)ptn[i>>>6] |= 1L<<i;\n\t\t\tfor(int j = 0;j < sup;j += tp){\n\t\t\t\tfor(int i = 0;i < tp && i+j < sup;i++){\n\t\t\t\t\tisnp[j+i] |= ptn[i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfinal int[] magic = {0, 1, 2, 53, 3, 7, 54, 27, 4, 38, 41, 8, 34, 55, 48, 28, 62, 5, 39, 46, 44, 42, 22, 9, 24, 35, 59, 56, 49, 18, 29, 11, 63, 52, 6, 26, 37, 40, 33, 47, 61, 45, 43, 21, 23, 58, 17, 10, 51, 25, 36, 32,\n\t              60, 20, 57, 16, 50, 31, 19, 15, 30, 14, 13, 12};\n\t\tout:\n\t\tfor(int i = 0;i < sup;i++){\n\t\t\tfor(long j = ~isnp[i];j != 0;j &= j-1){\n\t\t\t\tint p = i<<6|magic[(int)((j&-j)*0x022fdd63cc95386dL>>>58)];\n\t\t\t\tif((long)p*p > n)break out;\n\t\t\t\tfor(int q = p*p;q <= n;q += p)isnp[q>>6] |= 1L<<q;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i = 0;i < isnp.length;i++)isnp[i] = ~isnp[i];\n\t\tfor(int tp : tprimes)isnp[0] |= 1L<<tp;\n\t\tisnp[isnp.length-1] &= (1L<<n+1)-1;\n\t\t\n\t\treturn isnp;\n\t}\n\n\t\n\tpublic static void main(String[] args) throws Exception\n\t{\n\t\tlong S = System.currentTimeMillis();\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\t\n\t\tsolve();\n\t\tout.flush();\n\t\tlong G = System.currentTimeMillis();\n\t\ttr(G-S+\"ms\");\n\t}\n\t\n\tprivate static boolean eof()\n\t{\n\t\tif(lenbuf == -1)return true;\n\t\tint lptr = ptrbuf;\n\t\twhile(lptr < lenbuf)if(!isSpaceChar(inbuf[lptr++]))return false;\n\t\t\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\twhile(true){\n\t\t\t\tint b = is.read();\n\t\t\t\tif(b == -1){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn true;\n\t\t\t\t}else if(!isSpaceChar(b)){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\tprivate static byte[] inbuf = new byte[1024];\n\tstatic int lenbuf = 0, ptrbuf = 0;\n\t\n\tprivate static int readByte()\n\t{\n\t\tif(lenbuf == -1)throw new InputMismatchException();\n\t\tif(ptrbuf >= lenbuf){\n\t\t\tptrbuf = 0;\n\t\t\ttry { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n\t\t\tif(lenbuf <= 0)return -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\t\n\tprivate static boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n//\tprivate static boolean isSpaceChar(int c) { return !(c >= 32 && c <= 126); }\n\tprivate static int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n\t\n\tprivate static double nd() { return Double.parseDouble(ns()); }\n\tprivate static char nc() { return (char)skip(); }\n\t\n\tprivate static String ns()\n\t{\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile(!(isSpaceChar(b))){\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\t\n\tprivate static char[] ns(int n)\n\t{\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile(p < n && !(isSpaceChar(b))){\n\t\t\tbuf[p++] = (char)b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\t\n\tprivate static char[][] nm(int n, int m)\n\t{\n\t\tchar[][] map = new char[n][];\n\t\tfor(int i = 0;i < n;i++)map[i] = ns(m);\n\t\treturn map;\n\t}\n\t\n\tprivate static int[] na(int n)\n\t{\n\t\tint[] a = new int[n];\n\t\tfor(int i = 0;i < n;i++)a[i] = ni();\n\t\treturn a;\n\t}\n\t\n\tprivate static int ni()\n\t{\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static long nl()\n\t{\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static void tr(Object... o) { if(INPUT.length() != 0)System.out.println(Arrays.deepToString(o)); }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n\n\tboolean dfs(int v, int[] pair, boolean[] vis, boolean[][] g) {\n\t\tvis[v] = true;\n\t\tfor (int u = 0; u < g[v].length; u++) {\n\t\t\tif (!g[v][u]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (pair[u] == -1 || (!vis[pair[u]] && dfs(u, pair, vis, g))) {\n\t\t\t\tpair[u] = v;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\t\n\tvoid submit() {\n\t\tint n = nextInt();\n\t\tint[] xs = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\txs[i] = nextInt();\n\t\t}\n\t\t\n\t\tTreeSet<Integer> init = new TreeSet<>();\n\t\t\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (i == 0 || (xs[i - 1] != xs[i] - 1)) {\n\t\t\t\tinit.add(xs[i] - 1);\n\t\t\t}\n\t\t\tif (i == n - 1 || (xs[i + 1] != xs[i] + 1)) {\n\t\t\t\tinit.add(xs[i]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tboolean[] isPrime = new boolean[10_000_001];\n\t\tArrays.fill(isPrime, true);\n\t\tisPrime[0] = isPrime[1] = false;\n\t\t\n\t\tfor (int i = 2; i * i < isPrime.length; i++) {\n\t\t\tif (isPrime[i]) {\n\t\t\t\tfor (int j = i * i; j < isPrime.length; j += i) {\n\t\t\t\t\tisPrime[j] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tList<Integer>[] byPar = new ArrayList[2];\n\t\tbyPar[0] = new ArrayList<>();\n\t\tbyPar[1] = new ArrayList<>();\n\t\t\n\t\tfor (int x : init) {\n\t\t\tbyPar[x % 2].add(x);\n\t\t}\n\t\t\n\t\tboolean[][] g = new boolean[byPar[0].size()][byPar[1].size()];\n\t\tfor (int i = 0; i < byPar[0].size(); i++) {\n\t\t\tint x = byPar[0].get(i);\n\t\t\tfor (int j = 0; j < byPar[1].size(); j++) {\n\t\t\t\tint y = byPar[1].get(j);\n\t\t\t\t\n\t\t\t\tg[i][j] = isPrime[Math.abs(x - y)];\n\t\t\t}\n\t\t}\n\t\t\n\t\tint[] pair = new int[byPar[1].size()];\n\t\tArrays.fill(pair, -1);\n\t\tboolean[] vis = new boolean[byPar[0].size()];\n\t\t\n\t\tint match = 0;\n\t\tfor (int i = 0; i < g.length; i++) {\n\t\t\tArrays.fill(vis, false);\n\t\t\tif (dfs(i, pair, vis, g)) {\n\t\t\t\tmatch++;\n\t\t\t}\n\t\t}\n\t\t\n\t\tint part1 = byPar[0].size();\n\t\tint part2 = byPar[1].size();\n\t\t\n\t\tint ans = match + go(part1 - match, part2 - match);\n\t\tif (match > 0) {\n\t\t\tmatch--;\n\t\t\tans = Math.min(ans, match + go(part1 - match, part2 - match));\n\t\t}\n\t\t\n\t\tout.println(ans);\n\t}\n\t\n\tint go(int x, int y) {\n\t\tif ((x % 2) != (y % 2)) {\n\t\t\tthrow new AssertionError();\n\t\t}\n\t\tif (x % 2 == 0) {\n\t\t\treturn x + y;\n\t\t} else {\n\t\t\treturn x + y + 1;\n\t\t}\n\t}\n\n\tvoid preCalc() {\n\n\t}\n\n\tvoid stress() {\n\n\t}\n\n\tvoid test() {\n\n\t}\n\n\tMain() throws IOException {\n\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\tout = new PrintWriter(System.out);\n\t\tpreCalc();\n\t\tsubmit();\n\t\t//stress();\n\t\t//test();\n\t\tout.close();\n\t}\n\n\tstatic final Random rng = new Random();\n\n\tstatic int rand(int l, int r) {\n\t\treturn l + rng.nextInt(r - l + 1);\n\t}\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tnew Main();\n\t}\n\n\tBufferedReader br;\n\tPrintWriter out;\n\tStringTokenizer st;\n\n\tString nextToken() {\n\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\ttry {\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new RuntimeException(e);\n\t\t\t}\n\t\t}\n\t\treturn st.nextToken();\n\t}\n\n\tString nextString() {\n\t\ttry {\n\t\t\treturn br.readLine();\n\t\t} catch (IOException e) {\n\t\t\tthrow new RuntimeException(e);\n\t\t}\n\t}\n\n\tint nextInt() {\n\t\treturn Integer.parseInt(nextToken());\n\t}\n\n\tlong nextLong() {\n\t\treturn Long.parseLong(nextToken());\n\t}\n\n\tdouble nextDouble() {\n\t\treturn Double.parseDouble(nextToken());\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n\n\tboolean dfs(int v, int[] pair, boolean[] vis, boolean[][] g) {\n\t\tvis[v] = true;\n\t\tfor (int u = 0; u < g[v].length; u++) {\n\t\t\tif (!g[v][u]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (pair[u] == -1 || (!vis[pair[u]] && dfs(pair[u], pair, vis, g))) {\n\t\t\t\tpair[u] = v;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tvoid submit() {\n\t\t int n = nextInt();\n\t\t int[] xs = new int[n];\n\t\t for (int i = 0; i < n; i++) {\n\t\t xs[i] = nextInt();\n\t\t }\n\n//\t\tint n = 100;\n//\t\tint[] xs = new int[n];\n//\t\tfor (int i = 0; i < n; i++) {\n//\t\t\txs[i] = 2 * i + 1;\n//\t\t}\n\n\t\tTreeSet<Integer> init = new TreeSet<>();\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (i == 0 || (xs[i - 1] != xs[i] - 1)) {\n\t\t\t\tinit.add(xs[i] - 1);\n\t\t\t}\n\t\t\tif (i == n - 1 || (xs[i + 1] != xs[i] + 1)) {\n\t\t\t\tinit.add(xs[i]);\n\t\t\t}\n\t\t}\n\n\t\t// System.err.println(init);\n\n\t\tboolean[] isPrime = new boolean[10_000_001];\n\t\tArrays.fill(isPrime, true);\n\t\tisPrime[0] = isPrime[1] = false;\n\n\t\tfor (int i = 2; i * i < isPrime.length; i++) {\n\t\t\tif (isPrime[i]) {\n\t\t\t\tfor (int j = i * i; j < isPrime.length; j += i) {\n\t\t\t\t\tisPrime[j] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tList<Integer>[] byPar = new ArrayList[2];\n\t\tbyPar[0] = new ArrayList<>();\n\t\tbyPar[1] = new ArrayList<>();\n\n\t\tfor (int x : init) {\n\t\t\tbyPar[x % 2].add(x);\n\t\t}\n\n\t\tboolean[][] g = new boolean[byPar[0].size()][byPar[1].size()];\n\t\tfor (int i = 0; i < byPar[0].size(); i++) {\n\t\t\tint x = byPar[0].get(i);\n\t\t\tfor (int j = 0; j < byPar[1].size(); j++) {\n\t\t\t\tint y = byPar[1].get(j);\n\n\t\t\t\tg[i][j] = isPrime[Math.abs(x - y)];\n\t\t\t}\n\t\t}\n\n\t\tint[] pair = new int[byPar[1].size()];\n\t\tArrays.fill(pair, -1);\n\t\tboolean[] vis = new boolean[byPar[0].size()];\n\n\t\tint match = 0;\n\t\tfor (int i = 0; i < g.length; i++) {\n\t\t\tArrays.fill(vis, false);\n\t\t\tif (dfs(i, pair, vis, g)) {\n\t\t\t\tmatch++;\n\t\t\t}\n\t\t}\n\n\t\tint part1 = byPar[0].size();\n\t\tint part2 = byPar[1].size();\n\n\t\tint ans = match + go(part1 - match, part2 - match);\n\t\tif (match > 0) {\n\t\t\tmatch--;\n\t\t\tans = Math.min(ans, match + go(part1 - match, part2 - match));\n\t\t}\n\n\t\tout.println(ans);\n\t}\n\n\tint go(int x, int y) {\n\t\tif ((x % 2) != (y % 2)) {\n\t\t\tthrow new AssertionError();\n\t\t}\n\t\tif (x % 2 == 0) {\n\t\t\treturn x + y;\n\t\t} else {\n\t\t\treturn x + y + 1;\n\t\t}\n\t}\n\n\tvoid preCalc() {\n\n\t}\n\n\tvoid stress() {\n\n\t}\n\n\tvoid test() {\n\n\t}\n\n\tMain() throws IOException {\n\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\tout = new PrintWriter(System.out);\n\t\tpreCalc();\n\t\tsubmit();\n\t\t// stress();\n\t\t// test();\n\t\tout.close();\n\t}\n\n\tstatic final Random rng = new Random();\n\n\tstatic int rand(int l, int r) {\n\t\treturn l + rng.nextInt(r - l + 1);\n\t}\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tnew Main();\n\t}\n\n\tBufferedReader br;\n\tPrintWriter out;\n\tStringTokenizer st;\n\n\tString nextToken() {\n\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\ttry {\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new RuntimeException(e);\n\t\t\t}\n\t\t}\n\t\treturn st.nextToken();\n\t}\n\n\tString nextString() {\n\t\ttry {\n\t\t\treturn br.readLine();\n\t\t} catch (IOException e) {\n\t\t\tthrow new RuntimeException(e);\n\t\t}\n\t}\n\n\tint nextInt() {\n\t\treturn Integer.parseInt(nextToken());\n\t}\n\n\tlong nextLong() {\n\t\treturn Long.parseLong(nextToken());\n\t}\n\n\tdouble nextDouble() {\n\t\treturn Double.parseDouble(nextToken());\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.stream.IntStream;\nimport java.util.Arrays;\nimport java.util.Random;\nimport java.util.ArrayList;\nimport java.util.HashSet;\nimport java.io.OutputStreamWriter;\nimport java.io.OutputStream;\nimport java.io.PrintStream;\nimport java.util.Collection;\nimport java.util.Set;\nimport java.io.IOException;\nimport java.io.UncheckedIOException;\nimport java.util.List;\nimport java.util.stream.Stream;\nimport java.io.Closeable;\nimport java.io.Writer;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        Thread thread = new Thread(null, new TaskAdapter(), \"\", 1 << 27);\n        thread.start();\n        thread.join();\n    }\n\n    static class TaskAdapter implements Runnable {\n        @Override\n        public void run() {\n            InputStream inputStream = System.in;\n            OutputStream outputStream = System.out;\n            FastInput in = new FastInput(inputStream);\n            FastOutput out = new FastOutput(outputStream);\n            FPrimeFlip solver = new FPrimeFlip();\n            solver.solve(1, in, out);\n            out.close();\n        }\n    }\n\n    static class FPrimeFlip {\n        Debug debug = new Debug(false);\n        Set<Integer> set = new HashSet<>(200);\n        MillerRabin mr = new MillerRabin();\n\n        public void solve(int testNumber, FastInput in, FastOutput out) {\n            int n = in.readInt();\n            int[] x = new int[n + 1];\n            for (int i = 1; i <= n; i++) {\n                x[i] = in.readInt();\n                add(x[i]);\n                add(x[i] + 1);\n            }\n            int[] points = set.stream().mapToInt(Integer::intValue).toArray();\n            Randomized.shuffle(points);\n            Arrays.sort(points);\n            debug.debug(\"points\", points);\n            n = points.length;\n            KMAlgo km = new KMAlgo(points.length, points.length);\n            for (int i = 0; i < n; i++) {\n                if (points[i] % 2 != 0) {\n                    continue;\n                }\n                for (int j = 0; j < n; j++) {\n                    if (points[j] % 2 == 0) {\n                        continue;\n                    }\n                    int dist = Math.abs(points[i] - points[j]);\n                    if (mr.mr(dist, 10)) {\n                        km.addEdge(i, j, false);\n                    }\n                }\n            }\n\n            int cost = 0;\n            for (int i = 0; i < n; i++) {\n                cost += km.matchLeft(i) ? 1 : 0;\n            }\n\n            IntegerList unmatched = new IntegerList(n);\n            for (int i = 0; i < n; i++) {\n                if (points[i] % 2 == 0 && km.getLeftMate(i) == -1) {\n                    unmatched.add(points[i]);\n                }\n                if (points[i] % 2 == 1 && km.getRightMate(i) == -1) {\n                    unmatched.add(points[i]);\n                }\n            }\n\n            unmatched.sort();\n            int[] cnts = new int[2];\n            for (int i = 0; i < unmatched.size(); i++) {\n                cnts[unmatched.get(i) % 2]++;\n            }\n            cost += (cnts[0] / 2 + cnts[1] / 2) * 2;\n            cost += cnts[0] % 2 * 3;\n\n            out.println(cost);\n        }\n\n        public void add(int x) {\n            if (set.contains(x)) {\n                set.remove(x);\n            } else {\n                set.add(x);\n            }\n        }\n\n    }\n\n    static class SequenceUtils {\n        public static boolean equal(int[] a, int al, int ar, int[] b, int bl, int br) {\n            if ((ar - al) != (br - bl)) {\n                return false;\n            }\n            for (int i = al, j = bl; i <= ar; i++, j++) {\n                if (a[i] != b[j]) {\n                    return false;\n                }\n            }\n            return true;\n        }\n\n    }\n\n    static class IntegerList implements Cloneable {\n        private int size;\n        private int cap;\n        private int[] data;\n        private static final int[] EMPTY = new int[0];\n\n        public IntegerList(int cap) {\n            this.cap = cap;\n            if (cap == 0) {\n                data = EMPTY;\n            } else {\n                data = new int[cap];\n            }\n        }\n\n        public IntegerList(IntegerList list) {\n            this.size = list.size;\n            this.cap = list.cap;\n            this.data = Arrays.copyOf(list.data, size);\n        }\n\n        public IntegerList() {\n            this(0);\n        }\n\n        public void ensureSpace(int req) {\n            if (req > cap) {\n                while (cap < req) {\n                    cap = Math.max(cap + 10, 2 * cap);\n                }\n                data = Arrays.copyOf(data, cap);\n            }\n        }\n\n        private void checkRange(int i) {\n            if (i < 0 || i >= size) {\n                throw new ArrayIndexOutOfBoundsException();\n            }\n        }\n\n        public int get(int i) {\n            checkRange(i);\n            return data[i];\n        }\n\n        public void add(int x) {\n            ensureSpace(size + 1);\n            data[size++] = x;\n        }\n\n        public void addAll(int[] x, int offset, int len) {\n            ensureSpace(size + len);\n            System.arraycopy(x, offset, data, size, len);\n            size += len;\n        }\n\n        public void addAll(IntegerList list) {\n            addAll(list.data, 0, list.size);\n        }\n\n        public void sort() {\n            if (size <= 1) {\n                return;\n            }\n            Randomized.shuffle(data, 0, size);\n            Arrays.sort(data, 0, size);\n        }\n\n        public int size() {\n            return size;\n        }\n\n        public int[] toArray() {\n            return Arrays.copyOf(data, size);\n        }\n\n        public String toString() {\n            return Arrays.toString(toArray());\n        }\n\n        public boolean equals(Object obj) {\n            if (!(obj instanceof IntegerList)) {\n                return false;\n            }\n            IntegerList other = (IntegerList) obj;\n            return SequenceUtils.equal(data, 0, size - 1, other.data, 0, other.size - 1);\n        }\n\n        public int hashCode() {\n            int h = 1;\n            for (int i = 0; i < size; i++) {\n                h = h * 31 + Integer.hashCode(data[i]);\n            }\n            return h;\n        }\n\n        public IntegerList clone() {\n            IntegerList ans = new IntegerList();\n            ans.addAll(this);\n            return ans;\n        }\n\n    }\n\n    static class Modular {\n        int m;\n\n        public Modular(int m) {\n            this.m = m;\n        }\n\n        public Modular(long m) {\n            this.m = (int) m;\n            if (this.m != m) {\n                throw new IllegalArgumentException();\n            }\n        }\n\n        public Modular(double m) {\n            this.m = (int) m;\n            if (this.m != m) {\n                throw new IllegalArgumentException();\n            }\n        }\n\n        public int valueOf(int x) {\n            x %= m;\n            if (x < 0) {\n                x += m;\n            }\n            return x;\n        }\n\n        public int valueOf(long x) {\n            x %= m;\n            if (x < 0) {\n                x += m;\n            }\n            return (int) x;\n        }\n\n        public int mul(int x, int y) {\n            return valueOf((long) x * y);\n        }\n\n        public String toString() {\n            return \"mod \" + m;\n        }\n\n    }\n\n    static class FastOutput implements AutoCloseable, Closeable, Appendable {\n        private StringBuilder cache = new StringBuilder(10 << 20);\n        private final Writer os;\n\n        public FastOutput append(CharSequence csq) {\n            cache.append(csq);\n            return this;\n        }\n\n        public FastOutput append(CharSequence csq, int start, int end) {\n            cache.append(csq, start, end);\n            return this;\n        }\n\n        public FastOutput(Writer os) {\n            this.os = os;\n        }\n\n        public FastOutput(OutputStream os) {\n            this(new OutputStreamWriter(os));\n        }\n\n        public FastOutput append(char c) {\n            cache.append(c);\n            return this;\n        }\n\n        public FastOutput append(int c) {\n            cache.append(c);\n            return this;\n        }\n\n        public FastOutput println(int c) {\n            return append(c).println();\n        }\n\n        public FastOutput println() {\n            cache.append(System.lineSeparator());\n            return this;\n        }\n\n        public FastOutput flush() {\n            try {\n                os.append(cache);\n                os.flush();\n                cache.setLength(0);\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n            return this;\n        }\n\n        public void close() {\n            flush();\n            try {\n                os.close();\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n        }\n\n        public String toString() {\n            return cache.toString();\n        }\n\n    }\n\n    static class Randomized {\n        private static Random random = new Random(0);\n\n        public static void shuffle(int[] data) {\n            shuffle(data, 0, data.length - 1);\n        }\n\n        public static void shuffle(int[] data, int from, int to) {\n            to--;\n            for (int i = from; i <= to; i++) {\n                int s = nextInt(i, to);\n                int tmp = data[i];\n                data[i] = data[s];\n                data[s] = tmp;\n            }\n        }\n\n        public static int nextInt(int l, int r) {\n            return random.nextInt(r - l + 1) + l;\n        }\n\n    }\n\n    static class Debug {\n        private boolean offline;\n        private PrintStream out = System.err;\n        static int[] empty = new int[0];\n\n        public Debug(boolean enable) {\n            offline = enable && System.getSecurityManager() == null;\n        }\n\n        public Debug debug(String name, Object x) {\n            return debug(name, x, empty);\n        }\n\n        public Debug debug(String name, Object x, int... indexes) {\n            if (offline) {\n                if (!x.getClass().isArray()) {\n                    out.append(name);\n                    for (int i : indexes) {\n                        out.printf(\"[%d]\", i);\n                    }\n                    out.append(\"=\").append(\"\" + x);\n                    out.println();\n                } else {\n                    indexes = Arrays.copyOf(indexes, indexes.length + 1);\n                    if (x instanceof byte[]) {\n                        byte[] arr = (byte[]) x;\n                        for (int i = 0; i < arr.length; i++) {\n                            indexes[indexes.length - 1] = i;\n                            debug(name, arr[i], indexes);\n                        }\n                    } else if (x instanceof short[]) {\n                        short[] arr = (short[]) x;\n                        for (int i = 0; i < arr.length; i++) {\n                            indexes[indexes.length - 1] = i;\n                            debug(name, arr[i], indexes);\n                        }\n                    } else if (x instanceof boolean[]) {\n                        boolean[] arr = (boolean[]) x;\n                        for (int i = 0; i < arr.length; i++) {\n                            indexes[indexes.length - 1] = i;\n                            debug(name, arr[i], indexes);\n                        }\n                    } else if (x instanceof char[]) {\n                        char[] arr = (char[]) x;\n                        for (int i = 0; i < arr.length; i++) {\n                            indexes[indexes.length - 1] = i;\n                            debug(name, arr[i], indexes);\n                        }\n                    } else if (x instanceof int[]) {\n                        int[] arr = (int[]) x;\n                        for (int i = 0; i < arr.length; i++) {\n                            indexes[indexes.length - 1] = i;\n                            debug(name, arr[i], indexes);\n                        }\n                    } else if (x instanceof float[]) {\n                        float[] arr = (float[]) x;\n                        for (int i = 0; i < arr.length; i++) {\n                            indexes[indexes.length - 1] = i;\n                            debug(name, arr[i], indexes);\n                        }\n                    } else if (x instanceof double[]) {\n                        double[] arr = (double[]) x;\n                        for (int i = 0; i < arr.length; i++) {\n                            indexes[indexes.length - 1] = i;\n                            debug(name, arr[i], indexes);\n                        }\n                    } else if (x instanceof long[]) {\n                        long[] arr = (long[]) x;\n                        for (int i = 0; i < arr.length; i++) {\n                            indexes[indexes.length - 1] = i;\n                            debug(name, arr[i], indexes);\n                        }\n                    } else {\n                        Object[] arr = (Object[]) x;\n                        for (int i = 0; i < arr.length; i++) {\n                            indexes[indexes.length - 1] = i;\n                            debug(name, arr[i], indexes);\n                        }\n                    }\n                }\n            }\n            return this;\n        }\n\n    }\n\n    static class FastInput {\n        private final InputStream is;\n        private byte[] buf = new byte[1 << 20];\n        private int bufLen;\n        private int bufOffset;\n        private int next;\n\n        public FastInput(InputStream is) {\n            this.is = is;\n        }\n\n        private int read() {\n            while (bufLen == bufOffset) {\n                bufOffset = 0;\n                try {\n                    bufLen = is.read(buf);\n                } catch (IOException e) {\n                    bufLen = -1;\n                }\n                if (bufLen == -1) {\n                    return -1;\n                }\n            }\n            return buf[bufOffset++];\n        }\n\n        public void skipBlank() {\n            while (next >= 0 && next <= 32) {\n                next = read();\n            }\n        }\n\n        public int readInt() {\n            int sign = 1;\n\n            skipBlank();\n            if (next == '+' || next == '-') {\n                sign = next == '+' ? 1 : -1;\n                next = read();\n            }\n\n            int val = 0;\n            if (sign == 1) {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 + next - '0';\n                    next = read();\n                }\n            } else {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 - next + '0';\n                    next = read();\n                }\n            }\n\n            return val;\n        }\n\n    }\n\n    static class MillerRabin {\n        Modular modular;\n        Power power;\n        Random random = new Random();\n\n        public boolean mr(int n, int s) {\n            if (n <= 1) {\n                return false;\n            }\n            if (n == 2) {\n                return true;\n            }\n            if (n % 2 == 0) {\n                return false;\n            }\n            int m = n - 1;\n            while (m % 2 == 0) {\n                m /= 2;\n            }\n            modular = new Modular(n);\n            power = new Power(modular);\n            for (int i = 0; i < s; i++) {\n                int x = random.nextInt(n - 2) + 2;\n                if (!mr0(x, n, m)) {\n                    return false;\n                }\n            }\n            return true;\n        }\n\n        private boolean mr0(int x, int n, int m) {\n            return test(power.pow(x, m), m, n);\n        }\n\n        private boolean test(int y, int exp, int n) {\n            int y2 = modular.mul(y, y);\n            if (!(exp == n - 1 || test(y2, exp * 2, n))) {\n                return false;\n            }\n            if (exp != n - 1 && y2 != 1) {\n                return true;\n            }\n            if (y != 1 && y != n - 1) {\n                return false;\n            }\n            return true;\n        }\n\n    }\n\n    static class KMAlgo {\n        KMAlgo.Node[] leftSides;\n        KMAlgo.Node[] rightSides;\n        int version;\n\n        public KMAlgo(int l, int r) {\n            leftSides = new KMAlgo.Node[l];\n            for (int i = 0; i < l; i++) {\n                leftSides[i] = new KMAlgo.Node();\n                leftSides[i].id = i;\n                leftSides[i].leftSide = true;\n            }\n            rightSides = new KMAlgo.Node[r];\n            for (int i = 0; i < r; i++) {\n                rightSides[i] = new KMAlgo.Node();\n                rightSides[i].id = i;\n            }\n        }\n\n        public void addEdge(int lId, int rId, boolean urge) {\n            leftSides[lId].nodes.add(rightSides[rId]);\n            rightSides[rId].nodes.add(leftSides[lId]);\n            if (urge && leftSides[lId].partner == null && rightSides[rId].partner == null) {\n                leftSides[lId].partner = rightSides[rId];\n                rightSides[rId].partner = leftSides[lId];\n            }\n        }\n\n        private void prepare() {\n            version++;\n        }\n\n        public boolean matchLeft(int id) {\n            if (leftSides[id].partner != null) {\n                return true;\n            }\n            prepare();\n            return findPartner(leftSides[id]);\n        }\n\n        public int getLeftMate(int lId) {\n            if (leftSides[lId].partner != null) {\n                return leftSides[lId].partner.id;\n            }\n            return -1;\n        }\n\n        public int getRightMate(int rId) {\n            if (rightSides[rId].partner != null) {\n                return rightSides[rId].partner.id;\n            }\n            return -1;\n        }\n\n        private boolean findPartner(KMAlgo.Node src) {\n            if (src.visited == version) {\n                return false;\n            }\n            src.visited = version;\n            for (KMAlgo.Node node : src.nodes) {\n                if (!tryRelease(node)) {\n                    continue;\n                }\n                node.partner = src;\n                src.partner = node;\n                return true;\n            }\n            return false;\n        }\n\n        private boolean tryRelease(KMAlgo.Node src) {\n            if (src.visited == version) {\n                return false;\n            }\n            src.visited = version;\n            if (src.partner == null) {\n                return true;\n            }\n            if (findPartner(src.partner)) {\n                src.partner = null;\n                return true;\n            }\n            return false;\n        }\n\n        public String toString() {\n            StringBuilder builder = new StringBuilder();\n            for (int i = 0; i < leftSides.length; i++) {\n                if (leftSides[i].partner == null) {\n                    continue;\n                }\n                builder.append(leftSides[i].id).append(\" - \").append(leftSides[i].partner.id).append(\"\\n\");\n            }\n            return builder.toString();\n        }\n\n        public static class Node {\n            List<KMAlgo.Node> nodes = new ArrayList<>();\n            int visited;\n            KMAlgo.Node partner;\n            int id;\n            boolean leftSide;\n\n            public String toString() {\n                return \"\" + id;\n            }\n\n        }\n\n    }\n\n    static class Power {\n        final Modular modular;\n\n        public Power(Modular modular) {\n            this.modular = modular;\n        }\n\n        public int pow(int x, int n) {\n            if (n == 0) {\n                return modular.valueOf(1);\n            }\n            long r = pow(x, n >> 1);\n            r = modular.valueOf(r * r);\n            if ((n & 1) == 1) {\n                r = modular.valueOf(r * x);\n            }\n            return (int) r;\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.StringTokenizer;\nimport java.io.BufferedReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        FastScanner in = new FastScanner(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskF solver = new TaskF();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskF {\n        final int N = (int) (1e7 + 100);\n        boolean[] isPrime = new boolean[N];\n\n        public void solve(int testNumber, FastScanner in, PrintWriter out) {\n            Arrays.fill(isPrime, true);\n            isPrime[0] = false;\n            isPrime[1] = false;\n            for (int i = 2; i < N; i++) {\n                for (int j = i + i; j < N; j += i) {\n                    isPrime[j] = false;\n                }\n            }\n\n            int n = in.nextInt();\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++) {\n                a[i] = in.nextInt();\n            }\n\n            List<Integer> b = new ArrayList<>();\n            {\n                int l = -1;\n                int r = -1;\n                for (int x : a) {\n                    if (x == r + 1) {\n                        ++r;\n                    } else {\n                        if (l >= 0) {\n                            b.add(l);\n                            b.add(r + 1);\n                        }\n                        l = x;\n                        r = x;\n                    }\n                }\n                if (l >= 0) {\n                    b.add(l);\n                    b.add(r + 1);\n                }\n            }\n\n            List<Integer> even = new ArrayList<>();\n            List<Integer> odd = new ArrayList<>();\n            for (int x : b) {\n                if (x % 2 == 0) {\n                    even.add(x);\n                } else {\n                    odd.add(x);\n                }\n            }\n            boolean[][] g = new boolean[even.size()][odd.size()];\n            for (int i = 0; i < even.size(); i++) {\n                for (int j = 0; j < odd.size(); j++) {\n                    if (f(Math.abs(even.get(i) - odd.get(j))) == 1) {\n                        g[i][j] = true;\n                    }\n                }\n            }\n            int k = matching(g);\n            if (b.size() % 2 != 0) {\n                throw new AssertionError();\n            }\n            int ans = k;\n            ans += ((even.size() - k) / 2) * 2;\n            ans += ((odd.size() - k) / 2) * 2;\n            if ((even.size() - k) % 2 != 0) {\n                ans += 3;\n            }\n            out.println(ans);\n        }\n\n        private int f(int len) {\n            if (len < 1) {\n                return 0;\n            }\n            if (len % 2 == 0) {\n                return 2;\n            }\n            if (isPrime[len]) {\n                return 1;\n            }\n            return 3;\n        }\n\n        private int matching(boolean[][] g) {\n            int n = g.length;\n            int m = g[0].length;\n            int[] pair = new int[m];\n            Arrays.fill(pair, -1);\n            int res = 0;\n            boolean[] was = new boolean[n];\n            for (int i = 0; i < n; i++) {\n                Arrays.fill(was, false);\n                if (dfs(i, g, was, pair)) {\n                    ++res;\n                }\n            }\n            return res;\n        }\n\n        private boolean dfs(int v, boolean[][] g, boolean[] was, int[] pair) {\n            if (was[v]) {\n                return false;\n            }\n            was[v] = true;\n            for (int u = 0; u < g[v].length; u++) {\n                if (!g[v][u]) {\n                    continue;\n                }\n                if (pair[u] < 0 || dfs(pair[u], g, was, pair)) {\n                    pair[u] = v;\n                    return true;\n                }\n            }\n            return false;\n        }\n\n    }\n\n    static class FastScanner {\n        private BufferedReader in;\n        private StringTokenizer st;\n\n        public FastScanner(InputStream stream) {\n            in = new BufferedReader(new InputStreamReader(stream));\n        }\n\n        public String next() {\n            while (st == null || !st.hasMoreTokens()) {\n                try {\n                    st = new StringTokenizer(in.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return st.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\t// long t = System.currentTimeMillis();\n\t\tnew Main().run();\n\t\t// System.err.println(System.currentTimeMillis() - t);\n\t}\n\n\tint min_cost_flow(int s, int t, ArrayList<Edge>[] g) {\n\t\tclass Vertice implements Comparable<Vertice> {\n\t\t\tint id;\n\t\t\tlong dist;\n\n\t\t\tpublic Vertice(int id, long dist) {\n\t\t\t\tthis.id = id;\n\t\t\t\tthis.dist = dist;\n\t\t\t}\n\n\t\t\tpublic int compareTo(Vertice o) {\n\t\t\t\treturn Long.compare(this.dist, o.dist);\n\t\t\t};\n\t\t}\n\n\t\tint n = g.length;\n\n\t\tint min_cost = 0;\n\t\tg[t].add(new Edge(t, s, (1 << 30), 0));\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < g[i].size(); j++) {\n\t\t\t\tEdge e = g[i].get(j);\n\t\t\t\tg[e.src].get(j).rev_id = g[e.dst].size();\n\t\t\t\tg[e.dst].add(new Edge(e.dst, e.src, 0, -e.cost));\n\t\t\t\tg[e.dst].get(g[e.dst].size() - 1).rev_id = j;\n\t\t\t}\n\t\t}\n\n\t\tlong[] potential = new long[n];\n\t\tint[] excess = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (Edge e : g[i]) {\n\t\t\t\tif (e.cost < 0) {\n\t\t\t\t\te.add_flow(e.cap);\n\t\t\t\t\texcess[e.dst] += e.flow;\n\t\t\t\t\texcess[e.src] -= e.flow;\n\t\t\t\t\tg[e.dst].get(e.rev_id).add_flow(-e.cap);\n\t\t\t\t\tmin_cost += e.cost * e.flow;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tArrayList<Integer> sink_v = new ArrayList<>();\n\t\tArrayDeque<Integer> source_v = new ArrayDeque<>();\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (excess[i] < 0)\n\t\t\t\tsink_v.add(i);\n\t\t\telse if (excess[i] > 0)\n\t\t\t\tsource_v.add(i);\n\t\t}\n\t\twhile (!source_v.isEmpty()) {\n\n\t\t\tPriorityQueue<Vertice> priority_queue = new PriorityQueue<>();\n\t\t\tint[] pre_v = new int[n];\n\t\t\tint[] pre_e = new int[n];\n\t\t\tlong[] dist = new long[n];\n\t\t\tArrays.fill(pre_v, -1);\n\t\t\tArrays.fill(pre_e, -1);\n\t\t\tArrays.fill(dist, 1L << 60);\n\t\t\tint source = source_v.poll();\n\t\t\tdist[source] = 0;\n\t\t\tpre_v[source] = -1;\n\t\t\tpre_e[source] = -1;\n\t\t\tboolean[] looked = new boolean[n];\n\n\t\t\tpriority_queue.add(new Vertice(source, 0));\n\n\t\t\twhile (!priority_queue.isEmpty()) {\n\t\t\t\tint v = priority_queue.poll().id;\n\t\t\t\tif (looked[v])\n\t\t\t\t\tcontinue;\n\t\t\t\telse\n\t\t\t\t\tlooked[v] = true;\n\t\t\t\tfor (int i = 0; i < g[v].size(); i++) {\n\t\t\t\t\tEdge e = g[v].get(i);\n\t\t\t\t\tif (e.residue > 0) {\n\t\t\t\t\t\tif (dist[e.dst] > dist[v] + e.cost - potential[v] + potential[e.dst]) {\n\t\t\t\t\t\t\tdist[e.dst] = dist[v] + e.cost - potential[v] + potential[e.dst];\n\n\t\t\t\t\t\t\tpriority_queue.add(new Vertice(e.dst, dist[e.dst]));\n\t\t\t\t\t\t\tpre_v[e.dst] = v;\n\t\t\t\t\t\t\tpre_e[e.dst] = i;\n\t\t\t\t\t\t\tlooked[e.dst] = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint sink = -1;\n\t\t\tfor (int i = 0; i < sink_v.size(); i++) {\n\t\t\t\tif (pre_v[sink_v.get(i)] != -1) {\n\t\t\t\t\tsink = sink_v.get(i);\n\t\t\t\t\tsink_v.remove(i);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (sink == -1) {\n\t\t\t\tsource_v.add(source);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tif (dist[i] < (1L << 60))\n\t\t\t\t\tpotential[i] -= dist[i];\n\t\t\t\telse\n\t\t\t\t\tpotential[i] -= (1 << 30);\n\t\t\t}\n\n\t\t\tint delta = Math.min(Math.abs(excess[source]), Math.abs(excess[sink]));\n\n\t\t\tfor (int i = sink; i != source; i = pre_v[i]) {\n\t\t\t\tdelta = Math.min(delta, g[pre_v[i]].get(pre_e[i]).residue);\n\t\t\t}\n\t\t\tfor (int i = sink; i != source; i = pre_v[i]) {\n\t\t\t\tEdge e = g[pre_v[i]].get(pre_e[i]);\n\t\t\t\te.add_flow(delta);\n\t\t\t\tg[i].get(e.rev_id).add_flow(-delta);\n\t\t\t\tmin_cost += delta * e.cost;\n\t\t\t}\n\t\t\texcess[sink] += delta;\n\t\t\texcess[source] -= delta;\n\t\t\tif (excess[sink] < 0)\n\t\t\t\tsink_v.add(sink);\n\t\t\tif (excess[source] > 0)\n\t\t\t\tsource_v.add(source);\n\n\t\t}\n\n\t\treturn min_cost;\n\t}\n\n\tclass Edge {\n\t\tint src;\n\t\tint dst;\n\t\tint cap;\n\t\tint cost;\n\t\tint residue;\n\t\tint flow = 0;\n\t\tint rev_id = -1;\n\n\t\tEdge(int src, int dst, int cap, int cost) {\n\t\t\tthis.src = src;\n\t\t\tthis.dst = dst;\n\t\t\tthis.cap = cap;\n\t\t\tthis.cost = cost;\n\t\t\tresidue = this.cap - flow;\n\t\t}\n\n\t\tvoid add_flow(int flow) {\n\t\t\tthis.flow += flow;\n\t\t\tresidue = cap - this.flow;\n\t\t}\n\n\t}\n\n\tboolean[] isPrime = new boolean[1_000_000_3];\n\t{\n\t\tArrays.fill(isPrime, true);\n\t\tisPrime[0] = false;\n\t\tisPrime[1] = false;\n\t\tfor (int i = 2; i < isPrime.length; ++i) {\n\t\t\tif (isPrime[i]) {\n\t\t\t\tfor (int j = 2 * i; j < isPrime.length; j += i) {\n\t\t\t\t\tisPrime[j] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tisPrime[2] = false;\n\t}\n\n\tvoid solve(int n, int[] x) {\n\t\tArrayList<Integer> list = new ArrayList<>();\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tint j = i;\n\t\t\twhile (j + 1 < n && x[j] + 1 == x[j + 1]) {\n\t\t\t\t++j;\n\t\t\t}\n\t\t\tlist.add(x[i]);\n\t\t\tlist.add(x[j] + 1);\n\t\t\ti = j;\n\t\t}\n\t\tx = new int[list.size()];\n\t\tint even = 0, odd = 0;\n\t\tfor (int i = 0; i < x.length; ++i) {\n\t\t\tx[i] = list.get(i);\n\t\t\tif (x[i] % 2 == 0)\n\t\t\t\t++even;\n\t\t\telse\n\t\t\t\t++odd;\n\t\t}\n\t\tint[][] dist = new int[list.size()][list.size()];\n\t\tfor (int i = 0; i < dist.length; ++i) {\n\t\t\tfor (int j = 0; j < dist[i].length; ++j) {\n\t\t\t\tif (i == j)\n\t\t\t\t\tcontinue;\n\t\t\t\tint v = Math.abs(x[i] - x[j]);\n\t\t\t\tif (v % 2 == 1) {// 偶奇をつなぐ\n\t\t\t\t\tif (isPrime[v])\n\t\t\t\t\t\tdist[i][j] = 1;// 全てに優先する\n\t\t\t\t\telse\n\t\t\t\t\t\tdist[i][j] = Integer.MAX_VALUE / 3;\n\t\t\t\t} else if (v % 2 == 0) {// パリティの等しいものを繋ぐ.(例外処理2=5-3,4=9-5)\n\t\t\t\t\tdist[i][j] = 2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tArrayList<Edge>[] g = new ArrayList[list.size() + 2];\n\t\tfor (int i = 0; i < g.length; ++i) {\n\t\t\tg[i] = new ArrayList<>();\n\t\t}\n\t\tint src = g.length - 2;\n\t\tint dst = g.length - 1;\n\t\tfor (int i = 0; i < dist.length; i++) {\n\t\t\tfor (int j = 0; j < dist[i].length; j++) {\n\t\t\t\tif (x[i] % 2 == 0 && x[j] % 2 == 1 && isPrime[Math.abs(x[i] - x[j])])\n\t\t\t\t\tg[i].add(new Edge(i, j, 1, -dist[i][j]));\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < list.size(); ++i) {\n\t\t\tif (x[i] % 2 == 0)\n\t\t\t\tg[src].add(new Edge(src, i, 1, 0));\n\t\t\telse\n\t\t\t\tg[i].add(new Edge(i, dst, 1, 0));\n\t\t}\n\t\tint ret = 0;\n\t\tint c = -min_cost_flow(src, dst, g);\n\t\tret = c + (even - c) / 2 * 2 + (odd - c) / 2 * 2;\n\t\tif ((even - c) % 2 == 1)\n\t\t\tret += 3;\n\t\tSystem.out.println(ret);\n\t}\n\n\tpublic void run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint[] x = new int[n];\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tx[i] = sc.nextInt();\n\t\t}\n\t\tsolve(n, x);\n\t}\n\n\tstatic void tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        FastScanner in = new FastScanner(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskF solver = new TaskF();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskF {\n        final int N = (int) (1e7 + 100);\n        boolean[] isPrime = new boolean[N];\n\n        public void solve(int testNumber, FastScanner in, PrintWriter out) {\n            Arrays.fill(isPrime, true);\n            isPrime[0] = false;\n            isPrime[1] = false;\n            for (int i = 2; i < N; i++) {\n                for (int j = i + i; j < N; j += i) {\n                    isPrime[j] = false;\n                }\n            }\n\n            int n = in.nextInt();\n            int[] x = new int[n];\n            for (int i = 0; i < n; i++) {\n                x[i] = in.nextInt();\n            }\n\n            int[] d = new int[n];\n            for (int i = 0; i < n; i++) {\n                d[i] = 3 * (i + 1);\n                for (int j = 0; j < i; j++) {\n                    if (x[i] - x[j] == 1) {\n                        continue;\n                    }\n                    int cur = f(x[i] - x[j] + 1);\n                    for (int k = j; k < i; k++) {\n                        cur += f(x[k + 1] - x[k] - 1);\n                    }\n                    if (j > 0) {\n                        cur += d[j - 1];\n                    }\n                    d[i] = Math.min(d[i], cur);\n                }\n\n                if (i > 0 && x[i] == x[i - 1] + 1) {\n                    int cur = 2;\n                    if (i > 1) {\n                        cur += d[i - 1];\n                    }\n                    d[i] = Math.min(d[i], cur);\n                }\n            }\n            out.println(d[n - 1]);\n        }\n\n        private int f(int len) {\n            if (len < 1) {\n                return 0;\n            }\n            if (isPrime[len]) {\n                return 1;\n            }\n            if (len % 2 == 0) {\n                return 2;\n            }\n            return 3;\n        }\n\n    }\n\n    static class FastScanner {\n        private BufferedReader in;\n        private StringTokenizer st;\n\n        public FastScanner(InputStream stream) {\n            in = new BufferedReader(new InputStreamReader(stream));\n        }\n\n        public String next() {\n            while (st == null || !st.hasMoreTokens()) {\n                try {\n                    st = new StringTokenizer(in.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return st.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\t// long t = System.currentTimeMillis();\n\t\tnew Main().run();\n\t\t// System.err.println(System.currentTimeMillis() - t);\n\t}\n\n\tint min_cost_flow(int s, int t, ArrayList<Edge>[] g) {\n\t\tclass Vertice implements Comparable<Vertice> {\n\t\t\tint id;\n\t\t\tlong dist;\n\n\t\t\tpublic Vertice(int id, long dist) {\n\t\t\t\tthis.id = id;\n\t\t\t\tthis.dist = dist;\n\t\t\t}\n\n\t\t\tpublic int compareTo(Vertice o) {\n\t\t\t\treturn Long.compare(this.dist, o.dist);\n\t\t\t};\n\t\t}\n\n\t\tint n = g.length;\n\n\t\tint min_cost = 0;\n\t\tg[t].add(new Edge(t, s, (1 << 30), 0));\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < g[i].size(); j++) {\n\t\t\t\tEdge e = g[i].get(j);\n\t\t\t\tg[e.src].get(j).rev_id = g[e.dst].size();\n\t\t\t\tg[e.dst].add(new Edge(e.dst, e.src, 0, -e.cost));\n\t\t\t\tg[e.dst].get(g[e.dst].size() - 1).rev_id = j;\n\t\t\t}\n\t\t}\n\n\t\tlong[] potential = new long[n];\n\t\tint[] excess = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (Edge e : g[i]) {\n\t\t\t\tif (e.cost < 0) {\n\t\t\t\t\te.add_flow(e.cap);\n\t\t\t\t\texcess[e.dst] += e.flow;\n\t\t\t\t\texcess[e.src] -= e.flow;\n\t\t\t\t\tg[e.dst].get(e.rev_id).add_flow(-e.cap);\n\t\t\t\t\tmin_cost += e.cost * e.flow;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tArrayList<Integer> sink_v = new ArrayList<>();\n\t\tArrayDeque<Integer> source_v = new ArrayDeque<>();\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (excess[i] < 0)\n\t\t\t\tsink_v.add(i);\n\t\t\telse if (excess[i] > 0)\n\t\t\t\tsource_v.add(i);\n\t\t}\n\t\twhile (!source_v.isEmpty()) {\n\n\t\t\tPriorityQueue<Vertice> priority_queue = new PriorityQueue<>();\n\t\t\tint[] pre_v = new int[n];\n\t\t\tint[] pre_e = new int[n];\n\t\t\tlong[] dist = new long[n];\n\t\t\tArrays.fill(pre_v, -1);\n\t\t\tArrays.fill(pre_e, -1);\n\t\t\tArrays.fill(dist, 1L << 60);\n\t\t\tint source = source_v.poll();\n\t\t\tdist[source] = 0;\n\t\t\tpre_v[source] = -1;\n\t\t\tpre_e[source] = -1;\n\t\t\tboolean[] looked = new boolean[n];\n\n\t\t\tpriority_queue.add(new Vertice(source, 0));\n\n\t\t\twhile (!priority_queue.isEmpty()) {\n\t\t\t\tint v = priority_queue.poll().id;\n\t\t\t\tif (looked[v])\n\t\t\t\t\tcontinue;\n\t\t\t\telse\n\t\t\t\t\tlooked[v] = true;\n\t\t\t\tfor (int i = 0; i < g[v].size(); i++) {\n\t\t\t\t\tEdge e = g[v].get(i);\n\t\t\t\t\tif (e.residue > 0) {\n\t\t\t\t\t\tif (dist[e.dst] > dist[v] + e.cost - potential[v] + potential[e.dst]) {\n\t\t\t\t\t\t\tdist[e.dst] = dist[v] + e.cost - potential[v] + potential[e.dst];\n\n\t\t\t\t\t\t\tpriority_queue.add(new Vertice(e.dst, dist[e.dst]));\n\t\t\t\t\t\t\tpre_v[e.dst] = v;\n\t\t\t\t\t\t\tpre_e[e.dst] = i;\n\t\t\t\t\t\t\tlooked[e.dst] = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint sink = -1;\n\t\t\tfor (int i = 0; i < sink_v.size(); i++) {\n\t\t\t\tif (pre_v[sink_v.get(i)] != -1) {\n\t\t\t\t\tsink = sink_v.get(i);\n\t\t\t\t\tsink_v.remove(i);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (sink == -1) {\n\t\t\t\tsource_v.add(source);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tif (dist[i] < (1L << 60))\n\t\t\t\t\tpotential[i] -= dist[i];\n\t\t\t\telse\n\t\t\t\t\tpotential[i] -= (1 << 30);\n\t\t\t}\n\n\t\t\tint delta = Math.min(Math.abs(excess[source]), Math.abs(excess[sink]));\n\n\t\t\tfor (int i = sink; i != source; i = pre_v[i]) {\n\t\t\t\tdelta = Math.min(delta, g[pre_v[i]].get(pre_e[i]).residue);\n\t\t\t}\n\t\t\tfor (int i = sink; i != source; i = pre_v[i]) {\n\t\t\t\tEdge e = g[pre_v[i]].get(pre_e[i]);\n\t\t\t\te.add_flow(delta);\n\t\t\t\tg[i].get(e.rev_id).add_flow(-delta);\n\t\t\t\tmin_cost += delta * e.cost;\n\t\t\t}\n\t\t\texcess[sink] += delta;\n\t\t\texcess[source] -= delta;\n\t\t\tif (excess[sink] < 0)\n\t\t\t\tsink_v.add(sink);\n\t\t\tif (excess[source] > 0)\n\t\t\t\tsource_v.add(source);\n\n\t\t}\n\n\t\treturn min_cost;\n\t}\n\n\tclass Edge {\n\t\tint src;\n\t\tint dst;\n\t\tint cap;\n\t\tint cost;\n\t\tint residue;\n\t\tint flow = 0;\n\t\tint rev_id = -1;\n\n\t\tEdge(int src, int dst, int cap, int cost) {\n\t\t\tthis.src = src;\n\t\t\tthis.dst = dst;\n\t\t\tthis.cap = cap;\n\t\t\tthis.cost = cost;\n\t\t\tresidue = this.cap - flow;\n\t\t}\n\n\t\tvoid add_flow(int flow) {\n\t\t\tthis.flow += flow;\n\t\t\tresidue = cap - this.flow;\n\t\t}\n\n\t}\n\n\tboolean[] isPrime = new boolean[1_000_000_3];\n\t{\n\t\tArrays.fill(isPrime, true);\n\t\tisPrime[0] = false;\n\t\tisPrime[1] = false;\n\t\tfor (int i = 2; i < isPrime.length; ++i) {\n\t\t\tif (isPrime[i]) {\n\t\t\t\tfor (int j = 2 * i; j < isPrime.length; j += i) {\n\t\t\t\t\tisPrime[j] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tisPrime[2] = false;\n\t}\n\n\tvoid solve(int n, int[] x) {\n\t\tArrayList<Integer> list = new ArrayList<>();\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tint j = i;\n\t\t\twhile (j + 1 < n && x[j] + 1 == x[j + 1]) {\n\t\t\t\t++j;\n\t\t\t}\n\t\t\tlist.add(x[i]);\n\t\t\tlist.add(x[j] + 1);\n\t\t\ti = j;\n\t\t}\n\t\tx = new int[list.size()];\n\t\tint even = 0, odd = 0;\n\t\tfor (int i = 0; i < x.length; ++i) {\n\t\t\tx[i] = list.get(i);\n\t\t\tif (x[i] % 2 == 0)\n\t\t\t\t++even;\n\t\t\telse\n\t\t\t\t++odd;\n\t\t}\n\t\tint[][] dist = new int[list.size()][list.size()];\n\t\tfor (int i = 0; i < dist.length; ++i) {\n\t\t\tfor (int j = 0; j < dist[i].length; ++j) {\n\t\t\t\tif (i == j)\n\t\t\t\t\tcontinue;\n\t\t\t\tint v = Math.abs(x[i] - x[j]);\n\t\t\t\tif (v % 2 == 1) {// 偶奇をつなぐ\n\t\t\t\t\tif (isPrime[v])\n\t\t\t\t\t\tdist[i][j] = 1;// 全てに優先する\n\t\t\t\t\telse\n\t\t\t\t\t\tdist[i][j] = Integer.MAX_VALUE / 3;\n\t\t\t\t} else if (v % 2 == 0) {// パリティの等しいものを繋ぐ.(例外処理2=5-3,4=9-5)\n\t\t\t\t\tdist[i][j] = 2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tArrayList<Edge>[] g = new ArrayList[list.size() + 2];\n\t\tfor (int i = 0; i < g.length; ++i) {\n\t\t\tg[i] = new ArrayList<>();\n\t\t}\n\t\tint src = g.length - 2;\n\t\tint dst = g.length - 1;\n\t\tfor (int i = 0; i < dist.length; i++) {\n\t\t\tfor (int j = 1; j < dist[i].length; j++) {\n\t\t\t\tif (x[i] % 2 == 0 && x[j] % 2 == 1 && isPrime[Math.abs(x[i] - x[j])])\n\t\t\t\t\tg[i].add(new Edge(i, j, 1, -dist[i][j]));\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < list.size(); ++i) {\n\t\t\tif (x[i] % 2 == 0)\n\t\t\t\tg[src].add(new Edge(src, i, 1, 0));\n\t\t\telse\n\t\t\t\tg[i].add(new Edge(i, dst, 1, 0));\n\t\t}\n\t\tint ret = 0;\n\t\tint c = -min_cost_flow(src, dst, g);\n\t\tret = c + (even - c) / 2 * 2 + (odd - c) / 2 * 2;\n\t\tif ((even - c) % 2 == 1)\n\t\t\tret += 3;\n\t\tSystem.out.println(ret);\n\t}\n\n\tpublic void run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint[] x = new int[n];\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tx[i] = sc.nextInt();\n\t\t}\n\t\tsolve(n, x);\n\t}\n\n\tstatic void tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.io.IOException;\nimport java.io.Reader;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.stream.Stream;\nimport java.util.Optional;\nimport java.io.BufferedReader;\nimport java.util.Comparator;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author tanzaku\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        MyInput in = new MyInput(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskF solver = new TaskF();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskF {\n        public void solve(int testNumber, MyInput in, PrintWriter out) {\n            int n = in.nextInt();\n            List<Integer> ones = new ArrayList<>();\n            int[] xs = in.nextIntArray(n);\n            for (int i = 0; i < n; i++) {\n                if (i == 0 || xs[i] - xs[i - 1] != 1) ones.add(xs[i]);\n                if (i == n - 1 || xs[i + 1] - xs[i] != 1) ones.add(xs[i] + 1);\n            }\n\n            boolean[] isPrime = eratosthenes(10000000);\n            int m = ones.size();\n            int S = m * 2, T = S + 1;\n            PushRelabelBaseMaxFlow flow = new PushRelabelBaseMaxFlow(T + 1);\n            int[] cnt = new int[2];\n            for (int i = 0; i < ones.size(); i++) {\n                cnt[ones.get(i) % 2]++;\n                flow.addEdge(S, i, 1);\n                flow.addEdge(i + m, T, 1);\n                for (int j = 0; j < i; j++) {\n                    final int a = ones.get(i);\n                    final int b = ones.get(i);\n                    if (a == b) break;\n                    if (a - b != 2 && isPrime[a - b]) {\n                        flow.addEdge(i, j + m, 1);\n                        flow.addEdge(j, i + m, 1);\n                    }\n                }\n            }\n            int f1 = (int) (flow.relabelToFront(S, T) / 2);\n            cnt[0] -= f1;\n            cnt[1] -= f1;\n            int f2 = cnt[0] / 2 + cnt[1] / 2;\n            int f3 = cnt[0] % 2 != 0 ? 1 : 0;\n            out.println(f1 * 1 + f2 * 2 + f3 * 3);\n        }\n\n        private static boolean[] eratosthenes(int n) {\n            final boolean[] p = new boolean[n + 1];\n            Arrays.fill(p, true);\n            p[0] = p[1] = false;\n            for (int i = 2; i * i <= n; i++) {\n                if (p[i]) {\n                    for (int j = i * i; j <= n; j += i) {\n                        p[j] = false;\n                    }\n                }\n            }\n            return p;\n        }\n\n    }\n\n    static class PushRelabelBaseMaxFlow {\n        int V;\n        PushRelabelBaseMaxFlow.Vertex[] vertices;\n\n        public PushRelabelBaseMaxFlow(int V) {\n            this.V = V;\n            vertices = new PushRelabelBaseMaxFlow.Vertex[V];\n            for (int i = 0; i < V; i++) vertices[i] = new PushRelabelBaseMaxFlow.Vertex(i);\n        }\n\n        public void addEdge(int s, int t, int cap) {\n            PushRelabelBaseMaxFlow.Edge e1 = new PushRelabelBaseMaxFlow.Edge(vertices[s], vertices[t], cap);\n            PushRelabelBaseMaxFlow.Edge e2 = new PushRelabelBaseMaxFlow.Edge(vertices[t], vertices[s], 0);\n            e1.rev = e2;\n            e2.rev = e1;\n        }\n\n        private void initializePreflow(PushRelabelBaseMaxFlow.Vertex S) {\n            for (PushRelabelBaseMaxFlow.Vertex v : vertices) {\n                v.clear();\n            }\n            S.height = V;\n            for (PushRelabelBaseMaxFlow.Edge e : S.edges) {\n                e.v.excessFlow += e.capacity;\n                e.u.excessFlow -= e.capacity;\n                e.rev.capacity += e.capacity;\n                e.capacity = 0;\n            }\n        }\n\n        public long relabelToFront(int s, int t) {\n            initializePreflow(vertices[s]);\n            PushRelabelBaseMaxFlow.Vertex[] L = new PushRelabelBaseMaxFlow.Vertex[V - 1];\n            for (int i = 0, j = 0; i < V; i++) {\n                if (i != s && i != t) L[j++] = vertices[i];\n            }\n\n            int i = 0;\n            PushRelabelBaseMaxFlow.Vertex cur = L[i];\n            while (cur != null) {\n                int h0 = cur.height;\n                cur.discharge();\n                if (cur.height > h0) {\n                    L[i = 0] = cur;\n                }\n                PushRelabelBaseMaxFlow.Vertex tmp = L[++i];\n                L[i] = cur;\n                cur = tmp;\n            }\n\n            return vertices[t].excessFlow;\n        }\n\n        private static class Edge {\n            PushRelabelBaseMaxFlow.Vertex u;\n            PushRelabelBaseMaxFlow.Vertex v;\n            PushRelabelBaseMaxFlow.Edge rev;\n            long capacity;\n\n            public Edge(PushRelabelBaseMaxFlow.Vertex s, PushRelabelBaseMaxFlow.Vertex t, long cap) {\n                u = s;\n                v = t;\n                capacity = cap;\n                s.edges.add(this);\n            }\n\n            boolean canPush() {\n                return capacity > 0 && u.height == v.height + 1 && u.isOverflow();\n            }\n\n            void push() {\n                final long f = Math.min(u.excessFlow, capacity);\n                capacity -= f;\n                rev.capacity += f;\n                u.excessFlow -= f;\n                v.excessFlow += f;\n            }\n\n\n            public String toString() {\n                return String.format(\"[Edge u=%d(%d), v=%d(%d), c=%d]\", u.id, u.height, v.id, v.height, capacity);\n            }\n\n        }\n\n        static class Vertex {\n            final int id;\n            int height;\n            int excessFlow;\n            List<PushRelabelBaseMaxFlow.Edge> edges = new ArrayList<>();\n\n            public Vertex(int id) {\n                this.id = id;\n            }\n\n            void clear() {\n                height = 0;\n                excessFlow = 0;\n            }\n\n            boolean isOverflow() {\n                return excessFlow > 0;\n            }\n\n            void relabel() {\n                final int h = edges.stream().filter(e -> e.capacity > 0)\n                        .map(a -> a.v.height)\n                        .min(Comparator.naturalOrder())\n                        .get();\n                if (!isOverflow() || height > h) {\n                    throw new RuntimeException();\n                }\n                height = h + 1;\n            }\n\n            void discharge() {\n                while (isOverflow()) {\n                    for (PushRelabelBaseMaxFlow.Edge e : edges) {\n                        while (e.canPush()) e.push();\n                        if (!isOverflow()) return;\n                    }\n                    relabel();\n                }\n            }\n\n\n            public String toString() {\n                return String.format(\"[Vertex id=%d, h=%d, ex=%d, es=%s]\", id, height, excessFlow, edges);\n            }\n\n        }\n\n    }\n\n    static class MyInput {\n        private final BufferedReader in;\n        private static int pos;\n        private static int readLen;\n        private static final char[] buffer = new char[1024 * 8];\n        private static char[] str = new char[500 * 8 * 2];\n        private static boolean[] isDigit = new boolean[256];\n        private static boolean[] isSpace = new boolean[256];\n        private static boolean[] isLineSep = new boolean[256];\n\n        static {\n            for (int i = 0; i < 10; i++) {\n                isDigit['0' + i] = true;\n            }\n            isDigit['-'] = true;\n            isSpace[' '] = isSpace['\\r'] = isSpace['\\n'] = isSpace['\\t'] = true;\n            isLineSep['\\r'] = isLineSep['\\n'] = true;\n        }\n\n        public MyInput(InputStream is) {\n            in = new BufferedReader(new InputStreamReader(is));\n        }\n\n        public int read() {\n            if (pos >= readLen) {\n                pos = 0;\n                try {\n                    readLen = in.read(buffer);\n                } catch (IOException e) {\n                    throw new RuntimeException();\n                }\n                if (readLen <= 0) {\n                    throw new MyInput.EndOfFileRuntimeException();\n                }\n            }\n            return buffer[pos++];\n        }\n\n        public int nextInt() {\n            int len = 0;\n            str[len++] = nextChar();\n            len = reads(len, isSpace);\n            int i = 0;\n            int ret = 0;\n            if (str[0] == '-') {\n                i = 1;\n            }\n            for (; i < len; i++) ret = ret * 10 + str[i] - '0';\n            if (str[0] == '-') {\n                ret = -ret;\n            }\n            return ret;\n        }\n\n        public char nextChar() {\n            while (true) {\n                final int c = read();\n                if (!isSpace[c]) {\n                    return (char) c;\n                }\n            }\n        }\n\n        int reads(int len, boolean[] accept) {\n            try {\n                while (true) {\n                    final int c = read();\n                    if (accept[c]) {\n                        break;\n                    }\n                    if (str.length == len) {\n                        char[] rep = new char[str.length * 3 / 2];\n                        System.arraycopy(str, 0, rep, 0, str.length);\n                        str = rep;\n                    }\n                    str[len++] = (char) c;\n                }\n            } catch (MyInput.EndOfFileRuntimeException e) {\n            }\n            return len;\n        }\n\n        public int[] nextIntArray(final int n) {\n            final int[] res = new int[n];\n            for (int i = 0; i < n; i++) {\n                res[i] = nextInt();\n            }\n            return res;\n        }\n\n        static class EndOfFileRuntimeException extends RuntimeException {\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        FastScanner in = new FastScanner(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskF solver = new TaskF();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskF {\n        final int N = (int) (1e7 + 100);\n        boolean[] isPrime = new boolean[N];\n\n        public void solve(int testNumber, FastScanner in, PrintWriter out) {\n            Arrays.fill(isPrime, true);\n            isPrime[0] = false;\n            isPrime[1] = false;\n            for (int i = 2; i < N; i++) {\n                for (int j = i + i; j < N; j += i) {\n                    isPrime[j] = false;\n                }\n            }\n\n            int n = in.nextInt();\n            int[] x = new int[n];\n            for (int i = 0; i < n; i++) {\n                x[i] = in.nextInt();\n            }\n\n            int[] d = new int[n];\n            for (int i = 0; i < n; i++) {\n                d[i] = 3 * (i + 1);\n                for (int j = 0; j < i; j++) {\n                    if (x[i] - x[j] == 1) {\n                        continue;\n                    }\n\n                    int cur = f(x[i] - x[j] + 1);\n                    for (int k = j; k < i; k++) {\n                        int len = x[k + 1] - x[k];\n                        cur += f(len);\n                    }\n                    if (j > 0) {\n                        cur += d[j - 1];\n                    }\n                    d[i] = Math.min(d[i], cur);\n                }\n\n                if (i > 0 && x[i] == x[i - 1] + 1) {\n                    int cur = 2;\n                    if (i > 1) {\n                        cur += d[i - 1];\n                    }\n                    d[i] = Math.min(d[i], cur);\n                }\n            }\n            out.println(d[n - 1]);\n        }\n\n        private int f(int len) {\n            if (len == 1) {\n                return 0;\n            }\n            if (isPrime[len]) {\n                return 1;\n            }\n            if (len % 2 == 0) {\n                return 2;\n            }\n            return 4;\n        }\n\n    }\n\n    static class FastScanner {\n        private BufferedReader in;\n        private StringTokenizer st;\n\n        public FastScanner(InputStream stream) {\n            in = new BufferedReader(new InputStreamReader(stream));\n        }\n\n        public String next() {\n            while (st == null || !st.hasMoreTokens()) {\n                try {\n                    st = new StringTokenizer(in.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return st.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.io.IOException;\nimport java.io.Reader;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.stream.Stream;\nimport java.util.Optional;\nimport java.io.BufferedReader;\nimport java.util.Comparator;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author tanzaku\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        MyInput in = new MyInput(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskF solver = new TaskF();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskF {\n        public void solve(int testNumber, MyInput in, PrintWriter out) {\n            int n = in.nextInt();\n            List<Integer> ones = new ArrayList<>();\n            int[] xs = in.nextIntArray(n);\n            for (int i = 0; i < n; i++) {\n                if (i == 0 || xs[i] - xs[i - 1] != 1) ones.add(xs[i]);\n                if (i == n - 1 || xs[i + 1] - xs[i] != 1) ones.add(xs[i] + 1);\n            }\n\n            boolean[] isPrime = eratosthenes(10000000);\n            int m = ones.size();\n            int S = m * 2, T = S + 1;\n            PushRelabelBaseMaxFlow flow = new PushRelabelBaseMaxFlow(T + 1);\n//        Dinic flow = new Dinic(T + 1);\n            int[] cnt = new int[2];\n            for (int i = 0; i < ones.size(); i++) {\n                cnt[ones.get(i) % 2]++;\n                flow.addEdge(S, i, 1);\n                flow.addEdge(i + m, T, 1);\n                for (int j = 0; j < i; j++) {\n                    final int a = ones.get(i);\n                    final int b = ones.get(j);\n                    if (a == b) break;\n                    if (a - b != 2 && isPrime[a - b]) {\n                        flow.addEdge(i, j + m, 1);\n                        flow.addEdge(j, i + m, 1);\n                    }\n                }\n            }\n            int f1 = (int) (flow.relabelToFront(S, T) / 2);\n//        int f1 = (int)(flow.MaxFlow(S, T) / 2);\n            cnt[0] -= f1;\n            cnt[1] -= f1;\n            int f2 = cnt[0] / 2 + cnt[1] / 2;\n            int f3 = cnt[0] % 2 != 0 ? 1 : 0;\n            out.println(f1 * 1 + f2 * 2 + f3 * 3);\n        }\n\n        private static boolean[] eratosthenes(int n) {\n            final boolean[] p = new boolean[n + 1];\n            Arrays.fill(p, true);\n            p[0] = p[1] = false;\n            for (int i = 2; i * i <= n; i++) {\n                if (p[i]) {\n                    for (int j = i * i; j <= n; j += i) {\n                        p[j] = false;\n                    }\n                }\n            }\n            return p;\n        }\n\n    }\n\n    static class PushRelabelBaseMaxFlow {\n        int V;\n        PushRelabelBaseMaxFlow.Vertex[] vertices;\n\n        public PushRelabelBaseMaxFlow(int V) {\n            this.V = V;\n            vertices = new PushRelabelBaseMaxFlow.Vertex[V];\n            for (int i = 0; i < V; i++) vertices[i] = new PushRelabelBaseMaxFlow.Vertex(i);\n        }\n\n        public void addEdge(int s, int t, int cap) {\n            PushRelabelBaseMaxFlow.Edge e1 = new PushRelabelBaseMaxFlow.Edge(vertices[s], vertices[t], cap);\n            PushRelabelBaseMaxFlow.Edge e2 = new PushRelabelBaseMaxFlow.Edge(vertices[t], vertices[s], 0);\n            e1.rev = e2;\n            e2.rev = e1;\n        }\n\n        private void initializePreflow(PushRelabelBaseMaxFlow.Vertex S) {\n            for (PushRelabelBaseMaxFlow.Vertex v : vertices) {\n                v.clear();\n            }\n            S.height = V;\n            for (PushRelabelBaseMaxFlow.Edge e : S.edges) {\n                e.v.excessFlow += e.capacity;\n                e.u.excessFlow -= e.capacity;\n                e.rev.capacity += e.capacity;\n                e.capacity = 0;\n            }\n        }\n\n        public long relabelToFront(int s, int t) {\n            initializePreflow(vertices[s]);\n            PushRelabelBaseMaxFlow.Vertex[] L = new PushRelabelBaseMaxFlow.Vertex[V - 1];\n            for (int i = 0, j = 0; i < V; i++) {\n                if (i != s && i != t) L[j++] = vertices[i];\n            }\n\n            int i = 0;\n            PushRelabelBaseMaxFlow.Vertex cur = L[i];\n            while (cur != null) {\n                int h0 = cur.height;\n                cur.discharge();\n                if (cur.height > h0) {\n                    L[i = 0] = cur;\n                }\n                PushRelabelBaseMaxFlow.Vertex tmp = L[++i];\n                L[i] = cur;\n                cur = tmp;\n            }\n\n            return vertices[t].excessFlow;\n        }\n\n        private static class Edge {\n            PushRelabelBaseMaxFlow.Vertex u;\n            PushRelabelBaseMaxFlow.Vertex v;\n            PushRelabelBaseMaxFlow.Edge rev;\n            long capacity;\n\n            public Edge(PushRelabelBaseMaxFlow.Vertex s, PushRelabelBaseMaxFlow.Vertex t, long cap) {\n                u = s;\n                v = t;\n                capacity = cap;\n                s.edges.add(this);\n            }\n\n            boolean canPush() {\n                return capacity > 0 && u.height == v.height + 1 && u.isOverflow();\n            }\n\n            void push() {\n                final long f = Math.min(u.excessFlow, capacity);\n                capacity -= f;\n                rev.capacity += f;\n                u.excessFlow -= f;\n                v.excessFlow += f;\n            }\n\n\n            public String toString() {\n                return String.format(\"[Edge u=%d(%d), v=%d(%d), c=%d]\", u.id, u.height, v.id, v.height, capacity);\n            }\n\n        }\n\n        static class Vertex {\n            final int id;\n            int height;\n            int excessFlow;\n            List<PushRelabelBaseMaxFlow.Edge> edges = new ArrayList<>();\n\n            public Vertex(int id) {\n                this.id = id;\n            }\n\n            void clear() {\n                height = 0;\n                excessFlow = 0;\n            }\n\n            boolean isOverflow() {\n                return excessFlow > 0;\n            }\n\n            void relabel() {\n                final int h = edges.stream().filter(e -> e.capacity > 0)\n                        .map(a -> a.v.height)\n                        .min(Comparator.naturalOrder())\n                        .get();\n                if (!isOverflow() || height > h) {\n                    throw new RuntimeException();\n                }\n                height = h + 1;\n            }\n\n            void discharge() {\n                while (isOverflow()) {\n                    for (PushRelabelBaseMaxFlow.Edge e : edges) {\n                        while (e.canPush()) e.push();\n                        if (!isOverflow()) return;\n                    }\n                    relabel();\n                }\n            }\n\n\n            public String toString() {\n                return String.format(\"[Vertex id=%d, h=%d, ex=%d, es=%s]\", id, height, excessFlow, edges);\n            }\n\n        }\n\n    }\n\n    static class MyInput {\n        private final BufferedReader in;\n        private static int pos;\n        private static int readLen;\n        private static final char[] buffer = new char[1024 * 8];\n        private static char[] str = new char[500 * 8 * 2];\n        private static boolean[] isDigit = new boolean[256];\n        private static boolean[] isSpace = new boolean[256];\n        private static boolean[] isLineSep = new boolean[256];\n\n        static {\n            for (int i = 0; i < 10; i++) {\n                isDigit['0' + i] = true;\n            }\n            isDigit['-'] = true;\n            isSpace[' '] = isSpace['\\r'] = isSpace['\\n'] = isSpace['\\t'] = true;\n            isLineSep['\\r'] = isLineSep['\\n'] = true;\n        }\n\n        public MyInput(InputStream is) {\n            in = new BufferedReader(new InputStreamReader(is));\n        }\n\n        public int read() {\n            if (pos >= readLen) {\n                pos = 0;\n                try {\n                    readLen = in.read(buffer);\n                } catch (IOException e) {\n                    throw new RuntimeException();\n                }\n                if (readLen <= 0) {\n                    throw new MyInput.EndOfFileRuntimeException();\n                }\n            }\n            return buffer[pos++];\n        }\n\n        public int nextInt() {\n            int len = 0;\n            str[len++] = nextChar();\n            len = reads(len, isSpace);\n            int i = 0;\n            int ret = 0;\n            if (str[0] == '-') {\n                i = 1;\n            }\n            for (; i < len; i++) ret = ret * 10 + str[i] - '0';\n            if (str[0] == '-') {\n                ret = -ret;\n            }\n            return ret;\n        }\n\n        public char nextChar() {\n            while (true) {\n                final int c = read();\n                if (!isSpace[c]) {\n                    return (char) c;\n                }\n            }\n        }\n\n        int reads(int len, boolean[] accept) {\n            try {\n                while (true) {\n                    final int c = read();\n                    if (accept[c]) {\n                        break;\n                    }\n                    if (str.length == len) {\n                        char[] rep = new char[str.length * 3 / 2];\n                        System.arraycopy(str, 0, rep, 0, str.length);\n                        str = rep;\n                    }\n                    str[len++] = (char) c;\n                }\n            } catch (MyInput.EndOfFileRuntimeException e) {\n            }\n            return len;\n        }\n\n        public int[] nextIntArray(final int n) {\n            final int[] res = new int[n];\n            for (int i = 0; i < n; i++) {\n                res[i] = nextInt();\n            }\n            return res;\n        }\n\n        static class EndOfFileRuntimeException extends RuntimeException {\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.util.Arrays;\nimport java.io.IOException;\nimport java.io.UncheckedIOException;\nimport java.io.Closeable;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in Actual solution is at the top\n * \n * @author daltao\n */\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        Thread thread = new Thread(null, new TaskAdapter(), \"daltao\", 1 << 27);\n        thread.start();\n        thread.join();\n    }\n\n    static class TaskAdapter implements Runnable {\n        @Override\n        public void run() {\n            InputStream inputStream = System.in;\n            OutputStream outputStream = System.out;\n            FastInput in = new FastInput(inputStream);\n            FastOutput out = new FastOutput(outputStream);\n            TaskD solver = new TaskD();\n            solver.solve(1, in, out);\n            out.close();\n        }\n    }\n    static class TaskD {\n        NumberTheory.EulerSieve es = new NumberTheory.EulerSieve(10000000);\n        int[][][] dp;\n        int[] xs;\n        int n;\n\n        public void solve(int testNumber, FastInput in, FastOutput out) {\n            n = in.readInt();\n            xs = new int[n];\n            for (int i = 0; i < n; i++) {\n                xs[i] = in.readInt();\n            }\n\n            dp = new int[2][n][n];\n            SequenceUtils.deepFill(dp, -1);\n            int ans = dp(0, n - 1);\n            out.println(ans);\n        }\n\n        public int feeOnFlip(int len) {\n            if (len == 0) {\n                return 0;\n            }\n            if (len == 2) {\n                return 2;\n            }\n            if (es.isPrime(len)) {\n                return 1;\n            }\n            return len % 2 + 2;\n        }\n\n        public int dp(int l, int r) {\n            if (dp[0][l][r] == -1) {\n                if (l == r) {\n                    return dp[0][l][r] = feeOnFlip(1);\n                }\n                dp[0][l][r] = feeOnFlip(xs[r] - xs[l] + 1) + dpFlipped(l, r);\n                for (int i = l; i < r; i++) {\n                    dp[0][l][r] = Math.min(dp[0][l][r], dp(l, i) + dp(i + 1, r));\n                }\n            }\n            return dp[0][l][r];\n        }\n\n        public int dpFlipped(int l, int r) {\n            if (dp[1][l][r] == -1) {\n                if (l == r) {\n                    return dp[1][l][r] = 0;\n                }\n                if (l + 1 == r) {\n                    return dp[1][l][r] = feeOnFlip(xs[r] - xs[l] - 1);\n                }\n                // flip or sep\n                dp[1][l][r] = feeOnFlip(xs[r] - xs[l] - 1) + dp(l + 1, r - 1);\n                for (int i = l + 1; i < r; i++) {\n                    dp[1][l][r] = Math.min(dp[1][l][r], dpFlipped(l, i) + dpFlipped(i, r));\n                }\n            }\n            return dp[1][l][r];\n        }\n\n    }\n    static class NumberTheory {\n        public static class EulerSieve {\n            private int[] primes;\n            private boolean[] isComp;\n            private int primeLength;\n\n            public boolean isPrime(int x) {\n                if (x == 1) {\n                    return false;\n                }\n                return !isComp[x];\n            }\n\n            public EulerSieve(int limit) {\n                isComp = new boolean[limit + 1];\n                primes = new int[limit + 1];\n                primeLength = 0;\n                for (int i = 2; i <= limit; i++) {\n                    if (!isComp[i]) {\n                        primes[primeLength++] = i;\n                    }\n                    for (int j = 0, until = limit / i; j < primeLength && primes[j] <= until; j++) {\n                        int pi = primes[j] * i;\n                        isComp[pi] = true;\n                        if (i % primes[j] == 0) {\n                            break;\n                        }\n                    }\n                }\n            }\n\n        }\n\n    }\n    static class SequenceUtils {\n        public static void deepFill(Object array, int val) {\n            if (!array.getClass().isArray()) {\n                throw new IllegalArgumentException();\n            }\n            if (array instanceof int[]) {\n                int[] intArray = (int[]) array;\n                Arrays.fill(intArray, val);\n            } else {\n                Object[] objArray = (Object[]) array;\n                for (Object obj : objArray) {\n                    deepFill(obj, val);\n                }\n            }\n        }\n\n    }\n    static class FastInput {\n        private final InputStream is;\n        private byte[] buf = new byte[1 << 13];\n        private int bufLen;\n        private int bufOffset;\n        private int next;\n\n        public FastInput(InputStream is) {\n            this.is = is;\n        }\n\n        private int read() {\n            while (bufLen == bufOffset) {\n                bufOffset = 0;\n                try {\n                    bufLen = is.read(buf);\n                } catch (IOException e) {\n                    bufLen = -1;\n                }\n                if (bufLen == -1) {\n                    return -1;\n                }\n            }\n            return buf[bufOffset++];\n        }\n\n        public void skipBlank() {\n            while (next >= 0 && next <= 32) {\n                next = read();\n            }\n        }\n\n        public int readInt() {\n            int sign = 1;\n\n            skipBlank();\n            if (next == '+' || next == '-') {\n                sign = next == '+' ? 1 : -1;\n                next = read();\n            }\n\n            int val = 0;\n            if (sign == 1) {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 + next - '0';\n                    next = read();\n                }\n            } else {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 - next + '0';\n                    next = read();\n                }\n            }\n\n            return val;\n        }\n\n    }\n    static class FastOutput implements AutoCloseable, Closeable {\n        private StringBuilder cache = new StringBuilder(10 << 20);\n        private final Writer os;\n\n        public FastOutput(Writer os) {\n            this.os = os;\n        }\n\n        public FastOutput(OutputStream os) {\n            this(new OutputStreamWriter(os));\n        }\n\n        public FastOutput println(int c) {\n            cache.append(c).append('\\n');\n            return this;\n        }\n\n        public FastOutput flush() {\n            try {\n                os.append(cache);\n                os.flush();\n                cache.setLength(0);\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n            return this;\n        }\n\n        public void close() {\n            flush();\n            try {\n                os.close();\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "***"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.*;\n\npublic class Main {\n    static long __startTime = System.currentTimeMillis();\n\n    public static void main(String[] args) {\n        InputReader in = new InputReader(System.in);\n        PrintWriter out = new PrintWriter(System.out);\n\n        int n = in.nextInt();\n\n        int[] x = new int[n];\n        for (int i = 0; i < n ; i++) {\n            x[i] = in.nextInt();\n        }\n\n        Set<Integer> set = new TreeSet<>();\n        for (int i = 0; i < n ; i++) {\n            for (int a = x[i] ; a <= x[i]+1; a++) {\n                if (set.contains(a)) {\n                    set.remove(a);\n                } else {\n                    set.add(a);\n                }\n            }\n        }\n\n        List<Integer> r = new ArrayList<>(set);\n        int nodes = r.size();\n        MaxFlowDinic maxFlow = new MaxFlowDinic();\n        maxFlow.init(nodes+2);\n\n        int src = nodes;\n        int dst = nodes+1;\n\n        int odd = 0;\n        int even = 0;\n        for (int i = 0; i < nodes ; i++) {\n            if (r.get(i) % 2 == 0) {\n                even++;\n                maxFlow.edge(src, i, 1);\n            } else {\n                odd++;\n                maxFlow.edge(i, dst, 1);\n            }\n        }\n        for (int i = 0; i < nodes ; i++) {\n            for (int j = 0 ; j < nodes ; j++) {\n                if (r.get(i) % 2 == 0 && r.get(j) % 2 == 1) {\n                    int d = Math.abs(r.get(i) - r.get(j));\n                    if (isPrime(d)) {\n                        maxFlow.edge(i, j, 1);\n                    }\n                }\n            }\n        }\n\n        int F = maxFlow.max_flow(src, dst);\n        odd -= F;\n        even -= F;\n\n        int total = F + (odd / 2) * 2 + (even / 2) * 2;\n        if (odd % 2 == 1 && even % 2 == 1) {\n            total += 3;\n        }\n        out.println(total);\n        out.flush();\n    }\n\n    static boolean isPrime(int x) {\n        if (x == 1) {\n            return false;\n        }\n        for (int i = 2 ; i * i <= x ; i++) {\n            if (x % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static class MaxFlowDinic {\n        public List<int[]>[] graph;\n        public int[] deg;\n\n        public int[] level;\n        public int[] itr;\n\n        public int[] que;\n\n        @SuppressWarnings(\"unchecked\")\n        public void init(int size) {\n            graph = new List[size];\n            for (int i = 0; i < size ; i++) {\n                graph[i] = new ArrayList<int[]>();\n            }\n            deg = new int[size];\n            level = new int[size];\n            itr = new int[size];\n            que = new int[size+10];\n        }\n        public void edge(int from, int to, int cap) {\n            int fdeg = deg[from];\n            int tdeg = deg[to];\n            graph[from].add(new int[]{to, cap, tdeg});\n            graph[to].add(new int[]{from, 0, fdeg});\n            deg[from]++;\n            deg[to]++;\n        }\n\n        public int dfs(int v, int t, int f) {\n            if (v == t) return f;\n            for (int i = itr[v] ; i < graph[v].size() ; i++) {\n                itr[v] = i;\n                int[] e = graph[v].get(i);\n                if (e[1] > 0 && level[v] < level[e[0]]) {\n                    int d = dfs(e[0], t, Math.min(f, e[1]));\n                    if (d > 0) {\n                        e[1] -= d;\n                        graph[e[0]].get(e[2])[1] += d;\n                        return d;\n                    }\n                }\n            }\n            return 0;\n        }\n\n        public void bfs(int s) {\n            Arrays.fill(level, -1);\n            int qh = 0;\n            int qt = 0;\n            level[s] = 0;\n            que[qh++] = s;\n            while (qt < qh) {\n                int v = que[qt++];\n                for (int i = 0; i < graph[v].size() ; i++) {\n                    int[] e = graph[v].get(i);\n                    if (e[1] > 0 && level[e[0]] < 0) {\n                        level[e[0]] = level[v] + 1;\n                        que[qh++] = e[0];\n                    }\n                }\n            }\n        }\n\n        public int max_flow(int s, int t) {\n            int flow = 0;\n            while (true) {\n                bfs(s);\n                if (level[t] < 0) {\n                    return flow;\n                }\n                Arrays.fill(itr, 0);\n                while (true) {\n                    int f = dfs(s, t, Integer.MAX_VALUE);\n                    if (f <= 0) {\n                        break;\n                    }\n                    flow += f;\n                }\n            }\n        }\n    }\n\n    private static void printTime(String label) {\n        debug(label, System.currentTimeMillis() - __startTime);\n    }\n\n    public static void debug(Object... o) {\n        System.err.println(Arrays.deepToString(o));\n    }\n\n    public static class InputReader {\n        private static final int BUFFER_LENGTH = 1 << 12;\n        private InputStream stream;\n        private byte[] buf = new byte[BUFFER_LENGTH];\n        private int curChar;\n        private int numChars;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        private int next() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0)\n                    return -1;\n            }\n            return buf[curChar++];\n        }\n\n        public char nextChar() {\n            return (char) skipWhileSpace();\n        }\n\n        public String nextToken() {\n            int c = skipWhileSpace();\n            StringBuilder res = new StringBuilder();\n            do {\n                res.append((char) c);\n                c = next();\n            } while (!isSpaceChar(c));\n            return res.toString();\n        }\n\n        public int nextInt() {\n            return (int) nextLong();\n        }\n\n        public long nextLong() {\n            int c = skipWhileSpace();\n            long sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = next();\n            }\n            long res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = next();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public double nextDouble() {\n            return Double.valueOf(nextToken());\n        }\n\n        int skipWhileSpace() {\n            int c = next();\n            while (isSpaceChar(c)) {\n                c = next();\n            }\n            return c;\n        }\n\n        boolean isSpaceChar(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n//\t\tlong t = System.currentTimeMillis();\n\t\tnew Main().run();\n//\t\tSystem.err.println(System.currentTimeMillis() - t);\n\t}\n\n\tint min_cost_flow(int s, int t, ArrayList<Edge>[] g) {\n\t\tclass Vertice implements Comparable<Vertice> {\n\t\t\tint id;\n\t\t\tlong dist;\n\n\t\t\tpublic Vertice(int id, long dist) {\n\t\t\t\tthis.id = id;\n\t\t\t\tthis.dist = dist;\n\t\t\t}\n\n\t\t\tpublic int compareTo(Vertice o) {\n\t\t\t\treturn Long.compare(this.dist, o.dist);\n\t\t\t};\n\t\t}\n\n\t\tint n = g.length;\n\n\t\tint min_cost = 0;\n\t\tg[t].add(new Edge(t, s, (1 << 30), 0));\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < g[i].size(); j++) {\n\t\t\t\tEdge e = g[i].get(j);\n\t\t\t\tg[e.src].get(j).rev_id = g[e.dst].size();\n\t\t\t\tg[e.dst].add(new Edge(e.dst, e.src, 0, -e.cost));\n\t\t\t\tg[e.dst].get(g[e.dst].size() - 1).rev_id = j;\n\t\t\t}\n\t\t}\n\n\t\tlong[] potential = new long[n];\n\t\tint[] excess = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (Edge e : g[i]) {\n\t\t\t\tif (e.cost < 0) {\n\t\t\t\t\te.add_flow(e.cap);\n\t\t\t\t\texcess[e.dst] += e.flow;\n\t\t\t\t\texcess[e.src] -= e.flow;\n\t\t\t\t\tg[e.dst].get(e.rev_id).add_flow(-e.cap);\n\t\t\t\t\tmin_cost += e.cost * e.flow;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tArrayList<Integer> sink_v = new ArrayList<>();\n\t\tArrayDeque<Integer> source_v = new ArrayDeque<>();\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (excess[i] < 0)\n\t\t\t\tsink_v.add(i);\n\t\t\telse if (excess[i] > 0)\n\t\t\t\tsource_v.add(i);\n\t\t}\n\t\twhile (!source_v.isEmpty()) {\n\n\t\t\tPriorityQueue<Vertice> priority_queue = new PriorityQueue<>();\n\t\t\tint[] pre_v = new int[n];\n\t\t\tint[] pre_e = new int[n];\n\t\t\tlong[] dist = new long[n];\n\t\t\tArrays.fill(pre_v, -1);\n\t\t\tArrays.fill(pre_e, -1);\n\t\t\tArrays.fill(dist, 1L << 60);\n\t\t\tint source = source_v.poll();\n\t\t\tdist[source] = 0;\n\t\t\tpre_v[source] = -1;\n\t\t\tpre_e[source] = -1;\n\t\t\tboolean[] looked = new boolean[n];\n\n\t\t\tpriority_queue.add(new Vertice(source, 0));\n\n\t\t\twhile (!priority_queue.isEmpty()) {\n\t\t\t\tint v = priority_queue.poll().id;\n\t\t\t\tif (looked[v])\n\t\t\t\t\tcontinue;\n\t\t\t\telse\n\t\t\t\t\tlooked[v] = true;\n\t\t\t\tfor (int i = 0; i < g[v].size(); i++) {\n\t\t\t\t\tEdge e = g[v].get(i);\n\t\t\t\t\tif (e.residue > 0) {\n\t\t\t\t\t\tif (dist[e.dst] > dist[v] + e.cost - potential[v] + potential[e.dst]) {\n\t\t\t\t\t\t\tdist[e.dst] = dist[v] + e.cost - potential[v] + potential[e.dst];\n\n\t\t\t\t\t\t\tpriority_queue.add(new Vertice(e.dst, dist[e.dst]));\n\t\t\t\t\t\t\tpre_v[e.dst] = v;\n\t\t\t\t\t\t\tpre_e[e.dst] = i;\n\t\t\t\t\t\t\tlooked[e.dst] = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint sink = -1;\n\t\t\tfor (int i = 0; i < sink_v.size(); i++) {\n\t\t\t\tif (pre_v[sink_v.get(i)] != -1) {\n\t\t\t\t\tsink = sink_v.get(i);\n\t\t\t\t\tsink_v.remove(i);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (sink == -1) {\n\t\t\t\tsource_v.add(source);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tif (dist[i] < (1L << 60))\n\t\t\t\t\tpotential[i] -= dist[i];\n\t\t\t\telse\n\t\t\t\t\tpotential[i] -= (1 << 30);\n\t\t\t}\n\n\t\t\tint delta = Math.min(Math.abs(excess[source]), Math.abs(excess[sink]));\n\n\t\t\tfor (int i = sink; i != source; i = pre_v[i]) {\n\t\t\t\tdelta = Math.min(delta, g[pre_v[i]].get(pre_e[i]).residue);\n\t\t\t}\n\t\t\tfor (int i = sink; i != source; i = pre_v[i]) {\n\t\t\t\tEdge e = g[pre_v[i]].get(pre_e[i]);\n\t\t\t\te.add_flow(delta);\n\t\t\t\tg[i].get(e.rev_id).add_flow(-delta);\n\t\t\t\tmin_cost += delta * e.cost;\n\t\t\t}\n\t\t\texcess[sink] += delta;\n\t\t\texcess[source] -= delta;\n\t\t\tif (excess[sink] < 0)\n\t\t\t\tsink_v.add(sink);\n\t\t\tif (excess[source] > 0)\n\t\t\t\tsource_v.add(source);\n\n\t\t}\n\n\t\treturn min_cost;\n\t}\n\n\tclass Edge {\n\t\tint src;\n\t\tint dst;\n\t\tint cap;\n\t\tint cost;\n\t\tint residue;\n\t\tint flow = 0;\n\t\tint rev_id = -1;\n\n\t\tEdge(int src, int dst, int cap, int cost) {\n\t\t\tthis.src = src;\n\t\t\tthis.dst = dst;\n\t\t\tthis.cap = cap;\n\t\t\tthis.cost = cost;\n\t\t\tresidue = this.cap - flow;\n\t\t}\n\n\t\tvoid add_flow(int flow) {\n\t\t\tthis.flow += flow;\n\t\t\tresidue = cap - this.flow;\n\t\t}\n\n\t}\n\n\tboolean[] isPrime = new boolean[1_000_000_3];\n\t{\n\t\tArrays.fill(isPrime, true);\n\t\tisPrime[0] = false;\n\t\tisPrime[1] = false;\n\t\tfor (int i = 2; i < isPrime.length; ++i) {\n\t\t\tif (isPrime[i]) {\n\t\t\t\tfor (int j = 2 * i; j < isPrime.length; j += i) {\n\t\t\t\t\tisPrime[j] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tisPrime[2] = false;\n\t}\n\n\tvoid solve(int n, int[] x) {\n\t\tArrayList<Integer> list = new ArrayList<>();\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tint j = i;\n\t\t\twhile (j + 1 < n && x[j] + 1 == x[j + 1]) {\n\t\t\t\t++j;\n\t\t\t}\n\t\t\tlist.add(x[i]);\n\t\t\tlist.add(x[j] + 1);\n\t\t\ti = j;\n\t\t}\n\t\tx = new int[list.size()];\n\t\tint even = 0, odd = 0;\n\t\tfor (int i = 0; i < x.length; ++i) {\n\t\t\tx[i] = list.get(i);\n\t\t\tif (x[i] % 2 == 0)\n\t\t\t\t++even;\n\t\t\telse\n\t\t\t\t++odd;\n\t\t}\n\t\tint[][] dist = new int[list.size()][list.size()];\n\t\tfor (int i = 0; i < dist.length; ++i) {\n\t\t\tfor (int j = 0; j < dist[i].length; ++j) {\n\t\t\t\tif (i == j)\n\t\t\t\t\tcontinue;\n\t\t\t\tint v = Math.abs(x[i] - x[j]);\n\t\t\t\tif (v % 2 == 1) {// 偶奇をつなぐ\n\t\t\t\t\tif (isPrime[v])\n\t\t\t\t\t\tdist[i][j] = 1;// 全てに優先する\n\t\t\t\t\telse\n\t\t\t\t\t\tdist[i][j] = Integer.MAX_VALUE / 3;\n\t\t\t\t} else if (v % 2 == 0) {// パリティの等しいものを繋ぐ.(例外処理2=5-3,4=9-5)\n\t\t\t\t\tdist[i][j] = 2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tArrayList<Edge>[] g = new ArrayList[list.size() + 2];\n\t\tfor (int i = 0; i < g.length; ++i) {\n\t\t\tg[i] = new ArrayList<>();\n\t\t}\n\t\tint src = g.length - 2;\n\t\tint dst = g.length - 1;\n\t\tfor (int i = 0; i < dist.length; i++) {\n\t\t\tfor (int j = 1; j < dist[i].length; j++) {\n\t\t\t\tif (x[i] % 2 == 0 && x[j] % 2 == 1)\n\t\t\t\t\tg[i].add(new Edge(i, j, 1, dist[i][j]));\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < list.size(); ++i) {\n\t\t\tif (x[i] % 2 == 0)\n\t\t\t\tg[src].add(new Edge(src, i, 1, 0));\n\t\t\telse\n\t\t\t\tg[i].add(new Edge(i, dst, 1, 0));\n\t\t}\n\t\tint ret = 0;\n\t\tint c = min_cost_flow(src, dst, g);\n\t\tret = c + (even - c) / 2 * 2 + (odd - c) / 2 * 2;\n\t\tif ((even - c) % 2 == 1)\n\t\t\tret += 3;\n\t\tSystem.out.println(ret);\n\t}\n\n\tpublic void run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint[] x = new int[n];\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tx[i] = sc.nextInt();\n\t\t}\n\t\tsolve(n, x);\n\t}\n\n\tstatic void tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.io.IOException;\nimport java.io.Reader;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.io.BufferedReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author tanzaku\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        MyInput in = new MyInput(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskF solver = new TaskF();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskF {\n        public void solve(int testNumber, MyInput in, PrintWriter out) {\n            int n = in.nextInt();\n            List<Integer> ones = new ArrayList<>();\n            int[] xs = in.nextIntArray(n);\n            for (int i = 0; i < n; i++) {\n                if (i == 0 || xs[i] - xs[i - 1] != 1) ones.add(xs[i]);\n                if (i == n - 1 || xs[i + 1] - xs[i] != 1) ones.add(xs[i] + 1);\n            }\n\n            boolean[] isPrime = eratosthenes(10000000);\n            int m = ones.size();\n            int S = m * 2, T = S + 1;\n//        PushRelabelBaseMaxFlow flow = new PushRelabelBaseMaxFlow(T + 1);\n            Dinic flow = new Dinic(T + 1);\n            int[] cnt = new int[2];\n            for (int i = 0; i < ones.size(); i++) {\n                cnt[ones.get(i) % 2]++;\n                flow.addEdge(S, i, 1);\n                flow.addEdge(i + m, T, 1);\n                for (int j = 0; j < i; j++) {\n                    final int a = ones.get(i);\n                    final int b = ones.get(j);\n                    if (a == b) break;\n                    if (a - b != 2 && isPrime[a - b]) {\n                        flow.addEdge(i, j + m, 1);\n                        flow.addEdge(j, i + m, 1);\n                    }\n                }\n            }\n//        int f1 = (int)(flow.relabelToFront(S, T) / 2);\n            int f1 = (int) (flow.MaxFlow(S, T) / 2);\n            cnt[0] -= f1;\n            cnt[1] -= f1;\n            int f2 = cnt[0] / 2 + cnt[1] / 2;\n            int f3 = cnt[0] % 2 != 0 ? 1 : 0;\n            out.println(f1 * 1 + f2 * 2 + f3 * 3);\n        }\n\n        private static boolean[] eratosthenes(int n) {\n            final boolean[] p = new boolean[n + 1];\n            Arrays.fill(p, true);\n            p[0] = p[1] = false;\n            for (int i = 2; i * i <= n; i++) {\n                if (p[i]) {\n                    for (int j = i * i; j <= n; j += i) {\n                        p[j] = false;\n                    }\n                }\n            }\n            return p;\n        }\n\n    }\n\n    static class Dinic {\n        final int INF = 1 << 29;\n        Dinic.AdjListGraph g;\n        int[] level;\n        int[] iter;\n        int[] q;\n        List<int[]> es = new ArrayList<>();\n\n        void bfs(int s) {\n            for (int i = 0; i < level.length; i++) level[i] = -1;\n//\t\tQueue<Integer> q = new LinkedList<Integer>();\n            int qs = 0, qt = 0;\n            level[s] = 0;\n            q[qt++] = s;\n            while (qs != qt) {\n                int v = q[qs++];\n                for (int e = g.head[v]; e != -1; e = g.next[e]) {\n                    final int t = g.to[e];\n                    if (g.cap[e] > 0 && level[t] < 0) {\n                        level[t] = level[v] + 1;\n                        q[qt++] = t;\n                    }\n                }\n            }\n        }\n\n        int dfs(int v, int t, int f) {\n            if (v == t) return f;\n            for (int i = iter[v]; i != -1; i = iter[v] = g.next[i]) {\n                if (g.cap[i] > 0 && level[v] < level[g.to[i]]) {\n                    int d = dfs(g.to[i], t, Math.min(f, g.cap[i]));\n                    if (d > 0) {\n                        g.cap[i] -= d;\n                        g.cap[g.rev[i]] += d;\n                        return d;\n                    }\n                }\n            }\n            return 0;\n        }\n\n        public void addEdge(int from, int to, int cap) {\n            es.add(new int[]{from, to, cap,});\n//\t\tg.addEdge(from, to, cap, g.m + 1);\n//\t\tg.addEdge(to, from, 0, g.m - 1);\n        }\n\n        private void build() {\n            if (g == null) {\n                g = new Dinic.AdjListGraph(level.length, 2 * es.size() * 2);\n                for (int[] e : es) {\n                    g.addEdge(e[0], e[1], e[2], g.m + 1);\n                    g.addEdge(e[1], e[0], 0, g.m - 1);\n                }\n            }\n        }\n\n        public int MaxFlow(int s, int t) {\n            build();\n            int flow = 0;\n            for (; ; ) {\n                bfs(s);\n                if (level[t] < 0) return flow;\n                for (int i = 0; i < iter.length; i++) iter[i] = g.head[i];\n                for (int f = 0; (f = dfs(s, t, INF)) > 0; )\n                    flow += f;\n            }\n        }\n\n        public Dinic(int size) {\n            level = new int[size];\n            iter = new int[size];\n            q = new int[size];\n        }\n\n        static class AdjListGraph {\n            int m;\n            int[] head;\n            int[] next;\n            int[] to;\n            int[] rev;\n            int[] cap;\n\n            public AdjListGraph(int V, int E) {\n                head = new int[V];\n                next = new int[E];\n                to = new int[E];\n                cap = new int[E];\n                rev = new int[E];\n                clear();\n            }\n\n            public void clear() {\n                m = 0;\n                Arrays.fill(head, -1);\n            }\n\n            public void addEdge(int s, int t, int c, int r) {\n                next[m] = head[s];\n                head[s] = m;\n                to[m] = t;\n                cap[m] = c;\n                rev[m++] = r;\n            }\n\n        }\n\n    }\n\n    static class MyInput {\n        private final BufferedReader in;\n        private static int pos;\n        private static int readLen;\n        private static final char[] buffer = new char[1024 * 8];\n        private static char[] str = new char[500 * 8 * 2];\n        private static boolean[] isDigit = new boolean[256];\n        private static boolean[] isSpace = new boolean[256];\n        private static boolean[] isLineSep = new boolean[256];\n\n        static {\n            for (int i = 0; i < 10; i++) {\n                isDigit['0' + i] = true;\n            }\n            isDigit['-'] = true;\n            isSpace[' '] = isSpace['\\r'] = isSpace['\\n'] = isSpace['\\t'] = true;\n            isLineSep['\\r'] = isLineSep['\\n'] = true;\n        }\n\n        public MyInput(InputStream is) {\n            in = new BufferedReader(new InputStreamReader(is));\n        }\n\n        public int read() {\n            if (pos >= readLen) {\n                pos = 0;\n                try {\n                    readLen = in.read(buffer);\n                } catch (IOException e) {\n                    throw new RuntimeException();\n                }\n                if (readLen <= 0) {\n                    throw new MyInput.EndOfFileRuntimeException();\n                }\n            }\n            return buffer[pos++];\n        }\n\n        public int nextInt() {\n            int len = 0;\n            str[len++] = nextChar();\n            len = reads(len, isSpace);\n            int i = 0;\n            int ret = 0;\n            if (str[0] == '-') {\n                i = 1;\n            }\n            for (; i < len; i++) ret = ret * 10 + str[i] - '0';\n            if (str[0] == '-') {\n                ret = -ret;\n            }\n            return ret;\n        }\n\n        public char nextChar() {\n            while (true) {\n                final int c = read();\n                if (!isSpace[c]) {\n                    return (char) c;\n                }\n            }\n        }\n\n        int reads(int len, boolean[] accept) {\n            try {\n                while (true) {\n                    final int c = read();\n                    if (accept[c]) {\n                        break;\n                    }\n                    if (str.length == len) {\n                        char[] rep = new char[str.length * 3 / 2];\n                        System.arraycopy(str, 0, rep, 0, str.length);\n                        str = rep;\n                    }\n                    str[len++] = (char) c;\n                }\n            } catch (MyInput.EndOfFileRuntimeException e) {\n            }\n            return len;\n        }\n\n        public int[] nextIntArray(final int n) {\n            final int[] res = new int[n];\n            for (int i = 0; i < n; i++) {\n                res[i] = nextInt();\n            }\n            return res;\n        }\n\n        static class EndOfFileRuntimeException extends RuntimeException {\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\nusing Debug = System.Diagnostics.Debug;\nusing SB = System.Text.StringBuilder;\n//using System.Numerics;\nusing Number = System.Int64;\nusing static System.Math;\nusing C = System.Int32;\n//using static MathEx;\n//using P = System.Collections.Generic.KeyValuePair<int, int>;\nnamespace Program\n{\n    public class Solver\n    {\n        public void Solve()\n        {\n            var n = ri;\n            const int MAX = 10000005;\n            var a = new int[MAX];\n            var b = new int[MAX];\n            foreach (var x in sc.Integer(n))\n                a[x] = 1;\n            for (int i = 0; i < MAX - 1; i++)\n                b[i] = a[i + 1] ^ a[i];\n            var xs = Enumerate(2, x => new List<int>());\n            for (int i = 0; i < MAX; i++)\n                if (b[i] == 1) xs[i % 2].Add(i);\n\n\n            var isprime = MathEx.Sieve(10000005);\n            isprime[2] = false;\n\n            var m = xs[0].Count + xs[1].Count;\n            Debug.WriteLine(m);\n            Debug.WriteLine(xs[0].AsJoinedString());\n            Debug.WriteLine(xs[1].AsJoinedString());\n            var G = Enumerate(m + 2, x => new List<Edge>());\n            for (int i = 0; i < xs[0].Count; i++)\n                for (int j = 0; j < xs[1].Count; j++)\n                    if (isprime[Math.Abs(xs[0][i] - xs[1][j])]) G.AddDirectedEdge(i, xs[0].Count + j, 1);\n            var f = m;\n            var t = m + 1;\n            for (int i = 0; i < xs[0].Count; i++)\n                G.AddDirectedEdge(f, i, 1);\n            for (int i = 0; i < xs[1].Count; i++)\n                G.AddDirectedEdge(xs[0].Count + i, t, 1);\n            var mf = Flow.GetMaxFlow(G, f, t);\n            var ans = mf;\n            var u = xs[0].Count - mf;\n            var v = xs[1].Count - mf;\n            ans += 2 * (u / 2);\n            ans += 2 * (v / 2);\n            if (u % 2 == 1) ans += 3;\n            IO.Printer.Out.WriteLine(ans);\n\n        }\n        //*\n        int ri => sc.Integer();\n        long rl => sc.Long();\n        double rd => sc.Double();\n        string rs => sc.Scan();\n        char rc => sc.Char();\n\n        [System.Diagnostics.Conditional(\"DEBUG\")]\n        void put(params object[] a) => Debug.WriteLine(string.Join(\" \", a));\n\n        //*/\n        public IO.StreamScanner sc = new IO.StreamScanner(Console.OpenStandardInput());\n\n        static T[] Enumerate<T>(int n, Func<int, T> f)\n        {\n            var a = new T[n];\n            for (int i = 0; i < n; ++i) a[i] = f(i);\n            return a;\n        }\n        static void Swap<T>(ref T a, ref T b)\n        {\n            var tmp = a;\n            a = b;\n            b = tmp;\n        }\n    }\n}\n\n#region main\n\nstatic class Ex\n{\n    public static string AsString(this IEnumerable<char> ie)\n    {\n        return new string(ie.ToArray());\n    }\n\n    public static string AsJoinedString<T>(this IEnumerable<T> ie, string st = \" \")\n    {\n        return string.Join(st, ie);\n    }\n\n    public static void Main()\n    {\n        var solver = new Program.Solver();\n        solver.Solve();\n        Program.IO.Printer.Out.Flush();\n    }\n}\n\n#endregion\n#region Ex\n\nnamespace Program.IO\n{\n    using System.IO;\n    using System.Text;\n    using System.Globalization;\n\n    public class Printer: StreamWriter\n    {\n        static Printer()\n        {\n            Out = new Printer(Console.OpenStandardOutput()) { AutoFlush = false };\n        }\n\n        public static Printer Out { get; set; }\n\n        public override IFormatProvider FormatProvider\n        {\n            get { return CultureInfo.InvariantCulture; }\n        }\n\n        public Printer(Stream stream) : base(stream, new UTF8Encoding(false, true))\n        {\n        }\n\n        public Printer(Stream stream, Encoding encoding) : base(stream, encoding)\n        {\n        }\n\n        public void Write<T>(string format, T[] source)\n        {\n            base.Write(format, source.OfType<object>().ToArray());\n        }\n\n        public void WriteLine<T>(string format, T[] source)\n        {\n            base.WriteLine(format, source.OfType<object>().ToArray());\n        }\n    }\n\n    public class StreamScanner\n    {\n        public StreamScanner(Stream stream)\n        {\n            str = stream;\n        }\n\n        public readonly Stream str;\n        private readonly byte[] buf = new byte[1024];\n        private int len, ptr;\n        public bool isEof;\n\n        public bool IsEndOfStream\n        {\n            get { return isEof; }\n        }\n\n        private byte read()\n        {\n            if (isEof) return 0;\n            if (ptr < len) return buf[ptr++];\n            ptr = 0;\n            if ((len = str.Read(buf, 0, 1024)) > 0) return buf[ptr++];\n            isEof = true;\n            return 0;\n        }\n\n        public char Char()\n        {\n            byte b;\n            do b = read(); while ((b < 33 || 126 < b) && !isEof);\n            return (char)b;\n        }\n\n        public string Scan()\n        {\n            var sb = new StringBuilder();\n            for (var b = Char(); b >= 33 && b <= 126; b = (char)read())\n                sb.Append(b);\n            return sb.ToString();\n        }\n\n        public string ScanLine()\n        {\n            var sb = new StringBuilder();\n            for (var b = Char(); b != '\\n'; b = (char)read())\n                if (b == 0) break;\n                else if (b != '\\r') sb.Append(b);\n            return sb.ToString();\n        }\n\n        public long Long()\n        {\n            if (isEof) return long.MinValue;\n            long ret = 0;\n            byte b;\n            var ng = false;\n            do b = read(); while (b != 0 && b != '-' && (b < '0' || '9' < b));\n            if (b == 0) return long.MinValue;\n            if (b == '-')\n            {\n                ng = true;\n                b = read();\n            }\n            for (; ; b = read())\n            {\n                if (b < '0' || '9' < b)\n                    return ng ? -ret : ret;\n                ret = ret * 10 + b - '0';\n            }\n        }\n\n        public int Integer()\n        {\n            return (isEof) ? int.MinValue : (int)Long();\n        }\n\n        public double Double()\n        {\n            var s = Scan();\n            return s != \"\" ? double.Parse(s, CultureInfo.InvariantCulture) : double.NaN;\n        }\n\n        static T[] enumerate<T>(int n, Func<T> f)\n        {\n            var a = new T[n];\n            for (int i = 0; i < n; ++i) a[i] = f();\n            return a;\n        }\n\n        public char[] Char(int n)\n        {\n            return enumerate(n, Char);\n        }\n\n        public string[] Scan(int n)\n        {\n            return enumerate(n, Scan);\n        }\n\n        public double[] Double(int n)\n        {\n            return enumerate(n, Double);\n        }\n\n        public int[] Integer(int n)\n        {\n            return enumerate(n, Integer);\n        }\n\n        public long[] Long(int n)\n        {\n            return enumerate(n, Long);\n        }\n    }\n}\n\n#endregion\n\n#region sieve O(NloglogN)\nstatic public partial class MathEx\n{\n    static public bool[] Sieve(int p, List<int> primes = null)\n    {\n        var isPrime = new bool[p + 1];\n        for (int i = 2; i < isPrime.Length; i++) isPrime[i] = true;\n        for (int i = 2; i * i <= p; i++)\n            if (!isPrime[i]) continue;\n            else for (int j = i * i; j <= p; j += i) isPrime[j] = false;\n        if (primes != null) for (int i = 0; i <= p; i++) if (isPrime[i]) primes.Add(i);\n\n        return isPrime;\n    }\n}\n#endregion\n\n\n#region Edge\npublic class Edge\n{\n    public int to, rev;\n    public C cap;\n    public Edge(int t, int r, C _cap) { to = t; rev = r; cap = _cap; }\n    public override string ToString() { return string.Format(\"{0}: Capacity {1}\", to, cap); }\n}\n#endregion\n#region AddEdge\nstatic public partial class Flow\n{\n    static public void AddDirectedEdge(this List<Edge>[] G, int from, int to, C cap)\n    {\n        G[from].Add(new Edge(to, G[to].Count, cap));\n        G[to].Add(new Edge(from, G[from].Count - 1, 0));\n    }\n    static public void AddUndirectedEdge(this List<Edge>[] G, int from, int to, int cap)\n    {\n        G[from].Add(new Edge(to, G[to].Count, cap));\n        G[to].Add(new Edge(from, G[from].Count - 1, cap));\n    }\n}\n#endregion\n\n\n//MaxFlow\n#region Dinic\nstatic public partial class Flow\n{\n    static public C GetMaxFlow(List<Edge>[] G, int s, int t, C INF = -1)\n    {\n        var n = G.Length;\n        var level = new int[n];\n        var iter = new int[n];\n\n\n        Action<int> bfs = p =>\n        {\n            Array.Clear(level, 0, n);\n            var q = new Queue<int>();\n            level[s] = 1;\n            q.Enqueue(s);\n            while (q.Count > 0)\n            {\n                var v = q.Dequeue();\n                foreach (var e in G[v])\n                    if (e.cap > 0 && level[e.to] == 0)\n                    {\n                        level[e.to] = level[v] + 1;\n                        q.Enqueue(e.to);\n                    }\n            }\n        };\n\n\n        Func<int, int, C, C> dfs = null;\n        dfs = (v, u, f) =>\n        {\n            if (v == t) return f;\n            var ret = 0;\n            for (; iter[v] < G[v].Count; iter[v]++)\n            {\n                var e = G[v][iter[v]];\n                if (e.cap <= 0 || level[v] >= level[e.to]) continue;\n                var d = dfs(e.to, u, Math.Min(f, e.cap));\n                if (d <= 0) continue;\n                e.cap -= d;\n                G[e.to][e.rev].cap += d;\n                ret += d; f -= d;\n                if (f == 0) break;\n            }\n            return ret;\n        };\n\n\n        C flow = 0;\n        if (INF == -1) INF = C.MaxValue;\n        while (INF > 0)\n        {\n            bfs(s);\n            if (level[t] == 0) return flow;\n            Array.Clear(iter, 0, iter.Length);\n            C f;\n            while ((f = dfs(s, t, INF)) > 0) { flow += f; }\n        }\n        return flow;\n\n    }\n}\n#endregion"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Text;\nusing System.Collections.Generic;\nusing System.Linq;\nclass Solve{\n    public Solve(){}\n    StringBuilder sb;\n    public static int Main(){\n        new Solve().Run();\n        return 0;\n    }\n    void Run(){\n        sb = new StringBuilder();\n        Calc();\n        Console.Write(sb.ToString());\n    }\n    void Calc(){\n        int N = int.Parse(Console.ReadLine());\n        string[] str = Console.ReadLine().Split(' ');\n        int[] X = new int[N];\n        for(int i=0;i<N;i++){\n            X[i] = int.Parse(str[i]);\n        }\n        List<int> Diff = new List<int>();\n        Diff.Add(X[0]);\n        Diff.Add(X[N-1]+1);\n        for(int i=1;i<N;i++){\n            if(X[i] != X[i-1] + 1){\n                Diff.Add(X[i]);\n            }\n        }\n        for(int i=0;i<N-1;i++){\n            if(X[i] + 1 != X[i+1]){\n                Diff.Add(X[i]+1);\n            }\n        }\n        int[] diff = Diff.ToArray();\n        int o = 0;\n        int e = 0;\n        for(int i=0;i<diff.Length;i++){\n            if(diff[i] % 2 == 0){\n                e++;\n            }\n            else{\n                o++;\n            }\n        }\n        int[] Odd = new int[o];\n        int[] Even = new int[e];\n        o = 0;\n        e = 0;\n        for(int i=0;i<diff.Length;i++){\n            if(diff[i] % 2 == 0){\n                Even[e] = diff[i];\n                e++;\n            }\n            else{\n                Odd[o] = diff[i];\n                o++;\n            }\n        }\n        List<int> f = new List<int>();\n        List<int> t = new List<int>();\n        List<long> capa = new List<long>();\n        int S = 0;\n        int Ef = 1;\n        int Of = e+1;\n        int T = o+e+1;\n        for(int i=0;i<e;i++){\n            f.Add(S);\n            t.Add(Ef+i);\n            capa.Add(1);\n        }\n        for(int i=0;i<o;i++){\n            f.Add(Of+i);\n            t.Add(T);\n            capa.Add(1);\n        }\n        Generateprimenumber G = new Generateprimenumber(10000);\n        for(int i=0;i<e;i++){\n            for(int j=0;j<o;j++){\n                if(G.Prime(Math.Max(Even[i]-Odd[j],Odd[j]-Even[i]))){\n                    f.Add(Ef+i);\n                    t.Add(Of+j);\n                    capa.Add(1);\n                }\n            }\n        }\n        MaxFlow Flow = new MaxFlow(f.ToArray(),t.ToArray(),capa.ToArray(),o+e+2,0,o+e+1);\n        int flow = (int)Flow.flow;\n        int count = diff.Length - flow;\n        if(e % 2 != flow % 2){\n            count++;\n        }\n        sb.Append(count+\"\\n\");\n    }\n}\nclass Edge{\n    public Vertex to;\n    public long capacity;\n    public Edge rev;\n    public Edge(Vertex v,long c){\n        to = v;\n        capacity = c;\n    }\n}\nclass Vertex{\n    public bool finished;\n    public List<Edge> edges;\n    public void AddEdge(Edge e){\n        edges.Add(e);\n    }\n    public Vertex(){\n        edges = new List<Edge>();\n        finished = false;\n    }\n}\nclass MaxFlow{\n    Vertex[] point;\n    Vertex S;\n    Vertex G;\n    public long flow;\n    int E;\n    const long INF = 1000000000000000;\n    public MaxFlow(int[] f,int[] t,long[] capacity,int n,int s,int g){\n        point = new Vertex[n];\n        for(int i=0;i<n;i++){\n            point[i] = new Vertex();\n        }\n        E = f.Length;\n        for(int i=0;i<E;i++){\n            point[f[i]].AddEdge(new Edge(point[t[i]],capacity[i]));\n            point[t[i]].AddEdge(new Edge(point[f[i]],0));\n            point[f[i]].edges[point[f[i]].edges.Count-1].rev = point[t[i]].edges[point[t[i]].edges.Count-1];\n            point[t[i]].edges[point[t[i]].edges.Count-1].rev = point[f[i]].edges[point[f[i]].edges.Count-1];\n        }\n        S = point[s];\n        G = point[g];\n        flow = 0;\n        while(true){\n            long fl = dfs(S,INF);\n            flow += fl;\n            if(fl == 0){\n                break;\n            }\n            for(int i=0;i<n;i++){\n                point[i].finished = false;\n            }\n        }\n    }\n    long dfs(Vertex v,long f){\n        v.finished = true;\n        if(v == G){\n            return f;\n        }\n        for(int i=0;i<v.edges.Count;i++){\n            Edge e = v.edges[i];\n            if(!e.to.finished && e.capacity > 0){\n                long d = dfs(e.to,Math.Min(f,e.capacity));\n                if(d > 0){\n                    e.capacity -= d;\n                    e.rev.capacity += d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n}\nclass Generateprimenumber{\n    public int[] p;\n    public int length;\n    public Generateprimenumber(int n){\n        bool[] a = new bool[n+1];\n        List<int> pp = new List<int>();\n        int j = 2;\n        for(int i=0;i<n+1;i++){\n            a[i] = true;\n        }\n        while(j<=n){\n            if(a[j]){\n                pp.Add(j);\n                for(int i=j;(long)i*(long)j<=n;i++){\n                    a[i*j] = false;\n                }\n            }\n            j++;\n        }\n        length = pp.Count;\n        p = pp.ToArray();\n    }\n    public bool Prime(int x){\n        for(int i=0;i<length;i++){\n            if(p[i] == x){\n                return true;\n            }\n            else if(x % p[i] == 0){\n                return false;\n            }\n            else if(p[i]*p[i] > x){\n                break;\n            }\n        }\n        return x != 1;\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\nusing Debug = System.Diagnostics.Debug;\nusing SB = System.Text.StringBuilder;\n//using System.Numerics;\nusing Number = System.Int64;\nusing static System.Math;\nusing C = System.Int32;\n//using static MathEx;\n//using P = System.Collections.Generic.KeyValuePair<int, int>;\nnamespace Program\n{\n    public class Solver\n    {\n        public void Solve()\n        {\n            var n = ri;\n            const int MAX = 10000005;\n            var a = new int[MAX];\n            var b = new int[MAX];\n            foreach (var x in sc.Integer(n))\n                a[x] = 1;\n            for (int i = 0; i < MAX - 1; i++)\n                b[i] = a[i + 1] ^ a[i];\n            var xs = Enumerate(2, x => new List<int>());\n            for (int i = 0; i < MAX; i++)\n                if (b[i] == 1) xs[i % 2].Add(i);\n\n\n            var isprime = MathEx.Sieve(10000005);\n            isprime[2] = false;\n\n            var m = xs[0].Count + xs[1].Count;\n            Debug.WriteLine(m);\n            Debug.WriteLine(xs[0].AsJoinedString());\n            Debug.WriteLine(xs[1].AsJoinedString());\n            var G = new MaxFlow(m + 2);\n            for (int i = 0; i < xs[0].Count; i++)\n                for (int j = 0; j < xs[1].Count; j++)\n                    if (isprime[Math.Abs(xs[0][i] - xs[1][j])]) G.AddDirectedEdge(i, xs[0].Count + j, 1);\n            var f = m;\n            var t = m + 1;\n            for (int i = 0; i < xs[0].Count; i++)\n                G.AddDirectedEdge(f, i, 1);\n            for (int i = 0; i < xs[1].Count; i++)\n                G.AddDirectedEdge(xs[0].Count + i, t, 1);\n            var mf = G.Execute(f, t);\n            var ans = mf;\n            var u = xs[0].Count - mf;\n            var v = xs[1].Count - mf;\n            ans += 2 * (u / 2);\n            ans += 2 * (v / 2);\n            if (u % 2 == 1) ans += 3;\n            IO.Printer.Out.WriteLine(ans);\n\n        }\n        //*\n        int ri => sc.Integer();\n        long rl => sc.Long();\n        double rd => sc.Double();\n        string rs => sc.Scan();\n        char rc => sc.Char();\n\n        [System.Diagnostics.Conditional(\"DEBUG\")]\n        void put(params object[] a) => Debug.WriteLine(string.Join(\" \", a));\n\n        //*/\n        public IO.StreamScanner sc = new IO.StreamScanner(Console.OpenStandardInput());\n\n        static T[] Enumerate<T>(int n, Func<int, T> f)\n        {\n            var a = new T[n];\n            for (int i = 0; i < n; ++i) a[i] = f(i);\n            return a;\n        }\n        static void Swap<T>(ref T a, ref T b)\n        {\n            var tmp = a;\n            a = b;\n            b = tmp;\n        }\n    }\n}\n\n#region main\n\nstatic class Ex\n{\n    public static string AsString(this IEnumerable<char> ie)\n    {\n        return new string(ie.ToArray());\n    }\n\n    public static string AsJoinedString<T>(this IEnumerable<T> ie, string st = \" \")\n    {\n        return string.Join(st, ie);\n    }\n\n    public static void Main()\n    {\n        var solver = new Program.Solver();\n        solver.Solve();\n        Program.IO.Printer.Out.Flush();\n    }\n}\n\n#endregion\n#region Ex\n\nnamespace Program.IO\n{\n    using System.IO;\n    using System.Text;\n    using System.Globalization;\n\n    public class Printer: StreamWriter\n    {\n        static Printer()\n        {\n            Out = new Printer(Console.OpenStandardOutput()) { AutoFlush = false };\n        }\n\n        public static Printer Out { get; set; }\n\n        public override IFormatProvider FormatProvider\n        {\n            get { return CultureInfo.InvariantCulture; }\n        }\n\n        public Printer(Stream stream) : base(stream, new UTF8Encoding(false, true))\n        {\n        }\n\n        public Printer(Stream stream, Encoding encoding) : base(stream, encoding)\n        {\n        }\n\n        public void Write<T>(string format, T[] source)\n        {\n            base.Write(format, source.OfType<object>().ToArray());\n        }\n\n        public void WriteLine<T>(string format, T[] source)\n        {\n            base.WriteLine(format, source.OfType<object>().ToArray());\n        }\n    }\n\n    public class StreamScanner\n    {\n        public StreamScanner(Stream stream)\n        {\n            str = stream;\n        }\n\n        public readonly Stream str;\n        private readonly byte[] buf = new byte[1024];\n        private int len, ptr;\n        public bool isEof;\n\n        public bool IsEndOfStream\n        {\n            get { return isEof; }\n        }\n\n        private byte read()\n        {\n            if (isEof) return 0;\n            if (ptr < len) return buf[ptr++];\n            ptr = 0;\n            if ((len = str.Read(buf, 0, 1024)) > 0) return buf[ptr++];\n            isEof = true;\n            return 0;\n        }\n\n        public char Char()\n        {\n            byte b;\n            do b = read(); while ((b < 33 || 126 < b) && !isEof);\n            return (char)b;\n        }\n\n        public string Scan()\n        {\n            var sb = new StringBuilder();\n            for (var b = Char(); b >= 33 && b <= 126; b = (char)read())\n                sb.Append(b);\n            return sb.ToString();\n        }\n\n        public string ScanLine()\n        {\n            var sb = new StringBuilder();\n            for (var b = Char(); b != '\\n'; b = (char)read())\n                if (b == 0) break;\n                else if (b != '\\r') sb.Append(b);\n            return sb.ToString();\n        }\n\n        public long Long()\n        {\n            if (isEof) return long.MinValue;\n            long ret = 0;\n            byte b;\n            var ng = false;\n            do b = read(); while (b != 0 && b != '-' && (b < '0' || '9' < b));\n            if (b == 0) return long.MinValue;\n            if (b == '-')\n            {\n                ng = true;\n                b = read();\n            }\n            for (; ; b = read())\n            {\n                if (b < '0' || '9' < b)\n                    return ng ? -ret : ret;\n                ret = ret * 10 + b - '0';\n            }\n        }\n\n        public int Integer()\n        {\n            return (isEof) ? int.MinValue : (int)Long();\n        }\n\n        public double Double()\n        {\n            var s = Scan();\n            return s != \"\" ? double.Parse(s, CultureInfo.InvariantCulture) : double.NaN;\n        }\n\n        static T[] enumerate<T>(int n, Func<T> f)\n        {\n            var a = new T[n];\n            for (int i = 0; i < n; ++i) a[i] = f();\n            return a;\n        }\n\n        public char[] Char(int n)\n        {\n            return enumerate(n, Char);\n        }\n\n        public string[] Scan(int n)\n        {\n            return enumerate(n, Scan);\n        }\n\n        public double[] Double(int n)\n        {\n            return enumerate(n, Double);\n        }\n\n        public int[] Integer(int n)\n        {\n            return enumerate(n, Integer);\n        }\n\n        public long[] Long(int n)\n        {\n            return enumerate(n, Long);\n        }\n    }\n}\n\n#endregion\n\n#region sieve O(NloglogN)\nstatic public partial class MathEx\n{\n    static public bool[] Sieve(int p, List<int> primes = null)\n    {\n        var isPrime = new bool[p + 1];\n        for (int i = 2; i < isPrime.Length; i++) isPrime[i] = true;\n        for (int i = 2; i * i <= p; i++)\n            if (!isPrime[i]) continue;\n            else for (int j = i * i; j <= p; j += i) isPrime[j] = false;\n        if (primes != null) for (int i = 0; i <= p; i++) if (isPrime[i]) primes.Add(i);\n\n        return isPrime;\n    }\n}\n#endregion\n\n\npublic class MaxFlow\n{\n    public readonly List<Edge>[] G;\n    readonly int[] lv, iter;\n    public MaxFlow(int V)\n    {\n        G = new List<Edge>[V];\n        lv = new int[V];\n        iter = new int[V];\n        for (int i = 0; i < G.Length; i++)\n            G[i] = new List<Edge>();\n    }\n\n    public void AddDirectedEdge(int from, int to, C cap)\n    {\n        addEdge(from, to, cap, 0);\n    }\n\n    public void AddUndirectedEdge(int from, int to, C cap)\n    {\n        addEdge(from, to, cap, cap);\n    }\n    void addEdge(int f, int t, C c1, C c2)\n    {\n        var a = new Edge(t, c1);\n        var b = new Edge(f, c2);\n        Edge.Link(a, b);\n        G[f].Add(a);\n        G[t].Add(b);\n    }\n\n\n    public C Execute(int src, int sink, C f = -1)\n    {\n        C flow = 0;\n        if (f < 0) f = C.MaxValue;\n        while (f > 0)\n        {\n            bfs(src);\n            if (lv[sink] == 0) return flow;\n            Array.Clear(iter, 0, iter.Length);\n            C df;\n            while ((df = dfs(src, sink, f)) > 0) { flow += df; f -= df; }\n        }\n        return flow;\n    }\n\n    void bfs(int s)\n    {\n        Array.Clear(lv, 0, lv.Length);\n        var q = new Queue<int>();\n        lv[s] = 1;\n        q.Enqueue(s);\n        while (q.Count > 0)\n        {\n            var v = q.Dequeue();\n            foreach (var e in G[v])\n                if (e.Cap > 0 && lv[e.To] == 0)\n                {\n                    lv[e.To] = lv[v] + 1;\n                    q.Enqueue(e.To);\n                }\n        }\n\n    }\n    C dfs(int v, int t, C f)\n    {\n        if (v == t) return f;\n        C ret = 0;\n        for (; iter[v] < G[v].Count; iter[v]++)\n        {\n            var e = G[v][iter[v]];\n            if (e.Cap <= 0 || lv[v] >= lv[e.To]) continue;\n            C df = dfs(e.To, t, Math.Min(f, e.Cap));\n            if (df <= 0) continue;\n            e.Cap -= df;\n            e.Rev.Cap += df;\n            ret += df; f -= df;\n            if (f == 0) break;\n        }\n        return ret;\n\n    }\n    public class Edge\n    {\n        public static void Link(Edge e1, Edge e2)\n        {\n            e1.Rev = e2; e2.Rev = e1;\n        }\n        public int To { get; private set; }\n        public Edge Rev { get; private set; }\n        public C Cap { get; set; }\n        public Edge(int t, C c)\n        {\n            To = t;\n            Cap = c;\n        }\n        public override string ToString()\n        {\n            return string.Format(\"to: {0}, cap: {1}\", To, Cap);\n        }\n    }\n\n\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.IO;\nusing System.Text;\nusing System.Globalization;\nusing System.Diagnostics;\n\n\n\nclass Myon\n{\n    public Myon() { }\n    public static int Main()\n    {\n        new Myon().calc();\n        return 0;\n    }\n    \n\n    Scanner cin;\n\n    const int MAX = 10001000;\n    bool[] prime = new bool[MAX];\n    void setPrime()\n    {\n        prime[0] = prime[1] = true;\n        for (int i = 2; i < MAX; i++)\n        {\n            if (!prime[i])\n            {\n                for (int j = i + i; j < MAX; j+=i)\n                {\n                    prime[j] = true;\n                }\n            }\n        }\n    }\n    \n\n    void calc()\n    {\n        cin = new Scanner();\n        setPrime();\n        int N = cin.nextInt();\n        int[] A = cin.ArrayInt(N);\n\n        List<int> start = new List<int>();\n        List<int> num = new List<int>();\n\n        int pre = -2;\n        int cnt = 0;\n\n        foreach (var now in A)\n        {\n            if(now != pre + 1)\n            {\n                if (pre != -2)\n                {\n                    start.Add(pre - cnt);\n                    num.Add(cnt);\n                }\n                cnt = 0;\n            }\n            pre = now;\n            cnt++;\n        }\n        start.Add(pre - cnt);\n        num.Add(cnt);\n\n        int M = start.Count;\n\n\n        int[,] dist = new int[M, M];\n        for (int i = 0; i < M; i++)\n        {\n            for (int j = i + 1; j < M; j++)\n            {\n                dist[i, j] = dist[j, i] = -getCost(start[j] - start[i] - num[i]);\n                dist[i, j] = dist[j, i] -= getCost(start[j] - start[i] + num[j]);\n            }\n            dist[i, i] = -getCost(num[i]) * 2;\n        }\n        \n\n        long ans = hungarian(dist);\n        Console.WriteLine(ans / -2);\n        \n    }\n\n    int getCost(int A)\n    {\n        if (A % 2 == 0) return 2;\n        else if (!prime[A]) return 1;\n        else return 3;\n    }\n\n\n    long hungarian(int[,] a)\n    {\n        int n = a.GetLength(0);\n        long p, q;\n        long[] fx = new long[n];\n        long[] fy = new long[n];\n        long inf = (long)1e16;\n        long i, j, k;\n        for (i = 0; i < n; i++) fx[i] = inf;\n        for (i = 0; i < n; i++) fy[i] = inf;\n        long[] x = new long[n];\n        long[] y = new long[n];\n        for (i = 0; i < n; i++) x[i] = y[i] = -1;\n\n        for (i = 0; i < n; ++i)\n            for (j = 0; j < n; ++j)\n                fx[i] = Math.Max(fx[i], a[i, j]);\n        for (i = 0; i < n;)\n        {\n            long[] t = new long[n];\n            long[] s = new long[n + 1];\n            for (j = 0; j < n; j++) t[j] = -1;\n            for (j = 0; j <= n; j++) s[j] = i;\n            for (p = q = 0; p <= q && x[i] < 0; ++p)\n                for (k = s[p], j = 0; j < n && x[i] < 0; ++j)\n                    if (fx[k] + fy[j] == a[k, j] && t[j] < 0)\n                    {\n                        s[++q] = y[j];\n                        t[j] = k;\n                        if (s[q] < 0)\n                            for (p = j; p >= 0; j = p)\n                            {\n                                y[j] = k = t[j];\n                                p = x[k];\n                                x[k] = j;\n                            }\n                    }\n            if (x[i] < 0)\n            {\n                long d = inf;\n                for (k = 0; k <= q; ++k)\n                    for (j = 0; j < n; ++j)\n                        if (t[j] < 0) d = Math.Min(d, fx[s[k]] + fy[j] - a[s[k], j]);\n                for (j = 0; j < n; ++j)\n                {\n                    if (t[j] >= 0) fy[j] += d;\n                }\n                for (k = 0; k <= q; ++k) fx[s[k]] -= d;\n            }\n            else ++i;\n        }\n        long ret = 0;\n        for (i = 0; i < n; ++i) ret += a[i, x[i]];\n        return ret;\n    }\n}\n\n\nclass Scanner\n{\n    string[] s;\n    int i;\n\n    char[] cs = new char[] { ' ' };\n\n    public Scanner()\n    {\n        s = new string[0];\n        i = 0;\n    }\n\n    public string next()\n    {\n        if (i < s.Length) return s[i++];\n        string st = Console.ReadLine();\n        while (st == \"\") st = Console.ReadLine();\n        s = st.Split(cs, StringSplitOptions.RemoveEmptyEntries);\n        if (s.Length == 0) return next();\n        i = 0;\n        return s[i++];\n    }\n\n    public int nextInt()\n    {\n        return int.Parse(next());\n    }\n    public int[] ArrayInt(int N, int add = 0)\n    {\n        int[] Array = new int[N];\n        for (int i = 0; i < N; i++)\n        {\n            Array[i] = nextInt() + add;\n        }\n        return Array;\n    }\n\n    public long nextLong()\n    {\n        return long.Parse(next());\n    }\n\n    public long[] ArrayLong(int N, long add = 0)\n    {\n        long[] Array = new long[N];\n        for (int i = 0; i < N; i++)\n        {\n            Array[i] = nextLong() + add;\n        }\n        return Array;\n    }\n\n    public double nextDouble()\n    {\n        return double.Parse(next());\n    }\n\n\n    public double[] ArrayDouble(int N, double add = 0)\n    {\n        double[] Array = new double[N];\n        for (int i = 0; i < N; i++)\n        {\n            Array[i] = nextDouble() + add;\n        }\n        return Array;\n    }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Text;\nusing System.Collections.Generic;\nusing System.Linq;\nclass Solve{\n    public Solve(){}\n    StringBuilder sb;\n    public static int Main(){\n        new Solve().Run();\n        return 0;\n    }\n    void Run(){\n        sb = new StringBuilder();\n        Calc();\n        Console.Write(sb.ToString());\n    }\n    void Calc(){\n        int N = int.Parse(Console.ReadLine());\n        string[] str = Console.ReadLine().Split(' ');\n        int[] X = new int[N];\n        for(int i=0;i<N;i++){\n            X[i] = int.Parse(str[i]);\n        }\n        List<int> Diff = new List<int>();\n        Diff.Add(X[0]);\n        Diff.Add(X[N-1]+1);\n        for(int i=1;i<N;i++){\n            if(X[i] != X[i-1] + 1){\n                Diff.Add(X[i]);\n            }\n        }\n        for(int i=0;i<N-1;i++){\n            if(X[i] + 1 != X[i+1]){\n                Diff.Add(X[i]+1);\n            }\n        }\n        int[] diff = Diff.ToArray();\n        int o = 0;\n        int e = 0;\n        for(int i=0;i<diff.Length;i++){\n            if(diff[i] % 2 == 0){\n                e++;\n            }\n            else{\n                o++;\n            }\n        }\n        int[] Odd = new int[o];\n        int[] Even = new int[e];\n        o = 0;\n        e = 0;\n        for(int i=0;i<diff.Length;i++){\n            if(diff[i] % 2 == 0){\n                Even[e] = diff[i];\n                e++;\n            }\n            else{\n                Odd[o] = diff[i];\n                o++;\n            }\n        }\n        List<int> f = new List<int>();\n        List<int> t = new List<int>();\n        List<long> capa = new List<long>();\n        int S = 0;\n        int Ef = 1;\n        int Of = e+1;\n        int T = o+e+1;\n        for(int i=0;i<e;i++){\n            f.Add(S);\n            t.Add(Ef+i);\n            capa.Add(1);\n        }\n        for(int i=0;i<0;i++){\n            f.Add(Of+i);\n            t.Add(T);\n            capa.Add(1);\n        }\n        Generateprimenumber G = new Generateprimenumber(10000);\n        for(int i=0;i<e;i++){\n            for(int j=0;j<o;j++){\n                if(G.Prime(Math.Max(Even[i]-Odd[j],Odd[j]-Even[i]))){\n                    f.Add(Ef+i);\n                    t.Add(Of+j);\n                    capa.Add(1);\n                }\n            }\n        }\n        MaxFlow Flow = new MaxFlow(f.ToArray(),t.ToArray(),capa.ToArray(),o+e+2,0,o+e+1);\n        int flow = (int)Flow.flow;\n        int count = diff.Length - flow;\n        if(e % 2 != flow % 2){\n            count++;\n        }\n        sb.Append(count+\"\\n\");\n    }\n}\nclass Edge{\n    public Vertex to;\n    public long capacity;\n    public Edge rev;\n    public Edge(Vertex v,long c){\n        to = v;\n        capacity = c;\n    }\n}\nclass Vertex{\n    public bool finished;\n    public List<Edge> edges;\n    public void AddEdge(Edge e){\n        edges.Add(e);\n    }\n    public Vertex(){\n        edges = new List<Edge>();\n        finished = false;\n    }\n}\nclass MaxFlow{\n    Vertex[] point;\n    Vertex S;\n    Vertex G;\n    public long flow;\n    int E;\n    const long INF = 1000000000000000;\n    public MaxFlow(int[] f,int[] t,long[] capacity,int n,int s,int g){\n        point = new Vertex[n];\n        for(int i=0;i<n;i++){\n            point[i] = new Vertex();\n        }\n        E = f.Length;\n        for(int i=0;i<E;i++){\n            point[f[i]].AddEdge(new Edge(point[t[i]],capacity[i]));\n            point[t[i]].AddEdge(new Edge(point[f[i]],0));\n            point[f[i]].edges[point[f[i]].edges.Count-1].rev = point[t[i]].edges[point[t[i]].edges.Count-1];\n            point[t[i]].edges[point[t[i]].edges.Count-1].rev = point[f[i]].edges[point[f[i]].edges.Count-1];\n        }\n        S = point[s];\n        G = point[g];\n        flow = 0;\n        while(true){\n            long fl = dfs(S,INF);\n            flow += fl;\n            if(fl == 0){\n                break;\n            }\n            for(int i=0;i<n;i++){\n                point[i].finished = false;\n            }\n        }\n    }\n    long dfs(Vertex v,long f){\n        v.finished = true;\n        if(v == G){\n            return f;\n        }\n        for(int i=0;i<v.edges.Count;i++){\n            Edge e = v.edges[i];\n            if(!e.to.finished && e.capacity > 0){\n                long d = dfs(e.to,Math.Min(f,e.capacity));\n                if(d > 0){\n                    e.capacity -= d;\n                    e.rev.capacity += d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n}\nclass Generateprimenumber{\n    public int[] p;\n    public int length;\n    public Generateprimenumber(int n){\n        bool[] a = new bool[n+1];\n        List<int> pp = new List<int>();\n        int j = 2;\n        for(int i=0;i<n+1;i++){\n            a[i] = true;\n        }\n        while(j<=n){\n            if(a[j]){\n                pp.Add(j);\n                for(int i=j;(long)i*(long)j<=n;i++){\n                    a[i*j] = false;\n                }\n            }\n            j++;\n        }\n        length = pp.Count;\n        p = pp.ToArray();\n    }\n    public bool Prime(int x){\n        for(int i=0;i<length;i++){\n            if(p[i] == x){\n                return true;\n            }\n            else if(x % p[i] == 0){\n                return false;\n            }\n            else if(p[i]*p[i] > x){\n                break;\n            }\n        }\n        return true;\n    }\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio, std.array, std.string, std.conv, std.algorithm;\nimport std.typecons, std.range, std.random, std.math, std.container;\nimport std.numeric, std.bigint, core.bitop;\n\nvoid main() {\n    auto N = readln.chomp.to!int;\n    auto A = readln.split.map!(to!int).array;\n    \n    int[] B;\n    foreach (a; A) {\n        foreach (b; a-1..a+1) {\n            if (B.length > 0 && B[$-1] == b) B.popBack;\n            else B ~= b;\n        }\n    }\n\n    auto P = new bool[](10^^7 + 10);\n    fill(P, true);\n    P[0] = P[1] = false;\n    for (int i = 2; i < 10^^7 + 10; i++) {\n        if (!P[i]) continue;\n        for (int j = i + i; j < 10^^7 + 10; j += i) P[j] = false;\n    }\n\n\n    B.sort!\"a % 2 > b % 2\"();\n    int M = B.length.to!int;\n    int source = M;\n    int sink = M + 1;\n    int odd = B.map!(b => b % 2).sum;\n    int even = B.map!(b => 1 - b % 2).sum;\n    auto FF = new FordFulkerson(M + 2, source, sink);\n    foreach (i; 0..odd) FF.add_edge(source, i, 1);\n    foreach (i; odd..odd+even) FF.add_edge(i, sink, 1);\n    foreach (i; 0..odd) {\n        foreach (j; odd..odd+even) {\n            if (P[abs(B[i] - B[j])]) FF.add_edge(i, j, 1);\n        }\n    }\n    \n    int one = FF.run;\n    odd -= one;\n    even -= one;\n    int two = odd / 2 + even / 2;\n    int three = odd % 2;\n\n    writeln(one + two * 2 + three * 3);\n}\n\n\n\nclass FordFulkerson {\n    int N, source, sink;\n    int[][] adj;\n    int[][] flow;\n    bool[] used;\n\n    this(int n, int s, int t) {\n        N = n;\n        source = s;\n        sink = t;\n        assert (s >= 0 && s < N && t >= 0 && t < N);\n        adj = new int[][](N);\n        flow = new int[][](N, N);\n        used = new bool[](N);\n    }\n\n    void add_edge(int from, int to, int cap) {\n        adj[from] ~= to;\n        adj[to] ~= from;\n        flow[from][to] = cap;\n    }\n\n    int dfs(int v, int min_cap) {\n        if (v == sink)\n            return min_cap;\n        if (used[v])\n            return 0;\n        used[v] = true;\n        foreach (to; adj[v]) {\n            if (!used[to] && flow[v][to] > 0) {\n                auto bottleneck = dfs(to, min(min_cap, flow[v][to]));\n                if (bottleneck == 0) continue;\n                flow[v][to] -= bottleneck;\n                flow[to][v] += bottleneck;\n                return bottleneck;\n            }\n        }\n        return 0;\n    }\n\n    int run() {\n        int ret = 0;\n        while (true) {\n            foreach (i; 0..N) used[i] = false;\n            int f = dfs(source, int.max);\n            if (f > 0)\n                ret += f;\n            else\n                return ret;\n        }\n    }\n}\n"
  },
  {
    "language": "D",
    "code": "/+ dub.sdl:\n    name \"F\"\n    dependency \"dcomp\" version=\">=0.6.0\"\n+/\n\nimport std.stdio, std.algorithm, std.range, std.conv, std.typecons, std.math;\n// import dcomp.foundation, dcomp.scanner;\n// import dcomp.graph.maxflow;\n\nimmutable MD = 10^^7 + 10^^6;\n\nbool[] prList(int n) {\n    bool[] pr = new bool[n+1];\n    pr[] = true;\n    pr[0] = pr[1] = false;\n    foreach (i; 2..n+1) {\n        if (!pr[i]) continue;\n        for (auto j = 2*i; j <= n; j += i) {\n            pr[j] = false;\n        }\n    }\n    return pr;\n}\n\nint main() {\n    auto pl = prList(MD);\n    auto sc = new Scanner(stdin);\n    int n;\n    int[] v;\n    sc.read(n, v);\n    bool[] buf = new bool[MD];\n    v.each!(x => buf[x] = true);\n\n    int[] od, ev;\n    foreach (int i; 0..MD-1) {\n        if (buf[i] != buf[i+1]) {\n            //add i\n            if (i % 2) {\n                od ~= i;\n            } else {\n                ev ~= i;\n            }\n        }\n    }\n    debug writeln(od, \" \", ev);\n    int A = od.length.to!int, B = ev.length.to!int;\n    int N = A + B + 2;\n    alias E = Tuple!(int, \"to\", int, \"cap\", int, \"rev\");\n    E[][] g = new E[][](N);\n    void addEdge(int from, int to, int cap) {\n        debug writeln(\"add \", from, \" \", to, \" \", cap);\n        g[from] ~= E(to, cap, g[to].length.to!int);\n        g[to] ~= E(from, 0, g[from].length.to!int-1);\n    }\n    int sv = A+B, tv = A+B+1;\n    foreach (i; 0..A) {\n        addEdge(sv, i, 1);\n    }\n    foreach (j; 0..B) {\n        addEdge(A+j, tv, 1);\n    }\n    foreach (int i, d; od) {\n        foreach (int j, e; ev) {\n            if (pl[abs(d-e)]) {\n                addEdge(i, A+j, 1);\n            }\n        }\n    }\n    auto u = maxFlow!(int, 0)(g, sv, tv).flow;\n//    writeln(od, \" \", ev, \" \", u);\n    writeln(u + (A + B - 2 * u) + (A - u) % 2);\n    return 0;\n}\n/* IMPORT /home/yosupo/Program/dcomp/source/dcomp/graph/maxflow.d */\n// module dcomp.graph.maxflow;\n\n// import dcomp.container.deque;\n\nstruct maxFlowInfo(C) {\n    C flow;\n    bool[] dual;\n}\n\nmaxFlowInfo!(C) maxFlow(C, C EPS, T)(T g, int s, int t) {\n    assert(s != t);\n    import std.algorithm : map;\n    import std.range : array;\n    import std.conv : to;\n    int n = g.length.to!int;\n    int[] level = new int[n];\n    int[] iter = new int[n];\n\n    void bfs() {\n        level[] = -1; level[s] = 0;\n        auto que = Deque!int(s);\n        while (!que.empty) {\n            int v = que.back; que.removeBack();\n            foreach (e; g[v]) {\n                if (e.cap <= EPS) continue;\n                if (level[e.to] < 0) {\n                    level[e.to] = level[v] + 1;\n                    que.insertBack(e.to);\n                }\n            }\n        }\n    }\n\n    C dfs(int v, int t, C f) {\n        import std.algorithm : min;\n        if (v == t) return f;\n        auto edgeList = g[v][iter[v]..$];\n        foreach (ref e; edgeList) {\n            if (e.cap <= EPS) continue;\n            if (level[v] < level[e.to]) {\n                C d = dfs(e.to, t, min(f, e.cap));\n                if (d <= EPS) continue;\n                e.cap -= d;\n                g[e.to][e.rev].cap += d;\n                return d;\n            }\n            iter[v]++;\n        }\n        return 0;\n    }\n\n    C flow = 0;\n    while (true) {\n        bfs();\n        if (level[t] < 0) break;\n        iter[] = 0;\n        while (true) {\n            C f = dfs(s, t, C.max);\n            if (!f) break;\n            flow += f;\n        }\n    }\n\n    auto mfInfo = maxFlowInfo!C();\n    mfInfo.flow = flow;\n    mfInfo.dual = level.map!\"a == -1\".array;\n    return mfInfo;\n}\n\n\n\n \n\n\n \n\n \n/* IMPORT /home/yosupo/Program/dcomp/source/dcomp/foundation.d */\n// module dcomp.foundation;\n \nstatic if (__VERSION__ <= 2070) {\n    template fold(fun...) if (fun.length >= 1) {\n        auto fold(R, S...)(R r, S seed) {\n            import std.algorithm : reduce;\n            static if (S.length < 2) {\n                return reduce!fun(seed, r);\n            } else {\n                import std.typecons : tuple;\n                return reduce!fun(tuple(seed), r);\n            }\n        }\n    }\n     \n}\nversion (X86) static if (__VERSION__ < 2071) {\n    import core.bitop : bsf, bsr, popcnt;\n    int bsf(ulong v) {\n        foreach (i; 0..64) {\n            if (v & (1UL << i)) return i;\n        }\n        return -1;\n    }\n    int bsr(ulong v) {\n        foreach_reverse (i; 0..64) {\n            if (v & (1UL << i)) return i;\n        }\n        return -1;   \n    }\n    int popcnt(ulong v) {\n        int c = 0;\n        foreach (i; 0..64) {\n            if (v & (1UL << i)) c++;\n        }\n        return c;\n    }\n}\n/* IMPORT /home/yosupo/Program/dcomp/source/dcomp/container/deque.d */\n// module dcomp.container.deque;\n\n \nstruct Deque(T, bool mayNull = true) {\n    import core.exception : RangeError;\n    import core.memory : GC;\n    import std.range : ElementType, isInputRange;\n    import std.traits : isImplicitlyConvertible;\n\n    struct Payload {\n        T *d;\n        size_t st, length, cap;\n        @property bool empty() const { return length == 0; }\n        alias opDollar = length;\n        ref inout(T) opIndex(size_t i) inout {\n            version(assert) if (length <= i) throw new RangeError();\n            return d[(st+i >= cap) ? (st+i-cap) : st+i];\n        }\n        private void expand() {\n            import std.algorithm : max;\n            assert(length == cap);\n            auto nc = max(size_t(4), 2*cap);\n            T* nd = cast(T*)GC.malloc(nc * T.sizeof);\n            foreach (i; 0..length) {\n                nd[i] = this[i];\n            }\n            d = nd; st = 0; cap = nc;\n        }\n        void clear() {\n            st = length = 0;\n        }\n        void insertFront(T v) {\n            if (length == cap) expand();\n            if (st == 0) st += cap;\n            st--; length++;\n            this[0] = v; \n        }\n        void insertBack(T v) {\n            if (length == cap) expand();\n            length++;\n            this[length-1] = v; \n        }\n        void removeFront() {\n            assert(!empty, \"Deque.removeFront: Deque is empty\");        \n            st++; length--;\n            if (st == cap) st = 0;\n        }\n        void removeBack() {\n            assert(!empty, \"Deque.removeBack: Deque is empty\");        \n            length--;\n        }\n    }\n    struct RangeT(A) {\n        alias T = typeof(*(A.p));\n        alias E = typeof(A.p.d[0]);\n        T *p;\n        size_t a, b;\n        @property bool empty() const { return b <= a; }\n        @property size_t length() const { return b-a; }\n        @property RangeT save() { return RangeT(p, a, b); }\n        @property RangeT!(const A) save() const {\n            return typeof(return)(p, a, b);\n        }\n        alias opDollar = length;\n        @property ref inout(E) front() inout { return (*p)[a]; }\n        @property ref inout(E) back() inout { return (*p)[b-1]; }\n        void popFront() {\n            version(assert) if (empty) throw new RangeError();\n            a++;\n        }\n        void popBack() {\n            version(assert) if (empty) throw new RangeError();\n            b--;\n        }\n        ref inout(E) opIndex(size_t i) inout { return (*p)[i]; }\n        RangeT opSlice() { return this.save; }\n        RangeT opSlice(size_t i, size_t j) {\n            version(assert) if (i > j || a + j > b) throw new RangeError();\n            return typeof(return)(p, a+i, a+j);\n        }\n        RangeT!(const A) opSlice() const { return this.save; }\n        RangeT!(const A) opSlice(size_t i, size_t j) const {\n            version(assert) if (i > j || a + j > b) throw new RangeError();\n            return typeof(return)(p, a+i, a+j);\n        }\n    }\n    \n    alias Range = RangeT!Deque;\n    alias ConstRange = RangeT!(const Deque);\n    alias ImmutableRange = RangeT!(immutable Deque);\n    \n    Payload* p;\n    private void I() { if (mayNull && !p) p = new Payload(); }\n    private void C() const {\n        version(assert) if (mayNull && !p) throw new RangeError();\n    }\n    static if (!mayNull) {\n        @disable this();\n    }\n     \n    private this(Payload* p) {\n        this.p = p;\n    }\n    this(U)(U[] values...) if (isImplicitlyConvertible!(U, T)) {\n        p = new Payload();\n        foreach (v; values) {\n            insertBack(v);\n        }\n    }\n     \n    this(Range)(Range r)\n    if (isInputRange!Range &&\n    isImplicitlyConvertible!(ElementType!Range, T) &&\n    !is(Range == T[])) {\n        p = new Payload();\n        foreach (v; r) {\n            insertBack(v);\n        }\n    }\n    static Deque make() { return Deque(new Payload()); }\n    @property bool havePayload() const { return (!mayNull || p); }\n     \n    @property bool empty() const { return (!havePayload || p.empty); }\n     \n    @property size_t length() const { return (havePayload ? p.length : 0); }\n     \n    alias opDollar = length;\n    ref inout(T) opIndex(size_t i) inout {C; return (*p)[i]; }\n     \n    ref inout(T) front() inout {C; return (*p)[0]; }\n     \n    ref inout(T) back() inout {C; return (*p)[$-1]; }\n    void clear() { if (p) p.clear(); }\n     \n    void insertFront(T v) {I; p.insertFront(v); }\n     \n    void insertBack(T v) {I; p.insertBack(v); }\n     \n    alias stableInsertBack = insertBack;\n     \n    void removeFront() {C; p.removeFront(); }\n     \n    void removeBack() {C; p.removeBack(); }\n     \n    Range opSlice() {I; return Range(p, 0, length); }\n}\n\n\n \n\n \n\n \n\n \n\n \n\n \n/* IMPORT /home/yosupo/Program/dcomp/source/dcomp/scanner.d */\n// module dcomp.scanner;\n\n \nclass Scanner {\n    import std.stdio : File;\n    import std.conv : to;\n    import std.range : front, popFront, array, ElementType;\n    import std.array : split;\n    import std.traits : isSomeChar, isStaticArray, isArray; \n    import std.algorithm : map;\n    File f;\n    this(File f) {\n        this.f = f;\n    }\n    char[512] lineBuf;\n    char[] line;\n    private bool succ() {\n        import std.range.primitives : empty, front, popFront;\n        import std.ascii : isWhite;\n        while (true) {\n            while (!line.empty && line.front.isWhite) {\n                line.popFront;\n            }\n            if (!line.empty) break;\n            if (f.eof) return false;\n            line = lineBuf[];\n            f.readln(line);\n        }\n        return true;\n    }\n\n    private bool readSingle(T)(ref T x) {\n        import std.algorithm : findSplitBefore;\n        import std.string : strip;\n        import std.conv : parse;\n        if (!succ()) return false;\n        static if (isArray!T) {\n            alias E = ElementType!T;\n            static if (isSomeChar!E) {\n                 \n                 \n                auto r = line.findSplitBefore(\" \");\n                x = r[0].strip.dup;\n                line = r[1];\n            } else {\n                auto buf = line.split.map!(to!E).array;\n                static if (isStaticArray!T) {\n                     \n                    assert(buf.length == T.length);\n                }\n                x = buf;\n                line.length = 0;\n            }\n        } else {\n            x = line.parse!T;\n        }\n        return true;\n    }\n    int read(T, Args...)(ref T x, auto ref Args args) {\n        if (!readSingle(x)) return 0;\n        static if (args.length == 0) {\n            return 1;\n        } else {\n            return 1 + read(args);\n        }\n    }\n}\n\n\n \n \n\n \n"
  },
  {
    "language": "D",
    "code": "/+ dub.sdl:\n    name \"F\"\n    dependency \"dcomp\" version=\">=0.6.0\"\n+/\n\nimport std.stdio, std.algorithm, std.range, std.conv, std.typecons, std.math;\n// import dcomp.foundation, dcomp.scanner;\n// import dcomp.graph.maxflow;\n\nimmutable MD = 10^^7 + 10^^6;\n\nbool[] prList(int n) {\n    bool[] pr = new bool[n+1];\n    pr[] = true;\n    pr[0] = pr[1] = false;\n    foreach (i; 2..n+1) {\n        if (!pr[i]) continue;\n        for (auto j = 2*i; j <= n; j += i) {\n            pr[j] = false;\n        }\n    }\n    return pr;\n}\n\nint main() {\n    auto pl = prList(MD);\n    auto sc = new Scanner(stdin);\n    int n;\n    int[] v;\n//    sc.read(n, v);\n    n = 100;\n    foreach (int i; 0..n) {\n        v ~= i+1;\n    }\n    bool[] buf = new bool[MD];\n    v.each!(x => buf[x] = true);\n\n    int[] od, ev;\n    foreach (int i; 0..MD-1) {\n        if (buf[i] != buf[i+1]) {\n            //add i\n            if (i % 2) {\n                od ~= i;\n            } else {\n                ev ~= i;\n            }\n        }\n    }\n    debug writeln(od, \" \", ev);\n    int A = od.length.to!int, B = ev.length.to!int;\n    int N = A + B + 2;\n    alias E = Tuple!(int, \"to\", int, \"cap\", int, \"rev\");\n    E[][] g = new E[][](N);\n    void addEdge(int from, int to, int cap) {\n        debug writeln(\"add \", from, \" \", to, \" \", cap);\n        g[from] ~= E(to, cap, g[to].length.to!int);\n        g[to] ~= E(from, 0, g[from].length.to!int-1);\n    }\n    int sv = A+B, tv = A+B+1;\n    foreach (i; 0..A) {\n        addEdge(sv, i, 1);\n    }\n    foreach (j; 0..B) {\n        addEdge(A+j, tv, 1);\n    }\n    foreach (int i, d; od) {\n        foreach (int j, e; ev) {\n            if (pl[abs(d-e)]) {\n                addEdge(i, A+j, 1);\n            }\n        }\n    }\n    auto u = maxFlow!(int, 0)(g, sv, tv).flow;\n//    writeln(od, \" \", ev, \" \", u);\n    writeln(u + (A + B - 2 * u) + (A - u) % 2);\n    return 0;\n}\n/* IMPORT /home/yosupo/Program/dcomp/source/dcomp/graph/maxflow.d */\n// module dcomp.graph.maxflow;\n\n// import dcomp.container.deque;\n\nstruct maxFlowInfo(C) {\n    C flow;\n    bool[] dual;\n}\n\nmaxFlowInfo!(C) maxFlow(C, C EPS, T)(T g, int s, int t) {\n    assert(s != t);\n    import std.algorithm : map;\n    import std.range : array;\n    import std.conv : to;\n    int n = g.length.to!int;\n    int[] level = new int[n];\n    int[] iter = new int[n];\n\n    void bfs() {\n        level[] = -1; level[s] = 0;\n        auto que = Deque!int(s);\n        while (!que.empty) {\n            int v = que.back; que.removeBack();\n            foreach (e; g[v]) {\n                if (e.cap <= EPS) continue;\n                if (level[e.to] < 0) {\n                    level[e.to] = level[v] + 1;\n                    que.insertBack(e.to);\n                }\n            }\n        }\n    }\n\n    C dfs(int v, int t, C f) {\n        import std.algorithm : min;\n        if (v == t) return f;\n        auto edgeList = g[v][iter[v]..$];\n        foreach (ref e; edgeList) {\n            if (e.cap <= EPS) continue;\n            if (level[v] < level[e.to]) {\n                C d = dfs(e.to, t, min(f, e.cap));\n                if (d <= EPS) continue;\n                e.cap -= d;\n                g[e.to][e.rev].cap += d;\n                return d;\n            }\n            iter[v]++;\n        }\n        return 0;\n    }\n    C flow = 0;\n    while (true) {\n        bfs();\n        if (level[t] < 0) break;\n        iter[] = 0;\n        while (true) {\n            C f = dfs(s, t, C.max);\n            if (!f) break;\n            flow += f;\n        }\n    }\n\n    auto mfInfo = maxFlowInfo!C();\n    mfInfo.flow = flow;\n    mfInfo.dual = level.map!\"a == -1\".array;\n    return mfInfo;\n}\n\n\n\n \n\n\n \n\n \n/* IMPORT /home/yosupo/Program/dcomp/source/dcomp/foundation.d */\n// module dcomp.foundation;\n \nstatic if (__VERSION__ <= 2070) {\n    template fold(fun...) if (fun.length >= 1) {\n        auto fold(R, S...)(R r, S seed) {\n            import std.algorithm : reduce;\n            static if (S.length < 2) {\n                return reduce!fun(seed, r);\n            } else {\n                import std.typecons : tuple;\n                return reduce!fun(tuple(seed), r);\n            }\n        }\n    }\n     \n}\nversion (X86) static if (__VERSION__ < 2071) {\n    import core.bitop : bsf, bsr, popcnt;\n    int bsf(ulong v) {\n        foreach (i; 0..64) {\n            if (v & (1UL << i)) return i;\n        }\n        return -1;\n    }\n    int bsr(ulong v) {\n        foreach_reverse (i; 0..64) {\n            if (v & (1UL << i)) return i;\n        }\n        return -1;   \n    }\n    int popcnt(ulong v) {\n        int c = 0;\n        foreach (i; 0..64) {\n            if (v & (1UL << i)) c++;\n        }\n        return c;\n    }\n}\n/* IMPORT /home/yosupo/Program/dcomp/source/dcomp/container/deque.d */\n// module dcomp.container.deque;\n\n \nstruct Deque(T, bool mayNull = true) {\n    import core.exception : RangeError;\n    import core.memory : GC;\n    import std.range : ElementType, isInputRange;\n    import std.traits : isImplicitlyConvertible;\n\n    struct Payload {\n        T *d;\n        size_t st, length, cap;\n        @property bool empty() const { return length == 0; }\n        alias opDollar = length;\n        ref inout(T) opIndex(size_t i) inout {\n            version(assert) if (length <= i) throw new RangeError();\n            return d[(st+i >= cap) ? (st+i-cap) : st+i];\n        }\n        private void expand() {\n            import std.algorithm : max;\n            assert(length == cap);\n            auto nc = max(size_t(4), 2*cap);\n            T* nd = cast(T*)GC.malloc(nc * T.sizeof);\n            foreach (i; 0..length) {\n                nd[i] = this[i];\n            }\n            d = nd; st = 0; cap = nc;\n        }\n        void clear() {\n            st = length = 0;\n        }\n        void insertFront(T v) {\n            if (length == cap) expand();\n            if (st == 0) st += cap;\n            st--; length++;\n            this[0] = v; \n        }\n        void insertBack(T v) {\n            if (length == cap) expand();\n            length++;\n            this[length-1] = v; \n        }\n        void removeFront() {\n            assert(!empty, \"Deque.removeFront: Deque is empty\");        \n            st++; length--;\n            if (st == cap) st = 0;\n        }\n        void removeBack() {\n            assert(!empty, \"Deque.removeBack: Deque is empty\");        \n            length--;\n        }\n    }\n    struct RangeT(A) {\n        alias T = typeof(*(A.p));\n        alias E = typeof(A.p.d[0]);\n        T *p;\n        size_t a, b;\n        @property bool empty() const { return b <= a; }\n        @property size_t length() const { return b-a; }\n        @property RangeT save() { return RangeT(p, a, b); }\n        @property RangeT!(const A) save() const {\n            return typeof(return)(p, a, b);\n        }\n        alias opDollar = length;\n        @property ref inout(E) front() inout { return (*p)[a]; }\n        @property ref inout(E) back() inout { return (*p)[b-1]; }\n        void popFront() {\n            version(assert) if (empty) throw new RangeError();\n            a++;\n        }\n        void popBack() {\n            version(assert) if (empty) throw new RangeError();\n            b--;\n        }\n        ref inout(E) opIndex(size_t i) inout { return (*p)[i]; }\n        RangeT opSlice() { return this.save; }\n        RangeT opSlice(size_t i, size_t j) {\n            version(assert) if (i > j || a + j > b) throw new RangeError();\n            return typeof(return)(p, a+i, a+j);\n        }\n        RangeT!(const A) opSlice() const { return this.save; }\n        RangeT!(const A) opSlice(size_t i, size_t j) const {\n            version(assert) if (i > j || a + j > b) throw new RangeError();\n            return typeof(return)(p, a+i, a+j);\n        }\n    }\n    \n    alias Range = RangeT!Deque;\n    alias ConstRange = RangeT!(const Deque);\n    alias ImmutableRange = RangeT!(immutable Deque);\n    \n    Payload* p;\n    private void I() { if (mayNull && !p) p = new Payload(); }\n    private void C() const {\n        version(assert) if (mayNull && !p) throw new RangeError();\n    }\n    static if (!mayNull) {\n        @disable this();\n    }\n     \n    private this(Payload* p) {\n        this.p = p;\n    }\n    this(U)(U[] values...) if (isImplicitlyConvertible!(U, T)) {\n        p = new Payload();\n        foreach (v; values) {\n            insertBack(v);\n        }\n    }\n     \n    this(Range)(Range r)\n    if (isInputRange!Range &&\n    isImplicitlyConvertible!(ElementType!Range, T) &&\n    !is(Range == T[])) {\n        p = new Payload();\n        foreach (v; r) {\n            insertBack(v);\n        }\n    }\n    static Deque make() { return Deque(new Payload()); }\n    @property bool havePayload() const { return (!mayNull || p); }\n     \n    @property bool empty() const { return (!havePayload || p.empty); }\n     \n    @property size_t length() const { return (havePayload ? p.length : 0); }\n     \n    alias opDollar = length;\n    ref inout(T) opIndex(size_t i) inout {C; return (*p)[i]; }\n     \n    ref inout(T) front() inout {C; return (*p)[0]; }\n     \n    ref inout(T) back() inout {C; return (*p)[$-1]; }\n    void clear() { if (p) p.clear(); }\n     \n    void insertFront(T v) {I; p.insertFront(v); }\n     \n    void insertBack(T v) {I; p.insertBack(v); }\n     \n    alias stableInsertBack = insertBack;\n     \n    void removeFront() {C; p.removeFront(); }\n     \n    void removeBack() {C; p.removeBack(); }\n     \n    Range opSlice() {I; return Range(p, 0, length); }\n}\n\n\n \n\n \n\n \n\n \n\n \n\n \n/* IMPORT /home/yosupo/Program/dcomp/source/dcomp/scanner.d */\n// module dcomp.scanner;\n\n \nclass Scanner {\n    import std.stdio : File;\n    import std.conv : to;\n    import std.range : front, popFront, array, ElementType;\n    import std.array : split;\n    import std.traits : isSomeChar, isStaticArray, isArray; \n    import std.algorithm : map;\n    File f;\n    this(File f) {\n        this.f = f;\n    }\n    char[512] lineBuf;\n    char[] line;\n    private bool succ() {\n        import std.range.primitives : empty, front, popFront;\n        import std.ascii : isWhite;\n        while (true) {\n            while (!line.empty && line.front.isWhite) {\n                line.popFront;\n            }\n            if (!line.empty) break;\n            if (f.eof) return false;\n            line = lineBuf[];\n            f.readln(line);\n        }\n        return true;\n    }\n\n    private bool readSingle(T)(ref T x) {\n        import std.algorithm : findSplitBefore;\n        import std.string : strip;\n        import std.conv : parse;\n        if (!succ()) return false;\n        static if (isArray!T) {\n            alias E = ElementType!T;\n            static if (isSomeChar!E) {\n                 \n                 \n                auto r = line.findSplitBefore(\" \");\n                x = r[0].strip.dup;\n                line = r[1];\n            } else {\n                auto buf = line.split.map!(to!E).array;\n                static if (isStaticArray!T) {\n                     \n                    assert(buf.length == T.length);\n                }\n                x = buf;\n                line.length = 0;\n            }\n        } else {\n            x = line.parse!T;\n        }\n        return true;\n    }\n    int read(T, Args...)(ref T x, auto ref Args args) {\n        if (!readSingle(x)) return 0;\n        static if (args.length == 0) {\n            return 1;\n        } else {\n            return 1 + read(args);\n        }\n    }\n}\n\n\n \n \n\n \n"
  },
  {
    "language": "D",
    "code": "import std.stdio, std.array, std.string, std.conv, std.algorithm;\nimport std.typecons, std.range, std.random, std.math, std.container;\nimport std.numeric, std.bigint, core.bitop;\n\nvoid main() {\n    auto N = readln.chomp.to!int;\n    auto A = readln.split.map!(to!int).array;\n    \n    int[] B;\n    foreach (a; A) {\n        foreach (b; a-1..a+1) {\n            if (B.length > 0 && B[$-1] == b) B.popBack;\n            else B ~= b;\n        }\n    }\n\n    auto P = new bool[](10^^7 + 10);\n    fill(P, true);\n    P[0] = P[1] = false;\n    for (int i = 2; i < 10^^7 + 10; i++) {\n        if (!P[i]) continue;\n        for (int j = i + i; j < 10^^7 + 10; j += i) P[i] = false;\n    }\n\n\n    B.sort!\"a % 2 > b % 2\"();\n    int M = B.length.to!int;\n    int source = M;\n    int sink = M + 1;\n    int odd = B.map!(b => b % 2).sum;\n    int even = B.map!(b => 1 - b % 2).sum;\n    auto FF = new FordFulkerson(M + 2, source, sink);\n    foreach (i; 0..odd) FF.add_edge(source, i, 1);\n    foreach (i; odd..odd+even) FF.add_edge(i, sink, 1);\n    foreach (i; 0..odd) {\n        foreach (j; odd..odd+even) {\n            if (P[abs(B[i] - B[j])]) FF.add_edge(i, j, 1);\n        }\n    }\n\n    \n    int one = FF.run;\n    odd -= one;\n    even -= one;\n    int two = odd / 2 + even / 2;\n    int three = odd % 2 ? 1 : 0;\n\n    writeln(one + two * 2 + three * 3);\n}\n\n\n\nclass FordFulkerson {\n    int N, source, sink;\n    int[][] adj;\n    int[][] flow;\n    bool[] used;\n\n    this(int n, int s, int t) {\n        N = n;\n        source = s;\n        sink = t;\n        assert (s >= 0 && s < N && t >= 0 && t < N);\n        adj = new int[][](N);\n        flow = new int[][](N, N);\n        used = new bool[](N);\n    }\n\n    void add_edge(int from, int to, int cap) {\n        adj[from] ~= to;\n        adj[to] ~= from;\n        flow[from][to] = cap;\n    }\n\n    int dfs(int v, int min_cap) {\n        if (v == sink)\n            return min_cap;\n        if (used[v])\n            return 0;\n        used[v] = true;\n        foreach (to; adj[v]) {\n            if (!used[to] && flow[v][to] > 0) {\n                auto bottleneck = dfs(to, min(min_cap, flow[v][to]));\n                if (bottleneck == 0) continue;\n                flow[v][to] -= bottleneck;\n                flow[to][v] += bottleneck;\n                return bottleneck;\n            }\n        }\n        return 0;\n    }\n\n    int run() {\n        int ret = 0;\n        while (true) {\n            foreach (i; 0..N) used[i] = false;\n            int f = dfs(source, int.max);\n            if (f > 0)\n                ret += f;\n            else\n                return ret;\n        }\n    }\n}\n"
  },
  {
    "language": "D",
    "code": "/+ dub.sdl:\n    name \"F\"\n    dependency \"dcomp\" version=\">=0.6.0\"\n+/\n\nimport std.stdio, std.algorithm, std.range, std.conv, std.typecons, std.math;\n// import dcomp.foundation, dcomp.scanner;\n// import dcomp.graph.maxflow;\n\nimmutable MD = 10^^7 + 10^^6;\n\nbool[] prList(int n) {\n    bool[] pr = new bool[n+1];\n    pr[] = true;\n    pr[0] = pr[1] = false;\n    foreach (i; 2..n+1) {\n        if (!pr[i]) continue;\n        for (auto j = 2*i; j <= n; j += i) {\n            pr[j] = false;\n        }\n    }\n    return pr;\n}\n\nint main() {\n    auto pl = prList(MD);\n    auto sc = new Scanner(stdin);\n    int n;\n    int[] v;\n    sc.read(n, v);\n    bool[] buf = new bool[MD];\n    v.each!(x => buf[x] = true);\n\n    int[] od, ev;\n    foreach (int i; 0..MD-1) {\n        if (buf[i] != buf[i+1]) {\n            //add i\n            if (i % 2) {\n                od ~= i;\n            } else {\n                ev ~= i;\n            }\n        }\n    }\n    int A = od.length.to!int, B = ev.length.to!int;\n    int N = A + B + 2;\n    if (N > 1000) {\n        return 1;\n    }\n    alias E = Tuple!(int, \"to\", int, \"cap\", int, \"rev\");\n    E[][] g = new E[][](N);\n    void addEdge(int from, int to, int cap) {\n        debug writeln(\"add \", from, \" \", to, \" \", cap);\n        g[from] ~= E(to, cap, g[to].length.to!int);\n        g[to] ~= E(from, 0, g[from].length.to!int-1);\n    }\n    int sv = A+B, tv = A+B+1;\n    foreach (i; 0..A) {\n        addEdge(sv, i, 1);\n    }\n    foreach (j; 0..B) {\n        addEdge(A+j, tv, 1);\n    }\n    foreach (int i, d; od) {\n        foreach (int j, e; ev) {\n            if (pl[abs(d-e)]) {\n                addEdge(i, A+j, 1);\n            }\n        }\n    }\n    auto u = maxFlow!(int, 0)(g, sv, tv).flow;\n//    writeln(od, \" \", ev, \" \", u);\n    writeln(u + (A + B - 2 * u) + (A - u) % 2);\n    return 0;\n}\n/* IMPORT /home/yosupo/Program/dcomp/source/dcomp/graph/maxflow.d */\n// module dcomp.graph.maxflow;\n\n// import dcomp.container.deque;\n\nstruct maxFlowInfo(C) {\n    C flow;\n    bool[] dual;\n}\n\nmaxFlowInfo!(C) maxFlow(C, C EPS, T)(T g, int s, int t) {\n    assert(s != t);\n    import std.algorithm : map;\n    import std.range : array;\n    import std.conv : to;\n    int n = g.length.to!int;\n    int[] level = new int[n];\n    int[] iter = new int[n];\n\n    void bfs() {\n        level[] = -1; level[s] = 0;\n        auto que = Deque!int(0);\n        while (!que.empty) {\n            int v = que.back; que.removeBack();\n            foreach (e; g[v]) {\n                if (e.cap <= EPS) continue;\n                if (level[e.to] < 0) {\n                    level[e.to] = level[v] + 1;\n                    que.insertBack(e.to);\n                }\n            }\n        }\n    }\n\n    C dfs(int v, int t, C f) {\n        import std.algorithm : min;\n        if (v == t) return f;\n        auto edgeList = g[v][iter[v]..$];\n        foreach (ref e; edgeList) {\n            if (e.cap <= EPS) continue;\n            if (level[v] < level[e.to]) {\n                C d = dfs(e.to, t, min(f, e.cap));\n                if (d <= EPS) continue;\n                e.cap -= d;\n                g[e.to][e.rev].cap += d;\n                return d;\n            }\n            iter[v]++;\n        }\n        return 0;\n    }\n\n    C flow = 0;\n    while (true) {\n        bfs();\n        if (level[t] < 0) break;\n        iter[] = 0;\n        while (true) {\n            C f = dfs(s, t, C.max);\n            if (!f) break;\n            flow += f;\n        }\n    }\n\n    auto mfInfo = maxFlowInfo!C();\n    mfInfo.flow = flow;\n    mfInfo.dual = level.map!\"a == -1\".array;\n    return mfInfo;\n}\n\n\n\n \n\n\n \n\n \n/* IMPORT /home/yosupo/Program/dcomp/source/dcomp/foundation.d */\n// module dcomp.foundation;\n \nstatic if (__VERSION__ <= 2070) {\n    template fold(fun...) if (fun.length >= 1) {\n        auto fold(R, S...)(R r, S seed) {\n            import std.algorithm : reduce;\n            static if (S.length < 2) {\n                return reduce!fun(seed, r);\n            } else {\n                import std.typecons : tuple;\n                return reduce!fun(tuple(seed), r);\n            }\n        }\n    }\n     \n}\nversion (X86) static if (__VERSION__ < 2071) {\n    import core.bitop : bsf, bsr, popcnt;\n    int bsf(ulong v) {\n        foreach (i; 0..64) {\n            if (v & (1UL << i)) return i;\n        }\n        return -1;\n    }\n    int bsr(ulong v) {\n        foreach_reverse (i; 0..64) {\n            if (v & (1UL << i)) return i;\n        }\n        return -1;   \n    }\n    int popcnt(ulong v) {\n        int c = 0;\n        foreach (i; 0..64) {\n            if (v & (1UL << i)) c++;\n        }\n        return c;\n    }\n}\n/* IMPORT /home/yosupo/Program/dcomp/source/dcomp/container/deque.d */\n// module dcomp.container.deque;\n\n \nstruct Deque(T, bool mayNull = true) {\n    import core.exception : RangeError;\n    import core.memory : GC;\n    import std.range : ElementType, isInputRange;\n    import std.traits : isImplicitlyConvertible;\n\n    struct Payload {\n        T *d;\n        size_t st, length, cap;\n        @property bool empty() const { return length == 0; }\n        alias opDollar = length;\n        ref inout(T) opIndex(size_t i) inout {\n            version(assert) if (length <= i) throw new RangeError();\n            return d[(st+i >= cap) ? (st+i-cap) : st+i];\n        }\n        private void expand() {\n            import std.algorithm : max;\n            assert(length == cap);\n            auto nc = max(size_t(4), 2*cap);\n            T* nd = cast(T*)GC.malloc(nc * T.sizeof);\n            foreach (i; 0..length) {\n                nd[i] = this[i];\n            }\n            d = nd; st = 0; cap = nc;\n        }\n        void clear() {\n            st = length = 0;\n        }\n        void insertFront(T v) {\n            if (length == cap) expand();\n            if (st == 0) st += cap;\n            st--; length++;\n            this[0] = v; \n        }\n        void insertBack(T v) {\n            if (length == cap) expand();\n            length++;\n            this[length-1] = v; \n        }\n        void removeFront() {\n            assert(!empty, \"Deque.removeFront: Deque is empty\");        \n            st++; length--;\n            if (st == cap) st = 0;\n        }\n        void removeBack() {\n            assert(!empty, \"Deque.removeBack: Deque is empty\");        \n            length--;\n        }\n    }\n    struct RangeT(A) {\n        alias T = typeof(*(A.p));\n        alias E = typeof(A.p.d[0]);\n        T *p;\n        size_t a, b;\n        @property bool empty() const { return b <= a; }\n        @property size_t length() const { return b-a; }\n        @property RangeT save() { return RangeT(p, a, b); }\n        @property RangeT!(const A) save() const {\n            return typeof(return)(p, a, b);\n        }\n        alias opDollar = length;\n        @property ref inout(E) front() inout { return (*p)[a]; }\n        @property ref inout(E) back() inout { return (*p)[b-1]; }\n        void popFront() {\n            version(assert) if (empty) throw new RangeError();\n            a++;\n        }\n        void popBack() {\n            version(assert) if (empty) throw new RangeError();\n            b--;\n        }\n        ref inout(E) opIndex(size_t i) inout { return (*p)[i]; }\n        RangeT opSlice() { return this.save; }\n        RangeT opSlice(size_t i, size_t j) {\n            version(assert) if (i > j || a + j > b) throw new RangeError();\n            return typeof(return)(p, a+i, a+j);\n        }\n        RangeT!(const A) opSlice() const { return this.save; }\n        RangeT!(const A) opSlice(size_t i, size_t j) const {\n            version(assert) if (i > j || a + j > b) throw new RangeError();\n            return typeof(return)(p, a+i, a+j);\n        }\n    }\n    \n    alias Range = RangeT!Deque;\n    alias ConstRange = RangeT!(const Deque);\n    alias ImmutableRange = RangeT!(immutable Deque);\n    \n    Payload* p;\n    private void I() { if (mayNull && !p) p = new Payload(); }\n    private void C() const {\n        version(assert) if (mayNull && !p) throw new RangeError();\n    }\n    static if (!mayNull) {\n        @disable this();\n    }\n     \n    private this(Payload* p) {\n        this.p = p;\n    }\n    this(U)(U[] values...) if (isImplicitlyConvertible!(U, T)) {\n        p = new Payload();\n        foreach (v; values) {\n            insertBack(v);\n        }\n    }\n     \n    this(Range)(Range r)\n    if (isInputRange!Range &&\n    isImplicitlyConvertible!(ElementType!Range, T) &&\n    !is(Range == T[])) {\n        p = new Payload();\n        foreach (v; r) {\n            insertBack(v);\n        }\n    }\n    static Deque make() { return Deque(new Payload()); }\n    @property bool havePayload() const { return (!mayNull || p); }\n     \n    @property bool empty() const { return (!havePayload || p.empty); }\n     \n    @property size_t length() const { return (havePayload ? p.length : 0); }\n     \n    alias opDollar = length;\n    ref inout(T) opIndex(size_t i) inout {C; return (*p)[i]; }\n     \n    ref inout(T) front() inout {C; return (*p)[0]; }\n     \n    ref inout(T) back() inout {C; return (*p)[$-1]; }\n    void clear() { if (p) p.clear(); }\n     \n    void insertFront(T v) {I; p.insertFront(v); }\n     \n    void insertBack(T v) {I; p.insertBack(v); }\n     \n    alias stableInsertBack = insertBack;\n     \n    void removeFront() {C; p.removeFront(); }\n     \n    void removeBack() {C; p.removeBack(); }\n     \n    Range opSlice() {I; return Range(p, 0, length); }\n}\n\n\n \n\n \n\n \n\n \n\n \n\n \n/* IMPORT /home/yosupo/Program/dcomp/source/dcomp/scanner.d */\n// module dcomp.scanner;\n\n \nclass Scanner {\n    import std.stdio : File;\n    import std.conv : to;\n    import std.range : front, popFront, array, ElementType;\n    import std.array : split;\n    import std.traits : isSomeChar, isStaticArray, isArray; \n    import std.algorithm : map;\n    File f;\n    this(File f) {\n        this.f = f;\n    }\n    char[512] lineBuf;\n    char[] line;\n    private bool succ() {\n        import std.range.primitives : empty, front, popFront;\n        import std.ascii : isWhite;\n        while (true) {\n            while (!line.empty && line.front.isWhite) {\n                line.popFront;\n            }\n            if (!line.empty) break;\n            if (f.eof) return false;\n            line = lineBuf[];\n            f.readln(line);\n        }\n        return true;\n    }\n\n    private bool readSingle(T)(ref T x) {\n        import std.algorithm : findSplitBefore;\n        import std.string : strip;\n        import std.conv : parse;\n        if (!succ()) return false;\n        static if (isArray!T) {\n            alias E = ElementType!T;\n            static if (isSomeChar!E) {\n                 \n                 \n                auto r = line.findSplitBefore(\" \");\n                x = r[0].strip.dup;\n                line = r[1];\n            } else {\n                auto buf = line.split.map!(to!E).array;\n                static if (isStaticArray!T) {\n                     \n                    assert(buf.length == T.length);\n                }\n                x = buf;\n                line.length = 0;\n            }\n        } else {\n            x = line.parse!T;\n        }\n        return true;\n    }\n    int read(T, Args...)(ref T x, auto ref Args args) {\n        if (!readSingle(x)) return 0;\n        static if (args.length == 0) {\n            return 1;\n        } else {\n            return 1 + read(args);\n        }\n    }\n}\n\n\n \n \n\n \n"
  },
  {
    "language": "D",
    "code": "import std.stdio, std.array, std.string, std.conv, std.algorithm;\nimport std.typecons, std.range, std.random, std.math, std.container;\nimport std.numeric, std.bigint, core.bitop;\n\nvoid main() {\n    auto N = readln.chomp.to!int;\n    auto A = readln.split.map!(to!int).array;\n    \n    int[] B;\n    foreach (a; A) {\n        foreach (b; a-1..a+1) {\n            if (B.length > 0 && B[$-1] == b) B.popBack;\n            else B ~= b;\n        }\n    }\n\n    auto P = new bool[](10^^7 + 10);\n    fill(P, true);\n    P[0] = P[1] = false;\n    for (int i = 2; i < 10^^7 + 10; i++) {\n        if (!P[i]) continue;\n        for (int j = i + i; j < 10^^7 + 10; j += i) P[i] = false;\n    }\n\n\n    B.sort!\"a % 2 > b % 2\"();\n    int M = B.length.to!int;\n    int source = M;\n    int sink = M + 1;\n    int odd = B.map!(b => b % 2).sum;\n    int even = B.map!(b => 1 - b % 2).sum;\n    auto FF = new FordFulkerson(M + 2, source, sink);\n    foreach (i; 0..odd) FF.add_edge(source, i, 1);\n    foreach (i; odd..even) FF.add_edge(i, sink, 1);\n    foreach (i; 0..odd) {\n        foreach (j; odd..odd+even) {\n            if (P[abs(B[i] - B[j])]) FF.add_edge(i, j, 1);\n        }\n    }\n\n    \n    int one = FF.run;\n    odd -= one;\n    even -= one;\n    int two = odd / 2 + even / 2;\n    int three = odd % 2 ? 1 : 0;\n\n    writeln(one + two * 2 + three * 3);\n}\n\n\n\nclass FordFulkerson {\n    int N, source, sink;\n    int[][] adj;\n    int[][] flow;\n    bool[] used;\n\n    this(int n, int s, int t) {\n        N = n;\n        source = s;\n        sink = t;\n        assert (s >= 0 && s < N && t >= 0 && t < N);\n        adj = new int[][](N);\n        flow = new int[][](N, N);\n        used = new bool[](N);\n    }\n\n    void add_edge(int from, int to, int cap) {\n        adj[from] ~= to;\n        adj[to] ~= from;\n        flow[from][to] = cap;\n    }\n\n    int dfs(int v, int min_cap) {\n        if (v == sink)\n            return min_cap;\n        if (used[v])\n            return 0;\n        used[v] = true;\n        foreach (to; adj[v]) {\n            if (!used[to] && flow[v][to] > 0) {\n                auto bottleneck = dfs(to, min(min_cap, flow[v][to]));\n                if (bottleneck == 0) continue;\n                flow[v][to] -= bottleneck;\n                flow[to][v] += bottleneck;\n                return bottleneck;\n            }\n        }\n        return 0;\n    }\n\n    int run() {\n        int ret = 0;\n        while (true) {\n            foreach (i; 0..N) used[i] = false;\n            int f = dfs(source, int.max);\n            if (f > 0)\n                ret += f;\n            else\n                return ret;\n        }\n    }\n}\n"
  },
  {
    "language": "D",
    "code": "import std.stdio, std.array, std.string, std.conv, std.algorithm;\nimport std.typecons, std.range, std.random, std.math, std.container;\nimport std.numeric, std.bigint, core.bitop;\n\nvoid main() {\n    auto N = readln.chomp.to!int;\n    auto A = readln.split.map!(to!int).array;\n    \n    int[] B;\n    foreach (a; A) {\n        foreach (b; a-1..a+1) {\n            if (B.length > 0 && B[$-1] == b) B.popBack;\n            else B ~= b;\n        }\n    }\n\n    auto P = new bool[](10^^7 + 10);\n    fill(P, true);\n    P[0] = P[1] = false;\n    for (int i = 2; i < 10^^7 + 10; i++) {\n        if (!P[i]) continue;\n        for (int j = i + i; j < 10^^7 + 10; j += i) P[i] = false;\n    }\n\n\n    B.sort!\"a % 2 > b % 2\"();\n    int M = B.length.to!int;\n    int source = M;\n    int sink = M + 1;\n    int odd = B.map!(b => b % 2).sum;\n    int even = B.map!(b => 1 - b % 2).sum;\n    auto FF = new FordFulkerson(M + 2, source, sink);\n    foreach (i; 0..odd) FF.add_edge(source, i, 1);\n    foreach (i; odd..even) FF.add_edge(i, sink, 1);\n    foreach (i; 0..odd) {\n        foreach (j; odd..odd+even) {\n            if (P[abs(B[i] - B[j])]) FF.add_edge(i, j, 1);\n        }\n    }\n\n    \n    int one = FF.run;\n    odd -= one;\n    even -= one;\n    int two = min(odd, even);\n    int three = max(odd - two, even - two) / 2;\n\n    writeln(one + two * 2 + three * 3);\n}\n\n\n\nclass FordFulkerson {\n    int N, source, sink;\n    int[][] adj;\n    int[][] flow;\n    bool[] used;\n\n    this(int n, int s, int t) {\n        N = n;\n        source = s;\n        sink = t;\n        assert (s >= 0 && s < N && t >= 0 && t < N);\n        adj = new int[][](N);\n        flow = new int[][](N, N);\n        used = new bool[](N);\n    }\n\n    void add_edge(int from, int to, int cap) {\n        adj[from] ~= to;\n        adj[to] ~= from;\n        flow[from][to] = cap;\n    }\n\n    int dfs(int v, int min_cap) {\n        if (v == sink)\n            return min_cap;\n        if (used[v])\n            return 0;\n        used[v] = true;\n        foreach (to; adj[v]) {\n            if (!used[to] && flow[v][to] > 0) {\n                auto bottleneck = dfs(to, min(min_cap, flow[v][to]));\n                if (bottleneck == 0) continue;\n                flow[v][to] -= bottleneck;\n                flow[to][v] += bottleneck;\n                return bottleneck;\n            }\n        }\n        return 0;\n    }\n\n    int run() {\n        int ret = 0;\n        while (true) {\n            foreach (i; 0..N) used[i] = false;\n            int f = dfs(source, int.max);\n            if (f > 0)\n                ret += f;\n            else\n                return ret;\n        }\n    }\n}\n"
  },
  {
    "language": "D",
    "code": "/+ dub.sdl:\n    name \"F\"\n    dependency \"dcomp\" version=\">=0.6.0\"\n+/\n\nimport std.stdio, std.algorithm, std.range, std.conv, std.typecons, std.math;\n// import dcomp.foundation, dcomp.scanner;\n// import dcomp.graph.maxflow;\n\nimmutable MD = 10^^7 + 10^^6;\n\nbool[] prList(int n) {\n    bool[] pr = new bool[n+1];\n    pr[] = true;\n    pr[0] = pr[1] = false;\n    foreach (i; 2..n+1) {\n        if (!pr[i]) continue;\n        for (auto j = 2*i; j <= n; j += i) {\n            pr[j] = false;\n        }\n    }\n    return pr;\n}\n\nint main() {\n    auto pl = prList(MD);\n    auto sc = new Scanner(stdin);\n    int n;\n    int[] v;\n    sc.read(n, v);\n    bool[] buf = new bool[MD];\n    v.each!(x => buf[x] = true);\n\n    int[] od, ev;\n    foreach (int i; 0..MD-1) {\n        if (buf[i] != buf[i+1]) {\n            //add i\n            if (i % 2) {\n                od ~= i;\n            } else {\n                ev ~= i;\n            }\n        }\n    }\n    int A = od.length.to!int, B = ev.length.to!int;\n    int N = A + B + 2;\n    alias E = Tuple!(int, \"to\", int, \"cap\", int, \"rev\");\n    E[][] g = new E[][](N);\n    void addEdge(int from, int to, int cap) {\n        debug writeln(\"add \", from, \" \", to, \" \", cap);\n        g[from] ~= E(to, cap, g[to].length.to!int);\n        g[to] ~= E(from, 0, g[from].length.to!int-1);\n    }\n    int sv = A+B, tv = A+B+1;\n    foreach (i; 0..A) {\n        addEdge(sv, i, 1);\n    }\n    foreach (j; 0..B) {\n        addEdge(A+j, tv, 1);\n    }\n    foreach (int i, d; od) {\n        foreach (int j, e; ev) {\n            if (pl[abs(d-e)]) {\n                addEdge(i, A+j, 1);\n            }\n        }\n    }\n    auto u = maxFlow!(int, 0)(g, sv, tv).flow;\n//    writeln(od, \" \", ev, \" \", u);\n    writeln(u + (A + B - 2 * u) + (A - u) % 2);\n    return 0;\n}\n/* IMPORT /home/yosupo/Program/dcomp/source/dcomp/graph/maxflow.d */\n// module dcomp.graph.maxflow;\n\n// import dcomp.container.deque;\n\nstruct maxFlowInfo(C) {\n    C flow;\n    bool[] dual;\n}\n\nmaxFlowInfo!(C) maxFlow(C, C EPS, T)(T g, int s, int t) {\n    assert(s != t);\n    import std.algorithm : map;\n    import std.range : array;\n    import std.conv : to;\n    int n = g.length.to!int;\n    int[] level = new int[n];\n    int[] iter = new int[n];\n\n    void bfs() {\n        level[] = -1; level[s] = 0;\n        auto que = Deque!int(0);\n        while (!que.empty) {\n            int v = que.back; que.removeBack();\n            foreach (e; g[v]) {\n                if (e.cap <= EPS) continue;\n                if (level[e.to] < 0) {\n                    level[e.to] = level[v] + 1;\n                    que.insertBack(e.to);\n                }\n            }\n        }\n    }\n\n    C dfs(int v, int t, C f) {\n        import std.algorithm : min;\n        if (v == t) return f;\n        auto edgeList = g[v][iter[v]..$];\n        foreach (ref e; edgeList) {\n            if (e.cap <= EPS) continue;\n            if (level[v] < level[e.to]) {\n                C d = dfs(e.to, t, min(f, e.cap));\n                if (d <= EPS) continue;\n                e.cap -= d;\n                g[e.to][e.rev].cap += d;\n                return d;\n            }\n            iter[v]++;\n        }\n        return 0;\n    }\n\n    C flow = 0;\n    while (true) {\n        bfs();\n        if (level[t] < 0) break;\n        iter[] = 0;\n        while (true) {\n            C f = dfs(s, t, C.max);\n            if (!f) break;\n            flow += f;\n        }\n    }\n\n    auto mfInfo = maxFlowInfo!C();\n    mfInfo.flow = flow;\n    mfInfo.dual = level.map!\"a == -1\".array;\n    return mfInfo;\n}\n\n\n\n \n\n\n \n\n \n/* IMPORT /home/yosupo/Program/dcomp/source/dcomp/foundation.d */\n// module dcomp.foundation;\n \nstatic if (__VERSION__ <= 2070) {\n    template fold(fun...) if (fun.length >= 1) {\n        auto fold(R, S...)(R r, S seed) {\n            import std.algorithm : reduce;\n            static if (S.length < 2) {\n                return reduce!fun(seed, r);\n            } else {\n                import std.typecons : tuple;\n                return reduce!fun(tuple(seed), r);\n            }\n        }\n    }\n     \n}\nversion (X86) static if (__VERSION__ < 2071) {\n    import core.bitop : bsf, bsr, popcnt;\n    int bsf(ulong v) {\n        foreach (i; 0..64) {\n            if (v & (1UL << i)) return i;\n        }\n        return -1;\n    }\n    int bsr(ulong v) {\n        foreach_reverse (i; 0..64) {\n            if (v & (1UL << i)) return i;\n        }\n        return -1;   \n    }\n    int popcnt(ulong v) {\n        int c = 0;\n        foreach (i; 0..64) {\n            if (v & (1UL << i)) c++;\n        }\n        return c;\n    }\n}\n/* IMPORT /home/yosupo/Program/dcomp/source/dcomp/container/deque.d */\n// module dcomp.container.deque;\n\n \nstruct Deque(T, bool mayNull = true) {\n    import core.exception : RangeError;\n    import core.memory : GC;\n    import std.range : ElementType, isInputRange;\n    import std.traits : isImplicitlyConvertible;\n\n    struct Payload {\n        T *d;\n        size_t st, length, cap;\n        @property bool empty() const { return length == 0; }\n        alias opDollar = length;\n        ref inout(T) opIndex(size_t i) inout {\n            version(assert) if (length <= i) throw new RangeError();\n            return d[(st+i >= cap) ? (st+i-cap) : st+i];\n        }\n        private void expand() {\n            import std.algorithm : max;\n            assert(length == cap);\n            auto nc = max(size_t(4), 2*cap);\n            T* nd = cast(T*)GC.malloc(nc * T.sizeof);\n            foreach (i; 0..length) {\n                nd[i] = this[i];\n            }\n            d = nd; st = 0; cap = nc;\n        }\n        void clear() {\n            st = length = 0;\n        }\n        void insertFront(T v) {\n            if (length == cap) expand();\n            if (st == 0) st += cap;\n            st--; length++;\n            this[0] = v; \n        }\n        void insertBack(T v) {\n            if (length == cap) expand();\n            length++;\n            this[length-1] = v; \n        }\n        void removeFront() {\n            assert(!empty, \"Deque.removeFront: Deque is empty\");        \n            st++; length--;\n            if (st == cap) st = 0;\n        }\n        void removeBack() {\n            assert(!empty, \"Deque.removeBack: Deque is empty\");        \n            length--;\n        }\n    }\n    struct RangeT(A) {\n        alias T = typeof(*(A.p));\n        alias E = typeof(A.p.d[0]);\n        T *p;\n        size_t a, b;\n        @property bool empty() const { return b <= a; }\n        @property size_t length() const { return b-a; }\n        @property RangeT save() { return RangeT(p, a, b); }\n        @property RangeT!(const A) save() const {\n            return typeof(return)(p, a, b);\n        }\n        alias opDollar = length;\n        @property ref inout(E) front() inout { return (*p)[a]; }\n        @property ref inout(E) back() inout { return (*p)[b-1]; }\n        void popFront() {\n            version(assert) if (empty) throw new RangeError();\n            a++;\n        }\n        void popBack() {\n            version(assert) if (empty) throw new RangeError();\n            b--;\n        }\n        ref inout(E) opIndex(size_t i) inout { return (*p)[i]; }\n        RangeT opSlice() { return this.save; }\n        RangeT opSlice(size_t i, size_t j) {\n            version(assert) if (i > j || a + j > b) throw new RangeError();\n            return typeof(return)(p, a+i, a+j);\n        }\n        RangeT!(const A) opSlice() const { return this.save; }\n        RangeT!(const A) opSlice(size_t i, size_t j) const {\n            version(assert) if (i > j || a + j > b) throw new RangeError();\n            return typeof(return)(p, a+i, a+j);\n        }\n    }\n    \n    alias Range = RangeT!Deque;\n    alias ConstRange = RangeT!(const Deque);\n    alias ImmutableRange = RangeT!(immutable Deque);\n    \n    Payload* p;\n    private void I() { if (mayNull && !p) p = new Payload(); }\n    private void C() const {\n        version(assert) if (mayNull && !p) throw new RangeError();\n    }\n    static if (!mayNull) {\n        @disable this();\n    }\n     \n    private this(Payload* p) {\n        this.p = p;\n    }\n    this(U)(U[] values...) if (isImplicitlyConvertible!(U, T)) {\n        p = new Payload();\n        foreach (v; values) {\n            insertBack(v);\n        }\n    }\n     \n    this(Range)(Range r)\n    if (isInputRange!Range &&\n    isImplicitlyConvertible!(ElementType!Range, T) &&\n    !is(Range == T[])) {\n        p = new Payload();\n        foreach (v; r) {\n            insertBack(v);\n        }\n    }\n    static Deque make() { return Deque(new Payload()); }\n    @property bool havePayload() const { return (!mayNull || p); }\n     \n    @property bool empty() const { return (!havePayload || p.empty); }\n     \n    @property size_t length() const { return (havePayload ? p.length : 0); }\n     \n    alias opDollar = length;\n    ref inout(T) opIndex(size_t i) inout {C; return (*p)[i]; }\n     \n    ref inout(T) front() inout {C; return (*p)[0]; }\n     \n    ref inout(T) back() inout {C; return (*p)[$-1]; }\n    void clear() { if (p) p.clear(); }\n     \n    void insertFront(T v) {I; p.insertFront(v); }\n     \n    void insertBack(T v) {I; p.insertBack(v); }\n     \n    alias stableInsertBack = insertBack;\n     \n    void removeFront() {C; p.removeFront(); }\n     \n    void removeBack() {C; p.removeBack(); }\n     \n    Range opSlice() {I; return Range(p, 0, length); }\n}\n\n\n \n\n \n\n \n\n \n\n \n\n \n/* IMPORT /home/yosupo/Program/dcomp/source/dcomp/scanner.d */\n// module dcomp.scanner;\n\n \nclass Scanner {\n    import std.stdio : File;\n    import std.conv : to;\n    import std.range : front, popFront, array, ElementType;\n    import std.array : split;\n    import std.traits : isSomeChar, isStaticArray, isArray; \n    import std.algorithm : map;\n    File f;\n    this(File f) {\n        this.f = f;\n    }\n    char[512] lineBuf;\n    char[] line;\n    private bool succ() {\n        import std.range.primitives : empty, front, popFront;\n        import std.ascii : isWhite;\n        while (true) {\n            while (!line.empty && line.front.isWhite) {\n                line.popFront;\n            }\n            if (!line.empty) break;\n            if (f.eof) return false;\n            line = lineBuf[];\n            f.readln(line);\n        }\n        return true;\n    }\n\n    private bool readSingle(T)(ref T x) {\n        import std.algorithm : findSplitBefore;\n        import std.string : strip;\n        import std.conv : parse;\n        if (!succ()) return false;\n        static if (isArray!T) {\n            alias E = ElementType!T;\n            static if (isSomeChar!E) {\n                 \n                 \n                auto r = line.findSplitBefore(\" \");\n                x = r[0].strip.dup;\n                line = r[1];\n            } else {\n                auto buf = line.split.map!(to!E).array;\n                static if (isStaticArray!T) {\n                     \n                    assert(buf.length == T.length);\n                }\n                x = buf;\n                line.length = 0;\n            }\n        } else {\n            x = line.parse!T;\n        }\n        return true;\n    }\n    int read(T, Args...)(ref T x, auto ref Args args) {\n        if (!readSingle(x)) return 0;\n        static if (args.length == 0) {\n            return 1;\n        } else {\n            return 1 + read(args);\n        }\n    }\n}\n\n\n \n \n\n \n"
  },
  {
    "language": "Python",
    "code": "import sys\ninput = sys.stdin.readline\n\nimport itertools\nfrom collections import defaultdict\nimport numpy as np\n\nN = int(input())\nX = set(int(x) for x in input().split())\n\n# 2は素数でないとして扱って\nU = 10**7 + 100\nis_prime = np.zeros(U,dtype=np.bool)\nis_prime[3::2] = 1\nfor p in range(3,U,2):\n    if p*p > U:\n        break\n    if is_prime[p]:\n        is_prime[p*p::p+p] = 0\n\n# imosで値を入れないといけない場所\nX ^= set(x+1 for x in X)\n\nEV = set(x for x in X if x%2 == 0)\nOD = set(x for x in X if x%2 == 1)\n\n# 1手でとれるペアを見つける：最大マッチング\n# 奇点から偶点に辺を貼る\nsource = -1\nsink = -2\ngraph = defaultdict(set)\nfor x in EV:\n    graph[x].add(sink)\nfor x in OD:\n    graph[source].add(x)\nfor x,y in itertools.product(OD,EV):\n    if is_prime[abs(x-y)]:\n        graph[x].add(y)\n        \ndef bfs():\n    level = defaultdict(int)\n    q = [source]\n    level[source] = 1\n    d = 1\n    while q:\n        d += 1\n        if level[sink] != 0:\n            break\n        qq = []\n        for x in q:\n            for y in graph[x]:\n                if level[y]!=0:\n                    continue\n                level[y] = d\n                qq.append(y)\n        q = qq\n    return level\n\ndef dfs(v,level,itr):\n    if v == sink:\n        return True\n    for w in itr[v]:\n        if level[w]!=level[v]+1:\n            continue\n        if dfs(w,level,itr):\n            graph[v].remove(w)\n            graph[w].add(v)\n            return True\n    return False\n\ndef max_flow():\n    flow = 0\n    while True:\n        level = bfs()\n        if level[sink] == 0:\n            return flow\n        itr = {v:iter(graph[v]) for v in graph}\n        while dfs(source,level,itr):\n            flow += 1\n\nf = max_flow()\n\nod = len(OD); ev = len(EV)\nanswer = f\nod -= f; ev -= f\nanswer += 2*(od//2); od %= 2\nanswer += 2*(ev//2); ev %= 2\nif od:\n    answer += 3\nprint(answer)\n"
  },
  {
    "language": "Python",
    "code": "import itertools\nfrom math import sqrt\ndef chunk(a):\n    i = 0\n    res = []\n    while i < len(a):\n        res.append(a[i])\n        while i != len(a) - 1 and a[i + 1] == a[i] + 1:\n            i += 1\n        res.append(a[i] + 1)\n        i += 1\n    return res\n\ndef augment(g, src, dest):\n    o = [None] * len(g)\n    q = [(src, src)]\n    while q:\n        w = q.pop()\n        if o[w[0]] is None:\n            o[w[0]] = w[1]\n            for s in g[w[0]]:\n                if o[s] is None:\n                    q.append((s, w[0]))\n    if not o[dest]:\n        return False\n    i = dest\n    while i != src:\n        g[o[i]].discard(i)\n        g[i].add(o[i])\n        i = o[i]\n    return True\n\ndef match(a):\n    l = {}\n    c = 0\n    matches = 0\n    for i, j in a:\n        if i not in l:\n            l[i] = c\n            c += 1\n        if j not in l:\n            l[j] = c\n            c += 1\n    L = {v: k for k, v in l.items()}\n    g = [set() for i in range(len(l) + 2)]\n    src = len(l)\n    dest = src + 1\n    for i, j in a:\n        g[src].add(l[i])\n        g[l[i]].add(l[j])\n        g[l[j]].add(dest)\n    while augment(g, src, dest):\n        matches += 1\n    return matches\n\ndef prime(n):\n    for i in range(2, min(n, int(sqrt(n) + 7))):\n        if n % i == 0:\n            return False\n    return n > 1\n\ndef pairs(b):\n    c = []\n    for i in b:\n        for j in b:\n            if i % 2 == 0 and j % 2 == 1 and prime(abs(i - j)):\n                c.append((i, j))\n    return c\n\nn = int(input())\na = list(map(int, input().split()))\nb = chunk(a)\nr = match(pairs(b))\ne = len(list(filter(lambda x: x % 2 == 0, b)))\no = len(b) - e\nprint(int(r + 2 * ((e - r) // 2 + (o - r) // 2) + 3 * (e % 2)))\n"
  },
  {
    "language": "Python",
    "code": "import sys\ninput = sys.stdin.readline\n\nimport itertools\nfrom collections import defaultdict\nimport numpy as np\n\nN = int(input())\nX = set(int(x) for x in input().split())\n\n# 2は素数でないとして扱って\nU = 10**7 + 100\nis_prime = np.zeros(U,dtype=np.bool)\nis_prime[3::2] = 1\nfor p in range(3,U,2):\n    if p*p > U:\n        break\n    if is_prime[p]:\n        is_prime[p*p::p+p] = 0\n\n# imosで値を入れないといけない場所\nX ^= set(x+1 for x in X)\n\nEV = set(x for x in X if x%2 == 0)\nOD = set(x for x in X if x%2 == 1)\n\n# 1手でとれるペアを見つける：最大マッチング\n# 奇点から偶点に辺を貼る\nsource = -1\nsink = -2\ngraph = defaultdict(dict)\nfor x in EV:\n    graph[x][sink] = 1\n    graph[sink][x] = 0\nfor x in OD:\n    graph[source][x] = 1\n    graph[x][source] = 0\nfor x,y in itertools.product(OD,EV):\n    if is_prime[abs(x-y)]:\n        graph[x][y] = 1\n        graph[y][x] = 0\n\ndef bfs():\n    level = defaultdict(int)\n    q = [source]\n    level[source] = 1\n    d = 1\n    while q:\n        d += 1\n        if level[sink] != 0:\n            break\n        qq = []\n        for x in q:\n            for y,cap in graph[x].items():\n                if cap==0 or level[y]!=0:\n                    continue\n                level[y] = d\n                qq.append(y)\n        q = qq\n    return level\n\ndef dfs(v,f,level,itr):\n    if v == sink:\n        return f\n    for w,cap in itr[v]:\n        if cap==0 or level[w]!=level[v]+1:\n            continue\n        d = dfs(w,min(f,cap),level,itr)\n        if d:\n            graph[v][w] -= d\n            graph[w][v] += d\n            return d\n    return 0\n\ndef max_flow():\n    flow = 0\n    while True:\n        level = bfs()\n        if level[sink] == 0:\n            return flow\n        itr = {v:iter(graph[v].items()) for v in graph}\n        while True:\n            f = dfs(source,10**9,level,itr)\n            if f == 0:\n                break\n            flow += f\n\nf = max_flow()\n\nod = len(OD); ev = len(EV)\nanswer = f\nod -= f; ev -= f\nanswer += 2*(od//2); od %= 2\nanswer += 2*(ev//2); ev %= 2\nif od:\n    answer += 3\nprint(answer)"
  },
  {
    "language": "Python",
    "code": "import sys\ninput = sys.stdin.readline\n\nimport itertools\nfrom collections import defaultdict\nimport numpy as np\n\nN = int(input())\nX = set(int(x) for x in input().split())\n\n# 2は素数でないとして扱って\nU = 10**7 + 100\nis_prime = np.zeros(U,dtype=np.bool)\nis_prime[3::2] = 1\nfor p in range(3,U,2):\n    if p*p > U:\n        break\n    if is_prime[p]:\n        is_prime[p*p::p+p] = 0\n\n# imosで値を入れないといけない場所\nX ^= set(x+1 for x in X)\n\nEV = set(x for x in X if x%2 == 0)\nOD = set(x for x in X if x%2 == 1)\n\n# 1手でとれるペアを見つける：最大マッチング\n# 奇点から偶点に辺を貼る\nsource = -1\nsink = -2\ngraph = defaultdict(dict)\nfor x in EV:\n    graph[x][sink] = 1\n    graph[sink][x] = 0\nfor x in OD:\n    graph[source][x] = 1\n    graph[x][source] = 0\nfor x,y in itertools.product(OD,EV):\n    if is_prime[abs(x-y)]:\n        graph[x][y] = 1\n        graph[y][x] = 0\n\ndef bfs():\n    level = defaultdict(int)\n    q = [source]\n    level[source] = 1\n    d = 1\n    while q:\n        d += 1\n        if level[sink] != 0:\n            break\n        qq = []\n        for x in q:\n            for y,cap in graph[x].items():\n                if cap==0 or level[y]!=0:\n                    continue\n                level[y] = d\n                qq.append(y)\n        q = qq\n    return level\n\ndef dfs(v,f,level,itr):\n    if v == sink:\n        return f\n    for w,cap in itr[v]:\n        if cap==0 or level[w]!=level[v]+1:\n            continue\n        d = dfs(w,min(f,cap),level,itr)\n        if d:\n            graph[v][w] += d\n            graph[w][v] -= d\n            return d\n    return 0\n\ndef max_flow():\n    flow = 0\n    while True:\n        level = bfs()\n        if level[sink] == 0:\n            return flow\n        itr = {v:iter(graph[v].items()) for v in graph}\n        while True:\n            f = dfs(source,10**9,level,itr)\n            if f == 0:\n                break\n            flow += f\n\nf = max_flow()\n\nod = len(OD); ev = len(EV)\nanswer = f\nod -= f; ev -= f\nanswer += 2*(od//2); od %= 2\nanswer += 2*(ev//2); ev %= 2\nif od:\n    answer += 3\nprint(answer)"
  },
  {
    "language": "Python",
    "code": "import sys\ninput = sys.stdin.readline\n\nimport itertools\nfrom collections import defaultdict\nimport numpy as np\n\nN = int(input())\nX = set(int(x) for x in input().split())\n\n# 2は素数でないとして扱って\nU = 10**7 + 100\nis_prime = np.zeros(U,dtype=np.bool)\nis_prime[3::2] = 1\nfor p in range(3,U,2):\n    if p*p > U:\n        break\n    if is_prime[p]:\n        is_prime[p*p::p+p] = 0\n\n# imosで値を入れないといけない場所\nX ^= set(x+1 for x in X)\n\nEV = set(x for x in X if x%2 == 0)\nOD = set(x for x in X if x%2 == 1)\n\n# 1手でとれるペアを見つける：最大マッチング\n# 奇点から偶点に辺を貼る\nsource = -1\nsink = -2\ngraph = defaultdict(set)\nfor x in EV:\n    graph[x].add(sink)\nfor x in OD:\n    graph[source].add(x)\nfor x,y in itertools.product(OD,EV):\n    if is_prime[abs(x-y)]:\n        graph[x].add(y)\n        \ndef bfs():\n    level = defaultdict(int)\n    q = [source]\n    level[source] = 1\n    d = 1\n    while q:\n        d += 1\n        if level[sink] != 0:\n            break\n        qq = []\n        for x in q:\n            for y in graph[x]:\n                if level[y]!=0:\n                    continue\n                level[y] = d\n                qq.append(y)\n        q = qq\n    return level\n\ndef dfs(v,level,itr):\n    if v == sink:\n        return True\n    for w in itr[v]:\n        if level[w]!=level[v]+1:\n            continue\n        if w in graph[v] and dfs(w,level,itr):\n            graph[v].remove(w)\n            graph[w].add(v)\n            return True\n    return False\n\ndef max_flow():\n    flow = 0\n    while True:\n        level = bfs()\n        if level[sink] == 0:\n            return flow\n        itr = {v:iter(graph[v]) for v in graph}\n        while dfs(source,level,itr):\n            flow += 1\n\nf = max_flow()\n\nod = len(OD); ev = len(EV)\nanswer = f\nod -= f; ev -= f\nanswer += 2*(od//2); od %= 2\nanswer += 2*(ev//2); ev %= 2\nif od:\n    answer += 3\nprint(answer)\n"
  },
  {
    "language": "Python",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int MAXN = 1000100;\n\n#define rep(i, a, b) for(int i = a; i < (b); ++i)\n#define trav(a, x) for(auto& a : x)\n#define all(x) begin(x), end(x)\n#define sz(x) (int)(x).size()\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\nint N;\nint arr[MAXN];\n \nstruct Dinic {\n    struct Edge {\n        int to, rev;\n        ll c, f;\n    };\n    vi lvl, ptr, q;\n    vector<vector<Edge>> adj;\n    Dinic(int n) : lvl(n), ptr(n), q(n), adj(n) {}\n    void addEdge(int a, int b, ll c, int rcap = 0) {\n        adj[a].push_back({b, sz(adj[b]), c, 0});\n        adj[b].push_back({a, sz(adj[a]) - 1, rcap, 0});\n    }\n    ll dfs(int v, int t, ll f) {\n        if (v == t || !f) return f;\n        for (int& i = ptr[v]; i < sz(adj[v]); i++) {\n            Edge& e = adj[v][i];\n            if (lvl[e.to] == lvl[v] + 1)\n                if (ll p = dfs(e.to, t, min(f, e.c - e.f))) {\n                    e.f += p, adj[e.to][e.rev].f -= p;\n                    return p;\n                }\n        }\n        return 0;\n    }\n    ll calc(int s, int t) {\n        ll flow = 0; q[0] = s;\n        rep(L,0,31) do { // 'int L=30' maybe faster for random data\n            lvl = ptr = vi(sz(q));\n            int qi = 0, qe = lvl[s] = 1;\n            while (qi < qe && !lvl[t]) {\n                int v = q[qi++];\n                trav(e, adj[v])\n                    if (!lvl[e.to] && (e.c - e.f) >> (30 - L))\n                        q[qe++] = e.to, lvl[e.to] = lvl[v] + 1;\n            }\n            while (ll p = dfs(s, t, LLONG_MAX)) flow += p;\n        } while (lvl[t]);\n        return flow;\n    }\n};\n\nbool pr (int x)\n{\n    for (int i = 2; i * i <= x; i++)\n        if (x % i == 0) return false;\n    return true;\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(0);\n\n    cin >> N;\n    for (int i = 0; i < N; i++)\n        cin >> arr[i];\n    vector <int> v;\n    for (int i = 0; i < N; i++)\n    {\n        if (i == 0 || arr[i-1] + 1 < arr[i])\n            v.push_back(arr[i]);\n        if (i == N - 1 || arr[i+1] - 1 > arr[i])\n            v.push_back(arr[i]+1);\n    }\n\n    int m = v.size();\n    Dinic d (m + 2);\n    int ne = 0, no = 0;\n    for (int i = 0; i < m; i++)\n    {\n        if (v[i] % 2 == 0)\n        {\n            d.addEdge (m, i, 1);\n            ne++;\n        }\n        else\n        {\n            d.addEdge (i, m + 1, 1);\n            no++;\n        }\n    }\n    for (int i = 0; i < m; i++)\n        for (int j = 0; j < m; j++)\n        {\n            if (v[i] % 2 == 0 && v[j] % 2 == 1)\n            {\n                if (pr (abs (i - j)))\n                    d.addEdge (i, j, 1);\n            }\n        }\n\n    int r = d.calc (m, m + 1);\n\n    int res = r;\n    ne -= r;\n    no -= r;\n    res += 2 * (ne / 2 + no / 2);\n    res += 3 * (ne % 2 + no % 2);\n    cout << res << \"\\n\";\n}"
  },
  {
    "language": "Python",
    "code": "import itertools\nfrom math import sqrt\ndef chunk(a):\n    i = 0\n    res = []\n    while i < len(a):\n        res.append(a[i])\n        while i != len(a) - 1 and a[i + 1] == a[i] + 1:\n            i += 1\n        res.append(a[i] + 1)\n        i += 1\n    return res\n\ndef augment(g, src, dest):\n    o = [None] * len(g)\n    q = [(src, src)]\n    while q:\n        w = q.pop()\n        if o[w[0]] is None:\n            o[w[0]] = w[1]\n            for s in g[w[0]]:\n                if o[s] is None:\n                    q.append((s, w[0]))\n    if not o[dest]:\n        return False\n    i = dest\n    while i != src:\n        g[o[i]].discard(i)\n        g[i].add(o[i])\n        i = o[i]\n    return True\n\ndef match(a):\n    l = {}\n    c = 0\n    matches = 0\n    for i, j in a:\n        if i not in l:\n            l[i] = c\n            c += 1\n        if j not in l:\n            l[j] = c\n            c += 1\n    L = {v: k for k, v in l.items()}\n    g = [set() for i in range(len(l) + 2)]\n    src = len(l)\n    dest = src + 1\n    for i, j in a:\n        g[src].add(l[i])\n        g[l[i]].add(l[j])\n        g[l[j]].add(dest)\n    while augment(g, src, dest):\n        matches += 1\n    res = g[src].copy()\n    for i in range(len(g)):\n        if dest in g[i]:\n            res.add(i)\n    return len(g[dest])\n\ndef prime(n):\n    for i in range(2, min(n, int(sqrt(n) + 7))):\n        if n % i == 0:\n            return False\n    return n > 1\nn = int(input())\na = list(map(int, input().split()))\nb = chunk(a)\nc = []\nfor i in b:\n    for j in b:\n        if i % 2 == 0 and j % 2 == 1 and prime(abs(i - j)):\n            c.append((i, j))\nr = match(c)\nev = len(list(filter(lambda x: x % 2 == 0, b)))\nprint(int(r + 2 * ((ev - r) // 2 + (len(b) - ev + r) // 2) + 1.5 * (ev % 2 + (len(b) - ev) % 2)))\n"
  },
  {
    "language": "Python",
    "code": "import itertools\nfrom math import sqrt\ndef chunk(a):\n    i = 0\n    res = []\n    while i < len(a):\n        res.append(a[i])\n        while i != len(a) - 1 and a[i + 1] == a[i] + 1:\n            i += 1\n        res.append(a[i] + 1)\n        i += 1\n    return res\n\ndef augment(g, src, dest):\n    o = [None] * len(g)\n    q = [(src, src)]\n    while q:\n        w = q.pop()\n        if o[w[0]] is None:\n            o[w[0]] = w[1]\n            for s in g[w[0]]:\n                if o[s] is None:\n                    q.append((s, w[0]))\n    if not o[dest]:\n        return False\n    i = dest\n    while i != src:\n        g[o[i]].discard(i)\n        g[i].add(o[i])\n        i = o[i]\n    return True\n\ndef match(a):\n    l = {}\n    c = 0\n    matches = 0\n    for i, j in a:\n        if i not in l:\n            l[i] = c\n            c += 1\n        if j not in l:\n            l[j] = c\n            c += 1\n    L = {v: k for k, v in l.items()}\n    g = [set() for i in range(len(l) + 2)]\n    src = len(l)\n    dest = src + 1\n    for i, j in a:\n        g[src].add(l[i])\n        g[l[i]].add(l[j])\n        g[l[j]].add(dest)\n    while augment(g, src, dest):\n        matches += 1\n    return matches\n\ndef prime(n):\n    for i in range(2, min(n, int(sqrt(n) + 7))):\n        if n % i == 0:\n            return False\n    return n > 1\n\ndef pairs(b):\n    c = []\n    for i in b:\n        for j in b:\n            if i % 2 == 0 and j % 2 == 1 and prime(abs(i - j)):\n                c.append((i, j))\n    return c\n\nn = int(input())\na = list(map(int, input().split()))\nb = chunk(a)\nr = match(pairs(b))\ne = len(list(filter(lambda x: x % 2 == 0, b)))\no = len(b) - e\nprint(int(r + 2 * ((e - r) // 2 + (o - r) // 2) + 3 * ((e - r) % 2)))"
  },
  {
    "language": "Rust",
    "code": "#[allow(unused_imports)]\nuse std::cmp::*;\n#[allow(unused_imports)]\nuse std::collections::*;\nuse std::io::{Write, BufWriter};\n// https://qiita.com/tanakh/items/0ba42c7ca36cd29d0ac8\nmacro_rules! input {\n    ($($r:tt)*) => {\n        let stdin = std::io::stdin();\n        let mut bytes = std::io::Read::bytes(std::io::BufReader::new(stdin.lock()));\n        let mut next = move || -> String{\n            bytes\n                .by_ref()\n                .map(|r|r.unwrap() as char)\n                .skip_while(|c|c.is_whitespace())\n                .take_while(|c|!c.is_whitespace())\n                .collect()\n        };\n        input_inner!{next, $($r)*}\n    };\n}\n\nmacro_rules! input_inner {\n    ($next:expr) => {};\n    ($next:expr, ) => {};\n\n    ($next:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($next, $t);\n        input_inner!{$next $($r)*}\n    };\n}\n\nmacro_rules! read_value {\n    ($next:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($next, $t)),* )\n    };\n\n    ($next:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($next, $t)).collect::<Vec<_>>()\n    };\n\n    ($next:expr, chars) => {\n        read_value!($next, String).chars().collect::<Vec<char>>()\n    };\n\n    ($next:expr, usize1) => {\n        read_value!($next, usize) - 1\n    };\n\n    ($next:expr, [ $t:tt ]) => {{\n        let len = read_value!($next, usize);\n        (0..len).map(|_| read_value!($next, $t)).collect::<Vec<_>>()\n    }};\n\n    ($next:expr, $t:ty) => {\n        $next().parse::<$t>().expect(\"Parse error\")\n    };\n}\n\nfn prime_sieve(n: usize) -> Vec<bool> {\n    let mut ans = vec![true; n];\n    ans[0] = false;\n    ans[1] = false;\n    for i in 2 .. n {\n        if !ans[i] { continue; }\n        for j in 2 .. (n - 1) / i + 1 {\n            ans[i * j] = false;\n        }\n    }\n    ans\n}\n\nfn bipartite_matching(g: &[Vec<bool>]) -> usize {\n    let n = g.len();\n    if n == 0 { return 0; }\n    let m = g[0].len();\n    let mut to = vec![None; m];\n    let mut visited = vec![false; n];\n    let mut ans = 0;\n    fn augment(v: usize, g: &[Vec<bool>], m: usize,\n               visited: &mut [bool], to: &mut [Option<usize>])\n               -> bool {\n        if visited[v] { return false; }\n        visited[v] = true;\n        for i in 0 .. m {\n            if !g[v][i] { continue; }\n            if let Some(w) = to[i] {\n                if augment(w, g, m, visited, to) {\n                    to[i] = Some(v);\n                    return true;\n                }\n            } else {\n                to[i] = Some(v);\n                return true;\n            }\n        }\n        false\n    }\n    for i in 0 .. n {\n        for v in visited.iter_mut() { *v = false; }\n        if augment(i, &g, m, &mut visited, &mut to) { ans += 1; }\n    }\n    ans\n}\n\nfn solve() {\n    let out = std::io::stdout();\n    let mut out = BufWriter::new(out.lock());\n    macro_rules! puts {\n        ($($format:tt)*) => (write!(out,$($format)*).unwrap());\n    }\n    input! { x: [i64] }\n    const W: usize = 1 << 24;\n    let is_prime = prime_sieve(W);\n    let mut hs = HashSet::new();\n    for x in x {\n        if hs.contains(&x) {\n            hs.remove(&x);\n        } else {\n            hs.insert(x);\n        }\n        let x = x + 1;\n        if hs.contains(&x) {\n            hs.remove(&x);\n        } else {\n            hs.insert(x);\n        }\n    }\n    let mut even = Vec::new();\n    let mut odd = Vec::new();\n    for x in hs {\n        if x % 2 == 0 { even.push(x); }\n        else { odd.push(x); }\n    }\n    let n = even.len();\n    let m = odd.len();\n    let mut g = vec![vec![false; m]; n];\n    for i in 0 .. n {\n        for j in 0 .. m {\n            if is_prime[(even[i] - odd[j]).abs() as usize] {\n                g[i][j] = true;\n            }\n        }\n    }\n    let size = bipartite_matching(&g);\n    let mut tot = 3 * ((n - size) % 2);\n    tot += 2 * ((n - size) / 2);\n    tot += 2 * ((m - size) / 2);\n    tot += size;\n    puts!(\"{}\\n\", tot);\n}\n\nfn main() {\n    // In order to avoid potential stack overflow, spawn a new thread.\n    let stack_size = 104_857_600; // 100 MB\n    let thd = std::thread::Builder::new().stack_size(stack_size);\n    thd.spawn(|| solve()).unwrap().join().unwrap();\n}\n"
  },
  {
    "language": "Rust",
    "code": "#![allow(unused_imports, unused_variables, dead_code)]\nuse std::io::*;\nuse std::fmt::*;\nuse std::str::*;\nuse std::cmp::*;\nuse std::collections::*;\n\npub trait InputValue {\n    fn parse(s: &str) -> Self;\n}\n\npub fn read<T: InputValue>() -> T {\n    let mut buf = String::new();\n    let _ = stdin().read_line(&mut buf);\n    T::parse(&buf.trim())\n}\n\npub fn readnc<T: InputValue>() -> Vec<T> {\n    let mut vec = vec![];\n    let line: String = read();\n    for token in line.split_whitespace() {\n        vec.push(T::parse(token));\n    }\n    vec\n}\n\npub fn readn<T: InputValue>(n: usize) -> Vec<T> {\n    let mut vec = vec![];\n    for _ in 0..n {\n        vec.push(read());\n    }\n    vec\n}\n\nmacro_rules! parse_single_value {\n    ($($t:ty),*) => {\n        $(\n            impl InputValue for $t {\n                fn parse(s: &str) -> $t { s.parse().unwrap() }\n            }\n        )*\n\t}\n}\nparse_single_value!(i32, i64, f32, f64, usize, String);\n\nmacro_rules! parse_tuple {\n\t($($t:ident),*) => {\n\t\timpl<$($t),*> InputValue for ($($t),*) where $($t: InputValue),* {\n\t\t\tfn parse(s: &str) -> ($($t),*) {\n\t\t\t\tlet mut tokens = s.split_whitespace();\n\t\t\t\tlet t = ($($t::parse(tokens.next().unwrap())),*);\n\t\t\t\tt\n\t\t\t}\n\t\t}\n\t}\n}\nparse_tuple!(A, B);\nparse_tuple!(A, B, C);\n\n// ===\nconst MAX_FLOW: i32 = 100000000;\n\n#[derive(Clone, Copy)]\nstruct Edge {\n    from: usize,\n    to: usize,\n    cap: i32,\n    maxcap: i32\n}\n\nimpl Edge {\n    fn goto(&self, from: usize) -> usize {\n        self.from + self.to - from\n    }\n\n    fn cap(&self, from: usize) -> i32 {\n        if self.from == from {\n            self.cap\n        } else {\n            self.maxcap - self.cap\n        }\n    }\n}\n\nstruct FlowGraph {\n    n: usize,\n    graph: Vec<Vec<usize>>,\n    edges: Vec<Edge>,\n    level: Vec<i32>,\n    itr: Vec<usize>\n}\n\nimpl FlowGraph {\n    fn new(n: usize) -> Self {\n        let graph = vec![vec![]; n];\n        let level = vec![0; n];\n        let itr = vec![0; n];\n        FlowGraph { n: n, graph: graph, edges: vec![], level: level, itr: itr }\n    }\n\n    fn edge(&mut self, from: usize, to: usize, cap: i32) {\n        let e = Edge { from: from, to: to, cap: cap, maxcap: cap };\n        let l = self.edges.len();\n        self.graph[from].push(l);\n        self.graph[to].push(l);\n        self.edges.push(e);\n    }\n\n    fn dfs(&mut self, now: usize, to: usize, flow: i32) -> i32 {\n        if now == to {\n            return flow;\n        }\n        for i in self.itr[now]..self.graph[now].len() {\n            self.itr[now] = i;\n            let eidx = self.graph[now][i];\n\n            let e = self.edges[eidx];\n            let next = e.goto(now);\n            let ecap = e.cap(now);\n            if ecap > 0 && self.level[now] < self.level[next] {\n                let d = self.dfs(next, to, min(flow, ecap));\n                if d >= 1 {\n                    let e = &mut self.edges[eidx];\n                    if e.from == now {\n                        e.cap -= d;\n                    } else {\n                        e.cap += d;\n                    }\n                    return d;\n                }\n            }\n\n        }\n        return 0;\n    }\n\n    fn bfs(&mut self, from: usize) {\n        for i in 0..self.n {\n            self.level[i] = -1;\n        }\n        self.level[from] = 0;\n        let mut q: VecDeque<usize> = VecDeque::new();\n        q.push_back(from);\n        while let Some(idx) = q.pop_front() {\n            for &eidx in &self.graph[idx] {\n                let e = &self.edges[eidx];\n                let to = e.goto(idx);\n                if e.cap(idx) >= 1 && self.level[to] == -1 {\n                    self.level[to] = self.level[idx] + 1;\n                    q.push_back(e.to);\n                }\n            }\n        }\n    }\n\n    fn max_flow(&mut self, from: usize, to: usize) -> i32 {\n        let mut flow = 0;\n        while true {\n            self.bfs(from);\n            if self.level[to] == -1 {\n                return flow;\n            }\n            for i in 0..self.n {\n                self.itr[i] = 0;\n            }\n            while true {\n                let f = self.dfs(from, to, MAX_FLOW);\n                if f <= 0 {\n                    break;\n                }\n                flow += f;\n            }\n        }\n        0\n    }\n}\n\n// ===\n\nfn testflow() {\n    let mut flow = FlowGraph::new(5);\n    flow.edge(0, 1, 1);\n    flow.edge(1, 2, 1);\n    flow.edge(0, 3, 1);\n    flow.edge(2, 4, 1);\n    flow.edge(3, 4, 1);\n    println!(\"f={}\", flow.max_flow(0, 4));\n}\n\nfn prime(n: usize) -> Vec<bool> {\n    let mut ret = vec![true; n];\n    ret[0] = false;\n    ret[1] = false;\n    for i in 2..n {\n        if !ret[i] {\n            continue\n        }\n        let mut ii = i * i;\n        while ii < n {\n            ret[ii] = false;\n            ii += i;\n        }\n    }\n    ret\n}\n\nfn main() {\n    let n: usize = read();\n    let x: Vec<usize> = readnc();\n\n    let mut fpos = vec![];\n    fpos.push(x[0]);\n\n    for i in 1..n {\n        if x[i-1] + 1 < x[i] {\n            fpos.push(x[i-1]+1);\n            fpos.push(x[i])\n        }\n    }\n    fpos.push(x[n-1]+1);\n\n    let isp = prime(10000100);\n\n    let n = fpos.len();\n    let mut even = 0;\n    let mut odd = 0;\n    for &f in &fpos {\n        if f % 2 == 0 {\n            even += 1;\n        } else {\n            odd += 1;\n        }\n    }\n    \n    let mut flow = FlowGraph::new(n + 2);\n    let source = n;\n    let sink = n + 1;\n    for i in 0..n {\n        for j in 0..n {\n            if i != j || fpos[i] % 2 == 0 && fpos[j] % 2 == 1 {\n                flow.edge(i, j, 1);\n            }\n        }\n    }\n\n    let pair = flow.max_flow(source, sink);\n    let even_left = even - pair;\n    let odd_left = odd - pair;\n    println!(\"{}\", pair + (even_left / 2) * 2 + (odd_left / 2) * 2 + max(0, odd_left % 2) * 3);\n}"
  },
  {
    "language": "Rust",
    "code": "#![allow(unused_imports, unused_variables, dead_code)]\nuse std::io::*;\nuse std::fmt::*;\nuse std::str::*;\nuse std::cmp::*;\nuse std::collections::*;\n\npub trait InputValue {\n    fn parse(s: &str) -> Self;\n}\n\npub fn read<T: InputValue>() -> T {\n    let mut buf = String::new();\n    let _ = stdin().read_line(&mut buf);\n    T::parse(&buf.trim())\n}\n\npub fn readnc<T: InputValue>() -> Vec<T> {\n    let mut vec = vec![];\n    let line: String = read();\n    for token in line.split_whitespace() {\n        vec.push(T::parse(token));\n    }\n    vec\n}\n\npub fn readn<T: InputValue>(n: usize) -> Vec<T> {\n    let mut vec = vec![];\n    for _ in 0..n {\n        vec.push(read());\n    }\n    vec\n}\n\nmacro_rules! parse_single_value {\n    ($($t:ty),*) => {\n        $(\n            impl InputValue for $t {\n                fn parse(s: &str) -> $t { s.parse().unwrap() }\n            }\n        )*\n\t}\n}\nparse_single_value!(i32, i64, f32, f64, usize, String);\n\nmacro_rules! parse_tuple {\n\t($($t:ident),*) => {\n\t\timpl<$($t),*> InputValue for ($($t),*) where $($t: InputValue),* {\n\t\t\tfn parse(s: &str) -> ($($t),*) {\n\t\t\t\tlet mut tokens = s.split_whitespace();\n\t\t\t\tlet t = ($($t::parse(tokens.next().unwrap())),*);\n\t\t\t\tt\n\t\t\t}\n\t\t}\n\t}\n}\nparse_tuple!(A, B);\nparse_tuple!(A, B, C);\n\n// ===\nconst MAX_FLOW: i32 = 100000000;\n\n#[derive(Clone, Copy)]\nstruct Edge {\n    from: usize,\n    to: usize,\n    cap: i32,\n    maxcap: i32\n}\n\nimpl Edge {\n    fn goto(&self, from: usize) -> usize {\n        self.from + self.to - from\n    }\n\n    fn cap(&self, from: usize) -> i32 {\n        if self.from == from {\n            self.cap\n        } else {\n            self.maxcap - self.cap\n        }\n    }\n}\n\nstruct FlowGraph {\n    n: usize,\n    graph: Vec<Vec<usize>>,\n    edges: Vec<Edge>,\n    level: Vec<i32>,\n    itr: Vec<usize>\n}\n\nimpl FlowGraph {\n    fn new(n: usize) -> Self {\n        let graph = vec![vec![]; n];\n        let level = vec![0; n];\n        let itr = vec![0; n];\n        FlowGraph { n: n, graph: graph, edges: vec![], level: level, itr: itr }\n    }\n\n    fn edge(&mut self, from: usize, to: usize, cap: i32) {\n        let e = Edge { from: from, to: to, cap: cap, maxcap: cap };\n        let l = self.edges.len();\n        self.graph[from].push(l);\n        self.graph[to].push(l);\n        self.edges.push(e);\n    }\n\n    fn dfs(&mut self, now: usize, to: usize, flow: i32) -> i32 {\n        if now == to {\n            return flow;\n        }\n        for i in self.itr[now]..self.graph[now].len() {\n            self.itr[now] = i;\n            let eidx = self.graph[now][i];\n\n            let e = self.edges[eidx];\n            let next = e.goto(now);\n            let ecap = e.cap(now);\n            if ecap > 0 && self.level[now] < self.level[next] {\n                let d = self.dfs(next, to, min(flow, ecap));\n                if d >= 1 {\n                    let e = &mut self.edges[eidx];\n                    if e.from == now {\n                        e.cap -= d;\n                    } else {\n                        e.cap += d;\n                    }\n                    return d;\n                }\n            }\n\n        }\n        return 0;\n    }\n\n    fn bfs(&mut self, from: usize) {\n        for i in 0..self.n {\n            self.level[i] = -1;\n        }\n        self.level[from] = 0;\n        let mut q: VecDeque<usize> = VecDeque::new();\n        q.push_back(from);\n        while let Some(idx) = q.pop_front() {\n            for &eidx in &self.graph[idx] {\n                let e = &self.edges[eidx];\n                let to = e.goto(idx);\n                if e.cap(idx) >= 1 && self.level[to] == -1 {\n                    self.level[to] = self.level[idx] + 1;\n                    q.push_back(e.to);\n                }\n            }\n        }\n    }\n\n    fn max_flow(&mut self, from: usize, to: usize) -> i32 {\n        let mut flow = 0;\n        loop {\n            self.bfs(from);\n            if self.level[to] == -1 {\n                return flow;\n            }\n            for i in 0..self.n {\n                self.itr[i] = 0;\n            }\n            loop {\n                let f = self.dfs(from, to, MAX_FLOW);\n                if f <= 0 {\n                    break;\n                }\n                flow += f;\n            }\n        }\n    }\n}\n\n// ===\n\nfn testflow() {\n    let mut flow = FlowGraph::new(5);\n    flow.edge(0, 1, 1);\n    flow.edge(1, 2, 1);\n    flow.edge(0, 3, 1);\n    flow.edge(2, 4, 1);\n    flow.edge(3, 4, 1);\n    println!(\"f={}\", flow.max_flow(0, 4));\n}\n\nfn prime(n: usize) -> Vec<bool> {\n    let mut ret = vec![true; n];\n    ret[0] = false;\n    ret[1] = false;\n    for i in 2..n {\n        if !ret[i] {\n            continue\n        }\n        let mut ii = i * i;\n        while ii < n {\n            ret[ii] = false;\n            ii += i;\n        }\n    }\n    ret\n}\n\nfn main() {\n    let n: usize = read();\n    let x: Vec<usize> = readnc();\n\n    let mut fpos = vec![];\n    fpos.push(x[0]);\n\n    for i in 1..n {\n        if x[i-1] + 1 < x[i] {\n            fpos.push(x[i-1]+1);\n            fpos.push(x[i])\n        }\n    }\n    fpos.push(x[n-1]+1);\n\n    let isp = prime(10000100);\n\n    let n = fpos.len();\n    let mut even = 0;\n    let mut odd = 0;\n    for &f in &fpos {\n        if f % 2 == 0 {\n            even += 1;\n        } else {\n            odd += 1;\n        }\n    }\n\n    let mut flow = FlowGraph::new(n + 2);\n    let source = n;\n    let sink = n + 1;\n    for i in 0..n {\n        for j in 0..n {\n            if i != j || fpos[i] % 2 == 0 && fpos[j] % 2 == 1 {\n                flow.edge(i, j, 1);\n            }\n        }\n    }\n    for i in 0..n {\n        if fpos[i] % 2 == 0 {\n            flow.edge(source, i, 1);\n        } else {\n            flow.edge(i, sink, 1);\n        }\n    }\n\n    let pair = flow.max_flow(source, sink);\n    let even_left = even - pair;\n    let odd_left = odd - pair;\n    println!(\"{}\", pair + (even_left / 2) * 2 + (odd_left / 2) * 2 + max(0, odd_left % 2) * 3);\n}"
  },
  {
    "language": "Rust",
    "code": "use std::io::*;\nuse std::str::FromStr;\n\n#[allow(dead_code)]\nfn read<T: FromStr>() -> T {\n    let stdin = stdin();\n    let stdin = stdin.lock();\n    let token: String = stdin\n        .bytes()\n        .map(|c| c.expect(\"failed to read char\") as char)\n        .skip_while(|c| c.is_whitespace())\n        .take_while(|c| !c.is_whitespace())\n        .collect();\n    token.parse().ok().expect(\"failed to parse token\")\n}\n\nfn large_mul_mod(mut lhs: i64, mut rhs: i64, modulo: i64) -> i64 {\n    let mut ret = 0i64;\n    while rhs > 0 {\n        if (rhs & 1) == 1 {\n            ret = (ret + lhs) % modulo;\n        }\n        rhs >>= 1;\n        lhs = (lhs + lhs) % modulo;\n    }\n    ret\n}\n\nfn pow_mod(mut base: i64, mut power: i64, modulo: i64) -> i64 {\n    let mut ans = 1i64;\n    if modulo < (1 << 30) {\n        while power > 0 {\n            if (power & 1) == 1 {\n                ans = ans * base % modulo;\n            }\n            power >>= 1;\n            base = base * base % modulo;\n        }\n    } else {\n        while power > 0 {\n            if (power & 1) == 1 {\n                ans = large_mul_mod(ans, base, modulo);\n            }\n            power >>= 1;\n            base = large_mul_mod(base, base, modulo);\n        }\n    }\n    ans\n}\n\nfn suspect(t: i64, mut s: i64, d: i64, n: i64) -> bool {\n    let mut x = pow_mod(t, d, n);\n    if x == 1 {\n        return true;\n    }\n    while s > 0 {\n        s -= 1;\n        if x == n - 1 {\n            return true;\n        }\n        if n < (1 << 30) {\n            x = x * x % n;\n        } else {\n            x = large_mul_mod(x, x, n);\n        }\n    }\n    false\n}\n\n#[allow(dead_code)]\nfn is_prime(n: i64) -> bool {\n    if n <= 1 || (n > 2 && n % 2 == 0) {\n        return false;\n    }\n    let mut d = n - 1;\n    let mut s = 0;\n    while (d & 1) == 0 {\n        s += 1;\n        d >>= 1;\n    }\n    // let test = [2, 7, 61, 1i64 << 60]; // is for n < 2^32\n    let test = [2, 3, 5, 7, 11, 13, 17, 19, 23, 1i64 << 60]; // is for n < 10^16 (at least)\n    for &t in test.iter() {\n        if t >= n {\n            break;\n        }\n        if !suspect(t, s, d, n) {\n            return false;\n        }\n    }\n    true\n}\n\n#[test]\nfn test_is_prime() {\n    assert!(is_prime(2));\n    assert!(is_prime(3));\n    assert!(is_prime(5));\n    assert!(is_prime(7));\n    assert!(is_prime(11));\n    assert!(is_prime(103));\n    assert!(is_prime(1000000007));\n    assert!(is_prime(1000000009));\n    assert!(is_prime(3478329271));\n    assert!(is_prime(777177177781));\n    assert!(is_prime(67280421310721));\n\n    assert!(!is_prime(-1));\n    assert!(!is_prime(0));\n    assert!(!is_prime(1));\n    assert!(!is_prime(4));\n    assert!(!is_prime(9));\n    assert!(!is_prime(77));\n    assert!(!is_prime(1000000001));\n    assert!(!is_prime(4002002002));\n    assert!(!is_prime(7478329271));\n    assert!(!is_prime(1357436473381));\n}\n\ntype Weight = i32;\n#[allow(dead_code)]\n#[derive(Clone, Debug, Eq, PartialEq)]\nstruct Edge {\n    index: usize,\n    src: usize,\n    dest: usize,\n    weight: Weight,\n}\n#[allow(dead_code)]\nimpl Edge {\n    fn new(index: usize, src: usize, dest: usize, weight: Weight) -> Edge {\n        Edge {\n            index: index,\n            src: src,\n            dest: dest,\n            weight: weight,\n        }\n    }\n}\nimpl std::cmp::Ord for Edge {\n    fn cmp(&self, other: &Self) -> std::cmp::Ordering {\n        (self.weight, self.src, self.dest).cmp(&(other.weight, other.src, other.dest))\n    }\n}\nimpl std::cmp::PartialOrd for Edge {\n    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {\n        Some(self.cmp(other))\n    }\n}\ntype Edges = Vec<Edge>;\ntype Graph = Vec<Edges>;\n#[allow(dead_code)]\nfn graph_new(n: usize) -> Graph {\n    vec![vec![]; n]\n}\n\nuse std::collections::VecDeque;\n// index ^ 1 is reverse edge\n#[allow(dead_code)]\nfn add_bi_edge(graph: &mut Graph, index: &mut usize, src: usize, dest: usize, weight: Weight) {\n    graph[src].push(Edge::new(*index, src, dest, weight));\n    *index += 1;\n    graph[dest].push(Edge::new(*index, dest, src, weight));\n    *index += 1;\n}\n#[allow(dead_code)]\nfn add_uni_edge(graph: &mut Graph, index: &mut usize, src: usize, dest: usize, weight: Weight) {\n    graph[src].push(Edge::new(*index, src, dest, weight));\n    *index += 1;\n    graph[dest].push(Edge::new(*index, dest, src, 0));\n    *index += 1;\n}\n\n#[allow(dead_code)]\nfn augment(\n    g: &Graph,\n    capacity: &mut Vec<Weight>,\n    level: &Vec<usize>,\n    finished: &mut Vec<bool>,\n    from: usize,\n    t: usize,\n    cur: Weight,\n) -> Weight {\n    if from == t || cur == 0 {\n        return cur;\n    }\n    if finished[from] {\n        return 0;\n    }\n    for edge in g[from].iter() {\n        let to = edge.dest;\n        if level[to] != level[from] + 1 {\n            continue;\n        }\n        let ncur = std::cmp::min(cur, capacity[edge.index]);\n        let f = augment(g, capacity, level, finished, to, t, ncur);\n        if f > 0 {\n            capacity[edge.index] -= f;\n            capacity[edge.index ^ 1] += f;\n            return f;\n        }\n    }\n    finished[from] = true;\n    0\n}\n\n#[allow(dead_code)]\nfn max_flow(g: &Graph, e: usize, s: usize, t: usize) -> Weight {\n    let n = g.len();\n    let mut capacity: Vec<Weight> = vec![0; e];\n    for from in 0..n {\n        for edge in g[from].iter() {\n            capacity[edge.index] += edge.weight;\n        }\n    }\n    let mut ans = 0;\n    loop {\n        let mut level = vec![usize::max_value(); n];\n        level[s] = 0;\n        let mut que = VecDeque::<usize>::new();\n        que.push_back(s);\n        while let Some(from) = que.pop_front() {\n            if from == t {\n                break;\n            }\n            for edge in g[from].iter() {\n                let to = edge.dest;\n                if capacity[edge.index] > 0 && level[to] == usize::max_value() {\n                    que.push_back(to);\n                    level[to] = level[from] + 1;\n                }\n            }\n        }\n        let mut finished = vec![false; n];\n        let mut end = true;\n        loop {\n            let f = augment(\n                g,\n                &mut capacity,\n                &level,\n                &mut finished,\n                s,\n                t,\n                Weight::max_value(),\n            );\n            if f == 0 {\n                break;\n            }\n            ans += f;\n            end = false;\n        }\n        if end {\n            break;\n        }\n    }\n    ans\n}\n\nfn main() {\n    let n = read::<usize>();\n    let mut seq = vec![0i64; n];\n    for i in 0..n {\n        seq[i] = read::<i64>();\n    }\n    let mut start = -1;\n    let mut positions = vec![];\n    for i in 0..n {\n        if start == -1 {\n            start = seq[i];\n        }\n        if i == n - 1 || seq[i] + 1 != seq[i + 1] {\n            positions.push(start);\n            positions.push(seq[i] + 1);\n            start = -1;\n        }\n    }\n    // println!(\"{:?}\", positions);\n    let n = positions.len();\n    let source = n;\n    let dest = n + 1;\n    let size = n + 2;\n    let mut graph = graph_new(size);\n    let mut e = 0;\n    let mut odd_cnt = 0;\n    let mut even_cnt = 0;\n    for i in 0..n {\n        let pos = positions[i];\n        if pos % 2 == 0 {\n            odd_cnt += 1;\n            add_uni_edge(&mut graph, &mut e, source, i, 1);\n            for j in 0..n {\n                if is_prime((positions[j] - pos).abs()) {\n                    add_uni_edge(&mut graph, &mut e, i, j, 1);\n                }\n            }\n        } else {\n            even_cnt += 1;\n            add_uni_edge(&mut graph, &mut e, i, dest, 1);\n        }\n    }\n    let flow = max_flow(&graph, e, source, dest);\n    let mut ans = flow + (odd_cnt - flow) / 2 * 2 + (even_cnt - flow) / 2 * 2;\n    if (odd_cnt - flow) % 2 == 1 {\n        ans += 3;\n    }\n    println!(\"{}\", ans);\n}\n"
  },
  {
    "language": "Rust",
    "code": "#![allow(unused_imports, unused_variables, dead_code)]\nuse std::io::*;\nuse std::fmt::*;\nuse std::str::*;\nuse std::cmp::*;\nuse std::collections::*;\n\npub trait InputValue {\n    fn parse(s: &str) -> Self;\n}\n\npub fn read<T: InputValue>() -> T {\n    let mut buf = String::new();\n    let _ = stdin().read_line(&mut buf);\n    T::parse(&buf.trim())\n}\n\npub fn readnc<T: InputValue>() -> Vec<T> {\n    let mut vec = vec![];\n    let line: String = read();\n    for token in line.split_whitespace() {\n        vec.push(T::parse(token));\n    }\n    vec\n}\n\npub fn readn<T: InputValue>(n: usize) -> Vec<T> {\n    let mut vec = vec![];\n    for _ in 0..n {\n        vec.push(read());\n    }\n    vec\n}\n\nmacro_rules! parse_single_value {\n    ($($t:ty),*) => {\n        $(\n            impl InputValue for $t {\n                fn parse(s: &str) -> $t { s.parse().unwrap() }\n            }\n        )*\n\t}\n}\nparse_single_value!(i32, i64, f32, f64, usize, String);\n\nmacro_rules! parse_tuple {\n\t($($t:ident),*) => {\n\t\timpl<$($t),*> InputValue for ($($t),*) where $($t: InputValue),* {\n\t\t\tfn parse(s: &str) -> ($($t),*) {\n\t\t\t\tlet mut tokens = s.split_whitespace();\n\t\t\t\tlet t = ($($t::parse(tokens.next().unwrap())),*);\n\t\t\t\tt\n\t\t\t}\n\t\t}\n\t}\n}\nparse_tuple!(A, B);\nparse_tuple!(A, B, C);\n\n// ===\nconst MAX_FLOW: i32 = 100000000;\n\n#[derive(Clone, Copy)]\nstruct Edge {\n    from: usize,\n    to: usize,\n    cap: i32,\n    maxcap: i32\n}\n\nimpl Edge {\n    fn goto(&self, from: usize) -> usize {\n        self.from + self.to - from\n    }\n\n    fn cap(&self, from: usize) -> i32 {\n        if self.from == from {\n            self.cap\n        } else {\n            self.maxcap - self.cap\n        }\n    }\n}\n\nstruct FlowGraph {\n    n: usize,\n    graph: Vec<Vec<usize>>,\n    edges: Vec<Edge>,\n    level: Vec<i32>,\n    itr: Vec<usize>\n}\n\nimpl FlowGraph {\n    fn new(n: usize) -> Self {\n        let graph = vec![vec![]; n];\n        let level = vec![0; n];\n        let itr = vec![0; n];\n        FlowGraph { n: n, graph: graph, edges: vec![], level: level, itr: itr }\n    }\n\n    fn edge(&mut self, from: usize, to: usize, cap: i32) {\n        let e = Edge { from: from, to: to, cap: cap, maxcap: cap };\n        let l = self.edges.len();\n        self.graph[from].push(l);\n        self.graph[to].push(l);\n        self.edges.push(e);\n    }\n\n    fn dfs(&mut self, now: usize, to: usize, flow: i32) -> i32 {\n        if now == to {\n            return flow;\n        }\n        for i in self.itr[now]..self.graph[now].len() {\n            self.itr[now] = i;\n            let eidx = self.graph[now][i];\n\n            let e = self.edges[eidx];\n            let next = e.goto(now);\n            let ecap = e.cap(now);\n            if ecap > 0 && self.level[now] < self.level[next] {\n                let d = self.dfs(next, to, min(flow, ecap));\n                if d >= 1 {\n                    let e = &mut self.edges[eidx];\n                    if e.from == now {\n                        e.cap -= d;\n                    } else {\n                        e.cap += d;\n                    }\n                    return d;\n                }\n            }\n\n        }\n        return 0;\n    }\n\n    fn bfs(&mut self, from: usize) {\n        for i in 0..self.n {\n            self.level[i] = -1;\n        }\n        self.level[from] = 0;\n        let mut q: VecDeque<usize> = VecDeque::new();\n        q.push_back(from);\n        while let Some(idx) = q.pop_front() {\n            for &eidx in &self.graph[idx] {\n                let e = &self.edges[eidx];\n                let to = e.goto(idx);\n                if e.cap(idx) >= 1 && self.level[to] == -1 {\n                    self.level[to] = self.level[idx] + 1;\n                    q.push_back(to);\n                }\n            }\n        }\n    }\n\n    fn max_flow(&mut self, from: usize, to: usize) -> i32 {\n        let mut flow = 0;\n        loop {\n            self.bfs(from);\n            if self.level[to] < 0 {\n                return flow;\n            }\n            for i in 0..self.n {\n                self.itr[i] = 0;\n            }\n            loop {\n                let f = self.dfs(from, to, MAX_FLOW);\n                if f <= 0 {\n                    break;\n                }\n                flow += f;\n            }\n        }\n    }\n}\n\n// ===\n\nfn testflow() {\n    let mut flow = FlowGraph::new(5);\n    flow.edge(0, 1, 1);\n    flow.edge(1, 2, 1);\n    flow.edge(3, 0, 1);\n    flow.edge(2, 4, 1);\n    flow.edge(3, 4, 1);\n    println!(\"f={}\", flow.max_flow(0, 4));\n}\n\nfn prime(n: usize) -> Vec<bool> {\n    let mut ret = vec![true; n];\n    ret[0] = false;\n    ret[1] = false;\n    for i in 2..n {\n        if !ret[i] {\n            continue\n        }\n        let mut ii = i * i;\n        while ii < n {\n            ret[ii] = false;\n            ii += i;\n        }\n    }\n    ret\n}\n\nfn main() {\n    let n: usize = read();\n    let x: Vec<i32> = readnc();\n\n    let mut fpos = vec![];\n    fpos.push(x[0]);\n\n    for i in 1..n {\n        if x[i-1] + 1 < x[i] {\n            fpos.push(x[i-1]+1);\n            fpos.push(x[i])\n        }\n    }\n    fpos.push(x[n-1]+1);\n\n    let isp = prime(10000100);\n\n    let n = fpos.len();\n    let mut even = 0;\n    let mut odd = 0;\n    for &f in &fpos {\n        if f % 2 == 0 {\n            even += 1;\n        } else {\n            odd += 1;\n        }\n    }\n\n    let mut flow = FlowGraph::new(n + 2);\n    let source = n;\n    let sink = n + 1;\n    for i in 0..n {\n        for j in 0..n {\n            let d = (fpos[i] - fpos[j]).abs() as usize;\n            if i != j && fpos[i] % 2 == 0 && fpos[j] % 2 == 1 && isp[d] {\n                flow.edge(i, j, 1);\n            }\n        }\n    }\n    for i in 0..n {\n        if fpos[i] % 2 == 0 {\n            flow.edge(source, i, 1);\n        } else {\n            flow.edge(i, sink, 1);\n        }\n    }\n\n    let pair = flow.max_flow(source, sink);\n    let even_left = even - pair;\n    let odd_left = odd - pair;\n    println!(\"{}\", pair + (even_left / 2) * 2 + (odd_left / 2) * 2 + max(0, odd_left % 2) * 3);\n}"
  },
  {
    "language": "Rust",
    "code": "#[allow(unused_imports)]\nuse std::cmp::*;\n#[allow(unused_imports)]\nuse std::collections::*;\nuse std::io::{Write, BufWriter};\n// https://qiita.com/tanakh/items/0ba42c7ca36cd29d0ac8\nmacro_rules! input {\n    (source = $s:expr, $($r:tt)*) => {\n        let mut iter = $s.split_whitespace();\n        let mut next = || { iter.next().unwrap() };\n        input_inner!{next, $($r)*}\n    };\n    ($($r:tt)*) => {\n        let stdin = std::io::stdin();\n        let mut bytes = std::io::Read::bytes(std::io::BufReader::new(stdin.lock()));\n        let mut next = move || -> String{\n            bytes\n                .by_ref()\n                .map(|r|r.unwrap() as char)\n                .skip_while(|c|c.is_whitespace())\n                .take_while(|c|!c.is_whitespace())\n                .collect()\n        };\n        input_inner!{next, $($r)*}\n    };\n}\n\nmacro_rules! input_inner {\n    ($next:expr) => {};\n    ($next:expr, ) => {};\n\n    ($next:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($next, $t);\n        input_inner!{$next $($r)*}\n    };\n}\n\nmacro_rules! read_value {\n    ($next:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($next, $t)),* )\n    };\n\n    ($next:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($next, $t)).collect::<Vec<_>>()\n    };\n\n    ($next:expr, chars) => {\n        read_value!($next, String).chars().collect::<Vec<char>>()\n    };\n\n    ($next:expr, usize1) => {\n        read_value!($next, usize) - 1\n    };\n\n    ($next:expr, [ $t:tt ]) => {{\n        let len = read_value!($next, usize);\n        (0..len).map(|_| read_value!($next, $t)).collect::<Vec<_>>()\n    }};\n\n    ($next:expr, $t:ty) => {\n        $next().parse::<$t>().expect(\"Parse error\")\n    };\n}\n\n/**\n * Dinic's algorithm for maximum flow problem.\n * Verified by: yukicoder No.177 (http://yukicoder.me/submissions/148371)\n * Min-cut (the second element of max_flow's returned values) is not verified.\n */\n\n#[derive(Clone)]\nstruct Edge<T> {\n    to: usize,\n    cap: T,\n    rev: usize, // rev is the position of the reverse edge in graph[to]\n}\n\nstruct Dinic<T> {\n    graph: Vec<Vec<Edge<T>>>,\n    iter: Vec<usize>,\n    zero: T,\n}\n\nimpl<T> Dinic<T>\n    where T: Clone,\n          T: Copy,\n          T: Ord,\n          T: std::ops::AddAssign,\n          T: std::ops::SubAssign,\n{\n    fn bfs(&self, s: usize, level: &mut [Option<usize>]) {\n        let n = level.len();\n        for i in 0 .. n {\n            level[i] = None;\n        }\n        let mut que = std::collections::VecDeque::new();\n        level[s] = Some(0);\n        que.push_back(s);\n        while let Some(v) = que.pop_front() {\n            for e in self.graph[v].iter() {\n\t        if e.cap > self.zero && level[e.to] == None {\n\t            level[e.to] = Some(level[v].unwrap() + 1);\n\t            que.push_back(e.to);\n                }\n            }\n\t}\n    }\n    /* search augment path by dfs.\n     * if f == None, f is treated as infinity.\n     */\n    fn dfs(&mut self, v: usize, t: usize, f: Option<T>, level: &mut [Option<usize>]) -> T {\n        if v == t {\n            return f.unwrap();\n        }\n        while self.iter[v] < self.graph[v].len() {\n            let i = self.iter[v];\n            let e = self.graph[v][i].clone();\n            if e.cap > self.zero && level[v] < level[e.to] {\n                let newf = std::cmp::min(f.unwrap_or(e.cap), e.cap);\n                let d = self.dfs(e.to, t, Some(newf), level);\n                if d > self.zero {\n                    self.graph[v][i].cap -= d;\n                    self.graph[e.to][e.rev].cap += d;\n                    return d;\n                }\n            }\n            self.iter[v] += 1;\n        }\n        self.zero\n    }\n    pub fn new(n: usize, zero: T) -> Self {\n        Dinic {\n            graph: vec![Vec::new(); n],\n            iter: vec![0; n],\n            zero: zero,\n        }\n    }\n    pub fn add_edge(&mut self, from: usize, to: usize, cap: T) {\n        let added_from = Edge { to: to, cap: cap,\n                            rev: self.graph[to].len() };\n        let added_to = Edge { to: from, cap: self.zero,\n                            rev: self.graph[from].len() };\n        self.graph[from].push(added_from);\n        self.graph[to].push(added_to);\n    }\n    pub fn max_flow(&mut self, s: usize, t: usize) -> (T, Vec<usize>) {\n        let mut flow = self.zero;\n        let n = self.graph.len();\n        let mut level = vec![None; n];\n        loop {\n            self.bfs(s, &mut level);\n            if level[t] == None {\n                let ret = (0 .. n).filter(|&i| level[i] == None)\n                    .collect();\n                return (flow, ret);\n            }\n            self.iter.clear();\n            self.iter.resize(n, 0);\n            loop {\n                let f = self.dfs(s, t, None, &mut level);\n                if f <= self.zero { break; }\n                flow += f;\n            }\n        }\n    }\n}\n\n\nfn prime_sieve(n: usize) -> Vec<bool> {\n    let mut ans = vec![true; n];\n    ans[0] = false;\n    ans[1] = false;\n    for i in 2 .. n {\n        if !ans[i] { continue; }\n        for j in 2 .. (n - 1) / i + 1 {\n            ans[i * j] = false;\n        }\n    }\n    ans\n}\n\nfn bipartite_matching(g: &[Vec<usize>]) -> usize {\n    let n = g.len();\n    let m = g[0].len();\n    let mut din = Dinic::new(2 + n + m, 0);\n    for i in 0 .. n {\n        for j in 0 .. m {\n            din.add_edge(2 + i, 2 + n + j, g[i][j]);\n        }\n    }\n    for i in 0 .. n {\n        din.add_edge(0, 2 + i, 1);\n    }\n    for j in 0 .. m {\n        din.add_edge(2 + n + j, 1, 1);\n    }\n    let (ans, _) = din.max_flow(0, 1);\n    ans\n}\n\nfn solve() {\n    let out = std::io::stdout();\n    let mut out = BufWriter::new(out.lock());\n    macro_rules! puts {\n        ($($format:tt)*) => (write!(out,$($format)*).unwrap());\n    }\n    input! { x: [i64] }\n    const W: usize = 1 << 24;\n    let is_prime = prime_sieve(W);\n    let mut hs = HashSet::new();\n    for x in x {\n        if hs.contains(&x) {\n            hs.remove(&x);\n        } else {\n            hs.insert(x);\n        }\n        let x = x + 1;\n        if hs.contains(&x) {\n            hs.remove(&x);\n        } else {\n            hs.insert(x);\n        }\n    }\n    let mut even = Vec::new();\n    let mut odd = Vec::new();\n    for x in hs {\n        if x % 2 == 0 { even.push(x); }\n        else { odd.push(x); }\n    }\n    let n = even.len();\n    let m = odd.len();\n    let mut g = vec![vec![0; m]; n];\n    for i in 0 .. n {\n        for j in 0 .. m {\n            if is_prime[(even[i] - odd[j]).abs() as usize] {\n                g[i][j] = 1;\n            }\n        }\n    }\n    let size = bipartite_matching(&g);\n    let mut tot = 3 * ((n - size) % 2);\n    tot += 2 * ((n - size) / 2);\n    tot += 2 * ((m - size) / 2);\n    tot += size;\n    puts!(\"{}\\n\", tot);\n}\n\nfn main() {\n    // In order to avoid potential stack overflow, spawn a new thread.\n    let stack_size = 104_857_600; // 100 MB\n    let thd = std::thread::Builder::new().stack_size(stack_size);\n    thd.spawn(|| solve()).unwrap().join().unwrap();\n}\n"
  },
  {
    "language": "Rust",
    "code": "#![allow(unused_imports, unused_variables, dead_code)]\nuse std::io::*;\nuse std::fmt::*;\nuse std::str::*;\nuse std::cmp::*;\nuse std::collections::*;\n\npub trait InputValue {\n    fn parse(s: &str) -> Self;\n}\n\npub fn read<T: InputValue>() -> T {\n    let mut buf = String::new();\n    let _ = stdin().read_line(&mut buf);\n    T::parse(&buf.trim())\n}\n\npub fn readnc<T: InputValue>() -> Vec<T> {\n    let mut vec = vec![];\n    let line: String = read();\n    for token in line.split_whitespace() {\n        vec.push(T::parse(token));\n    }\n    vec\n}\n\npub fn readn<T: InputValue>(n: usize) -> Vec<T> {\n    let mut vec = vec![];\n    for _ in 0..n {\n        vec.push(read());\n    }\n    vec\n}\n\nmacro_rules! parse_single_value {\n    ($($t:ty),*) => {\n        $(\n            impl InputValue for $t {\n                fn parse(s: &str) -> $t { s.parse().unwrap() }\n            }\n        )*\n\t}\n}\nparse_single_value!(i32, i64, f32, f64, usize, String);\n\nmacro_rules! parse_tuple {\n\t($($t:ident),*) => {\n\t\timpl<$($t),*> InputValue for ($($t),*) where $($t: InputValue),* {\n\t\t\tfn parse(s: &str) -> ($($t),*) {\n\t\t\t\tlet mut tokens = s.split_whitespace();\n\t\t\t\tlet t = ($($t::parse(tokens.next().unwrap())),*);\n\t\t\t\tt\n\t\t\t}\n\t\t}\n\t}\n}\nparse_tuple!(A, B);\nparse_tuple!(A, B, C);\n\n// ===\nconst MAX_FLOW: i32 = 100000000;\n\n#[derive(Clone, Copy)]\nstruct Edge {\n    from: usize,\n    to: usize,\n    cap: i32,\n    maxcap: i32\n}\n\nimpl Edge {\n    fn goto(&self, from: usize) -> usize {\n        self.from + self.to - from\n    }\n\n    fn cap(&self, from: usize) -> i32 {\n        if self.from == from {\n            self.cap\n        } else {\n            self.maxcap - self.cap\n        }\n    }\n}\n\nstruct FlowGraph {\n    n: usize,\n    graph: Vec<Vec<usize>>,\n    edges: Vec<Edge>,\n    level: Vec<i32>,\n    itr: Vec<usize>\n}\n\nimpl FlowGraph {\n    fn new(n: usize) -> Self {\n        let graph = vec![vec![]; n];\n        let level = vec![0; n];\n        let itr = vec![0; n];\n        FlowGraph { n: n, graph: graph, edges: vec![], level: level, itr: itr }\n    }\n\n    fn edge(&mut self, from: usize, to: usize, cap: i32) {\n        let e = Edge { from: from, to: to, cap: cap, maxcap: cap };\n        let l = self.edges.len();\n        self.graph[from].push(l);\n        self.graph[to].push(l);\n        self.edges.push(e);\n    }\n\n    fn dfs(&mut self, now: usize, to: usize, flow: i32) -> i32 {\n        if now == to {\n            return flow;\n        }\n        for i in self.itr[now]..self.graph[now].len() {\n            self.itr[now] = i;\n            let eidx = self.graph[now][i];\n\n            let e = self.edges[eidx];\n            let next = e.goto(now);\n            let ecap = e.cap(now);\n            if ecap > 0 && self.level[now] < self.level[next] {\n                let d = self.dfs(next, to, min(flow, ecap));\n                if d >= 1 {\n                    let e = &mut self.edges[eidx];\n                    if e.from == now {\n                        e.cap -= d;\n                    } else {\n                        e.cap += d;\n                    }\n                    return d;\n                }\n            }\n\n        }\n        return 0;\n    }\n\n    fn bfs(&mut self, from: usize) {\n        for i in 0..self.n {\n            self.level[i] = -1;\n        }\n        self.level[from] = 0;\n        let mut q: VecDeque<usize> = VecDeque::new();\n        q.push_back(from);\n        while let Some(idx) = q.pop_front() {\n            for &eidx in &self.graph[idx] {\n                let e = &self.edges[eidx];\n                let to = e.goto(idx);\n                if e.cap(idx) >= 1 && self.level[to] == -1 {\n                    self.level[to] = self.level[idx] + 1;\n                    q.push_back(e.to);\n                }\n            }\n        }\n    }\n\n    fn max_flow(&mut self, from: usize, to: usize) -> i32 {\n        let mut flow = 0;\n        loop {\n            self.bfs(from);\n            if self.level[to] == -1 {\n                return flow;\n            }\n            for i in 0..self.n {\n                self.itr[i] = 0;\n            }\n            loop {\n                let f = self.dfs(from, to, MAX_FLOW);\n                if f <= 0 {\n                    break;\n                }\n                flow += f;\n            }\n        }\n    }\n}\n\n// ===\n\nfn testflow() {\n    let mut flow = FlowGraph::new(5);\n    flow.edge(0, 1, 1);\n    flow.edge(1, 2, 1);\n    flow.edge(0, 3, 1);\n    flow.edge(2, 4, 1);\n    flow.edge(3, 4, 1);\n    println!(\"f={}\", flow.max_flow(0, 4));\n}\n\nfn prime(n: usize) -> Vec<bool> {\n    let mut ret = vec![true; n];\n    ret[0] = false;\n    ret[1] = false;\n    for i in 2..n {\n        if !ret[i] {\n            continue\n        }\n        let mut ii = i * i;\n        while ii < n {\n            ret[ii] = false;\n            ii += i;\n        }\n    }\n    ret\n}\n\nfn main() {\n    let n: usize = read();\n    let x: Vec<i32> = readnc();\n\n    let mut fpos = vec![];\n    fpos.push(x[0]);\n\n    for i in 1..n {\n        if x[i-1] + 1 < x[i] {\n            fpos.push(x[i-1]+1);\n            fpos.push(x[i])\n        }\n    }\n    fpos.push(x[n-1]+1);\n\n    let isp = prime(10000100);\n\n    let n = fpos.len();\n    let mut even = 0;\n    let mut odd = 0;\n    for &f in &fpos {\n        if f % 2 == 0 {\n            even += 1;\n        } else {\n            odd += 1;\n        }\n    }\n\n    let mut flow = FlowGraph::new(n + 2);\n    let source = n;\n    let sink = n + 1;\n    for i in 0..n {\n        for j in 0..n {\n            let d = (fpos[i] - fpos[j]).abs() as usize;\n            if i != j && fpos[i] % 2 == 0 && fpos[j] % 2 == 1 && isp[d] {\n                flow.edge(i, j, 1);\n            }\n        }\n    }\n    for i in 0..n {\n        if fpos[i] % 2 == 0 {\n            flow.edge(source, i, 1);\n        } else {\n            flow.edge(i, sink, 1);\n        }\n    }\n\n    let pair = flow.max_flow(source, sink);\n    let even_left = even - pair;\n    let odd_left = odd - pair;\n    println!(\"{}\", pair + (even_left / 2) * 2 + (odd_left / 2) * 2 + max(0, odd_left % 2) * 3);\n}"
  },
  {
    "language": "Rust",
    "code": "use std::io::*;\nuse std::str::FromStr;\n\n#[allow(dead_code)]\nfn read<T: FromStr>() -> T {\n    let stdin = stdin();\n    let stdin = stdin.lock();\n    let token: String = stdin\n        .bytes()\n        .map(|c| c.expect(\"failed to read char\") as char)\n        .skip_while(|c| c.is_whitespace())\n        .take_while(|c| !c.is_whitespace())\n        .collect();\n    token.parse().ok().expect(\"failed to parse token\")\n}\n\nfn large_mul_mod(mut lhs: i64, mut rhs: i64, modulo: i64) -> i64 {\n    let mut ret = 0i64;\n    while rhs > 0 {\n        if (rhs & 1) == 1 {\n            ret = (ret + lhs) % modulo;\n        }\n        rhs >>= 1;\n        lhs = (lhs + lhs) % modulo;\n    }\n    ret\n}\n\nfn pow_mod(mut base: i64, mut power: i64, modulo: i64) -> i64 {\n    let mut ans = 1i64;\n    if modulo < (1 << 30) {\n        while power > 0 {\n            if (power & 1) == 1 {\n                ans = ans * base % modulo;\n            }\n            power >>= 1;\n            base = base * base % modulo;\n        }\n    } else {\n        while power > 0 {\n            if (power & 1) == 1 {\n                ans = large_mul_mod(ans, base, modulo);\n            }\n            power >>= 1;\n            base = large_mul_mod(base, base, modulo);\n        }\n    }\n    ans\n}\n\nfn suspect(t: i64, mut s: i64, d: i64, n: i64) -> bool {\n    let mut x = pow_mod(t, d, n);\n    if x == 1 {\n        return true;\n    }\n    while s > 0 {\n        s -= 1;\n        if x == n - 1 {\n            return true;\n        }\n        if n < (1 << 30) {\n            x = x * x % n;\n        } else {\n            x = large_mul_mod(x, x, n);\n        }\n    }\n    false\n}\n\n#[allow(dead_code)]\nfn is_prime(n: i64) -> bool {\n    if n <= 1 || (n > 2 && n % 2 == 0) {\n        return false;\n    }\n    let mut d = n - 1;\n    let mut s = 0;\n    while (d & 1) == 0 {\n        s += 1;\n        d >>= 1;\n    }\n    // let test = [2, 7, 61, 1i64 << 60]; // is for n < 2^32\n    let test = [2, 3, 5, 7, 11, 13, 17, 19, 23, 1i64 << 60]; // is for n < 10^16 (at least)\n    for &t in test.iter() {\n        if t >= n {\n            break;\n        }\n        if !suspect(t, s, d, n) {\n            return false;\n        }\n    }\n    true\n}\n\n#[test]\nfn test_is_prime() {\n    assert!(is_prime(2));\n    assert!(is_prime(3));\n    assert!(is_prime(5));\n    assert!(is_prime(7));\n    assert!(is_prime(11));\n    assert!(is_prime(103));\n    assert!(is_prime(1000000007));\n    assert!(is_prime(1000000009));\n    assert!(is_prime(3478329271));\n    assert!(is_prime(777177177781));\n    assert!(is_prime(67280421310721));\n\n    assert!(!is_prime(-1));\n    assert!(!is_prime(0));\n    assert!(!is_prime(1));\n    assert!(!is_prime(4));\n    assert!(!is_prime(9));\n    assert!(!is_prime(77));\n    assert!(!is_prime(1000000001));\n    assert!(!is_prime(4002002002));\n    assert!(!is_prime(7478329271));\n    assert!(!is_prime(1357436473381));\n}\n\ntype Weight = i32;\n#[allow(dead_code)]\n#[derive(Clone, Debug, Eq, PartialEq)]\nstruct Edge {\n    index: usize,\n    src: usize,\n    dest: usize,\n    weight: Weight,\n}\n#[allow(dead_code)]\nimpl Edge {\n    fn new(index: usize, src: usize, dest: usize, weight: Weight) -> Edge {\n        Edge {\n            index: index,\n            src: src,\n            dest: dest,\n            weight: weight,\n        }\n    }\n}\nimpl std::cmp::Ord for Edge {\n    fn cmp(&self, other: &Self) -> std::cmp::Ordering {\n        (self.weight, self.src, self.dest).cmp(&(other.weight, other.src, other.dest))\n    }\n}\nimpl std::cmp::PartialOrd for Edge {\n    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {\n        Some(self.cmp(other))\n    }\n}\ntype Edges = Vec<Edge>;\ntype Graph = Vec<Edges>;\n#[allow(dead_code)]\nfn graph_new(n: usize) -> Graph {\n    vec![vec![]; n]\n}\n\nuse std::collections::VecDeque;\n// index ^ 1 is reverse edge\n#[allow(dead_code)]\nfn add_bi_edge(graph: &mut Graph, index: &mut usize, src: usize, dest: usize, weight: Weight) {\n    graph[src].push(Edge::new(*index, src, dest, weight));\n    *index += 1;\n    graph[dest].push(Edge::new(*index, dest, src, weight));\n    *index += 1;\n}\n#[allow(dead_code)]\nfn add_uni_edge(graph: &mut Graph, index: &mut usize, src: usize, dest: usize, weight: Weight) {\n    graph[src].push(Edge::new(*index, src, dest, weight));\n    *index += 1;\n    graph[dest].push(Edge::new(*index, dest, src, 0));\n    *index += 1;\n}\n\n#[allow(dead_code)]\nfn augment(\n    g: &Graph,\n    capacity: &mut Vec<Weight>,\n    level: &Vec<usize>,\n    finished: &mut Vec<bool>,\n    from: usize,\n    t: usize,\n    cur: Weight,\n) -> Weight {\n    if from == t || cur == 0 {\n        return cur;\n    }\n    if finished[from] {\n        return 0;\n    }\n    for edge in g[from].iter() {\n        let to = edge.dest;\n        if level[to] != level[from] + 1 {\n            continue;\n        }\n        let ncur = std::cmp::min(cur, capacity[edge.index]);\n        let f = augment(g, capacity, level, finished, to, t, ncur);\n        if f > 0 {\n            capacity[edge.index] -= f;\n            capacity[edge.index ^ 1] += f;\n            return f;\n        }\n    }\n    finished[from] = true;\n    0\n}\n\n#[allow(dead_code)]\nfn max_flow(g: &Graph, e: usize, s: usize, t: usize) -> Weight {\n    let n = g.len();\n    let mut capacity: Vec<Weight> = vec![0; e];\n    for from in 0..n {\n        for edge in g[from].iter() {\n            capacity[edge.index] += edge.weight;\n        }\n    }\n    let mut ans = 0;\n    loop {\n        let mut level = vec![usize::max_value(); n];\n        level[s] = 0;\n        let mut que = VecDeque::<usize>::new();\n        que.push_back(s);\n        while let Some(from) = que.pop_front() {\n            if from == t {\n                break;\n            }\n            for edge in g[from].iter() {\n                let to = edge.dest;\n                if capacity[edge.index] > 0 && level[to] == usize::max_value() {\n                    que.push_back(to);\n                    level[to] = level[from] + 1;\n                }\n            }\n        }\n        let mut finished = vec![false; n];\n        let mut end = true;\n        loop {\n            let f = augment(\n                g,\n                &mut capacity,\n                &level,\n                &mut finished,\n                s,\n                t,\n                Weight::max_value(),\n            );\n            if f == 0 {\n                break;\n            }\n            ans += f;\n            end = false;\n        }\n        if end {\n            break;\n        }\n    }\n    ans\n}\n\nfn main() {\n    let n = read::<usize>();\n    let mut seq = vec![0i64; n];\n    for i in 0..n {\n        seq[i] = read::<i64>();\n    }\n    let mut start = -1;\n    let mut positions = vec![];\n    for i in 0..n {\n        if start == -1 {\n            start = seq[i];\n        }\n        if i == n - 1 || seq[i] + 1 != seq[i + 1] {\n            positions.push(start);\n            positions.push(seq[i] + 1);\n            start = -1;\n        }\n    }\n    // println!(\"{:?}\", positions);\n    let n = positions.len();\n    let source = n;\n    let dest = n + 1;\n    let size = n + 2;\n    let mut graph = graph_new(size);\n    let mut e = 0;\n    let mut odd_cnt = 0;\n    let mut even_cnt = 0;\n    for i in 0..n {\n        let pos = positions[i];\n        if pos % 2 == 0 {\n            odd_cnt += 1;\n            add_uni_edge(&mut graph, &mut e, source, i, 1);\n            for j in 0..n {\n                let d = (positions[j] - pos).abs();\n                if d > 2 && is_prime(d) {\n                    // println!(\"{} {}\", std::cmp::min(pos, positions[j]), std::cmp::max(pos, positions[j]));\n                    add_uni_edge(&mut graph, &mut e, i, j, 1);\n                }\n            }\n        } else {\n            even_cnt += 1;\n            add_uni_edge(&mut graph, &mut e, i, dest, 1);\n        }\n    }\n    let flow = max_flow(&graph, e, source, dest);\n    let mut ans = flow + (odd_cnt - flow) / 2 * 2 + (even_cnt - flow) / 2 * 2;\n    if (odd_cnt - flow) % 2 == 1 {\n        ans += 3;\n    }\n    println!(\"{}\", ans);\n}\n"
  },
  {
    "language": "Rust",
    "code": "#[allow(unused_imports)]\nuse std::cmp::*;\n#[allow(unused_imports)]\nuse std::collections::*;\nuse std::io::{Write, BufWriter};\n// https://qiita.com/tanakh/items/0ba42c7ca36cd29d0ac8\nmacro_rules! input {\n    (source = $s:expr, $($r:tt)*) => {\n        let mut iter = $s.split_whitespace();\n        let mut next = || { iter.next().unwrap() };\n        input_inner!{next, $($r)*}\n    };\n    ($($r:tt)*) => {\n        let stdin = std::io::stdin();\n        let mut bytes = std::io::Read::bytes(std::io::BufReader::new(stdin.lock()));\n        let mut next = move || -> String{\n            bytes\n                .by_ref()\n                .map(|r|r.unwrap() as char)\n                .skip_while(|c|c.is_whitespace())\n                .take_while(|c|!c.is_whitespace())\n                .collect()\n        };\n        input_inner!{next, $($r)*}\n    };\n}\n\nmacro_rules! input_inner {\n    ($next:expr) => {};\n    ($next:expr, ) => {};\n\n    ($next:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($next, $t);\n        input_inner!{$next $($r)*}\n    };\n}\n\nmacro_rules! read_value {\n    ($next:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($next, $t)),* )\n    };\n\n    ($next:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($next, $t)).collect::<Vec<_>>()\n    };\n\n    ($next:expr, chars) => {\n        read_value!($next, String).chars().collect::<Vec<char>>()\n    };\n\n    ($next:expr, usize1) => {\n        read_value!($next, usize) - 1\n    };\n\n    ($next:expr, [ $t:tt ]) => {{\n        let len = read_value!($next, usize);\n        (0..len).map(|_| read_value!($next, $t)).collect::<Vec<_>>()\n    }};\n\n    ($next:expr, $t:ty) => {\n        $next().parse::<$t>().expect(\"Parse error\")\n    };\n}\n\n/**\n * Dinic's algorithm for maximum flow problem.\n * Verified by: yukicoder No.177 (http://yukicoder.me/submissions/148371)\n * Min-cut (the second element of max_flow's returned values) is not verified.\n */\n\n#[derive(Clone)]\nstruct Edge<T> {\n    to: usize,\n    cap: T,\n    rev: usize, // rev is the position of the reverse edge in graph[to]\n}\n\nstruct Dinic<T> {\n    graph: Vec<Vec<Edge<T>>>,\n    iter: Vec<usize>,\n    zero: T,\n}\n\nimpl<T> Dinic<T>\n    where T: Clone,\n          T: Copy,\n          T: Ord,\n          T: std::ops::AddAssign,\n          T: std::ops::SubAssign,\n{\n    fn bfs(&self, s: usize, level: &mut [Option<usize>]) {\n        let n = level.len();\n        for i in 0 .. n {\n            level[i] = None;\n        }\n        let mut que = std::collections::VecDeque::new();\n        level[s] = Some(0);\n        que.push_back(s);\n        while let Some(v) = que.pop_front() {\n            for e in self.graph[v].iter() {\n\t        if e.cap > self.zero && level[e.to] == None {\n\t            level[e.to] = Some(level[v].unwrap() + 1);\n\t            que.push_back(e.to);\n                }\n            }\n\t}\n    }\n    /* search augment path by dfs.\n     * if f == None, f is treated as infinity.\n     */\n    fn dfs(&mut self, v: usize, t: usize, f: Option<T>, level: &mut [Option<usize>]) -> T {\n        if v == t {\n            return f.unwrap();\n        }\n        while self.iter[v] < self.graph[v].len() {\n            let i = self.iter[v];\n            let e = self.graph[v][i].clone();\n            if e.cap > self.zero && level[v] < level[e.to] {\n                let newf = std::cmp::min(f.unwrap_or(e.cap), e.cap);\n                let d = self.dfs(e.to, t, Some(newf), level);\n                if d > self.zero {\n                    self.graph[v][i].cap -= d;\n                    self.graph[e.to][e.rev].cap += d;\n                    return d;\n                }\n            }\n            self.iter[v] += 1;\n        }\n        self.zero\n    }\n    pub fn new(n: usize, zero: T) -> Self {\n        Dinic {\n            graph: vec![Vec::new(); n],\n            iter: vec![0; n],\n            zero: zero,\n        }\n    }\n    pub fn add_edge(&mut self, from: usize, to: usize, cap: T) {\n        let added_from = Edge { to: to, cap: cap,\n                            rev: self.graph[to].len() };\n        let added_to = Edge { to: from, cap: self.zero,\n                            rev: self.graph[from].len() };\n        self.graph[from].push(added_from);\n        self.graph[to].push(added_to);\n    }\n    pub fn max_flow(&mut self, s: usize, t: usize) -> (T, Vec<usize>) {\n        let mut flow = self.zero;\n        let n = self.graph.len();\n        let mut level = vec![None; n];\n        loop {\n            self.bfs(s, &mut level);\n            if level[t] == None {\n                let ret = (0 .. n).filter(|&i| level[i] == None)\n                    .collect();\n                return (flow, ret);\n            }\n            self.iter.clear();\n            self.iter.resize(n, 0);\n            loop {\n                let f = self.dfs(s, t, None, &mut level);\n                if f <= self.zero { break; }\n                flow += f;\n            }\n        }\n    }\n}\n\n\nfn prime_sieve(n: usize) -> Vec<bool> {\n    let mut ans = vec![true; n];\n    ans[0] = false;\n    ans[1] = false;\n    for i in 2 .. n {\n        if !ans[i] { continue; }\n        for j in 2 .. (n - 1) / i + 1 {\n            ans[i * j] = false;\n        }\n    }\n    ans\n}\n\nfn bipartite_matching(g: &[Vec<usize>]) -> usize {\n    let n = g.len();\n    let m = g[0].len();\n    let mut din = Dinic::new(2 + n + m, 0);\n    for i in 0 .. n {\n        for j in 0 .. m {\n            din.add_edge(2 + i, 2 + n + j, g[i][j]);\n        }\n    }\n    const INF: usize = 1 << 29;\n    for i in 0 .. n {\n        din.add_edge(0, 2 + i, INF);\n    }\n    for j in 0 .. m {\n        din.add_edge(2 + n + j, 1, INF);\n    }\n    let (ans, _) = din.max_flow(0, 1);\n    ans\n}\n\nfn solve() {\n    let out = std::io::stdout();\n    let mut out = BufWriter::new(out.lock());\n    macro_rules! puts {\n        ($($format:tt)*) => (write!(out,$($format)*).unwrap());\n    }\n    input! { x: [i64] }\n    const W: usize = 1 << 24;\n    let is_prime = prime_sieve(W);\n    let mut hs = HashSet::new();\n    for x in x {\n        if hs.contains(&x) {\n            hs.remove(&x);\n        } else {\n            hs.insert(x);\n        }\n        let x = x + 1;\n        if hs.contains(&x) {\n            hs.remove(&x);\n        } else {\n            hs.insert(x);\n        }\n    }\n    let mut even = Vec::new();\n    let mut odd = Vec::new();\n    for x in hs {\n        if x % 2 == 0 { even.push(x); }\n        else { odd.push(x); }\n    }\n    let n = even.len();\n    let m = odd.len();\n    let mut g = vec![vec![0; m]; n];\n    for i in 0 .. n {\n        for j in 0 .. m {\n            if is_prime[(even[i] - odd[j]).abs() as usize] {\n                g[i][j] = 1;\n            }\n        }\n    }\n    let size = bipartite_matching(&g);\n    let mut tot = 3 * ((n - size) % 2);\n    tot += 2 * ((n - size) / 2);\n    tot += 2 * ((m - size) / 2);\n    tot += size;\n    puts!(\"{}\\n\", tot);\n}\n\nfn main() {\n    // In order to avoid potential stack overflow, spawn a new thread.\n    let stack_size = 104_857_600; // 100 MB\n    let thd = std::thread::Builder::new().stack_size(stack_size);\n    thd.spawn(|| solve()).unwrap().join().unwrap();\n}\n"
  },
  {
    "language": "Rust",
    "code": "#[allow(unused_imports)]\nuse std::cmp::*;\n#[allow(unused_imports)]\nuse std::collections::*;\nuse std::io::{Write, BufWriter};\n// https://qiita.com/tanakh/items/0ba42c7ca36cd29d0ac8\nmacro_rules! input {\n    (source = $s:expr, $($r:tt)*) => {\n        let mut iter = $s.split_whitespace();\n        let mut next = || { iter.next().unwrap() };\n        input_inner!{next, $($r)*}\n    };\n    ($($r:tt)*) => {\n        let stdin = std::io::stdin();\n        let mut bytes = std::io::Read::bytes(std::io::BufReader::new(stdin.lock()));\n        let mut next = move || -> String{\n            bytes\n                .by_ref()\n                .map(|r|r.unwrap() as char)\n                .skip_while(|c|c.is_whitespace())\n                .take_while(|c|!c.is_whitespace())\n                .collect()\n        };\n        input_inner!{next, $($r)*}\n    };\n}\n\nmacro_rules! input_inner {\n    ($next:expr) => {};\n    ($next:expr, ) => {};\n\n    ($next:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($next, $t);\n        input_inner!{$next $($r)*}\n    };\n}\n\nmacro_rules! read_value {\n    ($next:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($next, $t)),* )\n    };\n\n    ($next:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($next, $t)).collect::<Vec<_>>()\n    };\n\n    ($next:expr, chars) => {\n        read_value!($next, String).chars().collect::<Vec<char>>()\n    };\n\n    ($next:expr, usize1) => {\n        read_value!($next, usize) - 1\n    };\n\n    ($next:expr, [ $t:tt ]) => {{\n        let len = read_value!($next, usize);\n        (0..len).map(|_| read_value!($next, $t)).collect::<Vec<_>>()\n    }};\n\n    ($next:expr, $t:ty) => {\n        $next().parse::<$t>().expect(\"Parse error\")\n    };\n}\n\n/**\n * Dinic's algorithm for maximum flow problem.\n * Verified by: yukicoder No.177 (http://yukicoder.me/submissions/148371)\n * Min-cut (the second element of max_flow's returned values) is not verified.\n */\n\n#[derive(Clone)]\nstruct Edge<T> {\n    to: usize,\n    cap: T,\n    rev: usize, // rev is the position of the reverse edge in graph[to]\n}\n\nstruct Dinic<T> {\n    graph: Vec<Vec<Edge<T>>>,\n    iter: Vec<usize>,\n    zero: T,\n}\n\nimpl<T> Dinic<T>\n    where T: Clone,\n          T: Copy,\n          T: Ord,\n          T: std::ops::AddAssign,\n          T: std::ops::SubAssign,\n{\n    fn bfs(&self, s: usize, level: &mut [Option<usize>]) {\n        let n = level.len();\n        for i in 0 .. n {\n            level[i] = None;\n        }\n        let mut que = std::collections::VecDeque::new();\n        level[s] = Some(0);\n        que.push_back(s);\n        while let Some(v) = que.pop_front() {\n            for e in self.graph[v].iter() {\n\t        if e.cap > self.zero && level[e.to] == None {\n\t            level[e.to] = Some(level[v].unwrap() + 1);\n\t            que.push_back(e.to);\n                }\n            }\n\t}\n    }\n    /* search augment path by dfs.\n     * if f == None, f is treated as infinity.\n     */\n    fn dfs(&mut self, v: usize, t: usize, f: Option<T>, level: &mut [Option<usize>]) -> T {\n        if v == t {\n            return f.unwrap();\n        }\n        while self.iter[v] < self.graph[v].len() {\n            let i = self.iter[v];\n            let e = self.graph[v][i].clone();\n            if e.cap > self.zero && level[v] < level[e.to] {\n                let newf = std::cmp::min(f.unwrap_or(e.cap), e.cap);\n                let d = self.dfs(e.to, t, Some(newf), level);\n                if d > self.zero {\n                    self.graph[v][i].cap -= d;\n                    self.graph[e.to][e.rev].cap += d;\n                    return d;\n                }\n            }\n            self.iter[v] += 1;\n        }\n        self.zero\n    }\n    pub fn new(n: usize, zero: T) -> Self {\n        Dinic {\n            graph: vec![Vec::new(); n],\n            iter: vec![0; n],\n            zero: zero,\n        }\n    }\n    pub fn add_edge(&mut self, from: usize, to: usize, cap: T) {\n        let added_from = Edge { to: to, cap: cap,\n                            rev: self.graph[to].len() };\n        let added_to = Edge { to: from, cap: self.zero,\n                            rev: self.graph[from].len() };\n        self.graph[from].push(added_from);\n        self.graph[to].push(added_to);\n    }\n    pub fn max_flow(&mut self, s: usize, t: usize) -> (T, Vec<usize>) {\n        let mut flow = self.zero;\n        let n = self.graph.len();\n        let mut level = vec![None; n];\n        loop {\n            self.bfs(s, &mut level);\n            if level[t] == None {\n                let ret = (0 .. n).filter(|&i| level[i] == None)\n                    .collect();\n                return (flow, ret);\n            }\n            self.iter.clear();\n            self.iter.resize(n, 0);\n            loop {\n                let f = self.dfs(s, t, None, &mut level);\n                if f <= self.zero { break; }\n                flow += f;\n            }\n        }\n    }\n}\n\n\nfn prime_sieve(n: usize) -> Vec<bool> {\n    let mut ans = vec![true; n];\n    ans[0] = false;\n    ans[1] = false;\n    for i in 2 .. n {\n        if !ans[i] { continue; }\n        for j in 2 .. (n - 1) / i + 1 {\n            ans[i * j] = false;\n        }\n    }\n    ans\n}\n\nfn bipartite_matching(g: &[Vec<usize>]) -> usize {\n    let n = g.len();\n    if n == 0 { return 0; }\n    let m = g[0].len();\n    let mut din = Dinic::new(2 + n + m, 0);\n    for i in 0 .. n {\n        for j in 0 .. m {\n            din.add_edge(2 + i, 2 + n + j, g[i][j]);\n        }\n    }\n    for i in 0 .. n {\n        din.add_edge(0, 2 + i, 1);\n    }\n    for j in 0 .. m {\n        din.add_edge(2 + n + j, 1, 1);\n    }\n    let (ans, _) = din.max_flow(0, 1);\n    ans\n}\n\nfn solve() {\n    let out = std::io::stdout();\n    let mut out = BufWriter::new(out.lock());\n    macro_rules! puts {\n        ($($format:tt)*) => (write!(out,$($format)*).unwrap());\n    }\n    input! { x: [i64] }\n    const W: usize = 1 << 24;\n    let is_prime = prime_sieve(W);\n    let mut hs = HashSet::new();\n    for x in x {\n        if hs.contains(&x) {\n            hs.remove(&x);\n        } else {\n            hs.insert(x);\n        }\n        let x = x + 1;\n        if hs.contains(&x) {\n            hs.remove(&x);\n        } else {\n            hs.insert(x);\n        }\n    }\n    let mut even = Vec::new();\n    let mut odd = Vec::new();\n    for x in hs {\n        if x % 2 == 0 { even.push(x); }\n        else { odd.push(x); }\n    }\n    let n = even.len();\n    let m = odd.len();\n    let mut g = vec![vec![0; m]; n];\n    for i in 0 .. n {\n        for j in 0 .. m {\n            if is_prime[(even[i] - odd[j]).abs() as usize] {\n                g[i][j] = 1;\n            }\n        }\n    }\n    let size = bipartite_matching(&g);\n    let mut tot = 3 * ((n - size) % 2);\n    tot += 2 * ((n - size) / 2);\n    tot += 2 * ((m - size) / 2);\n    tot += size;\n    puts!(\"{}\\n\", tot);\n}\n\nfn main() {\n    // In order to avoid potential stack overflow, spawn a new thread.\n    let stack_size = 104_857_600; // 100 MB\n    let thd = std::thread::Builder::new().stack_size(stack_size);\n    thd.spawn(|| solve()).unwrap().join().unwrap();\n}\n"
  },
  {
    "language": "Rust",
    "code": "#[allow(unused_imports)]\nuse std::cmp::*;\n#[allow(unused_imports)]\nuse std::collections::*;\nuse std::io::{Write, BufWriter};\n// https://qiita.com/tanakh/items/0ba42c7ca36cd29d0ac8\nmacro_rules! input {\n    ($($r:tt)*) => {\n        let stdin = std::io::stdin();\n        let mut bytes = std::io::Read::bytes(std::io::BufReader::new(stdin.lock()));\n        let mut next = move || -> String{\n            bytes\n                .by_ref()\n                .map(|r|r.unwrap() as char)\n                .skip_while(|c|c.is_whitespace())\n                .take_while(|c|!c.is_whitespace())\n                .collect()\n        };\n        input_inner!{next, $($r)*}\n    };\n}\n\nmacro_rules! input_inner {\n    ($next:expr) => {};\n    ($next:expr, ) => {};\n\n    ($next:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($next, $t);\n        input_inner!{$next $($r)*}\n    };\n}\n\nmacro_rules! read_value {\n    ($next:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($next, $t)),* )\n    };\n\n    ($next:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($next, $t)).collect::<Vec<_>>()\n    };\n\n    ($next:expr, chars) => {\n        read_value!($next, String).chars().collect::<Vec<char>>()\n    };\n\n    ($next:expr, usize1) => {\n        read_value!($next, usize) - 1\n    };\n\n    ($next:expr, [ $t:tt ]) => {{\n        let len = read_value!($next, usize);\n        (0..len).map(|_| read_value!($next, $t)).collect::<Vec<_>>()\n    }};\n\n    ($next:expr, $t:ty) => {\n        $next().parse::<$t>().expect(\"Parse error\")\n    };\n}\n\nfn prime_sieve(n: usize) -> Vec<bool> {\n    let mut ans = vec![true; n];\n    ans[0] = false;\n    ans[1] = false;\n    for i in 2 .. n {\n        if !ans[i] { continue; }\n        for j in 2 .. (n - 1) / i + 1 {\n            ans[i * j] = false;\n        }\n    }\n    ans\n}\n\n// Verified by https://atcoder.jp/contests/arc080/submissions/3957276\nfn bipartite_matching(g: &[Vec<bool>]) -> usize {\n    let n = g.len();\n    if n == 0 { return 0; }\n    let m = g[0].len();\n    let mut to = vec![None; m];\n    let mut visited = vec![false; n];\n    let mut ans = 0;\n    fn augment(v: usize, g: &[Vec<bool>],\n               visited: &mut [bool], to: &mut [Option<usize>])\n               -> bool {\n        if visited[v] { return false; }\n        visited[v] = true;\n        for i in 0 .. g[v].len() {\n            if !g[v][i] { continue; }\n            if let Some(w) = to[i] {\n                if augment(w, g, visited, to) {\n                    to[i] = Some(v); return true;\n                }\n            } else {\n                to[i] = Some(v); return true;\n            }\n        }\n        false\n    }\n    for i in 0 .. n {\n        for v in visited.iter_mut() { *v = false; }\n        if augment(i, &g, &mut visited, &mut to) { ans += 1; }\n    }\n    ans\n}\n\nfn solve() {\n    let out = std::io::stdout();\n    let mut out = BufWriter::new(out.lock());\n    macro_rules! puts {\n        ($($format:tt)*) => (write!(out,$($format)*).unwrap());\n    }\n    input! { x: [i64] }\n    const W: usize = 1 << 24;\n    let is_prime = prime_sieve(W);\n    let mut hs = HashSet::new();\n    for x in x {\n        if hs.contains(&x) {\n            hs.remove(&x);\n        } else {\n            hs.insert(x);\n        }\n        let x = x + 1;\n        if hs.contains(&x) {\n            hs.remove(&x);\n        } else {\n            hs.insert(x);\n        }\n    }\n    let mut even = Vec::new();\n    let mut odd = Vec::new();\n    for x in hs {\n        if x % 2 == 0 { even.push(x); }\n        else { odd.push(x); }\n    }\n    let n = even.len();\n    let m = odd.len();\n    let mut g = vec![vec![false; m]; n];\n    for i in 0 .. n {\n        for j in 0 .. m {\n            if is_prime[(even[i] - odd[j]).abs() as usize] {\n                g[i][j] = true;\n            }\n        }\n    }\n    let size = bipartite_matching(&g);\n    let mut tot = 3 * ((n - size) % 2);\n    tot += 2 * ((n - size) / 2);\n    tot += 2 * ((m - size) / 2);\n    tot += size;\n    puts!(\"{}\\n\", tot);\n}\n\nfn main() {\n    // In order to avoid potential stack overflow, spawn a new thread.\n    let stack_size = 104_857_600; // 100 MB\n    let thd = std::thread::Builder::new().stack_size(stack_size);\n    thd.spawn(|| solve()).unwrap().join().unwrap();\n}\n"
  }
]