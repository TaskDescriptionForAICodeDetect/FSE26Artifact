[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define MAX_N 100005\n\nbool cards[MAX_N];\nint N;\n\nbool isPrime(int n) {\n    if (n < 2) return false;\n    for (int i = 2; i * i <= n; i++) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\nint solve() {\n    int operations = 0;\n    \n    for (int p = 3; p <= N; p++) {\n        if (!isPrime(p)) continue;\n        \n        bool allDown = true;\n        for (int i = 0; i <= N - p; i++) {\n            bool needFlip = false;\n            for (int j = 0; j < p; j++) {\n                if (cards[i + j]) {\n                    needFlip = true;\n                    break;\n                }\n            }\n            \n            if (needFlip) {\n                operations++;\n                for (int j = 0; j < p; j++) {\n                    cards[i + j] = !cards[i + j];\n                }\n            }\n        }\n    }\n    \n    for (int i = 0; i < N; i++) {\n        if (cards[i]) return -1;\n    }\n    \n    return operations;\n}\n\nint main() {\n    scanf(\"%d\", &N);\n    \n    memset(cards, 0, sizeof(cards));\n    for (int i = 0; i < N; i++) {\n        int x;\n        scanf(\"%d\", &x);\n        cards[x - 1] = true;\n    }\n    \n    printf(\"%d\\n\", solve());\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 23:17:11"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define MAX_N 100000\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n    int *x = (int *)malloc((MAX_N + 2) * sizeof(int));\n    for (int i = 0; i <= MAX_N + 1; i++) {\n        x[i] = 0;\n    }\n    for (int i = 0; i < N; i++) {\n        int num;\n        scanf(\"%d\", &num);\n        x[num] ^= 1;\n    }\n\n    int res = 0;\n    for (int i = 1; i <= MAX_N; i++) {\n        if (x[i]) {\n            res++;\n            x[i] ^= 1;\n            x[i + 1] ^= 1;\n            x[i + 2] ^= 1;\n        }\n    }\n    printf(\"%d\\n\", res);\n    free(x);\n    return 0;\n}",
    "timestamp": "2025-08-05 23:17:21"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint main() {\n    int N;\n    cin >> N;\n    vector<int> x(N);\n    for (int i = 0; i < N; ++i) {\n        cin >> x[i];\n    }\n    sort(x.begin(), x.end());\n    \n    int res = 0;\n    for (int i = 0; i < N; ++i) {\n        if (x[i] == -1) continue;\n        res++;\n        int p = x[i];\n        for (int j = i; j < N; ++j) {\n            if (x[j] % p == 0) {\n                x[j] = -1;\n            }\n        }\n    }\n    cout << res << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 23:17:33"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int N = sc.nextInt();\n        int[] x = new int[N];\n        for (int i = 0; i < N; i++) {\n            x[i] = sc.nextInt();\n        }\n        Arrays.sort(x);\n        \n        List<Integer> positions = new ArrayList<>();\n        for (int num : x) {\n            positions.add(num);\n        }\n        \n        int res = 0;\n        while (!positions.isEmpty()) {\n            int current = positions.get(0);\n            positions.remove(0);\n            res++;\n            \n            if (!positions.isEmpty() && positions.get(0) == current + 2) {\n                positions.remove(0);\n            }\n        }\n        System.out.println(res);\n    }\n}",
    "timestamp": "2025-08-05 23:17:48"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class CardFlipping {\n    public static int minOperations(int[] cards) {\n        Set<Integer> faceUpSet = new HashSet<>();\n        for (int card : cards) {\n            faceUpSet.add(card);\n        }\n        \n        int operations = 0;\n        while (!faceUpSet.isEmpty()) {\n            int minFaceUp = Collections.min(faceUpSet);\n            boolean found = false;\n            \n            for (int p = 3; p <= faceUpSet.size() + minFaceUp; p++) {\n                if (!isPrime(p)) continue;\n                \n                boolean canFlip = true;\n                for (int j = 0; j < p; j++) {\n                    if (!faceUpSet.contains(minFaceUp + j)) {\n                        canFlip = false;\n                        break;\n                    }\n                }\n                \n                if (canFlip) {\n                    for (int j = 0; j < p; j++) {\n                        faceUpSet.remove(minFaceUp + j);\n                    }\n                    operations++;\n                    found = true;\n                    break;\n                }\n            }\n            \n            if (!found) break;\n        }\n        \n        return faceUpSet.isEmpty() ? operations : -1;\n    }\n    \n    private static boolean isPrime(int n) {\n        if (n <= 1) return false;\n        for (int i = 2; i * i <= n; i++) {\n            if (n % i == 0) return false;\n        }\n        return true;\n    }\n    \n    public static void main(String[] args) {\n        int[] cards = {1, 2, 3};\n        System.out.println(minOperations(cards));\n    }\n}",
    "timestamp": "2025-08-05 23:17:55"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\nvoid solve() {\n    int N;\n    cin >> N;\n    \n    vector<bool> flipped(N + 1, false);\n    for (int i = 0; i = 1; i <= N; i++) {\n        int x;\n        cin >> x;\n        flipped[x] = true;\n    }\n    \n    int ops = 0;\n    for (int p = 3; p <= N; p++) {\n        if (!(p & 1)) continue;  // skip even primes\n        \n        bool found_target = false;\n        for (int start = 1; start + p - 1 <= N; start++) {\n            bool all_flipped = true;\n            for (int j = start; j < start + p; j++) {\n                if (!flipped[j]) {\n                    all_flipped = false;\n                    break;\n                }\n            }\n            \n            if (all_flipped) {\n                for (int j = start; j < start + p; j++) {\n                    flipped[j] = !flipped[j];\n                }\n                ops++;\n                found_target = true;\n                break;\n            }\n        }\n        \n        if (!found_target) break;\n    }\n    \n    bool all_down = true;\n    for (int i = 1; i <= N; i++) {\n        if (flipped[i]) {\n            all_down = false;\n            break;\n        }\n    }\n    \n    cout << (all_down ? ops : -1) << endl;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n    \n    int T;\n    cin >> T;\n    while (T--) solve();\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 23:18:02"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def min_operations(N, x):\n    def sieve_of_eratosthenes(n):\n        is_prime = [True] * (n + 1)\n        p = 2\n        while (p * p <= n):\n            if is_prime[p]:\n                for i in range(p * p, n + 1, p):\n                    is_prime[i] = False\n            p += 1\n        prime_list = []\n        for p in range(3, n + 1):\n            if is_prime[p]:\n                prime_list.append(p)\n        return prime_list\n\n    def flip_cards(cards, start, p):\n        for i in range(start, start + p):\n            cards[i] = 1 - cards[i]\n\n    max_card = max(x)\n    primes = sieve_of_eratosthenes(max_card)\n\n    card_state = [0] * (max_card + 1)\n    for xi in x:\n        card_state[xi] = 1\n\n    operation_count = 0\n\n    while any(card_state[1:max_card+1]):\n        for p in reversed(primes):\n            for i in range(1, max_card - p + 2):\n                if card_state[i:i + p].count(1) > p // 2:\n                    flip_cards(card_state, i, p)\n                    operation_count += 1\n\n    return operation_count\n\n# Example Usage\nN = 3\nx = [1, 2, 3]\nprint(min_operations(N, x))",
    "timestamp": "2025-08-13 14:26:00"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class CardFlipping {\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int N = scanner.nextInt();\n        boolean[] cards = new boolean[10000];\n        Arrays.fill(cards, false);\n\n        for (int i = 0; i < N; i++) {\n            int x = scanner.nextInt();\n            cards[x] = true;\n        }\n\n        int operations = 0;\n        for (int i = 1; i < cards.length; i++) {\n            if (cards[i]) {\n                int prime = findPrime();\n                flipCards(cards, i, prime);\n                operations++;\n            }\n        }\n\n        System.out.println(operations);\n        scanner.close();\n    }\n\n    private static int findPrime() {\n        for (int p : new int[]{3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47}) {\n            return p; \n        }\n        return 3;\n    }\n\n    private static void flipCards(boolean[] cards, int startIndex, int prime) {\n        for (int i = startIndex; i < startIndex + prime && i < cards.length; i++) {\n            cards[i] = !cards[i];\n        }\n    }\n}",
    "timestamp": "2025-08-13 14:26:15"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\n#define MAX_N 1001\n\nbool is_prime[MAX_N];\nbool cards[MAX_N];\n\nvoid sieve_of_eratosthenes(int n) {\n    for (int i = 2; i <= n; i++) {\n        is_prime[i] = true;\n    }\n    for (int p = 2; p * p <= n; p++) {\n        if (is_prime[p]) {\n            for (int i = p * p; i <= n; i += p) {\n                is_prime[i] = false;\n            }\n        }\n    }\n}\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n    \n    for (int i = 1; i <= N; i++) {\n        int x;\n        scanf(\"%d\", &x);\n        cards[x] = true;\n    }\n    \n    sieve_of_eratosthenes(MAX_N - 1);\n\n    int operations = 0;\n    for (int i = 1; i < MAX_N; i++) {\n        if (cards[i]) {\n            for (int p = 3; p < MAX_N; p++) {\n                if (is_prime[p] && i + p - 1 < MAX_N) {\n                    for (int j = i; j < i + p; j++) {\n                        cards[j] = !cards[j];\n                    }\n                    operations++;\n                    break;\n                }\n            }\n        }\n    }\n    \n    printf(\"%d\\n\", operations);\n    return 0;\n}",
    "timestamp": "2025-08-13 14:26:23"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <bitset>\n#include <cmath>\n#include <algorithm>\n\n// Function to generate a list of prime numbers up to max_limit\nstd::vector<int> sieve_of_eratosthenes(int max_limit) {\n    std::vector<int> primes;\n    std::bitset<10000> is_prime;\n    is_prime.set();\n    is_prime[0] = is_prime[1] = 0;\n    for (int i = 2; i <= max_limit; ++i) {\n        if (is_prime[i]) {\n            primes.push_back(i);\n            for (int j = i * i; j <= max_limit; j += i) {\n                is_prime[j] = 0;\n            }\n        }\n    }\n    return primes;\n}\n\nint main() {\n    int N;\n    std::cin >> N;\n    std::vector<bool> card_status(10000, false); // Use a large enough size for demonstration\n    for (int i = 0; i < N; ++i) {\n        int x;\n        std::cin >> x;\n        card_status[x - 1] = true;\n    }\n\n    std::vector<int> primes = sieve_of_eratosthenes(10000); // Generate prime numbers up to 10000\n\n    int operations = 0;\n    // Process to flip the cards\n    for (int i = 0; i < card_status.size(); ++i) {\n        if (card_status[i]) {\n            for (int p : primes) {\n                if (i + p <= card_status.size()) {\n                    for (int j = i; j < i + p; ++j) {\n                        card_status[j] = !card_status[j];\n                    }\n                    ++operations;\n                    break;\n                }\n            }\n        }\n    }\n    \n    std::cout << operations << std::endl;\n    return 0;\n}",
    "timestamp": "2025-08-13 14:26:31"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def min_operations(cards):\n    N = len(cards)\n    operations = 0\n    \n    # Work with a copy of the cards to track current state\n    current_state = cards.copy()\n    \n    # Generate primes efficiently using Sieve of Eratosthenes\n    def generate_primes(limit):\n        sieve = [True] * (limit + 1)\n        sieve[0] = sieve[1] = False\n        primes = []\n        \n        for i in range(2, limit + 1):\n            if sieve[i]:\n                primes.append(i)\n                for j in range(i * i, limit + 1, i):\n                    sieve[j] = False\n        \n        return [p for p in primes if p >= 3]\n    \n    # Generate primes that can be used for flipping\n    max_prime = N + 1\n    possible_primes = generate_primes(max_prime)\n    \n    # Try to minimize operations\n    for prime in possible_primes:\n        # Check if we can resolve the problem with this prime\n        working_state = current_state.copy()\n        current_ops = 0\n        \n        for start in range(N - prime + 1):\n            # If any card in the prime-length window is face up\n            if any(working_state[start:start+prime]):\n                # Flip the window\n                for j in range(start, start+prime):\n                    working_state[j] = 1 - working_state[j]\n                current_ops += 1\n        \n        # Check if problem is solved after these operations\n        if all(card == 0 for card in working_state):\n            return current_ops\n    \n    return -1  # Impossible case",
    "timestamp": "2025-08-13 14:26:38"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\n\ndef solve():\n    N, *rest = map(int, sys.stdin.read().split())\n    x = rest[:N]\n    max_x = max(x) if N > 0 else 0\n    if max_x == 0:\n        print(0)\n        return\n    \n    # We model the problem as a system of linear equations mod 2\n    # The variables are whether we flip a certain prime p starting at position i\n    # The equations are for each card x, the sum of flips affecting it should be 1 if it's initially face up\n    \n    # The primes >=3 up to max_x + 2 (since p can be up to max_x + p -1 >= max_x)\n    primes = []\n    is_prime = [True] * (max_x + 2 + 1)\n    is_prime[0] = is_prime[1] = False\n    for i in range(2, max_x + 2 + 1):\n        if is_prime[i]:\n            if i >= 3:\n                primes.append(i)\n            for j in range(i*i, max_x + 2 + 1, i):\n                is_prime[j] = False\n    \n    # The variables are for each prime p, the possible starting positions i (1 <= i <= max_x)\n    # But since flipping p consecutive cards starting at i is the same as flipping starting at i + k*p\n    # We can limit i to 1 <= i <= p\n    \n    # We'll represent each card x as an equation: sum of flips covering x is 1 mod 2 if x is in the initial list\n    \n    # The total number of variables is sum_{p in primes} p\n    # But for large max_x, this is impractical. So we need a smarter approach.\n    \n    # Instead, observe that flipping p cards starting at i affects positions i, i+1, ..., i+p-1\n    # The key is to process the cards in order and flip when necessary.\n    # This is similar to the problem of turning off lights in a line, where each switch affects a range.\n    \n    # Initialize the flip effect array\n    flip = [0] * (max_x + 2)\n    res = 0\n    face_up = [0] * (max_x + 2)\n    for num in x:\n        face_up[num] = 1\n    \n    for i in range(1, max_x + 1):\n        flip[i] += flip[i-1]\n        current = (face_up[i] + flip[i]) % 2\n        if current == 1:\n            # Need to flip a prime p that covers i\n            # The smallest possible p is 3, but we need p >=3 and i + p -1 <= max_x\n            found = False\n            for p in primes:\n                if p >=3 and i + p -1 <= max_x:\n                    flip[i] += 1\n                    flip[i + p] -= 1\n                    res += 1\n                    found = True\n                    break\n            if not found:\n                print(-1)\n                return\n    print(res)\n\nsolve()",
    "timestamp": "2025-08-13 14:26:58"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function minimumOperations(N, cardNumbers) {\n    const isPrime = (num) => {\n        if (num < 2) return false;\n        for (let i = 2; i * i <= num; i++) {\n            if (num % i === 0) return false;\n        }\n        return true;\n    };\n\n    const primes = [];\n    for (let i = 3; i <= 100; i++) {\n        if (isPrime(i)) primes.push(i);\n    }\n\n    const flip = (cards, start, length) => {\n        for (let i = start; i < start + length; i++) {\n            cards[i] *= -1;\n        }\n    };\n\n    const solve = (cards) => {\n        const faceUpIndices = cards.reduce((arr, val, idx) => {\n            if (val === 1) arr.push(idx);\n            return arr;\n        }, []);\n        const m = faceUpIndices.length;\n        if (m === 0) return 0;\n\n        const dp = Array(m).fill(Infinity);\n        for (let start = 0; start < m; start++) {\n            dp[start] = start;\n            for (let prime of primes) {\n                const end = start + prime - 1;\n                if (end >= m) break;\n\n                const neededFlips = new Set(faceUpIndices.slice(start, end + 1));\n                if (neededFlips.size === prime) {\n                    dp[end] = Math.min(dp[end], (start > 0 ? dp[start - 1] : 0) + 1);\n                }\n            }\n        }\n        return dp[m - 1];\n    };\n\n    const cards = new Array(N).fill(-1);\n    cardNumbers.forEach(x => cards[x - 1] = 1);\n\n    return solve(cards);\n}\n\n// Example usage:\nconst N = 5;\nconst cardNumbers = [1, 2, 3, 4, 5];\nconsole.log(minimumOperations(N, cardNumbers)); // Should output the minimum number of operations.",
    "timestamp": "2025-08-13 14:27:11"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function minimumOperations(initialFaceUpCards) {\n    const faceUpCards = new Set(initialFaceUpCards);\n    let operations = 0;\n\n    while (faceUpCards.size > 0) {\n        let minPrime = findMinPrimeForOperation(faceUpCards);\n        if (minPrime === -1) break;\n\n        let consecutiveCardsFaced = findConsecutiveCardsToFlip(faceUpCards, minPrime);\n        consecutiveCardsFaced.forEach(card => faceUpCards.delete(card));\n        operations++;\n    }\n\n    return operations;\n}\n\nfunction findMinPrimeForOperation(faceUpCards) {\n    for (let p = 3; ; p++) {\n        if (!isPrime(p)) continue;\n        for (let start of faceUpCards) {\n            if (canFlipConsecutiveCards(faceUpCards, start, p)) {\n                return p;\n            }\n        }\n    }\n}\n\nfunction canFlipConsecutiveCards(faceUpCards, start, length) {\n    for (let i = 0; i < length; i++) {\n        if (!faceUpCards.has(start + i)) return false;\n    }\n    return true;\n}\n\nfunction findConsecutiveCardsToFlip(faceUpCards, length) {\n    for (let start of faceUpCards) {\n        if (canFlipConsecutiveCards(faceUpCards, start, length)) {\n            return Array.from({length}, (_, i) => start + i);\n        }\n    }\n    return [];\n}\n\nfunction isPrime(n) {\n    if (n < 2) return false;\n    for (let i = 2; i * i <= n; i++) {\n        if (n % i === 0) return false;\n    }\n    return true;\n}",
    "timestamp": "2025-08-13 14:27:18"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "const solve = () => {\n    const readline = require('readline');\n    const rl = readline.createInterface({\n        input: process.stdin,\n        output: process.stdout\n    });\n\n    let N;\n    let x = [];\n    let lineCount = 0;\n\n    rl.on('line', (line) => {\n        if (lineCount === 0) {\n            N = parseInt(line.trim());\n        } else {\n            x = line.trim().split(' ').map(Number);\n        }\n        lineCount++;\n        if (lineCount === 2) {\n            rl.close();\n        }\n    });\n\n    rl.on('close', () => {\n        x.sort((a, b) => a - b);\n        let res = 0;\n        for (let i = 0; i < N; i++) {\n            if (x[i] === 0) continue;\n            res++;\n            let current = x[i];\n            for (let j = i; j < N; j++) {\n                if (x[j] % current === 0) {\n                    x[j] = 0;\n                }\n            }\n        }\n        console.log(res);\n    });\n};\n\nsolve();",
    "timestamp": "2025-08-13 14:27:26"
  }
]