[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\n#define MAX_SIZE 100\n\ntypedef struct {\n    int x, y;\n} Position;\n\nbool canQueenEscape(int N, int M, Position queen, Position army[], int armySize) {\n    // Check if queen is already caught at initial position\n    for (int i = 0; i < armySize; i++) {\n        if (queen.x == army[i].x && queen.y == army[i].y) {\n            return false;\n        }\n    }\n\n    // Directions the queen can move (8 directions)\n    int dx[] = {-1, -1, -1, 0, 0, 1, 1, 1};\n    int dy[] = {-1, 0, 1, -1, 1, -1, 0, 1};\n\n    for (int dir = 0; dir < 8; dir++) {\n        Position next = queen;\n        while (1) {\n            next.x += dx[dir];\n            next.y += dy[dir];\n            if (next.x < 1 || next.x > N || next.y < 1 || next.y > M) {\n                return true; // Queen escaped\n            }\n\n            bool caught = false;\n            for (int i = 0; i < armySize; i++) {\n                if (next.x == army[i].x && next.y == army[i].y) {\n                    caught = true;\n                    break;\n                }\n            }\n            if (caught) {\n                break;\n            }\n        }\n    }\n    return false;\n}\n\nint main() {\n    int N, M;\n    scanf(\"%d %d\", &N, &M);\n\n    Position queen;\n    scanf(\"%d %d\", &queen.x, &queen.y);\n\n    int armySize;\n    scanf(\"%d\", &armySize);\n    Position army[MAX_SIZE];\n    for (int i = 0; i < armySize; i++) {\n        scanf(\"%d %d\", &army[i].x, &army[i].y);\n    }\n\n    if (canQueenEscape(N, M, queen, army, armySize)) {\n        printf(\"YES\\n\");\n    } else {\n        printf(\"NO\\n\");\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 21:12:13"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\n\nstruct Position {\n    int x, y;\n    int steps;\n};\n\nint main() {\n    int N, M;\n    cin >> N >> M;\n    vector<string> grid(N);\n    for (int i = 0; i < N; ++i) {\n        cin >> grid[i];\n    }\n\n    Position queen, army;\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < M; ++j) {\n            if (grid[i][j] == 'Q') {\n                queen.x = i;\n                queen.y = j;\n            } else if (grid[i][j] == 'A') {\n                army.x = i;\n                army.y = j;\n            }\n        }\n    }\n\n    int dx[] = {-1, 1, 0, 0, -1, -1, 1, 1};\n    int dy[] = {0, 0, -1, 1, -1, 1, -1, 1};\n\n    queue<Position> q;\n    q.push({queen.x, queen.y, 0});\n    vector<vector<bool>> visited(N, vector<bool>(M, false));\n    visited[queen.x][queen.y] = true;\n\n    bool escaped = false;\n    while (!q.empty()) {\n        Position current = q.front();\n        q.pop();\n\n        if (current.x == 0 || current.x == N-1 || current.y == 0 || current.y == M-1) {\n            escaped = true;\n            break;\n        }\n\n        for (int i = 0; i < 8; ++i) {\n            int nx = current.x + dx[i];\n            int ny = current.y + dy[i];\n            if (nx >= 0 && nx < N && ny >= 0 && ny < M && grid[nx][ny] != '#' && !visited[nx][ny]) {\n                visited[nx][ny] = true;\n                q.push({nx, ny, current.steps + 1});\n            }\n        }\n    }\n\n    if (!escaped) {\n        cout << \"NO\" << endl;\n        return 0;\n    }\n\n    queue<Position> armyQueue;\n    armyQueue.push({army.x, army.y, 0});\n    vector<vector<bool>> armyVisited(N, vector<bool>(M, false));\n    armyVisited[army.x][army.y] = true;\n    bool caught = false;\n\n    while (!armyQueue.empty()) {\n        Position current = armyQueue.front();\n        armyQueue.pop();\n\n        if (grid[current.x][current.y] == 'Q') {\n            caught = true;\n            break;\n        }\n\n        for (int i = 0; i < 4; ++i) {\n            int nx = current.x + dx[i];\n            int ny = current.y + dy[i];\n            if (nx >= 0 && nx < N && ny >= 0 && ny < M && grid[nx][ny] != '#' && !armyVisited[nx][ny]) {\n                armyVisited[nx][ny] = true;\n                armyQueue.push({nx, ny, current.steps + 1});\n            }\n        }\n    }\n\n    if (caught) {\n        cout << \"NO\" << endl;\n    } else {\n        cout << \"YES\" << endl;\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 21:13:13"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class QueenEscape {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int N = scanner.nextInt();\n        int M = scanner.nextInt();\n        int Qx = scanner.nextInt();\n        int Qy = scanner.nextInt();\n        int K = scanner.nextInt();\n        \n        Set<String> armyPositions = new HashSet<>();\n        for (int i = 0; i < K; i++) {\n            int Ax = scanner.nextInt();\n            int Ay = scanner.nextInt();\n            armyPositions.add(Ax + \",\" + Ay);\n        }\n        \n        boolean[][] visited = new boolean[N + 1][M + 1];\n        Queue<int[]> queue = new LinkedList<>();\n        queue.add(new int[]{Qx, Qy});\n        visited[Qx][Qy] = true;\n        \n        int[][] directions = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}, {-1, -1}, {-1, 1}, {1, -1}, {1, 1}};\n        boolean canEscape = false;\n        \n        while (!queue.isEmpty()) {\n            int[] current = queue.poll();\n            int x = current[0];\n            int y = current[1];\n            \n            if (x == 1 || x == N || y == 1 || y == M) {\n                canEscape = true;\n                break;\n            }\n            \n            for (int[] dir : directions) {\n                int nx = x + dir[0];\n                int ny = y + dir[1];\n                \n                if (nx >= 1 && nx <= N && ny >= 1 && ny <= M && !visited[nx][ny] && !armyPositions.contains(nx + \",\" + ny)) {\n                    visited[nx][ny] = true;\n                    queue.add(new int[]{nx, ny});\n                }\n            }\n        }\n        \n        System.out.println(canEscape ? \"YES\" : \"NO\");\n    }\n}",
    "timestamp": "2025-08-05 21:13:30"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class QueenEscape {\n    public static String canEscape(int N, int K, int R, int C, int[][] soldiers) {\n        // Grid representing the palace\n        boolean[][] grid = new boolean[N][N];\n        \n        // Mark soldier positions\n        for (int[] soldier : soldiers) {\n            int sr = soldier[0] - 1;\n            int sc = soldier[1] - 1;\n            grid[sr][sc] = true;\n        }\n        \n        // Queen's starting position\n        int qr = R - 1;\n        int qc = C - 1;\n        \n        // Possible queen movements (8 directions)\n        int[][] directions = {\n            {-1, 0}, {1, 0}, {0, -1}, {0, 1},\n            {-1, -1}, {-1, 1}, {1, -1}, {1, 1}\n        };\n        \n        // BFS to check escape\n        Queue<int[]> queue = new LinkedList<>();\n        boolean[][] visited = new boolean[N][N];\n        queue.offer(new int[]{qr, qc});\n        visited[qr][qc] = true;\n        \n        while (!queue.isEmpty()) {\n            int[] current = queue.poll();\n            int cr = current[0];\n            int cc = current[1];\n            \n            // Escape condition\n            if (cr == 0 || cr == N-1 || cc == 0 || cc == N-1) {\n                return \"YES\";\n            }\n            \n            // Try all 8 directions\n            for (int[] dir : directions) {\n                int nr = cr + dir[0];\n                int nc = cc + dir[1];\n                \n                // Check valid position\n                if (nr >= 0 && nr < N && nc >= 0 && nc < N \n                    && !grid[nr][nc] && !visited[nr][nc]) {\n                    queue.offer(new int[]{nr, nc});\n                    visited[nr][nc] = true;\n                }\n            }\n        }\n        \n        return \"NO\";\n    }\n    \n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        \n        // Input parameters\n        int N = scanner.nextInt(); // Grid size\n        int K = scanner.nextInt(); // Number of soldiers\n        int R = scanner.nextInt(); // Queen's row\n        int C = scanner.nextInt(); // Queen's column\n        \n        // Soldier positions\n        int[][] soldiers = new int[K][2];\n        for (int i = 0; i < K; i++) {\n            soldiers[i][0] = scanner.nextInt();\n            soldiers[i][1] = scanner.nextInt();\n        }\n        \n        // Output result\n        System.out.println(canEscape(N, K, R, C, soldiers));\n        \n        scanner.close();\n    }\n}",
    "timestamp": "2025-08-05 21:13:40"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdbool.h>\n\n#define MAX_GRID 100\n\nint grid[MAX_GRID][MAX_GRID];\nint rows, cols;\nint queen_row, queen_col;\n\nint dx[] = {-1, 1, 0, 0};\nint dy[] = {0, 0, -1, 1};\n\nbool is_valid_move(int x, int y) {\n    return x >= 0 && x < rows && y >= 0 && y < cols && grid[x][y] != 1;\n}\n\nbool can_escape(int x, int y, bool visited[MAX_GRID][MAX_GRID]) {\n    if (x == 0 || x == rows - 1 || y == 0 || y == cols - 1) {\n        return true;\n    }\n\n    visited[x][y] = true;\n\n    for (int i = 0; i < 4; i++) {\n        int new_x = x + dx[i];\n        int new_y = y + dy[i];\n\n        if (is_valid_move(new_x, new_y) && !visited[new_x][new_y]) {\n            if (can_escape(new_x, new_y, visited)) {\n                return true;\n            }\n        }\n    }\n\n    return false;\n}\n\nint main() {\n    scanf(\"%d %d\", &rows, &cols);\n\n    bool visited[MAX_GRID][MAX_GRID] = {false};\n\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            scanf(\"%d\", &grid[i][j]);\n            if (grid[i][j] == 2) {\n                queen_row = i;\n                queen_col = j;\n            }\n        }\n    }\n\n    bool result = can_escape(queen_row, queen_col, visited);\n\n    printf(\"%s\\n\", result ? \"YES\" : \"NO\");\n\n    return 0;\n}",
    "timestamp": "2025-08-05 21:13:47"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    bool canEscape(vector<vector<int>>& grid) {\n        int m = grid.size();\n        int n = grid[0].size();\n        vector<vector<bool>> visited(m, vector<bool>(n, false));\n        queue<pair<int, int>> q;\n        \n        // Find queen's starting position\n        int queenX = -1, queenY = -1;\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (grid[i][j] == 2) {\n                    queenX = i;\n                    queenY = j;\n                    break;\n                }\n            }\n            if (queenX != -1) break;\n        }\n        \n        // Directions: up, down, left, right\n        vector<pair<int, int>> directions = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n        \n        q.push({queenX, queenY});\n        visited[queenX][queenY] = true;\n        \n        while (!q.empty()) {\n            auto [x, y] = q.front();\n            q.pop();\n            \n            // Check if queen reaches border\n            if (x == 0 || x == m-1 || y == 0 || y == n-1) {\n                return true;\n            }\n            \n            // Try all 4 directions\n            for (auto [dx, dy] : directions) {\n                int nx = x + dx;\n                int ny = y + dy;\n                \n                // Check valid moves\n                if (nx >= 0 && nx < m && ny >= 0 && ny < n && \n                    !visited[nx][ny] && grid[nx][ny] != 1) {\n                    q.push({nx, ny});\n                    visited[nx][ny] = true;\n                }\n            }\n        }\n        \n        return false;\n    }\n};\n\nint main() {\n    Solution sol;\n    vector<vector<int>> grid = {\n        {0,0,0,0},\n        {1,2,1,0},\n        {0,0,0,0}\n    };\n    \n    cout << (sol.canEscape(grid) ? \"Queen can escape\" : \"Queen will be caught\") << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 21:13:56"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def can_queen_escape(grid, queen_pos, army_positions):\n    def move_queen(x, y):\n        moves = []\n        directions = [(-1, 0), (1, 0), (0, -1), (0, 1),\n                      (-1, -1), (-1, 1), (1, -1), (1, 1)]\n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and grid[nx][ny] == 0:\n                moves.append((nx, ny))\n        return moves\n\n    def bfs(start, targets):\n        queue = [(start, 0)]\n        visited = set([start])\n        while queue:\n            current_pos, steps = queue.pop(0)\n            if current_pos in targets:\n                return steps\n            for next_pos in move_queen(*current_pos):\n                if next_pos not in visited:\n                    visited.add(next_pos)\n                    queue.append((next_pos, steps + 1))\n        return float('inf')\n    \n    escape_found = False\n    grid_rows, grid_cols = len(grid), len(grid[0])\n    queen_move_positions = [queen_pos] + move_queen(*queen_pos)\n    army_reach = []\n    \n    for army_pos in army_positions:\n        army_reach.append(bfs(army_pos, queen_move_positions))\n    \n    min_army_reach = min(army_reach)\n    \n    if bfs(queen_pos, [(i, j) for i in range(grid_rows) for j in range(grid_cols) if i == 0 or i == grid_rows - 1 or j == 0 or j == grid_cols - 1]) < min_army_reach:\n        escape_found = True\n\n    return escape_found\n\n# Example usage:\ngrid = [\n    [0, 0, 0, 0, 0],\n    [0, 1, 1, 1, 0],\n    [0, 1, 0, 1, 0],\n    [0, 0, 0, 0, 0]\n]\nqueen_pos = (2, 2)\narmy_positions = [(0, 4), (3, 0)]\n\nprint(can_queen_escape(grid, queen_pos, army_positions))",
    "timestamp": "2025-08-13 05:27:47"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class QueenEscape {\n    private static final int[] rowDirs = {-1, 0, 1, 0};\n    private static final int[] colDirs = {0, 1, 0, -1};\n    \n    public static boolean canQueenEscape(char[][] grid, int queenRow, int queenCol) {\n        int n = grid.length;\n        boolean[][] visited = new boolean[n][n];\n        return dfs(grid, queenRow, queenCol, visited);\n    }\n    \n    private static boolean dfs(char[][] grid, int row, int col, boolean[][] visited) {\n        int n = grid.length;\n        if (row < 0 || row >= n || col < 0 || col >= n || grid[row][col] == 'A' || visited[row][col]) {\n            return false;\n        }\n        if (grid[row][col] == 'E') {\n            return true;\n        }\n        \n        visited[row][col] = true;\n        \n        for (int i = 0; i < 4; i++) {\n            int newRow = row + rowDirs[i];\n            int newCol = col + colDirs[i];\n            if (dfs(grid, newRow, newCol, visited)) {\n                return true;\n            }\n        }\n        \n        visited[row][col] = false;\n        return false;\n    }\n    \n    public static void main(String[] args) {\n        char[][] grid = {\n            { '.', '.', '.', 'A', '.' },\n            { '.', 'A', 'A', '.', '.' },\n            { '.', '.', 'Q', 'A', '.' },\n            { '.', '.', '.', 'A', 'E' },\n            { 'A', 'A', '.', '.', 'A' }\n        };\n        int queenRow = 2;\n        int queenCol = 2;\n        \n        boolean canEscape = canQueenEscape(grid, queenRow, queenCol);\n        System.out.println(\"Queen can escape: \" + canEscape);\n    }\n}",
    "timestamp": "2025-08-13 05:27:55"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n\n#define GRID_SIZE 8\n\ntypedef struct {\n    int x;\n    int y;\n} Position;\n\nint isValid(int x, int y) {\n    return x >= 0 && x < GRID_SIZE && y >= 0 && y < GRID_SIZE;\n}\n\nint canEscape(Position queen, Position armyPositions[], int armyCount) {\n    // Direction vectors for queen's possible moves (8 directions)\n    int dx[] = {-1, -1, -1, 0, 0, 1, 1, 1};\n    int dy[] = {-1, 0, 1, -1, 1, -1, 0, 1};\n\n    for (int dir = 0; dir < 8; dir++) {\n        int qx = queen.x;\n        int qy = queen.y;\n\n        while (isValid(qx + dx[dir], qy + dy[dir])) {\n            qx += dx[dir];\n            qy += dy[dir];\n\n            int safe = 1;\n            for (int i = 0; i < armyCount; i++) {\n                if (armyPositions[i].x == qx || armyPositions[i].y == qy ||\n                    abs(armyPositions[i].x - qx) == abs(armyPositions[i].y - qy)) {\n                    safe = 0;\n                    break;\n                }\n            }\n            \n            if (safe) return 1;\n        }\n    }\n\n    return 0;\n}\n\nint main() {\n    Position queen = {4, 4}; // Example starting position of the queen\n    Position armyPositions[] = {{0, 0}, {1, 2}, {3, 5}, {5, 3}, {6, 6}}; // Example army positions\n    int armyCount = sizeof(armyPositions) / sizeof(armyPositions[0]);\n\n    if (canEscape(queen, armyPositions, armyCount)) {\n        printf(\"Queen can escape.\\n\");\n    } else {\n        printf(\"Queen will be caught.\\n\");\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-13 05:27:59"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def can_escape(grid, start_row, start_col):\n    rows, cols = len(grid), len(grid[0])\n    visited = [[False] * cols for _ in range(rows)]\n    \n    def is_valid_move(row, col):\n        return (0 <= row < rows and \n                0 <= col < cols and \n                grid[row][col] != '#' and \n                not visited[row][col])\n    \n    def dfs(row, col):\n        if row == 0 or row == rows - 1 or col == 0 or col == cols - 1:\n            return True\n        \n        visited[row][col] = True\n        \n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        \n        for dx, dy in directions:\n            new_row, new_col = row + dx, col + dy\n            \n            if is_valid_move(new_row, new_col) and dfs(new_row, new_col):\n                return True\n        \n        return False\n    \n    return dfs(start_row, start_col)\n\n# Input parsing\nrows, cols = map(int, input().split())\ngrid = [list(input().strip()) for _ in range(rows)]\nstart_row, start_col = map(int, input().split())\n\n# Check escape\nif can_escape(grid, start_row - 1, start_col - 1):\n    print(\"YES\")\nelse:\n    print(\"NO\")",
    "timestamp": "2025-08-13 05:28:10"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def can_queen_escape(grid_size, queen_pos, army_pos, moves):\n    directions = {\n        'U': (-1, 0),\n        'D': (1, 0),\n        'L': (0, -1),\n        'R': (0, 1),\n        'UL': (-1, -1),\n        'UR': (-1, 1),\n        'DL': (1, -1),\n        'DR': (1, 1)\n    }\n    \n    qx, qy = queen_pos\n    army = set(army_pos)\n    \n    for move in moves:\n        dx, dy = directions[move]\n        while True:\n            qx += dx\n            qy += dy\n            if qx < 0 or qx >= grid_size or qy < 0 or qy >= grid_size:\n                return True\n            if (qx, qy) in army:\n                return False\n            if move in ['U', 'D', 'L', 'R']:\n                break\n    \n    return False",
    "timestamp": "2025-08-13 05:28:24"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\nstruct Position {\n    int x, y;\n};\n\nbool isValid(int x, int y, int n, int m, vector<vector<bool>>& visited) {\n    return x >= 0 && x < n && y >= 0 && y < m && !visited[x][y];\n}\n\nbool canQueenEscape(vector<vector<char>>& grid) {\n    int n = grid.size();\n    int m = grid[0].size();\n    Position queen;\n    vector<Position> army;\n    vector<vector<bool>> visited(n, vector<bool>(m, false));\n\n    // Find the positions of the queen and the army\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < m; ++j) {\n            if (grid[i][j] == 'Q') {\n                queen = {i, j};\n            }\n            if (grid[i][j] == 'A') {\n                army.push_back({i, j});\n            }\n        }\n    }\n\n    // Directions in which the queen can move: N, NE, E, SE, S, SW, W, NW\n    vector<int> dX = {-1, -1, 0, 1, 1, 1, 0, -1};\n    vector<int> dY = {0, 1, 1, 1, 0, -1, -1, -1};\n\n    // Breadth-first search to check if the queen can escape\n    queue<Position> q;\n    q.push(queen);\n    visited[queen.x][queen.y] = true;\n\n    while (!q.empty()) {\n        int qSize = q.size();\n        vector<vector<bool>> armyVisited(n, vector<bool>(m, false));\n        \n        // Move army first\n        for (Position armyPosition : army) {\n            for (int i = 0; i < 8; ++i) {\n                int newX = armyPosition.x + dX[i];\n                int newY = armyPosition.y + dY[i];\n                while (isValid(newX, newY, n, m, visited) && (grid[newX][newY] != '#')) {\n                    armyVisited[newX][newY] = true;\n                    newX += dX[i];\n                    newY += dY[i];\n                }\n            }\n        }\n        \n        // Now try to move the queen\n        while (qSize--) {\n            Position curr = q.front();\n            q.pop();\n            \n            // Check if the queen can escape\n            for (int i = 0; i < 8; ++i) {\n                int newX = curr.x + dX[i];\n                int newY = curr.y + dY[i];\n                while (isValid(newX, newY, n, m, visited) && grid[newX][newY] != '#' && !armyVisited[newX][newY]) {\n                    if (newX == 0 || newX == n-1 || newY == 0 || newY == m-1) {\n                        return true; // Can escape\n                    }\n\n                    visited[newX][newY] = true;\n                    q.push({newX, newY});\n                    \n                    newX += dX[i];\n                    newY += dY[i];\n                }\n            }\n        }\n    }\n\n    return false; // Queen is caught\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    vector<vector<char>> grid(n, vector<char>(m));\n\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < m; ++j) {\n             cin >> grid[i][j];\n        }\n    }\n\n    if (canQueenEscape(grid)) {\n        cout << \"Escape\" << endl;\n    } else {\n        cout << \"Caught\" << endl;\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-13 11:25:23"
  }
]