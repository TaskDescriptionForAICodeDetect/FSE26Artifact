[
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\n\nint dx[]={-1,0,1,0};\nint dy[]={0,-1,0,1};\n\nbool lp[30][30];\nbool ck[30][30][30][30];\nint dist[30][30][30][30];\nint relt[30][30][30][30];\nint memo[30][30][30][30];\nint W,H,gx[900],gy[900],gN;\nchar f[31][31];\n\nclass State\n{\npublic:\n\tint x,y,c;\n\tState(int x, int y, int c)\n\t:x(x),y(y),c(c)\n\t{}\n};\n\nvoid bfs(int x, int y)\n{\n\tbool hs[30][30]={0};\n\t\n\tqueue<State> q;\n\tq.push(State(x,y,0));\n\ths[x][y]=1;\n\t\n\twhile(!q.empty())\n\t{\n\t\tState s=q.front(); q.pop();\n\t\tdist[x][y][s.x][s.y]=s.c;\n\t\t\n\t\tfor(int i=0; i<4; i++)\n\t\t{\n\t\t\tint tx=s.x+dx[i], ty=s.y+dy[i];\n\t\t\tif(tx<0||ty<0||tx>=W||ty>=H) continue;\n\t\t\tif(f[tx][ty]=='#') continue;\n\t\t\tif(hs[tx][ty]) continue;\n\t\t\t\n\t\t\ths[tx][ty]=1;\n\t\t\t\n\t\t\tq.push(State(tx,ty,s.c+1));\n\t\t}\n\t}\n}\n\nvoid calcD()\n{\n\tfor(int i=0; i<H; i++)\n\tfor(int j=0; j<W; j++)\n\t{\n\t\tif(f[j][i]=='#') continue;\n\t\tbfs(j,i);\n\t}\n}\n\nbool loop(int qx, int qy, int d)\n{\n\tint sx=qx+dx[d], sy=qy+dy[d];\n\tif(sx<0||sy<0||sx>=W||sy>=H) return false;\n\tif(f[sx][sy]=='#') return false;\n\t\n\tbool hs[30][30]={0};\n\t\n\tqueue<State> q;\n\tq.push(State(sx,sy,0));\n\ths[qx][qy]=1;\n\ths[sx][sy]=1;\n\t\n\twhile(!q.empty())\n\t{\n\t\tState s=q.front(); q.pop();\n\t\t\n\t\tfor(int i=0; i<4; i++)\n\t\t{\n\t\t\tint tx=s.x+dx[i], ty=s.y+dy[i];\n\t\t\tif(tx<0||ty<0||tx>=W||ty>=H) continue;\n\t\t\tif(f[tx][ty]=='#') continue;\n\t\t\tif(tx==qx&&ty==qy)\n\t\t\t{\n\t\t\t\tif(s.c==0) continue;\n\t\t\t\telse return true;\n\t\t\t}\n\t\t\tif(hs[tx][ty]) continue;\n\t\t\t\n\t\t\ths[tx][ty]=1;\n\t\t\t\n\t\t\tq.push(State(tx,ty,s.c+1));\n\t\t}\n\t}\n\t\n\treturn false;\n}\n\nint judge(int qx, int qy, int ax, int ay)\n{\t\n\tfor(int k=0; k<gN; k++)\n\t{\n\t\tif(dist[qx][qy][gx[k]][gy[k]] < dist[ax][ay][gx[k]][gy[k]]) return 1;\n\t}\n\t\n\tif(lp[qx][qy]) return 0;\n\treturn -1;\n}\n\nvoid Search()\n{\n\tfor(int i=0; i<H; i++)\n\tfor(int j=0; j<W; j++)\n\t{\n\t\tif(f[j][i]=='#') continue;\n\t\tfor(int k=0; k<4; k++)\n\t\t{\n\t\t\tif(loop(j,i,k))\n\t\t\t{\n\t\t\t\t lp[j][i]=true;\n\t\t\t\t break;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int k=0; k<H; k++)\n\t\tfor(int l=0; l<W; l++)\n\t\t{\n\t\t\tif(f[l][k]=='#') continue;\n\t\t\trelt[j][i][l][k]=judge(j,i,l,k);\n\t\t}\n\t}\n}\n\nint Aphase(int a, int b, int x, int y);\nint Qphase(int a, int b, int x, int y);\n\nint Aphase(int a, int b, int x, int y, int d)\n{\n\tif(ck[a][b][x][y]) return memo[a][b][x][y];\n\tint ret=relt[a][b][x][y];\n\tfor(int i=0; i<H; i++)\n\tfor(int j=0; j<W; j++)\n\t{\n\t\tif(dist[x][y][j][i]==-1) continue;\n\t\t\n\t\tif(relt[a][b][j][i]>relt[a][b][x][y]) continue;\n\t\tif(dist[x][y][j][i]<=d)\n\t\t{\n\t\t\tret=min(ret, relt[a][b][j][i]);\n\t\t}\n\t}\n\t\n\tfor(int i=0; i<H; i++)\n\tfor(int j=0; j<W; j++)\n\t{\n\t\tif(dist[x][y][j][i]==-1) continue;\n\t\tif(ck[a][b][j][i]) \n\t\t{\n\t\t\tret=min(ret, memo[a][b][j][i]);\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tif(relt[a][b][j][i]>ret) continue;\n\t\tif(dist[x][y][j][i]<=d)\n\t\t{\n\t\t\tret=min(ret, Qphase(a,b,j,i));\n\t\t}\n\t\t\n\t}\n\treturn ret;\n}\n\nint Qphase(int a, int b, int x, int y)\n{\n\tif(ck[a][b][x][y]) return memo[a][b][x][y];\n\tck[a][b][x][y]=1;\n\t\n\tmemo[a][b][x][y]=relt[a][b][x][y];\n\tfor(int i=0; i<H; i++)\n\tfor(int j=0; j<W; j++)\n\t{\n\t\tif(f[j][i]=='#') continue;\n\t\tif(dist[a][b][j][i]>=dist[x][y][j][i]) continue;\n\t\tif(dist[a][b][j][i]==-1) continue;\n\t\t\n\t\tmemo[a][b][x][y]=max(memo[a][b][x][y], Aphase(j,i,x,y,dist[a][b][j][i]));\n\t}\n\t\n\treturn memo[a][b][x][y];\n}\n\nint main()\n{\n\twhile(cin >> W >> H, (W||H))\n\t{\n\t\tint ax,ay,qx,qy;\n\t\tgN=0;\n\t\tmemset(lp,0,sizeof(lp));\n\t\tmemset(dist, -1, sizeof(dist));\n\t\tmemset(ck,0,sizeof(ck));\n\t\tfor(int i=0; i<H; i++)\n\t\tfor(int j=0; j<W; j++)\n\t\t{\n\t\t\tcin >> f[j][i];\n\t\t\tif(f[j][i]=='A')\n\t\t\t{\n\t\t\t\tax=j; ay=i;\n\t\t\t}\n\t\t\tif(f[j][i]=='Q')\n\t\t\t{\n\t\t\t\tqx=j; qy=i;\n\t\t\t}\n\t\t\tif(f[j][i]=='E')\n\t\t\t{\n\t\t\t\tgx[gN]=j;\n\t\t\t\tgy[gN]=i;\n\t\t\t\tgN++;\n\t\t\t}\n\t\t}\n\t\t\n\t\tcalcD();\n\t\tSearch();\n\t\t\n\t\tint ret=Qphase(qx,qy,ax,ay);\n\t\tif(ret==-1) \tcout << \"Army can catch Queen.\" << endl;\n\t\telse if(ret==0)\tcout << \"Queen can not escape and Army can not catch Queen.\" << endl;\n\t\telse\t\t\tcout << \"Queen can escape.\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\n\nint dx[]={-1,0,1,0};\nint dy[]={0,-1,0,1};\n\nbool ck[30][30][30][30]; // ax,ay qx,qy\nint dist[30][30][30][30]; // xy to x'y'\nint relt[30][30][30][30];\nint memo[30][30][30][30];\nint W,H,gx[900],gy[900],gN;\nchar f[31][31];\n\nclass State\n{\npublic:\n\tint x,y,c;\n\tState(int x, int y, int c)\n\t:x(x),y(y),c(c)\n\t{}\n};\n\nvoid bfs(int x, int y)\n{\n\tbool hs[30][30]={0};\n\t\n\tqueue<State> q;\n\tq.push(State(x,y,0));\n\ths[x][y]=1;\n\t\n\twhile(!q.empty())\n\t{\n\t\tState s=q.front(); q.pop();\n\t\tdist[x][y][s.x][s.y]=s.c;\n\t\t\n\t\tfor(int i=0; i<4; i++)\n\t\t{\n\t\t\tint tx=s.x+dx[i], ty=s.y+dy[i];\n\t\t\tif(tx<0||ty<0||tx>=W||ty>=H) continue;\n\t\t\tif(f[tx][ty]=='#') continue;\n\t\t\tif(hs[tx][ty]) continue;\n\t\t\t\n\t\t\ths[tx][ty]=1;\n\t\t\t\n\t\t\tq.push(State(tx,ty,s.c+1));\n\t\t}\n\t}\n}\n\nvoid calcD()\n{\n\tfor(int i=0; i<H; i++)\n\tfor(int j=0; j<W; j++)\n\t{\n\t\tif(f[j][i]=='#') continue;\n\t\tbfs(j,i);\n\t}\n}\n\nint judge(int qx, int qy, int ax, int ay)\n{\n\tint cnt=0;\n\tfor(int k=0; k<gN; k++)\n\t{\n\t\tif(dist[qx][qy][gx[k]][gy[k]] < dist[ax][ay][gx[k]][gy[k]]) return 1;\n\t\t\n\t\tif(dist[qx][qy][gx[k]][gy[k]] == dist[ax][ay][gx[k]][gy[k]]) cnt++;\n\t}\n\tif(cnt>=2) return 0;\n\treturn -1;\n}\n\nvoid Search()\n{\n\tfor(int i=0; i<H; i++)\n\tfor(int j=0; j<W; j++)\n\t{\n\t\tif(f[j][i]=='#') continue;\n\t\tfor(int k=0; k<H; k++)\n\t\tfor(int l=0; l<W; l++)\n\t\t{\n\t\t\t\n\t\t\tif(f[l][k]=='#') continue;\n\t\t\trelt[j][i][l][k]=judge(j,i,l,k);\n\t\t}\n\t}\n}\n\nint Aphase(int a, int b, int x, int y);\nint Qphase(int a, int b, int x, int y);\n\nint Aphase(int a, int b, int x, int y, int d)\n{\n\tif(ck[a][b][x][y]) return memo[a][b][x][y];\n\tmemo[a][b][x][y]=relt[a][b][x][y];\n\tck[a][b][x][y]=1;\n\n\tfor(int i=0; i<H; i++)\n\tfor(int j=0; j<W; j++)\n\t{\n\t\tif(f[j][i]=='#') continue;\n\t\tif(dist[x][y][j][i]<=d)\n\t\t{\n\t\t\tbool g=true;\n\t\t\tfor(int k=0; k<gN; k++)\n\t\t\t{\n\t\t\t\tif(dist[a][b][gx[k]][gy[k]] < dist[j][i][gx[k]][gy[k]])\n\t\t\t\t{\n\t\t\t\t\tg=false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!g) continue;\n\n\t\t\tmemo[a][b][x][y]=min(memo[a][b][x][y], Qphase(a,b,j,i));\n\t\t\t\n\t\t}\n\t}\n\treturn memo[a][b][x][y];\n}\n\nint Qphase(int a, int b, int x, int y)\n{\n\tint ret=relt[a][b][x][y];\n\t//if(ck[a][b][x][y]) return ck[a][b][x][y];\n\tfor(int i=0; i<H; i++)\n\tfor(int j=0; j<W; j++)\n\t{\n\t\tif(f[j][i]=='#') continue;\n\t\tif(dist[a][b][j][i]>=dist[x][y][j][i]) continue;\n\t\tif(ck[j][i][x][y]) return memo[j][i][x][y];\n\t\t\n\t\tret=max(ret, Aphase(j,i,x,y,dist[a][b][j][i]));\n\t}\n\n\treturn ret;\n}\n\nint main()\n{\n\twhile(cin >> W >> H, (W||H))\n\t{\n\t\tint ax,ay,qx,qy;\n\t\tgN=0;\n\t\tmemset(ck,0,sizeof(ck));\n\t\tfor(int i=0; i<H; i++)\n\t\tfor(int j=0; j<W; j++)\n\t\t{\n\t\t\tcin >> f[j][i];\n\t\t\tif(f[j][i]=='A')\n\t\t\t{\n\t\t\t\tax=j; ay=i;\n\t\t\t}\n\t\t\tif(f[j][i]=='Q')\n\t\t\t{\n\t\t\t\tqx=j; qy=i;\n\t\t\t}\n\t\t\tif(f[j][i]=='E')\n\t\t\t{\n\t\t\t\tgx[gN]=j;\n\t\t\t\tgy[gN]=i;\n\t\t\t\tgN++;\n\t\t\t}\n\t\t}\n\t\t\n\t\tcalcD();\n\t\tSearch();\n\t\t\n\t\tint ret=Qphase(qx,qy,ax,ay);\n\t\tif(ret==-1) \tcout << \"Army can catch Queen.\" << endl;\n\t\telse if(ret==0)\tcout << \"Queen can not escape and Army can not catch Queen.\" << endl;\n\t\telse\t\t\tcout << \"Queen can escape.\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <queue>\n#include <cmath>\n#include <algorithm>\n#include <functional>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define rep1(i,n) for(int i=1;i<=(n);++i)\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl;\ntypedef pair<int,int> P;\nint h,w,qx,qy,ax,ay;\nstring s[30];\nshort int dp[30][30][30][30][2];\t//1->Qwin,-1->Awin.0->?\n//qx,qy,ax,ay,turn=0->queen\nint dx[5]={0,1,0,-1,0},dy[5]={0,0,1,0,-1};\nvector<P> exits;\nbool is(int x,int y){\n\tif(x<0||h<=x||y<0||w<=y||s[x][y]=='#') return false;\n\treturn true;\n}\nvoid init(){\n\texits.clear();\n\trep(i,h) rep(j,w) rep(k,h) rep(l,w) rep(turn,2) dp[i][j][k][l][turn]=0;\n}\nvoid showdp(int i,int j,int k,int l,int turn,int value){\n\tprintf(\"dp[%d][%d][%d][%d][%d]=%d\\n\",i,j,k,l,turn,value);\n}\nint main(){\n\twhile(true){\n\t\tcin>>w>>h;\n\t\tif(w==0) break;\n\t\tinit();\n\t\trep(i,h) cin>>s[i];\n\t\trep(i,h) rep(j,w){\n\t\t\tif(s[i][j]=='Q') qx=i,qy=j;\n\t\t\tif(s[i][j]=='A') ax=i,ay=j;\n\t\t\tif(s[i][j]=='E') exits.pb(P(i,j));\n\t\t}\n\t\tbool update=true;\n\t\tfor(P ex : exits){\n\t\t\tint x=ex.fs,y=ex.sc;\n\t\t\trep(i,h) rep(j,w) dp[x][y][i][j][0]=1;\n\t\t}\n\t\trep(i,h) rep(j,w) rep(turn,2) dp[i][j][i][j][turn]=-1;\n\t\twhile(update){\n\t\t\tupdate=false;\n\t\t\t//turn=0\n\t\t\trep(i,h) rep(j,w) rep(k,h) rep(l,w){\n\t\t\t\tif(dp[i][j][k][l][0]!=0) continue;\n\t\t\t\tbool allcant=true,canwin=false;\n\t\t\t\trep(di,5){\n\t\t\t\t\tint nx=i+dx[di],ny=j+dy[di];\n\t\t\t\t\tif(!is(nx,ny)) continue;\n\t\t\t\t\tif(dp[nx][ny][k][l][1]==1) canwin=true;\n\t\t\t\t\tif(dp[nx][ny][k][l][1]!=-1) allcant=false;\n\t\t\t\t}\n\t\t\t\tif(canwin){\n\t\t\t\t\tdp[i][j][k][l][0]=1;\n//\t\t\t\t\tshowdp(i,j,k,l,0,1);\n\t\t\t\t\tupdate=true;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(allcant){\n\t\t\t\t\tdp[i][j][k][l][0]=-1;\n//\t\t\t\t\tshowdp(i,j,k,l,0,-1);\n\t\t\t\t\tupdate=true;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//turn=1\n\t\t\trep(i,h) rep(j,w) rep(k,h) rep(l,w){\n\t\t\t\tif(dp[i][j][k][l][1]!=0) continue;\n\t\t\t\tbool allcant=true,canwin=false;\n\t\t\t\trep(di,5){\n\t\t\t\t\tint nx=k+dx[di],ny=l+dy[di];\n\t\t\t\t\tif(!is(nx,ny)) continue;\n\t\t\t\t\tif(dp[i][j][nx][ny][0]==-1) canwin=true;\n\t\t\t\t\tif(dp[i][j][nx][ny][0]!=1) allcant=false;\n\t\t\t\t}\n\t\t\t\tif(canwin){\n\t\t\t\t\tdp[i][j][k][l][1]=-1;\n//\t\t\t\t\tshowdp(i,j,k,l,1,-1);\n\t\t\t\t\tupdate=true;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(allcant){\n\t\t\t\t\tdp[i][j][k][l][1]=1;\n//\t\t\t\t\tshowdp(i,j,k,l,1,1);\n\t\t\t\t\tupdate=true;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n//\t\trep(i,h) rep(j,w) rep(k,h) rep(l,w) rep(turn,2) showdp(i,j,k,l,turn,dp[i][j][k][l][turn]);\n\t\tswitch(dp[qx][qy][ax][ay][0]){\n\t\t\tcase -1:\n\t\t\t\tputs(\"Army can catch Queen.\");\n\t\t\t\tbreak;\n\t\t\tcase 0:\n\t\t\t\tputs(\"Queen can not escape and Army can not catch Queen.\");\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tputs(\"Queen can escape.\");\n\t\t\t\tbreak;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\ntypedef vector<vector<int>> Graph;\n\nvector<int> solve(const Graph&g) {\n\tvector<int>nums(g.size());\n\tmap<int, vector<int>> revg;\n\tfor (int i = 0; i < g.size();++i){\n\t\tauto es(g[i]);\n\t\tnums[i] = es.size();\n\t\tfor (auto e : es) {\n\t\t\trevg[e].push_back(i);\n\t\t}\n\n\t}\n\n\t//1 : win   0 : draw   -1 :loss\n\tvector<int>anss(g.size());\n\tqueue<int>que;\n\tfor (int i = 0; i < g.size(); ++i) {\n\t\tif (!nums[i]) {\n\t\t\tque.push(i);\n\t\t\tanss[i] = -1;\n\t\t}\n\t}\n\twhile (!que.empty()) {\n\t\tint now(que.front());\n\t\tque.pop();\n\t\tif (anss[now] == 1) {\n\t\t\tfor (auto reve : revg[now]) {\n\t\t\t\tnums[reve]--;\n\t\t\t\tif (!nums[reve]&&anss[reve]==0) {\n\t\t\t\t\tanss[reve] = -1;\n\t\t\t\t\tque.push(reve);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if (anss[now] == -1) {\n\t\t\tfor (auto reve : revg[now]) {\n\t\t\t\tif (anss[reve] == 0) {\n\t\t\t\t\tanss[reve] = 1;\n\t\t\t\t\tque.push(reve);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tassert(false);\n\t\t}\n\t}\n\treturn anss;\n}\nint SIZE = 30;\nint gethash(int ax, int ay, int bx, int by, int c) {\n\treturn (ax-1)* SIZE * SIZE * SIZE * 2 + (ay-1)* SIZE * SIZE * 2 + (bx-1) * SIZE * 2 + (by-1) * 2 + c+1;\n}\n\nint main() {\n\twhile (true) {\n\t\tint W, H; cin >> W >> H;\n\t\tif (!W)break;\n\t\tvector<vector<int>>field(H + 2, vector<int>(W + 2,-1));\n\t\tint sqx, sqy, sax, say;\n\t\tfor (int i = 0; i < H; ++i) {\n\t\t\tstring st; cin >> st;\n\t\t\tfor (int j = 0; j < W; ++j) {\n\t\t\t\tswitch (st[j]) {\n\t\t\t\tcase 'Q':\n\t\t\t\t\tfield[i + 1][j + 1] = 0;\n\t\t\t\t\tsqx = j + 1; sqy = i + 1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'A':\n\t\t\t\t\tfield[i + 1][j + 1] = 0;\n\t\t\t\t\tsax = j + 1; say = i + 1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '#':\n\t\t\t\t\tbreak;\n\t\t\t\tcase '.':\n\t\t\t\t\tfield[i + 1][j + 1] = 0;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'E':\n\t\t\t\t\tfield[i + 1][j + 1] = 2;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tassert(false);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSIZE = max(H, W);\n\t\tGraph g(SIZE * SIZE * SIZE*SIZE*2+1);\n\t\tint dx[] = { -1,0,1,0,0 };\n\t\tint dy[] = { 0,1,0,-1,0 };\n\t\tfor (int qx = 1; qx < W + 1; ++qx) {\n\t\t\tfor (int qy = 1; qy < H + 1; ++qy) {\n\t\t\t\tif (field[qy][qx] == -1)continue;\n\t\t\t\tfor (int ax = 1; ax < W + 1; ++ax) {\n\t\t\t\t\tfor (int ay = 1; ay < H + 1; ++ay) {\n\t\t\t\t\t\tif (field[ay][ax] == -1)continue;\n\t\t\t\t\t\tfor (int nt = 0; nt < 2; ++nt) {\n\t\t\t\t\t\t\tint nowhash = gethash(qx, qy, ax, ay, nt);\n\t\t\t\t\t\t\tif (qx == ax&&qy == ay) {\n\t\t\t\t\t\t\t\tif (nt) {\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\tg[nowhash].push_back(0);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (field[qy][qx] == 2&&nt) {\n\t\t\t\t\t\t\t\tg[nowhash].push_back(0);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfor (int way = 0; way < 5; ++way) {\n\t\t\t\t\t\t\t\tint nqx(qx), nqy(qy), nax(ax), nay(ay);\n\t\t\t\t\t\t\t\tif (nt) {\n\t\t\t\t\t\t\t\t\tnqx += dx[way]; nqy += dy[way];\n\t\t\t\t\t\t\t\t\tif (field[nqy][nqx]==-1) continue;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\tnax += dx[way]; nay += dy[way];\n\t\t\t\t\t\t\t\t\tif ((field[nay][nax]==-1)) continue;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (nax == nqx&&nay == nqy) {\n\t\t\t\t\t\t\t\t\tif (nt) {\n\t\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\tg[nowhash].push_back(0);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tint nexthash = gethash(nqx, nqy, nax, nay, !nt);\n\t\t\t\t\t\t\t\tg[nowhash].push_back(nexthash);\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tauto anss=solve(g);\n\t\tint ans = anss[gethash(sqx, sqy, sax, say, 1)];\n\t\tif (ans == 0)cout << \"Queen can not escape and Army can not catch Queen.\" << endl;\n\t\telse if (ans == 1)cout << \"Queen can escape.\" << endl;\n\t\telse cout << \"Army can catch Queen.\" << endl;\n\t}\n\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <queue>\n#include <cmath>\n#include <algorithm>\n#include <functional>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define rep1(i,n) for(int i=1;i<=(n);++i)\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl;\ntypedef pair<int,int> P;\nint h,w,qx,qy,ax,ay;\nstring s[30];\nint dp[100][100][100][100][2];\t//1->Qwin,-1->Awin.0->?\n//qx,qy,ax,ay,turn=0->queen\nint dx[5]={0,1,0,-1,0},dy[5]={0,0,1,0,-1};\nvector<P> exits;\nbool is(int x,int y){\n\tif(x<0||h<=x||y<0||w<=y||s[x][y]=='#') return false;\n\treturn true;\n}\nvoid init(){\n\texits.clear();\n\trep(i,h) rep(j,w) rep(k,h) rep(l,w) rep(turn,2) dp[i][j][k][l][turn]=0;\n}\nvoid showdp(int i,int j,int k,int l,int turn,int value){\n\tprintf(\"dp[%d][%d][%d][%d][%d]=%d\\n\",i,j,k,l,turn,value);\n}\nint main(){\n\twhile(true){\n\t\tcin>>w>>h;\n\t\tif(w==0) break;\n\t\tinit();\n\t\trep(i,h) cin>>s[i];\n\t\trep(i,h) rep(j,w){\n\t\t\tif(s[i][j]=='Q') qx=i,qy=j;\n\t\t\tif(s[i][j]=='A') ax=i,ay=j;\n\t\t\tif(s[i][j]=='E') exits.pb(P(i,j));\n\t\t}\n\t\tbool update=true;\n\t\tfor(P ex : exits){\n\t\t\tint x=ex.fs,y=ex.sc;\n\t\t\trep(i,h) rep(j,w) dp[x][y][i][j][0]=1;\n\t\t}\n\t\trep(i,h) rep(j,w) rep(turn,2) dp[i][j][i][j][turn]=-1;\n\t\twhile(update){\n\t\t\tupdate=false;\n\t\t\t//turn=0\n\t\t\trep(i,h) rep(j,w) rep(k,h) rep(l,w){\n\t\t\t\tif(dp[i][j][k][l][0]!=0) continue;\n\t\t\t\tbool allcant=true,canwin=false;\n\t\t\t\trep(di,5){\n\t\t\t\t\tint nx=i+dx[di],ny=j+dy[di];\n\t\t\t\t\tif(!is(nx,ny)) continue;\n\t\t\t\t\tif(dp[nx][ny][k][l][1]==1) canwin=true;\n\t\t\t\t\tif(dp[nx][ny][k][l][1]!=-1) allcant=false;\n\t\t\t\t}\n\t\t\t\tif(canwin){\n\t\t\t\t\tdp[i][j][k][l][0]=1;\n//\t\t\t\t\tshowdp(i,j,k,l,0,1);\n\t\t\t\t\tupdate=true;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(allcant){\n\t\t\t\t\tdp[i][j][k][l][0]=-1;\n//\t\t\t\t\tshowdp(i,j,k,l,0,-1);\n\t\t\t\t\tupdate=true;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//turn=1\n\t\t\trep(i,h) rep(j,w) rep(k,h) rep(l,w){\n\t\t\t\tif(dp[i][j][k][l][1]!=0) continue;\n\t\t\t\tbool allcant=true,canwin=false;\n\t\t\t\trep(di,5){\n\t\t\t\t\tint nx=k+dx[di],ny=l+dy[di];\n\t\t\t\t\tif(!is(nx,ny)) continue;\n\t\t\t\t\tif(dp[i][j][nx][ny][0]==-1) canwin=true;\n\t\t\t\t\tif(dp[i][j][nx][ny][0]!=1) allcant=false;\n\t\t\t\t}\n\t\t\t\tif(canwin){\n\t\t\t\t\tdp[i][j][k][l][1]=-1;\n//\t\t\t\t\tshowdp(i,j,k,l,1,-1);\n\t\t\t\t\tupdate=true;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(allcant){\n\t\t\t\t\tdp[i][j][k][l][1]=1;\n//\t\t\t\t\tshowdp(i,j,k,l,1,1);\n\t\t\t\t\tupdate=true;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n//\t\trep(i,h) rep(j,w) rep(k,h) rep(l,w) rep(turn,2) showdp(i,j,k,l,turn,dp[i][j][k][l][turn]);\n\t\tswitch(dp[qx][qy][ax][ay][0]){\n\t\t\tcase -1:\n\t\t\t\tputs(\"Army can catch Queen.\");\n\t\t\t\tbreak;\n\t\t\tcase 0:\n\t\t\t\tputs(\"Queen can not escape and Army can not catch Queen.\");\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tputs(\"Queen can escape.\");\n\t\t\t\tbreak;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (int)(k); i < (int)(n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\nconst int dx[] = { -1, 0, 0, 1 }, dy[] = { 0, -1, 1, 0 };\n//[const int dx[] = { -1, -1, -1, 0, 0, 1, 1, 1 }, dy[] = { 0, -1, 1, -1, 1, 0, -1, 1 };\nbool valid(int x, int y, int h, int w) { return (x >= 0 && y >= 0 && x < h&&y < w); }\nint place(int x, int y, int w) { return w*x + y; }\n\nint dp[2][33][33][33][33]; //turn, x_queen, y_queen, x_army, y_army\nint h, w;\nvs fld;\n\ntypedef tuple<int, int, int, int, int> state;\n\nvoid init()\n{\n\tfld.clear(); fld.resize(h);\n\tMS(dp, 0);\n}\n\nint main()\n{\n\tcin.sync_with_stdio(false); cout << fixed << setprecision(10);\n\twhile (cin >> w >> h, h)\n\t{\n\t\tinit();\n\t\tREP(i, h) cin >> fld[i];\n\t\tpii army, queen;\n\t\tset<pii> exit;\n\t\tREP(i, h)REP(j, w)\n\t\t{\n\t\t\tif (fld[i][j] == '#') continue;\n\t\t\tif (fld[i][j] == 'Q') queen = pii(i, j);\n\t\t\tif (fld[i][j] == 'A') army = pii(i, j);\n\t\t\tif (fld[i][j] == 'E') exit.emplace(i, j);\n\t\t\tfld[i][j] = '.';\n\t\t}\n\t\tvector<state> updates;\n\t\tfor (auto i : exit)REP(ax, h)REP(ay, w)\n\t\t{\n\t\t\tint qx = i.first, qy = i.second;\n\t\t\tdp[0][qx][qy][ax][ay] = 1;\n\t\t\tupdates.push_back(state(0, qx, qy, ax, ay));\n\t\t}\n\t\tREP(i, h)REP(j, w)\n\t\t{\n\t\t\tif (fld[i][j] == '#') continue;\n\t\t\tdp[0][i][j][i][j] = -1;\n\t\t\tupdates.push_back(state(0, i, j, i, j));\n\t\t}\n\t\tREP(i, 2)REP(qx, h)REP(qy, w)REP(ax, h)REP(ay, w) updates.push_back(state(i, qx, qy, ax, ay));\n\t\twhile (!updates.empty())\n\t\t{\n\t\t\tvector<state> nexts;\n\t\t\tfor (auto tmp : updates)\n\t\t\t//REP(i, 2)REP(qx, h)REP(qy, w)REP(ax, h)REP(ay, w)\n\t\t\t{\n\t\t\t\tint i, qx, qy, ax, ay;\n\t\t\t\ttie(i, qx, qy, ax, ay) = tmp;\n\t\t\t\tif (!valid(qx, qy, h, w) || !valid(ax, ay, h, w) || dp[i][qx][qy][ax][ay] != 0) continue;\n\t\t\t\tif (i == 0)\n\t\t\t\t{\n\t\t\t\t\tset<int> st;\n\t\t\t\t\tst.insert(dp[1][qx][qy][ax][ay]);\n\t\t\t\t\tREP(j, 4)\n\t\t\t\t\t{\n\t\t\t\t\t\tint nx = qx + dx[j], ny = qy + dy[j];\n\t\t\t\t\t\tif (!valid(nx, ny, h, w) || fld[nx][ny] == '#') continue;\n\t\t\t\t\t\tst.insert(dp[1][nx][ny][ax][ay]);\n\t\t\t\t\t}\n\t\t\t\t\tif (st.size() == 1 && *st.begin() == -1)\n\t\t\t\t\t{\n\t\t\t\t\t\tdp[i][qx][qy][ax][ay] = -1;\n\t\t\t\t\t}\n\t\t\t\t\telse if (st.count(1))\n\t\t\t\t\t{\n\t\t\t\t\t\tdp[i][qx][qy][ax][ay] = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tset<int> st;\n\t\t\t\t\tst.insert(dp[0][qx][qy][ax][ay]);\n\t\t\t\t\tREP(j, 4)\n\t\t\t\t\t{\n\t\t\t\t\t\tint nx = ax + dx[j], ny = ay + dy[j];\n\t\t\t\t\t\tif (!valid(nx, ny, h, w) || fld[nx][ny] == '#') continue;\n\t\t\t\t\t\tst.insert(dp[0][qx][qy][nx][ny]);\n\t\t\t\t\t}\n\t\t\t\t\tif (st.size() == 1 && *st.begin() == 1)\n\t\t\t\t\t{\n\t\t\t\t\t\tdp[i][qx][qy][ax][ay] = 1;\n\t\t\t\t\t}\n\t\t\t\t\telse if (st.count(-1))\n\t\t\t\t\t{\n\t\t\t\t\t\tdp[i][qx][qy][ax][ay] = -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (dp[i][qx][qy][ax][ay] != 0)\n\t\t\t\t{\n\t\t\t\t\tif (dp[1 - i][qx][qy][ax][ay] == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tnexts.push_back(state(1 - i, qx, qy, ax, ay));\n\t\t\t\t\t}\n\t\t\t\t\tREP(i, 2)REP(j, 4)REP(k, 4)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (!valid(qx + dx[j], qy + dy[j], h, w) || !valid(ax + dx[k], ay + dy[k], h, w) || dp[i][qx + dx[j]][qy + dy[j]][ax + dx[k]][ay + dy[k]] != 0) continue;\n\t\t\t\t\t\tnexts.push_back(state(i, qx + dx[j], qy + dy[j], ax + dx[k], ay + dy[k]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tsort(ALL(updates));\n\t\t\tupdates.erase(unique(ALL(updates)), updates.end());\n\t\t\tupdates = nexts;\n\t\t}\n\t\t\n\n\t\tint ans = dp[0][queen.first][queen.second][army.first][army.second];\n\t\tif (ans == 1) cout << \"Queen can escape.\" << endl;\n\t\telse if (ans == 0) cout << \"Queen can not escape and Army can not catch Queen.\" << endl;\n\t\telse cout << \"Army can catch Queen.\" << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\nconst ld eps = 1e-9;\n\ntypedef vector<vector<int>> Graph;\n\nvector<int> solve(Graph&g) {\n\tvector<int>nums(g.size());\n\tGraph revg(g.size());\n\tfor (int i = 0; i < g.size();++i){\n\t\tauto es(g[i]);\n\t\tnums[i] = es.size();\n\t\tfor (auto e : es) {\n\t\t\trevg[e].push_back(i);\n\t\t}\n\t}\n\n\t//1 : win   0 : draw   -1 :loss\n\tvector<int>anss(g.size());\n\tqueue<int>que;\n\tfor (int i = 0; i < g.size(); ++i) {\n\t\tif (!nums[i]) {\n\t\t\tque.push(i);\n\t\t\tanss[i] = -1;\n\t\t}\n\t}\n\twhile (!que.empty()) {\n\t\tint now(que.front());\n\t\tque.pop();\n\t\tif (anss[now] == 1) {\n\t\t\tfor (auto reve : revg[now]) {\n\t\t\t\tnums[reve]--;\n\t\t\t\tif (!nums[reve]&&anss[reve]==0) {\n\t\t\t\t\tanss[reve] = -1;\n\t\t\t\t\tque.push(reve);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if (anss[now] == -1) {\n\t\t\tfor (auto reve : revg[now]) {\n\t\t\t\tif (anss[reve] == 0) {\n\t\t\t\t\tanss[reve] = 1;\n\t\t\t\t\tque.push(reve);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tassert(false);\n\t\t}\n\t}\n\treturn anss;\n}\nconst int SIZE = 32;\nint gethash(int ax, int ay, int bx, int by, int c) {\n\treturn (ax-1)* SIZE * SIZE * SIZE * 2 + (ay-1)* SIZE * SIZE * 2 + (bx-1) * SIZE * 2 + (by-1) * 2 + c+1;\n}\n\nint main() {\n\twhile (true) {\n\t\tint W, H; cin >> W >> H;\n\t\tif (!W)break;\n\t\tvector<vector<int>>field(H + 2, vector<int>(W + 2,-1));\n\t\tint sqx, sqy, sax, say;\n\t\tfor (int i = 0; i < H; ++i) {\n\t\t\tstring st; cin >> st;\n\t\t\tfor (int j = 0; j < W; ++j) {\n\t\t\t\tswitch (st[j]) {\n\t\t\t\tcase 'Q':\n\t\t\t\t\tfield[i + 1][j + 1] = 0;\n\t\t\t\t\tsqx = j + 1; sqy = i + 1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'A':\n\t\t\t\t\tfield[i + 1][j + 1] = 0;\n\t\t\t\t\tsax = j + 1; say = i + 1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '#':\n\t\t\t\t\tbreak;\n\t\t\t\tcase '.':\n\t\t\t\t\tfield[i + 1][j + 1] = 0;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'E':\n\t\t\t\t\tfield[i + 1][j + 1] = 2;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tassert(false);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tGraph g(3000000);\n\t\tint dx[] = { -1,0,1,0,0 };\n\t\tint dy[] = { 0,1,0,-1,0 };\n\t\tfor (int qx = 1; qx < W + 1; ++qx) {\n\t\t\tfor (int qy = 1; qy < H + 1; ++qy) {\n\t\t\t\tfor (int ax = 1; ax < W + 1; ++ax) {\n\t\t\t\t\tfor (int ay = 1; ay < H + 1; ++ay) {\n\t\t\t\t\t\tfor (int nt = 0; nt < 2; ++nt) {\n\t\t\t\t\t\t\tint nowhash = gethash(qx, qy, ax, ay, nt);\n\t\t\t\t\t\t\tif (qx == ax&&qy == ay) {\n\t\t\t\t\t\t\t\tif (nt) {\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\tg[nowhash].push_back(0);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (field[qy][qx] == 2&&nt) {\n\t\t\t\t\t\t\t\tg[nowhash].push_back(0);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfor (int way = 0; way < 5; ++way) {\n\t\t\t\t\t\t\t\tint nqx(qx), nqy(qy), nax(ax), nay(ay);\n\t\t\t\t\t\t\t\tif (nt) {\n\t\t\t\t\t\t\t\t\tnqx += dx[way]; nqy += dy[way];\n\t\t\t\t\t\t\t\t\tif (field[nqy][nqx]==-1) continue;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\tnax += dx[way]; nay += dy[way];\n\t\t\t\t\t\t\t\t\tif ((field[nay][nax]==-1)) continue;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (nax == nqx&&nay == nqy) {\n\t\t\t\t\t\t\t\t\tif (nt) {\n\t\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\tg[nowhash].push_back(0);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tint nexthash = gethash(nqx, nqy, nax, nay, !nt);\n\t\t\t\t\t\t\t\tg[nowhash].push_back(nexthash);\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tauto anss=solve(g);\n\t\tint ans = anss[gethash(sqx, sqy, sax, say, 1)];\n\t\tif (ans == 0)cout << \"Queen can not escape and Army can not catch Queen.\" << endl;\n\t\telse if (ans == 1)cout << \"Queen can escape.\" << endl;\n\t\telse cout << \"Army can catch Queen.\" << endl;\n\t}\n\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\ntypedef vector<vector<int>> Graph;\n\nvector<int> solve(const Graph&g) {\n\tvector<int>nums(g.size());\n\tGraph revg(g.size());\n\tfor (int i = 0; i < g.size();++i){\n\t\tauto es(g[i]);\n\t\tnums[i] = es.size();\n\t\tfor (auto e : es) {\n\t\t\trevg[e].push_back(i);\n\t\t}\n\n\t}\n\n\t//1 : win   0 : draw   -1 :loss\n\tvector<int>anss(g.size());\n\tqueue<int>que;\n\tfor (int i = 0; i < g.size(); ++i) {\n\t\tif (!nums[i]) {\n\t\t\tque.push(i);\n\t\t\tanss[i] = -1;\n\t\t}\n\t}\n\twhile (!que.empty()) {\n\t\tint now(que.front());\n\t\tque.pop();\n\t\tif (anss[now] == 1) {\n\t\t\tfor (auto reve : revg[now]) {\n\t\t\t\tnums[reve]--;\n\t\t\t\tif (!nums[reve]&&anss[reve]==0) {\n\t\t\t\t\tanss[reve] = -1;\n\t\t\t\t\tque.push(reve);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if (anss[now] == -1) {\n\t\t\tfor (auto reve : revg[now]) {\n\t\t\t\tif (anss[reve] == 0) {\n\t\t\t\t\tanss[reve] = 1;\n\t\t\t\t\tque.push(reve);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tassert(false);\n\t\t}\n\t}\n\treturn anss;\n}\nconst int SIZE = 30;\nint gethash(int ax, int ay, int bx, int by, int c) {\n\treturn (ax-1)* SIZE * SIZE * SIZE * 2 + (ay-1)* SIZE * SIZE * 2 + (bx-1) * SIZE * 2 + (by-1) * 2 + c+1;\n}\n\nint main() {\n\twhile (true) {\n\t\tint W, H; cin >> W >> H;\n\t\tif (!W)break;\n\t\tvector<vector<int>>field(H + 2, vector<int>(W + 2,-1));\n\t\tint sqx, sqy, sax, say;\n\t\tfor (int i = 0; i < H; ++i) {\n\t\t\tstring st; cin >> st;\n\t\t\tfor (int j = 0; j < W; ++j) {\n\t\t\t\tswitch (st[j]) {\n\t\t\t\tcase 'Q':\n\t\t\t\t\tfield[i + 1][j + 1] = 0;\n\t\t\t\t\tsqx = j + 1; sqy = i + 1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'A':\n\t\t\t\t\tfield[i + 1][j + 1] = 0;\n\t\t\t\t\tsax = j + 1; say = i + 1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '#':\n\t\t\t\t\tbreak;\n\t\t\t\tcase '.':\n\t\t\t\t\tfield[i + 1][j + 1] = 0;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'E':\n\t\t\t\t\tfield[i + 1][j + 1] = 2;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tassert(false);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tGraph g(SIZE * SIZE * SIZE*SIZE*2+1);\n\t\tint dx[] = { -1,0,1,0,0 };\n\t\tint dy[] = { 0,1,0,-1,0 };\n\t\tfor (int qx = 1; qx < W + 1; ++qx) {\n\t\t\tfor (int qy = 1; qy < H + 1; ++qy) {\n\t\t\t\tfor (int ax = 1; ax < W + 1; ++ax) {\n\t\t\t\t\tfor (int ay = 1; ay < H + 1; ++ay) {\n\t\t\t\t\t\tfor (int nt = 0; nt < 2; ++nt) {\n\t\t\t\t\t\t\tint nowhash = gethash(qx, qy, ax, ay, nt);\n\t\t\t\t\t\t\tif (qx == ax&&qy == ay) {\n\t\t\t\t\t\t\t\tif (nt) {\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\tg[nowhash].push_back(0);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (field[qy][qx] == 2&&nt) {\n\t\t\t\t\t\t\t\tg[nowhash].push_back(0);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfor (int way = 0; way < 5; ++way) {\n\t\t\t\t\t\t\t\tint nqx(qx), nqy(qy), nax(ax), nay(ay);\n\t\t\t\t\t\t\t\tif (nt) {\n\t\t\t\t\t\t\t\t\tnqx += dx[way]; nqy += dy[way];\n\t\t\t\t\t\t\t\t\tif (field[nqy][nqx]==-1) continue;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\tnax += dx[way]; nay += dy[way];\n\t\t\t\t\t\t\t\t\tif ((field[nay][nax]==-1)) continue;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (nax == nqx&&nay == nqy) {\n\t\t\t\t\t\t\t\t\tif (nt) {\n\t\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\tg[nowhash].push_back(0);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tint nexthash = gethash(nqx, nqy, nax, nay, !nt);\n\t\t\t\t\t\t\t\tg[nowhash].push_back(nexthash);\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tauto anss=solve(g);\n\t\tint ans = anss[gethash(sqx, sqy, sax, say, 1)];\n\t\tif (ans == 0)cout << \"Queen can not escape and Army can not catch Queen.\" << endl;\n\t\telse if (ans == 1)cout << \"Queen can escape.\" << endl;\n\t\telse cout << \"Army can catch Queen.\" << endl;\n\t}\n\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nconst int nmax = 30 + 1;\nconst int dx[5] = {0, 0, 1, -1, 0};\nconst int dy[5] = {1, -1, 0, 0, 0};\n\nstruct state {\n\tint x1, y1, x2, y2;\n\tbool turn; // 0 for Q ed\n\tstate() {};\n\tstate(int _x1, int _y1, int _x2, int _y2, bool _turn) {\n\t\tx1 = _x1, x2 = _x2, y1 = _y1, y2 = _y2, turn = _turn;\n\t}\n\tvoid init(int _x1, int _y1, int _x2, int _y2, bool _turn) {\n\t\tx1 = _x1, x2 = _x2, y1 = _y1, y2 = _y2, turn = _turn;\n\t}\n};\n\nbool f[nmax][nmax][nmax][nmax][2]; // 0 for lose\nvector<state> Q;\nbool ed[nmax][nmax][nmax][nmax][2];\nchar a[nmax][nmax];\nint n, m;\n\nint check(state &s)\n{\n\tint x1, x2, y1, y2;\n\tint nxtt = s.turn ^ 1;\n\tbool all = 1, exist = 0;\n\tif (s.turn == 0) {\n\t\tx1 = s.x1, y1 = s.y1;\n\t\tfor (int j = 0; j < 5; ++j) {\n\t\t\tx2 = s.x2 + dx[j], y2 = s.y2 + dy[j];\n\t\t\tif (x2 <= 0 || x2 > n || y2 <= 0 || y2 > m || a[x2][y2] == '#') continue;\n\t\t\tif (!ed[x1][y1][x2][y2][nxtt]) {\n\t\t\t\tall = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (f[x1][y1][x2][y2][nxtt] == 0)\n\t\t\t\texist = 1, all = 0;\n\t\t}\n\t}\n\telse {\n\t\tfor (int i = 0; i < 5; ++i) {\n\t\t\tx1 = s.x1 + dx[i], y1 = s.y1 + dy[i];\n\t\t\tif (x1 <= 0 || x1 > n || y1 <= 0 || y1 > m || a[x1][y1] == '#') continue;\n\t\t\tx2 = s.x2, y2 = s.y2;\n\t\t\tif (!ed[x1][y1][x2][y2][nxtt]) {\n\t\t\t\tall = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (f[x1][y1][x2][y2][nxtt] == 1)\n\t\t\t\texist = 1, all = 0;\n\t\t}\n\t}\n\tif (all)\n\t\treturn nxtt;\n\telse if (exist)\n\t\treturn s.turn;\n\telse return 2;\n}\n\nint main()\n{\n\twhile (1) {\n\t\tscanf(\"%d%d\", &n, &m);\n\t\tswap(n, m);\n\t\tif (n == 0 && m == 0) break;\n\t\tfor (int i = 1; i <= n; ++i)\n\t\t\tscanf(\"%s\", a[i] + 1);\n\t\tmemset(ed, 0, sizeof(ed));\n\t\tQ.clear();\n\t\tfor (int i = 1; i <= n; ++i)\n\t\t\tfor (int j = 1; j <= m; ++j) if (a[i][j] != '#')\n\t\t\t\tfor (int k = 1; k <= n; ++k)\n\t\t\t\t\tfor (int l = 1; l <= m; ++l) if (a[k][l] != '#') {\n\t\t\t\t\t\tif (i == k && j == l) {\n\t\t\t\t\t\t\tstate tmp(i, j, k, l, 1);\n\t\t\t\t\t\t\tQ.push_back(tmp);\n\t\t\t\t\t\t\tf[i][j][k][l][1] = 0;\n\t\t\t\t\t\t\ted[i][j][k][l][1] = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (a[i][j] == 'E') {\n\t\t\t\t\t\t\tstate tmp(i, j, k, l, 1);\n\t\t\t\t\t\t\tQ.push_back(tmp);\n\t\t\t\t\t\t\tf[i][j][k][l][1] = 1;\n\t\t\t\t\t\t\ted[i][j][k][l][1] = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n//\t\tprintf(\"hah\\n\");\n\t\tstate tmp;\n\t\tfor (int tmpi = 0; tmpi < Q.size(); ++tmpi) {\n//\t\t\tprintf(\"%d\\n\", (int)Q.size());\n\t\t\tstate now = Q[tmpi];\n\t\t\tint x1, x2, y1, y2, tmpf;\n//\t\t\tprintf(\"(%d) (%d) %d: %d\\n\", now->y1, now->y2, now->turn, f[now->x1][now->y1][now->x2][now->y2][now->turn]);\n//\t\t\tprintf(\"(%d, %d) (%d, %d) %d: %d\\n\", now->x1, now->y1, now->x2, now->y2, now->turn, f[now->x1][now->y1][now->x2][now->y2][now->turn]);\n\t\t\tbool nxtt = now.turn ^ 1;\n\t\t\tif (now.turn == 1) {\n\t\t\t\tx1 = now.x1, y1 = now.y1;\n\t\t\t\tfor (int j = 0; j < 5; ++j) {\n//\t\t\t\t\tprintf(\"hehe in\\n\");\n\t\t\t\t\tx2 = now.x2 + dx[j], y2 = now.y2 + dy[j];\n//\t\t\t\t\tprintf(\"hehe out\\n\");\n\t\t\t\t\tif (x2 <= 0 || x2 > n || y2 <= 0 || y2 > m || a[x2][y2] == '#') continue;\n\t\t\t\t\tif (ed[x1][y1][x2][y2][nxtt]) continue;\n\t\t\t\t\ttmp.init(x1, y1, x2, y2, nxtt);\n\t\t\t\t\tif ((tmpf = check(tmp)) != 2) {\n\t\t\t\t\t\ted[x1][y1][x2][y2][nxtt] = 1;\n\t\t\t\t\t\tf[x1][y1][x2][y2][nxtt] = tmpf;\n\t\t\t\t\t\tQ.push_back(tmp);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfor (int i = 0; i < 5; ++i) {\n\t\t\t\t\tx1 = now.x1 + dx[i], y1 = now.y1 + dy[i];\n\t\t\t\t\tif (x1 <= 0 || x1 > n || y1 <= 0 || y1 > m || a[x1][y1] == '#') continue;\n\t\t\t\t\tx2 = now.x2, y2 = now.y2;\n\t\t\t\t\tif (ed[x1][y1][x2][y2][nxtt]) continue;\n\t\t\t\t\ttmp.init(x1, y1, x2, y2, nxtt);\n\t\t\t\t\tif ((tmpf = check(tmp)) != 2) {\n\t\t\t\t\t\ted[x1][y1][x2][y2][nxtt] = 1;\n\t\t\t\t\t\tf[x1][y1][x2][y2][nxtt] = tmpf;\n\t\t\t\t\t\tQ.push_back(tmp);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint lx, ly, rx, ry;\n\t\tfor (int i = 1; i <= n; ++i)\n\t\t\tfor (int j = 1; j <= m; ++j) {\n\t\t\t\tif (a[i][j] == 'Q')\n\t\t\t\t\tlx = i, ly = j;\n\t\t\t\tif (a[i][j] == 'A')\n\t\t\t\t\trx = i, ry = j;\n\t\t\t}\n\t\tif (!ed[lx][ly][rx][ry][1])\n\t\t\tprintf(\"Queen can not escape and Army can not catch Queen.\\n\"); // tie\n\t\telse\n\t\t\tif (f[lx][ly][rx][ry][1])\n\t\t\t\tprintf(\"Queen can escape.\\n\"); //win\n\t\t\telse\n\t\t\t\tprintf(\"Army can catch Queen.\\n\"); //lose\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdlib>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\ntemplate<class T> inline void chmin(T &a, const T &b) { if(a > b) a = b; }\ntemplate<class T> inline void chmax(T &a, const T &b) { if(a < b) a = b; }\n\ntypedef vector<vector<int>> graph;\n\nconstexpr int INF = (1 << 29);\nconstexpr int MAX_N = 900;\n\nenum {Q, A, NUM};\n\nint dp[MAX_N][MAX_N][NUM];\n\ninline int get_index(int x, int y, int w) {\n\treturn x + y * w;\n}\n\ninline void add_edge(int a, int b, graph &G) {\n\tG[a].emplace_back(b);\n\tG[b].emplace_back(a);\n}\n\ninline string solve(int q, int a, const vector<int> &g, const graph &G) {\n\tfill_n((int *)dp, sizeof(dp) / sizeof(int), INF / 2);\n\n\tconst int n = G.size();\n\tfor(int v = 0; v < n; ++v) {\n\t\tdp[v][v][Q] = dp[v][v][A] = INF;\n\t}\n\n\tfor(const auto &e : g) {\n\t\tfor(int v = 0; v < n; ++v) {\n\t\t\tif(e != v) dp[e][v][Q] = 0;\n\t\t}\n\t}\n\n\tfor(int iter = 0; iter < 2 * n; ++iter) {\n\t\tfor(int v = 0; v < n; ++v) {\n\t\t\tfor(int u = 0; u < n; ++u) {\n\t\t\t\tif(v == u) continue;\n\n\t\t\t\t// queen turn\n\t\t\t\tif(dp[v][u][Q] != 0) {\n\t\t\t\t\tdp[v][u][Q] = INF;\n\t\t\t\t\tfor(const auto &to : G[v]) {\n\t\t\t\t\t\tchmin(dp[v][u][Q], dp[to][u][A]);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// army turn\n\t\t\t\tdp[v][u][A] = 0;\n\t\t\t\tfor(const auto &to : G[u]) {\n\t\t\t\t\tchmax(dp[v][u][A], dp[v][to][Q] + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif(dp[q][a][Q] >= INF) return \"Army can catch Queen.\";\n\tif(dp[q][a][Q] >= INF / 2) return \"Queen can not escape and Army can not catch Queen.\";\n\treturn \"Queen can escape.\";\n\t\n}\n\nint main() {\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\n\tfor(int w, h; cin >> w >> h && w;) {\n\t\tvector<string> field(h);\n\t\tfor(auto &e : field) cin >> e;\n\n\t\tconst int n = w * h;\n\t\tint q, a;\n\t\tvector<int> g;\n\n\t\tgraph G(n);\n\n\t\tfor(int i = 0; i < h; ++i) {\n\t\t\tfor(int j = 0; j < w; ++j) {\n\t\t\t\tif(field[i][j] == '#') continue;\n\n\t\t\t\tconst int v = get_index(j, i, w);\n\n\t\t\t\tswitch(field[i][j]) {\n\t\t\t\tcase 'Q': q = v; break;\n\t\t\t\tcase 'A': a = v; break;\n\t\t\t\tcase 'E': g.emplace_back(v); break;\n\t\t\t\t}\n\n\t\t\t\tadd_edge(v, v, G);\n\n\t\t\t\tif(i < h - 1) {\n\t\t\t\t\tif(field[i + 1][j] != '#') {\n\t\t\t\t\t\tadd_edge(v, get_index(j, i + 1, w), G);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif(j < w - 1) {\n\t\t\t\t\tif(field[i][j + 1] != '#') {\n\t\t\t\t\t\tadd_edge(v, get_index(j + 1, i, w), G);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << solve(q, a, g, G) << endl;\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\ntypedef vector<vector<int>> Graph;\n\nvector<int> solve(const Graph&g) {\n\tvector<int>nums(g.size());\n\tGraph revg(g.size());\n\tfor (int i = 0; i < g.size();++i){\n\t\tauto es(g[i]);\n\t\tnums[i] = es.size();\n\t\tfor (auto e : es) {\n\t\t\trevg[e].push_back(i);\n\t\t}\n\n\t}\n\n\t//1 : win   0 : draw   -1 :loss\n\tvector<int>anss(g.size());\n\tqueue<int>que;\n\tfor (int i = 0; i < g.size(); ++i) {\n\t\tif (!nums[i]) {\n\t\t\tque.push(i);\n\t\t\tanss[i] = -1;\n\t\t}\n\t}\n\twhile (!que.empty()) {\n\t\tint now(que.front());\n\t\tque.pop();\n\t\tif (anss[now] == 1) {\n\t\t\tfor (auto reve : revg[now]) {\n\t\t\t\tnums[reve]--;\n\t\t\t\tif (!nums[reve]&&anss[reve]==0) {\n\t\t\t\t\tanss[reve] = -1;\n\t\t\t\t\tque.push(reve);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if (anss[now] == -1) {\n\t\t\tfor (auto reve : revg[now]) {\n\t\t\t\tif (anss[reve] == 0) {\n\t\t\t\t\tanss[reve] = 1;\n\t\t\t\t\tque.push(reve);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tassert(false);\n\t\t}\n\t}\n\treturn anss;\n}\nconst int SIZE = 30;\nint gethash(int ax, int ay, int bx, int by, int c) {\n\treturn (ax-1)* SIZE * SIZE * SIZE * 2 + (ay-1)* SIZE * SIZE * 2 + (bx-1) * SIZE * 2 + (by-1) * 2 + c+1;\n}\n\nint main() {\n\twhile (true) {\n\t\tint W, H; cin >> W >> H;\n\t\tif (!W)break;\n\t\tvector<vector<int>>field(H + 2, vector<int>(W + 2,-1));\n\t\tint sqx, sqy, sax, say;\n\t\tfor (int i = 0; i < H; ++i) {\n\t\t\tstring st; cin >> st;\n\t\t\tfor (int j = 0; j < W; ++j) {\n\t\t\t\tswitch (st[j]) {\n\t\t\t\tcase 'Q':\n\t\t\t\t\tfield[i + 1][j + 1] = 0;\n\t\t\t\t\tsqx = j + 1; sqy = i + 1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'A':\n\t\t\t\t\tfield[i + 1][j + 1] = 0;\n\t\t\t\t\tsax = j + 1; say = i + 1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '#':\n\t\t\t\t\tbreak;\n\t\t\t\tcase '.':\n\t\t\t\t\tfield[i + 1][j + 1] = 0;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'E':\n\t\t\t\t\tfield[i + 1][j + 1] = 2;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tassert(false);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tGraph g(SIZE * SIZE * SIZE*SIZE*2+1);\n\t\tint dx[] = { -1,0,1,0,0 };\n\t\tint dy[] = { 0,1,0,-1,0 };\n\t\tfor (int qx = 1; qx < W + 1; ++qx) {\n\t\t\tfor (int qy = 1; qy < H + 1; ++qy) {\n\t\t\t\tfor (int ax = 1; ax < W + 1; ++ax) {\n\t\t\t\t\tfor (int ay = 1; ay < H + 1; ++ay) {\n\t\t\t\t\t\tfor (int nt = 0; nt < 2; ++nt) {\n\t\t\t\t\t\t\tint nowhash = gethash(qx, qy, ax, ay, nt);\n\t\t\t\t\t\t\tif (qx == ax&&qy == ay) {\n\t\t\t\t\t\t\t\tif (nt) {\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\tg[nowhash].push_back(0);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (field[qy][qx] == 2&&nt) {\n\t\t\t\t\t\t\t\tg[nowhash].push_back(0);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfor (int way = 0; way < 5; ++way) {\n\t\t\t\t\t\t\t\tint nqx(qx), nqy(qy), nax(ax), nay(ay);\n\t\t\t\t\t\t\t\tif (nt) {\n\t\t\t\t\t\t\t\t\tnqx += dx[way]; nqy += dy[way];\n\t\t\t\t\t\t\t\t\tif (field[nqy][nqx]==-1) continue;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\tnax += dx[way]; nay += dy[way];\n\t\t\t\t\t\t\t\t\tif ((field[nay][nax]==-1)) continue;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (nax == nqx&&nay == nqy) {\n\t\t\t\t\t\t\t\t\tif (nt) {\n\t\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\tg[nowhash].push_back(0);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tint nexthash = gethash(nqx, nqy, nax, nay, !nt);\n\t\t\t\t\t\t\t\tg[nowhash].push_back(nexthash);\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tauto anss=solve(g);\n\t\tint ans = anss[gethash(sqx, sqy, sax, say, 1)];\n\t\tif (ans == 0)cout << \"Queen can not escape and Army can not catch Queen.\" << endl;\n\t\telse if (ans == 1)cout << \"Queen can escape.\" << endl;\n\t\telse cout << \"Army can catch Queen.\" << endl;\n\t\tg.clear();\n\t}\n\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXH = 31;\nconst int MAXW = 31;\nconst int di[] = {0,1,0,-1,0};\nconst int dj[] = {1,0,-1,0,0};\nint W, H;\nchar G[MAXH][MAXW];\nint mem[MAXH][MAXW][MAXH][MAXW][2];\n\nint main() {\n  while(cin >> W >> H && (W|H)) {\n    int sqi, sqj, sei, sej;\n    for(int i = 0; i < H; ++i) {\n      for(int j = 0; j < W; ++j) {\n        cin >> G[i][j];\n        if(G[i][j] == 'Q') {\n          sqi = i;\n          sqj = j;\n        }\n        if(G[i][j] == 'A') {\n          sei = i;\n          sej = j;\n        }\n      }\n    }\n    \n    fill(mem[0][0][0][0], mem[0][0][0][0] + sizeof(mem)/sizeof(int), 1);\n    for(int qi = 0; qi < H; ++qi) {\n      for(int qj = 0; qj < W; ++qj) {\n        for(int ei = 0; ei < H; ++ei) {\n          for(int ej = 0; ej < W; ++ej) {\n            for(int t = 0; t < 2; ++t) {\n              int &now = mem[qi][qj][ei][ej][t];\n              if(G[qi][qj] == 'E' && t == 0) now = 2;\n              if(qi == ei && qj == ej) now = 0;\n            }\n          }\n        }\n      }\n    }\n    \n    for(bool update = true; update;) {\n      update = false;\n      for(int qi = 0; qi < H; ++qi) {\n        for(int qj = 0; qj < W; ++qj) {\n          for(int ei = 0; ei < H; ++ei) {\n            for(int ej = 0; ej < W; ++ej) {\n              for(int t = 0; t < 2; ++t) {\n                int &now = mem[qi][qj][ei][ej][t];\n                if(now != 1) continue;\n                int tmp = t * 2;\n                for(int k = 0; k < 5; ++k) {\n                  int nqi =  t ? qi : qi + di[k];\n                  int nqj =  t ? qj : qj + dj[k];\n                  int nei = !t ? ei : ei + di[k];\n                  int nej = !t ? ej : ej + dj[k];\n                  if(nqi < 0 || nqi >= H) continue;\n                  if(nqj < 0 || nqj >= W) continue;\n                  if(nei < 0 || nei >= H) continue;\n                  if(nej < 0 || nej >= W) continue;\n                  if(G[nqi][nqj] == '#') continue;\n                  if(G[nei][nej] == '#') continue;\n                  if(t) tmp = min(tmp, mem[nqi][nqj][nei][nej][1-t]);\n                  else  tmp = max(tmp, mem[nqi][nqj][nei][nej][1-t]);\n                }\n                if(tmp != 1) {\n                  now = tmp;\n                  update = true;\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n    int res = mem[sqi][sqj][sei][sej][0];\n    if(res == 0) cout << \"Army can catch Queen.\" << endl;\n    else if(res == 1) cout << \"Queen can not escape and Army can not catch Queen.\" << endl;\n    else cout << \"Queen can escape.\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\nusing namespace std;\ntypedef long long LL;\nconst int MAX_T = 15 * 30;\nint dx[5] = {1, 0, -1, 0, 0};\nint dy[5] = {0, 1, 0, -1, 0};\n\nint W, H;\nstring grid[30];\nchar memo[30][30][30][30][MAX_T];\nbool valid(int x, int w) {\n    return 0 <= x && x < w;\n}\nint dfs(int x1, int y1, int x2, int y2, int t) {\n    //printf(\"%d %d %d %d %d %c %c\\n\", x1, y1, x2, y2, t, grid[y1][x1], grid[y2][x2]);\n    if(t >= MAX_T) return 2;\n    char& res = memo[y1][x1][y2][x2][t];\n    if(res != -1) return res;\n\n    if(y1 == y2 && x1 == x2) return res = 1;\n\n    int turn = t % 2;\n    if(turn == 0) {\n        if(grid[y1][x1] == 'E') return res = 0;\n\n        bool draw = false;\n        REP(r, 5) {\n            int nx = x1 + dx[r];\n            int ny = y1 + dy[r];\n            if(valid(nx, W) && valid(ny, H) && grid[ny][nx] != '#') {\n                int check = dfs(nx, ny, x2, y2, t + 1);\n                if(check == 0) {\n                    return res = 0;\n                } else if(check == 2) {\n                    draw = true;\n                }\n            }\n        }\n        return res = (draw ? 2 : 1);\n    } else {\n        bool draw = false;\n        REP(r, 5) {\n            int nx = x2 + dx[r];\n            int ny = y2 + dy[r];\n            if(valid(nx, W) && valid(ny, H) && grid[ny][nx] != '#') {\n                int check = dfs(x1, y1, nx, ny, t + 1);\n                if(check == 1) {\n                    return res = 1;\n                } else if(check == 2) {\n                    draw = true;\n                }\n            }\n        }\n        return res = (draw ? 2 : 0);\n    }\n}\n\nint main(){\n    while(cin >> W >> H && W > 0){\n        REP(y, H) cin >> grid[y];\n        int x1 = -1, y1 = -1, x2 = -1, y2 = -1;\n        REP(y, H) REP(x, W) if(grid[y][x] == 'Q') x1 = x, y1 = y;\n        REP(y, H) REP(x, W) if(grid[y][x] == 'A') x2 = x, y2 = y;\n\n        memset(memo, -1, sizeof(memo));\n        int ans = dfs(x1, y1, x2, y2, 0);\n        if(ans == 0) {\n            cout << \"Queen can escape.\" << endl;\n        } else if(ans == 1) {\n            cout << \"Army can catch Queen.\" << endl;\n        } else {\n            cout << \"Queen can not escape and Army can not catch Queen.\" << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n// created [2020/03/09] 22:05:43\n#pragma GCC diagnostic ignored \"-Wsign-compare\"\n#pragma GCC diagnostic ignored \"-Wsign-conversion\"\n\nusing i32   = int32_t;\nusing i64   = int64_t;\nusing u32   = uint32_t;\nusing u64   = uint64_t;\nusing uint  = unsigned int;\nusing usize = std::size_t;\nusing ll    = long long;\nusing ull   = unsigned long long;\nusing ld    = long double;\ntemplate<typename T, usize n>\nusing arr = T (&)[n];\ntemplate<typename T, usize n>\nusing c_arr = const T (&)[n];\ntemplate<typename T>\nusing max_heap = std::priority_queue<T>;\ntemplate<typename T>\nusing min_heap = std::priority_queue<T, std::vector<T>, std::greater<T>>;\ntemplate<typename T> constexpr T popcount(const T u) { return u ? static_cast<T>(__builtin_popcountll(static_cast<u64>(u))) : static_cast<T>(0); }\ntemplate<typename T> constexpr T log2p1(const T u) { return u ? static_cast<T>(64 - __builtin_clzll(static_cast<u64>(u))) : static_cast<T>(0); }\ntemplate<typename T> constexpr T msbp1(const T u) { return log2p1(u); }\ntemplate<typename T> constexpr T lsbp1(const T u) { return __builtin_ffsll(u); }\ntemplate<typename T> constexpr T clog(const T u) { return u ? log2p1(u - 1) : static_cast<T>(u); }\ntemplate<typename T> constexpr bool ispow2(const T u) { return u and (static_cast<u64>(u) & static_cast<u64>(u - 1)) == 0; }\ntemplate<typename T> constexpr T ceil2(const T u) { return static_cast<T>(1) << clog(u); }\ntemplate<typename T> constexpr T floor2(const T u) { return u == 0 ? static_cast<T>(0) : static_cast<T>(1) << (log2p1(u) - 1); }\ntemplate<typename T> constexpr bool btest(const T mask, const usize ind) { return static_cast<bool>((static_cast<u64>(mask) >> ind) & static_cast<u64>(1)); }\ntemplate<typename T> void bset(T& mask, const usize ind) { mask |= (static_cast<T>(1) << ind); }\ntemplate<typename T> void breset(T& mask, const usize ind) { mask &= ~(static_cast<T>(1) << ind); }\ntemplate<typename T> void bflip(T& mask, const usize ind) { mask ^= (static_cast<T>(1) << ind); }\ntemplate<typename T> void bset(T& mask, const usize ind, const bool b) { (b ? bset(mask, ind) : breset(mask, ind)); }\ntemplate<typename T> constexpr T bcut(const T mask, const usize ind) { return ind == 0 ? static_cast<T>(0) : static_cast<T>((static_cast<u64>(mask) << (64 - ind)) >> (64 - ind)); }\ntemplate<typename T> bool chmin(T& a, const T& b) { return (a > b ? a = b, true : false); }\ntemplate<typename T> bool chmax(T& a, const T& b) { return (a < b ? a = b, true : false); }\nconstexpr unsigned int mod                  = 1000000007;\ntemplate<typename T> constexpr T inf_v      = std::numeric_limits<T>::max() / 4;\ntemplate<typename Real> constexpr Real pi_v = Real{3.141592653589793238462643383279502884};\nauto mfp = [](auto&& f) { return [=](auto&&... args) { return f(f, std::forward<decltype(args)>(args)...); }; };\n\ntemplate<typename T>\nT in()\n{\n    T v;\n    return std::cin >> v, v;\n}\ntemplate<typename T, typename Uint, usize n, usize i>\nT in_v(typename std::enable_if<(i == n), c_arr<Uint, n>>::type) { return in<T>(); }\ntemplate<typename T, typename Uint, usize n, usize i>\nauto in_v(typename std::enable_if<(i < n), c_arr<Uint, n>>::type& szs)\n{\n    const usize s = (usize)szs[i];\n    std::vector<decltype(in_v<T, Uint, n, i + 1>(szs))> ans(s);\n    for (usize j = 0; j < s; j++) { ans[j] = in_v<T, Uint, n, i + 1>(szs); }\n    return ans;\n}\ntemplate<typename T, typename Uint, usize n>\nauto in_v(c_arr<Uint, n> szs) { return in_v<T, Uint, n, 0>(szs); }\ntemplate<typename... Types>\nauto in_t() { return std::tuple<std::decay_t<Types>...>{in<Types>()...}; }\nstruct io_init\n{\n    io_init()\n    {\n        std::cin.tie(nullptr), std::ios::sync_with_stdio(false);\n        std::cout << std::fixed << std::setprecision(20);\n    }\n    void clear()\n    {\n        std::cin.tie(), std::ios::sync_with_stdio(true);\n    }\n} io_setting;\n\nint out() { return 0; }\ntemplate<typename T>\nint out(const T& v) { return std::cout << v, 0; }\ntemplate<typename T>\nint out(const std::vector<T>& v)\n{\n    for (usize i = 0; i < v.size(); i++) {\n        if (i > 0) { std::cout << ' '; }\n        out(v[i]);\n    }\n    return 0;\n}\ntemplate<typename T1, typename T2>\nint out(const std::pair<T1, T2>& v) { return out(v.first), std::cout << ' ', out(v.second), 0; }\ntemplate<typename T, typename... Args>\nint out(const T& v, const Args... args) { return out(v), std::cout << ' ', out(args...), 0; }\ntemplate<typename... Args>\nint outln(const Args... args) { return out(args...), std::cout << '\\n', 0; }\ntemplate<typename... Args>\nint outel(const Args... args) { return out(args...), std::cout << std::endl, 0; }\n#    define SHOW(...) static_cast<void>(0)\nconstexpr ull TEN(const usize n) { return n == 0 ? 1ULL : TEN(n - 1) * 10ULL; }\n\ntemplate<typename T, typename Uint, usize n, usize i>\nauto make_v(typename std::enable_if<(i == n), c_arr<Uint, n>>::type, const T& v = T{}) { return v; }\ntemplate<typename T, typename Uint, usize n, usize i>\nauto make_v(typename std::enable_if<(i < n), c_arr<Uint, n>>::type szs, const T& v = T{})\n{\n    const usize s = (usize)szs[i];\n    return std::vector<decltype(make_v<T, Uint, n, i + 1>(szs, v))>(s, make_v<T, Uint, n, i + 1>(szs, v));\n}\ntemplate<typename T, typename Uint, usize n>\nauto make_v(c_arr<Uint, n> szs, const T& t = T{}) { return make_v<T, Uint, n, 0>(szs, t); }\nint main()\n{\n    while (true) {\n        auto W = in<int>(), H = in<int>();\n        if (W == 0 and H == 0) { break; }\n        const auto sss = in_v<std::string>({H});\n        const int S    = H * W;\n        auto enc       = [&](const int y, const int x) { return y * W + x; };\n        const int SS   = S * S;\n        auto encenc    = [&](const int a_tern, const int qy, const int qx, const int ay, const int ax) { return a_tern * SS + enc(qy, qx) * S + enc(ay, ax); };\n        std::vector<std::vector<int>> g(2 * SS);\n        std::vector<int> odim(2 * SS, 0);\n        constexpr int dys[] = {-1, 0, 0, 1, 0};\n        constexpr int dxs[] = {0, -1, 1, 0, 0};\n        for (int a_tern = 0; a_tern < 2; a_tern++) {\n            if (a_tern == 0) {\n                for (int qy = 0; qy < H; qy++) {\n                    for (int qx = 0; qx < W; qx++) {\n                        if (sss[qy][qx] == '#') { continue; }\n                        for (int ay = 0; ay < H; ay++) {\n                            for (int ax = 0; ax < W; ax++) {\n                                if (sss[ay][ax] == '#') { continue; }\n                                if (qy == ay and qx == ax) { continue; }\n                                const int ss = encenc(a_tern, qy, qx, ay, ax);\n                                for (int qd = 0; qd < 5; qd++) {\n                                    const int dqy = dys[qd], dqx = dxs[qd];\n                                    const int nqy = qy + dqy, nqx = qx + dqx;\n                                    if (nqy < 0 or nqy >= H or nqx < 0 or nqx >= W) { continue; }\n                                    if (sss[nqy][nqx] == '#') { continue; }\n                                    const int nss = encenc(1 - a_tern, nqy, nqx, ay, ax);\n                                    g[nss].push_back(ss);\n                                    odim[ss]++;\n                                }\n                            }\n                        }\n                    }\n                }\n            } else {\n                for (int qy = 0; qy < H; qy++) {\n                    for (int qx = 0; qx < W; qx++) {\n                        if (sss[qy][qx] == '#') { continue; }\n                        for (int ay = 0; ay < H; ay++) {\n                            for (int ax = 0; ax < W; ax++) {\n                                if (sss[ay][ax] == '#') { continue; }\n                                const int ss = encenc(a_tern, qy, qx, ay, ax);\n                                for (int ad = 0; ad < 5; ad++) {\n                                    const int day = dys[ad], dax = dxs[ad];\n                                    const int nay = ay + day, nax = ax + dax;\n                                    if (nay < 0 or nay >= H or nax < 0 or nax >= W) { continue; }\n                                    if (sss[nay][nax] == '#') { continue; }\n                                    const int nss = encenc(1 - a_tern, qy, qx, nay, nax);\n                                    g[nss].push_back(ss);\n                                    odim[ss]++;\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        std::vector<int> win(SS * 2, 2);  // 0:lose, 1:win, 2:draw\n        std::queue<int> Q;\n        for (int a_tern = 0; a_tern < 2; a_tern++) {\n            for (int qy = 0; qy < H; qy++) {\n                for (int qx = 0; qx < W; qx++) {\n                    if (sss[qy][qx] == '#') { continue; }\n                    for (int ay = 0; ay < H; ay++) {\n                        for (int ax = 0; ax < W; ax++) {\n                            if (sss[ay][ax] == '#') { continue; }\n                            const int ss = encenc(a_tern, qy, qx, ay, ax);\n                            if (a_tern == 0) {\n                                if (qy == ay and qx == ax) {\n                                    win[ss] = 0;\n                                    Q.push(ss);\n                                } else if (sss[qy][qx] == 'E') {\n                                    win[ss] = 1;\n                                    Q.push(ss);\n                                }\n                            } else {\n                                if (qy == ay and qx == ax) {\n                                    win[ss] = 1;\n                                    Q.push(ss);\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        while (not Q.empty()) {\n            const int ss = Q.front();\n            Q.pop();\n            for (const int nss : g[ss]) {\n                if (win[nss] != 2) { continue; }\n                odim[nss]--;\n                if (win[ss] == 0) {\n                    win[nss] = 1;\n                    Q.push(nss);\n                } else if (win[ss] == 1) {\n                    if (odim[nss] == 0) {\n                        win[nss] = 0;\n                        Q.push(nss);\n                    }\n                }\n            }\n        }\n        int qy = -1, qx = -1, ay = -1, ax = -1;\n        for (int i = 0; i < H; i++) {\n            for (int j = 0; j < W; j++) {\n                if (sss[i][j] == 'Q') { qy = i, qx = j; }\n                if (sss[i][j] == 'A') { ay = i, ax = j; }\n            }\n        }\n        const int init_ss = encenc(false, qy, qx, ay, ax);\n        const int ans     = win[init_ss];\n        if (ans == 0) {\n            outln(\"Army can catch Queen.\");\n        } else if (ans == 1) {\n            outln(\"Queen can escape.\");\n        } else {\n            outln(\"Queen can not escape and Army can not catch Queen.\");\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define pb         push_back\n\nenum RES{DRAW=-1,WIN,LOSE};\n\nclass state{\npublic:\n  bool who;//0 queen 1 army\n  int q,a;\n};\n\n\nenum RES win[2][1000][1000];\nint need[2][1000][1000];\nvector<state> edge[2][1000][1000];\n\n\nint dx[]={0,0,1,-1,0};\nint dy[]={1,-1,0,0,0};\nchar m[30][30];\n\nbool out(int y,int x,int r,int c){\n  return y<0||x<0||y>=r||x>=c;\n}\n\nint md(int y,int x,int yy,int xx){\n  return max(y,yy)-min(y,yy)+max(x,xx)-min(x,xx);\n}\n\nvoid solve(int q,int a,int r,int c){\n  rep(i,2){\n    rep(j,r*c){\n      rep(k,r*c){\n\twin[i][j][k]=DRAW;\n\tedge[i][j][k].clear();\n\tneed[i][j][k]=0;\n      }\n    }\n  }\n  \n  rep(qi,r){\n    rep(qj,c){\n      if (m[qi][qj] == '#')continue;\n      rep(ai,r){\n\trep(aj,c){\n\t  if (m[ai][aj] == '#')continue;\n\t  rep(k,5){\n\t    int nex=qj+dx[k],ney=qi+dy[k];\n\t    if (out(ney,nex,r,c)||m[ney][nex] == '#')continue;\n\n\t    need[0][qi*c+qj][ai*c+aj]++;\n\t    edge[1][ney*c+nex][ai*c+aj].pb((state){0,qi*c+qj,ai*c+aj});\n\t  }\n\t  rep(k,5){\n\t    int nex=aj+dx[k],ney=ai+dy[k];\n\t    if (out(ney,nex,r,c)||m[ney][nex] == '#')continue;\n\t    need[1][qi*c+qj][ai*c+aj]++;\n\t    edge[0][qi*c+qj][ney*c+nex].pb((state){1,qi*c+qj,ai*c+aj});\n\t  }\n\t}\n      }\n    }\n  }\n\n  queue<state> Q;\n  //win q\n  rep(i,r){\n    rep(j,c){\n      if (m[i][j] == '#')continue;\n      rep(ii,r){\n\trep(jj,c){\n\t  if (m[ii][jj] == '#'||(ii==i&&jj==j))continue;\n\t  if (m[i][j] == 'E'){// && md(i,j,ii,jj)>1){\n\t    win[0][i*c+j][ii*c+jj]=WIN;\n\t    Q.push((state){0,i*c+j,ii*c+jj});\n\t  }\n\t  if (m[i][j] == 'E' && md(i,j,ii,jj) > 1){\n\t    win[1][i*c+j][ii*c+jj]=LOSE;\n\t    Q.push((state){1,i*c+j,ii*c+jj});\n\t  }\n\t}\n      }\n    }\n  }\n  \n\n  //win a\n  rep(i,r){\n    rep(j,c){\n      if (m[i][j] == '#')continue;\n      rep(k,4){\n\tint nex=j+dx[k],ney=i+dy[k];\n\tif (out(ney,nex,r,c)||m[ney][nex]=='#'){\n\t  continue;\n\t}\n\tif (win[1][i*c+j][ney*c+nex] == DRAW){\n\t  win[1][i*c+j][ney*c+nex]=WIN;\n\t  Q.push((state){1,i*c+j,ney*c+nex});\n\t}\n      }\n    }\n  }\n  \n\n  \n  rep(i,r){\n    rep(j,c){\n      if (m[i][j] == '#')continue;\n      if (win[0][i*c+j][i*c+j] == DRAW){\n\twin[0][i*c+j][i*c+j]=LOSE;\n\tQ.push((state){0,i*c+j,i*c+j});\n      }\n      if (win[1][i*c+j][i*c+j] == DRAW){\n\twin[1][i*c+j][i*c+j]=WIN;\n\tQ.push((state){1,i*c+j,i*c+j});\n      }\n    }\n  }\n  \n\n  while(!Q.empty()){\n    state now = Q.front();Q.pop();\n    //cout << now.who <<\" \" << now.q <<\" \" << now.a <<\" \" << win[now.who][now.q][now.a] << endl;\n    \n    rep(i,edge[now.who][now.q][now.a].size()){\n      state next=edge[now.who][now.q][now.a][i];\n      need[next.who][next.q][next.a]--;\n      //      if (next.who == 0 &&next.q == 0 && next.a == 1)\n      //\tcout <<now.who <<\" \" <<  now.q <<\" \" << now.a << endl;\n\n      if (win[next.who][next.q][next.a] != DRAW)continue;\n      if (win[now.who][now.q][now.a] == LOSE){\n\twin[next.who][next.q][next.a]=WIN;\n\tQ.push(next);\n      }else if (need[next.who][next.q][next.a] == 0 && \n\t\twin[next.who][next.q][next.a]  == DRAW){\n\twin[next.who][next.q][next.a]=LOSE;\n\tQ.push(next);\n      }\n    }\n  }\n\n  //  cout << need[0][q][a]<<endl;\n  if (win[0][q][a] == LOSE)cout << \"Army can catch Queen.\" << endl;\n  else if (win[0][q][a] == WIN)cout << \"Queen can escape.\" << endl;\n  else cout << \"Queen can not escape and Army can not catch Queen.\"<<endl;\n  return;\n}\n\n\nmain(){\n  int r,c;\n  while(cin>>c>>r && c){\n    rep(i,r){\n      rep(j,c)cin>>m[i][j];\n    }\n    int q,a;\n    rep(i,r){\n      rep(j,c){\n\tif (m[i][j] == 'Q')q=i*c+j;\n\tif (m[i][j] == 'A')a=i*c+j;\n      }\n    }\n    solve(q,a,r,c);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\ntypedef vector<vector<int>> Graph;\n\nvector<int> solve(const Graph&g) {\n\tvector<int>nums(g.size());\n\tmap<int, vector<int>> revg;\n\tfor (int i = 0; i < g.size();++i){\n\t\tauto es(g[i]);\n\t\tnums[i] = es.size();\n\t\tfor (auto e : es) {\n\t\t\trevg[e].push_back(i);\n\t\t}\n\n\t}\n\n\t//1 : win   0 : draw   -1 :loss\n\tvector<int>anss(g.size());\n\tqueue<int>que;\n\tfor (int i = 0; i < g.size(); ++i) {\n\t\tif (!nums[i]) {\n\t\t\tque.push(i);\n\t\t\tanss[i] = -1;\n\t\t}\n\t}\n\twhile (!que.empty()) {\n\t\tint now(que.front());\n\t\tque.pop();\n\t\tif (anss[now] == 1) {\n\t\t\tfor (auto reve : revg[now]) {\n\t\t\t\tnums[reve]--;\n\t\t\t\tif (!nums[reve]&&anss[reve]==0) {\n\t\t\t\t\tanss[reve] = -1;\n\t\t\t\t\tque.push(reve);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if (anss[now] == -1) {\n\t\t\tif (revg.find(now)!=revg.end()) {\n\t\t\t\tfor (auto reve : revg[now]) {\n\t\t\t\t\tif (anss[reve] == 0) {\n\t\t\t\t\t\tanss[reve] = 1;\n\t\t\t\t\t\tque.push(reve);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t}\n\t\telse {\n\t\t\tassert(false);\n\t\t}\n\t}\n\treturn anss;\n}\nint SIZE = 30;\nint gethash(int ax, int ay, int bx, int by, int c) {\n\treturn (ax-1)* SIZE * SIZE * SIZE * 2 + (ay-1)* SIZE * SIZE * 2 + (bx-1) * SIZE * 2 + (by-1) * 2 + c+1;\n}\n\nint main() {\n\twhile (true) {\n\t\tint W, H; cin >> W >> H;\n\t\tif (!W)break;\n\t\tvector<vector<int>>field(H + 2, vector<int>(W + 2,-1));\n\t\tint sqx, sqy, sax, say;\n\t\tfor (int i = 0; i < H; ++i) {\n\t\t\tstring st; cin >> st;\n\t\t\tfor (int j = 0; j < W; ++j) {\n\t\t\t\tswitch (st[j]) {\n\t\t\t\tcase 'Q':\n\t\t\t\t\tfield[i + 1][j + 1] = 0;\n\t\t\t\t\tsqx = j + 1; sqy = i + 1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'A':\n\t\t\t\t\tfield[i + 1][j + 1] = 0;\n\t\t\t\t\tsax = j + 1; say = i + 1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '#':\n\t\t\t\t\tbreak;\n\t\t\t\tcase '.':\n\t\t\t\t\tfield[i + 1][j + 1] = 0;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'E':\n\t\t\t\t\tfield[i + 1][j + 1] = 2;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tassert(false);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSIZE = max(H, W);\n\t\tGraph g(SIZE * SIZE * SIZE*SIZE*2+1);\n\t\tint dx[] = { -1,0,1,0,0 };\n\t\tint dy[] = { 0,1,0,-1,0 };\n\t\tfor (int qx = 1; qx < W + 1; ++qx) {\n\t\t\tfor (int qy = 1; qy < H + 1; ++qy) {\n\t\t\t\tif (field[qy][qx] == -1)continue;\n\t\t\t\tfor (int ax = 1; ax < W + 1; ++ax) {\n\t\t\t\t\tfor (int ay = 1; ay < H + 1; ++ay) {\n\t\t\t\t\t\tif (field[ay][ax] == -1)continue;\n\t\t\t\t\t\tfor (int nt = 0; nt < 2; ++nt) {\n\t\t\t\t\t\t\tint nowhash = gethash(qx, qy, ax, ay, nt);\n\t\t\t\t\t\t\tif (qx == ax&&qy == ay) {\n\t\t\t\t\t\t\t\tif (nt) {\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\tg[nowhash].push_back(0);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (field[qy][qx] == 2&&nt) {\n\t\t\t\t\t\t\t\tg[nowhash].push_back(0);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfor (int way = 0; way < 5; ++way) {\n\t\t\t\t\t\t\t\tint nqx(qx), nqy(qy), nax(ax), nay(ay);\n\t\t\t\t\t\t\t\tif (nt) {\n\t\t\t\t\t\t\t\t\tnqx += dx[way]; nqy += dy[way];\n\t\t\t\t\t\t\t\t\tif (field[nqy][nqx]==-1) continue;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\tnax += dx[way]; nay += dy[way];\n\t\t\t\t\t\t\t\t\tif ((field[nay][nax]==-1)) continue;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (nax == nqx&&nay == nqy) {\n\t\t\t\t\t\t\t\t\tif (nt) {\n\t\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\tg[nowhash].push_back(0);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tint nexthash = gethash(nqx, nqy, nax, nay, !nt);\n\t\t\t\t\t\t\t\tg[nowhash].push_back(nexthash);\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tauto anss=solve(g);\n\t\tint ans = anss[gethash(sqx, sqy, sax, say, 1)];\n\t\tif (ans == 0)cout << \"Queen can not escape and Army can not catch Queen.\" << endl;\n\t\telse if (ans == 1)cout << \"Queen can escape.\" << endl;\n\t\telse cout << \"Army can catch Queen.\" << endl;\n\t}\n\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (int)(k); i < (int)(n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\nconst int dx[] = { -1, 0, 0, 1 }, dy[] = { 0, -1, 1, 0 };\n//[const int dx[] = { -1, -1, -1, 0, 0, 1, 1, 1 }, dy[] = { 0, -1, 1, -1, 1, 0, -1, 1 };\nbool valid(int x, int y, int h, int w) { return (x >= 0 && y >= 0 && x < h&&y < w); }\nint place(int x, int y, int w) { return w*x + y; }\n\nint dp[2][33][33][33][33]; //turn, x_queen, y_queen, x_army, y_army\nint h, w;\nvs fld;\n\ntypedef tuple<int, int, int, int, int> state;\n\nvoid init()\n{\n\tfld.clear(); fld.resize(h);\n\tMS(dp, 0);\n}\n\nint main()\n{\n\tcin.sync_with_stdio(false); cout << fixed << setprecision(10);\n\twhile (cin >> w >> h, h)\n\t{\n\t\tinit();\n\t\tREP(i, h) cin >> fld[i];\n\t\tpii army, queen;\n\t\tset<pii> exit;\n\t\tREP(i, h)REP(j, w)\n\t\t{\n\t\t\tif (fld[i][j] == '#') continue;\n\t\t\tif (fld[i][j] == 'Q') queen = pii(i, j);\n\t\t\tif (fld[i][j] == 'A') army = pii(i, j);\n\t\t\tif (fld[i][j] == 'E') exit.emplace(i, j);\n\t\t\tfld[i][j] = '.';\n\t\t}\n\t\tvector<state> updates;\n\t\tfor (auto i : exit)REP(ax, h)REP(ay, w)\n\t\t{\n\t\t\tint qx = i.first, qy = i.second;\n\t\t\tdp[0][qx][qy][ax][ay] = 1;\n\t\t\tupdates.push_back(state(0, qx, qy, ax, ay));\n\t\t}\n\t\tREP(i, h)REP(j, w)\n\t\t{\n\t\t\tif (fld[i][j] == '#') continue;\n\t\t\tdp[0][i][j][i][j] = -1;\n\t\t\tupdates.push_back(state(0, i, j, i, j));\n\t\t}\n\t\tREP(i, 2)REP(qx, h)REP(qy, w)REP(ax, h)REP(ay, w) updates.push_back(state(i, qx, qy, ax, ay));\n\t\twhile (!updates.empty())\n\t\t{\n\t\t\tvector<state> nexts;\n\t\t\tfor (auto tmp : updates)\n\t\t\t//REP(i, 2)REP(qx, h)REP(qy, w)REP(ax, h)REP(ay, w)\n\t\t\t{\n\t\t\t\tint i, qx, qy, ax, ay;\n\t\t\t\ttie(i, qx, qy, ax, ay) = tmp;\n\t\t\t\tif (!valid(qx, qy, h, w) || !valid(ax, ay, h, w) || dp[i][qx][qy][ax][ay] != 0) continue;\n\t\t\t\tif (i == 0)\n\t\t\t\t{\n\t\t\t\t\tset<int> st;\n\t\t\t\t\tst.insert(dp[1][qx][qy][ax][ay]);\n\t\t\t\t\tREP(j, 4)\n\t\t\t\t\t{\n\t\t\t\t\t\tint nx = qx + dx[j], ny = qy + dy[j];\n\t\t\t\t\t\tif (!valid(nx, ny, h, w) || fld[nx][ny] == '#') continue;\n\t\t\t\t\t\tst.insert(dp[1][nx][ny][ax][ay]);\n\t\t\t\t\t}\n\t\t\t\t\tif (st.size() == 1 && *st.begin() == -1)\n\t\t\t\t\t{\n\t\t\t\t\t\tdp[i][qx][qy][ax][ay] = -1;\n\t\t\t\t\t}\n\t\t\t\t\telse if (st.count(1))\n\t\t\t\t\t{\n\t\t\t\t\t\tdp[i][qx][qy][ax][ay] = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tset<int> st;\n\t\t\t\t\tst.insert(dp[0][qx][qy][ax][ay]);\n\t\t\t\t\tREP(j, 4)\n\t\t\t\t\t{\n\t\t\t\t\t\tint nx = ax + dx[j], ny = ay + dy[j];\n\t\t\t\t\t\tif (!valid(nx, ny, h, w) || fld[nx][ny] == '#') continue;\n\t\t\t\t\t\tst.insert(dp[0][qx][qy][nx][ny]);\n\t\t\t\t\t}\n\t\t\t\t\tif (st.size() == 1 && *st.begin() == 1)\n\t\t\t\t\t{\n\t\t\t\t\t\tdp[i][qx][qy][ax][ay] = 1;\n\t\t\t\t\t}\n\t\t\t\t\telse if (st.count(-1))\n\t\t\t\t\t{\n\t\t\t\t\t\tdp[i][qx][qy][ax][ay] = -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (dp[i][qx][qy][ax][ay] != 0)\n\t\t\t\t{\n\t\t\t\t\tif (dp[1 - i][qx][qy][ax][ay] == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tnexts.push_back(state(1 - i, qx, qy, ax, ay));\n\t\t\t\t\t}\n\t\t\t\t\tREP(i, 2)REP(j, 4)REP(k, 4)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (!valid(qx + dx[j], qy + dy[j], h, w) || !valid(ax + dx[k], ay + dy[k], h, w) || dp[i][qx + dx[j]][qy + dy[j]][ax + dx[k]][ay + dy[k]] != 0) continue;\n\t\t\t\t\t\tnexts.push_back(state(i, qx + dx[j], qy + dy[j], ax + dx[k], ay + dy[k]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tsort(ALL(updates));\n\t\t\tupdates.erase(unique(ALL(updates)), updates.end());\n\t\t\tupdates = nexts;\n\t\t}\n\t\t\n\n\t\tint ans = dp[0][queen.first][queen.second][army.first][army.second];\n\t\tif (ans == 1) cout << \"Queen can escape.\" << endl;\n\t\telse if (ans == 0) cout << \"Queen can not escape and Army can not catch Queen.\" << endl;\n\t\telse cout << \"Army can catch Queen.\" << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (int)(k); i < (int)(n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\nconst int dx[] = { -1, 0, 0, 1 }, dy[] = { 0, -1, 1, 0 };\n//[const int dx[] = { -1, -1, -1, 0, 0, 1, 1, 1 }, dy[] = { 0, -1, 1, -1, 1, 0, -1, 1 };\nbool valid(int x, int y, int h, int w) { return (x >= 0 && y >= 0 && x < h&&y < w); }\nint place(int x, int y, int w) { return w*x + y; }\n\nint dp[2][33][33][33][33]; //turn, x_queen, y_queen, x_army, y_army\nint h, w;\nvs fld;\n\ntypedef tuple<int, int, int, int, int> state;\n\nvoid init()\n{\n\tfld.clear(); fld.resize(h);\n\tMS(dp, 0);\n}\n\nint main()\n{\n\tcin.sync_with_stdio(false); cout << fixed << setprecision(10);\n\twhile (cin >> w >> h, h)\n\t{\n\t\tinit();\n\t\tREP(i, h) cin >> fld[i];\n\t\tpii army, queen;\n\t\tset<pii> exit;\n\t\tREP(i, h)REP(j, w)\n\t\t{\n\t\t\tif (fld[i][j] == '#') continue;\n\t\t\tif (fld[i][j] == 'Q') queen = pii(i, j);\n\t\t\tif (fld[i][j] == 'A') army = pii(i, j);\n\t\t\tif (fld[i][j] == 'E') exit.emplace(i, j);\n\t\t\tfld[i][j] = '.';\n\t\t}\n\t\tvector<state> updates;\n\t\tfor (auto i : exit)REP(ax, h)REP(ay, w)\n\t\t{\n\t\t\tint qx = i.first, qy = i.second;\n\t\t\tdp[0][qx][qy][ax][ay] = 1;\n\t\t\tupdates.push_back(state(0, qx, qy, ax, ay));\n\t\t}\n\t\tREP(i, h)REP(j, w)\n\t\t{\n\t\t\tif (fld[i][j] == '#') continue;\n\t\t\tdp[0][i][j][i][j] = -1;\n\t\t\tupdates.push_back(state(0, i, j, i, j));\n\t\t}\n\t\tREP(i, 2)REP(qx, h)REP(qy, w)REP(ax, h)REP(ay, w) updates.push_back(state(i, qx, qy, ax, ay));\n\t\twhile (!updates.empty())\n\t\t{\n\t\t\tvector<state> nexts;\n\t\t\tfor (auto tmp : updates)\n\t\t\t//REP(i, 2)REP(qx, h)REP(qy, w)REP(ax, h)REP(ay, w)\n\t\t\t{\n\t\t\t\tint i, qx, qy, ax, ay;\n\t\t\t\ttie(i, qx, qy, ax, ay) = tmp;\n\t\t\t\tif (!valid(qx, qy, h, w) || !valid(ax, ay, h, w) || dp[i][qx][qy][ax][ay] != 0) continue;\n\t\t\t\tif (i == 0)\n\t\t\t\t{\n\t\t\t\t\tset<int> st;\n\t\t\t\t\tst.insert(dp[1][qx][qy][ax][ay]);\n\t\t\t\t\tREP(j, 4)\n\t\t\t\t\t{\n\t\t\t\t\t\tint nx = qx + dx[j], ny = qy + dy[j];\n\t\t\t\t\t\tif (!valid(nx, ny, h, w) || fld[nx][ny] == '#') continue;\n\t\t\t\t\t\tst.insert(dp[1][nx][ny][ax][ay]);\n\t\t\t\t\t}\n\t\t\t\t\tif (st.size() == 1 && *st.begin() == -1)\n\t\t\t\t\t{\n\t\t\t\t\t\tdp[i][qx][qy][ax][ay] = -1;\n\t\t\t\t\t}\n\t\t\t\t\telse if (st.count(1))\n\t\t\t\t\t{\n\t\t\t\t\t\tdp[i][qx][qy][ax][ay] = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tset<int> st;\n\t\t\t\t\tst.insert(dp[0][qx][qy][ax][ay]);\n\t\t\t\t\tREP(j, 4)\n\t\t\t\t\t{\n\t\t\t\t\t\tint nx = ax + dx[j], ny = ay + dy[j];\n\t\t\t\t\t\tif (!valid(nx, ny, h, w) || fld[nx][ny] == '#') continue;\n\t\t\t\t\t\tst.insert(dp[0][qx][qy][nx][ny]);\n\t\t\t\t\t}\n\t\t\t\t\tif (st.size() == 1 && *st.begin() == 1)\n\t\t\t\t\t{\n\t\t\t\t\t\tdp[i][qx][qy][ax][ay] = 1;\n\t\t\t\t\t}\n\t\t\t\t\telse if (st.count(-1))\n\t\t\t\t\t{\n\t\t\t\t\t\tdp[i][qx][qy][ax][ay] = -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (dp[i][qx][qy][ax][ay] != 0)\n\t\t\t\t{\n\t\t\t\t\tif (dp[1 - i][qx][qy][ax][ay] == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tnexts.push_back(state(1 - i, qx, qy, ax, ay));\n\t\t\t\t\t}\n\t\t\t\t\tREP(i, 2)REP(j, 4)REP(k, 4)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (!valid(qx, qy, h, w) || !valid(ax, ay, h, w) || dp[i][qx][qy][ax][ay] != 0) continue;\n\t\t\t\t\t\tnexts.push_back(state(i, qx + dx[j], qy + dy[j], ax + dx[k], ay + dy[k]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tsort(ALL(updates));\n\t\t\tupdates.erase(unique(ALL(updates)), updates.end());\n\t\t\tupdates = nexts;\n\t\t}\n\t\t\n\n\t\tint ans = dp[0][queen.first][queen.second][army.first][army.second];\n\t\tif (ans == 1) cout << \"Queen can escape.\" << endl;\n\t\telse if (ans == 0) cout << \"Queen can not escape and Army can not catch Queen.\" << endl;\n\t\telse cout << \"Army can catch Queen.\" << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 1000000007LL\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<P,P> PP;\n\nclass graph_bridge{\npublic:\n\tstatic const int MAX=905;\n\tvector<int> G[MAX];\n\tbool visited[MAX];\n\tint prenum[MAX],parent[MAX],lowest[MAX],timer;\n\tset<P> bridge;\n\tint cmp[MAX];\n\n\tvoid dfs(int v,int prev){\n\t\tprenum[v]=lowest[v]=timer;\n\t\ttimer++;\n\t\tvisited[v]=true;\n\t\tint next;\n\t\tfor(int i=0;i<G[v].size();i++){\n\t\t\tnext=G[v][i];\n\t\t\tif(!visited[next]){\n\t\t\t\tparent[next]=v;\n\t\t\t\tdfs(next,v);\n\t\t\t\tlowest[v]=min(lowest[v],lowest[next]);\n\t\t\t\tif(prenum[v]<lowest[G[v][i]])bridge.insert(P(min(v,G[v][i]),max(v,G[v][i])));\n\t\t\t}else if(next!=prev){\n\t\t\t\tlowest[v]=min(lowest[v],prenum[next]);\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid dfs2(int v,int k){\n\t\tcmp[v]=k;\n\t\tfor(int i=0;i<G[v].size();i++){\n\t\t\tint nv=G[v][i];\n\t\t\tif(cmp[nv]>=0)continue;\n\t\t\tif(bridge.find(P(min(v,nv),max(v,nv)))==bridge.end()){\n\t\t\t\tdfs2(nv,k);\n\t\t\t}\n\t\t}\n\t}\n\n\tint construct_TwoEdgeConnectedComponent(int N){\n\t\tfor(int i=0;i<N;i++){\n\t\t\tvisited[i]=false;\n\t\t}\n\t\ttimer=1;\n\t\tbridge.clear();\n\t\tfor(int i=0;i<N;i++){\n\t\t\tif(!visited[i]){\n\t\t\t\tdfs(i,-1);\n\t\t\t}\n\t\t}\n\t\tmemset(cmp,-1,sizeof(cmp));\n\t\tint k=0;\n\t\tfor(int i=0;i<N;i++){\n\t\t\tif(cmp[i]==-1){\n\t\t\t\tdfs2(i,k);\n\t\t\t\tk++;\n\t\t\t}\n\t\t}\n\t\treturn k;\n\t}\n};\n\ngraph_bridge b;\n\nint w,h;\nint fie[31][31];\nbool flag[31][31][31][31];\nint dx[5]={0,1,0,-1,0};\nint dy[5]={1,0,-1,0,0};\nint dist[2][31][31];\nint cnt[905];\nP q,a;\n\nvoid bfs(){\n\tmemset(dist,-1,sizeof(dist));\n\tfor(int i=0;i<2;i++){\n\t\tqueue<P> que;\n\t\tif(i==0){\n\t\t\tque.push(q);\n\t\t\tdist[i][q.first][q.second]=0;\n\t\t}else{\n\t\t\tque.push(a);\n\t\t\tdist[i][a.first][a.second]=0;\n\t\t}\n\t\twhile(que.size()){\n\t\t\tP p=que.front();\n\t\t\tque.pop();\n\t\t\tfor(int j=0;j<4;j++){\n\t\t\t\tint nx=p.second+dx[j];\n\t\t\t\tint ny=p.first+dy[j];\n\t\t\t\tif(nx<0 || ny<0 || nx>=w || ny>=h)continue;\n\t\t\t\tif(fie[ny][nx]==-1)continue;\n\t\t\t\tif(dist[i][ny][nx]==-1){\n\t\t\t\t\tdist[i][ny][nx]=dist[i][p.first][p.second]+1;\n\t\t\t\t\tque.push(P(ny,nx));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid solve(){\n\tmemset(fie,0,sizeof(fie));\n\tmemset(flag,false,sizeof(flag));\n\tmemset(cnt,0,sizeof(cnt));\n\tfor(int i=0;i<h;i++){\n\t\tstring str;\n\t\tcin >> str;\n\t\tfor(int j=0;j<w;j++){\n\t\t\tif(str[j]=='#'){\n\t\t\t\tfie[i][j]=-1;\n\t\t\t}\n\t\t\tif(str[j]=='E'){\n\t\t\t\tfie[i][j]=1;\n\t\t\t}\n\t\t\tif(str[j]=='Q'){\n\t\t\t\tq=P(i,j);\n\t\t\t}\n\t\t\tif(str[j]=='A'){\n\t\t\t\ta=P(i,j);\n\t\t\t}\n\t\t}\n\t}\n\tqueue<PP> que;\n\tfor(int i=0;i<h;i++){\n\t\tfor(int j=0;j<w;j++){\n\t\t\tif(fie[i][j]==1){\n\t\t\t\tfor(int k=0;k<h;k++){\n\t\t\t\t\tfor(int l=0;l<w;l++){\n\t\t\t\t\t\tif(k==i && l==j)continue;\n\t\t\t\t\t\tif(fie[k][l]==-1)continue;\n\t\t\t\t\t\tflag[i][j][k][l]=true;\n\t\t\t\t\t\tque.push(PP(P(i,j),P(k,l)));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\twhile(que.size()){\n\t\tPP p=que.front();\n\t\tque.pop();\n\t\tP pq=p.first,pa=p.second;\n\t\t//printf(\"%d %d %d %d\\n\",pq.second,pq.first,pa.second,pa.first);\n\t\tfor(int i=0;i<4;i++){\n\t\t\tint nx=pq.second+dx[i];\n\t\t\tint ny=pq.first+dy[i];\n\t\t\t//printf(\"%d %d\\n\",nx,ny);\n\t\t\tif(nx<0 || ny<0 || nx>=w || ny>=h)continue;\n\t\t\tif(fie[ny][nx]==-1)continue;\n\t\t\tfor(int j=0;j<5;j++){\n\t\t\t\tint n2x=pa.second+dx[j];\n\t\t\t\tint n2y=pa.first+dy[j];\n\t\t\t\t//printf(\"n2x %d %d\\n\",n2x,n2y);\n\t\t\t\tif(n2x<0 || n2y<0 || n2x>=w || n2y>=h)continue;\n\t\t\t\tif(fie[n2y][n2x]==-1)continue;\n\t\t\t\tif(nx==n2x && ny==n2y)continue;\n\t\t\t\tif(flag[ny][nx][n2y][n2x])continue;\n\t\t\t\tbool fo=true;\n\t\t\t\tfor(int k=0;k<5;k++){\n\t\t\t\t\tint n3x=n2x+dx[k];\n\t\t\t\t\tint n3y=n2y+dy[k];\n\t\t\t\t\t//printf(\"check %d %d\\n\",n3x,n3y);\n\t\t\t\t\tif(n3x<0 || n3y<0 || n3x>=w || n3y>=h)continue;\n\t\t\t\t\tif(fie[n3y][n3x]==-1)continue;\n\t\t\t\t\tif(!flag[pq.first][pq.second][n3y][n3x])fo=false;\n\t\t\t\t}\n\t\t\t\tif(fo){\n\t\t\t\t\t//printf(\"ok %d %d %d %d\\n\",nx,ny,n2x,n2y);\n\t\t\t\t\tflag[ny][nx][n2y][n2x]=true;\n\t\t\t\t\tque.push(PP(P(ny,nx),P(n2y,n2x)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif(flag[q.first][q.second][a.first][a.second]){\n\t\tprintf(\"Queen can escape.\\n\");\n\t\treturn;\n\t}\n\tbfs();\n\tfor(int i=0;i<h*w;i++){\n\t\tb.G[i].clear();\n\t}\n\tfor(int i=0;i<h;i++){\n\t\tfor(int j=0;j<w;j++){\n\t\t\tif(fie[i][j]>=0){\n\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\tint nx=j+dx[k];\n\t\t\t\t\tint ny=i+dy[k];\n\t\t\t\t\tif(nx<0 || nx>=w || ny<0 || ny>=h)continue;\n\t\t\t\t\tif(fie[ny][nx]==-1)continue;\n\t\t\t\t\tb.G[i*w+j].push_back(ny*w+nx);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint sz=b.construct_TwoEdgeConnectedComponent(h*w);\n\tfor(int i=0;i<h*w;i++){\n\t\tcnt[b.cmp[i]]++;\n\t}\n\tbool draw=false;\n\tfor(int i=0;i<h;i++){\n\t\tfor(int j=0;j<w;j++){\n\t\t\t//printf(\"%d %d %d\\n\",i,j,cnt[b.cmp[i*w+j]]);\n\t\t\tif(cnt[b.cmp[i*w+j]]>1 && dist[0][i][j]>=0 && (dist[0][i][j]<dist[1][i][j] || dist[1][i][j]==-1)){\n\t\t\t\tdraw=true;\n\t\t\t}\n\t\t}\n\t}\n\tif(dist[1][q.first][q.second]==-1)draw=true;\n\tprintf(\"%s\\n\",draw?\"Queen can not escape and Army can not catch Queen.\":\"Army can catch Queen.\");\n\treturn;\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d%d\",&w,&h);\n\t\tif(w==0 && h==0)break;\n\t\tsolve();\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\nInt dp[2][33][33][33][33];\nInt cnt[2][33][33][33][33];\nsigned main(){  \n  cin.tie(0);\n  ios::sync_with_stdio(0);\n  Int w,h;\n  while(cin>>w>>h,w){\n    vector<string> s(h);\n    for(Int i=0;i<h;i++) cin>>s[i];\n    memset(dp,-1,sizeof(dp));\n    memset(cnt,0,sizeof(cnt));\n    {\n      using T = tuple<Int, Int, Int, Int, Int>;\n      queue<T> q;\n      Int dy[]={0,0,1,-1,0};\n      Int dx[]={1,-1,0,0,0};\n      auto in=[&](Int y,Int x){\n\treturn 0<=y&&y<h&&0<=x&&x<w;\n      };\n      \n      for(Int qy=0;qy<h;qy++){\n\tfor(Int qx=0;qx<w;qx++){\n\t  if(s[qy][qx]=='#') continue;\n\t  for(Int ay=0;ay<h;ay++){\n\t    for(Int ax=0;ax<w;ax++){\n\t      if(s[ay][ax]=='#') continue;\n\t      // t == 0\t      \n\t      {\t\t\n\t\tif(s[qy][qx]=='E'&&!(qy==ay&&qx==ax)){\n\t\t  dp[0][qy][qx][ay][ax]=1;\n\t\t  q.emplace(0,qy,qx,ay,ax);\n\t\t}\n\t\tfor(Int k=0;k<5;k++){\n\t\t  Int ny=qy+dy[k],nx=qx+dx[k];\n\t\t  if(!in(ny,nx)||s[ny][nx]=='#') continue;\n\t\t  cnt[0][qy][qx][ay][ax]++;\n\t\t}\n\t      }\n\t      // t == 1\n\t      {\n\t\tfor(Int k=0;k<5;k++){\n\t\t  Int ny=ay+dy[k],nx=ax+dx[k];\n\t\t  if(!in(ny,nx)||s[ny][nx]=='#') continue;\n\t\t  if(ny==qy&&nx==qx){\t\t    \n\t\t    dp[1][qy][qx][ay][ax]=1;\n\t\t    q.emplace(1,qy,qx,ay,ax);\t\t  \n\t\t  }\n\t\t  cnt[1][qy][qx][ay][ax]++;\n\t\t}\n\t      }\n\t    }\n\t  }\t\n\t}\n      }\n      //cout<<cnt[0][0][0][0][1]<<endl;\n      const Int DBG = 0;\n      \n      while(!q.empty()){\n\tInt t,qy,qx,ay,ax;\n\ttie(t,qy,qx,ay,ax)=q.front();q.pop();\n\tInt d=dp[t][qy][qx][ay][ax];\n\tif(DBG) cout<<t<<\":\"<<qy<<\" \"<<qx<<\" \"<<ay<<\" \"<<ax<<\":\"<<d<<endl;\n\t\n\tif(t){\n\t  for(Int k=0;k<5;k++){\n\t    Int ny=qy+dy[k],nx=qx+dx[k];\n\t    if(!in(ny,nx)||s[ny][nx]=='#') continue;\n\t    if(~dp[!t][ny][nx][ay][ax]) continue;\n\t    cnt[!t][ny][nx][ay][ax]--;\n\t    if(!d||cnt[!t][ny][nx][ay][ax]==0){\n\t      if(DBG) cout<<\"->\"<<!t<<\" \"<<ny<<\" \"<<nx<<\" \"<<ay<<\" \"<<ax<<\":\"<<!d<<endl;\n\t      dp[!t][ny][nx][ay][ax]=!d;\n\t      q.emplace(!t,ny,nx,ay,ax);\n\t    }\n\t  }\n\t}else{\n\t  for(Int k=0;k<5;k++){\n\t    Int ny=ay+dy[k],nx=ax+dx[k];\n\t    if(!in(ny,nx)||s[ny][nx]=='#') continue;\n\t    if(~dp[!t][qy][qx][ny][nx]) continue;\n\t    cnt[!t][qy][qx][ny][nx]--;\n\t    if(!d||cnt[!t][qy][qx][ny][nx]==0){\n\t      if(DBG) cout<<\"->\"<<!t<<\" \"<<qy<<\" \"<<qx<<\" \"<<ny<<\" \"<<nx<<\":\"<<!d<<endl;\n\t      dp[!t][qy][qx][ny][nx]=!d;\n\t      q.emplace(!t,qy,qx,ny,nx);\n\t    }\n\t  }\n\t}\n      }\n      \n    }\n    \n    \n    {\n      Int qx,qy,ax,ay;\n      for(Int i=0;i<h;i++){\n\tfor(Int j=0;j<w;j++){\n\t  if(s[i][j]=='Q') qy=i,qx=j;\n\t  if(s[i][j]=='A') ay=i,ax=j;\n\t}\n      }\n      if(dp[0][qy][qx][ay][ax]==1)\n\tcout<<\"Queen can escape.\"<<endl;\n      if(dp[0][qy][qx][ay][ax]==0)\n\tcout<<\"Army can catch Queen.\"<<endl;\n      if(dp[0][qy][qx][ay][ax]==-1)\n\tcout<<\"Queen can not escape and Army can not catch Queen.\"<<endl;\n    }\n  }\n  \n  return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (int)(k); i < (int)(n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\nconst int dx[] = { -1, 0, 0, 1 }, dy[] = { 0, -1, 1, 0 };\n//[const int dx[] = { -1, -1, -1, 0, 0, 1, 1, 1 }, dy[] = { 0, -1, 1, -1, 1, 0, -1, 1 };\nbool valid(int x, int y, int h, int w) { return (x >= 0 && y >= 0 && x < h&&y < w); }\nint place(int x, int y, int w) { return w*x + y; }\n\nint dp[2][33][33][33][33]; //turn, x_queen, y_queen, x_army, y_army\nint h, w;\nvs fld;\n\nstruct state\n{\n\tint turn, qx, qy, ax, ay;\n\tstate(int a, int b, int c, int d, int e) :turn(a), qx(b), qy(c), ax(d), ay(e) {};\n};\n\nvoid init()\n{\n\tfld.clear(); fld.resize(h);\n\tMS(dp, 0);\n}\n\nint main()\n{\n\tcin.sync_with_stdio(false); cout << fixed << setprecision(10);\n\twhile (cin >> w >> h, h)\n\t{\n\t\tinit();\n\t\tREP(i, h) cin >> fld[i];\n\t\tpii army, queen;\n\t\tset<pii> exit;\n\t\tREP(i, h)REP(j, w)\n\t\t{\n\t\t\tif (fld[i][j] == '#') continue;\n\t\t\tif (fld[i][j] == 'Q') queen = pii(i, j);\n\t\t\tif (fld[i][j] == 'A') army = pii(i, j);\n\t\t\tif (fld[i][j] == 'E') exit.emplace(i, j);\n\t\t\tfld[i][j] = '.';\n\t\t}\n\t\tfor (auto i : exit)REP(ax, h)REP(ay, w)\n\t\t{\n\t\t\tint qx = i.first, qy = i.second;\n\t\t\tdp[0][qx][qy][ax][ay] = 1;\n\t\t}\n\t\tREP(i, h)REP(j, w)\n\t\t{\n\t\t\tif (fld[i][j] == '#') continue;\n\t\t\tdp[0][i][j][i][j] = -1;\n\t\t}\n\t\tvector<state> updates;\n\t\tREP(i, 2)REP(qx, h)REP(qy, w)REP(ax, h)REP(ay, w) updates.push_back(state(i, qx, qy, ax, ay));\n\t\twhile (!updates.empty())\n\t\t{\n\t\t\tvector<state> nexts;\n\t\t\tfor (auto tmp : updates)\n\t\t\t{\n\t\t\t\tREP(k, 4)REP(l, 4)REP(m, 2)\n\t\t\t\t{\n\t\t\t\t\tbool update = false;\n\t\t\t\t\tint i = m, qx = tmp.qx + dx[k], qy = tmp.qy + dy[k], ax = tmp.ax + dx[l], ay = tmp.ay + dy[l];\n\t\t\t\t\tif (!valid(qx, qy, h, w) || !valid(ax, ay, h, w) || dp[i][qx][qy][ax][ay] != 0) continue;\n\t\t\t\t\tif (i == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tset<int> st;\n\t\t\t\t\t\tst.insert(dp[1][qx][qy][ax][ay]);\n\t\t\t\t\t\tREP(j, 4)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tint nx = qx + dx[j], ny = qy + dy[j];\n\t\t\t\t\t\t\tif (!valid(nx, ny, h, w) || fld[nx][ny] == '#') continue;\n\t\t\t\t\t\t\tst.insert(dp[1][nx][ny][ax][ay]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (st.size() == 1 && *st.begin() == -1)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tdp[0][qx][qy][ax][ay] = -1;\n\t\t\t\t\t\t\tupdate = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (st.count(1))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tdp[0][qx][qy][ax][ay] = 1;\n\t\t\t\t\t\t\tupdate = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tset<int> st;\n\t\t\t\t\t\tst.insert(dp[0][qx][qy][ax][ay]);\n\t\t\t\t\t\tREP(j, 4)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tint nx = ax + dx[j], ny = ay + dy[j];\n\t\t\t\t\t\t\tif (!valid(nx, ny, h, w) || fld[nx][ny] == '#') continue;\n\t\t\t\t\t\t\tst.insert(dp[0][qx][qy][nx][ny]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (st.size() == 1 && *st.begin() == 1)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tdp[1][qx][qy][ax][ay] = 1;\n\t\t\t\t\t\t\tupdate = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (st.count(-1))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tdp[1][qx][qy][ax][ay] = -1;\n\t\t\t\t\t\t\tupdate = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (update) nexts.push_back(state(i, qx, qy, ax, ay));\n\t\t\t\t}\n\t\t\t}\n\t\t\tupdates = nexts;\n\t\t}\n\n\t\tint ans = dp[0][queen.first][queen.second][army.first][army.second];\n\t\tif (ans == 1) cout << \"Queen can escape.\" << endl;\n\t\telse if (ans == 0) cout << \"Queen can not escape and Army can not catch Queen.\" << endl;\n\t\telse cout << \"Army can catch Queen.\" << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (int)(k); i < (int)(n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\nconst int dx[] = { -1, 0, 0, 1 }, dy[] = { 0, -1, 1, 0 };\n//[const int dx[] = { -1, -1, -1, 0, 0, 1, 1, 1 }, dy[] = { 0, -1, 1, -1, 1, 0, -1, 1 };\nbool valid(int x, int y, int h, int w) { return (x >= 0 && y >= 0 && x < h&&y < w); }\nint place(int x, int y, int w) { return w*x + y; }\n\nint dp[2][33][33][33][33]; //turn, x_queen, y_queen, x_army, y_army\nint h, w;\nvs fld;\n\nstruct state\n{\n\tint turn, qx, qy, ax, ay;\n\tstate(int a, int b, int c, int d, int e) :turn(a), qx(b), qy(c), ax(d), ay(e) {};\n};\n\nvoid init()\n{\n\tfld.clear(); fld.resize(h);\n\tMS(dp, 0);\n}\n\nint main()\n{\n\tcin.sync_with_stdio(false); cout << fixed << setprecision(10);\n\twhile (cin >> w >> h, h)\n\t{\n\t\tinit();\n\t\tREP(i, h) cin >> fld[i];\n\t\tpii army, queen;\n\t\tset<pii> exit;\n\t\tREP(i, h)REP(j, w)\n\t\t{\n\t\t\tif (fld[i][j] == '#') continue;\n\t\t\tif (fld[i][j] == 'Q') queen = pii(i, j);\n\t\t\tif (fld[i][j] == 'A') army = pii(i, j);\n\t\t\tif (fld[i][j] == 'E') exit.emplace(i, j);\n\t\t\tfld[i][j] = '.';\n\t\t}\n\t\tvector<state> updates;\n\t\tfor (auto i : exit)REP(ax, h)REP(ay, w)\n\t\t{\n\t\t\tint qx = i.first, qy = i.second;\n\t\t\tdp[0][qx][qy][ax][ay] = 1;\n\t\t\tupdates.push_back(state(0, qx, qy, ax, ay));\n\t\t}\n\t\tREP(i, h)REP(j, w)\n\t\t{\n\t\t\tif (fld[i][j] == '#') continue;\n\t\t\tdp[0][i][j][i][j] = -1;\n\t\t\tupdates.push_back(state(0, i, j, i, j));\n\t\t}\n\t\tREP(i, 2)REP(qx, h)REP(qy, w)REP(ax, h)REP(ay, w) updates.push_back(state(i, qx, qy, ax, ay));\n\t\twhile (!updates.empty())\n\t\t{\n\t\t\tvector<state> nexts;\n\t\t\tfor (auto tmp : updates)\n\t\t\t{\n\t\t\t\tREP(k, 4)REP(l, 4)REP(m, 2)\n\t\t\t\t{\n\t\t\t\t\tbool update = false;\n\t\t\t\t\tint i = m, qx = tmp.qx + dx[k], qy = tmp.qy + dy[k], ax = tmp.ax + dx[l], ay = tmp.ay + dy[l];\n\t\t\t\t\tif (!valid(qx, qy, h, w) || !valid(ax, ay, h, w) || dp[i][qx][qy][ax][ay] != 0) continue;\n\t\t\t\t\tif (i == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tset<int> st;\n\t\t\t\t\t\tst.insert(dp[1][qx][qy][ax][ay]);\n\t\t\t\t\t\tREP(j, 4)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tint nx = qx + dx[j], ny = qy + dy[j];\n\t\t\t\t\t\t\tif (!valid(nx, ny, h, w) || fld[nx][ny] == '#') continue;\n\t\t\t\t\t\t\tst.insert(dp[1][nx][ny][ax][ay]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (st.size() == 1 && *st.begin() == -1)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tdp[0][qx][qy][ax][ay] = -1;\n\t\t\t\t\t\t\tupdate = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (st.count(1))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tdp[0][qx][qy][ax][ay] = 1;\n\t\t\t\t\t\t\tupdate = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tset<int> st;\n\t\t\t\t\t\tst.insert(dp[0][qx][qy][ax][ay]);\n\t\t\t\t\t\tREP(j, 4)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tint nx = ax + dx[j], ny = ay + dy[j];\n\t\t\t\t\t\t\tif (!valid(nx, ny, h, w) || fld[nx][ny] == '#') continue;\n\t\t\t\t\t\t\tst.insert(dp[0][qx][qy][nx][ny]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (st.size() == 1 && *st.begin() == 1)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tdp[1][qx][qy][ax][ay] = 1;\n\t\t\t\t\t\t\tupdate = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (st.count(-1))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tdp[1][qx][qy][ax][ay] = -1;\n\t\t\t\t\t\t\tupdate = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (update) nexts.push_back(state(i, qx, qy, ax, ay));\n\t\t\t\t}\n\t\t\t}\n\t\t\tupdates = nexts;\n\t\t}\n\n\t\tint ans = dp[0][queen.first][queen.second][army.first][army.second];\n\t\tif (ans == 1) cout << \"Queen can escape.\" << endl;\n\t\telse if (ans == 0) cout << \"Queen can not escape and Army can not catch Queen.\" << endl;\n\t\telse cout << \"Army can catch Queen.\" << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\ntypedef vector<vector<int>> Graph;\n\nvector<int> solve(const Graph&g) {\n\tvector<int>nums(g.size());\n\tGraph revg(g.size());\n\tfor (int i = 0; i < g.size();++i){\n\t\tauto es(g[i]);\n\t\tnums[i] = es.size();\n\t\tfor (auto e : es) {\n\t\t\trevg[e].push_back(i);\n\t\t}\n\n\t}\n\n\t//1 : win   0 : draw   -1 :loss\n\tvector<int>anss(g.size());\n\tqueue<int>que;\n\tfor (int i = 0; i < g.size(); ++i) {\n\t\tif (!nums[i]) {\n\t\t\tque.push(i);\n\t\t\tanss[i] = -1;\n\t\t}\n\t}\n\twhile (!que.empty()) {\n\t\tint now(que.front());\n\t\tque.pop();\n\t\tif (anss[now] == 1) {\n\t\t\tfor (auto reve : revg[now]) {\n\t\t\t\tnums[reve]--;\n\t\t\t\tif (!nums[reve]&&anss[reve]==0) {\n\t\t\t\t\tanss[reve] = -1;\n\t\t\t\t\tque.push(reve);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if (anss[now] == -1) {\n\t\t\tfor (auto reve : revg[now]) {\n\t\t\t\tif (anss[reve] == 0) {\n\t\t\t\t\tanss[reve] = 1;\n\t\t\t\t\tque.push(reve);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tassert(false);\n\t\t}\n\t}\n\treturn anss;\n}\nint SIZE = 30;\nint gethash(int ax, int ay, int bx, int by, int c) {\n\treturn (ax-1)* SIZE * SIZE * SIZE * 2 + (ay-1)* SIZE * SIZE * 2 + (bx-1) * SIZE * 2 + (by-1) * 2 + c+1;\n}\n\nint main() {\n\twhile (true) {\n\t\tint W, H; cin >> W >> H;\n\t\tif (!W)break;\n\t\tvector<vector<int>>field(H + 2, vector<int>(W + 2,-1));\n\t\tint sqx, sqy, sax, say;\n\t\tfor (int i = 0; i < H; ++i) {\n\t\t\tstring st; cin >> st;\n\t\t\tfor (int j = 0; j < W; ++j) {\n\t\t\t\tswitch (st[j]) {\n\t\t\t\tcase 'Q':\n\t\t\t\t\tfield[i + 1][j + 1] = 0;\n\t\t\t\t\tsqx = j + 1; sqy = i + 1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'A':\n\t\t\t\t\tfield[i + 1][j + 1] = 0;\n\t\t\t\t\tsax = j + 1; say = i + 1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '#':\n\t\t\t\t\tbreak;\n\t\t\t\tcase '.':\n\t\t\t\t\tfield[i + 1][j + 1] = 0;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'E':\n\t\t\t\t\tfield[i + 1][j + 1] = 2;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tassert(false);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSIZE = max(H, W);\n\t\tGraph g(SIZE * SIZE * SIZE*SIZE*2+1);\n\t\tint dx[] = { -1,0,1,0,0 };\n\t\tint dy[] = { 0,1,0,-1,0 };\n\t\tfor (int qx = 1; qx < W + 1; ++qx) {\n\t\t\tfor (int qy = 1; qy < H + 1; ++qy) {\n\t\t\t\tfor (int ax = 1; ax < W + 1; ++ax) {\n\t\t\t\t\tfor (int ay = 1; ay < H + 1; ++ay) {\n\t\t\t\t\t\tfor (int nt = 0; nt < 2; ++nt) {\n\t\t\t\t\t\t\tint nowhash = gethash(qx, qy, ax, ay, nt);\n\t\t\t\t\t\t\tif (qx == ax&&qy == ay) {\n\t\t\t\t\t\t\t\tif (nt) {\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\tg[nowhash].push_back(0);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (field[qy][qx] == 2&&nt) {\n\t\t\t\t\t\t\t\tg[nowhash].push_back(0);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfor (int way = 0; way < 5; ++way) {\n\t\t\t\t\t\t\t\tint nqx(qx), nqy(qy), nax(ax), nay(ay);\n\t\t\t\t\t\t\t\tif (nt) {\n\t\t\t\t\t\t\t\t\tnqx += dx[way]; nqy += dy[way];\n\t\t\t\t\t\t\t\t\tif (field[nqy][nqx]==-1) continue;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\tnax += dx[way]; nay += dy[way];\n\t\t\t\t\t\t\t\t\tif ((field[nay][nax]==-1)) continue;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (nax == nqx&&nay == nqy) {\n\t\t\t\t\t\t\t\t\tif (nt) {\n\t\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\tg[nowhash].push_back(0);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tint nexthash = gethash(nqx, nqy, nax, nay, !nt);\n\t\t\t\t\t\t\t\tg[nowhash].push_back(nexthash);\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tauto anss=solve(g);\n\t\tint ans = anss[gethash(sqx, sqy, sax, say, 1)];\n\t\tif (ans == 0)cout << \"Queen can not escape and Army can not catch Queen.\" << endl;\n\t\telse if (ans == 1)cout << \"Queen can escape.\" << endl;\n\t\telse cout << \"Army can catch Queen.\" << endl;\n\t}\n\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <queue>\n#include <cmath>\n#include <algorithm>\n#include <functional>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define rep1(i,n) for(int i=1;i<=(n);++i)\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl;\ntypedef pair<int,int> P;\nint h,w,qx,qy,ax,ay;\nstring s[30];\nshort int dp[100][100][100][100][2];\t//1->Qwin,-1->Awin.0->?\n//qx,qy,ax,ay,turn=0->queen\nint dx[5]={0,1,0,-1,0},dy[5]={0,0,1,0,-1};\nvector<P> exits;\nbool is(int x,int y){\n\tif(x<0||h<=x||y<0||w<=y||s[x][y]=='#') return false;\n\treturn true;\n}\nvoid init(){\n\texits.clear();\n\trep(i,h) rep(j,w) rep(k,h) rep(l,w) rep(turn,2) dp[i][j][k][l][turn]=0;\n}\nvoid showdp(int i,int j,int k,int l,int turn,int value){\n\tprintf(\"dp[%d][%d][%d][%d][%d]=%d\\n\",i,j,k,l,turn,value);\n}\nint main(){\n\twhile(true){\n\t\tcin>>w>>h;\n\t\tif(w==0) break;\n\t\tinit();\n\t\trep(i,h) cin>>s[i];\n\t\trep(i,h) rep(j,w){\n\t\t\tif(s[i][j]=='Q') qx=i,qy=j;\n\t\t\tif(s[i][j]=='A') ax=i,ay=j;\n\t\t\tif(s[i][j]=='E') exits.pb(P(i,j));\n\t\t}\n\t\tbool update=true;\n\t\tfor(P ex : exits){\n\t\t\tint x=ex.fs,y=ex.sc;\n\t\t\trep(i,h) rep(j,w) dp[x][y][i][j][0]=1;\n\t\t}\n\t\trep(i,h) rep(j,w) rep(turn,2) dp[i][j][i][j][turn]=-1;\n\t\twhile(update){\n\t\t\tupdate=false;\n\t\t\t//turn=0\n\t\t\trep(i,h) rep(j,w) rep(k,h) rep(l,w){\n\t\t\t\tif(dp[i][j][k][l][0]!=0) continue;\n\t\t\t\tbool allcant=true,canwin=false;\n\t\t\t\trep(di,5){\n\t\t\t\t\tint nx=i+dx[di],ny=j+dy[di];\n\t\t\t\t\tif(!is(nx,ny)) continue;\n\t\t\t\t\tif(dp[nx][ny][k][l][1]==1) canwin=true;\n\t\t\t\t\tif(dp[nx][ny][k][l][1]!=-1) allcant=false;\n\t\t\t\t}\n\t\t\t\tif(canwin){\n\t\t\t\t\tdp[i][j][k][l][0]=1;\n//\t\t\t\t\tshowdp(i,j,k,l,0,1);\n\t\t\t\t\tupdate=true;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(allcant){\n\t\t\t\t\tdp[i][j][k][l][0]=-1;\n//\t\t\t\t\tshowdp(i,j,k,l,0,-1);\n\t\t\t\t\tupdate=true;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//turn=1\n\t\t\trep(i,h) rep(j,w) rep(k,h) rep(l,w){\n\t\t\t\tif(dp[i][j][k][l][1]!=0) continue;\n\t\t\t\tbool allcant=true,canwin=false;\n\t\t\t\trep(di,5){\n\t\t\t\t\tint nx=k+dx[di],ny=l+dy[di];\n\t\t\t\t\tif(!is(nx,ny)) continue;\n\t\t\t\t\tif(dp[i][j][nx][ny][0]==-1) canwin=true;\n\t\t\t\t\tif(dp[i][j][nx][ny][0]!=1) allcant=false;\n\t\t\t\t}\n\t\t\t\tif(canwin){\n\t\t\t\t\tdp[i][j][k][l][1]=-1;\n//\t\t\t\t\tshowdp(i,j,k,l,1,-1);\n\t\t\t\t\tupdate=true;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(allcant){\n\t\t\t\t\tdp[i][j][k][l][1]=1;\n//\t\t\t\t\tshowdp(i,j,k,l,1,1);\n\t\t\t\t\tupdate=true;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n//\t\trep(i,h) rep(j,w) rep(k,h) rep(l,w) rep(turn,2) showdp(i,j,k,l,turn,dp[i][j][k][l][turn]);\n\t\tswitch(dp[qx][qy][ax][ay][0]){\n\t\t\tcase -1:\n\t\t\t\tputs(\"Army can catch Queen.\");\n\t\t\t\tbreak;\n\t\t\tcase 0:\n\t\t\t\tputs(\"Queen can not escape and Army can not catch Queen.\");\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tputs(\"Queen can escape.\");\n\t\t\t\tbreak;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nconst int N = 30;\nconst int dx[5]={1,-1,0,0,0};\nconst int dy[5]={0,0,1,-1,0};\n\nint h,w;\nstring s[N];\n\nbool IN(int y, int x){\n    return 0<=y && y<h && 0<=x && x<w && s[y][x]!='#';\n}\n\nint dp[N][N][N][N];\n\nusing pi = pair<int,int>;\nusing P = pair<pi,pi>;\n\nint main(){\n    while(cin >>w >>h,w){\n        rep(i,h) cin >>s[i];\n\n        int qy,qx,ay,ax;\n        rep(i,h)rep(j,w){\n            if(s[i][j]=='Q'){\n                qy = i;\n                qx = j;\n            }\n            if(s[i][j]=='A'){\n                ay = i;\n                ax = j;\n            }\n        }\n\n        memset(dp,-1,sizeof(dp));\n        queue<P> que;\n\n        // win\n        rep(i,h)rep(j,w){\n            if(s[i][j] != 'E') continue;\n            rep(ii,h)rep(jj,w){\n                int d = abs(i-ii) + abs(j-jj);\n                if(d>0){\n                    dp[i][j][ii][jj] = 1;\n                    que.push({{i,j},{ii,jj}});\n                }\n            }\n        }\n        while(!que.empty()){\n            P state = que.front();\n            que.pop();\n            pi queen = state.fi, army = state.se;\n            // dbg(state);\n\n            vector<P> check;\n            rep(qd,5)rep(ad,5){\n                int nqy = queen.fi + dy[qd];\n                int nqx = queen.se + dx[qd];\n                int nay = army.fi + dy[ad];\n                int nax = army.se + dx[ad];\n                if(!IN(nqy,nqx) || !IN(nay,nax) || dp[nqy][nqx][nay][nax]!=-1) continue;\n\n                check.pb({{nqy,nqx},{nay,nax}});\n            }\n\n            for(const auto &ppp:check){\n                pi nq = ppp.fi, na = ppp.se;\n\n                int res = 0;\n                rep(qd,5){\n                    int nqy = nq.fi+dy[qd], nqx = nq.se+dx[qd];\n                    if(!IN(nqy,nqx)) continue;\n\n                    int tmp = 1;\n                    rep(ad,5){\n                        int nay = na.fi+dy[ad], nax = na.se+dx[ad];\n                        if(!IN(nay,nax)) continue;\n                        if(dp[nqy][nqx][nay][nax] != 1) tmp = 0;\n                    }\n                    if(tmp){\n                        res = 1;\n                        break;\n                    }\n                }\n\n                if(res == 1){\n                    dp[nq.fi][nq.se][na.fi][na.se] = 1;\n                    que.push({nq,na});\n                }\n            }\n        }\n\n        // lose\n        rep(i,h)rep(j,w){\n            dp[i][j][i][j] = 0;\n            que.push({{i,j},{i,j}});\n        }\n        while(!que.empty()){\n            P state = que.front();\n            que.pop();\n            pi queen = state.fi, army = state.se;\n            // dbg(state);\n\n            vector<P> check;\n            rep(qd,5)rep(ad,5){\n                int nqy = queen.fi + dy[qd];\n                int nqx = queen.se + dx[qd];\n                int nay = army.fi + dy[ad];\n                int nax = army.se + dx[ad];\n                if(!IN(nqy,nqx) || !IN(nay,nax) || dp[nqy][nqx][nay][nax]!=-1) continue;\n\n                check.pb({{nqy,nqx},{nay,nax}});\n            }\n\n            for(const auto &ppp:check){\n                pi nq = ppp.fi, na = ppp.se;\n\n                int res = 0;\n                rep(qd,5){\n                    int nqy = nq.fi+dy[qd], nqx = nq.se+dx[qd];\n                    if(!IN(nqy,nqx)) continue;\n\n                    int tmp = 1;\n                    rep(ad,5){\n                        int nay = na.fi+dy[ad], nax = na.se+dx[ad];\n                        if(!IN(nay,nax)) continue;\n                        if(dp[nqy][nqx][nay][nax] == 0){\n                            tmp = 0;\n                            break;\n                        }\n                    }\n\n                    res |= tmp;\n                }\n\n                if(res == 0){\n                    dp[nq.fi][nq.se][na.fi][na.se] = 0;\n                    que.push({nq,na});\n                }\n            }\n        }\n\n        int res = dp[qy][qx][ay][ax];\n        if(res == 0) printf(\"Army can catch Queen.\\n\");\n        else if(res == 1) printf(\"Queen can escape.\\n\");\n        else printf(\"Queen can not escape and Army can not catch Queen.\\n\");\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define pb         push_back\n\nenum RES{DRAW=-1,WIN,LOSE};\n\nclass state{\npublic:\n  bool who;//0 queen 1 army\n  short q,a;\n};\n\n\nenum RES win[2][900][900];\nchar need[2][900][900];\nvector<state> edge[2][900][900];\n\nint dx[]={0,0,1,-1,0};\nint dy[]={1,-1,0,0,0};\nchar m[30][30];\n\nbool out(int y,int x,int r,int c){\n  return y<0||x<0||y>=r||x>=c;\n}\n\nint md(int y,int x,int yy,int xx){\n  return max(y,yy)-min(y,yy)+max(x,xx)-min(x,xx);\n}\n\nvoid solve(int q,int a,int r,int c){\n  rep(i,2){\n    rep(j,r*c){\n      rep(k,r*c){\n\twin[i][j][k]=DRAW;\n\tedge[i][j][k].clear();\n\tneed[i][j][k]=0;\n      }\n    }\n  }\n  \n  rep(qi,r){\n    rep(qj,c){\n      if (m[qi][qj] == '#')continue;\n      rep(ai,r){\n\trep(aj,c){\n\t  if (m[ai][aj] == '#')continue;\n\t  rep(k,5){\n\t    int nex=qj+dx[k],ney=qi+dy[k];\n\t    if (out(ney,nex,r,c)||m[ney][nex] == '#')continue;\n\n\t    need[0][qi*c+qj][ai*c+aj]++;\n\t    edge[1][ney*c+nex][ai*c+aj].pb((state){0,qi*c+qj,ai*c+aj});\n\t  }\n\t  rep(k,5){\n\t    int nex=aj+dx[k],ney=ai+dy[k];\n\t    if (out(ney,nex,r,c)||m[ney][nex] == '#')continue;\n\t    need[1][qi*c+qj][ai*c+aj]++;\n\t    edge[0][qi*c+qj][ney*c+nex].pb((state){1,qi*c+qj,ai*c+aj});\n\t  }\n\t}\n      }\n    }\n  }\n\n  queue<state> Q;\n  //win q\n  rep(i,r){\n    rep(j,c){\n      if (m[i][j] == '#')continue;\n      rep(ii,r){\n\trep(jj,c){\n\t  if (m[ii][jj] == '#'||(ii==i&&jj==j))continue;\n\t  if (m[i][j] == 'E'){// && md(i,j,ii,jj)>1){\n\t    win[0][i*c+j][ii*c+jj]=WIN;\n\t    Q.push((state){0,i*c+j,ii*c+jj});\n\t  }\n\t  //if (m[i][j] == 'E' && md(i,j,ii,jj) > 1){\n\t    //\t    win[1][i*c+j][ii*c+jj]=LOSE;\n\t    //Q.push((state){1,i*c+j,ii*c+jj});\n\t  //\t  }\n\t}\n      }\n    }\n  }\n  \n\n  //win a\n  rep(i,r){\n    rep(j,c){\n      if (m[i][j] == '#')continue;\n      rep(k,4){\n\tint nex=j+dx[k],ney=i+dy[k];\n\tif (out(ney,nex,r,c)||m[ney][nex]=='#'){\n\t  continue;\n\t}\n\tif (win[1][i*c+j][ney*c+nex] == DRAW){\n\t  win[1][i*c+j][ney*c+nex]=WIN;\n\t  Q.push((state){1,i*c+j,ney*c+nex});\n\t}\n      }\n    }\n  }\n  \n\n  \n  rep(i,r){\n    rep(j,c){\n      if (m[i][j] == '#')continue;\n      if (win[0][i*c+j][i*c+j] == DRAW){\n\twin[0][i*c+j][i*c+j]=LOSE;\n\tQ.push((state){0,i*c+j,i*c+j});\n      }\n      if (win[1][i*c+j][i*c+j] == DRAW){\n\twin[1][i*c+j][i*c+j]=WIN;\n\tQ.push((state){1,i*c+j,i*c+j});\n      }\n    }\n  }\n  \n\n  while(!Q.empty()){\n    state now = Q.front();Q.pop();\n    //cout << now.who <<\" \" << now.q <<\" \" << now.a <<\" \" << win[now.who][now.q][now.a] << endl;\n    \n    rep(i,edge[now.who][now.q][now.a].size()){\n      state next=edge[now.who][now.q][now.a][i];\n      need[next.who][next.q][next.a]--;\n      //      if (next.who == 0 &&next.q == 0 && next.a == 1)\n      //\tcout <<now.who <<\" \" <<  now.q <<\" \" << now.a << endl;\n\n      if (win[next.who][next.q][next.a] != DRAW)continue;\n      if (win[now.who][now.q][now.a] == LOSE){\n\twin[next.who][next.q][next.a]=WIN;\n\tQ.push(next);\n      }else if (need[next.who][next.q][next.a] == 0 && \n\t\twin[next.who][next.q][next.a]  == DRAW){\n\twin[next.who][next.q][next.a]=LOSE;\n\tQ.push(next);\n      }\n    }\n  }\n\n  //  cout << need[0][q][a]<<endl;\n  if (win[0][q][a] == LOSE)cout << \"Army can catch Queen.\" << endl;\n  else if (win[0][q][a] == WIN)cout << \"Queen can escape.\" << endl;\n  else cout << \"Queen can not escape and Army can not catch Queen.\"<<endl;\n  return;\n}\n\n\nmain(){\n  int r,c;\n  while(cin>>c>>r && c){\n    rep(i,r){\n      rep(j,c)cin>>m[i][j];\n    }\n    int q,a;\n    rep(i,r){\n      rep(j,c){\n\tif (m[i][j] == 'Q')q=i*c+j;\n\tif (m[i][j] == 'A')a=i*c+j;\n      }\n    }\n    solve(q,a,r,c);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <cassert>\n#include <climits>\n#include <queue>\n#include <set>\n#include <map>\n#include <valarray>\n#include <bitset>\n#include <stack>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int INF = 1<<29;\nconst double PI = acos(-1);\nconst double EPS = 1e-8;\n\nchar ba[30][30];\nint memo[30][30][30][30][2];\nint num[30][30][30][30][2];\n\nstruct P {\n  int qx,qy,ax,ay;\n  bool t;\n  P(int qy,int qx,int ay,int ax, bool t) : qx(qx),qy(qy),ax(ax),ay(ay),t(t) {}\n};\nint w,h;\n\nbool check(int y, int x) {\n  return y<0||y>=h||x<0||x>=w||ba[y][x]=='#';\n}\n\nint main() {\n  while(cin>>w>>h,w||h) {\n    int qx,qy;\n    int ax,ay;\n    REP(i,h) REP(j,w) {\n      cin >> ba[i][j];\n      if (ba[i][j] == 'Q') qy=i,qx=j;\n      else if(ba[i][j] == 'A') ay=i,ax=j;\n    }\n    memset(memo,-1,sizeof(memo));\n    memset(num,0,sizeof(num));\n    queue<P> Q;\n    const int dy[] = {0,-1,0,1,0};\n    const int dx[] = {0,0,1,0,-1};\n    \n    REP(y1,h) REP(x1,w) {\n      if (ba[y1][x1]=='#') continue;\n      REP(y2,h) REP(x2,w) {\n        if (ba[y2][x2]=='#') continue;\n        REP(k,2) {\n          if (y1==y2&&x1==x2) {\n            // queen lose\n            memo[y1][x1][y2][x2][k] = k;\n            Q.push(P(y1,x1,y2,x2,k));\n          } else if (ba[y1][x1]=='E' && k==0) {\n            // queen win\n            memo[y1][x1][y2][x2][k] = 1;\n            Q.push(P(y1,x1,y2,x2,k));\n          }\n          \n          REP(d,5) {\n            int yy1=y1+(k?dy[d]:0);\n            int xx1=x1+(k?dx[d]:0);\n            int yy2=y2+(k?0:dy[d]);\n            int xx2=x2+(k?0:dx[d]);\n            if (check(yy1,xx1)||check(yy2,xx2)) continue;\n            num[yy1][xx1][yy2][xx2][!k]++;\n          }\n        }\n      }\n    }\n    //cout << num[0][2][0][0][1] << endl;\n    while(!Q.empty()) {\n      P p = Q.front(); Q.pop();\n\n      int y1=p.qy,x1=p.qx,y2=p.ay,x2=p.ax,k=p.t;\n      //printf(\"(%d,%d),(%d,%d),%d  %d\\n\",y1,x1,y2,x2,k,memo[y1][x1][y2][x2][k]);\n      REP(d,5) {\n        int yy1=y1+(k?dy[d]:0);\n        int xx1=x1+(k?dx[d]:0);\n        int yy2=y2+(k?0:dy[d]);\n        int xx2=x2+(k?0:dx[d]);\n        if (check(yy1,xx1)||check(yy2,xx2)) continue;        \n        if (memo[yy1][xx1][yy2][xx2][!k]!=-1) continue;\n        if (memo[y1][x1][y2][x2][k] == 0) {\n          memo[yy1][xx1][yy2][xx2][!k] = 1;\n          Q.push(P(yy1,xx1,yy2,xx2,!k));\n        } else {\n          num[yy1][xx1][yy2][xx2][!k]--;\n          if (num[yy1][xx1][yy2][xx2][!k] == 0) {\n            //printf(\"  (%d,%d),(%d,%d),%d  \\n\",yy1,xx1,yy2,xx2,!k);\n            memo[yy1][xx1][yy2][xx2][!k] = 0;\n            Q.push(P(yy1,xx1,yy2,xx2,!k));\n          }\n        }\n      }\n    }\n    if (memo[qy][qx][ay][ax][0] == 0) {\n      cout << \"Army can catch Queen.\" << endl;\n    } else if (memo[qy][qx][ay][ax][0] == 1) {\n      cout << \"Queen can escape.\" << endl;\n    } else {\n      cout << \"Queen can not escape and Army can not catch Queen.\" << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<queue>\n#include<vector>\nusing namespace std;\nint dx[]={1,0,-1,0};\nint dy[]={0,1,0,-1};\nchar str[40][40];\nint qd[40][40];\nint ad[40][40];\nint n,m;\nint v[40][40];\nint bfs[32][32][32][32];\nvector<pair<int,int> > e;\nint s,t;\nint dfs(int a,int b,int c){\n\tv[a][b]=1;\n\tfor(int i=0;i<4;i++){\n\t\tif(~c&&(c^2)==i)continue;\n\t\tif(0<=a+dx[i]&&a+dx[i]<n&&0<=b+dy[i]&&b+dy[i]<m&&str[a+dx[i]][b+dy[i]]!='#'){\n\t\t\tif(v[a+dx[i]][b+dy[i]]){\n\t\t\t\tif(a+dx[i]==s&&b+dy[i]==t)return 1;\n\t\t\t}else{\n\t\t\t\tint res=dfs(a+dx[i],b+dy[i],i);\n\t\t\t\tif(res)return 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nint main(){\n\tint a,b;\n\twhile(scanf(\"%d%d\",&b,&a),a){\n\t\tn=a;m=b;\n\t\tfor(int i=0;i<a;i++)scanf(\"%s\",str[i]);\n\t\tint qr,qc;\n\t\tint ar,ac;\n\t\te.clear();\n\t\tfor(int i=0;i<a;i++)for(int j=0;j<b;j++){\n\t\t\tif(str[i][j]=='Q'){qr=i;qc=j;}\n\t\t\tif(str[i][j]=='A'){ar=i;ac=j;}\n\t\t\tif(str[i][j]=='E'){e.push_back(make_pair(i,j));}\n\t\t}\n\t\tqueue<pair<int,int> > Q;\n\t\tfor(int i=0;i<a;i++)for(int j=0;j<b;j++)qd[i][j]=ad[i][j]=999999999;\n\t\tQ.push(make_pair(qr,qc));\n\t\tqd[qr][qc]=0;\n\t\twhile(Q.size()){\n\t\t\tint row=Q.front().first;\n\t\t\tint col=Q.front().second;\n\t\t\tQ.pop();\n\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\tif(0<=row+dx[i]&&row+dx[i]<a&&0<=col+dy[i]&&col+dy[i]<b&&str[row+dx[i]][col+dy[i]]!='#'&&qd[row+dx[i]][col+dy[i]]>qd[row][col]+1){\n\t\t\t\t\tqd[row+dx[i]][col+dy[i]]=qd[row][col]+1;\n\t\t\t\t\tQ.push(make_pair(row+dx[i],col+dy[i]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tQ.push(make_pair(ar,ac));\n\t\tad[ar][ac]=0;\n\t\twhile(Q.size()){\n\t\t\tint row=Q.front().first;\n\t\t\tint col=Q.front().second;\n\t\t\tQ.pop();\n\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\tif(0<=row+dx[i]&&row+dx[i]<a&&0<=col+dy[i]&&col+dy[i]<b&&str[row+dx[i]][col+dy[i]]!='#'&&ad[row+dx[i]][col+dy[i]]>ad[row][col]+1){\n\t\t\t\t\tad[row+dx[i]][col+dy[i]]=ad[row][col]+1;\n\t\t\t\t\tQ.push(make_pair(row+dx[i],col+dy[i]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<a;i++)for(int j=0;j<b;j++){\n\t\t\tfor(int k=0;k<a;k++)for(int l=0;l<b;l++)bfs[i][j][k][l]=999999999;\n\t\t\tif(str[i][j]=='#')continue;\n\t\t\tbfs[i][j][i][j]=0;\n\t\t\tQ.push(make_pair(i,j));\n\t\t\twhile(Q.size()){\n\t\t\t\tint row=Q.front().first;\n\t\t\t\tint col=Q.front().second;\n\t\t\t\tQ.pop();\n\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\tif(0<=row+dx[k]&&row+dx[k]<a&&0<=col+dy[k]&&col+dy[k]<b&&str[row+dx[k]][col+dy[k]]!='#'&&bfs[i][j][row+dx[k]][col+dy[k]]>bfs[i][j][row][col]+1){\n\t\t\t\t\t\tbfs[i][j][row+dx[k]][col+dy[k]]=bfs[i][j][row][col]+1;\n\t\t\t\t\t\tQ.push(make_pair(row+dx[k],col+dy[k]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t/*\tif(i==5&&j==0){\n\t\t\t\tfor(int k=0;k<a;k++){\n\t\t\t\t\tfor(int l=0;l<b;l++)printf(\"%d \",bfs[i][j][k][l]);\n\t\t\t\t\tprintf(\"\\n\");\n\t\t\t\t}\n\t\t\t}*/\n\t\t}\n\t\tbool ok=false;\n\t\tfor(int i=0;i<a;i++){\n\t\t\tfor(int j=0;j<b;j++){\n\t\t\t\tif(str[i][j]=='#')continue;\n\t\t\t\tfor(int k=0;k<a;k++)for(int l=0;l<b;l++)v[k][l]=1;\n\t\t\t\tfor(int k=0;k<a;k++)for(int l=0;l<b;l++)if(str[k][l]=='#')v[k][l]=0;\n\t\t\t\tfor(int k=0;k<e.size();k++){\n\t\t\t\t\tfor(int x=0;x<a;x++)for(int y=0;y<b;y++)\n\t\t\t\t\t\tif(bfs[e[k].first][e[k].second][x][y]>bfs[i][j][e[k].first][e[k].second])v[x][y]=0;\n\t\t\t\t}\n\t\t\t/*\tif(i==5&&j==0){\n\t\t\t\t\tfor(int k=0;k<a;k++){\n\t\t\t\t\t\tfor(int l=0;l<b;l++)printf(\"%d\",v[k][l]);\n\t\t\t\t\t\tprintf(\"\\n\");\n\t\t\t\t\t}\n\t\t\t\t}*/\n\t\t\t\tbool OK=true;\n\t\t\t\tfor(int k=0;k<a;k++)for(int l=0;l<b;l++){\n\t\t\t\t\tif(v[k][l]&&qd[i][j]>=ad[k][l])OK=false;\n\t\t\t\t}\n\t\t\t\tif(OK)ok=true;\n\t\t\t}\n\t\t}\n\t\tif(ok){\n\t\t\tprintf(\"Queen can escape.\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\tfor(int i=0;i<a;i++)for(int j=0;j<b;j++){\n\t\t\tif(str[i][j]!='#'){\n\t\t\t\tfor(int k=0;k<a;k++)for(int l=0;l<b;l++)v[k][l]=0;\n\t\t\t\ts=i;t=j;\n\t\t\t\tif(dfs(i,j,-1)&&qd[i][j]<ad[i][j])ok=true;\n\t\t\t}\n\t\t}\n\t\tif(ok)printf(\"Queen can not escape and Army can not catch Queen.\\n\");\n\t\telse printf(\"Army can catch Queen.\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nconst int nmax = 30 + 1;\nconst int dx[5] = {0, 0, 1, -1, 0};\nconst int dy[5] = {1, -1, 0, 0, 0};\n\nstruct state {\n\tint x1, y1, x2, y2;\n\tbool turn; // 0 for Q ed\n\tstate() {};\n\tstate(int _x1, int _y1, int _x2, int _y2, bool _turn) {\n\t\tx1 = _x1, x2 = _x2, y1 = _y1, y2 = _y2, turn = _turn;\n\t}\n};\n\nbool f[nmax][nmax][nmax][nmax][2]; // 0 for lose\nvector<state> Q;\nbool ed[nmax][nmax][nmax][nmax][2];\nchar a[nmax][nmax];\nint n, m;\n\nint check(state &s)\n{\n\tint x1, x2, y1, y2;\n\tint nxtt = s.turn ^ 1;\n\tbool all = 1, exist = 0;\n\tif (s.turn == 0) {\n\t\tx1 = s.x1, y1 = s.y1;\n\t\tfor (int j = 0; j < 5; ++j) {\n\t\t\tx2 = s.x2 + dx[j], y2 = s.y2 + dy[j];\n\t\t\tif (x2 <= 0 || x2 > n || y2 <= 0 || y2 > m || a[x2][y2] == '#') continue;\n\t\t\tif (!ed[x1][y1][x2][y2][nxtt]) {\n\t\t\t\tall = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (f[x1][y1][x2][y2][nxtt] == 0)\n\t\t\t\texist = 1, all = 0;\n\t\t}\n\t}\n\telse {\n\t\tfor (int i = 0; i < 5; ++i) {\n\t\t\tx1 = s.x1 + dx[i], y1 = s.y1 + dy[i];\n\t\t\tif (x1 <= 0 || x1 > n || y1 <= 0 || y1 > m || a[x1][y1] == '#') continue;\n\t\t\tx2 = s.x2, y2 = s.y2;\n\t\t\tif (!ed[x1][y1][x2][y2][nxtt]) {\n\t\t\t\tall = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (f[x1][y1][x2][y2][nxtt] == 1)\n\t\t\t\texist = 1, all = 0;\n\t\t}\n\t}\n\tif (all)\n\t\treturn nxtt;\n\telse if (exist)\n\t\treturn s.turn;\n\telse return 2;\n}\n\nint main()\n{\n\twhile (1) {\n\t\tscanf(\"%d%d\", &n, &m);\n\t\tswap(n, m);\n\t\tif (n == 0 && m == 0) break;\n\t\tfor (int i = 1; i <= n; ++i)\n\t\t\tscanf(\"%s\", a[i] + 1);\n\t\tmemset(ed, 0, sizeof(ed));\n\t\tQ.clear();\n\t\tfor (int i = 1; i <= n; ++i)\n\t\t\tfor (int j = 1; j <= m; ++j) if (a[i][j] != '#')\n\t\t\t\tfor (int k = 1; k <= n; ++k)\n\t\t\t\t\tfor (int l = 1; l <= m; ++l) if (a[k][l] != '#') {\n\t\t\t\t\t\tif (i == k && j == l) {\n\t\t\t\t\t\t\tstate tmp(i, j, k, l, 1);\n\t\t\t\t\t\t\tQ.push_back(tmp);\n\t\t\t\t\t\t\tf[i][j][k][l][1] = 0;\n\t\t\t\t\t\t\ted[i][j][k][l][1] = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (a[i][j] == 'E') {\n\t\t\t\t\t\t\tstate tmp(i, j, k, l, 1);\n\t\t\t\t\t\t\tQ.push_back(tmp);\n\t\t\t\t\t\t\tf[i][j][k][l][1] = 1;\n\t\t\t\t\t\t\ted[i][j][k][l][1] = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\tfor (int tmpi = 0; tmpi < Q.size(); ++tmpi) {\n\t\t\tstate *now = &Q[tmpi];\n\t\t\tint x1, x2, y1, y2, tmpf;\n//\t\t\tprintf(\"(%d) (%d) %d: %d\\n\", now->y1, now->y2, now->turn, f[now->x1][now->y1][now->x2][now->y2][now->turn]);\n//\t\t\tprintf(\"(%d, %d) (%d, %d) %d: %d\\n\", now->x1, now->y1, now->x2, now->y2, now->turn, f[now->x1][now->y1][now->x2][now->y2][now->turn]);\n\t\t\tbool nxtt = now->turn ^ 1;\n\t\t\tif (now->turn == 1) {\n\t\t\t\tx1 = now->x1, y1 = now->y1;\n\t\t\t\tfor (int j = 0; j < 5; ++j) {\n\t\t\t\t\tx2 = now->x2 + dx[j], y2 = now->y2 + dy[j];\n\t\t\t\t\tif (x2 <= 0 || x2 > n || y2 <= 0 || y2 > m || a[x2][y2] == '#') continue;\n\t\t\t\t\tif (ed[x1][y1][x2][y2][nxtt]) continue;\n\t\t\t\t\tstate tmp(x1, y1, x2, y2, nxtt);\n\t\t\t\t\tif ((tmpf = check(tmp)) != 2) {\n\t\t\t\t\t\ted[x1][y1][x2][y2][nxtt] = 1;\n\t\t\t\t\t\tf[x1][y1][x2][y2][nxtt] = tmpf;\n\t\t\t\t\t\tQ.push_back(tmp);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfor (int i = 0; i < 5; ++i) {\n\t\t\t\t\tx1 = now->x1 + dx[i], y1 = now->y1 + dy[i];\n\t\t\t\t\tif (x1 <= 0 || x1 > n || y1 <= 0 || y1 > m || a[x1][y1] == '#') continue;\n\t\t\t\t\tx2 = now->x2, y2 = now->y2;\n\t\t\t\t\tif (ed[x1][y1][x2][y2][nxtt]) continue;\n\t\t\t\t\tstate tmp(x1, y1, x2, y2, nxtt);\n\t\t\t\t\tif ((tmpf = check(tmp)) != 2) {\n\t\t\t\t\t\ted[x1][y1][x2][y2][nxtt] = 1;\n\t\t\t\t\t\tf[x1][y1][x2][y2][nxtt] = tmpf;\n\t\t\t\t\t\tQ.push_back(tmp);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint lx, ly, rx, ry;\n\t\tfor (int i = 1; i <= n; ++i)\n\t\t\tfor (int j = 1; j <= m; ++j) {\n\t\t\t\tif (a[i][j] == 'Q')\n\t\t\t\t\tlx = i, ly = j;\n\t\t\t\tif (a[i][j] == 'A')\n\t\t\t\t\trx = i, ry = j;\n\t\t\t}\n\t\tif (!ed[lx][ly][rx][ry][1])\n\t\t\tprintf(\"Queen can not escape and Army can not catch Queen.\\n\"); // tie\n\t\telse\n\t\t\tif (f[lx][ly][rx][ry][1])\n\t\t\t\tprintf(\"Queen can escape.\\n\"); //win\n\t\t\telse\n\t\t\t\tprintf(\"Army can catch Queen.\\n\"); //lose\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (int)(k); i < (int)(n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\nconst int dx[] = { -1, 0, 0, 1 }, dy[] = { 0, -1, 1, 0 };\n//[const int dx[] = { -1, -1, -1, 0, 0, 1, 1, 1 }, dy[] = { 0, -1, 1, -1, 1, 0, -1, 1 };\nbool valid(int x, int y, int h, int w) { return (x >= 0 && y >= 0 && x < h&&y < w); }\nint place(int x, int y, int w) { return w*x + y; }\n\nint dp[2][33][33][33][33]; //turn, x_queen, y_queen, x_army, y_army\nint h, w;\nvs fld;\n\nstruct state\n{\n\tint turn, qx, qy, ax, ay;\n\tstate(int a, int b, int c, int d, int e) :turn(a), qx(b), qy(c), ax(d), ay(e) {};\n};\n\nvoid init()\n{\n\tfld.clear(); fld.resize(h);\n\tMS(dp, 0);\n}\n\nint main()\n{\n\tcin.sync_with_stdio(false); cout << fixed << setprecision(10);\n\twhile (cin >> w >> h, h)\n\t{\n\t\tinit();\n\t\tREP(i, h) cin >> fld[i];\n\t\tpii army, queen;\n\t\tset<pii> exit;\n\t\tREP(i, h)REP(j, w)\n\t\t{\n\t\t\tif (fld[i][j] == '#') continue;\n\t\t\tif (fld[i][j] == 'Q') queen = pii(i, j);\n\t\t\tif (fld[i][j] == 'A') army = pii(i, j);\n\t\t\tif (fld[i][j] == 'E') exit.emplace(i, j);\n\t\t\tfld[i][j] = '.';\n\t\t}\n\t\tfor (auto i : exit)REP(ax, h)REP(ay, w)\n\t\t{\n\t\t\tint qx = i.first, qy = i.second;\n\t\t\tdp[0][qx][qy][ax][ay] = 1;\n\t\t}\n\t\tREP(i, h)REP(j, w)\n\t\t{\n\t\t\tif (fld[i][j] == '#') continue;\n\t\t\tdp[0][i][j][i][j] = -1;\n\t\t}\n\t\tvector<state> updates;\n\t\tREP(i, 2)REP(qx, h)REP(qy, w)REP(ax, h)REP(ay, w) updates.push_back(state(i, qx, qy, ax, ay));\n\t\twhile (!updates.empty())\n\t\t{\n\t\t\tvector<state> nexts;\n\t\t\tfor (auto tmp : updates)\n\t\t\t{\n\t\t\t\tREP(k, 4)REP(l, 4)REP(m, 2)\n\t\t\t\t{\n\t\t\t\t\tbool update = false;\n\t\t\t\t\tint i = m, qx = tmp.qx + dx[k], qy = tmp.qy + dy[k], ax = tmp.ax + dx[l], ay = tmp.ay + dy[l];\n\t\t\t\t\tif (dp[i][qx][qy][ax][ay] != 0 || !valid(qx, qy, h, w) || !valid(ax, ay, h, w)) continue;\n\t\t\t\t\tif (i == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tset<int> st;\n\t\t\t\t\t\tst.insert(dp[1][qx][qy][ax][ay]);\n\t\t\t\t\t\tREP(j, 4)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tint nx = qx + dx[j], ny = qy + dy[j];\n\t\t\t\t\t\t\tif (!valid(nx, ny, h, w) || fld[nx][ny] == '#') continue;\n\t\t\t\t\t\t\tst.insert(dp[1][nx][ny][ax][ay]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (st.size() == 1 && *st.begin() == -1)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tdp[0][qx][qy][ax][ay] = -1;\n\t\t\t\t\t\t\tupdate = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (st.count(1))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tdp[0][qx][qy][ax][ay] = 1;\n\t\t\t\t\t\t\tupdate = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tset<int> st;\n\t\t\t\t\t\tst.insert(dp[0][qx][qy][ax][ay]);\n\t\t\t\t\t\tREP(j, 4)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tint nx = ax + dx[j], ny = ay + dy[j];\n\t\t\t\t\t\t\tif (!valid(nx, ny, h, w) || fld[nx][ny] == '#') continue;\n\t\t\t\t\t\t\tst.insert(dp[0][qx][qy][nx][ny]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (st.size() == 1 && *st.begin() == 1)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tdp[1][qx][qy][ax][ay] = 1;\n\t\t\t\t\t\t\tupdate = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (st.count(-1))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tdp[1][qx][qy][ax][ay] = -1;\n\t\t\t\t\t\t\tupdate = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (update) nexts.push_back(state(i, qx, qy, ax, ay));\n\t\t\t\t}\n\t\t\t}\n\t\t\tupdates = nexts;\n\t\t}\n\n\t\tint ans = dp[0][queen.first][queen.second][army.first][army.second];\n\t\tif (ans == 1) cout << \"Queen can escape.\" << endl;\n\t\telse if (ans == 0) cout << \"Queen can not escape and Army can not catch Queen.\" << endl;\n\t\telse cout << \"Army can catch Queen.\" << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXH = 31;\nconst int MAXW = 31;\nconst int di[] = {0,1,0,-1,0};\nconst int dj[] = {1,0,-1,0,0};\nint W, H;\nchar G[MAXH][MAXW];\nint mem[MAXH][MAXW][MAXH][MAXW][2];\n\nint main() {\n  while(cin >> W >> H && (W|H)) {\n    int sqi, sqj, sei, sej;\n    for(int i = 0; i < H; ++i) {\n      for(int j = 0; j < W; ++j) {\n        cin >> G[i][j];\n        if(G[i][j] == 'Q') {\n          sqi = i;\n          sqj = j;\n        }\n        if(G[i][j] == 'A') {\n          sei = i;\n          sej = j;\n        }\n      }\n    }\n    \n    fill(mem[0][0][0][0], mem[0][0][0][0] + sizeof(mem)/sizeof(int), 1);\n    for(int qi = 0; qi < H; ++qi) {\n      for(int qj = 0; qj < W; ++qj) {\n        for(int ei = 0; ei < H; ++ei) {\n          for(int ej = 0; ej < W; ++ej) {\n            for(int t = 0; t < 2; ++t) {\n              int &now = mem[qi][qj][ei][ej][t];\n              if(G[qi][qj] == 'E' && t == 0) now = 2;\n              if(qi == ei && qj == ej) now = 0;\n            }\n          }\n        }\n      }\n    }\n    \n    for(bool update = true; update;) {\n      update = false;\n      for(int qi = 0; qi < H; ++qi) {\n        for(int qj = 0; qj < W; ++qj) {\n          for(int ei = 0; ei < H; ++ei) {\n            for(int ej = 0; ej < W; ++ej) {\n              for(int t = 0; t < 2; ++t) {\n                int &now = mem[qi][qj][ei][ej][t];\n                if(now != 1) continue;\n                int tmp = t * 2;\n                for(int k = 0; k < 5; ++k) {\n                  int nqi =  t ? qi : qi + di[k];\n                  int nqj =  t ? qj : qj + dj[k];\n                  int nei = !t ? ei : ei + di[k];\n                  int nej = !t ? ej : ej + dj[k];\n                  if(nqi < 0 || nqi >= H) continue;\n                  if(nqj < 0 || nqj >= W) continue;\n                  if(nei < 0 || nei >= H) continue;\n                  if(nej < 0 || nej >= W) continue;\n                  if(G[nqi][nqj] == '#') continue;\n                  if(G[nei][nej] == '#') continue;\n                  if(t) tmp = min(tmp, mem[nqi][nqj][nei][nej][1-t]);\n                  else  tmp = max(tmp, mem[nqi][nqj][nei][nej][1-t]);\n                }\n                if(tmp != 1) {\n                  now = tmp;\n                  update = true;\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n    int res = mem[sqi][sqj][sei][sej][0];\n    if(res == 0) cout << \"Army can catch Queen.\" << endl;\n    else if(res == 1) cout << \"Queen can not escape and Army can not catch Queen.\" << endl;\n    else cout << \"Queen can escape.\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\ntemplate<class T> inline void chmin(T &a, const T &b) { if(a > b) a = b; }\ntemplate<class T> inline void chmax(T &a, const T &b) { if(a < b) a = b; }\n\ntypedef vector<vector<int>> graph;\n\nconstexpr int MAX_N = 900;\n\nenum {ESCAPE, LOOP, CATCH};\nenum {Q, A, NUM};\n\nconst string message[3] = {\n\t\"Queen can escape.\",\n\t\"Queen can not escape and Army can not catch Queen.\",\n\t\"Army can catch Queen.\",\n};\n\nint dp[MAX_N][MAX_N][NUM];\n\ninline int get_index(int x, int y, int w) {\n\treturn x + y * w;\n}\n\ninline void add_edge(int a, int b, graph &G) {\n\tG[a].emplace_back(b);\n\tG[b].emplace_back(a);\n}\n\ninline string solve(int q, int a, const vector<int> &g, const graph &G) {\n\tconst int n = G.size();\n\tfor(int v = 0; v < n; ++v) {\n\t\tfor(int u = 0; u < n; ++u) {\n\t\t\tdp[v][u][Q] = dp[v][u][A] = LOOP;\n\t\t}\n\t}\n\n\tfor(int v = 0; v < n; ++v) {\n\t\tdp[v][v][Q] = dp[v][v][A] = CATCH;\n\t}\n\n\tfor(const auto &e : g) {\n\t\tfor(int v = 0; v < n; ++v) {\n\t\t\tif(e != v) dp[e][v][Q] = ESCAPE;\n\t\t}\n\t}\n\n\twhile(true) {\n\t\tbool update = false;\n\n\t\tfor(int v = 0; v < n; ++v) {\n\t\t\tfor(int u = 0; u < n; ++u) {\n\t\t\t\tif(v == u) continue;\n\n\t\t\t\t// queen turn\n\t\t\t\tif(dp[v][u][Q] != ESCAPE) {\n\t\t\t\t\tconst int prev = dp[v][u][Q];\n\t\t\t\t\tdp[v][u][Q] = CATCH;\n\t\t\t\t\tfor(const auto &to : G[v]) {\n\t\t\t\t\t\tchmin(dp[v][u][Q], dp[to][u][A]);\n\t\t\t\t\t}\n\t\t\t\t\tif(dp[v][u][Q] != prev) update = true;\n\t\t\t\t}\n\n\t\t\t\t// army turn\n\t\t\t\t{\n\t\t\t\t\tconst int prev = dp[v][u][A];\n\t\t\t\t\tdp[v][u][A] = ESCAPE;\n\t\t\t\t\tfor(const auto &to : G[u]) {\n\t\t\t\t\t\tchmax(dp[v][u][A], dp[v][to][Q]);\n\t\t\t\t\t}\n\t\t\t\t\tif(dp[v][u][A] != prev) update = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(!update) break;\n\t}\n\n\treturn message[dp[q][a][Q]];\n}\n\nint main() {\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\n\tfor(int w, h; cin >> w >> h && w;) {\n\t\tvector<string> field(h);\n\t\tfor(auto &e : field) cin >> e;\n\n\t\tint next_label = 0;\n\t\tvector<vector<int>> label(h, vector<int>(w, -1));\n\t\tfor(int i = 0; i < h; ++i) {\n\t\t\tfor(int j = 0; j < w; ++j) {\n\t\t\t\tif(field[i][j] != '#') label[i][j] = next_label++;\n\t\t\t}\n\t\t}\n\n\t\tint q, a;\n\t\tvector<int> g;\n\n\t\tgraph G(next_label);\n\n\t\tfor(int i = 0; i < h; ++i) {\n\t\t\tfor(int j = 0; j < w; ++j) {\n\t\t\t\tif(field[i][j] == '#') continue;\n\n\t\t\t\tconst int v = label[i][j];\n\n\t\t\t\tswitch(field[i][j]) {\n\t\t\t\tcase 'Q': q = v; break;\n\t\t\t\tcase 'A': a = v; break;\n\t\t\t\tcase 'E': g.emplace_back(v); break;\n\t\t\t\t}\n\n\t\t\t\tadd_edge(v, v, G);\n\n\t\t\t\tif(i < h - 1) {\n\t\t\t\t\tif(field[i + 1][j] != '#') {\n\t\t\t\t\t\tadd_edge(v, label[i + 1][j], G);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif(j < w - 1) {\n\t\t\t\t\tif(field[i][j + 1] != '#') {\n\t\t\t\t\t\tadd_edge(v, label[i][j + 1], G);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << solve(q, a, g, G) << endl;\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXH = 31;\nconst int MAXW = 31;\nconst int di[] = {0,1,0,-1,0};\nconst int dj[] = {1,0,-1,0,0};\nint W, H;\nchar G[MAXH][MAXW];\nint mem[MAXH][MAXW][MAXH][MAXW][2];\n\nint main() {\n  while(cin >> W >> H && (W|H)) {\n    int sqi, sqj, sei, sej;\n    for(int i = 0; i < H; ++i) {\n      for(int j = 0; j < W; ++j) {\n        cin >> G[i][j];\n        if(G[i][j] == 'Q') {\n          sqi = i;\n          sqj = j;\n        }\n        if(G[i][j] == 'A') {\n          sei = i;\n          sej = j;\n        }\n      }\n    }\n    \n    fill(mem[0][0][0][0], mem[0][0][0][0] + sizeof(mem)/sizeof(int), 1);\n    for(int qi = 0; qi < H; ++qi) {\n      for(int qj = 0; qj < W; ++qj) {\n        for(int ei = 0; ei < H; ++ei) {\n          for(int ej = 0; ej < W; ++ej) {\n            for(int t = 0; t < 2; ++t) {\n              int &now = mem[qi][qj][ei][ej][t];\n              if(G[qi][qj] == 'E' && t == 0) now = 2;\n              if(qi == ei && qj == ej) now = 0;\n            }\n          }\n        }\n      }\n    }\n    \n    for(bool update = true; update;) {\n      update = false;\n      for(int qi = 0; qi < H; ++qi) {\n        for(int qj = 0; qj < W; ++qj) {\n          for(int ei = 0; ei < H; ++ei) {\n            for(int ej = 0; ej < W; ++ej) {\n              for(int t = 0; t < 2; ++t) {\n                int &now = mem[qi][qj][ei][ej][t];\n                if(now != 1) continue;\n                int tmp = t * 2;\n                for(int k = 0; k < 5; ++k) {\n                  int nqi =  t ? qi : qi + di[k];\n                  int nqj =  t ? qj : qj + dj[k];\n                  int nei = !t ? ei : ei + di[k];\n                  int nej = !t ? ej : ej + dj[k];\n                  if(nqi < 0 || nqi >= H) continue;\n                  if(nqj < 0 || nqj >= W) continue;\n                  if(nei < 0 || nei >= H) continue;\n                  if(nej < 0 || nej >= W) continue;\n                  if(G[nqi][nqj] == '#') continue;\n                  if(G[nei][nej] == '#') continue;\n                  if(t) tmp = min(tmp, mem[nqi][nqj][nei][nej][1-t]);\n                  else  tmp = max(tmp, mem[nqi][nqj][nei][nej][1-t]);\n                }\n                if(tmp != 1) {\n                  now = tmp;\n                  update = true;\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n    int res = mem[sqi][sqj][sei][sej][0];\n    if(res == 0) cout << \"Army can catch Queen.\" << endl;\n    else if(res == 1) cout << \"Queen can not escape and Army can not catch Queen.\" << endl;\n    else cout << \"Queen can escape.\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\nusing namespace std;\ntypedef long long LL;\nint dx[5] = {1, 0, -1, 0, 0};\nint dy[5] = {0, 1, 0, -1, 0};\n\nconst int MAX_T = 10 * 30 / 4;\n\nint W, H;\nstring grid[30];\nchar memo[30][30][30][30][MAX_T];\nbool valid(int x, int w) {\n    return 0 <= x && x < w;\n}\nint dfs(int x1, int y1, int x2, int y2, int t) {\n    //printf(\"%d %d %d %d %d %c %c\\n\", x1, y1, x2, y2, t, grid[y1][x1], grid[y2][x2]);\n    if(t >= MAX_T) return 2;\n    char& res = memo[y1][x1][y2][x2][t];\n    if(res != -1) return res;\n\n    if(y1 == y2 && x1 == x2) return res = 1;\n\n    int turn = t % 2;\n    if(turn == 0) {\n        if(grid[y1][x1] == 'E') return res = 0;\n\n        bool draw = false;\n        REP(r, 5) {\n            int nx = x1 + dx[r];\n            int ny = y1 + dy[r];\n            if(valid(nx, W) && valid(ny, H) && grid[ny][nx] != '#') {\n                int check = dfs(nx, ny, x2, y2, t + 1);\n                if(check == 0) {\n                    return res = 0;\n                } else if(check == 2) {\n                    draw = true;\n                }\n            }\n        }\n        return res = (draw ? 2 : 1);\n    } else {\n        bool draw = false;\n        REP(r, 5) {\n            int nx = x2 + dx[r];\n            int ny = y2 + dy[r];\n            if(valid(nx, W) && valid(ny, H) && grid[ny][nx] != '#') {\n                int check = dfs(x1, y1, nx, ny, t + 1);\n                if(check == 1) {\n                    return res = 1;\n                } else if(check == 2) {\n                    draw = true;\n                }\n            }\n        }\n        return res = (draw ? 2 : 0);\n    }\n}\n\nint main(){\n    while(cin >> W >> H && W > 0){\n        REP(y, H) cin >> grid[y];\n        int x1 = -1, y1 = -1, x2 = -1, y2 = -1;\n        REP(y, H) REP(x, W) if(grid[y][x] == 'Q') x1 = x, y1 = y;\n        REP(y, H) REP(x, W) if(grid[y][x] == 'A') x2 = x, y2 = y;\n\n        memset(memo, -1, sizeof(memo));\n        int ans = dfs(x1, y1, x2, y2, 0);\n        if(ans == 0) {\n            cout << \"Queen can escape.\" << endl;\n        } else if(ans == 1) {\n            cout << \"Army can catch Queen.\" << endl;\n        } else {\n            cout << \"Queen can not escape and Army can not catch Queen.\" << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\ntemplate<class T> inline void chmin(T &a, const T &b) { if(a > b) a = b; }\ntemplate<class T> inline void chmax(T &a, const T &b) { if(a < b) a = b; }\n\ntypedef vector<vector<int>> graph;\n\nconstexpr int MAX_N = 900;\n\nenum {ESCAPE, LOOP, CATCH};\nenum {Q, A, NUM};\n\nconst string message[3] = {\n\t\"Queen can escape.\",\n\t\"Queen can not escape and Army can not catch Queen.\",\n\t\"Army can catch Queen.\",\n};\n\nint dp[MAX_N][MAX_N][NUM];\n\ninline int get_index(int x, int y, int w) {\n\treturn x + y * w;\n}\n\ninline void add_edge(int a, int b, graph &G) {\n\tG[a].emplace_back(b);\n\tG[b].emplace_back(a);\n}\n\ninline string solve(int q, int a, const vector<int> &g, const graph &G) {\n\tconst int n = G.size();\n\tfor(int v = 0; v < n; ++v) {\n\t\tfor(int u = 0; u < n; ++u) {\n\t\t\tdp[v][u][Q] = dp[v][u][A] = LOOP;\n\t\t}\n\t}\n\n\tfor(int v = 0; v < n; ++v) {\n\t\tdp[v][v][Q] = dp[v][v][A] = CATCH;\n\t}\n\n\tfor(const auto &e : g) {\n\t\tfor(int v = 0; v < n; ++v) {\n\t\t\tif(e != v) dp[e][v][Q] = ESCAPE;\n\t\t}\n\t}\n\n\twhile(true) {\n\t\tbool update = false;\n\n\t\tfor(int v = 0; v < n; ++v) {\n\t\t\tfor(int u = 0; u < n; ++u) {\n\t\t\t\tif(v == u) continue;\n\n\t\t\t\t// queen turn\n\t\t\t\tif(dp[v][u][Q] != ESCAPE) {\n\t\t\t\t\tconst int prev = dp[v][u][Q];\n\t\t\t\t\tdp[v][u][Q] = CATCH;\n\t\t\t\t\tfor(const auto &to : G[v]) {\n\t\t\t\t\t\tchmin(dp[v][u][Q], dp[to][u][A]);\n\t\t\t\t\t}\n\t\t\t\t\tif(dp[v][u][Q] != prev) update = true;\n\t\t\t\t}\n\n\t\t\t\t// army turn\n\t\t\t\t{\n\t\t\t\t\tconst int prev = dp[v][u][A];\n\t\t\t\t\tdp[v][u][A] = ESCAPE;\n\t\t\t\t\tfor(const auto &to : G[u]) {\n\t\t\t\t\t\tchmax(dp[v][u][A], dp[v][to][Q]);\n\t\t\t\t\t}\n\t\t\t\t\tif(dp[v][u][A] != prev) update = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(!update) break;\n\t}\n\n\treturn message[dp[q][a][Q]];\n}\n\nint main() {\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\n\tfor(int w, h; cin >> w >> h && w;) {\n\t\tvector<string> field(h);\n\t\tfor(auto &e : field) cin >> e;\n\n\t\tconst int n = w * h;\n\t\tint q, a;\n\t\tvector<int> g;\n\n\t\tgraph G(n);\n\n\t\tfor(int i = 0; i < h; ++i) {\n\t\t\tfor(int j = 0; j < w; ++j) {\n\t\t\t\tif(field[i][j] == '#') continue;\n\n\t\t\t\tconst int v = get_index(j, i, w);\n\n\t\t\t\tswitch(field[i][j]) {\n\t\t\t\tcase 'Q': q = v; break;\n\t\t\t\tcase 'A': a = v; break;\n\t\t\t\tcase 'E': g.emplace_back(v); break;\n\t\t\t\t}\n\n\t\t\t\tadd_edge(v, v, G);\n\n\t\t\t\tif(i < h - 1) {\n\t\t\t\t\tif(field[i + 1][j] != '#') {\n\t\t\t\t\t\tadd_edge(v, get_index(j, i + 1, w), G);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif(j < w - 1) {\n\t\t\t\t\tif(field[i][j + 1] != '#') {\n\t\t\t\t\t\tadd_edge(v, get_index(j + 1, i, w), G);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << solve(q, a, g, G) << endl;\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\nconst int MAX = 40;\nint W,H,cq,ca;\nchar field[MAX][MAX];\nint memo[MAX*MAX][MAX*MAX][2]; // dp[Queen][Army][phase( 0 : Queen, 1 : Army )] := state\nint dx[] = {0,0,1,0,-1};\nint dy[] = {0,1,0,-1,0};\n\nbool isValid(int x,int y) { return 0 <= x && x < W && 0 <= y && y < H; }\n\n#define REPEAT 0\n#define ESCAPE 1\n#define CATCH -1\n\nvoid compute(){\n\n  vector<int> E;\n\n  rep(i,H) rep(j,W) {\n    if( field[i][j] == 'Q' ) field[i][j] = '.', cq = j + i * W;\n    if( field[i][j] == 'A' ) field[i][j] = '.', ca  = j + i * W;\n    if( field[i][j] == 'E' ) E.push_back(j+i*W);\n  }\n\n  rep(i,H*W) rep(j,H*W) rep(k,2) memo[i][j][k] = REPEAT;\n  \n  rep(i,(int)E.size()) rep(j,H*W) if( E[i] != j ) memo[E[i]][j][0] = ESCAPE;\n\n  rep(i,H*W) rep(k,2) if( field[i/W][i%W] != '#' ) memo[i][i][k] = CATCH;\n\n  bool update = true;\n  while( update ){\n    update = false;\n    rep(queen,H*W){\n      rep(army,H*W){\n\trep(phase,2){\n\t  if( memo[queen][army][phase] != REPEAT ) continue;\n\t  if( phase ) { // Army\n\t    bool escape = true;\n\t    bool cat = false;\n\t    REP(i,0,5){\n\t      int nx = army % W + dx[i], ny = army / W + dy[i];\n\t      if( !isValid(nx,ny) ) continue;\n\t      if( field[ny][nx] == '#' ) continue;\n\t      if( memo[queen][nx+ny*W][!phase] == CATCH  ) { cat = true; }\n\t      if( memo[queen][nx+ny*W][!phase] != ESCAPE ) { escape = false; }\n\t    }\n\t    if( cat    ) memo[queen][army][phase] = CATCH , update = true;\n\t    if( escape ) memo[queen][army][phase] = ESCAPE, update = true;\n\t  } else { // Queen\n\t    bool escape = false;\n\t    bool cat = true;\n\t    REP(i,0,5) {\n\t      int nx = queen % W + dx[i], ny = queen / W + dy[i];\n\t      if( !isValid(nx,ny) ) continue;\n\t      if( field[ny][nx] == '#' ) continue;\n\t      if( memo[nx+ny*W][army][!phase] == ESCAPE ) { escape = true; }\n\t      if( memo[nx+ny*W][army][!phase] != CATCH  ) { cat = false; }\n\t    }\n\t    if( escape ) memo[queen][army][phase] = ESCAPE, update = true;\n\t    if( cat    ) memo[queen][army][phase] = CATCH , update = true;\n\t  }\n\t}\n      }\n    }\n    /*\n    cout << endl;\n    cout << \"------ \" << endl;\n    rep(i,H*W) rep(j,H*W) {\n      cout << endl;\n      cout << memo[i][j][0] << \" \" << memo[i][j][1] << endl;\n      rep(y,H) {\n\trep(x,W) {\n\t  if( x + y * W == i && i == j ) cout << \"X\";\n\t  else if( x + y * W == i ) cout << \"Q\";\n\t  else if( x + y * W == j ) cout << \"A\";\n\t  else cout << field[y][x];\n\t}\n\tcout << endl;\n      }\n    }\n    */\n  }\n  if( memo[cq][ca][0] == REPEAT ) puts(\"Queen can not escape and Army can not catch Queen.\");\n  else if( memo[cq][ca][0] == ESCAPE ) puts(\"Queen can escape.\");\n  else puts(\"Army can catch Queen.\");\n}\n\nint main(){\n  while( cin >> W >> H, W|H ){\n    rep(i,H) rep(j,W) cin >> field[i][j];\n    compute();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\ntemplate<class T> inline void chmin(T &a, const T &b) { if(a > b) a = b; }\ntemplate<class T> inline void chmax(T &a, const T &b) { if(a < b) a = b; }\n\ntypedef vector<vector<int>> graph;\n\nconstexpr int MAX_N = 900;\n\nenum {ESCAPE, LOOP, CATCH};\nenum {Q, A, NUM};\n\nconst string message[3] = {\n\t\"Queen can escape.\",\n\t\"Queen can not escape and Army can not catch Queen.\",\n\t\"Army can catch Queen.\",\n};\n\nint dp[MAX_N][MAX_N][NUM];\n\ninline void add_edge(int a, int b, graph &G) {\n\tG[a].emplace_back(b);\n\tG[b].emplace_back(a);\n}\n\ninline string solve(int q, int a, const vector<int> &g, const graph &G) {\n\tconst int n = G.size();\n\tfor(int v = 0; v < n; ++v) {\n\t\tfor(int u = 0; u < n; ++u) {\n\t\t\tdp[v][u][Q] = dp[v][u][A] = LOOP;\n\t\t}\n\t}\n\n\tfor(int v = 0; v < n; ++v) {\n\t\tdp[v][v][Q] = dp[v][v][A] = CATCH;\n\t}\n\n\tfor(const auto &e : g) {\n\t\tfor(int v = 0; v < n; ++v) {\n\t\t\tif(e != v) dp[e][v][Q] = ESCAPE;\n\t\t}\n\t}\n\n\twhile(true) {\n\t\tbool update = false;\n\n\t\tfor(int v = 0; v < n; ++v) {\n\t\t\tfor(int u = 0; u < n; ++u) {\n\t\t\t\tif(v == u) continue;\n\n\t\t\t\t// queen turn\n\t\t\t\tif(dp[v][u][Q] != ESCAPE) {\n\t\t\t\t\tconst int prev = dp[v][u][Q];\n\t\t\t\t\tdp[v][u][Q] = CATCH;\n\t\t\t\t\tfor(const auto &to : G[v]) {\n\t\t\t\t\t\tchmin(dp[v][u][Q], dp[to][u][A]);\n\t\t\t\t\t}\n\t\t\t\t\tif(dp[v][u][Q] != prev) update = true;\n\t\t\t\t}\n\n\t\t\t\t// army turn\n\t\t\t\t{\n\t\t\t\t\tconst int prev = dp[v][u][A];\n\t\t\t\t\tdp[v][u][A] = ESCAPE;\n\t\t\t\t\tfor(const auto &to : G[u]) {\n\t\t\t\t\t\tchmax(dp[v][u][A], dp[v][to][Q]);\n\t\t\t\t\t}\n\t\t\t\t\tif(dp[v][u][A] != prev) update = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(!update) break;\n\t}\n\n\treturn message[dp[q][a][Q]];\n}\n\nint main() {\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\n\tfor(int w, h; cin >> w >> h && w;) {\n\t\tvector<string> field(h);\n\t\tfor(auto &e : field) cin >> e;\n\n\t\tint next_label = 0;\n\t\tvector<vector<int>> label(h, vector<int>(w, -1));\n\t\tfor(int i = 0; i < h; ++i) {\n\t\t\tfor(int j = 0; j < w; ++j) {\n\t\t\t\tif(field[i][j] != '#') label[i][j] = next_label++;\n\t\t\t}\n\t\t}\n\n\t\tint q, a;\n\t\tvector<int> g;\n\n\t\tgraph G(next_label);\n\n\t\tfor(int i = 0; i < h; ++i) {\n\t\t\tfor(int j = 0; j < w; ++j) {\n\t\t\t\tif(field[i][j] == '#') continue;\n\n\t\t\t\tconst int v = label[i][j];\n\n\t\t\t\tswitch(field[i][j]) {\n\t\t\t\tcase 'Q': q = v; break;\n\t\t\t\tcase 'A': a = v; break;\n\t\t\t\tcase 'E': g.emplace_back(v); break;\n\t\t\t\t}\n\n\t\t\t\tadd_edge(v, v, G);\n\n\t\t\t\tif(i < h - 1) {\n\t\t\t\t\tif(field[i + 1][j] != '#') {\n\t\t\t\t\t\tadd_edge(v, label[i + 1][j], G);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif(j < w - 1) {\n\t\t\t\t\tif(field[i][j + 1] != '#') {\n\t\t\t\t\t\tadd_edge(v, label[i][j + 1], G);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << solve(q, a, g, G) << endl;\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\n\nint dx[]={-1,0,1,0};\nint dy[]={0,-1,0,1};\n\nbool ck[30][30][30][30];\nint dist[30][30][30][30];\nint relt[30][30][30][30];\nint W,H,gx[900],gy[900],gN;\nchar f[31][31];\n\nclass State\n{\npublic:\n\tint x,y,c;\n\tState(int x, int y, int c)\n\t:x(x),y(y),c(c)\n\t{}\n};\n\nvoid bfs(int x, int y)\n{\n\tbool hs[30][30]={0};\n\t\n\tqueue<State> q;\n\tq.push(State(x,y,0));\n\ths[x][y]=1;\n\t\n\twhile(!q.empty())\n\t{\n\t\tState s=q.front(); q.pop();\n\t\tdist[x][y][s.x][s.y]=s.c;\n\t\t\n\t\tfor(int i=0; i<4; i++)\n\t\t{\n\t\t\tint tx=s.x+dx[i], ty=s.y+dy[i];\n\t\t\tif(tx<0||ty<0||tx>=W||ty>=H) continue;\n\t\t\tif(f[tx][ty]=='#') continue;\n\t\t\tif(hs[tx][ty]) continue;\n\t\t\t\n\t\t\ths[tx][ty]=1;\n\t\t\t\n\t\t\tq.push(State(tx,ty,s.c+1));\n\t\t}\n\t}\n}\n\nvoid calcD()\n{\n\tfor(int i=0; i<H; i++)\n\tfor(int j=0; j<W; j++)\n\t{\n\t\tif(f[j][i]=='#') continue;\n\t\tbfs(j,i);\n\t}\n}\n\nbool cg(int qx, int qy, int ax, int ay)\n{\n\tif(qx==ax&&qy==ay) return false;\n\tbool hs[30][30]={0};\n\t\n\tqueue<State> q;\n\tq.push(State(qx,qy,0));\n\ths[qx][qy]=1;\n\t\n\twhile(!q.empty())\n\t{\n\t\tState s=q.front(); q.pop();\n\t\tif(f[s.x][s.y]=='E') return true;\n\t\t\n\t\tfor(int i=0; i<4; i++)\n\t\t{\n\t\t\tint tx=s.x+dx[i], ty=s.y+dy[i];\n\t\t\tif(tx<0||ty<0||tx>=W||ty>=H) continue;\n\t\t\tif(f[tx][ty]=='#') continue;\n\t\t\tif(tx==ax&&ty==ay) continue;\n\t\t\tif(hs[tx][ty]) continue;\n\t\t\t\n\t\t\ths[tx][ty]=1;\n\t\t\t\n\t\t\tq.push(State(tx,ty,s.c+1));\n\t\t}\n\t}\n\t\n\treturn false;\n}\n\nint judge(int qx, int qy, int ax, int ay)\n{\t\n\tint cnt=0;\n\tfor(int k=0; k<gN; k++)\n\t{\n\t\tif(dist[qx][qy][gx[k]][gy[k]] < dist[ax][ay][gx[k]][gy[k]]) return 1;\n\t}\n\tfor(int i=0; i<H; i++)\n\tfor(int j=0; j<W; j++)\n\t{\n\t\tif(f[j][i]=='#') continue;\n\t\tif(dist[qx][qy][j][i]==-1) continue;\n\t\tif(dist[qx][qy][j][i]==dist[ax][ay][j][i]) cnt++;\n\t\t\n\t}\n\tif(!cg(qx,qy,ax,ay)) return -1;\n\tif(cnt>=2) return 0;\n\treturn -1;\n}\n\nvoid Search()\n{\n\tfor(int i=0; i<H; i++)\n\tfor(int j=0; j<W; j++)\n\t{\n\t\tif(f[j][i]=='#') continue;\n\t\tfor(int k=0; k<H; k++)\n\t\tfor(int l=0; l<W; l++)\n\t\t{\n\t\t\tif(f[l][k]=='#') continue;\n\t\t\trelt[j][i][l][k]=judge(j,i,l,k);\n\t\t}\n\t}\n}\n\nint Aphase(int a, int b, int x, int y);\nint Qphase(int a, int b, int x, int y);\n\nint Aphase(int a, int b, int x, int y, int d)\n{\n\tint ret=relt[a][b][x][y];\n\tfor(int i=0; i<H; i++)\n\tfor(int j=0; j<W; j++)\n\t{\n\t\tif(f[j][i]=='#') continue;\n\t\tif(dist[x][y][j][i]==-1) continue;\n\t\tif(ck[a][b][j][i]) continue;\n\t\t\n\t\tif(relt[a][b][j][i]>relt[a][b][x][y]) continue;\n\t\tif(dist[x][y][j][i]<=d)\n\t\t{\n\t\t\tret=min(ret, relt[a][b][j][i]);\n\t\t}\n\t}\n\t\n\tfor(int i=0; i<H; i++)\n\tfor(int j=0; j<W; j++)\n\t{\n\t\tif(f[j][i]=='#') continue;\n\t\tif(dist[x][y][j][i]==-1) continue;\n\t\tif(ck[a][b][j][i]) continue;\n\t\t\n\t\tck[a][b][j][i]=1;\n\t\t\n\t\tif(relt[a][b][j][i]>ret) continue;\n\t\tif(dist[x][y][j][i]<=d)\n\t\t{\n\t\t\tret=min(ret, Qphase(a,b,j,i));\n\t\t}\n\t\t\n\t}\n\treturn ret;\n}\n\nint Qphase(int a, int b, int x, int y)\n{\n\tint ret=-1;\n\tfor(int i=0; i<H; i++)\n\tfor(int j=0; j<W; j++)\n\t{\n\t\tif(f[j][i]=='#') continue;\n\t\tif(dist[a][b][j][i]>=dist[x][y][j][i]) continue;\n\t\tif(dist[a][b][j][i]==-1) continue;\n\t\t\n\t\tret=max(ret, Aphase(a,b,x,y,dist[a][b][j][i]));\n\t}\n\t\n\treturn ret;\n}\n\nint main()\n{\n\twhile(cin >> W >> H, (W||H))\n\t{\n\t\tint ax,ay,qx,qy;\n\t\tgN=0;\n\t\tmemset(dist, -1, sizeof(dist));\n\t\tmemset(ck,0,sizeof(ck));\n\t\tfor(int i=0; i<H; i++)\n\t\tfor(int j=0; j<W; j++)\n\t\t{\n\t\t\tcin >> f[j][i];\n\t\t\tif(f[j][i]=='A')\n\t\t\t{\n\t\t\t\tax=j; ay=i;\n\t\t\t}\n\t\t\tif(f[j][i]=='Q')\n\t\t\t{\n\t\t\t\tqx=j; qy=i;\n\t\t\t}\n\t\t\tif(f[j][i]=='E')\n\t\t\t{\n\t\t\t\tgx[gN]=j;\n\t\t\t\tgy[gN]=i;\n\t\t\t\tgN++;\n\t\t\t}\n\t\t}\n\t\t\n\t\tcalcD();\n\t\tSearch();\n\t\t\n\t\tint ret=Qphase(qx,qy,ax,ay);\n\t\tif(ret==-1) \tcout << \"Army can catch Queen.\" << endl;\n\t\telse if(ret==0)\tcout << \"Queen can not escape and Army can not catch Queen.\" << endl;\n\t\telse\t\t\tcout << \"Queen can escape.\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\n\nint dx[]={-1,0,1,0};\nint dy[]={0,-1,0,1};\n\nbool ck[30][30][30][30]; // ax,ay qx,qy\nint dist[30][30][30][30]; // xy to x'y'\nint relt[30][30][30][30];\nint memo[30][30][30][30];\nint W,H,gx[900],gy[900],gN;\nchar f[31][31];\n\nclass State\n{\npublic:\n\tint x,y,c;\n\tState(int x, int y, int c)\n\t:x(x),y(y),c(c)\n\t{}\n};\n\nvoid bfs(int x, int y)\n{\n\tbool hs[30][30]={0};\n\t\n\tqueue<State> q;\n\tq.push(State(x,y,0));\n\ths[x][y]=1;\n\t\n\twhile(!q.empty())\n\t{\n\t\tState s=q.front(); q.pop();\n\t\tdist[x][y][s.x][s.y]=s.c;\n\t\t\n\t\tfor(int i=0; i<4; i++)\n\t\t{\n\t\t\tint tx=s.x+dx[i], ty=s.y+dy[i];\n\t\t\tif(tx<0||ty<0||tx>=W||ty>=H) continue;\n\t\t\tif(f[tx][ty]=='#') continue;\n\t\t\tif(hs[tx][ty]) continue;\n\t\t\t\n\t\t\ths[tx][ty]=1;\n\t\t\t\n\t\t\tq.push(State(tx,ty,s.c+1));\n\t\t}\n\t}\n}\n\nvoid calcD()\n{\n\tfor(int i=0; i<H; i++)\n\tfor(int j=0; j<W; j++)\n\t{\n\t\tif(f[j][i]=='#') continue;\n\t\tbfs(j,i);\n\t}\n}\n\nint judge(int qx, int qy, int ax, int ay)\n{\n\tint cnt=0;\n\tfor(int k=0; k<gN; k++)\n\t{\n\t\tif(dist[qx][qy][gx[k]][gy[k]] < dist[ax][ay][gx[k]][gy[k]]) return 1;\n\t\t\n\t\tif(dist[qx][qy][gx[k]][gy[k]] == dist[ax][ay][gx[k]][gy[k]]) cnt++;\n\t}\n\tif(cnt>=2) return 0;\n\treturn -1;\n}\n\nvoid Search()\n{\n\tfor(int i=0; i<H; i++)\n\tfor(int j=0; j<W; j++)\n\t{\n\t\tif(f[j][i]=='#') continue;\n\t\tfor(int k=0; k<H; k++)\n\t\tfor(int l=0; l<W; l++)\n\t\t{\n\t\t\t\n\t\t\tif(f[l][k]=='#') continue;\n\t\t\trelt[j][i][l][k]=judge(j,i,l,k);\n\t\t}\n\t}\n}\n\nint Aphase(int a, int b, int x, int y);\nint Qphase(int a, int b, int x, int y);\n\nint Aphase(int a, int b, int x, int y, int d)\n{\n\tint ret=relt[a][b][x][y];\n\tfor(int i=0; i<H; i++)\n\tfor(int j=0; j<W; j++)\n\t{\n\t\tif(f[j][i]=='#') continue;\n\t\tif(dist[x][y][j][i]<=d)\n\t\t{\n\t\t\tbool g=true;\n\t\t\tfor(int k=0; k<gN; k++)\n\t\t\t{\n\t\t\t\tif(dist[a][b][gx[k]][gy[k]] < dist[j][i][gx[k]][gy[k]])\n\t\t\t\t{\n\t\t\t\t\tg=false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!g) continue;\n\n\t\t\tret=min(ret, Qphase(a,b,j,i));\n\t\t\t\n\t\t}\n\t}\n\treturn ret;\n}\n\nint Qphase(int a, int b, int x, int y)\n{\n\tif(ck[a][b][x][y]) return memo[a][b][x][y];\n\tck[a][b][x][y]=1;\n\tmemo[a][b][x][y]=relt[a][b][x][y];\n\n\tfor(int i=0; i<H; i++)\n\tfor(int j=0; j<W; j++)\n\t{\n\t\tif(j==a&&i==b) continue;\n\t\tif(ck[j][i][x][y]) return memo[j][i][x][y];\n\t\tif(f[j][i]=='#') continue;\n\t\tif(dist[a][b][j][i]>=dist[x][y][j][i]) continue;\n\t\t\n\t\tmemo[a][b][x][y]=max(memo[a][b][x][y], Aphase(j,i,x,y,dist[a][b][j][i]));\n\t}\n\t\n\t\n\treturn memo[a][b][x][y];\n}\n\nint main()\n{\n\twhile(cin >> W >> H, (W||H))\n\t{\n\t\tint ax,ay,qx,qy;\n\t\tgN=0;\n\t\tmemset(ck,0,sizeof(ck));\n\t\tfor(int i=0; i<H; i++)\n\t\tfor(int j=0; j<W; j++)\n\t\t{\n\t\t\tcin >> f[j][i];\n\t\t\tif(f[j][i]=='A')\n\t\t\t{\n\t\t\t\tax=j; ay=i;\n\t\t\t}\n\t\t\tif(f[j][i]=='Q')\n\t\t\t{\n\t\t\t\tqx=j; qy=i;\n\t\t\t}\n\t\t\tif(f[j][i]=='E')\n\t\t\t{\n\t\t\t\tgx[gN]=j;\n\t\t\t\tgy[gN]=i;\n\t\t\t\tgN++;\n\t\t\t}\n\t\t}\n\t\t\n\t\tcalcD();\n\t\tSearch();\n\t\t\n\t\tint ret=Qphase(qx,qy,ax,ay);\n\t\tif(ret==-1) \tcout << \"Army can catch Queen.\" << endl;\n\t\telse if(ret==0)\tcout << \"Queen can not escape and Army can not catch Queen.\" << endl;\n\t\telse\t\t\tcout << \"Queen can escape.\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\n\nint dx[]={-1,0,1,0};\nint dy[]={0,-1,0,1};\n\nbool ck[30][30][30][30]; // ax,ay qx,qy\nint dist[30][30][30][30]; // xy to x'y'\nint relt[30][30][30][30];\nint memo[30][30][30][30];\nint W,H,gx[900],gy[900],gN;\nchar f[31][31];\n\nclass State\n{\npublic:\n\tint x,y,c;\n\tState(int x, int y, int c)\n\t:x(x),y(y),c(c)\n\t{}\n};\n\nvoid bfs(int x, int y)\n{\n\tbool hs[30][30]={0};\n\t\n\tqueue<State> q;\n\tq.push(State(x,y,0));\n\ths[x][y]=1;\n\t\n\twhile(!q.empty())\n\t{\n\t\tState s=q.front(); q.pop();\n\t\tdist[x][y][s.x][s.y]=s.c;\n\t\t\n\t\tfor(int i=0; i<4; i++)\n\t\t{\n\t\t\tint tx=s.x+dx[i], ty=s.y+dy[i];\n\t\t\tif(tx<0||ty<0||tx>=W||ty>=H) continue;\n\t\t\tif(f[tx][ty]=='#') continue;\n\t\t\tif(hs[tx][ty]) continue;\n\t\t\t\n\t\t\ths[tx][ty]=1;\n\t\t\t\n\t\t\tq.push(State(tx,ty,s.c+1));\n\t\t}\n\t}\n}\n\nvoid calcD()\n{\n\tfor(int i=0; i<H; i++)\n\tfor(int j=0; j<W; j++)\n\t{\n\t\tif(f[j][i]=='#') continue;\n\t\tbfs(j,i);\n\t}\n}\n\nint judge(int qx, int qy, int ax, int ay)\n{\n\tint cnt=0;\n\tfor(int k=0; k<gN; k++)\n\t{\n\t\tif(dist[qx][qy][gx[k]][gy[k]] < dist[ax][ay][gx[k]][gy[k]]) return 1;\n\t\t\n\t\tif(dist[qx][qy][gx[k]][gy[k]] == dist[ax][ay][gx[k]][gy[k]]) cnt++;\n\t}\n\tif(cnt>=2) return 0;\n\treturn -1;\n}\n\nvoid Search()\n{\n\tfor(int i=0; i<H; i++)\n\tfor(int j=0; j<W; j++)\n\t{\n\t\tif(f[j][i]=='#') continue;\n\t\tfor(int k=0; k<H; k++)\n\t\tfor(int l=0; l<W; l++)\n\t\t{\n\t\t\t\n\t\t\tif(f[l][k]=='#') continue;\n\t\t\trelt[j][i][l][k]=judge(j,i,l,k);\n\t\t}\n\t}\n}\n\nint Aphase(int a, int b, int x, int y);\nint Qphase(int a, int b, int x, int y);\n\nint Aphase(int a, int b, int x, int y, int d)\n{\n\tint ret=relt[a][b][x][y];\n\tfor(int i=0; i<H; i++)\n\tfor(int j=0; j<W; j++)\n\t{\n\t\tif(f[j][i]=='#') continue;\n\t\tif(dist[x][y][j][i]<=d)\n\t\t{\n\t\t\tbool g=true;\n\t\t\tfor(int k=0; k<gN; k++)\n\t\t\t{\n\t\t\t\tif(dist[a][b][gx[k]][gy[k]] < dist[j][i][gx[k]][gy[k]])\n\t\t\t\t{\n\t\t\t\t\tg=false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!g) continue;\n\n\t\t\tret=min(ret, Qphase(a,b,j,i));\n\t\t\t\n\t\t}\n\t}\n\treturn ret;\n}\n\nint Qphase(int a, int b, int x, int y)\n{\n\tif(ck[a][b][x][y]) return memo[a][b][x][y];\n\tck[a][b][x][y]=1;\n\tmemo[a][b][x][y]=relt[a][b][x][y];\n\n\tfor(int i=0; i<H; i++)\n\tfor(int j=0; j<W; j++)\n\t{\n\t\tif(j==a&&i==b) continue;\n\t\tif(dist[a][b][j][i]>=dist[x][y][j][i]) continue;\n\t\tif(f[j][i]=='#') continue;\n\t\t\n\t\tif(ck[j][i][x][y]) return memo[j][i][x][y];\n\t\t\n\t\tmemo[a][b][x][y]=max(memo[a][b][x][y], Aphase(j,i,x,y,dist[a][b][j][i]));\n\t}\n\t\n\treturn memo[a][b][x][y];\n}\n\nint main()\n{\n\twhile(cin >> W >> H, (W||H))\n\t{\n\t\tint ax,ay,qx,qy;\n\t\tgN=0;\n\t\tmemset(ck,0,sizeof(ck));\n\t\tfor(int i=0; i<H; i++)\n\t\tfor(int j=0; j<W; j++)\n\t\t{\n\t\t\tcin >> f[j][i];\n\t\t\tif(f[j][i]=='A')\n\t\t\t{\n\t\t\t\tax=j; ay=i;\n\t\t\t}\n\t\t\tif(f[j][i]=='Q')\n\t\t\t{\n\t\t\t\tqx=j; qy=i;\n\t\t\t}\n\t\t\tif(f[j][i]=='E')\n\t\t\t{\n\t\t\t\tgx[gN]=j;\n\t\t\t\tgy[gN]=i;\n\t\t\t\tgN++;\n\t\t\t}\n\t\t}\n\t\t\n\t\tcalcD();\n\t\tSearch();\n\t\t\n\t\tint ret=Qphase(qx,qy,ax,ay);\n\t\tif(ret==-1) \tcout << \"Army can catch Queen.\" << endl;\n\t\telse if(ret==0)\tcout << \"Queen can not escape and Army can not catch Queen.\" << endl;\n\t\telse\t\t\tcout << \"Queen can escape.\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXH = 31;\nconst int MAXW = 31;\nconst int di[] = {0,1,0,-1,0};\nconst int dj[] = {1,0,-1,0,0};\nint W, H;\nchar G[MAXH][MAXW];\nint mem[MAXH][MAXW][MAXH][MAXW][2];\n\nint main() {\n  while(cin >> W >> H && (W|H)) {\n    int sqi, sqj, sei, sej;\n    for(int i = 0; i < H; ++i) {\n      for(int j = 0; j < W; ++j) {\n        cin >> G[i][j];\n        if(G[i][j] == 'Q') {\n          sqi = i;\n          sqj = j;\n        }\n        if(G[i][j] == 'A') {\n          sei = i;\n          sej = j;\n        }\n      }\n    }\n    \n    fill(mem[0][0][0][0], mem[0][0][0][0] + sizeof(mem)/sizeof(int), 1);\n    for(int qi = 0; qi < H; ++qi) {\n      for(int qj = 0; qj < W; ++qj) {\n        for(int ei = 0; ei < H; ++ei) {\n          for(int ej = 0; ej < W; ++ej) {\n            for(int t = 0; t < 2; ++t) {\n              int &now = mem[qi][qj][ei][ej][t];\n              if(G[qi][qj] == 'E' && t == 0) now = 2;\n              if(qi == ei && qj == ej) now = 0;\n            }\n          }\n        }\n      }\n    }\n    \n    for(bool update = true; update;) {\n      update = false;\n      for(int qi = 0; qi < H; ++qi) {\n        for(int qj = 0; qj < W; ++qj) {\n          for(int ei = 0; ei < H; ++ei) {\n            for(int ej = 0; ej < W; ++ej) {\n              for(int t = 0; t < 2; ++t) {\n                int &now = mem[qi][qj][ei][ej][t];\n                if(now != 1) continue;\n                int tmp = t * 2;\n                for(int k = 0; k < 5; ++k) {\n                  int nqi =  t ? qi : qi + di[k];\n                  int nqj =  t ? qj : qj + dj[k];\n                  int nei = !t ? ei : ei + di[k];\n                  int nej = !t ? ej : ej + dj[k];\n                  if(nqi < 0 || nqi >= H) continue;\n                  if(nqj < 0 || nqj >= W) continue;\n                  if(nei < 0 || nei >= H) continue;\n                  if(nej < 0 || nej >= W) continue;\n                  if(G[nqi][nqj] == '#') continue;\n                  if(G[nei][nej] == '#') continue;\n                  if(t) tmp = min(tmp, mem[nqi][nqj][nei][nej][1-t]);\n                  else  tmp = max(tmp, mem[nqi][nqj][nei][nej][1-t]);\n                }\n                if(tmp != 1) {\n                  now = tmp;\n                  update = true;\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n    int res = mem[sqi][sqj][sei][sej][0];\n    if(res == 0) cout << \"Army can catch Queen.\" << endl;\n    else if(res == 1) cout << \"Queen can not escape and Army can not catch Queen.\" << endl;\n    else cout << \"Queen can escape.\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\n\nint dx[]={-1,0,1,0};\nint dy[]={0,-1,0,1};\n\nbool ck[30][30][30][30]; // ax,ay qx,qy\nint dist[30][30][30][30]; // xy to x'y'\nint relt[30][30][30][30];\nint memo[30][30][30][30];\nint W,H,gx[900],gy[900],gN;\nchar f[31][31];\n\nclass State\n{\npublic:\n\tint x,y,c;\n\tState(int x, int y, int c)\n\t:x(x),y(y),c(c)\n\t{}\n};\n\nvoid bfs(int x, int y)\n{\n\tbool hs[30][30]={0};\n\t\n\tqueue<State> q;\n\tq.push(State(x,y,0));\n\ths[x][y]=1;\n\t\n\twhile(!q.empty())\n\t{\n\t\tState s=q.front(); q.pop();\n\t\tdist[x][y][s.x][s.y]=s.c;\n\t\t\n\t\tfor(int i=0; i<4; i++)\n\t\t{\n\t\t\tint tx=s.x+dx[i], ty=s.y+dy[i];\n\t\t\tif(tx<0||ty<0||tx>=W||ty>=H) continue;\n\t\t\tif(f[tx][ty]=='#') continue;\n\t\t\tif(hs[tx][ty]) continue;\n\t\t\t\n\t\t\ths[tx][ty]=1;\n\t\t\t\n\t\t\tq.push(State(tx,ty,s.c+1));\n\t\t}\n\t}\n}\n\nvoid calcD()\n{\n\tfor(int i=0; i<H; i++)\n\tfor(int j=0; j<W; j++)\n\t{\n\t\tif(f[j][i]=='#') continue;\n\t\tbfs(j,i);\n\t}\n}\n\n/*\nint judge(int qx, int qy, int ax, int ay)\n{\n\tint cnt=0;\n\tfor(int k=0; k<gN; k++)\n\t{\n\t\tif(dist[qx][qy][gx[k]][gy[k]] < dist[ax][ay][gx[k]][gy[k]]) return 1;\n\t\t\n\t\tif(dist[qx][qy][gx[k]][gy[k]] == dist[ax][ay][gx[k]][gy[k]]) cnt++;\n\t}\n\tif(cnt>=2) return 0;\n\treturn -1;\n}*/\n\nint judge(int qx, int qy, int ax, int ay)\n{\n\tint cnt=0;\n\tfor(int k=0; k<gN; k++)\n\t{\n\t\tif(dist[qx][qy][gx[k]][gy[k]] < dist[ax][ay][gx[k]][gy[k]]) return 1;\n\t}\n\tfor(int i=0; i<H; i++)\n\tfor(int j=0; j<W; j++)\n\t{\n\t\tif(f[j][i]=='#') continue;\n\t\tif(dist[qx][qy][j][i]==dist[ax][ay][j][i]) cnt++;\n\t}\n\tif(cnt>=2) return 0;\n\treturn -1;\n}\n\nvoid Search()\n{\n\tfor(int i=0; i<H; i++)\n\tfor(int j=0; j<W; j++)\n\t{\n\t\tif(f[j][i]=='#') continue;\n\t\tfor(int k=0; k<H; k++)\n\t\tfor(int l=0; l<W; l++)\n\t\t{\n\t\t\t\n\t\t\tif(f[l][k]=='#') continue;\n\t\t\trelt[j][i][l][k]=judge(j,i,l,k);\n\t\t}\n\t}\n}\n\nint Aphase(int a, int b, int x, int y);\nint Qphase(int a, int b, int x, int y);\n\nint Aphase(int a, int b, int x, int y, int d)\n{\n\tint ret=relt[a][b][x][y];\n\tfor(int i=0; i<H; i++)\n\tfor(int j=0; j<W; j++)\n\t{\n\t\tif(f[j][i]=='#') continue;\n\t\tif(relt[a][b][j][i]>relt[a][b][x][y]) continue;\n\t\tif(dist[x][y][j][i]<=d)\n\t\t{\n\t\t\tbool g=true;\n\t\t\tfor(int k=0; k<gN; k++)\n\t\t\t{\n\t\t\t\tif(dist[a][b][gx[k]][gy[k]] < dist[j][i][gx[k]][gy[k]])\n\t\t\t\t{\n\t\t\t\t\tg=false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!g) continue;\n\n\t\t\tret=min(ret, Qphase(a,b,j,i));\n\t\t}\n\t}\n\treturn ret;\n}\n\nint Qphase(int a, int b, int x, int y)\n{\n\tif(ck[a][b][x][y]) return memo[a][b][x][y];\n\tck[a][b][x][y]=1;\n\tmemo[a][b][x][y]=relt[a][b][x][y];\n\n\tfor(int i=0; i<H; i++)\n\tfor(int j=0; j<W; j++)\n\t{\n\t\tif(dist[a][b][j][i]>=dist[x][y][j][i]) continue;\n\t\tif(f[j][i]=='#') continue;\n\t\t\n\t\tif(!ck[j][i][x][y]) memo[j][i][x][y]=Aphase(j,i,x,y,dist[a][b][j][i]);\n\t\tmemo[a][b][x][y]=max(memo[a][b][x][y], memo[j][i][x][y]);\n\t}\n\t\n\treturn memo[a][b][x][y];\n}\n\nint main()\n{\n\twhile(cin >> W >> H, (W||H))\n\t{\n\t\tint ax,ay,qx,qy;\n\t\tgN=0;\n\t\tmemset(ck,0,sizeof(ck));\n\t\tfor(int i=0; i<H; i++)\n\t\tfor(int j=0; j<W; j++)\n\t\t{\n\t\t\tcin >> f[j][i];\n\t\t\tif(f[j][i]=='A')\n\t\t\t{\n\t\t\t\tax=j; ay=i;\n\t\t\t}\n\t\t\tif(f[j][i]=='Q')\n\t\t\t{\n\t\t\t\tqx=j; qy=i;\n\t\t\t}\n\t\t\tif(f[j][i]=='E')\n\t\t\t{\n\t\t\t\tgx[gN]=j;\n\t\t\t\tgy[gN]=i;\n\t\t\t\tgN++;\n\t\t\t}\n\t\t}\n\t\t\n\t\tcalcD();\n\t\tSearch();\n\t\t\n\t\tint ret=Qphase(qx,qy,ax,ay);\n\t\tif(ret==-1) \tcout << \"Army can catch Queen.\" << endl;\n\t\telse if(ret==0)\tcout << \"Queen can not escape and Army can not catch Queen.\" << endl;\n\t\telse\t\t\tcout << \"Queen can escape.\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nconst int dy[] = {0, 1, 0, -1, 0};\nconst int dx[] = {0, 0, 1, 0, -1};\n\nconst int WIN = -1;\nconst int LOSE = -2;\n\nclass Data\n{\npublic:\n    int y1, x1, y2, x2, turn;\n    Data(int y01, int x01, int y02, int x02, int turn0)\n    {\n        y1 = y01;\n        x1 = x01;\n        y2 = y02;\n        x2 = x02;\n        turn = turn0;\n    }\n    int toInt()\n    {\n        return (((y1 * 32 + x1) * 32 + y2) * 32 + x2) * 2 + turn;\n    }\n};\n\nint main()\n{\n    for(;;){\n        int h, w;\n        cin >> w >> h;\n        if(w == 0)\n            return 0;\n\n        vector<string> s(h+2, string(w+2, '#'));\n        int qy, qx, ay, ax;\n        for(int y=1; y<=h; ++y){\n            for(int x=1; x<=w; ++x){\n                cin >> s[y][x];\n                if(s[y][x] == 'Q'){\n                    qy = y;\n                    qx = x;\n                }else if(s[y][x] == 'A'){\n                    ay = y;\n                    ax = x;\n                }\n            }\n        }\n        \n        vector<vector<int> > adjacent(h+2, vector<int>(w+2));\n        for(int y=1; y<=h; ++y){\n            for(int x=1; x<=w; ++x){\n                for(int i=0; i<5; ++i){\n                    if(s[y+dy[i]][x+dx[i]] != '#')\n                        ++ adjacent[y][x];\n                }\n            }\n        }\n\n        vector<int> memo(32*32*32*32*2, 0);\n        queue<Data> q;\n        for(int y1=1; y1<=h; ++y1){\n            for(int x1=1; x1<=w; ++x1){\n                if(s[y1][x1] == '#')\n                    continue;\n                Data d(y1, x1, y1, x1, 0);\n                memo[d.toInt()] = LOSE;\n                q.push(d);\n\n                if(s[y1][x1] != 'E')\n                    continue;\n                for(int y2=1; y2<=h; ++y2){\n                    for(int x2=1; x2<=w; ++x2){\n                        if(s[y2][x2] == '#' || (y1 == y2 && x1 == x2))\n                            continue;\n                        Data d(y1, x1, y2, x2, 0);\n                        memo[d.toInt()] = WIN;\n                        q.push(d);\n                    }\n                }\n            }\n        }\n\n        while(!q.empty()){\n            Data d = q.front();\n            int k = d.toInt();\n            q.pop();\n\n            for(int i=0; i<5; ++i){\n                Data d2 = d;\n                swap(d2.y1, d2.y2);\n                swap(d2.x1, d2.x2);\n                d2.y1 += dy[i];\n                d2.x1 += dx[i];\n                d2.turn ^= 1;\n                if(s[d2.y1][d2.x1] == '#')\n                    continue;\n\n                int k2 = d2.toInt();\n\n                if(memo[k2] == WIN || memo[k2] == LOSE)\n                    continue;\n\n                if(memo[k] == WIN){\n                    ++ memo[k2];\n                    if(memo[k2] == adjacent[d2.y1][d2.x1]){\n                        memo[k2] = LOSE;\n                        q.push(d2);\n                    }\n                }else{\n                    memo[k2] = WIN;\n                    q.push(d2);\n                }\n            }\n        }\n\n        Data d(qy, qx, ay, ax, 0);\n        int k = d.toInt();\n        if(memo[k] == WIN)\n            cout << \"Queen can escape.\" << endl;\n        else if(memo[k] == LOSE)\n            cout << \"Army can catch Queen.\" << endl;\n        else\n            cout << \"Queen can not escape and Army can not catch Queen.\" << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define GET_MACRO(_1,_2,_3,_4,_5,_6,NAME,...) NAME\n#define pr(...) GET_MACRO(__VA_ARGS__,pr6,pr5,pr4,pr3,pr2,pr1)(__VA_ARGS__)\n#define Pr(a) (#a)<<\"=\"<<(a)<<\" \"\n#define pr1(a) cerr<<Pr(a)<<endl\n#define pr2(a,b) cerr<<Pr(a)<<Pr(b)<<endl\n#define pr3(a,b,c) cerr<<Pr(a)<<Pr(b)<<Pr(c)<<endl\n#define pr4(a,b,c,d) cerr<<Pr(a)<<Pr(b)<<Pr(c)<<Pr(d)<<endl\n#define pr5(a,b,c,d,e) cerr<<Pr(a)<<Pr(b)<<Pr(c)<<Pr(d)<<Pr(e)<<endl\n#define pr6(a,b,c,d,e,f) cerr<<Pr(a)<<Pr(b)<<Pr(c)<<Pr(d)<<Pr(e)<<Pr(f)<<endl\n#define int long long\n#define double long double\nusing namespace std;\nconst int INF = 1LL<<55;\nconst int mod = (1e9)+7;\nconst double EPS = 1e-8;\nconst double PI = 6.0 * asin(0.5);\ntypedef pair<int,int> P;\ntypedef long long ll;\ntemplate<class T> T Max(T &a,T b){return a=max(a,b);}\ntemplate<class T> T Min(T &a,T b){return a=min(a,b);}\nostream& operator<<(ostream& o,P p){return o<<\"(\"<<p.first<<\",\"<<p.second<<\")\";}\nistream& operator>>(istream& i,P &p){return i>>p.first>>p.second;}\nostream& operator<<(ostream& o,vector<auto> &a){int i=0;for(auto t:a)o<<(i++?\" \":\"\")<<t;return o;}\nistream& operator>>(istream& i,vector<auto> &a){for(auto &t:a)i>>t;return i;}\nvoid prArr(auto a,string s=\" \"){int i=0;for(auto t:a)cout<<(i++?s:\"\")<<t;cout<<endl;}\nconst int N = 31;\n\nint h, w;\nvector<string> mp;\nint dx[] = {0, 0, 0, 1, -1};\nint dy[] = {0, 1, -1, 0, 0};\nint in(int x,int y){return 0 <= x && x < w && 0 <= y && y < h;}\nint canMove(int x,int y){return in(x, y) && mp[y][x] != '#';}\n\nint dp[2][N][N][N][N];\nint used[2][N][N][N][N];\nint cnt[2][N][N][N][N];\nint bfs(){\n\n  struct dat{\n    int turn;\n    int y, x;\n    int b, a;\n    dat();\n    dat(int turn,int y,int x,int b,int a):turn(turn), y(y), x(x), b(b), a(a){}\n  };\n  \n  memset(dp,-1,sizeof(dp));\n  memset(used,0,sizeof(used));\n  memset(cnt,0,sizeof(cnt));\n\n  int Qx, Qy, Ax, Ay;\n  for(int i=0;i<h;i++)\n    for(int j=0;j<w;j++){\n      if(mp[i][j] == 'Q') Qx = j, Qy = i;\n      if(mp[i][j] == 'A') Ax = j, Ay = i;\n    }\n  \n  queue<dat> Q;\n  \n  // dp[0]->Q's turn\n  // dp[1]->A's turn\n\n  for(int i=0;i<h;i++)\n    for(int j=0;j<w;j++)\n      for(int b=0;b<h;b++)\n        for(int a=0;a<w;a++){\n          if(mp[i][j] == '#' || mp[b][a] == '#') continue;\n\t  \n          //Qの勝ち確定\n          if((i != b || j != a) && mp[i][j] == 'E') {\n            Q.push(dat(0, i, j, b, a));\n            dp[0][i][j][b][a] = 1;\n            used[0][i][j][b][a] = 1;\n          }\n          \n          //Aの勝ち確定\n          if(i == b && j == a) {\n\t    \n\t    //Qの負け\n\t    {\n\t      Q.push(dat(0, i, j, b, a));\t    \n\t      dp[0][i][j][b][a] = 0;\n\t      used[0][i][j][b][a] = 1;\n\t    }\n\t    \n\t    for(int k=0;k<5;k++){\n              int nb = b + dy[k];\n              int na = a + dx[k];\n              if(!canMove(na, nb) || used[1][i][j][nb][na]) continue;\n\t      Q.push(dat(1, i, j, nb, na));\n\t      dp[1][i][j][nb][na] = 1;\n\t      used[1][i][j][nb][na] = 1;\n\t    }\n\t  }\n\t}\n\n  \n  auto getVal=[&](int turn, int y,int x,int b,int a){\n    int draw = 0;\n    for(int i=0;i<5;i++){\n      int nturn = !turn;\n      int ny = y + (turn == 0? dy[i]:0);\n      int nx = x + (turn == 0? dx[i]:0);\n      int nb = b + (turn == 1? dy[i]:0);\n      int na = a + (turn == 1? dx[i]:0);\n      if(!canMove(nx, ny) || !canMove(na, nb)) continue;\n      if(dp[nturn][ny][nx][nb][na] == 0) return 1LL;\n      if(dp[nturn][ny][nx][nb][na] == -1) draw = 1;\n    }\n    return draw? -1LL:0LL;\n  };\n  \n  while(!Q.empty()){\n    auto t = Q.front(); Q.pop();\n    int turn = t.turn;\n    int y = t.y, x = t.x;\n    int b = t.b, a = t.a;\n    \n    for(int i=0;i<5;i++){\n      int nturn = !turn;\n      int ny = y + (nturn == 0? dy[i]:0);\n      int nx = x + (nturn == 0? dx[i]:0);\n      int nb = b + (nturn == 1? dy[i]:0);\n      int na = a + (nturn == 1? dx[i]:0);\n      if(!canMove(nx,ny) || !canMove(na,nb)) continue;\n      if(used[nturn][ny][nx][nb][na]) continue; \n      \n      int nval = getVal(nturn, ny, nx, nb, na);\n      if(nval == -1) continue;\n      dp[nturn][ny][nx][nb][na] = nval;\n      Q.push(dat(nturn, ny, nx, nb, na));\n      used[nturn][ny][nx][nb][na] = 1;\n    }\n  }\n\n  return dp[0][Qy][Qx][Ay][Ax];\n}\n\n\nsigned main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  while(1){\n    \n    cin>>w>>h;\n    if(w == 0 && h == 0) return 0;\n    mp.clear();\n    mp.resize(h);\n    cin>>mp;\n\n    int ans = bfs();\n    if(ans == -1) cout<<\"Queen can not escape and Army can not catch Queen.\"<<endl;\n    if(ans == 0) cout<<\"Army can catch Queen.\"<<endl;\n    if(ans == 1) cout<<\"Queen can escape.\"<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\ntypedef vector<vector<int>> Graph;\n\nvector<int> solve(Graph&g) {\n\tvector<int>nums(g.size());\n\tGraph revg(g.size());\n\tfor (int i = 0; i < g.size();++i){\n\t\tauto es(g[i]);\n\t\tnums[i] = es.size();\n\t\tfor (auto e : es) {\n\t\t\trevg[e].push_back(i);\n\t\t}\n\t}\n\n\t//1 : win   0 : draw   -1 :loss\n\tvector<int>anss(g.size());\n\tqueue<int>que;\n\tfor (int i = 0; i < g.size(); ++i) {\n\t\tif (!nums[i]) {\n\t\t\tque.push(i);\n\t\t\tanss[i] = -1;\n\t\t}\n\t}\n\twhile (!que.empty()) {\n\t\tint now(que.front());\n\t\tque.pop();\n\t\tif (anss[now] == 1) {\n\t\t\tfor (auto reve : revg[now]) {\n\t\t\t\tnums[reve]--;\n\t\t\t\tif (!nums[reve]&&anss[reve]==0) {\n\t\t\t\t\tanss[reve] = -1;\n\t\t\t\t\tque.push(reve);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if (anss[now] == -1) {\n\t\t\tfor (auto reve : revg[now]) {\n\t\t\t\tif (anss[reve] == 0) {\n\t\t\t\t\tanss[reve] = 1;\n\t\t\t\t\tque.push(reve);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tassert(false);\n\t\t}\n\t}\n\treturn anss;\n}\nconst int SIZE = 30;\nint gethash(int ax, int ay, int bx, int by, int c) {\n\treturn (ax-1)* SIZE * SIZE * SIZE * 2 + (ay-1)* SIZE * SIZE * 2 + (bx-1) * SIZE * 2 + (by-1) * 2 + c+1;\n}\n\nint main() {\n\twhile (true) {\n\t\tint W, H; cin >> W >> H;\n\t\tif (!W)break;\n\t\tvector<vector<int>>field(H + 2, vector<int>(W + 2,-1));\n\t\tint sqx, sqy, sax, say;\n\t\tfor (int i = 0; i < H; ++i) {\n\t\t\tstring st; cin >> st;\n\t\t\tfor (int j = 0; j < W; ++j) {\n\t\t\t\tswitch (st[j]) {\n\t\t\t\tcase 'Q':\n\t\t\t\t\tfield[i + 1][j + 1] = 0;\n\t\t\t\t\tsqx = j + 1; sqy = i + 1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'A':\n\t\t\t\t\tfield[i + 1][j + 1] = 0;\n\t\t\t\t\tsax = j + 1; say = i + 1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '#':\n\t\t\t\t\tbreak;\n\t\t\t\tcase '.':\n\t\t\t\t\tfield[i + 1][j + 1] = 0;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'E':\n\t\t\t\t\tfield[i + 1][j + 1] = 2;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tassert(false);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tGraph g(2000000);\n\t\tint dx[] = { -1,0,1,0,0 };\n\t\tint dy[] = { 0,1,0,-1,0 };\n\t\tfor (int qx = 1; qx < W + 1; ++qx) {\n\t\t\tfor (int qy = 1; qy < H + 1; ++qy) {\n\t\t\t\tfor (int ax = 1; ax < W + 1; ++ax) {\n\t\t\t\t\tfor (int ay = 1; ay < H + 1; ++ay) {\n\t\t\t\t\t\tfor (int nt = 0; nt < 2; ++nt) {\n\t\t\t\t\t\t\tint nowhash = gethash(qx, qy, ax, ay, nt);\n\t\t\t\t\t\t\tif (qx == ax&&qy == ay) {\n\t\t\t\t\t\t\t\tif (nt) {\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\tg[nowhash].push_back(0);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (field[qy][qx] == 2&&nt) {\n\t\t\t\t\t\t\t\tg[nowhash].push_back(0);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfor (int way = 0; way < 5; ++way) {\n\t\t\t\t\t\t\t\tint nqx(qx), nqy(qy), nax(ax), nay(ay);\n\t\t\t\t\t\t\t\tif (nt) {\n\t\t\t\t\t\t\t\t\tnqx += dx[way]; nqy += dy[way];\n\t\t\t\t\t\t\t\t\tif (field[nqy][nqx]==-1) continue;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\tnax += dx[way]; nay += dy[way];\n\t\t\t\t\t\t\t\t\tif ((field[nay][nax]==-1)) continue;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (nax == nqx&&nay == nqy) {\n\t\t\t\t\t\t\t\t\tif (nt) {\n\t\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\tg[nowhash].push_back(0);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tint nexthash = gethash(nqx, nqy, nax, nay, !nt);\n\t\t\t\t\t\t\t\tg[nowhash].push_back(nexthash);\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tauto anss=solve(g);\n\t\tint ans = anss[gethash(sqx, sqy, sax, say, 1)];\n\t\tif (ans == 0)cout << \"Queen can not escape and Army can not catch Queen.\" << endl;\n\t\telse if (ans == 1)cout << \"Queen can escape.\" << endl;\n\t\telse cout << \"Army can catch Queen.\" << endl;\n\t}\n\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\n\nint dx[]={-1,0,1,0};\nint dy[]={0,-1,0,1};\n\nbool lp[30][30];\nbool ck[30][30][30][30];\nint dist[30][30][30][30];\nint relt[30][30][30][30];\nint memo[30][30][30][30];\nint W,H,gx[900],gy[900],gN;\nchar f[31][31];\n\nclass State\n{\npublic:\n\tint x,y,c;\n\tState(int x, int y, int c)\n\t:x(x),y(y),c(c)\n\t{}\n};\n\nvoid bfs(int x, int y)\n{\n\tbool hs[30][30]={0};\n\t\n\tqueue<State> q;\n\tq.push(State(x,y,0));\n\ths[x][y]=1;\n\t\n\twhile(!q.empty())\n\t{\n\t\tState s=q.front(); q.pop();\n\t\tdist[x][y][s.x][s.y]=s.c;\n\t\t\n\t\tfor(int i=0; i<4; i++)\n\t\t{\n\t\t\tint tx=s.x+dx[i], ty=s.y+dy[i];\n\t\t\tif(tx<0||ty<0||tx>=W||ty>=H) continue;\n\t\t\tif(f[tx][ty]=='#') continue;\n\t\t\tif(hs[tx][ty]) continue;\n\t\t\t\n\t\t\ths[tx][ty]=1;\n\t\t\t\n\t\t\tq.push(State(tx,ty,s.c+1));\n\t\t}\n\t}\n}\n\nvoid calcD()\n{\n\tfor(int i=0; i<H; i++)\n\tfor(int j=0; j<W; j++)\n\t{\n\t\tif(f[j][i]=='#') continue;\n\t\tbfs(j,i);\n\t}\n}\n\nbool loop(int qx, int qy, int d)\n{\n\tint sx=qx+dx[d], sy=qy+dy[d];\n\tif(sx<0||sy<0||sx>=W||sy>=H) return false;\n\tif(f[sx][sy]=='#') return false;\n\t\n\tbool hs[30][30]={0};\n\t\n\tqueue<State> q;\n\tq.push(State(sx,sy,0));\n\ths[qx][qy]=1;\n\ths[sx][sy]=1;\n\t\n\twhile(!q.empty())\n\t{\n\t\tState s=q.front(); q.pop();\n\t\t\n\t\tfor(int i=0; i<4; i++)\n\t\t{\n\t\t\tint tx=s.x+dx[i], ty=s.y+dy[i];\n\t\t\tif(tx<0||ty<0||tx>=W||ty>=H) continue;\n\t\t\tif(f[tx][ty]=='#') continue;\n\t\t\tif(tx==qx&&ty==qy)\n\t\t\t{\n\t\t\t\tif(s.c==0) continue;\n\t\t\t\telse return true;\n\t\t\t}\n\t\t\tif(hs[tx][ty]) continue;\n\t\t\t\n\t\t\ths[tx][ty]=1;\n\t\t\t\n\t\t\tq.push(State(tx,ty,s.c+1));\n\t\t}\n\t}\n\t\n\treturn false;\n}\n\nint judge(int qx, int qy, int ax, int ay)\n{\t\n\tfor(int k=0; k<gN; k++)\n\t{\n\t\tif(dist[qx][qy][gx[k]][gy[k]] < dist[ax][ay][gx[k]][gy[k]]) return 1;\n\t}\n\t\n\tif(lp[qx][qy]) return 0;\n\treturn -1;\n}\n\nvoid Search()\n{\n\tfor(int i=0; i<H; i++)\n\tfor(int j=0; j<W; j++)\n\t{\n\t\tif(f[j][i]=='#') continue;\n\t\tfor(int k=0; k<4; k++)\n\t\t{\n\t\t\tif(loop(j,i,k))\n\t\t\t{\n\t\t\t\t lp[j][i]=true;\n\t\t\t\t break;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int k=0; k<H; k++)\n\t\tfor(int l=0; l<W; l++)\n\t\t{\n\t\t\tif(f[l][k]=='#') continue;\n\t\t\trelt[j][i][l][k]=judge(j,i,l,k);\n\t\t}\n\t}\n}\n\nint Aphase(int a, int b, int x, int y);\nint Qphase(int a, int b, int x, int y);\n\nint Aphase(int a, int b, int x, int y, int d)\n{\n\tint ret=relt[a][b][x][y];\n\tfor(int i=0; i<H; i++)\n\tfor(int j=0; j<W; j++)\n\t{\n\t\tif(dist[x][y][j][i]==-1) continue;\n\t\t\n\t\tif(relt[a][b][j][i]>relt[a][b][x][y]) continue;\n\t\tif(dist[x][y][j][i]<=d)\n\t\t{\n\t\t\tret=min(ret, relt[a][b][j][i]);\n\t\t}\n\t}\n\t\n\tfor(int i=0; i<H; i++)\n\tfor(int j=0; j<W; j++)\n\t{\n\t\tif(dist[x][y][j][i]==-1) continue;\n\t\tif(ck[a][b][j][i]) \n\t\t{\n\t\t\tret=min(ret, memo[a][b][j][i]);\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tif(relt[a][b][j][i]>ret) continue;\n\t\tif(dist[x][y][j][i]<=d)\n\t\t{\n\t\t\tret=min(ret, Qphase(a,b,j,i));\n\t\t}\n\t\t\n\t}\n\treturn ret;\n}\n\nint Qphase(int a, int b, int x, int y)\n{\n\tif(ck[a][b][x][y]) return memo[a][b][x][y];\n\tck[a][b][x][y]=1;\n\t\n\tmemo[a][b][x][y]=relt[a][b][x][y];\n\tfor(int i=0; i<H; i++)\n\tfor(int j=0; j<W; j++)\n\t{\n\t\tif(f[j][i]=='#') continue;\n\t\tif(dist[a][b][j][i]>=dist[x][y][j][i]) continue;\n\t\tif(dist[a][b][j][i]==-1) continue;\n\t\t\n\t\tmemo[a][b][x][y]=max(memo[a][b][x][y], Aphase(j,i,x,y,dist[a][b][j][i]));\n\t}\n\t\n\treturn memo[a][b][x][y];\n}\n\nint main()\n{\n\twhile(cin >> W >> H, (W||H))\n\t{\n\t\tint ax,ay,qx,qy;\n\t\tgN=0;\n\t\tmemset(lp,0,sizeof(lp));\n\t\tmemset(dist, -1, sizeof(dist));\n\t\tmemset(ck,0,sizeof(ck));\n\t\tfor(int i=0; i<H; i++)\n\t\tfor(int j=0; j<W; j++)\n\t\t{\n\t\t\tcin >> f[j][i];\n\t\t\tif(f[j][i]=='A')\n\t\t\t{\n\t\t\t\tax=j; ay=i;\n\t\t\t}\n\t\t\tif(f[j][i]=='Q')\n\t\t\t{\n\t\t\t\tqx=j; qy=i;\n\t\t\t}\n\t\t\tif(f[j][i]=='E')\n\t\t\t{\n\t\t\t\tgx[gN]=j;\n\t\t\t\tgy[gN]=i;\n\t\t\t\tgN++;\n\t\t\t}\n\t\t}\n\t\t\n\t\tcalcD();\n\t\tSearch();\n\t\t\n\t\tint ret=Qphase(qx,qy,ax,ay);\n\t\tif(ret==-1) \tcout << \"Army can catch Queen.\" << endl;\n\t\telse if(ret==0)\tcout << \"Queen can not escape and Army can not catch Queen.\" << endl;\n\t\telse\t\t\tcout << \"Queen can escape.\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define GET_MACRO(_1,_2,_3,_4,_5,_6,NAME,...) NAME\n#define pr(...) GET_MACRO(__VA_ARGS__,pr6,pr5,pr4,pr3,pr2,pr1)(__VA_ARGS__)\n#define Pr(a) (#a)<<\"=\"<<(a)<<\" \"\n#define pr1(a) cerr<<Pr(a)<<endl\n#define pr2(a,b) cerr<<Pr(a)<<Pr(b)<<endl\n#define pr3(a,b,c) cerr<<Pr(a)<<Pr(b)<<Pr(c)<<endl\n#define pr4(a,b,c,d) cerr<<Pr(a)<<Pr(b)<<Pr(c)<<Pr(d)<<endl\n#define pr5(a,b,c,d,e) cerr<<Pr(a)<<Pr(b)<<Pr(c)<<Pr(d)<<Pr(e)<<endl\n#define pr6(a,b,c,d,e,f) cerr<<Pr(a)<<Pr(b)<<Pr(c)<<Pr(d)<<Pr(e)<<Pr(f)<<endl\n#define int long long\n#define double long double\nusing namespace std;\nconst int INF = 1LL<<55;\nconst int mod = (1e9)+7;\nconst double EPS = 1e-8;\nconst double PI = 6.0 * asin(0.5);\ntypedef pair<int,int> P;\ntypedef long long ll;\ntemplate<class T> T Max(T &a,T b){return a=max(a,b);}\ntemplate<class T> T Min(T &a,T b){return a=min(a,b);}\nostream& operator<<(ostream& o,P p){return o<<\"(\"<<p.first<<\",\"<<p.second<<\")\";}\nistream& operator>>(istream& i,P &p){return i>>p.first>>p.second;}\nostream& operator<<(ostream& o,vector<auto> &a){int i=0;for(auto t:a)o<<(i++?\" \":\"\")<<t;return o;}\nistream& operator>>(istream& i,vector<auto> &a){for(auto &t:a)i>>t;return i;}\nvoid prArr(auto a,string s=\" \"){int i=0;for(auto t:a)cout<<(i++?s:\"\")<<t;cout<<endl;}\nconst int N = 31;\n\nint h, w;\nvector<string> mp;\nint dx[] = {0, 0, 0, 1, -1};\nint dy[] = {0, 1, -1, 0, 0};\nint in(int x,int y){return 0 <= x && x < w && 0 <= y && y < h;}\nint canMove(int x,int y){return in(x, y) && mp[y][x] != '#';}\n\nint dp[2][N][N][N][N];\nint used[2][N][N][N][N];\nint cnt[2][N][N][N][N];\nint bfs(){\n\n  struct dat{\n    int turn;\n    int y, x;\n    int b, a;\n    dat();\n    dat(int turn,int y,int x,int b,int a):turn(turn), y(y), x(x), b(b), a(a){}\n  };\n  \n  memset(dp,-1,sizeof(dp));\n  memset(used,0,sizeof(used));\n  memset(cnt,0,sizeof(cnt));\n\n  int Qx, Qy, Ax, Ay;\n  for(int i=0;i<h;i++)\n    for(int j=0;j<w;j++){\n      if(mp[i][j] == 'Q') Qx = j, Qy = i;\n      if(mp[i][j] == 'A') Ax = j, Ay = i;\n    }\n  \n  queue<dat> Q;\n  \n  // dp[0]->Q's turn\n  // dp[1]->A's turn\n\n  for(int i=0;i<h;i++)\n    for(int j=0;j<w;j++)\n      for(int b=0;b<h;b++)\n        for(int a=0;a<w;a++){\n          if(mp[i][j] == '#' || mp[b][a] == '#') continue;\n\t  \n          //Qの勝ち確定\n          if((i != b || j != a) && mp[i][j] == 'E') {\n            Q.push(dat(0, i, j, b, a));\n            dp[0][i][j][b][a] = 1;\n            used[0][i][j][b][a] = 1;\n          }\n          \n          //Aの勝ち確定\n          if(i == b && j == a) {\n\t    \n\t    //Qの負け\n\t    {\n\t      Q.push(dat(0, i, j, b, a));\t    \n\t      dp[0][i][j][b][a] = 0;\n\t      used[0][i][j][b][a] = 1;\n\t    }\n\t    \n\t    for(int k=0;k<5;k++){\n              int nb = b + dy[k];\n              int na = a + dx[k];\n              if(!canMove(na, nb) || used[1][i][j][nb][na]) continue;\n\t      Q.push(dat(1, i, j, nb, na));\n\t      dp[1][i][j][nb][na] = 1;\n\t      used[1][i][j][nb][na] = 1;\n\t    }\n\t  }\n\t}\n\n  \n  auto getVal=[&](int turn, int y,int x,int b,int a){\n    int draw = 0;\n    for(int i=0;i<5;i++){\n      int nturn = !turn;\n      int ny = y + (turn == 0? dy[i]:0);\n      int nx = x + (turn == 0? dx[i]:0);\n      int nb = b + (turn == 1? dy[i]:0);\n      int na = a + (turn == 1? dx[i]:0);\n      if(!canMove(nx, ny) || !canMove(na, nb)) continue;\n      if(dp[nturn][ny][nx][nb][na] == 0) return 1LL;\n      if(dp[nturn][ny][nx][nb][na] == -1) draw = 1;\n    }\n    return draw? -1LL:0LL;\n  };\n  \n  while(!Q.empty()){\n    auto t = Q.front(); Q.pop();\n    int turn = t.turn;\n    int y = t.y, x = t.x;\n    int b = t.b, a = t.a;\n    \n    for(int i=0;i<5;i++){\n      int nturn = !turn;\n      int ny = y + (nturn == 0? dy[i]:0);\n      int nx = x + (nturn == 0? dx[i]:0);\n      int nb = b + (nturn == 1? dy[i]:0);\n      int na = a + (nturn == 1? dx[i]:0);\n      if(!canMove(nx,ny) || !canMove(na,nb)) continue;\n      if(used[nturn][ny][nx][nb][na]) continue; \n      \n      int nval = getVal(nturn, ny, nx, nb, na);\n      if(nval == -1) continue;\n      dp[nturn][ny][nx][nb][na] = nval;\n      Q.push(dat(nturn, ny, nx, nb, na));\n      used[nturn][ny][nx][nb][na] = 1;\n    }\n  }\n\n  return dp[0][Qy][Qx][Ay][Ax];\n}\n\n\nsigned main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  while(1){\n    \n    cin>>w>>h;\n    if(w == 0 && h == 0) return 0;\n    mp.clear();\n    mp.resize(h);\n    cin>>mp;\n\n    int ans = bfs();\n    if(ans == -1) cout<<\"Queen can not escape and Army can not catch Queen.\"<<endl;\n    if(ans == 0) cout<<\"Army can catch Queen.\"<<endl;\n    if(ans == 1) cout<<\"Queen can escape.\"<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\ntypedef vector<vector<int>> Graph;\n\nvector<int> solve(Graph&g) {\n\tvector<int>nums(g.size());\n\tGraph revg(g.size());\n\tfor (int i = 0; i < g.size();++i){\n\t\tauto es(g[i]);\n\t\tnums[i] = es.size();\n\t\tfor (auto e : es) {\n\t\t\trevg[e].push_back(i);\n\t\t}\n\t}\n\n\t//1 : win   0 : draw   -1 :loss\n\tvector<int>anss(g.size());\n\tqueue<int>que;\n\tfor (int i = 0; i < g.size(); ++i) {\n\t\tif (!nums[i]) {\n\t\t\tque.push(i);\n\t\t\tanss[i] = -1;\n\t\t}\n\t}\n\twhile (!que.empty()) {\n\t\tint now(que.front());\n\t\tque.pop();\n\t\tif (anss[now] == 1) {\n\t\t\tfor (auto reve : revg[now]) {\n\t\t\t\tnums[reve]--;\n\t\t\t\tif (!nums[reve]&&anss[reve]==0) {\n\t\t\t\t\tanss[reve] = -1;\n\t\t\t\t\tque.push(reve);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if (anss[now] == -1) {\n\t\t\tfor (auto reve : revg[now]) {\n\t\t\t\tif (anss[reve] == 0) {\n\t\t\t\t\tanss[reve] = 1;\n\t\t\t\t\tque.push(reve);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tassert(false);\n\t\t}\n\t}\n\treturn anss;\n}\nconst int SIZE = 32;\nint gethash(int ax, int ay, int bx, int by, int c) {\n\treturn (ax-1)* SIZE * SIZE * SIZE * 2 + (ay-1)* SIZE * SIZE * 2 + (bx-1) * SIZE * 2 + (by-1) * 2 + c+1;\n}\n\nint main() {\n\twhile (true) {\n\t\tint W, H; cin >> W >> H;\n\t\tif (!W)break;\n\t\tvector<vector<int>>field(H + 2, vector<int>(W + 2,-1));\n\t\tint sqx, sqy, sax, say;\n\t\tfor (int i = 0; i < H; ++i) {\n\t\t\tstring st; cin >> st;\n\t\t\tfor (int j = 0; j < W; ++j) {\n\t\t\t\tswitch (st[j]) {\n\t\t\t\tcase 'Q':\n\t\t\t\t\tfield[i + 1][j + 1] = 0;\n\t\t\t\t\tsqx = j + 1; sqy = i + 1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'A':\n\t\t\t\t\tfield[i + 1][j + 1] = 0;\n\t\t\t\t\tsax = j + 1; say = i + 1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '#':\n\t\t\t\t\tbreak;\n\t\t\t\tcase '.':\n\t\t\t\t\tfield[i + 1][j + 1] = 0;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'E':\n\t\t\t\t\tfield[i + 1][j + 1] = 2;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tassert(false);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tGraph g(3000000);\n\t\tint dx[] = { -1,0,1,0,0 };\n\t\tint dy[] = { 0,1,0,-1,0 };\n\t\tfor (int qx = 1; qx < W + 1; ++qx) {\n\t\t\tfor (int qy = 1; qy < H + 1; ++qy) {\n\t\t\t\tfor (int ax = 1; ax < W + 1; ++ax) {\n\t\t\t\t\tfor (int ay = 1; ay < H + 1; ++ay) {\n\t\t\t\t\t\tfor (int nt = 0; nt < 2; ++nt) {\n\t\t\t\t\t\t\tint nowhash = gethash(qx, qy, ax, ay, nt);\n\t\t\t\t\t\t\tif (qx == ax&&qy == ay) {\n\t\t\t\t\t\t\t\tif (nt) {\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\tg[nowhash].push_back(0);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (field[qy][qx] == 2&&nt) {\n\t\t\t\t\t\t\t\tg[nowhash].push_back(0);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfor (int way = 0; way < 5; ++way) {\n\t\t\t\t\t\t\t\tint nqx(qx), nqy(qy), nax(ax), nay(ay);\n\t\t\t\t\t\t\t\tif (nt) {\n\t\t\t\t\t\t\t\t\tnqx += dx[way]; nqy += dy[way];\n\t\t\t\t\t\t\t\t\tif (field[nqy][nqx]==-1) continue;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\tnax += dx[way]; nay += dy[way];\n\t\t\t\t\t\t\t\t\tif ((field[nay][nax]==-1)) continue;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (nax == nqx&&nay == nqy) {\n\t\t\t\t\t\t\t\t\tif (nt) {\n\t\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\tg[nowhash].push_back(0);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tint nexthash = gethash(nqx, nqy, nax, nay, !nt);\n\t\t\t\t\t\t\t\tg[nowhash].push_back(nexthash);\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tauto anss=solve(g);\n\t\tint ans = anss[gethash(sqx, sqy, sax, say, 1)];\n\t\tif (ans == 0)cout << \"Queen can not escape and Army can not catch Queen.\" << endl;\n\t\telse if (ans == 1)cout << \"Queen can escape.\" << endl;\n\t\telse cout << \"Army can catch Queen.\" << endl;\n\t}\n\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcountll\n\n#define INF 1e16\n#define mod 1000000007\n\nint W,H;\nstring s[33];\nint ai,aj,qi,qj;\nint st[33][33][33][33][2];\nint rest[33][33][33][33][2];\nint dd[]={-1,0,0,1,0,-1};\n\nstruct state{\n  int qi,qj,ai,aj,t;\n};\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  while(1){\n    cin>>W>>H;\n    if(W==0)break;\n    rep(i,H){\n      cin>>s[i];\n      rep(j,W){\n        if(s[i][j]=='A'){\n          ai=i; aj=j;\n        }\n        if(s[i][j]=='Q'){\n          qi=i; qj=j;\n        }\n      }\n    }\n    memset(st,-1,sizeof(st));\n    memset(rest,0,sizeof(rest));\n    queue<state> que;\n    rep(sqi,H)rep(sqj,W)rep(sai,H)rep(saj,W)rep(tt,2){\n      if(s[sqi][sqj]=='#'||s[sai][saj]=='#')continue;\n\n      if(s[sqi][sqj]=='E'&&!(sqi==sai&&sqj==saj)&&tt==0){\n        que.push((state){sqi,sqj,sai,saj,tt});\n        st[sqi][sqj][sai][saj][tt]=1;\n      }else if(sqi==sai&&sqj==saj){\n        que.push((state){sqi,sqj,sai,saj,tt});\n        st[sqi][sqj][sai][saj][tt]=0;\n      }else if(tt==0){\n        rep(d,5){\n          int nqi=sqi+dd[d],nqj=sqj+dd[d+1];\n          if(nqi<0||nqi>=H||nqj<0||nqj>=W||s[nqi][nqj]=='#')continue;\n          rest[sqi][sqj][sai][saj][tt]++;\n        }\n      }else if(tt==1){\n        rep(d,5){\n          int nai=sai+dd[d],naj=saj+dd[d+1];\n          if(nai<0||nai>=H||naj<0||naj>=W||s[nai][naj]=='#')continue;\n          rest[sqi][sqj][sai][saj][tt]++;\n        }\n      }\n    }\n\n    while(que.size()){\n      state c=que.front(); que.pop();\n      int crtst=st[c.qi][c.qj][c.ai][c.aj][c.t];\n      if(c.t==1){\n        rep(d,5){\n          int nqi=c.qi+dd[d],nqj=c.qj+dd[d+1];\n          if(nqi<0||nqi>=H||nqj<0||nqj>=W||s[nqi][nqj]=='#'||\n            st[nqi][nqj][c.ai][c.aj][1-c.t]!=-1)continue;\n            if(crtst==1){\n              que.push((state){nqi,nqj,c.ai,c.aj,1-c.t});\n              st[nqi][nqj][c.ai][c.aj][1-c.t]=1;\n              continue;\n            }\n            rest[nqi][nqj][c.ai][c.aj][1-c.t]--;\n            if(rest[nqi][nqj][c.ai][c.aj][1-c.t]==0){\n              que.push((state){nqi,nqj,c.ai,c.aj,1-c.t});\n              st[nqi][nqj][c.ai][c.aj][1-c.t]=0;\n            }\n          }\n        }else if(c.t==0){\n          rep(d,5){\n            int nai=c.ai+dd[d],naj=c.aj+dd[d+1];\n            if(nai<0||nai>=H||naj<0||naj>=W||s[nai][naj]=='#'||\n              st[c.qi][c.qj][nai][naj][1-c.t]!=-1)continue;\n              if(crtst==0){\n                que.push((state){c.qi,c.qj,nai,naj,1-c.t});\n                st[c.qi][c.qj][nai][naj][1-c.t]=0;\n                continue;\n              }\n              rest[c.qi][c.qj][nai][naj][1-c.t]--;\n              if(rest[c.qi][c.qj][nai][naj][1-c.t]==0){\n                que.push((state){c.qi,c.qj,nai,naj,1-c.t});\n                st[c.qi][c.qj][nai][naj][1-c.t]=1;\n              }\n            }\n          }\n        }\n\n        if(st[qi][qj][ai][aj][0]==-1)cout<<\"Queen can not escape and Army can not catch Queen.\"<<endl;\n        if(st[qi][qj][ai][aj][0]==0) cout<<\"Army can catch Queen.\"<<endl;\n        if(st[qi][qj][ai][aj][0]==1) cout<<\"Queen can escape.\"<<endl;\n      }\n      return 0;\n    }\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\n\nint dx[]={-1,0,1,0};\nint dy[]={0,-1,0,1};\n\nbool ck[30][30][30][30]; // ax,ay qx,qy\nint dist[30][30][30][30]; // xy to x'y'\nint relt[30][30][30][30];\nint memo[30][30][30][30];\nint W,H,gx[900],gy[900],gN;\nchar f[31][31];\n\nclass State\n{\npublic:\n\tint x,y,c;\n\tState(int x, int y, int c)\n\t:x(x),y(y),c(c)\n\t{}\n};\n\nvoid bfs(int x, int y)\n{\n\tbool hs[30][30]={0};\n\t\n\tqueue<State> q;\n\tq.push(State(x,y,0));\n\ths[x][y]=1;\n\t\n\twhile(!q.empty())\n\t{\n\t\tState s=q.front(); q.pop();\n\t\tdist[x][y][s.x][s.y]=s.c;\n\t\t\n\t\tfor(int i=0; i<4; i++)\n\t\t{\n\t\t\tint tx=s.x+dx[i], ty=s.y+dy[i];\n\t\t\tif(tx<0||ty<0||tx>=W||ty>=H) continue;\n\t\t\tif(f[tx][ty]=='#') continue;\n\t\t\tif(hs[tx][ty]) continue;\n\t\t\t\n\t\t\ths[tx][ty]=1;\n\t\t\t\n\t\t\tq.push(State(tx,ty,s.c+1));\n\t\t}\n\t}\n}\n\nvoid calcD()\n{\n\tfor(int i=0; i<H; i++)\n\tfor(int j=0; j<W; j++)\n\t{\n\t\tif(f[j][i]=='#') continue;\n\t\tbfs(j,i);\n\t}\n}\n\nint judge(int qx, int qy, int ax, int ay)\n{\n\tint cnt=0;\n\tfor(int k=0; k<gN; k++)\n\t{\n\t\tif(dist[qx][qy][gx[k]][gy[k]] < dist[ax][ay][gx[k]][gy[k]]) return 1;\n\t\t\n\t\tif(dist[qx][qy][gx[k]][gy[k]] == dist[ax][ay][gx[k]][gy[k]]) cnt++;\n\t}\n\tif(cnt>=2) return 0;\n\treturn -1;\n}\n\nvoid Search()\n{\n\tfor(int i=0; i<H; i++)\n\tfor(int j=0; j<W; j++)\n\t{\n\t\tif(f[j][i]=='#') continue;\n\t\tfor(int k=0; k<H; k++)\n\t\tfor(int l=0; l<W; l++)\n\t\t{\n\t\t\t\n\t\t\tif(f[l][k]=='#') continue;\n\t\t\trelt[j][i][l][k]=judge(j,i,l,k);\n\t\t}\n\t}\n}\n\nint Aphase(int a, int b, int x, int y);\nint Qphase(int a, int b, int x, int y);\n\nint Aphase(int a, int b, int x, int y, int d)\n{\n\tint ret=relt[a][b][x][y];\n\tfor(int i=0; i<H; i++)\n\tfor(int j=0; j<W; j++)\n\t{\n\t\tif(f[j][i]=='#') continue;\n\t\tif(dist[x][y][j][i]<=d)\n\t\t{\n\t\t\tbool g=true;\n\t\t\tfor(int k=0; k<gN; k++)\n\t\t\t{\n\t\t\t\tif(dist[a][b][gx[k]][gy[k]] < dist[j][i][gx[k]][gy[k]])\n\t\t\t\t{\n\t\t\t\t\tg=false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!g) continue;\n\n\t\t\tret=min(ret, Qphase(a,b,j,i));\n\t\t\t\n\t\t}\n\t}\n\treturn ret;\n}\n\nint Qphase(int a, int b, int x, int y)\n{\n\tif(ck[a][b][x][y]) return memo[a][b][x][y];\n\tck[a][b][x][y]=1;\n\tmemo[a][b][x][y]=relt[a][b][x][y];\n\n\tfor(int i=0; i<H; i++)\n\tfor(int j=0; j<W; j++)\n\t{\n\t\tif(j==a&&i==b) continue;\n\t\tif(dist[a][b][j][i]>=dist[x][y][j][i]) continue;\n\t\tif(f[j][i]=='#') continue;\n\t\t\n\t\tif(ck[j][i][x][y]) memo[a][b][x][y]=max(memo[a][b][x][y], memo[j][i][x][y]);\n\t\telse memo[a][b][x][y]=max(memo[a][b][x][y], Aphase(j,i,x,y,dist[a][b][j][i]));\n\t}\n\t\n\treturn memo[a][b][x][y];\n}\n\nint main()\n{\n\twhile(cin >> W >> H, (W||H))\n\t{\n\t\tint ax,ay,qx,qy;\n\t\tgN=0;\n\t\tmemset(ck,0,sizeof(ck));\n\t\tfor(int i=0; i<H; i++)\n\t\tfor(int j=0; j<W; j++)\n\t\t{\n\t\t\tcin >> f[j][i];\n\t\t\tif(f[j][i]=='A')\n\t\t\t{\n\t\t\t\tax=j; ay=i;\n\t\t\t}\n\t\t\tif(f[j][i]=='Q')\n\t\t\t{\n\t\t\t\tqx=j; qy=i;\n\t\t\t}\n\t\t\tif(f[j][i]=='E')\n\t\t\t{\n\t\t\t\tgx[gN]=j;\n\t\t\t\tgy[gN]=i;\n\t\t\t\tgN++;\n\t\t\t}\n\t\t}\n\t\t\n\t\tcalcD();\n\t\tSearch();\n\t\t\n\t\tint ret=Qphase(qx,qy,ax,ay);\n\t\tif(ret==-1) \tcout << \"Army can catch Queen.\" << endl;\n\t\telse if(ret==0)\tcout << \"Queen can not escape and Army can not catch Queen.\" << endl;\n\t\telse\t\t\tcout << \"Queen can escape.\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define pb         push_back\n\nenum RES{DRAW=-1,WIN,LOSE};\n\nclass state{\npublic:\n  bool who;//0 queen 1 army\n  int q,a;\n};\n\n\nenum RES win[2][900][900];\nint need[2][900][900];\nvector<state> edge[2][900][900];\n\n\nint dx[]={0,0,1,-1,0};\nint dy[]={1,-1,0,0,0};\nchar m[30][30];\n\nbool out(int y,int x,int r,int c){\n  return y<0||x<0||y>=r||x>=c;\n}\n\nint md(int y,int x,int yy,int xx){\n  return max(y,yy)-min(y,yy)+max(x,xx)-min(x,xx);\n}\n\nvoid solve(int q,int a,int r,int c){\n  rep(i,2){\n    rep(j,r*c){\n      rep(k,r*c){\n\twin[i][j][k]=DRAW;\n\tedge[i][j][k].clear();\n\tneed[i][j][k]=0;\n      }\n    }\n  }\n  \n  rep(qi,r){\n    rep(qj,c){\n      if (m[qi][qj] == '#')continue;\n      rep(ai,r){\n\trep(aj,c){\n\t  if (m[ai][aj] == '#')continue;\n\t  rep(k,5){\n\t    int nex=qj+dx[k],ney=qi+dy[k];\n\t    if (out(ney,nex,r,c)||m[ney][nex] == '#')continue;\n\n\t    need[0][qi*c+qj][ai*c+aj]++;\n\t    edge[1][ney*c+nex][ai*c+aj].pb((state){0,qi*c+qj,ai*c+aj});\n\t  }\n\t  rep(k,5){\n\t    int nex=aj+dx[k],ney=ai+dy[k];\n\t    if (out(ney,nex,r,c)||m[ney][nex] == '#')continue;\n\t    need[1][qi*c+qj][ai*c+aj]++;\n\t    edge[0][qi*c+qj][ney*c+nex].pb((state){1,qi*c+qj,ai*c+aj});\n\t  }\n\t}\n      }\n    }\n  }\n\n  queue<state> Q;\n  //win q\n  rep(i,r){\n    rep(j,c){\n      if (m[i][j] == '#')continue;\n      rep(ii,r){\n\trep(jj,c){\n\t  if (m[ii][jj] == '#'||(ii==i&&jj==j))continue;\n\t  if (m[i][j] == 'E'){// && md(i,j,ii,jj)>1){\n\t    win[0][i*c+j][ii*c+jj]=WIN;\n\t    Q.push((state){0,i*c+j,ii*c+jj});\n\t  }\n\t  if (m[i][j] == 'E' && md(i,j,ii,jj) > 1){\n\t    win[1][i*c+j][ii*c+jj]=LOSE;\n\t    Q.push((state){1,i*c+j,ii*c+jj});\n\t  }\n\t}\n      }\n    }\n  }\n  \n\n  //win a\n  rep(i,r){\n    rep(j,c){\n      if (m[i][j] == '#')continue;\n      rep(k,4){\n\tint nex=j+dx[k],ney=i+dy[k];\n\tif (out(ney,nex,r,c)||m[ney][nex]=='#'){\n\t  continue;\n\t}\n\tif (win[1][i*c+j][ney*c+nex] == DRAW){\n\t  win[1][i*c+j][ney*c+nex]=WIN;\n\t  Q.push((state){1,i*c+j,ney*c+nex});\n\t}\n      }\n    }\n  }\n  \n\n  \n  rep(i,r){\n    rep(j,c){\n      if (m[i][j] == '#')continue;\n      if (win[0][i*c+j][i*c+j] == DRAW){\n\twin[0][i*c+j][i*c+j]=LOSE;\n\tQ.push((state){0,i*c+j,i*c+j});\n      }\n      if (win[1][i*c+j][i*c+j] == DRAW){\n\twin[1][i*c+j][i*c+j]=WIN;\n\tQ.push((state){1,i*c+j,i*c+j});\n      }\n    }\n  }\n  \n\n  while(!Q.empty()){\n    state now = Q.front();Q.pop();\n    //cout << now.who <<\" \" << now.q <<\" \" << now.a <<\" \" << win[now.who][now.q][now.a] << endl;\n    \n    rep(i,edge[now.who][now.q][now.a].size()){\n      state next=edge[now.who][now.q][now.a][i];\n      need[next.who][next.q][next.a]--;\n      //      if (next.who == 0 &&next.q == 0 && next.a == 1)\n      //\tcout <<now.who <<\" \" <<  now.q <<\" \" << now.a << endl;\n\n      if (win[next.who][next.q][next.a] != DRAW)continue;\n      if (win[now.who][now.q][now.a] == LOSE){\n\twin[next.who][next.q][next.a]=WIN;\n\tQ.push(next);\n      }else if (need[next.who][next.q][next.a] == 0 && \n\t\twin[next.who][next.q][next.a]  == DRAW){\n\twin[next.who][next.q][next.a]=LOSE;\n\tQ.push(next);\n      }\n    }\n  }\n\n  //  cout << need[0][q][a]<<endl;\n  if (win[0][q][a] == LOSE)cout << \"Army can catch Queen.\" << endl;\n  else if (win[0][q][a] == WIN)cout << \"Queen can escape.\" << endl;\n  else cout << \"Queen can not escape and Army can not catch Queen.\"<<endl;\n  return;\n}\n\n\nmain(){\n  int r,c;\n  while(cin>>c>>r && c){\n    rep(i,r){\n      rep(j,c)cin>>m[i][j];\n    }\n    int q,a;\n    rep(i,r){\n      rep(j,c){\n\tif (m[i][j] == 'Q')q=i*c+j;\n\tif (m[i][j] == 'A')a=i*c+j;\n      }\n    }\n    solve(q,a,r,c);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define pb         push_back\n\nenum RES{DRAW=-1,WIN,LOSE};\n\nclass state{\npublic:\n  bool who;//0 queen 1 army\n  short q,a;\n};\n\n\nenum RES win[2][900][900];\nchar need[2][900][900];\nvector<state> edge[2][900][900];\n\nint dx[]={0,0,1,-1,0};\nint dy[]={1,-1,0,0,0};\nchar m[30][30];\n\nbool out(int y,int x,int r,int c){\n  return y<0||x<0||y>=r||x>=c;\n}\n\nint md(int y,int x,int yy,int xx){\n  return max(y,yy)-min(y,yy)+max(x,xx)-min(x,xx);\n}\n\nvoid solve(int q,int a,int r,int c){\n  rep(i,2){\n    rep(j,r*c){\n      rep(k,r*c){\n\twin[i][j][k]=DRAW;\n\tedge[i][j][k].clear();\n\tneed[i][j][k]=0;\n      }\n    }\n  }\n  \n  rep(qi,r){\n    rep(qj,c){\n      if (m[qi][qj] == '#')continue;\n      rep(ai,r){\n\trep(aj,c){\n\t  if (m[ai][aj] == '#')continue;\n\t  rep(k,5){\n\t    int nex=qj+dx[k],ney=qi+dy[k];\n\t    if (out(ney,nex,r,c)||m[ney][nex] == '#')continue;\n\n\t    need[0][qi*c+qj][ai*c+aj]++;\n\t    edge[1][ney*c+nex][ai*c+aj].pb((state){0,qi*c+qj,ai*c+aj});\n\t  }\n\t  rep(k,5){\n\t    int nex=aj+dx[k],ney=ai+dy[k];\n\t    if (out(ney,nex,r,c)||m[ney][nex] == '#')continue;\n\t    need[1][qi*c+qj][ai*c+aj]++;\n\t    edge[0][qi*c+qj][ney*c+nex].pb((state){1,qi*c+qj,ai*c+aj});\n\t  }\n\t}\n      }\n    }\n  }\n\n  queue<state> Q;\n  //win q\n  rep(i,r){\n    rep(j,c){\n      if (m[i][j] == '#')continue;\n      rep(ii,r){\n\trep(jj,c){\n\t  if (m[ii][jj] == '#'||(ii==i&&jj==j))continue;\n\t  if (m[i][j] == 'E'){// && md(i,j,ii,jj)>1){\n\t    win[0][i*c+j][ii*c+jj]=WIN;\n\t    Q.push((state){0,i*c+j,ii*c+jj});\n\t  }\n\t  if (m[i][j] == 'E' && md(i,j,ii,jj) > 1){\n\t    win[1][i*c+j][ii*c+jj]=LOSE;\n\t    Q.push((state){1,i*c+j,ii*c+jj});\n\t  }\n\t}\n      }\n    }\n  }\n  \n\n  //win a\n  rep(i,r){\n    rep(j,c){\n      if (m[i][j] == '#')continue;\n      rep(k,4){\n\tint nex=j+dx[k],ney=i+dy[k];\n\tif (out(ney,nex,r,c)||m[ney][nex]=='#'){\n\t  continue;\n\t}\n\tif (win[1][i*c+j][ney*c+nex] == DRAW){\n\t  win[1][i*c+j][ney*c+nex]=WIN;\n\t  Q.push((state){1,i*c+j,ney*c+nex});\n\t}\n      }\n    }\n  }\n  \n\n  \n  rep(i,r){\n    rep(j,c){\n      if (m[i][j] == '#')continue;\n      if (win[0][i*c+j][i*c+j] == DRAW){\n\twin[0][i*c+j][i*c+j]=LOSE;\n\tQ.push((state){0,i*c+j,i*c+j});\n      }\n      if (win[1][i*c+j][i*c+j] == DRAW){\n\twin[1][i*c+j][i*c+j]=WIN;\n\tQ.push((state){1,i*c+j,i*c+j});\n      }\n    }\n  }\n  \n\n  while(!Q.empty()){\n    state now = Q.front();Q.pop();\n    //cout << now.who <<\" \" << now.q <<\" \" << now.a <<\" \" << win[now.who][now.q][now.a] << endl;\n    \n    rep(i,edge[now.who][now.q][now.a].size()){\n      state next=edge[now.who][now.q][now.a][i];\n      need[next.who][next.q][next.a]--;\n      //      if (next.who == 0 &&next.q == 0 && next.a == 1)\n      //\tcout <<now.who <<\" \" <<  now.q <<\" \" << now.a << endl;\n\n      if (win[next.who][next.q][next.a] != DRAW)continue;\n      if (win[now.who][now.q][now.a] == LOSE){\n\twin[next.who][next.q][next.a]=WIN;\n\tQ.push(next);\n      }else if (need[next.who][next.q][next.a] == 0 && \n\t\twin[next.who][next.q][next.a]  == DRAW){\n\twin[next.who][next.q][next.a]=LOSE;\n\tQ.push(next);\n      }\n    }\n  }\n\n  //  cout << need[0][q][a]<<endl;\n  if (win[0][q][a] == LOSE)cout << \"Army can catch Queen.\" << endl;\n  else if (win[0][q][a] == WIN)cout << \"Queen can escape.\" << endl;\n  else cout << \"Queen can not escape and Army can not catch Queen.\"<<endl;\n  return;\n}\n\n\nmain(){\n  int r,c;\n  while(cin>>c>>r && c){\n    rep(i,r){\n      rep(j,c)cin>>m[i][j];\n    }\n    int q,a;\n    rep(i,r){\n      rep(j,c){\n\tif (m[i][j] == 'Q')q=i*c+j;\n\tif (m[i][j] == 'A')a=i*c+j;\n      }\n    }\n    solve(q,a,r,c);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define pb         push_back\n\nenum RES{DRAW=-1,WIN,LOSE};\n\nclass state{\npublic:\n  bool who;//0 queen 1 army\n  short q,a;\n};\n\n\nenum RES win[2][900][900];\nchar need[2][900][900];\nvector<state> edge[2][900][900];\n\nint dx[]={0,0,1,-1,0};\nint dy[]={1,-1,0,0,0};\nchar m[30][30];\n\nbool out(int y,int x,int r,int c){\n  return y<0||x<0||y>=r||x>=c;\n}\n\nint md(int y,int x,int yy,int xx){\n  return max(y,yy)-min(y,yy)+max(x,xx)-min(x,xx);\n}\n\nvoid solve(int q,int a,int r,int c){\n  rep(i,2){\n    rep(j,r*c){\n      rep(k,r*c){\n\twin[i][j][k]=DRAW;\n\tedge[i][j][k].clear();\n\tneed[i][j][k]=0;\n      }\n    }\n  }\n  \n  rep(qi,r){\n    rep(qj,c){\n      if (m[qi][qj] == '#')continue;\n      rep(ai,r){\n\trep(aj,c){\n\t  if (m[ai][aj] == '#')continue;\n\t  rep(k,5){\n\t    int nex=qj+dx[k],ney=qi+dy[k];\n\t    if (out(ney,nex,r,c)||m[ney][nex] == '#')continue;\n\n\t    need[0][qi*c+qj][ai*c+aj]++;\n\t    edge[1][ney*c+nex][ai*c+aj].pb((state){0,qi*c+qj,ai*c+aj});\n\t  }\n\t  rep(k,5){\n\t    int nex=aj+dx[k],ney=ai+dy[k];\n\t    if (out(ney,nex,r,c)||m[ney][nex] == '#')continue;\n\t    need[1][qi*c+qj][ai*c+aj]++;\n\t    edge[0][qi*c+qj][ney*c+nex].pb((state){1,qi*c+qj,ai*c+aj});\n\t  }\n\t}\n      }\n    }\n  }\n\n  queue<state> Q;\n  //win q\n  rep(i,r){\n    rep(j,c){\n      if (m[i][j] == '#')continue;\n      rep(ii,r){\n\trep(jj,c){\n\t  if (m[ii][jj] == '#'||(ii==i&&jj==j))continue;\n\t  if (m[i][j] == 'E'){\n\t    win[0][i*c+j][ii*c+jj]=WIN;\n\t    Q.push((state){0,i*c+j,ii*c+jj});\n\t  }\n\t}\n      }\n    }\n  }\n  \n\n  //win a\n  rep(i,r){\n    rep(j,c){\n      if (m[i][j] == '#')continue;\n      rep(k,4){\n\tint nex=j+dx[k],ney=i+dy[k];\n\tif (out(ney,nex,r,c)||m[ney][nex]=='#'){\n\t  continue;\n\t}\n\tif (win[1][i*c+j][ney*c+nex] == DRAW){\n\t  win[1][i*c+j][ney*c+nex]=WIN;\n\t  Q.push((state){1,i*c+j,ney*c+nex});\n\t}\n      }\n    }\n  }\n  \n\n  \n  rep(i,r){\n    rep(j,c){\n      if (m[i][j] == '#')continue;\n      if (win[0][i*c+j][i*c+j] == DRAW){\n\twin[0][i*c+j][i*c+j]=LOSE;\n\tQ.push((state){0,i*c+j,i*c+j});\n      }\n      if (win[1][i*c+j][i*c+j] == DRAW){\n\twin[1][i*c+j][i*c+j]=WIN;\n\tQ.push((state){1,i*c+j,i*c+j});\n      }\n    }\n  }\n  \n\n  while(!Q.empty()){\n    state now = Q.front();Q.pop();\n    \n    rep(i,edge[now.who][now.q][now.a].size()){\n      state next=edge[now.who][now.q][now.a][i];\n      need[next.who][next.q][next.a]--;\n\n      if (win[next.who][next.q][next.a] != DRAW)continue;\n      if (win[now.who][now.q][now.a] == LOSE){\n\twin[next.who][next.q][next.a]=WIN;\n\tQ.push(next);\n      }else if (need[next.who][next.q][next.a] == 0 && \n\t\twin[next.who][next.q][next.a]  == DRAW){\n\twin[next.who][next.q][next.a]=LOSE;\n\tQ.push(next);\n      }\n    }\n  }\n\n  if (win[0][q][a] == LOSE)cout << \"Army can catch Queen.\" << endl;\n  else if (win[0][q][a] == WIN)cout << \"Queen can escape.\" << endl;\n  else cout << \"Queen can not escape and Army can not catch Queen.\"<<endl;\n  return;\n}\n\n\nmain(){\n  int r,c;\n  while(cin>>c>>r && c){\n    rep(i,r){\n      rep(j,c)cin>>m[i][j];\n    }\n    int q,a;\n    rep(i,r){\n      rep(j,c){\n\tif (m[i][j] == 'Q')q=i*c+j;\n\tif (m[i][j] == 'A')a=i*c+j;\n      }\n    }\n    solve(q,a,r,c);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define pb         push_back\n\nenum RES{DRAW=-1,WIN,LOSE};\n\nclass state{\npublic:\n  bool who;//0 queen 1 army\n  short q,a;\n};\n\n\nenum RES win[2][900][900];\nchar need[2][900][900];\nvector<state> edge[2][900][900];\n\nint dx[]={0,0,1,-1,0};\nint dy[]={1,-1,0,0,0};\nchar m[30][30];\n\nbool out(int y,int x,int r,int c){\n  return y<0||x<0||y>=r||x>=c;\n}\n\nint md(int y,int x,int yy,int xx){\n  return max(y,yy)-min(y,yy)+max(x,xx)-min(x,xx);\n}\n\nvoid solve(int q,int a,int r,int c){\n  rep(i,2){\n    rep(j,r*c){\n      rep(k,r*c){\n\twin[i][j][k]=DRAW;\n\tedge[i][j][k].clear();\n\tneed[i][j][k]=0;\n      }\n    }\n  }\n  \n  rep(qi,r){\n    rep(qj,c){\n      if (m[qi][qj] == '#')continue;\n      rep(ai,r){\n\trep(aj,c){\n\t  if (m[ai][aj] == '#')continue;\n\t  rep(k,5){\n\t    int nex=qj+dx[k],ney=qi+dy[k];\n\t    if (out(ney,nex,r,c)||m[ney][nex] == '#')continue;\n\n\t    need[0][qi*c+qj][ai*c+aj]++;\n\t    edge[1][ney*c+nex][ai*c+aj].pb((state){0,qi*c+qj,ai*c+aj});\n\t  }\n\t  rep(k,5){\n\t    int nex=aj+dx[k],ney=ai+dy[k];\n\t    if (out(ney,nex,r,c)||m[ney][nex] == '#')continue;\n\t    need[1][qi*c+qj][ai*c+aj]++;\n\t    edge[0][qi*c+qj][ney*c+nex].pb((state){1,qi*c+qj,ai*c+aj});\n\t  }\n\t}\n      }\n    }\n  }\n\n  queue<state> Q;\n  //win q\n  rep(i,r){\n    rep(j,c){\n      if (m[i][j] == '#')continue;\n      rep(ii,r){\n\trep(jj,c){\n\t  if (m[ii][jj] == '#'||(ii==i&&jj==j))continue;\n\t  if (m[i][j] == 'E'){\n\t    win[0][i*c+j][ii*c+jj]=WIN;\n\t    Q.push((state){0,i*c+j,ii*c+jj});\n\t  }\n\t}\n      }\n    }\n  }\n  \n\n  //win a\n  rep(i,r){\n    rep(j,c){\n      if (m[i][j] == '#')continue;\n      rep(k,4){\n\tint nex=j+dx[k],ney=i+dy[k];\n\tif (out(ney,nex,r,c)||m[ney][nex]=='#'){\n\t  continue;\n\t}\n\tif (win[1][i*c+j][ney*c+nex] == DRAW){\n\t  win[1][i*c+j][ney*c+nex]=WIN;\n\t  Q.push((state){1,i*c+j,ney*c+nex});\n\t}\n      }\n    }\n  }\n  \n\n  \n  rep(i,r){\n    rep(j,c){\n      if (m[i][j] == '#')continue;\n      if (win[1][i*c+j][i*c+j] == DRAW){\n\twin[1][i*c+j][i*c+j]=WIN;\n\tQ.push((state){1,i*c+j,i*c+j});\n      }\n    }\n  }\n  \n\n  while(!Q.empty()){\n    state now = Q.front();Q.pop();\n    \n    rep(i,edge[now.who][now.q][now.a].size()){\n      state next=edge[now.who][now.q][now.a][i];\n      need[next.who][next.q][next.a]--;\n\n      if (win[next.who][next.q][next.a] != DRAW)continue;\n      if (win[now.who][now.q][now.a] == LOSE){\n\twin[next.who][next.q][next.a]=WIN;\n\tQ.push(next);\n      }else if (need[next.who][next.q][next.a] == 0 && \n\t\twin[next.who][next.q][next.a]  == DRAW){\n\twin[next.who][next.q][next.a]=LOSE;\n\tQ.push(next);\n      }\n    }\n  }\n\n  if (win[0][q][a] == LOSE)cout << \"Army can catch Queen.\" << endl;\n  else if (win[0][q][a] == WIN)cout << \"Queen can escape.\" << endl;\n  else cout << \"Queen can not escape and Army can not catch Queen.\"<<endl;\n  return;\n}\n\n\nmain(){\n  int r,c;\n  while(cin>>c>>r && c){\n    rep(i,r){\n      rep(j,c)cin>>m[i][j];\n    }\n    int q,a;\n    rep(i,r){\n      rep(j,c){\n\tif (m[i][j] == 'Q')q=i*c+j;\n\tif (m[i][j] == 'A')a=i*c+j;\n      }\n    }\n    solve(q,a,r,c);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<queue>\nusing namespace std;\nint dx[]={1,0,-1,0};\nint dy[]={0,1,0,-1};\nchar str[40][40];\nint qd[40][40];\nint ad[40][40];\nint n,m;\nint v[40][40];\nint s,t;\nint dfs(int a,int b,int c){\n\tv[a][b]=1;\n\tfor(int i=0;i<4;i++){\n\t\tif(~c&&(c^2)==i)continue;\n\t\tif(0<=a+dx[i]&&a+dx[i]<n&&0<=b+dy[i]&&b+dy[i]<m&&str[a+dx[i]][b+dy[i]]!='#'){\n\t\t\tif(v[a+dx[i]][b+dy[i]]){\n\t\t\t\tif(a+dx[i]==s&&b+dy[i]==t)return 1;\n\t\t\t}else{\n\t\t\t\tint res=dfs(a+dx[i],b+dy[i],i);\n\t\t\t\tif(res)return 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nint main(){\n\tint a,b;\n\twhile(scanf(\"%d%d\",&b,&a),a){\n\t\tn=a;m=b;\n\t\tfor(int i=0;i<a;i++)scanf(\"%s\",str[i]);\n\t\tint qr,qc;\n\t\tint ar,ac;\n\t\tfor(int i=0;i<a;i++)for(int j=0;j<b;j++){\n\t\t\tif(str[i][j]=='Q'){qr=i;qc=j;}\n\t\t\tif(str[i][j]=='A'){ar=i;ac=j;}\n\t\t}\n\t\tqueue<pair<int,int> > Q;\n\t\tfor(int i=0;i<a;i++)for(int j=0;j<b;j++)qd[i][j]=ad[i][j]=999999999;\n\t\tQ.push(make_pair(qr,qc));\n\t\tqd[qr][qc]=0;\n\t\twhile(Q.size()){\n\t\t\tint row=Q.front().first;\n\t\t\tint col=Q.front().second;\n\t\t\tQ.pop();\n\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\tif(0<=row+dx[i]&&row+dx[i]<a&&0<=col+dy[i]&&col+dy[i]<b&&str[row+dx[i]][col+dy[i]]!='#'&&qd[row+dx[i]][col+dy[i]]>qd[row][col]+1){\n\t\t\t\t\tqd[row+dx[i]][col+dy[i]]=qd[row][col]+1;\n\t\t\t\t\tQ.push(make_pair(row+dx[i],col+dy[i]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tQ.push(make_pair(ar,ac));\n\t\tad[ar][ac]=0;\n\t\twhile(Q.size()){\n\t\t\tint row=Q.front().first;\n\t\t\tint col=Q.front().second;\n\t\t\tQ.pop();\n\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\tif(0<=row+dx[i]&&row+dx[i]<a&&0<=col+dy[i]&&col+dy[i]<b&&str[row+dx[i]][col+dy[i]]!='#'&&ad[row+dx[i]][col+dy[i]]>ad[row][col]+1){\n\t\t\t\t\tad[row+dx[i]][col+dy[i]]=ad[row][col]+1;\n\t\t\t\t\tQ.push(make_pair(row+dx[i],col+dy[i]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbool ok=false;\n\t\tfor(int i=0;i<a;i++){\n\t\t\tfor(int j=0;j<b;j++){\n\t\t\t\tif(str[i][j]=='E'&&qd[i][j]<ad[i][j])ok=true;\n\t\t\t}\n\t\t}\n\t\tif(ok){\n\t\t\tprintf(\"Queen can escape.\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\tfor(int i=0;i<a;i++)for(int j=0;j<b;j++){\n\t\t\tif(str[i][j]!='#'){\n\t\t\t\tfor(int k=0;k<a;k++)for(int l=0;l<b;l++)v[k][l]=0;\n\t\t\t\ts=i;t=j;\n\t\t\t\tif(dfs(i,j,-1)&&qd[i][j]<ad[i][j])ok=true;\n\t\t\t}\n\t\t}\n\t\tif(ok)printf(\"Queen can not escape and Army can not catch Queen.\\n\");\n\t\telse printf(\"Army can catch Queen.\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define pb         push_back\n\nenum RES{DRAW=-1,WIN,LOSE};\n\nclass state{\npublic:\n  bool who;//0 queen 1 army\n  int q,a;\n};\n\n\nenum RES win[2][900][900];\nchar need[2][900][900];\nvector<state> edge[2][900][900];\n\n\nint dx[]={0,0,1,-1,0};\nint dy[]={1,-1,0,0,0};\nchar m[30][30];\n\nbool out(int y,int x,int r,int c){\n  return y<0||x<0||y>=r||x>=c;\n}\n\nint md(int y,int x,int yy,int xx){\n  return max(y,yy)-min(y,yy)+max(x,xx)-min(x,xx);\n}\n\nvoid solve(int q,int a,int r,int c){\n  rep(i,2){\n    rep(j,r*c){\n      rep(k,r*c){\n\twin[i][j][k]=DRAW;\n\tedge[i][j][k].clear();\n\tneed[i][j][k]=0;\n      }\n    }\n  }\n  \n  rep(qi,r){\n    rep(qj,c){\n      if (m[qi][qj] == '#')continue;\n      rep(ai,r){\n\trep(aj,c){\n\t  if (m[ai][aj] == '#')continue;\n\t  rep(k,5){\n\t    int nex=qj+dx[k],ney=qi+dy[k];\n\t    if (out(ney,nex,r,c)||m[ney][nex] == '#')continue;\n\n\t    need[0][qi*c+qj][ai*c+aj]++;\n\t    edge[1][ney*c+nex][ai*c+aj].pb((state){0,qi*c+qj,ai*c+aj});\n\t  }\n\t  rep(k,5){\n\t    int nex=aj+dx[k],ney=ai+dy[k];\n\t    if (out(ney,nex,r,c)||m[ney][nex] == '#')continue;\n\t    need[1][qi*c+qj][ai*c+aj]++;\n\t    edge[0][qi*c+qj][ney*c+nex].pb((state){1,qi*c+qj,ai*c+aj});\n\t  }\n\t}\n      }\n    }\n  }\n\n  queue<state> Q;\n  //win q\n  rep(i,r){\n    rep(j,c){\n      if (m[i][j] == '#')continue;\n      rep(ii,r){\n\trep(jj,c){\n\t  if (m[ii][jj] == '#'||(ii==i&&jj==j))continue;\n\t  if (m[i][j] == 'E'){// && md(i,j,ii,jj)>1){\n\t    win[0][i*c+j][ii*c+jj]=WIN;\n\t    Q.push((state){0,i*c+j,ii*c+jj});\n\t  }\n\t  if (m[i][j] == 'E' && md(i,j,ii,jj) > 1){\n\t    win[1][i*c+j][ii*c+jj]=LOSE;\n\t    Q.push((state){1,i*c+j,ii*c+jj});\n\t  }\n\t}\n      }\n    }\n  }\n  \n\n  //win a\n  rep(i,r){\n    rep(j,c){\n      if (m[i][j] == '#')continue;\n      rep(k,4){\n\tint nex=j+dx[k],ney=i+dy[k];\n\tif (out(ney,nex,r,c)||m[ney][nex]=='#'){\n\t  continue;\n\t}\n\tif (win[1][i*c+j][ney*c+nex] == DRAW){\n\t  win[1][i*c+j][ney*c+nex]=WIN;\n\t  Q.push((state){1,i*c+j,ney*c+nex});\n\t}\n      }\n    }\n  }\n  \n\n  \n  rep(i,r){\n    rep(j,c){\n      if (m[i][j] == '#')continue;\n      if (win[0][i*c+j][i*c+j] == DRAW){\n\twin[0][i*c+j][i*c+j]=LOSE;\n\tQ.push((state){0,i*c+j,i*c+j});\n      }\n      if (win[1][i*c+j][i*c+j] == DRAW){\n\twin[1][i*c+j][i*c+j]=WIN;\n\tQ.push((state){1,i*c+j,i*c+j});\n      }\n    }\n  }\n  \n\n  while(!Q.empty()){\n    state now = Q.front();Q.pop();\n    //cout << now.who <<\" \" << now.q <<\" \" << now.a <<\" \" << win[now.who][now.q][now.a] << endl;\n    \n    rep(i,edge[now.who][now.q][now.a].size()){\n      state next=edge[now.who][now.q][now.a][i];\n      need[next.who][next.q][next.a]--;\n      //      if (next.who == 0 &&next.q == 0 && next.a == 1)\n      //\tcout <<now.who <<\" \" <<  now.q <<\" \" << now.a << endl;\n\n      if (win[next.who][next.q][next.a] != DRAW)continue;\n      if (win[now.who][now.q][now.a] == LOSE){\n\twin[next.who][next.q][next.a]=WIN;\n\tQ.push(next);\n      }else if (need[next.who][next.q][next.a] == 0 && \n\t\twin[next.who][next.q][next.a]  == DRAW){\n\twin[next.who][next.q][next.a]=LOSE;\n\tQ.push(next);\n      }\n    }\n  }\n\n  //  cout << need[0][q][a]<<endl;\n  if (win[0][q][a] == LOSE)cout << \"Army can catch Queen.\" << endl;\n  else if (win[0][q][a] == WIN)cout << \"Queen can escape.\" << endl;\n  else cout << \"Queen can not escape and Army can not catch Queen.\"<<endl;\n  return;\n}\n\n\nmain(){\n  int r,c;\n  while(cin>>c>>r && c){\n    rep(i,r){\n      rep(j,c)cin>>m[i][j];\n    }\n    int q,a;\n    rep(i,r){\n      rep(j,c){\n\tif (m[i][j] == 'Q')q=i*c+j;\n\tif (m[i][j] == 'A')a=i*c+j;\n      }\n    }\n    solve(q,a,r,c);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXH = 31;\nconst int MAXW = 31;\nconst int di[] = {0,1,0,-1,0};\nconst int dj[] = {1,0,-1,0,0};\nint W, H;\nchar G[MAXH][MAXW];\nint mem[MAXH][MAXW][MAXH][MAXW][2];\n\nint main() {\n  while(cin >> W >> H && (W|H)) {\n    int sqi, sqj, sei, sej;\n    for(int i = 0; i < H; ++i) {\n      for(int j = 0; j < W; ++j) {\n        cin >> G[i][j];\n        if(G[i][j] == 'Q') {\n          sqi = i;\n          sqj = j;\n        }\n        if(G[i][j] == 'A') {\n          sei = i;\n          sej = j;\n        }\n      }\n    }\n    \n    fill(mem[0][0][0][0], mem[0][0][0][0] + sizeof(mem)/sizeof(int), 1);\n    for(int qi = 0; qi < H; ++qi) {\n      for(int qj = 0; qj < W; ++qj) {\n        for(int ei = 0; ei < H; ++ei) {\n          for(int ej = 0; ej < W; ++ej) {\n            for(int t = 0; t < 2; ++t) {\n              int &now = mem[qi][qj][ei][ej][t];\n              if(G[qi][qj] == 'E' && t == 0) now = 2;\n              if(qi == ei && qj == ej) now = 0;\n            }\n          }\n        }\n      }\n    }\n    \n    for(bool update = true; update;) {\n      update = false;\n      for(int qi = 0; qi < H; ++qi) {\n        for(int qj = 0; qj < W; ++qj) {\n          for(int ei = 0; ei < H; ++ei) {\n            for(int ej = 0; ej < W; ++ej) {\n              for(int t = 0; t < 2; ++t) {\n                int &now = mem[qi][qj][ei][ej][t];\n                if(now != 1) continue;\n                int tmp = t * 2;\n                for(int k = 0; k < 5; ++k) {\n                  int nqi =  t ? qi : qi + di[k];\n                  int nqj =  t ? qj : qj + dj[k];\n                  int nei = !t ? ei : ei + di[k];\n                  int nej = !t ? ej : ej + dj[k];\n                  if(nqi < 0 || nqi >= H) continue;\n                  if(nqj < 0 || nqj >= W) continue;\n                  if(nei < 0 || nei >= H) continue;\n                  if(nej < 0 || nej >= W) continue;\n                  if(G[nqi][nqj] == '#') continue;\n                  if(G[nei][nej] == '#') continue;\n                  if(t) tmp = min(tmp, mem[nqi][nqj][nei][nej][1-t]);\n                  else  tmp = max(tmp, mem[nqi][nqj][nei][nej][1-t]);\n                }\n                if(tmp != 1) {\n                  now = tmp;\n                  update = true;\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n    int res = mem[sqi][sqj][sei][sej][0];\n    if(res == 0) cout << \"Army can catch Queen.\" << endl;\n    else if(res == 1) cout << \"Queen can not escape and Army can not catch Queen.\" << endl;\n    else cout << \"Queen can escape.\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\nusing namespace std;\ntypedef long long LL;\nint dx[5] = {1, 0, -1, 0, 0};\nint dy[5] = {0, 1, 0, -1, 0};\n\nconst int MAX_T = 10 * 30;\n\nint W, H;\nstring grid[30];\nchar memo[30][30][30][30][MAX_T];\nbool valid(int x, int w) {\n    return 0 <= x && x < w;\n}\nint dfs(int x1, int y1, int x2, int y2, int t) {\n    //printf(\"%d %d %d %d %d %c %c\\n\", x1, y1, x2, y2, t, grid[y1][x1], grid[y2][x2]);\n    if(t >= MAX_T) return 2;\n    char& res = memo[y1][x1][y2][x2][t];\n    if(res != -1) return res;\n\n    if(y1 == y2 && x1 == x2) return res = 1;\n\n    int turn = t % 2;\n    if(turn == 0) {\n        if(grid[y1][x1] == 'E') return res = 0;\n\n        bool draw = false;\n        REP(r, 5) {\n            int nx = x1 + dx[r];\n            int ny = y1 + dy[r];\n            if(valid(nx, W) && valid(ny, H) && grid[ny][nx] != '#') {\n                int check = dfs(nx, ny, x2, y2, t + 1);\n                if(check == 0) {\n                    return res = 0;\n                } else if(check == 2) {\n                    draw = true;\n                }\n            }\n        }\n        return res = (draw ? 2 : 1);\n    } else {\n        bool draw = false;\n        REP(r, 5) {\n            int nx = x2 + dx[r];\n            int ny = y2 + dy[r];\n            if(valid(nx, W) && valid(ny, H) && grid[ny][nx] != '#') {\n                int check = dfs(x1, y1, nx, ny, t + 1);\n                if(check == 1) {\n                    return res = 1;\n                } else if(check == 2) {\n                    draw = true;\n                }\n            }\n        }\n        return res = (draw ? 2 : 0);\n    }\n}\n\nint main(){\n    while(cin >> W >> H && W > 0){\n        REP(y, H) cin >> grid[y];\n        int x1 = -1, y1 = -1, x2 = -1, y2 = -1;\n        REP(y, H) REP(x, W) if(grid[y][x] == 'Q') x1 = x, y1 = y;\n        REP(y, H) REP(x, W) if(grid[y][x] == 'A') x2 = x, y2 = y;\n\n        memset(memo, -1, sizeof(memo));\n        int ans = dfs(x1, y1, x2, y2, 0);\n        if(ans == 0) {\n            cout << \"Queen can escape.\" << endl;\n        } else if(ans == 1) {\n            cout << \"Army can catch Queen.\" << endl;\n        } else {\n            cout << \"Queen can not escape and Army can not catch Queen.\" << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\nconst ld eps = 1e-9;\n\ntypedef vector<vector<short>> Graph;\n\nvector<int> solve(Graph&g) {\n\tvector<int>nums(g.size());\n\tGraph revg(g.size());\n\tfor (int i = 0; i < g.size();++i){\n\t\tauto es(g[i]);\n\t\tnums[i] = es.size();\n\t\tfor (auto e : es) {\n\t\t\trevg[e].push_back(i);\n\t\t}\n\t}\n\n\t//1 : win   0 : draw   -1 :loss\n\tvector<int>anss(g.size());\n\tqueue<int>que;\n\tfor (int i = 0; i < g.size(); ++i) {\n\t\tif (!nums[i]) {\n\t\t\tque.push(i);\n\t\t\tanss[i] = -1;\n\t\t}\n\t}\n\twhile (!que.empty()) {\n\t\tint now(que.front());\n\t\tque.pop();\n\t\tif (anss[now] == 1) {\n\t\t\tfor (auto reve : revg[now]) {\n\t\t\t\tnums[reve]--;\n\t\t\t\tif (!nums[reve]&&anss[reve]==0) {\n\t\t\t\t\tanss[reve] = -1;\n\t\t\t\t\tque.push(reve);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if (anss[now] == -1) {\n\t\t\tfor (auto reve : revg[now]) {\n\t\t\t\tif (anss[reve] == 0) {\n\t\t\t\t\tanss[reve] = 1;\n\t\t\t\t\tque.push(reve);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tassert(false);\n\t\t}\n\t}\n\treturn anss;\n}\nconst int SIZE = 32;\nint gethash(int ax, int ay, int bx, int by, int c) {\n\treturn (ax-1)* SIZE * SIZE * SIZE * 2 + (ay-1)* SIZE * SIZE * 2 + (bx-1) * SIZE * 2 + (by-1) * 2 + c+1;\n}\n\nint main() {\n\twhile (true) {\n\t\tint W, H; cin >> W >> H;\n\t\tif (!W)break;\n\t\tvector<vector<int>>field(H + 2, vector<int>(W + 2,-1));\n\t\tint sqx, sqy, sax, say;\n\t\tfor (int i = 0; i < H; ++i) {\n\t\t\tstring st; cin >> st;\n\t\t\tfor (int j = 0; j < W; ++j) {\n\t\t\t\tswitch (st[j]) {\n\t\t\t\tcase 'Q':\n\t\t\t\t\tfield[i + 1][j + 1] = 0;\n\t\t\t\t\tsqx = j + 1; sqy = i + 1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'A':\n\t\t\t\t\tfield[i + 1][j + 1] = 0;\n\t\t\t\t\tsax = j + 1; say = i + 1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '#':\n\t\t\t\t\tbreak;\n\t\t\t\tcase '.':\n\t\t\t\t\tfield[i + 1][j + 1] = 0;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'E':\n\t\t\t\t\tfield[i + 1][j + 1] = 2;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tassert(false);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tGraph g(3000000);\n\t\tint dx[] = { -1,0,1,0,0 };\n\t\tint dy[] = { 0,1,0,-1,0 };\n\t\tfor (int qx = 1; qx < W + 1; ++qx) {\n\t\t\tfor (int qy = 1; qy < H + 1; ++qy) {\n\t\t\t\tfor (int ax = 1; ax < W + 1; ++ax) {\n\t\t\t\t\tfor (int ay = 1; ay < H + 1; ++ay) {\n\t\t\t\t\t\tfor (int nt = 0; nt < 2; ++nt) {\n\t\t\t\t\t\t\tint nowhash = gethash(qx, qy, ax, ay, nt);\n\t\t\t\t\t\t\tif (qx == ax&&qy == ay) {\n\t\t\t\t\t\t\t\tif (nt) {\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\tg[nowhash].push_back(0);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (field[qy][qx] == 2&&nt) {\n\t\t\t\t\t\t\t\tg[nowhash].push_back(0);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfor (int way = 0; way < 5; ++way) {\n\t\t\t\t\t\t\t\tint nqx(qx), nqy(qy), nax(ax), nay(ay);\n\t\t\t\t\t\t\t\tif (nt) {\n\t\t\t\t\t\t\t\t\tnqx += dx[way]; nqy += dy[way];\n\t\t\t\t\t\t\t\t\tif (field[nqy][nqx]==-1) continue;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\tnax += dx[way]; nay += dy[way];\n\t\t\t\t\t\t\t\t\tif ((field[nay][nax]==-1)) continue;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (nax == nqx&&nay == nqy) {\n\t\t\t\t\t\t\t\t\tif (nt) {\n\t\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\tg[nowhash].push_back(0);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tint nexthash = gethash(nqx, nqy, nax, nay, !nt);\n\t\t\t\t\t\t\t\tg[nowhash].push_back(nexthash);\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tauto anss=solve(g);\n\t\tint ans = anss[gethash(sqx, sqy, sax, say, 1)];\n\t\tif (ans == 0)cout << \"Queen can not escape and Army can not catch Queen.\" << endl;\n\t\telse if (ans == 1)cout << \"Queen can escape.\" << endl;\n\t\telse cout << \"Army can catch Queen.\" << endl;\n\t}\n\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\ntypedef vector<vector<int>> Graph;\n\nvector<int> solve(const Graph&g) {\n\tvector<int>nums(g.size());\n\tGraph revg(g.size());\n\tfor (int i = 0; i < g.size();++i){\n\t\tauto es(g[i]);\n\t\tnums[i] = es.size();\n\t\tfor (auto e : es) {\n\t\t\trevg[e].push_back(i);\n\t\t}\n\n\t}\n\n\t//1 : win   0 : draw   -1 :loss\n\tvector<int>anss(g.size());\n\tqueue<int>que;\n\tfor (int i = 0; i < g.size(); ++i) {\n\t\tif (!nums[i]) {\n\t\t\tque.push(i);\n\t\t\tanss[i] = -1;\n\t\t}\n\t}\n\twhile (!que.empty()) {\n\t\tint now(que.front());\n\t\tque.pop();\n\t\tif (anss[now] == 1) {\n\t\t\tfor (auto reve : revg[now]) {\n\t\t\t\tnums[reve]--;\n\t\t\t\tif (!nums[reve]&&anss[reve]==0) {\n\t\t\t\t\tanss[reve] = -1;\n\t\t\t\t\tque.push(reve);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if (anss[now] == -1) {\n\t\t\tfor (auto reve : revg[now]) {\n\t\t\t\tif (anss[reve] == 0) {\n\t\t\t\t\tanss[reve] = 1;\n\t\t\t\t\tque.push(reve);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tassert(false);\n\t\t}\n\t}\n\treturn anss;\n}\nconst int SIZE = 30;\nint gethash(int ax, int ay, int bx, int by, int c) {\n\treturn (ax-1)* SIZE * SIZE * SIZE * 2 + (ay-1)* SIZE * SIZE * 2 + (bx-1) * SIZE * 2 + (by-1) * 2 + c+1;\n}\n\nint main() {\n\twhile (true) {\n\t\tint W, H; cin >> W >> H;\n\t\tif (!W)break;\n\t\tvector<vector<int>>field(H + 2, vector<int>(W + 2,-1));\n\t\tint sqx, sqy, sax, say;\n\t\tfor (int i = 0; i < H; ++i) {\n\t\t\tstring st; cin >> st;\n\t\t\tfor (int j = 0; j < W; ++j) {\n\t\t\t\tswitch (st[j]) {\n\t\t\t\tcase 'Q':\n\t\t\t\t\tfield[i + 1][j + 1] = 0;\n\t\t\t\t\tsqx = j + 1; sqy = i + 1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'A':\n\t\t\t\t\tfield[i + 1][j + 1] = 0;\n\t\t\t\t\tsax = j + 1; say = i + 1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '#':\n\t\t\t\t\tbreak;\n\t\t\t\tcase '.':\n\t\t\t\t\tfield[i + 1][j + 1] = 0;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'E':\n\t\t\t\t\tfield[i + 1][j + 1] = 2;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tassert(false);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tGraph g(2000000);\n\t\tint dx[] = { -1,0,1,0,0 };\n\t\tint dy[] = { 0,1,0,-1,0 };\n\t\tfor (int qx = 1; qx < W + 1; ++qx) {\n\t\t\tfor (int qy = 1; qy < H + 1; ++qy) {\n\t\t\t\tfor (int ax = 1; ax < W + 1; ++ax) {\n\t\t\t\t\tfor (int ay = 1; ay < H + 1; ++ay) {\n\t\t\t\t\t\tfor (int nt = 0; nt < 2; ++nt) {\n\t\t\t\t\t\t\tint nowhash = gethash(qx, qy, ax, ay, nt);\n\t\t\t\t\t\t\tif (qx == ax&&qy == ay) {\n\t\t\t\t\t\t\t\tif (nt) {\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\tg[nowhash].push_back(0);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (field[qy][qx] == 2&&nt) {\n\t\t\t\t\t\t\t\tg[nowhash].push_back(0);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfor (int way = 0; way < 5; ++way) {\n\t\t\t\t\t\t\t\tint nqx(qx), nqy(qy), nax(ax), nay(ay);\n\t\t\t\t\t\t\t\tif (nt) {\n\t\t\t\t\t\t\t\t\tnqx += dx[way]; nqy += dy[way];\n\t\t\t\t\t\t\t\t\tif (field[nqy][nqx]==-1) continue;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\tnax += dx[way]; nay += dy[way];\n\t\t\t\t\t\t\t\t\tif ((field[nay][nax]==-1)) continue;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (nax == nqx&&nay == nqy) {\n\t\t\t\t\t\t\t\t\tif (nt) {\n\t\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\tg[nowhash].push_back(0);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tint nexthash = gethash(nqx, nqy, nax, nay, !nt);\n\t\t\t\t\t\t\t\tg[nowhash].push_back(nexthash);\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tauto anss=solve(g);\n\t\tint ans = anss[gethash(sqx, sqy, sax, say, 1)];\n\t\tif (ans == 0)cout << \"Queen can not escape and Army can not catch Queen.\" << endl;\n\t\telse if (ans == 1)cout << \"Queen can escape.\" << endl;\n\t\telse cout << \"Army can catch Queen.\" << endl;\n\t}\n\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (int)(k); i < (int)(n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\nconst int dx[] = { -1, 0, 0, 1 }, dy[] = { 0, -1, 1, 0 };\n//[const int dx[] = { -1, -1, -1, 0, 0, 1, 1, 1 }, dy[] = { 0, -1, 1, -1, 1, 0, -1, 1 };\nbool valid(int x, int y, int h, int w) { return (x >= 0 && y >= 0 && x < h&&y < w); }\nint place(int x, int y, int w) { return w*x + y; }\n\nint dp[2][33][33][33][33]; //turn, x_queen, y_queen, x_army, y_army\nint h, w;\nvs fld;\n\nstruct state\n{\n\tint turn, qx, qy, ax, ay;\n\tstate(int a, int b, int c, int d, int e) :turn(a), qx(b), qy(c), ax(d), ay(e) {};\n};\n\nvoid init()\n{\n\tfld.clear(); fld.resize(h);\n\tMS(dp, 0);\n}\n\nint main()\n{\n\tcin.sync_with_stdio(false); cout << fixed << setprecision(10);\n\twhile (cin >> w >> h, h)\n\t{\n\t\tinit();\n\t\tREP(i, h) cin >> fld[i];\n\t\tpii army, queen;\n\t\tset<pii> exit;\n\t\tREP(i, h)REP(j, w)\n\t\t{\n\t\t\tif (fld[i][j] == '#') continue;\n\t\t\tif (fld[i][j] == 'Q') queen = pii(i, j);\n\t\t\tif (fld[i][j] == 'A') army = pii(i, j);\n\t\t\tif (fld[i][j] == 'E') exit.emplace(i, j);\n\t\t\tfld[i][j] = '.';\n\t\t}\n\t\tfor (auto i : exit)REP(ax, h)REP(ay, w)\n\t\t{\n\t\t\tint qx = i.first, qy = i.second;\n\t\t\tdp[0][qx][qy][ax][ay] = 1;\n\t\t}\n\t\tREP(i, h)REP(j, w)\n\t\t{\n\t\t\tif (fld[i][j] == '#') continue;\n\t\t\tdp[0][i][j][i][j] = -1;\n\t\t}\n\t\tbool update = true;\n\t\twhile (update)\n\t\t{\n\t\t\tupdate = false;\n\t\t\tREP(i, 2)REP(qx, h)REP(qy, w)REP(ax, h)REP(ay, w)\n\t\t\t{\n\t\t\t\tif (dp[i][qx][qy][ax][ay] != 0) continue;\n\t\t\t\tif (i == 0)\n\t\t\t\t{\n\t\t\t\t\tset<int> st;\n\t\t\t\t\tst.insert(dp[1][qx][qy][ax][ay]);\n\t\t\t\t\tREP(j, 4)\n\t\t\t\t\t{\n\t\t\t\t\t\tint nx = qx + dx[j], ny = qy + dy[j];\n\t\t\t\t\t\tif (!valid(nx, ny, h, w) || fld[nx][ny] == '#') continue;\n\t\t\t\t\t\tst.insert(dp[1][nx][ny][ax][ay]);\n\t\t\t\t\t}\n\t\t\t\t\tif (st.size() == 1 && *st.begin() == -1)\n\t\t\t\t\t{\n\t\t\t\t\t\tdp[0][qx][qy][ax][ay] = -1;\n\t\t\t\t\t\tupdate = true;\n\t\t\t\t\t}\n\t\t\t\t\telse if (st.count(1))\n\t\t\t\t\t{\n\t\t\t\t\t\tdp[0][qx][qy][ax][ay] = 1;\n\t\t\t\t\t\tupdate = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tset<int> st;\n\t\t\t\t\tst.insert(dp[0][qx][qy][ax][ay]);\n\t\t\t\t\tREP(j, 4)\n\t\t\t\t\t{\n\t\t\t\t\t\tint nx = ax + dx[j], ny = ay + dy[j];\n\t\t\t\t\t\tif (!valid(nx, ny, h, w) || fld[nx][ny] == '#') continue;\n\t\t\t\t\t\tst.insert(dp[0][qx][qy][nx][ny]);\n\t\t\t\t\t}\n\t\t\t\t\tif (st.size() == 1 && *st.begin() == 1)\n\t\t\t\t\t{\n\t\t\t\t\t\tdp[1][qx][qy][ax][ay] = 1;\n\t\t\t\t\t\tupdate = true;\n\t\t\t\t\t}\n\t\t\t\t\telse if (st.count(-1))\n\t\t\t\t\t{\n\t\t\t\t\t\tdp[1][qx][qy][ax][ay] = -1;\n\t\t\t\t\t\tupdate = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint ans = dp[0][queen.first][queen.second][army.first][army.second];\n\t\tif (ans == 1) cout << \"Queen can escape.\" << endl;\n\t\telse if (ans == 0) cout << \"Queen can not escape and Army can not catch Queen.\" << endl;\n\t\telse cout << \"Army can catch Queen.\" << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// Enjoy your stay.\n\n#include <bits/stdc++.h>\n\n#define EPS 1e-9\n#define INF 1070000000LL\n#define MOD 1000000007LL\n#define fir first\n#define foreach(it,X) for(auto it=(X).begin();it!=(X).end();it++)\n#define ite iterator\n#define mp make_pair\n#define mt make_tuple\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define pb push_back\n#define sec second\n#define sz(x) ((int)(x).size())\n\nusing namespace std;\n\ntypedef istringstream iss;\ntypedef long long ll;\ntypedef pair<ll,ll> pi;\ntypedef stringstream sst;\ntypedef vector<ll> vi;\n\nint H,W;\nchar c[32][32];\nint a[2][32][32][32][32];\nint rest[2][32][32][32][32];\nint dy[] = {0,1,0,-1,0};\nint dx[] = {1,0,-1,0,0};\n\ntypedef pair<int,pair<pair<int,int>,pair<int,int>>> state;\n\nbool ok(int y,int x){return 0<=y && y<H && 0<=x && x<W\n\t&& (c[y][x] == '.' || c[y][x] == 'E');}\n\nint main(){\n\tcin.tie(0);\n\tios_base::sync_with_stdio(0);\n\t\n\twhile(cin>>W>>H && W){\n\t\trep(i,H)cin>>c[i];\n\t\tint sqy,sqx,say,sax;\n\t\trep(i,H)rep(j,W){\n\t\t\tif(c[i][j] == 'Q'){\n\t\t\t\tsqy=i, sqx=j, c[i][j] = '.';\n\t\t\t}\n\t\t\tif(c[i][j] == 'A'){\n\t\t\t\tsay=i, sax=j, c[i][j] = '.';\n\t\t\t}\n\t\t}\n\t\tmemset(a,0,sizeof(a));\n\t\tmemset(rest,0,sizeof(rest));\n\t\tqueue<state> Q;\n\t\trep(qi,H)rep(qj,W)rep(ai,H)rep(aj,W)if(ok(qi,qj) && ok(ai,aj)){\n\t\t\tif(qi == ai && qj == aj){\n\t\t\t\ta[0][qi][qj][ai][aj] = -1;\n\t\t\t\tQ.push(mp(0,mp(mp(qi,qj),mp(ai,aj))));\n\t\t\t}\n\t\t\telse if(c[qi][qj] == 'E'){\n\t\t\t\ta[0][qi][qj][ai][aj] = 1;\n\t\t\t\tQ.push(mp(0,mp(mp(qi,qj),mp(ai,aj))));\n\t\t\t}\n\t\t\telse{\n\t\t\t\trep(dir,5){\n\t\t\t\t\tint Qi = qi+dy[dir], Qj = qj+dx[dir];\n\t\t\t\t\trest[0][qi][qj][ai][aj] += ok(Qi,Qj);\n\t\t\t\t}\n\t\t\t}\n\t\t\trep(dir,5){\n\t\t\t\tint Ai = ai+dy[dir], Aj = aj+dx[dir];\n\t\t\t\trest[1][qi][qj][ai][aj] += ok(Ai,Aj);\n\t\t\t}\n\t\t}\n\t\twhile(sz(Q)){\n\t\t\tstate q = Q.front(); Q.pop();\n\t\t\tint p = q.fir;\n\t\t\tint qy = q.sec.fir.fir, qx = q.sec.fir.sec;\n\t\t\tint ay = q.sec.sec.fir, ax = q.sec.sec.sec;\n\t\t\tint res = a[p][qy][qx][ay][ax];\n\t\t\t//cout<<p<<\" \"<<qy<<\" \"<<qx<<\" \"<<ay<<\" \"<<ax<<\" : \"<<res<<endl;\n\t\t\tif(p == 0){\n\t\t\t\tif(qy == sqy && qx == sqx && ay == say && ax == sax){\n\t\t\t\t\tif(res == 1)cout<<\"Queen can escape.\"<<endl;\n\t\t\t\t\telse cout<<\"Army can catch Queen.\"<<endl;\n\t\t\t\t\tgoto end;\n\t\t\t\t}\n\t\t\t\trep(dir,5){\n\t\t\t\t\tint Ay = ay+dy[dir], Ax = ax+dx[dir];\n\t\t\t\t\tif(!ok(Ay,Ax) || a[1][qy][qx][Ay][Ax] != 0)continue;\n\t\t\t\t\tif(res == 1){\n\t\t\t\t\t\trest[1][qy][qx][Ay][Ax]--;\n\t\t\t\t\t}\n\t\t\t\t\tif(res == -1 || res == 1 && rest[1][qy][qx][Ay][Ax] == 0){\n\t\t\t\t\t\ta[1][qy][qx][Ay][Ax] = -res;\n\t\t\t\t\t\tQ.push(mp(1,mp(mp(qy,qx),mp(Ay,Ax))));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\trep(dir,5){\n\t\t\t\t\tint Qy = qy+dy[dir], Qx = qx+dx[dir];\n\t\t\t\t\tif(!ok(Qy,Qx) || a[0][Qy][Qx][ay][ax] != 0)continue;\n\t\t\t\t\tif(res == 1){\n\t\t\t\t\t\trest[0][Qy][Qx][ay][ax]--;\n\t\t\t\t\t}\n\t\t\t\t\tif(res == -1 || res == 1 && rest[0][Qy][Qx][ay][ax] == 0){\n\t\t\t\t\t\ta[0][Qy][Qx][ay][ax] = -res;\n\t\t\t\t\t\tQ.push(mp(0,mp(mp(Qy,Qx),mp(ay,ax))));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<\"Queen can not escape and Army can not catch Queen.\"<<endl;\n\t\tend:;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "Queen can escape."
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\ntypedef vector<vector<int>> Graph;\n\nvector<int> solve(const Graph&g) {\n\tvector<int>nums(g.size());\n\tGraph revg(g.size());\n\tfor (int i = 0; i < g.size();++i){\n\t\tauto es(g[i]);\n\t\tnums[i] = es.size();\n\t\tfor (auto e : es) {\n\t\t\trevg[e].push_back(i);\n\t\t}\n\n\t}\n\n\t//1 : win   0 : draw   -1 :loss\n\tvector<int>anss(g.size());\n\tqueue<int>que;\n\tfor (int i = 0; i < g.size(); ++i) {\n\t\tif (!nums[i]) {\n\t\t\tque.push(i);\n\t\t\tanss[i] = -1;\n\t\t}\n\t}\n\twhile (!que.empty()) {\n\t\tint now(que.front());\n\t\tque.pop();\n\t\tif (anss[now] == 1) {\n\t\t\tfor (auto reve : revg[now]) {\n\t\t\t\tnums[reve]--;\n\t\t\t\tif (!nums[reve]&&anss[reve]==0) {\n\t\t\t\t\tanss[reve] = -1;\n\t\t\t\t\tque.push(reve);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if (anss[now] == -1) {\n\t\t\tfor (auto reve : revg[now]) {\n\t\t\t\tif (anss[reve] == 0) {\n\t\t\t\t\tanss[reve] = 1;\n\t\t\t\t\tque.push(reve);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tassert(false);\n\t\t}\n\t}\n\treturn anss;\n}\nint SIZE = 30;\nint gethash(int ax, int ay, int bx, int by, int c) {\n\treturn (ax-1)* SIZE * SIZE * SIZE * 2 + (ay-1)* SIZE * SIZE * 2 + (bx-1) * SIZE * 2 + (by-1) * 2 + c+1;\n}\n\nint main() {\n\twhile (true) {\n\t\tint W, H; cin >> W >> H;\n\t\tif (!W)break;\n\t\tvector<vector<int>>field(H + 2, vector<int>(W + 2,-1));\n\t\tint sqx, sqy, sax, say;\n\t\tfor (int i = 0; i < H; ++i) {\n\t\t\tstring st; cin >> st;\n\t\t\tfor (int j = 0; j < W; ++j) {\n\t\t\t\tswitch (st[j]) {\n\t\t\t\tcase 'Q':\n\t\t\t\t\tfield[i + 1][j + 1] = 0;\n\t\t\t\t\tsqx = j + 1; sqy = i + 1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'A':\n\t\t\t\t\tfield[i + 1][j + 1] = 0;\n\t\t\t\t\tsax = j + 1; say = i + 1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '#':\n\t\t\t\t\tbreak;\n\t\t\t\tcase '.':\n\t\t\t\t\tfield[i + 1][j + 1] = 0;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'E':\n\t\t\t\t\tfield[i + 1][j + 1] = 2;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tassert(false);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSIZE = max(H, W);\n\t\tGraph g(SIZE * SIZE * SIZE*SIZE*2+1);\n\t\tint dx[] = { -1,0,1,0,0 };\n\t\tint dy[] = { 0,1,0,-1,0 };\n\t\tfor (int qx = 1; qx < W + 1; ++qx) {\n\t\t\tfor (int qy = 1; qy < H + 1; ++qy) {\n\t\t\t\tif (field[qy][qx] == -1)continue;\n\t\t\t\tfor (int ax = 1; ax < W + 1; ++ax) {\n\t\t\t\t\tfor (int ay = 1; ay < H + 1; ++ay) {\n\t\t\t\t\t\tif (field[ay][ax] == -1)continue;\n\t\t\t\t\t\tfor (int nt = 0; nt < 2; ++nt) {\n\t\t\t\t\t\t\tint nowhash = gethash(qx, qy, ax, ay, nt);\n\t\t\t\t\t\t\tif (qx == ax&&qy == ay) {\n\t\t\t\t\t\t\t\tif (nt) {\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\tg[nowhash].push_back(0);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (field[qy][qx] == 2&&nt) {\n\t\t\t\t\t\t\t\tg[nowhash].push_back(0);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfor (int way = 0; way < 5; ++way) {\n\t\t\t\t\t\t\t\tint nqx(qx), nqy(qy), nax(ax), nay(ay);\n\t\t\t\t\t\t\t\tif (nt) {\n\t\t\t\t\t\t\t\t\tnqx += dx[way]; nqy += dy[way];\n\t\t\t\t\t\t\t\t\tif (field[nqy][nqx]==-1) continue;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\tnax += dx[way]; nay += dy[way];\n\t\t\t\t\t\t\t\t\tif ((field[nay][nax]==-1)) continue;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (nax == nqx&&nay == nqy) {\n\t\t\t\t\t\t\t\t\tif (nt) {\n\t\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\tg[nowhash].push_back(0);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tint nexthash = gethash(nqx, nqy, nax, nay, !nt);\n\t\t\t\t\t\t\t\tg[nowhash].push_back(nexthash);\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tauto anss=solve(g);\n\t\tint ans = anss[gethash(sqx, sqy, sax, say, 1)];\n\t\tif (ans == 0)cout << \"Queen can not escape and Army can not catch Queen.\" << endl;\n\t\telse if (ans == 1)cout << \"Queen can escape.\" << endl;\n\t\telse cout << \"Army can catch Queen.\" << endl;\n\t}\n\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconstexpr int dx[5] = {0, 0, 1, 0, -1};\nconstexpr int dy[5] = {0, 1, 0, -1, 0};\n\ntemplate<typename T>\nstd::vector<T> table(int n, T v) { return std::vector<T>(n, v); }\n\ntemplate <class... Args>\nauto table(int n, Args... args) {\n    auto val = table(args...);\n    return std::vector<decltype(val)>(n, std::move(val));\n}\n\nenum {\n    Escape,\n    Caught,\n    Undecided\n};\n\nint main() {\n    int w, h;\n    while(cin >> w >> h, w) {\n        vector<string> v(h);\n        for(auto& a : v) cin >> a;\n\n        auto can_move_to = [&] (int y, int x) {\n            return 0 <= y && y < h && 0 <= x && x < w && v[y][x] != '#';\n        };\n\n        int qy = -1, qx = -1, ay = -1, ax = -1;\n        auto dp = table(h, w, h, w, 2, Undecided);\n        auto deg = table(h, w, h, w, 2, 0);\n        queue<tuple<int, int, int, int, int>> que;\n        for(int i = 0; i < h; ++i) {\n            for(int j = 0; j < w; ++j) {\n                if(v[i][j] == '#') continue;\n\n                if(v[i][j] == 'Q') qy = i, qx = j;\n                if(v[i][j] == 'A') ay = i, ax = j;\n                for(int k = 0; k < h; ++k) {\n                    for(int l = 0; l < w; ++l) {\n                        if(v[k][l] == '#' || (k == i && l == j)) continue;\n\n                        for(int d = 0; d < 5; ++d) {\n                            const int ny1 = i + dy[d], nx1 = j + dx[d];\n                            const int ny2 = k + dy[d], nx2 = l + dx[d];\n                            deg[i][j][k][l][0] += can_move_to(ny1, nx1) && v[i][j] != 'E';\n                            deg[i][j][k][l][1] += can_move_to(ny2, nx2);\n                        }\n\n                        if(v[i][j] == 'E') {\n                            dp[i][j][k][l][0] = Escape;\n                            deg[i][j][k][l][0] = 0;\n                            que.emplace(i, j, k, l, 0);\n                        }\n                    }\n                }\n                dp[i][j][i][j][0] = dp[i][j][i][j][1] = Caught;\n                que.emplace(i, j, i, j, 0);\n                que.emplace(i, j, i, j, 1);\n            }\n        }\n        while(!que.empty()) {\n            int qy, qx, ay, ax, turn; tie(qy, qx, ay, ax, turn) = que.front();\n            que.pop();\n            if(turn == 0) { // Queen's turn, so consider army's move\n                for(int d = 0; d < 5; ++d) {\n                    const int nay = ay + dy[d], nax = ax + dx[d];\n                    if(!can_move_to(nay, nax) || dp[qy][qx][nay][nax][!turn] != Undecided) continue;\n                    if(dp[qy][qx][ay][ax][turn] == Escape) {\n                        if(--deg[qy][qx][nay][nax][!turn] == 0) {\n                            dp[qy][qx][nay][nax][!turn] = Escape;\n                            que.emplace(qy, qx, nay, nax, !turn);\n                        }\n                    } else {\n                        deg[qy][qx][nay][nax][!turn] = 0;\n                        dp[qy][qx][nay][nax][!turn] = Caught;\n                        que.emplace(qy, qx, nay, nax, !turn);\n                    }\n                }\n            } else {\n                for(int d = 0; d < 5; ++d) {\n                    const int nqy = qy + dy[d], nqx = qx + dx[d];\n                    if(!can_move_to(nqy, nqx) || dp[nqy][nqx][ay][ax][!turn] != Undecided) continue;\n                    if(dp[qy][qx][ay][ax][turn] == Escape) {\n                        deg[nqy][nqx][ay][ax][!turn] = 0;\n                        dp[nqy][nqx][ay][ax][!turn] = Escape;\n                        que.emplace(nqy, nqx, ay, ax, !turn);\n                    } else {\n                        if(--deg[nqy][nqx][ay][ax][!turn] == 0) {\n                            dp[nqy][nqx][ay][ax][!turn] = Caught;\n                            que.emplace(nqy, nqx, ay, ax, !turn);\n                        }\n                    }\n                }\n            }\n        }\n\n        const auto ans = dp[qy][qx][ay][ax][0];\n        if(ans == Escape) {\n            cout << \"Queen can escape.\" << endl;\n        } else if(ans == Caught) {\n            cout << \"Army can catch Queen.\" << endl;\n        } else {\n            cout << \"Queen can not escape and Army can not catch Queen.\" << endl;\n        }\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define HUGE_NUM 99999999999999999\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n#define NUM 31\n\nenum Type{\n\tCAN_EXIT,\n\tCAUGHT,\n\tINFINITE_LOOP,\n};\n\nenum Which{\n\tturn_Queen,\n\tturn_Army,\n};\n\nstruct LOC{\n\tvoid set(int arg_row,int arg_col){\n\t\trow = arg_row;\n\t\tcol = arg_col;\n\t}\n\tint row,col;\n};\n\nstruct Info{\n\tInfo(){\n\t\tQ_row = 0;\n\t\tQ_col = 0;\n\t\tA_row = 0;\n\t\tA_col = 0;\n\t}\n\tInfo(int arg_Q_row,int arg_Q_col,int arg_A_row,int arg_A_col){\n\t\tQ_row = arg_Q_row;\n\t\tQ_col = arg_Q_col;\n\t\tA_row = arg_A_row;\n\t\tA_col = arg_A_col;\n\t}\n\tint Q_row,Q_col,A_row,A_col;\n};\n\nint W,H;\nint diff_row[5] = {-1,0,0,0,1},diff_col[5] = {0,-1,0,1,0};\nLOC Q_start,A_start;\nchar base_map[NUM][NUM+1];\nType table[NUM][NUM][NUM][NUM][2];\nqueue<Info> QUEEN[2],ARMY[2];\n\n\nbool rangeCheck(int row,int col){\n\n\tif(row >= 0 && row <= H-1 && col >= 0 && col <= W-1 && base_map[row][col] != '#'){\n\n\t\treturn true;\n\t}else{\n\t\treturn false;\n\t}\n}\n\nvoid init_dp(){\n\n\tfor(int row = 0; row < H; row++){\n\t\tfor(int col = 0; col < W; col++){\n\t\t\tfor(int row2 = 0; row2 < H; row2++){\n\t\t\t\tfor(int col2 = 0; col2 < W; col2++){\n\t\t\t\t\ttable[row][col][row2][col2][turn_Queen] = INFINITE_LOOP;\n\t\t\t\t\ttable[row][col][row2][col2][turn_Army] = INFINITE_LOOP;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid set_exit(int exit_row,int exit_col){\n\n\tfor(int row = 0; row < H; row++){\n\t\tfor(int col = 0; col < W; col++){\n\t\t\ttable[exit_row][exit_col][row][col][turn_Queen] = CAN_EXIT;\n\t\t}\n\t}\n}\n\nvoid set_caught(){\n\n\tfor(int row = 0; row < H; row++){\n\t\tfor(int col = 0; col < W; col++){\n\t\t\ttable[row][col][row][col][turn_Queen] = CAUGHT;\n\t\t\ttable[row][col][row][col][turn_Army] = CAUGHT;\n\t\t}\n\t}\n}\n\nvoid func(){\n\n\tinit_dp();\n\n\tfor(int i = 0; i < 2; i++){\n\t\twhile(!QUEEN[i].empty())QUEEN[i].pop();\n\t\twhile(!ARMY[i].empty())ARMY[i].pop();\n\t}\n\n\tfor(int row = 0; row < H; row++){\n\n\t\tscanf(\"%s\",base_map[row]);\n\n\t\tfor(int col = 0; col < W; col++){\n\n\t\t\tif(base_map[row][col] == 'Q'){\n\n\t\t\t\tQ_start.set(row,col);\n\n\t\t\t}else if(base_map[row][col] == 'A'){\n\n\t\t\t\tA_start.set(row,col);\n\n\t\t\t}else if(base_map[row][col] == 'E'){\n\n\t\t\t\tset_exit(row,col);\n\t\t\t}\n\t\t}\n\t}\n\n\tset_caught();\n\n\tfor(int row = 0; row < H; row++){\n\t\tfor(int col = 0; col < W; col++){\n\t\t\tfor(int row2 = 0; row2 < H; row2++){\n\t\t\t\tfor(int col2 = 0; col2 < W; col2++){\n\t\t\t\t\tif(table[row][col][row2][col2][turn_Queen] == INFINITE_LOOP){\n\t\t\t\t\t\tQUEEN[0].push(Info(row,col,row2,col2));\n\t\t\t\t\t}\n\t\t\t\t\tif(table[row][col][row2][col2][turn_Army] == INFINITE_LOOP){\n\t\t\t\t\t\tARMY[0].push(Info(row,col,row2,col2));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tbool FLG;\n\tint CURRENT = 0,NEXT = 1;\n\tInfo info;\n\tint adj_row,adj_col;\n\tbool exit_FLG,caught_FLG;\n\n\twhile(true){\n\n\t\tFLG = false;\n\n\t\twhile(!QUEEN[CURRENT].empty()){\n\n\t\t\tinfo = QUEEN[CURRENT].front();\n\t\t\tQUEEN[CURRENT].pop();\n\n\t\t\tif(table[info.Q_row][info.Q_col][info.A_row][info.A_col][turn_Queen] != INFINITE_LOOP){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\texit_FLG = false;\n\t\t\tcaught_FLG = true;\n\n\t\t\tfor(int i = 0; i < 5; i++){\n\n\t\t\t\tadj_row = info.Q_row+diff_row[i];\n\t\t\t\tadj_col = info.Q_col+diff_col[i];\n\n\t\t\t\tif(!rangeCheck(adj_row,adj_col))continue;\n\n\t\t\t\tif(table[adj_row][adj_col][info.A_row][info.A_col][turn_Army] == CAN_EXIT){\n\t\t\t\t\texit_FLG = true;\n\t\t\t\t}\n\n\t\t\t\tif(table[adj_row][adj_col][info.A_row][info.A_col][turn_Army] != CAUGHT){\n\t\t\t\t\tcaught_FLG = false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(exit_FLG){\n\t\t\t\ttable[info.Q_row][info.Q_col][info.A_row][info.A_col][turn_Queen] = CAN_EXIT;\n\t\t\t\tFLG = true;\n\t\t\t}\n\n\t\t\tif(caught_FLG){\n\t\t\t\ttable[info.Q_row][info.Q_col][info.A_row][info.A_col][turn_Queen] = CAUGHT;\n\t\t\t\tFLG = true;\n\t\t\t}\n\n\t\t\tif(exit_FLG == false && caught_FLG == false){\n\t\t\t\tQUEEN[NEXT].push(info);\n\t\t\t}\n\t\t}\n\n\t\twhile(!ARMY[CURRENT].empty()){\n\n\t\t\tinfo = ARMY[CURRENT].front();\n\t\t\tARMY[CURRENT].pop();\n\n\t\t\tif(table[info.Q_row][info.Q_col][info.A_row][info.A_col][turn_Army] != INFINITE_LOOP){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\texit_FLG = true;\n\t\t\tcaught_FLG = false;\n\n\t\t\tfor(int i = 0; i < 5; i++){\n\n\t\t\t\tadj_row = info.A_row+diff_row[i];\n\t\t\t\tadj_col = info.A_col+diff_col[i];\n\n\t\t\t\tif(!rangeCheck(adj_row,adj_col))continue;\n\n\t\t\t\tif(table[info.Q_row][info.Q_col][adj_row][adj_col][turn_Queen] == CAUGHT){\n\t\t\t\t\tcaught_FLG = true;\n\t\t\t\t}\n\n\t\t\t\tif(table[info.Q_row][info.Q_col][adj_row][adj_col][turn_Queen] != CAN_EXIT){\n\t\t\t\t\texit_FLG = false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(exit_FLG){\n\t\t\t\ttable[info.Q_row][info.Q_col][info.A_row][info.A_col][turn_Army] = CAN_EXIT;\n\t\t\t\tFLG = true;\n\t\t\t}\n\n\t\t\tif(caught_FLG){\n\t\t\t\ttable[info.Q_row][info.Q_col][info.A_row][info.A_col][turn_Army] = CAUGHT;\n\t\t\t\tFLG = true;\n\t\t\t}\n\n\t\t\tif(exit_FLG == false && caught_FLG == false){\n\t\t\t\tARMY[NEXT].push(info);\n\t\t\t}\n\t\t}\n\n\t\tif(!FLG)break;\n\n\t\tswap(CURRENT,NEXT);\n\t}\n\n\tswitch(table[Q_start.row][Q_start.col][A_start.row][A_start.col][turn_Queen]){\n\tcase CAN_EXIT:\n\t\tprintf(\"Queen can escape.\\n\");\n\t\tbreak;\n\tcase CAUGHT:\n\t\tprintf(\"Army can catch Queen.\\n\");\n\t\tbreak;\n\tcase INFINITE_LOOP:\n\t\tprintf(\"Queen can not escape and Army can not catch Queen.\\n\");\n\t\tbreak;\n\t}\n}\n\nint main(){\n\n\twhile(true){\n\t\tscanf(\"%d %d\",&W,&H);\n\t\tif(W == 0 && H == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\n\nint dx[]={-1,0,1,0};\nint dy[]={0,-1,0,1};\n\nbool lp[30][30];\nbool ck[30][30][30][30];\nint dist[30][30][30][30];\nint relt[30][30][30][30];\nint memo[30][30][30][30];\nint W,H,gx[900],gy[900],gN;\nchar f[31][31];\n\nclass State\n{\npublic:\n\tint x,y,c;\n\tState(int x, int y, int c)\n\t:x(x),y(y),c(c)\n\t{}\n};\n\nvoid bfs(int x, int y)\n{\n\tbool hs[30][30]={0};\n\t\n\tqueue<State> q;\n\tq.push(State(x,y,0));\n\ths[x][y]=1;\n\t\n\twhile(!q.empty())\n\t{\n\t\tState s=q.front(); q.pop();\n\t\tdist[x][y][s.x][s.y]=s.c;\n\t\t\n\t\tfor(int i=0; i<4; i++)\n\t\t{\n\t\t\tint tx=s.x+dx[i], ty=s.y+dy[i];\n\t\t\tif(tx<0||ty<0||tx>=W||ty>=H) continue;\n\t\t\tif(f[tx][ty]=='#') continue;\n\t\t\tif(hs[tx][ty]) continue;\n\t\t\t\n\t\t\ths[tx][ty]=1;\n\t\t\t\n\t\t\tq.push(State(tx,ty,s.c+1));\n\t\t}\n\t}\n}\n\nbool loop(int qx, int qy, int d)\n{\n\tint sx=qx+dx[d], sy=qy+dy[d];\n\tif(sx<0||sy<0||sx>=W||sy>=H) return false;\n\tif(f[sx][sy]=='#') return false;\n\t\n\tbool hs[30][30]={0};\n\t\n\tqueue<State> q;\n\tq.push(State(sx,sy,0));\n\ths[qx][qy]=1;\n\ths[sx][sy]=1;\n\t\n\twhile(!q.empty())\n\t{\n\t\tState s=q.front(); q.pop();\n\t\t\n\t\tfor(int i=0; i<4; i++)\n\t\t{\n\t\t\tint tx=s.x+dx[i], ty=s.y+dy[i];\n\t\t\tif(tx<0||ty<0||tx>=W||ty>=H) continue;\n\t\t\tif(f[tx][ty]=='#') continue;\n\t\t\tif(tx==qx&&ty==qy)\n\t\t\t{\n\t\t\t\tif(s.c==0) continue;\n\t\t\t\telse return true;\n\t\t\t}\n\t\t\tif(hs[tx][ty]) continue;\n\t\t\t\n\t\t\ths[tx][ty]=1;\n\t\t\t\n\t\t\tq.push(State(tx,ty,s.c+1));\n\t\t}\n\t}\n\t\n\treturn false;\n}\n\nint judge(int qx, int qy, int ax, int ay)\n{\t\n\tif(qx==ax&&qy==ay) return -1;\n\tfor(int k=0; k<gN; k++)\n\t{\n\t\tif(dist[qx][qy][gx[k]][gy[k]] < dist[ax][ay][gx[k]][gy[k]]) return 1;\n\t}\n\t\n\tif(lp[qx][qy]) return 0;\n\treturn -1;\n}\n\nvoid calcD()\n{\n\tfor(int i=0; i<H; i++)\n\tfor(int j=0; j<W; j++)\n\t{\n\t\tif(f[j][i]=='#') continue;\n\t\tbfs(j,i);\n\t}\n}\n\nvoid Search()\n{\n\tfor(int i=0; i<H; i++)\n\tfor(int j=0; j<W; j++)\n\t{\n\t\tif(f[j][i]=='#') continue;\n\t\t\n\t\tfor(int k=0; k<4; k++)\n\t\t{\n\t\t\tif(loop(j,i,k))\n\t\t\t{\n\t\t\t\t lp[j][i]=true;\n\t\t\t\t break;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int k=0; k<H; k++)\n\t\tfor(int l=0; l<W; l++)\n\t\t{\n\t\t\tif(f[l][k]=='#') continue;\n\t\t\trelt[j][i][l][k]=judge(j,i,l,k);\n\t\t}\n\t}\n}\n\nint Aphase(int a, int b, int x, int y);\nint Qphase(int a, int b, int x, int y);\n\nint Aphase(int a, int b, int x, int y, int d)\n{\n\tif(ck[a][b][x][y]) return memo[a][b][x][y];\n\tint ret=relt[a][b][x][y];\n\tfor(int i=0; i<H; i++)\n\tfor(int j=0; j<W; j++)\n\t{\n\t\tif(dist[x][y][j][i]==-1) continue;\n\t\t\n\t\tif(dist[x][y][j][i]<=d)\n\t\t{\n\t\t\tret=min(ret, relt[a][b][j][i]);\n\t\t}\n\t}\n\t\n\tfor(int i=0; i<H; i++)\n\tfor(int j=0; j<W; j++)\n\t{\n\t\tif(dist[x][y][j][i]==-1) continue;\n\t\tif(ck[a][b][j][i]) \n\t\t{\n\t\t\tret=min(ret, memo[a][b][j][i]);\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tif(relt[a][b][j][i]>ret) continue;\n\t\tif(dist[x][y][j][i]<=d)\n\t\t{\n\t\t\tret=min(ret, Qphase(a,b,j,i));\n\t\t}\n\t\t\n\t}\n\treturn ret;\n}\n\nint Qphase(int a, int b, int x, int y)\n{\n\tif(ck[a][b][x][y]) return memo[a][b][x][y];\n\tck[a][b][x][y]=1;\n\t\n\tmemo[a][b][x][y]=relt[a][b][x][y];\n\tfor(int i=0; i<H; i++)\n\tfor(int j=0; j<W; j++)\n\t{\n\t\tif(f[j][i]=='#') continue;\n\t\tif(dist[a][b][j][i]>=dist[x][y][j][i]) continue;\n\t\tif(dist[a][b][j][i]==-1) continue;\n\t\tif(relt[a][b][x][y]>=relt[j][i][x][y]) continue;\n\t\t\n\t\tmemo[a][b][x][y]=max(memo[a][b][x][y], Aphase(j,i,x,y,dist[a][b][j][i]));\n\t}\n\t\n\treturn memo[a][b][x][y];\n}\n\nint main()\n{\n\twhile(cin >> W >> H, (W||H))\n\t{\n\t\tgN=0;\n\t\tint ax,ay,qx,qy;\n\t\tmemset(lp,0,sizeof(lp));\n\t\tmemset(ck,0,sizeof(ck));\n\n\t\tmemset(dist, -1, sizeof(dist));\n\t\tfor(int i=0; i<H; i++)\n\t\tfor(int j=0; j<W; j++)\n\t\t{\n\t\t\tcin >> f[j][i];\n\t\t\tif(f[j][i]=='A')\n\t\t\t{\n\t\t\t\tax=j; ay=i;\n\t\t\t}\n\t\t\tif(f[j][i]=='Q')\n\t\t\t{\n\t\t\t\tqx=j; qy=i;\n\t\t\t}\n\t\t\tif(f[j][i]=='E')\n\t\t\t{\n\t\t\t\tgx[gN]=j;\n\t\t\t\tgy[gN]=i;\n\t\t\t\tgN++;\n\t\t\t}\n\t\t}\n\t\tcalcD();\n\t\tSearch();\n\t\t\n\t\tint ret=Qphase(qx,qy,ax,ay);\n\t\tif(ret==-1) \tcout << \"Army can catch Queen.\" << endl;\n\t\telse if(ret==0)\tcout << \"Queen can not escape and Army can not catch Queen.\" << endl;\n\t\telse\t\t\tcout << \"Queen can escape.\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <chrono>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstring>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <iomanip>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n#include <cstdint>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\n#define MP make_pair\n#define PB push_back\n#define inf 1000000007\n#define rep(i,n) for(int i = 0; i < (int)(n); ++i)\n#define all(x) (x).begin(),(x).end()\n\ntemplate<typename A, size_t N, typename T>\nvoid Fill(A (&array)[N], const T &val){\n    std::fill( (T*)array, (T*)(array+N), val );\n}\n \ntemplate<class T> inline bool chmax(T &a, T b){\n    if(a<b){\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T> inline bool chmin(T &a, T b){\n    if(a>b){\n        a = b;\n        return true;\n    }\n    return false;\n}\n\nchar dp[31][31][31][31][151];\nvector<string> s;\nint n,m;\nbool ok(int i,int j){\n    if(i<0||i>=n)return false;\n    if(j<0||j>=m)return false;\n    if(s[i][j]=='#')return false;\n    return true;\n}\nint dfs(int qi,int qj,int ai,int aj,int tur){\n    if(tur==150){\n        return 3;\n    }\n    if(dp[qi][qj][ai][aj][tur]!=0){\n        return dp[qi][qj][ai][aj][tur];\n    }\n    if(qi==ai&&qj==aj){\n        dp[qi][qj][ai][aj][tur]=2;\n        return 2;\n    }\n    if(tur%2==0){\n        if(s[qi][qj]=='E'){\n            dp[qi][qj][ai][aj][tur] = 1;\n            return 1;\n        }\n        vector<int> a;\n        for(int i=-1;i<=1;i++){\n            if(ok(qi+i,qj)){\n                a.push_back(dfs(qi+i,qj,ai,aj,tur+1));\n            }\n        }\n        for(int j=-1;j<=1;j++){\n            if(ok(qi,qj+j)){\n                a.push_back(dfs(qi,qj+j,ai,aj,tur+1));\n            }\n        }\n        bool ss = 0;\n        for(auto x:a){\n            if(x==1){\n                dp[qi][qj][ai][aj][tur] = 1;\n                return 1;\n            }else if(x==3){\n                ss = 1;\n            }\n        }\n        if(ss){\n            dp[qi][qj][ai][aj][tur] = 3;\n            return 3;\n        }else{\n            dp[qi][qj][ai][aj][tur] = 2;\n            return 2;\n        }\n    }else{\n        vector<int> a;\n        for(int i=-1;i<=1;i++){\n            if(ok(ai+i,aj)){\n                a.push_back(dfs(qi,qj,ai+i,aj,tur+1));\n            }\n        }\n        for(int j=-1;j<=1;j++){\n            if(ok(ai,aj+j)){\n                a.push_back(dfs(qi,qj,ai,aj+j,tur+1));\n            }\n        }\n        bool ss = 0;\n        for(auto x:a){\n            if(x==2){\n                dp[qi][qj][ai][aj][tur] = 2;\n                return 2;\n            }else if(x==3){\n                ss = 1;\n            }\n        }\n        if(ss){\n            dp[qi][qj][ai][aj][tur] = 3;\n            return 3;\n        }else{\n            dp[qi][qj][ai][aj][tur] = 1;\n            return 1;\n        }\n    }\n\n}\n\n\nint main(){\n    while(1){\n        cin >> m >> n;\n        if(n==0)break;\n        rep(i,n){\n            rep(j,m){\n                rep(k,n){\n                    rep(l,m){\n                        rep(t,151){\n                            dp[i][j][k][l][t] = 0;\n                        }\n                    }\n                }\n            }\n        }\n        s.resize(n);\n        s.shrink_to_fit();\n        rep(i,n){\n            cin >> s[i];\n        }\n        int qi,qj,ai,aj;\n        rep(i,n){\n            rep(j,m){\n                if(s[i][j]=='A'){\n                    ai = i;\n                    aj = j;\n                }else if(s[i][j]=='Q'){\n                    qi = i;\n                    qj = j;\n                } \n            }\n        }\n        int k = dfs(qi,qj,ai,aj,0);\n        if(k==1){\n            cout << \"Queen can escape.\\n\";\n        }else if(k==2){\n            cout << \"Army can catch Queen.\\n\";\n        }else{\n            cout << \"Queen can not escape and Army can not catch Queen.\\n\";\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (int)(k); i < (int)(n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\nconst int dx[] = { -1, 0, 0, 1 }, dy[] = { 0, -1, 1, 0 };\n//[const int dx[] = { -1, -1, -1, 0, 0, 1, 1, 1 }, dy[] = { 0, -1, 1, -1, 1, 0, -1, 1 };\nbool valid(int x, int y, int h, int w) { return (x >= 0 && y >= 0 && x < h&&y < w); }\nint place(int x, int y, int w) { return w*x + y; }\n\nint dp[2][33][33][33][33]; //turn, x_queen, y_queen, x_army, y_army\nint h, w;\nvs fld;\n\nstruct state\n{\n\tint turn, qx, qy, ax, ay;\n\tstate(int a, int b, int c, int d, int e) :turn(a), qx(b), qy(c), ax(d), ay(e) {};\n};\n\nvoid init()\n{\n\tfld.clear(); fld.resize(h);\n\tMS(dp, 0);\n}\n\nint main()\n{\n\tcin.sync_with_stdio(false); cout << fixed << setprecision(10);\n\twhile (cin >> w >> h, h)\n\t{\n\t\tinit();\n\t\tREP(i, h) cin >> fld[i];\n\t\tpii army, queen;\n\t\tset<pii> exit;\n\t\tREP(i, h)REP(j, w)\n\t\t{\n\t\t\tif (fld[i][j] == '#') continue;\n\t\t\tif (fld[i][j] == 'Q') queen = pii(i, j);\n\t\t\tif (fld[i][j] == 'A') army = pii(i, j);\n\t\t\tif (fld[i][j] == 'E') exit.emplace(i, j);\n\t\t\tfld[i][j] = '.';\n\t\t}\n\t\tvector<state> updates;\n\t\tfor (auto i : exit)REP(ax, h)REP(ay, w)\n\t\t{\n\t\t\tint qx = i.first, qy = i.second;\n\t\t\tdp[0][qx][qy][ax][ay] = 1;\n\t\t\tupdates.push_back(state(0, qx, qy, ax, ay));\n\t\t}\n\t\tREP(i, h)REP(j, w)\n\t\t{\n\t\t\tif (fld[i][j] == '#') continue;\n\t\t\tdp[0][i][j][i][j] = -1;\n\t\t\tupdates.push_back(state(0, i, j, i, j));\n\t\t}\n\t\tREP(i, 2)REP(qx, h)REP(qy, w)REP(ax, h)REP(ay, w) updates.push_back(state(i, qx, qy, ax, ay));\n\t\twhile (!updates.empty())\n\t\t{\n\t\t\tvector<state> nexts;\n\t\t\tfor (auto tmp : updates)\n\t\t\t{\n\t\t\t\tbool update = false;\n\t\t\t\tint i = tmp.turn, qx = tmp.qx, qy = tmp.qy, ax = tmp.ax, ay = tmp.ay;\n\t\t\t\tif (!valid(qx, qy, h, w) || !valid(ax, ay, h, w) || dp[i][qx][qy][ax][ay] != 0) continue;\n\t\t\t\tif (i == 0)\n\t\t\t\t{\n\t\t\t\t\tset<int> st;\n\t\t\t\t\tst.insert(dp[1][qx][qy][ax][ay]);\n\t\t\t\t\tREP(j, 4)\n\t\t\t\t\t{\n\t\t\t\t\t\tint nx = qx + dx[j], ny = qy + dy[j];\n\t\t\t\t\t\tif (!valid(nx, ny, h, w) || fld[nx][ny] == '#') continue;\n\t\t\t\t\t\tst.insert(dp[1][nx][ny][ax][ay]);\n\t\t\t\t\t}\n\t\t\t\t\tif (st.size() == 1 && *st.begin() == -1)\n\t\t\t\t\t{\n\t\t\t\t\t\tdp[0][qx][qy][ax][ay] = -1;\n\t\t\t\t\t\tupdate = true;\n\t\t\t\t\t}\n\t\t\t\t\telse if (st.count(1))\n\t\t\t\t\t{\n\t\t\t\t\t\tdp[0][qx][qy][ax][ay] = 1;\n\t\t\t\t\t\tupdate = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tset<int> st;\n\t\t\t\t\tst.insert(dp[0][qx][qy][ax][ay]);\n\t\t\t\t\tREP(j, 4)\n\t\t\t\t\t{\n\t\t\t\t\t\tint nx = ax + dx[j], ny = ay + dy[j];\n\t\t\t\t\t\tif (!valid(nx, ny, h, w) || fld[nx][ny] == '#') continue;\n\t\t\t\t\t\tst.insert(dp[0][qx][qy][nx][ny]);\n\t\t\t\t\t}\n\t\t\t\t\tif (st.size() == 1 && *st.begin() == 1)\n\t\t\t\t\t{\n\t\t\t\t\t\tdp[1][qx][qy][ax][ay] = 1;\n\t\t\t\t\t\tupdate = true;\n\t\t\t\t\t}\n\t\t\t\t\telse if (st.count(-1))\n\t\t\t\t\t{\n\t\t\t\t\t\tdp[1][qx][qy][ax][ay] = -1;\n\t\t\t\t\t\tupdate = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (update)\n\t\t\t\t{\n\t\t\t\t\tREP(i, 2)REP(j, 4)REP(k, 4)\n\t\t\t\t\tnexts.push_back(state(i, qx + dx[j], qy + dy[j], ax + dx[k], ay + dy[k]));\n\t\t\t\t}\n\t\t\t}\n\t\t\tsort(ALL(updates));\n\t\t\tupdates.erase(unique(ALL(updates)), updates.end());\n\t\t\tupdates = nexts;\n\t\t}\n\t\t\n\n\t\tint ans = dp[0][queen.first][queen.second][army.first][army.second];\n\t\tif (ans == 1) cout << \"Queen can escape.\" << endl;\n\t\telse if (ans == 0) cout << \"Queen can not escape and Army can not catch Queen.\" << endl;\n\t\telse cout << \"Army can catch Queen.\" << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <stdio.h>\n#include <string.h>\n#include <queue>\n#include <assert.h>\n\nusing namespace std;\n\nstruct State {\n  int player;\n  int qx;\n  int qy;\n  int ax;\n  int ay;\n  State() {;}\n  State(int p, int y1, int x1, int y2, int x2) : player(p), qx(x1), qy(y1), ax(x2), ay(y2) {;}\n};\n\nchar field[50][50];\n\nstatic const int QTURN = 0;\nstatic const int ATURN = 1;\n\nstatic const int UNKONWN = 0;\nstatic const int QWIN = 1;\nstatic const int UNKNOWN = 0;\nstatic const int AWIN = -1;\n\nint temp1[100000];\nint win[2][40][40][40][40];\nint temp2[100000];\nint width;\nint height;\n\ninline bool can_move(int x, int y) {\n  return field[y][x] != '#';\n}\n\nint main() {\n  while (true) {\n  memset(field, '#', sizeof(field));\n  memset(win, 0, sizeof(win));\n  scanf(\"%d %d\", &width, &height);\nif (width == 0) { return 0; }\n  for (int y = 1; y <= height; y++) {\n    scanf(\"%s\", &field[y][1]);\n    field[y][width + 1] = '#';\n  }\n  int qstartx;\n  int qstarty;\n  int astartx;\n  int astarty;\n  int dx[5] = { 1, -1, 0, 0, 0 };\n  int dy[5] = { 0, 0, 1, -1, 0 };\n  queue<State> que;\n  for (int y = 1; y <= height; y++) {\n    for (int x = 1; x <= width; x++) {\n      if (field[y][x] == 'Q') {\n        qstartx = x;\n        qstarty = y;\n      } else if (field[y][x] == 'A')  {\n        astartx = x;\n        astarty = y;\n      } else if (field[y][x] == 'E') {\n        for (int i = 1; i <= height; i++) {\n          for (int j = 1; j <= width; j++) {\n            if (y == i && x == j) { continue; }\n            if (!can_move(j, i)) { continue; }\n            win[QTURN][y][x][i][j] = QWIN;;\n            for (int k = 0; k < 5; k++) {\n              int nx = j + dx[k];\n              int ny = i + dy[k];\n              if (!can_move(nx, ny)) { continue; }\n              que.push(State(ATURN, y, x, ny, nx));\n            }\n          }\n        }\n      }\n      if (!can_move(x, y)) { continue; }\n      win[QTURN][y][x][y][x] = AWIN;\n      win[ATURN][y][x][y][x] = AWIN;\n      for (int k = 0; k < 5; k++) {\n        int nx = x + dx[k];\n        int ny = y + dy[k];\n        if (!can_move(nx, ny)) { continue; }\n        que.push(State(ATURN, y, x, ny, nx));\n        que.push(State(QTURN, ny, nx, y, x));\n      }\n    }\n  }\n  while (!que.empty()) {\n    State state = que.front();\n    que.pop();\n    if (win[state.player][state.qy][state.qx][state.ay][state.ax] != UNKNOWN) { continue; }\n      //cout << state.player << \" \" << state.qx << \" \" << state.ax << endl;\n    int next_turn = (state.player + 1) & 1;\n    bool qwin = false;\n    bool unknown = false;\n    bool awin = false;\n    for (int i = 0; i < 5; i++) {\n      int next;\n      int nx;\n      int ny;\n      if (state.player == QTURN) {\n        nx = state.qx + dx[i];\n        ny = state.qy + dy[i];\n        if (!can_move(nx, ny)) { continue; }\n        next = win[next_turn][ny][nx][state.ay][state.ax];\n      } else {\n        nx = state.ax + dx[i];\n        ny = state.ay + dy[i];\n        if (!can_move(nx, ny)) { continue; }\n        next = win[next_turn][state.qy][state.qx][ny][nx];\n      }\n      switch (next) {\n        case QWIN:\n          qwin = true;\n          break;\n        case AWIN:\n          awin = true;\n          break;\n        case UNKNOWN:\n          unknown = true;\n          break;\n        default:\n          assert(false);\n      }\n    }\n    if (state.player == QTURN) {\n      if (qwin) {\n        win[state.player][state.qy][state.qx][state.ay][state.ax] = QWIN;\n      } else if (!unknown) {\n        win[state.player][state.qy][state.qx][state.ay][state.ax] = AWIN;\n      }\n    } else {\n      if (awin) {\n        win[state.player][state.qy][state.qx][state.ay][state.ax] = AWIN;\n      } else if (!unknown) {\n        win[state.player][state.qy][state.qx][state.ay][state.ax] = QWIN;\n      }\n    }\n    if (win[state.player][state.qy][state.qx][state.ay][state.ax] != UNKNOWN) {\n      //cout << state.player << \" \" << state.qx << \" \" << state.ax << \" \" << win[state.player][state.qy][state.qx][state.ay][state.ax] << endl;\n      //cout << state.player << \" \" << state.qx << \" \" << state.qy << \" \" << state.ax << \" \" << state.ay << \" \" << win[state.player][state.qy][state.qx][state.ay][state.ax] << endl;\n      if (state.player == QTURN) {\n        for (int i = 0; i < 5; i++) {\n          int nx = state.ax + dx[i];\n          int ny = state.ay + dy[i];\n          if (!can_move(nx, ny)) { continue; }\n          if (win[next_turn][state.qy][state.qx][ny][nx] != UNKNOWN) { continue; }\n          que.push(State(ATURN, state.qy, state.qx, ny, nx));\n        }\n      } else {\n        for (int i = 0; i < 5; i++) {\n          int nx = state.qx + dx[i];\n          int ny = state.qy + dy[i];\n          if (!can_move(nx, ny)) { continue; }\n          if (win[next_turn][ny][nx][state.ay][state.ax] != UNKNOWN) { continue; }\n          que.push(State(QTURN, ny, nx, state.ay, state.ax));\n        }\n      }\n    }\n  }\n  switch (win[QTURN][qstarty][qstartx][astarty][astartx]) {\n    case QWIN:\n      printf(\"Queen can escape.\\n\");\n      break;\n    case AWIN:\n      printf(\"Army can catch Queen.\\n\");\n      break;\n    case UNKNOWN:\n      printf(\"Queen can not escape and Army can not catch Queen.\\n\");\n      break;\n    default:\n      assert(false);\n  }\n}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\ntypedef vector<vector<int>> Graph;\n\nvector<int> solve(Graph&g) {\n\tvector<int>nums(g.size());\n\tGraph revg(g.size());\n\tfor (int i = 0; i < g.size();++i){\n\t\tauto es(g[i]);\n\t\tnums[i] = es.size();\n\t\tfor (auto e : es) {\n\t\t\trevg[e].push_back(i);\n\t\t}\n\t\tg[i].clear();\n\t}\n\n\t//1 : win   0 : draw   -1 :loss\n\tvector<int>anss(g.size());\n\tqueue<int>que;\n\tfor (int i = 0; i < g.size(); ++i) {\n\t\tif (!nums[i]) {\n\t\t\tque.push(i);\n\t\t\tanss[i] = -1;\n\t\t}\n\t}\n\twhile (!que.empty()) {\n\t\tint now(que.front());\n\t\tque.pop();\n\t\tif (anss[now] == 1) {\n\t\t\tfor (auto reve : revg[now]) {\n\t\t\t\tnums[reve]--;\n\t\t\t\tif (!nums[reve]&&anss[reve]==0) {\n\t\t\t\t\tanss[reve] = -1;\n\t\t\t\t\tque.push(reve);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if (anss[now] == -1) {\n\t\t\tfor (auto reve : revg[now]) {\n\t\t\t\tif (anss[reve] == 0) {\n\t\t\t\t\tanss[reve] = 1;\n\t\t\t\t\tque.push(reve);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tassert(false);\n\t\t}\n\t}\n\treturn anss;\n}\nconst int SIZE = 30;\nint gethash(int ax, int ay, int bx, int by, int c) {\n\treturn (ax-1)* SIZE * SIZE * SIZE * 2 + (ay-1)* SIZE * SIZE * 2 + (bx-1) * SIZE * 2 + (by-1) * 2 + c+1;\n}\n\nint main() {\n\twhile (true) {\n\t\tint W, H; cin >> W >> H;\n\t\tif (!W)break;\n\t\tvector<vector<int>>field(H + 2, vector<int>(W + 2,-1));\n\t\tint sqx, sqy, sax, say;\n\t\tfor (int i = 0; i < H; ++i) {\n\t\t\tstring st; cin >> st;\n\t\t\tfor (int j = 0; j < W; ++j) {\n\t\t\t\tswitch (st[j]) {\n\t\t\t\tcase 'Q':\n\t\t\t\t\tfield[i + 1][j + 1] = 0;\n\t\t\t\t\tsqx = j + 1; sqy = i + 1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'A':\n\t\t\t\t\tfield[i + 1][j + 1] = 0;\n\t\t\t\t\tsax = j + 1; say = i + 1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '#':\n\t\t\t\t\tbreak;\n\t\t\t\tcase '.':\n\t\t\t\t\tfield[i + 1][j + 1] = 0;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'E':\n\t\t\t\t\tfield[i + 1][j + 1] = 2;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tassert(false);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tGraph g(2000000);\n\t\tint dx[] = { -1,0,1,0,0 };\n\t\tint dy[] = { 0,1,0,-1,0 };\n\t\tfor (int qx = 1; qx < W + 1; ++qx) {\n\t\t\tfor (int qy = 1; qy < H + 1; ++qy) {\n\t\t\t\tfor (int ax = 1; ax < W + 1; ++ax) {\n\t\t\t\t\tfor (int ay = 1; ay < H + 1; ++ay) {\n\t\t\t\t\t\tfor (int nt = 0; nt < 2; ++nt) {\n\t\t\t\t\t\t\tint nowhash = gethash(qx, qy, ax, ay, nt);\n\t\t\t\t\t\t\tif (qx == ax&&qy == ay) {\n\t\t\t\t\t\t\t\tif (nt) {\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\tg[nowhash].push_back(0);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (field[qy][qx] == 2&&nt) {\n\t\t\t\t\t\t\t\tg[nowhash].push_back(0);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfor (int way = 0; way < 5; ++way) {\n\t\t\t\t\t\t\t\tint nqx(qx), nqy(qy), nax(ax), nay(ay);\n\t\t\t\t\t\t\t\tif (nt) {\n\t\t\t\t\t\t\t\t\tnqx += dx[way]; nqy += dy[way];\n\t\t\t\t\t\t\t\t\tif (field[nqy][nqx]==-1) continue;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\tnax += dx[way]; nay += dy[way];\n\t\t\t\t\t\t\t\t\tif ((field[nay][nax]==-1)) continue;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (nax == nqx&&nay == nqy) {\n\t\t\t\t\t\t\t\t\tif (nt) {\n\t\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\tg[nowhash].push_back(0);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tint nexthash = gethash(nqx, nqy, nax, nay, !nt);\n\t\t\t\t\t\t\t\tg[nowhash].push_back(nexthash);\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tauto anss=solve(g);\n\t\tint ans = anss[gethash(sqx, sqy, sax, say, 1)];\n\t\tif (ans == 0)cout << \"Queen can not escape and Army can not catch Queen.\" << endl;\n\t\telse if (ans == 1)cout << \"Queen can escape.\" << endl;\n\t\telse cout << \"Army can catch Queen.\" << endl;\n\t}\n\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\nInt dp[2][33][33][33][33];\nInt cnt[2][33][33][33][33];\nsigned main(){  \n  cin.tie(0);\n  ios::sync_with_stdio(0);\n  Int w,h;\n  while(cin>>w>>h,w){\n    vector<string> s(h);\n    for(Int i=0;i<h;i++) cin>>s[i];\n    memset(dp,-1,sizeof(dp));\n    memset(cnt,0,sizeof(cnt));\n    {\n      using T = tuple<Int, Int, Int, Int, Int>;\n      queue<T> q;\n      Int dy[]={0,0,1,-1,0};\n      Int dx[]={1,-1,0,0,0};\n      auto in=[&](Int y,Int x){\n\treturn 0<=y&&y<h&&0<=x&&x<w;\n      };\n      \n      for(Int qy=0;qy<h;qy++){\n\tfor(Int qx=0;qx<w;qx++){\n\t  if(s[qy][qx]=='#') continue;\n\t  for(Int ay=0;ay<h;ay++){\n\t    for(Int ax=0;ax<w;ax++){\n\t      if(s[ay][ax]=='#') continue;\n\t      // t == 0\t      \n\t      {\t\t\n\t\tif(s[qy][qx]=='E'&&!(qy==ay&&qx==ax)){\n\t\t  dp[0][qy][qx][ay][ax]=1;\n\t\t  q.emplace(0,qy,qx,ay,ax);\n\t\t}\n\t\tfor(Int k=0;k<5;k++){\n\t\t  Int ny=qy+dy[k],nx=qx+dx[k];\n\t\t  if(!in(ny,nx)||s[ny][nx]=='#') continue;\n\t\t  cnt[0][qy][qx][ay][ax]++;\n\t\t}\n\t      }\n\t      // t == 1\n\t      {\n\t\tfor(Int k=0;k<5;k++){\n\t\t  Int ny=ay+dy[k],nx=ax+dx[k];\n\t\t  if(!in(ny,nx)||s[ny][nx]=='#') continue;\n\t\t  if(ny==qy&&nx==qx){\t\t    \n\t\t    dp[1][qy][qx][ay][ax]=1;\n\t\t    q.emplace(1,qy,qx,ay,ax);\t\t  \n\t\t  }\n\t\t  cnt[1][qy][qx][ay][ax]++;\n\t\t}\n\t      }\n\t    }\n\t  }\t\n\t}\n      }\n      //cout<<cnt[0][0][0][0][1]<<endl;\n      const Int DBG = 0;\n      \n      while(!q.empty()){\n\tInt t,qy,qx,ay,ax;\n\ttie(t,qy,qx,ay,ax)=q.front();q.pop();\n\tInt d=dp[t][qy][qx][ay][ax];\n\tif(DBG) cout<<t<<\":\"<<qy<<\" \"<<qx<<\" \"<<ay<<\" \"<<ax<<\":\"<<d<<endl;\n\t\n\tif(t){\n\t  for(Int k=0;k<5;k++){\n\t    Int ny=qy+dy[k],nx=qx+dx[k];\n\t    if(!in(ny,nx)||s[ny][nx]=='#') continue;\n\t    if(~dp[!t][ny][nx][ay][ax]) continue;\n\t    cnt[!t][ny][nx][ay][ax]--;\n\t    if(!d||cnt[!t][ny][nx][ay][ax]==0){\n\t      if(DBG) cout<<\"->\"<<!t<<\" \"<<ny<<\" \"<<nx<<\" \"<<ay<<\" \"<<ax<<\":\"<<!d<<endl;\n\t      dp[!t][ny][nx][ay][ax]=!d;\n\t      q.emplace(!t,ny,nx,ay,ax);\n\t    }\n\t  }\n\t}else{\n\t  for(Int k=0;k<5;k++){\n\t    Int ny=ay+dy[k],nx=ax+dx[k];\n\t    if(!in(ny,nx)||s[ny][nx]=='#') continue;\n\t    if(~dp[!t][qy][qx][ny][nx]) continue;\n\t    cnt[!t][qy][qx][ny][nx]--;\n\t    if(!d||cnt[!t][qy][qx][ny][nx]==0){\n\t      if(DBG) cout<<\"->\"<<!t<<\" \"<<qy<<\" \"<<qx<<\" \"<<ny<<\" \"<<nx<<\":\"<<!d<<endl;\n\t      dp[!t][qy][qx][ny][nx]=!d;\n\t      q.emplace(!t,qy,qx,ny,nx);\n\t    }\n\t  }\n\t}\n      }\n      \n    }\n    \n    \n    {\n      Int qx,qy,ax,ay;\n      for(Int i=0;i<h;i++){\n\tfor(Int j=0;j<w;j++){\n\t  if(s[i][j]=='Q') qy=i,qx=j;\n\t  if(s[i][j]=='A') ay=i,ax=j;\n\t}\n      }\n      if(dp[0][qy][qx][ay][ax]==1)\n\tcout<<\"Queen can escape.\"<<endl;\n      if(dp[0][qy][qx][ay][ax]==0)\n\tcout<<\"Army can catch Queen.\"<<endl;\n      if(dp[0][qy][qx][ay][ax]==-1)\n\tcout<<\"Queen can not escape and Army can not catch Queen.\"<<endl;\n    }\n  }\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\n\nimport static java.util.Arrays.*;\nimport static java.util.Collections.*;\nimport static java.lang.Math.*;\n\npublic class Main {\n    int INF = 2 << 28;\n    \n    int w, h;\n    int[][] armyMap, queenMap, map;\n    boolean[][] roopMap;\n    ArrayList<P> trgPs;\n    int trgCnt, qsx, qsy, asx, asy;\n    void run() {\n        Scanner sc = new Scanner(System.in);\n        for (;;) {\n            w = sc.nextInt(); h = sc.nextInt();\n            if ((w|h) == 0) break;\n            \n            map = new int[h + 2][w + 2];\n            trgCnt = 0;\n            trgPs = new ArrayList<P>();\n            for (int[] a : map) fill(a, -1);\n            for (int i = 1; i <= h; i++) {\n                String l = sc.next();\n                for (int j = 1; j <= w; j++) {\n                    switch (l.charAt(j - 1)) {\n                    case '.': map[i][j] = 0; break;\n                    case '#': map[i][j] = -1; break;\n                    case 'Q': map[i][j] = 0; qsx = j; qsy = i; break;\n                    case 'A': map[i][j] = 0; asx = j; asy = i; break;\n                    case 'E': map[i][j] = ++trgCnt; trgPs.add(new P(j, i));\n                    }\n                }\n            }\n            \n            queenMap = new int[h+2][w+2];\n            armyMap = new int[h+2][w+2];\n            bfs(qsx, qsy, queenMap);\n            bfs(asx, asy, armyMap);\n            \n            roopMap = new boolean[h+2][w+2];\n            roop();\n            \n//            for (int[] a : queenMap) debug(a);\n//            for (int[] a : armyMap) debug(a);\n//            for (boolean[] a : roopMap) debug(a);\n            \n            System.out.println(checkAns());\n        }\n    }\n    \n    String checkAns() {\n        for (P t : trgPs) if (queenMap[t.y][t.x] < armyMap[t.y][t.x]) {\n            return \"Queen can escape.\";\n        }\n        for (int x = 1; x <= w; x++) for (int y = 1; y <= h; y++) if (roopMap[y][x]){\n            if (queenMap[y][x] < armyMap[y][x]) {\n                return \"Queen can not escape and Army can not catch Queen.\";\n            }\n        }\n        return \"Army can catch Queen.\";\n    }\n    \n    int[] dx = {-1,0,1,0};\n    int[] dy = {0,-1,0,1};\n    void bfs(int x, int y, int[][] pMap) {\n        LinkedList<P> q = new LinkedList<P>();\n        for (int[] a: pMap) fill(a, INF);\n        pMap[y][x] = 0;\n        q.add(new P(x, y));\n        for(;!q.isEmpty();) {\n            P cur = q.removeFirst();\n            \n            for (int i = 0; i < 4; i++) if (map[cur.y+dy[i]][cur.x+dx[i]] >= 0) {\n                if (pMap[cur.y+dy[i]][cur.x+dx[i]] > pMap[cur.y][cur.x] + 1) {\n                    pMap[cur.y+dy[i]][cur.x+dx[i]] = pMap[cur.y][cur.x] + 1;\n                    q.addLast(new P(cur.x + dx[i], cur.y + dy[i]));\n                }\n            }\n        }\n    }\n    \n    void roop() {\n        for (int y = 1; y <= h; y++) for (int x = 1; x <= w; x++) {\n            dfs(x, y, x, y, x, y, true, new boolean[h + 2][w + 2]);\n        }\n    }\n    \n    boolean dfs(int x, int y, int px, int py, int sx, int sy, boolean first, boolean[][] visited) {\n        if (!first) {\n            visited[y][x] = true;\n            if (x == sx && y == sy) {\n                return roopMap[y][x] = true;\n            }\n        }\n        boolean f = false;\n        for (int i = 0; i < 4; i++) if (map[y + dy[i]][x + dx[i]] >= 0) {\n            if (x + dx[i] == px && y + dy[i] == py) continue;\n            if (visited[y + dy[i]][x + dx[i]]) continue;\n            f |= dfs(x + dx[i], y + dy[i], x, y, sx, sy, false, visited);\n        }\n        \n        return roopMap[y][x] |= f;\n    }\n    \n    class P {\n        int x, y, c;\n        P(int x, int y) {\n            this.x = x; this.y = y;\n            this.c = 0;\n        }\n        \n        P(int x, int y, int c) {\n            this(x, y);\n            this.c = c;\n        }\n    }\n    \n    void debug(Object...os) {\n        System.err.println(deepToString(os));\n    }\n    \n    public static void main(String[] args) {\n        new Main().run();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.Scanner;\n\nclass Main {\n\tpublic static void main(String[] args) throws IOException {\n\t\tnew Main().run();\n\t}\n\n\tvoid run() throws IOException {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint W = sc.nextInt();\n\t\t\tint H = sc.nextInt();\n\t\t\tif (W == 0 && H == 0)\n\t\t\t\tbreak;\n\t\t\tchar[][] map = new char[H][W];\n\t\t\tfor (int i = 0; i < H; ++i) {\n\t\t\t\tmap[i] = sc.next().toCharArray();\n\t\t\t}\n\t\t\tint Ax = -1, Ay = -1;\n\t\t\tint Qx = -1, Qy = -1;\n\t\t\tfor (int i = 0; i < H; ++i) {\n\t\t\t\tfor (int j = 0; j < W; ++j) {\n\t\t\t\t\tif (map[i][j] == 'A') {\n\t\t\t\t\t\tAy = i;\n\t\t\t\t\t\tAx = j;\n\t\t\t\t\t} else if (map[i][j] == 'Q') {\n\t\t\t\t\t\tQy = i;\n\t\t\t\t\t\tQx = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint[][][] memo = new int[H * W][H * W][2];\n\n\t\t\tfor (int q = 0; q < H * W; ++q) {\n\t\t\t\tif (!valid(q, map, H, W))\n\t\t\t\t\tcontinue;\n\t\t\t\tfor (int a = 0; a < H * W; ++a) {\n\t\t\t\t\tif (!valid(a, map, H, W))\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tfor (int t = 0; t < 2; ++t) {\n\t\t\t\t\t\tif (q == a) {\n\t\t\t\t\t\t\tmemo[q][a][t] = -1;// Q?????????\n\t\t\t\t\t\t} else if (t == 0 && map[q / W][q % W] == 'E') {\n\t\t\t\t\t\t\tmemo[q][a][t] = 1;// Q?????????\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint[] d = { 0, W, -W, 1, -1 };\n\n\t\t\tfor (boolean update = true; update;) {\n\t\t\t\tupdate = false;\n\t\t\t\tfor (int q = 0; q < H * W; ++q) {\n\t\t\t\t\tif (!valid(q, map, H, W))\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tfor (int a = 0; a < H * W; ++a) {\n\t\t\t\t\t\tif (!valid(a, map, H, W))\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tfor (int t = 0; t < 2; ++t) {\n\t\t\t\t\t\t\tif (memo[q][a][t] != 0) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tint v = (t == 0 ? -999 : 999);\n\t\t\t\t\t\t\tfor (int i = 0; i < 5; ++i) {\n\t\t\t\t\t\t\t\tint na = a, nq = q;\n\t\t\t\t\t\t\t\tif (t == 0)\n\t\t\t\t\t\t\t\t\tnq += d[i];\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\tna += d[i];\n\t\t\t\t\t\t\t\tif ((t == 1 && !valid(a, d[i], map, H, W)) || (t == 0 && !valid(q, d[i], map, H, W)))\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\tif (t == 0) {\n\t\t\t\t\t\t\t\t\tv = Math.max(v, memo[nq][na][t ^ 1]);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tv = Math.min(v, memo[nq][na][t ^ 1]);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (v != 0) {\n\t\t\t\t\t\t\t\tmemo[q][a][t] = v;\n\t\t\t\t\t\t\t\tupdate = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t\t\tint Q = Qy * W + Qx;\n\t\t\tint A = Ay * W + Ax;\n\t\t\tif (memo[Q][A][0] == 0) {\n\t\t\t\tSystem.out.println(\"Queen can not escape and Army can not catch Queen.\");\n\t\t\t} else if (memo[Q][A][0] == -1) {\n\t\t\t\tSystem.out.println(\"Army can catch Queen.\");\n\t\t\t} else if (memo[Q][A][0] == 1) {\n\t\t\t\tSystem.out.println(\"Queen can escape.\");\n\t\t\t}\n\t\t}\n\n\t}\n\n\tboolean valid(int a, int d, char[][] map, int H, int W) {\n\t\tif (!valid(a, map, H, W) || !valid(a + d, map, H, W)) {\n\t\t\treturn false;\n\t\t}\n\t\tint h = a / W;\n\t\tint w = a % W;\n\t\tint nh = (a + d) / W;\n\t\tint nw = (a + d) % W;\n\t\tif (Math.abs(nh - h) + Math.abs(nw - w) <= 1) {\n\t\t\treturn true;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tboolean valid(int a, char[][] map, int H, int W) {\n\t\tif (a < 0 || a >= H * W)\n\t\t\treturn false;\n\t\tint h = a / W;\n\t\tint w = a % W;\n\t\tif (map[h][w] == '#')\n\t\t\treturn false;\n\t\treturn true;\n\t}\n\n\tvoid tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\n\nimport static java.util.Arrays.*;\nimport static java.util.Collections.*;\nimport static java.lang.Math.*;\n\npublic class Main {\n    int INF = 2 << 28;\n    \n    int w, h;\n    boolean[][] map;\n    ArrayList<P> trgPs;\n    int qsx, qsy, asx, asy;\n    \n    int[][][][][] mem;\n\n    \n    void run() {\n        Scanner sc = new Scanner(System.in);\n        \n        for (;;) {\n            w = sc.nextInt(); h = sc.nextInt();\n            if ((w|h) == 0) break;\n            map = new boolean[h + 2][w + 2];\n            trgPs = new ArrayList<P>();\n            \n            for (int i = 1; i <= h; i++) {\n                String l = sc.next();\n                for (int j = 1; j <= w; j++) {\n                    switch (l.charAt(j - 1)) {\n                    case '.': map[i][j] = true;  break;\n                    case '#': map[i][j] = false; break;\n                    case 'Q': map[i][j] = true;  qsx = j; qsy = i; break;\n                    case 'A': map[i][j] = true;  asx = j; asy = i; break;\n                    case 'E': map[i][j] = true;  trgPs.add(new P(j, i));\n                    }\n                }\n            }\n            \n            mem = new int[2][w + 2][h + 2][w + 2][h + 2];\n            \n            for (P p : trgPs) {\n                for (int x = 1; x <= w; x++) for (int y = 1; y <= h; y++) {\n                    mem[0][p.x][p.y][x][y] = 1;\n                }\n            }\n            \n            for (int x = 1; x <= w; x++) for (int y = 1; y <= h; y++) {\n                mem[0][x][y][x][y] = -1;\n            }\n            \n            boolean update = true;\n            int x = 1;\n            while (update) {\n                update = false;\n                for (int qx = 1; qx <= w; qx++) for (int qy = 1; qy <= h; qy++) if (map[qy][qx]) {\n                    for (int ax = 1; ax <= w; ax++) for (int ay = 1; ay <= h; ay++) if (map[ay][ax]) {\n                        update |= update(qx, qy, ax, ay, x);\n                    }\n                }\n//                debug(x, update);\n                x = 1 - x;\n                for (int[][][] a : mem[x]) for (int[][] b : a) for (int[] c : b) fill(c, 0);\n            }\n            \n            \n            \n            switch (mem[1-x][qsx][qsy][asx][asy]) {\n            case 1:\n                System.out.println(\"Queen can escape.\");\n                break;\n            case 0:\n                System.out.println(\"Queen can not escape and Army can not catch Queen.\");\n                break;\n            case -1:\n                System.out.println(\"Army can catch Queen.\");\n                break;\n            }\n        }\n    }\n    \n    int[] dx = {-1,0,1,0,0};\n    int[] dy = {0,-1,0,1,0};\n    boolean update(int qx, int qy, int ax, int ay, int t) {\n        if (mem[1-t][qx][qy][ax][ay] != 0) {\n            mem[t][qx][qy][ax][ay] = mem[1-t][qx][qy][ax][ay];\n            return false;\n        }\n        \n        for (int i = 0; i < 5; i++) if (map[qy+dy[i]][qx+dx[i]]) {\n            boolean flg = true;\n            for (int j = 0; j < 5; j++) if (map[ay+dy[j]][ax+dx[j]]) \n                flg &= mem[1-t][qx+dx[i]][qy+dy[i]][ax+dx[j]][ay+dy[j]] > 0;\n            if (flg) {\n                mem[t][qx][qy][ax][ay] = 1;\n                return true;\n            }\n        }\n        \n        boolean flg = true;\n        for (int i = 0; i < 5; i++) if (map[qy+dy[i]][qx+dx[i]]) {\n            boolean tmp = false;\n            for (int j = 0; j < 5; j++) if (map[ay+dy[j]][ax+dx[j]])\n                tmp |= mem[1-t][qx+dx[i]][qy+dy[i]][ax+dx[j]][ay+dy[j]] < 0;\n            flg &= tmp;\n        }\n        if (flg) {\n            mem[t][qx][qy][ax][ay] = -1;\n            return true;\n        }\n        \n        return false;\n    }\n    \n    class P {\n        int x, y;\n        P(int x, int y) {\n            this.x = x;\n            this.y = y;\n        }\n    }\n    \n    void debug(Object...os) {\n        System.err.println(deepToString(os));\n    }\n    \n    public static void main(String[] args) {\n        new Main().run();\n    }\n}"
  },
  {
    "language": "Python",
    "code": "from collections import deque, defaultdict\nimport sys\nreadline = sys.stdin.readline\nwrite = sys.stdout.write\ndd = ((-1, 0), (0, -1), (1, 0), (0, 1), (0, 0))\ndef solve():\n    W, H = map(int, readline().split())\n    if W == H == 0:\n        return False\n    S = [readline().strip() for i in range(H)]\n    px = py = qx = qy = 0\n    rs = []\n    pp = []\n    MP = [[0]*W for i in range(H)]\n    for i in range(H):\n        for j, c in enumerate(S[i]):\n            if c == \"Q\":\n                px = j; py = i\n            elif c == \"A\":\n                qx = j; qy = i\n            elif c == \"E\":\n                MP[i][j] = 1\n                rs.append((j, i))\n            elif c == \"#\":\n                MP[i][j] = 2\n            if c != \"#\":\n                pp.append((j, i))\n    mp = {}\n    L = 0\n    for ax, ay in pp:\n        for bx, by in pp:\n            mp[ax, ay, bx, by, 0] = L\n            L += 1\n            mp[ax, ay, bx, by, 1] = L\n            L += 1\n\n    que1 = deque()\n    ss = [-1]*L\n    cc = [0]*L\n\n    que = deque([(px, py, qx, qy, 0)])\n    used = [0]*L\n    used[mp[px, py, qx, qy, 0]] = 1\n    RG = [[] for i in range(L)]\n    deg = [0]*L\n    while que:\n        ax, ay, bx, by, t = key = que.popleft()\n        k0 = mp[key]\n        if ax == bx and ay == by:\n            que1.append(k0)\n            ss[k0] = 1\n            continue\n        if t == 0 and MP[ay][ax] == 1:\n            que1.append(k0)\n            ss[k0] = 0\n            continue\n        if t == 1:\n            for dx, dy in dd:\n                nx = bx + dx; ny = by + dy\n                if not 0 <= nx < W or not 0 <= ny < H or MP[ny][nx] == 2:\n                    continue\n                k1 = mp[ax, ay, nx, ny, t^1]\n                deg[k0] += 1\n                RG[k1].append(k0)\n                if not used[k1]:\n                    used[k1] = 1\n                    que.append((ax, ay, nx, ny, t^1))\n        else:\n            for dx, dy in dd:\n                nx = ax + dx; ny = ay + dy\n                if not 0 <= nx < W or not 0 <= ny < H or MP[ny][nx] == 2:\n                    continue\n                k1 = mp[nx, ny, bx, by, t^1]\n                deg[k0] += 1\n                RG[k1].append(k0)\n                if not used[k1]:\n                    used[k1] = 1\n                    que.append((nx, ny, bx, by, t^1))\n\n    while que1:\n        v = que1.popleft()\n        s = ss[v]; t = v % 2\n        if t == 0:\n            for w in RG[v]:\n                if ss[w] != -1:\n                    continue\n                if s == 1:\n                    que1.append(w)\n                    ss[w] = 1\n                else:\n                    deg[w] -= 1\n                    if deg[w] == 0:\n                        que1.append(w)\n                        ss[w] = 0\n        else:\n            for w in RG[v]:\n                if ss[w] != -1:\n                    continue\n                if s == 0:\n                    que1.append(w)\n                    ss[w] = 0\n                else:\n                    deg[w] -= 1\n                    if deg[w] == 0:\n                        que1.append(w)\n                        ss[w] = 1\n    k0 = mp[px, py, qx, qy, 0]\n    if ss[k0] == -1:\n        write(\"Queen can not escape and Army can not catch Queen.\\n\")\n    elif ss[k0] == 0:\n        write(\"Queen can escape.\\n\")\n    else:\n        write(\"Army can catch Queen.\\n\")\n    return True\nwhile solve():\n    ...\n"
  }
]