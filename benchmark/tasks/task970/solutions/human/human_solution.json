[
  {
    "language": "Crystal",
    "code": "K=1000000007\nn,m=gets.not_nil!.split.map &.to_i\na=Array.new(m+1){Array.new(n+2){[0_i64]*(n+2)}}\na[0][1][1]=1_i64\nm.times{|i|(n+1).times{|j|(n+1).times{|k|\n\ta[i+1][j+1][k]=(a[i+1][j+1][k]+a[i][j][k]*(n-j))%K\n\ta[i+1][j][k]=(a[i+1][j][k]+a[i][j][k]*(j-k))%K\n\ta[i+1][j][j]=(a[i+1][j][j]+a[i][j][k]*k)%K\n}}}\np a[m][n][n]"
  },
  {
    "language": "Scala",
    "code": "\nimport java.util.Scanner\n\n/**\n * Created by sonetsuyoshi on 2015/12/16.\n */\nobject Main extends App {\n  val MOD = 1000000007\n\n  val sc = new Scanner(System.in)\n\n  val N = sc.nextInt\n  val M = sc.nextInt\n\n  val dp = Array.ofDim[Long](2, N + 1, N + 1)\n  dp(0)(1)(1) = 1\n  for(i <- 0 until M) {\n    var from = i % 2\n    var to = 1 - from\n\n    dp(to) = Array.ofDim[Long](N + 1, N  + 1)\n\n    for(j <- 1 to N) {\n      for(k <- 1 to N) {\n        val d = dp(from)(j)(k)\n        if(d != 0) {\n          if(N - j > 0) {\n            dp(to)(j + 1)(k) += d * (N - j)\n            dp(to)(j + 1)(k) %= MOD\n          }\n          if(j - k > 0) {\n            dp(to)(j)(k) += d * (j - k)\n            dp(to)(j)(k) %= MOD\n          }\n          dp(to)(j)(j) += d * k\n          dp(to)(j)(j) %= MOD\n        }\n      }\n    }\n  }\n\n  println(dp(M % 2)(N)(N))\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,int> plli;\ntypedef pair<int,pii> pipii;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<pii> vpii;\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n);i>=0;i--)\n#define rrep2(i,a,b) for (int i=(a);i>b;i--)\n#define pb push_back\n#define fi first\n#define se second\n#define all(a) (a).begin(),(a).end()\n\nconst int mod = 1e9 + 7;\nconst ll INF = 1<<30;\nconst int dx[4] = {1, 0, -1, 0};\nconst int dy[4] = {0, 1, 0, -1};\nconst double pi = 3.141592653589793;\n\nint n,m;\nll dp[305][305][305];\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cin >> n >> m;\n    dp[0][1][1]=1;\n    rep2(i,1,m+1)rep2(j,1,n+1)rep2(k,1,j+1){\n        if (j!=n) dp[i][j+1][k]+=(dp[i-1][j][k]*(n-j))%mod;\n        dp[i][j][k]+=(dp[i-1][j][k]*(j-k))%mod;\n        dp[i][j][j]+=(dp[i-1][j][k]*k)%mod;\n    }\n    cout << dp[m][n][n]%mod << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define LL long long\n#define prim 1000000007\nusing namespace std;\n\nLL N,M,dp[2][310][310];\n\nint main(){\n    cin >> N >> M;\n\n    int i,j,k; bool l=0;\n    dp[0][0][0]=1;\n    for (i=M; i>0; i--){\n        l=!l;\n        for (j=0; j<N; j++)\n            for (k=0; k<=j; k++){\n                dp[l][j][k]=((N-j)*dp[!l][j-k][0])%prim;\n                dp[l][j][k]=(dp[l][j][k]+k*dp[!l][j][k])%prim;\n                dp[l][j][k]=(dp[l][j][k]+(j-k)*dp[!l][j][k+1])%prim;\n            }\n    }\n\n    cout << dp[l][N-1][0] << \"\\n\";\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n#define pb push_back\n#define mp make_pair\n#define eps 1e-9\n#define INF 2000000000\n#define LLINF 1000000000000000ll\n#define sz(x) ((int)(x).size())\n#define fi first\n#define sec second\n#define all(x) (x).begin(),(x).end()\n#define sq(x) ((x)*(x))\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);(i)++)\n#define repn(i,a,n) for(int (i)=(a);(i)<(int)(n);(i)++)\n#define EQ(a,b) (abs((a)-(b))<eps)\n#define dmp(x) cerr << __LINE__ << \" \" << #x << \" \" << x << endl;\ntemplate<class T> void chmin(T& a,const T& b){if(a>b)a=b;}\ntemplate<class T> void chmax(T& a,const T& b){if(a<b)a=b;}\ntemplate<class T>\nusing MaxHeap = priority_queue<T>;\ntemplate<class T>\nusing MinHeap = priority_queue<T,vector<T>,greater<T> >;\ntemplate<class T,class U>\nostream& operator << (ostream& os,pair<T,U>& p){\n  os << p.fi << ',' << p.sec; return os;\n}\ntemplate<class T,class U>\nistream& operator >> (istream& is,pair<T,U>& p){\n  is >> p.fi >> p.sec; return is;\n}\ntemplate<class T>\nostream& operator << (ostream &os,const vector<T> &vec){\n  for(int i=0;i<vec.size();i++){\n    os << vec[i];\n    if(i+1<vec.size())os << ' ';\n  }\n  return os;\n}\ntemplate<class T>\nistream& operator >> (istream &is,vector<T>& vec){\n  for(int i=0;i<vec.size();i++)is >> vec[i];\n  return is;\n}\nvoid fastio(){\n  cin.tie(0);\n  ios::sync_with_stdio(0);\n  cout<<fixed<<setprecision(20);\n}\nconst ll MOD = 1000000007ll; // if inv is needed, this shold be prime.\nstruct ModInt{\n\tll val;\n\tModInt():val(0ll){}\n\tModInt(ll v):val(((v%MOD)+MOD)%MOD){}\n\tModInt exp(ll y)const{\n\t\tif(!y)return ModInt(1ll);\n\t\tModInt a = exp(y/2ll);\n\t\ta *= a;\n\t\tif(y&1)a*=(*this);\n\t\treturn a;\n\t}\n\tbool operator==(const ModInt& x)const{return val==x.val;}\n\tinline bool operator!=(const ModInt& x)const{return !(*this==x);}\n\tbool operator<(const ModInt& x)const{return val<x.val;}\n\tbool operator>(const ModInt& x)const{return val>x.val;}\n\tinline bool operator>=(const ModInt& x)const{return !(*this<x);}\n\tinline bool operator<=(const ModInt& x)const{return !(*this>x);}\n\tModInt& operator+=(const ModInt& x){if((val+=x.val)>=MOD)val-=MOD;return *this;}\n\tModInt& operator-=(const ModInt& x){if((val+=MOD-x.val)>=MOD)val-=MOD;return *this;}\n\tModInt& operator*=(const ModInt& x){(val*=x.val)%=MOD;return *this;}\n\tModInt operator+(const ModInt& x)const{return ModInt(*this)+=x;}\n\tModInt operator-(const ModInt& x)const{return ModInt(*this)-=x;}\n\tModInt operator*(const ModInt& x)const{return ModInt(*this)*=x;}\n  friend istream& operator>>(istream&i,ModInt& x){i>>x.val;return i;}\n  friend ostream& operator<<(ostream&o,ModInt& x){o<<x.val;return o;}\n  ModInt pow(ModInt a,ll x) const {\n    ModInt res = ModInt(1ll);\n    while(x){\n      if(x&1)res *= a;\n      x >>= 1;\n      a = a*a;\n    }\n    return res;\n  }\n};\nvector<ModInt> inv,fac,facinv;\n// notice: 0C0 = 1 \nModInt nCr(int n,int r){\n\tassert(!(n<r));\n\tassert(!(n<0||r<0));\n\treturn fac[n]*facinv[r]*facinv[n-r];\n}\nvoid init(int SIZE){\n  fac.resize(SIZE+10);\n  inv.resize(SIZE+10);\n  facinv.resize(SIZE+10);\n\tfac[0]=ModInt(1ll);\n\tfor(int i=1;i<=SIZE;i++)fac[i]=fac[i-1]*ModInt(i);\n\tinv[1]=ModInt(1ll);\n\tfor(int i=2;i<=SIZE;i++)inv[i]=ModInt(0ll)-ModInt(MOD/i)*inv[MOD%i];\n\tfacinv[0]=ModInt(1ll);\n\tfor(int i=1;i<=SIZE;i++)facinv[i]=facinv[i-1]*inv[i];\n\treturn;\n}\nint N,M;\nModInt dp[305][305][305];\nint main(){\n  fastio();\n  cin >> N >> M;\n  dp[0][1][1] = ModInt(1ll);\n  for(int i=0;i<M;i++){\n    for(int j=1;j<=N;j++){\n      for(int k=1;k<=N;k++){\n        // if(dp[i][j][k]!=ModInt(0ll)){\n        //   cout << i << ' ' << j << ' ' << k << ' ' << dp[i][j][k] << endl;\n        // }\n        dp[i+1][j][k] += dp[i][j][k]*ModInt(k-j);\n        dp[i+1][j][k+1] += dp[i][j][k]*ModInt(N-k);\n        dp[i+1][k][k] += dp[i][j][k]*ModInt(j);\n      }\n    }\n  }\n  cout << dp[M][N][N] << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <string.h>\n\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\n#define ll long long\n#define ull unsigned ll\n#define db double\n#define INF 0x3f3f3f3f\n#define MOD 1000000007\n#define PII pair<int, int>\n\nint n,m;\nll dp[310][310][310];\n\nint main() {\n    scanf(\"%d%d\",&n,&m);\n    memset(dp,0,sizeof(dp));\n    dp[0][1][1]=1;\n    for (int i=0;i<m;i++) {\n        for (int j=1;j<=n;j++) {\n            for (int k=1;k<=n;k++) {\n                dp[i+1][j+1][k]=(dp[i+1][j+1][k]+dp[i][j][k]*(n-j))%MOD;\n                dp[i+1][j][k]=(dp[i+1][j][k]+dp[i][j][k]*(j-k))%MOD;\n                dp[i+1][j][j]=(dp[i+1][j][j]+dp[i][j][k]*k)%MOD;\n            }\n        }\n    }\n    printf(\"%lld\\n\",dp[m][n][n]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nconst long long mod = 1e9 + 7ll;\nconst int N = 300 + 10;\n\nlong long dp[ N ][ N ][ N ];\nint n, m;\n\nint main( void ) {\n\n\tcin.sync_with_stdio( false );\n\n\tcin >> n >> m;\n\tdp[0][1][1] = 1;\n\tfor ( int i = 0 ; i < m ; ++i ) {\n\t\tfor ( int city = 1 ; city <= n ; ++city ) {\n\t\t\tfor ( int cover = 1 ; cover <= n ; ++cover ) {\n\t\t\t\tlong long &d = dp[ i ][ city ][ cover ];\n\t\t\t\td %= mod;\n\t\t\t\tdp[ i+1 ][ city+1 ][ cover ] += ( ( n - city ) * d ) % mod;\n\t\t\t\tdp[ i+1 ][ city ][ cover ] += ( ( city - cover ) * d ) % mod;\n\t\t\t\tdp[ i+1 ][ city ][ city ] += ( cover * d ) % mod;\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << dp[m][n][n] % mod << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconstexpr int MOD = 1e9 + 7;\nusing fint64 = int_fast64_t;\ntemplate<fint64 MOD>\nstruct ModInt {\n\tfint64 x;\n\tModInt():x(0){}\n\tModInt(fint64 x):\n\t\tx(x>=0?x%MOD:(MOD-(-x)%MOD)%MOD)\n\t\t{}\n\t// 負号\n\tModInt operator -() const{\n\t\treturn ModInt(-x);\n\t}\n\t// 加算\n\tModInt &operator +=(const ModInt &rhs){\n\t\tx+=rhs.x;\n\t\tif(x>=MOD) x-=MOD;\n\t\treturn (*this);\n\t}\n\tModInt operator +(const ModInt &rhs) const{\n\t\treturn ModInt(*this)+=rhs;\n\t}\n\t// 減算\n\tModInt &operator -=(const ModInt &rhs){\n\t\tx+=MOD-rhs.x;\n\t\tif(x>=MOD) x-=MOD;\n\t\treturn (*this);\n\t}\n\tModInt operator -(const ModInt &rhs) const{\n\t\treturn ModInt(*this)-=rhs;\n\t}\n\t// 乗算\n\tModInt &operator *=(const ModInt &rhs){\n\t\tx*=rhs.x;\n\t\tif(x>=MOD) x%=MOD;\n\t\treturn (*this);\n\t}\n\tModInt operator *(const ModInt &rhs) const{\n\t\treturn ModInt(*this)*=rhs;\n\t}\n\t// 除算\n\tModInt &operator /=(const ModInt &rhs){\n\t\t(*this)*=rhs.inverse();\n\t\treturn (*this);\n\t}\n\tModInt operator /(const ModInt &rhs) const{\n\t\treturn ModInt(*this)/=rhs;\n\t}\n\t// 等号\n\tbool operator ==(const ModInt &rhs){\n\t\treturn x==rhs.x;\n\t}\n\tbool operator !=(const ModInt &rhs){\n\t\treturn x!=rhs.x;\n\t}\n\t// 累乗\n\tModInt pow(fint64 n) const{\n\t\tfint64 tmp=x;\n\t\tfint64 ret=1;\n\t\twhile(n>0){\n\t\t\tif(n&1) ret=ret*tmp%MOD;\n\t\t\ttmp=tmp*tmp%MOD;\n\t\t\tn>>=1ll;\n\t\t}\n\t\treturn ModInt(ret);\n\t}\n\t// 逆元\n\tModInt inverse() const{\n\t\tfint64 a=x,b=MOD,s=1,t=0;\n\t\twhile(b>0){\n\t\t\tfint64 u=a/b;\n\t\t\ta-=u*b;\n\t\t\ts-=u*t;\n\t\t\tswap(a,b);\n\t\t\tswap(s,t);\n\t\t}\n\t\treturn ModInt(s);\n\t}\n\t// 入出力\n\tfriend istream &operator >>(istream &lhs,ModInt<MOD> &rhs){\n\t\tfint64 x; lhs>>x;\n\t\trhs=ModInt<MOD>(x);\n\t\treturn lhs;\n\t}\n\tfriend ostream &operator <<(ostream &lhs,const ModInt<MOD> &rhs){\n\t\treturn lhs<<rhs.x;\n\t}\n};\nusing mint = ModInt<MOD>;\n\n// dp[i][j][k] := i回操作，孤立点j個，左端連結サイズk\nmint dp[310][310][310];\nint main() {\n\tint n, m; cin >> n >> m;\n\tdp[0][n - 1][1] = 1;\n\tfor(int i = 0; i < m; ++i) {\n\t\tfor(int j = 0; j < n; ++j) {\n\t\t\tfor(int k = 1; k <= n; ++k) {\n\t\t\t\tif(j - 1 >= 0) dp[i + 1][j - 1][k] += dp[i][j][k] * j;\n\t\t\t\tdp[i + 1][j][k] += dp[i][j][k] * max(0, n - j - k);\n\t\t\t\tif(n - j >= 0) dp[i + 1][j][n - j] += dp[i][j][k] * k;\n\t\t\t}\n\t\t}\n\t}\n\tcout << dp[m][0][n] << '\\n';\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconstexpr int mod = 1e9 + 7;\n\nint64_t dp[334][334][334];\n\nint main() {\n  int n, m;\n  cin >> n >> m;\n\n  dp[0][n - 1][1] = 1;\n  for (int i = 0; i < m; ++i) {\n    for (int j = 0; j < n; ++j) {\n      for (int k = 1; k <= n; ++k) {\n        (dp[i + 1][j][n - j] += k * dp[i][j][k] % mod) %= mod;\n        (dp[i + 1][j - 1][k] += j * dp[i][j][k] % mod) %= mod;\n        (dp[i + 1][j][k] += (n - j - k) * dp[i][j][k]) %= mod;\n      }\n    }\n  }\n\n  cout << dp[m][0][n] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int64_t MOD = 1e9+7;\nvoid add(int64_t& a, int64_t b){\n    a = (a+b) % MOD;\n}\nvoid mul(int64_t& a, int64_t b){\n    a = a*b % MOD;\n}\n\nint main(){\n    int N, M;\n    cin >> N >> M;\n\n    static int64_t dp[301][302][302];\n    dp[0][1][0] = 1;\n    for(int i=0; i<M; i++) for(int j=0; j<=N; j++) for(int k=0; k<=N; k++){\n        if(dp[i][j][k] == 0) continue;\n        int r = N-j-k;\n        add(dp[i+1][j+k][0], dp[i][j][k] * j);\n        add(dp[i+1][j][k], dp[i][j][k] * k);\n        add(dp[i+1][j][k+1], dp[i][j][k] * r);\n    }\n    cout << dp[M][N][0] << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<set>\n#include<map>\n#include<cmath>\n#include<queue>\n#include<bitset>\n#include<string>\n#include<cstdio>\n#include<cctype>\n#include<cassert>\n#include<cstdlib>\n#include<cstring>\n#include<sstream>\n#include<iostream>\n#include<algorithm>\n\n#define For(i,x,y) for (int i=x;i<y;i++)\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n\n#define dprintf(...) fprintf(stderr,__VA_ARGS__)\nusing namespace std;\n\nint IN(){\n\tint c,f,x;\n\twhile (!isdigit(c=getchar())&&c!='-');c=='-'?(f=1,x=0):(f=0,x=c-'0');\n\twhile (isdigit(c=getchar())) x=(x<<1)+(x<<3)+c-'0';return !f?x:-x;\n}\n\ntypedef long long ll;\ntypedef double db;\ntypedef pair<int,int> pii;\ntypedef vector<int> Vi;\n\nconst int N=300+3;\nconst int p=1e9+7;\n\nint C[N][N],F[N][N],G[N][N],pw[N][N],iv[N][N];\nint n,m,res;\n\nint Pow(int a,int b){\n\tint res=1;\n\tfor (;b;b>>=1,a=1ll*a*a%p) if (b&1) res=1ll*res*a%p;\n\treturn res;\n}\n\nint main(){\n\tFor(i,0,N){\n\t\tC[i][0]=1;\n\t\tFor(j,1,i+1) C[i][j]=(C[i-1][j-1]+C[i-1][j])%p;\n\t}\n\tFor(i,0,N) For(j,0,N){\n\t\tpw[i][j]=Pow(i,j);\n\t\tiv[i][j]=Pow(pw[i][j],p-2);\n\t}\n\tn=IN(),m=IN();\n\tFor(b,0,m+1){\n\t\tFor(a,1,n+1){\n\t\t\tF[a][b]=pw[a][b];\n\t\t\tFor(i,1,a){\n\t\t\t\tF[a][b]=(F[a][b]-1ll*G[a][i]*pw[a-i][b]%p+p)%p;\n\t\t\t}\n\t\t\tFor(i,a+1,n+1){\n\t\t\t\tG[i][a]=(G[i][a]+1ll*C[i-1][a-1]*iv[i-a][b]%p*F[a][b])%p;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\",F[n][m]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int MAXN = 300 + 5;\nconst int MOD = 1e9 + 7;\n\nint n, m, d[MAXN][MAXN][MAXN];\nint ans = 0;\n\nint main(){\n\tcin >> n >> m;\n\td[0][1][0] = 1;\n\tfor (int i = 0; i < m; i++)\n\t\tfor (int j = 1; j <= n; j++)\n\t\t\tfor (int w = 0; w <= n; w++){\n\t\t\t\tif (j + w < n){\n\t\t\t\t\td[i + 1][j + 1][w] = (d[i + 1][j + 1][w] + 1ll * (n-j-w) * d[i][j][w]) % MOD;\n\t\t\t\t\td[i + 1][j][w + 1] = (d[i + 1][j][w + 1] + 1ll * (n-j-w) * d[i][j][w]) % MOD;\n\t\t\t\t}\n\t\t\t\td[i + 1][j - 1][w + 1] = (d[i + 1][j - 1][w + 1] + 1ll * j * d[i][j][w]) % MOD;\n\t\t\t\td[i + 1][j][w] = (d[i + 1][j][w] + 1ll * j * d[i][j][w]) % MOD;\n\t\t\t}\n\n\tcout << d[m][0][n] << \"\\n\";\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <string.h>\n\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\n#define ll long long\n#define ull unsigned ll\n#define db double\n#define INF 0x3f3f3f3f\n#define MOD 1000000007\n#define PII pair<int, int>\n\nint n,m;\nll f[310][310];\n\nint main() {\n    scanf(\"%d%d\",&n,&m);\n    memset(f,0,sizeof(f));\n    f[0][0]=1;\n    for (int i=1;i<=m;i++) f[0][i]=(f[0][i-1]*n)%MOD;\n    for (int i=1;i<=n;i++) {\n        f[i][i]=1;\n        for (int j=i+1;j<=m;j++) {\n            f[i][j]=((n-1)*f[i][j-1]+f[i-1][j-1])%MOD;\n        }\n    }\n    ll ans=(f[n][m-1]+f[n-1][m-1])%MOD;\n    for (int i=1;i<n;i++) {\n        ans=(ans*i)%MOD;\n    }\n    printf(\"%lld\\n\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cstring>\nusing namespace std;\ntypedef long long ll;\n#define M 1000000007\nll n,m,ans;\nll dp[305][305][305];\nll z[305];\nint main(void){\n    cin>>n>>m;\n    for(int i=1;i<=m;i++)z[i]=z[i-1]*n%M;\n    dp[0][n-1][1]=1;\n    for(ll i=0;i<m;i++){\n        for(ll j=0;j<n;j++){\n            for(ll k=1;k<=n;k++){\n                dp[i+1][j-1][k]=(dp[i+1][j-1][k]+dp[i][j][k]*j%M)%M;\n                dp[i+1][j][k]=(dp[i+1][j][k]+dp[i][j][k]*(n-j-k)%M)%M;\n                dp[i+1][j][n-j]=(dp[i+1][j][n-j]+dp[i][j][k]*k)%M;\n            }\n        }\n    }\n    cout<<dp[m][0][n]<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define whlie while\n#define pb push_back\n#define eb emplace_back\n#define fi first\n#define se second\n#define rep(i,N) for(int i = 0; i < (N); i++)\n#define repr(i,N) for(int i = (N) - 1; i >= 0; i--)\n#define rep1(i,N) for(int i = 1; i <= (N) ; i++)\n#define repr1(i,N) for(int i = (N) ; i > 0 ; i--)\n#define each(x,v) for(auto& x : v)\n#define all(v) (v).begin(),(v).end()\n#define sz(v) ((int)(v).size())\n#define ini(...) int __VA_ARGS__; in(__VA_ARGS__)\n#define inl(...) ll __VA_ARGS__; in(__VA_ARGS__)\n#define ins(...) string __VA_ARGS__; in(__VA_ARGS__)\nusing namespace std; void solve();\nusing ll = long long; using vl = vector<ll>;\nusing vi = vector<int>; using vvi = vector< vector<int> >;\nconstexpr int inf = 1001001001;\nconstexpr ll infLL = (1LL << 61) - 1;\nstruct IoSetupNya {IoSetupNya() { cin.tie(nullptr); ios::sync_with_stdio(false); cout << fixed << setprecision(15); cerr << fixed << setprecision(7);} } iosetupnya;\ntemplate<typename T, typename U> inline bool amin(T &x, U y) { return (y < x) ? (x = y, true) : false; }\ntemplate<typename T, typename U> inline bool amax(T &x, U y) { return (x < y) ? (x = y, true) : false; }\ntemplate<typename T, typename U> ostream& operator <<(ostream& os, const pair<T, U> &p) { os << p.first << \" \" << p.second; return os; }\ntemplate<typename T, typename U> istream& operator >>(istream& is, pair<T, U> &p) { is >> p.first >> p.second; return is; }\ntemplate<typename T> ostream& operator <<(ostream& os, const vector<T> &v) { int s = (int)v.size(); rep(i,s) os << (i ? \" \" : \"\") << v[i]; return os; }\ntemplate<typename T> istream& operator >>(istream& is, vector<T> &v) { for(auto &x : v) is >> x; return is; }\nvoid in(){} template <typename T,class... U> void in(T &t,U &...u){ cin >> t; in(u...);}\nvoid out(){cout << \"\\n\";} template <typename T,class... U> void out(const T &t,const U &...u){ cout << t; if(sizeof...(u)) cout << \" \"; out(u...);}\ntemplate<typename T>void die(T x){out(x); exit(0);}\n#ifdef NyaanDebug\n  #include \"NyaanDebug.h\"\n  #define trc(...) do { cerr << #__VA_ARGS__ << \" = \"; dbg_out(__VA_ARGS__);} while(0)\n  #define trca(v,N) do { cerr << #v << \" = \"; array_out(v , N);cout << endl;} while(0)\n#else\n  #define trc(...)\n  #define trca(...)\n  int main(){solve();}\n#endif\nusing P = pair<ll,ll>; using vp = vector<P>;\nconstexpr int MOD = /**/ 1000000007; //*/ 998244353;\n/////////\n\ntemplate< int mod >\nstruct ModInt {\n  int x;\n\n  ModInt() : x(0) {}\n\n  ModInt(int64_t y) : x(y >= 0 ? y % mod : (mod - (-y) % mod) % mod) {}\n\n  ModInt &operator+=(const ModInt &p) {\n    if((x += p.x) >= mod) x -= mod;\n    return *this;\n  }\n\n  ModInt &operator-=(const ModInt &p) {\n    if((x += mod - p.x) >= mod) x -= mod;\n    return *this;\n  }\n\n  ModInt &operator*=(const ModInt &p) {\n    x = (int) (1LL * x * p.x % mod);\n    return *this;\n  }\n\n  ModInt &operator/=(const ModInt &p) {\n    *this *= p.inverse();\n    return *this;\n  }\n\n  ModInt operator-() const { return ModInt(-x); }\n\n  ModInt operator+(const ModInt &p) const { return ModInt(*this) += p; }\n\n  ModInt operator-(const ModInt &p) const { return ModInt(*this) -= p; }\n\n  ModInt operator*(const ModInt &p) const { return ModInt(*this) *= p; }\n\n  ModInt operator/(const ModInt &p) const { return ModInt(*this) /= p; }\n\n  bool operator==(const ModInt &p) const { return x == p.x; }\n\n  bool operator!=(const ModInt &p) const { return x != p.x; }\n\n  ModInt inverse() const {\n    int a = x, b = mod, u = 1, v = 0, t;\n    while(b > 0) {\n      t = a / b;\n      swap(a -= t * b, b);\n      swap(u -= t * v, v);\n    }\n    return ModInt(u);\n  }\n\n  ModInt pow(int64_t n) const {\n    ModInt ret(1), mul(x);\n    while(n > 0) {\n      if(n & 1) ret *= mul;\n      mul *= mul;\n      n >>= 1;\n    }\n    return ret;\n  }\n\n  friend ostream &operator<<(ostream &os, const ModInt &p) {\n    return os << p.x;\n  }\n\n  friend istream &operator>>(istream &is, ModInt &a) {\n    int64_t t;\n    is >> t;\n    a = ModInt< mod >(t);\n    return (is);\n  }\n\n  static int get_mod() { return mod; }\n};\n\nusing modint = ModInt< MOD >;\n\nmodint dp[303][303][303];\n\nvoid solve(){\n  ini(N , M);\n\n  dp[0][N - 1][1] = 1;\n\n  rep(t , M) rep(x , N + 1) rep(y , N + 1){\n    // (a)\n    dp[t + 1][x][N - x] += dp[t][x][y] * y;\n    // (b)\n    if(x) dp[t + 1][x - 1][y] += dp[t][x][y] * x;\n    // (c)\n    dp[t + 1][x][y] += dp[t][x][y] * (N-x-y);\n  }\n\n  out(dp[M][0][N]);\n\n  \n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <stdio.h>\n#include <stdlib.h>\n#include <vector>\n#include <map>\n#include <queue>\n#include <set>\n#include <string>\n#include <string.h>\n#include <stack>\n#include <assert.h>\n#include <bitset>\n#define Endl endl\n#define mp make_pair\n#define ll long long \n#define ull unsinged long long\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define over(A) {cout<<A<<endl;exit(0);}\n#define all(A) A.begin(),A.end()\n#define ceil(a,b) ((a-1)/b+1)\n#define srand() mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n#define rand(l,r) uniform_int_distribution<int>(l,r)(rng)\ntemplate <typename T1,typename T2> inline void chmin(T1 &x,T2 b) {if(b<x) x=b;}\ntemplate <typename T1,typename T2> inline void chmax(T1 &x,T2 b) {if(b>x) x=b;}\nconst int inf=1039074182;\nconst int mod=1e9+7;\nusing namespace std;\nint dp[305][305][305];\nint n,m;\n\nnamespace combinatorics\n{\n\tint *fac;\n\tint *ifac;\n\tint __Tmod;\n\tinline int add(int a,int b)\n\t{\n\t\treturn (a+b)%__Tmod;\n\t}\n\tinline int sub(int a,int b)\n\t{\n\t\treturn (a-b+__Tmod)%__Tmod;\n\t}\n\tinline int mult(int a,int b)\n\t{\n\t\treturn (1LL*a*b)%__Tmod;\n\t}\n\tinline int fastpow(int basic,int x)\n\t{\n\t\tif(x==0) return 1;\n\t\tint res=1;\n\t\twhile(x)\n\t\t{\n\t\t\tif(x&1)\tres=mult(res,basic);\n\t\t\tbasic=mult(basic,basic);\n\t\t\tx>>=1;\n\t\t}\n\t\treturn res;\n\t}\n\tinline int inv(int x)\n\t{\n\t\treturn fastpow(x,__Tmod-2);\n\t}\n\tvoid init(int n,int tmod)\n\t{\n\t\t__Tmod=tmod;\n\t\tfac=new int[n+5];\n\t\tifac=new int[n+5];\n\t\tfac[0]=1;\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t\tfac[i]=mult(fac[i-1],i);\n\t\t}\n\t\tifac[n]=inv(fac[n]);\n\t\tfor(int i=n-1;i>=0;i--)\n\t\t{\n\t\t\tifac[i]=mult(ifac[i+1],i+1);\n\t\t}\n\t}\n\tinline int C(int n,int m)\n\t{\n\t\treturn mult(mult(fac[n],ifac[m]),ifac[n-m]);\n\t}\n\tinline int Cat(int x)\n\t{\n\t\treturn mult(C(x*2,x),inv(x+1));\n\t}\n};\nusing namespace combinatorics;\n\ntemplate <typename T1,typename T2> upadd(T1 &a,T2 b) {a+=b;if(a>=mod) a-=mod;}\n\nint main()\n{\n//\tfreopen(\"input.txt\",\"r\",stdin);\n\tcin>>n>>m;\n\tinit(300,1e9+7);\n\tdp[0][1][1]=1;\n\tfor(int i=0;i<m;i++)\n\t{\n\t\tfor(int j=1;j<=min(i+1,n);j++)\n\t\t{\n\t\t\tfor(int k=1;k<=j;k++)\n\t\t\t{\n\t\t\t\tint now=dp[i][j][k];\n\t\t\t\tupadd(dp[i+1][j][j],mult(now,k));\n\t\t\t\tupadd(dp[i+1][j][k],mult(now,j-k));\n\t\t\t\tupadd(dp[i+1][j+1][k],mult(now,n-j));\n\t\t\t}\n\t\t}\n\t}\n\tcout<<dp[m][n][n]<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define FOR(i,a,b) for (int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define RREP(i,n) for (int i=(n)-1;i>=0;i--)\ntypedef long long LL;\nLL dp[302][302];\nLL dp2[302][302];\nint N;\nint M;\nint main(){\n        REP(i,302){\n            REP(j,302){\n                dp[i][j]=0;\n                dp2[i][j]=0;\n            }\n        }\n\tcin>>N>>M;\n\tdp[0][0]=1;\n\tREP(k,M){\n\t    REP(i,N){\n\t        REP(j,N){\n\t            //進む\n\t            dp2[i+1][j]+=(dp[i][j]*(N-1-i));\n\t             dp2[i+1][j]%=1000000007;\n\t            //戻る\n\t            if(j<=i){\n\t               dp2[i][i]+=(dp[i][j]*(j+1));\n\t                dp2[i][i]%=1000000007;\n\t            }\n\t            //自己ループ\n\t            dp2[i][j]+=(dp[i][j]*(i-j));\n\t            dp2[i][j]%=1000000007;\n\t        }\n\t    }\n\t    REP(i,N){\n\t        REP(j,N){\n\t            dp[i][j]=(dp2[i][j]%1000000007);\n\t            dp2[i][j]=0;\n\t        }\n\t    }\n\t}\n\t/*REP(i,30){\n\t        REP(j,30){\n\t        cout<<i<<\" \"<<j<<\" \"<<dp[i][j]<<endl;\n\t        }\n\t    }\n\t    cout<<endl;\n\t*/\n        cout<<dp[N-1][N-1]<<endl;\n\treturn(0);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\ntypedef long long int lli;\nlli dp[310][310][310];\n\nint main(){\n  int n, m;\n  int mod = 1e9+7;\n  std::cin >> n >> m;\n  if(m < n - 1){\n    std::cout << 0 << std::endl;\n    return 0;\n  }\n  dp[0][1][1] = 1;\n  for (int i = 0; i < m; i++) {\n    for (int j = 1; j <= n; j++) {\n      for (int k = 1; k <= n; k++) {\n        if(j + 1 <= n){\n          dp[i + 1][j + 1][k] += dp[i][j][k]*(n - j);\n          dp[i + 1][j + 1][k] %= mod;\n        }\n        dp[i + 1][j][k] += dp[i][j][k]*(j - k);\n        dp[i + 1][j][j] += dp[i][j][k]*k;\n        dp[i + 1][j][k] %= mod;\n        dp[i + 1][j][j] %= mod;\n      }\n    }\n  }\n  std::cout << dp[m][n][n] << std::endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n#define pb push_back\n#define ins insert\n#define pii pair<int,int>\n#define fs first\n#define sc second\n#define mpr make_pair\n#define iter iterator\n#define all(X) X.begin(),X.end()\n#define sau(X) sort(all(X)),X.resize(unique(all(X))-X.begin())\n#define exist(X,ele) binary_search(all(X),ele)\n#define y0 I_love_Ryougi_Shiki_0\n#define y1 I_love_Ryougi_Shiki_1\n\ntemplate<typename T1,typename T2>\nostream& operator << (ostream& out,const pair<T1,T2>& X)\n{\n\tout<<\"{\"<<X.fs<<\",\"<<X.sc<<\"}\";\n\treturn out;\n}\n\ntemplate<typename T>\nostream& operator << (ostream& out,const vector<T>& X)\n{\n\tfor(auto i:X) out<<i<<\" \";\n\treturn out;\n}\n\ntemplate<typename T>\ninline void cmin(T& x,T y)\n{\n\tif(!(x<y)) x=y;\n}\n\ntemplate<typename T>\ninline void cmax(T& x,T y)\n{\n\tif(x<y) x=y;\n}\n\nconst int inf=5000000000000000ll;\nconst int mod=1000000007;\n\nint dp[310][210][210]; // i edges | j points in total | k points can reach 1\n\nmain()\n{\n\tios::sync_with_stdio(false);\n\t\n\tint N,M; cin>>N>>M;\n\tif(N>M)\n\t{\n\t\tcout<<\"0\"<<endl;\n\t\treturn 0;\n\t}\n\tdp[0][1][1]=1;\n\tfor(int i=0;i<M;i++)\n\t{\n\t\tfor(int j=1;j<=N && j<=i+1;j++)\n\t\t{\n\t\t\tfor(int k=1;k<=j;k++)\n\t\t\t{\n\t\t\t\tif(dp[i][j][k]==0) continue;\n\t\t\t\tif(j<N) dp[i+1][j+1][k]+=dp[i][j][k]*(N-j),dp[i+1][j+1][k]%=mod; // nxt=white->grey\n\t\t\t\tdp[i+1][j][k]+=dp[i][j][k]*(j-k),dp[i+1][j][k]%=mod; // nxt=grey\n\t\t\t\tdp[i+1][j][j]+=dp[i][j][k]*k,dp[i+1][j][j]%=mod; // nxt=black all grey->black\n\t\t\t}\n\t\t}\n\t}\n\tcout<<dp[M][N][N]<<endl;\n\t\n\treturn 0;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define fbo find_by_order\n#define ook order_of_key\n\ntypedef long long ll;\ntypedef pair<ll,ll> ii;\ntypedef vector<int> vi;\ntypedef long double ld; \ntypedef tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> pbds;\ntypedef set<int>::iterator sit;\ntypedef map<int,int>::iterator mit;\ntypedef vector<int>::iterator vit;\n\nconst int MOD = 1e9 + 7;\nll dp[301][301];\nll g[301][301];\nll c[301][301];\n\nvoid add(ll &a, ll b)\n{\n\ta=(a+b)%MOD;\n}\n\nll mult(ll a, ll b)\n{\n\treturn (a*b)%MOD;\n}\n\nll choose(int n, int r)\n{\n\tif(n < r) return 0;\n\tif(n==r) return 1;\n\tif(r==0) return 1;\n\tif(c[n][r]!=-1) return c[n][r];\n\tc[n][r] = (choose(n-1,r)+choose(n-1,r-1))%MOD;\n\treturn c[n][r];\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tmemset(c,-1,sizeof(c));\n\tint n, m; cin>>n>>m;\n\tg[0][0] = 1;\n\tg[1][1] = 1;\n\tfor(int i = 2; i <= m; i++) g[i][1] = 1;\n\tfor(int j = 2; j <= n; j++)\n\t{\n\t\tfor(int i = j; i <= m; i++)\n\t\t{\n\t\t\tfor(int k = 1; k + j - 1 <= i; k++)\n\t\t\t{\n\t\t\t\tadd(g[i][j], mult(g[i-k][j-1], choose(i, k)));\n\t\t\t}\n\t\t}\n\t}\n\t//cerr<<g[10][3]<<'\\n';\n\tdp[0][1] = 1;\n\tfor(int i = 0; i < m; i++)\n\t{\n\t\tfor(int j = 1; j <= min(i+1,n); j++)\n\t\t{\n\t\t\tll val = dp[i][j];\n\t\t\tfor(int l = 1; l <= m - i; l++)\n\t\t\t{\n\t\t\t\tfor(int k = 0; k <= min(l - 1, n - j); k++)\n\t\t\t\t{\n\t\t\t\t\tint x = l+i;\n\t\t\t\t\tint y = k+j;\n\t\t\t\t\tadd(dp[x][y], mult(val, mult(choose(n-j,k),mult(g[l-1][k], j))));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << dp[m][n] << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#ifndef KOMAKI_LOCAL\n#define NDEBUG\n#endif\n\n#include <bits/stdc++.h>\n#include <sys/time.h>\n#include <unistd.h>\nusing namespace std;\n#define i64         int64_t\n#define rep(i, n)   for(i64 i = 0; i < ((i64)(n)); ++i)\n#define sz(v)       ((i64)((v).size()))\n#define bit(n)      (((i64)1)<<((i64)(n)))\n#define all(v)      (v).begin(), (v).end()\n\nstd::string dbgDelim(int &i){ return (i++ == 0 ? \"\" : \", \"); }\n#define dbgEmbrace(exp) { int i = 0; os << \"{\"; { exp; } os << \"}\"; return os; }\ntemplate <class T> std::ostream& operator<<(std::ostream &os, std::vector<T> v);\ntemplate <class T> std::ostream& operator<<(std::ostream &os, std::set<T> v);\ntemplate <class T> std::ostream& operator<<(std::ostream &os, std::queue<T> q);\ntemplate <class T> std::ostream& operator<<(std::ostream &os, std::priority_queue<T> q);\ntemplate <class T, class K> std::ostream& operator<<(std::ostream &os, std::pair<T, K> p);\ntemplate <class T, class K> std::ostream& operator<<(std::ostream &os, std::map<T, K> mp);\ntemplate <class T, class K> std::ostream& operator<<(std::ostream &os, std::unordered_map<T, K> mp);\ntemplate <int INDEX, class TUPLE> void dbgDeploy(std::ostream &os, TUPLE tuple){}\ntemplate <int INDEX, class TUPLE, class H, class ...Ts> void dbgDeploy(std::ostream &os, TUPLE t)\n{ os << (INDEX == 0 ? \"\" : \", \") << get<INDEX>(t); dbgDeploy<INDEX + 1, TUPLE, Ts...>(os, t); }\ntemplate <class T, class K> void dbgDeploy(std::ostream &os, std::pair<T, K> p, std::string delim)\n{ os << \"(\" << p.first << delim << p.second << \")\"; }\ntemplate <class ...Ts> std::ostream& operator<<(std::ostream &os, std::tuple<Ts...> t)\n{ os << \"(\"; dbgDeploy<0, std::tuple<Ts...>, Ts...>(os, t); os << \")\"; return os; }\ntemplate <class T, class K> std::ostream& operator<<(std::ostream &os, std::pair<T, K> p)\n{ dbgDeploy(os, p, \", \"); return os; }\ntemplate <class T> std::ostream& operator<<(std::ostream &os, std::vector<T> v)\n{ dbgEmbrace( for(T t: v){ os << dbgDelim(i) << t; }); }\ntemplate <class T> std::ostream& operator<<(std::ostream &os, std::set<T> s)\n{ dbgEmbrace( for(T t: s){ os << dbgDelim(i) << t; }); }\ntemplate <class T> std::ostream& operator<<(std::ostream &os, std::queue<T> q)\n{ dbgEmbrace( for(; q.size(); q.pop()){ os << dbgDelim(i) << q.front(); }); }\ntemplate <class T> std::ostream& operator<<(std::ostream &os, std::priority_queue<T> q)\n{ dbgEmbrace( for(; q.size(); q.pop()){ os << dbgDelim(i) << q.top();   }); }\ntemplate <class T, class K> std::ostream& operator<<(std::ostream &os, std::map<T, K> mp)\n{ dbgEmbrace( for(auto p: mp){ os << dbgDelim(i); dbgDeploy(os, p, \"->\"); }); }\ntemplate <class T, class K> std::ostream& operator<<(std::ostream &os, std::unordered_map<T, K> mp)\n{ dbgEmbrace( for(auto p: mp){ os << dbgDelim(i); dbgDeploy(os, p, \"->\"); }); }\n#define DBG_OUT std::cerr\n#define DBG_OVERLOAD(_1, _2, _3, _4, _5, _6, macro_name, ...) macro_name\n#define DBG_LINE() { char s[99]; sprintf(s, \"line:%3d | \", __LINE__); DBG_OUT << s; }\n#define DBG_OUTPUT(v) { DBG_OUT << (#v) << \"=\" << (v); }\n#define DBG1(v, ...) { DBG_OUTPUT(v); }\n#define DBG2(v, ...) { DBG_OUTPUT(v); DBG_OUT << \", \"; DBG1(__VA_ARGS__); }\n#define DBG3(v, ...) { DBG_OUTPUT(v); DBG_OUT << \", \"; DBG2(__VA_ARGS__); }\n#define DBG4(v, ...) { DBG_OUTPUT(v); DBG_OUT << \", \"; DBG3(__VA_ARGS__); }\n#define DBG5(v, ...) { DBG_OUTPUT(v); DBG_OUT << \", \"; DBG4(__VA_ARGS__); }\n#define DBG6(v, ...) { DBG_OUTPUT(v); DBG_OUT << \", \"; DBG5(__VA_ARGS__); }\n\n#define DEBUG0() { DBG_LINE(); DBG_OUT << std::endl; }\n#define DEBUG(...)                                                      \\\n  {                                                                     \\\n    DBG_LINE();                                                         \\\n    DBG_OVERLOAD(__VA_ARGS__, DBG6, DBG5, DBG4, DBG3, DBG2, DBG1)(__VA_ARGS__); \\\n    DBG_OUT << std::endl;                                               \\\n  }\n\n\nconst i64 MOD = (i64) (1e9 + 7);\nconst i64 MAX = 305;\ni64 dp[MAX][MAX][MAX];\ni64 recur(i64 n, i64 m, i64 left, i64 right)\n{\n  if(m == 0) return left == n ? 1 : 0;\n  i64 &res = dp[m][left][right];\n  if(res != -1) return res;\n  res = 0;\n  res = (res + recur(n, m - 1, left + right, 0) * left) % MOD;\n  res = (res + recur(n, m - 1, left, right) * right) % MOD;\n  res = (res + recur(n, m - 1, left, right + 1) * (n - left - right)) % MOD;\n  return res;\n}\n\n\nint main()\n{\n  i64 n, m;\n  cin >> n >> m;\n  memset(dp, -1, sizeof(dp));\n  cout << recur(n, m, 1, 0) << endl;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define mp make_pair\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<ll> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef pair<int,pii> pip;\ntypedef vector<pip>vip;\nconst double PI=acos(-1);\nconst double EPS=1e-8;\nconst int inf=1e8;\nll dp[310][310][310]={0};\nint main(){\n\tll MOD=1000000007;\n\tint n,m;\n\tcin>>n>>m;\n\tif(n>m){\n\t\tcout<<0<<endl;\n\t\treturn 0;\n\t}\n\tdp[0][1][1]=1;\n\trep(q,m)loop(i,1,n+1)loop(j,1,n+1){\n\t\t\tif(i!=n)(dp[q+1][i+1][j]+=dp[q][i][j]*(n-i))%=MOD;\n\t\t\t        (dp[q+1][i  ][j]+=dp[q][i][j]*(i-j))%=MOD;\n\t\t\t        (dp[q+1][i  ][i]+=dp[q][i][j]*(j  ))%=MOD;\n\t}\n\tcout<<dp[m][n][n]<<endl;\n}\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ADD(a, b) a = (a + ll(b)) % mod\n#define MUL(a, b) a = (a * ll(b)) % mod\n#define MAX(a, b) a = max(a, b)\n#define MIN(a, b) a = min(a, b)\n#define rep(i, a, b) for(int i = int(a); i < int(b); i++)\n#define rer(i, a, b) for(int i = int(a) - 1; i >= int(b); i--)\n#define all(a) (a).begin(), (a).end()\n#define sz(v) (int)(v).size()\n#define pb push_back\n#define sec second\n#define fst first\n#define debug(fmt, ...) Debug(__LINE__, \":\", fmt, ##__VA_ARGS__)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pi;\ntypedef pair<ll, ll> pl;\ntypedef pair<int, pi> ppi;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vl> mat;\ntypedef complex<double> comp;\nvoid Debug() {cout << '\\n'; }\ntemplate<class FIRST, class... REST>void Debug(FIRST arg, REST... rest){\n\tcout<<arg<<\" \";Debug(rest...);}\ntemplate<class T>ostream& operator<<(ostream& out,const vector<T>& v) {\n\tout<<\"[\";if(!v.empty()){rep(i,0,sz(v)-1)out<<v[i]<<\", \";out<<v.back();}out<<\"]\";return out;}\ntemplate<class S, class T>ostream& operator<<(ostream& out,const pair<S, T>& v){\n\tout<<\"(\"<<v.first<<\", \"<<v.second<<\")\";return out;}\nconst int MAX_N = 200010;\nconst int MAX_V = 100010;\nconst double eps = 1e-6;\nconst ll mod = 1000000007;\nconst int inf = 1 << 29;\nconst ll linf = 1LL << 60;\nconst double PI = 3.14159265358979323846;\n///////////////////////////////////////////////////////////////////////////////////////////////////\n\nint N, M;\nll dp[2][310][310];\n\nvoid solve() {\n\tcin >> N >> M;\n\tdp[0][N - 1][1] = 1;\n\t\n\tint now = 0, nex = 1;\n\trep(i, 0, M) {\n\t\tmemset(dp[nex], 0, sizeof(dp[nex]));\n\t\trep(j, 0, N + 1) {\n\t\t\trep(k, 0, N + 1) {\n\t\t\t\tif(!dp[now][j][k]) continue;\n\t\t\t\tif(j != 0) ADD(dp[nex][j - 1][k], dp[now][j][k] * j % mod);\n\t\t\t\tif(N - j - k > 0) ADD(dp[nex][j][k], dp[now][j][k] * (N - j - k) % mod);\n\t\t\t\tADD(dp[nex][j][N - j], dp[now][j][k] * k % mod);\n\t\t\t}\n\t\t}\n\t\tswap(now, nex);\n\t}\n\tcout << dp[now][0][N] << \"\\n\";;\n}\n\nint main() {\n#ifndef LOCAL\n\tios::sync_with_stdio(false);\n    cin.tie(0);\n#endif\n    cout << fixed;\n\tcout.precision(20);\n\tsrand((unsigned int)time(NULL));\n#ifdef LOCAL\n\t//freopen(\"in.txt\", \"wt\", stdout); //for tester\n    freopen(\"in.txt\", \"rt\", stdin);\n#endif\t\n\tsolve();\n#ifdef LOCAL\n    cerr << \"Time elapsed: \" << 1.0 * clock() / CLOCKS_PER_SEC << \" s.\\n\";\n#endif\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cstring>\nusing namespace std;\ntypedef long long ll;\n#define M 1000000007\nll n,m,ans;\nll dp[305][305][305];\nll z[305];\nint main(void){\n    cin>>n>>m;\n    z[0]=1;\n    for(int i=1;i<=m;i++)z[i]=z[i-1]*n%M;\n    dp[0][n-1][1]=1;\n    for(ll i=0;i<m;i++){\n        for(ll j=0;j<n;j++){\n            for(ll k=1;k<n;k++){\n                dp[i+1][j-1][k]=(dp[i+1][j-1][k]+dp[i][j][k]*j%M)%M;\n                dp[i+1][j][k]=(dp[i+1][j][k]+dp[i][j][k]*(n-j-k)%M)%M;\n                dp[i+1][j][n-j]=(dp[i+1][j][n-j]+dp[i][j][k]*k)%M;\n            }\n        }\n        ans=(ans+dp[i+1][0][n]*z[m-i-1]%M)%M;\n    }\n    cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <unistd.h>\n\nusing namespace std;\n\n#define DEBUG(x) cerr<<#x<<\": \"<<x<<endl;\n#define DEBUG_VEC(v) cerr<<#v<<\":\";for(int i=0;i<v.size();i++) cerr<<\" \"<<v[i]; cerr<<endl\n#define DEBUG_MAT(v) cerr<<#v<<endl;for(int i=0;i<v.size();i++){for(int j=0;j<v[i].size();j++) {cerr<<v[i][j]<<\" \";}cerr<<endl;}\n\n\ntypedef long long ll;\n#define vi vector<int>\n#define vl vector<ll>\n#define vii vector< vector<int> >\n#define vll vector< vector<ll> >\n#define vs vector<string>\n#define pii pair<int,int>\n#define pis pair<int,string>\n#define psi pair<string,int>\n#define pll pair<ll,ll>\ntemplate<class S, class T> pair<S, T> operator+(const pair<S, T> &s, const pair<S, T> &t) { return pair<S, T>(s.first + t.first, s.second + t.second); }\ntemplate<class S, class T> pair<S, T> operator-(const pair<S, T> &s, const pair<S, T> &t) { return pair<S, T>(s.first - t.first, s.second - t.second); }\ntemplate<class S, class T> ostream& operator<<(ostream& os, pair<S, T> p) { os << \"(\" << p.first << \", \" << p.second << \")\"; return os; }\n#define X first\n#define Y second\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define rep1(i,n) for(int i=1;i<=(n);i++)\n#define rrep(i,n) for(int i=(n)-1;i>=0;i--)\n#define rrep1(i,n) for(int i=(n);i>0;i--)\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define in(x, a, b) (a <= x && x < b)\n#define all(c) c.begin(),c.end()\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a = b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a = b; return 1; } return 0; }\n#define UNIQUE(v) v.erase(std::unique(v.begin(), v.end()), v.end());\nconst ll inf = 1000000001;\nconst ll INF = (ll)1e18 + 1;\nconst ll MOD = 1000000007;\n//const ll MOD = 998244353;\nconst double pi = 3.14159265358979323846;\n#define Sp(p) cout<<setprecision(15)<< fixed<<p<<endl;\nint dx[4] = { 1,0, -1,0 }, dy[4] = { 0,1,0,-1 };\nint dx2[8] = { 1,1,0,-1,-1,-1,0,1 }, dy2[8] = { 0,1,1,1,0,-1,-1,-1 };\n#define fio() cin.tie(0); ios::sync_with_stdio(false);\n//#define mp make_pair\n\n#define vlll vector<vll>\n\nint main() {\n  int n, m;\n  cin >> n >> m;\n  if (n > m) {\n    cout << 0 << endl;\n    return 0;\n  }\n\n  vlll dp(m + 1, vll(n + 1, vl(n + 1)));\n  dp[0][1][0] = 1;\n  \n  rep (i, m) {\n    rep (j, n + 1) {\n      rep (k, n + 1) {\n        ll koritsu = n - j - k;\n        if (koritsu < 0) continue;\n        if (dp[i][j][k] == 0) continue;\n        if (koritsu != 0) {\n          (dp[i + 1][j][k + 1] += dp[i][j][k] * koritsu % MOD) %= MOD;\n        }\n        (dp[i + 1][j][k] += dp[i][j][k] * k % MOD) %= MOD;\n        (dp[i + 1][j + k][0] += dp[i][j][k] * j % MOD) %= MOD;\n      }\n    }\n  }\n  cout << dp[m][n][0] % MOD << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<string.h>\nusing namespace std;\n\ntypedef long long LL;\ntypedef vector<int> VI;\n\n#define REP(i,n) for(int i=0, i##_len=(n); i<i##_len; ++i)\n#define EACH(i,c) for(__typeof((c).begin()) i=(c).begin(),i##_end=(c).end();i!=i##_end;++i)\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n\ntemplate<class T> inline void amin(T &x, const T &y) { if (y<x) x=y; }\ntemplate<class T> inline void amax(T &x, const T &y) { if (x<y) x=y; }\ntemplate<class Iter> void rprintf(const char *fmt, Iter begin, Iter end) {\n    for (bool sp=0; begin!=end; ++begin) { if (sp) putchar(' '); else sp = true; printf(fmt, *begin); }\n    putchar('\\n');\n}\ntemplate<int MOD>\nstruct ModInt {\n    unsigned x;\n    void undef() { x = (unsigned)-1; }\n    bool isnan() const { return x == (unsigned)-1; }\n    inline int getInt() const { return (int)x; }\n    template<class T> T get() const { return (T)x; }\n    inline int mod() const { return MOD; }\n    ModInt(int y=0) { if (y<0 || MOD<=y) y %= MOD; if (y<0) y += MOD; x=y; }\n    ModInt(long long y) { if (y<0 || MOD<=y) y %= MOD; if (y<0) y += MOD; x=y; }\n    ModInt(unsigned long long y) { if (MOD<=y) x = y % (unsigned long long)MOD; else x = y; }\n    ModInt &operator+=(const ModInt &y) { if ((x += y.x) >= MOD) x -= MOD; return *this; }\n    ModInt &operator-=(const ModInt &y) { if ((x += MOD - y.x) >= MOD) x -= MOD; return *this; }\n    ModInt &operator*=(const ModInt &y) { x = (unsigned long long)x * y.x % (unsigned long long)MOD; return *this; }\n    ModInt &operator/=(const ModInt &y) { x = (unsigned long long)x * y.inv().x % (unsigned long long)MOD; return *this; }\n    ModInt operator-() const { return (x ? MOD-x: 0); }\n    ModInt inv() const {\n\tunsigned a = MOD, b = x; int u = 0, v = 1;\n\twhile (b) {\n\t    int t = a / b;\n\t    a -= t * b; swap(a, b);\n\t    u -= t * v; swap(u, v);\n\t}\n\tif (u < 0) u += MOD;\n\treturn ModInt(u);\n    }\n    ModInt pow(long long y) const {\n\tModInt b = *this, r = 1;\n\tif (y < 0) { b = b.inv(); y = -y; }\n\tfor (; y; y>>=1) {\n\t    if (y&1) r *= b;\n\t    b *= b;\n\t}\n\treturn r;\n    }\n};\nconst LL MOD = 1000000007;\ntypedef ModInt<MOD> Mint;\nMint operator+(Mint x, const Mint &y) { if ((x.x += y.x) >= (unsigned)x.mod()) x.x -= x.mod(); return x; }\nMint operator-(Mint x, const Mint &y) { if ((x.x += x.mod() - y.x) >= (unsigned)x.mod()) x.x -= x.mod(); return x; }\nMint operator*(Mint x, const Mint &y) { x.x = (unsigned long long)x.x * y.x % (unsigned long long)x.mod(); return x; }\nMint operator/(Mint x, const Mint &y) { x.x = (unsigned long long)x.x * y.inv().x % (unsigned long long)x.mod(); return x; }\nbool operator<(const Mint &x, const Mint &y) { return x.x < y.x; }\nbool operator==(const Mint &x, const Mint &y) { return x.x == y.x; }\nbool operator!=(const Mint &x, const Mint &y) { return x.x != y.x; }\n\nint N, M;\nMint dp[2][311][311];\n\nint main() {\n    scanf(\"%d%d\", &N, &M);\n    int cur = 0, nxt = 1;\n    dp[0][1][0] = 1;\n\n    REP (t, M) {\n\tmemset(dp[nxt], 0, sizeof dp[nxt]);\n\n\tfor (int i=1; i<=t+1; i++) REP (j, N) if (dp[cur][i][j].x) {\n\t    dp[nxt][i+j][0] += dp[cur][i][j] * i;\n\t    dp[nxt][i][j] += dp[cur][i][j] * j;\n\t    if (i+j < N) dp[nxt][i][j+1] += dp[cur][i][j] * (N - i - j);\n\t}\n\n\tswap(cur, nxt);\n    }\n\n    printf(\"%d\\n\", dp[cur][N][0].getInt());\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconstexpr int mod = 1e9 + 7;\n\nint dp[334][334][334];\n\nint main() {\n  int n, m;\n  cin >> n >> m;\n\n  dp[0][n - 1][1] = 1;\n  for (int i = 0; i < m; ++i) {\n    for (int j = 0; j < n; ++j) {\n      for (int k = 1; k <= n; ++k) {\n        (dp[i + 1][j][n - j] += 1ll * k * dp[i][j][k] % mod) %= mod;\n        (dp[i + 1][j - 1][k] += 1ll * j * dp[i][j][k] % mod) %= mod;\n        (dp[i + 1][j][k] += 1ll * (n - j - k) * dp[i][j][k]) %= mod;\n      }\n    }\n  }\n\n  cout << dp[m][0][n] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <cstring>\n#include <sstream>\n#include <algorithm>\n#include <cstdlib>\n#include <map>\n#include <queue>\n#include <utility>\n#include <vector>\n#include <set>\n#include <memory.h>\n#include <iomanip>\n#include <bitset>\n#include <list>\n#include <stack>\n\nusing namespace std;\n\n#define mod 1000000007\n\nlong long int result[310][310][310] = {};\n\nint main()\n{\n\tint n, m;\n\tcin >> n >> m;\n\n\t// result[i][j][k] : 頂点1からの長さiのパスで、\n\t// パスに含まれるノード数はj個で\n\t// 頂点1と強連結しているものはk個\n\tresult[0][1][1] = 1;\n\tfor(int i = 0; i < m; i++){\n\t\tfor(int j = 0; j <= n; j++){\n\t\t\tfor(int k = 0; k <= j; k++){\n\t\t\t\tresult[i + 1][j + 1][k] += result[i][j][k] * (n - j);\n\t\t\t\tresult[i + 1][j + 1][k] = result[i + 1][j + 1][k] % mod;\n\t\t\t\tresult[i + 1][j][k] += result[i][j][k] * (j - k);\n\t\t\t\tresult[i + 1][j][k] = result[i + 1][j][k] % mod;\n\t\t\t\tresult[i + 1][j][j] += result[i][j][k] * k;\n\t\t\t\tresult[i + 1][j][j] = result[i + 1][j][j] % mod;\n\t\t\t}\n\t\t}\n\t}\n\tcout << result[m][n][n] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcountll\n\n#define INF 1e16\n#define mod 1000000007\n\nll N,M;\nll dp[301][301][301];\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  cin>>N>>M;\n\n  dp[0][1][1]=1;\n  rep(i,M)rep(j,N+1)rep(k,j+1){\n    if(dp[i][j][k]==0)continue;\n    { // not visited\n      if(j+1<=N)(dp[i+1][j+1][k]+=dp[i][j][k]*(N-j)%mod)%=mod;\n    }\n    { // sc\n      if(k>0)(dp[i+1][j][j]+=dp[i][j][k]*k%mod)%=mod;\n    }\n    { // back\n      (dp[i+1][j][k]+=dp[i][j][k]*(j-k)%mod)%=mod;\n    }\n  }\n\n  cout<<dp[M][N][N]<<endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n\nusing namespace std;\n\nconst int MOD = 1000000007;\n\nint main(){\n\tint N, M;\n\tstatic long long dp[301][301][301];\n\twhile(cin >> N >> M){\n\t\tmemset(dp, 0, sizeof(dp));\n\t\tdp[0][1][0] = 1;\n\t\tfor(int day=0;day<M;day++){\n\t\t\tfor(int ok=0;ok<N;ok++){\n\t\t\t\tfor(int ng=0;ng<N;ng++){\n\t\t\t\t\tif(dp[day][ok][ng] == 0) continue;\n\t\t\t\t\tdp[day+1][ok][ng] += dp[day][ok][ng] * ng;\n\t\t\t\t\tdp[day+1][ok][ng] %= MOD;\n\t\t\t\t\tdp[day+1][ok+ng][0] += dp[day][ok][ng] * ok;\n\t\t\t\t\tdp[day+1][ok+ng][0] %= MOD;\n\t\t\t\t\tdp[day+1][ok][ng+1] += dp[day][ok][ng] * (N - ok - ng);\n\t\t\t\t\tdp[day+1][ok][ng+1] %= MOD;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdp[day+1][N][0] += dp[day][N][0] * N;\n\t\t\tdp[day+1][N][0] %= MOD;\n\t\t}\n\t\tcout << dp[M][N][0] << endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <set>\n#include <vector>\n#include <cstring>\n\nusing namespace std;\n\ntypedef long long ll;\nconst ll mod = 1e9+7;\nll dp[333][333][333];\n\nll pl(ll a, ll b) {\n  return (a+b)%mod;\n}\nll ml(ll a, ll b) {\n  return (a*b)%mod;\n}\n\nint main(void) {\n  int n, m;\n  scanf(\"%d%d\", &n, &m);\n  dp[0][1][0] = 1;\n  for (int i = 0; i < m; i++) {\n    for (int j = 1; j <= n; j++) {\n      for (int k = 0; k < n; k++) {\n        // 強連結でない頂点から強連結でない頂点，新しく加える\n        if (n-j-k >= 0) {\n          dp[i+1][j][k+1] = pl(dp[i+1][j][k+1], ml(dp[i][j][k], n-j-k));\n        }\n        // 強連結でない頂点から強連結でない頂点へ\n        dp[i+1][j][k] = pl(dp[i+1][j][k], ml(dp[i][j][k], k));\n        // 強連結でない頂点から強連結な頂点へ\n        if (j+k <= n) {\n          dp[i+1][j+k][0] = pl(dp[i+1][j+k][0], ml(dp[i][j][k], j));\n        }\n      }\n    }\n  }\n  printf(\"%lld\\n\", dp[m][n][0]);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\n#define forn(i, n) for (int i = 0; i < (int)(n); ++i)\ntypedef long long LL;\ntypedef pair<int, int> PII;\n\nint n, m;\nint d[305], nd[305];\nint f[305][305], nf[305][305];\nconst int MOD = int(1e9) + 7;\n\ninline void add(int &x, LL y) {\n    x = (x + y) % MOD;\n}\n\nint main() {\n    cin >> n >> m;\n    memset(d, 0, sizeof d);\n    memset(f, 0, sizeof d);\n    d[1] = 1;\n    forn(times, m) {\n        memset(nd, 0, sizeof nd);\n        memset(nf, 0, sizeof nf);\n        for (int i = 1; i <= n; ++i) {\n            add(nd[i], (LL)d[i] * i);\n            add(nf[i + 1][i], (LL)d[i] * (n - i));\n        }\n        for (int i = 1; i <= n; ++i) {\n            for (int j = 1; j < i; ++j) {\n                if (f[i][j] == 0) {\n                    continue;\n                }\n                add(nf[i + 1][j], (LL)f[i][j] * (n - i));\n                add(nf[i][j], (LL)f[i][j] * (i - j));\n                add(nd[i], (LL)f[i][j] * j);\n            }\n        }\n        memcpy(d, nd, sizeof d);\n        memcpy(f, nf, sizeof f);\n    }\n    cout << d[n] << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\nconst int INF = (1<<30);\nconst ll INFLL = (1ll<<60);\nconst ll MOD = (ll)(1e9+7);\n\n#define l_ength size\n\nvoid mul_mod(ll& a, ll b){\n\ta *= b;\n\ta %= MOD;\n}\n\nvoid add_mod(ll& a, ll b){\n\ta = (a<MOD)?a:(a-MOD);\n\tb = (b<MOD)?b:(b-MOD);\n\ta += b;\n\ta = (a<MOD)?a:(a-MOD);\n}\n\nll dp[301][301][301];\n\nint main(void){\n\tint n,m,i,j,k;\n\tcin >> n >> m;\n\tdp[0][n-1][1] = 1ll;\n\tfor(i=0; i<m; ++i){\n\t\tfor(j=0; j<n; ++j){\n\t\t\tfor(k=0; k<n; ++k){\n\t\t\t\tif(j+k+1>n){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tadd_mod(dp[i+1][j][k+1],dp[i][j+1][k+1]*(j+1)%MOD);\n\t\t\t\tadd_mod(dp[i+1][j][k+1],dp[i][j][k+1]*(n-j-k-1)%MOD);\n\t\t\t\tadd_mod(dp[i+1][j][n-j],dp[i][j][k+1]*(k+1)%MOD);\n\t\t\t}\n\t\t}\n\t}\n\tcout << dp[m][0][n] << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <set>\n#include <vector>\n#include <cstring>\n\nusing namespace std;\n\ntypedef long long ll;\nconst ll mod = 1e9+7;\nll dp[333][333][333];\n\nll pl(ll a, ll b) {\n  return (a+b)%mod;\n}\nll ml(ll a, ll b) {\n  return (a*b)%mod;\n}\n\nvector<int> p;\nvector<int> g[11];\nint n, m;\nbool used[11];\nbool chk(int x) {\n  if (x == 0) return true;\n  if (used[x]) return false;\n  used[x] = true;\n  for (int i = 0; i < int(g[x].size()); i++) {\n    if (chk(g[x][i])) return true;\n  }\n  return false;\n}\n\nint solve(int v) {\n  if (int(p.size()) == m+1) {\n    if (p[0] != 0) return 0;\n    for (int i = 0; i < n; i++) {\n      g[i].clear();\n    }\n    for (int i = 0; i < int(p.size())-1; i++) {\n      if (p[i] != p[i+1]) {\n        g[p[i]].push_back(p[i+1]);\n      }\n    }\n    for (int i = 1; i < n; i++) {\n      memset(used, 0, sizeof(used));\n      if (!chk(i)) {\n        return 0;\n      }\n    }\n    return 1;\n  }\n  int res = 0;\n  for (int i = 0; i < n; i++) {\n    p.push_back(i);\n    res += solve(i);\n    p.pop_back();\n  }\n  return res;\n}\n\nint main(void) {\n  scanf(\"%d%d\", &n, &m);\n  // printf(\"%d\\n\", solve(0));\n  dp[0][1][0] = 1;\n  for (int i = 0; i < m; i++) {\n    for (int j = 1; j <= n; j++) {\n      //*\n      // 強連結な頂点から強連結な頂点へ\n      dp[i+1][j][0] = pl(dp[i+1][j][0], ml(dp[i][j][0], j));\n      // 強連結な頂点から強連結でない頂点へ\n      dp[i+1][j][1] = pl(dp[i+1][j][1], ml(dp[i][j][0], n-j));\n      //*/\n      for (int k = 1; k < n; k++) {\n        // 強連結でない頂点から強連結でない頂点，新しく加える\n        if (n-j-k >= 0) {\n          dp[i+1][j][k+1] = pl(dp[i+1][j][k+1], ml(dp[i][j][k], n-j-k));\n        }\n        // 強連結でない頂点から強連結でない頂点へ\n        dp[i+1][j][k] = pl(dp[i+1][j][k], ml(dp[i][j][k], k));\n        // 強連結でない頂点から強連結な頂点へ\n        if (j+k <= n) {\n          dp[i+1][j+k][0] = pl(dp[i+1][j+k][0], ml(dp[i][j][k], j));\n        }\n      }\n    }\n  }\n  ll res = 0;\n  for (int i = 0; i < n; i++) {\n    // printf(\"%lld\\n\", dp[m][n][i]);\n    res = pl(res, dp[m][n][i]);\n  }\n  printf(\"%lld\\n\", res);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long int64;\n\nconst int mod = 1e9 + 7;\n\nint dp[301][301][301];\nint N, M;\n\nint64 rec(int idx, int connect, int add)\n{\n  if(idx == M) return (connect == N);\n  if(~dp[idx][connect][add]) return (dp[idx][connect][add]);\n  int64 ret = 0;\n  if(connect + add + 1 <= N) ret += rec(idx + 1, connect, add + 1) * (N - connect - add) % mod;\n  if(add > 0) ret += rec(idx + 1, connect, add) * add % mod;\n  ret += rec(idx + 1, connect + add, 0) * connect % mod;\n  ret %= mod;\n  return (dp[idx][connect][add] = ret);\n}\n\nint main()\n{\n  cin >> N >> M;\n  memset(dp, -1, sizeof(dp));\n  cout << rec(0, 1, 0) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip> // << fixed << setprecision(xxx)\n#include <algorithm> // do { } while ( next_permutation(A, A+xxx) ) ;\n#include <vector>\n#include <string> // to_string(nnn) // substr(m, n) // stoi(nnn)\n#include <complex>\n#include <tuple> // get<n>(xxx)\n#include <queue>\n#include <stack>\n#include <map> // if (M.find(key) != M.end()) { }\n#include <set> // S.insert(M);\n// if (S.find(key) != S.end()) { }\n// for (auto it=S.begin(); it != S.end(); it++) { }\n// auto it = S.lower_bound(M);\n#include <random> // random_device rd; mt19937 mt(rd());\n#include <cctype>\n#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib> // atoi(xxx)\nusing namespace std;\n\n#define DEBUG 0 // change 0 -> 1 if we need debug.\n// insert #if<tab> by my emacs. #if DEBUG == 1 ... #end\n\ntypedef long long ll;\n\n// const int dx[4] = {1, 0, -1, 0};\n// const int dy[4] = {0, 1, 0, -1};\n\n// const int C = 1e6+10;\nconst ll MOD = 1000000007;\n\nll dp[310][310][310];\nll N, M;\n\nint main () {\n  cin >> N >> M;\n  for (auto d = 0; d <= M; ++d) {\n    for (auto i = 1; i <= d+1; ++i) {\n      for (auto j = 0; i+j <= d+1; ++j) {\n        dp[d][i][j] = 0;\n      }\n    }\n  }\n  dp[0][1][0] = 1;\n  for (auto d = 0; d <= M; ++d) {\n    for (auto i = 1; i <= d+1; ++i) {\n      for (auto j = 0; i+j <= d+1; ++j) {\n        dp[d+1][i][j+1] += (dp[d][i][j] * (N-i-j))%MOD;\n        dp[d+1][i][j+1] %= MOD;\n        dp[d+1][i][j] += (dp[d][i][j] * j)%MOD;\n        dp[d+1][i][j] %= MOD;\n        dp[d+1][i+j][0] += (dp[d][i][j] * i) %MOD;\n        dp[d+1][i+j][0] %= MOD;\n      }\n    }\n  }\n  cout << dp[M][N][0] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cassert>\n#include <typeinfo>\n#include <vector>\n#include <stack>\n#include <cmath>\n#include <set>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n#include <queue>\n#include <iomanip>\n#include <cctype>\n#include <random>\n#include <complex>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<string> vs;\ntypedef vector<bool> vb;\ntypedef vector<vb> vvb;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<P,int> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<30;\nconst ll INF=1ll<<62;\nconst double pi=acos(-1);\nconst double eps=1e-7;\nconst ll mod=1e9+7;\nconst int dx[4]={0,1,0,-1},dy[4]={1,0,-1,0};\n\nint n,m;\n\nint main(){\n\tcin>>n>>m;\n\tvvl dp,DP;\n\tdp=DP=vvl(n+1,vl(n+1));\n\tdp[1][0]=1;\n\tfor(int i=0;i<m;i++){\n\t\tfor(int j=1;j<=n;j++){\n\t\t\tDP[j][0]=0;\n\t\t\tfor(int k=1;k<=j;k++) (DP[j][0]+=dp[k][j-k]*k)%=mod;\n\t\t}\n\t\tfor(int j=1;j<=n;j++) for(int k=1;k<=n;k++){\n\t\t\tDP[j][k]=(dp[j][k]*k+dp[j][k-1]*(n-j-k+1))%mod;\n\t\t}\n\t\tdp=DP;\n\t}\n\tcout<<dp[n][0]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define fbo find_by_order\n#define ook order_of_key\n\ntypedef long long ll;\ntypedef pair<ll,ll> ii;\ntypedef vector<int> vi;\ntypedef long double ld; \ntypedef tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> pbds;\ntypedef set<int>::iterator sit;\ntypedef map<int,int>::iterator mit;\ntypedef vector<int>::iterator vit;\n\nconst int MOD = 1e9 + 7;\nint dp[301][301];\nint g[301][301];\nint c[301][301];\n\nvoid add(int &a, int b)\n{\n\ta=(a+b)%MOD;\n}\n\nint mult(int a, int b)\n{\n\treturn (a*1LL*b)%MOD;\n}\n\nint choose(int n, int r)\n{\n\tif(n < r) return 0;\n\tif(n==r) return 1;\n\tif(r==0) return 1;\n\tif(c[n][r]!=-1) return c[n][r];\n\tc[n][r] = (choose(n-1,r)+choose(n-1,r-1))%MOD;\n\treturn c[n][r];\n}\n\n\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tmemset(c,-1,sizeof(c));\n\tint n, m; cin>>n>>m;\n       if(n>m+1) cout<<0<<'\\n';\n\tg[0][0] = 1;\n\tg[1][1] = 1;\n\tfor(int i = 2; i <= m; i++) g[i][1] = 1;\n\tfor(int j = 2; j <= n; j++)\n\t{\n\t\tfor(int i = j; i <= m; i++)\n\t\t{\n\t\t\tfor(int k = 1; k + j - 1 <= i; k++)\n\t\t\t{\n\t\t\t\tadd(g[i][j], mult(g[i-k][j-1], choose(i, k)));\n\t\t\t}\n\t\t}\n\t}\n\t//cerr<<g[10][3]<<'\\n';\n\tdp[0][1] = 1;\n\tfor(int i = 0; i < m; i++)\n\t{\n\t\tfor(int j = 1; j <= min(i+1,n); j++)\n\t\t{\n\t\t\tint val = dp[i][j];\n\t\t\tfor(int l = 1; l <= m - i; l++)\n\t\t\t{\n\t\t\t\tfor(int k = 0; k <= min(l - 1, n - j); k++)\n\t\t\t\t{\n\t\t\t\t\tadd(dp[i+l][j+k], mult(val, mult(choose(n-j,k),mult(g[l-1][k], j))));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << dp[m][n] << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <iomanip>\n#include <climits>\n#include <limits>\n#include <algorithm>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <list>\n#include <stack>\n#include <string>\n#include <functional>\n#include <numeric>\n#include <map>\n#include <set>\n#include <cstdlib>\n#include <bitset>\n#include <unordered_map>\n#include <random>\n#include <cmath>\n#include <complex>\n\nusing namespace std;\n\ntypedef long long int ll;\ntypedef vector<int> vi;\ntypedef vector<vector<int>> vvi;\ntypedef pair<int, int> P;\ntypedef pair<ll, ll> Pll;\ntypedef vector<ll> vll;\ntypedef vector<vector<ll>> vvll;\n\nconst int INFL = (int)1e9;\nconst ll INFLL = (ll)1e18;\nconst double INFD = numeric_limits<double>::infinity();\nconst double PI = 3.14159265358979323846;\n#define Loop(i, n) for(int i = 0; i < (int)n; i++)\n#define Loopll(i, n) for(ll i = 0; i < (ll)n; i++)\n#define Loop1(i, n) for(int i = 1; i <= (int)n; i++)\n#define Loopll1(i, n) for(ll i = 1; i <= (ll)n; i++)\n#define Loopr(i, n) for(int i = (int)n - 1; i >= 0; i--)\n#define Looprll(i, n) for(ll i = (ll)n - 1; i >= 0; i--)\n#define Loopr1(i, n) for(int i = (int)n; i >= 1; i--)\n#define Looprll1(i, n) for(ll i = (ll)n; i >= 1; i--)\n#define Loopitr(itr, container) for(auto itr = container.begin(); itr != container.end(); itr++)\n#define printv(vector) Loop(i, vector.size()) { cout << vector[i] << \" \"; } cout << endl;\n#define printmx(matrix) Loop(i, matrix.size()) { Loop(j, matrix[i].size()) { cout << matrix[i][j] << \" \"; } cout << endl; }\n#define rnd(d) (ll)((double)(d) + (d >= 0 ? 0.5 : -0.5))\n#define floorsqrt(x) ((ll)sqrt((double)x) + ((ll)sqrt((double)x) * (ll)sqrt((double)x) <= (ll)(x) ? 0 : -1))\n#define ceilsqrt(x) ((ll)sqrt((double)x) + ((ll)x <= (ll)sqrt((double)x) * (ll)sqrt((double)x) ? 0 : 1))\n#define ceildiv(a, b) ((ll)(a) / (ll)(b) + ((ll)(a) % (ll)(b) == 0 ? 0 : 1))\n#define bitmanip(m,val) static_cast<bitset<(int)m>>(val)\n\n/*******************************************************/\n\nnamespace mod_op {\n\n\tconst ll MOD = (ll)1e9 + 7;\n\n\tclass Extended_Euclid {\n\tprivate:\n\t\tll m, n;\n\t\tvvll mx_multiply(vvll mx1, vvll mx2) {\n\t\t\tvvll ret(mx1.size(), vll(mx2[0].size(), 0));\n\t\t\tLoop(i, mx1.size()) {\n\t\t\t\tLoop(j, mx1[0].size()) {\n\t\t\t\t\tLoop(k, mx2[0].size()) {\n\t\t\t\t\t\tret[i][j] += mx1[i][k] * mx2[k][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\tpublic:\n\t\t// solve x, y s.t. mx + ny = gcd(m,n)\n\t\tll x, y, gcd;\n\t\tExtended_Euclid(ll M, ll N) {\n\t\t\tm = M;\n\t\t\tn = N;\n\t\t\tvll r(100), k(100);\n\t\t\tbool swapflag = false, m_negflag = false, n_negflag = false;\n\t\t\tif (m < n) { swap(m, n); swapflag = true; }\n\t\t\tif (m < 0) { m *= -1; m_negflag = true; }\n\t\t\tif (n < 0) { n *= -1; n_negflag = true; }\n\t\t\tr[0] = m;\n\t\t\tr[1] = n;\n\t\t\tint h = 1;\n\t\t\twhile (1) {\n\t\t\t\tk[h - 1] = r[h - 1] / r[h];\n\t\t\t\tr[h + 1] = r[h - 1] % r[h];\n\t\t\t\tif (r[h + 1] == 0) break;\n\t\t\t\th++;\n\t\t\t}\n\t\t\tgcd = r[h];\n\t\t\tvvll mx1 = { { 0, 1 },{ 1, (-1) * k[h - 1] } };\n\t\t\tLoopr(i, h - 1) {\n\t\t\t\tvvll mx2 = { { 0, 1 },{ 1, (-1) * k[i] } };\n\t\t\t\tmx1 = mx_multiply(mx1, mx2);\n\t\t\t}\n\t\t\tx = mx1[0][0];\n\t\t\ty = mx1[0][1];\n\t\t\tif (n_negflag) { n *= -1; y *= -1; }\n\t\t\tif (m_negflag) { m *= -1; x *= -1; }\n\t\t\tif (swapflag) { swap(m, n); swap(x, y); }\n\t\t}\n\t};\n\n\tclass modll {\n\tprivate:\n\t\tll mod;\n\t\tll val;\n\t\tinline ll modify(ll x) { ll ret = x % mod; if (ret < 0) ret += mod; return ret; }\n\t\tinline ll inv(ll x) { if (x == 0) return 1 / x; Extended_Euclid ee(x, -mod); return modify(ee.x); }\n\tpublic:\n\t\tmodll(ll init = 0, ll mod = MOD) { modll::mod = mod; val = modify(init); return; }\n\t\tmodll(const modll& another) { val = another.val; mod = another.mod; return; }\n\t\tinline modll& operator=(const modll &another) { val = another.val; return *this; }\n\t\tinline modll operator+(const modll &x) { return (val + x.val) % mod; }\n\t\tinline modll operator-(const modll &x) { return (val - x.val) % mod; }\n\t\tinline modll operator*(const modll &x) { return (val * x.val) % mod; }\n\t\tinline modll operator/(const modll &x) { return (val * inv(x.val)) % mod; }\n\t\tinline modll& operator+=(const modll &x) { val = (val + x.val) % mod; return *this; }\n\t\tinline modll& operator-=(const modll &x) { val = (val - x.val) % mod; return *this; }\n\t\tinline modll& operator*=(const modll &x) { val = (val * x.val) % mod; return *this; }\n\t\tinline modll& operator/=(const modll &x) { val = (val * inv(x.val)) % mod; return *this; }\n\t\tfriend inline istream& operator >> (istream &is, modll& x) { is >> x.val; return is; }\n\t\tfriend inline ostream& operator << (ostream &os, modll& x) { os << x.val; return os; }\n\t\tll get_val() { return val; }\n\t\tll get_mod() { return mod; }\n\t};\n\n\tmodll pow(modll n, ll p) {\n\t\tmodll ret;\n\t\tif (p == 0) ret = 1;\n\t\telse if (p == 1) ret = n;\n\t\telse {\n\t\t\tret = pow(n, p / 2);\n\t\t\tret *= ret;\n\t\t\tif (p % 2 == 1) ret *= n;\n\t\t}\n\t\treturn ret;\n\t}\n}\n\nusing namespace mod_op;\n\nint main() {\n\tint n, m; cin >> n >> m;\n\tvector<vector<modll>> dp(301, vector<modll>(301, 0));\n\tdp[1][0] = 1;\n\tLoop(i, m) {\n\t\tvector<vector<modll>> dpbuf(301, vector<modll>(301, 0));\n\t\tLoop(j, 301) {\n\t\t\tLoop(k, 301) {\n\t\t\t\tif (j + k < 301) dpbuf[j + k][0] += dp[j][k] * j;\n\t\t\t\tdpbuf[j][k] += dp[j][k] * k;\n\t\t\t\tif (k + 1 < 301 && n - j - k > 0) dpbuf[j][k + 1] += dp[j][k] * (n - j - k);\n\t\t\t}\n\t\t}\n\t\tdp = dpbuf;\n\t}\n\tcout << dp[n][0] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "\n//#define USEPB_DS\n#define USETR1\n#define CPPELEVEN\n#define GPP\n\n/*\n * temp.cpp\n *\n *  Created on: 2012-7-18\n *      Author: BSBandme\n */\n//#pragma comment(linker, \"/STACK:1024000000,1024000000\")\n\n#include <iostream>\n#include <fstream>\n#include <string.h>\n#include <cstdio>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <queue>\n#include <cassert>\n#include <list>\n#include <iomanip>\n#include <math.h>\n#include <deque>\n#include <utility>\n#include <map>\n#include <set>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cctype>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <functional>\n#include <sstream>\n#include <tuple>\n\nusing namespace std;\n\n#ifndef CPPELEVEN\n#ifdef USETR1\n#include <tr1/unordered_map>\n#include <tr1/unordered_set>\nusing namespace tr1;\n#endif\n#else\n#include <unordered_map>\n#include <unordered_set>\n#endif\n\n#ifdef USEPB_DS\n#include <ext/pb_ds/priority_queue.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\nusing namespace __gnu_pbds;\n// binomial_heap_tag, rc_binomial_heap_tag, thin_heap_tag, binary_heap_tag\ntypedef __gnu_pbds::priority_queue<int, greater<int>, pairing_heap_tag> pq_type;\n// splay_tree_tag, ov_tree_tag\ntypedef tree <int, null_type, less <int>, rb_tree_tag, tree_order_statistics_node_update> tree_type;\n#endif\n\n#define mpr make_pair\ntypedef unsigned int ui;\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\ntypedef pair <double, double> pdd;\ntypedef vector <int> vi;\ntypedef vector <ll> vll;\ntypedef vector <double> vd;\ntypedef vector <string> vs;\ntypedef map <string, int> mpsi;\ntypedef map <double, int> mpdi;\ntypedef map <int, int> mpii;\n\nconst double pi = acos(0.0) * 2.0;\nconst long double eps = 1e-10;\nconst int step[8][2] = {{-1, 0}, {0, 1}, {1, 0}, {0, -1}, {-1, 1}, {1, 1}, {1, -1}, {-1, -1}};\n\ntemplate <class T> inline T abs1(T a) {return a < 0 ? -a : a;}\n\n#ifndef CPPELEVEN\ntemplate <class T> inline T max1(T a, T b) { return b < a ? a : b; }\ntemplate <class T> inline T max1(T a, T b, T c) { return max1(max1(a, b), c); }\ntemplate <class T> inline T max1(T a, T b, T c, T d) { return max1(max1(a, b, c), d); }\ntemplate <class T> inline T max1(T a, T b, T c, T d, T e) { return max1(max1(a, b, c, d), e); }\ntemplate <class T> inline T min1(T a, T b) { return a < b ? a : b; }\ntemplate <class T> inline T min1(T a, T b, T c) { return min1(min1(a, b), c); }\ntemplate <class T> inline T min1(T a, T b, T c, T d) { return min1(min1(a, b, c), d); }\ntemplate <class T> inline T min1(T a, T b, T c, T d, T e) { return min1(min1(a, b, c, d), e); }\n#else\ntemplate <typename t, typename t1>\nt min1(t a, t1 b) { return a < b ? a : b; }\ntemplate <typename t, typename... arg>\nt min1(t a, arg... arr) { return min1(a, min1(arr...)); }\ntemplate <typename t, typename t1>\nt max1(t a, t1 b) { return a > b ? a : b; }\ntemplate <typename t, typename... arg>\nt max1(t a, arg... arr) { return max1(a, max1(arr...)); }\n#endif\n\ninline int jud(double a, double b){\n\tif(abs(a) < eps && abs(b) < eps) return 0;\n\telse if(abs1(a - b) / max(abs1(a), abs1(b)) < eps) return 0;\n\tif(a < b) return -1;\n\treturn 1;\n}\ntemplate <typename t> inline int jud(t a, t b){\n\tif(a < b) return -1;\n\tif(a == b) return 0;\n\treturn 1;\n}\n\n// f_lb == 1代表返回相同的一串的左边界，f_small == 1代表返回如果没有寻找的值返回小的数\ntemplate <typename it, typename t1>\ninline int find(t1 val, it a, int na, bool f_small = 1, bool f_lb = 1){\n\tif(na == 0) return 0;\n\tint be = 0, en = na - 1;\n\tif(*a <= *(a + na - 1)){\n\t\tif(f_lb == 0) while(be < en){\n\t\t\tint mid = (be + en + 1) / 2;\n\t\t\tif(jud(*(a + mid), val) != 1) be = mid;\n\t\t\telse en = mid - 1;\n\t\t}else while(be < en){\n\t\t\tint mid = (be + en) / 2;\n\t\t\tif(jud(*(a + mid), val) != -1) en = mid;\n\t\t\telse be = mid + 1;\n\t\t}\n\t\tif(f_small && jud(*(a + be), val) == 1) be--;\n\t\tif(!f_small && jud(*(a + be), val) == -1) be++;\n\t} else {\n\t\tif(f_lb) while(be < en){\n\t\t\tint mid = (be + en + 1) / 2;\n\t\t\tif(jud(*(a + mid), val) != -1) be = mid;\n\t\t\telse en = mid - 1;\n\t\t}else while(be < en){\n\t\t\tint mid = (be + en) / 2;\n\t\t\tif(jud(*(a + mid), val) != 1) en = mid;\n\t\t\telse be = mid + 1;\n\t\t}\n\t\tif(!f_small && jud(*(a + be), val) == -1) be--;\n\t\tif(f_small && jud(*(a + be), val) == 1) be++;\n\t}\n\treturn be;\n}\n\ntemplate <class T> inline T lowb(T num) {return num & (-num); }\n#ifdef GPP\ninline int bitnum(ui nValue) { return __builtin_popcount(nValue); }\ninline int bitnum(int nValue) { return __builtin_popcount(nValue); }\ninline int bitnum(ull nValue) { return __builtin_popcount(nValue) + __builtin_popcount(nValue >> 32); }\ninline int bitnum(ll nValue) { return __builtin_popcount(nValue) + __builtin_popcount(nValue >> 32); }\ninline int bitmaxl(ui a) { if(a == 0) return 0; return 32 - __builtin_clz(a); }\ninline int bitmaxl(int a) { if(a == 0) return 0; return 32 - __builtin_clz(a); }\ninline int bitmaxl(ull a) { int temp = a >> 32; if(temp) return 32 - __builtin_clz(temp) + 32; return bitmaxl(int(a)); }\ninline int bitmaxl(ll a) { int temp = a >> 32; if(temp) return 32 - __builtin_clz(temp) + 32; return bitmaxl(int(a)); }\n#else\n#endif\n\nlong long pow(long long n, long long m, long long mod = 0){\n\tif(m < 0) return 0;\n\tlong long ans = 1;\n\tlong long k = n;\n\twhile(m){\n\t\tif(m & 1) {\n\t\t\tans *= k;\n\t\t\tif(mod) ans %= mod;\n\t\t}\n\t\tk *= k;\n\t\tif(mod) k %= mod;\n\t\tm >>= 1;\n\t}\n\treturn ans;\n}\n\n#define  MOD 1000000007\ntemplate <class t1, class t2>\ninline void add(t1 &a, t2 b, int mod = -1) {\n\tif(mod == -1) mod = MOD;\n\ta += b;\n\twhile(a >= mod) a -= mod;\n\twhile(a < 0) a += mod;\n}\ntemplate <class t>\nvoid output1(t arr) {\n\tfor(int i = 0; i < (int)arr.size(); i++)\n\t\tcerr << arr[i] << ' ';\n\tcerr << endl;\n}\ntemplate <class t>\nvoid output2(t arr) {\n\tfor(int i = 0; i < (int)arr.size(); i++)\n\t\toutput1(arr[i]);\n}\n\n//....................密..........封..........线..........下..........禁..........止..........hack...............................................\n\nconst int mod = MOD;\nconst int maxn = 330;\nll dp[2][maxn][maxn];\nll sum[maxn];\nint n, m;\n\nint main() {\n\n//............................不要再忘了检查maxn大小了！！！！BSBandme你个SB！！！！...................................................\n\n\tios_base::sync_with_stdio(0);\n\t#ifdef DEBUG //......................................................................................................\n\tfreopen(\"input.txt\", \"r\", stdin);\n\t#endif //...........................................................................................................\n\n\tcin >> n >> m;\n\tint now = 0, nxt = 1;\n\tdp[now][1][1] = 1;\n\tfor(int i = 0; i < m; i++) {\n\t\tmemset(dp[nxt], 0, sizeof(dp[nxt]));\n\t\tfor(int j = 1; j <= n; j++) {\n\t\t\tfor(int k = 1; k <= j; k++) {\n\t\t\t\tadd(dp[nxt][j + 1][k], dp[now][j][k] * (n - j) % mod);\n\t\t\t\tadd(dp[nxt][j][k], dp[now][j][k] * (j - k) % mod);\n\t\t\t\tadd(dp[nxt][j][j], dp[now][j][k] * k % mod);\n\t\t\t}\n//\t\t\tmemset(sum, 0, sizeof(sum));\n//\t\t\tfor(int k = j; k >= 0; k--) {\n//\t\t\t\tsum[k] = sum[k + 1] + dp[now][j][k + 1];\n//\t\t\t\tsum[k] %= mod;\n//\t\t\t}\n//\t\t\tfor(int k = 1; k <= n; k++) {\n//\t\t\t\tadd(dp[nxt][j][k], sum[k]);\n//\t\t\t}\n\t\t}\n\t\tswap(nxt, now);\n\t}\n\tcout << dp[now][n][n] << endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <cstring>\n#include <sstream>\n#include <algorithm>\n#include <cstdlib>\n#include <map>\n#include <queue>\n#include <utility>\n#include <vector>\n#include <set>\n#include <memory.h>\n#include <iomanip>\n#include <bitset>\n#include <list>\n#include <stack>\n\nusing namespace std;\n\n#define mod 1000000007\n\nlong long int result[301][301][301] = {};\n\nint main()\n{\n\tint n, m;\n\tcin >> n >> m;\n\n\t// result[i][j][k] : 頂点1からの長さiのパスで、\n\t// パスに含まれるノード数はj個で\n\t// 頂点1と強連結しているものはk個\n\tresult[0][1][1] = 1;\n\tfor(int i = 0; i < m; i++){\n\t\tfor(int j = 0; j <= n; j++){\n\t\t\tfor(int k = 0; k <= j; k++){\n\t\t\t\tresult[i + 1][j + 1][k] += result[i][j][k] * (n - j);\n\t\t\t\tresult[i + 1][j + 1][k] = result[i + 1][j + 1][k] % mod;\n\t\t\t\tresult[i + 1][j][k] += result[i][j][k] * (j - k);\n\t\t\t\tresult[i + 1][j][k] = result[i + 1][j][k] % mod;\n\t\t\t\tresult[i + 1][j][j] += result[i][j][k] * k;\n\t\t\t\tresult[i + 1][j][j] = result[i + 1][j][j] % mod;\n\t\t\t}\n\t\t}\n\t}\n\tcout << result[m][n][n] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <functional>\n#include <algorithm>\n#include <array>\n#include <cstdio>\n#include <iterator>\n#include <cstdlib>\n#include <vector>\n#include <utility>\n#include <map>\ntemplate<typename T> struct ScanfSpecifier{};\n#define DEF(T,V) template<> struct ScanfSpecifier<T>{static constexpr const char* value = V;};\nDEF(char*,\"%s\")DEF(int,\"%d\")DEF(double,\"%lf\")DEF(float,\"%f\")DEF(char,\"%c\")DEF(const char*,\"%s\")DEF(unsigned long,\"%lu\")DEF(unsigned int, \"%u\")\n#ifdef _MSC_VER\nDEF(long long int,\"%I64d\")\n#else\nDEF(long long int,\"%lld\")\n#endif\n#undef DEF\ntemplate<typename T> int RD(T& arg){return std::scanf(ScanfSpecifier<T>::value, &arg);}\ntemplate<int S> int RD(char (&arg)[S]){return std::scanf(\"%s\", arg);}\nint RD(char* arg){return std::scanf(\"%s\", arg);}\ntemplate<> int RD<char>(char& arg){return std::scanf(\" %c\", &arg);}\ntemplate<typename T, typename... Args> int RD(T& arg1, Args&... args) {return RD(arg1) + RD(args...);}\ntemplate<typename T> T RD(){T ret; RD(ret); return ret;}\ntemplate<typename It> void RDV(It begin, It end) { while(begin != end) RD(*begin++); }\ntemplate<typename C> void RDV(C& c) {RDV(std::begin(c), std::end(c));}\ntemplate<typename T> void WT(T arg) {std::printf(ScanfSpecifier<T>::value, arg); }\ntemplate<typename T, typename U> void WT(std::pair<T, U> arg) {std::printf(\"(\"); WT(arg.first); std::printf(\", \"); WT(arg.second); std::printf(\")\");}\ntemplate<typename... Args> void WT(Args... args) { int alc = 0; int dummy[] = {((alc++? std::printf(\" \"): 0), WT(args), 0)...}; }\n\ntemplate<typename... Args> void WTL(Args... args) { WT(args...); std::printf(\"\\n\"); }\ntemplate<typename It> void WTV(It begin, It end) { int alc = 0; while(begin != end) (alc++? std::printf(\" \"): 0), WT(*begin++); }\ntemplate<typename C> void WTV(const C& c) {WTV(std::begin(c), std::end(c));}\ntemplate<typename It> void WTVL(It begin, It end) { WTV(begin, end); std::printf(\"\\n\"); }\ntemplate<typename C> void WTVL(const C& c) {WTVL(std::begin(c), std::end(c));}\n\n\n\n\ntemplate<unsigned int Z>\nstruct ZpZ\n{\n    static const unsigned int P = Z;\n    using U64 = unsigned long long int;\n    U64 value;\n    ZpZ(long long int n) {if(std::abs(n) >= P)n %= P; if(n < 0)n += P; value = n;}\n    ZpZ():value(0){}\n    ZpZ& operator+=(ZpZ p){if((value += p.value) >= P)value -= P; return *this;}\n    ZpZ& operator-=(ZpZ p){if(value >= p.value)value -= p.value; else value += P - p.value; return *this;}\n    ZpZ& operator*=(ZpZ p){value = value * p.value % P; return *this;}\n    ZpZ& operator/=(ZpZ p){value = value * p.inverse().value % P; return *this;}\n    bool operator==(ZpZ p){return value == p.value;}\n    bool operator!=(ZpZ p){return value != p.value;}\n\n#define DEF(op) ZpZ operator op(ZpZ r)const{return ZpZ(value) op##= r;}\nDEF(+)DEF(-)DEF(*)DEF(/)\n#undef DEF\n\n    explicit operator long long int()const{return value;}\n    explicit operator int()const{return value;}\n    ZpZ operator-(){return P - value;}\n    ZpZ inverse()\n    {\n        int a = value, b = P, u = 1, v = 0;\n        while(b) \n        {\n            int t = a / b;\n            std::swap(a -= t * b, b); \n            std::swap(u -= t * v, v);\n        }\n        if(u < 0) u += P;\n        return u;\n    }\n    ZpZ pow(U64 e)\n    {\n        U64 ret = 1, base = value;\n        while(e)\n        {\n            if((e & 1) && ((ret *= base) >> 32))\n                ret %= P;\n            if((base *= base) >> 32)\n                base %= P;\n            e >>= 1;\n        }\n        return ret;\n    }\n\n};\n\ntemplate<unsigned int P>\nvoid WT(ZpZ<P> arg) {WT((int)arg);}\n\n\n\n\nnamespace XX\n{   \n    template<template<typename> class Compare, typename T>\n    inline T& UP(T& x, const T& y){if(Compare<T>()(y, x)) x = y; return x;}\n    template<typename Compare, typename T>\n    inline T& UP(T& x, const T& y, Compare comp){if(comp(y, x)) x = y; return x;}\n\n    template<typename T> inline T& GT(T& x, const T& y){return UP<std::greater>(x, y);}\n    template<typename T> inline T& LS(T& x, const T& y){return UP<std::less>(x, y);}\n\n    template<typename T>\n    struct Mapper\n    {\n        int operator[](const T& v) { int& ret = table[v]; if(!ret) rtable[ret = table.size()] = v; return ret - 1; }\n        template<typename... Args> int operator()(Args... args) { return (*this)[T(args...)]; }\n        T rev(int idx){return rtable[idx + 1];}\n        std::map<T, int> table;\n        std::map<int, T> rtable;\n    };\n\n    template<typename T, int S>\n    struct ReferenceArray\n    {\n        struct It {typename std::array<T*, S>::iterator it; T& operator*(){return **it;} void operator++(){it++;} bool operator!=(const It& other){return it != other.it;} };\n        int size()const{return _ptr.size();}\n        It begin()const{return {_ptr.begin()};}\n        It end()const{return {_ptr.end()};}\n        T& operator[](int idx)const{return *_ptr[idx];}\n        mutable std::array<T*, S> _ptr;\n    };\n    template<typename T, typename... Args> \n    ReferenceArray<T, sizeof...(Args) + 1> MAKEV(T& arg1, Args&... args) {return {&arg1, &args...};}\n\n    struct Range\n    {   \n        struct It {   int num, step; int operator*(){return num;} void operator++(){num += step;} bool operator!=(const It& other){return num != other.num;} };\n        Range(int ee):b(0),e(ee){}\n        Range(int bb, int ee):b(bb), e(ee){}\n        It begin(){return {b, (b < e? 1: -1)};}\n        It end(){return {e, 0};}\n        int b, e;\n    };\n\n}\n\n\n\n\n\n//alias\n//RD[L],RDV[L],WT[L],WTV[L] for i/o\nconst int MOD = 1e9 + 7;\nusing ZZ = ZpZ<MOD>;\nZZ min(ZZ a, ZZ b){return std::min(a.value, b.value);}\nZZ max(ZZ a, ZZ b){return std::max(a.value, b.value);}\ntemplate<typename T> T& UMAX(T& x, T y){return XX::UP<std::greater>(x, y);}\ntemplate<typename T> T& UMIN(T& x, T y){return XX::UP<std::less>(x, y);}\nusing XX::UP; //(x,y) comp\nusing RG = XX::Range;\nusing XX::MAKEV;\nusing XX::Mapper;\n//template\n#include <vector>\n#include <string>\n#include <cstring>\n#include <set>\n#include <map>\n#include <cstdlib>\n#include <algorithm>\n#include <functional>\nusing namespace std;\n\nZZ dp[309][309][309];\n\nint main()\n{\n    int N, M;\n    RD(N, M);\n\n\n    dp[1][1][1] = 1;\n\n    for(int i = 1; i <= M; i++)\n        for(int j = 1; j <= N; j++)\n            for(int k = 1; k <= j; k++)\n            {\n//                WTL(i, j, k, (int)dp[i][j][k]);\n                if(j < N)\n                    dp[i + 1][j + 1][k] += dp[i][j][k];\n                dp[i + 1][j][j] += dp[i][j][k] * k;\n                dp[i + 1][j][k] += dp[i][j][k] * (j - k);\n            }\n\n    ZZ ans = dp[M + 1][N][N];\n    for(int i: RG(1, N))\n        ans *= i;\n    WTL((int)ans);\n}\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define rer(i,l,u) for(int (i)=(int)(l);(i)<=(int)(u);++(i))\n#define reu(i,l,u) for(int (i)=(int)(l);(i)<(int)(u);++(i))\nstatic const int INF = 0x3f3f3f3f; static const long long INFL = 0x3f3f3f3f3f3f3f3fLL;\ntypedef vector<int> vi; typedef pair<int, int> pii; typedef vector<pair<int, int> > vpii; typedef long long ll;\ntemplate<typename T, typename U> static void amin(T &x, U y) { if(y < x) x = y; }\ntemplate<typename T, typename U> static void amax(T &x, U y) { if(x < y) x = y; }\n\ntemplate<int MOD>\nstruct ModInt {\n\tstatic const int Mod = MOD;\n\tunsigned x;\n\tModInt() : x(0) {}\n\tModInt(signed sig) { int sigt = sig % MOD; if(sigt < 0) sigt += MOD; x = sigt; }\n\tModInt(signed long long sig) { int sigt = sig % MOD; if(sigt < 0) sigt += MOD; x = sigt; }\n\tint get() const { return (int)x; }\n\n\tModInt &operator+=(ModInt that) { if((x += that.x) >= MOD) x -= MOD; return *this; }\n\tModInt &operator-=(ModInt that) { if((x += MOD - that.x) >= MOD) x -= MOD; return *this; }\n\tModInt &operator*=(ModInt that) { x = (unsigned long long)x * that.x % MOD; return *this; }\n\n\tModInt operator+(ModInt that) const { return ModInt(*this) += that; }\n\tModInt operator-(ModInt that) const { return ModInt(*this) -= that; }\n\tModInt operator*(ModInt that) const { return ModInt(*this) *= that; }\n};\ntypedef ModInt<1000000007> mint;\n\n\nint main() {\n\tint N; int M;\n\twhile(~scanf(\"%d%d\", &N, &M)) {\n\t\tvector<vector<mint>> dp, ndp(N + 1, vector<mint>(N + 1));\n\t\tndp[1][1] = 1;\n\t\trep(k, M) {\n\t\t\tdp.swap(ndp);\n\t\t\tndp.assign(N + 1, vector<mint>(N + 1));\n\t\t\trer(i, 1, N) rer(j, 1, i) {\n\t\t\t\tmint x = dp[i][j];\n\t\t\t\tif(x.x == 0) continue;\n\t\t\t\t//行ってない場所\n\t\t\t\tif(i < N)\n\t\t\t\t\tndp[i + 1][j] += x * (N - i);\n\t\t\t\t//頂点1を含む強連結成分中\n\t\t\t\tndp[i][i] += x * j;\n\t\t\t\t//それ以外\n\t\t\t\tndp[i][j] += x * (i - j);\n\t\t\t}\n\t\t}\n\t\tmint ans = ndp[N][N];\n\t\tprintf(\"%d\\n\", ans.get());\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<iostream>\n#include<vector>\n#include<set>\n#include<map>\n#include<bitset>\n#include<cmath>\n#include<string>\n\n#define ls (t<<1)\n#define rs ((t<<1)+1)\n#define mid ((l+r)>>1)\n#define fi first\n#define se second\n#define mk make_pair\n#define pb push_back\n\n#define N 305\n#define M 200005\n#define seed 23333\n#define Mo 1000000007\n\nusing namespace std;\nint i,j,m,n,p,k;\nint f[N][N][N];\nvoid jia(int &x,int y)\n{\n\t\tx+=y; if (x>=Mo) x-=Mo;\n}\nint main()\n{\n\t\tscanf(\"%d%d\",&n,&m);\n\t\tf[0][1][0]=1;\n\t\tfor (i=0;i<m;++i)\n\t\t\tfor (j=1;j<=n;++j)\n\t\t\t\tfor (k=0;k<=i;++k)\n\t\t\t\t\tif (f[i][j][k])\n\t\t\t\t\t{\n\t\t\t\t\t\tif (j<n)\n\t\t\t\t\t\tjia(f[i+1][j+1][k+1],1ll*f[i][j][k]*(n-j)%Mo); \n\t\t\t\t\t\tjia(f[i+1][j][0],1ll*f[i][j][k]*(j-k)%Mo);\n\t\t\t\t\t\tjia(f[i+1][j][k],1ll*f[i][j][k]*k%Mo); \n\t\t\t\t\t}\n\t\tprintf(\"%d\\n\",f[m][n][0]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=(a);i<(b);++i)\ntypedef long long lint;\ntemplate< typename T > void modAdd(T& a, T b, T mod) { a = (a+b)%mod; }\n\nint N, M;\nlint dp[302][302][302];\nconst lint MOD = (lint)1e9 + 7;\n\nint main() {\n\tcin >> N >> M;\n\tmemset(dp, 0, sizeof(dp));\n\tdp[0][1][0] = 1;\n\tfor_(i,0,M) for_(c,0,N+1) for_(s,0,N) {\n\t\tif (c+s <= N) {\n\t\t\tmodAdd(dp[i+1][c+s][0], dp[i][c][s] * lint(c), MOD);\n\t\t\tmodAdd(dp[i+1][c][s], dp[i][c][s] * lint(s), MOD);\n\t\t}\n\t\tif (c+s+1 <= N) modAdd(dp[i+1][c][s+1], dp[i][c][s] * lint(N-c-s), MOD);\n\t}\n\tcout << dp[M][N][0] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <memory.h>\n#include <math.h>\n#include <assert.h>\n#include <queue>\n#include <map>\n#include <set>\n#include <string>\n#include <algorithm>\n#include <iostream>\n#include <functional>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> Pi;\n#define Fi first\n#define Se second\n#define pb(x) push_back(x)\n#define sz(x) (int)x.size()\n#define rep(i, n) for(int i=0;i<n;i++)\n#define all(x) x.begin(), x.end()\n\nconst int MOD = 1e9 + 7;\nll D[320][320][320];\nint N, M;\n\nll dfs(int a, int b, int c){\n\tif(D[a][b][c] != -1)return D[a][b][c];\n\tll &res = D[a][b][c]; res = 0;\n\tif(a == 0){\n\t\tif(b == 0 && c == N)res = 1;\n\t\telse res = 0;\n\t}\n\telse{\n\t\tif(b > 0)res = b * dfs(a-1, b-1, c);\n\t\tif(N-b-c > 0)res += (N-b-c) * dfs(a-1, b, c);\n\t\tres += c * dfs(a-1, b, N-b);\n\t\tres %= MOD;\n\t}\n\treturn res;\n}\n\nvoid solve(){\n\tscanf(\"%d%d\", &N, &M);\n\tmemset(D, -1, sizeof D);\n\tprintf(\"%lld\", dfs(M, N-1, 1));\n}\n\nint main(){\n\tint Tc = 1; //scanf(\"%d\\n\", &Tc);\n\tfor(int tc=1;tc<=Tc;tc++){\n\t\tsolve();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N (long long)(1e9 + 7)\n#define MAX 500000\nusing namespace std;\n\nlong long factorial[MAX] = {0}, finverse[MAX] = {0},\n          inverse[MAX] = {0};\n\nvoid smodfact() {\n  factorial[0] = factorial[1] = 1;\n  finverse[0] = finverse[1] = 1;\n  inverse[1] = 1;\n  for(int i = 2; i < MAX; ++i) {\n    factorial[i] = factorial[i - 1] * i % N;\n    inverse[i] = N - (inverse[N % i] * (N / i)) % N;\n    finverse[i] = finverse[i - 1] * inverse[i] % N;\n  }\n}\n\nlong long calccomb(long long n, long long k) {\n  if(n == k && n == 0) return 1;\n  if(n < 0 || k < 0 || n < k) return 0;\n  return factorial[n] * finverse[k] % N * finverse[n - k] %\n         N;\n}\n\nlong long n, m;\nlong long dp[305][305][305] = {0};\n\nlong long solve();\n\nint main() {\n  cin >> n >> m;\n  cout << solve() << endl;\n  return 0;\n}\n\nlong long solve() {\n  if(n > m) return 0;\n  smodfact();\n  dp[0][1][1] = 1;\n  for(int i = 0; i < m; ++i)\n    for(int j = 1; j <= n; ++j)\n      for(int k = 1; k <= n; ++k) {\n        dp[i + 1][j][k] += dp[i][j][k] * (j - k) % N;\n        dp[i + 1][j][k] %= N;\n        dp[i + 1][j][k] +=\n            dp[i][j - 1][k] * (n - j + 1) % N;\n        dp[i + 1][j][k] %= N;\n        dp[i + 1][j][j] += dp[i][j][k] * k % N;\n        dp[i + 1][j][j] %= N;\n      }\n  return dp[m][n][n];\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define F first\n#define S second\n#define pb push_back\n#define ld  double\n#define ll long long\n#define int long long\n\n\nusing namespace std;\n\nconst int MAXN = 333  , MOD = 1e9 + 7 , sq = 333  ;\n\nint dp[MAXN][MAXN][MAXN] ;\n\nint32_t main()\n{\n   ios::sync_with_stdio(0);cin.tie(0);\n   int n , m ;\n   cin >> n >> m ;\n   dp[n][0][0] = 1 ;\n\n   for(int k = 1 ; k <= m ;  k ++ )\n   {\n       for(int i = 1 ; i <= n ; i ++ )\n       {\n           for(int j = 0 ; i + j <= n ; j ++ )\n           {\n               dp[i][j][k] = (i*dp[i+j][0][k-1]+j*dp[i][j][k-1]+(n-i-j)*dp[i][j+1][k-1]) % MOD ;\n      //         cout<<i<<' '<<j<<' '<<k << ' '<<dp[i][j][k]<<'\\n';\n           }\n       }\n   }\n\n   cout<<dp[1][0][m] ;\n\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int mod = 1000*1000*1000+7;\n\nint N, M;\n\nint cc[302][302][302];\nint dp(int st, int c, int m) {\n    if(m == 0) return st == N;\n    int &ret = cc[st][c][m];\n    if(ret != -1) return ret;\n\n    ret = 1LL * c * dp(st, c, m - 1) % mod;\n    if(c) ret += 1LL * st * dp(st + c, 0, m - 1) % mod, ret %= mod;\n    if(c == 0) ret += 1LL * st * dp(st, c, m - 1) % mod, ret %= mod;\n    if(st + c < N) ret += 1LL * (N - st - c) * dp(st, c + 1, m - 1) % mod, ret %= mod;\n    return ret;\n}\n\nint main() {\n    cin >> N >> M;\n    memset(cc, -1, sizeof(cc));\n    cout << dp(1, 0, M);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define mod 1000000007\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define repn(i,x) for(int i=1;i<=x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\nll dp[3][2][305][305];\nint n,m;\nint main(){\n\tcin>>n>>m;\n\tdp[1][0][1][0] = 1;\n\tfor(int D=0;D<m;D++){\n\t    int day = D%2;\n\t    rep(a,3)rep(b,305)rep(c,305)dp[a][1-day][b][c]=0;\n\t\tfor(int w=1;w<=2;w++){\n\t\t\tfor(int sz=1;sz<=n;sz++){\n\t\t\t\tfor(int sz2=0;sz2<=n-sz;sz2++){\n\t\t\t\t\tif(dp[w][day][sz][sz2] == 0) continue;\n\t\t\t\t\tif(w == 1){\n\t\t\t\t\t\tdp[1][1-day][sz][sz2] = (dp[1][1-day][sz][sz2]+dp[w][day][sz][sz2]*sz%mod)%mod;\n\t\t\t\t\t\tdp[2][1-day][sz][1] = (dp[2][1-day][sz][1]+dp[w][day][sz][sz2]*(n-sz)%mod)%mod;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tdp[2][1-day][sz][sz2] = (dp[2][1-day][sz][sz2]+dp[w][day][sz][sz2]*sz2%mod)%mod;\n\t\t\t\t\t\tdp[2][1-day][sz][sz2+1] = (dp[2][1-day][sz][sz2+1]+dp[w][day][sz][sz2]*(n-sz-sz2)%mod)%mod;\n\t\t\t\t\t\tdp[1][1-day][sz+sz2][0] = (dp[1][1-day][sz+sz2][0]+dp[w][day][sz][sz2]*sz%mod)%mod;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << dp[1][m%2][n][0] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define maxn 309\nusing namespace std;\nint dp[maxn][maxn][maxn];\nconst int MOD=1e9+7;\ninline void add(int &x,int y){\n    x+=y;\n    if(x>=MOD)\n        x-=MOD;\n}\nint main(){\n    int n,m;\n    cin>>n>>m;\n    \n    dp[0][1][1]=1;\n    for(int i=0;i<m;i++){\n        for(int j=0;j<=n;j++){\n            for(int k=0;k<=j;k++){\n                if(dp[i][j][k]){\n                    add(dp[i+1][j+1][k],1LL*dp[i][j][k]*(n-j)%MOD);\n                    add(dp[i+1][j][k],1LL*dp[i][j][k]*(j-k)%MOD);\n                    add(dp[i+1][j][j],1LL*dp[i][j][k]*k%MOD);\n                }\n            }\n        }\n    }\n    cout<<dp[m][n][n]<<endl;\n    //system(\"pause\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <set>\n#include <vector>\n#include <cstring>\n\nusing namespace std;\n\ntypedef long long ll;\nconst ll mod = 1e9+7;\nll dp[333][333][333];\n\nll pl(ll a, ll b) {\n  return (a+b)%mod;\n}\nll ml(ll a, ll b) {\n  return (a*b)%mod;\n}\n\nint main(void) {\n  int n, m;\n  scanf(\"%d%d\", &n, &m);\n  dp[0][1][0] = 1;\n  for (int i = 0; i < m; i++) {\n    for (int j = 1; j <= n; j++) {\n      //*\n      // 強連結な頂点から強連結な頂点へ\n      dp[i+1][j][0] = pl(dp[i+1][j][0], ml(dp[i][j][0], j));\n      // 強連結な頂点から強連結でない頂点へ\n      dp[i+1][j][1] = pl(dp[i+1][j][1], ml(dp[i][j][0], n-j));\n      //*/\n      for (int k = 1; k < n; k++) {\n        // 強連結でない頂点から強連結でない頂点，新しく加える\n        if (n-j-k >= 0) {\n          dp[i+1][j][k+1] = pl(dp[i+1][j][k+1], ml(dp[i][j][k], n-j-k));\n        }\n        // 強連結でない頂点から強連結でない頂点へ\n        dp[i+1][j][k] = pl(dp[i+1][j][k], ml(dp[i][j][k], k));\n        // 強連結でない頂点から強連結な頂点へ\n        if (j+k <= n) {\n          dp[i+1][j+k][0] = pl(dp[i+1][j+k][0], ml(dp[i][j][k], j));\n        }\n      }\n    }\n  }\n  ll res = 0;\n  for (int i = 0; i < n; i++) {\n    // printf(\"%lld\\n\", dp[m][n][i]);\n    res = pl(res, dp[m][n][i]);\n  }\n  printf(\"%lld\\n\", res);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define sz(x) ((int) (x).size())\n#define forn(i,n) for (int i = 0; i < int(n); ++i)\ntypedef long long ll;\ntypedef long long i64;\ntypedef long double ld;\nconst int inf = int(1e9) + int(1e5);\nconst ll infl = ll(2e18) + ll(1e10);\n\nconst int mod = 1e9 + 7;\n\nvoid udd(int &a, int b) {\n    a += b;\n    if (a >= mod)\n        a -= mod;\n}\n\nint mul(ll a, ll b) {\n    return (a * b) % mod;\n}\n\nconst int maxn = 305;\nint d[maxn][maxn][maxn];\n\nvoid calc(int n, int m) {\n    d[0][1][0] = 1;\n    forn (i, m) {\n        forn (j, n + 1)\n            forn (k, n + 1) {\n                if (d[i][j][k] == 0)\n                    continue;\n                udd(d[i + 1][j][k], mul(k, d[i][j][k]));\n                udd(d[i + 1][j][k + 1], mul(n - j - k, d[i][j][k]));\n                udd(d[i + 1][j + k][0], mul(j, d[i][j][k]));\n            }\n    }\n}\n\nint main() {\n    #ifdef LOCAL\n    assert(freopen(\"f.in\", \"r\", stdin));\n    #else\n    #endif\n    int n, m;\n    cin >> n >> m;\n    calc(n, m);\n    cout << d[m][n][0] << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n#define pb push_back\n#define ins insert\n#define pii pair<int,int>\n#define fs first\n#define sc second\n#define mpr make_pair\n#define iter iterator\n#define all(X) X.begin(),X.end()\n#define sau(X) sort(all(X)),X.resize(unique(all(X))-X.begin())\n#define exist(X,ele) binary_search(all(X),ele)\n#define y0 I_love_Ryougi_Shiki_0\n#define y1 I_love_Ryougi_Shiki_1\n\ntemplate<typename T1,typename T2>\nostream& operator << (ostream& out,const pair<T1,T2>& X)\n{\n\tout<<\"{\"<<X.fs<<\",\"<<X.sc<<\"}\";\n\treturn out;\n}\n\ntemplate<typename T>\nostream& operator << (ostream& out,const vector<T>& X)\n{\n\tfor(auto i:X) out<<i<<\" \";\n\treturn out;\n}\n\ntemplate<typename T>\ninline void cmin(T& x,T y)\n{\n\tif(!(x<y)) x=y;\n}\n\ntemplate<typename T>\ninline void cmax(T& x,T y)\n{\n\tif(x<y) x=y;\n}\n\nconst int inf=5000000000000000ll;\nconst int mod=1000000007;\n\nint dp[310][210][210]; // i edges | j points in total | k points can reach 1\n\nmain()\n{\n\tios::sync_with_stdio(false);\n\t\n\tint N,M; cin>>N>>M;\n\tif(N>M)\n\t{\n\t\tcout<<\"0\"<<endl;\n\t\treturn 0;\n\t}\n\tdp[0][1][1]=1;\n\tfor(int i=0;i<M;i++)\n\t{\n\t\tfor(int j=1;j<=N;j++)\n\t\t{\n\t\t\tfor(int k=1;k<=j;k++)\n\t\t\t{\n\t\t\t\tif(dp[i][j][k]==0) continue;\n\t\t\t\tif(j<N) dp[i+1][j+1][k]+=dp[i][j][k]*(N-j),dp[i+1][j+1][k]%=mod; // nxt=white->grey\n\t\t\t\tdp[i+1][j][k]+=dp[i][j][k]*(j-k),dp[i+1][j][k]%=mod; // nxt=grey\n\t\t\t\tdp[i+1][j][j]+=dp[i][j][k]*k,dp[i+1][j][j]%=mod; // nxt=black all grey->black\n\t\t\t}\n\t\t}\n\t}\n\tcout<<dp[M][N][N]<<endl;\n\t\n\treturn 0;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long;\ntemplate<class T = int> using V = vector<T>;\ntemplate<class T = int> using VV = V< V<T> >;\n\ntemplate<unsigned P> struct ModInt {\n  using M = ModInt;\n  unsigned v;\n  ModInt() : v(0) {}\n  ModInt(auto x) : v(x >= 0 ? x % P : (P - -x % P) % P) {}\n  constexpr ModInt(unsigned v, int) : v(v) {}\n  static constexpr unsigned p() { return P; }\n  M operator+() const { return *this; }\n  M operator-() const { return {v ? P - v : 0, 0}; }\n  explicit operator bool() const noexcept { return v; }\n  bool operator!() const noexcept { return !(bool) *this; }\n  M operator*(M r) const { return M(*this) *= r; }\n  M operator/(M r) const { return M(*this) /= r; }\n  M operator+(M r) const { return M(*this) += r; }\n  M operator-(M r) const { return M(*this) -= r; }\n  bool operator==(M r) const { return v == r.v; }\n  bool operator!=(M r) const { return !(*this == r); }\n  M& operator*=(M r) { v = (uint64_t) v * r.v % P; return *this; }\n  M& operator/=(M r) { return *this *= r.inv(); }\n  M& operator+=(M r) { if ((v += r.v) >= P) v -= P; return *this; }\n  M& operator-=(M r) { if ((v += P - r.v) >= P) v -= P; return *this; }\n  M inv() const {\n    int a = v, b = P, x = 1, u = 0;\n    while (b) {\n      int q = a / b;\n      swap(a -= q * b, b);\n      swap(x -= q * u, u);\n    }\n    assert(a == 1);\n    return x;\n  }\n  M pow(auto n) const {\n    if (n < 0) return pow(-n).inv();\n    M res = 1;\n    for (M a = *this; n; a *= a, n >>= 1) if (n & 1) res *= a;\n    return res;\n  }\n  friend M operator*(auto l, M r) { return M(l) *= r; }\n  friend M operator/(auto l, M r) { return M(l) /= r; }\n  friend M operator+(auto l, M r) { return M(l) += r; }\n  friend M operator-(auto l, M r) { return M(l) -= r; }\n  friend ostream& operator<<(ostream& os, M r) { return os << r.v; }\n  friend istream& operator>>(istream& is, M& r) { lint x; is >> x; r = x; return is; }\n  friend bool operator==(auto l, M r) { return M(l) == r; }\n  friend bool operator!=(auto l, M r) { return !(l == r); }\n};\nusing Mint = ModInt<(unsigned) 1e9 + 7>;\n\nint main() {\n  cin.tie(nullptr); ios::sync_with_stdio(false);\n  int n, m; cin >> n >> m;\n  VV<Mint> dp(n, V<Mint>(n + 1));\n  dp[n - 1][1] = 1;\n  for (int i = 0; i < m; ++i) {\n    VV<Mint> ndp(n, V<Mint>(n + 1));\n    for (int x = 0; x < n; ++x) for (int y = 1; y <= n; ++y) {\n      ndp[x][n - x] += dp[x][y] * y;\n      ndp[x][y] += dp[x][y] * (n - x - y);\n      if (x) ndp[x - 1][y] += dp[x][y] * x;\n    }\n    swap(dp, ndp);\n  }\n  cout << dp[0][n] << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint d[333][333][333],n,m;\n#define mod 1000000007\nint add(int x,int y){\n\treturn (x+=y)<mod?x:x-mod;\n}\nint mul(int x,int y){\n\treturn (int)((long long int)x*y%mod);\n}\nvoid addto(int&x,int y){\n\tx = add(x,y);\n}\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\td[0][1][0] = 1;\n\tfor(int i=0; i<m; i++)\n\tfor(int j=1; j<=i+1 && j<=n; j++)\n\tfor(int k=0; j+k<=n; k++){\n\t\tif(d[i][j][k]==0)continue;\n\t\taddto(d[i+1][j+k][0],mul(d[i][j][k],j));\n\t\taddto(d[i+1][j][k],mul(d[i][j][k],k));\n\t\tif(j+k<n)\n\t\taddto(d[i+1][j][k+1],mul(d[i][j][k],n-j-k));\n\t}\n\tprintf(\"%d\\n\",d[m][n][0]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n*/\n\n#define _CRT_SECURE_NO_WARNINGS\n\n#include <fstream>\n#include <iostream>\n#include <string>\n#include <complex>\n#include <math.h>\n#include <set>\n#include <vector>\n#include <map>\n#include <queue>\n#include <stdio.h>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <ctime>\n\n#include <memory.h>\n#include <assert.h>\n\n#define y0 sdkfaslhagaklsldk\n\n#define y1 aasdfasdfasdf\n#define yn askfhwqriuperikldjk\n#define j1 assdgsdgasghsf\n#define tm sdfjahlfasfh\n#define lr asgasgash\n#define norm asdfasdgasdgsd\n#define have adsgagshdshfhds\n\n#define eps 1e-6\n#define M_PI 3.141592653589793\n#define bs 1000000007\n#define bsize 337\n\nusing namespace std;\n\nconst int INF = 1e9;\nconst int N = 201231;\n\nint n, m;\nlong long dp[305][305][305];\nint ans;\nvector<int> g[500];\nint used[500];\n\nvoid dfs(int v)\n{\n\tused[v] = 1;\n\tfor (int i = 0; i < g[v].size(); i++)\n\t{\n\t\tint to = g[v][i];\n\t\tif (used[to])\n\t\t\tcontinue;\n\t\tdfs(to);\n\t}\n}\n\nbool valid(int v)\n{\n\tfor (int i = 1; i <= n; i++)\n\t\tused[i] = 0;\n\tdfs(v);\n\treturn (used[1] == 1);\n}\n\nbool check()\n{\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tif (!valid(i))\n\t\t\treturn false;\n\t}\n\treturn true;\n}\n\nvector<int> path;\n\nvoid generate(int dep,int cur)\n{\n\tif (dep == m)\n\t{\n\t\tif (check())\n\t\t{\n\t\t\t++ans;\n\t\t\t/*for (int i = 0; i < path.size(); i++)\n\t\t\t{\n\t\t\t\tcout << path[i] << \" \";\n\t\t\t}\n\t\t\tcout << endl;*/\n\t\t}\n\t\treturn;\n\t}\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tg[cur].push_back(i);\n\t\tpath.push_back(i);\n\t\tgenerate(dep + 1, i);\n\t\tg[cur].pop_back();\n\t\tpath.pop_back();\n\t}\n}\n\nint brute(int m, int n)\n{\n\tans = 0;\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tg[i].clear();\n\t}\n\tpath.push_back(1);\n\tgenerate(0,1);\n\tpath.pop_back();\n\treturn ans;\n}\n\nint main(){\n\t//freopen(\"fabro.in\",\"r\",stdin);\n\t//freopen(\"fabro.out\",\"w\",stdout);\n\t//freopen(\"F:/input.txt\", \"r\", stdin);\n\t//freopen(\"F:/output.txt\", \"w\", stdout);\n\tios_base::sync_with_stdio(0);\n\t//cin.tie(0);\n\n\tcin >> n >> m;\n\n\tdp[0][1][0] = 1;\n\tfor (int i = 0; i <m; i++)\n\t{\n\t\tfor (int j = 1; j <= n; j++)\n\t\t{\n\t\t\tfor (int q = 0; q <= n; q++)\n\t\t\t{\n\t\t\t//\tcout << i << \" \" << j << \" \" << q << \" \" << dp[i][j][q] << endl;\n\n\t\t\t\tdp[i + 1][j][q + 1] += dp[i][j][q] * (n - j - q) % bs;// new vertex\n\t\t\t\tdp[i + 1][j + q][0]+=dp[i][j][q] * j%bs;\n\t\t\t\tdp[i + 1][j][q] += dp[i][j][q] * q%bs;\n\t\t\t\tdp[i + 1][j][q + 1] %= bs;\n\t\t\t\tdp[i + 1][j + q][0] %= bs;\n\t\t\t\tdp[i+1][j][q + 1] %= bs;\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << dp[m][n][0] << endl;\n\n//\tcout << brute(m, n) << endl;\n\n\tcin.get(); cin.get();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma target(\"avx\")\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<ll, ll> P;\ntypedef vector<ll> V;\ntypedef unordered_map<ll, ll> U_MAP;\ntypedef priority_queue<ll> pq;\ntypedef priority_queue<ll, vector<ll>, greater<ll>> rpq;\nconstexpr ll INF = 1e9, MOD = 1e9 + 7, ohara = 1e6 + 10;\nconstexpr ll LINF = 1e18;\n\n#define rep(i, n) for (ll(i) = 0; (i) < (int)(n); (i)++)\n#define rrep(i, a, b) for (ll i = (a); i < (b); i++)\n#define rrrep(i, a, b) for (ll i = (a); i >= (b); i--)\n#define all(v) (v).begin(), (v).end()\n#define Size(n) (n).size()\n#define Cout(x) cout << (x) << endl\n#define doublecout(a) cout << fixed << setprecision(15) << a << endl;\n#define fi first\n#define se second\n#define m_p make_pair\n#define p_b push_back\nstring to_string(string s) { return '\"' + s + '\"'; }\nstring to_string(const char* s) { return to_string((string)s); }\nstring to_string(bool b) { return (b ? \"true\" : \"false\"); }\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p) {\n  return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\";\n}\ntemplate <typename A>\nstring to_string(A v) {\n  bool first = true;\n  string res = \"{\";\n  for (const auto& x : v) {\n    if (!first) {\n      res += \", \";\n    }\n    first = false;\n    res += to_string(x);\n  }\n  res += \"}\";\n  return res;\n}\nvoid debug_out() { cerr << endl; }\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << \" \" << to_string(H);\n  debug_out(T...);\n}\n#define debug(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n\n//------ Believe yourself as a genius!!!!!! ------\n\nint dy[] = {1, 0, -1, 0};\nint dx[] = {0, 1, 0, -1};\n// int dy[]={-1,0,1,-1,1,-1,0,1};int dx[]={-1,-1,-1,0,0,1,1,1};\nstring alph(\"abcdefghijklmnopqrstuvwxyz\"), s;\nll n, cnt, ans, a, b, c, d, tmp, m, h, w, x, y, sum, k, q;\nll dp[301][301][301];\n\nint main(void) {\n  cin.tie(0);\n  cout.tie(0);\n  ios::sync_with_stdio(false);\n\n  cin >> n >> m;\n  dp[0][1][1] = 1;\n  rrep(i, 1, m + 1) {\n    rrep(j, 1, n + 1) {\n      rrep(k, 1, n + 1) {\n        (dp[i][j][k] += dp[i - 1][j - 1][k] * (n - j + 1)) %= MOD;\n        if (j - k >= 0) (dp[i][j][k] += dp[i - 1][j][k] * (j - k)) %= MOD;\n        (dp[i][j][j] += dp[i - 1][j][k] * k) %= MOD;\n      }\n    }\n  }\n  ans = dp[m][n][n];\n  Cout(ans);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long MOD = 1000000007;\nlong long dp[2][301][301] = {};\n\nvoid add(long long &a, long long b) {\n    a = (a + b) % MOD;\n}\n\nint main() {\n    int N, M;\n    cin >> N >> M;\n\n    dp[0][1][1] = 1;\n    for(int n=0; n<M; ++n) {\n        for(int x=0; x<=N; ++x) \n            for(int y=0; y<=N; ++y) dp[(n+1)&1][x][y] = 0;\n\n        for(int x=1; x<=N; ++x) {\n            for(int y=1; y<=N; ++y) {\n                if(x < N) add(dp[(n + 1)&1][x + 1][y], dp[n&1][x][y] * (N - x));\n                add(dp[(n + 1)&1][x][y], dp[n&1][x][y] * (x - y));\n                add(dp[(n + 1)&1][x][x], dp[n&1][x][y] * y);\n            }\n        }\n    }\n    cout << dp[M&1][N][N] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define each(itr,c) for(__typeof(c.begin()) itr=c.begin(); itr!=c.end(); ++itr)\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n\nconst ll mod=1e9+7;\n\nconst int N=300;\n// i日目,訪れた頂点数j,町1と強連結成分をなす町の個数k\nll dp[N+1][N+1][N+1]={0};\n\nint main()\n{\n    int n,m;\n    cin >>n >>m;\n\n    dp[0][1][1]=1;\n    rep(i,m)for(int j=1; j<=N; ++j)for(int k=1; k<=j; ++k)\n    {\n        // 町1との強連結成分内の町に行く\n        (dp[i+1][j][j]+=dp[i][j][k]*k)%=mod;\n        // 町1との強連結成分外の訪問済みの町に行く\n        (dp[i+1][j][k]+=dp[i][j][k]*(j-k))%=mod;\n        // 未訪問の町に行く\n        if(j<N) (dp[i+1][j+1][k]+=dp[i][j][k]*(n-j))%=mod;\n    }\n\n    cout << dp[m][n][n] << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntemplate<typename T> using Graph = vector<vector<T>>;\n\n#define REP(i, a, b) for (int i = (int)(a); i < (int)(b); i++)\n#define rep(i, a) REP(i, 0, a)\n#define EACH(i, a) for (auto i: a)\n#define ITR(x, a) for (__typeof(a.begin()) x = a.begin(); x != a.end(); x++)\n#define ALL(a) (a.begin()), (a.end())\n#define HAS(a, x) (a.find(x) != a.end())\n#define endl '\\n'\n\nll mod = 1e9 + 7;\nint N, M;\n\nll solve() {\n    ll ans = 1;\n    ll bns = 0;\n    if (N > M) return 0;\n\n    REP(i, 1, N) ans = ans*i%mod; \n    REP(i, N, M) {\n        ll cns = (N - 1)*ans + N*bns + i*(N - 2)*ans + i*ans;\n        bns = ans%mod;\n        ans = cns%mod;\n    }\n    return ans;\n}\n\nint main(void) {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  cin >> N >> M;\n\n  cout << solve() << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define fbo find_by_order\n#define ook order_of_key\n\ntypedef long long ll;\ntypedef pair<ll,ll> ii;\ntypedef vector<int> vi;\ntypedef long double ld; \ntypedef tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> pbds;\ntypedef set<int>::iterator sit;\ntypedef map<int,int>::iterator mit;\ntypedef vector<int>::iterator vit;\n\nconst int MOD = 1e9 + 7;\nint dp[301][301];\nint g[301][301];\nint c[301][301];\n\nvoid add(int &a, int b)\n{\n\ta=(a+b)%MOD;\n}\n\nint mult(int a, int b)\n{\n\treturn (a*1LL*b)%MOD;\n}\n\nint choose(int n, int r)\n{\n\tif(n < r) return 0;\n\tif(n==r) return 1;\n\tif(r==0) return 1;\n\tif(c[n][r]!=-1) return c[n][r];\n\tc[n][r] = (choose(n-1,r)+choose(n-1,r-1))%MOD;\n\treturn c[n][r];\n}\n\nint ans[25][25]={{174590825,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{630592107,187067364,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{317595576,491671885,817659471,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{324480512,92444956,994114427,309331349,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{612364202,116802899,655929952,661368963,303445769,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{606638382,944627578,727280267,991537326,148123070,964814732,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{563336210,369607651,290127485,889172436,936492713,735520178,112937795,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{165984396,799015248,486912799,521117486,624390497,322031184,265146713,848457973,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{287295458,339770185,962093194,762363875,729077145,140976536,460722256,150123933,113604679,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{384095459,55760009,715981525,481478020,252873333,808236679,963601439,953207486,898925290,263728612,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{736912749,619989847,900318537,355190782,500947559,271172016,808142456,419271751,104668525,356359753,162653895,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{841336699,650390144,965212201,643981400,184324286,794130820,99248535,871118495,716429799,694600601,437902292,519013648,0,0,0,0,0,0,0,0,0,0,0,0,0},{915460741,116425131,263167234,852499824,932629769,291439485,352018860,991837283,903680319,282542980,96363218,634872862,956915940,0,0,0,0,0,0,0,0,0,0,0,0},{200447810,866843803,336257064,816399216,869688615,425493111,68784436,705073103,437292234,506005380,526155553,258162808,435171770,591788795,0,0,0,0,0,0,0,0,0,0,0},{168847690,822322199,990442845,965338085,758690839,219673342,559006232,117800826,977005274,732970604,56916417,259299217,403931348,791601213,26960558,0,0,0,0,0,0,0,0,0,0},{53694932,565474974,632731496,87433237,40749860,777187417,472922764,408655822,75935427,148132450,252492149,628149298,761221221,504194651,382911931,818561771,0,0,0,0,0,0,0,0,0},{333718454,433775776,392284604,586425273,133800537,118842784,237933901,742149287,14020917,712607117,309090797,513404204,944802463,911902547,676293805,628844839,201473695,0,0,0,0,0,0,0,0},{671190979,411157756,221752076,506736399,253244307,211618808,355592370,865448446,870704796,235043072,504228932,782675809,846912453,885068228,449255191,886593260,453010234,830318534,0,0,0,0,0,0,0},{472043415,560217649,890513263,983927030,429872845,352453370,652170639,116002887,746783651,595373235,480035844,30310993,29092107,943012501,813190598,2845321,620711807,15326392,283328761,0,0,0,0,0,0},{722770244,733283236,843562963,828996090,322003279,62468645,844308987,112588368,567020965,347587121,455670496,729890099,90455001,727161841,591706943,491333391,482810700,478017614,804614373,298655153,0,0,0,0,0},{265464467,846469384,809126640,193953925,272811087,196193135,295333441,658337820,664873884,830781062,571633371,457793337,519111943,170258576,704187233,493211829,358250091,292789599,281803950,464507895,103269519,0,0,0,0},{265130055,785589421,861464691,194965928,48038786,58370502,701227955,454591773,279659919,545523305,101074712,175351818,659551630,105883439,943223593,866999396,493874374,243076971,665031202,803322783,62113368,567777414,0,0,0},{707826504,983129028,468792681,873334323,613021790,388256934,805163219,732021698,395119496,944922719,60104912,457147310,827854937,21728025,932652273,578302941,326556120,27487804,422490643,992667534,749959766,77560945,629890782,0,0},{81161051,68074540,921370941,413896636,669494525,442956804,282722258,841893368,898248894,801147845,623662065,127982157,191537128,71712684,302889271,58094980,76023842,234024116,629507376,745775252,120279925,513159340,820613176,707451727,0},{292889442,483336561,601883495,364319970,376194737,414129045,744286295,621511302,53122839,553736497,660821287,591290851,82748073,383280748,142913151,812763976,862935195,321050299,540099358,111174191,553155194,725252985,394734880,891402805,528064896}};\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tmemset(c,-1,sizeof(c));\n\tint n, m; cin>>n>>m;\n\t\n\tif(n>=276&&m>=276)\n\t{\n\t\tcout<<ans[m-276][n-276]<<'\\n';\n\t\treturn 0;\n\t}\n\t\n\tg[0][0] = 1;\n\tg[1][1] = 1;\n\tfor(int i = 2; i <= m; i++) g[i][1] = 1;\n\tfor(int j = 2; j <= n; j++)\n\t{\n\t\tfor(int i = j; i <= m; i++)\n\t\t{\n\t\t\tfor(int k = 1; k + j - 1 <= i; k++)\n\t\t\t{\n\t\t\t\tadd(g[i][j], mult(g[i-k][j-1], choose(i, k)));\n\t\t\t}\n\t\t}\n\t}\n\t//cerr<<g[10][3]<<'\\n';\n\tdp[0][1] = 1;\n\tfor(int i = 0; i < m; i++)\n\t{\n\t\tfor(int j = 1; j <= min(i+1,n); j++)\n\t\t{\n\t\t\tint val = dp[i][j];\n\t\t\tfor(int l = 1; l <= m - i; l++)\n\t\t\t{\n\t\t\t\tfor(int k = 0; k <= min(l - 1, n - j); k++)\n\t\t\t\t{\n\t\t\t\t\tadd(dp[i+l][j+k], mult(val, mult(choose(n-j,k),mult(g[l-1][k], j))));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << dp[m][n] << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#ifdef DEMETRIO\n#define deb(...) fprintf(stderr,__VA_ARGS__)\n#define deb1(x) cerr << #x << \" = \" << x << endl\n#else\n#define deb(...) 0\n#define deb1(x) 0\n#endif\n#define pb push_back\n#define mp make_pair\n#define fst first\n#define snd second\n#define fore(i,a,b) for(int i=a,ThxDem=b;i<ThxDem;++i)\n#define SZ(x) ((int)x.size())\n#define MOD 1000000007\nusing namespace std;\ntypedef long long ll;\n\nint n,m;\nint dp[302][302][302];\n\nint f(int m, int k, int b){\n\tif(dp[m][k][b]>=0)return dp[m][k][b];\n\tint r=0;\n\tif(m==0)r=!k&&!b;\n\telse {\n\t\tr=(1LL*(n-k)*f(m-1,k-b,0))%MOD;\n\t\tr+=(1LL*b*f(m-1,k,b))%MOD;r%=MOD;\n\t\tif(k-b){r+=(1LL*(k-b)*f(m-1,k,b+1))%MOD;r%=MOD;}\n\t}\n\treturn dp[m][k][b]=r;\n}\n\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tmemset(dp,-1,sizeof(dp));\n\tprintf(\"%d\\n\",f(m,n-1,0));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\ntypedef long long ll;\n\nll N, M;\nll MOD = 1000000007;\nll dp[300 + 10][300 + 10][300 + 10];\n//dp[i][j][k] := i回目の移動(1-idx)を終えて、まだ連結されてない町がj個あり、k個の長さから成る最初の連結成分を持つ場合の数\n\nint main() {\n\n\tcin >> N >> M;\n\t\n\tdp[0][N - 1][1] = 1;\n\tfor (int i = 0; i < M; i++) {\n\t\tfor (int j = 0; j <= N; j++) {\n\t\t\tfor (int k = 1; k <= N; k++) {\n\t\t\t\tif (j - 1 >= 0 && k + 1 <= N) {\n\t\t\t\t\tdp[i + 1][j - 1][k + 1] += (dp[i][j][k] * j % MOD);\n\t\t\t\t\tdp[i + 1][j - 1][k + 1] %= MOD;\n\t\t\t\t}\n\t\t\t\tif (N - j - k >= 0) {\n\t\t\t\t\tdp[i + 1][j][k] += dp[i][j][k] * (N - j - k) % MOD;\n\t\t\t\t\tdp[i + 1][j][k] %= MOD;\n\t\t\t\t}\n\t\t\t\tdp[i + 1][j][j] += (dp[i][j][k] * j % MOD);\n\t\t\t\tdp[i + 1][j][j] %= MOD;\n\t\t\t\t//特に動かない\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << dp[M - 1][0][N] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i, m, n) for(int(i) = (int)(m); i < (int)(n); ++i)\n#define rep2(i, m, n) for(int(i) = (int)(n)-1; i >= (int)(m); --i)\n#define REP(i, n) rep(i, 0, n)\n#define REP2(i, n) rep2(i, 0, n)\n#define all(hoge) (hoge).begin(), (hoge).end()\n#define en '\\n'\nusing ll = long long;\nusing ull = unsigned long long;\ntemplate <class T>\nusing vec = vector<T>;\ntemplate <class T>\nusing vvec = vector<vec<T>>;\ntypedef pair<ll, ll> P;\nconstexpr long long INF = 1LL << 60;\nconstexpr int INF_INT = 1 << 25;\nconstexpr long long MOD = (ll)1e9 + 7;\n//constexpr long long MOD = 998244353LL;\nusing ld = long double;\nstatic const ld pi = 3.141592653589793L;\ntypedef vector<ll> Array;\ntypedef vector<Array> Matrix;\n\ntemplate <class T>\ninline bool chmin(T &a, T b) {\n    if(a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate <class T>\ninline bool chmax(T &a, T b) {\n    if(a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\nstruct Edge {\n    ll to, rev;\n    long double cap;\n    Edge(ll _to, long double _cap, ll _rev) {\n        to = _to;\n        cap = _cap;\n        rev = _rev;\n    }\n};\nusing Edges = vector<Edge>;\nusing Graph = vector<Edges>;\n\nvoid add_edge(Graph &G, ll from, ll to, long double cap, bool revFlag,\n              long double revCap) {\n    G[from].push_back(Edge(to, cap, (ll)G[to].size()));\n    if(revFlag)\n        G[to].push_back(Edge(from, revCap, (ll)G[from].size() - 1));\n}\n\ntemplate <int mod>\nstruct ModInt {\n    int x;\n\n    ModInt() : x(0) {}\n\n    ModInt(int64_t y) : x(y >= 0 ? y % mod : (mod - (-y) % mod) % mod) {}\n\n    ModInt &operator+=(const ModInt &p) {\n        if((x += p.x) >= mod)\n            x -= mod;\n        return *this;\n    }\n\n    ModInt &operator-=(const ModInt &p) {\n        if((x += mod - p.x) >= mod)\n            x -= mod;\n        return *this;\n    }\n\n    ModInt &operator*=(const ModInt &p) {\n        x = (int)(1LL * x * p.x % mod);\n        return *this;\n    }\n\n    ModInt &operator/=(const ModInt &p) {\n        *this *= p.inverse();\n        return *this;\n    }\n\n    ModInt operator-() const { return ModInt(-x); }\n\n    ModInt operator+(const ModInt &p) const { return ModInt(*this) += p; }\n\n    ModInt operator-(const ModInt &p) const { return ModInt(*this) -= p; }\n\n    ModInt operator*(const ModInt &p) const { return ModInt(*this) *= p; }\n\n    ModInt operator/(const ModInt &p) const { return ModInt(*this) /= p; }\n\n    bool operator==(const ModInt &p) const { return x == p.x; }\n\n    bool operator!=(const ModInt &p) const { return x != p.x; }\n\n    ModInt inverse() const {\n        int a = x, b = mod, u = 1, v = 0, t;\n        while(b > 0) {\n            t = a / b;\n            swap(a -= t * b, b);\n            swap(u -= t * v, v);\n        }\n        return ModInt(u);\n    }\n\n    ModInt pow(int64_t n) const {\n        ModInt ret(1), mul(x);\n        while(n > 0) {\n            if(n & 1)\n                ret *= mul;\n            mul *= mul;\n            n >>= 1;\n        }\n        return ret;\n    }\n\n    friend ostream &operator<<(ostream &os, const ModInt &p) {\n        return os << p.x;\n    }\n\n    friend istream &operator>>(istream &is, ModInt &a) {\n        int64_t t;\n        is >> t;\n        a = ModInt<mod>(t);\n        return (is);\n    }\n\n    static int get_mod() { return mod; }\n};\n\nusing mint = ModInt<MOD>;\n\nmint dp[310][310][310];\nvoid solve() {\n    ll n, m;\n    cin >> n >> m;\n    dp[0][n - 1][1] = 1; //操作回数、孤立点の数、最初の連結成分のサイズ\n    REP(i, m) {\n        REP(j, n + 1) {\n            REP(k, n + 1) {\n                if(dp[i][j][k] == 0)\n                    continue;\n\n                dp[i + 1][j][n - j] += dp[i][j][k] * k;\n                dp[i + 1][j][k] += dp[i][j][k] * (n - j - k);\n                if(j > 0)\n                    dp[i + 1][j - 1][k] += dp[i][j][k] * j;\n            }\n        }\n    }\n\n    cout << dp[m][0][n] << en;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n\n    solve();\n    /*\n    ll t;\n    cin >> t;\n    REP(i, t)\n    solve();\n    */\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <stdio.h>\n#include <stdlib.h>\n#include <vector>\n#include <map>\n#include <queue>\n#include <set>\n#include <string>\n#include <string.h>\n#include <stack>\n#include <assert.h>\n#include <bitset>\n#define Endl endl\n#define mp make_pair\n#define ll long long \n#define ull unsinged long long\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define over(A) {cout<<A<<endl;exit(0);}\n#define all(A) A.begin(),A.end()\n#define ceil(a,b) ((a-1)/b+1)\n#define srand() mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n#define rand(l,r) uniform_int_distribution<int>(l,r)(rng)\ntemplate <typename T1,typename T2> inline void chmin(T1 &x,T2 b) {if(b<x) x=b;}\ntemplate <typename T1,typename T2> inline void chmax(T1 &x,T2 b) {if(b>x) x=b;}\nconst int inf=1039074182;\nconst int mod=1e9+7;\nusing namespace std;\nint dp[305][305][305];\nint n,m;\n\nnamespace combinatorics\n{\n\tint *fac;\n\tint *ifac;\n\tint __Tmod;\n\tinline int add(int a,int b)\n\t{\n\t\treturn (a+b)%__Tmod;\n\t}\n\tinline int sub(int a,int b)\n\t{\n\t\treturn (a-b+__Tmod)%__Tmod;\n\t}\n\tinline int mult(int a,int b)\n\t{\n\t\treturn (1LL*a*b)%__Tmod;\n\t}\n\tinline int fastpow(int basic,int x)\n\t{\n\t\tif(x==0) return 1;\n\t\tint res=1;\n\t\twhile(x)\n\t\t{\n\t\t\tif(x&1)\tres=mult(res,basic);\n\t\t\tbasic=mult(basic,basic);\n\t\t\tx>>=1;\n\t\t}\n\t\treturn res;\n\t}\n\tinline int inv(int x)\n\t{\n\t\treturn fastpow(x,__Tmod-2);\n\t}\n\tvoid init(int n,int tmod)\n\t{\n\t\t__Tmod=tmod;\n\t\tfac=new int[n+5];\n\t\tifac=new int[n+5];\n\t\tfac[0]=1;\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t\tfac[i]=mult(fac[i-1],i);\n\t\t}\n\t\tifac[n]=inv(fac[n]);\n\t\tfor(int i=n-1;i>=0;i--)\n\t\t{\n\t\t\tifac[i]=mult(ifac[i+1],i+1);\n\t\t}\n\t}\n\tinline int C(int n,int m)\n\t{\n\t\treturn mult(mult(fac[n],ifac[m]),ifac[n-m]);\n\t}\n\tinline int Cat(int x)\n\t{\n\t\treturn mult(C(x*2,x),inv(x+1));\n\t}\n};\nusing namespace combinatorics;\n\ntemplate <typename T1,typename T2> void upadd(T1 &a,T2 b) {a+=b;if(a>=mod) a-=mod;}\n\nint main()\n{\n//\tfreopen(\"input.txt\",\"r\",stdin);\n\tcin>>n>>m;\n\tinit(300,1e9+7);\n\tdp[0][1][1]=1;\n\tfor(int i=0;i<m;i++)\n\t{\n\t\tfor(int j=1;j<=min(i+1,n);j++)\n\t\t{\n\t\t\tfor(int k=1;k<=j;k++)\n\t\t\t{\n\t\t\t\tint now=dp[i][j][k];\n\t\t\t\tupadd(dp[i+1][j][j],mult(now,k));\n\t\t\t\tupadd(dp[i+1][j][k],mult(now,j-k));\n\t\t\t\tupadd(dp[i+1][j+1][k],mult(now,n-j));\n\t\t\t}\n\t\t}\n\t}\n\tcout<<dp[m][n][n]<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <iomanip>\n#include <climits>\n#include <limits>\n#include <algorithm>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <list>\n#include <stack>\n#include <string>\n#include <functional>\n#include <numeric>\n#include <map>\n#include <set>\n#include <cstdlib>\n#include <bitset>\n#include <unordered_map>\n#include <random>\n#include <cmath>\n#include <complex>\n\nusing namespace std;\n\ntypedef long long int ll;\ntypedef vector<int> vi;\ntypedef vector<vector<int>> vvi;\ntypedef pair<int, int> P;\ntypedef pair<ll, ll> Pll;\ntypedef vector<ll> vll;\ntypedef vector<vector<ll>> vvll;\n\nconst int INFL = (int)1e9;\nconst ll INFLL = (ll)1e18;\nconst double INFD = numeric_limits<double>::infinity();\nconst double PI = 3.14159265358979323846;\n#define Loop(i, n) for(int i = 0; i < (int)n; i++)\n#define Loopll(i, n) for(ll i = 0; i < (ll)n; i++)\n#define Loop1(i, n) for(int i = 1; i <= (int)n; i++)\n#define Loopll1(i, n) for(ll i = 1; i <= (ll)n; i++)\n#define Loopr(i, n) for(int i = (int)n - 1; i >= 0; i--)\n#define Looprll(i, n) for(ll i = (ll)n - 1; i >= 0; i--)\n#define Loopr1(i, n) for(int i = (int)n; i >= 1; i--)\n#define Looprll1(i, n) for(ll i = (ll)n; i >= 1; i--)\n#define Loopitr(itr, container) for(auto itr = container.begin(); itr != container.end(); itr++)\n#define printv(vector) Loop(i, vector.size()) { cout << vector[i] << \" \"; } cout << endl;\n#define printmx(matrix) Loop(i, matrix.size()) { Loop(j, matrix[i].size()) { cout << matrix[i][j] << \" \"; } cout << endl; }\n#define rnd(d) (ll)((double)(d) + (d >= 0 ? 0.5 : -0.5))\n#define floorsqrt(x) ((ll)sqrt((double)x) + ((ll)sqrt((double)x) * (ll)sqrt((double)x) <= (ll)(x) ? 0 : -1))\n#define ceilsqrt(x) ((ll)sqrt((double)x) + ((ll)x <= (ll)sqrt((double)x) * (ll)sqrt((double)x) ? 0 : 1))\n#define ceildiv(a, b) ((ll)(a) / (ll)(b) + ((ll)(a) % (ll)(b) == 0 ? 0 : 1))\n#define bitmanip(m,val) static_cast<bitset<(int)m>>(val)\n\n/*******************************************************/\n\nnamespace mod_op {\n\n\tconst ll MOD = (ll)1e9 + 7;\n\n\tclass Extended_Euclid {\n\tprivate:\n\t\tll m, n;\n\t\tvvll mx_multiply(vvll mx1, vvll mx2) {\n\t\t\tvvll ret(mx1.size(), vll(mx2[0].size(), 0));\n\t\t\tLoop(i, mx1.size()) {\n\t\t\t\tLoop(j, mx1[0].size()) {\n\t\t\t\t\tLoop(k, mx2[0].size()) {\n\t\t\t\t\t\tret[i][j] += mx1[i][k] * mx2[k][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\tpublic:\n\t\t// solve x, y s.t. mx + ny = gcd(m,n)\n\t\tll x, y, gcd;\n\t\tExtended_Euclid(ll M, ll N) {\n\t\t\tm = M;\n\t\t\tn = N;\n\t\t\tvll r(100), k(100);\n\t\t\tbool swapflag = false, m_negflag = false, n_negflag = false;\n\t\t\tif (m < n) { swap(m, n); swapflag = true; }\n\t\t\tif (m < 0) { m *= -1; m_negflag = true; }\n\t\t\tif (n < 0) { n *= -1; n_negflag = true; }\n\t\t\tr[0] = m;\n\t\t\tr[1] = n;\n\t\t\tint h = 1;\n\t\t\twhile (1) {\n\t\t\t\tk[h - 1] = r[h - 1] / r[h];\n\t\t\t\tr[h + 1] = r[h - 1] % r[h];\n\t\t\t\tif (r[h + 1] == 0) break;\n\t\t\t\th++;\n\t\t\t}\n\t\t\tgcd = r[h];\n\t\t\tvvll mx1 = { { 0, 1 },{ 1, (-1) * k[h - 1] } };\n\t\t\tLoopr(i, h - 1) {\n\t\t\t\tvvll mx2 = { { 0, 1 },{ 1, (-1) * k[i] } };\n\t\t\t\tmx1 = mx_multiply(mx1, mx2);\n\t\t\t}\n\t\t\tx = mx1[0][0];\n\t\t\ty = mx1[0][1];\n\t\t\tif (n_negflag) { n *= -1; y *= -1; }\n\t\t\tif (m_negflag) { m *= -1; x *= -1; }\n\t\t\tif (swapflag) { swap(m, n); swap(x, y); }\n\t\t}\n\t};\n\n\tclass modll {\n\tprivate:\n\t\tll mod;\n\t\tll val;\n\t\tinline ll modify(ll x) { ll ret = x % mod; if (ret < 0) ret += mod; return ret; }\n\t\tinline ll inv(ll x) { if (x == 0) return 1 / x; Extended_Euclid ee(x, -mod); return modify(ee.x); }\n\tpublic:\n\t\tmodll(ll init = 0, ll mod = MOD) { modll::mod = mod; val = modify(init); return; }\n\t\tmodll(const modll& another) { val = another.val; mod = another.mod; return; }\n\t\tinline modll& operator=(const modll &another) { val = another.val; return *this; }\n\t\tinline modll operator+(const modll &x) { return modify(val + x.val); }\n\t\tinline modll operator-(const modll &x) { return modify(val - x.val); }\n\t\tinline modll operator*(const modll &x) { return modify(val * x.val); }\n\t\tinline modll operator/(const modll &x) { return modify(val * inv(x.val)); }\n\t\tinline modll& operator+=(const modll &x) { val = modify(val + x.val); return *this; }\n\t\tinline modll& operator-=(const modll &x) { val = modify(val - x.val); return *this; }\n\t\tinline modll& operator*=(const modll &x) { val = modify(val * x.val); return *this; }\n\t\tinline modll& operator/=(const modll &x) { val = modify(val * inv(x.val)); return *this; }\n\t\tfriend inline istream& operator >> (istream &is, modll& x) { is >> x.val; return is; }\n\t\tfriend inline ostream& operator << (ostream &os, modll& x) { os << x.val; return os; }\n\t\tll get_val() { return val; }\n\t\tll get_mod() { return mod; }\n\t};\n\n\tmodll pow(modll n, ll p) {\n\t\tmodll ret;\n\t\tif (p == 0) ret = 1;\n\t\telse if (p == 1) ret = n;\n\t\telse {\n\t\t\tret = pow(n, p / 2);\n\t\t\tret *= ret;\n\t\t\tif (p % 2 == 1) ret *= n;\n\t\t}\n\t\treturn ret;\n\t}\n}\n\nusing namespace mod_op;\n\nint main() {\n\tint n, m; cin >> n >> m;\n\tvector<vector<modll>> dp(301, vector<modll>(301, 0));\n\tdp[1][0] = 1;\n\tLoop(i, m) {\n\t\tvector<vector<modll>> dpbuf(301, vector<modll>(301, 0));\n\t\tLoop(j, 301) {\n\t\t\tLoop(k, 301) {\n\t\t\t\tif (j + k < 301) dpbuf[j + k][0] += dp[j][k] * j;\n\t\t\t\tdpbuf[j][k] += dp[j][k] * k;\n\t\t\t\tif (k + 1 < 301 && n - j - k > 0) dpbuf[j][k + 1] += dp[j][k] * (n - j - k);\n\t\t\t}\n\t\t}\n\t\tdp = dpbuf;\n\t}\n\tcout << dp[n][0] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n#define ALL(c) (c).begin(), (c).end()\n\ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<VI> VVI;\ntypedef vector<VL> VVL;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\n\nconst ll mod = 1e9 + 7;\nll dp[311][311][311];\n\nint main(void){\n    int n, m;\n    cin >> n >> m;\n    dp[0][1][0] = 1;\n    REP(i,m) REP(j,n+1) REP(k,n+1){\n        if (j + k > n) continue;\n        dp[i+1][j][k] = (dp[i+1][j][k] + k * dp[i][j][k]) % mod;\n        dp[i+1][j+k][0] = (dp[i+1][j+k][0] + j * dp[i][j][k]) % mod;\n        dp[i+1][j][k+1] = (dp[i+1][j][k+1] + (n - k - j) * dp[i][j][k]) % mod;\n    }\n\n    // FOR(i,1,m){\n    //     cout << i << endl;\n    //     REP(j,n+1){\n    //         REP(k,n+1) cout << dp[i][j][k] << \" \";\n    //         cout << endl;\n    //     }\n    //     cout << endl;\n    // }\n    cout << dp[m][n][0] << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nlong long n, m, dp[305][305][305], mod = 1000000007;\nlong long solve(long long pos, long long rec1, long long rec2) {\n\tif (rec1 + rec2 > n)return 0;\n\tif (pos == m) {\n\t\tif (rec1 == n && rec2 == 0)return 1;\n\t\treturn 0;\n\t}\n\tif (dp[pos][rec1][rec2] >= 1)return dp[pos][rec1][rec2] - 1;\n\tlong long ret = 0;\n\tret += solve(pos + 1, rec1 + rec2, 0)*rec1;\n\tret += solve(pos + 1, rec1, rec2)*rec2;\n\tret += solve(pos + 1, rec1, rec2 + 1)*(n - rec1 - rec2); ret %= mod;\n\tdp[pos][rec1][rec2] = ret + 1;\n\treturn ret;\n}\nint main() {\n\tcin >> n >> m;\n\tcout << solve(0, 1, 0) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long MOD = 1000000007;\nlong long dp[301][301][301] = {};\n\nvoid add(long long &a, long long b) {\n    a = (a + b) % MOD;\n}\n\nint main() {\n    int N, M;\n    cin >> N >> M;\n\n    dp[0][1][1] = 1;\n    for(int n=0; n<M; ++n) {\n        for(int x=1; x<=N; ++x) {\n            for(int y=1; y<=N; ++y) {\n                add(dp[n + 1][x + 1][y], dp[n][x][y] * (N - x));\n                add(dp[n + 1][x][y], dp[n][x][y] * (x - y));\n                add(dp[n + 1][x][x], dp[n][x][y] * y);\n            }\n        }\n    }\n    cout << dp[M][N][N] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "# include <iostream>\n# include <algorithm>\n#include <array>\n# include <cassert>\n#include <cctype>\n#include <climits>\n#include <numeric>\n# include <vector>\n# include <string>\n# include <set>\n# include <map>\n# include <cmath>\n# include <iomanip>\n# include <functional>\n# include <tuple>\n# include <utility>\n# include <stack>\n# include <queue>\n# include <list>\n# include <bitset>\n# include <complex>\n# include <chrono>\n# include <random>\n# include <limits.h>\n# include <unordered_map>\n# include <unordered_set>\n# include <deque>\n# include <cstdio>\n# include <cstring>\n#include <stdio.h>\n#include<time.h>\n#include <stdlib.h>\n#include <cstdint>\n#include <cfenv>\n#include<fstream>\n//#include <bits/stdc++.h>\nusing namespace std;\nusing LL = long long;\nusing ULL = unsigned long long;\nlong long MOD = 1000000000 + 7; //924844033 1000000000 + 7;\nconstexpr long long INF = numeric_limits<LL>::max();\nconst double PI = acos(-1);\n#define fir first\n#define sec second\n#define thi third\n#define debug(x) cerr<<#x<<\": \"<<x<<'\\n'\ntypedef pair<LL, LL> Pll;\ntypedef pair<double, double> Dll;\ntypedef pair<LL, pair<LL, LL>> Ppll;\ntypedef pair<LL, pair<LL, bitset<100001>>> Pbll;\ntypedef pair<LL, pair<LL, vector<LL>>> Pvll;\ntypedef pair<LL, LL> Vec2;\nstruct Tll { LL first, second, third; };\nstruct Fll { LL first, second, third, fourth; };\ntypedef pair<LL, Tll> Ptll;\n#define rep(i,rept) for(LL i=0;i<rept;i++)\n#define Rrep(i,mf) for(LL i=mf-1;i>=0;i--)\nLL h, w, n, m, k, t, s, p, q, last, first, cnt, sum, ans, dp[310][310][310],a[200000],b[200000];\nstring str, ss;\nbool f;\nchar c;\nint di[4][2] = { { 0,1 },{ 1,0 },{ 0,-1 },{ -1,0 } };\nstruct Edge { LL to, cost; };\nstruct edge { LL from, to, cost; };\nvector<LL>vec;\nvector<edge>ed;\nvector<LL>v;\nmap<LL,LL>ma;\nset<LL>st;\nvoid YN(bool f) {\n\tif (f)\n\t\tcout << \"YES\" << endl;\n\telse\n\t\tcout << \"NO\" << endl;\n}\nvoid yn(bool f) {\n\tif (f)\n\t\tcout << \"Yes\" << endl;\n\telse\n\t\tcout << \"No\" << endl;\n}\n\nint main() {\n\tcin >> n >> m;\n\tdp[0][1][1] = 1;\n\trep(i, m) {\n\t\trep(j, n+1) {\n\t\t\trep(k, n+1) {\n\t\t\t\t(dp[i + 1][j + 1][k] += dp[i][j][k] * (n - j) % MOD) %= MOD;\n\t\t\t\t(dp[i + 1][j][j] += dp[i][j][k] * k% MOD) %= MOD;\n\t\t\t\t(dp[i + 1][j][k] += dp[i][j][k] * (j - k) % MOD) %= MOD;\n\t\t\t}\n\t\t}\n\t}\n\tcout << dp[m][n][n] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <map>\n#include <set>\n#include <cstdio>\n#include <cstring>\nusing namespace std;\n\n// modulo integer\n// M: modulo number\n// * M < 2^31\n// * M must be prime if you use division\ntemplate <int64_t M>\nclass mint {\npublic:\n        mint() :v(-1) {}\n        mint(int n) : v(n % M) {}\n\n        int64_t get() const { return v; }\n\n        mint &operator+=(const mint &r) {\n                v = (v + r.v) % M;\n                return *this;\n        }\n        mint &operator-=(const mint &r) {\n                v = (v - r.v + M) % M;\n                return *this;\n        }\n        mint &operator*=(const mint &r) {\n                v = (v * r.v) % M;\n                return *this;\n        }\n        mint &operator/=(const mint &r) {\n                return (*this) *= r.inv();\n        }\n\n        mint pow(int r) const {\n                mint k = *this, ret = 1;\n                while (r > 0) {\n                        if (r % 2 != 0) ret *= k;\n                        r /= 2;\n                        k *= k;\n                }\n                return ret;\n        }\n\n        mint inv() const {\n                return pow(M - 2);\n        }\n\nprivate:\n        int64_t v;\n};\n\ntemplate <int64_t M>\ninline mint<M> operator+(mint<M> l, const mint<M> &r) {\n        return l += r;\n}\n\ntemplate <int64_t M>\ninline mint<M> operator-(mint<M> l, const mint<M> &r) {\n        return l -= r;\n}\n\ntemplate <int64_t M>\ninline mint<M> operator*(mint<M> l, const mint<M> &r) {\n        return l *= r;\n}\n\ntemplate <int64_t M>\ninline mint<M> operator/(mint<M> l, const mint<M> &r) {\n        return l /= r;\n}\n\ntemplate <int64_t M>\ninline ostream &operator<<(ostream &os, const mint<M> &r) {\n        return os << r.get();\n}\n\ntypedef mint<1000000007> MINT;\n\nint n, m;\nMINT tbl[301][301][301];\n\nMINT solve(int s, int w, int r)\n{\n    // cout << s << \" \" << w << \" \" << r << endl;\n\n    if (r == 0) {\n        return s == n ? 1 : 0;\n    }\n\n    int u = n - s - w;\n\n    MINT &ret = tbl[s][w][r];\n    if (ret.get() >= 0)\n        return ret;\n\n    ret = 0;\n    ret += solve(s + w, 0, r - 1) * MINT(s);\n    if (w > 0) ret += solve(s, w, r - 1) * MINT(w);\n    if (u > 0) ret += solve(s, w + 1, r - 1) * MINT(u);\n\n    return ret;\n}\n\nint main()\n{\n    cin.tie(0);\n\n    cin >> n >> m;\n    cout << solve(1, 0, m) << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <map>\n#include <cmath>\n#include <cstdio>\n#include <vector>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\n#define x first\n#define y second\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<pii> vpii;\n\ntemplate <class T>\nvoid read(T &x)\n{\n\tchar ch;\n\tfor (ch=getchar();(ch<'0'||ch>'9')&&ch!='-';) ch=getchar();\n\tx=0;int t=1;if (ch=='-') {ch=getchar();t=-1;}\n\tfor (;ch>='0'&&ch<='9';ch=getchar()) x=x*10+ch-'0';\n\tx*=t;\n}\n\nconst int mod=1000000007;\n\nint dp[310][310],dp2[310][310];\n\nint main()\n{\n\t#ifndef ONLINE_JUDGE\n\t\t//freopen(\"input.txt\",\"r\",stdin);\n\t\t//freopen(\"output.txt\",\"w\",stdout);\n\t#endif\n\tint n,m;scanf(\"%d%d\",&n,&m);\n\tdp[1][1]=1;\n\tfor (int i=1;i<=m;i++)\n\t{\n\t\tfor (int j=1;j<=n;j++)\n\t\t\tfor (int k=1;k<=j;k++)\n\t\t\t{\n\t\t\t\tdp2[j][k]=dp[j][k];dp[j][k]=0;\n\t\t\t}\n\t\tfor (int j=1;j<=n;j++)\n\t\t\tfor (int k=1;k<=j;k++)\n\t\t\t{\n\t\t\t\tdp[j+1][k]=(ll(dp2[j][k])*(n-j)+dp[j+1][k])%mod;\n\t\t\t\tdp[j][k]=(ll(dp2[j][k])*(j-k)+dp[j][k])%mod;\n\t\t\t\tdp[j][j]=(ll(dp2[j][k])*k+dp[j][j])%mod;\n\t\t\t}\n\t}\n\tprintf(\"%d\\n\",dp[n][n]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <memory.h>\n#include <math.h>\n#include <assert.h>\n#include <queue>\n#include <map>\n#include <set>\n#include <string>\n#include <algorithm>\n#include <iostream>\n#include <functional>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> Pi;\n#define Fi first\n#define Se second\n#define pb(x) push_back(x)\n#define sz(x) (int)x.size()\n#define rep(i, n) for(int i=0;i<n;i++)\n#define all(x) x.begin(), x.end()\n\nconst int MOD = 1e9 + 7;\nint D[302][302][302];\nint N, M;\n\nint dfs(int a, int b, int c){\n\tif(D[a][b][c] != -1)return D[a][b][c];\n\tint &res = D[a][b][c]; res = 0;\n\tif(a == 0){\n\t\tif(b == 0 && c == N)res = 1;\n\t\telse res = 0;\n\t}\n\telse{\n\t\tif(b > 0)res = (b * (ll)dfs(a-1, b-1, c)) % MOD;\n\t\tif(N-b-c > 0)res = (res + (ll)(N-b-c) * dfs(a-1, b, c)) % MOD;\n\t\tres = (res + (ll)c * dfs(a-1, b, N-b)) % MOD;\n\t}\n\treturn res;\n}\n\nvoid solve(){\n\tscanf(\"%d%d\", &N, &M);\n\tmemset(D, -1, sizeof D);\n\tprintf(\"%d\", dfs(M, N-1, 1));\n}\n\nint main(){\n\tint Tc = 1; //scanf(\"%d\\n\", &Tc);\n\tfor(int tc=1;tc<=Tc;tc++){\n\t\tsolve();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <map>\n#include <cmath>\n#include <ctime>\n#include <bitset>\n#include <string>\n#include <vector>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cassert>\n#include <iomanip>\n#include <iostream>\n#include <algorithm>\n#define PR pair\n#define fi first\n#define se second\n#define mk make_pair\n#define pb push_back\n#define REP(i, x, y)   for(int i = (int)(x); i <= (int)(y); i++)\n#define FOR(i, x, y)   for(int i = (int)(x); i <  (int)(y); i++)\n#define PER(i ,x, y)  for(int i = (int)(x); i >= (int)(y); i--)\n#define CH\t         ch = getchar()\n#define Exit(...)    printf(__VA_ARGS__), exit(0)\n#define dln()        fprintf(stderr,\"\\n\")\n#define dprintf(...) fprintf(stderr,__VA_ARGS__)\nusing namespace std;\ntypedef double\t  db;\ntypedef long long LL;\ntypedef vector<int> VI;\ntypedef vector<VI > VII;\ntypedef PR<int,int> PII;\ntypedef vector<PII> VPI;\nconst\tint inf=2e9;\nconst\tLL Inf=1e10;\nconst\tint P=1e9+7;\nconst\tint N=1005;\n\ninline LL IN(){\n\tLL x = 0;\n\tint ch = 0, f = 0;\n\tfor (CH; ch != -1 && (ch < 48 || ch > 57); CH) f = (ch == '-');\n\tfor (; ch >= 48 && ch <= 57; CH) x = (x << 1) + (x << 3) + ch - '0';\n\treturn f ? (-x) : x;\n}\ntemplate<typename T> inline int chkmin(T &a, const T &b){if(b < a) return a = b, 1; return 0;}\ntemplate<typename T> inline int chkmax(T &a, const T &b){if(b > a) return a = b, 1; return 0;}\n\nvoid renew(int &x, const int &y){\n\tx += y;\n\tif(x >= P) x -= P;\n\tif(x <  0) x += P;\n}\n\nint Pow(int x, int y, int p){\n\tint a = 1;\n\tfor (; y; y >>= 1, x = (LL)x * x %p) if(y & 1) a=(LL)a * x%p;\n\treturn a;\n}\n\nint n, m;\nint dp[305][305][305];\nint main(){\n\tscanf(\"%d%d\", &n, &m);\n\tdp[0][1][1] = 1;\n\tREP(i, 0, m)\n\tREP(j, 0, n)\n\tREP(k, 0, j){\n\t\tint val = dp[i][j][k];\n\t\tif(!val) continue;\n\t\trenew(dp[i + 1][j + 1][k], (LL)val * (n - j) % P);\n\t\trenew(dp[i + 1][j][k], (LL)val * (j - k) % P);\n\t\trenew(dp[i + 1][j][j], (LL)val * k % P);\n\t}\n\tprintf(\"%d\\n\", dp[m][n][n]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <sstream>\n#include <string>\n#define _repargs(_1,_2,_3,name,...) name\n#define _rep(i,n) repi(i,0,n)\n#define repi(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define rep(...) _repargs(__VA_ARGS__,repi,_rep,)(__VA_ARGS__)\n#define all(x) (x).begin(),(x).end()\n#define mod 1000000007\n#define inf 2000000007\n#define mp make_pair\n#define pb push_back\ntypedef long long ll;\nusing namespace std;\ntemplate <typename T>\ninline void output(T a, int p = 0) {\n    if(p) cout << fixed << setprecision(p)  << a << \"\\n\";\n    else cout << a << \"\\n\";\n}\n// end of template\n\n// i日目, 訪れた頂点数j, 頂点1に戻れる頂点数k\nll dp[301][301][301];\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n    // source code\n    int N, M;\n    cin >> N >> M;\n    dp[0][1][1] = 1;\n    rep(i, M) rep(j, N + 1) rep(k, N + 1) {\n        (dp[i + 1][j + 1][k] += dp[i][j][k] * (N - j)) %= mod;\n        if(j >= k) (dp[i + 1][j][k] += dp[i][j][k] * (j - k)) %= mod;\n        (dp[i + 1][j][j] += dp[i][j][k] * k) %= mod;\n    }\n    \n    output(dp[M][N][N]);\n    \n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n \nusing namespace std;\nusing namespace __gnu_pbds;\n \n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define fbo find_by_order\n#define ook order_of_key\n \ntypedef long long ll;\ntypedef pair<ll,ll> ii;\ntypedef vector<int> vi;\ntypedef long double ld; \ntypedef tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> pbds;\ntypedef set<int>::iterator sit;\ntypedef map<int,int>::iterator mit;\ntypedef vector<int>::iterator vit;\n \nconst int MOD = 1e9 + 7;\nint dp[301][301];\nint g[301][301];\nint c[301][301];\n \nvoid add(int &a, int b)\n{\n\ta=(a+b)%MOD;\n}\n \nint mult(int a, int b)\n{\n\treturn (a*1LL*b)%MOD;\n}\n \nint choose(int n, int r)\n{\n\tif(n < r) return 0;\n\tif(n==r) return 1;\n\tif(r==0) return 1;\n\tif(c[n][r]!=-1) return c[n][r];\n\tc[n][r] = (choose(n-1,r)+choose(n-1,r-1))%MOD;\n\treturn c[n][r];\n}\n \n \nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tmemset(c,-1,sizeof(c));\n\tint n, m; cin>>n>>m;\n       if(n>m+1) {cout<<0<<'\\n'; return 0;}\n\tg[0][0] = 1;\n\tg[1][1] = 1;\n\tfor(int i = 2; i <= m; i++) g[i][1] = 1;\n\tfor(int j = 2; j <= n; j++)\n\t{\n\t\tfor(int i = j; i <= m; i++)\n\t\t{\n\t\t\tfor(int k = 1; k + j - 1 <= i; k++)\n\t\t\t{\n\t\t\t\tadd(g[i][j], mult(g[i-k][j-1], choose(i, k)));\n\t\t\t}\n\t\t}\n\t}\n\t//cerr<<g[10][3]<<'\\n';\n\tdp[0][1] = 1;\n\tfor(int i = 0; i < m; i++)\n\t{\n\t\tfor(int j = 1; j <= min(i+1,n); j++)\n\t\t{\n\t\t\tint val = dp[i][j];\n\t\t\tfor(int l = 1; l <= m - i; l++)\n\t\t\t{\n\t\t\t\tfor(int k = 0; k <= min(l - 1, n - j); k++)\n\t\t\t\t{\n\t\t\t\t\tadd(dp[i+l][j+k], mult(val, mult(choose(n-j,k),mult(g[l-1][k], j))));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << dp[m][n] << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include<set>\n#include<map>\n#include<cmath>\n#include<queue>\n#include<bitset>\n#include<string>\n#include<cstdio>\n#include<cctype>\n#include<cassert>\n#include<cstdlib>\n#include<cstring>\n#include<sstream>\n#include<iostream>\n#include<algorithm>\n\n#define For(i,x,y) for (int i=x;i<y;i++)\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n\n#define dprintf(...) fprintf(stderr,__VA_ARGS__)\nusing namespace std;\n\nint IN(){\n\tint c,f,x;\n\twhile (!isdigit(c=getchar())&&c!='-');c=='-'?(f=1,x=0):(f=0,x=c-'0');\n\twhile (isdigit(c=getchar())) x=(x<<1)+(x<<3)+c-'0';return !f?x:-x;\n}\n\ntypedef long long ll;\ntypedef double db;\ntypedef pair<int,int> pii;\ntypedef vector<int> Vi;\n\nconst int N=300+3;\nconst int p=1e9+7;\n\nint C[N][N],F[N][N],G[N][N][N],pw[N][N],iv[N][N];\nint n,m,res;\n\nint Pow(int a,int b){\n\tint res=1;\n\tfor (;b;b>>=1,a=1ll*a*a%p) if (b&1) res=1ll*res*a%p;\n\treturn res;\n}\n\nint main(){\n\tFor(i,0,N){\n\t\tC[i][0]=1;\n\t\tFor(j,1,i+1) C[i][j]=(C[i-1][j-1]+C[i-1][j])%p;\n\t}\n\tFor(i,0,N) For(j,0,N){\n\t\tpw[i][j]=Pow(i,j);\n\t\tiv[i][j]=Pow(pw[i][j],p-2);\n\t}\n\tn=IN(),m=IN();\n\tFor(a,1,n+1){\n\t\tFor(b,0,m+1){\n\t\t\tF[a][b]=pw[a][b];\n\t\t\tFor(i,1,a){\n\t\t\t\tF[a][b]=(F[a][b]-1ll*G[a][i][b]*pw[a-i][b]%p+p)%p;\n\t\t\t}\n\t\t}\n\t\tFor(i,a+1,n+1){\n\t\t\tFor(j,0,m+1){\n\t\t\t\tG[i][a][j]=((!j?0:G[i][a][j-1])+1ll*C[i-1][a-1]*iv[i-a][j]%p*F[a][j])%p;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\",F[n][m]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N,M;\nll dp[303][303][303];\nll mo=1000000007;\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N>>M;\n\tif(M<N) return _P(\"0\\n\");\n\tdp[0][1][1]=1; // as, tot\n\tFOR(i,M) {\n\t\tFOR(x,N+1) FOR(y,N+1) if(dp[i][x][y]) {\n\t\t\tll t=dp[i][x][y];\n\t\t\t// loop\n\t\t\t(dp[i+1][y][y] += t*x)%=mo;\n\t\t\t// already\n\t\t\t(dp[i+1][x][y] += t*(y-x))%=mo;\n\t\t\t// new\n\t\t\tif(y<N) (dp[i+1][x][y+1] += t*(N-y))%=mo;\n\t\t}\n\t}\n\t\n\tcout<<dp[M][N][N]<<endl;\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n';\n\tFOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tsolve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int mod = 1000000007;\nint N, M;\nlong long memo[301][301][301];\nbool visited[301][301][301];\nlong long f(int m, int p, int q) {\n\tif (m == 0) return q == N ? 1 : 0;\n\tif (visited[m][p][q]) return memo[m][p][q];\n\tvisited[m][p][q] = true;\n\tlong long r = 0;\n\tr += f(m-1, p, p) * q;\n\tr += f(m-1, p, q) * (p - q);\n\tif (p < N) r += f(m-1, p+1, q);\n\treturn memo[m][p][q] = r % mod;\n}\nint main() {\n\tcin >> N >> M;\n\tlong long r = f(M, 1, 1);\n\tfor (int i = 2; i <= N-1; ++ i) r = (r * i) % mod;\n\tcout << r << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconstexpr int mod = 1e9 + 7;\n\nint main() {\n  int n, m;\n  cin >> n >> m;\n\n  vector<vector<int64_t>> dp(334, vector<int64_t>(334, 0));\n  dp[n - 1][1] = 1;\n\n  for (int i = 0; i < m; ++i) {\n    vector<vector<int64_t>> dp2(334, vector<int64_t>(334, 0));\n    for (int j = 0; j < n; ++j) {\n      for (int k = 1; k <= n; ++k) {\n        (dp2[j][n - j] += k * dp[j][k] % mod) %= mod;\n        if (j) (dp2[j - 1][k] += j * dp[j][k]) %= mod;\n        (dp2[j][k] += (n - j - k) * dp[j][k]) %= mod;\n      }\n    }\n\n    dp = dp2;\n  }\n\n  cout << dp[0][n] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n#define pb push_back\n#define ins insert\n#define pii pair<int,int>\n#define fs first\n#define sc second\n#define mpr make_pair\n#define iter iterator\n#define all(X) X.begin(),X.end()\n#define sau(X) sort(all(X)),X.resize(unique(all(X))-X.begin())\n#define exist(X,ele) binary_search(all(X),ele)\n#define y0 I_love_Ryougi_Shiki_0\n#define y1 I_love_Ryougi_Shiki_1\n\ntemplate<typename T1,typename T2>\nostream& operator << (ostream& out,const pair<T1,T2>& X)\n{\n\tout<<\"{\"<<X.fs<<\",\"<<X.sc<<\"}\";\n\treturn out;\n}\n\ntemplate<typename T>\nostream& operator << (ostream& out,const vector<T>& X)\n{\n\tfor(auto i:X) out<<i<<\" \";\n\treturn out;\n}\n\ntemplate<typename T>\ninline void cmin(T& x,T y)\n{\n\tif(!(x<y)) x=y;\n}\n\ntemplate<typename T>\ninline void cmax(T& x,T y)\n{\n\tif(x<y) x=y;\n}\n\nconst int inf=5000000000000000ll;\nconst int mod=1000000007;\n\nint dp[310][310][310]; // i edges | j points in total | k points can reach 1\n\nmain()\n{\n\tios::sync_with_stdio(false);\n\t\n\tint N,M; cin>>N>>M;\n\tdp[0][1][1]=1;\n\tfor(int i=0;i<M;i++)\n\t{\n\t\tfor(int j=1;j<=N && j<=i+1;j++)\n\t\t{\n\t\t\tfor(int k=1;k<=j;k++)\n\t\t\t{\n\t\t\t\tif(dp[i][j][k]==0) continue;\n\t\t\t\tdp[i+1][j+1][k]+=dp[i][j][k]*(N-j)%mod;dp[i+1][j+1][k]%=mod; // nxt=white->grey\n\t\t\t\tdp[i+1][j][k]+=dp[i][j][k]*(j-k)%mod;dp[i+1][j][k]%=mod; // nxt=grey\n\t\t\t\tdp[i+1][j][j]+=dp[i][j][k]*k%mod;dp[i+1][j][j]%=mod; // nxt=black all grey->black\n\t\t\t}\n\t\t}\n\t}\n\tcout<<dp[M][N][N]<<endl;\n\t\n\treturn 0;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cassert>\n#include <typeinfo>\n#include <vector>\n#include <stack>\n#include <cmath>\n#include <set>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n#include <queue>\n#include <iomanip>\n#include <cctype>\n#include <random>\n#include <complex>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<string> vs;\ntypedef vector<bool> vb;\ntypedef vector<vb> vvb;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<P,int> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<30;\nconst ll INF=1ll<<62;\nconst double pi=acos(-1);\nconst double eps=1e-7;\nconst ll mod=1e9+7;\nconst int dx[4]={0,1,0,-1},dy[4]={1,0,-1,0};\n\nint n,m;\n\nint main(){\n\tcin>>n>>m;\n\tvvl dp,DP;\n\tdp=DP=vvl(n+1,vl(n+1));\n\tdp[1][0]=1;\n\tfor(int i=0;i<m;i++){\n\t\tfor(int j=1;j<=n;j++){\n\t\t\tDP[j][0]=0;\n\t\t\tfor(int k=1;k<=j;k++) (DP[j][0]+=dp[k][j-k]*k)%=mod;\n\t\t}\n\t\tfor(int j=1;j<=n;j++) for(int k=1;k<=n;k++){\n\t\t\tDP[j][k]=(dp[j][k]*k+dp[j][k-1]*(n-k))%mod;\n\t\t}\n\t\tdp=DP;\n\t}\n\tcout<<dp[n][0]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconstexpr int mod = 1e9 + 7;\n\n// int64_t dp[334][334][334];\nvector<vector<int64_t>> dp(334, vector<int64_t>(334, 0));\n\nint main() {\n  int n, m;\n  cin >> n >> m;\n\n  dp[n - 1][1] = 1;\n  for (int i = 0; i < m; ++i) {\n    vector<vector<int64_t>> dp2(334, vector<int64_t>(334, 0));\n    for (int j = 0; j < n; ++j) {\n      for (int k = 1; k <= n; ++k) {\n        (dp2[j][n - j] += k * dp[j][k] % mod) %= mod;\n        if (j) (dp2[j - 1][k] += j * dp[j][k] % mod) %= mod;\n        (dp2[j][k] += (n - j - k) * dp[j][k]) %= mod;\n      }\n    }\n    dp = dp2;\n  }\n\n  cout << dp[0][n] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <string.h>\n\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\n#define ll long long\n#define ull unsigned ll\n#define db double\n#define INF 0x3f3f3f3f\n#define MOD 1000000007\n#define PII pair<int, int>\n\nint n,m;\nll f[310][310];\n\nint main() {\n\tscanf(\"%d%d\",&n,&m);\n\tmemset(f,0,sizeof(f));\n\tf[0][0]=1;\n\tfor (int i=1;i<=m;i++) f[0][i]=(f[0][i-1]*n)%MOD;\n\tfor (int i=1;i<=n;i++) {\n\t\tf[i][i]=1;\n\t\tfor (int j=i+1;j<=m;j++) {\n\t\t\tf[i][j]=((n-1)*f[i][j-1]+f[i-1][j-1])%MOD;\n\t\t}\n\t}\n\tll ans=((n-1)*f[n][m-1]+f[n-1][m-1])%MOD;\n\tfor (int i=1;i<n;i++) {\n\t\tans=(ans*i)%MOD;\n\t}\n\tprintf(\"%lld\\n\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define mp make_pair\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<ll> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef pair<int,pii> pip;\ntypedef vector<pip>vip;\nconst double PI=acos(-1);\nconst double EPS=1e-8;\nconst int inf=1e8;\nint main(){\n\tint n,m;\n\tcin>>n>>m;\n\tif(n>m){\n\t\tcout<<0<<endl;\n\t\treturn 0;\n\t}\n\tvvi dp(n+1,vi(n+1));\n\tll MOD=1000000007;\n\tdp[1][1]=1;\n\trep(q,m){\n\t\tvvi ndp(n+1,vi(n+1));\n\t\tloop(i,1,n+1)loop(j,1,n+1){\n\t\t\tif(i!=n)(ndp[i+1][j]+=dp[i][j]*(n-i))%=MOD;\n\t\t\t        (ndp[i  ][j]+=dp[i][j]*(i-j))%=MOD;\n\t\t\t        (ndp[i  ][i]+=dp[i][j]*(j  ))%=MOD;\n\t\t}\n\t\tdp=ndp;\n\t}\n\tcout<<dp[n][n]<<endl;\n}\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define llint long long\n#define mod 1000000007\n\nusing namespace std;\n\nllint N, M;\nllint dp[305][305][305];\n\nint main(void)\n{\n\tcin >> N >> M;\n\t\n\tdp[0][0][1] = 1;\n\tfor(int i = 0; i < M; i++){\n\t\tfor(int j = 0; j <= N; j++){\n\t\t\tfor(int k = 0; k <= N; k++){\n\t\t\t\tif(N-(j+k) > 0){\n\t\t\t\t\tdp[i+1][j+1][k] += dp[i][j][k] * (N-(j+k)) % mod;\n\t\t\t\t\tdp[i+1][j+1][k] %= mod;\n\t\t\t\t}\n\t\t\t\tif(j > 0){\n\t\t\t\t\tdp[i+1][j][k] += dp[i][j][k] * j % mod;\n\t\t\t\t\tdp[i+1][j][k] %= mod;\n\t\t\t\t}\n\t\t\t\tif(k > 0){\n\t\t\t\t\tdp[i+1][0][j+k] += dp[i][j][k] * k % mod;\n\t\t\t\t\tdp[i+1][0][j+k] %= mod;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tcout << dp[M][0][N] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n#define pb push_back\n#define ins insert\n#define pii pair<int,int>\n#define fs first\n#define sc second\n#define mpr make_pair\n#define iter iterator\n#define all(X) X.begin(),X.end()\n#define sau(X) sort(all(X)),X.resize(unique(all(X))-X.begin())\n#define exist(X,ele) binary_search(all(X),ele)\n#define y0 I_love_Ryougi_Shiki_0\n#define y1 I_love_Ryougi_Shiki_1\n\ntemplate<typename T1,typename T2>\nostream& operator << (ostream& out,const pair<T1,T2>& X)\n{\n\tout<<\"{\"<<X.fs<<\",\"<<X.sc<<\"}\";\n\treturn out;\n}\n\ntemplate<typename T>\nostream& operator << (ostream& out,const vector<T>& X)\n{\n\tfor(auto i:X) out<<i<<\" \";\n\treturn out;\n}\n\ntemplate<typename T>\ninline void cmin(T& x,T y)\n{\n\tif(!(x<y)) x=y;\n}\n\ntemplate<typename T>\ninline void cmax(T& x,T y)\n{\n\tif(x<y) x=y;\n}\n\nconst int inf=5000000000000000ll;\nconst int mod=1000000007;\n\nint dp[310][210][210]; // i edges | j points in total | k points can reach 1\n\nmain()\n{\n\tios::sync_with_stdio(false);\n\t\n\tint N,M; cin>>N>>M;\n\tdp[0][1][1]=1;\n\tfor(int i=0;i<M;i++)\n\t{\n\t\tfor(int j=1;j<=N && j<=i+1;j++)\n\t\t{\n\t\t\tfor(int k=1;k<=j;k++)\n\t\t\t{\n\t\t\t\tif(dp[i][j][k]==0) continue;\n\t\t\t\tdp[i+1][j+1][k]+=dp[i][j][k]*(N-j),dp[i+1][j+1][k]%=mod; // nxt=white->grey\n\t\t\t\tdp[i+1][j][k]+=dp[i][j][k]*(j-k),dp[i+1][j][k]%=mod; // nxt=grey\n\t\t\t\tdp[i+1][j][j]+=dp[i][j][k]*k,dp[i+1][j][j]%=mod; // nxt=black all grey->black\n\t\t\t}\n\t\t}\n\t}\n\tcout<<dp[M][N][N]<<endl;\n\t\n\treturn 0;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define whlie while\n#define pb push_back\n#define eb emplace_back\n#define fi first\n#define se second\n#define rep(i,N) for(int i = 0; i < (N); i++)\n#define repr(i,N) for(int i = (N) - 1; i >= 0; i--)\n#define rep1(i,N) for(int i = 1; i <= (N) ; i++)\n#define repr1(i,N) for(int i = (N) ; i > 0 ; i--)\n#define each(x,v) for(auto& x : v)\n#define all(v) (v).begin(),(v).end()\n#define sz(v) ((int)(v).size())\n#define ini(...) int __VA_ARGS__; in(__VA_ARGS__)\n#define inl(...) ll __VA_ARGS__; in(__VA_ARGS__)\n#define ins(...) string __VA_ARGS__; in(__VA_ARGS__)\nusing namespace std; void solve();\nusing ll = long long; using vl = vector<ll>;\nusing vi = vector<int>; using vvi = vector< vector<int> >;\nconstexpr int inf = 1001001001;\nconstexpr ll infLL = (1LL << 61) - 1;\nstruct IoSetupNya {IoSetupNya() { cin.tie(nullptr); ios::sync_with_stdio(false); cout << fixed << setprecision(15); cerr << fixed << setprecision(7);} } iosetupnya;\ntemplate<typename T, typename U> inline bool amin(T &x, U y) { return (y < x) ? (x = y, true) : false; }\ntemplate<typename T, typename U> inline bool amax(T &x, U y) { return (x < y) ? (x = y, true) : false; }\ntemplate<typename T, typename U> ostream& operator <<(ostream& os, const pair<T, U> &p) { os << p.first << \" \" << p.second; return os; }\ntemplate<typename T, typename U> istream& operator >>(istream& is, pair<T, U> &p) { is >> p.first >> p.second; return is; }\ntemplate<typename T> ostream& operator <<(ostream& os, const vector<T> &v) { int s = (int)v.size(); rep(i,s) os << (i ? \" \" : \"\") << v[i]; return os; }\ntemplate<typename T> istream& operator >>(istream& is, vector<T> &v) { for(auto &x : v) is >> x; return is; }\nvoid in(){} template <typename T,class... U> void in(T &t,U &...u){ cin >> t; in(u...);}\nvoid out(){cout << \"\\n\";} template <typename T,class... U> void out(const T &t,const U &...u){ cout << t; if(sizeof...(u)) cout << \" \"; out(u...);}\ntemplate<typename T>void die(T x){out(x); exit(0);}\n#ifdef NyaanDebug\n  #include \"NyaanDebug.h\"\n  #define trc(...) do { cerr << #__VA_ARGS__ << \" = \"; dbg_out(__VA_ARGS__);} while(0)\n  #define trca(v,N) do { cerr << #v << \" = \"; array_out(v , N);cout << endl;} while(0)\n#else\n  #define trc(...)\n  #define trca(...)\n  int main(){solve();}\n#endif\nusing P = pair<ll,ll>; using vp = vector<P>;\nconstexpr int MOD = /**/ 1000000007; //*/ 998244353;\n/////////\n\ntemplate< int mod >\nstruct ModInt {\n  int x;\n\n  ModInt() : x(0) {}\n\n  ModInt(int64_t y) : x(y >= 0 ? y % mod : (mod - (-y) % mod) % mod) {}\n\n  ModInt &operator+=(const ModInt &p) {\n    if((x += p.x) >= mod) x -= mod;\n    return *this;\n  }\n\n  ModInt &operator-=(const ModInt &p) {\n    if((x += mod - p.x) >= mod) x -= mod;\n    return *this;\n  }\n\n  ModInt &operator*=(const ModInt &p) {\n    x = (int) (1LL * x * p.x % mod);\n    return *this;\n  }\n\n  ModInt &operator/=(const ModInt &p) {\n    *this *= p.inverse();\n    return *this;\n  }\n\n  ModInt operator-() const { return ModInt(-x); }\n\n  ModInt operator+(const ModInt &p) const { return ModInt(*this) += p; }\n\n  ModInt operator-(const ModInt &p) const { return ModInt(*this) -= p; }\n\n  ModInt operator*(const ModInt &p) const { return ModInt(*this) *= p; }\n\n  ModInt operator/(const ModInt &p) const { return ModInt(*this) /= p; }\n\n  bool operator==(const ModInt &p) const { return x == p.x; }\n\n  bool operator!=(const ModInt &p) const { return x != p.x; }\n\n  ModInt inverse() const {\n    int a = x, b = mod, u = 1, v = 0, t;\n    while(b > 0) {\n      t = a / b;\n      swap(a -= t * b, b);\n      swap(u -= t * v, v);\n    }\n    return ModInt(u);\n  }\n\n  ModInt pow(int64_t n) const {\n    ModInt ret(1), mul(x);\n    while(n > 0) {\n      if(n & 1) ret *= mul;\n      mul *= mul;\n      n >>= 1;\n    }\n    return ret;\n  }\n\n  friend ostream &operator<<(ostream &os, const ModInt &p) {\n    return os << p.x;\n  }\n\n  friend istream &operator>>(istream &is, ModInt &a) {\n    int64_t t;\n    is >> t;\n    a = ModInt< mod >(t);\n    return (is);\n  }\n\n  static int get_mod() { return mod; }\n};\n\nusing modint = ModInt< MOD >;\n\nmodint dp[303][303][303];\n\nvoid solve(){\n  ini(N , M);\n\n  dp[0][N - 1][1] = 1;\n  \n  rep(t , M) rep(x , N + 1) rep(y , N + 1){\n    // (a)\n    dp[t + 1][x][N - x] += dp[t][x][y] * ( (x+y==N) ? (y-1) : y );\n    // (b)\n    if(x) dp[t + 1][x - 1][y] += dp[t][x][y] * x;\n    // (c)\n    if(x + y != N) dp[t + 1][x][y] += dp[t][x][y] * (N-x-y-1);\n  }\n\n  out(dp[M][0][N]);\n\n  \n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <set>\n#include <vector>\n#include <cstring>\n\nusing namespace std;\n\ntypedef long long ll;\nconst ll mod = 1e9+7;\nll dp[333][333][333];\n\nll pl(ll a, ll b) {\n  return (a+b)%mod;\n}\nll ml(ll a, ll b) {\n  return (a*b)%mod;\n}\n\nint main(void) {\n  int n, m;\n  scanf(\"%d%d\", &n, &m);\n  dp[0][1][0] = 1;\n  for (int i = 0; i < m; i++) {\n    for (int j = 1; j <= n; j++) {\n      //*\n      // 強連結な頂点から強連結な頂点へ\n      dp[i+1][j][0] = pl(dp[i+1][j][0], ml(dp[i][j][0], j));\n      // 強連結な頂点から強連結でない頂点へ\n      dp[i+1][j][1] = pl(dp[i+1][j][1], ml(dp[i][j][0], n-j));\n      //*/\n      for (int k = 1; k < n; k++) {\n        // 強連結でない頂点から強連結でない頂点，新しく加える\n        if (n-j-k >= 0) {\n          dp[i+1][j][k+1] = pl(dp[i+1][j][k+1], ml(dp[i][j][k], n-j-k));\n        }\n        // 強連結でない頂点から強連結でない頂点へ\n        dp[i+1][j][k] = pl(dp[i+1][j][k], ml(dp[i][j][k], k));\n        // 強連結でない頂点から強連結な頂点へ\n        if (j+k <= n) {\n          dp[i+1][j+k][0] = pl(dp[i+1][j+k][0], ml(dp[i][j][k], j));\n        }\n      }\n    }\n  }\n  printf(\"%lld\\n\", dp[m][n][0]);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\ntypedef pair<LL, LL> PLL;\n\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define SORT(c) sort((c).begin(),(c).end())\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n#define FF first\n#define SS second\ntemplate<class S, class T>\nistream& operator>>(istream& is, pair<S,T>& p){\n  return is >> p.FF >> p.SS;\n}\n\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst LL MOD = 1e9+7;\n\nLL dp[310][310][310];\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  int N, M; cin >> N >> M;\n  dp[0][1][1] = 1;\n  for(int l=0;l<M;++l){\n\tfor(int n=1;n<=N;++n){\n\t  for(int k=1;k<=n;++k){\n\t\t(dp[l+1][n][k] += dp[l][n][k] * (n - k)) %= MOD;\n\t\t(dp[l+1][n][n] += dp[l][n][k] * k) %= MOD;\n\t\t(dp[l+1][n+1][k] += dp[l][n][k]) %= MOD;\n\t  }\n\t}\n  }\n\n  LL ans = dp[M][N][N];\n  for(LL i=1;i<N;++i)\n\t(ans *= i) %= MOD;\n  cout << ans << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma target(\"avx\")\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<ll, ll> P;\ntypedef vector<ll> V;\ntypedef unordered_map<ll, ll> U_MAP;\ntypedef priority_queue<ll> pq;\ntypedef priority_queue<ll, vector<ll>, greater<ll>> rpq;\nconstexpr ll INF = 1e9, MOD = 1e9 + 7, ohara = 1e6 + 10;\nconstexpr ll LINF = 1e18;\n\n#define rep(i, n) for (ll(i) = 0; (i) < (int)(n); (i)++)\n#define rrep(i, a, b) for (ll i = (a); i < (b); i++)\n#define rrrep(i, a, b) for (ll i = (a); i >= (b); i--)\n#define all(v) (v).begin(), (v).end()\n#define Size(n) (n).size()\n#define Cout(x) cout << (x) << endl\n#define doublecout(a) cout << fixed << setprecision(15) << a << endl;\n#define fi first\n#define se second\n#define m_p make_pair\n#define p_b push_back\nstring to_string(string s) { return '\"' + s + '\"'; }\nstring to_string(const char* s) { return to_string((string)s); }\nstring to_string(bool b) { return (b ? \"true\" : \"false\"); }\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p) {\n  return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\";\n}\ntemplate <typename A>\nstring to_string(A v) {\n  bool first = true;\n  string res = \"{\";\n  for (const auto& x : v) {\n    if (!first) {\n      res += \", \";\n    }\n    first = false;\n    res += to_string(x);\n  }\n  res += \"}\";\n  return res;\n}\nvoid debug_out() { cerr << endl; }\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << \" \" << to_string(H);\n  debug_out(T...);\n}\n#define debug(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n\n//------ Believe yourself as a genius!!!!!! ------\n\nint dy[] = {1, 0, -1, 0};\nint dx[] = {0, 1, 0, -1};\n// int dy[]={-1,0,1,-1,1,-1,0,1};int dx[]={-1,-1,-1,0,0,1,1,1};\nstring alph(\"abcdefghijklmnopqrstuvwxyz\"), s;\nll n, cnt, ans, a, b, c, d, tmp, m, h, w, x, y, sum, k, q;\nll dp[400][400][400];\n\nint main(void) {\n  cin.tie(0);\n  cout.tie(0);\n  ios::sync_with_stdio(false);\n\n  cin >> n >> m;\n  dp[0][1][1] = 1;\n  rrep(i, 1, m + 1) {\n    rrep(j, 1, n + 1) {\n      rrep(k, 1, n + 1) {\n        (dp[i][j][k] += dp[i - 1][j - 1][k] * (n - j)) %= MOD;\n        if (j - k >= 0) (dp[i][j][k] += dp[i - 1][j][k] * (j - k)) %= MOD;\n        (dp[i][j][j] += dp[i - 1][j][k] * k) %= MOD;\n      }\n    }\n  }\n  rep(i, m + 1) {\n    rep(j, n + 1) {\n      rep(k, n + 1) { cout << dp[i][j][k] << \" \"; }\n      cout << \"\\n\";\n    }\n    cout << \"\\n\";\n  }\n  ans = dp[m][n][n];\n  Cout(ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 305;\nconst long long int MOD = 1000000007;\nlong long int dp[MAXN][MAXN][MAXN];\nint main()\n{\n\tint n,m;\n\tcin>>n>>m;\n\tdp[0][1][1] = 1;\n\tfor (int i = 0; i <= m; ++i)\n\t{\n\t\tfor (int j = 0; j <= n; ++j)\n\t\t{\n\t\t\tfor (int k = 0; k <= n; ++k)\n\t\t\t{\n\t\t\t\tdp[i+1][j][j] = (dp[i+1][j][j] + dp[i][j][k]*k)%MOD;\n\t\t\t\tdp[i+1][j+1][k] = (dp[i+1][j+1][k] + dp[i][j][k]*(n-j))%MOD;\n\t\t\t\tdp[i+1][j][k] = (dp[i+1][j][k] + dp[i][j][k]*(j-k))%MOD;\n\t\t\t}\n\t\t}\n\t}\n\tcout<<dp[m][n][n]<<\"\\n\";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\nconst int INF = (1<<30);\nconst ll INFLL = (1ll<<60);\nconst ll MOD = (ll)(1e9+7);\n\n#define l_ength size\n\nvoid mul_mod(ll& a, ll b){\n\ta *= b;\n\ta %= MOD;\n}\n\nvoid add_mod(ll& a, ll b){\n\ta = (a<MOD)?a:(a-MOD);\n\tb = (b<MOD)?b:(b-MOD);\n\ta += b;\n\ta = (a<MOD)?a:(a-MOD);\n}\n\nll dp[334][334][334];\n\nint main(void){\n\tint n,m,i,j,k;\n\tcin >> n >> m;\n\tdp[0][n-1][1] = 1ll;\n\tfor(i=0; i<m; ++i){\n\t\tfor(j=0; j<n; ++j){\n\t\t\tfor(k=0; k<n; ++k){\n\t\t\t\tif(j+k+1>n){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tadd_mod(dp[i+1][j][k+1],dp[i][j+1][k+1]*(j+1)%MOD);\n\t\t\t\tadd_mod(dp[i+1][j][k+1],dp[i][j][k+1]*(n-j-k-1)%MOD);\n\t\t\t\tadd_mod(dp[i+1][j][n-j],dp[i][j][k+1]*(k+1)%MOD);\n\t\t\t}\n\t\t}\n\t}\n\tcout << dp[m][0][n] << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <string>\n#include <set>\n#include <cmath>\n#include <map>\n#define rep(i,n) for(int i=0;i<n;++i)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n//dp[i][j][k] 長さiでj個の点が含まれていて1を含む強連結点数がk個\nll dp[305][305][305];\nll mod = 1e9+7;\nint main(){\n    int n, m;\n    cin >> n >> m;\n    if(m<n){\n        puts(\"0\");\n        return 0;\n    }\n    dp[0][1][1]=1;\n    rep(i,m+1){\n        rep(j,n+1){\n            rep(k,j+1){\n                dp[i+1][j+1][k] += dp[i][j][k]*(n-j)%mod;\n                dp[i+1][j][k] += dp[i][j][k]*(j-k)%mod;\n                dp[i+1][j][j] += dp[i][j][k]*k%mod;\n                \n            }\n        }\n    }\n    cout << dp[m][n][n]%mod << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cmath>\n#include <queue>\n#include <vector>\n#include <map>\n#include <set>\n\nusing namespace std;\n\ntypedef pair<int , int> P2;\ntypedef pair<pair<int , int> , int> P3;\ntypedef pair<pair<int , int> , pair<int , int> > P4;\n#define Fst first\n#define Snd second\n#define PB(a) push_back(a)\n#define MP(a , b) make_pair((a) , (b))\n#define M3P(a , b , c) make_pair(make_pair((a) , (b)) , (c))\n#define M4P(a , b , c , d) make_pair(make_pair((a) , (b)) , make_pair((c) , (d)))\n#define repp(i,a,b) for(int i = (int)(a) ; i < (int)(b) ; ++i)\n#define repm(i,a,b) for(int i = (int)(a) ; i > (int)(b) ; --i)\n#define repv(t,it,v) for(vector<t>::iterator it = v.begin() ; it != v.end() ; ++it)\n\ntypedef long long LL;\n\nint N,M;\nLL dp[333][333][333];\nLL po[333];\nLL ans;\nconst LL mod = 1e9 + 7;\n\nint main(){\n\tscanf(\"%d%d\" , &N , &M);\n\tif(N > M){\n\t\tprintf(\"0\\n\");\n\t\treturn 0;\n\t}\n\tpo[0] = 1;\n\trepp(i,0,M){\n\t\tpo[i+1] = po[i] * N % mod;\n\t}\n\tdp[0][1][1] = 1;\n\trepp(i,1,M+1){\n\t\trepp(j,1,N+1){\n\t\t\trepp(k,1,j+1){\n\t\t\t\t(dp[i][j][k] += dp[i-1][j][k] * (j-k) + dp[i-1][j-1][k] * (N-j+1)) %= mod;\n\t\t\t\t(dp[i+1][j][j] += dp[i][j][k] * k) %= mod;\n\t\t\t}\n\t\t}\n\t//\trepp(k,1,N){\n\t//\t\t(dp[i][N][k] += dp[i-1][N][k] * (N-k) + dp[i-1][N-1][k]) %= mod;\n\t//\t\t(ans += (dp[i-1][N][k] * po[M-i] % mod) * k) %= mod;\n\t//\t}\n\t}\n\tprintf(\"%lld\\n\" , dp[M][N][N]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define all(v) (v).begin(),(v).end()\n#define pb push_back\n#define fi first\n#define se second\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nconst int mod=1000000007;\nint N,M;\nint dp[2][333][333];\n\ninline void add(int &a,int b){\n    a+=b;\n    if(a>=mod)a-=mod;\n}\n\nsigned main(){\n    cin>>N>>M;\n    dp[0][1][0]=1;\n    for(int i=0;i<M;i++){\n        for(int j=1;j<=N;j++){\n            for(int k=0;k<M&&j+k<=N;k++){\n                add(dp[(i+1)&1][j+k][0],dp[i&1][j][k]*j%mod);\n                add(dp[(i+1)&1][j][k+1],dp[i&1][j][k]*(N-j-k)%mod);\n                add(dp[(i+1)&1][j][k],dp[i&1][j][k]*k%mod);\n                dp[i&1][j][k]=0;\n            }\n        }\n    }\n    cout<<dp[M&1][N][0]<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cmath>\n#include <queue>\n#include <vector>\n#include <map>\n#include <set>\n\nusing namespace std;\n\ntypedef pair<int , int> P2;\ntypedef pair<pair<int , int> , int> P3;\ntypedef pair<pair<int , int> , pair<int , int> > P4;\n#define Fst first\n#define Snd second\n#define PB(a) push_back(a)\n#define MP(a , b) make_pair((a) , (b))\n#define M3P(a , b , c) make_pair(make_pair((a) , (b)) , (c))\n#define M4P(a , b , c , d) make_pair(make_pair((a) , (b)) , make_pair((c) , (d)))\n#define repp(i,a,b) for(int i = (int)(a) ; i < (int)(b) ; ++i)\n#define repm(i,a,b) for(int i = (int)(a) ; i > (int)(b) ; --i)\n#define repv(t,it,v) for(vector<t>::iterator it = v.begin() ; it != v.end() ; ++it)\n\ntypedef long long LL;\n\nint N,M;\nLL dp[333][333][333];\nLL po[333];\nLL ans;\nconst LL mod = 1e9 + 7;\n\nint main(){\n\tscanf(\"%d%d\" , &N , &M);\n\tif(N > M){\n\t\tprintf(\"0\\n\");\n\t\treturn 0;\n\t}\n\tpo[0] = 1;\n\trepp(i,0,M){\n\t\tpo[i+1] = po[i] * N % mod;\n\t}\n\tdp[1][1][1] = dp[0][1][1] = 1;\n\trepp(i,1,M+1){\n\t\trepp(j,1,N+1){\n\t\t\trepp(k,1,j+1){\n\t\t\t\t(dp[i][j][k] += dp[i-1][j][k] * (j-k) + dp[i-1][j-1][k] * (N-j+1)) %= mod;\n\t\t\t\t(dp[i+1][j][j] += dp[i][j][k] * k) %= mod;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\" , dp[M][N][N]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n////////////\n// ModInt //\n////////////\n\n// 四則演算の最も左に存在する値がModIntでなければキャストでバグる\n// 例えばx = mint * 1000;やx = ModInt(1000) * mint;はいいがx = 1000 * mint;は駄目。\ntemplate<int64_t mod_ = 1'000'000'007>\nclass ModInt {\nprivate:\n\tint64_t integer_;\n\npublic:\n\tconstexpr ModInt(const int64_t initial_number = 0)\n\t\t: integer_(initial_number){}\n\t\n\t// 四則演算\n\tconstexpr ModInt operator+(const ModInt& operand) const\n\t{\n\t\tModInt ret{this->integer_ + operand.integer_};\n\t\tif (ret.integer_ >= mod_)\n\t\t\tret.integer_ -= mod_;\n\t\treturn ret;\n\t}\n\tconstexpr ModInt operator-(const ModInt& operand) const\n\t{\n\t\tModInt ret{this->integer_ - operand.integer_};\n\t\tif (ret.integer_ < 0)\n\t\t\tret.integer_ += mod_;\n\t\treturn ret;\n\t}\n\tconstexpr ModInt operator*(const ModInt& operand) const\n\t{\n\t\treturn {this->integer_ * operand.integer_ % mod_};\n\t}\n\tconstexpr ModInt operator/(const ModInt& operand) const\n\t{\n\t\treturn *this * (operand ^ (mod_ - 2));\n\t}\n\n\t// 累乗\n\tconstexpr ModInt operator^(const int64_t operand) const\n\t{\n\t\tModInt ret{1}, pow_ope{this->integer_};\n\t\tfor (int64_t pow{operand}; pow > 0; pow >>= 1)\n\t\t{\n\t\t\tif (pow & 1) ret *= pow_ope;\n\t\t\tpow_ope *= pow_ope;\n\t\t}\n\t\treturn ret;\n\t}\n\n\t// 代入\n\tconstexpr ModInt& operator=(const ModInt& operand)\n\t{\n\t\tthis->integer_ = operand.integer_;\n\t\treturn *this;\n\t}\n\tconstexpr ModInt& operator+=(const ModInt& operand)\n\t{\n\t\t*this = *this + operand;\n\t\treturn *this;\n\t}\n\tconstexpr ModInt& operator-=(const ModInt& operand)\n\t{\n\t\t*this = *this - operand;\n\t\treturn *this;\n\t}\n\tconstexpr ModInt& operator*=(const ModInt& operand)\n\t{\n\t\t*this = *this * operand;\n\t\treturn *this;\n\t}\n\tconstexpr ModInt& operator/=(const ModInt& operand)\n\t{\n\t\t*this = *this / operand;\n\t\treturn *this;\n\t}\n\n\t// その他\n\tconstexpr operator int64_t() { return integer_; }\n\n\tconstexpr ModInt getOne() const\n\t{\n\t\treturn ModInt(1ll);\n\t}\n\tconstexpr ModInt getZero() const\n\t{\n\t\treturn ModInt(0ll);\n\t}\n};\n\nint main()\n{\n\tint N, M;\n\tscanf(\"%d%d\", &N, &M);\n\tusing Mint = ModInt<>;\n\tusing vi = std::vector<Mint>;\n\tusing vvi = std::vector<vi>;\n\tusing vvvi = std::vector<vvi>;\n\t// dp[day][visited][strong]\n\tvvvi dp(M + 1, vvi(N + 1, vi(N + 1)));\n\tdp[0][1][1] = Mint(1ll);\n\tfor (int day{}; day < M; day++)\n\t{\n\t\t// new\n\t\tfor (int visited{1}; visited <= N - 1; visited++)\n\t\t\tfor (int strong{1}; strong <= visited; strong++)\n\t\t\t\tdp[day + 1][visited + 1][strong] += dp[day][visited][strong] * Mint(N - visited);\n\t\t// visited, not strong\n\t\tfor (int visited{1}; visited <= N; visited++)\n\t\t\tfor (int strong{1}; strong < visited; strong++)\n\t\t\t\tdp[day + 1][visited][strong] += dp[day][visited][strong] * Mint(visited - strong);\n\t\t// strong\n\t\tfor (int visited{1}; visited <= N; visited++)\n\t\t\tfor (int strong{1}; strong <= visited; strong++)\n\t\t\t\tdp[day + 1][visited][visited] += dp[day][visited][strong] * Mint(strong);\n\t}\n\tstd::cout << dp.back().back().back() << std::endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n#define pb push_back\n#define ins insert\n#define pii pair<int,int>\n#define fs first\n#define sc second\n#define mpr make_pair\n#define iter iterator\n#define all(X) X.begin(),X.end()\n#define sau(X) sort(all(X)),X.resize(unique(all(X))-X.begin())\n#define exist(X,ele) binary_search(all(X),ele)\n#define y0 I_love_Ryougi_Shiki_0\n#define y1 I_love_Ryougi_Shiki_1\n\ntemplate<typename T1,typename T2>\nostream& operator << (ostream& out,const pair<T1,T2>& X)\n{\n\tout<<\"{\"<<X.fs<<\",\"<<X.sc<<\"}\";\n\treturn out;\n}\n\ntemplate<typename T>\nostream& operator << (ostream& out,const vector<T>& X)\n{\n\tfor(auto i:X) out<<i<<\" \";\n\treturn out;\n}\n\ntemplate<typename T>\ninline void cmin(T& x,T y)\n{\n\tif(!(x<y)) x=y;\n}\n\ntemplate<typename T>\ninline void cmax(T& x,T y)\n{\n\tif(x<y) x=y;\n}\n\nconst int inf=5000000000000000ll;\nconst int mod=1000000007;\n\nint dp[310][210][210]; // i edges | j points in total | k points can reach 1\n\nmain()\n{\n\tios::sync_with_stdio(false);\n\t\n\tint N,M; cin>>N>>M;\n\tdp[0][1][1]=1;\n\tfor(int i=0;i<M;i++)\n\t{\n\t\tfor(int j=1;j<=N && j<=i+1;j++)\n\t\t{\n\t\t\tfor(int k=1;k<=j;k++)\n\t\t\t{\n\t\t\t\tif(dp[i][j][k]==0) continue;\n\t\t\t\tdp[i+1][j+1][k]+=dp[i][j][k]*(N-j)%mod;dp[i+1][j+1][k]%=mod; // nxt=white->grey\n\t\t\t\tdp[i+1][j][k]+=dp[i][j][k]*(j-k)%mod;dp[i+1][j][k]%=mod; // nxt=grey\n\t\t\t\tdp[i+1][j][j]+=dp[i][j][k]*k%mod;dp[i+1][j][j]%=mod; // nxt=black all grey->black\n\t\t\t}\n\t\t}\n\t}\n\tcout<<dp[M][N][N]<<endl;\n\t\n\treturn 0;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <sstream>\n#include <string>\n#define _repargs(_1,_2,_3,name,...) name\n#define _rep(i,n) repi(i,0,n)\n#define repi(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define rep(...) _repargs(__VA_ARGS__,repi,_rep,)(__VA_ARGS__)\n#define all(x) (x).begin(),(x).end()\n#define mod 1000000007\n#define inf 2000000007\n#define mp make_pair\n#define pb push_back\ntypedef long long ll;\nusing namespace std;\ntemplate <typename T>\ninline void output(T a, int p = 0) {\n    if(p) cout << fixed << setprecision(p)  << a << \"\\n\";\n    else cout << a << \"\\n\";\n}\n// end of template\n\n// i日目, 訪れた頂点数j, 頂点1に戻れる頂点数k\nll dp[301][302][301];\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n    // source code\n    int N, M;\n    cin >> N >> M;\n    dp[0][1][1] = 1;\n    rep(i, M) rep(j, N + 1) rep(k, N + 1) {\n        (dp[i + 1][j + 1][k] += dp[i][j][k] * (N - j)) %= mod;\n        if(j >= k) (dp[i + 1][j][k] += dp[i][j][k] * (j - k)) %= mod;\n        (dp[i + 1][j][j] += dp[i][j][k] * k) %= mod;\n    }\n    \n    output(dp[M][N][N]);\n    \n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long MOD = 1000000007;\nlong long dp[301][301][301] = {};\n\nvoid add(long long &a, long long b) {\n    a = (a + b) % MOD;\n}\n\nint main() {\n    int N, M;\n    cin >> N >> M;\n\n    dp[0][1][1] = 1;\n    for(int n=0; n<M; ++n) {\n        for(int x=1; x<=N; ++x) {\n            for(int y=1; y<=N; ++y) {\n                if(x < N) add(dp[n + 1][x + 1][y], dp[n][x][y] * (N - x));\n                add(dp[n + 1][x][y], dp[n][x][y] * (x - y));\n                add(dp[n + 1][x][x], dp[n][x][y] * y);\n            }\n        }\n    }\n    cout << dp[M][N][N] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define SZ(X) ((int)(X).size())\n#define ALL(X) (X).begin(), (X).end()\n#define REP(I, N) for (int I = 0; I < (N); ++I)\n#define REPP(I, A, B) for (int I = (A); I < (B); ++I)\n#define RI(X) scanf(\"%d\", &(X))\n#define RII(X, Y) scanf(\"%d%d\", &(X), &(Y))\n#define RIII(X, Y, Z) scanf(\"%d%d%d\", &(X), &(Y), &(Z))\n#define DRI(X) int (X); scanf(\"%d\", &X)\n#define DRII(X, Y) int X, Y; scanf(\"%d%d\", &X, &Y)\n#define DRIII(X, Y, Z) int X, Y, Z; scanf(\"%d%d%d\", &X, &Y, &Z)\n#define RS(X) scanf(\"%s\", (X))\n#define CASET int ___T, case_n = 1; scanf(\"%d \", &___T); while (___T-- > 0)\n#define MP make_pair\n#define PB push_back\n#define MS0(X) memset((X), 0, sizeof((X)))\n#define MS1(X) memset((X), -1, sizeof((X)))\n#define LEN(X) strlen(X)\n#define PII pair<int,int>\n#define VI vector<int>\n#define VPII vector<pair<int,int> >\n#define PLL pair<long long,long long>\n#define VPLL vector<pair<long long,long long> >\n#define F first\n#define S second\ntypedef long long LL;\nusing namespace std;\nconst int MOD = 1e9+7;\nLL dp[301][301][301];\nvoid ADD(LL& x,LL v){x=(x+v)%MOD;}\nint main(){\n    DRII(N,M);\n    if(M<N)return 0*puts(\"0\");\n    dp[0][0][0]=1;\n    REP(i,M){\n        REP(j,N){\n            for(int k=0;j+k<N;k++){\n                if(dp[i][j][k]==0)continue;\n                ADD(dp[i+1][j][k],dp[i][j][k]*k);\n                ADD(dp[i+1][j][k+1],dp[i][j][k]*(N-1-j-k));\n                ADD(dp[i+1][j+k][0],dp[i][j][k]*(j+1));\n            }\n        }\n    }\n    return 0*printf(\"%lld\\n\",dp[M][N-1][0]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n#define ALL(c) (c).begin(), (c).end()\n\ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<VI> VVI;\ntypedef vector<VL> VVL;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\n\nconst ll mod = 1e9 + 7;\nll dp[611][611][611];\n\nint main(void){\n    int n, m;\n    cin >> n >> m;\n    dp[0][1][0] = 1;\n    REP(i,m) REP(j,n+1) REP(k,n+1){\n        dp[i+1][j][k] = (dp[i+1][j][k] + k * dp[i][j][k]) % mod;\n        dp[i+1][j+k][0] = (dp[i+1][j+k][0] + j * dp[i][j][k]) % mod;\n        dp[i+1][j][k+1] = (dp[i+1][j][k+1] + (n - k - j) * dp[i][j][k]) % mod;\n    }\n\n    // FOR(i,1,m){\n    //     cout << i << endl;\n    //     REP(j,n+1){\n    //         REP(k,n+1) cout << dp[i][j][k] << \" \";\n    //         cout << endl;\n    //     }\n    //     cout << endl;\n    // }\n    cout << dp[m][n][0] << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=a;i<b;i++)\n#define rrep(i,a,b) for(int i=a;i>=b;i--)\n#define fore(i,a) for(auto &i:a)\n#define all(x) (x).begin(),(x).end()\n#pragma GCC optimize (\"-O3\")\nusing namespace std; void _main(); int main() { cin.tie(0); ios::sync_with_stdio(false); _main(); }\ntypedef long long ll; const int inf = INT_MAX / 2; const ll infl = 1LL << 60;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a = b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a = b; return 1; } return 0; }\n//---------------------------------------------------------------------------------------------------\ntemplate<int MOD> struct ModInt {\n    static const int Mod = MOD; unsigned x; ModInt() : x(0) { }\n    ModInt(signed sig) { x = sig < 0 ? sig % MOD + MOD : sig % MOD; }\n    ModInt(signed long long sig) { x = sig < 0 ? sig % MOD + MOD : sig % MOD; }\n    int get() const { return (int)x; }\n    ModInt &operator+=(ModInt that) { if ((x += that.x) >= MOD) x -= MOD; return *this; }\n    ModInt &operator-=(ModInt that) { if ((x += MOD - that.x) >= MOD) x -= MOD; return *this; }\n    ModInt &operator*=(ModInt that) { x = (unsigned long long)x * that.x % MOD; return *this; }\n    ModInt &operator/=(ModInt that) { return *this *= that.inverse(); }\n    ModInt operator+(ModInt that) const { return ModInt(*this) += that; }\n    ModInt operator-(ModInt that) const { return ModInt(*this) -= that; }\n    ModInt operator*(ModInt that) const { return ModInt(*this) *= that; }\n    ModInt operator/(ModInt that) const { return MohydInt(*this) /= that; }\n    ModInt inverse() const { long long a = x, b = MOD, u = 1, v = 0;\n        while (b) { long long t = a / b; a -= t * b; std::swap(a, b); u -= t * v; std::swap(u, v); }\n        return ModInt(u); }\n    bool operator==(ModInt that) const { return x == that.x; }\n    bool operator!=(ModInt that) const { return x != that.x; }\n    ModInt operator-() const { ModInt t; t.x = x == 0 ? 0 : Mod - x; return t; }\n};\ntemplate<int MOD> ostream& operator<<(ostream& st, const ModInt<MOD> a) { st << a.get(); return st; };\ntemplate<int MOD> ModInt<MOD> operator^(ModInt<MOD> a, unsigned long long k) {\n    ModInt<MOD> r = 1; while (k) { if (k & 1) r *= a; a *= a; k >>= 1; } return r; }\ntypedef ModInt<1000000007> mint;\n/*---------------------------------------------------------------------------------------------------\n　　　　　　　　　　　 ∧＿∧  \n　　　　　 ∧＿∧ 　（´<_｀ ）　 Welcome to My Coding Space!\n　　　　 （ ´_ゝ`）　/　 ⌒i     \n　　　　／　　　＼　 　  |　|     \n　　　 /　　 /￣￣￣￣/　　|  \n　 ＿_(__ﾆつ/　    ＿/ .| .|＿＿＿＿  \n　 　　　＼/＿＿＿＿/　（u　⊃  \n---------------------------------------------------------------------------------------------------*/\n\n\n\n\n\n\nint N, M;\nmint dp[303][303][303];\n// dp[i][ok][ng]\n// i日目までで最初の強連結がok個あり、まだ使われていない町がng個ある時の組合せ\n//---------------------------------------------------------------------------------------------------\nvoid _main() {\n    cin >> N >> M;\n\n    dp[0][1][N - 1] = 1;\n    rep(i, 0, M) rep(ok, 1, N + 1) rep(ng, 0, N) if(ok + ng <= N) {\n        // 使われてない町の開拓\n        if (ng) dp[i + 1][ok][ng - 1] += dp[i][ok][ng] * ng;\n\n        // 全体を強連結にする\n        dp[i + 1][N - ng][ng] += dp[i][ok][ng] * ok;\n\n        // 全体を強連結にしない\n        dp[i + 1][ok][ng] += dp[i][ok][ng] * (N - ok - ng);\n    }\n\n    cout << dp[M][N][0] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int maxN = 305, mod = 1e9 + 7;\n\nint n, m;\nint f[maxN + 1][maxN + 1][maxN + 1];\n\ninline int ADD(int x, int y) { return x + y >= mod ? x + y - mod : x + y; }\n\nint main()\n{\n\tscanf(\"%d %d\", &n, &m);\n\n\tif(m < n) { puts(\"0\"); return 0; }\n\t\n\tf[0][1][1] = 1;\n\tfor(int i = 0; i < m; i++)\n\t\tfor(int j = 1; j <= n && j <= i + 1; j++)\n\t\t\tfor(int k = 1; k <= j; k++)\n\t\t\t{\n\t\t\t\tif(!f[i][j][k]) continue;\n\t\t\t\tf[i + 1][j][k] = ADD(f[i + 1][j][k], 1ll * f[i][j][k] * (j - k) % mod);\n\t\t\t\tf[i + 1][j + 1][k] = ADD(f[i + 1][j + 1][k], 1ll * f[i][j][k] * (n - j) % mod);\n\t\t\t\tf[i + 1][j][j] = ADD(f[i + 1][j][j], 1ll * f[i][j][k] * k % mod);\n\t\t\t}\n\t\n\tprintf(\"%d\", f[m][n][n]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include\"bits/stdc++.h\"\nusing namespace std;\n#define REP(k,m,n) for(int (k)=(m);(k)<(n);(k)++)\n#define rep(i,n) REP((i),0,(n))\nusing ll = long long;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\nusing tp3 = tuple<int, int, int>;\nusing Mat = vector<vector<ll>>;\nconstexpr int INF = 1 << 28;\nconstexpr ll INFL = 1ll << 60;\nconstexpr int dh[4] = { 0,1,0,-1 };\nconstexpr int dw[4] = { -1,0,1,0 };\nbool isin(const int H, const int W, const int h, const int w) {\n    return 0 <= h && h < H && 0 <= w && w < W;\n}\nstruct ModInt {\n    static const ll MOD = 1000000007;\n\n    // constructors etc\n    ModInt() :num(1ll) {}\n    ModInt(ll num_) :num(num_%MOD) {}\n    ModInt(const ModInt& modint) :num(modint.num%MOD) {}\n    ll get()const { return num; }\n\n    // operator etc\n    // operator ll() const { return num; }\n    // ll operator*() { return num; }\n    ModInt& operator+=(const ModInt& r) { (num += r.num) %= MOD; return *this; }\n    ModInt& operator-=(const ModInt& r) { (num += -r.num + MOD) %= MOD; return *this; }\n    ModInt& operator*=(const ModInt& r) { (num *= r.num) %= MOD; return *this; }\n    ModInt& operator/=(const ModInt& r) { (num *= r.inv().num) %= MOD; return *this; }\n    ModInt pow(const ModInt& r)const {\n        ll res = 1;\n        ll x = num;\n        ll n = r.num;\n        while (n > 0) {\n            if (n & 1)res = (res*x) % MOD;\n            x = (x*x) % MOD;\n            n >>= 1;\n        }\n        return res;\n    }\n    ModInt inv()const { return this->pow(MOD - 2); }\n\n    ModInt operator+(const ModInt& r)const { return ModInt(*this) += r; }\n    ModInt operator-(const ModInt& r)const { return ModInt(*this) -= r; }\n    ModInt operator*(const ModInt& r)const { return ModInt(*this) *= r; }\n    ModInt operator/(const ModInt& r)const { return ModInt(*this) /= r; }\n    ModInt operator+(const ll& r)const { return *this + ModInt(r); }\n    ModInt operator-(const ll& r)const { return *this - ModInt(r); }\n    ModInt operator*(const ll& r)const { return *this * ModInt(r); }\n    ModInt operator/(const ll& r)const { return *this / ModInt(r); }\n\nprivate:\n    ll num;\n};\nostream& operator<<(ostream& stream, const ModInt& val) { stream << val.get(); return stream; }\n\n// ============ template finished ============\n\nint main()\n{\n    constexpr ll MAX_N = 302;\n    ll N, M;\n    cin >> N >> M;\n    array<array<array<ModInt, MAX_N>, MAX_N>, MAX_N> dp;\n    rep(i, MAX_N)rep(j, MAX_N)rep(k, MAX_N)dp[i][j][k] = 0;\n    dp[0][0][0] = 1;\n    rep(alpha, MAX_N - 1)rep(beta, MAX_N - 1)rep(gamma, MAX_N - 1) if (beta <= gamma) {\n        auto D = dp[alpha][beta][gamma];\n        if (beta == gamma) {\n            dp[alpha + 1][beta][gamma] += D * (beta + 1);\n            dp[alpha + 1][beta][gamma + 1] += D;\n        }\n        else {\n            dp[alpha + 1][gamma][gamma] += D * (beta + 1);\n            dp[alpha + 1][beta][gamma] += D * (gamma - beta);\n            dp[alpha + 1][beta][gamma + 1] += D;\n        }\n    }\n    auto res = dp[M][N - 1][N - 1];\n    REP(i, 1, N)res *= i;\n    cout << res << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n\nusing namespace std;\n\nconst int MOD = 1000000007;\n\nint main(){\n\tint N, M;\n\tstatic long long dp[301][301][301];\n\twhile(cin >> N >> M){\n\t\tmemset(dp, 0, sizeof(dp));\n\t\tdp[0][1][0] = 1;\n\t\tfor(int day=0;day<M;day++){\n\t\t\tfor(int ok=0;ok<N;ok++){\n\t\t\t\tfor(int ng=0;ng<N;ng++){\n\t\t\t\t\tdp[day+1][ok][ng] += dp[day][ok][ng] * ng;\n\t\t\t\t\tdp[day+1][ok][ng] %= MOD;\n\t\t\t\t\tdp[day+1][ok+ng][0] += dp[day][ok][ng] * ok;\n\t\t\t\t\tdp[day+1][ok+ng][0] %= MOD;\n\t\t\t\t\tdp[day+1][ok][ng+1] += dp[day][ok][ng] * (N - ok - ng);\n\t\t\t\t\tdp[day+1][ok][ng+1] %= MOD;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdp[day+1][N][0] += dp[day][N][0] * N;\n\t\t\tdp[day+1][N][0] %= MOD;\n\t\t}\n\t\tcout << dp[M][N][0] << endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define VI vector<int>\nconst int MOD = 1e9 + 7;\n\nint main() {\n    int n, m; cin >> n >> m;\n\n    auto add = [] (int &a, int b) {\n        a += b;\n        if(a >= MOD)\n            a -= MOD;\n    };\n    \n    int dp[2][305][305];\n    memset(dp, 0, sizeof(dp));\n    \n    dp[0][0][n] = 1;\n\n    for(int i = 0; i < m; ++i) {\n        int par = i % 2;\n        memset(dp[1 - par], 0, sizeof(dp[1 - par]));\n        for(int j = 0; j <= min(i, n - 1); ++j)\n            for(int k = 1; k <= n; ++k) {\n                //cerr << i << \" \" << j << \" \" << k << \" \" << dp[par][j][k] << \"\\n\";\n                add(dp[1 - par][j + 1][min(j + 1, k)], dp[par][j][k]);\n                add(dp[1 - par][j][n], 1LL * dp[par][j][k] * min(k, j + 1) % MOD);\n                add(dp[1 - par][j][k], 1LL * dp[par][j][k] * max(0, (j + 1 - k)) % MOD);\n            }\n    }\n\n    int ans = dp[m % 2][n - 1][n];\n\n    for(int i = 1; i <= n - 1; ++i)\n        ans = 1LL * ans * i % MOD;\n\n    cout << ans << \"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<unordered_set>\n#include<unordered_map>\nusing namespace std;\ntypedef long long ll;\n#define mod 1000000007\n#define mad(a,b) a=(a+b)%mod;\n#define N 310\nll f[N][N][N];\nint main(){\n  ll n,m; cin>>n>>m;\n  for(int i=0;i<N;i++)for(int j=0;j<N;j++)for(int k=0;k<N;k++)f[i][j][k]=0;\n  f[0][1][1]=1;\n  for(int len=0;len<m;len++){\n      for(int a=1;a<=n;a++)for(int b=1;b<=n;b++){\n\t  ll ff=f[len][a][b];\n\t  if(a==b){\n\t      mad(f[len+1][a][a],ff*a);\n\t      mad(f[len+1][a][a+1],ff);\n\t  }\n\t  else{\n\t      mad(f[len+1][a][b],ff*(b-a));\n\t      mad(f[len+1][b][b],ff*a);\n\t      mad(f[len+1][a][b+1],ff);\n\t  }\n      }\n  }\n  ll ans=1;\n  for(ll i=1;i<n;i++)ans=ans*i%mod;\n  cout<<ans*f[m][n][n]%mod<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(), (x).end()\n\ntypedef long long ll;\ntypedef long double ld;\n\nconst int INF = 1e9;\nconst ld EPS = 1e-8;\nconst ll MOD = 1e9 + 7;\n\nint main(){\n  int N, M;\n  cin >> N >> M;\n  vector<vector<vector<ll>>> dp(M + 1, vector<vector<ll>> (N + 1, vector<ll> (N + 1, 0)));\n  dp[0][1][1] = 1;\n  REP(i,M)REP(j,N + 1)REP(k,N + 1) {\n    if(j + 1 <= N) {\n      dp[i + 1][j + 1][k] = (dp[i + 1][j + 1][k] + dp[i][j][k] * (N - j) % MOD) % MOD;\n    }\n    dp[i + 1][j][k] = (dp[i + 1][j][k] + dp[i][j][k] * (j - k) % MOD) % MOD;\n    dp[i + 1][j][j] = (dp[i + 1][j][j] + dp[i][j][k] * k % MOD) % MOD;\n  }\n  cout << dp[M][N][N] << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <cmath>\n#include <iomanip>\nusing namespace std;\n\ntypedef pair<int, int> P;\n#define rep(i, n) for (int i=0; i<(n); i++)\n#define all(c) (c).begin(), (c).end()\n#define uniq(c) c.erase(unique(all(c)), (c).end())\n#define _1 first\n#define _2 second\n#define pb push_back\n#define INF 1145141919\n#define MOD 1000000007\ninline void add(int &x, int y) {\n  x += y;\n  if (x >= MOD) x -= MOD;\n}\n\nint N, M;\nint dp[301][301][301];\n\nsigned main() {\n  ios::sync_with_stdio(false); cin.tie(0);\n  cin >> N >> M;\n\n  dp[0][1][1] = 1;\n  rep(i, M) {\n    rep(j, N+1) {\n      rep(k, j+1) {\n        if (j < N) {\n          add(dp[i+1][j+1][k], (1LL*(N-j)*dp[i][j][k]) % MOD);\n        }\n        add(dp[i+1][j][j], (1LL*  k  *dp[i][j][k]) % MOD);\n        add(dp[i+1][j][k], (1LL*(j-k)*dp[i][j][k]) % MOD);\n      }\n    }\n  }\n  cout << dp[M][N][N] << \"\\n\";\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\ntypedef long long ll;\n\nll N, M;\nll MOD = 1000000007;\nll dp[300 + 10][300 + 10][300 + 10];\n//dp[i][j][k] := i回目の移動(1-idx)を終えて、まだ連結されてない町がj個あり、k個の長さから成る最初の連結成分を持つ場合の数\n\nint main() {\n\n\tcin >> N >> M;\n\t\n\tdp[0][N - 1][1] = 1;\n\tfor (int i = 0; i <= M; i++) {\n\t\tfor (ll j = 0; j <= N - 1; j++) {\n\t\t\tfor (ll k = 1; k <= N; k++) {\n\t\t\t\tif (j - 1 >= 0) {\n\t\t\t\t\tdp[i + 1][j - 1][k] += (dp[i][j][k] * j % MOD);\n\t\t\t\t\tdp[i + 1][j - 1][k] %= MOD;\n\t\t\t\t}\n\t\t\t\tif (N - j - k >= 0) {\n\t\t\t\t\tdp[i + 1][j][k] += dp[i][j][k] * (N - j - k) % MOD;\n\t\t\t\t\tdp[i + 1][j][k] %= MOD;\n\t\t\t\t}\n\t\t\t\tdp[i + 1][j][N - j] += (dp[i][j][k] * k % MOD);\n\t\t\t\tdp[i + 1][j][N - j] %= MOD;\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << dp[M][0][N] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#define repeat(i,n) for (int i = 0; (i) < int(n); ++(i))\ntypedef long long ll;\nusing namespace std;\ntemplate <typename X, typename T> auto vectors(X x, T a) { return vector<T>(x, a); }\ntemplate <typename X, typename Y, typename Z, typename... Zs> auto vectors(X x, Y y, Z z, Zs... zs) { auto cont = vectors(y, z, zs...); return vector<decltype(cont)>(x, cont); }\nconst int mod = 1e9+7;\nint main() {\n    int n, m; cin >> n >> m;\n    auto dp = vectors(m+1, n+1, n+1, ll());\n    dp[0][1][0] = 1;\n    repeat (i,m) {\n        repeat (j,n+1) {\n            repeat (k,n+1) if (j+k <= n) {\n                dp[i+1][j][k] %= mod;\n                dp[i+1][j+k][0] += dp[i][j][k] * j % mod;\n                dp[i+1][j][k]   += dp[i][j][k] * k % mod;\n  if (k+1 <= n) dp[i+1][j][k+1] += dp[i][j][k] * (n-j-k) % mod;\n            }\n        }\n    }\n    cout << dp[m][n][0] % mod << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// #include {{{\n#include <iostream>\n#include <cassert>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <ctime>\n#include <queue>\n#include <set>\n#include <map>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <vector>\n#include <complex>\n#include <algorithm>\nusing namespace std;\n// }}}\n// #define {{{\ntypedef long long ll;\ntypedef double db;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\n#define de(x) cout << #x << \"=\" << x << endl\n#define rep(i,a,b) for(int i=a;i<(b);++i)\n#define per(i,a,b) for(int i=(b)-1;i>=(a);--i)\n#define all(x) (x).begin(),(x).end()\n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\n// }}}\n\nconst int N = 303 , P = 1e9 + 7;\ninline void pp(int &x,int d) {if((x+=d)>=P)x-=P;}\ninline int mul(int a,int b) {return ll(a)*b%P;}\nint f[N][N][N];\nint n , m;\n\nint main(){\n  cin >> n >> m;\n  f[0][1][1] = 1;\n  rep(i,0,m) {\n    for(int j=1;j<=n&&j<=i+1;++j)\n      for(int k=1;k<=j;++k) if(f[i][j][k]){\n        pp(f[i+1][j][k] , mul(f[i][j][k] , j - k));\n        pp(f[i+1][j][j] , mul(f[i][j][k] , k));\n        pp(f[i+1][j+1][k] , mul(f[i][j][k] , n - j));\n      }\n  }\n  cout << f[m][n][n] << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define be(v) (v).begin(),(v).end()\n#define pb(q) push_back(q)\ntypedef long long ll;\nusing namespace std;\nconst ll mod=1000000007, INF=mod*mod*3LL;\n#define doublecout(a) cout<<fixed<<setprecision(10)<<a<<endl;\n\nint main() {\n    cin.tie(0);\n    cout.tie(0);\n    ios::sync_with_stdio(false);\n    ll n, m;\n    cin >> n >> m;\n    vector<vector<vector<ll> > > dp(m+1, vector<vector<ll> > (n+1, vector<ll> (n+1, 0)));\n    dp[0][1][1] = 1;\n    for(ll i=0;i<m;i++){\n    \tfor(ll j=0;j<=n;j++){\n    \t\tfor(ll k=0;k<=n;k++){\n    \t\t\tll num = dp[i][j][k];\n    \t\t\tif(j != n) (dp[i+1][j+1][k] += (num * (n - j)) % mod) %= mod;\n    \t\t\t(dp[i+1][j][k] += num * (j - k)) %= mod;\n    \t\t\t(dp[i+1][j][j] += num * k) %= mod;\n    \t\t}\n    \t}\n    }\n    cout << dp[m][n][n] << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// https://cf16-final-open.contest.atcoder.jp/tasks/codefestival_2016_final_f?lang=en\n#include <bits/stdc++.h>\nusing namespace std;\n#pragma GCC optimize(\"Ofast\")\ntypedef vector<int> vi;\ntypedef long long lint;\ntypedef unsigned int uint;\ntypedef pair<int, int> pii;\ntypedef pair<lint, lint> pll;\ntypedef unsigned long long ulint;\n#define endl '\\n'\n#define fst first\n#define sed second\n#define pb push_back\n#define mp make_pair\n#define rint register int\n#define SZ(x) (int((x).size()))\n#define all(x) (x).begin(), (x).end()\n#define reveal(x) cerr << #x << \" = \" << (x) << endl\n#define rep(it, f, e) for (rint it = (f); it <= (e); ++it)\n#define per(it, f, e) for (rint it = (f); it >= (e); --it)\n#define repe(it, x) for (auto it = (x).begin(); it != (x).end(); ++it)\nconst int MOD = 1e9 + 7;\nint dp[305][305][305];\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(NULL), cout.tie(NULL);\n\tint n, m;\n\tcin >> n >> m;\n\tdp[0][1][1] = 1;\n\tauto chkMOD = [&] (int & x) {\n\t\tx >= MOD && (x -= MOD);\n\t};\n\trep (i, 0, m - 1) rep (j, 1, min(n, i + 1)) {\n\t\trep (k, 1, j) if (dp[i][j][k] != 0) {\n\t\t\tchkMOD(dp[i + 1][j + 1][k] += dp[i][j][k] * (0ll + n - j) % MOD);\n\t\t\tchkMOD(dp[i + 1][j][k] += dp[i][j][k] * (0ll + j - k) % MOD);\n\t\t\tchkMOD(dp[i + 1][j][j] += dp[i][j][k] * (0ll + k) % MOD);\n\t\t}\n\t}\n\tcout << dp[m][n][n] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\n\nconst int N=305;\nconst int mod=1000000007;\n\nint n,m;\nint dp[2][N][N];\n\nint main(){\n\tint i,j,k,now,pre,w;\n\tscanf(\"%d%d\",&n,&m);\n\tif (m<n){\n\t\tprintf(\"0\\n\");\n\t\treturn 0;\n\t}\n\tnow=0; pre=1;\n\tdp[0][1][1]=1;\n\tfor (i=1;i<=m;i++){\n\t\tnow^=1; pre^=1;\n\t\tfor (j=1;j<=i;j++)\n\t\t\tfor (k=1;k<=i&&k<=j;k++){\n\t\t\t\tif (!dp[pre][j][k]) continue;\n\t\t\t\tw=dp[pre][j][k];\n\t\t\t\t(dp[now][j+1][k]+=1ll*w*(n-j)%mod)%=mod;\n\t\t\t\t(dp[now][j][k]+=1ll*w*(j-k)%mod)%=mod;\n\t\t\t\t(dp[now][j][j]+=1ll*w*k%mod)%=mod;\n\t\t\t}\n\t\tmemset(dp[pre],0,sizeof(dp[pre]));\n\t}\n\tprintf(\"%d\\n\",dp[now][n][n]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define mp make_pair\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<ll> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef pair<int,pii> pip;\ntypedef vector<pip>vip;\nconst double PI=acos(-1);\nconst double EPS=1e-8;\nconst int inf=1e8;\nint main(){\n\tint n,m;\n\tcin>>n>>m;\n\tif(n>m){\n\t\tcout<<0<<endl;\n\t\treturn 0;\n\t}\n\tvvi dp(n+1,vi(n+1));\n\tll MOD=1000000007;\n\tdp[1][1]=1;\n\trep(q,n){\n\t\tvvi ndp(n+1,vi(n+1));\n\t\tloop(i,1,n+1)loop(j,1,n+1){\n\t\t\tif(i!=n)(ndp[i+1][j]+=dp[i][j]*(n-i))%=MOD;\n\t\t\t(ndp[i][j]+=dp[i][j]*(i-j))%=MOD;\n\t\t\t(ndp[i][i]+=dp[i][j]*j)%=MOD;\n\t\t}\n\t\tdp=ndp;\n\t}\n\tcout<<dp[n][n]<<endl;\n}\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#pragma target(\"avx\")\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<ll, ll> P;\ntypedef vector<ll> V;\ntypedef unordered_map<ll, ll> U_MAP;\ntypedef priority_queue<ll> pq;\ntypedef priority_queue<ll, vector<ll>, greater<ll>> rpq;\nconstexpr ll INF = 1e9, MOD = 1e9 + 7, ohara = 1e6 + 10;\nconstexpr ll LINF = 1e18;\n\n#define rep(i, n) for (ll(i) = 0; (i) < (int)(n); (i)++)\n#define rrep(i, a, b) for (ll i = (a); i < (b); i++)\n#define rrrep(i, a, b) for (ll i = (a); i >= (b); i--)\n#define all(v) (v).begin(), (v).end()\n#define Size(n) (n).size()\n#define Cout(x) cout << (x) << endl\n#define doublecout(a) cout << fixed << setprecision(15) << a << endl;\n#define fi first\n#define se second\n#define m_p make_pair\n#define p_b push_back\nstring to_string(string s) { return '\"' + s + '\"'; }\nstring to_string(const char* s) { return to_string((string)s); }\nstring to_string(bool b) { return (b ? \"true\" : \"false\"); }\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p) {\n  return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\";\n}\ntemplate <typename A>\nstring to_string(A v) {\n  bool first = true;\n  string res = \"{\";\n  for (const auto& x : v) {\n    if (!first) {\n      res += \", \";\n    }\n    first = false;\n    res += to_string(x);\n  }\n  res += \"}\";\n  return res;\n}\nvoid debug_out() { cerr << endl; }\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << \" \" << to_string(H);\n  debug_out(T...);\n}\n#define debug(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n\n//------ Believe yourself as a genius!!!!!! ------\n\nint dy[] = {1, 0, -1, 0};\nint dx[] = {0, 1, 0, -1};\n// int dy[]={-1,0,1,-1,1,-1,0,1};int dx[]={-1,-1,-1,0,0,1,1,1};\nstring alph(\"abcdefghijklmnopqrstuvwxyz\"), s;\nll n, cnt, ans, a, b, c, d, tmp, m, h, w, x, y, sum, k, q;\nll dp[400][400][400];\n\nint main(void) {\n  cin.tie(0);\n  cout.tie(0);\n  ios::sync_with_stdio(false);\n\n  cin >> n >> m;\n  dp[0][1][1] = 1;\n  rrep(i, 1, m + 1) {\n    rrep(j, 1, n + 1) {\n      rrep(k, 1, n + 1) {\n        (dp[i][j][k] += dp[i - 1][j - 1][k] * (n - j + 1)) %= MOD;\n        if (j - k >= 0) (dp[i][j][k] += dp[i - 1][j][k] * (j - k)) %= MOD;\n        (dp[i][j][j] += dp[i - 1][j][k] * k) %= MOD;\n      }\n    }\n  }\n  ans = dp[m][n][n];\n  Cout(ans);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*&@@@@@@@@&&&&&&&&&&&@@@@@@@@&%$$!'''..                                   .!&&&&&&&$$$$$$$$$$$%%%%%%%%%%%%%%%%%%%%%%%|\n@@@@@@@@@@@@@@@@&&&&&@@@@&&&&&%%|:`.                                          `|$$$$$$$%%%%%%%%%%||||||||||||||||||||||\n@@@@@@@@@@@@@@@@@@&@@@&&$&&$!;:.                                                .;%%%%%%%%||||||||||!!!!|||||||||||||||\n@@@@@@@@@@@@@@@@@@@&&&$%$&$%;.                                                    .:|||||||||!!!!!!!!!!!!!!!|||||||||||\n@@@@@@@@@@@@@@&&&&&$$$$$$|'                                                          '||||||!!!!!!!!!!!!!!!!!!|||||||||\n@@@@@@@@&&&&&&&&&&&$%|%!`        ....                                                 .'||||!!!!!!!!!!!!!!!!!!|||||||||\n&&&&&&&&&&&&&$$$$$$$%!'         ...                                                     .;|||!!!!!!!!!!!!!!!!!!!|||||||\n&&&&&&$$$$$$$$$$$$%|:.         ...                                                      ..'!|||||||||||||||||||||||||||\n$$$$$$$$$$$$%%%%%|;`          ....            ......                                     ..`;||||||||||||||||||||||||||\n%%%%%%%%%%%%%%%|!:..         ..`..    ..........   .                               ....     `;|||||||||||||||||||||||||\n%%||%||%|%%%%||!:`.          .``..        ..........                          .        ....  `;||||||||||||||||||||||||\n||||||||||||%|!;'.          ..``...      .....  ........                      ......    ..... .:|||||||||||||||||||||||\n|||||||||||||!;:`        ....```..    ..............                          .  ...............:||||||||||||||||||||||\n||||||||||%||!:'.      .   ..`'`.......................  .    .....              ......... ......:|%|||||||||||||||||||\n|||||||||%||!;'.          ..````..........................               ....       ..............:|%%%||||||||||||||||\n||||||||%||!;:`. ..      ...`'''``...............................                       ........  `;%||||||||||||||||||\n||||||%%%||!;:..... .......``''''```..........................................  `:;;;'.   ........ `;%|||||||||||||||||\n|||||||||%|!:`.............`''''''''`````````````.................................````...  ........ `;|||||||||||||||||\n||||||||||!:`............``'::::::::'''``'''``````````.............    ........`....```...   ........'!||||||||||||||||\n||||||||||;`............``':;;;;!;;;::::'''::'''``....................     ...`'````````....   .......:||||||||||||||||\n|||||||||;`....     ...``':;;!!!!!!!!;;;:::::::::''`````.....................':::'``````'``..   ..  ...:|||||||||||||||\n|||||||!'..         ..``':;;!!!!!!!!!!!;;;;;;;:::::'''```````````....```````'::::''''''''''``..   .  ...:||||||||||||||\n|||||!:'`.          .`'':;;!!!!!!||!!!!!!!!!;;;;;;::::::'''''''''''''''`''''''':::'''''''::`....       ..:|||||||||||||\n|||!;;'..          .`''::;;!!!!!|||||||!!!!!!!!!!!!;;;;;;;;;;;;;;;;;;;;;;;:::;:::::'''';;;:'.   .    .   .:||||||||||||\n||;!;:'`            `'::;;;!!!!!||||||||!!!!!!!!!!!!!!!!!!!!!!!!!||||||!;;;::::;;;::'':;:::'.             .:||||||||||!\n|!!!:'`.            .'::;;;!!!!!!|||||||||!!!!!!!!|!!!!!!!!!!!|||||%%%%||!;;;::::::::::::;:`..             .:|||||||||!\n!!!;''`.            .'::;;;!!!!!!!!||||!!!!||||!!!!!!;;;!!!!!!||||%%%|||||!!;;:;;;;:'':::'.                  :||||||||!\n!|!:''`.             `'::;;;!!!!!!!!!!!!!!!!!!!;::'':;;!!!!!!!|||||||||||||!!;;;;;;;:::''`.                   '!||||||!\n!!!:''`.             .`':;;;!!!!!!!!!!!!!!;:''''':;;;;;;;;!!!!||||||||||||!!!;;;;;;;:::''`..                   `;|!!!|!\n!!!:'`.               .'::;;;;!!!!!!!!;:''``':;;;;;;;;;;;;;!!|||||||||||||!!!!!;;;;;;:::''`..                   .:|||!!\n||!:'`..               `'::;;;;;;!;;;;:''':;;;;;;;;;::'`';!!||||||||||||||!!!!!!!!!;;;:::'`..                     '!|||\n|!!:'`..                `:::::;;;;;;;;;;::;;;::::::''``';!!|||||||||||||||!!!!!!!!!!;;;;::'`.                      `;||\n||!;'.                   ....``'::;;;!!;;;;;::'''`...`:;!!!|||||||||||||||!!!!!!!!!!!;;;;::'`..                 .   .'!\n%||;'..  ..               .`''::::::;!!!!!!;;;::''`::;;!!!||||||||||||||||||||||||!!!!!;;;;::'`.                      '\n|%|!:`.                     `'':::'::;!||||!!!!!!;;;;!!!!!||||||||||||||||||||||||||!!!!!;;;;;:'`.                    .\n||%|;`                        `````..`;|||||||||||!!!!!!!!|||||||||||||||||||||%||||||!!!!!!!!;::'`..                 .\n%|%%|'.  ..                    .....`':!||||||||||||!!||||||||||!!!|||||||%%%%%%%||||||!!|||||!!;:''`.                .\n|||%|;.                         .`''::;;|||||||||||!!!!|||||!!!!!!!|||||||%%%%%%|%%%||||||||||||!!;;:'`..             .\n|||%|!'.  ..                     `':::;;!|%|||||||!!!!!!!!!!!!!!!!!||||||%%%%%%%%%%%%|||||%%%|||||!!!;;:'`.           .\n||||||;`   ..                     `::;;;!|||||||||||!!!!!!!!!!!!!!!!!||||%%%%%%%$$%%%|||||%%%%%||||||||!!;:'`.        .\n||||||!:`  ...                     .::;;;!|||||||||||!!!!!!!!!!!!!!!!!||||||%%%%$$%%%||||%%%%%%%%||||%%%||!;;:'.      .\n|||||||;`     ..                    .':;;!|||||||||!!!;!!!!!!!!!!!!!!!!||||||%%%%%%%%||||%%%%%%%%%%%%%%%%%%%||!;:''`. .\n!!!!!!||;`.    ..              .      `:;;;!!!!!!;::;;!!!!!!!!!!!!!!!!!!|||||||||%%%||||%%%%%%%%||||%%%%%%%%%%%||!;;;::\n!!!!!!!!!:.  .......                    `::;;;;;;:;;;!!!||!!!;;;;:;;;!!!!!|||!!!|||||||%%%%%%%|||!||||%%%$$$%%%|||!!!!!\n!!!!!!!!!!:.  .......          .          `:::;;;;;;!!!!!!;;;:::;;;;;;!!!!!!!!!!!||||||%%%%%%%%|||!!!||||||||||||||!!!!\n;;;;;;!!!!!:`..........       ...           .`:::::;;;;;:'``':;!!!!!!!!!!|!!!!!!!||||||||%%%%%%%%%|||!!!!!!!!!!!!!!!!!!\n;;;;;;;!!!!!:`..........        .              .`::::''''':;;!!!!!!!!!|||||!!!!!!!!!!!||||||%%%$$$$%%|||!!!!!!!!!!!!!!!\n;;;;;!!!!!!!!;`............. ..                   .`::::;;;;;;;;;;!!!||%%||!!!!!!!;;;!!!!||||%%$$&&&$$%%%|||||||||||||!\n!!!!!!!!!!!!!!!:`............        ..               .':::::::;;!!|||%%%||!!!!;;;;;;;;;!!!!||%%$&&&&&$$$$$%%%%||||||||\n!!!!!!!!!!|!!!!!:`...............     .      ....        `::;;;!!||||||%||!!!:''::::;;;;;!!!!!|%$&&&&&&&$$$$%%%||||||||\n!!!!!!|||||||||!;`............         ...........         .';;!!!!!!!!!!!!;::::::::;;;;;!!!!!!|%$&&&&&&&$$$$%%%|||||||\n||||||||||||||||;`........... ...      .......`...           .';;;;;;;!!:``'':::;;;;;;!!!!|||||||$&@@@&&&&$$$$%%%%|||||\n||||||||||||||||:``.............       .............            .`':'`.....`':::;;;!!!!||%%%%%%||$@@@@@@&&&$$$%%%%%%%%|\n|||||||||||||%|!:'`.............      . ............                   ....`':::;;!|%$$$$$$$$$%%|%&@##@@@&&$$$$$$$$%%$%\n||||||||||%%%%|;;;`......  ....      ... ....     ...        ..       .....`':::;;!%$&&&&&&&&&&$%$&@@@@@@&&$$$$$$$$$$$$\n||||||%%%%%%%%%!;:'`.....   ...             ..     .......    ..   .....```''::;;!|%$&&@@@@@@@&&$$&&@@@@@&$$%%%%%%%$$$$\n%%%%%%%%%%%%%%%!!;'`...........               ...... ..........   ..``````'':;!%%$$$&&@@@###@@@@&&&&&&&$$%%%|||||%$$$&$\n%%%%%%%%%%%%%%%|!;'.....`''`..      .          ...............    .``````':!%%||||%$&@@######@@@&&&$$%%%||||||||%$&&&&&\n%%%%%%%%%%%%%%%|!:`.......`...     ...````''``````````````.......``''':;|%%|!!!!!!|%$@########@@@&$%%||||||||%%%$&&&@@@\n|%%%%%%%%%%%%%%%|;'`.`'`. .....`''''''::::::::::::::::;;:::'::::::;;;;!%%||!!!!!!!||$&########@&$%%|||||||%%$$$&@@@@@#@\nCoded by Shinmurn Shar, a 21-yr-old beautiful girl.\n*/\n#include <bits/stdc++.h>\nusing namespace std;\n#define loop(i,n) for(int i=0;i<(n);i++)\n#define pool(i,n) for(int i=(n)-1;i>=0;i--)\n#define cont(i,n) for(int i=1;i<=(n);i++)\n#define tnoc(i,n) for(int i=(n);i>=1;i--)\n#define circ(i,a,b) for(int i=(a);i<=(b);i++)\n#define cric(i,a,b) for(int i=(b);i>=(a);i--)\n#define sub(i,a) for(int i=a;i;i=((i-1)&(a)))\n#define subs(i,a) for(int i=a;i>=0;i=(!i?-1:((i-1)&(a))))\n#define range(i,a,b,c) for(int i=(a);((c)>0?i<=(b):i>=(b));i+=(c))\n#define foreach(it,v) for(__typeof((v).begin()) it=(v).begin(),ed=(v).end();it!=ed;it++)\n#define ln '\\n'\n#define all(a) a.begin(),a.end()\n#define OVER(...) return printf(__VA_ARGS__),0;\n#define FILL0(a) memset(a,0,sizeof(a))\n#define FILL1(a) memset(a,-1,sizeof(a))\n#define FILLBIG(a) memset(a,0x3f,sizeof(a))\n#define Mask(a) (1ll<<(a))\n#define Maskx(a,x) ((a)<<(x))\n#define Full(a) ((1ll<<(a))-1)\n#define Bit(a,x) (((a)>>(x))&1)\n#define SZ(a) ((int)((a).size()))\n#define filei(a) freopen(a,\"r\",stdin);\n#define fileo(a) freopen(a,\"w\",stdout);\n#define fileio(a) freopen(a\".in\",\"r\",stdin);freopen(a\".out\",\"w\",stdout)\n#define eprintf(...) fprintf(stderr,__VA_ARGS__)\n#define y0 y0O0OO00OO0OO0OO0OOO00OO0OO0O0O000OO0\n#define y1 y1II11II11III11I1III11II111IIII1II1I1\n#define pub push_back\n#define pob pop_back\n#define puf push_front\n#define pof pop_front\n#define mak make_pair\n#define emb emplace_back\n#define emf emplace_front\n#define emp emplace\ntemplate<typename _T>\nusing pair2=pair<_T,_T>;\ntemplate<typename _T>\nusing pair3=pair<pair<_T,_T>,_T>;\ntemplate<typename _T>\nusing pair4=pair<pair<_T,_T>,pair<_T,_T> >;\n#define mak3(a,b,c) make_pair(make_pair(a,b),c)\n#define mak4(a,b,c,d) make_pair(make_pair(a,b),make_pair(c,d))\ntemplate<typename _T>\nusing priq=priority_queue<_T>;\ntemplate<typename _T>\nusing qrip=priority_queue<_T,vector<_T>,greater<_T> >;\n#define ST first\n#define ND second\n#define FST first.first\n#define SND first.second\n#define RD second\n#define SRD second.first\n#define FTH second.second\n#ifndef JTAKIOI\n#define cerr if(0)cout\n#define tctest(clas,meth,...)\n#else\n#define tctest(clas,meth,...) int main(){fio<<(new clas)->meth(__VA_ARGS__)<<ln;}\n#endif\ntypedef long long ll;\ntypedef long double lf;\ntypedef istringstream iss;\ntypedef stringstream sst;\nconst lf pi=acosl(-1);\nconst int Inf=0x3f3f3f3f;\nconst ll INF=0x3f3f3f3f3f3f3f3fll;\nunsigned Rand(){return rand()*32768+rand();}\nint rand(int a,int b){return Rand()%(b-a+1)+a;}\ntemplate<typename _T>\ninline _T chmin(_T &a,_T b){return a>b?(a=b):a;}\ntemplate<typename _T>\ninline _T chmax(_T &a,_T b){return a<b?(a=b):a;}\ntemplate<typename _T,int len>\nstruct BIT{\n\t_T dt[len];\n\tinline void add(int a,_T x){while(a<len){dt[a]+=x;a+=a&-a;}}\n\tinline void add(int l,int r,_T x){add(l,x);add(r+1,-x);}\n\tinline _T get(int a){_T ans=0;while(a){ans+=dt[a];a-=a&-a;}return ans;}\n\tinline _T get(int l,int r){return get(r)-get(l-1);}\n};\ntemplate<typename _T,int len>\nstruct segbit{\n\t_T dt[2][len];\n\tinline void add(int a,_T x){int b=a;while(a<len){dt[0][a]+=x;dt[1][a]+=x*b;a+=a&-a;}}\n\tinline void add(int l,int r,_T x){add(l,x);add(r+1,-x);}\n\tinline _T sum(int a){_T ans=0;int b=a;while(a){ans+=(b+1)*dt[0][a]-dt[1][a];a-=a&-a;}return ans;}\n\tinline _T sum(int l,int r){return sum(r)-sum(l-1);}\n};\nstruct fastIO{\n\tinline fastIO operator>>(int& num){\n\t\tnum=0;char c=getchar();while(c!='-'&&(c<'0'||c>'9'))c=getchar();\n\t\tbool foo=0;if(c=='-'){foo=1;c=getchar();}\n\t\twhile(c>='0'&&c<='9'){num=(num<<3)+(num<<1)+c-'0';c=getchar();}\n\t\tif(foo)num=-num;return *this;\n\t}\n\tinline fastIO operator>>(ll& num){\n\t\tnum=0;char c=getchar();while(c!='-'&&(c<'0'||c>'9'))c=getchar();\n\t\tbool foo=0;if(c=='-'){foo=1;c=getchar();}\n\t\twhile(c>='0'&&c<='9'){num=(num<<3)+(num<<1)+c-'0';c=getchar();}\n\t\tif(foo)num=-num;return *this;\n\t}\n\tinline fastIO operator>>(float& num){scanf(\"%f\",&num);return *this;}\n\tinline fastIO operator>>(double& num){scanf(\"%lf\",&num);return *this;}\n\tinline fastIO operator>>(long double& num){scanf(\"%Lf\",&num);return *this;}\n\tinline fastIO operator>>(char& num){num=getchar();while(num==' '||num=='\\n')num=getchar();return *this;}\n\tinline fastIO operator>>(char* num){\n\t\tint cnt=0;char c=getchar();while(c==' '||c=='\\n')c=getchar();\n\t\twhile(c!=' '&&c!='\\n'){num[cnt++]=c;c=getchar();}num[cnt]=0;return *this;\n\t}\n\tinline fastIO operator>>(string& num){cin>>num;return *this;}\n\tinline void printInt(const int& num){if(num<10){putchar(num+'0');return;}printInt(num/10);putchar((num%10)+'0');}\n\tinline void printll(const ll& num){if(num<10){putchar(num+'0');return;}printll(num/10);putchar((num%10)+'0');}\n\tinline fastIO operator<<(const int& num){if(num<0)putchar('-'),printInt(-num);else printInt(num);return *this;}\n\tinline fastIO operator<<(const ll& num){if(num<0)putchar('-'),printll(-num);else printll(num);return *this;}\n\tinline fastIO operator<<(const float& num){printf(\"%.10f\",num);return *this;}\n\tinline fastIO operator<<(const double& num){printf(\"%.16lf\",num);return *this;}\n\tinline fastIO operator<<(const long double& num){printf(\"%.20Lf\",num);return *this;}\n\tinline fastIO operator<<(const char& num){putchar(num);return *this;}\n\tinline fastIO operator<<(const char* num){for(int i=0;num[i];i++)putchar(num[i]);return *this;}\n\tinline fastIO operator<<(const string& num){cout<<num;return *this;}\n\ttemplate<typename _T> inline fastIO operator<<(const vector<_T> &vec){printf(\"{ \");foreach(i,vec)operator<<(*i)<<' ';printf(\"}\");return *this;}\n}fio;\nconst lf eps=1e-10;\nstruct point{\n\tlf x,y;\n\tlf ang;\n\tpoint(){}\n\tpoint(lf x,lf y):x(x),y(y){ang=atan2l(y,x);}\n\tinline point operator=(const point &pt){x=pt.x;y=pt.y;return *this;}\n\tinline point operator-()const{return point(-x,-y);}\n\tinline point operator+(const point &pt)const{return point(x+pt.x,y+pt.y);}\n\tinline point operator-(const point &pt)const{return point(x-pt.x,y-pt.y);}\n\tinline point operator*(const lf &a)const{return point(x*a,y*a);}\n\tinline point operator/(const lf &a)const{return point(x/a,y/a);}\n\tinline point operator^(const lf &ang)const{return point(x*cosl(ang)-y*sinl(ang),x*sinl(ang)+y*cosl(ang));}\n\tinline point operator+=(const point &pt){return *this=point(x+pt.x,y+pt.y);}\n\tinline point operator-=(const point &pt){return *this=point(x-pt.x,y-pt.y);}\n\tinline point operator*=(const lf &a){return *this=point(x*a,y*a);}\n\tinline point operator/=(const lf &a){return *this=point(x/a,y/a);}\n\tinline point operator^=(const lf &ang){return *this=point(x*cosl(ang)-y*sinl(ang),x*sinl(ang)+y*cosl(ang));}\n\tinline lf operator*(const point &pt)const{return x*pt.x+y*pt.y;}//dot\n\tinline lf operator%(const point &pt)const{return x*pt.y-y*pt.x;}//det\n\tinline lf length()const{return x*x+y*y;}\n\tinline lf size()const{return sqrtl(x*x+y*y);}\n\tinline lf operator^(const point &pt)const{return acosl(*this*pt)/length()/pt.length();}\n\tinline lf getangle(){return ang=atan2l(y,x);}\n\tinline lf angle()const{return atan2l(y,x);}\n\tinline bool operator<(const point &p)const{return ang<p.ang;}\n};\ninline bool xsmaller(const point &x,const point &y){return fabs(x.x-y.x)<1e-10?x.y<y.y:x.x<y.x;}\ninline bool ysmaller(const point &x,const point &y){return fabs(x.y-y.y)<1e-10?x.x<y.x:x.y<y.y;}\nstruct line{\n\tpoint a,b;\n\tline(){}\n\tline(point a,point b):a(a),b(b){}\n};\npoint intersect(line x,line y){\n\tpoint p1=x.a,v1=x.b-x.a;\n\tpoint p2=y.a,v2=y.b-y.a;\n\treturn p1+v1*(((p2-p1)%v2)/(v1%v2));\n}\nconst int jt=1000000007;\ninline int ksmii(int a,int b=jt-2){\n\tif(b<0){return ksmii(ksmii(a),-b);}\n\tif(!b){return 1;}\n\tint x=ksmii(a,b>>1);x=1ll*x*x%jt;\n\tif(b&1)x=1ll*x*a%jt;return x;\n}\ntemplate<int len>\nstruct bitmod{\n\tint dt[len];\n\tinline void add(int a,int x){while(a<len){dt[a]=(dt[a]+x)%jt;a+=a&-a;}}\n\tinline void add(int l,int r,int x){add(l,x%jt);add(r+1,jt-x%jt);}\n\tinline int get(int a){int ans=0;while(a){ans=(ans+dt[a])%jt;a-=a&-a;}return ans;}\n\tinline int get(int l,int r){return (get(r)-get(l-1)+jt)%jt;}\n};\ntemplate<int len>\nstruct DSU{\n\tint fa[len],sz[len];\n\tDSU(){loop(i,len)fa[i]=i,sz[i]=1;}\n\tvoid init(){loop(i,len)fa[i]=i,sz[i]=1;}\n\tint root(int x){return fa[x]==x?x:(fa[x]=root(fa[x]));}\n\tbool conn(int a,int b){a=root(a);b=root(b);if(a==b)return 0;fa[a]=b;sz[b]+=sz[a];return 1;}\n};\ntemplate<typename _T>\ninline _T qp(_T a,int b){\n\tif(!b){return 1;}\n\t_T x=qp(a,b>>1);x=x*x;\n\tif(b&1){x=x*a;}return x;\n}\ntemplate<int R,int C=R>\nstruct matrix{\n\tint mat[R][C];\n\tint* operator[](int x){\n\t\treturn mat[x];\n\t}\n\tmatrix(){loop(i,R)loop(j,C)mat[i][j]=0;}\n\tmatrix(int x){loop(i,R)loop(j,C)mat[i][j]=(i==j?x:0);}\n\tmatrix<R,C> operator+(const matrix<R,C> m){\n\t\tmatrix<R,C> ans;\n\t\tloop(i,R)loop(j,C)ans.mat[i][j]=(mat[i][j]+m.mat[i][j])%jt;\n\t\treturn ans;\n\t}\n\ttemplate<int D>\n\tmatrix<R,D> operator*(const matrix<C,D> m){\n\t\tmatrix<R,D> ans;\n\t\tloop(i,R)loop(j,C)loop(k,D)ans.mat[i][k]=(ans.mat[i][k]+((ll)mat[i][j])*m.mat[j][k])%jt;\n\t\treturn ans;\n\t}\n\tmatrix<R,C> operator+=(const matrix<R,C> m){\n\t\tmatrix<R,C> ans;\n\t\tloop(i,R)loop(j,C)ans.mat[i][j]=(mat[i][j]+m.mat[i][j])%jt;\n\t\treturn ans;\n\t}\n\tmatrix<R,C> operator-=(const matrix<R,C> m){\n\t\tmatrix<R,C> ans;\n\t\tloop(i,R)loop(j,C)ans.mat[i][j]=(mat[i][j]-m.mat[i][j]+jt)%jt;\n\t\treturn ans;\n\t}\n\tvoid debug(){\n\t\tloop(i,R){loop(j,C)cerr<<mat[i][j]<<' ';cerr<<endl;}cerr<<endl;\n\t}\n};\n\nint n,m;\nint dp[305][305][305];\n\nint main(){\n\tfio>>n>>m;\n\tdp[0][1][1]=1;\n\tloop(i,m){\n\t\tcont(j,min(n,i+1)){\n\t\t\tcont(k,j){\n\t\t\t\tdp[i+1][j+1][k]=(dp[i+1][j+1][k]+1ll*dp[i][j][k]*(n-j))%jt;\n\t\t\t\tdp[i+1][j][k]=(dp[i+1][j][k]+1ll*dp[i][j][k]*(j-k))%jt;\n\t\t\t\tdp[i+1][j][j]=(dp[i+1][j][j]+1ll*dp[i][j][k]*k)%jt;\n\t\t\t}\n\t\t}\n\t}\n\tfio<<dp[m][n][n]<<ln;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define fbo find_by_order\n#define ook order_of_key\n\ntypedef long long ll;\ntypedef pair<ll,ll> ii;\ntypedef vector<int> vi;\ntypedef long double ld; \ntypedef tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> pbds;\ntypedef set<int>::iterator sit;\ntypedef map<int,int>::iterator mit;\ntypedef vector<int>::iterator vit;\n\nconst int MOD = 1e9 + 7;\nint dp[301][301];\nint g[301][301];\nint c[301][301];\n\nvoid add(int &a, int b)\n{\n\ta=(a+b)%MOD;\n}\n\nint mult(int a, int b)\n{\n\treturn (a*1LL*b)%MOD;\n}\n\nint choose(int n, int r)\n{\n\tif(n < r) return 0;\n\tif(n==r) return 1;\n\tif(r==0) return 1;\n\tif(c[n][r]!=-1) return c[n][r];\n\tc[n][r] = (choose(n-1,r)+choose(n-1,r-1))%MOD;\n\treturn c[n][r];\n}\n\nint ans[100][150]={{609336735,570061272,328533215,94291398,614628026,435475842,553956708,20840744,140398218,995532010,592513842,211104638,861879042,356968976,573334577,900466245,851964743,896814959,481732742,544653678,819041244,551057401,210581731,1395152,576480713,263039276,519924434,566549013,153998879,488540821,829624224,523126771,39857325,200185374,483910238,577725318,20412827,172102892,695900218,637573890,141744391,48214784,99131394,200170973,734747858,49942634,653253768,513575996,384376695,408271733,953520686,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{955291242,78629294,480998314,751026726,866366829,12995943,523452931,591273628,562087833,59060667,702103916,506567079,338554938,647536076,576500155,863216581,19086739,483835199,179891348,160638401,639823631,100975271,43010040,184895655,654283843,161005286,903245104,37338218,847144255,143518335,345316877,3944143,709274083,68869392,672055432,838094470,801474027,396261632,586818996,373319760,739730261,643109956,604932917,104254538,268473306,397984106,561243628,948543628,677657074,140031361,188965425,398547256,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{95744927,861501799,720283057,986355947,204764475,373746655,291598494,220355034,388505578,989351883,55828543,97245593,105899171,759731238,207596672,516841418,774163072,245912767,848026752,893166643,603676394,659192983,876513917,856135173,492036282,756183154,3399045,753140503,997573445,418902712,459087012,331305879,818935305,76360986,409058706,928764872,676221169,656841725,192215833,651297943,350555560,880657560,890526948,773943970,642249127,285308327,395297394,849980560,91298495,501748650,3473025,322119990,57630815,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{277934862,438661332,160893954,795828108,530941852,127011316,28167372,504099401,385565485,23379991,566787415,566159636,605333362,208603728,956162517,803345568,796371329,752585807,711293798,262666256,646866645,748620505,973295580,58559395,617834090,98258770,101485483,446392402,282374359,546126906,447446454,944724317,48950325,301085125,802023854,499189657,562216757,180468494,567150424,572632369,694978273,451888927,408050722,912146745,353604973,407108761,530844867,893367029,558286329,39547819,448522101,637620413,908238717,590189020,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{337252768,690275872,66345986,417169166,709759128,623444383,476668670,736336016,558026851,292032976,420065843,631754119,808668169,800080391,671295930,180903128,820385345,190557613,140925663,843294639,571212578,136945590,252367815,808566598,675036277,853442957,354827947,251276974,144326227,822505114,12198164,790512210,312078411,164470151,31322226,272736032,755986838,946757742,890191730,625155047,674185169,838870528,196335815,266317034,450045090,699824350,370470053,395565349,924467845,176941461,854368045,837232587,99010215,306084393,658145528,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{706610574,227185202,663689831,508970764,612486326,779067380,206567609,578145179,501805271,608401313,504982051,815535001,297368372,497103182,338701918,431855392,366455456,438161206,512994721,531629772,969003163,429211567,911971345,665631813,322014829,83646569,772383930,462775023,401991803,406267492,654955751,936932629,530973745,558401581,274074326,559601160,856434872,195842466,242629260,380977436,500556519,152159687,784730951,303826044,784659440,760051635,213959110,2542805,929622694,592332091,272883400,141313174,438847384,499452371,565620594,523824726,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{168591080,218623560,579327394,339074060,387882950,517499910,30540077,24725076,653720770,100347105,452622693,773578719,121828472,115462583,731185243,929539435,302751564,619636772,822740687,789446913,719393451,287782598,782052156,796804968,901594012,759772604,661342968,976051256,710346411,731839044,772407655,417056603,175429215,193147127,798880449,787213135,76783198,500445745,824814697,783998614,986886618,525950443,343300023,976584663,667527220,772935335,317171129,206119038,412467902,701924947,1526387,496403895,338336217,112808218,275452388,25916933,239523901,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{180844016,338862328,821076646,518482102,929394242,719988883,912298981,355029338,142686399,374079583,361368565,180084256,932166580,764452304,42659234,684893361,145470907,528470104,631717555,345216060,151350292,694865598,958233480,472377190,316021386,383002070,617066029,408005101,54269595,712801908,219184088,527101292,403033887,822510354,114386163,100089228,915259707,149067320,20199557,780598250,396592396,168033986,442547663,418059457,223560618,728749363,184846878,529931719,933003155,547558910,657626594,153684632,583153915,789370857,618505588,676170950,359562108,275722639,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{995205284,764729089,404143960,845862371,290599499,38534170,249350510,988804701,401043565,337445777,870764589,220399270,6987286,225736060,327727975,134740,798270966,906207904,921468276,270387274,214385667,520726825,962817405,828663877,319961024,851461497,305104755,814840459,34890497,393911802,933432488,861271298,672304837,813591688,163616489,29839774,457394850,934174940,936024062,318976961,324075161,19325573,34002352,65498384,47131083,905715727,573861365,404161948,509648107,428090806,960255886,382923225,744233575,274059360,81213584,109923575,776582200,864170200,366482613,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{276524644,25131541,161362716,827154319,920169384,828720165,996137885,615721436,745373063,891590890,633124888,709828763,580621797,560325325,13745942,243363276,408904726,509220675,200046913,856771774,900416836,832112367,801703642,767834718,812028285,286283160,54074076,328145089,472855719,159399835,679292022,938348637,218283267,232272212,150845889,110818097,381979472,256685613,364832282,677097035,991777633,937350305,742853307,849821999,798015173,612923037,482218642,275953314,69891597,589118326,224092700,788908087,352164193,972300873,518284064,528257495,268508156,53743974,326906397,349917552,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{138015693,889766430,174601116,482861925,906998801,399556798,214820669,403308842,757313307,618968259,267970457,329974314,387258653,854393798,216936839,27201422,178869459,262188526,474384935,395708326,983689039,390370575,843763141,853649635,439897244,781229222,258345677,470306852,236151686,827474578,236453522,859756886,360746302,374034689,634981676,671758328,872311773,745684393,246620361,9687726,992828220,366481173,75472872,596766323,579374997,284199604,244033199,371086649,524475765,879452138,509731115,157645773,577465958,8587553,135604499,673304776,17693086,686921614,21555197,363935183,492579463,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{691065249,97137100,376327671,481927054,794030419,364344261,46018636,175934618,140782990,482585873,237307543,575348320,372461901,674051712,853709283,341692820,344831015,77370416,480920962,442374005,30180134,100744254,313191421,664214302,110922141,344827573,169989198,167407409,838901049,788749842,156359838,91498969,705853935,290166201,494809945,112246269,612598975,944416158,574636726,412308488,351339175,43241854,250986217,645078430,267854723,484218080,92245011,846141753,935939133,399268042,189537760,670044918,699537647,327085930,43557991,117208374,732092745,447971381,488774400,469129363,130118713,839571906,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{225982523,805096421,146796798,343324298,313415159,207421361,686788319,353653673,469302741,644224427,962526742,107751145,131917519,447769776,577587182,223423694,849326487,592506827,210863138,682325109,8873909,123040219,140333282,193255016,776068964,504709386,367869930,241585137,558549506,866026834,240197833,551831926,371674895,632143413,588559099,660868212,789746800,394991883,535769741,372660801,196982007,598079913,317369717,771513313,493919952,638225158,527809302,187439685,610143610,635859661,148588831,923657823,322580754,643985257,771691096,659738303,449771160,78624615,182084072,520128376,494692739,719479133,882327217,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{54335863,295861775,177513095,747853733,587898472,611084237,292830828,602451001,892469824,207818059,873645901,537502929,976003148,350313300,377389151,725819771,854767804,421462346,78127096,600926300,604571789,764970970,342904304,968486550,639798026,412281354,649639059,822113805,584293563,435881441,733060688,615058878,606218773,229012428,863743231,37443076,479608962,891043090,630092599,8658352,469231647,733554262,858510736,131979241,648148562,397851352,556132810,525948568,668065554,887738613,824837158,637531497,424931866,587475231,334833504,525562171,315940625,636903244,968966313,842194267,911195012,520547161,303227863,762467347,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{342764800,978280830,247670680,570062301,334863052,664406159,758718425,305611838,372543683,484364691,363600560,957045222,179569606,840305447,167750819,14396117,939107239,224013889,525779521,387724888,946543575,303090013,748739270,226865375,223056640,581427468,827985526,472236901,271401641,969071821,473540550,467915199,913343038,826170841,618687977,724225307,764515025,515562332,407481673,462440893,782428676,631835732,800929416,99450419,219647483,455000893,861971857,684405724,540464004,361204718,305290909,368177488,628512086,816350214,348776631,912996547,316847919,846464689,87320477,214874850,502225433,317620768,796044572,954378793,572191387,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{57904703,627861011,347519824,163117632,29015632,362251904,770183329,428589980,821553494,18383251,271215117,529447719,527230137,869024054,638507966,725990810,53480599,844305106,898151215,548922831,268285070,538489287,663333939,61318108,502902980,99819049,809805722,964935593,367007444,715355671,978451467,440066155,284226348,494416281,733455695,767107016,116473251,455004833,497219723,507945042,988490615,14823454,415971980,879619066,123102268,906924501,104452764,904410154,164256450,964673614,152025050,788534942,996710239,956304863,739208019,98760186,492959637,253592710,638820876,575593891,680978478,403874058,708080665,85935986,546678932,636267559,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{782275245,364940635,428137999,333155057,377573564,950687301,128683548,451059823,838945396,19928592,769011096,719820744,985003643,709050805,240475903,294158249,57049115,666843906,451387334,898689334,548735267,705795651,338364207,891643587,350017750,493391086,372172504,222272001,808476976,9351766,474248026,721104915,611268311,472422449,578959977,951622828,200773614,554136199,900963458,48461982,692305977,232815856,753547644,129243808,138491628,489386205,153089998,245486146,775863931,38845719,623417759,719067634,299367549,848432942,695095392,729559655,4197882,168530511,396215853,574937624,503600245,788800319,907833396,401234392,77480860,699024909,446474585,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{637895593,763071714,742635105,593182265,825527367,730777431,166404268,240668629,806744945,106657943,322611210,885452629,983586911,248565924,801617271,751898874,810257423,806858908,230270117,399487878,341372023,671595865,906286103,203545273,587892485,222057780,779201825,584137076,265040849,147333017,443618552,75971237,81394788,537309657,10396752,212352333,329521268,124596071,859118562,783271491,274149596,860826480,948770482,759369473,5512842,102455575,30911869,938554442,324604885,313126425,166504988,236344153,280510526,390096679,288223176,995224355,298747393,655482260,708390487,720784415,498642716,160550068,2699622,905545541,65269863,347077558,41585897,57390296,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{79178907,344963617,484382636,288614022,683562570,949416159,500423680,764806339,895724495,970068455,582781215,52646836,806007428,983091694,308915910,84903204,819979197,500094588,351427273,293840953,84745152,957536640,571513921,164503540,197502697,531681593,637127342,593884428,995064242,64132183,866361050,597790447,764091519,88251116,170853499,153700678,294687124,438141130,257482010,124632103,702896932,836737155,753779585,1532999,203230977,1821081,376539419,675179906,699430768,594921145,635555862,616647628,969525460,123996240,58277062,495705095,857475799,565991143,756514547,887107968,890967448,250141876,116374870,333881205,515527901,865520749,448156173,416408015,706004244,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{798821566,29379250,965805037,606604501,189864972,928717209,485298094,742767250,724535467,760012327,825935086,938831514,81423429,407744978,512550398,386883428,332419013,733730118,633922692,204779442,238364886,930388476,714043334,761925637,305367255,737509685,819965420,126368238,723431181,571559206,293279270,592623761,57705233,350400464,786374676,887168790,460665664,768912522,623800591,689543752,25064621,826661357,969734599,72890678,972330907,450097883,3493586,379060634,526321298,249543358,551258029,349797079,414275827,176784934,738038821,312694245,13210606,770618189,291972545,984973332,943736492,942856865,56817809,31071719,748565789,362183153,795782601,245826626,669309464,186343365,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{962989714,861663771,495200127,957534118,216824079,790009358,422843433,987327814,483221418,258498732,672737421,351432267,99301060,678571327,213621474,46217566,162729301,334175518,52078802,83975693,97608333,24666314,199976475,819508419,672058099,255534741,559820631,493300975,379058189,780076728,32469877,389335673,322428991,827542335,268510335,368425127,647786231,257403865,112200191,301265269,682945770,352011481,276809655,615418339,931281071,897348803,433974614,973386153,723564493,853619392,460361915,137894957,794458717,625905119,351849035,312809091,134131513,81309954,541280653,259557411,455649422,483843619,994752795,71217957,562318058,303207919,484311256,956344725,324735835,18802867,907469102,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{297782235,930496877,413877221,436788445,768155994,2147786,603842629,301016817,187813975,623631051,157689274,707046717,598663660,433718097,919230506,204680538,51939663,115079332,811768232,443534031,703059700,77655433,633325738,10157478,890322986,345315117,739652429,286402568,330210076,926679326,234439916,703549644,530875143,94832957,136199281,510994536,512232393,357314140,801938514,368837027,48364917,950124513,247893368,337821691,127290335,51238729,457721083,968996107,158752568,133821682,149903547,104222841,887600847,444569761,835767528,952663877,235054181,667910211,659183934,119715702,594380924,596981061,391854173,782780694,265898212,324773469,425892471,986714585,166355041,511030777,698100535,690058561,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{973187578,749797643,889232135,991995290,198877941,340153538,580868590,918070795,129841098,607490700,474859563,456925379,483842338,847259347,71953321,552529844,884850256,109044607,188006265,559714540,643211279,189511360,541380689,935062728,207043063,524325012,287161943,607008541,369015114,117558711,185754337,600052581,295165423,576127061,656274693,772873372,284183015,9295445,39577993,474920314,766572374,169323889,755039582,570306856,814391360,42914564,610691722,141140,690194472,217426568,289853924,646925596,341259502,357730064,767733831,815713741,346596293,348463719,972366680,943108020,602514519,732768801,594029722,274286168,892346538,299230269,71447197,561363420,656163789,590862573,834946654,845882268,824567387,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{927131331,843862789,192176154,891569174,798799444,919355684,235830120,638575832,584816865,222867848,295961497,217908512,134385026,589137023,434626145,389800279,856266565,243761289,145323627,508506156,95351251,93736939,248290683,970961415,352123138,871921035,275107729,533694588,547551150,279825822,340381427,533359134,185863568,797678096,702123039,841829823,841646049,75871489,107405050,401621253,521179622,107254041,95280411,641914139,841342360,404802392,465093881,409943159,734992094,962758296,785946622,224480882,955368727,937633119,449053140,940581105,60287573,919615478,750051150,783348978,605123118,370004892,586929468,655361990,53147351,176402357,819228790,816438593,491555437,480607200,906054952,155673069,911301095,491688358,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{943533826,625921851,875424917,733100498,232210642,478562907,240536727,304174967,528553267,757373280,231877199,597464411,115328732,306001029,591082710,508077116,555032006,359962839,352781756,649872447,302504219,83399841,669611409,904478827,936061317,815498779,908590899,724000415,878345785,54040938,420961009,787287941,856463728,2270768,357765211,429715107,386389169,209589451,242635426,526626523,850639333,700933587,859911356,311171401,420083396,731893861,452880920,200934642,791934757,821156947,131515081,436920988,336946541,669680771,20582127,941704198,507023825,814506673,406835342,712646369,947615389,561135172,780596044,499574240,969491445,407986294,15770305,972299295,378722939,532675424,490248961,284115033,224278152,954878318,368314949,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{747425349,201238847,729585900,87008233,192239967,933057828,362527463,567382391,807372025,367288783,506655102,3767435,305809996,133315948,370725240,183767270,438900717,515712700,839060399,519018803,823398229,821052602,378091583,493173284,204638691,234513857,819958698,266156442,662960870,438039216,120704246,850267358,75827775,265954605,222773649,255349226,241663076,234751108,633715733,160478535,310684292,957236144,812410816,246605094,350130069,328296209,651813028,164631386,481184888,121962969,751882625,538181684,566069238,433112333,928572722,10734989,636166313,583054388,234795642,955592371,889699689,835865466,934668705,756602477,215980217,901182736,874815678,913037353,300567999,261322021,314292773,412791313,808156351,848505976,944162610,623620986,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{805857754,869161185,786187895,81709952,711517961,186981680,664011580,148098890,789581370,990300945,136472942,689069581,254881326,180202712,627673298,854410779,802195980,493845169,586586697,119345428,116305436,130591829,1274997,478469024,203020900,129594996,101819531,313003336,120167815,40034534,750707623,211657976,974506057,326378532,11491725,688901578,56302600,415297249,281351395,869943514,679591702,568094756,638723629,652340949,267030197,503138221,53522406,568260916,129940323,357767549,54367826,61107704,46145151,585438552,434625998,164776623,530828373,513540421,583097935,906726718,744642806,686757525,563473358,380692935,577636562,44074537,175170192,858631854,801641003,87024395,685408310,639633935,334189484,911957414,226888376,65257972,147952642,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{190807330,163303648,93638299,539236489,284059910,704908334,325609222,478462063,720022366,368970682,760178621,134456673,364264179,878215643,895171038,79446536,86996679,799875759,673654524,855379611,524974857,213716260,289673587,831565414,145541269,957618625,464549523,728501288,46760975,733282757,6299350,431846873,37255452,920265493,616582384,267859314,677194642,933187707,44999179,124035448,560142994,786931782,380123758,725380392,373559623,886629153,658407202,695175274,615554701,369308053,855235962,767824408,398611283,670859773,275357267,462769813,107950413,715861638,807030038,829063232,742308023,980059654,898375752,845676180,452958467,349314925,481336318,292577626,819091539,450995859,460629656,873480502,113183235,36860153,906431633,177986675,851636257,800542796,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{75177469,683972067,77908591,276936544,503102670,446534075,705638104,239237989,437613075,167694022,141794663,916581040,46262225,256197058,175082538,974051952,38221954,347966553,511369699,200012784,994233811,739329925,514159468,539278433,553970662,649883524,836178624,447938501,493638648,486858221,21463181,11733379,320610668,882848037,804052868,387726126,714863158,299401234,284933808,923752501,314609858,380708080,25463908,86882015,295249539,701272766,576807580,119872501,514054728,493934324,586141382,203543666,379099245,889554500,326530191,79684686,441128912,831344418,352694246,466138264,50002185,900800556,473756002,813121071,337361951,950632676,319335778,496778074,552729627,295438391,99525467,361623486,448639671,503233427,989266852,126401067,716842421,416415959,639080913,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{979858857,719934558,744715451,726607859,509764010,970353948,949022645,36978528,661680869,565556762,674129561,777408475,926025281,534980860,817706025,347320038,492404989,331621336,758060393,500984377,718124801,215320815,859081272,798145450,195146044,335689561,62731149,136662370,805212187,684622790,326115705,371479114,733378106,212686693,917367991,569836798,773424420,559923315,893461114,120723557,365536663,881856202,768937023,313195033,187889890,806642182,938066145,978247784,245799304,36253697,373845721,241713265,797395138,921425128,793943068,398237881,711036978,983330900,700966260,84427681,763016376,984116865,455824786,265210817,254816210,356742394,129944863,965499843,524255983,159928978,648858856,553753158,104509132,451453586,473314480,191498610,167878264,992395800,41924035,374744508,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{426840911,904956383,211342909,213313396,78715455,136339836,107299916,342717971,115847353,49393131,909225,64000812,348737405,784585189,618495332,897919132,23824674,705125561,736571715,825543787,288083660,246235816,882044676,84202954,766863597,131774990,572097480,62780639,510355078,666344291,638601865,457403402,967627193,479464770,980416788,943801898,402329392,970467613,93411828,412670289,943239971,609125773,790747396,761100402,904058388,673748744,757756271,77848930,243720010,492177210,204154528,784499988,229137898,775909813,626875890,225848300,709924491,443682030,28010061,391059310,92971443,21363809,848400541,425262052,277189715,429732652,983500156,355120874,111131015,523841129,740846878,770373431,165128182,753371909,970439291,427051978,705724441,386302340,861422335,984334439,232115378,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{97666051,24720611,204134326,944055019,549062389,62421000,92232693,328896643,256684372,689223617,885486283,337679511,618642339,708740856,619216748,959135652,877412204,552040378,309149558,771932247,627077439,786284749,464803690,637097661,492242697,850585432,406231215,668209054,427476321,425332061,892747609,578128865,782306024,386546697,681733865,372793359,593803459,120876196,410021094,736990553,442456501,544102543,335033975,652196118,871913493,904482821,651094387,595086398,820841393,139732214,409458301,198856237,595132831,832575530,550772130,726846303,602425764,955465510,216393667,170139022,12873640,254394587,419420465,162600731,871121323,614860403,149313506,578586869,155650799,767692675,260510246,669025300,517486150,29233780,689547936,999190824,243617051,52330259,772658635,901928652,908598763,15960970,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{653179840,465065091,250196718,661468835,769109695,371826996,375730313,274483948,875064675,400215050,597471198,966960543,670753249,535199621,309062180,711618140,19413437,461197690,404880525,669773017,904451621,105258372,885135586,693712809,339045740,443492058,965426706,433160451,938395493,809531472,82099991,782995252,575462820,618929986,88010506,874919969,893551859,609171546,149053257,809778188,819613957,621646871,531418180,769023959,903412564,632056996,916574920,947097518,131095867,487941134,418328052,120791497,484197014,421358899,776212497,485655413,625558493,373846044,431294618,835399961,602252089,268564164,500198289,424188946,523618260,770578589,393169664,527462887,189423845,946340128,88953244,118427497,150886270,636852804,679535532,256748230,216936131,185125888,816802461,552398390,909811735,83243267,85345953,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{464140182,709749800,156442203,724410988,994684625,361898446,279597509,840249288,261049946,770136099,802566791,267954013,962564909,864100869,161517852,304709092,781203699,217425945,555962273,939912218,468400425,838746658,26013049,600646575,116735738,992224463,631009533,287696299,856605394,999782248,334560312,63121016,580108737,118765076,8646482,962797036,996985643,872355812,637975681,25603816,854972147,889918235,470273160,649082871,254042913,670061326,716181964,763117558,384017853,112576959,819968714,853420368,490497337,85486369,931621469,146507673,102921686,220327491,575156953,731222601,583334426,994919382,240720487,611518935,600063598,399464632,974667689,728994155,42595691,325967474,804354842,229138628,802212558,9116783,978695,794521595,490988007,701475709,989591173,834478325,468404660,782144034,346409986,718178816,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{999138144,778428944,673945000,439971957,399243114,26782128,994567564,445876914,399479574,137150504,381336400,560422772,649129108,185404242,163141036,265773209,811093653,742886486,826907230,265667558,528683856,265208544,83064036,11698513,426748658,22760055,395685002,848275696,69474300,889347824,438790377,562258841,664528115,169399784,262699049,864734682,980335727,762464794,858161393,393985459,234872204,186605939,659461912,530387040,647681588,515172255,420254237,635113380,506484182,785052466,599498331,801323593,200908907,706350690,934207287,8209871,901809565,486469091,97241519,739290287,954242117,989346797,178032607,333067202,409322863,194865995,768076181,155907072,158508436,936670533,482940354,991543680,101188088,143504090,685986045,39275954,266314317,873899064,151697576,510965140,627609180,465301046,323796550,598973628,399801527,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{711406143,503580218,148893379,793195100,633776445,146114955,655888513,316668709,869539905,837148311,487306626,328114239,327163243,53393053,107756910,150414213,326167131,912042774,8209339,640520389,135544254,789214540,136735463,21645969,214990186,809296462,496815352,465742846,872062472,531196797,500971070,684138524,744744639,755689212,619426955,36505761,19119044,740939249,236102331,727451021,205050423,322320010,354263288,185410915,541136326,753547688,773690242,62412181,684787479,526885438,270641865,762590472,336613486,634342867,438140680,332646951,478427524,298357599,134863643,296614992,654408891,907393367,713137513,896227685,559550311,96494373,873164739,589930135,375253403,711918895,567745775,315483536,871672833,44945249,704942083,649024669,181440368,295557116,524679716,986135317,485679288,800294228,343575141,713055620,39174022,987099080,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{174859337,593565353,252295242,623571264,39590646,184266010,572376749,652635475,733943738,272091148,192070202,695648441,287648722,405085479,688411156,627722100,198483553,748733389,827487465,472782422,522289324,833241107,223981415,666372180,908110107,735051004,707007423,356899211,930270941,910041283,229919509,76313706,306894052,472339716,802704143,79971427,743042835,168534341,446832495,162913105,846848268,910531197,450392921,244933106,819120353,705375187,382264128,191626385,994785221,23181859,939821473,752789512,828828245,293931458,638875380,47528642,942182338,623067706,367895192,910830238,70686687,496935849,159067356,21365172,342143167,784465462,530573981,748306298,30439972,416340137,143571000,186122919,635687630,8843019,227140284,968341570,50967162,225593609,902677873,192363637,439398663,349513799,25532407,287394933,16774474,469974841,174340679,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{266431250,999011694,385232564,816827243,868295973,492347332,644076062,816195959,910944110,605436070,761697139,832748161,704614643,357358204,992819184,562851209,816684178,369213374,97323764,375307191,144617314,290797468,340238531,815346668,317320937,272463067,130437606,170491510,897320147,171351292,358837449,691266757,291202540,588803389,58133027,491210677,169810148,964112283,231494963,641071722,909602493,843420871,617354940,864976837,306642897,49241351,549616370,734948564,454357571,336619340,38055932,396062285,786386768,120699291,152030279,993890780,523756958,838626251,485381423,237325046,395466815,831830459,391432549,238663726,478238435,110588245,396931269,618991497,203447164,299622863,842922395,715214186,251444606,496837191,726170294,421586642,356836494,423520021,677657378,375476891,271664763,166074115,739200917,89157722,964383956,795595886,541530207,983462707,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{407478983,733480847,836684130,453663985,895365860,694192870,663644877,5156670,665009127,631531801,219710864,620164370,575788853,700749853,939753934,473854816,490785117,375733848,814209137,469328543,722053628,856808196,51514015,731194028,493921861,963169708,707241493,608484572,623227962,350472577,628766161,424191098,404371180,748432122,277446352,307930946,822549161,573137833,444528211,508707073,398901700,811230441,606721264,406756255,409981869,691791211,619705683,531792205,354130267,520299550,616405594,927439908,27298814,369940342,65882623,452974904,878243258,895157505,523088411,65717532,940168309,106197661,999735630,570204909,804687196,66361929,640290741,839960681,233727062,768193608,199852665,294556833,177587069,550943263,915512458,889537633,126571395,947065359,108788334,664884045,19132633,388513119,669382177,683434703,421641002,802714654,53949957,261185359,974687414,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{800152876,578441407,794598173,668728322,1977222,460745356,982788721,309254635,227659020,218061500,491828539,152907566,231938962,70774435,903776616,796567469,211762854,533061162,903960602,292890255,133039348,233821294,55596730,171736522,854852617,14019604,67814060,507208276,675490096,616949684,627079525,89578148,455304679,958339799,289810989,345064369,728365111,364508645,10034671,856966641,8527997,783846812,322616570,763606170,188855220,866709333,189239430,937553015,142320760,775155786,835287876,631084030,28780914,225004495,920269713,52092350,813035751,611046162,794577461,429698695,726497525,141535942,10666784,933677105,329538865,129290338,375992201,85667923,344184466,208248998,449034748,554262232,611511753,542211400,950909016,508058149,899867125,150911879,635223567,868611080,587842159,303712966,753858627,615843331,884014061,139557580,900645095,762561136,119385369,455931841,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{615690460,824992353,860125862,27560801,909167187,632984298,924339623,778217355,279454364,227224714,421209456,449992488,395984060,174132888,265397446,159053293,282745185,364728493,448459312,63363044,26427127,65844161,861257048,741062465,327096942,942857575,364931488,177955206,759034119,600641049,656824849,295961316,364452485,720741846,859463222,650471538,101812229,832491823,411512595,167131733,873325025,972624066,430298076,582947909,409349502,436638058,712782137,621578377,957213157,799078430,987632159,906018936,207138279,589510219,532256506,794135473,772961569,147808698,640656305,259547240,665481291,866224232,278275047,585492200,106022785,37601917,652341670,132832659,152977161,467713060,240382470,465660051,363831582,639432676,649211621,98044195,578492634,539532641,882193208,794801572,829731339,518100225,935588693,912759047,818772840,705275226,812056684,815825164,698006495,673857773,355910271,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{832865997,204752428,906197620,18732192,646593484,923707471,784608011,302478153,170165191,68224682,246199770,468890324,477470553,64423414,658884452,695437942,30771395,851843721,856321004,650994302,195042060,386871016,237839662,932462481,547714045,475782706,235249372,850908497,753356999,584290129,170786325,368243449,859489468,570362528,312332950,151811922,931362194,839599472,855875072,708676737,516464076,454064066,599999172,639190742,62460405,847595563,545464246,745895336,760233949,684058093,13477686,417560911,959341765,541073553,60058162,897839821,717020069,420696797,600323138,804767227,242526778,996598965,64553359,878271282,270589537,886600676,757703234,572376902,520443130,841346077,412137490,758118060,309429042,709235356,849062718,45626393,453818493,799771789,109506234,444959273,591788074,874789904,874973370,356656327,857780673,680363955,386615290,940490222,377338701,922192473,624305254,998705849,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{532800416,200077396,145612615,203439556,410371097,212579459,440478080,398004946,443803810,351047278,309742826,158370678,136323695,973055354,553802941,992565805,705597808,661048355,879895124,193155453,105018200,542074450,793076480,643199241,364979428,42841118,129226953,411273635,733181913,847109786,67221383,698721981,612317729,660931863,355355026,396141641,111896814,795400623,572390406,359863658,546548253,421545373,467947426,702871922,393599,688087117,401961778,290571831,369796842,612569608,947708573,397689330,110546723,263737174,271458860,672250121,26910394,120894348,236336399,639519742,193146860,892802652,471737001,172492600,896313502,195170712,566666653,920359819,385392701,537298526,173156364,257417480,965053228,19835162,408162006,433584038,458594600,635508199,809529424,959508750,898469933,946191917,35267174,433485768,190691750,482046094,118133232,647279720,886383355,610903412,727976253,208931420,924938843,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{674304181,431948376,283222519,287523219,53561872,762682087,316315383,786941631,694485035,290963229,404379212,505486132,937403611,741511620,644068105,677333123,463215871,952974050,20397990,153224938,621623403,594436711,133327623,778611059,61522590,499682423,203743566,76265514,141094667,152874107,835499442,575042152,919540546,511297012,558962207,429229942,13807836,974166662,191891367,164569346,792053620,819182505,467394851,103487508,202754388,72164592,52907887,46539801,934452455,767310307,871107959,568892690,333602662,696446966,266477107,522152716,581918908,155748153,402162461,179553255,84559604,900713609,573198786,297836368,580083063,995857249,151240868,260886012,728367133,190544299,343548093,771853265,862456758,155324823,208192047,857471360,62335285,480175328,125121299,201374517,57453006,450370884,435478854,469300885,283013849,660999444,603719750,342987593,65487973,842707617,88011292,572943944,713357995,721513687,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{765306863,889860204,998363995,95203759,8834087,125140363,702190169,625028394,224559196,681663266,106212096,974074356,616640789,96825767,170226793,762540022,456853752,214691063,880028,673204322,618813582,117069034,569629498,38597668,652424934,745595668,223982525,468791906,516620484,161763473,135864016,302954448,26233002,418833908,34355501,809244505,211577233,910197132,800757617,810282030,791462264,336017214,471243913,493252111,763772929,379288127,138713213,381660703,555842775,485109891,683152864,633694611,248744741,279494291,917089497,487346610,529540396,279934517,383994082,99278308,895076406,123610685,846357631,489859950,869716268,215213150,28459930,143457975,123464744,694414973,235008853,764625896,577679018,752213698,122078056,9497264,943012319,746482796,503631465,604978083,855285346,998878228,177041033,747715828,853225499,749541025,924505185,226392057,614538182,139110496,121384716,491270447,347422243,38568540,404766192,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{574642050,881524569,448061622,949559504,714607961,397211283,548114510,863239246,385801112,321887437,766413211,451940038,718594874,508218226,237606298,570982963,897356683,53554325,687603193,20829798,723123272,358309025,544677418,466525525,389921451,644412729,904558728,797478727,524281509,898644493,994092972,827813451,641063650,556398910,64399590,45655530,892509004,133231316,439527280,925385694,689514878,146730753,163773330,793000945,86577840,266045314,562379923,955027643,963823494,450240741,259494700,230906973,991519406,2816441,823341814,600235078,667165509,680022356,626054234,824387359,199722062,146605186,394837186,241221324,261131282,91297267,787328356,947938225,268388274,615919156,704048510,618369601,935748720,584506950,540614429,865056024,354263012,300379645,661554029,3334384,38908818,617057577,860682068,41255424,695151739,7522400,562514429,612899655,871581835,507522585,444596808,999483110,698450057,465484798,90504728,262140406,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{917297261,356458494,501362968,908932086,821415403,27909986,651826988,27829044,435745048,694729407,189138227,833629430,624838154,637443019,434881065,230354668,680837028,648353939,889044973,890075928,889981116,641287587,658292801,184742871,569952238,62657119,699413481,503476237,277012471,509302428,149149014,332245864,637680233,2483512,819524749,679066489,574432825,152207473,589430537,540308509,195510573,938418546,498422812,449736128,7497821,594366978,696031629,745616462,671233828,776851593,446956679,860687236,219267528,412411401,207725663,138744192,179073817,114727582,557828450,139035418,135012506,968300123,918322275,380979689,927068996,510588952,488711303,728417316,179802997,412172790,346691480,78584693,933747907,967619289,593486003,120744602,931839755,987779015,292882381,513006942,974762773,806766846,135288894,441900258,139581272,242401782,48767094,270324282,368837650,557856644,266112621,659119034,461287773,92679539,655312906,688698455,155581826,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{496617316,861694060,662127919,811188784,370014532,202064219,230689961,168847073,720483529,932510283,993196836,732914644,117312102,241667614,655146136,771013511,707356059,176905242,544898300,89347094,552999150,202627022,111152423,718115443,569800812,35671285,11886708,93244902,663607555,85032968,971278671,325211337,285314695,842950224,198657750,144104358,552862804,790848313,804876286,385868675,125049209,743408325,560274975,169786490,713575670,156064576,762972509,794906815,351936073,94062841,810306265,713620299,402668947,831139698,98391241,140064340,480195305,526312833,272545043,845468210,975000112,933754892,811778072,964243753,235162104,413000200,723003721,765058239,576886189,842902680,863140589,653178430,16708352,362799586,699853665,969626718,939207724,861181221,771237347,164948468,389856852,569171409,180471458,516258088,326018928,46946784,401430706,59895181,579188232,300741159,384387043,725448650,507224175,788434365,431303947,215388844,891555997,245836722,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{916091155,82272774,618415651,904639824,95336483,251704220,572272326,440531786,431352273,146932873,588959154,820872460,591132618,891065893,143390358,86087381,89783204,875326459,188021898,551834374,712349572,439682285,112668242,916238186,591994625,773128689,340486678,49278397,714275364,56235832,850176791,83980929,446549114,21534227,378982792,436674521,319920106,849905927,701806600,30060103,609809047,381610913,557762027,359145588,786007207,757787675,151787794,429737023,333756182,156720983,643358801,755636492,667703546,638632387,161668751,331520764,621722892,662985443,142300608,639375900,91455345,24807318,849379764,964635779,704454794,726494004,151473078,667276531,991944268,388302951,691425302,538497815,960243374,731086288,607874324,986581233,624120972,774339158,524790750,666148534,499275941,785819452,758401568,719483846,591439539,321944429,333043187,412959349,864712022,506814897,777825734,254009100,447499273,726030605,441163839,606955429,906227957,941644055,783509460,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{399434549,977280622,360713900,476711816,208029454,909606523,328970987,820256104,105244709,452332854,397097062,330456437,453369856,266359516,230531929,158743851,743671104,385060341,519230113,614946258,298502082,444124364,607237445,84039185,832032759,439809851,965589072,826078993,237995774,558870356,746316683,991019823,241024779,368739906,939209974,792675185,603056503,599794908,729879578,538952039,749964792,321937035,82675256,770355844,881877952,302442158,558740939,7783672,900730620,875797793,359520872,86539249,625015694,653836022,142145237,772369385,158269314,39405442,838229675,592418287,188058651,862742012,720004518,843747734,454277657,756676402,329381728,855613753,775347585,818852376,516542998,628821051,859268813,70736680,603721131,568465684,853910157,299693503,95821256,234592617,886574521,75894337,635900160,980235272,184553507,20543782,790087269,68018773,788160528,618256744,299647148,565125503,92972155,544439484,667006613,570404782,264251055,290479557,369689414,958982187,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{345587449,203657526,57018362,357998753,535295896,283441636,310455431,870524906,550880889,168303684,314936229,871485665,231354632,442827385,332487350,406715214,643406507,549670339,22727617,536257290,272008667,251895056,808233193,319991259,125376893,322270726,295876737,285345960,454121170,791565694,679884397,870579637,655583017,269675782,159056767,860758577,884044609,817266859,613493693,181645570,461135361,825523648,413723039,12730037,697884491,367762741,310528975,939989884,975978529,749287289,472570105,956291026,208061895,411852797,595553043,384746692,542133065,810534964,465316442,972737984,490890982,773336144,587243393,448084598,178758563,362532502,254210460,798938274,891535471,112394253,979824265,502071803,349054023,775789522,85765427,86874839,454176100,719252078,62700880,840451580,358045632,240068678,985561660,858016602,541969002,979902157,690820290,10122434,672118195,660698889,547516052,840362842,753333026,12520419,111503869,158327289,301858589,29157483,187637909,386267948,949109021,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{506051080,34178198,880698928,958126859,558281976,124566040,148449828,290853237,468229491,520635836,303542756,539568967,901448213,838707969,413926583,141631662,234708715,399313844,3812534,113952346,269035134,63066995,96724015,104631194,77918810,412402828,730400983,247076030,361301824,284389019,350113325,592535814,284333608,772424387,288278392,259858466,526369178,689682038,581864151,777993513,402839994,705546742,461974225,471988784,148124281,602313740,975921382,132652023,833788866,402816764,617558360,576623891,53274995,515163065,563418138,102925834,721021175,980652336,311284625,311726376,214909141,522000367,16135725,915440234,459914593,887740854,787867967,217041087,174566814,228187155,463291341,553455993,228013015,660484441,363266764,361241232,716572912,641300297,337622128,319844548,463902079,352426270,503453163,422607552,814046023,169735770,422384015,766990425,838576541,51541228,222343952,456705013,48874316,797740509,577840359,466874069,255967361,852985343,439413401,376757580,817013463,506341707,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{230333744,944508937,652171640,872323029,497023076,280506586,268122641,28380343,839668138,745435700,351888600,178025334,256415701,328878866,311611547,380975249,905966590,801162684,203481244,420063782,253671449,127500566,289410666,540156362,15868288,797769742,279732113,83685431,696464405,723075397,65210415,134018441,976307357,219912237,303519894,13861510,396873374,302462322,282959597,181413415,259840223,236169595,702499589,89919994,322477995,797461529,824015950,589391077,596724911,783977688,58894206,953548227,718071561,565775983,181904368,544212938,762792428,752278427,760586129,114803687,820658906,456352682,463805819,318902170,785673825,579354809,157132020,485124578,744062133,296647936,712703302,674558102,781288005,811690989,170385216,254297064,432271363,604950753,556956617,845993280,115982569,62971654,894433457,111166950,656406392,375296353,109552367,971329002,302445174,250620206,489287197,35100568,113054969,290066778,180876743,97303609,843092438,159266005,152308610,949126630,546949245,723536250,304401768,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{253526778,676688495,594461338,417346557,697739680,502612419,800857886,465885769,710989209,659913535,348362499,66369043,638461292,7022815,385284710,742092488,4880778,851939389,319686145,706218727,635622480,518282381,810151514,463487638,724568433,970050771,520710860,775249448,502802633,924089158,593098279,651076523,637609986,632015622,542116417,540392056,311740940,670075402,510570488,279065696,704167779,915624317,566010522,455246021,121405628,475867286,959179065,963117412,232836753,337849988,936183890,485755837,811037906,80165568,740406935,589550244,612329348,182620780,54291209,318574797,713073078,995882831,806015811,943670654,347133666,983213844,899830824,395574717,749701575,159186345,964275906,961934520,605916224,279730401,6324625,928484957,156637527,94735030,718898550,432835403,268707979,931989033,924163966,425709781,499875217,750425495,401745087,797347636,854748355,812948706,513725898,760567537,973630428,168116067,266171254,247469817,992918073,571262407,426023152,743189990,220753019,494902539,452631524,306882998,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{794751641,358320175,687875598,12902190,259488532,832100365,920739837,83568425,16297593,24533098,945850239,15475257,16497690,503380842,282311138,970455646,113841584,702821073,576822197,556219452,46318197,530228015,802541033,714961921,705217831,345963614,344946661,780517677,194543257,31837176,54893335,885729415,197174267,881504769,783594626,559698463,209034964,505016328,684399470,401992455,517910372,731272820,597319820,894022356,860079909,171664761,324496411,453066900,666940873,492449397,657634818,369310215,764643003,840854878,35606125,544057029,29298901,880180754,254174017,738209072,975374022,250051016,383404416,347116273,816324337,748183061,387100691,890172116,236172151,843612086,203150526,474681734,494052222,146376468,547336117,429094107,708913996,597644515,359319856,71028674,28238090,970794821,986499980,723845300,126088433,557535000,155752186,787575035,483096501,400059777,832823311,250208581,243970659,167068465,43614273,659806285,651519652,68828447,832418361,963803828,833064772,766714940,166863725,863360382,116617810,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{944762951,590797316,995088296,600808361,274541614,68248952,275501687,744838350,910743933,164622684,89391472,4130921,437359726,167354013,565026452,795964310,153776623,277977245,569524548,801726977,77564221,203597062,934770941,316656344,66115122,481707139,748690876,475282115,417495416,594899297,719580787,184171780,756608381,54591920,94014182,306051323,968119334,515618992,892473373,975619405,134594404,313267325,738388629,617872605,90129059,642115706,663080264,455912867,515895212,984887432,729413419,48926738,268772567,693952115,624608247,537185544,700905399,672599060,108702484,33525388,638748767,929647245,963562589,379086719,449713456,213313504,908852589,488808966,866374225,28105761,410982896,631837857,213851469,265538797,824392298,724913305,796874131,653536589,691660749,7718438,745809049,757859281,284835908,125533282,67066660,939065675,804400025,57919781,952575044,188130209,405158067,803412976,716535977,788429820,308192374,349284382,527640787,803959298,552788748,248557846,139201513,560944364,4812980,784554120,73042169,247801415,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{917573021,197069011,598459421,273910938,842958799,355752348,247687221,745526459,320651268,350082907,875561793,801928154,429318428,731701249,906803854,248183575,750276406,205496233,674231200,725044717,886601859,600896398,401027740,672469563,383240923,772101911,967215292,689367457,360635419,607209902,472564224,228388995,561116532,509179599,110095759,372443817,892032651,296696366,110186007,283339836,456027160,981216253,729400728,839189289,58144199,407863747,226181614,65610613,631749959,355729661,938791114,327087663,525116854,959050790,809760706,461258233,790889338,143558929,393441237,189082518,725089936,24852100,986556180,52345816,506560568,954139733,479579169,36436246,489616561,458109410,216621543,888357663,385702854,453851009,571824499,459223941,38903291,429847904,130532254,731862348,539802569,326015287,552496973,327760127,408959228,403043027,174317113,408641011,48833864,329512289,760567952,763973776,556956063,696467618,474788951,520950690,582144841,901000853,198391732,60730297,15007881,938118269,544724475,487153299,971882494,913419767,903262190,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{334703354,774580919,461722273,586718259,545317300,148117464,574848749,49553665,565845286,735883010,623270892,345658260,892313495,425217673,195577735,978947591,405475038,936143230,750978406,303970737,728229059,637274885,564455786,15741567,678703173,237430342,551379330,131191685,758576757,267996705,758905732,970062647,876593615,660036913,735792088,973366305,729167592,835692833,425720787,745629022,164464778,787385210,78422542,460513826,240557384,949625060,609452309,617926683,635500514,555218748,112851922,233596697,183035568,210741728,680867745,591436658,78629898,842249822,722693847,866942244,782635062,826265112,544351896,88388325,46200093,112819596,240917773,298689430,4477951,29233250,821140980,182773068,947804605,334698618,928209853,998951052,877061861,814907238,475033917,266608155,471924221,528630295,403490128,280959103,290642571,65127402,127432071,866357993,119359844,661183772,673606657,233224938,37619270,273446166,728697875,942596119,855923038,428751151,971396874,165361514,832774998,512011826,23472462,827134253,311853207,692777292,563969697,840273904,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{379417866,623562846,273579329,26644060,6195415,522989652,872631457,965465356,294005010,42663950,676831293,47224902,556059426,979272727,956326330,529702474,453905920,33103747,352566768,459002401,587707578,586885281,163676869,791566441,139452445,754315781,210179376,917612180,402935044,752918368,143141640,171726929,167742973,59244107,874505695,341872572,584739584,920110263,167663984,870441491,425126687,159380408,322551534,978611839,39322397,450170722,474905674,353292854,112637513,726511822,403176313,899119982,550212439,240839865,304382781,81086632,104963815,529682491,953382702,62467921,303848213,361152439,545094970,572059648,910426347,306568529,644427148,898997376,477563955,377654954,547666647,162190928,48996248,932057049,698189512,98554472,793060133,241429191,338624025,129236762,442575542,144892868,267367115,997348995,650566910,456326746,7560857,501387222,265294077,523899167,740753296,417557643,557377623,874959945,515991593,718137245,875219670,399645302,885246007,131145731,907616259,444770406,429903355,926410882,297267869,894367239,198043202,991754339,291503723,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{282810784,549283653,643225569,961815748,867804557,590759822,353293489,887763831,641692712,833484019,747455037,126341285,935156195,278818663,631949459,851506338,804537824,306582690,859977198,414671873,985723500,471098051,566305809,147376760,51721864,175091218,148324229,158754587,578363620,277090008,832375073,973433051,138866015,627613913,532300154,553825122,390826053,628776555,258277308,574884333,143867918,433760198,80430419,365304790,433141713,530557690,853171829,649490455,551628746,137204461,61786115,501837499,855675179,42450124,157961294,178881792,548349421,444849206,12002155,131094834,52377972,121971323,8820863,900185036,894303812,72420465,154400058,246101001,904785386,961659611,275111389,524144367,648477000,983751096,529405002,366535168,305177712,66632910,543178965,299428187,36197275,418685077,125240216,531620512,636065931,311354868,55683308,710684301,188073565,950408685,105697246,755960228,669372992,996799101,385505165,626605504,93560697,397338170,752504365,459359419,105325364,751033765,309993523,123957158,678797825,981687840,943677706,242021319,361105685,951652566,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{316723773,929198438,195817786,181861990,720490671,523180426,871563459,410699462,809502832,191716517,193091615,3807471,786343331,370955620,360043975,587117319,107238943,30844408,74626085,318932478,769386368,536136771,706545768,548272799,171779092,757485665,828129006,121142798,324713183,20429040,496238277,955071768,417093779,688184681,309020603,316293130,266686412,456397104,464604382,259553294,981803569,207352132,372387912,411498594,683219221,373051364,822066856,693769456,494547621,170556490,88436868,92819868,2643167,779843343,240531313,88510553,361924841,581335440,648616431,824719820,946314230,555382515,932667564,90475779,569859429,849481098,232492737,942355891,54630605,654093187,26400598,159372255,484704077,622448139,690921751,239213142,773257736,58171978,233699826,165322100,664812778,737206154,496222343,251846095,55129113,46037069,129136837,163919092,927541284,356073797,587368525,918558396,141851452,992818756,718637064,1515868,442894545,367250170,913198152,812540251,309954437,998092564,174870058,29973387,31242360,309612335,234519012,8444057,847563827,713011283,66102374,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{696540273,906270420,153002649,360919653,436359406,940104570,330167364,344854832,757882371,250538715,748153592,349371519,560593191,861206339,594999420,458654573,72436766,507658071,342900052,954248287,586408599,502204755,512676655,148779861,372062732,566375770,390264045,586196651,386317599,564836115,463830733,47612921,351876112,337693726,266149735,526487585,109553388,422282464,26054841,795364244,557069513,675422011,700779582,680832759,466420609,22912342,513115150,933499947,343064743,761495111,459711599,998883200,600569949,649024680,857850486,706112066,428827934,861328702,684271732,533792083,853073000,782136460,164339565,886153620,178618305,465126875,599865709,537116752,638673311,203669417,590670770,606702354,790962616,661874466,398972672,243565045,660846309,942941908,536470456,793064087,217896097,327481799,745678254,378499220,179173355,262524833,18307719,32853134,295271777,268077744,692826935,996932230,837095853,939272746,654739501,742535662,13027237,419775817,206391660,488116303,964697922,399107445,153476835,689671623,221205679,604205510,224438816,292066628,316583336,151881000,959787740,577992572,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{698970619,184952879,348624476,989412966,909447870,92102366,362445651,564817368,674770105,449189775,530862747,777371869,559736093,299989747,302092977,565110932,401030767,332509397,652911963,752485082,706116201,994346576,779947565,400033392,528046437,335358249,433532167,128147031,368064708,510999521,648729221,411137676,398033174,728670469,101120055,405686094,767239979,341427127,534224557,765624611,948698404,134529830,275494991,64166303,269168588,239113288,637987500,780722527,489917265,591430932,274272554,567290756,147169510,552148228,800131708,694797897,664879724,238566324,206046733,746641535,382343064,746633599,256709999,540747779,252760873,354513036,163756215,858803804,696688511,364457380,951065603,259399722,590275631,278012334,131303734,501706624,647276727,406138241,337078741,719933984,80275533,725272069,289699134,728377512,983988484,30110163,949611633,626937304,916540236,385377602,89481898,772645748,449602800,242521473,411539094,43091336,938565608,614231283,730241627,397736701,903336830,685722085,750663949,986198807,771588697,497945667,712008576,971564863,633762617,260392121,374022702,721834643,963717589,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{344398830,300839823,619578651,926285140,981472194,631637114,796662187,926157441,298327759,554981761,476877134,215520319,333253441,953710067,363643849,315521381,445568810,718911852,513393226,693131485,317696157,927554573,739476885,432389121,247495869,554760177,762013662,100993221,212803794,290175112,111768884,303630346,852607858,278267945,689088483,310271666,272568317,746349100,448898373,320984602,548644072,83795548,10266869,40342056,738932389,943765643,185670560,711099567,862407193,483581914,325107248,232959625,395865896,425127996,885892358,548581136,879927807,343730891,50887071,699580590,608762197,829395509,305079264,473159416,330710294,693269047,706421204,29854116,15117195,792199694,130546934,741119689,699178094,884326169,202587283,470461528,150797954,498418453,613536630,624271509,751515260,604107907,432840763,153712416,977294764,847942554,158483144,173726266,782502463,893242658,693813495,48174827,563974686,218312261,874049720,515759652,196975345,910024775,854358503,112514116,692954508,836209398,846285902,943545844,980013423,446402382,547492944,150907803,808209219,636460282,402357320,544193480,381446928,657550548,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{122828043,774988140,555171707,841743131,498134526,666223470,585633584,908809583,428607083,473235316,329231132,739831438,109035339,48609573,107202491,876218610,173225642,981817135,353728482,811091888,555214325,268991148,675024212,210946770,490732106,362831622,507635173,975541578,438421640,828749164,912006239,39104355,354610198,224611984,326045759,750146866,66014183,209888790,754036535,348386854,700507254,721635283,785917984,176727201,224941166,763860994,919239854,916990307,409806325,23140519,648023573,53165928,185908990,962855726,930129439,660580206,866821307,21750326,666226049,117402655,742721086,837669178,280942713,853259129,67937301,763666308,84532744,561254517,907191780,934907476,172113297,936770420,227421491,42825306,387414652,765451007,671330428,224661291,26564018,780926044,297663624,649111637,950906078,474009257,366471311,366936278,921432221,236215744,738940375,901698424,323765902,128145426,308561196,940360535,212518951,574072376,773358048,186728454,282989213,702692182,734400024,683501247,165906938,899249828,181487301,940215582,794792791,696952636,775526150,46453466,396534092,978428042,651382155,642672612,671819567,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{723200110,239335135,115601073,456473257,185975440,141469619,470708106,81765996,831507213,744707346,373501015,178429600,132956215,542982615,603072211,730512046,195543882,974533536,526290772,271060673,46691606,442670481,172406299,694155663,522609302,764893634,863754545,685417361,570983731,184867166,508706374,583188784,173965864,712189361,777976033,897387610,295340229,386361761,954575441,776526484,968876217,209678788,321771950,841215177,606183925,264311386,309895879,351882036,676464891,124253428,786875550,283584715,586711034,320463285,394500766,58792780,55714057,870828681,891351965,906681679,896643200,609260245,499978800,299364619,880087466,786838627,813250850,85875387,686173029,239002198,763211837,371772438,734527050,301545506,488892331,619010667,514756031,67523186,473486987,824282526,720632518,728162212,85339828,762340904,926735103,110743565,784821872,921212916,885708619,408650876,693722770,943206694,68168710,505730270,814386470,660779154,474382201,30909848,723456516,423230977,986212631,735467837,311987498,537896074,932850368,14080789,396881110,334680693,683462718,444249067,670529087,74774526,743358269,98862079,528762329,513684684,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{936403555,29735536,719094671,981253151,847606706,998649496,944701663,869929541,490402688,664786079,321859431,820046144,542816610,507345258,747927131,868017212,755522760,789761199,613554050,424312120,446044465,383441874,982900220,802388327,315390420,941417262,853812071,347599294,145497957,457999133,273928152,463057341,970072064,590409157,672894775,636266454,538337325,335242223,616529554,360794670,164142256,226479483,830941702,971245131,738959333,110037206,643954382,630977129,80618368,899436045,765275889,420895554,869950486,113166107,656804986,40513805,136631091,423214925,938654013,853533468,333491108,626075940,386263471,665771159,728389244,208546581,576521921,964355628,79188897,224180488,167996766,251069225,21600611,85020778,112995742,778498817,803323167,804688633,518275536,337761676,727890855,584929302,345416990,757684916,962299136,517942896,462812580,402784820,127165807,870660340,90444415,67685717,185592438,719094668,242867870,239453028,384184198,416135568,299205147,237141075,561978943,727199037,586699567,269056412,76368391,677479545,658576811,69508512,215520370,153071730,528820601,241471222,734241331,52675538,911027510,273246682,465279137,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{478783788,943747812,934351097,772718056,283521679,376207239,689916846,207591699,766976211,14961778,275930566,882304830,235715489,181763141,955267118,609831842,668482409,556682382,692982719,600868316,410957686,575082974,348833974,841405664,964253598,385116344,946192609,623379653,925339839,503423399,310928240,450445718,811030783,804531460,367164122,49354425,403240184,956102376,266582913,497531224,637530350,526518611,371543748,929672772,245881143,195027402,354771819,628308559,272688013,157704673,20266622,23435498,55004503,564466241,859015349,934611194,9344213,784223433,610145726,645792982,579286200,896157179,844737257,339366726,422360471,465216924,69013604,751368289,611392736,866428671,264385302,80594765,631186124,710099824,143751921,413001625,993488152,840397638,457169324,768461916,776821227,341143231,841882747,861233583,421052888,730973087,770735201,307062214,969850850,10738970,697855209,404126830,650945120,408604769,70477009,522887969,89982132,778741434,900206993,328789195,135910361,61534365,469334131,26845656,262836461,47988909,990210803,460903062,67928908,207330792,865174425,723284053,750798370,852290711,113864248,632119119,284165410,354211416,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{67708057,308240479,322834436,290564290,113117295,927252610,402222352,967408596,288627537,312285455,515357788,940223020,683569028,868175299,20460919,474591889,19697163,752396775,35847148,198463525,782212351,927947963,703771775,995416919,411163029,57248849,769561866,778457681,291402851,190201694,655673700,139316872,403105591,267360179,299435799,739831271,204179108,253271771,837959686,205238446,702272129,794792760,956338144,89530384,355925200,520356881,576625151,281205785,458667422,427928982,307297470,602719010,775139008,450933619,431225945,573632908,828448836,435866248,305315100,895686052,46393844,795765960,380642562,711522755,249677775,144304188,205055670,628282244,293319662,518154465,695517319,478817468,175210021,813822581,949869379,35867418,109249226,361293893,378834293,264605937,316489092,317205483,929633587,136410499,746235738,418755567,871183208,632717694,1996970,293598681,352549629,191606631,296271766,327386244,802883572,446582566,289974349,46304948,968871672,522997235,626979538,619309206,477663194,26107083,980440105,888587812,28911671,928683757,138735593,64355430,861170243,895184258,937067923,457324944,272336249,465038658,71333956,880564704,334765235,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{984466514,126958482,807817827,610725013,916403571,161283733,732885158,951702727,827303201,568621606,648699761,970166368,705413560,230575029,196204227,387483760,677825919,542624547,880031883,834538478,947042687,331295202,449051184,653686378,571937315,841736140,336582879,872964601,584755937,530493556,695098461,514766939,892780902,286047365,868147879,941244074,87091621,283053641,229850162,853783811,576978284,786100202,571636781,125087116,864519397,994458782,174066720,353793115,357274798,935181117,494754508,414322597,90656943,900462550,647002366,927011203,29872916,927331825,45137934,978414055,893487147,824209193,613593357,777068069,798905007,707818843,439076027,142580909,383409943,77422122,578835207,778171556,692597533,568733389,442595737,830158720,80819181,205257973,672793787,180402469,823287583,976410470,216317096,180669578,885967945,533257686,425199115,577986907,203700514,745598077,211328608,157150304,509372772,415654251,202828181,142105314,577761672,473835524,30928633,36516931,995960402,88128733,235580729,14199333,254453059,858057739,361490454,396483885,445588139,319753766,759352899,846410969,758077941,62876715,90150365,814316423,512875699,435240478,947000274,377722215,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{103641148,890527245,198760831,924416765,134603882,423543401,504157258,722680499,257668749,279850130,915008122,595372358,421538217,341081318,834270324,914045624,461706777,245464177,766184698,317704934,108598373,357365861,225744314,205999651,561014294,113507189,665334285,680941631,581841883,933080786,198498031,739672226,307097274,175784304,203209270,343759982,758680675,264304357,17844665,464398818,18254317,757761256,431561686,42492622,628975380,760991061,65491903,986038035,808340159,125849633,542950613,616571726,430858833,853474783,704659928,520832709,469887941,848819792,967314320,42380394,135980886,497448238,738793989,881700495,553549814,892762208,49600714,403955567,268129139,387239601,736030802,243698752,397353192,907870948,28579946,462616334,319365736,812685063,582084221,530901049,103426820,300914530,269661460,448739083,791004392,417024612,682853933,86584469,623278645,496954447,734921036,987138514,61532468,387502645,651047123,141641289,682809451,363561701,86283347,691952688,390952023,575078150,608768073,217621199,902827520,513715000,802886087,1218998,33472412,190173032,513251494,471284578,209803675,714681962,24531412,385412916,750698811,660206697,903097337,949280755,331666373,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{386438684,793476796,601952503,227468153,541278814,46195269,650096050,164058701,961853916,914556386,433842286,685320988,120589873,172870864,567163507,854743106,445168007,563218088,999232281,766708752,895585133,484064421,626539545,904632479,325000935,695699142,427255838,101972777,597425769,839139060,863744597,517712396,273029497,587370173,515671175,143896167,658271162,751480063,581339371,923068832,221169938,714795556,679403734,924614845,734533882,749129895,50158251,293098917,801026457,715878616,12745668,68222516,827272954,579823194,931693083,833024474,31055143,646787971,268810796,576654686,601353331,907796265,271146878,693416462,264785797,833534755,394751032,131649783,315118659,265000739,596427875,884741124,473724286,89911177,670719713,300293100,292943205,383333705,168312805,541496243,451832325,20871047,489501292,906667073,558307140,737633358,44972050,585287180,95522546,695438081,94210653,33619444,732099589,341520889,686567842,943402320,74878469,322930739,435385684,463778029,615014513,455889695,277682284,113196378,407091962,519198143,19306736,124919236,757630863,691070559,191674692,897241859,813324412,280417665,407022700,434029170,384576180,374081392,29812499,218072376,909928994,618324754,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{141893035,792438044,547433651,637990415,32854,80490593,392712743,744381704,802198455,651521676,542383871,297023352,551557293,584631813,59190771,416884998,989619684,767484757,503144376,838463640,849140267,103880565,134203413,6561043,460943769,559576895,307264413,817636008,563206186,697578095,624849352,559220114,939061219,983852100,425233389,703390363,698190814,402873487,925020965,818996929,269625172,506686890,263364904,917104197,948521175,9922025,589921469,55589085,999634340,700678535,384862080,895061403,678326301,157105313,248334198,88666933,654948386,565993514,329798803,865721502,901294325,347140410,591903954,274821294,643817002,492463178,932967482,58719510,506491791,132098854,2921304,522688985,226434706,775900852,124988294,236812739,698764466,342638677,596180757,527246165,972003583,275410484,362071257,813121326,676626065,705491179,446317246,177999550,557318415,806635576,120813807,231597381,322915071,578069961,726949865,548831919,640539334,692024597,711008014,953079740,726439578,303533230,686397534,691493200,481389189,82107151,77076888,712464230,272713288,956572800,593074695,38191462,881223690,811394269,15132838,294695235,593679761,359726938,849788340,844357030,577363815,138279714,313092993,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{260437572,247174254,721366922,96823293,146906123,770545858,321752192,158701069,712162554,838689723,813583406,130295792,967323669,351999342,44974070,343671828,509057325,125597776,964018006,564832823,108734002,86872214,22564581,178116640,845693834,879618118,84654803,272254577,636870471,526625385,363437775,837850185,196256398,774620023,383214291,929984055,194708216,397379380,381639035,319119878,416890557,177385838,258780224,943940943,759554956,667313535,995937519,711320276,690273724,255486598,348410265,238983347,663325085,942910911,718308965,878127606,751446372,756820220,921942090,162804962,194634451,292227613,530444092,431364988,44405832,788182832,25426942,528079778,979381498,122236939,714229004,741575848,735428936,260011120,132978482,777707967,755438411,642753538,929105072,72363218,61563073,127469426,984034200,844736741,966767237,242651825,861225029,643368569,795581866,616025008,848693160,463612032,719978630,827148500,416946574,440492187,967428352,640891312,413380788,177463134,608311899,487079362,257482516,396423757,740568330,958811570,343321542,783547801,454963762,8061313,600525228,332749733,899611091,572141624,634881347,985902875,203680870,759990807,199300150,2683792,408089708,20184683,507511959,453510755,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{681141525,387483039,545748319,167935963,477291680,234283675,634203959,531467496,590901863,150536243,65804040,493495657,402491087,46152487,354944185,901924021,453207103,811177712,609781680,864546370,285291035,964421793,689431545,456685176,558159608,695888251,184132718,370743269,779042788,128919369,651149282,987531198,661525328,403331035,301274045,195529633,343335330,945120436,677980305,14714266,385964848,96935319,435278277,947189563,506185148,843624399,863020509,965851552,607412673,858212515,325469237,18064171,788633125,33610248,347587281,241063801,357754976,247375758,482314237,308259108,702713853,684387064,603434121,184229137,29498322,757263050,930758848,86895731,866052259,426636868,988392009,572095977,930680370,406978361,333533140,305875166,510636495,428787322,839169211,179138590,124321002,38692217,244422587,705489406,326491541,793971689,122715545,122413632,972566808,859411213,645455500,362875002,565963374,702092257,932641281,817212170,526566348,15160821,187633402,179137298,740988224,829672799,758415353,585095845,120191975,410897984,103021280,903951534,508927063,556186007,906785781,247956361,902206613,819004061,696153236,774991903,406017287,218137946,731437338,276657837,958053498,779461828,467061060,773204051,791279553,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{523842017,712532861,273437122,23614638,398498680,341439469,646068361,305266191,266759688,553927162,102285290,113471993,543036647,158034687,736275474,666285994,796187535,369802045,507657864,691725383,718430896,929462459,565573426,104306810,159770212,741011985,431500496,445989632,66450877,492875977,996384449,571390320,337785942,359268915,890858673,683210975,293241064,421177859,42988349,923186198,756080445,625080724,855293415,335320519,409568620,881796591,536280332,818003610,820989781,340035390,805837355,789244285,697394947,55087609,101463554,245759570,211938638,295453042,686480470,159169748,645990311,682626571,213324353,89826432,470145444,34479543,975868184,413701032,349988457,814261088,684191021,762109118,123999138,151566028,508426663,352470490,840469397,553801897,247256169,277952386,485329997,708003828,829887732,249683847,513270213,814146274,676437539,75328377,972796061,825817226,214041709,468124070,667309399,647434749,31495060,234087096,110758726,985750198,948893036,830279843,873636597,623416922,828940755,1548465,605467560,977693844,289824517,721087316,637722535,728110929,587011616,7086055,567285478,198009154,204030823,303602715,900002334,470286527,628028451,930708422,273208303,699630448,992093783,354607307,515776745,781988692,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{701343229,957637318,762691183,447734740,875057873,330116319,944087008,194597913,857704810,38461553,153344222,332456036,554462843,844865364,998996248,315863770,506650929,582816213,590297469,676651382,613017470,534795864,872690009,411496932,165341927,708558126,186823689,842277706,506714004,263006510,129429549,424821834,999345920,133363959,977495292,946307288,987036232,526295051,226046285,244420584,865747938,144968899,445672811,887116737,52470045,487662940,151747136,802353598,235498385,498331897,585439955,905434075,49034520,332557119,782157346,268480968,808725749,781746266,837682424,404088121,299087224,356273198,858078008,270587091,792617326,643556718,354406288,522841936,693777967,84335291,825512257,259606214,19802554,92149337,439959807,721392760,149863773,732294395,225011473,410352368,764640107,942750742,264656835,526658558,313692404,163473728,342772160,129714348,511090666,751203995,379663490,923931451,603479621,800892673,101308345,648594164,486789785,249561195,134515668,859969051,665506323,495176735,702371763,82055132,3478547,524959484,996097568,136389400,114228405,395465638,857129407,408557362,376843335,449973240,652744628,2077672,82687080,894374722,747932605,477361286,246875313,246924385,636659562,749170683,302311499,770184816,767728482,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{723160966,340744004,18117483,911506773,303189961,620976967,984325802,772254534,205551732,401523824,743720054,258131193,41083024,377578131,904895063,414647607,558841052,997514370,349919294,786520167,373390042,208969252,781043624,727466920,927644140,741091763,98767223,47426597,828932528,702449060,880599762,874285392,834953103,965207714,772184336,24382195,287513487,469680503,480258622,787453961,985050903,861729657,984697522,572278233,412154448,390794720,323459031,858788112,862555330,281054421,613041213,597890192,341855669,111668076,984013337,122838265,89239836,825463315,734544644,149991413,659482490,448990948,126114940,329247321,958799150,832823619,370196066,498154291,625186,934779807,473955674,597167533,126005025,341999891,123190195,798111018,29407175,634475255,174192855,298974327,114610777,962216919,34291054,360499028,422598588,645013636,191145733,375302032,137924086,710477545,812806644,618427080,336036255,894164632,254196835,914634703,759345484,592028100,283476616,273387685,895338856,717475083,502573751,968772204,843134498,276762091,821314890,946323571,197691137,924586336,651107498,463133887,910496659,7699592,251868546,984933652,213433107,71421302,460186471,844766758,748730458,860032985,813836538,826372218,87938172,15574652,38283029,657754967,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{399992869,893120963,508471596,626616532,943252799,763931765,837879337,747391827,539652632,533112373,44126533,355424087,390664320,903283700,991869341,469334402,746614834,83220236,188727259,109333344,48918555,276198731,406853027,83405775,244879667,207833082,817696308,335324065,473389022,926946155,455964266,716586144,414956824,145117646,370765043,991214273,131283314,571667004,376192089,74423293,168921747,761301284,368818110,856179863,454236519,753472080,629438318,271713188,683356252,641236939,517757466,88806485,271733829,94012123,180725534,755571053,41966266,496764553,429712993,677838485,302174082,637247388,475683744,376687973,988677933,995118137,504631869,930797383,55215048,563740855,685347732,924374381,419190095,297536876,822436667,334693834,1295948,42176981,837823325,786180843,230378888,753109125,161514690,305550224,87630426,134713415,795399238,99519795,395399732,242584160,165304541,310405792,443472557,395319306,264048274,896500043,910914118,676229931,900059800,656754116,517181680,725794457,786817874,573819433,181167488,652861539,182556125,942007415,181651225,30315527,780872557,190127705,501432605,776459969,937620221,83382302,550517428,241346685,794246324,266130375,203064946,850051120,642586316,43403244,835177971,153207321,229769558,934513797,470609176,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{49714036,345859681,851415769,130901772,849296856,399113154,9808793,957103398,633065995,837869119,674434353,286473554,999148786,251393263,678619225,376540234,334497570,947129902,909505342,634957170,479324314,345267432,285054398,898657145,232253800,140670160,689828594,849140732,69070738,53947488,526307569,702010839,221284479,869604864,946501553,399585691,198375651,248148708,444627377,817499843,72635912,905274495,647726518,943869426,384883344,257760478,887074303,963466620,894963108,637872843,855400429,984051086,264464231,198269121,928929193,895981616,431608175,693989590,43668740,500945041,557670909,157864117,184237917,20315312,571736433,898201032,708703063,381571719,920114820,840199110,592935013,189570711,161368886,782563610,378554147,864260287,410572662,344901525,545132070,701686472,683584544,843308457,132455273,340766265,72910301,748361013,188681851,22241176,950503766,729236749,40031971,108320121,496437441,404214921,608828486,559403271,581498635,507390362,194533064,32770353,459275826,928591078,789792883,228753379,556629472,597759103,436353311,257566156,391987662,568236470,391731212,439116646,324986001,756541586,704369102,761092730,264930357,611113747,529959846,511459272,443991153,426077078,173093453,10260308,958979859,275537339,255886762,626868772,688612592,882792633,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{92916862,168226985,560715945,318640326,181031167,470555235,823209878,317436632,66382527,626356734,755057590,649317925,722917828,699703203,339359989,298322456,171932733,751596689,628513722,987391285,9016871,398370844,53162380,9763581,766088650,557873552,197982085,691883091,979688772,335647960,183876812,717794330,122873520,903413837,774478317,838593339,532082540,197305350,521165632,730990610,669584598,345758297,339036776,653189665,973668206,574098806,482543425,100771773,755115061,238775348,999609375,140929196,522603380,459195887,136157457,199513424,512970472,243234632,97755532,507635043,1289803,124393572,822018620,770978341,578239142,713577396,465831135,522354414,629686861,302487091,880282475,264044183,821119274,830540847,813588978,94988188,620493283,911057290,753175775,345787374,235806019,600058002,493325369,551588871,117944475,260977047,806362087,679592691,19202437,99556851,42781030,376199011,88688720,473603211,181658680,233823587,308991721,938499957,668708269,64097072,761111541,820418969,793604446,476843077,923958810,85544404,778025879,90964410,776805490,585229655,894594537,2250558,20361194,981910137,770468791,408407244,668802430,743485439,246102055,89603637,379562676,9330635,15766202,728952681,211799583,540131248,974787204,908633983,74006401,941942730,655852541,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{599302179,84530438,852061476,203805917,296609092,66739831,812339918,91998504,154347941,901526939,653417396,644456557,619424544,32890648,838315061,970448185,534501736,765947594,694229832,747416281,342188783,854742604,419742062,835413631,834032805,992337475,583858011,872117968,248154655,576975179,667235563,875072494,554824323,287080521,607903050,866495127,170022158,505338355,208544278,218660268,956149389,793441073,464277311,405990757,574834423,34661594,370994462,24382322,998553382,609101836,212333159,908410288,152183072,135964931,486094920,471302191,283716622,341755370,552844561,786957231,814267055,244779462,657318108,199423588,261506585,565361774,486554474,668277100,121941941,74223273,871266997,231204635,163022660,696371756,328471865,934874769,119389356,294432635,156546907,222902299,266407482,572340397,390895649,739584704,379835303,814253033,864058824,452021237,938828405,383604579,561320700,524145351,407389738,307447404,757342092,227046654,188191901,188977761,917882836,143332542,350821758,634188785,681679398,587879810,328850080,734285078,59580601,868555865,245141224,893491550,573073074,91480868,488686362,47041988,981523067,869366148,960400923,7158197,800309951,899381763,588168577,888892255,6965038,337976152,327427436,327565514,249306454,722079949,489129938,579441117,772127399,461198195,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{45250414,546371276,899014492,60323832,781416806,385680155,92897898,372674273,107437469,684548597,435758986,397615739,49559310,638514639,194383431,811824963,770557458,933598912,7472334,146297543,392587310,507623437,311922875,265240285,446775225,548017659,519565810,417889006,220615178,824962884,132672581,326945859,452267753,984725318,898729501,999135696,672829326,299914079,29378519,154796075,586584959,446713341,83422471,430996199,796164807,235112350,507897426,821170896,512344711,602995445,694144272,53239695,261246232,713036,488802177,22377935,823719,922488309,15073043,269292005,189508450,998522641,441144899,623896793,797908114,227854221,649190596,187649061,578755103,580760595,266316130,577185944,798198793,922653870,614993603,338221907,720915400,56248835,173724073,608061978,532353027,109100027,959020944,376999085,982080477,46274033,863077471,780048182,817437742,593442426,61694470,106627290,729051461,230808852,558706697,530974558,215045125,378567532,526001018,283158724,162412580,675402997,529870521,756461528,970948780,947763881,502390396,342468327,551357933,561870688,808339537,128110319,250534685,496131324,535405355,519695591,600644858,523690844,314230896,373508999,86500548,611704858,498550604,826426234,901273861,742023355,344116420,178559053,770043167,756763386,861211782,325002448,301567454,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{938352202,903635807,775900924,897220305,119065192,145641474,766963417,181680096,690700488,30593397,951593982,970141412,885425770,564000264,789287183,110946491,124967393,938827324,531445583,406222177,535803702,553629968,111283386,801709908,63577845,931802031,265071634,571418586,216493247,415728210,606032461,617114167,695485710,251779538,250643378,870446067,997178076,823561928,749737198,1988620,582209859,983659592,59732381,414967857,436513772,774852886,761578879,369785896,20614508,443371067,799301284,937203257,218029590,336191915,611938455,938180269,544471889,124272025,873779382,959240918,636376109,444252076,23178417,829242262,70186130,837757317,733421246,36413660,870264918,238690951,340018432,555585246,823715399,345434282,800517566,975030540,431046441,57125514,512054996,920726925,741627039,398017425,416168340,668011360,165337825,598814139,11669851,183709594,433877440,673544473,53260370,256807985,866792946,877308478,889381705,753197545,221511714,686057036,284814796,413762704,338210149,534556766,99487613,462618996,461370724,345733170,106439003,852910962,373624706,940435537,676794994,9345439,114048538,9174799,27979592,381940549,326608941,545516947,596848950,408775397,982519785,968609125,11128404,944766772,696494590,890803116,622712775,210221679,104112250,422892477,688087544,141800816,235654342,126646683,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{337025802,977711816,719230614,924781582,997088288,183717284,578190284,353694529,128017363,854195737,590750556,891814386,676465534,788151443,114572608,878924251,382530683,898515524,745363257,240822810,877873149,838663912,230168984,442557258,218540929,881405904,832660337,24222798,210801813,966281385,59677088,796104197,849717300,345402599,429017177,788190587,46351115,395044325,977154686,204842312,870006111,904676499,694246776,773007481,302964626,583478002,711790634,985777039,162312878,55794960,64042723,636933478,640070324,851419958,459190960,770703113,446130208,396016228,71089085,158939678,543630323,91391389,2782768,511181154,505113007,840454176,453963552,461234393,640272884,431303265,144862927,798802602,40979528,322817327,81305566,47684186,124869231,70478545,286210002,16023082,426514325,567023810,162260534,607276583,586968917,779763353,864025725,403872547,951270526,570486493,555549378,502033229,44570410,412347889,715843853,950392639,254359637,678219718,488794763,818687890,724542040,193750210,497433052,373867990,677476059,245942054,739589280,17115549,976590484,605743670,51766232,460530253,844840459,990832983,660983847,480450967,102685162,662031259,71333004,514240599,790371744,302699039,526709759,42824410,453927489,212733686,8317842,497736195,458319870,294886720,249899315,78985439,248253825,814792550,26346914,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{532801205,538828289,944269218,376153088,11582385,400569606,154862994,701677267,235602975,281787947,284870507,299067798,831477927,752442655,908225993,170286719,121244696,437382847,134900118,399920328,16717320,35648927,451853728,278643370,787276184,812175590,847413662,193324821,205382045,56935722,503149152,885500866,886788711,263619043,88845431,263227346,820025318,335442567,172861630,438806055,749139522,703675345,277291928,203146411,953239419,625254065,964041900,622760696,42565134,592230045,645012350,798688587,825985282,791501576,809712429,156611031,375680119,27728877,296061780,87297068,35521032,987270854,232649439,547134799,195541486,89163261,678345459,705818775,547230324,203983968,898358807,394006972,134918464,785159926,281368056,540893417,252652130,403635477,483869266,341126281,814888293,103353031,404635231,638707423,365992297,604037071,140405004,844626903,761380948,208202365,591302519,966675767,511299871,46334631,691078704,744059255,652910746,458436573,652506032,289125369,150921264,348796753,784221661,549214475,218692390,270017231,49991639,948117846,35575280,890995482,870433723,145258579,815258097,726133220,302094307,978376448,821464768,949331815,514015177,491029170,83876659,434787823,288566979,22273710,131639871,460244914,571177020,760821941,346152568,260256814,198249937,80263427,608566314,729879330,28074670,395203710,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{996567495,400403623,356083043,460845122,338812039,239970086,458697814,304150998,915305284,774514113,756250873,544229145,957647344,222637373,546917596,112114402,367345166,157143614,364320335,986445646,727750963,720415377,408528729,764870942,92104526,331706094,14706902,531452064,911071088,628851009,610581328,19564018,801184121,128478080,650507665,641068530,185890567,996194081,294226128,490541456,565757762,956139417,336170784,653229313,525480858,456400746,958745341,74873063,908874657,985206816,930719251,219547556,47104289,934902903,754377941,530931082,66940524,168805503,780288610,754799997,46674927,130163084,939272517,40836276,297353576,5726213,409755249,592216727,836308473,321458356,579316520,699399382,957448379,620453082,34230780,602743016,46305376,850757561,82321160,445902093,521883541,771419859,820530666,454947939,167924047,308591916,613152187,379115244,455767020,229397389,699508605,193158663,627578556,417824260,868895515,466796650,397437956,900713550,228013492,292922254,921489553,22425499,518036195,249576018,243260322,674786261,803017155,274453130,778631267,348238732,967144521,618313518,88077159,820287104,484552603,410104050,412389798,580499059,978552510,686247651,376581956,545415909,731287359,530511887,44877506,708378645,665813409,634927819,461582049,672848805,592381262,442674175,533745388,693460747,488419501,82436878,532851905,0,0,0,0,0,0,0,0,0,0,0,0,0},{775230223,40358661,212512579,885389906,755424757,976797228,513661389,31537804,549288008,616044432,109222987,491049168,152953911,646529599,646563944,326743280,47295190,93090302,582973786,178234853,967416827,595011246,448503085,113186190,282078094,341060701,385923487,134601207,576110589,815058683,917960169,669420946,573964082,699559597,118992228,57522855,618078260,808766854,441462979,73554374,909906564,863047217,949221067,282275910,151696848,641773309,137434550,571436872,519743404,420332996,124923408,742451951,553838660,844216896,733657881,153082172,970287268,404790192,825264423,917245699,308796225,301091132,873190517,143222815,341607343,637777192,538715861,164627383,272936037,982464208,193479629,302745271,861738849,875746862,865739003,743249930,593782214,852698386,6902436,721296976,756309361,370683736,558633139,800488777,219519337,540663851,722572332,233337113,386784364,691113979,529103038,685721430,92073864,52148769,543455872,148660456,542766821,278100950,243013305,510104548,518038983,699220120,497967745,901151236,493698789,231016369,284739580,797050675,941599716,510399887,17617527,152693362,81395570,355882044,5970785,466053632,87915860,702508480,62623052,778406672,992876681,352354491,655680263,17587544,496625810,116544478,180646490,52253921,840280245,418779296,68179219,161252279,412451032,902220575,129712387,881520587,478255715,927074723,0,0,0,0,0,0,0,0,0,0,0,0},{600211159,3732215,106816737,669487437,143527081,950876659,115866990,496702683,632951044,558751795,817427195,163980967,505135656,892975769,321173304,440391623,367202498,826650075,447328186,114554028,672960139,712062845,212958546,711852474,981853248,560916913,985036232,120779747,917813029,711916948,993661349,988305397,721269769,861365568,559282083,172176226,123164036,811931398,472314161,699907731,965638560,424891211,816379782,74827363,238654593,470649472,417311875,769381631,127549480,704172008,949121248,502029428,443120989,780983886,34502229,154357259,351494905,400805708,923494141,336560554,282769417,901207238,128165065,893908585,175061216,6163779,347414887,428620671,708166382,491958606,489426023,653846,60862538,660968423,799419494,748143619,114304703,353362269,661199680,149672751,192964538,448335420,480584993,612842609,236787458,309618958,843648517,660294768,952522649,799956995,353865807,883484201,692279491,792153634,427107684,802587134,659435307,929515390,110168129,345265749,145388852,694249426,215526988,569899087,811744485,479120536,760605333,970138756,26644839,503398931,349787866,541123878,453255215,165095226,778004121,862017138,887064176,197868089,98805677,680255699,241574973,169977443,632858443,188886001,876012199,228208498,325498887,834456517,289756365,75142330,422789989,401690398,313120116,770317305,545804204,66503235,604846386,285286247,124896599,0,0,0,0,0,0,0,0,0,0,0},{686083586,595296006,389818078,617446491,882562159,507370797,438712866,230847054,244581323,706019736,776370113,633821151,163982871,224769437,164069284,127725292,354453501,773485640,462089031,678635343,576248827,484758090,721376422,113628316,223389799,22257156,967399878,500499266,872022980,436572526,840012100,78605051,57745340,385427802,700959393,856894379,900725272,228932671,203819716,60690046,153892765,578704674,145283373,236825716,92556059,218556763,348899368,95907222,518797479,530443859,827739523,428453610,801117161,876090400,242726944,163139502,926209528,350023452,394445689,253051157,60661056,57063763,535529528,169389143,912722492,109665271,120538237,779270083,693660655,685527949,806538440,254392744,316500533,873703755,400757387,190813522,424670592,737644269,693620945,257121811,887449770,911468446,810786210,912307372,666457537,626238262,254709722,805979577,975187200,631703497,567560669,790320351,136083574,327147005,978850941,80582077,961070042,480751371,321317371,177395061,818723204,572481791,730482200,242754591,956396564,700821783,657936446,495664494,505370564,292299783,361815896,287380132,700246758,682221699,839083574,772950137,438839677,904509629,358300882,632505564,598347648,936920235,576345860,287371114,14226092,230510215,283543053,869086432,967598346,740259744,256407049,344540361,782355514,818724544,952886686,101323329,779896741,514287108,488772062,373862582,0,0,0,0,0,0,0,0,0,0},{977082204,684635834,474635847,224245123,820334714,635328399,141119738,344675717,708101875,108583708,977367414,406980863,43396702,252308572,493573167,251350137,672671884,630829165,70180868,279408600,290374564,571266387,565161131,903726703,922315997,437495480,949200164,624406784,879170557,347183525,550552645,75940555,835945525,295681605,554691383,91269438,721107377,273932508,50065795,176192073,219534777,410941638,809852982,864516224,797329848,774064370,549061080,368944224,783456590,162024791,754103220,283368348,917419385,735336399,750251247,195298179,7227030,61723005,861229059,378824355,307803072,897210062,966461759,763770627,40484681,55610557,268449440,300046361,768847792,924087651,957755248,298784682,585721052,51781189,916560503,592468166,148964124,9115446,336171964,407086618,172053589,311853857,458497219,610003597,328932935,618097928,66658644,209715752,814300586,229220457,924202287,412367960,835341267,844936646,455292373,278718748,226058613,72386975,470365568,148652104,166787455,224881701,814145552,710095783,280290650,722114688,446521759,261602017,269837613,529930857,213085731,819373868,986359721,167482492,700018616,951736104,120386380,347120209,763035760,639233517,804836207,274046213,730479331,690546915,996164693,622002119,365458578,58914726,754471413,325568964,174468079,864653806,179505478,710007318,239368906,786603384,921394362,4315153,139587030,842926113,738625799,0,0,0,0,0,0,0,0,0},{863701159,675893233,846451157,977949734,939609883,303894955,634993211,174835232,353894680,648587753,758225838,115509024,219220108,998962878,311770579,255868116,355234347,773628805,867604321,287725516,238942686,850298444,820688464,759587547,166649847,18273833,763676901,86448601,647921271,414408511,138256027,231666657,87105507,823447779,142450448,274348065,602243250,268935154,643359756,39589375,433432436,633664802,49050229,155769984,90339897,6235241,553342616,750385357,71312455,601421726,192311125,260184829,389736124,691314976,963014005,232510118,338752845,781020583,732957759,798441331,240540003,84705800,979804528,748759990,154605345,199546073,504847839,346522010,54130809,456157049,3475229,589137066,595367627,845419697,701990151,640387954,640704669,529984233,349698651,720709195,615816832,72905531,170685675,443098489,351674873,707031843,955173149,437551674,30102462,824811181,779492800,4308998,587683347,29011065,687735072,41385318,997667641,428790372,938668526,275023996,147392467,357226368,633285966,858467200,659336832,932986527,250223609,994874562,65611155,936658387,794619542,224886883,299050918,168084096,270481539,837648705,947012353,384337476,339805727,921674785,268646822,787426747,517845070,333164049,345827289,522731834,624550376,728487559,969918806,539284750,575103529,702389492,128132573,137782562,297958679,920843641,276572556,162639834,97529005,580198988,570847290,647632149,0,0,0,0,0,0,0,0},{828339312,543185748,411981074,695689273,277263759,273377166,793485627,631018404,613146854,17646196,381504371,434985071,953452475,223457372,968762795,946099574,322595527,766478638,705603337,829320534,10039323,919146717,93782714,141800540,378719332,791963843,263800443,220271946,308754084,501089375,465596119,439572649,800778511,774775707,814789853,157548537,6710989,945953061,362048235,580859879,678619823,818316531,384039055,983129684,565211702,403547122,125740844,586281714,805839915,522515102,653038461,745581703,800980047,756796950,136715347,231783066,344945452,730768285,924860225,175112977,706223805,749964187,703250512,161858403,94890930,750086495,223317313,357116949,299706093,882087956,599732991,465820545,201807918,208357033,841000812,787122072,301553158,171933639,904014177,808677200,73857907,654974916,337105736,230091266,604955068,478347980,858223527,488032966,564710832,337955903,996944226,96867528,791369014,841961152,976870154,964509528,384009643,356843921,684288650,588704317,107582354,813915088,380514338,61468388,35186507,735942999,279477135,980837980,35570535,919319182,194613580,717596549,809286936,352928157,599388444,325625596,969265860,625150836,259820326,896672273,555621806,151547629,412170552,903154557,889501760,746050252,908338404,546145484,275892490,290697003,528656438,76427808,781852461,369454561,736375638,12816436,950481089,804071328,525623296,233187479,738778272,707165803,181057157,0,0,0,0,0,0,0},{170172866,680246383,548427131,445773869,678848997,148122481,584925336,831709220,857892001,22491759,817178028,508013712,576464530,302655064,387325302,276528568,347393555,447031,656036746,699253208,184066582,982650914,956518026,775502957,354280182,260591659,878274225,807338436,592452519,352868256,427126601,144175161,263137133,124197956,220078508,184778564,28719950,901785431,921616121,473786796,535113998,960954256,910900054,901661313,249017037,340842825,743345324,858587574,685406131,949241436,122769232,615071147,778621911,819745547,9069048,707456430,988103496,556594262,673922616,859961660,629999079,504348689,854732761,706135295,125010777,739263024,660933883,193414972,860744313,89134598,629199760,635443670,471214942,85428612,576622585,285826097,700836297,188333645,714361976,687262994,505730474,96823690,167878601,786990447,287891337,98298965,61491934,305818039,349927258,490947765,89819707,502618283,31103831,451188535,410550262,402611692,394482586,17594202,811251076,644645696,543067065,23256098,567155514,721743617,762825730,565885751,592226252,882968924,11896692,415751736,447457972,279106575,537453172,643877749,501932814,586567853,571075357,780113481,274470221,598437315,668791282,419741138,209365476,775181884,912971150,988349882,334258052,274013462,622882655,27989687,973609658,20684966,633594608,656857040,734223053,419193808,860149871,437849386,326180175,613179023,94876681,798722388,575762492,267400092,0,0,0,0,0,0},{913393161,955063788,191115936,318624625,88167715,175877768,361514993,157584907,387909305,506548672,444806669,291699370,789107951,329247083,168036423,499222060,603683748,143925496,243548814,375500756,336410439,75368854,140171540,892254323,789485664,761137136,888881252,21673327,552763733,692428309,426737335,435439298,666103611,997135915,165450370,999475425,676295986,192996835,985963200,509844116,445717129,121980553,298830733,215218005,992084284,925394863,742389439,739632414,603270716,106759024,401109213,88225883,10006986,718372056,164236735,737591350,216140730,634905838,925229699,598401853,683284670,21587763,647902163,14612253,504589499,569075746,534250861,933821320,152951780,286430773,293244233,760475294,471603238,314003662,577965460,722375869,137971516,314407929,108493681,523045283,16264305,510984643,688504291,177288381,264718829,654471470,852039435,59175268,110900914,230678017,44729163,190444126,262940746,318869423,654308673,716621719,765737306,257009700,52035098,40037588,272895616,866769192,707185345,659859933,470728929,697856506,537845040,376754092,410133102,915958294,299232150,318442358,340385481,106281801,926828101,409576620,913308698,869356106,934280556,840568033,902304620,458009729,86312178,496406923,565407146,617177137,830683768,635993561,839706993,681887138,554873903,412409180,522239363,892298614,986792437,831434779,16861048,833691370,493392715,122611482,453731261,236491639,661280411,994190328,604400545,0,0,0,0,0},{3005108,813640560,473088383,88592901,391848481,638989820,334877785,289766997,451557290,523002897,596808278,257193597,780425807,154410831,974522583,126740367,584178018,383753358,606876278,732015760,414597718,890341558,7696967,986690887,83085973,841069743,320399050,647447082,61185053,976520187,593063585,630419207,603746577,88399558,904164967,523756838,352594146,218066818,184272358,444071013,116473757,796600237,100331323,528905636,49029797,645567575,51757685,244004127,353989176,216812860,808697267,942690792,776222658,841645481,600005674,730784450,797279900,980469760,414351680,59785499,342402291,147759317,636812860,188056599,33351855,501066111,604999947,365129728,333667683,842577357,485485567,346135539,43927927,53734923,313027451,2679844,570302954,750983611,986815119,918962949,865438035,790303023,798668647,963537670,760319309,645727431,606584804,640500293,898326164,972841172,74290331,58657070,954626005,457702153,255700661,454398627,808332357,693681652,862115647,358025735,696658587,160593995,186458064,609791858,969694014,72555703,783418574,826272299,7822760,194102307,611569708,154083715,815195503,62228111,494785661,834225160,869366695,884556421,335326354,448487786,991701835,200800788,431705574,4344225,165440714,129279033,538791659,335065823,50465704,594887406,717461778,834350623,617488068,505336174,816983432,419935919,379546097,915632962,417341100,728863306,483134960,291754604,395108778,993238673,957060446,22002704,0,0,0,0},{682058711,580851236,292071749,646080262,312106836,377507812,225480303,854980506,858192435,671128712,671203277,446909428,844317731,141295081,590828511,74544950,945327420,563021330,999303231,153691815,686367258,76223590,712806522,774480174,386762121,680292193,523137465,789845654,801034219,337315555,413760415,89582692,382992366,751064897,149673587,959277775,765167160,170078189,263205347,445231559,365677944,671864880,387487238,655468405,118687621,952296260,54500232,501743041,127063339,308393412,70795702,241828632,632128932,518073154,529902464,264676346,319447624,670040310,591636430,605385964,667279765,970954983,100277199,746252295,317139376,601764757,302397230,975266300,24526035,384974442,802842107,558581604,934718470,207315498,988696387,710831218,645863738,116655816,483906116,927500414,714446986,22925219,614283783,988740045,713160762,809388443,141293172,366126746,576352597,256725453,933129391,663401144,998860421,513107649,15573571,878546104,38504659,343296077,456921441,948915313,383694804,298577710,713967068,543645658,563981958,773156326,230186637,455076506,530829139,298640976,14349928,873686268,916185047,84657786,283350955,633545704,44064230,848754587,822009562,116917504,129028241,755726320,885597595,626473941,410354216,463763769,270603395,408538714,873330627,301910872,574263221,171533055,275713771,997427198,608192374,861270318,106602268,347274822,815259136,834126711,418699526,265243422,213142246,375877012,656474060,788900175,88010816,0,0,0},{351609890,254423661,466702341,957889764,393420384,686030605,953001399,750216729,260705062,33827798,337715919,315691950,658437730,808994879,466167189,270562859,553657682,113353404,814750569,440134266,994466217,804919439,468822686,743691428,489732053,151292542,906056760,331736866,433552522,108813709,333691951,633616924,15930208,643653091,999209522,994509966,993031735,314257660,210750217,793446642,365321706,820976104,838953596,163255436,666568903,290975373,446886953,960580755,382448875,527574432,808946744,52483453,738734299,339654229,591435573,307045775,268343262,704507633,146494608,908292133,3576159,888662682,641967720,212368527,424444084,209631278,816339601,728533624,512256963,659337873,36899365,222406179,672672796,6740325,169489034,427499072,205030358,56115606,28205053,48753146,659379145,877213471,391258087,147481614,197411431,442918919,409459137,927445583,735088480,858355834,415028100,703138417,382539760,327343802,705453561,297363513,904743843,542926102,195003294,744779983,742148165,921959808,122534883,482397807,863305954,19880978,416778024,328817548,269945821,240007029,589322732,931408903,664375843,86399726,130172615,449968316,867260799,740638658,432485571,203046732,358355278,552617732,93215860,318483790,878601265,466240249,1077275,405901501,338299808,341037927,371268866,942911418,197180909,449280109,684938139,265255433,728096441,907351417,639064540,989178215,788517108,964318427,799385955,890184000,444164368,188487164,346014203,264032448,0,0},{221808806,300594250,814809359,655515281,671202895,205814539,783207988,557359149,114468973,273038536,438781263,341333803,234155970,787896462,93426291,804214695,27119353,201353494,711294843,14067443,124861728,405491072,292846574,235316876,580644297,231504934,981047079,745929225,898389339,44203181,62507598,200914493,162370410,197105050,495588459,299527109,598831203,445532819,586319722,578789833,914596379,275964715,575736049,55978935,769296874,389330129,905578783,243981259,693111494,451090561,161807149,950510903,137095459,332458012,433931569,92708267,384625494,90254258,339123533,870146044,46253296,54876554,858805868,582087534,785471354,156846688,144968089,839741888,452419411,444982946,694826636,517263220,827754232,18266404,362423403,205373709,543657934,186394148,282545004,748636268,18848234,663011389,373482440,553500678,554891404,170392198,145600388,10363785,822266358,197181892,318507042,727632501,31635955,277174023,214404469,428408657,595366586,942250936,527740716,232597028,563280054,367742565,493814349,180820138,401911834,519767258,181771312,989646184,975039160,599255972,110224309,240823891,832223807,798573737,713305636,903781129,995151456,60200740,639809564,384083639,935032080,604248700,700293350,190348876,158683263,988395976,990668539,620285602,203246561,854217355,704934344,331558664,342133580,599334774,64735120,456755866,719503159,526860719,896859159,697744025,386274819,85609265,217534518,513928401,54074914,941933798,398034462,137348063,528064896,0},{86372691,648199582,614049620,337972846,7198257,375203049,187046971,744147092,487793243,481622337,483034422,749948778,700053850,796351218,867239832,465516283,503146104,8526372,920208520,945594204,831327021,323031660,350371498,924440843,675017456,654643584,744606237,46099604,74315639,890686859,577439845,993794029,98930784,57090225,221412627,162640747,247808650,789850236,941921756,309776754,463955731,370917573,679515964,808494078,851512641,129479182,117868270,225828215,667720162,241325373,569261749,564367599,76765800,252783663,836238692,318526344,895685401,947462453,661265210,828169994,14788939,680612124,850822084,618360169,654987325,829356479,366043964,162400154,961964399,915987962,46405926,685773656,756116706,178024451,313897159,330388571,867896121,625706699,145093701,43336065,874196287,890371605,175628393,373511682,937913835,726769215,829482159,555540655,678722667,570517138,748511259,156399329,799636751,420498439,422274198,748110673,741825687,569232513,186281198,314412702,198520805,858315957,200078146,146589795,658046371,940537661,181404299,487735919,618791709,293391438,210310934,771695696,178842827,219855820,127493105,421823398,402578221,422225286,69143413,429278451,997449631,609035925,722802190,641632408,44042188,762523483,194929330,927497156,244249241,69167991,587394175,826387562,139136383,289440900,682136313,146220769,824120240,383123738,397868571,872081558,594824609,624885580,899072594,657185803,178043352,229097485,805347424,833515785,529436833,528064896}};\n\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tmemset(c,-1,sizeof(c));\n\tint n, m; cin>>n>>m;\n\tif(n>150&&m>200)\n\t{\n\t\tcout<<ans[m-201][n-151]<<'\\n';\n\t\treturn 0;\n\t}\n\tg[0][0] = 1;\n\tg[1][1] = 1;\n\tfor(int i = 2; i <= m; i++) g[i][1] = 1;\n\tfor(int j = 2; j <= n; j++)\n\t{\n\t\tfor(int i = j; i <= m; i++)\n\t\t{\n\t\t\tfor(int k = 1; k + j - 1 <= i; k++)\n\t\t\t{\n\t\t\t\tadd(g[i][j], mult(g[i-k][j-1], choose(i, k)));\n\t\t\t}\n\t\t}\n\t}\n\t//cerr<<g[10][3]<<'\\n';\n\tdp[0][1] = 1;\n\tfor(int i = 0; i < m; i++)\n\t{\n\t\tfor(int j = 1; j <= min(i+1,n); j++)\n\t\t{\n\t\t\tint val = dp[i][j];\n\t\t\tfor(int l = 1; l <= m - i; l++)\n\t\t\t{\n\t\t\t\tfor(int k = 0; k <= min(l - 1, n - j); k++)\n\t\t\t\t{\n\t\t\t\t\tadd(dp[i+l][j+k], mult(val, mult(choose(n-j,k),mult(g[l-1][k], j))));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << dp[m][n] << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <iomanip>\n#include <climits>\n#include <limits>\n#include <algorithm>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <list>\n#include <stack>\n#include <string>\n#include <functional>\n#include <numeric>\n#include <map>\n#include <set>\n#include <cstdlib>\n#include <bitset>\n#include <unordered_map>\n#include <random>\n#include <cmath>\n#include <complex>\n\nusing namespace std;\n\ntypedef long long int ll;\ntypedef vector<int> vi;\ntypedef vector<vector<int>> vvi;\ntypedef pair<int, int> P;\ntypedef pair<ll, ll> Pll;\ntypedef vector<ll> vll;\ntypedef vector<vector<ll>> vvll;\n\nconst int INFL = (int)1e9;\nconst ll INFLL = (ll)1e18;\nconst double INFD = numeric_limits<double>::infinity();\nconst double PI = 3.14159265358979323846;\n#define Loop(i, n) for(int i = 0; i < (int)n; i++)\n#define Loopll(i, n) for(ll i = 0; i < (ll)n; i++)\n#define Loop1(i, n) for(int i = 1; i <= (int)n; i++)\n#define Loopll1(i, n) for(ll i = 1; i <= (ll)n; i++)\n#define Loopr(i, n) for(int i = (int)n - 1; i >= 0; i--)\n#define Looprll(i, n) for(ll i = (ll)n - 1; i >= 0; i--)\n#define Loopr1(i, n) for(int i = (int)n; i >= 1; i--)\n#define Looprll1(i, n) for(ll i = (ll)n; i >= 1; i--)\n#define Loopitr(itr, container) for(auto itr = container.begin(); itr != container.end(); itr++)\n#define printv(vector) Loop(i, vector.size()) { cout << vector[i] << \" \"; } cout << endl;\n#define printmx(matrix) Loop(i, matrix.size()) { Loop(j, matrix[i].size()) { cout << matrix[i][j] << \" \"; } cout << endl; }\n#define rnd(d) (ll)((double)(d) + (d >= 0 ? 0.5 : -0.5))\n#define floorsqrt(x) ((ll)sqrt((double)x) + ((ll)sqrt((double)x) * (ll)sqrt((double)x) <= (ll)(x) ? 0 : -1))\n#define ceilsqrt(x) ((ll)sqrt((double)x) + ((ll)x <= (ll)sqrt((double)x) * (ll)sqrt((double)x) ? 0 : 1))\n#define ceildiv(a, b) ((ll)(a) / (ll)(b) + ((ll)(a) % (ll)(b) == 0 ? 0 : 1))\n#define bitmanip(m,val) static_cast<bitset<(int)m>>(val)\n\n/*******************************************************/\n\nnamespace mod_op {\n\n\tconst ll MOD = (ll)1e9 + 7;\n\n\tclass Extended_Euclid {\n\tprivate:\n\t\tll m, n;\n\t\tvvll mx_multiply(vvll mx1, vvll mx2) {\n\t\t\tvvll ret(mx1.size(), vll(mx2[0].size(), 0));\n\t\t\tLoop(i, mx1.size()) {\n\t\t\t\tLoop(j, mx1[0].size()) {\n\t\t\t\t\tLoop(k, mx2[0].size()) {\n\t\t\t\t\t\tret[i][j] += mx1[i][k] * mx2[k][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\tpublic:\n\t\t// solve x, y s.t. mx + ny = gcd(m,n)\n\t\tll x, y, gcd;\n\t\tExtended_Euclid(ll M, ll N) {\n\t\t\tm = M;\n\t\t\tn = N;\n\t\t\tvll r(100), k(100);\n\t\t\tbool swapflag = false, m_negflag = false, n_negflag = false;\n\t\t\tif (m < n) { swap(m, n); swapflag = true; }\n\t\t\tif (m < 0) { m *= -1; m_negflag = true; }\n\t\t\tif (n < 0) { n *= -1; n_negflag = true; }\n\t\t\tr[0] = m;\n\t\t\tr[1] = n;\n\t\t\tint h = 1;\n\t\t\twhile (1) {\n\t\t\t\tk[h - 1] = r[h - 1] / r[h];\n\t\t\t\tr[h + 1] = r[h - 1] % r[h];\n\t\t\t\tif (r[h + 1] == 0) break;\n\t\t\t\th++;\n\t\t\t}\n\t\t\tgcd = r[h];\n\t\t\tvvll mx1 = { { 0, 1 },{ 1, (-1) * k[h - 1] } };\n\t\t\tLoopr(i, h - 1) {\n\t\t\t\tvvll mx2 = { { 0, 1 },{ 1, (-1) * k[i] } };\n\t\t\t\tmx1 = mx_multiply(mx1, mx2);\n\t\t\t}\n\t\t\tx = mx1[0][0];\n\t\t\ty = mx1[0][1];\n\t\t\tif (n_negflag) { n *= -1; y *= -1; }\n\t\t\tif (m_negflag) { m *= -1; x *= -1; }\n\t\t\tif (swapflag) { swap(m, n); swap(x, y); }\n\t\t}\n\t};\n\n\tclass modll {\n\tprivate:\n\t\tll val;\n\t\tinline ll modify(ll x) { ll ret = x % MOD; if (ret < 0) ret += MOD; return ret; }\n\t\tinline ll inv(ll x) { if (x == 0) return 1 / x; Extended_Euclid ee(x, -MOD); return modify(ee.x); }\n\tpublic:\n\t\tmodll(ll init = 0) { val = modify(init); return; }\n\t\tmodll(const modll& another) { val = another.val; return; }\n\t\tinline modll& operator=(const modll &another) { val = another.val; return *this; }\n\t\tinline modll operator+(const modll &x) { return (val + x.val) % MOD; }\n\t\tinline modll operator-(const modll &x) { return (val - x.val) % MOD; }\n\t\tinline modll operator*(const modll &x) { return (val * x.val) % MOD; }\n\t\tinline modll operator/(const modll &x) { return (val * inv(x.val)) % MOD; }\n\t\tinline modll& operator+=(const modll &x) { val = (val + x.val) % MOD; return *this; }\n\t\tinline modll& operator-=(const modll &x) { val = (val - x.val) % MOD; return *this; }\n\t\tinline modll& operator*=(const modll &x) { val = (val * x.val) % MOD; return *this; }\n\t\tinline modll& operator/=(const modll &x) { val = (val * inv(x.val)) % MOD; return *this; }\n\t\tfriend inline istream& operator >> (istream &is, modll& x) { is >> x.val; return is; }\n\t\tfriend inline ostream& operator << (ostream &os, modll& x) { os << x.val; return os; }\n\t\tll get_val() { return val; }\n\t};\n\n\tmodll pow(modll n, ll p) {\n\t\tmodll ret;\n\t\tif (p == 0) ret = 1;\n\t\telse if (p == 1) ret = n;\n\t\telse {\n\t\t\tret = pow(n, p / 2);\n\t\t\tret *= ret;\n\t\t\tif (p % 2 == 1) ret *= n;\n\t\t}\n\t\treturn ret;\n\t}\n}\n\nusing namespace mod_op;\n\nint main() {\n\tint n, m; cin >> n >> m;\n\tvector<vector<modll>> dp(301, vector<modll>(301, 0));\n\tdp[1][0] = 1;\n\tLoop(i, m) {\n\t\tvector<vector<modll>> dpbuf(301, vector<modll>(301, 0));\n\t\tLoop(j, 301) {\n\t\t\tLoop(k, 301) {\n\t\t\t\tif (j + k < 301) dpbuf[j + k][0] += dp[j][k] * j;\n\t\t\t\tdpbuf[j][k] += dp[j][k] * k;\n\t\t\t\tif (k + 1 < 301 && n - j - k > 0) dpbuf[j][k + 1] += dp[j][k] * (n - j - k);\n\t\t\t}\n\t\t}\n\t\tdp = dpbuf;\n\t}\n\tcout << dp[n][0] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define fi first\n#define se second\n#define pb push_back\n#define mp make_pair\n#define inf 1000000005\n#define all(a) (a).begin(), (a).end()\n#define ms(a,x) memset(a, x, sizeof(a))\n#define mod 1000000007\n#define sz(a) ((ll)(a).size())\n\ntemplate<class T> int getbit(T s, int i) { return (s >> i) & 1; }\ntemplate<class T> T onbit(T s, int i) { return s | (T(1) << i); }\ntemplate<class T> T offbit(T s, int i) { return s & (~(T(1) << i)); }\ntemplate<class T> int cntbit(T s) { return __builtin_popcount(s);}\n#define Rep(i,n) for(int i = 0; i < (n); ++i)\n#define Repd(i,n) for(int i = (n)-1; i >= 0; --i)\n#define For(i,a,b) for(int i = (a); i <= (b); ++i)\n#define Ford(i,a,b) for(int i = (a); i >= (b); --i)\n\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef long double ld;\n#define eps 1e-9\ntypedef pair<int, int> II;\ntypedef pair<ll, ll> LL;\ntemplate<class T> T gcd(T a, T b){ T r; while (b != 0) { r = a % b; a = b; b = r; } return a;}\ntemplate<class T> T lcm(T a, T b) { return a / gcd(a, b) * b; }\n#define PI (2 * acos((ld)0))\n#define linf (1ll << 60)\n#define y1 y32432\n#define y0 y435346\n\n#define maxn 305\n\nll f[maxn][maxn], g[maxn][maxn];\nint n, m;\n\nvoid add(ll &x, ll y){\n\tx += y;\n\tif(x >= mod) x -= mod;\n}\n\nint main()\n{\n//\tgen();\n//\tfreopen(\"in.txt\", \"r\", stdin);\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n\n    ms(f, 0); ms(g, 0);\n    cin >> n >> m;\n    f[1][1] = 1;\n\n    Rep(run, m){\n    \tFor(i, 1, n) For(j, 0, n) {\n    \t\tg[i][j] = f[i][j];\n    \t\tf[i][j] = 0;\n    \t}\n    \tFor(i, 1, n) For(j, 0, i) if(g[i][j]){\n    \t\tadd(f[i + 1][j], g[i][j] * (n - i) % mod);\n    \t\tadd(f[i][i], g[i][j] * j % mod);\n    \t\tadd(f[i][j], g[i][j] * (i - j) % mod);\n    \t}\n    }\n\n    cout << f[n][n] << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define _p(...) (void)printf(__VA_ARGS__)\n#define forr(x,arr) for(auto&& x:arr)\n#define _overload3(_1,_2,_3,name,...) name\n#define _rep2(i,n) _rep3(i,0,n)\n#define _rep3(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload3(__VA_ARGS__,_rep3,_rep2,)(__VA_ARGS__)\n#define _rrep2(i,n) _rrep3(i,0,n)\n#define _rrep3(i,a,b) for(int i=int(b)-1;i>=int(a);i--)\n#define rrep(...) _overload3(__VA_ARGS__,_rrep3,_rrep2,)(__VA_ARGS__)\n#define all(x) (x).begin(), (x).end()\n#define bit(n) (1LL<<(n))\n#define sz(x) ((int)(x).size())\n#define fst first\n#define snd second\nusing ll=long long;using pii=pair<int,int>;using vb=vector<bool>;\nusing vi=vector<int>;using vvi=vector<vi>;using vvvi=vector<vvi>;\nusing vl=vector<ll>;using vvl=vector<vl>;using vvvl=vector<vvl>;\nusing vd=vector<double>;using vvd=vector<vd>;using vvvd=vector<vvd>;\nusing vpii=vector<pii>;using vvpii=vector<vpii>;using vvvpii=vector<vvpii>;\ntemplate <typename T> T read() {T t; cin >> t; return t;}\n\nconst int mod = 1000000007;\n\ntemplate<int MOD>\nstruct Mint {\n  int x;\n  Mint() : x(0) {}\n  Mint(int y) : x(y >= 0 ? y % MOD : MOD - (-y) % MOD) {}\n  Mint(signed long long sll) : x(sll % MOD) { if (x < 0) x += MOD; }\n  Mint &operator+=(const Mint &rhs){ if((x += rhs.x) >= MOD) x -= MOD; return *this; }\n  Mint &operator-=(const Mint &rhs){ if((x += MOD - rhs.x) >= MOD) x -= MOD; return *this; }\n  Mint &operator*=(const Mint &rhs){ x = 1LL*x*rhs.x % MOD; return *this; }\n  Mint &operator/=(const Mint &rhs){ x = (1LL*x*rhs.inv().x) % MOD; return *this; }\n  Mint operator-() const { return Mint(-x); }\n  Mint operator+(const Mint &rhs) const { return Mint(*this) += rhs; }\n  Mint operator-(const Mint &rhs) const { return Mint(*this) -= rhs; }\n  Mint operator*(const Mint &rhs) const { return Mint(*this) *= rhs; }\n  Mint operator/(const Mint &rhs) const { return Mint(*this) /= rhs; }\n  bool operator<(const Mint &rhs) const { return x < rhs.x; }\n  Mint inv() const {\n    signed a = x, b = MOD, u = 1, v = 0, t;\n    while(b){ t = a / b; a -= t * b; swap(a, b); u -= t * v; swap(u, v); }\n    return Mint(u);\n  }\n  Mint operator^(unsigned long long t) const {\n    Mint e = *this, res = 1;\n    for(; t; e *= e, t>>=1) if (t & 1) res *= e;\n    return res;\n  }\n};\ntemplate<int MOD> ostream &operator<<(ostream &os, const Mint<MOD> &rhs) { return os << rhs.x; }\ntemplate<int MOD> istream &operator>>(istream &is, Mint<MOD> &rhs) { long long s; is >> s; rhs = Mint<MOD>(s); return is; };\n\nusing mint = Mint<mod>;\nusing vm=vector<mint>;using vvm=vector<vm>;using vvvm=vector<vvm>;\n\nvoid Main() {\n  int n = read<int>();\n  int m = read<int>();\n\n  vvvm dp(m+1, vvm(n+1, vm(n+1)));\n  dp[0][1][1] = 1;\n\n  rep(i, m) {\n    rep(j, 1, n+1) rep(k, 1, j+1) if (dp[i][j][k].x != 0) {\n      // 既に行っている町(町1には行けない)に行く\n      dp[i+1][j][k] += dp[i][j][k] * (j - k);\n\n      // 既に行っている町(町1に行ける)に行く\n      dp[i+1][j][j] += dp[i][j][k] * k;\n\n      // 新しい町に行く\n      if (n - j) dp[i+1][j+1][k] += dp[i][j][k] * (n - j);\n    }\n  }\n\n  cout << dp[m][n][n] << endl;;\n}\nint main() { cin.tie(nullptr); ios::sync_with_stdio(false); Main(); return 0; }\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i=a;i<b;i++)\n\n\n\ntypedef long long ll;\n#define MOD 1000000007\nint N, M;\n//-----------------------------------------------------------------\nll dp[303][303][303];\nint main() {\n\tcin >> N >> M;\n\n\tdp[0][1][1] = 1;\n\trep(i, 0, M) rep(j, 0, N + 1) rep(k, 0, N + 1) {\n\t\tdp[i + 1][j + 1][k] = (dp[i + 1][j + 1][k] + dp[i][j][k] * (ll)(N - j)) % MOD;\n\t\tif(0 < j - k) dp[i + 1][j][k] = (dp[i + 1][j][k] + dp[i][j][k] * (ll)(j - k)) % MOD;\n\t\tdp[i + 1][j][j] = (dp[i + 1][j][j] + dp[i][j][k] * (ll)k) % MOD;\n\t}\n\n\tcout << dp[M][N][N] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> l_l;\ntypedef pair<int, int> i_i;\ntemplate<class T>\ninline bool chmax(T &a, T b) {\n    if(a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T>\ninline bool chmin(T &a, T b) {\n    if(a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\n#define EPS (1e-7)\n#define INF (1e9)\n#define PI (acos(-1))\nconst ll mod = 1000000007;\nll N, M;\nll Prev[605][605][2];\nll Next[605][605][2];\n\nint main() {\n    //cout.precision(10);\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cin >> N >> M;\n    Prev[1][0][0] = 1;\n    ll minus;\n    while(M--) {\n        if(M == 0) minus = Prev[N][0][0] * N % mod;\n        for(int i = 0; i <= N; i++) {\n            for(int j = 0; j <= N; j++) {\n                for(int k = 0; k <= 1; k++) {\n                    Next[i][j][k] = 0;\n                }\n            }\n        }\n        for(ll i = 0; i <= N; i++) {\n            for(ll j = 0; j <= N; j++) {\n                Next[i][j][0] += Prev[i][j][0] * i;\n                Next[i][j][1] += Prev[i][j][0] * j;\n                Next[i][j+1][1] += Prev[i][j][0] * (N - i - j);\n                Next[i+j][0][0] += Prev[i][j][1] * i;\n                Next[i][j][1] += Prev[i][j][1] * j;\n                Next[i][j+1][1] += Prev[i][j][1] * (N - i - j);\n                Next[i][j][0] %= mod;\n                Next[i][j][1] %= mod;\n                Next[i][j+1][1] %= mod;\n                Next[i+j][0][0] %= mod;\n            }\n        }\n        swap(Next, Prev);\n        /*\n        cerr << endl;\n        cerr << M << endl;\n        for(int i = 0; i <= N; i++) {\n            for(int j = 0; j <= N; j++) {\n                cerr << i << \" \" << j << \" \" << Prev[i][j][0] << \" \" << Prev[i][j][1] << endl;\n            }\n        }\n        */\n    }\n    cerr << minus << endl;\n    cerr << Prev[N][0][1] << endl;\n    //cout << (Prev[N][0][0] - minus + mod) % mod << endl;\n    cout << (Prev[N][0][0] + mod) % mod << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n#define ALL(c) (c).begin(), (c).end()\n\ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<VI> VVI;\ntypedef vector<VL> VVL;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\n\nconst ll mod = 1e9 + 7;\nll dp[301][301][301];\n\nint main(void){\n    int n, m;\n    cin >> n >> m;\n    dp[0][1][0] = 1;\n    REP(i,m) REP(j,n+1) REP(k,n+1){\n        dp[i+1][j][k] = (dp[i+1][j][k] + k * dp[i][j][k]) % mod;\n        dp[i+1][j+k][0] = (dp[i+1][j+k][0] + j * dp[i][j][k]) % mod;\n        dp[i+1][j][k+1] = (dp[i+1][j][k+1] + (n - k - j) * dp[i][j][k]) % mod;\n    }\n\n    // FOR(i,1,m){\n    //     cout << i << endl;\n    //     REP(j,n+1){\n    //         REP(k,n+1) cout << dp[i][j][k] << \" \";\n    //         cout << endl;\n    //     }\n    //     cout << endl;\n    // }\n    cout << dp[m][n][0] << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <cstdio>\n#include <map>\n#include <numeric>\n#include <cmath>\n#include <set>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <complex>\n#include <string.h>\n#include <unordered_set>\n#include <unordered_map>\n#include <bitset>\n#include <iomanip>\n#include <sys/time.h>\n#include <tuple>\n#include <random>\nusing namespace std;\n\n#define endl '\\n'\n#define ALL(v) (v).begin(), (v).end()\n#define RALL(v) (v).rbegin(), (v).rend()\n#define UNIQ(v) (v).erase(unique((v).begin(), (v).end()), (v).end())\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> P;\ntypedef complex<double> comp;\ntypedef vector< vector<ld> > matrix;\nstruct pairhash {\npublic:\n    template<typename T, typename U>\n    size_t operator()(const pair<T, U> &x) const {\n\tsize_t seed = hash<T>()(x.first);\n\treturn hash<U>()(x.second) + 0x9e3779b9 + (seed<<6) + (seed>>2);\n    }\n};\nconst int inf = 1e9 + 9;\nconst ll mod = 1e9 + 7;\nconst double eps = 1e-8;\nconst double pi = acos(-1);\n\nll N, M;\nll dp[310][310][310];\n\nll mod_pow(ll x, ll n) {\n    ll res = 1;\n    while (n > 0) {\n        if (n & 1) res = (res * x) % mod;\n        x = (x * x) % mod;\n        n >>= 1;\n    }\n    return res;\n}\n\nll mod_inverse(ll x) {\n    return mod_pow(x, mod-2);\n}\nconst int max_n = 310;\nll fact[max_n];\nll fact_inv[max_n];\nvoid calc_fact() {\n    fact[0] = 1;\n    for (ll i = 1; i < max_n; i++)\n        fact[i] = (fact[i-1] * i) % mod;\n    fact_inv[max_n-1] = mod_inverse(fact[max_n-1]);\n    for (ll i = max_n-2; i >= 0; i--)\n        fact_inv[i] = (fact_inv[i+1] * (i+1)) % mod;\n}\n\n\nll calc(ll n, ll k, ll m) {\n    if (n == N && k ==0 && m == 0) return 1;\n    if (!(n+k <= N && m >= 0)) return 0;\n    if (dp[n][k][m] < 0) {\n        dp[n][k][m] = (n * calc(n+k, 0, m-1) + calc(n, k+1, m-1)) % mod;\n        dp[n][k][m] = (dp[n][k][m] + k * calc(n, k, m-1)) % mod;\n    }\n    return dp[n][k][m];\n}\n\nll solve() {\n    calc_fact();\n    memset(dp, -1, sizeof(dp));\n    return calc(1, 0, M) * fact[N-1] % mod;\n}\n\nvoid input() {\n    cin >> N >> M;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout << fixed << setprecision(15);\n\n    input();\n    cout << solve() << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define dbg(...) do{cerr<<__LINE__<<\": \";dbgprint(#__VA_ARGS__, __VA_ARGS__);}while(0);\n\nusing namespace std;\n\nnamespace std{template<class S,class T>struct hash<pair<S,T>>{size_t operator()(const pair<S,T>&p)const{return ((size_t)1e9+7)*hash<S>()(p.first)+hash<T>()(p.second);}};template<class T>struct hash<vector<T>>{size_t operator()(const vector<T> &v)const{size_t h=0;for(auto i : v)h=h*((size_t)1e9+7)+hash<T>()(i)+1;return h;}};}\ntemplate<class T>ostream& operator<<(ostream &os, const vector<T> &v){os<<\"[ \";rep(i,v.size())os<<v[i]<<(i==v.size()-1?\" ]\":\", \");return os;}template<class T>ostream& operator<<(ostream &os,const set<T> &v){os<<\"{ \"; for(const auto &i:v)os<<i<<\", \";return os<<\"}\";}\ntemplate<class T,class U>ostream& operator<<(ostream &os,const map<T,U> &v){os<<\"{\";for(const auto &i:v)os<<\" \"<<i.first<<\": \"<<i.second<<\",\";return os<<\"}\";}template<class T,class U>ostream& operator<<(ostream &os,const pair<T,U> &p){return os<<\"(\"<<p.first<<\", \"<<p.second<<\")\";}\nvoid dbgprint(const string &fmt){cerr<<endl;}template<class H,class... T>void dbgprint(const string &fmt,const H &h,const T&... r){cerr<<fmt.substr(0,fmt.find(\",\"))<<\"= \"<<h<<\" \";dbgprint(fmt.substr(fmt.find(\",\")+1),r...);}\ntypedef long long ll;typedef vector<int> vi;typedef pair<int,int> pi;const int inf = (int)1e9;const double INF = 1e12, EPS = 1e-9;\n\nconst int mod = 1e9 + 7;\nint n, m, dp[2][301][301];\n\nint main(){\n\tcin.tie(0); cin.sync_with_stdio(0);\n\t\n\tcin >> n >> m;\n\tint cur = 0, next = 1;\n\tdp[cur][1][1] = 1;\n\t\n\trep(i, m){\n\t\tmemset(dp[next], 0, sizeof(dp[next]));\n\t\trep(j, n+1) rep(k, n+1) if(dp[cur][j][k]){\n\t\t\t\n\t\t\t//1に戻れるところにいく\n\t\t\t(dp[next][j][j] += dp[cur][j][k] * (ll)k % mod) %= mod;\n\t\t\t\n\t\t\t//1からすでにいけるところのうち1に戻れないところにいく\n\t\t\t(dp[next][j][k] += dp[cur][j][k] * (ll)(j - k) % mod) %= mod;\n\t\t\t\n\t\t\t//1からいけなかったところにいく\n\t\t\tif(j + 1 <= n)\n\t\t\t(dp[next][j + 1][k] += dp[cur][j][k] * (ll)(n - j) % mod) %= mod;\n\t\t}\n\t\tswap(cur, next);\n\t}\n\tcout << dp[cur][n][n] << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define all(vec) vec.begin(), vec.end()\nusing namespace std;\nusing ll = long long;\nusing P = pair<ll, ll>;\nconstexpr ll INF = (1LL << 30) - 1LL;\nconstexpr ll LINF = (1LL << 60) - 1LL;\nconstexpr double eps = 1e-9;\nconstexpr ll MOD = 1000000007LL;\ntemplate <typename T>\nbool chmin(T& a, T b) {\n    if(a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n};\ntemplate <typename T>\nbool chmax(T& a, T b) {\n    if(a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n};\ntemplate <typename T>\nostream& operator<<(ostream& os, vector<T> v) {\n    for(int i = 0; i < v.size(); i++) {\n        os << v[i] << (i + 1 == v.size() ? \"\\n\" : \" \");\n    }\n    return os;\n}\ntemplate <typename T>\nvector<T> make_v(size_t a) {\n    return vector<T>(a);\n}\ntemplate <typename T, typename... Ts>\nauto make_v(size_t a, Ts... ts) {\n    return vector<decltype(make_v<T>(ts...))>(a, make_v<T>(ts...));\n}\ntemplate <typename T, typename V>\ntypename enable_if<is_class<T>::value == 0>::type fill_v(T& t, const V& v) {\n    t = v;\n}\ntemplate <typename T, typename V>\ntypename enable_if<is_class<T>::value != 0>::type fill_v(T& t, const V& v) {\n    for(auto& e : t) {\n        fill_v(e, v);\n    }\n};\ntemplate <ll mod>\nstruct modint {\n    ll val;\n    inline ll extgcd(ll a, ll b, ll& x, ll& y) {\n        if(a < b) {\n            return extgcd(b, a, y, x);\n        }\n        if(b == 0) {\n            x = 1, y = 0;\n            return a;\n        }\n        ll d = extgcd(b, a % b, y, x);\n        y -= a / b * x;\n        return d;\n    }\n    inline ll minv(ll k) {\n        ll x = 0, y = 0;\n        extgcd(k, mod, x, y);\n        if(x < 0) {\n            x += mod;\n        } else if(x == mod) {\n            x = 0;\n        }\n        return x;\n    }\n    inline ll mpow(ll n) {\n        ll res = 1, x = val;\n        while(n > 0) {\n            if(n & 1) {\n                res *= x;\n                res %= mod;\n            }\n            x = x * x % mod;\n            n >>= 1;\n        }\n        return res;\n    }\n    constexpr modint() : val(0) {}\n    constexpr modint(ll x) { val = (x + mod) % mod; }\n    modint inv() { return modint(minv(val)); }\n    modint operator+(const modint& to) const { return modint(val + to.val); }\n    modint operator-(const modint& to) const { return modint(val - to.val); }\n    modint operator*(const modint& to) const { return modint(val * to.val); }\n    modint operator/(const modint& to) const {\n        return modint(val * minv(to.val));\n    }\n    template <class T>\n    explicit operator T() {\n        return T(val);\n    }\n    template <typename T>\n    modint operator+(const T& to) const {\n        return modint(val + to);\n    }\n    template <typename T>\n    modint operator-(const T& to) const {\n        return modint(val - to);\n    }\n    template <typename T>\n    modint operator*(const T& to) const {\n        return modint(val * to);\n    }\n    template <typename T>\n    modint operator/(const T& to) const {\n        return modint(val * minv(to));\n    }\n    modint& operator++() { return *this = modint(val + 1); }\n    modint& operator--() { return *this = modint(val - 1); }\n    template <typename T>\n    modint& operator+=(const T& to) {\n        return *this = *this + to;\n    }\n    template <typename T>\n    modint& operator-=(const T& to) {\n        return *this = *this - to;\n    }\n    template <typename T>\n    modint& operator*=(const T& to) {\n        return *this = *this * to;\n    }\n    template <typename T>\n    modint& operator/=(const T& to) {\n        return *this = *this / to;\n    }\n    bool operator==(const modint& to) const { return val == to.val; }\n    bool operator!=(const modint& to) const { return val != to.val; }\n    bool operator>(const modint& to) const { return val > to.val; }\n    bool operator>=(const modint& to) const { return val >= to.val; }\n    bool operator<(const modint& to) const { return val < to.val; }\n    bool operator<=(const modint& to) const { return val <= to.val; }\n};\nusing mint = modint<MOD>;\nvector<mint> f, fi;\nvoid comb(int n) {\n    f.resize(n + 10);\n    fi.resize(n + 10);\n    f[0] = 1;\n    for(ll i = 1; i <= n; i++) {\n        f[i] = f[i - 1] * i;\n    }\n    fi[n] = f[n].inv();\n    for(ll i = n - 1; i >= 0; i--) {\n        fi[i] = fi[i + 1] * (i + 1LL);\n    }\n}\nmint ncr(ll n, ll r) {\n    if(n < r || n < 0 || r < 0) {\n        return 0;\n    }\n    return f[n] * fi[r] * fi[n - r];\n}\ninline mint mpow(mint x, ll n) {\n    mint res = 1;\n    while(n > 0) {\n        if(n & 1) {\n            res *= x;\n        }\n        x = x * x;\n        n >>= 1;\n    }\n    return res;\n}\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    ll n, m;\n    cin >> n >> m;\n    auto dp = make_v<mint>(m + 10, n + 10, n + 10);\n    dp[0][n - 1][1] = 1;\n    for(ll i = 1; i <= m; i++) {\n        for(ll j = 0; j < n; j++) {\n            mint s = 0;\n            for(ll k = n; k >= 1; k--) {\n                s += dp[i - 1][j][k] * (n - j - k + 1LL);\n            }\n            for(ll k = 1; k <= n; k++) {\n                dp[i][j][k] += dp[i - 1][j + 1][k - 1] * (j + 1LL);\n                if(k == 1) {\n                    dp[i][j][k] += s;\n                } else {\n                    dp[i][j][k] += dp[i - 1][j][k] * (k - 1LL);\n                }\n            }\n        }\n    }\n    cout << dp[m][0][1].val << endl;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define Mod 1000000007\n\nint main()\n{\t\n\tint N, M;\n\tscanf(\"%d %d\", &N, &M);\n\t\n\tint i, j, k;\n\tlong long dp[2][302][302] = {};\n\tfor (k = 1, dp[0][1][1] = 1; k <= M; k++) {\n\t\tfor (i = 1; i <= N; i++) {\n\t\t\tfor (j = 1; j <= i; j++) {\t\t\t\t\n\t\t\t\tdp[k%2][i+1][j] += dp[1-k%2][i][j] * (N - i);\n\t\t\t\tdp[k%2][i][i] += dp[1-k%2][i][j] * j;\n\t\t\t\tdp[k%2][i][j] += dp[1-k%2][i][j] * (i - j);\n\t\t\t\t\n\t\t\t\tdp[1-k%2][i][j] = 0;\n\t\t\t\tdp[k%2][i][j] %= Mod;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tprintf(\"%lld\\n\", dp[M%2][N][N]);\n\tfflush(stdout);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define Mod 1000000007\n\nint main()\n{\t\n\tint N, M;\n\tscanf(\"%d %d\", &N, &M);\n\t\n\tint i, j, k;\n\tlong long dp[302][302] = {}, tmp;\n\tfor (k = 1, dp[1][1] = 1; k <= M; k++) {\n\t\tfor (i = k; i >= 1; i--) {\n\t\t\tfor (j = i; j >= 1; j--) {\n\t\t\t\ttmp = dp[i][j] % Mod;\n\t\t\t\tdp[i][j] = 0;\n\t\t\t\tdp[i+1][j] += tmp * (N - i);\n\t\t\t\tdp[i][i] += tmp * j;\n\t\t\t\tdp[i][j] += tmp * (i - j);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tprintf(\"%lld\\n\", dp[N][N] % Mod);\n\tfflush(stdout);\n\treturn 0;\n}"
  },
  {
    "language": "Julia",
    "code": "N, M = map(x->parse(Int,x), split(rstrip(readline(STDIN), '\\n')))\n# one way path from 1, no path from 1\nstatus_mat = zeros(Int64, (N, N))\nstatus_mat[1, N] = 1\n\nbothM = zeros(Int64, (N, N))\nfor i in 1:N\n    for j in 1:N\n        bothM[i, j] = N-i-j+2\n    end\nend\n\ndiagM = zeros(Int64, (N, N))\nfor i in 1:N\n    diagM[i, i] = i - 1\nend\n\n\n\nfunction update_status_mat(status_mat)\n    new_status_mat = *(diagM, status_mat)\n    new_status_mat[1, :] += reshape(reducedim(+, (bothM.*status_mat), 1), N)\n    new_status_mat[2:N, 1:(N-1)] += *(status_mat, diagM)[1:(N-1), 2:N]\n    return new_status_mat % 1000000007\nend\n\nfor m in 1:M\n    status_mat = update_status_mat(status_mat)\nend\n\nprintln(status_mat[1,1])\n\n"
  },
  {
    "language": "Julia",
    "code": "N, M = map(x->parse(Int,x), split(readline(STDIN)))\n# one way path from 1, no path from 1\nstatus_mat = zeros(Int64, (N, N))\nstatus_mat[1, N] = 1\n \nbothM = zeros(Int64, (N, N))\nfor i in 1:N\n    for j in 1:N\n        bothM[i, j] = N-i-j+2\n    end\nend\n \ndiagM = zeros(Int64, (N, N))\nfor i in 1:N\n    diagM[i, i] = i - 1\nend\n \n \n \nfunction update_status_mat(status_mat)\n    new_status_mat = *(diagM, status_mat)\n    new_status_mat[1, :] += reshape(reducedim(+, (bothM.*status_mat), 1), N)\n    new_status_mat[2:N, 1:(N-1)] += *(status_mat, diagM)[1:(N-1), 2:N]\n    return new_status_mat % 1000000007\nend\n \nfor m in 1:M\n    status_mat = update_status_mat(status_mat)\nend\n \nprintln(status_mat[1,1])"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskF solver = new TaskF();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskF {\n        public int n;\n        public int m;\n        public int mod = 1000000007;\n\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            n = in.nextInt();\n            m = in.nextInt();\n            long[][][] dp = new long[2][n + 1][n + 1];\n            dp[0][n][0] = 1;\n            for (int slots = 1; slots <= m; slots++) {\n                int cur = slots % 2, prev = 1 - cur;\n                for (int x = 0; x <= n; x++) {\n                    for (int y = 0; y <= n; y++) {\n                        dp[cur][x][y] = 0;\n                        if (x > 0 && x + y <= n) dp[cur][x][y] += x * dp[prev][x + y][0];\n                        if (y > 0) dp[cur][x][y] += y * dp[prev][x][y];\n                        if (n - x - y > 0 && y + 1 <= n) dp[cur][x][y] += (n - x - y) * dp[prev][x][y + 1];\n                        dp[cur][x][y] %= mod;\n                    }\n                }\n            }\n            out.println(dp[m % 2][1][0]);\n        }\n\n    }\n\n    static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.util.NoSuchElementException;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tFS r = new FS();\n\t\tint N = r.nextInt();\n\t\tint M = r.nextInt();\n\t\tint MOD = 1000000007;\n\t\t// dp[days][added town][looped size]\n\t\tint[][][] dp = new int[M+1][N+1][N+1];\n\t\tdp[0][1][1] = 1;\n\t\tfor(int i=0; i<M; i++) {\n\t\t\tfor(int j=0; j<=N; j++) {\n\t\t\t\tfor(int k=0; k<=N; k++) {\n\t\t\t\t\t// add town unused\n\t\t\t\t\tif(j!=N) {\n\t\t\t\t\t\tdp[i+1][j+1][k] += (int)(((long)dp[i][j][k]*(N-j))%MOD);\n\t\t\t\t\t\tdp[i+1][j+1][k] %= MOD;\n\t\t\t\t\t}\n\t\t\t\t\t// add town used but not in loop\n\t\t\t\t\tdp[i+1][j][k] += (int)(((long)dp[i][j][k]*(j-k))%MOD);\n\t\t\t\t\tdp[i+1][j][k] %= MOD;\n\t\t\t\t\t// add town used and in loop\n\t\t\t\t\tdp[i+1][j][j] += (int)(((long)dp[i][j][k]*k)%MOD);\n\t\t\t\t\tdp[i+1][j][j] %= MOD;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(dp[M][N][N]);\n\t}\n\n\t// Read Class\n\tstatic class FS {\n\t\tprivate final InputStream in = System.in;\n\t\tprivate final byte[] buffer = new byte[1024];\n\t\tprivate int ptr = 0;\n\t\tprivate int buflen = 0;\n\t\tprivate boolean hasNextByte() {\n\t\t\tif (ptr < buflen) {\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\tptr = 0;\n\t\t\t\ttry {\n\t\t\t\t\tbuflen = in.read(buffer);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t\tif (buflen <= 0) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\tprivate int readByte() { return hasNextByte() ? buffer[ptr++] : -1;}\n\t\tprivate boolean isPrintableChar(int c) {return 33 <= c && c <= 126;}\n\t\tprivate void skipUnprintable() {while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;}\n\n\t\tpublic boolean hasNext() { skipUnprintable(); return hasNextByte();}\n\t\tpublic String next() {\n\t\t\tif (!hasNext()) throw new NoSuchElementException();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tint b = readByte();\n\t\t\twhile(isPrintableChar(b)) {\n\t\t\t\tsb.appendCodePoint(b);\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\treturn sb.toString();\n\t\t}\n\t\tpublic int nextInt() {\n\t\t\treturn (int)nextLong();\n\t\t}\n\t\tpublic long nextLong() {\n\t\t\tif (!hasNext()) throw new NoSuchElementException();\n\t\t\tlong n = 0;\n\t\t\tboolean minus = false;\n\t\t\tint b = readByte();\n\t\t\tif (b == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\tif (b < '0' || '9' < b) {\n\t\t\t\tthrow new NumberFormatException();\n\t\t\t}\n\t\t\twhile(true) {\n\t\t\t\tif ('0' <= b && b <= '9') {\n\t\t\t\t\tn *= 10;\n\t\t\t\t\tn += b - '0';\n\t\t\t\t} else if(b == -1 || !isPrintableChar(b)) {\n\t\t\t\t\treturn minus ? -n : n;\n\t\t\t\t} else {\n\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t}\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\n\npublic class Main {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\t\n\tstatic void solve()\n\t{\n\t\tint mod = 1000000007;\n\t\tint n = ni(), m = ni();\n\t\tlong[][] dp = new long[n+1][n+1];\n\t\tdp[1][0] = 1;\n\t\tfor(int i = 0;i < m;i++){\n\t\t\tlong[][] ndp = new long[n+1][n+1];\n\t\t\tfor(int j = 0;j <= n;j++){\n\t\t\t\tfor(int k = 0;j+k <= n;k++){\n\t\t\t\t\tif(k+1 <= n){\n\t\t\t\t\t\tndp[j][k+1] += dp[j][k] * (n-j-k);\n\t\t\t\t\t\tndp[j][k+1] %= mod;\n\t\t\t\t\t}\n\t\t\t\t\tndp[j+k][0] += dp[j][k] * j;\n\t\t\t\t\tndp[j+k][0] %= mod;\n\t\t\t\t\tndp[j][k] += dp[j][k] * k;\n\t\t\t\t\tndp[j][k] %= mod;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdp = ndp;\n\t\t}\n\t\tout.println(dp[n][0]);\n\t}\n\t\n\tpublic static void main(String[] args) throws Exception\n\t{\n\t\tlong S = System.currentTimeMillis();\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\t\n\t\tsolve();\n\t\tout.flush();\n\t\tlong G = System.currentTimeMillis();\n\t\ttr(G-S+\"ms\");\n\t}\n\t\n\tprivate static boolean eof()\n\t{\n\t\tif(lenbuf == -1)return true;\n\t\tint lptr = ptrbuf;\n\t\twhile(lptr < lenbuf)if(!isSpaceChar(inbuf[lptr++]))return false;\n\t\t\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\twhile(true){\n\t\t\t\tint b = is.read();\n\t\t\t\tif(b == -1){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn true;\n\t\t\t\t}else if(!isSpaceChar(b)){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\tprivate static byte[] inbuf = new byte[1024];\n\tstatic int lenbuf = 0, ptrbuf = 0;\n\t\n\tprivate static int readByte()\n\t{\n\t\tif(lenbuf == -1)throw new InputMismatchException();\n\t\tif(ptrbuf >= lenbuf){\n\t\t\tptrbuf = 0;\n\t\t\ttry { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n\t\t\tif(lenbuf <= 0)return -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\t\n\tprivate static boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n//\tprivate static boolean isSpaceChar(int c) { return !(c >= 32 && c <= 126); }\n\tprivate static int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n\t\n\tprivate static double nd() { return Double.parseDouble(ns()); }\n\tprivate static char nc() { return (char)skip(); }\n\t\n\tprivate static String ns()\n\t{\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile(!(isSpaceChar(b))){\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\t\n\tprivate static char[] ns(int n)\n\t{\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile(p < n && !(isSpaceChar(b))){\n\t\t\tbuf[p++] = (char)b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\t\n\tprivate static char[][] nm(int n, int m)\n\t{\n\t\tchar[][] map = new char[n][];\n\t\tfor(int i = 0;i < n;i++)map[i] = ns(m);\n\t\treturn map;\n\t}\n\t\n\tprivate static int[] na(int n)\n\t{\n\t\tint[] a = new int[n];\n\t\tfor(int i = 0;i < n;i++)a[i] = ni();\n\t\treturn a;\n\t}\n\t\n\tprivate static int ni()\n\t{\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static long nl()\n\t{\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static void tr(Object... o) { if(INPUT.length() != 0)System.out.println(Arrays.deepToString(o)); }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n  static Scanner sc = new Scanner(System.in);\n  static final long MOD = 1_000_000_007;\n\n  public static void main(String[] args) {\n    int N = sc.nextInt();\n    int M = sc.nextInt();\n    long[][][] dp = new long[2][N][N]; // dp[][can return to 1][on current path]\n    dp[0][0][0] = 1;\n    int t = 1;\n    for (int i = 0; i < M; i++) {\n      for (long[] a : dp[t]) {\n        Arrays.fill(a, 0L);\n      }\n      for (int j = 0; j < N; j++) {\n        for (int k = 0; j + k < N; k++) {\n          dp[t][j + k][0] += dp[1 - t][j][k] * (1 + j); // go to city connected to 1\n          dp[t][j + k][0] %= MOD;\n\n          dp[t][j][k] += dp[1 - t][j][k] * k; // go to a city on current path\n          dp[t][j][k] %= MOD;\n\n          if (k < N - 1) {\n            dp[t][j][k + 1] += dp[1 - t][j][k] * (N - 1 - j - k); // go to a city does not have a path to city 1\n            dp[t][j][k + 1] %= MOD;\n          }\n        }\n      }\n      t = 1 - t;\n    }\n//      for (int j = 0; j < N; j++) {\n//        System.out.println(Arrays.toString(dp[1-t][j]));\n//      }\n//      System.out.println();\n    System.out.println(dp[1 - t][N - 1][0]);\n  }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\n    static BufferedReader in;\n    static PrintWriter out;\n    static StringTokenizer tok;\n\n    void solve() throws IOException {\n        int n = ni();\n        int m = ni();\n\n        int MOD = 1000000007;\n\n        int[] t = new int[m];\n        t[0] = 1;\n        for (int i = 1; i < m; i++) {\n            if (i > n) {\n                t[i] = (t[i - 1] * n) % MOD;\n            } else {\n                t[i] = (t[i - 1] * i) % MOD;\n            }\n        }\n\n        int[] dp = new int[m];\n        for (int i = 1; i < m; i++) {\n            dp[i] = (dp[i] + t[i]) % MOD;\n            dp[i] = (dp[i] + (dp[i - 1] * (n - 1)) % MOD) % MOD;\n        }\n\n        out.println(dp[m - 1]);\n    }\n\n    String ns() throws IOException {\n        while (!tok.hasMoreTokens()) {\n            tok = new StringTokenizer(in.readLine(), \" \");\n        }\n        return tok.nextToken();\n    }\n\n    int ni() throws IOException {\n        return Integer.parseInt(ns());\n    }\n\n    long nl() throws IOException {\n        return Long.parseLong(ns());\n    }\n\n    double nd() throws IOException {\n        return Double.parseDouble(ns());\n    }\n\n    String[] nsa(int n) throws IOException {\n        String[] res = new String[n];\n        for (int i = 0; i < n; i++) {\n            res[i] = ns();\n        }\n        return res;\n    }\n\n    int[] nia(int n) throws IOException {\n        int[] res = new int[n];\n        for (int i = 0; i < n; i++) {\n            res[i] = ni();\n        }\n        return res;\n    }\n\n    long[] nla(int n) throws IOException {\n        long[] res = new long[n];\n        for (int i = 0; i < n; i++) {\n            res[i] = nl();\n        }\n        return res;\n    }\n\n    public static void main(String[] args) throws IOException {\n        in = new BufferedReader(new InputStreamReader(System.in));\n        out = new PrintWriter(System.out);\n        tok = new StringTokenizer(\"\");\n        Main main = new Main();\n        main.solve();\n        out.close();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.util.NoSuchElementException;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tFS r = new FS();\n\t\tint N = r.nextInt();\n\t\tint M = r.nextInt();\n\t\tint MOD = 1000000007;\n\t\t// dp[days][added town][looped size]\n\t\tlong[][][] dp = new long[M+1][N+1][N+1];\n\t\tdp[0][1][1] = 1;\n\t\tfor(int i=0; i<M; i++) {\n\t\t\tfor(int j=0; j<=N; j++) {\n\t\t\t\tfor(int k=0; k<=N; k++) {\n\t\t\t\t\t// add town unused\n\t\t\t\t\tif(j!=N) {\n\t\t\t\t\t\tdp[i+1][j+1][k] += dp[i][j][k]*(N-j);\n\t\t\t\t\t\tdp[i+1][j+1][k] %= MOD;\n\t\t\t\t\t}\n\t\t\t\t\t// add town used but not in loop\n\t\t\t\t\tdp[i+1][j][k] += dp[i][j][k]*(j-k);\n\t\t\t\t\tdp[i+1][j][k] %= MOD;\n\t\t\t\t\t// add town used and in loop\n\t\t\t\t\tdp[i+1][j][j] += dp[i][j][k]*k;\n\t\t\t\t\tdp[i+1][j][j] %= MOD;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(dp[M][N][N]);\n\t}\n\n\t// Read Class\n\tstatic class FS {\n\t\tprivate final InputStream in = System.in;\n\t\tprivate final byte[] buffer = new byte[1024];\n\t\tprivate int ptr = 0;\n\t\tprivate int buflen = 0;\n\t\tprivate boolean hasNextByte() {\n\t\t\tif (ptr < buflen) {\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\tptr = 0;\n\t\t\t\ttry {\n\t\t\t\t\tbuflen = in.read(buffer);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t\tif (buflen <= 0) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\tprivate int readByte() { return hasNextByte() ? buffer[ptr++] : -1;}\n\t\tprivate boolean isPrintableChar(int c) {return 33 <= c && c <= 126;}\n\t\tprivate void skipUnprintable() {while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;}\n\n\t\tpublic boolean hasNext() { skipUnprintable(); return hasNextByte();}\n\t\tpublic String next() {\n\t\t\tif (!hasNext()) throw new NoSuchElementException();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tint b = readByte();\n\t\t\twhile(isPrintableChar(b)) {\n\t\t\t\tsb.appendCodePoint(b);\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\treturn sb.toString();\n\t\t}\n\t\tpublic int nextInt() {\n\t\t\treturn (int)nextLong();\n\t\t}\n\t\tpublic long nextLong() {\n\t\t\tif (!hasNext()) throw new NoSuchElementException();\n\t\t\tlong n = 0;\n\t\t\tboolean minus = false;\n\t\t\tint b = readByte();\n\t\t\tif (b == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\tif (b < '0' || '9' < b) {\n\t\t\t\tthrow new NumberFormatException();\n\t\t\t}\n\t\t\twhile(true) {\n\t\t\t\tif ('0' <= b && b <= '9') {\n\t\t\t\t\tn *= 10;\n\t\t\t\t\tn += b - '0';\n\t\t\t\t} else if(b == -1 || !isPrintableChar(b)) {\n\t\t\t\t\treturn minus ? -n : n;\n\t\t\t\t} else {\n\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t}\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n  static Scanner sc = new Scanner(System.in);\n  static final long MOD = 1_000_000_007;\n\n  public static void main(String[] args) {\n    int N = sc.nextInt();\n    int M = sc.nextInt();\n    long[][][] dp = new long[2][N][N]; // dp[][can return to 1][on current path]\n    dp[0][0][0] = 1;\n    int t = 1;\n    for (int i = 0; i < M; i++) {\n      for (long[] a : dp[t]) {\n        Arrays.fill(a, 0L);\n      }\n      for (int j = 0; j < N; j++) {\n        for (int k = 0; j + k < N; k++) {\n          dp[t][j + k][0] += dp[1 - t][j][k]; // go to city 1\n          dp[t][j + k][0] %= MOD;\n\n          dp[t][j][k] += dp[1 - t][j][k] * (j + k); // go to a city on current path\n          dp[t][j][k] %= MOD;\n\n          if (k < N - 1) {\n            dp[t][j][k + 1] += dp[1 - t][j][k] * (N - 1 - j - k); // go to a city does not have a path to city 1\n            dp[t][j][k + 1] %= MOD;\n          }\n        }\n      }\n      t = 1 - t;\n    }\n//      for (int j = 0; j < N; j++) {\n//        System.out.println(Arrays.toString(dp[1-t][j]));\n//      }\n//      System.out.println();\n    System.out.println(dp[1 - t][N - 1][0]);\n  }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskF solver = new TaskF();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskF {\n        public int n;\n        public int m;\n        public int mod = 1000000007;\n        public long[][][] dp;\n\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            n = in.nextInt();\n            m = in.nextInt();\n            dp = new long[m + 1][n + 1][n + 1];\n            for (long[][] y : dp) for (long[] x : y) Arrays.fill(x, -1);\n            long ans = count(m, 1, 0);\n            out.println(ans);\n        }\n\n        public long count(int slots, int in, int out) {\n            if (dp[slots][in][out] != -1) return dp[slots][in][out];\n            if (slots == 0) return in == n ? 1 : 0;\n            long ret = 0;\n            // go inside\n            if (in > 0) ret += in * count(slots - 1, in + out, 0);\n            // go outside1\n            if (out > 0) ret += out * count(slots - 1, in, out);\n            // go outside2\n            if (n - in - out > 0) ret += (n - in - out) * count(slots - 1, in, out + 1);\n\n            return dp[slots][in][out] = ret % mod;\n        }\n\n    }\n\n    static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "// package atcoder.other2016.codefestival2016.finale;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\n\npublic class Main {\n    static final long MOD = 1000000007;\n\n    public static void main(String[] args) {\n        InputReader in = new InputReader(System.in);\n        PrintWriter out = new PrintWriter(System.out);\n\n        int n = in.nextInt();\n        int m = in.nextInt();\n\n        long[][][] dp = new long[m+1][n+1][n+1];\n        dp[0][1][1] = 1;\n\n        for (int i = 0; i < m ; i++) {\n            for (int j = 0; j <= n ; j++) {\n                for (int k = 0; k <= n; k++) {\n                    if (dp[i][j][k] == 0) {\n                        continue;\n                    }\n                    long base = dp[i][j][k];\n\n                    // go to unvisited place\n                    if (n - j >= 1) {\n                        dp[i+1][j+1][k] += base*(n-j)%MOD;\n                        dp[i+1][j+1][k] %= MOD;\n                    }\n\n                    // go to visited place but not belongs to one\n                    if (j - k >= 1) {\n                        dp[i+1][j][k] += base*(j-k)%MOD;\n                        dp[i+1][j][k] %= MOD;\n                    }\n\n                    // go to visited place belongs to one\n                    dp[i+1][j][j] += base * k % MOD;\n                    dp[i+1][j][j] %= MOD;\n                }\n            }\n        }\n\n\n        out.println(dp[m][n][n]);\n        out.flush();\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        private int[] nextInts(int n) {\n            int[] ret = new int[n];\n            for (int i = 0; i < n; i++) {\n                ret[i] = nextInt();\n            }\n            return ret;\n        }\n\n        private int[][] nextIntTable(int n, int m) {\n            int[][] ret = new int[n][m];\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < m; j++) {\n                    ret[i][j] = nextInt();\n                }\n            }\n            return ret;\n        }\n\n        private long[] nextLongs(int n) {\n            long[] ret = new long[n];\n            for (int i = 0; i < n; i++) {\n                ret[i] = nextLong();\n            }\n            return ret;\n        }\n\n        private long[][] nextLongTable(int n, int m) {\n            long[][] ret = new long[n][m];\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < m; j++) {\n                    ret[i][j] = nextLong();\n                }\n            }\n            return ret;\n        }\n\n        private double[] nextDoubles(int n) {\n            double[] ret = new double[n];\n            for (int i = 0; i < n; i++) {\n                ret[i] = nextDouble();\n            }\n            return ret;\n        }\n\n        private int next() {\n            if (numChars == -1)\n                throw new InputMismatchException();\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0)\n                    return -1;\n            }\n            return buf[curChar++];\n        }\n\n        public char nextChar() {\n            int c = next();\n            while (isSpaceChar(c))\n                c = next();\n            if ('a' <= c && c <= 'z') {\n                return (char) c;\n            }\n            if ('A' <= c && c <= 'Z') {\n                return (char) c;\n            }\n            throw new InputMismatchException();\n        }\n\n        public String nextToken() {\n            int c = next();\n            while (isSpaceChar(c))\n                c = next();\n            StringBuilder res = new StringBuilder();\n            do {\n                res.append((char) c);\n                c = next();\n            } while (!isSpaceChar(c));\n            return res.toString();\n        }\n\n        public int nextInt() {\n            int c = next();\n            while (isSpaceChar(c))\n                c = next();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = next();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c-'0';\n                c = next();\n            } while (!isSpaceChar(c));\n            return res*sgn;\n        }\n\n        public long nextLong() {\n            int c = next();\n            while (isSpaceChar(c))\n                c = next();\n            long sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = next();\n            }\n            long res = 0;\n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c-'0';\n                c = next();\n            } while (!isSpaceChar(c));\n            return res*sgn;\n        }\n\n        public double nextDouble() {\n            return Double.valueOf(nextToken());\n        }\n\n        public boolean isSpaceChar(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n        }\n    }\n\n    static void debug(Object... o) {\n        System.err.println(Arrays.deepToString(o));\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main {\n    static final long MOD=1000000007;\n    public static void main(String[] args) {\n        Scanner scan = new Scanner(System.in);\n        int n=scan.nextInt();\n        int m=scan.nextInt();\n        long[][][]dp=new long[m+1][n][n];\n        dp[0][0][0]=1;\n        for(int i=0;i<m;++i){\n            int u=i%2;\n            for(int j=0;j<n;++j)Arrays.fill(dp[1-u][j],0);\n            for(int j=0;j<n;++j)\n                for(int k=0;k<n;++k){\n                    if(j<n-1){\n                        dp[1-u][j+1][k]+=dp[u][j][k];\n                        dp[1-u][j+1][k]%=MOD;\n                    }\n                    dp[1-u][j][j]+=(k+1)*dp[u][j][k];\n                    dp[1-u][j][j]%=MOD;\n                    dp[1-u][j][k]+=(j-k)*dp[u][j][k];\n                    dp[1-u][j][k]%=MOD;\n                }\n        }\n        long t=0;\n        for(int i=0;i<n;++i)\n            t=(t+dp[m%2][i][n-1])%MOD;\n        for(int i=1;i<=n-1;++i)\n            t=t*i%MOD;\n        System.out.println(t);\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main {\n    static final long MOD=1000000007;\n    public static void main(String[] args) {\n        Scanner scan = new Scanner(System.in);\n        int n=scan.nextInt();\n        int m=scan.nextInt();\n        long[][][]dp=new long[2][n][n];\n        dp[0][0][0]=1;\n        for(int i=0;i<m;++i){\n            int u=i%2;\n            for(int j=0;j<n;++j)Arrays.fill(dp[1-u][j],0);\n            for(int j=0;j<n;++j)\n                for(int k=0;k<n;++k){\n                    if(j<n-1){\n                        dp[1-u][j+1][k]+=dp[u][j][k];\n                        dp[1-u][j+1][k]%=MOD;\n                    }\n                    dp[1-u][j][j]+=(k+1)*dp[u][j][k];\n                    dp[1-u][j][j]%=MOD;\n                    dp[1-u][j][k]+=(j-k)*dp[u][j][k];\n                    dp[1-u][j][k]%=MOD;\n                }\n        }\n        long t=0;\n        for(int i=0;i<n;++i)\n            t=(t+dp[m%2][i][n-1])%MOD;\n        for(int i=1;i<=n-1;++i)\n            t=t*i%MOD;\n        System.out.println(t);\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main {\n    static final long MOD=1000000007;\n    public static void main(String[] args) {\n        Scanner scan = new Scanner(System.in);\n        int n=scan.nextInt();\n        int m=scan.nextInt();\n        long[][][]dp=new long[m+1][n][n];\n        dp[0][0][0]=1;\n        for(int i=0;i<m;++i){\n            for(int j=0;j<n;++j)\n                for(int k=0;k<n;++k){\n                    if(j<n-1){\n                        dp[i+1][j+1][k]+=dp[i][j][k];\n                        dp[i+1][j+1][k]%=MOD;\n                    }\n                    dp[i+1][j][j]+=(k+1)*dp[i][j][k];\n                    dp[i+1][j][j]%=MOD;\n                    dp[i+1][j][k]+=(j-k)*dp[i][j][k];\n                    dp[i+1][j][k]%=MOD;\n                }\n        }\n        long t=0;\n        for(int i=0;i<n;++i)\n            t=(t+dp[m][i][n-1])%MOD;\n        for(int i=1;i<=n-1;++i)\n            t=t*i%MOD;\n        System.out.println(t);\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "// package atcoder.other2016.codefestival2016.finale;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\n\npublic class Main {\n    static final long MOD = 1000000007;\n\n    public static void main(String[] args) {\n        InputReader in = new InputReader(System.in);\n        PrintWriter out = new PrintWriter(System.out);\n\n        int n = in.nextInt();\n        int m = in.nextInt();\n\n        long[][][] dp = new long[2][n+1][n+1];\n        dp[0][1][1] = 1;\n\n        for (int ii = 0; ii < m ; ii++) {\n            int fr = ii % 2;\n            int to = 1 - fr;\n            for (int i = 0; i <= n; i++) {\n                Arrays.fill(dp[to][i], 0);\n            }\n\n            for (int j = 0; j <= n ; j++) {\n                for (int k = 0; k <= n; k++) {\n                    if (dp[fr][j][k] == 0) {\n                        continue;\n                    }\n                    long base = dp[fr][j][k];\n\n                    // go to unvisited place\n                    if (n - j >= 1) {\n                        dp[to][j+1][k] += base*(n-j)%MOD;\n                        dp[to][j+1][k] %= MOD;\n                    }\n\n                    // go to visited place but not belongs to one\n                    if (j - k >= 1) {\n                        dp[to][j][k] += base*(j-k)%MOD;\n                        dp[to][j][k] %= MOD;\n                    }\n\n                    // go to visited place belongs to one\n                    dp[to][j][j] += base * k % MOD;\n                    dp[to][j][j] %= MOD;\n                }\n            }\n        }\n\n\n        out.println(dp[m%2][n][n]);\n        out.flush();\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        private int[] nextInts(int n) {\n            int[] ret = new int[n];\n            for (int i = 0; i < n; i++) {\n                ret[i] = nextInt();\n            }\n            return ret;\n        }\n\n        private int[][] nextIntTable(int n, int m) {\n            int[][] ret = new int[n][m];\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < m; j++) {\n                    ret[i][j] = nextInt();\n                }\n            }\n            return ret;\n        }\n\n        private long[] nextLongs(int n) {\n            long[] ret = new long[n];\n            for (int i = 0; i < n; i++) {\n                ret[i] = nextLong();\n            }\n            return ret;\n        }\n\n        private long[][] nextLongTable(int n, int m) {\n            long[][] ret = new long[n][m];\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < m; j++) {\n                    ret[i][j] = nextLong();\n                }\n            }\n            return ret;\n        }\n\n        private double[] nextDoubles(int n) {\n            double[] ret = new double[n];\n            for (int i = 0; i < n; i++) {\n                ret[i] = nextDouble();\n            }\n            return ret;\n        }\n\n        private int next() {\n            if (numChars == -1)\n                throw new InputMismatchException();\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0)\n                    return -1;\n            }\n            return buf[curChar++];\n        }\n\n        public char nextChar() {\n            int c = next();\n            while (isSpaceChar(c))\n                c = next();\n            if ('a' <= c && c <= 'z') {\n                return (char) c;\n            }\n            if ('A' <= c && c <= 'Z') {\n                return (char) c;\n            }\n            throw new InputMismatchException();\n        }\n\n        public String nextToken() {\n            int c = next();\n            while (isSpaceChar(c))\n                c = next();\n            StringBuilder res = new StringBuilder();\n            do {\n                res.append((char) c);\n                c = next();\n            } while (!isSpaceChar(c));\n            return res.toString();\n        }\n\n        public int nextInt() {\n            int c = next();\n            while (isSpaceChar(c))\n                c = next();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = next();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c-'0';\n                c = next();\n            } while (!isSpaceChar(c));\n            return res*sgn;\n        }\n\n        public long nextLong() {\n            int c = next();\n            while (isSpaceChar(c))\n                c = next();\n            long sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = next();\n            }\n            long res = 0;\n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c-'0';\n                c = next();\n            } while (!isSpaceChar(c));\n            return res*sgn;\n        }\n\n        public double nextDouble() {\n            return Double.valueOf(nextToken());\n        }\n\n        public boolean isSpaceChar(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n        }\n    }\n\n    static void debug(Object... o) {\n        System.err.println(Arrays.deepToString(o));\n    }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Text;\nusing System.Collections.Generic;\nclass Solve{\n    int N,M;\n    public Solve(){}\n    StringBuilder sb;\n    public static int Main(){\n        new Solve().Run();\n        return 0;\n    }\n    void Run(){\n        sb = new StringBuilder();\n        Read();\n        Calc();\n        Console.Write(sb.ToString());\n    }\n    void Calc(){\n        long[,,] d = new long[M+1,N,N+1];\n        for(int i=0;i<M+1;i++){\n            for(int j=0;j<N;j++){\n                for(int k=0;k<N+1;k++){\n                    if(i == 0){\n                        if(j == 0 && k == 0){\n                            d[i,j,k] = 1;\n                        }\n                        else{\n                            d[i,j,k] = 0;\n                        }\n                    }\n                    else{\n                        d[i,j,k] = 0;\n                    }\n                }\n            }\n        }\n        for(int i=1;i<M+1;i++){\n            for(int j=0;j<N;j++){\n                for(int k=j;k<N+1;k++){\n                    if(k != 0){\n                        d[i,j,k] = (d[i,j,k] + (d[i-1,j,k] * (k-j-1) % Define.mod)) % Define.mod;\n                        d[i,k-1,k] = (d[i,k-1,k] + (d[i-1,j,k] * (j+1) % Define.mod)) % Define.mod;\n                    }\n                    if(k != N){\n                        if(k == 0){\n                            d[i,j,k+1] = (d[i,j,k+1] + d[i-1,j,k]) % Define.mod;\n                        }\n                        else{\n                            d[i,j,k+1] = (d[i,j,k+1] + (d[i-1,j,k] * (N-k) % Define.mod)) % Define.mod;\n                        }\n                    }\n                }\n            }\n        }\n        sb.Append(d[M,N-1,N]+\"\\n\");\n    }\n    void Read(){\n        string[] str = Console.ReadLine().Split(' ');\n        N = int.Parse(str[0]);\n        M = int.Parse(str[1])+1;\n    }    \n}\npublic static class Define{\n    public const long mod = 1000000007;\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Text;\nusing System.Collections.Generic;\nclass Solve{\n    int N,M;\n    public Solve(){}\n    StringBuilder sb;\n    public static int Main(){\n        new Solve().Run();\n        return 0;\n    }\n    void Run(){\n        sb = new StringBuilder();\n        Read();\n        Calc();\n        Console.Write(sb.ToString());\n    }\n    void Calc(){\n        long[,,] d = new long[M+1,N,N+1];\n        for(int i=0;i<M+1;i++){\n            for(int j=0;j<N;j++){\n                for(int k=0;k<N+1;k++){\n                    if(i == 0){\n                        if(j == 0 && k == 0){\n                            d[i,j,k] = 1;\n                        }\n                        else{\n                            d[i,j,k] = 0;\n                        }\n                    }\n                    else{\n                        d[i,j,k] = 0;\n                    }\n                }\n            }\n        }\n        for(int i=1;i<M+1;i++){\n            for(int j=0;j<N;j++){\n                for(int k=0;k<N+1;k++){\n                    if(k != 0){\n                        d[i,j,k] = (d[i,j,k] + (d[i-1,j,k] * (k-j-1) % Define.mod)) % Define.mod;\n                        d[i,k-1,k] = (d[i,k-1,k] + (d[i-1,j,k] * (j+1) % Define.mod)) % Define.mod;\n                    }\n                    if(k != N){\n                        if(k == 0){\n                            d[i,j,k+1] = (d[i,j,k+1] + d[i-1,j,k]) % Define.mod;\n                        }\n                        else{\n                            d[i,j,k+1] = (d[i,j,k+1] + (d[i-1,j,k] * (N-k) % Define.mod)) % Define.mod;\n                        }\n                    }\n                }\n            }\n        }\n        sb.Append(d[M,N-1,N]+\"\\n\");\n    }\n    void Read(){\n        string[] str = Console.ReadLine().Split(' ');\n        N = int.Parse(str[0]);\n        M = int.Parse(str[1])+1;\n    }    \n}\npublic static class Define{\n    public const long mod = 1000000007;\n}"
  },
  {
    "language": "Lisp",
    "code": "(eval-when (:compile-toplevel :load-toplevel :execute)\n  (sb-int:defconstant-eqx opt\n    #+swank '(optimize (speed 3) (safety 2))\n    #-swank '(optimize (speed 3) (safety 0) (debug 0))\n    #'equal)\n  #+swank (ql:quickload '(:cl-debug-print :fiveam) :silent t)\n  #-swank (set-dispatch-macro-character\n           #\\# #\\> (lambda (s c p) (declare (ignore c p)) `(values ,(read s nil nil t)))))\n#+swank (cl-syntax:use-syntax cl-debug-print:debug-print-syntax)\n\n(defmacro define-int-types (&rest bits)\n  `(progn\n     ,@(mapcar (lambda (b) `(deftype ,(intern (format nil \"UINT~A\" b)) () '(unsigned-byte ,b))) bits)\n     ,@(mapcar (lambda (b) `(deftype ,(intern (format nil \"INT~A\" b)) () '(signed-byte ,b))) bits)))\n(define-int-types 2 4 7 8 15 16 31 32 62 63 64)\n\n;; BEGIN_INSERTED_CONTENTS\n;;;\n;;; Arithmetic operations with static modulus\n;;;\n\n;; FIXME: Currently MOD* and MOD+ doesn't apply MOD when the number of\n;; parameters is one.\n(defmacro define-mod-operations (divisor)\n  `(progn\n     (defun mod* (&rest args)\n       (reduce (lambda (x y) (mod (* x y) ,divisor)) args))\n\n     (defun mod+ (&rest args)\n       (reduce (lambda (x y) (mod (+ x y) ,divisor)) args))\n\n     #+sbcl\n     (eval-when (:compile-toplevel :load-toplevel :execute)\n       (locally (declare (muffle-conditions warning))\n         (sb-c:define-source-transform mod* (&rest args)\n           (if (null args)\n               1\n               (reduce (lambda (x y) `(mod (* ,x ,y) ,',divisor)) args)))\n         (sb-c:define-source-transform mod+ (&rest args)\n           (if (null args)\n               0\n               (reduce (lambda (x y) `(mod (+ ,x ,y) ,',divisor)) args)))))\n\n     (define-modify-macro incfmod (delta)\n       (lambda (x y) (mod (+ x y) ,divisor)))\n\n     (define-modify-macro decfmod (delta)\n       (lambda (x y) (mod (- x y) ,divisor)))\n\n     (define-modify-macro mulfmod (multiplier)\n       (lambda (x y) (mod (* x y) ,divisor)))))\n\n(in-package :cl-user)\n\n(defmacro dbg (&rest forms)\n  #+swank\n  (if (= (length forms) 1)\n      `(format *error-output* \"~A => ~A~%\" ',(car forms) ,(car forms))\n      `(format *error-output* \"~A => ~A~%\" ',forms `(,,@forms)))\n  #-swank (declare (ignore forms)))\n\n(declaim (inline println))\n(defun println (obj &optional (stream *standard-output*))\n  (let ((*read-default-float-format* 'double-float))\n    (prog1 (princ obj stream) (terpri stream))))\n\n(defconstant +mod+ 1000000007)\n\n;;;\n;;; Body\n;;;\n\n(define-mod-operations +mod+)\n(defun solve (n m)\n  (declare #.opt\n           ((integer 1 300) n m))\n  (let ((dp (make-array '(301 301 301)\n                        :element-type 'uint31\n                        :initial-element 0)))\n    (setf (aref dp 0 1 0) 1)\n    (dotimes (x m)\n      (dotimes (y (+ n 1))\n        (dotimes (z (+ n 1))\n          (unless (zerop (aref dp x y z))\n            (incfmod (aref dp (+ x 1) (+ y z) 0)\n                     (mod* (aref dp x y z) y))\n            (incfmod (aref dp (+ x 1) y (+ z 1))\n                     (mod* (aref dp x y z) (the uint31 (- n y z))))\n            (incfmod (aref dp (+ x 1) y z)\n                     (mod* (aref dp x y z) z))))))\n    (aref dp m n 0)))\n\n(defun main ()\n  (let* ((n (read))\n         (m (read)))\n    (println (solve n m))))\n\n#-swank (main)\n\n;;;\n;;; Test and benchmark\n;;;\n\n#+swank\n(defun io-equal (in-string out-string &key (function #'main) (test #'equal))\n  \"Passes IN-STRING to *STANDARD-INPUT*, executes FUNCTION, and returns true if\nthe string output to *STANDARD-OUTPUT* is equal to OUT-STRING.\"\n  (labels ((ensure-last-lf (s)\n             (if (eql (uiop:last-char s) #\\Linefeed)\n                 s\n                 (uiop:strcat s uiop:+lf+))))\n    (funcall test\n             (ensure-last-lf out-string)\n             (with-output-to-string (out)\n               (let ((*standard-output* out))\n                 (with-input-from-string (*standard-input* (ensure-last-lf in-string))\n                   (funcall function)))))))\n\n#+swank\n(defun get-clipbrd ()\n  (with-output-to-string (out)\n    #+os-windows (run-program \"powershell.exe\" '(\"-Command\" \"Get-Clipboard\") :output out :search t)\n    #+os-unix (run-program \"xsel\" '(\"-b\" \"-o\") :output out :search t)))\n\n#+swank (defparameter *this-pathname* (uiop:current-lisp-file-pathname))\n#+swank (defparameter *dat-pathname* (uiop:merge-pathnames* \"test.dat\" *this-pathname*))\n\n#+swank\n(defun run (&optional thing (out *standard-output*))\n  \"THING := null | string | symbol | pathname\n\nnull: run #'MAIN using the text on clipboard as input.\nstring: run #'MAIN using the string as input.\nsymbol: alias of FIVEAM:RUN!.\npathname: run #'MAIN using the text file as input.\"\n  (let ((*standard-output* out))\n    (etypecase thing\n      (null\n       (with-input-from-string (*standard-input* (delete #\\Return (get-clipbrd)))\n         (main)))\n      (string\n       (with-input-from-string (*standard-input* (delete #\\Return thing))\n         (main)))\n      (symbol (5am:run! thing))\n      (pathname\n       (with-open-file (*standard-input* thing)\n         (main))))))\n\n#+swank\n(defun gen-dat ()\n  (uiop:with-output-file (out *dat-pathname* :if-exists :supersede)\n    (format out \"\")))\n\n#+swank\n(defun bench (&optional (out (make-broadcast-stream)))\n  (time (run *dat-pathname* out)))\n"
  },
  {
    "language": "Lisp",
    "code": "(eval-when (:compile-toplevel :load-toplevel :execute)\n  (sb-int:defconstant-eqx opt\n    #+swank '(optimize (speed 3) (safety 2))\n    #-swank '(optimize (speed 3) (safety 0) (debug 0))\n    #'equal)\n  #+swank (ql:quickload '(:cl-debug-print :fiveam) :silent t)\n  #-swank (set-dispatch-macro-character\n           #\\# #\\> (lambda (s c p) (declare (ignore c p)) `(values ,(read s nil nil t)))))\n#+swank (cl-syntax:use-syntax cl-debug-print:debug-print-syntax)\n\n(defmacro define-int-types (&rest bits)\n  `(progn\n     ,@(mapcar (lambda (b) `(deftype ,(intern (format nil \"UINT~A\" b)) () '(unsigned-byte ,b))) bits)\n     ,@(mapcar (lambda (b) `(deftype ,(intern (format nil \"INT~A\" b)) () '(signed-byte ,b))) bits)))\n(define-int-types 2 4 7 8 15 16 31 32 62 63 64)\n\n;; BEGIN_INSERTED_CONTENTS\n(declaim (inline map-indices))\n(defun map-indices (function max-indices)\n  \"Applies function to each vector of indices smaller than MAX-INDICES. The\nconsequence is undefined when the vector is modified in FUNCTION.\"\n  (declare (vector max-indices))\n  (let* ((size (length max-indices))\n         (indices (make-array size :element-type (array-element-type max-indices))))\n    (labels ((recur (pos)\n               (declare ((integer 0 #.array-dimension-limit) pos))\n               (if (= pos size)\n                   (funcall function indices)\n                   (dotimes (idx (the (integer 0 #.most-positive-fixnum)\n                                      (aref max-indices pos)))\n                     (setf (aref indices pos) idx)\n                     (recur (+ pos 1))))))\n      (recur 0))))\n\n(defmacro do-indices ((var end-indices) &body body)\n  \"DO-style macro for MAP-INDICES\"\n  `(block nil (map-indices (lambda (,var) ,@body) ,end-indices)))\n\n;;;\n;;; Binomial coefficient with mod\n;;; build: O(n)\n;;; query: O(1)\n;;;\n\n;; TODO: non-global handling\n\n(defconstant +binom-size+ 510000)\n(defconstant +binom-mod+ #.(+ (expt 10 9) 7))\n\n(declaim ((simple-array (unsigned-byte 31) (*)) *fact* *fact-inv* *inv*))\n(defparameter *fact* (make-array +binom-size+ :element-type '(unsigned-byte 31))\n  \"table of factorials\")\n(defparameter *fact-inv* (make-array +binom-size+ :element-type '(unsigned-byte 31))\n  \"table of inverses of factorials\")\n(defparameter *inv* (make-array +binom-size+ :element-type '(unsigned-byte 31))\n  \"table of inverses of non-negative integers\")\n\n(defun initialize-binom ()\n  (declare (optimize (speed 3) (safety 0)))\n  (setf (aref *fact* 0) 1\n        (aref *fact* 1) 1\n        (aref *fact-inv* 0) 1\n        (aref *fact-inv* 1) 1\n        (aref *inv* 1) 1)\n  (loop for i from 2 below +binom-size+\n        do (setf (aref *fact* i) (mod (* i (aref *fact* (- i 1))) +binom-mod+)\n                 (aref *inv* i) (- +binom-mod+\n                                   (mod (* (aref *inv* (rem +binom-mod+ i))\n                                           (floor +binom-mod+ i))\n                                        +binom-mod+))\n                 (aref *fact-inv* i) (mod (* (aref *inv* i)\n                                             (aref *fact-inv* (- i 1)))\n                                          +binom-mod+))))\n\n(initialize-binom)\n\n(declaim (inline binom))\n(defun binom (n k)\n  \"Returns nCk.\"\n  (if (or (< n k) (< n 0) (< k 0))\n      0\n      (mod (* (aref *fact* n)\n              (mod (* (aref *fact-inv* k) (aref *fact-inv* (- n k))) +binom-mod+))\n           +binom-mod+)))\n\n(declaim (inline perm))\n(defun perm (n k)\n  \"Returns nPk.\"\n  (if (or (< n k) (< n 0) (< k 0))\n      0\n      (mod (* (aref *fact* n) (aref *fact-inv* (- n k))) +binom-mod+)))\n\n;; TODO: compiler macro or source-transform\n(declaim (inline multinomial))\n(defun multinomial (&rest ks)\n  \"Returns the multinomial coefficient K!/k_1!k_2!...k_n! for K = k_1 + k_2 +\n... + k_n. K must be equal to or smaller than\nMOST-POSITIVE-FIXNUM. (multinomial) returns 1.\"\n  (let ((sum 0)\n        (result 1))\n    (declare ((integer 0 #.most-positive-fixnum) result sum))\n    (dolist (k ks)\n      (incf sum k)\n      (setq result\n            (mod (* result (aref *fact-inv* k)) +binom-mod+)))\n    (mod (* result (aref *fact* sum)) +binom-mod+)))\n\n(declaim (inline stirling2))\n(defun stirling2 (n k)\n  \"Returns the stirling number of the second kind S2(n, k). Time complexity is\nO(klog(n)).\"\n  (declare ((integer 0 #.most-positive-fixnum) n k))\n  (labels ((mod-power (base exp)\n             (declare ((integer 0 #.most-positive-fixnum) base exp))\n             (loop with res of-type (integer 0 #.most-positive-fixnum) = 1\n                   while (> exp 0)\n                   when (oddp exp)\n                   do (setq res (mod (* res base) +binom-mod+))\n                   do (setq base (mod (* base base) +binom-mod+)\n                            exp (ash exp -1))\n                   finally (return res))))\n    (loop with result of-type fixnum = 0\n          for i from 0 to k\n          for delta = (mod (* (binom k i) (mod-power i n)) +binom-mod+)\n          when (evenp (- k i))\n          do (incf result delta)\n             (when (>= result +binom-mod+)\n               (decf result +binom-mod+))\n          else\n          do (decf result delta)\n             (when (< result 0)\n               (incf result +binom-mod+))\n          finally (return (mod (* result (aref *fact-inv* k)) +binom-mod+)))))\n\n(declaim (inline catalan))\n(defun catalan (n)\n  \"Returns the N-th Catalan number.\"\n  (declare ((integer 0 #.most-positive-fixnum) n))\n  (mod (* (aref *fact* (* 2 n))\n          (mod (* (aref *fact-inv* (+ n 1))\n                  (aref *fact-inv* n))\n               +binom-mod+))\n       +binom-mod+))\n\n;;;\n;;; Arithmetic operations with static modulus\n;;;\n\n;; FIXME: Currently MOD* and MOD+ doesn't apply MOD when the number of\n;; parameters is one.\n(defmacro define-mod-operations (divisor)\n  `(progn\n     (defun mod* (&rest args)\n       (reduce (lambda (x y) (mod (* x y) ,divisor)) args))\n\n     (defun mod+ (&rest args)\n       (reduce (lambda (x y) (mod (+ x y) ,divisor)) args))\n\n     #+sbcl\n     (eval-when (:compile-toplevel :load-toplevel :execute)\n       (locally (declare (muffle-conditions warning))\n         (sb-c:define-source-transform mod* (&rest args)\n           (if (null args)\n               1\n               (reduce (lambda (x y) `(mod (* ,x ,y) ,',divisor)) args)))\n         (sb-c:define-source-transform mod+ (&rest args)\n           (if (null args)\n               0\n               (reduce (lambda (x y) `(mod (+ ,x ,y) ,',divisor)) args)))))\n\n     (define-modify-macro incfmod (delta)\n       (lambda (x y) (mod (+ x y) ,divisor)))\n\n     (define-modify-macro decfmod (delta)\n       (lambda (x y) (mod (- x y) ,divisor)))\n\n     (define-modify-macro mulfmod (multiplier)\n       (lambda (x y) (mod (* x y) ,divisor)))))\n\n\n(declaim (inline mod-power))\n(defun mod-power (base power modulus)\n  \"Returns BASE^POWER mod MODULUS. Note: 0^0 = 1.\n\nBASE := integer\nPOWER, MODULUS := non-negative fixnum\"\n  (declare ((integer 0 #.most-positive-fixnum) modulus power)\n           (integer base))\n  (let ((base (mod base modulus))\n        (res (mod 1 modulus)))\n    (declare ((integer 0 #.most-positive-fixnum) base res))\n    (loop while (> power 0)\n          when (oddp power)\n          do (setq res (mod (* res base) modulus))\n          do (setq base (mod (* base base) modulus)\n                   power (ash power -1)))\n    res))\n\n\n(in-package :cl-user)\n\n(defmacro dbg (&rest forms)\n  #+swank\n  (if (= (length forms) 1)\n      `(format *error-output* \"~A => ~A~%\" ',(car forms) ,(car forms))\n      `(format *error-output* \"~A => ~A~%\" ',forms `(,,@forms)))\n  #-swank (declare (ignore forms)))\n\n(declaim (inline println))\n(defun println (obj &optional (stream *standard-output*))\n  (let ((*read-default-float-format* 'double-float))\n    (prog1 (princ obj stream) (terpri stream))))\n\n(defconstant +mod+ 1000000007)\n\n;;;\n;;; Body\n;;;\n\n(defun solve-small (n m)\n  (let ((res 0)\n        (univs (coerce (loop repeat m collect n) 'vector)))\n    (do-indices (indices univs)\n      (let ((indices (concatenate '(simple-array uint8 (*)) #(0) indices))\n            (ins 0)\n            (outs 0))\n        (loop for i from 1 below (length indices)\n              unless (= (aref indices (- i 1)) (aref indices i))\n              do (setf (ldb (byte 1 (aref indices i)) ins) 1))\n        (loop for i from 0 below (- (length indices) 1)\n              unless (= (aref indices i) (aref indices (+ i 1)))\n              do (setf (ldb (byte 1 (aref indices i)) outs) 1))\n        (when (= (- (ash 1 n) 1) ins outs)\n          ;; #>indices\n          (incf res))))\n    res))\n(define-mod-operations +mod+)\n(defun calc-total (n m)\n  (let ((res 0))\n    (loop for i from 0 to n\n          do (incfmod res (mod* (mod-power (- n i) (- m 2) +mod+)\n                                (binom n i)\n                                (if (evenp i) 1 -1))))\n    res))\n\n(defun calc-ab (n m x)\n  (assert (>= x 2))\n  (let ((res 0))\n    (loop for i from 0 to (- n 1)\n          do (incfmod res (mod* (mod-power (- n 1 i) (- m x 1) +mod+)\n                                (binom (- n 1) i)\n                                (if (evenp i) 1 -1))))\n    res))\n\n(defun calc-c (n m x+y)\n  (assert (>= x+y 4))\n  (let ((res 0))\n    (loop for i from 0 to (- n 2)\n          do (incfmod res (mod* (mod-power (- n 2 i) (- m x+y) +mod+)\n                                (binom (- n 2) i)\n                                (if (evenp i) 1 -1))))\n    res))\n\n(defun calc-1 (n m)\n  (let ((res 0))\n    (loop for i from 0 to (- n 1)\n          when (zerop i)\n          do (incfmod res (mod-power n (- m 2) +mod+))\n          else do (incfmod res (mod* (mod-power (- n i) (- m 2) +mod+)\n                                     (binom (- n 1) i)\n                                     (if (evenp i) 1 -1))))\n    res))\n\n;; (defun solve (n m)\n;;   (let* ((m (+ m 1))\n;;          (factor (calc-total n m)))\n;;     (loop for x from 2 to (- m 1)\n;;           do (decfmod factor (* 2 (calc-ab n m x))))\n;;     (loop for sum from 4 to m\n;;           do (incfmod factor #>(mod* (- sum 3) (calc-c n m sum))) )\n;;     #>factor\n;;     (let ((res (mod+ (mod* factor (- n 1))\n;;                      (calc-1 n m))))\n;;       res)))\n\n;; (defun solve* (n m)\n;;   (let* ((m (+ m 1))\n;;          (res 0))\n;;     (loop for len from 2 to m\n;;           for factor = #>(calc-1 n len)\n;;           do (incfmod res (mod* factor (mod-power (- n 1) (- m len) +mod+))))\n;;     res))\n\n(defun solve (n m)\n  (let ((dp (make-array (list (+ m 1) (+ n 1) (+ n 1))\n                        :element-type 'uint31\n                        :initial-element 0)))\n    (setf (aref dp 0 1 0) 1)\n    (dotimes (x m)\n      (dotimes (y (+ n 1))\n        (dotimes (z (+ n 1))\n          (unless (zerop (aref dp x y z))\n            (incfmod (aref dp (+ x 1) (+ y z) 0)\n                     (mod* (aref dp x y z) y))\n            (incfmod (aref dp (+ x 1) y (+ z 1))\n                     (mod* (aref dp x y z) (- n y z)))\n            (incfmod (aref dp (+ x 1) y z)\n                     (mod* (aref dp x y z) z))))))\n    ;; #>dp\n    (aref dp m n 0)))\n(defun main ()\n  (let* ((n (read))\n         (m (read)))\n    (println (solve n m))))\n\n#-swank (main)\n\n;;;\n;;; Test and benchmark\n;;;\n\n#+swank\n(defun io-equal (in-string out-string &key (function #'main) (test #'equal))\n  \"Passes IN-STRING to *STANDARD-INPUT*, executes FUNCTION, and returns true if\nthe string output to *STANDARD-OUTPUT* is equal to OUT-STRING.\"\n  (labels ((ensure-last-lf (s)\n             (if (eql (uiop:last-char s) #\\Linefeed)\n                 s\n                 (uiop:strcat s uiop:+lf+))))\n    (funcall test\n             (ensure-last-lf out-string)\n             (with-output-to-string (out)\n               (let ((*standard-output* out))\n                 (with-input-from-string (*standard-input* (ensure-last-lf in-string))\n                   (funcall function)))))))\n\n#+swank\n(defun get-clipbrd ()\n  (with-output-to-string (out)\n    #+os-windows (run-program \"powershell.exe\" '(\"-Command\" \"Get-Clipboard\") :output out :search t)\n    #+os-unix (run-program \"xsel\" '(\"-b\" \"-o\") :output out :search t)))\n\n#+swank (defparameter *this-pathname* (uiop:current-lisp-file-pathname))\n#+swank (defparameter *dat-pathname* (uiop:merge-pathnames* \"test.dat\" *this-pathname*))\n\n#+swank\n(defun run (&optional thing (out *standard-output*))\n  \"THING := null | string | symbol | pathname\n\nnull: run #'MAIN using the text on clipboard as input.\nstring: run #'MAIN using the string as input.\nsymbol: alias of FIVEAM:RUN!.\npathname: run #'MAIN using the text file as input.\"\n  (let ((*standard-output* out))\n    (etypecase thing\n      (null\n       (with-input-from-string (*standard-input* (delete #\\Return (get-clipbrd)))\n         (main)))\n      (string\n       (with-input-from-string (*standard-input* (delete #\\Return thing))\n         (main)))\n      (symbol (5am:run! thing))\n      (pathname\n       (with-open-file (*standard-input* thing)\n         (main))))))\n\n#+swank\n(defun gen-dat ()\n  (uiop:with-output-file (out *dat-pathname* :if-exists :supersede)\n    (format out \"\")))\n\n#+swank\n(defun bench (&optional (out (make-broadcast-stream)))\n  (time (run *dat-pathname* out)))\n"
  },
  {
    "language": "Lisp",
    "code": "(eval-when (:compile-toplevel :load-toplevel :execute)\n  (sb-int:defconstant-eqx opt\n    #+swank '(optimize (speed 3) (safety 2))\n    #-swank '(optimize (speed 3) (safety 0) (debug 0))\n    #'equal)\n  #+swank (ql:quickload '(:cl-debug-print :fiveam) :silent t)\n  #-swank (set-dispatch-macro-character\n           #\\# #\\> (lambda (s c p) (declare (ignore c p)) `(values ,(read s nil nil t)))))\n#+swank (cl-syntax:use-syntax cl-debug-print:debug-print-syntax)\n\n(defmacro define-int-types (&rest bits)\n  `(progn\n     ,@(mapcar (lambda (b) `(deftype ,(intern (format nil \"UINT~A\" b)) () '(unsigned-byte ,b))) bits)\n     ,@(mapcar (lambda (b) `(deftype ,(intern (format nil \"INT~A\" b)) () '(signed-byte ,b))) bits)))\n(define-int-types 2 4 7 8 15 16 31 32 62 63 64)\n\n;; BEGIN_INSERTED_CONTENTS\n;;;\n;;; Arithmetic operations with static modulus\n;;;\n\n;; FIXME: Currently MOD* and MOD+ doesn't apply MOD when the number of\n;; parameters is one.\n(defmacro define-mod-operations (divisor)\n  `(progn\n     (defun mod* (&rest args)\n       (reduce (lambda (x y) (mod (* x y) ,divisor)) args))\n\n     (defun mod+ (&rest args)\n       (reduce (lambda (x y) (mod (+ x y) ,divisor)) args))\n\n     #+sbcl\n     (eval-when (:compile-toplevel :load-toplevel :execute)\n       (locally (declare (muffle-conditions warning))\n         (sb-c:define-source-transform mod* (&rest args)\n           (if (null args)\n               1\n               (reduce (lambda (x y) `(mod (* ,x ,y) ,',divisor)) args)))\n         (sb-c:define-source-transform mod+ (&rest args)\n           (if (null args)\n               0\n               (reduce (lambda (x y) `(mod (+ ,x ,y) ,',divisor)) args)))))\n\n     (define-modify-macro incfmod (delta)\n       (lambda (x y) (mod (+ x y) ,divisor)))\n\n     (define-modify-macro decfmod (delta)\n       (lambda (x y) (mod (- x y) ,divisor)))\n\n     (define-modify-macro mulfmod (multiplier)\n       (lambda (x y) (mod (* x y) ,divisor)))))\n\n(in-package :cl-user)\n\n(defmacro dbg (&rest forms)\n  #+swank\n  (if (= (length forms) 1)\n      `(format *error-output* \"~A => ~A~%\" ',(car forms) ,(car forms))\n      `(format *error-output* \"~A => ~A~%\" ',forms `(,,@forms)))\n  #-swank (declare (ignore forms)))\n\n(declaim (inline println))\n(defun println (obj &optional (stream *standard-output*))\n  (let ((*read-default-float-format* 'double-float))\n    (prog1 (princ obj stream) (terpri stream))))\n\n(defconstant +mod+ 1000000007)\n\n;;;\n;;; Body\n;;;\n\n(defun solve (n m)\n  (declare #.opt\n           ((integer 1 300) n m))\n  (let ((dp (make-array '(301 301 301)\n                        :element-type 'uint31\n                        :initial-element 0)))\n    (setf (aref dp 0 1 0) 1)\n    (dotimes (x m)\n      (dotimes (y (+ n 1))\n        (dotimes (z (+ n 1))\n          (unless (zerop (aref dp x y z))\n            (incfmod (aref dp (+ x 1) (+ y z) 0)\n                     (mod* (aref dp x y z) y))\n            (incfmod (aref dp (+ x 1) y (+ z 1))\n                     (mod* (aref dp x y z) (the uint31 (- n y z))))\n            (incfmod (aref dp (+ x 1) y z)\n                     (mod* (aref dp x y z) z))))))\n    (aref dp m n 0)))\n\n(defun main ()\n  (let* ((n (read))\n         (m (read)))\n    (println (solve n m))))\n\n#-swank (main)\n\n;;;\n;;; Test and benchmark\n;;;\n\n#+swank\n(defun io-equal (in-string out-string &key (function #'main) (test #'equal))\n  \"Passes IN-STRING to *STANDARD-INPUT*, executes FUNCTION, and returns true if\nthe string output to *STANDARD-OUTPUT* is equal to OUT-STRING.\"\n  (labels ((ensure-last-lf (s)\n             (if (eql (uiop:last-char s) #\\Linefeed)\n                 s\n                 (uiop:strcat s uiop:+lf+))))\n    (funcall test\n             (ensure-last-lf out-string)\n             (with-output-to-string (out)\n               (let ((*standard-output* out))\n                 (with-input-from-string (*standard-input* (ensure-last-lf in-string))\n                   (funcall function)))))))\n\n#+swank\n(defun get-clipbrd ()\n  (with-output-to-string (out)\n    #+os-windows (run-program \"powershell.exe\" '(\"-Command\" \"Get-Clipboard\") :output out :search t)\n    #+os-unix (run-program \"xsel\" '(\"-b\" \"-o\") :output out :search t)))\n\n#+swank (defparameter *this-pathname* (uiop:current-lisp-file-pathname))\n#+swank (defparameter *dat-pathname* (uiop:merge-pathnames* \"test.dat\" *this-pathname*))\n\n#+swank\n(defun run (&optional thing (out *standard-output*))\n  \"THING := null | string | symbol | pathname\n\nnull: run #'MAIN using the text on clipboard as input.\nstring: run #'MAIN using the string as input.\nsymbol: alias of FIVEAM:RUN!.\npathname: run #'MAIN using the text file as input.\"\n  (let ((*standard-output* out))\n    (etypecase thing\n      (null\n       (with-input-from-string (*standard-input* (delete #\\Return (get-clipbrd)))\n         (main)))\n      (string\n       (with-input-from-string (*standard-input* (delete #\\Return thing))\n         (main)))\n      (symbol (5am:run! thing))\n      (pathname\n       (with-open-file (*standard-input* thing)\n         (main))))))\n\n#+swank\n(defun gen-dat ()\n  (uiop:with-output-file (out *dat-pathname* :if-exists :supersede)\n    (format out \"\")))\n\n#+swank\n(defun bench (&optional (out (make-broadcast-stream)))\n  (time (run *dat-pathname* out)))\n"
  },
  {
    "language": "Lisp",
    "code": "(eval-when (:compile-toplevel :load-toplevel :execute)\n  (sb-int:defconstant-eqx opt\n    #+swank '(optimize (speed 3) (safety 2))\n    #-swank '(optimize (speed 3) (safety 0) (debug 0))\n    #'equal)\n  #+swank (ql:quickload '(:cl-debug-print :fiveam) :silent t)\n  #-swank (set-dispatch-macro-character\n           #\\# #\\> (lambda (s c p) (declare (ignore c p)) `(values ,(read s nil nil t)))))\n#+swank (cl-syntax:use-syntax cl-debug-print:debug-print-syntax)\n\n(defmacro define-int-types (&rest bits)\n  `(progn\n     ,@(mapcar (lambda (b) `(deftype ,(intern (format nil \"UINT~A\" b)) () '(unsigned-byte ,b))) bits)\n     ,@(mapcar (lambda (b) `(deftype ,(intern (format nil \"INT~A\" b)) () '(signed-byte ,b))) bits)))\n(define-int-types 2 4 7 8 15 16 31 32 62 63 64)\n\n;; BEGIN_INSERTED_CONTENTS\n;;;\n;;; Arithmetic operations with static modulus\n;;;\n\n;; FIXME: Currently MOD* and MOD+ doesn't apply MOD when the number of\n;; parameters is one.\n(defmacro define-mod-operations (divisor)\n  `(progn\n     (defun mod* (&rest args)\n       (reduce (lambda (x y) (mod (* x y) ,divisor)) args))\n\n     (defun mod+ (&rest args)\n       (reduce (lambda (x y) (mod (+ x y) ,divisor)) args))\n\n     #+sbcl\n     (eval-when (:compile-toplevel :load-toplevel :execute)\n       (locally (declare (muffle-conditions warning))\n         (sb-c:define-source-transform mod* (&rest args)\n           (if (null args)\n               1\n               (reduce (lambda (x y) `(mod (* ,x ,y) ,',divisor)) args)))\n         (sb-c:define-source-transform mod+ (&rest args)\n           (if (null args)\n               0\n               (reduce (lambda (x y) `(mod (+ ,x ,y) ,',divisor)) args)))))\n\n     (define-modify-macro incfmod (delta)\n       (lambda (x y)\n         (let ((tmp (+ x y)))\n           (if (>= tmp ,divisor)\n               (- tmp ,divisor)\n               tmp))))\n\n     (define-modify-macro decfmod (delta)\n       (lambda (x y) (mod (- x y) ,divisor)))\n\n     (define-modify-macro mulfmod (multiplier)\n       (lambda (x y) (mod (* x y) ,divisor)))))\n\n(in-package :cl-user)\n\n(defmacro dbg (&rest forms)\n  #+swank\n  (if (= (length forms) 1)\n      `(format *error-output* \"~A => ~A~%\" ',(car forms) ,(car forms))\n      `(format *error-output* \"~A => ~A~%\" ',forms `(,,@forms)))\n  #-swank (declare (ignore forms)))\n\n(declaim (inline println))\n(defun println (obj &optional (stream *standard-output*))\n  (let ((*read-default-float-format* 'double-float))\n    (prog1 (princ obj stream) (terpri stream))))\n\n(defconstant +mod+ 1000000007)\n\n;;;\n;;; Body\n;;;\n\n(define-mod-operations +mod+)\n\n(defun solve (n m)\n  (declare #.opt\n           ((integer 1 300) n m))\n  (let ((dp (make-array '(301 301 301) :element-type 'uint31 :initial-element 0)))\n    (setf (aref dp 0 1 0) 1)\n    (dotimes (x m)\n      (dotimes (y (+ n 1))\n        (dotimes (z (+ n 1))\n          (unless (zerop (aref dp x y z))\n            (incfmod (aref dp (+ x 1) (+ y z) 0)\n                     (mod* (aref dp x y z) y))\n            (incfmod (aref dp (+ x 1) y (+ z 1))\n                     (mod* (aref dp x y z) (the uint31 (- n y z))))\n            (incfmod (aref dp (+ x 1) y z)\n                     (mod* (aref dp x y z) z))))))\n    (aref dp m n 0)))\n\n(defun main ()\n  (let* ((n (read))\n         (m (read)))\n    (println (solve n m))))\n\n#-swank (main)\n\n;;;\n;;; Test and benchmark\n;;;\n\n#+swank\n(defun io-equal (in-string out-string &key (function #'main) (test #'equal))\n  \"Passes IN-STRING to *STANDARD-INPUT*, executes FUNCTION, and returns true if\nthe string output to *STANDARD-OUTPUT* is equal to OUT-STRING.\"\n  (labels ((ensure-last-lf (s)\n             (if (eql (uiop:last-char s) #\\Linefeed)\n                 s\n                 (uiop:strcat s uiop:+lf+))))\n    (funcall test\n             (ensure-last-lf out-string)\n             (with-output-to-string (out)\n               (let ((*standard-output* out))\n                 (with-input-from-string (*standard-input* (ensure-last-lf in-string))\n                   (funcall function)))))))\n\n#+swank\n(defun get-clipbrd ()\n  (with-output-to-string (out)\n    #+os-windows (run-program \"powershell.exe\" '(\"-Command\" \"Get-Clipboard\") :output out :search t)\n    #+os-unix (run-program \"xsel\" '(\"-b\" \"-o\") :output out :search t)))\n\n#+swank (defparameter *this-pathname* (uiop:current-lisp-file-pathname))\n#+swank (defparameter *dat-pathname* (uiop:merge-pathnames* \"test.dat\" *this-pathname*))\n\n#+swank\n(defun run (&optional thing (out *standard-output*))\n  \"THING := null | string | symbol | pathname\n\nnull: run #'MAIN using the text on clipboard as input.\nstring: run #'MAIN using the string as input.\nsymbol: alias of FIVEAM:RUN!.\npathname: run #'MAIN using the text file as input.\"\n  (let ((*standard-output* out))\n    (etypecase thing\n      (null\n       (with-input-from-string (*standard-input* (delete #\\Return (get-clipbrd)))\n         (main)))\n      (string\n       (with-input-from-string (*standard-input* (delete #\\Return thing))\n         (main)))\n      (symbol (5am:run! thing))\n      (pathname\n       (with-open-file (*standard-input* thing)\n         (main))))))\n\n#+swank\n(defun gen-dat ()\n  (uiop:with-output-file (out *dat-pathname* :if-exists :supersede)\n    (format out \"\")))\n\n#+swank\n(defun bench (&optional (out (make-broadcast-stream)))\n  (time (run *dat-pathname* out)))\n"
  },
  {
    "language": "Ruby",
    "code": "K=10**9+7\nN,M=gets.split.map &:to_i\nA=(M+1).times.map{(N+2).times.map{[0]*(N+2)}}\nA[0][1][1]=1\nM.times{|i|(N+1).times{|j|(N+1).times{|k|\n\tA[i+1][j+1][k]=(A[i+1][j+1][k]+A[i][j][k]*(N-j))%K\n\tA[i+1][j][k]=(A[i+1][j][k]+A[i][j][k]*(j-k))%K\n\tA[i+1][j][j]=(A[i+1][j][j]+A[i][j][k]*k)%K\n}}}\np A[M][N][N]"
  },
  {
    "language": "D",
    "code": "import std.stdio, std.array, std.string, std.conv, std.algorithm;\nimport std.typecons, std.range, std.random, std.math, std.container;\nimport std.numeric, std.bigint, core.bitop, core.stdc.string;\n\nimmutable long MOD = 10^^9 + 7;\n\nvoid main() {\n    auto s = readln.split.map!(to!int);\n    auto N = s[0];\n    auto M = s[1];\n\n    auto dp = new long[][][](M+1, N, N);\n    dp[0][0][0] = 1;\n\n    foreach (i; 0..M) {\n        foreach (j; 0..N) {\n            foreach (k; 0..N) {\n                if (dp[i][j][k] == 0) {\n                    continue;\n                }\n                if (j < N - 1) {\n                    (dp[i+1][j+1][k] += dp[i][j][k]) %= MOD;\n                }\n                (dp[i+1][j][k] += dp[i][j][k] * (j - k) % MOD) %= MOD;\n                (dp[i+1][j][j] += dp[i][j][k] * (k + 1) % MOD) %= MOD;\n            }\n        }\n    }\n\n    long ans = dp[M][N-1][N-1];\n    foreach (i; 1..N) ans = ans * i % MOD;\n    ans.writeln;\n}\n"
  },
  {
    "language": "D",
    "code": "import std.stdio, std.array, std.string, std.conv, std.algorithm;\nimport std.typecons, std.range, std.random, std.math, std.container;\nimport std.numeric, std.bigint, core.bitop, core.stdc.string;\n\nimmutable long MOD = 10^^9 + 7;\n\nvoid main() {\n    auto s = readln.split.map!(to!int);\n    auto N = s[0];\n    auto M = s[1];\n\n    auto dp = new long[][][](2, N, N);\n    dp[0][0][0] = 1;\n\n    int cur = 0;\n    int tar = 1;\n\n    foreach (i; 0..M) {\n        foreach (j; 0..N) {\n            foreach (k; 0..N) {\n                dp[tar][j][k] = 0;\n            }\n        }\n        foreach (j; 0..N) {\n            foreach (k; 0..N) {\n                if (dp[cur][j][k] == 0) {\n                    continue;\n                }\n                if (j < N - 1) {\n                    (dp[tar][j+1][k] += dp[cur][j][k]) %= MOD;\n                }\n                (dp[tar][j][k] += dp[cur][j][k] * (j - k) % MOD) %= MOD;\n                (dp[tar][j][j] += dp[cur][j][k] * (k + 1) % MOD) %= MOD;\n            }\n        }\n        swap(cur, tar);\n    }\n\n    long ans = dp[cur][N-1][N-1];\n    foreach (i; 1..N) ans = ans * i % MOD;\n    ans.writeln;\n}\n"
  },
  {
    "language": "Python",
    "code": "import numpy as np\nN, M = map(int, raw_input().split())\n# one way path from 1, no path from 1\nstatus_mat = np.zeros((N, N), dtype='int')\nstatus_mat[0, N-1] = 1\n\nbothM = np.zeros((N, N), dtype='int')\nfor i in range(N):\n    for j in range(N):\n        bothM[i, j] = N-i-j\n\ndiagM = np.diag(range(N))\n\n\n\ndef update_status_mat(status_mat):\n    new_status_mat = diagM.dot(status_mat)\n    new_status_mat[0, :] += (bothM*status_mat).sum(axis=0)\n    new_status_mat[1:, :(N-1)] += status_mat.dot(diagM)[:(N-1), 1:]\n    return new_status_mat % 1000000007\n\nfor m in range(M):\n    status_mat = update_status_mat(status_mat)\n\nprint status_mat[0,0]"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict, deque, Counter\nfrom heapq import heappush, heappop, heapify\nimport math\nimport bisect\nimport random\nfrom itertools import permutations, accumulate, combinations, product\nimport sys\nimport string\nfrom bisect import bisect_left, bisect_right\nfrom math import factorial, ceil, floor, cos, radians, pi, sin\nfrom operator import mul\nfrom functools import reduce\nfrom operator import mul\nfrom functools import lru_cache\nfrom pprint import pprint\n\nmod = 10 ** 9 + 7\nsys.setrecursionlimit(2147483647)\nINF = 10 ** 20\ndef LI(): return list(map(int, sys.stdin.buffer.readline().split()))\ndef I(): return int(sys.stdin.buffer.readline())\ndef LS(): return sys.stdin.buffer.readline().rstrip().decode('utf-8').split()\ndef S(): return sys.stdin.buffer.readline().rstrip().decode('utf-8')\ndef IR(n): return [I() for i in range(n)]\ndef LIR(n): return [LI() for i in range(n)]\ndef SR(n): return [S() for i in range(n)]\ndef LSR(n): return [LS() for i in range(n)]\ndef SRL(n): return [list(S()) for i in range(n)]\ndef MSRL(n): return [[int(j) for j in list(S())] for i in range(n)]\n\n\nn, m = LI()\ndp = [[0] * (n + 1) for _ in range(n + 1)]\ndp[1][1] = 1\nfor _ in range(m):\n    new_dp = [[0] * (n + 1) for _ in range(n + 1)]\n    for j in range(1, n + 1):\n        for k in range(1, j + 1):\n            new_dp[j][j] += dp[j][k] * k % mod\n            new_dp[j][j] %= mod\n            new_dp[j][k] += dp[j][k] * (j - k) % mod\n            new_dp[j][k] %= mod\n            if j != n:\n                new_dp[j + 1][k] += dp[j][k] * (n - j) % mod\n                new_dp[j + 1][k] %= mod\n    dp = new_dp\n\n\nprint(dp[n][n])\n\n\n"
  },
  {
    "language": "Python",
    "code": "import numpy as np\nN, M = map(int, raw_input().split())\n# one way path from 1, no path from 1\nstatus_mat = np.zeros((N, N), dtype='int')\nstatus_mat[0, N-1] = 1\n \nbothM = np.zeros((N, N), dtype='int')\nfor i in range(N):\n    for j in range(N):\n        bothM[i, j] = N-i-j\n \ndiagM = np.diag(range(N))\n \n \n \ndef update_status_mat(status_mat):\n    new_status_mat = diagM.dot(status_mat)\n    new_status_mat[0, :] += (bothM*status_mat).sum(axis=0)\n    new_status_mat[1:, :(N-1)] += status_mat.dot(diagM)[:(N-1), 1:]\n    return new_status_mat % 1000000007\n \nfor m in range(M):\n    status_mat = update_status_mat(status_mat)\n \nprint status_mat[0,0]"
  },
  {
    "language": "Python",
    "code": "import numpy as np\nN = 150\nM = 300\n# one way path from 1, no path from 1\nstatus_mat = np.zeros((N, N), dtype='int')\nstatus_mat[0, N-1] = 1\n\nbothM = np.zeros((N, N), dtype='int')\nfor i in range(N):\n    for j in range(N):\n        bothM[i, j] = N-i-j\n\ndiagM = np.diag(range(N))\n\n\n\ndef update_status_mat(status_mat):\n    new_status_mat = diagM.dot(status_mat)\n    new_status_mat[0, :] += (bothM*status_mat).sum(axis=0)\n    new_status_mat[1:, :(N-1)] += status_mat.dot(diagM)[:(N-1), 1:]\n    return new_status_mat % 1000000007\n\nfor m in range(M):\n    status_mat = update_status_mat(status_mat)\n\nprint status_mat[0,0]"
  },
  {
    "language": "Python",
    "code": "import numpy as np\nN, M = map(int, raw_input().split())\n# one way path from 1, no path from 1\nstatus_mat = np.zeros((N, N), dtype='int')\nstatus_mat[0, N-1] = 1\n\nbothM = np.zeros((N, N), dtype='int')\nfor i in range(N):\n    for j in range(N):\n        bothM[i, j] = N-i-j\n\ndiagM = np.diag(range(N))\n\n\n\ndef update_status_mat(status_mat):\n    status_mat[0, 0] = 0\n    new_status_mat = diagM.dot(status_mat)\n    new_status_mat[0, :] += (bothM*status_mat).sum(axis=0)\n    new_status_mat[1:, :(N-1)] += status_mat.dot(diagM)[:(N-1), 1:]\n    return new_status_mat % 1000000007\n\nfor m in range(M):\n    status_mat = update_status_mat(status_mat)\n\nprint status_mat[0,0]"
  },
  {
    "language": "Python",
    "code": "K=10**9+7\nN,M=map(int,raw_input().split())\nA=[[[0]*(N+2) for j in range(N+2)] for i in range(M+1)]\nA[0][1][1]=1\nfor i in range(M):\n\tfor j in range(N+1):\n\t\tfor k in range(N+1):\n\t\t\tA[i+1][j+1][k]=(A[i+1][j+1][k]+A[i][j][k]*(N-j))%K\n\t\t\tA[i+1][j][k]=(A[i+1][j][k]+A[i][j][k]*(j-k))%K\n\t\t\tA[i+1][j][j]=(A[i+1][j][j]+A[i][j][k]*k)%K\nprint A[M][N][N]"
  },
  {
    "language": "Python",
    "code": "K=10**9+7\nN,M=map(int,input().split())\nA=[[[0]*(N+2) for j in range(N+2)] for i in range(M+1)]\nA[0][1][1]=1\nfor i in range(M):\n\tfor j in range(N+1):\n\t\tfor k in range(N+1):\n\t\t\tA[i+1][j+1][k]=(A[i+1][j+1][k]+A[i][j][k]*(N-j))%K\n\t\t\tA[i+1][j][k]=(A[i+1][j][k]+A[i][j][k]*(j-k))%K\n\t\t\tA[i+1][j][j]=(A[i+1][j][j]+A[i][j][k]*k)%K\nprint(A[M][N][N])"
  },
  {
    "language": "Python",
    "code": "# dp[i][j] := i 回の移動で頂点 1 から自由に j 個行き来できて王様がその中にいる場合の数\n# O(N^2 M^2) の解を書こうと思ったけど最後に戻ってこないパターンが抜けてる\n# 面倒になって諦め\n\nexit()\n\nclass Combination:\n    def __init__(self, n_max, mod=10**9+7):\n        # O(n_max + log(mod))\n        self.mod = mod\n        f = 1\n        self.fac = fac = [f]\n        for i in range(1, n_max+1):\n            f = f * i % mod\n            fac.append(f)\n        f = pow(f, mod-2, mod)\n        self.facinv = facinv = [f]\n        for i in range(n_max, 0, -1):\n            f = f * i % mod\n            facinv.append(f)\n        facinv.reverse()\n\n    # \"n 要素\" は区別できる n 要素\n    # \"k グループ\" はちょうど k グループ\n\n    def __call__(self, n, r):  # self.C と同じ\n        return self.fac[n] * self.facinv[r] % self.mod * self.facinv[n-r] % self.mod\n\n    def C(self, n, r):\n        if not 0 <= r <= n: return 0\n        return self.fac[n] * self.facinv[r] % self.mod * self.facinv[n-r] % self.mod\n\n    def P(self, n, r):\n        if not 0 <= r <= n: return 0\n        return self.fac[n] * self.facinv[n-r] % self.mod\n\n    def H(self, n, r):\n        if (n == 0 and r > 0) or r < 0: return 0\n        return self.fac[n+r-1] * self.facinv[r] % self.mod * self.facinv[n-1] % self.mod\n\n    def rising_factorial(self, n, r):  # 上昇階乗冪 n * (n+1) * ... * (n+r-1)\n        return self.fac[n+r-1] * self.facinv[n-1] % self.mod\n\n    def stirling_first(self, n, k):  # 第 1 種スターリング数  lru_cache を使うと O(nk)  # n 要素を k 個の巡回列に分割する場合の数\n        if n == k: return 1\n        if k == 0: return 0\n        return (self.stirling_first(n-1, k-1) + (n-1)*self.stirling_first(n-1, k)) % self.mod\n\n    def stirling_second(self, n, k):  # 第 2 種スターリング数 O(k + log(n))  # n 要素を区別のない k グループに分割する場合の数\n        if n == k: return 1  # n==k==0 のときのため\n        return self.facinv[k] * sum((-1)**(k-m) * self.C(k, m) * pow(m, n, self.mod) for m in range(1, k+1)) % self.mod\n\n    def balls_and_boxes_3(self, n, k):  # n 要素を区別のある k グループに分割する場合の数  O(k + log(n))\n        if n < k: return 0\n        return sum((-1)**(k-m) * self.C(k, m) * pow(m, n, self.mod) for m in range(1, k+1)) % self.mod\n\n    def bernoulli(self, n):  # ベルヌーイ数  lru_cache を使うと O(n**2 * log(mod))\n        if n == 0: return 1\n        if n % 2 and n >= 3: return 0  # 高速化\n        return (- pow(n+1, self.mod-2, self.mod) * sum(self.C(n+1, k) * self.bernoulli(k) % self.mod for k in range(n))) % self.mod\n\n    def faulhaber(self, k, n):  # べき乗和 0^k + 1^k + ... + (n-1)^k\n        # bernoulli に lru_cache を使うと O(k**2 * log(mod))  bernoulli が計算済みなら O(k * log(mod))\n        return pow(k+1, self.mod-2, self.mod) * sum(self.C(k+1, j) * self.bernoulli(j) % self.mod * pow(n, k-j+1, self.mod) % self.mod for j in range(k+1)) % self.mod\n\n    def lah(self, n, k):  # n 要素を k 個の空でない順序付き集合に分割する場合の数  O(1)\n        return self.C(n-1, k-1) * self.fac[n] % self.mod * self.facinv[k] % self.mod\n\n    def bell(self, n, k):  # n 要素を k グループ以下に分割する場合の数  O(k**2 + k*log(mod))\n        return sum(self.stirling_second(n, j) for j in range(1, k+1)) % self.mod\n\n\nmod = 10**9+7\ncomb = Combination(300, mod)\nballs_and_boxes_3 = [[0] * 301 for _ in range(301)]\nfor n in range(301):\n    for k in range(301):\n        balls_and_boxes_3[n][k] = comb.balls_and_boxes_3(n, k)\n\nN, M = map(int, input().split())\ndp = [[0] * (N+1) for _ in range(M+1)]\ndp[0][1] = 1\nfor i in range(1, M+1):\n    for j in range(1, N+1):\n        n, k = 1, 0\n        dp[i][j] += dp[i-1][j] * j % mod\n        for n in range(1, i+1):\n            for k in range(1, min(j-1, n)+1):  # k=0 の場合も\n                dp[i][j] += dp[i-n][j-k] * comb.C(N-(j-k), k) % mod * balls_and_boxes_3[n-1][k] % mod * (j-k) % mod\n\nfor d in dp:\n    print(d)\n\nprint(dp[-1][-1])\n"
  },
  {
    "language": "Python",
    "code": "n, m = map(int,raw_input().split())\nmod = 10 ** 9 + 7\ndp=[[[0] * (n + 1) for _ in xrange(n + 1)] for _ in xrange(m + 1)]\ndp[0][1][1] = 1\nfor i in xrange(m):\n    for j in xrange(1, n + 1):\n        for k in xrange(1, j + 1):\n            dp[i+1][min(j+1,n)][k] += dp[i][j][k] * (n - j)  % mod\n            dp[i+1][j][k] += dp[i][j][k] * (j - k) % mod\n            dp[i+1][j][j] += dp[i][j][k] * k % mod\nprint dp[m][n][n] % mod\n"
  },
  {
    "language": "Python",
    "code": "\n\"\"\"\nWriter: SPD_9X2\nhttps://atcoder.jp/contests/cf16-final-open/tasks/codefestival_2016_final_f\n\n街を、初めて訪れる順に順番つけすると街の順列を考えずに済むようになる\n\nまだ未訪問を状態0\n訪問したが、町1に戻れない街を、状態1\n街0にたどり着くことが出来る街を、状態2 とする\n\n出来ることは高々3つ。\n未訪問の街に行く→状態0の街が一つ減り、1の街が1つ増える\n状態1の街に行く→なにも変化なし\n状態2の街に行く→状態1の街が全て2に変わる\n\nあとはこれでdpしてあげて、順列を掛けてあげれば終わり!\n→べつにdp推移中に計算すればokだった\n\ndp推移は、dp[未訪問の街の数][状態1の街の数] = 移動の数\nでおｋ O(N**3)で解ける。\n\n\"\"\"\n\nN,M = map(int,input().split())\n\ndp = [ [0] * N for i in range(N) ]\ndp[N-1][0] = 1\nmod = 10**9+7\n\nfor loop in range(M):\n\n    ndp = [ [0] * N for i in range(N) ]\n\n    for i in range(N):\n\n        for j in range(N):\n\n            #未訪問に行く\n            if i != 0 and j != N-1:\n                ndp[i-1][j+1] += dp[i][j] * i\n                ndp[i-1][j+1] %= mod\n\n            #状態1の街に行く(少なくとも1つある場合)\n\n            if j > 0:\n                ndp[i][j] += dp[i][j] * j\n                ndp[i][j] %= mod\n\n            #状態2の街に行く\n\n            ndp[i][0] += dp[i][j] * (N-i-j)\n            ndp[i][0] %= mod\n\n    dp = ndp\n\nprint (dp[0][0] % mod)"
  },
  {
    "language": "Python",
    "code": "n, m = map(int,raw_input().split())\nmod = 10 ** 9 + 7\ndp=[[[0] * (n + 1) for _ in xrange(n + 1)] for _ in xrange(2)]\ndp[0][1][1] = 1\nfor i in xrange(m):\n    for j in xrange(n + 1):\n        for k in xrange(n + 1):\n            dp[(i+1)%2][j][k] = 0\n    for j in xrange(1, n + 1):\n        for k in xrange(1, j + 1):\n            dp[(i+1)%2][min(j+1,n)][k] += dp[i%2][j][k] * (n - j) % mod\n            dp[(i+1)%2][j][k] += dp[i%2][j][k] * (j - k) % mod\n            dp[(i+1)%2][j][j] += dp[i%2][j][k] * k % mod\nprint dp[m%2][n][n] % mod\n"
  },
  {
    "language": "Python",
    "code": "n, m = map(int,raw_input().split())\nmod = 10**9 + 7\ndp=[[[0] * (n + 1) for _ in xrange(n + 1)] for _ in xrange(2)]\ndp[0][1][1] = 1\nfor i in xrange(m):\n    for j in xrange(1, n + 1):\n        for k in xrange(1, j + 1):\n            dp[(i+1)&1][min(j+1,n)][k] += dp[i&1][j][k] * (n - j)  % mod\n            dp[(i+1)&1][j][k] += dp[i&1][j][k] * (j - k) % mod\n            dp[(i+1)&1][j][j] += dp[i&1][j][k] * k % mod\nprint dp[m&1][n][n] % mod\n"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict, deque, Counter\nfrom heapq import heappush, heappop, heapify\nimport math\nimport bisect\nimport random\nfrom itertools import permutations, accumulate, combinations, product\nimport sys\nimport string\nfrom bisect import bisect_left, bisect_right\nfrom math import factorial, ceil, floor, cos, radians, pi, sin\nfrom operator import mul\nfrom functools import reduce\nfrom operator import mul\nfrom functools import lru_cache\nfrom pprint import pprint\n\nmod = 10 ** 9 + 7\nsys.setrecursionlimit(2147483647)\nINF = 10 ** 20\ndef LI(): return list(map(int, sys.stdin.buffer.readline().split()))\ndef I(): return int(sys.stdin.buffer.readline())\ndef LS(): return sys.stdin.buffer.readline().rstrip().decode('utf-8').split()\ndef S(): return sys.stdin.buffer.readline().rstrip().decode('utf-8')\ndef IR(n): return [I() for i in range(n)]\ndef LIR(n): return [LI() for i in range(n)]\ndef SR(n): return [S() for i in range(n)]\ndef LSR(n): return [LS() for i in range(n)]\ndef SRL(n): return [list(S()) for i in range(n)]\ndef MSRL(n): return [[int(j) for j in list(S())] for i in range(n)]\n\n\nn, m = LI()\ndp = [[[0] * (n + 1) for _ in range(n + 1)] for _ in range(m + 1)]\ndp[0][1][1] = 1\nfor i in range(m):\n    for j in range(1, n + 1):\n        for k in range(1, j + 1):\n            dp[i + 1][j][j] += dp[i][j][k] * k % mod\n            dp[i + 1][j][j] %= mod\n            dp[i + 1][j][k] += dp[i][j][k] * (j - k) % mod\n            dp[i + 1][j][k] %= mod\n            if j != n:\n                dp[i + 1][j + 1][k] += dp[i][j][k] * (n - j) % mod\n                dp[i + 1][j + 1][k] %= mod\n\n\nprint(dp[m][n][n])\n\n\n"
  },
  {
    "language": "Rust",
    "code": "#[allow(unused_macros)]\nmacro_rules! input {\n    (source = $s:expr, $($r:tt)*) => {\n        let mut iter = $s.split_whitespace();\n        let mut next = || { iter.next().unwrap() };\n        input_inner!{next, $($r)*}\n    };\n    ($($r:tt)*) => {\n        let stdin = std::io::stdin();\n        let mut bytes = std::io::Read::bytes(std::io::BufReader::new(stdin.lock()));\n        let mut next = move || -> String{\n            bytes\n                .by_ref()\n                .map(|r|r.unwrap() as char)\n                .skip_while(|c|c.is_whitespace())\n                .take_while(|c|!c.is_whitespace())\n                .collect()\n        };\n        input_inner!{next, $($r)*}\n    };\n}\n \n#[allow(unused_macros)]\nmacro_rules! input_inner {\n    ($next:expr) => {};\n    ($next:expr, ) => {};\n \n    ($next:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let mut $var = read_value!($next, $t);\n        input_inner!{$next $($r)*}\n    };\n}\n \n#[allow(unused_macros)]\nmacro_rules! read_value {\n    ($next:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($next, $t)),* )\n    };\n \n    ($next:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($next, $t)).collect::<Vec<_>>()\n    };\n \n    ($next:expr, chars) => {\n        read_value!($next, String).chars().collect::<Vec<char>>()\n    };\n \n    ($next:expr, bytes) => {\n        read_value!($next, String).into_bytes()\n    };\n \n    ($next:expr, usize1) => {\n        read_value!($next, usize) - 1\n    };\n \n    ($next:expr, $t:ty) => {\n        $next().parse::<$t>().expect(\"Parse error\")\n    };\n}\n \nuse std::cmp::Ordering;\nuse std::cmp;\nuse std::cmp::min;\nuse std::collections::BTreeMap;\nuse std::process;\nuse std::cmp::Ord;\nuse std::collections::HashMap;\nuse std::collections::HashSet;\nuse std::collections::VecDeque;\nuse std::collections::BTreeSet;\nuse std::mem;\nuse std::collections::BinaryHeap;\nuse std::hash::{Hash, Hasher};\n\n// ---------- begin ModInt ----------\n\n#[derive(Clone, Copy)]\nstruct ModInt(usize);\nimpl std::ops::Add for ModInt {\n    type Output = ModInt;\n    fn add(self, rhs: ModInt) -> Self::Output {\n        let mut d = self.0 + rhs.0;\n        if d >= MODu {\n            d -= MODu;\n        }\n        ModInt(d)\n    }\n}\n\nimpl std::ops::AddAssign for ModInt {\n    fn add_assign(&mut self, rhs: ModInt) {\n        *self = *self + rhs;\n    }\n}\n\nimpl std::ops::Sub for ModInt {\n    type Output = ModInt;\n    fn sub(self, rhs: ModInt) -> Self::Output {\n        let mut d = self.0 + MODu - rhs.0;\n        if d >= MODu {\n            d -= MODu;\n        }\n        ModInt(d)\n    }\n}\n\nimpl std::ops::SubAssign for ModInt {\n    fn sub_assign(&mut self, rhs: ModInt) {\n        *self = *self - rhs;\n    }\n}\n\nimpl std::ops::Mul for ModInt {\n    type Output = ModInt;\n    fn mul(self, rhs: ModInt) -> Self::Output {\n        ModInt((self.0 as u64 * rhs.0 as u64 % MODu as u64) as usize)\n    }\n}\n\nimpl std::ops::MulAssign for ModInt {\n    fn mul_assign(&mut self, rhs: ModInt) {\n        *self = *self * rhs;\n    }\n}\n\nimpl std::ops::Neg for ModInt {\n    type Output = ModInt;\n    fn neg(self) -> Self::Output {\n        ModInt(if self.0 == 0 {0} else {MODu - self.0})\n    }\n}\n\nimpl std::fmt::Display for ModInt {\n    fn fmt<'a>(&self, f: &mut std::fmt::Formatter<'a>) -> std::fmt::Result {\n        write!(f, \"{}\", self.0)\n    }\n}\n\nimpl std::str::FromStr for ModInt {\n    type Err = std::num::ParseIntError;\n    fn from_str(s: &str) -> Result<Self, Self::Err> {\n        let val = s.parse::<usize>()?;\n        Ok(ModInt::new(val))\n    }\n}\nimpl PartialEq for ModInt {\n    fn eq(&self, other: &Self) -> bool {\n        self.0 == other.0\n    }\n}\nimpl Hash for ModInt {\n    fn hash<H: Hasher>(&self, state: &mut H) {\n        self.0.hash(state);\n        self.0.hash(state);\n    }\n}\nimpl Eq for ModInt {}\n#[allow(dead_code)]\nimpl ModInt {\n    pub fn new(n: usize) -> ModInt {\n        ModInt(n % MODu)\n    }\n    pub fn zero() -> ModInt {\n        ModInt(0)\n    }\n    pub fn one() -> ModInt {\n        ModInt(1)\n    }\n    pub fn pow(self, mut n: usize) -> ModInt {\n        let mut t = ModInt::one();\n        let mut s = self;\n        while n > 0 {\n            if n & 1 == 1 {\n                t *= s;\n            }\n            s *= s;\n            n >>= 1;\n        }\n        t\n    }\n    pub fn inv(self) -> ModInt {\n        self.pow(MODu - 2)\n    }\n}\n// ---------- end ModInt ----------\n\n/// Equivalent to std::lowerbound and std::upperbound in c++\npub trait BinarySearch<T> {\n    fn lower_bound(&self, x:&T) -> usize;\n    fn upper_bound(&self, x:&T) -> usize;\n}\n \nimpl<T: Ord> BinarySearch<T> for VecDeque<T>{\n    fn lower_bound(&self, x: &T) -> usize {\n        let mut low = 0;\n        let mut high = self.len();\n \n        while low != high {\n            let mid = (low + high) / 2;\n            match self[mid].cmp(x) {\n                Ordering::Less => {\n                    low = mid + 1;\n                }\n                Ordering::Equal | Ordering::Greater => {\n                    high = mid;\n                }\n            }\n        }\n        low\n    }\n \n    fn upper_bound(&self, x: &T) -> usize {\n        let mut low = 0;\n        let mut high = self.len();\n \n        while low != high {\n            let mid = (low + high) / 2;\n            match self[mid].cmp(x) {\n                Ordering::Less | Ordering::Equal => {\n                    low = mid + 1;\n                }\n                Ordering::Greater => {\n                    high = mid;\n                }\n            }\n        }\n        low\n    }\n}\nimpl<T: Ord> BinarySearch<T> for [T]{\n    fn lower_bound(&self, x: &T) -> usize {\n        let mut low = 0;\n        let mut high = self.len();\n \n        while low != high {\n            let mid = (low + high) / 2;\n            match self[mid].cmp(x) {\n                Ordering::Less => {\n                    low = mid + 1;\n                }\n                Ordering::Equal | Ordering::Greater => {\n                    high = mid;\n                }\n            }\n        }\n        low\n    }\n \n    fn upper_bound(&self, x: &T) -> usize {\n        let mut low = 0;\n        let mut high = self.len();\n \n        while low != high {\n            let mid = (low + high) / 2;\n            match self[mid].cmp(x) {\n                Ordering::Less | Ordering::Equal => {\n                    low = mid + 1;\n                }\n                Ordering::Greater => {\n                    high = mid;\n                }\n            }\n        }\n        low\n    }\n}\n\nfn matmul(A:&Vec<Vec<i64>>, B:&Vec<Vec<i64>>) -> Vec<Vec<i64>>{\n    let mut C = vec![vec![0;B[0].len()];A.len()];\n    for i in 0..A.len(){\n        for k in 0..B.len(){\n            for j in 0..B[0].len(){\n                C[i][j] += A[i][k]*B[k][j];\n                C[i][j] %= MOD;\n            }\n        }\n    }\n    return C;\n}\nfn matpow(A:&mut Vec<Vec<i64>>, n:usize) -> Vec<Vec<i64>>{\n    let mut B = vec![vec![0;A.len()];A.len()];\n    for i in 0..A.len(){\n        B[i][i] = 1;\n    }\n    let mut n = n;\n    let mut tmp = A.clone();\n    while(n>0){\n        if n&1 == 1{B = matmul(&B, &tmp);}\n        tmp = matmul(&tmp, &tmp);\n        n>>=1;\n    }\n    return B;\n}\n\n \n \n \n\nfn divisor(n:usize) -> Vec<usize>{\n    let mut res:Vec<usize> = Vec::new(); \n    for i in 1..n+1{\n        if i*i>n{break;}\n        if n%i == 0{\n            res.push(i);\n            if i != n/i{\n                res.push(n/i);    \n            }    \n        }    \n    }\n    res\n}\nstruct UnionFind{\n    par:Vec<usize>,\n    rank:Vec<usize>,\n    size:Vec<usize>,\n    size_edge:Vec<usize>,\n}\nimpl UnionFind{\n    fn init(n:usize) -> UnionFind{\n        let mut par = vec![0;n];\n        for i in 0..n{\n            par[i] = i;\n        }\n        UnionFind{\n            par:par,\n            rank:vec![0;n],\n            size:vec![1;n],\n            size_edge:vec![0;n],\n        }\n    }\n    fn find(&mut self, x:usize) ->usize{\n        if(self.par[x] == x){\n            x\n        }\n        else{\n            let p = self.par[x];\n            let res = self.find(p);\n            self.par[x] = res;\n            res\n        }\n    }\n    fn same(&mut self, a:usize, b:usize)->bool{\n        self.find(a) == self.find(b)\n    }\n    fn unite(&mut self, a:usize, b:usize){\n        let x = self.find(a);\n        let y = self.find(b);\n        if x != y{\n            if (self.rank[x] < self.rank[y]){\n                self.par[x] = y;\n                self.size[y] += self.size[x];\n                self.size_edge[y] += self.size_edge[x];\n                self.size_edge[y] += 1;\n            }\n            else{\n                self.par[y] = x;\n                self.size[x] += self.size[y];\n                self.size_edge[x] += self.size_edge[y];\n                self.size_edge[x] += 1;\n                if(self.rank[x] == self.rank[y]){ self.rank[x]+=1;}\n            }\n            \n        }\n        else{\n            self.size_edge[x] += 1;\n        }\n    }\n    fn check_size(&mut self, a:usize) -> usize{\n        let x = self.find(a);\n        let s = self.size[x];\n        s\n    }\n}\npub struct Scanner<R> {\n    stdin: R,\n}\n \nimpl<R: std::io::Read> Scanner<R> {\n    pub fn read<T: std::str::FromStr>(&mut self) -> T {\n        use std::io::Read;\n        let buf = self\n            .stdin\n            .by_ref()\n            .bytes()\n            .map(|b| b.unwrap())\n            .skip_while(|&b| b == b' ' || b == b'\\n' || b == b'\\r')\n            .take_while(|&b| b != b' ' && b != b'\\n' && b != b'\\r')\n            .collect::<Vec<_>>();\n        std::str::from_utf8(&buf).unwrap()\n            .parse()\n            .ok()\n            .expect(\"Parse error.\")\n    }\n    pub fn vec<T: std::str::FromStr>(&mut self, n: usize) -> Vec<T> {\n        (0..n).map(|_| self.read()).collect()\n    }\n    pub fn chars(&mut self) -> Vec<char> {\n        self.read::<String>().chars().collect()\n    }\n}\nstruct LazySegTree<BiOp> {\n    n: usize,\n    val: Vec<i64>,\n    ma:Vec<i64>,\n    op: BiOp,\n    e: i64,\n    upe:i64,\n    inf:i64,\n}\n\nimpl<BiOp> LazySegTree<BiOp>\n    where BiOp: Fn(i64, i64) -> i64{\n    pub fn new(n_: usize, op: BiOp, e: i64, upe:i64, inf:i64) -> Self {\n        let mut n = 1;\n        while n < n_ { n *= 2; } // n is a power of 2\n\n        LazySegTree {n: n, val: vec![e; 2 * n ], ma:vec![upe;2*n], op: op, e: e, upe:upe, inf:inf}\n    }\n    pub fn query(&self, x:usize, y:usize, l:usize, r:usize, k:usize) -> i64 {\n        if (r<=x || y<=l) {return self.inf;}\n        if (x<=l && r<=y) {return self.ma[k];}\n        let mut L = self.query(x,y,l,(l+r)/2, k*2);\n        let mut R = self.query(x,y,(l+r)/2,r, k*2+1);\n        return self.val[k] + (self.op)(L, R);\n\n    }\n    \n    pub fn update(&mut self, x:usize, y:usize, v:i64, l:usize,r:usize, k:usize) {\n        if (l>=r) {return;}\n        if (x<=l && r<=y){\n            self.val[k]+=v;\n            self.ma[k]+=v;\n        }\n        else if(l<y && x<r){\n            self.update(x, y, v, l, (l+r)/2, k*2);\n            self.update(x,y,v,(l+r)/2,r, k*2+1);\n            self.ma[k] = self.val[k] + (self.op)(self.ma[k*2], self.ma[k*2+1]);\n        }\n    }\n}\nfn modinv(a:ModInt)->ModInt{\n    let mut a = a.0 as usize;\n    let mut b = MODu as i64;\n    let mut u = 1 as i64;\n    let mut v = 0 as i64;\n    let mut a = a as i64;\n    let mut m = MODu as i64;\n    while(b>0){\n        let mut t = a/b;\n        a -= t*b;\n        mem::swap(&mut a, &mut b);\n        u-=t*v;\n        mem::swap(&mut u, &mut v);    \n    }\n    u%=m;\n    if u<0{u+=m;}\n    return ModInt(u as usize);\n\n}\nfn modinv2(a:usize)->usize{\n    let mut a = a as usize;\n    let mut b = MODu as i64;\n    let mut u = 1 as i64;\n    let mut v = 0 as i64;\n    let mut a = a as i64;\n    let mut m = MODu as i64;\n    while(b>0){\n        let mut t = a/b;\n        a -= t*b;\n        mem::swap(&mut a, &mut b);\n        u-=t*v;\n        mem::swap(&mut u, &mut v);\n    }\n    u%=m;\n    if u<0{u+=m;}\n    return u as usize;\n\n}\nfn modpow(x:ModInt, n:ModInt) -> ModInt{\n        let mut ans = ModInt(1);\n        let mut n = n.0 as usize;\n        let mut x = x;\n        while(n != 0){\n            if (n&1 == 1){ans = ans*x;}\n            x = x*x;\n            n = n>>1;\n        }\n        ans\n}\nfn comb(a:usize, b:usize,  fac:&Vec<ModInt>, ifac:&Vec<ModInt>)->ModInt{\n        let mut a = a;\n        let mut b = b;\n        if a == 0 && b == 0{return ModInt(1);}\n        if a<b || a<0{return ModInt(0);}\n        let mut tmp = ifac[a-b]*ifac[b];\n        return tmp * fac[a];\n}\n\nfn invs()->(Vec<ModInt>, Vec<ModInt>){\n    let mut fac = vec![ModInt(0);300001];\n    let mut ifac = vec![ModInt(0);300001];\n    fac[0] = ModInt(1);\n    ifac[0] = ModInt(1);\n    for i in 0..300000{\n\n        fac[i+1] = fac[i] * ModInt(i+1);\n        ifac[i+1] = ifac[i] * modpow(ModInt(i+1), ModInt(MODu - 2));\n    }\n    (fac, ifac)\n}\n\nstruct ConvexHallTrick {\n    Q: Vec<(i64, i64)>,\n}\n\nimpl ConvexHallTrick{\n    pub fn new() -> Self {\n\n        ConvexHallTrick {Q: Vec::new()}\n    }\n    pub fn calc(&self, p:(i64, i64), x:i64)->i64{\n        return p.0 * x + p.1;\n    }\n    pub fn dodo(& self, A:(i64, i64), B:(i64, i64), C:(i64, i64)) -> bool{\n        //max or min\n        (A.1 - C.1) * (B.0 - A.0) <= (A.1 - B.1)*(C.0 - A.0)\n    }\n    pub fn add(&mut self, a:i64, b:i64){\n        self.Q.push((a, b));\n        let mut v = self.Q.len();\n        while(v >=3 && self.dodo(self.Q[v-3], self.Q[v-2], self.Q[v-1])){\n            self.Q[v-2] = self.Q[v-1];\n            self.Q.pop();\n            v = self.Q.len();\n        }\n    }\n    pub fn query(& self, x:i64) -> i64{\n        let mut L = -1;\n        let mut R = (self.Q.len() - 1) as i64;\n        while(R-L>1){\n            let mut m = (L+R)/2;\n            if self.calc(self.Q[m as usize], x)>=self.calc(self.Q[m as usize+1], x){\n                L=m;\n            }\n            else{\n                R=m;\n            }\n\n        }\n        return self.calc(self.Q[R as usize], x);\n    }\n}\n#[derive(Eq, PartialEq, Clone, Debug)]\npub struct Rev<T>(pub T);\nimpl<T: PartialOrd> PartialOrd for Rev<T> {\n    fn partial_cmp(&self, other: &Rev<T>) -> Option<Ordering> {\n        other.0.partial_cmp(&self.0)\n    }\n}\nimpl<T: Ord> Ord for Rev<T> {\n    fn cmp(&self, other: &Rev<T>) -> Ordering {\n        other.0.cmp(&self.0)\n    }\n}\nfn sieve(n:usize) -> (Vec<bool>, Vec<usize>){\n    let mut p:usize = 0;\n    let mut is_prime = vec![false; n+1];\n    let mut prime = Vec::new();\n    for i in 0..n+1{\n        is_prime[i] = true;\n    }\n    is_prime[0] = false;\n    is_prime[1] = false;\n    for i in 2..n+1{\n        if is_prime[i]{\n            prime.push(i as usize);\n            let mut j = 2*i;\n            while(j<=n){\n                is_prime[j] = false;\n                j+=i;\n            }\n        }\n    }\n    (is_prime, prime)\n    \n}\nfn nHr(n:usize, r:usize, fac:&Vec<ModInt>, ifac:&Vec<ModInt>) -> ModInt{\n    comb(n + r - 1, r, fac, ifac)\n}\nfn gcd(a:usize, b:usize)->usize{\n    if b==0{return a;}\n    return gcd(b, a%b);\n}\nfn lcm(a:usize, b:usize)->usize{\n    return (b/gcd(a, b))*a;\n}\nstruct SegTree_MOD<BiOp> {\n    n: usize,\n    dat: Vec<i64>,\n    op: BiOp,\n    e: i64,\n    mod_:i64,\n}\nimpl<BiOp> SegTree_MOD<BiOp>\n    where BiOp: Fn(i64, i64) -> i64 \n          {\n    pub fn new(n_: usize, op: BiOp, e: i64, mod_:i64) -> Self {\n        let mut n = 1;\n        while n < n_ { n *= 2; } // n is a power of 2\n        SegTree_MOD {n: n, dat: vec![e; 2 * n - 1], op: op, e: e, mod_:mod_}\n    }\n    /* ary[k] <- v */\n    pub fn update(&mut self, idx: usize, v: i64) {\n        let mut k = idx + self.n - 1;\n        self.dat[k] = v;\n        while k > 0 {\n            k = (k - 1) / 2;\n            self.dat[k] = (self.op)(self.dat[2 * k + 1], self.dat[2 * k + 2]);\n            self.dat[k] %= self.mod_;\n        }\n    }\n    /* [a, b) (note: half-inclusive)\n     * http://proc-cpuinfo.fixstars.com/2017/07/optimize-segment-tree/ */\n    pub fn query(&self, mut a: usize, mut b: usize) -> i64 {\n        let mut left = self.e;\n        let mut right = self.e;\n        a += self.n - 1;\n        b += self.n - 1;\n        while a < b {\n            if (a & 1) == 0 {\n                left = (self.op)(left, self.dat[a]);\n                left %= self.mod_;\n            }\n            if (b & 1) == 0 {\n                right = (self.op)(self.dat[b - 1], right);\n                right %= self.mod_;\n            }\n            a = a / 2;\n            b = (b - 1) / 2;\n        }\n        let mut res = (self.op)(left, right);\n        res %= self.mod_;\n        res\n        \n    }\n}\nfn modpow2(x:usize, n:usize) -> usize{\n        let mut ans = 1;\n        let mut n = n;\n        let mut x = x;\n        while(n != 0){\n            if (n&1 == 1){ans = ans*x%MODu;}\n            x = x*x%MODu;\n            n = n>>1;\n        }\n        ans\n}\n#[derive(Clone)]\nstruct PPUnionFind{\n    par:Vec<usize>,\n    rank:Vec<usize>,\n    time:Vec<usize>,\n    now:usize,\n    history:Vec<(usize, usize)>,\n}\nimpl PPUnionFind{\n    fn init(n:usize) -> PPUnionFind{\n        let mut par = vec![0;n];\n        for i in 0..n{\n            par[i] = i;\n        }\n        PPUnionFind{\n            par:par,\n            rank:vec![0;n],\n            time:vec![INF as usize;n],\n            now:0,\n            history:vec![],\n        }\n    }\n    fn find(&mut self, t:usize, x:usize) ->usize{\n        if self.time[x] > t{return x;}\n        else { let tt = self.par[x]; return self.find(t, tt);}\n    }\n    fn unite(&mut self, x:usize, y:usize) -> usize{\n        self.now+=1;\n        let mut x = x;\n        let mut y = y;\n        let nc = self.now;\n        x = self.find(nc, x);\n        y = self.find(nc, y);\n        if x == y{return self.now;}\n        if self.par[x] < self.par[y] {mem::swap(&mut x, &mut y);}\n        self.par[x] += self.par[y];\n        self.history.push((self.now, self.par[x]));\n        self.par[y] = x;\n        self.time[y] = self.now;\n        return self.now;\n    }\n}\n\nfn prim(cost:&Vec<Vec<(usize, i64)>>, vs:usize)->i64{\n    let mut used = vec![false; vs];\n    let mut bh = BinaryHeap::new();\n    for j in 0..cost[0].len(){\n            bh.push((cost[0][j].1 * -1, cost[0][j].0));\n    }\n    used[0] = true;\n    let mut res = 0;\n    while(bh.len()!=0){\n        let mut m = bh.pop().unwrap();\n        if used[m.1]{continue;}\n        used[m.1] = true;\n        for e in 0..cost[m.1].len(){\n            if used[cost[m.1][e].0] == false{\n                bh.push((cost[m.1][e].1 * -1, cost[m.1][e].0));\n            }\n        }\n        res += m.0*-1;\n    }\n    return res;\n}\nfn kruscal(cost:&mut Vec<(i64, usize, usize)>, vs:usize)->i64{\n    cost.sort();\n    let mut uf = UnionFind::init(vs);\n    let mut res = 0;\n\n    for i in 0..cost.len(){\n        let e = cost[i].clone();\n        if uf.find(e.1) != uf.find(e.2){\n            uf.unite(e.1, e.2);\n            res += e.0;\n        }\n    }\n    return res;\n}\nfn kruscal3(cost:&mut Vec<(f64, usize, usize, usize)>, vs:usize)->(UnionFind, Vec<usize>) {\n    cost.sort_by(|a, b| (&a.0).partial_cmp(&b.0).unwrap());\n    let mut uf = UnionFind::init(vs);\n    let mut res = 0.0;\n    let mut rv = Vec::new();\n    let mut c = 0.0;\n    let mut t = 0.0;\n    for i in 0..cost.len(){\n        let e = cost[i].clone();\n        if uf.find(e.1) != uf.find(e.2){\n            uf.unite(e.1, e.2);\n            rv.push(e.3);\n        }\n    }\n    return (uf,rv);\n}\nfn kruscal2(cost:&mut Vec<(f64, usize, usize)>, vs:usize)->f64{\n    cost.sort_by(|a, b| (&a.0).partial_cmp(&b.0).unwrap());\n    let mut uf = UnionFind::init(vs);\n    let mut res = 0.0;\n    for i in 0..cost.len(){\n        let e = cost[i].clone();\n        if uf.find(e.1) != uf.find(e.2){\n            uf.unite(e.1, e.2);\n            res+= e.0;\n        }\n    }\n    return res;\n}\n\nstruct segtree<I, Op>{\n    n: usize,\n    dat: Vec<I>,\n    op:Op,\n    e:I,\n}\nimpl<I, Op> segtree<I, Op>\n\n\n    where Op: Fn(I, I) -> I, I:Copy{\n        \n        pub fn new(n_:usize, op: Op, e:I)->Self{\n            let mut n = 1;\n            while(n<n_){n*=2;}\n            segtree{n: n, dat:vec![e; 2*n-1], op:op, e:e}\n        }\n        pub fn update(&mut self, k:usize, a:I){\n            let mut k = k;\n            k += self.n-1;\n            self.dat[k] = a;\n            while(k>0){\n                k = (k-1)/2;\n                self.dat[k] = (self.op)(self.dat[k*2 + 1], self.dat[k*2+2]);\n            }\n        }\n        pub fn query(&self, a:usize, b:usize, k:usize, l:usize, r:usize) -> I{\n            if r<=a || b<=l{return self.e;}\n            if a<=l && r<=b{return self.dat[k];}\n            else{\n                let mut vl = self.query(a, b, k*2+1, l, (l+r)/2);\n                let mut vr = self.query(a, b, k*2+2, (l+r)/2, r);\n                return (self.op)(vl, vr);\n            }\n        }\n    }\nstruct BIT<I, Op>{\n    n:usize,\n    bit:Vec<I>,\n    op:Op,\n    e:I,\n    ini:I,\n}\nimpl <I, Op>  BIT<I, Op>\n    /* 1-index*/  \n    where Op: Fn(I, I) -> I, I:Copy{\n        pub fn new(n_:usize, op:Op, e:I, ini:I)->Self{\n            BIT{n:n_, bit:vec![e;n_+1], op:op, e:e, ini:ini}\n        }\n        pub fn sum(&self, i:usize)->I{\n            let mut s = self.ini;\n            let mut i = i as i64;\n            while(i>0){\n                s = (self.op)(s, self.bit[i as usize]);\n                i -= i & -i;\n            }\n            return s;\n        }\n        pub fn add(&mut self, i:usize, x:I){\n            let mut i = i as i64;\n            while(i<=self.n as i64){\n                self.bit[i as usize] = (self.op)(self.bit[i as usize], x);\n                i += i & -i;\n            }\n        }\n    }\nstruct Dsegtree{\n    n: usize,\n    datA: Vec<i64>,\n    datB:Vec<i64>,\n    e:i64,\n}\nimpl Dsegtree{\n        pub fn new(n_:usize, e:i64)->Self{\n\n            Dsegtree{n:n_, datA:vec![e; 1<<22 - 1], datB:vec![e;1<<22 - 1], e:e}\n        }\n        pub fn update(&mut self,a:usize, b:usize, x:i64,  k:usize, l:usize, r:usize){\n            //println!(\"{} {} {} {} {} {}\", a, b, x, k , l, r);\n            if a<=l && r<=b{\n                self.datA[k] += x;\n            }\n            else if (l<b && a<r){\n                self.datB[k] += (cmp::min(b, r) as i64 - cmp::max(a, l) as i64) * x;\n                self.update(a, b, x, k*2+1, l, (l+r)/2);\n                self.update(a, b, x, k*2+2, (l+r)/2, r);\n            }\n        }\n        pub fn query(&self, a:usize, b:usize, k:usize, l:usize, r:usize) -> i64{\n            if (b<=l || r<=a){\n                return 0;\n            }\n            else if (a<=l && r<=b){\n                return self.datA[k] * ((r as i64-l as i64)) + self.datB[k];\n            }\n            else{\n                let mut res = (cmp::min(b, r) as i64 - cmp::max(a, l) as i64)* self.datA[k];\n                res += self.query(a, b, k*2+1, l, (l+r)/2);\n                res += self.query(a, b, k*2+2, (l+r)/2, r);\n                return res;\n            }\n        }\n    }\n/*\nunwrap_or_else\n*/\nfn prime_factor(n:usize)->HashMap<usize, usize>{\n    let mut res = HashMap::new();\n    let mut n = n;\n    for i in 2..n{\n        if i*i>n{break;}\n        while(n%i==0){\n            *res.entry(i).or_insert(0)+=1;\n            n/=i;\n        }\n    }\n    if n != 1{\n        res.insert(n, 1);\n    }\n    res\n}\nstruct rollinghash{\n    base:Vec<i64>,\n    Mod:Vec<i64>,\n    hash:Vec<Vec<i64>>,\n    power:Vec<Vec<i64>>,\n}\nimpl rollinghash{\n    pub fn new(s:&Vec<usize>)->Self{\n        let mut n = s.len();\n        let mut base = vec![1007, 2009];\n        let mut hash = vec![vec![0;n+1];2];\n        let mut power = vec![vec![1;n+1];2];\n        let mut Mod = vec![1000000007, 1000000009];\n        for iter in 0..2{\n            let mut ht = vec![0;n+1];\n            let mut pt = vec![1;n+1];\n            for i in 0..n{\n                hash[iter][i+1] = (hash[iter][i] * base[iter] + s[i] as i64) % Mod[iter];\n                power[iter][i+1] = power[iter][i] * base[iter] % Mod[iter];\n            }\n        }\n        return rollinghash{base:base, Mod:Mod, hash:hash, power:power}\n   \n    }\n    pub fn get(&self, l:usize, r:usize)->(i64, i64){\n        let mut res = self.hash[0][r] - self.hash[0][l] * self.power[0][r-l] % self.Mod[0];\n        if res<0{\n            res += self.Mod[0];\n        }\n        let mut res2 = self.hash[1][r] - self.hash[1][l] * self.power[1][r-l] % self.Mod[1];\n        if res2<0{\n            res2 += self.Mod[1];\n        }\n        return (res, res2);\n    }\n\n}\nstruct LCA{\n    G:Vec<Vec<i64>>,\n    parent:Vec<Vec<i64>>,\n    depth:Vec<i64>,\n    root:i64,\n}\nimpl LCA{\n    pub fn new(G:Vec<Vec<i64>>, N:i64,R:i64)->Self{\n        let D = (f64::log2(N as f64)) as i64 + 2;\n        LCA{G:G, parent:vec![vec![0;N as usize];1+D as usize], depth:vec![0;N as usize], root:R}\n    }\n    pub fn getP(&mut self, v:i64, p:i64, d:i64){\n        self.parent[0][v as usize] = p;\n        self.depth[v as usize] = d;\n        for i in 0..self.G[v as usize].len(){\n            if self.G[v as usize][i as usize] != p{\n                let n = self.G[v as usize][i as usize];\n                self.getP(n, v, d+1);\n            }\n        }\n    }\n    pub fn init(&mut self){\n        let root = self.root;\n        self.getP(root, -1, 0);\n        let V = self.depth.len();\n        let logN = f64::log2(V as f64) as i64 + 2;\n        for k in 0..logN{\n            for v in 0..V{\n                if self.parent[k as usize][v as usize] <0{\n                    self.parent[k as usize+1][v as usize] = -1;\n                }\n                else{\n                    self.parent[k as usize+1][v as usize] = self.parent[k as usize][ (self.parent[k as usize][v as usize]) as usize];\n                }\n            }\n        }\n    }\n    fn ft(&self, f:i64, d:i64)->i64{\n        let mut now = f;\n        let mut now2 = 0;\n        let V = self.depth.len();\n\n        let logN = f64::log2(V as f64) as i64 + 2;\n        let mut v = f;\n        for k in 0..logN{\n            if (d >> k) & 1 == 1{\n                v = self.parent[k as usize][v as usize];\n            }\n        }\n\n        return v;\n    }\n\n    fn lca(&mut self,u:i64, v:i64)->i64{\n        let mut u = u;\n        let mut v = v;\n        if self.depth[u as usize] > self.depth[v as usize]{\n            mem::swap(&mut u, &mut v);\n        }\n        let mut V = self.depth.len();\n        let logN = f64::log2(V as f64) as i64 + 2;\n        for k in 0..logN{\n            if ((self.depth[v as usize] - self.depth[u as usize]) >> k)&1 == 1{\n                v = self.parent[k as usize][v as usize];\n            }\n        }\n        if u == v{return u;}\n        for k in (0..logN).rev(){\n            if self.parent[k as usize][u as usize] != self.parent[k as usize][v as usize]{\n                u = self.parent[k as usize][u as usize];\n                v = self.parent[k as usize][v as usize];\n            }\n        }\n        return self.parent[0][u as usize];\n    }\n\n    fn dist(&mut self,u:i64, v:i64)->i64{\n        let lc = self.lca(u, v);\n        return self.depth[u as usize] + self.depth[v as usize] - 2* self.depth[lc as usize];\n    }\n\n}\nfn fast_prime_factor_table(ma:usize)->Vec<usize>{\n    let mut p = sieve(1001);\n    let mut minf = vec![0;ma];\n    for j in 0..p.1.len(){\n        let P = p.1[j];\n        let mut now = P;\n        for i in 2..ma{\n            if minf[now] ==0{\n                minf[now] = P;\n            }\n            now+=P;\n            if now>=ma{\n                break;\n            }\n        }\n    }\n    return minf;\n}\nfn area_rectanble(x1:f64, x2:f64, x3:f64, y1:f64, y2:f64, y3:f64)->f64{\n    let tmp = x1*y2 + x2*y3 + x3*y1 - y1*x2 - y2*x3 - y3*x1;\n    tmp.abs()/2.0\n}\n#[derive(PartialEq, Clone)]\nstruct FW(f64);\n\nimpl Eq for FW {}\n\nimpl PartialOrd for FW {\n    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n        self.0.partial_cmp(&other.0)\n    }\n}\n\nimpl Ord for FW {\n    fn cmp(&self, other: &FW) -> Ordering {\n        other.partial_cmp(self).unwrap()\n\n    }\n}\n/* parsing\n    fn expr(s:&Vec<char>, i:&mut usize) -> Vec<usize>{\n        let mut val = term(s, i);\n        while(*i<s.len() && (s[*i] == '+' || s[*i] == '-')){\n            let mut op = encode(s[*i]);\n            *i+=1;\n            let mut val2 = term(s, i);\n            val = cal(val, val2, op);\n        }\n        return val;\n    }\n    fn term(s:&Vec<char>, i:&mut usize) -> Vec<usize>{\n        let mut val = factor(s, i);\n        while(*i<s.len() && s[*i] == '*'){\n            let mut op = encode(s[*i]);\n            *i+=1;\n            let mut val2 = factor(s, i);\n            val = cal(val, val2, op);\n        }\n        return val;\n    }\n    fn factor(s:&Vec<char>, i:&mut usize)->Vec<usize>{\n        if s[*i] == 'R' || s[*i] == 'S' || s[*i] == 'P' || s[*i] == '?'{\n            let mut res = encode(s[*i]);\n            *i+=1;\n            return res;\n        }\n        *i+=1;\n        let mut ret = expr(s, i);\n        *i+=1;\n        return ret;\n    }\n*/\nfn matmulf64(A:&Vec<Vec<f64>>, B:&Vec<Vec<f64>>) -> Vec<Vec<f64>>{\n    let mut C = vec![vec![0.0;B[0].len()];A.len()];\n    for i in 0..A.len(){\n        for k in 0..B.len(){\n            for j in 0..B[0].len(){\n                C[i][j] += A[i][k]*B[k][j];\n            }\n        }\n    }\n    return C;\n}\n//sort_by_key(|a| vec![a[0], -a[1]]);\n//v.sort_by(|a, b| a.partial_cmp(b).unwrap());\n\n\n\n\n\n\nfn fact_mod(n:usize)->usize {\n    let mut  f = 1; \n    for i in 2..n+1{\n        f = f * (i % MODu) % MODu;\n    }\n    return f;\n}\n\nfn mod_pow(x:usize, n:usize) ->usize{\n    if(n == 0){ return 1;}\n    let mut res = mod_pow((x * x) % MODu, n / 2 );\n    if(n & 1 == 1){ res = (res * x) % MODu;}\n    return res;\n}\n\nfn comb2(n:usize, r:usize)->usize {\n    let mut n = n;\n    let mut r = r;\n    if(r > n-r) {r = n-r;}\n    if(r == 0) {return 1;}\n    let mut a = 1;\n    for i in 0..r{\n        a = a * ((n-i) % MODu) % MODu;\n    }\n    let mut b = mod_pow(fact_mod(r), MODu-2);\n    return (a % MODu) * (b % MODu) % MODu;\n}\n\n\n\n\nstruct scc{\n    G:Vec<Vec<usize>>,\n    rG:Vec<Vec<usize>>,\n    vs:Vec<usize>,\n    used:Vec<bool>,\n    cmp:Vec<usize>,\n}\nimpl scc{\n    pub fn new(N:usize, G:&Vec<Vec<usize>>, rG:&Vec<Vec<usize>>)->Self{\n        scc{G:G.clone(), rG:rG.clone(), vs:vec![], used:vec![false;N], cmp:vec![0;N]}\n    }\n    pub fn add_edge(&mut self, from:usize, to:usize){\n        self.G[from].push(to);\n        self.rG[to].push(from);\n    }\n    pub fn dfs(&mut self, v:usize){\n        self.used[v] = true;\n        for i in 0..self.G[v].len(){\n            let t = self.G[v][i];\n            if !self.used[t]{\n                self.dfs(t);\n            }\n        }\n        self.vs.push(v);\n    }\n    pub fn rdfs(&mut self, v:usize, k:usize){\n        self.used[v] = true;\n        self.cmp[v] = k;\n        for i in 0..self.rG[v].len(){\n            let t = self.rG[v][i];\n            if !self.used[t]{\n                self.rdfs(t, k);\n            }\n        }\n    }\n    pub fn scc(&mut self)->usize{\n        for v in 0..self.G.len(){\n            if !self.used[v]{\n                self.dfs(v);\n            }\n        }\n        self.used = vec![false;self.used.len()];\n        let mut k = 0;\n        for i in (0..self.vs.len()).rev(){\n            if !self.used[self.vs[i]]{\n                let t = self.vs[i];\n                self.rdfs(t, k);\n                k+=1;\n            }\n        }\n        k\n    }\n}\n\n\n#[macro_use]\nfn modinv3(a:i32)->i32{\n    let mut a = a as i32;\n    let mut b = MODu as i32;\n    let mut u = 1 as i32;\n    let mut v = 0 as i32;\n    let mut a = a as i32;\n    let mut m = MODu as i32;\n    while(b>0){\n        let mut t = a/b;\n        a -= t*b;\n        mem::swap(&mut a, &mut b);\n        u-=t*v;\n        mem::swap(&mut u, &mut v);\n    }\n    u%=m;\n    if u<0{u+=m;}\n    return u as i32;\n\n}\nfn solve(){\n    let sssss = std::io::stdin();\n    let mut sc = Scanner { stdin: sssss.lock() };\n    let mut N:usize = sc.read();\n    let mut M:usize = sc.read();\n    let mut dp = vec![vec![vec![0;2];N+1];N+1];\n    dp[1][0][0] = 1;\n    for i in 1..M+1{\n        let mut dp2 = vec![vec![vec![0;2];N+1];N+1];\n\n        for j in 0..cmp::min(N+1, i+10){\n\n            let mut min = 0;\n            if N>=M+j{\n                min = N-M-j;\n            }\n            for k in min..cmp::min(N+1, i+10){\n                //new\n                if N>=j+k{\n                    if k+1<=N{\n                        dp2[j][k+1][1] += dp[j][k][1]*(N-(j+k));\n                        dp2[j][k+1][1] %= MODu;\n\n                        dp2[j][k+1][1] += dp[j][k][0]*(N-(j+k));\n                        dp2[j][k+1][1] %= MODu;\n                    }\n                }\n                //from 1\n                if j+k<=N{\n                    dp2[j+k][0][0] += dp[j][k][1]*j;\n                    dp2[j+k][0][0] %= MODu;\n                }\n                dp2[j][k][1] += dp[j][k][1]*k;\n                dp2[j][k][1] %= MODu;\n                //from 0\n                dp2[j][k][0] += dp[j][k][0]*j;\n                dp2[j][k][0] %= MODu;\n            }\n        }\n        mem::swap(&mut dp, &mut dp2);\n    }\n    println!(\"{}\", dp[N][0][0]);\n\n\n}\n\n\nfn main(){\n    solve();\n}\nconst PI:f64 = std::f64::consts::PI;\npub static MOD:i64 = 1000000007;\npub static MODu:usize = 1000000007;\npub static MODi32:i32 = 1000000007;\npub static eps:f64 = 1e-6;\nconst INF: i64 = 1 << 62;\nconst INFu:usize = 1<<62;\n\n\n\n"
  },
  {
    "language": "Rust",
    "code": "#[allow(unused_imports)]\nuse std::io::{stdin, Read, StdinLock};\n#[allow(unused_imports)]\nuse std::cmp::{max, min, Ordering};\n#[allow(unused_imports)]\nuse std::str::FromStr;\n#[allow(unused_imports)]\nuse std::collections::{HashSet, HashMap, BinaryHeap, VecDeque};\n#[allow(unused_imports)]\nuse std::vec::Vec;\n\n#[allow(dead_code)]\nconst INF: i32 = 1000_000_000;\n#[allow(dead_code)]\nconst INFLL: i64 = 1000_000_000_000_000_000;\n#[allow(dead_code)]\nconst EPS: f64 = 1.0e-10;\n#[allow(dead_code)]\nconst MOD: i32 = 1000_000_007;\n#[allow(dead_code)]\nconst MODLL: i64 = 1000_000_007;\n\nstruct Scanner<'a> {\n    cin: StdinLock<'a>,\n}\n\n#[allow(dead_code)]\nimpl<'a> Scanner<'a> {\n    fn new(cin: StdinLock<'a>) -> Scanner<'a> {\n        Scanner {cin: cin}\n    }\n    fn read1<T: FromStr>(&mut self) -> Option<T> {\n        let token = self.cin.by_ref().bytes().map(|c| c.unwrap() as char)\n                    .skip_while(|c| c.is_whitespace())\n                    .take_while(|c| !c.is_whitespace())\n                    .collect::<String>();\n        token.parse::<T>().ok()\n    }\n    fn read<T: FromStr>(&mut self) -> T {\n        self.read1().unwrap()\n    }\n}\n\nfn main() {\n    let cin = stdin();\n    let cin = cin.lock();\n    let mut sc = Scanner::new(cin);\n\n    let (n, m): (usize, usize) = (sc.read(), sc.read());\n\n    let mut dp: Vec<Vec<i64>> = vec![vec![0; n + 1]; n + 1];\n    dp[1][n - 1] = 1 as i64;\n    for _i in 0..m {\n        let mut nxt: Vec<Vec<i64>> = vec![vec![0; n + 1]; n + 1];\n        for j in 0..n + 1 {\n            for k in 0..n + 1 {\n                nxt[n - k][k] += dp[j][k] * j as i64;\n                nxt[n - k][k] %= MODLL;\n                if k != 0 {\n                    nxt[j][k - 1] += dp[j][k] * k as i64;\n                    nxt[j][k - 1] %= MODLL;\n                }\n                nxt[j][k] += dp[j][k] * (n - k - j) as i64;\n                nxt[j][k] %= MODLL;\n            }\n        }\n        dp = nxt;\n    }\n\n    let ans = dp[n].iter().fold(0, |sum, a| sum + a) % MODLL;\n    println!(\"{}\", ans);\n}"
  },
  {
    "language": "Rust",
    "code": "#[allow(unused_macros)]\nmacro_rules! input {\n    (source = $s:expr, $($r:tt)*) => {\n        let mut iter = $s.split_whitespace();\n        let mut next = || { iter.next().unwrap() };\n        input_inner!{next, $($r)*}\n    };\n    ($($r:tt)*) => {\n        let stdin = std::io::stdin();\n        let mut bytes = std::io::Read::bytes(std::io::BufReader::new(stdin.lock()));\n        let mut next = move || -> String{\n            bytes\n                .by_ref()\n                .map(|r|r.unwrap() as char)\n                .skip_while(|c|c.is_whitespace())\n                .take_while(|c|!c.is_whitespace())\n                .collect()\n        };\n        input_inner!{next, $($r)*}\n    };\n}\n \n#[allow(unused_macros)]\nmacro_rules! input_inner {\n    ($next:expr) => {};\n    ($next:expr, ) => {};\n \n    ($next:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let mut $var = read_value!($next, $t);\n        input_inner!{$next $($r)*}\n    };\n}\n \n#[allow(unused_macros)]\nmacro_rules! read_value {\n    ($next:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($next, $t)),* )\n    };\n \n    ($next:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($next, $t)).collect::<Vec<_>>()\n    };\n \n    ($next:expr, chars) => {\n        read_value!($next, String).chars().collect::<Vec<char>>()\n    };\n \n    ($next:expr, bytes) => {\n        read_value!($next, String).into_bytes()\n    };\n \n    ($next:expr, usize1) => {\n        read_value!($next, usize) - 1\n    };\n \n    ($next:expr, $t:ty) => {\n        $next().parse::<$t>().expect(\"Parse error\")\n    };\n}\n \nuse std::cmp::Ordering;\nuse std::cmp;\nuse std::cmp::min;\nuse std::collections::BTreeMap;\nuse std::process;\nuse std::cmp::Ord;\nuse std::collections::HashMap;\nuse std::collections::HashSet;\nuse std::collections::VecDeque;\nuse std::collections::BTreeSet;\nuse std::mem;\nuse std::collections::BinaryHeap;\nuse std::hash::{Hash, Hasher};\n\n// ---------- begin ModInt ----------\n\n#[derive(Clone, Copy)]\nstruct ModInt(usize);\nimpl std::ops::Add for ModInt {\n    type Output = ModInt;\n    fn add(self, rhs: ModInt) -> Self::Output {\n        let mut d = self.0 + rhs.0;\n        if d >= MODu {\n            d -= MODu;\n        }\n        ModInt(d)\n    }\n}\n\nimpl std::ops::AddAssign for ModInt {\n    fn add_assign(&mut self, rhs: ModInt) {\n        *self = *self + rhs;\n    }\n}\n\nimpl std::ops::Sub for ModInt {\n    type Output = ModInt;\n    fn sub(self, rhs: ModInt) -> Self::Output {\n        let mut d = self.0 + MODu - rhs.0;\n        if d >= MODu {\n            d -= MODu;\n        }\n        ModInt(d)\n    }\n}\n\nimpl std::ops::SubAssign for ModInt {\n    fn sub_assign(&mut self, rhs: ModInt) {\n        *self = *self - rhs;\n    }\n}\n\nimpl std::ops::Mul for ModInt {\n    type Output = ModInt;\n    fn mul(self, rhs: ModInt) -> Self::Output {\n        ModInt((self.0 as u64 * rhs.0 as u64 % MODu as u64) as usize)\n    }\n}\n\nimpl std::ops::MulAssign for ModInt {\n    fn mul_assign(&mut self, rhs: ModInt) {\n        *self = *self * rhs;\n    }\n}\n\nimpl std::ops::Neg for ModInt {\n    type Output = ModInt;\n    fn neg(self) -> Self::Output {\n        ModInt(if self.0 == 0 {0} else {MODu - self.0})\n    }\n}\n\nimpl std::fmt::Display for ModInt {\n    fn fmt<'a>(&self, f: &mut std::fmt::Formatter<'a>) -> std::fmt::Result {\n        write!(f, \"{}\", self.0)\n    }\n}\n\nimpl std::str::FromStr for ModInt {\n    type Err = std::num::ParseIntError;\n    fn from_str(s: &str) -> Result<Self, Self::Err> {\n        let val = s.parse::<usize>()?;\n        Ok(ModInt::new(val))\n    }\n}\nimpl PartialEq for ModInt {\n    fn eq(&self, other: &Self) -> bool {\n        self.0 == other.0\n    }\n}\nimpl Hash for ModInt {\n    fn hash<H: Hasher>(&self, state: &mut H) {\n        self.0.hash(state);\n        self.0.hash(state);\n    }\n}\nimpl Eq for ModInt {}\n#[allow(dead_code)]\nimpl ModInt {\n    pub fn new(n: usize) -> ModInt {\n        ModInt(n % MODu)\n    }\n    pub fn zero() -> ModInt {\n        ModInt(0)\n    }\n    pub fn one() -> ModInt {\n        ModInt(1)\n    }\n    pub fn pow(self, mut n: usize) -> ModInt {\n        let mut t = ModInt::one();\n        let mut s = self;\n        while n > 0 {\n            if n & 1 == 1 {\n                t *= s;\n            }\n            s *= s;\n            n >>= 1;\n        }\n        t\n    }\n    pub fn inv(self) -> ModInt {\n        self.pow(MODu - 2)\n    }\n}\n// ---------- end ModInt ----------\n\n/// Equivalent to std::lowerbound and std::upperbound in c++\npub trait BinarySearch<T> {\n    fn lower_bound(&self, x:&T) -> usize;\n    fn upper_bound(&self, x:&T) -> usize;\n}\n \nimpl<T: Ord> BinarySearch<T> for VecDeque<T>{\n    fn lower_bound(&self, x: &T) -> usize {\n        let mut low = 0;\n        let mut high = self.len();\n \n        while low != high {\n            let mid = (low + high) / 2;\n            match self[mid].cmp(x) {\n                Ordering::Less => {\n                    low = mid + 1;\n                }\n                Ordering::Equal | Ordering::Greater => {\n                    high = mid;\n                }\n            }\n        }\n        low\n    }\n \n    fn upper_bound(&self, x: &T) -> usize {\n        let mut low = 0;\n        let mut high = self.len();\n \n        while low != high {\n            let mid = (low + high) / 2;\n            match self[mid].cmp(x) {\n                Ordering::Less | Ordering::Equal => {\n                    low = mid + 1;\n                }\n                Ordering::Greater => {\n                    high = mid;\n                }\n            }\n        }\n        low\n    }\n}\nimpl<T: Ord> BinarySearch<T> for [T]{\n    fn lower_bound(&self, x: &T) -> usize {\n        let mut low = 0;\n        let mut high = self.len();\n \n        while low != high {\n            let mid = (low + high) / 2;\n            match self[mid].cmp(x) {\n                Ordering::Less => {\n                    low = mid + 1;\n                }\n                Ordering::Equal | Ordering::Greater => {\n                    high = mid;\n                }\n            }\n        }\n        low\n    }\n \n    fn upper_bound(&self, x: &T) -> usize {\n        let mut low = 0;\n        let mut high = self.len();\n \n        while low != high {\n            let mid = (low + high) / 2;\n            match self[mid].cmp(x) {\n                Ordering::Less | Ordering::Equal => {\n                    low = mid + 1;\n                }\n                Ordering::Greater => {\n                    high = mid;\n                }\n            }\n        }\n        low\n    }\n}\n\nfn matmul(A:&Vec<Vec<i64>>, B:&Vec<Vec<i64>>) -> Vec<Vec<i64>>{\n    let mut C = vec![vec![0;B[0].len()];A.len()];\n    for i in 0..A.len(){\n        for k in 0..B.len(){\n            for j in 0..B[0].len(){\n                C[i][j] += A[i][k]*B[k][j];\n                C[i][j] %= MOD;\n            }\n        }\n    }\n    return C;\n}\nfn matpow(A:&mut Vec<Vec<i64>>, n:usize) -> Vec<Vec<i64>>{\n    let mut B = vec![vec![0;A.len()];A.len()];\n    for i in 0..A.len(){\n        B[i][i] = 1;\n    }\n    let mut n = n;\n    let mut tmp = A.clone();\n    while(n>0){\n        if n&1 == 1{B = matmul(&B, &tmp);}\n        tmp = matmul(&tmp, &tmp);\n        n>>=1;\n    }\n    return B;\n}\n\n \n \n \n\nfn divisor(n:usize) -> Vec<usize>{\n    let mut res:Vec<usize> = Vec::new(); \n    for i in 1..n+1{\n        if i*i>n{break;}\n        if n%i == 0{\n            res.push(i);\n            if i != n/i{\n                res.push(n/i);    \n            }    \n        }    \n    }\n    res\n}\nstruct UnionFind{\n    par:Vec<usize>,\n    rank:Vec<usize>,\n    size:Vec<usize>,\n    size_edge:Vec<usize>,\n}\nimpl UnionFind{\n    fn init(n:usize) -> UnionFind{\n        let mut par = vec![0;n];\n        for i in 0..n{\n            par[i] = i;\n        }\n        UnionFind{\n            par:par,\n            rank:vec![0;n],\n            size:vec![1;n],\n            size_edge:vec![0;n],\n        }\n    }\n    fn find(&mut self, x:usize) ->usize{\n        if(self.par[x] == x){\n            x\n        }\n        else{\n            let p = self.par[x];\n            let res = self.find(p);\n            self.par[x] = res;\n            res\n        }\n    }\n    fn same(&mut self, a:usize, b:usize)->bool{\n        self.find(a) == self.find(b)\n    }\n    fn unite(&mut self, a:usize, b:usize){\n        let x = self.find(a);\n        let y = self.find(b);\n        if x != y{\n            if (self.rank[x] < self.rank[y]){\n                self.par[x] = y;\n                self.size[y] += self.size[x];\n                self.size_edge[y] += self.size_edge[x];\n                self.size_edge[y] += 1;\n            }\n            else{\n                self.par[y] = x;\n                self.size[x] += self.size[y];\n                self.size_edge[x] += self.size_edge[y];\n                self.size_edge[x] += 1;\n                if(self.rank[x] == self.rank[y]){ self.rank[x]+=1;}\n            }\n            \n        }\n        else{\n            self.size_edge[x] += 1;\n        }\n    }\n    fn check_size(&mut self, a:usize) -> usize{\n        let x = self.find(a);\n        let s = self.size[x];\n        s\n    }\n}\npub struct Scanner<R> {\n    stdin: R,\n}\n \nimpl<R: std::io::Read> Scanner<R> {\n    pub fn read<T: std::str::FromStr>(&mut self) -> T {\n        use std::io::Read;\n        let buf = self\n            .stdin\n            .by_ref()\n            .bytes()\n            .map(|b| b.unwrap())\n            .skip_while(|&b| b == b' ' || b == b'\\n' || b == b'\\r')\n            .take_while(|&b| b != b' ' && b != b'\\n' && b != b'\\r')\n            .collect::<Vec<_>>();\n        std::str::from_utf8(&buf).unwrap()\n            .parse()\n            .ok()\n            .expect(\"Parse error.\")\n    }\n    pub fn vec<T: std::str::FromStr>(&mut self, n: usize) -> Vec<T> {\n        (0..n).map(|_| self.read()).collect()\n    }\n    pub fn chars(&mut self) -> Vec<char> {\n        self.read::<String>().chars().collect()\n    }\n}\nstruct LazySegTree<BiOp> {\n    n: usize,\n    val: Vec<i64>,\n    ma:Vec<i64>,\n    op: BiOp,\n    e: i64,\n    upe:i64,\n    inf:i64,\n}\n\nimpl<BiOp> LazySegTree<BiOp>\n    where BiOp: Fn(i64, i64) -> i64{\n    pub fn new(n_: usize, op: BiOp, e: i64, upe:i64, inf:i64) -> Self {\n        let mut n = 1;\n        while n < n_ { n *= 2; } // n is a power of 2\n\n        LazySegTree {n: n, val: vec![e; 2 * n ], ma:vec![upe;2*n], op: op, e: e, upe:upe, inf:inf}\n    }\n    pub fn query(&self, x:usize, y:usize, l:usize, r:usize, k:usize) -> i64 {\n        if (r<=x || y<=l) {return self.inf;}\n        if (x<=l && r<=y) {return self.ma[k];}\n        let mut L = self.query(x,y,l,(l+r)/2, k*2);\n        let mut R = self.query(x,y,(l+r)/2,r, k*2+1);\n        return self.val[k] + (self.op)(L, R);\n\n    }\n    \n    pub fn update(&mut self, x:usize, y:usize, v:i64, l:usize,r:usize, k:usize) {\n        if (l>=r) {return;}\n        if (x<=l && r<=y){\n            self.val[k]+=v;\n            self.ma[k]+=v;\n        }\n        else if(l<y && x<r){\n            self.update(x, y, v, l, (l+r)/2, k*2);\n            self.update(x,y,v,(l+r)/2,r, k*2+1);\n            self.ma[k] = self.val[k] + (self.op)(self.ma[k*2], self.ma[k*2+1]);\n        }\n    }\n}\nfn modinv(a:ModInt)->ModInt{\n    let mut a = a.0 as usize;\n    let mut b = MODu as i64;\n    let mut u = 1 as i64;\n    let mut v = 0 as i64;\n    let mut a = a as i64;\n    let mut m = MODu as i64;\n    while(b>0){\n        let mut t = a/b;\n        a -= t*b;\n        mem::swap(&mut a, &mut b);\n        u-=t*v;\n        mem::swap(&mut u, &mut v);    \n    }\n    u%=m;\n    if u<0{u+=m;}\n    return ModInt(u as usize);\n\n}\nfn modinv2(a:usize)->usize{\n    let mut a = a as usize;\n    let mut b = MODu as i64;\n    let mut u = 1 as i64;\n    let mut v = 0 as i64;\n    let mut a = a as i64;\n    let mut m = MODu as i64;\n    while(b>0){\n        let mut t = a/b;\n        a -= t*b;\n        mem::swap(&mut a, &mut b);\n        u-=t*v;\n        mem::swap(&mut u, &mut v);\n    }\n    u%=m;\n    if u<0{u+=m;}\n    return u as usize;\n\n}\nfn modpow(x:ModInt, n:ModInt) -> ModInt{\n        let mut ans = ModInt(1);\n        let mut n = n.0 as usize;\n        let mut x = x;\n        while(n != 0){\n            if (n&1 == 1){ans = ans*x;}\n            x = x*x;\n            n = n>>1;\n        }\n        ans\n}\nfn comb(a:usize, b:usize,  fac:&Vec<ModInt>, ifac:&Vec<ModInt>)->ModInt{\n        let mut a = a;\n        let mut b = b;\n        if a == 0 && b == 0{return ModInt(1);}\n        if a<b || a<0{return ModInt(0);}\n        let mut tmp = ifac[a-b]*ifac[b];\n        return tmp * fac[a];\n}\n\nfn invs()->(Vec<ModInt>, Vec<ModInt>){\n    let mut fac = vec![ModInt(0);300001];\n    let mut ifac = vec![ModInt(0);300001];\n    fac[0] = ModInt(1);\n    ifac[0] = ModInt(1);\n    for i in 0..300000{\n\n        fac[i+1] = fac[i] * ModInt(i+1);\n        ifac[i+1] = ifac[i] * modpow(ModInt(i+1), ModInt(MODu - 2));\n    }\n    (fac, ifac)\n}\n\nstruct ConvexHallTrick {\n    Q: Vec<(i64, i64)>,\n}\n\nimpl ConvexHallTrick{\n    pub fn new() -> Self {\n\n        ConvexHallTrick {Q: Vec::new()}\n    }\n    pub fn calc(&self, p:(i64, i64), x:i64)->i64{\n        return p.0 * x + p.1;\n    }\n    pub fn dodo(& self, A:(i64, i64), B:(i64, i64), C:(i64, i64)) -> bool{\n        //max or min\n        (A.1 - C.1) * (B.0 - A.0) <= (A.1 - B.1)*(C.0 - A.0)\n    }\n    pub fn add(&mut self, a:i64, b:i64){\n        self.Q.push((a, b));\n        let mut v = self.Q.len();\n        while(v >=3 && self.dodo(self.Q[v-3], self.Q[v-2], self.Q[v-1])){\n            self.Q[v-2] = self.Q[v-1];\n            self.Q.pop();\n            v = self.Q.len();\n        }\n    }\n    pub fn query(& self, x:i64) -> i64{\n        let mut L = -1;\n        let mut R = (self.Q.len() - 1) as i64;\n        while(R-L>1){\n            let mut m = (L+R)/2;\n            if self.calc(self.Q[m as usize], x)>=self.calc(self.Q[m as usize+1], x){\n                L=m;\n            }\n            else{\n                R=m;\n            }\n\n        }\n        return self.calc(self.Q[R as usize], x);\n    }\n}\n#[derive(Eq, PartialEq, Clone, Debug)]\npub struct Rev<T>(pub T);\nimpl<T: PartialOrd> PartialOrd for Rev<T> {\n    fn partial_cmp(&self, other: &Rev<T>) -> Option<Ordering> {\n        other.0.partial_cmp(&self.0)\n    }\n}\nimpl<T: Ord> Ord for Rev<T> {\n    fn cmp(&self, other: &Rev<T>) -> Ordering {\n        other.0.cmp(&self.0)\n    }\n}\nfn sieve(n:usize) -> (Vec<bool>, Vec<usize>){\n    let mut p:usize = 0;\n    let mut is_prime = vec![false; n+1];\n    let mut prime = Vec::new();\n    for i in 0..n+1{\n        is_prime[i] = true;\n    }\n    is_prime[0] = false;\n    is_prime[1] = false;\n    for i in 2..n+1{\n        if is_prime[i]{\n            prime.push(i as usize);\n            let mut j = 2*i;\n            while(j<=n){\n                is_prime[j] = false;\n                j+=i;\n            }\n        }\n    }\n    (is_prime, prime)\n    \n}\nfn nHr(n:usize, r:usize, fac:&Vec<ModInt>, ifac:&Vec<ModInt>) -> ModInt{\n    comb(n + r - 1, r, fac, ifac)\n}\nfn gcd(a:usize, b:usize)->usize{\n    if b==0{return a;}\n    return gcd(b, a%b);\n}\nfn lcm(a:usize, b:usize)->usize{\n    return (b/gcd(a, b))*a;\n}\nstruct SegTree_MOD<BiOp> {\n    n: usize,\n    dat: Vec<i64>,\n    op: BiOp,\n    e: i64,\n    mod_:i64,\n}\nimpl<BiOp> SegTree_MOD<BiOp>\n    where BiOp: Fn(i64, i64) -> i64 \n          {\n    pub fn new(n_: usize, op: BiOp, e: i64, mod_:i64) -> Self {\n        let mut n = 1;\n        while n < n_ { n *= 2; } // n is a power of 2\n        SegTree_MOD {n: n, dat: vec![e; 2 * n - 1], op: op, e: e, mod_:mod_}\n    }\n    /* ary[k] <- v */\n    pub fn update(&mut self, idx: usize, v: i64) {\n        let mut k = idx + self.n - 1;\n        self.dat[k] = v;\n        while k > 0 {\n            k = (k - 1) / 2;\n            self.dat[k] = (self.op)(self.dat[2 * k + 1], self.dat[2 * k + 2]);\n            self.dat[k] %= self.mod_;\n        }\n    }\n    /* [a, b) (note: half-inclusive)\n     * http://proc-cpuinfo.fixstars.com/2017/07/optimize-segment-tree/ */\n    pub fn query(&self, mut a: usize, mut b: usize) -> i64 {\n        let mut left = self.e;\n        let mut right = self.e;\n        a += self.n - 1;\n        b += self.n - 1;\n        while a < b {\n            if (a & 1) == 0 {\n                left = (self.op)(left, self.dat[a]);\n                left %= self.mod_;\n            }\n            if (b & 1) == 0 {\n                right = (self.op)(self.dat[b - 1], right);\n                right %= self.mod_;\n            }\n            a = a / 2;\n            b = (b - 1) / 2;\n        }\n        let mut res = (self.op)(left, right);\n        res %= self.mod_;\n        res\n        \n    }\n}\nfn modpow2(x:usize, n:usize) -> usize{\n        let mut ans = 1;\n        let mut n = n;\n        let mut x = x;\n        while(n != 0){\n            if (n&1 == 1){ans = ans*x%MODu;}\n            x = x*x%MODu;\n            n = n>>1;\n        }\n        ans\n}\n#[derive(Clone)]\nstruct PPUnionFind{\n    par:Vec<usize>,\n    rank:Vec<usize>,\n    time:Vec<usize>,\n    now:usize,\n    history:Vec<(usize, usize)>,\n}\nimpl PPUnionFind{\n    fn init(n:usize) -> PPUnionFind{\n        let mut par = vec![0;n];\n        for i in 0..n{\n            par[i] = i;\n        }\n        PPUnionFind{\n            par:par,\n            rank:vec![0;n],\n            time:vec![INF as usize;n],\n            now:0,\n            history:vec![],\n        }\n    }\n    fn find(&mut self, t:usize, x:usize) ->usize{\n        if self.time[x] > t{return x;}\n        else { let tt = self.par[x]; return self.find(t, tt);}\n    }\n    fn unite(&mut self, x:usize, y:usize) -> usize{\n        self.now+=1;\n        let mut x = x;\n        let mut y = y;\n        let nc = self.now;\n        x = self.find(nc, x);\n        y = self.find(nc, y);\n        if x == y{return self.now;}\n        if self.par[x] < self.par[y] {mem::swap(&mut x, &mut y);}\n        self.par[x] += self.par[y];\n        self.history.push((self.now, self.par[x]));\n        self.par[y] = x;\n        self.time[y] = self.now;\n        return self.now;\n    }\n}\n\nfn prim(cost:&Vec<Vec<(usize, i64)>>, vs:usize)->i64{\n    let mut used = vec![false; vs];\n    let mut bh = BinaryHeap::new();\n    for j in 0..cost[0].len(){\n            bh.push((cost[0][j].1 * -1, cost[0][j].0));\n    }\n    used[0] = true;\n    let mut res = 0;\n    while(bh.len()!=0){\n        let mut m = bh.pop().unwrap();\n        if used[m.1]{continue;}\n        used[m.1] = true;\n        for e in 0..cost[m.1].len(){\n            if used[cost[m.1][e].0] == false{\n                bh.push((cost[m.1][e].1 * -1, cost[m.1][e].0));\n            }\n        }\n        res += m.0*-1;\n    }\n    return res;\n}\nfn kruscal(cost:&mut Vec<(i64, usize, usize)>, vs:usize)->i64{\n    cost.sort();\n    let mut uf = UnionFind::init(vs);\n    let mut res = 0;\n\n    for i in 0..cost.len(){\n        let e = cost[i].clone();\n        if uf.find(e.1) != uf.find(e.2){\n            uf.unite(e.1, e.2);\n            res += e.0;\n        }\n    }\n    return res;\n}\nfn kruscal3(cost:&mut Vec<(f64, usize, usize, usize)>, vs:usize)->(UnionFind, Vec<usize>) {\n    cost.sort_by(|a, b| (&a.0).partial_cmp(&b.0).unwrap());\n    let mut uf = UnionFind::init(vs);\n    let mut res = 0.0;\n    let mut rv = Vec::new();\n    let mut c = 0.0;\n    let mut t = 0.0;\n    for i in 0..cost.len(){\n        let e = cost[i].clone();\n        if uf.find(e.1) != uf.find(e.2){\n            uf.unite(e.1, e.2);\n            rv.push(e.3);\n        }\n    }\n    return (uf,rv);\n}\nfn kruscal2(cost:&mut Vec<(f64, usize, usize)>, vs:usize)->f64{\n    cost.sort_by(|a, b| (&a.0).partial_cmp(&b.0).unwrap());\n    let mut uf = UnionFind::init(vs);\n    let mut res = 0.0;\n    for i in 0..cost.len(){\n        let e = cost[i].clone();\n        if uf.find(e.1) != uf.find(e.2){\n            uf.unite(e.1, e.2);\n            res+= e.0;\n        }\n    }\n    return res;\n}\n\nstruct segtree<I, Op>{\n    n: usize,\n    dat: Vec<I>,\n    op:Op,\n    e:I,\n}\nimpl<I, Op> segtree<I, Op>\n\n\n    where Op: Fn(I, I) -> I, I:Copy{\n        \n        pub fn new(n_:usize, op: Op, e:I)->Self{\n            let mut n = 1;\n            while(n<n_){n*=2;}\n            segtree{n: n, dat:vec![e; 2*n-1], op:op, e:e}\n        }\n        pub fn update(&mut self, k:usize, a:I){\n            let mut k = k;\n            k += self.n-1;\n            self.dat[k] = a;\n            while(k>0){\n                k = (k-1)/2;\n                self.dat[k] = (self.op)(self.dat[k*2 + 1], self.dat[k*2+2]);\n            }\n        }\n        pub fn query(&self, a:usize, b:usize, k:usize, l:usize, r:usize) -> I{\n            if r<=a || b<=l{return self.e;}\n            if a<=l && r<=b{return self.dat[k];}\n            else{\n                let mut vl = self.query(a, b, k*2+1, l, (l+r)/2);\n                let mut vr = self.query(a, b, k*2+2, (l+r)/2, r);\n                return (self.op)(vl, vr);\n            }\n        }\n    }\nstruct BIT<I, Op>{\n    n:usize,\n    bit:Vec<I>,\n    op:Op,\n    e:I,\n    ini:I,\n}\nimpl <I, Op>  BIT<I, Op>\n    /* 1-index*/  \n    where Op: Fn(I, I) -> I, I:Copy{\n        pub fn new(n_:usize, op:Op, e:I, ini:I)->Self{\n            BIT{n:n_, bit:vec![e;n_+1], op:op, e:e, ini:ini}\n        }\n        pub fn sum(&self, i:usize)->I{\n            let mut s = self.ini;\n            let mut i = i as i64;\n            while(i>0){\n                s = (self.op)(s, self.bit[i as usize]);\n                i -= i & -i;\n            }\n            return s;\n        }\n        pub fn add(&mut self, i:usize, x:I){\n            let mut i = i as i64;\n            while(i<=self.n as i64){\n                self.bit[i as usize] = (self.op)(self.bit[i as usize], x);\n                i += i & -i;\n            }\n        }\n    }\nstruct Dsegtree{\n    n: usize,\n    datA: Vec<i64>,\n    datB:Vec<i64>,\n    e:i64,\n}\nimpl Dsegtree{\n        pub fn new(n_:usize, e:i64)->Self{\n\n            Dsegtree{n:n_, datA:vec![e; 1<<22 - 1], datB:vec![e;1<<22 - 1], e:e}\n        }\n        pub fn update(&mut self,a:usize, b:usize, x:i64,  k:usize, l:usize, r:usize){\n            //println!(\"{} {} {} {} {} {}\", a, b, x, k , l, r);\n            if a<=l && r<=b{\n                self.datA[k] += x;\n            }\n            else if (l<b && a<r){\n                self.datB[k] += (cmp::min(b, r) as i64 - cmp::max(a, l) as i64) * x;\n                self.update(a, b, x, k*2+1, l, (l+r)/2);\n                self.update(a, b, x, k*2+2, (l+r)/2, r);\n            }\n        }\n        pub fn query(&self, a:usize, b:usize, k:usize, l:usize, r:usize) -> i64{\n            if (b<=l || r<=a){\n                return 0;\n            }\n            else if (a<=l && r<=b){\n                return self.datA[k] * ((r as i64-l as i64)) + self.datB[k];\n            }\n            else{\n                let mut res = (cmp::min(b, r) as i64 - cmp::max(a, l) as i64)* self.datA[k];\n                res += self.query(a, b, k*2+1, l, (l+r)/2);\n                res += self.query(a, b, k*2+2, (l+r)/2, r);\n                return res;\n            }\n        }\n    }\n/*\nunwrap_or_else\n*/\nfn prime_factor(n:usize)->HashMap<usize, usize>{\n    let mut res = HashMap::new();\n    let mut n = n;\n    for i in 2..n{\n        if i*i>n{break;}\n        while(n%i==0){\n            *res.entry(i).or_insert(0)+=1;\n            n/=i;\n        }\n    }\n    if n != 1{\n        res.insert(n, 1);\n    }\n    res\n}\nstruct rollinghash{\n    base:Vec<i64>,\n    Mod:Vec<i64>,\n    hash:Vec<Vec<i64>>,\n    power:Vec<Vec<i64>>,\n}\nimpl rollinghash{\n    pub fn new(s:&Vec<usize>)->Self{\n        let mut n = s.len();\n        let mut base = vec![1007, 2009];\n        let mut hash = vec![vec![0;n+1];2];\n        let mut power = vec![vec![1;n+1];2];\n        let mut Mod = vec![1000000007, 1000000009];\n        for iter in 0..2{\n            let mut ht = vec![0;n+1];\n            let mut pt = vec![1;n+1];\n            for i in 0..n{\n                hash[iter][i+1] = (hash[iter][i] * base[iter] + s[i] as i64) % Mod[iter];\n                power[iter][i+1] = power[iter][i] * base[iter] % Mod[iter];\n            }\n        }\n        return rollinghash{base:base, Mod:Mod, hash:hash, power:power}\n   \n    }\n    pub fn get(&self, l:usize, r:usize)->(i64, i64){\n        let mut res = self.hash[0][r] - self.hash[0][l] * self.power[0][r-l] % self.Mod[0];\n        if res<0{\n            res += self.Mod[0];\n        }\n        let mut res2 = self.hash[1][r] - self.hash[1][l] * self.power[1][r-l] % self.Mod[1];\n        if res2<0{\n            res2 += self.Mod[1];\n        }\n        return (res, res2);\n    }\n\n}\nstruct LCA{\n    G:Vec<Vec<i64>>,\n    parent:Vec<Vec<i64>>,\n    depth:Vec<i64>,\n    root:i64,\n}\nimpl LCA{\n    pub fn new(G:Vec<Vec<i64>>, N:i64,R:i64)->Self{\n        let D = (f64::log2(N as f64)) as i64 + 2;\n        LCA{G:G, parent:vec![vec![0;N as usize];1+D as usize], depth:vec![0;N as usize], root:R}\n    }\n    pub fn getP(&mut self, v:i64, p:i64, d:i64){\n        self.parent[0][v as usize] = p;\n        self.depth[v as usize] = d;\n        for i in 0..self.G[v as usize].len(){\n            if self.G[v as usize][i as usize] != p{\n                let n = self.G[v as usize][i as usize];\n                self.getP(n, v, d+1);\n            }\n        }\n    }\n    pub fn init(&mut self){\n        let root = self.root;\n        self.getP(root, -1, 0);\n        let V = self.depth.len();\n        let logN = f64::log2(V as f64) as i64 + 2;\n        for k in 0..logN{\n            for v in 0..V{\n                if self.parent[k as usize][v as usize] <0{\n                    self.parent[k as usize+1][v as usize] = -1;\n                }\n                else{\n                    self.parent[k as usize+1][v as usize] = self.parent[k as usize][ (self.parent[k as usize][v as usize]) as usize];\n                }\n            }\n        }\n    }\n    fn ft(&self, f:i64, d:i64)->i64{\n        let mut now = f;\n        let mut now2 = 0;\n        let V = self.depth.len();\n\n        let logN = f64::log2(V as f64) as i64 + 2;\n        let mut v = f;\n        for k in 0..logN{\n            if (d >> k) & 1 == 1{\n                v = self.parent[k as usize][v as usize];\n            }\n        }\n\n        return v;\n    }\n\n    fn lca(&mut self,u:i64, v:i64)->i64{\n        let mut u = u;\n        let mut v = v;\n        if self.depth[u as usize] > self.depth[v as usize]{\n            mem::swap(&mut u, &mut v);\n        }\n        let mut V = self.depth.len();\n        let logN = f64::log2(V as f64) as i64 + 2;\n        for k in 0..logN{\n            if ((self.depth[v as usize] - self.depth[u as usize]) >> k)&1 == 1{\n                v = self.parent[k as usize][v as usize];\n            }\n        }\n        if u == v{return u;}\n        for k in (0..logN).rev(){\n            if self.parent[k as usize][u as usize] != self.parent[k as usize][v as usize]{\n                u = self.parent[k as usize][u as usize];\n                v = self.parent[k as usize][v as usize];\n            }\n        }\n        return self.parent[0][u as usize];\n    }\n\n    fn dist(&mut self,u:i64, v:i64)->i64{\n        let lc = self.lca(u, v);\n        return self.depth[u as usize] + self.depth[v as usize] - 2* self.depth[lc as usize];\n    }\n\n}\nfn fast_prime_factor_table(ma:usize)->Vec<usize>{\n    let mut p = sieve(1001);\n    let mut minf = vec![0;ma];\n    for j in 0..p.1.len(){\n        let P = p.1[j];\n        let mut now = P;\n        for i in 2..ma{\n            if minf[now] ==0{\n                minf[now] = P;\n            }\n            now+=P;\n            if now>=ma{\n                break;\n            }\n        }\n    }\n    return minf;\n}\nfn area_rectanble(x1:f64, x2:f64, x3:f64, y1:f64, y2:f64, y3:f64)->f64{\n    let tmp = x1*y2 + x2*y3 + x3*y1 - y1*x2 - y2*x3 - y3*x1;\n    tmp.abs()/2.0\n}\n#[derive(PartialEq, Clone)]\nstruct FW(f64);\n\nimpl Eq for FW {}\n\nimpl PartialOrd for FW {\n    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n        self.0.partial_cmp(&other.0)\n    }\n}\n\nimpl Ord for FW {\n    fn cmp(&self, other: &FW) -> Ordering {\n        other.partial_cmp(self).unwrap()\n\n    }\n}\n/* parsing\n    fn expr(s:&Vec<char>, i:&mut usize) -> Vec<usize>{\n        let mut val = term(s, i);\n        while(*i<s.len() && (s[*i] == '+' || s[*i] == '-')){\n            let mut op = encode(s[*i]);\n            *i+=1;\n            let mut val2 = term(s, i);\n            val = cal(val, val2, op);\n        }\n        return val;\n    }\n    fn term(s:&Vec<char>, i:&mut usize) -> Vec<usize>{\n        let mut val = factor(s, i);\n        while(*i<s.len() && s[*i] == '*'){\n            let mut op = encode(s[*i]);\n            *i+=1;\n            let mut val2 = factor(s, i);\n            val = cal(val, val2, op);\n        }\n        return val;\n    }\n    fn factor(s:&Vec<char>, i:&mut usize)->Vec<usize>{\n        if s[*i] == 'R' || s[*i] == 'S' || s[*i] == 'P' || s[*i] == '?'{\n            let mut res = encode(s[*i]);\n            *i+=1;\n            return res;\n        }\n        *i+=1;\n        let mut ret = expr(s, i);\n        *i+=1;\n        return ret;\n    }\n*/\nfn matmulf64(A:&Vec<Vec<f64>>, B:&Vec<Vec<f64>>) -> Vec<Vec<f64>>{\n    let mut C = vec![vec![0.0;B[0].len()];A.len()];\n    for i in 0..A.len(){\n        for k in 0..B.len(){\n            for j in 0..B[0].len(){\n                C[i][j] += A[i][k]*B[k][j];\n            }\n        }\n    }\n    return C;\n}\n//sort_by_key(|a| vec![a[0], -a[1]]);\n//v.sort_by(|a, b| a.partial_cmp(b).unwrap());\n\n\n\n\n\n\nfn fact_mod(n:usize)->usize {\n    let mut  f = 1; \n    for i in 2..n+1{\n        f = f * (i % MODu) % MODu;\n    }\n    return f;\n}\n\nfn mod_pow(x:usize, n:usize) ->usize{\n    if(n == 0){ return 1;}\n    let mut res = mod_pow((x * x) % MODu, n / 2 );\n    if(n & 1 == 1){ res = (res * x) % MODu;}\n    return res;\n}\n\nfn comb2(n:usize, r:usize)->usize {\n    let mut n = n;\n    let mut r = r;\n    if(r > n-r) {r = n-r;}\n    if(r == 0) {return 1;}\n    let mut a = 1;\n    for i in 0..r{\n        a = a * ((n-i) % MODu) % MODu;\n    }\n    let mut b = mod_pow(fact_mod(r), MODu-2);\n    return (a % MODu) * (b % MODu) % MODu;\n}\n\n\n\n\nstruct scc{\n    G:Vec<Vec<usize>>,\n    rG:Vec<Vec<usize>>,\n    vs:Vec<usize>,\n    used:Vec<bool>,\n    cmp:Vec<usize>,\n}\nimpl scc{\n    pub fn new(N:usize, G:&Vec<Vec<usize>>, rG:&Vec<Vec<usize>>)->Self{\n        scc{G:G.clone(), rG:rG.clone(), vs:vec![], used:vec![false;N], cmp:vec![0;N]}\n    }\n    pub fn add_edge(&mut self, from:usize, to:usize){\n        self.G[from].push(to);\n        self.rG[to].push(from);\n    }\n    pub fn dfs(&mut self, v:usize){\n        self.used[v] = true;\n        for i in 0..self.G[v].len(){\n            let t = self.G[v][i];\n            if !self.used[t]{\n                self.dfs(t);\n            }\n        }\n        self.vs.push(v);\n    }\n    pub fn rdfs(&mut self, v:usize, k:usize){\n        self.used[v] = true;\n        self.cmp[v] = k;\n        for i in 0..self.rG[v].len(){\n            let t = self.rG[v][i];\n            if !self.used[t]{\n                self.rdfs(t, k);\n            }\n        }\n    }\n    pub fn scc(&mut self)->usize{\n        for v in 0..self.G.len(){\n            if !self.used[v]{\n                self.dfs(v);\n            }\n        }\n        self.used = vec![false;self.used.len()];\n        let mut k = 0;\n        for i in (0..self.vs.len()).rev(){\n            if !self.used[self.vs[i]]{\n                let t = self.vs[i];\n                self.rdfs(t, k);\n                k+=1;\n            }\n        }\n        k\n    }\n}\n\n\n#[macro_use]\nfn modinv3(a:i32)->i32{\n    let mut a = a as i32;\n    let mut b = MODu as i32;\n    let mut u = 1 as i32;\n    let mut v = 0 as i32;\n    let mut a = a as i32;\n    let mut m = MODu as i32;\n    while(b>0){\n        let mut t = a/b;\n        a -= t*b;\n        mem::swap(&mut a, &mut b);\n        u-=t*v;\n        mem::swap(&mut u, &mut v);\n    }\n    u%=m;\n    if u<0{u+=m;}\n    return u as i32;\n\n}\nfn solve(){\n    let sssss = std::io::stdin();\n    let mut sc = Scanner { stdin: sssss.lock() };\n    let mut N:usize = sc.read();\n    let mut M:usize = sc.read();\n    /*\n    let mut dp = vec![vec![vec![vec![0;2];N+1];N+1];M+1];\n    dp[0][1][0][0] = 1;\n    */\n    let mut now = HashMap::new();\n    now.insert(vec![1, 0, 0usize], 1usize);\n    let mut nnn = 0;\n    for _ in 1..M+1{\n        let mut nxt = HashMap::new();\n        for (xx, y) in &now{\n            let mut x = xx.clone();\n            let mut j = x[0];\n            let mut k = x[1];\n            let mut l = x[2];\n\n            let mut p = *y;\n            if l == 1{\n                if N>=j+k{\n                let mut nkey = vec![j, k+1, 1];\n                *nxt.entry(nkey.clone()).or_insert(0)+= (p*(N-(j+k)))%MODu;\n                *nxt.entry(nkey.clone()).or_insert(0)%= MODu;\n                }\n                let mut nkey = vec![j+k, 0, 0];\n                *nxt.entry(nkey.clone()).or_insert(0)+= (p*j)%MODu;\n                *nxt.entry(nkey.clone()).or_insert(0)%= MODu;\n\n                let mut nkey = vec![j, k, 1];\n                *nxt.entry(nkey.clone()).or_insert(0)+= (p*k)%MODu;\n                *nxt.entry(nkey.clone()).or_insert(0)%= MODu;\n            }\n            else{\n                if N>=j+k{\n                let mut nkey = vec![j, k+1, 1];\n                *nxt.entry(nkey.clone()).or_insert(0)+= (p*(N-(j+k)))%MODu;\n                *nxt.entry(nkey.clone()).or_insert(0)%= MODu;\n                }\n                let mut nkey = vec![j, k, 0];\n                *nxt.entry(nkey.clone()).or_insert(0)+= (p*j)%MODu;\n                *nxt.entry(nkey.clone()).or_insert(0)%= MODu;\n            }\n        }\n        nnn+=1;\n        mem::swap(&mut nxt, &mut now);\n    }\n    if now.contains_key(&(vec![N, 0, 0])){\n        println!(\"{}\", now[&(vec![N, 0, 0])]);\n    }\n    else{\n        println!(\"0\");\n    }\n    /*\n    for i in 1..M+1{\n        for j in 0..N+1{\n            for k in 0..N+1{\n                //new\n                if N>=j+k{\n                    if k+1<=N{\n                        dp[i][j][k+1][1] += dp[i-1][j][k][1]*(N-(j+k));\n                        dp[i][j][k+1][1] %= MODu;\n\n                        dp[i][j][k+1][1] += dp[i-1][j][k][0]*(N-(j+k));\n                        dp[i][j][k+1][1] %= MODu;\n                    }\n                }\n                //from 1\n                if j+k<=N{\n                    dp[i][j+k][0][0] += dp[i-1][j][k][1]*j;\n                    dp[i][j+k][0][0] %= MODu;\n                }\n                dp[i][j][k][1] += dp[i-1][j][k][1]*k;\n                dp[i][j][k][1] %= MODu;\n                //from 0\n                dp[i][j][k][0] += dp[i-1][j][k][0]*j;\n                dp[i][j][k][0] %= MODu;\n            }\n        }\n        /*\n        for j in 0..N+1{\n            for k in 0..N+1{\n                for l in 0..2{\n                    if dp[i][j][k][l] != 0{\n                        println!(\"{} {} {} {}\", i, j, k, dp[i][j][k][l]);\n                    }\n                }\n            }\n        }\n        */\n    }\n    println!(\"{}\", dp[M][N][0][0]);\n\n    */\n\n}\n\n\nfn main(){\n    solve();\n}\nconst PI:f64 = std::f64::consts::PI;\npub static MOD:i64 = 1000000007;\npub static MODu:usize = 1000000007;\npub static MODi32:i32 = 1000000007;\npub static eps:f64 = 1e-6;\nconst INF: i64 = 1 << 62;\nconst INFu:usize = 1<<62;\n\n\n\n"
  },
  {
    "language": "Rust",
    "code": "#[allow(unused_macros)]\nmacro_rules! input {\n    (source = $s:expr, $($r:tt)*) => {\n        let mut iter = $s.split_whitespace();\n        let mut next = || { iter.next().unwrap() };\n        input_inner!{next, $($r)*}\n    };\n    ($($r:tt)*) => {\n        let stdin = std::io::stdin();\n        let mut bytes = std::io::Read::bytes(std::io::BufReader::new(stdin.lock()));\n        let mut next = move || -> String{\n            bytes\n                .by_ref()\n                .map(|r|r.unwrap() as char)\n                .skip_while(|c|c.is_whitespace())\n                .take_while(|c|!c.is_whitespace())\n                .collect()\n        };\n        input_inner!{next, $($r)*}\n    };\n}\n \n#[allow(unused_macros)]\nmacro_rules! input_inner {\n    ($next:expr) => {};\n    ($next:expr, ) => {};\n \n    ($next:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let mut $var = read_value!($next, $t);\n        input_inner!{$next $($r)*}\n    };\n}\n \n#[allow(unused_macros)]\nmacro_rules! read_value {\n    ($next:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($next, $t)),* )\n    };\n \n    ($next:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($next, $t)).collect::<Vec<_>>()\n    };\n \n    ($next:expr, chars) => {\n        read_value!($next, String).chars().collect::<Vec<char>>()\n    };\n \n    ($next:expr, bytes) => {\n        read_value!($next, String).into_bytes()\n    };\n \n    ($next:expr, usize1) => {\n        read_value!($next, usize) - 1\n    };\n \n    ($next:expr, $t:ty) => {\n        $next().parse::<$t>().expect(\"Parse error\")\n    };\n}\n \nuse std::cmp::Ordering;\nuse std::cmp;\nuse std::cmp::min;\nuse std::collections::BTreeMap;\nuse std::process;\nuse std::cmp::Ord;\nuse std::collections::HashMap;\nuse std::collections::HashSet;\nuse std::collections::VecDeque;\nuse std::collections::BTreeSet;\nuse std::mem;\nuse std::collections::BinaryHeap;\nuse std::hash::{Hash, Hasher};\n\n// ---------- begin ModInt ----------\n\n#[derive(Clone, Copy)]\nstruct ModInt(usize);\nimpl std::ops::Add for ModInt {\n    type Output = ModInt;\n    fn add(self, rhs: ModInt) -> Self::Output {\n        let mut d = self.0 + rhs.0;\n        if d >= MODu {\n            d -= MODu;\n        }\n        ModInt(d)\n    }\n}\n\nimpl std::ops::AddAssign for ModInt {\n    fn add_assign(&mut self, rhs: ModInt) {\n        *self = *self + rhs;\n    }\n}\n\nimpl std::ops::Sub for ModInt {\n    type Output = ModInt;\n    fn sub(self, rhs: ModInt) -> Self::Output {\n        let mut d = self.0 + MODu - rhs.0;\n        if d >= MODu {\n            d -= MODu;\n        }\n        ModInt(d)\n    }\n}\n\nimpl std::ops::SubAssign for ModInt {\n    fn sub_assign(&mut self, rhs: ModInt) {\n        *self = *self - rhs;\n    }\n}\n\nimpl std::ops::Mul for ModInt {\n    type Output = ModInt;\n    fn mul(self, rhs: ModInt) -> Self::Output {\n        ModInt((self.0 as u64 * rhs.0 as u64 % MODu as u64) as usize)\n    }\n}\n\nimpl std::ops::MulAssign for ModInt {\n    fn mul_assign(&mut self, rhs: ModInt) {\n        *self = *self * rhs;\n    }\n}\n\nimpl std::ops::Neg for ModInt {\n    type Output = ModInt;\n    fn neg(self) -> Self::Output {\n        ModInt(if self.0 == 0 {0} else {MODu - self.0})\n    }\n}\n\nimpl std::fmt::Display for ModInt {\n    fn fmt<'a>(&self, f: &mut std::fmt::Formatter<'a>) -> std::fmt::Result {\n        write!(f, \"{}\", self.0)\n    }\n}\n\nimpl std::str::FromStr for ModInt {\n    type Err = std::num::ParseIntError;\n    fn from_str(s: &str) -> Result<Self, Self::Err> {\n        let val = s.parse::<usize>()?;\n        Ok(ModInt::new(val))\n    }\n}\nimpl PartialEq for ModInt {\n    fn eq(&self, other: &Self) -> bool {\n        self.0 == other.0\n    }\n}\nimpl Hash for ModInt {\n    fn hash<H: Hasher>(&self, state: &mut H) {\n        self.0.hash(state);\n        self.0.hash(state);\n    }\n}\nimpl Eq for ModInt {}\n#[allow(dead_code)]\nimpl ModInt {\n    pub fn new(n: usize) -> ModInt {\n        ModInt(n % MODu)\n    }\n    pub fn zero() -> ModInt {\n        ModInt(0)\n    }\n    pub fn one() -> ModInt {\n        ModInt(1)\n    }\n    pub fn pow(self, mut n: usize) -> ModInt {\n        let mut t = ModInt::one();\n        let mut s = self;\n        while n > 0 {\n            if n & 1 == 1 {\n                t *= s;\n            }\n            s *= s;\n            n >>= 1;\n        }\n        t\n    }\n    pub fn inv(self) -> ModInt {\n        self.pow(MODu - 2)\n    }\n}\n// ---------- end ModInt ----------\n\n/// Equivalent to std::lowerbound and std::upperbound in c++\npub trait BinarySearch<T> {\n    fn lower_bound(&self, x:&T) -> usize;\n    fn upper_bound(&self, x:&T) -> usize;\n}\n \nimpl<T: Ord> BinarySearch<T> for VecDeque<T>{\n    fn lower_bound(&self, x: &T) -> usize {\n        let mut low = 0;\n        let mut high = self.len();\n \n        while low != high {\n            let mid = (low + high) / 2;\n            match self[mid].cmp(x) {\n                Ordering::Less => {\n                    low = mid + 1;\n                }\n                Ordering::Equal | Ordering::Greater => {\n                    high = mid;\n                }\n            }\n        }\n        low\n    }\n \n    fn upper_bound(&self, x: &T) -> usize {\n        let mut low = 0;\n        let mut high = self.len();\n \n        while low != high {\n            let mid = (low + high) / 2;\n            match self[mid].cmp(x) {\n                Ordering::Less | Ordering::Equal => {\n                    low = mid + 1;\n                }\n                Ordering::Greater => {\n                    high = mid;\n                }\n            }\n        }\n        low\n    }\n}\nimpl<T: Ord> BinarySearch<T> for [T]{\n    fn lower_bound(&self, x: &T) -> usize {\n        let mut low = 0;\n        let mut high = self.len();\n \n        while low != high {\n            let mid = (low + high) / 2;\n            match self[mid].cmp(x) {\n                Ordering::Less => {\n                    low = mid + 1;\n                }\n                Ordering::Equal | Ordering::Greater => {\n                    high = mid;\n                }\n            }\n        }\n        low\n    }\n \n    fn upper_bound(&self, x: &T) -> usize {\n        let mut low = 0;\n        let mut high = self.len();\n \n        while low != high {\n            let mid = (low + high) / 2;\n            match self[mid].cmp(x) {\n                Ordering::Less | Ordering::Equal => {\n                    low = mid + 1;\n                }\n                Ordering::Greater => {\n                    high = mid;\n                }\n            }\n        }\n        low\n    }\n}\n\nfn matmul(A:&Vec<Vec<i64>>, B:&Vec<Vec<i64>>) -> Vec<Vec<i64>>{\n    let mut C = vec![vec![0;B[0].len()];A.len()];\n    for i in 0..A.len(){\n        for k in 0..B.len(){\n            for j in 0..B[0].len(){\n                C[i][j] += A[i][k]*B[k][j];\n                C[i][j] %= MOD;\n            }\n        }\n    }\n    return C;\n}\nfn matpow(A:&mut Vec<Vec<i64>>, n:usize) -> Vec<Vec<i64>>{\n    let mut B = vec![vec![0;A.len()];A.len()];\n    for i in 0..A.len(){\n        B[i][i] = 1;\n    }\n    let mut n = n;\n    let mut tmp = A.clone();\n    while(n>0){\n        if n&1 == 1{B = matmul(&B, &tmp);}\n        tmp = matmul(&tmp, &tmp);\n        n>>=1;\n    }\n    return B;\n}\n\n \n \n \n\nfn divisor(n:usize) -> Vec<usize>{\n    let mut res:Vec<usize> = Vec::new(); \n    for i in 1..n+1{\n        if i*i>n{break;}\n        if n%i == 0{\n            res.push(i);\n            if i != n/i{\n                res.push(n/i);    \n            }    \n        }    \n    }\n    res\n}\nstruct UnionFind{\n    par:Vec<usize>,\n    rank:Vec<usize>,\n    size:Vec<usize>,\n    size_edge:Vec<usize>,\n}\nimpl UnionFind{\n    fn init(n:usize) -> UnionFind{\n        let mut par = vec![0;n];\n        for i in 0..n{\n            par[i] = i;\n        }\n        UnionFind{\n            par:par,\n            rank:vec![0;n],\n            size:vec![1;n],\n            size_edge:vec![0;n],\n        }\n    }\n    fn find(&mut self, x:usize) ->usize{\n        if(self.par[x] == x){\n            x\n        }\n        else{\n            let p = self.par[x];\n            let res = self.find(p);\n            self.par[x] = res;\n            res\n        }\n    }\n    fn same(&mut self, a:usize, b:usize)->bool{\n        self.find(a) == self.find(b)\n    }\n    fn unite(&mut self, a:usize, b:usize){\n        let x = self.find(a);\n        let y = self.find(b);\n        if x != y{\n            if (self.rank[x] < self.rank[y]){\n                self.par[x] = y;\n                self.size[y] += self.size[x];\n                self.size_edge[y] += self.size_edge[x];\n                self.size_edge[y] += 1;\n            }\n            else{\n                self.par[y] = x;\n                self.size[x] += self.size[y];\n                self.size_edge[x] += self.size_edge[y];\n                self.size_edge[x] += 1;\n                if(self.rank[x] == self.rank[y]){ self.rank[x]+=1;}\n            }\n            \n        }\n        else{\n            self.size_edge[x] += 1;\n        }\n    }\n    fn check_size(&mut self, a:usize) -> usize{\n        let x = self.find(a);\n        let s = self.size[x];\n        s\n    }\n}\npub struct Scanner<R> {\n    stdin: R,\n}\n \nimpl<R: std::io::Read> Scanner<R> {\n    pub fn read<T: std::str::FromStr>(&mut self) -> T {\n        use std::io::Read;\n        let buf = self\n            .stdin\n            .by_ref()\n            .bytes()\n            .map(|b| b.unwrap())\n            .skip_while(|&b| b == b' ' || b == b'\\n' || b == b'\\r')\n            .take_while(|&b| b != b' ' && b != b'\\n' && b != b'\\r')\n            .collect::<Vec<_>>();\n        std::str::from_utf8(&buf).unwrap()\n            .parse()\n            .ok()\n            .expect(\"Parse error.\")\n    }\n    pub fn vec<T: std::str::FromStr>(&mut self, n: usize) -> Vec<T> {\n        (0..n).map(|_| self.read()).collect()\n    }\n    pub fn chars(&mut self) -> Vec<char> {\n        self.read::<String>().chars().collect()\n    }\n}\nstruct LazySegTree<BiOp> {\n    n: usize,\n    val: Vec<i64>,\n    ma:Vec<i64>,\n    op: BiOp,\n    e: i64,\n    upe:i64,\n    inf:i64,\n}\n\nimpl<BiOp> LazySegTree<BiOp>\n    where BiOp: Fn(i64, i64) -> i64{\n    pub fn new(n_: usize, op: BiOp, e: i64, upe:i64, inf:i64) -> Self {\n        let mut n = 1;\n        while n < n_ { n *= 2; } // n is a power of 2\n\n        LazySegTree {n: n, val: vec![e; 2 * n ], ma:vec![upe;2*n], op: op, e: e, upe:upe, inf:inf}\n    }\n    pub fn query(&self, x:usize, y:usize, l:usize, r:usize, k:usize) -> i64 {\n        if (r<=x || y<=l) {return self.inf;}\n        if (x<=l && r<=y) {return self.ma[k];}\n        let mut L = self.query(x,y,l,(l+r)/2, k*2);\n        let mut R = self.query(x,y,(l+r)/2,r, k*2+1);\n        return self.val[k] + (self.op)(L, R);\n\n    }\n    \n    pub fn update(&mut self, x:usize, y:usize, v:i64, l:usize,r:usize, k:usize) {\n        if (l>=r) {return;}\n        if (x<=l && r<=y){\n            self.val[k]+=v;\n            self.ma[k]+=v;\n        }\n        else if(l<y && x<r){\n            self.update(x, y, v, l, (l+r)/2, k*2);\n            self.update(x,y,v,(l+r)/2,r, k*2+1);\n            self.ma[k] = self.val[k] + (self.op)(self.ma[k*2], self.ma[k*2+1]);\n        }\n    }\n}\nfn modinv(a:ModInt)->ModInt{\n    let mut a = a.0 as usize;\n    let mut b = MODu as i64;\n    let mut u = 1 as i64;\n    let mut v = 0 as i64;\n    let mut a = a as i64;\n    let mut m = MODu as i64;\n    while(b>0){\n        let mut t = a/b;\n        a -= t*b;\n        mem::swap(&mut a, &mut b);\n        u-=t*v;\n        mem::swap(&mut u, &mut v);    \n    }\n    u%=m;\n    if u<0{u+=m;}\n    return ModInt(u as usize);\n\n}\nfn modinv2(a:usize)->usize{\n    let mut a = a as usize;\n    let mut b = MODu as i64;\n    let mut u = 1 as i64;\n    let mut v = 0 as i64;\n    let mut a = a as i64;\n    let mut m = MODu as i64;\n    while(b>0){\n        let mut t = a/b;\n        a -= t*b;\n        mem::swap(&mut a, &mut b);\n        u-=t*v;\n        mem::swap(&mut u, &mut v);\n    }\n    u%=m;\n    if u<0{u+=m;}\n    return u as usize;\n\n}\nfn modpow(x:ModInt, n:ModInt) -> ModInt{\n        let mut ans = ModInt(1);\n        let mut n = n.0 as usize;\n        let mut x = x;\n        while(n != 0){\n            if (n&1 == 1){ans = ans*x;}\n            x = x*x;\n            n = n>>1;\n        }\n        ans\n}\nfn comb(a:usize, b:usize,  fac:&Vec<ModInt>, ifac:&Vec<ModInt>)->ModInt{\n        let mut a = a;\n        let mut b = b;\n        if a == 0 && b == 0{return ModInt(1);}\n        if a<b || a<0{return ModInt(0);}\n        let mut tmp = ifac[a-b]*ifac[b];\n        return tmp * fac[a];\n}\n\nfn invs()->(Vec<ModInt>, Vec<ModInt>){\n    let mut fac = vec![ModInt(0);300001];\n    let mut ifac = vec![ModInt(0);300001];\n    fac[0] = ModInt(1);\n    ifac[0] = ModInt(1);\n    for i in 0..300000{\n\n        fac[i+1] = fac[i] * ModInt(i+1);\n        ifac[i+1] = ifac[i] * modpow(ModInt(i+1), ModInt(MODu - 2));\n    }\n    (fac, ifac)\n}\n\nstruct ConvexHallTrick {\n    Q: Vec<(i64, i64)>,\n}\n\nimpl ConvexHallTrick{\n    pub fn new() -> Self {\n\n        ConvexHallTrick {Q: Vec::new()}\n    }\n    pub fn calc(&self, p:(i64, i64), x:i64)->i64{\n        return p.0 * x + p.1;\n    }\n    pub fn dodo(& self, A:(i64, i64), B:(i64, i64), C:(i64, i64)) -> bool{\n        //max or min\n        (A.1 - C.1) * (B.0 - A.0) <= (A.1 - B.1)*(C.0 - A.0)\n    }\n    pub fn add(&mut self, a:i64, b:i64){\n        self.Q.push((a, b));\n        let mut v = self.Q.len();\n        while(v >=3 && self.dodo(self.Q[v-3], self.Q[v-2], self.Q[v-1])){\n            self.Q[v-2] = self.Q[v-1];\n            self.Q.pop();\n            v = self.Q.len();\n        }\n    }\n    pub fn query(& self, x:i64) -> i64{\n        let mut L = -1;\n        let mut R = (self.Q.len() - 1) as i64;\n        while(R-L>1){\n            let mut m = (L+R)/2;\n            if self.calc(self.Q[m as usize], x)>=self.calc(self.Q[m as usize+1], x){\n                L=m;\n            }\n            else{\n                R=m;\n            }\n\n        }\n        return self.calc(self.Q[R as usize], x);\n    }\n}\n#[derive(Eq, PartialEq, Clone, Debug)]\npub struct Rev<T>(pub T);\nimpl<T: PartialOrd> PartialOrd for Rev<T> {\n    fn partial_cmp(&self, other: &Rev<T>) -> Option<Ordering> {\n        other.0.partial_cmp(&self.0)\n    }\n}\nimpl<T: Ord> Ord for Rev<T> {\n    fn cmp(&self, other: &Rev<T>) -> Ordering {\n        other.0.cmp(&self.0)\n    }\n}\nfn sieve(n:usize) -> (Vec<bool>, Vec<usize>){\n    let mut p:usize = 0;\n    let mut is_prime = vec![false; n+1];\n    let mut prime = Vec::new();\n    for i in 0..n+1{\n        is_prime[i] = true;\n    }\n    is_prime[0] = false;\n    is_prime[1] = false;\n    for i in 2..n+1{\n        if is_prime[i]{\n            prime.push(i as usize);\n            let mut j = 2*i;\n            while(j<=n){\n                is_prime[j] = false;\n                j+=i;\n            }\n        }\n    }\n    (is_prime, prime)\n    \n}\nfn nHr(n:usize, r:usize, fac:&Vec<ModInt>, ifac:&Vec<ModInt>) -> ModInt{\n    comb(n + r - 1, r, fac, ifac)\n}\nfn gcd(a:usize, b:usize)->usize{\n    if b==0{return a;}\n    return gcd(b, a%b);\n}\nfn lcm(a:usize, b:usize)->usize{\n    return (b/gcd(a, b))*a;\n}\nstruct SegTree_MOD<BiOp> {\n    n: usize,\n    dat: Vec<i64>,\n    op: BiOp,\n    e: i64,\n    mod_:i64,\n}\nimpl<BiOp> SegTree_MOD<BiOp>\n    where BiOp: Fn(i64, i64) -> i64 \n          {\n    pub fn new(n_: usize, op: BiOp, e: i64, mod_:i64) -> Self {\n        let mut n = 1;\n        while n < n_ { n *= 2; } // n is a power of 2\n        SegTree_MOD {n: n, dat: vec![e; 2 * n - 1], op: op, e: e, mod_:mod_}\n    }\n    /* ary[k] <- v */\n    pub fn update(&mut self, idx: usize, v: i64) {\n        let mut k = idx + self.n - 1;\n        self.dat[k] = v;\n        while k > 0 {\n            k = (k - 1) / 2;\n            self.dat[k] = (self.op)(self.dat[2 * k + 1], self.dat[2 * k + 2]);\n            self.dat[k] %= self.mod_;\n        }\n    }\n    /* [a, b) (note: half-inclusive)\n     * http://proc-cpuinfo.fixstars.com/2017/07/optimize-segment-tree/ */\n    pub fn query(&self, mut a: usize, mut b: usize) -> i64 {\n        let mut left = self.e;\n        let mut right = self.e;\n        a += self.n - 1;\n        b += self.n - 1;\n        while a < b {\n            if (a & 1) == 0 {\n                left = (self.op)(left, self.dat[a]);\n                left %= self.mod_;\n            }\n            if (b & 1) == 0 {\n                right = (self.op)(self.dat[b - 1], right);\n                right %= self.mod_;\n            }\n            a = a / 2;\n            b = (b - 1) / 2;\n        }\n        let mut res = (self.op)(left, right);\n        res %= self.mod_;\n        res\n        \n    }\n}\nfn modpow2(x:usize, n:usize) -> usize{\n        let mut ans = 1;\n        let mut n = n;\n        let mut x = x;\n        while(n != 0){\n            if (n&1 == 1){ans = ans*x%MODu;}\n            x = x*x%MODu;\n            n = n>>1;\n        }\n        ans\n}\n#[derive(Clone)]\nstruct PPUnionFind{\n    par:Vec<usize>,\n    rank:Vec<usize>,\n    time:Vec<usize>,\n    now:usize,\n    history:Vec<(usize, usize)>,\n}\nimpl PPUnionFind{\n    fn init(n:usize) -> PPUnionFind{\n        let mut par = vec![0;n];\n        for i in 0..n{\n            par[i] = i;\n        }\n        PPUnionFind{\n            par:par,\n            rank:vec![0;n],\n            time:vec![INF as usize;n],\n            now:0,\n            history:vec![],\n        }\n    }\n    fn find(&mut self, t:usize, x:usize) ->usize{\n        if self.time[x] > t{return x;}\n        else { let tt = self.par[x]; return self.find(t, tt);}\n    }\n    fn unite(&mut self, x:usize, y:usize) -> usize{\n        self.now+=1;\n        let mut x = x;\n        let mut y = y;\n        let nc = self.now;\n        x = self.find(nc, x);\n        y = self.find(nc, y);\n        if x == y{return self.now;}\n        if self.par[x] < self.par[y] {mem::swap(&mut x, &mut y);}\n        self.par[x] += self.par[y];\n        self.history.push((self.now, self.par[x]));\n        self.par[y] = x;\n        self.time[y] = self.now;\n        return self.now;\n    }\n}\n\nfn prim(cost:&Vec<Vec<(usize, i64)>>, vs:usize)->i64{\n    let mut used = vec![false; vs];\n    let mut bh = BinaryHeap::new();\n    for j in 0..cost[0].len(){\n            bh.push((cost[0][j].1 * -1, cost[0][j].0));\n    }\n    used[0] = true;\n    let mut res = 0;\n    while(bh.len()!=0){\n        let mut m = bh.pop().unwrap();\n        if used[m.1]{continue;}\n        used[m.1] = true;\n        for e in 0..cost[m.1].len(){\n            if used[cost[m.1][e].0] == false{\n                bh.push((cost[m.1][e].1 * -1, cost[m.1][e].0));\n            }\n        }\n        res += m.0*-1;\n    }\n    return res;\n}\nfn kruscal(cost:&mut Vec<(i64, usize, usize)>, vs:usize)->i64{\n    cost.sort();\n    let mut uf = UnionFind::init(vs);\n    let mut res = 0;\n\n    for i in 0..cost.len(){\n        let e = cost[i].clone();\n        if uf.find(e.1) != uf.find(e.2){\n            uf.unite(e.1, e.2);\n            res += e.0;\n        }\n    }\n    return res;\n}\nfn kruscal3(cost:&mut Vec<(f64, usize, usize, usize)>, vs:usize)->(UnionFind, Vec<usize>) {\n    cost.sort_by(|a, b| (&a.0).partial_cmp(&b.0).unwrap());\n    let mut uf = UnionFind::init(vs);\n    let mut res = 0.0;\n    let mut rv = Vec::new();\n    let mut c = 0.0;\n    let mut t = 0.0;\n    for i in 0..cost.len(){\n        let e = cost[i].clone();\n        if uf.find(e.1) != uf.find(e.2){\n            uf.unite(e.1, e.2);\n            rv.push(e.3);\n        }\n    }\n    return (uf,rv);\n}\nfn kruscal2(cost:&mut Vec<(f64, usize, usize)>, vs:usize)->f64{\n    cost.sort_by(|a, b| (&a.0).partial_cmp(&b.0).unwrap());\n    let mut uf = UnionFind::init(vs);\n    let mut res = 0.0;\n    for i in 0..cost.len(){\n        let e = cost[i].clone();\n        if uf.find(e.1) != uf.find(e.2){\n            uf.unite(e.1, e.2);\n            res+= e.0;\n        }\n    }\n    return res;\n}\n\nstruct segtree<I, Op>{\n    n: usize,\n    dat: Vec<I>,\n    op:Op,\n    e:I,\n}\nimpl<I, Op> segtree<I, Op>\n\n\n    where Op: Fn(I, I) -> I, I:Copy{\n        \n        pub fn new(n_:usize, op: Op, e:I)->Self{\n            let mut n = 1;\n            while(n<n_){n*=2;}\n            segtree{n: n, dat:vec![e; 2*n-1], op:op, e:e}\n        }\n        pub fn update(&mut self, k:usize, a:I){\n            let mut k = k;\n            k += self.n-1;\n            self.dat[k] = a;\n            while(k>0){\n                k = (k-1)/2;\n                self.dat[k] = (self.op)(self.dat[k*2 + 1], self.dat[k*2+2]);\n            }\n        }\n        pub fn query(&self, a:usize, b:usize, k:usize, l:usize, r:usize) -> I{\n            if r<=a || b<=l{return self.e;}\n            if a<=l && r<=b{return self.dat[k];}\n            else{\n                let mut vl = self.query(a, b, k*2+1, l, (l+r)/2);\n                let mut vr = self.query(a, b, k*2+2, (l+r)/2, r);\n                return (self.op)(vl, vr);\n            }\n        }\n    }\nstruct BIT<I, Op>{\n    n:usize,\n    bit:Vec<I>,\n    op:Op,\n    e:I,\n    ini:I,\n}\nimpl <I, Op>  BIT<I, Op>\n    /* 1-index*/  \n    where Op: Fn(I, I) -> I, I:Copy{\n        pub fn new(n_:usize, op:Op, e:I, ini:I)->Self{\n            BIT{n:n_, bit:vec![e;n_+1], op:op, e:e, ini:ini}\n        }\n        pub fn sum(&self, i:usize)->I{\n            let mut s = self.ini;\n            let mut i = i as i64;\n            while(i>0){\n                s = (self.op)(s, self.bit[i as usize]);\n                i -= i & -i;\n            }\n            return s;\n        }\n        pub fn add(&mut self, i:usize, x:I){\n            let mut i = i as i64;\n            while(i<=self.n as i64){\n                self.bit[i as usize] = (self.op)(self.bit[i as usize], x);\n                i += i & -i;\n            }\n        }\n    }\nstruct Dsegtree{\n    n: usize,\n    datA: Vec<i64>,\n    datB:Vec<i64>,\n    e:i64,\n}\nimpl Dsegtree{\n        pub fn new(n_:usize, e:i64)->Self{\n\n            Dsegtree{n:n_, datA:vec![e; 1<<22 - 1], datB:vec![e;1<<22 - 1], e:e}\n        }\n        pub fn update(&mut self,a:usize, b:usize, x:i64,  k:usize, l:usize, r:usize){\n            //println!(\"{} {} {} {} {} {}\", a, b, x, k , l, r);\n            if a<=l && r<=b{\n                self.datA[k] += x;\n            }\n            else if (l<b && a<r){\n                self.datB[k] += (cmp::min(b, r) as i64 - cmp::max(a, l) as i64) * x;\n                self.update(a, b, x, k*2+1, l, (l+r)/2);\n                self.update(a, b, x, k*2+2, (l+r)/2, r);\n            }\n        }\n        pub fn query(&self, a:usize, b:usize, k:usize, l:usize, r:usize) -> i64{\n            if (b<=l || r<=a){\n                return 0;\n            }\n            else if (a<=l && r<=b){\n                return self.datA[k] * ((r as i64-l as i64)) + self.datB[k];\n            }\n            else{\n                let mut res = (cmp::min(b, r) as i64 - cmp::max(a, l) as i64)* self.datA[k];\n                res += self.query(a, b, k*2+1, l, (l+r)/2);\n                res += self.query(a, b, k*2+2, (l+r)/2, r);\n                return res;\n            }\n        }\n    }\n/*\nunwrap_or_else\n*/\nfn prime_factor(n:usize)->HashMap<usize, usize>{\n    let mut res = HashMap::new();\n    let mut n = n;\n    for i in 2..n{\n        if i*i>n{break;}\n        while(n%i==0){\n            *res.entry(i).or_insert(0)+=1;\n            n/=i;\n        }\n    }\n    if n != 1{\n        res.insert(n, 1);\n    }\n    res\n}\nstruct rollinghash{\n    base:Vec<i64>,\n    Mod:Vec<i64>,\n    hash:Vec<Vec<i64>>,\n    power:Vec<Vec<i64>>,\n}\nimpl rollinghash{\n    pub fn new(s:&Vec<usize>)->Self{\n        let mut n = s.len();\n        let mut base = vec![1007, 2009];\n        let mut hash = vec![vec![0;n+1];2];\n        let mut power = vec![vec![1;n+1];2];\n        let mut Mod = vec![1000000007, 1000000009];\n        for iter in 0..2{\n            let mut ht = vec![0;n+1];\n            let mut pt = vec![1;n+1];\n            for i in 0..n{\n                hash[iter][i+1] = (hash[iter][i] * base[iter] + s[i] as i64) % Mod[iter];\n                power[iter][i+1] = power[iter][i] * base[iter] % Mod[iter];\n            }\n        }\n        return rollinghash{base:base, Mod:Mod, hash:hash, power:power}\n   \n    }\n    pub fn get(&self, l:usize, r:usize)->(i64, i64){\n        let mut res = self.hash[0][r] - self.hash[0][l] * self.power[0][r-l] % self.Mod[0];\n        if res<0{\n            res += self.Mod[0];\n        }\n        let mut res2 = self.hash[1][r] - self.hash[1][l] * self.power[1][r-l] % self.Mod[1];\n        if res2<0{\n            res2 += self.Mod[1];\n        }\n        return (res, res2);\n    }\n\n}\nstruct LCA{\n    G:Vec<Vec<i64>>,\n    parent:Vec<Vec<i64>>,\n    depth:Vec<i64>,\n    root:i64,\n}\nimpl LCA{\n    pub fn new(G:Vec<Vec<i64>>, N:i64,R:i64)->Self{\n        let D = (f64::log2(N as f64)) as i64 + 2;\n        LCA{G:G, parent:vec![vec![0;N as usize];1+D as usize], depth:vec![0;N as usize], root:R}\n    }\n    pub fn getP(&mut self, v:i64, p:i64, d:i64){\n        self.parent[0][v as usize] = p;\n        self.depth[v as usize] = d;\n        for i in 0..self.G[v as usize].len(){\n            if self.G[v as usize][i as usize] != p{\n                let n = self.G[v as usize][i as usize];\n                self.getP(n, v, d+1);\n            }\n        }\n    }\n    pub fn init(&mut self){\n        let root = self.root;\n        self.getP(root, -1, 0);\n        let V = self.depth.len();\n        let logN = f64::log2(V as f64) as i64 + 2;\n        for k in 0..logN{\n            for v in 0..V{\n                if self.parent[k as usize][v as usize] <0{\n                    self.parent[k as usize+1][v as usize] = -1;\n                }\n                else{\n                    self.parent[k as usize+1][v as usize] = self.parent[k as usize][ (self.parent[k as usize][v as usize]) as usize];\n                }\n            }\n        }\n    }\n    fn ft(&self, f:i64, d:i64)->i64{\n        let mut now = f;\n        let mut now2 = 0;\n        let V = self.depth.len();\n\n        let logN = f64::log2(V as f64) as i64 + 2;\n        let mut v = f;\n        for k in 0..logN{\n            if (d >> k) & 1 == 1{\n                v = self.parent[k as usize][v as usize];\n            }\n        }\n\n        return v;\n    }\n\n    fn lca(&mut self,u:i64, v:i64)->i64{\n        let mut u = u;\n        let mut v = v;\n        if self.depth[u as usize] > self.depth[v as usize]{\n            mem::swap(&mut u, &mut v);\n        }\n        let mut V = self.depth.len();\n        let logN = f64::log2(V as f64) as i64 + 2;\n        for k in 0..logN{\n            if ((self.depth[v as usize] - self.depth[u as usize]) >> k)&1 == 1{\n                v = self.parent[k as usize][v as usize];\n            }\n        }\n        if u == v{return u;}\n        for k in (0..logN).rev(){\n            if self.parent[k as usize][u as usize] != self.parent[k as usize][v as usize]{\n                u = self.parent[k as usize][u as usize];\n                v = self.parent[k as usize][v as usize];\n            }\n        }\n        return self.parent[0][u as usize];\n    }\n\n    fn dist(&mut self,u:i64, v:i64)->i64{\n        let lc = self.lca(u, v);\n        return self.depth[u as usize] + self.depth[v as usize] - 2* self.depth[lc as usize];\n    }\n\n}\nfn fast_prime_factor_table(ma:usize)->Vec<usize>{\n    let mut p = sieve(1001);\n    let mut minf = vec![0;ma];\n    for j in 0..p.1.len(){\n        let P = p.1[j];\n        let mut now = P;\n        for i in 2..ma{\n            if minf[now] ==0{\n                minf[now] = P;\n            }\n            now+=P;\n            if now>=ma{\n                break;\n            }\n        }\n    }\n    return minf;\n}\nfn area_rectanble(x1:f64, x2:f64, x3:f64, y1:f64, y2:f64, y3:f64)->f64{\n    let tmp = x1*y2 + x2*y3 + x3*y1 - y1*x2 - y2*x3 - y3*x1;\n    tmp.abs()/2.0\n}\n#[derive(PartialEq, Clone)]\nstruct FW(f64);\n\nimpl Eq for FW {}\n\nimpl PartialOrd for FW {\n    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n        self.0.partial_cmp(&other.0)\n    }\n}\n\nimpl Ord for FW {\n    fn cmp(&self, other: &FW) -> Ordering {\n        other.partial_cmp(self).unwrap()\n\n    }\n}\n/* parsing\n    fn expr(s:&Vec<char>, i:&mut usize) -> Vec<usize>{\n        let mut val = term(s, i);\n        while(*i<s.len() && (s[*i] == '+' || s[*i] == '-')){\n            let mut op = encode(s[*i]);\n            *i+=1;\n            let mut val2 = term(s, i);\n            val = cal(val, val2, op);\n        }\n        return val;\n    }\n    fn term(s:&Vec<char>, i:&mut usize) -> Vec<usize>{\n        let mut val = factor(s, i);\n        while(*i<s.len() && s[*i] == '*'){\n            let mut op = encode(s[*i]);\n            *i+=1;\n            let mut val2 = factor(s, i);\n            val = cal(val, val2, op);\n        }\n        return val;\n    }\n    fn factor(s:&Vec<char>, i:&mut usize)->Vec<usize>{\n        if s[*i] == 'R' || s[*i] == 'S' || s[*i] == 'P' || s[*i] == '?'{\n            let mut res = encode(s[*i]);\n            *i+=1;\n            return res;\n        }\n        *i+=1;\n        let mut ret = expr(s, i);\n        *i+=1;\n        return ret;\n    }\n*/\nfn matmulf64(A:&Vec<Vec<f64>>, B:&Vec<Vec<f64>>) -> Vec<Vec<f64>>{\n    let mut C = vec![vec![0.0;B[0].len()];A.len()];\n    for i in 0..A.len(){\n        for k in 0..B.len(){\n            for j in 0..B[0].len(){\n                C[i][j] += A[i][k]*B[k][j];\n            }\n        }\n    }\n    return C;\n}\n//sort_by_key(|a| vec![a[0], -a[1]]);\n//v.sort_by(|a, b| a.partial_cmp(b).unwrap());\n\n\n\n\n\n\nfn fact_mod(n:usize)->usize {\n    let mut  f = 1; \n    for i in 2..n+1{\n        f = f * (i % MODu) % MODu;\n    }\n    return f;\n}\n\nfn mod_pow(x:usize, n:usize) ->usize{\n    if(n == 0){ return 1;}\n    let mut res = mod_pow((x * x) % MODu, n / 2 );\n    if(n & 1 == 1){ res = (res * x) % MODu;}\n    return res;\n}\n\nfn comb2(n:usize, r:usize)->usize {\n    let mut n = n;\n    let mut r = r;\n    if(r > n-r) {r = n-r;}\n    if(r == 0) {return 1;}\n    let mut a = 1;\n    for i in 0..r{\n        a = a * ((n-i) % MODu) % MODu;\n    }\n    let mut b = mod_pow(fact_mod(r), MODu-2);\n    return (a % MODu) * (b % MODu) % MODu;\n}\n\n\n\n\nstruct scc{\n    G:Vec<Vec<usize>>,\n    rG:Vec<Vec<usize>>,\n    vs:Vec<usize>,\n    used:Vec<bool>,\n    cmp:Vec<usize>,\n}\nimpl scc{\n    pub fn new(N:usize, G:&Vec<Vec<usize>>, rG:&Vec<Vec<usize>>)->Self{\n        scc{G:G.clone(), rG:rG.clone(), vs:vec![], used:vec![false;N], cmp:vec![0;N]}\n    }\n    pub fn add_edge(&mut self, from:usize, to:usize){\n        self.G[from].push(to);\n        self.rG[to].push(from);\n    }\n    pub fn dfs(&mut self, v:usize){\n        self.used[v] = true;\n        for i in 0..self.G[v].len(){\n            let t = self.G[v][i];\n            if !self.used[t]{\n                self.dfs(t);\n            }\n        }\n        self.vs.push(v);\n    }\n    pub fn rdfs(&mut self, v:usize, k:usize){\n        self.used[v] = true;\n        self.cmp[v] = k;\n        for i in 0..self.rG[v].len(){\n            let t = self.rG[v][i];\n            if !self.used[t]{\n                self.rdfs(t, k);\n            }\n        }\n    }\n    pub fn scc(&mut self)->usize{\n        for v in 0..self.G.len(){\n            if !self.used[v]{\n                self.dfs(v);\n            }\n        }\n        self.used = vec![false;self.used.len()];\n        let mut k = 0;\n        for i in (0..self.vs.len()).rev(){\n            if !self.used[self.vs[i]]{\n                let t = self.vs[i];\n                self.rdfs(t, k);\n                k+=1;\n            }\n        }\n        k\n    }\n}\n\n\n#[macro_use]\nfn modinv3(a:i32)->i32{\n    let mut a = a as i32;\n    let mut b = MODu as i32;\n    let mut u = 1 as i32;\n    let mut v = 0 as i32;\n    let mut a = a as i32;\n    let mut m = MODu as i32;\n    while(b>0){\n        let mut t = a/b;\n        a -= t*b;\n        mem::swap(&mut a, &mut b);\n        u-=t*v;\n        mem::swap(&mut u, &mut v);\n    }\n    u%=m;\n    if u<0{u+=m;}\n    return u as i32;\n\n}\nfn solve(){\n    let sssss = std::io::stdin();\n    let mut sc = Scanner { stdin: sssss.lock() };\n    let mut N:usize = sc.read();\n    let mut M:usize = sc.read();\n    let mut dp = vec![vec![vec![vec![0;2];N+1];N+1];M+1];\n    dp[0][1][0][0] = 1;\n\n    for i in 1..M+1{\n        for j in 0..N+1{\n            for k in 0..N+1{\n                //new\n                if N>=j+k{\n                    if k+1<=N{\n                        dp[i][j][k+1][1] += dp[i-1][j][k][1]*(N-(j+k));\n                        dp[i][j][k+1][1] %= MODu;\n\n                        dp[i][j][k+1][1] += dp[i-1][j][k][0]*(N-(j+k));\n                        dp[i][j][k+1][1] %= MODu;\n                    }\n                }\n                //from 1\n                if j+k<=N{\n                    dp[i][j+k][0][0] += dp[i-1][j][k][1]*j;\n                    dp[i][j+k][0][0] %= MODu;\n                }\n                dp[i][j][k][1] += dp[i-1][j][k][1]*k;\n                dp[i][j][k][1] %= MODu;\n                //from 0\n                dp[i][j][k][0] += dp[i-1][j][k][0]*j;\n                dp[i][j][k][0] %= MODu;\n            }\n        }\n        /*\n        for j in 0..N+1{\n            for k in 0..N+1{\n                for l in 0..2{\n                    if dp[i][j][k][l] != 0{\n                        println!(\"{} {} {} {}\", i, j, k, dp[i][j][k][l]);\n                    }\n                }\n            }\n        }\n        */\n    }\n    println!(\"{}\", dp[M][N][0][0]);\n\n                \n\n\n}\n\n\nfn main(){\n    solve();\n}\nconst PI:f64 = std::f64::consts::PI;\npub static MOD:i64 = 1000000007;\npub static MODu:usize = 1000000007;\npub static MODi32:i32 = 1000000007;\npub static eps:f64 = 1e-6;\nconst INF: i64 = 1 << 62;\nconst INFu:usize = 1<<62;\n\n\n\n"
  }
]