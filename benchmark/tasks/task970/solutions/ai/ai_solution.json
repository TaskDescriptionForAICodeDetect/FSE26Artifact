[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define MOD 998244353\n\nint find(int* parent, int x) {\n    if (parent[x] != x) \n        parent[x] = find(parent, parent[x]);\n    return parent[x];\n}\n\nvoid unite(int* parent, int* rank, int x, int y) {\n    int px = find(parent, x);\n    int py = find(parent, y);\n    \n    if (px == py) return;\n    \n    if (rank[px] < rank[py]) {\n        parent[px] = py;\n    } else {\n        parent[py] = px;\n        if (rank[px] == rank[py]) \n            rank[px]++;\n    }\n}\n\nint solve(int N, int M, int* route) {\n    long long ways = 1;\n    int* parent = malloc((N+1) * sizeof(int));\n    int* rank = malloc((N+1) * sizeof(int));\n    \n    for (int i = 1; i <= N; i++) {\n        parent[i] = i;\n        rank[i] = 0;\n    }\n    \n    int prev = 1;\n    for (int i = 0; i < M; i++) {\n        int curr = route[i];\n        \n        // Count possible roads\n        int possible_roads = 0;\n        for (int j = 1; j <= N; j++) {\n            if (find(parent, j) != find(parent, prev) && \n                find(parent, j) != find(parent, curr)) {\n                possible_roads++;\n            }\n        }\n        \n        // If no roads can be added, no solution\n        if (possible_roads == 0) {\n            free(parent);\n            free(rank);\n            return 0;\n        }\n        \n        ways = (ways * possible_roads) % MOD;\n        unite(parent, rank, prev, curr);\n        prev = curr;\n    }\n    \n    // Check if all towns are connected\n    int root = find(parent, 1);\n    for (int i = 2; i <= N; i++) {\n        if (find(parent, i) != root) {\n            free(parent);\n            free(rank);\n            return 0;\n        }\n    }\n    \n    free(parent);\n    free(rank);\n    return ways;\n}\n\nint main() {\n    int N, M;\n    scanf(\"%d %d\", &N, &M);\n    \n    int* route = malloc(M * sizeof(int));\n    for (int i = 0; i < M; i++) {\n        scanf(\"%d\", &route[i]);\n    }\n    \n    printf(\"%d\\n\", solve(N, M, route));\n    \n    free(route);\n    return 0;\n}",
    "timestamp": "2025-08-05 23:31:07"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define MOD 1000000007\n\nint main() {\n    int N, M;\n    scanf(\"%d %d\", &N, &M);\n    \n    int *c = (int *)malloc(M * sizeof(int));\n    for (int i = 0; i < M; i++) {\n        scanf(\"%d\", &c[i]);\n        c[i]--; // converting to 0-based index\n    }\n    \n    if (c[0] != 0 || c[M-1] != 0) {\n        printf(\"0\\n\");\n        free(c);\n        return 0;\n    }\n    \n    long long result = 1;\n    int *parent = (int *)malloc(N * sizeof(int));\n    for (int i = 0; i < N; i++) {\n        parent[i] = i;\n    }\n    \n    for (int i = 1; i < M; i++) {\n        int u = c[i-1];\n        int v = c[i];\n        \n        // Find root of u and v\n        while (parent[u] != u) {\n            parent[u] = parent[parent[u]];\n            u = parent[u];\n        }\n        while (parent[v] != v) {\n            parent[v] = parent[parent[v]];\n            v = parent[v];\n        }\n        \n        if (u != v) {\n            parent[v] = u;\n            result = (result * i) % MOD;\n        }\n    }\n    \n    printf(\"%lld\\n\", result);\n    free(c);\n    free(parent);\n    return 0;\n}",
    "timestamp": "2025-08-05 23:31:21"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\nint main() {\n    int N, M;\n    cin >> N >> M;\n    vector<int> c(M);\n    for (int i = 0; i < M; ++i) {\n        cin >> c[i];\n        c[i]--;\n    }\n\n    if (c[0] != 0 || c[M-1] != 0) {\n        cout << 0 << endl;\n        return 0;\n    }\n\n    vector<int> parent(N);\n    for (int i = 0; i < N; ++i) {\n        parent[i] = i;\n    }\n\n    auto find = [&](int x) {\n        while (parent[x] != x) {\n            parent[x] = parent[parent[x]];\n            x = parent[x];\n        }\n        return x;\n    };\n\n    auto unite = [&](int x, int y) {\n        x = find(x);\n        y = find(y);\n        if (x != y) {\n            parent[y] = x;\n        }\n    };\n\n    long long result = 1;\n    int components = N;\n\n    for (int i = 1; i < M; ++i) {\n        if (find(c[i-1]) != find(c[i])) {\n            result = result * components % MOD;\n            unite(c[i-1], c[i]);\n            components--;\n        }\n    }\n\n    cout << result << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-05 23:31:37"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n    static final int MOD = 1_000_000_007;\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st = new StringTokenizer(br.readLine());\n        int N = Integer.parseInt(st.nextToken());\n        int M = Integer.parseInt(st.nextToken());\n        int[] c = new int[M];\n        st = new StringTokenizer(br.readLine());\n        for (int i = 0; i < M; i++) {\n            c[i] = Integer.parseInt(st.nextToken());\n        }\n\n        if (c[0] != 1 || c[M - 1] != N) {\n            System.out.println(0);\n            return;\n        }\n\n        UnionFind uf = new UnionFind(N + 1);\n        long result = 1;\n        for (int i = 1; i < M; i++) {\n            int prev = c[i - 1];\n            int curr = c[i];\n            if (uf.find(prev) != uf.find(curr)) {\n                int count = 0;\n                for (int neighbor = 1; neighbor <= N; neighbor++) {\n                    if (uf.find(prev) == uf.find(neighbor) && uf.find(curr) != uf.find(neighbor)) {\n                        count++;\n                    }\n                }\n                result = (result * count) % MOD;\n                uf.union(prev, curr);\n            }\n        }\n\n        System.out.println(result);\n    }\n\n    static class UnionFind {\n        int[] parent;\n\n        public UnionFind(int size) {\n            parent = new int[size];\n            for (int i = 0; i < size; i++) {\n                parent[i] = i;\n            }\n        }\n\n        public int find(int x) {\n            if (parent[x] != x) {\n                parent[x] = find(parent[x]);\n            }\n            return parent[x];\n        }\n\n        public void union(int x, int y) {\n            int rootX = find(x);\n            int rootY = find(y);\n            if (rootX != rootY) {\n                parent[rootY] = rootX;\n            }\n        }\n    }\n}",
    "timestamp": "2025-08-05 23:31:56"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class TakahashiKingdomRoads {\n    static final int MOD = 998244353;\n    \n    public static int countRoadSequences(int N, int[] tour) {\n        DisjointSet ds = new DisjointSet(N);\n        \n        for (int i = 0; i < tour.length - 1; i++) {\n            ds.union(tour[i] - 1, tour[i + 1] - 1);\n        }\n        \n        int disconnectedGroups = ds.countDisjointSets();\n        return pow(N - 1, disconnectedGroups - 1);\n    }\n    \n    static int pow(int base, int exp) {\n        long result = 1;\n        long x = base;\n        \n        while (exp > 0) {\n            if (exp % 2 == 1) {\n                result = (result * x) % MOD;\n            }\n            x = (x * x) % MOD;\n            exp /= 2;\n        }\n        \n        return (int) result;\n    }\n    \n    static class DisjointSet {\n        int[] parent;\n        int[] rank;\n        \n        DisjointSet(int n) {\n            parent = new int[n];\n            rank = new int[n];\n            for (int i = 0; i < n; i++) {\n                parent[i] = i;\n            }\n        }\n        \n        int find(int x) {\n            if (parent[x] != x) {\n                parent[x] = find(parent[x]);\n            }\n            return parent[x];\n        }\n        \n        void union(int x, int y) {\n            int rootX = find(x);\n            int rootY = find(y);\n            \n            if (rootX == rootY) return;\n            \n            if (rank[rootX] < rank[rootY]) {\n                parent[rootX] = rootY;\n            } else if (rank[rootX] > rank[rootY]) {\n                parent[rootY] = rootX;\n            } else {\n                parent[rootY] = rootX;\n                rank[rootX]++;\n            }\n        }\n        \n        int countDisjointSets() {\n            Set<Integer> roots = new HashSet<>();\n            for (int i = 0; i < parent.length; i++) {\n                roots.add(find(i));\n            }\n            return roots.size();\n        }\n    }\n    \n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int N = scanner.nextInt();\n        int M = scanner.nextInt();\n        \n        int[] tour = new int[M];\n        for (int i = 0; i < M; i++) {\n            tour[i] = scanner.nextInt();\n        }\n        \n        System.out.println(countRoadSequences(N, tour));\n    }\n}",
    "timestamp": "2025-08-05 23:32:06"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nconst int MOD = 1e9 + 7;\n\nclass UnionFind {\npublic:\n    vector<int> parent, rank;\n    \n    UnionFind(int n) {\n        parent.resize(n + 1);\n        rank.resize(n + 1, 0);\n        for (int i = 1; i <= n; i++) {\n            parent[i] = i;\n        }\n    }\n    \n    int find(int x) {\n        if (parent[x] != x) {\n            parent[x] = find(parent[x]);\n        }\n        return parent[x];\n    }\n    \n    bool unite(int x, int y) {\n        int rootX = find(x);\n        int rootY = find(y);\n        \n        if (rootX == rootY) return false;\n        \n        if (rank[rootX] < rank[rootY]) {\n            parent[rootX] = rootY;\n        } else {\n            parent[rootY] = rootX;\n            if (rank[rootX] == rank[rootY]) {\n                rank[rootX]++;\n            }\n        }\n        return true;\n    }\n};\n\nint main() {\n    int N, M;\n    cin >> N >> M;\n    \n    vector<int> route(M);\n    for (int i = 0; i < M; i++) {\n        cin >> route[i];\n    }\n    \n    ll ways = 1;\n    UnionFind uf(N);\n    \n    for (int i = 1; i < M; i++) {\n        int prev = route[i-1];\n        int curr = route[i];\n        \n        int componentsBefore = uf.find(1);\n        bool united = uf.unite(prev, curr);\n        int componentsAfter = uf.find(1);\n        \n        if (united) {\n            ways = (ways * (N - i + 1)) % MOD;\n        }\n    }\n    \n    cout << ways << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 23:32:14"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def count_sequences(N, M):\n    if M < N - 1:\n        return 0\n\n    def factorial(num):\n        if num == 0 or num == 1:\n            return 1\n        else:\n            result = 1\n            for i in range(2, num + 1):\n                result *= i\n            return result\n\n    def binomial_coefficient(n, k):\n        if k > n:\n            return 0\n        return factorial(n) // (factorial(k) * factorial(n - k))\n\n    result = binomial_coefficient(M - 1, N - 2) * factorial(N - 2)\n    return result\n\n# Example usage\nN = 4\nM = 6\nprint(count_sequences(N, M))",
    "timestamp": "2025-08-13 15:42:29"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.Scanner;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class KingdomTour {\n\n    static int N, M;\n    static int[] towns;\n    static long result;\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        N = scanner.nextInt();\n        M = scanner.nextInt();\n        result = 0;\n        towns = new int[M];\n\n        if (M == 1) {\n            result = N - 1;\n        } else {\n            List<Integer> currentSequence = new ArrayList<>();\n            currentSequence.add(1);\n            dfs(currentSequence, 1);\n        }\n\n        System.out.println(result);\n        scanner.close();\n    }\n\n    private static void dfs(List<Integer> currentSequence, int lastTown) {\n        if (currentSequence.size() == M) {\n            if (isValidSequence(currentSequence)) {\n                result++;\n            }\n            return;\n        }\n\n        for (int nextTown = lastTown + 1; nextTown <= N; nextTown++) {\n            currentSequence.add(nextTown);\n            dfs(currentSequence, nextTown);\n            currentSequence.remove(currentSequence.size() - 1);\n        }\n    }\n\n    private static boolean isValidSequence(List<Integer> sequence) {\n        boolean[] visited = new boolean[N + 1];\n        for (int town : sequence) {\n            visited[town] = true;\n        }\n\n        for (int i = 1; i <= N; i++) {\n            if (!visited[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n}",
    "timestamp": "2025-08-13 15:42:33"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n\n#define MOD 1000000007\n\nint countSequences(int N, int M) {\n    if (M < N) return 0;\n\n    long long dp[N + 1][M + 1];\n    for (int i = 0; i <= N; i++) {\n        for (int j = 0; j <= M; j++) {\n            dp[i][j] = 0;\n        }\n    }\n\n    dp[1][1] = 1; // Starting at the capital on the first day.\n\n    for (int days = 2; days <= M; days++) {\n        for (int towns = 1; towns <= N; towns++) {\n            for (int prevTowns = 1; prevTowns <= N; prevTowns++) {\n                if (towns != prevTowns) {\n                    dp[towns][days] = (dp[towns][days] + dp[prevTowns][days - 1]) % MOD;\n                }\n            }\n        }\n    }\n\n    long long result = 0;\n    for (int town = 1; town <= N; town++) {\n        result = (result + dp[town][M]) % MOD;\n    }\n    \n    return result;\n}\n\nint main() {\n    int N, M;\n    scanf(\"%d %d\", &N, &M);\n    printf(\"%d\\n\", countSequences(N, M));\n    return 0;\n}",
    "timestamp": "2025-08-13 15:42:41"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nconst int MOD = 1000000007;\n\nint countSequences(int N, int M) {\n    vector<vector<long long>> dp(M+1, vector<long long>(N+1, 0));\n    dp[0][1] = 1; // Start at town 1 on day 0\n    \n    for (int i = 1; i <= M; ++i) {\n        for (int j = 1; j <= N; ++j) {\n            for (int k = 1; k <= N; ++k) {\n                if (j != k) {\n                    dp[i][j] = (dp[i][j] + dp[i-1][k]) % MOD;\n                }\n            }\n        }\n    }\n    \n    return dp[M][N]; // End at town c_M = N\n}\n\nint main() {\n    int N, M;\n    cin >> N >> M;\n    cout << countSequences(N, M) << endl;\n    return 0;\n}",
    "timestamp": "2025-08-13 15:42:43"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def solve(N, M, c):\n    MOD = 10**9 + 7\n    \n    def find(parent, x):\n        if parent[x] != x:\n            parent[x] = find(parent, parent[x])\n        return parent[x]\n    \n    def union(parent, x, y):\n        px, py = find(parent, x), find(parent, y)\n        if px != py:\n            parent[px] = py\n    \n    def count_valid_paths():\n        total = 0\n        for start_order in range(M):\n            parent = list(range(N+1))\n            roads_added = 0\n            \n            # First connect capital town 1\n            current = 1\n            \n            for i in range(start_order, M):\n                if find(parent, current) != find(parent, c[i]):\n                    union(parent, current, c[i])\n                    roads_added += 1\n                current = c[i]\n            \n            for i in range(start_order):\n                if find(parent, current) != find(parent, c[i]):\n                    union(parent, current, c[i])\n                    roads_added += 1\n                current = c[i]\n            \n            # Check if all towns are connected\n            root = find(parent, 1)\n            if all(find(parent, j) == root for j in range(1, N+1)) and roads_added == N-1:\n                total += 1\n        \n        return total % MOD\n    \n    return count_valid_paths()\n\n# Read input\nN, M = map(int, input().split())\nc = list(map(int, input().split()))\n\n# Print result\nprint(solve(N, M, c))",
    "timestamp": "2025-08-13 15:42:51"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\nMOD = 10**9 + 7\n\ndef solve():\n    N, M = map(int, sys.stdin.readline().split())\n    c = list(map(int, sys.stdin.readline().split()))\n    \n    if c[0] != 1 or c[-1] != N:\n        print(0)\n        return\n    \n    parent = [i for i in range(N + 1)]\n    rank = [1] * (N + 1)\n    \n    def find(u):\n        while parent[u] != u:\n            parent[u] = parent[parent[u]]\n            u = parent[u]\n        return u\n    \n    def union(u, v):\n        u_root = find(u)\n        v_root = find(v)\n        if u_root == v_root:\n            return False\n        if rank[u_root] > rank[v_root]:\n            parent[v_root] = u_root\n            rank[u_root] += rank[v_root]\n        else:\n            parent[u_root] = v_root\n            rank[v_root] += rank[u_root]\n        return True\n    \n    components = N\n    res = 1\n    for i in range(M - 1):\n        u = c[i]\n        v = c[i + 1]\n        if find(u) != find(v):\n            res = res * components % MOD\n            union(u, v)\n            components -= 1\n    print(res)\n\nsolve()",
    "timestamp": "2025-08-13 15:43:02"
  }
]