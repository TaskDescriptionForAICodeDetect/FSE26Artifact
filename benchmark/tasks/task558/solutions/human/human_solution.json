[
  {
    "language": "Scala",
    "code": "object Main extends App {\n  import scala.io.StdIn._\n  val n = readInt()\n  val points = Array.fill(n){\n    val Array(x, y) = readLine.trim.split(' ').map(_.toDouble)\n    Point(x, y)\n  }\n  var minTurn = Double.MaxValue\n  for (shops ← points.permutations) {\n    minTurn = math.min(minTurn, shops.foldLeft((Point(-1, 0), Point(0, 0), 0d)){\n      case ((prev, current, sum), next) ⇒ (current, next, math.acos((current - prev).angleFrom(next - current).cos) * 180 / math.Pi + sum)\n    } match {case (prev, current, sum) ⇒ math.acos((current - prev).angleFrom((Point(0, 0) - current)).cos) * 180 / math.Pi + sum})\n  }\n  println(f\"$minTurn%.10f\")\n}\ncase class Point(x: Double, y: Double) {\n  def -(that: Point): Vector = Vector(x - that.x, y - that.y)\n}\ncase class Vector(x: Double, y: Double) {\n  def length: Double = math.sqrt(x * x + y * y)\n  def dot(that: Vector): Double = x * that.x + y * that.y\n  def cross(that: Vector): Double = x * that.y - y * that.x\n  def angleFrom(that: Vector): Angle = length * that.length match {case len ⇒ Angle(cross(that) / len, dot(that) / len)}\n}\ncase class Angle(sin: Double, cos: Double)\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#pragma GCC diagnostic ignored \"-Wsign-compare\"\n#pragma GCC diagnostic ignored \"-Wsign-conversion\"\n\n#define NDEBUG\nusing i32 = int32_t;\nusing i64 = int64_t;\nusing u32 = uint32_t;\nusing u64 = uint64_t;\nusing uint = unsigned int;\nusing usize = std::size_t;\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\ntemplate<typename T> constexpr T popcount(const T u) { return u ? static_cast<T>(__builtin_popcountll(static_cast<u64>(u))) : static_cast<T>(0); }\ntemplate<typename T> constexpr T log2p1(const T u) { return u ? static_cast<T>(64 - __builtin_clzll(static_cast<u64>(u))) : static_cast<T>(0); }\ntemplate<typename T> constexpr T msbp1(const T u) { return log2p1(u); }\ntemplate<typename T> constexpr T lsbp1(const T u) { return __builtin_ffsll(u); }\ntemplate<typename T> constexpr T clog(const T u) { return u ? log2p1(u - 1) : static_cast<T>(u); }\ntemplate<typename T> constexpr bool ispow2(const T u) { return u and (static_cast<u64>(u) & static_cast<u64>(u - 1)) == 0; }\ntemplate<typename T> constexpr T ceil2(const T u) { return static_cast<T>(1) << clog(u); }\ntemplate<typename T> constexpr T floor2(const T u) { return u == 0 ? static_cast<T>(0) : static_cast<T>(1) << (log2p1(u) - 1); }\ntemplate<typename T> constexpr bool btest(const T mask, const usize ind) { return ((static_cast<u64>(mask) >> ind) & static_cast<u64>(1)); }\ntemplate<typename T> constexpr T bcut(const T mask, const usize ind) { return ind == 0 ? static_cast<T>(0) : static_cast<T>((static_cast<u64>(mask) << (64 - ind)) >> (64 - ind)); }\ntemplate<typename T> bool chmin(T& a, const T& b) { return (a > b ? a = b, true : false); }\ntemplate<typename T> bool chmax(T& a, const T& b) { return (a < b ? a = b, true : false); }\nconstexpr unsigned int mod                  = 1000000007;\ntemplate<typename T> constexpr T inf_v      = std::numeric_limits<T>::max() / 4;\ntemplate<typename Real> constexpr Real pi_v = Real{3.141592653589793238462643383279502884};\ntemplate<typename T>\nT read()\n{\n    T v;\n    return std::cin >> v, v;\n}\ntemplate<typename T>\nstd::vector<T> read_vec(const std::size_t size)\n{\n    std::vector<T> v(size);\n    for (auto& e : v) { std::cin >> e; }\n    return v;\n}\ntemplate<typename... Types>\nauto read_vals() { return std::tuple<std::decay_t<Types>...>{read<Types>()...}; }\n#define SHOW(...) static_cast<void>(0)\ntemplate<typename T>\nstd::vector<T> make_v(const std::size_t size, T v) { return std::vector<T>(size, v); }\ntemplate<class... Args>\nauto make_v(const std::size_t size, Args... args) { return std::vector<decltype(make_v(args...))>(size, make_v(args...)); }\nint main()\n{\n    const auto n = read<usize>();\n    std::vector<ld> x(n + 2, 0), y(n + 2, 0);\n    for (usize i = 1; i <= n; i++) { std::cin >> x[i] >> y[i]; }\n    auto ang = [&](const ld x, const ld y) { return std::atan2(y, x) / pi_v<ld> * 180 + (y < 0 ? 360 : 0); };\n    std::vector<usize> v(n + 2);\n    std::iota(v.begin(), v.end(), 0);\n    ld ans = 360 * n;\n    do {\n        ld pa = 0, sum = 0;\n        for (usize i = 0; i <= n; i++) {\n            const ld dx = x[v[i + 1]] - x[v[i]], dy = y[v[i + 1]] - y[v[i]];\n            const ld na = ang(dx, dy), da = std::abs(na - pa);\n            pa = na, sum += std::min(da, 360 - da);\n        }\n        chmin(ans, sum);\n    } while (std::next_permutation(v.begin() + 1, v.end() - 1));\n    std::cout << std::fixed << std::setprecision(15) << ans << std::endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long;\ntemplate<class T = int> using V = vector<T>;\ntemplate<class T = int> using VV = V< V<T> >;\n\nconstexpr double pi = acos(-1);\n\nint main() {\n  cin.tie(nullptr); ios::sync_with_stdio(false);\n  int n; cin >> n;\n  V<> x(n + 3), y(n + 3);\n  for (int i = 2; i < n + 2; ++i) cin >> x[i] >> y[i];\n  V<> idx(n + 3);\n  iota(begin(idx) + 2, end(idx) - 1, 2);\n  double res = 1e10;\n  do {\n    double curr = 0;\n    for (int p = 1; p <= n + 1; ++p) {\n      int i = idx[p - 1], j = idx[p], k = idx[p + 1];\n      double th = 4 * pi + atan2(y[j] - y[i], x[j] - x[i]) - atan2(y[k] - y[j], x[k] - x[j]);\n      th = fmod(th, 2 * pi);\n      th = min(th, 2 * pi - th) / pi * 180;\n      curr += th;\n    }\n    res = min(res, curr);\n  } while (next_permutation(begin(idx) + 2, end(idx) - 1));\n  cout << fixed << setprecision(15) << res << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing CP = complex<long double>;\n#define X real()\n#define Y imag()\nconst long double PI = acos(-1);\nconst long double EPS = 1e10;\n// conj(x) : complex conjugate,(0,1)->(0,-1)\n// abs(x) : dist between(0,0) and x\n// norm(x) : abs(x) * abs(x)\n// arg(x) : argment\nlong double dot(CP a, CP b) { return (a * conj(b)).X; }\nlong double cross(CP a, CP b) { return (a * conj(b)).Y; }\nlong double corner(CP a, CP b) {\n  //[0,pi]\n  return acos(dot(a, b) / (abs(a) * abs(b)));\n}\n\nint n;\nvector<CP> v;\n\nlong double solve();\nlong double calc(CP &nowv, CP &nowp, CP nextp);\n\nint main() {\n  cin >> n;\n  for(int i = 0; i < n; ++i) {\n    int x, y;\n    cin >> x >> y;\n    v.push_back(CP(x, y));\n  }\n  cout << fixed << setprecision(10);\n  cout << solve() << endl;\n  return 0;\n}\nlong double solve() {\n  vector<int> perm;\n  long double ans = 1e10;\n  for(int i = 0; i < n; ++i) perm.push_back(i);\n  do {\n    long double nowans = 0;\n    CP nowv(1, 0), nowp(0, 0);\n    for(int i = 0; i < n; ++i)\n      nowans += calc(nowv, nowp, v[perm[i]]);\n    nowans += calc(nowv, nowp, CP(0, 0));\n    ans = min(nowans, ans);\n  } while(next_permutation(perm.begin(), perm.end()));\n  return ans / (2 * PI) * 360.0;\n}\n\nlong double calc(CP &nowv, CP &nowp, CP nextp) {\n  long double ans = corner(nowv, nextp - nowp);\n  if(ans != 0) nowv = nextp - nowp;\n  nowp = nextp;\n  return ans;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ndouble PI2 = acos(-1) * 2;\ndouble normal(double a){\n    while(a >= PI2) a -= PI2;\n    while(a < 0) a += PI2;\n    return a;\n}\n\nint main() {\n    int N;\n    int X[9], Y[9];\n    cin >> N;\n    for(int i=0; i<N; i++) cin >> X[i] >> Y[i];\n    X[N] = Y[N] = 0;\n\n    double ans = 1e18;\n    vector<int> order(N+1);\n    for(int i=0; i<=N; i++) order[i] = i;\n\n    do{\n        double res = 0;\n        int x = 0, y = 0;\n        double ang = 0;\n        for(int i : order){\n            double a = atan2(Y[i]-y, X[i]-x);\n            res += min(normal(a-ang), normal(ang-a));\n            x = X[i];\n            y = Y[i];\n            ang = a;\n        }\n        ans = min(ans, res);\n    }while(next_permutation(order.begin(), order.end()-1));\n    ans *= 360 / PI2;\n    cout << fixed << setprecision(10) << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,n) for(ll i=0;i<(n);++i)\n#define reps(i,n) for(ll i=1;i<=(n);++i)\nusing ll = long long;\nusing str = string;\nconstexpr long long INF = (1LL<<60);\nconstexpr long long MOD = (1e9+7);\ntemplate<class T>inline T gcd(T a,T b){if(b==0)return a; return(gcd(b,a%b));}\ntemplate<class T>inline T lcm(T a,T b){return a/gcd(a,b)*b;}\ntemplate<class T>inline bool chmax(T &a,const T &b){if(a<b){a=b;return true;}return false;}\ntemplate<class T>inline bool chmin(T &a,const T &b){if(a>b){a=b;return true;}return false;}\ninline void dump(){cout<<endl;}\ntemplate<class Head,class... Tail>inline void dump(Head&& head, Tail&&... tail){cout<<head<<\", \";dump(forward<Tail>(tail)...);}\ntemplate<typename T>inline istream &operator>>(istream&input,vector<T>&v){for(auto &elemnt:v)input>>elemnt;return input;}\ntemplate<class T>vector<T> make_vec(size_t a){return vector<T>(a);}\ntemplate<class T, class... Ts>auto make_vec(size_t a, Ts... ts){return vector<decltype(make_vec<T>(ts...))>(a, make_vec<T>(ts...));}\nusing pdd = pair<double,double>;\nconstexpr double PI = acos(-1);\ndouble rad_to_deg(double r){\n  return r*180.0/PI;\n}\ndouble Atan2(pdd v){\n  return atan2(v.first,v.second);\n}\npdd dif(pdd a,pdd b){\n  return { b.first-a.first,b.second-a.second };\n}\n\nmain(){\n  cin.tie(0);\n  ios::sync_with_stdio(0);\n  cout<<fixed<<setprecision(10);\n  \n  ll n;\n  cin>>n;\n  vector<pdd> a(n);\n  rep(i,n)cin>>a[i].first>>a[i].second;\n\n  sort(a.begin(),a.end());\n  double ans=(double)INF;\n  do{\n    double tmp=0.0;\n    pdd pos(0,0);\n    pdd vec1(1,0);\n    a.emplace_back(0,0);\n    rep(i,n+1){\n      pdd vec2=dif(pos,a[i]);\n      auto s=rad_to_deg(Atan2(vec1));\n      auto t=rad_to_deg(Atan2(vec2));\n      auto d=abs(s-t);\n      d=min(d,360.0-d);\n      tmp+=d;\n      pos=a[i];\n      vec1=vec2;\n    }\n    a.pop_back();\n    ans=min(ans,tmp);\n  }while(next_permutation(a.begin(),a.end()));\n  cout<<(ans)<<endl;\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nconst int mod = 1e9 + 7;\nconst int inf = (1 << 30) - 1;\nconst ll infll = (1LL << 61) - 1;\n\nusing Real = long double;\nusing Point = complex<Real>;\nconst Real Pi = acos(-1), EPS = 1e-9;\ninline bool eq(Real a, Real b) { return fabs(a - b) < EPS; }\n\n//scalar\nPoint operator*(const Point &p, const Real &c)\n{\n    return Point(c * real(p), c * imag(p));\n}\n\n//add\nPoint operator+(const Point &p, const Point &q)\n{\n    return Point(real(p) + real(q), imag(p) + imag(q));\n}\n\nPoint operator-(const Point &p, const Point &q)\n{\n    return Point(real(p) - real(q), imag(p) - imag(q));\n}\n\n//equal\nbool operator==(const Point &p, const Point &q)\n{\n    return (real(p) == real(q)) && (imag(p) == imag(q));\n}\n\nReal radian_to_degree(Real r)\n{\n    return (r * 180.0 / Pi);\n}\n\nReal degree_to_radian(Real d)\n{\n    return (d * Pi / 180.0);\n}\n\n// norm\nReal norm(const Point &p)\n{\n    return real(p) * real(p) + imag(p) * imag(p);\n}\n\nReal abs(const Point &p)\n{\n    return sqrt(norm(p));\n}\n\n//argumant [0, 2 * Pi)\nReal arg(const Point &p)\n{\n    Real a = atan2(imag(p), real(p));\n    if (a < 0)\n        a = fabs(a) + Pi;\n    return a;\n}\n\nReal dot(const Point &p, const Point &q)\n{\n    return (real(p) * real(q) + imag(p) * imag(q));\n}\n\n//input\nistream &operator>>(istream &is, Point &p)\n{\n    Real a, b;\n    is >> a >> b;\n    p = Point(a, b);\n    return is;\n}\n\n//output\nostream &operator<<(ostream &os, Point &p)\n{\n    os << fixed << setprecision(10) << p.real() << \" \" << p.imag();\n}\n\nReal get_angle(Point a, Point b)\n{\n    return acos(dot(a, b) / (abs(a) * abs(b)));\n}\n\nint N;\n\nint main()\n{\n    cin >> N;\n    vector<Point> X(N);\n    for (int i = 0; i < N; i++)\n    {\n        cin >> X[i];\n    }\n\n    vector<int> index(N);\n    for (int i = 0; i < N; i++)\n    {\n        index[i] = i;\n    }\n\n    long double ans = 1e6;\n\n    do\n    {\n        Point now_vect(0.5, 0.); //今向いている方向\n        long double res = 0.;\n        for (int i = 0; i < N; i++)\n        {\n            Point next_vect = (i == 0 ? X[index[i]] : X[index[i]] - X[index[i - 1]]);\n            res += get_angle(now_vect, next_vect);\n            now_vect = next_vect;\n        }\n        Point next_vect = -X[index[N - 1]];\n        res += get_angle(now_vect, next_vect);\n        ans = min(ans, res);\n    } while (next_permutation(index.begin(), index.end()));\n\n    cout << fixed << setprecision(10);\n    cout << radian_to_degree(ans) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<iomanip>\n#include<cmath>\n#include<algorithm>\n#include<cassert>\nusing namespace std;\n\n#define EPS (1e-10)\n#define equals(a, b) (fabs((a) - (b)) < EPS)\n\nstruct Point;\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\nstruct Circle;\nstruct Segment;\ntypedef Segment Line;\ndouble norm(Point a);\ndouble abs(Point a);\ndouble dot(Vector a, Vector b);\ndouble cross(Vector a, Vector b);\ndouble getDistance(Point a, Point b);\ndouble getDistanceLP(Line l, Point p);\ndouble getDistanceSP(Segment s, Point p);\ndouble getDistance(Segment s1, Segment s2);\nbool isOrthogonal(Vector a, Vector b);\nbool isOrthogonal(Point a1, Point a2, Point b1, Point b2);\nbool isOrthogonal(Segment s1, Segment s2);\nbool isParallel(Vector a, Vector b);\nbool isParallel(Point a1, Point a2, Point b1, Point b2);\nbool isParallel(Segment s1, Segment s2);\nint ccw(Point p0, Point p1, Point p2);\nbool intersect(Point p1, Point p2, Point p3, Point p4);\nbool intersect(Segment s1, Segment s2);\nbool intersect(Circle c, Line l); // 誤差の検証をしていない\nbool intersect(Circle c1, Circle c2); // 誤差の検証をしていない\n\nPoint project(Segment s, Point p);\nPoint reflect(Segment s, Point p);\nPoint getCrossPoint(Segment s1, Segment s2);\npair<Point,Point> getCrossPoints(Circle c, Line l);\npair<Point,Point> getCrossPoints(Circle c1, Circle c2); // 誤差の検証をしていない\npair<Point,Point> getContactPoints(Circle c, Point p); // 接点 点は円の外部\n\ndouble area(Polygon g); // convexでなくてもよい. absを消せば符号付き面積\nbool isConvex(Polygon g); // O(n^2) 線形時間アルゴリズムが存在するらしい\nint contains(Polygon g, Point p);\n\ndouble arg(Vector p);   // 偏角\nVector polar(double a, double r); // 極座標系->ベクトル\n\nPolygon andrewScan(Polygon g); // 凸包の辺上の点も含めたければ!=CLOCKWISEを==COUNTER_CLOCKWISEに\ndouble convexDiameter(Polygon g); // gはconvex \n\n\nstruct Point{\n    double x, y;\n\n    Point(double x = 0, double y = 0) : x(x), y(y) {}\n\n    Point operator + (Point p){ return Point(x+p.x, y+p.y); }\n    Point operator - (Point p){ return Point(x-p.x, y-p.y); }\n    Point operator * (double a){ return Point(a*x, a*y); }\n    Point operator / (double a){ return Point(x/a, y/a); }\n\n    double abs() { return sqrt(norm()); }\n    double norm() { return x*x + y*y; }\n\n    bool operator < (const Point &p) const{\n        return x != p.x ? x < p.x : y < p.y;\n    }\n\n    bool operator == (const Point &p) const{\n        return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n    }\n};\n\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\nstruct Circle{\n    Point c;\n    double r;\n    Circle(Point c = Point(), double r = 0.0) : c(c), r(r) {}\n};\n\nstruct Segment{\n    Point p1, p2;\n    Segment(Point p1, Point p2) : p1(p1), p2(p2) {}\n};\n\ntypedef Segment Line;\n\n\ndouble norm(Point a){\n    return a.x * a.x + a.y * a.y;\n}\n\ndouble abs(Point a){\n    return sqrt(norm(a));\n}\n\ndouble dot(Vector a, Vector b){\n    return a.x * b.x + a.y * b.y;\n}\n\ndouble cross(Vector a, Vector b){\n    return a.x * b.y - a.y * b.x;\n}\n\ndouble getDistance(Point a, Point b){\n    return abs(a - b);\n}\n\ndouble getDistanceLP(Line l, Point p){\n    return abs(cross(l.p2 - l.p1, p - l.p1) / abs(l.p2 - l.p1));\n}\n\ndouble getDistanceSP(Segment s, Point p){\n    if(dot(s.p2-s.p1, p-s.p1) < 0.0)    return abs(p-s.p1);\n    if(dot(s.p1-s.p2, p-s.p2) < 0.0)    return abs(p-s.p2);\n    return getDistanceLP(s, p);\n}\n\ndouble getDistance(Segment s1, Segment s2){\n    if(intersect(s1, s2))   return 0.0;\n    return min({getDistanceSP(s1, s2.p1), getDistanceSP(s1, s2.p2), \n                getDistanceSP(s2, s1.p1), getDistanceSP(s2, s1.p2)});\n}\n\n\nbool isOrthogonal(Vector a, Vector b){\n    return equals(dot(a, b), 0.0);\n}\nbool isOrthogonal(Point a1, Point a2, Point b1, Point b2){\n    return isOrthogonal(a1-a2, b1-b2);\n}\nbool isOrthogonal(Segment s1, Segment s2){\n    return equals(dot(s1.p2-s1.p1, s2.p2-s2.p1), 0.0);\n}\nbool isParallel(Vector a, Vector b){\n    return equals(cross(a, b), 0.0);\n}\nbool isParallel(Point a1, Point a2, Point b1, Point b2){\n    return isParallel(a1-a2, b1-b2);\n}\nbool isParallel(Segment s1, Segment s2){\n    return equals(cross(s1.p2-s1.p1, s2.p2-s2.p1), 0.0);\n}\n\n\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;   // p2->p0->p1\nstatic const int ONLINE_FRONT = -2; // p0->p1->p2\nstatic const int ON_SEGMENT = 0;    // p0->p2->p1\nint ccw(Point p0, Point p1, Point p2){\n    Vector a = p1 - p0;\n    Vector b = p2 - p0;\n    if(cross(a, b) > EPS)   return COUNTER_CLOCKWISE;\n    if(cross(a, b) < -EPS)  return CLOCKWISE;\n    if(dot(a, b) < -EPS)    return ONLINE_BACK;\n    if(norm(a) < norm(b))   return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\n\nbool intersect(Point p1, Point p2, Point p3, Point p4){\n    return (ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 &&\n            ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0);\n}\nbool intersect(Segment s1, Segment s2){\n    return intersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\nbool intersect(Circle c, Line l){\n    return getDistanceLP(l, c.c) < c.r+EPS;\n}\nbool intersect(Circle c1, Circle c2){\n    return abs(c1.r-c2.r) <= getDistance(c1.c, c2.c) && getDistance(c1.c, c2.c) < c1.r+c2.r+EPS;\n}\n\nPoint project(Segment s, Point p){\n    Vector base = s.p2 - s.p1;\n    double r = dot(p - s.p1, base) / norm(base);\n    return s.p1 + base * r;\n}\n\nPoint reflect(Segment s, Point p){\n    return p + (project(s, p) - p) * 2.0;\n}\n\nPoint getCrossPoint(Segment s1, Segment s2){\n    Vector base = s2.p2 - s2.p1;\n    double d1 = abs(cross(base, s1.p1-s2.p1));\n    double d2 = abs(cross(base, s1.p2-s2.p1));\n    double t = d1 / (d1 + d2);\n    return s1.p1 + (s1.p2 - s1.p1) * t;\n}\n\npair<Point,Point> getCrossPoints(Circle c, Line l){\n    assert(intersect(c, l));\n    Vector pr = project(l, c.c);\n    Vector e = (l.p2 - l.p1) / abs(l.p2 - l.p1);\n    double base = sqrt(c.r * c.r - norm(pr - c.c));\n    return make_pair(pr + e*base, pr - e*base);\n}\n\npair<Point,Point> getCrossPoints(Circle c1, Circle c2){\n    assert(intersect(c1, c2));\n    double d = abs(c1.c - c2.c);\n    double a = acos( (c1.r*c1.r + d*d - c2.r*c2.r)/(2*c1.r*d) );\n    double t = arg(c2.c - c1.c);\n    return make_pair(c1.c + polar(c1.r, t+a), c1.c + polar(c1.r, t-a));\n}\n\npair<Point,Point> getContactPoints(Circle c, Point p){\n    assert(c.r < getDistance(c.c, p));\n    double d = getDistance(c.c, p);\n    return getCrossPoints(c, Circle(p, sqrt(d*d-c.r*c.r)));\n}\n\ndouble area(Polygon g){\n    if(g.size() < 3)    return 0;\n    int n = g.size();\n    Point o(0.0, 0.0);\n    double s = 0.0;\n    for(int i = 0; i < n; i++)  s += cross(g[i]-o, g[(i+1)%n]-o);\n    return abs(s) / 2.0;\n}\n\nbool isConvex(Polygon g){\n    bool ret = true;\n    int n = g.size();\n    for(int i = 0; i < n; i++){\n        for(int j = i+1; j < n; j++){\n            if(cross(g[i]-g[(i+n-1)%n], g[j]-g[(i+n-1)%n]) < -EPS || cross(g[(i+1)%n]-g[i], g[j]-g[i]) < -EPS){\n                ret = false;\n            }\n        }\n    }\n    return ret;\n}\n\nstatic const int IN = 2;\nstatic const int ON = 1;\nstatic const int OUT = 0;\nint contains(Polygon g, Point p){\n    int n = g.size();\n    bool x = false;\n    for(int i = 0; i < n; i++){\n        Point a = g[i] - p, b = g[(i+1)%n] - p;\n        if(abs(cross(a, b)) < EPS && dot(a, b) < EPS)   return ON;\n        if(a.y > b.y)   swap(a, b);\n        if(a.y < EPS && EPS < b.y && cross(a, b) > EPS) x = !x;\n    }\n    return x ? IN : OUT;\n}\n\n\ndouble arg(Vector p){\n    return atan2(p.y, p.x);\n}\n\nVector polar(double a, double r){\n    return Point(a * cos(r), a * sin(r));\n}\n\n\nPolygon andrewScan(Polygon g){\n    Polygon u, l;\n    if(g.size() < 3)    return g;\n    sort(g.begin(), g.end());\n    u.push_back(g[0]);\n    u.push_back(g[1]);\n    l.push_back(g[g.size()-1]);\n    l.push_back(g[g.size()-2]);\n\n    // upper\n    for(int i = 2; i < g.size(); i++){\n        for(int n = u.size(); n >= 2 && ccw(u[n-2], u[n-1], g[i]) != CLOCKWISE; n--){\n            u.pop_back();\n        }\n        u.push_back(g[i]);\n    }\n\n    // lower\n    for(int i = g.size()-3; i >= 0; i--){\n        for(int n = l.size(); n >= 2 && ccw(l[n-2], l[n-1], g[i]) != CLOCKWISE; n--){\n            l.pop_back();\n        }\n        l.push_back(g[i]);\n    }\n\n    reverse(l.begin(), l.end());\n    for(int i = u.size()-2; i >= 1; i--)    l.push_back(u[i]);\n\n    return l;\n}\n\ndouble convexDiameter(Polygon g){\n    double d = 0.0;\n    int n = g.size();\n    int is = 0, js = 0;\n    for(int i = 1; i < n; i++){\n        if(g[i].y > g[is].y)    is = i;\n        if(g[i].y < g[js].y)    js = i;\n    }\n    d = getDistance(g[is], g[js]);\n\n    int i = is, j = js, maxi = is, maxj = js;\n    do{\n        if(cross(g[(i+1)%n]-g[i], g[(j+1)%n]-g[j]) >= 0.0)  j = (j+1)%n;\n        else    i = (i+1)%n;\n        if(getDistance(g[i], g[j]) > d){\n            d = getDistance(g[i], g[j]);\n            maxi = i, maxj = j;\n        }\n    }while(i != is || j != js);\n\n    return d; // farthest pair is (maxi, maxj).\n}\n\n\ndouble todeg(double d){\n    return d / acos(0.0) / 2 * 180;\n}\n\nint main(){\n    int n;\n    cin >> n;\n    vector<Point> vp;\n    for(int i = 0; i < n; i++){\n        int x, y;\n        cin >> x >> y;\n        vp.push_back(Point(x, y));\n    }\n    sort(vp.begin(), vp.end());\n    double ans = n*360.0;\n    do{\n        double tmp = 0;\n        Point p = Point(1, 0);\n        Point from = Point(0,0);\n        for(int i = 0; i < n; i++){\n            double way = todeg(arg(vp[i]-from));\n            tmp += min(abs(todeg(arg(p))-way), 360-abs(todeg(arg(p))-way));\n            p = vp[i]-from;\n            from = vp[i];\n        }\n        double way = todeg(arg(Point(0,0)-vp.back()));\n        tmp += min(abs(todeg(arg(p))-way), 360-abs(todeg(arg(p))-way));\n        ans = min(ans, tmp);\n    }while(next_permutation(vp.begin(), vp.end()));\n    cout << fixed << setprecision(12) << ans << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iomanip>\n#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <complex>\n\nusing Real = long double;\nusing std::complex;\nusing std::vector;\nusing Complex = complex<Real>;\n\nstruct Fout {\n    int precision;\n    Fout(int precision) : precision(precision) {}\n};\nstd::ostream& operator<<(std::ostream& os, const Fout& fio) {\n    os << std::fixed << std::setprecision(fio.precision);\n    return os;\n}\n\nconst Real PI = acos(-1);\n\nint fact(int n) {\n    return n == 0 ? 1 : n * fact(n - 1);\n}\n\nint main() {\n    int n;\n    std::cin >> n;\n\n    vector<Complex> xs(n);\n    for (auto& x : xs) {\n        Real a, b;\n        std::cin >> a >> b;\n        x = Complex(a, b);\n    }\n    xs.emplace(xs.begin(), 0);\n    xs.emplace_back(0);\n\n    Real ans = 1e100;\n    for (int q = 0; q < fact(n); ++q) {\n        Real theta = 0, sum = 0;\n        for (int i = 0; i <= n; ++i) {\n            Real phi = std::arg(xs[i + 1] - xs[i]);\n            Real delta = std::abs(theta - phi);\n            sum += std::min(delta, 2 * PI - delta) * 180 / PI;\n            theta = phi;\n        }\n        ans = std::min(ans, sum);\n        std::next_permutation(xs.begin() + 1, xs.end() - 1,\n                              [](Complex a, Complex b) { return a.real() < b.real(); });\n    }\n\n    std::cout << Fout(10) << ans << std::endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\n// #define int ll\nusing PII = pair<ll, ll>;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n\ntemplate<typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate<typename T> bool IN(T a, T b, T x) { return a<=x&&x<b; }\ntemplate<typename T> T ceil(T a, T b) { return a/b + !!(a%b); }\n\ntemplate<typename T> vector<T> make_v(size_t a) { return vector<T>(a); }\ntemplate<typename T,typename... Ts>\nauto make_v(size_t a,Ts... ts) {\n    return vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));\n}\ntemplate<typename T,typename V> typename enable_if<is_class<T>::value==0>::type\nfill_v(T &t, const V &v) { t=v; }\ntemplate<typename T,typename V> typename enable_if<is_class<T>::value!=0>::type\nfill_v(T &t, const V &v ) { for(auto &e:t) fill_v(e,v); }\n\ntemplate<class S,class T>\nostream &operator <<(ostream& out,const pair<S,T>& a) {\n    out<<'('<<a.first<<','<<a.second<<')'; return out;\n}\ntemplate<class T>\nostream &operator <<(ostream& out,const vector<T>& a){\n    out<<'[';\n    for(const T &i: a) out<<i<<',';\n    out<<']';\n    return out;\n}\ntemplate<class T>\nostream &operator <<(ostream& out, const set<T>& a) {\n    out<<'{';\n    for(const T &i: a) out<<i<<',';\n    out<<'}';\n    return out;\n}\ntemplate<class T, class S>\nostream &operator <<(ostream& out, const map<T,S>& a) {\n    out<<'{';\n    for(auto &i: a) out<<i<<',';\n    out<<'}';\n    return out;\n}\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0}; // DRUL\nconst int INF = 1<<30;\nconst ll LLINF = 1LL<<60;\nconst ll MOD = 1000000007;\n\nsigned main(void)\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    ll n;\n    cin >> n;\n    vector<ll> x(n), y(n);\n    REP(i, n) cin >> x[i] >> y[i];\n\n    const double PI = acos(-1);\n\n    vector<ll> ord(n);\n    iota(ALL(ord), 0);\n    double ret = LLINF;\n    do {\n        // cout << ord << endl;\n        ll mx = 0, my = 0;\n        double dir = 0, arg = 0;\n        for(auto i: ord) {\n            double t = atan2(y[i]-my, x[i]-mx);\n            arg += min(2*PI-abs(t-dir), abs(t-dir));\n            // cout << \"i=\" << i << \" t=\" << t << \" \" << min(2*PI-abs(t-dir), abs(t-dir)) << endl;\n            dir = t;\n            mx = x[i], my = y[i];\n        }\n        double t = atan2(0-my, 0-mx);\n        arg += min(2*PI-abs(t-dir), abs(t-dir));\n        // cout << \"i=\" << n << \" t=\" << t << \" \" << min(2*PI-abs(t-dir), abs(t-dir)) << endl;\n        // cout << arg << endl;\n        chmin(ret, arg);\n    } while(next_permutation(ALL(ord)));\n\n    cout << fixed << setprecision(9) << ret * 180.0 / PI << endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define PI acos(-1.0)\n\nint main(){\n  int n; cin >> n;\n  vector<pair<int, int> > xy(n);\n  for (int i = 0; i < n; ++i) cin >> xy[i].first >> xy[i].second;\n  sort(xy.begin(), xy.end());\n  double alpha = 0, ans = 1e18;\n  do {\n    alpha = atan2(xy[0].second, xy[0].first);\n    if (alpha < 0) alpha += 2 * PI;\n    double tmp = min(alpha, 2 * PI - alpha);\n    for (int i = 1; i < n; ++i) {\n      double t = atan2(xy[i].second - xy[i - 1].second, xy[i].first - xy[i - 1].first);\n      if (t < 0) t += 2 * PI;\n      tmp += min(abs(alpha - t),2 * PI- abs(alpha - t));\n      alpha = t;\n    }\n    double t = atan2(-xy[n - 1].second, -xy[n - 1].first);\n    if (t < 0) t += 2 * PI;\n    tmp += min(abs(alpha - t), 2 * PI - abs(alpha - t));\n    ans = min(ans, tmp);\n  } while (next_permutation(xy.begin(), xy.end()));\n  printf(\"%.10f\\n\", ans * 180.0 / PI);\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#define YES \"YES\"\n#define NO \"NO\"\n#define YESNO OUT(three(solve(),YES,NO))\n#define ECHO OUT(solve())\n#define three(A,B,C) ((A)?(B):(C))\n#define FOR(i,a,b)  for(LL i=(a);i< (LL)(b);i++)\n#define EFOR(i,a,b) for(LL i=(a);i<=(LL)(b);i++)\n#define RFOR(i,a,b) for(LL i=(b);i>=(LL)(a);i--)\n#define REP(i,b) FOR(i,zero,b)\n#define rep REP\n#define EREP(i,b) EFOR(i,zero,b)\n#define RREP(i,b) RFOR(i,b,zero)\n#define ALL(c) c.begin(),c.end()\n#define UNIQUE(c) sort(ALL(c));c.erase(unique(ALL(c)),c.end())\n#define MAX(c) (*max_element(ALL(c)))\n#define MIN(c) (*min_element(ALL(c)))\n#define MP make_pair\n#define FI first\n#define SE second\n#define SI(x) (LL(x.size()))\n#define PB push_back\n#define DEBUG(a) OUT(a)\n#define DEBUG2(a,b) OUT2(a,b)\n#define cat cout << __LINE__ << endl\n#define OUT(a) cout << (a) << endl\n#define OUT2(a,b) cout << (a) <<\" \"<<(b) << endl\n#define zero 0LL\n#define all ALL\n#define pb emplace_back\n#define eb pb\n#define int long long\nusing namespace std;\ntemplate<typename T> inline void maximize(T &a, T b) { a = max(a, b); }\ntemplate<typename T> inline void minimize(T &a, T b) { a = min(a, b); }\ntemplate<typename T> inline bool middle(T a, T b, T c) { return b <= a && a <= c; }\ntemplate<class T> inline bool MX(T &l, const T &r) { return l < r ? l = r, 1 : 0; }\ntemplate<class T> inline bool MN(T &l, const T &r) { return l > r ? l = r, 1 : 0; }\ntypedef int LL;\ntypedef double ld;\ntypedef int ut;\ntypedef vector<ut> VI;\ntypedef vector<VI> VII;\ntypedef pair<ut, ut> pr;\ntypedef pair<ut, pr> ppr;\ntypedef vector<pr> Vpr;\ntypedef vector<ppr> Vppr;\ntypedef tuple<int, int, int, int> tapu;\ntypedef vector<tapu> Vtapu;\ntypedef priority_queue<tapu, Vtapu, greater<tapu> > PQ;\ninline void outputVI(VI x) { REP(i, SI(x)) { cout << three(i, \" \", \"\") << x[i]; }OUT(\"\"); }\nconst int SIZE1 = 3e5 + 1000;\nconst int SIZE2 = 5010;\nconst int SIZE3 = 430;\nconst int SIZE = SIZE1;\nconst int MAPSIZE = 40;\nconst LL p = 7 + 1e9;\nconst LL INF = 1LL << 60;\nconst long double EPS = 1e-7;\ntypedef pair<ld, ut> pld;\n \nLL N;\nLL X[SIZE],Y[SIZE];\nld solve(VI v){\n  ld dir=0;\n  ld dirsum=0;\n  v.pb(0);  \n  pr now=pr(0,0);\n  REP(i,N+1){\n    ld ndir=atan2(Y[v[i]]-now.second,X[v[i]]-now.first);\n        \n    dirsum+=min(2*M_PI-abs<ld>(ndir-dir),abs<ld>(ndir-dir));\n  //  cout << dir*360/(2*M_PI) << endl;\n    dir=ndir;  \n    now=pr(X[v[i]],Y[v[i]]);\n  }\n  //cout << dirsum << endl;\n  //outputVI(v);\n  return dirsum;\n}\nsigned main(){\n  cout << setprecision(10) << endl;\n  cin >> N;\n  VI v;\n  EFOR(i,1,N){\n    cin >> X[i] >> Y[i];\n  }\n  EFOR(i,1,N) v.pb(i);\n  ld ans=INF;\n  do{\n    MN(ans,solve(v));\n  }while(next_permutation(ALL(v)));\n  //cout << ans << endl;\n  cout << ans*360*1.0/(2*M_PI) << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define INF_LL (int64)1e18\n#define INF (int32)1e9\n#define REP(i, n) for(int64 i = 0;i < (n);i++)\n#define FOR(i, a, b) for(int64 i = (a);i < (b);i++)\n#define all(x) x.begin(),x.end()\n#define fs first\n#define sc second\n\nusing int32 = int_fast32_t;\nusing uint32 = uint_fast32_t;\nusing int64 = int_fast64_t;\nusing uint64 = uint_fast64_t;\nusing PII = pair<int32, int32>;\nusing PLL = pair<int64, int64>;\n\nconst double eps = 1e-10;\n\ntemplate<typename A, typename B>inline void chmin(A &a, B b){if(a > b) a = b;}\ntemplate<typename A, typename B>inline void chmax(A &a, B b){if(a < b) a = b;}\n\ntemplate<typename T>\nvector<T> make_v(size_t a){return vector<T>(a);}\n\ntemplate<typename T,typename... Ts>\nauto make_v(size_t a,Ts... ts){\n  return vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));\n}\n\ntemplate<typename T,typename U,typename... V>\ntypename enable_if<is_same<T, U>::value!=0>::type\nfill_v(U &u,const V... v){u=U(v...);}\n\ntemplate<typename T,typename U,typename... V>\ntypename enable_if<is_same<T, U>::value==0>::type\nfill_v(U &u,const V... v){\n  for(auto &e:u) fill_v<T>(e,v...);\n}\n\nint main() {\n    int64 N;\n    cin >> N;\n    vector<int64> perm(N);\n    vector<int64> x(N+1), y(N+1);\n    iota(all(perm), 0);\n    REP(i,N) {\n        cin >> x[i] >> y[i];\n    }\n    double res = INF_LL;\n    do {\n        double now = 0;\n        double sum = 0;\n        int64 px = 0, py = 0;\n        REP(i, N+1) {\n            int64 nid = (i == N ? N : perm[i]);\n            double deg = atan2(y[nid]-py, x[nid]-px);\n            double diff = abs(now-deg);\n            diff = min(diff, 2*M_PI-diff);\n            now = deg;\n            sum += diff;\n            px = x[nid]; py = y[nid];\n        }\n        chmin(res, sum);\n    } while(next_permutation(all(perm)));\n    cout << fixed << setprecision(10) << res/M_PI*180 << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, m, n) for (int i = m; i < n; ++i)\n\nint main() {\n    int N; cin >> N;\n    using P = pair<int, int>;\n    vector<P> S(N);\n    rep(i, 0, N) {\n        int x, y;\n        cin >> x >> y;\n        S[i] = make_pair(x, y);\n    }\n    function<double(double)> f = [&](double r) {\n        double res = r * 180 / M_PI;\n        return res;\n    };\n    function<int(int, int)> pos = [&](int x, int y) {\n        if(x >= 0) {\n            if(y >= 0) return 1;\n            else return 4;\n        } else {\n            if(y >= 0) return 2;\n            else return 3;\n        }\n    };\n    function<double()> solve = [&]() {\n        int x = 0, y = 0;\n        vector<double> T = {0};\n        S.push_back(make_pair(0, 0));\n        rep(i, 0, N + 1) {\n            int vx = S[i].first - x, vy = S[i].second - y;\n            double t = atan((double)vy / vx);\n            t = f(t);\n            if(pos(vx, vy) != 1) t += 180;\n            if(pos(vx, vy) == 4) t += 180;\n            T.push_back(t);\n            x = S[i].first;\n            y = S[i].second;\n        }\n        S.pop_back();\n        double res = 0;\n        rep(i, 0, N + 1) {\n            double add = abs(T[i + 1] - T[i]);\n            if(add > 180) add = 360 - add;\n            res += add;\n        }\n        return res;\n    };\n    double ans = 1e9;\n    sort(S.begin(), S.end());\n    do {\n        ans = min(ans, solve());\n    } while(next_permutation(S.begin(), S.end()));\n    printf(\"%.10lf\\n\", ans);\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"O3\")\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\n#include <bitset>\nusing namespace std;\n\nusing ll = long long;\nusing P = pair<int, int>;\nusing T = tuple<int, int, int>;\n\ntemplate <class T> inline T chmax(T &a, const T b) {return a = (a < b) ? b : a;}\ntemplate <class T> inline T chmin(T &a, const T b) {return a = (a > b) ? b : a;}\n\nconstexpr int MOD = 1e9 + 7;\nconstexpr int inf = 1e9;\nconstexpr long long INF = 1e18;\nconstexpr double pi = acos(-1);\nconstexpr double EPS = 1e-10;\n\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, 1, 0, -1};\n\ndouble todeg(double ang){\n    return ang * 180 / pi;\n}\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int n; cin>>n;\n    vector<int> x(n), y(n);\n    for(int i=0; i<n; i++) cin>>x[i]>>y[i];\n    vector<int> perm(n);\n    iota(perm.begin(), perm.end(), 0);\n\n    double ans = inf;\n    do{\n        vector<P> points;\n        points.emplace_back(0, 0);\n        for(auto i : perm) points.emplace_back(x[i], y[i]);\n        points.emplace_back(0, 0);\n\n        double theta = 0, sum = 0;\n        for(int i=0; i<=n; i++){\n            int dx = points[i+1].first - points[i].first;\n            int dy = points[i+1].second - points[i].second;\n\n            double cur_theta = atan2(dy, dx);\n\n            sum += todeg(min(abs(theta - cur_theta), 2 * pi - abs(theta - cur_theta)));\n            theta = cur_theta;\n        }\n\n        chmin(ans, sum);\n    }while(next_permutation(perm.begin(), perm.end()));\n\n    printf(\"%.10f\\n\", ans);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <iomanip>\n#include <cmath>\n#include <cassert>\nusing namespace std;\n\nstruct point{\n    int x,y;\n};\n\nstruct vec{\n    point left, right;\n};\n\n\ndouble dot( vec a, vec b ){\n    double x1 = a.left.x-a.right.x;\n    double x2 = b.left.x-b.right.x;\n\n    double y1 = a.left.y-a.right.y;\n    double y2 = b.left.y-b.right.y;\n\n    return x1*x2+y1*y2;\n}\n\ndouble norm( vec a ){\n    return sqrt(dot(a,a));\n}\n\ndouble f( vec a, vec b ){\n    assert( norm(a)!=0 );\n    assert( norm(b)!=0 );\n    return 180*acos( dot(a,b)/norm(a)/norm(b) )/3.14159265;\n}\n\nint main(){\n    int n;\n    cin>>n;\n\n    vector<point> vp;\n    for( int i=0; i<n; ++i ){\n        int x,y;\n        cin>>x>>y;\n        vp.emplace_back(point{x,y});\n    }\n\n    vector<int> num;\n    for( int i=0; i<n; ++i ){\n        num.emplace_back(i);\n    }\n    double ans = 1e8;\n\n    do{\n        vector<point> tmp;\n        tmp.push_back(point{0,0});\n        \n        for( auto elm: num ){\n            tmp.emplace_back(point{vp[elm]});\n        }\n        tmp.push_back(point{0,0});\n\n        double cand = 0;\n        for( int i=0; i<(int)tmp.size()-1; ++i ){\n            if( i==0 ){\n                vec a = vec{tmp[i  ], tmp[i+1]};\n                vec def = vec{point{0,0}, point{1,0}};\n                cand += f( a, def );\n            }else{\n                vec a = vec{tmp[i-1], tmp[i  ]};\n                vec b = vec{tmp[i  ], tmp[i+1]};\n                cand += f( a, b );\n            }\n        }\n        ans = min( ans, cand );\n    }while(next_permutation( num.begin(), num.end() ));\n    cout << std::setprecision(10) << ans << endl;\n}    \n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <iomanip>\n#include <set>\n#include <tuple>\n#define mkp make_pair\n#define mkt make_tuple\n#define rep(i,n) for(int i = 0; i < (n); ++i)\nusing namespace std;\ntypedef long long ll;\nconst ll MOD=1e9+7;\n\nint N;\nvector<int> X,Y;\n\nconst double PI=acos(-1.0);\n\nint main(){\n  cin>>N;\n  X.resize(N);\n  Y.resize(N);\n  rep(i,N) cin>>X[i]>>Y[i];\n\n  vector<int> v;\n  for(int i=0;i<N;i++) v.push_back(i);\n\n  double ans=1e9;\n  do{\n    int x=0,y=0;\n    double vx=1,vy=0;\n    double t=0.0;\n    for(int i=0;i<N;i++){\n      double nvx=X[v[i]]-x;\n      double nvy=Y[v[i]]-y;\n\n      double c=sqrt(nvx*nvx+nvy*nvy);\n      nvx=nvx/c;\n      nvy=nvy/c;\n\n      double nai=vx*nvx+vy*nvy;\n      double a=sqrt(vx*vx+vy*vy);\n      double b=sqrt(nvx*nvx+nvy*nvy);\n      a*=b;\n      double res=(double)nai/a;\n      res=acos(res);\n      res*=180.0/PI;\n      t+=res;\n      x=X[v[i]];\n      y=Y[v[i]];\n      vx=nvx;\n      vy=nvy;\n    }\n      double nvx=0-x;\n      double nvy=0-y;\n\n      double c=sqrt(nvx*nvx+nvy*nvy);\n      nvx=nvx/c;\n      nvy=nvy/c;\n\n      double nai=vx*nvx+vy*nvy;\n      double a=sqrt(vx*vx+vy*vy);\n      double b=sqrt(nvx*nvx+nvy*nvy);\n      a*=b;\n      double res=(double)nai/a;\n      res=acos(res);\n      res*=180.0/PI;\n      t+=res;\n      ans=min(ans,t);\n\n  }while(next_permutation(v.begin(),v.end()));\n\n  cout<<fixed<<setprecision(10)<<ans<<endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#if __has_include(\"../library/Basic/Debug.hpp\")\n\n#include \"../library/Basic/Debug.hpp\"\n\n#else\n\n/* ----- Header Files ----- */\n// IO\n#include <cstdio>\n#include <iomanip>\n#include <ios>\n#include <iostream>\n\n// algorithm\n#include <algorithm>\n#include <cmath>\n#include <numeric>\n\n// container\n#include <vector>\n#include <string>\n#include <tuple>\n#include <complex>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <bitset>\n\n// others\n#include <random>\n#include <limits>\n#include <functional>\n#include <ctime>\n#include <cassert>\n#include <cstdint>\n\n/* ----- Type Alias ----- */\nusing Int = long long int;\nusing Real = long double;\nusing std::pair;\nusing std::string;\nusing std::tuple;\nusing std::vector;\ntemplate <class T>\nusing MaxHeap = std::priority_queue<T>;\ntemplate <class T>\nusing MinHeap = std::priority_queue<T, std::vector<T>, std::greater<T>>;\n\ntemplate <class T>\nT genv(T v) { return v; }\n\ntemplate <class T, class... Ts>\nauto genv(size_t l, Ts... ts) {\n    return vector<decltype(genv<T>(ts...))>(l, genv<T>(ts...));\n}\n\ntemplate <class Cost = Int>\nstruct Edge {\n    Int src, dst;\n    Cost cost;\n    Edge(Int src = -1, Int dst = -1, Cost cost = 1)\n        : src(src), dst(dst), cost(cost){};\n\n    bool operator<(const Edge<Cost>& e) const { return this->cost < e.cost; }\n    bool operator>(const Edge<Cost>& e) const { return this->cost > e.cost; }\n};\n\ntemplate <class Cost = Int>\nusing Edges = vector<Edge<Cost>>;\ntemplate <class Cost = Int>\nusing Graph = vector<vector<Edge<Cost>>>;\n\n#endif\n\n/* ----- Misc ----- */\nvoid fastio() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n}\n\nstruct Fout {\n    Int precision;\n    Fout(Int precision) : precision(precision) {}\n};\nstd::ostream& operator<<(std::ostream& os, const Fout& fio) {\n    os << std::fixed << std::setprecision(fio.precision);\n    return os;\n}\n\n\n/* ----- Constants ----- */\n// constexpr Int INF = std::numeric_limits<Int>::max() / 3;\n// constexpr Int MOD = 1000000007;\nconst Real PI = acos(-1);\n// constexpr Real EPS = 1e-10;\n// std::mt19937 mt(int(std::time(nullptr)));\n\nusing std::complex;\nusing Complex = complex<Real>;\n\nint fact(int n) {\n    return n == 0 ? 1 : n * fact(n - 1);\n}\n\nint main() {\n    int n;\n    std::cin >> n;\n\n    vector<Complex> xs(n);\n    for (auto& x : xs) {\n        Real a, b;\n        std::cin >> a >> b;\n        x = Complex(a, b);\n    }\n    xs.emplace(xs.begin(), 0);\n    xs.emplace_back(0);\n\n    Real ans = 1e100;\n    for (int q = 0; q < fact(n); ++q) {\n        Real theta = 0, sum = 0;\n        for (int i = 0; i <= n; ++i) {\n            Real phi = std::arg(xs[i + 1] - xs[i]);\n            Real delta = std::abs(theta - phi);\n            sum += std::min(delta, 2 * PI - delta) * 180 / PI;\n            theta = phi;\n        }\n        ans = std::min(ans, sum);\n        std::next_permutation(xs.begin() + 1, xs.end() - 1,\n                              [](Complex a, Complex b) { return a.real() < b.real(); });\n    }\n\n    std::cout << Fout(10) << ans << std::endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "/*  -*- coding: utf-8 -*-\n *\n * 3066.cc: Satake likes straight\n */\n\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n#include<set>\n#include<stack>\n#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n#include<numeric>\n#include<utility>\n#include<complex>\n#include<functional>\n \nusing namespace std;\n\n/* constant */\n\nconst int MAX_N = 9;\nconst int NBITS = 1 << MAX_N;\nconst double PI = acos(-1.0);\nconst double DINF = 1e60;\n\n/* typedef */\n\ntemplate <typename T>\nstruct Pt {\n  T x, y;\n\n  Pt() {}\n  Pt(T _x, T _y) : x(_x), y(_y) {}\n  Pt(const Pt<T> &pt) : x(pt.x), y(pt.y) {}\n\n  Pt<T> operator+(const Pt<T> pt) const { return Pt<T>(x + pt.x, y + pt.y); }\n  Pt<T> operator-() const { return Pt<T>(-x, -y); }\n  Pt<T> operator-(const Pt<T> pt) const { return Pt<T>(x - pt.x, y - pt.y); }\n  Pt<T> operator*(T t) const { return Pt<T>(x * t, y * t); }\n  Pt<T> operator/(T t) const { return Pt<T>(x / t, y / t); }\n  T dot(Pt<T> v) const { return x * v.x + y * v.y; }\n  T cross(Pt<T> v) const { return x * v.y - y * v.x; }\n  Pt<T> mid(const Pt<T> pt) { return Pt<T>((x + pt.x) / 2, (y + pt.y) / 2); }\n  T d2() { return x * x + y * y; }\n  double d() { return sqrt(d2()); }\n\n  Pt<T> normalize() {\n    double d0 = d();\n    return (d0 != 0.0) ? Pt<T>(x / d0, y / d0) : *this;\n  }\n\n  void print() { printf(\"(%d,%d)\", x, y); }\n};\n\ntypedef Pt<double> pt;\n\n/* global variables */\n\npt ps[MAX_N], nvs[MAX_N][MAX_N];\ndouble dp[NBITS][MAX_N][MAX_N];\n\n/* subroutines */\n\ninline void setmin(double &a, double b) { if (a > b) a = b; }\n\n/* main */\n\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  n++;\n\n  ps[0] = pt(0.0, 0.0);\n  for (int i = 1; i < n; i++) scanf(\"%lf%lf\", &ps[i].x, &ps[i].y);\n\n  for (int i = 0; i < n; i++)\n    for (int j = 0; j < n; j++)\n      if (i != j)\n\tnvs[i][j] = (ps[j] - ps[i]).normalize();\n\n  int nbits = 1 << n;\n  for (int bits = 0; bits < nbits; bits++)\n    for (int i = 0; i < n; i++)\n      fill(dp[bits][i], dp[bits][i] + n, DINF);\n\n  for (int i = 1, bi = 1 << 1; i < n; i++, bi <<= 1)\n    dp[1 | bi][0][i] = acos(nvs[0][i].x);\n\n  for (int bits = 0; bits < nbits; bits++)\n    for (int i = 0; i < n; i++)\n      for (int j = 0; j < n; j++)\n\tif (dp[bits][i][j] < DINF)\n\t  for (int k = 0, bk = 1; k < n; k++, bk <<= 1)\n\t    if (! (bits & bk))\n\t      setmin(dp[bits | bk][j][k],\n\t\t     dp[bits][i][j] + acos(nvs[i][j].dot(nvs[j][k])));\n\n  double mind = DINF;\n  for (int i = 0; i < n; i++)\n    for (int j = 0; j < n; j++)\n      if (dp[nbits - 1][i][j] < DINF)\n\tsetmin(mind, dp[nbits - 1][i][j] + acos(nvs[i][j].dot(nvs[j][0])));\n\n  printf(\"%.8lf\\n\", mind * 180 / PI);\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <complex>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\nusing W = double;\nusing P = complex<W>;\nconstexpr W pi = acos(-1);\n\nint main(){\n  int N;\n  cin >> N;\n  vector<P> ps;\n  for(int i = 0; i < N; ++i){\n    W x, y;\n    cin >> x >> y;\n    ps.emplace_back(x,y);\n  }\n  vector<int> I(N);\n  for(int i = 0; i < N; ++i) I[i] = i;\n  W ans = 1e18;\n  do{\n    P s(0,0), d(1,0);\n    W t = 0;\n    for(int i = 0; i < N; ++i){\n      W a = abs(arg((ps[I[i]]-s)/d));\n      t += a;\n      d = (ps[I[i]]-s)/abs((ps[I[i]]-s));\n      s = ps[I[i]];\n    }\n    t += abs(arg((P(0,0)-s)/d));\n    ans = min(ans,t);\n  }while(next_permutation(I.begin(), I.end()));\n  ans *= 180./pi;\n  printf(\"%.12f\\n\",ans);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n\n#include <iostream>\n#include <complex>\n#include <string>\n#include <algorithm>\n#include <numeric>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n\n#include <functional>\n#include <cassert>\n\ntypedef long long ll;\nusing namespace std;\n\n#ifndef LOCAL\n#define debug(x) ;\n#else\n#define debug(x) cerr << __LINE__ << \" : \" << #x << \" = \" << (x) << endl;\n\ntemplate <typename T1, typename T2>\nostream &operator<<(ostream &out, const pair<T1, T2> &p) {\n  out << \"{\" << p.first << \", \" << p.second << \"}\";\n  return out;\n}\n\ntemplate <typename T>\nostream &operator<<(ostream &out, const vector<T> &v) {\n  out << '{';\n  for (const T &item : v) out << item << \", \";\n  out << \"\\b\\b}\";\n  return out;\n}\n#endif\n\n#define mod 1000000007 //1e9+7(prime number)\n#define INF 1000000000 //1e9\n#define LLINF 2000000000000000000LL //2e18\n#define SIZE 200010\n\ntypedef double P_type; //座標(integer or real)\ntypedef double G_real; //実数の戻り値(float or double or long double)\ntypedef complex<P_type> P;\nconst G_real P_eps = 1e-8; //整数の時はゼロ\n\nnamespace std{\n  template<class T> bool operator<(const complex<T> &a, const complex<T> &b){\n    return abs(a.real() - b.real()) < P_eps ? a.imag() + P_eps < b.imag() : a.real() + P_eps < b.real();\n  }\n};\n\nP rotate(P p, double theta){\n  return p * P(cos(theta), sin(theta));\n}\n\n//内積\nP_type dot(P a, P b) {\n  return (a * conj(b)).real();\n}\n\n//外積\nP_type cross(P a, P b) {\n  return (conj(a) * b).imag();\n}\n\n//反時計回り\nint ccw(P a, P b, P c){\n  if(cross(b-a, c-a) > P_eps) return 1; //COUNTER_CLOCKWISE(center:a)\n  if(cross(b-a, c-a) < -P_eps) return -1; //CLOCKWISE(center:a)\n  if(dot(b-a, c-a) < -P_eps) return -2; //c -> a -> b\n  if(dot(a-b, c-b) < -P_eps) return 2; //a -> b -> c\n  return 0; //a -> c -> b\n}\n\n// a -> b -> c\nP_type degree(P a, P b, P c) {\n  c = c - b;\n  a = b - a;\n  return atan2(cross(c, a), dot(c, a)) / M_PI * 180;\n}\n\nint main(){\n  int N, x[8], y[8];\n  P points[11];\n\n  cin >> N;\n\n  for(int i=0; i<N; i++) {\n    cin >> x[i] >> y[i];\n    points[i+1] = P(x[i], y[i]);\n  }\n\n  int p[N+3];\n  iota(p, p+N+3, 0);\n  points[0] = P(0, 0);\n  points[N+1] = P(0, 0);\n  points[N+2] = P(-1, 0);\n\n  double ans = 1e18;\n\n  do{\n    double sum = 0;\n\n    for(int i=N+1; i>=1; i--) {\n      sum += abs(degree(points[p[i+1]], points[p[i]], points[p[i-1]]));\n    }\n\n    ans = min(ans, sum);\n\n  }while(next_permutation(p+1, p+N+1));\n\n  printf(\"%.10lf\\n\", ans);\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#include<cmath>\nusing namespace std;\n\nstruct P {\n  int x, y;\n  P(int x, int y) : x(x), y(y) {}\n};\n\nint n;\ndouble x[9],y[9];\n//using P=pair<int,int>;\nvector<P> p;\nP vec0(1,0);\ndouble minx=1<<30;\n\ndouble norm(P v) { // 長さを返す\n  return sqrt(v.x * v.x + v.y * v.y);\n}\n\ndouble calc_deg(P cur, P nxt, P v) {\n  auto u = P{nxt.x - cur.x, nxt.y - cur.y};\n  auto ip = v.x * u.x + v.y * u.y; // 内積\n  return acos(ip / norm(v) / norm(u)) / 2 / acos(-1) * 360;\n}\n\nint main(){\n    vector<int> a;\n    cin>>n;\n    for(int i=0; i<n; i++){\n        cin>>x[i]>>y[i];\n        p.push_back(P(x[i],y[i]));\n        a.push_back(i);\n    }\n    do{\n        P posv={1,0};\n        P posp={0,0};\n        double temp=0;\n        for (int i=0; i<n; i++){\n            temp+=calc_deg(posp,p[a[i]],posv);\n            posv.x=p[a[i]].x-posp.x; posv.y=p[a[i]].y-posp.y;\n            posp=p[a[i]];\n        }\n        P vec1={0,0};\n        temp+=calc_deg(posp,vec1,posv);\n        minx=(minx<temp)?minx:temp;\n    }while(next_permutation(a.begin(), a.end()));\n    printf(\"%.8lf\\n\",minx);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <class T>\ninline bool chmax(T &a, T b)\n{\n    if (a < b)\n    {\n        a = b;\n        return 1;\n    }\n    return 0;\n}\ntemplate <class T>\ninline bool chmin(T &a, T b)\n{\n    if (a > b)\n    {\n        a = b;\n        return 1;\n    }\n    return 0;\n}\ntypedef long long int ll;\n\n#define ALL(v) (v).begin(), (v).end()\n#define RALL(v) (v).rbegin(), (v).rend()\n#define endl \"\\n\"\nconst double EPS = 1e-7;\nconst int INF = 1 << 30;\nconst ll LLINF = 1LL << 60;\nconst double PI = acos(-1);\nconst int MOD = 1000000007;\n\n//-------------------------------------\n\nusing P = pair<double, double>; //x, y\n\nP makeVec(P prev, P next)\n{\n    double x = next.first - prev.first;\n    double y = next.second - prev.second;\n    return P(x, y);\n}\n\ndouble calc(P prev, P next)\n{\n    double x1 = prev.first;\n    double y1 = prev.second;\n    double x2 = next.first;\n    double y2 = next.second;\n    return fabs((atan2(x1 * y2 - x2 * y1, x1 * x2 + y1 * y2) / PI) * 180.0);\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n;\n    cin >> n;\n    vector<P> point(n);\n    for (int i = 0; i < n; i++)\n    {\n        cin >> point[i].first >> point[i].second;\n    }\n    double ans = 1000000;\n    sort(ALL(point));\n    do\n    {\n        // cout << \"dbg:\";\n        // for(int i=0;i<n;i++){\n        //     if(i == n - 1){\n        //         cout << \"(\" << point[i].first << \", \" << point[i].second << \")\" << endl;\n        //     }else\n        //     {\n        //         cout << \"(\" << point[i].first << \", \" << point[i].second << \")\" << \" \";\n        //     }\n        // }\n        double tmp = 0;\n        vector<P> vec;\n        vec.push_back(P(1, 0));\n        vec.push_back(makeVec(P(0, 0), point[0]));\n        for (int i = 0; i < n; i++)\n        {\n            if (i == n - 1)\n            {\n                vec.push_back(makeVec(point[i], P(0, 0)));\n            }\n            else\n            {\n                vec.push_back(makeVec(point[i], point[i + 1]));\n            }\n        }\n        for (int i = 0; i < vec.size() - 1; i++)\n        {\n            tmp += calc(vec[i], vec[i + 1]);\n        }\n        chmin(ans, tmp);\n    } while (next_permutation(ALL(point)));\n    cout << fixed;\n    cout << setprecision(15) << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define ALL(a)  (a).begin(),(a).end()\n#define ALLR(a)  (a).rbegin(),(a).rend()\n#define spa << \" \" <<\n#define lfs <<fixed<<setprecision(10)<<\n#define test cout<<\"test\"<<endl;\n#define fi first\n#define se second\n#define MP make_pair\n#define PB push_back\n#define EB emplace_back\n#define rep(i,n,m) for(ll i = n; i < (ll)(m); i++)\n#define rrep(i,n,m) for(ll i = n - 1; i >= (ll)(m); i--)\ntypedef long long ll;\ntypedef long double ld;\nconst ll MOD = 1e9+7;\n//const ll MOD = 998244353;\nconst ll INF = 1e18;\nusing P = pair<ll, ll>;\ntemplate<typename T>\nvoid chmin(T &a,T b){if(a>b)a=b;}\ntemplate<typename T>\nvoid chmax(T &a,T b){if(a<b)a=b;}\nvoid pmod(ll &a,ll b){a=(a+b)%MOD;}\nvoid pmod(ll &a,ll b,ll c){a=(b+c)%MOD;}\nvoid qmod(ll &a,ll b){a=(a*b)%MOD;}\nvoid qmod(ll &a,ll b,ll c){a=(b*c)%MOD;}\nll median(ll a,ll b, ll c){return a+b+c-max({a,b,c})-min({a,b,c});}\nvoid ans1(bool x){if(x) cout<<\"Yes\"<<endl;else cout<<\"No\"<<endl;}\nvoid ans2(bool x){if(x) cout<<\"YES\"<<endl;else cout<<\"NO\"<<endl;}\nvoid ans3(bool x){if(x) cout<<\"Yay!\"<<endl;else cout<<\":(\"<<endl;}\ntemplate<typename T1,typename T2>\nvoid ans(bool x,T1 y,T2 z){if(x)cout<<y<<endl;else cout<<z<<endl;}  \ntemplate<typename T>\nvoid debug(vector<vector<T>>v,ll h,ll w){for(ll i=0;i<h;i++)\n{cout<<v[i][0];for(ll j=1;j<w;j++)cout spa v[i][j];cout<<endl;}};\nvoid debug(vector<string>v,ll h,ll w){for(ll i=0;i<h;i++)\n{for(ll j=0;j<w;j++)cout<<v[i][j];cout<<endl;}};\ntemplate<typename T>\nvoid debug(vector<T>v,ll n){cout<<v[0];\nfor(ll i=1;i<n;i++)cout spa v[i];cout<<endl;};\ntemplate<typename T>\nvector<vector<T>>vec(ll x, ll y, T w){\n  vector<vector<T>>v(x,vector<T>(y,w));return v;}\nll gcd(ll x,ll y){ll r;while(y!=0&&(r=x%y)!=0){x=y;y=r;}return y==0?x:y;}\ntemplate<typename T>\nvoid emp(map<T,ll>&m, T x){m.emplace(x,0).first->second++;}\nvector<ll>dx={1,0,-1,0,1,1,-1,-1};\nvector<ll>dy={0,1,0,-1,1,-1,1,-1};\ntemplate<typename T>\nvector<T> make_v(size_t a,T b){return vector<T>(a,b);}\ntemplate<typename... Ts>\nauto make_v(size_t a,Ts... ts){\n  return vector<decltype(make_v(ts...))>(a,make_v(ts...));\n}\nusing Real = long double;\nusing Point = complex< Real >;\nconst Real EPS = 1e-9, PI = acos(-1);\n\ninline bool eq(Real a, Real b) { return fabs(b - a) < EPS; }\n\nPoint operator*(const Point &p, const Real &d) {\n  return Point(real(p) * d, imag(p) * d);\n}\n\nistream &operator>>(istream &is, Point &p) {\n  Real a, b;\n  is >> a >> b;\n  p = Point(a, b);\n  return is;\n}\n\nostream &operator<<(ostream &os, Point &p) {\n  os << fixed << setprecision(10) << p.real() << \" \" << p.imag();\n}\n\nPoint rotate(Real theta, const Point &p) {\n  return Point(cos(theta) * p.real() - sin(theta) * p.imag(), sin(theta) * p.real() + cos(theta) * p.imag());\n}\n\nReal radian_to_degree(Real r) {\n  return (r * 180.0 / PI);\n}\n\nReal degree_to_radian(Real d) {\n  return (d * PI / 180.0);\n}\n\nReal get_angle(const Point &a, const Point &b, const Point &c) {\n  const Point v(b - a), w(c - b);\n  Real alpha = atan2(v.imag(), v.real()), beta = atan2(w.imag(), w.real());\n  if(alpha > beta) swap(alpha, beta);\n  Real theta = (beta - alpha);\n  return min(theta, 2 * acos(-1) - theta);\n}\n\nnamespace std {\n  bool operator<(const Point &a, const Point &b) {\n    return a.real() != b.real() ? a.real() < b.real() : a.imag() < b.imag();\n  }\n}\n\n\nstruct Line {\n  Point a, b;\n\n  Line() = default;\n\n  Line(Point a, Point b) : a(a), b(b) {}\n\n  Line(Real A, Real B, Real C) // Ax + By = C\n  {\n    if(eq(A, 0)) a = Point(0, C / B), b = Point(1, C / B);\n    else if(eq(B, 0)) b = Point(C / A, 0), b = Point(C / A, 1);\n    else a = Point(0, C / B), b = Point(C / A, 0);\n  }\n\n  friend ostream &operator<<(ostream &os, Line &p) {\n    return os << p.a << \" to \" << p.b;\n  }\n\n  friend istream &operator>>(istream &is, Line &a) {\n    return is >> a.a >> a.b;\n  }\n};\n\nstruct Segment : Line {\n  Segment() = default;\n\n  Segment(Point a, Point b) : Line(a, b) {}\n};\n\nstruct Circle {\n  Point p;\n  Real r;\n\n  Circle() = default;\n\n  Circle(Point p, Real r) : p(p), r(r) {}\n};\n\nusing Points = vector< Point >;\nusing Polygon = vector< Point >;\nusing Segments = vector< Segment >;\nusing Lines = vector< Line >;\nusing Circles = vector< Circle >;\n\nReal cross(const Point &a, const Point &b) {\n  return real(a) * imag(b) - imag(a) * real(b);\n}\n\nReal dot(const Point &a, const Point &b) {\n  return real(a) * real(b) + imag(a) * imag(b);\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_1_C\n// 3点の位置関係を出力\nint ccw(const Point &a, Point b, Point c) {\n  b = b - a, c = c - a;\n  if(cross(b, c) > EPS) return +1;  // \"COUNTER_CLOCKWISE\"\n  if(cross(b, c) < -EPS) return -1; // \"CLOCKWISE\"\n  if(dot(b, c) < 0) return +2;      // \"ONLINE_BACK\"\n  if(norm(b) < norm(c)) return -2;  // \"ONLINE_FRONT\"\n  return 0;                         // \"ON_SEGMENT\"\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_A\n// 平行ならtrue\nbool parallel(const Line &a, const Line &b) {\n  return eq(cross(a.b - a.a, b.b - b.a), 0.0);\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_A\nbool orthogonal(const Line &a, const Line &b) {\n  return eq(dot(a.a - a.b, b.a - b.b), 0.0);\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_1_A\nPoint projection(const Line &l, const Point &p) {\n  double t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n  return l.a + (l.a - l.b) * t;\n}\n\nPoint projection(const Segment &l, const Point &p) {\n  double t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n  return l.a + (l.a - l.b) * t;\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_1_B\nPoint reflection(const Line &l, const Point &p) {\n  return p + (projection(l, p) - p) * 2.0;\n}\n\nbool intersect(const Line &l, const Point &p) {\n  return abs(ccw(l.a, l.b, p)) != 1;\n}\n\nbool intersect(const Line &l, const Line &m) {\n  return abs(cross(l.b - l.a, m.b - m.a)) > EPS || abs(cross(l.b - l.a, m.b - l.a)) < EPS;\n}\n\nbool intersect(const Segment &s, const Point &p) {\n  return ccw(s.a, s.b, p) == 0;\n}\n\nbool intersect(const Line &l, const Segment &s) {\n  return cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < EPS;\n}\n\nReal distance(const Line &l, const Point &p);\n\nbool intersect(const Circle &c, const Line &l) {\n  return distance(l, c.p) <= c.r + EPS;\n}\n\nbool intersect(const Circle &c, const Point &p) {\n  return abs(abs(p - c.p) - c.r) < EPS;\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_B\nbool intersect(const Segment &s, const Segment &t) {\n  return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 && ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nint intersect(const Circle &c, const Segment &l) {\n  if(norm(projection(l, c.p) - c.p) - c.r * c.r > EPS) return 0;\n  auto d1 = abs(c.p - l.a), d2 = abs(c.p - l.b);\n  if(d1 < c.r + EPS && d2 < c.r + EPS) return 0;\n  if(d1 < c.r - EPS && d2 > c.r + EPS || d1 > c.r + EPS && d2 < c.r - EPS) return 1;\n  const Point h = projection(l, c.p);\n  if(dot(l.a - h, l.b - h) < 0) return 2;\n  return 0;\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_7_A&lang=jp\nint intersect(Circle c1, Circle c2) {\n  if(c1.r < c2.r) swap(c1, c2);\n  Real d = abs(c1.p - c2.p);\n  if(c1.r + c2.r < d) return 4;\n  if(eq(c1.r + c2.r, d)) return 3;\n  if(c1.r - c2.r < d) return 2;\n  if(eq(c1.r - c2.r, d)) return 1;\n  return 0;\n}\n\nReal distance(const Point &a, const Point &b) {\n  return abs(a - b);\n}\n\nReal distance(const Line &l, const Point &p) {\n  return abs(p - projection(l, p));\n}\n\nReal distance(const Line &l, const Line &m) {\n  return intersect(l, m) ? 0 : distance(l, m.a);\n}\n\nReal distance(const Segment &s, const Point &p) {\n  Point r = projection(s, p);\n  if(intersect(s, r)) return abs(r - p);\n  return min(abs(s.a - p), abs(s.b - p));\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_D\nReal distance(const Segment &a, const Segment &b) {\n  if(intersect(a, b)) return 0;\n  return min({distance(a, b.a), distance(a, b.b), distance(b, a.a), distance(b, a.b)});\n}\n\nReal distance(const Line &l, const Segment &s) {\n  if(intersect(l, s)) return 0;\n  return min(distance(l, s.a), distance(l, s.b));\n}\n\nPoint crosspoint(const Line &l, const Line &m) {\n  Real A = cross(l.b - l.a, m.b - m.a);\n  Real B = cross(l.b - l.a, l.b - m.a);\n  if(eq(abs(A), 0.0) && eq(abs(B), 0.0)) return m.a;\n  return m.a + (m.b - m.a) * B / A;\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_C\nPoint crosspoint(const Segment &l, const Segment &m) {\n  return crosspoint(Line(l), Line(m));\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_7_D\npair< Point, Point > crosspoint(const Circle &c, const Line l) {\n  Point pr = projection(l, c.p);\n  Point e = (l.b - l.a) / abs(l.b - l.a);\n  if(eq(distance(l, c.p), c.r)) return {pr, pr};\n  double base = sqrt(c.r * c.r - norm(pr - c.p));\n  return {pr - e * base, pr + e * base};\n}\n\npair< Point, Point > crosspoint(const Circle &c, const Segment &l) {\n  Line aa = Line(l.a, l.b);\n  if(intersect(c, l) == 2) return crosspoint(c, aa);\n  auto ret = crosspoint(c, aa);\n  if(dot(l.a - ret.first, l.b - ret.first) < 0) ret.second = ret.first;\n  else ret.first = ret.second;\n  return ret;\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_7_E\npair< Point, Point > crosspoint(const Circle &c1, const Circle &c2) {\n  Real d = abs(c1.p - c2.p);\n  Real a = acos((c1.r * c1.r + d * d - c2.r * c2.r) / (2 * c1.r * d));\n  Real t = atan2(c2.p.imag() - c1.p.imag(), c2.p.real() - c1.p.real());\n  Point p1 = c1.p + Point(cos(t + a) * c1.r, sin(t + a) * c1.r);\n  Point p2 = c1.p + Point(cos(t - a) * c1.r, sin(t - a) * c1.r);\n  return {p1, p2};\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_7_F\npair< Point, Point > tangent(const Circle &c1, const Point &p2) {\n  return crosspoint(c1, Circle(p2, sqrt(norm(c1.p - p2) - c1.r * c1.r)));\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_7_G\nLines tangent(Circle c1, Circle c2) {\n  Lines ret;\n  if(c1.r < c2.r) swap(c1, c2);\n  Real g = norm(c1.p - c2.p);\n  if(eq(g, 0)) return ret;\n  Point u = (c2.p - c1.p) / sqrt(g);\n  Point v = rotate(PI * 0.5, u);\n  for(int s : {-1, 1}) {\n    Real h = (c1.r + s * c2.r) / sqrt(g);\n    if(eq(1 - h * h, 0)) {\n      ret.emplace_back(c1.p + u * c1.r, c1.p + (u + v) * c1.r);\n    } else if(1 - h * h > 0) {\n      Point uu = u * h, vv = v * sqrt(1 - h * h);\n      ret.emplace_back(c1.p + (uu + vv) * c1.r, c2.p - (uu + vv) * c2.r * s);\n      ret.emplace_back(c1.p + (uu - vv) * c1.r, c2.p - (uu - vv) * c2.r * s);\n    }\n  }\n  return ret;\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_3_B\nbool is_convex(const Polygon &p) {\n  int n = (int) p.size();\n  for(int i = 0; i < n; i++) {\n    if(ccw(p[(i + n - 1) % n], p[i], p[(i + 1) % n]) == -1) return false;\n  }\n  return true;\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_4_A\nPolygon convex_hull(Polygon &p) {\n  int n = (int) p.size(), k = 0;\n  if(n <= 2) return p;\n  sort(p.begin(), p.end());\n  vector< Point > ch(2 * n);\n  for(int i = 0; i < n; ch[k++] = p[i++]) {\n    while(k >= 2 && cross(ch[k - 1] - ch[k - 2], p[i] - ch[k - 1]) < 0) --k;\n  }\n  for(int i = n - 2, t = k + 1; i >= 0; ch[k++] = p[i--]) {\n    while(k >= t && cross(ch[k - 1] - ch[k - 2], p[i] - ch[k - 1]) < 0) --k;\n  }\n  ch.resize(k - 1);\n  return ch;\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_3_C\nenum {\n  OUT, ON, IN\n};\nint contains(const Polygon &Q, const Point &p) {\n  bool in = false;\n  for(int i = 0; i < Q.size(); i++) {\n    Point a = Q[i] - p, b = Q[(i + 1) % Q.size()] - p;\n    if(a.imag() > b.imag()) swap(a, b);\n    if(a.imag() <= 0 && 0 < b.imag() && cross(a, b) < 0) in = !in;\n    if(cross(a, b) == 0 && dot(a, b) <= 0) return ON;\n  }\n  return in ? IN : OUT;\n}\n\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1033\nvoid merge_segments(vector< Segment > &segs) {\n\n  auto merge_if_able = [](Segment &s1, const Segment &s2) {\n    if(abs(cross(s1.b - s1.a, s2.b - s2.a)) > EPS) return false;\n    if(ccw(s1.a, s2.a, s1.b) == 1 || ccw(s1.a, s2.a, s1.b) == -1) return false;\n    if(ccw(s1.a, s1.b, s2.a) == -2 || ccw(s2.a, s2.b, s1.a) == -2) return false;\n    s1 = Segment(min(s1.a, s2.a), max(s1.b, s2.b));\n    return true;\n  };\n\n  for(int i = 0; i < segs.size(); i++) {\n    if(segs[i].b < segs[i].a) swap(segs[i].a, segs[i].b);\n  }\n  for(int i = 0; i < segs.size(); i++) {\n    for(int j = i + 1; j < segs.size(); j++) {\n      if(merge_if_able(segs[i], segs[j])) {\n        segs[j--] = segs.back(), segs.pop_back();\n      }\n    }\n  }\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1033\nvector< vector< int > > segment_arrangement(vector< Segment > &segs, vector< Point > &ps) {\n  vector< vector< int > > g;\n  int N = (int) segs.size();\n  for(int i = 0; i < N; i++) {\n    ps.emplace_back(segs[i].a);\n    ps.emplace_back(segs[i].b);\n    for(int j = i + 1; j < N; j++) {\n      const Point p1 = segs[i].b - segs[i].a;\n      const Point p2 = segs[j].b - segs[j].a;\n      if(cross(p1, p2) == 0) continue;\n      if(intersect(segs[i], segs[j])) {\n        ps.emplace_back(crosspoint(segs[i], segs[j]));\n      }\n    }\n  }\n  sort(begin(ps), end(ps));\n  ps.erase(unique(begin(ps), end(ps)), end(ps));\n\n  int M = (int) ps.size();\n  g.resize(M);\n  for(int i = 0; i < N; i++) {\n    vector< int > vec;\n    for(int j = 0; j < M; j++) {\n      if(intersect(segs[i], ps[j])) {\n        vec.emplace_back(j);\n      }\n    }\n    for(int j = 1; j < vec.size(); j++) {\n      g[vec[j - 1]].push_back(vec[j]);\n      g[vec[j]].push_back(vec[j - 1]);\n    }\n  }\n  return (g);\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_4_C\nPolygon convex_cut(const Polygon &U, Line l) {\n  Polygon ret;\n  for(int i = 0; i < U.size(); i++) {\n    Point now = U[i], nxt = U[(i + 1) % U.size()];\n    if(ccw(l.a, l.b, now) != -1) ret.push_back(now);\n    if(ccw(l.a, l.b, now) * ccw(l.a, l.b, nxt) < 0) {\n      ret.push_back(crosspoint(Line(now, nxt), l));\n    }\n  }\n  return (ret);\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_3_A\nReal area2(const Polygon &p) {\n  Real A = 0;\n  for(int i = 0; i < p.size(); ++i) {\n    A += cross(p[i], p[(i + 1) % p.size()]);\n  }\n  return A;\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_7_H\nReal area2(const Polygon &p, const Circle &c) {\n  if(p.size() < 3) return 0.0;\n  function< Real(Circle, Point, Point) > cross_area = [&](const Circle &c, const Point &a, const Point &b) {\n    Point va = c.p - a, vb = c.p - b;\n    Real f = cross(va, vb), ret = 0.0;\n    if(eq(f, 0.0)) return ret;\n    if(max(abs(va), abs(vb)) < c.r + EPS) return f;\n    if(distance(Segment(a, b), c.p) > c.r - EPS) return c.r * c.r * arg(vb * conj(va));\n    auto u = crosspoint(c, Segment(a, b));\n    vector< Point > tot{a, u.first, u.second, b};\n    for(int i = 0; i + 1 < tot.size(); i++) {\n      ret += cross_area(c, tot[i], tot[i + 1]);\n    }\n    return ret;\n  };\n  Real A = 0;\n  for(int i = 0; i < p.size(); i++) {\n    A += cross_area(c, p[i], p[(i + 1) % p.size()]);\n  }\n  return A;\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_4_B\nReal convex_diameter(const Polygon &p) {\n  int N = (int) p.size();\n  int is = 0, js = 0;\n  for(int i = 1; i < N; i++) {\n    if(p[i].imag() > p[is].imag()) is = i;\n    if(p[i].imag() < p[js].imag()) js = i;\n  }\n  Real maxdis = norm(p[is] - p[js]);\n\n  int maxi, maxj, i, j;\n  i = maxi = is;\n  j = maxj = js;\n  do {\n    if(cross(p[(i + 1) % N] - p[i], p[(j + 1) % N] - p[j]) >= 0) {\n      j = (j + 1) % N;\n    } else {\n      i = (i + 1) % N;\n    }\n    if(norm(p[i] - p[j]) > maxdis) {\n      maxdis = norm(p[i] - p[j]);\n      maxi = i;\n      maxj = j;\n    }\n  } while(i != is || j != js);\n  return sqrt(maxdis);\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_5_A\nReal closest_pair(Points ps) {\n  if(ps.size() <= 1) throw (0);\n  sort(begin(ps), end(ps));\n\n  auto compare_y = [&](const Point &a, const Point &b) {\n    return imag(a) < imag(b);\n  };\n  vector< Point > beet(ps.size());\n  const Real INF = 1e18;\n\n  function< Real(int, int) > rec = [&](int left, int right) {\n    if(right - left <= 1) return INF;\n    int mid = (left + right) >> 1;\n    auto x = real(ps[mid]);\n    auto ret = min(rec(left, mid), rec(mid, right));\n    inplace_merge(begin(ps) + left, begin(ps) + mid, begin(ps) + right, compare_y);\n    int ptr = 0;\n    for(int i = left; i < right; i++) {\n      if(abs(real(ps[i]) - x) >= ret) continue;\n      for(int j = 0; j < ptr; j++) {\n        auto luz = ps[i] - beet[ptr - j - 1];\n        if(imag(luz) >= ret) break;\n        ret = min(ret, abs(luz));\n      }\n      beet[ptr++] = ps[i];\n    }\n    return ret;\n  };\n  return rec(0, (int) ps.size());\n};\nint main(){\n  cin.tie(NULL);\n  ios_base::sync_with_stdio(false);\n  ll res=0,res1=INF,res2=-INF,buf=0;\n  bool judge = true;\n  ll n;cin>>n;\n  vector<Point>x(n);\n  ld ret=1e18;\n  vector<ll>a(n);\n  rep(i,0,n)a[i]=i;\n  Point k(-1,0);\n  Point o(0,0);\n  rep(i,0,n)cin>>x[i];\n  ld eps=1e9;\n  do{\n    //debug(a,n);\n    ld sumbuf=get_angle(k,o,x[a[0]]);\n    sumbuf+=get_angle(o,x[a[0]],x[a[1]]);\n    rep(i,0,n-2){\n      sumbuf+=get_angle(x[a[i]],x[a[i+1]],x[a[i+2]]);\n    }\n    sumbuf+=get_angle(x[a[n-2]],x[a[n-1]],o);\n    //cout<<radian_to_degree(sumbuf)<<endl;\n    chmin(ret,radian_to_degree(sumbuf));\n  }while(next_permutation(ALL(a)));\n  cout lfs ret<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// #define _GLIBCXX_DEBUG // for STL debug (optional)\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\n#include <bitset>\nusing namespace std;\nusing ll = long long int;\nusing int64 = long long int;\n \ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n \nconst int INF = 1001001001;\nconst ll LONGINF = 1001001001001001LL;\nconst ll MOD = 1000000007LL;\n \nint main() {\n    int N; cin >> N;\n    vector<int> X(N), Y(N);\n\n    for(int i=0; i<N; i++) {\n        cin >> X[i] >> Y[i];\n    }\n\n    vector<int> perm(N);\n    iota(perm.begin(), perm.end(), 0);\n\n    double PI = acos(-1);\n    double ans = LONGINF;\n    do {\n        vector< pair<int, int> > points;\n        points.emplace_back(0, 0);\n        for(auto e : perm) points.emplace_back(X[e], Y[e]);\n        points.emplace_back(0, 0);\n\n        double theta = 0, sum = 0;\n        for(int i=0; i<=N; i++) {\n            int dx = points[i+1].first - points[i].first;\n            int dy = points[i+1].second - points[i].second;\n            // fprintf(stderr, \"dx = %d, dy = %d\\n\", dx, dy);\n\n            double n_theta = atan2(dy, dx);\n\n            double rot = min(abs(theta - n_theta), 2*PI - abs(theta - n_theta));\n            sum += rot / PI * 180.0;\n            // fprintf(stderr, \"rot = %.12f\\n\", rot / PI * 180);\n            theta = n_theta;\n        }\n        ans = min(ans, sum);\n    }while(next_permutation(perm.begin(), perm.end()));\n\n    printf(\"%.12f\\n\", ans);\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// includes {{{\n#include<iostream>\n#include<iomanip>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<map>\n#include<set>\n#include<tuple>\n#include<cmath>\n#include<random>\n#include<cassert>\n#include<bitset>\n#include<cstdlib>\n// #include<deque>\n// #include<multiset>\n// #include<cstring>\n// #include<bits/stdc++.h>\n// }}}\nusing namespace std;\nusing ll = long long;\n\nconstexpr double PI = acos(-1);\n\nint main() {\n  std::ios::sync_with_stdio(false), std::cin.tie(0);\n  int n;\n  cin >> n;\n  vector<int> x(n + 1), y(n + 1);\n  for(int i = 0; i < n; i++) cin >> x[i] >> y[i];\n  vector<int> p(n);\n  iota(begin(p), end(p), 0);\n  double ans = 1e100;\n  do{\n    double sum = 0;\n    double now = atan2(0, 1);\n    ll X = 0, Y = 0;\n    p.push_back(n);\n    for(auto i : p) {\n      double t = atan2(y[i] - Y, x[i] - X);\n      sum += min({abs(now - t), abs(t - now), abs(now - t + 2 * PI), abs(t - now + 2 * PI), abs(now - t - 2 * PI), abs(t - now - 2 * PI)});\n      now = t;\n      X = x[i], Y = y[i];\n    }\n    p.pop_back();\n    ans = min(ans, sum);\n  } while(next_permutation(begin(p), end(p)));\n  cout << fixed << setprecision(20);\n  cout << ans / 2 / PI * 360 << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define ll long long\n#define ld long double\n\n// 2つのベクトル(x1,y1),(x2,y2)のなす角を求める.\nld angle(int x1, int y1, int x2, int y2) {\n\tll inner_product = (ll)x1 * x2 + (ll)y1 * y2;\n\tld abs1 = (ld)pow((ll)x1 * x1 + (ll)y1 * y1, 0.5);\n\tld abs2 = (ld)pow((ll)x2 * x2 + (ll)y2 * y2, 0.5);\n\tld cos_theta = inner_product / (abs1 * abs2);\n\treturn 180 * acos(cos_theta) / M_PI;\n}\n\nsigned main() {\n\tint n; cin >> n;\n\tvector<pair<int, int>> xy(n);\n\tfor (int i = 0; i < n; ++i)\n\t\tcin >> xy[i].first >> xy[i].second;\n\n\tsort(xy.begin(), xy.end());\n\n\tld ans = ((ld)360.0) * n;\n\n\twhile (next_permutation(xy.begin(), xy.end())) {\n\t\tld tmp = (ld)0.0;\n\t\tint x, y; x = y = 0; // 現在の座標\n\t\tint dirx = 1, diry = 0;\n\t\tfor (auto pi : xy) {\n\t\t\ttmp += angle(dirx, diry, pi.first - x, pi.second - y);\n\t\t\tdirx = pi.first - x;\n\t\t\tdiry = pi.second - y;\n\t\t\tx = pi.first;\n\t\t\ty = pi.second;\n\t\t}\n\t\ttmp += angle(dirx, diry, -x, -y);\n\t\tans = min(ans, tmp);\n\t}\n\n\tcout << setprecision(15) << ans << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n\ntemplate<typename F>\nstruct FixPoint : F{\n  FixPoint(F&& f):F(forward<F>(f)){}\n  template<typename... Args>\n  decltype(auto) operator()(Args&&... args) const{\n    return F::operator()(*this,forward<Args>(args)...);\n  }\n};\ntemplate<typename F>\ninline decltype(auto) MFP(F&& f){\n  return FixPoint<F>{forward<F>(f)};\n}\n\n\nstruct FastIO{\n  FastIO(){\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n  }\n}fastio_beet;\n\n\nstruct Precision{\n  Precision(){\n    cout<<fixed<<setprecision(12);\n  }\n}precision_beet;\n\n//INSERT ABOVE HERE\n\nusing D = double;\nconst D PI = asin(1)*2;\nD dot(D x1,D y1,D x2,D y2){\n  return x1*x2+y1*y2;\n}\n\nsigned main(){\n  int n;\n  cin>>n;\n  vector<D> xs(n),ys(n);\n  for(int i=0;i<n;i++) cin>>xs[i]>>ys[i];\n  xs.emplace_back(0);\n  ys.emplace_back(0);\n  xs.emplace_back(-1);\n  ys.emplace_back(0);\n\n  vector<int> vs(n+3,n),used(n,0);\n  vs[0]=n+1;\n\n  D ans=1e9;\n  auto check=\n    [&](){\n      D res=0;\n      for(int i=0;i+2<n+3;i++){\n        D dx=xs[vs[i+1]]-xs[vs[i+0]],dy=ys[vs[i+1]]-ys[vs[i+0]];\n        D nx=xs[vs[i+2]]-xs[vs[i+1]],ny=ys[vs[i+2]]-ys[vs[i+1]];\n        D th=acos(min(1.0,max(dot(dx,dy,nx,ny)/hypot(dx,dy)/hypot(nx,ny),\n                          -1.0)));\n        //cout<<dx<<\" \"<<dy<<\":\"<<nx<<\" \"<<ny<<\":\"<<th<<endl;\n        res+=abs(th)/PI*180;\n      }\n      chmin(ans,res);\n    };\n\n  MFP([&](auto dfs,int d)->void{\n        if(d==n+2){\n          check();\n          return;\n        }\n        for(int i=0;i<n;i++){\n          if(used[i]) continue;\n          used[i]=1;\n          vs[d]=i;\n          dfs(d+1);\n          used[i]=0;\n        }\n      })(2);\n\n  cout<<ans<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#define _overload3(_1,_2,_3,name,...) name\n#define _rep(i,n) repi(i,0,n)\n#define repi(i,a,b) for(int i=int(a),i##_len=(b);i<i##_len;++i)\n#define MSVC_UNKO(x) x\n#define rep(...) MSVC_UNKO(_overload3(__VA_ARGS__,repi,_rep,_rep)(__VA_ARGS__))\n#define all(c) c.begin(),c.end()\n#define mp make_pair\n#define write(x) cout<<(x)<<'\\n'\nusing namespace std; typedef long long ll; template<class T>using vv = vector<vector<T>>;\ntemplate<class T>auto vvec(int n, int m, T v) { return vv<T>(n, vector<T>(m, v)); }\ntemplate<class T, class U>bool chmax(T& a, U&& b) { return a < b ? a = b, 1 : 0; }\ntemplate<class T, class U>bool chmin(T& a, U&& b) { return b < a ? a = b, 1 : 0; }\nconstexpr int INF = 1 << 29, MOD = int(1e9) + 7; constexpr ll LINF = 1LL << 60;\nstruct aaa { aaa() { cin.tie(0); ios::sync_with_stdio(0); cout << fixed << setprecision(10); }; }aaaa;\n\nconst double PI = 3.14159265359;\n\nint N;\nvector<int> Y, X;\n\ndouble sumDeg(const vector<int>& order) {\n    int y = 0, x = 0;\n    double deg = 0.0, sum = 0.0;\n\n    for (int o : order) {\n        double nextDeg = 0.0;\n\n        if (x == X[o]) {\n            if (y < Y[o]) {\n                nextDeg = PI / 2;\n            }\n            else {\n                nextDeg = 3 * PI / 2;\n            }\n        }\n        else {\n            nextDeg = X[o] > x ? atan((double)(Y[o] - y) / (X[o] - x)) : PI + atan((double)(Y[o] - y) / (X[o] - x));\n            if (nextDeg > 2 * PI) nextDeg - 2 * PI;\n        }\n\n        sum += nextDeg > deg ?\n            min(nextDeg - deg, 2 * PI - (nextDeg - deg)) :\n            min(deg - nextDeg, 2 * PI - (deg - nextDeg));\n\n        deg = nextDeg;\n        y = Y[o];\n        x = X[o];\n    }\n\n    return 180 * sum / PI;\n}\n\nint main() {\n    cin >> N;\n    Y.resize(N);\n    X.resize(N);\n    rep(i, N) cin >> X[i] >> Y[i];\n    Y.push_back(0);\n    X.push_back(0);\n\n    vector<int> order(N + 1);\n    iota(all(order), 0);\n\n    double ans = 1e9;\n    do {\n        ans = min(ans, sumDeg(order));\n    } while (next_permutation(order.begin(), order.end() - 1));\n\n    write(ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <utility>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <list>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n\nusing namespace std;\n\n#define PI acos(-1.0)\n\nint main() {\n\tint n; cin >> n;\n\tvector<pair<int, int> > xy(n);\n\tfor (int i = 0; i < n; ++i) cin >> xy[i].first >> xy[i].second;\n\tsort(xy.begin(), xy.end());\n\tdouble alpha = 0, ans = 1e18;\n\tdo {\n\t\talpha = atan2(xy[0].second, xy[0].first);\n\t\tif (alpha < 0) alpha += 2 * PI;\n\t\tdouble tmp = min(abs(alpha), 2 * PI - abs(alpha));\n\t\tfor (int i = 1; i < n; ++i) {\n\t\t\tdouble t = atan2(xy[i].second - xy[i - 1].second, xy[i].first - xy[i - 1].first);\n\t\t\tif (t < 0) t += 2 * PI;\n\t\t\ttmp += min(abs(alpha - t),2*PI- abs(t - alpha));\n\t\t\talpha = t;\n\t\t}\n\t\tdouble t = atan2(-xy[n - 1].second, -xy[n - 1].first);\n\t\tif (t < 0) t += 2 * PI;\n\t\ttmp += min(abs(alpha - t), 2 * PI - abs(t - alpha));\n\t\tans = min(ans, tmp);\n\t} while (next_permutation(xy.begin(), xy.end()));\n\tprintf(\"%.10f\\n\", ans * 180.0 / PI);\n\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*** author: yuji9511 ***/\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> lpair;\nconst ll MOD = 1e9 + 7;\nconst ll INF = 1e18;\n#define rep(i,m,n) for(ll i = (m); i < (n); i++)\n#define rrep(i,m,n) for(ll i = (m); i >= (n); i--)\n#define print(x) cout << (x) << endl;\n#define print2(x,y) cout << (x) << \" \" << (y) << endl;\n#define printa(x,n) for(ll i = 0; i < n; i++){ cout << (x[i]) << \" \\n\"[i==n-1];};\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tll N;\n\tcin >> N;\n\tdouble X[10], Y[10];\n\trep(i,0,N) cin >> X[i] >> Y[i];\n\tvector<ll> v(N);\n\tiota(v.begin(), v.end(), 0);\n\tdouble ans = INF;\n\tconst double PI = atan2(0, -1);\n\tdo{\n\t\tdouble res = 0.0;\n\t\tdouble vy = Y[v[0]], vx = X[v[0]];\n\t\tdouble a1 = atan2(0.0, 1.0);\n\t\tdouble a2 = atan2(vy, vx);\n\t\tdouble diff = abs(a1 - a2);\n\t\t// print(diff);\n\t\tif(diff > PI) diff = abs(diff - 2*PI);\n\t\tres += diff * 180.0 / PI;\n\t\t// print(res);\n\t\trep(i,0,N-1){\n\t\t\tdouble vy2 = Y[v[i+1]] - Y[v[i]];\n\t\t\tdouble vx2 = X[v[i+1]] - X[v[i]];\n\t\t\ta1 = atan2(vy, vx);\n\t\t\ta2 = atan2(vy2, vx2);\n\t\t\tdiff = abs(a1 - a2);\n\t\t\tif(diff > PI) diff = abs(diff - 2*PI);\n\t\t\tres += diff * 180.0 / PI;\n\t\t\tvy = vy2;\n\t\t\tvx = vx2;\n\t\t}\n\n\t\tdouble vy2 = 0 - Y[v[N-1]];\n\t\tdouble vx2 = 0 - X[v[N-1]];\n\t\ta1 = atan2(vy, vx);\n\t\ta2 = atan2(vy2, vx2);\n\t\tdiff = abs(a1 - a2);\n\t\tif(diff > PI) diff = abs(diff - 2*PI);\n\t\tres += diff * 180.0 / PI;\n\n\t\tans = min(ans, res);\n\n\n\t}while(next_permutation(v.begin(), v.end()));\n\tcout << setprecision(10) << ans << endl;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n\n                   _ooOoo_\n                  o8888888o\n                  88\" . \"88\n                  (| -_- |)\n                  O\\  =  /O\n               ____/`---'\\____\n             .'  \\\\|     |//  `.\n            /  \\\\|||  :  |||//  \\\n           /  _||||| -:- |||||-  \\\n           |   | \\\\\\  -  /// |   |\n           | \\_|  ''\\---/''  |   |\n           \\  .-\\__  `-`  ___/-. /\n         ___`. .'  /--.--\\  `. . __\n      .\"\" '<  `.___\\_<|>_/___.'  >'\"\".\n     | | :  `- \\`.;`\\ _ /`;.`/ - ` : | |\n     \\  \\ `-.   \\_ __\\ /__ _/   .-` /  /\n======`-.____`-.___\\_____/___.-`____.-'======\n                   `=---='\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n                    prayer\n*/\n\n// g++ -std=c++11 a.cpp\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<utility>\n#include<cmath>\n#include<random>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#include<typeinfo>\n#define loop(i,a,b) for(long long i=a;i<b;i++)\n#define rep(i,a) loop(i,0,a)\n#define FOR(i,a) for(auto i:a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n#define show1d(v) {rep(_,v.size())cout<<\" \"<<v[_];cout<<endl;}\n#define show2d(v) {rep(__,v.size())show1d(v[__]);}\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\n#define int ll\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n#define mt make_tuple\ntypedef tuple<int,int,int,int> tp;\ntypedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\nconst double PI=acos(-1);\nconst double EPS=1e-9;\nDef inf = sizeof(Def) == sizeof(long long) ? 2e18 : 1e9+10;\n#define yes cout<<\"Yes\\n\"\n#define no cout<<\"No\\n\"\n\ntemplate< typename T >\nistream &operator>>(istream &is, vector< T > &v) {\n  for(T &in : v) is >> in;\n  return is;\n}\n\ndouble f(int a,int b,int c,int d){\n    double t=a*d-b*c;\n    t/=sqrt(a*a+b*b);\n    t/=sqrt(c*c+d*d);\n    t=asin(t);\n    t*=180/acos(-1);\n    t=abs(t);\n    // cout<<a<<\" \"<<b<<\" \"<<c<<\" \"<<d<<\" \"<<t<<endl;\n    if(a*c+b*d<0)t=180-t;\n    return t;\n}\nsigned main(){\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n    int n;\n    cin>>n;\n    double out=inf;\n    vvi in(n+2,vi(2));\n    rep(i,n)rep(j,2)cin>>in[i+1][j];\n    vi t(n+2);\n    rep(i,n+2)t[i]=i;\n    do{\n        double s=0;\n        s+=f(1,0,in[t[1]][0],in[t[1]][1]);\n        rep(i,n){\n            int a=in[t[i+1]][0]-in[t[i+0]][0];\n            int b=in[t[i+1]][1]-in[t[i+0]][1];\n            int c=in[t[i+2]][0]-in[t[i+1]][0];\n            int d=in[t[i+2]][1]-in[t[i+1]][1];\n            s+=f(a,b,c,d);\n        }\n        // cout<<s<<endl;\n        cmin(out,s);\n    }while(next_permutation(t.begin()+1,t.begin()+n+1));\n    cout<<shosu(9)<<out<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nusing int64 = long long;\nconst int mod = 1e9 + 7;\n\nconst int64 infll = (1LL << 62) - 1;\nconst int inf = (1 << 30) - 1;\n\nstruct IoSetup {\n  IoSetup() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n    cerr << fixed << setprecision(10);\n  }\n} iosetup;\n\n\ntemplate< typename T1, typename T2 >\nostream &operator<<(ostream &os, const pair< T1, T2 > &p) {\n  os << p.first << \" \" << p.second;\n  return os;\n}\n\ntemplate< typename T1, typename T2 >\nistream &operator>>(istream &is, pair< T1, T2 > &p) {\n  is >> p.first >> p.second;\n  return is;\n}\n\ntemplate< typename T >\nostream &operator<<(ostream &os, const vector< T > &v) {\n  for(int i = 0; i < (int) v.size(); i++) {\n    os << v[i] << (i + 1 != v.size() ? \" \" : \"\");\n  }\n  return os;\n}\n\ntemplate< typename T >\nistream &operator>>(istream &is, vector< T > &v) {\n  for(T &in : v) is >> in;\n  return is;\n}\n\ntemplate< typename T1, typename T2 >\ninline bool chmax(T1 &a, T2 b) { return a < b && (a = b, true); }\n\ntemplate< typename T1, typename T2 >\ninline bool chmin(T1 &a, T2 b) { return a > b && (a = b, true); }\n\ntemplate< typename T = int64 >\nvector< T > make_v(size_t a) {\n  return vector< T >(a);\n}\n\ntemplate< typename T, typename... Ts >\nauto make_v(size_t a, Ts... ts) {\n  return vector< decltype(make_v< T >(ts...)) >(a, make_v< T >(ts...));\n}\n\ntemplate< typename T, typename V >\ntypename enable_if< is_class< T >::value == 0 >::type fill_v(T &t, const V &v) {\n  t = v;\n}\n\ntemplate< typename T, typename V >\ntypename enable_if< is_class< T >::value != 0 >::type fill_v(T &t, const V &v) {\n  for(auto &e : t) fill_v(e, v);\n}\n\ntemplate< typename F >\nstruct FixPoint : F {\n  FixPoint(F &&f) : F(forward< F >(f)) {}\n\n  template< typename... Args >\n  decltype(auto) operator()(Args &&... args) const {\n    return F::operator()(*this, forward< Args >(args)...);\n  }\n};\n\ntemplate< typename F >\ninline decltype(auto) MFP(F &&f) {\n  return FixPoint< F >{forward< F >(f)};\n}\n\nusing Real = double;\nusing Point = complex< Real >;\nconst Real EPS = 1e-8, PI = acos(-1);\n\ninline bool eq(Real a, Real b) { return fabs(b - a) < EPS; }\n\nPoint operator*(const Point &p, const Real &d) {\n  return Point(real(p) * d, imag(p) * d);\n}\n\nistream &operator>>(istream &is, Point &p) {\n  Real a, b;\n  is >> a >> b;\n  p = Point(a, b);\n  return is;\n}\n\nostream &operator<<(ostream &os, Point &p) {\n  os << fixed << setprecision(10) << p.real() << \" \" << p.imag();\n}\n\n// 点 p を反時計回りに theta 回転\nPoint rotate(Real theta, const Point &p) {\n  return Point(cos(theta) * p.real() - sin(theta) * p.imag(), sin(theta) * p.real() + cos(theta) * p.imag());\n}\n\nReal radian_to_degree(Real r) {\n  return (r * 180.0 / PI);\n}\n\nReal degree_to_radian(Real d) {\n  return (d * PI / 180.0);\n}\n\n// a-b-c の角度のうち小さい方を返す\nReal get_angle(const Point &a, const Point &b, const Point &c) {\n  const Point v(b - a), w(c - b);\n  Real alpha = atan2(v.imag(), v.real()), beta = atan2(w.imag(), w.real());\n  if(alpha > beta) swap(alpha, beta);\n  Real theta = (beta - alpha);\n  return min(theta, 2 * acos(-1) - theta);\n}\n\nnamespace std {\n  bool operator<(const Point &a, const Point &b) {\n    return a.real() != b.real() ? a.real() < b.real() : a.imag() < b.imag();\n  }\n}\n\n\nstruct Line {\n  Point a, b;\n\n  Line() = default;\n\n  Line(Point a, Point b) : a(a), b(b) {}\n\n  Line(Real A, Real B, Real C) // Ax + By = C\n  {\n    if(eq(A, 0)) a = Point(0, C / B), b = Point(1, C / B);\n    else if(eq(B, 0)) b = Point(C / A, 0), b = Point(C / A, 1);\n    else a = Point(0, C / B), b = Point(C / A, 0);\n  }\n\n  friend ostream &operator<<(ostream &os, Line &p) {\n    return os << p.a << \" to \" << p.b;\n  }\n\n  friend istream &operator>>(istream &is, Line &a) {\n    return is >> a.a >> a.b;\n  }\n};\n\nstruct Segment : Line {\n  Segment() = default;\n\n  Segment(Point a, Point b) : Line(a, b) {}\n};\n\nstruct Circle {\n  Point p;\n  Real r;\n\n  Circle() = default;\n\n  Circle(Point p, Real r) : p(p), r(r) {}\n};\n\nusing Points = vector< Point >;\nusing Polygon = vector< Point >;\nusing Segments = vector< Segment >;\nusing Lines = vector< Line >;\nusing Circles = vector< Circle >;\n\nReal cross(const Point &a, const Point &b) {\n  return real(a) * imag(b) - imag(a) * real(b);\n}\n\nReal dot(const Point &a, const Point &b) {\n  return real(a) * real(b) + imag(a) * imag(b);\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_1_C\n// 点の回転方向\nint ccw(const Point &a, Point b, Point c) {\n  b = b - a, c = c - a;\n  if(cross(b, c) > EPS) return +1;  // \"COUNTER_CLOCKWISE\"\n  if(cross(b, c) < -EPS) return -1; // \"CLOCKWISE\"\n  if(dot(b, c) < 0) return +2;      // \"ONLINE_BACK\"\n  if(norm(b) < norm(c)) return -2;  // \"ONLINE_FRONT\"\n  return 0;                         // \"ON_SEGMENT\"\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_A\n// 平行判定\nbool parallel(const Line &a, const Line &b) {\n  return eq(cross(a.b - a.a, b.b - b.a), 0.0);\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_A\n// 垂直判定\nbool orthogonal(const Line &a, const Line &b) {\n  return eq(dot(a.a - a.b, b.a - b.b), 0.0);\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_1_A\n// 射影\n// 直線 l に p から垂線を引いた交点を求める\nPoint projection(const Line &l, const Point &p) {\n  double t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n  return l.a + (l.a - l.b) * t;\n}\n\nPoint projection(const Segment &l, const Point &p) {\n  double t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n  return l.a + (l.a - l.b) * t;\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_1_B\n// 反射\n// 直線 l を対称軸として点 p  と線対称にある点を求める\nPoint reflection(const Line &l, const Point &p) {\n  return p + (projection(l, p) - p) * 2.0;\n}\n\nbool intersect(const Line &l, const Point &p) {\n  return abs(ccw(l.a, l.b, p)) != 1;\n}\n\nbool intersect(const Line &l, const Line &m) {\n  return abs(cross(l.b - l.a, m.b - m.a)) > EPS || abs(cross(l.b - l.a, m.b - l.a)) < EPS;\n}\n\nbool intersect(const Segment &s, const Point &p) {\n  return ccw(s.a, s.b, p) == 0;\n}\n\nbool intersect(const Line &l, const Segment &s) {\n  return cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < EPS;\n}\n\nReal distance(const Line &l, const Point &p);\n\nbool intersect(const Circle &c, const Line &l) {\n  return distance(l, c.p) <= c.r + EPS;\n}\n\nbool intersect(const Circle &c, const Point &p) {\n  return abs(abs(p - c.p) - c.r) < EPS;\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_B\nbool intersect(const Segment &s, const Segment &t) {\n  return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 && ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nint intersect(const Circle &c, const Segment &l) {\n  if(norm(projection(l, c.p) - c.p) - c.r * c.r > EPS) return 0;\n  auto d1 = abs(c.p - l.a), d2 = abs(c.p - l.b);\n  if(d1 < c.r + EPS && d2 < c.r + EPS) return 0;\n  if(d1 < c.r - EPS && d2 > c.r + EPS || d1 > c.r + EPS && d2 < c.r - EPS) return 1;\n  const Point h = projection(l, c.p);\n  if(dot(l.a - h, l.b - h) < 0) return 2;\n  return 0;\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_7_A&lang=jp\nint intersect(Circle c1, Circle c2) {\n  if(c1.r < c2.r) swap(c1, c2);\n  Real d = abs(c1.p - c2.p);\n  if(c1.r + c2.r < d) return 4;\n  if(eq(c1.r + c2.r, d)) return 3;\n  if(c1.r - c2.r < d) return 2;\n  if(eq(c1.r - c2.r, d)) return 1;\n  return 0;\n}\n\nReal distance(const Point &a, const Point &b) {\n  return abs(a - b);\n}\n\nReal distance(const Line &l, const Point &p) {\n  return abs(p - projection(l, p));\n}\n\nReal distance(const Line &l, const Line &m) {\n  return intersect(l, m) ? 0 : distance(l, m.a);\n}\n\nReal distance(const Segment &s, const Point &p) {\n  Point r = projection(s, p);\n  if(intersect(s, r)) return abs(r - p);\n  return min(abs(s.a - p), abs(s.b - p));\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_D\nReal distance(const Segment &a, const Segment &b) {\n  if(intersect(a, b)) return 0;\n  return min({distance(a, b.a), distance(a, b.b), distance(b, a.a), distance(b, a.b)});\n}\n\nReal distance(const Line &l, const Segment &s) {\n  if(intersect(l, s)) return 0;\n  return min(distance(l, s.a), distance(l, s.b));\n}\n\nPoint crosspoint(const Line &l, const Line &m) {\n  Real A = cross(l.b - l.a, m.b - m.a);\n  Real B = cross(l.b - l.a, l.b - m.a);\n  if(eq(abs(A), 0.0) && eq(abs(B), 0.0)) return m.a;\n  return m.a + (m.b - m.a) * B / A;\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_C\nPoint crosspoint(const Segment &l, const Segment &m) {\n  return crosspoint(Line(l), Line(m));\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_7_D\npair< Point, Point > crosspoint(const Circle &c, const Line l) {\n  Point pr = projection(l, c.p);\n  Point e = (l.b - l.a) / abs(l.b - l.a);\n  if(eq(distance(l, c.p), c.r)) return {pr, pr};\n  double base = sqrt(c.r * c.r - norm(pr - c.p));\n  return {pr - e * base, pr + e * base};\n}\n\npair< Point, Point > crosspoint(const Circle &c, const Segment &l) {\n  Line aa = Line(l.a, l.b);\n  if(intersect(c, l) == 2) return crosspoint(c, aa);\n  auto ret = crosspoint(c, aa);\n  if(dot(l.a - ret.first, l.b - ret.first) < 0) ret.second = ret.first;\n  else ret.first = ret.second;\n  return ret;\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_7_E\npair< Point, Point > crosspoint(const Circle &c1, const Circle &c2) {\n  Real d = abs(c1.p - c2.p);\n  Real a = acos((c1.r * c1.r + d * d - c2.r * c2.r) / (2 * c1.r * d));\n  Real t = atan2(c2.p.imag() - c1.p.imag(), c2.p.real() - c1.p.real());\n  Point p1 = c1.p + Point(cos(t + a) * c1.r, sin(t + a) * c1.r);\n  Point p2 = c1.p + Point(cos(t - a) * c1.r, sin(t - a) * c1.r);\n  return {p1, p2};\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_7_F\n// 点 p を通る円 c の接線\npair< Point, Point > tangent(const Circle &c1, const Point &p2) {\n  return crosspoint(c1, Circle(p2, sqrt(norm(c1.p - p2) - c1.r * c1.r)));\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_7_G\n// 円 c1, c2 の共通接線\nLines tangent(Circle c1, Circle c2) {\n  Lines ret;\n  if(c1.r < c2.r) swap(c1, c2);\n  Real g = norm(c1.p - c2.p);\n  if(eq(g, 0)) return ret;\n  Point u = (c2.p - c1.p) / sqrt(g);\n  Point v = rotate(PI * 0.5, u);\n  for(int s : {-1, 1}) {\n    Real h = (c1.r + s * c2.r) / sqrt(g);\n    if(eq(1 - h * h, 0)) {\n      ret.emplace_back(c1.p + u * c1.r, c1.p + (u + v) * c1.r);\n    } else if(1 - h * h > 0) {\n      Point uu = u * h, vv = v * sqrt(1 - h * h);\n      ret.emplace_back(c1.p + (uu + vv) * c1.r, c2.p - (uu + vv) * c2.r * s);\n      ret.emplace_back(c1.p + (uu - vv) * c1.r, c2.p - (uu - vv) * c2.r * s);\n    }\n  }\n  return ret;\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_3_B\n// 凸性判定\nbool is_convex(const Polygon &p) {\n  int n = (int) p.size();\n  for(int i = 0; i < n; i++) {\n    if(ccw(p[(i + n - 1) % n], p[i], p[(i + 1) % n]) == -1) return false;\n  }\n  return true;\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_4_A\n// 凸包\nPolygon convex_hull(Polygon &p) {\n  int n = (int) p.size(), k = 0;\n  if(n <= 2) return p;\n  sort(p.begin(), p.end());\n  vector< Point > ch(2 * n);\n  for(int i = 0; i < n; ch[k++] = p[i++]) {\n    while(k >= 2 && cross(ch[k - 1] - ch[k - 2], p[i] - ch[k - 1]) < EPS) --k;\n  }\n  for(int i = n - 2, t = k + 1; i >= 0; ch[k++] = p[i--]) {\n    while(k >= t && cross(ch[k - 1] - ch[k - 2], p[i] - ch[k - 1]) < EPS) --k;\n  }\n  ch.resize(k - 1);\n  return ch;\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_3_C\n// 多角形と点の包含判定\nenum {\n  OUT, ON, IN\n};\n\nint contains(const Polygon &Q, const Point &p) {\n  bool in = false;\n  for(int i = 0; i < Q.size(); i++) {\n    Point a = Q[i] - p, b = Q[(i + 1) % Q.size()] - p;\n    if(a.imag() > b.imag()) swap(a, b);\n    if(a.imag() <= 0 && 0 < b.imag() && cross(a, b) < 0) in = !in;\n    if(cross(a, b) == 0 && dot(a, b) <= 0) return ON;\n  }\n  return in ? IN : OUT;\n}\n\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1033\n// 線分の重複除去\nvoid merge_segments(vector< Segment > &segs) {\n\n  auto merge_if_able = [](Segment &s1, const Segment &s2) {\n    if(abs(cross(s1.b - s1.a, s2.b - s2.a)) > EPS) return false;\n    if(ccw(s1.a, s2.a, s1.b) == 1 || ccw(s1.a, s2.a, s1.b) == -1) return false;\n    if(ccw(s1.a, s1.b, s2.a) == -2 || ccw(s2.a, s2.b, s1.a) == -2) return false;\n    s1 = Segment(min(s1.a, s2.a), max(s1.b, s2.b));\n    return true;\n  };\n\n  for(int i = 0; i < segs.size(); i++) {\n    if(segs[i].b < segs[i].a) swap(segs[i].a, segs[i].b);\n  }\n  for(int i = 0; i < segs.size(); i++) {\n    for(int j = i + 1; j < segs.size(); j++) {\n      if(merge_if_able(segs[i], segs[j])) {\n        segs[j--] = segs.back(), segs.pop_back();\n      }\n    }\n  }\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1033\n// 線分アレンジメント\n// 任意の2線分の交点を頂点としたグラフを構築する\nvector< vector< int > > segment_arrangement(vector< Segment > &segs, vector< Point > &ps) {\n  vector< vector< int > > g;\n  int N = (int) segs.size();\n  for(int i = 0; i < N; i++) {\n    ps.emplace_back(segs[i].a);\n    ps.emplace_back(segs[i].b);\n    for(int j = i + 1; j < N; j++) {\n      const Point p1 = segs[i].b - segs[i].a;\n      const Point p2 = segs[j].b - segs[j].a;\n      if(cross(p1, p2) == 0) continue;\n      if(intersect(segs[i], segs[j])) {\n        ps.emplace_back(crosspoint(segs[i], segs[j]));\n      }\n    }\n  }\n  sort(begin(ps), end(ps));\n  ps.erase(unique(begin(ps), end(ps)), end(ps));\n\n  int M = (int) ps.size();\n  g.resize(M);\n  for(int i = 0; i < N; i++) {\n    vector< int > vec;\n    for(int j = 0; j < M; j++) {\n      if(intersect(segs[i], ps[j])) {\n        vec.emplace_back(j);\n      }\n    }\n    for(int j = 1; j < vec.size(); j++) {\n      g[vec[j - 1]].push_back(vec[j]);\n      g[vec[j]].push_back(vec[j - 1]);\n    }\n  }\n  return (g);\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_4_C\n// 凸多角形の切断\n// 直線 l.a-l.b で切断しその左側にできる凸多角形を返す\nPolygon convex_cut(const Polygon &U, Line l) {\n  Polygon ret;\n  for(int i = 0; i < U.size(); i++) {\n    Point now = U[i], nxt = U[(i + 1) % U.size()];\n    if(ccw(l.a, l.b, now) != -1) ret.push_back(now);\n    if(ccw(l.a, l.b, now) * ccw(l.a, l.b, nxt) < 0) {\n      ret.push_back(crosspoint(Line(now, nxt), l));\n    }\n  }\n  return (ret);\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_3_A\n// 多角形の面積\nReal area(const Polygon &p) {\n  Real A = 0;\n  for(int i = 0; i < p.size(); ++i) {\n    A += cross(p[i], p[(i + 1) % p.size()]);\n  }\n  return A * 0.5;\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_7_H\n// 円と多角形の共通部分の面積\nReal area(const Polygon &p, const Circle &c) {\n  if(p.size() < 3) return 0.0;\n  function< Real(Circle, Point, Point) > cross_area = [&](const Circle &c, const Point &a, const Point &b) {\n    Point va = c.p - a, vb = c.p - b;\n    Real f = cross(va, vb), ret = 0.0;\n    if(eq(f, 0.0)) return ret;\n    if(max(abs(va), abs(vb)) < c.r + EPS) return f;\n    if(distance(Segment(a, b), c.p) > c.r - EPS) return c.r * c.r * arg(vb * conj(va));\n    auto u = crosspoint(c, Segment(a, b));\n    vector< Point > tot{a, u.first, u.second, b};\n    for(int i = 0; i + 1 < tot.size(); i++) {\n      ret += cross_area(c, tot[i], tot[i + 1]);\n    }\n    return ret;\n  };\n  Real A = 0;\n  for(int i = 0; i < p.size(); i++) {\n    A += cross_area(c, p[i], p[(i + 1) % p.size()]);\n  }\n  return A;\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_4_B\n// 凸多角形の直径(最遠頂点対間距離)\nReal convex_diameter(const Polygon &p) {\n  int N = (int) p.size();\n  int is = 0, js = 0;\n  for(int i = 1; i < N; i++) {\n    if(p[i].imag() > p[is].imag()) is = i;\n    if(p[i].imag() < p[js].imag()) js = i;\n  }\n  Real maxdis = norm(p[is] - p[js]);\n\n  int maxi, maxj, i, j;\n  i = maxi = is;\n  j = maxj = js;\n  do {\n    if(cross(p[(i + 1) % N] - p[i], p[(j + 1) % N] - p[j]) >= 0) {\n      j = (j + 1) % N;\n    } else {\n      i = (i + 1) % N;\n    }\n    if(norm(p[i] - p[j]) > maxdis) {\n      maxdis = norm(p[i] - p[j]);\n      maxi = i;\n      maxj = j;\n    }\n  } while(i != is || j != js);\n  return sqrt(maxdis);\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_5_A\n// 最近点対\nReal closest_pair(Points ps) {\n  if(ps.size() <= 1) throw (0);\n  sort(begin(ps), end(ps));\n\n  auto compare_y = [&](const Point &a, const Point &b) {\n    return imag(a) < imag(b);\n  };\n  vector< Point > beet(ps.size());\n  const Real INF = 1e18;\n\n  function< Real(int, int) > rec = [&](int left, int right) {\n    if(right - left <= 1) return INF;\n    int mid = (left + right) >> 1;\n    auto x = real(ps[mid]);\n    auto ret = min(rec(left, mid), rec(mid, right));\n    inplace_merge(begin(ps) + left, begin(ps) + mid, begin(ps) + right, compare_y);\n    int ptr = 0;\n    for(int i = left; i < right; i++) {\n      if(abs(real(ps[i]) - x) >= ret) continue;\n      for(int j = 0; j < ptr; j++) {\n        auto luz = ps[i] - beet[ptr - j - 1];\n        if(imag(luz) >= ret) break;\n        ret = min(ret, abs(luz));\n      }\n      beet[ptr++] = ps[i];\n    }\n    return ret;\n  };\n  return rec(0, (int) ps.size());\n}\n\nint main() {\n  int N;\n  cin >> N;\n  Points p(N);\n  cin >> p;\n  vector< int > ord(N);\n  iota(begin(ord), end(ord), 0);\n\n  double ret = 1e18;\n  do {\n    Point pre(-1, 0), cur(0, 0);\n    double sum = 0;\n    for(int i : ord) {\n      sum += get_angle(pre, cur, p[i]);\n      pre = cur;\n      cur = p[i];\n    }\n    sum += get_angle(pre, cur, Point(0, 0));\n    chmin(ret, sum);\n  } while(next_permutation(begin(ord), end(ord)));\n\n  cout << radian_to_degree(ret) << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//#define NDEBUG\n#include <cstddef>\n#include <cstdint>\n#include <iostream>\n#include <iterator>\n#include <vector>\n\nnamespace n91 {\n\n  using i8 = std::int_fast8_t;\n  using i32 = std::int_fast32_t;\n  using i64 = std::int_fast64_t;\n  using u8 = std::uint_fast8_t;\n  using u32 = std::uint_fast32_t;\n  using u64 = std::uint_fast64_t;\n  using isize = std::ptrdiff_t;\n  using usize = std::size_t;\n\n  constexpr usize operator\"\" _z(unsigned long long x) noexcept {\n    return static_cast<usize>(x);\n  }\n\n  template <class T> class integral_iterator {\n  public:\n    using difference_type = T;\n    using value_type = T;\n    using pointer = const value_type*;\n    using reference = value_type;\n    using iterator_category = std::random_access_iterator_tag;\n\n  private:\n    using self_type = integral_iterator<value_type>;\n    value_type i;\n\n  public:\n    constexpr integral_iterator() noexcept : i() {}\n    explicit constexpr integral_iterator(const value_type i) noexcept : i(i) {}\n    constexpr self_type operator++(int) noexcept { return self_type(i++); }\n    constexpr self_type operator--(int) noexcept { return self_type(i--); }\n    constexpr self_type operator[](const difference_type rhs) const noexcept {\n      return self_type(i + rhs);\n    }\n    constexpr self_type& operator++() noexcept {\n      ++i;\n      return *this;\n    }\n    constexpr self_type& operator--() noexcept {\n      --i;\n      return *this;\n    }\n    constexpr reference operator*() const noexcept { return i; }\n    constexpr self_type operator+(const difference_type rhs) const noexcept {\n      return self_type(i + rhs);\n    }\n    constexpr self_type operator-(const difference_type rhs) const noexcept {\n      return self_type(i - rhs);\n    }\n    constexpr difference_type operator-(const self_type rhs) const noexcept {\n      return i - rhs.i;\n    }\n    constexpr bool operator<(const self_type rhs) const noexcept {\n      return i < rhs.i;\n    }\n    constexpr bool operator<=(const self_type rhs) const noexcept {\n      return i <= rhs.i;\n    }\n    constexpr bool operator>(const self_type rhs) const noexcept {\n      return i > rhs.i;\n    }\n    constexpr bool operator>=(const self_type rhs) const noexcept {\n      return i >= rhs.i;\n    }\n    constexpr bool operator==(const self_type rhs) const noexcept {\n      return i == rhs.i;\n    }\n    constexpr bool operator!=(const self_type rhs) const noexcept {\n      return i != rhs.i;\n    }\n    constexpr self_type& operator+=(const difference_type rhs) noexcept {\n      i += rhs;\n      return *this;\n    }\n    constexpr self_type& operator-=(const difference_type rhs) noexcept {\n      i -= rhs;\n      return *this;\n    }\n  };\n  template <class T>\n  constexpr integral_iterator<T> make_int_itr(const T i) noexcept {\n    return integral_iterator<T>(i);\n  }\n  class rep {\n    const usize f, l;\n\n  public:\n    constexpr rep(const usize f, const usize l) noexcept : f(f), l(l) {}\n    constexpr auto begin() const noexcept { return make_int_itr(f); }\n    constexpr auto end() const noexcept { return make_int_itr(l); }\n  };\n  class revrep {\n    const usize f, l;\n\n  public:\n    revrep(const usize f, const usize l) noexcept : f(l), l(f) {}\n    auto begin() const noexcept {\n      return std::make_reverse_iterator(make_int_itr(f));\n    }\n    auto end() const noexcept {\n      return std::make_reverse_iterator(make_int_itr(l));\n    }\n  };\n  template <class T> auto md_vec(const usize n, const T& value) {\n    return std::vector<T>(n, value);\n  }\n  template <class... Args> auto md_vec(const usize n, Args... args) {\n    return std::vector<decltype(md_vec(args...))>(n, md_vec(args...));\n  }\n  template <class T> constexpr T difference(const T& a, const T& b) {\n    return a < b ? b - a : a - b;\n  }\n  template <class T> T scan() {\n    T ret;\n    std::cin >> ret;\n    return ret;\n  }\n\n} // namespace n91\n\n#include <algorithm>\n#include <iostream>\n#include <utility>\n#include <complex>\n#include <numeric>\n#include<iomanip>\n\nnamespace n91 {\n\n  void main_() {\n    usize n;\n    std::cin >> n;\n    using c=std::complex<long double>;\n    std::vector<c> p(n);\n    for (auto& e : p) {\n      i32 x, y;\n      std::cin >> x >> y;\n      e = c(x, y);\n    }\n    p.emplace_back(0, 0);\n    std::vector<usize> idx(n);\n    std::iota(idx.begin(), idx.end(), 0);\n    idx.push_back(n);\n    long double ans = 100;\n    const auto arg = [](const c& x) {\n      return std::atan2(x.imag(), x.real());\n    };\n    const long double pi = std::acos(-1);\n    do {\n      long double sum = 0;\n      c prev(0, 0), d(1, 0);\n      for (const auto i : idx) {\n        const auto next = p[i];\n        auto rot = arg(next - prev) - arg(d);\n        if (rot > pi) {\n          rot -= pi * 2;\n        }\n        if (rot < -pi) {\n          rot += pi * 2;\n        }\n        sum += std::abs(rot);\n        d = next - prev;\n        prev = next;\n      }\n      ans = std::min(ans, sum);\n    } while (std::next_permutation(idx.begin(), idx.end() - 1));\n    std::cout << std::setprecision(10) << ans * 180 / pi << std::endl;\n  }\n\n} // namespace n91\n\nint main() {\n  n91::main_();\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing db = double;\n#define fi first\n#define se second\n#define pb push_back\n#define eb emplace_back\n#define all(v) (v).begin(), (v).end()\n#define siz(v) (ll)(v).size()\n#define rep(i, n) for (ll i = 0; i < (ll)(n); i++)\n#define repi(i, x, n) for (ll i = x; i < (ll)(n); i++)\n#define lb lower_bound\n#define ub upper_bound\ntypedef pair<int, int> P;\ntypedef pair<ll, ll> PL;\nconst ll mod = 1000000007;\nconst ll INF = 1000000099;\nvector<ll> dx = {-1, 1, 0, 0}, dy = {0, 0, -1, 1};\n//cin.tie(0);ios::sync_with_stdio(false);\n\n\nsigned main()\n{\n    cout<<fixed;\n    int n;\n    cin >> n;\n    long double ans = INF;\n    vector<pair<long double, long double>> v(n + 2);\n    v[0].fi = .0;\n    v[0].se = .0;\n    rep(i, n) cin >> v[i + 1].fi >> v[i + 1].se;\n    v[n + 1].fi = .0;\n    v[n + 1].se = .0;\n\n    sort(v.begin()+1,v.end()-1);\n\n    do\n    {\n        long double cnt = abs(atan2(v[1].se, v[1].fi))* 180.0;\n        //cout<<cnt<<endl;\n        rep(i, n)\n        {\n            long double x1 = v[i].fi, y1 = v[i].se, x2 = v[i + 1].fi, y2 = v[i + 1].se, x3 = v[i + 2].fi, y3 = v[i + 2].se;\n            long double a = pow(((x2 - x1) * (x2 - x1)) + ((y2 - y1) * (y2 - y1)), 0.5);\n            long double b = pow(((x3 - x2) * (x3 - x2)) + ((y3 - y2) * (y3 - y2)), 0.5);\n\n            long double cos_sita = ((x2 - x1) * (x3 - x2) + (y2 - y1) * (y3 - y2)) / (a * b);\n            long double sita = acos(cos_sita);\n            //cout<<sita * 180 / M_PI<<endl;\n            cnt += sita * 180.0;\n            //cout << cnt/M_PI << endl;\n        }\n        ans = min(ans, cnt / M_PI);\n\n    } while (next_permutation(v.begin() + 1, v.end() - 1));\n    cout << setprecision(10) << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define HUGE_NUM 99999999999999999\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n\nstruct Point{\n\tPoint(double arg_x,double arg_y){\n\t\tx = arg_x;\n\t\ty = arg_y;\n\t}\n\n\tPoint(){\n\t\tx = y = 0.0;\n\t}\n\n\tPoint operator + (Point p){ return Point(x+p.x,y+p.y); }\n\tPoint operator - (Point p){ return Point(x-p.x,y-p.y);}\n\tPoint operator * (double a){ return Point(a*x,a*y); }\n\tPoint operator / (double a){ return Point(x/a,y/a); }\n\n\tdouble abs(){ return sqrt(norm()); }\n\tdouble norm(){ return x*x + y*y; }\n\n\tbool operator<(const Point &p) const{\n\t\treturn x != p.x? x < p.x: y < p.y;\n\t}\n\n\tbool operator == (const Point &p) const{\n\t\treturn fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n\t}\n\n\tdouble x,y;\n};\n\ntypedef Point Vector;\nint N;\nPoint point[8];\n\ndouble norm(Vector a){\n\treturn a.x*a.x+a.y*a.y;\n}\n\ndouble abs(Vector a){\n\treturn sqrt(norm(a));\n}\n\ndouble cross(Vector a,Vector b){\n    return a.x*b.y-a.y*b.x;\n}\n\ndouble dot(Vector a,Vector b){\n    return a.x*b.x + a.y*b.y;\n}\n\n\nint main(){\n\n\tscanf(\"%d\",&N);\n\n\tfor(int i = 0; i < N; i++){\n\n\t\tscanf(\"%lf %lf\",&point[i].x,&point[i].y);\n\t}\n\n\tint table[N];\n\tfor(int i = 0; i < N; i++){\n\n\t\ttable[i] = i;\n\t}\n\n\tdouble ans = BIG_NUM;\n\n\tdo{\n\n\t\tPoint pre;\n\t\tpre.x = 0;\n\t\tpre.y = 0;\n\n\t\tdouble tmp = 0;\n\n\t\tVector vec,next_vec;\n\t\tvec.x = 1;\n\t\tvec.y = 0;\n\n\t\tfor(int i = 0; i < N; i++){\n\n\t\t\tnext_vec = point[table[i]]-pre;\n\n\t\t\ttmp += fabs(acos(dot(next_vec,vec)/(abs(next_vec)*abs(vec))));\n\n\t\t\tpre = point[table[i]];\n\t\t\tvec = next_vec;\n\t\t}\n\n\t\t//家に帰る\n\t\tdouble x = 0;\n\t\tdouble y = 0;\n\n\t\tnext_vec.x = x-pre.x;\n\t\tnext_vec.y = y-pre.y;\n\n\t\ttmp += fabs(acos(dot(next_vec,vec)/(abs(next_vec)*abs(vec))));\n\n\t\tans = min(ans,tmp);\n\n\t}while(next_permutation(table,table+N));\n\n\tprintf(\"%.10lf\\n\",(ans*180)/M_PI);\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <bitset>\n#include <algorithm>\n#include <complex>\n#include <array>\nusing namespace std;\n\n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n#define ALL(c) (c).begin(), (c).end()\n\ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<VI> VVI;\ntypedef vector<VL> VVL;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\ntypedef vector<double> VD;\ntypedef vector<VD> VVD;\n\ntemplate<typename T> void chmin(T &a, T b) { if (a > b) a = b; }\ntemplate<typename T> void chmax(T &a, T b) { if (a < b) a = b; }\n\nint in() { int x; scanf(\"%d\", &x); return x; }\nll lin() { ll x; scanf(\"%lld\", &x); return x; }\n\nconst double pi = acos(-1.0);\n\ndouble calc(double x, double y){\n    return fmin(fmin(fabs(x - y), fabs(x - y + 2 * pi)), fabs(x - y - 2 * pi));\n}\n\nint main() {\n    int n;\n    cin >> n;\n    VD x(n), y(n);\n    REP(i,n){\n        cin >> x[i] >> y[i];\n    }\n    VI p(n);\n    REP(i,n) p[i] = i;\n    double ans = 1e9;\n    do {\n        double s = 0.0, t = 0.0;\n        double xp = 0.0, yp = 0.0;\n        REP(i,n){\n            double xq = x[p[i]], yq = y[p[i]];\n            double u = atan2(yq - yp, xq - xp);\n            // cout << t * 180 / pi << \" \" << u * 180 / pi << endl;\n            s += calc(t, u);\n            xp = xq;\n            yp = yq;\n            t = u;\n        }\n        s += calc(t, atan2(-yp, -xp));\n        ans = fmin(ans, s);\n    }while (next_permutation(ALL(p)));\n    ans *= 180.0 / pi;\n    printf(\"%.15f\\n\", ans);\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <climits>\n#include <cstdio>\n#include <math.h>\n\n#define rep(i, n) for(int i=0; i<(int)(n); i++)\n#define INF INT_MAX\n\ntypedef long long ll;\n\nusing namespace std;\n\n//ベクトルの定義\nstruct Vector2D{\n\tdouble x;\n\tdouble y;\n};\n\n//ベクトルの長さを計算する\ndouble get_vector_length(Vector2D v) {\n\treturn pow((v.x * v.x) + (v.y * v.y), 0.5);\n}\n\n//ベクトル内積\ndouble dot_product(Vector2D vl, Vector2D vr) {\n\treturn vl.x * vr.x + vl.y * vr.y;\n}\n\n//２つのベクトルABのなす角度θを求める\ndouble AngleOf2Vector(Vector2D A, Vector2D B)\n{\n\t//　※ベクトルの長さが0だと答えが出ませんので注意してください。\n\n\t//ベクトルAとBの長さを計算する\n\tdouble length_A = get_vector_length(A);\n\tdouble length_B = get_vector_length(B);\n\n\t//内積とベクトル長さを使ってcosθを求める\n\tdouble cos_sita = dot_product(A, B) / (length_A * length_B);\n\n\t//cosθからθを求める\n\tdouble sita = acos(cos_sita);\n\n\t//ラジアンでなく0～180の角度でほしい場合はコメント外す\n\tsita = sita * 180.0 / M_PI;\n\n\treturn sita;\n}\n\n\nint main(void){\n\tll n; cin >> n;\n\tvector<Vector2D> xy(n);\n\trep(i, n) cin >> xy[i].x >> xy[i].y;\n\t\n\tvector<int> perm(n);\n\trep(i, n) perm[i] = i;\n\tdouble ans = INF;\n\tdo{\n\t\tdouble sum = 0;\n\t\tVector2D prev{1, 0};\n\t\trep(i, perm.size()){\n\t\t\tVector2D v1{(prev.x), (prev.y)};\n\t\t\tVector2D v2;\n\t\t\tif(i==0) v2 ={xy[perm[i]].x, xy[perm[i]].y};\n\t\t\telse v2 ={xy[perm[i]].x - xy[perm[i-1]].x, xy[perm[i]].y - xy[perm[i-1]].y};\n\t\t\tsum += AngleOf2Vector(v1, v2);\n\t\t\tprev = {v2.x, v2.y};\n\t\t}\n\t\tVector2D l1{(prev.x), (prev.y)};\n\t\tVector2D l2;\n\t\tl2 ={0 - xy[perm[perm.size()-1]].x, 0 - xy[perm[perm.size()-1]].y};\n\t\tsum += AngleOf2Vector(l1, l2);\n\t\tprev ={l2.x, l2.y};\n\n\t\tans = min(ans, sum);\n\n\t}while(next_permutation(perm.begin(), perm.end()));\n\tprintf(\"%.20lf\\n\", ans);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <chrono>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstring>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n#include <cstdint>\nusing namespace std;\ntypedef long long ll;\n#define MP make_pair\n#define PB push_back\n#define inf 1000000007\n#define mod 1000000007\n#define rep(i,n) for(int i = 0; i < (int)(n); ++i)\n#define EPS 1e-10\n\ntypedef complex<double> C;\n\nconst double PI = 4*atan(1.0);\n\nbool eq(double a,double b)\n{\n  return (-EPS<a-b&&a-b<EPS);\n}\n\nnamespace std\n{\n    bool operator < (const C a, const C b) {\n        return a.real() != b.real() ? a.real() < b.real() : a.imag() < b.imag();\n    }\n    bool operator > (const C a, const C b) {\n        return a.real() != b.real() ? a.real() > b.real() : a.imag() > b.imag();\n    }\n    bool operator==(const C a, const C b){\n        return (eq(a.real(),b.real()) && eq(a.imag(),b.imag()));\n    }\n    bool operator!=(const C a, const C b){\n        return !(a == b);\n    }\n    C operator* (const C a, const C b){\n        return C(a.real()*b.real()-a.imag()*b.imag(),a.real()*b.imag()+a.imag()*b.real());\n    }\n}\n\n//条件付きsqrt\ndouble Sqrt(double x)\n{\n    if(x<0) return 0;\n    else    return sqrt(x);\n}\n\n//正規化\nC normalize(C c)\n{\n    return c / abs(c);\n}\n\n//角度(rad)\ndouble getarg(C a,C b){\n    return arg(b*conj(a));\n}\n\n//外積\ndouble cross(const C a, const C b)\n{\n    return imag(conj(a)*b);\n}\n//内積\ndouble dot(const C a, const C b)\n{\n    return real(conj(a)*b);\n}\n\n//bを中心としてaをth(rad)回転\nC rot(C a,C b,double th)\n{\n    return b + (a-b) * C(cos(th),sin(th));\n}\n\nint ccw(C a, C b, C c)\n{\n    b -= a; c -= a;\n    if(cross(b, c) > 0)   return +1;       // counter clockwise\n    if(cross(b, c) < 0)   return -1;       // clockwise\n    if(dot(b, c) < 0)     return +2;       // c--a--b on line\n    if(norm(b) < norm(c)) return -2;       // a--b--c on line\n    return 0;   // a--c--b on line\n}\n\ndouble dp[10][10][1<<9];\nvector<double> x,y;\ndouble calc(int i,int j,int k){\n    C c1(x[i]-x[j],y[i]-y[j]);\n    C c2(x[k]-x[i],y[k]-y[i]);\n    return abs(getarg(c1,c2)/M_PI*180.0);\n}\n\nint main(){\n    int n;\n    cin >> n;\n    x.resize(n);\n    y.resize(n);\n    rep(i,n){\n        cin >> x[i] >> y[i];\n    }\n    \n    // rep(i,n+1){\n    //     rep(j,n+1){\n    //         rep(k,1<<n){\n    //             dp[i][j][k] = inf;\n    //         }\n    //     }\n    // }\n    // rep(i,n+1){\n    //     if(i==0)continue;\n    //     C c1(1,0);\n    //     C c2(x[i],y[i]);\n        \n    //     dp[i][0][1<<(i-1)] = abs(getarg(c1,c2)/M_PI*180.0);\n    //     //cerr << i << \" \" << 0 << \" \" << dp[i][0][1<<(i-1)] << endl;\n    // }\n    \n    // rep(i,n+1){\n    //     if(i==0)continue;\n    //     rep(j,n+1){\n    //         rep(k,1<<n){\n    //             if(abs(dp[i][j][k]-inf)<=EPS){\n    //                 continue;\n    //             }\n    //             //cerr << i << \" \" << j << \" \" << k << endl;\n    //             rep(l,n){\n    //                 if((k>>l)&1){\n\n    //                 }else{\n    //                     int id = l+1;\n    //                     //cerr << id << endl;\n    //                     dp[id][i][k^(1<<l)] = min(dp[id][i][k^(1<<l)],dp[i][j][k]+calc(i,j,id));\n    //                     //cerr << dp[id][i][k^(1<<l)] << endl;\n    //                 }\n    //             }\n    //         }\n    //     }\n    // }\n    // double mi = inf;\n    // rep(i,n+1){\n    //     rep(j,n+1){\n    //         if(i==0||j==0)continue;\n    //         if(i==j)continue;\n    //         //cerr << i << \" \" << j << \" \" << dp[i][j][(1<<n)-1]  << \" \" <<  calc(i,j,0) << endl;\n    //         mi = min(mi,dp[i][j][(1<<n)-1] + calc(i,j,0));\n    //     }\n    // }\n    vector<int>v(n);\n    rep(i,n){\n        v[i] = i;\n    }\n    double mi = inf;\n    do{\n        C c1(1,0);\n        C p(0,0);\n        double tmp  = 0;\n        rep(i,n){\n            C c2(x[v[i]]-p.real(),y[v[i]]-p.imag());\n            tmp +=  abs(getarg(c1,c2)/M_PI*180.0);\n            p = C(x[v[i]],y[v[i]]);\n            c1 = c2;\n            //cerr << p << \" \" << c2 << endl;\n        }\n        C c3(-x[v[n-1]],-y[v[n-1]]);\n        tmp +=  abs(getarg(c1,c3)/M_PI*180.0);\n            \n        mi = min(mi,tmp );\n\n    }while(next_permutation(v.begin(),v.end()));\n    cout.precision(20);\n    cout << mi << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<iomanip>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n#include<limits>\n\nusing namespace std;\n\n#define int long long\n#define endl \"\\n\"\n\nconst long long INF = (long long)1e18;\nconst long long MOD = (long long)1e9 + 7; \n\nstring yn(bool f){return f?\"Yes\":\"No\";}\nstring YN(bool f){return f?\"YES\":\"NO\";}\n\n#define x first\n#define y second\n\nlong double angle(pair<int,int> a, pair<int,int> b){\n\tstatic long double PI = acos(-1);\n\tlong double inner_product = a.x*b.x + a.y*b.y, absa = sqrt(a.x*a.x + a.y*a.y), absb = sqrt(b.x*b.x + b.y*b.y);\n\tlong double c = inner_product/(absa*absb);\n\treturn fabs(acos(c)/PI)*180;\n}\n\nsigned main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tcout<<fixed<<setprecision(10);\n\t\n\tint n;\n\tvector<int>  per;\n\tvector<pair<long double, long double>> shop;\n\tlong double ans = numeric_limits<long double>::max();\n\t\n\tcin>>n;\n\t\n\tshop.resize(n+1);\n\tper.resize(n+2);\n\t\n\tfor(int i = 1; i <= n; per[i] = i, i++)\n\t\tcin>>shop[i].x>>shop[i].y;\n\t\n\tdo{\n\t\tlong double sum = 0;\n\t\tpair<long long, long long> nd, d = {1,0};\n\t\t\n\t\tfor(int i = 0; i <= n; d = nd, i++){\n\t\t\tnd = make_pair(shop[per[i+1]].x - shop[per[i]].x, shop[per[i+1]].y - shop[per[i]].y);\n\t\t\tsum += angle(d,nd);\n\t\t}\n\t\t\n\t\tans = min(ans, sum);\n\t\t\n\t} while(next_permutation(per.begin()+1, per.end()-1));\n\t\n\tcout<<ans<<endl;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <utility>\n#include <stdio.h>\n#include <math.h>\n#include <algorithm>\n#define llint long long\n#define eps 1e-8\n\nusing namespace std;\n\nstruct vec2d{\n\tdouble x, y;\n\tvec2d(){}\n\tvec2d(double x, double y){\n\t\tthis->x = x, this->y = y;\n\t}\n\tdouble add(double a, double b){\n\t\tif(fabs(a+b) < eps * (fabs(a) + fabs(b))) return 0.0;\n\t\treturn a+b;\n\t}\n\tvec2d operator+(vec2d ope){\n\t\treturn vec2d(add(x, ope.x), add(y, ope.y));\n\t}\n\tvec2d operator-(vec2d ope){\n\t\treturn vec2d(add(x, -ope.x), add(y, -ope.y));\n\t}\n\tvec2d operator*(double t){\n\t\treturn vec2d(x*t, y*t);\n\t}\n\tvec2d operator/(double t){\n\t\treturn vec2d(x/t, y/t);\n\t}\n\tdouble dot(vec2d ope){\n\t\treturn add(x*ope.x, y*ope.y);\n\t}\n\tdouble cross(vec2d ope){\n\t\treturn add(x*ope.y, -y*ope.x);\n\t}\n\tdouble norm(){\n\t\tdouble d2 = dot(*this);\n\t\tif(d2 > 0) return sqrt(d2);\n\t\treturn 0.0;\n\t}\n};\n\nllint n;\nvec2d p[10];\n\nint main(void)\n{\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\t\n\tcin >> n;\n\tfor(int i = 0; i < 10; i++) p[i].x = p[i].y = 0;\n\tfor(int i = 1; i <= n; i++) cin >> p[i].x >> p[i].y;\n\t\n\tint perm[10];\n\tfor(int i = 0; i < 10; i++) perm[i] = 0;\n\tfor(int i = 1; i <= n; i++) perm[i] = i;\n\t\n\tdouble ans = 1e9;\n\tdo{\n\t\tvec2d a = p[perm[1]], b = vec2d(1, 0);\n\t\tdouble tmp = fabs(acos(a.dot(b) / (a.norm()*b.norm())));;\n\t\tfor(int i = 1; i <= n; i++){\n\t\t\tvec2d a = p[perm[i]]-p[perm[i-1]], b = p[perm[i+1]]-p[perm[i]];\n\t\t\ttmp += fabs(acos(a.dot(b) / (a.norm()*b.norm())));\n\t\t\t//cout<< a.x << \" \" << a.y << \" \" << b.x << \" \" << b.y << \" \" << a.dot(b) << endl;\n\t\t\t//cout << a.dot(b) / (a.norm()*b.norm()) << endl;\n\t\t}\n\t\tans = min(ans, tmp);\n\t}while(next_permutation(perm+1, perm+n+1));\n\t\n\tprintf(\"%.11f\\n\", ans * 180 / 3.14159265358979);\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<utility>\n#include<algorithm>\n#include<string>\n#include<cstdio>\n#include<queue>\n#include<functional>\n#include <tuple>\n#include<iomanip>\n#include<cmath>\nusing namespace std;\ndouble const pi = acos(-1.0);\ndouble f(pair<int,int>p1,pair<int,int>p2) {\n\tint x1, x2, y1, y2;\n\ttie(x1, y1) = p1;\n\ttie(x2, y2) = p2;\n\tdouble p = acos(1.0/(hypot(x1, y1)*hypot(x2, y2)) * (x1*x2 + y1 * y2)) * 180 / pi;\n\treturn min(p, 360 - p);\n}\nint main() {\n\tint n; cin >> n;\n\tvector<pair<int, int>>v(n);\n\tfor (int i = 0; i < n; ++i) {\n\t\tcin >> v[i].first >> v[i].second;\n\t}\n\tsort(v.begin(), v.end());\n\tdouble res = 1e9;\n\tdo {\n\t\tdouble a = 0;\n\t\tint x = 1, y = 0;\n\t\tint cx = 0, cy = 0;\n\t\tpair<int, int> p1, p2;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t    p1 = make_pair(x, y);\n\t\t\tp2 = make_pair(v[i].first - cx, v[i].second - cy);\n\t\t\ta += f(p1, p2);\n\t\t\ttie(x, y) = p2;\n\t\t\ttie(cx, cy) = v[i];\n\t\t}\n\t\tp1 = make_pair(x, y);\n\t\tp2 = make_pair(-v.back().first, -v.back().second);\n\t\ta += f(p1, p2);\n\t\tres = min(res, a);\n\t} while (next_permutation(v.begin(), v.end()));\n\tcout << fixed << setprecision(16) << res << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long long ll;\ntypedef long double ld;\nconst int INF=1e9,MOD=1e9+7,ohara=1e6+10;\nconst ll LINF=1e18;\nusing namespace std;\n    \n#define rep(i,n) for(int (i)=0;(i)<(int)(n);(i)++)\n#define rrep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrrep(i,a,b) for(int i=(a);i>=(b);i--)\n#define all(v) (v).begin(), (v).end()\n#define Size(n) (n).size()\n#define Cout(x) cout<<(x)<<endl\n#define doublecout(a) cout<<fixed<<setprecision(15)<<a<<endl;\n#define Cerr(x) cerr<<(x)<<endl\n#define fi first\n#define se second\n#define P pair<ll,ll> \n#define m_p make_pair\n#define V vector<ll> \n#define U_MAP unordered_map<ll,ll>\n#define pq priority_queue<ll>\n#define rpq priority_queue<ll,vector<ll>,greater<ll>>\n#define p_b push_back\n    \nll n,cnt,a,b,c,d,tmpp,m,h,w,x[20],y[20],sum,pos,k;\nld doua;\nint dy[]={1,0,-1,0};\nint dx[]={0,1,0,-1};\n//int dy[]={-1,0,1,-1,1,-1,0,1};\n//int dx[]={-1,-1,-1,0,0,1,1,1};\nstring alph(\"abcdefghijklmnopqrstuvwxyz\"),s;\nbool fl;\nstruct edge{int to,cost;};\ndouble ans=-1.0;\n    \n//-------------------------↓↓↓↓↓↓------------------------\n    \n//------ 自分を天才だと信じる ------\n    \nint main(void){\n    cin.tie(0);\n    cout.tie(0);\n    ios::sync_with_stdio(false);\n    \n    cin>>n;\n    rep(i,n)cin>>x[i]>>y[i];\n    vector<ll> p(n);\n    rep(i,n)p[i]=i;\n    do{\n        double theta=0.0;\n        double anss=0.0;\n        ll bex=0,bey=0;\n        rep(i,n){\n            double nowtheta;\n            if(x[p[i]]==bex){\n                //Cout(\"A\");\n                if(y[p[i]]>bey){\n                    nowtheta=90.0;\n                }\n                else{\n                    nowtheta=270.0;\n                }\n            }\n            else if(y[p[i]]==bey){\n                if(x[p[i]]>bex){\n                    nowtheta=0.0;\n                }\n                else{\n                    nowtheta=180.0;\n                }\n            }\n            else{\n                //Cout(\"A\");\n                double tmp;\n                tmp=(double)abs(y[p[i]]-bey)/(double)abs(x[p[i]]-bex);\n                nowtheta=atan(tmp);\n                nowtheta=nowtheta*180.0/M_PI;\n                //doublecout(nowtheta/M_PI*180.0);\n                if(x[p[i]]<bex&&y[p[i]]>bey){\n                    nowtheta=180.0-nowtheta;\n                }\n                else if(x[p[i]]<bex&&y[p[i]]<bey){\n                    nowtheta=nowtheta+180.0;\n                }\n                else if(x[p[i]]>bex&&y[p[i]]<bey){\n                    nowtheta=360.0-nowtheta;\n                }\n            }\n            anss+=min(abs(theta-nowtheta),360.0-abs(theta-nowtheta));\n            theta=nowtheta;\n            bex=x[p[i]];\n            bey=y[p[i]];\n            //Cout(anss);\n            //cout<<bex<<\" \"<<bey<<\"\\n\";\n        }\n        //cout<<\"\\n\";\n        double nowtheta;\n            if(0==bex){\n                //Cout(\"A\");\n                if(0>bey){\n                    nowtheta=90.0;\n                }\n                else{\n                    nowtheta=270.0;\n                }\n            }\n            else if(0==bey){\n                if(0>bex){\n                    nowtheta=0.0;\n                }\n                else{\n                    nowtheta=180.0;\n                }\n            }\n            else{\n                //Cout(\"A\");\n                double tmp;\n                tmp=(double)abs(0-bey)/(double)abs(0-bex);\n                nowtheta=atan(tmp);\n                nowtheta=nowtheta*180.0/M_PI;\n                if(0<bex&&0>bey){\n                    nowtheta=180.0-nowtheta;\n                }\n                else if(0<bex&&0<bey){\n                    nowtheta=nowtheta+180.0;\n                }\n                else if(0>bex&&0<bey){\n                    nowtheta=360.0-nowtheta;\n                }\n            }\n           // Cout(anss);\n            anss+=min(abs(theta-nowtheta),360.0-abs(theta-nowtheta));\n            theta=nowtheta;\n        //cout<<x[p[1]]<<\" \"<<y[p[1]]<<\"\\n\";\n        //Cout(anss);\n        //cout<<\"\\n\";\n        if(ans==-1.0)ans=anss;\n        else ans=min(ans,anss);\n    }while(next_permutation(all(p)));\n    doublecout(ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<algorithm>\n#include<vector>\n#include<iomanip>\nusing namespace std;\nint N;\nvector<pair<int,int> >A;\ndouble f(int x1,int y1,int x2,int y2)\n{\n\tdouble a=atan2(y1,x1);\n\tdouble b=atan2(y2,x2);\n\tdouble x=abs(a-b)*180/M_PI;\n\tif(x>180)x=360-x;\n\t//cout<<\"(\"<<x1<<\", \"<<y1<<\") , (\"<<x2<<\", \"<<y2<<\") = \"<<x<<endl;\n\treturn x;\n}\nint main()\n{\n\tcin>>N;\n\tfor(int i=0;i<N;i++)\n\t{\n\t\tint a,b;cin>>a>>b;\n\t\tA.push_back(make_pair(a,b));\n\t}\n\tsort(A.begin(),A.end());\n\tdouble ans=1e9;\n\tdo{\n\t\tdouble now=0;\n\t\tint px=A[0].first;\n\t\tint py=A[0].second;\n\t\tnow+=f(1,0,px,py);\n\t\tfor(int i=1;i<N;i++)\n\t\t{\n\t\t\tint x=A[i].first-A[i-1].first;\n\t\t\tint y=A[i].second-A[i-1].second;\n\t\t\tnow+=f(px,py,x,y);\n\t\t\tpx=x;\n\t\t\tpy=y;\n\t\t}\n\t\tint x2=-A[N-1].first;\n\t\tint y2=-A[N-1].second;\n\t\tnow+=f(px,py,x2,y2);\n\t\tans=min(ans,now);\n\t}while(next_permutation(A.begin(),A.end()));\n\tcout<<fixed<<setprecision(16)<<ans<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define whlie while\n#define pb push_back\n#define eb emplace_back\n#define fi first\n#define se second\n#define rep(i,N) for(int i = 0; i < (N); i++)\n#define repr(i,N) for(int i = (N) - 1; i >= 0; i--)\n#define rep1(i,N) for(int i = 1; i <= (N) ; i++)\n#define repr1(i,N) for(int i = (N) ; i > 0 ; i--)\n#define each(x,v) for(auto& x : v)\n#define all(v) (v).begin(),(v).end()\n#define sz(v) ((int)(v).size())\n#define vrep(v,it) for(auto it = v.begin(); it != v.end(); it++)\n#define vrepr(v,it) for(auto it = v.rbegin(); it != v.rend(); it++)\n#define ini(...) int __VA_ARGS__; in(__VA_ARGS__)\n#define inl(...) ll __VA_ARGS__; in(__VA_ARGS__)\n#define ins(...) string __VA_ARGS__; in(__VA_ARGS__)\nusing namespace std; void solve();\nusing ll = long long; using vl = vector<ll>;\nusing vi = vector<int>; using vvi = vector< vector<int> >;\nconstexpr int inf = 1001001001;\nconstexpr ll infLL = (1LL << 61) - 1;\nstruct IoSetupNya {IoSetupNya() { cin.tie(nullptr); ios::sync_with_stdio(false); cout << fixed << setprecision(15); cerr << fixed << setprecision(7);} } iosetupnya;\ntemplate<typename T, typename U> inline bool amin(T &x, U y) { return (y < x) ? (x = y, true) : false; }\ntemplate<typename T, typename U> inline bool amax(T &x, U y) { return (x < y) ? (x = y, true) : false; }\ntemplate<typename T, typename U> ostream& operator <<(ostream& os, const pair<T, U> &p) { os << p.first << \" \" << p.second; return os; }\ntemplate<typename T, typename U> istream& operator >>(istream& is, pair<T, U> &p) { is >> p.first >> p.second; return is; }\ntemplate<typename T> ostream& operator <<(ostream& os, const vector<T> &v) { int s = (int)v.size(); rep(i,s) os << (i ? \" \" : \"\") << v[i]; return os; }\ntemplate<typename T> istream& operator >>(istream& is, vector<T> &v) { for(auto &x : v) is >> x; return is; }\nvoid in(){} template <typename T,class... U> void in(T &t,U &...u){ cin >> t; in(u...);}\nvoid out(){cout << \"\\n\";} template <typename T,class... U> void out(const T &t,const U &...u){ cout << t; if(sizeof...(u)) cout << \" \"; out(u...);}\ntemplate<typename T>void die(T x){out(x); exit(0);}\n#ifdef NyaanDebug\n  #include \"NyaanDebug.h\"\n  #define trc(...) do { cerr << #__VA_ARGS__ << \" = \"; dbg_out(__VA_ARGS__);} while(0)\n  #define trca(v,...) do { cerr << #v << \" = \"; array_out(v , __VA_ARGS__ );} while(0)\n#else\n  #define trc(...)\n  #define trca(...)\n  int main(){solve();}\n#endif\n \nconstexpr int MOD = /**/ 1000000007; //*/ 998244353;\n/////////////////\n\nconstexpr double pi = 3.14159265358979323846;\nusing P = pair<double , double>;\n\nusing vp = vector<P>;\ndouble nasukaku(P a,P b){\n  double alen = sqrt( (a.fi * a.fi) + (a.se * a.se) );\n  double blen = sqrt( (b.fi * b.fi) + (b.se * b.se) );\n  double naiseki = a.fi * b.fi + a.se * b.se;\n  return acos(naiseki / alen / blen) * 180.0 / pi;\n}\n\nvoid solve(){\n  ini(N);\n  vector<P> v(N); in(v);\n\n  vi ord(N);\n  iota(all(ord) , 0);\n  double ans = 1e16;\n  do{\n    P vec = P(1.0 , 0.0);\n    P cur = P(0.0 , 0.0);\n    double curans = 0.0;\n    rep(i,N){\n      P nya = P(v[ord[i]].fi - cur.fi , v[ord[i]].se - cur.se);\n      curans += abs(nasukaku(vec , nya));\n      trc(vec , nya , nasukaku(vec , nya));\n      cur = v[ord[i]];\n      vec = nya;\n    }\n    P nya = P(-v[ord[N-1]].fi , -v[ord[N-1]].se);\n    curans += abs(nasukaku(vec , nya));\n    amin(ans , curans);\n  }while(next_permutation(all(ord)));\n  out(ans);\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<math.h>\n#define min(p,q)((p)<(q)?(p):(q))\n#define PI 3.14159265358979323\n\nvoid nexp(int*a,int cnt){\n\tint l=cnt-1,r=cnt-1;\n\tint t;\n\twhile(--l>=0&&a[l]>a[l+1]);\n\tif(l>=0){\n\t\twhile(a[l]>a[r])r--;\n\t\tt=a[l];a[l]=a[r];a[r]=t;\n\t}\n\tfor(l++,r=cnt-1;l<r;l++,r--)t=a[l],a[l]=a[r],a[r]=t;\n}\nint x[9],y[9];\nint a[10];\nint main(){\n\tint n;\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)scanf(\"%d%d\",x+i,y+i);\n\tdouble ans=1e100;\n\tfor(int i=1;i<=n;i++)a[i]=i;\n\tfor(int iiii=0;iiii<40320;iiii++){\n\t\tdouble arg=0,tans=0;\n\t\tfor(int i=0;i<=n;i++){\n\t\t\tdouble narg=atan2(y[a[i+1]]-y[a[i]],x[a[i+1]]-x[a[i]]);\n\t\t\tdouble temp=(narg-arg)/PI*180;\n\t\t\twhile(temp<-180)temp+=360;\n\t\t\twhile(temp>180)temp-=360;\n\t\t\ttans+=fabs(temp);\n\t\t\targ=narg;\n\t\t}\n\t\tans=min(ans,tans);\n\t\tnexp(a+1,n);\n\t}\n\tprintf(\"%f\\n\",ans);\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <string.h>\n#include <math.h>\n#include <limits.h>\n#define Max(a, b) ((a) > (b) ? (a) : (b))\n#define Min(a, b) ((a) > (b) ? (b) : (a))\n#define abs(x) ((x) > 0 ? (x) : -(x))\n#define MOD (ll)1000000007 //10^9 + 7\n#define endl printf(\"\\n\")\ntypedef long long ll;\n#define rep(i, n) for (int i = 0; i < (n); i++)\n#define rep2(i, n, m) for (int i = (n), i < (m); i++)\n\n//typedef struct {float arg; int x, y;} shop;\n\n/*int shop_comp(const void *a, const void *b)\n{\n  shop x = *(shop *)a, y = *(shop *)b;\n  if (x.arg > y.arg) return  1;\n  if (x.arg < y.arg) return -1;\n  return 0;\n}*/\n\n\nint array[11], used[11], n;\ndouble x[11], y[11], ans = 1e9+7;\nvoid dfs(int i) {\n  if (i == n) {\n    //for (int j = 0; j <= n; j++) printf(\"%d \", array[j]); endl;\n    double arg = 0.0;\n    double u = 1.0, v= 0.0;\n    double xf = 0.0, yf = 0.0;\n    for (int i = 0; i <= n; i++) {\n      int k = array[i];\n      double dx = x[k] - xf, dy = y[k] - yf;\n      //printf(\"%lf %lf %lf %lf\\n\", u, v, \n      //printf(\"%lf\\n\", acos((u*dx+v*dy)/sqrt((u*u+v*v)*(dx*dx+dy*dy))));\n      arg += acos((u*dx+v*dy)/sqrt((u*u+v*v)*(dx*dx+dy*dy)));\n      xf = x[k]; yf = y[k];\n      u = dx; v = dy;\n    }\n    ans = Min(ans, arg);\n    return ;\n  }\n  for (int j = 1; j <= n; j++) {\n    if (used[j] == 0) {\n      used[j] = 1;\n      array[i] = j;\n      dfs(i + 1);\n      used[j] = 0;\n    }\n  }\n}\n\n  \nint\nmain(int argc, char *argv[])\n{\n  scanf(\"%d\", &n);\n  x[n] = 0.0; y[n] = 0.0;\n  rep(i, n) scanf(\"%lf %lf\", &x[i + 1], &y[i + 1]);\n\n  dfs(0);\n\n  printf(\"%lf\\n\", (ans/M_PI) * 180.0);\n\n  return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<math.h>\n#include<string.h>\nint nxpt(char *s){\n  int i,l=strlen(s),max=0,f[260]={0};\n  for(l--;l+1&&max<=s[l];l--)f[max=s[l]]++;\n  if(l<0)return 0;\n  f[s[l]]++;\n  for(i=s[l]+1;f[i]==0;i++);\n  f[s[l]=i]--;\n  for(i=0;s[++l];f[s[l]=i]--){\n    while(f[i]==0)i++;\n  }\n  return 1;\n}\ndouble PI=acos(-1);\ndouble f(double a,double b,double c,double d){\n  //printf(\"%lf %lf %lf %lf\\n\",a,b,c,d);\n  double dot=(a*c+b*d)/(hypot(a,b)*hypot(c,d));\n  //printf(\"%lf\\n\",dot);\n  return acos(dot)*180.0/PI;\n}\nint main(){\n  int n,i,j,x[10],y[10];\n  double dx=1,dy=0,px=0,py=0,r,min=1e9;\n  char s[10]={};\n  scanf(\"%d\",&n);\n  for(i=0;i<n;i++)scanf(\"%d %d\",&x[i],&y[i]);\n  for(i=0;i<n;i++)s[i]=i+'0';\n  do{//printf(\"%s\\n\",s);\n    r=0;\n    dx=1;\n    dy=0;\n    px=0;\n    py=0;\n    for(i=0;i<n;i++){\n      j=s[i]-'0';\n      r+=f(dx,dy,x[j]-px,y[j]-py);//printf(\"%lf\\n\",r);\n      dx=x[j]-px;\n      dy=y[j]-py;\n      px=x[j];\n      py=y[j];\n    }\n    r+=f(dx,dy,-px,-py);\n    if(min>r)min=r;\n  }while(nxpt(s));\n  printf(\"%.10lf\\n\",min);\n  return 0;\n}\n\n"
  },
  {
    "language": "Python",
    "code": "from math import atan2, degrees\nfrom itertools import permutations\n\nN = int(input())\nXY = [list(map(int, input().split())) for _ in range(N)]\npx = py = 0\nans = float(\"inf\")\nfor t in permutations(XY):\n    a = 0\n    deg = 0\n    for x, y in t + ([0, 0],):\n        d = degrees(atan2(y-py, x-px))\n        delta = deg - d\n        if delta < 0: delta += 360\n        if delta > 180: delta = 360 - delta\n        a += delta\n\n        px, py = x, y\n        deg = d\n    ans = min(a, ans)\nprint(ans)\n\n"
  },
  {
    "language": "Python",
    "code": "#!usr/bin/env python3\nfrom collections import defaultdict,deque\nfrom heapq import heappush, heappop\nimport sys\nimport math\nimport bisect\nimport random\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef I(): return int(sys.stdin.readline())\ndef LS():return [list(x) for x in sys.stdin.readline().split()]\ndef S():\n    res = list(sys.stdin.readline())\n    if res[-1] == \"\\n\":\n        return res[:-1]\n    return res\ndef IR(n):\n    return [I() for i in range(n)]\ndef LIR(n):\n    return [LI() for i in range(n)]\ndef SR(n):\n    return [S() for i in range(n)]\ndef LSR(n):\n    return [LS() for i in range(n)]\n\nsys.setrecursionlimit(1000000)\nmod = 1000000007\n\n\ndef solve():\n    from itertools import permutations\n    def dot(a,b):\n        return sum(list(map(lambda x : x[0]*x[1], zip(a,b))))\n\n    n = I()\n    p = LIR(n)\n    ans = float(\"inf\")\n    for l in permutations(range(n),n):\n        x,y = [0,0]\n        m = 0\n        v = [1,0]\n        for i in l:\n            s,t = p[i]\n            nv = [s-x,t-y]\n            m += math.acos(dot(v,nv)/(dot(v,v)*dot(nv,nv))**0.5)\n            x,y = s,t\n            v = [nv[0],nv[1]]\n        s,t = 0,0\n        nv = [s-x,t-y]\n        m += math.acos(dot(v,nv)/(dot(v,v)*dot(nv,nv))**0.5)\n        ans = min(ans, m)\n    print(ans*180/math.pi)\n    return\n\n\nif __name__ == \"__main__\":\n    solve()\n\n"
  },
  {
    "language": "Rust",
    "code": "//https://qiita.com/tanakh/items/0ba42c7ca36cd29d0ac8\nmacro_rules! input {\n    (source = $s:expr, $($r:tt)*) => {\n        let mut iter = $s.split_whitespace();\n        input_inner!{iter, $($r)*}\n    };\n    ($($r:tt)*) => {\n        let s = {\n            use std::io::Read;\n            let mut s = String::new();\n            std::io::stdin().read_to_string(&mut s).unwrap();\n            s\n        };\n        let mut iter = s.split_whitespace();\n        input_inner!{iter, $($r)*}\n    };\n}\n\nmacro_rules! input_inner {\n    ($iter:expr) => {};\n    ($iter:expr, ) => {};\n    ($iter:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($iter, $t);\n        input_inner!{$iter $($r)*}\n    };\n}\n\nmacro_rules! read_value {\n    ($iter:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($iter, $t)),* )\n    };\n    ($iter:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($iter, $t)).collect::<Vec<_>>()\n    };\n    ($iter:expr, chars) => {\n        read_value!($iter, String).chars().collect::<Vec<char>>()\n    };\n    ($iter:expr, usize1) => {\n        read_value!($iter, usize) - 1\n    };\n    ($iter:expr, $t:ty) => {\n        $iter.next().unwrap().parse::<$t>().expect(\"Parse error\")\n    };\n}\n\n//\n\nfn eval(p: &[(i32, i32)]) -> f64 {\n    let mut ans = 0.0f64;\n    let mut now = (0i32, 0i32);\n    let mut b = 0f64;\n    for &(x, y) in p {\n        let dx = (x - now.0) as f64;\n        let dy = (y - now.1) as f64;\n        let (dx, dy) = (dx * b.cos() + dy * b.sin(), -dx * b.sin() + dy * b.cos());\n        let c = (dx / (dx * dx + dy * dy).sqrt()).acos();\n        ans += c;\n        now = (x, y);\n        if dy > 0.0 {\n            b += c;\n        } else {\n            b -= c;\n        }\n    }\n    ans\n}\n\nfn enumerate(k: usize, p: &mut [(i32, i32)]) -> f64 {\n    let n = p.len() - 1;\n    if k >= n {\n        return eval(&p);\n    }\n    let mut ans = enumerate(k + 1, p);\n    for i in (k + 1)..n {\n        p.swap(k, i);\n        let v = enumerate(k + 1, p);\n        if v < ans {\n            ans = v;\n        }\n    }\n    let v = p[k];\n    for i in (k + 1)..n {\n        p[i - 1] = p[i];\n    }\n    p[n - 1] = v;\n    ans\n}\n\nfn run() {\n    input! {\n        n: usize,\n        p: [(i32, i32); n],\n    }\n    let mut p = p;\n    p.push((0, 0));\n    let ans = enumerate(0, &mut p);\n    println!(\"{:.10}\", ans / std::f64::consts::PI * 180.0);\n}\n\nfn main() {\n    run();\n}\n\n"
  }
]