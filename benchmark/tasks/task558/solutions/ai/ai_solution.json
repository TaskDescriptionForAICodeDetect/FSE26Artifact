[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n#include <limits.h>\n\n#define MAX_STORES 100\n#define PI 3.14159265358979323846\n\ntypedef struct {\n    int x, y;\n} Point;\n\ndouble angle_between_vectors(int x1, int y1, int x2, int y2) {\n    double dot_product = x1 * x2 + y1 * y2;\n    double mag1 = sqrt(x1 * x1 + y1 * y1);\n    double mag2 = sqrt(x2 * x2 + y2 * y2);\n    double cos_angle = dot_product / (mag1 * mag2);\n    return fabs(acos(cos_angle) * 180 / PI);\n}\n\ndouble solve(Point stores[], int N) {\n    double min_rotation = INT_MAX;\n    \n    for (int initial_dir = 0; initial_dir < 360; initial_dir += 1) {\n        int curr_x = 0, curr_y = 0;\n        int curr_dx = round(cos(initial_dir * PI / 180));\n        int curr_dy = round(sin(initial_dir * PI / 180));\n        double total_rotation = 0;\n        \n        int visited[MAX_STORES] = {0};\n        int stores_visited = 0;\n        \n        while (stores_visited < N) {\n            int best_store = -1;\n            double min_angle = INT_MAX;\n            \n            for (int i = 0; i < N; i++) {\n                if (!visited[i]) {\n                    double angle = angle_between_vectors(curr_dx, curr_dy, \n                                                         stores[i].x - curr_x, \n                                                         stores[i].y - curr_y);\n                    if (angle < min_angle) {\n                        min_angle = angle;\n                        best_store = i;\n                    }\n                }\n            }\n            \n            if (best_store == -1) break;\n            \n            total_rotation += min_angle;\n            \n            curr_dx = stores[best_store].x - curr_x;\n            curr_dy = stores[best_store].y - curr_y;\n            \n            curr_x = stores[best_store].x;\n            curr_y = stores[best_store].y;\n            \n            visited[best_store] = 1;\n            stores_visited++;\n        }\n        \n        if (stores_visited == N) {\n            double home_angle = angle_between_vectors(curr_dx, curr_dy, 1, 0);\n            total_rotation += home_angle;\n            \n            min_rotation = fmin(min_rotation, total_rotation);\n        }\n    }\n    \n    return min_rotation;\n}\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n    \n    Point stores[MAX_STORES];\n    for (int i = 0; i < N; i++) {\n        scanf(\"%d %d\", &stores[i].x, &stores[i].y);\n    }\n    \n    double result = solve(stores, N);\n    printf(\"%.2f\\n\", result);\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 22:07:25"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\ntypedef struct {\n    double x, y;\n} Point;\n\ndouble cross_product(Point a, Point b) {\n    return a.x * b.y - a.y * b.x;\n}\n\ndouble dot_product(Point a, Point b) {\n    return a.x * b.x + a.y * b.y;\n}\n\ndouble angle_between(Point a, Point b) {\n    double dot = dot_product(a, b);\n    double cross = cross_product(a, b);\n    double angle = atan2(cross, dot);\n    return fabs(angle);\n}\n\nint compare_angles(const void *a, const void *b) {\n    double angle_a = *((double *)a);\n    double angle_b = *((double *)b);\n    if (angle_a < angle_b) return -1;\n    if (angle_a > angle_b) return 1;\n    return 0;\n}\n\ndouble solve(int N, Point stores[]) {\n    if (N == 0) return 0.0;\n\n    double *angles = (double *)malloc(N * sizeof(double));\n    for (int i = 0; i < N; i++) {\n        angles[i] = atan2(stores[i].y, stores[i].x);\n    }\n\n    qsort(angles, N, sizeof(double), compare_angles);\n\n    double min_total_angle = 2 * M_PI;\n    for (int i = 0; i < N; i++) {\n        double total_angle = 0.0;\n        double prev_angle = 0.0;\n        for (int j = 0; j < N; j++) {\n            int idx = (i + j) % N;\n            double current_angle = angles[idx];\n            if (j == 0) {\n                total_angle += fabs(current_angle);\n            } else {\n                double diff = current_angle - prev_angle;\n                if (diff < 0) diff += 2 * M_PI;\n                total_angle += diff;\n            }\n            prev_angle = current_angle;\n        }\n        total_angle += fabs(angles[i]);\n        if (total_angle < min_total_angle) {\n            min_total_angle = total_angle;\n        }\n    }\n\n    free(angles);\n    return min_total_angle;\n}\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n    Point *stores = (Point *)malloc(N * sizeof(Point));\n    for (int i = 0; i < N; i++) {\n        scanf(\"%lf %lf\", &stores[i].x, &stores[i].y);\n    }\n    printf(\"%.10f\\n\", solve(N, stores));\n    free(stores);\n    return 0;\n}",
    "timestamp": "2025-08-05 22:07:48"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n\nusing namespace std;\n\nconst double PI = 3.14159265358979323846;\n\nstruct Point {\n    double x, y;\n    Point(double x = 0, double y = 0) : x(x), y(y) {}\n    double angle() const {\n        double ang = atan2(y, x) * 180.0 / PI;\n        if (ang < 0) ang += 360.0;\n        return ang;\n    }\n};\n\ndouble calculate_min_angle(const vector<Point>& points) {\n    if (points.empty()) return 0.0;\n\n    vector<double> angles;\n    for (const auto& p : points) {\n        angles.push_back(p.angle());\n    }\n    sort(angles.begin(), angles.end());\n\n    int n = angles.size();\n    double min_total = 360.0;\n    for (int i = 0; i < n; ++i) {\n        double start = angles[i];\n        double end = angles[(i + 1) % n];\n        double diff;\n        if (i < n - 1) {\n            diff = end - start;\n        } else {\n            diff = (360.0 - end) + start;\n        }\n        double total = 360.0 - diff;\n        if (total < min_total) {\n            min_total = total;\n        }\n    }\n\n    return min_total;\n}\n\nint main() {\n    int N;\n    cin >> N;\n    vector<Point> stores(N);\n    for (int i = 0; i < N; ++i) {\n        cin >> stores[i].x >> stores[i].y;\n    }\n\n    double min_angle = calculate_min_angle(stores);\n    cout << min_angle << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-05 22:08:08"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int N = scanner.nextInt();\n        List<Point> points = new ArrayList<>();\n        points.add(new Point(0, 0)); // Home is the first point\n        for (int i = 0; i < N; i++) {\n            int x = scanner.nextInt();\n            int y = scanner.nextInt();\n            points.add(new Point(x, y));\n        }\n        points.add(new Point(0, 0)); // Return home is the last point\n\n        int size = points.size();\n        double[][] dp = new double[size][360];\n        for (double[] row : dp) {\n            Arrays.fill(row, Double.MAX_VALUE);\n        }\n        dp[0][0] = 0; // Starting at home with 0 degrees rotation\n\n        for (int i = 1; i < size; i++) {\n            Point current = points.get(i);\n            Point prev = points.get(i - 1);\n            double dx = current.x - prev.x;\n            double dy = current.y - prev.y;\n            double requiredAngle = Math.toDegrees(Math.atan2(dy, dx));\n            requiredAngle = (requiredAngle + 360) % 360;\n\n            for (int prevAngle = 0; prevAngle < 360; prevAngle++) {\n                if (dp[i - 1][prevAngle] == Double.MAX_VALUE) continue;\n                double diff = Math.abs(requiredAngle - prevAngle);\n                double rotation = Math.min(diff, 360 - diff);\n                double totalRotation = dp[i - 1][prevAngle] + rotation;\n                int roundedAngle = (int) Math.round(requiredAngle) % 360;\n                if (totalRotation < dp[i][roundedAngle]) {\n                    dp[i][roundedAngle] = totalRotation;\n                }\n            }\n        }\n\n        double minRotation = Double.MAX_VALUE;\n        for (double rotation : dp[size - 1]) {\n            if (rotation < minRotation) {\n                minRotation = rotation;\n            }\n        }\n        System.out.println(minRotation);\n    }\n\n    static class Point {\n        double x, y;\n\n        Point(double x, double y) {\n            this.x = x;\n            this.y = y;\n        }\n    }\n}",
    "timestamp": "2025-08-05 22:08:34"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class SatakeShopping {\n    static class Point {\n        long x, y;\n        Point(long x, long y) {\n            this.x = x;\n            this.y = y;\n        }\n    }\n\n    static long calculateAngle(Point from, Point to) {\n        long dx = to.x - from.x;\n        long dy = to.y - from.y;\n        return (long) (Math.atan2(dy, dx) * 180 / Math.PI + 360) % 360;\n    }\n\n    static long minimumRotation(Point[] stores) {\n        int n = stores.length;\n        long[][] dp = new long[1 << n][n];\n        for (long[] row : dp) Arrays.fill(row, Long.MAX_VALUE / 2);\n\n        for (int i = 0; i < n; i++) {\n            dp[1 << i][i] = calculateAngle(new Point(0, 0), stores[i]);\n        }\n\n        for (int mask = 1; mask < (1 << n); mask++) {\n            for (int last = 0; last < n; last++) {\n                if ((mask & (1 << last)) == 0) continue;\n                for (int next = 0; next < n; next++) {\n                    if (last == next || (mask & (1 << next)) == 0) continue;\n                    long rotation = Math.abs(calculateAngle(stores[last], stores[next]));\n                    dp[mask][next] = Math.min(dp[mask][next], \n                        dp[mask ^ (1 << next)][last] + rotation);\n                }\n            }\n        }\n\n        long minRotation = Long.MAX_VALUE;\n        for (int last = 0; last < n; last++) {\n            minRotation = Math.min(minRotation, \n                dp[(1 << n) - 1][last] + calculateAngle(stores[last], new Point(0, 0)));\n        }\n\n        return minRotation;\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        Point[] stores = new Point[n];\n        \n        for (int i = 0; i < n; i++) {\n            stores[i] = new Point(scanner.nextLong(), scanner.nextLong());\n        }\n        \n        System.out.println(minimumRotation(stores));\n        scanner.close();\n    }\n}",
    "timestamp": "2025-08-05 22:08:43"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <limits>\n#include <iomanip>\n\nusing namespace std;\n\nconst double EPS = 1e-9;\nconst double PI = acos(-1.0);\n\nstruct Point {\n    double x, y;\n    Point(double x = 0, double y = 0) : x(x), y(y) {}\n    \n    double length() const {\n        return sqrt(x * x + y * y);\n    }\n    \n    Point normalize() const {\n        double len = length();\n        return Point(x / len, y / len);\n    }\n};\n\ndouble dot(const Point& a, const Point& b) {\n    return a.x * b.x + a.y * b.y;\n}\n\ndouble cross(const Point& a, const Point& b) {\n    return a.x * b.y - a.y * b.x;\n}\n\ndouble angle(const Point& a, const Point& b) {\n    double cosTheta = dot(a, b) / (a.length() * b.length());\n    cosTheta = max(-1.0, min(1.0, cosTheta));\n    double theta = acos(cosTheta);\n    double sign = cross(a, b) >= 0 ? 1.0 : -1.0;\n    return sign * theta * 180.0 / PI;\n}\n\ndouble solve(vector<Point>& stores) {\n    int n = stores.size();\n    vector<vector<double>> dp(1 << n, vector<double>(n, numeric_limits<double>::max()));\n    vector<vector<int>> prev(1 << n, vector<int>(n, -1));\n    \n    Point initial(1, 0);\n    \n    for (int i = 0; i < n; ++i) {\n        Point diff = stores[i];\n        double rot = angle(initial, diff);\n        dp[1 << i][i] = abs(rot);\n    }\n    \n    for (int mask = 1; mask < (1 << n); ++mask) {\n        for (int i = 0; i < n; ++i) {\n            if (!(mask & (1 << i))) continue;\n            \n            for (int j = 0; j < n; ++j) {\n                if (i == j || !(mask & (1 << j))) continue;\n                \n                int prevMask = mask ^ (1 << i);\n                Point from = stores[j];\n                Point to = stores[i];\n                double rot = angle(from, to);\n                \n                double candidate = dp[prevMask][j] + abs(rot);\n                if (candidate < dp[mask][i]) {\n                    dp[mask][i] = candidate;\n                    prev[mask][i] = j;\n                }\n            }\n        }\n    }\n    \n    double minRot = numeric_limits<double>::max();\n    int finalMask = (1 << n) - 1;\n    \n    for (int i = 0; i < n; ++i) {\n        Point from = stores[i];\n        Point to(1, 0);\n        double finalRot = angle(from, to);\n        double candidate = dp[finalMask][i] + abs(finalRot);\n        minRot = min(minRot, candidate);\n    }\n    \n    return minRot;\n}\n\nint main() {\n    int n;\n    cin >> n;\n    \n    vector<Point> stores(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> stores[i].x >> stores[i].y;\n    }\n    \n    cout << fixed << setprecision(9) << solve(stores) << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 22:08:55"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import math\nimport itertools\n\ndef angle_between(v1, v2):\n    # Calculate angle between two vectors\n    dot_product = v1[0] * v2[0] + v1[1] * v2[1]\n    mag_v1 = math.sqrt(v1[0]**2 + v1[1]**2)\n    mag_v2 = math.sqrt(v2[0]**2 + v2[1]**2)\n    cos_theta = dot_product / (mag_v1 * mag_v2)\n    cos_theta = min(1, max(-1, cos_theta))  # To handle any floating-point arithmetic issues\n    angle_rad = math.acos(cos_theta)\n    angle_deg = math.degrees(angle_rad)\n    return angle_deg\n\ndef minimum_total_rotation(n, stores):\n    min_angle = float('inf')\n    permutations = itertools.permutations(stores)\n    \n    for perm in permutations:\n        current_pos = (0, 0)\n        current_dir = (1, 0)\n        total_angle = 0\n        \n        for store in perm:\n            if store == current_pos:\n                continue\n            \n            # Calculate direction vector to the store\n            target_vec = (store[0] - current_pos[0], store[1] - current_pos[1])\n            \n            # Calculate rotation needed to face the store\n            angle_to_store = angle_between(current_dir, target_vec)\n            total_angle += angle_to_store\n            \n            # Move to the store\n            current_pos = store\n            current_dir = target_vec\n        \n        # Return to origin\n        target_vec = (-current_pos[0], -current_pos[1])\n        angle_to_origin = angle_between(current_dir, target_vec)\n        total_angle += angle_to_origin\n        \n        # Update the minimum angle found\n        min_angle = min(min_angle, total_angle)\n    \n    return min_angle\n\n# Example usage:\nN = 3\nstores = [(1, 0), (0, 1), (1, 1)]\nprint(minimum_total_rotation(N, stores))",
    "timestamp": "2025-08-13 09:07:14"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.Scanner;\n\npublic class SatakeShopping {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n\n        int[] x = new int[n + 1];\n        int[] y = new int[n + 1];\n        boolean[] visited = new boolean[n + 1];\n\n        for (int i = 1; i <= n; i++) {\n            x[i] = scanner.nextInt();\n            y[i] = scanner.nextInt();\n        }\n        scanner.close();\n\n        // Home is (0, 0) initially\n        x[0] = 0;\n        y[0] = 0;\n        \n        double minAngle = Double.POSITIVE_INFINITY;\n        minAngle = dfs(0, 1, n, 0, 0, x, y, visited, 0);\n        System.out.printf(\"%.9f\\n\", minAngle);\n    }\n\n    private static double dfs(int current, int depth, int n, double currentAngle, int visitedCount, int[] x, int[] y, boolean[] visited, double angle) {\n        if (depth == n + 1) {\n            double lastLeg = calculateAngle(x[current], y[current], x[0], y[0], currentAngle);\n            return angle + lastLeg;\n        }\n\n        double minAngle = Double.POSITIVE_INFINITY;\n        for (int i = 1; i <= n; i++) {\n            if (!visited[i]) {\n                visited[i] = true;\n                double newAngle = calculateAngle(x[current], y[current], x[i], y[i], currentAngle);\n                minAngle = Math.min(minAngle, dfs(i, depth + 1, n, newAngle, visitedCount + 1, x, y, visited, angle + Math.abs(newAngle - currentAngle)));\n                visited[i] = false;\n            }\n        }\n        return minAngle;\n    }\n\n    private static double calculateAngle(int x1, int y1, int x2, int y2, double previousAngle) {\n        double dx = x2 - x1;\n        double dy = y2 - y1;\n        double angle = Math.atan2(dy, dx) * (180 / Math.PI);\n        if (angle < 0) angle += 360;\n        return angle;\n    }\n}",
    "timestamp": "2025-08-13 09:07:22"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\n#define PI 3.14159265358979323846\n\ntypedef struct {\n    int x, y;\n} Store;\n\ndouble min_rotation_angle(Store stores[], int N) {\n    int visited = 0;\n    double total_angle = 0;\n    double current_angle = 0;\n    int current_x = 0, current_y = 0;\n\n    while (visited < N) {\n        int best_store_index = -1;\n        double best_angle = 360.0;\n\n        for (int i = 0; i < N; ++i) {\n            int dx = stores[i].x - current_x;\n            int dy = stores[i].y - current_y;\n\n            if (dx == 0 && dy == 0)\n                continue;\n\n            double angle_to_store = atan2(dy, dx) * 180.0 / PI;\n            while (angle_to_store < 0) angle_to_store += 360.0;\n\n            double angle_difference = fabs(angle_to_store - current_angle);\n            if (angle_difference > 180.0)\n                angle_difference = 360.0 - angle_difference;\n\n            if (angle_difference < best_angle) {\n                best_angle = angle_difference;\n                best_store_index = i;\n            }\n        }\n\n        total_angle += best_angle;\n        current_angle = atan2(stores[best_store_index].y - current_y, stores[best_store_index].x - current_x) * 180.0 / PI;\n        while (current_angle < 0) current_angle += 360.0;\n\n        current_x = stores[best_store_index].x;\n        current_y = stores[best_store_index].y;\n        visited++;\n    }\n\n    if (current_x != 0 || current_y != 0) {\n        double angle_to_home = atan2(-current_y, -current_x) * 180.0 / PI;\n        while (angle_to_home < 0) angle_to_home += 360.0;\n\n        double angle_difference = fabs(angle_to_home - current_angle);\n        if (angle_difference > 180.0)\n            angle_difference = 360.0 - angle_difference;\n        \n        total_angle += angle_difference;\n    }\n\n    return total_angle;\n}\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n    Store stores[N];\n    for (int i = 0; i < N; ++i) {\n        scanf(\"%d %d\", &stores[i].x, &stores[i].y);\n    }\n    printf(\"%.9lf\\n\", min_rotation_angle(stores, N));\n    return 0;\n}",
    "timestamp": "2025-08-13 09:07:30"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from typing import List, Tuple\nimport math\n\ndef min_rotation_angle(stores: List[Tuple[int, int]]) -> float:\n    def calc_angle(from_vec, to_vec):\n        dot = from_vec[0] * to_vec[0] + from_vec[1] * to_vec[1]\n        det = from_vec[0] * to_vec[1] - from_vec[1] * to_vec[0]\n        return abs(math.atan2(det, dot))\n\n    def solve_path(remaining_stores, current_pos, current_dir):\n        if not remaining_stores:\n            # Return home\n            home_vec = (\n                -current_pos[0],\n                -current_pos[1]\n            )\n            return calc_angle(current_dir, home_vec)\n\n        min_rotation = float('inf')\n        for i, store in enumerate(remaining_stores):\n            store_vec = (\n                store[0] - current_pos[0],\n                store[1] - current_pos[1]\n            )\n            rotation = calc_angle(current_dir, store_vec)\n            \n            new_stores = remaining_stores[:i] + remaining_stores[i+1:]\n            sub_rotation = solve_path(\n                new_stores, \n                store, \n                store_vec\n            )\n            \n            min_rotation = min(min_rotation, rotation + sub_rotation)\n\n        return min_rotation\n\n    return solve_path(stores, (0, 0), (1, 0))",
    "timestamp": "2025-08-13 09:07:59"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import math\n\ndef solve():\n    N = int(input())\n    stores = []\n    for _ in range(N):\n        x, y = map(int, input().split())\n        stores.append((x, y))\n    \n    # The home is at (0, 0)\n    points = [(0, 0)] + stores\n    \n    # Precompute the direction vectors from each point to others\n    directions = []\n    for i in range(len(points)):\n        x1, y1 = points[i]\n        dirs = []\n        for j in range(len(points)):\n            if i == j:\n                continue\n            x2, y2 = points[j]\n            dx = x2 - x1\n            dy = y2 - y1\n            angle = math.atan2(dy, dx)\n            dirs.append(angle)\n        directions.append(dirs)\n    \n    # DP[mask][last] = (min_angle, current_angle)\n    # mask is a bitmask representing visited stores\n    # last is the index of the last visited point (0 is home)\n    INF = float('inf')\n    dp = [[(INF, 0.0) for _ in range(len(points))] for _ in range(1 << len(points))]\n    \n    # Initial state: at home (0), mask 1 (only home visited), angle 0 (facing (1,0))\n    dp[1][0] = (0.0, 0.0)\n    \n    for mask in range(1 << len(points)):\n        for last in range(len(points)):\n            current_min, current_angle = dp[mask][last]\n            if current_min == INF:\n                continue\n            # Try to visit all unvisited points\n            for next_point in range(len(points)):\n                if mask & (1 << next_point):\n                    continue\n                # Compute the angle between current_angle and the direction to next_point\n                dx = points[next_point][0] - points[last][0]\n                dy = points[next_point][1] - points[last][1]\n                target_angle = math.atan2(dy, dx)\n                delta = target_angle - current_angle\n                # Normalize delta to [-pi, pi]\n                delta = (delta + math.pi) % (2 * math.pi) - math.pi\n                abs_delta = abs(delta)\n                new_min = current_min + abs_delta\n                new_mask = mask | (1 << next_point)\n                new_angle = target_angle\n                if new_min < dp[new_mask][next_point][0]:\n                    dp[new_mask][next_point] = (new_min, new_angle)\n    \n    # After visiting all stores, return to home (point 0)\n    full_mask = (1 << len(points)) - 1\n    min_total = INF\n    for last in range(1, len(points)):\n        current_min, current_angle = dp[full_mask ^ 1][last]\n        if current_min == INF:\n            continue\n        # Compute angle from last point back to home\n        dx = 0 - points[last][0]\n        dy = 0 - points[last][1]\n        target_angle = math.atan2(dy, dx)\n        delta = target_angle - current_angle\n        delta = (delta + math.pi) % (2 * math.pi) - math.pi\n        abs_delta = abs(delta)\n        total = current_min + abs_delta\n        if total < min_total:\n            min_total = total\n    \n    print(\"{0:.10f}\".format(min_total))\n\nsolve()",
    "timestamp": "2025-08-13 09:08:27"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\nusing namespace std;\n\nstruct Point {\n    int x, y;\n    Point(int x=0, int y=0): x(x), y(y) {}\n};\n\n// Function to calculate the angle between two points with respect to the origin\ndouble calculateAngle(Point& a, Point& b) {\n    return atan2(b.y - a.y, b.x - a.x);\n}\n\n// Helper function to calculate the smallest angle of rotation required\ndouble mod(double x, double y) {\n    return x - y * floor(x / y);\n}\n\n// Function to calculate the minimum angle rotation\ndouble minRotation(vector<Point>& stores) {\n    int n = stores.size();\n    vector<double> angles;\n    \n    // Calculate angles of each store from origin\n    for (int i = 0; i < n; ++i) {\n        angles.push_back(calculateAngle(Point(0, 0), stores[i]));\n    }\n    \n    // Sort the angles\n    sort(angles.begin(), angles.end());\n    \n    // Calculate the angle differences\n    double min_rotation = 2 * M_PI; // Start with a max possible value (full rotation)\n    for (int i = 1; i < n; ++i) {\n        min_rotation = min(min_rotation, angles[i] - angles[i-1]);\n    }\n    \n    // Consider the circular difference\n    min_rotation = min(min_rotation, 2 * M_PI - angles[n-1] + angles[0]);\n\n    // Return total rotation in degrees\n    return min_rotation * 180.0 / M_PI;\n}\n\nint main() {\n    int n;\n    cin >> n;\n    vector<Point> stores(n);\n    \n    for (int i = 0; i < n; ++i) {\n        cin >> stores[i].x >> stores[i].y;\n    }\n\n    cout << fixed << minRotation(stores) << endl;\n    return 0;\n}",
    "timestamp": "2025-08-13 11:49:42"
  }
]