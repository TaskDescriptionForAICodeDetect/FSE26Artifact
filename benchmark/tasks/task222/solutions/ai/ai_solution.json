[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n\n#define MAX_CITIES 100\n#define MAX_SPEED 100\n\ntypedef struct {\n    int to;\n    int distance;\n    int speed_limit;\n} Road;\n\ntypedef struct {\n    Road roads[MAX_CITIES];\n    int count;\n} City;\n\nCity cities[MAX_CITIES];\nint min_time[MAX_CITIES][MAX_SPEED + 1];\n\ntypedef struct {\n    int city;\n    int speed;\n    int time;\n} State;\n\nState heap[MAX_CITIES * (MAX_SPEED + 1)];\nint heap_size;\n\nvoid heap_push(State s) {\n    int i = heap_size++;\n    while (i > 0) {\n        int p = (i - 1) / 2;\n        if (heap[p].time <= s.time) break;\n        heap[i] = heap[p];\n        i = p;\n    }\n    heap[i] = s;\n}\n\nState heap_pop() {\n    State ret = heap[0];\n    State x = heap[--heap_size];\n    int i = 0;\n    while (i * 2 + 1 < heap_size) {\n        int a = i * 2 + 1, b = i * 2 + 2;\n        if (b < heap_size && heap[b].time < heap[a].time) a = b;\n        if (heap[a].time >= x.time) break;\n        heap[i] = heap[a];\n        i = a;\n    }\n    heap[i] = x;\n    return ret;\n}\n\nvoid dijkstra(int start, int goal, int n) {\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j <= MAX_SPEED; j++) {\n            min_time[i][j] = INT_MAX;\n        }\n    }\n    heap_size = 0;\n    min_time[start][1] = 0;\n    heap_push((State){start, 1, 0});\n\n    while (heap_size > 0) {\n        State current = heap_pop();\n        if (current.city == goal) {\n            printf(\"%d\\n\", current.time);\n            return;\n        }\n        if (current.time > min_time[current.city][current.speed]) continue;\n\n        for (int i = 0; i < cities[current.city].count; i++) {\n            Road road = cities[current.city].roads[i];\n            if (current.speed > road.speed_limit) continue;\n            int to = road.to;\n            int time = current.time + road.distance / current.speed;\n            if (time < min_time[to][current.speed]) {\n                min_time[to][current.speed] = time;\n                heap_push((State){to, current.speed, time});\n            }\n        }\n\n        if (current.speed > 1) {\n            int new_speed = current.speed - 1;\n            if (current.time < min_time[current.city][new_speed]) {\n                min_time[current.city][new_speed] = current.time;\n                heap_push((State){current.city, new_speed, current.time});\n            }\n        }\n        if (current.speed < MAX_SPEED) {\n            int new_speed = current.speed + 1;\n            if (current.time < min_time[current.city][new_speed]) {\n                min_time[current.city][new_speed] = current.time;\n                heap_push((State){current.city, new_speed, current.time});\n            }\n        }\n    }\n    printf(\"unreachable\\n\");\n}\n\nint main() {\n    int n, m;\n    while (scanf(\"%d %d\", &n, &m) == 2) {\n        for (int i = 0; i < n; i++) {\n            cities[i].count = 0;\n        }\n        int start, goal;\n        scanf(\"%d %d\", &start, &goal);\n        start--; goal--;\n\n        for (int i = 0; i < m; i++) {\n            int x, y, d, c;\n            scanf(\"%d %d %d %d\", &x, &y, &d, &c);\n            x--; y--;\n            cities[x].roads[cities[x].count] = (Road){y, d, c};\n            cities[x].count++;\n            cities[y].roads[cities[y].count] = (Road){x, d, c};\n            cities[y].count++;\n        }\n\n        dijkstra(start, goal, n);\n    }\n    return 0;\n}",
    "timestamp": "2025-08-05 19:08:59"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class CarTrip {\n    static class City {\n        int id;\n        List<Road> roads = new ArrayList<>();\n        \n        City(int id) {\n            this.id = id;\n        }\n    }\n    \n    static class Road {\n        City dest;\n        int distance;\n        int speedLimit;\n        \n        Road(City dest, int distance, int speedLimit) {\n            this.dest = dest;\n            this.distance = distance;\n            this.speedLimit = speedLimit;\n        }\n    }\n    \n    static class State implements Comparable<State> {\n        City city;\n        int speed;\n        double time;\n        \n        State(City city, int speed, double time) {\n            this.city = city;\n            this.speed = speed;\n            this.time = time;\n        }\n        \n        @Override\n        public int compareTo(State other) {\n            return Double.compare(this.time, other.time);\n        }\n    }\n    \n    public static String findShortestTime(int n, List<City> cities, City start, City goal) {\n        PriorityQueue<State> pq = new PriorityQueue<>();\n        Map<String, Double> visited = new HashMap<>();\n        \n        pq.offer(new State(start, 0, 0));\n        \n        while (!pq.isEmpty()) {\n            State current = pq.poll();\n            \n            String key = current.city.id + \",\" + current.speed;\n            if (visited.containsKey(key) && visited.get(key) <= current.time) {\n                continue;\n            }\n            visited.put(key, current.time);\n            \n            if (current.city == goal) {\n                return String.format(\"%.6f\", current.time);\n            }\n            \n            for (Road road : current.city.roads) {\n                for (int newSpeed = Math.max(1, current.speed - 1); \n                     newSpeed <= Math.min(road.speedLimit, current.speed + 1); \n                     newSpeed++) {\n                    \n                    double travelTime = (double) road.distance / newSpeed;\n                    State nextState = new State(road.dest, newSpeed, current.time + travelTime);\n                    \n                    String nextKey = road.dest.id + \",\" + newSpeed;\n                    if (!visited.containsKey(nextKey) || \n                        visited.get(nextKey) > nextState.time) {\n                        pq.offer(nextState);\n                    }\n                }\n            }\n        }\n        \n        return \"unreachable\";\n    }\n    \n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        \n        while (scanner.hasNext()) {\n            int n = scanner.nextInt();\n            if (n == 0) break;\n            \n            List<City> cities = new ArrayList<>();\n            for (int i = 0; i < n; i++) {\n                cities.add(new City(i));\n            }\n            \n            int m = scanner.nextInt();\n            for (int i = 0; i < m; i++) {\n                int u = scanner.nextInt();\n                int v = scanner.nextInt();\n                int distance = scanner.nextInt();\n                int speedLimit = scanner.nextInt();\n                \n                cities.get(u).roads.add(new Road(cities.get(v), distance, speedLimit));\n                cities.get(v).roads.add(new Road(cities.get(u), distance, speedLimit));\n            }\n            \n            int start = scanner.nextInt();\n            int goal = scanner.nextInt();\n            \n            String result = findShortestTime(n, cities, cities.get(start), cities.get(goal));\n            System.out.println(result);\n        }\n        \n        scanner.close();\n    }\n}",
    "timestamp": "2025-08-05 19:09:12"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <climits>\n#include <algorithm>\n\nusing namespace std;\n\nstruct Road {\n    int to, length, max_speed;\n};\n\nstruct State {\n    int city, speed;\n    int time;\n    bool operator>(const State& other) const {\n        return time > other.time;\n    }\n};\n\nint main() {\n    int N, M;\n    while (cin >> N >> M, N != 0 || M != 0) {\n        int S, G;\n        cin >> S >> G;\n        S--; G--;\n\n        vector<vector<Road>> roads(N);\n        for (int i = 0; i < M; ++i) {\n            int x, y, d, c;\n            cin >> x >> y >> d >> c;\n            x--; y--;\n            roads[x].push_back({y, d, c});\n            roads[y].push_back({x, d, c});\n        }\n\n        const int MAX_SPEED = 100;\n        vector<vector<int>> dist(N, vector<int>(MAX_SPEED + 1, INT_MAX));\n        priority_queue<State, vector<State>, greater<State>> pq;\n\n        dist[S][0] = 0;\n        pq.push({S, 0, 0});\n\n        int result = -1;\n        while (!pq.empty()) {\n            State current = pq.top();\n            pq.pop();\n\n            if (current.city == G && current.speed == 1) {\n                result = current.time;\n                break;\n            }\n\n            if (current.time > dist[current.city][current.speed]) {\n                continue;\n            }\n\n            for (const Road& road : roads[current.city]) {\n                for (int delta = -1; delta <= 1; ++delta) {\n                    int new_speed = current.speed + delta;\n                    if (new_speed < 1 || new_speed > road.max_speed) {\n                        continue;\n                    }\n\n                    int new_time = current.time + road.length / new_speed;\n                    if (new_time < dist[road.to][new_speed]) {\n                        dist[road.to][new_speed] = new_time;\n                        pq.push({road.to, new_speed, new_time});\n                    }\n                }\n            }\n        }\n\n        if (result == -1) {\n            cout << \"unreachable\" << endl;\n        } else {\n            cout << result << endl;\n        }\n    }\n    return 0;\n}",
    "timestamp": "2025-08-05 19:09:38"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <limits.h>\n\n#define MAX_CITIES 500\n#define MAX_ROADS 5000\n\ntypedef struct {\n    int dest;\n    int length;\n    int max_speed;\n} Road;\n\ntypedef struct {\n    int speed;\n    double time;\n} State;\n\nRoad roads[MAX_ROADS];\nint road_count;\nint city_count;\nint start, goal;\nState graph[MAX_CITIES][101];  // max speed 100\n\nvoid solve_dataset() {\n    for (int i = 0; i < city_count; i++) {\n        for (int j = 0; j <= 100; j++) {\n            graph[i][j].time = INFINITY;\n        }\n    }\n    \n    graph[start][0].time = 0;\n    \n    int updated;\n    for (int iter = 0; iter < city_count; iter++) {\n        updated = 0;\n        for (int road = 0; road < road_count; road++) {\n            int from = roads[road].dest;\n            int to = roads[road].dest;\n            int road_length = roads[road].length;\n            int max_road_speed = roads[road].max_speed;\n            \n            for (int curr_speed = 0; curr_speed <= 100; curr_speed++) {\n                if (graph[from][curr_speed].time == INFINITY) continue;\n                \n                for (int next_speed = curr_speed - 1; next_speed <= curr_speed + 1; next_speed++) {\n                    if (next_speed < 0 || next_speed > max_road_speed) continue;\n                    \n                    double travel_time = (double)road_length / next_speed;\n                    double new_time = graph[from][curr_speed].time + travel_time;\n                    \n                    if (new_time < graph[to][next_speed].time) {\n                        graph[to][next_speed].time = new_time;\n                        graph[to][next_speed].speed = next_speed;\n                        updated = 1;\n                    }\n                }\n            }\n        }\n        \n        if (!updated) break;\n    }\n    \n    double min_time = INFINITY;\n    for (int speed = 0; speed <= 100; speed++) {\n        min_time = fmin(min_time, graph[goal][speed].time);\n    }\n    \n    if (min_time == INFINITY) {\n        printf(\"unreachable\\n\");\n    } else {\n        printf(\"%.6f\\n\", min_time);\n    }\n}\n\nint main() {\n    int datasets;\n    scanf(\"%d\", &datasets);\n    \n    while (datasets--) {\n        scanf(\"%d %d %d %d\", &city_count, &road_count, &start, &goal);\n        \n        for (int i = 0; i < road_count; i++) {\n            int u, v, length, max_speed;\n            scanf(\"%d %d %d %d\", &u, &v, &length, &max_speed);\n            roads[i].dest = v;\n            roads[i].length = length;\n            roads[i].max_speed = max_speed;\n        }\n        \n        solve_dataset();\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 19:09:49"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <limits>\n#include <cmath>\n\nusing namespace std;\n\nconst int MAX_CITIES = 1000;\nconst double INF = numeric_limits<double>::infinity();\n\nstruct Road {\n    int dest;\n    double length;\n    int max_speed;\n};\n\nstruct State {\n    int city;\n    double time;\n    int speed;\n    \n    bool operator>(const State& other) const {\n        return time > other.time;\n    }\n};\n\ndouble solve_dataset() {\n    int n, m, start, goal;\n    cin >> n >> m >> start >> goal;\n    \n    vector<vector<Road>> graph(n + 1);\n    vector<bool> has_accel(n + 1, false);\n    \n    for (int i = 0; i < m; ++i) {\n        int u, v, length, max_speed;\n        cin >> u >> v >> length >> max_speed;\n        graph[u].push_back({v, (double)length, max_speed});\n        graph[v].push_back({u, (double)length, max_speed});\n    }\n    \n    int k;\n    cin >> k;\n    for (int i = 0; i < k; ++i) {\n        int city;\n        cin >> city;\n        has_accel[city] = true;\n    }\n    \n    vector<vector<double>> dist(n + 1, vector<double>(101, INF));\n    priority_queue<State, vector<State>, greater<State>> pq;\n    \n    pq.push({start, 0, 0});\n    dist[start][0] = 0;\n    \n    while (!pq.empty()) {\n        State current = pq.top();\n        pq.pop();\n        \n        if (current.city == goal) \n            return current.time;\n        \n        if (current.time > dist[current.city][current.speed])\n            continue;\n        \n        for (const Road& road : graph[current.city]) {\n            double road_time = road.length / min((double)road.max_speed, (double)current.speed);\n            double new_time = current.time + road_time;\n            \n            // No change in speed\n            if (current.speed <= road.max_speed && \n                new_time < dist[road.dest][current.speed]) {\n                dist[road.dest][current.speed] = new_time;\n                pq.push({road.dest, new_time, current.speed});\n            }\n            \n            // Acceleration possible\n            if (has_accel[current.city]) {\n                // Speed up\n                if (current.speed < 100) {\n                    int new_speed = current.speed + 1;\n                    if (new_speed <= road.max_speed && \n                        new_time < dist[road.dest][new_speed]) {\n                        dist[road.dest][new_speed] = new_time;\n                        pq.push({road.dest, new_time, new_speed});\n                    }\n                }\n                \n                // Slow down\n                if (current.speed > 0) {\n                    int new_speed = current.speed - 1;\n                    if (new_speed <= road.max_speed && \n                        new_time < dist[road.dest][new_speed]) {\n                        dist[road.dest][new_speed] = new_time;\n                        pq.push({road.dest, new_time, new_speed});\n                    }\n                }\n            }\n        }\n    }\n    \n    return -1;\n}\n\nint main() {\n    int t;\n    cin >> t;\n    \n    for (int i = 0; i < t; ++i) {\n        double result = solve_dataset();\n        if (result == -1)\n            cout << \"unreachable\" << endl;\n        else\n            printf(\"%.10f\\n\", result);\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 19:10:01"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main {\n    static class Road {\n        int to, length, maxSpeed;\n        Road(int to, int length, int maxSpeed) {\n            this.to = to;\n            this.length = length;\n            this.maxSpeed = maxSpeed;\n        }\n    }\n\n    static class State implements Comparable<State> {\n        int city, speed;\n        long time;\n        State(int city, int speed, long time) {\n            this.city = city;\n            this.speed = speed;\n            this.time = time;\n        }\n        public int compareTo(State other) {\n            return Long.compare(this.time, other.time);\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        while (sc.hasNext()) {\n            int N = sc.nextInt();\n            int M = sc.nextInt();\n            if (N == 0 && M == 0) break;\n            int S = sc.nextInt();\n            int G = sc.nextInt();\n            List<List<Road>> adj = new ArrayList<>();\n            for (int i = 0; i <= N; i++) {\n                adj.add(new ArrayList<>());\n            }\n            for (int i = 0; i < M; i++) {\n                int x = sc.nextInt();\n                int y = sc.nextInt();\n                int d = sc.nextInt();\n                int c = sc.nextInt();\n                adj.get(x).add(new Road(y, d, c));\n                adj.get(y).add(new Road(x, d, c));\n            }\n\n            long[][][] dist = new long[N + 1][201][2];\n            for (int i = 0; i <= N; i++) {\n                for (int j = 0; j <= 200; j++) {\n                    Arrays.fill(dist[i][j], Long.MAX_VALUE);\n                }\n            }\n            PriorityQueue<State> pq = new PriorityQueue<>();\n            dist[S][0][0] = 0;\n            pq.add(new State(S, 0, 0));\n\n            long result = -1;\n            while (!pq.isEmpty()) {\n                State current = pq.poll();\n                if (current.city == G && current.speed == 1) {\n                    result = current.time;\n                    break;\n                }\n                if (dist[current.city][current.speed][0] < current.time) continue;\n                for (Road road : adj.get(current.city)) {\n                    for (int delta = -1; delta <= 1; delta++) {\n                        int newSpeed = current.speed + delta;\n                        if (newSpeed <= 0 || newSpeed > road.maxSpeed) continue;\n                        long newTime = current.time + (long) road.length * 100 / newSpeed;\n                        if (dist[road.to][newSpeed][0] > newTime) {\n                            dist[road.to][newSpeed][0] = newTime;\n                            pq.add(new State(road.to, newSpeed, newTime));\n                        }\n                    }\n                }\n            }\n            System.out.println(result == -1 ? \"unreachable\" : result);\n        }\n        sc.close();\n    }\n}",
    "timestamp": "2025-08-05 19:10:27"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from collections import deque\nimport sys\nimport heapq\n\ndef shortest_time_to_travel(datasets):\n    results = []\n    \n    for data in datasets:\n        num_cities, num_roads, roads, start_city, goal_city = data\n        adjacency_list = {i: [] for i in range(num_cities)}\n        \n        for road in roads:\n            city_a, city_b, speed_limit = road\n            adjacency_list[city_a].append((city_b, speed_limit))\n            adjacency_list[city_b].append((city_a, speed_limit))\n        \n        min_time = [[float('inf')] * (num_cities + 1) for _ in range(num_cities)]\n        min_time[start_city][0] = 0\n        priority_queue = [(0, start_city, 0)]\n        \n        reachable = False\n        while priority_queue:\n            curr_time, curr_city, curr_speed = heapq.heappop(priority_queue)\n            \n            if curr_city == goal_city:\n                results.append(curr_time)\n                reachable = True\n                break\n\n            if curr_time > min_time[curr_city][curr_speed]:\n                continue\n\n            for neighbor, speed_limit in adjacency_list[curr_city]:\n                for speed_change in (-1, 0, 1):\n                    new_speed = curr_speed + speed_change\n                    if 0 <= new_speed <= speed_limit:\n                        travel_time = curr_time + 1 if new_speed > 0 else float('inf')\n                        if travel_time < min_time[neighbor][new_speed]:\n                            min_time[neighbor][new_speed] = travel_time\n                            heapq.heappush(priority_queue, (travel_time, neighbor, new_speed))\n        \n        if not reachable:\n            results.append(\"unreachable\")\n    \n    return results\n\n# Example usage:\n# datasets = [\n#     (5, 4, [(0, 1, 5), (1, 2, 10), (2, 3, 8), (3, 4, 5)], 0, 4),\n#     (3, 2, [(0, 1, 10), (1, 2, 10)], 0, 2)\n# ]\n# print(shortest_time_to_travel(datasets))",
    "timestamp": "2025-08-13 02:47:56"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class CarTrip {\n    static class Edge {\n        int city;\n        int distance;\n        int speedLimit;\n        boolean hasDevice;\n\n        public Edge(int city, int distance, int speedLimit, boolean hasDevice) {\n            this.city = city;\n            this.distance = distance;\n            this.speedLimit = speedLimit;\n            this.hasDevice = hasDevice;\n        }\n    }\n\n    static class State implements Comparable<State> {\n        int city;\n        int speed;\n        int time;\n\n        public State(int city, int speed, int time) {\n            this.city = city;\n            this.speed = speed;\n            this.time = time;\n        }\n\n        @Override\n        public int compareTo(State other) {\n            return Integer.compare(this.time, other.time);\n        }\n    }\n    \n    public static int findShortestTime(List<List<Edge>> graph, int start, int goal) {\n        int n = graph.size();\n        int[][] minTime = new int[n][101];\n        for (int i = 0; i < n; i++) {\n            Arrays.fill(minTime[i], Integer.MAX_VALUE);\n        }\n        PriorityQueue<State> pq = new PriorityQueue<>();\n        pq.offer(new State(start, 0, 0));\n        minTime[start][0] = 0;\n\n        while (!pq.isEmpty()) {\n            State current = pq.poll();\n\n            if (current.city == goal) {\n                return current.time;\n            }\n\n            if (current.time > minTime[current.city][current.speed]) {\n                continue;\n            }\n\n            for (Edge edge : graph.get(current.city)) {\n                for (int delta = -1; delta <= 1; delta++) {\n                    if (delta != 0 && !edge.hasDevice) {\n                        continue;\n                    }\n                    int newSpeed = current.speed + delta;\n                    if (newSpeed <= 0 || newSpeed > edge.speedLimit) {\n                        continue;\n                    }\n                    int newTime = current.time + edge.distance / newSpeed;\n                    if (newTime < minTime[edge.city][newSpeed]) {\n                        minTime[edge.city][newSpeed] = newTime;\n                        pq.offer(new State(edge.city, newSpeed, newTime));\n                    }\n                }\n            }\n        }\n\n        return Integer.MAX_VALUE;\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        while (scanner.hasNext()) {\n            int cityCount = scanner.nextInt();\n            int roadCount = scanner.nextInt();\n            int startCity = scanner.nextInt();\n            int goalCity = scanner.nextInt();\n\n            List<List<Edge>> graph = new ArrayList<>();\n            for (int i = 0; i < cityCount; i++) {\n                graph.add(new ArrayList<>());\n            }\n\n            for (int i = 0; i < roadCount; i++) {\n                int u = scanner.nextInt();\n                int v = scanner.nextInt();\n                int distance = scanner.nextInt();\n                int speedLimit = scanner.nextInt();\n                boolean hasDevice = scanner.nextInt() == 1;\n\n                graph.get(u).add(new Edge(v, distance, speedLimit, hasDevice));\n            }\n\n            int result = findShortestTime(graph, startCity, goalCity);\n            if (result == Integer.MAX_VALUE) {\n                System.out.println(\"unreachable\");\n            } else {\n                System.out.println(result);\n            }\n        }\n        scanner.close();\n    }\n}",
    "timestamp": "2025-08-13 02:48:07"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n\n#define MAX_CITIES 100\n#define INF INT_MAX\n\ntypedef struct {\n    int city;\n    int time;\n    int speed;\n} State;\n\ntypedef struct {\n    int to;\n    int length;\n    int maxSpeed;\n} Road;\n\ntypedef struct Node {\n    State state;\n    struct Node *next;\n} Node;\n\ntypedef struct {\n    Node *front;\n    Node *rear;\n    int size;\n} Queue;\n\nvoid initQueue(Queue *queue) {\n    queue->front = queue->rear = NULL;\n    queue->size = 0;\n}\n\nint isEmpty(Queue *queue) {\n    return queue->size == 0;\n}\n\nvoid enqueue(Queue *queue, State state) {\n    Node *newNode = (Node *)malloc(sizeof(Node));\n    newNode->state = state;\n    newNode->next = NULL;\n    if (isEmpty(queue)) {\n        queue->front = queue->rear = newNode;\n    } else {\n        queue->rear->next = newNode;\n        queue->rear = newNode;\n    }\n    queue->size++;\n}\n\nState dequeue(Queue *queue) {\n    if (isEmpty(queue)) {\n        State state = {-1, -1, -1};\n        return state;\n    }\n    Node *temp = queue->front;\n    State state = temp->state;\n    queue->front = queue->front->next;\n    if (!queue->front) queue->rear = NULL;\n    free(temp);\n    queue->size--;\n    return state;\n}\n\nState createState(int city, int time, int speed) {\n    State state = {city, time, speed};\n    return state;\n}\n\nvoid bfs(int n, int startCity, int goalCity, Road roads[MAX_CITIES][MAX_CITIES], int roadCount[MAX_CITIES]) {\n    int minTime[MAX_CITIES][2 * MAX_CITIES + 1];\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j <= 2 * MAX_CITIES; j++) {\n            minTime[i][j] = INF;\n        }\n    }\n\n    Queue queue;\n    initQueue(&queue);\n    enqueue(&queue, createState(startCity, 0, 1));\n    minTime[startCity][1] = 0;\n\n    while (!isEmpty(&queue)) {\n        State current = dequeue(&queue);\n        int city = current.city;\n        int time = current.time;\n        int speed = current.speed;\n\n        for (int i = 0; i < roadCount[city]; i++) {\n            Road road = roads[city][i];\n            int newCity = road.to;\n            int newTime = time + road.length / speed;\n            int maxSpeed = road.maxSpeed;\n\n            for (int newSpeed = speed - 1; newSpeed <= speed + 1; newSpeed++) {\n                if (newSpeed >= 1 && newSpeed <= maxSpeed) {\n                    if (newTime < minTime[newCity][newSpeed]) {\n                        minTime[newCity][newSpeed] = newTime;\n                        enqueue(&queue, createState(newCity, newTime, newSpeed));\n                    }\n                }\n            }\n        }\n    }\n\n    int result = INF;\n    for (int speed = 1; speed <= 2 * MAX_CITIES; speed++) {\n        if (minTime[goalCity][speed] < result) {\n            result = minTime[goalCity][speed];\n        }\n    }\n\n    if (result == INF) {\n        printf(\"unreachable\\n\");\n    } else {\n        printf(\"%d\\n\", result);\n    }\n}\n\nint main() {\n    int n, startCity, goalCity;\n\n    while (scanf(\"%d %d %d\", &n, &startCity, &goalCity) == 3) {\n        Road roads[MAX_CITIES][MAX_CITIES];\n        int roadCount[MAX_CITIES] = {0};\n\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                int length, maxSpeed;\n                if (scanf(\"%d %d\", &length, &maxSpeed) == 2 && length > 0 && maxSpeed > 0) {\n                    roads[i][roadCount[i]].to = j;\n                    roads[i][roadCount[i]].length = length;\n                    roads[i][roadCount[i]].maxSpeed = maxSpeed;\n                    roadCount[i]++;\n                }\n            }\n        }\n\n        bfs(n, startCity, goalCity, roads, roadCount);\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-13 02:48:22"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from heapq import heappush, heappop\nimport math\n\ndef solve_car_trip():\n    while True:\n        # Read number of cities and roads\n        N, M = map(int, input().split())\n        if N == 0 and M == 0:\n            break\n        \n        # Read acceleration devices\n        K = int(input())\n        accel_devices = set(map(int, input().split()))\n        \n        # Read start and goal cities\n        start, goal = map(int, input().split())\n        \n        # Create adjacency list and road information\n        graph = [[] for _ in range(N+1)]\n        roads = {}\n        \n        for _ in range(M):\n            u, v, L, S = map(int, input().split())\n            graph[u].append(v)\n            graph[v].append(u)\n            roads[(u,v)] = (L, S)\n            roads[(v,u)] = (L, S)\n        \n        # Dijkstra's algorithm with speed tracking\n        dist = {}\n        pq = []\n        heappush(pq, (0, start, 1))  # (time, city, current_speed)\n        \n        while pq:\n            time, city, speed = heappop(pq)\n            \n            if city == goal:\n                print(f\"{time:.2f}\")\n                break\n            \n            # Skip if we have a better time/speed to this city\n            key = (city, speed)\n            if key in dist and dist[key] <= time:\n                continue\n            dist[key] = time\n            \n            # Try accelerating/decelerating at acceleration devices\n            if city in accel_devices:\n                for new_speed in [speed-1, speed+1]:\n                    if new_speed <= 0:\n                        continue\n                    heappush(pq, (time, city, new_speed))\n            \n            # Try moving to neighboring cities\n            for next_city in graph[city]:\n                road_length, speed_limit = roads.get((city, next_city), (0, 0))\n                \n                # Check if current speed is within speed limit\n                if speed > speed_limit:\n                    continue\n                \n                # Calculate travel time\n                travel_time = road_length / speed\n                \n                heappush(pq, (time + travel_time, next_city, speed))\n        \n        else:\n            print(\"unreachable\")\n\n# Run the solution\nsolve_car_trip()",
    "timestamp": "2025-08-13 02:48:39"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import heapq\n\ndef solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    idx = 0\n    while True:\n        N = int(data[idx])\n        M = int(data[idx+1])\n        idx +=2\n        if N ==0 and M ==0:\n            break\n        S = int(data[idx])-1\n        G = int(data[idx+1])-1\n        idx +=2\n        \n        adj = [[] for _ in range(N)]\n        for _ in range(M):\n            x = int(data[idx])-1\n            y = int(data[idx+1])-1\n            d = int(data[idx+2])\n            c = int(data[idx+3])\n            idx +=4\n            adj[x].append((y, d, c))\n            adj[y].append((x, d, c))\n        \n        INF = float('inf')\n        # dist[city][speed] = time\n        dist = [[INF]*(31) for _ in range(N)]\n        dist[S][0] = 0\n        heap = []\n        heapq.heappush(heap, (0, S, 0))\n        \n        found = False\n        while heap:\n            current_time, u, speed_u = heapq.heappop(heap)\n            if u == G and speed_u ==1:\n                found = True\n                print(current_time)\n                break\n            if current_time > dist[u][speed_u]:\n                continue\n            for (v, d, c) in adj[u]:\n                for delta in [-1, 0, 1]:\n                    speed_v = speed_u + delta\n                    if speed_v <=0 or speed_v > c:\n                        continue\n                    time_v = current_time + d / speed_v\n                    if time_v < dist[v][speed_v]:\n                        dist[v][speed_v] = time_v\n                        heapq.heappush(heap, (time_v, v, speed_v))\n        if not found:\n            print(\"unreachable\")\n\nsolve()",
    "timestamp": "2025-08-13 02:49:00"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <limits>\n#include <unordered_map>\n#include <tuple>\n\nusing namespace std;\n\nstruct Edge {\n    int destination;\n    int speed_limit;\n    int length;\n};\n\nstruct State {\n    int city;\n    int speed;\n    int time;\n    bool operator>(const State& other) const {\n        return time > other.time;\n    }\n};\n\nint shortest_time(int n, int start, int goal, const vector<vector<Edge>>& graph) {\n    const int INF = numeric_limits<int>::max();\n    vector<vector<int>> min_time(n, vector<int>(n + 1, INF));\n    priority_queue<State, vector<State>, greater<State>> pq;\n\n    pq.push({start, 1, 0});\n    min_time[start][1] = 0;\n\n    while (!pq.empty()) {\n        State state = pq.top();\n        pq.pop();\n\n        int city = state.city;\n        int speed = state.speed;\n        int time = state.time;\n\n        if (city == goal) {\n            return time;\n        }\n\n        if (time > min_time[city][speed]) {\n            continue;\n        }\n\n        for (const Edge& edge : graph[city]) {\n            for (int accel = -1; accel <= 1; ++accel) {\n                int new_speed = speed + accel;\n                if (new_speed > 0 && new_speed <= edge.speed_limit) {\n                    int new_time = time + edge.length / new_speed;\n                    if (new_time < min_time[edge.destination][new_speed]) {\n                        min_time[edge.destination][new_speed] = new_time;\n                        pq.push({edge.destination, new_speed, new_time});\n                    }\n                }\n            }\n        }\n    }\n\n    int result = *min_element(min_time[goal].begin(), min_time[goal].end());\n    return result == INF ? -1 : result;\n}\n\nint main() {\n    int n, m, start, goal;\n    while (cin >> n >> m && n != 0) {\n        vector<vector<Edge>> graph(n);\n        \n        for (int i = 0; i < m; ++i) {\n            int u, v, l, s;\n            cin >> u >> v >> l >> s;\n            --u; // Adjusting to 0-based indexing\n            --v; // Adjusting to 0-based indexing\n            graph[u].push_back({v, s, l});\n            graph[v].push_back({u, s, l}); // Assuming bidirectional roads \n        }\n        \n        cin >> start >> goal;\n        --start; // Adjusting to 0-based indexing\n        --goal; // Adjusting to 0-based indexing\n        \n        int result = shortest_time(n, start, goal, graph);\n        if (result == -1) {\n            cout << \"unreachable\" << endl;\n        } else {\n            cout << result << endl;\n        }\n    }\n    return 0;\n}",
    "timestamp": "2025-08-13 11:07:34"
  }
]